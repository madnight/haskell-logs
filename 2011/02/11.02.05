00:05:35 <Wooga> so, can anyone help me with combining consume Iteratee and enumList Enumerator using Data.Enumerator module? 
00:05:51 <Wooga> how this would look like in ghci oneliner?
00:14:49 <loupgaroublond> hey all, did i miss some critical announcement? what happened to code.haskell.org? 
00:15:53 <Wooga>  work for me
00:15:56 <Wooga> works*
00:16:35 <geheimdienst> loupgaroublond: looks like a bunch of empty directories to me :-/
00:16:36 <loupgaroublond> so a lot of project directories are empty
00:16:39 <loupgaroublond> yeah
00:16:50 <Wooga> hm, really
00:17:03 <geheimdienst> i think they're still messing with the server or something. this has been going on for a while now
00:17:12 <loupgaroublond> oh
00:17:23 <geheimdienst> it's an unfortunate state of affairs, for sure
00:17:40 <loupgaroublond> indeed, i was hoping to see if there were any interesting updates in xmonad
00:19:14 <geheimdienst> you're right. i'm running xmonad-darcs as well and haven't updated in a while. darcs fetch doesn't work
00:19:23 <geheimdienst> dammit
00:23:06 <ksf> gah. who broke haskell98
00:23:35 <ksf> seems we're managing to break 6.12 builds while fixing for 7
00:31:46 <accel> "data Shape = Rectangle ... | Circle ... | Polygon ... " allows me to _enumerate_ all the things that a shape is. Is there a way to say define a type as "anything that supports area + perimeter typeclasses is a shape" ?
00:32:32 <ksf> I dunno, is there?
00:32:46 <ksf> that's a geometry, not haskell question.
00:32:59 <accel> it's a haskell question; i want to define a type "Shape"
00:33:05 <ksf> beziers can probably do that
00:33:05 <accel> that can store anyting that supports area + perimeter
00:33:07 <nanothief> not sure what you mean, something like class (Area s, Perimeter s) => Shape s where sideCount :: Int ?
00:33:31 <dibblego> data Shape = { area :: Int, perimeter :: Int }
00:33:48 <nanothief> or (Area s, Perimeter s) => [s]
00:34:10 <ksf> accel, the question is: what's an area, and what's a perimeter?
00:34:14 <geheimdienst> probably missing something, but have you thought about a "class Shape where area :: Int ..."?
00:34:23 * accel rethinks
00:34:29 <accel> my question waas poorly formulated, sorry
00:34:31 <dibblego> a type-class must have type variables and functions must use them
00:34:31 <geheimdienst> you don't have to enumerate all the instances at the place where the class is defined. you can declare instances in whatever module
00:34:33 <ksf> area is quite simple, but is perimeter the shape, or a number, or...?
00:37:42 <drbean> Using type classes is a way of getting round the immutability of type definitions?
00:37:58 <Wooga> is there anyone who actualy understands how iteratee from Data.Enumerator wors ?
00:38:29 <Wooga> *here *works
00:39:24 <ksf> last time I looked at enumerator it seemed strange
00:39:44 <ksf> yeah, the hardcoded list type.
00:41:09 <Wooga> how do you execute Iteratee with Enumerator if Iteratee returns, well, Iteratee and Enumerator takes Step ?
00:41:15 <ksf> otherwise it looks like a standard cps implementation
00:41:29 <Wooga> consume Iteratee with enumList enumerator for example
00:42:06 <Tau> how can i count how many times a element appears in a list ?
00:42:16 <Tau> is there some predefined func
00:42:51 <systemfault> I don't know but I guess you could use length + filter
00:42:52 <ksf> > let countOccs x = length . filter (==x) in countOccs 'a' "abbaaabaa"
00:42:53 <lambdabot>   6
00:43:11 <geheimdienst> > length $ filter (== 3) [1,3,3,1,3,1,3]
00:43:12 <lambdabot>   4
00:43:13 <ksf> Wooga, you don't so much consume iteratees as drive them.
00:43:37 <geheimdienst> systemfault: you're on the right track
00:43:43 <Wooga> ksf: i mean Iteratee named `consume'
00:43:44 * ksf recommends reading oleg's original code
00:43:51 <Tau> k
00:43:52 <ksf> ah.
00:44:39 <systemfault> :)
00:44:46 <Wooga> i just don't understand how do i glue `consume' and `enumList' together
00:46:38 <ksf> Wooga, $$
00:47:03 <ksf> beware though, I didn't actually try that, just looked at the types.
00:49:00 * ksf thinks that package is fundamentally broken.
00:49:05 <lewis1711> is a tuple contiguous in memory? or is that the kind of low level detail I shouldn't worry about? ;)
00:49:30 <Bynbo7> lewis1711: no, and yes
00:49:33 <ksf> it's conflating the chunk type with the element type.
00:49:39 <Tau> lewis1711, i think they are but lists i presume to be kind of linked lists.
00:49:41 <Bynbo7> a tuple is two pointers basically
00:49:51 <ksf> if you want to understand iteratees, I'd recommend against using that package
00:50:15 <Bynbo7> Tau: lists are linked lists, yes
00:50:22 <lewis1711> singly?
00:50:26 <Bynbo7> yes
00:50:30 <Tau> Bynbo7, k
00:50:33 <aristid> ksf: which package?
00:50:46 <Wooga> ksf: so taking Oleg's original implementation instead of Data.Enumerator is not bad?
00:51:05 <Wooga> i had Oleg's code working for me
00:51:21 <Bynbo7> @src []
00:51:21 <lambdabot> data [] a = [] | a : [a]
00:51:41 <aristid> Wooga: i'm pretty sure you can get enumerator to work
00:52:35 <ksf> I think it's borked.
00:52:41 <ksf> the chunk type.
00:52:56 <ksf> it's much better to use ListLike instead of [] inside the chunks
00:53:09 <ksf> keeps the interface cleaner
00:53:55 <ksf> head for the list version is head :: Monad  m => Iteratee  a m (Maybe  a) , while for bytestrings it's head :: Monad  m => Iteratee  ByteString  m (Maybe  Word8)
00:53:59 <ksf> that's just inconsistent.
00:54:44 <ksf> that's not to say that oleg's code is clean, it's tailored to his example and not in library shape.
00:55:18 <aristid> ksf: i think enumeratee is simplified pretty brutally on purpose
00:55:27 <aristid> *enumerator
00:55:34 <ksf> well, in that spot, it's just vastly oversimplified.
00:55:48 <aristid> brutally, even :)
00:55:54 <ksf> that's saying that pushing square pegs through round holes is simple.
00:56:39 <ksf> oh, data.iteratee switched to CPS
00:56:45 <ksf> real, proper cps, not half-assed
01:00:25 <aristid> ksf: so you say that enumerator is unusable and iteratee has to be used?
01:00:33 <ksf> yep
01:00:40 <ksf> IMNSHO
01:00:46 <Wooga> k, switching to iteratee
01:00:50 <Wooga> %)
01:01:07 <ksf> NSHO because I spend some serious amount of time trying to fledge out an interface for iteratees, myself.
01:01:35 <ksf> currently, they don't combine very well
01:01:49 <ksf> that is, there's no proper transformer support
01:02:12 <aristid> is it possible to write converters between the different iteratee types?
01:02:14 <Bynbo7> i found enumerator to be much much easier to use
01:02:23 <aristid> because there are some invested resources there
01:02:38 <aristid> for example, I use http-enumerator (there is no http-iteratee at all)
01:02:40 <ksf> in principle it's quite easy to write a unified interface
01:03:02 <ksf> but that won't be as dumbed down as enumerator
01:04:21 <ksf> wut wai is built on that adomination
01:04:33 <lewis1711> every single type must have a typeclass, right?
01:04:34 <aristid> not just wai.
01:04:51 <lewis1711> or belong to some typeclass that defines how it behaves.
01:05:00 <aristid> lewis1711: no.
01:05:27 <Bynbo7> jjohnsson: no? why should it?
01:05:34 <aristid> Bynbo7: ?
01:05:42 <Bynbo7> uh, lewis1711, sorry
01:06:01 <lewis1711> well otherwise, how would one use it?
01:06:04 <lewis1711> was my line of thinking
01:06:12 <Botje> woo, fosdem
01:06:14 <aristid> Bynbo7: they don't even share the same initial letter, and j to l has a distance of TWO on a standard keyboard :P
01:06:45 <Bynbo7> aristid: the nick reminded me of jlouis, so i went for the j =)
01:06:47 <aristid> lewis1711: with normal functions
01:07:04 * Maxdamantus wonders why plusPtr :: Ptr a -> Int -> Ptr b
01:07:06 <Bynbo7> lewis1711: what about Bool? what classes do you need to be able to use it?
01:07:11 <aristid> Bynbo7: there is a jlewis, too :D
01:07:11 <lewis1711> Eq
01:07:20 <Bynbo7> heh
01:07:32 <aristid> lewis1711: no. pattern matching on constructors requires no Eq
01:07:37 <Bynbo7> lewis1711: but, Eq is defined in terms of Bool
01:07:40 <Bynbo7> @src Eq
01:07:40 <lambdabot> class  Eq a  where
01:07:40 <lambdabot>     (==), (/=)   :: a -> a -> Bool
01:07:47 <lewis1711> I see
01:08:01 <lewis1711> but surely, for even pattern matching to be performed, there must be some "root type class"
01:08:11 <aristid> no.
01:08:11 <lewis1711> or base or what have you, that defines the behaviour for pattern matches
01:08:16 <Bynbo7> data Direction = LeftDir | RightDir
01:08:19 <aristid> pattern matching REQUIRES NO TYPE CLASS.
01:08:25 <Bynbo7> that's not a member of any class
01:08:39 <lewis1711> hmm
01:08:46 <Bynbo7> foo LeftDir = 1; foo RightDir=2
01:08:56 <Bynbo7> bloody spacebar
01:09:06 <aristid> Bynbo7: i think the heart of his confusion is pattern matching itself
01:09:20 <Maxdamantus> > (\a b -> a == b) NaN NaN
01:09:21 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaN'
01:09:26 <lewis1711> aristid: nah that's not it. I just dunno haskell
01:09:35 <Bynbo7> lewis1711: I'm sensing an OOP background
01:09:54 <Bynbo7> types are not derived from other types
01:09:57 <Maxdamantus> > (\a b -> a == b) (0/0) (0/0)
01:09:58 <lambdabot>   False
01:10:07 <lewis1711> I don't have a strong background in anything:P
01:10:10 <Bynbo7> s/types/data
01:10:18 <aristid> Maxdamantus: why the eta expansion?
01:10:53 * Maxdamantus wonders why there's no NaN constructor.
01:10:55 <lewis1711> Bynbo7: right. so there's no type hierarcy, as it were.
01:11:02 <Bynbo7> indeed
01:12:20 <ksf> well, you *can* build them in a hirarchy.
01:12:22 <Bynbo7> lewis1711: pattern matching is fundamentally different to equality
01:12:32 <kfr> Hierarchy*
01:12:46 <ksf> but that's containment relations, not subtyping.
01:12:50 <lewis1711> alright. that clears it up for now. will continue mah learnings (btw, if LYAH is considered inaccurate or something, plz say so now)
01:13:01 <ksf> lyah is considered brilliant
01:13:27 <Bynbo7> lewis1711: lyah is the best introduction to haskell imo
01:13:40 <lewis1711> good
01:13:47 <ksf> especially because it's an insult to academic habitus
01:13:49 <Bynbo7> for example: data Foo = Bar Foo, is a piece of data that can only look like Bar (Bar (Bar (Bar.... if you were to derive Eq on it, and you tried to check if two things were equal, it wuld never terminate
01:13:58 <Bynbo7> but you can pattern match on it just fine
01:14:59 * ksf considers making a t-shirt saying "This pseudointellectual habitus pisses me imminently off"
01:15:40 <ksf> "This pseudointellectual habitus pisses me, imminently, off" , even
01:17:05 <Wooga> hm
01:17:08 * ksf thinks he just had a major idiomatic failure, there.
01:17:28 <Wooga> why can't i call Done a (StreamG c el) constructor form Data.Iteratee ?
01:17:45 <Wooga> looking at source code it gets exported
01:17:59 <Wooga> but it is not available in ghci for some reason
01:17:59 * ksf is looking for a proper translation for "ankotzen" that isn't so glaringly non-vulgar as "make me sick"
01:18:32 <Bynbo7> Wooga: there's functions you're supposed to use to get access to those sorts of things
01:19:12 <kfr> ksf: Makes me sick sounds good
01:19:13 <azaq23> ksf: It gets on your nerve
01:19:20 <aristid> ksf: just "ankotzen". it doesn't matter if people don't understand it, that's the point of the pseudointellectual habitus anyways.
01:19:29 <ksf> heh.
01:19:36 <aristid> but it should be a noun.
01:19:37 <aristid> Ankotzung
01:19:59 <Wooga> Bynbo7: but source code it is defined plainly as `data IterGV c el m a = Done a (StreamG c el)'
01:20:18 <aristid> ksf: how about: "This pseudointellectual habitus is a primary source of my imminent Ankotzung."
01:20:19 <Wooga> or i am not understanding something?
01:20:54 <ksf> nah the ankotzung isn't immanent in you, but the habitus.
01:21:23 <ksf> "Euer pseudointellektueller habitus kotzt mich immanent an"
01:21:43 <ksf> which is even moar pseudointellectual in german because of the use of "immanent"
01:22:37 <ksf> it's bloody used as pseudointellectual cognate of "about to happen", ffs.
01:22:51 <Wooga> why it can be unavialable in ghci when it gets properly exported with  IterGV (..), ?
01:23:45 <ksf> that's not even elegant usage of pseudointellectualism, as "eloquent" for "garrulous"
01:24:11 <ksf> Wooga, did you compile the code first?
01:24:20 <ksf> ghc loads .o files, and it might've gotten optimised away.
01:24:21 <lewis1711> "To be a member of Ord, a type must first have membership in the prestigious and exclusive Eq club." so there's no type hierarchy, but there is a typeclass hierarchy?
01:24:32 <ksf> yep.
01:24:38 <lewis1711> ksf: I am quite fond of using "concatenate" to join things. oh wait, that's standard in computer science:P
01:24:41 <ksf> well, not so much of a hierarchy.
01:24:55 <Wooga> ksf: which code? Data.Iteratee should be compiled by my package manager already
01:24:55 <aristid> it's a DAG, i think
01:25:16 <Wooga> and it :m's properly
01:25:30 <ksf> Wooga, then I have no idea.
01:25:31 <aristid> lewis1711: that's why join = concat
01:25:36 <aristid> :t join
01:25:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:25:47 <aristid> for m = [], at least
01:25:50 <ksf> :t concat
01:25:51 <lambdabot> forall a. [[a]] -> [a]
01:25:51 <lewis1711> oh good
01:26:15 <ksf> that's not proper caleskell.
01:26:26 <Saizan> ksf: exported symbols don't get optimized away
01:26:30 <aristid> ksf: sure is. Caleskell is slightly inconsistent.
01:27:33 <ksf> lewis1711, anyway, you're still looking, in some sense, at a containment relation.
01:28:09 <ksf> at least that's what the typeclass subtyping looks like when you translate typeclasses into proper arguments
01:28:45 <lewis1711> containment relation... that's a new one
01:28:46 <lewis1711> :)
01:28:48 <Saizan> Wooga: which package is this?
01:28:51 <Bynbo7> lewis1711: i wouldn't call it a typeclass hierarchy, some classes have constraints on what other classes the types need to be a member of before being part of the type.
01:29:09 <ksf> it's best to forget everything you know about OOP (or any other programming language, for that matter) when learning haskell, as stuff that might look similar is actually vastly different.
01:29:20 <Wooga> Saizan: Data.Iteratee
01:29:28 <ksf> lewis1711, well, is a car an engine?
01:29:30 <Saizan> Wooga: that's the module
01:29:33 <aristid> Bynbo7: doesn't that require extensions?
01:29:34 <Bynbo7> you can define any class you like without any constraints. but things like Ord have an Eqconstraint because it doesn't make much sense to be able to compare the ordering of things without knowing whether they're equal
01:29:43 <Bynbo7> aristid: hmm?
01:30:00 <aristid> Bynbo7: i mean for those kind of constraints
01:30:00 <lewis1711> ksf: no. what's the analogy here?
01:30:01 <Wooga> Saizan: i used dev-haskell/iteratee-0.7.0.0 eubild to install this
01:30:07 <Bynbo7> aristid: no...
01:30:10 <Bynbo7> @src Ord
01:30:10 <lambdabot> class  (Eq a) => Ord a  where
01:30:10 <lambdabot>     compare      :: a -> a -> Ordering
01:30:10 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
01:30:10 <lambdabot>     max, min         :: a -> a -> a
01:30:12 <ksf> lewis1711, one is contained within the other.
01:30:19 <Wooga> Saizan: guess it is named 'iteratee'
01:30:20 <aristid> Bynbo7: i mean for the non-DAG case... man
01:30:28 <ksf> which is just different from "a car is a vehicle"
01:30:36 <Bynbo7> aristid: eh? you've lost me
01:30:45 <Wooga> Saizan: yes, it definently is: ╰> ghc-pkg list | grep iteratee iteratee-0.7.0.0
01:31:02 <aristid> <Bynbo7> lewis1711: i wouldn't call it a typeclass hierarchy, some classes have constraints on what other classes the types need to be a member of before being part of the type.
01:31:05 <Bynbo7> ok, i meant to end that sentense with class, not type
01:31:08 <ksf> which is a metaphor abundant in OOP and virtually unused in haskell.
01:31:16 <Wooga> ah
01:31:21 <Wooga> i got why it wasn't there
01:31:32 <Wooga> i read 0.2.4 version of documentation
01:31:36 <aristid> Bynbo7: oh, you just meant that it is a DAG, not a hierarchy?
01:31:40 <Wooga> when actual is 0.7
01:31:44 <Bynbo7> aristid: yeah
01:31:44 <Wooga> damned google
01:31:53 <Saizan> Wooga: that's what i was suspecting
01:31:59 <aristid> Bynbo7: i thought you meant the crazy stuff that can be done with MPTCs and such
01:32:10 <Bynbo7> aristid: i meant it's not like there's a Type clase, then a Eq class where you have types which can be tested for equality
01:32:20 <Bynbo7> s*
01:32:32 <aristid> yeah
01:32:37 <ksf> one could also do class (Ord a) => Eq a where x (==) y = x <= y && y >= x 
01:32:47 <ksf> but that wouldn't make much sense 
01:32:48 <aristid> ksf: syntax error :P
01:32:56 <lewis1711> ksf: I wasn't really coming from "C++ style" OOP with the hierarchy thing. more sets
01:33:01 <ksf> ...add {;} here and there.
01:33:17 <aristid> ksf: s/\(==\)/==/
01:33:25 <lewis1711> in that at first i thought Num would be a set that contained Int and Float, etc. then I found out it was a class
01:33:47 <lewis1711> but that's probably just as bad an anology, thinking of types as sets
01:33:55 <ksf> well, it's an open set.
01:34:00 <aristid> lewis1711: i think that classes do correspond to sets, in a way. the sets of types on which the class operations are defined
01:34:43 <lewis1711> sort of reminds me of monoids
01:34:46 <ksf> or rather the set of instances of a type.
01:34:55 <ksf> the class itself is just an interface
01:35:51 <aristid> lewis1711: did you know that monads are just monoids in the catagory of ennobunktors?
01:36:00 <aristid> or did i make some spelling mistake there? :D
01:36:11 <aristid> @quote ennobunktor
01:36:11 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
01:36:11 <ksf> monoidal /objects/
01:36:36 <Bynbo7> ha
01:36:40 <lewis1711> ennobunktors? :D I may be a noob, but I'm not *that* much of a noob
01:37:05 <aristid> it was just a stupid joke :D
01:38:47 <ksf> lewis1711, well: "class Functor f where ..." is the category of endofunctors in hask, with instances as objects and I don't think we have any sensible morphisms.
01:39:08 <Saizan> lewis1711: it's quite fine to thing of type classes as relations/sets of types
01:39:32 <lewis1711> oh man, my phd friend tried to tell me about endofunctions (not functors), brave guy:)
01:39:57 <Saizan> heh, i was late on that
01:39:57 <lewis1711> Saizan: oh?
01:40:34 <Saizan> anyhow, the relation view scales nicely to multi parameters type classes
01:41:25 * hackagebot comonad-transformers 1.5.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.2 (EdwardKmett)
01:41:30 <ksf> quick, someone make a denotional semantics of haskell, then we know what typeclasses are.
01:42:06 <lewis1711> is there anyway to get the members of a typeclass in ghci?
01:42:15 <ksf> :i ?
01:42:18 <Bynbo7> :info <class>
01:42:25 * hackagebot keys 0.2.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.2.1 (EdwardKmett)
01:42:29 <ksf> :i Eq
01:42:38 <ksf> @slap lambdabot
01:42:38 * lambdabot submits lambdabot's email address to a dozen spam lists
01:42:52 <ksf> @vixen not very smart today, are we?
01:42:52 <lambdabot> let's don't talk about that
01:43:29 * hackagebot representable-functors 0.3.0 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.3.0 (EdwardKmett)
01:44:29 * hackagebot adjunctions 0.9.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.9.0 (EdwardKmett)
01:44:47 <lewis1711> "class Eq a where  (==) :: a -> a -> Bool ... " is that equivalent to (==) being defined as a function that only operates on members of this typeclass? or could one defined another type class and use (==) to mean something confusingly different
01:45:10 <edwardk> lewis: the former.
01:45:22 <lewis1711> stupid question, sorry
01:45:24 <lewis1711> :t (==)
01:45:25 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:45:29 <lewis1711> answers it:D
01:45:51 <edwardk> lewis: in order to define a new typeclass with (==) as a member you'd have to do so in a module that hides the prelude. but you wouldn't be able to have both (==)'s in scope at the same time. you'd have to use qualified imports to access one or the other
01:47:36 <lewis1711> edwardk: makes sense.
01:51:43 <pozic> How can I create an uninitialized ST array? 
01:52:30 * hackagebot representable-tries 0.2.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.2.1 (EdwardKmett)
01:53:10 <ksf> yay hygenic scoping
01:54:02 <edwardk> import Data.Array.Base use newArray_
01:54:48 <Wooga> how do i extract resulting value of `enumPureNChunk "1234" 2 peek' using Data.Iteratee ?
01:54:54 <pozic> edwardk: that is not uninitialized. 
01:55:06 <Bynbo7> pozic: yes it is
01:55:18 <Bynbo7> newArray is initialised, newArray_ isn't
01:55:23 <pozic> Bynbo7: Builds a new array, with every element initialised to an undefined value. In a monadic context in which operations must be deterministic (e.g. the ST monad), the array elements are initialised to a fixed but undefined value, such as zero.
01:55:26 <Bynbo7> i think
01:55:29 <pozic> Bynbo7: No, it is NOT.
01:55:30 <koninkje> Wooga: use run, or runIter
01:55:48 <Bynbo7> pozic: what do you want then?
01:55:53 <edwardk> pozic: the ST case may screw you
01:56:09 <pozic> edwardk: there used to be a function with 'unsafe' in it, that did this.
01:56:13 <Bynbo7> it would be a very bad idea for ST arrays to be initialised with random data
01:56:21 <pozic> Bynbo7: no, it would not. 
01:56:30 <Bynbo7> because you then lose all the guarantees of ST
01:56:32 <Bynbo7> yes, it would
01:56:57 <pozic> Bynbo7: no, you wouldn't. Please, talk to someone else. 
01:57:37 <Bynbo7> runSTArray $ unsafeNewArray (0,10)
01:57:41 <Bynbo7> that would not be pure
01:57:45 <edwardk> Bynbo7: unless your algorithm will fill in all of the locations you happen to ddress before you use them
01:58:06 <Wooga> koninkje: when i am trying to, i am getting nasty message about missing type signatures, but i have no idea where and which to place them: http://paste.pocoo.org/show/332497/
01:58:07 <edwardk> sadly pozic: ST provides no raw array creators, all of them fill in some suitable default
01:58:23 <pozic> edwardk: then they changed that in a backwards incompatible manner. 
01:58:26 <Bynbo7> edwardk: sure, but unless you can guarantee that, it still breaks purity
01:58:32 <pozic> edwardk: since there used to be such a function. 
01:58:46 <pozic> They literally do everything to make it unpopular, don't they?
01:59:10 <Bynbo7> what?
01:59:18 <Bynbo7> why do you need such a thing anyway?
01:59:25 <koninkje> Wooga: Yeah, the iteratee library gets upset when it can't monomorphize all the type variables
01:59:29 <Bynbo7> i also think what you're looking for may be in GHC.Arr
01:59:33 <edwardk> hrmm
01:59:37 <koninkje> Wooga: which version of iteratee are you using?
01:59:37 <edwardk> what about unsafeNewArray_
01:59:46 <Wooga> koninkje: lastest, 7.0
01:59:57 <edwardk> just looking not seeing the defaults leaked through
02:00:45 <edwardk> that appears to be the one you need
02:00:55 <koninkje> Wooga: where did enumPureNChunk get moved to? Or, what's its type?
02:01:01 <edwardk> :t Data.Array.Base.unsafeNewArray_
02:01:02 <lambdabot> forall i (m :: * -> *) (a :: * -> * -> *) e. (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> m (a i e)
02:01:02 <Blkt> good day everyone
02:01:33 <koninkje> Wooga: ah, I found it
02:02:31 <pozic> edwardk: yeah, it seems they introduced a generalized version of it. the STU variant implements it in constant time (at least if the OS is sane). 
02:02:59 <pozic> I think many OSs still only give you initialized memory, unfortunately.
02:03:01 <koninkje> Wooga: try something like ghci> run (enumPureNChunk "1234" 2 peek) :: Iteratee [] IO Int
02:03:19 <lewis1711> type classes seem like a really god idea (just finished the LYAH chapter on them). Sort of reminds me of something similar in ML. weird they never caught on.
02:03:35 <edwardk> pozic: well, in a lot of cases that is what you get from the OS, but not always from your libc once garbage starts to recycle
02:03:59 <edwardk> leading to all those lovely errors when folks use malloc expecting calloc behavior because their test cases never deleted anything before reallocating
02:04:26 <edwardk> er s/garbage recycle/memory getting freed/
02:04:28 <koninkje> Wooga: OOps, I meant ghci> run (enumPureNChunk "1234" 2 peek :: Iteratee [] IO Int)
02:06:42 <Wooga> koninkje: am i understanding right thet last argument (Int) should be type of peek returning ?
02:06:52 <Wooga> koninkje: then it probably should be Char
02:07:04 <Wooga> because peek returns single char
02:07:10 <Wooga> can't remember if wrapped into maybe
02:07:25 <Wooga> yes, weapped
02:07:46 <Wooga> koninkje: also single [] gives * -> * kind error
02:07:50 <pozic> edwardk: where exactly is it? http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:unsafeNewArray_ => nothing
02:07:51 <Wooga> and [a] not helps too
02:08:19 <edwardk> data.array.base
02:08:56 <edwardk> Prelude Data.Array.Base> :t unsafeNewArray_ ==> unsafeNewArray_ :: (MArray a e m, GHC.Arr.Ix i) => (i, i) -> m (a i e)
02:09:01 <Wooga> koninkje: http://paste.pocoo.org/show/332501/
02:09:16 <pozic> edwardk: in which version?
02:09:34 <Bynbo7> which version of what?
02:09:36 <pozic> edwardk: got it
02:09:58 <edwardk> i'm running array 0.3.0.2 so i hope its in just about anything relatively current ;)
02:13:15 <pozic> Is there a foldM like function for ByteStrings?
02:13:28 <koninkje> Wooga: Er, yeah, tht should be Char not Int.
02:14:09 <koninkje> Wooga: try  ghci> run (enumPureNChunk "1234" 2 peek :: Iteratee String IO Char)
02:14:39 <koninkje> I've only used iteratee < 0.4 so far, so the types are different than I'm used to
02:14:39 <edwardk> just define something like
02:14:45 <Wooga> koninkje: http://paste.pocoo.org/show/332504/
02:15:06 <edwardk> foldrM f z0 xs = BS.foldl f' return xs z0 where f' k x z = f x z >>= k
02:15:18 <koninkje> In any case, you should give the argument to run a type signature which makes it whatever monomorphic type you want, then run should work fine
02:16:07 <koninkje> Oh, right. First use joinI before run
02:16:36 <koninkje> > run (joinI $ enumPureNChunk "1234" 2 peek :: Iteratee String IO Char)
02:16:37 <lambdabot>   Not in scope: `run'Not in scope: type constructor or class `Iteratee'Not in...
02:20:05 <Wooga> koninkje: http://paste.pocoo.org/show/332506/
02:20:39 <Wooga> (i am using Maybe Char because of peek :: (Monad m, Data.ListLike.Base.ListLike s el) => Iteratee s m (Maybe el))
02:26:28 <Wooga> yay!
02:26:35 <Wooga> i figured that out: run $ joinIM $ enumPureNChunk "dasdfs" 10 peek 
02:26:50 <Wooga> dunno what is joinIM, but it works
02:27:17 <koninkje> Right, I was thining enumPureNChunk returned an Enumeratee (instead of Enumerator) for some reason
02:27:37 <koninkje> joinIM just pushes the monadic effects inside the iteratee
02:28:11 <dqd> Is GHC 6.12.1 between versions 6.10.1 and 6.13? Because my Cabal says it's not: http://pastebin.dqd.cz/7eH6/raw/
02:28:14 <koninkje> It doesn't actually do anything, it's just a type coercion since m(Iteratee s m a) ~= Iteratee s m a
02:29:11 <Wooga> koninkje: what operator '~=' do? is it means 'roughly equal'?
02:29:25 <koninkje> Whereas joinI actually does something, namely it says that when the outer iteratee is given EOF, then it should send EOF to the inner iteratee
02:29:42 <koninkje> Wooga: I mean it as the symbol for isomorphism
02:30:44 <Wooga> koninkje: well, thanks for helping!
02:30:51 <koninkje> sure thing
02:33:59 <koninkje> dqd: it should be...
02:35:15 <Saizan> dqd: it's referring to the ghc library
02:35:55 <Saizan> dqd: how did you install ghc? on debian/ubuntu you might need libghc6-ghc-dev if you installed through the repos
02:36:51 <dqd> Saizan: This is a Fedora system, it's installed from the packages.
02:37:14 <Saizan> dqd: look for a package with the ghc lib
02:37:43 <dqd> This is the list of installed packages: http://pastebin.dqd.cz/2Y0Z/raw/
02:37:58 <dqd> Is there something missing?
02:38:17 <Wooga> dqd: maybe *ghc*devel* ?
02:38:51 <Saizan> dqd: can you paste "ghc-pkg list ghc" ?
02:39:16 <dqd> Saizan: There: http://pastebin.dqd.cz/rjR7/raw/
02:39:29 <dqd> Wooga: Oh, that's right.
02:39:33 <Wooga> btw, fyi, in gentoo you have almost all hackage in haskell overlay and you don't need to use anything but emerge to install them
02:40:01 <Wooga> thats really convinient
02:40:50 <Saizan> dqd: yeah, you lack ghc-6.12.1 there
02:40:59 <dqd> OK, thanks for now, I'll try to get the devel packages.
02:41:20 <Tau> is there some built in function to count how times a element appears in a list ?
02:41:39 <mauke> length + filter
02:41:43 <pozic> length . filter(==e)?
02:42:12 <Wooga> length $ filter
02:42:16 * Wooga just kidding
02:42:38 <Tau> what does filter do
02:42:43 <Wooga> erm.. filters?
02:42:46 <Tau> i'm new to haskell.
02:43:00 <pozic> Tau: then read a few books :)
02:43:09 <Tau> Polarina, what ones do u hint
02:43:12 <Wooga> > filter (<5) [1..10]
02:43:13 <lambdabot>   [1,2,3,4]
02:43:24 <Tau> i see.
02:43:28 <edwardk> > filter (> 4) [1,3,3,4,5,6,3,12]
02:43:29 <lambdabot>   [5,6,12]
02:43:43 <pozic> Tau: The Haskell School of Expression is acceptable. 
02:43:53 <Wooga> i'd reccomend lyah for begining
02:44:05 <Tau> can i obtain these from google ?
02:44:06 <Wooga> http://learnyouahaskell.com/
02:44:16 <mauke> no, try the web instead
02:44:45 <Tau> mauke, that was a joke.
02:45:10 <edwardk> tau: there is also real world haskell: http://book.realworldhaskell.org/read/
02:45:39 <Wooga> but rwh is kinda inconsistent
02:45:49 <edwardk> it makes a nice counterpoint to LYAH
02:46:26 <pozic> There is still a niche for an advanced Haskell book. 
02:46:28 <Tau> edenc, humm, i think that one will be suitable.
02:46:28 <aristid> neither is flawless
02:46:43 <aristid> pozic: an advanced modern haskell book?
02:46:44 <Tau> but i have a question on using filter to count how many elements appears in a list.
02:46:45 <shachaf> Someone should write a flawless Haskell book, clearly.
02:46:54 <aristid> shachaf: indeed.
02:46:56 <mauke> flaskell
02:46:59 <Tau> isn't that computationally expensive in relation to a imperive way ?
02:47:05 <mauke> Tau: why?
02:47:10 <Wooga> oh no
02:47:14 <c_wraith> Tau: only without fusion
02:47:21 <Wooga> purity alows really aggressive optimization
02:47:25 <Tau> c_wraith, how so ?
02:47:27 <pozic> Tau: in theory, no, in practice it is almost impossible to predict.
02:47:41 <c_wraith> Tau: If it fuses, the filter doesn't actually create an intermediate data structure
02:47:42 <aristid> Tau: GHC is a smart cookie. it can optimise that to a very fast loop :)
02:47:43 <shachaf> pozic: That's a little excessive, isn't i?
02:47:58 <shachaf> pozic: You can predict what that piece of code will do reasonably well.
02:48:01 <Tau> aristid, lol
02:48:03 <Tau> nice.
02:48:15 <pozic> shachaf: it depends on so many things, amongst which the RULES system, which is a hack.
02:49:04 <pozic> Some kind of interface coloring your lines green or something like that when the loops are really tight would be nice.
02:49:07 <Tau> c_wraith, then, everytime i use filter it doesn't create a structure it returns pointers which delimites ranges of the list ?
02:49:19 <mauke> Tau: no
02:49:20 <c_wraith> Tau: not that simple
02:49:28 <pozic> That is, when no intermediate lists are being generated and all you get are nice fast array like structures.
02:49:44 <mauke> pozic: array-like? huh?
02:50:05 <pozic> mauke: lists are slow. 
02:50:07 <Wooga> random-accessable, i guess
02:50:08 <c_wraith> it's not array-like.  It just doesn't create an intermediate list
02:50:23 <mauke> pozic: no, they aren't
02:50:34 <Tau> c_wraith, but how can you use what it returns what does it return in memory ?
02:50:42 <c_wraith> If it fuses, the it just becomes a single loop that traverses the list counting matching elements
02:51:04 <c_wraith> Without ever creating an intermediate loop.
02:51:06 <pozic> And a list contains of a bunch of pointers. 
02:51:11 <pozic> Following pointers is slow.
02:51:18 <Tau> for ex filter ( > 1) [1..10000] would it return a couple of pointers delimiting 2..10000 ?
02:51:24 <mauke> pozic: compared to what?
02:51:34 <mauke> Tau: no
02:51:36 <c_wraith> Tau: no.  It depends on how it is used
02:51:44 <pozic> mauke: compared to an array. 
02:51:46 <Tau> i see.
02:51:51 <mauke> pozic: arrays have no speed
02:51:55 <c_wraith> Tau: list fusion is an optimization on sequences of operations.
02:52:01 <pozic> Take for example filter ( > 1) [1..10000]
02:52:04 <mauke> pozic: that's like saying "I prefer streets because lakes are slow"
02:52:22 <Tau> c_wraith, k
02:52:25 <pozic> Well, that's a constant expression.
02:53:06 <mauke> hmm
02:53:16 <mauke> how would you write filter (> 1) on arrays?
02:53:23 <pozic> Let's say we have filter p [1..10000]. In that case, it should simply convert the list into one or more arrays, which then get rebuild at the end. 
02:53:34 <mauke> what?
02:53:36 <pozic> That is, at no point a list exists in the program. 
02:53:47 <mauke> that makes no sense
02:53:53 <pozic> Sure, there is a list in the source code, but no list data structure actually exists at run-time.
02:54:03 <mauke> there is no list in the source code
02:54:07 <systemfault> pozic: You're doing it wrong... Don't think of haskell with your C-mentality... It doesn't work like that.
02:54:07 <mauke> it's a call to enumFromTo
02:54:37 <pozic> mauke: and what does it return?
02:54:43 <jaj> pozic: you have your initial list and an expressions that operates on the list which is evaluated lazily on demand
02:54:46 <mauke> depends
02:55:14 <pozic> jaj: and how are the elements of this list accessed? 
02:55:15 <mauke> at the language level, [a]
02:55:34 <aristid> mauke: vector<int>::iterator it = remove_if(v.begin(), v.end(), _1 > 1); v.erase(it, v.end());
02:55:38 <pozic> jaj: via a pointer in some random place in memory out of the cache. 
02:55:55 <Wooga> vectors are really slow in comparison to C-arrays
02:56:06 <aristid> Wooga: huh? no
02:56:07 <mauke> pozic: why do you think it's a random place?
02:56:08 <Wooga> tr1 arrays as well
02:56:18 <mauke> Wooga: I don't think that makes sense
02:56:20 <aristid> Wooga: you have to compile with optimisation enabled.
02:56:48 <mauke> std::vector is backed by a C array
02:56:49 <pozic> mauke: it is undefined, so it could happen. 
02:56:52 <Wooga> aristid: even -O3 not makes vectors faster then haslf-perfoomanced arrays
02:57:03 <systemfault> Wooga: 1) Comparing vector to C array is like comparing apples to oranges..
02:57:13 <aristid> Wooga: that's not really true.
02:57:17 <Wooga> systemfault: yes, bu tr1 array is as slow as vector
02:57:26 <systemfault> Wooga: Not really..
02:57:34 <Wooga> i have syntehtic tests
02:57:41 <mauke> ok, people. stop saying data structures are slow.
02:57:41 <systemfault> You clearly don't know what you're talking about.
02:57:45 <mauke> can we talk about operations instead?
02:58:04 <aristid> mauke: "mauke" is a slow String.
02:58:18 <mauke> pozic: yes, but in this case they're generated one after another, so wouldn't they end up close to each other?
02:58:52 <Wooga> systemfault: aristid: mauke: watch: http://paste.pocoo.org/show/332513/
02:59:12 <Wooga> flags are -lSDL -O3
02:59:12 <mauke> Wooga: .push_back? what
02:59:18 <Wooga> mauke: it is outside of test loop
02:59:29 <mauke> still
02:59:37 <Wooga> it pushes elemnt to a vector
02:59:39 <pozic> mauke: it probably would. Still, you are using more memory than needed. 
02:59:59 <Wooga> to the end of vector, to be sure
03:00:00 <mauke> pozic: that depends on how I use the result
03:00:14 <pozic> mauke: I thought the promise of functional programming was that the source code and the implementation basically have nothing to do with eachother anymore. 
03:00:36 <pozic> So far nobody actually has done something like that. 
03:00:53 <pozic> Fusion is just a simple approximation of that idea. 
03:01:44 <mauke> > 1000000 `div` 2 * 1000001
03:01:45 <lambdabot>   500000500000
03:01:53 <aristid> Wooga: if you know the size of the vector in advance, use reserve() to hint it.
03:02:05 <mauke> or just specify it in the declaration
03:02:37 <aristid> mauke: well, then push_back would not work. there's a difference between capacity and size.
03:02:46 <Wooga> aristid: does it makes traversing the vecotr faster? or only adding elemnts to it?
03:02:52 <mauke> yes, but then you can just assign to the elements
03:02:57 <mauke> like the array code does
03:03:05 <aristid> yeah.
03:03:11 <Wooga> hm, interesting
03:03:27 <mauke> I'mm a rewrite this thing
03:03:43 <mauke> SDL and integer overflow, bah
03:04:23 <systemfault> Anyway... one thing that's for sure, std::array cannot be slower.
03:04:33 <Wooga> well, value of sum exists only for preserve g++ from optimizing loop to a compilt time
03:04:36 <systemfault> As it's basically a struct with an array inside.
03:04:53 <systemfault> (It's an aggregate in C++-speak)
03:05:04 <mauke> argh, size is not size_t
03:05:08 <rudi_s> Hi. I'm using QuickCheck to test a function and one possible parameter value should be ignored, in this case Empty (because the function fails for it). At the moment I have prop_test Empty = True ==> True ; prop_test x = .. ==> ... I'm sure there's a better way to handle that. Thanks (I'm a Haskell noob, so I hope this isn't a too stupid question).
03:05:09 * mauke curses C++
03:05:26 <systemfault> mauke: Use size_t :/
03:05:35 * mauke uses enum
03:06:44 <Saizan> rudi_s: 1) why not prop_test Empty = True; .. ? 2) you could make a custom generator for your input type that never produces an Empty and then use it with forAll
03:08:26 <Saizan> rudi_s: forget 1) :)
03:08:51 <Tau> it is weird. i'm trying to define it dk: Int -> Int in the ghci.
03:09:01 <Tau> as it is being explained in the tutorial.
03:09:15 <mauke> Tau: you can't
03:09:16 <Tau> but it appears to be wrong.
03:09:20 <Wooga> without reserve: STDARRAY: 579 frames, ARRAY: 1762 frames, VECTOR: 736 frames
03:09:30 <Wooga> C-array just two times faster 
03:09:34 <Wooga> now i'll try reserve
03:09:34 <Tau> mauke,how should i use that ?
03:09:40 <mauke> Tau: put it in a file
03:09:44 <Tau> ah.
03:09:59 <Tau> mauke, alright.
03:10:20 <rudi_s> Saizan: ;-) 2) doesn't work because I sometimes need the Empty for other tests.
03:10:46 <rudi_s> I mean True ==> True is okay and works fine, I just thought maybe there is a cleaner way.
03:10:54 <Saizan> rudi_s: that's not a problem with forAll
03:11:19 <Saizan> rudi_s: you can decide which generator to use for this test while not affecting the Arbitrary instance
03:11:42 <Saizan> rudi_s: property True would be a cleaner way to write True ==> True too
03:12:13 <Wooga> with .reserve(): STDARRAY: 678, ARRAY: 1792, VECTOR: 777
03:12:22 <Wooga> reserver changed nothing
03:12:47 <rudi_s> Saizan: Thanks, that looks better. And I will have a look at forAll. Thanks for your help.
03:12:51 <Wooga> and C-arrays still two (or even more) times faster
03:19:17 <aristid> Wooga: compiler version and options?
03:19:28 <Wooga> g++ (Gentoo 4.4.4-r2 p1.3, pie-0.4.5) 4.4.4
03:19:32 <Wooga> -lSDL -O3
03:20:38 <aristid> *shrug*
03:21:05 <Wooga> are you getting completly different results?
03:22:18 <Tau> when i do let a @ b = 3 it accepts but when i go do 1 @ 2 it raises a exception.
03:22:23 <Tau> why ?
03:22:35 <aristid> Wooga: i did not bother trying it.
03:22:40 <Wooga> lol
03:22:43 <mauke> Tau: because @ is only valid in patterns
03:22:59 <aristid> and because 1 is not a valid variable name
03:23:19 <Tau> humm.
03:23:22 <Tau> alright.
03:23:54 <mauke> Wooga: http://codepad.org/mSZG122R
03:25:01 <Wooga> mun: looks like compile-time optimization
03:25:04 <Wooga> mauke: *
03:25:28 <mauke> then why does it get slower when I increase LOOP?
03:25:31 <systemfault> q
03:25:57 <Wooga> maybe because you rining it only once?
03:26:03 <mauke> what
03:26:10 <Wooga> wait, i read the code
03:27:22 <Wooga> yep, you calling it only once
03:27:39 <mauke> calling what?
03:27:41 <Wooga> tests
03:27:49 <Wooga> they are not in infinite loop
03:28:10 <systemfault> td::vector: 286464 t = 0.729823, C array: 286464 t = 0.718435, tr1::array: 286464 t = 0.714460
03:28:26 <Wooga> it must be computig results before running main program
03:28:33 <mauke> then why does it get slower when I increase LOOP?
03:28:34 <Wooga> or something like that
03:28:38 <Wooga> thats why
03:28:42 <mauke> that makes no sense
03:28:52 <mauke> if it computes the result at compile time, LOOP should have no effect
03:29:40 <Wooga> hm
03:29:54 <Wooga> then why in my case vectors and tr1 arrays two-three times slower?
03:29:59 <Saizan> Tau: you can't have an operator named @ because that's reserved for so called as-patterns:
03:30:17 <mauke> Wooga: no idea
03:30:20 <Saizan> > let xxs@(x:xs) = [1,2,3] in (xss,x,xs)
03:30:21 <lambdabot>   Not in scope: `xss'
03:30:23 <mauke> maybe look at the generated code
03:30:27 <Saizan> > let xxs@(x:xs) = [1,2,3] in (xxs,x,xs)
03:30:28 <lambdabot>   ([1,2,3],1,[2,3])
03:30:32 <Tau> saiam, i see.
03:30:52 <Wooga> ah, i see
03:30:56 <Wooga> mauke: that must be size_t
03:31:38 <mauke> I just replaced all size_t by int; no difference
03:31:53 <Wooga> then this is my turn to have no idea
03:32:39 <aristid> Wooga: i note that you write the main loop three times. probably there is a subtle difference between the loops.
03:36:48 <mauke> Wooga: ~500 frames for all three versions
03:37:15 <Wooga> mauke: on mine example?
03:37:17 <mauke> yes
03:37:22 <Wooga> thats strange
03:38:02 <mauke> oh, that's interesting
03:38:10 <mauke> ARRAYBASE gets ~100 frames more with -O3
03:39:19 <ksf> erm...
03:39:25 <ksf> why is only Num defaultable?
03:40:59 <Wooga> mauke: this is definently size_t
03:41:15 <Wooga> i tried to replace ints in mine example and got same results as in your exampel
03:41:28 <edwardk> not just Num
03:41:30 <mauke> Wooga: changing stdarraybase.size() to size leads to a 50% speed drop on -O3
03:41:31 <pozic> http://paste.debian.net/106587/
03:41:39 <pozic> What is terribly stupid about that piece of code?
03:41:51 <mauke> Wooga: on the other hand, changing vectorbase.size() to size made it as fast as the C array
03:41:53 <pozic> It runs 120 times slower than a C++ version I also wrote. 
03:42:59 <Wooga> size_t makes vectors and tr 1 arays faster and C-arrays slower
03:43:13 <Wooga> i wonder why
03:43:22 <mauke> Wooga: changed it to const int wtf = stdarraybase.size(); ... i < wtf
03:43:30 <mauke> now all three are at 650 frames at -O3
03:44:13 <aristid> mauke: size() SHOULD be cheap with -O3
03:44:18 <aristid> so that seems like a gcc bug
03:44:38 <aristid> seems like gcc does not inline aggressively enough
03:44:39 <mauke> it's cheap but seems to affect other optimizations
03:44:50 <mauke> note that it got SLOWER when I replaced it by a constant
03:44:58 <aristid> gcc is no ghc 7 after all, so we can't expect it to be so clever
03:45:14 <Wooga> but why C-arrays are getting slower with size_t instead of int ?
03:45:22 <chrisdone> Ciao chappies. Is anyone interested in hacking on hpaste.org?
03:45:23 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
03:45:26 <chrisdone> @messages
03:45:27 <lambdabot> copumpkin asked 1d 17h 38m 28s ago: any idea why hpaste sometimes goes into "bad gateway" mode?
03:45:54 <chrisdone> copumpkin: I think I do, Charles.
03:46:11 <aristid> chrisdone: copumpkin's name is Daniel, not Charles :)
03:46:29 <chrisdone> It was an expression, but well done for knowing his name.
03:46:57 <tg_> aristid: Charles is the name of the butler who will inform the sir copumkin later
03:47:14 <aristid> chrisdone: i know it from twitter :)
03:48:15 <tg_> I am beginning to think that pure mathemiticians are so rare on IRC because of the lack encoding and/or the ability to copy/paste things from PDFs.
03:48:36 <tg_> I'm sure there are a host of other reasons, too
03:48:49 <chrisdone> Do mathemiticians work in mathemitigation?
03:49:12 <mauke> mathemission
03:49:16 <tg_> that sounds like a theme park
03:49:37 <tg_> chrisdone: seriously, though
03:49:55 <tg_> you try overlaying LaTeX or MathML or something like that into IRC cleanly
03:49:58 <tg_> hehe
03:50:01 <mauke> ∀α→ℝ∋
03:50:05 <pozic> mauke: do you have any idea why the Haskell version is 120 times slower than the C++ version? 
03:50:13 <mauke> pozic: no
03:50:16 <tg_> mauke: if only
03:53:01 <chrisdone> copumpkin: Actually, I have no idea. I just tested. Sometimes the process just dies without an error message.
03:53:22 * chrisdone runs ab -n100000 -c4
03:54:02 * hackagebot eq 0.2.0 - GADT-based type-level equality  http://hackage.haskell.org/package/eq-0.2.0 (EdwardKmett)
03:54:08 <ricree> anyone at all familiar with the Haskell LLVM bindings?  I'm trying to run some of the example code I've seen, and I get the error "user error (Interpreter has not been linked in.)"
03:54:30 <chrisdone> Oh. I see it's doing the bad gateway thing right now.
03:55:17 <pozic> I think the only way to get the Haskell version as fast as the C++ version is to write C in Haskell.
03:55:21 <Bynbo7> ricree: you need to run the initializeNativeFunction before you can use the JIT
03:55:43 <Bynbo7> uh, initializeNativeTarget
03:56:06 <Bynbo7> pozic: what are you working on?
03:56:30 <ricree> Bynbo7: thank you
03:56:42 <Bynbo7> ricree: that bit me a few days ago too
03:57:03 * hackagebot representable-tries 0.2.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.2.2 (EdwardKmett)
03:57:19 <pozic> Bynbo7: Andrew Coppin's Byte Histogram problem. 
03:57:41 <Bynbo7> link?
03:59:03 * hackagebot recursion-schemes 0.4.0.3 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.4.0.3 (EdwardKmett)
03:59:04 <pozic> Bynbo7: http://haskell.1045720.n5.nabble.com/Byte-Histogram-td3369969.html
03:59:32 <pozic> I wonder how he got the Haskell version as fast as his C++ version. Or maybe his C++ version is slow. 
03:59:41 <Bynbo7> "(Unless you're seriously going to suggest that "
03:59:42 <Bynbo7> GHC's native code generator is any match for the might of a half-decent 
03:59:42 <Bynbo7> C compiler...) 
03:59:45 <Bynbo7> uh...
03:59:56 <pozic> Bynbo7: which is true. 
03:59:57 <Bynbo7> actually the code produced by the NGC IS faster than the C backend
04:00:05 <Bynbo7> in many cases
04:00:22 <geheimdienst> what is NGC?
04:00:23 <pozic> Bynbo7: no surprise there. 
04:00:32 <geheimdienst> oh scratch that, native code gen
04:00:33 <Bynbo7> geheimdienst: native code generator
04:00:55 <chrisdone> Hm. No problems after 100k requests. TBH I think it's probably Takusen. 
04:01:05 <pozic> Bynbo7: anyway, produce a Haskell program which runs 100 times faster than the one I posted while not resorting to C like coding. 
04:01:37 <Bynbo7> i think i wrote that exact program a month ago, using iteratees
04:01:48 <pozic> Bynbo7: so, copy paste it somewhere. 
04:01:54 <Bynbo7> oh, maybe not
04:02:13 <Bynbo7> ah yes, i did
04:03:34 <pozic> Ah, make it 300 times faster in C++, btw. 
04:03:53 <Bynbo7> http://hpaste.org/43645/iteratee_byte_histogram
04:04:29 <Bynbo7> i haven't tested the speed, i just wrote it to learn how to use iteratees
04:04:43 <pozic> Bynbo7: that doesn't output the same as my program.
04:04:51 <Bynbo7> ...
04:04:56 <Bynbo7> i wonder why
04:05:05 <Bynbo7> maybe because i didn't write it to do so?
04:05:15 <pozic> Bynbo7: then you failed to answer the question.
04:05:20 <Bynbo7> ...
04:05:26 <Bynbo7> you're an idiot
04:05:28 <pozic> Bynbo7: you are an arrogant prick.
04:05:43 <Bynbo7> i wasn't trying to answer your question at all
04:05:44 <pozic> Bynbo7: do you really think I do not understand what your program does?
04:05:47 <geheimdienst> please keep it civil, folks
04:05:48 <chrisdone> Alright, chaps.
04:05:54 <pozic> Bynbo7: so, why wo you say anything at all then?
04:06:05 <Bynbo7> ... because tyou asked me to!
04:06:08 <pozic> Bynbo7: "oh, look, I use iteratees". 
04:06:13 <Bynbo7> i told me to paste the code, so i did
04:06:13 <pozic> Bynbo7: no, I did NOT.
04:06:23 <pozic> Bynbo7: you said it solved the exact same problem. 
04:06:27 <pozic> Bynbo7: which it does NOT.
04:06:29 <Bynbo7> i did not
04:06:33 <pozic> Bynbo7: stop wasting my time, TYVM.
04:06:48 <mauke> pozic: stop making me unhappy
04:06:56 <Bynbo7> i said i wrote a program that does the same thing, ie, count make a histogram of the bytes in the file
04:07:03 <Bynbo7> you asked me to pate it, so i did
04:09:16 <pozic> Bynbo7: "i think i wrote that exact program a month"<- your words
04:09:18 <chrisdone> copumpkin: For now, I put a watcher on it to restart it if it doesn't respond. At any rate, I want to make it easy to install and setup and hack on, so I might switch to Snap and HaskellDB.
04:09:36 <Bynbo7> -_-
04:09:37 <pozic> Bynbo7: in reference to the program I wrote. 
04:09:58 <pozic> Bynbo7: even then what you pasted is not a program.
04:10:06 <pozic> Bynbo7: it is a function with free types. 
04:10:13 <Bynbo7> i didn't even paste the whole program
04:10:22 <pozic> Bynbo7: no, you pasted garbage. 
04:10:33 <Bynbo7> ha
04:10:38 <pozic> Bynbo7: if you do not intend to answer, do not answer at all.
04:10:41 --- mode: ChanServ set +o mauke
04:10:41 --- mode: mauke set +q $a:pozic
04:10:49 <Bynbo7> thank you mauke 
04:11:11 <geheimdienst> the right thing, mauke
04:11:13 <chrisdone> copumpkin: (I expect it's one of the C-library-based libraries I'm using, that tends to be a common cause of a program just ending instead of throwing an exception ...)
04:11:26 <geheimdienst> possibly a last warning would have been in order, but bah
04:11:31 --- mode: mauke set -o mauke
04:11:52 <Bynbo7> i don't get why we've been getting so many frustrating people in here lately
04:12:00 <Bynbo7> this weekend has been horrible
04:12:14 <aristid> Bynbo7: something to do with universities maybe?
04:12:20 <dankna> I only just arrived, but I think it just has to do with our exposure reaching some sort of tipping point
04:12:27 * chrisdone rubs lambda-oil on Bynbo7's temples
04:12:29 <dankna> (I didn't see whatever conversation prompted it)
04:12:38 <Bynbo7> why thank you chrisdone 
04:12:45 <dankna> so by the way!  design question time!
04:12:48 <Saizan> pozic has been here for years
04:12:52 <Bynbo7> whoo!
04:12:57 <dankna> I am working on a replacement for hoc, the Haskell-ObjC bridge
04:13:08 <chrisdone> Nice.
04:13:20 <Bynbo7> oh excellent
04:13:23 <dankna> thanks.  here's the question.  well, here's some more explanation, followed eventually by the question.
04:13:27 <burp> chrisdone: do you write ljorban?
04:13:40 <dankna> the hoc groveller actually used reflection as far as I can tell
04:13:56 <dankna> mine is using the thoughtfully-provided "bridge support" XML files
04:14:00 <chrisdone> burp: 'Fraid I don't know what that is.
04:14:24 <dankna> these files provide vast stores of information which would not be available at runtime, or even to a c2hs-style approach
04:14:24 <burp> oh sorry I mean, lojban ;)
04:14:37 <dankna> for example, they provide information on the semantics of constants, not just their types
04:14:37 <chrisdone> copumpkin: (FWIW here's the custodian log: http://hpaste.org/fastcgi.log)
04:14:44 * geheimdienst hands Bynbo7 a lambdakitty. i didn't see the whole run-up, but fwiw, i thought you were a little abrupt with the "you're an idiot". just for future reference.
04:15:00 <chrisdone> burp: Do I write it, habitually? Or do you mean the package?
04:15:05 <dankna> sometimes they mention "by the way, this constant is a pointer, but don't try to access it - it's an out-of-band value"
04:15:28 <dankna> is it appropriate to model this in the generated .hs files?
04:15:31 <dankna> if so, how?
04:15:35 <Bynbo7> geheimdienst: I've been dealing with a much higher amount of annoying people on IRC over the last three days than usual, so I'm starting to get a little pissed off
04:15:42 <burp> chrisdone: habitually, just asking because I saw your bot package
04:16:19 <aristid> dankna: yeah, make a type for opaque pointers :)
04:16:30 <Saizan> Bynbo7: if you keep reacting like a pissed off person the number of annoying incidents will only increase though :)
04:16:38 <chrisdone> burp: Oh. Not much these days. I'm working on a chatterbot that learns on and off. But talking it much now.
04:16:39 <dankna> aristid: yeah, rather, one type for each type of opaque pointer :)
04:16:55 <Bynbo7> Saizan: this is true. doesn't make it any easier to not get pissed off though
04:17:10 <dankna> aristid: but for example, if the constant is kCFAllocatorUseContext (actually, this appears to be the one and only instance of the problem in the entire corpus...)
04:17:18 <dankna> that's actually a -1 or something, I assume
04:17:31 <Bynbo7> and now he's abusing me in PM's
04:17:35 <dankna> and can only be passed to some of the functions that are expecting a CFAllocator, not all of them
04:18:27 <dankna> I guess it doesn't really need to model that restriction
04:18:39 <dankna> especially since it can't - I don't have information on which functions are "okay"
04:18:50 <dankna> and double-especially since it's only the one instance
04:19:17 <dankna> anyway, sorry for talking over your other conversation, I now return you to it :)
04:21:45 <geheimdienst> Bynbo7: fwiw, i find your byteHistogram clear and informative. i've just started checking out iteratees since i kept hearing the term.
04:22:07 <dankna> a related design problem that just occurred to me is name-prefix-mapping
04:22:21 <geheimdienst> mauke: it's been 10 minutes now. do you think it's appropriate to un-"q" pozic?
04:22:24 <dankna> I think I shall provide a hardcoded list of name prefixes that get translated into packages
04:22:39 <mauke> geheimdienst: default timer is set to 1h
04:22:46 <geheimdienst> oh i see
04:22:51 <aristid> dankna: meh, imperative interfaces can be pretty messy
04:22:56 <Bynbo7> geheimdienst: yeah, the only reason i wrote it was to see if i could write it. I'm sure the performance sucks, but who cares right? that wasn't the point (and in my experience it did happen to be extremely fast
04:23:15 <dankna> aristid: they surely can, but we must deal with them naetheless
04:23:35 <aristid> dankna: yep.
04:25:14 <Bynbo7> geheimdienst: http://hpaste.org/paste/43645/iteratee_byte_histogram_annot#p43646 has main as well, if you're interested in seeing how to use it :)
04:25:43 <Bynbo7> geheimdienst: i think I might write a version using LLVM as well, just for funsies :)
04:26:31 <geheimdienst> good addition. thanks.
04:27:19 <Bynbo7> but first, i have a C++ book to read, and a hot bath to have. later all
04:27:32 <geheimdienst> yeah, later
04:28:06 <dankna> and then we've got the enumerated constants
04:28:18 <dankna> it would be too much to hope that these could be grouped nicely together
04:28:30 <dankna> instead we just have name-value pairs for them
04:29:00 <dankna> I think I'm simply going to translate each one as, for example, nsFontPanelSizeModeMask :: Int64 ; nsFontPanelSizeModeMask = 2
04:29:07 <Wooga> i wonder, if i have a pure function, which happens to need sometimes something from outside world and if i want to use iteratee; should i make this function whole big iteratee?
04:29:13 <dankna> although Int64 is probably the wrong type, hm
04:29:23 <dankna> this is very C-oriented as you can see
04:29:26 <Wooga> or is it possible to seperate this function from itetatee body?
04:29:33 <dankna> in C these were preprocessor constants
04:30:35 <dankna> it would be splendiferous if we could pair them with the functions they are meant to be parameters to, or something
04:30:49 <dankna> but we cannot!  so.
04:31:09 <dankna> pardon my thinking out loud, but it's early in the morning and nobody else is really using the channel :) tell me to stop and I will
04:31:14 <geheimdienst> dankna, not sure what constraints you're working under, but xlib does it thusly: file://localhost/usr/share/doc/haskell-x11/html/Graphics-X11-Types.html
04:31:27 <dankna> did you just link me to a localhost url? :)
04:31:38 <dankna> @hackage haskell-x11
04:31:38 <lambdabot> http://hackage.haskell.org/package/haskell-x11
04:31:40 <aristid> dankna: it's not early in the morning in yurop :)
04:31:47 <dankna> aristid: true true
04:31:54 <geheimdienst> yes sorry :)
04:32:09 <ski> (aristid : it feels that way, to me ..)
04:32:24 <geheimdienst> http://hackage.haskell.org/packages/archive/X11/latest/doc/html/Graphics-X11-Types.html
04:32:24 --- mode: ChanServ set +o mauke
04:32:24 --- mode: mauke set +b $a:pozic
04:32:27 <dankna> thanks
04:32:37 <geheimdienst> it's always early morning in my personal 1-man timezone
04:32:49 <dankna> ah yes, I see
04:33:05 <dankna> that's a good approach
04:33:08 <Bynbo7> mauke: what was the ban for? just curious
04:33:14 --- mode: mauke set -o mauke
04:33:15 <geheimdienst> anyhoo, lots of special-purpose types, sometimes used only in one function. it's quite convenient because ghc catches a lot of errors
04:33:32 <mauke> Bynbo7: he told me to fuck myself in privmsg, then quit
04:33:45 <Bynbo7> ah, so i wasn't the only one :)
04:33:58 * chrisdone has also experienced PM abuse from that guy
04:34:07 <dankna> the problem is that the Cocoa API is orders of magnitude larger than the X11 one
04:34:26 <dankna> so whatever data we can extract automatically is pretty much what we're stuck with
04:34:39 <geheimdienst> true, true
04:35:29 <dankna> still it's good to keep this style in mind at least
04:35:59 <dankna> I think I'll at least define a type CEnum = Int32
04:36:19 <dankna> and use that for everything
04:37:59 <geheimdienst> how are you extracting the cocoa api? i'm interested because i got to deal with obj-c sometimes at work
04:39:15 <dankna> oh, Apple has extracted it for us - it's how PyObjC and RubyCocoa work
04:39:44 <dankna> there are giant XML files with all this semantic information inside the .frameworks
04:39:59 <dankna> not all .frameworks, only the ones that have had it prepared, but that's all the important system ones
04:40:31 <dankna> they were constructed with a tool that's also available, which does a mix of reflection, header-parsing, and hand-coded overrides
04:40:41 <dankna> so since a lot of work has gone into constructing them I figure I might as well use them, eh.
04:40:51 <geheimdienst> yes absolutely
04:40:56 <geheimdienst> interesting, thanks
04:40:58 <dankna> np
04:45:23 <geheimdienst> wikipedia: "Independently binding the Cocoa API is a major undertaking since Apple chose an extremely convoluted (and equally poorly documented) scheme of message passing via libObjC as the main route.[citation needed]"
04:47:18 <dankna> citation needed indeed.  I don't find it poorly documented at all.  too verbosely documented if anything.
04:47:24 <dankna> but it IS a major undertaking.
04:47:38 <dankna> (I'm not sure what source one cites to show the lack of documentation, haha)
04:50:53 <Maxdamantus> Is there something similar to Data.Map.adjust, but which applies the function to a given default value incase the key doesn't exist?
04:52:25 <Maxdamantus> Can't see anything in the docs, but there is a huge set of operations, and I'd imagine it'd be quicker to do it in one pass rather than first checking whether it exists then inserting/updating.
04:53:21 <Maxdamantus> Oh, alter seems to be it.
04:55:05 <Veinor> dankna: i assume you cite someone who's a computer person saying 'this is poorly documented'
04:56:07 <geheimdienst> you should cite the nonpartisan Institute for Determining Documentation Poverty
05:10:39 --- mode: ChanServ set +o mauke
05:10:39 --- mode: mauke set -q $a:pozic
05:11:29 --- mode: mauke set -o mauke
05:14:24 * hackagebot representable-tries 0.2.3 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.2.3 (EdwardKmett)
05:19:57 <ksf> @pl (\h t -> h)
05:19:58 <lambdabot> const
05:20:31 <Maxdamantus> @pl asTypeOf
05:20:31 <lambdabot> asTypeOf
05:20:36 <ksf> yet another example of using something I don't grok.
05:20:43 <ksf> ...usually, I'm using const with an argument.
05:21:25 <ksf> @pl (\h t -> t)
05:21:26 <lambdabot> const id
05:21:44 <Maxdamantus> @unpl asTypeOf
05:21:44 <lambdabot> asTypeOf
05:22:24 <fryguybob> @type let k x _ = x; s f g x = (f x) (g x) in s k k
05:22:25 <lambdabot> forall t. t -> t
05:23:20 <fryguybob> @type const <*> const
05:23:21 <lambdabot> forall b. b -> b
05:23:44 <geheimdienst> > (const <*> const) 42
05:23:45 <lambdabot>   42
05:23:55 <geheimdienst> that was a little anticlimactic
05:23:58 <fryguybob> :D
05:24:12 <geheimdienst> what would you use const <*> const for?
05:24:24 <fryguybob> id of course
05:24:26 * hackagebot representable-tries 0.2.3.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.2.3.1 (EdwardKmett)
05:24:54 <edwardk> @type const <*> const
05:24:55 <lambdabot> forall b. b -> b
05:25:26 <Bynbo7> :t k k k
05:25:26 <lambdabot>     Couldn't match expected type `Expr -> Expr -> t'
05:25:27 <lambdabot>            against inferred type `Expr'
05:25:27 <lambdabot>     In the expression: k k k
05:25:39 <aristid> :t k
05:25:40 <lambdabot> Expr
05:25:43 <aristid> :t f f f
05:25:43 <lambdabot>     Ambiguous type variable `a' in the constraints:
05:25:44 <lambdabot>       `SimpleReflect.FromExpr a'
05:25:44 <lambdabot>         arising from a use of `f' at <interactive>:1:2
05:25:46 <aristid> :t f
05:25:47 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:25:52 <aristid> :t f :: Expr
05:25:53 <lambdabot> Expr
05:25:58 <aristid> :t f f f :: Expr
05:25:59 <lambdabot>     Ambiguous type variable `a' in the constraints:
05:25:59 <lambdabot>       `Show a' arising from a use of `f' at <interactive>:1:0-4
05:25:59 <lambdabot>       `SimpleReflect.FromExpr a'
05:25:59 <Bynbo7> :t let k x _ = x in k k k
05:26:00 <lambdabot> forall t t1. t -> t1 -> t
05:26:17 <Bynbo7> :t let k x _ = x in k k k k
05:26:18 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> t1
05:26:21 <Bynbo7> :t let k x _ = x in k k k k k
05:26:22 <lambdabot> forall t t1. t -> t1 -> t
05:26:23 <aristid> :t (f :: Expr -> Expr -> Expr) f f
05:26:24 <lambdabot> Expr
05:26:24 <Bynbo7> :t let k x _ = x in k k k k k k
05:26:25 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> t1
05:26:26 <aristid> > (f :: Expr -> Expr -> Expr) f f
05:26:27 <lambdabot>   f f f
05:30:32 <edwardk> playing around with representations and adjunctions i just now realized that the the cofree comonad of an representable functor f that has representation 'a'  is a representable functor, with representation [a]. i'm a bit slow some days
05:31:18 <Bynbo7> thought for a minute you were talking about the coffee monad :)
05:31:22 <Bynbo7> uh, comonad
05:31:46 <edwardk> i clearly need to start drinking the decaf comonad if i'm going to ever get some sleep
05:31:47 <Martty> coffee + monad = comonad
05:34:10 <harlekin> I have a Intel Wirless 5000 card and loaded modules iwlagn, iwlcore, mac80211, cfg80211. ifconfig -a still doesn't show the card. What module could be missing?
05:34:19 <Bynbo7> @hoogle f (g a) -> g (f a)
05:34:19 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
05:34:19 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
05:34:19 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:34:24 <harlekin> Woops. Wrong channel. Sorry.
05:34:26 <aristid> :t u
05:34:26 <lambdabot> Expr
05:34:35 <Bynbo7> harlekin: heh, i was going to say :)
05:40:11 <wto> > map succ "wto"
05:40:12 <lambdabot>   "xup"
05:40:59 <chrisdone> Someone in here told me that select count(*) is slower than select count(id) in PostgreSQL. I'm pretty sure it's not. It would be optimised away.
05:41:05 <chrisdone> :t succ
05:41:05 <lambdabot> forall a. (Enum a) => a -> a
05:42:08 <geheimdienst> > map succ "chrisdone"
05:42:08 <lambdabot>   "disjtepof"
05:42:38 <wto> chrisdone: that sounds reasonable.
05:42:44 <chrisdone> > concat $ group "geheimdienst"
05:42:45 <lambdabot>   "geheimdienst"
05:43:02 <chrisdone> > concat $ group "lambdabot"
05:43:03 <lambdabot>   "lambdabot"
05:43:10 <Maxdamantus> @pl unfoldr (Just . (\(a, b) -> (b, a)) . (`divMod` 10))
05:43:10 <lambdabot> unfoldr (Just . uncurry (flip (,)) . (`divMod` 10))
05:43:17 <chrisdone> Oh, yeah. Group preserves order.
05:44:02 <jix> chrisdone: I think there was a way to let postgres output the result of the query planner.. EXPLAIN or something like that
05:44:28 <jix> chrisdone: that might show that count(*) does the exact same thing as count(id)
05:49:20 <chrisdone> Jiten: I'll try that.
05:50:16 <chrisdone> It says that the aggregate with differs.
05:50:23 <aristid> > unfoldr (Just . uncurry (flip (,)) . (`divMod` 10)) $ 123
05:50:25 <lambdabot>   [3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:51:04 <chrisdone> yogurt=> explain select count(*) from "user";
05:51:04 <chrisdone>  Aggregate  (cost=1243.54..1243.55 rows=1 width=0)
05:51:04 <chrisdone> yogurt=> explain select count(id) from "user";
05:51:04 <chrisdone>  Aggregate  (cost=1243.54..1243.55 rows=1 width=4)
05:51:05 <hewei> Hi there, how can I find where "instance Applicative (Either e)" is defined please? 
05:51:11 <aristid> @ let swap = uncurry $ flip (,)
05:51:14 <aristid> @let swap = uncurry $ flip (,)
05:51:14 <lambdabot>  Defined.
05:51:17 <chrisdone> jix: So I suppose the size could indeed change the speed.
05:51:22 <aristid> > unfoldr (Just . swap . (`divMod` 10)) $ 123
05:51:24 <lambdabot>   [3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:51:54 <chrisdone> jix: Though I don't really know what width means...
05:52:52 <jix> chrisdone: what would explain select * from "user"; and explain select id from "user"; output?
05:53:04 <jix> chrisdone: I can imagine it is the amount of bytes (or some other unit) to be fetched per row
05:53:28 <geheimdienst> "cost" seems totally the same, to me
05:53:47 <chrisdone> id: Seq Scan on "user"  (cost=0.00..1137.63 rows=42363 width=4)
05:53:49 <chrisdone> *: Seq Scan on "user"  (cost=0.00..1137.63 rows=42363 width=645)
05:54:22 <Bynbo7> odd
05:54:24 <chrisdone> jix: So it seems like * costs zero bytes, where as id costs 4 (id is an int) 
05:54:41 <chrisdone> Jiten: (I mean when using count())
05:54:42 <jix> chrisdone: yeah, but the cost estimate still is the same for both
05:54:57 <chrisdone> Right.
05:55:25 <geheimdienst> possibly width is only really relevant for joins?
05:55:59 <jix> chrisdone: I guess there is no difference because counting the records (without index) means fetching them all. And looking at just the header (or whatever there is) or at the header + id makes no difference for disk reads.
05:56:19 <jix> but eh I'm just guessing here
05:56:40 * chrisdone nods
05:57:33 <jix> hewei: usually it's efined close to data Either _or_ close to class Applicative
06:00:13 <kingping> hello
06:00:34 <hewei> jix: thanks, but I import both Data.Either and Control.Applicative, but don't get the instance definition ...
06:01:22 <geheimdienst> > fmap (+1) $ Just 3
06:01:23 <lambdabot>   Just 4
06:01:43 <geheimdienst> :t fmap (+1) Just
06:01:44 <lambdabot> forall a. (Num (Maybe a)) => a -> Maybe a
06:01:52 <geheimdienst> > fmap (+1) $ Left 3
06:01:53 <lambdabot>   Left 3
06:01:57 <geheimdienst> > fmap (+1) $ RIght 3
06:01:58 <lambdabot>   Not in scope: data constructor `RIght'
06:02:06 <geheimdienst> :t fmap (+1) Left
06:02:07 <lambdabot> forall a b. (Num (Either a b)) => a -> Either a b
06:10:43 <aristid> geheimdienst: haha
06:10:51 <aristid> :t fmap (+1) . Left
06:10:51 <lambdabot> forall a a1. (Num a) => a1 -> Either a1 a
06:12:28 <fryguybob> @type flip fmap . Left
06:12:29 <lambdabot> forall a b a1. a1 -> (a -> b) -> Either a1 b
06:12:33 <fryguybob> @type flip fmap . Right
06:12:33 <lambdabot> forall a b a1. a -> (a -> b) -> Either a1 b
06:25:42 <gwern> yay! pandoc no longer emits ugly HTML!
06:26:15 <gwern> it's... so... *beautiful*
06:26:36 <hewei> jix: It seems that instance Applicative (Either e) is not defined in 6.12.3 but in GHC 7 
06:26:50 <wires> I'm trying to cabal install hprotoc-1.8.1 but it fails with "Could not deduce (Functor r) from the context (Monad r)", full error here: http://hpaste.org/43648/compiling_hprotoc181_fails Any ideas?
06:30:21 <aristid> gwern: day saved
06:30:32 <gwern> aristid: well, that alone makes it a good day
06:30:37 <aristid> :)
06:30:50 <gwern> I'd given up
06:31:11 <gwern> I feel like one of those dogs used in learned helplessness experiments where the researchers suddenly got bored and turned off the electrification
06:32:34 <gwern> if you know what I mean
06:33:55 <chrisdone> gwern: "I want a bone!"?
06:34:06 <gwern> no. that is not what I meant.
06:34:20 <edwardk> hewei: its in Control.Monad.Instances
06:34:38 <edwardk> if its anywhere ;)
06:34:47 <aristid> gwern: you mean that you're used to getting nearly electrocuted by ugly HTML every day, and now suddenly the near-electrocution stopped?
06:34:53 <theorbtwo> You find yourself with sunnden freedom, but don't quite believe it won't be snatched away if you take it?
06:35:07 <gwern> aristid and theorbtwo are much closer than chrisdone ~-~
06:35:17 <chrisdone> It's pretty obvious what he meant. I was joking.  O__________________O
06:35:34 <aristid> chrisdone: that's what you would say NOW :p
06:35:48 <edwardk> ah, rather Control.Applicative exports it, C.M.I defines the functor/monad instances
06:45:40 * hackagebot representable-functors 0.3.0.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.3.0.1 (EdwardKmett)
06:45:42 * hackagebot adjunctions 0.9.0.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.9.0.1 (EdwardKmett)
06:46:39 <hewei> edwardk: I see it here under GHC 7: 
06:46:41 <hewei> instance Applicative (Either e) -- Defined in Control.Applicative
06:46:42 <hewei>  
06:48:31 <aristid> hewei: without any constraint on e?
06:48:49 <aavogt> they changed it apparently
06:49:11 <aavogt> or maybe that was something else
06:49:11 <aristid> aavogt: srsly?
06:49:33 <edwardk> aavogt: we killed the 'e' constraints a while back
06:49:38 <kingping> > scanl1 (+) [1..5]
06:49:39 <lambdabot>   [1,3,6,10,15]
06:49:45 <edwardk> aavogt: the fail just blows up now.
06:49:49 <aristid> edwardk: but after 6.12?
06:49:49 <edwardk> thank god
06:49:59 <edwardk> it was in that general timeframe
06:50:11 <edwardk> so i don't know which release it went into
06:50:24 <aristid> edwardk: my 6.12.1 (i know, old) still has the constraint
06:50:44 <kingping> > :t (+)
06:50:45 <lambdabot>   <no location info>: parse error on input `:'
06:50:49 <kingping> :t (+)
06:50:50 <lambdabot> forall a. (Num a) => a -> a -> a
06:50:55 <aavogt> there's another data just like Either with some class providing what's inside the Left?
06:51:22 <edwardk> 6.12.3 still had it off in mtl or some crap
06:51:22 <aristid> edwardk: or, wait. WHERE does the Either monad/applicative come from?
06:51:25 <ManateeLazyCat> Hi all. :)
06:51:37 <aristid> edwardk: mtl 2.0 still has Control.Monad.Error, i think
06:51:52 <edwardk> aristid: yes, but it no longer provides the instance for Either
06:52:03 <aristid> instance Monad (Either e) -- Defined in Control.Monad.Trans.Error
06:52:05 <aristid> wtf
06:52:08 <aristid> without constraint
06:52:13 <aristid> but in Error
06:52:18 <edwardk> or re-exported?
06:52:18 <aristid> for compat, i guess
06:52:31 <aavogt> well that's not really compatibility
06:52:37 <aristid> edwardk: it's a good change, tho
06:52:44 <ManateeLazyCat> Why all repositories in code.haskell.org is empty?
06:52:55 <ManateeLazyCat> Down again?
06:53:02 <aavogt> ManateeLazyCat: they are working on replacing the server
06:53:11 <aavogt> it got hacked or something earlier this week
06:53:30 <ManateeLazyCat> aavogt: Still in replace? Why *always* replace server? 
06:53:43 <gienah> gentoo gave up on c.h.o and moved the repo to github
06:53:46 <Bynbo7> ManateeLazyCat: this is the first time they've done anything to code.haskell.org
06:53:50 <aristid> gienah: hah.
06:54:22 <aristid> how reliable is patch-tag?
06:54:41 <ManateeLazyCat> Bynbo7: I don't know, but server problem is terrible, i use patch-tag.com instead.
06:54:47 <aavogt> aristid: better than c.h.o?
06:54:50 <edwardk> aristid: note they only provide the Either instances for versions of base before 4.3
06:55:01 <aristid> edwardk: that makes sense.
06:55:02 <edwardk> aristid: otherwise its assumed to be in base
06:55:03 <Bynbo7> ManateeLazyCat: this is why they're trying to move to a new server
06:55:10 <gienah> I had no problem building happstack using darcs (happstack uses patch-tag)
06:55:12 <ManateeLazyCat> Bynbo7: I use c.h.o before, but i can't access my response when i wake up (in Chinese time).
06:55:43 <edwardk> gah. seeing that module reminds me i need to dualize some of the mtl machinery still
06:55:53 <ManateeLazyCat> Bynbo7: Hope new server works well, i can't access gtk2hs repository now.
06:55:58 <edwardk> aristid: it drove me away from darcs completely
06:56:07 <ManateeLazyCat> Bynbo7: gtk2hs homepage down long time.
06:56:09 <aristid> edwardk: what? c.h.o?
06:56:16 <edwardk> aristid: no, patchtag
06:56:19 <aristid> oh.
06:56:23 <edwardk> thats why all my stuff is on darcs now
06:56:26 <ManateeLazyCat> aavogt: Yeah, i think so.
06:56:47 <aristid> edwardk: there's no high-quality hosting for darcs
06:56:53 <aristid> => github wins :)
06:56:57 <Bynbo7> indeed
06:57:00 <edwardk> er sorry s/darcs/git/
06:57:12 <aristid> i figured that you meant git :)
06:57:12 <Bynbo7> i used to use darcs, but gid is just so much easier to share your code with
06:57:14 <edwardk> i defected to github and once i got over the initial hurdle, rather like it
06:57:18 <Bynbo7> and work with other people
06:57:20 <ManateeLazyCat> edwardk: AFAIK, patch-tag.com is best host for darcs.
06:57:37 <edwardk> ManateeLazyCat: after it ate a dozen repos of mine, i bailed.
06:57:44 <Bynbo7> ManateeLazyCat: it's got nothing on github though
06:58:08 <Bynbo7> ManateeLazyCat: uh, i should say, it's crap compared to github, that was a pretty strange use of english i used then, sorry :P
06:58:09 <edwardk> and i'm much happier with github than i've been with any other version control hosting solution
06:58:12 <ManateeLazyCat> Bynbo7: If github support darcs, i will switch.
06:58:27 <Bynbo7> well... no, it only supports git
06:58:49 <Bynbo7> i guess you could use it to have a github repo of a darcs repo =)
06:58:52 <edwardk> git vs. darcs for a single developer workflow isn't all that different.
06:58:57 <ManateeLazyCat> Bynbo7: Github is awesome, but now i just want to use darcs, maybe i'm keyboard guy. :)
06:59:06 <mm_freak> is there a GHC version, which uses epoll already?
06:59:08 <edwardk> ManateeLazyCat: so am i ;)
06:59:40 <Bynbo7> edwardk: aye, if it was just me, I'd probably chose darcs, because it has a much nicer interface
06:59:52 <Bynbo7> but got working with a bunch of people, it much easier with git
07:00:05 <Bynbo7> which is why I'm glad the GHC team are moving to git
07:00:22 <mm_freak> Bynbo7: are you a GHC developer?
07:00:24 <edwardk> Bynbo7: i mostly got sick of dealing with things like making sure that comonad.com was online so i could upload my haddocks, etc.
07:00:34 <Bynbo7> mm_freak: I'd like to be :)
07:00:40 <mm_freak> ah, ok
07:00:43 <ManateeLazyCat> Bynbo7: I heard git have better support on merge features.
07:00:46 <edwardk> mm_freak: git admits a much easier multi-developer workflow
07:01:03 <edwardk> mm_freak: lots of folks _would_ hack on ghc, if they could do so less painfully
07:01:04 <mm_freak> i heard that GHC 7's RTS uses epoll instead of select, is that true?
07:01:12 <aavogt> Bynbo7: are they actually?
07:01:13 <edwardk> mm_freak: thats the gist of it
07:01:17 <Bynbo7> ManateeLazyCat: much nicer, it just works how it should
07:01:18 <mm_freak> edwardk: i see
07:01:32 <Bynbo7> aavogt: yes, i hear once 7.0.2 is release, they'll make it official
07:01:49 <aavogt> edwardk: building ghc is another hurdle
07:01:56 <edwardk> true enough
07:02:55 <edwardk> ManateeLazyCat: clearly you should pick up iolaus and finish it. then you can work darcs-style on git ;)
07:03:26 <retrofit> !ops
07:03:42 <Bynbo7> ?
07:03:58 <edwardk> i think he wanted to bang the ops
07:04:04 <ManateeLazyCat> edwardk: I hope one day, i can build better interface for darcs, then darcs focus on algorithm.
07:04:04 <Bynbo7> oh no :o
07:04:09 <Bynbo7> oh my even
07:04:15 <ManateeLazyCat> edwardk: iolaus? Link?
07:04:32 <edwardk> https://github.com/droundy there are two repos there iolaus and iolaus-broken
07:04:34 <Bynbo7> IO Laus
07:04:54 <edwardk> its a git 'porcelain' that makes git feel like darcs by handling heads in the darcs fashion
07:05:16 <aristid> it is supposed to be Steinlaus, not IO Laus
07:05:17 <edwardk> he seems to have gotten bored with it
07:05:55 <mm_freak> ah, seems like GHC 6.13 does epoll
07:05:57 <Yvemath> Which haskell ebook would ya recommend/prefer for a starter. I've had my experiences with BASIC,C,C++,Java,VB.net,PHP,Perl and currently diving in Python ?
07:06:25 <mauke> are there that many haskell ebooks?
07:06:29 <edwardk> Yvemath: there are 2-3. "Learn You a Haskell" is a good tongue in cheek introduction available in deadtree and web form
07:06:47 <monadic_kid> mauke: there was YAHT
07:06:59 <Bynbo7> Yvemath: LYAH, and you should try and forget everything you know about all those languages ;)
07:07:00 <edwardk> Yvemath: "Real World Haskell" serves as a good counterpoint to LYAH, the former goes more steadily through the material while the latter goes in fits and starts
07:07:02 <Bynbo7> @where lyah
07:07:03 <lambdabot> http://www.learnyouahaskell.com/
07:07:05 <ManateeLazyCat> Yvemath: http://learnyouahaskell.com/
07:07:10 <gienah> slyfox: it did allow it to build, I will try your earlier suggestion and let you know
07:07:14 <edwardk> @where rwh
07:07:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:07:38 <Yvemath> Thanks, all. I'll have a look.. :)
07:07:40 * gienah wrong channel sorry
07:07:40 <edwardk> Real World Haskell is an O'Reilly book by some folks who tend to lurk here on channel
07:07:41 <monadic_kid> The haskell wikibook is a semi decent extra resource as well
07:07:50 <mm_freak> Yvemath: basically forget all of the languages you mentioned, except perhaps python…  and i mean it literally…  free your mind from the programming concepts you've used so far, because they'll get in your way…  then i heard good things about LYAH
07:07:51 <Bynbo7> Yvemath: you should be willing to accept that haskell is nothing like any of the languages you've mentioned
07:07:52 <aristid> edwardk: why did you read RWH and LYAH? didn't you already know haskell before reading them?
07:07:59 <sm> morning all. Anyone interested in building better darcs hosting, help alexsuraci/Heffalump/http://darcsden.com
07:08:26 <ManateeLazyCat> Yvemath: mm_freak's *forgot* suggest is most important. ;p
07:08:31 <aristid> sm: did you notice that people were mentioning how terrible darcs hosting options are at this point? :)
07:08:39 <edwardk> aristid: i have a great deal of interest in pedagogy, plus I was kicking around the idea of working on a Haskell book after being contacted by a publisher last year
07:08:43 <mauke> mm_freak: why except perhaps python? IMO some Perl concepts are actually relevant, but python ...?
07:09:03 <Bynbo7> Yvemath: also, the very best resource for learning haskell is this channel
07:09:19 <mm_freak> mauke: python has quite a few functional concepts and also some syntax, which resembles haskell, for example list comprehensions
07:09:23 <edwardk> aristid: but the publisher kind of trailed away, and other shiny things grabbed my eye.
07:09:34 <ManateeLazyCat> It's very funny like Chinese's best KongFu, if you don't forgot, you can't learn it, more like Haskell style. :)
07:09:37 <Yvemath> Bynbo7: ManateeLazyCat: mm_freak: Yes, i'm willing of course. I currently use xmonad, and had been able to manage to configure it as i need. But there are still some operators and some "notations" that seem tricky to me.
07:09:37 <mauke> mm_freak: ok, list comprehensions and significant whitespace
07:09:38 <Bynbo7> with the accompaniment of LYAH and the RWH
07:09:46 <sm> aristid: I addressed my remark to people interested in building better darcs hosting :)
07:09:48 <mauke> mm_freak: but for functional concepts I'd actually go to perl
07:09:57 <luite> edwardk should totally write a haskell tutorial based on all his new shiny packages :)
07:10:01 <mm_freak> mauke: yes, that too, and it also has some functional combinators, though only for lists
07:10:01 <edwardk> aristid: but i bought a copy of both just to support the community and to be able to use them to convince folks locally to try haskell
07:10:11 <mauke> static types: C, C++, Java
07:10:13 <sm> interested in hacking on github ? oh! you can't. Darcsden is much much nicer for that 
07:10:20 <mm_freak> mauke: what i like about python is the somewhat clean lambda syntax…  i think, perl doesn't have this
07:10:23 <aristid> edwardk: now i wonder how many copies RWH sold.
07:10:25 <mauke> explicit (lexical) scoping: Perl
07:10:30 <edwardk> luite: heh, well, i was talking to byorgey about a new generation typeclassopedia ;)
07:10:30 <sm> obviously if you just want to host your project today, github is the place to be
07:10:34 <Bynbo7> Yvemath: Xmonad has somewhat of a DSL for its configuration file. not all haskell will look like that
07:10:35 <mauke> mm_freak: I think perl has the better syntax there
07:10:50 <ManateeLazyCat> Yvemath: Best forgot all about OOP... ;)
07:10:50 <mm_freak> mauke: perhaps i don't know it, what does it look like?
07:11:00 <mauke> mm_freak: sub foo { }  # named function
07:11:04 <aristid> sm: you could apply to github if you want to hack on it :D but yeah, you're right
07:11:08 <mauke> mm_freak: sub { }  # lambda expression
07:11:18 <mm_freak> mauke: python:  lambda x: x+1
07:11:28 <mauke> mm_freak: yes, which sucks
07:11:37 <edwardk> luite: as a means to try to help folks transition from the pointless Pointed to the shiny and elegant semigroupoid based precursors to Applicative, Monad, etc. ;)
07:11:49 <mm_freak> mauke: what exactly sucks about it?  it's almost like haskell
07:11:53 <mauke> mm_freak: 1) it looks nothing like "normal" functions  2) it's limited to a single expression
07:12:09 <Bynbo7> eh?
07:12:10 <Yvemath> Thanks all, i'll try. & ofcourse, what's best is we 've a nice community.
07:12:17 <Bynbo7> you can do lambda x, y: x+y no?
07:12:27 <sm> you can also run your own local darcsden if you prefer more reliability/control. We were just chatting about ways to sync them up
07:12:33 <luite> edwardk: hee
07:12:36 <luite> hehe
07:12:38 <Bynbo7> Yvemath: stick around in here and ask questions :)
07:12:54 <Yvemath> yeah, sure. :)
07:13:03 <mm_freak> mauke: good point, although lambdas in haskell don't look much like normal functions either
07:13:16 <mauke> mm_freak: perl's big failure here is the lack of parameter lists, but otherwise sub { my ($x) = @_; $x + 1 } is fine IMO
07:13:30 <Eduard_Munteanu> sm: so what do they need help with, hacking on the site / hosting engine?
07:13:32 <mauke> mm_freak: well, I can do foo = \x -> x + 1 in Haskell :-)
07:13:47 <mm_freak> except "lambda" vs. "\" and ":" vs. "->" there isn't much difference between haskell and python lambdas
07:13:55 <mm_freak> mauke: f = lambda x: x+1
07:13:56 <mm_freak> ;)
07:14:19 <mauke> mm_freak: f x = x + 1 is invalid, though
07:14:22 <edwardk> well, the room hasn't gone spinning for a couple of hours. i;m going to go see if i can get some sleep
07:14:42 <Bynbo7> I'm going to read my book and then sleep. night all
07:14:49 <Bynbo7> night edwardk 
07:14:55 <mauke> mm_freak: you need parens around the parameters and an explicit return
07:14:57 <Eduard_Munteanu> o/
07:15:13 <ManateeLazyCat> Any cool haskell package release recently? I haven't touch my keyboard some weeks.
07:15:20 <ManateeLazyCat> night edwardk
07:15:32 <edwardk> (wound up with some strange inner ear infection, which has the world tilting sideways from time to time)
07:15:38 <Eduard_Munteanu> Sure, edwardk tried to beat your record with hackage updates :P
07:15:46 <edwardk> here's to the power of antibiotics ;)
07:16:01 <edwardk> ahhaha
07:16:11 <sm> Eduard_Munteanu: a good way to help is running the darcsden engine locally, hacking on it, and feeding improvements to darcsden.com. Improving darcs is also always useful but harder
07:16:30 * Eduard_Munteanu will keep that in mind
07:16:36 <mm_freak> mauke: right, but you view it this way:  lambdas in python are a syntactic improvement over ordinary functions, while in perl you get no improvement in favor of consistent syntax
07:16:37 <Bynbo7> edwardk: you don't have any updates to all your packages to release before you go to sleep? :O
07:16:55 <mm_freak> so it's a pro and contra
07:17:19 <mauke> also, the whole expression/statement distinction is a bigger issue in python
07:17:20 <edwardk> Bynbo7: nah, too much work to round them all up. i need a script to just blip through all the directories. i can almost hear dcoutts screaming now.
07:17:24 <ManateeLazyCat> sm: Are you darcsden.com developer?
07:17:46 <Bynbo7> anyway...
07:17:48 <edwardk> as 50 packages slam into hackage all at once
07:17:49 * Bynbo7 -> sleep
07:17:51 <sm> ManateeLazyCat: I have contributed a couple of patches and talked about it a lot
07:17:51 <mm_freak> mauke: to work around it you can still define lexically scoped funtions, which become closures
07:17:52 <edwardk> yeah
07:18:07 <mauke> mm_freak: yeah, you have to give them names
07:18:08 <sm> hoping to use it to replace darcsweb on my server soon
07:18:16 <sm> it's nice code
07:18:17 <mauke> mm_freak: to me that feels like writing asm
07:18:33 <mauke> I can't write whole expressions; instead I have to name my intermediate results
07:18:43 <mm_freak> mauke: right…  generally i'm not a big fan of python, but i like its syntax over perl's
07:19:06 <ManateeLazyCat> edwardk: Haha, maybe you like my dist-upload, upload package automatically. :)
07:19:10 <mm_freak> at least the layout part
07:19:13 <ManateeLazyCat> @dist-upload
07:19:13 <lambdabot> Unknown command, try @list
07:19:16 <ManateeLazyCat> @package dist-upload
07:19:16 <lambdabot> http://hackage.haskell.org/package/dist-upload
07:19:18 <mauke> I like the good parts of perl too much to enjoy python
07:19:22 <edwardk> ManateeLazyCat: btw- you have the 5th most number of packages of any user on hackage ;)
07:19:47 * hackagebot http-types 0.3.0 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.3.0 (AristidBreitkreuz)
07:19:51 <mm_freak> mauke: dunno, i've never found many good parts in either of them
07:20:22 <ManateeLazyCat> edwardk: Really? Who is first? Dons?
07:20:25 * sm heads afk, later
07:20:26 <ManateeLazyCat> :)
07:20:30 <mm_freak> to me perl feels like a better PHP
07:20:42 <edwardk> dons, me, then henning and snoyman
07:21:06 <edwardk> i may have actually overtaken dons, i haven't checked
07:21:14 <mauke> mm_freak: no manual memory management; convenient syntax for many common tasks; errors don't cause undefined behavior
07:21:28 <edwardk> i know he has more actual _users_, but bah, why rate by a metric you'll never win on ;)
07:21:35 <mm_freak> mauke: which are you now comparing?
07:22:02 <ManateeLazyCat> edwardk: How much gap between the two of us? :)
07:22:07 <mauke> just trying to name some good parts of perl and python
07:22:17 <mauke> well, the other side would be something like C
07:22:18 <mm_freak> mauke: ah, yes
07:22:31 <aristid> edwardk: woah, you dominate the what's new list
07:22:33 <ManateeLazyCat> edwardk: I haven't write haskell code almost one month.
07:22:36 <edwardk> 29 vs. ~48
07:22:37 <gh_> hi, what's the difference between "import Module" and "import Module ()"?
07:22:49 <ManateeLazyCat> edwardk: I will start again in one week. :)
07:22:54 <mauke> gh_: import all symbols vs. import nothing
07:22:54 <edwardk> ManateeLazyCat: hahahaha
07:23:08 <edwardk> yeah you mentioned you were going to go visit family far away from the internet or some such
07:23:09 <Veinor> import Module () is only useful if Module has some typeclass instances
07:23:12 <xplat> > ((const "Error") `either` head) <$> [Left "Timeout", Right ["foo", "bar"]]
07:23:13 <lambdabot>   ["Error","foo"]
07:23:16 <ManateeLazyCat> edwardk: Don't worried, i will reach you very soon. :)
07:23:30 <edwardk> ManateeLazyCat: you're welcome to do so
07:23:33 <gh_> mauke, thanks.
07:23:37 <gh_> Veinor, indeed it has.
07:23:54 <edwardk> my stuff is mostly generalized abstract nonsense
07:24:19 <mm_freak> mauke: well, i think that's not a fair comparison…  i don't view C as a high level language (and i'm not sure how anyone can get anything done in C)
07:24:22 <xplat> returns a function which applies the left or right operand, depending if the argument is Left or Right :)
07:24:31 <mauke> mm_freak: perl as a better PHP kind of hurts :-/
07:24:58 <mm_freak> mauke: except a lot more syntactic sugar, what does it have, what PHP lacks?
07:24:59 <Maxdamantus> Errors don't cause UB in C .. bad code does.
07:25:02 <mauke> on the other hand, you have to wonder about PHP, given that it's younger than perl (and originally was a perl script)
07:25:09 <xplat> well, consider that perl was a better PHP before PHP was even invented, or at least before anybody knew it was invented ...
07:25:18 <Maxdamantus> Hm. I guess bad coding could be said to be an error of the programmer.
07:25:21 <mauke> mm_freak: sane scoping
07:25:32 <mauke> mm_freak: that's something I miss in PHP, python, and javascript
07:25:39 <mauke> in order of depreference
07:25:41 <xplat> PHP: improving perl by making it worse
07:26:16 <mm_freak> where does perl have better scoping than PHP?
07:26:23 <mauke> uh, everywhere?
07:26:27 <aristid> mauke: woah, parsing the word depreference was hard for me
07:26:33 <mm_freak> mauke: i need an example
07:26:38 <aristid> it took almost 5 seconds
07:26:46 <Veinor> i parsed it as 'dep reference'
07:26:55 <aristid> Veinor: me too, but i backtracked
07:27:18 <mauke> mm_freak: sub mk_counter { my ($i) = @_; sub { $i++ } } my $f = mk_counter 42;
07:27:36 <xplat> perl has proper block scoping, if you use 'my'.  it suks that sometimes you have to use 'our' or 'local', though.
07:27:46 <mauke> 'local' is unrelated to scoping
07:27:57 <aristid> local is a very funny hack
07:28:01 <ManateeLazyCat> @time 
07:28:02 <lambdabot> Local time for ManateeLazyCat is Sat Feb  5 23:45:29 2011
07:28:05 <aristid> @time
07:28:06 <lambdabot> Local time for aristid is Sat Feb 5 16:45:32 2011
07:28:09 <aristid> @time mauke
07:28:14 <ManateeLazyCat> Good night all, i need some sleep. :)
07:28:17 <xplat> mauke: it's related in that it has to be used as a substitute for scoping with special variables that don't obey scoping
07:28:34 <mauke> xplat: if they obeyed scoping, they would be useless
07:29:10 <mauke> aristid: try again :-)
07:29:19 <aristid> @time mauke
07:29:20 <lambdabot> Local time for mauke is 25:12:62 AM
07:29:20 <lambdabot> Local time for mauke is 25:12:62 AM
07:29:24 <aristid> twice, even
07:29:35 <xplat> mauke: $_ wouldn't be, although it would be less use
07:29:36 <aristid> mauke: but that time is invalid :(
07:29:39 <mauke> aristid: that's what happens when the first one doesn't get a reply
07:29:49 * hackagebot xmlhtml 0.1 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1 (ChrisSmith)
07:29:54 <mauke> xplat: and $_ obeys scoping now
07:29:58 <mauke> xplat: in that you can say 'my $_'
07:30:04 <aristid> mauke: since when? oO
07:30:09 <mauke> some time now
07:30:17 <aristid> mauke: i still mostly use 5.8 :D
07:30:18 <xplat> yeah, i was going to say that this situation was improving even in the perl5 branch
07:30:56 <mauke> aristid: 5.10.0 (current is 5.12.3)
07:31:07 <mm_freak> mauke: well, in PHP only local scoping is implicit
07:31:16 <mm_freak> you need to be explicit about global or closure scopes
07:31:20 <mauke> mm_freak: implicit scoping is failure
07:31:27 <aristid> mauke: that explains why. i can't choose the version of Perl tho. (corporate... they still use IE 6 there)
07:31:34 <mauke> PHP doesn't have real local scope, only function scope
07:31:35 <mm_freak> mauke: haskell has implicit scoping
07:31:43 <mauke> mm_freak: where?
07:31:54 <mm_freak> f x = \y -> x+y
07:31:55 <xplat> implicit scoping is better if it's local, but it still fails
07:32:09 <mauke> mm_freak: that's not implicit
07:32:18 <xplat> mm_freak: that is explicit scoping, the 'f x' is explicitly a binder
07:32:40 <mm_freak> hmm
07:33:18 <mm_freak> well, i think there is only one type of scope in haskell
07:33:25 <Kaidelong> anything like implicit scoping in haskell would show up in the type system, wouldn't it?
07:33:34 <Kaidelong> IE with state monads
07:33:34 <aristid> mm_freak: no, two: type scoping and value scoping :)
07:33:42 <mm_freak> lol
07:34:02 <xplat> hey, actually haskell does have implicit scoping ... for type variables
07:34:12 <mm_freak> xplat: nope
07:34:13 <mauke> Kaidelong: python-style implicit scoping wouldn't make sense in haskell due to the lack of assignment
07:34:23 <mm_freak> xplat: scoped type variables need a 'forall'
07:34:28 <xplat> foralls are inferred at the outside of a type
07:34:40 <aristid> xplat: not for scoped types.
07:34:47 <mauke> all types are scoped
07:35:02 <mm_freak> xplat: when ScopedTypeVariables is on there is a difference between 'a' and 'forall a. a'
07:35:19 <mm_freak> Kaidelong: that reminds me of the microsoft/haskell hoax
07:35:31 <mauke> mm_freak: doesn't change that in 'foo :: a -> a' is implicitly scoped to that type signature
07:35:36 <mauke> er, 'a' is
07:35:56 <xplat> mm_freak: well, then forall-primes are inferred :)
07:36:35 <Kaidelong> mm_freak: did you mean me?
07:36:53 <mm_freak> hmm, well, you could say that in haskell there are no free variables
07:37:22 <mm_freak> but if there is only one scope, then the property of being implicitly/explicitly scoped is meaningless
07:37:33 <mm_freak> you can view everything as both implicit and explicit
07:37:36 <mm_freak> Kaidelong: yes
07:37:47 <mauke> there are multiple scopes
07:37:51 <mauke> one for every type signature
07:38:19 <mm_freak> Kaidelong: http://haskell.org/haskellwiki/Humor/Microsoft
07:38:38 <mm_freak> mauke: i'm at the value level though
07:38:42 <Kaidelong> mm_freak: I just found that!
07:38:52 <xplat> yeah, you can reuse 'a' in as many freestanding type sigs as you want and it's not the same 'a'
07:39:50 <mm_freak> one /type/ of scope…  for example, if we assume that scoping is explicit, how would implicit scoping look like?
07:40:00 <xplat> at the value level in haskell there is no implicit scoping, though, except maybe if you get crazy with the implicit arguments extension that practically nobody uses
07:40:50 <mm_freak> ok, you can say that you can't use a variable, which hasn't been defined somewhere
07:41:00 <mauke> I think what I dislike is the lack of binders
07:41:00 <mm_freak> that's a valid argument
07:41:22 <mauke> even with only one scope, I still want explicit declarations
07:41:53 <mm_freak> mauke: that would be unneccessary extra line noise, though
07:42:07 <mm_freak> i like haskell for its concise syntax
07:42:09 <mauke> I disagree strognly
07:42:17 * ski always thought that `foo :: forall a. ..a..' making `a' in scope in the definition, but that `foo :: ..a..' doesn't, was backwards ..
07:42:17 <mauke> uh, haskell has explicit binders
07:42:29 <xplat> i guess you could say that in haskell98 there is only one scope possible for each use of a type variable, so binders would bee redundant, but if you wrote large type signatures you might want them to forestall typos with
07:42:59 <mm_freak> well, the choice of 'forall' is a bit unfortunate
07:43:09 <mauke> ∀a.
07:43:12 <mauke> :-)
07:43:22 <mm_freak> haskell should have scoped type variables /by default/
07:43:28 <mm_freak> if you want to reuse a type name, use forall
07:43:39 <mauke> huh?
07:43:42 <ski> xplat : one could argue that `f x = \y -> x+y' really means `forall x. f x = \y -> x+y', btw :)
07:44:36 <mauke> ski: but that doesn't explain what f is
07:45:19 <mauke> maybe that's not necessary if you go full declarative or something
07:45:36 <ski> `f' is the thing that is defined
07:45:58 <mauke> I read it as defining 'f x'
07:45:59 <ski> naturally it is a free variable of its definition
07:46:02 <mm_freak> mauke: currently in the upper level binding you use 'forall' to mark a type variable as scoped for the entire definition instead of only the corresponding type signature
07:46:20 <mm_freak> mauke: IMO that should be the default even without forall
07:46:21 <ski> mauke : yes, by defining `f x' for every `x', `f' is indirectly defined
07:46:24 <Kaidelong> mauke: Why not see it as a grammatical rule?
07:46:25 <xplat> prolog is scoped pretty similarly to type signatures in haskell98
07:46:37 <mm_freak> if you want to reuse a type variable inside a 'where' or something, you can still use forall /there/
07:46:41 <mauke> ski: it doesn't work that way for 'type' :-)
07:46:58 <ski> mauke : i'm not sure what you refer to ..
07:47:16 <mauke> ski: type F x = x
07:47:22 <mauke> ski: that doesn't mean F is usable
07:47:39 <mauke> only 'F something' is valid
07:47:50 <ski> clearly that defines `F x' for every type `x', indirectly defining the type `F'
07:48:10 <xplat> it works fine with data and newtype
07:48:12 <ski> oh .. well, that is only a syntactic restriction on how it may be used
07:48:32 <mauke> I don't think it's just syntactic
07:48:33 <ski> but i guess i see what you meant, yes
07:49:02 <ski> (but i'd still just say that the semantics of `F' is defined, even if it can only be used syntactically in applications)
07:49:26 <ski> (this being a case of an implementation restriction)
07:49:41 <xplat> it's more a semantic restriction that most places you can only use type constructors, not general type functions, plus a matching syntactic restriction based on the fact that all other type functions were introduced way, way after 'type'
07:51:24 <xplat> it seems like it should make sense to use F a lot of the places you can use type families, it's really just a type family with no class context
07:53:54 * hackagebot asn1-data 0.4.4 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.4.4 (VincentHanquez)
07:56:43 <ski> (xplat : re Prolog scoping, yes)
07:56:45 <ski> is Perl `local' a "dynamic scope" thing (which would be better called "dynamic extent") ?
07:56:54 <Kaidelong> Haskell was probably the first thing that made me realize that functional programming is not a fancy way of doing imperative programming
07:56:59 <Kaidelong> Scheme and F# did not
07:57:01 <mauke> ski: well, it really just temporarily changes the value of a variable
07:57:07 <Kaidelong> I am wondering why this is
07:57:11 <mauke> ski: so in some sense, yes
07:57:14 <ski> mauke : i think it would be nice if we were given a choice about explicit scoping or not .. e.g. a `LANGUAGE' flag (or more fine-grained)
07:57:30 <Bynbo7> Kaidelong: probably because they have much more direct mappings to imperative versions of the same programs
07:57:50 * Kaidelong thinks he just realized it and it has to do with typeclasses
07:58:07 <Kaidelong> and what bynbo7 said by specialization
07:58:18 <ski> mauke : ok, so that sounds like Common Lisp's "special" variables, and Scheme's "fluid variables" and "parameters" ..
07:58:25 <Kaidelong> since essentially typeclasses get in the way of the mapping
07:58:36 <Bynbo7> i think in those languages, it's a lot easier to see "this happens, the this, then this"
07:58:46 <Kaidelong> you can't evaluate polymorphic haskell code in your head
07:58:51 <Kaidelong> because methods can be overloaded
07:58:57 <mauke> ski: yes, but it's not bound to the variables
07:59:15 <mauke> ski: I think it's bad to overload LET to do both
07:59:42 <ski> maybe
07:59:58 <ski> using the *same* kind of declaration in a `let' would be bad, i agree
08:00:07 <jacobian> I just used the Identity monad for the first time and it was out of shear laziness 
08:00:08 <ski> using another kind of declaration could be fine, i think
08:00:19 <ski> like `let ?x = 0 in ...' in Haskell
08:00:42 <mauke> when I read about lisp I thought this was screamingly obvious
08:00:59 <ski> jacobian : instead of converting between `State s a' and `StateT s Identity a' or something similar ?
08:01:08 <mauke> (let ((x 0)) ... (temporarily (x 42) ...))
08:01:39 <jacobian> ski: I was changing code from using Maybe to Identity 
08:01:44 <mauke> the let introduces a new local variable, which is then used with another value (and restored automatically)
08:01:48 <ski> in Scheme, you can not temporarily change the referent of a fluid variable with `let'
08:01:51 <jacobian> ski: It was a lot of code written in a monadic style 
08:02:10 <mauke> I don't know scheme or what fluid variables are
08:02:10 <jacobian> I thought there was a failure condition, but it was a mistake 
08:02:14 <ski> (if you try, you just end up making a new lexically scoped variable, which shadows the other one)
08:02:44 <ski> you have to use `fluid-let' (or `let-fluid') or `with-parameterization' (depending on which variant you use), instead
08:02:51 <mauke> funnily enough this is also broken in perl because you can't apply 'local' to local variables
08:03:17 <ski> fluid variables is one way to make "dynamic scope"
08:03:33 <mauke> the workaround is the same as python's workaround for mutable closed-over variables
08:03:36 <chrisdone> mauke: FLUI-LET temporarily assigns an existing binding to something else.
08:03:43 <chrisdone> (Doesn't create any new bindings.)
08:04:40 <mauke> (let (x 0) (let (f (lambda () x)) (fluid-let (x 1) (f))))  ; like this?
08:05:22 <chrisdone> Exactly. It will return 1.
08:05:32 <mauke> do { my @x = 0; my $f = sub { $x }; local $x[0] = 1; $f->() }  # 1
08:05:42 <chrisdone> Same idea then.
08:05:50 <mauke> er
08:05:54 <mauke> sub { $x[0] }
08:10:08 <jacobian> who needs referential transparency 
08:10:56 <jacobian> 'When I use a word,' Humpty Dumpty said, in rather a scornful tone, 'it means just what I choose it to mean — neither more nor less.' 
08:11:17 <ski> using the "parameter" version instead, you don't start with a normal lexical scoped variable, but instead create a new cell (like `IORef', a bit), and then use operations to extract the current value, as well as change the value, for a dynamic extent
08:11:52 <mauke> > runReader (do { let {f = ask}; local (const 1) f }) 0
08:11:53 <lambdabot>   1
08:13:18 <ski> i suppose one could imagine `newRTVar :: a -> RT r (RTVar r a)',`getRTVar :: RTVar r a -> RT r a',`localRTVar :: RTVar r a -> (a -> a) -> (RT r b -> RT r b)',`runRT :: (forall r. RT r a) -> a' ..
08:13:27 <ski> mauke : *nod*
08:14:50 <ski> (also, each thread has its own copy (possibly copy-on-write) of all the parameterization variables)
08:21:16 <ricree> Anyone familiar with the LLVM bindings?  I'm trying to get the code generation from a simple AST, and I'm having trouble wrapping my head around the types here.  http://hpaste.org/43652/basic_llvm
08:35:56 <Bynbo7> ricree: i think it has to do with the types of fadd and fsub returning Value Double (if i remember correctly)
08:37:43 <Bynbo7> but...i don't know how to fix that :(
08:42:31 <Wooga> how do i use peek iteratee with fileDrive? i tried `run $ joinIM $ fileDriver peek "/dev/urandom', but it only yields error http://paste.pocoo.org/show/332658/
08:42:50 <Wooga> fileDriver*
08:45:40 <Saizan> what is the type of fileDriver ?
08:45:49 <aristid> @hoogle peek
08:45:50 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
08:45:50 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
08:45:50 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
08:46:10 <Wooga> Saizan: fileDriver :: (MonadCatchIO m, NullPoint s, ReadableChunk s Source
08:46:13 <ricree> Bynbo7:  Yeah, I think it has something to do with a difference in type between what's return from another binop vs an actual value.  But I'm just having a heck of a time figuring out what the types should be here
08:46:14 <Wooga> el) => Iteratee s m a -> FilePath -> m a
08:46:20 <Wooga> ugh
08:46:33 <Saizan> Wooga: it seems you don't need joinIM nor run
08:47:02 <Saizan> the result type is directly "m a" where the only contraint on m is MonadCatchIO, and IO fits that
08:47:04 <aristid> Wooga: ugly type :/
08:48:14 <Wooga> Saizan: aha, but just removing joinIM does not helps: http://paste.pocoo.org/show/332661/
08:48:33 <Saizan> Wooga: yeah, you need to remove run too
08:48:57 <Wooga> Saizan: still the same: http://paste.pocoo.org/show/332662/
08:49:33 <Saizan> that means you need to specify 's' more precisely
08:50:49 <Saizan> e.g. fileDriver (peek :: Iteratee String IO Char) "/dev/urandom" 
08:51:01 <Saizan> s/Char/Maybe Char/
08:52:32 <Saizan> polymorphic producer + polymorphic consumer = need lots of type annotations
08:53:02 <Wooga> yay! `fileDriver (peek :: Iteratee String IO (Maybe Char)) "/dev/urandom"' worked!
08:53:08 <Wooga> Saizan: thank you a lot!
08:53:16 <russruss> Hi - I'm a total beginner, first day with Haskell although I've done some functional coding before and I have some weak understanding of language design principles.  I've noticed that there are several GHC extensions that allow more expressiveness in the type system (GADTs, RankNTypes, TypeFamilies).  These are pretty appealing features to me, but I'm not sure how common these extensions are and how "experimental/bleeding edge" they
08:53:16 <russruss> to the average Haskell user.  Is it considered bad form to use any of the libraries I mentioned?  How about using a mixture of RankNTypes and GADTs in code when you could easily only use GADTs?
08:56:11 <Kaidelong> russruss: I'm not very sure about type families but I am pretty sure nobody will complain about you using GADTs and RankNTypes
08:56:21 <Tomsik> I dunno, I like them
08:56:26 <Saizan> GADTs are probably the less scary of the three, though i think unless you're being particularly crazy the average haskell user should be able to use an API consisting of those, but not necessarily understand the implementation
08:56:30 <Kaidelong> I do not use type families so I can't say one way or the other
08:57:07 <Kaidelong> what I do know from having used libraries that use type families is that they can cause very, very cryptic type errors
08:57:09 <Saizan> RankNTypes can lead to some quite hard to understand situations though
08:57:11 <geheimdienst> i would say the issue would only come up if you're seriously considering releasing code
08:57:14 <Jafet> Don't use blank verse until you find yourself in a play.
08:57:21 <Tomsik> I've used type families, there are some limitations placed on them to ensure termination of typechecking and some on pattern matching, but it's pretty okay
08:57:42 <Tomsik> type families associated with type classes are most useful IMO
08:58:08 <geheimdienst> i mean, for just trying things and experimenting, go as crazy as you like :)
08:58:26 <Jafet> Haskell is very expressive without type extensions.
08:58:36 <russruss> aiight, cool.  I just wanted to get a sense of how people felt about them before I went off and learned something everyone else was afraid of :-)
08:59:39 <Kaidelong> In the case of GADTs and RankNTypes, those should probably both be standard haskell, really
08:59:45 <Kaidelong> especially GADTs
08:59:53 <russruss> yeah I mean I suppose it's a bit silly to be asking for permission to mess around but thanks
08:59:57 <Kaidelong> existential quantification too
09:00:20 <russruss> is it true that anything you can do with RankNTypes you can do with GADTs?
09:00:46 <russruss> I like the syntax better for RankNTypes for simple things in any case
09:00:47 * Kaidelong knows that it is true that anything you can do with RankNTypes you can do with Rank2Types
09:00:57 <Kaidelong> but it is harder
09:01:07 <geheimdienst> on that general note, what's the public opinion on OverloadedStrings? i have recently started to use them, but i have some doubts my haskell-fu might be too weak
09:01:18 <Jafet> "Beware of the Turing tar pit..."
09:01:51 <Tomsik> > let id x = x :: (forall a. a -> a)
09:01:52 <lambdabot>   not an expression: `let id x = x :: (forall a. a -> a)'
09:02:00 <Tomsik> > let id x = x in id id
09:02:01 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
09:02:01 <lambdabot>    arising from a use of `...
09:02:12 <Saizan> well, GADTs implicitly enable ExistentialQuantification and PolymorphicComponents, so i guess you can wrap your polymorphic types in a gadt so your function have a superficially low-rank type
09:02:15 * Jafet fixes Tomsik to a point
09:02:25 <Veinor> geheimdienst: i have no experience with them, but i like the concept.
09:02:39 <Maxdamantus> :t let id x = x in id id
09:02:40 <lambdabot> forall t. t -> t
09:03:09 <Veinor> is the packing and such done at compile time?
09:03:53 <geheimdienst> i don't know :) how do you mean packing?
09:04:00 <Kaidelong> Saizan: Needing to make a new GADT to make something with a higher rank type seems silly though
09:05:22 <Saizan> Kaidelong: yeah, though sometimes it helps with type inference, and might be necessary to avoid ImpredicativeTypes
09:05:36 <ski> (Kaidelong : yeah .. a bit like needing to make a new record type to return a bunch of information from a function (assuming you want names, and not just positions as in tuples))
09:05:53 * ski . o O ( `foo :: ... -> FooResult' )
09:06:06 <russruss> everyone cool with MultiParamTypeClasses?  Seems like a pretty necessary feature
09:06:17 <Kaidelong> russruss: Absolutely
09:06:18 <Saizan> yep, that's used everywhere
09:06:22 <Veinor> geheimdienst: i guess what I mean is, if I have a really large literal, does it have to convert it to whatever type at run-time, or does it do so at compile time?
09:06:24 <Jafet> ML lets you define types locally, doesn't it?
09:06:34 <Veinor> like how 2+2 will usually get optimized into 4
09:06:45 <ski> some people think type families are to be a replacement for multi-parameter type classes .. i think the jury is till out
09:06:45 <Jafet> It makes some code clearer, and some other code more confusing
09:06:49 <Saizan> russruss: OverlappingInstances and IncoherentInstances are the bad ones
09:06:56 <ski> Jafet : it does, yes
09:07:10 <Saizan> ski: i thought they were pushing them just for fundeps
09:07:12 <roconnor> ski: aren't type families (or was it data families) equivalent to fundeps?
09:07:37 <ski> Saizan : pushing what ? MPTCs ?
09:07:43 <geheimdienst> veinor, okay i see. i don't have big literals at all, they are all maybe 100 bytes
09:07:57 <geheimdienst> saizan: how about undecidableinstances?
09:08:00 <ski> roconnor : i don't know .. but it's not only that, but usability
09:08:01 <geheimdienst> is that evil?
09:08:02 <Saizan> ski: type families
09:08:06 <roconnor> ski: true true
09:08:28 <roconnor> My boss says that GADTs are equivalent to typeclasses and could have been implemented in Haskell 98
09:08:50 <Saizan> geheimdienst: that's fine, at worst GHC will stop instance resolution after some recursion depth is reached
09:09:04 <geheimdienst> i see, thanks
09:09:27 <Saizan> roconnor: yep, oleg's finally tagless interpreters shows that
09:10:38 <roconnor> Saizan: so we can remove all that stuff we added to GHC to support GADTs?
09:11:51 <Saizan> roconnor: if you're ok with making a new type and a new instance everytime you want to recurse over a gadt..
09:12:09 <roconnor> Saizan: I'm okay with GHC doing that under the covers
09:12:42 <Saizan> roconnor: i think it's easier for GHC to use the stuff they added then
09:12:49 <roconnor> ;)
09:13:06 <Kaidelong> Saizan: It would be nice if there was a good solution for what OverlappingInstances does, eventually, though
09:13:17 <Kaidelong> perhaps a breadth-first search over superclasses
09:13:21 <Kaidelong> or something like that
09:13:27 <Saizan> Kaidelong: see "instance chains"
09:15:13 * hackagebot graph-rewriting 0.5 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.5 (JanRochel)
09:16:52 <Kaidelong> Saizan: Has that actually been implemented?
09:17:06 <Kaidelong> (looks nice though)
09:18:32 * Kaidelong wonders why nobody the functor hierarchy couldn't be done with conditional superclass definitions. IE "if this instance is for something not already a superclass, the class definition (not the instance definition) can define why it is also in the superclass"
09:18:49 <Kaidelong> or is that some haskell extension I do not know about?
09:19:49 <Saizan> there are many proposals for that kind of thing, with different tradeoffs
09:19:53 <Kaidelong> IE inside the Monad class you could have "infer Applicative where"
09:19:59 <Kaidelong> or something like that
09:20:25 <Saizan> some are discussed in related threads on the libraries@ mailing list
09:21:15 * hackagebot graph-rewriting-layout 0.4.4 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.4.4 (JanRochel)
09:21:29 <ski> Kaidelong : that would be a kind of defaulting, i think
09:21:52 <Kaidelong> ski: yes
09:22:20 <Kaidelong> one problem would be where defaults conflict
09:22:24 <Kaidelong> but you could make that an error
09:22:38 <ski> Kaidelong : i would want to write it like `class Monad Foo where {instance Functor Foo where {fmap = liftM}; ...}'
09:22:43 <Kaidelong> and then perhaps use some kind of chaining or ordering construct to disambiguate
09:23:07 <ski> or something like that, anyway
09:23:15 * hackagebot graph-rewriting-gl 0.6.3 - OpenGL interface for interactive hypergraph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6.3 (JanRochel)
09:23:16 <Saizan> http://vimeo.com/16541904 <- nice talk btw
09:23:26 * ski thinks ordering constructs are probably a misttake
09:23:37 <ski> (hehe s/misttake/mistake/ :)
09:23:47 <helgikrs> is there a speed difference with working with sockets or converting them to handles? is there a reason to use one over the other?
09:23:52 * ski takes some mist home
09:24:53 <Tomsik> I'd rather see class (Applicative m) => Monad m where
09:25:21 <Kaidelong> Tomsik: a superclass?
09:25:48 <Tomsik> You have to be applicative to be a monad
09:26:08 <Kaidelong> Tomsik: Yes, that's true, in the current haskell libraries, they don't even do the superclass thing
09:26:15 <Kaidelong> although a way to infer superclasses would be nice
09:26:24 <Kaidelong> err, superclass instances
09:26:36 <Tomsik> It's in the wrong direction IMO
09:26:39 <Kaidelong> with rules supplied int he class definition, of course
09:26:45 <Tomsik> If you had it like applicative => monad
09:26:55 <Kaidelong> Tomsik: Why? If you can make a monad definition, you have a functor definition
09:26:57 <Tomsik> you'd have to have an applicative instance
09:27:00 <Kaidelong> @src liftM
09:27:00 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:27:02 <Tomsik> and then liftM = fmap
09:27:13 <Tomsik> not fmap = liftM
09:27:39 <aristid> Tomsik: and (>>=) outside the type class, but join inside?
09:28:06 <Tomsik> What do you mean?
09:28:37 <Tomsik> You're trying to imply that I have CT background,  aren't you
09:28:54 <Kaidelong> yeah that'd make it more of a category theory definition I guess
09:29:13 <Kaidelong> would be interesting if you could define it *either* way
09:29:22 <Kaidelong> but I don't know if that is really so important
09:33:18 * hackagebot heist 0.5.0.0 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.5.0.0 (DougBeardsley)
09:35:11 <angasule> Hi, i'm following this tutorial: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing  and using ghc 6.12.1 with both libghc6-parsec2-dev and libghc6-parsec3-dev installed on Debian squeeze. When I add the line "import Text.ParserCombinators.Parsec hiding (spaces)" the compile files with an undefined reference
09:35:34 <angasule> main.o: In function `slW_info': (.text+0x1f7): undefined reference to `__stginit_parseczm3zi1zi0_TextziParserCombinatorsziParsec_'
09:36:08 <monochrom> ghc --make f.hs
09:36:39 <ski> Tomsik : yes, from a logical perspecticve, the `=>' in `class Applicative m => Monad m' points in the wrong direction ;)
09:37:16 <Tomsik> "is in applicative => can be a monad" :p
09:37:17 <monochrom> just punctuation. people read too much between the lines.
09:37:31 <ski> (surely, if `Monad m' holds, then `Applicative m' ought to also hold .. not the other way around !)
09:37:52 <geheimdienst> monochrom: which lines? the two lines of =?
09:37:56 <ski> well, in `instance Eq a => Eq [a]', it can be read as implication
09:37:58 <angasule> monochrom: thanks :-) I'll search for what that does exactly
09:38:20 <monochrom> yes, the two lines of =
09:38:25 <Kaidelong> ski: but this would be "class (Applicative m) => Monad m"
09:38:28 <Kaidelong> not "instance"
09:38:51 <Kaidelong> in which case the implication does point the wrong way
09:38:57 <Kaidelong> perhaps call it abduction?!
09:38:59 <ski> Kaidelong : i know, i'm just claiming that (i my eyes) the `=>' in `class' declarations is pointing in the wrong way
09:39:24 <Tomsik> (+) :: Num a => a -> a -> a
09:39:28 <Tomsik> is it wrong too? :p
09:39:38 * ski abducts `=>' from `class' declarations .. and Kaidelong along the way !
09:39:40 <Kaidelong> Tomsik: No
09:39:48 <Kaidelong> (+) is a proof of a -> a -> a
09:39:48 <ski> Tomsik : no, not quite
09:39:53 <Kaidelong> but only when a is a Num
09:40:03 <RayNbow> @pl \x -> abs (x :: Int) >= 0
09:40:04 <lambdabot> (>= 0) . abs . (:: Int)
09:40:06 <RayNbow> erm
09:40:09 <RayNbow> @check \x -> abs (x :: Int) >= 0
09:40:10 <lambdabot>   "OK, passed 500 tests."
09:40:14 <RayNbow> @check \x -> abs (x :: Int) >= 0
09:40:15 <lambdabot>   "OK, passed 500 tests."
09:40:33 * RayNbow wonders how many tests he should run for it to fail
09:41:12 <Tomsik> Just one, feed it a hardcore relativist
09:41:25 <ski> @check all (\x -> abs (x :: Int) >= 0)
09:41:26 <lambdabot>   "OK, passed 500 tests."
09:41:52 <ski> (that's for making it check *all* the possible inputs)
09:42:23 <RayNbow> > (\x -> abs (x :: Int) >= 0) (-3)
09:42:24 <lambdabot>   True
09:42:28 <RayNbow> > (\x -> abs (x :: Int) >= 0) minBound
09:42:29 <lambdabot>   False
09:42:43 <Tomsik> @check (\x -> x `mod` 997 != 0)
09:42:44 <lambdabot>   Not in scope: `!='
09:42:47 <Tomsik> @check (\x -> x `mod` 997 /= 0)
09:42:48 <lambdabot>   "Falsifiable, after 1 tests:\n0\n"
09:42:51 <Tomsik> @check (\x -> x `mod` 997 /= 0)
09:42:52 <lambdabot>   "Falsifiable, after 1 tests:\n0\n"
09:42:55 <Tomsik> :<
09:43:03 <ski> > abs (minBound :: Int)
09:43:04 <lambdabot>   -9223372036854775808
09:43:26 <Tomsik> @check (\x -> x `mod` 997 > 0)
09:43:27 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
09:43:35 <Tomsik> Damn you check
09:43:51 <parcs> > abs (minBound + 1 :: Int)
09:43:52 <lambdabot>   9223372036854775807
09:44:22 <Kaidelong> goeie dag
09:44:38 <ski> (just in case anyone was taking me seriously above, re `all' .. i wasn't :)
09:45:15 <Kaidelong> ski: aren't there actually some ways by which you can do that in practice?
09:45:22 <Kaidelong> but they require fancy static analysis
09:47:19 <ski> well, for some kinds of problem, there are
09:47:56 <parcs> > minBound :: In
09:47:56 <lambdabot>   Not in scope: type constructor or class `In'
09:47:59 <parcs> > minBound :: Int
09:47:59 <lambdabot>   -9223372036854775808
09:48:13 <merijn> Can someone un-americanify "graduate program" for me? Is that just PhD programs or also master's?
09:48:14 <ski> Zeilberger have some fun examples about proving various geometric theorems, by checking them in some small finite number of instances, from which the general validity follows by a meta-theorem
09:48:23 <Kaidelong> merijn: the latter
09:48:33 <Kaidelong> and then some other things like law/architecture/engineering stuff
09:48:33 <ski> (and also for things with polynomials, of course)
09:48:44 <merijn> Kaidelong: ok, thanks
09:48:44 <Kaidelong> and medical school
09:48:55 <Kaidelong> basically there are all sorts of graduate programs
09:48:57 <sbahra> Isn't PhD also part of a "graduate program"?
09:49:13 <Kaidelong> sbahra: merijn did say "also"
09:49:26 <sbahra> Aha.
09:49:27 * ski misread "medical" as "medieval" ..
09:50:04 <wto> That sounds like great schools!
09:50:37 <Tomsik> @check \x -> (fix $ \f n -> if n == 1 then 1 else if n `mod` 2 == 0 then f $ n `div` 2 else f $ 3*n+1) x == 1
09:50:41 <lambdabot>   mueval-core: Time limit exceeded
09:50:47 <Tomsik> Ha ha!
09:51:39 <merijn> Kaidelong: Well, I just needed to know which application criteria for summer school apply to me as a master's. So the other billion interpretations are less important to me :p
09:52:52 <Tomsik> I heard that all straight edge & ruler theorems are in 2-EXPSPACE or something
09:53:15 <Veinor> Tomsik: haha
09:53:25 <Veinor> well
09:53:42 <Veinor> you don't want fix, you want fixedPoint or something
09:54:05 <Veinor> where fixedPoint f n | n == f n = n; | otherwise = fixedPoint f (f n)
09:59:56 <marekweb> where is the "import" supposed to go? i get a parse error
10:06:54 <copumpkin> marekweb: up at the top before data or function declarations
10:08:04 <aavogt> after "module Foo where", if you've got that
10:18:07 <ski> > let import Data.Map in lookup () empty
10:18:08 <lambdabot>   <no location info>: parse error on input `import'
10:19:27 * hackagebot pandoc 1.8.0.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8.0.2 (JohnMacFarlane)
10:20:34 <aristid> :t M.lookup
10:20:35 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
10:20:46 <aristid> > M.lookup () M.empty
10:20:46 <lambdabot>   Nothing
10:20:50 <aristid> ski: :)
10:24:07 <copumpkin> man, I really want closed type families
10:24:18 <aristid> copumpkin: GADTs?
10:24:23 <copumpkin> not the same
10:24:59 <aristid> ok, they are closed data families
10:25:02 <copumpkin> the point is having families that are injective be invertible
10:25:23 <copumpkin> this can't be a data family, sadly
10:25:30 <aristid> copumpkin: use fundeps
10:25:47 <copumpkin> it's not a bidirectional relationship
10:25:57 <copumpkin> so it isn't fully injective
10:26:06 <copumpkin> but it is invertible for this particular case
10:30:52 <elliott> Is there a name for: data FailureStream a = End | Failure | Cons a (FailureStream a)?
10:31:03 <elliott> Consider e.g. a parser (for lists, I guess) that can give partial results.
10:31:30 * hackagebot pandoc 1.8.0.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8.0.3 (JohnMacFarlane)
10:34:59 <NemesisD> writing my first cabal package. my test build depends on Text.JSON and HUnit, for some reason the setup script always says hunit -any and json -any are missing, but im positive theyve been installed with cabal
10:36:28 <monochrom> Setup.hs defaults to "global". cabal-install defaults to "user". do you know what this means?
10:37:44 <NemesisD> i don't, but i do see that using the cabal binary seems to have access to my packages
10:38:13 <monochrom> the early section of my http://www.vex.net/~trebla/haskell/sicp.xhtml
10:39:17 <monochrom> "global" packages are not supposed to depend on "user" packages. you have hunit and json installed as "user". you build your new package as "global". all your "user" packages are ignored.
10:40:00 <dafis> NemesisD: it means runhaskell ./Setup.hs has access to only the global package db unless you pass the --user flag to configure, while cabal install'ed packages land in the user package db unless you pass the --global flag
10:41:14 <monochrom> The abstraction leaks. Such inconsistency is an example. IMO cabal-install is better off not pretending to abstract away things.
10:41:38 * hackagebot Thrift 0.5.0 - Thrift library package  http://hackage.haskell.org/package/Thrift-0.5.0 (KirkPeterson)
10:41:52 <NemesisD> dafis: that makes sense
10:42:39 * hackagebot cassandra-thrift 0.7.0 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.7.0 (KirkPeterson)
10:42:41 <NemesisD> another question: how would i add to the load path in my tests, my source code is off in another directory but i need to import those modules from test/
10:43:55 <Saizan> monochrom: which abstraction?
10:45:05 <monochrom> the whole idea that "cabal install blah" "just works" "transparent to user" "you don't need to worry about dependencies" "you don't need to know what is global what is user"
10:45:56 <monochrom> and the fact that all these are undocumented.
10:45:57 <Saizan> so you'd prefer to have to install deps manually and have no default for --global/user ?
10:46:25 <ski> elliott : something like `ListT Maybe a' ?
10:46:38 <monochrom> yes
10:46:49 <elliott> ski: well, indeed.
10:47:02 <elliott> has anyone figured out the platonically perfect way of writing ListT yet? :-)
10:47:21 <monochrom> or else a "transparent" "you don't need to know anything" abstraction that never leaks.
10:47:26 <Saizan> platonically perfect?
10:47:26 <ski> (where `newtype ListT f a = MkListT (f (ListCell f a))' and `data ListCell f a = Nil | Cons a (ListT f a)')
10:47:39 <monochrom> 99.99% perfect.
10:48:11 <ski> elliott : you should note that `ListT' is not a monad transformer, though (though when restricting the domain to *commutative* monads, then it becomes a valid transformer)
10:48:33 <ski> elliott : in any case, this one can be useful for other things as well .. like `ListT IORef', e.g.
10:48:41 <elliott> indeed
10:48:59 * ski has sometimes called this `ListT' simply `List' ..
10:49:04 <Saizan> monochrom: i think the only problem is that not enough people are exposed to ghc-pkg, cabal is not trying to abstract over it at all, just working with it
10:49:47 <monochrom> for example if Setup.hs and cabal-install use the same default (e.g. both default to global or both default to user), then it has the license to abstract away from that.
10:50:36 <ski> @type let len f as = f (loop as) where loop [] = 0; loop (_:as) = 1 + len f as in len
10:50:37 <lambdabot> forall t t1. (Num t) => (t -> t) -> [t1] -> t
10:50:37 <aristid> ski: what about using LogicT instead?
10:51:13 <ski> @type let map c f as = c (loop as) where loop [] = []; loop (a:as) = f a : map k f as in map
10:51:13 <lambdabot>     Couldn't match expected type `[a] -> [a]'
10:51:14 <lambdabot>            against inferred type `Expr'
10:51:14 <lambdabot>     In the expression: c (loop as)
10:51:20 <ski> @type let map c f as = c (loop as) where loop [] = []; loop (a:as) = f a : map c f as in map
10:51:20 <lambdabot> forall a t. ([a] -> [a]) -> (t -> a) -> [t] -> [a]
10:51:33 <ski> aristid : instead of what ?
10:51:48 <aristid> ski: ListT
10:51:59 <Saizan> the idea they have a different default because they are meant for different users/use cases, Setup is more for machines than humans
10:52:13 <ski> aristid : would i get the left-to-right traversal, instead of some breadth-first one, with that ?
10:52:16 <Saizan> i.e. distro build scripts
10:52:17 <elliott> is there a way to force ghci to load a file even if it has a non-standard extension?
10:52:38 <aristid> ski: um, not sure :)
10:53:41 * hackagebot partial-isomorphisms 0.2 - Partial isomorphisms.  http://hackage.haskell.org/package/partial-isomorphisms-0.2 (TillmannRendel)
10:54:36 <ski> elliott : start GHCi with `-XLanguageExtension' or do `:set -XLanguageExtension' interactively (or add `{-# LANGUAGE LanguageExtension #-}' to the top of the file, if that's what you're asking about)
10:54:42 <elliott> hmm, what does # mean at the start of a line in literate haskell?
10:54:44 <BMeph> elliott: I was thinking of a comonad+monad way of describing a list that edwardk also noticed. He may have something exotic and useful that "does ListT right".
10:54:45 <elliott> seems to be erroring out on it
10:54:50 <elliott> ski: ah, thanks
10:54:57 <elliott> (-x lhs seems to work)
10:54:59 <ski> aristid : in my case, the single-linked-listness of it was a feature :)
10:56:40 <ski> (aristid : in fact, i was using `ListT (LogVar s)' to implement possibly partially instantiated linked lists in my small logic programming EDSL)
10:57:57 <aristid> ski: LogVar is commutative?
10:58:52 <kmc> so i'm FFI-wrapping a C library.  my Haskell users will expect to pass me callbacks, which I'll convert to C function pointers using foreign import "wrapper".  but i don't want the user to have to call freeHaskellFunPtr directly or indirectly
10:59:06 <kmc> is there a common solution here?
10:59:19 <kmc> i think i might use a finalizer on the value that represents an overall session with the library
10:59:26 <kmc> but there's various tricky bits to get right
11:00:48 <monochrom> the excuse that Setup.hs is for distro build scripts is pretty lame. first of all this intention and how it differs from cabal-install is undocumented in the cabal manual. how are people other than insiders supposed to know?
11:02:05 <monochrom> secondly how many distro build script writers are there in the whole world? probably just 5. compared to how many beginners will get interested in rolling their own cabalized packages.
11:02:48 <ski> aristid : i'm not sure what you're asking about ..
11:03:04 <ski> aristid : `LogVar s' is not a monad, if that's what you're thinking
11:03:34 <aristid> ski: how is ListT (LogVar s) even valid without LogVar s being a monad?
11:03:46 <ski>   instance MonadRef (LogVar s) (Logic s)
11:03:47 <monochrom> Setup.hs having a different default from cabal-install is a principle of maximum surprise to the whole community except for 5 persons.
11:03:59 <aristid> ski: MonadRef??
11:04:02 <aristid> @hoogle MonadRef
11:04:02 <lambdabot> No results found
11:04:10 <ski> aristid : `ListT' isn't here to be thought of as a monad transformer at all
11:04:41 * aristid confused
11:04:58 <ski> aristid : `class Monad m => MonadRef ref m where newRef :: a -> m (ref a); readRef :: ref a -> m a; writeRef :: ref a -> a -> m ()'
11:05:29 <ski> `ListT ref' is just a linked list, where each cell is indirected through `ref'
11:05:42 <ski> so if `ref' is `IORef', it's a list where each cell is mutable
11:05:57 <ski> if `ref' is `Maybe' it's a list which can terminate prematurely (as elliott asked for)
11:06:05 <ski> if `ref' is `Identity' it's just a normal list
11:06:09 <elliott> right
11:06:20 <monochrom> here is the true optimal thing to do: Setup.hs does the same thing (at least easily visible aspects) as cabal-install. The 5 writers of distro build scripts are told to add --global. How are they told? Send out an email to 5 addresses, or write it clearly in bold large letters in the manual, or write it clearly in the "Setup --help" message.
11:06:22 <ski> if `ref' is `[]', then it's more or less a rose tree
11:06:49 <kmc> istr some way to attach finalizers to arbitrary values (not just ForeignPtrs)
11:06:51 <kmc> anyone remember?
11:06:54 <ski> if `ref' is `IO', then it's a list where each cell may do some `IO'-computation to be determined
11:07:45 <copumpkin> omg sigfpe left ILM
11:08:25 <ski> (aristid : re `MonadRef' .. i'm still not sure whether it's sensible to add any FD .. also i've been thinking about splitting the class up)
11:08:37 * ski . o O ( "ILM" ? )
11:08:47 <ezyang> copumpkin: Wait, what? 
11:09:08 * ski . o O ( "I? Last Margin" ? )
11:09:18 <monochrom> international league of marinators
11:09:19 <Twey> Cache miss, resort to Google
11:09:26 <copumpkin> ezyang: he just announced it on twitter
11:09:28 <copumpkin> zomg :P
11:09:31 <Twey> Institute of Leadership and Management?
11:09:37 <ezyang> whoa 
11:09:57 <copumpkin> @google ILM
11:09:59 <lambdabot> http://www.ilm.com/
11:09:59 <lambdabot> Title: Industrial Light & Magic
11:10:16 <monochrom> incorporation of lesbian men
11:10:37 <kmc> i guess i'd use System.Mem.Weak
11:10:43 <kmc> this all feels... wrong somehow
11:10:57 <drhodes> if I've got a .. data Foo = A Int | B Int | .. | Z Int;  and want to extract the Int from a [Foo] .. [(A 3), (C 9), (Z 4)], is there a way to do this without writing a 26 line pattern match function, or changing to record syntax?
11:11:00 <ski> "Incongruous Liberate Mal'cev" ?
11:11:32 <kmc> data Foo = A Int | ... | Z Int deriving (Enum)
11:11:38 <kmc> then you can use "fromEnum"
11:11:41 <drhodes> oh yeah!
11:11:43 <kmc> err but maybe not
11:11:47 <kmc> because you have a data field
11:12:06 <ski> drhodes : `data Foo = F Tag Int; data Tag = A | B | ... | Z'
11:12:20 <monochrom> www.ilm.com is a stupid flash-only front page. I would leave it too.
11:13:46 <drhodes> ok, I'll let those simmer, thanks ski, kmc.
11:13:52 <Veinor> yeah, you can't derive foo with non-nullary constructors
11:13:55 <Veinor> er, derive Enum
11:18:06 <Jesin> well
11:18:40 <Jesin> I think you can in the special case of a single unary constructor whose argument is also an Enum
11:18:46 <Jesin> can't you?
11:18:48 <Jesin> like
11:19:11 <Jesin> newtype Foo = Foo {getFoo :: Integer} deriving Enum
11:19:49 <Jesin> or even
11:19:58 <Jesin> newtype Foo a = Foo {getFoo :: a} deriving Enum
11:20:15 * Jesin tests this
11:20:48 <Jesin> ...
11:20:51 <Jesin> ok, apparently you can't
11:21:16 <Jesin> hmm
11:21:58 <aristid> :t toEnum
11:21:59 <lambdabot> forall a. (Enum a) => Int -> a
11:22:12 <Jesin> I feel like "deriving" should be more powerful than it is with newtype
11:22:12 <aristid> Jesin: i don't see how toEnum would be implemented there
11:22:16 <Jesin> not with data, obviously
11:22:17 <gwern> @quote
11:22:17 <lambdabot> cale says: Differential geometry is the study of manifolds under change of notation.
11:22:36 <aristid> i suppose that quote is pretty funny.
11:22:41 <Jesin> aristid: toEnum = Foo . toEnum
11:22:47 <Jesin> :p
11:23:05 <aristid> Jesin: oh, right, newtype deriving. then it should actually work.
11:23:18 <aristid> Jesin: the syntax is deriving (Enum), not deriving Enum
11:23:20 <Jesin> is that already an extension or proposal?
11:23:31 <aristid> i think it's haskell98
11:23:42 <Saizan> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
11:23:54 <Jesin> niiice
11:23:55 <Saizan> and "deriving Enum" is fine
11:24:43 <Jesin> good to hear that's already implemented
11:24:54 <Jesin> it didn't seem like it would be very hard  :p
11:25:24 <Jesin> speaking of easy things
11:25:30 <Jesin> why isn't join a method of Monad already?
11:26:02 * ski is pondering Synthetic Differential Geometry in ##logic ..
11:26:10 <Saizan> because there's a fair share of people opposing it
11:26:14 <Jesin> I can understand the whole Functor => Applicative => Monad thing might break existing code
11:26:16 <Jesin> but
11:26:19 <Jesin> WHAT
11:26:19 <aristid> Jesin: because haskell98 was made by evil monkeys (very intelligent evil monkeys)
11:26:22 <Jesin> whaaaat
11:26:24 <Jesin> but
11:26:33 <Saizan> see the thread on libraries@
11:26:36 <Jesin> putting join in Monad wouldn't even break anything
11:26:37 <systemfault> Where can I buy an evil monkey?
11:26:40 <Jesin> umm, where is that?
11:26:46 <Jesin> Saizan, link?
11:26:48 <aristid> systemfault: they're too expensive for your budget.
11:26:52 <systemfault> :(
11:27:01 <Saizan> @google haskell mailing lists
11:27:07 <lambdabot> http://www.haskell.org/haskellwiki/Mailing_Lists
11:27:07 <lambdabot> Title: Mailing lists - HaskellWiki
11:27:08 * ski remembers a paper that wanted `ap' in `Monad' (though i think they secretly just longed for `Applicative', but didn't know about it yet, it not having been invented)
11:27:31 <aristid> ski: stupid people from the past. they know less than we do.
11:28:36 <Jesin> I mean, it's just
11:28:45 <Jesin> I wrote a monad instance for a thing recently
11:28:54 <Jesin> and actually found it easier to implement (>>=) as
11:29:08 <Saizan> Jesin: the main aargument seems to be that you'd need more monad laws, making it harder to understand
11:29:30 <Jesin> m >>= f = join (fmap f m) where
11:29:32 <Jesin>   join m = [...]
11:29:47 <Jesin> umm
11:30:15 <Jesin> if you want fewer laws
11:30:22 <monochrom> more laws makes it easier to understand, not harder.
11:30:24 <Saizan> (some also worry about typeclass dictionaries getting bigger, but i think that's pretty moot)
11:30:28 <Jesin> get rid of (>>)
11:30:30 <Jesin> and fail
11:30:46 <Saizan> monochrom: depends.
11:30:57 <Jesin> I find it makes monads easier to understand
11:31:07 <Tomsik> You don't need more laws
11:31:15 <Tomsik> Er, I mean, you don't need to be afraid of
11:31:17 <Tomsik> more laws
11:31:23 <ski> Saizan : well, just as we can choose which set of operations to implement in other clases, we should be able to choose which set of laws corresponding to the set of operations that we implement that we need to think about, and prove
11:31:26 <Tomsik> You just need a better notation for them
11:31:31 <Saizan> these laws would actually give you more information, they'd just impose the coherency that currently is given by construction
11:31:38 <Saizan> *wouldn't
11:31:44 <Jesin> I really had no idea what (>>=) did until I learned that m >>= f = join (fmap f m)
11:32:17 <Tomsik> I see (=<<) as monadic application
11:32:21 <Tomsik> :t (=<<)
11:32:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:32:24 <Jesin> and I think the list monad could be better implemented with join = concat
11:32:26 <Jesin> :p
11:33:56 <Tomsik> :t (<*>).return
11:33:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f, Monad f) => (a -> b) -> f a -> f b
11:34:03 <Tomsik> whoops
11:34:40 <monochrom> because humans are not as intelligent as computers, "does not give more information" in the information-theoretic sense is pretty irrelevant.
11:35:09 <monochrom> there are redundant laws because humans need the redundancy.
11:35:59 <Jesin> yeah
11:36:23 <NemesisD> is it possible to export a constant from a module
11:37:03 <copumpkin> preflex: seen pozic
11:37:04 <preflex>  pozic was last seen on #haskell-blah 9 minutes and 26 seconds ago, saying: Can someone unban me in #haskell? I think someone cannot really control his admin powers.
11:37:36 <Jesin> I say put join in the class, add more laws and a thing that says "this subset of the laws implies this other subset, so you only need to prove one and you've got all of it"
11:37:42 <monochrom> for example when I do peano arithmetic, in the information-theoretic sense the famous peano axioms "suffice". but I use the "derived" x+y=y+x so much I'll add it as an extra law. In fact I don't even use the famous peano axioms all that often. Another example of redundant law I use all the time is (m<n iff m+1<=n).
11:38:24 <Jesin> yeah
11:38:25 <copumpkin> mmm peano
11:38:37 <copumpkin> monochrom: funny you should mention that! I'm just working on that :P
11:39:04 <monochrom> I would even say, because I'm a lowly human, (m<n iff m+1<=n) gives me much more understanding than the successor mumble-jumble.
11:39:07 <Jesin> umm
11:39:08 <Jesin> http://www.haskell.org/pipermail/libraries/
11:39:14 <Jesin> is there a good way to search that?
11:39:23 <Jesin> I wanna find the thing where they don't decide to put join in Monad
11:39:45 <chrisdone> copumpkin: He was being abusive and vile before. Nothing new there. But was doing it in the channel and then to the person who put him on silent to stop it. He ought to learn to control his temper before speaking of others'.
11:39:55 <Saizan> yeah, but this additional law isn't a nice composition of the others, it's more or less at the same level of usefulness, it's just additional complexity
11:40:15 <Jesin> yes and it gives better understanding
11:40:20 <Jesin> and the other thing is
11:40:24 <Jesin> you don't even HAVE to use it!
11:40:31 <copumpkin> chrisdone: oh I see
11:40:34 <copumpkin> chrisdone: oh yay, you're back!
11:40:57 <chrisdone> copumpkin: That's right, Gary. Did you see my replies about hpaste? (Guess not.)
11:41:07 <copumpkin> chrisdone: I did :0
11:41:09 <copumpkin> :)
11:41:13 <Jesin> if you're too lazy to learn the join laws, just use the old (>>=) laws and verify that join m = m >>= id
11:41:16 * adu is so happy
11:41:24 <Tomsik> is there some name for this:
11:41:26 <Tomsik> :t \f -> join . liftM f
11:41:27 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> m a1 -> m a
11:41:47 <Jesin> yes
11:41:50 <Jesin> that's called (>>=)
11:41:56 <Jesin> err
11:41:58 <Jesin> sorry
11:41:59 <chrisdone> copumpkin: I'm using FastCGI at work so I don't think it's that. I think it's the Takusen driver.
11:42:00 <Jesin> (=<<)
11:42:05 <chrisdone> copumpkin: Come va? ;-)
11:42:45 <copumpkin> benissimo
11:42:54 <NemesisD> anyone? i need to export a list of tests (as an algebraic data type?) that i can merge into a main test list
11:43:06 <Tomsik> Darn :(
11:43:20 <Tomsik> I don't like (=<<) and (>>=) for aesthetic reasons
11:43:51 <Jesin> well, there are only so many pretty combinations of punctuation
11:44:10 <monochrom> I suggest ⊱
11:44:27 <Jesin> hmm
11:44:27 <adu> oooo pretty
11:44:32 <chrisdone> copumpkin: A colleague told me of tongue twister you told me about a while ago. Trentatre trentini entrarono a trento, tutti a trentretrrtrrr.. *explodes*
11:44:39 <Jesin> does GHC accept unicode nicely like that btw?
11:44:41 <copumpkin> :)
11:44:48 <monochrom> yes!
11:44:50 <copumpkin> tutti trotterellando
11:44:52 <copumpkin> :P
11:44:58 <monochrom> even lambdabot does these days
11:45:14 --- mode: ChanServ set +o mauke
11:45:14 --- mode: mauke set -b $a:pozic
11:45:23 <adu> > length "∀"
11:45:23 <lambdabot>   1
11:45:24 <chrisdone> copton: trotterellando seriously hard for me, haha.
11:45:28 <monochrom> > let (⊱) = (>>=) in [1,2,3] ⊱ \x -> [x+1]
11:45:29 <lambdabot>   [2,3,4]
11:45:39 <Jesin> :D
11:45:46 <Jesin> that's pretty awesome
11:45:46 <Tomsik> > let ś ć ł = ć + ł in ś 3 4
11:45:47 <lambdabot>   7
11:45:57 <chrisdone> copumpkin: Woops. XChat's completion, not used to it.
11:46:00 <copumpkin> chrisdone: there's also "sopra la panca la capra canta; sotto la panca la capra crepa"
11:46:01 <kmc> is there any way to convert between Handle and Foreign.C.Types.CFile?
11:46:04 <kmc> i kinda doubt it
11:46:04 --- mode: mauke set -o mauke
11:46:12 <nosila> hey
11:46:13 <chrisdone> copton: Haha. Awesome.
11:46:22 <chrisdone> copumpkin: Damnit!
11:46:24 <Jesin> oops
11:46:28 <Jesin> accidentally closed client
11:46:29 * chrisdone must switch to ERC
11:46:31 <Jesin> what'd I miss?
11:46:32 <nosila> how can you import a file that is one folder "up" the tree??
11:46:58 <nosila> *module
11:47:08 <chrisdone> nosila: You should set the load path when compiling/loading with GHC/GHCi so that it is included.
11:47:32 <adu> > let (×) = (*) in 4 × 5
11:47:34 <lambdabot>   20
11:47:36 <chrisdone> Like, src/ and tests/, and then you can import FooTest from test from a file in src/
11:47:42 <nosila> the oposite??
11:48:20 <adu> Jesin: you can also make modules which import and export unicode identifiers
11:48:34 <adu> Jesin: so you can make stuff other people can use
11:48:46 <Jesin> yaaaay
11:48:53 <Jesin> hmm
11:48:53 <nosila> like, if you want to import a module that is in a subfolder you do import SubFolder.Module, i want the oposite
11:49:09 <monochrom> there are also ⤜ and ⤚
11:49:09 <adu> something like Control.Monad.Unicode or Data.List.Unicode
11:49:20 <Jesin> GAH
11:49:21 <Jesin> wow
11:49:41 <Jesin> hmm, does GHC interpret ∀ as forall?
11:49:47 <copumpkin> with UnicodeSyntax turned on
11:49:53 <Jesin> k
11:49:56 <Jesin> ^^
11:50:04 <Jesin> ooh
11:50:28 <nosila> chrisdone:  isnt there a way to do that in the code? 
11:50:39 <Jesin> does that also make ⊛ be <*>
11:50:52 <mwnaylor>  newbie here.  any opinions on the o'reilly book _Real World Haskell_?
11:51:01 <chrisdone> nosila: Possibly add it with {-# OPTIONS .. #-}, but I don't think so from Haskell proper.
11:51:08 <narens> mwnaylor: it's very good
11:51:09 <Jesin> apparently it doesn't
11:51:14 <Jesin> which is nice
11:51:21 <Jesin> hehe
11:51:23 <Jesin> hmm
11:51:43 <nosila> crhisdone: hum what? could you explain that a little bit or give me a link that can ?
11:51:58 <Jesin> I guess no infix type constructors are allowed except (->) and the various (,) are they?
11:52:10 <Jesin> and all infix data constructors have to start with :
11:52:10 <opqdonut> with an extension, yes
11:52:14 <chrisdone> nosila: The general idea is the compiler is supposed to be at the toplevel directory for all modules. That's why you have to add other directories for it to be toplevel too.
11:52:35 <opqdonut> Jesin: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/data-type-extensions.html
11:52:38 <nosila> chrisdone: eitherway, i'm using winGHCI, how should i add that?
11:52:44 <chrisdone> nosila: Well, I mean {-# OPTIONS -ifoo #-} will add it.
11:53:04 <chrisdone> nosila: In GHCi, :set -lpath.
11:53:11 <Jesin> there has to be at least some sort of pragma or extension already that puts join in Monad
11:53:13 <Jesin> please?  :p
11:53:19 <chrisdone> Alternatively just :cd to the top-level path.
11:54:04 <chrisdone> nosila: You can use it multiple times, btw. :set -lfoo -lbar -lmu to set many load paths. I think. I've never needed to do it. Let me know if it works.
11:54:06 <mwnaylor> narens:  any suggested reading order?  skip some chapters or just read through?
11:54:26 <nosila> damn, dont know wth that does lol
11:54:32 <narens> mwnaylor: go through each one, and try the examples yourself
11:55:04 <narens> mwnaylor: just experiment code snippets in ghci
11:55:06 <nosila> i just need to get a module that is in a upper folder just for testing but i guess i can do the oposite also
11:55:09 <nosila> easier lol
11:55:30 <chrisdone> nosila: http://www.haskell.org/ghc/docs/latest/html/users_guide/
11:55:59 <chrisdone> nosila: Not sure where it is in the guide... (how to use -l).
11:56:10 <mwnaylor> narens:  i'll try it again, and try examples.  just reading the json section made my mind wander.
11:56:20 <chrisdone> nosila: Yeah, so what's the upper directory called?
11:56:20 <nosila> random thing, what is the ! and $ for??
11:56:33 <nosila> chrisdone: ADS
11:57:07 <chrisdone> nosila: So in GHCi try writing this: ":set -l. -lADS" and then ":m + TheModuleName"
11:57:13 <narens> mwnaylor: well, if you want another novice perspective I recommend: learnyouahaskell.com
11:58:12 <Rotaerk> mwnaylor, I tended to skip the overly extensive examples
11:58:20 <ski> Tomsik : `(=<<)' is also sometimes called `extend', and `(f =<<)' is sometimes written as `f^*', and sometimes `f =<< ma' is written like `f * ma' in the literature
11:58:24 <ski> monochrom : in my take `m<n iff m+1=<n' is part of the definition of `=<' :)
11:58:26 <chrisdone> nosila: You mean the Haskell functions (!) and ($)? The former is usually used for dereferencing at an index of an array or vector-like thing, the latter applies its right hand side to its left.
11:58:53 <ski> nosila,chrisdone : in some contexts `!' is for making things strict
11:58:54 <mauke> s/right/left/
11:59:00 <ski> @src ($!)
11:59:00 <lambdabot> f $! x = x `seq` f x
11:59:20 <chrisdone> mauke: Do you apply a function to parameters or parameters to a function?
11:59:30 <ski>   f $! !x = f x  -- alternative definition, using `BangPatterns'
11:59:32 <mauke> chrisdone: I apply a function to parameters
11:59:47 <monochrom> Except for consistency proofs, I don't make a big fuss about axiom ≠ definition ≠ theorem ≠ law
11:59:54 * hackagebot wai-app-static 0.0.1.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.0.1.1 (MichaelSnoyman)
11:59:56 * hackagebot yesod 0.7.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.7.0 (MichaelSnoyman)
11:59:59 * hackagebot yesod-auth 0.3.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.3.0 (MichaelSnoyman)
12:00:01 * hackagebot yesod-core 0.7.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.7.0 (MichaelSnoyman)
12:00:03 * hackagebot yesod-form 0.0.0 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.0.0 (MichaelSnoyman)
12:00:05 <chrisdone> Okay. I never remember which way round it is.
12:00:07 <nosila> could you give me an easy and simple exemplo of (!) and ($) usage??
12:00:20 <mauke> @src ($)
12:00:20 <lambdabot> f $ x = f x
12:00:29 <mauke> > sqrt $ 2
12:00:30 <lambdabot>   1.4142135623730951
12:00:50 <chrisdone> > sqrt $ 2 * 3
12:00:51 <lambdabot>   2.449489742783178
12:01:04 * hackagebot yesod-json 0.0.0 - Generate content for Yesod using the json-types package.  http://hackage.haskell.org/package/yesod-json-0.0.0 (MichaelSnoyman)
12:01:07 * hackagebot yesod-newsfeed 0.0.0 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-0.0.0 (MichaelSnoyman)
12:01:09 * hackagebot yesod-persistent 0.0.0 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-0.0.0 (MichaelSnoyman)
12:01:11 * hackagebot yesod-sitemap 0.0.0 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-0.0.0 (MichaelSnoyman)
12:01:13 * hackagebot yesod-static 0.0.0 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.0.0 (MichaelSnoyman)
12:01:29 <Rotaerk> geez, hackagebot, spam why dontcha
12:01:53 <chrisdone> Why do all those packages come under the yesod prefix? 
12:01:55 <gwern> Rotaerk: the only thing worse than lots of uploads to hackage is the opposite
12:02:01 <Rotaerk> heh
12:02:11 <mauke> gwern: ... lots of downloads?
12:02:51 <chrisdone> Lots of hackages to upload.
12:03:46 <nosila> and for the (!) ?
12:03:55 <mauke> :t listArray
12:03:56 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
12:04:07 <nosila> Thanks for the ($) examples ;)
12:04:24 <mauke> > listArray (0, 25) ['a' .. 'z'] ! 12
12:04:25 <lambdabot>   'm'
12:04:42 <ClaudiusMaximus> > M.empty M.! ()
12:04:43 <lambdabot>   *Exception: Map.find: element not in the map
12:04:54 <marekweb> ok i have been struggling with this for a while now. I wrote a function called lengthWithoutSpaces :: String -> Int.  Now I want to sort a list of strings by the values returned by it, how do I do this?
12:05:10 <mauke> sortBy (comparing lengthWithoutSpaces)
12:06:05 <marekweb> aha
12:07:19 <ClaudiusMaximus> perhaps:   map fst . sortBy (comparing snd) . map (\s -> (s, lengthWithoutSpaces s))  -- profiling should help you decide whether it's worthwhile
12:08:46 <mauke> map snd . sort . map ((,) =<< lengthWithoutSpaces)
12:09:46 <jeffwheeler> I'm trying to play with Yesod, but I can't seem to get the most basic examples to run. I've copied the sample helloworld.hs file from the book, removed the $ in the TH, and tried running it.
12:09:47 <jeffwheeler> http://hpaste.org/paste/43654/yesod_problem_annotation#p43655
12:10:00 <jeffwheeler> But it seems like the TH generates a "naked expression" at the top level.
12:10:18 <jeffwheeler> I think I understand what that means, but I don't know how to fix it.
12:11:34 <doserj> jeffwheeler: mkYesod is a TH function? Why did you remove the $?
12:11:49 <jeffwheeler> doserj: isn't that a necessary change for 7.0?
12:12:20 <jeffwheeler> doserj: without it, I get indentation problems.
12:12:44 <jeffwheeler> (And to fix the indentation problems, I can indent the / line, but that causes a parse error.
12:13:46 <doserj> jeffwheeler: mkYesod is not a quasiquoter. You still need sth like $(mkYesod ...)
12:14:18 <ski> @type ((,) =<<)
12:14:19 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
12:14:19 <ski> @type (arr id &&&)
12:14:20 <lambdabot> forall b (a :: * -> * -> *) c'. (Arrow a) => a b c' -> a b (b, c')
12:14:23 <ski> @type (id &&&)
12:14:24 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
12:14:56 <jeffwheeler> doserj: Do you mean like this last paste? That fails immediately on the first $ -- http://hpaste.org/paste/43654/yesod_problem_annotation#p43656
12:15:54 <marekweb> mauke, where do i import 'comparing' from?
12:16:09 <doserj> LANGUAGE TemplateHaskell?
12:16:45 <monochrom> Data.Ord.comparing iirc
12:17:06 <jeffwheeler> doserj: doh, that was it (and then removing the $ like I did originally). Was that not necessary in 6.12?
12:17:11 <monochrom> @hoogle comparing
12:17:11 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:17:14 <monochrom> :)
12:17:32 <marekweb> thanks
12:17:58 <jeffwheeler> doserj: (also, thanks a bunch for the help)
12:18:57 <doserj> jeffwheeler: yeah, $(..) or not shouldn't actually matter it seems. I have no idea if LANGUAGE QuasiQuotes used to imply TemplateHaskell...
12:19:29 <jeffwheeler> doserj: What's the $(...) syntax normally used for?
12:19:59 <pozic> GHC 7 is 6 times faster than GHC 6.12 on just counting some byte occurences. It is still 50 times slower than C++, though. 
12:20:31 <doserj> $(f ...) tell ghc that f is TH function to be executed at compile time and splice in the result of f "as source code". 
12:20:31 <djahandarie> pozic, is that with LLVM or the NCG (on 7)?
12:20:46 <pozic> djahandarie: the defaults. I don't know what is default.
12:20:53 <djahandarie> The default is the NCG.
12:20:57 <jeffwheeler> doserj: gotcha, thanks
12:20:59 <djahandarie> Try out -fllvm
12:21:13 <doserj> on the top-level, you don't need the $(...), but you can use $(...) inside other expressions, declarations, etc
12:21:27 <djahandarie> You might need to pass some flags to llvm to get it to do the optimization you need and those can be hard to find sometimes though
12:21:38 <marekweb> thanks for the help all, without this channel I would still be lost
12:22:41 <pozic> djahandarie:  ghc --make -O2 -fllvm gives me 6.12 levels of slowness. 
12:23:04 <djahandarie> Yeah, it sometimes does worse than the NCG
12:23:41 <djahandarie> I've found that it performs better when you're using Data.Vector heavily
12:24:10 <edwardk> djahandarie: the llvm backend?
12:24:15 <djahandarie> Yeah
12:24:38 <systemfault> Data.Vector does wonder with the NCG
12:26:09 <djahandarie> pozic, oh, try dropping -optlo-O3 on there, not sure if that gets added in by default now or not
12:27:10 <pozic> djahandarie: that wins 0.02 seconds.
12:28:18 <djahandarie> Heh. Well, if you really feel like wasting a bunch of time you can try running Acovea on it (which will find the optimum set of flags)
12:28:26 <djahandarie> Relevant: http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/
12:28:27 <ski> @index comparing
12:28:27 <lambdabot> bzzt
12:28:43 <aavogt> Data.Ord?
12:28:44 <djahandarie> LLVM isn't a silver bullet so you may not get anywhere with that, but it could be worth a shot
12:29:17 <ski> aavogt : yeah, as monochrom noted above .. i was just checking whether `index' knew (and it didn't ..)
12:29:24 <edwardk> wel, at least a local optimum ;)
12:29:41 <aavogt> yes @index is quite useless
12:29:48 <merijn> edwardk: Depends on your evolutionary algorithm
12:30:14 * djahandarie goes afk
12:30:26 <dankna> do I correctly understand dons to be saying on that page that GHC-with-LLVM no longer uses STG at all?
12:30:35 <edwardk> if your search space is large enough to justify using GP/GA techniques you won't be finding a global optimum ;)
12:31:00 <merijn> edwardk: If you use deterministic population selection evolutionary algorithms are guaranteed to find an optimum solutions (of course you might find the heat death of the universe before then...)
12:31:00 <edwardk> if its small enough to exhaustively search it, then they are terribly inefficient
12:32:08 <edwardk> they are a k-optimal solution to the multi-armed bandit problem. but any pre-existing knowledge of the payouts of the levers trumps executing blindly.
12:32:09 <Jafet> else unsafeBuyNewComputer -- important fallthrough, do not remove
12:32:22 <dankna> Jafet: haha
12:32:35 <copumpkin> pozic: is your haskell code actually good? cause no matter how smart your compiler is, it's not going to make bad code fast
12:33:49 <Philippa> well, not sufficiently bad code
12:35:35 <Jafet> Unless, sometimes, that compiler is gcc
12:35:41 <pozic> copumpkin: IMHO, it should run faster, because the meaning is trivial. 
12:35:48 <pozic> copumpkin: Full code: http://hpaste.org/43658/slow_haskell
12:37:19 <pozic> copumpkin: that is, the compiler should see that I am just counting some stuff and reading something from a file. It should have a strategy for dealing with that extremely common case. 
12:37:41 <copumpkin> then make it see that
12:37:51 <pozic> copumpkin: it should write the C++ code (which runs in 0.03 seconds for a 31M file input). 
12:38:02 <copumpkin> typically people arguing that "the compiler should see what I'm doing and do it faster" don't realize how hard it is to make compilers see things
12:38:37 <copumpkin> try it with Vector
12:38:48 <pozic> copumpkin: I can probably port the C++ low-level details to Haskell, but then there is no point in using Haskell anymore.
12:39:04 <copumpkin> sure
12:39:07 <pozic> The type-safety of C++ is the same, the C++ is shorter, etc. 
12:39:16 <opqdonut> err
12:39:17 <copumpkin> even then it won't be as fast, because CHC doesn't do many low-level optimizations
12:39:18 <systemfault> lol
12:39:23 <opqdonut> "extremely common case" <- I don't agree
12:39:34 <opqdonut> minimal benchmarks are uninteresting, mostly
12:40:03 <copumpkin> pozic: anyway, most of the recent developments on speeding up array computations have been on the array/accelerate/repa front
12:40:18 <copumpkin> so unless you're using those, you're not really looking at the best we can do right now
12:40:45 <copumpkin> not sure this particular one would be much better though
12:40:53 <copumpkin> but it might be
12:41:13 <pozic> copumpkin: basically you are saying "hey, you are not using the alpha code in the repository of some academic that probably doesn't build at all."
12:41:20 <copumpkin> pozic: the best way to get low-level things optimized is to post a blog post (you're pretty close to this approach already, fwiw) saying how much haskell/GHC sucks because your particular microbenchmark is slower
12:41:31 <copumpkin> pozic: you were unbanned recently, but that can change again
12:41:39 <copumpkin> pozic: it's a _very_ common package on hackage
12:41:41 <copumpkin> lots of things use it
12:41:52 <pozic> copumpkin: what is wrong with what I said? 
12:41:58 <copumpkin> you didn't even bother looking it up
12:42:04 <copumpkin> and stereotyped haskell as academic bullshit
12:42:06 <pozic> copumpkin: I have already seen it. 
12:42:21 <copumpkin> then you're just wrong
12:42:31 <copumpkin> people use it all over the place
12:42:42 <copumpkin> it's actually easier to use than most of the base arrays
12:42:52 <kfr> <copumpkin> and stereotyped haskell as academic bullshit <- hey, that's the only reason I even started learning Haskell
12:42:53 <copumpkin> because it has an interface much closer to lists
12:42:56 <opqdonut> yeah, vector is great
12:43:35 <pozic> I can rewrite it one more time. What is the best Haskell can offer? 
12:43:52 <kfr> pozic: For what?
12:44:08 <copumpkin> pozic: I just told you
12:44:45 <pozic> copumpkin: you specified multiple options, AFAIK.
12:44:51 <copumpkin> vector, then
12:45:05 <copumpkin> repa and accelerate are for certain kinds of parallelism
12:45:28 <ddarius> copumpkin: You need to preemptively give up on people.  It will make you more serene.  Like me.
12:45:39 * copumpkin crosses his legs and goes "om"
12:46:10 <pozic> Ok, so you are saying that Andrew Coppin did not raise a valid point? 
12:46:17 <Saizan> ddarius++
12:46:36 <dddarius> pozic: just try it and get back to us. I'm not going to bother
12:46:39 <pozic> An obvious Haskell program simply _is_ 300 times slower in Haskell than in C++. 
12:46:47 <pozic> Yes, I will try it. 
12:47:15 <pozic> I mean I am open to change, I just think compiler writers cannot be taken seriously when they produce this kind of output :)
12:47:45 * fryguybob takes SPJ seriously.
12:47:57 <ddddarius> pozic: it's funny because you're trolling!
12:48:23 <pozic> Ok, so uvector or vector?
12:48:30 <ddddarius> "I'm sorry, the fact that GHC optimises Haskell-idiomatic functional programs better than just about any other compiler on Earth just isn't enough."
12:48:49 <pozic> That is because there is no competition. 
12:48:52 <elliott> (OK, so no other compiler really *tries* to do that, but GHC's still very good at what it does.)
12:48:56 <merijn> Sure there is
12:48:59 <merijn> OCaml
12:49:03 <elliott> pozic: Well, as far as functional language compilers go, GHC comes out basically on top.
12:49:12 <elliott> OCaml code tends to be faster, but OCaml code is usually much lower level/strict/imperative.
12:49:15 <pozic> merijn: and OCaml generally killed Haskell in performance. 
12:49:23 <elliott> See above.
12:49:24 <merijn> elliott: He was insinuating that there are no other functional languages competing
12:49:31 <elliott> For the kind of *functional* style that idiomatic Haskell programs are written in, GHC does amazingly.
12:49:58 <merijn> pozic: But how can you possibly justify the slow down of writing C++ instead of pure ASM? :>
12:50:38 <systemfault> Perhaps he's simply doing it wrong...
12:50:40 <elliott> I'm sure that, were I a C++ programmer, the sum of the time my code spends executing, and the time I spend crying and wondering where I went wrong in life, would vastly exceed the sum of my execution and development time as a Haskell user.
12:50:55 <pozic> Stalin is an example of how compilers should work. 
12:50:59 <elliott> The first variable to optimise for is "not crying and wondering where I went wrong in life to be using such a horrible language".
12:51:08 <elliott> pozic: STALIN only supports a *subset* of R4RS.
12:51:18 <elliott> pozic: Furthermore, it does best on heavy, numeric code, not general programs.
12:51:38 <elliott> Besides, Scheme programs usually have a sequential, strict structure, even if it's hidden with tail recursion.
12:51:40 <merijn> I can count the number of times I have had problems with language speed in my programs on 0 hands
12:51:45 <pozic> elliott: yes, but it was written by one guy. 
12:51:51 <elliott> pozic: How is that relevant?
12:52:02 <elliott> What STALIN does is easier than what OCaml does. What OCaml does is far easier than what GHC does.
12:52:25 <elliott> The fact that GHC produces pretty damn good code for such maintainable and elegant functional programs is a testament to how impressive a compiler it is.
12:52:37 <pozic> elliott: I completely disagree on that. 
12:52:44 <elliott> pozic: That is because you are a troll.
12:52:54 <pozic> elliott: if I would write it in a readable way, it would be 1000 times slower. 
12:53:00 <merijn> elliott: You are wasting time
12:53:05 <elliott> pozic: Go use OCaml.
12:53:11 <elliott> merijn: Evidently.
12:53:12 <copumpkin> okay
12:53:17 <copumpkin> let's stop feeding
12:53:21 <merijn> You should join us in the Zen corner of not feeding the trolls :)
12:53:21 <ezyang> om nom nom nom 
12:53:48 <ezyang> A few weeks ago I got annoyed because I wrote some idiomatic list processing code, and GHC didn't optimize it away >:-) 
12:55:04 <Saizan> ghc just tought you liked lists, so left some there
12:55:10 * hackagebot asn1-data 0.4.5 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.4.5 (VincentHanquez)
12:55:13 * hackagebot certificate 0.6.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.6.0 (VincentHanquez)
12:55:47 <ezyang> "Premature optimization is the root of all evil" -> "Not if you put it into your compiler!" 
12:57:18 <elliott> Seriously, I don't get this performance obsession.
12:57:38 <elliott> Like maybe once have I thought "oh, I want this to be fast, I'll write it in C instead of Haskell", and /that's/ because the thing I was implementing was hideously inefficient by design.
12:58:02 <dankna> if you write in *cough* certain non-Haskell languages *cough*, you get slowness for free
12:58:21 <dankna> but apart from the language impl being downright brokenly slow, I agree that performance obession hardly matters
12:58:46 <merijn> Like I said, I can count the number of times where language speed was an issue for me on zero hands
12:58:51 <Saizan> depends on the domain i think
12:58:58 <dankna> well, yes, as Saizan says
12:59:15 <dankna> certainly if you're writing hard-realtime DSP
12:59:26 <merijn> Saizan: Well sure, that doesn't hold for supercomputing or scientific number crunching, but people that do that should know what they're doing
12:59:30 <Saizan> or even if you have very large data sets
13:00:01 <merijn> I subscribe to the motto: "If you need to ask, language speed is not your problem."
13:00:56 <Saizan> the question is if it's feasible even with perfect knowledge
13:02:23 <pozic> The problem is that "FP people" go around screaming "FP is fast", while in fact that has never been demonstrated. 
13:02:32 <Saizan> e.g. tibbe started working on a more efficient Map-like data structure because he felt there were none good enough (especially memory-wise i think)
13:02:49 <merijn> pozic: If you disagree, feel free to leave
13:03:05 <pozic> merijn: that is ad hominem. 
13:03:10 <elliott> what.
13:03:15 <merijn> pozic: No it isn't
13:03:20 <elliott> copumpkin: is that sufficiently close to outright trolling? :)
13:03:31 <Martty> ignrage commencing
13:03:38 <Martty> ignorage even
13:03:41 <copumpkin> elliott: I actually followed ddarius' suggestion
13:03:47 <merijn> Ad hominem would be if I tell you to go the hell away because you're an idiot. (Which is true, to!)
13:03:52 <elliott> copumpkin: pssht, madman!
13:03:56 <elliott> let's get out the pitchforks
13:04:01 <copumpkin> anyway
13:04:03 <copumpkin> both of you
13:04:04 <mauke> well, well, well
13:04:12 <mauke> what's this, then?
13:04:34 <ClaudiusMaximus> my time is more important than CPU time (because i can always buy more CPUs) - I can write algorithms in Haskell much more than 5x quicker than I can in C++, so i don't care if they take 5x as long to run when compiled with ghc vs g++
13:04:36 <merijn> mauke: Shocking news, Haskell is actually really slow and sucks! Who knew? :>
13:04:41 <pozic> I am surrounded by idiots. That's all. 
13:04:51 <pozic> No need to waste time on that.
13:05:15 <elliott> pozic: don't waste your time with us fools then
13:05:19 <dankna> I had somebody the other day try to convince me that ten degrees Fahrenheit is "twice as warm" as five degrees Fahrenheit
13:05:29 <elliott> hey Cale, you should fix Caleskell, ($) is still infixl
13:05:32 <elliott> erm
13:05:33 <elliott> hey Cale, you should fix Caleskell, ($) is still infixr
13:05:33 <dankna> (the connection is being surrounded by idiots)
13:05:36 <pozic> elliott: not all of the people in #haskell are idiots. 
13:05:38 <ezyang> ClaudiusMaximus: Of course, when the program takes a long time to run and you wait for the result, it wastes your time too :-) 
13:05:51 <elliott> pozic: sorry, we can drive away the others if you'd like :)
13:06:02 <dino-> How would we get OCaml's functor behavior in Haskell? Is it really just simply that Haskell has higher-order types?
13:06:08 <ClaudiusMaximus> ezyang: i can sleep while i wait (gotta do it sometime!) :)
13:06:19 <elliott> theory: people like spending more time coding for shorter runtime, because coding is busywork and you don't notice time passing
13:06:30 <elliott> whereas execution is usually uneventful until you get a result, and thus the time drags out
13:07:17 <ClaudiusMaximus> i heard 'ld' sucks and 'gold' is better - how do i make cabal-install use it?
13:07:18 <gwern> coding is fun. waiting isn't.
13:07:22 <parcs> when would one use an IntMap over a Vector?
13:07:33 <copumpkin> parcs: for fast updates
13:07:39 <Saizan> dino-: depends, what are you using them for?
13:07:43 * ezyang doesn't think coding is fun, and tries to avoid it as much as possible :-) 
13:07:57 <ezyang> dino-: Functor typeclass? 
13:08:04 <ddarius> dino-: There's a paper that shows how to encode a module system similar to SML's and O'Caml's into Haskell type classes (and vice versa.)
13:08:05 <ezyang> Or are you talking more generally about OCaml modules? 
13:08:06 <elliott> ClaudiusMaximus: gold is a bit faster.
13:08:06 <dino-> Saizan: Not sure, I'm not, but am curious as to what it is that's analogous in Haskell to this.
13:08:07 <pozic> copumpkin: you just suggested me to use vector for a problem that requires updates. 
13:08:09 <elliott> ClaudiusMaximus: I wouldn't bother.
13:08:09 <aristid> ezyang: why are you not doing something entirely unrelated to software, then?
13:08:12 <edwardk> hrmm, is someone around that can fix a problem on the hackage server?
13:08:13 <ClaudiusMaximus> parcs: sparseness would be my guess
13:08:15 <ezyang> ddarius: Oleg, by any chance? 
13:08:16 <pozic> copumpkin: are you internally inconsistent? 
13:08:23 <elliott> ClaudiusMaximus: The actual results are the same, gold is just a bit faster, and I doubt linking time is taking up too much of your compiles.
13:08:25 <ddarius> dino-: Luckily for you, the encoding into Haskell isn't too bad, and has probably been improved by recent language additions.
13:08:25 <ezyang> aristid: :-) 
13:08:39 <ClaudiusMaximus> elliott: the problem i'm having is 'ld' using too much memory
13:08:44 <edwardk> pozic: copumpkin is very much a contradiction in terms
13:08:45 <ddarius> edwardk: You clogged up the tubes?
13:08:46 <elliott> Mind you, Haskell's module system really needs replacing with ML's.
13:08:48 <byorgey> pozic: who isn't?
13:08:51 <elliott> It's just plain better. :p
13:08:53 <ddarius> edwardk: He is?
13:09:00 <edwardk> ddarius: a while ago: http://hackage.haskell.org/packages/archive/ad/1.0.0/logs/failure/ghc-7.0
13:09:19 <aristid> ezyang: also, coding IS fun :P
13:09:28 <edwardk> ddarius: yeah he's like british and american and italian — at the same time. its quite strange
13:09:29 <dino-> ezyang: yes, modules, not the confusing (triple!) overloading of that word.
13:09:32 <byorgey> "Do I contradict myself? Very well, then I contradict myself, I am large, I contain multitudes." - WW
13:09:53 <merijn> byorgey: Who's the WW stand for?
13:10:02 <byorgey> Walt Whitman
13:10:04 <edwardk> ddarius: it looks like the template-haskell interface file is busted
13:10:15 <ezyang> aristid: Coding is fun. Being wrapped up in a puzzle that you're gradually solving is fun. Getting stuck is not. 
13:10:15 <ddarius> dino-: Here's one of the papers: http://www.cs.rutgers.edu/~ccshan/xlate/xlate.pdf
13:10:28 <dino-> ddarius: Terrific, thank you.
13:10:33 <ezyang> Lack of puzzle (reduction of coding to data entry) is not fun. 
13:10:46 <ezyang> Of course, I find that when I get unstuck is usually when I learn the most. 
13:10:46 <aristid> ezyang: full agreement
13:11:16 <edwardk> or maybe i just need to raise the ceiling on the template-haskell dependency
13:12:14 <aristid> edwardk: huh?
13:12:36 * aristid is confused by what "raise the ceiling" might mean
13:12:36 <copumpkin> pozic: anyway, at a glance, I'd guess that BS.unpack is your source of slowness
13:12:52 <copumpkin> pozic: what's the point of even reading in a bytestring if you're going to convert it to a list?
13:13:03 <edwardk> aristid: in the cabal file its capped below 2.5, the current TH is 2.5
13:13:32 <aristid> edwardk: yeah, you gotta fix that :)
13:13:50 <ddarius> dino-: Here's a huge document about it: http://www.stefanwehr.de/publications/Wehr_ML_modules_and_Haskell_type_classes.pdf
13:14:09 <aristid> edwardk: also, flood snoyman out of the what's new list!
13:14:23 <NemesisD> any test-framework/hunit users?
13:14:36 <ddarius> dino-: And a much smaller version: http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf
13:14:38 <edwardk> aristid: well, thats a dangerous arms race. he came along and flooded me out, so i might as well give him his moment in the sun
13:14:55 <edwardk> … before crushing him ;)
13:15:02 <NemesisD> i've got a test main and some number of test modules, i'd like to figure out how to export array constants of tests from them, concat them in main and run them
13:15:09 <aristid> edwardk: you are just too nice.
13:15:41 <ezyang> NemesisD: Yo. 
13:15:48 <ezyang> But you should just ask your question. 
13:15:51 <ezyang> oh, you did :-) 
13:16:04 <dino-> ddarius: Thank you.
13:16:15 <NemesisD> i don't know if its a crazy thing to export a constant but i sure am having a hard time with it
13:16:16 <edwardk> can someone with ghc 7 'trie' and install the 'representable-tries' package and tell me what breaks?
13:16:18 * hackagebot ad 1.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.0.1 (EdwardKmett)
13:16:21 <ezyang> NemesisD: You can totally export arbitrary variables from modules. They don't have to be functions. 
13:16:33 <ezyang> The only possible problem is the monomorphism restriction. 
13:16:43 <NemesisD> whats that now?
13:16:52 <ddarius> NemesisD: The only things you can export are constants.
13:17:45 <pozic> copumpkin: did you look what I said at the top of the paste? 
13:17:55 <copumpkin> pozic: I did
13:17:56 <yuji> This is an absurdly amazing website :D
13:18:03 <pozic> copumpkin: so, very creative comment then.
13:18:10 <ezyang> NemesisD: Non-functions may be less polymorphic than you expect them to be. 
13:18:12 <monochrom> irc is a website?
13:18:14 <NemesisD> by constant i meant non-function
13:18:19 <NemesisD> i think
13:18:34 <copumpkin> pozic: my point is, you're bitching about it being slow while knowing why it's slow. Fix that, then bitch if it's still slow
13:18:37 <yuji> tryhaskell.org pointed me to IRC in browser
13:18:45 <monochrom> module M(c) where c=0
13:18:57 <ddarius> copumpkin has backslid.
13:19:08 <Saizan> ezyang: nothing
13:19:18 <Saizan> edwardk: nothing, it installs fine
13:19:35 <monochrom> oh, tryhaskell.org is absurdly amazing, I agree :)
13:19:39 <edwardk> saizan: k, then hackage was just being a little out of sync with itself when the build bot got to it
13:19:52 <merijn> yuji: If you're just starting out I can also recommend reading Learn You A Haskell
13:19:58 <pozic> copumpkin: now you just ignore everything I said before. 
13:20:12 <edwardk> pozic: seriously, chill the fuck out
13:20:21 <NemesisD> hmm maybe my problems lie elsewhere, i have different modules which define records that happen to have fields with the same name
13:20:27 <byorgey> yuji: welcome, glad you are enjoying it =)
13:20:30 <pozic> edwardk: what makes you think I am not chilled? 
13:20:44 <pozic> edwardk: do you think I have a deadline for a totally uninteresting program?
13:20:56 <pozic> edwardk: do you think I care about what he says? 
13:21:06 --- mode: ChanServ set +o copumpkin
13:21:10 --- mode: copumpkin set +b *!~b@unaffiliated/pozic
13:21:10 --- kick: pozic was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
13:21:10 <edwardk> pozic: the fact that you've been actively denigrating and attacking anyone who even remotely look in your direction for a couple of days now
13:21:19 --- mode: copumpkin set -o copumpkin
13:22:46 <yuji> byorgey, merijn: thanks : )  I'm just browsing around.. went from stack to google to an rather smooth and fun tutorial
13:23:00 <yuji> funny*
13:23:36 * ddarius <3 vim.
13:23:49 <edwardk> saizan: can you repeat the experiment with 'ad'?
13:24:02 <fryguybob> edwardk: Built without problems for me with ghc-7.1.20110203
13:24:05 <edwardk> saizan: just running through and cleaning up errors on ghc 7 that i see in build logs
13:24:14 <edwardk> fryguybob: thanks =)
13:26:35 * Heffalump thinks this is a good reason to remind everyone of http://www.haskell.org/haskellwiki/IRC_channel#Principles
13:26:56 <Heffalump> I was particularly hoping to show it to pozic, but he's gone..
13:27:04 <edwardk> TL;DR version, be nice or else ;)
13:27:04 <Saizan> edwardk: http://hpaste.org/43660/some_errors
13:28:04 <copumpkin> Heffalump: he's chewing me out in #haskell-blah, if you'd like to
13:28:14 <fryguybob> edwardk: I don't get the first error from Saizan's paste but I do get the other two.
13:28:19 <edwardk> ugh. the ClassI stuff is template haskell API change. the Show (t a) one is a change in how instance body constraints propagate. i can fix the Show, but the other may require some gymnastics
13:28:34 <edwardk> (mainly because its tricky to do blind
13:30:28 <ClaudiusMaximus> elliott: i found instructions (as simple as: aptitude install binutils-gold) and now i can successfully (cabal install cabal-install) without running out of memory
13:30:34 * byorgey would also like to remind everyone that the principles don't cease to apply when you are interacting with someone who is violating them.
13:30:54 <elliott> ClaudiusMaximus: you didn't say you were running out of memory. :)
13:31:08 <elliott> I don't think that apt command will switch the default binutils aliases to gold ones though... but maybe.
13:31:11 <ezyang> Ooh, binutils-gold has worked wonders for me in the past. 
13:31:14 <elliott> Try "ls -l $(which ld)".
13:31:14 <ClaudiusMaximus> i did, 22 minutes ago
13:31:18 <Heffalump> byorgey: right.
13:31:21 <elliott> ClaudiusMaximus: ok, well I didn't see :P
13:31:22 <ClaudiusMaximus> and it does
13:31:25 * hackagebot wai-extra 0.3.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.3.2 (MichaelSnoyman)
13:32:47 <NemesisD> could someone help me figure why my constructor isn't in scope: http://hpaste.org/43662/i_fail_at_hunit
13:33:25 <parcs> ClaudiusMaximus: how did you make cabal-install use gold instead of ld?
13:33:42 <ClaudiusMaximus> parcs: no need, it's handled by Debian's 'diversions' mechanism
13:34:04 <dibblego> NemesisD: do you have MediaCollection.hs there?
13:34:17 <Saizan> NemesisD: if you say MediaCollection in the export list you're exporting only the type
13:34:33 <Saizan> NemesisD: use MediaCollection(MediaCollection) or MediaCollection(..)
13:34:49 <dibblego> oh sorry, it's there, yes see what Saizan said
13:34:49 <parcs> ClaudiusMaximus: ah, my distrubution doesn't feature that
13:35:08 <edwardk> hrmm, so basicaly to pattern match on ClassI  need to check the version of template-haskell and dipatch accordingly?
13:35:20 <NemesisD> Saizan: the .. corresponds to all the constructors? would it also include fields? it kind of irks me to have to manually export the fields
13:35:56 <Saizan> NemesisD: all the constructors, don't know about the fields
13:36:07 <schoppenhauer> hello. I was just looking for Liskell, but seems like all the repositories have been closed. Does anybody know what happened to the Liskell project?
13:36:35 <jix> schoppenhauer: if it's on code.haskell.org it's just a server problem
13:37:01 <ClaudiusMaximus> using Data.Vec, to get something working quickly i just copy-pasted some code to replace Vec2/Mat22 with Vec4/Mat44 - how might i refactor it to work generically for all VecN/MatNN ?  http://gitorious.org/maximus/gmndl/blobs/master/Roots.hs#line33
13:37:22 <schoppenhauer> jix: well, there is a directory, but its empty: http://code.haskell.org/liskell/
13:38:00 <chopin> Can anyone look at this please ?
13:38:03 <chopin> http://pastebin.com/ehsRtdR6
13:38:13 <chopin> How can I make it possible for each i i want ?
13:38:59 <Saizan> ClaudiusMaximus: what happens if you remove the type signature and let it be inferred?
13:39:46 <jix> schoppenhauer: yeah, the original server got hacked and the contents aren't transfered yet
13:40:07 <ClaudiusMaximus> Saizan: doesn't compile, can't infer size of matrix (when i last checked - i'll check again, in case something changed)
13:40:14 <jix> schoppenhauer: all (but 5 or so) projects on code.haskell.org are empty directories... and afaik that will be fixed the next days (i hope so)
13:40:26 <schoppenhauer> jix: ok, thank you.
13:40:41 <Saizan> ClaudiusMaximus: ah, j and y?
13:41:55 <ClaudiusMaximus> Saizan: something like that - removing all type signatures gives me 50 lines of contexts that are missing...
13:42:23 <NemesisD> Saizan: making progress, when i try to construct an instance of MediaCollection, i get errors about name and items not being (visible) fields of of constructor.
13:43:09 <aavogt> ClaudiusMaximus: matFromLists has to be told how large the matrix will be
13:43:26 <NemesisD> i've tried in the module declaration: MediaCollection(MediaCollection, name, items) and MediaCollection(MediaCollection), name, items to no avail
13:43:34 <aavogt> maybe there is a way to specify that it will be square
13:43:53 <wsgel> Hi, I'm a relative newcomer to Haskell, and I'd like to get started playing with web apps... there seem to be a number of good frameworks (Snap, Yesod, Happstack...) and not having much experience I'm having a little trouble sorting them out. Could you guys point me to a newb-friendly comparison of them?
13:43:55 <ClaudiusMaximus> aavogt: i know - but how do i say "i want a square matrix the same size in each direction as this vector"
13:46:27 <aavogt> ClaudiusMaximus: at the end of somewhere, you can put something like:        ...   `const` (j `asTypeOf` (y * transpose y)) -- if * is for multiplying vectors
13:46:48 <aavogt> then again, I dunno if the fundeps used there will let that help at all
13:46:58 <ClaudiusMaximus> aavogt: hmm, yes, was just thinking about outer products
13:47:51 <Saizan> you could also write a type family Square that maps a vector type to the type of the corresponding square matrix
13:48:43 <ClaudiusMaximus> chopin: break it down recursively into something like     | i == 1 = ...    | i > 1 = ... (foo (i - 1)) ...
13:52:38 <parcs> wsgel: nothing like that exists. if you are really new to haskell, they will all seem pretty daunting. if you not-so-new, then i suggest you take a look at all of them and decide for yourself.
13:53:59 <edwardk> saizan: hrmm i really have no good idea how to fix the Show error in ghc 7
13:54:05 <edwardk> the other two i've fixed
13:55:51 <edwardk> fryguybob: can you try pulling ad-1.0.2 and compiling that?
13:56:22 <fryguybob> yeah
13:56:32 * hackagebot ad 1.0.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.0.2 (EdwardKmett)
13:56:35 <wsgel> parcs: thanks, I'm inexperienced but comfortable with the language, so I guess that depends on the definition of new. Are they all pretty similar?
13:57:11 <edwardk> i added the CPP logic to build with either TH 2.4 or 2.5, but can't fix the show error that saizan ran into without deep voodoo
13:58:55 <fryguybob> edwardk: Seems happy.
13:59:11 <edwardk> fryguybob: on what version again?
13:59:22 * edwardk is trying to bracket the problem ;)
13:59:27 <fryguybob> 7.1.20110203
13:59:40 <edwardk> so 'bleeding edge'
14:00:15 <fryguybob> Yeah I was trying 7 for the first time yesterday.
14:01:36 <ddarius> edwardk: 7.1.20110203 is soo two days ago.
14:02:11 <edwardk> ddarius: of course. the two days it takes to build ghc! ;)
14:02:13 <systemfault> ddarius: It's 6.1
14:02:13 <fryguybob> the "stings but is healing edge".
14:02:20 <systemfault> Yeah... Windows 7 isn't really Windows 7
14:02:37 <systemfault> Windows 2000 was 5.0
14:02:40 <systemfault> XP 5.1
14:02:49 <systemfault> Vista 6.0 and Finally... Windows 7 is 6.1
14:02:51 <elliott> is there a getByte? I want to read literal bytes from stdin without pulling in all of ByteString.
14:02:56 <elliott> As Chars from 0 to 255 is fine.
14:02:59 <elliott> Or Word8s.
14:03:08 <systemfault> Hmm, wrong channel..
14:03:10 <systemfault> Damnit
14:04:34 <dmwit> elliott: Do you really want to read literal bytes, or do you want one of the serialization/deserialization libraries?
14:04:51 <elliott> dmwit: I really want to read literal bytes, yes.
14:04:59 <elliott> And put them, but putChar can actually do that.
14:05:24 * dmwit shrugs
14:05:34 <dmwit> Sounds like you want Data.Binary to me.
14:06:10 <elliott> dmwit: I really don't. :)
14:07:16 <ClaudiusMaximus> :t hGetBuf
14:07:17 <lambdabot> Not in scope: `hGetBuf'
14:07:24 <ClaudiusMaximus> @hoogle hGetBuf
14:07:25 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
14:07:25 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
14:07:25 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
14:08:04 <elliott> hm.
14:08:05 <elliott> Ptr.
14:08:13 <elliott> that will be... unworkable
14:08:18 <ClaudiusMaximus> it'll be fine
14:08:23 <ClaudiusMaximus> @hoogle alloca
14:08:23 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
14:08:24 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
14:08:24 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
14:09:15 <elliott> ClaudiusMaximus: I'd rather pull in ByteString than Ptr. Ptr is basically unworkable.
14:09:18 <elliott> ofc I'd prefer neither :p
14:09:22 <ClaudiusMaximus> something like:  getByte = alloca $ \p -> hGetBuf ... p ... >> peek p
14:09:27 <elliott> Can I set the encoding of stdout?
14:09:33 <elliott> To uninterpreted 8-bit, say?
14:11:03 * ClaudiusMaximus eats, bbl
14:11:20 <dmwit> ?hoogle encoding
14:11:20 <lambdabot> Network.CGI newtype ContentEncoding
14:11:20 <lambdabot> Network.CGI ContentEncoding :: String -> ContentEncoding
14:11:20 <lambdabot> Network.HTTP.Headers HdrAcceptEncoding :: HeaderName
14:11:42 <dmwit> ?hoogle hSetEnc
14:11:42 <lambdabot> No results found
14:11:51 <dmwit> Oh well, that was worth a shot. =P
14:12:05 <elliott> Select binary mode (True) or text mode (False) on a open handle. (See also openBinaryFile.)
14:12:06 <elliott> This has the same effect as calling hSetEncoding with latin1, together with hSetNewlineMode with noNewlineTranslation.
14:12:06 <elliott> tada
14:12:13 <elliott> hSetBinaryMode stdin True
14:14:48 * cizra is struggling with basic ffi stuff
14:15:21 <cizra> readFile :: (Sample e, Buffer a e) => FilePath -> IO (Info, Maybe (a e))
14:15:40 <cizra> It turns out I can't just call the function. I need to give it concrete types for a and e
14:15:42 <dibblego> for scripts, I use #!/usr/bin/runhaskell, but this doesn't work on OSX, should I use #!/usr/bin/env runhaskell ?
14:15:47 <elliott> dibblego: yes
14:15:53 <elliott> always use /usr/bin/env :p
14:15:58 <dibblego> ok thanks
14:16:41 <cizra> elliott: I've seen a machine where there was no /usr/bin/env. Can't recall what the OS was, though.
14:17:00 <elliott> cizra: Can always do "runhaskell foo" manually or edit the file if your OS is that braindead.
14:17:04 <parcs> nixos doesn't have /usr/bin/env, i've heard
14:17:18 <cizra> ^ about those Sample and Buffer, I have no idea what to put there. Double should be a good Sample, but Buffer is weird
14:17:23 <elliott> env is useful for more than running programs
14:17:28 <elliott> so nixos probably has env, maybe not in /usr/bin
14:17:30 <elliott> easy to symlink
14:20:39 * hackagebot ad 1.0.3 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.0.3 (EdwardKmett)
14:21:10 <edwardk> ok, ad should now work correctly on 7.0
14:21:25 <edwardk> thanks everyone
14:24:02 <elliott> yay, automatic differentiation
14:24:48 <edwardk> as soon as hmatrix gets split apart i should have a new version
14:24:59 <jix> now ai please
14:25:18 <jix> oh wait that requires ai...
14:25:18 <edwardk> jix: backpropagation is just a trivial application of automatic differentiation ;)
14:25:45 <edwardk> jix: no problem this is haskell, we excel at coinductive definitions like that ;)
14:25:53 <edwardk> just "fix ai"
14:25:57 <edwardk> done
14:26:22 <Saizan> sounds like a good plot for a doctor who episode
14:26:38 <aristid> :t let ai = fix ai in ai
14:26:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
14:26:39 <lambdabot>     Probable cause: `fix' is applied to too many arguments
14:26:39 <lambdabot>     In the expression: fix ai
14:26:44 <aristid> damn.
14:26:48 <aristid> ai can't be fixed
14:27:08 <edwardk> aristid: it can. just start with an ai, then fix it. don't make it its own fixed point.
14:27:25 <edwardk> :t let crappy_ai = id in fix crappy_ai
14:27:26 <lambdabot> forall a. a
14:27:33 <edwardk> see, you can derive anything!
14:28:13 <aristid> haskell!!!111
14:28:29 <edwardk> now, unfortunately its a pure function, so you can't interact with the ai.
14:29:42 <edwardk> but it'll happily chew up your spare cycles thinking about stuff, unless it has a nervous breakdown and detects that its in a <<loop>>
14:30:11 <edwardk> then it'll take a stab at the halting problem, killing itself, thereby showing its genius
14:31:06 * edwardk is rather sleep deprived. this was intended for #haskell-blah ;)
14:34:26 <aristid> edwardk: i wonder how you can do this stuff without sleeping
14:34:35 <aristid> or without sleeping enough
14:34:54 <edwardk> change topics enough, let the portions of my brain that aren't being actively used for the current topic rest ;)
14:35:03 * Twey suspects edwardk is going to change the world and then die an early death
14:35:22 <edwardk> i hope not. i want to be around for the semigroupoid filled world i create!
14:35:35 <Twey> Hehehe
14:35:38 <aristid> without even a single night of sleep, i get totally bad, and everything in me just wants to sleep
14:35:55 <edwardk> a lot of folks want to achieve immortality through their work. i want to achieve immortality through not dying.
14:36:13 * BMeph hopes he doesn't have a dream where he's groped by groupoid groupies! ...or does he?
14:36:20 <dankna> edwardk: I concur fully, but this is not an original sentiment :) I forget who said it...
14:36:29 <edwardk> woody allan i think
14:36:40 <dankna> really?  doesn't seem like him.  but who knows.
14:37:03 <shachaf> edwardk: Do you know Raymond Smullyan's recipe for immortality?
14:37:49 <shachaf> 1. Always tell the truth, and never make any false statement. 2. Say "I will repeat this sentence tomorrow".
14:37:55 <dankna> haha
14:37:58 <edwardk> yeah
14:38:00 <dankna> that's so Smullyan
14:38:56 * copumpkin read that as the recipe for immorality
14:46:18 <BMeph> Raymond Smullyan's recipe for immorality: 1. Never tell the truth, and always make any false statement. 2. Say "I will reearn my sentence tomorrow". ;)
14:48:29 <iago> what is the most recommended tool for automatic generation of Arbitrary (QuickCheck) instances ? Now I think the best choice is Agata but I would appecia
14:48:35 <iago> appreciate any advice
14:50:38 <edwardk> hrmm. i just found a use for haskellers.com, the package list will feed you when your packages have restrictions on the upper bounds of packages that keeps them from working wiht the latest versions of other packages
15:01:21 <edwardk> that is if i could log out of this silly new user account it made in order to try to figure out how to log in to edit my package list. meh
15:01:37 <bla123> i can build some app via "ghc --make", but doing so via cabal, ghc (6.12.3) tells me that "SomeException" was out of scope. is my cabal file missing something?
15:02:39 <dafis> bla123: probably cabal tries to build against base-3.*, put base >= 4 in the build depends
15:04:22 <bla123> dafis: fixed it, wow that was easy! why didn't it use the latest version? i had "base >= 3.0" in the cabal file
15:05:48 <dafis> bla123: there's a preferred version of base==3 because a lot of packages broke with base 4 when that was new; probably that should be removed now that base 4 is two major GHC versions old
15:06:20 <bla123> dafis: ok, good to know. thanks a lot
15:06:54 <dafis> No sweat
15:07:11 <Saizan> anyhow, it's a good thing, since now you've a correct constraint.
15:08:34 <bla123> saizan: to be honest, i have no clue what versions are required. do i have to try all versions of all libs?
15:09:23 <bla123> i simply put ">= (my current version)" in there
15:11:51 <Saizan> == x.y.* would be better, at least for packages which follow the PVP
15:12:09 <Saizan> where x and y are the first two components of your current version
15:12:53 * hackagebot hatt 0.3 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-0.3 (BenedictEastaugh)
15:16:00 <bla123> saizan: can a bump of the "y" part in "x.y" make the package incompatible to earlier versions with the same "x" part? (if following PVP)
15:16:17 <Saizan> yes
15:16:49 <bla123> oh, i thought that only meant that functionality was added
15:17:38 <Jesin> I thought generally a change in major version number meant backwards compatibility was broken
15:18:32 <Jesin> the second number meant stuff was added
15:18:43 <Jesin> and beyond that could be stuff added or just bugfix
15:18:45 <Jesin> or something.
15:18:55 * hackagebot monad-control 0.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.1 (BasVanDijk)
15:24:40 <Yvemath> What's the scope of haskell language in Göteborg,Sweden ? :S Would i be able to get a work permit based on it ?
15:32:56 <nosila_> hi again
15:33:04 <nosila_> having a problem
15:33:13 <nosila_> in Parque module
15:33:49 <nosila_> i have data Parque = Parque_Empty | Parque Int ..... (a lot of things)
15:33:52 <|dafis|> what kind of problem?
15:34:19 <nosila_> then i have GUI.ParqueUI module
15:35:05 <nosila_> that handles the GUI as the name suggest, it show's a menu that gets data from the input to create a new Parque
15:36:03 <nosila_> sorry, not a new Parque but another structure that uses Parque and other things
15:36:48 <nosila_> i'm trying to put Parque_Empty where i need it but the compilers says that it isnt in scope
15:37:08 <nosila_> the line where i do this is in a return, inside a 'do'
15:37:55 <nosila_> i'm importing everything i need 
15:38:01 <|dafis|> nosila: how did you export the Parque datatype?
15:38:18 <nosila_> i need to "export" it?
15:38:29 <nosila_> everywhere i need to use it i just import that module
15:39:05 <|dafis|> nosila: if you don't have an explicit export list, the entire top level of the module is exported, that should be fine then 
15:39:26 <|dafis|> nosila: so, how did you import module Parque?
15:39:27 <nosila> hum, let me check that ;)
15:40:43 <nosila> oh shit
15:40:53 <nosila> i think it was the "explicit export list"
15:41:09 <nosila> let me do that, brb ;89
15:41:38 <dafis> nosila: if you put Parque(..) in the export list, the type is exported with all constructors
15:42:49 <nosila> that's what was missing ;)
15:42:50 <nosila> but
15:43:13 <nosila> can i only export a specific constructor?
15:43:27 <mauke> I think so
15:43:33 <dafis> nosila: sure, Parque(Parque_Empty)
15:43:35 <mauke> things to try: Type(Constructor)
15:43:48 <dafis> exports the type and that one constructor
15:44:04 <nosila> that's legit
15:44:06 <nosila> thanks ;)
15:44:21 <nosila> yap, working
15:44:47 <nosila> damn, this "small" syntax things are killing me lol
15:45:03 <nosila> thanks mauke: and dafis:
15:53:45 <gwern> @wn pun
15:53:48 <lambdabot> *** "pun" wn "WordNet (r) 2.0"
15:53:49 <lambdabot> pun
15:53:49 <lambdabot>      n : a humorous play on words; "I do it for the pun of it"; "his
15:53:49 <lambdabot>          constant punning irritated her" [syn: {punning}, {wordplay},
15:53:49 <lambdabot>           {paronomasia}]
15:53:51 <lambdabot> [3 @more lines]
15:53:57 <gwern> lambdabot: @join #lesswrong
15:59:37 <eschew> hi all, what's the easiest way of resetting ghc + cabal to a fresh state? I foolishly upgraded a package my compiler uses, and managed to get completely wedged...
16:00:45 <Saizan> eschew: rm -fr ~/.ghc should do it
16:01:03 <Saizan> eschew: unless you've installed something with --global
16:01:26 <eschew> Saizan: ok, i'll try that. I tried removing ~/.cabal but that only made things worse :)
16:02:19 <Saizan> eschew: yeah, ~/.cabal only has the sources and the compiled libs, the metadata is in ~/.ghc
16:03:13 * hackagebot dbus-core 0.8.5.4 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.5.4 (JohnMillikin)
16:04:14 * hackagebot dbus-client 0.4.0.4 - Monadic and object-oriented interfaces to DBus  http://hackage.haskell.org/package/dbus-client-0.4.0.4 (JohnMillikin)
16:08:39 <dankna> Cocoa uses 596 distinct types.
16:08:44 <dankna> Just thought you'd want to know!
16:08:55 <copumpkin> dankna: how are you analyzing it?
16:09:06 <aristid> dankna: thank you for letting us know!
16:09:10 <dankna> haha
16:09:15 <starclou1ed> hello everybody
16:09:18 <dankna> copumpkin: I'm working on replacing hoc, the Haskell-ObjC bridge.
16:09:36 <dankna> copumpkin: I'm using Apple's BridgeSupport XML files for my data.
16:09:44 <copumpkin> dankna: oh cool, I've worked on aspects of that before, but mostly just brainstorming rather than writing any significant body of code :)
16:09:47 <dankna> yeah
16:09:52 <copumpkin> dankna: have you seen the stuff on the ghc wiki?
16:09:57 <dankna> no, where?
16:10:02 <copumpkin> TacticalGrace also has been quite interested in it
16:10:11 <dankna> haven't met TacticalGrace, but good.
16:10:14 <copumpkin> http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC
16:10:40 <dankna> the biggest problem I see coming up, which I'm not ready to handle quite yet, is how to enable garbage collection on both sides of the FFI line
16:11:01 <starclou1ed> anyone knows the main difference between haskel an agda?
16:11:04 <dankna> I am resigned to having no way to cope with cycles that cross the line,
16:11:06 <copumpkin> calling out to objc_msgSend in a generic way also seems tough
16:11:11 <eschew> Saizan: ugh, now I ran into the same problem I ran into on the virtual machine: http://hpaste.org/43648/compiling_hprotoc181_fails
16:11:11 <copumpkin> since the FFI doesn't support varargs
16:11:13 <ddarius> starclou1ed: Look at them at all.  It should be clear...
16:11:13 <dankna> nah, libffi can do that
16:11:29 <copumpkin> starclou1ed: dependent types, practical compilation
16:11:52 <dankna> I believe we're already linked against libffi, so all that should be necessary is to import its symbols and then invoke objc_msgSend through those instead of directly
16:12:04 <copumpkin> oh, fair enough
16:12:24 <dankna> yeah
16:12:39 <copumpkin> well I look forward to seeing what you come up with :)
16:12:49 <copumpkin> I really want to not have to use objective c
16:12:56 <dafis> eschew: have you tried adding Functor r to the context?
16:12:58 <dankna> no kidding :)
16:12:59 <dankna> thanks!
16:13:10 <eschew> dafis: not my code...
16:13:20 <dafis> owww
16:13:24 <eschew> dafis: it's http://hackage.haskell.org/package/hprotoc-1.8.1
16:13:31 <dankna> so far I've got it reading about 2/3 of the information in the BridgeSupport files
16:13:34 <dafis> which package?
16:13:38 <dankna> and not doing any generation yet
16:13:57 <dankna> the information I am reading already does include the linkage-type specifications, which I'm parsing out
16:14:15 <ddarius> copumpkin: There's an easy way to not have to use Objective-C...
16:14:44 <copumpkin> ddarius: I don't ever use it anyway, but considering I'm on a mac, it'd be nice to be able to interface with the native libraries here :P
16:15:47 <dafis> eschew: rats, it's an executable, no docs to look for a workaround :(
16:16:15 <eschew> dafis: hm? it builds from src i think?
16:17:28 <eschew> dafis: as far as i can tell the issue is related to upgrading cabal + base libraries; hprotoc used to build just fine.
16:18:38 <dafis> eschew: sure it builds from source, I just can't look at it on hackage
16:21:26 <eschew> dafis: oh. http://hpaste.org/43667/resolvehs  -- line 1107
16:24:31 <Saizan> eschew: change the fmap's in that function with liftM
16:25:06 * copumpkin wants throttleList :: Int -> [a] -> [a]
16:25:07 <eschew> Saizan: I don't see how to cabal-install a package after cabal unpacking it?
16:25:14 <copumpkin> that produces the input list slowly
16:25:20 <copumpkin> but otherwise acts like id after being applied to the int
16:25:31 <Saizan> eschew: run "cabal install" from the source tree
16:25:38 <dafis> eschew: change code, append a .1 to the version number and `cabal install' in the package dir
16:25:58 <Saizan> ah, yeah, remember to bump the version
16:26:37 <eschew> dafis: ah, adding  Functor r  to the context seems to have fixed it
16:26:42 <dafis> eschew: I don't think that code ever compiled, probably added a type signature and didn't double-check
16:26:50 <eschew> dafis, Saizan: I'll email the author
16:26:54 <copumpkin> jmcarthur: do you know rolf rolles?
16:26:57 <eschew> dafis, Saizan: thanks! :-)
16:27:10 <jmcarthur> copumpkin: yes?
16:27:14 <copumpkin> just curious
16:27:20 <copumpkin> saw he was at pikewerks at some point
16:27:24 <eschew> dafis: I last compiled it this past fall, it did build then
16:27:30 <eschew> dafis: i'm not sure what changed since then
16:27:31 <jmcarthur> you know him through reverse engineering stuff i assume
16:27:40 <copumpkin> yeah, but only barely
16:27:45 <jmcarthur> he's also an ocaml guy
16:27:51 <copumpkin> yep
16:27:54 <dafis> eschew: I suspect the old code had no type signature
16:27:57 <copumpkin> seems pretty cool
16:28:14 <jmcarthur> i never actually met him. i was hired and took over his project after he left
16:28:27 <copumpkin> oh I see
16:28:42 <jmcarthur> i've spoken to him a few times online and stuff though
16:28:52 <jmcarthur> randomly bumped into him on reddit, actually ^_^
16:28:55 <Saizan> dafis: i think in the past there was a Monad f => Functor (StateT s f) instance, while now it's Functor f => Functor (StateT s f)
16:29:07 <copumpkin> yeah, he submits most of the links to /r/ReverseEngineering
16:29:16 <jmcarthur> yup
16:29:23 * ddarius thinks he'll learn the bass line to Wrong Way.
16:32:28 <Jesin> why are all the liftM written in do notation
16:32:35 <Jesin> I think it would be clearer the other way
16:32:52 <Jesin> at least for liftM, maybe not for liftM2
16:32:58 * ddarius hugs (co)ends and indexed (co)limits.
16:33:11 <Jesin> but, eh
16:33:17 <Jesin> one thing at a time, let's get join in Monad first
16:33:18 <Jesin> :p
16:33:39 <dafis> Saizan: that would explain it indeed
16:34:47 <Jesin> liftM f m = m >>= return . f
16:36:32 <tswett> > mod (-1) 2
16:36:33 <lambdabot>   1
16:38:03 <aristid> > rem (-1) 2
16:38:04 <lambdabot>   -1
16:38:07 <aristid> yay.
16:38:52 <dafis> > quot (-1) 2
16:38:53 <lambdabot>   0
16:39:03 <dafis> > div (-1) 2
16:39:04 <lambdabot>   -1
16:39:36 <dibblego> why is hugs included in the haskell platform?
16:39:46 <dafis> is it?
16:40:12 <dibblego> I have had a report from a mac user that it was
16:40:26 <dibblego> let me clarify...
16:40:59 <rando> I'm working my way through the Project Euler problems using Haskell, and I'm able to piece together code in ghci that gets me the answer. However, I'd like to learn more about structuring programs in Haskell, and so would like each problem to be a self-contained file, so that I can just do `runhaskell problem1.hs`. I'm having trouble finding documentation on how to structure the code in the file to make that work, though. Here's m
16:40:59 <rando> y first attempt, which doesn't work, but shows what I'm trying to accomplish: https://gist.github.com/812948
16:41:39 <glguy> rando: just unindent sumOfMultiples
16:41:47 <dafis> dibblego: at least, it's not listed on the contents page
16:42:03 <dibblego> dafis: clarified, his report was faulty, thanks
16:42:05 <rando> glguy: wow, ok, that was easy :)
16:42:31 <rando> where do I go to rtfm to find out why that worked?
16:42:57 <ddarius> @where report
16:42:58 <lambdabot> http://www.haskell.org/onlinereport/
16:43:11 <dafis> @where rwh
16:43:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:45:55 * ddarius assumes user error even before user's report an error.
16:47:15 <ddarius> -'
16:52:42 <aristid> ddarius: you even made your own user error there
16:53:31 <ddarius> aristid: I'm a user too.
16:53:39 <nosila> Hey again
16:54:10 <nosila> What's the best way to do "type" checking in haskell? ex: the user can only input a int
16:56:24 <dafis> nosila: the simplest way is to `case reads input of { [(value,"")] -> okay; _ -> curse user; }'
16:57:09 <nosila> wow, could you put some code @ pastebin please?
16:59:11 <tg_> dafis: really?
16:59:12 <nosila> i need values to be >0 also =/
16:59:54 <dafis> tg_: I can't think of a simpler way off the top of my head
17:00:06 * ddarius just uses a type system that type checks the users so that only well-typed users can use the program.  Remember: Well-typed users can't go wrong.
17:00:14 <dmwit> case reads input of { [(value,"")] | value > 0 -> okay; _ -> curse user; }
17:00:22 <pedro_saints> Question: " Module `Happstack.Server' does not export `defaultBodyPolicy' " means defaultBodyPolicy is not in Happstack.Server?
17:00:39 <aristid> ddarius: well-typed users are impossible as they would violate your first axiom
17:01:30 <pedro_saints> @vixen Do you like to violate axioms?
17:01:31 <lambdabot> yeah, i like
17:01:31 <dmwit> nosila: Like that?
17:01:46 <pedro_saints> @vixen ...
17:01:46 <lambdabot> stop being racist!
17:02:38 <pedro_saints> @vixen It's not racist if violate all axioms
17:02:38 <lambdabot> i dislike racist things
17:02:56 <dafis> nosila: http://hpaste.org/43668/simple_input_check simple. stupid,but should clear up the idea
17:03:18 <nosila> gonna check it ;)
17:03:22 <pedro_saints> @vixen okay you made ur point
17:03:22 <lambdabot> ok
17:04:03 <ddarius> dafis: I hope a paypal link is included in that paste.
17:04:17 <gwern> I'm racist against stupid people
17:04:27 <dafis> ddarius: oops, forgot that
17:04:28 <nosila> dafis: why you use the $ @ putStr??
17:04:42 <nosila> dafis: couldnt you just do it without the ($)??
17:04:52 <pedro_saints> do "stupid people" have their own race?
17:04:58 <dafis> nosila: because I use (++), I could also have used parentheses
17:05:07 <nosila> hum kk
17:05:16 <nosila> dafis: anw, what is 'value' ??
17:06:16 <dafis> nosila: the value read from the input, out of habit, I wrote val in the return, but it should be value
17:06:19 <dmwit> [(value, "")] is a pattern; it either binds the variable "value" to the integer in a one-element list or fails as a pattern, passing on to the next pattern.
17:06:45 <dmwit> > let [(value, "")] = [(1, "")] in value
17:06:46 <lambdabot>   1
17:06:52 <dmwit> > let [(value, "")] = [(1, "this fails")] in value
17:06:53 <lambdabot>   *Exception: <interactive>:3:4-38: Irrefutable pattern failed for pattern [(...
17:06:55 <ddarius> One day I'm going to log on under a different nick and pose as a "beginner" and God help you all then.
17:07:02 <dmwit> > let [(value, "")] = [(1, ""), (2, "")] in value
17:07:03 <lambdabot>   *Exception: <interactive>:3:4-37: Irrefutable pattern failed for pattern [(...
17:08:24 <dafis> > case [(1,""),(2,"")] of { [(value,"")] -> "Yay"; _ -> "Och"; }
17:08:25 <lambdabot>   "Och"
17:09:13 <dafis> pedro_saints: yes, homo sapiens
17:09:29 <dmwit> > let britishize (colo:r) = colo:'u':r in britishize "Och"
17:09:30 <lambdabot>   "Ouch"
17:09:58 <ddarius> dmwit: Shouldn't that be "britishise" ?
17:10:04 <pedro_saints> dafis: that's cold
17:11:29 <ddarius> > let americanize (c:o:l:o:u:r) = c:o:l:o:r in (americanize "colour", americanize "valour")
17:11:30 <lambdabot>   Conflicting definitions for `o'
17:11:30 <lambdabot>  Bound at: <interactive>:1:19
17:11:30 <lambdabot>            <i...
17:11:35 <ddarius> Ah yes.
17:11:58 <dmwit> valour works as a pattern
17:12:29 <ddarius> > let americanize (c:o:l:ο:u:r) = c:o:l:o:r in (americanize "colour", americanize "valour")
17:12:30 <lambdabot>   ("color","valar")
17:12:38 <ddarius> Curses!
17:12:43 <gwern> ah, the Valar
17:12:46 <aristid> what does it work now?
17:12:50 <ddarius> > let americanize (c:o:l:ο:u:r) = c:o:l:ο:r in (americanize "colour", americanize "valour")
17:12:51 <lambdabot>   ("color","valor")
17:12:54 <dmwit> > let americanize (v:a:l:o:u:r) = v:a:l:o:r in map americanize ["colour", "valour", "humour"]
17:12:55 <lambdabot>   ["color","valor","humor"]
17:13:20 <dmwit> aristid: Unicode letter that looks kind of like an 'o', probably.
17:13:28 <aristid> dmwit: evil
17:13:30 <monochrom> > let americanize (v:a:l:o:u:r) = v:a:l:o:r in map americanize ["america", "haskell", "coca cola"]
17:13:30 <lambdabot>   ["amerca","haskll","cocacola"]
17:13:41 <ddarius> dmwit: You have very discerning eyes for it to look "kind of" like an o.
17:13:49 <dmwit> Well, "amerca" was pretty much right, anyway. =P
17:14:19 <gwern> > let americanize = drop 1 . take 3 in map americanize ["america", "haskell"]
17:14:21 <lambdabot>   ["me","as"]
17:14:46 * gwern feels too bored to fix it
17:15:02 * dmwit feels not bored enough to fix it
17:15:37 * hackagebot language-go 0.8 - A library for analysis and synthesis of Go code.  http://hackage.haskell.org/package/language-go-0.8 (AndrewRobbins)
17:15:39 <dmwit> ddarius: Or a very discerning font, of course.
17:16:33 <dmwit> My font just displays the Unicode codepoint as the glyph. Reading text takes a bit of work, but it's so worth it for times like these.
17:18:37 <nosila> dafis: but, [(value,"")] that defines a pattern?????
17:18:59 <nosila> let americanize = drop 1 . take 3 in map americanize ["america", "haskell"]
17:19:13 <nosila> ups sorry
17:19:33 * ddarius doesn't think anyone sits around putting the English alphabet on pottery.
17:20:18 <dmwit> nosila: Could you phrase your answer in the form of a question, please?
17:20:29 <dafis> nosila: [(value,"")] is a pattern which is matched by one-element lists containing a pair whose second component is an empty String and with arbitrary first component
17:21:08 <nosila> dafis: didnt really get the [(value, "")] part, let me recheck it 
17:21:36 <Saizan> "could you phrase your answer in the form of a question" made me laugh
17:21:55 <dafis> Saizan: Jeopardy, I think
17:23:50 <nosila> but
17:24:16 <nosila> what's the need of the empty string??
17:24:53 <nosila> dafis: another thing, line 4. case reads input of, you dont have to put ::Int there??
17:25:16 <dafis> nosila: to verify that the entire input has been parsed
17:25:45 <dafis> nosila: the type signature forces value to have type Int (if it exists)
17:26:13 <aristid> > reads "4a" :: [(Int,String)]
17:26:14 <lambdabot>   [(4,"a")]
17:26:29 <aristid> this "a" is unwanted
17:27:07 <nosila> reads "4a34" :: [(Int,String)]
17:27:12 <nosila> what if i do that?
17:27:58 <nosila> f*** this, can someone point me for some more code of it? maybe i'll understand it better if i see that in another situation
17:28:24 <dafis> nosila: put a '>' before your expression to let lambdabot evaluate it
17:28:33 <parcs> > reads "4a34" :: [(Int,String)]
17:28:34 <lambdabot>   [(4,"a34")]
17:29:21 <nosila> > reads "4a34" :: [(Int,Char, Int, String)]
17:29:22 <lambdabot>   Couldn't match expected type `(GHC.Types.Int,
17:29:22 <lambdabot>                              ...
17:29:31 <nosila> > reads "4a3sdsd" :: [(Int,Char, Int, String)]
17:29:32 <lambdabot>   Couldn't match expected type `(GHC.Types.Int,
17:29:32 <lambdabot>                              ...
17:29:43 <parcs> :t reads
17:29:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:29:55 <parcs> you can only change the a there
17:30:23 <parcs> you can run reads consecutively:
17:30:42 <nosila> that wasnt here http://zvon.org/other/haskell/Outputprelude/read_f.html
17:30:42 <nosila> <_<
17:31:27 <nosila> so, read will take the 1st element of the input and after that you test it against the pattern, is that right?
17:31:41 <dafis> nosila: Related: lex, *reads*, show, shows
17:32:45 <nosila> :t lex
17:32:45 <lambdabot> String -> [(String, String)]
17:32:51 <dafis> nosila: read checks if reads returned a one-element result list and the second component of the pair (the remaining input) is all whitespace
17:32:51 <nosila> :t reads
17:32:52 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:33:04 <dafis> > read "12    " :: Int
17:33:05 <lambdabot>   12
17:33:25 <dafis> > reads "12   " :: [(int,String)]
17:33:26 <lambdabot>   Could not deduce (GHC.Read.Read int) from the context ()
17:33:26 <lambdabot>    arising from a ...
17:33:34 <dafis> > reads "12   " :: [(Int,String)]
17:33:35 <lambdabot>   [(12,"   ")]
17:33:50 <nosila> oohhhhh
17:33:56 <nosila> okok now i get it, thanks
17:34:09 <nosila> that link i gave you was messing with my thoughts
17:35:41 <nosila> no, i was messing with my own thoughts lol forget about it, thanks to everyone ;)))
17:41:09 <ruinous-one> msg NickServ stumplabuntil011 jstump89@gmail.com
17:41:33 <Entroacceptor> mmmh
17:42:32 <dafis> that's quick
17:46:58 <sbahra> lol
18:08:35 <stroan> god, parsec is beautiful. don't know what I spent so much time with happy
18:08:39 <stroan> why*
18:13:18 <edwardk> happy is not happy making =)
18:13:21 <edwardk> otoh, it runs fast
18:13:31 <edwardk> but its so hellish to contort around
18:16:24 <edwardk> hrmm, interesting, the fact that i couldn't put the superclass equality constraint on a typeclass may have steered me to a better design.
18:17:15 <edwardk> tries where all i need to do is establish an isomorphism for the key, this makes it cheaper to provide things like instances for newtypes, etc.
18:18:25 <mm_freak> @djinn (a -> a) -> a
18:18:25 <lambdabot> -- f cannot be realized.
18:18:42 <HRuivo> hi all
18:19:09 <edwardk> mm_freak: fix is 'assuming the hypothesis'. djinn would never do anything so droll. ;)
18:19:43 <mm_freak> hehe ok
18:20:52 <pedro_saints> Is it true that cats say leksah instead of lexer?
18:22:14 <Bynbo7> only lolcats
18:22:53 <edwardk> yes, LC_ALL="en@lolcat" should perform that transliteration for you, for any compatible program ;)
18:23:39 <shepheb> anyone know the syntax for $forall in Hamlet 7?
18:24:47 <shepheb> ah, nm, ran a test file through the hamlet6to7 conversion utility
18:25:29 <edwardk> the only forall I can think of in hamlet was something like "He was a man, take him forall in all, I shall not look upon his like again." ;)
18:25:31 <Jesin> @djinn (a -> Bool) -> a
18:25:31 <lambdabot> -- f cannot be realized.
18:25:39 <Jesin> @djinn ([Bool] -> Bool) -> [Bool]
18:25:39 <lambdabot> Error: Undefined type []
18:25:44 <edwardk> i didn't realize they'd done so many sequels though
18:26:56 <Jesin> XD
18:27:36 <edwardk> er, what is hamlet 7 anyways?
18:28:04 <shepheb> the templating system for Yesod, the web framework
18:28:08 <edwardk> ah
18:29:15 <pedro_saints> oh okay
18:31:33 <nosila> hey again
18:31:54 <nosila> return x where x=1
18:31:56 <nosila> posible'
18:32:00 <nosila> possible?*
18:32:44 <Cale> let x = 1 in return x
18:32:49 <Cale> is a valid expression
18:32:49 <edwardk> > let { foo = return x where x =1 } in foo :: [Int]
18:32:50 <lambdabot>   [1]
18:33:22 <medfly> you
18:33:40 <Cale> 'where' is part of the syntax of declarations. You can certainly define x inside of an attached where clause, and then apply return to it in the definition of something.
18:33:41 <edwardk> where is applied to certain parts of a statement, it isn't usable directly just anywhere in an expression though, as cale noted. you attach where clauses to 
18:34:02 <Cale> actually, it's also part of the syntax of case expressions, but let's ignore that ;)
18:34:08 <edwardk> n, as usual cale beat me to it =)
18:36:53 <ddarius> > x where x = 3
18:36:54 <lambdabot>   <no location info>: parse error on input `where'
18:37:29 <nosila> hum thanks
18:37:38 <nosila> another thing
18:39:02 <Wooga> @hoogle enumPureNChunk
18:39:02 <lambdabot> No results found
18:39:14 <shachaf> > case 1 of 1 -> x where x = 1
18:39:15 <lambdabot>   1
18:39:24 <Wooga> how this can be? it was in Data.Iteratee.Base yesterday!
18:39:44 <Bynbo7> hoogle doesn't search hackage packages
18:40:04 <Wooga> ah
18:41:04 <Wooga> ah, i am liar
18:41:10 <Wooga> it in ListLike
18:43:51 <Gracenotes> hm. what's a good, terse expression that takes a long time to get into WHNF?
18:44:06 <Gracenotes> say, a few seconds
18:45:51 <Bynbo7> 2^1235688394 `seq` Just undefined? :P
18:48:42 <Gracenotes> more seconds and less decades -.-
18:49:09 <edwardk> start removing digits ;)
18:50:54 <Bynbo7> > 2^1235688394 `seq` Just undefined
18:50:56 <Gracenotes> how about, say, one-liner implementation of busy beaver FSM? -.-
18:51:09 <lambdabot>   thread killed
18:51:13 <Bynbo7> > 2^12356883 `seq` Just undefined
18:51:16 <lambdabot>   Just *Exception: Prelude.undefined
18:51:38 <centrinia> > 2^( 2^12356883) `par` Just undefined
18:51:39 <lambdabot>   Just *Exception: Prelude.undefined
18:52:56 <drbean> > let x = x where x = 3
18:52:57 <lambdabot>   not an expression: `let x = x where x = 3'
18:53:22 <centrinia> > let x = x in x -- x_x
18:53:25 <lambdabot>   mueval-core: Time limit exceeded
18:54:32 <drbean> It works here.
18:55:05 <Gracenotes> ghci treats it as an assignment
18:55:25 <Gracenotes> er, well, a binding. it's not an expression :/
18:56:10 <centrinia> @let x = x where x=3
18:56:10 <HRuivo> hi, I'm having this error Non-exhaustive patterns in function paGetIdByName and can't find a fix to it
18:56:12 <lambdabot>  Defined.
18:56:26 <centrinia> > x
18:56:26 <lambdabot>   Ambiguous occurrence `x'
18:56:26 <lambdabot>  It could refer to either `L.x', defined at <local...
18:56:27 <HRuivo> what I'm missing?
18:56:46 <dmwit> HRuivo: You're missing just about all the details we need to help you.
18:56:58 <parcs> > L.x
18:57:02 <lambdabot>   mueval-core: Time limit exceeded
18:57:20 <HRuivo> http://pastebin.com/v0bkd51J the code
18:57:21 <dmwit> ?hpaste
18:57:21 <lambdabot> Haskell pastebin: http://hpaste.org/
18:57:21 <Gracenotes> > let x = let x = 3 in x in x
18:57:21 <lambdabot>   3
18:57:30 <Gracenotes> > let x = x where x = 3 in x
18:57:30 <centrinia> HRuivo, just define paGetIdByName _ = undefined -- or something to that effect.
18:57:31 <lambdabot>   3
18:57:56 <Jesin> @undefine
18:58:01 <Jesin> > x
18:58:02 <lambdabot>   x
18:58:04 <centrinia> HRuivo, what is paGetByName 0 [] ?
18:58:08 <dmwit> HRuivo: How about empty lists, or lists that start with constructors other than PontoAcesso_Empty or PAcesso?
18:58:31 <jsvc> Is there an extension that allows importing remote modules? Say I have a module definition at example.com/mymodule and I want to have GHC automatically download it when I ask it to compile a program that imports it
18:58:45 <HRuivo> sorry I forgot data PontoAcesso = PontoAcesso_Empty | PAcesso ID Nome Descricao Parque VeiculoPerms UtentePerms
18:59:10 <HRuivo> paGetByName should return a PontoAcesso by its name
18:59:47 <Gracenotes> jsvc: when you have dynamically loaded modules, accessing them via network is a short step away
18:59:51 <drbean> > let x = let x = 7 in x in x
18:59:52 <lambdabot>   7
19:00:05 <Gracenotes> (also a short step away from lots of security exploits, but anyway)
19:00:24 <Gracenotes> ...whether ghc has dynamically loaded modules is not certain. there are some experimental implementations.
19:02:01 <jsvc> Gracenotes: so is there a standard way of doing this?
19:02:04 <Jesin> :t let cfind p = x : cfind (p . (x :)) where x = p $ True : cfind (p . (True :)) in cfind
19:02:05 <lambdabot> ([Bool] -> Bool) -> [Bool]
19:02:20 <Jesin> @let cfind p = x : cfind (p . (x :)) where x = p $ True : cfind (p . (True :))
19:02:21 <lambdabot>  Defined.
19:02:55 <polypus> haskell noob, but a bit surprised by this; if i write
19:02:56 <Jesin> @let csearch p = if p xs then Just xs else Nothing where xs = cfind p
19:02:56 <lambdabot>  Defined.
19:03:00 <polypus> f x y = sum [1..x] + y
19:03:06 <polypus> let g = f 1111111
19:03:13 <polypus> i now get the expected delay on the first call to g as the cpu churns.
19:03:14 <polypus> but if i call it again, why does it delay again? i'd think teh compiler
19:03:14 <polypus> would be smart enough to not re-evaluate the sum?
19:03:32 <Jesin> umm
19:03:35 <Gracenotes> jsvc: there *was* hsplugins.. and LazyManateeCat is working on some things, he's not here now
19:03:50 <Gracenotes> by "now" I mean not in the channel at the moment afaik
19:04:40 <polypus> after let g = f 111111, i call g once (g 1), and then get the delay. what i'm surprised about is the delay on further calls
19:04:40 <jsvc> Gracenotes: thanks, are there plans to make this relatively standard?
19:05:14 <pedro_saints> @hoogle cuteFun
19:05:15 <lambdabot> No results found
19:06:09 <Jesin> @help seen
19:06:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:06:16 <Jesin> @seen Cale
19:06:16 <preflex>  Cale was last seen on #haskell 33 minutes and 28 seconds ago, saying: is a valid expression
19:06:17 <lambdabot> Unknown command, try @list
19:06:33 <Cale> meow
19:07:19 <Gracenotes> jsvc: not certain. I suppose if you don't very actively maintain it it stops working, due to having to be closely in cahoots with compiler
19:07:31 <djahandarie> polypus, you mean you want it to store the previous result of a function call?
19:07:58 <Cale> jsvc: Check out hint
19:08:09 <polypus> it's not what i want per say (memoization) i'm just surprised by the behavior
19:08:31 <Cale> hint is a bit more modern than hs-plugins I think... though it's possible that someone has done some work on hs-plugins recently that I don't know about
19:08:38 <dankna> direct-plugins
19:08:40 <dankna> mine
19:08:54 <djahandarie> polypus, if you don't mean memoization, you probably mean common sub-expression elimination?
19:08:56 <dankna> not perfect, but it has the advantage that I know how it works and can answer questions about it
19:09:12 <djahandarie> i.e., f 1 + f 1 should turn into let x = f 1 in x + x
19:09:13 <Gracenotes> I just know of hs-plugins
19:09:14 <jsvc> Gracenotes: will do, thanks a lot :)
19:09:28 <Cale> http://hackage.haskell.org/package/hint
19:09:35 <dankna> @hackage direct-plugins
19:09:35 <lambdabot> http://hackage.haskell.org/package/direct-plugins
19:09:46 <Gracenotes> Cale: ah. I've heard people talking about hint not being ghc7-friendly
19:09:54 <Cale> hint is a little more full-featured than direct-plugins seems to be, but maybe if you want something really simple :)
19:10:00 <Cale> Ah, that would be unfortunate.
19:10:07 <Gracenotes> I wonder how much work needs to be done
19:10:08 <dankna> ah, yeah, direct-plugins was aiming for, well, simple
19:10:56 <Gracenotes> jsvc: ah, so try these out :) .. not sure how to convince the compiler that the symbols you need will be resolved at runtime, but I'm sure other people do
19:11:24 <djahandarie> polypus, I'm kind of guessing here though. Put some specific code on http://hpaste.org and say exactly what you are/were expecting and perhaps I'll be able to have a better response
19:11:59 <djahandarie> But if you are expecting common sub-expression elimination, GHC does a little, but doing it for everything can lead to memory usage exploding
19:12:16 <djahandarie> It only does it for 'very simple' stuff. I don't know the exact criteria/algorithm.
19:12:26 <djahandarie> And it only does it for that stuff on -O2
19:13:07 <polypus> djahandarie: i posted all the relevent code. if i partially apply f and the compiler can infer that some of the work can be thunked and only calculated once, i'm wondering why it doesn't do so
19:14:20 <jsvc> So if I follow correctly, there isn't anything that works with GHC7 atm
19:14:38 <nosila> hey, why i'm getting an error here
19:14:38 <nosila> http://hpaste.org/43670/gettipo
19:14:39 <dankna> jsvc: I haven't tried direct-plugins with GHC7 but I wouldn't be surprised if it's broken.  I can't speak to the others.
19:14:43 <djahandarie> polypus, ah, I see now
19:14:44 <nosila> GUI\UtenteUI.hs:73:8: parse error on input `case'
19:14:51 <dankna> I suspect their authors would tell you the same though.
19:15:01 <Cale> jsvc: GHC7 will break a lot of the APIs that these plugin architectures rely on, so it might be a bit of work to get them to build
19:15:34 <Gracenotes> polypus: it seems that compiled on -O2, it does exhibit that behavior
19:15:42 <djahandarie> polypus, I imagine that is just not a simple thing to detect. Because your f could be written such a way that you can't evaluate it at all without all the variables present.
19:15:43 <Cale> nosila: becuase you missed a semicolon
19:15:57 <Cale> nosila: It would be better just to lay things out correctly :P
19:16:03 <nosila> *headbangs the wall in front of him*
19:16:18 <polypus> Gracenotes: interesting. i tried it with -O2 and i didn't get the optimization
19:16:22 <nosila> Cale: lay things out correctly? How come?
19:16:56 <Gracenotes> f x y = sum [1..x] + y; g = f 111111111; main = do print (g 1); print (g 1). compiled with ghc --make -O2 thing.hs
19:17:12 <djahandarie> Gracenotes, he means g 1 and g 200
19:17:15 <Cale> nosila: http://hpaste.org/control
19:17:24 <Cale> errrr
19:17:32 <ddarius> Oh no.
19:17:36 <Cale> http://hpaste.org/paste/43670/gettipo_annotation#p43671
19:17:50 <Gracenotes> hm. I'll try again. I don't think GHC would CSE in that case.. it doesn't tend to do that
19:18:09 <djahandarie> Gracenotes, yours is trivially optimized with CSE, but the other one would require a lot of insight about the functions that I'm pretty sure GHC doesn't have
19:18:18 <Gracenotes> nope, works just fine
19:18:46 <nosila> then
19:18:51 <Gracenotes> 15 seconds, then prints 6172839549382717 6172839549382916
19:18:51 <nosila> why the use of ; ???
19:19:04 <nosila> i just put that because i saw it in another code lol
19:19:51 <Gracenotes> GHC can partially apply a closure by sort of converting an argument into an environmental variable
19:20:11 <danharaj_> is calculating 'takeWhile' and 'dropWhile' in two different but related expressions less efficient than using a where clause and 'span' to have them computed in one go?
19:20:33 <polypus> i'll try again with -O2, maybe i screwed up first time
19:20:56 <Gracenotes> danharaj_: span is good if you want both
19:22:54 <djahandarie> Oh god damn it. I restarted my internet and hackage is now lagging like all hell for me again.
19:23:07 * djahandarie has no idea why this only happens with Hackage
19:23:24 <nosila> Cale: why the ; and { are usefull?
19:23:42 <Gracenotes> @check \xs -> let f = (>2) . length in span f xs == (takeWhile f xs, dropWhile (not . f) xs)
19:23:43 <lambdabot>   "Falsifiable, after 1 tests:\n[[()]]\n"
19:24:02 <Cale> nosila: They're useful if you're blind or if you're generating code using other code
19:24:15 <Cale> nosila: They're also useful if you have to cram a bunch of code into one line
19:24:22 <djahandarie> danharaj_, they should fuse if you are using Data.List.Stream
19:24:29 <djahandarie> Not with just Data.List though, I don't think
19:24:37 <Gracenotes> er, the not is silly, nvm
19:24:41 <Cale> nosila: Formally, the layout syntax is defined in terms of the curly braces and semicolons syntax
19:25:05 <nosila> hum ok then
19:25:10 <nosila> Thanks Cale: 
19:25:11 <nosila> ;)
19:26:31 <djahandarie> danharaj_, yeah, Data.List is just explicit recursion for takeWhile and dropWhile with no rewrite rules so there is no way they'd be fused, and span would do better.
19:26:44 <ddarius> Blind people code *shudder*
19:27:55 <nosila>     ; let utente = (Utente no bi tp pr mo [])         in return (addElement arvore utente)
19:27:59 <nosila> isnt this ok???
19:28:07 <Gracenotes> blind people code in *insert your (un)favorite allegedly unaesthetic language here*
19:28:09 <jsvc> Are there any good resources explaining how to write GHC extensions?
19:28:11 <nosila> getting addElement not in scope =X
19:28:41 <Gracenotes> scopemonster ate it
19:29:37 <nosila> LOL
19:36:08 <Cale> nosila: addElement isn't a standard library function. I don't know if it's supposed to be in scope or not.
19:36:26 <nosila> was missing a import
19:37:16 <nosila> http://hpaste.org/43673/getint
19:37:37 <nosila> why is the return IO Int? (and not just Int) ??
19:37:57 <augur> byorgey!
19:38:51 <Cale> nosila: Because you're not producing an Int, you're producing a description of some I/O to take place which when it runs will produce an Int
19:39:17 <augur> byorgey: you're wrong to say that forall a. a -> a has exactly one inhabitant
19:39:25 <augur> in the type domain you gave, it has infinitely many inhabitants
19:39:37 <augur> as do all the other types
19:39:45 <Cale> After all, if getInt :: Int, then it must be some specific Int value, so whichever one it was, it would have to always be that same value.
19:40:23 <Cale> So if you put getInt into ghci, for example, and it came back with 5, then it would have to always be 5, because that's how definitions work :)
19:41:51 <nosila> Cale: but that's just because i dont have arguments or that's because i get the input from the user??
19:42:01 <Cale> a bit of both
19:42:06 <nosila> lol
19:42:25 <nosila> bcuz im having another error
19:42:28 <Cale> Functions with parameters are allowed to produce different values depending on the values of the arguments
19:43:03 <nosila> in a function like that but that gets a Int from the user, convert the int to a data that i have, and return the data
19:43:04 <Cale> IO actions are allowed to return different values when run depending on input from the user.
19:43:11 <nosila> gonna post the code up
19:44:20 <Cale> Break the problem into an IO action of type IO Int, and a function Int -> MyData, and then combine the two with fmap or liftM
19:44:27 <Cale> (which are equivalent)
19:44:35 <nosila> http://hpaste.org/paste/43670/gettipo_annotation#p43675
19:44:49 <nosila> :t fmap
19:44:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:45:20 <Cale> Though I suppose in this case, the fact that you're already producing a menu for a Tipo means that you might as well apply the function to the Int which is read
19:45:40 <Cale> getTipo :: IO Tipo
19:45:47 <nosila> i've already changed that
19:46:09 <deech> Has anyone here worked with Standard ML? Besides strictness, does it have any advantage over Haskell?
19:46:29 <Cale> deech: If you call strictness an advantage at all... that's more just a difference :)
19:46:37 <Bynbo7> i wouldn't call that an advantage
19:46:39 <Cale> SML has a nice module system
19:46:52 <deech> Cale: Yeah I didn't mean to phrase it that way. 
19:47:47 <deech> And I don't think its pure either, correct?
19:47:54 <Cale> nosila: The type signature for fmap might be a bit confusing, but we can substitute f = IO into it to get (a -> b) -> IO a -> IO b
19:48:06 <Cale> deech: right
19:48:33 <djahandarie> And adding the extra parens might help too:  (a -> b) -> (IO a -> IO b)
19:48:50 <nosila> now i'm lost lol
19:48:55 <Cale> depending on how you want to look at it :)
19:49:07 <nosila> the error changed
19:49:27 <Cale> nosila: But in your case, since you do a bunch of prompting, it's probably best just to do what you're already doing
19:49:32 <Cale> nosila: What's the remaining error?
19:50:23 <nosila> nevermind, it's working ;)
19:50:28 <nosila> THANKS =D
19:50:47 <nosila> (now i have other errors in other modules lol gonna solve them)
19:54:30 <Bynbo7> win 20
19:58:29 <byorgey> augur: but I specified that I wanted to consider terms only up to behavioral equivalence
19:58:43 <augur> byorgey: what?
19:59:10 <augur> oh yes, i know. there are an infinite number of behaviorally distinct functions that inhabit the type forall a. a -> a
19:59:18 <byorgey> augur: there are?
19:59:19 <ddarius> byorgey: Now you know to drown your readership in endless technical minutae.
19:59:23 <augur> byorgey: ofcourse there are
19:59:35 <byorgey> ddarius: ?
19:59:47 <byorgey> augur: like what?
20:00:05 <augur> byorgey: f :: forall a. a -> a <=> f = { (x,y) : x, y :: a }
20:00:17 <augur> obviously there are an infinite number of such functions
20:00:30 <augur> for instance
20:00:41 <ddarius> That equivalence doesn't hold.
20:00:49 <augur> f (n :: Int) = 0; f x = x
20:00:53 <augur> id except for integers
20:00:54 <ddarius> In fact, the right side doesn't make any sense.
20:01:01 <augur> ddarius: ofcourse it does
20:01:11 <byorgey> augur: that function does not have type forall a. a -> a
20:01:16 <augur> byorgey: yes it does
20:01:19 <byorgey> it has type Int -> Int
20:01:23 <augur> no it doesnt
20:01:36 <augur> in haskell it might
20:01:43 <augur> but the flaws of haskell's type system are irrelevant
20:01:48 <byorgey> oh, you want to be able to do dispatch on types
20:01:49 <dolio> There is no term in the typed lambda calculus that is 'identity except for on integers.'
20:02:00 <augur> byorgey: im not talking about dispatch or anything
20:02:03 <augur> im talking about the function
20:02:16 <ddarius> augur: a is not bound on the right side.
20:02:16 <byorgey> this isn't about haskell, it's a feature of the polymorphic lambda calculus
20:02:18 <dolio> At least, not the one most people use.
20:02:26 <augur> { (x,y) : if (x :: Int) then y = 0 else y = x }
20:02:39 <augur> that has the same type as signature as id
20:02:50 <augur> since for all arguments, it returns a value of the same type as the argument
20:03:02 <augur> each pair in this extensional model is of the form (a,a)
20:03:09 <byorgey> augur: I see what you are saying, but in the polymorphic lambda calculus you cannot test for type like that
20:03:21 <augur> byorgey: thats not my problem, thats yours :)
20:03:28 <augur> you didnt specify it had to be testable
20:03:32 <augur> just that it had to inhabit the type
20:03:38 <augur> well that inhabits the type
20:03:48 <byorgey> I specified that we were talking about the polymorphic lambda calculus.
20:03:56 <ddarius> augur: a isn't anything
20:04:19 <augur> byorgey: mmm i suppose...
20:04:28 <augur> byorgey: you DID say a stripped down haskell type system
20:04:32 <augur> so i guess you're right
20:04:35 <augur> but only on a technicality!
20:04:52 <byorgey> of course it is a technicality.
20:04:55 <augur> :P
20:04:58 <dolio> In fact, families of functions like that are sort of *the* reason that the polymorphic lambda calculus doesn't have (non-trivial) set-theoretic models.
20:04:59 <byorgey> it was a very carefully chosen technicality.
20:05:12 <ddarius> augur: You're wrong with the "argument" you've given, though you could certainly envision systems where you would be right.
20:05:17 <augur> byorgey: cheater.
20:05:55 <augur> byorgey: can you demonstrate constructively how it comes out that id is the only inhabitant of forall a. a -> a?
20:06:02 <byorgey> augur: I don't mean it in that way.  I mean, I chose things the way I did because that's what leads to an interesting problem.
20:06:11 <augur> i know :p
20:06:13 <byorgey> in a system of the sort you describe, the problem I've stated is utterly trivial.
20:06:47 <augur> byorgey: forget the system i described, its irrelevant now
20:06:54 <byorgey> augur: intuitively, it has to work *uniformly* for all types
20:06:58 <ddarius> augur: It's parametricity.  Adding a typecase construct would indeed violate parametricity and lead to terms like you are trying to construct.
20:07:04 <byorgey> so the only thing it can do is return the argument it is given.
20:07:19 <augur> i want to see a constructive proof that id is the only inhabitant. i get it intuitively given your conditions, but i'd find the proof lovely
20:07:30 <ddarius> @free id
20:07:31 <lambdabot> f . id = id . f
20:07:43 <dolio> It's a consequence of parametricity.
20:07:52 <augur> dolio: show!
20:07:55 <byorgey> augur: if you want a formal proof, see Wadler's "Theorems for Free!"
20:08:07 <augur> wadler :|
20:08:09 <augur> this guy
20:08:16 <byorgey> a rigorous proof is surprisingly non-trivial.
20:08:19 <dolio> You can read Reynolds instead, if you want.
20:08:35 <ddarius> Or you could provide a categorical semantics and derive it from there.
20:09:26 <Bynbo7> @free map
20:09:27 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
20:09:41 <Bynbo7> @free (>>=)
20:09:41 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
20:11:59 <dolio> http://hpaste.org/43677/free_theorem_junk
20:12:28 <augur> byorgey: im not buying this
20:12:30 <dolio> There. I postulate the parametricity theorem, and prove the induction principle for (forall a. a -> a), with forall f. f = id along the way.
20:12:53 <augur> wadler says in the intro, "r is provided with no operations on values of type X"
20:12:55 <augur> but how do we know this
20:15:53 <augur> its quite fascinating if its true, but i'd love to see /why/ its true
20:16:55 <NemesisD> anyone ever used Distribution.Simple.Command for creating executables with subcommands? evidently cabal uses it. i also see a competitor UI.Command
20:18:42 <augur> dolio: further, is it true that there is some sort of deep relationship between the functions that co-inhabit types?
20:19:12 <dolio> I'm not sure what that means.
20:19:17 <augur> well, like
20:20:51 <augur> wadler says that for the function r :: forall a. [a] -> [a], we know that for all a, b, f :: a -> b, f.r = r.f
20:21:02 <augur> for a function r :: ~
20:21:24 <dolio> map f . r = r . map f, you mean.
20:21:35 <augur> yes that sorry :p
20:22:08 <augur> he uses weird notation and translating it into hasklish is ~
20:22:09 <augur> anyway
20:22:55 <augur> so he says, for instance, r = reverse, f = charCode, or maybe r = tail, f = inc
20:23:24 <augur> but does this suggest some deep connection then between reverse and tail, or charCode and inc?
20:23:57 <augur> or is it merely the connection of inhabiting the types in question
20:25:22 <dolio> It is a consequence of them inhabiting the same type, and the uniformity of products indexed by 'all types' in the polymorphic lambda calculus.
20:25:41 <augur> but is there nothing deeper than that?
20:25:53 <haskellnoob> Hi. I am trying to understand a piece of code that appears in the darcs source.
20:26:33 <haskellnoob> I am not able to figure out what a certain function does; I think I know what each small piece in the function does, but am struggling to figure out how these compose.
20:27:45 <ddarius> augur: The "deep" connection is their types.
20:27:49 <augur> ok
20:27:54 <haskellnoob> I have pasted to hpaste a minimal chunk of code which illustrates my doubt.
20:27:55 <ddarius> The theorems are free.  You get what you pay for.
20:28:10 <haskellnoob> (What is the incantation for conjuring up that paste here?)
20:28:22 <augur> ddarius: but that means theres no deep connection in the structure of the functions themselves then?
20:28:54 <ddarius> Also, we know there are no operations on values of type X because we've provided no operations.  As I mentioned earlier, you could readily provide primitive operations that would allow you to "introspect" on types and all these parametricity theorems would fail.
20:28:56 <augur> like, theres no deep sense in which reverse and tail "really are the same thing"
20:29:01 <haskellnoob> The code is at http://hpaste.org/43678/composed_function_doubt
20:29:07 <ddarius> augur: They clearly are not the same thing.
20:29:15 <augur> ddarius: well clearly
20:29:24 <haskellnoob> my doubt is: what does the function doReverse do?
20:29:30 <augur> hence why im asking about deeper, not so clear things :P
20:30:03 <ddarius> augur: They have the same types.  The "free theorems" are true of all things with the same types.
20:30:13 <augur> ddarius: ok nevermind then
20:30:19 <augur> talking to you has always been difficult :P
20:32:32 <haskellnoob> my problem is specifically at line 16, where lastWord is defined
20:32:50 <haskellnoob> I am not able to parse this correctly
20:33:00 <joe6> i have asked this question a few times hoping to get a better answer. I have around 2KLoc of ASM that I want to convert to some high level language. Atom seems promising but I could not make much sense of it from the manual. Has anyone used atom for asm? any experiences, please?
20:33:25 <aavogt> @unpl foldr . flip $ \ def -> fromMaybe def . flip lookup known_flags
20:33:25 <lambdabot> (foldr (\ b c -> fromMaybe c (lookup b known_flags)))
20:34:15 <aavogt> @type foldr
20:34:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:34:33 <haskellnoob> aavogt: thanks. Can I get this unpl thing on my machine? It seems quite useful
20:34:46 <aavogt> you can  cabal install lambdabot I think
20:34:51 <aavogt> or just PM the bot
20:34:54 <polypus> i'd like to completely uninstall all my cabal packages to start from scratch. how should i do that?
20:35:13 <haskellnoob> aavogt: I was specifically trying to figure out this result of unpl: now I can stare at this and understand it.
20:35:16 <haskellnoob> Thanks!
20:35:52 <haskellnoob> aavogt: but I cannot be online all the time, so an offline tool would be very useful for me. let me see how to install lambdabot
20:36:10 <haskellnoob> You guys are wonderful :)
20:36:11 <aavogt> @type find
20:36:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:39:34 * aavogt thinks that lastWord does unnecessary calculation
20:40:00 <aavogt> but laziness!
20:41:59 <thoughtpolice> joe6: atom generates C code for one thing, not assembly code. but you basically want a DSL that will allow you to generate said ASM code, yes?
20:42:22 <thoughtpolice> joe6: if so, you may like the LLVM library more. you can generate LLVM bitcode using it, and have LLVM compile it into assembly
20:42:30 <thoughtpolice> @hackage llvm
20:42:30 <lambdabot> http://hackage.haskell.org/package/llvm
20:43:07 <joe6> thoughtpolice: thanks for responding. thanks, let me check on llvm. The big issue is that the asm has been hard to maintain. It is too much code to do a simple task.
20:43:45 <joe6> My options at this point are to look at SDCC (a C compiler) and recode in C or any other better alternative.
20:45:29 <thoughtpolice> joe6: unless you have particularly unusual constraints (i.e. you are doing register allocation by hand,) I think LLVM would probably work just fine. the bitcode is a bit higher level than regular assembly, and llvm itself has multiple architecture backends - you could generate x86 code, or PPC code, for example (barring some things - if your bitcode program depends on e.g. system endianness, LLVM can't magic this away for you, it must be taken i
20:46:40 <thoughtpolice> joe6: the llvm library on hackage is also really a DSL for the LLVM library - you could probably stick another language on top of there, if the domain is a little more well defined, and then have a compiler take your DSL language -> LLVM bitcode (via the llvm library)
20:46:52 <thoughtpolice> or you can just directly use the llvm library. you have some options
20:47:10 <joe6> thoughtpolice: ok, will check up on LLVM. What was your experience with atom?
20:47:21 <joe6> Is it meant to be a DSL?
20:47:55 <thoughtpolice> yes, atom is a DSL. when you run your haskell program, it will basically spit out a piece of C code for you, that implements the program you wrote with atom
20:47:59 <Bynbo7> it's a DSL for creating C
20:48:48 <joe6> thoughtpolice: Is it worth it? "another layer of abstraction" to just coding in C?
20:49:15 <joe6> i read that article about moving from 22KLoc using atom.
20:49:17 <Bynbo7> you'd have to be the one to decide that
20:49:38 <joe6> but, other than that, I cannot seem to find much info on its' workings.
20:49:48 <ddarius> joe6: Are you confident in your abilities to produce arbitrarily complicated C code that has hard real-time guarantees?
20:49:55 <thoughtpolice> joe6: atom is designed for use cases, the creator uses it as his job (eaton?) for programming hydraulic vehicles, and the software must meet certain real-time guarantees
20:50:02 <thoughtpolice> er, 
20:50:07 <thoughtpolice> 'certain use cases'
20:50:33 <thoughtpolice> atom is designed to generate C code that meets those guarantees, only you get to write the program in a much higher level language, and atom does the hard part of turning it into C
20:50:50 <thoughtpolice> there are some examples here of using atom to program an arduino controller, for example: http://blog.sw17ch.com/wordpress/?cat=3
20:50:59 <ddarius> thoughtpolice: I don't think that part is actually very hard.
20:51:09 <joe6> oh, ok. i do not have much "hard real-time guarantees" situatuon. thanks will check the tutorial about arduino.
20:51:56 <thoughtpolice> ddarius: you're right, a bit of bad wording.
20:52:32 <joe6> my problem is that the code has too many lines and I would love to use something more high-level so that I do not have to keep scrolling around to understand/see what's going on.
20:52:55 <ddarius> joe6: So do so.
20:53:46 <haskellnoob> I was trying to install lambdabot using the instructions from here : http://www.haskell.org/haskellwiki/Lambdabot/Building
20:54:13 <haskellnoob> But all three darcs repos mentioned in the first step seem to have disappeared: darcs quits saying each of them is not a valid repository
20:54:56 <haskellnoob> Where can I get the darcs repos for haskell-src-exts , mubot , and  lambdabot ?
20:55:52 <joe6> ddarius: i am exploring the options available. C, LLVM, atom...
20:58:44 <gienah> is there an easier way to convert a Data.ByteString B to a Int (or to a String) than my crazy code: (read $ map unsafeCoerce $ B.unpack cid) :: Integer)
20:59:45 <joe6> thoughtpolice: thanks for your suggestions and help. LLVM seems very promising. It appears that there is actually a llvm project for a pic too.
21:01:55 <gienah> haskellnoob: at least some of the darcs repos on code.haskell.org are offline, I think will hopefully be restored from backup some time
21:02:28 <haskellnoob> gienah: So this is a temporary glitch? I thought the repos have moved to some other place.
21:03:08 <haskellnoob> gienah: Thank you.
21:03:14 <gienah> haskellnoob: I think its a temporary glitch
21:03:59 <Gracenotes> I thought the community servers went boom
21:04:30 <Gracenotes> hopefully to un-boom soon
21:05:01 <thoughtpolice> i think igloo's been taking time to put them back online since they were hacked, and a bit of it is there already I think
21:05:06 <thoughtpolice> lots of user pages etc are gone atm though
21:05:19 <gienah> Gracenotes: I'm not really sure.  The gentoo-haskell stuff on c.h.o is still offline, it has been moved to github in order to bring it back up
21:05:38 <Gracenotes> I missed the details, were these the new ones or the yale ones that were hacked?
21:07:30 <revenantphx> joe6: Isn't LLVM bytecode... you know, bytecode?
21:07:52 <revenantphx> Usually you'd use a compiler to generate llvm bytecode, then feed it through llvm to get asm. (it's a compiler backend)
21:08:11 <revenantphx> unless there's an LLVM assembly language
21:08:16 <kmc> there is
21:08:31 <kmc> there are three standard representations of LLVM code, one textual and two binary
21:08:39 <revenantphx> oh interesting.
21:08:45 <revenantphx> what's the difference between the binary ones?
21:08:48 <kmc> or you can call the library functions without generating LLVM code internally
21:08:55 <kmc> revenantphx, fast vs. compact, I think.  i may misremember
21:09:30 <Gracenotes> there's an llvm interpreter, right? there has to be
21:09:37 <Gracenotes> a bytecode interpreter
21:10:08 <revenantphx> Gracenotes: why?
21:10:14 <Gracenotes> so the selection might make a difference there
21:10:37 <revenantphx> LLVM is a low-level virtual machine. It's nothing like a JVM.
21:10:40 <kmc> there is, but there doesn't have to be
21:10:41 <Gracenotes> revenantphx: hm... why not. it sounds like something someone would have implemented at some point
21:11:14 <revenantphx> Arbitrary Language code -> compiler --> LLVM bytecode --> native assembly.
21:11:15 <Gracenotes> yeah, I know. but its SSA is simple enough to be executed on the fly, no
21:11:33 <revenantphx> The idea being the bytecode -> asm compiler can be implemented for multiple platforms, and the bytecode remains portable.
21:11:51 <thoughtpolice> there is an llvm interpreter
21:11:52 <revenantphx> Gracenotes: I'd think so.
21:11:54 <Maxdamantus> The way I see it, a VM is just an abstract platform, which is likely to be implemented in many ways.
21:11:56 <revenantphx> Then again, I haven't used it.
21:11:57 <thoughtpolice> it's called 'lli' i believe
21:12:02 <thoughtpolice> and included in the standard llvm distribution
21:12:05 <Maxdamantus> The compiler frontends compile for the llvm platform.
21:12:25 <revenantphx> i.e, clang.
21:12:30 <revenantphx> C -> LLVM -> ASM
21:12:38 <revenantphx> (or C++, ObjC, ObjC++ I belive)
21:12:39 <Gracenotes> it's similar to the gcc compiler suite, but.. a tad less C-obsessed
21:12:52 <Gracenotes> and gcc compiler suite has a redundant acronym, doesn't it
21:13:03 <revenantphx> All GNU things do.
21:13:10 <revenantphx> Anyways, I don't think it's like GCC at all tbh.
21:13:21 <thoughtpolice> in practice LLVM bitcode isn't portable unless you explicitly generate it in such a way to not care about things like endianness, for example. lots of things that use LLVM will in practice generate bitcode using things like constants defined for the target platform, making the resulting bitcode non-portable
21:13:35 <revenantphx> thoughtpolice: ah, mm
21:13:36 <revenantphx> k
21:14:00 <thoughtpolice> and LLVM by itself isn't anything like GCC, LLVM is a toolchain for building things like compilers, debuggers, things that inspect or analyze machine code, etc
21:14:30 <revenantphx> I'm thinking of writing something using LLVM next year.
21:14:39 <revenantphx> I need to wise up to this stuff sooner than later.
21:14:41 <thoughtpolice> GCC doesn't really expose much of its internals, e.g. GIMPLE to people just using gcc, so you can't just say, generate GIMPLE then feed it to gcc and you get a binary
21:15:00 <Gracenotes> thinking more about the way gcc likes to separates frontends and backends
21:15:05 <thoughtpolice> you actually need to integrate a compiler frontend into gcc to get to the point of generating gimple
21:15:15 <Gracenotes> if, say, you want to port a language to it for god-knows-why
21:15:15 <revenantphx> I see gcc as a backend.
21:15:22 <kmc> gcc has been aggressively hostile to being used this way, for political reasons
21:15:34 <revenantphx> kmc: which way?
21:15:43 <kmc> as a backend for code generated by other software
21:15:47 <thoughtpolice> being used as a platform for implementing compilers for example
21:15:59 <thoughtpolice> see: rms vs. guys who implemented a java frontend for gcc
21:16:14 <kmc> the java frontend is in standard gcc and has been for a while
21:16:17 <thoughtpolice> RMS does not want GCC for example to be usable by proprietary IDEs for things like code generation
21:16:27 <kmc> the first C++ and ObjC frontends were contributed by companies and it's believed that, had it been easy to plug in loosely coupled frontends, they wouldn't have contributed source
21:16:41 <Gracenotes> I don't know many java people who like gjc
21:16:44 <thoughtpolice> kmc: that debate is old, but it is an example of the reasoning RMS puts forth
21:16:48 <kmc> i don't know many people who like gjc
21:16:52 <Gracenotes> *gcj
21:16:52 <kmc> gcj?
21:16:53 <Maxdamantus> gcj*
21:16:53 <kmc> yeah
21:16:55 <kmc> hehe
21:17:02 <revenantphx> gcc is dead to me, for the last year i've exclusively used clang, and been perfectly fine.
21:17:10 <kmc> revenantphx, have you compiled Linux with clang?
21:17:17 <revenantphx> No, I don't work on linux much anymore.
21:17:19 <kmc> (it's been done, kind of, but not exactly a sane thing yet)
21:17:28 <revenantphx> I really really like clang though
21:17:39 <Maxdamantus> I think they've also set it up to be done at boot, with tcc.
21:17:48 <revenantphx> It's just very slick in my experience. I'm sure there are nasty bits underneath, but I havent seen any visible on the outside.
21:17:49 * kmc hands revenantphx a black turtleneck
21:17:58 <revenantphx> kmc: D: noooo.
21:17:59 <thoughtpolice> tccboot is a hack that requires some modifications to the linux kernel to work correctly
21:18:11 <thoughtpolice> the guy who compiled Linux with clang had to do a lot of work actually
21:18:15 <revenantphx> Well, let me put it this way kmc,
21:18:17 <thoughtpolice> and AFAIK, a bit of that work has not yet made it upstream
21:18:20 <kmc> the Linux source abuses GCC features to an amazing degree
21:18:26 <revenantphx> I don't work on linux anymore, but I ssh into linux boxes way too much.
21:18:33 <kmc> it's really quite amazing
21:18:44 <revenantphx> I kind of expect the linux kernel to reach critical mass at some point.
21:18:56 <revenantphx> As in, it's too big to be wholly maintained, and parts begin to bitrot.
21:19:17 <thoughtpolice> linux tends to generally abuse binutils, I know there's a lot of stuff it abuses that's part of ld, which is why it's not possible to build linux using gold yet
21:19:19 <Gracenotes> I've been grepping through it lately. reading some network drivers.
21:19:32 <kmc> revenantphx, there was a high-profile security vulnerability recently relating to the bitrotten support for a network protocol used only by 1980's-era microcomputers
21:19:39 <revenantphx> nice
21:19:48 <kmc> which module is still shipped by many popular distributions
21:19:48 <revenantphx> Can we have a successor to linux soon?
21:19:51 <kmc> and will automatically load itself
21:19:54 <kmc> revenantphx, go ahead
21:20:09 <revenantphx> Yeah, I realize the presumptuousness of that statement,
21:20:15 <revenantphx> but I'm sure someone must have tried.
21:20:21 <Gracenotes> PLAN 9 FROM OUTER SPACE
21:20:26 <revenantphx> Gracenotes: predictable.
21:20:33 <Gracenotes> COMPLETE WITH CUTE BUNNEH LOGO
21:20:51 <thoughtpolice> bitrot is inevitable as a part of all software if you ask me, linux is not immune by any means. they at least have very strict maintainer roles and various subsystem maintainers to help mitigate this at several levels
21:21:16 <tessier> revenantphx: What would such a successor be like and who would code it?
21:21:21 <nosila> going too sleep, too much haskell for today lol
21:21:27 <nosila> cya
21:21:28 <revenantphx> tessier: It would be coded by self-aware haskell.
21:21:29 <thoughtpolice> although the fact that things like what kmc mentions happen isn't totally surprising
21:21:52 <tessier> revenantphx: You'll have to wait for the Singularity for that, I'm afraid.
21:22:35 <kmc> revenantphx, i'm not too interested in Yet Another implementation of the ancient and crufted POSIX semantics
21:22:40 <revenantphx> See, when I said all computers hooked up to the internet should have a 1,000,000 node ANN with permission to send multicast UDP packets around, no one listened to me.
21:22:46 <Gracenotes> backwards compatibility is depressingly ubiquitous in software/hardware
21:22:52 <ddarius> tessier: Singularity OS?
21:22:53 <tessier> revenantphx: He just said a successor, he didn't specify semantics.
21:22:54 <kmc> i'd be interested in an OS with new, better semantics, maybe something that knows about types other than [Word8]
21:23:01 <revenantphx> kmc: I agree with this
21:23:14 <revenantphx> A strictly typed system would be interesting to say the least.
21:23:16 <tessier> What about...House? I think that was it: OS written in haskell.
21:23:17 <Gracenotes> it's the guiding principle of software engineering, at least as far as software engineering generally affects me
21:23:21 <revenantphx> Among other things, I hate file extensions.
21:23:24 <ddarius> @google Singularity OS
21:23:25 <lambdabot> http://research.microsoft.com/en-us/projects/singularity/
21:23:25 <lambdabot> Title: Singularity - Microsoft Research
21:23:28 <revenantphx> File extensions need to die in a hole.
21:23:38 <revenantphx> They are one of the worst ideas ever for managing what/how a file is/is opened.
21:23:54 <tessier> revenantphx: Linux doesn't make use of file extensions for anything. What extensions there are exist for the benefit of humans.
21:23:56 <revenantphx> Plus when the file name is long they're hard to read.
21:24:02 <kmc> they aren't an idea really
21:24:03 <thoughtpolice> we have halvm now - we can just run ghc programs directly on xen.
21:24:04 <Maxdamantus> I agree with tessier.
21:24:06 <kmc> more like a loose convention that caught on
21:24:14 <Maxdamantus> They're very useful, but only when humans are looking at them.
21:24:15 <Gracenotes> I've been writing a basic OS in C. Haskell... well... I can't imagine that being much anything other than a more-or-less direct translation into IO with extra asm bits to load it
21:24:25 <Maxdamantus> find ~/ -name \*.foo
21:25:02 <Maxdamantus> If you're looking at a directory of files, you don't need to waste time running some content-detecting mechanism on them to figure out what they are.
21:25:07 <revenantphx> I'm waiting for the day we discover a perfect equation for the state of the entire universe. Mainly because if we pass it into Haskell functions, we can make *any* function pure, regardless of use of mutable state.
21:25:17 <Maxdamantus> Sometimes the content-detection is difficult, eg in the case of program source code.
21:25:24 <djahandarie> revenantphx, you can also predict the future. :)
21:25:27 <tessier> revenantphx: What would you store such a state in being that it has to also store its own state which is within that universe?
21:25:33 <revenantphx> djahandarie: Multithreading just got way easier.
21:25:40 <djahandarie> Haskell is pretty bad at doing the low-level stuff required for an OS.
21:25:45 <revenantphx> tessier: Magic.
21:25:46 <Maxdamantus> You have a file which at first glance appears to be C, but it's actually C++.
21:25:59 <djahandarie> Do you go left, or right?
21:26:24 <Maxdamantus> In some cases, assuming it is C will mean it might happen to compile, but with different results.
21:26:38 <Gracenotes> I have an amazing idea! let's detect content-types solely on the basis of file extensions!
21:26:44 <Maxdamantus> (or vice-versa)
21:26:52 <Gracenotes> no one's done it before, and certainly it's not a security risk
21:27:18 <djahandarie> Habit is an interesting "dialect" of Haskell that is specifically tailored for low-level Haskell stuff.
21:27:24 <thoughtpolice> djahandarie: halvm seems to work pretty well for prototyping stuff on xen. mostly the issue I see is the actual need for data types where precise layout controll is required, without things like template haskell, etc.
21:27:39 <djahandarie> Though I haven't heard from them since the Galois talk
21:28:07 <thoughtpolice> iavor, one of the guys behind hobbit, the successor to habit (he also worked on habit himself) described a lot of these kinds of ideas in his PhD thesis
21:28:14 <thoughtpolice> (iavor is also a galois guy :)
21:28:46 <djahandarie> thoughtpolice, yeah HaLVM is cool and definitely makes this stuff easier
21:28:53 <djahandarie> And there is a successor to habit?
21:28:56 <revenantphx> Is galois secretly an organization dedicated to bringing about the haskellingularity?
21:28:58 <djahandarie> Link! :o
21:29:03 <thoughtpolice> er, i meant predecessor
21:29:05 <thoughtpolice> :P
21:29:06 <thoughtpolice> sorry!
21:29:12 <rothwell> 'lo. i just installed the 7.0.1 binaries on freebsd 8.1 and am now trying to build cabal... unfortunately, i just get this message: http://paste.lisp.org/display/119410
21:29:15 <djahandarie> :(
21:29:23 <thoughtpolice> djahandarie: i actually noticed that iavor uploaded a old snapshot of hobbit on his github, though
21:29:32 <thoughtpolice> it was interesting to finally see SOME of that work out there in the open
21:29:53 <thoughtpolice> http://github.com/yav/hobbit
21:30:04 <Gracenotes> rothwell: arg! I got that too >:(
21:30:19 <rothwell> Gracenotes: argh! any idea what the problem is?
21:30:22 <djahandarie> minecraft-proxy...
21:30:28 <djahandarie> Wasn't glguy working on something like that too?
21:30:36 <Gracenotes> rothwell: it seems.. one might have to wait until cabal-install-1.10.0 comes out
21:30:43 <djahandarie> Oh hey, forked from glguy/minecraft-proxy, I guess it's the same thing
21:30:49 <dankna> old version of Cabal?  I'm running cabal library 1.11.0, although that's unreleased and I'm using an unreleased ghc as well.
21:30:51 <Gracenotes> that's just my guess. there's probably a better more immediate fix.
21:30:59 <Gracenotes> er, yeah, 1.11.0
21:31:06 <revenantphx> AGH.
21:31:16 <revenantphx> ITS FOLLOWING ME EVEN INTO HASKELL.
21:32:10 <dankna> so I'm not quite understanding why you're trying to build 1.8.0.4
21:32:19 <thoughtpolice> djahandarie: i thought that was slightly humorous, i guess some of the galois guys are minecrafters :)
21:32:27 <Gracenotes> dankna: probably to bootstrap cabal-install?
21:32:39 <rothwell> dankna, Gracenotes: yeah
21:32:43 <dankna> you don't need an old version of Cabal to bootstrap cabal-install, you can bootstrap it with the latest
21:32:50 <Gracenotes> cabal-install-0.8.2 depends on cabal 1.8.*
21:32:55 <dankna> I just did it two weeks ago
21:32:59 <Gracenotes> and there's no newer version :/
21:33:06 <dankna> oh, right.  I may have edited that dependency in the .cabal file ^^'
21:33:13 <dankna> caveat emptor if you do the same
21:33:31 <dankna> welcome to the cutting edge :)
21:33:47 <ddarius> Are you still an emptor if it is free?
21:33:52 <rothwell> i... think i'll stick to 6.12.3
21:33:55 <Gracenotes> heh. okay.. so let cabal-install-0.8.2 use Cabal 1.10.*
21:33:58 <dankna> what, you haven't heard of total cost of ownership? :)
21:34:42 <ddarius> dankna: But you don't own it either.
21:34:44 <Gracenotes> rothwell: it might work! but.. I had problems using GHC 7 earlier today too.. after a while I was like fuck it, deleted everything, sudo apt-get install ghc6 cabal-install, *covers ears* scary monsters can't come get me anymore
21:34:49 <Gracenotes> ...roughly
21:35:14 <rothwell> hehe
21:35:18 <dankna> ddarius: that's a point!
21:35:22 <dankna> well
21:35:32 <dankna> technically you own the copy of it.  just not the copyright on it.
21:36:02 <dankna> for the record, my system has been stable for two weeks.  but different version of ghc as I said.
21:36:09 <dankna> and two weeks is not exactly a millenium.
21:36:38 <dankna> you do need to seriously evaluate whether it's worth the effort to you to be ahead of the release curve in the Haskell world
21:37:01 <dankna> in my case the answer is yes because I find my software just breaks sooner if I code to the not-as-new versions :)
21:37:24 <dankna> also I occasionally have other reasons, like there was a performance issue with large arrays and the GC, but that finally got the fix released, so.
21:38:00 <dankna> but make no mistake, it's a lot of effort.  having to edit packages in minor ways to get them to build at all is fairly routine.  for example somewhere along the lines they changed the layout rule and added a LANGUAGE flag to change it back...
21:39:07 <kmc> cool, haddock documents an abstract "newtype" as if it were declared with "data"
21:39:08 <kmc> :)
21:39:27 <dankna> nice
21:51:51 * hackagebot spelling-suggest 0.5.0 - Spelling suggestion tool with library and command-line interfaces.  http://hackage.haskell.org/package/spelling-suggest-0.5.0 (GregWeber)
22:30:46 <wkoiking> hi
22:34:00 <woopy> hello
22:57:06 <Jonno_FTW> how come the code for lambdabot isn't on code.haskell.org?
22:57:41 <kmc> it's on hackage.haskell.org
23:03:48 <Jonno_FTW> kmc: ahh
23:03:50 <Jonno_FTW> @list
23:03:50 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:12:02 <Jonno_FTW> kmc: where do I darcs pull it from then?
23:15:50 <kmc> i guess it's down
23:16:34 <Jonno_FTW> :(
23:16:47 <Jonno_FTW> would it be safe to get the tarball and compile from there?
23:18:25 <Jonno_FTW> @version
23:18:25 <lambdabot> lambdabot 4.2.2.1
23:18:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
23:32:29 <tehgeekmeister> what is the general approach behind libraries that claim to ensure certain properties using the type system (yesod and url correctness, for example)?
23:37:51 <kmc> don't think there's a single general approach for all of them
23:38:48 <kmc> any more than there's a single general approach for writing an arbitrary program
23:38:57 <kmc> you want a different program, you use different techniques
23:39:05 <kmc> you want different correctness properties, you use different techniques
23:40:02 <kmc> maybe you'd like http://blog.sigfpe.com/2010/08/constraining-types-with-regular.html
23:43:35 <Jonno_FTW> should I use yesod or snap?
23:43:47 <c_wraith> They do pretty entirely different things
23:43:59 <c_wraith> Which one does what you want?
23:46:14 <kfr> c_wraith entirely different how? They both are web development frameworks, no?
23:46:38 <c_wraith> the have entirely different philosophies and tools
23:46:51 <c_wraith> yesod is about creating REST sites
23:46:57 <kfr> REST = ?
23:47:52 <jeffwheeler> c_wraith: what would you say snap is about, in comparison?
23:50:10 <kfr> jeffwheeler: Beware! He will try to sell you Snap because he is a Snap developer!
23:50:15 <c_wraith> haha.
23:50:22 <c_wraith> I'm a snap developer, in a very limited way :)
23:50:43 <jeffwheeler> c_wraith: I'm fine with being sold; I'm interested but apathetic right now.
23:51:12 <c_wraith> I'm not likely to sell it too hard.  It is still very early phase.
23:51:34 <jeffwheeler> They both seem like pretty solid frameworks right now. I was playing with Yesod earlier and disliked some "magic" (like / HomeR GET calling getHomeR magically).
23:52:24 <c_wraith> Long term, snap wants to be sort of like the Lift framework in java-land, I believe
23:52:38 <c_wraith> But there's a long way to go, yet.  Still working on the fundamentals.
23:54:12 <jeffwheeler> I'm not familiar with that. I'm coming to haskell web frameworks with a background in Haskell and in Django stuff. It seems like Yesod tries to mimic traditional frameworks like Django a bit more.
23:56:07 <kfr> I'm currently trying to write my own framework, slowly rediscovering bits of pieces why Yesod and Snap do things the way they do
23:56:22 <kfr> Which was previously unclear to me
23:58:32 <glguy> thoughtpolice: a lot of us are, actually :)  (/me challenges thoughtpolice to identify the appropriate context)
