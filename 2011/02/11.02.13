00:13:47 <haskellnoob> Hi. I had asked a doubt a week ago about a certain piece of code from the darcs source which I was trying to decipher.
00:13:57 <haskellnoob> I think I have deciphered it now :)
00:14:28 <haskellnoob> I have posted my breakdown of it here : http://hpaste.org/43942/composed_function_doubt
00:14:38 <haskellnoob> Does this analysis look OK?
00:16:29 <jonkri> ddarius: why would the logging initialization function take a LoggerT? would that LoggerT be a function defined within the logging framework?
00:18:49 <ddarius> jonkri: Presumably you aren't going to "reinitialize" the logging stuff mid-stride, though, if you do want to do that, you certainly could.  This "initialization" function is basically the "runLoggerT" function, the thing that let's you actually observe results from a LoggerT computation.
00:28:09 <haskellnoob> Hi. I had asked a doubt a week ago about a certain piece of code from the darcs source which I was trying to decipher.
00:28:12 <haskellnoob> I think I have deciphered it now :)
00:28:13 <haskellnoob> I have posted my breakdown of it here : http://hpaste.org/43942/composed_function_doubt
00:28:16 <haskellnoob> Does this analysis look OK?
00:30:57 <ddarius> What's a type where equality is semidecidable but inequality is undecidable?
00:32:11 <haskellnoob> ddarius: By semidecidable do you mean recursively enumerable?
00:32:59 <Taejo> haskellnoob: they generally mean the same thing
00:33:00 <ddarius> By "semidecidable" I mean if a and b are equal then a == b will always return true, but if they are not equal then it will fail to return any result in at least some cases.
00:35:10 <ddarius> (Topologically I'm asking for something that is discrete but not Hausdorff, with perhaps slightly odd meanings for those terms.)
00:35:57 <Taejo> indeed
00:36:11 <Taejo> since a discrete topology is Hausdorff
00:36:40 <Taejo> do you mean Hausdorff but not discrete?
00:37:05 * Taejo hasn't done topology of CS (or any topology) in too long
00:37:32 <Taejo> ddarius: [Bool] is such a type
00:38:01 <Taejo> and indeed it is Hausdorff but not discrete
00:38:48 <haskellnoob> ddarius: does this not depend on how exactly (==) is implemented for the type?
00:39:43 <Taejo> haskellnoob: enumerability and decidability are properties of problems, not of programs (although both are witnessed by programs)
00:39:46 <ddarius> haskellnoob: The question is whether there exists any sound such (==).
00:41:39 <haskellnoob> ddarius: What about the following implementation of (==) which tests whether two functions of type Num -> Bool are identical: enumerate the numbers starting from 1, and return True iff both the functions return the same value on some integer ? (Or am I getting this totally wrong?)
00:42:00 <ddarius> Taejo: I meant what I said.  It's not hard to find things with semidecidable inequality and undecidable equality.  I also formulated the question as I originally did as the "slight oddness" of my meanings may matter.
00:43:52 <ddarius> haskellnoob: That's on an unbounded domain that will never return anything.  Even on a bounded domain that will not return true for all equivalent function, e.g. const undefined is clearly equal to const undefined, but you == will not return true for that.
00:44:38 <haskellnoob> ddarius: The range is Bool, which has exactly two values.. I don't get the const thing 
00:45:36 <haskellnoob> (I have a feeling we are talking about different things here :) )
00:48:41 <ddarius> haskellnoob: The question is, is there a type where you can implement (==) so that it always returns True when the values are, in fact, equal and no other time for which you can't write (/=) so that it always returns True for things that are, in fact, unequal and no other time.
00:49:09 <ddarius> s/no other time for/no other time, for/
01:00:32 <ddarius> (Also, incidentally, in Haskell no type has semidecidable in/equality except, arguably, Void, but I'm not limiting my question to Haskell.)
01:08:32 <jonkri> ddarius: i don't want to "reinitialize" the logging stuff. why not wrap the runLoggerT function inside the function you suggested and have one less parameter? and what do you mean by letting me observe the results?
01:11:14 <ddarius> jonkri: I'm suggesting that this -be- the runLoggerT function.
01:13:11 <ddarius> Also, main :: IO a, you need to produce an IO action eventually.
01:13:31 <jonkri> ddarius: can we omit the LoggerT argument though, and have it constructed internally in the runLoggerT function?
01:13:38 <jonkri> leaving only the "stuff" argument
01:19:00 <jonkri> if not: how would the person using the logging library construct it?
01:33:08 <dullboy> hello, I'm a novice trying to use parsec. Should I install it using cabal or is there something Debian I can use?
01:34:29 <dullboy> ah no problem, I've found the package
01:35:30 <Jafet> cabal and dpkg are mutual bigots, so it's bad either way
01:36:03 <Figs> Hello, I seem to be missing the docs for Control.Monad.Reader in Haskell Platform 2010. Is this a known issue, or something peculiar to my installation?
01:37:28 <ddarius> jonkri: Why do you even think you want a monad transformer?
01:38:38 <Figs> For example, on my system this path does not exist: file:///C:/Program%20Files/Haskell%20Platform/2010.2.0.0/doc/html/libraries/mtl-1.1.0.2/Control-Monad-Reader-Class.html
01:39:30 <dullboy> Jafet: thanks :)
01:43:55 <dullboy> anyone knows parsec? I'm trying "anyChar `manyTill` spaces" for "a b" but it doesn't work...
01:45:57 <Jafet> "doesn't work" doesn't work. Describe the problem
01:47:20 <dullboy> No instance for (Text.Parsec.Prim.Stream s m Char)
01:48:42 <Jafet> Well, looks like anyChar is a Char parser, and spaces is a String parser
01:48:49 <Bynbo7> well that has nothing to do with parsec not working
01:49:39 <dullboy> I mean my use of parsec is not working :)
01:50:16 <Jafet> Oh, this is parsec-3
01:50:24 <Jafet> One parsec too many for me
01:50:24 <Figs> dullboy: What are you trying to get parsec to do?
01:50:46 <dullboy> Figs: I'm trying to lean. I want to parse "a b c"
01:51:15 <dullboy> I tried "many1 anyChar" but I guess it's not right either
01:51:30 <jaj> dullboy: well manyTill can't work since you only have 1 char
01:52:35 <jaj> dullboy: oh sorry that's not true "applies parser p zero or more times"
01:53:17 <Figs> dullboy: What do you want to do with "a b c"?
01:53:30 <dullboy> jaj: yes, plus I'm using longer strings... ugh, am I dumb or the initial learning curve is so steep?
01:53:49 <dullboy> Figs: I return it in a data type I made
01:56:14 <dullboy> Jafet: but if I do "anyChar `manyTill` space" I get the same error
02:03:59 <Figs> dullboy: Maybe what you're looking for is something like: manyTill anyToken space  ?
02:07:46 <Figs> or, perhaps: sepBy (many1 letter) space  ?
02:13:46 <dullboy> Figs: well thanks, I'm getting another error now. The type ctor fails because there are some [[Char]] instead of strings... I'll look into it
02:15:02 <Figs> "sepBy (many1 letter) space" would parse something like "a b c" into ["a", "b", "c"]
02:17:08 <jonkri> ddarius: to have a context in which developers can easily access the ("stateful") logging functions
02:17:24 <andreypopp> Hello, where I can download haskell-mode for Vim?
02:17:33 <andreypopp> http://projects.haskell.org/haskellmode-vim/ seems to be empty :-(
02:18:36 <opqdonut> gah, do I have to have profiling versions of every library I use installed in order to profile?
02:18:43 <c_wraith> yes
02:18:50 <opqdonut> *sigh*
02:19:14 <blackdog> opqdonut: it's a pain. set it in your cabal config file once and reinstall, you should be fine.
02:19:28 <opqdonut> blackdog: ok
02:19:32 <blackdog> (reinstall the hackage packages, i mean)
02:20:03 <opqdonut> yes
02:20:07 <opqdonut> is there a single command for that?
02:20:32 <blackdog> oh wooouuuldn't it be luvverly
02:21:01 <opqdonut> :S
02:24:58 <jonkri> ddarius: how would you do it?
02:46:29 <lewis1711> what's with the whole x:xs thing? I mean I know what it is semantically, but where did that convention come from?
02:48:41 <Blkt> good day everyone
02:50:06 <Figs> lewis1711: I don't know, but you might start looking through the history of lisp's cons function.
02:50:33 <lewis1711> it's in okasaki as well, in the ML examples
02:50:44 <Figs> (cons 1 (cons 2 (cons 3 nil))) is a bit verbose :)
02:50:45 <Saizan> xs is simply the plural of x, if you're referring to that
02:51:05 <lewis1711> Saizan: ah. should have figured that out
02:51:09 <lewis1711> yeah that's all I was wondering
02:51:22 <Figs> lewis1711: Oh, I thought you were looking for the etymology of (:))
02:51:25 <Figs> *(:)
02:51:41 <lewis1711> Figs: (list 1 2 3) , or is that just scheme? :D
02:52:50 <Figs> lewis1711: [1,2,3] is the same as 1:2:3:[]
02:53:32 <Jafet> > let cons = (:); nil = [] in (cons 1 (cons 2 (cons 3 nil)))
02:53:33 <lambdabot>   [1,2,3]
02:53:44 <Jafet> Hathkell?
02:53:44 <lewis1711> yeah, but who would want to write it that way? ;)
02:54:00 <lewis1711> ha. I was looking at liskell today
02:54:11 <lewis1711> http://www.liskell.org/
03:02:45 <adu> lewis1711: liskell is awsome
03:05:06 <ksf> whatever happened to category-extras?
03:05:06 <lambdabot> ksf: You have 1 new message. '/msg lambdabot @messages' to read it.
03:05:37 <ksf> @tell xplat both
03:05:37 <lambdabot> Consider it noted.
03:14:31 <ksf> is category-extras dead?
03:14:57 <ksf> @seed edwardk 
03:14:57 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
03:15:05 <ksf> preflex, seen edwardk 
03:15:05 <preflex>  edwardk was last seen on #haskell 1 day, 3 hours, 41 minutes and 10 seconds ago, saying: ddarius: in practice i find that i wind up having to start somewhere in the middle as well, i want to be able to reason about the resulting monstrosity after all ;)
03:15:59 <ksf> @ask edwardk is category-extras dead, or at least obsolete? 
03:16:00 <ezyang> Does anyone know of a "debugger" that works on the typechecking process? 
03:16:00 <lambdabot> Consider it noted.
03:16:23 <ezyang> Allowing you to see the flow of data as types get unified, step forward and backwards from the type error, etc? 
03:17:26 <ksf> it's called oleg's brain.
03:17:50 <ezyang> Ah! Where can I download Oleg's brain? :-) 
03:18:08 <ksf> you might want to ask spj, he seems to have a copy of it.
03:18:33 <ksf> though probably an outdated version.
03:19:02 <ManateeLazyCat> Hi all. :)
03:20:00 <ddarius> @google Chameleon type debugger.
03:20:02 <lambdabot> http://www.google.com.hk/url?sa=p&hl=zh-CN&pref=hkredirect&pval=yes&q=http://www.google.com.hk/search%3Fhl%3Den%26q%3DChameleon%2520type%2520debugger.%26btnI%3DI'm%2BFeeling%2BLucky&ust=12975974204681
03:20:02 <lambdabot> 01&usg=AFQjCNEd-cHwGvaP9BVa4YDP84YevxWMgg
03:20:02 <lambdabot> Title: cache:http://www.google.com.hk/url?sa=p&hl=zh-CN&pref=hkredirect&pval=yes&q=http ...
03:20:03 <ezyang> More seriously, I'd kind of like to build one of those. I'm not sure if it'll actually help people, but it sounds interesting and useful, especially in the presence of inferred types. Maybe I'll try prototyping one on the simple lambda calculus. 
03:20:08 <Saizan> ezyang: http://portal.acm.org/citation.cfm?id=871895.871903
03:20:09 <ezyang> ugh 
03:20:11 <ddarius> @google Chameleon type debugger
03:20:11 <ezyang> Thanks! 
03:20:12 <lambdabot> http://www.google.com.hk/url?sa=p&hl=zh-CN&pref=hkredirect&pval=yes&q=http://www.google.com.hk/search%3Fhl%3Den%26q%3DChameleon%2520type%2520debugger%26btnI%3DI'm%2BFeeling%2BLucky&ust=129759743098328
03:20:12 <lambdabot> 9&usg=AFQjCNGu8vJ1VBginf514NptuMWzkMRcGw
03:20:12 <lambdabot> Title: cache:http://www.google.com.hk/url?sa=p&hl=zh-CN&pref=hkredirect&pval=yes&q=http ...
03:20:19 <ddarius> Hmm
03:20:57 * ksf would like a package called "Hask" that includes all that stuff from category-extras which makes sense in everyday programming
03:23:06 <ddarius> @hackage void
03:23:06 <lambdabot> http://hackage.haskell.org/package/void
03:23:57 <ksf> absurd (Void a) = absurd a
03:24:23 * ksf would prefer absurd (Void _) = error "ex falso quodlibet"
03:26:14 <ezyang> Ah, disappointing, Chameleon is built on top of their own Haskell-like language. 
03:26:31 <ezyang> (well, it is their own Haskell-like language) 
03:27:07 <ksf> you could hack Debug.Trace into ghc's typechecker
03:27:19 <ddarius> ezyang: The debugger works for Haskell 98 as well.
03:27:39 <ezyang> Ooh, classy. 
03:27:50 <ezyang> Though not GHC Haskell, I presume? 
03:27:58 <ksf> afaiu implementations are free to fail differently on bad programs, though.
03:28:14 <ksf> that is, two compilers may check the types completely different and thus flag the error somewhere else
03:29:00 <ksf> ghc, for example, resolves typeclasses ultra-lazily. :t is returning what's essentially WHNF.
03:29:05 <ezyang> Yeah. I suppose one fundamental problem to this approach is that you still have to understand how typechecking works under the hood. 
03:29:23 <ezyang> so it might not actually be so helpful for beginners. 
03:30:06 <ksf> the best thing to do when being faced with an incomprehensible type error is to look for an error in layout or a missing argument to a function.
03:30:24 <dom1_> I used to be able to logon to code.haskell.org and to www.haskell.org
03:30:59 <dom1_> Did lots of things get moved?
03:31:08 <ezyang> ksf: Yeah, the "ignore the message and look around you" approach. 
03:31:39 <ezyang> Dependently-typed style programming in Haskell probably could gain from proof assistant tyle interaction. 
03:31:46 <ezyang> That's a different class of incomprehensible errors :-) 
03:31:56 <ksf> next comes writing type signature and replacing code with "undefined", in strategic places.
03:32:09 <Saizan> agda style holes would make any error easier to debug
03:32:24 <ksf> partial type sigs, too.
03:32:42 <Saizan> dom1_: c.h.o got hacked, they haven't restored the account yet
03:32:51 <ksf> uhc getting traction can only be good for the state of haskell
03:32:51 <Saizan> dom1_: *accounts
03:32:53 <ezyang> Partial type sigs need Oleg level hacks :-) 
03:33:02 <ksf> ...or uhc.
03:33:42 <dom1_> @Saizan: ok thanks I haven't logged on for years
03:33:42 <lambdabot> Unknown command, try @list
03:34:12 <dom1_> So I thought everything might have changed
03:34:23 <dom1_> I had some old code I wanted to look at
03:34:42 <dom1_> But it didn't seem to be where I thought I had left it
03:54:17 <dibblego> does a blog using hakyll allow comments?
03:54:47 <xarch> hm
03:54:51 <xarch> with disqus
03:54:59 <xarch> but otherwise no
03:55:07 <dibblego> ok I'll have to investigate cheers
04:11:56 <lewis1711> so when you guys come across something you'd model with objects in other languages, what do you do in haskell? make records, and functions that operate on them?
04:12:31 <shapr> Were I not about to fall over asleep, I would give you a detailed answer...
04:12:32 <Jonno_FTW> lewis1711: you make a monad, and possibly a type class/ctype
04:12:35 <shapr> but in general, it depends
04:13:28 <shapr> objects are code that has data, typeclasses are data that has code... sort of.
04:14:54 <Saizan> lewis1711: i'd try to rethink it in terms of algebraic data types first
04:14:54 <ddarius> @tell roconnor See the last twenty minutes of this http://www.cs.uoregon.edu/Activities/summerschool/summer10/video/OPLSS10-22-3.mp4 and maybe also http://www.cs.uoregon.edu/Activities/summerschool/summer10/video/OPLSS10-23-3.mp4 (though I haven't watched the latter yet)
04:14:54 <lambdabot> Consider it noted.
04:14:55 <Toxaris_> lewis1711: Most often, you can use algebraic data types and functions that operate over them. About one data constructor per concrete subclass.
04:15:21 <lewis1711> interesting
04:15:54 <Toxaris_> lewis1711: But if you don't know the subclasses in advance (think anonymous subclasses or plugins), you can model objects as a record of functions
04:16:27 <Toxaris_> lewis1711: About one function per method in the abstract base class.
04:17:09 <Toxaris_> Lambda expressions are a special case of this: You can use them to model objects with only one method.
04:17:48 <lewis1711> you've lost me there
04:17:55 <Toxaris_> where?
04:18:12 <lewis1711> using lambda expressions to model objects
04:18:42 <dibblego> an interface with n methods is a tuple-n of lambda expressions
04:18:50 <Toxaris_> lewis1711: Let's say we have, in Java: interface {int foo (int x)}
04:19:09 <Toxaris_> lewis1711: Hmm, of course: interface Foo {int foo (int x); }
04:19:11 <Saizan> it's a tuple of functions
04:19:22 <Toxaris_> lewis1711: So in Haskell, we can use   type Foo = Int -> Int
04:19:26 <Saizan> lambda expressions are just a particular way to build functions
04:20:46 <Toxaris_> lewis1711: because with a value of type Foo in Java, all we can do is: call foo. And with a value of type Int -> Int in Haskell, all we can do is: call it. So they are equivalent for our purpose.
04:21:13 <Toxaris_> Many uses of objects follow this pattern of having only one method. For example, the Strategy pattern.
04:22:07 <jonkri> ddarius: would the alternative be to have the user wrap the logging state object in some kind of state monad or something?
04:22:54 <lewis1711> still lost. what does this have to do with objects? 
04:24:03 <Botje> lewis1711: slightly not-haskell, but have you read SICP? they use closures to elegantly model objects
04:24:21 <lewis1711> haven't read most of it, but i have read tha tbiot
04:24:23 <lewis1711> *that bit
04:24:42 <lewis1711> I don't consider it that elegant because it falls apart when you want to clone or inherit from something
04:24:53 <lewis1711> works well for singletons i guess
04:28:13 <Toxaris_> lewis1711: well, a value of type Foo in Java is an object. But a value of type Foo in Haskell is a function. But these values can be used in similar ways. So we have modelled objects with functions.
04:28:26 <ezyang> Who said cloning worked by default in Java? :-) 
04:28:52 <Toxaris_> Well, I started talking Java, not lewis1711, I think.
04:28:58 <lewis1711> correct
04:29:10 <Botje> lewis1711: inheriting is just a case of using a different "catch-all" handler
04:29:22 <Botje> cloning is easily implemented by adding a clone method everywhere :)
04:29:24 <lewis1711> I don't regard java as all that OOP
04:29:44 <lewis1711> Toxaris_: ah, get you now
04:30:17 <tomh> hey what am I supposed to do when I get hGetContents: invalid argument (Illegal byte sequence)?
04:30:17 <Toxaris_> lewis1711: what do you regard as OOP?
04:30:30 <tomh> file is utf-8
04:30:57 <ezyang> tomh: Is it well-formed utf-8? 
04:31:05 <tomh> how can I check?
04:31:37 <ezyang> If it's not to big, open it up in a reasonable text editor like vim and look for suspicious byte literals. 
04:31:57 <ezyang> although, it might be as simple as switching the encoding on the handle. 
04:32:05 * ezyang doesn't remember what the default encoding is. 
04:32:11 <ezyang> hSetEncoding. 
04:32:13 <lewis1711> Toxaris_: ruby, smalltalk. I still think java is OOP, but not pure or close to it
04:32:18 <tomh> mm well its in a external library :(
04:32:21 <lewis1711> or maybe a hybrid
04:32:27 <tomh> so I can't really change the program
04:32:45 <ezyang> Ok, probably your file is naughty. 
04:32:49 <tomh> It might be my files as I use files created on windows and try to run them on mac now
04:33:09 <Botje> tomh: no, haskell doesn't mind \r\n
04:33:59 <Toxaris_> lewis1711: well, since Haskell is statically typed, it is more natural to model statically typed objects.
04:34:06 <tomh> well If I use the exact same files on windows with the exact same library it works
04:34:38 <tomh> but im pretty sure its the windows text files
04:34:45 <lewis1711> yeah. wasn't criticising your choice of language, was just responding to ezyang
04:34:58 <tomh> an empty file created on mac works
04:35:58 <Botje> tomh: maybe it's encoded weirdly.
04:36:05 <Toxaris_> lewis1711: and since Haskell is purely functional, it is more natural to model stateless objects
04:36:07 <Botje> what encoding does your editor say it is?
04:36:10 <tomh> Botje: that might be it
04:36:20 <nominolo> @users
04:36:20 <lambdabot> Unknown command, try @list
04:36:30 <tomh> it was utf-8, but I spotted a weird character now :)
04:36:33 <Botje> yay :)
04:36:35 <Toxaris_> lewis1711: so what's left of OO? late binding!
04:37:54 <Toxaris_> lewis1711: with static typing, late binding means that we can call a method and we know that we get a well-typed result, but we don't know *which* method body exactly is execeuted. Now, in statically typed FP, the very samy is true of first-class functions: We can call a function without knowing what exactly will be executed.
05:04:04 <ksf> why are there no handle IO functions in vector?
05:04:15 <ksf> it seems it could completely replace ByteString
05:04:27 <ksf> ...*and* Text
05:05:56 <ezyang> IIRC, vector doesn't do chained chunks of memory? 
05:08:00 <ksf> oh, yes.
05:08:13 <ksf> but then I don't need those, iteratees are all about chaining, after all.
05:10:21 <ezyang> ksf: You're talking about internal representations, I assume? 
05:10:28 <ezyang> Because text definitely adds value. 
05:11:30 <ksf> anything that one couldn't get via Data.Encoding?
05:12:20 <ezyang> dunno. 
05:15:17 <ksf> gragh. can't make an instance, anyway.
05:15:22 <ksf> instance (V.Vector v a) => Chunk v where
05:15:22 <ksf>     type Elem v = a
05:15:24 <ksf> doesn't work.
05:16:53 <xplat> 23:43 < roconnor> you probably don't want/need to make objects into a setoid
05:16:53 <lambdabot> xplat: You have 1 new message. '/msg lambdabot @messages' to read it.
05:17:24 <ksf> duh.
05:17:26 <ksf> instance (V.Vector v a) => Chunk (v a) where
05:17:26 <ksf>     type Elem (v a) = a
05:17:32 <ksf> yay undecidable instances
05:18:01 <jaj> hi, I was wondering what would you recommend to do IPC in haskell?
05:18:15 <ksf> good question.
05:18:22 <xplat> if you want to quotient the objects and not just the morphisms of a category, you don't just need to provide an equivalence relation on objects, you need to specify isos that are consistent with the equivs on the homsets
05:18:49 <ddarius> xplat: Of course you do.
05:19:03 <ksf> more importantly, you need to express the isos as zygohistomorphic prepromorphisms from Set to Hask
05:19:11 <jaj> the IPC package is marked deprecated but I like the idea of having something lightweight on top of sockets, I'd rather not depend on something like dbus
05:19:36 <ksf> there's e.g. a package that can make your code an erlang node
05:19:58 <ksf> there's also able web servers, you could go REST
05:20:15 <ksf> which would mean great debuggability.
05:21:00 <ksf> or something like 9p
05:21:11 <ksf> never used that package we have, though.
05:21:29 <ksf> probably not the most efficient or high-level, but 9p is great.
05:22:40 <jaj> hmm yeah 9p may be interesting
05:23:08 <Bynbo7> there's also things like ZeroMQ
05:25:18 <jaj> I thought about starting a web browser project in haskell. What I thought was having light-weight clients that wrap webkit, webkit should be the only visible widget in the client process. then I would have a controlling process that manages the clients. The clients should be embedded using Xembed and communication between the clients and the manager should go through a simple IPC channel
05:26:23 <jaj> and the manager should be configurable through a highlevel DSL in xmonad fashion
05:27:57 <ksf> jaj, https://github.com/mozilla/chromeless
05:29:10 <ksf> there's some work going on compiling haskell to javascript, so we could do http backends and AJAX frontends, all completely in haskell.
05:32:42 <xplat> 00:57 < Jafet> Is there a decision procedure for determining whether a P=NP?  paper is valid
05:33:29 <augur> Saizan: you awake?
05:33:33 <xplat> if scott aaronson says it's valid, then it's valid.  if he says anything about it at all, it was either a near miss or went viral.
05:33:37 <jonkri> how can i get a YYYYMMDDHHMM string in haskell?
05:33:48 <jonkri> http://hackage.haskell.org/packages/archive/time/1.1.2.1/doc/html/Data-Time-Calendar.html ?
05:34:50 <hpc> also try Data.Time
05:34:54 <hpc> and System.Locale
05:35:49 <vegai> anyone know if HP2011 will wait for ghc-7.0.2?
05:35:52 <hpc> to format the current time, using RFC 822, use
05:36:00 <hpc> formatTime defaultTimeLocale rfc822DateFormat <$> getCurrentTime
05:36:22 <jonkri> thanks
05:36:32 <hpc> it's not the format you want, but it's a start
05:36:34 <ksf> hmmm. I can express null in terms of Foldable, but then I'm still lacking a generic empty structure.
05:37:01 <ksf> ...and I don't want to use Monoid as that one comes with mappend
05:44:25 <RyanRN> Hi haskellers â€” does anyone know if the hackagedb build environment is documented somewhere (e.g. how does it attempt to build your package)?  And is there anyway to emulate it locally to test your package before upload?
05:45:10 <RyanRN> This ticket seems to imply that all packages live in one build environment?  (Rather than sandboxes.)
05:45:11 <RyanRN> http://hackage.haskell.org/trac/hackage/ticket/598
06:00:04 <augur> @tell conal do you know of any research into what sorts of concrete denotations/data structures can be associated with different sorts of operations?
06:00:05 <lambdabot> Consider it noted.
06:10:41 <Navigium> hello... I'm looking for any useful wxHaskell documentation. Is there anything except all the simple hello-world examples and the API?
06:12:31 * ksf had the impression gtk2hs is more popular
06:12:45 <Philippa> last time I used it (which was admittedly many years ago) after that you had to grab general wx documentation and apply it
06:13:24 <ksf> both libraries have a quite unhaskelly feel to them
06:14:10 <Navigium> ksf: I know, but I want the app to look ok on OS X - because there may be people using it on that..
06:14:14 <Gracenotes> graphics.. hard
06:14:23 <Gracenotes> FRP.. harder
06:14:48 <ksf> yep.
06:14:53 <Navigium> ksf: is there anything more "haskelly" ?
06:15:02 <ksf> reactive just doesn't work, and grapefruit never gained any traction
06:15:25 <ksf> grapefruit, yes.
06:15:33 <ksf> not for the faint of heart, though.
06:17:22 <Gracenotes> the devil's in the implementation. still, you can make FPS games with reactive which evidently perform okay. http://www.haskell.org/haskellwiki/Frag
06:17:37 <ksf> with reactive?
06:17:46 <Gracenotes> not the library, with reactive techniques
06:17:57 <ksf> you can't even do an fps display without hogging the cpu
06:18:18 <ksf> once, admittedly, you could.
06:18:20 <nosila> anyone here?
06:18:32 <ksf> it was the most complex code I ever got running.
06:18:38 <Navigium> hmm.. sounds like I will implement my CLI interface first...
06:18:58 <ksf> if in doubt, do a web interface
06:19:22 <Gracenotes> well, it's admirable. really though, imperative is the way :/ OpenGL, GTK, and Cairo are nice in that they use state objects outside of IO before rendering
06:19:23 <Navigium> ksf: I generally don't like web interfaces.
06:19:54 <Gracenotes> unfortunately, their state objects are meant to be manipulated with extreme bias to mutation, so everything's in IO instead of some nice state monad
06:20:22 <ksf> there's gpipe
06:20:35 <ksf> which is a nice concept, but in utter need of a complete rewrite.
06:21:10 <ksf> at which point it probably makes more sense to just transplant it into lambdacube
06:21:12 <Gracenotes> other things like SDL are very hard to make functional
06:21:48 <ksf> SDL is a PITA even imperatively.
06:22:14 <Gracenotes> I wrote a sidescroller in it. not that painful actually, just loading textures and displaying them at offsets.
06:22:22 <ksf> it's about the worst standard linux ever produced.
06:22:32 <Gracenotes> and a raytracer, too, just writing the image pixel by pixel
06:23:01 <Gracenotes> I get how it fails when you need something a little more advanced
06:26:16 <nosila> hey
06:34:27 <nosila> dont know why but my wireless goes down 
06:34:32 <nosila> everytime i come here
06:34:36 <sm> Navigium: the wxhaskell maintainer's blog has some nice examples
06:36:17 <augur> anyone familiar with theory of computation?
06:36:49 <basti_> a little
06:36:51 <Navigium> sm: Got a link by any chance?
06:37:18 <sm> no
06:43:43 <Jonhow> hi
06:43:54 <Jonhow> can anybody tell why this doesn't work
06:44:03 <Jonhow> http://hpaste.org/43943/case
06:45:14 <Saizan> Jonhow: you want let newTree = addElement arvore u
06:46:11 <Saizan> Jonhow: because the return type of addElement is not IO (BSTree a)
06:47:27 <Jonhow> it gives me this error   parse error on input `='
06:48:01 <Jonhow> and before it was giving me this error
06:48:08 <Jonhow>   Couldn't match expected type `BSTree Utente'            against inferred type `IO Utente'
06:49:15 <Lemmih> Jonhow: Try updating your paste.
06:49:41 <Lemmih> Jonhow: Parse errors are easier to debug when we can see what you wrote.
06:51:54 <Saizan> Jonhow: you need the 'let'
06:52:35 <Jonhow> http://hpaste.org/paste/43943/case_annotation#p43944
06:52:37 <augur> Saizan!
06:53:33 <Jonhow> let where?
06:53:38 <Jonhow> ooh okok
06:53:46 <Saizan> http://hpaste.org/paste/43943/case_annotation#p43945 <- it should work like this
06:53:47 <Jonhow> is runing  ;)
06:53:53 <Jonhow> gonna try it
06:54:19 <Jonhow> is working, thaaanks a lot ;)
06:54:44 <Saizan> np :)
07:13:45 <ddarius> edwardk: Was that Thai restaurant Amy, you, and I went to when I first got here, the Similans?
07:30:12 * hackagebot epubname 2.3.1 - Rename epub ebook files based on meta information  http://hackage.haskell.org/package/epubname-2.3.1 (DinoMorelli)
07:52:17 * hackagebot darcs-fastconvert 0.2.1 - Import/export git fast-import streams to/from darcs.  http://hackage.haskell.org/package/darcs-fastconvert-0.2.1 (PetrRockai)
07:56:16 <sdvvdsvd> is it possible to use unix programms (like ls or s.th.) from haskell? when yes, how?
07:57:15 <dino-> sdvvdsvd: yes! System.Environment, System.Console.GetOpt and writing to stdout, stderr
07:57:38 <dino-> Oh, sorry
07:57:46 <dino-> IRTA "write" instead of "use"
07:58:53 <dino-> But.. yes! System.Cmd, System.Process
07:59:19 <dino-> Possibly also the HSH library
07:59:29 <dino-> sdvvdsvd: ^^
07:59:58 <sdvvdsvd> :module System.Cmd and then rawSystem?
08:00:32 <dino-> sdvvdsvd: Or system, depending on what you need.
08:01:17 <dino-> And if you need more control, things in System.Process will allow you to supply handles for stdin/stdout/stderr
08:01:19 * hackagebot redis 0.10.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.10.1 (AlexanderBogdanov)
08:01:30 <dino-> And do things like waitForProcess
08:02:05 <dino-> Also may need System.Exit for exit code things.
08:03:20 * hackagebot intel-aes 0.1.2.1 - Hardware accelerated AES encryption and RNG.  http://hackage.haskell.org/package/intel-aes-0.1.2.1 (RyanNewton)
08:04:29 <koala_man> how do you replace with regex? google only seems to know about Text.Regex.subRegex, but that's from regex-compat which I guess isn't ideal for new code
08:05:46 <dino-> koala_man: Wait, I use that a lot. Is that bad?
08:06:29 <koala_man> if regex-compat is a compatibility layer for an old api, then surely you're supposed to use something else
08:06:57 <dino-> I just import Text.Regex and use mkRegex, mkRegexWithOpts and subRegex a lot
08:07:49 <dino-> But yeah, maybe somebody should weigh in with what we should be doing and what these various packages are about.
08:09:19 <Saizan> thhe thing is that the old api is sane, while the new one is madness
08:21:59 <ksf> TIL: you can write Foo a => Bar a => instead of (Foo a, Bar a) =>
08:22:07 <Veinor> haha
08:22:32 <copumpkin> uncurry your contexts!
08:22:47 <Ferdirand> huh ?
08:23:20 <ddarius> GHC will let you write contexts quite crazily.
08:23:34 <ddarius> :t Foo a => a -> Bar b => b
08:23:35 <lambdabot> parse error on input `=>'
08:23:46 <ddarius> :t Foo a => a -> (Bar b => b)
08:23:47 <lambdabot> parse error on input `=>'
08:24:24 * hackagebot pandoc 1.8.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8.1 (JohnMacFarlane)
08:26:00 <edwardk> @tell byorgey good catch
08:26:00 <lambdabot> Consider it noted.
08:28:01 <ksf> preflex, nickometer ]d]on[YwkAdrA[ 
08:28:02 <preflex>  ]d]on[YwkAdrA[ is 99.921377% lame
08:28:41 <ksf> has someone figured out whether it's possible to score a perfect 100?
08:29:12 <]d]on[YwkAdrA[> lul
08:30:11 <edwardk> @tell byorgey part of the problem was i swapped from using 'cotraverse' to 'collect' as part of the class.
08:30:11 <lambdabot> Consider it noted.
08:31:10 <ddarius> edwardk: You ever play with Nuprl?
08:31:30 <edwardk> ddarius: googled my way around it, read a bunch of papers, but never used it
08:31:30 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:31:58 <ddarius> lambdabot?
08:32:30 <edwardk> @tell ksf yes. it will soon be fully partitioned into other packages
08:32:30 <lambdabot> Consider it noted.
08:32:59 <ddarius> Ah, everything you said before was a lambdabot command.
08:33:02 <ksf> @tell edwardk cool
08:33:02 <lambdabot> Consider it noted.
08:33:03 <edwardk> yep
08:33:03 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
08:33:20 <edwardk> ksf: hadn't noticed you active on the channel when i finally got around to @messaging ;)
08:33:22 <edwardk> @messages
08:33:23 <lambdabot> ksf said 20s ago: cool
08:33:26 * hackagebot distributive 0.1.2 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.1.2 (EdwardKmett)
08:33:30 <ksf> @messages
08:33:30 <lambdabot> edwardk said 1m ago: yes. it will soon be fully partitioned into other packages
08:37:40 <ksf> while I'm at it, there's no ready-made typeclass hierachry capturing http://hpaste.org/43946/blub , is there?
08:38:14 <edwardk> not that i know of
08:39:10 <edwardk> i don't particularly using type families for things like that when i may want to tie a fixpint or be able to use the property polymorphically, and in the simpler case, there isn't enough structure for it to be all that satisfying
08:39:43 <ksf> well, I don't want to see any "Iteratee [Blub] Blub m a" in my code.
08:39:59 <ksf> or "Iteratee ByteString Word8 m a", for that matter.
08:40:01 <edwardk> *nods*
08:40:12 <edwardk> i've been slowly trying to work up a few classes for dealing with container like things
08:40:21 <edwardk> but they mostly emerged as a side-effect of other stuff i was hacking on
08:40:28 * hackagebot pandoc 1.8.1.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8.1.1 (JohnMacFarlane)
08:40:40 <edwardk> http://hackage.haskell.org/packages/archive/keys/0.2.1/doc/html/Data-Key.html
08:41:01 <edwardk> i used them in representable-functors, adjunctions, and representable-tries
08:41:42 <edwardk> Keyed and Indexable came up naturally in the process of hacking up representable-functors, the others were properties i wanted representable-tries to have
08:43:01 <ksf> head :: (Monad m, Decons c) => Iteratee c m (Element c)   is non-scary enough imnsho
08:43:54 <copumpkin> Decons?
08:44:06 <copumpkin> is that a listifier?
08:44:14 <ksf> a delistifier
08:44:23 <ddarius> Conor's Oregon Programming Languages Summer School talk has an excellent start.
08:44:26 <ksf> http://hpaste.org/43946/blub
08:45:09 <copumpkin> ddarius: the first of the set? (in haskell/SHE)?
08:45:19 <ksf> head is about the only iteratee function that cares about any internals of the chunk type, the rest only cares whether the chunk is null or not
08:45:39 <ddarius> copumpkin: I would assume it's the first.
08:46:13 <ksf> and my goal is to make as general as possible combinators available, so you can freely mix+match 
08:46:21 <copumpkin> I think that's the one where I saw him talk about how transpose ~ getZipList . traverse ZipList
08:46:22 <edwardk> ksf: that looks a lot like the stream class in parsec3
08:46:41 <ksf> ...up to implementing your own iteratees and using it with the provided generic functions.
08:46:58 <ksf> yep, a lot of parsers come with one.
08:47:05 <copumpkin> ksf: is that a good thing, though? :P
08:47:29 <ksf> not really.
08:48:27 <ksf> otoh, when it comes to iteratees over raw byte streams, I'd like to read multi-byte types off the stream, too.
08:49:02 <ksf> but head/tail is the absolute minimum you need to do anything sensible
08:49:28 <ksf> (without specialising your iteratees to the chunk type)
08:51:21 <ksf> http://hpaste.org/43947/iteratee_class
08:51:27 <ksf> that's the typeclass I came up with.
08:52:03 <ksf> modulo the hard-coded exception type I think I got it nailed, but there's just no sane replacement for that Typeable-based adomination.
08:54:23 <ksf> it's one of those cases where everything but an associated type would make the code ridiciously verbose
09:02:47 <harlekin> @pl (\s -> fmap (formatTime defaultTimeLocale ("" ++ s))
09:02:47 <lambdabot> (line 1, column 53):
09:02:47 <lambdabot> unexpected end of input
09:02:47 <lambdabot> expecting variable, "(", operator or ")"
09:02:49 <harlekin> @pl (\s -> fmap (formatTime defaultTimeLocale ("" ++ s)))
09:02:49 <lambdabot> fmap . formatTime defaultTimeLocale . ([] ++)
09:03:04 <harlekin> @pl (\s -> fmap (formatTime defaultTimeLocale ("" ++ s)) getCurrentTime)
09:03:04 <lambdabot> flip fmap getCurrentTime . formatTime defaultTimeLocale . ([] ++)
09:04:51 <dankna> grr
09:04:56 <dankna> hmm
09:07:50 <sgronblo> What is this error even trying to say? "Occurs check: cannot construct the infinite type: a = [a]"
09:08:23 <Botje> sgronblo: it can be pretty obscure, but it means you have something vaguely like b = a : a
09:09:26 <sdvvdsvd> hi, small question, with the FFI i can call c functions, when i make my own functions with a file foo.c how can i include it to the FFI? i just made it with header files like math.h which are in the system and only use foreign import ccall "name"
09:09:53 <Botje> sdvvdsvd: you need to link your foo.c into a library first
09:10:47 <sdvvdsvd> okay, and when i do this, how cann i call my own lib?
09:11:45 <Botje> you need to tell haskell to link your library as well, i think
09:16:26 <byorgey> sgronblo: what the error means is that due to the way the types work out in your code, there is some variable which is required to have both type a and type [a]
09:16:26 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:16:36 <byorgey> sgronblo: but this is not possible.
09:16:44 <ClaudiusMaximus> sdvvdsvd, Botje: ghc can compile C too, so you should just be able to add foreign import and add the .c file to the ghc --make line
09:17:05 <byorgey> sgronblo: unfortunately that might not help track down the error very well.  if you put your code on hpaste.org someone might be able to help you figure out what you are doing wrong.
09:17:06 <dankna> sgronblo: what that specific situation usually means is that you confused a "rest of list" variable with an "item of list" variable.
09:18:00 <ClaudiusMaximus> sdvvdsvd, Botje: if using cabal, there's a "C-sources:" line where you can add it
09:23:32 <ddarius> The first part of Conor's talk is similar (but far more entertaining) than my talk.
09:34:27 <Saizan> which talk?
09:38:58 <ddarius> http://www.cs.uoregon.edu/Activities/summerschool/summer10/curriculum.html
09:39:02 * Saizan wonders if type inference is supposed to be complete for type families
09:39:34 <ksf> it's one-sided for type families
09:39:48 <ksf> that is, kinda like a fundep a -> b without b -> a
09:39:53 <ksf> data families work better.
09:40:06 <Saizan> that's not what i was wondering :)
09:46:22 <Philippa> so I'm finding I don't like video much when someone's handed me a whole vid as a citation for one point or something like that
09:46:26 <Philippa> mostly because you can't skim the things
09:46:41 <Philippa> that said: that particular bunch is stuff I should watch sometime!
09:47:03 <copumpkin> Philippa: yeah, they're pretty fun to watch
09:47:50 <ddarius> Conor's first talk is fantastic.
09:48:21 <ksf> bah. nobody wants to talk with me.
09:48:39 <ksf> mention monads and everybody is suddenly a smart alec, but mention iteratees and everybody shuts up
09:49:05 <ksf> I should call them fuzzy special-purpose ContT's, instead.
09:49:21 <copumpkin> ksf: free monads?
09:49:31 <copumpkin> then you'll get us interested again
09:49:37 <copumpkin> I guess they're not quite free
09:49:40 <ceii_> ksf: you should explain why they're like döner kebabs
09:49:40 <ksf> kinda.
09:49:42 <copumpkin> or maybe they are
09:49:46 <ksf> http://hpaste.org/43947/iteratee_class
09:50:01 <ksf> I based that on my adt version and was able to derive a CPS version straight from it.
09:50:14 <copumpkin> see, my own iteratee type wouldn't be able to fit into that
09:50:15 <copumpkin> :(
09:50:36 <ksf> not even with some tweaking?
09:50:39 <copumpkin> nope
09:50:45 <ksf> what does it look like?
09:50:55 <copumpkin> I wanted a "no bullshit" iteratee with no monads and no failure :P
09:51:06 <copumpkin> since in my application I had neither of those, but still wanted the inversion of control
09:51:26 <ksf> I tried the no failure approach, that is, wrap the whole thing in an ErrorT, but that's only one direction.
09:51:40 <ksf> exceptions need to travel from the iteratees to the enumerators, too.
09:51:49 <copumpkin> yeah
09:51:53 <copumpkin> I just don't need failure
09:52:09 <ksf> well, you could just stub those out.
09:52:31 <ksf> ...and fail to implement MonadException, which provides throw and catch
09:52:56 <ksf> and the monad can be identity, for all I care.
09:53:02 <copumpkin> yeah
09:53:19 <copumpkin> it just complicated things, and I didn't need the generality
09:53:25 <copumpkin> I could go back and add it
09:53:32 <copumpkin> but then again, I probably don't need the class either :)
09:54:20 <ksf> the class fell out of an attempt to get rid of all that adt inspection and construction in the standard iteratees and enumerators
09:55:49 <ksf> actually, I should make SomeException a parameter.
09:56:12 <copumpkin> or an associated type
09:56:45 <ksf> well... yes.
09:58:32 <ksf> two, even, one for every direction.
10:03:47 <ksf> ...otoh that means that I can only have generic iteratees that are pure
10:09:20 <ksf> copumpkin++
10:09:27 <copumpkin> ?
10:09:54 <ksf> my generic functions aren't only more general now but even have clearer signatures
10:10:07 <copumpkin> oh nice
10:10:18 <copumpkin> and I didn't even have to do anything!
10:10:41 <ksf> head :: (Iteratee iter, Monad m, Decons c) => (String -> MsgIn iter -> iter c m (Element c)) -> iter c m (Element c)
10:11:45 <ddarius> It just tumbles off the tongue.
10:12:05 <augur> byorgey: ping
10:12:20 <augur> copumpkin!
10:12:40 <ddarius> Oh noes!
10:12:46 * ddarius is next in alphabetical order.
10:12:56 <copumpkin> lol
10:15:22 <periodic> What is this Iterator/Iteratee thing about anyway? Seems to be all the rage.
10:15:58 <copumpkin> periodic: gives you a fairly neat (for some definitions of neat) to have a consumer that controls when the producer produces things
10:16:18 <copumpkin> it's basically a simple EDSL (the free monad view) that lets you say you're done, and here's a result, or "gimme moar"
10:16:37 <glguy> iteratees?
10:16:42 <periodic> copumpkin: huh. Alright, I'll have to look into it.
10:16:49 <copumpkin> glguy: yep
10:16:58 <periodic> does it sort of "replace" some other common pattern?
10:17:08 <periodic> E.g. if I didn't know what iterators were, what would I be doing instead?
10:17:12 <copumpkin> periodic: it's the main answer we have so far to lazy IO
10:17:21 <copumpkin> it's still not as easy to use as lazy IO, but it's safer
10:17:41 <roconnor> ugh, my proofs on paper are getting unwieldy and I don't quite trust them.  But there is no formalization of F_omega that supports free theorems so I don't think I can easily formalize my proofs. :(
10:17:41 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
10:17:50 <glguy> it suffer from a bit of type proliferation
10:17:52 <copumpkin> roconnor: aw :(
10:18:04 <copumpkin> roconnor: what are you proving?
10:18:12 <periodic> okay, so like when I'm parsing a file previously into a lazy bytestring it would basically give another way of reading the file lazily?
10:18:50 <copumpkin> periodic: I wouldn't say lazily, but with an iteratee you basically construct a computation that requests new chunks from the stream as necessary, or returns something (or an error)
10:18:59 <roconnor> I'm proving that the coalgebra laws for lenses are equivalent to the laws for a monoidal natural transformation for van Laarhoven lenses
10:19:01 <copumpkin> then some producer will take your iteratee and actually make the IO calls for you
10:19:21 <copumpkin> is van Laarhoven twanvl?
10:19:27 <roconnor> yes
10:19:30 <copumpkin> okay
10:19:43 <roconnor> I'm trying to name a computer science term after him :D
10:19:50 <copumpkin> I'm sure he won't object :P
10:19:54 <glguy> periodic: some of the confusion from your question might stem from there being iteratees, enumeratees, and enumerators
10:20:06 <periodic> oh, right.
10:20:15 * copumpkin adopts the O'Connor interpretation of the van Laarhoven lenses
10:20:17 <periodic> glguy: exactly.
10:20:28 <periodic> now I'm confused.
10:20:33 <ksf> periodic, your iteratees are either suspensions of your current parsing state, or a result
10:20:39 <roconnor> copumpkin: perhaps the person who discovered van Laarhoven lenses first might object.  Thought I don't know who they are, if they exist.
10:20:41 <periodic> so what's an enumerator then?
10:20:58 <copumpkin> roconnor: things always get named after people who didn't actually invent them
10:20:59 <ksf> if it's a result the enumerator returns, when it's a suspension the enumerator gives it a chunk of data to process
10:21:30 <ksf> the rest is a proper >>= instance so that one iteratee can eat half a chunk and pass it to the next one.
10:21:30 <periodic> ksf: so iterators and enumerators are related?
10:21:36 <ksf> iteratees
10:21:49 <ksf> iterators are a different kind of thing, most importantly, not a haskell concept.
10:22:04 <roconnor> copumpkin: for the record, the van Laarhoven representation of a lens is (forall f. (Functor f) => (b -> f b) -> (a -> f a))
10:22:07 <ksf> what's called iterator in python are the enumerators.
10:22:08 <Kaidelong> what's the difference between an enumerator and an iterator?
10:22:17 <Kaidelong> and wouldn't an iterator be the haskell concept of a list?
10:22:17 <periodic> ksf: you just used iteratee and enumerator in adjacent sentences.
10:22:26 <ksf> yeah.
10:22:35 <glguy> enumerators enumerate things, produce? iterators are applied to a list of things?
10:22:46 <ksf> iterators iterate, iteratees get iterated.
10:23:01 <ksf> python's got the terminology mixed up, oleg got it right.
10:23:11 <periodic> Are these things in common modules, like Data.Iteratee and Data.Enumerator?
10:23:16 <roconnor> why does j-invariant hate darcs so much?
10:23:21 <periodic> I should just go look at what they actually DO.
10:23:38 <ksf> I recommend reading the original oleg code, and his explanations
10:23:47 <Heffalump> dons: have you heard anything about the next European hackathon?
10:23:58 <Saizan> how was the last paper on GHC's typechecker called?
10:24:04 <periodic> ksf: thanks
10:24:08 <copumpkin> roconnor: j-invariant is a very forceful and opinionated person, from what I've seen. If it weren't hate, it'd be love :)
10:24:58 <copumpkin> roconnor: also, #haskell-behindtheirback
10:25:01 <copumpkin> :P
10:25:16 <Heffalump> who is j-invariant?
10:25:23 <glguy> What's darcs?
10:25:33 <Heffalump> who am I?
10:28:24 <periodic> glguy: ghe VCS?
10:28:27 <periodic> *the
10:28:34 <Kaidelong> So what is this technical concept of an iterator that I'm missing?
10:28:34 <Kaidelong> I've always thought of it in the Java sense
10:28:34 <Kaidelong> in which haskell in haskell you really just call it a "list"
10:29:26 <udoprog> I'm having a problem combining waitForProcess with signal handlers. While waiting for a subprocess the signal handle does not appear to be invoked, the documentation does however state that it will be called later on a separate thread
10:29:49 <Kaidelong> @ty (head .) . drop
10:29:50 <lambdabot> forall a. Int -> [a] -> a
10:30:19 <ksf> udoprog, did you compile with -threaded?
10:30:31 <ksf> my crystall ball tells me that might be the solution
10:31:10 <udoprog> ksf: durr, using cabal, one sec...
10:31:18 <ksf> Kaidelong, like all imperative terminology, it's an underdefined, fuzzy, and, ultimately, broken concept.
10:31:20 <udoprog> so probably not : )
10:31:57 <ksf> the closest definition of iterators that I have is "castrated coroutine"
10:32:24 <udoprog> ksf: hah, thanks, that was easy : P
10:32:55 <Kaidelong> ksf: Actually it's be more "routine" than "co-routine" wouldn't it? Since it is pulled from.
10:32:58 <ksf> #haskell. where people not understanding your problem solve it by hand-waving.
10:32:59 <Kaidelong> it'd*
10:33:20 <ksf> well, the whole yield thing python does.
10:33:22 <Kaidelong> I guess you could think of it as a function with an implicit parameter
10:33:41 <ksf> castrated because you can't send data back the other way.
10:33:47 <Kaidelong> ksf: the concept was around long before python
10:33:54 <Kaidelong> look at the "suspend" keyword in icon
10:34:03 <ksf> I don't know icon
10:36:07 <Kaidelong> actually, with Icon's suspend keyword, you could send data back
10:36:36 <Kaidelong> so I guess those could kind of have been seen as full on coroutines
10:36:42 * roconnor reads "eta" in his download bar as Î·
10:36:43 <ksf> yeah
10:36:56 <ksf> the thing iteratees give you in addition is abstracting over chunk boundaries
10:37:06 <Kaidelong> roconnor: Should be ETA
10:37:12 <ksf> you can do block I/O and not care about it.
10:37:42 * Kaidelong generally thinks that "coroutine" implies a certain inversion of control, but that doesn't seem to be how people usually mean it in the context of things like scheme
10:37:52 <ksf> you can do that with any of the fusion frameworks, too, but those don't give you fine-grained guarantees about when IO is done etc.
10:38:30 <ksf> coroutines are two sequences of computations that can yield to each other.
10:38:43 <ksf> well, two or more.
10:38:51 <ksf> haskell's soft threads are managed coroutines.
10:39:09 <ksf> the difference to full-blown threads is that the latter can get preempted
10:39:23 <ksf> which needs interrup/os support
10:39:30 <siim> @pl cssName arg = (fontName arg) ++ ".css"
10:39:30 <lambdabot> cssName = (++ ".css") . fontName
10:39:40 <systemfault> And kernel threads are slow.
10:40:09 <ksf> well, not in linux, they are not. they're only *slower*
10:40:14 * Kaidelong likes the whole IEnumerable vs IObservable thing Erik Meijir has successfully pushed
10:40:29 <Kaidelong> err
10:40:45 <ksf> linux can do all that "create 1000000million processes/threads and kill them in <1sec" thing
10:40:46 <Kaidelong> or whatever his name was
10:41:17 <ksf> there is, though, of course context switching overhead.
10:42:40 <Tinned_Tuna> Is that a thousand billion create/kills per second? 
10:42:48 <Tinned_Tuna> or have I misread that ?
10:43:01 * ddarius suspects ksf miswrote that.
10:43:09 <systemfault> Yeah, context switching is expensive. afaik
10:43:30 <systemfault> That's what's making kernel thread slow
10:43:42 <Tinned_Tuna> conext switching is expensive, but it is helped by modern hardware...
10:43:44 <Kaidelong> Icon is actually probably one of the nicer imperative languages that were designed. I wonder why it is largely forgotten now
10:43:57 <shachaf> ddarius: What, a trillion threads?
10:44:14 <gwern> @quote
10:44:14 <lambdabot> syntaxglitch says: every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally
10:44:14 <lambdabot> while working on something way more interesting
10:44:22 <Tinned_Tuna> are those all at once, or sequential
10:44:33 <Tinned_Tuna> i.e. create, kill, create, kill ...
10:44:33 <systemfault> I like 3)
10:44:50 <Tinned_Tuna> or create, create, create ... create, kill, kill ... kill. ?
10:44:54 <Kaidelong> same goes for SNOBOL which preceeded it
10:45:19 <keep_learning> hello all 
10:45:29 <Tinned_Tuna> if it's the later, then it could be very expensive, memory wise
10:45:33 <gwern> @quote memory
10:45:33 <lambdabot> tolkad says: haskell isn't even turing complete without infinite memory
10:45:34 <cole> I have a type class called "View" and it has a method called "display." I have something called a ListView and something else called a GridView, both of which implement View's Interface. The problem is that I'd like for display to take different arguments for the GridView than it does for the ListView. Is this possible?
10:45:44 <ddarius> Even simply incrementing a counter from 0 to a trillion would take over a second (quite a lot more than a second actually.)
10:45:49 <applicative> hello keep_learning
10:45:57 <keep_learning> could some one tell me how to get key from a Map for given value
10:45:57 * hackagebot directory-tree 0.10.0 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.10.0 (BrandonSimmons)
10:46:08 <keep_learning> applicative, hello applicative 
10:46:19 <keep_learning> http://en.wikipedia.org/wiki/Baby-step_giant-step
10:46:34 <keep_learning> i am trying to implement this using Map 
10:46:39 <Lemmih> cole: You don't really wanna use a class in that case. Try objects instead.
10:46:40 <Botje> keep_learning: M.lookup
10:46:41 <kmc> cole, is there a good reason for them both to belong to this "View" class?
10:46:49 <kmc> why not just have "displayGrid" and "displayList"?
10:46:49 <Botje> uh, just lookup :p
10:46:59 <cole> You would suggest objects?
10:47:00 <keep_learning> M.lookup takes key and return value
10:47:04 <kmc> cole, Haskell's type classes are quite overused, IMO
10:47:06 <Kaidelong> tolkad's statement up there has nothing to do with "Haskell the programming language"
10:47:25 <keep_learning> i need to check if y is value for any key 
10:47:41 <keep_learning> then i have to return key 
10:47:45 <Tinned_Tuna> keep_learning: with Data.Map, I think that'd be slow...
10:47:48 <keep_learning> other wise keep iterating 
10:47:59 <keep_learning> Tinned_Tuna, yes 
10:48:07 <applicative> @type M.lookup
10:48:08 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
10:48:11 <copumpkin> I want parametrized modules for some things, and type classes for others. Just like I like fundeps for some things and type families for others
10:48:11 <Tinned_Tuna> keep_learning: can you not just go for the key it should be in?
10:48:23 <kmc> cole, don't know what you mean by "objects"
10:48:31 <Botje> keep_learning: you could use assocs and then walk that list
10:48:33 <Tinned_Tuna> or keep two maps, one of k,v and the other of v,k ?
10:48:38 <keep_learning> Tinned_Tuna, i did not get you 
10:48:43 <kmc> if you're looking to use "class" everywhere you'd use an interface in Java, then you're probably overusing it
10:48:51 <kmc> because Java has only one form of abstraction, and Haskell has many
10:48:53 <Botje> keep_learning: if this operation will be frequent, get a bimap
10:48:54 <ddarius> copumpkin: Luckily you can have both.
10:48:57 <cole> kmc: Lemmih used the word
10:49:02 <Tinned_Tuna> keep_learning: is there no way of knowing the key, k, given the value, v ?
10:49:04 <keep_learning> Botje, then list would be great 
10:49:15 <kmc> Haskell doesn't have a specific thing named "objects"
10:49:34 <ddarius> Haskell doesn't have anything named "objects."
10:49:34 <copumpkin> ddarius: except not in haskell :(
10:49:48 <ddarius> copumpkin: What are you talking about?
10:50:16 <keep_learning> Tinned_Tuna, so like imperative language we get key for any given value O(log n) like 
10:50:17 <copumpkin> ddarius: oh, the parametrized modules part
10:50:34 <ddarius> copumpkin: Is easily encoded into Haskell.  Into type classes no less.
10:50:43 <ddarius> Especially with associated types now.
10:50:43 <Lemmih> cole: Data types in Haskell can be used in much a similar way to objects in, say, Java or C#.
10:50:49 <Tinned_Tuna> I would guess that the easiest way to do this is to wrap up two maps to create a bimap
10:50:52 <keep_learning> Botje, Then it would be nice to use List 
10:50:56 <Tinned_Tuna> or , see if Hackage has one already.
10:51:07 <kmc> programming in Haskell by analogy to Java or C# is likely to end poorly
10:51:09 <keep_learning> Botje,  in case which will perform better ?
10:51:14 <keep_learning> Botje, Map or List
10:51:25 <copumpkin> yeah, just as fundeps and type families are encodable (mostly) from one another, but one view is often cleaner than another. Maybe a preprocessor that lets me pretend I have a parametrized module and writes a typeclass for m1
10:51:42 <Tinned_Tuna> keep_learning: if you use a list for it, almost all operations will be O(n)
10:51:43 <keep_learning> Botje, if i have to iterate through Map to get the key for given value 
10:51:43 <ddarius> copumpkin: That may already exist.
10:51:55 <cole> Lemmih: How would I do that in this case? Create a view and create two functions which operate on it, one called "displayList" and another called "displayGraph"?
10:52:02 <copumpkin> I saw a paper by chak about translating between the two
10:52:04 <Tinned_Tuna> where as with a map, given a key, a lookup is O(lg n), as is insertion
10:52:05 <keep_learning> Tinned_Tuna, and  for Map ?
10:52:07 <kmc> data ListView = ...
10:52:10 <kmc> data GraphView = ...
10:52:16 <Tinned_Tuna> it's only the otherway around that it will be O(n)
10:52:22 <ddarius> copumpkin: Him and also an earlier one by Ken Shan.
10:52:25 <copumpkin> ah
10:52:38 <Lemmih> cole: What's a view?
10:52:44 <ddarius> (And a giant one with Stephanie Weirich(?))
10:52:59 <keep_learning> Tinned_Tuna, ok , for given key we can get value in o(log n) but other way is Linear 
10:53:06 <keep_learning> Tinned_Tuna, am i correct ?
10:53:08 <Tinned_Tuna> i.e. with a map, only doing a reverse lookup will be O(n), almost all other operations of importance will be O(lg n)
10:53:33 <Tinned_Tuna> Most likely, I haven't looked into the other way around ...
10:53:35 <ddarius> @hackage bimap
10:53:35 <lambdabot> http://hackage.haskell.org/package/bimap
10:53:36 <keep_learning> Tinned_Tuna, So hashMap will good ?
10:54:21 <Tinned_Tuna> probably
10:54:38 <cole> A View is a class which provides has a "display" method. (a -> String -- like show) The idea is that the graphs implement this display method and thus I can print them to the screen.
10:54:43 <applicative> keep_learning I was looking into the problem and noticed these modules; maybe theyll have something http://blog.haynberg.de/?p=548&lang=en
10:55:00 <kmc> cole, "A view is.... a display method (a -> String)"
10:55:06 <kmc> why do you need that extra layer of indirection
10:55:12 <kmc> type View a = a -> String
10:55:27 <ksf> all your big-Os are flawed.
10:55:44 <Tinned_Tuna> ksf: go on?
10:55:48 <ksf> the only sensible way to measure cost by now is cache misses.
10:56:00 <Tinned_Tuna> ksf: I hate you.
10:56:03 <mauke> shit was so cache
10:56:05 <cole> A View also has an "edit :: Int -> EventKey -> a -> a" method . . .
10:56:11 <kmc> cole, in Java, functions aren't first class, so it's customary to wrap each function in many layers of abstract factory builder XML configuration nonsense
10:56:22 <ddarius> Just pull out PDM.
10:56:24 <kmc> data View a = View { display :: a -> String, edit :: Int -> EventKey -> a -> a }
10:56:40 <kmc> cole, http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
10:56:58 <Tinned_Tuna> keep_learning: I would guess that the best way to get what you want is use two maps
10:57:12 <Tinned_Tuna> let one be m1 which maps from k -> v
10:57:18 <Tinned_Tuna> and m2 which is v -> k
10:57:41 <ksf> kmc, could it be that this applies to extensible-exceptions?
10:57:42 * ddarius is going to do his laundry, take a shower, and then return to watching Conor be entertaining.
10:57:43 <Tinned_Tuna> and then just write your own functions to insert into both, etc. in a sane way
10:57:53 <ksf> finally I know I'm not alone hating them.
10:57:54 <keep_learning> Tinned_Tuna, thanks 
10:57:58 <Lemmih> cole, kmc: Or: data View a = View { display :: String, edit :: Int -> EventKey -> View a }
10:58:07 <kmc> ksf, seems plausible
10:58:18 <kmc> ksf, i don't think the lesson here is "never use existentials with classes"
10:58:28 <Tinned_Tuna> problem is that you use twice the memory for doing anything with them.
10:58:30 <kmc> i think the lesson is "existentials with classes are not the simplest solution"
10:58:42 <kmc> "and are tempting if you come from the world of poorly-expressive OOP languages"
10:59:15 <kmc> ksf, i'm curious what an existential-less extensible exception API would look like
10:59:23 <cole> How do I apply the view to a graph?
10:59:40 <kmc> maybe Haskell should just get extensible variants in the language
10:59:45 <Heffalump> ksf: records aren't extensible, so I don't think it does apply
10:59:55 <applicative> is there more film of conor lecturing?
10:59:58 <kmc> that's the ocaml solution.... the language allows for a single extensible variant, named "exn" or such
11:00:44 <kmc> just like it hard-codes typechecking rules for printf
11:00:52 <kmc> (so does gcc)
11:01:00 * hackagebot list-grouping 0.1.1 - Functions for grouping a list into sublists  http://hackage.haskell.org/package/list-grouping-0.1.1 (BrandonSimmons)
11:01:41 <keep_learning> Tinned_Tuna, i am not expert of haskell but is flip handy here ?
11:02:22 <ksf> kmc, Heffalump, HList/grapefruit-records
11:02:30 * applicative notices that, inevitably Oleg has implemented discrete logarithms in the typesystem
11:02:35 <ksf> we really, really need a sane extensible record system
11:02:41 <kmc> what about TRex
11:03:20 <kmc> maybe if people weren't advised to ignore implementations other than GHC, we'd have TRex and ACIO in GHC by now
11:03:24 <ksf> though as the case may be extensible-exception only needs variadic sums
11:04:12 <ddarius> Tinned_Tuna, keep_learning: You may want to consider that bimap package I already pointed out.
11:04:19 <accel> there are implementations besides GHC?
11:04:25 <accel> I thought GHC = Haskell
11:04:30 <keep_learning> ddarius, ya sure i will 
11:04:30 * ksf must admit ignorance of hugs
11:04:41 <ksf> if it were in uhc, I'd know of it.
11:04:48 <kmc> accel, ;P
11:04:51 <sgronblo> Doesn't haskell wiki have some nicelly formatted function reference for haskell?
11:05:02 <kmc> accel, Haskell is specified by a language standard, not by an implementation
11:05:08 <keep_learning> ddarius,  but some where i read that flip reverse the input order
11:05:11 <kmc> there is Haskell 98 and Haskell 2010 and various older versions (Haskell 1.4 anyone)
11:05:31 <kmc> accel, Haskell implementations include GHC, YHC, Hugs, JHC, and UHC/EHC
11:05:32 <ksf> sgronblo, we have hackage
11:05:38 <ksf> which is full of haddock docs
11:05:50 <kmc> accel, however GHC is by far the most polished one, and is used for the vast majority of real work
11:06:09 <sgronblo> ksf: isnt this some sort of cpan-thing?
11:06:13 <kmc> accel, GHC also implements many features not specified in the standard
11:06:26 <kmc> and so code using those features is not as portable
11:06:30 <ksf> sgronblo, that, too.
11:06:39 <kmc> and the rate of standardization has lagged recently, so much real-world code depends on GHC-only features
11:06:40 <mauke> sgronblo: yes; what were you looking for?
11:06:55 <kmc> accel, i advise people to look at the other implementations not for general use, but for specific purposes and/or ideas/inspiration
11:06:55 <sgronblo> oh wait how did you use the bot here to search for functions that return a for input b?
11:07:16 <kmc> for example the TRex and ACIO extensions i mentioned are from Hugs and JHC respectively and, if included in GHC, would solve specific pain points with real code
11:07:22 <ksf> sgronblo, you might be looking for http://hackage.haskell.org/package/base-4.3.0.0
11:07:22 <mauke> sgronblo: http://www.haskell.org/hoogle/
11:07:29 <ksf> @hoogle Int -> Char
11:07:30 <lambdabot> Data.Char chr :: Int -> Char
11:07:30 <lambdabot> Data.Char intToDigit :: Int -> Char
11:07:30 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
11:08:10 <ddarius> TRex and ACIO aren't omitted from GHC due to laziness.
11:08:22 <kmc> Hugs is still somewhat popular because it's simple and is written in portable C
11:08:34 <ddarius> kmc: Hugs seems pretty dead now.
11:08:38 <kmc> so it's easier to port to other platforms than GHC
11:08:48 <kmc> ddarius, mostly, but it's been ported to iPhone / iPad for example
11:09:03 <ksf> ddarius, which does'nt buy you anything as hugs can't run ghc.
11:09:08 <kmc> (of course, jailbreak-only... it would really be too much to expect to spend $500 on a shiny toy and actually have the right to use it)
11:09:44 <ddarius> kmc: How would Apple make money?
11:09:56 <kmc> what i'd like to see is a portable C interpreter for GHC's bytecode
11:10:02 * hackagebot xmlhtml 0.1.3 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.3 (ChrisSmith)
11:10:19 <kmc> then GHC could ship with a copy of the compiler precompiled to bytecode, which would run on any platform and could itself emit bytecode
11:10:40 <accel> kmc: hmm, I kinda like systems that have one main implementation
11:10:42 <kmc> or, if it knows about your platform, could emit native code including a native-compiled (i.e. faster) copy of GHC itself
11:10:43 <ddarius> I'm not sure there's an external format for GHC bytecode (though it would be relatively easy to add.)
11:10:46 <accel> kmc: I think lots of hobby implemeatntions did scheme in
11:10:59 <ddarius> accel: Scheme is alive and well.
11:11:06 <kmc> this is how ocamlc works
11:11:11 <ksf> kmc, there's llvm
11:11:13 <accel> ddarius: no it's not
11:11:17 <kmc> accel, i disagree.  how did the existence of hobby implementations hurt PLT Scheme?
11:11:23 <kmc> ksf, LLVM bytecode is hardly portable
11:11:40 <kmc> not the way GHC produces it
11:11:52 <ddarius> GHC has a knack for that.
11:12:00 <kmc> it would be better to produce STG-machine bytecode and interpret that
11:12:00 <ksf> yep.
11:12:01 <kmc> as YHC does
11:12:17 <kmc> this is for the slow, compatible path anyway, and it would be easier
11:12:24 <bos> preflex: seen edwardk 
11:12:24 <preflex>  edwardk was last seen on #haskell 2 hours, 26 minutes and 6 seconds ago, saying: ksf: that looks a lot like the stream class in parsec3
11:12:40 <kmc> note that GHCi already runs off of something similar
11:12:42 <ksf> like producing perfectly portable C, but, alas, compiling in constants from the donor system.
11:12:52 <accel> how do I tell lambdabot to send a message?
11:12:54 <ksf> cross-compiling ghc is *very* painful.
11:13:20 <ksf> @tell accell you just @tell it to
11:13:21 <lambdabot> Consider it noted.
11:13:36 <accel> #tell ksf my nick is accel, a single l
11:13:40 <mauke> ksf: you fail at tab completion
11:13:42 <accel> @tell ksf my nick is accel, a single l
11:13:42 <lambdabot> Consider it noted.
11:13:52 <ksf> @messages
11:13:52 <lambdabot> accel said 11s ago: my nick is accel, a single l
11:13:58 <kmc> accel, anyway, Haskell unambiguously has one main implementation, but i think we benefit greatly from the idea that there *is* a standard
11:14:04 <accel> @tell lambdabot @tell lambdabot @tell lambdabot
11:14:04 <lambdabot> Nice try ;)
11:14:08 <accel> lol
11:14:10 <kmc> rather than saying "Haskell is whatever GHC 6.12.3 happens to accept, with all its bugs and features"
11:14:15 <kmc> that way lies Perl
11:14:22 <accel> and python and ruby
11:14:25 <mauke> and php
11:14:29 <kmc> python has a standard, sort of
11:14:36 <kmc> and there are several implementations of Python
11:14:38 <systemfault> Well, ghc is the "standard" :/
11:14:39 <kmc> or closely related languages
11:14:41 * systemfault flees
11:14:50 <mm_freak> @fix (@tell lambdabot)
11:14:51 <lambdabot> Maybe you meant: bid faq ft id thx
11:15:05 <kmc> people do in fact use Jython and Cython for real stuff, and i hear PyPy is getting close
11:15:08 <ksf> @thx
11:15:09 <lambdabot> you are welcome
11:15:20 <accel> > "Hello World"
11:15:21 <lambdabot>   "Hello World"
11:15:24 <kmc> it doesn't hurt that CPython is wretchedly terrible
11:15:28 <kmc> whereas GHC is pretty damn good
11:15:30 <accel> lambdabot: putStr "Hello World"
11:15:40 <accel> > putStr "Hello World"
11:15:41 <lambdabot>   <IO ()>
11:15:49 <accel> is there a way to get lambdabot to just print thigns out w/o the quotes?
11:15:55 <kmc> > text "hi accel"
11:15:56 <lambdabot>   hi accel
11:16:03 <accel> > text "@tell lambdabot @tell lambdabot"
11:16:04 <lambdabot>   @tell lambdabot @tell lambdabot
11:16:07 <mm_freak> :t text
11:16:08 <lambdabot> String -> Doc
11:16:13 <accel> :t Doc
11:16:14 <lambdabot> Not in scope: data constructor `Doc'
11:16:31 <kmc> accel, people have been working on breaking lambdabot for about 6 years
11:16:33 <kmc> just so you know
11:16:36 <mercury^_> > text "> 3+4"
11:16:37 <lambdabot>   > 3+4
11:16:40 <accel> kmc: so it's mostly patched?
11:16:44 <kmc> yep
11:16:47 <mercury^_> Stupid bot. :(
11:16:48 <kmc> not to say there aren't bugs
11:16:50 <kmc> it sometimes crashes
11:16:59 <accel> I think the problem is that there's only one lambdabot here
11:17:02 <kmc> but it's pretty hard to make it do terribly annoying things, or to compromise the host system
11:17:03 <accel> and it doesn't parse it's own output
11:17:08 <mm_freak> mercury^_: that wouldn't work, and it's not because lambdabot detects it
11:17:09 <accel> we need 2 of more bots
11:17:10 <mauke> accel: preflex is another bot
11:17:10 <kmc> accel, the problem is that it prefixes its output with " "
11:17:11 <accel> to make it fun
11:17:18 <accel> preflex: yo
11:17:26 <accel> mauke: how do you use preflex ?
11:17:32 <kmc> preflex, seen accel
11:17:33 <preflex>  accel was last seen on #haskell 6 seconds ago, saying: mauke: how do you use preflex ?
11:17:35 <mauke> preflex: help
11:17:35 <preflex>  try 'help help' or see 'list' for available commands
11:17:44 <accel> preflex: list
11:17:45 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
11:17:46 <kmc> preflex, zdec zdzuzuzuzuzd
11:17:46 <preflex>  ZCode: [zdec, zenc]
11:17:47 <preflex>  $____$
11:19:17 <ion> accel: The issue of â€œtwo bots on a channel, one of which may inadvertently say something that triggers something undesired in the otherâ€ has been dealt with in the IRC RFC by introducing the NOTICE command. The rules are simple: automatons *only* use NOTICE to say things, and automatons are forbidden to trigger stuff from incoming NOTICEs, PRIVMSGs only. Of course, lambdabot violates that rule. :-P
11:19:34 <hvr> http://hackage.haskell.org/package/derive-2.4.2 points to the broken link http://community.haskell.org/~ndm/derive/ ... is there a mirror for it?
11:19:45 <kmc> most bots violate this rule, because many clients render NOTICE in an annoying way
11:19:51 <mm_freak> ion: lambdabot doesn't follow this /recommendation/ in the standard
11:19:57 <kmc> also, who here *isn't* an automaton?
11:20:17 <accel> alright
11:20:21 <accel> I guess in order to make this happen
11:20:28 <accel> I'll have to take part as a bot, unti lI get kicked
11:20:46 <ksf> accel, fix id
11:20:49 <accel> you can now send me commands via "accel: ", which I will ignore
11:21:15 <mm_freak> accel: please ignore this command
11:21:21 <mm_freak> see, you don't ignore commands
11:21:51 <mm_freak> you actually executed my command very well
11:23:11 <kmc> accel, you should write a bot in Haskell
11:23:24 <kmc> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
11:23:44 <Zao> Notices steal attention and look very different in most clients.
11:23:53 <accel> yeah; i want to desig a bot
11:23:59 <accel> that tries to confuse lambdabot
11:24:25 <kmc> cool, as it happens i want to design a bot that gets kicked from #haskell
11:24:28 <kmc> maybe we can work together? ;P
11:24:44 <accel> lol
11:25:37 <mauke> I want to write an irc server that confuses clients
11:25:56 <accel> i.e. randomly sends out ascii goasce?
11:26:00 <accel> *t*
11:26:19 <mauke> no, it should send two pings in the connection registration phase
11:26:39 <mauke> and always tell you that your nick is taken on the first NICK attempt
11:27:00 <mauke> and send packets that don't end with \n
11:27:01 <mafs> it should just route messages to the wrong channels
11:27:12 <mauke> it should still be a working irc server
11:27:18 <accel> it should also randomly op new comers with a certain probability
11:27:41 <mauke> boring
11:28:03 <accel> not at all
11:28:09 <accel> if I had ops, this channel would be very fun right now
11:28:10 <mm_freak> mauke: send a few hundred thousand JOIN commands to the client with different channel names
11:28:30 <mm_freak> that should crash almost every client, likely together with the machine it's running on
11:28:50 <accel> does your sever have that many channels?
11:28:52 <mauke> also boring
11:29:04 <mauke> I don't want to break correctly written clients
11:29:32 <ksf> clients not ignoring such spam are broken
11:29:41 <ksf> this is network programming we're talking about
11:30:02 <mauke> how do you know it's "spam"?
11:30:03 <mm_freak> ksf: nonetheless they are correct
11:30:15 <ksf> unprompted-for joins?
11:30:24 <ksf> I'd accept a couple, but not more
11:30:24 <mauke> happens in reality
11:30:25 <mm_freak> there is nothing wrong with autojoins
11:30:34 <ksf> yeah, but not a hundred or more.
11:30:38 <mm_freak> why?
11:31:07 <mm_freak> many bots autojoin to hundreds of channels by chanserv's autojoin on other networks
11:31:11 <ksf> ...and especially don't accept more joins than the client can handle
11:31:23 <mm_freak> how many joins can the client handle?
11:31:38 <ksf> bots are a different thing
11:31:56 <ksf> but clients for human consumption shouldn't be arsed to join a gazillion channels
11:32:15 <mauke> no, just a few hundred
11:32:15 <ksf> they should ignore netsplit messages, too (which xchat doesn't)
11:33:09 <ksf> ...when the server does something suspicious, protect the user.
11:33:11 <mm_freak> the point is:  that's your view of a security-enhanced client
11:33:22 <ksf> who can always allow, of course.
11:33:24 <ksf> yeah.
11:33:27 <mm_freak> that's a special case of the more general /correct/ client
11:33:45 <mm_freak> a correct IRC client can very well crash the machine, if the server is not trustworthy
11:34:02 <ksf> that's protocol correctness, but not more.
11:34:16 <ksf> the client also has to deal with the machine it's running on
11:34:19 <mauke> protocol correctness is my concern
11:34:59 <mm_freak> ksf: also note that given your definitions of security features, no client on this earth is â€” well â€” security-correct
11:35:27 <mm_freak> so go ahead and be the first to write one =)
11:35:41 <mm_freak> wellâ€¦
11:36:12 <mm_freak> the original "irc" client is, given that it doesn't know about channels
11:36:22 <mm_freak> it just prints whatever comes from the server
11:36:34 <kmc> netcat?
11:36:49 <mm_freak> IRC-pretty-formatted netcat with a command line
11:36:52 <mauke> mm_freak: oh, there's some funky things you can do with escape sequences
11:37:08 * hackagebot FunGEn 0.3 - FUNctional Game ENgine  http://hackage.haskell.org/package/FunGEn-0.3 (SimonMichael)
11:37:33 <mm_freak> mauke: you can also get funky with nicknamesâ€¦  some clients ignore that []\ = {}|
11:38:05 <mauke> mm_freak: how does that cause problems?
11:38:20 <mm_freak> mauke: you can make those clients go crazy with nicklists
11:38:34 <mm_freak> like the same person given with different caps
11:38:43 <mm_freak> jumping around in the nicklist each second
11:38:54 <mauke> huh?
11:39:05 <mauke> the nicklist is static
11:39:45 <mm_freak> virtually all clients never ignore NAMES replies
11:39:59 <mauke> hah
11:40:01 <mm_freak> in fact, you can make the nicklist dance by sending (correct) NAMES replies each second
11:40:16 <mm_freak> without disturbing any functionality
11:45:36 <sgronblo> Where does this x:xs convention come from? I'm not sure I like it
11:45:51 <kmc> oral tradition passed down from the ancients
11:45:54 <kmc> you don't have to use it
11:45:57 <aavogt> do you know what it means?
11:45:57 <kmc> but i'm curious why you don't like it
11:46:17 <kmc> the 's' indicates a plural
11:46:26 <mauke> $x : @x  -- :-)
11:52:42 <keep_learning> hello all, i wrote the program using Bimap but i am getting compilation error 
11:52:42 <MHD0> I am having trouble cabal installing OpenAL
11:52:45 <keep_learning> http://hpaste.org/43950/discretelog
11:53:08 <keep_learning> algorithm is here http://en.wikipedia.org/wiki/Baby-step_giant-step
11:54:05 <navaati> MHD0, are the C OpenAL headers installed ?
11:54:35 <keep_learning> Couldn't match expected type `m a' against inferred type `Integer'
11:54:35 <keep_learning>     In the fourth argument of `recfuN', namely `m'
11:54:35 <keep_learning>     In the expression: recfuN y inv 0 m mp
11:54:35 <keep_learning>     In the expression:
11:54:35 <keep_learning>         let
11:54:36 <keep_learning>           m = ceiling . sqrt . fromIntegral $ p
11:54:40 <keep_learning>           mp = Bmap.fromList [... | j <- ...]
11:54:41 <MHD0> navaati: Not sure, where is cabal's include directory?
11:54:42 <keep_learning>           [u, _, _] = extended_gcD a p
11:54:44 <keep_learning>           ....
11:54:46 <keep_learning>         in recfuN y inv 0 m mp
11:55:22 <navaati> MHD0: which distro do you use ?
11:55:36 <MHD0> navaati: WinXP32
11:56:02 <navaati> ohâ€¦ I forgot this one
11:56:06 <keep_learning> any one ?
11:56:08 <navaati> not my cup of tea, sorry
11:57:12 <MHD0> navaati: Ok, i'll just try an figure out myself.
11:57:29 <Botje> keep_learning: don't paste errors in the channel
11:57:41 <Botje> keep_learning: very probably you get errors because lookupR returns something of type m a
11:57:51 <monochrom> keep_learning: try http://hpaste.org/paste/43950/discretelog_annotation#p43952
11:58:13 <kmc> anyone here ever add an extra import just for haddock's sake?
11:58:15 <keep_learning> Botje, ok, from next time i will keep in mind
11:58:36 <monochrom> long story short: specialize "m" to "Maybe"
11:58:39 <kmc> for example i want to "import qualified Data.ByteString as BS", but in my haddock comments i want to refer to @'ByteString.copy'@ and have that link successfully
11:59:21 <monochrom> and yeah, paste error as comment appended to your file
11:59:24 * hackagebot hmatrix 0.11.0.1 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.11.0.1 (AlbertoRuiz)
11:59:27 <keep_learning> monochrom, thank you
11:59:37 <c_wraith> kmc: import it twice?
11:59:52 <c_wraith> kmc: but the haddoc will just show the text "copy" there anyway
12:00:05 <c_wraith> err, haddock
12:01:23 <kmc> oh?
12:01:24 * hackagebot cmdargs 0.6.8 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.8 (NeilMitchell)
12:01:28 <kmc> then i can just write @'BS.copy'@, cool
12:02:31 <c_wraith> Yeah.  Sometimes I wish I didn't have to mouseover the link to know what module it was talking about.
12:03:34 <kmc> then maybe @ByteString.@@'BS.copy'@
12:03:37 <kmc> sigh
12:03:57 <navaati> how can i do profiling on my code while using cabal to build it ?
12:04:52 <tswett> > map ((sqrt 2 + 1) ^) [1..]
12:04:52 <lambdabot>   [2.414213562373095,5.82842712474619,14.071067811865474,33.970562748477136,8...
12:05:08 <tswett> > drop 6 $ map ((sqrt 2 + 1) ^) [1..]
12:05:09 <lambdabot>   [478.00209204105295,1153.9991334482224,2786.000358937498,6725.999851323218,...
12:05:25 <tswett> Neat, eh?
12:06:41 <luite> navaati: cabal configure --enable-executable-profiling
12:07:17 <MHD0> I just came across a functor definition of "Functor [::]" what is that type "[::]"?
12:07:19 <luite> navaati: unfortunately, cabal cannot automatically install the profiling version of your dependencies
12:07:48 <kmc> MHD0, Data Parallel Haskell arrays
12:08:04 <MHD0> kmc: Cool?
12:08:11 <kmc> it's the type constructor for DPH arrays, the way [] is the tycon for lists
12:08:20 <kmc> [::] Int  === [:Int:]
12:09:06 <navaati> luite, "Could not find module `Prelude.Unicode': Perhaps you haven't installed the profiling libraries for package `base-unicode-symbols-0.2.1.1'?" -> yeah, unfortunatelyâ€¦ is there a way to re-cabal-install it with profiling symbols ?
12:09:39 <luite> navaati: yeah that's the problem I mentioned, you have installed the regular version of your dependencies, but not the profiling one
12:10:18 <ceii_> navaati: set library-profiling to true in your cabal config, and cabal install --reinstall everything you need
12:10:19 <luite> navaati: depending on how many dependencies you have, you can either cabal install --reinstall -p depdendency, for each dependency, manually
12:11:22 <luite> navaati: or you can enable library-profiling by default, nuke your package database (you could remove ~/.ghc and ~/.cabal/lib) and just cabal install your own package again :)
12:11:44 <navaati> but if i reinstall everything with profiling, won't all my haskell programms will suffer of perf penalty ?
12:12:00 <luite> navaati: nope, but it will take twice as long to install each package
12:12:06 <ceii_> noj, it will build profiling libraries in addition to the normal ones
12:12:18 <luite> navaati: since it builds both a regular version, and one with profiling enabled
12:12:32 <navaati> great, no problem then
12:13:29 <navaati> thanks
12:15:30 <tswett> > let plastic = (iterate (\x -> x - (x^3 - x - 1)/(3*x^2 - 1)) 1.3) !! 100 in map (plastic ^) [7..]
12:15:31 <lambdabot>   [7.159191246982879,9.483909204227626,12.563504827719065,16.643100451210508,...
12:15:55 <tswett> Why, those don't look like integers at all.
12:16:03 <tswett> > let plastic = (iterate (\x -> x - (x^3 - x - 1)/(3*x^2 - 1)) 1.3) !! 100 in map (plastic ^) [15..]
12:16:04 <lambdabot>   [67.89711976208679,89.94453379403348,119.15113907296305,157.84165355612026,...
12:16:10 <tswett> Never mind, then.  :P
12:16:23 <augur> anyone super awesome with type theory and algebraic interpretations of logics?
12:30:31 <greap> Is there a saner way to do this? [[a,b,c,d,e,f,g,h] | a<-p, b<-p, c<-p, d<-p, e<-p, f<-p, g<-p, h<-p]
12:30:59 <mauke> all paths
12:31:02 <mauke> sequence
12:31:32 <hvr> + replicate 
12:32:46 <kmc> > sequence $ replicate 3 "abc"
12:32:47 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
12:33:11 <greap> Ah, replicateM n p does it
12:33:31 <greap> Thanks kmc 
12:43:30 <sgronblo> Are "names" defined in "where expressions" available to all function value definitions and all guard "paths" for those functions?
12:43:51 <copumpkin> guards yes, patterns no
12:43:53 <copumpkin> as far as I remember
12:43:54 <c_wraith> sgronblo: they're available within the specific equation
12:44:03 <c_wraith> that includes all guards, but only one equation
12:44:16 <c_wraith> well, all guards *within* that equation
12:44:40 <sgronblo> ah thanks
12:45:32 <sgronblo> Trying to debug the dreaded "occurs check infinite type blah blah" error again
12:49:36 * hackagebot hint 0.3.3.2 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.2 (DanielGorin)
12:50:02 <c_wraith> sweet.  upgrade to ghc 7 imminent at work, with that release
12:51:12 <kmc> woooo
12:51:48 <kmc> sgronblo, do you understand what the error is saying?
12:53:03 * kmc needs to stop obsessively fine-tuning his libraries and release them already
12:53:23 <sgronblo> kmc: not really because the offending row isn't really doing anything, but i think the real error is hiding on some other line
12:53:43 <luite> c_wraith: i'd wait for 7.0.2
12:54:11 <djahandarie> kmc, release it and then obsessively fine-tune it and release it again :D
12:54:36 <dankna> that's what I do.  sometimes if you're really lucky someone else will do the hard work of benchmarking it for you :D
12:54:47 <dankna> (somebody benched direct-fastcgi against the alternatives, haha)
12:54:56 <dankna> (didn't bother to tell me he had done so though!  I found out by doing vanity googling)
12:54:56 <aristid> kmc: just release more often. you can keep fine-tuning obsessively :)
12:55:04 <c_wraith> luite: what particular issues would keep you away from 7.0.1?
12:55:40 <luite> c_wraith: some io manager issue that causes my snap programs to stop working after a few minutes
12:56:03 <Heffalump> I know that we can't build darcs head with 7.0.1 due to an internal error, so I'd also stay clear of it on general quality grounds
12:56:20 <luite> and I had some minor issues with the type inference engine
12:56:21 * shapr hugs Heffalump 
12:56:25 <Heffalump> hi shapr
12:56:39 <shapr> hiya Heffalump 
12:56:40 <glguy> start thinking about GHC 7 when it is incorporated into the Haskell Platform release
12:56:47 <luite> all bugs I encountered have already been fixed in the latest 7.0 snapshots
12:57:09 <earthy> yay, snapshots for production code
12:57:12 <monochrom> when is Haskell Platform released? :)
12:57:13 <earthy> *ahem*
12:57:27 <luite> earthy: for development in my case :)
12:57:40 <c_wraith> honestly, I think the platform is something to be avoided
12:57:40 <luite> I expect 7.0.2 to be released when it's ready for production :p
12:57:43 <Heffalump> monochrom: a couple of weeks I think, it's stalled on GHC 7.0.2 and a cabal-install update
12:57:55 <monochrom> good idea to wait for ghc 7.0.2
12:57:59 <Heffalump> yeah
12:58:08 <monochrom> ok I won't press then!
12:58:09 <earthy> well, I really prefer developing on the same environment as that provided in production
12:58:26 <monochrom> (was thinking it planned to go with 7.0.1)
12:59:26 <monochrom> there is a lambdacat of simon marlow cat "fixed in HEAD, kthxbye" :)
13:00:00 <c_wraith> well.  We're already using patched versions of cabal and cabal-install...
13:00:00 <luite> hehe that's quite appropriate for the 7.0.1 release ;p
13:00:10 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#965006902_kWLvY
13:02:45 <dankna> bwahaha, I love the one in the shower that's "trapd in IO monad - plz help"
13:03:11 <monochrom> yeah that was one of the most beloved. so cute. :)
13:04:05 <ion> Î»Î¿Î»cats
13:04:22 <aristid> @quote lolcat
13:04:22 <lambdabot> silver says: by the way, in android sdk "adb lolcat" equals to "adb logcat" (which prints out system log from the phone)
13:04:41 <kmc> not Î»Ï‰Î»?
13:05:09 <ion> kmc: I donâ€™t know Greek enough to say whether omicron or omega is the right letter there. That is to say, at all. :-P
13:05:13 <kmc> likewise
13:05:56 <kmc> Î’ÏÎµÎºÎµÎºÎµÎºÎ­Î¾ ÎºÎ¿Î¬Î¾ ÎºÎ¿Î¬Î¾
13:08:39 <pedro3005> http://paste.pocoo.org/show/337920/ what is the complexity of primeFactors?
13:11:00 <ray> omicron
13:11:38 <luite> pedro3005: how do you describe the size of your input? it's obviously an exponential time algorithm if you consider the number of bits to encode n
13:12:22 <pedro3005> luite, what do you mean?
13:12:23 <luite> or at least exponential
13:13:03 <monochrom> if n's prime factorization is p*q*r (say), your algorithm takes p+q+r steps.
13:13:27 <monochrom> or rather p+q+r divisions
13:13:37 <ray> the way to remember omicron vs omega is one is o-micron (short o) and one is o-mega (long o) (but they are the same in modern greek anyway)
13:14:39 <luite> yeah, and if your input size is n bits, then it could take 2^n divisions in the worst case
13:15:22 <monochrom> and to make things worse, each division is like (log n)^3 smaller steps
13:16:43 <pedro3005> hm
13:16:59 <pedro3005> yeah 2^n division but each division calls leastFactor
13:17:04 <pedro3005> divisions*
13:17:18 <pedro3005> leastFactor is O(n) but the n varies significantly with each division
13:17:34 <luite> nah the worst case of it's a prime number, and everything is spent within leastFactor
13:18:01 <pedro3005> wouldn't that be the best case?
13:18:27 <luite> no, the best case would probably be a power of two
13:18:28 <pedro3005> if n is prime, then it'll take n operations
13:18:44 <pedro3005> actually, n - 1, but that doesn't matter
13:18:48 <luite> pedro3005: yeah that's bad, since that's exponential time
13:19:02 <pedro3005> exponential? it's linear
13:19:04 <luite> pedro3005: since your input size is only log(n)
13:19:12 <pedro3005> oh, hm
13:19:26 <pedro3005> what do you mean, input size?
13:19:34 <pedro3005> ah, I see
13:19:41 <monochrom> common mistake to look at "n" and declare "linear time"
13:19:56 <Clex> I can't compile this code http://pastebin.com/8ST4n4ry which comes from Haskell Wiki. It does not link. Does anyone have an idea?
13:20:04 <luite> pedro3005: there are actually polynomial time primality testing algorithms
13:20:15 <luite> deterministic ones
13:21:07 <pedro3005> luite, but this isn't primality testing, it's factorization into primes
13:21:20 <luite> yeah that's more difficult :)
13:21:28 <remy_o> maybe factorisation has been also done
13:21:40 <remy_o> but polynomial algorithms have no concrete uses
13:21:56 <c_wraith> remy_o: that's the most confusing thing I've ever heard
13:22:02 <monochrom> no known polynomial time factorization yet. but we have "subexponential" ones.
13:23:55 <ray> it's O(0) because i'm never going to run it
13:24:24 <gienah> hi slyfox, ltk, leksah-server and leksah build with haddock and cabal libs, which meant with ghc 6.12.3 they need to build with cabal <1.9 on my box which has cabal 1.10
13:24:37 <gienah> oops wrong channel
13:24:45 <monochrom> heh
13:26:04 <navaati> Clex : it seems that there is a space at the begining of each line of your source code
13:26:37 <HJvT> @monochrom: it compiles for me; maybe a configuration error?
13:26:37 <lambdabot> Unknown command, try @list
13:27:29 <Clex> navaati: sorry, c/p fail. :)
13:27:40 <Clex> But you can remove it, it still does not link.
13:27:50 <Clex> s/it/them/
13:28:10 <navaati> it works for me
13:28:23 <monochrom> "it" = ?
13:28:35 <navaati> the source Clex pasted
13:28:54 <navaati> what compilator do you use ?
13:29:01 <navaati> s/what/which/
13:29:31 <Clex> ghc
13:29:50 <Clex> The Glorious Glasgow Haskell Compilation System, version 6.12.3
13:30:06 <navaati> Clex: what is the error ?
13:30:39 <monochrom> paste error message verbatim
13:30:48 <HJvT> monochrom: John's currency: Just "Euro"
13:30:48 <HJvT> Pete's currency: Nothing
13:30:55 <Clex> A lot of errors like :
13:30:55 <Clex> (.text+0x1fa): undefined reference to `containerszm0zi1zi0zi1_DataziMap_lookup_closure'
13:31:13 <mauke> --make
13:31:19 <monochrom> eh? it is not my program or my compiler error
13:31:46 <ion> clex: Btw, thereâ€™s some strange usage of parentheses in that code, although they donâ€™t cause an error. Please see the hlint messages in http://hpaste.org/43955/foo
13:31:56 <HJvT> Sorry it was somebody else program
13:32:02 <Clex> Thanks mauke, it seems to work.
13:32:47 <kmc> ghc --make is almost always the answer to linker errors
13:32:54 <kmc> it's the default mode in GHC 7
13:33:08 <kmc> in fact if you are invoking ghc by hand, you almost always should use --make
13:33:27 <aristid> even cabal build uses ghc --make, i think
13:33:31 <Clex> Okay, didn't know. Thanks guys.
13:33:43 <kmc> aristid, yeah, although it also passes the -package args explicitly iirc
13:35:15 <pedro3005> luite, what is a deterministic polynomial time primality checking test?
13:35:23 <pedro3005> I mean, which?
13:35:27 <pedro3005> I looked at wikipedia, can't find it
13:35:46 <kmc> http://en.wikipedia.org/wiki/AKS_primality_test
13:36:46 * hackagebot DRBG 0.1.3 - A deterministic random bit generator (aka RNG, PRNG) implementing DRBGs from NIST SP 800-90  http://hackage.haskell.org/package/DRBG-0.1.3 (ThomasDuBuisson)
13:39:38 <pedro3005> 1. If n = a^b for integers a > 0 and b > 1, output composite.
13:39:42 <pedro3005> how do I check this?
13:40:12 <Krimpet> Hello; I'm trying to get parallelism working in Haskell. I sprinkled calls to `par` to indicate what could be calculated in parallel, and compiled with the ghc -threaded option, but +RTS -s is telling me "SPARKS: 0 (0 converted, 0 pruned)". Anyone know why the sparks don't seem to be recognized?
13:40:33 <c_wraith> Krimpet: are you using -N ?
13:40:41 <gwern> @quote blod.*god
13:40:41 <lambdabot> No quotes match. It can only be attributed to human error.
13:40:47 <gwern> @quote blood.*god
13:40:47 <lambdabot> No quotes match. Wrong!  You cheating scum!
13:40:50 <Krimpet> c_wraith, yes, I've tried -N, -N2, etc.
13:41:09 <c_wraith> Krimpet: are you using pseq anywhere?
13:41:16 <Krimpet> c_wraith, no.
13:41:45 <gwern> @quote lamprey
13:41:45 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
13:41:49 <Cale> pedro3005: for any given value of a >= 2, there will not be so many values of b to check
13:42:09 <Cale> pedro3005: So I think it means just to do a brute-force search.
13:42:10 <c_wraith> Krimpet: That's probably why..  ghc determined that because of the lack of pseq, nothing was being saved by using a spark
13:42:11 <kmc> Krimpet, the fact that no sparks are even being created indicates that your calls to "par" are not being evaluated
13:42:26 <pedro3005> Cale, up to ceil(n ^ 1/a) , right?
13:42:38 <Cale> yeah
13:42:38 <kmc> i would think that the common par-without-pseq mistake would result in lots of pruned sparks
13:42:47 <kmc> but maybe they would get pruned at compile time?
13:43:05 <Cale> hmm
13:43:29 <Krimpet> Ah. Here's an example of what my code looks like right now: http://hpaste.org/43956/par
13:43:41 <kmc> Krimpet, the idea there is that if you say Â«a `par` (a+b)Â» then it's somewhat likely that the (+) will be evaluated first, forcing 'a' in that thread, and by the time another thread gets to the 'a' spark, it's already under evaluation
13:43:59 <kmc> Krimpet, so instead you'd say Â«a `par` (b `pseq` (a+b))Â»
13:44:17 <Cale> pedro3005: There is probably a better way to do that actually.
13:44:26 <Krimpet> kmc, in my code above, where would pseq fit?
13:44:27 <kmc> (pseq x y) has the same denotational semantics as  (seq x y) but makes the more precise operational guarantee that x will get evaluated before y
13:44:32 <Cale> pedro3005: The paper says it's possible to do in O~(log^3(n))
13:44:36 <kmc> thus forcing the other thread to work on b before it gets a change to make a fizzle
13:45:07 <Cale> [vzGG99] Joachim von zur Gathen and Jürgen Gerhard. Modern Computer Algebra. Cambridge University Press, 1999.
13:45:18 <Cale> ^^ the reference it gives for that fact
13:45:25 <Cale> hmm
13:45:51 <pedro3005> Also not sure how to do
13:45:59 <pedro3005> Find the smallest r such that o_r(n) > log^2(n).
13:47:29 <Cale> From the paper: "In step 2, we find an r with o_r(n) > log^2 n. This can be done by trying out successive values of r and testing if n^k /= 1 (mod r) for every k <= log^2 n.
13:47:50 * hackagebot DRBG 0.1.4 - A deterministic random bit generator (aka RNG, PRNG) implementing DRBGs from NIST SP 800-90  http://hackage.haskell.org/package/DRBG-0.1.4 (ThomasDuBuisson)
13:48:05 <Cale> For a particular r, this will involve at most O(log^2 n) multiplications modulo r, and so will take time O~(log^2 n log r).
13:48:26 <pedro3005> what paper? do you have a link?
13:48:39 <Cale> The one linked by the wikipedia article
13:48:44 <Cale> "PRIMES is in P"
13:48:45 <Krimpet> I have four computations I'd like to run in parallel; should I use par on three and seq on the last?
13:48:49 <Cale> (the famous paper :)
13:49:40 <Saizan> Krimpet: better if it's pseq
13:49:54 <Krimpet> Saizan, so, pseq on the last?
13:50:48 <Feuerbach> Does -ddump-simpl show the code before or after applying the RULES?
13:50:55 <kmc> after, i believe
13:51:00 <kmc> there's also an option to tell you what rules fire
13:51:05 <kmc> i believe ghc-core will invoke that for you
13:51:12 <Krimpet> All four computations can be executed in whatever order.
13:51:26 <kmc> Krimpet, of course -- they're pure Haskell evaluation, no?
13:51:45 <kmc> par is for parallel evaluation of expressions -- if you want parallel execution of IO actions, there's a whole other system
13:51:53 <Krimpet> kmc, yes. I'm confused by what seq is actually supposed to do.
13:52:02 <Krimpet> I'm not using IO here, BTW; all pure.
13:52:05 <kmc> in this case you mean?
13:52:37 <Krimpet> Yes. It sounds to me like a `seq` b is supposed to ensure that a is executed before b?
13:52:44 <kmc> s/executed/evaluated/
13:52:50 <kmc> and seq doesn't guarantee that, but pseq does
13:53:11 <kmc> (execution is what happens to IO actions; evaluation is what happens to expressions (which might evaluate to IO actions, but that's irrelevant)
13:53:15 <kmc> )
13:53:20 <Krimpet> Right, evaluation is what I mean.
13:53:38 <kmc> the expression Â«a `par` (b `pseq` (a+b))Â» will create a "spark" for 'a', which is just a note to maybe later evaluate 'a' in parallel if there's a core free
13:53:51 <kmc> and then the evaluating thread goes on to evaluate (b `pseq` (a+b))
13:53:56 <kmc> the point of pseq is to keep that thread busy for a while
13:54:07 <kmc> if you just  write Â«a `par` (a+b)Â»
13:54:07 <Saizan> seq is defined a way that the only guarantee is that a will be evaluated before the whole (a `seq` b) expression is, it doesn't guarantee much about b
13:54:09 <Cale> seq is defined by two equations:  seq _|_ y = _|_  and  seq x y = y  otherwise.
13:54:16 <kmc> you make a spark for 'a', and then immediately evaluate (a+b)
13:54:24 <kmc> and evaluating (a+b) is going to force evaluating 'a'
13:54:25 <Feuerbach> kmc: well, it tells me that "++" has fired, but I don't see it's effect (i.e. (++) is still there)
13:54:27 <Cale> Where _|_ is a symbol which represents nontermination or failure
13:54:32 <kmc> and if that happens before the spark gets used, then the spark fizzles
13:54:35 <Saizan> s/about b/about the order relative to b/
13:54:45 <Krimpet> Basically, I just want to evaluate a, b, c, and d in parallel, and then evaluate (e a b c d).
13:54:50 <kmc> because you can't do speculative parallel evaluation of something that's already being evaluated elsewhere out of necessity
13:55:07 * Heffalump sends a patch in case it's useful
13:55:14 <Heffalump> oops
13:55:15 <kmc> Krimpet, do you understand my explanation of why pseq is needed?
13:55:23 <kmc> Krimpet, a `par` b `par` c `par` d `pseq` e a b c d
13:55:32 <kmc> but i wonder if you'd rather be using Control.Parallel.Strategies
13:55:48 <Cale> Thus, when evaluating seq x y, the compiler just has to ensure that x is evaluated (in order to ensure that it's terminating) before allowing the result of evaluating y to become available to whatever is pattern matching this expression.
13:55:59 <Cale> It might evaluate y first, then x, then result in y
13:56:00 <Krimpet> kmc, I tried that, but I'm still getting "SPARKS: 0"
13:56:07 <kmc> ok
13:56:09 <Cale> Or it might evaluate x first, then y, and result in y
13:56:13 <kmc> clearly something else is wrong then
13:56:21 <kmc> are you sure the call to par is even being forced?
13:56:26 <kmc> try throwing a Debug.Trace.trace around it
13:57:59 <Cale> What kmc wrote will evaluate a, b, and c in parallel with (evaluating d and then e a b c d)
13:59:30 <Cale> If d is really quick to evaluate, and if e pattern matches its parameters early on, then the worker thread which is evaluating e a b c d might be forced to evaluate a, b, and c itself, rather than allowing the sparks to complete on another processor.
13:59:35 <Cale> But that's sort of unlikely
14:00:19 <Cale> (and if the evaluation of a, b, or c has already started, the e a b c d worker will wait.
14:00:20 <Cale> )
14:01:23 <Cale> Krimpet: You are building with -threaded and running the program with +RTS -n2 or something?
14:01:39 <Krimpet> Cale, yes.
14:01:41 <Cale> er, -N2
14:01:50 <Krimpet> Yep, -N2.
14:02:31 <Krimpet> kmc, hmm, I've never used Debug.Trace.trace - how would I use it here?
14:02:44 <Cale> Is kmc's concern possible? Could it be that this whole result isn't even being used in some way?
14:03:00 <Cale> Is the function e certain to use all its parameters?
14:03:49 <kmc> Krimpet, (trace "foo" x) is equivalent to x, except it will also print "foo" when x is evaluated
14:03:59 <kmc> intended as a quick hackish way to get debug output
14:04:11 <kmc> but it also lets you observe precise evaluation order
14:04:14 <Saizan> try some parentheses too: (a `par` b `par` c `par` d) `pseq` e a b c d
14:06:16 <pedro3005> is this a good implementation of euler's totient function?
14:06:19 <pedro3005> phi n = length $ filter ((== 1) . (gcd n)) [1..n]
14:06:29 <Krimpet> Cale, e is a constructor for a record data type in this case, actually; the members of at least some the values created should be accessed at some point.
14:06:44 <pedro3005> > let phi n = length $ filter ((== 1) . (gcd n)) [1..n] in phi 9
14:06:44 <Cale> pedro3005: It's correct, but very inefficient
14:06:46 <lambdabot>   6
14:06:49 <Ferdirand> pedro3005: no, it's very slow
14:06:50 <Krimpet> Saizan, parentheses don't seem to work.
14:07:21 <pedro3005> how to do it right?
14:07:23 <Cale> Krimpet: oh, in that case, it will not demand the evaluation of any of the 4 parameters
14:07:40 <remy_o> pedro3005: you would have to compute prime factors of n 
14:08:06 <remy_o> your phi is in O(n log n)
14:08:28 <Cale> Krimpet: Unless the data constructor is strict in those parameters.
14:08:43 <Krimpet> Ohh.
14:08:57 <remy_o> pedro3005: phi(n) is n times (product of all (1-1/p)) for primes p dividing n 
14:08:58 <Cale> But that should be okay, I think
14:09:07 <Cale> hmm
14:09:14 <Cale> No, maybe it isn't okay
14:10:07 <Cale> Because by the time you're evaluating this expression, you'll be pattern matching on that constructor, and it might be a bit late to start doing things in parallel.
14:10:29 <Cale> I don't know, it might be okay sometimes.
14:12:33 <pedro3005> remy_o, but won't 1/p lose precision?
14:13:06 <Cale> pedro3005: Not if you use rational numbers
14:13:11 <Krimpet> By the way, I wrapped the entire block of `par`s and `pseq`s in a trace, but the trace string isn't being printed, it seems.
14:13:20 <Cale> You shouldn't use floating point numbers for these sorts of things anyway
14:14:21 <Cale> Krimpet: Then the whole expression isn't being evaluated by your program
14:15:00 <Cale> (you can't speed that up!)
14:15:30 <kmc> if this is going into a record, maybe you're never evaluating that particular record field?
14:15:46 <Krimpet> Cale, nevermind, I surrounded just one of the values being passed to seq, and it is being printed.
14:16:04 <Krimpet> kmc, at least some of the records' fields should be accessed.
14:16:15 <Krimpet> The record in question is a quadtree.
14:16:34 <Cale> If  (trace "x" a) `seq` b prints something, then so should  trace "x" (a `seq` b)
14:17:22 <Krimpet> Wait, my mistake.
14:18:43 <Krimpet> It changed because I changed the input to the whole function elsewhere. :p
14:18:46 <pedro3005> @src rem
14:18:46 <lambdabot> Source not found. Sorry.
14:18:55 <pedro3005> why doesn't it find the source?
14:19:10 <kmc> because @src is a lookup in a flat text file that ships with lambdabot
14:19:17 <kmc> it has nothing to do with the actual haskell code installed
14:19:59 <pedro3005> so @src isn't how it's actually implemented?
14:20:08 <kmc> nope
14:20:14 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
14:20:17 <kmc> these all have source links
14:20:20 <kmc> as do the packages on hackage
14:20:21 <Krimpet> Yes, the problem was that the records' fields weren't being evaluated after all - perhaps GHC was optimizing something away with the inputs I gave it.
14:20:28 <Ferdirand> rem is natively implemented anyway
14:20:34 <lpsmith> alternatively,  if you have the prime factorization [(p0,k0),(p1,k1)...]  then phi = product . map (\(p,k) -> (p-1) * p^(k-1))
14:20:41 <kmc> Ferdirand, what do you mean?
14:20:48 <lpsmith> no rational or real arithmetic needed
14:20:53 <Krimpet> Thanks for all the help! :)
14:21:02 <Ferdirand> kmc: for integers, it uses the rem from gmp iirc
14:21:03 <lpsmith> pedro3005, ^^^^
14:21:04 <kmc> rem is in the Integral type class; it can have a different implementation for each type
14:21:15 <kmc> Ferdirand, sure, but there's still Haskell source in GHC.Num or something to make that happen
14:21:27 <Bynbo7> @src Integer rem
14:21:27 <lambdabot> Source not found. There are some things that I just don't know.
14:23:25 <kmc> ("GHC Haskell" source if you want to be pedantic like me, since it involves unboxed types and such)
14:24:33 <pedro3005> huh.. is this the whole source for Prelude? http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/Prelude.html
14:24:55 <kmc> yep pedro3005, it's mostly imported from elsewhere
14:25:07 <kmc> ghci's ":i" will tell you where something is really from
14:25:18 <kmc> of course it's not required to implement Prelude this way, but it's how GHC does it
14:25:31 <kmc> and i think ~every other Haskell compiler, since they kind of share the standard library files
14:25:56 <navaati> are there leksah users here ?
14:26:40 <pedro3005> oh cool
14:27:18 <pedro3005> where is the source for GHC.Num ?
14:27:40 <kmc> inside the GHC source tree for one
14:27:48 <kmc> don't know if it's hyperlinked online somewhere
14:29:19 <dino-> Here, has link to source: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#t%3ANum
14:29:30 <kmc> haskell is like sausages, if you like the result you don't want to see how it's made :)
14:30:18 <dino-> Er, and the recent version (6.12.3, base 4.2.0.2): http://www.haskell.org/ghc/docs/6.12.3/html/libraries/base-4.2.0.2/Prelude.html#t%3ANum
14:30:42 <dino-> pedro3005: source for Num ^^
14:30:44 <edwardk> kmc: simon marlow must have an unusually strong stomach ;)
14:30:51 <kmc> no kidding
14:31:10 <dschoepe> Can I construct coproducts in (â„•, â‰¤) by taking inl = inr = id? This should work since there's always at most one arrow between a and any other object, right?
14:32:29 <Saizan> the coproduct is the max of the two elements
14:32:34 <Tomsik> *exatly* one arrow
14:32:43 <Tomsik> to satisfy definition
14:33:01 <Saizan> and inl and inr are the only arrows between each element and the max of them
14:34:20 <Saizan> the id arrow only witnesses the reflexivity of <=
14:35:05 <copumpkin> product is glb, coproduct is lub
14:36:14 <dschoepe> Okay, I see where I went wrong, I only checked if one half the diagram commuted :)
14:36:38 <doserj> dschoepe: inl = inr = id doesn't even type-check: inl:: a -> a :+: b versus id:: a -> a
14:37:26 <Saizan> it'd typecheck if A + B = A = B :)
14:37:55 <doserj> yes, which it isn't (in general)
14:38:02 <jeffwheeler> The `cabal ghci' haskell-proposal seems strange to me. Isn't cabal intended to be compiler-independent?
14:38:13 <jeffwheeler> Do the other compilers have interpreters?
14:38:44 <jeffwheeler> (Here's the proposal on reddit: http://www.reddit.com/r/haskell_proposals/comments/fkqp1/cabal_ghci/)
14:40:09 <pedro3005> :i foldl says it's from Data.List
14:40:15 <pedro3005> er
14:40:18 <pedro3005> GHC.List
14:40:47 <pedro3005> but I couldn't find foldl in http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/Data-List.html
14:42:02 <doserj> errm, yes? it is in http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/GHC-List.html after all...
14:43:39 <pedro3005> oh, i missed that
14:43:41 <pedro3005> sorry
14:49:52 <pedro3005> how does this work?
14:49:54 <pedro3005> repeat x = xs where xs = x : xs
14:50:29 <Peaker> pedro3005, that is equivalent to  repeat x = x : repeat x           (except in ghc the former is more efficient)
14:50:34 <companion_cube> fix (1:)
14:50:37 <companion_cube> > fix (1:)
14:50:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:50:54 <pedro3005> Peaker, I know, but I can't see why it works
14:50:55 <Peaker> pedro3005, you can read this definition:   repeat x = x : repeat x        for understanding it, and then see how the other is equivalent to it
14:50:59 <mauke> pedro3005: circular list
14:51:22 <mauke> Peaker: the xs = x : xs version is easier in that it doesn't require lazy evaluation
14:51:55 <Peaker> mauke, I guess. I find it a bit harder for some reason
14:51:57 <Rotaerk> xs = x : xs works *because* it's lazily evaluated
14:52:00 <kmc> pedro3005, why shouldn't it work?
14:52:05 <mauke> Rotaerk: no
14:52:11 <pedro3005> xs isn't defined
14:52:14 <kmc> yes it is
14:52:17 <kmc> let and where are recursive
14:52:23 <mauke> pedro3005: 'xs = ...' defines xs
14:52:34 <kmc> > let fact 0 = 1; fact n = n * fact (n-1) in fact 5
14:52:35 <lambdabot>   120
14:52:37 <TTimo> it's still circular no matter what .. the only way you get out of it is because it's lazy
14:52:37 <kmc> ^^^^ recursive "let"
14:52:39 <Peaker> pedro3005, you're allowed to use definitions above/below/same-line --- that forms a recursion
14:52:51 <mauke> TTimo: then why does it work in C?
14:53:12 <pedro3005> well yes I understand recursion
14:53:14 <Rotaerk> pedro3005, xs = x : xs = x : (x : xs) = x : (x : (x : xs))) = ...
14:53:30 <Peaker> pedro3005, so the list    repeat x    is just (:) between x and the recursively applied (repeat x)
14:53:34 <pedro3005> oh yes, ha, makes sense
14:53:37 <pedro3005> thanks
14:53:39 <TTimo> mauke: well same, the compiler understands a forward, circular definition for C types
14:53:52 <mauke> struct node { int data; struct node *next; }; ... struct node xs = { x, &xs };
14:53:55 <kmc> pedro3005, "let" / "where" blocks basically define graphs of nodes and edges
14:53:59 <remy_o> @pl \x -> xs where xs = x:xs 
14:53:59 <lambdabot> (line 1, column 19):
14:53:59 <lambdabot> unexpected "="
14:53:59 <lambdabot> expecting variable, "(", operator or end of input
14:54:12 <Peaker> pedro3005, instead of actually re-applying "repeat x" in a recursion, the "trick" is to re-use the exact same value we're now returning, which is operationally more efficient
14:54:18 <remy_o> @pl \x -> let xs = x:xs in xs
14:54:18 <lambdabot> fix . (:)
14:54:28 <kmc> pedro3005, if you've seen the little cons-cell diagrams from SICP or the like
14:54:40 <kmc> then you can imagine making the "tail" part of the list cell point back at that same cell
14:54:47 <kmc> that's how you make an infinite / circular list
14:54:55 <kmc> and in Haskell, those arrows can point at blocks of unevaluated code too
14:56:59 <mm_freak_> mauke: struct node { int *data; struct node *next };
14:57:14 <mauke> mm_freak_: why?
14:57:37 <mm_freak_> mauke: because this only works, because it's lazily evaluatedâ€¦  what you're doing:  you're just simulating thunks in haskell
14:57:49 <mauke> what?
14:58:03 <mauke> I'm not simulating thunks
14:58:08 <mauke> my version works
14:58:14 <mauke> making data a pointer changes nothing
14:58:26 <mm_freak_> mauke: do the same with [0..]
14:58:36 <mauke> impossible (in Haskell)
14:58:53 <mm_freak_> what do you mean?
14:59:14 <mauke> it can't be done
14:59:43 <Peaker> mauke, it can in some instances of Num/Enum :)
14:59:55 <mauke> hah
15:00:12 <mm_freak_> mauke: i mean, express [0..] in C
15:00:17 <mm_freak_> using your linked list approach
15:00:36 <mauke> that's not "the same"
15:00:37 <Peaker> mm_freak_, infinite non-circular lists do "need" laziness in this sense
15:00:41 <mauke> [0 ..] isn't a circular structure
15:00:53 <Peaker> mm_freak_, circular lists don't "need" laziness, just a circular reference
15:01:00 <mm_freak_> well, it is, but not necessarily a generic linked list
15:02:44 <mm_freak_> struct node { int data; struct node (*next)(); }  /* when cheating is allowed */
15:02:52 <mm_freak_> struct node { int data; struct node (*next)(int); }  /* when cheating is not allowed */
15:02:53 <kelvie_> Are there any xml parsers that don't use up gigs of memory parsing 20M XML files?
15:03:16 <mauke> mm_freak_: why an int parameter?
15:03:29 <mm_freak_> mauke: because otherwise you need closures, which C doesn't have
15:03:48 <mauke> sure it does, just build them
15:03:52 <mauke> a closure is a tuple
15:04:06 <kelvie_> I've tried HXT/xpath and haxml..
15:04:06 <Peaker> mauke, well, I guess he meant for the "int" to be the second component in that tuple
15:04:18 <Peaker> though "int" is a very unconventional choice for it
15:04:46 <mm_freak_> mauke: by that logic, C also has OOP support, lambdas and dependent types ;)
15:06:57 <edwardk> preflex: xseen byorgey
15:06:57 <preflex>  byorgey was last seen on freenode/#haskell 5 hours, 50 minutes and 3 seconds ago, saying: sgronblo: unfortunately that might not help track down the error very well.  if you put your code on hpaste.org someone might be able to help you figure out what you are doing wrong.
15:07:57 <mm_freak_> mauke: but if you know a solution, which gets along without the int parameter and without anything else, then of course i'd appreciate, if you told me
15:08:07 <mm_freak_> a standard C solution that is
15:08:56 <mm_freak_> GCC supports lexically scoped functions, which is what i meant by cheating
15:09:06 <Peaker> mm_freak_, the more conventional approach is to pass a (void *) and not an int
15:09:41 <mm_freak_> Peaker: same thing
15:09:45 <Peaker> mm_freak_, I recently started passing a ptr to the struct that contains the func-ptr. Then I can "down-cast" the ptr to that struct to a container struct. Since I always have the caller allocate the struct, it can put any data it wants around it
15:10:55 <mm_freak_> Peaker: the more conventional approach is not to construct such a thing, but use the method, which is more natural in C:  loops and a counter variable
15:11:34 <Peaker> mm_freak_, Well, if you want to build a modular solution in C, function pointers are indispensable
15:11:43 <Peaker> mm_freak_, My c code has a lot of function pointers...
15:12:38 <ClaudiusMaximus> i had some C where i used something like  foo = (mode ? floor : ceil)(bar);  and i was surprised it worked
15:13:51 <Draconx|Laptop> I'm surprised that you were surprised.
15:14:02 <ClaudiusMaximus> :)
15:16:35 <mm_freak_> Peaker: my C code is almost entirely written in CPS, though i seldomly write C code
15:18:27 <Peaker> mm_freak_, I like CPS in C because C is much better at passing continuations than it is at ADTs, and they are pretty equivalent
15:18:34 <Peaker> so when I want an ADT, I write its catamorphism in C
15:18:44 <Peaker> (One of the ways Haskell has affects my C code)
15:18:49 <aristid> CPS without first-class functions?
15:19:03 <navaati> this is funny : haskell guys doing haskell in Câ€¦ why not just doing haskell ?
15:19:20 <Peaker> aristid, passing around a (void *) is good enough, especially since all the calls are done in the same stack frame (excuse the non-standard terminology :)
15:19:36 <Peaker> navaati, Because I want tight control of resources
15:19:54 <Peaker> navaati, And no GC latencies
15:20:44 <navaati> i admit that sometimes, the RTS is annoying
15:21:09 <navaati> but aren't there functionnal languages without GC ?
15:21:24 <ezyang> maybe, but that sounds very difficult to do. 
15:21:31 <mm_freak_> navaati: because sometimes you have no choice
15:21:45 <mm_freak_> if i have the choice, i use haskell
15:21:47 <Peaker> navaati, We often even prefer logic bugs over performance bugs/potential leaks... a logic bug is usually work-aroundable/acceptable.  A leak will eventually crash the entire thing.  I think when you want easy-to-reason-about performance, go for C. If you want easy-to-reason-about correctness, go for Haskell
15:21:48 * ezyang wonders how you would pull that off. 
15:22:33 <ezyang> Oh man. I wonder if anyone's written a dependently typed C. 
15:22:39 <kmc> ATS?
15:22:54 <Peaker> We'd rather spend a bit of time to get something with acceptable performance, then work like hell to make it correct - than start with something correct and then work like hell to get it reasonably performing, and maybe even failing to and thus having nothing
15:22:59 <mm_freak_> navaati: i don't think there can be functional languages without at least some primitive form of GC
15:23:01 <Clex> What is wrong with this?
15:23:01 <Clex> main = print (show (Data.Map.lookup "foo" (Data.Map.insert ("foo" "bar" Data.Map.empty))))
15:23:07 <mm_freak_> navaati: even the unlambda interpreter/compiler needs GC
15:23:13 <Peaker> Clex, It's using too many parenthesis :)
15:23:19 <kmc> Clex, you say (f (x y z)) when you probably mean (f x y z)
15:23:20 <edwardk> ezyang: cyclone, ats, etc.
15:23:23 <rwbarton> ("foo" "bar" Data.Map.empty)
15:23:29 <kmc> (f x y) is ((f x) y) not (f (x y))
15:23:33 <kmc> hi rwbarton
15:23:37 <rwbarton> you're using "foo" as a function there
15:23:39 <rwbarton> hey
15:23:39 <ezyang> Mmm. 
15:23:46 <Peaker> Clex, I actually meant stylistically but it is also the true problem :)
15:24:02 <Clex> I often do errors because of parenthesis, so I tend to abuse. :)
15:24:05 <edwardk> ezyang: the problem with functional programming without GC in general is that a lot of the fp tricks like currying, etc. all rely on near silent memory allocation for closures, without that you lose much of the point of fp
15:24:08 <Peaker> Clex, main = print . show . Data.Map.lookup "foo" . Data.Map.insert "foo" "bar" $ Data.Map.empty
15:24:23 <kmc> if you want to see closures without GC, look at C++1x lambda
15:24:33 <kmc> i expect they'll be pretty usable with reference-counted smart pointers
15:24:33 <djahandarie> ATS is ML-inspired isn't it?
15:24:34 <edwardk> er sorry navaati:
15:24:40 <edwardk> djahandarie: yes.
15:24:41 <mm_freak_> Peaker: i don't know how you write your haskell code, but mine performs very well, mostly from the start up
15:25:08 <mm_freak_> at some point you get a good intuition for how your code will behave and where laziness may bite you
15:25:12 <Clex> Thanks Peaker.
15:25:17 <BMeph> Clex: In this case, it is not abuse. It's just wrong. :)
15:25:18 <kmc> as far as i can tell ATS is inspired mostly by five sheets of high-powered blotter acid, but it's the only language i know of in that niche
15:25:33 <edwardk> djahandarie: ats is interesting, but it has some serious design issues, it was more accreted than designed. any identifier you  might think to use is probably a keyword.. even i it has _'s in it ;)
15:25:53 <kmc> i have absolutely no idea how to start trying to learn ATS
15:26:05 <kmc> i started to read the "tutorial" and it was incomprehensible
15:26:11 <edwardk> kmc: become hongwei xi ;)
15:26:13 <djahandarie> lol
15:26:14 <kmc> makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
15:26:21 <Clex> BMeph: I see. The dot seems to be a good habit.
15:26:28 <ezyang> hahaha 
15:26:43 <Peaker> mm_freak_, do you honestly write a large Haskell project and don't end up with any space leak anywhere?
15:27:33 <edwardk> peaker: i rarely run into space leaks in haskell code, but rarely do i lean heavily on laziness
15:27:42 <Peaker> mm_freak_, If you even accidentally use mapM once instead of mapM_ you get a linear space leak.. Also pretty difficult to find from profiling, easier to find from code review
15:27:44 <djahandarie> @remember kmc i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
15:27:44 <lambdabot> It is forever etched in my memory.
15:28:20 <edwardk> djahandarie: you might want to add [Regarding ATS] in that quote
15:29:09 <edwardk> i love the awesomely intuitive keywords like symintr and staload ;)
15:29:18 <djahandarie> Well I didn't want to to be particularly hateful :P
15:29:21 <kmc> sorry apparently it's "Teach Yourself PHP, MySQL and Apache in 24 Hours"
15:29:33 <dino-> Peaker: But doesn't recent GHC warn for that? Not doing something with results of mapM_ ?
15:29:56 <dino-> (Which I love, even though I had to go back and add lots of _ <- to things in places)
15:30:04 <kmc> teach yourself agile webscale HTML5 Canvas node.js iphone app slam scrum hackathons in 24 hours
15:30:14 <Peaker> dino-, Maybe.. I was helping a friend who wasn't keeping 0 warnings at all times :)  Yet another reason to
15:30:15 <djahandarie> Hahaha
15:30:26 <kmc> dino-, mapM_ is okay, it returns an action which produces ()
15:30:37 <edwardk> dino: more likely its just not doing something with a non () result in a monad
15:30:40 <dino-> kmc: bleh, meant mapM
15:30:47 <kmc> if it warns that your mapM should be a mapM_, then it's actually providing useful performance advice
15:30:55 <kmc> (which you are free to ignore)
15:30:59 <dino-> Oh you know what I meant!
15:31:14 <kmc> oh i misunderstood the context
15:31:38 <Peaker> @type sequence_
15:31:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:31:41 <navaati> how can I do something like "mapM_ (\p -> anActionUsing p) $ [(x,y) | x <- [boxX..(boxX+width)], y <- [boxY..(boxY+height)]]", but without building the whole list ?
15:32:12 <kmc> you aren't necessarily building the whole list
15:32:16 <Peaker> navaati, Haskell is lazy so only the relevant part of the list will be built
15:32:21 <kmc> the comprehension can produce (:)-cells one by one, as mapM_ consumes them
15:32:34 <kmc> and with the right list fusion optimizations, it might not even allocate those intermediate cells
15:32:47 <ezyang> lies! :-) 
15:32:52 <Peaker> navaati, btw, you can use:   liftM2 (,) [boxX..(boxX+width)] [boxY..(boxY+height)]     in place of that list comprehension
15:32:58 <kmc> basically don't worry about it until you profile and find that this is a huge performance sore spot
15:33:28 <navaati> kmc, you mean this fusion-stuff are automatic ? i thought i needed to use special libs
15:33:37 <navaati> s/this/thses/
15:33:39 <Peaker> @let sizedRange start size = [start..(start+size)]
15:33:40 <lambdabot>  Defined.
15:33:56 <kmc> some level of it is automatic
15:33:58 <Peaker> > liftM2 (,) (sizedRange 10 5) (sizedRange 100 2)
15:33:59 <kmc> with recent GHC
15:33:59 <lambdabot>   [(10,100),(10,101),(10,102),(11,100),(11,101),(11,102),(12,100),(12,101),(1...
15:34:42 <navaati> Peaker: why would be liftM2 is more efficient than list comprehension ?
15:34:59 <Peaker> navaati, not more efficient, just more concise
15:34:59 <djahandarie> navaati, one type of fusion is on by default in Data.List. You can get a different type with Data.List.Stream
15:35:07 <navaati> (this lambdabot is really greatâ€¦)
15:37:59 <Peaker> navaati, yeah, it is
15:38:23 <Peaker> @let x `divides` y = x `mod` y == 0
15:38:24 <lambdabot>  Defined.
15:38:29 <Peaker> > 8 `divides` 3
15:38:31 <lambdabot>   False
15:38:32 <Peaker> > 8 `divides` 2
15:38:34 <lambdabot>   True
15:38:50 <Peaker> > let primes = nubBy divides [2..]   in   take 100   primes
15:38:52 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:38:57 <djahandarie> It'd be cool if there were some way to write things into isomorphic but differently-fusing forms, without a meta-language.
15:39:05 <djahandarie> (Or super compilation)
15:39:34 <ezyang> It's nice to want things ;-) 
15:40:06 <djahandarie> I wonder what fusing is actually a property of, it seems a lot more general than lists
15:40:08 <Clex> Does Map.Data.insert actually modifies the map or should it be used like 'h = Data.Map.insert "foo" "bar" h'?
15:40:19 <djahandarie> Recursive structures?
15:40:30 <djahandarie> Functors in general?
15:40:42 * djahandarie goes to think about this more before blabbing any further
15:41:28 <kmc> Clex, values in Haskell can't be modified in place
15:41:30 <kmc> it returns a new map
15:41:41 <kmc> which may look like a copy, but will share most of its storage in memory with the old map
15:41:56 <kmc> the cool thing about Haskell is that this sharing is not some crazy specific optimization; it's a natural consequence of how immutable algebraic data works
15:42:03 <mm_freak_> Peaker: i use the type system to avoid space leaks like thatâ€¦  really i seldomly get serious space leaks, which are hard to spot
15:42:35 <kmc> in fact i'd argue that values in *any* language can't be modified in place... the idea of "value" contradicts that operation
15:42:47 <kmc> but of course most languages muddle together the ideas of value, identity, and state
15:42:58 <Clex> That's what I thought. It just seems strange when you're not used to.
15:43:12 <kmc> yep, it's a whole different way of thinking
15:43:37 <Clex> So it's useless to give a function a Data.Map if it does not return it.
15:43:52 <kmc> Clex, it might do a lookup and return the result, or use it somehow
15:43:56 <Clex> A function which inserts. :)
15:44:01 <mm_freak_> kmc: that was the natural thing to do back when the first programming languages were inventedâ€¦  after all most people got their mind infected by the turing machine way to view a computer, and in fact most computers are modelled to reflect that
15:44:05 <mm_freak_> unfortunate, but true
15:44:20 <Peaker> mm_freak_, I haven't written any long-running Haskell stuff yet. My friend who has, did have to profile a lot and code review some to prune the space leaks
15:44:45 <Peaker> Turing Machine Way is pretty different from the Von Neumann way.. though both are "machinery"
15:44:54 <mm_freak_> Peaker: right now i'm implementing two sites in haskellâ€¦  one for my homepage, one for my company
15:44:57 <kmc> mm_freak_, i don't really mind the imperative view for some things, i appreciate that Haskell provides it as one tool in the toolbox and doesn't force it on every problem
15:45:01 <Clex> kmc: should I use some kind of a global variable or something?
15:45:05 <kmc> Clex, no
15:45:08 <kmc> you should return the updated map
15:45:12 <mm_freak_> Peaker: i'm suggesting the lambda calculus as the alternative to the turing machine model
15:45:30 <Peaker> mm_freak_, I think a few people have suggested it too before :)
15:45:41 <Philippa> mm_freak_: even so, turing's not the guy to blame. The TM is extremely good at fulfilling its design aim - namely convincing us what the right class of 'computable functions' is
15:45:41 <kmc> Clex, Haskell functions don't describe what f *does*, they describe what f x *is*
15:45:48 <Clex> kmc: but what if I need my function to return a String? Should I return a tuple String/Map instead ?
15:45:59 <kmc> Clex, if you have to return a string and also an updated map, then yes
15:46:04 <mm_freak_> Philippa: yes
15:46:07 <mm_freak_> i don't argue that
15:46:13 * Philippa doesn't think the lambda calculus is the right model at hardware level either
15:46:26 <Clex> Ok, thanks.
15:47:01 <kmc> i'm all for multiparadigm languages, this "paradigm" notion is ridiculous anyway
15:47:02 <mm_freak_> Philippa: there have been machines modelled after the lambda calculus viewâ€¦  AFAIK implementing function languages on those machines is much easier
15:47:02 <Philippa> though I guess if anyone wants to show me a good hardware-level regioning system I might contemplate it
15:47:22 <kmc> Haskell is a good multiparadigm language and it's a failure of education that most people see it as a FP-only extremist side-show
15:47:55 <ezyang> lisp machines! 
15:47:55 <mm_freak_> kmc: haskell is a language, in which you can use all paradigms very easily, except perhaps OOP
15:48:05 <Philippa> kmc: CTM et al doesn't help because it offers a specific notion of 'paradigm' and thus 'multiparadigm' without talking about haskell's version effectively at all - it essentially ends up writing it out of existance
15:48:07 <mm_freak_> (C++-style OOP that is)
15:48:17 <ezyang> mm_freak_: I think if you take the actor interpretation of OOP, Haskell can work quite nicely. 
15:48:18 <kmc> C++ is an esolang
15:48:21 <ezyang> message passing and stuff. 
15:48:23 <kmc> don't use it to define what OOP means
15:48:52 <ivanm> if I need to strictly read in lazy ByteString (well, actually Text but I'm needing to do explicit encoding conversion) values from a Handle, what's the best way? use Strict ByteStrings and convert? or read it in then evaluate the length?
15:49:10 <kmc> ivanm, it's a simple operation to convert a strict to a lazy bytestring
15:49:12 <kmc> and cheap
15:49:35 <kmc> do you care how big the chunks in your lazy bytestring are?
15:49:43 <ivanm> not particularly
15:49:48 <ivanm> since I'll just be parsing them anyway
15:49:55 <kmc> why does it need to be lazy BS?
15:50:08 <ivanm> because I need to convert it to lazy Text
15:50:10 <navaati> mm_freak_: how can a machine be modeled for FP ? i hardly see a processor as another thing than a turing machineâ€¦
15:50:32 <ivanm> but I need the I/O to be strict because otherwise the program its getting the output finishes running before the input is fully read
15:50:33 <mm_freak_> ezyang: i think the actor interpretation is not a major improvement over normal procedural programmingâ€¦  it helps, but it's not exactly a paradigm shift
15:50:54 <ezyang> Why not? 
15:51:23 <ezyang> I've always thought the paradigm shift of OOP is that you associate code with data. 
15:51:41 <ezyang> The actor interpretation brings out the fact that data is state. 
15:51:57 <mm_freak_> ezyang: well, it gives you a nicer syntax for the things you would normally do by passing "objects" to procedures
15:52:44 <Philippa> mm_freak_: I take it you don't like the CTM notion of paradigm at all?
15:52:57 <ezyang> foo obj 1 vs obj.foo 1... not convinced :-) 
15:53:09 <mm_freak_> hehe
15:53:19 <mm_freak_> C++-style OOP does a bit more like OOP polymorphism
15:53:20 <ivanm> kmc: so you reckon to just do fmap (LB.fromChunks . (:[])) . SB.hGetContents ?
15:53:34 <kmc> OOP proponents sometimes try to take credit for the idea of abstract data types, which is actually much older
15:53:35 <ion> obj `foo` 1 :-P
15:53:38 <mm_freak_> Philippa: what's the C in CTM?
15:53:53 <Philippa> Concepts, IIRC
15:53:56 <kmc> and the teaching of OOP in most schools encourages this error
15:54:10 <Peaker> I prefer explicit C virtual tables with a simple macro to initialize them (making sure you don't forget some of them) over C++ virtuals.  The C ones are actually more type-safe and flexible
15:54:11 <Philippa> it's a book, not a turing machine variant :-)
15:54:32 <mm_freak_> navaati: i don't know the details, but the lambda calculus motivates a set of machine instructions
15:54:36 <kmc> and if the only language your school teaches is Java, you'll of course attribute every design feature of Java to the Stated Official Doctrine of Java
15:54:38 <mm_freak_> Philippa: i don't know that one
15:55:53 <parcs> what's the difference between the printf in base and the one in the printf-mauke package?
15:56:23 <Philippa> http://www.info.ucl.ac.be/~pvr/book.html
15:57:47 <ivanm> parcs: IIRC, the latter uses TH to be typed
16:06:42 <xplat> preflex: xseen ksf
16:06:42 <preflex>  ksf was last seen on freenode/#haskell 4 hours, 32 minutes and 34 seconds ago, saying: the client also has to deal with the machine it's running on
16:08:06 <xplat> @ask ksf have you tried implementing chunked iteratees in terms of single-item-per-step iteratees?
16:08:06 <lambdabot> Consider it noted.
16:10:12 <dcoutts> c_wraith: btw, what patches on Cabal + cabal-install are you using?
16:10:21 <dcoutts> c_wraith: would they be generally useful?
16:11:08 <c_wraith> dcoutts: I don't remember what all the changes were, but at least one of them was allowing cabal to take multiple package database args
16:11:53 <dcoutts> c_wraith: oh right, yes just a matter of sorting out the command line bit, since we added support for multiple ones internally
16:12:44 <dcoutts> c_wraith: if you have a moment some time, I'd appreciate a list of alterations that you've found useful (even without patches)
16:13:02 * dcoutts has been hacking on cabal-install all weekend
16:13:12 <c_wraith> dcoutts: pheaver is the one who's actually made the changes.  He's here on and off.
16:13:37 <c_wraith> dcoutts: I'm not actually that familiar with them, nor where the sources are.
16:14:06 <gaze__> Hey, if I'm throwing together an eDSL of some sort with the state monad
16:14:23 <dcoutts> c_wraith: ok, ta
16:14:26 <gaze__> and I want my "compiler" to puke if it encounters something that's structurally wrong
16:14:37 <gaze__> and I can't lift that structural error into the type system
16:14:51 <gaze__> is there any way to get a line number when I error out about that line?
16:15:01 <xplat> assert
16:15:29 <xplat> wait, maybe not
16:15:46 <xplat> but you could see how assert does it
16:15:58 <monochrom> Control.Exception.assert (b > 0) (5/b)
16:17:01 <xplat> if you just use assert youÄºl get the line number in your library, but if you copy the way it works you can get the line number in the embedded dsl code
16:17:18 <xplat> *you'll
16:17:50 <gwern> @quote
16:17:50 <lambdabot> gaal says: (ghc predicted a cpu death on my computer once.)
16:18:21 <gaze__> it looks as if ghc has some internal stuff to do asserts
16:18:38 <gaze__> there's some preprocessing going on
16:19:46 <gaze__> ooh, is tomh tom hawkins?
16:19:53 <gaze__> god damnit.
16:20:15 <gaze__> I'm basically trying to copy what he's done as an academic exercise and reimplement parts of bluespec as a haskell edsl
16:27:11 <xplat> @quote generated
16:27:12 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
16:27:12 <lambdabot> thing is.
16:27:18 <xplat> @quote generated
16:27:19 <lambdabot> jpet says: Ok, after studying the generated core a bit, I can conclude that generated core is somewhat hard to follow.
16:27:32 * hackagebot mysnapsession 0.4 - Sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.4 (ChrisSmith)
16:28:33 * hackagebot mysnapsession-example 0.4 - Example projects using mysnapsession  http://hackage.haskell.org/package/mysnapsession-example-0.4 (ChrisSmith)
16:41:48 <tg_> .
16:42:47 <kmc> !
16:42:52 <stepkut> is there a prefered library for list zippers ?
16:43:26 <stepkut> ListZipper looks nice.. 
16:46:33 <edwardk> stepkut: depends on what you want to do and what api you want
16:46:51 <absentia> n
16:47:14 <gwern> there
16:47:23 <gwern> I have now voted on everything in the haskell proposals subreddit
16:47:46 <gwern> and because of the options I set, I see nothing when I go to http://www.reddit.com/r/haskell_proposals/ :)
16:48:02 <edwardk> gwern: nice
16:48:11 <stepkut> edwardk: all i really need is, fromList, left, right, cursor, and perhaps endp..
16:48:21 <edwardk> gwern: i need to put out a call for new proposals, etc.
16:48:22 <stepkut> edwardk: no insert/delete/modify
16:48:26 <gwern> it's peculiarly satisfying
16:48:30 <gwern> edwardk: oh, dons just did that
16:48:35 <stepkut> edwardk: just navigation 
16:48:48 <edwardk> sweet =)
16:57:11 <ocharles> Hey there. Playing around with parsec at the moment and trying to do some basic stuff... having a bit of trouble parsing :foo:bar: into ["Foo","Bar"] though. using "between" and "sepBy1" with the same separating parser doesn't seem to work (because sepBy1 consumes the end clause)
16:57:31 <ocharles> any ideas on how I should approach parsing this?
16:59:35 <rudle> hi, i'm new to haskell. i'm wondering why i can't pattern match with ``(x:xs:y)''. i understand why it doesn't work, given the possibility of an infinite list - is there an elegant way (ie. without head or tail) to use this pattern?
16:59:45 <kmc> it does work
16:59:54 <kmc> (x:xs:y) will match any list of 2 or more elements
17:00:00 <kmc> naming the first one x, the second xs, and the rest y
17:00:03 <kmc> that's probably not what you intended
17:00:26 <kmc> the reason becomes clearer if you drop the special syntax for lists
17:00:30 <kmc> data List a = Nil | Cons a (List a)
17:00:40 <kmc> then your pattern is:  Cons x (Cons xs y)
17:01:15 <kmc> basically there's no great way to pattern match the end of a list, and it would involve walking to the end of the list one element at a time
17:01:20 <kmc> which of course "reverse" will do for you
17:01:38 <kmc> so maybe you want something like "f (x:xs) = case reverse xs of (y:_) -> ..."
17:02:09 <kmc> or maybe you want to turn on the ViewPatterns extension and say "f (x:xs@(reverse -> (y:_)))"
17:02:15 <kmc> i don't think either of these is a great option
17:02:23 <kmc> maybe you want to use Data.Sequence instead of lists
17:02:26 <parcs> what about using last?
17:02:29 <siracusa> How do you convert between Data.ByteString.UTF8.ByteString and Data.ByteString.Lazy.ByteString?
17:03:06 <kmc> siracusa, the former is just Data.ByteString.ByteString
17:03:13 <c_wraith> kmc, it's a newtype
17:03:16 <kmc> oh?
17:03:21 <c_wraith> it has different instances
17:03:27 <kmc> :/
17:03:28 <kmc> sigh
17:03:49 <kmc> that's not what i see here: http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/src/Data-ByteString-UTF8.html
17:04:08 <c_wraith> oh, does it just have conflicting instances when you import it with .Char8?
17:04:14 <rudle> kmc: that was informative. thank you. 
17:04:26 <kmc> maybe c_wraith 
17:04:31 <kmc> Char8 is so evil anyway
17:04:39 <kmc> if you want to represent bytes, use ByteString
17:04:44 <kmc> if you want to represent Text, use Text
17:05:04 <kmc> if you want to convert between them, use the functions in Data.Text.Encoding
17:05:31 <c_wraith> If I want to use bytestring, but not call Ord all the time, use .Char8
17:05:40 <c_wraith> err, ord
17:05:54 <c_wraith> ord is unrelated to Ord.  sad overloading in namespace there
17:05:54 <kmc> ByteString.Char8 is the "let's pretend it's 1960 and the only people with computers speak English" module
17:06:11 <siracusa> I just want String -> lazy ByteString, so maybe there's a better way to do that.
17:06:31 <kmc> siracusa, well there are many functions of that type
17:06:36 <Peaker> c_wraith, you get Word8 out of ByteString, so you don't need ord, maybe fromIntegral?
17:06:37 <kmc> one for each Unicode encoding
17:06:55 <c_wraith> Peaker, when I'm encoding the literals I want to parse
17:06:57 <kmc> if you're using ord to put Chars into a ByteString then you're still Doing It Wrong
17:07:03 <kmc> because ByteString doesn't contain Char
17:07:06 <kmc> it contains.......... bytes
17:07:13 <c_wraith> kmc: you seem to be operating under the assumption I don't know what I'm doing.
17:07:19 <c_wraith> That's an error
17:07:37 <c_wraith> I quite often parse formats that are strictly specified
17:07:37 <kmc> i'm not
17:07:45 <c_wraith> to contain specific bytes
17:07:49 <siracusa> Yeah, but I don't care which one
17:07:57 <kmc> if they are specified at the byte level then you should use byte literals
17:08:09 <c_wraith> those are exceptionally verbose
17:08:14 <c_wraith> and unmaintainable
17:08:29 <kmc> or at least use an explicit "fromLatin1" function rather than some IsString nonsense
17:08:43 * hackagebot spelling-suggest 0.5.0.1 - Spelling suggestion tool with library and command-line interfaces.  http://hackage.haskell.org/package/spelling-suggest-0.5.0.1 (GregWeber)
17:08:47 <kmc> i object to ByteString.Char8 because it tries to hide the fact that what one is doing here is basically totally wrong
17:09:02 <kmc> and leads to much continuing confusion over this Unicode business
17:09:48 <kmc> calling fromLatin1IReallyPromiseThereAreNoCodepointsAbove127ISwear would make that hack clear
17:09:58 <kmc> probably needs some "unsafe" too
17:10:05 <c_wraith> No confusion to me.  *shrug*
17:10:15 <hpc> XD
17:10:29 <kmc> as is, half the programming world is still wandering around saying "silly foreigners, i just want to convert strings to bytes, what's the big deal"
17:10:42 <Peaker> c_wraith, What mapping do you use?  something from a string literal to ByteString?
17:11:18 <c_wraith> Peaker: depends on what I'm doing.  I just said there are cases where .Char8 does exactly what I want.
17:12:02 <c_wraith> Oftentimes, it's not what I want.
17:12:34 <Peaker> I agree with kmc though that we should make truncating unicode code points harder, not easier, to emphasize that it is almost always the wrong thing
17:12:48 <dankna> indeed we should
17:14:23 <ion> Latin-1 has code points up to 255
17:14:46 <dankna> the problem is that people misunderstand when you say "ASCII"
17:15:07 * hpc considers ascii to be an artifact
17:15:20 <hpc> of the days when having that extra bit for checksum was actually useful
17:15:20 <dankna> thinking you actually mean, well, usually the Windows default codepage (which is not actually the default in many places)
17:15:21 <Philippa> yeah, they hear various forms of 'extended ascii'
17:15:42 <rwbarton> it's pretty lucky that they decided to only use a 7-bit encoding though
17:16:59 <siracusa> So how do I get a String into a lazy ByteString?
17:17:09 <hpc> siracusa: pack
17:17:13 <Philonous> Is there any example of serious use of ContT "in the wild"? 
17:17:17 <hpc> :t BS.pack
17:17:18 <lambdabot> [Word8] -> BSC.ByteString
17:17:22 <hpc> er
17:17:24 <dankna> :t fromString
17:17:25 <lambdabot> Not in scope: `fromString'
17:17:28 <dankna> @hoogle fromString
17:17:28 <lambdabot> Data.String fromString :: IsString a => String -> a
17:17:32 <dankna> bah
17:17:35 <dankna> @hackage utf8-strings
17:17:36 <lambdabot> http://hackage.haskell.org/package/utf8-strings
17:17:41 <hpc> @instances IsString
17:17:42 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
17:17:52 <hpc> @instances-importing Data.String IsString
17:17:53 <lambdabot> [Char]
17:17:57 <hpc> bleh
17:18:19 <gwern> > length "GREETINGS FELLOW HUMANS"
17:18:20 <lambdabot>   23
17:18:21 <dankna> http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-ByteString-Lazy-UTF8.html#v:fromString
17:18:28 <dankna> there we go
17:18:54 <siracusa> dankna: But this is a different ByteString
17:19:04 <dankna> siracusa: it what?
17:19:20 <siracusa> Yeah, different from Data.ByteString.Lazy
17:19:57 <dankna> oh.  you wrote your own?
17:20:22 <siracusa> No
17:20:56 <siracusa> I mean Data.ByteString.Lazy.UTF8.ByteString /= Data.ByteString.Lazy.ByteString
17:21:01 <dankna> no, it is
17:21:08 <dankna> it's reexported
17:21:39 <siracusa> It's reported as an error
17:21:41 <dankna> I believe, anyway.  I've only ever used utf8-string for non-lazy ByteStrings, but I don't see why it would be different.
17:22:22 <dankna> hpaste the code and error?
17:22:35 <siracusa> @where hpaste
17:22:35 <lambdabot> http://hpaste.org/
17:25:40 <siracusa> http://hpaste.org/43957/different_bytestrings
17:26:38 <dankna> siracusa:
17:26:50 <dankna> you imported Data.ByteString.UTF8 on line 2, not Data.ByteString.Lazy.UTF8
17:26:53 <dankna> both exist
17:27:41 <siracusa> Oh
17:28:59 <siracusa> But then I get nearly the same error
17:29:40 <dankna> well, annotate the patch with the new error?
17:29:43 <dankna> er paste
17:31:05 <siracusa> http://hpaste.org/paste/43957/different_bytestrings_annotat#p43958
17:31:50 <dankna> hashlazy is TAKING a lazy bytestring but RETURNING a non-lazy one!  bizarre
17:32:12 <dankna> one sec
17:32:17 <siracusa> Indeed! That's strange.
17:32:40 <dankna> http://hpaste.org/paste/43957/different_bytestrings_annotat#p43959
17:32:57 <dankna> that's what I'd do (haven't tested it), if hashlazy is outside your control
17:33:04 <dankna> if it's under your control I'd fix it instead
17:33:18 <dankna> er, my line 3 is wrong, but you see what I meant
17:34:31 <siracusa> dankna: Ok, works. Thanks!
17:34:38 <dankna> np!
17:36:20 <Peaker> It makes sense to return a strict bytestring since it is very small
17:36:31 <Peaker> and to take a lazy one since it may be very big and generated "on-the-fly"
17:36:57 <dankna> yeah, fair
17:37:19 <Peaker> if they had different names it would be so much easier
17:37:29 <dankna> oh well, heh
17:37:44 <Peaker> ByteArray, ChunkList
17:38:08 <ddarius> ALittleBS, ALotOfBS
17:38:34 <dankna> those are good names, Peaker
17:39:41 <Peaker> I wish Haskell had started a backwards-incompatible project in parallel where everything is fixed without giving it a second thought, and frozen after a few years of fixage
17:39:47 <Peaker> Like Python 3
17:40:09 <hpc> Peaker: that would rock
17:40:15 <accel> what problem would that solve?
17:40:57 <Peaker> accel, the various crap in Haskell's ecosystem:  Monad <-> Applicative,  get rid of mtl,  ByteString rename (or even generalize to unboxed arrays?)
17:41:24 <dankna> I'm not sure I wish that
17:41:24 <accel> holy shit, does Gram Hutton's Programming in Haskell manage to get by without talking about monads?
17:41:37 <pikhq> Peaker: Arguably, you could fix all that just fine. Yourself.
17:41:48 <pikhq> Libraries are (relatively) easy to fix.
17:41:48 <accel> Peaker: what's mtl?
17:42:08 <Peaker> pikhq, Not the Prelude
17:42:27 <Peaker> accel, the old monad transformer library that everyone agrees is wrong but has too much momentum to just replace
17:42:34 <pikhq> Just a library, even if it is one with Magic.
17:42:51 <Peaker> pikhq, you mean by hacking on ghc?
17:43:59 <pikhq> Peaker: Most of the stuff you would actually want to fix wouldn't be *that* painful to fix, though.
17:44:19 <Peaker> pikhq, why don't they fix it then?
17:44:46 <pikhq> Because you don't just go out and break stuff when you're trying to comply with a spec.
17:45:08 <rwbarton> because being able to use all the libraries that use Monad has more utility than making Applicative a superclass of Monad?
17:46:06 <Peaker> rwbarton, Why wouldn't you be able to use them?
17:46:08 <pikhq> rwbarton: s/all/many of/ I'm sure there's at least *some* libraries that'd work just fine with Applicative a superclass of Monad.
17:46:28 <rwbarton> Well, you'd have to adjust the ones that define Monad instances at least
17:46:53 <accel> rwbarton: are you graduating / going to be on the job market soon?
17:47:07 <Peaker> rwbarton, not only if they forget the Applicative instance? In which case they need adjusting anyway?
17:47:26 <Peaker> rwbarton, btw: the adjustment is pretty easy (copy&pasting Functor/Applicative instances based on the monad one)
17:48:13 <rwbarton> Peaker: sure but by the same logic you don't really gain much
17:51:08 <Peaker> rwbarton, I can get rid of a lot of library duplication
17:51:17 <Peaker> rwbarton, and duplicate type-class constraints on functions
17:51:18 <dankna> look at it this way.  Haskell is better for many purposes than C, Perl, and several other ancient languages.  it doesn't get away from the problem of legacy code, no, but nothing yet does.
17:51:52 <rwbarton> if you want to do it, go ahead, nothing is stopping you
18:24:01 * hackagebot husk-scheme 2.1 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-2.1 (JustinEthier)
18:54:07 * hackagebot vector-buffer 0.1 - A buffer compatible with Data.Vector.Storable  http://hackage.haskell.org/package/vector-buffer-0.1 (VivianMcPhail)
18:54:38 <RyanRN> line
18:55:00 <shapr> RyanRN: hook?
18:57:55 <RyanRN> [sinker] â€” oops typo ;-)  But good response
19:00:19 <shapr> RyanRN: Are you related to RyanT5000 ?
19:05:59 <akjeflaj> hi
19:06:09 <kmc> hi
19:06:09 <shapr> hiya, how's code?
19:06:14 <mikeg> For UDP networking, is it safe to use System.Timeout to handle recvFrom timeouts? I call recvFrom in a loop for 5 seconds, then close the socket. Then when I try to recvFrom on a new socket, it blocks.
19:06:39 <mikeg> not closing the first socket allows me to read from the second... network-2.3.0.2 with the bytestring variants
19:06:55 <akjeflaj> my name is greg
19:07:02 <akjeflaj> how to make code?
19:07:19 <kmc> what kind of code akjeflaj?
19:07:21 <kmc> ok
19:07:22 <kmc> then
19:07:33 <tg_> how does babby made
19:08:33 <TTimo> ok how do I get 6.13 and all the dependent stuff safely installed next to my distro provided 6.12
19:08:34 <mikeg> or could someone point me to a real haskell program (not a sample...) that uses UDP networking?
19:13:12 <ClaudiusMaximus> mikeg: perhaps http://hackage.haskell.org/packages/archive/hosc/0.8/doc/html/Sound-OpenSoundControl-Transport-UDP.html
19:15:34 <mikeg> "-- N.setSocketOption fd N.RecvTimeOut 1000" looks like they have a similar problem to me :)
19:16:52 <siracusa> On a Windows system, how do I create an output handle for runProcess that ignores all output?
19:22:14 * hackagebot vector-buffer 0.1.0.1 - A buffer compatible with Data.Vector.Storable  http://hackage.haskell.org/package/vector-buffer-0.1.0.1 (VivianMcPhail)
20:20:41 <minsa> what is pseudo polynomial time ? I am reading wikipedia but couldn't understand it. "Consider the problem of testing whether a number n is prime, by naively checking whether no number in {2, 3, ..., n/2} divides n evenly."
20:29:01 <Gracenotes> I wonder if, switching from GHC 6.12 to 7, this whole out of memory (requested 1048576 bytes) thing will go away
20:30:00 <rwbarton> minsa: it typically means polynomial in the value of a parameter, rather than its length in an efficient encoding
20:30:46 <minsa> so the function is not polynomial but it grows really fast because of the input ? 
20:30:55 <Gracenotes> especially since there's 25GB free memory. is malloc being bad? :(
20:31:07 <rwbarton> so here trial division is polynomial in n but it's not polynomial in b = log_2 n which is the length of the input (assuming binary representation)
20:31:29 <blbrown_win3> I want to render basic 2D (lines, points, rectangles) shapes with a target to Win32.  Which framework would you recommend.  I was trying to avoid opengl
20:31:45 <blbrown_win3> with minimal install fuss
20:32:10 <minsa> ok ? 
20:34:21 <Twey> blbrown_win3: Why avoid OpenGL?  OpenGL is fine for that sort of thing if you don't mind going low-level.  You could also use Gtk2Hs and a canvas, or something higher-level like FieldTrip (experimental-ish).
20:35:04 <blbrown_win3> Twey, it is fine but more advanced than what I needed.  E.g. I would have to worry about projections and matrices.  I just want to draw a point with minimal effort
20:36:17 <minsa> rwbarton, I think I am getting it now. It is polynomial not because of the physical length but because of its value.
20:36:20 <minsa> is it true ? 
20:37:55 <Twey> blbrown_win3: You don't have to worry about such things to use OpenGL
20:38:19 <blbrown_win3> what is the default 2D projection in OpenGL?
20:38:41 <blbrown_win3> matrix mode anyway
20:38:43 <dankna> well, you do have to worry about them a little
20:38:47 <Twey> I don't even know, that's how little you need to know to use OpenGL :Ã¾
20:38:49 <blbrown_win3> ...exactly
20:38:50 <luite> blbrown_win3: you could use cairo with one of the higher level libraries that build on it. installation isn't terribly difficult, you have to download and install a gtk package, extract it, add a directory to your path and then cabal install it
20:39:01 <Twey> You can just start drawing and specify coordinates for triangles
20:39:19 <blbrown_win3> luite, gtk2hs/cairo doesn't sound too bad
20:39:33 <luite> blbrown_win3: hm, I realized that I overloaded "it" a bit in that sentence :p
20:40:03 <blbrown_win3> Twey, and opengl isn't too bad I guess either.  The abstraction is just so far away from 2d rendering
20:40:31 <Twey> Hm, maybe I'm wrong â€” I'm sure I remember Just Drawing Stuff, but this site looks like it sets up projection stuff first
20:40:59 <rwbarton> minsa: right.  Usually "polynomial" refers to polynomial in the length and "pseudopolynomial" means polynomial in the value
20:42:30 <dainanaki> I'm having a weird dependency issue that's cropped up. I'm trying to cabal install yesod-auth, but I'm getting a message saying that ghc-6.12.3 requires unix==2.4.0.2 however unix-2.4.0.2 was excluded because ghc-6.12.3 requires unix==2.4.1.0
20:42:48 <dainanaki> can anyone tell me what the deal is?
20:43:21 <minsa> rwbarton, for the problem of checking primality via division, shouldn't the length of the input be   2 to n  instead of just n and how many digit n has ? 
20:47:13 <luite> minsa: the amount of space on a tape of a turing machine for encoding an integer is in the order of log(n), for an n-digit number, if you use at least two symbols
20:48:30 <minsa> luite, thnx. so  iterating  from  2 to n is part of the function and not part of the input. 
20:49:01 <luite> minsa: but sometimes what you say is used as a basis for pseudopolynomial time, namely when you encode the integer in unary, you use only one symbol on the tape for the number, then the problem becomes solvable in polynomial time with respect to this input
20:49:34 <ivanm> dainanaki: does "ghc-pkg check" bitch?
20:50:12 <luite> minsa: some NP-complete problems that use integers are still hard (not solvable in pseudopolynomial time) when you encode all integers in their problem with this unary encoding
20:50:21 <dainanaki> ivanm: Oh idunno anymore. I just uninstalled 6.12 and am just gonna install 7.0.1 and see how that goes
20:50:34 <ivanm> dainanaki: remember to keep your current cabal-install then
20:50:40 <dainanaki> i sure did
20:50:46 <dainanaki> learned that the hard way
20:51:09 * minsa trying to understand luite's comments.
20:52:09 <luite> minsa: an example may help. do you know the 3-partition problem?
20:52:39 <minsa> luite, unfortunately, no.
20:52:46 <minsa> I am still working my way through graph.
20:53:30 <luite> minsa: oh it's easy to explain, you have a group of 3n items, each with a value (an integer), and you want to check whether you can divide them into n groups, where each group has the same combined value
20:53:54 <minsa> ok.
20:54:04 <minsa> I understand the problem statement.
20:55:35 <luite> minsa: a problem is just a list of integers, the values of the items. you could encode each integer with unary encoding, a problem instance [3,4,2] could then look like 1110111101100 on the tape, you encode the integers in unary with only the symbol 1, use a 0 to separate the values, and possibly 00 to end the input
20:55:49 <dainanaki> ivanm: incidentally, do I have to do anything special with old packages from 6.12.3 that I cabal installed?
20:56:05 <ivanm> dainanaki: rm ~/.ghc/ghc-6.12.3/
20:56:15 <ivanm> just to get clear up space
20:56:15 <kmc> blbrown_win3, i think all the matrices come initialized to identity
20:56:22 <ivanm> you'll have to rebuild all of them by hand
20:56:24 <kmc> (transform and modelview etc)
20:56:25 <luite> minsa: of course 3 values isn't a real 3-partition problem, since the answer is always yes
20:56:35 <kmc> the viewport matrix is kind of special, usually you'd set that with some GLU stuff
20:56:44 <kmc> dim flashes of memories from a previous life
20:57:25 <minsa> ok, luite, so far so good.
20:57:53 <luite> minsa: bit this should give you an idea of the input length for a real problem with real values. now in this case, you can prove that there are still polynomial-time reductions from SAT (boolean satisfyability).
20:58:53 <luite> minsa: so even with respect to this horribly inefficient encoding scheme, the problem is hard, meaning that if you could solve it in polynomial time with respect to the unary encoded input, you could solve all NP-complete problems in polynomial time
20:59:37 <dolio> Presumably the problem is hard with respect to the number of integers given, not the size of those integers?
21:00:04 <luite> minsa: so there is no pseudopolynomial time algorithm known for this problem, and it wouldn't be very productive to look for one, unless you want to prove P=NP :)
21:01:00 <luite> but in that case, you also have a real polynomial time algorithm
21:02:09 <luite> dolio: well all such problems become "trivial" if you bound the number of integers, since you can solve them with a very simple branching algorithm in a bounded number of branches
21:02:12 <NemesisD> is there a better way to swap out an element in an array than using splitAt or span?
21:03:06 <kmc> (//) :: Ix i => Array i e -> [(i, e)] -> Array i e
21:03:13 <kmc> "Constructs an array identical to the first argument except that it has been updated by the associations in the right argument."
21:03:23 <kmc> but from your question i'm guessing you meant "list" not "array"
21:03:26 <kmc> in which case, not really
21:03:30 <dolio> luite: I mean the hardness lies in selecting the partitions, not in any of the operations (addition, comparison) of the integers themselves.
21:03:41 <NemesisD> yeah sorry, meant list
21:03:46 <minsa> luite, thank you very much. I will read and work out problems until I get itdown pad. I am grasping it more than before.
21:04:00 <kmc> NemesisD, if you're thinking of your list positionally, why not use Data.Sequence, IntMap or (Map Int) instead?
21:04:08 <kmc> lists really aren't made to be indexed randomly
21:04:16 <kmc> they are more like loops than data structures
21:05:30 <luite> dolio: addition and comparison is hardly ever the problem, since as long as you use only polynomial space, they cannot take exponential time. that's why you can often assume an arithmetic model where such operations are constant time. there are tricky cases though, with rational number or real number arithmetic where the representation for each numbers could grow exponentially
21:06:34 <luite> but in case of 3-partition, you probably only need addition and comparison (although the requirement is a property of the algorithm, not the problem)
21:07:09 <ivanm> grrr.... spent ages trying to debug why something was stuffing up only to find that the problem was caused by remnants of my last debugging attempt (which I solved) :@
21:07:33 <kmc> ivanm, isn't software great?
21:10:18 <dolio> luite: Yeah, that was pretty much the point I was trying to make. If we assume that all the numbers involved are just atomic things of all the same size, and that things like 'do these partitions have the same value' all take constant time, the problem remains hard.
21:10:39 <ivanm> kmc: yeah :s
21:11:38 <dolio> Because, naively, we still have to check a lot of partitions.
21:12:00 <djahandarie> I remember that some instance somehow getting loaded into my ghci really screwed stuff up because it didn't go away between :rs and it took awhile to figure that one out
21:13:11 <dolio> And presumably 3-SAT doesn't transfer its hardness to 3-partition by generating very large numbers to be partitioned. :)
21:13:47 <luite> dolio: hmm, not sure if you mean the right thing there :p since for example the 2-partition problem (make 2 groups with equal value) is also still hard if you assume those things. but it does admit a pseudopolynomial time algorithm (so it becomes easy with respect to the length of the unary encoding in the example I just gave to minsa)
21:14:22 <dolio> Hmm.
21:15:09 <luite> so you could say 2-partition is easy with respect to the combined value of the items
21:15:14 <luite> while 3-sat is still hard
21:15:28 <luite> err
21:15:29 <luite> 3-partition
21:15:37 * copumpkin proves P=NP by providing a polynomial reduction from 3-SAT to 2-SAT
21:16:12 <luite> copumpkin: please add it the the pile of P=NP papers waiting to be reviewed
21:16:44 <kmc> that's what arxiv.org is for
21:17:41 * djahandarie proves it in Coq and calls it a day
21:17:51 <accel> actually
21:17:54 <accel> what is a good program
21:17:57 <accel> for storing math proofs?
21:18:03 <luite> copumpkin: try not to use linear programming in your reduction or you'll have to prove that there are strongly polynomial-time algorithms for solving that
21:18:04 <kmc> coq
21:18:15 <copumpkin> luite: there are!
21:18:27 <accel> is it "smart" enough to store the proof of Cook's Turing Machine <--> 3SAT ?
21:18:31 <luite> copumpkin: I'm sure you can cite some arxiv paper with a proof :p
21:18:43 <kmc> probably
21:18:53 <kmc> and who cares if it can store the proof, what's important is that it can check the proof
21:19:02 <accel> yeah; acn it check that proof?
21:19:09 <accel> http://coq.inria.fr/stdlib/
21:19:12 <kmc> i would guess soo
21:19:16 <accel> it doesn't look like it even knows about turing machines
21:19:20 <kmc> well sure
21:19:23 <kmc> you have to tell it
21:19:36 <kmc> the Haskell Prelude doesn't know about OpenGL or TCP/IP
21:19:43 <accel> wht's coq implemented in?
21:19:45 <kmc> but people have written libraries for these
21:19:45 <kmc> ocaml
21:19:47 <accel> yeah; but for something like coq
21:19:59 <accel> I would assume, perhaps incorrectly, that ppl would ahve a giant database of existing proofs
21:20:02 <kmc> it might be unreasonably painful to explain Cook's reduction at the level where Coq operates
21:20:04 <luite> accel: keep a diary with your results and then become a famous mathematician. people will work out and publish your results after your death
21:20:09 <kmc> but actually i think it wouldn't be too bad
21:20:10 <accel> as i bet writing proofs in coq is going to redefine tedious
21:20:16 <kmc> Coq was used for a verified proof of the Four Color Theorem
21:20:19 <kmc> which i think should be a lot worse
21:20:44 <kmc> i don't know where the "hackage for coq" is, if that's what your'e asking
21:21:00 <accel> kmc: that's what I thought ... in practice, coq isn't "powerful" enough for a human to type out cook's reduction
21:21:03 <kmc> but just because something isn't in the standard library doesn't mean nobody is orpviding it
21:21:03 <Gracenotes> "The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics."
21:21:11 <kmc> e.g. http://ltamer.sourceforge.net/
21:21:15 <luite> meh all these computer proofs, I don't trust them. one day I'm going to invent a map that's not four-colorable ;)
21:21:16 <Gracenotes> I've always liked that quote
21:21:18 <kmc> accel, like i said, they did 4CT, i think that should be a lot worse
21:21:18 <accel> that's what I hate about these proof assistants
21:21:38 <accel> awsn't 4colors
21:21:43 <accel> just giant ass case analysis?
21:21:47 <accel> i.e. no brillaicne behind it
21:21:56 <copumpkin> I wouldn't say that
21:22:03 <accel>  i just did
21:22:05 <kmc> no, it was quite tricky to figure out how to reduce the problem to a finite set of cases
21:22:14 <luite> accel: well that was the final part, the first part was proving that each map is reducible to one of these (19hundredsomething?) cases
21:22:16 <kmc> and also to pick a way of doing so which makes the number manageable
21:22:25 <kmc> obviously the naive approach to 4CT has an infinite number of cases
21:23:12 <kmc> accel, i recommend you read research.microsoft.com/en-us/um/people/gonthier/4colproof.pdf
21:23:53 <kmc> at least the setup should be pretty much accessible
21:24:13 <accel> are there any theorem provers written in haskell?
21:24:28 <kmc> and it should explain both why solving 4CT was non-trivial, and also why this coq-verified proof is fundamentally different from the computer-assisted proofs of the 70's
21:24:32 <kmc> accel, yes
21:24:35 <kmc> Agda and Epigram
21:24:38 <kmc> probably others
21:25:15 <kmc> basically the original computer-assisted proofs had hundreds of pages of non-computerized argument about why what the computer did was sufficient, plus a computer program with unknown bugs
21:25:54 <kmc> the more recent work in Coq formalizes the argument so the only thing you need to trust is Coq itself and a few pages worth of definitions
21:26:13 <accel> I actually don't even know how to formulate basic things as computer redable proofs
21:26:17 <accel> things like:
21:26:28 <accel> a K-type TM can be simulated by a 1-tape TM with polynomial slow down
21:26:36 <kmc> well accel if you want to learn, you could do a lot worse than reading this book: http://www.cis.upenn.edu/~bcpierce/sf/
21:26:36 <accel> comparison sorting takes atoeast O(n log n) comparisons
21:27:09 <kmc> it's an intro to coq and an intro to theory of programming languages
21:27:21 <kmc> in which you prove a variety of results about functional and imperative languages
21:27:25 <kmc> not explicitly turing machines but pretty close
21:27:29 <kmc> it's also a *lot* of fun
21:27:30 <accel> i want to prove things about complexity theory
21:27:36 <accel> fuck these simple things
21:27:55 <kmc> accel, that's not how people learn
21:28:00 <kmc> start with the simple stuff
21:28:08 <accel> i've read books on complexity theory
21:28:10 <accel> and written proofs
21:28:15 <accel> just not sure how to make the proofs comptuer readable
21:28:35 <kmc> and you would start learning by making some easy proofs computer readable
21:28:43 <kmc> do you think it's just a matter of syntax, of hitting the right keys?
21:28:53 <kmc> of course not, it's a whole new programming language, probably radically different from anything you've used
21:28:57 <kmc> you can't expect to jump in the deep end
21:29:34 <luite> if you need you prove something for which there are no libraries (definitions and proofs of basic properties) available, you'll probably have to to a lot of work (months, years?) before you can even enter the proposition meaningfully
21:43:21 <shamster> are closures often used in haskell (i.e. are they idiomatic and common?) or is there another way around that I haven't seen yet? 
21:43:45 <kmc> yes, Haskell is proud of its roots in functional programming
21:43:53 <accel> how do you even write a basica haskell prover
21:43:59 <accel> taht can prove shit like "p & q => p"
21:44:08 <kmc> @djinn (p,q) -> p
21:44:09 <lambdabot> f (a, _) = a
21:44:24 <accel> kmc: ?
21:44:30 <kmc> http://lambda-the-ultimate.org/node/1178
21:45:09 <accel> how does returning a function of a given type
21:45:11 <accel> provide a proof?
21:45:22 <kmc> http://en.wikipedia.org/wiki/Curry-Howard_Isomorphism
21:45:39 <accel> kmc: I hate to admit this
21:45:52 <accel> kmc: but I'm starting to respect you
21:46:06 <kmc> hahaha
21:46:55 <copumpkin> accel: the C-H stuff is amazingly simple and powerful
21:47:03 <copumpkin> proving has never been so fun
21:47:22 <luite> that must be the first declaration of love on this valentine's day on this channel ;)
21:47:27 <kmc> awwww
21:47:30 <kmc> â™¥
21:48:30 <Jafet> @quote â™¥
21:48:30 <lambdabot> No quotes match. I feel much better now.
21:48:37 <Jafet> @vixen â™¥
21:48:38 <lambdabot> What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
21:48:39 <kmc> accel, you may also enjoy http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
21:48:48 <luite> does anyone know whether Stephen Tetley (author of Wumpus) hangs around on this channel or network?
21:48:53 * copumpkin â™¥ TTFP
21:49:25 <kmc> copumpkin, are the slides from your Agda talk online?
21:50:12 <Kaidelong> oh wow
21:50:24 <Kaidelong> kmc why have I only found out about that book now
21:50:39 <kmc> i still haven't read most of it :/
21:51:04 <Kaidelong> I have been looking for this book for a while now
21:51:15 <ivanm> hooray, Text-based graphviz appears to be a _smidgeon_ faster than String-based graphviz! \o/
21:51:16 <Kaidelong> not specifically, but in the sense of having looked for a book like it
21:51:28 <ivanm> (one test indicates 4.48s vs 4.63s)
21:52:10 <kmc> what Pierce et al's coq book has that TTFP doesn't is a bunch of fun exercises you can easily load
21:52:16 <copumpkin> kmc: thanks for reminding me. uploading right now!
21:52:16 <kmc> i.e. many levels of an addictive puzzle game
21:52:21 <kmc> woot
21:52:52 <copumpkin> thinking of doing a bunch of blog posts about it (I have some half-written stuff) once I actually get around to putting the ever-unpublished website up
21:53:05 <kmc> excellent
21:53:33 <copumpkin> http://dl.dropbox.com/u/361503/Agda%20and%20dependent%20types.pdf is the slides, but they won't appear for another several minutes (the hotel connection is kinda slow)
21:59:51 <Chaze> @ap  (\f a -> f a a)
21:59:51 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
22:00:01 <Chaze> :t  (\f a -> f a a)
22:00:02 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
22:01:42 <Chaze> how can i get lambdabot to find a point-free version again?
22:01:56 <kmc> @pl \x -> (2*x,3+x)
22:01:57 <lambdabot> liftM2 (,) (2 *) (3 +)
22:02:29 <Chaze> @pl (\f a -> f a a)
22:02:29 <lambdabot> join
22:02:33 <Chaze> thanks
22:03:06 <kmc> pl for "pointless"
22:03:43 <kmc> or perhaps as an homage to Perl
22:03:52 <copumpkin> kmc: the slides are up
22:04:32 * copumpkin goes to sleep
22:05:16 <kmc> thanks
22:11:40 <Chaze> i think i want to learn a language of the set APL,K,J
22:11:40 <accel> did you know
22:11:46 <Chaze> which one do you recommend?
22:11:48 <accel> that Perl aws named after Pearl of Great Price ?
22:11:58 <accel> implementing J in haskell.
22:12:06 <accel> APL rquires special keyboard
22:12:36 <Chaze> well, it wouldn't be the first keyboard layout i learn
22:12:41 <Chaze> that doesn't scare me
22:13:09 <Kaidelong> err this book says that a type language's syntax prevents you from writing code with type errors in it...
22:13:11 <accel> it's not special keybaord layout as in dvorak
22:13:16 <accel> it's _special_ keybaord
22:13:21 <Kaidelong> but I never really thought of that as a function of the syntax
22:13:25 <kmc> special unicode page
22:13:43 <Kaidelong> Chaze: J
22:14:03 <Kaidelong> that said, I do not like any of them much
22:14:21 <Kaidelong> @ty (<*>id)
22:14:22 <lambdabot> forall a b. (a -> a -> b) -> a -> b
22:14:33 <Chaze> i just like having a language ready that beats any character count of others :)
22:14:38 <Chaze> not because it's practical, but fun
22:14:54 <Chaze> i think APL is kinda old-fashioned by now
22:15:00 <Chaze> so why J over K?
22:15:12 <accel> what comes first in your keybaord, J or K?
22:15:19 <accel> in mine, it's J
22:15:31 <Kaidelong> > ((*)<*>id) 2
22:15:32 <lambdabot>   4
22:15:36 <Chaze> dvorak here :p
22:15:39 <Kaidelong> > ((*)<*>id) 10
22:15:39 <Chaze> but yeah, same
22:15:40 <lambdabot>   100
22:15:49 <accel> wtf is <*> ?
22:15:57 <Kaidelong> @ty (<*>)
22:15:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:16:06 <kmc> accel, it's one of the typeclass methods of Applicative
22:16:09 <kmc> the crucial one really
22:16:21 <kmc> applies a "container" of functions across a "container" of arguments, i.e.
22:16:23 <Kaidelong> for functions it is exactly the S combinator
22:16:28 <kmc> > [succ,pred] <*> [3,7]
22:16:29 <lambdabot>   [4,8,2,6]
22:16:42 <kmc> > Just show <*> Just 5
22:16:43 <lambdabot>   Just "5"
22:16:47 <kmc> > Nothing <*> Just 5
22:16:48 <lambdabot>   Nothing
22:17:06 <accel> (+) <*> [3,7]
22:17:14 <accel> > (+) <*> id [3,7]
22:17:15 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[t]'
22:17:22 <accel> > ((+) <*> id) [3,7]
22:17:23 <lambdabot>   No instance for (GHC.Num.Num [t])
22:17:23 <lambdabot>    arising from a use of `e_137' at <inte...
22:17:38 <accel> @ty <*>
22:17:39 <lambdabot> parse error on input `<*>'
22:17:47 <accel> @ty (<*>)
22:17:47 <kmc> @ty (<*>)
22:17:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:17:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:18:06 <accel> wtf is an Applicative?
22:18:18 <kmc> http://www.haskell.org/haskellwiki/Typeclassopedia
22:18:21 <Kaidelong> @instances-importing Applicative
22:18:22 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
22:18:27 <Kaidelong> wut
22:18:31 <kmc> why the fuck can't you ask a question without using the phrase "the fuck"?
22:18:50 <accel> because wtf is 1 letter shorter than what
22:19:02 <kmc> you could say "wut" but i think that would annoy me more
22:19:16 <accel> it also requires less mental effort since wtf is all left hand, so no need to coordinate 
22:19:23 <Kaidelong> but what about that picture of a pear in front of the lighthouse
22:19:24 <accel> whichi avoids left-right race conditions
22:19:29 <accel> thus allowing fasteter typing
22:19:33 <kmc> you could instead say Åµ
22:19:35 <kmc> one character
22:19:43 <djahandarie> Kaidelong, but wut*
22:19:56 <accel> maybe instead, of 'what', I'll use ?
22:20:00 <accel> so that beomes
22:20:02 <accel> ? is applicative
22:20:08 <accel> but that's annoying, as I have to hit shift
22:20:18 <accel> and even more coordinateion with left pinky right ring finger
22:20:31 <djahandarie> Applicativeã¯ã„ã£ãŸã„ä½•ãªã‚“ã ï¼Ÿï¼ï¼Ÿï¼
22:20:35 <accel> kmc: perhaps i can recommend an irc client that can auto s/wtf/what ?
22:20:37 <kmc> accel, get a better keyboard layout
22:21:28 <Kaidelong> I still don't like xchat's insistance that I cannot use "teh" ironically
22:21:47 <accel> teh teh teh teh teh teh teh teh teh
22:21:50 <accel> does it auto correct for you?
22:21:53 <Kaidelong> yeah
22:22:25 <Kaidelong> Anyway moving on!
22:22:41 <Kaidelong> an applicative is a functor which has "pure" (which is like return)
22:22:48 <Kaidelong> and then application
22:22:57 <Kaidelong> which is pretty much just like function application
22:23:06 <kmc> the <left> <left> <backspace> <right> h
22:23:07 <Kaidelong> f (a -> b) -> a -> b
22:23:12 <Kaidelong> @ty ($)
22:23:13 <lambdabot> forall a b. (a -> b) -> a -> b
22:23:16 <kmc> i did that a few times and it disabled the autocorrect :O
22:23:20 <kmc> now it's back :/
22:23:21 <Kaidelong> @ty (<*>)
22:23:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:23:28 <Kaidelong> compare those two
22:23:39 <kmc> i already linked accel to Typeclassopedia
22:23:40 <kmc> btw
22:23:47 <Kaidelong> ah did he read it?
22:23:50 <kmc> no idea
22:23:56 <kmc> but in general it is good if people read things
22:24:21 <kmc> it is easy to sit in this channel all day and say "wtf is foo" without actually reading any of the links people send you
22:24:47 <accel> kmc: that doc you send me to
22:24:49 <accel> it's complicated
22:24:55 <accel> there's this diagram with boxes and arrows
22:24:55 <kmc> accel, no shit
22:24:59 <accel> and applicative pointing to monad
22:24:59 <kmc> Haskell is complicated
22:25:02 <accel> and moniod pointing to monad
22:25:05 <accel> and I'm looking at it
22:25:10 <accel> and wondering ... where is the color?
22:25:19 <ray> haskell is easy
22:25:22 <Kaidelong> accel: what about what I said
22:25:23 <Kaidelong> is that complicated?
22:25:53 <djahandarie> A monad is just a monoid in the category of endofunctors, what's the problem?
22:25:58 * hackagebot vector-buffer 0.1.0.2 - A buffer compatible with Data.Vector.Storable  http://hackage.haskell.org/package/vector-buffer-0.1.0.2 (VivianMcPhail)
22:26:02 <accel> Kaidelong: I don't understand it yet.
22:26:03 <dcolish> are some concurrent operations from Control.Concurrent are evaluated lazily?
22:27:05 <dcolish> in my case, if i dont do a readMVar, the value isnt pulled, but it's being bound much earlier
22:27:11 <djahandarie> A monad is just a lax functor from a terminal bicategory, what's the problem?
22:27:27 <Kaidelong> if a functor over a function is an applicative functor there is a function from that applicative functor over that function to a functor over the input of that function to a functor over the output of that functor
22:27:27 <c_wraith> dcolish: the value stored in the MVar is the thunk
22:27:36 <Kaidelong> or
22:27:44 <Kaidelong> f (a -> b) -> f (a) -> f (b)
22:27:44 <c_wraith> dcolish: Unless you explicitly force the value before inserting it into the MVar
22:27:48 <Kaidelong> to be short about it
22:27:59 <dcolish> c_wraith: ok I think that's what is wrong here
22:28:16 <dcolish> when i force the value, the behavior is as expected
22:28:18 <Kaidelong> also all monads are like this since <*> just becomes =<<
22:28:26 <dcolish> the test is slightly bogus imo
22:28:46 <Kaidelong> wait no
22:28:49 <Kaidelong> it doesn't
22:28:53 <c_wraith> <*> is liftM
22:28:58 <c_wraith> err, sorry
22:28:59 <c_wraith> ap
22:29:10 <c_wraith> man, I'm having trouble today
22:29:11 <Kaidelong> @src ap
22:29:12 <lambdabot> ap = liftM2 id
22:29:44 <Kaidelong> so <*> is just liftM2 id
22:29:48 <Kaidelong> easy
22:29:50 <Kaidelong> ...
22:30:32 <ivanm> does anyone know if there's a reason why <+> in wl-pprint doesn't have the empty document as an identity?
22:33:54 <ivanm> (since the one in pretty has that property)
22:35:24 * Kaidelong does not know the library but unless there is some explicit comment saying why that isn't true for <+> that sounds like it is probably a bug
22:42:22 <ClaudiusMaximus> suggestions welcome for improving my graphical user interface: http://claudiusmaximus.goto10.org/g/mandelbrot/gmndl_1-10_11_1-5_56_1-3_169_2-3_508.png
22:42:44 <ivanm> Kaidelong: *nod*
22:43:52 <ClaudiusMaximus> a good start would be for me to label the entry fields, and mark which ones accept input and which ones are for display only...
22:58:48 <byorgey> @tell edwardk that didn't help.  The problem is that in fmapDefault when you call collect (haha) you are using Identity in place of g and the g from fmapDefault as the f of collect.
22:58:48 <lambdabot> Consider it noted.
22:59:21 <byorgey> @tell edwardk hence defining fmapDefault in terms of fmap.  I think it is simply not true that Distributives must be Functors.
22:59:22 <lambdabot> Consider it noted.
23:01:27 <shapr> Has anyone heard of a Haskell implementation of a TCP/IP stack?
23:02:07 <ray> i believe that haskell os project had a network stack
23:02:55 <shachaf> Yep: "A network protocol stack, with basic support for Ethernet, IPv4, ARP, DHCP, ICMP (ping), UDP, TFTP and TCP."
23:03:03 <byorgey> @tell edwardk or if it is true, it is because of some sort of parametricity result, not because it can be constructively implemented
23:03:03 <lambdabot> Consider it noted.
23:03:48 <dainanaki> what's the deal with telling lambdabot stuff?
23:04:23 <shapr> @tell dainanaki It leaves a message that's displayed when that person is next active.
23:04:23 <lambdabot> Consider it noted.
23:04:47 <dainanaki> aha
23:04:48 <lambdabot> dainanaki: You have 1 new message. '/msg lambdabot @messages' to read it.
23:09:08 * hackagebot vector-buffer 0.1.0.3 - A buffer compatible with Data.Vector.Storable  http://hackage.haskell.org/package/vector-buffer-0.1.0.3 (VivianMcPhail)
23:11:33 <Kaidelong> adjunctions remind me of idempotence
23:11:36 <Kaidelong> should they?
23:11:53 <byorgey> definitely
23:12:59 <byorgey> for example, if f and g form a Galois connection (a special case of adjunctions) then f . g and g . f are both idempotent
23:13:24 <byorgey> and I'm sure there is a way to generalize the notion of idempotence so that statement applies to any adjunction
23:13:28 <byorgey> but I don't know what it is
23:14:33 <shapr> The IPv4.hs module in House isn't particularly pretty.
23:14:44 <byorgey> I bet ddarius knows, ask him tomorrow
23:14:54 <Kaidelong> byorgey: that doesn't look right
23:15:11 <Kaidelong> byorgey: nm
23:15:11 <byorgey> Kaidelong: which part?
23:15:13 <Kaidelong> I just got it
23:15:15 <byorgey> ok
23:15:29 <Chaze> @pl (\f g a b -> g b (f a b))
23:15:30 <lambdabot> flip ((.) . ap)
23:16:53 <byorgey> Kaidelong: also see http://blog.plover.com/math/monad-closure.html
23:17:06 <byorgey> monads can be thought of as (idempotent) closure operators
23:17:19 <byorgey> and every monad arises as a composition of adjoint functors
23:22:51 <Chaze> @pl (/f g a b -> g b (f a))
23:22:51 <lambdabot> (line 1, column 2):
23:22:51 <lambdabot> unexpected "/"
23:22:52 <lambdabot> expecting lambda abstraction or expression
23:23:06 <Chaze> @pl (\f g a b -> g b (f a))
23:23:06 <lambdabot> flip ((.) . flip)
23:24:40 <Chaze> @pl (\a b -> 10 * a + b)
23:24:40 <lambdabot> (+) . (10 *)
23:29:24 <Chaze> @pl (\f g-> (f 10) . (g 10))
23:29:25 <lambdabot> (. ($ 10)) . (.) . ($ 10)
23:29:56 <Chaze> @pl (\a f g-> (f a) . (g a))
23:29:57 <lambdabot> ap (flip . (((.) . (.)) .) . flip id) (flip id)
23:31:05 <Kaidelong> @ty (f <$> (. g)) 10
23:31:06 <lambdabot>     No instance for (Show (f b))
23:31:06 <lambdabot>       arising from a use of `f' at <interactive>:1:1
23:31:06 <lambdabot>     Possible fix: add an instance declaration for (Show (f b))
23:31:16 <Kaidelong> > (f <$> (. g)) 10
23:31:17 <lambdabot>   No instance for (SimpleReflect.FromExpr (f a))
23:31:18 <lambdabot>    arising from a use of `Si...
23:31:39 <Kaidelong> > ((+) <$> (. (*))) 10 2
23:31:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
23:31:40 <lambdabot>    arising from a use of `...
23:32:00 <Kaidelong> > (((+) .) <$> (*)) 10 2
23:32:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:32:01 <lambdabot>    arising from a use of `...
23:32:05 <Kaidelong> bah
23:32:07 <Kaidelong> oh
23:32:12 <Kaidelong> > (((+) .) <*> (*)) 10 2
23:32:12 <lambdabot>   Occurs check: cannot construct the infinite type:
23:32:13 <lambdabot>    a = (a -> a1) -> a -> a1
23:32:19 <Kaidelong> > ((+) <*> (. (*))) 10 2
23:32:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
23:32:49 <Kaidelong> well alright then
23:33:14 <Chaze> @pl (\f g x -> f x (g x))
23:33:14 <lambdabot> ap
23:33:33 <Kaidelong> > (((.) . (+)) <*> (*)) 10 2
23:33:35 <lambdabot>   30
23:33:38 <Kaidelong> there we go
23:35:39 <Kaidelong> @ty (<*>) . (((.) .)
23:35:40 <lambdabot> parse error (possibly incorrect indentation)
23:35:44 <Kaidelong> @ty (<*>) . ((.) .)
23:35:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Functor f1) => f (a -> b) -> f (f1 a) -> f (f1 b)
23:36:03 <Kaidelong> @ty (<*>) . ((Prelude.) .)
23:36:03 <lambdabot> Not in scope: data constructor `Prelude'
23:36:08 <Kaidelong> @ty (<*>) . ((Prelude..) .)
23:36:09 <lambdabot> forall (f :: * -> *) b c a. (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
23:36:52 <Kaidelong> @ty (<*>) . ((.) .) $ (+) (*) 10 2
23:36:53 <lambdabot> forall a b (f :: * -> *). (Functor f, Num b) => ((a -> b) -> f a) -> (a -> b) -> f b
23:36:59 <Kaidelong> > (<*>) . ((.) .) $ (+) (*) 10 2
23:37:00 <lambdabot>   Overlapping instances for GHC.Show.Show
23:37:00 <lambdabot>                              (((a -...
23:37:37 <Kaidelong> > ((<*>) . ((.) .)) (+) (*) 10 2
23:37:39 <lambdabot>   30
23:37:55 * Kaidelong notes that this is a good argument against not sleeping
23:38:35 <Kaidelong> ((<*>).((.).))
23:38:48 <Kaidelong> is shorter than what lambdabot showed you with PL though, Chaze
23:39:07 <Kaidelong> (and more general)
23:39:38 <Chaze> Kaidelong: i wasn't actually using that, i was just checking if i was overseeing something simple
23:46:59 <dainanaki> > round $ 0.83 * (18000 * 1732 + 23500 * 2691)
23:47:00 <lambdabot>   78364035
