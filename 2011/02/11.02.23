00:06:03 <bicilotti> good morning haskellers
00:06:26 <bicilotti> I have some problems understanding the => a -> b -> a 
00:06:58 <bicilotti> I know how + and ^ work in real life, for example, but I am not sure hot wo read |=> a -> b -> a|
00:07:33 <sipa> "bla =>" gives a constraint on types
00:07:44 <bicilotti> (reading RAH chap 1, btw)
00:08:37 <aristid> bicilotti: there's usually something to the left of =>
00:09:10 <bicilotti> (^) :: (Num a, Integral b) => a -> b -> a 	-- Defined in GHC.Real
00:09:14 <bicilotti> ^-- for example
00:09:32 <bicilotti> we all know that 3^2^8 is 3^(2^8)
00:09:51 <bicilotti> I bet what I've pasted expresses the same thing
00:09:59 <sipa> no
00:10:00 <bicilotti> I just don't know how tor read it :P
00:10:03 <bicilotti> oh
00:10:04 <bicilotti> sorry
00:10:19 <sipa> it just gives the types
00:10:41 <sipa> of what you can give to ^
00:10:50 <aristid> and what it returns
00:11:07 <sipa> but take an easier example
00:11:17 <sipa> :t (+)
00:11:18 <lambdabot> forall a. (Num a) => a -> a -> a
00:11:30 <bicilotti> oh oh my first mistake, great! :D 
00:11:42 <aristid> you only learn from mistakes ;)
00:11:58 <sipa> it says that for any type a, you give it two a's
00:12:04 <bicilotti> ok, so where it is expressed the ltr or rtl precedence?
00:12:16 <sipa> and get an a back
00:12:25 <bicilotti> sipa, crystal clear!
00:12:32 <sipa> that's stated separately
00:12:45 <sipa> in the fixity declaration
00:12:57 <bicilotti> doh
00:13:15 <bicilotti> "Pen> " :info : (+)
00:13:17 <bicilotti> data [] a = ... | a : [a] 	-- Defined in GHC.Types
00:13:19 <bicilotti> infixr 5 :
00:13:20 <bicilotti> class (Eq a, Show a) => Num a where
00:13:21 <bicilotti>   (+) :: a -> a -> a
00:13:23 <bicilotti>   ...
00:13:25 <bicilotti>   	-- Defined in GHC.Num
00:13:26 <bicilotti> infixl 6 +
00:13:28 <bicilotti> so I cannot judge that from here, right ?
00:13:31 <bicilotti> (sorry for the paste dump, mispasted)
00:13:36 <sipa> you can
00:13:40 <bicilotti> :D
00:13:46 <sipa> infixr
00:13:47 <bicilotti> enlighten me, sipa =)
00:14:28 <sipa> that means it is right associative 
00:14:55 <sipa> and 6 is the precedence
00:14:57 <bicilotti> DOH
00:15:00 <bicilotti> now I get it
00:15:16 <bicilotti> thankee
00:29:04 <bicilotti> let me bother you again
00:29:21 <bicilotti> I read that ** is like ^ when the base is not an integral, right?
00:29:36 <aristid> :t (**)
00:29:36 <lambdabot> forall a. (Floating a) => a -> a -> a
00:29:48 <aristid> @instances Floating
00:29:48 <lambdabot> Double, Float
00:29:50 <bicilotti> :info (**) looks unintelligible though
00:30:33 <aristid> it's (Floating a) => a -> a -> a, and infixr 8
00:30:55 <aristid> so it only works on Float and Double
00:33:20 <bicilotti> great, thanks
00:52:44 <mux> http://i.imgur.com/ZyeCO.jpg
00:53:30 <mux> someone should probably add a Haskell one, such as, "I don't understand what that is but it is incredibly elegant"
00:54:58 <vegai> how about "It's only two pages, and I have no idea what you're saying."
00:55:05 <vegai> right after Java
00:55:23 <vegai> or "I'm two sentences in, and..."
00:55:36 <mux> or "Is that all?! Seriously, 20 lines?"
00:56:01 <vegai> "AAAGHH THE BEAUTY IT BURNS MY EYES"
00:56:37 <vegai> "Where can I find cheap resources who can understand all this?"
00:57:07 <ski> @instances-importing Data.Complex Floating
00:57:07 <lambdabot> Complex a, Double, Float
01:31:24 <earthy> "I asked you for an essay, not poetry!"
01:35:23 <jonkri> earthy: :)
01:35:28 <jonkri> good one
01:36:12 <Entroacceptor> "to understand it, you have to read this, that, and this whole box of papers first"
01:37:13 <bicilotti> I know this isn't 100% haskell related but: the tutorial I am reading asked me to run runghc WC < foo.txt from a shell
01:37:33 <bicilotti> which in winxp meant  doing a lot of cd folder\etc
01:38:11 <bicilotti> do you know if there's a way to open a command line directly from a folder (i.e. without having to manually type the address)?
01:38:19 <bicilotti> or if there's a simpler solution?
01:38:47 <quicksilver> well, I'd leave a command line permanently open in the directory you're working in...
01:38:53 <earthy> http://www.microsoft.com/windowsxp/downloads/powertoys/xppowertoys.mspx <- install these
01:39:08 <earthy> that gives you 'Open Command Window Here'
01:40:10 <Botje> bicilotti: why not move your haskell stuff into your home directory?
01:40:20 <Botje> bicilotti: also, have you tried dragging and dropping a folder onto your terminal window?
01:40:30 <Botje> maybe it will paste in the path
01:40:58 <whald> can someone here please help me to interpret a small snippet of Core? it's here: http://hpaste.org/44231/components_core
01:42:07 <bicilotti> thanks Botje it worked
01:42:20 <bicilotti> and earthly and quicksilver too
01:42:35 <whald> i already bugged people here with this yesterday evening, noone knows why it's so slow and does so many allocations
01:42:54 <whald> looking at the core i see nothing suspicious and several thing i don't understand
01:44:51 <whald> looking at the GHC profiling data it eats ~20% of my cpu and does ~12% of all allocations. i don't understand why it does allocations at all
01:45:11 <whald> it should only extract a component from a vector in R3
01:51:11 <bicilotti> sin(pi) 1.2246063538223773e-16 <-- that's because of float extrrrrrrrrrrravaganza, right?
01:51:43 <Botje> yup
01:51:59 <bicilotti> sin(pi) == 0 //False :(
01:52:14 <bicilotti> (no worries, floats are troublesome everywhere)
01:52:57 <quicksilver> I'm not sure that's really because of floating point.
01:53:07 <bicilotti> quicksilver: then why?
01:53:18 <quicksilver> it's because 'sin' is a transcendental function and 'pi' is a transcendental value
01:54:14 <quicksilver> however you represent your numbers it's going to be hard to get sin(pi) == 0.
01:54:43 <quicksilver> because sin is going to be implemented either as an infinite computation or an approximation. 
01:55:50 <Tomsik> Sins transcend our computers!1!!
01:56:09 <bicilotti> thanks quicksilver 
02:02:08 <bicilotti> very good, chapter one done, thanks for your help!
03:14:10 <dancor> how is there an Eq CReal instance
03:14:37 <dancor> computable-real equality is not computable right?
03:15:43 <dancor> "The equality relation on computable real numbers is not computable" http://en.wikipedia.org/wiki/Computable_analysis
03:16:54 <quicksilver> dancor: it's approximate equality
03:16:58 <quicksilver> to 50 dps, IIRC.
03:17:34 <dancor> digits = 40
03:17:57 <dancor> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/src/Data-Number-CReal.html#CReal
03:18:00 <dancor> crazy.
03:18:40 <dancor> well it's certainly not the purest possible computable-real library
03:21:20 <Blkt> good day everyone
03:47:01 <TPJ> Hello. Is there anyone who uses the Snap framework?
03:48:51 <Entroacceptor> no, snap users don't exist
03:49:39 <TPJ> Perhaps cabal users could help too... ;-)
03:50:35 <TPJ> I'm trying to install (upgrade) snap, and I have problems with upgrading the haskell98 package.
03:51:37 <TPJ> I can do "cabal upgrade haskell98" without any problems.
03:51:37 <TPJ> But when I try to "cabal upgrade snap", it tries to upgrade haskell98 and it fails.
03:51:37 <TPJ> And I don't understand why.
03:51:57 <Entroacceptor> ugh...
03:52:12 <Entroacceptor> every time I encounter stuff like that I just rm -rf .ghc
03:52:47 <luite> TPJ: I think you shouldn't use cabal upgrade, especially not with packages like haskell98. You probably want something like cabal install snap-0.4
03:53:10 <Peaker> If I have a ForeignPtr, how do I typically use it?  Do I have some top-level do a "withForeignPtr" on it, and use it as a Ptr everywhere? Why was ForeignPtr distinguished from a Ptr? Why not Ptr = ForeignPtr with (const (return ())) as its action?
03:53:40 <Peaker> Why does snap use haskell98?  Stop importing non-hierarchial names..
03:54:19 <TPJ> When I try to install snap, it tries to upgrade haskell98, and then fails. I tried to upgrade haskell98 just because of this failure...
03:54:44 <TPJ> I'll try this trick with .ghc...
03:54:59 <ocharles> @src [] (>>=)
03:54:59 <lambdabot> xs >>= f     = concatMap f xs
03:55:09 <ocharles> @src concatMap
03:55:09 <lambdabot> concatMap f = foldr ((++) . f) []
03:55:43 <ocharles> so [] as a monad acts like applicative lists, that is - non-deterministic computations?
04:01:57 <TPJ> WOW, it worked! Removing .ghc solved my problem.
04:01:57 <TPJ> Perhaps it's a common trick... Well, I learned the lesson and I won't ask such a questions before checking it in the future.
04:01:57 <TPJ> Thank you very much!
04:02:44 <TPJ> BTW, I'm a Haskell newbie, so I do realize that my questions might be silly.
04:03:37 <Eduard_Munteanu> Entroacceptor: that really sounds like the Microsoft way of fixing things :P
04:03:48 <luite> hmm, removing .ghc really shouldn't be necessary in general, except as a last resort.
04:04:09 <Entroacceptor> Eduard_Munteanu: till someone tells me a better, faster or easier way...
04:04:56 <Entroacceptor> I've spend hours trying to fix it
04:05:19 <Entroacceptor> so I thought "recompiling doesn't take nearly that long"
04:05:42 <Entroacceptor> maybe I'm doing something wrong to mess up my local packages all the time
04:05:43 <Eduard_Munteanu> Yeah, joke's on GHC though :)
04:07:56 <b52> hey, if i create an udp socket using Network.Socket, does it have a default port already?
04:08:13 <luite> I have to admit that I use it all too often myself, reinstalling is just quicker, especially if your own packages are cabalized
04:09:15 <jonkri> is there a way i can "hide" HLoggerState so that nothing external to this module can modify/create an instance, yet allow a HLoggerState to be passed around in external modules? https://patch-tag.com/r/jonkri/HLogger/snapshot/current/content/pretty/HLogger.hs
04:13:43 <luite> jonkri: yes, you just use  module HLogger (HLoggerState) where
04:14:03 <luite> jonkri: if you export HLoggerState(..), you also export the constructors
04:15:07 <luite> but without the (..), you can determine yourself what the user has access to
04:19:00 <jonkri> luite: sweet beans! thanks :)
04:24:05 <ocharles> anyone know of any articles that explain how to derive the reader monad?
04:24:47 <pastorn> ocharles: how does your monad look now?
04:24:55 <ocharles> I've got "return x = \_ -> x" so far, but I can't figure out >>=
04:25:12 <jonkri> ocharles: my advice: make sure you fully understand functor, applicative functors, monads and newtype first
04:25:23 <ocharles> jonkri: I understand those, i'm working on monads now
04:25:31 <ocharles> I get the maybe, io and list monads fine
04:25:37 <jonkri> ok :)
04:25:39 <ocharles> oh, and state
04:26:25 <pastorn> ocharles: so you want to make an instance for ((->) r) ?
04:26:27 <Peaker> how do I get Haskell actions to run in the finalizer of a ForeignPtr?
04:26:45 <pastorn> Peaker: withForeignPtr?
04:26:47 <ocharles> and I have the signatures for the reader monad: return :: a -> (e -> b), (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
04:26:56 <ocharles> but I can't seem to figure out anything that will get me there
04:26:59 <ocharles> pastorn: right
04:27:00 <Peaker> pastorn, No no, I want to create a ForeignPtr
04:27:08 <Peaker> pastorn, and the finalizer is a FunPtr, not an IO () thingie
04:28:13 <ocharles> I assume the point of the reader monad is like threading a variable through a whole computation, where the value doesn't change between computations
04:28:28 <pastorn> Peaker: i got one from ByteString.Internal
04:29:03 <pastorn> ocharles: exactly, except for 'local'
04:29:39 <pastorn> ocharles: i might reccomend you do a non-shallow reader first
04:29:49 <ocharles> ok, what's non-shallow?
04:30:06 <pastorn> ocharles: newtype Env e a = Env { runEnv :: (e -> a) }
04:30:28 <ocharles> is that not the same as newtyp Reader e a = Reader { runReader :: (e -> a) } ?
04:30:33 <ocharles> except without typos :)
04:30:35 <pastorn> ocharles: well, that's actually pretty deep too
04:33:45 <pastorn> http://hpaste.org/44234/monadstyles <-- ocharles 
04:33:50 <ocharles> ooo, I think I've got it!
04:33:53 * ocharles tries this
04:33:56 <ClaudiusMaximus> Peaker: foreign import ccall "wrapper" myIO2FunThing :: IO () -> IO (FunPtr (IO ())) -- perhaps ?  (i'm not 100% sure, s'been a while since i fiddled with that kind of thing)
04:33:59 <quicksilver> Peaker: you can't run haskell actions from finalizers because finalizers run during the GC and that's not a safe time for haskell code to run.
04:34:34 <ClaudiusMaximus> ah, good point...
04:34:45 <Peaker> quicksilver, ah, for a bit of a penalty it could remain reachable and be run after GC?
04:34:45 <pastorn> ocharles: please note that the really shallow style is only possible for just the Reader monad
04:34:55 <pastorn> you can't really do that for any other monads
04:35:01 <quicksilver> Peaker: ignore that, I'm wrong.
04:35:14 <quicksilver> Peaker: http://www.mail-archive.com/haskell-cafe@haskell.org/msg30939.html ;)
04:36:55 <Eduard_Munteanu> pastorn: what's the difference there, really?
04:37:16 <Eduard_Munteanu> Just leaving out some wrappers?
04:37:40 <Eduard_Munteanu> Though DeepReader looks intriguing.
04:37:57 <Peaker> quicksilver, thanks
04:38:05 <pastorn> Eduard_Munteanu: the deep version is much more extendable
04:38:44 <pastorn> Eduard_Munteanu: and you only need to add constructors and lines in your run-function to extend it... the monad instances are dead simple
04:44:14 <pastorn> Eduard_Munteanu: didn't try it, but here it is: http://hpaste.org/paste/44234/monadstyles_annotation#p44235
04:50:26 <donri> Trying [1..ceiling $ sqrt n] where n is a Num, which throws type errors that no signature I can invent fixes
04:51:09 <donri> works in ghci
04:51:51 <Eduard_Munteanu> pastorn: ah, thanks.
04:52:06 * Eduard_Munteanu adds it to the "niceties about GADTs" list :)
04:52:28 <pastorn> donri: works for me...
04:54:36 <pastorn> donri: you might want parenthenses around the 2nd expression there
04:55:10 <donri> Ambiguous type variable `t'
04:55:26 <Eduard_Munteanu> > [1..ceiling $ sqrt n]
04:55:27 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
04:55:27 <lambdabot>    arising from a us...
04:55:34 <Eduard_Munteanu> :t ceiling
04:55:35 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
04:55:50 <Eduard_Munteanu> > [1..ceiling . sqrt $ n]
04:55:51 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
04:55:51 <lambdabot>    arising from a us...
04:56:13 <Eduard_Munteanu> > [1..(ceiling . sqrt $ n)]
04:56:14 <pastorn> donri: fixate it with a type signature then :)
04:56:14 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
04:56:14 <lambdabot>    arising from a us...
04:56:33 <donri> pastorn: just don't know what signature
04:56:47 <pastorn> > (\n -> [1 .. ((ceiling $ sqrt n) :: Int)]) 9
04:56:48 <lambdabot>   [1,2,3]
04:56:49 <Eduard_Munteanu> > [1..(ceiling . sqrt $ n)] :: [Int]
04:56:50 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
04:56:50 <lambdabot>    arising from a us...
04:57:05 <ocharles> yay, I derived the reader monad at last
04:57:16 <pastorn> ocharles: cool, paste?
04:57:29 <ClaudiusMaximus> > let n :: Int ; n = 42 in [1 .. ceiling . sqrt . fromIntegral $ n ]
04:57:31 <lambdabot>   [1,2,3,4,5,6,7]
04:57:33 <ocharles> turning point came when I realised that a monad chain's computations, so I need to run the first computation in the environment first
04:57:36 <ocharles> pastorn: just x >>= f = \e -> f (x e) e
04:57:41 <ocharles> now I can read your paste :)
04:58:39 <Eduard_Munteanu> Hrm, how come pastorn's works?
04:58:56 <pastorn> Eduard_Munteanu: i actually make use of the 'n'
04:59:07 <pastorn> Eduard_Munteanu: :p
04:59:24 <Eduard_Munteanu> Heh. But I used an ascription as well, hrm...
04:59:30 <donri> ClaudiusMaximus: thanks :)
04:59:34 <Eduard_Munteanu> That should be the same thing.
04:59:38 <fryguybob> @type n
04:59:39 <lambdabot> Expr
04:59:51 <fryguybob> > n + 1
04:59:52 <lambdabot>   n + 1
04:59:59 <Eduard_Munteanu> @type foobarbazboof
05:00:00 <lambdabot> Not in scope: `foobarbazboof'
05:00:10 <Eduard_Munteanu> Oh, what trickery is that...
05:00:28 <fryguybob> @hackage simple-reflect
05:00:28 <lambdabot> http://hackage.haskell.org/package/simple-reflect
05:07:07 <pastorn> ocharles: you understand my paste a bit better now?
05:07:36 <ocharles> pastorn: yea, I think so
05:07:45 <ocharles> though why GADTs are needed is beyond me for now
05:08:00 <ocharles> but I won't be learning about them until they actually have a use (and I can use them)
05:14:17 <pastorn> ocharles: otherwise i couldn't force the type signature for (:>>=)
05:19:27 <ksf_> anyone else willing to put up a 500 karma bounty on http://stackoverflow.com/questions/5057136/real-world-applications-of-zygohistomorphic-prepromorphisms ?
05:20:03 <ksf_> I'm just asking because doing it myself would bring me down to 213, as I don't circlejerk with the c++ guys.
05:21:46 <ezyang> What would it be for? :-) 
05:22:06 <ksf_> coming up with an application for zygohistomorphic prepromorphisms.
05:22:25 <ksf_> I want to write "this is the idiomatic way to do foo" into the wiki.
05:23:28 <Eduard_Munteanu> I hope those won't be trivially coaxing the beast into doing the job.
05:23:28 <tobias___> hi, can anyone give me a hint why this recursion would stack overflow? http://hpaste.org/44236/stack_overflow
05:23:40 <ksf_> if nobody comes up with anything in the seven days, I'd adward the karma to edwardk's answer.
05:23:40 <tobias___> it looks tail recursive to me
05:24:00 <ksf_> tail recursion isn't necessarily a good idea.
05:24:22 <ksf_> haskell's stack looks vastly different from those of strict languages.
05:24:28 <ezyang> I can prolly spare 500 bounty, but I am reasonably happy with stephen tetley's answer. 
05:24:50 <ksf_> hmmm add some !s to rng c and sum
05:25:11 <dafis> tobias___: your values aren't evaluated on the spot
05:25:24 <ksf_> ezyang, his answer isn't elegible.
05:25:35 * frerich feels really stupid because he thought "zygohistomorphic preopromorphism" was just a joke on buzzwords or something, and now it turns out that it's not...
05:25:38 <ksf_> he's pointing to a mere zygomorphism.
05:25:43 <tobias___> dafis: so you think my "value" are the problem?
05:25:44 <ezyang> Oh, I see. 
05:25:51 <phrackSipsin> Would anyone mind helping me with why this returns an incorrect indentation error: http://hpaste.org/44237/incorrectindentation
05:25:53 <koala_man> is the last operation there "integrate'" or ">>="?
05:26:06 <ezyang> How about 400 bounty? :-) 
05:26:06 <ksf_> tobias___, most likely, yes. you're building up thunks, not evaluating them as you go.
05:26:13 <ksf_> the only way to be sure is to look at the core.
05:26:25 <tobias___> ksf_: ah, adding ! to rng c and sum solved it
05:26:58 <tobias___> indeed ! before sum is enough
05:27:05 <tobias___> so it's the value
05:27:08 <ksf_> :t mfoldl'
05:27:09 <lambdabot> Not in scope: `mfoldl''
05:27:11 <ksf_> :t mfoldl
05:27:12 <lambdabot> Not in scope: `mfoldl'
05:27:14 <ksf_> hmmm.
05:27:19 <tobias___> I have tried to do value `seq` integrate' before, but that didn't work 
05:27:47 <tobias___> seems that the problem is still the sum+value
05:27:57 <dafis> tobias___: that would still build a thunk for the sum
05:28:08 <tobias___> yeah, just noticed - thanks :>
05:28:15 <dafis> yes, the sum needs to be kept evaluated (too)
05:28:25 <ksf_> ghc's strictness analyser is good, but it's not perfect.
05:28:59 <saml> you need haskell help?
05:29:10 <ezyang> posted +300 bounty 
05:29:15 <ezyang> cyall 
05:29:18 <ksf_> in general, stack overflows mean that you're building up computations.
05:29:39 <ksf_> ...and then blow the stack forcing them, as the evaluator has to walk down the spine, and start from the inside.
05:29:47 <ksf_> ezyang, thanks
05:32:23 <dankna> aw, it's +300 reputation, not +300 dollars :)
05:32:47 <dankna> I would totally spend a few hours coming up with a solution, but who cares about meaningless reputation points, haha
05:33:14 <ksf_> +300 gives you many privileges, instantly.
05:33:19 <dankna> hmm
05:33:56 <dafis> ksf_: like?
05:33:58 <ksf_> http://stackoverflow.com/privileges
05:34:03 <ksf_> up to "view close votes"
05:34:44 <dankna> actually, that looks nice
05:34:53 <ksf_> anyway, it's for hack value.
05:34:54 <dankna> I could use that rep to be a grammar nazi
05:34:55 * hackagebot compdata 0.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.1 (PatrickBahr)
05:35:17 <dankna> yeah, it looks like a fun way to warm up while I'm waiting for people to show up in #ghc so I can ask them to merge my patch that isn't ready yet but is so bit I'm afraid it will bitrot before it is :)
05:35:52 <dankna> (the diff is 6700 lines, which means I probably touched half that many)
05:39:26 <dankna> hey I think I may have one!
05:39:39 <dafis> dankna: namely?
05:39:39 <dankna> I need to check whether it is one though, which means I need to understand that type signature haha
05:39:53 <dankna> unpacking ambiguity-packed parse forests after a GLR parse
05:40:31 * dafis versteht Bahnhof
05:40:37 <dankna> (unfortunate name, since *LR names generally refer to parse-table-generation algorithms, but GLR is an algorithm for running a push-down-automaton nondeterministically)
05:41:48 <ksf_> that sounds like a cool topic for a particular hilarious functional pearl.
05:42:00 * dankna nods
05:43:31 <dankna> but I can't write a functional pearl, because they are published traditionally in peer-reviewed papers and I have no credentials :)
05:43:45 <dankna> s/papers/journals/
05:43:54 <dankna> I mean, I suppose I could write one, but.
05:43:55 <ksf_> that's simple, get a co-author that has them.
05:44:00 <dankna> that's true
05:44:26 <dankna> in here, that ought to be the easy part, haha
05:45:03 <ksf_> for additional lulz, publish it on the 1st of april
05:45:09 <dankna> hehe
05:45:15 <dankna> ever seen the Journal of Irrepreducible Results?
05:45:23 <ksf_> nope
05:45:30 <dankna> it published humor pieces
05:45:39 <dankna> evolutionary histories of the common paperclip
05:45:48 <dankna> recipies for baking chi-squares to feed large groups of statisticians
05:46:11 <dankna> I think it's still around, but I saw it in the 90s
05:46:55 <dankna> http://icfp06.cs.uchicago.edu/bird-talk.pdf -- is this upside-down for everyone or just me?
05:47:31 <sy`> dankna: It is.
05:47:40 * dankna uses the "two-finger rotate page" gesture in Preview.app for the first time
05:47:58 <sy`> lol
05:48:15 <sy`> I hate it when pdfs are sideways.
05:48:19 <dankna> me too
05:48:32 <ksf_> or postscript output.
05:48:37 <ksf_> like the one hp2ps produces.
05:49:05 <dankna> it has bookmarks in it though, I give it credit for that
05:49:18 <sy`> Now I'm learning about the history of the pearl
05:49:22 <ksf_> luckily, gv can take an orientation parameter on the commandline.
05:49:32 <dankna> hah, yes, but I'm on a Mac :(
05:49:34 <ksf_> also saves me from passing -colour to hp2ps
05:49:59 * hackagebot Pathfinder 0.5.3 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.5.3 (GeorgeGiorgidze)
05:50:26 <ksf_> even better, tohugh, okluar *remembers* the orientation.
05:50:32 <ksf_> and position in the file.
05:50:56 <sy`> i like evince
05:50:59 * hackagebot DSH 0.5.3 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.5.3 (GeorgeGiorgidze)
05:51:07 <dankna> Preview gives you the option to re-save the file with your orientation changes applied
05:51:27 <dankna> it does not remember your position in the file automatically, but has a bookmarks menu for doing so manually
05:52:24 <ksf_> okular is actually the best kde program there is.
05:52:41 <dankna> oh?
05:52:44 <ksf_> that is, it uses all those nifty kdelib features without getting on your nerves.
05:52:51 <sy`> I could never get my mind around KDE.
05:52:55 <ksf_> and doesn't tend to crash, like the rest of kde.
05:53:17 <dafis> ksf_: my kde crashes very rarely
05:53:18 <dankna> that is nice
05:53:25 <sy`> I can't survive without stumpwm... 
05:53:30 <dankna> my kde crashes never, because I don't actually have one
05:54:24 <ksf_> if the zygo paper is to be a pearl, I think it would have to have building up recursion schemes as a topic.
05:54:37 <ksf_> that is, the obvious co-author would be edwardk.
05:54:41 <dankna> hmm
05:54:42 <dankna> true
05:54:57 <quicksilver> "The Obvious Co-author" would be a good title.
05:55:04 <sy`> lol
05:55:26 <dankna> reminds me of that Larry Niven short story - "Rotating Cylinders and the Possibility of Global Causality Violation"
05:55:37 <dankna> I'm not sure I feel up to writing it as a pearl, but if it IS a zhmppm, I'd like to at least get stackoverflow credit for it :)
05:59:09 <ksf_> while kde is pretty useable without kwin, you absolutely need to use the kicker or what was all that desktop punk called.
05:59:20 <ksf_> I couldn't even figure out how to start the config dialog via dbus.
05:59:45 <dankna> heh
05:59:49 <dankna> kicker?
05:59:55 <sy`> I just don't think my brain is wired to use KDE.
06:00:05 <sgronblo> Is there a pre-existing function in haskell that does f l = [[e] | e <- l] ?
06:00:16 <dafis> sgronblo: map return
06:00:21 <ksf_> the main panel / stat button thingie. pre 4.0, though.
06:00:32 <dankna> ahh
06:00:41 <ksf_> nowadays it's called plasma.
06:00:43 <sgronblo> doesn't return return an IO object?
06:00:44 <sy`> kicker always crashed when I used KDE
06:00:59 <sgronblo> or is that only in do blocks?
06:01:00 <dafis> sgronblo: any Monad, can be IO, Maybe, [], ...
06:01:18 <dafis> sgronblo: to fix the type, map (:[])
06:01:29 <dankna> note that your code will misbehave if you give it the wrong type signature, due to the polymorphism of return
06:01:33 <dankna> hence dafis's advice
06:01:49 <sgronblo> dafis: I haven't gotten to the monads yet
06:01:53 <ksf_> :t map pure
06:01:54 <lambdabot> forall a (f :: * -> *). (Applicative f) => [a] -> [f a]
06:01:59 <dankna> (being in the wrong monad leads to hilarious misbehavior)
06:02:02 <Peaker> sgronblo, Do you know type-classes?
06:02:09 <ksf_> :t map pure ::  [a] -> [[a]]
06:02:10 <lambdabot> forall a. [a] -> [[a]]
06:02:16 <dafis> > map return [1 .. 5] ::[[Int]]
06:02:16 <lambdabot>   [[1],[2],[3],[4],[5]]
06:02:34 <dafis> > map return [1 .. 5] ::[Maybe Int]
06:02:34 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
06:02:47 <anincog> Hi. I'm trying to do something involving type-level naturals, and I'm a bit confused regarding conversion into actual naturals (or Int, for simplicity in my case). Here's my first attempt, working just fine http://hpaste.org/44238/type_level_naturals_working .
06:02:50 <dankna> map return [1 .. 5] :: [(Int, Int)]
06:02:51 <dafis> :t map (:[])
06:02:52 <lambdabot> forall a. [a] -> [[a]]
06:02:55 <dankna> > map return [1 .. 5] :: [(Int, Int)]
06:02:56 <lambdabot>   No instance for (GHC.Base.Monad ((,) GHC.Types.Int))
06:02:56 <lambdabot>    arising from a use ...
06:02:59 <dankna> hah okay
06:03:11 <ksf_> anincog, that looks correct.
06:03:13 <anincog> Then I tried to make the conversion into Int tail-recursive, http://hpaste.org/44239/type_level_naturals_not_worki , and now I get complaints from GHC regarding infinite types... I'm confused :)
06:03:44 <anincog> ksf_: Am I doing something stupid in the second version, as far as you can see?
06:03:49 <dankna> please annotate pastes in future rather than making multiple ones
06:03:53 <dankna> I'm reading it now though
06:04:00 <anincog> dankna: Sorry, I will :)
06:04:05 <dankna> np, just telling you :)
06:04:17 <ksf_> anincog, yes, you're producing an endless loop.
06:04:20 <anincog> oh and ignore the import in the beginning of the second paste, of course :)
06:04:30 <ksf_> toNat' isn't an typeclass method.
06:04:35 <dafis> anincog: probably toNat' needs a type signature since it uses polymorphic recursion
06:04:37 <ksf_> you're never hitting any bottom case.
06:04:42 <anincog> aah
06:04:47 <anincog> of course, that makes sense
06:04:59 <anincog> thanks, guys :)
06:05:06 <sgronblo> but was there anything wrong with using the nice list comprehension I showed in my original question? my main point was not about how it can be implemented more efficiently but rather if haskell comes bundled with a function that splits a list into a list of lists with each element in its own list?
06:05:27 <dankna> sgronblo, there was nothing wrong with the list comprehension per se.
06:05:51 <dankna> sgronblo, "map return" is neither more nor less efficient - should be precisely as efficient.  it's just that you may find one form or the other more /readable/.
06:06:36 <ksf_> :t (. (.)) :: [a] -> [[a]]
06:06:37 <lambdabot>     Couldn't match expected type `[a]'
06:06:37 <lambdabot>            against inferred type `a1 -> [a]'
06:06:37 <lambdabot>     In the expression: (. (.)) :: [a] -> [[a]]
06:06:41 <ksf_> :t (.)
06:06:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:06:49 <dafis> sgronblo: the difference is that you can use `map return' as an argument to a higher order function, while you can't do it with a list comprehension
06:06:49 <ksf_> ah doh.
06:06:58 <ksf_> :t (. pure) :: [a] -> [[a]]
06:06:59 <lambdabot>     Couldn't match expected type `[a]'
06:06:59 <lambdabot>            against inferred type `a1 -> [a]'
06:06:59 <lambdabot>     In the expression: (. pure) :: [a] -> [[a]]
06:07:05 <ksf_> :t (pure .) :: [a] -> [[a]]
06:07:06 <lambdabot> forall a. [a] -> [[a]]
06:07:45 <Peaker> :t (pure Prelude..)
06:07:46 <lambdabot> forall b (f :: * -> *) a. (Applicative f) => (a -> b) -> a -> f b
06:10:02 <ksf_> anincog, you might want to try using type families for arithmetic.
06:10:02 <anincog> ksf_, dafis: With a type signature for toNat' everything works out beautifully. Thanks a lot :)
06:10:44 <anincog> ksf_: I was thinking about it, yes, but I haven't quite seen the light yet.
06:10:57 <ksf_> ...and note that in general, tail recursion doesn't buy you anything in haskell
06:11:09 <Peaker> it does for strict thingies
06:11:13 <sgronblo> I just tried map return "blargh" in ghci, but got some whine about monads in return for it
06:11:40 <ksf_> and I'd dare to wager that ghc is evaluating those nats at compile-time, anyway.
06:11:50 <pastorn> sgronblo: yeah, probably it doesn't know which monad you want to lift it to
06:12:12 <pastorn> > map return "blargh"
06:12:13 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
06:12:13 <lambdabot>    arising from a use of...
06:12:19 <pastorn> > map return "blargh" :: [Maybe Char]
06:12:19 <lambdabot>   [Just 'b',Just 'l',Just 'a',Just 'r',Just 'g',Just 'h']
06:12:26 <pastorn> > map return "blargh" :: [[Char]]
06:12:27 <lambdabot>   ["b","l","a","r","g","h"]
06:12:40 <pastorn> sgronblo: ^^^
06:12:46 <sgronblo> but with my list comprehension I didn't hav eto specify any monads
06:13:00 <ksf_> becaues list comprehensions are by default restricted to lists
06:13:01 <pastorn> yes, because it knows what to do then :)
06:13:20 <zygoloid> > Data.Traversable.sequence (Just "blargh")
06:13:21 <lambdabot>   [Just 'b',Just 'l',Just 'a',Just 'r',Just 'g',Just 'h']
06:13:35 <pastorn> > [ Just x | x <- "blargh" ]
06:13:36 <lambdabot>   [Just 'b',Just 'l',Just 'a',Just 'r',Just 'g',Just 'h']
06:13:49 <ksf_> > join (map return "blargh :: [[Char]])
06:13:49 <pastorn> > [ return x | x <- "blargh" ] -- i bet this will fail
06:13:50 <lambdabot>   <no location info>:
06:13:50 <lambdabot>      lexical error in string/character literal at end o...
06:13:50 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
06:13:50 <lambdabot>    arising from a use of...
06:13:56 <ksf_> > join (map return "blargh" :: [[Char]])
06:13:57 <lambdabot>   "blargh"
06:13:59 <anincog> ksf_: You mean à la the "faking it" paper, right? (Regarding type level arithmetic)
06:15:17 <sgronblo> so this means that haskell does NOT have a function that does this, and that I have to define it myself every time?
06:15:20 <ksf_> anincog, http://hpaste.org/44240/typenats
06:15:39 <ksf_> (note that Mul needs undecidable instances because of the nested call)
06:15:51 <ksf_> (ghc isn't smart enough to see that it's a structural recursion)
06:15:51 <dankna> sgronblo, well, I mean, you could define a function that does it if you need to do it a lot.  the hard part is coming up with a good name!
06:16:31 <anincog> ksf_: Wow, thanks :) 
06:18:39 <ksf_> anincog, you might also be interested in http://hackage.haskell.org/trac/ghc/wiki/TypeNats , which is coming soon.
06:19:09 <ksf_> should probably be in HEAD by now.
06:19:51 <dankna> what's a good name for a fixed-point type with 1 sign bit, 15 bits before the binary point, and 16 bits after the binary point?
06:19:59 <dankna> I am considering Fixed32 and Fixed16Dot16
06:19:59 <dancor> sgronblo: are you asking if there is something shorter for: map (:[])
06:20:14 <ksf_> Int15d15, yes.
06:20:28 <dankna> oh, single lowercase d for the separator, that could work
06:20:31 <anincog> ksf_: Thanks for the tip
06:20:37 <dankna> I do think I prefer Fixed rather than Int - it's not an Int :)
06:20:48 <ksf_> well, it most cernainly isn't a word.
06:20:55 <ksf_> int is saying that it's signed.
06:21:03 <dankna> I see that, but it's not integral!
06:21:15 <ksf_> well, sure it is.
06:21:26 <ksf_> it's certainly not floting.
06:21:32 <dankna> yeah, it's fixed-point :)
06:21:38 <dankna> hence my word Fixed
06:21:49 <dankna> I agree that the loss of information on its signedness is unfortunate
06:21:54 <ksf_> you can scale all your maths and suddlenly, you got an integral type.
06:22:15 <dankna> well no, not really.  addition and subtraction scale.  multiplication and division behave differently.
06:22:19 <ksf_> you could use F15d15 and UF15d15
06:22:27 <dankna> I don't actually need an unsigned version :)
06:22:38 <dankna> but if I did that's what I would do, yes
06:22:48 <ksf_> wait I once implemented those for freetype
06:22:50 <dafis> ksf_: should be F15d16, I think
06:22:56 <dankna> yes, that's what I'm doing lol
06:23:03 <dankna> you worked on freetype, the C library?
06:23:31 <dankna> I'm doing an OpenType reader (I don't think Freetype supports the advanced OpenType tables, not that I really care whether I'm duplicating work or not, as I find the Freetype license unpalatable)
06:23:48 <ksf_> nah, I've got semi-complete bindings flying around.
06:24:02 <dankna> ahh
06:24:05 <ksf_> http://hpaste.org/44241/fixed_point
06:24:18 <ksf_> ...note that there's Data.Fixed
06:24:24 <dankna> !
06:24:40 <dankna> in base, even
06:24:53 <dankna> that's certainly convenient
06:25:16 <dankna> what are you using those empty data decls for?
06:25:26 <ksf_> witnesses
06:25:34 <dankna> yeah, but to what :)
06:25:46 <adamvh> I vote Int15d15
06:25:51 <adamvh> Or Int15f15
06:25:54 <ksf_> how many bits after the point
06:25:57 <dankna> adamvh: hmm okay - your vote is appreciated
06:26:08 <adamvh> since the first 15 bits _are_ an integer
06:26:15 <dankna> it's +-15.16
06:26:22 <ksf_> so with Data.Fixed you'd have Fixed 15d16 or something.
06:26:39 <ksf_> Fixed S15d16?
06:26:40 <adamvh> You don't have a mantissa / exponent scheme, right?
06:26:51 <ksf_> and then Fixed U15d16 for unsigned 
06:26:52 <dankna> although now that you mention it I also need +-1.14
06:27:00 <dankna> that's correct, no exponent, it's all mantissa
06:27:04 <dankna> that's why it's fixed-point
06:27:11 <adamvh> So you really are just doing integer multiplication and division, right?
06:27:27 <adamvh> and discarding results that overflow on the big end and underflow on the small end
06:27:34 <dankna> adamvh: no - integer addition and subtraction, but multiplication and division take account of where the binary point ("decimal point" except it's not) is
06:27:46 <adamvh> How so?
06:27:59 <adamvh> (Now I'm curious)
06:28:14 <dankna> +000000000000001.0000000000000000 * 000000000000001.0000000000000000 = 000000000000001.0000000000000000
06:28:25 <dankna> like that
06:28:56 <dankna> yeah, the existence of Data.Fixed makes my naming scheme simpler :)
06:28:57 <ksf_> addition, as a linear operation, doesnt' care about where the point is.
06:29:02 <dankna> I think I shall indeed go with ksf's suggestion
06:29:03 <adamvh> Ah so it's like
06:29:55 <dankna> if you went to a Montessori school you learned multiplication with the checkerboard and the school probably had the decimal version of the checkerboard but you probably never used it :)  if you went to a traditional school, you learned the algorithm for multiplication where you line everything up vertically with the dot.
06:30:38 <dankna> either way, you have to do some shifts and stuff to make it work out
06:30:57 <dafis> dankna: (int1.frac1)*(int2.frac2) = (2^16*(int1.frac1))*(2^16*(int2.frac2)) / (2^32), so it's integer multiplication plus a shift (and taking care of under/overflow)
06:31:07 <dankna> dafis: that sounds right, yes
06:31:09 <dafis> dang, too late
06:31:25 <adamvh> ((a >> 15) * (b >> 15) << 15) + ((a << 15) >> 15) * ((a << 15) >> 15))
06:31:37 <adamvh> in C-speak
06:31:46 <dankna> but I don't have to implement arithmetic, because the base package has Data.Fixed :D as ksf pointed out
06:32:31 <adamvh> But it's all integer multiplies and bitshift, hence why I think there shouldn't be an f in the type name
06:32:47 <dankna> well, if "f" is understood to stand for "floating", yes
06:32:52 <dafis> dankna: *if* you need speed, implementing it yourself with shifting can be faster than Data.Fixed
06:32:52 <dankna> but the word "fixed-point" has the same initial letter
06:32:58 <dankna> dafis: I don't need speed :)
06:33:03 <xplat> and so does 'fractional'
06:33:12 <ksf_> dankna, hush, back to your morphisms!
06:33:18 <dankna> haha
06:33:25 <dafis> dankna: then definitely use Data.Fixed :)
06:33:29 <dankna> indeed!
06:34:14 <ksf_> 300 isn't all, btw.
06:34:21 <adamvh> danka: I remember the checkerboard!
06:34:25 <dankna> adamvh :D :D :D
06:34:29 <ksf_> an additional 10 per upvote and 15 for the accepted answer.
06:34:33 <dankna> oh, neat
06:34:51 <dankna> adamvh: I bet you didn't realize that it's a different algorithm than the pencil-and-paper method
06:35:02 <ksf_> there's 16 people watching, so make that a virtually sure +160 karma.
06:35:07 <dankna> it does the combining as the last step instead of the first
06:35:20 <adamvh> No, I never thought about it at the time
06:35:24 <dankna> er, I mean the shifting
06:35:35 <dankna> yeah, that's the genius of it.  you don't have to be aware that there's deep stuff going on.
06:35:55 <adamvh> Do you remember the peg-board and the exploded cube they used to teach us the binomial theorem?
06:35:59 <dankna> it's less error-prone, which is why she developed it
06:36:00 <dankna> yes I do!
06:36:09 <adamvh> That thing was the shit
06:36:15 <dankna> I actually have had Montessori teacher training, so I know the binomial and trinomial cubes and all this stuff
06:36:15 <ksf_> nope. we learn binominals algebraically.
06:36:25 <xplat> it's not like there's a distinct step where shifting happens
06:36:37 <dankna> yeah that's an awesome one.  especially so because it's present in the classroom from age 3, where it's a sensorial puzzle
06:36:58 <adamvh> I was approximating cube roots using the Taylor series in 3rd grade, but I didn't realize that was what I was doing until like Junior year of college
06:36:58 <dankna> and then after having been exposed to it for possibly as much as six years, you learn around age nine that it has a deeper meaning!
06:37:02 <xplat> if you turn the checkerboard on its corner the shifting happens first
06:37:07 <dankna> yeah, haha
06:37:25 <dankna> xplat: well, I'd say the shifting happens in the combining step where you move things down along the diagonal.  but I suppose you're right.
06:37:39 <dankna> xplat: but contrast it to the pencil-and-paper algorithm where you do the shifting explicitly
06:37:54 <ksf_> but then we started out with sets and number systems in 1st class.
06:37:56 <adamvh> I also was not very good with the cube roots...
06:38:11 <dankna> adamvh: yeah :D you had a good elementary school then.  a lot of schools don't have teachers who understand the advanced algebra materials.
06:38:30 <ksf_> I could actually add and subtract base 2 through 7 or so before we knew all number symbols.
06:38:38 <xplat> yeah, and if you ask them a question they get all flustered
06:38:42 <dankna> ksf: well, that's nice I suppose
06:39:19 <ksf_> and set union is quite obviously quite related to addition.
06:39:29 <dankna> you had what is known as the "new math", ksf
06:39:31 <adamvh> My shitty performance at actually estimating cube roots when called up to do so may have had something to do with pushing the boundaries of the teacher's knowledge, lol
06:39:36 <dankna> a fad in public education which has now run its course
06:39:45 <dankna> there was a book "Why Johnny Can't Add" about it
06:39:52 <dankna> adamvh: lol haha
06:40:04 <xplat> addition is the decategorification of disjoint set union
06:40:12 <dankna> decategorification haha
06:40:12 <adamvh> I left that school around then and didn't see cube roots again until 8th grade, so who knows
06:40:14 <dankna> I suppose it is
06:40:34 <ksf_> dankna, then they're applying it wrong.
06:40:36 <adamvh> xplat: over just the integers, or also the reals
06:40:37 <ksf_> I can definitely add.
06:40:42 <adamvh> ?
06:40:44 <dankna> adamvh: yeah...  oh well.  it's a shame that people don't keep their kids in Montessori through middle school... although that's changing.  for us at least.
06:41:00 <dankna> ksf: okay, well that's good.  obviously it worked out for you; in general it tends not to.
06:41:08 <xplat> adamvh: the reals seem to have a similar, but much trickier, story
06:41:27 <adamvh> dankna; Any that I have will stay in Montessori _at least_ until high school
06:41:31 <dankna> good! :D
06:41:31 <ksf_> http://www.uebungsblatt.de/mathe1.html
06:41:33 <dankna> I approve
06:41:37 <ksf_> doesn't seem to have changed, either.
06:41:48 <dankna> you know, Brin and Page credited Montessori for some of their intelligence :)
06:42:02 <adamvh> Honestly you could probably bridge straight from Montessori to community college
06:42:08 <dankna> you really could
06:42:53 <dankna> in our middle school we have proven that the child-centered classroom still works when they're ready for abstraction
06:43:15 <dankna> it's more work for the teacher when everyone's at a different point in the book, or even in different books, but hey, it's worth it
06:43:34 <adamvh> However I want my progeny to have the opportunity to laid before age 22 (to be brutally frank), so I will probably send them to a traditional high school
06:43:43 <adamvh> which, despite its other faults, does provide that
06:43:49 <dankna> that's the biggest reason we hear
06:44:08 <dankna> I think that given the nearly-nonexistent status of Montessori highschools, I agree with the call
06:44:37 <adamvh> 'cause going straight to community college at like 14 pretty much guarantees celibacy until the job market
06:44:37 <xplat> abstraction's no obstruction to our child-centered teaching
06:44:40 <dankna> when I did my training, the highest they went up to was age 12 - when of course I'm in a classroom with ages 11 through 15
06:44:52 <dankna> xplat: haha :D
06:45:08 <xplat> the calculus does not require endless hours of preaching
06:45:21 <adamvh> xplat: A-fucking-men
06:45:45 <adamvh> Just so a diagram with some epsilon bands
06:45:55 <adamvh> Have some practice materials like kumon or something
06:46:01 <adamvh> save the students some time
06:46:15 <adamvh> *show a diagram
06:46:31 <dankna> well, I think the hardest concept in calculus is delta-epsilon proofs
06:46:43 <dankna> "For every delta there exists an epsilon" is a hard concept
06:46:49 <dankna> er
06:46:52 <dankna> did I get that backwards
06:46:53 <dankna> I did
06:46:54 <dankna> but anyway.
06:47:16 <adamvh> Yeah the logical quantification is tough - it makes constructing a proof hard to wrap your head around
06:47:18 <xplat> yeah, those nested quantifiers will get you
06:47:23 <dankna> quite so
06:47:36 <ksf_> oh, I just looked at the curriculum and apparantly there's a single one for grades 1+2
06:47:41 <xplat> i think the best way to attack it may be the game semantics of quantifiers, but then i'm not an educator
06:47:45 <ksf_> that's a lot of freedom the teachers have there.
06:48:03 <adamvh> but if you just show a picture, with epsilon/delta labelled - it's pretty easy to communicate what a limit _is_
06:48:08 <dankna> ksf: that's not itself a bad thing.
06:48:08 <adamvh> if not how to _do the proofs_
06:48:19 <dankna> adamvh: yeah
06:48:24 <ksf_> and the kids are supposed to be able to apply terms and equations to real-world applications by the end of the 2. term.
06:48:43 <dankna> ksf: what age does that correspond to?  different countries do the grade system differently
06:49:02 <ksf_> you start school the year you have your 6th birthday.
06:49:12 <dankna> and that's "grade 1"?
06:49:17 <ksf_> yep.
06:49:28 <adamvh> Personally I think if you do epsilon-delta proofs _by picture_ for a long time, at a young age, you could get the method across
06:49:33 <dankna> then, I don't think that's realistic.  especially if they haven't had what we call preschool, which is ages 3-6.
06:49:48 <dankna> to teach algebra before counting and arithmetic...
06:49:54 <ksf_> there's kindergarden, but not everyone visits it.
06:50:03 <adamvh> It's just the aversion of analysis classes to proof-by-picture that makes it hard, imo
06:50:15 <dankna> right, Kindergarten here is a single year immediately prior to 1st grade, around age, ummm, 7?
06:50:33 <xplat> here it's 5
06:50:35 <ksf_> by the end of term 1 you presumably can add asd subtract up to 100.
06:51:15 <ksf_> kindergarden is everything that's pre-school, here.
06:51:17 <dankna> it goes preschool, kindergarten, 1st-3rd grades (collectively called "elementary"), 4th-8th grades (collectively "middle school"), 9th-12th (highschool), and then college which doesn't use numbers
06:51:41 <ksf_> it's a place where you can dump your kids without them hating you.
06:51:45 <dankna> not everyone does go to preschool here, since the public schools do start with kindergarten
06:52:15 <dankna> it's why preschool is our best marketing opportunity - we don't have to deal with competition that gives it away for free
06:52:30 <dankna> kids shouldn't hate school :( ever :(
06:52:38 <dankna> there's no reason they have to if it's good :(
06:52:55 <ksf_> kindergarden has a limited paedagogical task.
06:53:03 <dankna> I see what you're saying
06:53:24 <ksf_> they're not supposed to be spoon-fed knowledge there, but neither held back if they want to learn.
06:53:34 <dankna> I wish I could show you our promotional video for preschool, but a) it's half an hour long; b) I don't have permission to do that; c) I don't have it encoded at anything below DVD-quality
06:53:36 <ksf_> kids like to be taught stuff, but noones' forcing them, there.
06:53:50 <dankna> yeah, that much is in keeping with Montessori principles
06:53:58 <Kaidelong> dankna: American school is pretty much just a prison
06:54:08 <dankna> Kaidelong: insert the word "public" and I agree
06:54:27 <Kaidelong> so it is natural for kids to hate it
06:54:37 <Kaidelong> especially ones who are told they're supposed to be there to learn (and know better)
06:54:40 <dankna> Kaidelong: it even follows the same floor plan as a prison, with high fractal dimension and chokepoints to limit the scope of a riot :(
06:54:42 <ksf_> principals can probably legally marry pupils there, if they happen to have sex.
06:55:31 <xplat> i kind of wish schools taught social skills, but instead they seem to leave it to some combination of family/sink-or-swim
06:55:37 <dankna> did you hear this thing from Florida about how one district tried a classroom with no teacher in it, just computers?
06:56:00 <dankna> xplat: that's the thing!  everyone says "we want our kids to go to public school so they learn to socialize" but that's exactly what it doesn't teach!
06:56:10 <xplat> it would be fine to leave it to family if the families were qualified, but so many families couldn't teach a fish to swim
06:56:15 <dankna> agreed
06:56:19 <Kaidelong> xplat: Most people don't need to learn that specially, although schools probably make it worse
06:56:19 <ksf_> you can absolutely, for example, teach kids how to deal with sitting still and being attentive as a group for some time by just reading them a story.
06:56:37 <dankna> ksf: I'm not sure what that's an example of, but yes, you can
06:56:46 <Kaidelong> xplat: what schools should really teach is stuff like how to file your taxes and how to vote, which they do a bit of
06:56:47 <ksf_> my kindergarden days.
06:56:51 <xplat> Kaidelong: i disagree.  some people need to learn it specially just to get by, but most people need to to get ahead
06:57:12 <dankna> ksf: we were into Harry Potter before it was popular - even the older students loved it when the history teacher would read it to them, doing dramatic voices
06:57:13 <Kaidelong> xplat: Well I was in the prior category, but I was told that was unusual
06:57:19 <dankna> ksf: we also used LotR in that capacity
06:57:42 <Kaidelong> hmm
06:57:47 <ksf_> well, my kindergarden was operated by the lutheran church, so it was a bit tamer than that.
06:58:14 * Kaidelong wonders why this isn't in blah
06:58:26 <dankna> because it happens not to be.  it could though.
06:58:44 <ksf_> becaues we're just coming to the point of when and how to indoctinate kids with functional programming.
06:58:53 <dankna> not before age 12
06:59:05 <dankna> I have thought about it, and I think BASIC is appropriate for ages 9-12
06:59:20 <Kaidelong> ksf_: Really, you want to indoctrinate them with software engineering. Functional programming seems to follow naturally from that, given recent developments
06:59:24 <ksf_> depends, I'd say. you could start with first-order stuff before.
06:59:24 <dankna> they have to get to the point of naturally discovering the need for clean code of some sort
06:59:46 <dankna> and then you jump in with advice on HOW to write clean code
07:00:06 <companion_cube> the visual functional programming language in haskell would be nice for children
07:00:06 <xplat> Kaidelong: how to file taxes, vote, start a company, etc are certainly things that should be taught too
07:00:13 <ksf_> and probably, for a change, teach three additional methods of addition after they've mastered division.
07:00:35 <dankna> xplat: oh I definitely agree with your list of things to mention
07:00:37 <xplat> dankna: why would anyone teach basic to a 9 year old?  even when i was 9 they had LOGO
07:00:38 <ksf_> just to emphasize the point of algorithm vs. what to compute.
07:00:39 <adamvh> Something like scratch is probably best for the young 'uns
07:00:57 <ksf_> jep.
07:01:04 <adamvh> Or maybe some friendlier lisp dialect
07:01:04 <dankna> xplat: LOGO is ... decent, yes.
07:01:18 <Kaidelong> xplat: I "discovered" something very BASIC/Assembler like when I was around 9
07:01:21 <Kaidelong> a little earlier
07:01:22 <rly> Why would there be any difference to the tools adults should use and the tools children should use? 
07:01:25 <dankna> well, I wound up using BASIC because there just wasn't time to pick something that wasn't off-the-shelf
07:01:28 <adamvh> but I think dynamic typing is probably a good idea for the kiddies
07:01:33 <Kaidelong> so perhaps that kind of programming is just "natural"
07:01:43 <xplat> and that's STILL better for teaching programming than visual basic, which would be one of the best basics
07:01:56 <dankna> well, I actually am using a package language-basic which I implemented in Haskell :)
07:01:58 <ksf_> rly, because most adults are plain incapable of grokking programmer's toys.
07:01:59 <Kaidelong> xplat: I am not so sure
07:02:04 <Kaidelong> recently I worked with a student
07:02:06 <adamvh> rly: Because adults and kids have different priorities
07:02:08 <dankna> it will have turtle graphics in it, for whatever that's worth, when I get to the point
07:02:19 <Kaidelong> whose program failed mysteriously at runtime (but compiled just fine)
07:02:27 <Kaidelong> turns out she was missing a right parenthesis
07:02:52 <dankna> yeah - I have a discarded draft where I was going to use a language with block structure (to be designed)
07:02:57 <adamvh> Kids want something to work with a minimum of fuss and understanding
07:03:04 <Kaidelong> I think those kinds of aspects of Visual Basic inspire people to superstition and paranoia
07:03:12 <Kaidelong> but perhaps something *visual basic like*
07:03:19 <dankna> I had written a trivial text editor for it that colored the background in darkening pastels alternating blue/green to indicate deeper levels of nesting
07:03:25 <dankna> thereby making it impossible to forget a close-block
07:03:26 <ksf_> scratch is actually quite ideal.
07:03:35 <dankna> but in the end I decided it was simpler to use a language which doesn't have blocks at all
07:03:40 <ksf_> it could probably be a wee bit more functional.
07:03:42 <Kaidelong> Smalltalk was designed with pedagogical intent
07:03:52 <ksf_> so was pascal.
07:03:53 <dankna> so was Pascal; that doesn't mean it works :)
07:03:56 <dankna> jinx
07:04:06 * Kaidelong likes Pascal though
07:04:13 <adamvh> ksf_: one could presumably make it that way if one desired
07:04:14 <ksf_> single-exit is just broken.
07:04:15 <dankna> Pascal is not my favorite programming language :)
07:04:20 <Kaidelong> well not Pascal
07:04:23 <ksf_> unnecessarily complicates code.
07:04:24 <Kaidelong> I should say Delphi
07:04:25 <rly> Can someone define functional programming? 
07:04:30 <Kaidelong> rly: No
07:04:34 <ksf_> let's say denotational.
07:04:40 <ksf_> without going prolog.
07:04:42 <vegai> it's when you use functions a lot
07:04:46 <Kaidelong> but it is not as bad a situation as with object oriented programming
07:04:54 <dankna> even the ICFPC doesn't try to define it - "To forestall debate, we accept submissions in any language"
07:04:56 <copumpkin> expression-oriented programming?
07:04:57 <rly> Denotational programming has nothing to do with programming anymore. 
07:05:08 <copumpkin> that's the best I can do without going haskell-specific
07:05:15 <companion_cube> give Coq to children!
07:05:16 <adamvh> rly: a bare minimum - functions must be able to be bound to any symbol to which data may be bound
07:05:24 <Itkovian> @seen BCoppens
07:05:24 <lambdabot> Unknown command, try @list
07:05:24 <preflex>  BCoppens was last seen on #haskell-blah 2 hours, 27 minutes and 25 seconds ago, saying: jaspervdj: sounds nice :)
07:05:30 <companion_cube> so that they learn to prove the code they write
07:05:36 <Kaidelong> adamvh: what about total functional languages
07:05:40 <ksf_> adamvh, that's, strictly speaking, higher-order functional.
07:05:42 <dafis> companion_cube: you can write that, but don't say it out aloud :)
07:05:46 <dankna> I'd put it this way: Functions are first-class objects which can be passed and returned
07:05:47 <rly> adamvh: so, C is a functional programming language? 
07:05:56 <dankna> C /can/ be used to write functional programs
07:06:00 <dankna> you can write higher-order functions in it
07:06:01 <Kaidelong> rly: C allows you to do functional programming
07:06:04 <dankna> of course they can't be well-typed
07:06:12 <adamvh> companion_cube: depending on you pronunciation, you may have trouble with getting the public on board
07:06:19 <Kaidelong> rly: <LANGUAGE OF YOUR CHOICE> also allows you to do functional programming
07:06:22 <ksf_> what about showing the kids how to express that addition algorithm they know recursively.
07:06:25 <ksf_> peano numerals.
07:06:29 <adamvh> necessary condition, not sufficient
07:06:30 <Kaidelong> in the case of things like Ruby, Python, C etc though
07:06:44 <rly> Kaidelong: that was the point.
07:06:45 <Kaidelong> it is very difficult to get functional programming out of them because mutable state is so pervasive
07:06:45 <companion_cube> dafis, you're right, but fortunately i speak another language :)
07:07:14 <ksf_> it's probably important that you can reduce the used calculus by term-rewriting.
07:07:15 <Ke> well most compilers do not have tail call recursion optimizations
07:07:18 <adamvh> Kaidelong: pretty much inpossible
07:07:18 <dankna> Kaidelong, don't confuse it with /pure/ functional programming, which is what Haskell does with the no-side-effects thing, either
07:07:22 <Ke> so it may be a bit painfull
07:07:26 <dafis> companion_cube: they'll thing of Coq au Riesling then?
07:07:29 <ksf_> so the first chapter or so of SICP applies.
07:07:30 <dankna> Lisp has side-effects but nobody would argue it's not functional
07:07:33 <Kaidelong> dankna: It's not confusion
07:07:35 <adamvh> Did you know default arguments in Python are mutable?
07:07:38 <dankna> okay, so long as you're aware
07:07:42 <adamvh> dankna: actually I would
07:07:48 <Kaidelong> dankna: I would argue that LISP without lexical scope is not functional
07:07:51 <dankna> adamvh: haha okay
07:07:53 <adamvh> I love me some Common Lisp
07:08:02 <ksf_> scheme without set!
07:08:08 <dankna> Lisp has side-effects, but I wouldn't argue it's not functional :D
07:08:23 <adamvh> but whenever someone says:  I want to get into functional programming, and I've been thinking about Common Lisp
07:08:31 <dankna> yeah :(
07:08:36 <adamvh> I think, you are misinformed
07:08:36 <dankna> that's just a shame
07:08:42 <Kaidelong> dankna: you don't have to be pure to get something pretty denotational
07:08:54 <Kaidelong> look at the MLs
07:08:54 <dankna> mind you, it's a well-designed language... but static typing is just better
07:09:16 <adamvh> Common Lisp is remarkable for its metaprogramming facilities and image-based development (which, by the way , is pretty much the antithesis of functional programming)
07:09:19 <dankna> actually, the Common Lisp HyperSpec is a nicer document in terms of writing style and clarity than the Haskell 2010 report is
07:09:30 <Kaidelong> I think the most important thing is a focus on immutable data structures and using lexical scope
07:09:42 <Kaidelong> (since lexical scope translates into lambda calculus in a straightforward way)
07:09:50 <adamvh> It's essentially a very advance Python-alike designed with metaprogramming in mind
07:10:25 <dankna> yeah, image-based development is meh
07:10:38 <Kaidelong> adamvh: Yeah, it's important to distinguish Lisp the syntax from Common Lisp though
07:10:39 <adamvh> I think "functional programming language" is a somewhat silly term, since you have to do IO
07:10:40 <dankna> the metaprogramming, you're right, that's really what sets it apart as a language
07:10:51 <Kaidelong> there are things like applicative common lisp and scheme which are much more functional
07:10:53 <dankna> we have Template Haskell but it's just not as nice
07:11:18 <dankna> isn't there some project which uses Lisp syntax for Haskell?
07:11:25 <alej> liskell
07:11:29 <adamvh> Kaidelong: right, but the perception that "I'll learn functional programming, Lisp is a nice place to start" is a problem
07:11:38 <Kaidelong> adamvh: I have met a victim of that
07:11:46 <dafis> dankna: that's so wrong, Haskell syntax for Lisp, that may work out
07:12:03 <adamvh> dafis: Actually I think it's a great idea
07:12:07 <Kaidelong> I actually only really got into functional programming when I started getting very into C#
07:12:11 <dankna> dafis: no!  other way around
07:12:21 <dankna> I love Lisp's syntax actually
07:12:28 <adamvh> dankna: agreed
07:12:29 <Kaidelong> although Scheme and ML whet my appetite beforehand
07:12:49 * dafis considers Lisp syntax worse than perl
07:12:51 <dankna> yeah - I spent five years on Common Lisp before I learned Haskell
07:12:57 <dankna> not because I wasn't aware of both languages
07:13:02 <dankna> I just found Haskell harder to get into
07:13:06 <dankna> we didn't have RWH or LYAH back then
07:13:09 <adamvh> I also love image-based development, since "redefine functions and variables when you fucked up, keeping program state intact" is really nice for my workflow
07:13:24 <dankna> I love image-based development until I want to deploy something
07:13:37 <dankna> or until I have a running image that I can't reproduce from the source code
07:13:46 <Kaidelong> dankna: Even with those Haskell uses very abstract concepts and mathematical terms
07:13:46 <Kaidelong> and not just when it comes to "monads"
07:13:54 <adamvh> dankna: yeah, these are problems
07:13:57 <Kaidelong> People struggle to "get" abstraction
07:14:11 <dankna> Kaidelong: oh I agree, but you can learn it as a "better C" and I still think that it's worthwhile to do so
07:14:18 <dankna> you don't /have/ to learn monoids, functors, etc
07:14:25 <xplat> dankna: yeah, that's a persistent problem with relational databases too, but there it really can't be helped
07:14:30 <Kaidelong> dankna: You will eventually
07:14:48 <adamvh> dankna: However, the ability to modify a running image with costly initialization can be useful even at deployment
07:14:52 <dankna> xplat: hmmm, yeah.  I hadn't thought of that as analogous.  at least with most SQL engines you can ask for the schema.
07:15:02 <adamvh> Ideally, the image would _store_ the source
07:15:18 <dankna> adamvh: I agree.  I'd like to see a unification of the models somehow.
07:15:34 <adamvh> So that it could provide it to you on request and then lazily recompile as necessary
07:15:40 <dankna> right
07:16:03 <dankna> I'd like to see integration of cabal and ghci that lets me, for example, load and reload a file that needs to be preprocessed with Happy, without jumping through hoops
07:16:40 <dankna> how does ghci implement reload?  does it unload everything and start from scratch?
07:17:33 <Kaidelong> haskell's syntax might be another hurdle
07:17:37 <Kaidelong> it is really nice
07:17:45 <Kaidelong> but
07:17:54 <adamvh> As an added bonus, image-based development allows you to basically punt on static analysis for IDE-ish things
07:17:57 <Kaidelong> It is very different from what most people are used to
07:18:25 * ksf_ can't imagine that square n = n * n is hard to grok.
07:18:46 <adamvh> Common Lisp IDEs just talk to the image for code completion, etc., and it'd be nice if there were some way to do that with ghci
07:18:46 <dankna> it's really not
07:18:55 <dankna> adamvh: yeah, that's very true.
07:18:55 <ksf_> and kids are used to 2 * 2 = 4, that's bleeding similar.
07:19:39 * Kaidelong is not sure he likes instance chaining
07:19:45 <adamvh> ksf_:  I think it's the $ <$>, <*>, ` ` menagerie that are the problem
07:20:04 <adamvh> >>=, ->, ::
07:20:08 <ksf_> well I wouldn't throw those at unsuspecting 8-year olds
07:20:10 <adamvh> kinda cryptic really
07:20:18 <Kaidelong> ksf_: Syntax for single line declarations is nice
07:20:26 <Kaidelong> well, syntax is nice, period
07:20:27 <adamvh> Can you get by without :: and -> though
07:20:41 <Kaidelong> but people seem to develop superstitious indenting habits
07:20:47 <ksf_> :: and -> are kinda important, though.
07:21:00 <ksf_> you probably don't have to say that -> is material implication.
07:21:11 <ksf_> say it's "results in a "
07:21:21 <adamvh> ksf_: that's what it is in _my_ head
07:21:43 <adamvh> and if you can get 8 year olds as educated as me, that's a good start, if I do say so myself
07:21:48 <ksf_> burn him on a stake!
07:21:48 <Kaidelong> Actually perhaps one of the problems with Haskell is that is self-selects for people who are bad at explaining it well to people who won't learn it anyway
07:21:53 <ksf_> he's denying curry-howard!
07:22:04 <zzing> If I am going to make a module that contains some C/ObjC code in it, is there anything that must be taken care of from a ghc7 perspective so as to still be 6.12 compatible? I am running 6.12.
07:22:21 <Kaidelong> because I have actually told someone that they can think of "->" as implication
07:22:35 <Kaidelong> without realizing that that was more confusing than helpful
07:23:22 <adamvh> yeah, I would go with "it's like the comma in a C function declaration, except the last one.  The thing after the last one is the return type"
07:23:59 <Kaidelong> also someone I am quite fond of believes that Haskell is a low level language because it has a compiler and static types
07:24:04 <ksf_> you'd start off with one-parameter functions, anyway.
07:24:05 <Kaidelong> I find that saddening
07:24:15 <alej> Kaidelong: lol what
07:24:27 <ksf_> dunno how to best deal with curried vs. uncurried functions.
07:24:35 <adamvh> Yeah, Haskell is _not_ a low level because it won't let me allocate any god damned memory and has a freaking garbage collector
07:24:37 <adamvh> bleck
07:24:47 <Kaidelong> alej: His job has him working with plenty of PHP so I'm going to try to corrupt him
07:24:49 <ksf_> as currying isn't first-order, anymore.
07:25:11 <adamvh> However, I forgive it these transgressions, because I like the type system
07:25:31 <adamvh> and I am not start enough to figure out how one could be all Hindley-Milner and allow manual memory allocation
07:25:33 <Kaidelong> adamvh: That criteron wouldn't really work either though
07:25:36 <adamvh> *smart enough
07:25:42 <Kaidelong> you could have something low level with managed memory
07:25:56 <adamvh> Kaidelong: that would just be something shitty
07:26:07 <rly> adamvh: are you joking? 
07:26:12 <Kaidelong> adamvh: Sure. But aren't some bytecodes actually like that?
07:26:19 <adamvh> rly: mostly
07:26:36 <Kaidelong> adamvh: Or hell, some binaries, when using managed resources provided by the OS
07:26:37 <rly> adamvh: you can write all the pointer poking code you want in Haskell. 
07:27:00 <ksf_> basic exercises could look like "you have three triangles t0, t1, and t2, and a square s0, and functions triangleArea :: Triangle -> Area and squareArea :: Square -> Area. write a program that calculates the total area of all shapes.
07:27:38 <adamvh> rly: Not quite as convenient as C for that purpose, though
07:28:06 <ksf_> "with the same three triangles, display the one with the largest and smallest area on the screen"
07:28:06 <Kaidelong> adamvh: Well you could a C compiler embedded in Haskell
07:28:20 <adamvh> Kaidelong: that is a very good point
07:28:43 <ksf_> Kaidelong, on the type level!
07:29:09 <Kaidelong> it may not even be that hard really
07:29:22 <ksf_> we already have a basic
07:29:51 <adamvh> The main problem being that if you every need very fine-grained manual control over memory allocation, access patterns, and instruction selection, one has to jump through a lot of hoops to get the GC to give you the data need and then bugger off until you do the things you need to do
07:30:00 <ksf_> longjmp will be tricky, though.
07:30:19 <Kaidelong> ksf_: Well you don't have to implement everything
07:30:27 <adamvh> So I'm a little bit biased against GC-by default
07:30:41 <ksf_> though I don't think even 10% of all programmers that claim they know c ever heard of it.
07:30:58 <alej> i dont think i've ever seen longjmp in the wild
07:31:05 <ben> libpng error handling, iirc
07:31:11 <Kaidelong> adamvh: I do not like the state of the art in memory management either but perhaps *a* garbage collector *could* be nice
07:31:12 <adamvh> alej: exception handling in Apple's libobjc
07:31:18 <alej> might have used it once, but i certainly didn't need to use it
07:31:22 <companion_cube> setjmp/longjmp is as evil as goto, except non local
07:31:35 <ksf_> chicken scheme's nifty on-the-stack nursery.
07:31:41 <adamvh> Kaidelong: agreed
07:31:45 <ben> I have used longjmp only long to realise I am not smart enough to use it wisely
07:31:52 <alej> haha
07:31:56 <Kaidelong> but I think Microsoft has made a good case that programmers should not generally be allowed to do manual allocation
07:32:01 <ksf_> green threads.
07:32:12 <Kaidelong> and deallocation
07:32:37 <Kaidelong> and perhaps in the future operating systems like Singularity might actually be viable
07:32:37 <ksf_> I'm fine with by default being protected from shooting my own foot.
07:32:47 <ksf_> but if I want to, I don't want to code in pascal.
07:33:23 <dafis> alej: http://thedailywtf.com/Articles/Longjmp--FOR-SPEED!!!.aspx
07:33:25 <eva> hellow
07:33:42 <adamvh> Kaidelong: Since my code is numerical, and runtime factors of two matter to me, the GC is something I only want to involve in the sort of undemanding stuff like input management and maybe computation setup
07:33:45 <kulakowski> Kaidelong: I had a friend who interned on that, it seemed compelling, if still a ways off.
07:33:51 <Kaidelong> ksf_: Well the motivation is more about "gun control" than just stopping you from shooting yourself in the foot
07:34:06 <adamvh> Kaidelong: the meat of my algorithms all kind of require manual memory management
07:34:14 <alej> dafis: :(
07:34:49 <eva> why does the haskell code in this pastebin only return 'pointless' and not the other return values? http://pastebin.com/1ggMvABv
07:34:50 <ksf_> I think haskell got it right with unsafe*
07:34:53 <Kaidelong> adamvh: your OS might not allow you to though (or at least put you in a sandbox that imposes runtime costs)
07:35:01 <ksf_> and those alloc functions.
07:35:17 <Kaidelong> Most current ones are lenient with unsafe code
07:35:29 <adamvh> Kaidelong: I'm looking into Haskell as a replacement for Common Lisp with C for the hardcore bits
07:35:37 <ksf_> I don't think I'd want to lay out a tree in van embde boas and write a pure interface for that, though.
07:35:54 <adamvh> hoping that I can wring enough performance out of Haskell to justify living in one language
07:35:56 <ksf_> I'd prefer if I could program the rts to lay out my tree smartly.
07:36:03 <Kaidelong> adamvh: when talking about the current state of the art, that all makes sense
07:36:15 <copumpkin> eva: return is a misleading name
07:36:22 <Kaidelong> looking into the future we might end up banashing unmanaged code entirely for security and reliability reasons
07:36:27 <eva> oh?
07:36:37 <copumpkin> eva: it only acts like a regular "imperative" return at the end of a do block. Anything before that is basically a no-op
07:36:41 <Kaidelong> (and because assuming all code is managed allows runtime systems to make more assumptions when optimizing)
07:36:49 <eva> no op?
07:36:50 <adamvh> Kaidelong: Color me skeptical
07:36:51 <smartrahul> What are the applications of Haskell?
07:36:55 <copumpkin> eva: does nothing at all
07:37:04 <copumpkin> smartrahul: we write brainfuck interpreters
07:37:08 <copumpkin> nothing else is possible
07:37:23 <adamvh> Kaidelong: The question is: can you ever get more performance by using unmanaged code
07:37:26 <adamvh> ?
07:37:27 <ksf_> it just injects a value. you have to read it out, too, and your first returns aren't read by anything.
07:37:33 <dafis> copumpkin: not true, I saw a decent Befunge interpreter written in Haskell once
07:37:40 <adamvh> Kaidelong: If the answer to that question is ever true
07:37:46 <eva> so, why doesn't it print all the returns instead of just the last one?
07:37:53 <dankna> sorry I kinda disappeared - I'm busy writing up a patch
07:37:54 <Kaidelong> adamvh: You will probably always be able to find some counterexample but that doesn't neccessarily make it important
07:37:56 <adamvh> Kaidelong: then scientific programmer will need to write unmanaged code
07:38:02 <Kaidelong> right
07:38:05 <copumpkin> eva: because as I said, the earlier returns do nothing, by design
07:38:27 <Kaidelong> but adamvh a lot of those programmers still write FORTRAN on bare metal
07:38:37 <ksf_> return "hello" >>= \_ -> return "aren't" >>= \_ return "these"
07:38:40 <Kaidelong> so it is somewhat orthogonal
07:38:42 <ksf_> ...because they all get ignored.
07:38:45 <adamvh> Kaidelong: and I'm one of them
07:38:52 <copumpkin> eva: or to put it another way, why would you expect it to do all the other returns too?
07:38:55 <Kaidelong> Right.
07:38:57 <adamvh> Kaidelong: but I'd like it not to be orthognal
07:38:59 <copumpkin> and how would you expect that to happen?
07:39:15 <Kaidelong> adamvh: Yeah, it would be nice if it isn't
07:39:31 <adamvh> Kaidelong: I don't see a reason why one couldn't use some sort of Haskell-y thing on big iron
07:39:50 <adamvh> Kaidelong: provided it gave very fine control over memory management when desired
07:39:51 <eva> well, i thought 'return' meant something like 'return the value to standard out'
07:40:01 <ben> well, it doesn't
07:40:03 <xplat> 11:01 < alej> i dont think i've ever seen longjmp in the wild
07:40:07 <Kaidelong> adamvh: No reason. Although GHC would not neccessarily be what you are looking for
07:40:17 <alej> xplat: yes...?
07:40:29 <eva> what does return mean in haskell then?
07:40:32 <xplat> a server i've worked on uses longjmp to handle panicky shutdowns on asserts
07:40:37 <adamvh> Right - this is for local proof of concept stuff, so absolute performance isn't critical for me right now
07:40:40 <companion_cube> :t return
07:40:41 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:40:45 <Kaidelong> eva: return is a function from an element to something containing that element
07:40:55 <ksf_> like
07:40:59 <companion_cube> > return 42 :: [Int]
07:40:59 <Kaidelong> > return 5 :: [Int] -- eva
07:41:00 <lambdabot>   [42]
07:41:00 <lambdabot>   [5]
07:41:06 <ksf_> > return 'a' :: String
07:41:06 <companion_cube> hey
07:41:06 <lambdabot>   "a"
07:41:35 <ksf_> @quote stereo
07:41:36 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
07:41:39 <adamvh> It's just that I dream of one day being able to write both proof of concept exploratory stuff and big-iron serious business stuff in haskell
07:41:41 <ksf_> @quote stereo
07:41:41 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
07:41:44 <Boxo> > return 3.1 :: Maybe Double
07:41:45 <lambdabot>   Just 3.1
07:42:22 <Kaidelong> adamvh: What if it turns out that you end up being good at neither thing in Haskell?
07:42:28 <ben> > (return 3.1 :: Int -> Double) 42
07:42:29 <lambdabot>   3.1
07:42:31 <Boxo> > return 13 :: Either Bool Int
07:42:32 <lambdabot>   Overlapping instances for GHC.Base.Monad
07:42:32 <lambdabot>                              (Data...
07:42:44 <Kaidelong> although I am being the devil's advocate there
07:42:48 <Kaidelong> I think that is possible
07:42:55 <xplat> 11:05 < Kaidelong> adamvh: your OS might not allow you to though (or at least  put you in a sandbox that imposes runtime costs)
07:42:59 <Peaker> '
07:43:04 <adamvh> Kaidelong: well I think that is already pretty good for proof of concept exploratory stuff
07:43:21 <xplat> most OSes don't have to put you in a sandbox with runtime costs, the processor does it for them
07:43:26 <Saizan> adamvh: http://lambda-the-ultimate.org/node/4205
07:43:32 <Kaidelong> xplat: Oh wow that's a good point
07:44:00 <Kaidelong> xplat: but I was mostly meaning Singularity there
07:44:19 <Kaidelong> or House, which turns out to be fundamentally touching on some of the same concepts
07:44:53 <Kaidelong> adamvh: now that I remember it, House might touch on some of your thoughts
07:45:14 <lispy> and http://halvm.org/wiki/
07:45:17 <Kaidelong> I do not think they butchered the garbage collector though
07:45:31 <Kaidelong> but perhaps they did and I am wrong on that
07:45:34 <lispy> I think halvm is probably more current/ready to go than House
07:46:14 <BrianHV> lots of things link to haskell.org/fruit which is 404. did the contents of that page move somewhere?
07:46:15 <Kaidelong> lispy: HaLVM is interesting yes
07:46:33 <Kaidelong> BrianHV: As far as I know Fruit and wxFruit are pretty much abandoned
07:46:59 <Kaidelong> grapefruit was meant to succeed fruit but I think that is also now abandoned
07:47:00 <BrianHV> Kaidelong: that's unfortunate... but I'm still interested in the concepts
07:47:57 <Kaidelong> BrianHV: "Real World Functional Programming" goes over some of those concepts in F#, where you implement reactive programming from scratch
07:48:10 <Kaidelong> the basic idea is that time becomes a parameter
07:48:18 <Kaidelong> Haskell gives you some particularly nice ways to talk about that
07:48:54 <BrianHV> all right, thanks... I'll take a look at RWFP
07:49:10 * Kaidelong does not know if that's available for free online unfortunately
07:49:21 <Kaidelong> but if you own it or you are not frightened of libraries
07:49:30 <Kaidelong> they have a decent section on functional reactive programming
07:49:38 <Kaidelong> which introduces the concepts well enough
07:49:42 <BrianHV> cool
08:22:45 <mun_> if y is not free in f, how are \lambda x. f and \lambda y. f by? alpha, beta, or eta?
08:33:46 <jmcarthur> mun_: i don't understand the question. i doesn't appear to be a complete or unambiguous sentence
08:33:59 <jmcarthur> *it
08:34:33 <quicksilver> the question is, how do you describe the transformation (\x -> f) ~~~ (\y -> f), given that x and y are not free in f.
08:34:40 <jmcarthur> mun_: do you mean how are (\lambda x. f) and (\lambda y. f) related?
08:34:50 <quicksilver> I would say the answer is alpha conversion
08:34:55 <jmcarthur> i would say alpha as well
08:35:15 <jmcarthur> with the qualification that x *and* y must not be free in f, not just y
08:35:30 <quicksilver> yes, I corrected his question in my reposting of it ;)
08:35:45 <jmcarthur> ah didn't catch that
08:44:43 <aristid> @hoogle showBits
08:44:43 <lambdabot> No results found
08:48:36 <ClaudiusMaximus> :t showIntAtBase
08:48:37 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
08:49:43 <ClaudiusMaximus> > showIntAtBase 2 ("o!"!!) 42 ""
08:49:43 <lambdabot>   "!o!o!o"
08:50:12 <ion> :t readIntAtBase
08:50:12 <lambdabot> Not in scope: `readIntAtBase'
08:50:44 <ClaudiusMaximus> :t digitToInt
08:50:45 <lambdabot> Char -> Int
08:51:18 <ion> Ah, readInt, too.
08:53:36 <turiya> hi
08:54:42 <FUZxxl> hi
08:54:53 <turiya> i am building a binary tree by recursion and the program is too slow.. any pointers on how to speed it up?
08:55:36 <FUZxxl> Please post some code into a pastebin.
08:58:44 <turiya> FUZxx1: http://hpaste.org/44245/waveletshs, http://hpaste.org/44246/convhs, http://hpaste.org/44247/tesths, thats the complete code
08:59:21 <turiya> i am specifically looking at the function nDWT in waveletshs which somehow is too slow..
08:59:56 <turiya> FUZxxl: ^^^^
09:03:46 <Saizan> maybe you want to share the downsampling? 
09:04:04 <turiya> hi
09:05:30 <Saizan> ah, i see l vs. h now
09:07:03 <Saizan> turiya: how large are these trees? do you want to generate them as you consume them or up front?
09:08:08 <jonkri> hey everyone! i was having a discussion with my c teacher today about haskell, and he asked me if there was something in haskell where you can formally specify that a value should be inside an interval, for example that an float must be between 2.5 and 3.5, like in ada
09:08:32 <jonkri> so i got curious about whether there's something like it, and if it would be useful
09:08:46 <ion> Alas, nothing on the type level, but guards are available.
09:09:22 <jonkri> you would need something that guarantees that a function will return something in an interval or set of intervals to enforce that right?
09:09:35 <jonkri> i mean
09:09:46 <jonkri> in order for it to be statically useful
09:10:06 <jonkri> i guess is hould read up on how ada does it
09:10:11 <parcs> didn't type-level natural recently get committed into GHC HEAD?
09:10:11 <kmc> jonkri, there isn't really, people sometimes fake it with smart constructors
09:10:15 <jmcarthur> jonkri: well, there are ways to do it, but it involves smart constructors, most likely
09:10:39 <dayz> if I have a theory T with a function symbol f and an axiom "f(x) = 0", then if I extend this theory to include 2 function symbols, g and h, and an axiom "g(x) = f(x) + h(x)". then is the extension a definitional extension?
09:10:43 <jmcarthur> jonkri: and you could also put some numbers at the type level to express the valid range and stuff, but you would still need a smart constructor to create the value
09:11:38 <monochrom> yes
09:13:18 <dayz> according to wikipedia http://en.wikipedia.org/wiki/Extension_by_definitions there should exist a formula \phi(y,x1..xn) of the old theory T, such that \phi(f(x1..xn),...).
09:13:27 <jonkri> like a function that wraps the value in the smart type and returns like "Just" the type or throws an exception or something?
09:13:45 <dayz> but there isn't such a \phi in my case because function symbol h doesn't exist in T.
09:13:52 * jonkri googles haskell smart constructors
09:14:17 <jmcarthur> jonkri: you have the idea
09:14:26 <monochrom> well then, extend in two stages, add just h in the first stage.
09:14:27 <jonkri> i see
09:14:29 <duckinator> hi
09:14:34 <jmcarthur> jonkri: typically you would return Maybe a value of the type you need
09:15:01 <jmcarthur> jonkri: so in this case, something like   interval :: Word -> Maybe (Interval lower upper)
09:15:10 <jmcarthur> or whatever
09:15:10 <dayz> i seem to be defining both g and h in a single axiom.
09:15:29 <jmcarthur> that was assuming something like intervals on natural numbers or something
09:15:56 <jonkri> i see
09:16:08 <dayz> monochrom, what would be the way to split "g(x) = f(x) + h(x)" into two?
09:16:27 <monochrom> no way and unnecessary
09:16:37 <jonkri> is it possible to restrict a type to a finite range of numbers, like 5..25, without using smart constructors?
09:16:53 <dankna> jonkri: no
09:16:59 <dankna> jonkri: it wouldn't have much benefit anyhow
09:17:20 <jonkri> yeah, ok
09:17:51 <dayz> monochrom, hmm ok. on a similar topic, is a theory extended by a new symbol *without* a definition still a definitional extension?
09:18:20 <monochrom> I don't know what your wikipedia says. I say yes.
09:19:15 <dayz> monochrom, ah ok. well i'm just looking at http://en.wikipedia.org/wiki/Extension_by_definitions "Definition of function symbols"
09:21:04 <jonkri> is there some way to make a type constructor which takes an arbitrary interval, and at the function type signature level say something like "the arbitrary interval between x and y"?
09:21:19 <jonkri> something like an incomplete type taking two numbers
09:21:27 <jonkri> weird :)
09:21:36 <dankna> sure, you could do it
09:21:43 <dankna> you'd want type-level natural numbers
09:21:53 <dankna> or perhaps more generally, type-level integers
09:22:08 <dankna> how important is it to you?
09:22:11 <dankna> what's the use-case?
09:23:09 <jmcarthur> well, actually, there is a way to do this
09:23:11 <jonkri> i'm just curious
09:23:12 <jmcarthur> without smart constructor
09:23:32 <jmcarthur> but it requires you to build a singleton type gadt for the numbers and stuff
09:23:39 <jonkri> what's a type level integer?
09:23:47 <jonkri> gadt?
09:24:34 <dankna> a type-level integer is a type that corresponds to an integer
09:24:36 <jmcarthur> hmm, it might not actually
09:24:39 <dankna> you would have one type for each integer
09:24:40 <jmcarthur> i'm gonna try that
09:24:42 <jmcarthur> *this
09:24:42 <byorgey> GADT = Generalized Algebraic Data Type
09:24:48 <dankna> hence an infinite number of them
09:25:17 <dayz> thanks
09:25:48 <dankna> the way that it's done for natural numbers, for example, is to define data Natural = Zero | Successor Natural
09:26:20 <dankna> then the type corresponding to 5 is Successor (Successor (Successor (Successor (Successor Natural)))) and you define a type synonym type Five = that type-expression
09:27:36 <jonkri> i see
09:27:58 <dankna> integers are more complicated; you can't just add Predecessor because it's important that there be only one type for each value
09:29:07 <kmc> data Integer = IZero | NatPlusOne Natural | NegativeNatMinusOne Natural
09:29:21 <dankna> kmc: yes, that's what I would do
09:29:32 <dankna> although you don't want the IZero constructor
09:29:39 <dankna> oh wait, yes you do
09:29:59 <dankna> why did you do it that way and not data Integer = Natural Natural | NegativeNaturalMinusOne Natural ?
09:30:33 <kmc> symmetry :)
09:30:37 <kmc> but that works too
09:30:48 <dankna> hah okay :)
09:30:54 <kmc> or you can just have positive and negative zero
09:31:00 <kmc> like a one's-complement machine :)
09:31:03 <dankna> ha
09:31:11 <kmc> cause those are so popular nowadays
09:31:22 <kmc> pos/neg 0 can be useful in floating point
09:31:28 <dankna> so I've heard
09:31:34 <kmc> but floating point is just terrible
09:31:57 <dankna> I demand you implement type-level floating-point quaternions
09:32:04 <kmc> a number representation that makes both the computer scientists and the real-analysis people cry
09:32:19 <dankna> indeed.
09:32:20 <jonkri> so basically we can't do this with Int or Integer because it's optimized and not defined in haskell terms
09:32:21 <kulakowski> kmc: Is there a less terrible alternative you'd like to share?
09:32:29 <dankna> jonkri: correct
09:32:41 <Twey> 180125 < kmc> pos/neg 0 can be useful in floating point
09:32:43 <Twey> How so?
09:32:45 <kmc> kulakowski, for some applications yes, but no, i'm not asserting the existence of a better one in general
09:32:45 <dankna> jonkri: well actually not exactly
09:32:58 <dankna> jonkri: suppose that Int were an enumeration data Int = 0 | 1 | 2 | 3 ...
09:33:08 <kmc> Twey, when you want to know the sign of something even if it underflows
09:33:08 <Twey> IIRC the IEEE float just uses negative zero for NaN or something like that
09:33:08 <dankna> jonkri: you still couldn't do it, because Haskell does not support subset types
09:33:15 <Twey> Aha
09:33:37 <kmc> because positive values = launch zee missiles and negative values = surrender
09:33:39 <kmc> or something
09:33:52 <Twey> Heh
09:34:07 <jonkri> so what did you mean by me needing type-level integers then?
09:34:20 <dankna> jonkri: just as if we had type DanNamePart = Dan | N | Knapp, you couldn't define a type that would match only Dan
09:34:21 <monochrom> consistent with having +infinity and -infinity being different.
09:34:25 <quuuux> apparently, using case expressions with 336 branches slows down GHC somewhat
09:34:36 <jonkri> i see
09:34:42 <dankna> jonkri: well, you had asked a more specific question.  you said something like "can I define a type that /describes/ the range..."
09:34:59 <dankna> to which the answer is yes, but it's nontrivial and you have to seriously question the reasons for doing so
09:35:19 <jonkri> thanks :)
09:35:23 <dankna> sure :)
09:35:24 <jmcarthur> i don't know if i got this right: http://hpaste.org/44248/statically_typed_intervals_on
09:35:54 <jmcarthur> i haven't checked anything, and i don't have a way to construct Intervals from anything but Nats
09:36:54 <jonkri> crazy code :)
09:36:58 <jonkri> empty data types and stuff
09:37:11 <jmcarthur> necessary due to limitations of haskell :\
09:37:15 <dankna> huh, interesting
09:37:22 <monochrom> there was also an explanation of the usage of signed 0s by the numerical people, triggered by Java not providing it.
09:37:53 <copumpkin> fucking signed zero
09:38:22 <kmc> quuuux, heh
09:38:30 <kmc> quuuux, does it at least produce good code?
09:38:49 <jmcarthur> jonkri: as you can see, you basically have to prove by construction that a Nat is within the desired interval in order to construct an Interval value
09:38:51 <dankna> what are you casing on?  an instruction set architecture?
09:39:04 <quuuux> kmc: depends on your definition of 'good', but it won me a 20% speedup
09:39:06 <jmcarthur> jonkri: can be kind of involved, especially when you try to use it for anything more complicated
09:39:22 <jmcarthur> on the plus side, no smart constructors!
09:39:31 <quuuux> dankna: pre-computing factorials
09:39:36 <dankna> oh!  okay
09:39:40 <jmcarthur> although you still need a function to convert from "normal" numeric types to Nats and Intervals, and those would give you maybes
09:40:17 <jonkri> very interesting
09:41:35 <jmcarthur> jonkri: if you are willing to go with smart constructors then the implementation could be more efficient, but then you don't have as much of a guarantee that the implementation of Interval is correct
09:41:43 <monochrom> "how java's floating-point hurts everyone everywhere" slides http://www.cs.berkeley.edu/~wkahan/JAVAhurt.pdf
09:41:44 <turiya> my binary tree building is taking too long for a small tree (32 nodes). i am building it recursively and am also enforcing strictness.. i am not sure what i am doing wrong. are there any general strategies for speeding up constructing binary trees?
09:41:50 <jmcarthur> you could still have some guarantees that client code is using it correctly though, if you assume that the library is correct
09:43:33 <maurer_> What is the reccomended way to solve
09:43:34 <maurer_> cabal: Can't find transitive deps for haddock
09:43:52 <maurer_> Arising from using executables which depend on the library defined in the same package.
09:43:58 <dankna> maurer_: oh, weird
09:44:34 <maurer_> http://hackage.haskell.org/trac/hackage/ticket/656 <- there's already a bug filed on this, but I was wondering if there was a workaround
09:45:40 <jmcarthur> lol my code is wrong
09:45:47 <jmcarthur> oh
09:45:53 <jmcarthur> no it's not nevermind
09:45:57 <jmcarthur> i'll just stop looking at it
09:46:09 <dankna> maurer: I think the workaround is "don't do that then" :)
09:46:13 <jmcarthur> ever look at a word so long that it starts looking wrong and you question its spelling? ;)
09:46:20 <dankna> yes.
09:46:31 <jmcarthur> same thing happens to me with code sometimes
09:47:08 <dankna> agreed
09:49:40 <maurer_> danka: My build times literally more than triple if I "don't do that"
09:49:47 <kulakowski> jmcarthur: 's called semantic satiation
09:49:47 <maurer_> err, dankna
09:50:28 <aristid> @src foldl'
09:50:28 <lambdabot> foldl' f a []     = a
09:50:28 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:52:58 <dankna> maurer_: oh :(
09:53:52 <dankna> well, then I think the recommended solution is to get the cabal source and start debugging :(
09:56:40 <dankna> maurer_, out of curiosity, why does the dependency help your build times?
09:57:14 <maurer_> I'm using executable stanzas, so rather than rebuilding the entire library for each of the n executables in the package, I only build the big library (most of the build time) once, then build each of the little apps against it.
10:05:12 <LeeS> I'm having a problem with >>=, wondering if I could get some help
10:05:42 <LeeS> using Parsec,
10:05:50 <mauke> first you need to ask permission for asking permission
10:05:56 <LeeS> parsePart :: Parser Int
10:06:14 <LeeS> parsePart = many1 digit >>= read
10:06:33 <mauke> bzzt, type error
10:06:43 <kmc> "read" isn't a function returning a parser
10:06:44 <mauke> >>= requires (a -> m b), read is (a -> b)
10:06:50 <kmc> it's just a function you can apply to the result of the parser
10:06:57 <kmc> try:   fmap read (many1 digit)
10:07:03 <kmc> or:  read <$> many1 digit
10:07:08 <kmc> using (<$>) from Control.Applicative
10:08:09 <LeeS> Is there a way to lift the (a->b) to (a -> m b)??  The exercises in "Write yourself a scheme" said to do this with >>=
10:08:22 <LeeS> Maybe the exercises need some rework?
10:08:25 <mauke> yes, just use return :: b -> m b
10:08:28 <jmcarthur> you actually want to lift (a->b) to (m a -> m b)
10:08:32 <jmcarthur> that's what <$> does
10:08:37 <jmcarthur> or liftM, or liftA, or fmap
10:09:02 <jmcarthur> or to answer more directly
10:09:07 <jmcarthur> if you have f :: a -> b
10:09:12 <jmcarthur> (return . f) :: a -> m b
10:09:30 <jmcarthur> but then you still have to use >>=
10:09:34 <LeeS> OK, thanks all
10:09:42 <kmc> LeeS, many1 digit >>= (\x -> return (read x))
10:09:42 <jmcarthur> with <$> and company you don't need >>=
10:09:48 <kmc> but you can probably see why we prefer fmap / <$>
10:10:02 <LeeS> it certainly seems that <$> is the better choice
10:10:09 <mauke> @src liftM
10:10:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:10:09 <jmcarthur> it's in Control.Applicative
10:10:16 <jmcarthur> you should have liftM in scope already though
10:10:23 <mauke> and fmap
10:10:31 <jmcarthur> yeah, if it's an instance of Functor (Parsec is)
10:10:34 <mauke> @. undo src liftM
10:10:34 <lambdabot> ()
10:10:42 <mauke> wat
10:10:44 <jmcarthur> (must be an instance of Functor for <$> to work as well)
10:10:53 <jmcarthur> ...
10:11:02 <jmcarthur> @undo liftM f m1 = do { x1 <- m1; return (f x1) }
10:11:02 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1)
10:11:10 <jmcarthur> ...
10:15:42 <quuuux> oh, hey, my projected running time is down to below a month. Optimisation ftw
10:16:47 <jmcarthur> quuuux: what are you writing?
10:16:52 <maurer_> quuuux: Apply parallelism. Find 30 machines, and go to sleep :P
10:16:57 <kmc> haha
10:17:11 <quuuux> jmcarthur: some brute force-ish Bayesian analysis
10:17:13 <aristid> @src zipWith
10:17:14 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:17:14 <lambdabot> zipWith _ _      _      = []
10:17:26 <jmcarthur> ah
10:18:14 <aristid> the real implementation probably pulls out the f? zipWith f = go where go (a:as) (b:bs) = f a b : go as bs; go _ _ = []
10:18:22 <aristid> i guess i could look it up :D
10:18:59 <aristid> weird, it doesn't
10:19:03 <kulakowski> quuuux: Down to a month from what?
10:19:10 <aristid> so zipWith can never get inlined
10:19:23 <quuuux> kulakowski: on the order of years
10:19:25 <copumpkin> aristid: PATCH!!
10:19:30 <copumpkin> apply SAT
10:19:35 <aristid> copumpkin: huh?
10:19:42 <copumpkin> propose to fix that :P
10:19:55 <copumpkin> static argument transformation is what people are calling that stuff
10:20:30 <aristid> well, uh, that's too much hassle for something that doesn't really affect me :P
10:20:42 <copumpkin> dude it's for the good of the community :P
10:20:47 <copumpkin> :(
10:20:47 <quuuux> kulakowski: I didn't work it out exactly, I took one look at the number of zeros and decided to break out the profiler
10:20:53 <aristid> i just wanted to look up how zipWith works so i can implement a similar function
10:21:17 <kulakowski> quuuux: I can imagine. What are you doing?
10:22:15 <quuuux> kulakowski: Bayesian likelihood analysis, with a lot of variables
10:22:18 <aristid> copumpkin: i don't want you to be sad though, so please give me the link where i can report such issues :)
10:22:28 <copumpkin> aristid: I don't have one :)
10:22:32 <aristid> hmm
10:22:35 <aristid> ok google will help me
10:22:38 <copumpkin> but libraries@ is the typical place to talk about that stuff
10:22:55 <aristid> no i found a trac
10:22:57 <copumpkin> ah okay
10:23:05 <copumpkin> the list is a good place to get discussion about the issue as a whole though
10:23:14 <copumpkin> there may be other places in base where it would benefit
10:24:00 <kmc> is there somewhere i can see the entire module namespace of all Hackage packages
10:24:08 <kmc> have to decide between Data.Algorithm and Algorithm ;P
10:25:20 <ClaudiusMaximus> kmc: bit out of date i think.. https://gist.github.com/raw/463423/f8458d83b1a7cc26cdbf812747188993e50cd8a2/The%20Haskell%20module%20landscape
10:26:24 <kmc> thanks ClaudiusMaximus
10:26:49 <kmc> i wonder if i should advertise my module as "diff: now with 100% fewer snakes"
10:29:37 <sgronblo> random question, I don't know much about erlang and have only recently been rediscovering haskell out of curiousity. however i seem to remember that some code examples of erlang that I've seen looked a bit haskellish in the syntax. am I just remembering wrong or?
10:29:38 <aristid> copumpkin: http://hackage.haskell.org/trac/ghc/ticket/4976 :)
10:29:40 <monochrom> snakes?
10:30:08 <monochrom> both erlang and haskell enjoy pattern-matching IIRC
10:30:57 <kmc> sgronblo, i think the syntax is pretty different
10:31:08 <kmc> but these things are subjective
10:31:34 <saml> data Foo = X | Y       why not automatically  Foo.X  and Foo.Y  for namespacing
10:32:00 <saml> in the same module, if I have data Bar = X | Y   i cannot has cheeseburgers
10:32:02 <jmcarthur> saml: well we have modules for that, at least
10:32:10 <kmc> it's embarrassing that the best documentation of the algorithm i'm implementing is on livejournal
10:32:22 <saml> kmc, what is your algorithm?
10:32:22 <sgronblo> kmc: i see. anyway I guess I should just find out for myself.
10:32:29 <kmc> http://alfedenzo.livejournal.com/170301.html
10:32:30 <monochrom> these rhetorical "why not" questions are better left unanswered
10:33:01 <saml> livejournal is web scale. it's never down because of memcache
10:33:07 <jmcarthur> hard to tell when it's rhetorical sometimes
10:33:08 <kmc> hehehe
10:34:23 <c_wraith> ok....  What are the instance-resolution rules GHC uses between modules?
10:34:29 <saml> why if then else?   when there is case?
10:34:32 <c_wraith> I just ran into a strange case where something compile that shouldn't have
10:34:38 <saml> case expr of  True ->   False ->
10:34:41 <c_wraith> *compiled
10:34:46 <saml> can we remove if else?
10:35:04 <aristid> normally, you add numbers from right-to-left. but is it possible to do addition from left-to-right? maybe with a trick?
10:35:05 <c_wraith> saml: yes, there's no good reason for if/then/else to be syntax in haskell
10:35:26 <aristid> if should be a function
10:35:27 <c_wraith> aristid: use an appropriate fold?
10:35:33 <saml> yah i wanna define functions named if, then, else. let's remove it from syntax
10:35:43 <aristid> c_wraith: that's not helpful :(
10:36:14 <aristid> saml: you only need the if function
10:36:19 <aristid> saml: no need for then and else
10:37:12 <monochrom> there is a trick using a different representation. I forgot the details.
10:37:16 <copumpkin> aristid: yay
10:37:43 <aristid> monochrom: do you have keywords i can search for?
10:37:48 <monochrom> I don't.
10:37:52 <saml> aristid, what's type of your if function?
10:38:06 <aristid> :t let if' a b c = if a then b else c in if'
10:38:07 <lambdabot> forall t. Bool -> t -> t -> t
10:38:08 <saml> if :: Bool -> a -> a -> a
10:38:12 <aristid> yes.
10:42:43 <c_wraith> so yeah.  I had a module that was using an instance not imported by that module, including transitively.  It compiled anyway, because of something else GHC compiled before it.  Is that really the way instance resolution should be working?  I'd be much happier getting a compile error there.
10:43:21 <dankna> GHC unfortunately uses some IORefs under the hood and I suspect that's what's happening there
10:43:33 <dankna> that is, it's probably difficult to isolate that state
10:43:59 <c_wraith> hmm
10:44:03 <c_wraith> that is unfortunate
10:44:14 <c_wraith> The code was wrong, as I understand the haskell spec
10:44:16 <dankna> it might be worth opening a ticket for it,
10:44:24 <dankna> if you can produce a test case that clearly shouldn't compile but does?
10:44:35 <c_wraith> I'd have to work at it to produce something minimal
10:44:56 <dankna> I think it would be helpful
10:45:05 <c_wraith> at the moment, it's about 50 modules.  I think 3 should suffice.
10:45:06 <copumpkin> I agree
10:46:02 <c_wraith> I think this depends, to some extent, on what order ghc --make decides to compile modules in
10:46:21 <jystic> @pl f e = a $ m to fr e
10:46:21 <lambdabot> f = a . m to fr
10:46:25 <dankna> hmm
10:46:36 <dankna> very possible
10:47:03 <c_wraith> because if there was a transitive dependency forcing the order, it wouldn't be an error
10:47:51 <c_wraith> I'll look at creating a test case for this later
10:55:10 <zzing> If I wanted to make a library to allow a haskell program to interface with the windowing system on mac, linux, windows, etc. what would be the most generic way of implementing so the platform code is separate, but the program doesn't have to worry about what platform they are on?
10:56:28 <orbitz> Hello, does anyoen have a few minutes to give the Mr Wizard description of Dependent Types? I just don't get it..
10:57:05 <kmc> orbitz, do you know Haskell?
10:57:08 <kmc> how well
10:57:16 <orbitz> mildly
10:57:20 <sepp2k> Who or what is Mr. Wizard?
10:57:28 <kmc> try www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
10:57:37 <orbitz> sepp2k: Mr Wizard is an old sciecen show that would describe science ot chidlren
10:57:42 <kmc> Agda is dependently typed, but a lot like Haskell in other ways
10:57:52 <kmc> it's pretty accessible if you know Haskell and, say, GADTs
10:58:03 <orbitz> i'l look
10:58:03 <orbitz> thanks
10:59:09 <kmc> when you tell GHC "deriving (Typeable)", it could actually derive Typeable1?
10:59:11 <kmc> craaaazy
11:00:52 <byorgey> kmc: pretty cool, eh?
11:00:59 * copumpkin runs screaming
11:02:18 <quuuux> ghc -fvia-c likes the 336-branch case-expression even less, apparently
11:02:23 <kmc> haha
11:02:33 <kmc> did you look at the C output?
11:02:57 <quuuux> it's busy compiling and eating memory. The result had better be fast
11:03:05 <c_wraith> kmc: it can even derive Typeable2 in some cases
11:03:09 <kmc> :O
11:03:14 <orbitz> copumpkin: don't run form me!
11:03:21 <kmc> scientists are still trying to figure out how to derive Typeable3
11:03:36 <orbitz> kmc: they should make a science fiction movie out of it
11:03:43 <c_wraith> It probably will go all the way up to Typeable7
11:03:43 <orbitz> derive Typeable3 and grey goo happens
11:03:58 <c_wraith> That collection of classes is scary
11:04:16 <kmc> i wonder if i've ever created a type with 7 parameters
11:05:03 <c_wraith> however, deriving typeableX only works if all the type parameters have kind *
11:05:09 <c_wraith> if they don't, you have to do it manually
11:16:04 <copumpkin> http://snapplr.com/cjeq what's he talking about there?
11:16:29 <parcs> c
11:16:38 <parcs> (disregard)
11:16:50 <c_wraith> I think he's talking about "I don't know what I'm talking about"
11:16:54 <c_wraith> Or else "I'm lying"
11:17:15 <c_wraith> because quite obviously, tail calls optimization eliminate pushing/popping stack frames
11:17:33 <mauke> maybe he's thinking of perl
11:17:34 <c_wraith> err, call
11:18:10 <atxplay> preflex: seen xplat
11:18:10 <preflex>  xplat was last seen on #haskell 3 hours, 34 minutes and 55 seconds ago, saying: most OSes don't have to put you in a sandbox with runtime costs, the processor does it for them
11:19:24 <copumpkin> it makes no sense to me why it would use more instructions
11:19:29 <copumpkin> to eliminate tail calls
11:19:34 <c_wraith> It doesn't.
11:19:53 <tibbe> That's weird
11:20:09 <tibbe> GHC seems to be automatically picking an instance when two different ones are available
11:20:22 <tibbe> does GHC look through newtypes and see that two instances are the same (they're not)!
11:20:37 <copumpkin> tibbe: have any scary extensions turned on?
11:20:52 <tibbe> copumpkin: not that I know of
11:20:57 <kmc> that sounds a bit like the unsound Fc axioms bug from 6.12
11:20:59 <tibbe> GeneralizedNewtypeDeriving
11:21:10 <tibbe> this is on 7.0.1
11:21:18 <kmc> do you have a small test case?
11:21:39 <tibbe> kmc: not at the moment
11:25:23 * hackagebot comonad-transformers 1.5.2.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.2.2 (EdwardKmett)
11:28:34 <aristid> @hoogle Integer -> [Word]
11:28:35 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
11:28:35 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
11:28:35 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
11:28:44 <Kaidelong> bos: "abtruse kernel infelicities?" No better way to phrase that?
11:29:41 <Kaidelong> abstruse I mean
11:31:27 <Kaidelong> "arcane kernel design desicions" or something
11:32:31 <geheimdienst> Kaidelong: that would be much less of a lol :-(
11:33:13 <Kaidelong> geheimdienst: I admit I did giggle a bit. Although the point of experience reports isn't to make people laugh though... I think
11:34:52 <geheimdienst> i think it's not to be underestimated how much more enjoyable a text can be made by these small things, word choice and such
11:43:30 * hackagebot comonads-fd 1.5.2.2 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.5.2.2 (EdwardKmett)
11:44:22 <edwardk> preflex: xseen roconnor
11:44:22 <preflex>  roconnor was last seen on freenode/#haskell-blah 3 hours, 58 minutes and 28 seconds ago, saying: that's true
11:44:44 <edwardk> @tell roconnor added some lens support to comonad-transformers
11:44:44 <lambdabot> Consider it noted.
11:46:05 <mauke> preflex: peek-messages lambdabot
11:46:05 <preflex>  They don't have any new messages.
11:58:51 <EliasAmaral> how to get ghc to print the type of all top level definitions for me? (I supposed the .hi file was meant for that, but I guess I was wrong)
11:59:20 <EliasAmaral> I want to add a signature for something, but alas, I don't know its type..
11:59:28 <kmc> turn on -Wall
11:59:32 <mauke> load it in ghci
11:59:34 <kmc> in fact, always use -Wall always
11:59:42 <alej> why
11:59:43 <alej> ?
11:59:56 <kmc> because warnings are usefu
12:00:01 <parcs> EliasAmaral: :load file.hs followed by :type function
12:00:06 <kmc> in this case, it will give you the type of the thing with no type signature
12:00:14 <EliasAmaral> parcs, :load has a problem, the file has dependencies
12:00:22 <alej> I really should use -Wall
12:00:27 <EliasAmaral> and apparently I have to resolve them on my own
12:00:45 <alej> or at least have C-c C-l do -Wall if it doesn't already
12:00:47 <EliasAmaral> and perform the loading of everything on my own (nevermind ghc --make already has this code)
12:00:58 <parcs> EliasAmaral: that shouldn't be a problem..
12:01:11 <EliasAmaral> oh, uhm... er.. C-c C-l.. worked
12:01:31 <EliasAmaral> oh I know the prolbem. my modules were lowercase
12:01:51 <xplat> that ... is not recommended
12:01:55 <EliasAmaral> but I changed a while ago. well nice :)
12:02:19 <EliasAmaral> xplat, I think the requeriment for capitalized file is useless, since a module can't (sytactically) be lowercase..
12:02:46 <mauke> that way lies ocaml
12:02:54 <EliasAmaral> this promiscuous link between file and module reminds me the ugly part of java
12:04:56 <xplat> well, without it you need 'make depend'
12:06:21 <xplat> either periodically, or just scan every file under your project directory that changes to see what modules it contains
12:10:58 <kmc> is there a function like (a -> Maybe a) -> [a] -> [a]
12:11:06 <kmc> which is like "map" but stops at the first Nothing
12:11:55 <dankna> isn't the Maybe monad a little like that?
12:12:13 <dankna> :t (\a -> do a)
12:12:13 <lambdabot> forall t. t -> t
12:12:21 <dankna> hm
12:12:50 <mauke> @pl (\a -> do a)
12:12:50 <lambdabot> do
12:13:41 <EliasAmaral> is there an IO action that is like 'do nothing'?
12:13:48 <dankna> return ()
12:14:25 <xplat> :t catMaybes . sequence
12:14:26 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
12:14:26 <lambdabot>       Expected type: [[a1]] -> [Maybe a]
12:14:26 <lambdabot>       Inferred type: [[a1]] -> [[a1]]
12:14:27 <Boxo> > return undefined >> print "heh"
12:14:28 <lambdabot>   <IO ()>
12:15:13 <dankna> @pl let { visit [] results = results ; visit (Nothing:rest) results = results ; visit (Just item:rest) results = visit rest (results ++ [item]) } in visit [Just 4, Just 5, Just 6, Nothing, Just 7, Just 8, Just 9] []
12:15:13 <lambdabot> (line 1, column 5):
12:15:13 <lambdabot> unexpected "{"
12:15:13 <lambdabot> expecting "()", natural, identifier or "in"
12:15:15 <alej> map f . takeWhile isMaybe
12:15:24 <dankna> @pl let visit [] results = results ; visit (Nothing:rest) results = results ; visit (Just item:rest) results = visit rest (results ++ [item]) in visit [Just 4, Just 5, Just 6, Nothing, Just 7, Just 8, Just 9] []
12:15:24 <lambdabot> (line 1, column 11):
12:15:24 <lambdabot> unexpected "["
12:15:24 <lambdabot> expecting pattern or "="
12:15:55 <tromp_> :t isMaybe
12:15:56 <lambdabot> Not in scope: `isMaybe'
12:16:08 <dankna> :t isJust
12:16:09 <lambdabot> forall a. Maybe a -> Bool
12:16:12 <alej> errr
12:16:13 <alej> yeah
12:16:14 <alej> whatever
12:16:16 <alej> hehe
12:16:24 <alej> not isJust
12:16:27 <dankna> actually
12:16:28 <alej> errr
12:16:30 <kmc> so the "elf" package seems to be missing support for reading relocation tables; anyone know if this is in another package?
12:16:31 <alej> i am stupid
12:16:31 <tromp_> :t isNothing
12:16:32 <lambdabot> forall a. Maybe a -> Bool
12:16:35 <alej> isJust is what I want
12:16:36 <dankna> map fromJust . takeWhile isJust
12:16:37 <Boxo> calm down alej
12:16:48 <alej> haha sorry
12:16:50 <dankna> kmc: no idea
12:17:05 <xplat> dankna: that would do it
12:19:46 <EliasAmaral> Wow, I could make a program that read commands, such that each command might influence the outcome of the next commands (using State monad) and a state that corresponds to program halting (that actually halts). but I'm not sure this is the best way to model this..
12:20:22 <EliasAmaral> I do this with: handler state (Right c) = do { let (a, s) = runState (command $ c) state; putStrLn a; action s; return s }
12:20:38 <EliasAmaral> next step: encapsulate the IO action within StateT
12:20:53 <EliasAmaral> it's being challenging though
12:21:16 <xplat> @ty foldr (flip $ maybe [] . flip (:)) []
12:21:16 <lambdabot> forall a. [Maybe a] -> [a]
12:22:00 <xplat> > foldr (flip $ maybe [] . flip (:)) [Just 1, Just 2, Just 3, Nothing, Just 5, Just 6]
12:22:01 <lambdabot>   Overlapping instances for GHC.Show.Show
12:22:01 <lambdabot>                              ([Data...
12:22:11 <xplat> > foldr (flip $ maybe [] . flip (:)) [Just 1, Just 2, Just 3, Nothing, Just 5, Just 6] :: [Int[
12:22:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:22:15 <xplat> > foldr (flip $ maybe [] . flip (:)) [Just 1, Just 2, Just 3, Nothing, Just 5, Just 6] :: [Int]
12:22:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
12:22:15 <lambdabot>         against inferred typ...
12:22:41 <xplat> > foldr (flip $ maybe [] . flip (:)) [] [Just 1, Just 2, Just 3, Nothing, Just 5, Just 6] :: [Int]
12:22:42 <lambdabot>   [1,2,3]
12:22:52 <xplat> well, that was more annoying than it was meant to be
12:26:25 <astroboy> I have a big list of things that I have to store. Each thing as a score, and can be identified with an integer. I want to be able to keep a list sorted after the score of those things, and I want the possibility to change the score of a certain thing with a certain Id. What data structure would you suggest? 
12:28:25 <xplat> astroboy: a relational database
12:28:39 <astroboy> xplat: I want/have to do it with haskell :P
12:29:09 <companion_cube> a map from objects to scores ?
12:29:18 <xplat> then use haskelldb :þ
12:29:28 <astroboy> In C/Python etc I'd have a heap and a Set that gets you the object from the id, so i could change the score and rebuild the heap
12:29:50 <rly> astroboy: that would be a horrible idea. 
12:30:07 <astroboy> rly: what would you suggest then?
12:30:40 <astroboy> xplat: I'd like to do it myself with haskell data types...
12:30:47 <xplat> you could always duplicate that by using a treap, and then people could DOS you by scoring in order of arrival ...
12:30:53 <rly> astroboy: this is not #datastructures. Go to a university if you want to learn how to do this. 
12:31:38 <astroboy> rly: why so angry? I want to do it in haskell
12:32:02 <astroboy> rly: and I already go to a uni
12:32:04 <companion_cube> astroboy, you have plenty of data structures in haskell
12:32:04 <djahandarie> rly, could you take it down a notch? We aren't against learning in here. :)
12:32:34 <astroboy> companion_cube: I still can't find something good in haskell do do what I want to do
12:32:36 <companion_cube> astroboy, there is Data.Set and Data.Map, that should be enough, i guess
12:32:40 <rly> astroboy: learning Haskell/=introduction to algorithms.
12:33:05 <Philippa> rly: knock it off
12:33:06 <aristid> rly: i think it's perfectly OK to discuss data structures in #haskell, as long as you want to implement them in haskell
12:33:12 <astroboy> rly: I have the clrs next to me, and I think I'll be able to solve that in a non purely functional language
12:33:24 <Philippa> especially as haskell often requires different data structures to those common in an imperative language
12:33:27 <EliasAmaral> astroboy, can't you use a heap?
12:33:30 <companion_cube> what misses you, astroboy ?
12:33:48 <Philippa> astroboy: read up on finger trees, you'll enjoy
12:34:03 <astroboy> EliasAmaral: I want to retrieve the elements by their ids, and order them by their scores. And I want to be able to change the score
12:34:07 <astroboy> Philippa: I will! thanks
12:34:14 <xplat> you could keep a Data.Set.Set of (score, idnum) and a Data.Map.Map from idnum to score
12:34:30 <Philippa> how often will you need them ordered by score compared to your update frequency?
12:34:36 <xplat> although you might want to use an IntMap in the second case
12:34:49 <EliasAmaral> astroboy, you want two orderings? a heap would order by the score, with the ability to change the score
12:34:52 <rly> astroboy: almost all of the data structures in clrs can be implemented in a purely functional way (and they have already been implemented). 
12:34:55 <astroboy> xplat: that would be slow, and you're basically simulating pointers with the ints :P
12:35:01 <EliasAmaral> are you sure you will going to need to order by the id as well?
12:35:16 <EliasAmaral> you almost never will need to order by two constraints
12:35:35 <xplat> astroboy: do you want to have a list ordered by score, or do you just want the few high scores?
12:35:35 <astroboy> rly: that's not true, a lot (and I mean a lot) use references. That's why this book exists: http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1298495167&sr=8-1
12:35:42 <rly> astroboy: did you try to implement any data structure from clrs in Haskell?
12:36:03 <astroboy> xplat: I want a few high scores most of the times, but I want to be able to get the low ones as well.
12:36:05 <silbo> hey guys
12:36:07 <edwardk> Astroboy: the easiest way to implement what you ask would be a ingertree
12:36:09 <Philippa> rly: if someone's citing Okasaki at you, it's time to drop the high and mighty
12:36:33 <rly> Philippa: would you be so kind to explain why?
12:36:58 <rly> astroboy: you might think so, but you would be wrong. 
12:37:09 <Philippa> because they know enough to show legitimate interest in something other than the standard library structures
12:37:16 <xplat> astroboy: if you use a heap to keep the order by score, it takes as long (within a constant) to pull the scores out as it would to sort them
12:37:16 <astroboy> rly: even something stupid like a queue is not trivial in haskell
12:37:36 <EliasAmaral> astroboy, a queue? why?
12:37:37 <Philippa> astroboy: depends what performance you want, but if you're not happy paying the log hit, agreed
12:37:38 <rly> astroboy: your idea of trivial clearly differs from the mathematical meaning of trivial.
12:37:39 <xplat> so you're only really gaining for the 'few top scores' case
12:37:48 <edwardk> rly: chill out
12:37:50 <EliasAmaral> I think there is already a queue in the standard library
12:37:54 <companion_cube> i agree for the queue
12:38:12 <companion_cube> it's not as trivial as in C
12:38:19 <edwardk> queues are actually something non-trivial in a functional framework, especially if you want O(1) enqueue and dequeue.
12:38:30 <silbo> Hey guys, any Google Summer Of Code potential mentors here?
12:38:42 <edwardk> or worse if you also want O(log(min(m,n)) split
12:38:45 <edwardk> silbo: yes
12:38:46 <astroboy> EliasAmaral: a queue is "obvious" in most programming languages. they're not in haskell, how do you push at the back and pop at the front in 0(1)?
12:39:01 <silbo> edwardk: hey it's you again xD
12:39:09 <silbo> edwardk: nice to see you too
12:39:23 <EliasAmaral> astroboy, who needs exactly O(1)? :t
12:39:26 <Philippa> astroboy: FWIW, you'll get fewer arguments if you qualify about desired performance straight away
12:39:26 <astroboy> anyway, finger trees seem to be the most popular suggestion, I'll read on them
12:39:31 <edwardk> EliasAmaral: i do ;)
12:39:34 <astroboy> EliasAmaral: I do
12:39:38 <Philippa> EliasAmaral: people working on datasets where log isn't a small number
12:39:39 <astroboy> ahah
12:39:46 <Philippa> log isn't even 32 any more
12:40:06 <xplat> Philippa: they can use a larger base
12:40:08 <astroboy> Philippa: I'd like to access members in constant time and change priority in O(log n)
12:40:08 <Philippa> we're sure not in the days when it wasn't going to be more than 16 :-)
12:40:18 <EliasAmaral> O(log n) would grow too much? it depends more on the constants than n I guess
12:40:41 <mauke> priority? what
12:40:48 <mauke> is this queues or priority queues?
12:40:52 * hackagebot pdfinfo 0.1 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-0.1 (ChrisDone)
12:40:54 * hackagebot sequential-index 0.0 - Sequential index numbers between 0.0 and 1.0 that allow arbitrarily inserting new numbers in between (for special containers).  http://hackage.haskell.org/package/sequential-index-0.0 (AristidBreitkreuz)
12:41:02 <xplat> astroboy: access members by ID in constant time?
12:41:26 <xplat> astroboy: technically you can't even do that in imperative languages
12:41:32 <astroboy> xplat: you are right that's asking for too much
12:41:41 <astroboy> let's say in IntMap time :P
12:41:42 <djahandarie> astroboy, Data.Sequence from containers is an example of a finger tree with a list-like interface. It notes most of the O()s in there too.
12:41:49 <edwardk> astroboy: a fingertree with a monoid that looks like data M k v = M Priority k v | E
12:43:12 <astroboy> djahandarie, edwardk: thanks, looking at it now
12:43:12 <edwardk> astroboy: with mempty = E, and mappend E b = b; mappend a E = a; mappend (M p k v) (M p' k' v') | p <= p' = M p k v' | otherwise = M p' k' v' 
12:43:58 <silbo> edwardk: can you give an example project that will be on google summer of code? xD
12:44:15 <edwardk> astroboy: then you make your inserts into the tree preserve the ordering on v, so that you have an ordering on the values, and you can extract the least priority'd k.
12:44:23 <Philippa> doing my homework for me's always a classic SoC project :-)
12:44:29 <xplat> anyway re: big logs, even in these troubled days speed still doubles more often than dataset size squares
12:44:34 <edwardk> by using split to find it, and then grafting the fingertree back up around you
12:44:37 <Philippa> I seem to be stuck on parsing still though
12:45:35 <EliasAmaral> would removing mutability actually makes the best algorithm for some problem to have a worse complexity?
12:45:51 <edwardk> silbo: the main focus for the summer of code for the haskell community is incremental improvement to projects already in use by the community. one example might be taking something like jmacro and adding efficient bytestring builder support, or a back end to the existing javascript minimizer to make it generate smaller code, both woul work well with integrating it into modern web front ends
12:46:09 <edwardk> EliasAmaral: sometimes, it costs you a logarithmic factor
12:46:22 <edwardk> EliasAmaral: provably in a strict setting, it is an open question in a lazy setting
12:46:27 <xplat> EliasAmaral: for example, on union-find
12:46:57 <astroboy> edwardk: So wait, I "index" (don't know if this is the right term) the sequence using the score
12:47:00 <astroboy> edwardk: what about duplicate scores?
12:47:05 <edwardk> union-find in a strict environment is provably a logarithmic factor slower than the optimal O(n alpha n)
12:47:05 <astroboy> also, how can I retrieve quickly the element by id?
12:47:08 <kmc> EliasAmaral, you can emulate mutable variables with a O(log (# variables)) cost
12:47:14 <rly> edwardk: doesn't that only count for RAM machines which have no side-effecting operations? 
12:47:24 <kmc> by passing and modifying a tree indexed by the variable name or whatever
12:47:35 <kmc> EliasAmaral, Haskell has plenty of true mutable variables though
12:47:56 <companion_cube> in ST ?
12:48:00 <rly> edwardk: if you do have operations which need to happen in order, I can think of examples where you always lose a log factor. 
12:48:02 <edwardk> astroboy: the 'v' there is the 'id', the 'k' there is the actual item, 'p' is the score.. so you store the elements sorted by id, but you use the monoid to build up as you climb the tree what the smallest priority item you've seen in that portion fo the tree
12:48:03 <kmc> IO, ST, STM, etc.
12:48:18 <EliasAmaral> edwardk, logarithmic factor like some algorithm with complexity O(f(n)) would become O(log(n) * f(n)) ?
12:48:19 <kmc> arrays, unboxed vectors, Chans, synchronization primitives of various sorts
12:48:31 <astroboy> edwardk: Oh, ok. It kinda makes sense. Thanks a lot
12:48:35 <kmc> there's no shortage of tools for imperative programming in Haskell
12:48:49 <EliasAmaral> kmc, oh, ST uses mutability underneath? hm
12:48:57 <edwardk> EliasAmaral: yes, because you can emulate mutable pointers with a tree in the back end
12:49:21 <edwardk> EliasAmaral: so you at worst pick up a logarithmic factor to deal with dereferencing costs.
12:49:30 <kmc> EliasAmaral, STRef and IORef have the same runtime implementation in GHC
12:49:42 <kmc> the difference between them is entirely a static type-level thing
12:49:50 <silbo> edwardk: ok thx for the information, I will try to find something in google about it
12:50:08 <astroboy> edwardk: yeah but that's still quite bad, I think that emulating pointers that way is almost always stupid
12:50:46 <aristid> just for fun (and profit): what would be a good infix operator for taking the average of two values? :)
12:50:55 <edwardk> astroboy: merely pointing out that it exists as a simple encoding of how you can make any imperative pointer-machine algorithm into a pure persistent algorithm
12:50:58 <rly> astroboy: your problem does not require mutable variables. 
12:51:14 <astroboy> rly: that comment wasn't related to my problem
12:51:16 <xplat> astroboy: there are often better ways, but it does place a bound on how much better mutability can make something
12:51:21 <EliasAmaral> but at best one could maybe make up a functional solution with the same complexity as an imperative solution? or it is impossible?
12:51:38 <kmc> EliasAmaral, often possible, sometimes impossible
12:51:41 <rly> astroboy: can you then explain your reaction to edwardk?
12:51:56 <astroboy> xplat, edwardk: yeah it's just that emulating pointers it's an idea that often crosses my mind but I always rejected it :P
12:52:11 <kmc> EliasAmaral, this fact is of limited real-world application though
12:52:11 <astroboy> rly: ? this is a chat I comment on things
12:52:11 <xplat> rly: did astroboy run over your dog or something?
12:52:35 <rly> xplat: are you the same user as astroboy?
12:52:35 <kmc> EliasAmaral, because every practical functional language lets you also do mutation and imperative programming
12:52:43 <kmc> and there are nice ways to mix the techniques
12:52:46 <Philippa> rly: knock it off. Last warning.
12:52:49 <astroboy> rly: ok you're just trolling I'll stop answering
12:52:58 <edwardk> rly: chill
12:54:15 <EliasAmaral> kmc, i mean, i see in a lot of places that FP is going to be the future because of penalties when sharing data between imperative programs. but if there are problems that require mutability to be feasible, then it must stay at least inside each process
12:54:44 <astroboy> btw the application is a reddit-like post sytem, in which the posts get scores based on various factors
12:55:15 <companion_cube> and you really cannot use a DB ?
12:55:23 <edwardk> EliasAmaral: immutability helps when it comes to reasoning equationally about an API, and lets you cheaply recycle previous results or earlier states, but it isn't a panacea.
12:55:34 <companion_cube> too bad
12:55:38 <astroboy> companion_cube: it's just an exercise. I'm writing it in happstack and I want to use the MACID and nothing else
12:55:56 <Philippa> finger trees're the way to go there, anyway
12:56:05 <rly> Why does everyone recommend him to go and look at fingertrees while there are already libraries which solve the exact problem he has? 
12:56:22 <astroboy> rly: could you tell me which libs?
12:56:49 <edwardk> rly: a priority queue with the ability to access by id?
12:57:11 <edwardk> rly: not aware of a convenient library for that here.
12:57:18 <rly> astroboy: I am only trolling here, so I won't. 
12:57:27 <astroboy> lol ok
12:57:41 <tibbe> edwardk: the PSQ supports an extra key
12:57:50 <tibbe> edwardk: so you can access by priority or key
12:58:17 <djahandarie> tibbe, and those are just finger trees aren't they?
12:58:32 --- mode: ChanServ set +o Philippa
12:58:40 --- kick: rly was kicked by Philippa (I said last warning)
12:58:44 <tibbe> djahandarie: the PSQ is implemented using a tournament tree
12:58:46 <edwardk> tibbe: ah, didn't realize fingertree-psqueue already had the monoid i was mentioning =)
12:58:50 --- mode: Philippa set -o Philippa
12:59:07 <edwardk> tibbe: there is also a fingertree impl: http://hackage.haskell.org/packages/archive/fingertree-psqueue/0.2/doc/html/Data-FingerTree-PSQueue.html
12:59:15 <astroboy> tibbe: that's exactly what I need! thanks
12:59:18 <edwardk> but its less efficient than the tournament tree one
12:59:33 <tibbe> edwardk: there's also a package called 'PSQ'
12:59:38 <djahandarie> Is the tournament tree one implemented in some package?
12:59:39 <djahandarie> Ah
12:59:48 <tibbe> sorry, it is: http://hackage.haskell.org/package/PSQueue
13:01:58 <astroboy> tibbe: yeah I was looking at that! Now I want to know how they work ehe
13:01:59 <rly> I am glad at least someone else also knew the answer for astroboy's sake. 
13:02:04 <tibbe> astroboy: they work like a normal priority queue, but also allow you to edit items already in the tree using a key
13:02:07 <tibbe> astroboy: so you can update the priority of an item
13:02:14 <Philippa> rly: in future, give the answer
13:03:11 <monochrom> PSQueue rocks
13:03:14 <astroboy> rly: if you really knew the answer, and you don't want people to talk about data structures here, the best way would've been to tell me
13:03:25 <rly> astroboy: nah, you were already full of yourself. 
13:03:44 <astroboy> rly: ok. whatever. I tried.
13:05:07 <kmc> woah, we're at 762 users
13:05:17 <alej> crap haskell isn't cool anymore, it's too popular
13:05:30 <djahandarie> Quick, everyone jump ship!
13:05:39 <Philippa> worse, we're drawing gun numbers in our user count
13:05:39 <Philippa> maybe we could use that for a cull though?
13:05:43 <monochrom> still cool until 1000 users. oh wait, already happened at stackoverflow
13:06:16 <Philippa> rly: none of what's gone above was "intro to algorithms" stuff and it was firmly on-topic however
13:07:01 <monochrom> I think "why aren't you listening to me!" was the real problem.
13:07:11 * djahandarie agrees and thinks that "purely functional data structures" chat is on-topic in #haskell .
13:08:28 <Philippa> *nod*. Though threads that do little but hook a lazy ST computation up to a couple of Chans can be a laugh too
13:18:12 --- topic: '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
13:18:12 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Fri Jan 28 14:21:41 2011]
13:19:35 <EliasAmaral> f (a b) (c d) -> f (a b) $ c d. is there a way to remove the () from (a b) too?
13:20:00 <rly> kmc: I never suggested it was shocking. 
13:20:51 <Philippa> rly: none of what's gone above was "intro to algorithms" stuff and it was firmly on-topic however
13:27:04 * hackagebot FTPLine 1.3.0 - A command-line FTP client.  http://hackage.haskell.org/package/FTPLine-1.3.0 (DanielDiaz)
13:41:21 --- mode: gibson.freenode.net set +o ChanServ
13:46:46 <EliasAmaral> why is the kind * -> * -> * different from (* -> *) -> *?
13:47:37 <tromp_> cause it's * ->  (* -> *) 
13:47:38 <c_wraith> EliasAmaral: Because * -> * -> * is * -> (* -> *)
13:47:39 <byorgey> EliasAmaral: -> associates to the right, so  * -> * -> *  is the same as  * -> (* -> *)
13:48:00 <wavewave> where is 'lookAhead' in attoparsec?
13:48:15 <byorgey> EliasAmaral: put another way,  * -> * -> *  is the kind of types that take two type parameters, whereas  (* -> *) -> * takes *one* (higher-order) parameter
13:48:34 <wavewave> It was in attoparsec 0.7 but I cannot find it in current version.
13:49:22 <EliasAmaral> oh i see
13:50:01 <c_wraith> @kind Either
13:50:13 <c_wraith> ...  we've lost \bot
13:51:51 <EliasAmaral> lambdabot, hi
13:54:39 <EliasAmaral> :t forM
13:54:50 <EliasAmaral> @hoogle forM
13:55:24 <byorgey> forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:55:53 <byorgey> forM = flip mapM
13:56:00 <byorgey> mapM f = sequence . map f
14:02:17 <wavewave> anyone can answer about attoparsec lookAhead?
14:08:35 <Mitar> is there assert-like function for IO mand?
14:08:56 <Mitar> which would assure execution order (like difference between throw and throwIO)?
14:09:16 <EliasAmaral> http://stackoverflow.com/questions/4204086/is-the-monad-w-instance-anywhere-standard
14:10:04 <lambdabot> * -> * -> *
14:10:13 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:10:13 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
14:10:13 <lambdabot> Network.Browser data Form
14:10:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:11:22 <tibbe> dcoutts: which parts of your thesis did you recommend I read?
14:12:48 <gwern> edwardk: yeah, see the -cafe thread
14:13:13 <gwern> edwardk: unordered-containers specifically
14:13:25 <azaq23> Mitar: Standard "fail" of the monad typeclass seems like what you're looking for, but it's somehow not recommended (though maybe only in general, not for IO specifically), 
14:13:26 <azaq23> and I don't know enough about throw / throwIO to understand what you're saying with this, so this is the best I can say.
14:13:51 <azaq23> @src IO fail
14:13:52 <lambdabot> fail s  = failIO s
14:14:30 <Mitar> i would need assert, not fail
14:14:39 <Mitar> and difference is explained in documentation of Control.Exception
14:15:11 <Mitar> Although file:///usr/share/doc/ghc/html/libraries/base-4.3.0.0/Control-Exception.html#v:throwIO has a type that is an instance of the type of file:///usr/share/doc/ghc/html/libraries/base-4.3.0.0/Control-Exception.html#v:throw, the two functions are subtly different.
14:15:14 <edwardk> gwern: ah that.
14:15:24 <Mitar> The file:///usr/share/doc/ghc/html/libraries/base-4.3.0.0/Control-Exception.html#v:throwIO variant should be used in preference to file:///usr/share/doc/ghc/html/libraries/base-4.3.0.0/Control-Exception.html#v:throw to raise an exception within the file:///usr/share/doc/ghc/html/libraries/base-4.3.0.0/System-IO.html#t:IO monad because it guarantees ordering with respect to other file:///usr/share/doc/ghc/html/libraries/base-4.3.0.0/System-IO.html#t:IO operations, 
14:17:04 <dankna> Miktar: you are linking us to things on your own filesystem
14:19:10 <maurer_> dankna: He probably just copied out of his browser.
14:19:37 <EliasAmaral> can one do deriving (Functor, Monad)? what it would mean? o.o like data X a = X a | Y a deriving (Functor, Monad)
14:19:37 <dankna> yes, I wished to point that out to him :)
14:19:41 <Mitar> dankna: those are links? oh, this rich-text copy/paste
14:19:42 <Mitar> sorry
14:19:49 <dankna> oh, haha
14:19:51 <dankna> np
14:20:22 <Mitar> i just wanted to copy text, so this is interesting to know ;-)
14:20:28 <Mitar> but does not help me with assert ;-)
14:21:04 <monochrom> "deriving (Functor,Monad)" does not work for most cases.
14:21:32 <c_wraith> deriving Functor works with recent enough version of GHC
14:22:58 <byorgey> EliasAmaral: according to folklore, some types have more than one valid Monad instance
14:23:03 <byorgey> although I don't know of any off the top of my head
14:23:35 <byorgey> however, any given type has either 0 or 1 valid Functor instances
14:24:17 <EliasAmaral> <byorgey> however, any given type has either 0 or 1 valid Functor instances
14:24:29 <byorgey> EliasAmaral: in the special case of a newtype wrapper around an existing Monad it is possible to say deriving Monad using GeneralizedNewtypeDeriving
14:24:31 <edwardk> byorgey: State
14:24:39 <byorgey> oh right!
14:24:46 <EliasAmaral> I heard that monads actually are like functor plus flatten/something like that
14:24:54 <byorgey> there's the normal State monad and the spooky backwards-time-traveling-state monad
14:25:02 <EliasAmaral> so it is flatten that can be chosen more than one way?
14:25:06 <edwardk> EliasAmaral: monads = functor + join + return
14:25:22 <shachaf> byorgey: Spooky backwards-time-traveling state monad?
14:25:26 <edwardk> EliasAmaral: correct
14:25:32 <byorgey> EliasAmaral: yes, "flatten" = join
14:25:48 <edwardk> shachaf: when you go to define a state monad, there is more than one way to plumb the state through. the obviously correct way, but you can also screw up and wire it backwards
14:25:52 <byorgey> shachaf: yes, just wire up the state-passing the other way when you implement >>=
14:26:02 <EliasAmaral> o.o
14:26:07 <shachaf> edwardk: Does anything interesting happen when you do that?
14:26:08 <djahandarie> Are there any actual uses for that btw?
14:26:14 <EliasAmaral> so what this will means? o.o
14:26:21 <EliasAmaral> mean*
14:26:45 <edwardk> shachaf: this means you get state from the 'future' and send them backwards into the computation, this works fine as long as the control flow your state monad doesn't depend on the state in question
14:27:13 <EliasAmaral> so if it eval the state at all it loops forever?
14:27:19 <ddarius> djahandarie: Yes!
14:27:34 <djahandarie> ddarius, neat, like what?
14:28:12 <edwardk> @quote edwardk state
14:28:12 <lambdabot> edwardk says: All you need to do to time travel is use the backward state monad trick on IO, so just rewrite IO, which is State# RealWorld -> (# a , State# RealWorld irc://irc.freenode.net/#) with
14:28:12 <lambdabot> the wrong bind. I tried that next Tuesday and i'm still getting over the vomiting and disorientation.
14:28:14 <jkarlson> is there really no IO Bool -> IO () loop
14:28:52 <djahandarie> lol
14:30:02 <maurer_> Ke: What do you want it for?
14:30:31 <edwardk> EliasAmaral: it is easy to get tied into a knot where your answer depends on your answer
14:30:47 <Ke> iterate IO function until it returns True so false
14:31:06 <maurer_> Ke: I quite understand what you want the function to do. I'm questioning what you want to use it for.
14:31:39 <azaq23> Mitar: AFAIC tell, If you want the exact assertIO equivalent to assert, you'll likely not find anything as there's nothing documented in Control.Exception, since assert seems to be (when you view the source in the Control.Exception doc) implemented as a magic function like seq
14:31:50 <Ke> I want retry connectin to server if the first try fails
14:32:26 <byorgey> Ke: shouldn't be hard to write yourself, I don't think there's a standard library function to do that
14:32:38 <Ke> yup, I know it's easy
14:32:40 <edwardk> whileM mb = do b <- mb; when b $ whileM mb
14:34:45 <byorgey> whileM = ap (>>=) (flip when . whileM)
14:35:29 <byorgey> hooray for unnecessary code golf via equational reasoning
14:35:36 <j-invariant> byorgey horay
14:35:38 <j-invariant> hooray
14:36:16 <j-invariant> whens the monad reader
14:36:51 <parcs> :t ap (>>=) (flip when . whileM)
14:36:52 <lambdabot> Not in scope: `whileM'
14:37:03 <parcs> :t let whileM = ap (>>=) (flip when . whileM)
14:37:04 <lambdabot> <no location info>:
14:37:04 <lambdabot>     not an expression: `let whileM = ap (>>=) (flip when . whileM)'
14:37:11 <parcs> eh :(
14:37:12 <Mathnerd314> :t while
14:37:13 <lambdabot> Not in scope: `while'
14:37:15 <edwardk> in whileM
14:37:20 <parcs> :t let whileM = ap (>>=) (flip when . whileM) in whileM
14:37:21 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
14:37:27 <parcs> :t let whileM = flip ap (>>=) (flip when . whileM) in whileM
14:37:29 <lambdabot>     Couldn't match expected type `Bool'
14:37:29 <lambdabot>            against inferred type `(a -> m b) -> m b'
14:37:29 <lambdabot>       Expected type: m a -> Bool -> m1 ()
14:37:45 <j-invariant> I dont get haskell whats the big deal
14:37:48 <j-invariant> its just another language?
14:38:03 <parcs> :t fix $ ap (>>=) . flip when
14:38:05 <lambdabot>     Couldn't match expected type `m a' against inferred type `Bool'
14:38:05 <lambdabot>     In the first argument of `flip', namely `when'
14:38:05 <lambdabot>     In the second argument of `(.)', namely `flip when'
14:39:03 <edwardk> @type let whileM = (>>=) <*> flip when . whileM in whileM — kills some parens
14:39:04 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
14:39:48 <j-invariant> shapr
14:39:56 <copumpkin> @get-shapr
14:39:57 <lambdabot> shapr!!
14:40:09 <edwardk> j-invariant: trolling again?
14:40:14 <byorgey> @type let whileM = fix $ \f -> (>>=) <*> flip when . f in whileM  ? kills some puppies
14:40:16 <lambdabot> Not in scope: `?'
14:40:16 <lambdabot> Not in scope: `kills'
14:40:16 <lambdabot> Not in scope: `puppies'
14:40:28 <byorgey> wait, how did you do the ? thing
14:40:28 <j-invariant> edwardk: whats life all about
14:41:21 <Mathnerd314> would there be problems with instance (Monad a, Monad b) => Monad (a b) ?
14:41:28 <copumpkin> kind
14:41:30 <edwardk> Mathnerd314: yes
14:41:35 <j-invariant> ANYONE HERE NOT BORING?
14:41:35 <shachaf> byorgey: That wasn't a ?, it was a Unicode em-dash.
14:41:41 <Mathnerd314> Monad (a . b), then
14:41:44 <shachaf> byorgey: I guess lambdabot treats it as --?
14:41:47 <copumpkin> Mathnerd314: yes
14:41:49 <byorgey> oh. I guess so!
14:42:02 <copumpkin> Mathnerd314: you can do it with functor
14:42:03 <edwardk> Mathnerd314: a.) the kinds don't line up, but even if you make a :. b for some type composition operator :., in general monads don't compose.
14:42:23 <monochrom> something broke lambdabot's utf8 support
14:42:35 <edwardk> functors, and applicatives compose in general. but there isn't a general purpose monad coproduct for any two arbitrary monads
14:42:35 <Mathnerd314> edwardk: example of when they don't?
14:42:46 <centrinia> Is there a Monad type?
14:42:52 <byorgey> Mathnerd314: it's sufficient (but not necessary, I think) for the monads to commute, i.e. there is a function  comm :: m (n a) -> n (m a)
14:42:56 <edwardk> mathnerd: STM :. IO
14:43:06 <lambdabot> I thought the high bit was the evil bit?
14:43:16 <byorgey> Mathnerd314: implementing 'join' is the hard part
14:43:20 <copumpkin> lambdabot is talking again
14:43:20 <edwardk> mathnerd: more subtly IO :. []
14:43:33 <j-invariant> data Monad m = MakeMonad { fmap :: (a -> b) -> m a -> m b ; join :: m (m a) -> m a ; return a -> m a}
14:43:38 <edwardk> mathnerd: pointed functors compose. so you can get the return to work
14:43:39 <lambdabot> Oh, look, the ape can string a sentence together!
14:43:48 <j-invariant> primeates
14:43:52 <j-invariant> humans evolved from mice
14:43:54 <j-invariant> in my theory
14:43:55 <Mathnerd314> byorgey: ah. I see.
14:44:00 --- mode: ChanServ set +o monochrom
14:44:05 <edwardk> mathnerd: but to build the bind you need some kind of trick. usually in the form of a distributive law or way to merge monads together.
14:44:15 --- mode: monochrom set +q j-invariant!*@*
14:44:21 --- mode: monochrom set -o monochrom
14:44:22 <lambdabot> Has anyone really been far even as decided to use even go want to do look more like?
14:44:51 --- mode: ChanServ set +o monochrom
14:44:56 --- mode: monochrom set +b j-invariant!*@*
14:45:09 <djahandarie> -_-
14:45:11 --- mode: monochrom set -q j-invariant!*@*
14:45:13 <edwardk> e.g. a m :. n ~> m, m :. n ~> n :. m, or m :. n :. m ~> m :. n law — other constructions like state are built by sandwiching an adjunction, or using the traversable-ness of left adjoints or the distributiveness of right adjoints
14:45:16 --- mode: monochrom set -o monochrom
14:45:32 <monochrom> childish behaviour
14:46:26 <byorgey> lambdabot also seems to be exhibiting childish behaviour
14:46:33 * copumpkin whistles innocently
14:46:46 <monochrom> /mode #haskell +q lambdabot!*@*
14:46:49 <edwardk> strangely lambdabot looked a bit like a pineapple for a moment there
14:47:01 * copumpkin whistles innocently
14:47:18 <Mathnerd314> copumpkin: why are you whistling so innocently?
14:47:24 <copumpkin> no reason
14:47:26 * copumpkin whistles innocently
14:48:12 <edwardk> I've always wondered why it was called whistling innocently. I've only ever heard whistling out of folks who are guilty.
14:48:41 * centrinia whistles guiltily.
14:49:36 <lambdabot> I'm whistling innocently too
14:49:43 <monochrom> haha
14:51:16 <edwardk> djahandarie: i just saw your losing rap battle. greatly amused
14:51:24 <djahandarie> edwardk, :P
14:53:18 <djahandarie> edwardk, have you uploaded those videos yet?
14:56:27 <edwardk> ping me in a couple hours when i'm physically located near the camera. you always ask me when i'm at the office =)
14:56:30 <blackdawn> hey
14:56:37 <blackdawn> i'm using sqrt n
14:56:42 <blackdawn> and i want it to return a int
14:56:49 <blackdawn> so i can use it with [ 1 .. sqrt n ]
14:56:52 <blackdawn> how can i achieve that
14:56:54 <dankna> :t floor
14:56:55 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:56:59 <djahandarie> edwardk, solution is to just bring the camera to work. ;)
14:57:17 <dankna> > let n = 64 in [1 .. floor $ sqrt n]
14:57:18 <lambdabot>   [1,2,3,4,5,6,7,8]
14:57:54 <blackdawn> i see.
14:57:55 <blackdawn> thank u dankna 
14:57:58 <dankna> np
14:58:14 <blackdawn> dankna, why did u put $ ?
14:58:39 <dankna> blackdawn: it's equivalent to floor (sqrt n)
14:58:53 <dankna> $ is an operator that essentially puts everything after it in parentheses, and does nothing else
14:58:55 <blackdawn> danharaj, i see.
14:58:56 <blackdawn> thank u
14:59:11 <dankna> so many Dans in here :)
15:04:13 <danglego> I am using a language with TCO, therefore, I cannot use DList, however, what is the next best thing to use in the Writer monad for appending values? I am thinking Data.Sequence
15:04:20 <danglego> s/with/without
15:04:21 <ezyang> @seen copumpkin 
15:04:22 <lambdabot> Unknown command, try @list
15:04:22 <preflex>  copumpkin was last seen on #haskell 16 minutes and 55 seconds ago, saying: * copumpkin whistles innocently
15:04:26 * copumpkin hides
15:04:34 <djahandarie> Hides innocently.
15:05:02 <ezyang> copumpkin: Hey. :-) Did you ever figure out what Hoopl's story with labels is supposed to be? 
15:05:14 <copumpkin> ezyang: what about them?
15:05:26 <shachaf> danglego: What languaege? Scala?
15:05:50 <ezyang> copumpkin: The code that lets you actually get a fresh label is hidden from Compiler.Hoopl, and you need Compiler.Hoopl.GHC to get it. This seems... suboptimal. 
15:06:01 <copumpkin> oh
15:06:06 <copumpkin> yeah, that does
15:06:12 <copumpkin> does the example code just use the .GHC version?
15:07:52 <ezyang> Hoopl7 appears to define its own Label type. 
15:08:26 <pedro3005> if I have an integer n, how do I construct a list with the values 1, 2, 3, ..., floor (sqrt n) ? I tried a simple range but keep hitting type errors
15:08:39 <ezyang> none of the other sampels have labels in them. 
15:08:57 <ezyang> I guess what's confusing is that Hoopl exports a Label type too... 
15:09:05 <sipa> > [ floor (sqrt x) | x <- [1..] ]
15:09:06 <lambdabot>   [1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,6,...
15:09:22 <pedro3005> no, the inverse
15:09:34 <ezyang> Wait... 
15:09:37 <sipa> pedro3005: ?
15:09:39 <blackdawn> http://codepad.org/PT4ztw16
15:09:43 <blackdawn> what is the problem with that ?
15:09:43 <ezyang> No, I 'm just dumb. There's a freshLabel function. 
15:09:51 <pedro3005> > let n = 10 in [x | x <- [1.. floor $ sqrt n]
15:09:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:10:02 <pedro3005> > let n = 10 in [x | x <- [1.. floor $ sqrt n]]
15:10:04 <lambdabot>   [1,2,3]
15:10:11 <pedro3005> huh, why doesn't it work here
15:10:19 <Cale> blackdawn: Writing sqrt n implies that n is of an appropriate type that you can take the sqrt of ti
15:10:21 <Cale> it*
15:10:29 <SirFrancisDrake> doesn't it?
15:10:34 <Cale> blackdawn: which means that n is of some floating point type
15:10:36 <dankna> the most obvious problem with it, blackdawn, is the lack of newlines
15:10:43 <dankna> not that that's why it doesn't work
15:10:43 <Cale> blackdawn: But you say that it's an Int
15:10:47 <pedro3005> blackdawn, lol i was trying to solve it
15:10:50 <dankna> but you asked an ambiguous question :)
15:10:59 <blackdawn> peddie, solve what
15:11:02 <Cale> blackdawn: You need a conversion, like  floor (sqrt (fromIntegral n))
15:11:02 <blackdawn> Cale, lol
15:11:05 <blackdawn> but
15:11:10 <blackdawn> Cale, it is receiving a int.
15:11:15 <ezyang> Ha, and I wasn't even looking in the right directory for the sample code. :o) 
15:11:17 <blackdawn> i see.
15:11:19 <blackdawn> Cale, thank you.
15:12:29 <blackdawn> Cale, worked.
15:12:39 <blackdawn> lol
15:12:47 <blackdawn> but it got in an eternal loop.
15:12:48 <blackdawn> or recursion.
15:14:01 <gwern> > 0.05 * 500
15:14:02 <lambdabot>   25.0
15:22:02 <pedro3005> Is (:) O(1)?
15:22:16 <Saizan> yes
15:22:31 <pedro3005> I see.. and what is (!!)?
15:22:34 <shachaf> pedro3005: (:) is a constructor. data [a] = [] | a : [a]
15:22:50 <shachaf> pedro3005: You can probably work out (!!) from that definition. :-)
15:22:59 <shachaf> It has to walk the list.
15:23:06 <pedro3005> O(n), yeah
15:24:35 <gwern> > 365 * 0.1
15:24:36 <lambdabot>   36.5
15:25:57 <gwern> > 37*25
15:25:58 <lambdabot>   925
15:29:47 <gwern> > 37*500
15:29:48 <lambdabot>   18500
15:30:18 <gwern> > 30 / 18500
15:30:19 <lambdabot>   1.6216216216216215e-3
15:30:30 <gwern> > (30 / 18500) * 100
15:30:30 <lambdabot>   0.16216216216216214
15:30:45 <gwern> hrm. that's not right
15:32:36 <copumpkin> #haskell: gwern's desk calculator
15:33:10 <gwern> copumpkin: my calculations must be logged for all eternity
15:33:19 <copumpkin> gwern: a noble goal
15:33:25 <copumpkin> and one I fully support
15:33:36 <gwern> some seek immortality through sex & kids, I seek immortality through lambdabot
15:34:12 <dobblego> is the statement "monads do not compose" most concisely written "(Monad n, Monad m) => n a -> m (n a) cannot be written"?
15:34:39 <kulakowski> > len "monads do not compose"
15:34:40 <lambdabot>   Not in scope: `len'
15:34:43 <ddarius> :t return :: (Monad n, Monad m) => n a -> m (n a)
15:34:45 <lambdabot> forall (n :: * -> *) a (m :: * -> *). (Monad m, Monad n) => n a -> m (n a)
15:34:51 <copumpkin> instance (Monad f, Monad g) => Monad (f . g)
15:34:52 <kulakowski> > length "monads do not compose"
15:34:53 <lambdabot>   21
15:34:59 <copumpkin> cannot be written such that it satisfies the laws
15:35:25 <dobblego> cheers
15:35:37 <copumpkin> whereas s/Monad/Functor/ or Applicative and you can
15:35:42 <dobblego> right
15:37:41 <gwern> > (30 / (74*500)) * 100
15:37:42 <lambdabot>   8.108108108108107e-2
15:40:55 <applicative> blackdawn, your definition is trying to decide whether something is prime by first deciding whether it and a few other things are prime
15:41:13 <copumpkin> applicative: that's the way I'd do it!
15:42:03 <applicative> i agree it's the really deep way, but i was thinking http://codepad.org/pnVCyQD3 was more in the spirit of http://codepad.org/PT4ztw16
15:42:09 <kulakowski> I'd just throw a log(n) sized die and guess.
15:42:27 <copumpkin> kulakowski: where can I get one of those?
15:42:30 <copumpkin> I've wanted one for a while
15:42:58 * applicative wants one for each n
15:43:49 <gwern> > 1556000000 / 21000000
15:43:49 <lambdabot>   74.0952380952381
15:59:28 <k-invariant> how do I get a String out of the IO monad
15:59:58 <jmcarthur> k-invariant: you don't
16:00:08 <k-invariant> hi jmcarthur 
16:00:14 <jmcarthur> k-invariant: instead, you transform your pure functions to operate on IO Strings
16:00:23 <jmcarthur> k-invariant: so for example:
16:00:26 <k-invariant> ccan you unban me please btw
16:00:30 <djahandarie> jmcarthur, I think this may be j-invarient.
16:00:32 <tg_> jmcarthur: beware, he was just +q'ed for trolling the hell out of #blah
16:00:32 <djahandarie> @ops
16:00:32 <lambdabot> Maybe you meant: docs oeis pl
16:00:34 <djahandarie> @where ops
16:00:35 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
16:00:39 <djahandarie> tg_, and he's banned in here.
16:00:41 <tg_> djahandarie: it is
16:00:43 <k-invariant> djahandarie: he is an op you dork
16:00:52 <k-invariant> thats why I asked him that
16:00:55 <tg_> [19:28] ->> j-invariant is ~aaaa@unaffiliated/j-invariant (bbbbb)
16:00:59 <tg_> [19:30] ->> k-invariant is ~aaaa@unaffiliated/j-invariant (bbbbb)
16:01:02 <jmcarthur> ah
16:01:04 <tg_> i guess his ban
16:01:08 <tg_> is not quite strong enough
16:01:12 <Cale> k-invariant: Do you mean, how do you run an IO String action to get its result?
16:01:16 <jmcarthur> was this just today?
16:01:22 <k-invariant> yes jmcarthur it was today
16:01:22 <djahandarie> jmcarthur, moments ago.
16:01:26 <tg_> jmcarthur: he was banned fron #haskell a while ago
16:01:29 <k-invariant> why must everyone speak for me?
16:01:30 <tg_> he was +q'ed in #haskell-blah
16:01:31 <tg_> today
16:01:40 <tg_> about 5 minutes ago
16:01:55 <djahandarie> k-invariant, join #haskell-ops if you want to discuss bans, don't ban-evade back in here.
16:02:01 <Cale> k-invariant: Inside a do-block which describes another IO action, you can write  v <- x  and if x :: IO String, then v :: String in the remainder of the do-block
16:02:13 <Cale> k-invariant: The do-block as a whole will have type IO t for some t.
16:02:26 <k-invariant> if #haskell is so friendly how come everyone in here hates me
16:02:32 <Cale> k-invariant: I don't hate you
16:02:34 <k-invariant> thanks cale
16:02:52 <tg_> the other 703 of us do, though :(
16:02:57 <jmcarthur> i don't hate anybody that gets banned
16:03:12 <tg_> I don't hate anyone on IRC, unless they are secretly genocidal dictators
16:03:21 <dankna> that's why the kick message is "your manner is not conducive to the desired atmosphere" :)
16:03:25 <jmcarthur> i only ever ban to keep the channel clean
16:03:32 <k-invariant> tg_: that's really funny tg_ because thousands of people just got killed...
16:03:44 <k-invariant> have some respect
16:03:56 <tg_> k-invariant: I don't see how what I said was in any manner disrespectful
16:04:01 <tg_> and I am aware of current events
16:04:07 <k-invariant> tg_: that just makes it all the worse
16:04:19 <kakeman> life is... somthing really weird shit
16:04:48 <tg_> I, for one, wish more people could see the videos of non-violent protestors getting assasinated in the streets by police and paramilitary forces
16:04:54 <tg_> s/could/would/
16:05:06 <jmcarthur> k-invariant: please stay on topic. discuss banning policy at #haskell-ops, and discuss genocide in... #genocide?
16:05:13 <kakeman> nobody would care
16:05:16 <k-invariant> I've written over 10 thousand lines of haskell but I don't feel I know the language at all
16:05:19 <kakeman> really
16:05:27 <tg_> kakeman: no
16:05:31 <tg_> more trolling
16:05:47 <kakeman> everybody are busy on what they are doing
16:05:51 <jmcarthur> ^^ goes for everybody, so i'm not singling k-invariant out
16:05:55 <Cale> 10 thousand lines is a lot of Haskell code.
16:06:10 <k-invariant> Cale: iv'e written interpreters for every language and all algorithms
16:06:15 <Cale> heh
16:06:18 <k-invariant> in the last 5 yeras or more
16:06:26 <tg_> jmcarthur: Good rules are just rules. Just rules are those which are applied justly.
16:06:26 <k-invariant> but I don't think I learned "programming" propely
16:06:34 <jmcarthur> k-invariant: you've written 10kloc and don't yet know what to do with IO String?
16:06:36 <Cale> So basically what you're saying is that you're lying ;)
16:06:54 <k-invariant> its hard to think with all this meat
16:06:56 <Philippa> Cale: eh, it's possible to write 10KLoC of variations on a theme and never learn how to do anything else
16:06:59 <k-invariant> im using a physical brain
16:07:08 * applicative is using the ghc
16:07:16 <jmcarthur> k-invariant: you can complain or you can learn
16:07:22 <k-invariant> okay
16:07:31 <k-invariant> jmcarthur: are you really anggry atme from last time
16:07:34 <Cale> Philippa: I was referring to the "I've written interpreters for every language and all algorithms"
16:07:40 <Philippa> k-invariant: have you written an IRC client before?
16:07:46 <k-invariant> Cale: lisp, C, perl java prolog haskell etc...
16:07:53 <k-invariant> Philippa: no but I wrote a bot
16:07:53 <sproingie> that reminds me of "I am aware of all internet traditions"
16:07:58 <Philippa> Cale: *shrug* - somewhat hyperbolised, but hey
16:08:06 <Cale> k-invariant: Do you mean you've written interpreters for all of those languages in Haskell?
16:08:09 <Philippa> k-invariant: write a multi-server client with a UI. It's good for the soul
16:08:11 <k-invariant> Cale:  yes
16:08:14 <Cale> k-invariant: Why are they not on Hackage?
16:08:15 <Cale> :)
16:08:24 <k-invariant> Cale: hackage requies my real name
16:08:30 <jmcarthur> k-invariant: are you the guy that i thought was complaining too much a fairly long time ago?
16:08:39 <k-invariant> I dont use my real name except for govt. issuse
16:08:41 <jmcarthur> k-invariant: i wasn't mad at you then, nor now
16:08:45 <Cale> Also, how many lines does your parser for perl take? :)
16:08:47 <k-invariant> jmcarthur: okay cool
16:08:51 * BMeph wants an Io interpreter writtenin Haskell...oh, he's writing one! Never mind.
16:08:56 <k-invariant> oh ell not perl but I hacked on Perl 6 
16:09:01 <Philippa> Cale: 1. It returns the string as its own AST :p
16:09:15 <k-invariant> PUGS
16:09:22 <jmcarthur> BMeph: heh. i thought about doing that once, but decided i wouldn't ever use it anyway, and i'm not sure how education it would be anyway
16:09:28 <jmcarthur> *educational
16:09:39 <k-invariant> brainfuck
16:09:41 <k-invariant> lambda calculus
16:10:39 <jmcarthur> if i'm ever mad at somebody and think they deserve a kick/ban/+q, i try to get another op to do it. conflict of interest
16:10:47 <k-invariant> your wise
16:11:00 <k-invariant> unlik some people who I wont mention..
16:11:01 <BMeph> jmcarthur: Well, just from reading it, I've figured out that Martin Sandin was really bad at OCaml in 2002. I hope that 1) He got better at it; 2) he's better at Java. ;)
16:11:22 <jmcarthur> ha
16:12:51 <HugoDaniel> hi
16:13:21 <ezyang> Hmm. I can't decide whether or not I should add legitimate procedures to my Nop programming language. 
16:13:48 <Augusto> boa noite
16:13:52 <jmcarthur> ezyang: Nop?
16:14:01 <geheimdienst> no-op?
16:14:03 <ezyang> It's only non-control instruction is 'nop'. 
16:14:03 <jmcarthur> is there any information about this language anywhere?
16:14:10 <jmcarthur> ha
16:14:11 <ezyang> No. :-) 
16:14:22 <jmcarthur> so i'm guessing it's imperative then
16:14:25 <ezyang> Yeah. 
16:14:29 <djahandarie> ezyang, I have an answer for you: nop.
16:14:40 <ezyang> OK. :-) 
16:14:47 <jmcarthur> so you define data with control structures?
16:14:55 <Augusto> goodnight. someone speak Portuguese?
16:15:01 <jmcarthur> like an imperative church encoding or something?
16:15:05 <jmcarthur> :P
16:15:19 <ezyang> No, it's not actually meant to do anything useful; I'm just trying to construct a simpler example of Hoopl usage. 
16:15:25 <k-invariant> cale whats your goal in life
16:15:25 <jmcarthur> ah okay
16:15:31 <jmcarthur> oh yeah i'm interested in hoopl
16:15:34 <jmcarthur> is this for a blog post?
16:15:36 <ezyang> Although an imperative church encoding would be kind of funny. 
16:15:37 <ezyang> Yah. 
16:15:43 <jmcarthur> sweet. i look forward to it
16:16:06 <jmcarthur> i have no idea what an imperative equivalent to church encoding would look like
16:16:12 <ezyang> The example code in Hoopl is actually pretty good, but it's a bit long, in order to be comprehensive. So I'm trying to figure out how much I can chuck out without making it work. 
16:16:23 <jmcarthur> i guess a procedure taking two arguments
16:16:27 <jmcarthur> hmm
16:16:37 <Cale> k-invariant: Uh, to have fun learning interesting stuff? Something like that, I guess :)
16:16:43 <jmcarthur> no, a function pointer... but then it needs the data to pass to it...
16:16:51 <jmcarthur> (i'm thinking about tuples)
16:16:59 <ezyang> jmcarthur: Btw, re our conversation a few days back, I actually went to another seminar where the person was talking about interactive computer algebra algorithms. Looks like interactivity is something people are thinking about these days :-) 
16:16:59 <k-invariant> I don't think anyone on this planet has any idea what the fuck is going on
16:17:03 <blackdawn> hey
16:17:05 <ddarius> Cale: Would you be upset if you had fun doing other things?
16:17:06 <blackdawn> http://codepad.org/vcx38fWY
16:17:13 <blackdawn> i can't understand why that fails
16:17:16 <jmcarthur> ezyang: yeah! i was inspired by theorem provers, actually
16:17:20 <Cale> ddarius: Not particularly upset, no.
16:18:04 <jmcarthur> except theorem provers are constructive. this would be more... transformational?
16:18:08 <Augusto> can someone help me? I'ma student and am learning the language Haskell. My teacher asked to create a function that shows the arithmetic average between three or more numbers. The problem is that I have not figured how to do this.
16:18:20 <Cale> ddarius: But I tend to have the most fun when there's something of an intellectual challenge to what I'm doing.
16:18:21 <ezyang> IMO, you'd want an integrated theorem prover to prove the correctness of your transformations. 
16:18:27 <jmcarthur> yes
16:18:32 <ezyang> Augusto: Do you know what the type of your function is. 
16:19:05 <Augusto> Int?
16:19:51 <Pseudonym> Augusto: Int isn't the type of a function.
16:19:51 <ezyang> Ok, good first step. That's the return type. 
16:19:54 <ezyang> What's the input type? 
16:20:17 <Augusto> He wants to use integers.
16:20:29 <Bynbo7> Int or Integer?
16:20:43 <monochrom> arithmetic average is unlikely an integer. what is the arithmetic average of 1,1,1?
16:20:46 <ezyang> Augusto: Ok. How would you represent "integers" (emphasis on 's') 
16:20:54 <Pseudonym> monochrom: 1
16:20:55 <monochrom> oops, 1,2,2
16:21:12 <Augusto> My problem is I still do not understand how to create variables and functions.
16:22:06 <Augusto> I'm "losing virginity" in this programming language.
16:22:11 <Bynbo7> heh
16:22:30 <ezyang> Oh, this would be hilarious if the problems I solved reduced to thsoe of combinatorial species. 
16:23:27 <djahandarie> Augusto, here is a function     f :: Int -> Int; f x = x + 1;
16:23:59 <djahandarie> Can you tell what it does?
16:26:45 <k-invariant> whta would the typical haskell programmer be?
16:27:09 <Pseudonym> k-invariant: The typical Haskell programmer would be here.
16:27:51 <Augusto> djahandarie - Create a variable and assign the value?
16:28:43 <djahandarie> Augusto, f is the function here. It 'takes in' an Int and 'gives back' an Int.
16:28:50 <djahandarie> That is what the stuff before the ; says.
16:28:52 <Bynbo7> Augusto: no, it is a funct6ion which takes an int (called x) and adds 1 to it, and returns that
16:29:24 <djahandarie> After the ; says "I accept one thing 'x', and I turn that into an 'x + 1'"
16:29:25 <monochrom> function means "like mathematical function" not "like C function"
16:29:36 <Bynbo7> Augusto: haskell is not like languages you may have used before, you don't change tgew value of variables, thinngs are not mutable
16:29:45 <k-invariant> ANyone know any COOL WEBISETS?
16:29:46 <ddarius> monochrom: A subset of ordered pairs?
16:29:54 <k-invariant> monad.reader.com and reddit/r/haskell
16:30:15 <ddarius> Bynbo7: Need to tone back the sake a bit.
16:30:37 <blackdawn> what function could i use to find the max element of a list
16:30:43 <blackdawn> like [1, 2, 1, 3] return s 3
16:30:54 <Bynbo7> new keyboard, not used to the key spacing (and my typing's never been that crash hot)
16:30:56 <k-invariant> > max [1,2,3,1]
16:30:56 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
16:30:57 <lambdabot>    arising from a use ...
16:30:58 <ddarius> blackdawn: What would it's type be?
16:31:05 <k-invariant> > maximum [1,2,3,1]
16:31:06 <lambdabot>   3
16:31:07 <blackdawn> ddarius, ints
16:31:12 <monochrom> "a subset of ordered pairs" works more beautifully than I thought
16:31:21 <k-invariant> > maximum [1..]
16:31:25 <Bynbo7> blackdawn: what is max short for?
16:31:31 <ddarius> blackdawn: ints isn't a function type.  It's not even a type.
16:31:39 <lambdabot>   thread killed
16:32:04 <blackdawn> ddarius, k
16:32:10 <blackdawn> Bynbo7, hm
16:32:11 <blackdawn> max
16:32:13 <blackdawn> i tried that.
16:32:27 <Bynbo7> no, max is short for maximum, try that ;)
16:32:34 <Bynbo7> > maximum [1,2,3,1]
16:32:39 <lambdabot>   mueval-core: Time limit exceeded
16:32:43 <Bynbo7> o.O
16:32:43 <blackdawn> k
16:32:46 <Bynbo7> > maximum [1,2,3,1]
16:32:48 <lambdabot>   3
16:32:57 <Bynbo7> there we go, wtf lambdabot o.O
16:33:08 <k-invariant> I DID THAT ALREADY
16:33:11 <djahandarie> I think it was having trouble with something else.
16:33:31 <ion> Perhaps there’s load on the server on which λbot’s running.
16:33:40 * djahandarie nods
16:33:41 <Augusto> if it returns me the sum of the numbers assigned in the function
16:33:54 * djahandarie also wonders why ion went through the trouble of using unicode for that
16:33:56 <Augusto> if it returns me the sum of the numbers assigned in the function
16:34:03 <lambdabot> I feel tired.
16:34:19 * djahandarie eyes copumpkin
16:34:23 <copumpkin> ?
16:34:24 <Bynbo7> ah, cale added the skynet plugin, i forgot about that
16:34:26 <copumpkin> not me this time
16:34:33 <djahandarie> :(
16:34:35 <Pseudonym> What do you mean "this time"?
16:34:44 * copumpkin whistles innocently
16:34:59 <Pseudonym> BTW, there's a little-known way to tell who it was if you're quick.
16:35:04 <ion> djahandarie: Well, there’s no real difference in the amount of keystrokes.
16:35:10 <copumpkin> Pseudonym: what's that?
16:35:17 <Pseudonym> @seen copumpkin
16:35:18 <lambdabot> Unknown command, try @list
16:35:18 <djahandarie> ion, do you have a compose key or latex input setup? :P
16:35:18 <preflex>  copumpkin was last seen on #haskell 7 seconds ago, saying: Pseudonym: what's that?
16:35:27 <ddarius> Pseudonym: Foiled!
16:35:29 <Pseudonym> Oh, lambdabot isn't doing it.
16:35:32 <copumpkin> Pseudonym: how would that work?
16:35:41 <copumpkin> Pseudonym: I'm not called copumpkin when I'm controlling it
16:35:46 <Pseudonym> Ah.
16:35:47 <copumpkin> I don't actually have admin access :P
16:35:52 <copumpkin> preflex: seen TheHunter
16:35:53 <preflex>  TheHunter was last seen on #haskell 77 days, 6 hours, 24 minutes and 25 seconds ago, saying: I just hijacked this nick better
16:36:15 <Pseudonym> Controlling lambdabot is registered by the @seen command.
16:36:24 <copumpkin> except the @seen command was killed
16:36:26 <ion> djahandarie: There’s no compose combination for lambda, and for most of the letters i use a LaTeX input setup, but for λ i happen to remember the Unicode point (U+3BB) which makes it fast to type with ctrl-shift-U.
16:36:28 <Pseudonym> Right.
16:36:31 <Pseudonym> So forget I spoke.
16:36:41 <djahandarie> Heh
16:36:57 <Pseudonym> Before it was killed, you could tell who it was by getting in a @seen on all of the likely suspects before they spoke in the channel.
16:36:58 * monochrom thinks of cotrolling lambdabot
16:38:20 <lambdabot> That would either mean me controlling you, or it's a variation on a rickroll where you watch a cotangent video.
16:38:50 <gwern> > (0.1+0) / 2
16:38:51 <lambdabot>   5.0e-2
16:39:02 <monochrom> nice
16:42:14 <gwern> > 25 / 0.005 
16:42:14 <lambdabot>   5000.0
16:42:37 <k-invariant> if only Ayn Rand could see us today...
16:43:01 <Pseudonym> She still wouldn't have anything interesting to say.
16:44:16 <gwern> she'd like the new amphetamines & stimulants, and no-fault divorces
16:44:53 <k-invariant> hi conal
16:45:08 <conal> k-invariant: hi
16:46:41 <k-invariant> Haskell is the closet humanity has come to Leibniz dream of a language of thought
16:47:35 <conal> k-invariant: maybe with dependent types. and when we do not use IO.
16:47:54 <k-invariant> yes thats true
16:48:22 <conal> since IO's role is to hold what we don't understand.
16:50:00 <ddarius> women :: IO Issues
16:50:27 <Bynbo7> there's a 99 problems joke to be made there
16:51:05 <djahandarie> I've got 99 problems but IO encomppasses them all so I don't need to worry about it?
16:51:20 <k-invariant> Godel destroyed Hilberst program the same way that Turing destroyed Leibniz. We are still picking up the peices
16:51:47 <ion> ddarius: :-D
16:51:48 <monochrom> are you done off-topicking?
16:51:50 <k-invariant> How can dependent types coexist with uncertainly and aprpoxmiation
16:52:24 <Bynbo7> glad i wasn't the only one who noticed
16:56:14 <k-invariant> Bertrand russel showed us that "the table" doesn't really exist as we see it, And category theory/haskell data types just cover the issue of what
16:56:20 <k-invariant> is really the "initial" object
16:56:35 <astroboy> I have a strange problem, "make" has lost tab-completion |:
16:56:51 --- mode: ChanServ set +o monochrom
16:57:13 --- mode: monochrom set -b j-invariant!*@*
16:57:32 --- mode: monochrom set +b *!*@unaffiliated/j-invariant
16:57:36 <astroboy> ops sorry wrong chan
16:57:41 --- mode: monochrom set -o monochrom
16:58:06 <JuanDaugherty> aprpoxmiation - say that 3X
16:58:51 <JuanDaugherty> click your heels 3X
16:59:10 <JuanDaugherty> and say "I do believe in tables, I do believe in tables ..."
16:59:21 <monochrom> are you done too?
16:59:48 * JuanDaugherty sheepishly
16:59:50 <JuanDaugherty> y
17:00:12 <Cale> k-invariant: "the table"?
17:00:48 <robryk> astroboy: try a new shell
17:02:25 <conal> k-invariant: i was just about to ask the same. what's the table?
17:04:29 <astroboy> robryk: that message was meant to be in #archlinux... irssi windows
17:06:30 <robryk> oh, ok
17:15:00 <levifikri> Hi. I want to store data in a collection. The collection would be updated regularly. What is the most suitable Abstract Data Type for this?
17:16:12 <levifikri> and I want to append the list frequently
17:16:41 <Bynbo7> levifikri: we'd need to know more than that, what sort of data? how will you access it? do you need a key-value store?
17:17:44 <levifikri> Just a string, doesn't need to be ordered. The only requirement is that: list concatenation operation would be done frequently
17:17:54 <btutt> Data.Sequence maybe?
17:18:08 <Bynbo7> yeah, i was going to suggest that too
17:18:48 <Cale> Or maybe a function from lists to lists
17:18:56 <shachaf> What do you mean, doesn't need to be ordered?
17:19:06 <shachaf> Cale: As in DList?
17:19:09 <Cale> mhm
17:19:26 <Cale> So the functions add elements to the beginning of a list
17:19:36 <Bynbo7> levifikri: could you give us more information about what you actually want to do? the more clear you are, the better answers you'll get :)
17:19:58 <Cale> id is the empty container, (x:) is a singleton, and (.) is concatenation (in O(1) time)
17:20:46 <levifikri> ok. I would like to list all files on a particular directory recursively. And I would like to store the result in a list like collection.
17:21:06 <levifikri> so, I would expect to do many concatenation operations frequently
17:21:58 <shachaf> Why "a list like collection"?
17:22:04 <levifikri> btutt how does it differ from list? Haskell Wiki only state " Apart from being finite and having strict operations, sequences also differ from lists in supporting a wider variety of operations efficiently."
17:22:42 <levifikri> shachaf any better recommendation? I though list is the best for this, isn't it?
17:23:22 <Cale> levifikri: You can concatenate two values of Data.Sequence type or split at the nth element in logarithmic time.
17:23:44 <Cale> and of course, indexing is similarly logarithmic
17:23:45 <Bynbo7> levifikri: list is good ig you can prepend elements, and pretty terrible if you're appending elements
17:23:59 <kmc> Cale, but O(log n) is soooo much slower than O(1)!  [/troll]
17:24:00 <Bynbo7> if*
17:24:06 <shachaf> If you already know what data structure is best, why are you asking? :-)
17:24:26 <kmc> btw ♥♥♥ Data.Sequence
17:24:39 <kmc> just implemented a diff algorithm that would have been a performance disaster with lists and a code disaster with arrays
17:24:46 <kmc> Seq was perfect
17:25:04 <levifikri> shachaf I came from Java background. So I didn't really sure what ADT is provided best for this
17:25:42 <levifikri> So, if we have Seq, why we still have Data.List? What are the advantages of Data.List to Data.Seq?
17:25:44 <djahandarie> kmc, DList isn't bad.
17:25:58 <kmc> levifikri, lists are much simpler in construction
17:26:00 <shachaf> djahandarie: If all you need is appends, sure.
17:26:04 <kmc> that is, any beginner can define lists themselves
17:26:10 <kmc> data List a = Nil | Cons a (List a)
17:26:18 <kmc> Seq is based on a much more complicated / clever 2-3 finger tree zipper thingy
17:26:20 <btutt> levifikri: Data.Sequence allows for more flexible munging in the middle. dlist seems more appropriate if you want effecient appends but otherwise want a more list like perf.
17:26:20 <Bynbo7> levifikri: lists are the bread and butter of datastructures in haskell. they provide many useful operations
17:26:45 <kmc> levifikri, because of laziness, lists are almost more like control-flow structures than data structures
17:27:03 <Bynbo7> levifikri: list and seq are for different things really (lists are basically haskell's forloop for example)
17:27:18 <kmc> levifikri, that is, applying an incremental list consumer to a lazy list producer establishes a coroutine between the two
17:27:22 <levifikri> Oh, I got good article comparing List and Seq: http://www.haskell.org/haskellwiki/Performance
17:27:29 <kmc> and sometimes all the intermediate allocation will be optimized out
17:27:35 <aristid> where is Test.QuickCheck.Batch gone?
17:28:25 <co_dh> greeting ,guys. I encounter a problem when reading the paper : monad transformer and modular interpreter.  instance Monad m => Monad (ErrorT m) where is not accepted by Haskell. 
17:28:46 <kmc> that sounds fine
17:28:50 <kmc> even in Haskell 98
17:28:56 <Saizan> co_dh: which error do you get?
17:28:58 <co_dh> it tells me ErrorT should have 2 arguments. while data Error a = Ok a | Error String type ErrorT m a = m (Error a)
17:29:07 <co_dh> wait: 
17:29:11 <BMeph> Doesn't (ErrorT m) take two more type arguments? :)
17:29:14 <co_dh> data Error a = Ok a | Error String
17:29:21 <co_dh> type ErrorT m a = m (Error a)
17:29:23 <kmc> ErrorT should have two arguments when used as a type, but instances of Monad are supposed to be "missing" their last parameter
17:29:31 <kmc> it's "Monad Maybe" and not "Monad (Maybe t)"
17:29:52 <co_dh> Type synonym `ErrorT' should have 2 arguments, but has been given 1 In the instance declaration for `Monad (ErrorT m)'
17:30:06 <Saizan> co_dh: oh, you've to use a newtype
17:30:11 <Saizan> co_dh: not a type synonym
17:30:48 <Saizan> i.e. newtype ErrorT m a = ErrorT (m (Error a))
17:31:16 <levifikri> Ok, I would go for Seq them. And now, I would want to parallelize my code. Meaning that, the Seq would be appended by more than 1 threads. I'm thinking of using MVar Seq and append the list in critical section (mutually exclusively). Do you think it is really the best choice?
17:31:29 <co_dh> thanks everybody :)
17:31:57 <kmc> levifikri, sounds ok but maybe you should consider pure parallelism before you go for explicit concurrency
17:32:14 <kmc> i.e. par and the other stuff in http://hackage.haskell.org/package/parallel
17:32:34 <robryk> kmc: he seems to want to parralelise IO operations
17:32:37 <kmc> oh
17:32:53 <kmc> levifikri, i assume the threads do some computation before appending?
17:33:00 <kmc> i.e. they won't spend all their time with the mvar held?
17:33:08 <kmc> you might have to explicitly force that to happen outside the locking
17:33:17 <levifikri> kmc most of them are IO operations
17:33:33 <kmc> you could also make them write into a Chan and have a single thread do the appending
17:33:46 <kmc> why do you need to collect the results as a single Seq
17:33:54 <kmc> as opposed to, say, a list of "chunks" produced by each thread
17:34:17 <robryk> by the way: how can one defend against exhausting memory by unamtched throughput chan other than using boundedchan?
17:34:49 <kmc> kind of a weird question, "how can i make a bounded chan without using BoundedChan"
17:34:55 <ezyang> robryk: Control the sending rate? 
17:35:20 <robryk> how?
17:35:35 <btutt> http://ghcmutterings.wordpress.com/2010/08/20/parallel-programming-in-haskell-with-explicit-futures/ might help too
17:35:37 <robryk> i seem to need to know how long a queue i have in a chan
17:35:52 <ezyang> I mean, there's lots of ways to do it. 
17:35:54 <Cale> levifikri: It's probably fine. In a lot of tests, using immutable data structures inside MVars is ironically faster than using concurrent data structures :)
17:36:21 <kmc> how ironic ;)
17:36:56 <kmc> it's actually a really cool style
17:37:05 <Bynbo7> implementing a bounded chan should be pretty trivial: data BChan a = BChan (Chan a) (MVar Word)
17:37:16 <kmc> persistent structures + lock-free zero-copy snapshotting + single-instruction optimistic update
17:37:21 <Bynbo7> oh uh, needs a Word in there tyoo
17:37:23 <Bynbo7> too*
17:37:37 <kmc> it's reminiscent of read-copy update, which is all the rage in Linux now
17:37:42 <c_wraith> MVars are fast, and designed to minimize contention.  You need a huge workload (and a lot of cores) for a concurrent data structure to beat a pure data structure inside an MVar
17:38:22 <Bynbo7> c_wraith: pure structures in IORefs updated using atomicModifyIORef is even faster
17:38:29 <c_wraith> Bynbo7: not in my experience
17:38:50 <kmc> some people might not want to admit it, but the Linux kernel is full of functional programming, object-oriented programming, aspect-oriented, you name it
17:38:51 <kmc> all in C
17:39:07 <kmc> they kind of want to use every trick possible
17:39:09 <Bynbo7> yeah? Simon Marlow seemed to think it was considerably faster than using MVars
17:39:29 <ezyang> RCU is awesome. :-) 
17:39:35 <kmc> hi ezyang
17:39:39 <c_wraith> Bynbo7: in my experience, IORefs updated with atomicModifyIORef fall over painfully under high update contention.  MVars just survive
17:39:40 <ezyang> Hello! 
17:40:00 <kmc> how is aMIOR implemented?
17:40:09 <Bynbo7> ah fair enough, i haven't axtually had an opportunity to test it myself
17:40:25 <robryk> does atomicModify lock or does it do something like rcu?
17:40:33 <c_wraith> kmc: single-instruction exchange
17:40:44 <levifikri> c_wraith is there any concurrent data structure in Haskell? I thought Haskell is pure language?
17:40:52 <btutt> i.e. lock xchg (InterlockCompareExchange on Windows) I'm guessing
17:40:58 <kmc> levifikri, there are plenty of mutable data structures in Haskell
17:41:03 <kmc> and plenty of support for imperative programming
17:41:13 <levifikri> kmc could you list some of them?
17:41:13 <robryk> so it can't be slower multi-threaded than one-threaded
17:41:13 <kmc> levifikri, it's pure in the sense that evaluation does not cause execution.  we have other ways of describing execution
17:41:21 <Bynbo7> robryk: i think it uses an atomic compare and swap. all that needs to be changed is swapping a pointer
17:41:22 <kmc> levifikri, read the last few chapters of Real World Haskel
17:41:28 <levifikri> kmc ok
17:41:34 <kmc> STM is really cool
17:42:13 <levifikri> Cale "using immutable data structures inside MVars is ironically faster than using concurrent data structures". Why so?
17:42:32 <kmc> levifikri, there are single-value reference cells as well as arrays, which usually come in IO, ST, and STM flavors, and also boxed and unboxed
17:42:42 <kmc> IO being the basic way to build imperative programs in Haskell
17:42:55 <kmc> ST is like IO except you can assert that a "closed universe" of mutation behaves like a pure function
17:42:58 <kmc> and the type system will check it for you
17:43:17 <kmc> and then you get to use it as a pure function, but at the same level of performance the IO code would have
17:43:24 <kmc> STM is the optimistic lock-free transactional concurrency stuff
17:44:04 <kmc> so yeah, Haskell is a multiparadigm language with pretty good support for imperative and concurrent programming
17:44:33 <kmc> you can create variables / channels, and then spawn some threads that close over them
17:44:39 <kmc> with much less syntactic overhead than most languages
17:45:43 <levifikri> ok, seems I have some to read. Thx guys. Will come back after finish reading all those stuff :).
17:47:12 <gwern> offhand, has anyone here bought any girl scout cookiees this year? how much did they charge you?
17:50:14 <btutt> Are MVars + functional data structures faster due to lazy thunk evaluation reducing the time to mutate the MVar vs. more complex concurrent data structures?
17:50:20 <Cale> levifikri: Well, it comes down to the constant factors involved in all the bookkeeping for the various concurrency abstractions. Simpler and mostly pure turns out to be better in a lot of cases, even if different parts of the structure can't be modified concurrently.
17:50:48 <Cale> Laziness *may* have something to do with it, that's an interesting point.
17:51:36 <Cale> In general, the ability to put unevaluated expressions into an MVar to be evaluated on read is a useful technique (but also something that is sometimes undesirable)
17:52:19 <djahandarie> Neat, this Japanese company http://www.itpl.co.jp/tech/formal/index.html used Coq to verify their OCaml program's validity. And the program is pretty run-of-the-mill standard application stuff, nothing strange.
17:52:45 <monochrom> I put a whole Data.Map into an MVar. very little work on my part to gain the holy grail "consistent snapshot"
17:54:31 <btutt> I suppose also only needing to stick the root pointer to the data structure (lazy or otherwise) inside the MVar also helps a bunch vs typical (as a complex example) lock free linked lists or lock free hash implementations
17:55:37 <monochrom> wait-free lock-free data structures require PhD
17:55:39 <levifikri> I wonder, how does Haskell manage the garbage resulted from immutable data structure? Let's say we have a recursive quick sort function. During each intermediate step (recurrence), we would have a temporary list storing partially ordered data. Haskell makes a copy of the array for each recurrence, correct? Doesn't it mean that a lot of memory needs to be allocated?
17:55:57 <BMeph> gwern: $4
17:56:09 <gwern> BMeph: where was that?
17:56:17 <monochrom> someone should write a blog "it takes a PhD to not use haskell" :)
17:56:51 <geheimdienst> monochrom: unfortunately, to use it takes a phd too
17:56:52 <kmc> levifikri, the Haskell spec doesn't say much about that
17:56:57 <kmc> but GHC has a pretty sophisticated garbage collector
17:56:59 <djahandarie> My PL teacher said "you need a PhD in theorem proving to use dependently-typed languages" to me. :(
17:57:08 <kmc> that expects to do lots of short-lived allocation
17:57:13 <levifikri> assume the algorithm is as simple as below:
17:57:15 <levifikri> quickSort :: Ord a => [a] -> [a]
17:57:15 <levifikri> quickSort (x:xs) = losort ++ x : hisort
17:57:16 <levifikri>   where
17:57:16 <levifikri>     losort = quickSort [y | y <- xs, y < x]
17:57:16 <levifikri>     hisort = quickSort [y | y <- xs, y >= x]
17:57:16 <levifikri> quickSort [] = []
17:57:25 <kmc> levifikri, for "allocation" think alloca(), not malloc()
17:57:29 <djahandarie> levifikri, use http://hpaste.org in the future
17:57:34 <kmc> just increments a pointer basically
17:57:35 <pumpkin> djahandarie: pff
17:57:44 <btutt> geheimdienst: no kidding. lock free data structures have lots of non-obvious tradeoffs vs locking data structures.
17:57:53 <kmc> if you have a garbage collector you don't have to walk a free list etc.
17:58:03 <levifikri> djahandarie thx for pointing out
17:58:03 <kmc> you just use the heap sequentially and then collect
17:58:14 <Cale> levifikri: You do need to remember that evaluation is lazy, and hence outermost-first though.
17:58:35 <BMeph> gwern 7-Eleven. :)
17:58:44 <djahandarie> pumpkin, moments later he said that if I'm looking to be a grad student that he would be glad :P
17:58:52 <pumpkin> djahandarie: that's cool
17:59:01 <Cale> levifikri: Well, the Haskell spec doesn't actually say "lazy" and what GHC does isn't *exactly* just lazy evaluation, but close enough :)
17:59:07 <gwern> BMeph: har har, but I meant, what state? I paid 4$ too but that was in san francisco and I was wondering if we/that troop were overcharged for being in a big city
17:59:12 <wavewave> does anyone know how to setup hoogle for my local cabal package?
17:59:28 <Cale> levifikri: The list [y | y <- xs, y < x] won't likely all ever be in memory at once
17:59:37 <BMeph> gwern: Sorry, I can't help, then; I'm in San Diego. :)
17:59:47 <djahandarie> pumpkin, I don't know if I want to be one though. :P Undergraduate is painful enough for me
17:59:47 <Cale> levifikri: its elements will be constructed as they're consumed
17:59:52 <wavewave> I just want to search functions in my cabal repository.
18:00:29 <gwern> BMeph: too darn close, but I guess it's another data point
18:00:41 <ray> so if you need a phd to use dependently typed languages i've had a phd all along without realizing it?
18:00:50 <ray> this is like a motivational fable here
18:00:50 <btutt> I was bored senseless as an undergrad in CS. *snore*
18:00:53 <ray> the phd was inside me all along
18:01:04 * gwern is writing an essay arguing that the girl scouts leadership is corrupt, but with a twist - I'm going to write the essay and only *then* see what the crucial IRS financial filings actually say
18:01:05 <BMeph> gwern: Exactly.
18:01:13 <pumpkin> djahandarie: it's a very different experience, PhD at least
18:01:23 <ray> CS is probably the problem, i've never been *bored* by undergrad math that i already knew
18:01:26 <kmc> Cale, in what way is what GHC does not lazy eval?
18:01:27 <pumpkin> masters is a bit like an extension of undergrad
18:01:41 <Cale> kmc: There's a strictness analyser
18:01:43 <djahandarie> pumpkin, wait, do you have a PhD?
18:02:03 * djahandarie thought pumpkin just had an bachelor's
18:02:06 <gwern> Cale: it doesn't hold on to every evaluated thunk, too, right? doesn't it have to never re-evaluate stuff to be fully lazy?
18:02:06 <Cale> kmc: The evaluation order isn't *cough* strictly outermost first
18:02:13 <pumpkin> djahandarie: well, I did a couple of years of phd work :P
18:02:21 * hackagebot sequential-index 0.1 - Sequential index numbers between 0.0 and 1.0 that allow arbitrarily inserting new numbers in between (for special containers).  http://hackage.haskell.org/package/sequential-index-0.1 (AristidBreitkreuz)
18:02:22 <Cale> gwern: It never re-evaluates stuff.
18:02:26 <djahandarie> pumpkin, ah. :P
18:02:47 <gwern> Cale: huh? if that's so, what are all these memoization packages doing?
18:03:12 <gwern> (saying, 'good job GHC for not throwing away this evaluated expression because if you had I might actually need to do something'?)
18:03:18 <btutt> ray: That makes sense. I started having problems when trying to visualize fun things like surface normals to >=3d functions :)
18:03:27 <djahandarie> pumpkin, I don't think I would end up with anything interesting as a researcher
18:03:38 <Cale> lazy evaluation only specifies that a parameter to a function which occurs multiple times in the body of the function is evaluated once, and the result of that evaluation is shared among the copies
18:03:47 <BMeph> gwern: My wife says they're the same price across the country, and have been for years. :)
18:03:49 <ray> you just visualize in 2D or 3D if you must and then generalize
18:03:52 <Cale> It doesn't say "memoise all functions"
18:04:09 <gwern> BMeph: years, perhaps, but not decades. I remember selling them in the '90s for 2 or 2.50 a box
18:04:31 <monochrom> in "3*4 + 3*4" the first "3*4" is evaluated at most once and the second "3*4" is evaluated at most once. but there are two "3*4"s, not just one.
18:04:32 <Cale> Memoising functions isn't the same as not re-evaluating expressions which have already been reduced.
18:04:43 <btutt> lame state university clac/diffeq grad tas probably didn't help either.
18:04:58 <monochrom> in "let x=3*4 in x+x" there is only one "3*4"
18:05:30 <monochrom> and time for shameless plug again: http://www.vex.net/~trebla/haskell/lazy.xhtml
18:05:56 <BMeph> gwern: ...and I remember buying gas  in the 90's for $1 a gallon. So prices shift. :)
18:06:14 <ray> what a shameful plug
18:06:36 <robryk> gwern: memoization helps when you call function with the same parameter from different places
18:06:40 <gwern> BMeph: yeah but I don't think flour and chocolate prices have more than doubled since then
18:07:02 <btutt> you'd be surprised. food prices have been going up quickly lately
18:07:17 <ray> i don't consider myself to know something until i can explain it to my sister
18:07:27 <ray> she doesn't have to understand but i have to be able to put up a reasonable explanation
18:08:02 <Bynbo7> i did that yesterday with my girlfriend, explaining the difference between concurrency and parallelism, and also what an OS does
18:08:33 <ray> for example, i was never able to do that with vector cross products until i learned quaternion products
18:08:44 <ray> therefore i didn't know it
18:09:57 <BMeph> ray: Great! Now, do it again, with Clifford Algebras! ;)
18:11:30 <ray> that is certainly one way to go
18:13:22 <ezyang> Hmmmm... it might be a little difficult to do dataflow optimization if there is no data.... 
18:16:23 * hackagebot websockets 0.3.0.0 - Create WebSocket servers  http://hackage.haskell.org/package/websockets-0.3.0.0 (SinisaBidin)
18:24:58 <ezyang> I wonder what the minimal amount of state I can add to admit some nontrivial data flow optimization. 
18:25:09 <ezyang> How about a single variable's worth of state? Boolean? Hmmm.... 
18:25:39 <Pseudonym> Which data flow optimisation did you have in mind?
18:25:47 <Pseudonym> Conditional constant propagation might be a good candidate.
18:26:34 <ezyang> I mean, it doesn't even have to be a real world useful optimisation; I just need it to be just complex enough to showcase some of Hoopls features, like fixpoint calculation. 
18:27:10 <kmc> hoopleheads
18:29:04 <ezyang> Oooh! I should use Hoopl to simulate feedback systems. 
18:45:10 <co_dh> Hi, there, is there a way to filter out message like somebody has quit, joined #haskell? 
18:45:27 <djahandarie> co_dh, what's your client?
18:45:34 <co_dh> a web client. 
18:45:44 <co_dh> http://webchat.freenode.net/?channels=#haskell
18:45:48 <kmc> deep packet inspection iptables rule
18:45:49 <djahandarie> Ah. It may not be possible with that.
18:45:59 <djahandarie> :P
18:46:19 <djahandarie> co_dh, actually, click the options on the top left
18:46:20 <co_dh> well, the irc server should have a config for that .
18:46:25 <djahandarie> "Hide JOINS/PARTS/QUITS"
18:46:55 <kmc> what's a good name for an element of a diff?
18:47:00 <co_dh> djahandarie: thanks !!
18:47:02 <kmc> that is, a single line which is either +, -, or context
18:47:08 <kmc> except for a generalized idea of "line"
18:47:15 <co_dh> diff block?
18:47:17 <btutt> segment, hunk, token
18:47:25 <kulakowski> diffy
18:47:27 <Chaze> @src swap
18:47:28 <lambdabot> Source not found. Sorry.
18:47:35 <kmc> i think of a hunk as being a list of contiguous lines of the same type
18:47:36 <kmc> but, ok
18:47:45 <djahandarie> Are you writing hdiff kmc?
18:47:55 <kmc> i am implementing patience diff in haskell
18:48:01 <kmc> actually it already works
18:48:12 <btutt> part of a hunk range would be a token then
18:48:18 <kmc> but i want to make sure the API and naming are sane before i release it (hopefully tonight, if i don't get drunk or something)
18:48:21 <btutt> it just happens to be a line token
18:48:44 <kmc> djahandarie, what is / would be hdiff?
18:49:13 <co_dh> kmc : can you diff at the word level ? like meld. I mean , hilight the difference between words in 2 lines.
18:49:23 <djahandarie> diff written in Haskell. Because Haskell makes everything better.
18:49:29 <kmc> :D
18:49:35 <kmc> does darcs not already have that?
18:49:44 <djahandarie> But perhaps more usefully, a parser/dsl for diffs.
18:49:47 <djahandarie> Yeah, probably.
18:49:51 <kmc> i'm diffing things that aren't text, which is why i'm reimplementing
18:50:00 <co_dh> kmc: I don't use darcs. 
18:50:09 <kmc> there's an implementation of the classic O(ND) diff algo on hackage, but it's really slow in my experience
18:50:13 <co_dh> kmc: cool, what is it if it's not text?
18:50:14 <btutt> but its still an abstract sequence?
18:50:21 <kmc> yeah
18:50:30 <kmc> co_dh, byte sequences and other stuff
18:50:38 <co_dh> cool !
18:50:54 <kmc> yeah, the type sig is:  (Ord t) => [t] -> [t] -> [Token t]
18:51:01 <kmc> need Ord because it uses Data.Map internally
18:51:12 <dankna> @hoogle Word8 -> Int8
18:51:13 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
18:51:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:51:13 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
18:51:18 <kmc> hehehe
18:51:21 <kmc> unsafeCoerce ;P
18:51:24 <dankna> ha
18:51:29 <btutt> The classic O(ND) with linear space? 
18:51:46 <kmc> btutt, i think so, not sure.  http://hackage.haskell.org/package/Diff
18:52:00 <kmc> o, or not
18:52:21 <btutt> yeah, thats the linear space one i bet
18:52:26 <dankna> oh, look at that, fromIntegral /does/ do what I want
18:52:33 <dankna> namely it makes the high bit act as sign
18:52:47 <btutt> You can get an amazing set of improvements if you prevent common prefixes/suffixes from entering the algorithm
18:53:04 <dankna> for bonus points make your diff implementation export an interface that also works with the rsync algorithm as a backend.
18:53:14 <Bynbo7> > -1 :: Word8
18:53:15 <kmc> btutt, interesting
18:53:15 <lambdabot>   255
18:53:22 <kmc> i didn't try that
18:53:47 <kmc> but it would break as soon as one file has a line inserted at the beginning
18:53:51 <btutt> it might be O(mn) and linear space but its still expensive since it does 2 LCS computations per divide and conquer pass
18:53:52 <kmc> even if there are 500 common lines in between
18:54:13 <kmc> patience diff is cool because it does small LCS computations only
18:55:16 <btutt> Some implementations assign unique token ids before running the algorithm
18:55:27 <btutt> 'cause reseeking stream == badness
18:55:45 <kmc> makes sense
18:56:28 <kmc> the basic limitation of patience diff is that it looks at the *unique* lines on each side
18:56:53 <kmc> so if everything is repeated, it has nowhere to start
18:57:06 <kmc> it does LCS on the unique lines and then recurses to the chunks in between
18:57:16 <kmc> (so then more stuff becomes unique in the restricted context)
18:57:50 <btutt> yep. Another diff implementation i've seen did SES on paragraphs and then lines
18:57:56 <kmc> SES?
18:58:05 <btutt> Shortest edit script
18:58:09 <kmc> ah
18:58:10 <btutt> diff is computing SES.
18:58:28 <btutt> LCS is a subpart of SES usually
18:58:36 <kmc> is there a name for \f -> catMaybes . map f
18:59:08 <btutt> which is why somebody wrote that O(NP) LCS algorithm that isn't applicable for diff because it doesn't work well for linear space SES.
18:59:36 <btutt> i.e. O(NP) LCS requires backtraking to get SES
19:00:12 * Bynbo7 is a member of the SES :o
19:00:24 <Pseudonym> GNU diff uses LCS plus local search to get not-too-bad edit script.
19:00:43 <kmc> i've decided to add --patience to my git-diff alias
19:00:48 <kmc> and see if i like it
19:00:59 <kmc> it's easy to come up with cases where patience diff is better
19:01:04 <kmc> but i'm sure it has its own pathologies
19:01:04 <btutt> yeah, gnu diff uses linear space O(ND) LCS to compute the SES
19:01:34 <btutt> all of the difference algorithms do
19:02:06 <btutt> I like windiff's implementation for use in non-merge related diff scenarios. (uses line movement detection)
19:05:03 <btutt> (i forget which paper its based off of
19:16:38 <kmc> ugh, not totally happy with Element, Token, Line, or Hunk
19:16:41 <kmc> naming stuff is hard
19:16:47 * kmc makes a note to never have children
19:17:07 <btutt> Monad, Category, and Helen, see easy. ;)
19:17:25 <kmc> haha
19:17:43 <kmc> maths has this problem where all the names for collections have precise meanings
19:18:04 <kmc> set, group, category, field
19:18:07 <kmc> body if you're french
19:18:19 <btutt> don't forget ring :)
19:18:31 <kmc> it burns burns burns
19:18:33 <btutt> althogh not sure if thats a collection
19:18:46 <copumpkin> I'd call all of them structures
19:18:58 <kmc> anyway there's no good word for just "Some stuff"
19:19:06 <kmc> sometimes "family" or "collection"
19:20:21 <geheimdienst> bag?
19:20:40 <dankna> kmc: Item
19:20:49 <dankna> kmc: Collection
19:21:09 <kmc> i guess i should call it Item and just make people import qualified
19:21:13 <geheimdienst> signifies that you don't care about a mathematical sense, it's "just some stuff"
19:21:24 <kmc> i've heard "bag" as a synonym for "multiset"
19:22:10 <btutt> just call it stuff and [stuff]
19:22:14 <BMeph> Funny, I've heard of "multiset" as a preferred name for "bag"... ;þ
19:22:39 <dankna> what does Item conflict with that people would need it qualified?
19:23:18 <kmc> just that it's stupid if your code says "Item" everywhere
19:23:24 <kmc> whereas "Diff.Item" is ok
19:23:28 <dankna> oh
19:23:29 <dankna> I guess.
19:23:43 <kmc> i could name it DiffItem but i prefer to let the importer decide the prefix
19:24:17 <btutt> yeah, clarity is more important than brevity sometimes. Sometimes that makes reading Haskell kind of painful.
19:24:25 * shachaf occasionally wishes Haskell's module system was nicer.
19:25:05 * dankna sort of wishes you could export a module qualified
19:25:18 <kmc> brevity often helps with clarity
19:25:19 <kmc> not always
19:25:24 <shachaf> And by "occasionally" I mean "whenever I write Haskell". Which is occasionally.
19:26:01 <dankna> module AllTheCrapIAlwaysNeedAnyway (Data.Map.Map, module Data.Map as Map) where ...
19:26:15 <kmc> you can't do that can you? :/
19:26:27 * geheimdienst likes qualified importing. when reading, you can immediately tell where stuff comes from
19:26:28 <kmc> oh you said that up there
19:27:03 * shachaf gets spam about quality imports all the time.
19:28:12 <dankna> no, you can't do that, yeah
19:28:31 <dankna> I wish you could.  I doubt anyone else really wants the feature or I'd see about implementing it.
19:28:52 <dankna> there are some design issues with it of course
19:34:32 <kmc> i'e wanted that
19:59:21 <Chaze> @pl (\t -> [(a,b) | a <- t, b <- t])
19:59:22 <lambdabot> liftM2 (:) (((a, b) | a) <-) (return . (b <-))
19:59:42 <kmc> urk
19:59:55 <kmc> pl fail
20:00:02 <kmc> Chaze, liftM2 (,)
20:00:06 <shachaf> @. pl undo (\t -> [(a,b) | a <- t, b <- t])
20:00:07 <lambdabot> (=<<) =<< (. (flip flip [] . ((:) .) . (,))) . (>>=)
20:00:08 <parcs> i wonder what it interprets brackets as
20:00:12 <kmc> @pl \xs -> liftM2 (,) xs xs
20:00:13 <lambdabot> join (liftM2 (,))
20:00:18 <kmc> > join (liftM2 (,)) "abc"
20:00:18 <shachaf> parcs: Singleton list.
20:00:19 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c'...
20:00:29 <Chaze> kmc: nice, thanks
20:00:33 <parcs> ah, duh
20:01:32 <mightybyte> @pl (\f vs -> modifyTS $ bindSplices (concat $ map (map (second return) . f) vs))
20:01:32 <lambdabot> ((modifyTS . bindSplices . join) .) . map . (map (second return) .)
20:01:34 <parcs> :t (=<<) =<< (. (flip flip [] . ((:) .) . (,))) . (>>=)
20:01:36 <lambdabot> forall a. [a] -> [(a, a)]
20:01:46 <parcs> oh god
20:01:53 <mightybyte> lol
20:03:17 <mightybyte> @pl (\f vs -> modifyTS $ bindSplices (concat $ map f vs))
20:03:18 <lambdabot> ((modifyTS . bindSplices . join) .) . map
20:05:35 <co_dh> parcs: what are you reading ? if you don't mind.
20:06:51 <parcs> co_dh: what do you mean?
20:07:54 <Chaze> some math terminology i forgot: when a closure operator can be defined as the fixpoint of f, how do you call f?
20:10:55 <co_dh> parcs : I'm wondering where this coming from : (=<<) =<< (. (flip flip [] . ((:) .) . (,))) . (>>=)
20:11:05 <co_dh> but I found it in the log , never mind.
20:17:41 <co_dh> I don't understand what's the closed means in Closed Cartesian Category. I know it's about exponential, but why it's called closed ? 
20:18:29 <co_dh> for me, the closed remind me the definition in algebra. that is , (N, +) while + is closed.
20:19:18 <Twey> http://en.wikipedia.org/wiki/Closed_category
20:19:18 <copumpkin> closed under cartesian product?
20:19:45 <copumpkin> fair enough :)
20:23:09 <co_dh> I think Closed might related to exponential ( functional space)
20:23:26 <copumpkin> he just gave you a link saying what it is :)
20:24:43 <co_dh> ok, that's means the Closed means the Hom functor is closed, thanks copumpkin and Twey
21:06:11 <Chaze> i haven't actually been complining a lot. i get these linker errors when using Data.Set:
21:06:11 <Chaze>  undefined reference to `containerszm0zi2zi0zi1_DataziSet_Tip_closure'
21:06:19 <Chaze> is there something i have to pass to ghc?
21:06:33 <copumpkin> --make
21:07:05 <kmc> basically, always pass --make
21:07:10 <kmc> it's the default now
21:07:28 <augur> copumpkin!
21:07:32 <augur> you slag!
21:07:45 <kmc> this also means you don't have to list all your .hs files -- it's enough to name the one containing "main", and it will find the rest by imports
21:07:49 <kmc> and recompile them only if they've changed
21:07:50 <Chaze> thanks
21:07:56 <augur> kmc: wheres your block
21:07:57 <augur> blog..
21:08:11 <kmc> http://mainisusuallyafunction.blogspot.com/ why
21:08:15 <kmc> i also wrote some stuff on the ksplice blog
21:20:09 * hackagebot elf 0.24 - Parser for ELF object format.  http://hackage.haskell.org/package/elf-0.24 (ErikCharlebois)
21:20:49 <kmc> :O
21:21:13 <kmc> have my wishes secretly been answered?
21:21:47 <btutt> dunno you want to parse elf binaries?
21:22:26 <kmc> yes, and i was using the elf library
21:22:32 <kmc> but earlier complained of a missing feature
21:22:51 <kmc> (i'm using it either way, just might have to write more code myself)
21:23:05 <btutt> libelf is missing something? 
21:23:55 <kmc> the haskell library named "elf"
21:24:03 <btutt> ah
21:55:45 <Veinor> okay, so
21:56:00 <Veinor> if the Functor typeclass is just endofunctors on Hask
21:56:12 <Veinor> fmap obviously corresponds to the part of the functor that maps arrows
21:56:17 <Veinor> but what about the part that maps objects?
21:56:55 <kmc> that's the type constructor itself
21:57:15 <copumpkin> Veinor: Maybe :: * -> *
21:57:21 <copumpkin> object to object!
21:58:16 <Veinor> oh, duh
21:58:25 <Veinor> i got mixed up and forgot that objects in Hask are types, not values
21:59:29 <kmc> yeah
21:59:36 <kmc> i think of a category basically as a "typed monoid"
21:59:40 <kmc> which yeah is backwards ;)
22:00:00 <copumpkin> values are morphisms from the terminal object!
23:13:35 * hackagebot pdfinfo 0.1.1 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-0.1.1 (ChrisDone)
