00:01:41 <fabian> great, I can talk on any channel on freenode but #erlang
00:02:53 <chrisdone> testing... %
00:02:53 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
00:03:01 <chrisdone> @messages
00:03:01 <lambdabot> Twey said 2d 8h 57m 54s ago: Please swap the title/author fields :<
00:03:06 <chrisdone> LOL
00:04:02 <chrisdone> who has the power to restart hackagebot?
00:06:42 <chrisdone> -  when (not $ Debug `elem` opts) $ hPrintf h (s++"\r\n")
00:06:42 <chrisdone> +  when (not $ Debug `elem` opts) $ hPrintf h ("%s\r\n") s
00:06:42 <chrisdone> this line needs changing in rss2irc. don't have time to submit a patch and I'll probably forget
00:14:51 <aleator> Anyone heard of   (GHC version 7.0.1 for i386-apple-darwin):
00:14:51 <aleator> 	initC: srt_lbl
00:14:54 <aleator> ?
00:15:11 <aleator> ghc: panic! (the 'impossible' happened)
00:15:38 <aleator> I can't find bug report for this, but I don't really have a good test case either
00:17:25 <aleator> Or, ghc: panic! (the 'impossible' happened)
00:17:25 <aleator>   (GHC version 7.0.1 for i386-apple-darwin):
00:17:25 <aleator> 	nameModule i{v a2iq}
00:17:29 <aleator> ?
00:29:11 <btutt> Well, that did the trick. Much 2xslower but ~20MB instead of ~189MB of space
00:41:27 <sipa> :t foldr
00:41:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
00:44:12 <jonkri> how can i create a new record based on a record? something like this: s#State { parsingContext = DocumentStarted }
00:44:48 <Saizan> without the #State
00:44:57 <aleator> jonkri: let myrec = .. in myrec{foo=1}? 
00:45:47 <merijn> Anyone here who can tell me what a "!-redex" is? By the looks of it, it appears to just simplify lambda terms. i.e. if !x = s is a local definition then !-reduction appears to be "!x = s:S . t" reduces to "t" if x not in t
00:46:50 <jonkri> Saizan, aleator: "s { parsingContext = DocumentStarted }" worked. thanks
00:49:12 <solrize> @hoogle xor
00:49:13 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
00:53:19 <btutt> IIRC ! forces 1 level of thunk evaluation if the right hand side is a thunk (or a sequence of thunks)
00:53:59 <btutt> if the right is just say 3.14 then there isn't anyt thunk to evaluate
00:53:59 <merijn> btutt: You were referring to my question?
00:54:05 <btutt> yeah
00:54:25 <merijn> I wasn't referring to haskell syntax, but type theory :)
00:54:38 <btutt> oh, then nvm. ;)
00:55:12 <btutt> lack of strictness has been giving me headaches lately. ;)
00:55:46 <gienah> In type theory I have only heard of iota, beta, zeta and delta reductions, not sure what ! reduction is
00:57:44 <merijn> gienah: I think its similar to gamma reduction I've seen mentioned in some of the epigram papers (i.e. garbage collection of local variables, where you can replace a local variable with its value after its been bound). But I'm not sure about that
00:58:49 <gienah> merijn: thanks
00:59:08 <merijn> Which is sort of what I wanted to check here :p
00:59:19 <merijn> But I guess all the type theory people are still in bed
00:59:46 <gienah> I guess so, maybe later you might have more luck
01:02:15 <Saizan> i've only seen ! in epigram 2 syntax, where it's one fo the two projections for sigma types iirc
01:04:05 <merijn> Saizan: I'm reading about Oleg now, where ! is let-definition (i.e. local variables). The !-reduction seems similar to gamma-reduction I saw in Epigram papers, but I'm not certain I;m right about that
01:13:55 * hackagebot iteratee 0.8.1.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.1.1 (JohnLato)
01:39:10 <maxJadi> Hi, I have problem with "import Network" after compiling on ghci, ghci says "Could not find module `Network' :", I have install haskell-platform and i have fedora. Any idea ?   
01:48:07 <ivanm> maxJadi: because the module isn't called Network
01:48:21 <ivanm> oh, wait, I lie: it _is_ called Network
01:48:33 <ivanm> maxJadi: ghc-pkg list network
01:51:19 <gienah> maxJadi: the fedora packaging notes talk about separate library packages, not sure if that gives any hints or not:  http://fedoraproject.org/wiki/Packaging:Haskell
01:51:50 <maxJadi> ivanm, I got some warning  "WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.      /usr/lib/ghc-6.12.3/package.conf.d    /home/max/.ghc/i386-linux-6.12.3/package.conf.d", I seems that i should remove and install it again.... 
01:52:02 <ivanm> which packages are broken?
01:52:10 <ivanm> and are they broken in your global or local pkg db?
01:57:37 <maxJadi>  ivanm ,It has to do with XML-Enumerator package which is external ....,
01:58:56 <ivanm> so what exactly are you doing?
01:59:04 <ivanm> running ghci, and then doing "import Network" inside of it?
01:59:25 <ivanm> wait, ghc-pkg list didni't list it...
01:59:31 <ivanm> which indicates that it isn't installed...
02:01:27 <jonkri> maxJadi: have you done cabal install xml-enumerator?
02:02:11 <jonkri> maxJadi: and please provide the output from ghc-pkg check
02:03:09 <ivanm> jonkri: that shouldn't matter if he just wants to use network
02:04:25 <eroomde> hi BONUS - thank you for your great tutorial. Is there a link for an offline version somewhere? I am going abroad to somewhere internetless for a couple of weeks and would like to really dive into it
02:06:24 <eroomde> oh it's a slow day, sorry I missed the pdf file that's trivially googleable the first time round. sorry for time wasting!
02:07:53 <maxJadi> jonkri, I do even reinstall the xml-enumerator package but still the same ... 
02:10:27 <ivanm> maxJadi: can you paste the entire output of "ghc-pkg check" somewhere?
02:11:26 <maxJadi> ivanm, jonkri , there is no indicator that shows eml-enumerator is not installed ..... I got "http://paste.pocoo.org/show/342724/" from ghc-pkg check
02:11:58 <ivanm> maxJadi: ghc-pkg list xml-enumerator
02:12:31 <ivanm> (though that output shows that xml-enumerator is installed, just that one of its dependencies was either uninstalled or upgraded and it thus can't find it)
02:13:57 <maxJadi> ivan, it lists two versions of xml-enumerator, 0.1.0 (which is red) and 0.1.1. how can i uninstall 0.1.0?
02:15:09 <ivanm> maxJadi: how did you install it, with cabal-install?
02:15:44 <ivanm> if so, "ghc-pkg unregister xml-enumerator-0.1.0" will stop ghc-pkg from knowing about it, but will leave the installed files floating around
02:16:24 <maxJadi> Yeah, 
02:16:41 <maxJadi> ivanm, Yeah
02:40:09 <KitB_> Is haskell.org down again?
02:40:30 <ToRA> it's up for me
02:40:32 <nanothief> its working for me
02:40:39 <KitB_> Hmm
02:40:48 <KitB_> isup.me says it's down as well
02:41:16 <nanothief> http://www.downforeveryoneorjustme.com/haskell.org says it's up
02:41:41 <KitB> Now it's changed its mind
02:42:45 <KitB> And now it's working for me
02:42:50 <KitB> nevermind :)
02:43:11 * Daerim managed to get a link between Fortran and haskell going. Wohoo!
02:44:00 <Daerim> well... actually I guess it's a deadly sin I'll propably go to hell for, but still
02:44:18 <KitB> Can anyone point me at a function that'll take a string and split it into a list of strings given a delimiter (like lines/words but general)?
02:45:29 <dobblego> KitB: see Data.List.Split on hackage
02:45:32 <Daerim> KitB, I think "split" does exactly that
02:47:17 <KitB> dobblego, Daerim: thanks
02:47:20 <Daerim> hmm... odd.. split exists in both Text and Bytestring, but not for normal lists in base?
02:49:40 <maxJadi> ivanm, i tried using cabal upgrade and cabal install to solve it without success. i also reinstalled ghc and cabal-install and removed .cabal and .ghc, but i get back into the same problem with Network notbeing importable
02:50:02 <maxJadi> ghc-pkg check returns nothing
03:11:26 <ivanm> maxJadi: if "ghc-pkg list network" doesn't say anything, then you don't have it installed
03:11:38 <ivanm> Daerim: see the split package
03:11:41 <ivanm> @hoogle split
03:11:41 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
03:11:41 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
03:11:41 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
03:12:04 <smoge> Hi
03:12:36 <Daerim> ivanm, yes I've seen it. I just found it curious that it wasn't in the haskell platform I guess
03:12:38 <smoge> anyone knows a program that reads metadata from a PDF file?
03:12:39 * ivanm waves idly in smoge's general direction
03:12:55 <ivanm> Daerim: 1) it has to be proposed to be in the platform, 2) is it that hard to install it yourself?
03:13:03 <ivanm> smoge: in haskell you mean?
03:13:05 <ivanm> or in general?
03:13:06 <smoge> like a title of an article
03:13:14 <smoge> in haskell (or anything)
03:13:55 <ivanm> pdfinfo ?
03:14:26 <smoge> thanks ivanm, i will take a look
03:16:24 <Daerim> ivanm, .....
03:25:54 <maxJadi> ivanm, it seems that network was not installed. thought ghc came bundled with it. thanks for your help
03:49:17 <KitB> I'm looking for a map-like structure that supports findMax on /values/ rather than keys, any suggestions?
03:54:37 <dancor> KitB: if there is more than one max value do you want all the keys?
03:55:06 <KitB> dancor: No, just any old one
03:55:21 <dancor> how about bimap
03:55:23 <dancor> http://hackage.haskell.org/packages/archive/bimap/0.2.4/doc/html/Data-Bimap.html
03:55:26 <dancor> findMaxR
03:55:29 <KitB> Fantastic
03:55:30 <KitB> Thanks
03:56:27 <dancor> tho with bimap i don't think you can have repeated values
03:57:44 <dancor> you could also create a shallow wrapper around map that tracks the max value
03:58:22 <KitB> Indeed
03:58:50 <KitB> I'll be using it basically to count occurrences of strings
03:59:01 <KitB> (in a set of sets of strings)
03:59:09 <sipa> otherwise you need a (Map k v, Set [v]), keeping them synchronized
04:14:49 <dancor> what do i do if i'm trying to compile something and ghc says: Couldn't match expected type `network-2.2.1.10:Network.URI.URI' with actual type `Network.URI.URI'
04:14:59 <mm_freak> i found that with the enumerator package you don't even need blaze-builder or something like that anymore
04:15:07 <mm_freak> i love iteratees
04:15:24 <mm_freak> the more i use them, the less fun it gets to code in another language
04:15:30 <mm_freak> almost frustrating
04:15:54 <merijn> mm_freak: Same goes for haskell in general, for me
04:16:18 <dancor> i just did a (ghc-pkg --hide network-2.3), hope i don't end up regretting it
04:16:20 <merijn> Doing C atm and all I can think is "this would be so much easier in haskell..."
04:21:45 <mm_freak> merijn: well, there are some concepts, which you can only use in haskell sanely
04:22:16 <mm_freak> not counting theorem proving languages, because i don't really view them as general purpose languages
04:25:18 <astroboy> Is there anyway to have haskell indenting in vim as in emacs while editing haskell? As in pressing <Tab> indents the current line?
04:25:34 <merijn> astroboy: Works fine for me...
04:25:57 <astroboy> merijn: you mean that you've got the behaviour I described?
04:26:08 <merijn> There should be various haskell syntax files for vim, but autoindenting works out of the box for me
04:26:24 <merijn> Or you mean like reindenting stuff?
04:27:02 <astroboy> merijn: well for example now I'm on a data type
04:27:13 <astroboy> I have Data Foo = Foo
04:27:24 <astroboy> then i want to insert deriving (Eq) on the next line
04:27:42 <astroboy> and with emacs it puts the deriving where the = is on the previous line
04:27:52 <astroboy> I mean it doesn't seem aware of the context
04:27:59 <astroboy> it just puts 4 spaces
04:28:21 <astroboy> if I try to do Foo | Bar, same thing
04:28:23 <merijn> astroboy: Maybe some of this stuff helps? http://projects.haskell.org/haskellmode-vim/
04:28:35 <astroboy> merijn: that's what I'm using now, it doesn't mention indenting
04:29:55 <astroboy> also, haskellmode is the only reason why I'm trying to use vim
04:31:03 <merijn> You might need some non-standard indent file, I'd say googling "haskell vim indent" should turn up something?
04:31:50 <astroboy> merijn: actually you're right, there seems to be something
04:32:42 <merijn> I don't think the default indent files are very sophisticated and haskellmode doesn't seem to include a more sophisticated one. But I can't imagine no one having created one yet
04:34:39 <astroboy> merijn: i'm trying it now
04:35:28 <astroboy> merijn: no, it doesn't really work
04:35:36 <astroboy> or maybe I simply didn't install it properly :P
04:48:50 <astroboy> merijn: ok, I shoved the code into autoload and it works, but it doesn't work well
04:49:22 <astroboy> for example, if I'm typing "[ foo" and i go to a new line, it should align with the [
04:57:16 <Peaker> To get the sizeof() of some C struct I want to use via FFI (I don't need the struct fields, the struct is opaque except for its size as it is to be allocated by the caller), what do I do?
04:57:32 <uroborous> greetings... I'm using Parsec to transform some Log file data from a file. I now want to use the same parser to process data directly from a System.runCommand. Any pointers on hooking up the parse with the runCommand output?
04:57:55 <Peaker> should I use c2hs with the struct, or is it easier to just write a little C file with mallocSomeStruct(params) so that I can call that instead of knowing the sizeof?
04:58:40 <Peaker> uroborous, do you want it to lazily consume runCommand or is it OK for it to get the entire output and then consume that?
04:59:05 <uroborous>  preferably Lazy, but I am curious to see the direct route also
05:00:06 <Peaker> http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:readProcess -- is strict
05:03:37 <uroborous> thanks Peaker! now the the Lazy approach...
05:04:06 <Peaker> uroborous, I think you might want to use enumerators for that
05:04:17 <Peaker> not sure how to compose enumerators with parsec, probably a naive approach could work
05:06:33 <Peaker> is there a nice way to get c2hs to preprocess code without a manual build system?
05:06:39 <Peaker> maybe a pragma at the top of the file?
05:07:23 <Eduard_Munteanu> Manual?
05:07:33 <Eduard_Munteanu> I'd think Makefiles/Cabal.
05:08:26 <Peaker> I'll look up how to use Cabal with it..
05:08:31 <Peaker> What's the difference between c2hs and chs2hs?
05:15:48 <Claudius1aximus> Peaker: hsc2hs is probably what you want for simple things; afaik c2hs is for binding whole libraries automatically
05:17:07 <Peaker> Ah.. I see greencard is supposed to go even further
05:17:18 <Peaker> I think I'll start with greencard hoping for the best. if that fails, c2hs. If that fails, hsc2hs
05:24:00 <deech> Hi all, I just ran into this syntax in the ThreadScope source "return ViewerState { .. }". It appears to grab everything initialized upto that point in the do-block and somehow create a ViewerState datatype with it. Can someone point me to where this feature is documented?
05:24:14 <mm_freak> case undefined of _ | cond1 -> expr1 | cond2 -> expr2 …
05:24:22 <mm_freak> is there a more elegant way to write this?
05:24:31 <mm_freak> i have no particular expression to pattern-match against
05:25:54 <pastorn> mm_freak: nested ifs?
05:26:38 <ClaudiusMaximus> deech: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards perhaps
05:27:28 <quuuux> mm_freak: writing it with guards and giving the conditional expression a name may help
05:27:39 * liyang <3 record wildcards and named field puns
05:29:41 <hpc> named field puns?
05:30:19 <liyang> mm_freak: nested cases (yes, cases on Bools) formats more easily than if-then-else, if you can split the conditions up nicely.
05:30:28 <deech> ClaudiusMaximus: Interesting. I bet that's it, although the documentation doesn't say it works in a do-block initialized variables.
05:30:45 <liyang> hpc: allows you to write e { field_name } instead of e { field_name = field_name }
05:31:06 <KitB> Anyone have any ideas on making a Hashable instance for HashSet?
05:31:32 <hpc> liyang: oh cool
05:31:44 <deech> liyang: Does this work in 6.12.3?
05:32:16 <quuuux> deech: works for me in 6.12.1, so I'd be surprised if it didn't :)
05:32:40 <liyang> deech: it's been around for years!
05:33:02 <pastorn> mm_freak: i actually like the case-thing you seem to have there, though i'd case on () and not on undefined
05:33:24 <augur> i dont think i follow how f algebras work. if you have something F : 1 + X*X -> X, isnt the X*X already an element of the relevant type? or am i doing something wrong
05:33:49 <deech> liyang: neat!
05:33:49 * quuuux didn't know until last week that you could guard on case branches
05:34:13 <liyang> (so if you're in a do block say, you just bind some names that happen to coincide with record field names, and do a return Cons {..} at the end, which I suspect is what ThreadScope was doing.)
05:34:40 <jonkri> how can i go from a bytestring with random elements to a random list of characters with contents like a-z, 0-9?
05:35:31 <deech> liyang: I think you're right! It's just really cool. 
05:36:05 <mm_freak> hmm, yes
05:36:11 <mm_freak> i think, i'll stick to what i have
05:36:40 <mm_freak> i can't separate the conditions nicely
05:36:55 <quuuux> jonkri: I don't understand your question. If you just want a random list of those characters, generate one?
05:36:56 <liyang> I'm guess that's an intended use of RecordWildCards though. What's not is possibly using ViewPatterns to perform minor coercions. e.g. foo (fromIntegral -> n) = ...
05:38:38 <deech> liyang: Yes, I wish they'd documented that it works in a do-block since "let x = ..." and "x <- ..." are completely different things.
05:39:20 <jonkri> quuuux: i want a random string, and the only source of randomness that i have is a bytestring :)
05:39:40 <jonkri> quuuux: i want the string to be "human readable"
05:40:04 <Eduard_Munteanu> @hoogle random
05:40:04 <lambdabot> package random
05:40:04 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
05:40:04 <lambdabot> module System.Random
05:40:12 <quuuux> jonkri: so extract some entropy from your bytestring, and use that as a seed for Haskell's RNG API?
05:40:44 <liyang> deech: it doesn't matter where the bound name comes from (be it let-, <-, or \lambda-bound), as long as it coincides with a field name.
05:40:55 <Eduard_Munteanu> As far as some people here say, reseeding a PRNG isn't good.
05:41:19 <jonkri> Eduard_Munteanu, quuuux: i'm using http://hackage.haskell.org/packages/archive/crypto-api/0.4.1/doc/html/System-Crypto-Random.html
05:41:31 <jonkri> i see
05:41:48 <Eduard_Munteanu> You might want to unpack your Bytestring and map values into A-Za-z0-9
05:42:09 <liyang> deech: in fact, if you mis-spell the name on the let or <- line say, it'll try to assign the projector for that field to that field itself, which gives slightly obtuse type errors.
05:42:10 <Eduard_Munteanu> *If* the bytestring is a good random source.
05:42:35 <jonkri> Eduard_Munteanu: it should be
05:42:37 <hpc> > length $ ['A'..'Z'] ++ ['a'..'z'] ++ ['0'..'9']
05:42:39 <lambdabot>   62
05:42:54 <hpc> Eduard_Munteanu: mapping will be problematic
05:43:33 <hpc> you can't make the mapping a bijection, so it will be biased towards some values
05:43:40 <Eduard_Munteanu> Well, an easy way is to zip that, then index into it with modulo arithmetic
05:43:52 <Eduard_Munteanu> Ah, yes.
05:44:04 <hpc> well, bijection modulo the width of whatever
05:44:17 <quuuux> just use it in 62-byte blocks
05:44:32 <hpc> quuuux: haha
05:45:05 <Eduard_Munteanu> Why not use the whole 0..255 and uuencode or something at the end if you don't want binary data?
05:46:17 <Eduard_Munteanu> Also if you add one/two other symbols, like '@' and '#', the length is 64 so you can make a non-biased map.
05:46:30 <Eduard_Munteanu> > 256/64
05:46:31 <lambdabot>   4.0
06:04:48 <pastorn> ugh... multiple records in one type :(
06:04:59 <pastorn> danger! danger!
06:05:05 <jonkri> how can i go from Byte8 to Num?
06:05:17 <pastorn> jonkri: fromIntegral
06:05:41 <hpc> > let x = 5 :: Byte8 in fromIntegral x
06:05:42 <lambdabot>   Not in scope: type constructor or class `Byte8'
06:07:08 <copumpkin> Word8?
06:07:17 <jonkri> oh :P
06:10:12 <apfelmus> Hello. :)
06:10:17 <apfelmus> Anyone seen byorgey around?
06:10:23 <copumpkin> byorgey might have
06:10:30 <copumpkin> preflex: seen byorgey 
06:10:30 <preflex>  byorgey was last seen on #haskell 1 day, 21 hours, 7 minutes and 51 seconds ago, saying: hi hi copumpkin 
06:11:22 <apfelmus> preflex: > 1 + 1
06:11:32 <hpc> preflex: 1+1
06:11:42 <hpc> preflex: i am disappoint
06:11:59 <apfelmus> preflex is a bot, right?
06:12:07 <hpc> yes
06:12:27 <hpc> lambdabot is the more useful bot here though
06:12:30 <liyang> no, we pay some cheap callcentre staff to keep track of everyone on the channel.
06:12:40 <hpc> lol
06:13:09 <apfelmus> Ah. I thought that the callcenters were hiring expensive robots that pretend to be cheap call center staff
06:14:14 <liyang> apfelmus: but how do they make any profit?!?
06:14:22 <hpc> liyang: they are also a bank
06:14:52 <hpc> they sink money into the robots and deduct it from the other branch
06:14:54 <hpc> then get bailed out
06:15:35 <apfelmus> What happened to the deadline for the monad.reader?
06:16:05 <apfelmus> I've sent something in but haven't heard back from Brent yet.
06:16:25 <apfelmus> That's why I'm stalking around the block, looking fro byorgey.
06:16:28 <apfelmus> *for
06:17:49 <xplat> < lambdabot> http://hackage.haskell.org/package/toilet
06:18:01 <xplat> wow, what a naive set of assumptions
06:18:38 <xplat> these are supposed to be smart students, like they wouldn't think of cooperative schemes for advantage that involve multiple countries
06:21:26 <xplat> if you can advance 10 rankings while also advancing one competitor 10 rankings that is a definite win for the determined cheater
06:24:36 <mm_freak> which variant would you recommend?  Iteratee over StateT or StateT over Iteratee?
06:24:50 <mm_freak> currently i'm using the latter, but it's a bit inconvenient
06:25:00 <mm_freak> (talking about the 'enumerator' package)
06:25:07 <earthy> mm_freak: I'm using Iteratee over State
06:25:26 <earthy> seems to fall out nicely
06:25:37 <mm_freak> yeah, i think i'll go with that, too
06:25:51 <earthy> StateT over Iteratee sounds cumbersome, to say the least
06:26:40 <Peaker> because lifting iteratee operations is heavy?
06:26:50 * earthy laughs
06:27:02 <pastorn> could someone help me with a sort of tricky problem?
06:27:11 <earthy> because Iteratee m a already has a slot for an arbitrary monad
06:27:17 <pastorn> i think there's a typeclass solution to what i want to do, but i can't see it
06:27:18 <earthy> without needing to do lifting
06:27:32 <earthy> whereas StateT Iteratee does need lifting
06:28:35 <pastorn> so what i have now is data D = D0 { dState :: State } | D1 { dState :: State, ...*lotsofstuffhere*... }
06:28:51 <mm_freak> earthy: i'm talking about StateT, not State
06:29:06 <mm_freak> and both Iteratee and StateT use CPS
06:29:16 <pastorn> (State is an enum-like, has 4 constructors)
06:29:30 <mm_freak> the lifting itself is not expensive, but i'm doing way more Iteratee operations
06:29:53 <mm_freak> and now it's a performance question
06:30:05 <mm_freak> StateT over Iteratee appears faster to me intuitively
06:30:20 <pastorn> now i have a function 'update :: Input -> D -> D', but it's turning out to be quite a mess...
06:30:20 <mm_freak> but on a second thought, it may be the other way around
06:33:45 <Peaker> earthy, how do you perform actions in the "m" of the Iteratee monad?
06:33:53 <Peaker> earthy, surely there must be some lifting going on?
06:34:01 <mm_freak> Peaker: lift . lift
06:34:07 <mm_freak> ah, directly
06:34:10 <mm_freak> then only lift
06:34:44 <mm_freak> now the question remains:  how do i convert Iteratee a (StateT s m) b to Iteratee a m b?  probably the correct answer is:  i don't
06:35:03 <Peaker> It can't be directly in the "Iteratee m a", because e.g: (>>) can't bind "Iteratee m a" actions with "m b" actions directly
06:35:22 <phryk> Can anyone tell me just how much space ghc needs to compile?!
06:35:41 <phryk> I have 1.6G free, and it fails because it runs out of space…
06:38:25 <tab> phryk: i've got a build of ghc-7 that is taking 2.3G
06:38:50 <Peaker> Apparently GHC comes out of Microsoft! :-)
06:39:04 <pastorn> http://hpaste.org/44211/better_design <-- could someone comment?
06:39:55 <pastorn> oh, and if i have the constructor D0 the state is always S0
06:40:20 <Peaker> pastorn, why not have D be (Bool, S)?
06:40:41 <Peaker> pastorn, and why not have the case determine which "run" to use, and then apply that to inp and d?
06:40:44 <pastorn> Peaker: tha actual design is more complicated
06:41:12 <Peaker> You could probably get rid of the S type altogether, and have D itself contain runN inside it?
06:41:18 <pastorn> the problem with the different runs is not the problems either... they'll all look pretty much the same
06:41:43 <pastorn> Peaker: i'll just show you the *actual* code
06:42:32 <pastorn> Peaker: http://codepad.org/lik4brxg
06:42:58 <merijn> Peaker: A few of the core GHC people work at Microsoft Research, yes
06:43:53 <pastorn> Peaker: look at the bottom for the exported typeclass (with types)
06:44:57 <Peaker> pastorn, I dislike the style of shared field names in constructors
06:45:07 <Peaker> pastorn, I'd refactor the shared part outside to a product type
06:45:19 <pastorn> Peaker: i had that... looked like shit
06:45:23 <Peaker> runBoard seems like "id"?
06:45:39 <pastorn> Peaker: yeah... for now, look at its type
06:46:19 <Peaker> seems the runners have a shared "Size -> UserGame -> UserGame" at the end
06:46:21 <pastorn> Peaker: the idea is that in the mainLoop all incoming network messages gets distributed to all the components, then the components are responsible for either updating or ignoring
06:47:06 <pastorn> Peaker: yeah, there will also be a case for when a private chat message is received from your opponent
06:47:26 <phryk> So
06:47:41 <phryk> Now i cleared 3.0G for the compilation of ghc-6.12.3
06:47:58 <phryk> if this dies again, I'll stab one of the core devs with a spoon.
06:49:05 <pastorn> Peaker: i could try and rewrite it as a product type, but it's not gonna be pretty
06:49:23 <Peaker> pastorn, It seems like you could use Maybe to wrap the non-shared fields? Or do you mean to expand that later?
06:49:47 <Peaker> pastorn, maybe it can start non-pretty and be beautified even more
06:50:10 <pastorn> Peaker: ah, i had some old code backed up: http://codepad.org/GPNWRcmU
06:51:03 <jonkri> can you hard code defines/macros in haskell?
06:51:54 <Peaker> pastorn, maybe you could have a Maybe type with Nothing to represent NoGame, and (Just (Blah, UserGameData))  where Blah = BeforeFirst | Playing | GameDone
06:52:07 <Peaker> pastorn, that way it is easier to get to the UserGameData regardless of the Blah
06:52:14 <jonkri> on second thoughts, i guess that's just a function huh :P
06:52:19 <Peaker> pastorn, also differentiate NoGame more fundamentally from the rest
06:52:19 <pastorn> Peaker: true...
06:52:53 <Peaker> pastorn, Maybe is less informative, but has a bazillion functions ready :)
06:53:14 <pastorn> Peaker: could you make a small paste with what you mean?
06:53:47 <Peaker> ok
06:56:42 <pastorn> Peaker: i was thinking this could be constructed with GADTs in some way...
07:01:01 <Peaker> bah, it ruined the formatting cause it was a "comment"
07:01:28 <Peaker> http://codepad.org/k93C0kcW
07:01:39 <Peaker> oops, forgot UserData there
07:03:13 <Peaker> http://codepad.org/h9VC4zur
07:03:18 <pastorn> Peaker: you can't put the player nick within the maybe... that way you won't have the information in the beginning :(
07:03:38 <pastorn> it's needed to discerd between the game you're playing and games which you're observing
07:03:41 <Peaker> pastorn, It's out of the Maybe
07:03:49 <Peaker> pastorn, in the first paste I just forgot it altogether
07:04:17 <pastorn> heh
07:04:30 <pastorn> hmm... this might get messy, but i'll try it
07:05:51 <Peaker> do you know SECs?
07:06:15 <pastorn> ehm... no?
07:06:24 <Peaker> they're great for these kinds of structures
07:06:26 <Peaker> @where SEC
07:06:26 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
07:08:09 <Peaker> pastorn, to form a UserGame -> UserGame function, you can use something like:  atUserData doThat   or:  atUserGameData . fmap . second . atTimeAddition $ (+elapsedTime)
07:08:12 <pastorn> Peaker: look like fclabels
07:08:26 <pastorn> oh
07:08:37 <Peaker> fclabels is like SECs for the special case of type products, so it makes sense to also have a "getter"
07:08:44 * hackagebot mongoDB 0.9.3 - MongoDB driver  http://hackage.haskell.org/package/mongoDB-0.9.3 (TonyHannan)
07:09:04 <Peaker> SECs are for the more general case (inside functions' args and results, all elements in a list, ...) so a "getter" doesn't always make sense
07:09:17 <pastorn> Peaker: i'll do it with standard haskell first
07:09:19 <Peaker> pastorn, the "fmap" there is used to go inside the maybe
07:09:37 <Peaker> sure, though without SECs it will probably get messy quickly :)
07:09:58 <pastorn> Peaker: i think with the data i'm holding it's gonna be messy whatever i do
07:11:24 <Peaker> I disbelieve that :)
07:14:04 <pastorn> Peaker: i reduced your structure a bit ;)
07:14:11 <pastorn> flattened it, but kept the maybe
07:14:21 <Peaker> Sure :)
07:14:59 <mercury^_> What extensions does that SEC post use?
07:15:41 <mercury^_> Because `first reverse [1,2,3]' seems nonsensical.
07:15:51 <mercury^_> > first reverse [1,2,3]
07:15:51 <lambdabot>   Couldn't match expected type `[t]' against inferred type `([a], d)'
07:16:05 <mux> > first reverse [[1,2,3]]
07:16:06 <lambdabot>   Couldn't match expected type `[[t]]'
07:16:06 <lambdabot>         against inferred type `([a], d)'
07:16:09 <mux> err
07:16:15 <Peaker> I don't see "first reverse" anywhere there
07:16:16 <mux> > first reverse ([1,2,3],undefined)
07:16:17 <lambdabot>   ([3,2,1],*Exception: Prelude.undefined
07:16:28 <mercury^_> Peaker: (blabla.blabla.first) reverse
07:16:59 <Peaker> @let v0 = (3, \ c -> (['r',c,'q',c], isDigit c))
07:17:00 <lambdabot>  Defined.
07:17:08 <Peaker> @let result = (.)
07:17:09 <lambdabot>  Defined.
07:17:21 <Peaker> > (second.result.first) reverse v0
07:17:22 <lambdabot>   Overlapping instances for GHC.Show.Show
07:17:22 <lambdabot>                              (GHC.T...
07:17:55 <Peaker> > let x = (second.result.first) reverse v0 in    snd x '1'
07:17:57 <lambdabot>   ("1q1r",True)
07:18:29 <Peaker> the reverse applies in the second of the tuple (3, ...) in the result of \c -> ...   in the first of (...., isDigit c)
07:18:37 <Peaker> and that is indeed a list, so it's senseful to reverse it
07:24:49 * hackagebot mongoDB 0.9.4 - MongoDB driver  http://hackage.haskell.org/package/mongoDB-0.9.4 (TonyHannan)
07:28:47 <sipa> is there a function :: (a -> m b) -> m (a -> b) possible?
07:29:04 <xplat> i like ~> from http://matt.immute.net/content/pointless-fun
07:29:38 <xplat> it ought to be in Data.Function, has anyone proposed that yet?
07:31:01 <Saizan> sipa: not possible in general
07:31:50 <xplat> sipa: for the special case of IO, that would be a function that predicts all the effects you might need to compute the b value given any a and applies them in advance
07:33:40 <xplat> clearly you can see this wouldn't work for \x -> do { putStrLn $ "What is your favorite " ++ x ++ "?"; getLine }
07:34:27 <eikke> did anyone ever, for educational purposes or something alike, write an implementation of (basic) Paxos using Haskell? I'm a little stuck on how to structure the code/implement things without mutability
07:35:03 * JuanDaugherty wonders if Paxos is worth googling.
07:35:18 <Twey> eikke: If it's an imperative algorithm, we have ST for that sort of thing
07:35:24 <zaphar_ps> The original paper is a hard read
07:35:37 <zaphar_ps> I recommend the paxos made easy paper instead
07:35:55 <eikke> Twey: yes, I know about ST etc :)
07:36:03 <eikke> zaphar_ps: original is more fun to read ;)
07:37:38 <Cale> eikke: What application of it do you have in mind? I was unfamiliar with it until a moment ago, but by the looks of it you either want to think in terms of pure state transitions (represent the state of the system somehow, and describe its evolution over time by a function), or you want to use the concurrency primitives and multiple threads.
07:38:17 <xplat> i suppose it could go in Control.Category too
07:38:25 <eikke> Cale: wouldnt want to use it for some specific app, but write an implementation using some threads (for every actor)
07:38:48 <Cale> eikke: Do you know about MVar and Chan?
07:39:02 <eikke> Cale: the reasons: learn something myself, and create a 'simple' demonstration imlpementation of Basic Paxos, without any clutter  (like when reading some C imlpementation)
07:39:26 <JuanDaugherty> ah so it was, a general algorithm, not another purposeless pkg/platform
07:39:38 <eikke> Cale: I'm using Chan's already for inter-thread communication, and MVar for main-thread-blocking
07:40:00 <Cale> okay, so you already have mutability :)
07:40:31 <eikke> Cale: yes, but using MVars to keep track of state (like, number of promises accepted) feels dirty in a haskell sense :)
07:40:49 <Cale> You could use function parameters
07:40:58 <Cale> (perhaps)
07:41:47 <eikke> mhm, thats most likely the way to go indeed... didnt write/think haselly for too long
07:42:23 <xplat> > let f ~> g = (f >>>) . (g <<<)
07:42:24 <lambdabot>   not an expression: `let f ~> g = (f >>>) . (g <<<)'
07:43:30 <xplat> @let f ~> g = (f >>>) . (g <<<)
07:43:31 <lambdabot>  Defined.
07:47:38 <pastorn> Peaker: http://codepad.org/WBm0tX6L
07:50:03 <xplat> > sortBy (map toLower ~> (map toLower ~> id) $ compare) . words $ "for the special case of IO"
07:50:04 <lambdabot>   ["case","for","IO","of","special","the"]
07:51:21 <xplat> (yes, on would work here, but other less symmetric cases come up)
07:55:44 <Nisstyre> Why is ghci almost 700 mb?
07:55:57 <Nisstyre> s/ghci/ghc/
07:56:49 <pastorn> Nisstyre: search stackoverflow for that
07:57:00 <pastorn> Nisstyre: it was brought up there recently
07:57:16 <Nisstyre> yeah I see it now
07:57:17 <Nisstyre> thanks
07:57:23 <vegai> 700mb? huh
07:57:43 <vegai> oh, you mean the whole package, not just the binary
07:57:55 <Nisstyre> yeah that includes ghc and ghci
07:58:02 <Nisstyre> and the libraries
07:58:23 <jmcarthur> the libraries i think are the bulk. also, ghc includes a complete gcc
07:59:07 <vegai> http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
07:59:21 <Nisstyre> jmcarthur, why? Is it because it's incompatible somehow with the version of gcc already on there?
07:59:42 <xplat> 700MB is pretty large big all right
07:59:43 <jmcarthur> Nisstyre: i don't know. i doubt it's incompatible
07:59:55 <vegai> gcc's included in ghc only in windows, apparently
08:00:01 <jmcarthur> ah!
08:00:07 <jmcarthur> makes sense
08:00:57 * hackagebot epubname 2.3.2 - Rename epub ebook files based on meta information  http://hackage.haskell.org/package/epubname-2.3.2 (DinoMorelli)
08:02:02 <Nisstyre> jmcarthur, according to my package manager it only depends on perl, gmp, and gcc
08:02:46 <Nisstyre> it'll be bigger though because it's a 64 bit version
08:03:56 <sipa> Saizan, xplat: thanks, i realized it myself shortly after asking :)
08:04:32 <jmcarthur> Nisstyre: the ghc package in my package manager is 55M
08:04:36 <jmcarthur> compressed
08:04:51 <jmcarthur> this is 64 bit
08:05:35 <Yasir> Hey
08:06:10 <Yasir> Does (n f x) in SUCC := \n f x. f (n f x) mean that f is applied n times to x ? And then, f is applied to the result once more.
08:06:12 <Nisstyre> jmcarthur, http://www.archlinux.org/packages/extra/i686/ghc/
08:06:46 <Nisstyre> I'm not talking about the compressed size either
08:06:50 <jmcarthur> Nisstyre: http://www.archlinux.org/packages/extra/x86_64/ghc/
08:06:55 <jmcarthur> ah
08:08:00 <jmcarthur> i'm still going to say that it's mostly libraries
08:08:11 <Nisstyre> fair enough
08:08:28 <doserj> Yasir: in effect, yes, as long as n is a natural number. 
08:08:30 <augur> what does it mean for a diagram to commute
08:09:08 <zygoloid> augur: all paths in the diagrams between two points give the same arrow when composed
08:09:14 <augur> ok
08:09:20 <augur> thats what i thought but i wasnt sure
08:09:31 <augur> and not all arrow diagrams commute. ok.
08:13:40 <jmcarthur> i'm pulling some patches for my checkout of ghc head and saw this: "Now that we've stopped trying to support 64bit OS X 10.5 [...]"
08:13:44 <jmcarthur> what's the deal there?
08:15:06 <dankna> jmcarthur: excellent question.  I didn't see that, or hear that discussion.  I will note that 10.5 is not the current version.
08:15:22 <dankna> you might ask whoever's credited with the patch
08:15:46 <apfelmus> @seen byorgey
08:15:47 <lambdabot> Unknown command, try @list
08:15:47 <preflex>  byorgey was last seen on #haskell 1 day, 23 hours, 13 minutes and 11 seconds ago, saying: hi hi copumpkin 
08:15:56 <jmcarthur> Igloo: ^^
08:26:25 <byorgey> apfelmus: I am here.  and I did get your emails.
08:26:40 <byorgey> apfelmus: I am just processing life in "batch mode", that is all =)
08:28:37 <copumpkin> byorgey: does this year's hac phi have a webpage yet?
08:28:42 <byorgey> copumpkin: no
08:28:48 <copumpkin> this time I have no excuse not to go!
08:28:52 <byorgey> hooray!
08:28:54 <copumpkin> can't wait :D
08:29:13 <byorgey> copumpkin: most of the information from last year's webpage should still be accurate, if you just change the dates and so on
08:29:30 <byorgey> we will try to get a new page up soon
08:29:41 <ccasin> yes - hacphi will be wonderful and everyone should come :)
08:39:16 <apfelmus> byorgey: Hehe, ok. Thanks!
08:39:41 <copumpkin> ccasin: if _everyone_ came, would you be able to handle it? :P
08:40:08 <djahandarie> When is the date?
08:40:36 <copumpkin> can't remember, end of july or june or something
08:40:43 <ccasin> copumpkin: we'll find a way :)
08:41:17 <ccasin> djahandarie: July 29-31
08:42:09 <djahandarie> Hmm, I could go
08:43:10 <ccasin> you should come, it will be fun!  byorgey sent a brief announcement to the list last week but we'll have a more complete one with all the details in the next month or two
08:43:38 <djahandarie> Maybe this way I can bug byorgey to finish his typekind stuff in real life... >=)
08:43:51 <copumpkin> lol
08:43:56 <copumpkin> I'm sure he's just itching for people to do that
08:44:08 <dankna> ooh, I'll put it on my calendar.  dunno if I can go yet.
08:44:09 <copumpkin> more constructively, you could help him with it at the hackathon!
08:44:52 <dankna> are there going to be nametags that tell us everyone's irc name so we can actually recognize people?  haha
08:45:15 <djahandarie> I don't know if I could, I might be petrified by looking at the GHC source, I hear it's scary
08:45:23 <dankna> it is scary
08:46:23 <djahandarie> I recall him saying something about having a version merged with HEAD, but I don't think he ever made that public
08:47:09 * djahandarie gone
08:47:24 <revenantphx> I have a new goal for a bit.
08:47:36 <revenantphx> I want to try to get incremental (packet) parsing working in C :\.
08:47:43 <mm_freak> is there an easy way to compose Enumeratees?
08:47:44 <revenantphx> Like, asynchronous, non-blocking.
08:47:54 <revenantphx> mm_freak: >=== and ===<
08:47:58 <revenantphx> and $$ I think.
08:48:04 <revenantphx> er wait, thats for enumerators
08:48:07 <mm_freak> revenantphx: in the 'enumerator' package
08:48:22 <hpc> revenantphx: i read that as C:\ ans was confused
08:48:29 <Igloo> jmcarthur: We no longer support 10.5 in the sense of it being a "tier 1 platform"
08:48:31 <mm_freak> yes, and that's (<==<) and (>==>)
08:48:46 <revenantphx> mm_freak: there are also >>== and ==<<
08:48:50 <jmcarthur> Igloo: ah, i see. thanks for clarifying
08:49:14 <revenantphx> You can still use those of course, since the type of an enumeratee is Step -> Iteratee
08:49:43 <revenantphx> You'll see Step -> Iteratee in the signatures for >>==, ==<<, $$, >==> and <==<
08:50:47 <mm_freak> revenantphx: yes, but i don't see how i can /compose/ enumeratees…  i can only see how to apply cascaded enumeratees 
08:50:54 <revenantphx> Ah... I see.
08:51:14 <jmcarthur> i still don't have a great sense of the semantics of iteratees
08:51:17 <mm_freak> the pattern is:  joinI $ enumee1 $$ joinI $ enumee2 $$ iteratee
08:51:25 <revenantphx> jmcarthur: me neither, but they start making sense a bit.
08:51:40 <revenantphx> Slowly. Like most haskell things.
08:51:41 <mm_freak> i can write a function Iteratee -> Iteratee that way, but not a new Enumeratee
08:52:01 <revenantphx> Well, remember runIteratee is Iteratee -> Step
08:52:03 <jmcarthur> i mean i have an operational sense of it, but that doesn't really help me reason about the code
08:52:13 <revenantphx> But yeah, I don't know how to compose Iteratees.
08:52:19 <revenantphx> jmcarthur: the yesod posts were good.
08:52:22 <mm_freak> revenantphx: yeah, but you know, that's dirty =)
08:52:25 <revenantphx> Still, really complex XD.
08:52:27 <jmcarthur> yeah, i've read them a bit
08:52:32 <revenantphx> mm_freak: then abstract is out yourself :3
08:52:45 <jmcarthur> but all explanations are operational in nature. i'd love something a bit more denotational
08:52:49 <mm_freak> i'll go with Iteratee -> Iteratee for now
08:53:03 <revenantphx> http://docs.yesodweb.com/blog/enumerators-tutorial-part-3
08:53:08 <revenantphx> In the end it says "You can always compose multiple enumeratees together, such as in http-enumerator."
08:53:14 <revenantphx> Maybe that's worth taking a look at?
08:53:30 <Twey> Isn't >> compose for iteratees?
08:53:40 <revenantphx> >>==
08:53:53 <revenantphx> er, ==<<
08:54:04 <revenantphx> (or alternatively $$ is a synonym) 
08:54:14 <revenantphx> You know...
08:54:40 <revenantphx> I find it painful to work in a language without being able to define infix functions, and space applied functions :(
08:55:02 <revenantphx> Damnit Haskell.
08:55:29 <Twey> We warned you :þ
08:55:43 <revenantphx> Well, it gave me some ideas for implementing my own language :).
08:55:58 <revenantphx> The idea in my head has so far developed to "C with first-class functions"
08:56:00 <revenantphx> >_>
08:56:03 <Twey> Yeah, we all go through that phase :þ
08:56:05 <awesomehaskell> Which version of haskell is more stable and offers more feature ghc for windows or linux
08:56:16 <revenantphx> They
08:56:20 <Zao> awesomehaskell: Eh?
08:56:23 <revenantphx> They're as far as I know ,equivalent, but
08:56:29 <awesomehaskell> ok. :)
08:56:32 <revenantphx> I generally find working in a cygwin environment or such is painful on Windows.
08:56:50 <sipa> revenantphx: C with first class functions, isn't that ML?
08:56:53 <xplat> ghc for linux is better supported even though half the compiler writers work at msr :)
08:56:58 <Zao> awesomehaskell: The differences will be in libraries that either out of necessity or lazyness require platform dependent dependencies or a unixy environment to build in.
08:57:01 <revenantphx> I would seriously recommend using a Linux environment if only because more developers support it as a platform.
08:57:12 <revenantphx> And a lot of useful libraries are unixy bindings, yeah.
08:57:18 <revenantphx> sipa: >_>
08:57:21 <awesomehaskell> super
08:57:25 <awesomehaskell> xD
08:57:30 <mm_freak> Twey: composing iteratees is done with (>>=) or (>>==)
08:57:39 <xplat> even the RTS works better on linux than windows
08:57:39 <mm_freak> depending on whether you want to change the input type along the way
08:57:45 <xplat> at least in 6.x
08:57:50 <revenantphx> sipa: And no, I'd use C syntax and such. Kind of a dialect thing.
08:58:21 <Twey> mm_freak: What's >> then?
08:58:30 <revenantphx> I'd also add better support for working with raw data, something like erlangs bit-twiddling utilities maybe.
08:58:30 <Twey> revenantphx: Icky
08:58:30 <mm_freak> Twey: the usual (>>)
08:58:34 <xplat> >> is compose-and-ignore-left-result
08:58:42 <Twey> Right
08:58:45 <mm_freak> Twey: remember that (Iteratee a m) is a monad
08:58:51 <Twey> That's what I thought
08:58:52 <mm_freak> so you have (>>=) and (>>)
08:58:59 <revenantphx> You can't use >> and >>= to compose iteratee's of different types though.
08:59:02 <Twey> Oh, >> would ignore the output from the last one?
08:59:12 <revenantphx> >>== and ==<< can be used to compose iteratees with different input/output types.
08:59:14 <sipa> no, from the first one
08:59:18 <Twey> Heh
08:59:22 <Twey> ‘Last’ as in ‘previous’
08:59:25 <Twey> Thank you, English >.>
08:59:27 <mm_freak> Twey: the "result" (it's not exactly an "output" as in iterHandle)
08:59:29 <sipa> haha
08:59:51 <sipa> << ignores the result of its left argument
09:00:01 <revenantphx> Dear English, (•_•)┌║┐
09:00:01 <sipa> unambiguous now? :)
09:00:11 <sipa> >> i mean
09:00:12 <Twey> mm_freak: The tokenised value, right?
09:00:12 <sipa> damn
09:00:17 <Twey> Or list thereof, rather
09:00:26 <Twey> sipa: Haha
09:00:26 <jacobian> butlast in haskell? 
09:00:43 <Adamant> revenantphx: no good. English will absorb that and make it it's own.
09:01:09 <xplat> revenantphx: you should use the rounded box for the left/inner/pinky side
09:01:11 <revenantphx> Brave words. I've heard them before, from thousands of species across thousands of worlds, since long before you were created. But, now they are all Anglo-Saxonized. 
09:01:18 <Twey> And then assign it five extra meanings
09:01:23 <revenantphx> You will be assimilated into English.
09:02:07 <mm_freak> Twey: an iteratee is essentially just a consumer…  the input is the "tokenized" value (it's not really tokenized, but just enumerated)
09:02:17 <mm_freak> Twey: the output is whatever your computation does with that value
09:02:29 <mm_freak> the result ;)
09:02:48 <Twey> *nod*
09:02:51 <mm_freak> writing iteratees is really very easy
09:02:56 <xplat> Twey: at least one of which is a direct antonym of one of the others
09:03:06 <mm_freak> if you've ever written a monadic parser, then you understand the general idea
09:03:07 <Twey> xplat: Of course
09:03:15 <Twey> I sort of get iteratees in theory
09:03:31 <Twey> I just don't have the relation to the implementation down that well
09:03:44 <Twey> I think I probably need to use them a bit
09:03:49 <mm_freak> Twey: my impression is that you can only get iteratees and related concepts by writing real code
09:03:55 <Twey> Yeah
09:04:15 * Twey allocates some time to fiddling around with them in GHCi.
09:04:24 <mm_freak> Twey: whenever you're tempted to create lists, create enumerators instead
09:04:31 <mm_freak> GHCi won't make you happy
09:04:38 <xplat> iteratees are kinda like parser combinators on steroids
09:04:40 <mm_freak> you really need to write actual programs
09:05:36 <xplat> except out of the box they don't come with all the recognition stuff that PCs have, but you could add it if you wanted
09:05:57 <mm_freak> Twey: writing network programs using iteratees is actually very educating and funny, too
09:06:56 <Philippa> um. If it doesn't recognise stuff, how is it like a parser combinator?
09:07:33 <xplat> because they combine in similar ways
09:07:33 <Philippa> oh, right, it's literally "thing that consumes" and nothing else
09:09:07 <mm_freak> Philippa: the attoparsec-enumerator package turns a parser into an iteratee in the real sense, i.e. it really becomes an incremental parser
09:09:14 <mm_freak> and the code is actually very short
09:09:45 <xplat> the main reason you would wrap parser combinators rather than just writing recognizer iteratees to use directly is that PCs will handle the backtracking for you while iteratees would consider it a pitfall due to the possibility to leak space
09:10:03 <Twey> mm_freak: GHCi usually makes me happy.  I can't think of a good intro project, at the moment.
09:10:41 <Philippa> I should have a play with them sometime. Right now I'm working on yet another parsing lib though
09:10:51 <Philippa> (and yes, it does have reasonably valid grounds for existing)
09:11:12 <Twey> What grounds are those?
09:11:25 <Philippa> it can do stuff I can't make an existing lib do
09:11:47 <mm_freak> xplat: for context-free grammars, iteratees are just fine
09:12:00 <Philippa> (it's built around a different grammar formalism, power stems from there)
09:12:03 <xplat> Twey: that was good for about 0.67 bits, eh?
09:12:28 <mm_freak> Philippa: like what?
09:12:37 <Twey> What grammar formalism?
09:12:55 <Philippa> mm_freak: like work out for itself where backtracking's needed or otherwise without any annotations
09:13:35 <Philippa> (and no, I don't mean "backtrack everywhere", I mean if you feed it something that's LL(1) it won't even bother setting up the backtrack mechanisms)
09:13:44 <Twey> Neat
09:14:25 <xplat> ah, that is much nicer than most of these
09:14:43 <jmcarthur> sounds cool. can't wait to see it
09:15:36 <xplat> must be applicative/arrow rather than monaidic
09:15:48 <Philippa> jmcarthur: that could be a problem because you know what I'm like at getting stuff done :-) But yeah
09:16:00 <mm_freak> Philippa: look at polyparse
09:16:04 <Philippa> xplat: yeah, it's applicative with some additional restrictions
09:16:33 <xplat> but which grammar formalism?
09:16:40 <Olathe> @hoogle Int -> [a] -> [a]
09:16:41 <lambdabot> Prelude drop :: Int -> [a] -> [a]
09:16:41 <lambdabot> Prelude take :: Int -> [a] -> [a]
09:16:41 <lambdabot> Data.List drop :: Int -> [a] -> [a]
09:16:57 <Philippa> xplat: whatever the name for the grammatical version of a visibly pushdown language is
09:17:14 <Olathe> @pl \n -> concat . replicate n
09:17:14 <lambdabot> (join .) . replicate
09:17:30 <FUZxxl> @hoogle Data.Map a b -> c -> (b -> c) -> a -> c
09:17:31 <lambdabot> Parse error:
09:17:31 <lambdabot>   --count=20 "Data.Map a b -> c -> (b -> c) -> a -> c"
09:17:31 <lambdabot>                  ^
09:17:42 <FUZxxl> @hoogle Data.Map.Map a b -> c -> (b -> c) -> a -> c
09:17:42 <lambdabot> Parse error:
09:17:42 <lambdabot>   --count=20 "Data.Map.Map a b -> c -> (b -> c) -> a -> c"
09:17:42 <lambdabot>                  ^
09:18:08 <FUZxxl> @hoogle a -> a
09:18:08 <lambdabot> Prelude id :: a -> a
09:18:08 <lambdabot> Data.Function id :: a -> a
09:18:08 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
09:18:24 <FUZxxl> @hoogle a -> b
09:18:24 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:18:24 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:18:24 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
09:18:39 <FUZxxl> @hoogle (a,b,c) -> a
09:18:39 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
09:18:39 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
09:21:01 <xplat> visibly pushdown kind of requires a lexer to parse normal strings ...
09:21:59 <Philippa> actually it doesn't
09:22:15 <Philippa> well, depending on what your brackets look like
09:22:26 <Philippa> but even so? Not a big deal
09:22:45 <Philippa> Separate lexers end up being a good idea for a whole range of reasons
09:23:23 <pokoko222> hello haskellers, its been a while
09:23:33 <monochrom> zomg
09:23:34 <xplat> well, okay, i guess mapping a function over the string is a pretty trivial lexer, but you'd need something stronger for xml-like bracketing ...
09:23:35 <pokoko222> i just started my Algebra I course :D
09:24:00 <xplat> but it was more of an observation than a criticism
09:24:04 <Philippa> xplat: yeah, xml needs multiple stacks. But not everybody's parsing XML
09:24:07 <copumpkin> pokoko222: no AlgebraLove?
09:24:15 <pokoko222> i was wondering, how much of the proofs do you guys remember?
09:24:23 <FUZxxl> :pf '\a -> a'
09:24:26 <FUZxxl> @pf '\a -> a'
09:24:26 <lambdabot> Maybe you meant: bf pl
09:24:33 <copumpkin> @djinn a -> a
09:24:33 <lambdabot> f a = a
09:24:40 <pokoko222> i mean lot of the proofs are not intuitive, i can work them through, but i will probably not be able to do them a day after
09:24:54 <jmcarthur> you get better at it
09:24:55 <FUZxxl> @pointfree 
09:24:55 <lambdabot> Unknown command, try @list
09:25:00 <FUZxxl> @list
09:25:00 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:25:01 <xarch> @djinn a -> b
09:25:01 <lambdabot> -- f cannot be realized.
09:25:03 <copumpkin> pokoko222: don't just work through them! actually try the proofs yourself
09:25:05 <pokoko222> i ask here because lot of you people here like abstract algebra and stuff
09:25:12 <xarch> hm
09:25:13 <monochrom> I only remember proof skeletons. and even then Dijkstra's let-the-symbols-do-the-work eliminates a good portion of that.
09:25:15 <Philippa> yeah, eventually you just remember the "weird"/insightful bits
09:25:20 <Philippa> monochrom: yeah, exactly
09:25:25 <jmcarthur> it helps to try proving additional things aside from just what your lecturer is doing
09:25:25 <xarch> looks like he doesn't know how to fix
09:25:31 <xarch> @djinn (a -> a) -> a
09:25:32 <lambdabot> -- f cannot be realized.
09:25:38 <pokoko222> copumpkin you mean like not even looking at the solution, like getting myself to the limit of thinking about it?
09:25:40 <FUZxxl> @pl \a-> a
09:25:41 <lambdabot> id
09:25:46 <xplat> remembering the details of proofs is what agda/coq is for :)
09:25:47 <pokoko222> some are so not intuitive you know
09:26:05 <FUZxxl> Is there a special rooms just for to use lambdabot?
09:26:12 <copumpkin> pokoko222: yeah, I mean that
09:26:13 <jmcarthur> FUZxxl: try a privmsg session
09:26:16 <kmc> FUZxxl, you can private-message her
09:26:18 <xarch> /query lambdabot
09:26:23 <jmcarthur> FUZxxl: /msg lambdabot blah blah blah
09:26:23 <pokoko222> i do tend to remember tecnuiqes very well, and general ideas but details of proofs as xplat said hmm...
09:26:38 <monochrom> I do have some talent of noticing the proof skeleton and not drowned in detailed steps.
09:26:53 <pokoko222> monochrom ah very well said
09:27:00 <monochrom> but I guess I learned that skilled from programming.
09:27:01 <jmcarthur> pokoko222: you don't really want to memorize a proof. you want to master the kind of thinking that went into creating it, and you can rederive the proof later if you need to
09:27:07 <xplat> copumpkin: speaking of which, i am getting tempted to help with your functors, but i probably don't have enough free RAM on this box to fully test the proofs :I
09:27:30 <copumpkin> xplat: yay! it's actually not too ram-intensive compared to previous efforts
09:27:33 <copumpkin> the irrelevance helps a lot
09:27:38 <copumpkin> and using a recent agda build doe stoo
09:27:44 <copumpkin> xplat: how much RAM do you have?
09:28:04 <jmcarthur> it's amazing how much ram agda uses :\
09:28:30 <copumpkin> I have yet to encounter something I haven't been able to check in this library
09:28:34 <xplat> copumpkin: i think i have 2G here but there's a lot of other ram-hoggish stuff
09:28:38 <copumpkin> maybe I'm just doing doing complicated-enough proofs
09:28:56 <copumpkin> xplat: ah okay, that might be tight, but just stay out of the arrow category or NT proofs and you'll probably be fine
09:29:14 <pokoko222> i remember when you guys told me proofs are same as programming, heh yeah lot of knowledge applies here 
09:29:15 <copumpkin> anyway yeah, I welcome any changes or additions :)
09:29:46 <pokoko222> jmcarthur rederive is not same as remember?
09:30:08 <copumpkin> pokoko222: not at all. I don't know the quadratic formula by heart but I know how to figure it out when I need it
09:30:09 <jmcarthur> pokoko222: it's a matter of understanding vs. rote memorization, is all
09:31:12 <pokoko222> copumpkin heh i know that too but that is so easy and intuitive compared to this algebra stuff i do now
09:31:29 <jmcarthur> that is, in fact, the purpose of a proof. knowing several facts about a system is much more boring than knowing how to derive facts about a system
09:31:36 <monochrom> things like "from the group axioms, prove that inverses are unique" are hard to either remember or create yourself, but they are rare and not too important. but things like the first isomorphism theorem, those tend to write themselves.
09:31:37 <copumpkin> you just need to get to the point where you have that intuition for manipulating abstract quantities and structures
09:32:02 <revenantphx> You may spend your entire life trying.
09:32:10 <copumpkin> pokoko222: if you think of these proofs as constrained programming, it's a puzzle
09:32:41 <copumpkin> "I only have a handful of functions (the axioms of whatever structure you're working on) to build this program I need and I need to combine them in a clever way to get the result I want"
09:33:14 <jmcarthur> yeah, some people aren't made for it, some people don't find it as interesting as others, and some people just never see the point in the first place (typically those who believe that math should only be "practical"). for those who don't fall into those categories, though, derivation is pretty cool
09:33:18 <monochrom> I played a lot with Lego when I was a child. Hope it helps.
09:33:35 <copumpkin> yeah, lego was fun
09:34:56 <pokoko222> lol
09:34:59 <revenantphx> I got so pissed off at calculus trying to derive Q = Q0(1-e^(-t/RC)) for RC circuits from Kirchoff's voltage law.
09:35:07 * xplat types cabal install Agda, braces himself ...
09:35:13 <revenantphx> (this was because I didn't know about integration factors)
09:35:31 <revenantphx> (so I was really frustrated when it kept integrating to constants)
09:35:43 <copumpkin> xplat: yay
09:35:52 * edwardk watches xplat become dependently typed.
09:35:54 <xplat> speaking of circuits, impedance is such a brilliant hack
09:35:55 <copumpkin> xplat: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
09:36:17 <edwardk> The visuals are something like the scene in Tron, where Flynn gets sucked into the computer.
09:37:05 <jmcarthur> omg those isometric algorithms are awesome
09:37:07 <edwardk> Just make sure you defined yourself as codata, that way you'll be productive and can live forever, otherwise you're practically guaranteed to terminate.
09:37:14 * roconnor sees xplat fibrated
09:37:31 <jmcarthur> isomorphic*
09:37:42 <jmcarthur> yay for hollywood lingo
09:37:44 <pokoko222> jmcarthur sometimes i feel like i can't wait to get done with this algebra proofs stuff subject just to continue on the REAL stuff, programming, i am in love with computer vision now .... i guess i am in your practical group of people
09:37:53 <edwardk> That of course assumes that counter to agda culture that someone actually runs you after you typecheck.
09:38:00 <xplat> in the fourier transform of the circuit, capacitance and inductance are just frequency-dependent, imaginary resistance
09:38:10 <roconnor> edwardk: why would you run code that is typechecked?
09:38:24 <jmcarthur> pokoko222: well, you're not in that group as long as you *recognize* where the fun might come from, even if you don't appreciate it yourself
09:38:41 <revenantphx> roconnor: lol.
09:39:19 <jmcarthur> pokoko222: but actually, if you are principled enough about your programming, you're writing proofs anyway ;)
09:39:36 <pokoko222> oh i feel very good about my programming
09:39:45 <revenantphx> I'm trying to work out a C based parsing engine... with some fun involved.
09:40:04 <pokoko222> relative to math that is, i am far from master
09:40:13 <edwardk> roconnor: clearly such behavior is irrational, once you have solved the general problem there is no reason to look at any particular answer. just trust that your compiler is consistent.
09:40:18 <revenantphx> Namely, I want it to store the incoming data in a sparse buffer (already wrote this), and then return blocks (apple extension to C, they're closures) that are used as generators to produce the fields of the packet.
09:40:25 <jmcarthur> pokoko222: what i mean is that the two tasks are literally the same
09:40:33 <revenantphx> And then when they terminate they report somehow that that portion of the data is no longer useful
09:40:39 <xplat> at runtime you can only run things that won't need to be typechecked afterward.  boring!
09:41:00 <revenantphx> Stuff's all haskelly and lazy/deferred.
09:41:28 <roconnor> edwardk: I remember feeling weird about running my trig functions in Coq after proving they were correct.  I mean, I knew the answer was going to be right.
09:41:31 <edwardk> think of runtime as a form of laziness, deferring until later all the stuff you don't want to compute up front, then perhaps it is more palatable ;)
09:42:05 <roconnor> edwardk: And I really didn't care what the sine of 1 radian is.
09:42:30 <kmc> anyone implemented "patience diff" in Haskell?
09:42:34 <jmcarthur> pokoko222: a correct program is a proof of the program's specification. if your programming language is simple enough, it even *looks* like taking a system with axioms and deriving properties about the system
09:42:36 <kmc> http://bramcohen.livejournal.com/73318.html
09:43:19 <xplat> kmc: i saw you ask that earlier and started wondering how much easier the LCSS step gets without duplicates
09:43:44 <kmc> xplat, i just coded the lcs-by-patience-sort part of it
09:44:18 <xplat> kmc: oh, then you're nearly done
09:44:24 <jmcarthur> roconnor: i get that same feeling
09:44:26 <kmc> and there were a few places where ignoring duplicates made it simpler
09:44:36 <kmc> but i didn't try the with-duplicates approach so i don't know in the end how much harder it is
09:45:23 <edwardk> kmc i implemented the patience sort, but not the full diff
09:45:25 <jmcarthur> it doesn't even feel like a consistency check. it just feels like wasted work
09:45:26 <kmc> xplat, i guess? it seems like the rest of it will be kind of annoying to do in a pure-functional way
09:45:38 <kmc> lcs was like 14 lines
09:45:45 <kmc> i'm using IntMap as a priority queue of sorts
09:45:50 <kmc> which is probably not ideal
09:46:09 <kmc> but it seems fast enough
09:46:23 <xplat> kmc: the hardest remaining part is eliminating duplicates, the rest is trivial
09:46:29 <edwardk> kmc: i have a heaps package which provides a nice priority queue
09:47:21 <kmc> cool
09:47:27 <kmc> the operations aren't quite priority-queue
09:47:29 <kmc> that i need
09:47:35 <edwardk> *nods*
09:47:57 <kmc> i basically need IntMap.split, plus the ability to alter a value while also moving it from one key to another
09:48:00 <xplat> maybe i mean most annoying rather than hardest, it's probably like 2 lines
09:48:25 <edwardk> kmc: you look at just using a fingertree?
09:48:33 <kmc> not directly, no
09:49:12 <edwardk> easy/cheap to split, easy to add priority queue machinery, nice asymptotics. (cruddy constants, but you can't have everything)
09:53:48 <xplat> edwardk: what are the arguments to histo again?
09:54:39 <xplat> histomorphism seems perfect for uniq -d ...
09:54:55 <edwardk> histo :: Functor f => (f (Stream f a) -> a) -> Mu f -> a
09:55:56 <edwardk> where Stream is an f-branching stream, so you can get the annotated tree of all the responses you gave below
09:56:26 <chrisdone> anyone got a pdfinfo lib for haskell? was thinking of just piping to pdfinfo but if someone already has a haskelly interface already.. I need page size and page numbers
09:58:56 <copumpkin> omg it's chrisdone 
09:58:58 <xplat> if only they'd though to write type [a] = Mu (Either () `O` (,) a) ...
09:59:19 <chrisdone> omgo it's pumpkin
10:00:24 <dolio> Yes, In (O (Right (x,xs))) is superior to (x:xs).
10:02:17 <chrisdone> /o/
10:02:22 * chrisdone slaps copumpkin's head
10:02:42 <xplat> dolio: bah, anyone who wants to do direct recursion deserves to have to type that
10:02:51 <dolio> :)
10:03:01 <dolio> Actually, if you use SHE, it wouldn't be that bad.
10:03:08 <dolio> With its pattern aliases.
10:08:22 <xplat> i wonder if with type families it would be possible to make all those work on a Recursive typeclass
10:09:08 <xplat> Level (Mu f) = f
10:23:47 <chrisdone> the documentation for readProcess says
10:23:48 <chrisdone>   > readProcess "date" [] []
10:23:48 <chrisdone>   Right "Thu Feb  7 10:03:39 PST 2008\n"
10:23:50 <chrisdone> but 
10:23:52 <chrisdone> :t readProcess
10:23:53 <lambdabot> Not in scope: `readProcess'
10:24:14 <chrisdone> well, IO String
10:24:43 <dmwit> I'm going to bet the type is more correct than the documentation.
10:25:13 <dmwit> By the way, my documentation doesn't say that.
10:25:15 <xplat> that documentation was probably pasted from ghci
10:25:23 <dmwit> http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:readProcess
10:25:29 <dmwit> No "Right" in there.
10:25:48 <xplat> oh, the Right ... hm, yeah
10:26:09 <chrisdone> ah, I'm on an old doc
10:26:13 <chrisdone> serves me right for using google
10:26:40 <chrisdone> @google hackage process
10:26:41 <lambdabot> http://hackage.haskell.org/package/process-1.0.1.3
10:26:41 <lambdabot> Title: HackageDB: process-1.0.1.3
10:26:45 <chrisdone> :[
10:28:22 <monochrom> old doc doesn't tell new tricks
10:28:57 <chrisdone> hehe
10:29:39 <xplat> "An old doc can't teach you new tricks."
10:30:41 <chrisdone> with the exception of the kama sutra. *bows*
10:32:19 <monochrom> haha
10:45:34 <xplat>                                                                                In
10:47:35 <xplat> In fact, we shall use the very strong system of dependent types of the Agda language[1,19] which is based on Martin-Löf type theory [14,15,16,18]. In this language we can express more or less any conceivable property! (We have to say “more or less” because Gödel’s incompleteness theorem sets a limit for the expressivity of logical languages.)
10:48:12 <xplat> this grave misunderstanding of Gödel's theorem makes me doubt the usefulness of this tutorial
10:48:43 <accel> is this Godel's incompleteness theorem
10:48:45 <accel> it's referring to?
10:48:55 <mauke> wat
10:49:09 <accel> mauke: I'm trying to confuse you since you kicked me lst time
10:49:11 <accel> *last*
10:49:30 <accel> http://en.wikipedia.org/wiki/Godel%27s_incompleteness_theorem
10:49:32 <mauke> you win this round
10:51:21 <Blkt> good evening everyone
10:56:15 <kmc> hahaha accel
10:56:47 <augur> are there infinity Int values?
10:56:52 <DevHC> is anyone here experienced in FFI?
10:57:02 <hpc> augur: there aren't...
10:57:05 <augur> shame.
10:57:24 <hpc> there's Integer
10:57:30 <mauke> still no infinity
10:57:31 <DevHC> but there are still no infinity values
10:57:41 <dmwit> augur: You're guaranteed 2^29 Int values (I think... might be 2^28), though on my machine GHC gives me a 64-bit Int.
10:57:47 <augur> ok
10:58:06 <jaj> > 1/0
10:58:07 <lambdabot>   Infinity
10:58:07 <mauke> .oO( machinteger )
10:58:13 <augur> im just curious, because it would make certain folds really nice if there was a lowest lower bound for integers
10:58:19 <xplat> Integer has infinitely many values, at least if you run it on a machine with an infinitely wide address bus
10:58:30 <mauke> augur: there is (for Int)
10:58:35 <augur> mauke: oh?
10:58:41 <mauke> minBound
10:58:44 <augur> ahhh
10:58:45 <kmc> Int is guaranteed to have 2^30 values (-2^29 to 2^29-1)
10:58:57 <hpc> > minBound :: Int
10:58:57 <lambdabot>   -9223372036854775808
10:58:57 <kmc> and on GHC it's actually a machine word, so will have 2^32 or 2^64 values
10:59:07 <xplat> all ordered types with a minimum value have the minBound function
10:59:13 <xplat> or they should, anyway
10:59:15 <accel> kmc: http://bit.ly/eH1OKN :-)
10:59:16 <mauke> s/function/value/
10:59:21 <augur> nifty.
10:59:22 <augur> ok
10:59:22 <xplat> it's from the Bounded typeclass
10:59:45 <c_wraith> one could argue typeclass values are functions from type to value. >_>
10:59:49 <xplat> mauke: er, yes
11:00:05 <dmwit> You can always add a distinct minimal element, as well. (With Maybe, or with the more specific types whose names I always forget for adding minimal and maximal elements.
11:00:08 <dmwit> )
11:00:09 <xplat> although, yeah, what c_wraith said.  or from instance to value, anyway
11:00:10 <kmc> GHC's Integer on a 64-bit system is limited to a measly (2^64)^(2^64) values
11:00:12 <kmc> pathetic
11:00:43 <burp> > (2^64)^(2^64)
11:00:52 <kmc> DevHC, you can just ask your FFI question
11:00:57 <xplat> that's ... not gonna wrok
11:00:58 <lambdabot>   thread killed
11:01:02 <burp> woops
11:01:03 <DevHC> i once did, no answer :P
11:01:05 <DevHC> but here goes:
11:01:10 <accel> RWH
11:01:10 <kmc> oh, what was it?
11:01:13 <mauke> accel: except "Gödel’s incompleteness theorem sets a limit ..."  "is this Godel's incompleteness theorem?" is not an application of logic
11:01:51 <xplat> mauke: all programs are logic, even Eliza :)
11:02:12 <burp> it's about 10^10^21
11:02:35 <xplat> what?  that's not even a whole googolplex
11:02:45 <Peaker> Agda/et-al allow infinitely many axioms, don't they?  So they don't get hit by Godel?
11:03:01 <roconnor> xplat: Tarski's theorem arguably puts a limit on the expressivity of logic, and argueably Tarski's theorem is a corrolary of Goedel's theorem.
11:03:03 <accel> how about this: http://bit.ly/gYdsFg
11:03:32 <burp> @faq can haskell handle a whole googolplex?
11:03:32 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:36 <xplat> Peaker: they do if the axioms are recursively enumerable, although it may take a little more work to show
11:03:41 <DevHC> in a haskell file i have: foreign export ccall "hs_test_import_dynamic" testImportDynamic :: FunPtr (CInt -> IO ()) -> IO ()
11:03:41 <DevHC> in a C file i have: static void passed_one(int x);, and also: hs_test_import_dynamic(&passed_one);
11:03:41 <DevHC> this produces the following warning: warning: passing argument 1 of 'hs_test_import_dynamic' from incompatible pointer type
11:03:43 <copumpkin> > 10^100
11:03:46 <DevHC> WHY is that warning given?
11:03:47 <lambdabot>   mueval-core: Time limit exceeded
11:03:49 <roconnor> @faq can haskell express a truth predicate?
11:03:49 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:52 <roconnor> :O
11:03:53 <accel> @faq can haskell compute undecidable languages?
11:03:53 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:53 <copumpkin> > 10^(10^100)
11:03:58 <Peaker> xplat, everything on a computer is recursively enumerable?
11:03:59 <lambdabot>   mueval: ExitFailure 1
11:04:32 <xplat> Peaker: yes
11:04:45 <robryk> DevHC: have you tried looking at the C code which causes the warning?
11:04:58 <mauke> DevHC: what does the declaration of hs_test_import_dynamic look like?
11:05:01 <DevHC> i created both codes
11:05:14 <DevHC> GHC declares hs_test_import_dynamic
11:05:21 <robryk> ah, sorry, read it wrong
11:05:30 <mauke> DevHC: where and how?
11:05:35 <DevHC> extern void hs_test_import_dynamic(HsFunPtr a1);
11:05:38 <xplat> roconnor: okay, i have to award you a No-Prize for that one
11:05:42 <DevHC> in ft_stub.h
11:05:56 <roconnor> what is a No-Prize?
11:05:57 <robryk> and how is HsFunPtr defined?
11:06:05 * mauke ponders
11:06:14 <kmc> whatever HsFunPtr is, it's not specific to the type CInt -> IO ()
11:06:16 <hpc> > No-Prize
11:06:17 <lambdabot>   Not in scope: data constructor `No'Not in scope: data constructor `Prize'
11:06:21 <kmc> so i think this is something you basically have to live with
11:06:22 <Peaker> xplat, but if you're free to add א0 axioms to solve א0 problems, then you can't possible hit a Godel limit?
11:06:47 <DevHC> robryk: i have no idea
11:06:53 <kmc> it seems that, when generating a C stub for exporting a function that takes a function pointer, GHC doesn't take that function pointer argument in a type-safe way
11:07:11 <robryk> DevHC: so do gcc -E ft_stub.h | grep HsFunPtr
11:07:25 <xplat> back in the Marvel Comics letters columns, if a reader wrote in and explained some possibly-twisted interpretation where a mistake pointed out by a previous letter-writer could be considered really-not-a-mistake, they were not awarded a prize
11:07:34 <DevHC> lol @ "gcc -E ft_stub.h"
11:07:35 <xplat> so they were awarded a No-Prize instead
11:07:51 <roconnor> xplat: :)
11:08:03 <robryk> DevHC: why?
11:08:09 <robryk> it precompiles and outputs precompiled code
11:08:12 <roconnor> xplat: ya, that sounds about right.
11:08:34 <DevHC> i'll need help doing that
11:08:43 <DevHC> there's this line in ft_stub.h: #include "HsFFI.h"
11:08:52 <DevHC> i use ghc --make to "make that file appear"
11:09:03 <DevHC> but otherwise i don't know where that file comes from?
11:09:16 <robryk> oh, okay. wait a moment
11:09:17 <xplat> Peaker: how do you know which axioms to add?
11:09:55 <Peaker> xplat, at worst, I add the thing I'm searching for as an axiom :)
11:10:02 <DevHC> oh, it's not generated by ghc, i found it in /usr/... :O
11:10:03 <robryk> typedef void (*HsFunPtr)(void); /* this should better match StgAddr */
11:10:07 <robryk> strange
11:10:19 <Peaker> (btw: finally having a Hebrew layout comes handy in an English conversation :)
11:10:19 <DevHC> typedef void			(*HsFunPtr)(void); /* this should better match StgAddr */
11:10:22 <xplat> Peaker: but how do you know that won't make your system inconsistent?
11:10:47 <robryk> either we consciously use wrong pointers because they are the same, or something strange has happended
11:10:54 <robryk> i would wager first case
11:11:09 <Peaker> xplat, ah, but we get to choose potential inconsistency over incompleteness
11:11:25 <DevHC> well, it doesn't cause any errors during runtime
11:12:05 <robryk> so the question for ffi-knowledgeable individuals is whether we treat all funptrs as void (*ptr)(void)
11:14:29 <kmc> seems like it
11:14:58 <DevHC> the question is more like: WHY?
11:15:07 <robryk> simplicity
11:15:12 <chrisdone> :t bi g f = g . f . g
11:15:15 <lambdabot> parse error on input `='
11:15:18 <xplat> Peaker: Gödel's Theorem does not limit the completeness of inconsistent systems
11:15:21 <robryk> you can have one type for pointers to functions
11:15:22 <chrisdone> :t let bi g f = g . f . g in bi
11:15:23 <lambdabot> forall a b. (a -> b) -> (b -> a) -> a -> b
11:15:23 <chrisdone> can't get enough of this function
11:15:43 <chrisdone> great for working at the ends of strings
11:15:49 <DevHC> then why not simpy void* to avoid warnings?
11:16:06 <robryk> because it does not necessarily work on strange platforms afaik
11:16:36 <robryk> i remember that casting function pointer to data pointer can be harmful ; don't remember exactly why
11:16:48 <robryk> and the comment by that typedef may be a clue
11:16:53 <Peaker> xplat, yeah, I know. I'm not sure why Godel is cited in the Agda case, isn't it just the same problem as with any math system?
11:16:59 <mux> well, it's illegal in C to cast a function pointer to a data one
11:17:22 <monochrom> in the 8086 days, code pointer and data pointer could be different size, in fact different spaces.
11:17:30 <DevHC> hmm
11:17:39 <mux> but commonly abused, see dlsym()
11:17:42 <mauke> all pointer types can be different sizes
11:17:57 <mux> IIRC, function pointers and data points are actually different under ia64
11:18:41 <monochrom> the "tiny", "small", "medium", "large", "huge" models :)
11:18:42 <xplat> there's no such thing as ia65
11:18:47 <xplat> *ia64
11:18:57 <zygoloid> there's no such thing as a harvard architecture :)
11:18:59 <xplat> monochrom: ah, the bad old days
11:19:04 <mux> there's no spoon
11:19:10 <kmc> @hackage spoon
11:19:10 <lambdabot> http://hackage.haskell.org/package/spoon
11:19:20 * mux kicks hackage in the nuts
11:19:26 <kmc> there are lots of modern harvard architecture chips
11:19:31 <kmc> like AVR microcontrollers
11:19:48 <xplat> and DSPs
11:20:00 <kmc> though i don't know how function pointers work in avr-gcc
11:20:59 <xplat> there are lots of processor architectures that make function and data pointers incompatible
11:21:15 <mux> 
11:21:17 <xplat> but ia64 isn't a processor architecture, it's a kind of paperweight
11:21:34 <mux> whatever you want to call it, it exists, and there are OSes running on it
11:22:41 <kmc> the only ia64 system i've seen was only like 6U and 50 pounds
11:22:42 <xplat> i call those 'paperweight-heating spells'
11:22:52 <kmc> so i would have to say that s390 is a better architecture for paperweights
11:22:59 <mux> I have access to an itanium 2 beast
11:23:16 * mux tries to remember the hostname
11:24:44 <mux> heh
11:24:48 <mux> FreeBSD pluto2.freebsd.org 9.0-CURRENT FreeBSD 9.0-CURRENT #6 r218667: Sun Feb 13 20:30:04 UTC 2011     marcel@pluto2.freebsd.org:/usr/obj/tank/usr/src/sys/PLUTO2  ia64
11:25:16 <mux> CPU: McKinley (900 Mhz Itanium 2)
11:25:49 <sm> spoon looks handy
11:25:49 <mux> I have no info about its weight :-)
11:26:39 <sm> http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/Control-Spoon.html makes it sound like it catches most but not all exceptions.. what would be some that it doesn't catch ?
11:27:30 <kmc> nondeterministic stuff
11:27:38 <kmc> like running out of memory
11:27:42 <mauke> infinite loops
11:27:48 <kmc> i wouldn't say "most"
11:27:57 <mauke> probably exceptions thrown from other threads
11:28:14 <kmc> it catches basically things that indicate a deterministic failure in pure computation
11:28:23 <kmc> because those are the things which "should be" Maybe instead
11:28:25 <xplat> couldn't it also fail to catch an exception if you didn't force enough of the value under the spoon before extracting things?
11:28:31 <kmc> and other stuff would break referential transparency
11:28:47 <kmc> xplat, yep, that's why "teaspoon" evaluates to WHNF, and "spoon" to NF
11:28:59 <xplat> aha
11:29:11 <xplat> and that's why it depends on deepseq
11:29:15 <sm> thanks
11:37:56 <chrisdone> http://hpaste.org/44215/pdfinfo ;)
11:39:38 <kmc> good times
11:39:41 <kmc> what are you using it for?
11:39:55 <byorgey> chrisdone: did you just write that in the last 1.5 hours?
11:40:03 <chrisdone> byorgey: sure
11:40:06 <byorgey> nice =)
11:40:09 <chrisdone> :P
11:40:10 <copumpkin> chrisdone: as you didn't use my fancy trim
11:40:30 <kmc> i like that HLint is giving hints about GHC's show output
11:40:54 <chrisdone> kmc: have a bunch of academic PDFs submitted for conferences, need to generate a proceedings, count the papers, and do some minimal validation on paper size just to help out the publication managers
11:41:01 <kmc> cool
11:41:46 <chrisdone> copumpkin: which fancy trim?
11:43:14 <augur> byorgey: ive almost got an algo to enumerate the linear lambda terms. :T
11:43:18 <joe6> has anyone thought of just porting llvm to haskell?
11:43:28 <byorgey> augur: oh, nice =)
11:43:29 <opqdonut> what do you mean?
11:43:29 <copumpkin> the un-reversey one I write in here a lot
11:43:29 * copumpkin conjures it up again
11:43:29 <copumpkin> strip = join . init . tail . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ")
11:43:29 <copumpkin> <_<
11:43:32 <joe6> instead of C++? 
11:43:50 <opqdonut> oh the actual implementation
11:43:52 <opqdonut> probably not
11:43:56 <augur> byorgey: i just need to figure out how to diagonalize it so that each term is accessible in finite time
11:44:13 <byorgey> copumpkin: what's wrong with the reversey one?
11:44:29 <chrisdone> copumpkin: haha
11:44:40 <kmc> joe6, an incredible amount of work has gone into the C++ LLVM implementation
11:44:45 <kmc> it's easy enough to use it from Haskell
11:44:47 <joe6> opqdonut, the code is pretty malleable and the architecture seems to be very good and modular. Haskell would make it so much more readable.
11:44:49 <kmc> so why reinvent the wheel?
11:44:57 <copumpkin> byorgey: it's reversey!
11:45:05 <copumpkin> byorgey: mine is less strict
11:45:56 <joe6> kmc, because it is so much harder to add target backends using C++...
11:45:56 <copumpkin> it can output stuff as soon as it transitions between space and nonspace
11:45:56 <joe6> kmc, yes, i understand the re-inventing the wheel..
11:45:56 <copumpkin> our wheel will be better
11:46:10 <joe6> copumpkin, yes, that is the reason..
11:46:12 <copumpkin> bettar, even
11:46:16 <byorgey> copumpkin: ah! so it is.
11:46:16 <byorgey> > let strip = join . init . tail . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") in take 30 . strip $ "   " ++ cycle "hello "
11:46:20 <lambdabot>   mueval-core: Time limit exceeded
11:46:42 <copumpkin> hmm
11:46:57 <byorgey> that was not what I expected
11:46:59 <copumpkin> same here
11:47:18 <byorgey> augur: check out http://hackage.haskell.org/package/control-monad-omega , perhaps?
11:47:34 <augur> nah ive got a simple diagonalization method thatll work :p
11:47:38 <copumpkin> byorgey: it works fine
11:47:39 <byorgey> ok =)
11:47:42 <copumpkin> on ghci
11:47:44 <copumpkin> it's just mueval being wonky
11:48:04 <copumpkin> even without the take 30
11:48:15 <byorgey> yes, you're right
11:48:33 <copumpkin> now, it isn't quite as succinct as the reversey way
11:48:53 <copumpkin> but I keep it tucked away in my silly haskell snippets file
11:49:24 * copumpkin should really reticulate some splines
11:49:42 <mmaruseacph2> @ap f x y z = g z
11:49:42 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
11:49:50 <mmaruseacph2> @pl f x y z = g z
11:49:51 <lambdabot> f = const (const g)
11:50:09 <mmaruseacph2> @pl f x y z = g z x y
11:50:09 <lambdabot> f = flip . flip g
11:50:31 <chrisdone_> eh, they're kicking me out at the office
11:50:31 * chrisdone_ goes home
11:50:32 <chrisdone_> ciao!
11:53:50 <copumpkin> What is the category that is used to interpret linear logic in a categorical logic sense?
11:53:55 <hpc> byorgey: cool module, bro
11:54:28 <byorgey> hpc: hm?
11:54:32 <copumpkin> (from haskell-cafe)
11:54:59 <augur> byorgey: this is untyped tho
11:55:03 <xplat> copumpkin: i remember there being a few competing interpretations
11:55:15 <augur> adding typing will be slightly harder i think
11:55:17 <copumpkin> someone just asked that on -cafe and I was curious 
11:55:33 <xplat> copumpkin: fatal: https://github.com/pumpkin/categories//info/refs download error - The requested URL returned error: 500
11:55:46 <copumpkin> maybe github is messing up?
11:56:06 <kmc> maybe you can make an interface so we can write backends in Haskell
11:56:06 <kmc> without rewriting the entire thing
11:56:07 <kmc> or maybe it's not actually that bad to reimplement
11:56:35 <byorgey> augur: but the typing is the interesting part!
11:56:46 <kmc> since llvm has standardized external formats and there are already parser / generator libraries for Haskell
11:56:52 <copumpkin> xplat: you cloned git://github.com/pumpkin/categories.git ?
11:57:05 <copumpkin> xplat: that looks like the plain old html-generating land
11:57:38 <xplat> oh, yeah, i was cloning the wrong thing
11:57:39 <hpc> byorgey: it's neat
11:58:10 <kmc> what does the LLVM C++ library give you for implementing backends
11:58:10 <aavogt> > let strip = join . init . tail . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") in take 4 . strip $ "   " ++ cycle "hello "
11:58:10 <kmc> besides data structures and a parser for LLVM bitcode?
11:58:11 <lambdabot>   "hell"
11:58:27 <byorgey> hpc: what are you referring to? control-monad-omega?  if so I agree it's very cool but I didn't write it
11:58:34 <copumpkin> that'd be luqui
11:58:36 <copumpkin> preflex: seen luqui
11:59:05 <xplat> copumpkin: wow, you've been busier than i thought
11:59:10 <mauke> huh
11:59:18 <copumpkin> xplat: a lot of those modules are empty, alas :)
11:59:24 <copumpkin> I made them cause I wanted to remember stuff I wanted to write
11:59:31 <mauke> preflex thinks it sent a reply but I don't see it
11:59:45 <copumpkin> mauke: it's a trap!
12:00:01 <mauke> preflex: version
12:00:16 * copumpkin pats preflex 
12:00:45 <xplat> does functor equality belong in Functor or Functor.Core?
12:01:39 <copumpkin> I haven't quite decided yet. I separated them at first because I had functor equality as natural isomorphism which depended on natural transformation which depended on functors, but now I got rid of that
12:02:05 <copumpkin> probably core, but I'd leave it in Functor for now just to avoid getting overwhelmed by typechecking
12:03:05 <copumpkin> also, the usual gitty workflow is to fork it on github, then clone your forked repository
12:03:08 <DevHC> FFI allows importing addresses (foreign import ccall "static myheader.h &var" var) from C as either (Ptr a) or (FunPtr a). if i use (Ptr a), then i can then peek/poke the C variable, as data, via the imported address. the obvious way to type the data as a function pointer is to use (Ptr (FunPtr a)). now, what if i import something with the other allowed general type, (FunPtr a)? well, apparently that doesn't work unless i import the address of a funct
12:03:08 <DevHC> ion (like: foreign import ccall "static math.h &sin" sin :: FunPtr (Double -> Double)). but i can do that with a static function import (ie., without the "&"). so is FunPtr allowed for "&"?
12:05:55 <DevHC> i mean, SHOULD (FunPtr a) be allowed for "&", WHY?
12:06:03 <hpc> byorgey: indeed
12:09:04 <xplat> copumpkin: to use the usual github workflow i'd have to remember my github password :I
12:09:36 <copumpkin> aw okay :)
12:10:54 <xplat> i realize it works much better that way, i used it for a while to work on my one friend's minecraft clone
12:11:16 <copumpkin> doesn't really matter :)
12:11:34 <hpc> preflex: seen preflex
12:11:34 <hpc> is preflex muted?
12:11:36 <copumpkin> hpc: b0rked
12:12:29 <mauke> well, that would explain it
12:12:53 <copumpkin> mauke: what was it?
12:13:00 <mauke> copumpkin: netsplit
12:13:08 <copumpkin> how was it here?
12:16:20 <whald_> i have strange performance numbers for a very simple function of mine, maybe someone can explain to me what i'm doing wrong?
12:16:31 <whald_> the code is here: http://hpaste.org/44217/components
12:17:02 <mauke> what's a Flt?
12:17:13 <whald_> the two functions "component1" and "component2" are, well, the same - yet different
12:17:30 <whald_> at least after ghc chewed on them
12:17:40 <whald_> mauke: oh, it's a Float
12:17:48 <mauke> ...
12:17:55 <conal> whald_: what differences do you see?
12:18:02 <whald_> i just gave it a different name so i can swap for Double when i want to
12:18:50 <whald_> this is part of a raytracer, and the ~2 function uses whopping 15.5% cpu cycles + 17.3% allocations
12:19:07 <whald_> and the first one is at ~14% cpu and 0% allocations
12:19:12 <conal> whald_: oh -- the second is more expensive than the first?
12:19:22 <whald_> yes, by much
12:19:31 <whald_> especially the allocations are strange to me
12:19:34 <conal> whald_: maybe because ghc optimizes pattern matching
12:19:52 <whald_> and anyway i feel both of them are *very* slow
12:20:02 <conal> whald_: hm. no idea off-hand about the allocations. hm.
12:21:04 <whald_> the BVH traversal is the workhorst of the entire thing, eating 35% cpu, directly followed by this ugly "component" which i though would essentially optimized awy
12:21:06 <conal> New blog post: "Deriving list scans" at http://conal.net/blog/posts/deriving-list-scans/
12:21:27 <whald_> -workhorst +workhorse :-)
12:22:09 <hpc> ah k
12:22:10 <hpc> mauke: the netsplit happened too late for it to have started before preflex was first queried
12:22:27 <conal> whald_: "BVH"?
12:22:41 <whald_> conal: "bounding volume hierarchy"
12:22:42 <Olathe> @pl \a b -> f a
12:22:42 <lambdabot> const . f
12:22:48 <conal> whald_: ah. thx.
12:25:59 <mauke> preflex: version
12:25:59 <preflex>  9.455
12:26:24 <mauke> preflex: seen copumpkin 
12:26:24 <preflex>  copumpkin was last seen on #haskell 14 minutes and 51 seconds ago, saying: hpc: b0rked
12:26:37 <copumpkin> unb0rked
12:26:40 <monadic_kid> whald_: you should trying use strict tuples and/or strictness annotations
12:27:49 <whald_> monadic_kid: or going for a ADT instead of tuples? i didn't know what would turn out better when i started this, so i rolled a dice
12:28:18 <whald_> monadic_kid: an ADT with strictness annotation, that is
12:28:46 <fryguybob> conal: The font size changes for the line right after "Folds".  In the source this line isn't in a <p></p>.
12:29:17 <conal> fryguybob: thx! will fix.
12:29:25 <monadic_kid> whald_: yes records with strict parameters and maybe UNPACK pragma: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
12:30:21 <monadic_kid> whald_: you have unboxed primitives as well
12:33:17 <whald_> monadic_kid: i'd like to be able to iterate over the vector components because it allows to write really nice traversal and bounding box intersection routines, so i can't really make use of record syntax i think
12:34:03 <whald_> monadic_kid: but if it helps ghc to generate better code i'll give it a try and see
12:37:17 <brett> Is there a mirror of the haskell-mode for emacs available?
12:37:20 <brett> http://projects.haskell.org/haskellmode-emacs/ is an empty page
12:38:28 <monadic_kid> whald_: I don't understand what you mean, how is it much different than using a tuple, records have various ways of de-constructing it's components and accessor functions are generated plus you have record update patterns
12:40:27 <robryk> monadic_kid: does what you are saying explain the difference between the two defintions of component?
12:42:01 <monadic_kid> robryk: no I'm not explaining that
12:42:14 <robryk> ok; thanks
12:42:41 <conal> fryguybob: there was another instance of the same issue. fixed now. i sent a bug report to pandoc-discuss.
12:42:57 <fryguybob> conal: Looks good!
12:43:02 <conal> :)
12:43:45 <whald_> monadic_kid: yes, records are much more flexible than tuples but i just don't need most of that, that's why i rolled a dice when i started
12:44:57 <monadic_kid> whald_: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma
12:45:00 <whald_> monadic_kid: what i do need is the "component" function, and i don't see why it performs so bad for tuples, and how it performs on an adt is what i'm trying to find out currently
12:47:49 <monadic_kid> whald_: probably because tuples are not strict, the functions may have not be inlined (there is an inline pragma), what is Flt?
12:49:13 <whald_> type Flt = Float (so i can swap for Double, just in case..)
12:51:43 <monadic_kid> whald_: I'd suggest using strict-ness annotations and UNPACK pragma to force unboxed types
12:52:32 <whald_> monadic_kid: ok, i'm about to try that, i'll tell how it turns out
13:04:22 <lpsmith> Out of curiousity,  has anybody documented Caleskell?
13:07:41 <Eduard_Munteanu> lpsmith: there seem to be a few people around who can enumerate the differences, but there are few of them.
13:07:45 <Eduard_Munteanu> :t mappend
13:07:46 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:08:02 <Eduard_Munteanu> (few differences I mean)
13:08:13 <Eduard_Munteanu> And I'm struggling for the rest.
13:08:36 <lpsmith> > LT ++ undefined
13:08:38 <lambdabot>   LT
13:08:44 <lpsmith> > EQ ++ undefined
13:08:45 <lambdabot>   *Exception: Prelude.undefined
13:08:50 <lpsmith> > GT ++ undefined
13:08:52 <lambdabot>   GT
13:08:53 <Eduard_Munteanu> Wait that wasn't right.
13:09:00 <lpsmith> ++ is mappend :)
13:09:05 <lpsmith> (.) is fmap
13:09:06 <Eduard_Munteanu> :t mplus
13:09:07 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
13:09:22 <Eduard_Munteanu> Uh, I forget.
13:09:35 <lpsmith> I know that much,  I don't know much more
13:10:08 <Eduard_Munteanu> :t (++)
13:10:09 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:10:16 <Eduard_Munteanu> Oh, right, that was it.
13:10:17 <lpsmith> There you go :)
13:10:34 <sm> downforeveryoneorjustme.com says planet.haskell.org is up, I can't access it via HTTP. Just me ?
13:11:04 <lpsmith> sm,  it took a second,  but planet works for me
13:11:05 <Eduard_Munteanu> sm: just you, though I had some delay loading it
13:11:26 <Eduard_Munteanu> :t (>>>)
13:11:27 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
13:11:38 <sm> lpsmith, Eduard_Munteanu: thanks
13:12:39 <djahandarie> flip is a special definition
13:12:40 <djahandarie> :t flip
13:12:41 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:13:07 <djahandarie> Then there is the NumInstaces stuff from vector-space
13:13:14 <djahandarie> NumInstances*
13:14:14 <lpsmith> :t map
13:14:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:14:28 <djahandarie> Why use map when you can (.)? :)
13:14:38 <lpsmith> right
13:14:40 <lpsmith> : )
13:15:03 <djahandarie> @typ Prelude.flip $ fmap . (Prelude.flip id)
13:15:04 <lambdabot> forall a (f :: * -> *) c. (Functor f) => f (a -> c) -> a -> f c
13:15:18 <djahandarie> I think there is a nicer definition but I don't remember it right now :P
13:15:24 <djahandarie> (For Caleskell flip)
13:18:33 <Eduard_Munteanu> @src (.)
13:18:33 <lambdabot> (f . g) x = f (g x)
13:18:33 <lambdabot> NB: In lambdabot,  (.) = fmap
13:19:07 <Eduard_Munteanu> (+1) . [1,2,3,4]
13:19:07 <Eduard_Munteanu> > (+1) . [1,2,3,4]
13:19:08 <lambdabot>   [2,3,4,5]
13:19:31 <Eduard_Munteanu> Now is there any reason for these changes?
13:19:44 <djahandarie> > 1 . [1,2,3,4]
13:19:45 <lambdabot>   [1,1,1,1]
13:20:00 <djahandarie> fufufu
13:20:07 <Eduard_Munteanu> Umm!
13:20:07 <Eduard_Munteanu> How?
13:20:07 <djahandarie> Eduard_Munteanu, because it's neat.
13:20:13 <djahandarie> How what? :P
13:20:15 <Eduard_Munteanu> > (const 1) . [1,2,3,4]
13:20:16 <lambdabot>   [1,1,1,1]
13:20:20 <djahandarie> (Major lag due to Freenode)
13:20:39 <Eduard_Munteanu> Well 1 isn't actually 'const 1'.
13:20:41 <djahandarie> > (sin^2 + cos^2) $ 163451
13:20:42 <lambdabot>   1.0
13:20:47 <djahandarie> Eduard_Munteanu, says who? ;)
13:21:03 <Eduard_Munteanu> Hrm.
13:21:11 <mauke> > 1 2 3
13:21:12 <lambdabot>   1
13:21:19 <djahandarie> Eduard_Munteanu, see VectorSpace.NumInstances from vector-space
13:21:22 <Eduard_Munteanu> :t 1
13:21:23 <lambdabot> forall t. (Num t) => t
13:21:24 <djahandarie> (I think that's the module at least)
13:21:44 <Eduard_Munteanu> Hm, what mauke said made me think about function application magic
13:21:49 <djahandarie> :t 1 :: (Num t) => a -> t
13:21:49 <mauke> > (+ (+ 1 2) 3 4)
13:21:49 <lambdabot> forall a t. (Num t) => a -> t
13:21:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:21:50 <lambdabot>    arising from a use of `...
13:22:04 <djahandarie> :t 1 :: (Num t) => a -> b -> t
13:22:05 <lambdabot> forall a b t. (Num t) => a -> b -> t
13:22:05 <mauke> > (+ (+ 1 2) 3) 4
13:22:06 <Eduard_Munteanu> Oh, ok, so there is some magic going on.
13:22:06 <lambdabot>   8
13:22:13 <pumpkin> lol
13:22:14 <mauke> not quite lisp
13:22:24 <djahandarie> Heh mauke
13:23:15 <ocharles> In http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Either I can see that Either is an instance of the Functor type class
13:23:22 <ocharles> but where can I read the source the implementation?
13:23:29 <pumpkin> that's often quite hard to track down
13:23:32 <pumpkin> and I'm not sure
13:23:33 <mauke> @src Either fmap
13:23:33 <lambdabot> fmap _ (Left x) = Left x
13:23:33 <lambdabot> fmap f (Right y) = Right (f y)
13:23:44 <Eduard_Munteanu> Rrright... http://hackage.haskell.org/packages/archive/vector-space/0.7.2/doc/html/Data-NumInstances.html
13:23:45 <ocharles> I see no fmap at http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Either.html#Either
13:23:48 <Eduard_Munteanu> Informative :P
13:23:55 <ocharles> pumpkin: I see
13:24:04 <djahandarie> Eduard_Munteanu, see the source, it is all instances :P
13:24:09 <ocharles> mauke: great, that's what I worked out myself too, but I'll be writing more (existing) functors and I don't want to spam the channel
13:24:15 <ocharles> can I pm lambdabot?
13:24:15 <pumpkin> poor orphans
13:24:21 <mauke> ocharles: sure
13:24:24 <pumpkin> ocharles: if you ask her nicely
13:24:27 <ocharles> :)
13:24:43 <ocharles> ok, that'll do for now then
13:24:52 <ocharles> onwards to work out what Functor ((,) e) could mean!
13:24:54 <Eduard_Munteanu> djahandarie: I thought that couldn't work without compiler magic. :/
13:25:13 <djahandarie> Eduard_Munteanu, what exactly?
13:25:19 <Eduard_Munteanu> I mean interpreting 3 as some a->b
13:25:30 <pumpkin> no compiler magic
13:25:36 <pumpkin> beyond what it already does for number literals
13:25:47 <maurer_1> Eduard_Munteau: Just make it an instance of Num, and you're done
13:25:48 <mauke> @djinn (a -> b) -> ((,) e) a -> ((,) e) b
13:25:49 <lambdabot> Cannot parse command
13:25:55 <mauke> why not
13:26:06 <Eduard_Munteanu> Well, 3 can be an Int, a Float etc., but why a->b? Just the instance declaration?
13:26:18 <djahandarie> It can be any Num
13:26:18 <mauke> @djinn (a -> b) -> (e, a) -> (e, b)
13:26:18 <lambdabot> f a (b, c) = (b, a c)
13:26:20 <djahandarie> :t 3
13:26:21 <lambdabot> forall t. (Num t) => t
13:26:31 <djahandarie> So as long as there is a Num (a->b) it can be a->b
13:26:48 <djahandarie> (In this case it is (Num b) => Num (a->b) though)
13:27:04 <mauke> > deriv (1 + sin) x
13:27:04 <lambdabot>   1 * cos x
13:27:08 <Eduard_Munteanu> Oh, I see. I thought types for literals were fixed to a set.
13:27:16 <mauke> lambdabot: you win this round
13:27:31 <Eduard_Munteanu> mauke: yeah, I know the stuff on automatic differentiation
13:27:36 <Eduard_Munteanu> Rewrite rules, IIRC.
13:27:40 <pumpkin> no rewrite rules
13:27:48 <djahandarie> Rewrite rules wouldn't be able to do that :P
13:27:59 <mauke> Eduard_Munteanu: that was triple magic
13:28:09 <djahandarie> :t deriv
13:28:09 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
13:28:10 <Eduard_Munteanu> Ah, I'm confusing then
13:28:20 <mauke> differentiation, function numbers, and simple reflection
13:28:25 <sm> oh, that's neat: https://github.com/languages/Haskell
13:28:33 <djahandarie> Simple reflection is nice with the ad package too
13:28:35 <mauke> > deriv (1 + sin) 2
13:28:36 <lambdabot>   -0.4161468365471424
13:28:58 <djahandarie> But we really need bindings to something to simplify expressions
13:29:08 <djahandarie> I forget what those things are called...
13:29:16 <pumpkin> simplatrons
13:29:43 <djahandarie> lol, something tells me that isn't it
13:29:46 <djahandarie> That would be too simple
13:29:47 <mauke> > deriv (1 + 1) x
13:29:48 <lambdabot>   0
13:30:24 <maurer_1> Eduard_Munteanu: http://hpaste.org/44218/numbers_const_functions
13:31:15 <maurer_1> Defining Eq and Show is kind of awkward, but Num evidently implies them.
13:31:32 <Eduard_Munteanu> Hm, I see.
13:32:04 <pumpkin> > deriv (sin + cos) x
13:32:05 <lambdabot>   1 * cos x + 1 * negate (sin x)
13:32:32 <djahandarie> > deriv (sin^2) x
13:32:33 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x)
13:33:44 <whald_> monadic_kid: so i'm through with the tuple -> adt with annotations conversion
13:34:06 <whald_> it gave a 30% speed rush _over all_
13:34:14 <whald_> thanks. :-)
13:34:44 <whald_> (though i still wonder what's the problem with tuples to start with...)
13:34:54 <djahandarie> > deriv (\x -> sin(x^2)) x
13:34:54 <lambdabot>   (1 * x + x * 1) * cos (x * x)
13:35:02 <monadic_kid> whald_: they are lazy and boxed types
13:35:03 <companion_cube> ôO, lambdabot can do that ?
13:35:29 <ocharles> am I right in thinking that fmap over (a->) is just function composition?
13:35:45 <ocharles> that is, fmap f g = f . g?
13:35:45 <mauke> ocharles: yes
13:35:52 <ocharles> neat!
13:36:01 <monadic_kid> whald_: what did you use, strict params & unpack pragma? 
13:36:03 <mauke> ocharles: in lambdabot, (.) = fmap
13:36:35 <ocharles> > (*2) . [1]
13:36:36 <lambdabot>   [2]
13:36:41 <ocharles> cool :)
13:36:41 <whald_> monadic_kid: yes
13:36:58 <djahandarie> ocharles, in real life most people just use <$> for fmap :P
13:37:08 <ocharles> yea, I do that atm with applicative
13:37:22 <ocharles> but i'm trying to spend this evening really honing my knowledge of it all
13:37:40 <mauke> :t [fmap, liftM, (<$>), liftA, (Prelude..)]
13:37:41 <lambdabot> forall a b a1. [(a -> b) -> (a1 -> a) -> a1 -> b]
13:38:20 <monadic_kid> whald_: don't get there is an inline pragma for funcitons, are you going to try using Parallel Haskell at some point?
13:38:31 <monadic_kid> whald_: *don't forget
13:38:37 * ocharles can't read existential types yet
13:38:52 <mauke> that wasn't an existential type
13:39:22 <whald_> monadic_kid: yes, i'll go for statified sampling next and then parallelism of some form is next on my todo list
13:39:53 <whald_> monadic_kid: if i had an quad core parallelism would be ranked higher :-)
13:40:27 <monadic_kid> whald_: should be quite easy to parallize as long as they are pure functions
13:41:03 <whald_> monadic_kid: sadly it's an stochastic tracer, so i need a RNG which makes the pureness difficult
13:41:34 <whald_> monadic_kid: *luckily* it's an stochastic tracer because the images are so much more appealing
13:43:58 <pumpkin> ocharles: yep
13:43:58 <pumpkin> > deriv (\x -> log (sin (cos (x^3))))) x
13:43:58 <pumpkin> lambdabot is awfully slow today
13:43:58 <kmc> is there already a type which works like (a,b) but has Eq and Ord that look only at the second element?
13:43:58 <kmc> in some library?
13:43:58 <pumpkin> I doubt it
13:43:58 <pumpkin> I've never seen such a thing
13:43:59 <lambdabot>   <no location info>: parse error on input `)'
13:44:00 <whald_> monadic_kid: while over all the ADT change was very good for performance, my "component" is now up to 18% cpu and 12% allocations
13:44:21 <whald_> i'll force to inline that one...
13:44:32 <monadic_kid> whald_: RNG doesn't make the pure-ness difficult, it might make your code less embarrassing in parallell though.
13:45:00 <monadic_kid> *embarrassingly 
13:45:24 <mauke> > deriv (\x -> log (sin (cos (x^3)))) x
13:45:25 <lambdabot>   ((1 * x + x * 1) * x + x * x * 1) * negate (sin (x * x * x)) * cos (cos (x ...
13:46:15 <whald_> monadic_kid: but i can't "synchronize" (sorry, i come from Java...) on the RNG every time i need a value, so i need an RNG which supports a "split" operation which is then used for lots of computations so the cost of splitting amortizes
13:46:30 <whald_> monadic_kid: but maybe i'm still too much caught in my Java world
13:46:59 <whald_> monadic_kid: but then i think this problem is pretty fundamental, and the language won't make any difference here
13:48:31 <augustss> howdy
13:49:03 <monadic_kid> whald_: that is what i meant by less parallel, but pure-ness doesn't have to get effected by RNG you can still do that purely functionally and funny you mentioned split, there is a split function in the RandomGen type-class
13:50:05 <whald_> monadic_kid: the standard randomGen is very slow, i'm using the MWC random package which outperforms the default implementation by a factor of 30 for my use case
13:52:00 <whald_> monadic_kid: ok, this is getting weird for me, my new vector and component are here: http://hpaste.org/44219/the_faster_vector_the_slower
13:52:10 <pumpkin> augustss: greetings!
13:53:01 <whald_> with the inline pragma i get 1% off from the component cost, so it's 16.3 cpu / 12.2 alloc -- this can't be the last word for such a simple thing?
13:56:53 <whald_> monadic_kid: maybe something gets accounted to the component function which i don't expect?
13:57:27 <whald_> monadic_kid: i mean, i can hardly imagine how a ghc would generate code for this function which needs an allocation at all
13:57:43 <jmcarthur> whald_: you can still keep purity even with mwc-random by making a pure, splittable supply of values from it (such as with the value-supply package, although i don't know if that would work mwc-random's ST interface in particular). it would still create a single point of contention (a hidden, shared RNG), but you would be able to do away with the imperativeness of ST
13:58:03 <jfischoff> does anyone know of a library that uses template haskell to make n-ary versions of the Control.Arrow functions, like first ***, etc?
14:00:09 <jmcarthur> whald_: also, why not define component like this?: http://hpaste.org/paste/44219/the_faster_vector_the_slower#p44220
14:01:26 <monadic_kid> whald_: how comes you went with this defintion instead of the other one you had before? you could also try making Dimensions parameter strict in the function argument. I've also seen people use True instead of otherwise in shootout ocde
14:01:29 <whald_> jmcarthur: first, thanks for the hint, i noted it and try to decipher what it means later this week when i'm up to it
14:02:27 <jmcarthur> whald_: finally, how about using record labels instead of a component function and Dimension type at all? http://hpaste.org/paste/44219/the_faster_vector_the_slower#p44221
14:02:59 <jmcarthur> monadic_kid: i really doubt either of those would make a difference
14:03:22 <jmcarthur> monadic_kid: ghc should be able to tell that dim is strict, and the otherwise/True thing was probably just to save characters
14:07:07 <whald_> jmcarthur: because i need to store the dimension when constructing spatial subdivision data structures (kdtree, bvh, whatever)
14:07:22 <jmcarthur> ah!
14:07:35 <jmcarthur> whald_: okay, then i'd go with my pattern matching version
14:07:47 <jmcarthur> whald_: it's possible that that one would be a little faster than your guarded version
14:07:54 <whald_> ok, had to take care of the kid, i'm at it now
14:08:01 <jmcarthur> pattern matching is basically a switch statement
14:08:13 <jmcarthur> the guard might be compiled to the same, but i don't know
14:10:47 <monadic_kid> jmcarthur: We've already been through this, guard expressions where slower than using pattern matching, also using strict fields and unpack pragma gave him ~30% speed increase
14:10:50 <danharaj> Someone just quoted this in another channel on a completely unrelated topic :p 07 01http://bash.org/?870063
14:10:55 <danharaj> djahanderie is e-famous
14:11:27 <jmcarthur> ah
14:11:33 <jmcarthur> then why drop back to guards?
14:11:44 <monadic_kid> jmcarthur: no idea
14:11:48 <jmcarthur> oh maybe that's why you were asking earlier
14:11:50 <monadic_kid> jmcarthur: i was about to ask him
14:11:56 <jmcarthur> *what you were
14:12:21 <whald_> jmcarthur: component with "case" instead of guards is 12.6 cpu / 12.2 alloc, so it's better. now i try pattern matching
14:12:56 <Tomsik> Guards slower than pattern matching, where is my 'sufficiently smart' ghc :(
14:13:20 <jmcarthur> it's actually a tough optimization, i bet
14:13:29 <jmcarthur> since (==) could mean anything
14:13:34 <augustss> Tomsik: you didn't implement it yet?
14:13:37 <robryk> but what is better with pattern matching?
14:13:40 <Tomsik> I'm just kidding
14:13:47 <monadic_kid> whald_: yeah i was wondering why you went back the guard form, i don't think you'll see a difference between case and pattern matching on function args they should be equivalent
14:13:53 <Cale> It's pretty obvious why guards ought to be slower than pattern matching.
14:14:06 <jmcarthur> robryk: closed form formula?
14:14:08 <Cale> At least, to the extent that they're interchangeable
14:14:11 <kmc> pattern matching is one of the primitive instructions of the STG-machine, basically
14:14:13 <robryk> i see not-faster only
14:14:22 <kmc> when you implement (==) you will use pattern matching
14:14:32 <robryk> jmcarthur: i'm afraid i don't understand
14:14:46 <jmcarthur> robryk: no branching
14:15:05 <montana> Quick question, if I return a monad, ex -> IO (),   what does the () mean?
14:15:06 <copumpkin> danharaj: awesome
14:15:07 <robryk> eh? how? you branch into cases then too
14:15:13 <augustss> depending on what you are pattern matching on, guards could be as fast, but in general it's tricky
14:15:25 <kmc> montana, () is a type with no useful values
14:15:26 <hpc> montana: data () = ()
14:15:28 <kmc> its only value is ()
14:15:36 <hpc> so you have IO stuff, with nothing inside
14:15:38 <augustss> () isn't useful?
14:15:40 <thoughtpolice> dons: gah, you deleted your post on reddit/haskell about the SAT! i figured out why the manually SAT'd program is so much faster and was going to reply :(
14:15:43 <kmc> so "IO ()" is the type of "recipe for performing IO, which produces no result"
14:15:44 <Cale> robryk: Pattern matching in GHC basically involves ensuring that an expression is evaluated (entering the code for it which returns immediately if already evaluated) and then doing an integer test to see if the pattern matches.
14:15:51 <thoughtpolice> (sat on the binary-trees benchmark, that is)
14:15:55 <monadic_kid> it's un-useful-ness is useful :)
14:15:58 <hpc> or in imperative terms, a void method
14:16:02 <montana> okz
14:16:09 <montana> thank you
14:16:18 <robryk> Cale: or a few integer tests, right?
14:16:24 <Cale> Well, yeah
14:16:33 <Cale> One for each pattern to try
14:16:42 <robryk> oh
14:16:45 <Cale> (there might be some optimisation here)
14:16:46 <augustss> 10010
14:16:48 <kmc> it's even faster than what Cale said, if GHC is doing pointer tagging
14:16:48 <robryk> even if patterns are deep?
14:16:51 <kmc> which it usually is now
14:17:00 <Cale> Well, patterns which are deep get compiled to shallow ones
14:17:09 <robryk> i mean, i can match on a:b:c:xs
14:17:17 <robryk> oh, ok
14:17:18 <Cale> So, yeah, deeper patterns will involve more tests too
14:17:32 <whald_> jmcarthur: with pattern matching it's 12.5% cpu and 18% alloc, so this is the fastest for now
14:18:02 <whald_> jmcarthur: and it's just "data Dimension = X | Y | Z deriving Eq", nothing fancy about that
14:18:05 <jmcarthur> whald_: wait, you were comparing patterns to case expressions? ...
14:18:17 <Cale> kmc is right too, there's pointer tagging which can allow it to skip entering the expression's code sometimes
14:18:25 <jmcarthur> whald_: yeah, but (==) in guards would still probably be more work
14:18:45 <whald_> jmcarthur: first was case, then guards and last was pattern matching
14:19:27 <jmcarthur> whald_: i'm surprised there is any difference between the latter two at all
14:19:32 <robryk> but why doesn't dim == X do the same that doing case dim of X would do?
14:19:36 <whald_> jmcarthur: i agree, and pattern matching is the fastes which, while it makes sense, is still unbelievable slow
14:19:39 <jmcarthur> whald_: actually, it doesn't look like it was a significant difference
14:19:45 <kmc> :t M.insertWith (\_ _ -> Nothing)
14:19:46 <lambdabot> forall a k. (Ord k) => k -> Maybe a -> M.Map k (Maybe a) -> M.Map k (Maybe a)
14:19:47 <Cale> Guards which do the same thing as patterns (using == or something) will be slower because you'll end up needing to do the equality test on top of pattern matching the boolean result.
14:20:06 <Cale> So at best, you're turning one pattern match into two
14:20:12 <robryk> but won't == get inlined?
14:20:33 <dons> thoughtpolice: i figured out too :)
14:20:42 <Cale> Even if it is inlined, and your type is so simple that equality testing is a single pattern match...
14:20:46 <dons> thoughtpolice: shadowing is kind of bad ... esp. when it doesn't affect  the result.
14:21:06 <robryk> i mean, am i right that it won't use the heap for bools then?
14:21:11 <Cale> (though actually, it'll have to be at least two even for Bool)
14:21:14 <jmcarthur> robryk: but inlining it still gives you a whole case expression. inlining it for two guards gives you two case expressions. on top of all this, the guard has to check the result which is like another case expression each time
14:21:33 <jmcarthur> robryk: it would have to do some pretty fancy stuff
14:21:50 <robryk> so it creates a full blown bool then?
14:21:56 <robryk> with all refcounting and so on?
14:22:01 <monadic_kid> whald_: you might be better of using an newtype Int instead of an algebgraic type to pick out the components, ghc doesn't optimize ADT with more than one constructor
14:22:13 <copumpkin> refcounting in my haskell!?
14:22:16 <jmcarthur> i can't say what ghc actually does. all i can say is it's harder than it appears
14:22:23 <jmcarthur> i can say it doesn't do refcounting :P
14:22:23 <monadic_kid> whald_: well doesn't do unboxing of ADT with more than one constructor
14:22:30 <dons> thoughtpolice: is that what you saw too?
14:22:35 <robryk> sorry, meant checking whether object is still alive
14:22:37 <edwardk> robryk: there are two Bool constructors, neither take arguments, so they don't get allocated as fresh arguments on the heap when referenced, you just point to the canonical constructor for each (once you evaluate the closure and get a True or False out that is)
14:22:38 <whald_> monadic_kid: oh, ok, this gives a new spin to the whole thing, i'll try
14:22:48 <robryk> oh, ok
14:22:48 <jmcarthur> monadic_kid: huh?
14:23:00 <jmcarthur> i hadn't heard this. i'm not sure i understand what you mean though
14:23:10 <edwardk> robryk: this also happens with [a], there is only one [] constructor floating around.
14:23:10 <copumpkin> it doesn't combinatorially explode the unboxed constructors
14:23:15 <copumpkin> which I'd like it to do
14:23:45 <robryk> ok, and then checking for truth will compare addresses?
14:23:51 <robryk> or will it be more involved
14:24:00 <jmcarthur> oh, it points to a canonical constructor on the heap instead of just duplicating a tag?
14:24:03 <Cale> @src (==) Bool
14:24:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:24:08 <Cale> @src Bool (==)
14:24:08 <lambdabot> Source not found. That's something I cannot allow to happen.
14:24:09 <Cale> hmm
14:24:18 <edwardk> robryk: technically it'll check the tagbits
14:24:19 <Cale> I forget how to ask for that :)
14:24:40 <Cale> oh, right
14:24:44 <Cale> it's just derived
14:24:45 <edwardk> robryk: then it'll fall back on something more involved. for most cases, this will be masking off the pointer for its lsbs.
14:24:51 <jmcarthur> copumpkin: this sounds like low hanging fruit...
14:25:07 <monadic_kid> jmcarthur: http://www.haskell.org/haskellwiki/Performance/Data_types#Single-constructor_datatypes
14:25:10 <jmcarthur> probably tougher than it sounds though
14:25:12 <edwardk> robryk: but if that is something that hasn't had its tag bits propagated yet, then it'll fall back on the usual case machinery
14:25:17 <copumpkin> jmcarthur: sure, but reboxing stuff when necessary can be tough
14:25:28 <robryk> ok.
14:25:43 <monadic_kid> jmcarthur: http://www.haskell.org/haskellwiki/Performance/Data_types#Enumerations
14:25:49 <edwardk> robryk: http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/index.htm gives the gory details in legible form
14:25:54 <robryk> thanks
14:26:30 <jmcarthur> monadic_kid: i see. thanks
14:26:37 <jmcarthur> that's a lame limitation
14:27:16 <robryk> do i understand correctly, that stg machine is involved whenever you evaluate a closure?
14:27:54 <edwardk> robryk: the stg basically defines the structure for how closures are built, and how to replace them with their answer
14:29:59 <kmc> STG is the name of a virtual machine with two remarkable properties: it's "obvious" how to compile minimal-Haskell to it, and it's also "obvious" how to implement each of its instructions efficiently in C or assembly for real architectures
14:30:09 <augustss> robryk: the stg machine is only involved in an abstract sense.  It's an intermediate representation of the program while compiling.
14:30:26 <djahandarie> kmc, obviously nothing is that obvious though.
14:30:28 <kmc> obviously these things are not really obvious, or a 40-page paper would not be necessary, but that's the idea
14:30:33 <djahandarie> :P
14:30:33 <kmc> ;)
14:30:37 <edwardk> =)
14:30:50 <robryk> ok. so how does it relate to the stg stack, which is something that is real and used during execution? (or am i wrong?)
14:30:53 <augustss> kmc: obvious is retrospect :)
14:31:07 <edwardk> robryk: you might find http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729 to be a handy guide
14:31:33 <edwardk> when paired with the dynamic pointer tagging paper from earlier it works as a pretty good field guide to the STG
14:31:33 <kmc> robryk, one of the components of the STG machine's state is a stack 
14:31:52 <augustss> robryk: ghc does keep a stack that is kinda like the stg stack.
14:31:57 <kmc> robryk, i wouldn't say that STG is "not real"
14:32:00 <Cale> robryk: I like to think of GHC's stack as consisting of case expressions (or other pattern matches) which are waiting for their scrutinee to be sufficiently evaluated to pattern match.
14:32:28 <robryk> does anthing worthwhile sit on the hardware stack durign execution?
14:32:43 <augustss> robryk: what is the hardware stack?
14:32:46 <copumpkin> hardware stack?
14:32:50 <copumpkin> C foreign calls?
14:33:02 <edwardk> the STG is just an intermediate representation which is used to perform some last second optimizations before moving to a more imperative model. unlike core you can talk a bit more about whether or not evaluating a closure is visible to some other computation and thus note whether or not the closure should be pointed to the answer or not, etc.
14:33:09 <robryk> hardware stack is the one which is pointed to by [er]sp
14:33:22 <kmc> robryk, when compiling through C, GHC does its best to remove the C function preludes
14:33:23 <copumpkin> robryk: there's nothing special about the stack. it's just a region of memory that's used in a certain conventional way
14:33:29 <kmc> that's one of the jobs of the Evil Mangler
14:33:49 <augustss> robryk: that's just a convention.  I've used esp for other purposes. :)
14:33:52 <robryk> i mean, does it get used much?
14:34:07 <kmc> no
14:34:13 <robryk> ok, thanks
14:34:14 <augustss> robryk: for FFI calls
14:34:20 <edwardk> robryk: if you mean the c-style stack, pointed to by ESP, etc., not much. ghc maintains little baby stacks of its own, and jumps into code blocks rather than calls for most of its dirty work
14:34:27 <ocharles> what does "`pure' is not a (visible) method of class `Applicative" mean?
14:34:31 <edwardk> but ffi, etc. abuses the c stack
14:34:46 <Cale> ocharles: Means you need to import Control.Applicative
14:34:49 <kmc> robryk, ghc -fvia-c -keep-hc-files --make foo.hs
14:34:52 <kmc> robryk, then look at foo.hc
14:34:56 <robryk> tried once
14:34:59 <edwardk> ocharles: probably that you forgot to import Control.Applicative
14:35:01 <augustss> and puke
14:35:10 <kmc> yep
14:35:13 <robryk> haven't seen much
14:35:16 <ocharles> Cale: I'm trying to write "instance Applicative Maybe", so I can't just import Control.Applicative (as that defines this exact instance)
14:35:16 <edwardk> =)
14:35:20 <kmc> robryk, you'll see it's pretty light on standard C function calls
14:35:26 <Cale> ocharles: Oh, can't do that.
14:35:29 <ocharles> I tried "import Control.Applicative (Applicative)"
14:35:32 <ocharles> oh, bummer
14:35:35 <ocharles> I'll write my own class then
14:35:39 <edwardk> ocharles: then you're screwed because the class and the instance are in the same module
14:35:42 <kmc> but you will see them if you make an FFI call that's imported "unsafe"
14:35:44 <augustss> ocharles: (Applicative(..))
14:36:03 <edwardk> ocharles: importing anything from Control.Applicative will drag along all the instances
14:36:06 <Cale> There's no way to prevent the instance from being imported if you import anything from that module
14:36:08 <ocharles> ah
14:36:10 <kmc> Haskell evaluation proceeds mostly by tail-calls, which are implemented with this JMP_ macro
14:36:10 <augustss> ocharles: otherwise you only import the class, and not the methods
14:36:15 <ocharles> ok, that makes sense
14:36:29 <robryk> is there a quick answer, or should i read first the stg paper: why isn't `normal' stack used as the stg stack?
14:36:35 <edwardk> the reason you couldn't see pure was by saying Applicative rather than Applicative(..) you can't see the members, but even with that you get 'infected' with the instance for Maybe.
14:36:37 <kmc> read the paper ;)
14:36:39 <ocharles> i'll just copy pasta the class for now, as this is just for learning
14:36:39 <robryk> ok
14:36:53 <ocharles> edwardk, augustss: ah that helps too
14:36:55 <ocharles> much clearer now
14:36:56 <kmc> robryk, for one, to not interfere with the C stack, when compiling through C
14:37:04 <edwardk> robryk: it could be.
14:37:18 <edwardk> robryk: but the issue comes up with garbage collection, which needs to walk that stack
14:37:25 <kmc> robryk, also GHC implements (or did at one point implement) STG using two stacks, one for primitive values and one for pointers to the heap
14:37:29 <edwardk> robryk: this makes such a stack much less portable
14:37:35 <acowley> ocharles: why not use your own version of Maybe instead of your own class?
14:37:36 <kmc> that way you don't have to waste space tagging which is which
14:37:56 <ocharles> acowley: i don't see how that really changes anything, I'm not going to be using other stuff in Control.Applicative
14:37:56 <whald_> monadic_kid: i tried the suggestion from you / http://www.haskell.org/haskellwiki/Performance/Data_types#Enumerations
14:38:04 <augustss> kmc: you don't need to waste any important space by using one stack
14:38:06 <ocharles> I just want to understand how to write <$> for Maybe
14:38:13 <ocharles> <*>*
14:38:28 <monadic_kid> whald_: any luck?
14:38:38 <edwardk> just write functions with the same signatures as those of Applicative for Maybe
14:38:39 <acowley> ocharles: I see. Rewriting the data type is usually helpful because it is short, while functionality built on the class is rich and useful.
14:38:45 <edwardk> or make your own Maybe type and reinvent it
14:38:45 <augustss> kmc: you just needs stack descriptors at the safe points
14:38:46 <thoughtpolice> dons: yeah i believe so, when i looked at the core I could see the internal 'go' loop for (the modified) sumT had been hoisted out and put directly into the call site (inside depth, which was inlined into main) thus eliminating sumT almost entirely, but I figured something was wrong once I looked at the code and saw that sumT depends on 'check' for every iteration as opposed to just one - hence GHC would 'hoist' the internal loop in this case in
14:38:50 <ocharles> right
14:38:54 <whald_> monadic_kid: it didn't help either, it's 18% cpu (though allocations seem to be constant at ~12% whatever i try)
14:39:36 <whald_> monadic_kid: maybe i should have a look at the "Core" thing. it had look and came around that till now... :-)
14:39:47 <whald_> -look +luck
14:43:49 <Peaker> @djinn Maybe (a -> b) -> Maybe a -> Maybe b
14:43:49 <lambdabot> f a b =
14:43:49 <lambdabot>     case a of
14:43:49 <lambdabot>     Nothing -> Nothing
14:43:49 <lambdabot>     Just c -> case b of
14:43:49 <lambdabot>               Nothing -> Nothing
14:43:51 <lambdabot>               Just d -> Just (c d)
14:44:02 <Peaker> augustss, ^^ awesome work :)
14:44:26 <augustss> :)
14:44:34 <mux> automatically deriving <*> for Maybe? cute :-)
14:44:55 <kmc> i'm surprised djinn didn't give the equally valid term (\_ _ -> Nothing)
14:44:59 <kmc> which also has that type
14:45:04 <kmc> i guess it tries to use all arguments when possible
14:45:07 <kmc> stupid relevance logic ;P
14:45:09 <augustss> kmc: it does
14:45:11 <monadic_kid> whald_: did you try adding ! to the argument, how many times is that function called, how much time does it take for one call?
14:45:13 <robryk> oh, i once wondered why does TVar stuff use locking at all? is the logarithmic + only lock-free, not wait-free penalty greater than what one could get by removing locks?
14:45:24 <monadic_kid> whald_: ! the dimensions argument
14:45:26 <kmc> it uses locking?
14:45:33 <robryk> last i looked, yes
14:45:36 <robryk> when it is upadting
14:45:45 <robryk> it locks, checks versions, updated, unlocks
14:45:50 <robryk> *updates
14:46:03 <Peaker> augustss, how much work was djinn?
14:46:05 <kmc> as opposed to spinning on a version test-and set?
14:46:18 <robryk> yes, on a tree of all TVars
14:46:26 <robryk> no, not a version test-and-set
14:46:27 <augustss> Peaker: probably a few weeks, I don't remember exactly
14:46:39 <robryk> a pointer test-and-set
14:46:57 <augustss> Peaker: the import part was finding a good algorithm for finding the proofs
14:47:29 <augustss> Peaker: luckily Roy Dyckhoff had one in Prolog
14:47:32 <copumpkin> just enumerate all strings and output the first one that parses and typechecks to the right thing
14:47:36 <robryk> i mean, if you had few TVars, you could put a structure with pointers to then all and have somewhere a pointer to the structure
14:47:38 <copumpkin> that's what I'd do
14:47:43 <robryk> together with version info
14:48:10 <mreh> edwardk: don't mean to nag, did you give that patch to conal?
14:48:11 <robryk> then you construct new structure, and do compare-and-swap on both the pointer and version
14:48:21 <edwardk> mreh: i did.
14:48:27 <edwardk> mreh: its on my github
14:48:28 <mreh> edwardk: cool, thanks
14:48:34 <edwardk> mreh: if you want to play with it
14:48:36 <mreh> oh great
14:48:38 <whald_> monadic_kid: i did (hat to enable language feature BangPatterns for this one), but no change
14:48:57 <edwardk> mreh: there are a few semigroup instances that could be added above and beyond what i did, but it compiles now
14:49:03 <acowley> copumpkin: you've been in school too long :P
14:49:16 <copumpkin> acowley: nope!
14:49:23 <copumpkin> I've been out of school too long :P
14:49:25 <mreh> edwardk: that defines join correct?
14:49:48 <acowley> I always love decidability proofs of re structures
14:49:54 <acowley> It's so anticlimactic
14:50:01 <ddarius> copumpkin: Haven't you only been out of school (since last time) about a few months?
14:51:05 <Peaker> augustss, a few weeks sounds reasonable, especially since it includes a paper :) (the paper is probably a substantial portion of that?)
14:51:12 <copumpkin> ddarius: indeed!
14:51:18 <copumpkin> I think around 7 or 8 now
14:51:38 <edwardk> mreh: class Semigroup m where (<>) :: m -> m -> m — kinda boring ;)
14:51:42 <augustss> Peaker: a paper?  it doesn't really include a paper
14:52:04 <acowley> Is it acceptable if I use the AdditiveGroup class from vector-space for something that's just a group without being particularly additive?
14:52:10 <acowley> Or is that crass
14:52:52 <mreh> how did we end up with a symbol like >>=?
14:53:08 <Peaker> augustss, I thought you wrote a paper about djinn, I must mis-remember
14:53:21 <ocharles> mreh: well >> sequences, discarding the result, so adding an "=" makes sense
14:53:28 <Peaker> augustss, oh, I think I may be confused because of the link to the original algorithm's (prolog) paper
14:53:32 <augustss> Peaker: there are slides.  I've given several talks about it
14:53:40 <ocharles> you probably want to know more why we got ">>", but I think >> is a pretty good symbolic operator
14:54:04 <sm> ezyang: how do you make the whiteboard-style diagrams on your blog ? they're nice
14:55:50 <edwardk> acowley: how could you! (actually, its fine)
14:56:11 <acowley> edwardk: I will note your blessing in the comments
14:56:40 <edwardk> awesome =)
14:57:09 <accel> amazon is the new walmart
14:57:14 <accel> they're going to have their hands in everything
14:57:16 <accel> selling books
14:57:22 <accel> selling every fucking thing online
14:57:25 <accel> than EC2 + S3
14:57:29 <accel> and now video on demand
14:58:38 <eroomde> hi - a quick question for someone doing their first haskell project - is darcs still the defacto standard and worth learning if one comes from a git background? or is git becoming an equal citizen?
14:59:13 <augustss> eroomde: use what you feel comfortable with
14:59:14 <acowley> git is pretty popular in the Haskell community
14:59:25 <accel> the only people who use darcs rather than git
14:59:30 <accel> are those too blinded by loyalty to haskell to be practical
14:59:33 <eroomde> augustss: ok cool, that's the answer I suppose I wanted to hear.
14:59:43 <monochrom> I disagree with accel.
14:59:53 <eroomde> git is what I know, I just hope I wouldn't be cutting myself off by using it
14:59:58 <augustss> accel: also, darcs is very nice, except for performance problems
15:00:14 <accel> yeah, ppeople who ignore performance problems
15:00:17 <accel> are not very practical in my book
15:00:28 <augustss> accel: it works great for small projects
15:00:42 <accel> most of my projects tend to be more than 10 lines of code
15:00:58 <kmc> accel, troll much?
15:00:58 <monochrom> > "ignore performance problems" == "has not run into performance problems"
15:00:59 <lambdabot>   False
15:01:00 <helgikrs> xD
15:01:05 <accel> kmc: :-)
15:01:27 <kmc> you're not entirely wrong, though ;)
15:01:47 <kmc> anyway i don't think all haskellers need to use the same VCS or window manager or editor or keyboard or desk chair
15:01:49 <acowley> eroomde: sticking with git is no problem, you'll be able to figure out bits of darcs as the need arises
15:01:50 <augustss> but git is unbearably slow on my laptop.  every command takes at least 30s
15:01:55 <copumpkin> augustss: wow
15:01:59 <monochrom> the exact condition for pushing darcs to become slow is not as simple as "many lines of code"
15:02:03 <copumpkin> augustss: windows?
15:02:08 <accel> augustss: have you done a git gc?
15:02:08 <acowley> augustss: that is not normal
15:02:10 <augustss> windows
15:02:10 <copumpkin> I've heard it's way slower on windows
15:02:15 <copumpkin> not sure why
15:02:19 <augustss> no, it's not normal
15:02:19 <acowley> kmc: The chair does have to be red, though
15:02:31 <kmc> probably because windows sucks and furthermore linux kernel developers have no interest in optimizing code for windows?
15:02:34 <copumpkin> what color should the shed be?
15:02:38 <augustss> it happened after i updated to a new cygwin version
15:02:39 <accel> acowley: you an also use any editor you wish as long as it's vim 7.2
15:02:50 <augustss> the time is spent in lsass.exe
15:02:52 <ddarius> copumpkin: My shed is made of glass.
15:02:59 <eroomde> gosh I feel I've prodded a beehive with a stick here
15:02:59 <dankna> accel: 7.2.1, you heretic
15:03:02 <eroomde> I do apologise!
15:03:15 * copumpkin avoids throwing stones around ddarius' shed
15:03:51 <kmc> eroomde, :D
15:03:52 <edwardk> kmc: if we used the same desk chair, it would be awfully inconvenient to communicate over IRC. everyone would be waiting for their chance to sit down.
15:03:59 <accel> anyone here familiar with metafont?
15:04:03 <accel> i'd really like a texmacs clone in haskell
15:04:10 <accel> and since we already have text rendering in opengl
15:04:13 <accel> the biggest questions are:
15:04:17 <eroomde> anyway, time for me to be off. thanks for the advice all!
15:04:24 <accel> (1) aligning the cahrs in the right place (like the tex algorithm) and (2) reading the fonts properly
15:04:26 <dankna> we have text rendering in OpenGL?
15:04:35 <accel> dankna: yeah
15:04:39 <dankna> with what package?
15:04:50 <accel> HOpenGl can render text as a texture and display it
15:05:04 <dankna> oh, nice.  but does it give us access to full font metrics?  we'll need those
15:05:18 <accel> taht i'm not sure on
15:05:20 <dankna> for what you're talking about I think we even need the fancy new OpenType features
15:05:25 <accel> problem is, I catually don't understand metafont
15:05:27 <accel> i.e. waht it outputs
15:05:32 <dons> thoughtpolice: yeah, it was a (silly) name shadowing, and that the test output was unaffected by not actually building the trees :)
15:05:44 <dankna> I haven't used metafont, but I believe it just converts metrics into a format suitable for TeX
15:05:59 <accel> yeah, waht is that format?
15:06:06 <dankna> I am reading http://en.wikipedia.org/wiki/Metafont
15:06:07 <accel> "that format" = key to extracting the math fonts from TeX
15:06:10 <dankna> it sounds like it has a virtual machine
15:06:25 <accel> by "virtual machine" you mean "interpreter ?
15:06:44 <dankna> well, I mean something with well-defined behavior that I'm not sure just what it is because I haven't read enough :)
15:07:06 <dankna> hmm
15:07:19 <dankna> but you can use non-Metafont fonts in TeX too, with some versions of TeX
15:07:33 <accel> ah; I'm happy to juust use aerial + Math
15:07:43 <dankna> ah
15:08:10 <dankna> well, I have writing an OpenType loader on my to-do list somewhere down near the bottom...
15:08:22 <accel> why don't you kill all the items above it
15:08:29 <accel> and add "metafont loader' right undr it
15:08:41 <dankna> haha
15:08:49 <dankna> because I have my own priorities, not the same as yours :)
15:09:21 <dankna> note that you can actually use the GLU tesselator to draw text if you can get the font loaded
15:09:57 <dankna> you feed it a vector image and it gives you triangles
15:10:16 <dankna> I took that approach in Emerald Frame, but that only works on the Mac so far because it doesn't contain its own font loader
15:10:25 <dankna> (Emerald Frame being my answer to SDL)
15:10:33 <dankna> (implemented in C but with a Haskell binding)
15:13:28 <acowley> dankna: (Is it cross-platform?)
15:13:56 <monadic_kid> amd making opencl simpler with haskell: http://developer.amd.com/zones/OpenCLZone/publications/assets/MakingOpenCLSimplewithHaskell.pdf
15:13:57 <dankna> it's trying to be Mac/Win/Lin but Lin is for after the API stabilizes and Win is behind in the area of text
15:14:07 <acowley> I've been pretty frustrated with SDL on Mac due to needing various shims to get the executable off the ground
15:14:19 <dankna> yeah, indeed
15:14:27 <Peaker> SDL can probably be fixed to avoid the SDL_main hack
15:14:47 <Peaker> They'd probably accept a patch for that
15:14:50 <acowley> I have my own bindings I use in my projects, but they're junky
15:14:53 <dankna> the SDL_main hack is the tip of the iceberg.  SDL just gets a lot of small details wrong.
15:14:59 <acowley> Peaker: I don't know if it's that easy
15:15:03 <Peaker> It's the reason behind the shim stuff
15:15:10 <Peaker> dankna, any examples?
15:15:14 <dankna> well, sure
15:15:23 <thoughtpolice> monadic_kid: super neato
15:15:33 <dankna> I need to pull up the SDL API docs to remind myself
15:17:21 <dankna> okay, right.  this isn't really a defect so much as a note, but it contains a lot of stuff for working with pixel buffers, when what you really want to do is work with OpenGL directly nowadays.
15:17:47 <dankna> the semantics of particular events are difficult to work with because they didn't put enough effort into reconciling cross-platform models
15:17:52 <Peaker> well, SDL's surface stuff can be abandoned for OpenGL
15:17:58 <dankna> there are some real subtleties for example in what the Mac vs Win considers a double-click
15:18:07 <acowley> monadic_kid: This looks great
15:18:19 <dankna> or a right-click (don't get me started on people who write programs that require a three-button mouse...)
15:18:24 <dankna> (I use a trackpad, so... yeah...)
15:18:34 <Peaker> dankna, I may have written a toy that did, once :)
15:18:42 <dankna> yes, I agree, Peaker, that's why I didn't call it a defect
15:18:44 <dankna> hehe I see
15:18:44 <acowley> My biggest issue with SDL bindings is the startup shim and making sure the event thread is always treated with kid gloves
15:19:05 <acowley> I acknowledge both are awkward issues, but I'd like to be the one treated with kid gloves by the API
15:19:08 <dankna> yeah, the event thread shouldn't need to be special.  in EF I actually took the opposite approach - once you've done your initial setup, it calls you, instead of vice-versa
15:19:17 <Peaker> I don't know of any alternative to OpenGL+SDL. GLUT is too horrible
15:19:24 <acowley> I use GLUT :(
15:19:31 <dankna> GLUT is horrible :(
15:19:42 <Peaker> dankna, taking over my mainloop isn't very nice..
15:19:46 <dankna> because SDL is actually a relatively small program, I decided to go the route of making my own
15:20:13 <Peaker> window setup, event input, sound
15:20:14 <acowley> Well we can all frown at it, but at least I can get GLUT working on a fresh machine with less hoop jumping
15:20:17 <dankna> Peaker: well, it's not ideal, but what can you really do about it?  if you need to handle network connections or files in the background, use a thread
15:20:29 <Peaker> acowley, GLUT doesn't support "shift+tab" :P
15:20:36 <Peaker> acowley, or keyboard layouts that aren't English
15:20:54 <acowley> Peaker: I mostly use the arrow keys
15:21:00 <Peaker> dankna, consider I want to write my own mainloop in a monad transformer that isn't IO or something like that
15:21:02 <acowley> Peaker: so GLUT has me covered
15:21:13 <Peaker> dankna, it's relatively easy to use threads/messages to translate callbacks to events though
15:21:14 <dankna> I also don't like how certain things in SDL more-or-less-arbitrarily require separate packages - SDL_image, SDL_text
15:21:31 <Peaker> dankna, modularity is a good thing, even when there's not enough of it :)
15:21:35 <Peaker> (not all-or-nothing)
15:21:44 <dankna> Peaker: you can use your own monad with it, it works like this (a little awkward, but keep in mind that EF is multi-language)
15:22:15 <dankna> you make a StablePtr to the state you need to re-enter your monad, and set it as the context void * for all the callbacks you register for
15:22:30 <dankna> then when you get a callback you extract it and enter the monad.  you can write a helper function to do that.
15:22:36 <Peaker> Not sure you can "re-enter a monad" with state?
15:22:42 <dankna> it depends on the monad, certainly
15:22:56 <Peaker> But I can just write a getEvent API on top of a callback API
15:23:02 <dankna> that's true
15:23:44 <Peaker> one is just the catamorphism of the other :)
15:23:47 <dankna> haha
15:24:07 <Peaker> the cata of: data Event = KeyEvent Key | MouseEvent ... | ...   is really a bunch of callbacks to handle each
15:24:30 <dankna> oh, I also took issue with the keymap things in SDL
15:24:42 <accel> bah
15:24:47 <dankna> aside from the fact that they're #defines, which is a pain to bind against, they don't take sufficient care to be cross-platform
15:24:52 <accel> can't understand metafont
15:24:57 <accel> why is knuth so much smarter than me
15:25:01 <dankna> accel: heh
15:25:16 <dankna> the Mac has more modifier keys than Windows, and Linux has even more than that; you can't paper over that like they tried to do
15:28:27 <augustss> Mmmmm, modifier keys...  I miss the Lisp Machine.
15:28:32 <dankna> haha
15:28:40 <augustss> Super, hyper, and meta keys
15:31:05 <acowley> monadic_kid: those slides get kind of anti-Haskell there at the end!
15:34:46 <Peaker> dankna, I think it isn't SDL's role to give meaning to keys like "modifier" at all. They should just have sent low-level press/release events and let you decide
15:35:44 <dankna> Peaker: well, no.  because the low-level events behave differently on different platforms!
15:35:56 <dankna> Peaker: what event is sent on a repeat, for example?
15:36:38 <dankna> also, modifiers are treated separately by all platforms - you have to go to extra work to treat them as just like any other key
15:36:42 <Peaker> dankna, it shouldn't send repeat
15:36:54 <dankna> Peaker: that's an interesting theory :)
15:37:04 <Peaker> SDL should do extra work to make sure that it just gives you a low-level "press/release" of keys
15:37:16 <Peaker> (perhaps with a high-level layout mapping to unicode, but that's secondary)
15:37:17 <copumpkin> a press release?
15:37:23 <Peaker> :)
15:37:34 <dankna> so you get to manually implement timers if you want repeating keys?  that hardly seems in keeping with the "simple" part of their manifesto.
15:37:45 <Peaker> modifier keys/repeat are interpretations of press/release that apps are allowed to have
15:37:47 <Twey> It should probably give both
15:38:06 <Peaker> dankna, I think it should have the smallest/simplest/lowest possible API that gives you all the power
15:38:11 <dankna> well, I handle it by making repeats distinctive in the type (it's not trivial to even determine which low-level events ARE repeats)
15:38:18 <dankna> so that you can ignore them if you choose to
15:38:29 <Peaker> dankna, repeat is easy enough to implement as a higher abstraction. No need to mess with these platform-specific repeats
15:38:31 <Twey> A low-level press/release with additional modifier information attached so that the caller is free to ignore it, and a high-level character mapping
15:38:39 <Twey> With repeats, modifiers, &c. all bundled in
15:39:07 <dankna> Twey: well, that's loosely what I wound up doing
15:39:26 <dankna> the thing is that SDL does not give you all the power - it loses information by oversimplifying
15:39:31 <Peaker> Twey, the problem with modifiers is that it is really platform-dependent. I guess it falls in the same category of unicode mapping. The meaning assigned by OS is X, feel free to ignore
15:39:45 <Twey> Peaker: Yeah
15:39:57 <Twey> Well
15:40:13 <Twey> It needn't be — there's a set of modifiers, and either they're pressed or they aren't
15:40:36 <Peaker> Why not allow checking if any key is currently pressed, rather than just the modifiers? Then the modifiers aren't special anymore
15:40:39 <dankna> there's also the problem that if you do your own tracking,
15:40:43 <Twey> Interpreting what that *means* is the platform-dependent part, and in most cases if you want a low-level event you won't care
15:40:47 <dankna> you can get the following sequence:
15:40:53 <dankna> key down, keyboard unplug!  another key down
15:40:56 <dankna> now is the first key still down?
15:41:01 <dankna> (the user had two keyboards plugged in at the start)
15:41:03 <Twey> Peaker: Unfortunately the hardware doesn't necessarily work like that
15:41:10 <monochrom> haha, keyboard unplug
15:41:13 <dankna> yeah
15:41:16 <Twey> dankna: Yes, but that's pathological :þ
15:41:23 <dankna> yes, it is, I wound up assuming it would never happen
15:41:25 <dankna> but it /could/ :)
15:41:39 <Peaker> data KeyEvent = KeyEvent KeyCode KeyMeaning ; data KeyMeaning = Modifier Mod | Unicode String ; data Mod = Ctrl | Alt | ...
15:41:46 <Twey> Applications should not have to worry about device hotplugging
15:41:47 <monochrom> going low-level leads to much special-casing.
15:41:53 <Peaker> Twey, it doesn't have to be the hardware
15:42:09 <Peaker> Twey, IIRC, the hardware doesn't treat modifiers specially at all
15:42:22 <dankna> the hardware actually does, yes
15:42:29 <Twey> It does
15:42:33 <dankna> or the OS does, at a very low level - I'm not sure which
15:42:46 <Twey> I'm pretty sure the hardware does
15:42:51 <Peaker> I wrote a PC keyboard driver long ago
15:42:58 <dankna> okay, but everything is USB now
15:43:02 <Twey> IIRC only a byte is allocated by the protocol for each keypress
15:43:16 <Twey> Yes, but there's a standard USB HID protocol too, which has the same limitations
15:43:23 <dankna> okay
15:43:24 <Peaker> In USB I think modifiers are even less likely to be special. Why not let the OS track it?  The keyboard sends (Bool, KeyCode) events
15:43:49 <Peaker> Pre-USB, port 60h was essentially IRQ-based stream of (Bool, KeyCode) 
15:43:55 <dankna> anyway, my point is that what the OS actually does does not expose this stream of raw events directly
15:43:59 <Peaker> KeyCode could be Alt or Ctrl, etc
15:44:02 <dankna> you have to have actual data structures and stuff tracking keystates yourself
15:44:04 <dankna> which is what I did in EF
15:44:23 <dankna> the OS assumes you want things at a higher level of abstraction and you have to pay attention to its subtleties to re-extract the lower level
15:44:52 <dankna> and it's a different algorithm to get at the low level stream on each OS, too
15:45:09 <dankna> SDL just passes along the OS's high-level events, which is just clearly the wrong thing to do
15:45:34 <dankna> since the high-level events have different meanings on different platforms
15:45:43 <Peaker> It's sad that OS's aren't layered nicely, so you can just dig under the layer you don't want
15:45:55 <dankna> yes, but this is the world we live in / and this is the chance we're given :)
15:49:48 <Twey> Hmm
15:52:23 <Twey> dankna, Peaker: Yeah, modifiers are still treated specially by the USB HID protocol.  There's room for up to six keycodes in each report (not including modifiers, which are in a separate byte), but I don't know whether that means simultaneous presses or if it's just for several keypresses within the frame time
15:52:36 <dankna> Twey: thanks!  good to know.
15:52:53 * dancor got the google-chrome "aw, snap!" on http://snapframework.com/faq
15:53:00 <Twey> dankna: Haha
15:53:01 <Twey> Neat
15:53:09 <dankna> dankna != dancor
15:53:27 <geheimdienst> lemme check
15:53:34 <dancor> there are three dan*'s here
15:53:34 <geheimdienst> > "dankna" != "dancor"
15:53:35 <lambdabot>   Not in scope: `!='
15:53:36 <ddarius> dankna: This seem to be a common problem for you.
15:53:41 <dankna> ddarius: it really does
15:53:48 <Twey> dankna: Yeah, sorry :þ
15:53:51 <dankna> ddarius: at least people in here get my name right and don't call me danke
15:53:57 <dankna> Twey: haha it's fine
15:53:59 <Twey> Heh
15:54:08 <Twey> I'm going to read it as dan-kna for ever more, now
15:54:19 <dankna> well, good, cause that's the right way :)
15:54:24 <Twey> Oho
15:54:32 <Twey> Well, it's a bit more flattering than dank-na
15:54:38 <dankna> yes, indeed
15:54:47 <dankna> the latter suggests that I live in a cave
16:28:45 <copumpkin> preflex: seen jfredett
16:28:46 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
16:28:46 <preflex>  jfredett was last seen on #haskell-blah 350 days, 16 hours, 34 minutes and 7 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
16:35:53 * ddarius has wondered what's up with Joe
16:36:28 <copumpkin> lost interest/found something better?
16:38:00 <monochrom> achieved nirvana
16:38:14 <accel> ongbak 2 is amazing
16:38:18 <accel> it's everything I want in a movie
16:38:22 <accel> no plot, pure fight scenes
16:44:40 <ddarius> ongbak 2 sucked.
16:44:45 <ddarius> The first one was pretty good.
16:44:59 <acowley> You two should fight
16:45:12 <c_wraith> and make sure to broadcast it online
16:45:45 <accel> how about ongbak fights for ongbak's honor?
16:45:53 <accel> I don't think I would do justice representing ongbak
16:46:40 <acowley> It's an optimization: we transform ongbak into you, hold the fight, then transform you back into ongbak
16:47:22 <copumpkin> ddarius and accel in a thai deathmatch
16:47:25 <accel> it's easy for ongbak to simulate me; for me to simulate ongbak is a bit harder
16:47:25 <copumpkin> who would win?
16:47:37 <accel> copumpkin: depends, do I get ops during the fight?
16:47:43 <acowley> Although I think I am claiming a partial isomorphism between accel and ddarius under the ongbak structure
16:48:11 <copumpkin> accel: you can stop asking, because I can guarantee you'll never get ops :P
16:48:14 <copumpkin> so no
16:48:16 <acowley> Screw it, this is what unsafeCoerce is for
16:48:27 <accel> hmm; time to get a new cloak
16:48:51 <copumpkin> accel: you can keep the same name, just change the attitude and you'll be fine :)
16:49:03 <copumpkin> changing only the name without changing the attitude will likely get you the same response next time
16:52:26 <accel> copumpkin: what is the correct attitude? would you mind writing a guide? Earn you a Haskell op; or Real world #haskell op; or #haskell op of expression
16:52:31 <_erik> I've started, today, to try learning haskell. I've no experience with functional, but a lot with various imperative langs. I'm using YAHT, but am stuck on exercise 3.10. My code's at http://hpaste.org/44224/yaht_exercise_310
16:52:49 <copumpkin> accel: it isn't something that people often strive for, since it really doesn't mean much
16:53:02 <accel> life without dreams is meaningless
16:53:05 <_erik> What is happening there? I can't see how my attempt differs from the YAHT example
16:53:08 <accel> said some famous people
16:53:24 <copumpkin> accel: dream of getting better at haskell, or of one day writing a zygohistomorphic prepromorphism
16:53:49 * shachaf is reminded of how YAHT actually starts out by making people use IO and do notation.
16:53:53 <azaq23> > let t = "5" in read 5
16:53:54 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
16:53:54 <lambdabot>    arising from the literal `...
16:54:04 <aristid> people need goals in their life... but writing a non-trivial zygohistomorphic prepromorphism is just too ambitious
16:54:05 <azaq23> > let t = "5" in read t
16:54:06 <lambdabot>   *Exception: Prelude.read: no parse
16:54:14 <shachaf> _erik: Adding an explicit type signature should fix it.
16:54:14 <accel> > read "5"
16:54:15 <lambdabot>   *Exception: Prelude.read: no parse
16:54:22 <Saizan> _erik: you never use n, so the compiler can't tell which type it should be, so it won't know what code to use for read
16:54:23 <shachaf> _erik: But not using YAHT should fix it even more. :-)
16:54:25 <accel> > (read "5") + 2
16:54:25 <azaq23> > let t = "5" in (read t) :: Int
16:54:26 <lambdabot>   5
16:54:26 <lambdabot>   7
16:54:47 <azaq23> erik_: let n = read anum misses the type signature
16:54:49 <_erik> shachaf: any recommendations for a better intro? considering I have *no* functional experience whatsoever :P
16:55:01 <shachaf> _erik: I think LYAH is recommended around here.
16:55:03 <shachaf> @where lyah
16:55:03 <lambdabot> http://www.learnyouahaskell.com/
16:55:25 <_erik> yes, the error say so, yet YAHT uses the exact same construct... so I'm a bit baffled, I haven't gotten to type signatures yet
16:55:25 <acowley> _erik: The example pins down Int
16:55:55 <acowley> Note how an Int is passed to doGuessing, and guessNum is compared to it
16:56:00 <_erik> aha
16:56:17 <shachaf> _erik: I suspect that in the YAHT example the function's type is guessed from the context.
16:56:26 <acowley> It's really the < function that nails it
16:56:41 <_erik> ok, then it makes sense
16:56:52 <acowley> An Ord instance is required, one of the operands is an Int, and the type signature of < says the other operand must be the same type.
16:57:00 <_erik> so, I'm back to solving that annoying exercise, and then I'll switch to LYAH
16:57:25 <_erik> thanks :)
16:58:13 <shachaf> _erik: Note that everything that you read about do notation is probably kind of wrong. :-)
16:58:31 <shachaf> _erik: At least, I seem to remember that YAHT's explanation was pretty confusing.
16:58:32 <_erik> yes I've understood that being imperative is considered bad :P
16:58:55 <shachaf> _erik: Well, do notation isn't really imperative. :-)
16:58:59 <_erik> it's kind of hard to wrap my mind around the functional concept, but it's about time :P
17:00:16 <acowley> It's easier than it seems! I (want to) believe that most of the difficulty people have is due to nervousness about the concept rather than anything really difficult.
17:00:38 <_erik> well my initial impression is that it reminds me of how you build makefiles
17:12:01 * BMeph suspects that the toughest part of "functionalism" ;) is ditching the whole "take an object and call a method in order to do something" brain-washing of OOism.
17:12:33 * ddarius suspects the toughest part is ceasing to blame other things.
17:12:34 <tibbe_> BMeph: I suspect it's giving up on global state entirely ;)
17:12:56 <_erik> lazy evaluation and lack of state are kind of new yeah
17:13:08 <accel> is there a stackoverflow for haskell? if I can't get ops and kick people; I want to downvote and flag posts for deletion
17:13:17 <tibbe_> OO is really good for hiding global mutable state, you take a C program with global variables and wrap it in class { }
17:16:26 <monochrom> "take an object, call a method" ≅ "take a parameter, apply a function"
17:17:16 <accel> eh; more like take a monad; do somethign in it
17:17:32 <monochrom> as for multiple-parameter functions, "ever heard of multiple dispatch?"
17:17:52 <copumpkin> accel: just the usual stackoverflow
17:17:54 <acowley> accel: you mean, "wrap it in class { }" ≅ "wrap it in Monad m => m ()"
17:18:39 <accel> no; i was thinking wrap it in a state moand
17:18:48 <accel> since functions outside of ahskell oftimes modify the underlying object
17:19:08 <acowley> Forget State monads, we want mutable reference cells!
17:21:40 <monochrom> newtype ForgetfulState s a = FS a
17:22:45 <c_wraith> instance Monad (ForgetfulState s) where
17:22:47 <acowley> Indexed by all possible values of my heap
17:24:44 <djahandarie> Is ForgetfulState related to ForgetfulFunctor?
17:24:53 <monochrom> O long time no see the lazy cat!
17:25:12 <ManateeLazyCat> Try to learn Python today. :)
17:25:12 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
17:25:17 <acowley> djahandarie: Yes, the structure you forget is mutable
17:25:20 <ManateeLazyCat> monochrom: Hey. :)
17:25:48 <ManateeLazyCat> monochrom: How are you? Friend. ;)
17:26:42 <monochrom> I am beginning my most ambitious writing project ever. http://www.vex.net/~trebla/haskell/lazy.xhtml
17:27:11 <monochrom> Now I just have to force my "subsequent sections"!
17:27:39 <djahandarie> Reminds me to continue what I'm writing
17:27:42 <ManateeLazyCat> @tell juhp Thanks, i think i just can use python or C in our Linux version. :)
17:27:42 <lambdabot> Consider it noted.
17:27:57 <monochrom> onoes python
17:28:22 <ManateeLazyCat> monochrom: I have use Java develop a News Reader for Android 2.1 or above, now i'm try to learn Python to write software for my Linux version.
17:28:42 <ManateeLazyCat> monochrom: That's why disappear... 
17:28:44 <geheimdienst> "This article is about lazy evaluation, an evaluation strategy, an operational semantics. It will be written lazily as people force me. Goodbye."
17:28:59 <monochrom> hahaha
17:29:24 <ManateeLazyCat> monochrom: But i will continue to work on Manatee develop after i learn Python, 
17:29:42 <ManateeLazyCat> monochrom: Then i can write Java or Python code when work, then write haskell code after work. :)
17:30:23 <djahandarie> monochrom, http://althack.org/stlc.html is what I'm writing :o). It's missing intro and transitions and an edit pass (and it isn't done either...) but hey better than nothing. :P
17:30:29 <ManateeLazyCat> monochrom: http://linux.deepin.org/ A Linux version for Chinese people. :)
17:31:07 <ddarius> People have the writing fever lately.
17:33:50 <ManateeLazyCat> Maybe need a week to learn Python then continue work on Manatee, sorry haskell community, I did not realize my commitment for Manatee.
17:36:21 <ManateeLazyCat> Bye all, need to work, i will write more haskell code very soon. :)
17:38:59 <acowley> Debugging coordinate transformations is the worst thing. Ever.
17:40:06 <monochrom> heh I did a bit of it for my little svg expression pics
17:41:16 <monochrom> "why is that box not showing up?" "oh wait I should add 10 units not subtract 10 units!"
17:41:48 <acowley> I have to do it a lot (computer vision), and this instance is just killing me as I'm trying to get my code, some library code, and some of my advisor's code all in the same frame
17:42:14 <acowley> I've got inverted Ys from image coordinates, left-handed coordinates from 3D rendering, and every other combination of flipped axes imaginable
17:42:59 <monochrom> haha
17:43:40 <monochrom> at least those people are not crazy enough to "tilt the z-axis by 45 degrees" yet
17:43:41 <acowley> In an effort to keep things right handeded, my advisor's code has an up vector that's negative Y
17:43:49 <copumpkin> preflex: seen medfly
17:43:49 <preflex>  medfly was last seen on #haskell 13 days, 17 hours, 6 minutes and 39 seconds ago, saying: homework may be all "problem x,y,z on book"
17:44:33 <acowley> Which is great, except that we have separate R and T since we're sticking to an SE(3) representation that's a pair of a quaternion and a vector, and I think only one of them has the inverted Y.
17:44:56 <acowley> And the only non-trivial data set I have involves some chaotic motion
17:57:55 <ddarius> acowley: Clearly you should be using types to keep track of handedness.
17:59:16 <acowley> When I figure out what handedness all this C code is using, I probably will
17:59:40 <acowley> I've been really happy with Image type wrapper for OpenCV code that tracks number of color channels and color depth in the type
18:26:31 <zzing> In python if somebody wanted to make an opengl game they might choose pygame or pyglet. What exists for haskell that similarly assists in bridging the portability gap with opengl and the windowing system?
18:26:49 <acowley> GLUT
18:27:28 <accel> this is increadible
18:27:37 <kmc> GLUT sucks
18:27:42 <accel> Knuth wrote the Metafont books back in 1986
18:27:43 <acowley> accel: you got ops?
18:27:44 <kmc> SDL sucks too but is all right for getting input and an OpenGL context
18:27:52 <accel> acowley: ouch
18:27:54 <zzing> SDL doesn't work too well for me
18:27:57 <acowley> GLUT sucks, but works
18:28:00 <zzing> I suppose there was glfw too
18:28:08 <accel> Knuth wrote the Knuth books back in 1986
18:28:12 <acowley> SDL sucks less, but can be harder to get working
18:28:13 <accel> so one can only imagine how long ago he invented it
18:28:21 <accel> kmc: what do you dislike about glut?
18:28:42 <accel> kmc: or rather, the glut haskell bindins
18:28:58 <kmc> nothing in particular about the haskell b ]indings
18:29:09 <accel> kmc: I find that with haskell
18:29:13 <accel> stuff is so high level
18:29:16 <accel> I no longer care about the bindings
18:29:19 <accel> i.e. back in C++ land
18:29:23 <accel> GLUT/GLFW seemed different
18:29:29 <zzing> Does cabal-install work with ghc7 now?
18:29:35 <accel> but in haskell; I can't imagine how my GLUT/GLFW bindings differ
18:29:53 <Mitar> @pl (\(_, node') -> node' /= node)
18:29:53 <lambdabot> (node /=) . snd
18:30:59 <acowley> GLUT just requires that you take care of some dirty business, then you can get on with writing your code.
18:31:39 <Mitar> @pl  (\(_, node') -> nodes ! node' `attachTo` [TranslatableFor nodeNerve])
18:31:39 <lambdabot> (`attachTo` [TranslatableFor nodeNerve]) . (nodes !) . snd
18:32:51 <accel> the most amazing thing about haskell
18:33:00 <accel> is that, (without trolling, yes I know this is hard to believe)
18:33:06 <accel> I find Mac a usable unix replacement
18:33:19 <Mitar> @pl (nodeNerve `attachTo` (map (\(_, node') -> TranslatableFor $ nodes ! node') out'))
18:33:19 <lambdabot> nodeNerve `attachTo` map (TranslatableFor . (nodes !) . snd) out'
18:33:20 <accel> i.e. in C++, I had all these issues where my libary bindings didn't work the same on linux/mac
18:33:30 <accel> whereas, "ghc --make" seems to just take care of shit
18:33:42 <accel> and code (with exception of some implicit conversion bugs) just works fine
18:34:17 <acowley> accel: Agreed... with the exception of SDL
18:35:07 <Mitar> @pl (mapM_ (\(_, node') -> nodes ! node' `attachTo` [TranslatableFor nodeNerve]) inn')
18:35:07 <lambdabot> mapM_ ((`attachTo` [TranslatableFor nodeNerve]) . (nodes !) . snd) inn'
18:36:22 <accel> as I read the metafont manual
18:36:24 <accel> I can't help but ask
18:36:28 <accel> why didn't this take over the world
18:36:39 <accel> why the fuck did we, as computer scientists, not bow before Don Knuth and build upon his work
18:36:45 <accel> instead of re-inventing shit left and right, like svg
18:36:51 <accel> whereas metafont/metapost is Turing complete ....
18:37:00 <accel> and metafont alredy proven to work via TeX
18:38:43 <monochrom> svg serves a different purpose from metafont
18:38:45 <acowley> We do still use TeX. 
18:39:00 <monochrom> Turing-completeness is not a benefit.
18:39:13 <zzing> If I wanted to deal with data that is in a 2d format (say like a matrix) and I had to do operations like insert a column (of zeros) before and after, or add a row of zeros before or after, what data structure would I want to look at?
18:39:42 <tg_> matrices
18:39:54 <acowley> zzing: being able to insert both rows and columns is tricky
18:40:21 <zzing> acowley: hence why I ask before I engage any effort to actually do it.
18:41:33 <copumpkin> anyone here like unsolved metavariables? I have plenty http://hpaste.org/44225/quite_a_few_unsolved_metas
18:41:40 <acowley> zzing: I can't think of a data structure that allows both of those operations to run very efficiently. Pick one.
18:42:17 <acowley> copumpkin: You need Ltac
18:42:32 <zzing> acowley: The full problem domain here is opening an image, extra a 2d set of data (bytes) that represent a height map. Then surround the height map with zeros, and then have all data loaded relative to a certain point (so that you have heights above and below zero). Eventually, this will be joined by coordinates and be put into an array buffer in opengl and used with an index buffer for a triangle strip. I am presently doing this in py
18:42:48 <acowley> Oh, well that's different
18:43:00 <copumpkin> acowley: don't insult me!
18:43:04 <dankna> zzing: your message was cut off at the words "presently doing this in py"
18:43:17 <acowley> allocate the larger array, then copy line-by-line into your region of interest
18:43:30 <zzing> dankna: it continues: thon. I am considering haskell.
18:44:06 <acowley> If you really care about performance, then you need to do this just how you would in C
18:44:29 <zzing> acowley: What data structure library would be efficient for this, with the consideration that it will be loaded into a vbo?
18:44:49 <prsteele> zzing: In python, numpy...
18:44:54 <acowley> So, honestly, I would probabaly do this in C and FFI it
18:44:59 <acowley> because to load the VBO you want a pointer
18:45:17 <zzing> prsteele: numpy  is giving me some trouble :p
18:45:34 <zzing> acowley: I want to do it all in haskell if possible.
18:45:50 <acowley> zzing: Then use Data.Vector.Storable.Mutable
18:45:51 <zzing> The data creation point doesn't have to be absolutely efficient, just not horrible.
18:46:03 <zzing> It is the runtime that is important
18:46:15 <zzing> The actual loop I should say
18:46:24 <zzing> Because this is vbo it shouldn't be too much lifting
18:46:29 <acowley> Yep
18:47:30 <acowley> So you're going to be writing Haskell-formatted C in IO to poke a fresh Data.Vector.Storable.Mutable.MVector
18:47:56 <zzing> ok, now the other point is obtaining the data from the image in a reasonable format
18:48:06 <zzing> pyglet makes this very easy, I am hoping haskell is just as easy
18:48:13 <acowley> You can use my OpenCV bindings
18:48:26 <zzing> It is a grayscale png file, I just need the intensity values
18:48:52 <acowley> How about stb-image?
18:48:55 <tibbe> ezyang: I could use a strict pair right now
18:49:04 <tibbe> ezyang: defining yet another strict pair type
18:49:10 <acowley> is that a euphemism?
18:49:24 * BMeph strains to resist the cheap and easy "That's what she said" line...too late.
18:49:33 <zzing> this? http://hackage.haskell.org/package/HOpenCV
18:50:09 <acowley> That's the original OpenCV bindings. I have a fork that I use in my code. It is full of bad ideas and horrible mistakes, but is more complete
18:50:38 <acowley> But it requires OpenCV, which, if you're trying to make something for other people to build, might be a bit much
18:50:59 <zzing> stbimage might work, but I think a more complete image library is best because I might be using it for textures later
18:51:03 <accel> what's a good resource on how Parsec _works_ ... i.e. how it's impelmented, rather than how to use it?
18:51:17 <acowley> zzing: I use my OpenCV library to load images into textures
18:51:18 <accel> I want to really really really understand parsec
18:51:21 <accel> or one of it's variants
18:51:24 <accel> what's a good implementation to read?
18:51:36 <acowley> accel: the best way to learn it is to write your own
18:51:57 <zzing> acowley: As you say, OpenCV is a bit much. I am also targeting windows
18:52:02 <acowley> accel: it's not that hard to reimplement the basics
18:52:02 <accel> acowley: yeah; against what implementation?
18:52:06 <accel> acowley: I don't know how to write a parsec
18:52:17 <accel> acowley: so the question is, what parsec variant is good to read?
18:52:18 <accel> i.e. easy to read
18:52:48 <acowley> accel: It's a motivating example for learning a composition of MaybeT and State
18:53:24 <zzing> acowley: it looks like other things are sparse, I might try the tga loader
18:53:37 <accel> so basically read parsec?
18:53:59 <accel> the whole library is
18:54:00 <accel> whoa
18:54:02 <accel> < 2K LOC
18:54:31 <acowley> accel: you can, but starting from scratch really isn't that daunting! Start out with a parser that only runs against strings
18:54:53 <tibbe> what would you call a function that doesn't change a data structures size?
18:54:56 <tibbe> sizeInvariant?
18:55:01 <tibbe> anything shorter/catchier?
18:55:07 <acowley> accel: Write a function that takes a Char and a String, and returns a Maybe (Char, String) where the returned String is what is left after consuming the specified Char
18:55:21 <accel> acowley: I've already spent all my courage of month asking for ops; for Parsec, I'll start with reading
18:55:23 <acowley> tibbe: map :P
18:55:35 <tibbe> acowley: already taken :)
18:55:47 <aristid> fmap
18:57:06 <acowley> accel: The really neat part about trying to write your own parser combinators is that the types lead you to a good design without you even noticing
18:57:36 <zzing> brb
18:58:00 <geheimdienst> tibbe: sameSize?
18:58:11 <tibbe> geheimdienst: I like it, simple :)
18:58:29 <geheimdienst> ... you have a function for the express purpose of not changing the size? :-o
18:58:46 <acowley> geheimdienst: You can't be too careful
18:59:06 <prsteele> tibbe: isocardinal?
19:00:03 <tibbe> prsteele: heh
19:00:11 <tibbe> geheimdienst: it's a combinator
19:00:51 <co_dh> what's the formal definition of a combinator ? 
19:01:03 <Rotaerk> something that combinates!
19:01:09 <co_dh> other than the  K S I combinator ?
19:01:32 <shachaf> co_dh: Something that's defined only in terms of its arguments.
19:01:34 <co_dh> so any binary function can be regards as a combinator ? 
19:01:35 <geheimdienst> prsteele: yeah, le's put more a 'em lating names in der haskell, it don't got enough already
19:01:55 <acowley> A higher order function that returns a function that is a combination of its arguments
19:01:59 <Rotaerk> shachaf, isn't that a function?
19:02:03 <geheimdienst> i loosely thought combinator was the math-heads' word for higher-order function
19:02:30 <acowley> Rotaerk: many functions refer to non-argument values
19:03:11 <co_dh> combinator do not necessarily return a function. 
19:03:40 <Rotaerk> acowley, oh, so:  f y g = g y would be a combinator, but f g = g 5 wouldn't
19:03:44 <Rotaerk> because 5 isn't an argument
19:03:54 <tibbe> sameSize :: (Tree k v -> Tree k v) -> HashMap k v -> Hash Map k v
19:04:04 <shachaf> Rotaerk: Well, unless by 5 you mean Church-encoded 5. :-)
19:04:12 <tibbe> A HashMap is a tree and its size
19:04:15 <Rotaerk> why does the encoding matter
19:04:24 <acowley> Rotaerk: right
19:04:38 <prsteele> shachaf: would that be something like s(s(s(s(1)))) ?
19:04:42 <acowley> Rotaerk: but I wouldn't get bent out of shape if someone wanted to be more liberal in applying the word
19:05:01 <Rotaerk> acowley, i don't think that's sensical, because there's an invisible operator there: function application
19:05:02 <acowley> co_dh: they do in my book! (that only I read)
19:05:06 <shachaf> 5 = \f x -> f (f (f (f (f x))))
19:05:24 <co_dh> which book are you talking about? 
19:05:26 <geheimdienst> so a combinator is a function that takes functions and returns a function. the rest doesn't seem so essential to me
19:05:26 <acowley> Rotaerk: function application is the combinator
19:05:28 <prsteele> shachaf: so more general than Peano?
19:05:47 <Rotaerk> hmm
19:05:47 <co_dh> at least in Control.Arrow, (>>>) do not return a function, and I believe it's a combinator. :)
19:05:50 <shachaf> prsteele: ?
19:06:09 <acowley> co_dh: I meant in my personal usage of the word
19:06:13 <shachaf> co_dh: id is a combinator.
19:06:20 <prsteele> shachaf: Church encoding (of a number?) is more general than the Peano axioms?
19:07:26 <co_dh> shachaf: I don't think id is a combinator , 
19:07:33 <shachaf> prsteele: I'm not sure what you mean by "more general". It's an one way to represent a number.
19:07:43 <acowley> co_dh: But a cat is awfully like a function
19:07:51 <prsteele> shachaf: okay
19:07:57 <shachaf> co_dh: <co_dh> other than the  K S I combinator ?
19:08:12 <shachaf> co_dh: I is id
19:08:19 <Rotaerk> I never really understood the point of church encoding
19:08:22 <co_dh> shachaf: lol, yes, you are right :)
19:08:32 <acowley> >>> returns a cat a c which is a morphism from a to c
19:08:40 <shachaf> Rotaerk: The point?
19:08:51 <acowley> id is not a combinator
19:09:11 <Rotaerk> I mean, why encode values as combinations of functions, when that's not what those values *are*
19:09:16 <acowley> Rotaerk: to demonstrate the expressive power of the lambda calculus if nothing else
19:09:24 <Rotaerk> 5 isn't the concept of applying a function 5 times
19:09:50 <Rotaerk> unless that function is successor
19:09:50 <acowley> Rotaerk: If I can define addition and multiplication in terms of that representation, how is it different from what you think a natural number really is?
19:09:54 <kulakowski> Rotaerk: 5 also isn't a string of bits '00000101' or a string of digits '5'
19:10:20 <Rotaerk> kulakowski, yes, but the point of that encoding makes sense
19:10:31 <shachaf> Rotaerk: It's an encoding of the concept. Just like S(S(S(S(S(0))))) is, and the set {4,{4}}.
19:11:33 <acowley> Platonic 5 is ε
19:11:41 <kulakowski> Rotaerk: Do you know what the successor function is, with Church encoding?
19:11:56 <byorgey> Rotaerk: the ability to encode ANY data type in terms of nothing but 1-arguments functions is a surprising and powerful idea.
19:12:17 <Rotaerk> hmm true
19:12:24 <byorgey> it turns out to be useful sometimes, but that was never the original point.
19:12:35 <byorgey> Church was trying to come up with a foundation for mathematics.
19:14:04 <byorgey> that pesky Y combinator sort of ruined that, but on the whole I'd say things have turned out OK.
19:15:51 <co_dh> so Church build the whole mathematics from lambda calculus?  including , numbers , pair, ...  this is something I don't understand much .
19:16:13 <byorgey> co_dh: yes.
19:16:42 <co_dh> in fact, Church only say : from lambda calculus, we can build all recursive function on numbers , right? 
19:17:43 <byorgey> well, I'm hazy on the precise details of how Church formulated it.
19:19:01 <Rotaerk> I suppose what it means is that one shouldn't necessarily encode your values in lambda calculus, but that if you can show a more complex system to be reduceable to the lambda calculus, then it can also represent any data type
19:19:36 <augur> byorgey: so you're mister species
19:19:55 <augur> tell me about species and law-satisfaction
19:20:46 <byorgey> augur: can you be more specific please?
19:21:47 <ddarius> byorgey: What are you talking about?  You can't tell him about all of species in a few minutes over chat?
19:21:54 <augur> species ~ inductively-defined data types. do you know of any research into inductive data types that satisfy laws? eg monads satisfy laws, can you define the type of monads inductively?
19:22:09 <byorgey> ddarius: you're right, sorry, what was I thinking
19:22:17 <augur> what kinds of properties are inductive(izable)
19:22:39 <byorgey> augur: all of them, if you have a dependently typed language
19:22:59 <byorgey> via the Curry-Howard isomorphism
19:23:25 <augur> byorgey: how so tho? ive seen monoids defined as types, but they include proofs of monoidality as arguments, so its not inductive
19:23:35 <byorgey> augur: how is that not inductive?
19:23:35 <augur> not inductive on the monoids, anyway
19:24:00 <augur> its not like you have some monoid M and then some inductive step M : Monoid => f(M) : Monoid
19:24:47 <byorgey> augur: it's the same thing, there are just some extra arguments.
19:25:27 <augur> not really.. i mean, knowing that, say, <Z,+> is a monoid (its a monoid, isnt it?) what can we get from that?
19:25:40 <augur> <Z,+> : Monoid => f <Z,+> : Monoid
19:25:44 <augur> but whats f <Z,+>
19:26:56 <prsteele> what's the convention for indicating an illegal operation? For example, if I have 'data A = B | C | D', and I want to allow '<some B> + <some C>' but not '<some B> + <some D>' ?
19:27:11 <byorgey> I think I see what you are saying, and I think the answer is no, you can't do that
19:27:14 <byorgey> but it's just an intuition
19:27:21 <augur> byorgey: for monoids? probably not, i agree
19:27:36 <acowley> wait what?
19:27:49 <augur> but is there any research into what is and isnt inductivizable, then?
19:27:50 <acowley> If you have a monoid, and you have its underlying set and operation
19:28:07 <acowley> Then you want to use it to construct another monoid?
19:28:11 <augur> acowley: bingo.
19:28:15 <Jafet> > undefined --prsteele
19:28:16 <lambdabot>   *Exception: Prelude.undefined
19:28:33 <prsteele> Jafet: thakns
19:28:53 <acowley> I don't understand the problem, though
19:29:01 <augur> acowley: you just gave it!
19:29:19 <acowley> instance (Monoid a, Monoid b) => Monoid (a,b) where
19:29:19 <acowley>         mempty = (mempty, mempty)
19:29:19 <acowley>         (a1,b1) `mappend` (a2,b2) =
19:29:19 <acowley>                 (a1 `mappend` a2, b1 `mappend` b2)
19:29:21 <byorgey> augur: of course there are some such operations which produce new monoids from old, but there is no way you are going to be able to inductively *characterize* all monoids that way.
19:29:22 <acowley> That kind of thing
19:29:53 <acowley> Oh
19:30:15 <augur> byorgey: perhaps not! (tho the set of monoids that you COULD characterize that way is of interest to me, im sure)
19:30:36 <augur> the question really is about what sorts of data structures are characterizable like that, and what sets arent.
19:30:37 <Jafet> < error "prsteele's (+) isn't total!?"
19:30:43 <Jafet> > error "prsteele's (+) isn't total!?"
19:30:43 <lambdabot>   *Exception: prsteele's (+) isn't total!?
19:30:51 <byorgey> augur: ok, well, I don't know.
19:30:53 <augur> byorgey: lemme phrase it this way, now, cause its an interesting question
19:31:42 <augur> byorgey: type 0 grammars are inductive, as far as i can tell by the meaning of inductive. and monoidality when proved in the usual fashion is translatable into an equivalent type 0 grammar
19:31:48 <augur> so proof of monoidality is inductivizable
19:32:36 <augur> over the yield strings of the grammar, i mean
19:35:21 <augur> if monoids are necessarily non-inductive, this would suggest that there is no type 0 grammar in which for all monoids M that arent "initial", the string that means M : Monoid reduces to a string that means M' : Monoid where M' != M, and M' : Monoid is one of a __finite__ number of start strings
19:36:02 <augur> that would be a way of detecting this property, i suppose -- if you could find the machine reducing proof of M's monoidality to proof of M''s monoidality
19:36:23 <augur> hmm .. if monoids arent inductive it would mean theres an infinite generating set
19:36:31 <augur> like the primes
19:37:02 <byorgey> well, you obviously already know a lot more about this than I do =)
19:37:10 <augur> i dont "know" anything, im making shit up :p
19:37:16 <acowley> augur: I think it would have to be since you have things like <Z,+> and <Z,*>
19:37:25 <acowley> How could you generate one from the other?
19:37:29 <augur> acowley: well, you might not
19:37:32 <acowley> There isn't one canonical base case
19:37:36 <augur> but maybe you could generate everything else from those two!
19:37:51 <augur> so you'd have some finite number of monoid axioms
19:37:57 <augur> instead of just one
19:38:07 <augur> like a disjunctive data type
19:38:15 <augur> data Monoid = <Z,+> | <Z,*> | ...
19:38:30 <augur> | Monoid * Monoid
19:38:32 <augur> etc
19:40:12 <Jarvis_> what would be a good functional datastructure for storing a probability table involving multiple variables?
19:40:51 <augur> byorgey: btw, i read in awodey's CT book about eh.. what is this
19:41:05 <augur> using coequalizers to define algebras
19:41:23 <augur> so he gives the example with generates = x,y,z, and relations xy = z, y^2 = 1
19:42:50 <augur> and says F(2) =f,g=> F(3) where f = [xy,y^2], g = [z,1], and a coequalizer F(3) -> Q that "forces" the equalities to hold
19:43:09 <augur> and he says Q ~= F(x,y,z)/(xy = z, y^2 = 1)
19:43:12 <prsteele> Jarvis_: piecewise linear estimate?
19:43:17 <augur> what magic is this
19:44:07 <augur> and what is this ultimately doing, in terms of being able to use such a device practically?
19:44:10 <Jarvis_> prsteele: I'm not sure what that is
19:44:45 <prsteele> Jarvis_: instead of storing all the data points in a table, create a piecewise linear function that approximates the data
19:44:52 <copumpkin> kmc: nice blog post 
19:45:42 <Jarvis_> prsteele: how does one do that in haskell?
19:46:12 <kmc> thanks copumpkin
19:46:23 <augur> what blog post? :o
19:46:39 <prsteele> Jarvis_: do you have the data ahead of time, or do you generate it on-the-fly?
19:46:58 <ddarius> augur: It's building an equivalence relation with generated from xy = z and y^2 = 1 (so we add reflexivity, symmetry, and transitivity) and then partitioning the triples (x,y,z) by that equivalence relation and calling that set of partitions (equivalence classes) F(x,y,z)/(xy = z, y^2 = 1).
19:46:58 <copumpkin> augur: it's seekrit!
19:47:09 <copumpkin> augur: fine, it's on the ksplice blog
19:47:19 <Jarvis_> prsteele: I have it ahead of time
19:47:52 <augur> ddarius: is there a sensible way of translating this into actual code?
19:48:24 <kulakowski> augur: How much algebra have you studied?
19:48:27 <augur> or any such defined things, if something else is easier to translate?
19:48:38 <prsteele> Jarvis_: Then you can construct the estimating function ahead of time... one way is to solve it as a network flow problem
19:48:53 <ddarius> You could do it literally, which is what Rod Burstall does for similar constructions in "Computational Category Theory" but doing "over types" is quite a bit trickier, though still doable in a couple of ways.
19:48:57 <prsteele>  Jarvis_: but I bet a stats package (like R) could do it for you
19:49:02 <augur> kulakowski: hardly any! i never know where to start. ive got books here and there and they usually start with stuff like groups and the like, and i end up not knowing what to make of that stuff
19:49:16 <augur> ddarius: ill give this book/paper a look
19:50:14 <ddarius> Typically when this type of situation occurs in programming, programmers use abstract data types.  Quotienting = abstraction.
19:50:30 <Jarvis_> prsteele: hm... but what kind of data structure would I store it in? would it literally be a function?
19:50:31 <augur> kulakowski: why, is there some beautifully simple algebraic answer that would blow my mind? :x
19:51:22 <prsteele> Jarvis_: Once you have it, yes
19:51:43 <prsteele> Jarvis_: There will be a tradeoff between accuracy and number of breakpoints
19:52:04 <kulakowski> augur: I was going to suggest sort of the opposite. Learn some less abstract stuff, undergrad (linear) algebra, and then learn how to say all your proofs in fancy categorical language.
19:52:05 <Jarvis_> prsteele: I'd rather not sacrifice accuracy
19:52:42 <prsteele> Jarvis_: Hm. Then maybe just a binary search tree?
19:53:09 <prsteele> Jarvis_: ah, but you have multiple variables...
19:53:49 <Jarvis_> prsteele: yeah, I basically want a way to represent the factors of a markov network
19:57:25 <augur> kulakowski: less fancy stuff is familiar enough to me, but i dont know how to put it into CT terms
19:57:48 <applicative> hmm, no tempests in a teapots in -cafe, what am i supposed to read?
19:58:31 <monochrom> read my incomplete http://www.vex.net/~trebla/haskell/lazy.xhtml :)
19:58:42 <applicative> okay
19:59:05 <augur> kmc: wheres your blog
20:06:07 <applicative> monochrom, nice.  Maybe it would be clearer if you systematically counterposed strict evaluation side by side in your outline evaluation sequences?  
20:06:15 <applicative> but maybe that's not to your purpose
20:15:16 <applicative> I am forever thinking, I must have done with this laziness nonsense.  When the excellent tutorial of tibbe came out a few months ago I thought, I will follow his example.
20:15:41 <applicative> I picked a few stupid project euler problems and thought, I'll expedite these...
20:15:54 <tibbe> applicative: I finally think I've figured it out, laziness almost never bothers me anymore
20:16:09 <tibbe> applicative: I'll write a few more blog posts on the topic soon
20:16:26 <tibbe> applicative: there's a good way to think about laziness that I don't think is written down anywhere
20:16:29 <prsteele> tibbe: what's your blog?
20:16:42 <tibbe> prsteele: http://blog.johantibell.com/
20:16:44 <applicative> oh good. the one on high speed haskell is incredibly good, i've read it several times
20:16:56 <prsteele> tibbe: thanks
20:17:02 <tibbe> applicative: thanks :)
20:17:15 <applicative> one could use much more of this. 
20:17:20 <ddarius> tibbe: Which is?
20:18:22 <applicative> but i was going to say, nevertheless, after attempting to apply all the lessons, with mixed results, -- the problem was to count all the paths from upper left to lower right in 'taxi space' --
20:18:31 <tibbe> ddarius: start at the return type, if you want your function to be strict, use a type with strict fields (and if not use a lazy type)
20:18:54 <tibbe> ddarius: if you return e.g. (Int, Double) the function will be lazy
20:19:07 <tibbe> ddarius: if you don't want that, define a strict pair (or use the one from the 'strict' package)
20:19:22 <tibbe> ddarius: that way you very rarely have to use any bangs or seqs anymore
20:19:27 <applicative> then i went for the laziest solution imaginable: an infinite matrix of paths for all possible n x m areas.  and it was 10 x as fast as all the others. 
20:21:05 <applicative> a good library is of great help in these matters.   Data.Vector.Unboxed is always a win for me.
20:21:42 <Jarvis_> applicative: are you talking about this one? http://projecteuler.net/index.php?section=problems&id=15
20:21:54 <tibbe> applicative: yes, my new HashMap has a strict version, so you don't have to think about lazy vs strict values
20:22:08 <applicative> Jarvis_, yes exactly, I chose it at random
20:23:11 <Jarvis_> applicative: there's a closed form solution to that one via pascal's triangle
20:24:12 <applicative> oh, I see, it would involve more wit than i was probably applying. admittedly my ultralazy solution required a little insight beyond brute force. 
20:24:24 <int80_h> is hackage down?
20:24:35 <applicative> oh god not again
20:24:48 <int80_h> :(
20:24:50 <int80_h> ?
20:25:16 <int80_h> elaborate?
20:25:34 <Jarvis_> applicative: I didn't figure out the clever formula solution either... I did a dynamic programming algorithm using Data.Array that I was mighty proud of until I saw the simple mathematical solution :P
20:25:43 <Eduard_Munteanu> @where isitdown
20:25:43 <lambdabot> I know nothing about isitdown.
20:25:48 <Eduard_Munteanu> @where down
20:25:48 <lambdabot> I know nothing about down.
20:25:52 <Eduard_Munteanu> *sigh*
20:25:54 <geheimdienst> @google down for everyone
20:25:56 <lambdabot> http://downforeveryoneorjustme.com/
20:25:56 <lambdabot> Title: Down For Everyone Or Just Me -> Check if your website is down or up?
20:26:01 <applicative> hackage seems okay fo me
20:26:13 <tibbe> Jarvis_: on the topic of laziness, dynamic programming can be really neatly expressed by e.g. a Map with lazy values that refer to itself
20:26:26 <tibbe> up for me too
20:26:48 <Jarvis_> tibbe: right, or lazy arrays, which is what I used
20:27:02 <tibbe> Jarvis_: yes :)
20:27:24 * tibbe is just happy that he finally found one actually use for value-lazy maps
20:27:37 <int80_h> I'll try from lemmih's server
20:27:50 <Eduard_Munteanu> @where+ down http://downforeveryoneorjustme.com/
20:27:50 <lambdabot> Okay.
20:29:06 <applicative> it seems that the troubles with laziness comprehension come especially from large data structures, things you are using as 'control' so to speak, and the interaction of these with each others. This is where I find it easy to get lost.
20:29:21 <int80_h> dang
20:30:10 <tibbe> applicative: like using list as streams?
20:31:48 <int80_h> hmm, it works on my private server too. concluson: work net is fuxor'd
20:31:49 <applicative> yes, I suppose that's good if that's what you're actually doing.
20:33:56 <Eduard_Munteanu> Thinking about it, maybe lambdabot could implement downforeveryoneorjustme.com-like functionality.
20:35:19 <applicative> but anyway, I have no insight insight into how the matter is to be understood. you should keep expanding those slides as new points occur to you.  Much of it was familiar, but having all together - even simple obvious things like the pictures of the memory layout - was very helpful.
20:35:47 <prsteele> tibbe: your slides are the best explanation of why foldl' works the way it does that I've seen
20:36:17 <tibbe> prsteele: thanks :)
20:36:39 <sbahra> @ask Cale Any chance we could get lambdabot in #concurrencykit? 
20:36:39 <lambdabot> Consider it noted.
20:36:48 <Cale> yes
20:36:48 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
20:36:50 <Rotaerk> is downforeveryoneorjustme.com down or is it just me?
20:37:07 <Cale> lambdabot: @join #concurrencykit
20:37:47 <sbahra> Cale: <3
20:37:50 <sbahra> Cale: Thank you.
20:37:55 <Eduard_Munteanu> Hrm, we've got a Calebot :P
20:39:21 <Eduard_Munteanu> Bah, I wish lambdabot was fixed on Gentoo.
20:40:17 <Eduard_Munteanu> (actually it's GHC's fault I think)
20:41:21 <adnap> okay, i know nothing about concurrency in haskell, but are their concurrency models that utilize pipelining?  it seems perfect for function composition.
20:41:26 <adnap> *there
20:41:37 <prsteele> can I bind a function over groups of patterns without using a module-level function?
20:42:24 <Jarvis_> prsteele: you mean like with "where"?
20:43:05 <prsteele> Jarvis_: Can where bind across patterns as well as guards?
20:43:08 <siracusa> Rotaerk: It's just you
20:43:26 <Jarvis_> prsteele: yes
20:43:32 <btutt> Hrm. How do you pattern match using a non-String string type. i.e. TagSoup.TagOpen (T.pack "span") _ -> ....
20:44:08 <btutt> (T being Data.Text)
20:44:29 <adnap> huh?
20:44:34 <adnap> you can pattern match on any value
20:45:00 <Eduard_Munteanu> btutt: you can only pattern-match on constructors, however ViewPatterns allows you to compose on the right so to speak
20:45:32 <btutt> ViewPatterns one of the many language extensions?
20:45:46 <Eduard_Munteanu> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
20:45:47 <prsteele> Jarvis_: How would I modify this to make the where clause bind over both patterns? http://hpaste.org/44226/where_clause_over_patterns
20:45:47 <Eduard_Munteanu> Yes.
20:46:14 <Eduard_Munteanu> quoting... "View patterns permit calling the view function inside the pattern and matching against the result: size (view -> Unit) = 1
20:46:19 <Eduard_Munteanu> size (view -> Arrow t1 t2) = size t1 + size t2
20:46:20 <adnap> case?
20:46:33 <adnap> prsteele: couldn't you use a case and followed by a where?
20:47:20 <btutt> oh sweet. that looks like the ticket
20:47:25 <dibblego> @hoogle (Traversable t, Traversable r, Monad z) => z (t (u, r b)) -> z (u, r (t b))
20:47:25 <lambdabot> No results found
20:47:37 <dibblego> @hoogle (Monoid u, Traversable t, Traversable r, Monad z) => z (t (u, r b)) -> z (u, r (t b))
20:47:37 <lambdabot> No results found
20:48:15 <Eduard_Munteanu> btutt: but as adnap notes, there might be better ways
20:48:32 <Jarvis_> prsteele: ah, I see what you meant... no, I don't know of a way to make that work
20:49:11 <prsteele> adnap: let's see... I think you're correct...
20:50:19 <adnap> prsteele: i just annotated
20:51:01 <Jarvis_> hehe, me too :P
20:51:03 <Eduard_Munteanu> prsteele: you could have foo's actual code inside a 'where'/'let', and name it foo'. Or just make it top-level, you don't have to export it.
20:51:11 <prsteele> adnap: got it working with case, thanks
20:51:38 <adnap> np
20:51:40 <prsteele> adnap: perfect, thanks
20:51:40 <Eduard_Munteanu> like foo = foo' where foo' = ... ; x = ...
20:51:57 <Jarvis_> Eduard_Munteanu: oh, another good solution
20:52:35 <adnap> yeah, it's easier if the context is known
20:52:56 <adnap> not sure what you're doing since it was so abstract
20:53:38 <Jarvis_> prsteele: btw, I think you're right about using a binary tree to represent the probability table
20:54:06 <dmwit> ?remember Eliezer_Yudkowski You should always take joy in discovery [even if you aren't the "first" to discover it]... It is meaningless to talk of being the "first" or the "only" person to know a thing, when everything knowable is known within worlds that are in neither your past nor your future.
20:54:06 <lambdabot> I will never forget.
20:54:58 <mae> hello all
20:55:06 <Eduard_Munteanu> Interesting, who's that chap?
20:55:16 <mae> just a humble coder
20:55:27 <geheimdienst> Eduard_Munteanu: he's Less Wrong guy
20:55:30 <Eduard_Munteanu> mae: oh, hi, not you :)
20:55:37 <Eduard_Munteanu> Ah.
20:55:41 <dmwit> Eduard_Munteanu: Not sure about his greater context, but just now I'm reading his sequence introducing quantum physics.
20:56:50 <mae> Eduard_Munteanu: that infamous eh?
20:56:54 <kulakowski> dmwit: I found that the QM sequence started off pretty strong, but lost a lot of steam towards the end.
20:57:04 <dmwit> kulakowski: I'm finding it the same way.
20:57:08 <dmwit> kulakowski: And a bit short on math. =)
20:57:12 <kulakowski> dmwit: Exactly
20:57:22 * copumpkin sought inspiration in coq and found the way forward
20:57:45 <dmwit> But I've got a physicist for a wife, so I've got some strong recommendations for math books to read when I'm done with the intuition bits.
20:57:49 <copumpkin> when in doubt, pull out the coq
20:57:56 <acowley> copumpkin: You looked into your heart and found Ltac?
20:58:04 <copumpkin> acowley: no ltac, thankfully
20:58:10 <Rotaerk> dmwit, where'd you get that quote of yudkowsky?
20:58:45 <dmwit> Rotaerk: http://lesswrong.com/lw/qz/living_in_many_worlds/
20:59:00 <Rotaerk> ah
20:59:29 <btutt> oh, yeah I see what you mean, you still have to match against a pattern
21:00:17 <Rotaerk> dmwit, I just recognized the name because I used to follow http://singinst.org
21:01:02 <kulakowski> dmwit: The post on the uncertainty principle is where it really went downhill for me. From then on it's mostly philosophical crap, because I think you really need the math to back up any interpretation of QM. And in that post he says "Not grokking the math"...
21:01:28 <btutt> so i'd do something like TagSoup.TagOpen ((\x -> (x == (T.pack "span")) -> True) -> blah blah blah
21:01:52 <btutt> where x would have type T.Text
21:01:55 <dmwit> kulakowski: Well, to be fair, the very first post set the tone on philosophy (i.e. was very strong on it).
21:04:36 <kulakowski> dmwit: True
21:06:38 <aristid> btutt: -> is not a valid operator, so that expression seems to be rather invalid, and i can't guess what you intend
21:07:11 <btutt> trying to use the ViewPattern suggestion
21:07:30 <dibblego> @type \x y t -> (fst `x` t, snd `y` t)
21:07:31 <lambdabot> forall t a b t1 a1 b1 t2. (((a, b) -> a) -> t -> t1) -> (((a1, b1) -> b1) -> t -> t2) -> t -> (t1, t2)
21:09:30 <btutt> something like TagSoup.TagOpen (Data.Text.pack "span") _ -> blah blah
21:09:32 <btutt> that works
21:11:44 <btutt> i.e. TagSoup.Open ( (== T.pack $ "span") -> True) _ -> blah blah
21:12:30 <benjumanji> hi all, I am trying to cabal install hprotoc and am having a few problems
21:12:35 <benjumanji> http://hpaste.org/44229/hprotoc_build_problems
21:12:50 <benjumanji> I was wondering if anyone had had similar issues...
21:13:08 <dmwit> Booooo, tell the maintainer it's broken.
21:13:16 <applicative> copumpkin is studying coq? what next?
21:13:18 <dmwit> Bonus points if you send a patch adding Functor to the context. =)
21:13:23 <benjumanji> haha
21:13:25 <benjumanji> will do
21:13:36 <Eduard_Munteanu> btutt: should be like TagSoup.Open (T.pack -> "span") _ = ...
21:13:43 * Eduard_Munteanu has to go, school...
21:13:44 <Eduard_Munteanu> o/
21:13:51 <dmwit> benjumanji: Really, though, that particular error should be quite easy to fix.
21:13:58 <dmwit> I can help, if you're not sure how to do it yourself.
21:14:05 <copumpkin> applicative: I wouldn't say studying it :)
21:14:15 <copumpkin> I've read my book on coq and don't really have much desire to use it much
21:14:21 <benjumanji> I'll have a go, and if I fail miserably I'll come back begging for help later
21:14:24 <benjumanji> tx
21:14:26 <copumpkin> by my book on coq, I mean smerdyakov's book on coq
21:14:45 <applicative> smerdyakov??
21:14:53 <copumpkin> adam chlipala
21:14:56 <applicative> ah
21:14:59 <btutt> Eduard_Munteanu: T.unpack -> "span" would do the trick
21:15:01 <ddarius> "I wrote a book about Coq, then read it, and I still didn't know a thing about Coq."
21:15:10 <copumpkin> lol
21:15:11 <btutt> but the == doesn't do the unpack. ;)
21:15:36 <applicative> i started and gave up.  I have been annotating voevodsky's module with diagrams the last few days though
21:16:44 <dmwit> smerdyakov = adam chlipala?
21:16:45 <prsteele> is there a convention / styleguide for comments in Haskell, e.g. PEP8 in Python, or javadoc in Java?
21:16:52 <dmwit> And here I was thinking adamc = adam chlipala.
21:17:03 <applicative> it's pretty hilarious he has put it on github as 'vladimirias'
21:17:20 <dankna> prsteele, there is haddock
21:17:51 <prsteele> dankna: thanks
21:17:55 <applicative> if you follow the haddock rules it is converted into html like you see on hackage
21:18:42 <dankna> sure
21:19:27 <applicative> prsteele, i should say, to html or all and sundry other things.
21:20:17 <prsteele> applicative: LaTeX ? :P
21:20:37 <dankna> that would be nice
21:20:38 <applicative> yes, you probably have it if you have the haskell platform etc. try haddock --help
21:20:44 <dankna> but I don't think so, no
21:20:56 <applicative>                 --latex                   use experimental LaTeX rendering
21:20:56 <applicative>                 --latex-style=FILE        provide your own LaTeX style in FILE
21:21:03 <applicative> are among the options
21:21:19 <dankna> oh, great
21:22:28 <prsteele> applicative: what's your haddock -V
21:22:58 <prsteele> applicative: doesn't look like 2.6 has those options...
21:23:45 <btutt> ViewPatterns did the trick. Thanks!
21:27:25 <adnap> applicative, nice.
21:27:47 <adnap> we should all get category theoretic nicks.
21:28:41 <adnap> oh, this reminds me of halloween costumes.
21:28:55 <benjumanji> dmwit: fixed and patch sent. I guess I just needed someone to tell me to do it rather than be lazy.
21:29:57 <adnap> jumanji
21:30:42 <adnap> man, i would be so good at playing jumanji after seeing that movie.  you basically have to speedrun it.
21:31:15 <adnap> it's not really even a fun game if you cut out all the crazy stuff.
21:36:35 <cole_> What module is "lift" defined in?
21:38:23 <Pseudonym> @hoogle lift
21:38:23 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
21:38:23 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
21:38:23 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
21:38:34 <Pseudonym> Control.Monad.Trans
21:38:36 <adnap> Control.Monad?
21:39:38 <cole_> Are there other programming languages which have a hoogle equivalent?
21:43:05 <cole_> Why doesn't this work: "myPath = Path "/my/path"; newPath = lift (++ "/new") myPath "
21:43:44 <Zao> Any particular reason you do not use FilePath so you can be portable?
21:45:17 <aristid> myPath </> "new" would be it with FilePath
21:47:09 <cole_> Zao: I meant FilePath. It is FilePath.
21:47:21 <Zao> cole_: So why the hardcoded / in strings?
21:47:27 <cole_> I'm trying to add text to the filepath.
21:48:12 <cole_> Isn't filepath just "type FilePath = String" 
21:49:09 <tibbe> cole_: yes, at the moment
21:49:09 <aristid> > "a" </> "b"
21:49:10 <lambdabot>   Not in scope: `</>'
21:49:29 <aristid> tibbe: changing that would break a lot of code, i think
21:49:37 <tibbe> aristid: possibly yes
21:49:55 <tibbe> aristid: file paths are a mess, they're Unicode-ish on Windows and byte blobs on unix
21:51:33 <cole_> Okay, so I can use </> to add FilePaths. how do I add "IO FilePath" to a "FilePath"?
21:51:48 <aristid> tibbe: on most Linux systems it's UTF-8 these days, so that would be Unicode-ish, too
21:52:00 <aristid> cole_: fmap
21:52:17 <dankna> of course there's Unicode normalization forms to consider
21:52:24 <tibbe> aristid: I think any byte sequence is a valid path on Linux and only / is special
21:52:33 <dankna> Win uses UTF16 I think
21:52:38 <tibbe> aristid: there's a long ticket on Trac about it
21:52:45 <aristid> tibbe: well, right, the operating system doesn't enforce anything
21:52:46 <tibbe> dankna: yes
21:53:00 <BMeph> dankna: It's UCS-2, or as 	 like to call it, WTF-8. ;)
21:53:05 <dankna> and Mac uses UTF8 NFD
21:53:07 <dankna> haha, yeah
21:53:09 <aristid> isn't '\0' special too?
21:53:24 <aristid> but '\n' isn't, which makes writing safe shell scripts a pleasure
21:53:24 <Zao> BMeph: WTF-8 is the canonical denominator for UTF-8, I hear.
21:53:49 <Zao> BMeph: Windows hasn't spoken UCS-2 since NT4, you know.
21:54:00 <Zao> It would be nice if you stopped propagating ancient lies.
21:54:39 <Zao> (or somewhere around those times, not quite sure if it was 3.51 or 4.0 that were the last retarded one)
22:00:55 <btutt> UTF-16 is not UCS-2
22:01:13 <btutt> *mutters about surrogate pairs
22:01:40 <dankna> yes, we know
22:02:11 <kulakowski> aristid: IFS is fun!
22:04:51 <cole_> "fmap (</> "data") getHomeDirectory)" gives error: Coulnd't match expected type 'char' against inferred type '[Char]'n
22:11:38 <cole_> How do you convert from an "IO a" to an "a"?
22:11:44 <dmwit> You don't.
22:11:55 <dmwit> You convert from (a -> b) to (IO a -> IO b).
22:12:04 <dmwit> or from (a -> IO b) to (IO a -> IO b).
22:12:22 <dmwit> That is, you convert the consumer, not the producer.
22:14:14 <dmwit> Also, your pasted snippet works, so whatever error you have must be coming from somewhere else.
22:15:24 <dmwit> You may also be interested in getUserDataDir :: String -> IO FilePath, from the xdg-basedir package.
22:19:33 <NemesisD> are you not supposed to pattern match on double-quoted string literals?
22:19:58 <dolio> You can.
22:20:09 <NemesisD> i keep getting lexical errors
22:20:33 <NemesisD> oh wait, nevermind
22:21:00 <NemesisD> it was a case of escape fail
22:25:25 <xu888> Im getting a Parse Error in Pattern on a program I wrote, can anyone say what is causing that?: http://pastebin.com/qEifV42N
22:26:06 <dmwit> Don't mix spaces and tabs, mang.
22:26:58 <dmwit> Anyway, yeah, all the lines in a do-block (and in any other block, for that matter) must have the same amount of indentation.
22:26:58 <xu888> y... yeah?!
22:27:29 <xu888> oh... i see.  no, the pastebin added that mixed spacing
22:27:46 <dmwit> I don't believe you.
22:28:10 <dmwit> ah
22:28:16 <dmwit> There's another error, on line 6.
22:28:22 <dmwit> You probably meant to preface that line with a "let".
22:28:47 <xu888> yes, that was my next questino
22:28:49 <xu888> thanks
22:28:56 <dmwit> All the parens on that line are unnecessary, by the way.
22:29:20 <dmwit> Also, you can use "readLn" for the common getLine/read combo.
22:30:42 <xu888> oh.... i'm just working out of the wikibook and doing an exercise is alll....
22:31:46 <xu888> now it's complaining there is something wrong with putStrLn "The triangle has area of " in the last line
22:32:00 <dmwit> yeah
22:32:03 <dmwit> I was about to mention that.
22:32:15 <xu888> i dont see what is wrong
22:32:22 <dmwit> There are two easy solutions: wrap parens around the whole argument to putStrLn, or stick a $ between them.
22:32:47 <dmwit> xu888: It's parsing that as (putStrLn "The triangle") ++ show area ++ "blah"
22:32:58 <dmwit> Since the result of putStrLn is not a String, that doesn't work out very well.
22:33:25 <dmwit> The rule to remember is: function application binds tighter than anything else (except record syntax).
22:35:13 <xu888> ok, i put parens around it, but it still fails to compile in GHCi
22:35:40 <dmwit> Paste the updated version + error?
22:35:45 <dmwit> (Not in-channel, of course.)
22:36:47 <xu888> dosen't like the use of "/"
22:37:25 <dmwit> The exact error, please.
22:37:57 <xu888> http://pastebin.com/62EdEzjU
22:38:09 <ClaudiusMaximus> why is   instance Functor ((,) a)   defined in Control.Monad.Instances instead of somewhere i would find it without spending 10 minutes looking?  (eg: Data.Functor or Data.Tuple or ...)
22:39:21 <dmwit> xu888: Oh, you need to convert area back to a String.
22:39:25 <xu888> error = No instance for (Fractional Char [Char]) arising from the use of '/' at triArea.hs:6:12-40
22:39:31 <xu888> oh... yeah?
22:39:32 <dmwit> xu888: Try "show area" instead of "area".
22:39:55 <xu888> ok!  it seems to work now!
22:39:57 <xu888> thanks!
22:40:04 <dmwit> ClaudiusMaximus: Sorry.
22:40:13 <xu888> well... it compiled at least lol
22:42:02 <xu888> I've used :l triArea, now when I put in triArea at *Main>, I get :1:0: not in scope: 'triArea'
22:42:42 <dmwit> Perhaps you meant to put in "main"?
22:43:32 <xu888> this is the 1st time i've ever programmed in haskell, i don't know your meaning sorry
22:44:17 <dmwit> After loading triArea, the value to run is called "main", not "triArea".
22:44:37 <xu888> oh... ha ha, thanks!
22:44:38 <dmwit> When you write "main = do { blah blah blah }", that's defining a value called main.
22:44:55 <xu888> en
22:44:58 <xu888> i see that now
22:45:51 <xu888> ok, that is cool, it really works now!
22:45:55 <xu888> thanks so much
22:46:01 <xu888> mwit++
22:46:22 <xu888> dmwit++
22:46:50 <dmwit> cheers mate
22:47:24 <xu888> 88
23:29:49 <co_dh> Hello, anybody knows how can I got a date range, e.g. : 20110201  to 20110501 ? 
23:29:52 <bos> @pl \s r -> s + f r
23:29:52 <lambdabot> (. f) . (+)
23:31:45 <aristid> co_dh: data DateRange = FromTo Day Day
23:32:16 <co_dh> <aristid> which lib is it ? should I write it myself? 
23:32:32 <aristid> co_dh: yeah, i think there's no pre-defined type for that in time
23:32:51 <co_dh> ok, thanks. 
23:33:02 <aristid> but why do you put words in my mouth? you realize that <aristid> xxx looks like you quote me? :)
23:33:34 <aristid> :t let result=(.); argument=flip (.) in \f -> (argument.result) f (+)
23:33:34 <lambdabot> forall a b (f :: * -> *). (Functor f, Num (f b)) => (a -> b) -> f a -> f b -> f b
23:33:44 <aristid> :t \f -> (. f) . (+)
23:33:45 <co_dh> aristid: sorry for that. I'm use a web client of irc, it display user name inside <>
23:33:45 <lambdabot> forall b (f :: * -> *). (Functor f, Num b) => f b -> b -> f b
23:33:56 <co_dh> http://webchat.freenode.net/?channels=#haskell
23:34:16 <aristid> co_dh: displaying them in <> is normal :)
23:34:39 <aristid> :t let result=(Prelude..); argument=flip (Prelude..) in \f -> (argument.result) f (+)
23:34:39 <lambdabot> forall b c a. (Num c) => (b -> c) -> (a -> b) -> (a -> c) -> a -> c
23:34:42 <co_dh> I should use aristid: instead of <aristid>
23:34:52 <aristid> :t \f -> (Prelude.. f) Prelude.. (+)
23:34:53 <lambdabot> forall b a. (Num b) => (a -> b) -> b -> a -> b
23:35:13 <aristid> :t let result=(Prelude..); argument=flip (Prelude..) in \f -> (result.argument) f (+)
23:35:13 <lambdabot> forall a a1. (Num a) => (a1 -> a) -> a -> a1 -> a
23:35:30 <aristid> ok, that's better
23:35:40 <aristid> @pl \f -> (. f) . (+)
23:35:40 <lambdabot> (. (+)) . flip (.)
23:36:09 <aristid> :t (result.argument) (+) argument
23:36:10 <lambdabot> Not in scope: `argument'
23:36:10 <lambdabot> Not in scope: `argument'
23:36:22 <aristid> :t let result=(Prelude..); argument=flip (Prelude..) in (result.argument) (+) argument
23:36:22 <lambdabot> forall a b. (Num b) => (a -> b) -> b -> a -> b
