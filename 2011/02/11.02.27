00:12:41 <gwern> @quote problem.*programs
00:12:42 <lambdabot> gwern says: my problem is that most programs I use already exist
00:13:07 <Veinor> wat?
00:13:33 <gwern> Veinor: the context was me complaining that I didn't have any interesting ambitious haskell projects
00:13:40 <Veinor> ahh
00:13:54 <gwern> so you understand my point
00:15:07 <btutt> :)create a haskell <-> objc 2.0 binding 
00:15:37 <gwern> I wouldn't use that
00:26:06 <neilk_> Just a general question about Haskell, or rather, laziness
00:26:37 <neilk_> let's say I wanted to implement simulated annealing. Is this going to be really hard in Haskell? I have difficulty imagining how to do it without state.
00:27:48 <c_wraith> what's state got to do with laziness?
00:27:53 <koninkje> Haskell has plenty of state...
00:29:26 <neilk_> okay, perhaps I need an education, but my question really doesn't make sense?
00:30:19 <neilk_> the only simulated annealing impl I can find in Haskell uses a C library
00:31:17 <koninkje> For intense mathematical operations laziness can bite you if you do things naively; but so long as you're not naive about it, Haskell rocks for that kind of thing
00:31:25 <neilk_> oh, nm, there is that Learn you a Haskell thing.
00:31:28 <Jafet> I hear that using Haskell without knowing Haskell is hard
00:31:32 <neilk_> I hated that the first time I tried to read it.
00:32:08 <koninkje> I'd guess the reason for just binding a C library is that if someone else has already done all the hard optimizing work for you...
00:33:45 <Jafet> For example, the gcc developers
00:33:48 <wavewave> will making a graph database in haskell be competitive?
00:34:08 <Jafet> Probably not, since I don't know any other graph database in haskell it would compete with
00:35:09 <wavewave> Jafet: I mean can  haskell compete with other implementation in other languages?
00:35:21 <wavewave> mostly Java, I think.
00:35:52 <arcatan> neilk_: there is the concurrent-sa package, which i think is a Haskell implementation of simulated annealing
00:35:52 <augur> ddarius! :|
00:35:57 <arcatan> neilk_: http://hackage.haskell.org/package/concurrent-sa
00:36:14 <dibblego> competing against Java is like punching up pre-school kids
00:36:18 <neilk_> arcatan: thanks
00:36:35 <wavewave> yes. concurrent-sa,  I wanted to tell this... but didn't remember the name~
00:37:12 <Jafet> What impure thoughts, dibblego
00:37:57 <wavewave> dibblego: but java has a great speed these days. 
00:39:32 <wavewave> anyway, I think haskell can shine in graph database things.
00:40:12 <wavewave> some cool design with nice type system.. 
00:41:21 <wavewave> algebraic data type is a graph.
00:41:25 <Jafet> wavewave, frankly, asking that question here is like going into a Porsche showroom and asking the salesman whether it would be faster to take a train or a bus from Buckingham to Queensborough
00:41:38 <dibblego> not sure what to say mate, I don't like punching kids, even the fastest ones
00:43:04 <Jafet> Er, a train or a car
00:49:00 <arcatan> can you get from Buckingham to Queensborough by train?
00:49:28 <Jafet> Beats me, I've never even left Heathrow
01:02:40 <earthy_> wavewave: there's no reason why it shouldn't be competitive, especially when compared to java
01:04:07 <augur> CTists, why are the epis in Sets the surjections?
01:04:12 <augur> surely thats not true
01:05:11 <augur> i mean, if X = {1,2,3}, Y = {1,2}, Z = {1,2}, we could have e : X -> Y where e(1) = e(2) = 1, and e(3) = 2
01:05:38 <augur> and have f : Y -> Z where f(1) = 1, f(2) = 2, and g : Y -> Z where f(1) = 2, and f(2) = 1
01:05:46 <augur> obviously f != g, but e is a surjection
01:07:18 <augur> hmm.. no i think i might have gotten this wrong
01:07:55 <augur> ok nevermind
01:11:06 <Kaidelong> wavewave: If you care about performance, you can probably get GHC to produce things that are faster than what the java compiler can produce, at least. Although if you care about performance you'll probably want something like C or FORTRAN perhaps with a propietary compiler
01:11:18 <solrize> is 6.12 ghc still current, i.e. should i report bugs in it that aren't too serious? 
01:11:53 <Kaidelong> not that beating Java on performance is that high a bar
01:12:16 <Kaidelong> although I heard they've come a long way
01:12:40 <Polarina> solrize: does the bug occur in more recent versions of ghc as well?
01:12:42 <Bynbo7> depends, it's possible to write fast java too
01:12:54 <solrize> Polarina, 6.12 is what i'm using 
01:12:57 <Bynbo7> and the JVM is very impressive
01:13:03 <solrize> i haven't tested with anything newer
01:13:03 <Kaidelong> Bynbo7: Right, but having a runtime system that permits reflection imposes an unavoidable cost
01:13:22 <Kaidelong> not that I'm saying it is a bad idea
01:13:28 <solrize> Kaidelong, ??
01:13:28 <Polarina> solrize: Try to see if you can reproduce the bug in a more recent version of GHC. :)
01:13:43 <Kaidelong> solrize: type information has to be kept at runtime
01:13:44 <solrize> the reflection info can be in some separate gdb-like table can't it?
01:14:07 <ivant> Kaidelong, server compiler in Sun JVM is very smart, in particular, it can figure out that you are not using reflection and optimize the code very efficiently
01:14:20 <Kaidelong> ooh
01:14:27 <ivant> and deoptimize it later if necessary
01:14:39 <solrize> java sucks so badly as a language that it's probably saner to use some other jvm-targeting compiler
01:14:42 <Kaidelong> hmm, so you really should use the server version for java if you care about performance?
01:15:10 <Kaidelong> solrize: I think what ivant mentioned would work for anything that targets the jvm
01:15:20 <ivant> Kaidelong, that goes without saying. Other VMs do some cool stuff too. JRockit does some nifty optimizations.
01:15:46 <Kaidelong> anyway last I checked GHC defeats Java on most benchmarks, although that might have changed
01:16:25 <ivant> Kaidelong, do you mean the language shootout? As far as I remember, Haskell code there was not particularly idiomatic
01:16:26 <Kaidelong> although performance really should be the least of your worries
01:16:28 <solrize> you have to write pretty contorted code to make ghc output run fast
01:17:39 <Kaidelong> ivant: Certainly, although what's idiomatic in haskell is different from what's idiomatic in say, C
01:17:57 <Kaidelong> and if you really care about performance above all else you should be using something like C anyway
01:18:23 <ivant> Kaidelong, or hand optimized assembly for your particular architecture, yes :-)
01:19:23 <solrize> i wish hackage had some kind of imperative EDSL that used ghc's type system but that made super-fast code with LLVM
01:19:30 <solrize> C should be banned
01:19:43 <Bynbo7> very few people can actually hand optimise assembly better than most compilers these days
01:19:48 <Kaidelong> how's disciple on that?
01:20:03 <Bynbo7> solrize: well, there is the LLVM package...
01:20:11 <Kaidelong> Bynbo7: from what I remember there are some surprises where compilers can be pretty bad about certain things, like where to place jumps
01:20:23 <Kaidelong> but generally yes
01:20:28 <solrize> disciple is very interesting
01:21:07 <Kaidelong> my dad's working on a purely functional language designed to look like imperative programming
01:21:14 <solrize> but i was thinking of something usable for writing functions callable from GHC
01:21:18 <solrize> the way you'd use the C FFI
01:21:31 <Kaidelong> from what I've seen of it he's somewhat rediscovered haskell, except streams are slightly more specific than monads I suppose
01:21:31 <solrize> disciple has a garbage collector
01:23:35 <mm_freak_> how do i regain access to code.haskell.org?
01:23:49 <mm_freak_> is there some standard process for former users?
01:26:06 <Bynbo7> you'd probably do better to ask in #ghc
01:26:07 <mm_freak_> Bynbo7: "you"?
01:26:07 <Bynbo7> you...
01:26:07 <Bynbo7> ask in #ghc -_-
01:26:07 <mm_freak_> why?
01:26:07 <Bynbo7> mainly because the people who could tell you spend more time in there than here
01:26:07 <mm_freak_> ah, ok
01:26:07 <Bynbo7> (ie Igloo and others)
01:26:07 <mm_freak_> thanks
03:26:29 --- topic: '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
03:26:29 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Fri Jan 28 14:21:19 2011]
03:33:45 <chrisdone> I just saw this compile error when building web-encodings
03:33:47 <ezyang> tim_: Here's another way of thinking about it that may be more immediately useful: if you have IO a and you have a function a -> IO b (some function that looks at the return value of the original IO), you can put them together with >>=. The end result is still IO b, that is, you didn't "escape" the IO monad, but the function can act as if it had access to the value. 
03:33:47 <chrisdone> Web/Encodings.hs:181:13:
03:33:47 <chrisdone>     Warning: Pattern match(es) are overlapped
03:33:47 <chrisdone>              In a case alternative:
03:33:47 <chrisdone>                  '#' : 'x' : hex -> ...
03:33:47 <chrisdone>                  '#' : 'X' : hex -> ...
03:33:48 <chrisdone>                  '#' : dec -> ...
03:33:59 <chrisdone> I don't get it.
03:34:14 <ezyang> Mm, that is a bit odd. 
03:34:23 <chrisdone> Maybe there's more in the file that it's talking about...
03:34:40 <pozic> chrisdone: that is not odd.
03:35:09 <pozic> chrisdone: it is a true statement that they are overlapped, but it is also true that there is no complete overlap.
03:35:19 <tim_> ezyang - thanks, yep that's really useful
03:36:04 <pozic> chrisdone: also, it is not an error. It is a warning.
03:36:08 <chrisdone> pozic: What I'm wondering is why bother reporting it?
03:36:19 <tim_> I think I'm still in this mindset of thinking like I have to get values out of the IO monad to use them which is the wrong approach - I should be lifting pure computations into the IO monad to operate on effectful values
03:36:25 <pozic> chrisdone: because the compiler was instructed to do that.
03:36:34 <pozic> chrisdone: you can disable those arnings.
03:36:37 <pozic> chrisdone: warnings*
03:36:52 <tim_> which i guess is the whole point - you keep the IO in the type signature to denote that  the computation depends on the Real World in some sense.
03:36:56 <tim_> thanks!
03:38:01 * hackagebot Annotations 0.1.3 - Constructing, analyzing and destructing annotated trees  http://hackage.haskell.org/package/Annotations-0.1.3 (MartijnVanSteenbergen)
03:39:32 <chrisdone> pozic: The code's compiled with -Wall. I just tried this case with -Wall too:
03:39:35 <chrisdone> f x = case x of
03:39:35 <chrisdone>         'b' : "ar" -> ()
03:39:35 <chrisdone>         'b' : "az" -> ()
03:39:35 <chrisdone>         _     -> ()
03:39:43 <chrisdone> (And also mere "bar" and "baz".)
03:39:50 <chrisdone> But I don't get an overlap warning.
03:40:12 <chrisdone> Hm.
03:40:24 <pozic> chrisdone: that is fairly surprising, but the former information was not surprising.
03:40:32 <pozic> chrisdone: also: who cares about warnings? 
03:40:48 <pozic> chrisdone: the matching stuff has already been solved by Neil Mitchell a few years ago.
03:40:49 <chrisdone> Ah, it happens when you put in a free variable.
03:40:58 <alex404> If you're going to do an operation on the entire list any, is there much penalty to doing something like: toList . vectorFun . fromList $ xs
03:40:59 <pozic> chrisdone: all someone has to do is port that to GHC.
03:41:04 <alex404> *anyway
03:41:09 <chrisdone> (Change "ar"/"az" to r.)
03:43:04 <Bynbo7> alex404: depends, can you give more details? (if fectorFun is expensive on lists, but cheaper on (i assume) vectors, then it may be beneficial
03:44:48 <alex404> Bynbo7: But I guess in that case, would it have been much cheaper to simply have the data structure as a vector in the first place? For example, the statistics package is really nice, but it's all on vectors. So if you're using lists, you'd have to switch data structures every time. Is there a big penalty for this?
03:45:31 <Bynbo7> there shouldn't be, but if you can move to just using vectors, then you might be better off
03:46:17 <alex404> Bynbo7: Indeed. But one shouldn't consider it crippling beyond some manageable constant factor to go back and forth?
03:46:31 <Bynbo7> hopefully not
03:46:34 <alex404> :)
03:46:50 <alex404> I guess I'll just need to benchmark it at some point
03:50:04 * hackagebot wraxml 0.4.3.1 - Lazy wrapper to HaXML, HXT, TagSoup via custom XML tree structure  http://hackage.haskell.org/package/wraxml-0.4.3.1 (HenningThielemann)
03:50:07 <solrize> yawwn
03:50:09 <solrize> sorry
03:54:09 <ClaudiusMaximus> i asked, can Cabal handle C++ source files semi-automatically, similarly to how it handles C source files? -- the answer is yes, just list them in the "C-sources:" stanza and it magically works :)
03:54:58 <chrisdone> ClaudiusMaximus: "Works" meaning what?
03:55:32 <ClaudiusMaximus> chrisdone: gets compiled as C++ and linked with the program, which runs as well as it would if i manually invoked g++ and passed the .o file to ghc --make
03:56:29 <chrisdone> ClaudiusMaximus: Do you have to specify explicit calling conventions in your C++ file, in order to call it from Haskell?
03:58:06 <ClaudiusMaximus> chrisdone: yes.  i have one 'template<typename T> compute(..., T v, ...);' and 'extern "C" { compute_f32( ... float v ...) { compute( ... v ...) } ...etc... }'
03:58:44 * chrisdone nods
03:59:02 <ClaudiusMaximus> chrisdone: the alternative would be to reverse engineer the C++ name mangling; and then get into headaches with template specialization anyway...
03:59:18 <ClaudiusMaximus> (or something, my C++ is weak!)
04:00:24 <luite> does your package also work with ghci on windows?
04:00:48 <ClaudiusMaximus> luite: mine? i doubt it, it's an executable that uses GLUT :)
04:10:08 <ClaudiusMaximus> @hoogle FilePath -> IO Integer
04:10:09 <lambdabot> Trace.Hpc.Mix getModificationTime :: FilePath -> IO Integer
04:10:09 <lambdabot> Prelude readIO :: Read a => String -> IO a
04:10:09 <lambdabot> System.IO readIO :: Read a => String -> IO a
04:16:37 <hpc> did someone say my name?
04:16:42 <hpc> oh, lambdabot
04:22:56 <Jafet> @vixen say my name too
04:22:57 <lambdabot> Pleased to meetcha!
04:23:20 <ddarius> This place is ridiculous.
04:24:28 <dolio> @qwe1234
04:24:29 <lambdabot> Unknown command, try @list
04:24:33 <dolio> @quote qwe1234
04:24:34 <lambdabot> qwe1234 says: lisp is a wannabe python from the seventies.
04:25:36 <hpc> @protontorpedo
04:25:36 <lambdabot> so haskell is free?
04:26:25 <dolio> protontorpedo is too repetitive.
04:26:30 <dolio> @keal is where it's at.
04:26:30 <lambdabot> there is no way to prove the failsafe exists
04:26:56 <hpc> @keal?
04:26:56 <lambdabot> i can explain why something is without knowing what the rules decided by man are
04:27:13 <hpc> oh, wannabe philosiraptor?
04:29:06 <dolio> Mostly just incoherent nonsense, from what I've seen.
04:29:25 <dolio> Although, that might fit with your description.
04:29:30 <hpc> @keal
04:29:31 <lambdabot> i changed my user od
04:32:23 <hpc> hehe
04:33:07 <chrisdone> Is there some software that makes reading academic papers better than merely reading? Like being able to click notes and references, links to the authors, links to references' DOI page, publication home page, etc.? I know papers are aimed to be printed but... it feels like academic publishing hasn't advanced since the 70s.
04:33:57 <ddarius> Well, TeX was released in the 70s...
04:34:10 <chrisdone> Exactly…
04:34:35 <hpc> can't tex do what you are asking?
04:34:50 <chrisdone> I don't know. Can it?
04:35:06 <Jafet> Sure, given a suitable processor
04:35:10 <Jafet> I think pdflatex will do it
04:35:27 <Jafet> (Can you even put links in postscript?)
04:36:26 <Bynbo7> chrisdone: it can, there's a hyperlink package
04:41:54 <luite> chrisdone: you can make collections with mendeley, which automatically extracts some metadata or retrieves it from a website
04:42:28 <luite> you can organize your references in collections, but I don't believe it automatically creates links
04:44:18 * hackagebot http-monad 0.1.0.1 - Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation  http://hackage.haskell.org/package/http-monad-0.1.0.1 (HenningThielemann)
04:44:32 <levifikri> Hi, is Data.Map efficient for frequent insertion?
04:45:45 <levifikri> or is there any Map like data type in Haskell which is more suitable for it?
04:45:57 <sipa> a mutable array? ;)
04:46:07 <Bynbo7> what sorts of numbers are you thinking about?
04:46:21 <levifikri> I need to be able to lookup a value fast
04:46:29 <levifikri> a key I meant
04:46:39 <ddarius> luite: The "automatically" is a bit overstated.
04:46:42 <sipa> lookup and insert are both O(log n), with n the number of elements already in there
04:46:43 <Bynbo7> might want to check out tibbe's recent package
04:47:00 <levifikri> My concern is the memory
04:47:10 <Bynbo7> what types are the keys?
04:47:15 <luite> ddarius: yeah it sometimes get it right :p
04:47:20 <levifikri> Is GHC allocate new memory each time it's inserted?
04:47:22 <luite> gets
04:47:38 <Jafet> Besides, we have citeseer for that sort of thing.
04:47:51 <Bynbo7> luite: well it has to, but it will also garbage collect previous values
04:47:55 <levifikri> Bynbo7 The keys are ByteString
04:48:10 <Bynbo7> there are better structures to use for that then. 
04:48:23 <Bynbo7> like the one i mentioned
04:48:36 <levifikri>  tibbe's recent package?
04:48:41 <levifikri> what is it?
04:48:55 <luite> yes, mendely does have a related papers feature though, but citeseer is usually better
04:49:05 <luite> mendeley
04:49:06 <Bynbo7> luite: sec, finding it
04:49:40 <Bynbo7> levifikri: http://hackage.haskell.org/package/unordered-containers
04:52:09 <levifikri> Bynbo7 thx!
04:53:01 <Bynbo7> levifikri: I'm sure tibbe would be very happt to hear how it performs for you, and any issues you have
04:54:09 <levifikri> any paper or documentation on how to use it?
04:55:29 <Bynbo7> it's got almost exactly the same interface as Data.Map, it shouldn't need much documentation
04:55:31 <levifikri> oh, there is. http://blog.johantibell.com/
05:02:28 <noetic> I'm a haskell newbie, so forgive this naive question. Given ($) :: (a -> b) -> a -> b, then why do we have ($ 3) :: (Num a) => (a -> b) -> b? I was under the impression the first parameter should get replaced by currying. But the first parameter here is a function (a -> b)...
05:03:03 <hpc> noetic: you wrote a section
05:03:23 <hpc> (:op: foo) f = f :op: foo
05:03:50 <hpc> (:op:) foo f = foo :op: f
05:04:17 <hpc> normally, ($) 3 wouldn't typecheck
05:04:22 <hpc> but lambdabot has funny instances
05:04:24 <hpc> :t ($) 3
05:04:25 <lambdabot> forall a b. (Num b) => a -> b
05:04:28 <Bynbo7> ($ 3) is the same as (\f -> f $ 3)
05:04:31 <hpc> :t ($ 3)
05:04:32 <lambdabot> forall a b. (Num a) => (a -> b) -> b
05:04:32 <noetic> Excellent! Thanks. I forgot about sections :)
05:06:36 <levifikri> Hi, what are the differences between Data.Map and Data.Hashtable?
05:07:17 <Ke> map is a tree and hashtable a linear data structure typically
05:07:29 <Ke> so mostly performance
05:07:52 <Bynbo7> hashtables don't make much sense in haskell
05:08:15 <Ke> in IO everything makes sense
05:08:16 <Bynbo7> (things like tibbe's hashed array mapped trie type makes much more sense)
05:08:24 <Ke> but it makes code ugly
05:09:02 <Saizan> is Data.Hashtable still slower than Data.Map for most purpouses?
05:09:47 <n00p> I'd say a hashed array mapped trie makes more sense in general, than a hashtable... but then, I'm a fan of tries :/
05:10:14 <n00p> Not just in Haskell. I use tries all over the place. Heck, I don't even know Haskell yet :P
05:12:05 <tim_> hey all - might any of you guys be able to shed light on a weird type error I'm having? code is at https://gist.github.com/846190- I get "couldn't match expected type Result [Review] against inferred type IO [Review] at line 30, but I'm not entirely sure why the compiler's inferring the type IO [Review] at that point - with the type signature of reviews :: IO (Result [Review]) surely ghc should expect reviews' to have type Result [Review]?
05:12:27 <tim_> sure it's something simple I'm missing but it's frustrating me no end.
05:13:18 <Bynbo7> what is the type of json in reviews?
05:13:34 <Bynbo7> is it really an IO action?
05:13:35 <tim_> it'd be....
05:13:43 <Bynbo7> also, that style is pretty horrible
05:13:44 <Saizan> tim_: an inner do like that is still expected to be of the same monad as the overall do block
05:13:50 <tim_> IO (Result [JSObject a])
05:13:52 <hpc> tim_: reviews' <- do ...
05:14:02 <tim_> Saizan - aah, gotcha
05:14:02 <hpc> tim_: that action on the rhs is IO
05:14:08 <hpc> or supposed to be
05:14:12 <tim_> aaah, cool I see
05:14:32 <tim_> in that case, is there an idiomatic style for writing nested monadic actions like this?
05:14:42 <Saizan> return $ do ..
05:14:49 <tim_> aha!
05:14:49 <Bynbo7> there's no need for it to be nested
05:14:51 <tim_> oh that's neat
05:14:51 <hpc> i would do
05:15:00 <hpc> let reviews' = do ...
05:15:16 <ddarius> The monad laws say there is no reason to.
05:15:19 <hpc> return $ do ... is kinda icky
05:15:22 <Bynbo7> you can completely remove the reviews' <- do and return reviews' lines
05:15:32 <hpc> oh, or that
05:15:33 <hpc> lol
05:15:50 <tim_> hah yes
05:15:55 <Saizan> he needs a return around makeReviews
05:15:56 <Bynbo7> i don't think return $ do ... will work
05:16:02 <hpc> Bynbo7: yeah it will
05:16:05 <hpc> you delete the last line
05:16:12 <Saizan> is json in IO?
05:16:13 <hpc> and end the block with return $ do {that action}
05:16:27 <Bynbo7> but there's no need...
05:16:29 <tim_> hang on
05:16:36 <tim_> return json>>= makeReviews
05:16:37 <aavogt> usually people don't indent the bodies of modules
05:16:39 <Saizan> no
05:16:42 <tim_> should do the trick right
05:16:49 <tim_> aah, that's also good to know
05:16:54 <Saizan> return (json >>= makeReviews)
05:16:59 <tim_> yup
05:17:10 <tim_> cool, thanks all!
05:17:12 <ddarius> aavogt: How then will we know when our modules end?!
05:17:17 <Bynbo7> getJsonFile "../data_imports/reviews.json" >>= makeReviews . join should do the trick i think
05:17:38 <Saizan> Bynbo7: check the type of makeReviews
05:17:43 <Bynbo7> hmm, or something like that
05:18:11 <Bynbo7> isn't that function just fmap makeReviews $ getJsonFile "../data_imports/reviews.json"?
05:18:18 <tim_> aah, fmap!
05:18:25 <tim_> of course
05:18:25 <Bynbo7> or something extremely close to it, needs a join
05:18:31 <aavogt> sequence . map = mapM
05:18:34 <tim_> yep I'm seeing this now
05:18:37 <Saizan> fmap (makeReviews =<<)
05:18:47 <Bynbo7> there we go
05:19:10 <aavogt> ddarius: braces
05:19:51 <aavogt> @src readFile
05:19:52 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
05:20:17 <ddarius> aavogt: Ashley Yakeley -always- uses braces and semicolons and -always- indents.
05:20:20 <aavogt> tim_: you can use that instead of the openFile
05:20:40 <aavogt> ddarius: leading semicolons?
05:21:01 <ddarius> I'm pretty sure they're trailing, but I haven't looked in a while.
05:21:02 <hpc> > (do {;;;;;;;;5}) 5
05:21:03 <lambdabot>   5
05:21:05 <tim_> aavogt: thanks!
05:21:57 <ddarius> > let ;;;; in 3
05:21:59 <lambdabot>   3
05:22:07 <hpc> ddarius: o.O
05:22:16 <hpc> oh right, empty let
05:22:18 <hpc> > let in 3
05:22:19 <lambdabot>   3
05:22:48 <hpc> > let let in let let in let in in 3
05:22:49 <lambdabot>   <no location info>: parse error on input `in'
05:22:51 <hpc> > let let in let let in let in in in 3
05:22:52 <lambdabot>   <no location info>: parse error on input `in'
05:23:06 <hpc> bah
05:23:16 <ddarius> let let is never legal.
05:23:22 <aavogt> > let inlet = let in x in inlet
05:23:23 <lambdabot>   x
05:23:28 <hpc> :D
05:23:39 <aavogt> @quote evar
05:23:40 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
05:23:52 <ddarius> > do do 3
05:23:53 <lambdabot>   3
05:24:12 <tim_> Bynbo7: it's not quite  - getJsonFile returns IO (Result [JSONObject JSONValue]) rather than IO [JSONObject JSONValue]
05:24:18 <Bynbo7> > do do do do do ()
05:24:19 <lambdabot>   ()
05:24:40 <Bynbo7> tim_: sure, i said it was close to fmap, see what Saizan said earlier
05:24:43 <sipa> is () a monad>
05:24:44 <sipa> ?
05:24:49 <Saizan> no
05:24:52 <aavogt> @type do ()
05:24:53 <lambdabot> ()
05:24:56 <Saizan> do x = x
05:25:21 <tim_> aha yes!
05:25:31 <aavogt> why didn't they add an unnecessary Monad m =>  there though?
05:25:34 <xplat> the monad stuff doesn't come in until you use a ;
05:25:37 <ddarius> Also a monad is a type constructor of kind * -> * (plus some operations), which the value () certainly isn't, nor is the type ().
05:25:41 <tim_> > :t =<<
05:25:42 <lambdabot>   <no location info>: parse error on input `:'
05:26:03 <Saizan> :t (=<<)
05:26:04 <ddarius> > do ;;;;;;;; ()\
05:26:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:26:05 <lambdabot>   <no location info>: parse error on input `\'
05:26:06 <ddarius> > do ;;;;;;;; ()
05:26:08 <lambdabot>   ()
05:26:13 <Saizan> f =<< m = m >>= f
05:26:13 <ddarius> xplat: That's not true either.
05:26:15 <aavogt> for consistency so that 'do' always adds such a constraint
05:26:23 <xplat> ddarius: wiseass :P
05:26:28 <tim_> @type =<<
05:26:29 <lambdabot> parse error on input `=<<'
05:26:35 <juturna> how do I bring arbitrary functions into a monad? I know I need to use lift somehow... just as an example, return 2 >>= f (* 2) what would the definition of f be
05:26:35 <tim_> @type (=<<)
05:26:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:26:58 <xplat> aavogt: then it wouldn't be a simple syntactic rewriting
05:26:59 <ddarius> aavogt: It's a place where the Report isn't too clear, but it do-notation is a purely syntactic translation, and do x -> x.
05:27:15 <tim_> aha, neat!
05:27:30 <Bynbo7> @src (=<<)
05:27:30 <lambdabot> f =<< x = x >>= f
05:27:34 <aavogt> xplat: I guess they could specify   do x -> x `asTypeOf` (return undefined)
05:27:35 <chrisdone> jutaro: (Num a,Monad m) => (a -> a) -> a -> m a
05:27:47 <xplat> juturna: f = liftM
05:27:50 <tim_> so fmap (foo =<<) is equivalent to fmap . fmap?
05:28:00 <ClaudiusMaximus> @hoogle Int -> [IO a] -> IO [a]
05:28:01 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
05:28:01 <lambdabot> Data.Generics.Aliases ext1R :: (Monad m, Data d, Typeable1 t) => m d -> m (t e) -> m d
05:28:01 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
05:28:19 <hpc> :t const flip
05:28:20 <lambdabot> forall (f :: * -> *) a b b1. (Functor f) => b1 -> f (a -> b) -> a -> f b
05:28:26 <hpc> :P
05:28:30 <tim_> :t flip
05:28:31 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:28:31 <xplat> aavogt: sure, but that would be gross Xp
05:28:37 <Saizan> juturna: either return 2 >>= return . (*2) or liftM (*2) (return 2)
05:28:38 <juturna> so why doesn't return 2 >>= liftM (* 2) work
05:28:47 <hpc> :t const sequence
05:28:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> [m a] -> m [a]
05:28:52 <hpc> aha! :P
05:29:09 <chrisdone> juturna: As I said in the type...
05:29:13 <tim_> @hoogle (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:29:14 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
05:29:14 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
05:29:14 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
05:29:16 <chrisdone> In your example, the type of f would be: (Num a,Monad m) => (a -> a) -> a -> m a
05:29:26 <aavogt> xplat: nobody writing haskell would see it, except in the type of    do a
05:29:35 <chrisdone> :t liftM (*2)
05:29:36 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a -> m a
05:29:38 <Saizan> juturna: because >>= expects an (a -> m b) as second argument, while (liftM (*2)) is m a -> m a
05:29:53 <xplat> aavogt: and the output of @undo
05:30:16 <juturna> thanks
05:30:19 <xplat> also, it'd make things needlessly harder for the optimizer
05:30:24 <Saizan> tim_: (fmap . fmap)
05:30:36 <aavogt> @undo [ x | x <- xs, x <- return (x+1) ]
05:30:37 <lambdabot> concatMap (\ x -> concatMap (\ x -> [x]) return (x + 1)) xs
05:31:01 <hpc> @djinn (a -> a) -> a -> m a
05:31:01 <lambdabot> -- f cannot be realized.
05:31:07 <hpc> @djinn Monad m => (a -> a) -> a -> m a
05:31:08 <lambdabot> f _ a = return a
05:31:08 <aavogt> @@ type undo [ x | x <- xs, x <- return (x+1) ]
05:31:09 <lambdabot>  type undo [ x | x <- xs, x <- return (x+1) ]
05:31:14 <c_wraith> aavogt: that reduces to xs
05:31:28 <hpc> don't you want @.?
05:31:34 <aavogt> @type \xs -> concatMap (\ x -> concatMap (\ x -> [x]) return (x + 1)) xs
05:31:36 <lambdabot>     Couldn't match expected type `[a]'
05:31:36 <lambdabot>            against inferred type `a1 -> m a1'
05:31:36 <lambdabot>     In the second argument of `concatMap', namely `return'
05:31:45 <aavogt> c_wraith: no @undo is broken
05:31:48 <hpc> @. type undo [ x | x <- xs, x <- return (x+1) ]
05:31:49 <lambdabot> Not in scope: `xs'
05:32:05 <aavogt> > [ x | x <- [0 .. 5], x <- return (x+1) ]
05:32:07 <lambdabot>   [1,2,3,4,5,6]
05:32:30 <hpc> oh right, because list comprehension translates to do
05:32:39 <c_wraith> oh.
05:32:40 <c_wraith> shadowing
05:32:41 <c_wraith> eww
05:33:02 <aavogt> name shadowing is for exams
05:33:46 <Twey> Heh
05:33:54 <hpc> name shadowing is "that thing you don't do and why doesn't it give a warning"
05:34:03 <Saizan> silly ad-hoc pretty printers
05:34:08 <aavogt> xplat: I think asTypeOf is going to have no runtime cost for sensible compilers
05:34:18 <aavogt> @src asTypeOf
05:34:18 <lambdabot> asTypeOf = const
05:35:40 <xplat> aavogt: i don't think any of these are super-strong reasons for not having the rewriting introduce a type constraint, but since i think your reason for having it introduce one is also incredibly weak ...
05:36:29 <aavogt> Saizan: so @undo is broken because it doesn't print as    concatMap (\ x -> concatMap (\ x -> [x]) (return (x + 1))) xs, but represents it as that internally?
05:36:33 <aavogt> xplat: agreed
05:37:05 <Saizan> aavogt: that's my guess
05:38:34 <ddarius> Feel free to poke through the source and fix it.
05:40:02 <Saizan> you could even fix pl's parser and make it report a sensible error for (n+3)-tuples
05:40:35 <hpc> @pl \x y z f -> (x, y, z, f)
05:40:35 <lambdabot> (,,,)
05:40:47 <hpc> @pl \x y z f q -> (x, y, z, f, q)
05:40:48 <lambdabot> (,,,,)
05:40:48 <Zenon1> hum has anyone here got any experience installing the SDL haskell module on windows?
05:40:51 <Saizan> @pl \(a,b,c) -> a
05:40:51 <lambdabot> (line 1, column 6):
05:40:51 <lambdabot> unexpected ","
05:40:51 <lambdabot> expecting letter or digit, operator or ")"
05:40:51 <lambdabot> ambiguous use of a non associative operator
05:41:02 <hpc> oh lol
05:41:20 <hpc> @pl (x, y) -> x
05:41:20 <lambdabot> (line 1, column 8):
05:41:20 <lambdabot> unexpected ">" or "-"
05:41:20 <lambdabot> expecting variable, "(", operator or end of input
05:41:23 <hpc> er
05:41:26 <hpc> @pl \(x, y) -> x
05:41:26 <lambdabot> fst
05:43:27 <ion> -lh
05:43:29 <ion> whoops
05:45:42 <hpc> > fromEnum "$K("
05:45:42 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
05:45:43 <lambdabot>    arising from a use of `...
05:46:06 <hpc> > "$K(" < "$K)"
05:46:07 <lambdabot>   True
05:46:21 <hpc> > ord '(' - ord ')'
05:46:22 <lambdabot>   -1
05:46:24 <hpc> neat
05:56:01 <kniu> @hoogle (a, b) -> (a -> c) -> (c, b)
05:56:02 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
05:56:02 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
05:56:02 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
05:56:37 <kniu> srsly?
05:56:41 <c_wraith> @hoogle Control.Arrow.first
05:56:41 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
05:56:53 <Bynbo7> :t flip first
05:56:55 <lambdabot> forall b c d. (b, d) -> (b -> c) -> (c, d)
05:58:50 <hpc> @hoogle Word8
05:58:51 <lambdabot> Data.Word data Word8
05:58:51 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
06:05:36 <ClaudiusMaximus> any thoughts on this function?  is something similar/better available somewhere on hackage?  http://hpaste.org/44348/concurrent_mapm
06:06:04 <hpaste> ClaudiusMaximus pasted "concurrent mapM"  http://hpaste.org/44348
06:06:14 <Bynbo7> :O
06:06:21 <Bynbo7> hpaste is back!
06:06:40 <kramble> hi, iplayed a bit with fix function, and I'm asking myself why this function exist ? it's look like more a joke than a usefull function
06:06:55 <c_wraith> kramble: it's general recursion
06:07:07 <Bynbo7> kramble: any recursive function can be written using fix.
06:07:22 <Bynbo7> but it's not in general all that useful
06:07:25 <kramble> yes i swa that, but do you use it instead of standard recursion definition ?
06:07:42 <Bynbo7> i wouldn't, it makes code more unreadable
06:08:00 <hpc> :t (/)
06:08:00 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:08:02 <hpc> :t div
06:08:03 <lambdabot> forall a. (Integral a) => a -> a -> a
06:08:15 <hpc> > 123 `div` 16
06:08:15 <lambdabot>   7
06:08:22 <hpc> > 127 `div` 16
06:08:23 <lambdabot>   7
06:08:24 <hpc> cool
06:08:42 <c_wraith> > let ones = 1 : ones in ones
06:08:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:08:53 <Saizan> kramble: it's sometimes useful when you want to write a loop and let feels syntactically heavy
06:08:54 <Twey> > fix (1 :)
06:08:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:09:09 <hpc> it's also perfect for confusing newbies :D
06:09:22 <Saizan> well, sure :)
06:09:39 <ddarius> ClaudiusMaximus: I believe there are a few packages on Hackage with somewhat similar things.
06:09:41 <c_wraith> > fix $ (0:) . scanl (+) 1
06:09:41 <Twey> kramble: fix captures the pattern ‘let x = f x in x’
06:09:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:09:52 <Jafet> @src fix
06:09:53 <lambdabot> fix f = let x = f x in x
06:10:09 <aavogt> figuring out a name for the function that calls itself is quite expensive
06:10:19 <kramble> aavogt: :)
06:10:28 <Bynbo7> > fix error -- hpc: and making all your problems go away!
06:10:29 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:10:42 <Saizan> "let f = .. in f" looks quite silly to me
06:10:44 <Twey> E.G. let ones = 1 : ones in ones = let ones = (1 :) ones in ones = let { f = (1 :); x = f x } in x = fix (1 :)
06:10:48 <ddarius> ClaudiusMaximus: Also, with a bit of unsafeInterleaveIO, you could get something a bit more concurrent (i.e. get futures) though you would no longer have the property that all of the IO actions had completed when forkIOs completed.
06:10:59 <ClaudiusMaximus> ddarius: i thought there would be - but finding them is hard!  (also: my implementation will deadlock on exceptions)
06:11:12 <companion_cube> @source fix
06:11:13 <lambdabot> fix not available
06:11:15 <chrisdone> kramble: My IRC server uses it: https://github.com/chrisdone/hulk/blob/master/src/Hulk/Server.hs#L48
06:11:22 <ddarius> ClaudiusMaximus: Add a bracket.
06:11:28 <Bynbo7> chrisdone: putMVar m =<< x might be better written putMVar m =<< evaluate =<< x
06:11:45 <Bynbo7> uh, ClaudiusMaximus, not chrisdone 
06:12:24 <kramble> so you use fix when you want a recursive function but not bind it to a variable
06:12:26 <kramble> ?
06:12:38 <ClaudiusMaximus> ddarius, Bynbo7 : this is just a quick hack really, the actions are (mostly) FFI calls so i know the output will be fully evaluated...
06:12:42 <Bynbo7> i don't think i would ever use fix
06:12:45 <ddarius> Most people don't use fix at all, but some do use it just for that.
06:13:05 <hpc> i personally prefer to write the recursion by hand
06:13:06 <chrisdone> I do, if I don't want to bother writing let loop = .. in ...
06:13:09 <hpc> somehow it seems easier to read
06:13:24 <Bynbo7> me too
06:13:27 <hpc> sometimes i write folds by hand
06:13:47 <aavogt> other languages do this `fix' thing with references to `self' or `this'
06:14:05 <ddarius> @hackage spawn
06:14:05 <lambdabot> http://hackage.haskell.org/package/spawn
06:14:09 <chrisdone> I use it similar to Scheme's LET LOOP syntax.
06:14:37 <revenantphx> So #haskell, maybe you can tell me,
06:14:48 <aavogt> or you can accomplish similar things using fix at least
06:14:50 <revenantphx> How can I make a LaTeX document the size of a composition notebook page :|
06:14:55 <chrisdone> ddarius: Nice
06:15:06 <ClaudiusMaximus> ddarius: thanks
06:15:14 <aavogt> \bot is pretty dangerous with this: withParsed :: (forall a. (Data a, Eq a) => a -> a) -> String -> String
06:15:16 <revenantphx> My physics lab was perfect except the teacher noted me down for not using certain LaTeX tags...
06:15:21 <hpc> http://www.andy-roberts.net/misc/latex/latextutorial8.html
06:15:29 <revenantphx> It's dangerous to have a CS teacher for a Physics teacher.
06:15:50 <chrisdone> Pretty sure physicists love their LaTeX too.
06:16:00 <revenantphx> chrisdone: yep.
06:16:06 <revenantphx> hpc: Not helping. I couldn't find a package with the correct sizing for a composition notebook page.
06:16:09 <Bynbo7> revenantphx: what didn't you use?
06:16:13 <revenantphx> I want something to manually set the size.
06:16:16 <hpc> oh
06:16:32 <revenantphx> Bynbo7: I didn't use left quotes and such.
06:16:41 <revenantphx> Bynbo7: and it was on 81/2x11 paper.
06:16:43 <aavogt> so changing to haskell-src-exts doesn't trigger any type error, when the 'a' ends up being either HsDecl or HsExp
06:16:53 <hpc> revenantphx: that's letter size, i think
06:16:58 <revenantphx> hpc: It is, US Letter.
06:17:04 <revenantphx> I need it to be on Composition Notebook size.
06:17:05 <revenantphx> which is...
06:17:07 <hpc> oh
06:17:13 <aavogt> use the geometry package
06:17:13 <hpc> which is 9xsomething dumb
06:17:17 <revenantphx> 9.75x7.5
06:17:19 <revenantphx> or something.
06:20:35 <tawe> Can somebody give me some way to think about functions like this? http://pastebin.com/nqLLewDY  , to compute ys, use ys. 
06:21:18 <Bynbo7> does that even typecheck?
06:21:35 <Bynbo7> i guess it does
06:21:39 <c_wraith> ([x] ++) is a really verbose way to write (x:)
06:21:41 <Bynbo7> but it never terminates
06:21:57 <c_wraith> it's like nub, but only for infinite lists
06:22:04 <Bynbo7> or maybe it does, i can never remember which way filter works -_-
06:22:22 <c_wraith> oh
06:22:23 <sepp2k> tawe: To calculate the first element of ys, you don't neeed ys. To calculate the second element you need the first, which you have, etc...
06:22:26 <Bynbo7> i think that is exactly repeat x
06:22:28 <hpc> filter is lazy
06:22:44 <aavogt> sometimes x /= x
06:22:54 <hpc> > filter (== 'x') "xxx"
06:22:55 <lambdabot>   "xxx"
06:22:57 <aavogt> > let x = 1/0 in x == x
06:22:58 <lambdabot>   True
06:23:02 <hpc> yeah, it is exactly repeat
06:23:03 <aavogt> > let x = 0/0 in x == x
06:23:04 <lambdabot>   False
06:23:09 <tawe> sepp2k, oh, the lazy thing. thanks, makes sense.
06:23:16 <hpc> except with serious performance issues :P
06:23:17 <Bynbo7> hpc: well, with the assumption that x == x forall x
06:23:18 <c_wraith> that's a crazy implementation
06:23:35 <hpc> Bynbo7: true
06:23:39 <Saizan> i guess this is a trimmed down example of something else
06:23:58 <aavogt> in that case you get       x : undefined   or so
06:24:20 <hpc> > 1024 :: Word8
06:24:21 <lambdabot>   0
06:24:25 <hpc> > 1034 :: Word8
06:24:26 <lambdabot>   10
06:25:11 <FUZxxl> > map (+1) [1..100]
06:25:12 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
06:25:16 <FUZxxl> > map (+1) [1..10]
06:25:17 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
06:26:15 <roconnor> Does ContT State really turn a lazy state into a strict state?
06:26:32 <Blkt> good day everyone
06:26:33 <Saizan> @unmtl ContT r State a
06:26:34 <lambdabot> err: `State r' is not applied to enough arguments, giving `/\A. r -> (A, r)'
06:26:43 <Saizan> @unmtl ContT r (State s) a
06:26:44 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
06:27:28 <hpc> @unmtl Cont
06:27:28 <lambdabot> err: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
06:27:33 <hpc> @unmtl Cont a b
06:27:34 <lambdabot> (b -> a) -> a
06:27:44 <hpc> @unmtl Reader a b
06:27:44 <lambdabot> a -> b
06:28:23 <Saizan> > execState . flip runContT return $ fix (>> put ())
06:28:26 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> ())
06:28:26 <lambdabot>    arising from a use of...
06:28:37 <Saizan> > flip execState () . flip runContT return $ fix (>> put ())
06:28:50 <lambdabot>   mueval: ExitFailure 1
06:28:50 <lambdabot>  mueval-core: Time limit exceeded
06:28:53 <rtharper> join #freenode
06:28:55 <rtharper> oops
06:28:56 <Saizan> > flip execState () $ fix (>> put ())
06:28:56 <rtharper> =p
06:29:01 <lambdabot>   mueval-core: Time limit exceeded
06:29:06 <roconnor> :)
06:29:39 <roconnor> Saizan: how about do { put undefined; put () } ?
06:29:46 <Saizan> > flip evalState () . flip runContT return $ fix (>> put ())
06:29:49 <roconnor> does strict state crash on that?
06:29:51 <lambdabot>   mueval-core: Time limit exceeded
06:30:07 <Saizan> > flip evalState () $ fix (>> put ())
06:30:09 <lambdabot>   ()
06:30:13 <Saizan> hah.
06:30:22 <Saizan> roconnor: no
06:30:51 <roconnor> ah
06:31:07 <aavogt> > toConstr HsEnumFromThen
06:31:09 <lambdabot>   Not in scope: data constructor `HsEnumFromThen'
06:31:12 <hpc> > evalState (put undefined >> put ()) ()
06:31:15 <lambdabot>   ()
06:31:26 <Saizan> roconnor: strict State is only strict on the tuple
06:31:30 <aavogt> why do all Data instances have so much undefined?
06:31:38 <hpc> :w
06:31:41 <hpc> crap
06:32:12 <aavogt> the instance shouldn't be implemented if the authors are not willing to expose themselves like that
06:32:32 <Saizan> rather, the instance should be implemented in terms of the external API
06:32:51 <aavogt> Exp in haskell-src is not even abstract
06:33:08 <aavogt> *HsExp
06:33:21 <roconnor> okay so ContT does strictify State
06:34:04 * aavogt can't abuse Data to avoid writing the 4 cases for  HsEnumFrom*
06:34:05 <Saizan> > runState (undefined >> put ()) ()
06:34:07 <lambdabot>   ((),())
06:34:21 <roconnor> Though I still think Leon's guess that ContT makes things faster by stricifying state is wrong.
06:34:28 <Saizan> > runState (flip runContT return (undefined >> put ())) ()
06:34:30 <lambdabot>   *Exception: Prelude.undefined
06:34:32 <ddarius> roconnor: It is wrong.
06:34:59 <roconnor> ddarius: ya, your claims about avoiding pattern matching and avoiding boxing things makes more sense to me.
06:36:10 <aavogt> specifically this code http://hpaste.org/44350/haskellsrc_annoyance
06:38:41 <roconnor> I think many haskellers are under the mistaken impression that strictness -> faster
06:38:57 <hpc> strictness -> less memory
06:39:01 <hpc> sometimes
06:39:06 <c_wraith> except when it means infinite memory
06:39:18 <hpc> so yeah, strictness -> no useful conclusions
06:39:20 <hpc> :P
06:39:21 <Saizan> or O(n) rather than O(1) memory
06:39:30 <roconnor> hpc: very somtimes
06:39:47 <chrisdone> This rss2irc program I'm using is chock full of strictness annotations. An rss announce doesn't have to be fast. But that's like a signature for "Written by Don Stewart".
06:40:08 <hpc> lol
06:40:22 <Eduard_Munteanu> I hear "in-place updates" less and less these days :/
06:40:23 <roconnor> like c_wraith says, often strictness bring an infinite list into memory instead of generating one element at a time and processing it.
06:40:26 <aavogt> you could get stack overflows from too much laziness
06:40:57 <hpc> often times, you are "strict enough" already
06:41:59 <hpc> at least, i have never found any spot in my code where strictness would measurably alter performance
06:42:20 <Saizan> i tend to associate strictness with "smaller constant factors", whatever that means
06:43:30 <Eduard_Munteanu> Depends on the application, I found a few places where it made a difference when I was implementing those compression algos.
06:43:31 <chrisdone> Well, my Hulk's been up for two weeks. Sitting around using 4MB of memory atm.
06:44:34 * chrisdone baffled that people are *still* writing IRC servers in C
06:47:41 <ddarius> aavogt: You can get stack overflows from too much strictness.
06:47:58 <hpc> ddarius: or from the wrong kind of strictness
06:48:17 <hpc> like if you strictly evaluate a huge list backwards
06:48:35 <ddarius> Saizan: If something is used/strict, then it is almost always better to have it be in an evaluated form (particularly for "simple" types.)
06:49:08 <Saizan> yeah
06:49:23 <aavogt> what's a proper interface for improving @doc beyond the textual substitution currently done?
06:49:23 <ddarius> For "compound" types, things get much less clear and you get into Okasaki-like subtlety.
06:50:04 <Saizan> aavogt: hoogle -l
06:50:10 <Eduard_Munteanu> Why, because you could keep it unboxed?
06:50:18 <ddarius> Eduard_Munteanu: Stuff like that, yes.
06:50:54 * Eduard_Munteanu wonders why -O2 doesn't imply -funbox-strict-fields yet, though.
06:51:10 <Eduard_Munteanu> Though admittedly it isn't very smart about it.
06:51:12 <ddarius> I think if you examine Filinski's symmetric lambda calculus, you could actually derive a duality between the "stack" usage of eager and lazy code.
06:51:25 <Saizan> it can be a pessimization, if you have too much reboxing
06:51:26 <ddarius> Eduard_Munteanu: There are cases where it's not an optimization.
06:51:42 <Eduard_Munteanu> Yeah.
06:54:32 <Saizan> > flip execState () $ fix (>> put ()) -- lambdabot fooled me earlier.
06:54:34 <lambdabot>   ()
06:55:34 <ion> Fool me twice… You can’t get fooled again.
06:56:51 <hpc> YYYYYEEEEAAAAAAHHH!
06:57:17 <roconnor> > flip execState () $ fix (>> put ())
06:57:19 <lambdabot>   ()
06:57:47 <roconnor> lambdabot is so finicky
07:19:02 <aavogt> preflex: seen benmachine
07:19:02 <preflex>  benmachine was last seen on #haskell 1 day, 15 hours, 55 minutes and 24 seconds ago, saying: rly: that erm, sounded like a suggestion to me :P
07:19:38 <aavogt> anybody know where the quasiquoters in http://hackage.haskell.org/package/haskell-src-meta got moved to?
07:19:53 <aavogt> there's some in here http://hackage.haskell.org/package/applicative-quoters, but that's not everything
07:20:03 <chrisdone> @hackage haskell-src-exts-qq
07:20:04 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts-qq
07:20:06 <chrisdone> Here?
07:20:54 <aavogt> hmm, hard to say
07:21:00 <shlevy> If I have an algebraic data type with several fields defined using record syntax, is there an easy way to write a function that just changes one of those fields, or will I have to call the constructor again with all the other fields the same?
07:21:57 <aavogt> shlevy: dat { field = newValue }
07:22:32 <aavogt> where you've probably bound    dat and newValue in the function with that body
07:22:45 <shlevy> aavogt: Oh, awesome. Thanks.
07:25:22 <roconnor> *L* ``You are being pedantic and childish. Being certain does not preclude the possibility of changing one's mind given new information.
07:25:48 <roconnor> people have a funny definition of certainity
07:26:06 <Twey> roconnor: Just a pragmatic one
07:26:13 <roconnor> I guess
07:26:34 <roconnor> my math training has made it difficult for me to communicate with regular people
07:26:36 <Twey> Since we're all ultimately fallible, ‘certain’ as an absolute concept isn't very useful outside philosophical discussions
07:27:00 <ddarius> Twey: "certain" <=> "logical tautology"
07:27:33 <Twey> So people use it to mean ‘with a degree of likelihood suitable to allow action without consideration to other possibilities’
07:27:44 <Twey> ddarius: Like I said :þ
07:27:50 * shlevy decides to leave before the philosophical flamewar erupts
07:28:15 <Twey> Though, even then, logic may be wrong, so what one thinks is a tautology may not be… we're a bit screwed if it is, though…
07:29:12 <chrisdone> Sure is beer talk in here.
07:29:25 <ddarius> Twey: If logic is wrong then you are quite alright in "changing your mind when you are certain" because, at that point, there's no rubric to judge you against.
07:29:35 <Twey> Indeed
07:29:43 <jmcarthur> yeah i was about to say... what does it even mean for logic to be wrong?
07:29:44 <roconnor> more likely your deduction of a tautology was wrong
07:29:51 <Twey> Everything goes a bit out of the window at that point
07:29:52 <jmcarthur> (rhetorical questions)
07:30:27 <roconnor> even if I prove a statement in Coq, there is always some concern that cosmic rays have been mucking with my RAM.
07:30:52 <c_wraith> that's why you should do it agian
07:30:54 <c_wraith> *again
07:30:57 * roconnor recalls http://r6.ca/blog/20041110T014300Z.html
07:31:02 <ddarius> roconnor: English statements on paper are much more robust against cosmic rays.
07:31:02 <c_wraith> reduce the odds significantly!
07:31:06 <illissius> maybe it makes sense to distinguish between 'i am certain my conclusions are correct given the facts' and 'i am certain my facts are correct'
07:31:32 <ddarius> illissius: That distinction already exists in probability theory.
07:31:43 * rwbarton wonders whether modus ponens is a fact
07:32:06 <roconnor> rwbarton: it is more like part of the definition of implication
07:32:14 <illissius> ddarius: right, just referring to the seemingly-strange formulation of 'certain' which roconnor quoted
07:32:15 <Boxo> Just name a probability and say that if you assign a probability higher than that to p, you're certain of p. Not really deep.
07:32:48 <roconnor> Boxo: yep, that seems to be the colloquial usage
07:33:06 <ddarius> For p varying between 0 and 1.
07:33:10 <Twey> roconnor: Hmm, maybe you got cracked in the meantime
07:33:36 <roconnor> Twey: it is possible.
07:34:24 <Twey> Never ascribe to cosmic rays that which is adequately explained by malice?
07:34:28 <roconnor> Twey: if it were for the fact that the earth was being bobarded by a solar flare at the time I was running the md5sums I might even believe that
07:34:36 <roconnor> :D
07:35:03 <Boxo> has a cosmic ray ever caused some failure of electronics?
07:35:07 <ddarius> Twey: Never ascribe to cosmic rays, malice, or anything else, that which is adequately explained by user error.
07:35:08 <roconnor> I guess techinicaly CMEs aren't cosmic radiation
07:35:14 <dolio> I think coq bugs are a more pressing concern than cosmic rays.
07:35:15 <ddarius> Boxo: Yes.
07:35:21 <Boxo> ddarius: story?
07:35:50 <roconnor> ddarius: ya, I don't think I can convince anyone that I didn't change the contents of the file between my two runs.
07:36:06 <roconnor> ddarius: But I've convinced myself that I hadn't
07:36:39 <roconnor> (the files)
07:36:58 <parcs> @hoogle (*>)
07:37:00 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
07:37:00 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
07:37:00 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:37:05 <tawe> This is true?:  foldr1 f (x:xs) = foldr f x xs  ?
07:37:17 <roconnor> @src foldr1
07:37:20 <lambdabot> foldr1 _ [x]    = x
07:37:20 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:37:20 <lambdabot> foldr1 _ []     = undefined
07:37:21 <ddarius> roconnor: You could have also md5summed the wrong files.  Something else could have changed the files.
07:37:34 <ddarius> tawe: Yes.
07:37:56 <roconnor> yes that is possible.  Cosmic rays could have changed the files :D
07:37:59 <hymnusalae_> excuse me, is there a standard function as (\ t -> (\ x -> t)) ? and is there a good website to search such kind of strange functions?
07:38:06 <Twey> hymnusalae_: const
07:38:08 <dolio> I expect it's the actual definition of foldr1 used in base.
07:38:11 <ddarius> :t \t x -> t
07:38:12 <roconnor> ddarius: both of them
07:38:14 <hymnusalae_> Twey, thanks, so fast!
07:38:14 <lambdabot> forall t t1. t -> t1 -> t
07:38:18 <ddarius> @pl \t x -> t
07:38:19 <lambdabot> const
07:38:22 <chrisdone> hymnusalae_: Hoogle is the web site to use.
07:38:24 <pozic> roconnor: the touch of God if you have a religious audience.  
07:38:27 <ddarius> @djinn t -> t1 -> t
07:38:28 <lambdabot> f a _ = a
07:38:38 <hymnusalae_> chrisdone, i thought hoogle is a robot here... thank you very much.
07:39:02 <Twey> hymnusalae_: It's not really a strange function: it's something of a staple of point-free programming.  ☺
07:39:07 * ddarius is now curious about the etymology of "robot"
07:39:10 <roconnor> ddarius: I ran the md5sums three files, then the next thing I did (on that laptop) was run the md5sums on the three files again.
07:39:13 <Twey> ddarius: Russian
07:39:20 <Twey> ‘Robotnik’, slave
07:39:32 <hymnusalae_> Twey, :) thanks a lot.
07:39:44 <roconnor> ddarius: I could see the different sums on two of the three files on the same terminal window.
07:39:46 <ddarius> Twey: Excellent.
07:39:50 <hpc> entertainingly, slave comes from "Slav"
07:39:53 <Twey> Curses
07:39:56 <tawe> foldr1 (+) [1,2,3] is  1+(2+3). but with that definition is:  2+(3+1), is this right?
07:39:59 <Twey> Czech, not Russian.
07:40:02 <hpc> so all robots are east-european
07:40:18 <roconnor> ddarius: the three files were rather large gziped tar files that I was backing up by copying to CD.
07:40:40 <kniu> > The split operation allows one to obtain two independent random number generators. This is very useful in functional programs (for example, when passing a random number generator down to recursive calls), but very little work has been done on statistically robust implementations of split ([1,4] are the only examples we know of).
07:40:42 <lambdabot>   <no location info>: parse error on input `in'
07:40:42 <ddarius> roconnor: There is also the possibility that you simply misread the numbers.  Trust nothing.
07:40:55 <kniu> So how robust is split, really?
07:40:56 <roconnor> ddarius: yep, I could have been delusional
07:41:22 <Saizan> > foldr1 f [a,b,c] :: [Expr]
07:41:26 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
07:41:26 <lambdabot>         against inferre...
07:41:28 <roconnor> ddarius: but given my first hand experience of the situtation and given the sunspot activity at the time I blame the sunspots.
07:41:34 <Saizan> > foldr1 f [a,b,c] 
07:41:35 <lambdabot>   f a (f b c)
07:41:49 <dolio> tawe: Ah, true. I guess I was thinking foldl1.
07:41:53 <roconnor> ddarius: granted, before I learned about the sunspots, I did kinda think I must have made some mistake somehow.
07:41:55 <Saizan> > foldr f a [b,c] 
07:41:57 <lambdabot>   f b (f c a)
07:42:01 <hpc> @unmtl Writer a b
07:42:01 <lambdabot> (b, a)
07:42:08 <tawe> so its not equivalent :S thats my question
07:42:08 <ddarius> tawe: That's a good point.
07:42:11 <tawe> changes the order
07:42:15 <dolio> Yep.
07:42:20 <ddarius> tawe: Yep, Saizan has demonstrated it.
07:42:40 <Boxo> > foldr1 (+++++) [a,b,c] 
07:42:42 <lambdabot>   Not in scope: `+++++'
07:42:49 <Boxo> > foldr1 (+++++) [a,b,c] :: Expr
07:42:50 <lambdabot>   Not in scope: `+++++'
07:43:08 <tawe> That was my guess.. but i doubt it because i take it from a Haskell book. thats why i asked here 
07:43:12 <Boxo> Meh, didn't think so. Any operators you can sue like that?
07:43:14 <tawe> weir
07:43:14 <ddarius> > foldl f a [b, c]
07:43:16 <lambdabot>   f (f a b) c
07:43:21 <ddarius> > foldl1 f [a,b,c[
07:43:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:43:23 <ddarius> > foldl1 f [a,b,c]
07:43:25 <lambdabot>   f (f a b) c
07:43:58 <ddarius> @let (++++) = fun "++++"
07:43:59 <lambdabot>  Defined.
07:44:05 <shlevy> I'm not sure if this is a GHC question or a bash question, but... I have haskell program that I'm using as a script. When I run it with `runghc -Wall -Werror script.hs` it works fine, and if I put '#!/usr/bin/runhaskell' at the top of the script and run it directly, it's fine, but if I change the shebang to '#!/usr/bin/runhaskell -Wall -Werror' I get ghc: unrecognised flags: -Wall -Werror
07:44:09 <ddarius> > foldr1 (++++) [a,b,c]
07:44:11 <lambdabot>   ++++ a (++++ b c)
07:44:15 <ddarius> Hmm...
07:44:18 <tawe> So I guess 'The craft of Functional programming' has a bug? :/
07:44:21 <ddarius> Not exactly what I was going for.
07:44:35 <ddarius> tawe: Possibly.  There's probably an errata page somewhere.
07:44:36 <mauke> shlevy: it's a OS question
07:44:44 <Boxo> :t fun
07:44:46 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
07:45:11 <shlevy> mauke: Is there a better place to ask it?
07:45:12 <ddarius> There's probably an 'op'
07:45:16 <Boxo> :t op
07:45:18 <lambdabot> Not in scope: `op'
07:45:22 <Boxo> :t operator
07:45:23 <lambdabot> Not in scope: `operator'
07:45:24 <Twey> :t oper
07:45:26 <lambdabot> Not in scope: `oper'
07:45:26 <mauke> shlevy: actually it's not a question at all
07:45:35 <ddarius> @hackage simple-reflect
07:45:35 <lambdabot> http://hackage.haskell.org/package/simple-reflect
07:45:43 <shlevy> mauke: Ok, fine. Here's the question: Why is that error occuring?
07:45:43 <tawe> @src foldr1
07:45:43 <lambdabot> foldr1 _ [x]    = x
07:45:43 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:45:43 <lambdabot> foldr1 _ []     = undefined
07:45:44 <Twey> Huh
07:45:46 <Twey> There is an op
07:45:50 <Twey> In the docs, at least
07:46:08 <tawe> Great. Thanks for the help :)
07:46:11 <ddarius> > Debug.SimpleReflect.Expr.op
07:46:11 <mauke> shlevy: because the OS only allows a single arg on the #! line, so it ends up passing '-Wall -Werror' to runhaskell
07:46:12 <lambdabot>   Not in scope: `Debug.SimpleReflect.Expr.op'
07:46:15 <ddarius> Hmm
07:46:27 <Twey> Must be running 0.1
07:46:30 <Twey> There's no op in that
07:46:31 <Boxo> > SimpleReflect.Expr.op
07:46:32 <lambdabot>   Not in scope: `SimpleReflect.Expr.op'
07:47:12 <Boxo> > SimpleReflect.FromExpr.op
07:47:13 <lambdabot>   Not in scope: `SimpleReflect.FromExpr.op'
07:47:33 <shlevy> mauke: So is there a straightforward way to do what I want besides writing a script that calls runghc with all the arguments given to it?
07:47:42 <mauke> shlevy: writing a script won't work
07:47:49 <mauke> a script interpreter can't be a script
07:48:12 <parcs> so is *> the applicative version of >>
07:48:23 <shlevy> mauke: runghc is a script
07:48:27 <Jafet> use draconian;
07:48:58 <Saizan> parcs: yep
07:49:19 <shlevy> mauke: At least, the arch linux version of it is. It does some variable defining the execs a binary in /usr/lib/ghc-6.12.13
07:49:38 <ddarius> foo.sh: #!./foo.sh
07:50:09 <ryant5000> is there anyone in here with either experience writing desugarers or who was involved with the Arrows preprocessor/desugarer?
07:51:14 <Boxo> :t \a b -> fmap const a <*> b
07:51:15 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f a
07:51:32 <napping> pozic: reasonable histogram performance doesn't require losing abstractions
07:52:04 * hackagebot mohws 0.2.1 - Modular Haskell Web Server  http://hackage.haskell.org/package/mohws-0.2.1 (HenningThielemann)
07:52:22 <chrisdone> People are actually using mohws. Hm.
07:52:42 <Heffalump> hackage uploads != use :-)
07:52:55 <pozic> napping: how fast is it now? 
07:53:23 <chrisdone> Heffalump: Well, *someone*'s maintaining it. ;-)
07:54:00 <napping> pozic: about half the read/buf solution, sounds like what you manage
07:54:11 <ddarius> HWS has evolved quite a bit, at least going by the name changes.
07:54:23 <pozic> napping: so, 475MB/s?
07:54:25 <napping> pozic: but all the gunk hidden inside a "mapST_" for lazy bytestrings, and an "unsafeUpdate" for arrays
07:55:20 <hpc> egads, mohws looks anything but modular
07:56:03 <pozic> napping: still, it goes against the spirit of Haskell to use unsafe operations.
07:56:09 <hpc> oh, it's the whole server, not just cgi
07:56:11 <napping> about 420, vs. 780-680 for 'read'ing 1MB buffers
07:56:32 <pozic> napping: one should be able to prove that it is always going to work and then compile to unsafe operations.
07:56:33 <napping> "Who's afraid of a little unsafePerformIO?"
07:56:50 <pozic> napping: unsafePerformIO is not portable.
07:56:50 <napping> yeah, that's one of the incompletenesses of the language
07:56:58 <hpc> unsafePerformIO isn't quite as scary as unsafeInterleaveIO
07:57:02 <napping> what do you mean it's not portable
07:57:03 <Jafet> unsafePerformInterleavedIO
07:57:11 <napping> hey, unsafeInterleaveIO doesn't break the type system
07:57:18 <ddarius> hpc: I don't see how you can say that.
07:57:32 <hpc> ddarius: because one breaks your code in obvious ways
07:57:34 <ddarius> unsafeInterleaveIO isn't too much different from return . unsafePerformIO.
07:57:35 <hpc> the other, in subtle ways
07:57:44 <pozic> napping: I mean that you cannot assume anything about unsafePerformIO.
07:57:47 <napping> pozic: that's a good aim for an IO library for Agda. Haskell isn't really up to the task
07:57:54 <ddarius> hpc: That's certainly not the case.
07:58:04 <pozic> napping: the specification essentially says nothing at all.
07:58:31 <pozic> napping: it is just that there are a lot of programs which use unsafePerformIO and they all hope that it works in a certain way.
07:58:41 <napping> pozic: it says if you obey your proof obligation it works fine
07:59:31 <pozic> napping: unless the spec changed in H2010, it doesn't.
08:00:17 <Jafet> Well, there is no proof. If there was, unsafePerformIO wouldn't be needed
08:01:06 <hpc> Jafet: that's a little unfair; there are foreign APIs with impure functions, but pure combinations of those functions
08:01:44 <Jafet> Indeed. There's just no way to say that they are pure in Haskell.
08:03:07 <napping> pozic: it's in the FFI addendum
08:03:23 <napping> Jafet: yes, that's why you have a proof obligation
08:03:28 <pozic> napping: did it change?
08:03:35 <pozic> napping: if not, see previous response.
08:03:43 <napping> pozic: what do you mena, did it change?
08:03:51 <Jafet> Well, I've never seen any libraries obliged to provide proofs.
08:04:16 <napping> Jafet: "proof obligation" means it's not safe to use unless you go and write some proofs of things that cannot be proved within the langauge
08:04:57 <pozic> napping: there are no proof obligations to generate.
08:05:02 <pozic> napping: because it has no semantics...
08:05:18 <pozic> napping: it just is that lots of people think it has certain useful semantics.
08:05:19 <rwbarton> that's like saying print has no semantics
08:05:21 <hpc> it's the same situation with being obligated to prove the functor/monad/category laws
08:05:23 <napping> "This value should be independent of the environment, otherwise, the system behaviour is undefined"
08:05:30 <pozic> rwbarton: no, print has semantics.
08:05:38 <rwbarton> what are they?
08:05:38 <napping> so, ensure the former, or you'll get the latter
08:06:18 <pozic> rwbarton: it writes whatever the input was to some output port.
08:06:25 <rwbarton> ok
08:06:31 <shlevy> Haskell newbie here, so maybe this is a dumb question, but... When do you need unsafePerformIO?
08:06:33 <rwbarton> unsafePerformIO executes its action when it is forced
08:06:37 <rwbarton> was that so hard?
08:06:51 <hpc> shlevy: ideally, never; it's mostly for FFI people
08:06:59 <pozic> rwbarton: show me a standard where that is the case, TYVM.
08:07:08 <pozic> rwbarton: H98 doesn't say that.
08:07:09 <hpc> shlevy: say you have a random number library
08:07:10 <shlevy> hpc: Why would you even need it there? Can't you just keep all of your FFI in IO?
08:07:17 <hpc> that makes a random number generator
08:07:28 <hpc> and a function to get the next random element
08:07:35 <hpc> that modifies the generator in place
08:07:47 <napping> shlevy: some functions you import, like "sin", are pure and can be exposed as pure functions
08:07:54 <Jafet> pozic: does hs98 define Haskell?
08:07:57 <hpc> you can make randoms :: RandomGen -> IO [a]
08:08:01 <rwbarton> pozic: I really don't care to
08:08:03 <hpc> but not RandomGen -> [a]
08:08:12 <napping> shlevy: others are almost pure, except you need to allocate an array to get the result from or something
08:08:46 <hpc> but it's possible to make RandomGen -> [a], since it can be made pure
08:09:04 <hpc> copy the RandomGen for internal use, and modify that internally
08:09:22 <hpc> then do unsafePerformIO (randoms gen_copy)
08:09:53 <pozic> Jafet: to some degree.
08:10:00 <napping> pozic: look up FUNDIO
08:10:08 <hpc> keeping all FFI in IO would be absolute hell
08:10:16 <hpc> there's too many useful libraries with pure functionality
08:10:24 <pozic> rwbarton: I have had this discussion before, and I have always been right. 
08:10:37 <shlevy> hpc: I'm missing something, sorry... Why can't RandomGen -> [a] be written without unsafePerformIO?
08:10:46 <pozic> That people act differently in practice has nothing to do with what is on paper.
08:10:57 <hpc> shlevy: because the C interface only exposes functions that modify the internals of the RandomGen
08:10:57 <napping> shlevy: It could be in Haskell
08:11:04 <hpc> (hypothetically)
08:11:20 <napping> shlevy: but if you wanted to import from some C library, you couldn't just call it an infinite number of times immediately
08:12:00 <shlevy> hpc: Ah, I missed that we were dealing with a C interface
08:12:00 <rwbarton> pozic: I was under the mistaken impression that you were talking about actual issues regarding unsafePerformIO, and not legalese
08:12:04 <rwbarton> I don't care about the latter
08:12:21 <napping> so you need to do something suspicious to make it so that when the tail of the list is forced it goes and makes another caqll
08:12:23 <hpc> shlevy: np, forgot to mention that part
08:13:01 <napping> pozic: Haskell doesn't have a formal semanics if that's what you're worried about
08:13:05 <shlevy> napping: So basically using unsafePerformIO to make a chain of C functions lazy?
08:13:16 <hpc> not "lazy" so much as "pure"
08:13:32 <napping> shlevy: you can do a lot of things with it, that was the example here
08:13:57 <pozic> napping: (+) has certain semantics (its documentation), but for unsafePerformIO no useful property can be derived, other than that it changes the type.
08:14:35 <napping> pozic: nonsense. Give a semantics for IO, and require that you can prove the IO action has no observable side effects and a pure result
08:14:46 <pozic> rwbarton: this 'legalese' is the difference between a language which people can use in 50 years and one which is forgotten in 20. 
08:14:49 <shlevy> napping: Ok.
08:14:58 * ddarius isn't certain that () isn't a valid implementation of Double.
08:15:18 <shlevy> hpc: Why would keeping all FFI within IO be hell? I've never done FFI so I have no idea
08:15:21 <hpc> ddarius: it's precisely as valid as the spec :P
08:15:23 <ddarius> pozic: Clearly not as there are much bigger holes than that in C, FORTRAN, Lisp, etc.
08:15:52 <pozic> ddarius: Only Lisp has stood the test of time from that list, IMHO.
08:16:09 <pozic> ddarius: C code which runs unmodified after 30 years?
08:16:11 <napping> FORTRAN is still quite good at what it does
08:16:13 <pozic> I do not think so.
08:16:24 <pozic> napping: and FORTRAN has lots of different versions.
08:16:32 <pozic> napping: i.e. formally completely different languages.
08:16:36 <hpc> shlevy: the FFI IO stuff makes everything that calls them IO
08:16:41 <andrewsw> shlevy: I would guess it would force IO deep into the code in ways you might not want.
08:16:47 <hpc> and there's a fair few libraries out there that are FFI
08:17:08 <ddarius> I would say modern Lisps are more different from early Lisps more than modern C or FORTRAN is different from early C or FORTRAN.
08:17:08 <hpc> and even more libraries that use those
08:17:26 <napping> anyway, the description in the FFI is clear enough
08:18:14 <shlevy> hpc: Mm, fair enough. But the impression I'm getting is that you shouldn't use unsafePerformIO unless it's possible to rewrite the function in pure Haskell with enough time and effort. Right?
08:18:39 <ddarius> I also suspect that there is a decent amount of C that would run unchanged on modern compilers.
08:18:40 <Daerim> I'm having a curious case of a noob question. In a do statement I have a line  (path, handle) <- openTempFile "" "temp.tex"   . After this it will let me use "path", but claims "handle" is undefined. 
08:18:41 <napping> shlevy: yeah, that's right
08:19:05 <hpc> shlevy: yeah, but sometimes you just need that extra oomph C gives you :P
08:19:32 <napping> ddarius: the only big shift I recall is K & R vs. Ansi
08:19:32 <shlevy> hpc: For performance reasons or syntax better suited for the problem?
08:19:37 <andrewu> trying to understand arrows and IO: does anybody know of a text with examples how to use Control.Arrow.ArrowIO?
08:19:40 <napping> shlevy: could be either
08:19:48 <tawe> Question. I defined: last xs = foldr1 (\x y -> y) xs   , so to get the last element of the list. Now I'm asked to do the same function with foldr. I thought in using some special character for the empty list. i.e: if 'foo' is the function that use foldr, then foo x specialcharacter = x, and f x y = y. But seems a bit dirty... any ideas?
08:20:09 <tawe> foo x y = y
08:20:15 <hpc> andrewu: how much of arrows you you understand atm?
08:20:16 <napping> shlevy: If you have to work with a lot of pointers and array accesses, *x and a[i] and stuff is a lot nicer than the default versions, and the result usually ends up a bit faster too
08:20:39 <napping> pozic: anyway, the only unsafe thing was an array update that skips bounds checking
08:20:43 <parcs> what's the most efficient way of serializing an int to a bytestring?
08:20:44 <shlevy> napping: The impression I've been getting in my research (only known about Haskell for a few weeks) is that there's a big push to put as many performance considerations into the compiler and out of the code as possible. Is that accurate?
08:20:53 <hpc> tawe: foldr1 f (x:xs) = foldr f x xs
08:20:54 <andrewu> i am new to it. i have worked through the tinylanguage in hughes paper and made some experiments. 
08:21:13 <tawe> hpc, :S
08:21:17 <napping> shlevy: I'm not quite sure I'd put it like that.
08:21:24 <ddarius> shlevy: Yes and no.  There's certainly a desire and trend to do that, but that's the case for pretty much all languages.
08:21:29 <hpc> so last [] = error "oshi-"
08:21:30 <dolio> hpc: We already determined earlier that's wrong. :)
08:21:35 <hpc> last (x:xs) = foldr ...
08:21:38 <hpc> dolio: really?
08:21:39 <napping> It seems to me it's more about putting performance considerations into libraries, and making sure the compiler eliminates abstractions very well
08:21:39 <hpc> :(
08:21:56 <dolio> hpc: Yeah. foldr1 takes the last element as the zero, not the first.
08:22:18 <shlevy> napping: Hmm, ok
08:22:31 <monochrom> my http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml uses IOSArrow which is a case of ArrowIO. I don't do actual I/O there, but you could insert a few print statements.
08:22:53 <andrewu> hpc: what i wanted is a tiny imperative language with arrows (including some store and print statements)
08:23:00 <hpc> ah
08:23:05 <revenantphx> So, I'm implementing a simple infix calculator in Java (ugh) for class
08:23:12 <shlevy> The reason I'm curious about all this is because my eventual end-goal is performance-critical embedded systems, and I had always assumed I'd need to use C until I found out about fp
08:23:13 <ddarius> shlevy: And also, in common with most language implementations, there's not a desire for it to make "big" optimizations in a fickle, heuristic manner.  People don't like relying on unpredictable optimizations.  So, in that regard, there are plenty of things GHC, say, -could- do that it chooses not to.
08:23:13 <napping> The compiler is supposed to do a good job of things, but libraries are important too, like ByteString reading files in 64k chunks
08:23:22 <revenantphx> And I worked out the algorithm, but I'm wondering how it might be generalized.
08:23:46 <hpc> revenantphx: Exec.execute("someHaskellBinary"); // ;)
08:23:49 <revenantphx> In simple terms, I go token by token, if the token is a number, I add it to the value stack, but it's an operator:
08:23:51 <napping> shlevy: I wouldn't expect to be running Haskell on all but the biggest embedded systems, so you probably don't actually have to care about Haskell performance at all
08:23:57 <ddarius> shlevy: Haskell (and most high-level languages) is probably not appropriate for that for reasons not really related to the typical notion of performance.
08:24:12 <napping> shlevy: rather, you might look at things like "Atom" that generate code
08:24:23 <revenantphx> then if the precedence is greater than the one on top of the stack right now I reduce the stuff on the stack until it isnt.
08:24:27 <revenantphx> And then push the operator on.
08:24:32 <revenantphx> so if I had a + b * c
08:24:37 <revenantphx> then I'd push a, +, and b
08:24:39 <hpc> revenantphx: you know what shunting-yard is?
08:24:42 <shlevy> ddarius: Hmm, what would you consider "typical notion" of performance?
08:24:43 <monochrom> there is no generalization to talk about until you have two examples to unify.
08:24:45 <revenantphx> and then I wouldn't push * until I evaluate a + b
08:24:50 <revenantphx> hpc: No.
08:24:54 <revenantphx> monochrom: Hm, true.
08:24:56 <hpc> it's basically what you describe
08:25:03 <napping> shlevy: wall clock time, whatever the executable size or memory consumption
08:25:07 <hpc> the wiki page explains it in imperative style, so i suggest reading it
08:25:12 <revenantphx> Oh okay then.
08:25:15 <revenantphx> I'll takea look.
08:25:34 <hpc> i still have to implement that for my IRC bot...
08:25:35 <ddarius> shlevy: Most programmers care about throughput, not latency (unless it gets to the point that it is bothering users.)  I.e. most programs require very little in the way of real-time guarantees.
08:25:37 <revenantphx> "The algorithm was invented by Edsger Dijkstra..."
08:25:37 <andrewu> monochrom: thank you, i read it!
08:25:42 <revenantphx> why am I not surprised.
08:25:59 <shlevy> napping: Ah. I've always thought of it as consisting of all three, but that's because I've known where I wanted to end up before I knew anything detailed about programming
08:26:44 <ddarius> shlevy: Even having all three of those is usually not enough (or as important) for embedded applications as latency.
08:27:32 <napping> pozic: I'll see if making indexing check first against maxBound and minBound wins
08:27:48 <shlevy> ddarius: Hmm, I've always thought of latency as an aspect of overall execution time. Am I looking at that wrong?
08:27:57 <Jafet> Well, there are garbage collectors for real-time response, so that's not such a big problem
08:28:08 <napping> pozic: and it sounds like you should be using ATS, or coming up with an IO system for Agda
08:28:19 <ddarius> Jafet: Which are very slow and complicated and fairly uncommon.
08:28:30 <napping> not that Agda doesn't have it's own giant holes in specification
08:28:42 <Jafet> I think the bigger problem would be pebkac creating unforeseen thunks.
08:29:09 <ddarius> shlevy: Overall execution time is just that.  The total time.  If it takes ten seconds total, that doesn't say anything about whether it did 1000 in one second, and 1 in 9 seconds, or whether it did each in about 10/1001 of a second.
08:29:28 <tawe> There are special characters in haskell? like a joker?
08:29:34 <dolio> tawe: I think the easiest way to implement last is to have it return a Maybe a, and post-process.
08:29:49 <monochrom> joker is not a special character
08:29:56 <shlevy> ddarius: Ah, seen. 
08:29:58 <ddarius> dolio: That's kind of what the exercise is getting at.
08:30:41 <hpc> @hoogle Writer
08:30:41 <lambdabot> module Control.Monad.Writer
08:30:41 <lambdabot> Control.Monad.Writer.Lazy newtype Writer w a
08:30:41 <lambdabot> Control.Monad.Writer.Lazy Writer :: (a, w) -> Writer w a
08:30:53 <dolio> ddarius: Implementing foldl and inlining some of its arguments is another option. :)
08:31:03 <dolio> But that's trickier.
08:31:30 <tawe> Let me see what a 'Maybe a' is 
08:31:41 <ddarius> dolio: Not if the exercise is to implement in terms of foldr.
08:32:03 <ddarius> Unless you're going to implement foldl in terms of foldr which is doable but probably more complicated than doing it "directly."
08:32:07 <dolio> I mean implementing foldl using foldr.
08:32:13 <dolio> Which is why it's tricky.
08:32:30 <Mathnerd314> @src foldl
08:32:30 <lambdabot> foldl f z []     = z
08:32:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:32:33 <Mathnerd314> @src foldr
08:32:34 <lambdabot> foldr f z []     = z
08:32:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:33:06 <ddarius> dolio: Actually, I misread what you said originally, so my remarks are misplaced.
08:35:28 <tawe> dolio, do you have some example of the 'Maybe' use?
08:35:48 <dolio> > Just 5
08:35:49 <lambdabot>   Just 5
08:35:55 <dolio> > Just 5 :: Maybe Int
08:35:56 <lambdabot>   Just 5
08:35:59 <dolio> > Nothing :: Maybe Int
08:36:00 <lambdabot>   Nothing
08:36:01 <Zao> tawe: When you may have a value or not.
08:36:07 <napping> :q
08:36:12 <shlevy> ls
08:36:15 <shlevy> whoops
08:36:18 <hpc> hehe
08:36:33 <hpc> on another channel, we have a bot that detects gnu utils and responds with
08:36:34 <ddarius> > (Nothing, Just x, maybe n g Nothing, maybe n g (Just x))
08:36:35 <Zao> You could envision a 'find' function for a [t] returning a Maybe t.
08:36:36 <lambdabot>   (Nothing,Just x,n,g x)
08:36:42 <hpc> "[sudo] password for $nick:]
08:36:42 <ddarius> Entire semantics in half a line.
08:36:43 <hpc> "
08:37:48 <shlevy> hpc: Awesome :)
08:38:01 <shlevy> hpc: Anyone ever fall for it?
08:39:33 <dolio> > foldr (\e k z -> k (const e z)) id [1..10] undefined
08:39:33 <lambdabot>   10
08:39:40 <hpc> shlevy: i wish
08:40:26 <shlevy> :t ++
08:40:26 <lambdabot> parse error on input `++'
08:40:28 <hpc> :t (++)
08:40:29 <shlevy> :t (++)
08:40:31 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:40:33 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:40:40 <hpc> (++) == mappend
08:40:44 <shlevy> :t mappend
08:40:44 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:40:51 <shlevy> hpc: That's what I was just checking :)
08:40:52 <hpc> in Prelude, it's [a] -> [a] -> [a]
08:40:56 <tawe> I guess I'm missing something. This chapter is about a primer in 'foldr'. So I guess strange things of Maybe, it's not the idea. I'm still thinking why the book stated that: foldr1 f (x:xs) = foldr f x xs. If that was true, it's trivial. Maybe that errata makes this exercise more difficult than the author expected.
08:40:58 <hpc> but lambdabot is cooler
08:40:59 <hpc> :P
08:41:13 <shlevy> hpc: Ah. Where's the ++ that lambdabot is using defined?
08:41:29 <hpc> shlevy: custom file
08:41:44 <hpc> there's more where that came from, but i forget all of them atm
08:42:01 <shlevy> hpc: Ah, boo. Any chance of that getting redefined in a future Haskell'?
08:42:05 <dolio> tawe: foldr1 f (x:xs) = foldr f x xs makes the foldr1 exercise harder, as far as I can tell.
08:42:12 <hpc> shlevy: unlikely for most of it
08:42:36 <hpc> :t (.)
08:42:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:42:46 <shlevy> hpc: Sigh. I hate backwards compatibility sometimes
08:42:49 <hpc> there are a crapton of generalizations of (.)
08:42:54 <hpc> so the debate would be which to use
08:43:03 <shlevy> hpc: Ok, that's a fair case
08:43:03 <tawe> dolio, no, simpler. Because last xs = foldr1 (\x y -> y) xs.  And then use that identity to express it with foldr.
08:43:04 <ddarius> tawe: No, I suspect the problem is as difficult as the author expected, and that the author wasn't relying on that error.
08:43:26 <andrewu> monochrom: with the current version of hxt (9.1.0) your example does not run; the Text.XML.HXT.Arrow is broken up in many imports. which one do i need?
08:43:42 <dolio> tawe: That definition of last only works if foldr1 isn't defined as foldr f x xs.
08:44:41 <ddarius> tawe: A similar question is how to implement tail in terms of foldr.  The answer is not immediately obvious.
08:45:01 <dolio> foldr f x xs is an okay definition if you don't really care that it takes the first element and puts it at the end of the list.
08:45:11 <shlevy> How do I enable a GHC flag in my source?
08:45:24 <ddarius> shlevy: Which flag do you want to enable?
08:45:36 <hpc> {-# LANGUAGE Flag #-} iirc
08:45:51 <hpc> also {-# LANGUAGE Flag, FlagTwo #-}
08:45:52 <ddarius> hpc: That's not about GHC flags.
08:45:56 <hpc> oh
08:46:00 <hpc> derp
08:46:04 <shlevy> ddarius: I'm writing a script to run all of my unit tests, and I want it to be run with -Wall -Werror
08:46:32 <pozic> shlevy: OPTIONS_GHC
08:46:34 <ddarius> shlevy: There are two pragmas.  OPTIONS and OPTIONS_GHC.
08:46:42 <pozic> What is derp?
08:47:13 <andrewu> shlevy: i use  {-# OPTIONS -Wall #-}
08:47:15 <tawe> Even if this difficulty is what the author intended... I'd like to see the official solution. He cannot pretend I know something that in previous chapters is not mentioned.
08:47:35 <TTimo> pozic: http://knowyourmeme.com/memes/derp
08:47:42 <shlevy> so {-# OPTIONS_GHC -Wall -Werror #-} ?
08:47:50 <dolio> Has it talked about tuples? Booleans?
08:47:51 <ddarius> tawe: There are a lot of ways of doing it.  Certainly if you are talking about foldr, you already, technically, have more than enough to do it.
08:47:55 <shlevy> ddarius: What's the difference between the two?
08:48:11 <ddarius> shlevy: One is GHC specific the other isn't.
08:48:28 <tawe> dolio, yes
08:48:30 <ddarius> "GHC-specific" meaning it will only be parsed by GHC, other implementations will ignore it.
08:48:38 <dolio> You can do it with those, too.
08:49:03 <shlevy> ddarius: Is it safe to assume that any implementation will recognize -Wall and -Werror?
08:49:37 <ddarius> shlevy: Probably, but obviously there is no guarantee.  Of course, you only have to worry about the implementations you'd actually support.
08:51:17 <shlevy> ddarius: Hm... Well since I'm not even putting this in the library code, I think it's safe to use OPTIONS
08:53:22 <tawe> dolio, I'm having some troubles with the types. Here's the idea: http://pastebin.com/E0K48tmF
08:53:24 <shlevy> Why would you use multiple constructors instead of a type class with default implementations and multiple instances?
08:54:24 <ddarius> shlevy: And what would types would you be making instances for?
08:54:30 <dolio> tawe: If you can match on True for the second argument of aux1, it must have type Bool.
08:54:31 <shlevy> Hmm, just had a thought: Can you pattern match on the constructor of an instance of the type class?
08:54:46 <dolio> But you're also claiming it has type a.
08:54:50 <dolio> That isn't going to work.
08:54:55 <shlevy> ddarius: I'm not sure what you mean
08:54:56 <tawe> I know.
08:55:17 <tawe> dolio, that's why I asked about some kind of joke
08:55:35 <dolio> However, that's sort of the idea.
08:56:09 <dolio> You use the boolean to track whether you're at the last value or not.
08:56:26 <tawe> Yes, I know the idea. I don't know the tools to implement it.
08:56:32 <shlevy> @hoogle Text.ICalendar.Parser.ComponentName
08:56:33 <lambdabot> No results found
08:56:42 <dolio> You said the book discussed tuples.
08:56:44 <parcs> @hoogle Integral a => a -> ByteString
08:56:45 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:56:45 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:56:46 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
08:56:54 <dolio> So what about a boolean and an a?
08:57:15 <ddarius> shlevy: How about this.  Try your idea for a bit and see what happens.
08:58:08 <shlevy> I was looking at http://hackage.haskell.org/packages/archive/iCalendar/0.0/doc/html/Text-ICalendar-Parser.html and wondering why not make ComponentName a type class so that you can write functions only intended to be used on, say, VEVENTs, and let the type system enforce that
08:58:49 <tawe> dolio, using a tuple woud not screw the function definition for the general case of the foldr?
08:59:23 <revenantphx> hpc: Thanks for that btw,
08:59:47 <revenantphx> I'm thinking of adding unary and some different associativity operators for fun now :|
08:59:54 <shlevy> Is there a way to write a function for only a particular constructor?
08:59:55 <ddarius> shlevy: Again, in some made up example or in some of your code try using that style and see what happens.
09:00:22 <dolio> tawe: For foldr, the reduction function has type a -> r -> r, not a -> a -> a.
09:00:26 <hpc> shlevy: yes, but you won't catch errors at compilation
09:00:30 <hpc> @src head
09:00:31 <lambdabot> head (x:_) = x
09:00:31 <lambdabot> head []    = undefined
09:00:37 <hpc> ^ example
09:00:49 <shlevy> hbc: Mm, that's what I thought
09:00:58 <shlevy> erm, hpc: Mm, that's what I thought
09:01:02 <hpc> :P
09:01:56 <ddarius> shlevy: What you suggest is not a bad idea in general, and such a style is used in some places, but there are trade-offs and complications.
09:03:56 <hpaste> copumpkin pasted "network failure"  http://hpaste.org/44358
09:04:50 <copumpkin> :o
09:05:20 <parcs> > foldr1 f [1..10]
09:05:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:05:26 <lambdabot>    `GHC.Enum.Enum a'
09:05:26 <lambdabot>      a...
09:05:31 <parcs> > foldr1 f [1..10] :: [Expr]
09:05:33 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
09:05:33 <lambdabot>    arising from the lite...
09:07:14 <shlevy> What kind of source control do folks here use?
09:07:38 <ddarius> copumpkin: Perhaps the hsc is missing the include or pointing at a different include than the one that is being checked.
09:07:45 <shlevy> I'm a git fan myself
09:07:54 <ddarius> shlevy: Whatever they feel like.  There's a decent amount of darcs, git, and Mercurial.
09:07:54 <napping> shlevy: git or darcs mostly, it seems
09:09:05 <hpc> svn here
09:09:12 <hpc> it's what i know best
09:10:39 <Oby420> http://reddit.com/r/haskell
09:11:03 <napping> yes, and?
09:11:28 <hpaste> pepsimax pasted "!pepsimax!"  http://hpaste.org/44360
09:11:31 <hpaste> tibbe pasted "cabal-install-0.10.0 bootstrap.sh failure"  http://hpaste.org/44361
09:12:17 <Oby420> what's with this pepsimax thing?
09:12:38 <shlevy> Anyone know any good guides for Haskell package namespaces? 
09:12:50 <tawe> dolio, http://pastebin.com/bre2JrJd   :)
09:12:51 <hpc> namespaces?
09:13:18 <Oby420> LOL HASKEEL DONT HAVE NAMESPACES U NOOB
09:13:44 <shlevy> Perhaps I'm using the wrong terminology... Categories?
09:14:05 <Oby420> U SHOULD READ A BOOK ON CATEGORY THEORY INSTEAD LOL
09:14:16 <dolio> tawe: That works. But you don't need to match on (x:xs). You can use undefined instead.
09:14:30 <hpc> shlevy: ignore him ;)
09:14:40 <hpc> haskell's system is packages, which contain modules
09:14:43 <shlevy> hpc: I am. I was responding to you :)
09:14:57 <tawe> dolio, how is that?
09:15:01 <mauke> how do I named packages
09:15:03 <hpc> so the package are stuff like base, mtl...
09:15:30 <Oby420> LOOL GUIS U R SUCH N00bz ROFL GO READ SOME BOURBAKI LL
09:15:31 <hpc> modules are Control.Morphism.Zygohistoprepromorphism
09:15:33 <hpc> etc
09:15:34 <dolio> foldr aux1 (undefined, True) xs
09:15:36 <shlevy> Right, is there any sort of commonly-accepted convention for deciding the package basename?
09:15:55 <tawe> dolio, cool. Thanks for your help. :)
09:16:03 <hpc> shlevy: not really, just something catchy that isn't taken
09:16:32 <hpc> names range from the obvious like "category-extras" to "snap"
09:16:41 <hpc> snap being a web framework
09:17:37 <shlevy> hpc: Heh, alright. Something tells me something like "Com.SheaLevy.Android.TZCal" would not be greatly appreciated, though :)
09:17:53 <hpc> no, that's for the modules :P
09:18:01 <hpc> packages aren't heirarchical
09:18:08 <hpc> or that word, spelled right
09:19:19 <shlevy> hpc: Oh, I misunderstood the distinction. I though a package would be the base name and the module is just the specific module you care about. When do I care about the package name?
09:19:30 <hpc> shlevy: when putting things on hackage
09:19:50 <hpc> example: http://hackage.haskell.org/package/category-extras-0.53.5
09:19:56 <hpc> package name is category-extras
09:20:08 <hpc> it has modules in Control.Category
09:20:10 <hpc> etc etc
09:20:20 <shlevy> hpc: Aaah. So would most packages contain one hierarchy of modules?
09:20:34 <shlevy> hpc: Obviously that one doesn't
09:20:34 <hpc> usually
09:20:44 <napping> shlevy: the package names actually seem to be fairly flat. There are somewhere suggestions for the module naming
09:20:45 <hpc> depends on the scope of the package
09:20:58 <copumpkin> ooh http://www.andrew.cmu.edu/user/awodey/catlog/notes/
09:21:02 <shlevy> hpc: So I guess my question is: Are there any guidelines for module naming?
09:21:14 <napping> shlevy: There are all sorts of propsals floating around, but now there is not required connection between packages and modules, like all modules being under a common subtree or anythin
09:21:33 <napping> though it is recommended
09:24:29 <shlevy> @djinn a -> b -> a
09:24:30 <lambdabot> f a _ = a
09:24:34 <shlevy> Very cool
09:26:54 <Oby420> lambdabot: 2+2
09:26:59 <Oby420> rude
09:27:05 <roconnor> > 2 + 2
09:27:06 <lambdabot>   4
09:27:17 <Oby420> thanks
09:27:20 <roconnor> > deriv tan x
09:27:20 <kafee> people, what about Typeable, what does it actually do?
09:27:21 <lambdabot>   1 * cos x * recip (cos x) + sin x * negate (1 * negate (sin x) * recip (cos...
09:27:23 <Oby420> > "hi"
09:27:25 <lambdabot>   "hi"
09:27:36 <shlevy> :t deriv
09:27:37 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
09:27:38 <Oby420> > print $ "h"
09:27:41 <lambdabot>   <IO ()>
09:28:06 <Saizan> kafee: typeOf x produces a value that's supposed to represent the type of x at runtime
09:28:13 <shlevy> > unsafePerformIO (print $ "h")
09:28:14 <lambdabot>   Not in scope: `unsafePerformIO'
09:28:22 <napping> kafee: it's used in Dynamic
09:28:41 <shlevy> Well darn. I was hoping I could hack lambdabot :(
09:28:51 <aavogt> @commands
09:28:51 <lambdabot> Unknown command, try @list
09:28:54 <aavogt> @list
09:28:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:29:13 <roconnor> shlevy: it is easier to forkbomb lambdabot
09:29:13 <kafee> and how does it do that?
09:29:34 <aavogt> @pl can sometimes take a long time to terminate
09:29:34 <lambdabot> can sometimes take a long time to terminate
09:29:44 <aavogt> maybe forever?
09:29:53 <shlevy> What's @pl?
09:30:24 <mauke> removes named parameters
09:30:32 <roconnor> @pl (\f -> f (\a b -> f b a))
09:30:32 <lambdabot> ap id flip
09:30:36 <shlevy> Ahh
09:30:45 <roconnor> shlevy: removes all lambdas from expressions
09:30:51 <Oby420> @run "!pepsimax!"
09:30:52 <roconnor> @unpl puts them back in
09:30:52 <lambdabot>   "!pepsimax!"
09:30:52 <lambdabot>  Parse error at "in" (column 16)
09:31:08 <roconnor> @unpl ap id flip
09:31:08 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ a -> a) (\ b c d -> b d c)
09:31:41 <shlevy> Is it possible to make any function that doesn't pattern-match completely point-free?
09:31:50 <roconnor> actually I'm not sure this example typechecks
09:31:54 <roconnor> @type ap id flip
09:31:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = a1 -> a -> b
09:31:57 <lambdabot>     Probable cause: `flip' is applied to too few arguments
09:31:57 <lambdabot>     In the second argument of `ap', namely `flip'
09:32:02 <roconnor> that explains the crazy results
09:32:33 <roconnor> shlevy: yes
09:33:08 <roconnor> shlevy: you can write any lambda expression using only (ap) and (const)
09:33:17 <shlevy> :t ap
09:33:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:33:49 <roconnor> specifically using (ap :: c -> (a -> b) -> (c -> a) -> c -> b)
09:34:00 <roconnor> @type (ap :: c -> (a -> b) -> (c -> a) -> c -> b)
09:34:00 <lambdabot>     Occurs check: cannot construct the infinite type:
09:34:00 <lambdabot>       c = a -> b -> c -> b
09:34:00 <lambdabot>     In the expression: (ap :: c -> (a -> b) -> (c -> a) -> c -> b)
09:34:03 <roconnor> er
09:34:11 <roconnor> @type (ap :: (c -> (a -> b)) -> (c -> a) -> c -> b)
09:34:12 <lambdabot> forall c a b. (c -> a -> b) -> (c -> a) -> c -> b
09:34:13 <Boxo> ap ~= \abc.ac(bc)
09:34:17 <roconnor> ^^ that ap
09:35:05 <Boxo> http://www.c2.com/cgi/wiki?EssAndKayCombinators
09:35:43 <Jafet> :t Prelude.ap
09:35:44 <lambdabot> Not in scope: `Prelude.ap'
09:35:50 <Jafet> :t Control.Monad.ap
09:35:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:37:35 <shlevy> boxo: So const is K and ap is S?
09:37:51 <napping> ooh, how about ap, (.snd), and curry?
09:38:44 <napping> :t (\f x y -> x y (f x))
09:38:44 <lambdabot> forall t t1 t2. ((t -> t1 -> t2) -> t1) -> (t -> t1 -> t2) -> t -> t2
09:39:24 <mrshoe> i'm working on a raytracer and i have a scene (a list of triangles and spheres) and i need to map the intersectRay function over that list
09:39:51 <blueonyx> hi, how to store values of different type in a single container? (namely function which i interpret with hint) 
09:40:01 <mrshoe> but if i make two separate types that are instances of some Primitive typeclass.. i can't have a list contain 2 types
09:40:16 <blueonyx> hehe
09:40:23 <mrshoe> blueonyx: nice
09:40:29 * hackagebot mohws 0.2.1.1 - Modular Haskell Web Server  http://hackage.haskell.org/package/mohws-0.2.1.1 (HenningThielemann)
09:40:35 <Saizan> do you have a finite universe of types?
09:40:42 <mrshoe> i do
09:40:44 <aavogt> blueonyx: Dynamic or similar is another option
09:40:45 <Saizan> if so just use a tagged union
09:40:53 <blueonyx> me not
09:41:26 <blueonyx> @hoogle Dynamic
09:41:26 <lambdabot> module Data.Dynamic
09:41:26 <lambdabot> Data.Dynamic data Dynamic
09:41:26 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
09:41:40 <aavogt> blueonyx: so hint is interpreting some strings as what?
09:41:45 <mrshoe> Saizan: so just implement the intersectRay function once and pattern match on value constructor?
09:41:53 <roconnor> Dynamic is evil
09:42:04 <mrshoe> instead of implementing it for each type?
09:42:24 <aavogt> it's probably easier to do the  interpret-as-function-type-1,2,3,4 ... and supplying those arguments at the same time
09:42:40 <blueonyx> aavogt: strings to functions, yea
09:42:52 <blueonyx> mh
09:42:53 <aavogt> say you like to interpret    ["(+)","negate", ... ]
09:43:01 <aavogt> and know x1,x2 ... 
09:43:48 <blueonyx> aavogt: you mean i store the functions as strings and evaluate them when needed? :/
09:44:14 <napping> :t let l = flip . curry; v = fst; s = (. snd) in l (l (ap (s v) v))
09:44:15 <Saizan> mrshoe: yeah, you can of course implement separate intersectRay functions and compose them later into a function that does the pattern matching and calls those
09:44:16 <lambdabot> forall a a1 b. a -> (a1 -> b) -> a1 -> b
09:44:24 <napping> :t \x y -> x y
09:44:25 <lambdabot> forall t t1. (t -> t1) -> t -> t1
09:44:28 <aavogt> what you can do is try something like:      case () of _ | Just f1 <- interpret str -> f1 x1   | Just f2 <- interpret str -> f2 x1 x2 ...
09:44:40 <napping> DeBruijn combinators
09:44:46 <azaq23> shlevy: For monads, yes. The most basic definition is the applicative instance for ((->) t), where pure = const (so the K combinator) and (<*>) is the S combinator. For applicatives which are also monads, (<*>) = ap, so ap is for ((->) t) also S since it also has a monad instance.
09:45:30 <aavogt> where you've already decided what the different argument types are  (and the result types are all the same)
09:46:03 <Saizan> mrshoe: if you think you'll need to handle a large number of different types in the future there are more appropriate designs, but this one is quite simple
09:46:04 <roconnor> azaq23: oh interesting.  So all you need is pure and <*> to write any lambda expression
09:46:08 <blueonyx> my result types have 2 type variables xD
09:46:52 <napping> roconnor: You haven't seen combinator conversion?
09:47:11 <roconnor> napping: I have.  I just didn't make the connection that K =pure
09:47:15 <mrshoe> Saizan: ok, thanks.. i was hoping i could do multiple types in a typeclass but i guess a single type would just be easier
09:47:50 <blueonyx> i guess interpreting again and again is more evil than Data.Dynamic
09:47:57 <ddarius> roconnor: Normal bracket abstraction just makes the lambda bound variable an "environment" in an environment monad.
09:48:11 <ddarius> s/an/the/
09:48:35 <roconnor> what does normal bracket abstraction mean?
09:50:12 <azaq23> roconnor: There is an article about that in the issue 17 of the monad reader, "The reader monad and abstraction elimination", it contains an example program which uses template haskell for an automated conversion of lambda terms into terms using pure / (<*>)
09:50:42 <ddarius> roconnor: Bracket abstraction is the algorithm that turns a lambda term into uses of combinators.  By "normal" I merely meant the usual one using S and K.
09:51:31 * hackagebot happstack-heist 6.0.1 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-6.0.1 (JeremyShaw)
09:51:54 <roconnor> ddarius: I understand
09:52:07 <shlevy> Do people here find tools like hlint and haskell style scanner useful?
09:52:23 <roconnor> shlevy: I've never used them
09:52:34 <hpc> shlevy: i don't use it, but it's one of the nicer features of hpaste
09:52:38 <hpc> so i suppose it could help
09:52:39 <aavogt> what's the "haskell style scanner"?
09:52:51 <shlevy> Linked to from the hlint home page http://projects.haskell.org/style-scanner/
09:53:14 <djahandarie> hlint is nice, but you eventually just don't need it anymore
09:53:25 <djahandarie> (Except for when you forget to remove extensions)
09:53:26 <ddarius> shlevy: I like the hlint integration into hpaste, but I don't use either.
09:53:27 <aavogt> ghc does -fwarn-tabs
09:55:12 <ddarius> copumpkin: Most of those look rather drafty.
09:55:19 <copumpkin> ddarius: indeed :
09:55:20 <copumpkin> :)
09:55:50 <monochrom> @quote monochrom style
09:55:50 <lambdabot> No quotes match. Wrong!  You cheating scum!
09:55:50 <ddarius> Admittedly, Probably Theory the Logic of Science is, unfortunately, rather drafty but still good.
09:55:53 <monochrom> @quote monochrom heart
09:55:53 <lambdabot> monochrom says: if you don't try to write a new OS at 20, you have no heart. if you try to write a new OS at 40, you have no brain.
09:55:59 <monochrom> @quote monochrom heart
09:55:59 <lambdabot> monochrom says: best practice haskell is "go with your heart"
09:56:24 <roconnor> ddarius: I feel like I should work through some of the examples in that textbook
09:58:36 * Baughn wonders if there are any cheap algorithms to enumerate locations in a discrete 3d grid, by order of euclidian distance from the origin
09:58:40 <ddarius> Spanish should have more Greek influence so I can say, "Vaya con cardios"
09:58:54 <Baughn> ..I'd take new york distance, too
09:59:30 <ddarius> Manhattan distance should be pretty straight forward.
09:59:58 <Baughn> It's straightforward for 2d, at least
10:00:28 <Baughn> And, okay, I can think of several ways to do it relatively cheaply in 3d
10:00:34 <Saizan> mrshoe: you'd need what's called an "existential wrapper" for that
10:00:41 <Baughn> Heck, since I can precache the locations for my use-case, I don't even /need/ performance. Still.
10:01:11 <tawe> (\x y -> x*y) 2 3
10:01:26 <Baughn> 6
10:01:28 <tawe> sorry, somehow i thought this was the winhugs window :/ haha
10:01:40 <Twey> Heh
10:01:43 <hpc> lol hugs
10:02:27 <Twey> \x y -> x * y = \x y -> (*) x y = \x -> \y -> (*) x y = \x -> (*) x = (*)
10:02:51 <Baughn> parse error on input `='
10:03:06 <dark> hpc, is hugs just "outdated" / "not maintained"?
10:03:21 <Twey> dark: ‘Superseded’ would be the term
10:03:25 <Baughn> dark: "Not GHC"
10:03:26 <napping> Baughn: let me guess, DF?
10:03:30 <aavogt> it still works
10:03:38 <Twey> More or less
10:03:46 <Baughn> napping: Not lately. Broken laptop.
10:03:47 <napping> 3d manhattan distance would be messy but not too hard
10:03:48 <dark> I think it is bad for the language to be somehow 'defined' by an implementation
10:03:52 <ddarius> Twey: I wouldn't say that.  Hugs is mostly just a pile of crap.  It's main benefit being that it has a relatively standard C implementation.
10:03:56 <napping> oh, you want 3d grids for something else
10:03:59 <Baughn> napping: Oh, the algorithm.. no, Minecraft actually
10:04:04 <tawe> I'm guessing if there's some easy way to apply partial functions but not in the variable order. Like: foo x 3 . I'd do: (\x -> foo x 3), but seems awful.
10:04:15 <dark> and this is usually what happens when one has just one implementation that 'works' with all fancy new extensions
10:04:19 <roconnor> tawe: flip foo 3
10:04:24 <ddarius> tawe: It's called lambda notation.
10:04:39 <Baughn> napping: I think I'll just go with the brute-force method of sorting them by the square of the vector
10:04:41 <tromp_> > do { k<-[1..]; let a=1; return k }
10:04:42 <Baughn> napping: That works. :P
10:04:43 <lambdabot>   <no location info>: parse error on input `}'
10:04:49 <dark> ddarius, oh you despise hugs? but why
10:04:58 <tromp_> why is that a parse error?
10:05:01 <Twey> tawe: flip foo 3, or (`foo` 3)
10:05:07 <napping> dark: that seems to be a little less bad for Haskell because usually the fancy new extension comes with a whole research paper describing it very carefully
10:05:09 <tawe> roconnor, and in the general case?
10:05:18 <tawe> foo 2 3 5 x 5 6?
10:05:32 <Twey> Lambdas.  :þ
10:05:35 <bicilotti> foo.txt | main <-- is that the correct way of piping a file under windows cmd?
10:05:35 <roconnor> @pl (\x ->  foo 2 3 5 x 5 6)
10:05:36 <lambdabot> flip (flip (foo 2 3 5) 5) 6
10:05:39 <Twey> Or some careful combination of combinators
10:05:42 <dark> napping, (and then ghc implements it 'like this paper, but with a different syntax')
10:05:46 <tawe> lol
10:05:49 <roconnor> hmm
10:05:59 <napping> dark: it's less bad that the "extensions" of the main interpreter being whatever quick hacks the maintainers fancy (and don't bother to document)
10:06:02 <Twey> That can get nasty pretty quickly, though
10:06:02 <aavogt> the implementations aren't necessarily exactly the same as the papers. Take template haskell as an example
10:06:04 <roconnor> @pl (\x a b c d e ->  foo a b c x d e)
10:06:06 <lambdabot> flip (flip . (flip .) . foo)
10:06:16 <roconnor> there
10:06:17 <roconnor> actually
10:06:20 <Twey> @pl \a b c d e -> f e d c b a
10:06:21 <Saizan> dark: syntax is actually just written down on the haskell prime wiki, i'd be more worried about some corner cases of type inference
10:06:21 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip f)))
10:06:21 <roconnor> @pl (\foo x a b c d e ->  foo a b c x d e)
10:06:22 <lambdabot> flip . ((flip . (flip .)) .)
10:06:34 <napping> Baughn: I wonder what you can do with just distance, rather than a shortest path
10:07:01 <napping> the manhattan distance enumerator, at least, and work in constant size
10:07:08 <bicilotti> because it gives me thie error : | Give me some input: main: <stdin>: hGetLine: end of file | :(
10:07:16 <napping> I don't see how to enumerate by euclidian distance with constant storage
10:07:22 <geheimdienst> :t (++) . show
10:07:22 <lambdabot> forall a. (Show a) => a -> String -> String
10:07:36 <bicilotti> even though the file is ot empty!
10:07:54 <aavogt> @ty shows
10:07:56 <lambdabot> forall a. (Show a) => a -> String -> String
10:09:06 <geheimdienst> so, i need to turn on rank-2 types (whatever that is) to use a signature like that? ^^
10:09:40 <rwbarton> geheimdienst: no
10:10:09 <rwbarton> that's just a normal class context
10:10:45 <geheimdienst> ghc tells me "Illegal symbol '.' in type, perhaps you intended -XRankNTypes or similar flag to enable explicit-forall syntax: forall <tvs>. <type>". if i enable Rank2Types, this message goes away ...
10:10:53 <geheimdienst> but i'm confused too
10:10:53 <rwbarton> oh
10:10:59 <rwbarton> well, don't write the "forall a." part
10:11:11 <rwbarton> unless you need ScopedTypeVariables
10:11:52 <rwbarton> the "forall a." is implicit
10:13:06 <geheimdienst> yeah you're right, i just tried it and it works. thanks.
10:13:19 <Philonous> geheimdienst: -XExplicitForAll allows you to write explicit foralls (well, duh), and it is implicitly turned on by RankNTypes
10:13:45 <Philonous> That's why ghc stopped complaining 
10:14:19 <bicilotti> oh, "type" i should have used, ok
10:14:36 <geheimdienst> Philonous: good to know, thanks
10:15:57 <ddarius> copumpkin: I like Appendix D of catlog0.pdf
10:17:53 <Philonous> geheimdienst: Btw. a rank 2 type is when the forall occurs on the left side of a (->), like in (forall a. a -> a) -> Int -> Int
10:18:18 <copumpkin> ddarius: the outline?
10:20:30 <geheimdienst> wow, that explanation is suspiciously understandable
10:20:37 <ddarius> copumpkin: Appendix C I meant to say.
10:20:49 <copumpkin> ddarius: oh, that one is excellent, I agree
10:20:55 * ddarius is having quite a bit of difficultly accurately communicating to copumpkin of late.
10:21:04 <geheimdienst> my type was this: forall a. (Show a) => a -> String -> String. so that's a rank-2 type, while this isn't? forall a. (Show a) => String -> String -> a
10:21:24 * monochrom , instead, suspects all non-understandable explanations
10:21:28 <geheimdienst> ddarius: you mean to say copumpkin makes you confuse the appendixes?
10:21:45 <Saizan> geheimdienst: neither are
10:21:50 <ddarius> geheimdienst: No.  Also "appendices."
10:22:16 <monochrom> "left side of ->" really means "left argument of ->"
10:22:24 <rwbarton> by "left of (->)" Philonous means as the domain of a function
10:22:33 <Philonous> geheimdienst: No, the forall is outside the whole thing, 
10:22:33 <geheimdienst> ddarius: please check a dictionary
10:22:51 <Philonous> geheimdienst: In both cases
10:23:28 <geheimdienst> okay i see. the rank-2 types indeed were a red herring, it was only the ExplicitForAll that mattered. thanks for the explanation, guys
10:23:28 <monochrom> @wn appendices
10:23:30 <lambdabot> *** "appendices" wn "WordNet (r) 2.0"
10:23:30 <lambdabot> appendices
10:23:30 <lambdabot>      See {appendix}
10:23:30 <lambdabot>  
10:23:30 <lambdabot> *** "appendices" wn "WordNet (r) 2.0"
10:23:32 <lambdabot> [7 @more lines]
10:23:37 <monochrom> @wn appendix
10:23:37 <lambdabot> *** "appendix" wn "WordNet (r) 2.0"
10:23:37 <lambdabot> appendix
10:23:39 <lambdabot>      n 1: supplementary material that is collected and appended at the
10:23:43 <lambdabot>           back of a book
10:23:43 <monochrom> @wn appendixes
10:23:45 <lambdabot>      2: a vestigial process that extends from the lower end of the
10:23:47 <lambdabot> [3 @more lines]
10:23:48 <lambdabot> No match for "appendixes".
10:24:04 <monochrom> dictionary check complete
10:25:06 <Saizan> "process calculus" has a whole new meaning now
10:27:39 <hpaste> SheaLevy pasted "Stupid Type Class Question"  http://hpaste.org/44366
10:27:59 <monochrom> eh? the hpaste bot has awaken again?
10:28:00 <shlevy> Is there a way to make testFunction work the way I want?
10:28:08 <Saizan> not really
10:28:26 <monochrom> pattern matching on types? no. unless you add methods to your class.
10:29:36 <shlevy> monochrom: So some sort of "what class am I" method that I'd have to check within the function?
10:30:03 <shlevy> erm, "what type an I" method, rather
10:30:12 <napping> sounds like you are confusing OO classes
10:30:13 * shlevy is trying really hard to get away from the OO mindset, he swears!
10:30:30 <shlevy> napping: Yeah, I am. 
10:30:35 <Saizan> also, maybe you shouldn't use a typeclass at all
10:30:36 <napping> Haskell separates several things most object systems mix in
10:31:00 <ddarius> "Why is the letter λ used?  The notation goes back to Alonzo Church.  We have it on good authority that once professor Church was sent a postcard asking him 'Why λ?'  He wrote the answer onto the same postcard and returned it.  The answer was this: 'enie menie miney mo'."
10:31:13 <Baughn> shlevy: You can pattern-match on types just fine, that's what the instance statement is for. ;)
10:31:15 <monochrom> even in orthodox OO, "what class am I" is frowned upon. just implement the desired behaviour. you want to return 0? then return 0. don't ask "what class am I" ever.
10:31:30 <Baughn> shlevy: But that kind of type-level programming is kind of an advanced topic
10:31:41 <Baughn> If you're asking such questions now, you're asking the wrong questions
10:31:59 <ddarius> Indeed.  Doing a instance selection, or arguably any kind of case analysis at all, is technically antithetical to the ideas of OOP.
10:32:06 <monochrom> http://hpaste.org/paste/44366/stupid_type_class_question_an#p44367
10:32:10 <Saizan> yeah, it'd make sense if testFunction was a method of TestClass
10:32:14 <roconnor> ddarius: I was told that he was using a ^ over the bound variable x, and the typesetter didn't know how to write this so stuck a lambda before it.
10:32:33 <ddarius> roconnor: Yes.  And in all likelihood that's an apocryphal story.
10:32:42 <roconnor> :(
10:32:59 <copumpkin> there are no stupid questions
10:33:02 <copumpkin> just stupid people
10:33:09 <ddarius> of which there are plenty
10:33:42 * Saizan is shocked
10:34:21 <dark> ddarius, I don't understand. is this related to http://en.wikipedia.org/wiki/Eeny,_meeny,_miny,_moe ?
10:34:27 <shlevy> Well, the reason I want to use this kind of thing is this: I want to be able to write functions that ONLY typecheck for TestInstance, and functions that typecheck for any instance of TestClass but act differently for each
10:34:42 <augustss> roconnor: Frege used something like ^
10:35:39 <shlevy> Ah, I was approaching it wrong
10:35:41 <napping> shlevy: if it's supposed to have an unrelated definition for each instance, it has to be a class method
10:35:47 <ddarius> dark: Yes.  In America (at least, though probably most English-speaking nations), it is used to pick something arbitrarily.
10:35:49 <shlevy> A class method is exactly what I need
10:36:53 <dark> ddarius, oh, I think we have something similar in portuguese, "uni duni te.."
10:36:54 <monochrom> http://www.cs.toronto.edu/~hehner/BAUA.pdf contains the summary story of Church's λ notation, and citation. BAUA.pdf itself is in the Mathematical Intelligencer v.26 n.2 p.3-19, 2004
10:37:14 <shlevy> Baughn: I think I understand my problem now, but now you've piqued my curiosity. What's the "instance" statement and when is it useful?
10:37:41 <napping> the one that makes instances of classes
10:37:42 <Baughn> shlevy: Type-classes. class, instance. A simple example is the Show type-class
10:38:07 <Baughn> shlevy: But people adhering to the Olegian faith can do things you'd never believe with type-classes; the system is, in fact, turing-complete.
10:38:25 <Baughn> Though it's based on logic programming, not FP
10:38:32 <Baughn> (There are some efforts to fix this)
10:38:54 <dark> Baughn, which system?
10:38:58 <shlevy> napping: Oh. Duh. I already know and use that one. *facepalm*
10:39:15 <shlevy> Baughn: Do I want to know what the Olegian faith is?
10:39:20 <Baughn> dark: Haskell's type system, with classes included
10:39:33 <dark> õ.o
10:39:40 <Baughn> shlevy: A joke. There's a somewhat famous guy called Oleg who's done several really eldritch things with types.
10:39:53 <Baughn> @quote oleg
10:39:53 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
10:40:15 <dark> Baughn, but type classes with two parameters, right?
10:40:15 <shlevy> Baughn: And now a further question: What does it mean to describe something as 'eldritch'?
10:40:57 <allbery_b> think HP Lovecraft
10:41:02 <dark> or haskell 98 type classes are turing complete too?
10:41:08 <allbery_b> no
10:41:09 <aavogt> no you need extensions
10:41:16 <Baughn> dark: Two. Or *more*!
10:41:22 <hpc> the type system is kept deliberately incomplete
10:41:35 <hpc> completeness makes compilation potentially non-terminating
10:41:41 <allbery_b> but GHC isn't Haskell 98; it's System Fc (I think)
10:41:57 <Baughn> Though in practice you can already make non-terminating programs with just H'98
10:41:58 <dark> now I want to see a type class that calculate prime numbers in compile time
10:42:11 <hpc> Baughn: how?
10:42:12 <Baughn> They might *theoretically* terminate.. in a googol years, yes
10:42:24 <Jafet> !quote milli
10:42:28 <Jafet> @quote milli
10:42:29 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
10:42:34 <Baughn> hpc: Certain exponentially costly abuses of type inference. I don't remember the details.
10:42:37 <monochrom> hahaha
10:42:40 <ddarius> http://www.wisdomandwonder.com/link/3022/why-church-chose-lambda
10:43:03 <monochrom> now, who will mock the mockingbird - in the type system?
10:43:55 <Philippa> allbery_b: Fc doesn't have type classes, it's the language they're dictionary transformed into
10:46:16 <shlevy> :t \
10:46:16 <dark> ^ or ^' is just worse than lambda
10:46:16 <lambdabot> parse error (possibly incorrect indentation)
10:46:17 <dark> i think
10:46:36 <shlevy> Boo
10:46:38 <dark> lambda isn't first class at haskell
10:46:52 <monochrom> it is 0th class
10:47:01 <dark> to think about it, i don't know if it is typeable
10:47:01 <allbery_b> Philippa: so isomorphic, no?
10:47:19 <sipa> of course it is not
10:47:31 <sipa> its first argument is a pattern, not an expression
10:47:38 <shlevy> dark: I wanted to write λ = \ at the top of my code :)
10:47:40 <augustss> many things are not first class
10:47:47 <augustss> 'where' is not first class
10:48:03 <dark> shlevy, there is some ghc extension for some unicode things
10:48:06 <augustss> like \ it's just syntax
10:48:14 <copumpkin> I want first-class data types
10:48:20 <dark> maybe it also lets one put lambda at \?
10:49:28 <allbery_b> record update syntax. (grumble)
10:49:36 <augustss> copumpkin: me too!
10:49:55 <lelf> dark: nope
10:50:19 <ddarius> allbery_b: No.
10:50:20 <shlevy> lelf: Darn :(
10:50:46 <shlevy> How hard would it be to learn Scala if you already know Haskell?
10:50:55 <copumpkin> shlevy: took me almost no time at all :P
10:51:25 <ddarius> It depends on whether you want to learn Scala, or learn how to translate Haskell to Scala.
10:51:25 <lelf> λ is letter
10:51:49 <djahandarie> ddarius, which one is harder?
10:51:56 <ddarius> djahandarie: The former.
10:52:01 <ddarius> Assuming you know Haskell.
10:52:13 <ddarius> (Maybe even if you don't...)
10:52:29 <shlevy> I have an Android application that I'm currently coding in Haskell and hopefully I can use LambdaVM or the Android Native Development Kit, but if not I'll go to Scala
10:52:31 <djahandarie> Is there that big of a difference?
10:52:45 <copumpkin> djahandarie: using subtyping is fun and something you can't directly translate from haskell
10:52:58 <copumpkin> mapping haskell to scala isn't a surjective function, maybe
10:54:35 <shlevy> ddarius: What if you're versed in both Java and Haskell? Then is there still a significant difference between learning Scala and learning to translate Haskell to Scala?
10:55:13 <augustss> copumpkin: nor injective
10:56:01 <copumpkin> yeah
10:56:09 <hpc> at least it's a pure function...
10:56:41 <augustss> hpc: is it?  i think it side effects your brain to translate :)
10:57:15 <Ptival> ^^
10:57:21 <hpc> haha
10:57:36 <ddarius> djahandarie: I'm mostly just making fun of copumpkin and his coworkers.
10:57:37 <ddarius> (and some other parts of the Scala community)
10:57:50 <copumpkin> :P
10:57:59 <copumpkin> hey, I actually use scala features that haskell doesn't have
10:58:17 <augustss> copumpkin: you use scala for a living?
10:58:22 <copumpkin> augustss: yeah
10:58:35 <copumpkin> as of a couple of months ago, anyway
10:58:49 <dark> copumpkin, features? such as?
10:59:12 <dark> subtyping?
10:59:21 <copumpkin> dark: subtyping is the main one, yeah
10:59:27 <copumpkin> not really a fan of implicits
10:59:32 <augustss> (sane) global variables?
10:59:38 <copumpkin> used in any way but typeclassy ways
10:59:54 <lpsmith> heh,  sane global variables would be nice for Haskell.
11:00:02 <dark> any sufficiently good mapping between two languages is bijective. but sometimes it will require some ugly global transformation or something
11:00:55 <ddarius> dark: Not true.
11:01:02 <lpsmith> dark, what do you mean by "bijective",  I don't think I agree with that statement
11:01:52 <shlevy> dark: I'm not sure if this is where you're going with this, but turing-completeness says nothing about performance, memory usage, etc.
11:02:27 <shlevy> dark: So yes, you can express the same computation in any two reasonable languages, but the two implementations might differ vastly
11:05:04 <lpsmith> shlevy, well,  I'm interpreting "bijective" as being able to round-trip a compiler;  basically writing a compiler and near-perfect decompiler.  I don't think dark's making a statement about resource usage.
11:06:37 * ddarius ponders how best represent that the term constructors of the simply typed lambda calculus are (categorically) natural as an equation between derivations or terms that meshes well with the typical notation.
11:08:01 <ddarius> lpsmith: I doubt he's suggesting that.  Just a way to go to and a way to go back, not necessarily inverse, but which preserves observational behavior.
11:08:19 <ddarius> s/suggesting that/suggesting even that/
11:08:44 <shlevy> lpsmith: Would it be cheating for your "compiler" to construct a virtual machine in the target language then compile the original language to that vm's bytecode?
11:08:53 <ddarius> In my understanding of what he meant, no.
11:09:36 <shlevy> lpsmith: Because if I ignore resources, I can easily write compiler from Haskell to any language that I can write an LLVM implementation on :)
11:09:38 <ddarius> And his statement (with my understanding) is true -if- you restrict to Turing-complete languages (modulo, perhaps, some issues of how input and output is encoded.)
11:17:47 <shlevy> Is it possible to create a CPU with a machine code that's not imperative?
11:19:11 <hpc> shlevy: probably, but it would be difficult
11:19:22 <ddarius> shlevy: There's nothing special about machine code.  You can have Haskell be the "machine code."  You'd just have to implement a Haskell implementation in silicon.
11:19:43 <xplat> "just" :)
11:20:01 <xplat> but Fc might be doable
11:20:07 <hpc> assembly language is imperative because there's little conceptual space between that and the state machine that is the silicon
11:20:11 <shlevy> ddarius: Well, my question is: Is that possible?
11:20:15 <ddarius> There are a few CPUs geared to functional programming such as the Reduceron.  I believe there is one that ran a dialect of Scheme more or less directly.
11:20:19 <hpc> widen the gap and there's a crapton of work to make up
11:20:22 <ddarius> shlevy: Of course it is.
11:20:22 <btutt> Indeed, haven't most attempts at creating x on a chip been lack luster? i.e. the original ARM Java bytecode support?
11:20:55 <ddarius> hpc: The silicon isn't a state machine.
11:21:09 <xplat> really there's a pretty wide gap between machine code and what the processor is doing in a lot of common architectures, like x86
11:21:23 <shlevy> ddarius: In a way that doesn't first implement some sort of imperative language then run the haskell implementation on top of that?
11:21:37 <hpc> ddarius: sure it is, if you use flip-flops at all
11:21:38 <Philippa> btutt: reduceron gets a lot of tricks that something like a JVM chip can't, FWIW
11:21:57 <ddarius> hpc: Flip-flops are already a decent amount of abstraction above silicon.
11:22:19 <shlevy> ddaruis: What do you count as silicon, then? 
11:22:57 <xplat> ddarius: i think the abstraction gap being talked about is between machine code and the designer/EE representation of the chip, not the *physical* silicon
11:23:39 <augustss> silicon has bad gap
11:23:48 <augustss> band gap
11:23:56 <ddarius> xplat: The chip manufacturer's deal with many details below the level of behavioral specification.
11:24:23 <shlevy> Hmm... http://en.wikipedia.org/wiki/Symbolics#Ivory_and_Open_Genera
11:24:28 <ddarius> Such as layout and process.
11:24:38 <ddarius> And parasitic capacitances and such.
11:25:05 <xplat> ddarius: sure, they do eventually, but that's mostly waterfall, isn't it?
11:25:32 <augustss> It gets messy very fast once you leave the digital domain.
11:26:19 <xplat> and anyway when you get to that point you no longer are worrying about the relation of the behavioral specification to the machine code semantics, just about whether and how you can meet the behavioral specification
11:26:43 <kniu> I wrote a pathtracer in Haskell.
11:26:50 <kniu> When I tell it to do more than 10 samples,
11:26:56 <napping> in the sense of having global state, hardware is not at all imperative
11:27:07 <kniu> laziness kicks in and thrashes my harddrive to standstill.
11:27:16 <xplat> napping: the actor model is still imperative
11:27:19 <ddarius> kniu: How do you know it's laziness?
11:27:31 <kniu> What else could it be?
11:27:41 <ddarius> kniu: You using a lot of memory.
11:28:00 <napping> in the sense of having local transitions, even lambda calculus is defined in terms of local transformations like beta reduction
11:28:19 <xplat> there are other ways to end up with semantic garbage than laziness, and other ways to end up with excessive memory use than semantic garbage
11:28:43 <kniu> My pathtracer in C, rendering the same scene, doesn't have this problem.
11:28:56 <napping> kniu: it might be not enough laziness, if you are first building a list of too many paths, and then trying to process them
11:29:11 <xplat> napping: lambda calculus is defined in terms of local equivalences, it's reduction strategies that are defined in terms of local transformations
11:29:13 <ddarius> kniu: I doubt there is a direct one-to-one correspondence between your C code and your Haskell code.
11:29:15 <jmcarthur> yeah you could hit the problems i'm hitting right now with incorrect documentation and actions that do different things for different versions of ghc
11:29:18 <btutt> The reduceron perf numbers still look anemic based on http://www.cs.york.ac.uk/fp/reduceron/icfp2010talk.pdf but its certainly an interesting project to keep watch on
11:29:20 <jmcarthur> :P
11:29:46 <napping> xplat: if anything, it should be easier to build hardware where one part can get on with lookup up and expanding definitions, without having to tell the rest of the chip what's going on
11:29:52 <kniu> so what should I do?
11:29:57 <thatBlueThing> Hi there; I'm new to haskell and attempting the nodes of a tree with an in-order walk (using the state monad). See https://gist.github.com/846480
11:30:06 <kniu> How do I figure out what's causing this?
11:30:29 <ddarius> kniu: Use the profiling tools.  Or look at your code and ponder.
11:30:36 <thatBlueThing> The error I'm getting is included in the gist
11:30:42 <napping> xplat: It's impossible to implement a modern processor that actually represents "eax" with a single bit of state all parts of the chip update
11:30:50 <thatBlueThing> There's some subtletly I must not be understanding here—could anyone comment?
11:31:10 <thatBlueThing> if it helps, the error is (xpected type: Maybe [NumTree Int a]
11:31:10 <thatBlueThing>   Inferred type: Maybe
11:31:13 <augustss> knui: heap profiling
11:31:17 <napping> kniu: +RTS -hT
11:31:17 <thatBlueThing>                    (StateT Int Data.Functor.Identity.Identity [NumTree Int a]))
11:31:30 <napping> the heap profile will show what sort of values are taking up the memory
11:31:33 <xplat> napping: i guess depending on what you mean by 'modern processor', yes.  at least all modern processors treat eax and friends as abstractions rather than as physical registers.
11:32:00 <napping> xplat: among other reasons, because there's not enough time in a clock cycle to get a signal across the chip!
11:32:30 <kniu> hm
11:32:36 <kniu>     Could not find module `Graphics.Imlib':
11:32:36 <kniu>       Perhaps you haven't installed the profiling libraries for package `Imlib-0.1.2'?
11:32:36 <kniu>       Use -v to see a list of the files searched for.
11:32:41 <kniu> Any way to avoid this?
11:32:44 <augustss> xplat: as abstraction, yes.  but fast machine have not had a single piece of hardware for a register since the 60s
11:33:35 <xplat> napping: arguably you could take an architecture similar to the original 386 and build out 1000 cores on a chip, then a signal wouldn't have to cross the whole chip in a cycle
11:33:38 <ddarius> augustss: So the concept of registers was an abstraction before the computer age even properly began?
11:33:48 <thatBlueThing> if anyone could perhaps reccomend a more elegant way to acheieve the same result (numbering the nodes of a tree with an in-order walk), please do suggest
11:34:06 <augustss> ddarius: first implemented in 360/91 in the mid 60s
11:34:10 <btutt> kniu: Add library-profiling: True and executable-profiling : True to your ~/.cabal/config file and cabal install --reinstall <pkg>
11:34:16 <napping> xplat: and then you really want to avoid global state
11:34:33 <btutt> kniu: you'll have to do that for your entire dependancy chain
11:34:36 <augustss> ddarius: Tomasulo scheduling
11:34:40 <napping> xplat: and conversely, a machine language that enforces referential transparency might not be such a loss
11:34:48 <ddarius> thatBlueThing: Step one.  Indent less.
11:34:48 <btutt> I got kind of annoyed it wasn't done by default. :)
11:34:57 <kniu> aw dang.
11:34:59 <napping> augustss: Depends what you mean by "fast machine"
11:35:24 <napping> also if you're counting the forwarding in an in-order pipeline as having "a" physical register
11:35:27 <btutt> kniu: Also setting flags: -auto-call -caf-all probably wouldn't hurt either
11:35:37 <augustss> napping: I mean a machine that is on the edge of performance for the underlying technology it uses
11:35:37 <jmcarthur> thatBlueThing: i wouldn't use a state monad for that at all. i'd just pass the values around myself. also, no need for a separate NumTree type. NumTree Int a the same as Tree (Int, a)
11:35:38 <btutt> (again in the cabal config file)
11:35:48 <jmcarthur> *is the same
11:35:51 <napping> yeah, if you mean it like that
11:36:20 <napping> x86 didn't get it until the pentiums
11:36:40 <augustss> napping: agreed, but the idea is old
11:37:03 <jmcarthur> thatBlueThing: you may also be interested in Data.Tree
11:37:56 <raeez> ddarius: is there perhaps an up-to-date difinitive style guide you could refer me to? The ones I could find are mostly dated/fragmented/conflicting
11:38:03 <xplat> really the more i learn about microprocessors, the more i think not very much was invented for micros other than process tech
11:38:11 <raeez> ddarius: raeez = thatBlueThing
11:38:48 <xplat> almost everything else was just recapitulating the history of mainframes at a smaller physical scale
11:39:47 <ddarius> raeez: You don't really need a style guide.  If you were writing C/Java/C#/some C-style language, you wouldn't have open braces and then start indented further right than the open braces (except perhaps in some edge cases.)
11:39:58 <augustss> xplat: yep
11:40:31 <raeez> ddarius: sure; mostly curious about what *else* I'm getting wrong as well
11:41:02 <monochrom> @quote monochrom best.practice
11:41:02 <lambdabot> monochrom says: best practice haskell is "go with your heart"
11:41:14 <monochrom> haskell style guide is also "go with your heart"
11:41:46 <augustss> I kinda wish there were a style guide
11:41:50 <xplat> someone once responded that once you've used haskell for a while that turns out to be a plenty tight constraint :)
11:41:59 <kniu> It seems that a couple of strategically placed $!s did the trick.
11:42:07 <kniu> Constant memory usage now.
11:42:19 <djahandarie> kniu, I usually place them at random until my problem goes away
11:42:21 <xplat> okay, so it was laziness :)
11:42:38 <ddarius> augustss: There are a few, none of which I like, but all of them and most code that you see is pretty similar.
11:42:58 <ddarius> djahandarie: That's a horrible approach.
11:43:00 <kniu> perhaps I should try DDC out.
11:43:25 <monochrom> I should explain why it is so for haskell and not so for C Java etc. After learning haskell (both syntax and semantics), you tend to raise your expectation for everything, including yourself. Your own heart develops a lower tolerance and becomes a suitable implicit style guide. This doesn't happen with most other languages; they don't raise your expectations, you need a separate style guide to.
11:43:28 <djahandarie> ddarius, there are usually only a couple thousand permutations
11:43:34 <pozic> Does anyone know if you can step through a computation in Coq? Or whether there is something like trace for Coq?
11:43:45 <ddarius> djahandarie: That's not the only reason why it is horrible.
11:43:47 <hpaste> ChrisLavoie pasted "guard style"  http://hpaste.org/44372
11:43:55 <napping> pozic: you can trace tactics
11:44:19 <pozic> napping: I know, but I don't want that.
11:44:29 <moosefish> For some reason I can't quite find a visually pleasing way of doing "guard style" code in Haskell. Suggestions? (see http://hpaste.org/44372/guard_style )
11:44:42 <augustss> pozic: why would you need to step through execution?  that's only for debugging, and surely there can be no bugs. :)
11:44:42 <napping> you can also get a term to progress yourself using unfold and cbv [<flags>] and such
11:44:44 <xplat> in languages like coq and agda, where you don't usually run code that compiles, you usually want to trace at compile time :)
11:45:10 <pozic> augustss: actually I think there is a bug in the Coq libraries ;) However small the probability. 
11:45:15 <ddarius> moosefish: I suggest guards.
11:45:23 <napping> what are you even trying to run?
11:45:29 <moosefish> ddarius: It becomes unwieldly after more than 2-3
11:45:37 <pozic> If I run it by hand, my code is correct.
11:45:50 <copumpkin> pozic: what's the bug? :o
11:45:51 <raeez> jmcarthur: thanks for the reccomendations; if I *were* to write this with a state monad (whole point of this exercise for me is to better understand monads), which bit am I getting wrong?
11:45:53 <ddarius> moosefish: I don't see how it would be any more or less unwieldy than it would be in your example.
11:46:27 <ddarius> copumpkin: Clearly the bug is in Coq.
11:46:30 <napping> pozic: what is your code, and what do you expect?
11:46:37 <pozic> copumpkin: most likely some of my assumptions are wrong. 
11:46:47 <napping> ddarius: no, clearly CIC is inconsistent!
11:46:50 <moosefish> ddarius: Some of the code I'm working with has a few dozen 'guards', and I need to inject code between guards (otherwise the guards become too long to fit on a std width screen).
11:46:56 <pozic> copumpkin: but assuming my understanding of all the functions I use is correct, then it is correct. 
11:47:12 <copumpkin> hm!
11:47:17 <copumpkin> a mystery indeed
11:47:38 <ddarius> moosefish: You could abuse callCC.
11:47:39 <pozic> That is why I want something to step through it in a slightly more automatic way. 
11:47:47 <napping> what is the code?
11:47:59 <napping> there are not many things in the library that run for very long
11:48:44 <napping> I did mention "unfold" and "cbv[beta,iota,zeta]"
11:48:45 <jmcarthur> raeez: i went back to look at it and it's deleted from github
11:48:52 <xplat> moosefish: in your pasted example you should be using 'guard' in the Maybe monad
11:49:10 <ddarius> moosefish: Though I'd probably abstract the guards or something as having a "few dozen" things to check seems excessive.
11:49:38 <ddarius> You could also, just, you know, throw an exception.
11:49:40 <raeez> jmcarthur: sorry about that: https://gist.github.com/846498
11:50:01 <Feuerbach> Can I enforce an associated type to be an instance of a particular class?
11:50:19 <copumpkin> depends where, but probably
11:50:25 <jmcarthur> raeez: the error no longer matches the code
11:50:30 <xplat> moosefish: do { guard $ length args == 2; guard $ head args /= "Bar"; {- do something -} }
11:50:35 <copumpkin> Feuerbach: in a class declaration?
11:50:45 <Feuerbach> copumpkin: yes
11:50:59 <copumpkin> class (MyClass (AssType a)) => AnotherClass a where type AssType a :: *; ...
11:51:02 <moosefish> xplat: yeah, that's starting to look like it. Awesome, thanks.
11:51:20 <copumpkin> it feels kind of like an odd place to put it, but also not
11:51:33 <moosefish> ddarius: Would that I could, not working within my favourite codebase right now.
11:51:53 <Feuerbach> copumpkin: thanks, looks like what I need.
11:51:54 <raeez> jmcarthur: apologies again, updated the gist to match the right output https://gist.github.com/846498
11:52:52 <raeez> i'm assuming my misunderstanding is with the use of mapM
11:53:26 <raeez> in this case, does numberTree count as a 'monadic function'?
11:53:26 <jmcarthur> raeez: do you know the type of mapM numberTree a?
11:54:06 <moosefish> xplat: Would it work with Either as well?
11:54:29 <azaq23> @src Error mzero
11:54:29 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:54:32 <xplat> moosefish: yes, assuming the Monad and MonadPlus instances for Either a are visible
11:55:26 <raeez> jmcarthur: going from mapM's signature: it should be State Int (Maybe [NumTree a b])?
11:55:43 <xplat> can someone remind us which module they are in?
11:55:49 <raeez> seeing as the result of mapM in the type signature is m [b]
11:55:57 <jmcarthur> raeez: i'll give you part of the solution and you can figure out the other part. the issue here is that you are applying return to the result of the case expression, but one of the cases actually is in State already (and further wrapped in Maybe, which confuses the issue further)
11:56:17 <jmcarthur> raeez: so the first thing i would do is no return the entire case expression and for the first case say "return Nothing"
11:56:31 <jmcarthur> raeez: that means that in the second case you can use do notation and stuff like normal
11:56:49 <jmcarthur> raeez: and the type of the expression you will need to create is State Int (NumTree Int a)
11:57:11 <raeez> jmcarthur: I see; thanks—I really should have avoided Maybe in this case
11:57:13 <jmcarthur> *not return the entire case expression
11:57:25 <raeez> jmcarthur: thanks a bunch
11:57:27 <jmcarthur> nah Maybe isn't the problem. it's just confusing things for you though
11:57:32 <xplat> hm, does Either a actually have a MonadZero?  (and does it only work for Monoid a or something?)
11:57:35 <jmcarthur> isn't the main problem anyway
11:57:56 <jmcarthur> np
11:58:17 <xplat> the MonadError class is probably more appropriate for Either anyway
11:58:32 <Twey> I guess it has two MonadZero's
11:58:38 <Twey> (both for Monoid a)
11:58:46 <Twey> Oh wait
11:58:48 <Twey> No, silly me
11:59:31 <jmcarthur> raeez: i don't even remember forking that gist, but i just got a google alert saying that i did... o_O
11:59:36 <jmcarthur> that was fast and unexpected
11:59:52 <Twey> Heh
12:02:13 <raeez> jmcarthur: bizarre
12:02:55 <raeez> jmcarthur: perhaps viewing the gist while logged into github fires something off?
12:03:09 <raeez> only somewhat reasonable (and by that I mean far-fetched) explanation I can think of
12:05:40 <jmcarthur> yeah... weird
12:15:22 <pozic> No worries people, Coq is still consistent ;)
12:15:52 <FUZxxl> How to rewrite this in a less uggly style: parseSymbol = satisfy isLetter >>= many (\x -> isLetter x || isDigit x) >>= \rest -> chr:rest
12:16:14 <FUZxxl> How to rewrite this in a less uggly style: parseSymbol = satisfy isLetter >>= many (\x -> isLetter x || isDigit x) >>= \rest -> return $ chr:rest
12:16:17 <Twey> Does that even type-check?
12:16:19 <Twey> Oh, right
12:16:25 <FUZxxl> Sorry. Typo
12:16:34 <Botje> FUZxxl: return . (chr:)
12:16:34 <Twey> parseSymbol = satisfy isLetter >>= many (liftM2 (||) isLetter isDigit) >>= return . (chr :)
12:17:29 <FUZxxl> How to rewrite this in a less uggly style: parseSymbol = satisfy isLetter >>= \chr -> many (\x -> isLetter x || isDigit x) >>= \rest -> return $ chr:rest
12:17:35 <FUZxxl> Oops. Forgot this.
12:18:46 <aavogt>  liftM2 (:) (satisfy isLetter) (many (liftM2 (||) isLetter isDigit))
12:18:54 <Botje> FUZxxl: don't retype stuff if you want to paste it in IRC :)
12:18:57 <Twey> Rrh
12:19:05 <aavogt> well it changed
12:19:06 <Twey> parseSymbol satisfy
12:19:07 <Twey> Er
12:20:32 <aavogt> or also if your parser is in Applicative:     (:) <$> satisfy isLetter <*> many ((||) <$> isLetter <*> isDigit)
12:20:57 <Twey> parseSymbol = satisfy isLetter >>= flip fmap (many (liftM2 (||) isLetter isDigit)) . (:)
12:21:24 <Twey> Hm
12:21:31 <monochrom> what is the type if isLetter?
12:21:34 <Twey> Ooh, yes, the Applicative is nice
12:21:40 <aavogt> @hoogle satisfy
12:21:41 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
12:21:41 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
12:21:41 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
12:21:42 <FUZxxl> Botje: Yes. 
12:22:00 <FUZxxl> monochrom: isLetter :: Char -> Bool
12:22:11 <FUZxxl> I use attoparsec.
12:23:08 <FUZxxl> I use this one for now, also changed result from String to ByteString: satisfy isLetter >>= (<$> takeWhile (\x -> isLetter x || isDigit x)) . B.cons
12:24:13 <Twey> Nahh, might as well stick with Applicative for the function too
12:24:17 <Twey> Makes it nice and consistent
12:25:03 <Fuco> is there some built-in function to return a value from a simple maping like this? [('a','1'),('b','2'),('c','3'),('d','4'),('e','5')]
12:25:05 <Fuco> by key
12:25:08 <FUZxxl> aavogt: Will this preserve the order?
12:26:11 <FUZxxl> I think this is best: B.cons <$> satisfy isLetter <*> takeWhile (\x -> isLetter x || isDigit x)
12:26:20 <FUZxxl> I keep the lambda as it is easier to read.
12:27:02 <sepp2k> Fuco: Prelude.lookup
12:28:22 <aavogt> FUZxxl: at least with liftM2, it has to be exactly the same
12:30:14 <aavogt> with the <*> it's possible that the second parser will take the input first, depending on who wrote the Applicative instance
12:30:43 <Fuco> sepp2k: thanks
12:31:06 <sepp2k> np
12:32:26 <aavogt> @type (\ a b -> do f <- a; y <- b; return (f y) , {- vs -} \ a b -> do y <- b; f <- a; return (f y))
12:32:27 <lambdabot> forall (m :: * -> *) b t (m1 :: * -> *) t1 b1. (Monad m, Monad m1) => (m (t -> b) -> m t -> m b, m1 (t1 -> b1) -> m1 t1 -> m1 b1)
12:38:31 <kniu> Problem persists.
12:39:30 <kniu> Is there any way I can tell the compiler that a certain expression should just be evaluated strictly, in a DEEP way?
12:39:45 <aavogt> @hackage deepseq
12:39:46 <lambdabot> http://hackage.haskell.org/package/deepseq
12:39:53 <kniu> oh
12:39:56 <copumpkin> man, that is so deep
12:40:16 <aavogt> it's bad for performance to do unnecessary forcing
12:41:41 <kniu> I'll keep that in mind.
12:42:49 <tromp_> in haskell it's easy to define the infinite list of fibonacci numbers, i wonder if there's a way to do the same for partition numbers
12:43:14 <tromp_> they satisfy the infinite recurrence p(k) = p(k − 1) + p(k − 2) − p(k − 5) − p(k − 7) + p(k − 12) + p(k − 15) − p(k − 22) − ...
12:43:27 <tromp_> where the offsets follow a simple pattern
12:46:49 <tromp_> > zip (cycle [1,1,-1,-1]) $ scanl (+) 1 $ do k<-[1..];[k,2*k+1]
12:46:50 <lambdabot>   [(1,1),(1,2),(-1,5),(-1,7),(1,12),(1,15),(-1,22),(-1,26),(1,35),(1,40),(-1,...
12:47:01 <ddarius> tromp_: See the pentagonal numbers.
12:47:58 <tromp_> pentagonal numbers are easy, but how to do list of all partition numbers?
12:49:48 <ddarius> > map (\n -> (3*n*n - n) `div` 2)) [0..]
12:49:49 <lambdabot>   <no location info>: parse error on input `)'
12:49:55 <ddarius> > map (\n -> (3*n*n - n) `div` 2) [0..]
12:49:56 <lambdabot>   [0,1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,65...
12:50:05 <ddarius> > map (\n -> (3*n*n - n) `div` 2) [0,-1..]
12:50:06 <lambdabot>   [0,2,7,15,26,40,57,77,100,126,155,187,222,260,301,345,392,442,495,551,610,6...
12:50:56 <ddarius> > map (\n -> (3*n*n - n) `div` 2) (foldr (\x xs -> x:-x:xs) [] [0..])
12:50:57 <lambdabot>   Not in scope: data constructor `:-'
12:52:06 <tromp_> needs a space between : and -
12:52:12 <ddarius> Leonhard Euler has shit on arXiv.  He's so hip.
12:52:27 <copumpkin> lol
12:53:06 <ddarius> Euler is quite definitely my favorite mathematician.
12:56:30 <copumpkin> Oyclid and Yooler
12:56:53 <maurer_> Is there an easy way to install Haskell Platform on a linux machine I don't have root on?
12:56:54 <tromp_> more like oiler
12:57:19 <copumpkin> two Eus, so different
12:57:33 <tromp_> you-clit :)
12:57:45 <copumpkin> :(
12:57:46 <Zao> maurer_: Considering that the HP is usually in the form of distro packages, you might be slightly out of luck.
12:57:55 <Zao> maurer_: Try grabbing the tarball and see if you can --prefix it to kingdom come.
12:58:43 <maurer_> Zao: OK. The GHC they've got on here has hardcoded things that depend on things I don't have read permissions on :/
12:59:06 <maurer_> (otherwise I'd just install cabal-install and run with it)
12:59:34 <Zao> Personally I just install all the packages I care about locally.
12:59:38 <Zao> (GHC too, really)
13:00:28 <maurer_> So, I can do that, I was just hoping for something quicker.
13:05:31 <ddarius> tromp_: Anyway, you should be able to code it as a straightforward dynamic program from the original definition you gave.
13:05:36 <augur> ddarius! \o/
13:12:31 <tromp_> i can do dynamic programming but that requires fixing the dimensions
13:12:38 <ddarius> tromp_: Why?
13:13:22 <tromp_> because i'd use listArray
13:13:29 <ddarius> Then don't do that.
13:13:47 <tromp_> don't know how else to do DP
13:14:04 <tromp_> certainly not with infinite lists
13:15:18 <copumpkin> tromp_: the lazy int-trie in memocombinators
13:15:28 <copumpkin> or edwardk's representable stuff
13:17:18 <ddarius> Yes, a bit trie is the most obvious first choice for a not unreasonably slow semi-infinite structure
13:17:54 <ddarius> @hoogle Array i e -> [e]
13:17:55 <lambdabot> Data.Graph.Inductive.Graph nodes :: Graph gr => gr a b -> [Node]
13:17:55 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
13:17:55 <lambdabot> Data.Graph.Inductive.Query.DFS dfs' :: Graph gr => gr a b -> [Node]
13:18:02 <copumpkin> meh :)
13:18:43 <tromp_> ok, let me try the memocombinators
13:18:44 <pozic> tromp_: To compute p x, you check whether x is a key in some structure, if so, return, if not you compute p x the hard way and insert it when done. 
13:19:28 <ddarius> pozic: The hard part, in this case, is doing "check whether x is a key" efficiently.
13:19:57 <pozic> You can build a growable ST array. 
13:20:11 <tromp_> i didn't know they can grow
13:20:23 <copumpkin> the naive fibonacci example on http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.1/doc/html/Data-MemoCombinators.html is cute
13:20:23 <copumpkin> tromp_: you can write one that does
13:20:45 <copumpkin> growing arrays would benefit from the spanking new primops I wrote for GHC
13:21:42 <pozic> copumpkin: which ones?
13:22:01 <copumpkin> just a bunch of efficient array copies for boxed arrays (unboxed can be written as FFI calls)
13:22:22 <copumpkin> (they just call memcpy, but need to take care of some GC book-keeping too)
13:22:58 <copumpkin> it'd be nice to have some sort of even more primitive memcpy knowledge in the code generator, like what gcc does, but for now this is already quite a bit better
13:24:00 <monochrom> I see, you want growable array. this can be implemented on top of existing array libs.
13:24:29 <pozic> ArrayRef implements them for example.
13:24:47 <monochrom> even Java's growable "Vector" is merely a layer above ungrowable array with copy-when-grow.
13:24:56 <pozic> I wrote my own, since ArrayRef compiled only every blue moon.
13:25:17 <monochrom> ah. well, if someone else already did it, even better.
13:25:48 <augur> copumpkin!
13:25:48 <augur> \o/
13:26:18 <copumpkin> ohai2u augur
13:26:22 <tromp_> @hoogle second
13:26:23 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
13:26:23 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
13:26:23 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
13:29:19 <tromp_> that works very smooth. thx guys
13:30:34 <augur> copumpkin: stratify [1,2] [a,b,c] = [[(1,a)], [(1,b),(2,a)], [(1,b),(2,c)], [(1,c)]]
13:31:23 <augur> aha!
13:31:58 <augur> wtf
13:32:05 <hpc> that's an odd netsplit
13:32:30 <burp`> o0
13:32:30 <augur> stratify [1,2] [a,b,c] = zip [1,2] [a,b,c] ++ zip [1,2] [b,c] ++ zip [1,2] [c]
13:34:45 <pozic> tromp_: which one are you using now?
13:34:54 <tromp_> p=Memo.integral q where q 0=1;q n=sum.map(\(s,k)->s*p(n-k))$takeWhile(\(s,k)->k<=n)$zip(cycle [1,1,-1,-1])$scanl(+)1$do k<-[1..];[k,2*k+1]
13:35:37 <tromp_> not quite a one-liner yet:(
13:36:03 <pozic> tromp_: can't you use the array version?
13:36:11 <pozic> tromp_: this one is log n, AFAIK. 
13:36:20 <augur> hmm.
13:36:27 <tromp_> cant be log n
13:36:29 <kloeri> hpc: wasn't a netsplit
13:36:49 <tromp_> have to compute most preceding partition numbers
13:36:59 <pozic> tromp_: ah, never mind, it doesn't come with growable arrays.
13:37:13 <hpc> a whole bunch of people disconnected at precisely the same time...
13:37:16 <pozic> tromp_: what does it compute anyway? 
13:37:17 <hpc> what else would it be?
13:37:42 <pozic> tromp_: i.e., the application.
13:37:48 <kloeri> hpc: not sure what exactly happened but the servers stayed connected
13:37:50 <copumpkin> hpc: a netsplit elsewhere
13:37:57 <tromp_> http://en.wikipedia.org/wiki/Partition_%28number_theory%29
13:39:36 <hpc> so it was a netsplit :P
13:39:37 <augur> hm. stratify xs ys == stratify ys xs ; stratify xs (stratify ys zs) == stratify (stratify xs ys) zs
13:40:35 <pozic> tromp_: but in what are you using those numbers or is it just "for fun"?
13:40:49 <tromp_> for fun
13:41:34 <tromp_> well, i like to figure out how concisely things can be described by a program
13:41:35 <augur> i shall return to this problem later i suppose
13:41:54 <tromp_> in this case by an efficient program
13:42:57 <augur> hmm, i guess this is just a diagonalization problem
13:43:52 <augur> copumpkin: whats the easiest diagonalization of the rationals?
13:44:37 <copumpkin> (stolen from Cale)
13:44:38 <copumpkin> > 1 : fix ((1 % 1 :) >=> \x -> [1+x, 1 / (1 + x)])
13:44:40 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
13:44:54 <copumpkin> (positive ones, just interleave negatives into it)
13:45:14 <Cale> and zero, of course :)
13:45:30 <copumpkin> 0 DOES NOT EXIST
13:45:36 <copumpkin> DON'T BE SILLY
13:46:42 <augur> ill have to look at this carefully
13:48:52 <manizzle> what is haskell primarily used for/good at?
13:49:12 <copumpkin> manizzle: programming.
13:49:37 <copumpkin> more seriously, all we do with it is non-real-world programmin
13:49:54 <manizzle> im aware of that. anything specific that haskell fills a niche for?
13:50:22 <copumpkin> writing programming language implementations
13:50:50 <manizzle> ive been using erlang for a while, and i see its niche lies in concurrency, fault tolerance and code hotswapping(kinda funky how it works)
13:50:55 <manizzle> oh
13:50:57 <manizzle> i see
13:51:09 <copumpkin> but seriously, haskell is pretty general-purpose
13:51:22 <copumpkin> but it might take a while before you feel comfortable enough with it to write most things in it
13:51:58 <manizzle> what about its performance?
13:52:08 <copumpkin> it's potentially pretty good
13:52:21 <copumpkin> but reasoning about it takes getting used to
13:52:34 <manizzle> i am aware of that, but i am up for it.
13:52:56 <manizzle> reading lysh right now
13:54:25 <augur> copumpkin: whats >=> again?
13:54:32 <copumpkin> kleisli composition
13:54:36 <augur> ?
13:54:41 <copumpkin> if =<< is like function application on monadic functions
13:54:43 <maurer_> manizzle: It's good for compiler development, and programs that _really_ need to be correct.
13:54:48 <copumpkin> <=< is like function composition on monadic functions
13:55:14 <copumpkin> @src (>=>)
13:55:15 <lambdabot> Source not found. I am sorry.
13:55:16 <sipa> :t (<=<)
13:55:18 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:55:38 <augur> oic
13:55:55 <copumpkin> :t (\f g x -> f =<< g x)
13:55:56 <lambdabot> forall t a (m :: * -> *) b. (Monad m) => (a -> m b) -> (t -> m a) -> t -> m b
13:55:57 <ddarius> @hoogle splitAt
13:55:58 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
13:55:58 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
13:55:58 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
13:55:59 <sipa> :t (=<<)
13:56:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:56:07 <ddarius> http://hpaste.org/44374/partitionsumofdivisors
13:57:18 <augur> copumpkin: hm. is there a clean version of diagonalization that doesnt factor out things ~ 1, etc.?
13:57:29 <copumpkin> how do you mean?
13:57:37 <copumpkin> @hackage control-monad-omega 
13:57:38 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
13:57:40 <augur> like, one that yields [1%1, 1%2, 2%2, 2%1, ...]
13:57:45 <augur> i dont want omega! :|
13:57:52 <augur> i want to understand it, not use it!
13:57:59 <copumpkin> hm
13:58:14 <augur> or actually
13:58:15 <augur> preferably
13:58:23 <copumpkin> not sure then
13:58:32 <augur> [1%1, 1%2, 2%1, 1%3, 2%2, 3%1, ...]
13:58:48 <augur> where the "equidistant" ones are congruent
13:58:50 <monochrom> oh, with redundancy is easy.
14:00:09 <monochrom> concat [ [ (x,y) | x<-[1..n], let y = n-x ] | n<-[2..] ]
14:01:31 <augur> monochrom: ok, do it without using math ;)
14:01:33 <monochrom> in recognition that when you do e.g. 1%3, 2%2, 3%1  numerator+denominator=4
14:01:52 <monochrom> sorry, I insist on using math, there is no other choice
14:02:15 <monochrom> > take 20 (concat [ [ (x,y) | x<-[1..n], let y = n-x ] | n<-[2..] ])
14:02:16 <lambdabot>   [(1,1),(2,0),(1,2),(2,1),(3,0),(1,3),(2,2),(3,1),(4,0),(1,4),(2,3),(3,2),(4...
14:02:30 <copumpkin> onoes
14:02:32 <monochrom> sorry, that errs
14:02:33 <copumpkin>  division by 0
14:02:50 <augur> monochrom: diagonalize [a,b] [c,d,e] = [(a,c), (a,d), (b,c), (a,e), (b,d), (b,e)]
14:02:53 <comex> so copumpkin: how to invert the bits in a number?
14:03:00 <copumpkin> :t complement
14:03:02 <lambdabot> forall a. (Bits a) => a -> a
14:03:03 <monochrom> > take 20 (concat [ [ (x,y) | x<-[1..n-1], let y = n-x ] | n<-[2..] ])
14:03:04 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3...
14:03:06 <ddarius> > complement 0
14:03:07 <lambdabot>   Ambiguous type variable `a' in the constraint:
14:03:07 <lambdabot>    `Data.Bits.Bits a'
14:03:07 <lambdabot>      a...
14:03:10 <copumpkin> > complement 0 :: Word32
14:03:11 <lambdabot>   4294967295
14:03:14 <ddarius> > complement 0 :: Integer
14:03:15 <lambdabot>   -1
14:03:33 <monochrom> > [(a,c), (a,d), (b,c), (a,e), (b,d), (b,e)]
14:03:33 <lambdabot>   [(a,c),(a,d),(b,c),(a,e),(b,d),(b,e)]
14:03:35 <monochrom> done
14:03:36 <aristid> > complement (-1) :: Integer
14:03:37 <lambdabot>   0
14:03:41 <aristid> > complement (-2) :: Integer
14:03:42 <lambdabot>   1
14:03:50 <copumpkin> that integer has infinite bits!
14:03:52 <aristid> > complement 1 :: Integer
14:03:53 <lambdabot>   -2
14:04:05 <hpaste> ddarius pasted "partition/sum-of-divisors"  http://hpaste.org/44374
14:04:13 <comex> thanks
14:05:18 <ddarius> Choosing a starting array size of 1024, say, rather than 2 in my bit trie will significantly improve the performance.
14:09:32 <monochrom> I don't know why diagonalize [a,b] [c,d,e] = [(a,c), (a,d), (b,c), (a,e), (b,d), (b,e)]
14:10:13 <hpaste> lpsmith pasted "diagonalization"  http://hpaste.org/44375
14:10:44 <lpsmith> I didn't take the time to figure out what should be done in finite cases.
14:10:54 <monochrom> haha
14:11:13 <monochrom> @remember lpsmith I didn't take the time to figure out what should be done in finite cases.
14:11:13 <lambdabot> Okay.
14:17:16 <augur> aha! got it!
14:17:18 <augur> mostly
14:18:05 <augur> ok lemme write this in haskell now
14:26:07 <augur> :D
14:27:18 <augur> so simple!
14:27:40 <augur> probably not what you'd want for an omega monad tho
14:30:19 <tromp_> :t neg
14:30:20 <lambdabot> Not in scope: `neg'
14:31:39 <siracusa> :t negate
14:31:40 <lambdabot> forall a. (Num a) => a -> a
14:35:41 <augur> copumpkin, monochrom:
14:35:47 <augur> http://hpaste.org/44376/stratifier
14:35:57 <hpaste> augur pasted "Stratifier"  http://hpaste.org/44376
14:36:03 <augur> that too
14:36:15 <augur> probably could clean it up but you get the point!
14:39:02 <augur> i wonder if i can make it take [[a]] instead of [a]
14:39:35 * hackagebot gnuplot 0.4.1.1 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.4.1.1 (HenningThielemann)
14:40:36 <augur> yes probably
14:53:49 <manizzle> are type classes kinda like templates?
14:53:55 <shlevy> Howdy. I'm trying to figure out when relativeTo will return Nothing. Am I missing something, or will it always return a value? http://hackage.haskell.org/packages/archive/network/2.1.0.0/doc/html/src/Network-URI.html#relativeTo
14:54:56 <shlevy> :t Network.URI.relativeTo
14:54:57 <lambdabot> Network.URI.URI -> Network.URI.URI -> Maybe Network.URI.URI
14:55:16 <shlevy> :source Network.URI.relativeTo
14:55:29 <shlevy> @source Network.URI.relativeTo
14:55:30 <lambdabot> Network.URI.relativeTo not available
14:55:30 <Heffalump> manizzle: not really, though the proposed C++ concepts feature is quite similar
14:57:44 <hpc> :t readArray
14:57:44 <lambdabot> Not in scope: `readArray'
14:57:49 <hpc> @hoogle readArray
14:57:49 <lambdabot> Data.Array.MArray readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
14:57:56 <revenantphx> Question: Do you guys have any recommendations for reading to learn about parsing. Just, in general and specific.
14:58:03 <revenantphx> Question Mark: ?
14:58:16 <mm_freak_> revenantphx: you mean independent of any specific library?
14:58:24 <revenantphx> mm_freak_: Yes. Theory type stuff.
14:59:01 <mm_freak_> revenantphx: then read about formal grammars
14:59:11 <revenantphx> Well, I'm asking for specific reading :P
14:59:19 <revenantphx> Like, recommendations on introductory type papers, books, etc
14:59:25 <revenantphx> preferably that I can get my hands on in the next 10 minutes.
15:00:34 <mm_freak_> well, for learning the wikipedia articles are "just enough" to get into the topic…  if you want something more thorough, prepare to put a few hours or days into dry theory and get a book
15:00:53 <revenantphx> I thought as much, any book recommendations then?
15:01:06 <mm_freak_> nope, sorry, but you may find some interesting links there, too
15:05:40 <siracusa> revenantphx: http://en.wikipedia.org/wiki/Dragon_Book_(computer_science), probably not available within the next 10 minutes, though :-P
15:06:10 <ddarius> Hmm.  The best way to represent functorial action of type constructors may be to "pattern match" in the context.
15:06:51 <revenantphx> I think it would be an interesting social experiment to force 100 enterprise java programmers to listen in on #haskell nonstop for an hour or two.
15:07:07 <revenantphx> (with access to wikipedia, etc)
15:07:10 <revenantphx> And then examine their productivity in the following weeks.
15:07:21 <Twey> I approve
15:07:27 <mm_freak_> does anyone know a good proxy client library?  any proxy type would be good
15:07:33 <revenantphx> mm_freak_: netcat.
15:07:48 <revenantphx> :3
15:08:27 <mm_freak_> a forward proxy, with which i can specify where to connect to
15:08:39 <mm_freak_> like HTTP CONNECT or SOCKS
15:09:30 <mm_freak_> but i'm afraid i'm going to have to write my own library (again)
15:09:55 <copumpkin> seems like a good library to have
15:10:17 <shlevy> Is there any way to define an algebraic datatype in ghci?
15:10:58 <copumpkin> no
15:11:00 <mm_freak_> true, and i think CONNECT is the easiest to implement
15:11:34 <ddarius> revenantphx: I read this a very long time ago (like 12 years ago).  I'm not sure if I'd recommend it, but it's there and parsing theory is a fairly well understood field at this point. http://www.scifac.ru.ac.za/compilers/
15:11:47 <augur> copumpkin! \o/
15:11:49 <augur> ive got my solution!
15:11:54 <copumpkin> augur: :O
15:12:16 <augur> http://hpaste.org/44378/better_stratifier
15:12:27 <hpaste> augur pasted "Better Stratifier"  http://hpaste.org/44378
15:12:30 <augur> and that.
15:12:35 <augur> i should stop doing this
15:13:27 * copumpkin doesn't really get what stratifier does :)
15:13:42 <augur> diagonalization!
15:13:47 <augur> sort of.
15:14:02 <augur> oh the twists and turns that were about to go on to get to this
15:14:04 <augur> ok, so!
15:14:17 <augur> suppose you have a CFG with ordered rules
15:14:56 <augur> but crucially the rules are partially ordered -- only rules for the same non-terminal are ordered relative to one another and that ordering is partial too
15:14:57 <basti_> wow they integrated hlint into hpaste. i haven't seen that before :)
15:15:24 <ddarius> basti_: It's pretty nice.
15:15:36 <augur> this way you have the ability to say that there are "preferred" ways of building this kind of X
15:15:47 <augur> maybe you say X -> Y << Z << W
15:16:04 <augur> which says X can be made of a Y Z or W, take your pick, but Y is more preferred than Z and Z more preferred than W
15:16:37 <copumpkin> hm
15:16:43 <augur> ok now suppose you have also X' -> Y' << Z' << W'
15:16:50 <augur> and S -> X X'
15:17:21 <augur> so what are the most preferred Ses?
15:17:24 <augur> the second most? etc.
15:17:29 <augur> stratifier!
15:17:52 <augur> the most preferred S is Y Y'
15:18:36 <augur> S -> Y Y' << (Y Z' | Z Y') << (Y W' | Z Z' W Y') << (Z W' | W Z') << W W'
15:18:53 <augur> where | is equally preferably disjunction
15:19:15 <augur> hence, each thing joined by << is a stratum of equally good combinations
15:19:44 * hackagebot netlines 0.1.0 - Enumerator tools for text-based network protocols  http://hackage.haskell.org/package/netlines-0.1.0 (ErtugrulSoeylemez)
15:19:45 * hackagebot ismtp 2.0.1 - Advanced ESMTP library  http://hackage.haskell.org/package/ismtp-2.0.1 (ErtugrulSoeylemez)
15:19:51 <ddarius> @google context free grammar sheaf category theory
15:19:53 <lambdabot> http://math.mit.edu/~dspivak/cs/technical_proposal2010.pdf
15:19:53 <lambdabot> Title: Technical Proposal
15:19:55 <augur> but notice that each of these is also one diagonal sweep in the classical depiction of diagonalization!
15:19:59 <augur> ddarius: what is this :|
15:20:40 <ddarius> I have no idea.  I'm just considering whether context free grammars would be nice as (pre)sheaves, and if anyone has done anything with it before.
15:20:45 <augur> o ok
15:20:51 <augur> copumpkin: so you see, stratify!
15:21:05 <copumpkin> sort of :P
15:21:18 <ddarius> (Though, actually, I was aware of the stuff related to the paper lambdabot returned, which, as far as I can tell, isn't related to CFGs.)
15:21:18 <augur> :D
15:21:25 <wagle> dspivak is doing interesting stuff also with ontology (semantic web) and databases
15:21:34 <ddarius> @google "context free grammar" sheaf "category theory"
15:21:36 <lambdabot> http://math.mit.edu/~dspivak/cs/technical_proposal2010.pdf
15:21:36 <lambdabot> Title: Technical Proposal
15:22:06 <ddarius> wagle: Yeah, he gave a talk at the Boston Haskell User Group last month, and I had read his work earlier than that.
15:22:12 <augur> copumpkin: its just a way of figuring out how to enumerate a CFG, really
15:22:32 <wagle> he was in oregon until he moved to mit
15:23:00 <augur> everything in the same stratum is equally "deep" in terms of the choices
15:23:50 <copumpkin> augur: ah I see
15:24:03 <augur> thats another way of looking at it. X -> Y | Z | W, X' -> Y' | Z' | W'
15:24:14 <augur> we dont want to try to enumerate all the X -> Y's first, right
15:24:36 <augur> thats the point of diagonalization -- we can get to everything in finite time
15:25:17 <copumpkin> oh yeah, I wrote an enumerator for a CFG at some point
15:25:50 <augur> to do that you'd just need to join the results and you've got an enumerator
15:26:31 <ddarius> A coalgebraic view of CFGs would probably work much better here than what I was thinking.
15:26:38 <augur> if you dont join the results, you have a CFG with ranked alternatives, and each stratum is a set of alternatives that are ranked equally
15:27:36 <augur> so you can think of this as an enumerator for a PCFG with only relative probability taken into account, and it preserves relative probability in the output
15:27:38 <copumpkin> I started writing an enumerator for CFGs in agda way back in the day too
15:27:52 <augur> so things that are most likely are in the first stratum, things that are next most likely in the second stratum, etc.
15:27:55 <copumpkin> but started yak shaving and failed at that
15:27:59 <ddarius> Though the presheaf view is kind of pretty too.
15:28:53 <shlevy> How is record update syntax desugared?
15:30:30 <monochrom> I don't think that's desugared.
15:30:41 <Saizan> @where report
15:30:41 <lambdabot> http://www.haskell.org/onlinereport/
15:30:42 <augur> ok, back to working
15:31:14 <mm_freak_> agenda:  write an SSL/TLS enumeratee and a CONNECT proxy client library…  i hope, i'm not reinventing the wheel
15:31:23 <monochrom> but I guess you can consider r{x=5} as C{x=5, y=r y, z=r z}
15:32:15 <mm_freak_> the network protocol implementors among you may find the 'netlines' library useful…  particularly the enumHandleTimeout enumerator, which is really a missing feature in the 'enumerator' package
15:32:15 <hpc> monochrom: y r
15:32:17 <shlevy> Saizan: You could respond that way to any question that doesn't involve a non-core library
15:32:20 <Saizan> the report says that it pattern matches
15:32:28 <Saizan> shlevy: i was looking for myself
15:32:41 <shlevy> Saizan: Oh, sorry. 
15:33:08 <Saizan> http://www.haskell.org/onlinereport/exps.html <- section 3.15.3 btw
15:33:19 <shlevy> Saizan: Thanks
15:36:01 <shlevy> What's a good heuristic for deciding between Either and Maybe?
15:37:18 <mm_freak_> shlevy: if you need more information about failure than the fact that something failed, then use Either
15:37:24 <hpc> shlevy: can you fail in exactly one way? Maybe!
15:37:30 <hpc> need more info? Either!
15:37:42 <hpc> need a whole lot of info? refactor!
15:38:20 <mm_freak_> shlevy: 'Either e' is a monad implementing exceptions, where an exception is of type 'e'
15:39:25 <shlevy> Actually, my choice is between Maybe, Either, or an incomplete pattern match
15:39:51 <mm_freak_> incomplete as in non-exhaustive?
15:39:59 <shlevy> mm_freak_: Yeah
15:40:04 <mm_freak_> bad choice
15:40:16 <sipa> just use error!
15:40:17 <sipa> *ducks*
15:40:18 <mm_freak_> very bad choice…  this is a very dirty version of Maybe
15:40:45 <HugoDaniel> i love my monads
15:42:38 <shlevy> Ok. This distinction comes from Java, but: Do Haskell programmers have a differentiation of errors like RunTimeException versus normal Exception?
15:42:53 <hpc> sipa: lol
15:43:24 <blackdog> shlevy: what would that mean?
15:44:15 <chrisf|work> shlevy: do you mean checked vs unchecked java exceptions?
15:45:15 <shlevy> blackdog: Well, what it means in terms of language implementation is whether programmers who use those methods are required to check for the exception. But what I'm thinkin of is a difference between programming errors and resource failure.
15:46:49 <bicilotti> I am trying to compile LambaHack and failing miserably. What's the correct syntax, "cabal install LambdaHack"?
15:47:03 <hpc> chrisf|work: checked exceptions are watched by the compiler; they need to have a handler when you compile the code
15:47:06 <hpc> unchecked don't
15:47:35 <hpc> the result being if you have a checked exception you can prove doesn't happen, through validating input, you still need an extraneous try-catch block
15:47:39 <chrisf|work> hpc: i'm aware of that ;)
15:47:49 <hpc> oh lol
15:48:05 <shlevy> Basically, my impression of Java best practice is that you use a checked exception when the client code can do something about it at runtime, and unchecked otherwise
15:49:31 <shlevy> And that programming errors (e.g. passing something constructed with the wrong constructor to a method that only deals with a certain constructor) would be unchecked
15:49:57 <chrisf|work> my impression was that checked exceptions in java were a very bad idea ;)
15:50:25 <bicilotti> "Cannot find gtk2hsC2hs" <- :)
15:50:26 <shlevy> chrisf|work: Aren't Maybe, Either, etc. just like checked exceptions? 
15:50:30 <bicilotti> :(
15:50:48 <shlevy> chrisf|work: You have to take into account that an error might occur and possibly deal with it if you want to get the value
15:51:16 <shlevy> @source :
15:51:17 <lambdabot> : not available
15:51:21 <shlevy> @source (:)
15:51:22 <lambdabot> (:) not available
15:51:28 <chrisf|work> shlevy: the difference is that haskell doesnt impose a *massive* syntactic burden in the very common "i dont care" case ;)
15:51:29 <sipa> :t (:)
15:51:31 <lambdabot> forall a. a -> [a] -> [a]
15:52:34 <chrisf|work> in java a try/catch block isnt even an expression :(
15:52:42 <shlevy> @source head
15:52:43 <lambdabot> head not available
15:52:52 <shlevy> @source Data.List.head
15:52:52 <lambdabot> Data.List.head not available
15:53:17 <augur> ok people
15:53:19 <augur> CTists
15:53:19 <hpc> chrisf|work: you can make it an expression, by making an anonymous class with a run method, then calling the run method
15:53:23 <hpc> :P
15:53:30 <hpc> java-lambda!
15:53:49 <chrisf|work> the kludgiest noisiest lambda syntax ever :D
15:53:56 <Saizan> bicilotti: you've to install gtk2hs-buildtools or something like that
15:54:05 <augur> if X is a post x <= y, x <= z, and A is a poset a <= b <= c
15:54:07 <hpc> chrisf|work: extra credit for currying!
15:54:18 <kleinucopia> hi, I need to do search engine lookups and retrieve the number of hits for each query. Is there a haskell package that can help, or must I scum through HTML files?
15:54:52 <augur> why does X have 5 2-elements : 2 -> X, and A have 6 2-elements : 2 -> A
15:54:55 <ddarius> chrisf|work: Try some XSLT.
15:55:06 <Saizan> kleinucopia: for the latter tagsoup should help
15:55:29 <hpc> ddarius: i wouldn't wish that on /hitler/!
15:55:31 <copumpkin> augur: A has a <= c
15:55:47 <augur> copumpkin: yes i get that, but why does that help?
15:55:48 <ddarius> augur: id_x, id_y, id_z, x->y, x->z; id_a, id_b, id_c, a->b, b->c, a->c
15:56:10 <chrisf|work> actually, i think being forced to use XSLT would be a pretty good punishment for war crimes.
15:56:28 <augur> ddarius: i suppose im not getting then what 2 -> X and 2 -> A are doing
15:56:36 <augur> 1 -> X should give the elements of x, right?
15:57:28 <shlevy> Ah, this is what I was looking for http://www.haskell.org/haskellwiki/Error_vs._Exception
15:57:39 <artefon> hi, what is the best way to keep track of the progress of a function that takes a long time?
15:57:59 <kleinucopia> Saizan: do you know if there are google, yahoo, etc. search API bindings for haskell? I couldn't come up with anything in hackage.
15:58:05 <augur> i mean, i think i see where you're going with 2 -> X -- one of the 2's gives you the elements, the other gives you the orderings
15:58:28 <augur> but then does 1 -> X behave similarly?
15:58:52 <augur> 1 -> X into the orderings has 2, but 1 -> A into the orderings has three
16:00:57 <ddarius> As a category, a poset is the obvious thing, you have an arrow A -> B if A <= B.  2 is the category that looks like a single arrow.  Each functor from 2 into a poset category P maps onto an arrow.  So the set of functors 2 -> P is the set of arrows of P.
16:01:16 <shlevy> From that article "These ASSERTs can be disabled by a compiler switch for efficiency concerns". How?
16:01:16 <ddarius> 1 is a category that's just an object.  The set of functors 1 -> P is the set of objects of P.
16:03:02 <ddarius> You can think of a 1 or 2 as the "shape" of an object or arrow respectively.  Then a functor from 1 or 2 is a "diagram" of that shape.
16:03:04 <Saizan> kleinucopia: i only know of a google translate binding
16:03:19 <kleinucopia> Saizan: thx anyway :)
16:03:33 <geheimdienst> shlevy, use the compiler switch -O or -fignore-asserts
16:03:37 <geheimdienst> @hoogle assert
16:03:38 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:03:38 <lambdabot> Control.OldException assert :: Bool -> a -> a
16:03:38 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
16:04:08 <augur> ddarius: ah, but if 2, X, and A are in the category Pos of posets, f is supposed to be a morphism
16:04:14 <geheimdienst> shlevy: see also http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:assert
16:04:29 <shlevy> geheimdienst: Thanks
16:04:38 <augur> in such a case, are the elements of 2, X, and A taken to be the objects and arrows of the categories 2, X, and A?
16:06:17 <ddarius> The category of Posets is equivalent to the category of categories with at most one arrow between any two objects.
16:06:49 <augur> ok
16:07:07 <augur> but how does that connect up?
16:07:42 <ddarius> A functor between poset categories (i.e. posets viewed as categories, not the category of posets) is exactly a monotonic function.
16:07:59 <augur> i mean, ok, firstly, is 1 -> X giving, necessarily, the objects of X, and not the arrows of X?
16:08:08 <ddarius> Yes.
16:08:13 <augur> why cant it give arrows?
16:08:17 <ddarius> How would it?
16:08:30 <augur> why would 2 -> X give arrows?! i :|
16:08:58 <Eduard_Munteanu> 1 the 1-category or terminal object?
16:09:11 <augur> {*}
16:09:15 <Eduard_Munteanu> Ah.
16:09:19 <augur> the 1-poset
16:09:20 <ddarius> Because, as a category, 2 is a category with two objects and one non-identity arrow.  That non-identity arrow can be mapped by a functor to any particular arrow of another category.
16:09:32 <ddarius> augur, Eduard_Munteanu: Those are equivalent.
16:10:07 <augur> ok, so when treating the categories as objects in a category, morphisms ~ functors
16:10:30 <augur> so since 1 has no arrows (except the identity arrow) 1 -> X maps only objects
16:10:31 <ddarius> (Well, technically I need to add the condition "and no non-identity isomorphisms" otherwise it's equivalent to preorders not posets.)
16:11:09 <augur> whereas 2 has one arrow, and so can map that arrow to (i guess multiple) arrows
16:11:44 <ddarius> augur: Any particular functor (monotonic function) will only map that arrow to a single other arrow, but it can be -any- other arrow in the target.
16:12:22 <ddarius> The set of all those functors (monotonic functions) is bijective to the set of arrows (comparable [ordered] pairs) in the target
16:12:38 <augur> oh, so its more that there are 5 functors from Cat2 to CatX, while theres 6 from Cat2 to CatA
16:12:46 <augur> right ok
16:12:49 <ddarius> Yes.
16:12:53 <augur> ok!
16:12:54 <augur> :D
16:13:03 <copumpkin> augur: isn't it fun!?
16:13:14 <augur> understanding is totally fun :D
16:13:16 <Eduard_Munteanu> I'm clearly too late here, haven't seen A and X defined. :/
16:13:27 <augur> X = { x <= y, x <= z }
16:13:34 <augur> A = { a <= b <= c }
16:13:56 <Eduard_Munteanu> Posets and preorders?
16:14:13 <augur> both are posets
16:14:19 <augur> just different ones
16:14:22 <augur> thats the only thing at issue
16:14:28 <copumpkin> they're also preorders :)
16:14:31 <augur> that too!
16:14:34 <Eduard_Munteanu> Ah.
16:14:47 <Eduard_Munteanu> So you literally mean a, b and c as objects.
16:15:07 <copumpkin> anyone want to admire my CT creation?
16:15:16 <augur> yes!
16:15:18 <copumpkin> https://github.com/pumpkin/categories
16:15:22 <ddarius> The poset 2 is, actually, rather important, and is the subobject classifier for the topos of posets.
16:15:22 <copumpkin> still horribly incomplete
16:15:28 <Eduard_Munteanu> Dang I need a github blog too.
16:15:40 <augur> horrible
16:15:49 <augur> whats a github blog
16:15:51 <copumpkin> I have lots of empty modules in there :)
16:15:53 <copumpkin> sadly
16:15:59 <Eduard_Munteanu> Oh.
16:16:07 <augur> also, i hate github
16:16:16 <augur> it wont upload files correctly for me :(
16:16:25 <Eduard_Munteanu> augur: github can generate pages for you, so you can actually host proper web pages (like blogs) there!
16:16:26 <augur> maybe im just doing it wrong
16:16:34 <copumpkin> augur: probably
16:16:36 <ddarius> copumpkin: I'm vaguely considering formalizing Wildberger's ideas (or ideas that he would approve of) in Nuprl mostly depending on just how grotty Nuprl is to use.
16:16:41 <augur> but if so, then git has a horrible UI :(
16:16:45 <copumpkin> ddarius: rational trig?
16:16:48 <copumpkin> or what part of it?
16:16:53 <ddarius> copumpkin: Not just rational trig.
16:17:13 <ddarius> In fact, probably not too much of rational trig as that's basically a few straightforward definitions and five equations.
16:17:28 <shlevy> augur: Why do you hate github?
16:17:36 <Eduard_Munteanu> augur: I don't really like github's interface either, or maybe I'm not used to it. I prefer stuff like repo.or.cz or git.kernel.org, it just looks cleaner.
16:17:53 <chrisf|work> augur: most power tools have a "horrible ui" if you decide you *must* get your fingers involved with the business end ;)
16:17:54 <augur> shlevy: "augur: it wont upload files correctly for me :("
16:18:02 * hackagebot theoremquest 0.0.0 - A common library for TheoremQuest, a theorem proving game.  http://hackage.haskell.org/package/theoremquest-0.0.0 (TomHawkins)
16:18:13 <ddarius> copumpkin: There's stuff like rational curvature, polynumbers, his "type" based view of mathematical structures (which fits very closely with how Nuprl works) and his geometry.
16:18:14 <shlevy> augur: Whoops, missed that
16:18:15 <copumpkin> a theorem proving game!
16:18:19 <chrisf|work> augur: what exactly is going wrong?
16:18:28 <ddarius> copumpkin: And it wouldn't be too hard for me to formalize other areas in his kind of style.
16:18:29 <copumpkin> ddarius: ah, I need to look at more of his stuff
16:18:36 <augur> chrisf|work: if i knew exactly what was going wrong i'd be a github developer not a github user ;P
16:18:39 <shlevy> Eduard_Munteanu: Really? I find it much easier to navigate github than git.kernel.org
16:18:41 <augur> i can tell yo the behavior tho!
16:18:56 <ddarius> copumpkin: Watch out!  The final boss is the Riemann Hypothesis.
16:19:00 <copumpkin> lol
16:19:01 <augur> i add a file then commit, and it never shows up.
16:19:02 * hackagebot theoremquest-client 0.0.0 - A simple client for the TheoremQuest theorem proving game.  http://hackage.haskell.org/package/theoremquest-client-0.0.0 (TomHawkins)
16:19:18 <Eduard_Munteanu> augur: surely you know you must push, right?
16:19:33 <copumpkin> chpwn: oh you like haskell too!
16:19:35 <Eduard_Munteanu> Otherwise it's just your local repo.
16:19:38 <ddarius> Though I have actually considered what would happen if you formulated proving certain conjectures as games.
16:19:48 <augur> Eduard_Munteanu: that might be the problem!
16:20:14 <copumpkin> https://github.com/tomahawkins/theoremquest/blob/master/notes
16:20:26 <Eduard_Munteanu> augur: ah, it's understandable if you come from CVS/SVN. In Git you rather work with your local copy.
16:20:27 <copumpkin> looks kinda cute :)
16:20:41 <augur> i dont come from anything
16:20:50 <Eduard_Munteanu> Heh, copumpkin 
16:20:55 <Eduard_Munteanu> Ah.
16:20:57 <shlevy> augur: Git is distributed, so committing just updates your local copy. To update another copy (github, in this example), you'll need to push
16:21:03 <augur> i was just going by the github intro which, as far as i remember, has no push step
16:21:07 <shlevy> And Eduard_Munteanu beat me to it :)
16:21:13 <copumpkin> augur: I'd be very surprised if they didn't mention push
16:21:20 <copumpkin> since without it nothing really happens with their site :P
16:21:39 <geheimdienst> pushing might be in the chapter on how to work with others on the same repo ...
16:21:51 <augur> im probably just an idiot when it comes to repositories
16:22:26 <hpc> @hoogle PortNumber
16:22:27 <lambdabot> Network PortNumber :: PortNumber -> PortID
16:22:27 <lambdabot> Network data PortNumber
16:22:27 <lambdabot> Network.BSD data PortNumber
16:22:58 <Eduard_Munteanu> Or admin-ing your own repo.
16:23:23 <Eduard_Munteanu> Most stuff happens on a local repo and changes are sent by mail, usually.
16:23:58 <Eduard_Munteanu> (though somebody has to push, or commit directly into a repo published by a Git server)
16:25:18 <augur> yyyeah
16:25:24 <augur> i have no idea what im doing with this stupid git crap
16:26:42 <geheimdienst> augur, i found both mercurial (hg) and darcs much easier to use than git, even if they don't have a snazzy website like github
16:26:51 <augur> i feel like all of these pages explaining how to use git are backwards
16:27:11 <shlevy> augur: Have you ever used any source control system?
16:27:16 <augur> shlevy: no
16:27:33 <augur> instead of babysteps up to using git, they work backwards from other versioning systems down to the basics
16:27:37 <mm_freak_> augur: you may want to start with darcs, which has a very simple interface
16:27:46 <mm_freak_> mostly you need only four commands
16:27:54 <mm_freak_> init, record, tag and whatsnew
16:28:15 <Eduard_Munteanu> Yeah, I hear darcs is easier and offers lots of help, never used it though.
16:28:42 <shlevy> shlevy: Ok. A basic git workflow: modify current working, git add ., git commit -m "Commit message", git push
16:28:50 <chrisf|work> darcs also provides ample opportunities to go make a cup of coffee while you're waiting.
16:28:54 <Eduard_Munteanu> Talking to yourself? :P
16:29:00 <shlevy> Whoops
16:29:01 <mm_freak_> yeah, darcs is about the easiest i've ever used…  you can't do fancy merging stuff like in git, but it suffices for most people
16:29:05 <augur> http://help.github.com/
16:29:07 <augur> i mean what is this
16:29:12 <shlevy> augur: Ok. A basic git workflow: modify current working, git  add ., git commit -m "Commit message", git push
16:29:19 <augur> Repos about creating/deletion/moving
16:29:23 <chrisf|work> augur: read `pro git` and `git for computer scientists`.
16:29:23 <augur> then collaborating
16:29:33 <augur> THEN everday git?
16:29:38 <lispy> and the visual guide to git
16:29:51 <lispy> Then be ready to google whenever git says anything because the messages are incomprehensible :)
16:29:54 <augur> because collaborating with git can be done without knowing how to use git for non-collaborative purposes?
16:30:04 <augur> and why does everyday git start with working with remotes?
16:30:05 <augur> whats a remote?
16:30:13 <augur> i dont know what a remote is
16:30:17 <Eduard_Munteanu> I hear this is good... http://progit.org/book/
16:30:18 <chrisf|work> a remote is another related repository somewhere else.
16:30:21 <mm_freak_> that stuff you control your TV with
16:30:26 <lispy> I found it useful to put the $? in my prompt string because I frequently couldn't tell the different between git success messages and git error messages
16:30:28 <chrisf|work> like the one you cloned from.
16:30:29 <augur> chrisf|work: thats not the point
16:30:36 <shlevy> augur: You don't need to right now :) Everyday Git must suck as an intro if that's what it starts with
16:30:38 <geheimdienst> yes, git has tons of off-beat terms
16:30:39 <Eduard_Munteanu> Yes, like chrisf|work says
16:30:55 <augur> the point is not "please tell me what a remote is"
16:30:58 <shlevy> augur: I've been using git for a few years now and never used a remote.
16:31:07 <Eduard_Munteanu> augur: a remote is also the way you'll specify where to push the changes (and how)
16:31:14 <chrisf|work> shlevy: really? o_O
16:31:18 <augur> the point is "you shouldnt start explaining how to use git for everyday purposes by talking about remotes but not explaining remotes"
16:31:20 <lispy> shlevy: interesting, I use remotes all the time when using git
16:31:37 <JuanDaugherty> so the remote brings the social aspect in dunnit?
16:31:48 <chrisf|work> JuanDaugherty: more or less.
16:31:52 <lispy> JuanDaugherty: more like an alias
16:32:01 <lispy> JuanDaugherty: github brings in the social aspect
16:32:05 <augur> if you ever see me complaining about something, this is not an invitation to explain it. when i complain, its because i think something is wrong, not because i want to understand. :P
16:32:06 <shlevy> augur: That being said, a crappy intro doesn't mean the tool itself sucks. The first thing I read about Haskell was Real World Haskell, and it was awful for someone who knew nothing about fp
16:32:21 <JuanDaugherty> I meant for DVCS.
16:32:24 <Eduard_Munteanu> augur: basically you start by adding the remote to ~/.gitconfig, then you can use 'git push' on that remote's name
16:32:27 <augur> shlevy: no i know, but this is the official github help file
16:32:33 <augur> Eduard_Munteanu: i will stab you in the face
16:32:33 <Eduard_Munteanu> Oh.
16:32:34 <Eduard_Munteanu> :)
16:32:58 <Eduard_Munteanu> Ok, I wasn't reading, I was just typing :)
16:33:00 <geheimdienst> augur, seriously, i can only recommend darcs. it's much nicer than git
16:33:05 <shlevy> chrisf|work, lispy: Perhaps I'm not utilizing git fully? 
16:33:05 <chrisf|work> augur: i believe you picked a poor tutorial.
16:33:14 <augur> chrisf|work: probably! shame its the official help file :|
16:33:31 <lispy> shlevy: well, for me github is the reason to use git. YMMV
16:33:41 <chrisf|work> shlevy: as a maintainer i use remotes all the time.
16:33:44 <stepkut> and git is the reason not to use git :p
16:33:59 <Eduard_Munteanu> shlevy: well it's kinda normal not to use remotes, especially if you don't have your own repo. It's perfectly okay just to git-send-email your patches.
16:34:29 <Eduard_Munteanu> IDK, I like Git. Will try darcs some day when I get to hack on a Haskell project.
16:34:37 <shlevy> lispy: I use git for github too, but I've only ever had one github project that I started. The rest started off with a git clone, so I guess the remote part was already done for me?
16:34:42 <augur> heres what i want: GUI that shows the version tree with changes as arrows labeled with the change. i can drag and drop a file onto a node in the tree to add or change, i can select a file in a node hit delete to remove it
16:34:53 <lispy> shlevy: ah yes
16:35:00 <augur> doing this to non-leaves constitutes a fork of some previous version
16:35:04 <augur> why is this so hard? :(
16:35:36 <lispy> augur: isn't that what gitk (or was it gitgui? something like that) does?
16:35:41 <augur> dunno!
16:35:46 <chrisf|work> augur: there are various history viewers for git
16:36:01 <chrisf|work> they are an important part of your toolkit.
16:36:07 <augur> but the point is really that these operations should also be CLable with identical structure
16:36:14 <geheimdienst> lispy, gitk mostly only displays the history. i'm fairly sure you can't do things like drag files onto patches
16:36:21 <augur> git version add file
16:36:23 * shlevy wonders why anyone thinkgs augur wants us to explain git concepts when he's clearly just venting about the tutorial
16:36:26 <augur> git version remove file
16:36:42 <augur> shlevy: i wonder the same thing too, especially when i explicitly said this :)
16:37:21 <Eduard_Munteanu> shlevy: no, unless you set up the remote for pushing, you don't actually need one.
16:37:34 <Eduard_Munteanu> It's more common to just send patches.
16:37:36 <augur> and you know, fine, if you have local vs. remote stuff, lovely, but git seems to complicate this enormously, from what i can see
16:37:43 <augur> ok back to CT
16:37:44 <Eduard_Munteanu> One man, one pusher per repo
16:38:03 <Eduard_Munteanu> augur: or git tutorial
16:38:05 <Eduard_Munteanu> *s
16:38:08 <augur> ?
16:38:44 <Eduard_Munteanu> It's not particularly complicated, it might be just the tutorial you read.
16:39:47 <geheimdienst> Eduard_Munteanu: in my experience, git _is_ complicated. lots of commands with lots of switches, many of them inconsistent, tons of technical terms (stage, index, blob, tree ...)
16:41:06 <Eduard_Munteanu> Yeah, it's confusing at first. Especially if you come from a CVS/SVN background and pulling ain't CVS pulling, fetching ain't CVS fetching
16:41:40 <chrisf|work> it is complicated and hard to use right up until the point where your mental model matches what's actually going on -- then it's very natural.
16:43:02 * shlevy has never used anything but git and therefore thinks all other SCMs are just terrible
16:44:01 <copumpkin> darcs is pretty nice
16:44:19 <Eduard_Munteanu> Most others are, Git's model is way saner.
16:44:23 * JuanDaugherty soured on darcs a few years ago.
16:44:29 <copumpkin> Eduard_Munteanu: saner how?
16:44:46 * alip grabs popcorn
16:44:48 <Eduard_Munteanu> I think the distributed paradigm is better.
16:44:50 <geheimdienst> all i know is that i have used git for a while, then wanted to change my bash prompt to show the numbers of new/changed/staged files. after some fiddling, i went on #git, and they basically told me "what, are you stupid or something? git ls-files --cached of course doesn't list the cached files"
16:44:57 <copumpkin> darcs is just as easily distributed
16:44:59 <djahandarie> I think darcs model is nicer, I'm pretty sure the main reason that people don't use it is due to performance problems
16:45:12 <geheimdienst> since then, i've been a darcs user :)
16:45:24 <djahandarie> code.haskell.org going down probably didn't help the situation
16:45:28 * JuanDaugherty don't wan't people messin around with flaky ass theories they haven't worked out on vcs.
16:45:38 <blackdog> geheimdienst: if you went on the basis of friendliness of user communities, you'd be using haskell rather than C
16:45:40 <maurer_> Is there anything like github, but for darcs?
16:45:42 <blackdog> ... wait a minute
16:45:49 <Eduard_Munteanu> My understanding is Git and darcs have a very similar model, perhaps except darcs goes to lengths to solve patch dependencies and conflicts.
16:45:58 <JuanDaugherty> nah
16:45:58 <djahandarie> maurer_, patchtag
16:46:01 <shachaf> geheimdienst: Yes. Admittedly both people in #darcs are pretty nice.
16:46:38 <JuanDaugherty> the only thing they have in common is they're both DVCS
16:46:39 <copumpkin> Eduard_Munteanu: git tracks the state of the entire repo at any given time, and figures out changes as differences in that state, whereas darcs is tracking changes and figures out states by applying all the changes
16:46:54 <copumpkin> darcs is the derivative of git
16:46:55 <Eduard_Munteanu> Is darcs' patch editing facilities any good? I think Git rocks there too, even though people sometimes mention StGit and all that stuff that isn't necessary.
16:46:58 <copumpkin> :P
16:47:13 <sm> maurer_: two: http://patch-tag.com and http://darcsden.org
16:47:19 <shlevy> If you're not pattern-matching on a function argument, is it ever better to not write the function point-free with respect to that argument?
16:47:23 <djahandarie> Ah right, darcsden too.
16:47:26 * JuanDaugherty actually forgot he was in #haskell.
16:47:32 <maurer_> I'm checking out patchtag now. Any reason to use one over the other?
16:47:57 <Eduard_Munteanu> shlevy: how do you pattern-match pointfree?
16:48:14 <sm> darcsden has forking and inter-fork pulling support, but is not as reliable as patchtag (because of insufficient hosting)
16:48:19 <shlevy> Eduard_Munteanu: If you're *not* pattern matching on a given argument
16:48:34 <sm> these two really need a champion to combine them.. neither current maintainer has the time
16:48:35 <Eduard_Munteanu> Sorry, I should read better.
16:48:39 <geheimdienst> that's not even the main thing, irc friendliness is a nice bonus but i can cope without it. what crosses the line for me is a command-line interface apparently designed by old-world monkeys. how can you name stuff so misleadingly that "git ls-files --cached" does not list the cached files, and then have unclear docs about it?
16:49:21 <geheimdienst> anyhoo, i prefer darcs or mercurial, i find git fast but overly complicated
16:49:21 <JuanDaugherty> Old-world monkeys.
16:49:42 <geheimdienst> yes, possibly even old world monkeys
16:49:57 <ddarius> geheimdienst: Wouldn't poor name choice and poor documentation go together?
16:50:02 <augur> im so confused about why epis and monos make sense :(
16:50:42 <augur> well, the sections and retractions stuff, anyway
16:50:52 <JuanDaugherty> everybody who has an idea for a new whizbang vcs should just stifle themselves if they can't do something spectacular with merge
16:50:55 <wagle> @hoogle sort
16:50:55 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
16:50:55 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
16:50:55 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
16:51:08 <augur> ddarius: can i bug you some more off channel
16:51:20 <geheimdienst> ddarius: absolutely
16:51:24 <shlevy> Does anyone have any problems with how git actually works, or just with interface?
16:51:24 <copumpkin> why not ask in the channel?
16:51:26 <JuanDaugherty> last I knew darcs couldn't even guarantee reliable operation on normal vcs ops
16:51:40 <djahandarie> copumpkin, because then no one else can absorb his knowledge
16:51:46 <shlevy> That is: Assuming you knew git syntax as well as you knew English, would you have any problems?
16:51:47 <djahandarie> augur wants it all for himself.
16:51:50 <augur> copumpkin: its pretty low level CT stuff, and i dont want to derail the on topic conversations
16:52:00 <copumpkin> augur: you mean all the talk of source control in #haskell?
16:52:05 <copumpkin> yeah, I guess we shouldn't disturb that
16:52:06 <augur> that too :P
16:52:11 <djahandarie> We need #categorytheory
16:52:18 <copumpkin> djahandarie: you said it
16:52:24 <Eduard_Munteanu> augur: if you studied sections and retractions for normal functions, you should find it easy for epis/monos.
16:52:25 <sm> yes please
16:52:31 <augur> created!
16:52:42 <copumpkin> ## seems more appropriate
16:52:58 <wagle> whats the diff between # and ##?
16:52:59 <djahandarie> Bah
16:53:02 <augur> fine!
16:53:03 <djahandarie> Stupid freenode policies
16:53:20 <Eduard_Munteanu> Topic-centred channels should be '##' IIRC.
16:53:30 <Saizan> i thought #haskell == #categorytheory up to isomorphim
16:53:33 <shlevy> Topic-centred as opposed to?
16:53:37 <augur> Saizan: x3
16:53:37 <copumpkin> Saizan: unique isomorphism?
16:53:48 <shlevy> How do you add a quote?
16:53:57 <wagle> Saizan++
16:53:57 <Eduard_Munteanu> UMP!
16:54:41 <geheimdienst> i thought it was something like: #java would be sanctioned by sun/oracle (whatever sanctioned means), ##java would be just guys chatting about java
16:54:58 <wagle> just to be pedantic, how about ##category-theory
16:55:03 <Saizan> copumpkin: heh, you want to define the category of irc channels for me?:)
16:55:22 <geheimdienst> #categorical-theory
16:55:26 <sm> JuanDaugherty: I'm interested, got an example of that ? in #darcs if you prefer
16:55:27 <djahandarie> What would be the morphisms?
16:55:52 <copumpkin> wagle: I'm indifferent, but if you can convince people to join the other one 
16:56:01 * djahandarie doesn't care either
16:56:03 <Eduard_Munteanu> Redirects?
16:56:18 <copumpkin>  /sajoin ddarius ##categorytheory
16:56:36 <wagle> just thinking to be consistant with the naming of other channels
16:56:56 <wagle> since we get stuck with whatever is decided now
16:57:11 <shlevy> Stuck, until we forget that it exists :)
16:57:22 <JuanDaugherty> sm: example of a failure, no. And i could be out of date. I was intended to use darcs as my preferred vcs c. '06 when i realized it's various shortcomings
16:57:36 <JuanDaugherty> *intending
16:59:07 <djahandarie> wagle, I think hyphens are reserved for #somenamehere-sidechannel
16:59:13 <djahandarie> Like #haskell-blah
16:59:17 <JuanDaugherty> SFAIK, the Theory of Patches is still largely a chimera as far as the pot of gold and the end or the rainbow I mentioned, i.e. superior merge.
16:59:37 <wagle> djahandarie: oh
16:59:58 <JuanDaugherty> but I would presume it's far better on basic vcs ops
17:00:01 <djahandarie> So we'd be overloading - and that would be bad^tm. ;)
17:00:02 * wagle ponders "haskell-category-theory"
17:01:37 <Entroacceptor> please, no more channels...
17:01:38 <deech> Hi all, how do I over-ride a libraries instance of "Show"? I get errors about duplicate instance declarations.
17:02:03 <Saizan> deech: you can't
17:02:17 <Saizan> you can use a newtype though, or simply a separate function
17:02:38 <wagle> Entroacceptor: hence my pondering it instead of creating it
17:04:51 <deech> Saizan: And if I use a newtype I would have to change the sig. on any function that uses the library data type, correct?
17:05:32 <aavogt> instances are rather global
17:06:00 <Saizan> deech: it'd be a different type
17:07:27 <deech> Saizan: Yeah, it's probably just easier to create a seperate function. Thanks!
17:08:02 <sm> JuanDaugherty: yes, darcs is very good on basic version control ops and simplicity of mental model, and it's easy (I believe) to migrate to git later. I think folks should not fear to at least try it
17:08:13 <sm> oops gotta go
17:14:28 <shlevy> Hmm
17:14:43 <shlevy> I have "{-# OPTIONS_GHC -Wall -Werror #-}" at the top of my source file, right under #!/usr/bin/runghc
17:15:03 <shlevy> Yet running the file by itself doesnn't prodouce errors that runghc -Wall -Werror filename does
17:16:26 <shlevy> Hmm. If I have no module declaration could that be the problem?
17:16:29 <shlevy> Checking...
17:17:02 <aavogt> that probably doesn't matter
17:17:04 <shlevy> Nope
17:17:15 <aavogt> you can also put      #!/usr/bin/runghc -Wall -Werror
17:18:05 <shlevy> aavogt: I tried that, didn't work. Got the following error: "ghc: unrecognised flags: -Wall -Werror
17:18:08 <shlevy> "
17:18:42 <Eduard_Munteanu> That's weird.
17:19:54 <shlevy> Eduard_Munteanu: Agreed, especially since runghc is very happy with those commands on the command line
17:20:15 * hackagebot TrieMap 4.0.0 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-4.0.0 (LouisWasserman)
17:21:07 <rwbarton> shlevy: your os is actually running /usr/bin/runghc '-Wall -Werror'
17:22:46 <shlevy> rwbarton: Figured it might be something like that. Any reason why the pragma doesn't work?
17:23:43 <rwbarton> shlevy: what happens if you don't have the #! line but you do have the options pragma
17:23:53 <rwbarton> and you run your program with runghc with no other options
17:24:09 <shlevy> rwbarton: Checking...
17:24:23 <aavogt> some older ghcs didn't look very far for pragmas
17:24:33 <rwbarton> yeah, that could also be the problem
17:25:04 <rwbarton> there are also options that don't work in OPTIONS pragmas but I doubt that -Wall and -Werror are among them
17:25:13 <shlevy> rwbarton: Still no dice
17:25:17 <rwbarton> Ah
17:25:23 <rwbarton> What happens if you only specify one of the options?
17:25:34 <shlevy> version 6.12.3
17:25:39 <rwbarton> With LANGUAGE pragmas you're supposed to separate the languages with commas
17:25:44 <rwbarton> so I don't know how OPTIONS_GHC works
17:25:46 <shlevy> rwbarton: Hmm, lets' try that
17:26:53 <shlevy> rwbarton: Nope, still doesn't show the error with -Wall
17:27:13 <rwbarton> so you have {-# OPTIONS_GHC -Wall #-} on the first line of the file?
17:27:22 <shlevy> rwbarton: Yep
17:27:28 <rwbarton> what happens if you build with ghc --make?
17:27:58 <shlevy> And when I changed it to Wall without the -, it says "runTests.hs:1:15: unknown flag in  {-# OPTIONS #-} pragma: Wall", which is strange because it's a OPTIONS_GHC pragma
17:28:05 <shlevy> rwbarton: Checking
17:28:22 <rwbarton> ghc probably uses the same code for OPTIONS_GHC as OPTIONS
17:28:49 <rwbarton> (That suggests to me that -Wall doesn't work in OPTIONS_GHC)
17:29:06 <shlevy> using ghc --make doesn't result in the warning being shown either
17:29:25 <aavogt> it does here
17:29:48 <aavogt> you might not have warnings come up if ghc figures it doesn't need to do any compilation because the file is up to date
17:30:06 <shlevy> aavogt: There were no executables in my path when I ran it
17:30:21 <shlevy> Just .hs files
17:30:49 <Saizan> .hi ?
17:31:04 <shlevy> Saizan: None before ghc --make.
18:02:54 <masonkramer_> hi guys.  small newb question.  I'm following along in the YAHT introduction to Haskell.  http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
18:03:36 <masonkramer_> in the guide the author lists Prelude> :t fst having the output: forall a b . (a,b) -> a
18:03:57 <masonkramer_> when I do it, I get something different, namely, fst :: (a, b) -> a
18:04:04 <shachaf> masonkramer_: The author is using some extensions.
18:04:14 <shachaf> masonkramer_: For forall is implied.
18:04:48 <shachaf> s/For/The/
18:05:08 <masonkramer_> Alright, that's less suprising than the other option, which was that the forall was not implied
18:05:36 <aavogt> or back then ghci didn't print haskell 98 types by default
18:05:45 <shachaf> masonkramer_: If I remember correctly, YAHT starts out pretty confusingly (and worse: using IO). You might want to read another introduction.
18:06:12 <shachaf> aavogt: Yes, also possible.
18:06:24 <JuanDaugherty> sm: OK I will take your word for it (but continue to use svn and for a DVCS git except where darcs is received)
18:07:02 <masonkramer_> I'm not too far along, but I'm sort of grokking it.  He does hit monads by chapter 3, and no, he hasn't left me with a conceptual understanding of a monad by chapter 4
18:07:11 <masonkramer_> Do you have a recommendation?
18:07:42 <masonkramer_> I think I hit on this one because it provided some exercises
18:07:55 <masonkramer_> which I've found to be very important 
18:30:13 <applicative> @type fst
18:30:14 <lambdabot> forall a b. (a, b) -> a
18:30:42 <applicative> Hugs still gives the unpretentious fst :: (a,b) -> a
18:31:32 <applicative> @type fmap
18:31:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:32:09 <applicative> Hm, Hugs and ghci agree on the polite fmap :: Functor f => (a -> b) -> f a -> f 
18:32:42 <applicative> masonkramer_ these are just more long-winded, they mean the same
18:33:27 <aavogt> they mean something different with -XScopedTypeVariables
18:33:44 <applicative> ah, is that where lambdabot is getting the superior info
18:34:39 <applicative> no, I thought if i turned it on, ghci would be more loquacious.
18:43:10 <hpaste> wagle pasted "expand maybe"  http://hpaste.org/44383
18:44:02 * wagle wonders how to get that to work
18:47:56 <aavogt> to write the instance?
18:48:04 <Cale> wagle: why the t' in the type signature for expand?
18:48:20 <applicative> you need to restrict the class class (Enum t, Bounded t) => Expandable t and whats up with t' as Cale says
18:48:41 <wagle> want to unify t with (Maybe t')
18:49:11 <Cale> um, but nothing about your type signature actually suggests that should be the case.
18:49:26 <wagle> its t' that is Enum and Bounded
18:49:51 <wagle> Maybe t' is Expandable if t' is Enum and Bounded
18:50:18 <wagle> i gave the last attempt that didnt compile
18:50:47 <copumpkin> Cale: there's a ##categorytheory if you missed it
18:51:01 <Cale> copumpkin: cool
18:51:16 <wagle> how do you add ##categorytheory plug to the title?
18:52:09 <applicative> why not just say t is expandable if there's expand :: Maybe t -> t ?  
18:52:21 <Cale> Or Maybe t -> [t]
18:52:34 <Cale> So it would be  instance Expandable Bool
18:52:47 <Cale> and  class Expandable t where expand :: Maybe t -> [t]
18:53:57 <applicative> it works fine http://hpaste.org/paste/44383/expand_maybe_annotation#p44384  I think wagle has a mysterious ulterior motive 
18:55:14 <wagle> yeah, thats a simple example of a much more complicated thing I'm trying to do
18:56:59 <applicative> it seemed so, since " explode Nothing = [minBound .. maxBound]; explode (Just x) = [x] " with no typeclass works well enough. or so it seems
18:59:38 * applicative just noticed his irc watcher turned the arrows around: " <- codolio has disconnected ..."  then "-> dolio has joined..."
19:00:45 <masonkramer_> I have a [Integer -> Integer].  I want to apply some values to it.  I expected map 3 (map (+) [1,2,3]) to do the trick, but it isn't.  
19:01:09 <applicative> >  map 3 (map (+) [1,2,3]) 
19:01:10 <lambdabot>   [3,3,3]
19:01:34 <rwbarton> lambdabot: an excellent educational tool
19:01:46 <parcs> > map ($ 3) [(+1), (+2), (+3)]
19:01:47 <lambdabot>   [4,5,6]
19:01:49 <applicative> sorry, couldn't resist
19:02:11 <rwbarton> applicative: not your fault, unless you added the instance :)
19:02:23 <wagle> its more complicated than my example..  coming up with a better example
19:02:54 <applicative> masonkramer_, you want to map the function "applied to the number three" over those functions, following parcs
19:03:33 <masonkramer_> http://hpaste.org/44385/lambabot_and_ghci_dont_match
19:03:52 <copumpkin> masonkramer_: get used to it :)
19:04:11 <Cale> masonkramer_: Right, there are some extra instances in lambdabot, but the lambdabot code won't do what you're expecting anyway
19:04:20 <applicative> masonkramer_ i apologize for trigger lambabots amusing features in this context
19:04:26 <applicative> triggering
19:04:33 <Cale> (you want map ($ 3) like parcs shows)
19:04:38 <masonkramer_> thanks guys
19:04:59 <masonkramer_> I suppose I'll get to $
19:05:06 <monochrom> lambdabot has a lot of dubious extensions.
19:05:09 <parcs> get to it right now
19:05:12 <parcs> @type ($)
19:05:13 <lambdabot> forall a b. (a -> b) -> a -> b
19:05:22 <Cale> The reason it typechecks in lambdabot is that lambdabot has an instance of Num for functions, which makes it possible to use 3 as the constant function which always gives 3 as its result
19:05:46 <parcs> @type ($ 3)
19:05:47 <lambdabot> forall a b. (Num a) => (a -> b) -> b
19:05:53 <Cale> (and map needs a function as its parameter, so that's the only way to make (map 3) make sense)
19:05:55 <monochrom> > 3 "x"
19:05:56 <lambdabot>   3
19:07:02 <c_wraith> ...  without lambdabots crazy function instances
19:08:03 * djahandarie still supports a 'vanilla >' command in addition to the existing > command
19:08:06 <applicative> masonkramer_ you could also write something like map (\f -> f 3) (map (+) [1,2,3])
19:08:08 <applicative> > map (\f -> f 3) (map (+) [1,2,3])
19:08:09 <lambdabot>   [4,5,6]
19:08:19 <djahandarie> But I don't want to alter lambdabot :(
19:08:29 <ddarius> djahandarie: That would be a relatively simple change.
19:08:31 <wagle> no, it works now, i ported the example back to the real program wrong..  fixed that, and it works
19:08:41 <wagle> It Just Works (TM)
19:09:31 <wagle> applicative: Cale: thanks for help
19:09:56 <DevHC> does lambdabot gather statistics like "number of expression lines parsed per day"?
19:10:10 <ddarius> No.
19:10:14 <DevHC> fix!
19:10:32 <masonkramer_> applicative: Ok, in retrospect, that makes more sense, given map's type
19:10:32 <ddarius> dons was keeping statistics of other sorts for a while, but I don't think any of that stuff is maintained any more.
19:10:41 <masonkramer_> thanks
19:10:59 <aavogt> you can download the logs and run that program (ircstats or something) yourself
19:11:05 <DevHC> :P
19:13:27 <hpaste> mason pasted "lambabot and ghci don't match"  http://hpaste.org/44385
19:13:36 <masonkramer_> that's old news 
19:14:43 <djahandarie> masonkramer_, it runs on a poll so sometimes it isn't that fast
19:14:58 <djahandarie> chrisdone is planning on making a push version at some point I think
19:18:57 <masonkramer_> I'm astounded at how much programming is being done with type signatures and (what I know as) multi method dispatch
19:19:11 <masonkramer_> neat stuff...really neat
19:19:22 <wagle> @hoogle uniq
19:19:22 <lambdabot> Language.Haskell.TH.Syntax type Uniq = Int
19:19:22 <lambdabot> module Data.Unique
19:19:22 <lambdabot> Data.Unique data Unique
19:19:36 <wagle> @hoogle unique
19:19:36 <lambdabot> module Data.Unique
19:19:36 <lambdabot> Data.Unique data Unique
19:19:36 <lambdabot> Data.Unique hashUnique :: Unique -> Int
19:19:56 <masonkramer_> goodnight
19:20:34 <wagle> want a list operation that takes a sorted list and removes dups..  is this a library function that already exists?
19:20:49 <parcs> @type nub
19:20:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:21:00 <wagle> thanks
19:21:49 <wagle> @hoogle nub
19:21:50 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
19:21:50 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
19:57:45 * acfoltzer waves
19:58:00 <acfoltzer> haven't come in here before now, but have a typechecking problem I'm hoping someone might be interested in
19:58:55 <siracusa> acfoltzer: What's the problem?
19:59:20 <acfoltzer> siracusa: a few weeks ago, had a homework assignment to derive a combinator, let's call it k'
19:59:27 <acfoltzer> such that k' v = k'
19:59:53 <acfoltzer> we didn't have to typecheck it or anything, just come up with a definition in the lambda calculus
20:00:22 <acfoltzer> but I got curious about how to get it to work with all the tricks I've seen to make the Y combinator typecheck
20:00:34 <acfoltzer> and just can't seem to get it to go through
20:01:45 <acfoltzer> so, I figured I'd drop by here to share the puzzle :)
20:10:20 <monochrom> @type let k' v = k in k'
20:10:20 <lambdabot> forall t. t -> Expr
20:10:30 <monochrom> @type let k' v = k' in k'
20:10:31 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
20:10:31 <lambdabot>     Probable cause: `k'' is applied to too few arguments
20:10:31 <lambdabot>     In the expression: k'
20:11:02 <monochrom> alright, you need a newtype to break the cycle
20:11:06 <acfoltzer> mhmm
20:11:16 <applicative> the compiler is so inferior, cant infer an infinite type
20:11:18 <acfoltzer> I'm just getting stuck about where to use it
20:11:49 <monochrom> actually the compiler can infer an infinite type and just suppresses it
20:11:50 <acfoltzer> since it seems like the type of v is in the middle of the usual t1 -> t = t1 relation
20:13:31 <Eduard_Munteanu> Something like a hungry function I suppose.
20:13:41 <Eduard_Munteanu> Right?
20:13:52 <acfoltzer> indeed
20:13:56 <acfoltzer> insatiable, even
20:14:28 <applicative> it nourishes itself on everything, maintains itself thus
20:14:38 <Eduard_Munteanu> (I mean the rigorous meaning of "hungry" functions)
20:15:13 <acfoltzer> hmm, haven't heard of that
20:17:24 <monochrom> first cut: newtype Hungry a = Ctor{dtor:: a -> Hungry a}; eat :: Hungry a; eat = Ctor(\_ -> eat).  To use, example: (dtor eat 0) gives you (eat) again.
20:20:46 <acfoltzer> monochrom: nice!
20:22:06 <acfoltzer> first stab at making it polymorphic is to change the type around a bit: data Hungry a = forall b. Ctor {dtor :: a -> Hungry b}
20:22:26 <acfoltzer> but ghc doesn't agree with this
20:22:45 <acfoltzer> at least when invoking it like (dtor eat 0)
20:23:05 <acfoltzer> oh, and I do existentials enabled
20:23:09 <rwbarton> you want Ctor (dtor :: forall b. a -> Hungry b}
20:24:02 <acfoltzer> and there it is!
20:24:30 <acfoltzer> yikes, two weeks of on-and-off hacking and you all get it in less than 30 minutes
20:24:37 <monochrom> second cut: turn on RankNTypes, then newtype Hungry = Ctor{dtor:: forall a. a->Hungry}; eat :: Hungry; eat = Ctor(\_->eat).  This is more flexible.  Previously, (dtor (dtor eat 'x') True) did not work because it required a=Char and a=True at the same time.  Now you can do it.
20:25:17 <acfoltzer> ah, that looks like the point-free equivalent of rwbarton's idea
20:25:32 <rwbarton> yeah, that works too and is simpler
20:25:45 <monochrom> no, instead it eliminates the useless b.
20:26:33 <siracusa> What is the default precedence and fixity of operators?
20:28:01 <monochrom> default is infixl 9
20:29:10 <mzero> which is .... tightest?
20:29:17 <mzero> I can never remember which way it goes
20:29:19 <monochrom> yes
20:29:27 <mzero> anyone got a good mnemonic?
20:29:34 <monochrom> I ask ghci for ":info * +" to remind me
20:29:41 <mzero> I do too!
20:29:45 <acfoltzer> okay, thank you both. I'll have to play around with it some more
20:29:48 <mzero> though didn't know you could ask for two at once
20:30:00 <acfoltzer> just to make sure I can reproduce that sort of type for other programs
20:30:34 <acfoltzer> it's nice to see another example besides Y of how to corral the infinite type
20:37:44 <acfoltzer> thanks again, and goodnight!
20:38:00 <acfoltzer> shutting down before this midwest storm knocks out the power
20:40:29 <accel> any haskellers in the stanford / palo alto area?
20:42:48 <BMeph> accel: Yes. Granted, I'm not one, but I figured you could use even an unhelpful answer. ;)
20:43:07 <accel> ah; so basically yes, the set is non-empty
20:43:12 <accel> but no, I have no idea who belongs ot the set?
20:43:15 <accel> are you a mathematician?
20:56:27 <mzero> accel - yes
20:56:34 <mzero> I'm in Mtn. View
20:56:48 <mzero> and just two weekends ago there were >70!
21:21:30 <dobblego> why is Writer not Traversable?
21:22:20 <dobblego> (Writer w) that is
21:26:48 <accel> is haskell's relationship to objective-c closer to C or C++? i.e.is there a haskell objective-c ffi, or do I need to wrap objective-c in C in order for haskell to access it
21:27:27 <blackdog> accel: there's HOC, which wraps haskell for obj-c, but last time i tried it was a huge pain to install
21:27:36 <blackdog> the C FFI is much more heavily used
21:27:56 <accel> so basiaclly if i want to interafce objective-c code
21:27:59 <accel> i should wratp it up in C
21:31:26 <blackdog> accel: it's probably easier, yes. 
21:31:58 <blackdog> http://code.google.com/p/hoc/ if you're interested in wolfgang's stuff, though.
21:33:13 <accel> got it; thanks
21:36:53 <mzero> accel - I don't know if Apple publishes the objective-C ABI -- that is I think they expect non-objective-C code to call exported C interfaces
21:37:37 <applicative> accel, i take it you've seen things like http://tscheff.blogspot.com/2010/02/currync-converter-using-haskell-with.html https://github.com/nfjinjing/haskell-cocoa-currency-converter-example
21:53:22 <accel> applicative: no, first time
22:08:17 <accel> is tehre a haskell module to play raw pcm data on mac os x?
22:16:37 <wagle> which of the prolly billyuns of xml packages should I use for processing XML files in haskell?
22:52:46 <xplat> there are other ones than xml-enumerators and hxt?
22:53:40 <xplat> see also: http://stackoverflow.com/questions/1361307/which-haskell-xml-library-to-use
23:49:39 <jaj> hi
23:52:32 <jaj> I have my main function calling funcA :: String -> a which in turn calls funcB :: String -> b. Actually the String from main is needed in funcB but funcA doesn't need it, it just carries it around. Can I use the Reader Monad to abstract the string away from funcA?
23:53:35 <jaj> knowing that the types don't exactly match up (I would have "Reader String a" and "Reader String b")
