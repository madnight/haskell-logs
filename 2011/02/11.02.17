00:00:04 <dark> by the time we have technology to travel to an alien that is careless on its communication, they will have a lot less to offer
00:00:39 <kikik> hey! I need a bit help.it is a homework. I need to write a function that will give the places of an elements in the list, that will fulfill the predicate. sp, i guess it should count the length of the list from the first element till the first element, that fulfills the predicate
00:01:04 <jonkri> why does this result in "space leaks", and how can it be prohibited? is it related to tail recursion? sum1 (x:xs) = x + sum1 xs
00:01:23 <Jafet> We could offer them work in tech support.
00:01:28 <blackdog> jonkri: try expanding it out step by step
00:01:40 <blackdog> try sum1 (1:2:3:4:[])
00:01:48 <jonkri> blackdog: ok, thanks
00:01:51 <dark> jonkri, yes, it is not tail recursive, but it could made to, with.. foldl
00:01:58 <dark> :t foldl
00:01:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:02:17 <dark> like foldl (+) 0 list
00:02:29 <blackdog> dark: first step would probably be to use a recursive function with an accumulator 
00:02:38 <blackdog> foldl' is for advanced credit:)
00:02:50 <Jafet> dark: that's the definition for Prelude.sum, and it has a space leak
00:03:09 <dark> oh, it is not strict
00:03:15 <dark> @src sum
00:03:15 <lambdabot> sum = foldl (+) 0
00:04:01 <Jafet> kikik: what kind of help do you need?
00:04:34 <dark> kikik, like places even [1, 4, 0] would return [2, 3]?
00:04:51 <dark> or rather [1, 2], counting from 0
00:05:23 <kikik> dark: like (==2) [1,2,3,4,2] will return [2,5]
00:05:54 <dark> ok, it is the same as i said. and counting from 1
00:06:06 <dark> (like the first element is 1th, not 0th)
00:06:14 <kikik> dark: so actually, that is the length of the elemenets in the list, that fulfil the predicate, isnt it?
00:06:15 <dark> 1st
00:06:37 <kikik> dark: yeah. let it be so
00:07:29 <dark> kikik, uhm. õ.o. I would define something like foldi that is like foldl but gives an additional argument to the loop function, the position of the element in the list
00:07:42 <luite> kikik: do you have to use specific functions to accomplish this? which functions have just been introduced?
00:07:44 <dark> supposing it isn't already defined in haskell.. o.o
00:08:34 <kikik> luite: simple functions like take, drop..,  and foldr, foldl, map
00:08:36 <dark> this foldi would be of type (Int -> a -> b -> a) -> a -> [b] -> a
00:08:51 <luite> kikik: you might find this useful:
00:09:12 <luite> > zip [1..] "abcabcabc"
00:09:13 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'a'),(5,'b'),(6,'c'),(7,'a'),(8,'b'),(9,'c')]
00:09:32 <luite> kikik: this pairs each element with its position, should make your job easier, right? :)
00:09:36 <dark> hm õ.o
00:10:00 <dark> yeah, with that, nobody would need my foldi
00:10:02 <luite> I think you can take it frome here on
00:10:27 <dark> but i still think those haskell magical recipes are too abstract to my brain
00:10:30 <kikik> dark: hah, sorry%)) zip seems to be easier%)
00:11:11 <kikik> dark: hah. yeah. to mine as well, though I am not good at it%)
00:12:00 <gaze__> http://hpaste.org/44054/better_way_to_write_this there are a ton of primes here... I feel like I'm doing this totally wrong
00:12:02 <dark> but the code would be: foldi (\i acc el -> if predicate el then i : acc else acc) [] list
00:12:12 <gaze__> what would be a better way to write this... given the structure of it?
00:12:47 <dark> and i find this code easy to understand (but maybe because i am used to write custom folds, for eg. binary trees, or for some specific ordering..)
00:14:32 <dark> gaze__, i think where clauses are supposed to be shorter
00:14:46 <dark> also why nested where?
00:15:25 <gaze__> well, I'm not sure how to do it otherwise
00:19:41 <kikik> luite: and after that I just to filter the second arguments and in case of true it should return me the first arfuments of the tupels
00:20:22 <gaze__> I don't want to call fbas2 with the [] [] arguments, but I want all that other crap to update every iteration
00:20:26 <luite> kikik: yeah, there are multiple ways to do that. you can use a fold to do it all at once, but a separate filter and map are probably more readable
00:20:34 <gaze__> so not too sure what the syntax would be, haha
00:21:21 <kosmikus> Jafet: LambdaHack doesn't need gtk. It's just one of several possible frontends.
00:21:26 <gwern> I love consequentialist ethical reasoning. it lets me claim that folding@home is killing 12000 africans every year
00:22:56 <luite> gwern: are those the good kind of poor helpless hungry africans with big eyes, or the once carrying ak47's and actively engaging in civil wars?
00:23:05 <luite> ones
00:24:30 <dark> gwern, and what are your suppositions? that those resources, if not used at folding@home, could be donated?
00:24:39 <gwern> dark: basically
00:24:43 <gwern> electricity ain't free
00:25:13 <gwern> for the longer less fun argument, see http://www.gwern.net/Notes.html#charitable-supercomputing
00:26:14 <dark> this is similar for saying that the heat generated by all our machines are killing those people (since that if we had 100% efficient machines, we would consume less electricity, and thus we could donate)
00:26:34 <dark> similar in the sense that there are no 100% efficient machine
00:27:24 <gwern> dark: not really, since we are in full possession of the 'don't run Folding@home and run up your electricity bill' technology
00:28:30 <DrTeggy> Good morning all.
00:28:31 <kiki_> luite:so, here it will filter the elements ind p (x:xs) =( map (filter p.snd)  (zip [1..] (x:xs))) 
00:28:41 <gwern> it's an advanced technique, but I believe a nontrivial number of folding@home volunteers are also capable of transmitting wealth to effective charities through lost technologies like 'credit cards', although given the rarity of this, I may be over-optimistic
00:29:40 <dark> gwern, not running folding@home wouldn't mean the machine would be turned off (sometimes it would, but lots of those are geeks that would let the machine always on anyway). but if the saving is considerable, saving electricity would mean a better environmental record, but would hardly mean any kind of aid for anyone
00:30:23 <gwern> dark: if we're going to assume total assholes who won't give to charity, why are they running folding@home at all?
00:30:42 <gwern> notice I make the assumption that charity is about helping people, not about making yourself feel better
00:30:48 <luite> kiki_: you don't need filter within your map
00:30:50 <dark> because they find it cool
00:31:12 <Jafet> kosmikus: oh, ok
00:31:20 <gwern> 'oh, I run folding@home, I'm a good person, never mind that it's useless and expensive and I could save a life with my electricity savings over a year or two'
00:31:26 <gwern> or whatever
00:31:33 <luite> kiki_: since you want to filter first, and then map the complete filtered list
00:31:39 <dark> gwern, also, you are supposing that all this electricity saved can be donated fully to some third party. apart from donation fees and such, i think that when people rationalize that they are giving again an amount, they give less
00:31:39 <Jafet> kosmikus: I'm just downloading it to see your FOV in action
00:32:05 <gwern> dark: huh? 'giving again an amount'?
00:32:05 <kosmikus> Jafet: I'm usually using the vty frontend myself.
00:32:10 <dark> electricity bills are fuzzier, so people can't calculate and see exactly how much they are spending on a certain software
00:32:15 <dark> giving away*
00:32:18 <kosmikus> Jafet: I think Mikolaj prefers the gtk one.
00:32:34 <dark> sorry, poor english commandment, plus sleepy
00:32:41 <kiki_> luite:ok... the this ind p (x:xs) =( map (p.snd)  (zip [1..] (x:xs))
00:33:25 <luite> kiki_: try to work out the separate functions in ghci first. you don't need (x:xs) by the way, just use xs
00:33:37 <gwern> dark: it is not hard to get a rough idea of how much your ps3 running day and night for floating@home would cost
00:33:38 <luite> kiki_: everything will work fine on the empty list
00:33:56 <Jafet> kosmikus: it seems that the hackage builds with gtk by default, then
00:34:14 <gwern> dark: but again, it would require people genuinely caare about results and not making themselves feel like moral folks
00:35:06 <kosmikus> Jafet: yes, I think gtk is the default, because Mikolaj configured it as default. We have to pick one default :)
00:35:35 <dark> gwern, the interesting fact is that when SETI@home was launched, idle processors wouldn't spend less electricity than busy ones. for saving power, an idle computer would shut down the monitor, disks etc but the power consumption of the computer per se wouldn't decrease. so, if you _had_ to be with the computer turned on, that computational output would be wasted
00:36:49 <Jafet> If we don't waste more power, how can we ever reach 1.0K?
00:37:17 <dark> 1K?
00:37:36 <Jafet> kosmikus: er, how should I make it use vty, then?
00:38:10 <dark> gwern, also, you _can_ contribute meaningfully to those projects without having your computer on all day. like, running as background process, and when you are afk but can't turn off the computer
00:39:39 <dark> since processing power is increasing quickly, today's computers running occasionally something on background will finish quickly than a decade or two before, running full time
00:40:33 <luite> wouldn't it be better to wait just another decade then? :p
00:41:10 <Jafet> kosmikus: disregard, found it
00:41:43 <dark> but, but, those guys want to calculate this thing right now :P in another decade maybe current interesting problems will be already solved
00:44:16 <koala_man> hah, I didn't believe that about seti@home, but indeed. even though the hlt instruction was apparently part of 8086, it wasn't used in win9x due to incompatibility with a lot of hardware at the time
00:45:22 <kikiki> luite: sorry, my connection is low
00:46:05 <dark> earlier linux kernel also did a busy loop instead of halting iirc
00:46:27 <dark> kikiki, want to see my solution?
00:46:38 <luite> dark: don't spoil the fun ;p
00:46:57 <kikiki> dark: hah, no, a bot later, sorry%)
00:47:10 <dark> ok. in the end i used zip [1..] to turn foldl into my foldi
00:47:10 <koala_man> probably for the same reasons
00:47:48 <dark> so i might be comfortable with this zip @.@
00:48:23 <dark> there are a lot of functions that i find a bit foreign
00:48:26 <dark> @src zipWith
00:48:27 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:48:27 <lambdabot> zipWith _ _      _      = []
00:48:31 <dark> @src zip
00:48:32 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
00:48:32 <lambdabot> zip _      _      = []
00:48:33 <luite> kikiki: I think you have the right idea, that you should first filter and then map. you only need to combine them in the correct way with the zip
00:50:21 <dark> and there is also unzip o.o
00:51:37 <kikiki> luite:  m.. ind p (xs) =   (map (p.snd)  (zip [1..] (xs)))  so my problem here is that I wrongly combined tha fucktions?
00:51:46 <DrTeggy> fucktions?
00:51:51 <DrTeggy> Good grief.
00:51:59 <DrTeggy> Show some respect.  ;-)
00:52:10 <dark> lol
00:53:00 <luite> kikiki: yeah, you don't have a filter there
00:54:44 <luite> kikiki: try to to the filter part first, and leave out the map for now
00:55:37 <luite> so your function will produce a [(Int, a)], each element satisfying the predicate paired with its index
00:57:37 <kikiki> luite:  but how can I use filter on an each second element of a tupel in a list without maping??
00:58:10 <luite> kikiki: look at the type of filter
00:58:14 <luite> @type filter
00:58:15 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:58:28 <luite> so your predicate is for a single element
00:58:33 <luite> > filter even [1..10]
00:58:34 <lambdabot>   [2,4,6,8,10]
00:58:38 <luite> no need for an extra map
01:03:09 <xarch> how can I use an old version of a package for only one file?
01:03:30 <kikiki> ind p (xs) |   p (snd (zip [1..] xs))    ok. that is the first step. filtering
01:04:17 <luite> kikiki: I don't think you're going in the right direction
01:04:43 <luite> kikiki: you can't use snd with the result of  zip [1..] xs
01:06:39 <luite> kikiki: just assume that you have a list of type [(Int, a)] and a predicate  a -> Bool, your result should be a list of type [(Int, a)]
01:07:14 <luite> kikiki: so your function would be f :: (a -> Bool) -> [(Int, a)] -> [(Int, a)]
01:07:56 <luite> kikiki: that is the "filter" part, you still have to use map for [(Int, a)] -> [Int], but you can worry about that later
01:09:18 <kikiki>  f p (x:xs) | p (snd x) = x: f p xs    otherwise = f p xs
01:09:56 <luite> kikiki: you can use filter instead of guards
01:10:43 <dark> @src filter
01:10:43 <lambdabot> filter _ []     = []
01:10:43 <lambdabot> filter p (x:xs)
01:10:43 <lambdabot>     | p x       = x : filter p xs
01:10:43 <lambdabot>     | otherwise = filter p xs
01:11:06 <dark> the filter has the guard so that similar functions won't need it
01:11:26 <ddarius> :t filter . (. snd)
01:11:27 <lambdabot> forall a a1. (a -> Bool) -> [(a1, a)] -> [(a1, a)]
01:11:34 <luite> kikiki: you almost had the correct answer in one of your earlier attempts, you just used it with map instead of filter
01:12:39 <dark> ddarius, haskell is a such adequate language for code golf
01:15:24 <kikiki> luite: ind p (xs) =   (filter (p.snd)  (zip [1..] (xs)))  so this one?
01:15:56 <luite> kikiki: just test it, does it give the correct result? :)
01:16:05 <mux> you could just use zip [1..] (filter p xs)
01:16:18 <mux> no need to zip first if you're not using the index in the predicate
01:16:19 <luite> mux: no that would give a different answer
01:16:40 <mux> oh, right, you'd get different indices
01:16:55 <luite> yeah the point was to get the indices that satisfy the predicate
01:17:47 <gaze__> are there any functions that are just straight up (a -> b -> c) -> (b-> a -> c)
01:17:53 <gaze__> flip the first 2 arguments of a function
01:18:06 <luite> @type flip
01:18:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:18:07 <Jafet> :t flip
01:18:08 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:18:16 <luite> oh great
01:18:20 <Jafet> :t P.flip
01:18:21 <lambdabot> Couldn't find qualified module.
01:18:22 <luite> thans Cale ;P
01:18:26 <Jafet> :t Prelude.flip
01:18:27 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:18:27 <luite> @type Prelude.flip
01:18:28 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:18:38 <luite> hehe stereo
01:18:41 <kikiki> luite: well.. yeah. huh. thank you very much. it was really easy
01:18:52 <Jafet> A bit off-sync there
01:18:54 <gaze__> thanks :D
01:19:25 <luite> kikiki: yeah it is once you see it :) what is your complete result now? let's see if we can clean it up some more
01:19:40 <kikiki> luite: thanks for the patience
01:19:56 <kikiki> luite: ind p (xs) =   map fst    (filter (p.snd)  (zip [1..] (xs))) 
01:20:33 <luite> kikiki: ok, cleaned up a little: ind p xs = map fst . filter (p.snd) . zip [1..] $ xs
01:20:41 <luite> kikiki: you don't need so many parenteses
01:20:51 <luite> parentheses
01:21:25 <luite> kikiki: and if you want, you can make it a little more points free: ind p = map fst . filter (p.snd) . zip [1..]
01:21:36 <luite> but those are all essentially the same
01:22:02 <kikiki> luite: yep. I see it. it is really cool=)
01:23:20 <gaze__> did anyone end up having a look at that code I wanted to make look a little less stupid?
01:25:14 <gaze__> not sure what to do about this nested where clause, haha
01:26:30 <kikiki> luite: and one small thing. the arithemtics middle of the Ints of the list is a median or a really like [a,b] = div a+b 2
01:27:32 <luite> kikiki: you can do it really easily, namely   (sum of the list) `div` (length of the list)
01:27:42 <dark> i saw, what i would is: the inner where can be deleted i think, and the things inside it can be moved out (to the outer where)
01:27:44 <luite> kikiki: you already have funtions for both
01:27:59 <luite> kikiki: but this approach does have a disadvantage for very long lists
01:29:43 <kikiki> luite: no,no hah. wait. I just dont understand the meaning of the arithemtics middle , so it not the median of the list?
01:29:48 <dark> gaze__, http://hpaste.org/paste/44054/better_way_to_write_this_ann#p44056 like this
01:31:25 <dark> anyway i haven't liked this approach of defining lots of twoletter' twoletter'' (supposedly to replace twoletter?).. but i sometimes do this (in ocaml, so one has only let.. like let x' = f x in let y' = f y in ..)
01:32:15 <dark> i suppose that not having a non-recursive binding is hurting then
01:32:58 <gaze__> well, what's the alternative to the primes?
01:33:40 <luite> kikiki: it's usually just called arithmetic mean, or "average"
01:34:02 <dark> kikiki, my solution http://hpaste.org/44057/uglier was really worse than yours in the end
01:34:06 <luite> kikiki: at least I think that's what hey mean :)
01:34:18 <dark> gaze__, the af''' ? hmm.. i'm not sure..
01:35:14 <kikiki> dark: I would have sat with you here till me tomorrows exam
01:35:32 <gaze__> dark: that doesn't work... nothing is there to bind s1/s2 at the outer level
01:35:45 <dark> gaze__, ah
01:36:15 <dark> gaze__, hmmm.. why?
01:36:30 <gaze__> well, s1 and s2 are arguments to f
01:37:03 <dark> ah
01:37:05 <dark> duh
01:37:27 <dark> maybe defining f as top level is the solution?
01:37:42 <dark> but wouldn't solve the whole problem
01:37:51 <gaze__> now I'm throwing internal stuff into my namespace
01:37:57 <gaze__> like, really don't wanna do that
01:39:05 <dark> really doesn't know, maybe you should throw some chunks to @pl or other rewriting tool
01:39:21 <dark> but not sure if it would understand nested wheres
01:39:50 <dark> i mean, i really don't know
01:41:28 <gaze__> meh I'll leave it
01:41:45 <gaze__> I really like this sort of idea of building programs in tiny pieces and thinking through each function very carefully
01:41:52 <gaze__> and then hooking it all togther
01:54:57 <kikiki> luite: are you still here? I have really only one and really small question
02:02:10 <luite> kikiki: yeah, I have to go in a few minutes though
02:04:46 <kikiki> http://codepad.org/kccYmqbb so, the trees are equel when the absolute values of their nodes are equel
02:05:12 <kikiki> http://codepad.org/e8MgSkcU why  am I not allowd to write it so? because a leaf is not a tree?
02:06:38 <sipa> kikiki: works perfectly?
02:06:56 <mm_freak> in the enumerator package what's the difference between EOF and Chunks []?
02:07:07 <kikiki> sipa: yeah
02:07:36 <luite> kikiki: you don't need the last two lines in the instance of Eq
02:07:55 <luite> kikiki: since the patterns of the first two already cover all possible cases
02:08:04 <mm_freak> ah, got it already
02:08:29 <kikiki> luite:http://codepad.org/e8MgSkcU here it is general. so is it right as well?
02:09:19 <luite> kikiki: yeah looks ok to me :)
02:09:38 <kikiki> luite: ok. thanks%)
02:23:00 <dark> why isn't Control.Monad.State at http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html ? should I use Control,Monad.ST? is there some documentation / tutorial for it?
02:24:09 <dark> i'm looking at http://www.haskell.org/haskellwiki/State_Monad that looks simple and i can run that code (ghci has Control.Monad.State) but i can't find it on hackage
02:24:23 <dark> i can find http://cvs.haskell.org/Hugs/pages/libraries/mtl/Control-Monad-State.html
02:24:28 <quicksilver> dark: it's not there because it's in mtl, not in base
02:24:43 <quicksilver> dark: ST is something quite different from State.
02:25:15 <dark> ihttp://hackage.haskell.org/package/mtl-1.1.0.2 ok
02:25:19 <dark> quicksilver, hm o.o
02:25:52 <quicksilver> the haskell platform contains MTL
02:26:15 <dark> so Control.Monad.State is http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html Control.Monad.State.Lazy?
02:26:24 <quicksilver> yup
02:26:48 <dark> so the "module" at haddock actually means that one module opened the other?
02:26:53 <quicksilver> yes
02:27:04 <dark> oh that makes sense now, thanks
02:27:07 <quicksilver> in this case it's really a way of making one module an alias to the otehr
02:27:15 <quicksilver> C.M.S is an alias to C.M.S.Lazy
02:27:51 <dark> I have have import Text.Parsec and then import Text.Parsec.Prim which is redundant
02:57:12 <hape01> I have a (homogenous - I´ve learned, there are no others then homogenous) list of (union) types, each encapsulating a potentially different type. Do you have me a hint, how I could get a list of all compoments of a special type in that list?
02:57:34 <Zao> @type filter
02:57:35 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:58:14 <hape01> Zao: Yes I need a filter function, I see
02:58:34 <Zao> Or map from your union type to Maybe t.
02:58:38 <Zao> And then catMaybes to get a list of t.
02:59:02 <Peaker> @type \p xs -> do { x <- xs ; guard (p x) ; return x }
02:59:03 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> m b -> m b
02:59:36 <Peaker> @type rights
02:59:37 <lambdabot> forall a b. [Either a b] -> [b]
02:59:42 <Peaker> hape01, something like that?
03:00:05 <hape01> Peaker, Zao: That sounds good but I am not skilled yet to do now...
03:00:18 <Maxdamantus> :t \p xs -> xs >>= \x -> guard (p x) >> return x
03:00:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> m a -> m a
03:00:20 <Peaker> @type \xs -> [x | Right x <- xs]
03:00:21 <lambdabot> forall t t1. [Either t t1] -> [t1]
03:00:22 <Maxdamantus> @pl \p xs -> xs >>= \x -> guard (p x) >> return x
03:00:23 <lambdabot> (=<<) . (`ap` return) . (((>>) . guard) .)
03:00:27 <hape01> With pattern matching I guess i can write a function which returns True for...
03:00:54 <hape01> wow
03:00:56 <Peaker> hape01, you can use a list comprehension or do block with pattern matching and let the pattern match fails be pruned automatically from the result list
03:01:16 <Maxdamantus> @src filter
03:01:17 <lambdabot> filter _ []     = []
03:01:17 <lambdabot> filter p (x:xs)
03:01:17 <lambdabot>     | p x       = x : filter p xs
03:01:17 <lambdabot>     | otherwise = filter p xs
03:01:39 <hape01> thank you all, but for now thats to much for me unfortunatelly
03:02:13 <ddarius> Down with booleans.
03:03:47 <Maxdamantus> > [1..10] >>= (:[]) . (2*)
03:03:56 <lambdabot>   mueval: ExitFailure 1
03:03:56 <lambdabot>  mueval-core: Time limit exceeded
03:05:28 <ClaudiusMaximus> > partitionEithers [Left "hello", Right "world"]
03:05:31 <lambdabot>   (["hello"],["world"])
03:10:55 <Maxdamantus> > partitionEithers $ zipWith ($) (cycle [Left, Right]) [1..20]
03:10:56 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20])
03:13:08 <Ferdirand> that's cute
03:25:00 <ocharles> @hoogle cycle
03:25:00 <lambdabot> Prelude cycle :: [a] -> [a]
03:25:01 <lambdabot> Data.List cycle :: [a] -> [a]
03:25:01 <lambdabot> Data.ByteString.Lazy cycle :: ByteString -> ByteString
03:25:53 <Maxdamantus> @src cycle
03:25:53 <lambdabot> cycle [] = undefined
03:25:53 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:28:11 <ocharles> Is it possible to have a lazy list that's generated by doing IO? I'm wrapping a C function that uses an iterator, so presumably my "fetch_next_result" function needs to be in the IO monad, because it steps the iterator forward
03:29:10 <ocharles> but I can't see a way to build a list without evaluating fetch_next_result until it returns null
03:29:34 <Maxdamantus> It doesn't need to be in the IO monad.
03:30:16 <ocharles> The public API in haskell might not need to be, no, but fetch_next_result does
03:30:30 <ocharles> I would have thought, anyway
03:31:14 * Maxdamantus hasn't thought very much about it, but the laziness of readFile etc seems very complicated.
03:31:29 <ClaudiusMaximus> @src hGetContents
03:31:29 <lambdabot> Source not found. Are you on drugs?
03:32:04 <Maxdamantus> Hmm.. a <- readFile "foo"; forkIO $ print a; print a
03:32:47 <dark> <dark> i have a program where users type commands. i also keep a state. each command can print a string, and it also can inspect and change the state. initially the command function was to receive the old state, the input, and return the new state and the output <- I want to use the state monad, but I don't know how to model this
03:33:07 <quicksilver> you just use unsafeInterleaveIO on each fetch_next_result
03:33:08 <ClaudiusMaximus> "lazy list generated by doing IO" is probably not going to be robust in any real-world scenario
03:33:11 <dark> <dark> I'm satisfied in getting a string, somehow, after the command is run (I don't want it to handle with IO) but I think the output string shouldn't be part of the state (because after it is output, it is garbage)
03:33:18 <quicksilver> it's probably a bad idea, of course.
03:33:30 <ocharles> ClaudiusMaximus: it's not really doing any IO though, it's just stepping a std::iterator
03:33:56 <ocharles> but because it's mutating the iterator object (iterator++) I put it in the IO monad for now
03:34:04 <sipa> it is observably modifying a global state, no?
03:34:05 <quicksilver> the risk, I think, is that two threads hit the thunk at the same moment
03:34:13 <quicksilver> then you update the iterator twice
03:34:24 <iago> hi all, someone could point me a possible cause of this problem?
03:34:25 <iago> $ hpc report hpctixdir/darcs-9957.tix 
03:34:25 <iago> hpc: can not find Darcs.Patch.Prim.V1.Core in ["./.hpc"]
03:34:25 <iago> iago@bolboreta:~/p/darcs/screened/dev$ ls .hpc/Darcs.Patch.Prim.V1.Co
03:34:25 <iago> Darcs.Patch.Prim.V1.Coalesce.mix  Darcs.Patch.Prim.V1.Commute.mix   Darcs.Patch.Prim.V1.Core.mix      
03:34:25 <iago> iago@bolboreta:~/p/darcs/screened/dev$ ls .hpc/Darcs.Patch.Prim.V1.Core.mix 
03:34:26 <iago> .hpc/Darcs.Patch.Prim.V1.Core.mix
03:34:33 * ocharles sighs
03:34:43 <iago> ops, sorry
03:34:49 <iago> $ hpc report hpctixdir/darcs-9957.tix 
03:34:49 <iago> hpc: can not find Darcs.Patch.Prim.V1.Core in ["./.hpc"]
03:34:50 <iago> $ ls .hpc/Darcs.Patch.Prim.V1.Core.mix 
03:34:50 <iago> .hpc/Darcs.Patch.Prim.V1.Core.mix
03:35:00 <ocharles> sipa: right, it's certainly not pure
03:35:07 <ocharles> iago: dude, paste bin.
03:35:50 <iago> ocharles, I use pastebin when I go to paste more than 4 lines...
03:35:58 <ocharles> iago: no, you use a pastebin, period.
03:36:11 <ocharles> and guess what, you just pasted more than 4 lines
03:36:23 <iago> was a mistake
03:36:45 <quicksilver> yes, please use a pastebin for any amount - even 2 lines - but also, please don't attack mistakes with sarcasm ;)
03:37:31 <iago> ok sorry
03:37:58 <iago> http://paste.debian.net/107928/ <-- please, can some point me the cause of this HPC error ?
03:38:16 <iago> most I can found googling are another people asking the same without a response
03:38:27 <quicksilver> I'm afraid I've never used hpc.
03:45:36 <drbean> @hoogle partitionEithers
03:45:37 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
03:52:54 <harlekin> I'm trying to write a FFI to the C function statfs (sys/vfs.h). This is my first attempt to FFI in Haskell and I came up with http://hpaste.org/paste/44058/statfs_annotation#p44059, however, hsc2hs yields many error messages. What am I doing wrong?
03:53:02 <harlekin> (Sorry for confusing title and author in hpaste.)
03:55:17 <Cozminsky> so, advice for a newbie haskeller
03:55:42 <Cozminsky> I think I want to make a rest interface to domain name maintenance
03:55:57 <Cozminsky> with nsupdate and rndc addzone in bind9
03:56:26 <mux> harlekin: looks like you just need an include such as sys/types.h
03:56:30 <ClaudiusMaximus> harlekin: syntax is (#peek ... ) not #{peek ... )  as far as i can tell http://therning.org/magnus/archives/tag/hsc2hs
03:58:03 <harlekin> mux, ClaudiusMaximus, both suggestions don't change anything.
03:59:54 <Lemmih> harlekin: Have a look at the generated C code.
03:59:54 <mux> there are syntax errors in the file you pasted
04:00:18 <ClaudiusMaximus> harlekin: ah, s/statfs/struct statfs/ 
04:00:35 <ClaudiusMaximus> harlekin: then i get fewer errors
04:00:40 <mux> the #include is buggy too
04:02:32 <dark> at parsec, how to trail whitespace _after_ certain parser? (I have a parser that accepts everything: many1 anyChar. but it should drop any whitespace from the right. so "a  b c   " should be parsed as "a  b c"
04:02:42 <harlekin> ClaudiusMaximus, thanks. That solves it. (:
04:03:18 <ClaudiusMaximus> harlekin: http://hpaste.org/paste/44058/fewer_errors#p44060
04:03:23 <dark> i know that for lexeme parsers one will skip whitespace before any token; but in this case, whitespace is significant (except whitespace exactly before EOF)
04:03:49 <harlekin> ClaudiusMaximus, yeah. I got the names wrong with the last two errors remaining after your change.
04:04:12 <ClaudiusMaximus> harlekin: cool
04:16:15 <harlekin> Is there a way to reexport everything that imported by a specific module?
04:17:55 <Twey> Just don't provide an export list
04:18:02 <Twey> It'll export every name in the module
04:18:16 <jix_> Twey: I don't think it will reexport anything
04:18:26 <quicksilver> put the module name in your export list.
04:18:45 <quicksilver> module Foo (module Bar) where { import Bar; }
04:18:49 <quicksilver> I think I got that right.
04:19:19 <harlekin> quicksilver, thanks. That's what I wanted. (:
04:40:56 <udoprog> Asking this question again, does anyone know if it's possible to get the process id of a process spawned using CreateProcess ?
04:42:38 <zygoloid> CreateProcess sounds like a type/data constructor, not something which could spawn a process
04:43:18 <zygoloid> if you mean the Win32 API call, this is not the right place to ask
04:43:38 <Lemmih> zygoloid: I think he talks about System.Process.
04:44:56 <udoprog> yes, proc populates a CreateProcess, and I use it in conjunction with the createProcess function in System.Process
04:45:16 <udoprog> how many times did I say process ? : P
04:46:45 <zygoloid> http://hackage.haskell.org/packages/archive/process/1.0.1.4/doc/html/src/System-Process-Internals.html#ProcessHandle
04:47:01 <zygoloid> ^^ there's a withProcessHandle in System.Process.Internals if you really need to look inside the ProcessHandle
04:47:16 <zygoloid> but you're better off using the functions in System.Process if you can
04:47:57 <udoprog> yeah, but I need to issue a custom signal other than TERM : P
04:49:09 <zygoloid> ok, then withProcessHandle is the way to go: withProcessHandle hdl (\p -> case p of OpenHandle pid -> kill sig pid; _ -> return _)
04:49:12 <ManateeLazyCat> Hi all. :)
04:50:13 <udoprog> zygoloid: sweet, how can I look up documentation about internals in the future (couldn't find it on hoogle)?
04:51:46 <ocharles> Hey, any thoughts on https://github.com/ocharles/Xapian-Haskell/blob/msets/Xapian.hs#L89 ? It's my Haskell interface to some C functions.
04:51:54 <ocharles> From my understanding that will strictly evaluate the whole iterator, and is not lazy
04:52:10 <zygoloid> udoprog: it looks like it's not really documented. i suspect that's deliberate, and that they don't want people using it since it's inherently non-portable.
04:53:32 <udoprog> zygoloid: ah, but how does this differ from components which are specifically marked as e.g. 'Unix' ?
04:53:57 <zygoloid> System.Process is supposed to be portable.
04:55:22 <ocharles> Indeed, it does evaluate the entire iterator first, hrm.
04:55:45 <udoprog> zygoloid: yeah, just seems like you could have a small non-portable unix portion of the package, but thanks for the help and insight
05:00:02 <quicksilver> ocharles: if you change "fetchMSets msets >>= \rest -> return (mset:rest)" to "rest <- unsafeInterleaveIO (fetchMSets msets); return (mset:rest)"
05:00:16 <quicksilver> ocharles: then it will do the IO interleaved with the evaluation.
05:00:18 <ocharles> quicksilver: interesting
05:00:20 <quicksilver> this may well be a bad idea.
05:00:30 <ocharles> yea, the unsafe there makes me wonder :)
05:00:33 <quicksilver> and it is almost certainly not threadsafe as I remarked earlier.
05:00:35 <ocharles> i guess this is what you were saying about multiple threads?
05:00:36 <ocharles> right
05:01:10 <Jafet> You can do anything with ST and STRef that you could do with State
05:01:24 <quicksilver> to be honest, if you want people to have the control to fetch gradually, I would simple expose and iterator-like API (possible in addition to a simple list fetch)
05:01:34 <quicksilver> might like the C(++) API.
05:01:34 <Jafet> Er nevermind, I was in an IRC time warp
05:01:49 <ocharles> quicksilver: any Haskell stuff I could use for reference there?
05:03:29 <ksf> > runState (sequence . repeat $ state (\x -> (x,x+1))) 0
05:03:34 <lambdabot>   mueval-core: Time limit exceeded
05:03:44 <ksf> ...try to do that with ST
05:05:11 <pacak> Does anybody here understands package iteratee? I am trying to create flattenStream :: Monad m => Enumeratee [s] s m a (to process output of enumLinesBS with it), but i think i am going in wrong direction.
05:05:15 * dark found how to skip spaces after some parser that accepts everything, on parsec. manyTill anyChar (spaces >> eof) instead of many anyChar
05:06:26 <Jafet> > runST $ do{ r <- newSTRef 0; sequence . repeat $ modifySTRef r succ; readSTRef r; }
05:06:32 <lambdabot>   mueval: ExitFailure 1
05:06:32 <lambdabot>  mueval-core: Time limit exceeded
05:07:00 <Jafet> Close enough@
05:07:17 <parcs> what should i do about this "orphan instance": instance MonadCGI m => MonadCGI (ReaderT r m) where ...
05:07:35 <ocharles> dark: maybe many whitespace
05:07:50 <ocharles> dark: or does the spaces parser handle tabs and stuff too? I forget
05:08:50 <dark> oh it is not parsing "a b", it says unexpected b
05:09:04 <dark> i think i might put that spaces >> eof under try
05:10:23 <dark> and, i want spaces only
05:10:39 <ocharles> dark: where's your parser so far?
05:10:45 <dark> with try it worked o.o
05:10:47 <ocharles> it sounds like your (spaces >> eof) is in the wrong parser
05:11:13 <ocharles> you probably want something like : importantParser <* (spaces >> eof)
05:11:23 <ocharles> as your main parser runner
05:11:38 <dark> ocharles, it can parse chat a  b c as Command1 Chat "a  b c", hello as Command0 Hello and everything else it fails
05:11:44 <dark> hmm
05:11:45 <peoro> is it possible to explicitly tell haskell the type of a function defined in a `where' block?
05:12:04 <dark> <*? is it like manyTill? o.o
05:12:04 <Jafet> peoro: sure, give it a type signature
05:12:17 <ocharles> dark: no, <* is part of Control.Applicative
05:12:22 <ocharles> @hoogle (<*)
05:12:22 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
05:12:23 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
05:12:23 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
05:12:28 <peoro> Jafet: where? how? `where f :: T; f = ...' ?
05:12:30 <dark> @src (<*)
05:12:30 <lambdabot> (<*) = liftA2 const
05:12:34 <Jafet> peoro: sure.
05:12:38 <peoro> hum
05:12:41 <peoro> it's not working
05:12:51 <ocharles> dark: it essentially sequences the 2 parser, and discards the result of the right
05:12:53 <dark> ocharles, how <* would help to do the job that manyTill seems to do?
05:12:58 <dark> hmm
05:13:04 <ocharles> that is probably a terrible explanation, but it's where my intuition is so far :)
05:13:13 <dark> makes sense, but I need to (try $ spaces >> eof) anyway
05:13:27 <ocharles> dark: I don't know if it would, I'm just guessing because I haven't seen more of your parser
05:13:36 <ocharles> dark: you shouldn't have to try that if it's in the right place
05:13:52 <dark> oh. hmmm.
05:13:55 <dark> @.@
05:13:56 <lambdabot> Maybe you meant: . @
05:14:00 <ocharles> paste your parser. hint hint.
05:14:53 <dark> http://hpaste.org/44061/littleparser
05:15:02 <dark> after many tries i was able to make this on my own,
05:15:28 <dark> I thought about using fancy Token and stuff but I'm confused about simple monadic things, also..
05:16:18 <ocharles> you can rewrite action as: control <$> line, I believe
05:16:26 <ocharles> (with Control.Applicative)
05:16:40 <ocharles> anyway, that's just golf :)
05:17:02 <dark> uhm. o.o i got how to write monadic code by seeing an explanation of this p >>= \r1 −> q >>= \r2 −> return (r1,r2) (actually written in ocaml, so fun for \)
05:17:24 <dark> in a presentation of pcl, a parsec clone written in ocaml
05:18:09 <dark> @hoogle control
05:18:09 <lambdabot> Data.Char Control :: GeneralCategory
05:18:10 <lambdabot> Network.HTTP.Headers HdrCacheControl :: HeaderName
05:18:10 <lambdabot> Data.Char isControl :: Char -> Bool
05:18:17 <dark> @src (<$>)
05:18:18 <lambdabot> f <$> a = fmap f a
05:19:05 <dark> oh so fmap f a is a >>= return . f for monads?
05:20:18 <dark> action used to be a do, action = do { cmd <- line; return $ command cmd }
05:21:02 <ocharles> yea, what you have now is nicer, but the above is cleaner, imo
05:21:21 <ocharles> So what exactly are you trying to parse? I'm not sure about the branch stuff that sort of goes out of parsing context, and then back in to it
05:21:22 <dark> btw my golfing is at that rest, is that the better way for writing something like manyTill1 ? (that is, manyTill, but accepting at least one)
05:21:24 <ocharles> seems un-necessary
05:21:53 <dark> oh, the code before had a veery ugly do inside if inside do o.o'
05:22:06 <dark> it is.. a mud command
05:22:36 <dark> thing is, depending on the command (the first token), whitespace might or might not be relevant after certain point
05:23:13 <dark> so for chat a  b, whitespace is relevant there, and the message is "a  b". but get a  b, just gets a from b
05:23:29 <ocharles> sure, but if you have "a b          " then why do you either care about trailing whitespace?
05:23:41 <ocharles> unless of course you need "a b    c", but then consume space as you need it
05:24:02 <dark> because i thought it would be challenging to write (i tried many approaches)
05:24:10 <dark> but really no usefulness
05:24:14 <ocharles> i have an idea, let me just try this
05:24:52 <dark> some muds will get this like i wrote, some won't, and some will not have any kind of marker after the message so nobody will notice
05:25:08 <ocharles> I'm learning parsec too btw, so this is good exercise for me ;)
05:26:03 <ocharles> Why do you have the distinction of Zero and One as data types?
05:26:05 <Younder> My book on Category theory arrived today. This one's by Steve Awodey. I also have a 'looser' book by Pierce. Shame since his introduction to type theory rocks.
05:26:58 <ocharles> I think it'll be easier to have Command { name :: String, args :: [String] }
05:26:58 <ocharles> then you can pattern match on [] or (x:xs)
05:27:03 <dark> something i wanted to make is that chat alone gives a syntax error. and it works, because rest requires at least a char
05:27:11 <ocharles> I see
05:27:19 <dark> ocharles, I want command arity to be part of the type
05:27:32 <ocharles> dark: isOne and isZero take a command name and return true or false on argument count?
05:27:38 <dark> ocharles, so some commands will receive an arg, some none.. btw my whole code: http://hpaste.org/paste/44061/littleparser_annotation#p44062
05:27:52 <dark> yes, they are pure functions (defined in a very awkward way, btw)
05:28:05 <dark> actually, this is redundant
05:28:32 <ocharles> dark: ok, so: isZero "north" = True, and isOne "attack" = True (assuming you have to have a target to attack or something)
05:29:22 * hackagebot LinearSplit 0.1 - Partition the sequence of items to the subsequences in the order given  http://hackage.haskell.org/package/LinearSplit-0.1 (VitaliyRukavishnikov)
05:29:32 <Younder> Every tim a good Math book arrives it's like Christmas around here. Am I truly the only one that feels this way?
05:29:53 <Younder> Hell even chromium can't spell math ;)
05:30:01 <dark> ocharles, yes
05:30:21 <dark> ocharles, actually the code is http://hpaste.org/paste/44061/littleparser_annotation#p44063
05:30:29 <dark> i got something cut there
05:30:54 <Younder> well someone has to love math.
05:31:32 <dark> ocharles, i use the deriving for not having to write the command name twice (also there is some hSetBuffering that someone here instructed me, I don't know exactly how that stuff work)
05:32:17 <dark> most of Main was written by someone here I lost track whom, and I've been using it for lots of little parsec things (I use it that way: rlwrap ./interpreter)
05:33:25 <dark> also that trim is from wikipedia :P (i'm surprised there isn't a trim somewhere at the std lib)
05:34:03 <numbers> Have I just walked into a conversation about Mathew Flinders cat?
05:34:05 <Younder> By the get Lang's book on Algebra. Difficult so do your homework. But a winner.
05:34:19 <jonkri> if someone has a good understanding of the enumerator library i would be mighty obliged if someone could tell me how to get started with parseBytes of Text.XML.Enumerator.Parse. i know what an Iteratee, Enumerator and Enumeratee is on a type level, but i don't know how to connect it all together. i have a ByteString that i want to generate XML events from. thanks
05:35:08 <Younder> I love the way he uses category theory to make a coherent whole.
05:35:57 <Younder> Anyhow I've got material to last me for years..
05:36:22 <ocharles> dark: hrm, I have something that works quite nicely if you're willing to lose arity from the types
05:36:30 <ocharles> And has more potential for multiple argument commands
05:37:04 <dark> what?
05:37:49 <dark> (no i'm losing preserving arity. i would like also to preserve types, like, get a b, a is an object)
05:38:07 <ocharles> dark: http://hpaste.org/44064/parser_for_dark
05:38:35 <ocharles> in line, you just change the return to: return (Command name arg)
05:38:43 <dark> if i don't, i need to parse it again to check if i have the right number of parameters. (and see the arity sometimes affects the whitespace significance)
05:38:52 <ocharles> nope, this checks parameter count for you
05:38:57 <ocharles> check out the example cases
05:39:21 <dark> hm
05:41:28 <dark> hm interesting o.o
05:41:50 <dark> what about "attack a " ? this should parse as "attack a"
05:42:05 <ocharles> it does
05:42:10 <ocharles> see test2
05:42:16 <ocharles> and test4
05:42:40 <dark> neither has an accepting parser with trailing whitespace
05:43:04 <dark> 2 has whitespace between tokens and 4 has trailing whitespace but fails
05:43:26 <ocharles> eol = spaces >> eof
05:43:36 <ocharles> then replace eof with eol
05:44:02 <ocharles> (parser input = parse (line <* eol) "command prompt" input)
05:45:13 <dark> Hm @.@
05:46:23 <ocharles> so https://gist.github.com/831786 would be my solution
05:46:51 <ocharles> but I'd lose "isZero" and "isOne" and have a map of command name to argument count somewhere
05:47:15 <ocharles> and ignore that foo line :)
05:47:21 <dark> yes it works nicely.. but another thing I wanted was to make exhaustive pattern matching on the commands and arguments, to not leave error cases after successful parsing. and I can't do it if my command is a string, or if the arguments are a list (the parser does a good job to verify this, but it doesn't tag the types with information sufficient to prove it was verified)
05:47:35 <dark> (yes, rather useless for a mud)
05:47:45 <ocharles> not sure I follow there
05:48:22 <dark> suppose i return ("attack",["a"],1) , ok. now I need to perform the action
05:48:41 <dark> then I lookup the command table for "attack". what if there is no such string there?
05:49:07 <ocharles> you wouldn't get that far
05:49:15 <ocharles> your parser would crash saying it doesn't know what the attack command is
05:49:22 * ocharles shall expand his example
05:49:51 <peoro> Why isn't this OK? `f :: (Integral a) => a -> a; f x = ceiling (x/2)' -- it sais it cannot deduce RealFrac from Integer, but hum, `(x/2)' (where `x' is Integer) is not a RealFrac?
05:49:59 <dark> the parser information and the actual command table could evolve differently
05:50:23 <ocharles> dark: you will see in a moment :)
05:50:24 <zygoloid> @type (/)
05:50:28 <mux> peoro: the (/) operator applies to fractional types
05:50:29 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:50:38 <zygoloid> peoro: ^^ (/) produces the same type you give it.
05:50:38 <mux> peoro: try ceiling (fromIntegral x / 2)
05:50:48 <mux> or maybe just x `div` 2
05:50:53 <mux> if you just want integer division
05:51:10 <zygoloid> (x + 1) `div` 2
05:51:47 <mux> x `quot` 2
05:51:58 <peoro> hum...
05:52:06 <zygoloid> peoro wants to round up. so (x+1) `div` 2
05:52:24 <dark> but in fact I can do pattern matching against strings, and then pattern match against a variable (to rule out the possibility for a pattern failure)
05:52:30 <peoro> yes, ok, I know there are other ways to get the same result
05:52:44 <peoro> but cannot understand why it doesn't work... hum...
05:52:56 <zygoloid> peoro: so, it doesn't work because (x/2) :: Integer because x :: Integer. and Integer is not a RealFrac.
05:53:06 <peoro> hmmm, ok, but...
05:53:25 <zygoloid> (it's also no Fractional, which (/) requires)
05:53:26 <peoro> ok, I guess I got it
05:53:50 <mux> my brain mixes ceiling and floor
05:53:59 <peoro> I thought it was `ceiling''s fault, not (/)'s.
05:54:14 <zygoloid> mux's suggestion of fromIntegral is the thing to remember for this sort of issue.
05:54:38 <mux> in his case he'd be better off using integer division, but the fromIntegral example helps understanding the issue
05:54:46 <mux> or so I hope
05:55:07 <zygoloid> > let f x = x / 2 in f (4 :: Integer)
05:55:08 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
05:55:08 <lambdabot>    arising f...
05:55:28 <zygoloid> ^^ peoro: you'd have got an error from the (/) had the ceiling error not been spotted first :)
05:56:45 <ocharles> dark: https://gist.github.com/831804
05:58:03 <ocharles> dark: so here we have a map of allowed commands, and their parameter count. if we can't lookup a command, we throw an error
05:58:27 <ocharles> You can even go one step further, and have the command map be a map of command name to parser. So you could have a command like: "get {item} from {something}"
05:58:38 <ocharles> (and thus have specialized parsers for each command)
06:01:22 <dark> ocharles, hmm. nice @.@ map of command name to a parser is a great idea
06:03:13 <ozataman> Hey all - is there a way to make a polymorphic function with a typeclass constraint (as opposed to a function on concrete types) into a generic query with Data.Generics? 
06:04:44 <dark> ocharles, at my functional programming incursions i try to not make invalid data representable. the idea of throwing the invalid command at same time you give its arity is very nice :P but suppose I have a command with 3 parameters. its function receives a list. if it tries to do pattern matching there, it will also need to test for the case where the list has less than 3 elements
06:05:00 <dark> otherwise it risks a pattern failure
06:05:59 <dark> of course the function that provided it the list is promising the list has at least 3 elements, but a list with less than 3 elements is representable (the type system doesn't disallow it)
06:08:46 <dreixel> ozataman: no, I don't think so. Typeable is monomorphic.
06:09:16 <ozataman> dreixel: too bad. any suggestions on how this could be accomplished?
06:10:30 <dreixel> ozataman: well, use one ext per concrete type
06:10:44 <dreixel> or fundamentally rethink Typeable and its integration with syb...
06:10:49 <ozataman> dreixel: that's what I was trying to avoid. oh well. 
06:11:00 <ozataman> dreixel: haha, no thanks :)
06:11:01 <dreixel> ozataman: I'm afraid there's no easy way around that
06:11:19 <dark> ocharles, a solution would be to write a big 'dispatch' function, that receives the commands and the arguments and call them with right arity (like case (ommand, arg) of ("attack", [x]) -> attack x | "get", [x, y] -> get x y | ..), but I was trying to avoid such glue code (because I have to repeat myself so many times..)
06:11:25 <dreixel> I also dislike this kind of code: http://hackage.haskell.org/packages/archive/syb/0.3/doc/html/src/Data-Generics-Builders.html#empty
06:12:14 <ozataman> dreixel: I am trying to write a small library to take an arbitrary data type and turn it into a bson Document automatically. beginnings of a simple, custom ORM if you will..
06:12:46 <dreixel> ozataman: why did you choose syb? there are other gp libs.
06:13:08 <ozataman> dreixel: I was just a little bit more familiar with it.. any other suggestions?
06:17:52 <ocharles> dark: well one big function like that is definitely not the right way to do it
06:18:01 <ocharles> you lose all composability and all sorts of stuff there
06:18:32 <zygoloid> dreixel: can you extend your typeclass with an operation like: castMyClass :: (Typeable a, WrapMyClass b) => a -> Maybe (WrapMyClass b)
06:18:52 <dark> ocharles, like that - like my command0 and command1 functions?
06:18:53 <zygoloid> (where WrapMyClass carries a MyClass b instance and a b)
06:20:26 <zygoloid> hmm, i don't think even that helps ;(
06:20:26 <dark> i don't want to write a meaningless dispatch (that would call other functions to do the job), unless it didn't listed all cases (like, looked up the right function in a Map)
06:21:03 <ocharles> dark: The parser could return a Command object that is a function, that runs the command with the arguments curried in. You could store the function to curry in the dispatch table
06:21:51 <ocharles> Hrm, actually no, because all the functions would have different type signatures, so maybe not
06:21:56 <zygoloid> ozataman: ^^ oops, i meant that for you (but it won't work). can you wrap your typeclass instances before they land in the data structure you want to traverse?
06:22:17 <ocharles> dark: but I have to get back to work now, sorry. good luck
06:22:18 <ocharles> !
06:22:44 <ozataman> zygoloid: no problem :) but I don't think I follow what you mean
06:22:48 <dark> ocharles, ok. nice ideas you sent here, thanks =)
06:24:33 <dreixel> ozataman: depends on what you want to do. What is it?
06:25:04 <zygoloid> ozataman: if you want to attack all (say) Num instances in some data structure, you could wrap them in an additional data constructor, so you know which things to look at, and have somewhere to hang the Num instance.
06:25:11 <peoro> is it possible to overload a function su that I provide two different definitions according to the type of parameters?
06:25:26 <ozataman> dreixel: I am trying to write a small library to take an arbitrary data type and turn it into a bson Document automatically. beginnings of a simple, custom ORM if you will..
06:25:55 <zygoloid> so rather than building A 0.0 (B 1 (3%5)), you'd build A (Wrapper 0.0) (B (Wrapper 1) (Wrapper (3%5)))
06:26:19 <dreixel> ozataman: well, I guess most approaches will manage that fine. Ever heard of instant-generics? http://hackage.haskell.org/package/instant-generics
06:26:36 <ozataman> zygoloid: ah, so you mean to add the wrappers inside the datatype and then use higher rank types in my query?
06:26:41 <dreixel> ozataman: http://hackage.haskell.org/package/generic-deriving is also very similar and has more example functions
06:26:51 <dreixel> ozataman: or http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regular
06:26:56 <zygoloid> ozataman: yeah, but it sounds like that won't work for your problem :(
06:26:58 <ozataman> dreixel: I actually just saw instant generics after a search for generics on hackage. 
06:27:02 <dreixel> (all in the same style, using type families for representation)
06:27:29 <dreixel> I think they will all work ok with adhoc cases for entire subclasses
06:30:45 <ozataman> dreixel: thanks, I will take a look at these. significant time effort though to digest these things :)
06:31:26 <dreixel> ozataman: I think your function will ultimately be similar to generic show. Have a look at that in these approaches. Perhaps instant-generics is the easiest.
06:31:45 <ozataman> dreixel: thank you, I'll start with that
06:31:53 <duckinator> hi
06:32:24 <ozataman> I basically need to be able to say if you see a term that is an instance of the Val typeclass, then do this with it.
06:33:29 <dreixel> ozataman: if you run into trouble just ask. Also, I'm not always around here, http://www.haskell.org/mailman/listinfo/generics might be better
06:34:30 <rwbarton> ozataman: that isn't a totally coherent thing to do, because some library you import might decide to define a new instance of Val, which will change the meaning of your function
06:34:45 <rwbarton> that said, some generics libraries let you do things which are not totally coherent things to do
06:35:41 <ozataman> rwbarton: true, but it would also significantly remove boilerplate for end users that just want to have an easy way to serialize their custom datatypes to and from the DB
06:36:05 <ozataman> dreixel: thank you, just signed up for that list
06:36:49 <rwbarton> perhaps what you want is an incoherent, overlapping instance for any type that does nothing
06:37:00 <rwbarton> that at least forces you to confess to your sin
06:37:06 <rwbarton> and then you can use a combinator like everywhere
06:38:48 <Younder> If I said anything to offend anyone I am sorry.
06:40:57 <dreixel> rwbarton: an incoherent instance would take precendence over the interesting ones, no?
06:43:08 <numbers> What is meant by "minBound and maxBound are interesting because they have a type of (Bounded a) => a. In a sense they are polymorphic constants."
06:43:11 <Younder> A certain tibbe said I had used foul language and name calling in here. I am not sure what he means. But I conjoin in the spirit of Haskell and enjoy the free and open discussion. And I to enjoy the opens and egalitarianism.
06:43:45 <rwbarton> Maybe I didn't mean IncoherentInstances; I never use OverlappingInstances anyways
06:43:49 <Younder> If I did something to disrupt that I am truly sorry.
06:44:23 <dreixel> rwbarton: I almost never not use it :P
06:44:54 <rwbarton> ... That's crazy :P
06:50:59 <Younder> Haskell is a warm and friendly group. Let's keep it that way.
06:51:16 <peoro> I need to apply a function to a list of elements, starting from the first one, until a given condition is reached -- `foldl' would be perfect, except my list is infinite -- what should I use then?
06:52:17 <copumpkin> Younder: :D
06:52:49 <Younder> Why doesn't foldl work for a infinite list. You just need some upper boundary.
06:52:50 <harlekin> peoro, maybe use scanl?
06:53:22 <harlekin> > scanl (+) 0 [1..]
06:53:23 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
06:53:32 <peoro> hum...
06:53:48 <copumpkin> Younder: the bound can be expressed with a take
06:53:51 <seliopou> speaking of lambdabot evaluating expression, anybody know how to get that working with the lambdabot hackage package?
06:53:58 <seliopou> mueval seems to be crapping out on me
06:53:59 <peoro> harlekin: as far as I know scanl is just like fold except it returns intermediary results - but I don't need them
06:54:10 <rwbarton> dreixel: but yes, I think you are right about incoherentinstances
06:54:31 <harlekin> peoro, so when working on an infinite list, you can make it finite and use foldl or you could use scanl and just pick that element which is the last you're interested in.
06:54:51 <peoro> wait, I need to sum up the first N numbers from a list until the sum becomes greater than N -- was thinking that foldl would do the trick, but hum, I'm not sure anymore
06:54:52 <harlekin> Or the only element.
06:55:34 <harlekin> > last $ takeWhile (<27) $ scanl (+) [5,20,1,1,3]
06:55:35 <lambdabot>   Couldn't match expected type `[a]'
06:55:35 <lambdabot>         against inferred type `[[t]] -> ...
06:55:44 * hackagebot enumerator 0.4.7 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.7 (JohnMillikin)
06:56:27 <rwbarton> The basic question here is how to figure out whether some type has a Val instance when you're only given a Data instance dictionary, and that doesn't sound possible to me
06:56:28 <peoro> harlekin, your solution would work but it seems complicated
06:57:08 <peoro> I mean, I think I would need a simple function like `foldl' that just starts folding from left...
06:57:26 <harlekin> > last $ takeWhile (<27) $ scanl (+) 0 $ [5,20,1,1,3] ++ repeat 1
06:57:29 <lambdabot>   26
06:57:44 <doserj> > head . snd . break (>=100) . scanl1 (+) $ [1..]
06:57:46 <lambdabot>   105
06:58:16 <augur> beep boop
06:58:29 <augur> anyone know anything about constraint satisfaction problems that can be solved without search?
06:58:59 <peoro> ok, but it seems fairly complex ... wait, I'll try to explain what I mean using haskell itself :F
06:59:28 <roconnor> does the s
06:59:31 <roconnor> oops
07:00:22 <doserj> > head . dropWhile (<100) . scanl1 (+) $ [1..]
07:00:23 <lambdabot>   105
07:00:43 <rwbarton> "without search"?  2SAT, linear programing?
07:01:08 <copumpkin> mmm, 2SAT
07:01:09 <rwbarton> I'm guessing those aren't the answers you want.
07:01:57 <Younder> 3SAT is NP complete. 2SAT isn't.
07:02:24 <peoro> hum...
07:05:50 <peoro> ok, trying to implement the scanl-like function I was thinking about I figured out that `last . takeWhile . scanl' (or something equivalend) is probably cleaner...
07:06:29 <roconnor> js
07:06:36 <roconnor> using last isn't a good sign
07:07:24 <roconnor> at least not a good sign of efficency
07:07:31 <roconnor> it might be a good sign of readablity
07:08:46 <peoro> roconnor, why not? I need the sum of the first N elements of a list such that it is lesser than N --- `( last . takeWhile (<=N) . scanl (+) 0 ) [1..]'
07:09:04 <dainanaki> Has anyone here used yesod much?
07:09:10 <peoro> I was hoping there was a function like `foldl' that works with infinite lists, but there's not
07:11:22 <Younder> peoro, No function works with infinite lists.
07:11:40 <copumpkin> some functions work more nicely on infinite lists than others
07:11:48 <Younder> Haven't you heard of the my in my recursion
07:12:25 <peoro> Younder, uh? functions can work with infinite lists thanks to lazyness
07:12:37 <Younder> You wan't the combo of foldl and take
07:12:48 * hackagebot yesod-static 0.0.0.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.0.0.1 (MichaelSnoyman)
07:12:49 <zygoloid> no function can distinguish an infinite list from a suitably long list
07:12:56 <zygoloid> (and still be total)
07:13:08 <Younder> peoro, If you introduce a upper bound my
07:13:08 <peoro> Younder, yes, that's what I did
07:19:00 <Younder> every computation has a upper bound. See to Goedls incompleteness theorem. You can compute Pi to a million digits or to a trillion but eventually you have to stop.
07:20:06 <Younder> Or the equivalent the Halting problem.
07:20:11 <peoro> Younder, yes, but the function can be defined to work with an infinite list, then you only apply it to a finite set of elements
07:20:50 <peoro> I mean... I'm not good with formal definitions, but I'm pretty sure we're thinking about the same thing.
07:25:39 <Younder> peoro, right
07:30:27 <Younder> well a foldl followed by a take on a lazy declaration is perfectly fine and something you should expext.
07:31:56 * hackagebot bitstream 0.1 - Fast, packed, strict and lazy bit streams with stream fusion  http://hackage.haskell.org/package/bitstream-0.1 (MasatakeDaimon)
07:43:51 <robryk> could freeze :: something -> Array i a be written without unsafe functions and so that it doesn't construct the whole list of elements and allocate it in its entirety?
07:44:47 <robryk> I can do as in here: http://hpaste.org/44076/array_freezing , but i cannot think of a way to do it without unsafeFreeze
07:45:13 <ClaudiusMaximus> :t array
07:45:14 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
07:45:28 <ClaudiusMaximus> :t listArray
07:45:29 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
07:46:14 <robryk> but I don't know how to do it in such a way, that the intermediate list won't get allocated all at once
07:46:51 <ClaudiusMaximus> have you profiled to check that the intermediate list is indeed allocated all at once?
07:47:28 <ClaudiusMaximus> ahhh, hm
07:47:30 <robryk> it seems so. freeze, which operates this way, takes >10x more time and significantly more allocations
07:47:35 <ClaudiusMaximus> i seem to recall something like this
07:47:46 <robryk> when compiles with -O2 it overflows the stack
07:47:49 <robryk> *compiled
07:47:55 <ClaudiusMaximus> :t getElems
07:47:56 <lambdabot> Not in scope: `getElems'
07:48:02 <ClaudiusMaximus> @hoogle getElems
07:48:02 <lambdabot> Data.Array.MArray getElems :: (MArray a e m, Ix i) => a i e -> m [e]
07:48:35 <ClaudiusMaximus> that's the one that caused me similar problems
07:48:57 <blAckEn3d> hey, I have a question about fmap and laziness (I guess, I'm not that experienced with haskell)
07:49:04 <blAckEn3d> I have the following function: http://hpaste.org/44077/fmap
07:49:48 <blAckEn3d> the way it's written in the paste the file won't get created, but if I bind the result of genPage first and write that it will create the file
07:50:01 <blAckEn3d> I was just curious why that happens
07:51:36 <robryk> is walkDir relevant? ie. does it still behave that way when you cause it to try to write one file only?
07:52:13 <robryk> @Claudius: did you resolve them then?
07:52:13 <lambdabot> Unknown command, try @list
07:53:24 <blAckEn3d> @robryk: walkDir seems to act as expected no matter how many files I have
07:53:24 <lambdabot> Unknown command, try @list
07:53:48 <sioraiocht> there isn't by any chance some keyword for existential types that isn't "forall" is there?
07:53:54 <sioraiocht> just for aesthetics?
07:54:05 <ClaudiusMaximus> robryk: i can't remember, i'd have to delve into logs...
07:54:08 <robryk> exists
07:55:59 <sioraiocht> robryk: hrm, I get an error that "exists" is not a data constructor
07:56:11 <ClaudiusMaximus> robryk: this is what i found in my logs...
07:56:12 <ClaudiusMaximus> 2011-01-08.log-16:40 < mm_freak_> ClaudiusMaximus: try using runSTUArray and 'elems'
07:56:15 <ClaudiusMaximus> 2011-01-08.log-16:41 < mm_freak_> runSTUArray doesn't copy the array
07:57:07 <robryk> sioraiocht: i might have misremembered, but it gets used somewhere, that i'm quite sure of
07:57:13 <sioraiocht> robryk: I thought so too
07:57:16 <robryk> thanks
07:57:39 <robryk> blackened: does http://hpaste.org/paste/44077/fmap_annotation#p44079 still do the strange thing?
07:58:53 <blAckEn3d> I'll give it a try
07:59:46 <robryk> Claudius: i don't see how i could use them. i have a mutable array at first, and elems is for immutable ones
08:00:17 <ClaudiusMaximus> @hoogle thaw
08:00:17 <lambdabot> Data.Array.MArray thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
08:00:17 <lambdabot> Data.Array.MArray unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
08:00:18 <lambdabot> Data.Array.IO.Internals unsafeThawIOUArray :: Ix ix => UArray ix e -> IO (IOUArray ix e)
08:01:12 <ClaudiusMaximus> wait, i'm confused - i got the direction of freeze/thaw mixed up i think :S
08:02:49 <robryk> it seems that list consumers in monad are good consumers, but list generators aren't good generators
08:03:24 <robryk> we want to reverse this somehow
08:06:18 <robryk> but for that we'd have to restrict ourselves somehow so that list consumers stop being good consumers, because you can't have both due to side-effects
08:16:34 <accel> yi = an exploration in research data structures for text editing; leksah = Haskell IDE. Is there an effort to write a production quality editor in Haskell; i.e. vim, nano, notepad in haskell?
08:17:51 <quicksilver> if all you want is notepad, just use the gtk text view in gtk2hs :P
08:18:04 <quicksilver> otherwise, yi is the only effort to write a production quality editor I'm aware of.
08:18:12 <quicksilver> note that it is not, yet, a successful effort.
08:18:25 <djahandarie> It's pretty neat but it doesn't feel like it has momentum behind it
08:18:31 <djahandarie> (Yi)
08:18:56 <quicksilver> writing a programmable text editor is hard. Writing a GUI text editor is dull.
08:19:06 <monochrom> frankly we don't need more editors or more NIH
08:19:07 <monochrom> and by NIH I mean NIH-therefore-must-reinvent
08:19:09 * hackagebot xml-types 0.1.3 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.1.3 (JohnMillikin)
08:19:31 <accel> monochrom: I actually want an _understandable_ text editor
08:19:37 <accel> monochrom: emacs core is ugly; elisp is worse
08:19:50 <accel> monochrom: I tried reading vim source; I'm about 100 IQ points too low for that
08:19:57 <monochrom> the original vi should be pretty understandable.
08:20:00 <quicksilver> it seems, to me, an attractive idea to have a programmable text editor with a cleaner and more powerful design than emacs or vim.
08:20:01 <accel> Haskell, with it's types + purity; I find I have a hope fo understanding it.
08:20:16 <quicksilver> but not attractive enough for me to spend time on it myself, clearly.
08:20:25 <accel> I'm considering doing it myself
08:20:29 <accel> after I finish this TeX DSl
08:20:38 <accel> what makes me have faith in this ...
08:20:45 <accel> and that compared to other window managers, I find XMonad surprisingly readable
08:20:57 <accel> and if I had the same in a text editor, I'd be doubly happy
08:21:10 <quicksilver> I'm not sure that has much to do with XMonad being written in haskell.
08:21:14 <accel> (emacs I hate for elisp; vim -- I can't figure out how to get basic identing work)
08:21:23 <accel> quicksilver: what does it have to do with then? dons awesome coding style?
08:21:28 <ocharles> Hrm... how do I print for each value in getArgs? I went to fmap first, but that's sort of the reverse of what I want
08:21:31 <djahandarie> dons didn't make xmonad
08:21:35 <quicksilver> I think it has to do with it being well-written by some smart people who had an explicit goal to keep code size small.
08:21:45 <djahandarie> Though he did write a lot
08:22:04 <accel> djahandarie: supposedly other ppl exist, but as far as I'm concerned dons single handedly wrote xmonad & RWH
08:22:09 <peoro> f x = x `mod` 3 == 0 -- how could I write this function as a point free one?
08:22:34 <djahandarie> accel, a number of those other people are in this channel so I don't think they'd appreciate that ;)
08:22:36 <monochrom> (== 0) . (`mod` 3)
08:22:39 <accel> dj
08:22:46 <accel> djahandarie: crap, do any of them have ops?
08:22:50 <djahandarie> Yes
08:22:51 <quicksilver> all of them, I suspect.
08:22:52 <djahandarie> Watch out
08:23:01 * accel apologies profusely everyone who worked on RWH / xmonad
08:23:04 <quicksilver> ;)
08:23:07 * accel apologies profusely everyone who worked on RWH / xmonad (that has ops)
08:23:13 * accel apologies profusely everyone who worked on RWH / xmonad (that has ops; and is easily angered)
08:23:15 <djahandarie> lol
08:23:34 <peoro> monochrom: thanks! I find it very though to do this job... always feel the need to put a `flip' here and there and everything explodes...
08:23:44 <tg_> you forgot to apologize to those who you just spurriously apologized three times
08:23:50 <monochrom> sectioning saves the day
08:24:23 <monochrom> I apologize to those who don't apologize to themselves
08:24:25 <accel> tg_: are you suggesting there are ops with bad temper?
08:24:32 <accel> tg_: I thought they were all angels
08:24:50 <accel> iirc, the buddha himself comes here to seek their patience and wisdom
08:24:59 * monochrom is a well-temperer operator
08:25:00 <tg_> monochrom has ben known to give firm spankings
08:25:07 <monochrom> err, well-tempered
08:25:08 <accel> monochrom has ops?
08:25:19 <accel> i'm pretty sure I've pissed him off in the past, and nothing bad has ever hapened
08:25:53 <dainanaki> I'm pretty sure I got kicked for 5 minutes when I noted that sometimes Haskell is sofa king hard.
08:25:56 <djahandarie> accel, it's more of if you piss off the whole room rather than an operator
08:26:01 <monochrom> if buddha is in the channel, ban buddha.
08:26:08 <dainanaki> Mind you, it might have been a bad day.
08:26:17 <accel> djahandarie: how do I achieve the former?
08:26:19 --- mode: ChanServ set +o copumpkin
08:26:23 --- mode: copumpkin set +b buddha!*@*
08:26:27 --- mode: copumpkin set -o copumpkin
08:26:43 <djahandarie> accel, dunno.
08:26:43 <accel> crap, copumpkin has ops too?
08:26:44 <tg_> that guy is all flowers and philosophy anyway
08:26:45 <tg_> who needs him
08:26:57 <tg_> accel: that's the problem with ops in this channel. you never know who has them until they uses them
08:26:59 <accel> man, it seems like everyone who's been telling me to read LYAH / RWH (and I ignored) has ops
08:27:11 <dainanaki> lesson to be learned?
08:27:19 <accel> yeah; switch nicks frequently
08:27:21 <accel> thankgod for cloaking
08:27:30 <dainanaki> man, RWH is like my second bible.
08:27:38 <tg_> my first
08:27:45 <tg_> the bible is terrible at teaching Haskell
08:27:58 <dainanaki> indeed.
08:28:22 <tg_> though as we all know
08:28:24 <tg_> Jesus was a monad.
08:28:27 <djahandarie> Bind, and it shall be bound to you. For whatever monad you deal out to others, it will be bound to you in return...
08:28:51 <dainanaki> It's true. He was lifted into heaven.
08:29:00 <accel> module Parser(parseFile, Val(..)) where
08:29:05 <accel> how do I export all the constructors of data Val ?
08:29:10 <accel> clearly Val(..) is not doing it
08:29:23 <dainanaki> And I mean feeding 5000 dudes? Definitely some side effects there.
08:29:26 <monochrom> Val(..) is doing it.
08:29:29 <ocharles> Hrm, how can I better express: (\hrm -> addPosting doc (fst hrm) (snd hrm)) `mapM` (terms `zip` [1..])?
08:29:40 <accel> import Parser (parseFile, Val)
08:29:43 <accel> clearly i'm not importing it
08:29:46 <accel> how do I import it?
08:29:46 <robryk> yes
08:29:51 <robryk> you should be importing Val(..)
08:29:52 <monochrom> Val(..) again
08:30:03 <accel> monochrom: ah; thanks
08:30:11 <ocharles> aha, uncurry ftw
08:30:11 <accel> monochrom++ # must pay the ops their dues
08:30:29 <ocharles> now I get - (uncurry $ addPosting doc) `mapM` (terms `zip` [1..]) - does that seem sensible?
08:30:49 <djahandarie> Work hard and become a C-er, be lazy and always Haskell...
08:31:03 <monochrom> the haskell designers are not perverts who contrive one import syntax and a different export syntax.
08:31:58 <accel> monochrom: I dunno; they invented Monads
08:32:20 <ocharles> uh...
08:32:33 <quicksilver> ocharles: zipWithM (addPosting doc) terms [1..]
08:32:45 <ocharles> quicksilver: thanks, that "uh.." was more at "they invented monads"
08:32:57 <ocharles> quicksilver: but yea, I'll look that up now
08:33:34 <quicksilver> ocharles: I was just combining your mapM and zip
08:33:41 <quicksilver> and the curry, in a sense
08:33:52 <ocharles> quicksilver: yea, but I just wanted to double check I could understand how it all works
08:33:53 <accel> is it bad if modules mutlaly depend on each other?
08:34:17 <monochrom> not bad, but ghc makes you work harder
08:34:28 <ocharles> quicksilver: i didn't know about zipWith either, that looks handy too
08:35:19 <accel> hmm, I feel like I want to separate my haskell code in such a way, I have one file called Types.hs and another called Ops.hs
08:35:30 <accel> and a third Globals.h
08:36:10 <quicksilver> mutually recursive modules seem like something you should consider avoiding if it's possible to do so
08:36:23 <quicksilver> because it's nice to be arrange your abstraction boundaries along module lines
08:40:21 <copumpkin> edwardk: turns out stackoverflow chat for haskell is frozen
08:40:23 <copumpkin> so no chat
08:40:35 <djahandarie> StackOverflow chat?
08:42:11 <accel> there's haskell resources besides #haskell & it's benevalonent ops for life?
08:42:24 <copumpkin> accel: what's the issue with this one?
08:42:37 <accel> issue with what?
08:42:37 <copumpkin> accel: there's haskell-cafe mailing list and the stackoverflow tag
08:42:49 <copumpkin> and the haskell subreddit
08:42:51 <interferon> what's the advantage of the new CPS engine in GHC?
08:43:07 * sm has been getting fresh items via the stack overflow haskell tag feed
08:43:15 <copumpkin> djahandarie: someone told us to go there to chat but it's closed
08:43:16 <copumpkin> :(
08:43:40 <djahandarie> I didn't even know there ever was one :(
08:44:23 <djahandarie> Oh wow, there sure are a bunch of chat rooms
08:44:37 <djahandarie> StackOverflow is going to take down Freenode!
08:44:57 <accel> stackoverflow is running an irc server?
08:44:57 <copumpkin> lol
08:45:01 <copumpkin> no
08:45:01 <accel> time to run over and grab ops
08:45:03 <copumpkin> it's their own chat thing
08:45:32 <robryk> is a list with taking-next-element a monadic action (as in http://hpaste.org/44080/list) used somewhere?
08:45:44 <djahandarie> accel, you seem to have an unhealthy obsession with ops. Perhaps you should get an injection for that.
08:45:58 <accel> not ops, just the power of being ops
08:46:11 <copumpkin> accel: quit going on about tht
08:46:21 <djahandarie> "pack primates hunger for these things in this order; oxygen, water, food, sex and hierarchical status; irc is often  misused for the last...
08:46:32 <copumpkin> moderation is used pretty rarely in here
08:46:43 <copumpkin> and you don't have to worry about pissing ops off personally
08:46:48 <copumpkin> you just have to worry about being pleasant
08:46:59 <copumpkin> I'd hope it wouldn't be a worry for most people
08:49:25 <accel> taht's really good
08:49:28 <accel> you guys sould start a comedy show
08:49:33 <copumpkin> o.O
08:50:01 <edwardk> copumpkin: well, being unpleasant pisses off the ops so its hard to draw that distinction ;)
08:50:20 <copumpkin> yeah, but we'll get pissed off if someone is unpleasant to anyone in here
08:50:27 <copumpkin> no need to be worried specifically about being unpleasant to ops
08:50:45 <accel> I think the difference between "unpleasant" vs "pissing off the ops"; is unpleasant = mass flooding = not okay; but being mean to ops, i.e. saying "copumpking likes to code in C and leavea state all over the palce" = okay
08:51:02 <copumpkin> that isn't unpleasant really
08:51:03 <copumpkin> it's silly
08:51:30 <copumpkin> I wouldn't hold anything against you for saying that to me, but if you said nothing but stuff like that it'd start getting tiresome
08:51:57 <accel> you know, what scres me most
08:52:01 <accel> is the realization that often times,
08:52:06 <accel> a single line of haskell = entire function in other languages
08:52:16 <accel> i'm just looking over my code
08:52:25 <accel> and a 100 line haskell file is a "burden" to intellectually comprehend
08:52:34 <accel> whereas in C, I'd just glance over it, and know how ti works
08:53:32 <accel> so for example, my entire prog is 144 LOC right now
08:53:43 <accel> but in one file, incomprehensible (especially with the record fields stepping on each other)
08:53:53 <accel> so now, I have Parser = 65 LOC, Evaluator = 55 LOC, Main = 24 LOC
08:53:57 <copumpkin> it certainly takes getting used to :)
08:54:06 <copumpkin> I tend to keep my functions in haskell tiny
08:54:13 <copumpkin> and general
08:54:24 <copumpkin> so I can understand their behavior more easily
09:00:02 <ocharles> well you kind of have to
09:01:11 <ocharles> but i agree, I just finished porting http://xapian.org/docs/quickstart.html to Haskell and it's... 10 lines, with imports and whitespace
09:05:58 <quicksilver> I wonder if a lot of the namespacing problems that people find with haskell would be remedied simply by allowing 'local modules' within another module
09:06:16 <quicksilver> they'd just be namespaces, possibly with some special import/export support possibly not.
09:06:18 <accel> this is a fucking idiotiqc quetion -- I have a (x :: State Int [Val]) ; how how do I create a State w/ Int = 0, so I can run x, and get my [Val] ?
09:06:29 <quicksilver> runState x 0 ?
09:06:40 <accel> this is a fucking idiotiqc quetion -- I have a (x :: State Int [Val]) ; how how do I create a State w/ Int = 0, so I can run x, and get my [Val] ? i.e. I want a function that's " run_this_fucking_state :: Int -> (State Int [Val]) -> [Val])
09:06:44 <Jafet> Doesn't Haskell ostensibly allow local modules?
09:07:09 <quicksilver> Jafet: it doesnt specify how files and modules relate, but it doesn't allow nested modules, which is what I'm implying.
09:07:27 <Jafet> Well, sometimes I've wanted ML-style local type definitions.
09:07:30 <accel> quicksilver: I believe it's fst $ runState x 0 
09:07:33 <quicksilver> accel: your functions are runState, evalState and execState
09:07:36 <quicksilver> correct.
09:07:48 <accel> quicksilver: thank
09:07:59 <edwardk> jafet: sadly no
09:08:05 <quicksilver> Jafet: yes, occassionally me too. I'm not opposed to that but I think (possibly) local namespaces would be enough.
09:08:29 <Jafet> So... is anyone seriously working on it?
09:08:32 <pozic> If you pass a structure containing functions around, you also have a 'module'. 
09:09:17 <pozic> It is just that having it integrated in the language might be a good thing. 
09:09:23 <edwardk> jafet: nope
09:09:38 <pozic> The disadvantage is that it complicates the language. 
09:09:52 <accel> :t runState
09:09:53 <lambdabot> forall s a. State s a -> s -> (a, s)
09:09:55 <accel> :t execState
09:09:57 <lambdabot> forall s a. State s a -> s -> s
09:10:00 <accel> :t evalState
09:10:01 <lambdabot> forall s a. State s a -> s -> a
09:10:04 <quicksilver> pozic: sure, but I was honestly just talking about the namespacing benefit.
09:10:11 <quicksilver> not modules as first class in any sense.
09:10:15 <edwardk> jafet: there is no wrapper around module in the syntax
09:10:29 <quicksilver> just module F where { module G where { f :: A }; module H where { f :: B } }
09:10:40 <quicksilver> ^^ F.G.f not colliding with F.H.f
09:12:44 <Jafet> If you could have multiple modules per file, you could technically have that
09:13:24 <accel> why is " ... $ `String` x\n" illegal in cases where " ... (`String` x)\n" fine ?
09:13:38 <Jafet> ... just less sweetly
09:14:19 <Jafet> `String` x is an operator without a left operand
09:14:28 <Jafet> (`String` x) is an operator section
09:14:31 <accel> yeah, so whyd oes $ vs () differ in this case?
09:14:35 <accel> oh
09:15:21 <doserj> because () does more than just grouping here
09:15:43 <accel> doserj: noted; thanks
09:18:22 <accel> does haskell provide a stack implementation?
09:18:34 <accel> hoogle keeps on telling me about
09:18:35 <accel> happstack
09:18:37 <accel> stackoverflow
09:18:39 <accel> and stack depth
09:18:49 <monochrom> list = stack
09:18:54 <Apocalisp> What's wrong with [] ?
09:19:43 <Apocalisp> let push = (:)
09:19:46 <doserj> top = head, push = (:), pop = tail
09:19:52 <accel> ok ok ok
09:19:57 <accel> point taken
09:20:37 <monochrom> succint answer is superior :)
09:21:36 <Apocalisp> let pop = liftA2 (,) head tail
09:21:51 <edwardk> [] is an awesome stack
09:22:42 <edwardk> Seq makes a pretty damn good random access deque too
09:23:06 <monochrom> bot wants a wholesome snack
09:26:34 <stepkut> monochrom: what is the link to that blog post about mixing cabal-install and distribution packages ?
09:48:47 <katja> ?scr map
09:48:47 <lambdabot> Maybe you meant: arr rc src
09:49:06 <katja> ?src map
09:49:06 <lambdabot> map _ []     = []
09:49:06 <lambdabot> map f (x:xs) = f x : map f xs
09:52:45 <gigabytes> hello
09:53:07 <gigabytes> can someone explain me what is this "monomorphism restriction" ? I've searched on the internet, but it's not very clear
09:53:38 <Zao> gigabytes: By default, values and functions prefer to be taking concrete types instead of using quantifiers.
09:53:49 <monochrom> stepkut: http://www.vex.net/~trebla/haskell/sicp.xhtml
09:53:57 <ezyang> gigabytes: It's to prevent users from being surprised by repeated computation of a "constant" 
09:54:00 <gigabytes> Zao: I don't think to get the point
09:54:21 * Zao defers to people who excel at explaining it.
09:54:32 <gwern> > 300 * 20
09:54:33 <lambdabot>   6000
09:55:24 <monochrom> stepkut: http://www.vex.net/~trebla/haskell/sicp.xhtml
09:55:37 <dahankzter> Is "read" the way to convert a string to int?
09:55:54 <Zao> dahankzter: It tends to be a decent way.
09:56:01 <gigabytes> ezyang: can you explain better?
09:56:05 <Tau> hey, i'm new to haskell and i'm using ghci to test things.
09:56:16 <dahankzter> Zao: thx
09:56:20 <ezyang> gigabytes: What seems unclear to you? 
09:56:34 <Zao> dahankzter: There might be other functions if you have requirements like particular radixes or suchlike.
09:56:36 <Tau> how can i define a function with pattern matching in the ghci ? i type let func 8 = "j" and then let func 9 = "h"
09:56:38 <Tau> and it doesn't work
09:56:48 <Tau> how can i make it accept more than two definitions ?
09:56:56 <Tau> i mean, how can i ident the code in the ghci.
09:57:06 <gigabytes> ezyang: when ghc gives me an error that has to do with the monomorphism restriction, all I have to do is adding an explicit type declaration. What does this have to do with "repeated" computations?
09:57:14 <ezyang> Tau: You can use semicolons 
09:57:23 <monochrom> let { func 8 = "j"; func 9 = "h" }
09:57:33 <Tau> hmm.
09:57:34 <ezyang> gigabytes: So, what that means is that you've tried to use the value with two different types. 
09:57:40 <Tau> ezyang, alright.
09:57:45 <Tau> monochrom, nice.
09:57:46 <monochrom> but I would write a file and load
09:57:55 <gigabytes> Tau: Layout doesn't work in the interpreter. I suggest you to write to a file and load it with :load and :reload
09:58:01 <ezyang> So by default, GHC will complain. If you add an explicit type, GHC needs to compute the value for every end type 
09:58:10 <Tau> gigabytes, yes. it seems better.
09:58:21 <gigabytes> ezyang: I'll paste an example
09:59:30 <lispy> http://www.reddit.com/r/haskell/comments/fnc80/type_level_natural_numbers_ready_to_merge_into/
10:00:02 <gwern> > 200/(log 0.05)
10:00:03 <lambdabot>   -66.76164013906681
10:00:17 <robryk> does IO monad look like a State monad from the point of the view of the compiler?
10:00:18 <accel> in "put t { texStack = (String ln ("\\" : name)) texStack t }" is "maeCommand1 :: String -> Command
10:00:26 <gwern> > 200/(log 5)
10:00:27 <lambdabot>   124.26698691192237
10:00:29 <accel> in "put t { texStack = (String ln ("\\" : name)) texStack t }" is "maeCommand1 :: String -> Command" a function of some sort? I want to factor it out
10:01:09 <accel> ideally, I want to just pass a function that modifies a field of a record
10:01:53 <sproingie> robryk: i think it's more like ST RealWorld 
10:02:15 <sproingie> robryk: that's as ST is concerned tho.  i think ghc special-cases IO directly
10:02:50 <accel> modString :: (String LineNumber String) -> (String -> String) -> (String LineNumber String) <-- given Haskell already knows the data Constructor String, can I somehow drop the LineNumber part?
10:03:00 <robryk> ok. i want to imagine what happens when i do `do { x <- someArrayProducingOperation ; let y = f x ; someOperation y }'
10:03:06 <sproingie> IOW i think ST may be in terms of IO and not the other way around
10:03:11 <gwern> > 200/(log 1.05)
10:03:12 <lambdabot>   4099.18686285757
10:03:31 <robryk> does it necessarily follow that x gets computed whole before y's evaluation begins?
10:04:17 <monochrom> someArrayProducingOperation gets computed, but x probably doesn't
10:04:28 <robryk> ok
10:05:20 <jsgf> bos: morning
10:05:52 <robryk> i am trying to find a way (possibly other than just putting in unsafePerformIO) to have a array-processing function fed with an array read from outside, and not store that array in memory at any time
10:06:15 <bos> jsgf: hole
10:06:20 <bos> jsgf: uh, hola
10:07:04 <monochrom> look for "freeze" and "thaw" for transferring arrays out of ST or into
10:07:37 <jsgf> bos: do the Monoid conflict resolution versions do anything useful with links or user metadata?
10:07:40 <jmcarthur> robryk: are you talking about actual arrays or just lists?
10:07:53 <robryk> sorry. my bad. meant lists
10:08:23 <gigabytes> ezyang: http://hpaste.org/44081/monomorphism_restriction
10:08:28 <monochrom> lists are immutable. so called "change" means creating new lists, therefore more memory
10:08:36 <jmcarthur> robryk: there are a few ways to do it. you could explicitly interleave reading and processing, you could use unsafeInterleaveIO, or you could use iteratees
10:08:43 <bos> jsgf: all the conflict resolution code does is call mconcat on the siblings. the rest is up to you.
10:09:15 <jmcarthur> robryk: the last one is intended to be a better replacement for the second to last one, but it's kind of tough to learn
10:09:25 <robryk> jmcarthur: thanks, will read on those and come back if/when i find something confusing
10:09:32 <jmcarthur> robryk: unsafeInterleaveIO is a bit better than unsafePerformIO, but can still lead to some unexpected things if you aren
10:09:34 <jmcarthur> 't careful
10:09:47 <jmcarthur> robryk: the first one is obviously the least composable and the most work
10:10:03 <Cale> robryk: If lists are processed in the natural order, then it's quite possible that only one element of an intermediate list be in memory at once, and there are lots of rewriting rules for fusing operations on lists so as to eliminate intermediates if you turn on optimisations.
10:10:37 <jmcarthur> i *think* robryk is basically just looking for a lazy IO sort of thing
10:10:46 <robryk> moreorless yes
10:10:47 <Cale> For a simple example, if you write   map f (map g xs)  it will be turned into  map (f . g) xs
10:10:53 <robryk> i know that
10:10:56 <gigabytes> ezyang: why doesn't this work? It works with an explicit type signature (height :: (Ord t1, Num t1, Ord t, Show t) => Tree t -> t1), or by adding the parameter, eg definig height t = treefold.... t instead
10:11:00 <robryk> but it doesn't mix well with monads
10:11:08 <jmcarthur> list is a monad
10:11:12 <Cale> It doesn't?
10:11:22 <robryk> freeze creates and allocates whole list
10:11:31 <Cale> wait, what?
10:11:37 <Cale> freeze is an array thing
10:11:45 <robryk> it does something like { list <- getAssocs something ; return array bnds list }
10:12:09 <robryk> the intermediate list gets allocated whole, not one element at a time
10:13:08 <Cale> Well, there's not necessarily an intermediate list in freeze.
10:13:26 <Cale> Though I suppose there might be.
10:13:30 <robryk> you mean that it can be done without or that there isn't in the implementation?
10:13:33 <ezyang> gigabytes: Oh, you've done something silly :-) 
10:13:54 <gigabytes> ezyang: what exactly? :)
10:13:56 <ezyang> You've written height point-free 
10:14:09 <ezyang> So even though it is a "function", the monomorphism restriction applies. 
10:14:17 <gigabytes> ok
10:14:17 <gigabytes> so
10:14:26 <gigabytes> please explain me what "point-free" does mean :)
10:14:29 <Cale> Well, it should be impossible to tell without looking at the source code whether or not there's an intermediate list in freeze.
10:14:41 <robryk> yes
10:14:45 <jsgf> bos: hm. 
10:14:52 <ezyang> gigabytes: You've omitted some of the arguments, roughly. 
10:14:53 <monochrom> monomorphism restriction is triggered by syntax "x = ..." doesn't care function vs not-function
10:14:59 <robryk> i looked, because freezing a sizeable array took very long
10:14:59 <ezyang> f z = g versus f z x = g x 
10:15:03 <Cale> It does make a copy of the original array, so the space usage is O(n)
10:15:44 <gigabytes> ezyang: ah ok. That was intentional. So why does this code fail?
10:15:54 <robryk> and due to the array it takes more than 10 times longer than rewriting the array into another mutable one and unsafeFreezing that one
10:16:01 <robryk> *due to the list
10:16:14 <jmcarthur> okay so this is actually arrays, *not* lists?
10:16:20 <Cale> Well, unsafeFreeze doesn't even make a copy
10:16:24 <Cale> oh
10:16:31 <Cale> That's interesting
10:16:49 <Cale> So it might be worth suggesting that implementation to the GHC folks
10:16:54 <robryk> it's impossible
10:16:58 <jmcarthur> robryk: you mean that freeze is slower than copy-and-unsafeFreeze?
10:17:09 <robryk> you need a mutable version of the immutable array you want to create
10:17:11 <robryk> yes
10:17:17 <jmcarthur> interesting
10:17:23 <jmcarthur> i wonder why freeze is slower
10:17:38 <robryk> because it converts the whole array into a list
10:17:38 <Cale> It looks like freeze really does construct an intermediate list.
10:17:47 <robryk> and does a bucketload of allocations
10:18:16 <robryk> if i compile it with optimization, it overflows a 100M stack for a 1200*1600 Int array
10:18:23 <Cale> es <- mapM (unsafeRead marr) [0 .. n - 1]
10:18:25 <ezyang> because the monomorphism restriction forces the function to "decide" what the a in Tree a is, but there's no information what that type should be. 
10:18:29 <jmcarthur> oh yuck, freeze uses a list
10:19:26 <gigabytes> ezyang: hm.. that's still unclear but I have to go. Thank you very much. Bye bye
10:19:32 <Cale> The freeze operation obviously hasn't been the focus of much optimisation effort :)
10:19:37 <robryk> it can't be
10:19:47 <robryk> the only way to create an immutable array is from a list
10:19:54 <jmcarthur> not true
10:19:56 <Cale> No, there are other ways
10:19:59 <robryk> what?
10:20:04 <Cale> Remember that this is inside the GHC implementation
10:20:05 <jmcarthur> you can make a mutable array and unsafeFreeze it
10:20:09 <robryk> no
10:20:14 <robryk> oh
10:20:18 <robryk> you mean for specific arrays?
10:20:34 <robryk> not any IArray?
10:20:37 <jmcarthur> it's how listArray works
10:20:47 <Cale> It's possible to specialise a polymorphic operation for IArrays on particular types.
10:20:53 <Cale> unsafeFreeze in fact uses this :)
10:20:59 <robryk> ok
10:21:00 <jmcarthur> it just makes a mutable array and then gives you an immutable array using the mutable one underneath
10:21:21 <jsgf> bos: trying to work out how it all fits together. The Links and usermeta are only exposed through Content?  So I need to toContent my types to get to them?
10:21:36 <jmcarthur> note to self: never use the freeze functions
10:21:38 <jmcarthur> *function
10:22:20 <monochrom> "The old array and index might not be well-behaved, so we need to use the safe array creation function here."
10:22:40 <c_wraith> Oh, hmm.  An extension for compiler-supported type-level naturals is planned for GHC 7.2?
10:22:44 <monochrom> though I don't know what could go wrong
10:22:44 <bos> jsgf: you need to use https://github.com/mailrank/riak-haskell-client/blob/master/src/Network/Riak/Value/Monoid.hs
10:22:55 <copumpkin> c_wraith: not sure it'll be 7.2, but soon I hope :)
10:23:03 <bos> jsgf: you can use get to give you back a Content
10:23:13 <bos> jsgf: and then use fromContent to convert that you your type
10:23:18 <jmcarthur> wtf. "unsafeFreeze = freeze" and it relies on rewrite rules for the faster implementation
10:23:27 <robryk> well, how else?
10:23:35 <robryk> when it is supposed to work for any IArray
10:23:35 <bos> jsgf: and the Content that "get" hands you back will contain the links and such that you need
10:23:35 <Cale> jmcarthur: yeah
10:23:36 <jmcarthur> Cale: is that the crazy specialization you were talking about?
10:23:49 <Cale> jmcarthur: hah, answered your question before you asked it
10:23:49 <monochrom> same technique for fromIntegral
10:24:06 <jmcarthur> seems yucky
10:24:24 <Cale> jmcarthur: It's pretty reasonable. It means that unsafeFreeze will work at any type
10:24:50 <Cale> but you get the optimisation when the particular pair of types to convert between are appropriate
10:24:56 <jmcarthur> seems like something i would have used a type family / type class thingy for
10:25:04 <jmcarthur> i guess i see that though
10:25:11 <jmcarthur> means the interface isn't cluttered with it, this way
10:25:30 <bos> jsgf: make sense?
10:25:39 <monochrom> if you find me a time machine, I can ship type family back to 2000 when this happened
10:27:09 <dark> how to make a documentation (with haddock maybe?) with a theming similar to hackage?
10:27:27 <jmcarthur> dark: read the haddock docs?
10:27:31 <monochrom> a new enough version of haddock
10:27:44 <Cale> Yeah, that's just the new version of haddock, I think.
10:27:51 <jmcarthur> it is
10:27:53 <robryk> by the way: was there any particular reason hs-ffmpeg got sort of abandoned in 2009?
10:28:16 <monochrom> perhaps author went back to school
10:28:20 <dark> oh, i'm at http://www.haskell.org/haddock/doc/html/invoking.html :)
10:28:24 <robryk> oh, ok
10:28:35 <dark> dev-haskell/haddock 2.7.2 here
10:28:37 <robryk> was wondering if there's something else i should use isndtead
10:28:41 <dark> is that version too old?
10:28:57 <dark> (for this theming thing)
10:29:18 <jsgf> bos: yes, as far as it goes.  But what type needs a Monoid instance?  Content?
10:29:56 <monochrom> need 2.8
10:30:00 <bos> jsgf: oh hm, riight.
10:30:07 <bos> jsgf: that won't work, will it.
10:30:12 <bos> jsgf: i've to run for a bit.
10:30:18 <bos> sorry to leave you in suspense.
10:30:22 <monochrom> oh, maybe 2.7.2 is new enough
10:30:36 <monochrom> sorry, misread. it is 2.8
10:30:42 <robryk> what should i do if i have a patch that makes it sort-of work (instead of crash on dealloc of some objects) in current ghc?
10:30:50 <robryk> i mean, hsffmpeg
10:31:30 <c_wraith> robryk: see if you can contact the maintainer.  If not, things get a bit tougher.
10:31:36 <Cale> Try emailing the maintainer, and if you don't get a reply, you can always just upload a newer version to hackage yourself. :)
10:31:37 <robryk> ok
10:31:43 <robryk> will try that
10:31:48 <dark> haddock: unrecognized option `--built-in-themes' unrecognized option `--theme=ocean'
10:32:14 <Cale> dark: You need a newer haddock, I think.
10:32:22 <ksf> why aren't we advertising on stackoverflow?
10:32:32 <robryk> is there some widely-used way to prevent objects pointed to by foreign ptrs which won't be referenced in haskell but will be referenced from the outside library being dealloced?
10:32:32 <dark> ok, will try to get 2.8.0, thanks
10:32:50 <Cale> http://hackage.haskell.org/package/haddock
10:32:56 <Cale> Why not 2.9.1?
10:33:05 <robryk> i mean, when we can tell that ptr X contains a handle to the thing pointer Y points to
10:33:13 <Cale> Oh, maybe that's ghc-7 only?
10:33:14 <dark> http://www.haskell.org/haddock/ haven't see it there, thanks
10:33:26 <dark> ghc 6.12.3 here
10:33:34 <Cale> yeah, 2.8.1 will be the one you want
10:33:42 <Cale> You should be able to cabal install it
10:38:40 <accel> is there a conciser version of:
10:38:42 <accel> evalVal (NewLine ln) = do  t <- get put t { texStack = (String ln "\n"): texStack t }
10:39:14 <dark> @pl do  t <- get put t { texStack = (String ln "\n"): texStack t }
10:39:15 <lambdabot> (line 1, column 20):
10:39:15 <lambdabot> unexpected "{"
10:39:15 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
10:39:15 <zygoloid> modify, rather than get/put
10:39:29 <accel> zygoloid: anh modify :: MonadState s m => (s -> s) -> m () thanks
10:42:00 <c_wraith> accel, when flattening a multi-line do block to single line for pasting here, please also convert it to use { ; } notation
10:42:08 <accel> c_wraith: noted
10:42:13 <accel> c_wraith: doubly noted if you have ops
10:42:21 <dark> lol
10:42:24 <accel> i think i'm going to look into my vim plugin
10:42:30 <accel> and try to get the auto paste to hpaste.org working
10:42:33 <accel> then I can just send links
10:42:41 <accel> yay for laziness
10:43:13 <zygoloid> accel: i'd write that as: evalVal (NewLine ln) = (modify . modifyTexStack) (String ln "\n":)
10:43:24 <accel> whoa
10:43:26 <accel> modifyTexStack
10:43:30 <dark> i want an emacs mode for hpaste then o.o
10:43:31 <accel> that's brilliant
10:43:38 <zygoloid> @where sec
10:43:39 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
10:43:43 <zygoloid> accel: ^^ read that
10:43:46 <accel> dark: in emacs, it's M-x shell vim
10:44:25 <dark> :) or C-x C-f ~/.emacs  and figure out how to code it in elisp
10:44:32 <accel> zygoloid: is there a twitter version of that post?
10:44:48 <accel> zygoloid: bookmarked to read later, after I get this code working
10:45:02 <accel> the modifyTexStack + "abuse" of : is brilliant though
10:46:23 <katja> ?src iter
10:46:24 <lambdabot> Source not found. It can only be attributed to human error.
10:49:04 <dark> btw haddock is so nice =~
10:49:33 <astroboy> If there is a flag "foo" defined in the .cabal file of some package, how do I enable that flag when using "runhaskell Setup configure"?
10:50:04 <accel> I would rather lose a pinky than lose haskell.
10:50:05 <dcoutts> astroboy: runhaskell Setup configure -ffoo
10:50:11 <accel> Writing interpreters in haskell = teh funiness.
10:50:15 <copumpkin> -fffuuu
10:50:34 <astroboy> dcoutts: ok, that's what I try and it doesn't work. it must be something else I guess...
10:55:09 * hackagebot free 0.1.0 - Haskell 98 monads for free  http://hackage.haskell.org/package/free-0.1.0 (EdwardKmett)
10:57:37 <thoughtpolice> copumpkin: cabal install rage -f7u12
10:59:03 <katja> hey! could someone help me. I need to define that fucntion with a foldr. i dont understand it a bit, because f in iter is a operation with an element already but foldr has different places for an operation and an element
11:01:24 <katja> sorry that funciton http://codepad.org/ffqi3Z3I
11:05:14 * hackagebot eq 0.3.0 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.0 (EdwardKmett)
11:06:42 <taotree> error trying to install haskell98:  http://hpaste.org/44083/haskell98error  
11:07:59 <ksf> looks like haskell98 broke, yes.
11:08:27 <ksf> It's probably not fixed yet because people using that package don't care about having the newest ghc version...
11:08:35 <Tomsik> @pl \(a,b) (c,d) = (a+c, b+d)
11:08:36 <lambdabot> (line 1, column 14):
11:08:36 <lambdabot> unexpected "="
11:08:36 <lambdabot> expecting pattern or "->"
11:08:40 <Tomsik> @pl \(a,b) (c,d) -> (a+c, b+d)
11:08:41 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
11:08:41 <edwardk> fun
11:08:41 <taotree> oh ok... so... that means I'll try install previous version then...
11:08:44 <Tomsik> ouch
11:09:00 <ksf> taotree, I suspect you have ghc 7?
11:09:34 <taotree> ksf, no 6.12.3
11:09:46 <taotree> haskell98-1.0.1.1 just installed fine
11:09:49 <ksf> hmm. it *does* depend on directory
11:10:09 <taotree> maybe my Directory is broken or wrong version or broke it?
11:10:14 <Tomsik> Is there any equivalent of bimap?
11:10:17 <Tomsik> for (,)
11:10:21 <hpc> :t for
11:10:22 <lambdabot> Not in scope: `for'
11:12:55 <ksf> taotree, you need directory >=1.1.0.0
11:13:19 <edwardk> tomski: yes
11:13:21 <edwardk> bifunctors
11:13:23 <ksf> taotree, feel free to name+shame Ian for not specifying that constraint
11:13:32 <edwardk> tomski: a small haskell 98 package
11:14:00 <edwardk> http://hackage.haskell.org/packages/archive/bifunctors/0.1/doc/html/Data-Bifunctor.html
11:14:06 <taotree> ksf, ok, thanks, I'll upgrade directory and see where that goes
11:15:31 <copumpkin> Tomsik: bimap on (,) is (***)
11:15:55 <doserj> > let f =  uncurry (***) . ((+) *** (+)) in f (1,2) (3,4)
11:15:57 <lambdabot>   (4,6)
11:16:19 <edwardk> bah, bimap on (,) is bimap ;)
11:17:38 <Tomsik> oh, right, I'm kind of unfamiliar with operators from Control.Arrow
11:17:40 <Tomsik> thanks
11:29:28 <HugoDaniel> hi
11:29:54 <HugoDaniel> how do i create a Word8 type from a Char type ?
11:30:16 <monochrom> fromIntegral . fromEnum
11:30:20 <Zao> @type ord
11:30:21 <lambdabot> Char -> Int
11:30:22 <HugoDaniel> thanks monochrom 
11:30:36 <monochrom> you could s/fromEnum/ord/
11:31:00 <Zao> HugoDaniel: Note that the ordinal from most Char do not fit in a Word8.
11:31:14 <Zao> 10FFFF - 256 or so :D
11:32:20 <monochrom> 𝐈 𝐚𝐠𝐫𝐞𝐞
11:35:10 <HugoDaniel> Zao, yes, im aware of that, i just need to compare for equality a ',' to a UTF8 Word8
11:35:52 <accel> Help! I have a replacement table http://hpaste.org/44089/replace .. I want to take str, nd replace all occurences of teh unicode char in the left with the string int he right; how do I do this? I almost want to map, but not quite .. i.e. I want the string to go through all transforms, not a separate string for each transform
11:36:55 <Zao> HugoDaniel: Better safe than sorry :D
11:36:59 <accel> http://hpaste.org/paste/44089/replace_annotation#p44090 is what I have so far
11:37:06 <accel> what do I use isntead of the map?
11:37:42 <EvanR> :t map map
11:37:43 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
11:37:46 <EvanR> ;)
11:37:58 <accel> it's not map
11:38:08 <accel> i needd the changes to the string after each replace to accumulate
11:38:15 <ksf> :t lookup
11:38:16 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:38:17 <EvanR> fold maybe
11:38:33 <EvanR> fold the chances into the initial string
11:38:36 <EvanR> changes
11:39:05 <ksf> map (\c -> maybe c id (lookup c replaces))
11:39:23 <accel> ksf++
11:39:47 <accel> this is faster too
11:40:05 <ksf> I wouldn't write (lookup c replaces), though, but write replacementFor :: Char -> String
11:40:19 <monochrom> does not typecheck
11:40:21 <ksf> so that you can change the lookup structure without changing anything els
11:40:35 <accel> what? I'm just going to use a map
11:41:24 <ksf> :t \xs c -> maybe c id (lookup c xs)
11:41:24 <lambdabot> forall a. (Eq a) => [(a, a)] -> a -> a
11:41:42 <ksf> monochrom, why wouldn't it typecheck?
11:42:11 <accel> what's wrong with this: http://hpaste.org/44091/replace
11:42:39 <accel> the |
11:42:48 <monochrom> delete the |
11:42:56 <ksf> that, and your fancy symbols are strings
11:43:09 <accel> ksf: they're called unicode
11:43:28 <shachaf> accel: Still strings.
11:43:28 <monochrom> ksf means "∀" vs '∀'
11:43:36 <monochrom> and this also answers ksf's question
11:43:38 <accel> ay; i know, it
11:43:39 <accel> s fixed
11:43:39 <ksf> subList c = Map.lookup c . Map.fromList $ [...]
11:44:09 <monochrom> (\xs c -> maybe c id (lookup c xs)) in separation typechecks but not in context
11:44:25 <copumpkin> fromMaybe
11:44:45 <ksf> monochrom, behold my powerful typechecker, which infers Char if all strings are of length 1.
11:44:50 <ksf> your compiler can't do that.
11:45:08 <ksf> :t fromMaybe
11:45:09 <lambdabot> forall a. a -> Maybe a -> a
11:45:21 <copumpkin> hmm, the typechecking seems fishy in that file
11:45:24 <monochrom> I know a hundred depraved compilers/interpreters such as perl's who do that.
11:45:27 <ksf> ha! fiddlesticks.
11:45:39 <copumpkin> seems like he wants concatMap (maybe pure (lookup 
11:45:57 <ksf> newfangled functions like that are the reason why young people can't code pointless, anymore!
11:47:18 <xplat> 02:15 < ray> half of mathematics is suspecting someone proved your baseless  assertion and forging on
11:48:03 <xplat> the other half, of course, is realizing that nobody ever proved your obvious assumption and in fact it is either false or independent of your axiom system
11:48:17 <monochrom> haha independent
11:48:42 <ksf> and all of philosophy is starting out with "supposing what I say is true" and then elaborating on that.
11:48:42 <accel> http://hpaste.org/44092/strict <-- why can't I do this?
11:48:48 <accel> http://hpaste.org/44092/strict <-- why can't I do this? (I want it to be stricct)
11:49:13 <sproingie> "supposing what i say is false, suppose what i say is false"
11:49:14 <ksf> no, you don't want that.
11:49:20 <accel> why not?
11:49:31 * ksf waves with his hand.
11:49:38 * accel believes
11:49:47 <accel> i clearly don't want that
11:50:24 <ksf> well, short version of the long answer, it's a CAF, anyway, the map is only going to be constructed once.
11:50:30 <accel> what's a CAF ?
11:50:55 <ksf> INCIDENTALLY, I just answered a similar question here: http://stackoverflow.com/questions/5032750/haskell-caching-function-values
11:51:08 <accel> should I upvote?
11:51:21 <ksf> yes, please, I'm a karmawhore.
11:51:32 <accel> are you barsoap?
11:51:36 <ksf> yep
11:51:38 <xplat> @remember accel < accel> one day, it was raining < accel> I was walking home < accel> I saw Knuth biking home, wearing a helmet, in the rain < accel> and I freaked out < accel> rain was hitting him like any other mortal ... it wasn't bounching off his aura of awesomeness
11:51:38 <lambdabot> It is stored.
11:52:18 <accel> xplat: are you jealous I was close enough to knuth to witness him biking in the rain?
11:54:09 <accel> ksf: I have like over 4K karma on that site
11:54:18 <accel> all I did was ask a bunch of silly C++ questions
11:54:39 <ksf> yep, c++ is nearly as bad a circlejerk as c#
11:54:45 <systemfault> Yeah.
11:54:58 <systemfault> It's no #Haskell :P
11:55:07 <xplat> accel: we're all close to knuth, whenever we write good algorithms
11:55:29 <systemfault> Knuth...
11:55:52 <systemfault> I wonder if he will finish his book before...
11:56:05 <monochrom> before I finish my thesis!
11:56:10 <xplat> 2012
11:56:12 <aaaaaa> :D
11:56:50 <systemfault> Before he dies :'(
11:57:15 <accel> knuth is the only reason why I believe
11:57:26 <accel> inventing a machine that lets us transfer remaining life years from oen person to another
11:57:29 <accel> is a good idea
11:57:34 <monochrom> even elvis hasn't died and is still sighted
11:58:19 <systemfault> Of course!
11:58:20 <aaaaaa> he's undead
11:58:27 <systemfault> T-Virus?
11:58:40 <systemfault> Resident Evil Knuth
11:58:49 <monochrom> hahaha
11:58:57 <xplat> lots of people finish books after they die anyway
11:59:10 <xplat> heinlein, asimov, tolkein, hubbard
11:59:48 <aaaaaa> lots of people begin to write books after they die anyway
12:00:04 <monochrom> but do they blog?
12:00:05 <xplat> it's like if you don't write at least one book after you're dead you fail as a writer
12:00:40 <systemfault> I troll asimov
12:00:49 <accel> damn it; is there no unicode for >= ?
12:00:51 <systemfault> The 3 laws of robotics: #1 - The first rule of Fight Club is, you do not talk about Fight Club.#2 - The second rule of Fight Club is, you DO NOT talk about Fight Club. #3 - If someone says stop, goes limp, taps out, the fight is over.
12:01:01 <hpc> accel: there is
12:01:09 <hpc> apparently i can't type it into putty though
12:01:12 <accel> http://en.wikipedia.org/wiki/List_of_Unicode_characters disagrees
12:01:16 <mauke> U+2265 (e2 89 a5): GREATER-THAN OR EQUAL TO [≥]
12:01:17 <accel> what's the unicode hex?
12:01:20 <hpc> that's not even close to complete
12:01:58 <accel> what shold I use to seach unicode chars then?
12:02:04 <hpc> accel: google
12:02:07 <ksf> accel, http://hackage.haskell.org/package/base-unicode-symbols
12:02:08 <xplat> gucharmap?
12:02:20 <mauke> accel: a local copy of http://mauke.dyndns.org/stuff/javascript/unicode.html :-)
12:02:24 <aaaaaa> kcharselect?
12:02:25 <hpc> "unicode less than or equal to"
12:02:31 <hpc> leads to http://www.fileformat.info/info/unicode/char/2264/index.htm
12:02:49 <accel> mauke: oh shit
12:02:51 <accel> mauke: that is nice
12:02:56 <accel> mauke: is it a single page?
12:03:07 <accel> mauke: i.e. search in javascript
12:03:09 <mauke> yes
12:03:53 <ksf> whooping 707k
12:04:00 <accel> i should wget that page for fun
12:04:10 <accel> unless mauke has ops
12:04:12 <hpc> that's a cool page
12:04:12 <accel> in which case i should not
12:04:19 <accel> local copy saved
12:04:45 <monochrom> http://www.vex.net/~trebla/symbols/select.html
12:04:51 <hpc> mauke: can i host the page?
12:04:56 <mauke> hpc: sure
12:05:00 <hpc> credit will be given
12:06:54 <xplat> accel: how many chapter of RWH have you got through now?
12:07:00 <augustss> hi
12:07:03 <hpc> http://98.169.17.243:8000/thirdparty/unicode.html
12:07:12 <hpc> should be an exact copy, unless wget fails
12:07:29 * hackagebot th-sccs 0.0.0.20110217 - Binding group analysis in Template Haskell  http://hackage.haskell.org/package/th-sccs-0.0.0.20110217 (NicolasFrisby)
12:07:38 <mauke> heh, noscript fails spectacularly on that
12:07:46 <accel> xplat: eh; 14ish ? skipped the database one though
12:08:04 <christo_m> Hi, im going to be writing a LUA compiler with Haskell using Parsec, would LUA be a good choice , i found a grammar here: http://lua-users.org/wiki/LuaGrammar
12:08:16 <christo_m> i was going to do modelica but it looked really long, and i want to minimize errors i might make 
12:08:17 <accel> why?
12:08:20 <xplat> accel: 04♥07✶08❩03♣02♦06Ω
12:08:25 <ksf> (≫=) = (>>=)
12:08:25 <ksf> (U+226B, MUCH GREATER-THAN) + (U+3D, EQUALS SIGN) 
12:08:28 <christo_m> accel: well, its for a course
12:08:28 <ksf> two characters?
12:08:32 <accel> xplat: LOL
12:08:42 <accel> xplat: i believe though, I asked specifically for a blinking gold star
12:08:48 <xplat> couldn't find a reliable way to do blinking star, so a whole bowl of lucky charms instead ...
12:08:59 <christo_m> accel: im not really new to functional programming but it's been a while (have experience with some mosml and ocaml)
12:09:18 <accel> it's funny you want to write  lua interpereter
12:09:22 <accel> lua = te reason I decided to learn haskell
12:09:25 <ksf> lua is a cool language.
12:09:28 <christo_m> Oh
12:09:31 <accel> had enough of compliated tables w/ no types
12:09:33 <christo_m> i just picked it because the grammar is short, honestly
12:09:37 <accel> it's great untill you code gets to around 5-6K LOC
12:09:44 <accel> then I'm like wtf, is this type supposed to be, and why is it nil?
12:09:45 <christo_m> ya thats the thing, type inference is the second assignment, thats going to be hard
12:09:59 <christo_m> but right now, for lexing and parsing, haskell and parsec good choice?
12:10:08 <accel> christo_m: course soudns intense; who teaches it?
12:10:22 <christo_m> http://www.cas.mcmaster.ca/~carette/
12:10:26 * ksf doesn't like parsec because you have to annotate backtracking
12:10:34 * accel loves parsec
12:10:40 * monochrom doesn't backtract
12:10:50 <accel> back tracking things = expensive; expensive things shoudl be ugly
12:11:08 <ksf> christo_m, http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators  is great
12:11:10 <monochrom> "you do or you don't, there is no backtrack"
12:11:14 <mauke> parsec is morally ugly
12:11:14 <christo_m> see i just learned about annotations like a class ago
12:11:20 <ksf> ...and has a great interface, but it hides itself.
12:11:22 <christo_m> and attribute grammars (though those arent used really anymore)
12:11:26 <xplat> i wish grammar-combinators did LR or GLL, then i would use that
12:11:46 <accel> all the worlds' data shuld ust be expressed using sexps
12:11:48 <accel> problem solved
12:11:54 <monochrom> xml
12:12:06 <accel> xml isn't human friendly
12:12:12 <christo_m> ksf: you recommend that over parsec then?
12:12:15 <hpc> xml isn't anything friendly
12:12:16 <christo_m> it looks easier to read for some reason
12:12:22 <ksf> christo_m, yes.
12:12:31 <accel> parsec made me undeststand monads
12:12:32 <monochrom> exterminate all humans
12:12:35 <accel> it formced me to reinvent state monad
12:12:38 <accel> then how to combine monads
12:12:39 <christo_m> accel: ya i want to learn what a monad is lol
12:12:44 <ksf> accel, uu-parsinglib would make you understand applicative.
12:12:58 <accel> and then suddenly, ksf gave me a gold star, with a red heart, a green three leave clover, and a purple horseshoe
12:13:01 <xplat> xml isn't bad for marking up big hunks of text, it sucks for anything else though
12:13:14 <accel> wait, I think that was xplat
12:13:15 <ksf> that was xplat
12:13:19 * accel scrolls up
12:13:25 <accel> that was xplat
12:13:43 <xplat> you forgot the yellow moon and blue diamond
12:14:03 <accel> there's millions of unicode chars, and 256 colors; why so few?
12:14:40 <monochrom> 256 colours? did accel just came here from year 1990?
12:15:01 <Entroacceptor> ...says the one called monochrom....
12:15:04 <xplat> well, you still only get 256 colours on terminals ...
12:15:27 <xplat> and that's the nice ones
12:15:43 <monochrom> even I have 16777216 levels of grey
12:15:49 <xplat> some still only have 16
12:16:13 <monochrom> teaches you to let go of terminals
12:16:19 <monochrom> @quote ray 1970s
12:16:19 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
12:16:20 <xplat> monochrom: you lie, there's no way your ramdac is that good.  i mean 4096 i could believe ...
12:16:51 <ksf> christo_m, otoh, though, lisp of course has an even simpler grammar, and I think it'd be easier to change its semantics to include hindley-milner.
12:17:10 <xplat> you'll end up with liskell98 :)
12:17:10 <christo_m> ksf: he didnt put it on his list
12:17:16 <christo_m> and i passed the date to suggest a language
12:17:29 <christo_m> this guys smarter than he looks
12:17:30 <xplat> nobody else suggested lisp either?
12:17:35 <christo_m> im not sure
12:17:37 <christo_m> its like half grad students
12:17:39 <christo_m> i feel so out of place
12:17:46 <christo_m> 12 ppl i think
12:18:24 <xplat> christo_m: they should be the ones who feel out of place, they took until grad school to get ready for this class :)
12:18:58 <christo_m> http://lua-users.org/wiki/LuaGrammar  <- is this the right grammar to use though
12:19:02 <christo_m> how do i handle multiple definitions like that
12:19:22 <christo_m> it says its in Lemon, i guess thats some other language
12:20:00 <christo_m> http://www.lua.org/manual/5.1/manual.html#8
12:20:06 <christo_m> think its that, anyway thanks ksf 
12:20:09 <christo_m> and everyone
12:21:17 <accel> christo_m: lua may be more helpful if you want lua grammar
12:24:20 <seydar> can someone explain channels to me
12:26:58 <ClaudiusMaximus> woop, sped up my program 4x by 1.memoizing and 2.exploiting symmetry
12:27:22 <ksf> christo_m, there's even a parsec grammar linked from that page
12:27:37 <seydar> ClaudiusMaximus: how do you exploit symmetry
12:27:52 <ksf> it's 5.0, but updating it should be easier than writing it from scratch.
12:28:22 <xplat> ksf: that might not exactly fit the spirit of the assignment though ...
12:29:14 <ClaudiusMaximus> seydar: in this line: if lo < 1/2 then params ! a else second conjugate (params ! angledInternalAddress (1 - lo))
12:29:22 <ksf> lua should be a charm to parse, anyway.
12:29:38 <christo_m> it looks so easssy
12:29:43 <christo_m> mind if i msg back and show you what i got
12:29:46 <ksf> as close to lisp as any language with actual grammar can be
12:29:49 <christo_m> it'll probably bad first run through
12:30:09 <seydar> ClaudiusMaximus: wat
12:30:20 <harlekin> Is there a way to tell ghc the output name of the .hi and .o file?
12:30:27 <ksf> LL(1), isn't it?
12:30:27 <seydar> ClaudiusMaximus: this is probably the last thing you want to do, but I don't know what symmetry is
12:30:32 <seydar> outside of geometry
12:30:45 <ksf> that is, just write a regex ;)
12:30:47 <xplat> LL(1) is the perfect thing for parsec
12:31:15 <ClaudiusMaximus> seydar: well, then you'll know that complex conjugate is a symmetry
12:31:27 <ksf> LL(1) is an excuse for parser writers and a bane for grammar writers
12:31:48 <ClaudiusMaximus> seydar: the program does do some geometry :)
12:32:45 <ClaudiusMaximus> seydar: and 1 - x is also a symmetry...
12:32:50 <christo_m> AH
12:32:51 <xplat> i don't like trying to fit grammars into LL(1), but whenever i have to use some combinator library to write a parser i'm glad if someone else did that for me
12:32:57 <christo_m> ksf: i have to do lexical analysis still
12:32:59 <christo_m> with Alex or something
12:33:03 <christo_m> i cant just jump into parsing can i/
12:33:20 <ksf> you can, in principle, but it's going to be dirty.
12:33:25 <seydar> ClaudiusMaximus: oh, so you actually used symmetry to improve the actual algorithm and not just the magic behind the algorithm
12:33:30 <ksf> you can use parsing combinators to lex, though.
12:34:08 <ksf> the main problem with leaving out lexing is whitespace
12:34:42 <xplat> you can even use parsing combinators to create van wijngaarden grammars, probably, but then your head asplode
12:34:46 <ClaudiusMaximus> seydar: yeah - essentially i was recomputing the same things 4x too often (they occur twice, just with different names, and there is symmetry so i can do an easier calculation to find one half from the other half)
12:34:52 <christo_m> Dammit, theyre tiger compiler is non existent
12:37:49 <ClaudiusMaximus> this 4x is only a constant factor though, it still takes O(2^n) time, which i can't fix, because that's the nature of the geometry...
12:37:52 <christo_m> i dont know if this is a good idea
12:37:59 <christo_m> ksf: i liked parsec because it does both lexing and parsing
12:38:15 <xplat> ClaudiusMaximus: O(2^n)?  :(
12:38:17 <augur> anyone familiar, REALLY familiar, with constraint satisfaction?
12:38:19 <ksf> uu-parsinglib can do that too, but if you're comfortable with parsec, use it.
12:39:03 <pozic> augur: that is not a question.
12:39:10 <christo_m> ksf: im reading the technical documantation, maybe a tad over my head 
12:39:11 <christo_m> but im trying
12:39:15 <monochrom> my parsec example is at http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
12:39:16 <xplat> christo_m: the problem with leaving out a lexer is, as mentioned, that whitepace will be EVERYWHERE in your grammar and will make you tear your hair out
12:39:18 <augur> pozic: yes it is.
12:39:25 <ksf> every haskell parser should be quite easy to use, if it's not called happy.
12:39:46 <ksf> christo_m, it's more of a tutorial on how to implement it. the source itself has examples
12:40:03 <ClaudiusMaximus> @oeis 1,1,3,6,15,27
12:40:04 <lambdabot>  Number of 2n-bead balanced binary necklaces of fundamental period 2n, equiva...
12:40:05 <lambdabot>  [1,1,1,3,6,15,27,63,120,252,495,1023,2010,4095,8127,16365,32640,65535,130788...
12:40:06 <pozic> augur: it really is an ask to ask question.
12:40:22 <augur> pozic: not if i dont have another question to ask!
12:40:23 <pozic> augur: or do you want to hire a consultant?
12:40:29 <interferon> is it fair to say that the only special forms in haskell are seq and error?
12:40:34 <xplat> ksf: btw does uu-parsinglib handle actual strings or only [Char]?
12:40:55 <augur> pozic: its more that im looking for someone i can bug in /msg, since i dont want to bog down the channel with non-haskell stuff.
12:41:07 <mauke> interferon: I don't think they're special forms
12:41:08 <xplat> interferon: the special forms are let and case
12:41:10 <pozic> augur: so, then you should have asked that. 
12:41:22 <xplat> and maybe ::
12:41:30 <interferon> mauke: in that they can't be implemented by the user using just function application and pattern matching
12:41:32 <augur> pozic: i did!
12:41:35 <ksf> xplat, String *is* [Char]
12:41:47 <mauke> interferon: that's not what I'd call "special forms"
12:41:50 <xplat> ksf String is, but strings aren't
12:42:01 <interferon> you guys are talking about syntax
12:42:01 <monochrom> pozic's point is made and augur gets it.
12:42:12 <interferon> i'm talking about exceptions to the rules of evaluation
12:42:19 <augur> monochrom: im going to bug you now, just for fun.
12:42:46 <mauke> interferon: seq a b = const b $! a
12:42:46 <christo_m> whats with <$>
12:43:06 <interferon> mauke: then it's $!
12:43:07 <mauke> interferon: error _ = undefined
12:43:23 <mauke> interferon: f $! x = seq x (f x)
12:43:33 <ksf> xplat, the answer is yes, but it doesn't come with pre-built instances for that.
12:43:40 <mauke> interferon: I think seq follows the normal rules of evaluation
12:43:45 <interferon> mauke: :) i don't think that recursion terminates
12:43:48 <christo_m> oh i see, union
12:43:55 <interferon> christo_m: not necessarily
12:44:08 <ksf> <$> is $ in a Functor.
12:44:13 <ksf> or over a functor.
12:44:26 <xplat> seq !a b = b
12:44:29 <ksf> it's infix fmap.
12:44:43 <ksf> > (+1) <$> [1,2]
12:44:44 <lambdabot>   [2,3]
12:45:08 <ksf> > (+1) <$> [(+3), (*5)] <*> [1,2]
12:45:09 <lambdabot>   [5,6,6,11]
12:45:56 <christo_m> i cant even parse that
12:46:05 <ksf> > [(+3), (*5)] <*> [1,2]
12:46:06 <lambdabot>   [4,5,5,10]
12:46:23 <christo_m> okay
12:46:23 <christo_m> ya
12:46:24 <xplat> > (+) <$> [1,2] <*> [0,4]
12:46:25 <lambdabot>   [1,5,2,6]
12:46:40 <christo_m> yaya definetely got that
12:46:47 <christo_m> okay so + means what it means when its in paranthesis or []
12:46:50 <christo_m> actually [] is a list
12:46:51 <christo_m> okay
12:47:03 <christo_m> i got it, expressions and lists, unionating and being applied
12:47:11 <ksf> ...now replace [] with the parser type.
12:47:23 <pozic> christo_m: there is no need to understand that. It's obfuscation. 
12:47:30 <christo_m> pozic: what do you suggest lol
12:47:56 <ksf> so you have something like "Definition <$> (ident <$ char '=') <*> expr" 
12:48:06 <pozic> christo_m: the operators have a meaning for parsers, and that meaning is fairly useful. To apply the operators on lists is just confusing.
12:48:18 <ksf> ...provided data Definition = Definition Identifier Expression
12:48:51 <ksf> Monad [a] is more confusing.
12:49:42 <christo_m> ksf: sorry can you use an aexample
12:49:45 <christo_m> for example exp in the LUA grammar
12:49:51 <christo_m> exp ::=  nil | false | true | Number | String | `...´ | function | prefixexp | tableconstructor | exp binop exp | unop exp
12:50:03 <christo_m> its like, calling exp inside itself
12:50:06 <christo_m> recursive datatypes?
12:50:18 <gwern> > 1/500 * 20^(-1.5) + 1/3000
12:50:19 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:50:19 <lambdabot>    `GHC.Real.Fractional b'
12:50:19 <lambdabot> ...
12:50:25 <gwern> > 1/500 * 20^(-(1.5)) + 1/3000
12:50:26 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:50:26 <lambdabot>    `GHC.Real.Fractional b'
12:50:26 <lambdabot> ...
12:50:35 <gwern> > (1/500 * 20^(-(1.5))) + 1/3000
12:50:35 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:50:36 <lambdabot>    `GHC.Real.Fractional b'
12:50:36 <lambdabot> ...
12:50:38 <gwern> argh
12:50:46 <christo_m> ?
12:51:00 <ksf> christo_m, haskell's ADTs can be recursive.
12:51:23 <christo_m> dont you mean AST's? (abstract syntax tree)
12:51:25 <christo_m> whats D?
12:51:34 <ksf> Expr = Expr `And` Expr | Exrp `Plus` Expr | Var String
12:51:47 <ksf> s/^/data/
12:51:52 <ksf> abstract data type
12:51:54 <mauke> algebraic
12:51:59 <ksf> yeah.
12:52:13 <gwern> > (1/500 * 20**(-(1.5))) + 1/3000
12:52:14 <lambdabot>   3.556940131083312e-4
12:52:18 <gwern> there we go
12:52:21 <kulakowski> interferon: Would irrefutable patterns would count for what you were asking earlier about specially evaluated forms? It's hard to say without knowing exactly what you meant.
12:52:29 <gwern> > ((1/500 * 20**(-(1.5))) + 1/3000) * (20*365.25)
12:52:30 <lambdabot>   2.598344765756359
12:52:33 <ksf> ...consisting of product types (ie. like tuples), sum types (the | part) and recursion.
12:52:38 <christo_m> ksf: okay so, you're syntax there looks different than before
12:52:47 <christo_m> what about the <$> now dont they have to be in there ?
12:52:57 <interferon> kulakowski: i guess i'm asking which combinators can't be implemented with just function application and pattern application
12:53:06 <ksf> the Expr thing was a data type definition.
12:53:11 <christo_m> right
12:53:13 <interferon> kulakowski: as in the original lisp, there were seven special forms and everything else was a macro or function
12:53:19 <christo_m> right, thats how you define types?
12:53:20 <ksf> the line with the <$> was a parsing function.
12:53:22 <christo_m> like enum almost right?
12:53:37 <interferon> kulakowski: and the only operators i can think of that i couldn't implement myself without help from the implementation are seq and error
12:54:22 <pozic> interferon: seq can be faked and error = error is theoretically the same. 
12:54:32 <roconnor> @type let error x = error (""+x) in error
12:54:33 <lambdabot>     No instance for (Num [Char])
12:54:33 <lambdabot>       arising from a use of `+' at <interactive>:1:21-24
12:54:33 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
12:54:38 <roconnor> @type let error x = error (""++x) in error
12:54:39 <lambdabot> forall t. [Char] -> t
12:54:44 <interferon> pozic: well, but error = error never terminates. Prelude.error stops immediately with a message
12:54:59 <mauke> what, do you mean error = error never terminates?
12:55:01 <pozic> interferon: yes, but that's not the semantics of error, AFAIK. 
12:55:01 <interferon> gotta have the implementation help with that
12:55:03 <mauke> it raises an exception
12:55:12 <interferon> mauke: only when the stack overflows
12:55:22 <ksf> christo_m, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
12:55:27 <interferon> mauke: try it
12:55:35 <roconnor> if error = error causes a stack overflow, you have a crappy haskell implementaiton.
12:55:56 <mauke> interferon: a.out: <<loop>>
12:56:22 <interferon> roconnor: right, not strictly a stack overflow
12:56:32 <interferon> roconnor: point is, it's not immediate termination like Prelude.error
12:56:46 <interferon> roconnor: not *at all* a stack overflow :)
12:56:53 <roconnor> as mauke notes it does cause immediate termination in many implemenations
12:56:56 <mauke> interferon: ...
12:57:08 <interferon> i mean, not in ghci
12:57:12 <interferon> i just tried it
12:57:19 <interferon> is the behavior in ghc different?
12:57:24 <mauke> interferon: try it
12:57:27 <christo_m> ksf: i feel like i can just prepend the keyword "data" to the LUA grammar on thes ite lol
12:57:36 <roconnor> mauke: ghc --version ?
12:57:37 <taotree> cabal install time results in segfault   http://hpaste.org/44094/time_segfault
12:57:38 <xplat> error = error is tail-recursive
12:57:47 <mauke> roconnor: 6.10.2
12:57:49 <roconnor> xplat: tail-recursion is irrelevent in haskell
12:57:53 <ksf> christo_m, modulo some lists, yes.
12:57:56 <xplat> and in a very strong sense
12:58:15 <xplat> it doesn't create any new continuations when you force it either
12:58:22 <christo_m> ksf: modulo some lists?
12:58:22 <ksf> well, you could probably do without lists, but your AST would be a bugger to work with
12:58:42 <xplat> roconnor: tail-recursion in the usual sense is, yes
12:59:10 <ksf> e.g. data Stmt = For Ident [Expr] Block
12:59:23 <ksf> no that's a bad examlpe.
12:59:29 <xplat> maybe there should be a separate word for the kind that matters, but i'm not aware of such a word
12:59:55 <christo_m> ksf: i have to do something about the braces
13:00:00 <christo_m> i dont think haskell uses braces
13:00:09 <roconnor> there is no stack push when you enter a function in haskell.
13:00:09 <ksf> what I mean is that you will want to use haskell lists instead of saying VarList = Var String VarList | VarListNil
13:00:13 <christo_m> thats what you mean by continuation?
13:00:18 <xplat> haskell uses a lot of braces
13:00:20 <christo_m> okay
13:00:26 <xplat> although usually most of them are invisible
13:00:58 <xplat> the only braces that can't go invisible are the ones in record syntax
13:01:14 <monochrom> > let { x=1; y=2 } in x+y
13:01:15 <lambdabot>   3
13:01:18 <ksf> I'm not sure what's meant by those braces in the BNF
13:01:38 <ksf> oooh, repetition.
13:01:46 <roconnor> christo_m: haskell's 2-D layout is syntactic sugar for braced expressions.
13:03:00 <christo_m> see im still confused about recursive data structures
13:03:01 <christo_m> going to read
13:03:13 <christo_m> because var list again, makes a definition for var twice
13:03:29 <christo_m> maybe i need to have an "atom" defined, because i want to choose between left or right recursion there ??
13:04:04 <xplat> roconnor: yes, the stack push happens later, when you force the function's result to WHNF.  error = error doesn't need that stack push either.
13:04:38 <roconnor> xplat: in GHC a stack push happens when you enter a case expression.
13:04:57 <pozic> christo_m: which other programming experience do you have?
13:05:16 <roconnor> xplat: perhaps that is the same as what you said.
13:05:44 <xplat> roconnor: modulo some probably-irrelevant details, yes
13:08:08 <taotree> Grr... cabal weirdness:  cabal: dependencies conflict: ghc-6.12.3 requires array ==0.3.0.2 however
13:08:08 <taotree> array-0.3.0.2 was excluded because ghc-6.12.3 requires array ==0.3.0.1
13:08:21 <christo_m> pozic: mostly with java and C
13:08:31 <christo_m> pozic: i have a small knowledge of mosml and ocaml, mostly from school
13:09:37 <pozic> christo_m: in Java, how do you build a linked list?
13:09:56 <silver> new LinkedList<>();?
13:10:13 <pozic> Did they finally implement that?
13:10:24 <pozic> When I used Java, there were no singly linked lists.
13:10:37 <xplat> i think it's a doubly-linked list
13:10:53 <pozic> Ok, so how do you build a singly linked list without any libraries?
13:11:17 <pozic> (christo_m is supposed to answer that)
13:12:03 <silver> :-)
13:13:59 <jacobian> @pl (\ acc t -> (acc+1,(PointerTag:t))
13:13:59 <lambdabot> (line 1, column 35):
13:13:59 <lambdabot> unexpected end of input
13:14:00 <lambdabot> expecting variable, "(", operator or ")"
13:14:06 <jacobian> @pl (\ acc t -> (acc+1,(PointerTag:t)))
13:14:07 <lambdabot> (. (PointerTag :)) . (,) . (1 +)
13:15:08 <monochrom> taotree: could you show me outputs of "ghc -v" and "ghc-pkg list -v"?
13:15:15 <christo_m> pozic: ya i did it in C++
13:15:18 <christo_m> and in C
13:15:44 <christo_m> i wouldnt use java for that personally, because i like dealing with pointers in C/C++
13:16:11 <christo_m> but usually id have 2 classes, one for the actualy list of some generic type (templates used here)
13:16:32 <christo_m> and the other for the actual data item in it, then each data item would have a pointer to the next one, (and the previous one if i want double linked)
13:16:51 <christo_m> id have a pointer in the list class for the head and tail
13:19:09 <pozic> christo_m: so, that would _also_ be a recursive type.
13:19:52 <Algo> gooooooooooo haskell!
13:20:55 <pozic> christo_m: do you get it now?
13:21:02 <christo_m> pozic: one moment
13:21:16 <christo_m> ksf was right, i should use the native types as much as possible
13:21:23 <christo_m> im trying to declare a list lmao, i cant find how to do it explicitly
13:21:44 <christo_m> varlist ::= var {`,´ var} for this grammar
13:21:51 <christo_m> other var?
13:21:59 <christo_m> sorry, i either have a var, or a comma followed by another var?
13:22:27 <pozic> christo_m: which grammar is that?
13:22:46 <pozic> christo_m: and it seems to have nothing to do with you not understanding recursive types in Haskell.
13:22:49 <monochrom> I'll just show you a few examples. var. var,var. var,var,var.
13:23:01 <Lambdanewb> hey guys can anyone pls tell me whats wrong with this picture
13:23:01 <christo_m> pozic: i know , thats another problem, one at a time i guess
13:23:02 <Lambdanewb> splitAt' :: Int -> [a] -> ([a],[a]) splitAt' 0 x = ([],x) splitAt' _ [] = ([],[]) splitAt' p (x:xs) = (x:splitAt' p-1 xs,xs)
13:23:05 <christo_m> pozic: grammar for LUA
13:23:26 <monochrom> If you know regex's *, pretend you see varlist ::= var (`,´ var)*
13:23:53 <pozic> christo_m: yes, one at a time. You cannot solve two high level tasks in parallel. You are not a computer. 
13:24:16 <christo_m> maybe im threading
13:24:27 <christo_m> but right, i should use semaphores
13:24:33 <christo_m> because im trying to access the critical section 
13:24:43 <taotree> monochrom, I think I have an idea... I see that it's trying to install versions of packages that according to hackage were built on ghc 7, but I'm using ghc 6.12.3.
13:25:04 <christo_m> monochrom: i actually never learned regexp outside of the automata definition
13:25:08 <taotree> So, I'm not checking the ghc version in hackage when I run into these things and install a version that is not ghc7 only
13:25:16 <taotree> s/not//
13:25:43 <taotree> the first not... I am checking now--wasn't before
13:38:52 <Lambdanewb> so can anyone say whats wrong with this code:     splitAt' :: Int -> [a] -> ([a],[a]) splitAt' 0 x = ([],x) splitAt' _ [] = ([],[]) splitAt' p (x:xs) = (x:splitAt' (p-1) xs,xs)
13:39:31 <Lambdanewb> I get the following error
13:39:32 <Lambdanewb>     Couldn't match expected type `[a]'            against inferred type `([a], [a])'     In the second argument of `(:)', namely `splitAt' (p - 1) xs'     In the expression: x : splitAt' (p - 1) xs     In the expression: (x : splitAt' (p - 1) xs, xs)
13:40:32 <mauke> Lambdanewb: the error is obvious to me
13:40:44 <mauke> it complains about splitAt' (p - 1) xs having the wrong type
13:41:04 <mauke> it knows that splitAt' returns ([a], [a])
13:41:13 <mauke> but (x :) expects [a]
13:41:26 <mauke> :t (:)
13:41:27 <lambdabot> forall a. a -> [a] -> [a]
13:41:50 <Lambdanewb> oh I see
13:41:52 <litb> :t ('A':)
13:41:53 <lambdabot> [Char] -> [Char]
13:42:17 <Lambdanewb> how can I do that with a tupples instead of a list then
13:42:19 <Lambdanewb> ?
13:44:09 <Lambdanewb> maybe something like x:fst splitAt' (p-1) xs
13:44:48 <Lambdanewb> nope
13:45:16 <Lambdanewb> was missing the ()
13:45:16 <Lambdanewb> x
13:45:18 <Lambdanewb> xD
13:46:37 <litb> hmm
13:47:09 <Lambdanewb> splitAt' p (x:xs) = (x:fst (splitAt' (p-1) xs), snd (splitAt' (p-1) xs))
13:47:12 <Lambdanewb> now it works
13:47:13 <Lambdanewb> xD
13:47:16 <Lambdanewb> thanks guys
13:50:10 <accel> yo; after 72 hours
13:50:25 <accel> i just finished my txt -> LaTeX markup language
13:50:28 <accel> written in pure haskell
13:50:32 <accel> just wanted to thanks
13:50:39 <christo_m> dammit
13:50:41 <christo_m> lol
13:50:42 <accel> to all those bored people (with nothing better to do in life) that answered all my questions
13:50:49 <accel> I really apprecaite your help :-)
13:51:21 <Twey> Pandoc? ;)
13:53:21 <christo_m> dude dont ruin it for eveyrone man
13:53:32 <christo_m> i still cant implement varlist hows thata hah
13:56:42 <christo_m> http://www.lua.org/manual/5.1/manual.html#2.4.1  can someone explain
13:56:43 <monochrom> varlist = var `sepBy1` comma
13:56:49 <christo_m> the {}
13:56:55 <christo_m> im so screwed for this its not funny
13:57:09 <christo_m> sepBy1 , isnt that parsec
13:57:14 <christo_m> im using uuparsing lib now
13:57:26 <monochrom> same {} as you saw before.  chunk ::= (stat [`;`])*
13:58:11 <christo_m> i dont know what the paranthesis means
13:58:18 <christo_m> do you mean by * union?
13:58:30 <monochrom> * is repetition
13:58:50 <monochrom> () is just mathematical parentheses, i.e., helps you read
13:59:06 <monochrom> or s/helps you read/disambiguates how to read/
14:00:22 <christo_m> and what would i use for repetition in haskell
14:00:25 <christo_m> how will it know
14:00:35 <christo_m> data chunk = (stat [';'])* is enough?
14:01:14 <monochrom> depends on parser lib. in parsec I write (many (...)). I don't know uuparsing.
14:01:49 <christo_m> ya i should use parsec
14:02:06 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-150002.1
14:02:25 <monochrom> lua seems to use the same convention for [], {}
14:03:08 <monochrom> oh well maybe that confuses more than clarifies. I don't know how to communicate with you.
14:07:53 <christo_m> monochrom: well, you,'re doing a good job so far
14:07:55 <christo_m> sincerely
14:09:06 * hackagebot wikipedia4epub 0.0.7 - Wikipedia EPUB E-Book construction from Firefox history.  http://hackage.haskell.org/package/wikipedia4epub-0.0.7 (RadoslavDorcik)
14:09:29 <ocharles> Is it good or bad practice to explicitly mention type signatures everywhere in your code?
14:09:40 <ocharles> or indifferent?
14:09:43 <mauke> depends on your definition of "everywhere"
14:10:12 <ocharles> as everywhere as https://github.com/portnov/pandoc/blob/21f32c329512623ebcba6a7a5255d67f1921dcf8/src/Text/Pandoc/Definition.hs
14:10:27 <ocharles> maybe not the best example file
14:10:38 <monochrom> I give type sigs to exported things to help haddock. unexported things I go with my heart.
14:10:57 <mauke> I put a type signature on all top-level bindings (by default)
14:11:00 <ocharles> so public api stuff you give sigs for?
14:11:20 <monochrom> if haddock were smarter, I would even skip those.
14:11:25 <lispy> I put type sigs on all top-level bindings and frequently to functions defined in where blocks
14:11:40 <ocharles> is this for aesthetics, or practicalities?
14:11:49 <monochrom> a balance of both
14:11:54 <lispy> I find that typing the type signature helps me to write the definition, an if I'm going to type it out, I might as well keep ti
14:12:17 <ocharles> interesting
14:12:22 <lispy> ocharles: think of types as machine checkable documentation
14:12:28 <monochrom> general haskell style guide: go with your heart. you will be surprised that it is a pretty tight constraint.
14:12:34 <ocharles> for me I'm still at the stage where I'm throwing things together a little haphazardly
14:12:55 <ocharles> lispy: yea, I can see type sigs as an assertion for stuff that's exported as "this is the api, and I won't change it"
14:13:30 <ocharles> on a more general question, I dunno how you guys do namespacing here, but what would be an appropriate namespace for my bindings to Xapian? (a text search engine)
14:13:47 <ocharles> well, indexing/database/search library, that is
14:14:03 <ksf> Text.Xaipan sounds fine
14:14:35 <ksf> parsers etc. are all under Text, even if you can use them for something different
14:14:39 <ocharles> Not Search. or Text.Search. ? I'd have thought the 'search' bit is more important than the 'text' bit
14:15:17 <ocharles> ksf: right, but it's more a database approach - it creates a physical store and queries that, it's not just operating on text entirely
14:15:21 <ksf> Database might be good, too.
14:15:47 <ksf> Database.Xaipan or Database.Text.Xaipan
14:15:49 <lispy> ocharles: you might checkout similar libraries to see what they do
14:15:55 <ocharles> lispy: I can't find any :)
14:16:03 <ocharles> no bindings for lucene or ferret, anyway
14:16:13 <ksf> though all those SQL things in takusen aren't in Database.SQL.*, either.
14:16:32 <lispy> ocharles: Sometimes #haskell is the wrong place to get this stuff answered.  For some questions it helps  to write up what you're planning to do then email haskell-cafe or haskell-beginners asking for feedback
14:16:51 <ocharles> lispy: good advice. I need to get round to subscribing to the cafe soon
14:17:44 <ksf> in Xaipan's case I'd even say Search.Xaipan
14:17:57 <ksf> as in Search.Hoogle etc.
14:18:18 <ksf> ...Hoogle doesn't live in Search, but it arguably should.
14:18:29 <ocharles> Search.Xapian was my first choice, yea
14:21:56 <kevinburke> has anyone here used lex?
14:22:00 <kevinburke> excuse me alex?
14:24:12 * hackagebot wikipedia4epub 0.0.8 - Wikipedia EPUB E-Book construction from Firefox history.  http://hackage.haskell.org/package/wikipedia4epub-0.0.8 (RadoslavDorcik)
14:36:17 * hackagebot happstack 6.0.0 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.0.0 (JeremyShaw)
14:36:19 * hackagebot happstack-data 6.0.0 - Happstack data manipulation libraries  http://hackage.haskell.org/package/happstack-data-6.0.0 (JeremyShaw)
14:36:21 * hackagebot happstack-hamlet 6.0.0 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.0.0 (JeremyShaw)
14:36:23 * hackagebot happstack-heist 6.0.0 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-6.0.0 (JeremyShaw)
14:36:25 * hackagebot happstack-hsp 6.0.0 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.0.0 (JeremyShaw)
14:37:28 * hackagebot happstack-hstringtemplate 6.0.0 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-6.0.0 (JeremyShaw)
14:37:30 * hackagebot happstack-ixset 6.0.0 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/happstack-ixset-6.0.0 (JeremyShaw)
14:37:32 * hackagebot happstack-plugins 6.0.0 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.0.0 (JeremyShaw)
14:37:34 * hackagebot happstack-server 6.0.0 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.0.0 (JeremyShaw)
14:37:36 * hackagebot happstack-state 6.0.0 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-6.0.0 (JeremyShaw)
14:38:38 * hackagebot happstack-util 6.0.0 - Web framework  http://hackage.haskell.org/package/happstack-util-6.0.0 (JeremyShaw)
14:38:44 <mercury^_> wtf...
14:41:51 <stepkut>  mercury^_: ?
14:48:30 <mercury^_> stepkut: I was bewildered by all the hackage spam.
14:49:16 * edwardk waves hello.
14:49:29 <sm> happstack 6.. congrats stepcut 
14:49:33 <stepkut> mercury^_: new happstack release. Bumped the version on all the packages
14:49:44 <stepkut> mercury^_: http://www.reddit.com/r/haskell/comments/fnit9/haskell_web_framework_happstack_6_released/
14:50:00 <geheimdienst> congrats on the release
14:50:25 <mercury^_> stepkut: Yes, I realised that. I still think it is suboptimal for the bot to print all those messages. Oh and, congratulations. :)
14:50:37 <stepkut> mercury^_: thanks :)
14:50:54 <stepkut> mercury^_: once I release happstack-ircbot we can fix those bot problems ;)
14:51:47 <christo_m> so would i use data keyword
14:51:50 <christo_m> to make my own types
14:51:52 <christo_m> or use parsec somehow like
15:01:29 * hackagebot email 0.1 - Sending eMail in Haskell made easy  http://hackage.haskell.org/package/email-0.1 (JohannesWeiss)
15:03:43 <christo_m> im so screwed
15:03:48 <christo_m> the lua parser this other guy wrote
15:03:49 <christo_m> is actually long
15:03:51 <christo_m> i didnt think it would be this much
15:04:30 * hackagebot wikipedia4epub 0.0.9 - Wikipedia EPUB E-Book construction from Firefox history.  http://hackage.haskell.org/package/wikipedia4epub-0.0.9 (RadoslavDorcik)
15:05:23 <cwillu_at_work> stab
15:06:37 <cwillu_at_work> gwern, so is there where you bring me to dumbledore to make it official?
15:06:56 <gwern> cwillu_at_work: dumbledore does like men, 'tis true
15:07:00 <Tomsik> Gandalf > Dumbledore
15:07:23 <cwillu_at_work> Tomsik, MoR!Dumbledore > Gandalf
15:07:40 <cwillu_at_work> he even says so
15:07:47 <Tomsik> MoR?
15:07:58 <cwillu_at_work> gwern, you've been derelict in your duties I see
15:08:16 <cwillu_at_work> Tomsik, http://www.fanfiction.net/s/5782108/
15:08:18 <gwern> cwillu_at_work: there are only 36 hours in the day you know
15:08:21 <gwern> can't be everywhere
15:09:14 <JoshTriplett> I remember using a GHC extension before that allowed me to make a partially applied type synonym an instance of a class.  However, I can't seem to find the details on how.  Could someone point me in the right direction?
15:11:19 <geheimdienst> gwern: what planet you on?
15:11:40 <gwern> geheimdienst: it was a MoR joke. it's not *for* you
15:13:17 <blackdog> gwern: curses, still at part 4 of self-actualisation? it's been forever!
15:13:44 <cwillu_at_work> gwern, I think you managed to miss that joke
15:13:47 <gwern> blackdog: them's the breaks. consider this an opportunity to register predictions about when the next one will come out, to calibrate yourself
15:14:39 <blackdog> gwern: it's a slightly less rational model, perhaps more akin to the rat tappingfor cocaine.
15:15:05 <gwern> blackdog: eliezer has implored everyone to use rss or sign up for email. don't blame him
15:15:30 <blackdog> gwern: that's the worst thing - I _have_ registered for RSS
15:15:48 <blackdog> i think some part of me thinks that there mightbe special magic updates that only the web-viewers will see
15:15:53 <blackdog> magical thinking etc
15:16:14 <lostman> epollControl: permission denied ;-(
15:16:19 <lostman> what could be causing that?
15:17:02 <cwillu_at_work> blackdog, the rss feed is generated by polling the website
15:17:02 <lostman> I just compiled my program with ghc7 head and it refuses to do threading
15:18:51 <robryk1> lostman: what system are you on?
15:19:34 <blackdog> cwillu_at_work: i said it was magical thinking :)
15:19:37 <mm_freak> there should be a variant of ($) with a higher priority than (>>=)
15:19:39 <lostman> robryk: gentoo x64
15:19:53 <cwillu_at_work> blackdog, I'm fixing you.
15:19:54 <Adamant> I have no idea what the hell you guys are talking about other that it probably involves the Less Wrong guy
15:20:02 * cwillu_at_work giggles
15:20:26 <blackdog> cwillu_at_work: how's fixing people working out for you? :)
15:20:30 <sm> does anyone remember the name of that haskell tool announced this year that figures out balanced finances for a group of people ?
15:20:45 <cwillu_at_work> blackdog, quite well, thankyou
15:21:00 <Adamant> you know, being clever
15:21:11 <Adamant> how's that working out for you?
15:21:13 <cwillu_at_work> blackdog, in most cases, the trick is not letting them know you're doing it (including such things as overtly directing their behaviour, etc)
15:21:13 <geheimdienst> Adamant: i think i understand that there is a "Harry Potter and the Methods of Rationality", possibly even written by Less Wrong Guy
15:21:43 <Adamant> geheimdienst: does it recognize rationality worship as a particularly annoying religion?
15:21:50 <blackdog> Adamant: we make soap. sell their fat asses back to them.
15:22:12 <robryk> lostman: sorry, no idea besides that EPERM from epoll_ctl means that one tries to monitor a file descriptor which doesn't support it
15:22:24 <gwern> are dependent type languages not turing-complete?
15:22:41 <robryk> and, given it works somewhere, i do not see why something like this should be different on x64
15:22:41 <geheimdienst> it has chapter headings like "A Day of Very Low Probability" and "Comparing Reality to its Alternatives" and "Hold Off on Proposing Solutions"
15:22:45 <geheimdienst> a fun read, no doubt
15:22:50 <gwern> sm: I didn't know we had a accounting tool besides hledger
15:23:14 <sm> gwern: there's umm , but this was another one
15:23:15 <cwillu_at_work> geheimdienst, if you haven't had at least one giggling fit in the first three chapters, it's probably not for you
15:23:25 <sm> should be in hackage Finance, but isn't
15:23:44 <lostman> robryk: what is epollControl anyway? haven't seen that before
15:24:36 <robryk> i presume it is a name for epoll_ctl
15:24:59 <robryk> which is a syscall for adding/removing fds from a set of fds monitored by epoll
15:26:18 <lostman> sigh... hate obscure problems like that... I'll try recompiling with ghc-7.0.1 and see if that'll help
15:27:28 <christo_m> http://www.lua.org/manual/5.1/manual.html#2.4.1
15:27:33 <christo_m> how would i implement stat
15:27:46 <christo_m> i guess i need 11 different definitions for it
15:28:18 <luite> lostman: you might want to try a recent snapshot of ghc 7.0, there were some problems with the io manager in 7.0.1
15:28:32 <JoshTriplett> How can I write the type (, b) ?
15:28:41 <JoshTriplett> Without a newtype?
15:28:53 <JoshTriplett> I need something of kind * -> *.
15:29:08 <sipa> dont think you can
15:29:09 <JoshTriplett> I can write "(,) a", and that gets me (a,), but I need (,b).
15:29:09 <ksf> ((,) b)
15:29:11 <ksf> er no.
15:29:18 <JoshTriplett> ksf: :)
15:29:24 <ksf> we don't have type-level lambda or flip.
15:29:26 <JoshTriplett> sipa: Any particular reason?
15:29:37 <JoshTriplett> ksf: I understand why not lambda, but why not flip?
15:29:46 <ksf> hmmm. type families.
15:30:45 <lostman> luite: ok, I'll give it a go
15:31:07 <ksf> type family Flip (t :: * -> * -> *) :: * -> * -> *; type instance Flip (a,b) = (b, a) 
15:31:21 <ksf> then use Flip (,) b
15:31:42 <JoshTriplett> ksf: That sounds promising.  I'll try that.
15:32:01 <shachaf> What about the type (-> b)?
15:32:20 <ksf> define another instance.
15:32:42 <JoshTriplett> In theory you could write an instance which took the constructor as a parameter, couldn't you?
15:32:44 <ksf> I'd be surprised if the thing can be generalised.
15:32:49 <JoshTriplett> ksf: Oh?  Why not?
15:33:02 <ksf> because I might be wrong and you right...
15:33:26 <JoshTriplett> I meant, did you have any particular reason to think generality wouldn't work? :)
15:33:34 <ksf> type family Flip2 (t :: * -> * -> *) a b ::  *; type instance Flip t a b = t b a 
15:33:46 <ksf> yeah, mind-tilt.
15:34:21 <ksf> type families can be curried
15:34:37 <JoshTriplett> ksf: That's part of what I need, since type aliases alone don't seem to allow that.
15:34:49 <JoshTriplett> Hmmm, syntax error.
15:34:53 <JoshTriplett> test.hs:3:36: parse error on input `::'
15:34:59 <JoshTriplett> for your Flip type family.
15:35:04 <ksf> -XTypeSignatures?
15:35:22 <JoshTriplett> You mean KindSignatures?
15:35:27 <ksf> yeah
15:35:29 <JoshTriplett> Have it.
15:37:11 <ksf> type family Flip (t :: * -> * -> *) a b :: * ; type instance Flip t a b = t b a ; type Tup a b = Flip (,) a b
15:37:48 <ksf> but that *can't* be curried as Flip results in *.
15:39:27 <ksf> I guess you have to just deal with multiple instances
15:39:36 <ksf> *live
15:44:33 <Philonous> Can I find out whether there is a package on hackage that uses CC-delcont?
15:45:50 <ksf> yep, there's reverse dependency-capable hackages
15:45:53 <parcs> Philonous: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/CC-delcont-0.2
15:45:56 <ksf> (somewhere on the net)
15:46:37 <Philonous> parcs: Great, thanks
15:47:30 <Philonous> Ah, silly, nobody seems to use it, really.
16:11:56 <wavewave> anyone knows how to link 64 bit FFI library in haskell on Mac OS X?
16:12:36 <blackdog> wavewave: first you need a 64 bit ghc
16:12:38 <wavewave> I got an error like file is not of required architecture... when I ghc .. 
16:12:50 <blackdog> on mac os x, you need to install ghc from macports
16:12:54 <blackdog> it has a bunch of patches on it
16:13:11 <blackdog> you can then use that to compile 7.0.1, should you want to, and it'll then make x86_64 binaries
16:13:32 <blackdog> ... or you could just use the macports one. it's 6.12.3, though.
16:13:34 <wavewave> Thanks, blackdog: is it possible to use homebrew?
16:13:38 <blackdog> wavewave: no.
16:13:48 <wavewave> I am now using 6.12.3
16:13:50 <blackdog> :) i mean, you could port the patches if you're feeling industrious.
16:13:54 <blackdog> i like homebrew better too
16:14:09 <blackdog> but i was just using it to bootstrap 7.0.1 anyway.
16:14:28 <wavewave> hmm I alreadys setup too much.. changing to macport is ....
16:14:36 <kulakowski> blackdog, wavewave: I'm currently building/fixing all packages under homebrew for the upcoming refactor, and that's on my todo list.
16:14:56 <wavewave> kulakowski: great!
16:16:14 <kulakowski> wavewave: Not sure if it'll be in the official repo, because they have very odd standards about upstream patches. But I'll make a note to let you to know once I do.
16:16:24 <blackdog> kulakowski: fantastic. thanks.
16:17:13 <blackdog> kulakowski: perhaps submit patches to ghc dev? someone's got to do it, might as well do it at source
16:17:39 <blackdog> Igloo's pretty good about taking patches so long as you don't break it for anyone else;)
16:17:55 <kulakowski> blackdog: Yeah.
16:20:27 <wavewave> hmm anyway, since i need to use this urgently... I had better recompile my other c++ program in 32 bit mode.. 
16:21:45 <wavewave> what is an ordinary option for forcing 32bit mode compilation in "configure"?
16:22:43 <ikeg> Ann: patches for GOA (lambdabot on GHCi) for the recent ghc : https://github.com/IKEGAMIDaisuke/goa : http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid 
16:29:57 <wavewave> okay found the option.. just read README. :)
16:30:45 <ikeg> It's a light hack : https://github.com/IKEGAMIDaisuke/goa/blob/master/goa-3.0.2.patch
16:31:13 <mm_freak> is it possible to assign "futures" to an iteratee without having to write a wrapper monad?  background:  i'm writing a library for line-oriented network protocols, and it has a 'netLine' function, which reads one line with a given maximum length…  if the length is exceeded, the rest of the line is discarded in constant memory
16:31:54 <ikeg> The original GOA is great, but, I missed the one on hackageDB doesn't work recently : http://hackage.haskell.org/package/goa
16:31:58 <mm_freak> problem is:  netLine will not return the prefix of the line, until a whole line has been read…  it would be better, if i could say:  when calling netLine again, first read the current line to its end
16:32:41 <mm_freak> or actually the /last/ line
16:34:23 <ksf> @pl \x y -> x + 1 == y
16:34:23 <lambdabot> (==) . (1 +)
16:37:45 <christo_m> ksf: wanna help me with this buddy
16:37:46 <christo_m> haha
16:41:57 <christo_m> is it enough to write data Unop = Minus | Not
16:42:06 <christo_m> if its unop = '-' | not for example
16:45:38 <monochrom> yes
16:45:50 <christo_m> monochrom: why is that, haskell knows what Minus is?
16:46:08 <christo_m> what about '#' can i write Hash or osmething
16:46:09 <monochrom> no, haskell doesn't know. but you know.
16:46:13 <christo_m> oh okay
16:46:19 <christo_m> right
16:46:32 <christo_m> what if minus is a unary operation and a binary operation
16:47:05 <monochrom> presumably you can another data type for binop, and it has the binary minus
16:47:10 <monochrom> s/can/have/
16:47:42 <monochrom> and presumably when you parse, you already make up your mind whether you're seeing binary minus or unary minus
16:48:16 <monochrom> the whole point of writing an interpreter/compiler is that the computer doesn't know, but you know.
16:48:28 <monochrom> in fact the whole point of writing a program at all
16:48:42 <christo_m> i gues im just still confused about th process
16:48:47 <christo_m> you dont understand, its the first time this guy has taught the course
16:48:49 <monochrom> if the computer knows, it no longer needs you.
16:48:51 <christo_m> and he says he alwasy makes it too hard
16:49:18 <christo_m> to my knowledge
16:49:28 <christo_m> im scanning, lexing, parsing, then i compose an AST from the info i collect
16:49:37 <christo_m> then i have to do the type system etc
16:49:57 <christo_m> ive learned about LL and LR, 
16:50:32 <monochrom> the lua grammar seems to be written to easily fit LL
16:51:18 <christo_m> parsec is LL(*) right?
16:51:21 <christo_m> like i can define the lookahead i mean
16:52:08 <christo_m> nvm might just be LL top down
16:52:25 <monochrom> parsec could be used as LL or as context-sensitive or as type 0
16:53:54 <ddarius> monochrom: Or as Turing recognizable.  Where do you draw the line?
16:54:24 <monochrom> there is no line to be drawn
16:56:21 <gienah> christo_m: antlr is LL(*), however currently using antlr requires using the antlr C runtime for the lexer and parser, an option if you really need LL(*)
16:56:35 <christo_m> apparently i dont need to do lexing , i just need to parse input , so i can do it lexer free
16:56:41 <christo_m> ya
16:56:49 <christo_m> i dont know how much that simplifies anything
16:58:52 <mm_freak> i think that in parsec (or in monadic parsers in general) the process of lexing is implicit
16:59:50 <kulakowski> wavewave: -m32
17:01:56 <wavewave> kulakowski: I knew -m32 for gcc, but I wanted to know a global option for "./configure" for a c++ project..
17:02:03 <ddarius> mm_freak: That's not the case.  Parsec does handle lexing as parsing pretty well, but that's not required by Parsec and certainly not by monadic parsers in general.
17:02:51 <wavewave> kulakowski: and found that it was explained in README. definitely, that's just different package by package.. no global rule. 
17:03:02 <mm_freak> ddarius: well, one might ask where you draw the line between parsing and lexing
17:03:07 <wavewave> kulakowski: thank you, though. 
17:03:28 <ddarius> mm_freak: Usually about the same place you draw the line between regular and context-free grammars.
17:03:47 <kulakowski> wavewave: hope you got it working
17:05:55 <mm_freak> ddarius: i don't understand that comparison…  lexing for me corresponds to the concept of enumeratees
17:06:21 <mm_freak> or is a special case thereof
17:06:25 <smarmy_> couldn't all compiler phases be enumeratees in that sense?
17:06:51 <xplat> smarmy_: no, only the ones that are streaming
17:07:03 <smarmy_> hmmm... i suppose so
17:07:27 <ddarius> Almost all aspects that are considered "lexical" are recognizable by regular grammars, a notable exception being nested comments which is probably why many languages don't allow them.
17:07:39 <ddarius> s/don't/didn't/
17:08:14 <xplat> lexing is basically a preprocessing phase where you turn an LL(*) or LR(*) grammar to (1) using a finite state transducer
17:08:25 <micahjohnston> aha he's online again looks like
17:08:33 <micahjohnston> ugh wrong channel
17:08:47 <xplat> although, yeah, languages with nested comments exceed that
17:08:48 <wavewave> kulakowski: in fact, compilation failed :-(.  somewhat bad packaging.. 
17:08:48 <ddarius> xplat: Yep.
17:08:58 <kulakowski> wavewave: boo. what package?
17:09:35 <wavewave> kulakowski: ahh. but I found the binary distribution 32bit, 64bit.. so finally okay ;-)
17:09:44 <wavewave> kulakowski: it's ROOT. 
17:09:53 <wavewave> root.cern.ch
17:09:59 <mm_freak> i didn't know that lexing has a theoretical foundation…  i always thought that lexing is just the process of converting a Char-parser to a Token-parser (for some application-specific Token type)
17:10:15 <kulakowski> wavewave: ah. scientist code.
17:10:31 <wavewave> yeah. kk 
17:10:48 <xplat> mm_freak: the theoretical foundation i'm using is sort of bolted on after the fact by examining what most lexers actually do
17:10:55 <wavewave> I have my private binding code to this ROOT package. 
17:11:07 <wavewave> haskell binding code.
17:11:32 <wavewave> and now I changed to mac, so i am trying to build a system here.
17:11:37 <ddarius> I'm pretty confident their main reason for existence was performance and parser simplicity (primarily for the sake of performance) back when this stuff mattered.
17:12:06 <wavewave> some time, I will announce the haskell ROOT binding on hackage.
17:12:38 <wavewave> it's pretty convenient. 
17:12:45 <mm_freak> btw, given fast parser libraries like attoparsec, is there nowadays a need to use happy/alex?
17:13:00 <xplat> ddarius: well, yes, i was a little more concerned with how they achieved that
17:13:27 <ddarius> xplat: I agree with everything you've said.  I'm just saying why they bothered.
17:13:44 <xplat> ddarius: oh, good point
17:14:04 * hackagebot either 0.1 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.1 (EdwardKmett)
17:14:18 <xplat> mm_freak: there are a lot of grammars i would rather do with happy/alex than attoparsec
17:15:12 <xplat> attoparsec seems to be perfect for replacing/replicating hand-rolled RD parsers with something more compact and readable
17:17:52 <xplat> it's not so good for things that were made with yacc because they tend to use constructs that result in either excess backtracking or premature commitment in most combinator frameworks
17:17:56 <ksf> @pl (\xs -> (map.map) snd . groupBy (const fst)   . zip (True:zipWith ((==) . (+1)) xs (tail xs))
17:17:57 <lambdabot> (line 1, column 94):
17:17:57 <lambdabot> unexpected end of input
17:17:57 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or ")"
17:18:05 <ksf> @pl (\xs -> (map.map) snd . groupBy (const fst)   . zip (True:zipWith ((==) . (+1)) xs (tail xs)))
17:18:05 <lambdabot> ((map (map snd) . groupBy (const fst)) .) . zip . (True :) . ap (zipWith ((==) . (1 +))) tail
17:18:49 <xplat> (including attoparsec, although not to quite as severe an extent as parsec)
17:19:51 <xplat> the only combinator parsing framework i've dealt with so far that even begins to substitute for yacc is gll-combinators for scala, but it is too slow to be practical and unmaintained anyway :(
17:20:22 <xplat> grammar-combinators might grow into something even better but it's too early to tell
17:20:59 <ksf> @pl (\xs -> (map.map) snd . groupBy (const fst)   . zip (True:zipWith ((==) . (+1)) xs (tail xs) $ xs)
17:20:59 <lambdabot> (line 1, column 99):
17:21:00 <lambdabot> unexpected end of input
17:21:00 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or ")"
17:21:20 <xplat> (and by 'yacc' i mean the class of LR(1) and better parser generators including happy)
17:21:28 <christo_m> varlist ::= var {`,´ var}  should become data Varlist = Var (Comma Var)* ?
17:21:33 <ksf> @pl (\xs -> (map.map) snd . groupBy (const fst)   . zip (True:zipWith ((==) . (+1)) xs (tail xs))  $ xs)
17:21:33 <lambdabot> ((map (map snd) . groupBy (const fst)) .) =<< zip . (True :) . ap (zipWith ((==) . (1 +))) tail
17:22:58 <xplat> christo_m: no, Comma doesn't have any interesting data so you can leave it out of your types, so you end up with just type Varlist = [Var]
17:23:44 <xplat> christo_m: (leaving out things like that is what puts the 'abstract' in 'abstract syntax tree')
17:23:47 <christo_m> so i can just ignore it?
17:24:14 <christo_m> so i dont need to prefix it with data
17:24:18 <christo_m> im not making it its own type. hm
17:24:34 <christo_m> i guess i dont need to put the comma because haskell by default defines lists the same
17:24:48 <xplat> christo_m: that has nothing to do with it
17:25:02 <christo_m> explist ::= {exp `,´} exp , see why is the order different here
17:25:05 <christo_m> xplat: then what does it have to do with
17:25:10 <christo_m> im not understanding
17:25:38 <xplat> christo_m: you might know this already, but there are two things you have to define, types to hold your parsing results, and parsers to do the actual parsing
17:26:20 <christo_m> right, i get this
17:26:30 <christo_m> but i would obviously like to use as much of the native haskell types as possible
17:26:33 <christo_m> so i get checking for free
17:26:46 <christo_m> isnt that the point of defining varlist like how you did?
17:27:49 <xplat> christo_m: that's part of the point, but even if i was making a new type rather than reusing list there would be no use including Comma
17:27:53 <ray> haskel
17:28:57 <christo_m> xplat: no i agree with you
17:29:01 <xplat> the reason the commas are left out is that there is nothing you can do with the commas alone to make the expression still parse but have a different meaning
17:29:21 <christo_m> i think my problem is im just doing without thinking
17:29:23 <christo_m> and i dont have a lot of time
17:29:28 <christo_m> so im stressing myself out, but i get what you're saying
17:29:52 <xplat> ah
17:29:54 <christo_m> explist ::= {exp `,´} exp , So regardless of the change in order here
17:30:05 <christo_m> i can still do Explist = [Exp]
17:30:10 <xplat> right
17:31:32 <xplat> and you can still parse it with sepBy1
17:31:43 <xplat> or whatever the uu-parsinglib equivalent is
17:32:01 <christo_m> no im using parsec now
17:32:04 <christo_m> gave up on uu parsing
17:32:15 <christo_m> ya sepBy1 will be using comma right
17:32:21 <christo_m> makes sense
17:32:51 <saml> what is continuation?
17:33:00 <saml> does it eliminate function call stack (in C sense)
17:40:28 <xplat> saml: a continuation is sort of 'where a function returns to' or 'what happens to the value of the function after it returns'
17:40:47 <xplat> (in pure code these are the same thing, in impure code it gets dicey)
17:41:15 <saml> http://www.cs.indiana.edu/~jsobel/c455-c511.updated.txt   is there source code of this guy's homework?
17:41:30 <xplat> like in 1+(2*3), the continuation of (2*3) is 1+_
17:41:42 <dark> uhm, i would say that a continuation is a function that when called, makes you jump to the environment where it was created (that is, if it is created with a "call with current continuation" construct)
17:41:51 <dark> oh
17:41:53 <saml> he said that he transformed his scheme code to continuation passing style.. and hand compiled to C for performance
17:42:10 <dark> in the most general sense i get lost
17:43:06 <saml> can i compile any program to C with goto only?
17:43:13 <saml> i sound stupid
17:44:01 <gienah> saml: in C there is also setjmp
17:44:02 <dark> saml, almost every control struct must be translated to a branch instruction that is like if + goto
17:44:12 <xplat> saml: 'continuation passing style' means that instead of calling a function and letting it return to its continuation implicitly, you wrap up the continuation as a function that takes the return value as an argument, and let the called function call back to the continuation explicitly
17:47:05 <saml> give me haskell example of CPS
17:47:20 <saml> i can google because i'm a good person
17:47:32 <xplat> so like 1+2*3 becomes ‘\c -> multiply 2 3 $ (\t -> plus 1 t) c’
17:48:29 <xplat> where ‘multiply’ is a function that multiplies its first two arguments and passes the product to its third (function) argument
17:48:51 <saml> i fail to see how this can affect performance
17:49:04 <xplat> multiply :: Int -> Int -> (Int -> a) -> a
17:49:44 <saml> if i write in CPS, it's faster?
17:49:52 <Eduard_Munteanu> No.
17:50:19 <Eduard_Munteanu> But in some cases it can restructure code in such a way to make it faster.
17:50:30 <Eduard_Munteanu> I don't know off the top of my head...
17:51:11 <xplat> yeah, it's not so much 'CPS goes fast', more that it offers opportunities for optimization
17:51:34 <saml> does ghc automatically does that for optimization?
17:51:38 <xplat> although early on historically the reasons for CPS didn't have a lot to do with speed i think
17:52:39 <xplat> except maybe specifically for speed of scheme implementations
17:54:27 <xplat> scheme and other languages that allow you to specifically manipulate continuations and pass them around like normal functions, those do run faster if you CPS them (in the compiler) because it eliminates the distinction between 'return' and 'call' so you don't need to special-case reified continuation calls in the runtime
17:54:43 * copumpkin uses CPS for polymorphic returns
17:55:05 <Veinor> how do I make home/end keys work with ghci
17:55:07 <Adamant> CPS and SSA are both formally linked and are the format of choice for most functional-ish and imperative languages at this point
17:55:07 <copumpkin> (existential ones)
17:55:07 <Veinor> ?
17:55:17 <Jesin> SSA=?
17:55:27 <Adamant> Single Statement Assignment
17:55:28 <Adamant> IIRC
17:55:44 <Jesin> right
17:55:50 <xplat> Adamant: yeah, SSA is just how CPS looks if it's invented by assembly programmers instead of functional programmers :)
17:55:53 <Eduard_Munteanu> A basic high-level intermediate representations used in compilers.
17:55:55 <Adamant> :P
17:56:03 <Eduard_Munteanu> Although I don't know if CPS has its place there :/
17:56:10 <Adamant> it's used
17:56:17 <Adamant> not as much in Haskell
17:56:25 <Adamant> I think WHNF is the standard there due to laziness
17:56:38 <Adamant> I am no ghc guru though
17:56:48 <Eduard_Munteanu> Wait, wait, that's just evaluation semantics
17:57:12 <xplat> SSA = Static Single Assignment (form)
17:57:20 <Adamant> yeah
17:57:57 <xplat> the idea being that each variable is only assigned in one basic block, and only assigned once each time through the block
17:58:13 <Eduard_Munteanu> SSA is pure, in a sense
17:58:20 <xplat> this makes iteration remarkably similar to recursion
17:58:43 <xplat> (recursion in a pure functional language, to be precise)
17:59:02 <Jesin> yeah
17:59:35 <Eduard_Munteanu> SSA is nice because it enables some optimizations, and quite many of them are described in terms of SSA representations.
17:59:47 <Jesin> according to wikipedia,
17:59:49 <Jesin> "SSA is formally equivalent to a well-behaved subset of CPS (excluding non-local control flow, which does not occur when CPS is used as intermediate representation), so optimizations and transformations formulated in terms of one immediately apply to the other."
17:59:49 <Eduard_Munteanu> Like copy propagation, CSE etc.
18:00:04 <Eduard_Munteanu> Ah.
18:00:39 <Veinor> so, i heard it's possible to run ghc7 and ghc6 together
18:00:53 <ezyang> Veinor: Yep. 
18:00:58 <Veinor> how do I go about doing this?
18:01:13 <ezyang> Where are your ghc6 and ghc7 from? 
18:01:32 <Veinor> binaries downloaded from haskell.org
18:01:33 <xplat> Veinor: install one, install the other with a different prefix, that's basically it
18:01:56 <xplat> might be difficult if they're binaries :I
18:02:02 <ezyang> What OS? 
18:02:41 <ezyang> Here is the wrapper script the GHC build tree uses to allow in-directory running: http://hpaste.org/44100/the_wrapper_script_of_doom 
18:02:49 <ezyang> you'll need to fix up the paths, obviously. 
18:02:57 <xplat> with windows binaries it would be easy, though -- basically the only case where windows wins over anything for package management :)
18:03:04 <Veinor> ubuntu.
18:03:11 <ezyang> Yeah, multiversioning on Linux is an unsolved problem. 
18:03:19 <Veinor> ezyang: "but /home/ezyang doesn't exist!"
18:04:32 <Veinor> hm. actually, considering that /usr/local/bin/ghc is just a symlink to /usr/local/bin/ghc-6.12.3...
18:04:56 <Eduard_Munteanu> Gentoo folks solved the multi-gcc issue by using some symlink machinery I think.
18:05:09 <xplat> the main problem with multiversioning is the 99.44% case is 'i want to blow away the old version when i install the new version'
18:05:10 <Eduard_Munteanu> I suppose a user-local install of GHC would be similar.
18:05:19 <ksf> Veinor, there's more than that. have a look at the script that is ..../bin/ghc
18:05:32 <Veinor> ksf: ah
18:05:36 <ksf> it points to the actual binary in lib and passes all paths
18:05:50 <Veinor> so i could just install to ~/ghc7
18:05:53 <mathstuf> hi, what libraries are there to do string-template replacements?
18:06:07 <mathstuf> something between template and StringTemplate (i think)
18:06:16 <xplat> and so it's hard to make even small compromises for that 0.56% case without causing inordinate damage
18:06:25 <ksf> Veinor, that's what I do
18:07:05 <christo_m> xplat: fieldsep ::= `,´ | `;´ , i should probably define field right
18:07:07 <christo_m> and then have sepBy
18:08:27 <xplat> christo_m: i think so; this is getting lua-specific and i don't know lua so i'm not quite as sure as earlier
18:09:12 <Veinor> now i just have to figure out how to specify 'i want the ghc7 stuff'
18:09:41 <Eduard_Munteanu> Veinor: export PATH=... ?
18:09:48 <Veinor> prolly, yeah.
18:10:02 <christo_m> xplat: me neither, i probably should have learned it
18:10:48 <Eduard_Munteanu> Not sure if you need LD_LIBRARY_PATH too.
18:12:16 * hackagebot xml-types 0.1.4 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.1.4 (JohnMillikin)
18:12:18 <gienah> on linux including gentoo can use chroot to install another ghc version
18:15:11 <gienah> mathstuf: I guess you already know about HStringTemplate
18:15:17 <xplat> well, you can always use a chroot.  they're not QUITE as much pain as a vm :)
18:15:31 <Eduard_Munteanu> They're still a PITA.
18:15:55 <mathstuf> gienah: oops, thats what i meant by StringTemplate
18:16:11 <Veinor> cabal-1.8.0.2 doesn't compile on ghc7 :|
18:16:28 <Veinor> filepath is too new
18:16:41 <xplat> and i guess you can't actually always use a chroot; you can't run a different kernel version in one :)
18:16:56 <xplat> for that you need an actual vm
18:17:40 <gienah> Veinor: gentoo uses cabal-1.10.0.0 for ghc 7
18:18:00 <Veinor> ah
18:18:31 <mathstuf> gienah: maybe template can do what i need
18:18:45 <xplat> hm, people say the relational calculus is declarative and relational algebra is procedural
18:18:58 <xplat> why do i see them both as declarative then?
18:18:59 <gienah> mathstuf: that's good, I haven't uses template or HStringTemplate
18:21:40 <xplat> or if i squint the other way i can see them both as procedural (they both immediately suggest a procedure to find results)
18:22:38 <xplat> i guess it's that the natural procedure for relational algebra more closely resembles the steps real databases use when executing queries?
18:22:42 <revenantphx> OH SHIT THE SLENDERMAN
18:23:35 <xplat> (but before the relational model didn't they act more like the natural procedure for the calculus?)
18:24:14 <xplat> (and executing datalog as prolog works like the calculus too!)
18:38:44 <ezyang> Hmm, I have a theory about laziness which is that it's easier to annotate lazy code to be strict than vice versa. I wonder if this is actually true. 
18:39:30 <dolio> I don't know, have you read Okasaki's book?
18:39:54 <ezyang> Yeah, I'd say I understand basically the first half. 
18:40:10 <dolio> Well, the relevant part would be that he uses ML with laziness annotations.
18:40:44 <ray> i had that theory too then i realized all i knew was haskell
18:41:00 <ezyang> Yeah, but my recollection was only for a few, specialized data structures. But I guess it'll be good to look at that code again. 
18:41:20 <dolio> I can't recall if it requires explicit forcing. If so, then that's in support of your case.
18:41:40 <dolio> When annotating lazy programs with strictness, you usually only annotate forcing.
18:41:52 <dolio> When annotating strict programs with laziness, a lot of times you annotate both.
18:42:27 <dolio> Well, annotate both for the lazy parts.
18:42:43 <Jesin> well, obviously if you're too lazy to annotate, then you're lazy
18:42:44 <Jesin> :P
18:44:59 <Eduard_Munteanu> Well I suppose for most things it doesn't matter if they're lazy or strict, so laziness might be beneficial in a lot more cases.
18:47:34 <wichobabas> hi!
18:47:52 <wichobabas> i'm having some trouble using UTF-8
18:47:54 <wichobabas> =(
18:48:03 <Eduard_Munteanu> Hi wichobabas 
18:48:21 <wichobabas> i can't print simbols
18:48:23 <wichobabas> like
18:48:25 <wichobabas> ¬
18:48:48 <wichobabas> anyone can help me?=
18:48:50 <wichobabas> =D
18:49:13 <Eduard_Munteanu> Do you know about hSetEncoding?
18:49:18 <wichobabas> I tried to use
18:49:19 <wichobabas> Data.String.UTF8
18:49:23 <wichobabas> but
18:49:31 <Eduard_Munteanu> I presume you're getting an error whenever you're trying to output UTF8
18:49:44 <wichobabas> on the import statement
18:50:07 <wichobabas> maybe it isn't implemented on on hugs
18:50:14 <siracusa> I guess it's a console related problem rather a Haskell problem.
18:50:15 <Eduard_Munteanu> Oh, hugs.
18:50:24 <wichobabas> Can't find imported module "Data.String.UTF8"
18:50:28 <Eduard_Munteanu> wichobabas: hugs is really old
18:50:50 <Eduard_Munteanu> @where platform
18:50:50 <lambdabot> http://hackage.haskell.org/platform/
18:51:15 <Eduard_Munteanu> That's what's recommended these days ^
18:51:23 <wichobabas> lol
18:51:43 <wichobabas> maybe my computer is older than hugs
18:51:44 <wichobabas> xD
18:52:10 <wichobabas> i cant use haskell platform because my computer is power pc
18:52:12 <wichobabas> =(
18:52:23 <Eduard_Munteanu> Hm, no PPC build?
18:52:36 <wichobabas> Eduard_Munteanu++
18:52:39 <wichobabas> nop
18:52:42 <wichobabas> ;_;
18:53:16 <Eduard_Munteanu> wichobabas: are you running Linux? If so, what distro?
18:53:33 <Eduard_Munteanu> They might have a GHC build.
18:53:45 <wichobabas> no, i'm runing mac os 10.5
18:56:18 <Eduard_Munteanu> wichobabas: have you tried getting it through MacPorts, or at least GHC? A quick grep through that seems to show something about PPC
18:56:59 <wichobabas> yeap it but it need xcode 3.2
18:57:11 <wichobabas> that it's only for intel
18:57:12 <wichobabas> xD
18:57:24 <gienah> I wonder if you can run gentoo in a chroot on the ppc mac
18:57:28 <Eduard_Munteanu> Xcode is a dependency for GHC? :/
18:57:36 <Eduard_Munteanu> Hah.
18:57:51 <stepcut> Eduard_Munteanu: only on OS X ;)
18:57:51 <wichobabas> maybe I only need a new computer
18:57:52 <wichobabas> xD
18:58:20 <stepcut> Eduard_Munteanu: mostly for gcc, etc. not the actually editor :)
18:58:22 <Eduard_Munteanu> PPC is interesting.
18:58:36 <Eduard_Munteanu> Oh.
18:59:57 <Eduard_Munteanu> Well you could get a Linux running.
19:00:20 <wichobabas> on my office computer there is no problem
19:00:34 <wichobabas> im runing slackware 13 with ghc
19:00:59 <wichobabas> but it would be really cool
19:01:18 <Eduard_Munteanu> Well, back to your problem. Maybe you can get the missing bits by installing cabal (somehow) and using it to build the missing stuff?
19:01:19 <wichobabas> to make this work on my laptop with ppc
19:01:53 <Eduard_Munteanu> Maybe cabal still builds on hugs.
19:02:47 <gienah> maybe chroot is a linux thing, anyway you could install gentoo on a ppc mac, maybe dual boot if you still want macos
19:04:33 <Bynbo7> OS X has chroot too
19:04:51 <wichobabas> i'll try gentoo one of these days
19:05:06 <wichobabas> I had never worked with that distro
19:05:31 <wichobabas> i'll try it
19:05:46 <gienah> gentoo has good haskell support, and support ppc
19:06:08 <Eduard_Munteanu> Well keep in mind it's a source-based distro, so it won't be quick&easy to install.
19:06:18 <Bynbo7> does that support intersect though?
19:06:23 <Eduard_Munteanu> Arch also has good Haskell support IIRC, but I'm not sure about PPC.
19:06:37 <gienah> no, may destroy the laptop if the cooling is not good enough :-/
19:07:44 <Eduard_Munteanu> Granted, Gentoo supports most arches out there, if I'm not mistaken.
19:07:53 <Eduard_Munteanu> Even FreeBSD variants.
19:08:43 * Eduard_Munteanu should try a BSD in a VM some day.
19:11:43 <gienah> Bynbo7: I don't know what you mean by intersect
19:12:09 <Bynbo7> does ghc work on ppc under ubuntu. i believe the only platform ghc has ever worked for with ppc is OS X
19:12:39 <kfr> And the bootstrapping process for ghc has been broken for close to 2 years now
19:12:47 <kfr> i.e. it hasn't been ported to new platforms since then pretty much
19:13:13 <kfr> It's a low priority issue to the devs at that
19:14:02 <gienah> Bynbo7: ghc 6.12.3 and 7.0.1 are supported on ppc and ppc64 with gentoo
19:14:16 <Bynbo7> interesting
19:14:34 <gienah> kfr: and of course we bootstrap ghc on gentoo :-_
19:15:10 * gienah my smiley fell flat due to a typo
19:15:57 <applicative> wichobabas, i'm puzzled, mac ppc binaries like this http://www.haskell.org/ghc/download_ghc_7_0_1#macosxppc are supposed to be for your situation...
19:15:58 <elliott> what's that evil magical ghc prim to check if two things have the same memory address :)
19:16:51 <dolio> reallyUnsafePtrEquality#
19:17:06 <elliott> Now I just have to find the module :-P
19:17:33 <wichobabas> downloading =P
19:17:51 <wichobabas> thanks
19:18:06 <wichobabas> ++applicative
19:18:14 <wichobabas> how dows karma works here?
19:18:30 <wichobabas> plus plus nick?
19:18:35 <wichobabas> or nick plus plus
19:20:45 <Bynbo7> applicative++
19:20:50 <Bynbo7> it's done ow
19:20:51 <Bynbo7> now*
19:25:39 --- topic: '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
19:25:39 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Fri Jan 28 14:21:18 2011]
19:25:39 --- names: list (clog accel brisbin damex elliott pheaver litb_ roconnor sebfisch danblick Hugglesworth mrsolo miclorb ousado_ npouillard btubbs dnolen xplat ngochai pikhq_ Mathnerd314 jaj micrypt cognominal wichobabas Draconx pyrony yhager_ edwardk Bynbo7 metaliving augur abiraja moshee mzero exlevan Gracenotes ski ozataman Cobra_ mathstuf c_wraith cubi SsvRrwQ cyphunk_ copumpkin aristid tibbe zmbmartin joelb ddemmmherffffers applicative ambroff abijr dolio Jesin nchaimov)
19:25:39 --- names: list (lpsmith revenantphx Rotaerk QinGW myu2 juhp sbahra dancor mpiechotka _ay_ cheater00 killown siracusa spetrea-home ab3 Philippa fryguybob ceii_ theorbtwo _sh3 sidek troofax kermit aristid_ cwillu_at_work integral rando_ darq[afk] __nickm__ nkpart christo_m kfish augustss Utkarsh ikeg ISF danharaj AVbd br35 bos newsham novas0x2a brushbox dkasak pingveno dibblego m3ga regalia_ tensorpudding siplux Darkone alip matt5 rapacity Raynes bd_ mindwarp gienah jacobian)
19:25:39 --- names: list (noam emporas tg__ conal erg0t kulakowski toothbrush0 s76 ormaaj fogus_away Eridius gniourf_gniourf jystic HugoDaniel ray Jantaro taotree joyfulgirl Amadiro hpc FDFlock Draconx|Laptop Cale Egbert9e9 phenom_ yrlnry romanandreg levitation_ Cozminsky Watermind hvr welterde hotaru2k3 pankajm hzh bogner ocharles jgrimes kfr Persa drbair_work nettok lispy_ dual Zeiris abbe Entroacceptor Adamant davean adimit mun phrackSipsin _ggreg mq MrFahrenheit peoro chitech)
19:25:39 --- names: list (muhtimin_ sopvop jedai_ scm MacCoaster rainnighte Eduard_Munteanu Jafet jonafan ddarius alexsuraci` peddie jaspervdj xinitrc pantski insomnia1alt joeytwiddle lsthemes hackagebot monochrom Yvemath Modius dleslie SonicvanaJr lostman liyang_ Axman6 bhungy freedrull parcs milli benedikt willb1 cafesofie [mth]_ otto_s_ tmuki derekwright Guest29350 sophacles O1athe leers orbekk McManiaC tomjnixo1 BMeph Paradox924X ArchGT snorble mgsloan Denebola Arnar Raku^ Igloo)
19:25:39 --- names: list (chitragupt kakeman solidsnack bradleyayerswork toei Bassetts Philonous smarmy_ Astro ville dom96 joaopizani waern_ rdd mariano|godot thetallguy ace2001ac CoryDambach nniro digitteqnohippie snhmib Maxdamantus etabot xinming gbeshers deggis lunaris xarch rup dju vegai filius sShintah stepnem ian_mi Gunni @ChanServ marienz shachaf ibt a11235_ ortmage guerrilla Aisling koala_man FauxFaux almostsix allbery_b robinbb jql nothingmuch_ hellige freiksenet PsiOmega)
19:25:39 --- names: list (suiside CindyLinz majoh wagle dcolish franz_ Cthulhon dfeuer Twey rokoteko bqf int-e eno fihi09`` digitteknohippie jlewis chromakode derrotebaron raek Gabbie robinsmidsrod AnAdorableNick MasseR gdsx mrshoe jrk_ ahihi2 cpa Blub\0 jlouis duairc cjay quaestor norm2782 Rooz skaar aiko_ Jiten copton thoughtpolice janne davidL EvanCarroll emias ksandstr jd10_ taruti sutats mattam sajkr ulber tomaw ido category caligula Ke ChongLi trez gds jml andrewsw etpace dmwit)
19:25:39 --- names: list (snarkyboojum ben Saizan __marius__ mrd udoprog palmje pou_ c1de0x bxc_ ibid Boxo tengen poucet flori lambdabot Vq adnap o^_^o nlogax ve dons electrogeek Heffalump ToRA Tinned_Tuna thorkilnaur qebab sipa nimred MrDomino^ Ferdirand jcapper rwbarton plan OnionKnight cizra alexsdutton jdavis untwisted solarus opqdonut fabjan metasyntax bartavelle BrianHV Odd_Bloke koninkje_away steve_himself osfameron tlockney dilinger pastorn cpa_ ricky benthos joni6128 ilab)
19:25:39 --- names: list (danr tew88 ihckt scsibug mjrosenb inr alexbobP codemac Counter-Strike stesh thorstadt jssanders And[y] tessier Adman65 oc gerard0 sohum nornagon sgtarr ahihi neurogeek cafaro johs faj deavid alpounet EvanR endpoint_david Botje cynick Lemmih Gilly jrockway scree Jaak_ KitB_ okp_ tab duckinator ziman geekounet ps-auxw mike1703 snr mortberg saurik profmakx DustyDingo jbauman canvon jdsc hyko alios djahandarie noj wires BONUS aavogt erk quicksilver tromp_)
19:25:39 --- names: list (Innominate schroedinbug1 tafryn jix_ ClaudiusMaximus Vulpyne _2x2l alexsuraci earthy whoops naypalm Laney ReinH mikeg Nanar mafs tswett agemo TML Obfuscate orbitz ath Starfire_ Guest4559 bezik olsner Clex Zol ion Bleadof finnomenon frerich ehamberg Younder rothwell jamwt Zao iFire eyck rryan_work DrSyzygy Sunhay Martty_ thetallguy1 gseitz Dashkal zax cozmic dv- Baughn companion_cube arkx Vorpal flippo glguy klugez magicman em kelvie aleator _mpu tamiko pix|)
19:25:39 --- names: list (aculich edwtjo ixzkn zygoloid clanehin mm_freak niko mietek dreixel Fingerzam iveqy luite kosmikus birkenfeld epmf cncl_ dino- HaudRex edenc eZet Eelis helgikrs obiwahn `0660 Taggnostr2 vili shepheb regalia hc yahooooo Liskni_si Aestas Intensity silex sproingie [mth] blackdog Neronus ernst dionoea zaphar_ps pantsd nominolo saiam Belgarion0 zakwilson mux gereedy kaol kalven sonnym1 TheMoonMaster Evious nathanic MK_FG Janno shamster mornfall pettter Ornedan)
19:25:39 --- names: list (PHO_ stroan_ elliottt byorgey obcode sgronblo slabanja SimonRC dcoutts idoru pesco go|dfish kelvie_ absentia audunska carrbs jmcarthur Hunner _Mitar dqd kloeri dorkitud1 zmyrgel` dumael inimino periodic idnar comex_ jvogel StoneToad burp impl KaneTW systemfault dMazzz liesen tavelram_ timchen1a reacocard david` Nereid noddy muep araujo tlonim kalivha cibs mlh Veinor yx harlekin elliottcable Cerise flamingspinach perlite mercury^_ ahf kolmodin_ defect akamaus)
19:25:39 --- names: list (henr_k andersk todos_ ivan jayne tridactyla drhodes krainboltgreene barik hiredman sbok ezyang afarmer dogmaT akosch dropdrive dRbiG lantti gwern setmeaway winxordie CosmicRay wto anders^^ cyanoacry dankna alek_br Colours drbean minsa flux Khisanth dixie gbacon_ pimeys kniu TacticalGrace larsrh borism)
19:29:55 <wichobabas> applicative++
19:30:11 <accel> waht is this applicative
19:30:13 <accel> and why do I care?
19:30:27 <wichobabas> accel++
19:30:29 <wichobabas> xD
19:31:07 <accel> wichobabas: should I wire you payment via paypal or direct to bank?
19:31:35 <wichobabas> O_O
19:32:02 <accel> you're answering to my craig's list ad to increase my karma right?
19:34:30 <wichobabas> i dont understand
19:34:40 <wichobabas> lol
19:35:02 <accel> ah; neer mind; failed joke on my part
19:35:18 <cncl_> what's the syntax for lambdabot's djinn
19:35:19 <accel> what is applicative good for (compared to monads)
19:35:25 <accel> @djinn
19:35:25 <lambdabot> Cannot parse command
19:35:35 <cncl_> thanks
19:35:37 <accel> ie.. what problem does applicative solves that functions/monads do not?
19:35:39 <aristid> @djinn a -> b -> (b, a)
19:35:39 <lambdabot> f a b = (b, a)
19:36:28 <aristid> accel: applicative is more general. not every applicative type is a (valid) instance of monad
19:36:49 <aristid> for example ZipList
19:37:18 <accel> @src ZipLis
19:37:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:37:25 <aristid> pro bonus feature: applicative has the freakier syntax
19:37:30 <aristid> @hoogle ZipList
19:37:30 <lambdabot> Control.Applicative newtype ZipList a
19:37:30 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
19:37:30 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
19:37:32 <accel> aristid: can you motiate it with "here's probalem XYZ; applicative has nice solution"
19:37:55 <accel> aristid: 
19:38:04 <accel> http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
19:38:07 <accel> is that a good tutorial?
19:38:21 <aristid> accel: i guess you could just try to find the story how applicative was invented
19:39:20 <accel> aristid: ya; you hav a link?
19:39:30 <aristid> no, sorry.
19:40:15 <accel>  fmap3 :: (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d
19:40:15 <accel>  fmap3 f (Just x) (Just y) (Just z) = Just (f x y z)
19:40:15 <accel>  fmap3 _ _        _        _        = Nothing
19:40:21 <accel> is the point to of applicative?
19:40:21 <greap> Hey guys. I'm getting a weird error in haskell: Couldn't match expected type `Vector3 GLdouble' against inferred type `Vertex3 GLdouble'
19:40:36 <greap> What could be happening here?
19:40:50 <accel> greap: see the Vector3 vs Vertex3 ?
19:40:53 <accel> greap: they're different types
19:40:55 <sebfisch> @accel http://strictlypositive.org/IdiomLite.pdf (research paper that introduced applicative functors)
19:40:56 <lambdabot> Unknown command, try @list
19:41:01 <greap> Oh. hahah
19:41:09 <greap> I totally missed that.
19:41:10 <accel> greap: yeah; i ran into the same problem :-)
19:41:14 <greap> Thanks accel 
19:41:37 <accel> sebfisch: cool; thanks
19:42:01 <aristid> sebfisch: are you Sebastian Fischer from uni kiel?
19:42:26 <sebfisch> yes and no (I am now in Tokyo)
19:55:15 <napolitanka> Hi. I'm using the newest plugins library with GHC 6.12.3. Loading a definition seems to fail with "unknown symbol `blahblah_lp_closure', user error (resolvedObjs failed.)" What am I doing wrong?
20:11:45 * hackagebot kit 0.6.7 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.7 (NickPartridge)
20:23:31 <int80_h> hey-ooo
20:31:37 <int80_h> http://hpaste.org/44101/hdbc_installation_problems
20:35:37 <accel> is it possible to have an if then clause without an else clause?
20:35:37 <gienah> int80_h: pgconfig is part of postgresql
20:35:49 <gienah> accel: no
20:36:01 <int80_h> gienah: indeed, it is.
20:36:08 <accel> gienah: how do I get an empty else clause then?
20:36:10 <siracusa> int80_h: Is pgconfig on your path?
20:36:26 <sebfisch> accel: what should be the result for a false condition?
20:36:29 <int80_h> which is why I mention I've got it installed. But I think it's client side software, which I may not have installed
20:36:34 <accel> return ()
20:36:36 <accel> hmm, good call
20:36:36 <gienah> accel: haskell is strange compared to other programming languages insisting on the else clause
20:36:49 <accel> it makes ssense now
20:36:49 <rwbarton> @src when
20:36:50 <lambdabot> when p s = if p then s else return ()
20:36:53 <accel> to have the then/else cuases have the same type
20:37:13 <sebfisch> @hoogle unless
20:37:14 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
20:37:22 <sebfisch> @hoogle when
20:37:23 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
20:37:23 <int80_h> crap, it says I already have client stuff installed.
20:39:24 <int80_h> siracusa: hmm this isn't a haskell problem. For some reason pgconfig never installed. I don't know why.
20:39:37 <int80_h> or if it did, it's not in the predictable places
20:39:44 <int80_h> which doesn't make sense
20:43:13 <int80_h> solved. I just needed the riht.deb packages installed.
20:45:19 * accel just reached a new level of understanding for Monads.
20:45:29 <accel> Monad Understanding: Newb Level 2 achieved.
20:46:52 <int80_h> accel: hey I got that one too!
20:47:00 <monochrom> haskell if-then-else is not strange. just like c ?:
20:47:04 <accel> *high five*
20:47:38 <accel> nothign in haskell is weird; it just has fucking counter intuitive names if you're used to other programming languages
20:47:55 <accel> things like if-then-else, return, do, >>
20:47:59 <accel> can we make it mroe confusing?
20:48:08 <monochrom> imperative if-then may be a convenient shorthand, but when you reason about imperative programs, you must always put back the else, i.e., if b then P else nop. the nop there is important.
20:48:18 <accel> let's rename if-then-else to: batman (1>2) superman 3 wonderwoman 4
20:48:27 <accel> or return () to: hitler ()
20:48:47 <accel> I think that would make the sematnics clearer
20:54:29 <int80_h> first usage of godwin evar!
20:54:38 <int80_h> in #haskell at least
20:54:48 <int80_h> I think we should commemerate somehow
20:55:02 <accel> by giving me ops
20:55:10 <accel> anyone who uses hitler as a vraible name is clearly sane
20:55:12 <accel> and should be granted powers
20:56:15 <copumpkin> man, I don't think we've ever had an op beggar in here for as long as I've been around
20:56:19 <copumpkin> which admittedly isn't really that long
20:56:34 <accel> beggar?
20:56:38 <accel> I just think it's funny
20:56:54 <monochrom> please give me op too, I beg you, I promise I will use it for great good
20:57:09 <accel> I promise to use mine for evil
20:57:12 --- mode: ChanServ set +o copumpkin
20:57:13 --- mode: copumpkin set +o monochrom
20:57:15 --- mode: copumpkin set -o copumpkin
20:57:16 <accel> if you op both monochrom and me, it'll balance the world
20:57:27 <copumpkin> o shit, things are unbalanced now
20:57:35 <monochrom> I know an easier way to balance
20:57:37 --- mode: monochrom set -o monochrom
20:57:42 <monochrom> balanced
20:58:41 <lispy> I used to have ops here until freenode reset my account.  I think I'm better off without it :)
20:59:19 <accel> one day, one day *shakes fist at sky randomly* one day, I will have ops; probably when the Acolypase arrives
20:59:45 <lispy> accel: Have you contributed to lambdabot yet?
21:00:01 <lispy> That used to be one of the criteria (jokingly)
21:00:13 <accel> lispy: I have tried to break labmdabot
21:00:14 <accel> does that count?
21:00:16 <djahandarie> I've avoided patching lambdabot at all costs
21:00:22 <monochrom> well I now have ops in ##accel too
21:00:27 <djahandarie> Haha
21:00:35 <accel> that's a most worthless channel
21:01:34 <lispy> accel: heh
21:01:49 <lispy> accel: if you can break lambdabot send me a patch that makes it so your breakage no longer works :)
21:01:57 <shachaf> lispy: Lambdabot isn't difficult to break.
21:02:02 * lispy doesn't maintain lambdabot but hosts the server it runs on
21:02:27 <shachaf> lispy: I think there are at least a couple of known ways to @admin yourself.
21:02:39 <lispy> shachaf: hmm...maybe /msg the commands that berak it?
21:02:50 <accel> this is so sad; my entire DSl is only 271 LOC
21:02:56 <accel> and I bet I can get it down to 200 if I refactor a bit
21:03:08 <accel> it's basically a forth interpreter
21:03:13 <accel> that outputs TeX
21:03:19 <accel> (as I don't like the TeX amcros sytem)
21:05:30 <lispy> accel: cool
21:08:30 <accel> I'm going to write a great editor in haskell
21:08:40 <accel> the one day, #haskell shall beg to give me ops,
21:08:43 <accel> and I shall turn it down.
21:08:54 * accel starts coding
21:08:57 <shachaf> @msg #haskell Yep, it still works.
21:08:57 <lambdabot> Yep, it still works.
21:09:00 <shachaf> @admin - shachaf
21:11:06 <copumpkin> shachaf: yeah, ah well :P
21:12:20 <lispy> accel: You're the next dons?  One of his "first" apps was an editor in Haskell.  Now he's a celebrity in the community.  Used to run lambdabot, definitely has ops here.
21:14:11 <accel> lispy: yi?
21:14:17 <lispy> accel: that is correct
21:15:07 <lispy> accel: one of my first real haskell programs was an emacs lisp compiler (helisp) so that yi would support elisp.  I made it as far as a generic scheme compiler and got distracted by grad school.  I hope to finish it some day :)
21:15:25 <accel> lispy: why do you want elisp?
21:15:28 <shachaf> Regarding writing an editor: http://www.metafilter.com/90719/Ommwriter-is-a-texteditor-for-your-wild-monkey-minds#3027487
21:15:29 <accel> lispy: elisp is the reason I don't use emacs
21:15:46 <lispy> accel: just so I can port the wealth of elisp to yi
21:16:05 <lispy> accel: although elisp is a poor language, there is a lot of useful code in that language
21:16:32 <accel> lispy: perhaps you could hack jonathan tan's 48 hour scheme-in-haskell compiler into elisp
21:17:00 <lispy> accel: I think I was further along than that actually
21:17:21 <lispy> accel: if I picked it up again, I would either a) use llvm bitcode, b) translate to Haskell
21:17:54 <shachaf> I don't think that Scheme is even a compiler, is it?
21:18:00 <lispy> accel: I was to the point of generating assembly code for factorial that had proper tail call
21:19:09 <shachaf> Speaking of tail calls, "return [void expression];" seems to be invalid C by the standard, sadly.
21:19:16 <shachaf> (In a void function.)
21:19:31 <lispy> shachaf: hehe.  Nice find.
21:19:37 <shachaf> lispy: It's annoying. :-(
21:19:41 <lispy> shachaf: return;"
21:19:43 <lispy> er
21:19:56 <lispy> shachaf: "return;" is valid in a void returning function though
21:20:12 <lispy> C's void is very weird though.
21:20:21 <shachaf> lispy: Yes, but when I want to indicate a tail call, it would be much nicer to say "return g();" where g returns void than "g(); return;".
21:20:26 <lispy> You can cast a statement to void, but void is uninhabited otherwise
21:20:47 <shachaf> lispy: A statement or an expression?
21:20:57 <lispy> Gosh.  I'm not sure
21:21:12 <lispy> Not enough of a C language lawyer
21:21:18 <monochrom> http://www.vex.net/~trebla/ieg.xhtml  \∩/
21:21:36 <lispy> I've seen it as a way to get rid of compiler warnings about unused variables after a goto
21:21:50 <lispy> like, somelabel: (void)foo;
21:22:21 <lispy> monochrom: did you maket hat?
21:22:26 <monochrom> yes!
21:22:32 <lispy> monochrom: cool, what are you working on?
21:22:59 <monochrom> my vapourware tutorial on lazy evaluation will feature such SVG graphics!
21:24:38 <monochrom> haha let me make it more mind-boggling
21:25:07 <lispy> that was weird
21:25:15 <lispy> Not sure why I was disconnected
21:25:27 <lispy> I was only disconnected from freenode
21:26:05 <accel> http://en.wikipedia.org/wiki/AKS_primality_test <-- what step of this allows primality checking without giving the actual factors?
21:27:28 <lispy> accel: think of it more as a proof that the number is composite in linear time than a proof that it is prime
21:27:59 <lispy> accel: it's like we test all the ways that it could have factors.  We don't find any, so it must be prime.
21:28:50 <accel> the algorithms section seems way too simple
21:28:54 <accel> it's like 6 lines long
21:29:03 <accel> which would be 3 lines of haskell moand transformer code
21:29:09 <lispy> accel: it's more like 6 function calls than 6 lines
21:29:26 <lispy> accel: proving it's not a power of a prime is not just 1 line
21:29:37 <accel> If n = ab for integers a > 0 and b > 1, output composite.
21:29:41 <accel> oh, a is a prime in taht lien?
21:29:44 <accel> how do you ctually prove that?
21:29:50 <accel> (i.e. do fast check vs power of prime)
21:30:07 <lispy> I don't know :(  When this algo first came out, I tried to implement it and got stuck finding the way to do the first step :(
21:30:33 <accel> http://www.scottaaronson.com/writings/prime.pdf
21:30:36 <accel> big fan of this guys writing
21:33:26 <lispy> accel: you can probably figure out if n = a^b using logs or something.
21:34:53 <lispy> log_a n = log_a (a^b) = b * log_a a = b, or some such madness
21:35:15 <accel> yeah; but you still need a list of all the primes
21:35:18 <accel> less than N
21:35:21 <accel> less than sqrt(N)
21:35:24 <accel> to brute force taht
21:36:11 <lispy> Well, you just need to test if the log_a n for
21:36:13 <lispy> gah
21:36:39 <lispy> Well, you just need to test if the log_a n is natural for a's that are logorithmic in n?
21:37:25 <lispy> and I think that's going to be automatically linear in the number of bits in n, because log_a n, means a >= 2
21:37:56 <lispy> The constant on AKS is huge.
21:38:14 <lispy> It's much better to use known probablistic methods for primality testing
21:38:44 <accel> bah
21:38:52 <accel> he wimped out in the end of section 11
21:40:48 <lispy> accel: I have some primality testing (and even RSA) in haskell if you want a copy. I wrote it when I was just learning the language so it's very rough.
21:41:57 <accel> lispy: what if I'm not in the US; couldn't the NSA nab you for distributing weapons of mass destruction? :-)
21:42:50 <monochrom> perhaps no one is in the US and no one should be nabbed
21:43:24 <lispy> accel: Well, it doesn't implement the RSA protocol, only the basical algo for Integer :)
21:43:38 <samantha> hello
21:43:43 <lispy> samantha: hi
21:43:58 <samantha> do you know if they are a Java channel?
21:44:08 <lispy> samantha: yes, try ##java
21:44:19 <samantha> oh ok
21:44:21 <samantha> kool
21:44:25 <samantha> thank you much
21:53:34 <jfischoff> is there a way for ghc to auto-generate stub functions, i.e. blah = error "blah not implemented"?
21:54:04 <lispy> jfischoff: hmm...you could use template haskell, but I don't know of any way to do this (or need really)
21:54:21 <lispy> jfischoff: what are you doing that needs lots of stubs?
21:54:50 <jfischoff> sometimes when I am starting out like to write just the signatures
21:54:57 <jfischoff> its not a big deal
21:55:26 <jfischoff> actually I already use TH to do something like that for default functions during testing
21:55:38 <jfischoff> but I have to list the functions :(
21:55:46 <lispy> jfischoff: blah = undefined, seems short.  You could do a top level u = undefined to shorten it to blah = u
21:56:16 <jfischoff> yeah, but then I don't know where it came from, unless there is a way to get that info
21:56:23 <lispy> jfischoff: you could use Language.Haskell + TH to avoid listing them
21:56:32 <jfischoff> how?
21:56:39 <lispy> jfischoff: I did something like this once for autogenerating a test harness
21:57:13 <jfischoff> So if I just write the signature, I get TH to read the file and generate the body?
21:57:17 <lispy> jfischoff: http://blog.codersbase.com/2006/09/simple-unit-testing-in-haskell.html
21:57:39 <lispy> jfischoff: in that article I use unsafePerformIO but there is a better way to do IO in TH, but I forgot how
21:57:57 <jfischoff> ok your using src extensions
21:58:01 <jfischoff> yeah runIO I think
21:58:08 <jfischoff> but its all the same really
21:58:17 <lispy> jfischoff: these days, you could use haskell-src-ext I used some older lib in the post
21:58:32 <jfischoff> same thing, I thought you meant just with TH
21:58:48 <jfischoff> yeah, I search for tests that way
21:59:21 <jfischoff> fixed up the function extractor on hackage to not barf when cpp is used
21:59:42 <lispy> nice!
22:00:49 <jfischoff> that should work if you want it: http://hpaste.org/44103/functionextractcpp
22:01:15 <jfischoff> its using hscpp
22:01:50 <jfischoff> huh its saying there is an error, oh well
22:02:06 <lispy> jfischoff: I don't have an immediate need but i'll keep it in mind
22:02:27 <jfischoff> it was an easy fix
22:02:28 <lispy> jfischoff: that's not a real error, that's the result of running hlint
22:02:33 <jfischoff> ah
22:04:42 <accel> TH is awesomeness
22:04:49 <accel> I would rather be ops
22:04:51 <accel> in a TH channel
22:04:54 <accel> than a #haskell channel
22:06:15 <lispy> accel: if you were an op in a TH channel you could generate the op perms for the #haskell channel :)
22:07:00 <lispy> accel: you seem pretty active here lately.  What inspired you to start learning Haskell?
22:07:07 <Bynbo7> accel: learnt the basics of haskell yet? =)
22:07:32 <accel> Bynbo7: haskell has basics? it's learning curve looks the same as VIM's
22:07:33 <lispy> Bynbo7: Is it even possible for one person to learn all of the basics of Haskell?
22:07:57 <accel> lispy: I started building a MMO in haskell
22:07:59 <Bynbo7> well, a week ago he seemed amazed by pattern matching
22:08:12 <lispy> Bynbo7: whenever I think I've learned Haskell I spend a weekend trolling through oleg's website and make myself feel like I'm just learning to type :)
22:08:21 <lispy> accel: go on
22:08:46 <jfischoff> lispy: How does his mind work? I don't get it.
22:08:53 <accel> who is this Oleg?
22:09:07 <accel> and where is his blog?
22:09:11 <Chaze> i'm trying to write a function that produces the partion of a number. but i can't seem to get it right
22:09:17 <Bynbo7> sure, but oleg's stuff isn't the basics of haskell. things like pattern matching, ADT's how to actually write functions in a functional style, and take advantage of laziness probably would be the basics
22:09:33 <accel> Bynbo7: holy shit, I actually understand the terms you used
22:09:46 <accel> Bynbo7: just don't use the word "transformer" or "applicative" or "functor" or "arrow"
22:09:49 <Bynbo7> can you actually use them?
22:09:55 <Chaze> it's *almost* there, but i'm missing something: http://hpaste.org/44105/produce_partions
22:10:03 <Bynbo7> you don't understand functors and you're writing an MMO? -_-
22:10:05 <jfischoff> Chaze: this a lib for that if you want
22:10:15 <jfischoff> Chaze: there is a lib I mean
22:10:19 <lispy> jfischoff: the funny thing about oleg is that his stuff is totally reasonable once you wrap your mind around it.  It can seem foreign, spend time with it and then it's like, "oh yeh, duh.  I can't see any other way that things would make sense."
22:10:31 <accel> lispy: where is Oleg's blog?
22:10:33 <Chaze> jfischoff: probably, but i'd rather try to figure this out myself.
22:10:46 <Chaze> ..or preferebly, with the help of someone in here :P
22:10:46 <jfischoff> lispy: that's comforting actually
22:10:51 <Bynbo7> Chaze: you don't really seem to be using max
22:10:53 <jfischoff> Chaze: cool
22:11:05 <lispy> accel: here is the haskell centric part: http://okmij.org/ftp/Haskell/index.html
22:11:10 <lispy> ?olegfact
22:11:10 <lambdabot> Unknown command, try @list
22:11:14 <lispy> ?quote olegfact
22:11:14 <lambdabot> No quotes match.
22:11:16 <accel> http://okmij.org/ftp/ man; taht is a ahrd to use UI
22:11:20 <lispy> ?quote oleg
22:11:21 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
22:11:29 <lispy> ?quote oleg
22:11:29 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
22:11:29 <Chaze> Bynbo7: in the last line, i do
22:11:32 <lispy> ?quote oleg
22:11:32 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
22:11:38 <lispy> ?quote millioleg
22:11:38 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
22:11:42 <lispy> ?quote millioleg
22:11:42 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
22:11:59 <Bynbo7> Chaze: why do you set max to 1? in the recursive case, max is always 1
22:12:58 <Chaze> i subtract k from n, then with the remaining (n-k), i need the whole thing
22:12:59 <Chaze> don't i?
22:14:14 <lispy> accel: Oleg is a world export on continuations
22:14:16 <Bynbo7> i don't really understand what the algorithm is supposed to do really
22:14:28 <lispy> accel: so when you're ready to learn about those, hit up his articles
22:14:57 <lispy> accel: he also does things with the Haskell type system + type classes that people once thought to be impossible
22:15:15 <Chaze> Bynbo7: well, i read up on the 'partion function', which gives the number of ways of writing n as a sum of positive integers
22:15:22 <Chaze> partition*
22:15:22 <dmwit> Chaze: What is the type of k? What is the type of j? After stating those, ask: does (k : j) make sense?
22:15:26 <lispy> accel: I think he may have been the first to realize that type classes in Haskell have a natural correspondence to prolog
22:15:49 <Chaze> k is a number, j is a list
22:15:49 <lispy> accel: once you see the intuition behind his stuff, it cannot be unseen
22:15:53 <Chaze> the types are correct
22:15:57 <Chaze> but i'm missing something
22:17:02 <accel> lispy: link to article on typeclsses / prolog ?
22:17:51 <lispy> accel: I don't know a specific reference for that.  It comes out as commentary in some of his papers, but I forget which ones.  You really can't go wrong reading his papers, getting lost in the meanings, and then asking us for help understanding them.
22:18:16 <lispy> accel: probaly the HList paper?
22:18:34 <lispy> accel: http://homepages.cwi.nl/~ralf/HList/
22:19:38 <Chaze> alright, the anchor was of a bit: instead of | max > n = []
22:19:42 <Chaze> it has to be | max > n = [[]]
22:23:26 <Chaze> ah, i think i misunderstood http://en.wikipedia.org/wiki/Partition_%28number_theory%29#Intermediate_function
22:23:49 <Chaze> the values for the intermediate function are not disjunct as a iterate k
22:35:49 <jfischoff> lispy: I'm reading your blog and I am in agreement with we should be building proofs from properities
22:36:19 <jfischoff> lispy: have you read this hybrid type checking paper? slang.soe.ucsc.edu/cormac/papers/toplas09.pdf
22:37:45 <lispy> jfischoff: no I haven't thanks for the refrence, I'll put this on my kindle
22:38:33 <lispy> jfischoff: I'm a huge fan of "pay as you go" methodologies
22:39:19 <jfischoff> lispy: Yeah, I wish we could specify the domain exactly for our function with regular types, but we can't so something is better then nothing
22:40:14 <lispy> jfischoff: Right, it's weird that Haskell doesn't have an efficient way to define Nat other than using Word32, Word8, etc
22:40:29 <jfischoff> lispy: the most interesting idea in that paper, was that the you could send data back from program to help the compiler deduce stuff in the future
22:41:18 <jfischoff> lispy: yeah, nats are so basic to comp sci, its surprising how little support there is for them although, there is support in HEAD now
22:41:22 <lispy> jfischoff: Steve Yegge thinks we should use probability theory with type checking, but I have yet to figure out how that can be sound.  Not that I think he's 100% wrong, I just don't know how to answer his question.
22:41:37 <jfischoff> lispy: I think so too
22:41:38 <lispy> jfischoff: ah yeah, Iavor's stuff.  Isn't that amazing?
22:42:05 <jfischoff> lispy: yeah, saw on github and thought it was a mistake
22:42:19 <lispy> hehe, I sit next to him at work so I knew it was real :)
22:42:31 <jfischoff> lispy: back to the probability. This is how I would do it...
22:42:39 <jfischoff> lispy: oh cool, tell him thanks
22:42:45 <lispy> will do
22:43:41 <jfischoff> lispy: annotate your types will probability list distribution, i.e. its a list with average length 6, and Gaussian
22:44:41 <lispy> oh, so you could know/infer that it's always list.  But the length could be based on observation.
22:45:10 <lispy> seeing someone call it with a list of length that is an outlier could be a warning?
22:45:25 <jfischoff> lispy: you'd start by saying what your expectations are, ahnd then profiling or other data would update it
22:45:58 <jfischoff> lispy: so later you could use that data to build optimal data structures and triage potential issues
22:46:29 <jfischoff> lispy: like this should be packed in a few Word32 and "lets look at this unlikely input"
22:46:46 <lispy> hmm
22:47:03 <lispy> Normally profiling is downstream from source
22:47:10 <lispy> But you want a feedback loop
22:47:25 <lispy> I wonder how that could integrate with VCS
22:47:25 <jfischoff> well there is already a feedback loop
22:47:30 <jfischoff> its just by us
22:47:32 <jfischoff> manually
22:47:41 <lispy> The compiler could open a branch and modify code on that branch based on what it learns
22:47:58 <hjkkh> 5 + 7 lol
22:48:10 <jfischoff> lispy: yeah there are alot of ways
22:48:11 <lispy> > 5 + 7
22:48:11 <lambdabot>   12
22:48:37 <lispy> jfischoff: I always think of how to bring it back to vcs :)  Too many days spent hacking on darcs :)
22:48:46 <jfischoff> lispy: but even without profile guide updates, which is ideal, just incorporating our expectations would be useful
22:49:03 <lispy> yes, machine checkable documentation, ftw
22:49:11 <jfischoff> lispy: I think that is the end goal right
22:49:30 <jfischoff> lispy: if it passes your test autocheck it in, or something like that :)
22:50:07 <lispy> Yeah, in the future I think testing will automation will just get better.  So that might be a reasonable bet.
22:50:11 <jfischoff> lispy: here is the other thing, like a prob dist, you can autogenerate arbitrary functions better
22:50:22 <jfischoff> lispy: I hope so
22:50:53 <jfischoff> lispy: sometimes I feel like if there was LESS money in software, our tools would be better
22:51:07 <lispy> how so?
22:51:43 <jfischoff> lispy: when I have worked at companies that were killing it, they just throw more people at problems
22:51:54 <Adamant> sometimes necessity is the mother of invention
22:52:03 <jfischoff> lispy: exactly
22:52:06 <Adamant> other times it's the father of crude hacks
22:52:16 <othiym23> just look at the Ruby / Rails community
22:52:19 <jfischoff> Adamant: true
22:52:32 <jfischoff> rails is good or bad?
22:52:34 <mkscrg> How do I annotate an [Int] field in a record to be evaluated strictly?
22:52:36 <othiym23> tons of money getting thrown at a community, and it's hard to say whether it's benefitting or harming the community
22:52:42 <mkscrg> ![Int] doesn't seem to cut it
22:52:45 <jfischoff> ah
22:52:52 <othiym23> Rails is awesome, but there's a lot of shysters and hucksters involved, though
22:52:55 <lispy> mkscrg: ![Int] only forces the first cons of the list
22:53:00 <Adamant> othiym23: I suspect it's doing both.
22:53:07 <othiym23> Adamant: probably
22:53:30 <mkscrg> lispy: Am I forced to use deepseq, or somesuch?
22:53:43 <lispy> mkscrg: with [Int] there are at least three levels of eval you can do.  Evaluating the first cons.  Evaluating all the cons (but not the elements) and evaluating the spine plus the elements
22:54:07 <mkscrg> Right. I need to do the third.
22:54:23 <Adamant> lispy: that's an interesting idea
22:54:26 <lispy> mkscrg: DeepSeq (NFData?) is reasonable then
22:54:39 <lispy> Adamant: wait, what is?
22:54:50 <Adamant> lispy: at least, running known common probability distributions against things is probably a good idea
22:55:01 <Adamant> probablistic checking stuff
22:55:13 <lispy> ah.  Well, soundness is the trick.
22:55:14 <jfischoff> sweet we're back to that!
22:55:28 <Adamant> yeah, it's not general.
22:55:29 <lispy> Being honest about when you *know* something vs when you are sure about it
22:55:59 <Adamant> paraconsistent logics for the weird
22:56:07 <jfischoff> yeah, if you want to get precise that is good, but anything is better where we are now
22:56:08 <lispy> heh
22:56:33 <jfischoff> we should atleast give the compiler some sense of our expectations
22:56:40 <lispy> Dependent types are a nice goal, but maybe we don't need them and we can just approximate them
22:56:58 <hjkkh> ipad, android tablet or playbook?
22:57:17 <Adamant> orbital nuclear strike
22:57:23 <lispy> hjkkh: ipad is better than archos at the moment.  I haven't seen playbok.
22:57:25 <Adamant> oh wait, that wasn't an option :(
22:57:42 <hjkkh> i like you adamant
22:57:43 <Adamant> if we can't be sure, I would go with Android tablets
22:57:50 <hjkkh> you seem real nice
22:57:53 * lispy suspects hjkkh is a bot
22:57:54 <jfischoff> nice talking to you guys, gotta go
22:57:57 <hjkkh> im not
22:57:59 <lispy> jfischoff: cheers
22:58:07 <jfischoff> lispy: cheers
22:58:24 <Adamant> hjkkh: sorry, i just dislike the current crop of tablets
22:58:24 <hjkkh> cheers?
22:58:30 <Adamant> they're actually pretty cool
22:58:35 <hjkkh> what is your name?
22:58:43 * lispy is even more sure
22:58:45 <Adamant> yah
22:58:51 <Adamant> that was a little too obvious
22:58:55 <hjkkh> why
22:58:59 <dmwit> mkscrg: Might be worth writing a hand-rolled specialized strict list, rather than trying to remember to litter deepSeq in all the right places.
22:59:15 <hjkkh> im not a bot because i can answer any question you give me
22:59:21 <dmwit> mkscrg: e.g. data IntList = Nil | Cons !Int !IntList
22:59:22 <lispy> dmwit: using a smart constructor to get strictness?
22:59:26 <hjkkh> that probs sounds like im a bot
22:59:30 <hjkkh> but im not
22:59:51 <lispy> hjkkh: are you interested in learning haskell?
23:00:18 <hjkkh> i actually came here because i heard the coffee was great but sure, i'll learn haskell if you want
23:00:23 <lispy> dmwit: okay. For some reason my mind didn't go there, but that looks like it would work :)
23:00:43 <Adamant> lispy: it's a trick. one of Watson's sockpuppet accounts. get an axe.
23:00:45 <Adamant> :P
23:00:51 <lispy> hjkkh: heh.  Who told you our secret?
23:01:01 <mkscrg> dmwit: Good call, but using deepSeq is pretty simple here. It's just a record update where one Int in a [Int] is incremented
23:01:46 <lispy> dmwit: given the way ! works in Core, it deepSeq may actually be fewer evaluations in this case
23:01:54 <hjkkh> i hired a private detective to investigate after I saw the one on house get with the cutty chick and then house got with the cutty chick so i thought that if i hired 1 i would get a girl like cutty
23:02:13 <lispy> Adamant: I have to admit, it's good
23:02:19 <Adamant> it is
23:02:25 <Adamant> someone knows a little psychology
23:02:26 <lispy> Adamant: But it's in the uncanny valley
23:02:36 <Adamant> yup
23:03:12 <lispy> hjkkh: I like pizza
23:03:48 <hjkkh> what flavour?
23:04:12 <dolio> Cutty, eh.
23:04:17 <Adamant> hjkkh: sardine and salmon roe.
23:04:37 <lispy> dolio: some people are into blood letting
23:04:42 <hjkkh> sounds exotic, but i guess i should expect that from you
23:05:02 <lispy> hjkkh: can you help me with this double integral?
23:05:15 <lispy> hjkkh: the jacobian is really hard to compute
23:05:19 <dmwit> hjkkh: Let's use "whargarbl" instead of "I". Whargarbl guess whargarbl would believe you weren't a bot if you responded appropriately to this.
23:05:31 <hjkkh> i can try, at school i did 3x3 simultaneous equations and i found it easy
23:06:20 <hjkkh> honestly every response i come up with sounds like a bot doesnt it
23:06:43 <hjkkh> ask me a general knowledge question that a bot wouldn't know the answer to, if thats possible
23:07:32 <lispy> hjkkh: I_D (I (dx dx) / (x^2 + y^2)^2), where I = integral
23:07:39 <lispy> er, dx dy
23:07:45 <Adamant> ruler ruling rules rules. how many instances of "rule" in that sentence?
23:07:53 <lispy> and |x| + |y| >= 1
23:08:44 <hjkkh> im guessing that rule is in ruling because it is the root word maybe but if thats true then 4 but i think its a trick question so im gonna lock in....3
23:09:02 <hjkkh> can i use a life line?
23:09:09 <Adamant> hmm.
23:09:34 <lispy> hjkkh: hmm...you may be real after all
23:09:37 <Chaze> in case anyone cares: i finally got my partition function down :) http://hpaste.org/44108/produce_partions
23:09:40 <Adamant> answer dmwit's question
23:09:56 <hjkkh> lispy: is that calculus?
23:10:04 <lispy> hjkkh: well yeah
23:10:10 <lispy> hjkkh: it's a double integral
23:10:22 * dmwit concludes: not a bot
23:10:29 <hjkkh> ok i dont take calculus because i am a bot
23:10:36 <hjkkh> just kidding
23:10:38 <lispy> hjkkh: I don't even think wolfram's mathematica can solve it without help :)
23:10:55 <dmwit> Even though he didn't answer my puzzle, which I believe with absolutely no bias was the best of all of them. =P
23:10:57 <Adamant> dmwit: probably not, although some bots are human-assistend
23:11:12 <Adamant> dmwit: it was good :)
23:11:33 <hjkkh> what was the question
23:11:45 <hjkkh> dmwit
23:11:53 <lispy> hjkkh: so I guess some apology is due.  Sorry for thinking you were a bot.  We don't normally harass new comers :)
23:11:57 <Adamant> member:hjkkh: Let's use "whargarbl" instead of "I". Whargarbl guess whargarbl would believe you weren't a bot if you responded appropriately to this.
23:12:00 <Adamant> yes
23:12:03 <Adamant> sorry :{
23:12:05 <Adamant> :P
23:12:19 <hjkkh> i guess im not a bot then lol
23:12:40 <Adamant> "you made some good points.... I don't even know anymore"
23:12:47 <lispy> Your own doubt about being a bot may be your most human characteristic to date....hmm
23:13:07 <dmwit> I wonder how I would prove I wasn't a bot, if that ever came up.
23:13:16 <hjkkh> can you harrass me, honestly its 8:39 at night and i need something to do
23:13:32 <hjkkh> do you still think im a bot
23:13:50 <dmwit> Well, there's always Project Euler.
23:14:23 <hjkkh> nothing like a website dedicated to the fascinating world of mathematics and programming
23:14:26 <lispy> hjkkh: No I don't think you're a bot, but I'm curious.  Are you learning haskell or otherwise interested in it?  Most people here are here because of an interest in Haskell.
23:14:49 * dolio is here because he's interested in Eddie Haskell from Leave it to Beaver.
23:14:58 <dmwit> Or you could git clone http://dmwit.com/connexus/ and tell me how awful my game-in-progress is. =)
23:14:59 * lispy bans dolio 
23:15:00 <hjkkh> i told you, im here because i heard the coffee was much better than starbucks and also because i want to make people laugh
23:15:26 <lispy> dmwit: have you heard of #haskell-game yet?
23:15:35 <dmwit> I'm in it. =)
23:15:38 <hjkkh> *hjkkh sips coffee
23:15:58 <hjkkh> *sips coffee
23:16:01 <lispy> hjkkh: k.  That sounds more like #haskell-blah, FWIW
23:16:05 <lispy> dmwit: cool
23:16:30 <lispy> dmwit: sorry, so what type of game is it?
23:16:34 <hjkkh> how do you get rid oh my name and just have *hjkkh sips coffee?
23:16:41 <dmwit> Haven't touched it since Hac Phi 2, though, so... I probably don't technically qualify as a #haskell-gamer.
23:16:49 <dmwit> It's a stupid puzzle game.
23:16:59 <lispy> dmwit: I got that much from the .cabal file :)
23:17:12 <dmwit> oh
23:17:21 * dmwit reads the .cabal
23:17:28 <hjkkh> like that ^
23:17:40 <dmwit> "a small puzzle game"
23:17:41 <dmwit> lol
23:17:54 <lispy> dmwit: if it's by you, I doubt it's as lame as you say
23:17:59 <dmwit> Uh, the goal is to connect every square to the center server.
23:18:01 <lispy> so I demand a better description :)
23:18:12 <dmwit> You can rotate the piece on any grid point.
23:18:17 <hjkkh> do you like the smell of your own farts
23:18:26 <lispy> dmwit: so, like tetris on a graph?
23:18:39 <dmwit> um
23:18:48 <dmwit> Not really. I'm not sure how to explain it.
23:19:10 <lispy> hjkkh: the reason I mention #haskell-blah is that we have certain requirements about being on topic but #haskell-blah has no such requirement.
23:19:11 <dmwit> It's like a grid of optical fibers, and a single laser source, and you have to line up all the fibers.
23:19:36 <hjkkh> come on mate, i'm trying to make you smile, give a guy a chance
23:19:49 <dmwit> I should really make a website / polish it up.
23:20:11 <lispy> dmwit: yeah, you should.  I'm on windows at the moment and on this machine my only haskell compiler is in a vm so I'm slow to try your code
23:20:19 <dmwit> Maybe I'll set aside some Haskell time next week and get back into some of these old projects. =P
23:20:26 * dmwit nods
23:20:28 <lispy> cool!
23:20:32 <dmwit> gtk2hs on Windows is always a joy, too.
23:20:33 <lispy> I would like that :)
23:20:57 <hjkkh> lispy: i made you smile :)
23:21:02 <lispy> I'm trying to get back into hacking when I'm not at work
23:21:19 <lispy> Currently I only do hacking for $job and frankly, that's lame.
23:21:27 <dmwit> yeah
23:21:34 <lispy> I mean, I like my work, it's just lame that I don't do hobby stuff too
23:21:53 <dmwit> I feel kind of crappy about it, but now that I'm an adult, I can't deny that there are more "other" things that need to get taken care of, too.
23:21:56 <hjkkh> im gonna head off now, thanks for the coffee @everyone
23:21:57 <lispy> hobby coding is a nice way to learn and explore
23:22:03 <lispy> hjkkh: see ya
23:22:08 <Adamant> lispy: maybe keep it unrelated to work?
23:22:10 <dmwit> cheers, hjkkh
23:22:20 <Adamant> that can increase motiviation
23:22:22 <hjkkh> i love you guys, wanna be my roomate
23:22:26 <lispy> Adamant: Yeah.  I have one project that is work related, but I need to do more of what you say.
23:22:43 <Adamant> lispy: I've already done the burnout thing one and a half times
23:22:51 <lispy> Adamant: heeh. yeah.
23:22:58 <lispy> My masters was a burnout
23:23:08 <hjkkh> im really sorry but im gonna spam you now, i know you'll just laugh tho
23:23:13 <lispy> Working full time + writing thesis == exhausted
23:23:30 <hjkkh> dsifh
23:23:31 <hjkkh> hsdf
23:23:32 <hjkkh> h
23:23:33 <hjkkh> h
23:23:34 <hjkkh> g
23:23:34 <hjkkh> h
23:23:35 <hjkkh> h
23:23:35 <hjkkh> h
23:23:36 <hjkkh> h
23:23:37 <hjkkh> h
23:23:37 <hjkkh> h
23:23:38 <hjkkh> h
23:23:38 <hjkkh> h
23:23:38 <hjkkh> h
23:23:39 <hjkkh> h
23:23:39 <Adamant> once due to tech in general or and once because I realized I need to get a new profession or it was going to drive me up the wall.
23:23:39 <hjkkh> h
23:23:40 <hjkkh> h
23:23:41 <djahandarie> @ops
23:23:41 <lambdabot> Maybe you meant: docs oeis pl
23:23:44 <djahandarie> @where ops
23:23:44 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:23:44 <hjkkh> h
23:23:45 <hjkkh> h
23:23:46 <hjkkh> h
23:23:47 <hjkkh> h
23:23:48 <hjkkh> h
23:23:48 <hjkkh> h
23:23:49 <hjkkh> h
23:23:50 <hjkkh> h
23:23:51 <hjkkh> h
23:23:51 <hjkkh> h
23:23:53 <hjkkh> h
23:23:55 <hjkkh> ban me!
23:23:56 <hjkkh> h
23:23:57 <hjkkh> h
23:23:58 <hjkkh> h
23:23:59 <hjkkh> h
23:24:03 <hjkkh> i cant take it anymore
23:24:05 <hjkkh> h
23:24:05 <hjkkh> h
23:24:05 <hjkkh> h
23:24:05 <hjkkh> h
23:24:05 <hjkkh> h
23:24:06 <hjkkh> h
23:24:06 <hjkkh> h
23:24:06 <hjkkh> h
23:24:06 <hjkkh> h
23:24:07 <hjkkh> h
23:24:07 <hjkkh> h
23:24:08 <hjkkh> h
23:24:24 <Adamant> IRC account suicide by op?
23:24:31 <dmwit> Neat, we didn't even need an op.
23:24:33 <djahandarie> :P
23:24:34 <Adamant> yah
23:24:43 <othiym23> doesn't he realize that #haskell is serious business?
23:24:50 <lispy> othiym23: srsly
23:24:55 <Adamant> much like the Internet at large
23:24:56 <dmwit> Or is "Excess Flood" more manual than it sounds?
23:25:05 <Adamant> I think it's automatic
23:25:07 <lispy> dmwit: too much work!
23:25:09 <djahandarie> It is automatic.
23:25:10 <dmwit_> hi
23:25:12 <lispy> This #haskell thing should be lazy.
23:25:16 <dmwit_> im a loller
23:25:24 <dmwit_> and now im gonna spam again
23:25:29 <dmwit_> ban me please
23:25:30 * dmwit notes that dmwit_ does not have +i, and is therefore not the true dmwit_
23:25:48 <dmwit_> you got me
23:25:50 <dmwit_> i gtg by
23:25:53 * lispy nods, dmwit_ has the same /whois as hjkkh
23:25:54 <dmwit_> *bye
23:26:02 <dmwit_> you got me
23:26:04 <Adamant> the true dmwit cannot be spoken of.
23:26:11 <dmwit_> did i make you smile?
23:26:14 <dmwit_> at all?
23:26:27 <xarch> no
23:26:34 <lispy> Adamant: I want to make a database in Haskell
23:26:38 <Chaze> is there something more elegant to case a of {True -> 1; False -> 0}
23:26:47 <lispy> Adamant: and a nice fun multiplayer 2d rpg game
23:26:49 <Adamant> lispy: relational algebra based?
23:27:00 <xarch> if a then 1 else 0 :>
23:27:08 <lispy> Adamant: I'd settle for SQL compatible actually.  I was thinking to make it formally verified via Isabelle
23:27:17 <Chaze> xarch: that's not so much better :(
23:27:21 <Adamant> you could subset SQL to get that
23:27:33 <xarch> well
23:27:33 <lispy> Adamant: So, the goal isn't performance (although that would be a secondary goal) but instead make it proveably correct
23:27:35 <Adamant> the real problem would be efficency, as a first guess
23:27:38 <Adamant> yeah
23:27:51 <dmwit> > map fromEnum [False, True] -- Chaze
23:27:52 <lambdabot>   [0,1]
23:27:59 <othiym23> lispy: if you make your DB use Tutorial D for its query grammar I'll be your friend
23:27:59 <xarch> you can't do better, I think
23:27:59 <kernoil> what is haskell
23:28:03 <lispy> Need a performant and provably correct data store?  Okay, use hDB
23:28:13 <Chaze> dmwit: right, i remember!
23:28:18 <Adamant> ACID
23:28:20 <othiym23> I keep trying to do something similar, and bootstrapping the type system makes my head explode every time
23:28:20 <lispy> othiym23: What is this Tutorial D?
23:28:35 <Adamant> lispy: never read Date/
23:28:36 <Cale> kernoil: It's a functional programming language
23:28:50 <othiym23> lispy: CJ Date's DSL for the relational algebra and calculus
23:28:50 <Cale> http://haskell.org/haskellwiki/Haskell
23:28:53 <lispy> Cale: !  I'm happy to see you
23:28:56 <Adamant> lispy: if you haven't, you should
23:28:59 <Cale> lispy: hello
23:29:13 <othiym23> lispy: _Databases in Depth_ is a nice, terse read on it
23:29:20 <lispy> Cale: I upgraded a bunch of stuff on the linode.  I'm thinking I should reboot at some point.  Does lambdabot start on boot automatically?
23:29:24 <Cale> no
23:29:25 <kernoil> can haskell do guis?
23:29:30 <Adamant> his intro books are nice as well
23:29:34 <Cale> kernoil: yep, it's general purpose
23:29:39 <kernoil> oh cool
23:29:40 <lispy> othiym23: thanks for the reference
23:29:44 <dmwit> kernoil: Yes, see gtk2hs, wxHaskell, and the QT bindings.
23:29:55 <othiym23> Adamant: that's what _Databases in Depth_ is, it's ~160 pages and has lots of great / fun exercises
23:29:58 <lispy> Cale: are you totally burnt out and spent on running lambdabot ?
23:30:01 <othiym23> I think they're fun, at least
23:30:04 <othiym23> but I'm a nerd
23:30:12 <Cale> lispy: It's still running isn't it? :)
23:30:16 <Adamant> othiym23: I got one of his books for a DB course
23:30:24 <Adamant> quality
23:30:26 <djahandarie> Erg, was suppose to go to sleep
23:30:45 <lispy> Cale: yes it's running.  I just want to check in and make sure that you're not running it out of sheer obligation.  I know you have an amazing amount of patience, but I don't want to abuse you either.
23:30:52 <Cale> heh, it's all right
23:31:01 <Cale> The thing stays up on its own fairly well
23:31:16 <lispy> Yes, it seems to be more resource efficient than it was 2 years ago as well
23:31:30 <lispy> Which I can't figure out why
23:31:42 <Cale> New compiler :)
23:31:56 <lispy> Cale: how is your job going?
23:31:57 <Cale> (just a guess)
23:32:01 <Cale> Pretty good
23:32:15 <lispy> You're not here as much, so I guess that means they keep you buys
23:32:17 <lispy> busy*
23:32:51 <Cale> Yeah, well, they get most of my time spent thinking about programming anyway :)
23:33:01 * lispy nods
23:33:18 <dmwit> lispy and I were just discussing that phenomenon.
23:33:21 <lispy> I find that most technical people are only good for about 8-10 hours / day max
23:33:36 <lispy> Beyond 6 hours the rate of mistakes climbs
23:33:39 <Adamant> thinking is hard. let's go fishing.
23:34:16 <lispy> Testing is hard; let's go theorem proving
23:34:27 <Cale> I've also been picking up starcraft, so that eats into the free time :)
23:34:35 <lispy> nice
23:34:48 <lispy> Cale: stay away from minecraft :)  Nothing but pure addiction over there
23:35:14 <Adamant> Minecraft is leveraging our LEGO addictions into a new era
23:35:21 <lispy> yeah...
23:35:35 <lispy> I finally tried it and wow, I <3 that game
23:35:49 <Adamant> i tried it and I've been trying to limit my time
23:35:54 <lispy> hehe
23:35:55 <Adamant> I like it too much already
23:35:59 <Adamant> I can tell
23:36:09 <lispy> We should have a #haskell server
23:36:26 <othiym23> Starcraft is pretty much the gaming equivalent to hacking on monads: it's brain-expanding but it also tends to be self-limiting as a time suck
23:36:32 <othiym23> especially if you spend much time on the ladder
23:36:49 <othiym23> I can play about 8 games a night / weekend day before I need to vegetate for a while
23:37:05 <cads> I"m like that with chess
23:37:19 <Cale> Yeah, but there's seemingly no limitation on the amount of watching other players play starcraft that I can consume.
23:37:25 <cads> what is special about mindcraft?
23:37:29 <Adamant> Fallout is my anti-drug
23:37:36 <cads> aside from it being turing complete-ish :)
23:37:48 <lispy> cads: it's a very creative game in that there are basically unbounded resources and it's up to you to think of ways to combine them
23:37:51 <othiym23> Cale: well, yeah
23:38:04 <Adamant> cads: unlimited LEGO set. monsters to fight if you want them. collaboration.
23:38:18 <othiym23> I've been unemployed for the last few months and most of my non-job searching time has been spent either hacking or watching the GSL
23:38:30 <cads> lispy: what kinds of goals do people get to have in the game?
23:38:32 <Cale> othiym23: day9?
23:38:43 <Adamant> cads: whatever you want
23:38:48 <Adamant> it's like zombo.com
23:39:01 <othiym23> Cale: Funday Mondays when they sound promising, Newbie Tuesdays when it's not totally remedial
23:39:07 <lispy> cads: that's a good point.  The game doesn't really encourage much other than basic survival.  But, then in the multiplayer servers people like to "compete" to make cool forts and other structures
23:39:13 <cads> so it's as limitless and mind expanding as an empty sheet of paper?
23:39:21 <othiym23> Cale: I like him better when he's analyzing than when he's trying to do live commentating, though
23:39:25 <Cale> yeah
23:39:25 <othiym23> I prefer his brother for live stuff
23:39:42 <Adamant> not quite, but it's like a virtual LEGO Mindstorms set you can share with friends over the tubes.
23:40:12 <cads> hehe, can I make money with it?
23:40:15 <othiym23> did that guy ever finish his Minecraft Starship Enterprise?
23:40:17 <Adamant> not yet
23:40:21 <Adamant> you can make money in it
23:40:26 <Adamant> but it's game money
23:40:35 <Adamant> and no big economy
23:40:37 <Adamant> wait
23:40:41 <lispy> cads: you could probably make money from cheap server hosting, but I don't know of any other ways to make money off minecraft other than being notch (the author)
23:40:47 <cads> heh, I want a virtual laboratory
23:40:50 <Adamant> I can't remember if there's money in game
23:41:06 <Cale> Did you see the recent one on constant queen production? That was pretty interesting. (I play protoss, but for some reason, I end up watching a lot of zerg play)
23:41:09 <Adamant> cads: write a FEA simulator
23:41:20 <lispy> Adamant: no money in game, but you could trade for items.  If you were good at finding diamond other players would want that, for eexample
23:41:32 <cads> Adamant: I meant a scifi looking minecraft laboratory :)
23:41:39 <Adamant> ah :P
23:41:47 <Adamant> FEA is still pretty sci-fi to me
23:42:20 <Adamant> people build some impressive stuff
23:42:24 <othiym23> Cale: yes, and I enjoyed it, although it wasn't as nuts as a couple from last fall
23:42:36 <othiym23> I play Random, which is why I'm still Bronze, but I don't care
23:42:43 <cads> Adamant: feas looks too unimposing these days
23:43:03 <othiym23> it's an absorbing little tinker-toy set for strategy and it makes me more efficient at using my computer, or so I rationalize to myself
23:43:06 <Adamant> cads: you might be able to write an extension for Minecraft at some point
23:43:22 <cads> Adamant: it used to be arcane badly tesselated triangulations displayed in black and white on low resolution jagged displays
23:43:46 <lispy> Adamant: a guy I work with (glguy) wrote a proxy in Haskell for minecraft that lets you see through blocks.  It's on github
23:43:49 <Adamant> cads: talking to engineer friends, it sounds like there are some FEA's that still need to be written
23:43:53 <Adamant> ah
23:44:03 <Cale> I'm still rated bronze, but I need to play more 1v1 random. There was a long period where I was mainly playing with people from in-game chat, and I'm pretty sure that I'm somewhere in the gold-platinum range.
23:44:15 <Cale> My bonus pool is up around 2000
23:44:18 <othiym23> wow, Data.Char.isUpper works properly on Cyrillic
23:44:20 <othiym23> that surprises me
23:44:26 <othiym23> Cale: keep telling yourself that ;)
23:44:30 <cads> Adamant: It would be amazing to have one that endows a game with actual laboratory strength physics
23:44:42 <lispy> othiym23: that's because Char in haskell is a unicode codepoint
23:44:44 <Cale> othiym23: Well, I beat my friend in diamond about 1/3 of the time
23:45:01 <othiym23> I think if I chose a race and stuck with it for a while, I could probably get out of Bronze, but I react... poorly when I get 6 pooled
23:45:03 <cads> Adamant: for the express purpose of giving people tools to engineer real objects using a game
23:45:35 <Adamant> cads: Gerry's Mod and such aren't quite there yet
23:45:42 <othiym23> lispy: I knew that, I just didn't know that it had enough of the guts in place to do proper recognition of non-Latin cases
23:45:45 <Adamant> but there are physics sandbox games out there already
23:45:53 <Adamant> 3D complicated ones
23:46:19 <cads> Adamant: I've seen some very awesome looking machine simulators
23:46:24 <lispy> minecraft hits a sweet spot between realism and lego
23:46:48 <lispy> having multiplayer though may be the most engrossing bit
23:46:48 <Adamant> the graphics card companies have started modifying their GPGPU's to support physics code increasingly
23:46:56 <othiym23> ahhhh... libunicode, that makes sense
23:46:59 <Cale> othiym23: Yeah, I'm getting better about handling that sort of early-game aggression, but it's still a bit of a problem. I need to work out timings for a build with an early forge so that I have a decent plan instead of winging it when I scout a 6 pool.
23:48:06 <othiym23> Cale: what's "hilarious" is getting worker rushed, which is almost incentive on its own to get the hell out of bronze
23:48:16 <othiym23> I can fight it off, but it makes for tedious games
23:48:54 <Cale> heh, the 12 drone rush might actually be legitimate on steppes
23:50:05 <cads> Adamant: have there been any games that use distributed computing power provided by the users, that you know of?
23:50:33 <lispy> cads: interesting.  It's hard to trust clients.
23:50:36 <Adamant> only for running clients and hashcash-type stuff
23:50:41 <Adamant> unless you're doing serious games
23:50:50 <lispy> cads: seti@home does it but then it's allowed horrible latency and rechecking
23:51:00 <Cale> cads: http://video.google.com/videoplay?docid=-8246463980976635143 -- a talk about human computation
23:51:07 <Adamant> Cale beat me to it
23:51:20 <Adamant> there are attempts to use people as a computational element
23:51:27 <lispy> "Cale beat me to it" a phrase common whisphered in #haskell
23:51:29 <Adamant> beyond the Mechanical Turk type stuff
23:51:46 <Veinor> haha
23:51:49 <Bynbo7> there's an interesting protile folding game, where you have to fold protines to match a specific shape, and the best ones act5ually get used for further testing
23:51:55 <Adamant> gah, I have puny limited human hands and they must scream
23:52:40 <lispy> Adamant: you're like a human sized trex? :)
23:53:09 <Adamant> aktually my arms are long-ish. I just can't type that fast.
23:53:10 <kernoil> how do i make a new class?
23:53:12 <cads> I was thinking about the work it'd take to factor out most of the drudgery in basic, say, data sorting tasks, such that the task is more or less challenging and pleasant
23:53:15 <Bynbo7> uh, protine, not pritile -_-
23:53:26 <cads> it seems like this guy has though about all sorts of stuff like that :)
23:53:38 <kernoil> how do i make a new class in haskall
23:53:48 <Adamant> kernoil: it's not OO based
23:54:00 <kernoil> what?
23:54:12 <kernoil> where do i start my program then?
23:54:19 <Adamant> Main
23:54:32 <kernoil> shouldn't that be a static of a class tho?
23:54:46 <Cale> http://www.youtube.com/watch?v=lGYJyur4FUA
23:54:47 <othiym23> kernoil: in an OO language, yes
23:55:05 <lispy> kernoil: heh, no.  classes in haskell are used to group types togetehr
23:55:08 <Adamant> no, Main is a hook to start executing your program
23:55:31 <lispy> kernoil: type class in haskell == set with a common interface
23:55:59 <lispy> kernoil: Are you reading RWH or LYAH?
23:56:48 <lispy> Haskell is easy to learn, but there are lots of potential wrong turns when getting started
23:57:01 <Adamant> kernoil: Haskell is both lazy and functional. if you're not used to that, it can take a bit to wrap your brain around it.
23:57:23 <kernoil> oh okay
23:57:29 <lispy> Adamant: yeah, I'm lazy and dysfunctional so it takes me a while to get started :)
23:57:40 <Bynbo7> step #1: forget all Java
23:57:50 <Adamant> so you organize things by functions, and these functions are like pure mathematical functions to a degree
23:57:58 <Jafet> That takes two days.
23:57:59 <Bynbo7> step #2: Forget everything you know about Object Oriented Programming
23:58:00 <Adamant> instead of by objects
23:58:17 <Bynbo7> step #3: Forget everything you know about programming
23:58:18 <lispy> kernoil: the closest we have to the classes you're used to are the what we call modules
23:58:18 <kernoil> how would haskell be useful for real programming then if it's not OO?
23:58:24 <Bynbo7> step #4: learn haskell
23:58:40 <othiym23> lispy: I'd argue that modules are closer to Java packages
23:58:56 <Bynbo7> kernoil: so C isn't a useful programming language?
23:58:58 <othiym23> a typeclass is kind of like a Java interface, although more declarative
23:59:02 <Adamant> the other thing is that while you use recursion in Haskell, it can be better to generate an "infinite" data struct and do things with that
23:59:17 <Adamant> kernoil: different paradigms are good for different things
23:59:20 <lispy> othiym23: modules are how achive implementation polymorphism.  Export all the same names but a completely different set of types and implementations.
23:59:21 <kernoil> Bynbo7: not anymore
23:59:24 <Bynbo7> i thought you could do real real programming in C, guess not
23:59:26 <kernoil> nobody uses it now
23:59:34 <Bynbo7> uh, I'm sorry, yes they do
23:59:35 <kernoil> i meant like new stuff
23:59:40 <kernoil> like iPhones apps
23:59:42 <othiym23> kernoil: Haskell is useful because it makes you think of problems in terms of *what* you want, rather than *how* you compute it
23:59:42 <Adamant> some, like imperative, OO, and functional, are quite general
23:59:52 <shachaf> lispy: Modules are a bit of an awkward way to do it, unfortunately. :-(
23:59:59 <lispy> shachaf: yes
