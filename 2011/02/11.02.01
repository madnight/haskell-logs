00:00:30 <twb> cheater-: http://www.traverse.com.au/, a hardware vendor
00:01:07 <cheater-> oh, i thought "traverse" was some funny term for "bridging" - i googled around for traverse with no useful result, hence the question
00:01:46 <twb> (Note: the viking is just a conventional crappy ADSL modem in a card form factor.)
00:01:57 <cheater-> nice - i wonder how much the geos stands for
00:02:09 <twb> cheater-: about AUD550
00:02:27 <cheater-> ow, that's a bit much now!
00:02:43 <twb> And you can't get them in 1RU yet :-/
00:02:56 <cheater-> i thought all you got was the card?
00:03:11 <twb> From them, yes.  cf. yawarra.com.au
00:03:56 <twb> I got a 1RU from them with a soekris net5501 and a solos
00:05:06 <cheater-> nice!
00:06:12 <twb> Kinda pricy, given it's only 4×100baseT
00:07:11 <twb> Bloody stupid that a WNDR3700 has a five-port programmable 1000baseT switch for AUD160, when a four-port 1000baseT PCI card is like four times that :-/
00:07:14 <cheater-> i'm guessing you use it for things like say running pf with regex
00:07:30 <wagle> @hoogle Data.Traversable
00:07:31 <lambdabot> module Data.Traversable
00:07:31 <lambdabot> Data.Traversable class (Functor t, Foldable t) => Traversable t
00:07:40 <twb> cheater-: well, -m recent.
00:07:58 <twb> xt_recent.ko, that is
00:08:25 <twb> If embdebian would get off its arse, I wouldn't need a 4GiB rootfs
00:08:56 <wagle> odd, don't find it on my ghc
00:08:59 <cheater-> xt_recent.ko?
00:09:34 <{aaron}> is there an easy way to convert a tuple to a list or otherwise access tuple values beyond the second?
00:09:44 <twb> cheater-: auto-blacklisting source IPs with high connection attempt rates, and auto-unblacklisting them when they stop.
00:10:18 <wagle> bah, they've encrypted the modules even more than before
00:10:22 <twb> {aaron}: (_:_:_:_x:xs) ?
00:10:24 <pozic> {aaron}: template haskell solved that 'problem'.
00:10:38 <twb> Oh, tuple
00:10:39 <kfr> {aaron} if the tuple is supposed to have a "variable size" you shouldn't be using a tuple really, if it has too many elements you might not want to use a tuple either, but a more structured data declaration
00:11:08 <{aaron}> well, it's fixed size, i suppose I could define a data type for it, but it is fairly transient
00:11:14 <pozic> {aaron}: and ntuple solves the problem too. 
00:11:23 <Axman6> {aaron}: no, don;t use tuples if you're going to put more than say three things in them
00:11:25 <pozic> {aaron}: without TH.
00:12:24 <pozic> 1 + (1,"ba", 'a') => 2 would also be an interesting language.
00:12:25 <Axman6> {aaron}: make a record
00:12:51 <pozic> I.e., a language in which you do selection by type.
00:12:56 <Axman6> pozic: and 'a' : (a,"ba",'a') -> "xba"?
00:13:03 <pozic> Axman6: right
00:13:28 <cheater-> twb: ah
00:13:30 <Axman6> yeah, i can't see that working out too well
00:13:32 <pozic> 1 + (2,2,2) => error "dude, use your brain"
00:13:42 <Axman6> or.. (3,3,3)
00:13:54 <pozic> Yes, or that, but that might become a bit too complicated.
00:16:35 <pozic> If every value has a different type, you don't need any selection functions anymore, I think. 
00:16:41 <{aaron}> ... record accessors are in a shared namespace...
00:17:45 <kfr> {aaron} yeah I hate that
00:17:49 <kfr> It's a really bad idea imho
00:19:14 <Axman6> {aaron}: they're exactly what you need here
00:20:10 <{aaron}> well, then i need to prefix them all so they don't conflict with identical names in another record
00:20:17 <kfr> I use them all the time but accessing records must really be made smarter because what people are doing right now is to resort to C practices
00:20:26 <kfr> The standard packages use C practices there, too
00:21:11 <kfr> data MyType = MyType { myTypeRecord1 :: Type1, myTypeRecord1 :: Type2, {- ... -} }
00:21:16 <kfr> Is a common sight in Haskell
00:21:38 <kfr> Woops, Record2* obviously
00:21:44 <Axman6> i was gonna say :P
00:25:11 <accel> @src init
00:25:11 <lambdabot> init [x]    = []
00:25:11 <lambdabot> init (x:xs) = x : init xs
00:25:11 <lambdabot> init []     = undefined
00:25:37 <accel> so init = everything except the last item?
00:25:50 <kfr> > init [1, 2, 3]
00:25:52 <lambdabot>   [1,2]
00:30:29 <geheimdienst1> accel, yes
00:32:35 <accel> http://hackage.haskell.org/trac/ghc/ticket/917 <-- why is this hard?
00:34:47 <Axman6> accel: when init gets run, it forces the entire spine of the list to be computed because last also needs that same list, meaning a hell of a lot gets allocated
00:35:30 <Axman6> oh actually, but sure why -O introduces a space leak. maybe it inlines things in an odd way
00:36:20 <accel> hmm,
00:36:43 <accel> does "length [1...N]" take O(1) or O(N) space ?
00:36:53 <Axman6> O(N), it has to
00:36:58 <c_wraith> uh.
00:37:03 <Axman6> uh, O(1) space, sorry
00:37:10 <Axman6> missed the space =)
00:37:29 <accel> so what optimization happens in ticket 917
00:37:36 <accel> that foreces it to be O(N) space? I missed that part
00:37:58 <c_wraith> the optimization is memoizing the list
00:38:26 <kfr> http://siyobik.info/pastebin_download.php?id=586 <- what's the problem with the configuration step here? I am puzzled, all the packages it demands are available
00:38:30 <Axman6> it's not memoising it, it's evaluating it, and because it's still referrenced, it can;t be GC'd
00:38:38 <Axman6> but, i'm not sure how that works here
00:39:05 <accel> Axman6: why can't be it gced?
00:39:12 <accel> the fast there is a "last" or the fact that it's in a case statement?
00:39:13 <Axman6> because it's still referenced...
00:39:28 <accel> Axman6: what references it?
00:39:30 <Axman6> the fact that last evaluates the entire spine of the list
00:40:03 <Axman6> hmm, yeah i don't get why -O breaks it
00:40:20 <accel> Axman6: if you can solve this problem, we can write a paper on it
00:40:35 <accel> where by "we write a paper" I mean "you do the work and attach me as co author"
00:54:51 <alex404> Is there any way to have a multiparameter class which automatically generates a record over some of the types?
00:55:02 <category> Do you, dear #haskell denizens, have any suggestions of good code for a new Haskell programmer to read? In terms of learning technique, style, etc.?
00:55:47 <alex404> category: Learn you a haskell is probably the best tutorial. After that statistics and XMonad I think are quite well designed.
00:56:31 <category> alex404: Yes, almost finished LYAH. Thanks for the suggestions.
00:58:37 <Axman6> category: Xmonad is often recommended
01:02:27 <accel> > 2^100
01:02:28 <lambdabot>   1267650600228229401496703205376
01:02:42 <accel> > 2^1000
01:02:43 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
01:03:29 <kfr> <alex404> Is there any way to have a multiparameter class which automatically generates a record over some of the types?
01:03:36 <kfr> Template Haskell perhaps?
01:06:06 <alex404> kfr: Right. Cheers.
01:08:21 <hvr> why does "cabal list" take so long? (~5 secs on my host)
01:08:51 <kfr> hvr: Because cabal was written by academics
01:09:02 <hvr> :-)
01:09:15 <kfr> I wasn't trying to be funny, that really is the reason.
01:10:43 <pozic> hvr: 1) Cabal is a mistake for about 90% 2) Cabal funding is non-existent. 
01:11:04 <hvr> pozic: why's 1)?
01:11:26 <pozic> hvr: because autoconf has shown that feature detection beats version detection. 
01:12:24 <kfr> I thought autoconf was widely looked down on :o
01:12:42 <category> autoconf may not be pretty, but it's highly effective. :o)
01:12:47 <pozic> kfr: that is just because of the languages which it uses that not many people master.
01:12:52 <ben> It's only so widely looked down on because everybody has to use it
01:12:56 <pozic> different => oh, then it must suck. 
01:13:18 <pozic> It is archaic, old, yes, but some of the ideas are better.
01:13:36 <pozic> Cabal was just the simplest possible solution at some point in time.
01:13:53 <pozic> It is my no means the best solution or a long term viable solution. 
01:13:53 <kfr> ben nobody has to use it
01:14:05 <kfr> category: It's extremely slow, I always considered it highly inefficient
01:14:10 <ben> But everything else is insufficient
01:14:36 <category> kfr: Oh, I said "effective", not "efficient". :o)
01:14:50 <pozic> Why does one need to run code on platforms that maybe 30 people on the planet run? 
01:15:08 <pozic> If they care so much, maybe they should just fix their platform to become compatible.
01:15:41 <pozic> Instead of accommodating everything in a compatibility swamp which the autotools offer.
01:16:05 <category> pozic: I used to port open-source code to Digital Unix. When use of autoconf became widespread, it was a real blessing. The relative homogeneity of the UNIX world is a rather recent development, remember.
01:20:10 <pozic> category: I remember that lots of stuff didn't even build on Linux, because the authors failed to specify which version of the autotools they required.
01:20:16 <Botje> they all run vim, gcc and haskell. who needs anything else >:)
01:21:46 <kfr> Botje: Visual Studio 2010
01:21:48 <kfr> And/or ed
01:23:53 <hvr> well, but cabal and autoconf are not really the same imho
01:24:05 <dcoutts> hvr, kfr: cabal list is slow for one reason, caching, or rather the lack thereof. It reads the whole ~20mb tarball, and if you're doing cabal list with no search terms then it has to parse about 1/2 the .cabal files in that 20mb tarball.
01:24:07 <hvr> cabal is more like the make component of automake
01:24:20 <hvr> + apt-get features
01:24:29 <hvr> imho
01:24:48 <dcoutts> pozic: strange, I thought autoconf has shown that package management was better than feature detection!
01:24:56 <hvr> dcoutts: I just checked, my .tar file is 33MiB :)
01:25:15 <dcoutts> hvr: ok, so it's getting slower and slower... :-)
01:25:16 <hvr> dcoutts: does 'cabal update' fetch the whole 33MiB .tar?
01:25:24 <dcoutts> hvr: but compressed
01:25:43 <dcoutts> and eventually I'll have to add an index
01:26:01 <dcoutts> it's slow for dep planning too, though not quite as bad
01:29:00 <hvr> dcoutts: on ubuntu systems you notice that 'cabal list' is slow, since there's a /etc/bash_completion.d/cabal scriptlet, that does tab-completion for 'cabal install <TAB>' :-)
01:29:13 <dcoutts> hvr: ah yes, we've turned that off :-)
01:29:19 <dcoutts> since it's sloooo
01:29:30 <dcoutts> in the next release I mean
01:29:50 <dcoutts> pozic: seriously, my take is that autoconf does what it does reasonably well, but it does not attempt to solve (or even really help with) package management which is where all the really impressive progress has been
01:30:24 <dcoutts> to turn an autoconf-ed package into a distro package requires reverse engineering the dependencies out of the autoconf ./configure script
01:30:47 <dcoutts> the ./configure script never tells you the dependencies (not in any automatic or machine readable way)
01:30:54 <dcoutts> it just says "no" or "yes"
01:31:10 <dcoutts> and does not tell you if it's operating in a degraded mode because it's missing some dependency
01:31:27 <dcoutts> all this information is missing, and has to be supplied manually by the person making the distro package
01:32:00 <pozic> dcoutts: and now it has to be supplied manually by whoever makes the cabal package.
01:32:07 <hvr> dcoutts: autoconf imho does solve a completely different problem than what cabal is meant to solve
01:32:28 <dcoutts> pozic: yes! by the package author. So it's done once and everyone else benefits from automatic dep resolution.
01:33:23 <dcoutts> hvr: I'm not sure that's entirely true. There are some aspects where they are incompatible.
01:33:30 <hvr> dcoutts: autoconf is about compensating for heterogenous software environments
01:33:54 <hvr> dcoutts: where no unified software registry is available and everything has to be probed for
01:34:11 <dcoutts> hvr: it's about adapting to an environment in which it is placed, vs stating facts about the environment which it expects.
01:34:32 <pozic> dcoutts: but stating facts is rather hard. 
01:35:04 <hvr> dcoutts: ...yes, that's what I was trying to state :)
01:35:16 <pozic> dcoutts: saying "ok, my program has to be able to write to stdout", running a small test to verify that and testing a few million other things with solutions is much more robust.
01:35:26 <dcoutts> hvr: and I think there is a continuum between the two
01:35:36 <pozic> dcoutts: it is future proof for example, which cabal packages are not.
01:35:54 <dcoutts> pozic: it's only future proof in as much as your feature tests are complete
01:36:49 <hvr> dcoutts: ...do you mean, that cabal could incorporate some of autoconf's ideas?
01:36:54 <dcoutts> pozic: I think in the limit the two approaches get very similar, "test if this C function is present"
01:37:13 <pozic> dcoutts: do you want to put all those tests in cabal?
01:37:24 <pozic> dcoutts: shared by all with a huge pile of code to maintain?
01:37:50 <pozic> You can do that, but your specs have to be extremely precise.
01:38:27 <dcoutts> pozic: I don't think it's necessary to be quite so precise in practice, the level of whole C libs is usually enough.
01:39:18 <pozic> dcoutts: there should be integration between GHC and cabal. 
01:39:27 <dcoutts> but in principle, I think the package management approach of specifying requirements should scale down to a finer level
01:39:35 <pozic> dcoutts: if one is able to compile a program on a machine, one should be able to automatically generate its cabal file.
01:40:01 <dcoutts> pozic: yes, I think that's mostly right, and would cover the simple stuff
01:40:06 <pozic> dcoutts: the compiler has verified that it is compilable, it knows which deps it is currently using, so it should simply generate a snapshot of that.
01:40:09 <dcoutts> like package dependencies
01:40:51 <pozic> Support for multiple arches is more complicated, but at least you can start with a simple structure and for 99% of the packages you don't need the complicated stuff, anyway. 
01:41:19 <pozic> If you would setup different build trees for different arches, you could simply build a foopkg-i686 package, etc.
01:41:42 <pozic> Hmm, that might be a bad idea.
01:44:43 <dcoutts> hvr: so the first thing we did in the direction of more flexibility/adaptability to the environment was to add these configuration flags in the .cabal file. They're carefully designed however to actually inform package managers about optional/conditional dependencies.
01:45:04 <dcoutts> rather than just be opaque functions from Environment -> Bool
01:45:38 <dcoutts> it's a trivial sort of logic language
01:46:05 <kfr> I'm surprised that it doesn't use Haskell
01:46:24 <dcoutts> kfr: that would not meet the requirements
01:46:55 <dcoutts> opaque function from env to maybe configuration is not enough
01:55:03 <magthe> community.haskell.org seems to have lost my ssh key, who should I contact to regain access to my account?
01:55:14 <Axman6> maybe Igloo?
01:55:32 <Axman6> dcoutts might know *poke*
01:55:34 <dcoutts> magthe: wait a bit
01:55:54 <dcoutts> most accounts have not had their access restored yet
01:56:29 <dcoutts> (by the sophisticated method of mv authorized_keys-disabled authorized_keys)
01:56:37 <kfr> lol.
01:56:45 <kfr> No authorized_keys2?
01:57:33 <magthe> dcoutts: ah, that would explain it... any ETA?
01:58:41 <dcoutts> magthe: the infra team is still checking over the other services and it's not yet decided if all accounts will be automatically re-enabled or if we'll have a method to request (confirming the account is still needed)
01:59:44 <magthe> dcoutts: oki, fair enough, I'll have to check in again in a few days then
01:59:57 <dcoutts> magthe: look out for an announcement
02:00:53 <magthe> dcoutts: I will, thanks
02:15:30 <b0fh_ua> @pl f p s = flip feed empty $ parse p s
02:15:30 <lambdabot> f = (flip feed empty .) . parse
02:17:20 <merijn> Is there any way I can avoid having to add parenthesis around the function composition in functions like "filter ((==0) . (`rem` 128))"?
02:18:07 <merijn> Its triggering outbreaks of my parenthesis allergy >.>
02:18:17 <kfr> flip rem $ 128
02:18:48 <merijn> kfr: I meant the composition, not the slicing
02:19:06 <merijn> Also, "flip rem $ 128" makes no sense, that's just "flip rem 128"
02:19:07 <kfr> Oh, I totally misread
02:19:19 <lunaris> merijn: Only if you're prepared to use prefix forms
02:19:32 <lunaris> :t filter ((==) 0 . flip rem 128)
02:19:32 <lambdabot> forall a. (Integral a) => [a] -> [a]
02:19:42 <lunaris> Or similar.
02:19:43 <lunaris> I believe.
02:19:46 <merijn> lunaris: So that's a no then
02:19:50 <kfr> I always overuse $ :[]
02:19:51 <lunaris> Well
02:19:53 <nlogax> :t filter $ (==0) . (`rem` 128)
02:19:54 <lambdabot> forall a. (Integral a) => [a] -> [a]
02:20:05 <lunaris> You won't be able to lose the ones around (==)
02:20:08 <kfr> nlogax yeah I was about to suggest that
02:20:17 <lunaris> As nlogax shows, you can use ($) like that
02:20:20 <merijn> My main problem is typing filter/maps with multiple function applications and then having to go back to add parenthesis to it
02:20:26 <lunaris> But personally I'd use parentheses in that case any day.
02:20:42 <merijn> When I use slicing I always immediately type the parentheses so I don't forget and have to go back :p
02:21:23 <merijn> I suppose I could juse get in the habit of "filter $ foo $ stuff"
02:21:46 <kfr> filter . foo $ stuff?
02:22:58 <merijn> kfr: No, although filter $ foo $ stuff is wrong too, that first applies foo to stuff, then passes it to filter...
02:25:18 <kfr> a $ b is just a b  anyways, right?
02:25:32 <merijn> :t ($)
02:25:33 <lambdabot> forall a b. (a -> b) -> a -> b
02:25:48 <merijn> :t filter $ even
02:25:49 <lambdabot> forall a. (Integral a) => [a] -> [a]
02:25:51 <merijn> :t filter $ even $
02:25:52 <lambdabot> parse error (possibly incorrect indentation)
02:26:04 <kfr> Huh
02:26:05 <merijn> :t filter $ even $ [1..]
02:26:06 <lambdabot>     Couldn't match expected type `a -> Bool'
02:26:06 <lambdabot>            against inferred type `Bool'
02:26:06 <lambdabot>     In the second argument of `($)', namely `even $ [1 .. ]'
02:26:28 <merijn> That gets parsed as "filter (even [1..])"
02:26:45 <merijn> kfr: Which part is the "huh" part?
02:26:53 <kfr> The terminal $
02:27:27 <yitz> :t (filter $ even $)
02:27:27 <lambdabot>     The operator `$' [infixr 0] of a section
02:27:28 <lambdabot>         must have lower precedence than that of the operand,
02:27:28 <lambdabot>           namely `$' [infixr 0]
02:27:30 <merijn> I wanted to partially apply that, but it only works like this
02:27:35 <merijn> :t ((filter $ even) $)
02:27:36 <lambdabot> forall a. (Integral a) => [a] -> [a]
02:27:50 <merijn> Is there a way to query fixity from lambdabot?
02:28:02 <yitz> :t (filter . even $)
02:28:02 <lambdabot>     Couldn't match expected type `a -> Bool'
02:28:03 <lambdabot>            against inferred type `Bool'
02:28:03 <lambdabot>     In the second argument of `(.)', namely `even'
02:28:20 <merijn> filter . even makes no sense
02:28:33 <merijn> :t (.)
02:28:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:28:37 <merijn> :t filter
02:28:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:28:44 <merijn> : (filter .)
02:28:49 <merijn> :t (filter .)
02:28:50 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> Bool) -> f ([a] -> [a])
02:29:00 <HugoDaniel> hi
02:29:02 <HugoDaniel> what are comonads ?
02:29:08 <HugoDaniel> where can i learn about them ?
02:29:25 <Younder> wikipedia
02:29:27 <merijn> HugoDaniel: Haskell comonads or math comonads?
02:29:36 <kfr> Monads over the co-category of the category of a monad
02:29:39 <merijn> Because I think those are each other's inverse :p
02:29:43 <kfr> Or something like that
02:29:46 * kfr shrugs helplessly
02:29:55 <Younder> http://en.wikipedia.org/wiki/Monad_(category_theory)#Comonads_and_their_importance
02:31:03 <Younder> On the whole wikipedia has excellent math articles.
02:31:25 <kfr> Yeah it does, I used it a lot as an undergrad
02:33:34 <MrAI> type DataType = (Name, [Constructors])
02:33:34 <MrAI> List2 :: DataType
02:33:34 <MrAI> List2 = ("List", [c1,c2])
02:33:42 <MrAI> Why is that invalid?
02:33:50 <MrAI> *An invalid type signature
02:34:24 <Axman6> what are the types of c1 and c2?
02:34:26 <ToRA> functions have to start with a lower case letter;  list2 :: DataType ; list2 = (...)
02:34:35 <Axman6> oh, right
02:34:36 <Axman6> heh
02:34:39 <MrAI> :D
02:34:40 <MrAI> Ta
02:34:58 <HugoDaniel> cool
02:35:02 <HugoDaniel> wikipedia for me then
02:35:02 <HugoDaniel> :)
02:35:03 <HugoDaniel> thanks
02:37:25 <Younder> Just got through 'Category theory for computer scientist's' myself.
02:43:43 * hackagebot Digit 0.0.2 - A data-type representing digits 0-9  http://hackage.haskell.org/package/Digit-0.0.2 (TonyMorris)
02:44:04 <profmakx> O.o
02:45:32 <Axman6> not quite sure what the point of that package is...
02:46:44 <Younder> Think I will need a book that more fully explains category theory  to understand Lang's Algebra..
02:52:08 <Cale> Younder: Have you seen Awodey's book?
02:57:51 <Younder> no
02:58:41 <Cale> It's my favourite introductory category theory text.
02:59:56 <jacobian> Lang's Algebra is not the most readable text
03:00:55 <Cale> http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/ -- awesome
03:01:42 <Younder> jacobian, so I've heard. I have a couple of other books as well
03:02:02 <Axman6> Cale: heh, i was about to say PHP does the same thing :P
03:02:26 <Axman6> read "2.2250738585072012e-308" :: Double
03:02:38 <Axman6> > read "2.2250738585072012e-308" :: Double
03:02:39 <lambdabot>   2.2250738585072014e-308
03:02:46 <jacobian> ;)
03:02:52 <shachaf> Cale: While you're at it, do you have any other favourite introductory texts? :-)
03:02:56 <Axman6> now quite the same number though...
03:03:09 <Axman6> > read "2.2250738585072012e-308" == 2.2250738585072012e-308
03:03:10 <lambdabot>   True
03:03:15 <Cale> shachaf: Well, I'm a big fan of Spivak's Calculus
03:03:15 <Axman6> of is it :o
03:03:16 <Axman6> heh
03:03:30 <jacobian> I liked Spivak's Calculus 
03:03:48 <shachaf> Yes, I've seen you mention it.
03:04:09 <Cale> For algebra, I'm not sure. I have a couple of texts which are nothing to write home about. Dummit and Foote is supposed to be good and looks good on a skim through, but I haven't read it.
03:04:29 <Cale> Artin's algebra also doesn't look so bad
03:05:03 <Younder> jacobian, Hes 5 volume set on differential geometry is also excellent. At the the first two volumes I read.
03:05:10 <shachaf> Jacobson's _Basic Algebra I_ was recommended to me at one point.
03:05:42 <merijn> While we're on the topic of books, does anyone know "Basic Category Theory for Computer Scientists by Pierce? Is it any good?
03:05:48 <Cale> For linear algebra, Roman's book is exceptional, but is aimed at graduate students.
03:11:29 <Younder> merijn, No, not really. You can find better free online resources. But do get his book on type theory.
03:12:02 <merijn> Younder: I don't think I really need intro books on type theory any more
03:12:16 <merijn> So unless its a fairly advanced book...
03:12:27 <Younder> He has a advanced book too.
03:12:41 <jacobian> the advanced book isn't great
03:12:47 <Younder> ok
03:12:52 <jacobian> it's a collection of topics by different authors
03:13:03 <merijn> Any recommended category theory books?
03:13:50 <jacobian> For type theory I liked http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
03:14:09 <Younder> One was just mentioned. Awodey's basic category theory. (Which I just ordered)
03:14:22 <merijn> I'll check it out, thanks :)
03:19:06 <accel> is learn you haskell for a great good ... any good ?
03:19:12 <Twey> Sure
03:19:23 <merijn> accel: It is excellent
03:19:44 <merijn> I highly recommend it if you are new to functional programming (and even if you are not, I still recommend it)
03:19:54 <Twey> Can't guarantee its style will suit you, but the information's all there
03:20:17 <ion> Yeah, it’s great.
03:20:24 <accel> the art is beautiful
03:20:31 <accel> it's as if picasso himself drew the diagrams
03:20:45 <accel> the book deserves to be painted over the cistine chapel
03:21:03 <Saizan> *sistine
03:21:11 <merijn> accel: My personal recommendation is to read Learn You a Haskell first and after that move on to Real World Haskell to get an idea of...well, real world haskell :p
03:21:13 <Younder> accel, Real world Haskell is pretty good
03:21:39 <merijn> Younder: IMO that is more suited as a followup once you sort of get the basics, though
03:21:54 <accel> in my opinion; there should be a rule in haskell land
03:22:08 <accel> if you right a big, well known piece of software, you should be requied to write a book on haskell
03:22:21 <accel> so the ghc guys, as well as the leksah team, should write and share knowlege :-)
03:22:29 <stian_> Did a cabal install of yesod, it failed with "ambiguous occurence of mapM" (Prelude.mapM and Data.Enumerator.mapM). Ran cabal install yesod again (for some reason), and it installed fine. What gives?
03:22:40 <Saizan> the "ghc guys" have written a lot on haskell :)
03:22:44 <Younder> merijn, Perhaps, I had background from Common Lisp and some ML so to me it fit like a glove.
03:23:01 <accel> Younder: what do you think of lisk?
03:23:12 <merijn> Younder: Yeah, that makes sense. But a lot of people don't start with a functional background :)
03:23:22 <accel> all haskell needs ... is to replace template haskell with defmacro
03:23:37 <Saizan> stian_: maybe you did a cabal update in-between?
03:23:52 <stian_> Saizan, no cabal update in-between
03:24:02 <Saizan> stian_: installed some other package?
03:24:16 <stian_> Saizan, no i just ran cabal intstall yesod twice
03:24:23 <stian_> install*
03:25:01 <Younder> accel, An interesting language. It's solution to functional programming is pretty hopeless. Loots of intermediate data structures. But with the series library it get's interesting.
03:25:25 <Saizan> that's quite surprising, it should be deterministic, it can be affected by the packages already installed though
03:25:45 <accel> Younder: lisk or CL is hopeless?
03:26:38 <joe6> accel: give TH a try. it is pretty good and once you get the hang of it. it is not a big deal.
03:26:45 <joe6> almost feels like defmacro too.
03:28:37 <joe6> http://hpaste.org/43510/joe : the code here gets the accessors of all fields of a record and any sub-records along with the field names. I am not sure if there is any use in making it a hackage module.
03:28:44 <joe6> any suggestions, please?
03:28:58 <joe6> is it worth making this code a hackage module?
03:29:11 <Younder> accel, No I often use it for rapid prototyping where Haskell's typesystem get's in the way.
03:30:06 <stian_> Saizan, if you want to have a look: http://hpaste.org/43511/
03:30:11 <Younder> accel,  This is, however, only productive is you already know CL as it is very much a world on it's own.
03:30:25 <accel> Younder: are you talking about Lisk or Haskell   being hopeless?
03:30:29 <accel> Younder: I'm confused.
03:30:43 <accel> Younder: Lisk = Haskell sematncsi w/ Lisp syntax
03:30:47 <Younder> accel, for you, perhaps, python?
03:33:25 <joe6> Saizan: any thoughts, please? is it worth putting this to hackage?
03:34:08 <accel> http://www.hyperedsoftware.com/blog/entries/first-stab-th.html <-- this looks unreadable
03:34:12 <accel> is this english?
03:35:15 <joe6> no, use this: http://web.archive.org/web/20080822110747/haskell.org/bz/th3.htm
03:35:22 <joe6> this is the best TH tutorial.
03:35:36 <joe6> is very useful and gets you functional very quickly.
03:35:36 <accel> not loading
03:35:41 <accel> or, loading very slowly
03:35:43 <accel> failed connection
03:35:58 <joe6> and then, this http://web.archive.org/web/20080822110753/haskell.org/bz/thdoc.htm
03:36:18 <accel> http://web.archive.org/web/20080822110747/haskell.org/bz/th3.htm <-- does not work
03:36:25 <accel> do I need a different date?
03:41:05 <joe6> accel: what do you mean? I have it loaded up in my browser. Let me refresh it.
03:41:27 <dibblego> @check \x -> (" " `intercalate` x) == unwords x
03:41:31 <lambdabot>   mueval-core: Time limit exceeded
03:41:34 <dibblego> boo
03:41:37 <dibblego> is that true?
03:41:38 <joe6> accel: it does, try it again.
03:42:11 <accel> wtf
03:42:17 <accel> is web.archive.org non deterministic?
03:42:34 * accel saves the page in case it goes down again
03:43:26 <ion> Perhaps some sync issues among different frontend servers, or something like that.
03:44:02 <accel> with template haskell?
03:44:04 <accel> yell file line = fail ($(printf "Error in file %s line %d") file line)
03:44:06 <accel> becomes valid code?
03:45:10 <Axman6> why not use CPP there, and use FILE and LINE?
03:45:22 <accel> I think it's a demo
03:45:27 <accel> to show how to use TH
03:45:37 <accel> rather than "this is the coolest / most important TH usage ever"
03:45:47 <Axman6> i don't see why TH is needed there
03:46:38 <ion> With that kind of printf the compiler can verify the parameters statically.
03:49:29 <ion> (I probably misunderstood what you meant.)
03:50:02 <accel> can TH get type info out of an expression?
03:50:17 <accel> or is it just doinb blind rewriting?
03:50:32 <merijn> Not really haskell specific, but I need some algorithm help (or perhaps even trivial math), given a rectangle of size N by M and a fraction F I need to find a rectangle of size P by Q whose surface is fraction F of the size of N by M's surface (preferably keeping P and Q proportional to N and M, but that is not necessary). Any suggestions?
03:51:03 <ion> I haven’t got around to studying TH, but i just expected that printf invocation gets replaced by something akin to ‘\a b → … :: String → Integer → String’ during compilation. :-)
03:51:21 <accel> so basically it's just sting substitution
03:51:24 <opqdonut> merijn: err take the square root of F and use that for scaling?
03:51:41 <opqdonut> merijn: or were there other constraints? like M, N, P, Q being integers?
03:51:43 <Axman6> accel: no
03:51:45 <ion> More like AST substitution i assume.
03:51:58 <ion> But someone who actually knows TH will be a better source of information. :-)(
03:52:05 <ion> :-) even
03:52:29 <accel> opqdonut: let P = 1, Q = M * N * F :-)
03:52:33 <merijn> opqdonut: Well, M and N are integers but approximation of P by Q is good enough so I can just round
03:53:53 <opqdonut> merijn: sqrt(F)*M * sqrt(F)*M = F*M*N
03:53:54 <merijn> opqdonut: Like I said, I probably wanted trivially math. But I was suffering from massive blackout on how to approach the issue.
03:53:59 <merijn> Thanks :)
03:54:04 <opqdonut> and the aspect ratio stays the same, of course
03:54:06 <merijn> s/trivially/trivial
03:54:16 <opqdonut> no problem
03:59:45 <pedro3005> was the (m + 1) pattern match killed in 7.0.1 ?
04:01:24 <quicksilver> well, it was removed from Haskell2010
04:01:31 <quicksilver> I think you can still turn it on explicitly if you want it
04:07:01 <NeKoFu> Hi everyone, I'm trying Haskell for the first time
04:07:18 <dibblego> hi NeKoFu how goes it?
04:07:42 <NeKoFu> It's pretty hard for the moment but very interesting
04:07:59 <dibblego> what resources are you using to learn?
04:08:22 <NeKoFu> I follow lesson on tryhaskell.org
04:08:43 <pedro3005> http://learnyouahaskell.com is good
04:08:48 <merijn> NeKoFu: The start can be very hard (especially when you've programmed before)
04:09:01 <merijn> And I agree, Learn You a Haskell is very good
04:09:11 <NeKoFu> thank I will take a look
04:12:41 <NeKoFu> great site, a lot of example, thank you again
04:13:12 <accel> is "type ... = ..... " basiaclly a C #define ?
04:14:20 <dibblego> no, it's a type alias
04:14:25 <dibblego> there is no macro expansion
04:14:34 <accel> say I have:
04:14:38 <accel> type Vertex = (Double, Double)
04:14:42 <merijn> accel: It is more like C's typedef
04:14:47 <accel> is the note equiv if I did a s/Vertex/(Double, Double)/ ?
04:15:50 <saml> hey how can I convert string to double?
04:16:06 <merijn> saml: You probably want "read"
04:16:08 <merijn> :t read
04:16:09 <Twey> > read "23.56" :: Double
04:16:09 <lambdabot> forall a. (Read a) => String -> a
04:16:09 <lambdabot>   23.56
04:16:17 <Twey> > read "23.56" :: Double + 1
04:16:18 <lambdabot>   Could not deduce (GHC.Read.Read
04:16:18 <lambdabot>                      ((+) GHC.Types.Double ...
04:16:20 <Twey> D'aw
04:16:22 <pedro3005> is there a lot of difference between haskell 2010 and haskell 98?
04:16:28 <Twey> > 1 + read "23.56" :: Double
04:16:29 <lambdabot>   24.56
04:16:45 <saml> > 1 + read "2.2250738585072012e-308" :: Double
04:16:46 <lambdabot>   1.0
04:16:47 <Twey> pedro3005: A few key differences
04:17:01 <saml> how come haskell does not hang when java does?
04:17:12 <merijn> saml: Non-sucky compiler
04:17:17 <Twey> pedro3005: http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
04:17:43 <merijn> saml: C doesn't hang on that bug either. Its a java bug, why would it hang haskell?
04:18:18 <saml> so, if i find a java web server with html form that takes floating point number, i can halt the server right?
04:18:45 <merijn> saml: No, only for double's, floats are not affected
04:19:19 <saml> is there a way to find such floating point number?
04:19:22 <saml> say, for haskell
04:19:33 <saml> there must be a bug in haskell's double implementation, too
04:19:45 <pedro3005> why?
04:20:22 <merijn> saml: Sure, simple. Try all possible double values
04:20:24 <saml> because double implmentation is hard
04:20:35 <saml> no, you are ph.d use newton's method
04:21:11 <merijn> I'm pretty sure Newton never worked with IEEE754 double precision floating points....
04:21:21 <Twey> Hehe
04:22:01 <merijn> Also, note the subtle trolling of wannabe exploiters by telling them to simply "try all possible double values" :>
04:22:50 * Twey doesn't get how you can successfully implement singles but not doubles.
04:22:51 <merijn> Pretty sure just iterating over all 2^64 values will take some time, iterating over all possible ways to generate those 2^64 values will take far longer :)
04:22:52 <saml> we can write a paper about halting problem and heuristical way of selecting turing machine input
04:29:59 <pedro3005> why doesn't this work?
04:30:07 <pedro3005> > map (+) [(1, 2), (3, 4)]
04:30:08 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> (t, t1))
04:30:08 <lambdabot>    arising fro...
04:30:27 <dibblego> pedro3005: (+) doesn't operate on pairs
04:30:40 <pedro3005> oh, right
04:30:43 <dibblego> pedro3005: are you expecting [3, 7] ?
04:31:06 <dibblego> > map (uncurry (+)) [(1, 2), (3, 4)]
04:31:07 <lambdabot>   [3,7]
04:31:11 <rribeiro> pedro3005, try: map (uncurry (+))
04:31:17 <pedro3005> hmm, uncurry
04:45:59 <ksf_> > read "2.2250738585072012e-308" :: Float
04:46:00 <lambdabot>   0.0
04:46:05 <ksf_> > read "2.2250738585072012e-308" :: Double
04:46:06 <lambdabot>   2.2250738585072014e-308
04:46:12 <ksf_> hmm.
04:47:01 <ksf_> > read "2.2250738585072012e-308" :: CReal
04:47:02 <lambdabot>   0.0
04:47:06 <ksf_> wtf?
04:47:13 <ksf_> oh.
04:47:18 <ksf_> showFFloat etc.
05:01:07 <aleator> Could someone help me type this right http://hpaste.org/43518/typeheadache ?
05:02:17 <zygoloid> aleator: HasGen and Statet expect a type Monad m => m (of kind * -> *). so you'd need to specify MyMonad instead of MyMonad s.
05:02:29 <zygoloid> hmm, scratch that, insufficient coffee
05:04:27 <zygoloid> "m (Gen (m s))" does not unify with "MyMonad s (Gen s)", so "getGen = get" won't work. did you mean "getGen :: m (Gen (Statet m))"?
05:04:41 <levifikri> Hi, handle (\_ -> return Nothing) $ do ... raises 
05:04:43 <levifikri> Ambiguous type variable `e' in the constraint:   `Exception e'     arising from a use of `handle' at BetterPredicate.hs:46:19-47 Probable fix: add a type signature that fixes these type variable(s)
05:05:13 <merijn> :t handle
05:05:13 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
05:05:25 <levifikri> I just copy & pasted from Real World Haskell. 
05:05:41 <doserj> try \SomeException -> return Nothing
05:05:56 <merijn> levifikri: My guess: "\_ -> return Nothing" does not specify a type, which confuses GHC because it is not sure what type _ should be
05:06:00 <levifikri> what is the most generic exception?
05:06:50 <doserj> "SomeException"
05:09:23 <levifikri> doserj it works, thx :)
05:09:26 <kfr> http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/
05:10:00 <Baughn> The ghost of IPv4... IANA is out, let's close up shop.
05:10:05 <Silvah> :t SomeException
05:10:06 <lambdabot> Not in scope: data constructor `SomeException'
05:10:15 <Baughn> @hoogle SomeException
05:10:16 <lambdabot> Control.Exception data SomeException
05:10:16 <lambdabot> Control.Exception SomeException :: e -> SomeException
05:10:16 <lambdabot> Control.Exception.Base data SomeException
05:11:02 <kfr> > read "2.2250738585072012e-308" :: Double
05:11:03 <merijn> Baughn: IANA has been out for like one or two days now
05:11:04 <kfr> CRASH
05:11:04 <lambdabot>   2.2250738585072014e-308
05:11:17 <kfr> How did it do that?!
05:11:19 <merijn> kfr: That only works in bad languages
05:11:22 <kfr> lambdabot is supposed to time out by now
05:11:25 <Veinor> kfr: i like this comment:
05:11:26 <Veinor> "Uh… use BigDecimal instead? Double and Floats are known to be buggy and have problems with some operations (like division). BigDecimal was created to address those problems.
05:11:36 <kfr> Veinor hahaha wtf?
05:11:43 <ion> :-D
05:11:46 <Veinor> you can't trust that ieee spec, man
05:11:49 <Veinor> too damn buggy
05:11:55 <Veinor> better use arbitrary-precision integers!
05:11:58 <Baughn> merijn: The announcement was today, and they haven't even officially allocated the final five yet..
05:12:13 <yitz> > 2.2250738585072012e-308
05:12:14 <lambdabot>   2.2250738585072014e-308
05:12:21 <yitz> > 2.2250738585072011e-308
05:12:22 <lambdabot>   2.225073858507201e-308
05:12:30 <yitz> > 2.2250738585072014e-308
05:12:31 <lambdabot>   2.2250738585072014e-308
05:12:34 <merijn> People have been coming in and trying that number all day, I don't see the point?
05:12:55 <Baughn> http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/
05:12:56 <dibblego> scala> "2.2250738585072012e-308".toDouble
05:12:58 <yitz> merijn: we're all just checking
05:13:00 <dibblego> fails to terminate ^
05:13:08 <Bynbo7> both PHP and Java fail to parse it merijn 
05:13:14 <ddarius> dibblego: That would be expected.
05:13:24 <merijn> Bynbo7: I know, but I fail to see how PHP and java impact haskell?
05:13:25 <Bynbo7> we're just gloating at our superior technology!
05:13:30 <dafis> > 2.22507385072012e-308
05:13:31 <lambdabot>   2.22507385072012e-308
05:13:37 <merijn> C doesn't break either, afaik
05:13:42 <yitz> notice that ghc changes the last digit from 2 to 4
05:13:58 <lpsmith> I just tried converting every number of the form 2.225073858xxxxxe-308,  no crashes
05:14:05 <yitz> anyway that was on 32 bit, and \bot is on a 64 bit machine
05:14:08 <merijn> yitz: Who says that is not the proper IEEE754 form?
05:14:19 <yitz> don't know, just interesting.
05:14:21 <merijn> double's are 64bit on 32bit machines too >.>
05:14:36 <merijn> Minor roundings on floating points are hardly ever interesting
05:14:49 <lpsmith> yitz,  you can't represent  2.22507385072012e-308  exactly in a double
05:15:51 <kfr> <yitz> notice that ghc changes the last digit from 2 to 4
05:15:55 <kfr> Severe fault, Haskell sucsk
05:16:01 <yitz> yeah i guess he used that in the post because he didn't know what it really looks like as a Double - because he is using languages that can't parse it. :)
05:16:05 <kfr> Functional programming proven to be useless
05:16:17 <dafis> yitz: where does ghc change the last digit from 2 to 4?
05:16:26 <kfr> > 2.2250738585072012e-308
05:16:27 <lambdabot>   2.2250738585072014e-308
05:16:37 <kfr> > 2.2250738585072012e-308 == 2.2250738585072014e-308
05:16:38 <lambdabot>   True
05:16:39 <yitz> I have a 32 bit machine, ghci is fine with it there too.
05:17:02 <dafis> > 2.2250738585072012e-308
05:17:03 <lambdabot>   2.2250738585072014e-308
05:17:26 <yitz> > let f x = f x in f 2.2250738585072012e-308
05:17:28 <dafis> anybody know which version of ghc the bot is running?
05:17:30 <lambdabot>   mueval-core: Time limit exceeded
05:17:35 <kfr> > "Haskell " ++ (if 2.2250738585072012e-308 == 2.2250738585072014e-308 then "sucks, it's just as bad as PHP as you can see" else "is flawless.")
05:17:39 <lambdabot>   mueval-core: Time limit exceeded
05:17:42 <dafis> > 0.5^1030
05:17:42 <kfr> What
05:17:43 <lambdabot>   0.8691694759794e-310
05:17:55 <dafis> Ah, 6.something
05:18:24 <kfr> Why did it fail to eval that?!
05:18:40 <Bynbo7> > "Haskell " ++ (if 2.2250738585072012e-308 == 2.2250738585072014e-308 then "sucks, it's just as bad  as PHP as you can see" else "is flawless.")
05:18:42 <lambdabot>   "Haskell sucks, it's just as bad  as PHP as you can see"
05:18:48 <Bynbo7> because you don
05:18:48 <kfr> Now it works hmm
05:18:51 <ion> > (decodeFloat 2.2250738585072012e-308, decodeFloat 2.2250738585072014e-308)
05:18:52 <lambdabot>   ((4503599627370496,-1074),(4503599627370496,-1074))
05:18:53 <Bynbo7> don't have magic fingers
05:19:37 <dafis> yitz: There was a typo in the floatToDigits function in GHC.Float, so it printed some numbers wrong (they would still be parsed to the correct Double, so it was no big thing)
05:20:13 <dafis> the correction is in 7
05:20:16 <yitz> python is fine with it.
05:20:26 <dafis> with what?
05:20:36 <yitz> though perhaps jpython wouldn't be, i don't have jpython.
05:20:42 <kfr> Python is a language, not an interpreter
05:20:48 <kfr> Precisely, yitz
05:21:08 <yitz> kfr: one usually means cpython when not specifying
05:23:03 <dafis> preflex: seen b0fh_ua
05:23:03 <preflex>  b0fh_ua was last seen on #haskell 3 hours, 7 minutes and 39 seconds ago, saying: @pl f p s = flip feed empty $ parse p s
05:24:04 <kfr> I just came up with a lambdabot problem I am unable to solve. What line L in the channel do you need to say such that lambabot will print L to the channel?
05:24:31 <kfr> i.e. a fixed point of lambdabot
05:24:38 <kfr> Regarding the input and the output
05:24:53 <dafis> > 1
05:24:54 <lambdabot>   1
05:24:59 <kfr> That didn't work
05:25:08 <kfr> The input is "> 1" whereas the output is " 1"
05:25:20 <dafis> kfr: okay, wasn't sure
05:25:27 <kfr> > "> 1" == " 1"
05:25:28 <lambdabot>   False
05:25:32 <kfr> Computer says no!
05:26:45 <dafis> kfr: then I think it's impossible, input always starts with '>', output with ' '
05:27:23 <kfr> Oh, it adds a space, true
05:27:30 <kfr> But let's pretend the space isn't there then :)
05:27:40 <kfr> The exercise is to add the "> " part somehow
05:28:54 <dafis> kfr: My only idea is to get a funky number type into the bot
05:29:25 <kfr> Wait, actually it's not possible, I think
05:29:49 <kfr> Oh nevermind, I forgot that the > is not part of the Haskell code itself lol
05:29:54 <dafis> newtype Ha = Ha Int; instance show Ha where show (Ha i) = "> " ++ show i ++ " :: Ha"
05:29:56 <kfr> Might still be possible, who knows
05:29:59 <merijn> > "test"
05:30:00 <lambdabot>   "test"
05:30:02 <merijn> hmm
05:30:05 <merijn> Tricky
05:30:09 <kfr> Yeah
05:30:13 <merijn> > putStrLn "test"
05:30:13 <kfr> I bet it might be easier in Lisp
05:30:14 <lambdabot>   <IO ()>
05:30:32 <merijn> > const >
05:30:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:30:37 <merijn> > const ">"
05:30:38 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> [GHC.Types.Char])
05:30:38 <lambdabot>    arising ...
05:31:38 <ddarius> > text (\x -> x++' ':show x) "> test (\\x -> x++' ':show x)"
05:31:39 <lambdabot>   The lambda expression `\ x -> x L.++ ' ' : GHC.Show.show x'
05:31:39 <lambdabot>  has one argume...
05:32:48 <dafis> > text $ (\x -> x++' ':show x) "> text $ (\\x -> x++' ':show x)"
05:32:50 <lambdabot>   > text $ (\x -> x++' ':show x) "> text $ (\\x -> x++' ':show x)"
05:33:10 <kfr> Wow
05:33:20 <kfr> dafis I think you win
05:33:22 <kfr> Impressive
05:33:23 <dafis> kydos to ddarius
05:33:26 <kfr> :D
05:33:36 <ion> :t text
05:33:37 <lambdabot> String -> Doc
05:33:42 <dafis> I just fixed a typo and precedence error
05:33:47 <kfr> I have no idea what text is
05:33:56 <Silvah> Haha, lambdabot eval quine :D
05:34:34 <ion> > text "foo\nPRIVMSG #haskell :bar"
05:34:34 <lambdabot>   foo
05:34:34 <lambdabot>  PRIVMSG #haskell :bar
05:35:04 <ddarius> ion: It's all been tried before.
05:35:18 <ion> :-)
05:35:33 <pedro3005> how does it protect against hangs?
05:35:45 <interferon> Planet Haskell still down?
05:35:46 <kfr> I managed to execute shell code on that geordy bot on freenode
05:35:53 <dafis> mueval time limit?
05:35:54 <kfr> C/C++ are great for that
05:36:02 <Silvah> > ""
05:36:03 <lambdabot>   ""
05:36:42 <merijn> kfr: Yeah, a lot of C programmers are nowhere near paranoid enough about user input
05:37:01 <kfr> Unluckily the last part failed :'(
05:37:07 <ion> s/C //
05:37:12 <merijn> true
05:37:13 <kfr> Filthy syscall blocking!
05:37:26 <dafis> merijn: I'm not paranoid about input either (if I'm the only one to ever run the programmes)
05:37:29 <kfr> He had already locked it down
05:38:16 <merijn> dafis: Tell that to the guy running plentyoffish (the dating site) who lost 28 million people worth of e-mail addresses, passwords, paypal accounts and personal info to an SQL injection :>
05:39:21 <dafis> merijn: Okay, imprecise language on my part, "If I'm the only one to ever pass input to those programmes."
05:39:42 <cheater-> merijn: let me guess, raid is backup?
05:39:57 <merijn> cheater-: Probably :p
05:41:43 <ion> cheater: “Yeah, we didn’t do backups. But what is this RAID you’re talking of?“
05:42:33 <cheater-> ion: it's a way of doing backup!
05:42:42 <lpsmith> >  text "> 2 + 2"
05:42:43 <lambdabot>   > 2 + 2
05:43:02 <merijn> Dropbox means that for the first time in my live I actually keep up to date backups of my personal documents :p
05:43:06 <lpsmith> >  text "testing"
05:43:07 <lambdabot>   testing
05:43:48 <Veinor> merijn: whoo!
05:44:08 <merijn> 3GB of free offsite backups, whoo!
05:44:48 <Bynbo7> > text "\DEL\DEL> 1+1"
05:44:49 <lambdabot>   > 1+1
05:45:14 <lpsmith> =)
05:45:59 <dafis> > text "\r> text\"\r"
05:46:00 <lambdabot>   > text"
05:46:49 <Bynbo7> > text "\n> 1+1"
05:46:50 <lambdabot>   > 1+1
05:46:56 <Bynbo7> > text "foo\n> 1+1"
05:46:56 <lambdabot>   foo
05:46:56 <lambdabot>  > 1+1
05:47:00 <lpsmith> > text ""\ESC[3~test"
05:47:01 <lambdabot>   <no location info>: parse error on input `\'
05:47:07 <lpsmith> > text "\ESC[3~test"
05:47:08 <lambdabot>   [3~test
05:47:23 <ion> > let bold = ("\2" ++) . (++ "\2") in text $ "Are " ++ bold "these" ++ " filtered?"
05:47:25 <lambdabot>   Are these filtered?
05:47:35 <Bynbo7> there used t be a way to make two bots in here talk to each other a bit, but no infinite loop
05:47:56 <ion> bynbo7: Had they been RFC-compliant, even that wouldn’t have ever happened.
05:48:12 <Bynbo7> hmm?
05:48:38 <lpsmith> > text "\btest"
05:48:39 <lambdabot>   test
05:49:08 <ddarius> ion: People get upset when lambdabot uses notices.
05:49:13 <ion> That’s the point of the very existence of the NOTICE command. Automatons *only* ever have stuff triggered based on incoming PRIVMSGs, and automatons *only* ever send automatic messages with NOTICEs.
05:51:16 <lpsmith> Well, even if we could get lambdabot to say "> 1 + 1",  there certainly is no guarantee it'll respond to it's own message
05:51:41 <ddarius> lambdabot never responds to herself.
05:51:43 <ion> As an added bonus, IRC clients can push channels with new PRIVMSGs higher in the activity list than those with just new NOTICES (at least irssi does that by default), and NOTICES tend to be rendered in a different style making the conversation easier to distinguish from bot messages.
05:57:54 <koala_man> rendering notices and privmsgs so differently is not beneficial. that's why bots never reply with notices.
05:58:29 <ion> Should joins and quits be rendered like channel messages, too?
05:59:51 <koala_man> no. should questions and answers be rendered completely differently?
06:00:40 <hpc> lpsmith: you have to go out of your way to make a bot respond to itself
06:01:10 <hpc> lpsmith: outgoing messages aren't sent back to the client that generates them, so lambdabot would have to somehow feed its own output back into the stream it reads from
06:01:58 <lpsmith> hpc,  yeah, my knowledge of IRC is pretty minimal,  but that doesn't surprise me.   In fact,  that's kinda what I was expecting.
06:02:18 <hpc> lpsmith: that's not just IRC, but any network protocol that isn't sadistically broken
06:02:21 <hpc> ;)
06:03:06 <lpsmith> Well,  something to confirm that a message was received would be nice.  IRC and AIM and a lot of chat protocols are sadistically broken that way ;-)
06:03:54 <hpc> lpsmith: you do get that in IRC, but not right away; every few minutes the server sends PING server.freenode.net
06:03:59 <hpc> and you have to send back PONG server.freenode.net
06:04:07 <hpc> or you get dropped
06:04:33 <lpsmith> yeah,  I did write a very minimal IRC bot once,  I do know about PINGS and PONGS,  but that's hardly a confirmation that a message was received
06:05:01 <hpc> lpsmith: perhaps TCP then?
06:05:17 <hpc> it guarantees the presence and order of packets
06:05:54 <lpsmith> IRC already uses TCP
06:06:09 <hpc> problem solved! :P
06:06:35 * hpc obnoxiously guides you to his own conclusion
06:06:35 <lpsmith> and honestly,  it's not enough when you are dealing with unacceptably flaky internet connections,  as I've often had to put up with over the years
06:27:24 <beastaugh> does anyone know how I can print Unicode characters to the Windows console?
06:38:10 <fryguybob> beastaugh: See this thread: http://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019442.html
06:41:40 <fryguybob> beastaugh: And http://hackage.haskell.org/trac/ghc/ticket/4471
06:41:54 <beastaugh> fryguybob: thanks!
06:42:34 <beastaugh> looks like a complete pain, maybe I'll just swap in an ASCII representation on Windows
06:43:03 <fryguybob> beastaugh: Yup.
06:43:28 <hvr> what's wrong with "instance (MyClass e) => Eq e where ..."?
06:44:25 <fryguybob> hvr: What error do you get?
06:44:34 <hvr> Illegal instance declaration for `Eq e'
06:44:34 <hvr>          (All instance types must be of the form (T a1 ... an)
06:44:34 <hvr>           where a1 ... an are type *variables*,
06:44:34 <hvr>           and each type variable appears at most once in the instance head.
06:44:38 <hvr> that one
06:45:43 <dafis> hvr: firstly, e is a type variable, that requires FlexibleInstances since H98/H2010 instances must be a type constructor applied to the suitable number of (distinct) type variables
06:46:11 <dafis> hvr, so instance Class Foo where, instance Class2 (Foo a b c) where ...
06:47:28 <dafis> hvr: secondly, what you wrote is basically and instance Eq e where, it matches all types (and if you try to use Eq methods on something that isn't an instance of MyClass, you get a compile error
06:48:24 <dafis> hvr: but there are already instances of Eq, so that's an overlapping instance, won't compile (without the extension)
06:48:36 <dafis> @quote quicksilver overlapping
06:48:36 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
06:48:36 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
06:49:25 <dafis> hvr: that quote may be exaggerating a little, but overlapping instances are indeed dangerous
06:49:42 <quicksilver> quicksilver never exaggerates.
06:50:07 <dafis> quicksilver: so maybe lambdabot peppered up the quote?
06:50:25 <quicksilver> ;)
06:51:03 <doserj> I wouldn't want to know what quicksilver says to unsafePerformIO then...
06:53:24 <earthy> plus, overlapping instances quite quickly leads to wanting UndecidableInstances
06:53:41 <doserj> UndecidableInstances are fine
06:53:55 <dafis> earthy: IncoherentInstances are eeevil
06:53:57 <doserj> (after compilation finishes...)
06:54:12 <earthy> doserj: ay, there's the rub. ;)
06:57:27 <earthy> I'd like the type system to be decidable, so that at least compilation will either succeed or fail
06:57:53 <quicksilver> you can have a decidable type system which require UndecidableInstances
06:58:06 <quicksilver> because GHC's decidability criterion is simplistic and you may be smarter.
06:58:42 <earthy> quicksilver: that I know
06:59:10 <earthy> but still, it's a good hint that *maybe* what I'm doing is too hard. ;)
06:59:49 <earthy> (there's that thing about not programming to the limits of your intelligence, because then by definition you will be too stupid to debug the thing)
07:08:38 <petersonx> Hi, I want to have fun with hasktags / Emacs. But I am on windows, I cant do find -name \*\*hs | xargs hasktags        How do you generate Haskell TAGS files for Emacs?
07:10:10 <hvr> dafis: what I don't get is why then "instance (JSON a, JSON b) => JSON (a,b) where
07:10:13 <hvr> " works
07:11:06 <Eduard_Munteanu> petersonx: doesn't msys/mingw have 'find'?
07:11:24 <Eduard_Munteanu> Haskell Platform comes with some mingw stuff.
07:11:44 <zygoloid> hvr: (a, b) is just sugar for (,) a b, and (,) is just a normal two-argument type constructor, like Either.
07:11:49 <petersonx> Eduard_Munteanu: i have a look
07:11:52 <dafis> hvr: Because it's a specific type constructor, `(,)', applied to two distinct type variables, a and b. So the instance head (a,b) matches only pairs and not other types.
07:12:20 <hvr> dafis: ...ok, now I trying to see the problem, thx :-)
07:12:28 <hvr> s/trying/beginning/
07:13:00 <dafis> hvr: in the equivalent form, instance (JSON a, JSON b) => JSON ((,) a b) where ..., do you see the difference?
07:13:30 <hvr> dafis: would that work even if the rhs would have a different type-class than JSON?
07:13:54 <dafis> hvr: yes
07:14:15 <dafis> hvr: GHC only looks at the part after the '=>' to select instances
07:14:20 <Jonno_FTW> how do I make my module names not ambiguous?
07:14:23 <Jonno_FTW>   Ambiguous module name `Control.Monad.Reader'
07:14:30 <hvr> dafis: so "instance (MyClass e) => Eq (e,e) where ..." should work?
07:14:58 <dafis> hvr: so, with instance (...) => A a where, it sees just "instance A a where..." for the purpose of instance selection
07:15:27 <dafis> hvr: No, at least not easily, there you have the same type variable twice
07:15:52 <dafis> hvr: I think FlexibleInstances would allow that
07:16:25 <dafis> hvr: except there's already an "instance (Eq a, Eq b) => Eq (a,b) where"
07:16:36 <hvr> ic
07:16:38 <dafis> hvr: so yours would be overlapping
07:17:07 <hvr> thx for the explaination
07:17:14 <petersonx> Eduard_Munteanu: unfortunatelly i cant install msys/mingw and haskellplatform doesn't deliver find, which i would need for hasktags collecting files
07:17:27 <dafis> Jonno_FTW: specify the package to use on the command line, or better, in the.cabal file
07:17:35 <roconnor> @bot
07:17:35 <lambdabot> :)
07:17:57 <Jonno_FTW> dafis: can't I do it in my module?
07:18:21 <hvr> dafis: btw, I had a 'MyClass', that had a generic 'getId' function, which would provide me with an unique id, which I hoped to use generically for an Eq instance... 
07:18:44 <dafis> Jonno_FTW: yeeeeessss, but you shouldn't, there's an extension that allows it, but it should only be used for very low level compiler-internal stuff
07:19:05 <Jonno_FTW> ok
07:19:37 <dafis> hvr: perhaps you can get by with a wrapper type?
07:20:35 <dafis> hvr: newtype Wrapper a = W a; instance (MyClass a) => Eq (Wrapper a) where (W x) == (W y) = getId x == getId y
07:24:08 <dafis> Jonno_FTW: another option is of course to unregister some packages to make the module name unambiguous
07:25:30 <Jonno_FTW> how do I do that?
07:25:56 <dafis> Jonno_FTW: ghc-pkg unregister foo
07:26:17 <dafis> Jonno_FTW: but don't unregister packages you still need for other stuff
07:26:41 <dafis> Jonno_FTW: wher did the ambiguous Control.Monad.Reader occur?
07:26:55 <dafis> which packages, I mean
07:27:07 <Jonno_FTW>     Ambiguous module name `Control.Monad.Reader':
07:27:08 <Jonno_FTW>       it was found in multiple packages: monads-tf-0.1.0.0 mtl-1.1.0.2
07:27:27 <kfr> ghc-pkg hide monads-tf
07:27:27 <dafis> an old acquaintance
07:27:35 <kfr> Is what I did
07:27:39 <kfr> I have no idea what monads-tf is
07:27:57 <dafis> kfr: monad transformers using type families
07:30:09 <zygoloid> package-qualified imports seem like a great fit for the monads-tf problem to me...
07:30:36 <Jonno_FTW> I was going through roll your own irc bot tutorial
07:31:07 <Jonno_FTW> and I couldn't get the "Use
07:31:07 <Jonno_FTW> forkIO
07:31:10 <Jonno_FTW> to add a command line interface" part
07:43:31 <kfr> Jonno_FTW: Well, when you are performing blocking IO in the main thread you can't easily perform IO on the console
07:43:35 <kfr> In the same thread
07:43:53 <kfr> You bascially want to receive stuff from the socket(s) and read stdin simultaneously
07:44:15 <Jonno_FTW> hmm
07:44:44 <petersonx> Hi, I want to have fun with hasktags / Emacs. But I am on windows, I cant do find -name \*\*hs | xargs hasktags. How do you generate Haskell TAGS files for Emacs?
07:45:01 <petersonx> (sorry for asking again)
07:45:55 <Jonno_FTW> kfr: I got this far http://hpaste.org/43521/irc_client
07:46:27 <kfr> Single letter variable names make me cry
07:46:41 <Jonno_FTW> sorry bout that
07:47:08 <kfr> Btw
07:47:11 <kfr> :t fmap
07:47:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:47:15 <kfr> :t <$>
07:47:16 <lambdabot> parse error on input `<$>'
07:47:23 <kfr> :t (<$>)
07:47:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:47:37 <kfr> That's the inline version of fmap basically ^
07:47:49 <kfr> No need for `fmap` although it might actually be faster to type haha
07:48:00 <Jonno_FTW> yeah
07:48:15 <Jonno_FTW> but otherwise what was I doing wrong?
08:03:24 <kik_> hey! could me some one explain why foldr has a type 	(a -> b -> b) -> b -> [a] -> b    , I mean how it can be defined. foldr (+) 5 [1,2,3,4]  as I got (+) ist a first a, then it will be with 5 apllied to the last element,so 4 that is (a->b->b)
08:04:08 <kfr> @src foldr
08:04:08 <lambdabot> foldr f z []     = z
08:04:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:05:22 <kik_> i guess that is the answer, isnt it?
08:05:28 <Twey> kik_: (+) :: Num a => a -> a -> a
08:05:48 <EvanR-work> 5+(1+(2+(3+(4))))
08:05:58 <Twey> So in foldr (+), Num a => a = a, b = a
08:06:17 <Twey> So that becomes foldr :: Num a => (a -> a -> a) -> a -> [a] -> a
08:06:18 <dafis> kik_: it is the answer, but it's not obvious to a beginner
08:06:52 <Botje> kik_: type variables (a,b) are allowed to map to the same type
08:07:07 <Jonno_FTW> kfr: I'm still stuck
08:07:14 <Twey> Then foldr (+) :: Num a => a -> [a] -> a; foldr (+) 5 :: Num a => [a] -> a; foldr (+) 5 [1 .. 4] :: Num a => a
08:07:17 * hackagebot unix-compat 0.2.1.1 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.2.1.1 (JacobStanley)
08:08:11 <kik_> ok. so I got it first three varialbes (a->b->b) stand for a operations like (+)(-)(:)(*)
08:08:26 <Twey> kik_: That's just one variable
08:08:34 <kik_> yeah
08:08:35 <Twey> A function that takes an a and a b and returns a b
08:09:19 <kik_> ok. but why not a->a->a-> why there is a b?
08:09:37 <Bynbo7> because sometimes you don't want a and b to be the same types
08:09:49 <byorgey> @type (:)
08:09:50 <lambdabot> forall a. a -> [a] -> [a]
08:10:02 <Bynbo7> > foldr (:) [] [1..10] -- here a is Num a => a, and b is Num a => [a]
08:10:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:10:11 * Bynbo7 high fives byorgey 
08:10:25 <byorgey> kik_: a is the type of the elements of the list, and b is the type of the result you want
08:10:38 <byorgey> sometimes they are the same, like if you want to add up all the numbers in the list and get a number
08:10:52 <byorgey> but sometimes they are different, like when you want to compute the length (a number) of a list of Chars
08:11:13 * byorgey high fives Bynbo7 back
08:16:32 <kik_> byorgey: could you please write that what you said in a fucktion foldr
08:17:11 <kfr> Jonno_FTW sorry, I'm about to pass out
08:17:43 <Jonno_FTW> too much irc can do that to you
08:17:50 <kfr> I don't even know what that code does
08:18:01 <byorgey> > foldr (+) 0 [1,2,3,4,5]   -- computing the sum of a list of numbers, here a = b = Int
08:18:01 <lambdabot>   15
08:18:10 <kfr> I have no idea what io/hGetLine/writeOut/manage do
08:18:27 <Jonno_FTW> never mind then
08:18:33 <byorgey> > foldr (\x n -> n + 1) 0 "hello world"  -- computing the length of a list of Chars, here a = Char and b = Int
08:18:34 <lambdabot>   11
08:18:38 <Jonno_FTW> I'll ask on stack overflow
08:18:40 <byorgey> kik_: does that help?
08:19:36 <kik_> byorgey: i need a simplier example with two different types%)
08:21:03 <byorgey> kik_: Bynbo7 gave an example earlier
08:21:14 <byorgey> > foldr (:) [] [1,2,3,4,5]  -- here a = Int, b = [Int]
08:21:18 <lambdabot>   [1,2,3,4,5]
08:21:55 <cuzzie> > 1 + 2
08:21:56 <lambdabot>   3
08:23:28 <kik_> byorgey: that mean that (:) has (a->b->b) ? for example it takes 5 and [4] and gives [5,4] back
08:23:46 <byorgey> kik_: right
08:23:50 <byorgey> @type (:)
08:23:51 <lambdabot> forall a. a -> [a] -> [a]
08:23:51 <dafis> kik_: for b = [a]
08:24:21 * hackagebot text 0.11.0.3 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.3 (BryanOSullivan)
08:25:07 <kik_> ok, so when defining a type of a fucktion I should look whether it takes only one types or can take different types?
08:25:22 * hackagebot text 0.11.0.4 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.4 (BryanOSullivan)
08:26:06 <dafis> Okay, I know, RERO, but two releases within five minutes is a bit excessive, innit?
08:26:57 <smarmy> only for the first 3 version digits.  the 4th is fair game
08:27:27 <dafis> smarmy: still, leave people at least enough time to cabal update
08:29:13 <Saizan> RERO?
08:29:26 <dafis> release early, release often
08:29:46 <kik_> f x y z = foldr x y [d|d<-z,d<=y] and for example here. so, i know that foldr x has a type (a->b->b) , i iknow as well that <= induces class Ord, does that mean that foldr x has to have then only one type? like (a->a->a)
08:30:30 <dafis> kik_: yes, the use of (<=) forces a = b
08:31:00 <dafis> kik_: but that doesn't affect the type of foldr, only the type *at which it is used*
08:31:06 <kik_> dafis: I guess because and int and a char cannot be compared,yeah?
08:31:12 <dafis> right
08:31:13 <azaq23> :t let f x y z = foldr x y [d | d <- z, d <= y] in f
08:31:14 <lambdabot> forall b. (Ord b) => (b -> b -> b) -> b -> [b] -> b
08:31:20 <kfr> Well, luckily you don't actually need to test code in Haskell so you can be sure that it works as intended if it compiles. This way frequent releases are a non-issue!
08:31:23 <azaq23> @bot
08:31:23 <lambdabot> :)
08:38:25 * hackagebot text 0.11.0.5 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.5 (BryanOSullivan)
08:39:07 <dafis> if it weren't bos, I'd severely doubt the quality of the library
08:39:40 <copumpkin> why?
08:40:27 <dafis> with so many releases in such a short time, the question whether the author thought it through well and tested it at all arises
08:41:04 <dafis> of course, it's not only bos, I also trust edwardk's libs
08:41:44 * zygoloid trusts edwardk's libs but doesn't really understand a lot of them ;)
08:43:17 <copumpkin> the prolific hackage-fillers
08:45:04 <kik_> f x y z = "acd" ++ map x [d|d<-y, d<=length z]  and hier z should be  definatelly a list so, either [Int] or [char], and the fuktion should give us as well [char] as, something will be connected to char "acd", map has a type (a->b)->[a]->[b],
08:45:20 <kfr> *definitely
08:45:37 <kik_> sorry
08:45:50 <kfr> And it's [Char] aka String
08:45:53 <Botje> kik_: note that length is polymorphic
08:46:01 <kfr> Lower case types are not even permitted in Haskell, are they?
08:46:01 <Botje> length doesn't care about the type of the list you give it
08:46:19 <Botje> kik_: so actually you cannot determine the type of z from this function alone
08:46:26 <dafis> kfr: type variables
08:46:40 <kfr> dafis: I knew somebody would do that
08:46:52 <dafis> might as well be me ;)
08:47:33 <kik_> Botje: ok, then y shoul be definitely an Int, so we could compare the length of z with y
08:51:10 <Botje> kik_: the d<-y in the list comprehension forces y to be a list
08:51:25 <Botje> with d having the type of an element of that list
08:51:35 <Botje> <= forces d to be Int
08:51:38 <Botje> so y :: [Int]
08:53:14 <kik_> Botje: m.. but then wouldnt it be so [4]<=length [1,2]
08:53:47 <dafis> kik_: No, y :: [Int], d :: Int
08:54:14 <kik_> Botje: m.. but then wouldnt it be so [4]<=length [1,2]
08:56:20 <kik_> ok, so .... [Int]->[Int]->[Char] , where the first [Int] stands for y, second for [d|d<-y, d<=length z] and the last [Char] for rhe result
08:57:31 <dafis> :t let f x y z = "acd" ++ map x [d|d<-y, d<=length z] in f
08:57:32 <lambdabot> forall a. (Int -> Char) -> [Int] -> [a] -> [Char]
08:57:55 <kik_> dafis: I have looked already the type, but i want to know why it is so
08:58:12 <kik_> dafis: and why my thoughts are wrong
08:59:19 <dafis> kik_: ("acd" ++) forces map x [...] to have type [Char], aka String
08:59:49 <kik_> dafis: yeah, the result will be [char] I got this already
08:59:59 <dafis> so x :: (t -> Char), where t is the type of elements of y
09:00:17 <ezyang> Hey #haskell, what's your favorite specialized niche monad? 
09:00:34 <dafis> the elements of y are compared with (length z), so they must have type Int
09:01:25 <dafis> all that is ever done with z is calculate its length, so all we can say about it is, it's a list: z :: [a]
09:03:02 <alpounet> ezyang, if you wanna give concrete examples
09:03:11 <alpounet> i remember one about Logic
09:03:17 <alpounet> for implementing prolog in haskell
09:03:30 <ezyang> alpounet: Not specialized enough :-) 
09:03:36 <ezyang> I'm thinking stuff like the "X monad" 
09:03:43 <alpounet> oh
09:03:45 <ezyang> or the "Fuel monad". :-) 
09:04:05 <ezyang> application monads are kind of all the same, but if one does something kind of unusual that'd be itneresting. 
09:04:35 <alpounet> ezyang, iirc chrisdone has written an IRC monad
09:04:39 <alpounet> in his last blog post
09:04:53 <kik_> dafis: ok.. but where feom do we have [Int]
09:05:24 <dafis> kik_: [d | d <- y, d <= someInt]
09:05:42 <dafis> so the elements of y have type Int, hence y :: [Int]
09:05:45 <kik_> dafis: ok. thank you very much
09:08:41 <kik_> I have one more question. I have to make data Figur an instance to class Ord, adn when the surfaces are equel, I should compare the perimiter, but how can I do it, when there is no (==) (=/) in class Ord http://codepad.org/IKWCPr33
09:09:13 <Bynbo7> @src Ord
09:09:13 <lambdabot> class  (Eq a) => Ord a  where
09:09:13 <lambdabot>     compare      :: a -> a -> Ordering
09:09:13 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:09:13 <lambdabot>     max, min         :: a -> a -> a
09:09:23 <Bynbo7> sure there is, all Ords have Eq
09:10:18 <adu> does anyone have a nice reference for when to use "try" in Parsec?
09:10:39 <Philippa_> adu: when the local grammar isn't LL(1)
09:10:47 <ezyang> adu: Doesn't the tutorial discuss it? 
09:11:04 <zygoloid> Philippa_: or when the local grammar is LL(1) but you've not factored your parser that way :)
09:11:08 <ezyang> Philippa_: If you said that, hm, a week ago, I wouldn't have understood :-) 
09:11:33 <Philippa_> alternatively: when two branches both accept the same initial token
09:11:59 <Philippa_> zygoloid: well, by "the" grammar I mean the thing related to a PEG that you can extract from the parsing code
09:12:06 <kik_> Bynbo7: so I wrote evrything right there?
09:12:16 <Bynbo7> no idea
09:12:22 * Bynbo7 -> sleep
09:12:31 <Philippa_> only, how it'd behave if it backtracked by default
09:12:52 <adu> Philippa_: even if those tokens are burried under layers of functions?
09:13:31 <Philippa_> adu: right, it's the order of token consumption that matters
09:13:43 <adu> like Expr = Prim = Call = Id(ExprList) and Expr2 = TypeCall = Id(Type)
09:14:09 <Philippa_> all the haskell-level substitution is irrelevant, as are calls to things like return
09:14:55 <adu> I've started using unsafePerformIO$putStr to make sure it's going thru al <|> and I was surprized that it wasn't
09:15:15 <adu> Philippa_: I'll try to keep that in mind
09:16:07 <Philippa_> you want to be wary doing that (also, use Debug.Trace) - you need to make sure your print call actually gets evaluated
09:16:24 <adu> oh
09:16:32 <adu> how do I do that?
09:16:43 * adu has never used Debug.Trace
09:16:57 <Philippa_> well, putting Debug.Trace.Trace immediately around the <|> itself works
09:17:27 <Philippa_> if <|> associates to the right then it'll only go through the ones it needs to make a decision on though
09:17:30 <adu> will it give lots of feedback?
09:17:48 <Philippa_> it's just a "printf function"
09:17:54 <Philippa_> that you can stick in pure code
09:18:06 <adu> ok
09:32:30 <syntaxfree> say I have this brute force program. Probably not written in an optimal fashion.
09:32:47 <syntaxfree> I'm expecting it to run for three to six days on a windows computer.
09:33:11 <syntaxfree> is there a significant gain in efficiency if I compile it on the target platform, viz. running it from ghci?
09:33:30 <kfr> Just learn more Haskell, according to Wadler you will lose interest in programming in the process!
09:33:42 <mzero> syntaxfree - yes
09:33:45 <kfr> syntaxfree generally speaking, yes
09:33:52 <kfr> You do want to compile that and produce a binary
09:33:53 <zygoloid> syntaxfree: yes, compiling with optimizations can make a /massive/ difference over ghci.
09:34:02 <syntaxfree> I had overlooked that. 
09:34:15 <ezyang> Would it be right to say a monad if it can be shown to be isomorphic to Return a | Roll (f (Free f a))? 
09:34:21 <syntaxfree> kfr: it kind of matches my experience.
09:35:11 <zygoloid> ezyang: "...right to say a monad "£$*CARRIER LOST*%$*@ if it can be shown..."
09:35:25 <ezyang> sorry, "a monad is free" :-) 
09:35:26 <zygoloid> "... is free ..." ?
09:35:43 <ezyang> also, data Free f a = Return a | ... 
09:35:55 <zygoloid> sounds right to me :)
09:36:16 <zygoloid> seems reasonable to say a monad is free if it's isomorphic to the free monad along some functor
09:36:29 <ezyang> ok, good. 
09:36:47 <ezyang> I have this sort of intuitive sense that free monads are usually seen around "structures", like lists and trees. 
09:36:49 <zygoloid> reasonable, but i can't say if a CT expert would consider it "right" :)
09:37:12 <ezyang> Hehe :-) 
09:38:44 <ezyang> I'm working on a illustration of different sorts of monads and how they relate with each other. 
09:38:56 <ezyang> and I want to group lists and trees under "free monads" 
09:39:30 <zygoloid> you going to deal with Kan extensions? :)
09:39:53 <ezyang> What is a Kan extension in topology? :-) 
09:41:40 <zygoloid> umm :) i don't like to go outside Hask.
09:42:16 <jmcarthur> syntaxfree: you want to compile it and make sure to use -O or -O2
09:43:10 <jmcarthur> ezyang: my intuition is that free monads are trees with values at the leaves and cofree comonads are trees with values at the branches
09:43:26 <syntaxfree> jmcarthur: now you're starting to sound like a gentoo kid.
09:43:42 <jmcarthur> syntaxfree: it's very important for getting good performance with ghc to use optimizations
09:43:51 <kamaji> Dumb question: How do I use Data.Sized.Sparse.Matrix?
09:43:53 <jmcarthur> syntaxfree: it can make orders of magnitude difference
09:44:14 <syntaxfree> I remember hanging out at #gentoo and debating the relative merits of -ffastmath or whatever was the flag that didn't check for math errors such as sqrt(-1)
09:44:14 <zygoloid> it can make asymptotic difference in some cases :)
09:44:28 <jmcarthur> zygoloid: yeah, which i actually find rather unfortunate
09:44:39 <syntaxfree> Then I had sex. That cured me of my Linux disease.
09:44:56 <kamaji> oh, got it. sized-types
09:45:05 <jmcarthur> syntaxfree: well, this isn't just something minor like that
09:46:59 <syntaxfree> so what will -O and -O2 do respectively? More importantly, does -O imply -O2 or are there trade-offs?
09:47:17 <jmcarthur> syntaxfree: -O2 implies -O2. there isn't usually a huge difference between the two
09:47:20 <jmcarthur> err
09:47:25 <jmcarthur> *  -O2 implies -O
09:47:52 <jmcarthur> syntaxfree: and -O2 isn't necessarily always going to produce a faster binary than -O
09:48:16 <Entroacceptor> so, can haskell convert numbers? http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/
09:48:18 <jmcarthur> syntaxfree: there are yet more flags you can use as well, but i wouldn't bother unless you really know what you're doing
09:48:32 <jmcarthur> > 2.2250738585072012e-308
09:48:32 <lambdabot>   2.2250738585072014e-308
09:48:42 <jmcarthur> > read "2.2250738585072012e-308" :: Double
09:48:43 <lambdabot>   2.2250738585072014e-308
09:48:52 <jmcarthur> doesn't seem to have that issue ^_^
09:48:53 <syntaxfree> the main function relies on filtering through an infinite list. I'm hoping the compiler knows how to turn this into a loop.
09:49:09 <kunwon13> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! kunwon13 cozmic Yvemath jmv__ MayDaniel kamaji baldo ablokzijl FDFlock simplesimon2k ski maltem syntaxfree c_wraith And[y] rks BCoppens PatrickRobotham conal twanvl medfly SyntaxNinja Jantaro drunK Egbert9e9 jsgf treyka kaini mma
09:49:26 <jmcarthur> syntaxfree: even if it doesn't, laziness should make sure you don't run out of memory unless you're holding onto the head of the list
09:49:31 <syntaxfree> that was odd.
09:49:41 <jmcarthur> syntaxfree: but it usually will help you fuse list operations
09:49:47 <jmcarthur> s/help you//
09:50:03 <jmcarthur> if you use -O at least
09:50:06 <syntaxfree> jmcarthur: not at all. the main function is actually main = filter allTheseTests [4022...]
09:50:15 <syntaxfree> s/actually/literally/
09:50:19 <jmcarthur> ah, then it shouldn't be an issue at all
09:50:23 <jmcarthur> that *is* just one loop
09:50:30 <jmcarthur> compiler doesn't even have to do anything magical there
09:50:30 <syntaxfree> I understand map fusion.
09:50:45 <ezyang> jmcarthur: That's an interesting intuition! 
09:50:48 <kamaji> Is there a dynamically sized 2D array in haskell?
09:51:19 <jmcarthur> kamaji: i don't know of any, but there are sparse maps which can get you basically the same thing
09:51:28 <jmcarthur> kamaji: Data.Map, Data.IntMap, etc.
09:51:30 <syntaxfree> at least once I understood map fusion. I wrote a tutorial and/or rant on that for my then-blog.
09:51:47 <kamaji> jmcarthur: oh, of course..... i'm a dumbass :D
09:51:49 <kamaji> jmcarthur: thanks!
09:51:55 <syntaxfree> for all the good they've done, both psychiatric medication and an office job seem to have robbed me of my "edge".
09:51:56 <medfly> weird
09:52:10 <kunwon3> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! kunwon3 Kruppe Gracenotes cozmic Yvemath jmv__ MayDaniel kamaji baldo ablokzijl FDFlock simplesimon2k ski maltem syntaxfree c_wraith And[y] rks BCoppens PatrickRobotham conal twanvl medfly SyntaxNinja Jantaro drunK Egbert9e9 jsg
09:52:10 <kunwon3> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! ajhager ceii_ sonnym RayNbow corruptmemory adu parcs icbh noam ab3 FireFly dolio dmwit ccasin rribeiro copumpkin Yacoby jem777 Taejo cheater- roconnor eb4890 cibs ankit9 Apocalisp Eduard_Munteanu ttuegel asflierl Ziphilt beastau
09:52:10 <kunwon3> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! msieradzki mceier paper_cc dschoepe dfkjjkfd Guest16479 pedro3005 dibblego drmegahertz doserj trin_cz bo0ts__ nostard jrib Twey derekwright [df] lpsmith kaf3ii uberfry ceii Snark Younder simonmellor polarina carlocci Y_Less [mth
09:52:13 <zygoloid> syntaxfree: I know kung fusion
09:52:17 <kunwon8> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! kunwon8 Kruppe Gracenotes cozmic Yvemath jmv__ MayDaniel kamaji baldo ablokzijl FDFlock simplesimon2k ski maltem syntaxfree c_wraith And[y] rks BCoppens PatrickRobotham conal twanvl medfly SyntaxNin
09:52:17 <kunwon8> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! ajhager ceii_ sonnym RayNbow corruptmemory adu parcs icbh noam ab3 FireFly dolio dmwit ccasin rribeiro copumpkin Yacoby jem777 Taejo cheater- roconnor eb4890 cibs ankit9 Apocalisp Eduard_Munteanu tt
09:52:17 <kunwon8> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! msieradzki mceier paper_cc dschoepe dfkjjkfd Guest16479 pedro3005 dibblego drmegahertz doserj trin_cz bo0ts__ nostard jrib Twey derekwright [df] lpsmith kaf3ii uberfry ceii Snark Younder simonmellor
09:52:19 <jmcarthur> holy crap
09:52:24 <Jonno_FTW> egads
09:52:25 <Ziphilt> oh god this again
09:52:26 <syntaxfree> but that's a topic for -blah, and I'm actually shirking from work, so I should go away.
09:52:39 <sonnym> always distracts me
09:52:40 <jmcarthur> will we need to go invite only for a bit? :\
09:52:43 <syntaxfree> you need to set the channel +m and give +v to active users.
09:52:56 <syntaxfree> so only users with the cross by their names can talk.
09:52:56 <Ziphilt> we are supposed to be smart; how about a bot that detects and automutes this?
09:52:58 <ttuegel> how american-centric.
09:53:13 <tg_> again, he "says" he's kuwon1, but he's kuwon8. burn the witch!
09:53:14 <lpsmith> can we ban any username that starts with kunwon?
09:53:15 <sproingie> Ziphilt: that's kind of what idoru is doing
09:53:17 <medfly> Ziphilt, well, it seems like one exists, as he gets killed almost automatically.
09:53:23 <jmcarthur> heh
09:53:28 <sproingie> Ziphilt: it's a botnet
09:53:36 <Ziphilt> bots fighting bots?
09:53:37 <jmcarthur> lpsmith: we can try
09:53:45 <medfly> maybe registered users only would be good if he continues to bug us.
09:53:53 <sproingie> idoru's an ircop afaik.  i just think he's running some detection script
09:54:20 * syntaxfree spent too much of his adolescence on iRC.
09:54:21 <sproingie> registered users only is the mode any sensible irc channel should be on
09:54:31 <lpsmith> well, everytime this spammer has been especially rude to both highlight me and insult me,   it's always ben kunwon*
09:54:31 <medfly> syntaxfree, me too
09:54:37 <syntaxfree> sproingie: it's an arms race.
09:54:50 <syntaxfree> you can easily have a bot register an user on freenode every ten minutes.
09:54:52 <medfly> syntaxfree, let's start a support group or something. on IRC.
09:55:03 <syntaxfree> then freenode will have to enforce that with emails.
09:55:09 <medfly> sure, but most people don't bother.
09:55:13 --- mode: ChanServ set +o jmcarthur
09:55:25 <syntaxfree> medfly:  famous last words.
09:55:26 <sproingie> then you'd have to attack the freenode infrastructure and freenode itself would fight back
09:55:29 <syntaxfree> man, I should be working.
09:56:02 <sproingie> captchas and so forth.  which aren't foolproof but they do slow things down
09:56:02 <syntaxfree> I'm already shirking from work by writing brute force code for the Ponder This challenge for february
09:56:02 <syntaxfree> .
09:56:34 --- mode: jmcarthur set +b kunwon*!*@*
09:56:39 <syntaxfree> http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/challenges/February2011.html
09:56:40 <jmcarthur> does that look right?
09:57:07 <jmcarthur> omg i just got privmsged :\
09:57:37 <jmcarthur> "the spambots are trying to get you to ban me by using those nicks, and that lpsmith guy is one of them"  haha
09:58:06 <sproingie> what looks right is /mode #haskell +r
09:58:33 <Twey> 180801 < medfly> maybe registered users only would be good if he continues to bug us.
09:58:36 * Twey read ‘hug’
09:59:32 <lpsmith> well,  I don't want to ban legit people,  but I'm not aware that we have a legit kunwon* user in this channel
09:59:33 <aristid> i don't like the idea of registered users only. i think #haskell should be an open place without restrictions on who can come in. (i am registered, so no personal stake)
10:00:21 <sproingie> then that means you welcome spammers
10:00:26 <jmcarthur> lpsmith: well, he asked me to ask in #freenode about it, and he's being very polite
10:00:32 <sproingie> it's a tradeoff
10:00:48 <Jesin> hmm
10:01:09 <aristid> sproingie: i don't welcome them. i accept them in exchange for a bigger benefit.
10:01:29 <Jesin> if I make an instance Eq a => Eq ([Bool] -> a)
10:01:39 <lpsmith> well, if the message is from a legit user,  I can understand his frustration.
10:01:48 <Jesin> that would not cause overlap problems with other function types, would it?
10:01:50 * sproingie shrugs.  i suspect if they escalate, the open attitude won't last
10:02:24 <lpsmith> maybe the ban isn't the right approach
10:02:36 <Jesin> like, would that make it impossible to define any other Eq instances for functions?
10:02:54 <jmcarthur> there seems to be some consensus in #freenode that kunwon1 is legit
10:03:08 <lpsmith> fair enough
10:03:12 <c_wraith> legit = believes what he's saying?
10:03:38 <jmcarthur> well, i haven't received word from anybody too trustworthy yet though
10:04:08 <sproingie> it's a bot.  the names are randomized.  banning an unregistered nick is pointless.
10:04:10 <lpsmith> #freenode is a strange place,  filled with less than trustworthy people :-/
10:04:41 <lpsmith> Wasn't it kunwon last time?  Or am I not recalling correctly?
10:05:11 <shenshei> hello, is it possible to generate the hoogle doc of an installed package with cabal command ?
10:05:11 <sproingie> randomized based off someone's nick i guess.  sounds like more reason to believe it's an attack on the guy
10:05:26 <sproingie> anyway if he's not interested in haskell, he probably won't care if his nick is banned from here
10:05:38 <sproingie> oh he's on the channel
10:06:00 <adu> Entroacceptor: good article
10:06:01 <sproingie> preflex: seen kunwon1
10:06:01 <preflex>  kunwon1 was last seen on #haskell 3 days, 20 hours, 26 minutes and 54 seconds ago, saying: :p
10:07:32 <lpsmith> yeah,  I was recalling incorrectly,  the username that the spammerbots have been using hasn't always been kunwon*
10:09:00 <lpsmith> although,  looking at the logs from 4 days ago,  kunwon1 joined the channel after it was flooded
10:10:04 <jmcarthur> can anybody confirm for me that /mode +e $a:kunwon1 does what i hope it does?
10:10:13 <jmcarthur> (exempt kunwon1 from the ban)
10:10:33 <sproingie> #freenode would probably have a better idea
10:10:40 <al3x> i joined here after seeing the freenode complaint, and i totally think kunwon1 is guilty and messing with you
10:11:08 <adu> kunwon1: says it wasn't him
10:11:19 <lpsmith> and it doesn't look like kunwon1 has been on #haskell in quite some time before that
10:11:19 <lpsmith> well, at least a week
10:11:21 <jmcarthur> al3x: and you also think Xd1358 is in on it?
10:11:25 <mauke> jmcarthur: only one way to find out :-)
10:11:39 <al3x> jmcarthur: the timing made it seem like it...i have been in freenode all morning, and they all started talking at once
10:11:45 <al3x> but i really dont know
10:12:18 <jmcarthur> al3x: is that /mode command that was suggested at least reasonable? i've never set an exemption before
10:12:32 <lpsmith> Yeah,  unless kunwon can pass a pop quiz on something very basic about Haskell that can't be looked up using Google in a minute,  I say he's probably guilty,  judging from the logs for the last week
10:12:51 <lpsmith> err, two weeks
10:12:52 <al3x> jmcarthur: i am asking someone right now 
10:12:59 <jmcarthur> thanks
10:13:15 <mauke> jmcarthur: it is reasonable
10:13:25 <al3x> jmcarthur: they didnt know, but based on this looks like it means ban exception http://freenode.net/using_the_network.shtml
10:13:42 <al3x> so, i guess they were being truthful
10:14:15 <jmcarthur> i'm confused about the $a: part
10:14:37 <mauke> why?
10:14:43 <jmcarthur> i don't know what it does
10:14:57 <mauke> have you tried the docs?
10:15:30 <jmcarthur> sorry i had googled and didn't find it, but now i see it
10:15:55 <kunwon1> ok, can you see me?
10:15:57 <kunwon1> :D
10:16:03 <mauke> yes
10:16:06 <kunwon1> excellent.
10:16:09 <kunwon1> thanks jmcarthur 
10:16:24 --- mode: ChanServ set +o mauke
10:16:39 <Jesin> hmm
10:16:44 <al3x> jmcarthur: the person i asked thinks it means "user name" the $a
10:16:45 <Jesin> @list
10:16:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:16:55 --- mode: mauke set -o mauke
10:17:01 <jmcarthur> al3x: http://www.ircworld.org/?page_id=23  <-- says it means require being identified with nick services
10:17:08 <jmcarthur> seems reasonable
10:17:10 --- mode: jmcarthur set -o jmcarthur
10:17:14 <Jesin> @help
10:17:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:17:43 <mauke> what pages are you people looking at?
10:17:46 <mauke> this makes me a sad panda
10:18:05 <jmcarthur> or at least it has something to do with that...
10:18:27 <jmcarthur> oh, *username*, not nick
10:18:33 <mauke> it's all described in http://freenode.net/using_the_network.shtml 
10:18:36 <bos> @pl \x -> x `mod` 7 /= 0
10:18:36 <lambdabot> (0 /=) . (`mod` 7)
10:20:50 <lpsmith> so,  kunwon1,  why are you interested in Haskell?
10:21:13 <kunwon1> lpsmith: i'm interested in all programming languages :)
10:22:08 <lpsmith> So what languages do you currently use?
10:22:28 <al3x> i myself have never heard of haskell before, but i am trigger happy with link-clicking :D (tho i am reading baout haskell now that i know about it)
10:22:36 <kunwon1> lpsmith: right now my job is python
10:22:41 <zygoloid> jmcarthur: before kunwon, the #politics spammers used these usernames (and more): nempe, neko, ksjnbe23
10:23:26 <kunwon1> zygoloid: yes, it's really only one spammer, he's been banned from this network for some time and he chooses the nicks of people who have banned him/otherwise wronged him
10:23:51 * zygoloid thinks the ban here will not work for long
10:25:59 <lpsmith> yeah,  the ban is going to be way less effective that I thought it would be
10:26:20 <jmcarthur> well, i'm leaving for a bit. hopefully a decent solution comes up besides invite-only
10:26:57 <lpsmith> It's too bad we can't upload a little lua script or something to filter messages that highlight more than 5 people or whatever
10:27:54 * zygoloid /ignore -pattern *##politics* -channels #haskell
10:28:18 <maurer_1> Is it considered more correct to depend on haskell2010, or base, for the purposes of getting the Prelude?
10:28:41 <Saizan> base
10:28:52 <maurer_1> OK. What is depending on haskell2010 intended for?
10:29:07 <conal> New blog post: http://conal.net/blog/posts/from-tries-to-trees/ (last in this series)
10:29:30 <sproingie> wouldn't be too hard to make irssi detect multiple hilights like that
10:30:08 <Twey> From tries to trees?  I thought the progression was usually the other way around.
10:30:14 <kunwon1> lpsmiththere are existing irssi scripts that do that, sproingie 
10:30:16 <kunwon1> xchat too
10:30:18 <sproingie> a trie is a tree
10:30:24 <kunwon1> oops
10:30:25 <sproingie> kunwon1: cool, got a url?
10:30:38 <lpsmith> zygoloid, that's a client side ignore?   
10:30:38 <lpsmith> Or is that something an op can set on a channel?
10:30:47 <zygoloid> lpsmith: client-side, sadly
10:30:50 <sproingie> my irssi-fu is not strong
10:31:05 <sproingie> it's client-side but if it's on an op's account...
10:31:15 <sproingie> suffice to say there are actions other than /ignore
10:31:44 <sproingie> two long lines with >5 hilights each, kick
10:32:42 <kunwon1> sproingie: i can't seem to find the irssi one anymore, but here's the xchat version: http://code.google.com/p/auv5scripts/source/browse/trunk/mass-highlight.pl?spec=svn2&r=2
10:32:52 --- mode: ChanServ set +o copumpkin
10:32:55 <conal> Twey: usually is in my experience, too.
10:33:00 --- mode: copumpkin set +b *kunwon*!*@*
10:33:21 <sproingie> kunwon1: cool, it's perl so it shouldn't be too hard to convert
10:33:32 <sproingie> perl is usually the only thing irssi supports anyway
10:33:40 <kunwon1> i use xchat :D
10:33:55 <sproingie> i use irssi+screen
10:34:00 * mauke gets to work
10:35:31 <sproingie> searching for irssi mass hilight, first hit is a troll site that generates mass hilights
10:35:52 <sproingie> still, i can just reverse the script since it'll have the api for getting at the current nicks
10:36:05 <mauke> er, that's actually documented
10:36:38 <lpsmith_> copumpkin, I'm not sure that the ban is such a good idea
10:36:45 <copumpkin> lpsmith_: why not?
10:36:48 --- mode: copumpkin set -o copumpkin
10:37:05 <copumpkin> I know it isn't actually that person responsible
10:37:06 <zygoloid> copumpkin: before today, none of the spammers matched that mask
10:37:13 <copumpkin> they have actually
10:37:16 <lpsmith_> Because I was wrong in my recollection that the nick used was always kunwon
10:37:17 <copumpkin> I considered it a couple of days ago
10:37:20 <lpsmith_> hmm
10:37:24 <kunwon1> they've been doing it in other channels for weeks
10:37:28 <kunwon1> using my nick, i mean
10:37:36 <copumpkin> oh the real kunwon actually hangs out in here
10:37:41 --- mode: ChanServ set +o copumpkin
10:37:48 --- mode: copumpkin set -b *kunwon*!*@*
10:37:48 <kunwon1> copumpkin: an exempt has been set for me
10:37:50 <lpsmith_> well,  looking at the logs from 4 days ago,  the spammers didn't match that mask
10:37:51 <mauke> copumpkin: ...
10:37:51 <copumpkin> oh okay
10:37:54 <kunwon1> copumpkin: that ban won't effect me
10:38:02 <copumpkin> mauke: ?
10:38:12 <mauke> copumpkin: HE WAS TALKING WHICH IS HOW YOU NOTICED HIM
10:38:19 <mauke> why do you think he's affected by the ban?
10:38:22 <lpsmith_> it says kunwon1 at the beginning of the message,  but the username didn't match
10:38:23 <sproingie> jmcarthur: put an exception in
10:38:25 <sproingie> oops
10:38:27 <copumpkin> people change IPs and masks
10:38:29 <sproingie> jmcarthur put an exception in
10:38:31 <copumpkin> I figured he might be okay now
10:38:32 <kunwon1> they hit a dozen other channels on this network every day
10:38:33 <copumpkin> and not always
10:38:35 <kunwon1> it's been going on for years
10:38:40 <kunwon1> at least one year, anyway
10:39:16 <copumpkin> mauke: so the idea was that he might be affected at other times, but whatever
10:39:20 --- mode: copumpkin set -o kunwon1
10:39:32 <mauke> ah
10:39:33 <ddarius> copumpkin: Just ban *
10:39:40 <lpsmith_> hahaha
10:39:48 <copumpkin> that's the anti-terrorism approach
10:39:53 --- mode: copumpkin set -o copumpkin
10:39:59 <sproingie> put everyone on the no fly list
10:40:21 <Jesin> @help undefine
10:40:21 <lambdabot> undefine. Reset evaluator local bindings
10:40:37 <Jesin> @undefine
10:41:03 <lpsmith_> well,  getting rid of airliners certainly *is* one way of eliminating their potential use as weapons against larger buildings
10:45:18 <aristid> @remember lpsmith well,  getting rid of airliners certainly *is* one way of eliminating their potential use as weapons against larger buildings
10:45:18 <lambdabot> It is forever etched in my memory.
10:45:41 <roconnor> edwardk: the put/get laws stated in http://hackage.haskell.org/packages/archive/comonad-transformers/0.6.2/doc/html/Control-Comonad-Trans-Store-Lazy.html don't type check
10:45:52 <aristid> lpsmith_: that's probably material for #haskell-blah, but i liked the phrase anyways :P
10:45:56 <roconnor> edwardk: mostly because you are using a different type for put than I use.
10:46:43 <aristid> :t put
10:46:44 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
10:46:47 <ddarius> The crack in my classical acoustic is getting wider.
10:47:06 <roconnor> ddarius: does that give the sound more character?
10:47:19 <aristid> roconnor: put for a Comonad?
10:47:25 <roconnor> yes
10:47:27 <ddarius> I don't think it currently changes the quality of the sound in any noticable way.
10:47:30 <roconnor> for the store comonad
10:47:33 <aristid> shouldn't it have a slightly different name to avoid clashes and confusion?
10:47:52 <roconnor> it is in a different module
10:48:09 <aristid> sure, but still.
10:48:13 <roconnor> the two puts are presumably related in someway
10:48:22 <aristid> in what way?
10:48:54 <roconnor> some way
10:50:45 <Jesin> ...
10:50:51 <Jesin> the output of @pl is pretty horrible
10:51:41 <lpsmith> Yeah,  there's often better pointfree definitions than pl provide
10:52:00 <Jesin> :t let cantorFind1 p = (let h = p (True : cantorFind1 (p . (True :))) in h : cantorFind1 (p . (h :))) in cantorFind1
10:52:01 <lambdabot> ([Bool] -> Bool) -> [Bool]
10:52:04 <lpsmith> And pointfree can be taken a little overboard
10:52:15 <Jesin> @pl let cantorFind1 p = (let h = p (True : cantorFind1 (p . (True :))) in h : cantorFind1 (p . (h :))) in cantorFind1
10:52:15 <lambdabot> fix (ap (ap . (ap (:) .) . (. ((. (:)) . (.))) . (.)) (ap id . ((True :) .) . (. (. (True :)))))
10:52:19 <Jesin> ...yeah.
10:52:27 <Jesin> :t fix (ap (ap . (ap (:) .) . (. ((. (:)) . (.))) . (.)) (ap id . ((True :) .) . (. (. (True :)))))
10:52:28 <lambdabot> ([Bool] -> Bool) -> [Bool]
10:53:17 <ddarius> That's, like, ten times clearer.
10:53:22 <sproingie> next time someone asks me for what haskell looks like, i'll point them to something as simple and elegant as fix (ap (ap . (ap (:) .) . (. ((. (:)) . (.))) . (.)) (ap id . ((True :) .) . (. (. (True :)))))
10:53:38 <Jesin> yeah no, @pl is horrible for examples
10:53:40 <Jesin> :p
10:53:51 <sipa> @unpl fix (ap (ap . (ap (:) .) . (. ((. (:)) . (.))) . (.)) (ap id . ((True :) .) . (. (. (True :)))))
10:53:51 <lambdabot> fix ((\ x ac -> (\ bi -> (:) >>= \ ai -> (\ i -> x (\ e -> bi (((:)) i e))) >>= \ ah -> return (ai ah)) >>= \ z -> ac >>= \ y -> return (z y)) >>= \ q -> (\ aw -> (\ j -> j) >>= \ ay -> (\ br ->
10:53:51 <lambdabot> True : aw (\ bx -> br (True : bx))) >>= \ ax -> return (ay ax)) >>= \ p -> return (q p))
10:53:51 <Jesin> Also, @unpl does not know how to expand ap or (>>=) for functions, I think?
10:53:52 <sproingie> i like that it ends with a smiley
10:53:55 <lpsmith> Although,  there might be one pointless idiom that would be quite useful
10:54:10 <sproingie> apparently it can expand ap
10:54:10 <ddarius> Jesin: It would be unsound (in many cases) for it to do so.
10:54:20 <Jesin> well, it can expand ap into (>>=)
10:54:30 <lpsmith> Often I want the combinator   \f g x -> f x && g x
10:54:36 <Jesin> @unpl ap f g
10:54:36 <lambdabot> (f >>= \ b -> g >>= \ a -> return (b a))
10:54:49 <lpsmith> Although I guess technically that is  s (&&) f g
10:55:14 <Jesin> hm?
10:55:15 <Jesin> well
10:55:30 <Jesin> ap = s
10:55:32 <Jesin> :p
10:55:37 <Jesin> as is (<*>)
10:55:42 <Jesin> for functions anyway
10:56:05 <lpsmith> right,  but there isn't a monad instance for functions,  not by default anyway :)
10:56:10 <Jesin> umm
10:56:15 <Jesin> there is in Control.Monad.Instances
10:56:17 <Jesin> :p
10:56:26 <aristid> blame haskell98
10:56:28 <Jesin> return = const
10:56:42 <aristid> join f a = f a a
10:56:54 <aristid> fmap f g = f . g
10:57:01 <lpsmith> well,  more to the point,   I can't write    f `s (&&)` g `s (&&)` h,  which is a little ugly anyway
10:57:03 <ion> > liftM2 (&&) f g $ x
10:57:04 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Bool.Bool)
10:57:04 <lambdabot>    arising from a us...
10:57:06 <Jesin> and m >>= f = join (fmap f m)
10:57:08 <aristid> @src (->) (>>=)
10:57:08 * Kaidelong thought about it the other day and realized that the thing he was thinking of could be done purely with applicative functors, although you'd need various kinds of ugly "uncurries"
10:57:08 <lambdabot> f >>= k = \ r -> k (f r) r
10:57:18 <ion> > liftM2 (z) f g $ x
10:57:18 <lambdabot>   Couldn't match expected type `a1 -> a2 -> b'
10:57:18 <lambdabot>         against inferred type ...
10:57:23 <Kaidelong> those uncurries could be called layouts, I guess
10:57:28 <ion> meh
10:57:38 <byorgey> preflex: seen conal
10:57:38 <preflex>  conal was last seen on #haskell 24 minutes and 44 seconds ago, saying: Twey: usually is in my experience, too.
10:57:40 <Kaidelong> anyway that means I've rediscovered TV
10:57:44 <Kaidelong> and perhaps I should just use TV
10:57:53 <conal> byorgey: hi
10:57:57 <byorgey> conal: happy birthday =)
10:58:03 <conal> byorgey: thanks! :D
10:58:11 <ddarius> > let (-|) = flip; (|-) = id in a -| f (&&) |- b
10:58:11 <lambdabot>   Couldn't match expected type `f (a -> b)'
10:58:11 <lambdabot>         against inferred type `Si...
10:58:12 <Kaidelong> ja veels geluk
10:58:16 <Jesin> @src (->) (<*>)
10:58:16 <lambdabot> (<*>) f g x = f x (g x)
10:58:39 <ddarius> > let (-|) = flip; (|-) = id in a -| f (+) |- b
10:58:39 <lambdabot>   Couldn't match expected type `f (a -> b)'
10:58:39 <lambdabot>         against inferred type `Si...
10:58:47 <ddarius> Expr isn't that clever.
10:59:05 <Jesin> @pl \f g x -> f x &% g x
10:59:05 <lambdabot> liftM2 (&%)
10:59:44 <Jesin> hmm
10:59:46 <Jesin> [14:12:24]	<lpsmith>	well, more to the point, I can't write f `s (&&)` g `s (&&)` h, which is a little ugly anyway
10:59:52 <Jesin> let's see...
11:00:10 <Jesin> @unpl (\x -> f x) <*> (\x -> g x)
11:00:11 <lambdabot> ((\ x -> f x) <*> \ x -> g x)
11:00:22 <Twey> o.@
11:00:25 <Jesin> @unpl (\x -> f x) `ap` (\x -> g x)
11:00:25 <lambdabot> ((\ x -> f x) >>= \ b -> (\ x -> g x) >>= \ a -> return (b a))
11:00:28 <Jesin> =/
11:00:44 <Twey> None of this is point-free to start with
11:00:58 <Jesin> I used the lambdas for the type restriction
11:01:02 <Twey> They should rename @unpl to @uglify :þ
11:01:14 <Jesin> so it was clearly the (r ->) applicative instance, and not just any applicative
11:01:23 <reacocard> how can I have a record-style data hold different instances of a type class? i tried this but it gives me the error afterwards: http://hpaste.org/43525/random_title
11:01:26 <Twey> *nod*
11:01:59 <Twey> f >>= \b -> g >>= return . b
11:02:07 <sipa> reacocard: RenderWin is a type class, and not a type
11:02:11 <Twey> f >>= \b -> fmap b g
11:02:17 <Jesin> unpl should recognize when a function on monads or applicatives uses the (r ->) instance
11:02:19 <Jesin> and expand those
11:02:20 <Twey> f >>= flip fmap g
11:02:20 <sipa> you'll have to write something like RenderWin a => a
11:02:42 <lpsmith> yeah,  and it's not the s combinatory
11:02:42 <lpsmith> liftM2 is right though
11:02:52 <lpsmith> liftA2 is a little better,  that way I don't have to import Control.Monad.Instances
11:02:53 <Jesin> as is liftA2
11:02:57 <portnov> hi
11:03:00 <Jesin> yes
11:03:04 <reacocard> sipa: well see, for different render backends i want eahc to have their own isntance of RenderWin, since they'll need to hold different state, and i want to keep that sate associated with the generic Win it comes from
11:03:14 <portnov> is there a «standard» function to find index of maximal value in the list?
11:03:14 <reacocard> sipa: so how do i do that within haskell's type system?
11:03:55 <copumpkin> portnov: maximum
11:04:10 <copumpkin> > maximum [12,2,6,3,7,1,3]
11:04:11 <lambdabot>   12
11:04:18 <portnov> copumpkin: maximum finds element itself; I need it's index in list.
11:04:21 <kfr> He said index
11:04:23 <copumpkin> oh
11:04:27 <copumpkin> kfr: thank you
11:04:40 <copumpkin> no, but you can compose simple standard functions to get it
11:04:51 <copumpkin> :t maximumBy snd . zip [0..]
11:04:52 <lambdabot>     Occurs check: cannot construct the infinite type:
11:04:52 <lambdabot>       b = (a, b) -> Ordering
11:04:52 <lambdabot>     Probable cause: `snd' is applied to too many arguments
11:04:59 <copumpkin> :t maximumBy (comparing snd) . zip [0..]
11:04:59 <lambdabot> forall a b. (Ord b, Num a, Enum a) => [b] -> (a, b)
11:05:05 <copumpkin> :t fst . maximumBy (comparing snd) . zip [0..]
11:05:06 <lambdabot> forall a b. (Ord b, Num a, Enum a) => [b] -> a
11:05:09 <jetkoten> hi #haskell
11:05:19 <portnov> copumpkin: thanks.
11:05:20 <copumpkin> portnov: if you're looking at indices, it might be a bad sign though (not necessarily)
11:05:37 <Jesin> you may want to use arrays instead of lists
11:05:41 <Jesin> if you're using lots of indices
11:05:42 <Jesin> :p
11:05:49 --- mode: ChanServ set +o monochrom
11:05:50 <portnov> @hoogle comparing
11:05:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:05:52 <kfr> Yeah at first I'd like to hear about the particular use case
11:06:03 --- mode: monochrom set -o monochrom
11:06:23 <Jesin> @src comparing
11:06:24 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:06:34 <Jesin> right, lambdabot doesn't have good source repositories
11:06:38 <copumpkin> comparing = on compare
11:07:25 <aristid> :t on compare
11:07:26 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
11:07:29 <aristid> :t comparing
11:07:30 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
11:08:23 <dafis> hi jetkoten 
11:08:54 <kamaji> how do I call a function with integer arguments from main?
11:09:36 <burp> kamaji: what have you tried?
11:09:39 <kamaji> myfunc 1 2 3
11:09:41 <monochrom> main = f 10
11:09:44 <kamaji> well, print myfunc 1 2 3
11:09:48 <kamaji> is print the problem?
11:09:52 <monochrom> print (myfunc 1 2 3)
11:09:54 <kfr> print $ myfunc 1 2 3
11:09:55 <kamaji> oh balls...
11:09:57 <kamaji> thanks :p
11:10:24 <kfr> kamaji: Otherwise it would be interpreted as a call to print with 4 arguments
11:11:16 <kamaji> kfr: yea, I getcha. Dumb mistake, thanks :)
11:11:32 <kamaji> hopefully by the end of project euler I will stop doing it :D
11:12:50 <jetkoten> kamaji: wow, small world! i have exactly the same question for exactly the same reason! :)
11:12:56 <jetkoten> dafis: hi
11:13:19 <jetkoten> dafis: good to see you again
11:14:07 <dafis> jetkoten: greetings, any new Euler problem under attack?
11:14:07 <jetkoten> dafis: i've just gotten my ghci to change focus the way i wanted, thanks to the list... and i've also just gotten ghc-mod working in my emacs to give me haskell flymake too... things are very good, haskellwise at the moment.
11:14:18 <dafis> nice
11:15:08 <jetkoten> dafis: i'm still working on #2, and looking to figure out how to wrap my code in a module to be able to call from command line with number arguments, just like kamaji (also in the channel right now) is doing...
11:15:34 <dafis> jetkoten: import System.Environment (getArgs)
11:15:35 <jetkoten> dafis: how is everything with you today?
11:15:49 <dafis> jetkoten: fine, so far, and with you?
11:16:16 <roconnor> @tell edwardk I'm becoming increasingly convinced your definition of put in Control.Comonad.Trans.Store.Lazy is wrong
11:16:16 <lambdabot> Consider it noted.
11:16:39 <dafis> jetkoten: and then `args <- getArgs' gives you the list of command line args (as Strings), which you then can parse
11:16:46 <jetkoten> dafis: good thanks, and after having made the progress setting up my emacs, great! :)
11:17:14 <jetkoten> dafis: hmmm, i'm trying to figure out what you've shown me now
11:18:09 <dafis> jetkoten: for example, you want three arguments, two Ints and a Float:
11:18:50 <jetkoten> dafis: i'd already seen this page (to follow) and run the code there before coming across the #2 question, so right now i'm trying to wrap the fibonacci_fast.hs code in a Module to be able to say from the command line "fastfib 33"
11:18:52 <jetkoten> dafis: http://en.literateprograms.org/Fibonacci_numbers_%28Haskell%29
11:19:12 <dafis> main = do { args <- getArgs; let (i1,i2,f) = case args of { (a:b:c:_) -> (read a, read b, read c); _ -> error "too few arguments"; nowDoSomeWork; }
11:19:58 <jetkoten> dafis: i know i need to do module Main where and then main = on a new line 
11:20:56 <dafis> jetkoten: module Main (main) where; import System.Environment (getArgs); main :: IO (); main = getArgs >>= print . fastfib . read . head
11:21:31 <dafis> jetkoten: it will die horrible on malformed input or when called without argument, but for a quick hack, that'll do
11:22:01 <jetkoten> dafis: wow, i never would have guessed that in a million years! thanks. let's see if i can get it running.
11:22:38 <jetkoten> dafis: my flymake is saying parse error on the ( before getArgs... i'll try and run it anyway though
11:23:22 <jetkoten> dafis: some kind of indentation problem? still trying to learn the rules for that
11:23:26 <Kaidelong> @tell Rotaerk I do not know if curry/uncurrying is ever neccessary to write things pointfree unless there is some specific thing you want to do with a tuple
11:23:27 <lambdabot> Consider it noted.
11:23:46 <dafis> jetkoten: replace each ';' with a newline
11:24:14 <dafis> jetkoten: oh, and of course you have to import the module defining fastfib too
11:25:34 <jetkoten> dafis: ok, doing newlines
11:25:54 <dafis> jetkoten: and start each line in the first column
11:26:08 <jetkoten> dafis: importing the module for fastfib, would that be fib in the code?
11:26:12 <mauke> any spambots here? I'd like to test a script
11:26:18 <jetkoten> dafis: and first column meaning no indents for each?
11:26:29 <dafis> jetkoten: probably
11:26:38 <jetkoten> dafis: :)
11:26:47 <dafis> jetkoten: or all indented to the same level
11:26:47 <jetkoten> dafis: and remove the ; each time too/
11:27:08 <zygoloid> mauke: ooh, me, me!
11:27:15 <dafis> jetkoten: not strictly necessary, but it's prettier without ';'
11:27:18 <zygoloid> no wait, i thought you said autobots
11:28:01 <jetkoten> dafis: ok done, now flymake says parse error on import System.Environment, maybe it and all following should be intented one level in?
11:28:17 <jetkoten> dafis: oops, nope, forgot a ;
11:29:32 <jetkoten> dafis: but now re: the (getArgs) on a line by itself flymake says Couldn't match expected type `Q [Dec]'
11:29:52 <jetkoten> dafis: nope, my mistake again... :)
11:30:34 <dafis> jetkoten: the (getArgs) on the same line as the `import System.Environment', or you could leave that away and import the entire module
11:32:36 <jetkoten> dafis: thanks, i just figured it out looking at your code again, and... it works! 
11:32:43 <dafis> :D
11:33:23 <jetkoten> dafis: so i can just use this as a template to work with the other questions hopefully, just substitute the function names for whatever i'd like to pass input and then print... wonderful!
11:34:09 <dafis> jetkoten: but you should learn to fetch and parse args properly nevertheless
11:34:42 <jetkoten> dafis: how would i do that... in one of the tutorials, likely?
11:36:43 <dafis> jetkoten: for more complicate commandline stuff, you should look at System.Console.GetOpt and at the cmdargs package
11:37:57 <dafis> jetkoten: otherwise, args gives you a list of Strings, you just have to make sure you get the right number of them and then parse each arg-String as the appropriate type for that argument
11:38:19 <jetkoten> dafis: thanks, i'm guessing that you did it properly the first time you sent the code with the read a read b read c ... so i can make a note of that code and try and learn it too
11:39:18 <dafis> jetkoten: `read' is fine if you only get well-formed input, if you want to fail gracefully on malformed input, learn to write parsers, e.g. with the parsec package
11:40:10 <dafis> jetkoten: but for this kind of programmes, having it error with ***Exception: Prelude.read: no parse is okay
11:42:18 <jetkoten> dafis: great, thanks very much. y, one of my pet projects that i'd like to do once i get up to speed will involve screen scraping from HTML so, i'll need to learn about parsing
11:43:06 <jetkoten> dafis: actually, i went to the library yesterday and found a lecture series on DVD about discrete mathematics i'm going to watch to try and refresh my memory... there's a whole 1 hour lecture on inclusion/exclusion like from last time. :)
11:43:20 <dafis> jetkoten: cool
11:44:44 <jetkoten> dafis: got two books about the fibonacci sequence too, it's not only popping up in p.e., but a movie i watched the other day too, there was a robot the humans were testing and someone asked him for the 22000th fibonacci number and he calculated it instantly and said "it'd take you 40 years to do this by hand!" hahaha :)
11:45:35 <dafis> jetkoten: which isn't true, even with pencil and paper, it wouldn't take more than a couple of months
11:45:55 <jetkoten> dafis: i had wanted to ask you, besides reading tutorials and working on p.e. and the 99 problems... is there anything else that you would recommend in terms of books or activities for someone to learn Haskell well?
11:45:57 <star_> hello
11:45:59 <dafis> for slow calculators
11:46:37 <jetkoten> dafis: maybe it was 220000th :) it was a huge one, i can't remember which exactly... and entertainment movies aren't always know for their scientific truthfullness at all times. :)
11:46:53 <star_> anyone could give me an example of types of types (kinds) in the real live?
11:47:16 <dafis> jetkoten: books: Real World Haskell, activities: write programmes that interest you; start with smallish things and proceed to larger ones
11:47:23 <sipa> star_: * is the kind of "normal" types
11:47:25 <tibbe> anyone have a copy of the haskellmode-emacs repo?
11:47:58 <sipa> star_: Maybe, for example, has kind * -> *, since it can be seen as a function that takes a (normal) type as argument, and returns a new (normal) type
11:48:48 <jetkoten> dafis: thanks. i've already ordered RWC, should be here maybe today or tomorrow. programming i'm just trying to learn the basics, but it did feel great to achieve completion of p.e. 1, with your kind help of course. i'm actually going to go back to it and do it again with list comps too.
11:49:09 <star_> sipa: thanks but I read some articles about that but I need like a real world example for understandng
11:51:46 <jetkoten> dafis: just getting the basic syntax and conventions is all i hope for at the moment.
11:52:43 <dafis> jetkoten: practice for the syntax, read code for the conventions
11:52:59 <jetkoten> dafis: cool
11:53:28 <dafis> jetkoten: and reading the Haskell report is also a good idea to learn about the syntax and standard libraries
11:53:38 <dafis> @where report
11:53:38 <lambdabot> http://www.haskell.org/onlinereport/
11:55:14 <jetkoten> dafis: ahh, yes, that's a good idea, i've heard people mention it here and there... i also found the 'tour of the prelude' the other day and was reading about the implementation of some of the built-ins there too. many of the implementations there are too abstract for me to comprehend at this point though.
11:55:20 <navaati> hi
11:55:57 <dafis> jetkoten: you need not eat all at once, revisit later when you have more experience
11:56:44 <thierry`> hi, I'm trying to use the ClockTime monad in a recursive function : I want to add the time of the call of the function to a string, how can I do that?
11:56:48 <navaati> is yampa fast enough to work at 44kHz ? I think it could be a lot of fun to make sound with it
11:57:09 <jetkoten> dafis: y, it's hard to find the right blend of do-able and easy-enough though... but that's what things like LYAH seem really good at for getting up to speed with the basics.
11:58:12 <dafis> jetkoten: yeah, it's difficult to find something which is a challenge, but yet within easy enough reach
12:00:05 <jetkoten> dafis: challenge is not a problem for me to find in Haskell so far at all! hahaha
12:00:14 <jetkoten> dafis: easy is... :)
12:00:15 <mauke> I need someone to highlight 5 or more nicks in the same message
12:00:34 <dafis> jetkoten: not easy, just not too difficult
12:00:39 <mauke> I promise it won't hurt much!
12:01:45 <dafis> mauke: how do I highlight nicks?
12:01:49 <jetkoten> dafis: y, but 80 plus percent of the code i read might as well be japanese characters (which i don't read) at this point... but, i do pick up what i can when i can and make progress that way.
12:01:51 <mauke> ...
12:01:56 <mauke> by using them in your message
12:02:03 <dafis> mauke: just mention them or what?
12:02:07 <mauke> yes
12:02:45 <dafis> okay, mauke, I, dafis, talking with jetkoten and waiting for int80_h, also curious about bos and dons do
12:03:19 <dafis> mauke: so, what was supposed to happen?
12:03:28 <dafis> Those were six nicks
12:03:30 <mauke> something :-(
12:03:38 <mauke> no, int80_h isn't
12:03:41 <maurer_> Is there anything like a "Default" typeclass, i.e. class Default a where default :: a
12:03:48 <mauke> maurer_: yes
12:03:51 <dafis> ah, right, he's not online
12:03:53 <mauke> it's on hackage
12:04:01 <thierry`> how can I add a "do" in a function to switch a IO String to a String while keeping a let -- in 
12:04:12 <mauke> thierry`: what
12:04:32 <thierry`> mauke : ok I want to add a IO String to a String in my function
12:04:37 <mauke> no
12:04:55 <thierry`> mauke : ok, no it's not possible or no I shouldn't try that?
12:05:07 <mauke> no, that makes no sense so it's not what you want
12:05:09 <jetkoten> dafis: funny thing in the bookstore yesterday... before the winter holidays i went in: RWH, Prog. in Haskell, Haskell Craft of Func. Prog. were all there. i thought i'd browse them yesterday... all are now gone! :)
12:05:21 <mauke> it's like trying to multiply print by sqrt 2
12:05:34 <dafis> jetkoten: sold or returned to the publisher?
12:06:13 <thierry`> mauke : mmm ok, here's exactly what I want to do: get a ClockTime to get the current time and add it to string to log when the function has been called
12:06:39 <jetkoten> good question, but i think sold... because they have an 'other programming languages' section that is full of other things like erlang, ruby, python, so i'll never know, but it was funny to me that all had evaporated like that. :)
12:07:52 <dafis> jetkoten: sections 'Haskell' and 'other programming languages'? Cool store ;)
12:08:17 <thierry`> mauke : so I stuck with a IO Clocktime that I want to put in a string with the less hassle possible
12:08:22 <thierry`> I'm stuck*
12:08:42 <mauke> thierry`: IO ClockTime is something that when executed will return a ClockTime
12:09:27 <thierry`> mauke : ok then there's something I don't get about monads
12:09:43 <mauke> ignore monads, learn IO
12:09:57 <jetkoten> dafis: well, Haskell was in there with 'other' but, y, i was very pleased to see such diversity in a 'regular' bookstore. it was seeing them there abot a month ago that actually inspired me to learn Haskell, that and the wide range of functionality/domains that Haskell work in/with
12:10:07 <thierry`> mauke: ok so what should I write to simply get a ClockTime and add it to a string in a function?
12:10:25 <mauke> I don't understand "add it to a string"
12:10:57 <navaati> thierry`, i imagine you mean "show and then concatenate" ?
12:11:39 <thierry`> well if I would do "let x = getClockTime,  my_string = show x"
12:12:03 <thierry`> so I want a ClockTime and apply a "show" on it
12:12:19 <Apocalisp> do { x <- getClockTime; let my_string = show x }
12:12:22 <mauke> getClockTime >>= \x -> let my_string = show x in ...
12:12:25 <sipa> ++ does list (or string) concatenation
12:12:36 <thierry`> wow thanks a lot
12:13:36 <mauke> dafis: can you try again?
12:13:38 <Apocalisp> @undo do { x <- getClockTime; return show x ++ foo }
12:13:38 <lambdabot> getClockTime >>= \ x -> return show x ++ foo
12:14:41 <dafis> mauke: I can, I will greetings to bos, dons, zygoloid, jetkoten, Apocalisp, Axman6, ivanm and everybody else, I went for science
12:14:42 --- mode: ChanServ set +o mauke
12:14:42 --- mode: mauke set +q $a:dafis
12:14:51 <navaati> nobody for yampa ?
12:14:56 <mauke> this was a triumph
12:15:03 --- mode: mauke set -q $a:dafis
12:15:16 <dafis> I'm relieved
12:15:33 --- mode: mauke set -o mauke
12:15:40 <mauke> you got hit by: a smooth criminal
12:15:47 <mauke> and three scripts working together
12:16:14 <aristid> dafis: don't mention too many people at once :)
12:16:29 <dafis> aristid: you tell me *now*?
12:16:31 <aristid> especially not bos, dons, zygoloid, jetkoten, Apocalisp, Axman6, ivanm and everybody else
12:16:48 <aristid> mauke: did you deactivate it?
12:17:36 <dafis> mauke: maaauuuuukeee
12:17:37 <mauke> aristid: no, I just set the message length trigger to 150
12:18:10 <aristid>  especially not bos, dons, zygoloid, jetkoten, Apocalisp, Axman6, ivanm and everybody else especially not bos, dons, zygoloid, jetkoten, Apocalisp, Axman6, ivanm and everybody else especially not bos, dons, zygoloid, jetkoten, Apocalisp, Axman6, ivanm and everybody else
12:18:11 --- mode: ChanServ set +o mauke
12:18:11 --- mode: mauke set +q $a:MisterN
12:18:41 --- mode: mauke set -o mauke
12:19:01 <dafis> aristid: sag was
12:19:13 <bos> aristid: knock it off
12:19:31 <dafis> bos: It's all in the interest of science
12:19:41 <bos> i don't care. do it somewhere else.
12:20:09 <dafis> testing mauke's anti-spam script
12:20:16 <jacobian> is there a function: f x = [x]
12:20:21 <mauke> jacobian: return
12:20:23 <dafis> jacobian: return
12:20:27 <FauxFaux> jacobian: return
12:20:56 --- mode: ChanServ set +o mauke
12:20:56 --- mode: mauke set -q $a:MisterN
12:21:26 --- mode: mauke set -o mauke
12:21:29 <aristid> thanks mauke, and sorry to everybody whom i highlighted, it was admittedly rather childish
12:22:01 <lpsmith> mauke, so what is your script supposed to do?
12:22:07 <mauke> dafis++ aristid++  # for playing guinea pig
12:22:14 <aristid> 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
12:22:15 <mauke> lpsmith: detect mass highlighting
12:22:15 <dafis> gracias
12:22:27 <jacobian> hehe, duh
12:22:31 <lpsmith> right,  but how does it respond to mass highlighting?
12:22:39 <lpsmith> Does it benefit the channel or just you?
12:22:39 <djahandarie> Alright I think discussing this has gotten more spammy than the spam itself
12:22:48 <mauke> customizable. current action: temporarily mute the offender
12:23:31 <aristid> mauke: it has thresholds on both number of highlighted people and message length?
12:23:54 <mauke> aristid: yes
12:24:36 <Philippa_> to check the obvious...
12:24:38 <Philippa_> @ops
12:24:38 <lambdabot> Maybe you meant: docs oeis pl
12:24:43 <Philippa_> @op
12:24:43 <lambdabot> Maybe you meant: . ? @ bf do ft id map pl rc v wn yow
12:24:43 <aristid> @where ops
12:24:43 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
12:24:44 --- mode: ChanServ set +o mauke
12:24:44 --- mode: mauke set +q $a:lambdabot
12:24:48 <aristid> HAHAHA
12:24:49 <Philippa_> yeah, that
12:24:55 <mauke> fuck
12:25:01 <copumpkin> lol
12:25:04 --- mode: mauke set -q $a:lambdabot
12:25:04 <aristid> Philippa_: now you also triggered the wrath of bos :P
12:25:34 --- mode: mauke set -o mauke
12:25:47 * mauke ponders
12:25:49 <copumpkin> mauke: wouldn't it be faster to just stay opped? can you handle three of them in a row like the bot catches?
12:25:54 <copumpkin> I mean like the bot produces
12:25:56 <aristid> well, technically it was always me. damn.
12:26:17 <mauke> copumpkin: that's done by another script
12:26:33 <aristid> mauke: just make a special case for lambdabot
12:26:37 <copumpkin> but I mean if the spammer sends a flood of three things in a row
12:26:41 <mauke> it auto-ops me for all commands that require +o
12:27:16 <copumpkin> as he usually does, before he gets killed
12:27:16 <mauke> aristid: I think the Right™ solution would be to remove all nicks from @where ops
12:27:33 <Botje> so how would you get ops then?
12:27:37 <copumpkin> type it anyway
12:27:41 <copumpkin> we set highlights on it
12:27:46 <Philippa_> nah, ignore lambdabot but boot anyone who does @where ops repeatedly
12:27:57 <copumpkin> ops
12:28:15 <aristid> Philippa_: well, that can be abused, i think
12:28:23 <aristid> > "Phi" + "lippa_"
12:28:24 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:28:24 <lambdabot>    arising from a use of `GH...
12:28:28 <aristid> > "Phi" ++ "lippa_"
12:28:30 <lambdabot>   "Philippa_"
12:28:52 <aristid> but then, most spammers don't specifically target haskell channels with lambdabot
12:28:54 <ddarius> aristid: There are still humans.
12:28:55 <copumpkin> there are quite a few ways to make lambdabot say what you want
12:28:58 <Philippa_> aristid: false negatives are tolerable, that one can be dealt with by hand
12:29:47 <aristid> > pred . "dpqvnqljo!jt!sjhiu"
12:29:49 <lambdabot>   "copumpkin is right"
12:30:00 <Philippa_> I mean, there's a reason we're around in the first case
12:30:03 <jetkoten> navaati: just thought of this re: yampa, try haskell-art mailing list?
12:30:21 <aristid> Philippa_: our raison d'être is fighting spam?
12:30:38 <Philippa_> no, it's dealing with stuff that we can't make a bot deal with adequately
12:30:58 <Philippa_> I don't think the arms race is going to get too ridiculous just yet
12:31:10 <Philippa_> (arguably a shame. As in: Mission. Fucking. Accomplished.)
12:31:34 <navaati> jetkoten, actually there's a YampaSynth package (grmbl, every cool idea is already done)… so, must be fast enough
12:31:40 <faluf> Hoping someone could look over this code and give me some basic advice. Questions are in the pastebin. http://hpaste.org/43526/atree
12:31:54 <Philippa_> values of "fast enough" can vary hugely, but sure
12:32:11 <lpsmith> I agree with Philippa_,  it seems tolerable at this stage to ignore lambdabot for now
12:32:13 <Philippa_> (fast enough to do on a core i7 stuff I could do on a 286? Not so difficult to achieve)
12:32:26 <lpsmith> False negatives are perfectly acceptable
12:32:47 <jetkoten> navaati: oh that's neat, y, i'd like to do some sound experiments with Haskell too.
12:32:50 <aristid> faluf: indeed, a lot of these things should not be type synonyms
12:33:04 <aristid> type Version = (Int,Int,Int)
12:33:17 <aristid> why is this a tuple when it could be a data?
12:33:54 <aristid> data Version = Version { versionMajor :: Int, versionMinor :: Int, versionSubminor :: Int }
12:34:02 <Philippa_> because nobody could be arsed to refactor that far yet but at least it lets you write annotations that enable further improvement
12:34:29 <Botje> isn't it about time konsole et al are 'done' ? 
12:34:40 <aristid> Botje: ?
12:34:47 <Botje> hmm
12:34:51 <Philippa_> anyway, I'm off again. Have fun spamblocking
12:34:52 <Botje> this isn't #perl, I take it.
12:35:14 <navaati> aristid, well, godd question : what is the adventages of non-record datatypes over tuples ?
12:35:22 <navaati> s/godd/good/
12:35:53 <aristid> navaati: my type suggestions was a record... but anyways, the advantage is that the type system knows more about it
12:35:59 <faluf> aristid: thanks. I was just not sure of the advantages/disadvantages of using them here. Haven't written much Haskell so I didn't know if this would come back to bite me later
12:36:38 <dafis> navaati: if you use tuples for everything, you have less control over getting the right input, and with data, you can make fields strict if you need to
12:37:04 <navaati> aristid, the type system knows more about "Version Int Int Int" than about "(Int,Int,Int)" ? hum… in which way ?
12:37:16 <jetkoten> dafis: i'm going to go, see you again sometime
12:37:25 <mauke> Version, not Version Int Int Int
12:37:26 <dafis> jetkoten: bye
12:37:29 <aristid> navaati: one could be ANY tuple of 3 ints, the other is a Version
12:38:12 <faluf> aristid: what about those data constructors at the bottom? Better off to write those using record syntax and get rid of all the simple "information" type synonyms in the middle block?
12:38:31 <aristid> faluf: you can keep the simple type synonyms
12:38:40 <aristid> faluf: the idea in (2) seems like a good change too
12:38:46 <aristid> but you can ALSO use record syntax
12:39:57 <aristid> faluf: and clearly you also want a separate Action type
12:40:08 <ddarius> > let f :: (a,b) -> Int; f ((,){}) = 3 in f (2,3)
12:40:09 <lambdabot>   3
12:40:15 <aristid> faluf: that would solve (3)
12:40:39 <aristid> ddarius: is this haskell 98?
12:40:46 <boegel> someone familiar with the FGL library in here who can help me out?
12:40:51 <thierry`> how can I do something like my_string ++ my_io_string and get a IO String? (my_string is String and my_io_string is IO String type)
12:40:59 <aristid> preflex: seen ivanm
12:40:59 <ddarius> aristid: Yes.
12:41:00 <preflex>  ivanm was last seen on #haskell 2 days, 7 hours, 24 minutes and 6 seconds ago, saying: oh, forgot about hinotify
12:41:06 <boegel> I'm trying to figure out how to find the minimum distance between two nodes in a graph...
12:41:34 <pedro3005> how do you implement a factorial function that uses constant storage?
12:41:38 <boegel> I figured constructing the msTree (minimal spanning tree) would allow me to do that, but it seems I'm mistaken....
12:41:49 <mauke> pedro3005: limit the size of allowed numbers
12:42:06 <pedro3005> even so
12:42:11 <dafis> pedro3005: factorial :: Int -> Int
12:42:15 <faluf> aristid: If I created a seperate action type, how would I go about creating a tree that contains both items and actions while only allowing actions to be internal nodes? assuming I'm using Data.Tree and not rolling my own
12:42:15 <aristid> pedro3005: fortunately you can easily accomplish this by using only 64-bit numbers
12:42:41 <dafis> aristid: what a waste when we have 8-bit numbers
12:42:46 <aristid> faluf: using Data.Tree, you cannot.
12:43:00 <aristid> dafis: huh?
12:43:10 <ddarius> const True, one-bit factorial
12:43:21 <pedro3005> but on the usual recursive defintion, don't you store in memory all the subsequent numbers down to one? factorial 5 gets reduced to 5 * 4 * 3 * 2 * 1, so stored 5 numbers. factorial n stores n numbers, O(n) storage
12:43:37 <dafis> aristid: Word8 (I know they take WORD_SIZE_IN_BITS bits actually, except in UArrays)
12:43:48 <gigabytes> pedro3005: what you want is the tail recursive version
12:43:55 <mauke> pedro3005: no, we fuse list generation and consumption
12:44:00 <aristid> dafis: i still don't follow
12:44:07 <pedro3005> mauke, explain?
12:44:12 <mauke> at least I hope we actually do
12:44:20 <mauke> factorial n = product [1 .. n]
12:44:21 <pedro3005> gigabytes, how would that go in haskell?
12:44:38 <ddarius> mauke: product is a good consumer and enumFromTo is a good producer
12:44:43 <dafis> pedro3005: factorial n = foldl' (*) 1 [1 .. n] should run in constant space (disregarding the size of the result) when compiled with -O
12:44:43 <mauke> yay!
12:44:57 <ddarius> Actually, product isn't a good consumer I don't think.
12:45:04 <ddarius> In stream-fusion it would work though.
12:45:30 <faluf> aristid: ok, I had originally written it _without_ Data.Tree because of this. Would it be worth it to abandon the library for this guarantee? In other words, would this condition be difficult to enforce 
12:45:35 <gigabytes> pedro3005: like any other language. fact 0 a = n; fact n a = fact (n-1) n*a
12:45:56 <djahandarie> Neat post from conal :) http://conal.net/blog/posts/from-tries-to-trees/
12:45:57 <dafis> aristid: you suggested limiting the size by using 64-bit numbers, I reduced the size by limiting to 8-bit numbers
12:46:18 <pedro3005> gigabytes, but then you'd need to call factorial with two parameters
12:46:18 <aristid> dafis: no gain, both is constant size, fulfilling the requirement.
12:46:27 <pedro3005> which doesn't make sense
12:46:31 <aristid> dafis: you can't get more constant than constant
12:46:40 <dafis> aristid: an eight-fold memory reduction is no gain?
12:46:53 <aristid> dafis: indeed.
12:46:54 <dafis> aristid: but you can get smaller constants
12:47:04 <gigabytes> pedro3005: just rename it... fact n = fact' n 1 where fact' =....
12:47:05 <aristid> dafis: but small constants were not a requirement.
12:47:32 <dafis> aristid: no, but why not optimise for space?
12:47:58 <aristid> dafis: why not optimise for size of accepted input space?
12:48:24 <aristid> dafis: but you are right that i should have used Word64, not Int64 :)
12:48:28 <dafis> aristid: then use Integer, those are also constant size
12:49:39 <edwardk> preflex: xseen djahandarie
12:49:39 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:49:39 <preflex>  djahandarie was last seen on freenode/#haskell 3 minutes and 43 seconds ago, saying: Neat post from conal :) http://conal.net/blog/posts/from-tries-to-trees/
12:50:08 <edwardk> @tell roconnor how so?
12:50:08 <lambdabot> Consider it noted.
12:50:17 <djahandarie> yo
12:50:30 <edwardk> djahandarie: what went wrong with the type family definition of newtype under ghc < 7 ?
12:51:29 <djahandarie> Hmm, it wouldn't fully infer things sometimes
12:52:15 <djahandarie> The type family would still be left in the type sometimes basically
12:53:19 <edwardk> probably with partial applications?
12:53:40 <roconnor> edwardk: well I want a function put0 b (StoreT f _) = StoreT f b.  You said I just extend your put to get that, but extending put doesn't yield that function.
12:53:41 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
12:53:45 <djahandarie> Yes, that was when it was most noticiable, but I think I got it to happen even when you fully applied things
12:54:02 <pumpkin> yeah, even full application screwed up
12:54:05 <pumpkin> I'd just call it a bug
12:54:12 <Jesin> it's fixed in GHC 7 though?
12:54:13 <edwardk> roconnor: =/
12:54:15 <pumpkin> and screw working around bugs
12:54:16 <pumpkin> yeah
12:54:37 <djahandarie> It's odd though, since it is incredibly simple code
12:54:44 <pozic> GHC contains bugs? NO WAI!
12:54:59 <edwardk> roconnor: now i'm trying to figure out what my put means. i really want put to be a cokleisli action and that is the definition that is
12:55:21 <roconnor> what can I say
12:55:51 <pedro3005> what is wrong with http://paste.pocoo.org/show/330782/ ?
12:55:54 <Jesin> :t (,){}
12:55:55 <lambdabot> forall a b. (a, b)
12:56:00 <Jesin> :t (,)
12:56:01 <lambdabot> forall a b. a -> b -> (a, b)
12:56:01 <edwardk> because ultimately put/get onad side are kleisli actions
12:56:05 <edwardk> er monad
12:56:12 <Jesin> ...ooh.
12:56:13 <Jesin> hmm.
12:56:23 <Botje> you want a * m, not a * n
12:56:24 <Jesin> :k (,)
12:56:24 <lambdabot> * -> * -> *
12:56:38 <pedro3005> duh, sorry
12:56:51 <Jesin> :t []{}
12:56:52 <lambdabot> forall a. [a]
12:56:58 <Jesin> > []{}
12:56:59 <lambdabot>   []
12:57:03 <Jesin> > [,]{}
12:57:04 <lambdabot>   <no location info>: parse error on input `,'
12:57:09 <Jesin> > (:){}
12:57:09 <lambdabot>   [*Exception: <interactive>:3:0-4: Missing field in record construction
12:57:36 <edwardk> i need to update the haddocks there anyways, since it doesn't bother extending the get action, etc.
12:58:12 <dafis> pedro3005: what's the problem?
12:58:20 <pedro3005> Botje pointed it out
12:58:36 <pedro3005> I function was evaluating n^n not n!
12:58:36 <dafis> ah, yes
12:58:54 <pedro3005> my*
12:59:04 <edwardk> roconnor: with your definition of put, you could 'put' in Env as well, which is kinda odd
12:59:48 <Jesin> > (,){}
12:59:49 <lambdabot>   (*Exception: <interactive>:3:0-4: Missing field in record construction
12:59:57 <Jesin> > (,){2,3}
12:59:58 <lambdabot>   <no location info>: parse error on input `2'
13:00:10 <Jesin> > (,){fst=2,snd=3}
13:00:11 <lambdabot>   Constructor `(,)' does not have field `Data.Tuple.fst'Constructor `(,)' doe...
13:00:13 <roconnor> edwardk: I don't see any way of defining my put by extending something
13:00:21 <Jesin> hmm.
13:00:31 <dafis> > (,) 2 3
13:00:32 <lambdabot>   (2,3)
13:00:38 <edwardk> i don't know that you can. one sec. trying to play with the laws for a minute
13:00:41 <Jesin> umm
13:00:43 <roconnor> edwardk: because extend doesn't move the location of the head in the store
13:00:45 <Jesin> why does this work:
13:00:47 <edwardk> wondering if they are inside out
13:00:48 <Jesin> :t (,,){}
13:00:49 <lambdabot> forall a b c. (a, b, c)
13:01:03 <roconnor> edwardk: and put is the primitive operation for moving the location of the head in the store.
13:01:10 <aristid> > (,,){}
13:01:10 <Jesin> :k (,,){}
13:01:11 <lambdabot>   (*Exception: <interactive>:3:0-5: Missing field in record construction
13:01:11 <lambdabot>     Unexpected record type {}
13:01:11 <lambdabot>     In the type `(,,) {}'
13:01:37 <ddarius> That kind error is a bit odd...
13:01:42 <Jesin> > (,,) {1; 2; 3}
13:01:42 <lambdabot>   <no location info>: parse error on input `1'
13:01:50 <dafis> Jesin: you can use record syntax with empty braces on all constructors, if you put values in, it only works when they were defined with record syntax
13:02:00 <Jesin> hmm, k
13:02:12 <thierry`> I, I'm trying to call a recursive function have a IO String in his type with a String, is there any way to do that?
13:03:02 <Jesin> because yeah, data constructors are a particular thing, not the same as functions, though they can act as functions
13:03:06 <Jesin> got it
13:03:17 <Jesin> umm
13:03:25 <Jesin> [16:17:39]	<thierry`>	I, I'm trying to call a recursive function have a IO String in his type with a String, is there any way to do that?
13:03:26 <homekevin> This is making my head hurt: flip' f x y = f y x
13:03:29 <ddarius> Data constructors are functions.  They're just special functions.
13:03:38 <Jesin> what do you mean "with a string"
13:03:48 <byorgey> thierry`: you can wrap the String in a call to 'return'
13:03:57 <byorgey> if s :: String, then (return s) :: IO String
13:04:13 <Jesin> well, technically
13:04:14 <thierry`> byorgey : nice exactly what I wanted
13:04:16 <Jesin> :t return s
13:04:16 <lambdabot> forall (m :: * -> *). (Monad m) => m Expr
13:04:27 <Jesin> :t return (s :: String)
13:04:28 <lambdabot>     Couldn't match expected type `String' against inferred type `Expr'
13:04:28 <lambdabot>     In the first argument of `return', namely `(s :: String)'
13:04:28 <lambdabot>     In the expression: return (s :: String)
13:04:31 <Jesin> wait what
13:04:34 <pumpkin> lol
13:04:39 <Jesin> :t return "foo"
13:04:40 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
13:04:42 <pumpkin> who provides s?
13:04:51 <ddarius> pumpkin: Lambdabot.
13:04:51 <pumpkin> Jesin: you certainly didn't!
13:04:53 <byorgey> homekevin: is there something particular you're confused about?
13:04:53 <pumpkin> I know
13:04:56 <pumpkin> it was rhetorical :)
13:05:12 <aristid> :t s
13:05:13 <lambdabot> Expr
13:05:14 <Jesin> but, this does work:
13:05:19 <aristid> > s
13:05:20 <lambdabot>   s
13:05:29 <aristid> > f s
13:05:30 <Jesin> :t return "foo" :: IO String
13:05:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:05:30 <lambdabot>    `GHC.Show.Show a'
13:05:30 <lambdabot>      a...
13:05:31 <lambdabot> IO String
13:05:35 <Jesin> :t return "foo" :: IO String
13:05:35 <lambdabot> IO String
13:05:39 <Jesin> there
13:05:41 <pumpkin> Jesin: yeah, sure, no s there
13:05:41 <homekevin> byorgey: No, not really anything specific. It's just hard for me to understand the x and y as arguments to f rather than arguments to flip'
13:05:42 <Jesin> :p
13:06:00 <Jesin> oh
13:06:10 <Jesin> homekevin, that's just getting an intuition for currying
13:06:11 <dafis> homekevin: does flip' f = \x y -> f y x make it better?
13:06:16 <byorgey> homekevin: oh, but they are arguments to flip'.  Flip takes three arguments, a function and two other arguments, and applies the function to its other two arguments.
13:06:29 <homekevin> dafis: I haven't learned \ yet.
13:06:35 <dafis> oh
13:06:39 <byorgey> homekevin: \ just makes an anonymous function
13:06:43 <dafis> ignore that, then
13:06:47 <Jesin> how about flip' f = \x -> \y -> f y x
13:06:51 <Jesin> :P
13:06:52 <byorgey> like \x -> x + 3  is a function which takes an argument x and adds 3 to it
13:07:02 <dafis> homekevin: flip' f = g where g x y = f y x
13:07:18 <homekevin> dafis: Yeah, that was how I wrote it the first time.
13:07:26 <Jesin> :t let flip' f = g where g x y = f y x in flip'
13:07:27 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t1 -> t -> t2
13:07:30 <Jesin> :p
13:07:31 <homekevin> Then I saw the shorter version.
13:07:38 <Jesin> by this time
13:07:49 <Jesin> hmm.
13:08:24 <ddarius> :t let swap (x,y) = (y,x) in curry . (. swap) . uncurry
13:08:25 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
13:08:26 <Jesin> well, I guess I've gotten used to thinking of functions as curried
13:08:43 <Jesin> :p
13:08:56 <Jesin> ooh!
13:09:04 <maurer_> If I want a (Map Word64 a) type, but want to implement it as IntMap a on 64-bit or higher systems, and as Map Word64 otherwise, what is the best way to do this?
13:09:06 <homekevin> byorgey: I think you raised a good point, there. I believe I'm making a false distinction between arguments to f and arguments to flip'... or something like that.
13:09:06 <Jesin> homekevin, here's a cool trick
13:09:10 <Jesin> :t id
13:09:11 <lambdabot> forall a. a -> a
13:09:12 <Jesin> :t flip
13:09:12 <maurer_> I'm currently likely to use the CPP macro system.
13:09:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:09:17 <Jesin> ...
13:09:22 <Jesin> WHAT DID THEY DO TO FLIP
13:09:26 <pumpkin> :y P.flip
13:09:27 <Jesin> it's defined with (.), isn't it
13:09:35 <pumpkin> :t P.flip
13:09:36 <Jesin> @src flip
13:09:36 <lambdabot> Couldn't find qualified module.
13:09:36 <lambdabot> flip f x y = f y x
13:09:39 <Jesin> ...
13:09:50 <Jesin> because lambdabot's source database sucks
13:09:52 <Jesin> =/
13:09:54 <Jesin> hmm
13:09:57 <pumpkin> nah, Cale's just too radical
13:10:00 <dafis> :t Prelude.flip
13:10:01 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:10:08 <byorgey> homekevin: let me put it this way: you could think of flip' as a function that takes one argument and returns a function of two arguments.  Or you could think of it as a function of three arguments.  In Haskell, these are just two different ways of looking at the same thing.
13:10:13 <byorgey> homekevin: it does take some getting used to.
13:10:23 <aristid> :t flip'
13:10:24 <lambdabot> Not in scope: `flip''
13:10:31 <aristid> flip'?
13:10:43 <Jesin> homekevin: what byorgey said, basically  :p
13:10:46 <Jesin> in particular
13:10:49 <homekevin> I see what you mean byorgey, but I'll have to process it for a while before my brain will accept it, I think.
13:10:51 <byorgey> homekevin: in other words, every function that "takes multiple arguments" actually takes one argument and returns a function.
13:10:59 <byorgey> homekevin: yup, that's normal =)
13:11:45 <Jesin> flip is a function, (flip f) is a function, (flip f x) is a function which equals ((flip f) x)
13:11:48 <monochrom> @quote monochrom ary
13:11:48 <lambdabot> monochrom says: [..] the standard library should not come with all conceivable data structures; instead it should come with a coupon for a course on how to design data structures.
13:11:52 <monochrom> @quote monochrom 17-ary
13:11:53 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
13:12:33 <Jesin> :t curry id
13:12:34 <lambdabot> forall a b. a -> b -> (a, b)
13:12:43 <Jesin> :t (,)
13:12:44 <lambdabot> forall a b. a -> b -> (a, b)
13:12:45 <Jesin> lol  :p
13:12:45 <Apocalisp> :t \x -> map ($ x)
13:12:46 <lambdabot> forall a b. a -> [a -> b] -> [b]
13:12:57 <Jesin> :t map (flip id)
13:12:58 <lambdabot> forall a b. [a] -> [(a -> b) -> b]
13:13:12 <Apocalisp> :t fmap $ flip id
13:13:13 <Jesin> :t map . (flip id)
13:13:13 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f a -> f ((a -> b) -> b)
13:13:13 <lambdabot> forall b a. a -> [a -> b] -> [b]
13:13:36 <Jesin> :t fmap . flip id
13:13:37 <lambdabot> forall b (f :: * -> *) a. (Functor f) => a -> f (a -> b) -> f b
13:13:41 <Jesin> :p
13:14:08 <Apocalisp> @pl \fs x -> map ($x) fs
13:14:09 <lambdabot> flip (map . flip id)
13:14:09 <aristid> :t flip
13:14:09 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:14:27 <Jesin> wtf did they do to flip
13:14:28 <Jesin> hmm
13:14:34 <byorgey> Jesin: generalized it
13:14:34 <aristid> :t \f a -> fmap ($ a) f
13:14:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
13:14:36 <Jesin> flip f x y = f y x
13:14:40 --- mode: ChanServ set +o mauke
13:14:40 --- mode: mauke set -q $a:dafis
13:14:49 <byorgey> Jesin: the Prelude flip uses the ((->) e) functor
13:14:50 <aristid> mauke: ?
13:14:52 <djahandarie> let f == (c ->)
13:14:56 <Apocalisp> :t flip (fmap . flip id)
13:14:56 <lambdabot> forall b (f :: * -> *) a. (Functor f) => f (a -> b) -> a -> f b
13:15:01 <Jesin> yes, byorgey, I got it
13:15:08 <Kaidelong> for any exhaustive pattern (not including view patterns), prove that it is exhaustive
13:15:12 <Kaidelong> is this decidable or not?
13:15:26 <Jesin> @pl (fmap . flip id)
13:15:27 <lambdabot> fmap . flip id
13:15:30 --- mode: mauke set -o mauke
13:15:35 <Jesin> @pl flip (fmap . flip id)
13:15:35 <lambdabot> flip (fmap . flip id)
13:15:37 <mauke> aristid: insufficient smartness in tmpmute
13:15:39 <Jesin> =/
13:15:39 <Jesin> hmm
13:15:40 <byorgey> Kaidelong: it is decidable if you just have pattern-matching and not guards
13:15:45 <byorgey> Kaidelong: with guards it is undecidable
13:15:45 <Jesin> @unpl flip (fmap . flip id)
13:15:46 <lambdabot> (\ b c -> fmap (\ f -> f c) b)
13:15:48 <Kaidelong> thank you
13:16:39 <Jesin> (\f x -> fmap (\g -> g x) f)
13:16:43 <Jesin> :t (\f x -> fmap (\g -> g x) f)
13:16:44 <lambdabot> forall t b (f :: * -> *). (Functor f) => f (t -> b) -> t -> f b
13:16:49 <Jesin> :t flip
13:16:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:17:31 <Jesin> f . g = \x -> f (g x)
13:17:48 <Kaidelong> byorgey: Am I right to believe that including view patterns will make it undecidable? It seems "obvious" to me in that using a view pattern means performing potentially arbitrary computations
13:18:06 <maurer_2> Is there any way for me to detect if I am on a 64 vs 32 bit platform under Cabal?
13:18:08 <byorgey> Kaidelong: yes, I think you are right
13:18:09 --- mode: ChanServ set +o mauke
13:18:09 --- mode: mauke set -q $a:MisterN
13:18:29 <Jesin> (\g -> g x) . f = \y -> (\g -> g x) (f y)
13:18:51 <dafis> maurer_2: check fromIntegral (maxBound :: Int) in Setup.hs
13:18:59 --- mode: mauke set -o mauke
13:19:06 <Jesin> :t \f x -> \y -> (\g -> g x) (f y)
13:19:07 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
13:19:36 <Jesin> so
13:19:37 <maurer_2> dafis: How do I get that information to my build? I'm trying to pick between two implementations of a data structure at compile time, one of which will only operate properly on 64 bit systems.
13:19:56 <dafis> maurer_2: then I'd recommend CPP
13:19:59 <byorgey> Jesin: ah, very nice
13:20:14 <Jesin> :t let flip' f x = fmap ($ x) f in flip'
13:20:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:20:17 <Jesin> :t flip
13:20:17 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:20:20 <maurer_2> dafis: Yeah, I've got it separated with a CPP #if clause, but I don't know how to get the bittage to a CPP variable to test it.
13:20:23 <Jesin> so that's what he did.
13:20:40 <dafis> maurer_2: #include "MachDeps.h"
13:20:48 <Jesin> :t let flip' f x = ($ x) . f in flip'
13:20:49 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:20:57 <dafis> maurer_2: #if WORD_SIZE_IN_BITS == 64
13:21:01 <maurer_2> Thanks.
13:21:15 <maurer_2> I was trying to use WORD_SIZE_IN_BITS, but didn't know about MachDeps.h
13:21:33 <dafis> maurer_2: it's GHC only, unfortunately, afaik
13:22:10 <maurer_2> dafis: That's fine. If WORD_SIZE_IN_BITS is undefined, it takes the else clause and falls back to the regular implementation
13:22:21 <maurer_2> The 64-bit sped-up version is GHC only anyways.
13:22:39 <dafis> maurer_2: that's fine, then
13:23:00 <aristid> few people use compilers other than ghc nowadays
13:23:00 <stepkut> haddock does not seem to list what types are instances of various classes anymore.. am I doing something wrong?
13:23:24 <dafis> maurer_2: wrap the #include "MachDeps.h" in an #ifdef __GLASGOW_HASKELL__ though
13:23:33 <maurer_2> Ah, good idea, thanks.
13:24:32 <Jesin> seriously, ($ x) . f
13:24:42 --- mode: ChanServ set +o mauke
13:24:42 --- mode: mauke set -q $a:lambdabot
13:24:50 <pumpkin> lol
13:25:18 <ski> @botsnack
13:25:18 <lambdabot> :)
13:25:33 --- mode: mauke set -o mauke
13:27:15 <jmcarthur> is this script even worth it?
13:30:22 <byorgey> let f f = f in f 3  -- any guesses what this does?
13:30:34 <byorgey> no fair asking lambdabot
13:31:38 <jmcarthur> wow trivial
13:31:40 <jmcarthur> err
13:31:42 <jmcarthur> *trivia
13:32:54 <pumpkin> yep
13:33:20 <Jesin> ...lol!
13:33:20 <pumpkin> well, I'm pretty sure I know what it does
13:33:25 <maurer_2> byorgey: Why would that be hard?
13:33:34 <stepkut> byorgey: I would guess that the second f shadows the first f, so we have, let f f' = f' in f 3, which is like, let id x = x in id 3. But I could be wrong :)
13:33:41 * stepkut checks his answer
13:33:44 <Jesin> nope
13:33:49 <byorgey> maurer_2: it isn't necessarily obvious which f refers to what.
13:33:51 <Jesin> :t let f f = f in f 3
13:33:52 <lambdabot> forall t. (Num t) => t
13:33:57 <Jesin> wait what
13:33:58 <ddarius> pumpkin: You weren't immediately sure?
13:34:02 <Jesin> > let f f = f in f 3
13:34:03 <lambdabot>   3
13:34:05 <Jesin> whaaaat
13:34:06 <pumpkin> ddarius: I'm never 100% sure!
13:34:07 <Jesin> WHY
13:34:12 <pumpkin> Jesin: shadowing
13:34:13 <byorgey> stepkut is correct =)
13:34:15 <maurer_2> scoping
13:34:28 <pumpkin> who wants to guess at what 
13:34:28 <jmcarthur> based on the type signature i'd say it's 3
13:34:29 <Jesin> :t let f f = f in f
13:34:30 <lambdabot> forall t. t -> t
13:34:38 <pumpkin> let f f f = f f in f 3 3 does?
13:34:45 <pumpkin> ;)
13:34:48 <jmcarthur> because if it was making f = \x -> _|_ then it would have a different type
13:34:52 <Jesin> :t let f f f = f f in f
13:34:53 <lambdabot>     Conflicting definitions for `f'
13:34:53 <lambdabot>     Bound at: <interactive>:1:6
13:34:53 <lambdabot>               <interactive>:1:8
13:34:55 <byorgey> pumpkin: well now, that's an error =)
13:35:11 <pumpkin> here's a tricky one
13:35:12 <Jesin> :t let f f = f f in f
13:35:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:35:13 <lambdabot>     Probable cause: `f' is applied to too many arguments
13:35:13 <lambdabot>     In the expression: f f
13:35:17 <jmcarthur> of course somebody would cheat before i get the answer out
13:35:32 <Jesin> jmcarthur, it was guessed correctly
13:35:35 <Jesin> before I cheated
13:35:37 <Jesin> :p
13:35:43 <Jesin> (I guessed wrong)
13:35:48 <byorgey> jmcarthur: I like your type-based reasoning though =)
13:35:53 <pumpkin> guess what this does: let f ~((a, b), (c, d)) = c + d in f (undefined, (5, 6))
13:35:54 <pumpkin> no cheating
13:36:23 <pumpkin> I guess I didn't need a ~ there
13:36:23 <aristid> 11?
13:36:27 <pumpkin> no
13:36:27 <jmcarthur> huh
13:36:32 <Jesin> it's either 11 or _|_
13:36:32 <ddarius> pumpkin: You did.
13:36:34 <jmcarthur> _|_ i guess
13:36:38 <pumpkin> oh I did, yeah
13:36:40 <ezyang> Anyone have a copy of "Circular Programs and Self-Referential Structures"? 
13:36:46 <jmcarthur> the ~ was critical to throwing us off!
13:36:50 <Jesin> but yeah, the pattern-match fails
13:36:52 <Jesin> I wonder, though
13:36:55 <pumpkin> it does?
13:36:56 * hackagebot comonad-transformers 1.4.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.4.0 (EdwardKmett)
13:37:04 <Jesin> > let f ~((a, b), (c, d)) = c + d in f (undefined, (5, 6))
13:37:05 <lambdabot>   *Exception: Prelude.undefined
13:37:12 <Jesin> > let f ~(~(a, b), (c, d)) = c + d in f (undefined, (5, 6))
13:37:12 <lambdabot>   11
13:37:15 <Jesin> haha
13:37:15 <ddarius> jmcarthur: pumpkin though he wrote something more like let ~(..., ...) in ... for a second. 
13:37:20 <Jesin> I was right
13:37:21 <Jesin> :p
13:37:23 <edwardk> roconnor: ok. i gave you the comonad-transformer version you wanted, now you need to fix the comonads-fd instances ;)
13:37:24 <pumpkin> ddarius: wow, you can read my mind
13:38:22 <Jesin> > let ~(f ~(~(a, b), (c, d))) = c + d in f (undefined, (5, 6))
13:38:23 <lambdabot>   <no location info>: Parse error in pattern
13:38:25 <Jesin> :p
13:38:35 <jmcarthur> fail
13:38:56 <pumpkin> I still find that case slightly puzzling
13:39:02 <Jesin> > let ~(~a,~b)=(undefined, 3) in b
13:39:03 <lambdabot>   3
13:39:04 <ddarius> pumpkin: Your case?
13:39:06 <pumpkin> but not 100% puzzling
13:39:07 <pumpkin> yeah
13:39:11 <Jesin> > let ~(a,b)=(undefined, 3) in b
13:39:12 <lambdabot>   3
13:39:16 <Jesin> wat
13:39:21 <pumpkin> Jesin: exactly :P
13:39:29 <Jesin> oh
13:39:29 * allbery_b is pleased to learn that he guessed right
13:39:30 <Jesin> I get it
13:39:33 <pumpkin> well
13:39:34 <ddarius> > let f ~ x = x in f ~ 3
13:39:35 <lambdabot>   Pattern syntax in expression context: ~3
13:39:35 <pumpkin> you used a let there
13:39:37 <pumpkin> which is different
13:39:39 <Jesin> it doesn't try to parse the 'a' in the last thing
13:39:59 <Jesin> but in the first thing, it tries to parse undefined into (a,b)
13:39:59 <pumpkin> > let f ~(a, (b, c)) = b + c in f (undefined, (1,2))
13:40:00 <lambdabot>   3
13:40:03 <Jesin> which is what fails
13:40:03 * ddarius would be unhappy with guessing whether or not the end result was right.
13:40:09 <pumpkin> > let f ~((x,y), (b, c)) = b + c in f (undefined, (1,2))
13:40:10 <lambdabot>   *Exception: Prelude.undefined
13:40:24 <Jesin> because undefined is not of the form (x,y)
13:40:26 <Jesin> :p
13:40:35 <jmcarthur> this on isn't really a mind bender, just trivia:
13:40:37 <ski> Jesin : s/parse/match/
13:40:40 <jmcarthur> let f a@b@c@d@e = a + b + c + d + e in f 5
13:40:50 <pumpkin> that's cute
13:40:50 <Jesin> ....lol
13:40:52 <byorgey> haha
13:40:58 <Jesin> > let f a@b@c@d@e = a + b + c + d + e in f 5
13:40:59 <lambdabot>   25
13:41:03 <Jesin> :p
13:41:15 <Jesin> hmm
13:41:27 <Jesin> > let f (n+1) = n in f 5
13:41:27 <aristid> jmcarthur: it does precisely what one would expect?
13:41:28 <lambdabot>   <no location info>: Parse error in pattern
13:41:39 <Jesin> so lambdabot has the n+k thing removed, got it
13:41:52 <jmcarthur> aristid: it's just a matter of whether you have been convinced that it's valid syntax or not
13:42:18 <aristid> jmcarthur: it seemed plausible enough :)
13:42:25 <Jesin> hmm...
13:42:34 <jmcarthur> still useless, unless you're trying to write obfuscated code
13:42:36 <Jesin> let a@b@c = 5 in a+b+c
13:42:39 <Jesin> > let a@b@c = 5 in a+b+c
13:42:40 <lambdabot>   15
13:42:45 <halcyon10> hi, cabal gives me the error "cabal: ar is required but it could not be found." when i try to install a package. Anyone know what's missing?
13:43:03 <Jesin> case 5 of a@b@c -> (a,b,c)
13:43:07 <Jesin> > case 5 of a@b@c -> (a,b,c)
13:43:08 <lambdabot>   (5,5,5)
13:43:14 <monochrom> seems "ar" is missing. it's a unix/linux program to produce lib files.
13:43:21 <Jesin> :t case 5 of a@b@c -> (a,b,c)
13:43:22 <lambdabot> forall t. (Num t) => (t, t, t)
13:43:59 <Jesin> :t join $ join $ (,,)
13:44:00 <lambdabot> forall c. c -> (c, c, c)
13:44:07 <dcoutts> halcyon10: interesting, what platform? does ghc work?
13:44:13 <Jesin> :t join curry
13:44:14 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b) -> c
13:44:14 <lambdabot>     Probable cause: `curry' is applied to too few arguments
13:44:14 <lambdabot>     In the first argument of `join', namely `curry'
13:44:17 <Jesin> :t join uncurry
13:44:18 <lambdabot>     Couldn't match expected type `a -> b -> a1'
13:44:18 <lambdabot>            against inferred type `(a, b)'
13:44:18 <lambdabot>       Expected type: (a -> b -> a1) -> (a -> b -> a1) -> a1
13:44:23 <Jesin> :t join . uncurry
13:44:24 <lambdabot> forall a a1 b. (a1 -> b -> (a1, b) -> a) -> (a1, b) -> a
13:44:28 <Jesin> :t join . curry
13:44:29 <lambdabot> forall a b. ((b, b) -> a) -> b -> a
13:44:41 <Jesin> :t join . uncurry . (,)
13:44:45 <lambdabot>     Couldn't match expected type `b -> (a1, b) -> a'
13:44:46 <halcyon10> dcoutts: i'm on mac os x and installed the haskell platform. ghc is working
13:44:49 <lambdabot>            against inferred type `(a2, a1)'
13:44:53 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
13:45:09 <Jesin> :t join . curry . id
13:45:11 <Jesin> :t join . curry id
13:45:13 <lambdabot> forall a b. ((b, b) -> a) -> b -> a
13:45:14 <dcoutts> halcyon10: so the programs gcc and ld are present, but ar is not?
13:45:17 <lambdabot>     Couldn't match expected type `(a, (a, b))'
13:45:19 <lambdabot>            against inferred type `b -> (a, b)'
13:45:21 <lambdabot>     Probable cause: `curry' is applied to too few arguments
13:45:31 <Jesin> :t join id
13:45:35 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
13:45:39 <lambdabot>     Probable cause: `id' is applied to too few arguments
13:45:43 <lambdabot>     In the first argument of `join', namely `id'
13:45:44 <Jesin> :t join ($)
13:45:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
13:45:48 <Jesin> =/
13:45:49 <lambdabot>       Expected type: (a -> a1) -> (a -> a1) -> a1
13:45:51 <Jesin> hmm.
13:45:53 <lambdabot>       Inferred type: (a -> a1) -> a -> a1
13:46:20 <halcyon10> dcoutts: gcc is working, but ld is not
13:46:49 <dcoutts> halcyon10: and what does that mean exactly, that ld is not working?
13:47:47 <halcyon10> dcoutts: sorry for being unclear, i think it's not installed, at least the command doesn't work in bash
13:48:14 <dcoutts> halcyon10: did you install Xcode?
13:48:24 * dcoutts wonders how gcc works without ld
13:50:31 <Jesin> @undefine
13:50:58 <halcyon10> dcoutts: oh, it just dawned on me. I had Xcode installed on my old system, but recently switched to another computer and installed from a timemachine backup. Perhaps i have to reinstall the developer tools...
13:51:05 <Jesin> @let cFind p = h : cFind (p . (h :)) where h = p $ True : cFind (p . (True :))
13:51:06 <monochrom> oh hehe
13:51:06 <lambdabot>  Defined.
13:51:29 <hpc> :t cFind
13:51:30 <lambdabot> ([Bool] -> Bool) -> [Bool]
13:51:39 <hpc> cfind (const True)
13:51:41 <shachaf> dcoutts: Maybe it uses a binary in /usr/lib/gcc?
13:51:45 <hpc> > cfind (const True)
13:51:45 <lambdabot>   Not in scope: `cfind'
13:51:46 <Jesin> :t cFind
13:51:47 <lambdabot> ([Bool] -> Bool) -> [Bool]
13:51:52 <hpc> > cFind (const True)
13:51:53 <Jesin> you have to capitalize the f
13:51:54 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
13:51:55 <Jesin> :p
13:52:00 <hpc> > cFind (const False)
13:52:01 <dcoutts> halcyon10: ah ok, sounds plausible. Normally one doesn't find gcc without ld and ar
13:52:01 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
13:52:04 <hpc> fun
13:52:13 <Jesin> no, there's more fun coming up
13:52:26 <hpc> > cFind any
13:52:27 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
13:52:27 <lambdabot>         against inferred typ...
13:52:35 <dcoutts> shachaf: sure it's possible, but the usual setup puts ld and ar on the path with gcc, since most makefiles need all three
13:52:39 <hpc> :t any
13:52:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:52:43 <dafis> > cFind or
13:52:44 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
13:52:49 <dafis> > cFind and
13:52:53 <lambdabot>   mueval-core: Time limit exceeded
13:52:58 <Jesin> anyway...
13:53:05 <hpc> > cFind xor
13:53:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:53:06 <lambdabot>         against inferred type ...
13:53:06 <Jesin> :t fix cFind
13:53:06 <lambdabot>     Couldn't match expected type `[Bool] -> Bool'
13:53:07 <lambdabot>            against inferred type `[Bool]'
13:53:07 <lambdabot>     In the first argument of `fix', namely `cFind'
13:53:09 <Jesin> hmm
13:53:25 <hpc> :t or
13:53:26 <lambdabot> [Bool] -> Bool
13:53:37 <hpc> :t xor
13:53:38 <lambdabot> forall a. (Bits a) => a -> a -> a
13:53:39 <dafis> > fix (return . cFind)
13:53:40 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:53:40 <lambdabot>         against inferred type ...
13:53:45 <Jesin> @undefine
13:54:02 <dafis> > fix ((return .) . cFind)
13:54:03 <lambdabot>   Not in scope: `cFind'
13:54:09 <Jesin> I prefer lowercase
13:54:13 <Jesin> because there are more functions coming
13:54:16 <Jesin> @let cfind p = h : cfind (p . (h :)) where h = p $ True : cfind (p . (True :))
13:54:17 <lambdabot>  Defined.
13:54:22 <dafis> > fix ((return .) . cfind)
13:54:23 <lambdabot>   Couldn't match expected type `m a'
13:54:23 <lambdabot>         against inferred type `GHC.Bool....
13:54:28 <aristid> > fix $ return .: cfind
13:54:29 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool] -> GHC.Bool.Bool'
13:54:29 <lambdabot>         aga...
13:54:51 <aristid> :t cfind
13:54:52 <lambdabot> ([Bool] -> Bool) -> [Bool]
13:54:58 <aristid> :t return .: cfind
13:54:59 <lambdabot> forall (m :: * -> *). (Monad m) => ([Bool] -> Bool) -> [m Bool]
13:55:17 <aristid> :t flip . (return .: cfind)
13:55:17 <lambdabot> forall a. ([Bool] -> Bool) -> a -> [Bool]
13:55:34 <Jesin> @let cforsome p = p (cfind p)
13:55:35 <lambdabot>  Defined.
13:55:43 <aristid> :t cforsome
13:55:44 <lambdabot> ([Bool] -> Bool) -> Bool
13:55:52 <aristid> :t fix
13:55:52 <lambdabot> forall a. (a -> a) -> a
13:56:02 <opqdonut> oh the spam
13:56:10 * hackagebot comonads-fd 1.4.0 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.4.0 (EdwardKmett)
13:56:35 <Jesin> @let cforall p = not (cfind (not . p))
13:56:35 <lambdabot>  <local>:3:17:
13:56:36 <lambdabot>      Couldn't match expected type `Bool' against inferred type...
13:56:41 <edwardk> @tell roconnor comonad-transformers and comonads-fd have been patched
13:56:41 <lambdabot> Consider it noted.
13:57:03 <Jesin> @let cforall p = not $ p $ cfind $ not . p
13:57:04 <lambdabot>  Defined.
13:57:30 <Jesin> wait
13:57:32 <Jesin> no
13:57:40 <Jesin> @let cforall p = p $ cfind $ not . p
13:57:41 <lambdabot>  <local>:3:0:
13:57:41 <lambdabot>      Warning: Pattern match(es) are overlapped
13:57:41 <lambdabot>               In...
13:57:44 <Jesin> dangit
13:57:49 <Jesin> have to start over
13:57:57 <Jesin> I'll do this in a text file and then paste
13:58:12 * hackagebot recursion-schemes 0.4.0.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.4.0.2 (EdwardKmett)
13:58:25 <ski> Jesin : is that related to Martin Escards
13:58:26 <ski> @where impossible
13:58:27 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
13:58:28 <ski> ?
13:58:34 <Jesin> yup
13:58:35 <Jesin> :p
13:58:40 <Jesin> @undefine
13:59:04 <ski> @where topology
13:59:04 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
13:59:05 <lambdabot> dvi|ps)> by Martn Escard
14:00:41 <Jesin> @let cfind p = h : cfind (p . (h :)) where h = p $ True : cfind (p . (True :))
14:00:42 <lambdabot>  Defined.
14:00:46 <Jesin> @let cforsome p = p (cfind p)
14:00:47 <lambdabot>  Defined.
14:00:52 <Jesin> @let cforall p = p (cfind (not . p))
14:00:52 <lambdabot>  Defined.
14:01:00 <Jesin> @let csearch p = if p xs then Just xs else Nothing where xs = cfind p
14:01:01 <lambdabot>  Defined.
14:01:06 <Jesin> :t csearch
14:01:06 <lambdabot> ([Bool] -> Bool) -> Maybe [Bool]
14:02:18 <hpc> eek
14:02:56 <Jesin> :t let cequal f g = cforall (\x -> f x == g x) in cequal
14:02:57 <lambdabot> forall a. (Eq a) => ([Bool] -> a) -> ([Bool] -> a) -> Bool
14:02:59 <Jesin> yay
14:03:04 <Jesin> @let cequal f g = cforall (\x -> f x == g x)
14:03:05 <lambdabot>  Defined.
14:03:49 <ski> > cequal (const False) (\(_:_) -> False)
14:03:50 <lambdabot>   True
14:03:56 <Jesin> now we can test any computable functions on the space of infinite bitstrings for equality
14:04:03 <Jesin> :p
14:04:15 * hackagebot adjunctions 0.5.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.5.2 (EdwardKmett)
14:04:17 <aristid> @let cfan = "Jesin"
14:04:18 <lambdabot>  Defined.
14:05:26 <ski> > cforall $ \xs -> cforsome $ \ys -> cequal xs (map not ys)
14:05:27 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool] -> a'
14:05:27 <lambdabot>         against inferre...
14:05:46 <Jesin> :t (!!)
14:05:47 <lambdabot> forall a. [a] -> Int -> a
14:05:49 <Jesin> ...
14:06:17 <ski> oh .. this doesn't work, of course
14:06:52 <Jesin> the guy generalizes (.) = fmap and flip f x = fmap ($ x) f
14:07:01 <Jesin> but he doesn't even generalize (!!) = genericIndex
14:07:04 <faluf> Anyone have any advice on http://hpaste.org/43530/atree_annotation. My attempt at an improvement on http://hpaste.org/43526/atree. Thanks
14:07:18 <Jesin> :t genericIndex
14:07:19 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
14:07:34 <pozic> faluf: there are actual dimensional numbers.
14:07:45 <pozic> faluf: there is a dimensional package on Hackage.
14:07:52 <pozic> faluf: otherwise I didn't look.
14:08:16 <faluf> pozic: thanks for the glance, appreciate it
14:08:22 <ski> > cforall $ \xs -> cforsome $ \ys -> cequal (== xs) (== map not ys)  -- and this doesn't work either, since `(==)' is not total in infinite lists
14:08:26 <lambdabot>   mueval-core: Time limit exceeded
14:08:44 <ski> Jesin : well, suggest it to Cale :)
14:09:17 <pozic> faluf: also no real program still contains type declarations after some time of development.
14:09:39 <dafis> pozic: ??
14:10:06 <Jesin> @tell Cale while you're generalizing (.) = fmap and flip f x = fmap ($ x) f, why not make (!!) = genericIndex, take = genericTake etc while you're at it?
14:10:06 <lambdabot> Consider it noted.
14:10:11 <dafis> type declarations as in "type Foo = Bar" or type signatures?
14:10:12 <pozic> dafis: That is my experience. 
14:10:19 <pozic> dafis: the former.
14:10:33 <dafis> pozic: Ah, okay, that, yes
14:10:38 <faluf> pozic: why is that?
14:10:48 <Jesin> :t fromEnum
14:10:49 <lambdabot> forall a. (Enum a) => a -> Int
14:10:57 <pozic> faluf: it turns out that if something is worth giving a name, you often want to do more with it later on.
14:11:02 <ski> faluf : 404
14:11:21 <dafis> faluf: and prevent any mixup with similar but different stuff
14:11:22 <pozic> faluf: so, first you switch to a newtype and then later on you might even switch to a data declaration. 
14:12:03 <pozic> That is just how programs evolve. Knowing that you can just as well skip the illusion that you will keep a type forever around.
14:12:24 <ski> @src String
14:12:25 <lambdabot> type String = [Char]
14:12:34 <ski> @src ShowS
14:12:34 <lambdabot> type ShowS = String -> String
14:12:38 <ski> @src ReadS
14:12:38 <lambdabot> Source not found. I feel much better now.
14:12:48 <ski>   type ReadS a = String -> [(a,String)]
14:12:51 <pozic> ski: exceptions to the rule.
14:13:00 <ski> counter-examples :)
14:13:04 <pozic> ski: and maybe those choices are not even good. 
14:13:23 <pozic> ski: strings are lists have causes lots of issues.
14:13:29 <ski> indeed
14:13:29 <pozic> caused*
14:13:30 <maurer_2> pozic: I frequently have "type Foo = State FooState" when using the state monad for a complex function.
14:13:38 <Jesin> :t fromBool
14:13:39 <lambdabot> Not in scope: `fromBool'
14:13:56 <faluf> pozic: why newtype first? doesn't that preclude the possibility of using prelude functions that operate on similar structures without first "unboxing" them? my terminology may be a bit off
14:14:05 <Jesin> @let fromBool x = if x then 1 else 0
14:14:06 <lambdabot>  Defined.
14:14:07 <Jesin> :t fromBool
14:14:08 <lambdabot> forall t. (Num t) => Bool -> t
14:14:08 <pozic> faluf: you can derive all that stuff.
14:14:43 <pozic> faluf: anyway, maybe you should just experience it yourself.
14:15:58 <ski> faluf : i think something like Hugs' "Restricted type synonyms" <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> would be useful ..
14:16:19 <faluf> pozic: Well, there is something to be said for that. There is also something to be said for best practices and collective wisdom. Was just trying to figure out if I was headed down a bad path.
14:16:49 <edwardk> ski: thats rather convenient
14:16:52 <romanandreg> guys is there a way to just declare a type
14:16:58 <romanandreg> to avoid circular dependecy
14:17:02 <romanandreg> dependency*
14:17:04 <pumpkin> faluf: newtype doesn't need unboxing
14:17:17 <ski> edwardk : i wish GHC supported it ..
14:17:18 <pozic> romanandreg: let me guess: you want mutual recursive modules?
14:17:18 <pumpkin> faluf: meaning the constructor that you have to stick onto it and take off is only present in your code
14:17:21 <romanandreg> declare it but not define it
14:17:21 <hpc> romanandreg: it's ugly; rephrase your modules
14:17:23 <pumpkin> the generated code doesn't contain any
14:17:23 <edwardk> ski: but it suffers from the disease that you have to think of all uses of a type for yourself, so no one can come along and extend your data type
14:17:37 <romanandreg> the thing is that I have a Field module
14:17:41 <romanandreg> and a FieldMap module
14:17:44 <Jesin> @src and
14:17:44 <lambdabot> and   =  foldr (&&) True
14:17:46 <Jesin> @src or
14:17:46 <lambdabot> or    =  foldr (||) False
14:17:48 <ski> edwardk : either in that form, or at least in the form of exporting a `type T ... = ...' definition abstractly from a module
14:17:49 <romanandreg> FieldMap is an abstract Map of Fields
14:17:55 <pozic> hpc: I don't think there are always nice solutions. 
14:18:07 <romanandreg> but Fields can have subfields, and this subfields is just another FieldMAp
14:18:14 <romanandreg> so I'm getting this ugly circular dependency
14:18:16 <hpc> pozic: it can't be much uglier than mutual module recursion
14:18:22 <romanandreg> they are in different modules
14:18:27 <romanandreg> because I have functions for each of them
14:18:31 <ski> edwardk : yes, it's an alternative to `type' and `newtype', not to `data'
14:18:33 <romanandreg> and I want to use them qualified
14:18:36 <romanandreg> so the code is more clear
14:18:46 <Jesin> > cequals (not . and . take 215) (or . take 215 . map not)
14:18:46 <hpc> romanandreg: make Fields.Types
14:18:46 <lambdabot>   Not in scope: `cequals'
14:18:50 <Jesin> > cequal (not . and . take 215) (or . take 215 . map not)
14:18:52 <lambdabot>   True
14:19:00 <hpc> romanandreg: then write functions in the other modules, and both import the Types module
14:19:08 <faluf> pumpkin: I meant that if you newtype a String for example, you have to turn it back into a string before you can use it in functions taking Strings. Is that correct?
14:19:08 <romanandreg> ok
14:19:20 <hpc> that's the popular solution to that particular problem
14:19:28 <pumpkin> faluf: in your code, yes, it's annoying. But at runtime there's no "turning back into"
14:19:29 <Jesin> > cequal (not . foldr (/=) . take 215) (foldr (/=) . take 215 . map not)
14:19:30 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:19:30 <lambdabot>         against inferred type ...
14:19:35 <hpc> (at least, if hackage is any indicator)
14:19:46 <Jesin> > cequal (not . foldr (/=) False . take 215) (foldr (/=) False . take 215 . map not)
14:19:46 <pumpkin> faluf: the whole point of a newtype is that it has the same runtime representation as the underlying type
14:19:49 <lambdabot>   mueval-core: Time limit exceeded
14:19:55 <pumpkin> faluf: so there's no actual wrapping/unrapping
14:19:58 <Jesin> > cequal (not . foldr (/=) False . take 215) (foldr (/=) True . take 215)
14:20:02 <lambdabot>   mueval-core: Time limit exceeded
14:20:11 <pumpkin> Jesin: pm?
14:20:15 <Jesin> sorry
14:20:18 <Jesin> right, ok
14:20:20 <Jesin> :p
14:20:24 <faluf> pumpkin: that is what I meant by "unboxing" earlier; that you have to have a function NewTypeString -> String
14:20:47 <pumpkin> faluf: yeah, but that function has no cost, except syntactically when you're writing and reading the code
14:20:50 <romanandreg> hpc: thanks
14:20:52 <romanandreg> I will do that
14:21:04 <ski> romanandreg : i know OCaml (and probably SML/NJ) supports mutually recursively constructing `Field' and `FieldMap' modules, using an (abstract) `Map' functor (i.e. function from module to module)
14:21:09 <faluf> pumpkin: ah, ok
14:22:34 <ski> faluf : did you check out the link i provided ?
14:23:04 <faluf> pumpkin: and type has that benefit as well, but without the added benefit of extra type checking? and data has more overhead?
14:23:20 <faluf> ski: reading it now
14:24:03 <pumpkin> faluf: yeah, type is literally just a synonym. Newtype gives you a "temporary type" that exists only during typechecking
14:24:49 <ski> faluf : yes (to the questions to pumpkin)
14:25:15 <djahandarie> Newtype also gets rid of an extra bottom
14:25:19 * ski wants to be able to declare temporary types inside `where'-clauses ..
14:25:46 <ski> (djahandarie : not in comparision to `type' ..)
14:25:54 <djahandarie> Right, in comparision to data
14:26:05 <halcyon10> dcoutts: reinstalling the developer tools fixed the problem, ld and ar working again
14:26:13 <dcoutts> great
14:26:39 <faluf> Also, I'm not sure the conversion to record syntax was worth it...seems sort of clumsy. Is that just inexperience talking?
14:27:25 <jmcarthur> record syntax can be clumsy sometimes, but once you get used to working with it it rarely is
14:27:34 <dankna> record syntax is indeed kinda clumsy at first, but it's the best we've got.
14:27:41 <maurer_2> faluf: Record syntax is kind of clumsy, and there are lots of proposals to change it. However, if you have more than a few entries, using record syntax will help you when you have to update your program, as you will not have to change every single time that you access that datatype just to add or remove a field.
14:28:06 <Jesin> record syntax also works pretty well with newtype, imo
14:28:11 <dankna> to smooth things over, be aware of both the Record { whatever = whatever } pattern-binding approach to getting fields, and the whatever = whatever Record accessor one.
14:29:03 <ski> faluf : record syntax is ugly, and could be improved (especially nested record update is irritating)
14:29:05 <Jesin> sometimes I dislike how "deriving Show" works out for that
14:29:08 <Jesin> :p
14:29:23 <ski> write a `Show' instance, manually :)
14:29:27 <Jesin> yup
14:29:49 <maurer_2> Also check out Data.Accessor
14:29:52 <ski> (defining `showsPrec', correctly using `showParen', of course)
14:29:57 <ski> aye
14:30:04 <maurer_2> It's not necessary for small records, but if you get too many levels of nesting, it can help
14:30:43 <faluf> I appreciate the advice. Guess I'll stop worrying about the structure and get to writing something useful with what I've got. Then I can see how it needs to change.
14:30:48 <ski> it would still be helpful with better pointful support for record update, imo .. in addition to pointless support such as `Data.Accessor'
14:31:33 <faluf> Should I take it as a big loss to be abandoning Data.Tree?
14:32:12 <ski> abandon it, why ?
14:32:18 <ski> because of ugly `Show' instance ?
14:32:47 <ski> > Node 0 [Node 1 [Node 3 []],Node 2 []]
14:32:47 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {r...
14:33:09 <faluf> ski: because I require leaves and internal nodes to store different info
14:33:19 <ski> oh
14:33:31 <ski> then i'd probably just roll my own
14:33:34 <faluf> I suppose I could figure out a way to enfore it when the tree is constructed
14:33:36 * hpc didn't even realize there was a Data.Tree
14:33:41 * hpc has only ever rolled his own
14:33:44 <ski> i'm not aware of `Data.Tree' being used *that* much
14:34:03 <faluf> but might better to just roll my own for the guarantee and the experience
14:34:14 <ski> (but it *could* be good with a variant of it, with different leaf and node element types, in the library somewhere)
14:34:42 * ski has mostly used `Data.Tree' in lambdabot, to try things out ;)
14:35:08 <hpc> i don't think it would be possible to make a sufficiently flexible tree data type
14:35:15 <hpc> for general use
14:35:33 <hpc> there's so many different situations in which different trees are needed, more so than lists
14:35:45 <ski>   data Tree f node leaf = Leaf leaf | Node node (f (Tree f node leaf))  -- ?
14:35:49 <hpc> (list, array, bytestring...)
14:35:59 <hpc> ski: that can't be empty
14:36:06 <dankna> and in today's programming languages, using an existing type gets you nothing much anyway
14:36:07 <ski> right, because it's a monad
14:36:09 <faluf> ski: I could, of course, write something MyTree -> (Tree BothNodeTypes) if I needed it to be in Data.Tree
14:36:13 <adu> i need help, is there a way to do f >>= g >>= g >>= g >>= g >>= g... as long as there is no failure?
14:36:29 <hpc> :t repeat
14:36:30 <lambdabot> forall a. a -> [a]
14:36:39 <dankna> in my hypothetical dream language it would get you a library of "metaphors", which would be a new language construct allowing you to use different APIs for the same underlying objects depending on what perspective you were viewing them from
14:36:40 <adu> hpc: ah thanks
14:36:45 <hpc> adu: no, that's not it
14:36:46 <ski>   instance Functor f => Monad (Tree f node)
14:36:52 <dankna> but I can't figure out the exact details of how that would work, at least not yet
14:36:54 <hpc> well, it could be part of it
14:36:55 <faluf> thanks everyone
14:36:59 <pumpkin> dankna: conor's ala combinator?
14:37:09 <dankna> pumpkin: sounds relevant, where can I read about it?
14:37:17 <pumpkin> @hackage newtypes
14:37:18 <lambdabot> http://hackage.haskell.org/package/newtypes
14:37:27 <dankna> 404
14:37:27 <pumpkin> @hackage newtype
14:37:27 <lambdabot> http://hackage.haskell.org/package/newtype
14:37:34 <dankna> hmm interesting
14:38:01 <adu> hpc: basically, something like ... (try f >>= g >>= g) <|> (try f >>= g) <|> f
14:38:10 <ski> @type fix . (>=>)  -- adu ?
14:38:10 <dankna> ah, a nice simple API to understand :)
14:38:11 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
14:38:25 <jkr> if I'm pattern-matching on a type, and it should do the same thing for multiple constructors, how can I indicate that without cutting and pasting?
14:38:44 <ski> adu : a sensible name for this could be `subst0' or something like that
14:38:46 <dankna> well, this is relevant, but I'm thinking of something a bit more involved.  for example, you could view a tree as a graph just by using the appropriate terminology for it.
14:38:51 <hpc> ski: i think you are composing in the wrong direction, but yes
14:38:52 <jkr> e.g. f (A x) and f (B x) should do the same thing with x, but not f (C x)
14:38:59 <hpc> er, no
14:39:01 <hpc> im dumb
14:39:02 <ski> adu : reserving `subst' for `Monad m => (a -> m a) -> (m a -> m b)'
14:39:08 <adu> :t (>=>)
14:39:09 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:39:15 <ski> @type fix . (<=<)
14:39:16 <lambdabot> forall (m :: * -> *) c a. (Monad m) => (c -> m c) -> a -> m c
14:39:29 <ski> hpc : no, the other direction is the useless one
14:39:41 <dankna> and for anything geometric, you could, say, store a rectangle as corner+size but refer to it as corner+corner for both reading and writing
14:39:46 <ski> > (fix . (>=>)) (const Nothing) ()
14:39:48 <lambdabot>   Nothing
14:39:52 <ski> > (fix . (<=<)) (const Nothing) ()
14:39:54 <lambdabot>   *Exception: stack overflow
14:40:00 <ski> hpc : ^ see ?
14:40:08 <hpc> ski: shush
14:40:10 <hpc> :D
14:40:25 <adu> lol
14:40:26 <dankna> the latter can be done with today's languages and a sufficiently detailed implementation, but the idea would be to make that implementation much easier to write
14:40:36 <dankna> possibly with some sort of views or something
14:41:07 <ski> jkr : unfortunately Haskell doesn't have disjunctive patterns .. if it had, you should be able to write something like `f (A x | B x) = ..x..'
14:41:20 <dankna> another part of the idea is inferring that if I ask for "the left side" and I'm in the context of a rectangle, the object of that is "the rectangle", without having to type it out
14:41:30 <ski> (jkr : OCaml and SML/NJ has them, i think)
14:41:34 <dankna> I'm babbling, and getting no responses, so I think I'll stop :)
14:42:12 <ski> (jkr : see the OCaml code at <http://rosettacode.org/wiki/Pattern_matching> for an example of disjunctive patterns)
14:42:44 <ski> jkr : the best you can do in Haskell is to factor out the common code ..
14:45:14 <ski> adu : the reason for naming it `subst :: Monad m => (var -> m var) -> (m var -> m a)' is that if `m var' is an expression tree, with `var' its type of variables, then using `subst' will (recursively) apply the given `var -> m var' substitution on the `m var' argument
14:46:19 <saml> is there thread safe file io library?
14:46:22 <maurer_2> jkr: If you're doing it a lot, you could always use a view pattern to project those two onto the same constructor in a particular view.
14:46:50 <jkr> ski, maurer_2 : oh well. Thanks, guys
14:47:10 <ski> dankna : i think it could be useful to export a type *as-if* it had a given `data' definition in terms of constructors, even if the representation is actually different .. so you could have multiple such views of a type, as long as you define how to resolve pattern-matches against the virtual constructors (and ensure they are injective and disjoint, i think)
14:47:19 <adu> hmm that didn't quite work
14:47:25 <maurer_2> jkr: tbh, I usually just end up with something like
14:47:25 <maurer_2> f' x = blah
14:47:25 <maurer_2> f (A x) = f' x..
14:47:42 <maurer_2> Not that it's a particularly good solution, but it works and doesn't mess up maintainability much.
14:47:43 <ski> (maurer_2 : that's factoring out the common code, right :)
14:47:47 <maurer_2> ski: Yeah.
14:47:50 <dankna> ski: yes - yes, that's definitely part of it.
14:48:13 <halcyon10> is there a way to import from two packages from hackage whose module-names collide?
14:48:39 <ski> (.. well, injective, disjoint, and exhaustive .. maybe also fixpoint-free ?)
14:48:44 <dankna> halcyon10: there is a syntax for that, I think, but it's nonstandard and also I don't remember it.  what packages are they?
14:48:48 <hpc> halcyon10: "import blah from foo" iirc
14:48:56 <hpc> don't remember if it needs extensions or not
14:48:57 <dankna> (ski: your terminology has lost me :) )
14:49:31 <halcyon10> dankna: i want to use AC-Vector and vector in the same program
14:49:33 <ski> dankna : injectivity ensures that if we try to match a value with `C x y', then this can only match in at most one way
14:49:44 <dankna> yes you would absolutely want multiple such views
14:49:45 <adu> so if g :: a -> m a and f :: m a i should be calling it f >>= (fix . (>=>)) g?
14:49:48 <ski> dankna : disjointness ensures that no value can match both `C x y' and `D z'
14:49:55 <halcyon10> hpc: thanks, i'll try to look that up
14:50:12 <adu> maybe I should just write my own
14:50:24 <dankna> ski: hmm okay.  yes.  what about the rectangle example, where corner1 is common to two different views?  that seems to be non-disjoint, although it's an illusion because it means the same thing in both cases.
14:50:40 <ski> dankna : fixpoint-freeness would ensure that `z' can't be the same as `D z' .. i suppose with cyclic data in Haskell, this is false .. and i don't really see where having this would be useful (operationally)
14:51:00 <dankna> ski: so perhaps there needs to be a refinement that allows disjointness when the affected fields are related by the identity transformation
14:51:12 <ski> dankna : exhaustiveness means that if `C' and `D' is the only constructors, then every value must match one of `C x y' and `D z'
14:51:26 <dankna> ski: hmmm okay, yeah, these all seem like reasonable restrictions and thanks for explaining them
14:52:24 <dankna> now I need to make a clipfile for this conversation :)
14:52:30 <ski> adu : yes, or `subst g f', if you have defined `subst' in the obvious way
14:52:45 <adu> :t subst
14:52:46 <lambdabot> forall a. (Num a) => String -> Sym a -> Sym a -> Sym a
14:52:49 <ski> not that one
14:53:08 <adu> ski: can you help me discover the "obvious way"?
14:54:20 <adu> subst = (>>= (fix . (>=>)))?
14:54:31 <ski> @let mySubst0 :: Monad m => (var -> m var) -> (var -> m a); mySubst0 f x = fix (f x >>=)
14:54:31 <lambdabot>  <local>:8:75:
14:54:31 <lambdabot>      Occurs check: cannot construct the infinite type: b = m b...
14:54:38 <ski> um
14:54:42 <pumpkin> subst :: a == b -> f a -> f b?
14:54:53 <pumpkin> oh
14:56:02 <adu> :t \f g -> fix (>>= g) f
14:56:03 <lambdabot> forall t b. (Monad ((->) t)) => t -> (b -> t -> b) -> b
14:56:12 <ski> @let mySubst0 :: Monad m => (var -> m var) -> (var -> m a); mySubst0 env = fix (env >=>)
14:56:13 <lambdabot>  Defined.
14:57:30 <halcyon10> dankna, hpc: found it, with -XPackageImports you can import with e.g. "import "network" Network.Socket"
14:57:40 <hpc> halcyon10: nice
14:58:00 <halcyon10> thanks again for pointing me in the right direction
14:58:00 <adu> :t mySubst0
14:58:01 <lambdabot> forall var (m :: * -> *) a. (Monad m) => (var -> m var) -> var -> m a
14:58:31 <dankna> ah!  yeah, that looks familiar.  glad you figured it out, halcyon10.
14:58:33 <ski> @let mySubst :: Monad m => (var -> m var) -> (m var -> m a); mySubst env mv = mySubst env . env =<< mv
14:58:34 <lambdabot>  Defined.
14:58:52 <adu> :t mySubst
14:58:53 <lambdabot> forall var (m :: * -> *) a. (Monad m) => (var -> m var) -> m var -> m a
14:58:59 <adu> that's better
14:59:20 <ski> adu : you can probably play around with those definitions more, if you like .. but that should work, i think
15:00:01 <adu> ok, I'll try it
15:00:09 <augur> ok, im building a theorem prover, and i want to know peoples opinions: should i a) make proof rules into functions, b) should i incorporate an implicit types (if so how power) instead of an explicit syntactic type system like in Martin-Loef type theory?
15:01:10 <ski> pumpkin : monadic substitition (for expression/tree monads)
15:01:23 <pumpkin> yeah, I was just being deliberately obtuse
15:01:28 <adu> ski: why isn't it -> m var at the end?
15:01:43 <pumpkin> adu: the a isn't constrained
15:01:53 <pumpkin> it could be, since that's less general
15:02:33 <ski> adu : because if you're recursively substituting away *all* the "variable names" (strings or numbers or whatever), then in the final tree/expression, there'll be no variables at all left .. so it becomes polymorphic in the variable type (just like how the empty list, which has no elements, is polymorphic in the element type)
15:02:52 <ski> an alternative typing would be
15:03:00 <ski>   mySubst :: Monad m => (var -> m var) -> (m var -> m Void)
15:03:05 <ski> (where `Void' is an empty type)
15:03:17 <pumpkin> you could easily write its type as (Monad m) => (var -> m var) -> m var -> m (Either Int (a -> b))
15:03:41 <ski> but the polymorphic version is probably more useful in practice (since then you don't have to `liftM void', to change the variable type to whatever you want)
15:04:12 <ski> pumpkin : yeah .. can you rederive the original one from that, then ?
15:04:27 <ski> @type forever
15:04:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:04:42 <ski>   forever :: Monad m => m () -> m Void
15:04:51 <ski> is an alternative typing for this (equially powerful)
15:05:02 <ski> but the polymorphic one is probably better in practice
15:06:38 <ski> (maybe `Monad m => m (exists a. a) -> m (forall b. b)' would be even better .. if it could be made to work properly (i.e. `forall' and `exists' interacting properly with functors `m')
15:08:12 <adu> hmm I'm still recieving the failure, even with fix
15:08:31 <ski> <adu> i need help, is there a way to do f >>= g >>= g >>= g >>= g >>= g... as long as there is no failure?
15:08:34 <ski> <adu> hpc: basically, something like ... (try f >>= g >>= g) <|> (try f >>= g) <|> f
15:08:38 <ski> hm (thinking more on this)
15:09:17 <ski> this `subst' operation is suitable for some kinds of monads .. i'm not sure whether it is suitable for whatever (parsing ?) monad you're using
15:09:18 <adu> i'm not looking for equality, like fix is generally used for
15:09:45 <adu> I'm looking to get the result of g one try before the failure
15:09:54 <ski> (huh, who mentioned equality ?)
15:10:08 <adu> i did, probably because I'm a dumbo
15:11:23 <ski> hm, wouldn't you need to wrap whole disjuncts in `try' ?
15:11:31 <adu> perhaps there is a better way to do this
15:11:41 * ski tries to recall exactly how `try' worked ..
15:11:52 <adu> oh (try (f >>= g >>= g)) yes
15:13:32 * ski suspects adu is parsing infix(l ?) operators ..
15:13:48 <adu> yes
15:14:45 <adu> ski: and I'm probably going about it all wrong
15:15:10 <adu> ski: if you want specifics: http://golang.org/doc/go_spec.html#PrimaryExpr
15:17:07 <adu> also, if you're interested, this is what I had about a month ago: hackage.haskell.org/package/language-go
15:17:14 <ski> hm
15:17:24 <conal> mux: ping
15:17:34 <jmcarthur> oh speak of the devil
15:17:42 <pumpkin> glguy isn't the devil
15:17:48 <ski> it could be that `subst' would be appropriate in this situation, but i'm not sure
15:17:53 <conal> not the only devil, anyway.
15:18:10 <jmcarthur> conal: i was just about to try privmsging you to see if you feel like brainstorming with me about a precise model for light
15:18:23 <conal> jmcarthur: :) sounds fun.
15:18:33 <ski> adu : in any case, it would be good not to reparse from the beginning, until you hit the correct length (presumably you've already realized this)
15:18:39 <dankna> light?  as in a raytracer or something?
15:18:41 <conal> jmcarthur: maybe with luqui also
15:18:56 <jmcarthur> ah i guess i could pull it into email
15:19:02 <jmcarthur> luqui is not here at the moment :(
15:19:06 <ski> adu : what i have done in the past is explicit left-recursion-elimination
15:19:11 <jmcarthur> i'll do that
15:19:32 <conal> jmcarthur: cool.
15:21:30 <adu> ski: the ambiguities that I seem to be having the most trouble with are PrimaryExpr/Operand's id.id (for qualified identifiers), PrimaryExpr/Operand's id.id (for method expressions), PrimaryExpr/Conversion's id(...) for type-casts, PrimaryExpr/Selector's id.id for struct members, and PrimaryExpr/Call's id(...) for function calls
15:22:21 <jmcarthur> dankna: the intended renderer is currently a deferred shader
15:22:25 <adu> but that's a different issue than right-associative operators
15:22:40 <ski> adu : i.e. converting `expr = do {e <- atomicExpr; return e} <|> do {e <- expr; x <- more; return (combine e x)}' into `expr = do {e <- atomicExpr; continue e}; continue e = do {return e} <|> do {x <- more; continue (combine e x)}' (possibly flipping order of `(<|>)' arguments)
15:23:26 <mux> conal: pong
15:23:54 <conal> mux: another lovely operation: transpose :: IsNat n => Vec m (Vec n a) -> Vec n (Vec m a)
15:24:05 <mux> conal: yup I have it already
15:24:10 <dankna> jmcarthur: oh, so this is an OpenGL-related thing?  in what sense is the shader deferred?
15:24:10 <conal> mux: :)
15:24:48 <mux> conal: I also added type-safe indexing using BNat (which I called Fin, coincidentally; I had seen this name in an Agda tutorial)
15:24:58 <adu> ski: thanks :) that looks like it might work :)
15:25:31 <conal> mux: nice. i just added also, via a HasTrie instance.
15:25:43 <conal> mux: i might rename BNat to 'Fin'
15:25:44 <ski> adu : you might have to fiddle with `try' and `(<|>)' argument ordering, and maybe even factoring out common prefices .. but that method has worked for me in the past
15:26:41 <conal> mux: did you use foldr to define transpose?
15:26:52 <ski> adu : and btw, `atomicExpr' here is anything that doesn't have a left-associative operator as main operator
15:27:00 <adu> ok
15:27:10 <mux> conal: I used just "sequenceA"
15:27:17 <mux> as someone in here suggested
15:27:24 <ski> @type foldr (zipWith (:)) (repeat [])
15:27:25 <lambdabot> forall a. [[a]] -> [[a]]
15:27:27 <adu> ski: which in my case would be Operand|Conversion|BuiltinCall?
15:27:41 <conal> mux: ah. nice.
15:27:58 <ski> adu : i think so
15:28:06 <mux> I started doing it by hand afterwards, thinking I could get rid of the IsNat constraint, but I needed it anyway for the case where you have Vec n (Vec 0) -> Vec 0 (Vec n)
15:28:32 <ski> adu : often i've called the  continue  operation  return'  so that it looks like a variant of  return  :)
15:28:38 <Jesin> :t zipWith (:)
15:28:39 <lambdabot> forall a. [a] -> [[a]] -> [[a]]
15:28:41 <ski> but maybe `continue' is clearer anyway
15:28:49 <hpc> :t continue
15:28:50 <lambdabot> Not in scope: `continue'
15:28:54 <adu> ski: maybe in a private where clause...
15:28:59 <conal> mux: i had to fiddle to get ski's definition for lists. a couple of wrong tries that compiled. hard to imagine a wrong-but-compiling transpose for Vec
15:29:06 <ski> hpc : locally defined in my comment to `adu' above
15:29:16 <Jesin> foldr (zipWith (:)) (repeat []) ["this ","is ","a ","test"]
15:29:17 <hpc> ski: just making sure it didn't shadow anything
15:29:21 <Jesin> > foldr (zipWith (:)) (repeat []) ["this ","is ","a ","test"]
15:29:21 <lambdabot>   ["tiat","hs e"]
15:29:35 <ski> adu : uh, right .. i thought i put it inside `where' above, but apparently i forgot to
15:29:56 <mux> conal: yup, associated type synonyms make this harder than it should somehow :)
15:30:14 <ski> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
15:30:15 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
15:30:15 <Jesin> > foldr (zipWith (:)) (repeat []) ["abc","def"]
15:30:16 <lambdabot>   ["ad","be","cf"]
15:30:57 <ski> > foldr (liftM2 (:)) (return []) ["abc","def"]
15:30:58 <lambdabot>   ["ad","ae","af","bd","be","bf","cd","ce","cf"]
15:31:02 <Jesin> :t try
15:31:03 <lambdabot> Not in scope: `try'
15:31:08 <ski> @hoogle try
15:31:08 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
15:31:08 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
15:31:08 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
15:31:13 <ski> @hoogle+
15:31:13 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
15:31:13 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
15:31:13 <lambdabot> Text.ParserCombinators.Parsec.Prim try :: GenParser tok st a -> GenParser tok st a
15:31:22 <ski> the `Parsec' one
15:31:27 <conal> this whole bit with length-sized numbers, vectors, and trees was just an aside from deriving parallel algorithms. hard to stop fiddling with it now.
15:31:50 <mux> conal: I thought I might as well share the code somewhere: https://bitbucket.org/mumux/stuff/src/1e9537e03f08/Vector.hs -- feel free to take or suggest anything. it's very similar to yours anyway
15:32:09 <ski> conal : wrong, how ?
15:32:13 <ezyang> It reminds me of something Conor McBride did a while back, conal. 
15:32:18 <adu> ski: it WORKS! it just parsed "a(3)(3)(3)(3)"
15:32:28 <ski> adu : nice :)
15:32:52 <mux> conal: notice how unelegant init and last are; I couldn't get away with a simpler definition
15:32:55 <Jesin> :t fix . (>=>)
15:32:56 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
15:32:57 <conal> ski: i think i tried [] instead of repeat []. and i started with someone else's version that used [[]]
15:32:57 <andres_> hello everybody
15:32:59 <Jesin> :t (fix .)
15:33:00 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
15:33:08 <djahandarie> conal, have you considered trying to generalize this stuff to any recursive structure (presumably by defining it with Mu and a Functor base type)?
15:33:08 <Jesin> :t (fix Prelude..)
15:33:09 <lambdabot> forall a a1. (a1 -> a -> a) -> a1 -> a
15:33:21 <adu> ski: thank you so much
15:33:34 <andres_> someone could tell what kind of types there are (recursive types, polymorphic types, etc)?
15:33:48 <Jesin> :t flip . flip
15:33:48 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
15:33:52 <Jesin> :p
15:33:56 <Jesin> hmm.
15:34:09 <conal> djahandarie: i sure haven't. nice idea! apply to regular types, using a depth-limited variant of Mu.
15:34:18 <djahandarie> Exactly
15:34:21 <conal> cool!
15:35:10 <djahandarie> Now you can figure out how to do that because it was causing me too much trouble to try and do it in a comment :D
15:35:36 <conal> mux: did you need the @(_ :< _) in last & init ?
15:35:44 <mux> conal: yup
15:35:51 <ski> (adu : of course, if you want several different precedence levels, you'll have to do the same trick multiple times)
15:35:51 <ski> conal : oh .. that could explain it, yes
15:35:52 <ski> adu : anyway, if i remember, i'll try to ponder whether one could use `subst' successfully in situations like these ..
15:35:57 <conal> mux: wow.
15:36:37 <mux> conal: it seems that every transition of an associated type synonym needs to match one specific pattern for a function; and GHC doesn't seem to "generalize" or however you could call that
15:37:09 <mux> conal: it's like it forgot what I matched the line just before, making some others things impossible in this one pattern
15:37:17 <ski> (adu : i also suspect that one could use composable continuations usefully, to do this kind of parsing thing ..)
15:37:43 <conal> mux: hm! i'll try it to, and then maybe i'll understand what you mean.
15:38:00 <ski> mux : that sounds plausible
15:38:26 <ski> (maybe that's something one could suggest to the GHC folk to try to improve ?)
15:40:16 <ski> conal : "depth-limited variant of Mu" <- ohh, shiny :)
15:40:43 <conal> ski: yeah! djahandarie's idea. nice one.
15:41:11 <conal> oh, wait. hm. maybe it's what i'm calling f :^ n.
15:41:21 <conal> i think so.
15:41:51 <conal> in http://conal.net/blog/posts/a-trie-for-length-typed-vectors/
15:41:58 <mux> ah, from a related bug report: "I wish this was easier to fix. The difficulty is that the type inference engine (which has a sophisticated constraint solver) only sees one equation at a time, and hence can't check exhaustiveness). But the overlap checker (which sees all the equations at once) does not have a sophisticated solver."
15:42:04 <mux> from spj
15:42:42 <ski> i assume you mean `data MuN (f :: * -> *) (a :: *) :: * -> * where MuZero :: a -> MuN f a Zero; MuSucc :: MuN f a n -> MuN f a (Succ n)' ?
15:42:47 <adu> ski: the final code: http://codepad.org/aEhKrNBX
15:43:35 <conal> ski: that version is close to one of the two at http://conal.net/blog/posts/a-trie-for-length-typed-vectors/
15:43:40 <djahandarie> conal, seems like you are right
15:43:43 * ski looks at that
15:44:11 <conal> djahandarie: the connection with Mu hadn't occurred to me. neat.
15:44:35 <conal> mux: ah, sigh. bleeding edge of ghc.
15:44:47 <ski> conal : er, of course i meant s/MuN f a n/f (MuN f a n)/ ..
15:45:02 <conal> ski: i figured you did.
15:45:17 <andres_> anyone could help tell me the kinds of datatypes there are?
15:45:26 <sipa> *
15:45:37 <djahandarie> I wonder how various morphisms interact with MuN
15:45:40 <ski> so `Mu f a' is more or less `MuN f a omega', then ..
15:45:47 <djahandarie> This could be an interesting class of structures
15:45:52 <conal> ski: ooh, yeah.
15:46:10 <conal> ski: too bad we can't type that omega. at least i don't think we can.
15:46:21 <ski> m
15:46:23 * ski wants to have GADT `newtype's ..
15:46:44 <conal> though some type systems do check infinite types.
15:46:56 <kyagrd> ski, agree
15:46:58 <sipa> ski: does a newtype with a type constraint not do the same?
15:46:59 <mux> I want to see a new type system so good it'll get finished before it gets replaced by a new one :-)
15:47:00 <ezyang> ==ski 
15:47:07 <hpc> mux++
15:47:12 <ski> (where the result types of the constructors are all disjoint, and where you're only allowed to match if you can already figure out from the types which constructor is the correct one)
15:47:22 <conal> mux: how on earth did you come up with your @(_ :< _) work-around.
15:47:23 <conal> ?
15:47:29 <sipa> ski: oh i see
15:47:34 <ski> sipa : i want multiple constructors for the `newtype'
15:47:36 <mux> conal: I couldn't tell right now
15:47:42 <conal> hah
15:48:17 <djahandarie> type family / newtype instance?
15:48:22 <mux> maybe... it was this voice in my head
15:49:00 <Janno> yber fail
15:49:30 <ski> sipa : like `newtype Vector (a :: *) :: * -> * where Nil :: () -> Vector a Zero; Cons :: (a,Vector a n) -> Vector a (Succ n)', e.g.
15:49:47 <dolio> ski: There's no f for which MuN f a = Vec with the above definition.
15:49:55 <dolio> And Vec a omega /= List a.
15:50:00 <kyagrd> If you use impredicative encodings you can define those Mus as just type synomyms
15:50:17 <dolio> Unless I'm misinterpreting what the n is.
15:50:23 <ski> hm .. though thinking on this, maybe this is not so dissimilar to `type familiy Vector (a :: *) :: * -> *; type instance Vector a Zero = (); type instance Vector a (Succ n) = (a,Vector a n)' (or with `data' maybe), except that this is open, not closed
15:50:24 <kyagrd> just have to turn on ImpredicativeTypes and RankNTypes
15:50:46 <kyagrd> then the problem is it is virtually impossible to define class instances :)
15:51:17 <djahandarie> ski, which is why you use newtype instance :)
15:51:24 <ski> dolio : hm .. i wasn't thinking about connecting this `MuN' to `Vec' at all (maybe conal was ?)
15:51:31 <ski> djahandarie : but then it would still be open :)
15:51:55 <kyagrd> One can use plain Mu with the GADT base functor like object
15:52:05 <kyagrd> another way to go
15:52:34 <ski> yeah, but the point was to avoid the tags which tell which alternative it is
15:52:38 <conal> ski: yeah. MuN (i call (:^)) makes it easy to define Trie (Vec n).
15:52:57 <ski> conal : that's cool ! :)
15:54:09 <djahandarie> ski, data family Vector n a; newtype instance Vector Z a = VectorZ a; newtype instance Vector (S n) a = VectorS (a, Vector n a) or so wouldn't fix it?
15:54:13 <conal> ski: yeah :)
15:54:22 <ski> another thing i'd like is records where some fields only exists if type indices are of particular shapes
15:54:33 <augur> ski: opinion needed
15:54:45 <augur> conal too if you're interested in giving opinions >.>
15:54:53 * ski . o O ( "opium-onion" )
15:55:09 <augur> uh, obviously
15:55:19 <augur> i dont know what other interpretation of opinion there is
15:55:29 * augur inhales deeply
15:55:45 <conal> augur: i don't care for opinions, but maybe i'll find an unpinion instead. 
15:56:00 <ski> sipa : btw, what did you mean more exactly by "does a newtype with a type constraint not do the same?" ?
15:56:54 <augur> ski: so im building a theorem prover, and im considering implementing proof rules as functions (e.g. a rule like   a b => [a,b] (make-pair)   might be equivalent to   make-pair = \a b -> [a,b])
15:56:54 --- mode: ChanServ set +o mauke
15:56:55 --- mode: mauke set +q $a:augur
15:57:08 <ski> another nice thing would be to be able to have multiple (coherent) definitions of `newtype's
15:57:10 * djahandarie thinks mauke's script is broken
15:57:21 <ski> like having both
15:57:44 <edwardk> preflex: xseen roconnor
15:57:44 <preflex>  roconnor was last seen on freenode/#haskell 2 hours, 56 minutes and 46 seconds ago, saying: edwardk: and put is the primitive operation for moving the location of the head in the store.
15:57:45 --- mode: mauke set -o mauke
15:58:00 <ski>   newtype Foo f a = C (f (Bar f a))
15:58:12 <edwardk> roconnor: ok, i now at least have a more principled way of reconciling the differences between the two puts =)
15:58:31 <ski>   newtype Baz a = B0 (Foo Identity a)
15:58:44 <djahandarie> Uh
15:58:48 <djahandarie> @where ops
15:58:48 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:58:50 <ski>   newtype Baz a = B1 (Bar Identity a)
15:58:55 <djahandarie> Some -q augur
15:59:06 <djahandarie> And tell mauke to fix his script
15:59:10 <hpc> +q is quiet?
15:59:12 <djahandarie> Yes
15:59:19 <aristid> edwardk: i don't like the name put for StoreT, because i confuse it with put for StateT
15:59:25 <ski> both definitions of `Baz' would have the same representation, so it shouldn't hurt to have both of them
15:59:36 <edwardk> aristid: as you should. its the same operation
15:59:38 <ski> (i can't come up with a better example atm, sorry)
16:00:00 <edwardk> aristid: one is a comonad, the other is a monad, but the operation set supported is the same
16:00:16 <edwardk> aristid: this is why there ask in EnvT, because thats Coreader
16:00:28 <edwardk> and it means the same thing once you abstract away kleisli vs. cokleisli
16:00:31 <ski> djahandarie : well, using that, it is possible to add more instances for `Vector', so it is open, rather than closed
16:00:35 --- mode: ChanServ set +o jmcarthur
16:00:45 <ski> djahandarie : apart from that, it's mostly fine
16:00:45 <aristid> edwardk: really you gotta explain that stuff in your blog
16:00:53 <edwardk> in the case of Reader vs. Coreader, a -> e -> b is isomorphic to (e, a) -> b 
16:00:55 --- mode: jmcarthur set -q $a:augur
16:01:04 <aristid> edwardk: you could explain it on IRC, but many more people would benefit from a blog post
16:01:05 --- mode: jmcarthur set -o jmcarthur
16:01:26 <edwardk> so ask :: a -> e -> e     — and ask :: (e, a) -> e are the same operation
16:01:35 <edwardk> aristid: in the case of reader i _did_ explain it in a blog post ;)
16:01:40 <augur> ski: so im building a theorem prover, and im considering implementing proof rules as functions (e.g. a rule like   a b => [a,b] (make-pair)   might be equivalent to   make-pair = \a b -> [a,b]) ;; im also considering adding types beyond just the existing possibility of explicit martin-loef style types ;; do you think this is a good way to go? or should i make typing an explicit part of the proof instead of an implicit one?
16:01:41 --- mode: ChanServ set +o mauke
16:01:41 --- mode: mauke set +q $a:augur
16:01:45 <djahandarie> -_-
16:01:51 <allbery_b> fight! fight!
16:01:56 <aristid> edwardk: oh? how old?
16:02:13 <alpounet> edwardk, that was on your way to kan extensions right ?
16:02:16 <ski> augur : i'm not sure what exactly these functions are ..
16:02:16 <edwardk> aristid: it was 'kan extensions ii' i think. there is a section on how all readers are the same
16:02:21 <alpounet> yeah
16:02:31 --- mode: mauke set -o mauke
16:02:41 <ski> augur : are they meta-level functions, which take object-level proofs (or formulae) and combine them in various ways ?
16:02:45 <mux> is there a pragma that allows disabling a specific warning for in some block of coe?
16:02:48 <mux> code
16:02:56 <edwardk> aristid: that gives the context to understand adjunctions, and once you understand adjunctions you can see the connection between my comonads and the corresponding monads
16:02:56 <jmcarthur> conal: you and luqui have mail
16:03:09 <jmcarthur> alpounet: dang, i should have included you
16:03:38 <alpounet> jmcarthur, no problem, you can still forward it to me
16:03:47 <alpounet> i believe you have my email address somewhere
16:03:54 <conal> jmcarthur: if you re-send and include alpounet, will be easier for luqui & me to also include
16:04:07 <jmcarthur> alpounet: i'll do what conal suggested ^^
16:04:18 <alpounet> yeah, that's better
16:04:19 <alpounet> thanks!
16:05:00 * fryguybob wonders if augur will be rescued again...
16:05:54 <djahandarie> Maybe /kick mauke until his script stops quieting people seemingly randomly too :P
16:06:10 <saikobee> Can anyone help me with this error? https://gist.github.com/807009
16:06:36 <saikobee> I previously had `x * k` working, but after refactoring some code it stopped working
16:06:58 * ski wasn't sure of the need to silence augur .. it seemed related to the general topic of type systems, and wasn't (afaict) very disrupting
16:07:18 <djahandarie> ski, it wasn't intentional, mauke added a script to stop spam and it's going haywire
16:07:33 <ski> .. oh
16:07:38 <ski> i thought it was the other way around
16:07:48 --- mode: ChanServ set +o jmcarthur
16:07:50 <ski> (the script removing the silencing, by itself)
16:08:15 <djahandarie> augur, just avoid saying that line again :P
16:09:33 --- mode: jmcarthur set +b *!*@p3m/member/mauke$#haskell-ops
16:09:39 --- kick: mauke was kicked by jmcarthur (mauke)
16:09:53 --- mode: jmcarthur set -q $a:augur
16:09:56 --- mode: jmcarthur set -o jmcarthur
16:10:04 <augur> poor mauke :(
16:10:05 <jmcarthur> felt weird kicking mauke
16:10:10 <ski> saikobee : `x * fromIntegral k'
16:10:13 <claney> hi, has something changed about code.haskell.org? darcs get http://code.haskell.org/binary-shared gives "not a repository"?
16:10:23 <augur> ski: did you see the pm?
16:10:29 <ski> oh
16:10:35 <saikobee> ski: I know I can do that manually, but it was automatic before
16:10:40 <saikobee> ski: I only had to type `x * k'
16:10:52 <augur> for anyone else who cares:   they're functions/proof rules that manipulate formulae, the use of which constitutes part of the construction of a proof ;; so like if make-pair is such a rule/function, and say left = \[a,b] -> a is another such rule, the proof a b => [a,b] => a might be seen as the sequence of rule applications [make-pair, left], or functionally, as the composition left . make-pair
16:11:47 <ski> > let x :: Rational; x = 2 / 3; k :: Integer; k = 4 in x * k
16:11:48 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
16:11:48 <lambdabot>         against inferred t...
16:11:51 <ski> > let x :: Rational; x = 2 / 3; k :: Integer; k = 4 in x * fromIntegral k
16:11:52 <lambdabot>   8 % 3
16:12:01 <ski> saikobee : it's the same as there ^
16:12:25 <ski> saikobee : numeric *literals* are overloaded, but there's no implicit conversions between numeric types
16:12:32 <ski> though ..
16:12:35 <ski> ah, DMR !
16:12:37 <gwern> claney: c.h.o seems to be empty right now
16:12:55 <jmcarthur> ha, i think i did that redirect ban wrong
16:13:04 <saikobee> ski: sure, but i was able to get this conversion to be implicit before. any idea how to get it back?
16:13:08 --- mode: ChanServ set +o jmcarthur
16:13:15 --- mode: jmcarthur set -b *!*@p3m/member/mauke$#haskell-ops
16:13:29 <augur> ski: im just not sure if i i should make the function-ness of it all explicit
16:13:30 <jmcarthur> oh no, i did it right. my client just shows something different from what i typed
16:13:45 <djahandarie> $a:mauke$#haskell-ops
16:13:49 <augur> because i do want users to be able to use functions in the language
16:13:54 <augur>  /proof system
16:13:55 <djahandarie> But it seems like he isn't automatically joining so it doesn't really matter
16:13:56 <claney> yes, seems that way. is there an up-to-date mirror somewhere?
16:13:57 <augur> hrm
16:14:02 --- mode: jmcarthur set -o jmcarthur
16:14:04 <augur> ski: lambdabot me some messages
16:14:04 <augur> afk
16:14:05 <jmcarthur> yeah, we're alright
16:14:22 <gwern> claney: nope.
16:14:37 <ski> saikobee : either add `{-# NoMonomorphismRestriction #-}' at the top of the file, or add the signature `k :: Num a => a'
16:14:37 <ski> that way, `k' will be overloaded
16:14:37 <ski> saikobee : in no case wil lyou get an implicit conversion, though
16:14:37 <ski> (saikobee : haskell doesn't do implicit conversions of this sort)
16:15:20 <claney> thanks. will just wait then I guess. how long do these kind of things normally last?
16:15:43 <ski> @tell augur i'm not sure how to read the proof `a b => [a,b] => a' .. is this more or less ordinary logic ? or a more or less random formal system ? maybe a linguistic system ?
16:15:43 <lambdabot> Consider it noted.
16:16:06 <saikobee> ski: oh, nevermind. i see the issue. if i type `x * 4' it works out, but if i use `k' it gets mad because it's an integer. nevermind then.
16:16:43 <saikobee> ski: i'm aware of haskell not automatically converting things like that, but just got a little confused because the behavior of 4 changes when it is bound to k.
16:16:49 <saikobee> ski: thanks :)
16:17:54 <edwardk> @tell roconnor my 'put' makes sense as an random access 'read' on the current store
16:17:54 <lambdabot> Consider it noted.
16:18:54 <edwardk> @tell roconnor while my 'modify' is a 'relative read' relative to the head of the store.
16:18:54 <lambdabot> Consider it noted.
16:19:43 <ski> @tell augur also i think if `make-pair' is curried, you'd need `(left .) . make-pair' instead .. maybe something based on concatenative programming (like Forth,Factor and Joy) would be appropriate (just an idea) ?
16:19:43 <lambdabot> Consider it noted.
16:19:43 <ski> saikobee : yes, `4' is overloaded .. normally `k' would be overloaded as well, but since it isn't *syntactically* a function definition, the dreaded monomorphism restriction kicks in and forces it to be monomorphic
16:19:43 <ski> saikobee : the cure is to either disable DMR, or to add an explicit type signature for `k'  (the alternative of making it into a syntactic function definition doesn't work here, since it's not (known to be) of function type)
16:19:44 <ski> saikobee : oh, sorry, after the `{-#' you need `LANGUAGE', before `NoMonomorphismRestriction'
16:21:24 <ski> (jmcarthur : hm, was kicking mauke needed ? .. as long as augur (or anyone else) didn't repeat themselves, it was ok, no ?)
16:21:54 <edwardk> @tell roconnor while for wont of a better name: warp :: (s -> s) -> Store s a -> Store s a; warp f (Store k j) = Store (f . k) j — gives you the ability in some sense to separate the read and write heads. though that fact is clearer in the indexed store
16:21:54 <lambdabot> Consider it noted.
16:22:00 <ski> edwardk : `Store' is the "state-in-context" comonad ?
16:22:35 <edwardk> @tell roconnor er (k . f) j
16:22:35 <lambdabot> Consider it noted.
16:22:43 <edwardk> ski: yeah
16:22:53 <jmcarthur> ski: it's been a continuing problem today. i don't think it was uncalled for, and he's not even banned now
16:23:01 <gwern> repeat themselves? was that the #xkcd script against repetition?
16:23:31 <edwardk> ski: the seemingly clean duality with state is a bit more complicated than at first it seemed.
16:23:35 <ski> what did you call `\f (Store k j) -> Store (k . f) j' ? .. was that `modify' ?
16:23:40 <edwardk> the duality is fine, but the operation set is a bit different
16:24:05 <ski> jmcarthur : ok, i see
16:24:09 <roconnor> edwardk: I figured out how to define my put using your put
16:24:09 <lambdabot> roconnor: You have 5 new messages. '/msg lambdabot @messages' to read them.
16:24:13 <augur> o hai
16:24:13 <lambdabot> augur: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:24:14 <edwardk> modify needs to tweak the state on the right, if you precompose it with the function, it doesn't have the right semantics
16:24:19 <edwardk> roconnor: ?
16:24:44 <augur> ski: no, make-pair and all of these proof things are uncurried
16:24:48 * ski thought augur would be gone for a while .. otherwise he'd not had bothered with sending `tell's to lambdabot ..
16:25:00 <augur> i really should've written it \(a,b) -> [a,b], but
16:25:12 <roconnor> edwardk: myput b x = yourput b (duplicate x)
16:25:35 <roconnor> edwardk: The trick is not to extend your put, but to compose with duplicate
16:25:35 <edwardk> hrmm
16:25:48 <edwardk> guess that makes sense
16:25:57 <edwardk> that keeps me cokleisli
16:26:01 <edwardk> which makes me very happy
16:26:03 <roconnor> and I'm happy
16:26:10 <roconnor> as long as I can define my put
16:26:20 <ski> (jmcarthur : fyi, i've seen eli in #scheme have a gabot which warned after three repetitions, and banned after the fourth .. or something like that)
16:26:24 <roconnor> ... but given that it was so hard, I suggest adding my put to the library
16:26:31 <roconnor> under some sort of name
16:26:32 <cwraith> cokleisli sounds like some kind of drug
16:26:44 * roconnor away for dinner for a few minutes
16:26:46 <edwardk> roconnor: yeah
16:26:51 <edwardk> roconnor: we need to talk when you get back
16:27:02 <ski> edwardk : yeah, since `(Store s a -> b) ~= (a -> Cont s b)' ..
16:27:37 <edwardk> ski: note that breaks down a bit when talking StoreT and ContT
16:27:43 <augur> see, the real issue is that i want users to be able to have functions explicitly, so that rewrite rules could include as part of the rewrite a function application like, say... a b => [a, f b] (r), where f is an actual function, so that [a, f b] ~= whatever its redux is
16:28:04 <ski> edwardk : so, what did you call the operation which is like `warp' but flipping the composition ?
16:28:04 <jmcarthur> ski: that seems a reasonable policy
16:28:20 <edwardk> ski: one is just map
16:29:03 <augur> so that reduction of f b to its denotation is not considered part of the proof, as such, or at least its reduction to its value usurps all proof search
16:29:06 <edwardk> ski: i'm playing with names atm, seeking clean laws for roconnor
16:30:10 <edwardk> @tell roconnor i think i'll call your put 'put' and my put 'read'. defining yours by default in terms of mine
16:30:10 <lambdabot> Consider it noted.
16:30:22 <edwardk> @tell roconnor that way 'read' is random access to the store
16:30:22 <lambdabot> Consider it noted.
16:34:17 <edwardk> hrmm, read could also be 'peek' =)
16:35:47 <ski> edwardk : hm, no actually on second thought i was wrong. `Store s a -> b  ~=  (s,s -> a) -> b  ~=  (s -> a) -> (s -> b)' while `(b -> o) -> (a -> o)  ~=  a -> ((b -> o) -> o)  ~=  a -> Cont o b' (as i'm sure you already know)
16:36:12 * ski tries to recall what he actually meant to recall/say
16:36:13 <edwardk> ski: yeah, its close. for a while i thought Cont and Store were related.
16:36:17 <edwardk> they are close
16:36:35 <augur> ski: no opinions? :(
16:37:45 <ski> <ski> edwardk : oh .. now i remember what i was thinking of .. i was thinking of `\f (Store k j) -> Store k (f j)' (i just for some reason misremembered that one was to flip the composition)
16:37:49 <ski> <ski> edwardk : so, what about that one ? is that your `modify' ?
16:37:52 <ski> <ski> edwardk : have you considered renaming `duplicate' to `scaffold' ?
16:37:58 <ski> <ski> (i don't recall whether i've mentioned that name suggestion to you, or not)
16:38:03 <ski> <ski> (re `StoreT' and `ContT' : yeah ..)
16:38:10 <BMeph> Has anyone heard anything about rehashing Uustalu-Vene papers, now that GHC has gone through so much more fruitful development?
16:38:28 <edwardk> Cont is given rise to by the adjunction between (<-) and (<-), which is an adjunction from Hask^op -> Hask. since its a composition of adjunctions its adjoint would be itself, but there is no dual adjunction on Cont, because that would require ((a -> r) -> r) -> a
16:38:35 <edwardk> er dual adjunction giving rise to Cont
16:39:08 <copumpkin> scaffold :O
16:39:11 <edwardk> we can do that with games involving mutation in other languages, just not in hask
16:39:12 <ski> augur : i think it sounds sensible
16:39:26 <edwardk> i think i'll stick with duplicate for now =)
16:39:26 <ski> copumpkin : yeah, isn't it good ? :)
16:39:42 <copumpkin> ski: I guess :P
16:39:43 <ski>   scaffold :: Comonad w => w a -> w (w a)
16:40:02 <ski> raises a scaffold, splitting the `w' structure into two levels
16:40:13 <copumpkin> ski: call it tails, à la Cale's (.) ;)
16:40:25 <ski> .. well, at least it's better than `duplicate' and 'cojoin', i think
16:40:26 <edwardk> tails is something i've considered, but its too horrid =)
16:40:35 <copumpkin> didn't stop Cale from doing (.)
16:40:35 <copumpkin> :P
16:40:51 <edwardk> copumpkin: note that nothing else has adopted that use of (.) =P
16:40:58 <augur> ski: do you think there should be a special distinction between proof functions and other functions? cause like.. i can imagine that you could have like.. make-pair used as a mandatory thing, or used as part of a search
16:41:03 * ski views those `(.)' and `flip' with mixed feelings
16:41:16 <BMeph> Has anyone analyzed whether a viable ListT can be based off of List being "iso" to MaybeT Stream?
16:41:45 <augur> i mean, you could either have the proof do like   a b => [a,b] (make-pair),  but you could also have some rule that explicitly uses make-pair, in like a b => [a, b, make-pair a b]
16:41:46 <augur> or something
16:42:03 <edwardk> bmeph: i have a comonad transformer with that mindset
16:42:04 <Jesin> :t flip
16:42:05 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:42:14 <ski> edwardk : well, only if the functions are linear, no ?
16:42:26 <Jesin> :t (.)
16:42:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:42:31 <edwardk> ski: well, it can fairly easily unsafePerformIO so you need to be careful =)
16:42:43 <Jesin> :t flip . (. flip id)
16:42:44 <lambdabot> forall a b a1 b1. (((a1 -> b1) -> b1) -> a -> b) -> a -> a1 -> b
16:43:00 <Jesin> hm.
16:43:00 <edwardk> ski: basically you lose all sense of propriety when it comes to control flow. just pretend you're in scheme ;)
16:43:07 <Jesin> :t (flip .) . flip id
16:43:08 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => a1 -> (a1 -> f (a -> b)) -> a -> f b
16:43:17 <ski> (of course, i'm the one who suggested `flip', so i suppose maybe i shouldn't complain too much ;)
16:43:18 <BMeph> edwardk: Sweet! That tells me that my mind is not yet disintegrated into useless mush. I hope it gives good results. :)
16:43:31 <edwardk> :t flip
16:43:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:43:40 <edwardk> hahaha
16:43:48 <ski> like it ? :)
16:43:57 <edwardk> i call that one ($>) in Data.Functor.Apply atm
16:44:58 <ski> augur : hm, do you mean the distinction of using a function as a proof-step, and using it to specify part of a formula ?
16:45:12 <Jesin> flip [(2+),(2*),(3-)] 5
16:45:15 <Jesin> > flip [(2+),(2*),(3-)] 5
16:45:16 <lambdabot>   [7,10,-2]
16:45:23 <edwardk> ski: i wind up using that a lot actually with wfix
16:45:25 <Jesin> lol.
16:45:29 <Jesin> umm
16:45:37 <Jesin> I hope you can still get it to inline properly that way?
16:45:44 * ski can imagine that :)
16:45:45 <copumpkin> > sequence [(2+),(2*),(3-)] 5
16:45:46 <lambdabot>   [7,10,-2]
16:45:51 <augur> ski: yeah, im not sure if its /necessary/ to have such a distinction
16:45:55 <Jesin> hmm.
16:45:55 <augur> but maybe
16:45:55 <copumpkin> omg proof that flip = sequence
16:45:58 <copumpkin> ALWAYS
16:46:04 <Jesin> wait what
16:46:06 <Jesin> lol
16:46:14 <Jesin> ...
16:46:18 <Jesin> :t sequence
16:46:18 <hpc> :t sequence
16:46:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:46:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:46:22 <hpc> :t flip
16:46:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:46:28 <hpc> holy balls
16:46:31 <ski> edwardk : re "control flow" .. hence i was suggesting using the continuation linearly
16:46:39 <Jesin> o.o
16:46:42 <Jesin> hmm.
16:46:44 <copumpkin> PROOF THAT ANY FUNCTOR IS A MONAD
16:46:49 <copumpkin> (OR AN APPLICATIVE, FINE)
16:47:02 <hpc> copumpkin: more like PROOF THAT -> IS BOTH
16:47:08 <augur> proof steps should also be conditional, i think. which surely isnt a typical kind of function (not that you couldnt have such a function, but)
16:47:11 <copumpkin> hpc: ALL MONADS AND ALL FUNCTORS
16:47:17 <ski> copumpkin : well, you need `pure' as well :)
16:47:18 <Jesin> WHY ARE WE SHOUTING
16:47:22 <hpc> WHY NOT?
16:47:24 <hpc> :D
16:47:28 <copumpkin> Jesin: BECAUSE I AM VERY EMPHATIC
16:47:34 <copumpkin> ski: NO
16:47:36 <ski> WHO'S SHOUTING ?
16:47:44 <edwardk> fib d = wfix $ flip d $ fby 0 . extend (\dg -> extract dg + 1 `fby `dg) 
16:47:45 <monochrom> proof that all letters have capped versions
16:47:47 <edwardk> thats cute
16:47:59 <hpc> :t sequence `asTypeOf` flip
16:48:00 <lambdabot> forall a a1. [a1 -> a] -> a1 -> [a]
16:48:07 <Jesin> wow
16:48:09 <Jesin> they have asTypeOf
16:48:17 <ski> augur : well, it could be useful to at least distinguish between those two different *uses* of functions
16:48:18 <Jesin> :t asTypeOf
16:48:19 <lambdabot> forall a. a -> a -> a
16:48:21 <Jesin> :k asTypeOf
16:48:22 <hpc> asTypeOf = const, with more constrained signature
16:48:22 <lambdabot> Not in scope: type variable `asTypeOf'
16:48:30 <hpc> @src asTypeOf
16:48:30 <lambdabot> asTypeOf = const
16:48:32 <Jesin> :t const
16:48:32 <lambdabot> forall a b. a -> b -> a
16:48:40 <hpc> it's pretty clever
16:48:44 <Jesin> yeah
16:48:45 <ski> (augur : and of course you should distinguish between object-level and meta-level functions, but i assume you already know that)
16:48:46 <Jesin> it is
16:48:47 <augur> ski: ok. maybe with some sort of special operator?
16:49:31 <Jesin> :t flip `astypeof` sequence
16:49:31 <lambdabot> Not in scope: `astypeof'
16:49:33 <ski> @type sequence `asTypeOf` flip
16:49:34 <lambdabot> forall a a1. [a1 -> a] -> a1 -> [a]
16:49:37 <Jesin> :t flip `asTypeOf` sequence
16:49:37 <lambdabot> forall a b. [a -> b] -> a -> [b]
16:49:40 <augur> ski: yeah, well, i mean, these arent supposed to be object-level functions, as such, they're just supposed to be meta-level just like proof steps, but more transparently
16:49:51 <ski> (hehe, triple-echo)
16:50:28 <Jesin> :t join `asTypeOf` concat
16:50:29 <lambdabot> forall a. [[a]] -> [a]
16:50:44 <Jesin> :t (>>=)
16:50:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:51:14 <Jesin> @src (->) (>>=)
16:51:14 <lambdabot> f >>= k = \ r -> k (f r) r
16:51:17 <augur> ski: so like, in principle you _could_ wrap the entire expression in some sort of EVAL flag, right
16:51:21 <Jesin> @src [] (>>=)
16:51:22 <lambdabot> xs >>= f     = concatMap f xs
16:51:42 <roconnor> edwardk: I'm back
16:51:52 <Jesin> but, wow
16:52:14 <augur> to force the function to evaluate strictly prior to all other proof search, you'd just make sure no non-reduction rule applies to something wrapped in EVAL, or something
16:52:34 <Jesin> :t fmap fmap (`id` x) 
16:52:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (Expr -> a -> b) -> f a -> f b
16:52:58 <Jesin> :t fmap fmap fmap (flip id)
16:52:59 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) b. (Functor f, Functor f1) => f (f1 a) -> f (f1 ((a -> b) -> b))
16:53:12 <Jesin> :t fmap (fmap fmap (flip id))
16:53:13 <lambdabot> forall b (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1) => f1 a -> f1 (f (a -> b) -> f b)
16:53:13 <ski> augur : what do you mean by conditional proof steps ? .. ones with side conditions ?
16:53:24 <Jesin> hm.
16:53:26 <ski> edwardk : yeah, cute :)
16:53:34 <augur> so its really just more of a meta tool for making certain equivalencies transparent, so that instead of proving explicitly that x = y therefore K{x} can rewrite as K'{x} because we have some rule K{y} => K'{y}, you just can transparently reduce it
16:53:43 <thierry`> hi, I'm working with Data.Time to get the time when each call of a recursive function is runned and I was wondering about the lazyness of Haskell, could it run the function later and then give me a time a little bit too late?
16:53:52 <Jesin> :t let flip' f x = fmap ($ x) f
16:53:53 <lambdabot> <no location info>:
16:53:53 <lambdabot>     not an expression: `let flip' f x = fmap ($ x) f'
16:53:58 <Jesin> :t let flip' f x = fmap ($ x) f in flip'
16:53:59 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:54:00 <Jesin> :t flip
16:54:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:54:03 <augur> ski: yeah, like, you can't apply this proof step without some properties holding of the inputs/outputs
16:54:07 <Jesin> ok, so that's how that's defined
16:54:09 <Jesin> ...
16:54:10 <ski> > map `asTypeIn` \map -> map chr []
16:54:10 <lambdabot>   Overlapping instances for GHC.Show.Show
16:54:10 <lambdabot>                              ((GHC....
16:54:13 <ski> @type map `asTypeIn` \map -> map chr []
16:54:14 <lambdabot> (Int -> Char) -> [Int] -> [Char]
16:54:22 <ski> @type asTypeIn
16:54:23 <lambdabot> forall a b. a -> (a -> b) -> a
16:56:34 <Jesin> wait what
16:56:40 <Jesin> :t asTypeOf
16:56:41 <lambdabot> forall a. a -> a -> a
16:56:43 <Jesin> :t asTypeIf
16:56:44 <lambdabot> Not in scope: `asTypeIf'
16:56:45 <Jesin> :t asTypeIn
16:56:45 <lambdabot> forall a b. a -> (a -> b) -> a
16:56:48 <Jesin> hm.
16:57:09 <Jesin> :t unsafeCoerce
16:57:09 <lambdabot> Not in scope: `unsafeCoerce'
16:57:14 <Jesin> :t Unsafe.Coerce.unsafeCoerce
16:57:15 <lambdabot> forall a b. a -> b
16:57:23 <ski> augur : yeah, one would need to reduce the formulae wrt the (meta-)functions in them, before being able to match them against a particular pattern, to be able to apply proof steps
16:57:25 <ski> `asTypeIn' is useful to constrain the type of an expression, by how it is *used* in another expression
16:57:27 <Jesin> :t Unsafe.Coerce.unsafeCoerce `asTypeIn` (>>=)
16:57:28 <lambdabot> forall a b. a -> b
16:57:38 <Jesin> oh wait
16:57:40 <Jesin> hm.
16:57:41 <ski>   a `asTypeIn` _ = a  -- the definition
16:57:53 <edwardk> heh, half tempted to call peek/read/whatever 'goto'
16:58:27 <ski> `asTypeIn' can also be used to ask which specific instance of a polymophic function is used, in an expression
16:58:35 <edwardk> goto x . extend . goto = goto  — is the main law i can seem to find for it
16:58:41 <Jesin> :t (>>=) `asTypeIn` flip
16:58:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:58:55 <edwardk> er thats slightly off
16:58:58 <Jesin> :t (>>=) `asTypeIn` (let flip' f x y = f y x in flip')
16:58:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:58:59 <ski> (.. i.e. ask for the type of the instance of it)
16:59:18 <edwardk> goto x (extend (goto y) s) = goto y s
16:59:30 <augur> ski: indeed; the idea behind the functions in rules is to allow that sort of thing to be explicit. so for example, instead of _searching_ for the reverse of a list by blind proof search, lets say, you can just define it and eliminate the search component entirely by enforcing the use of certain rules immediately
17:00:32 <Jesin> hmm
17:00:32 <BMeph> :t (=<<) `asTypeOf` flip
17:00:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
17:00:33 <lambdabot>     Probable cause: `flip' is applied to too many arguments
17:00:33 <lambdabot>     In the second argument of `asTypeOf', namely `flip'
17:00:34 <Jesin> [20:14:01]	<ski>	`asTypeIn' can also be used to ask which specific instance of a polymophic function is used, in an expression
17:00:40 <Jesin> ski, how?
17:00:44 <augur> but if i unify rules with functions, i dont know how to bolt conditions onto the functions
17:00:53 <Jesin> :t (=<<) `asTypeIn` flip
17:00:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:01:04 <ski> @type (>>=) `asTypeIn` \(>>=) -> Nothing >>= undefined
17:01:05 <lambdabot> forall a b. Maybe a -> (a -> Maybe b) -> Maybe b
17:01:22 <Jesin> ooh
17:01:24 <Jesin> ok
17:01:59 <BMeph> :t asTypeOf
17:02:00 <Jesin> @type (>>=) in \(>>=) -> Unsafe.Coerce.unsafeCoerce >>= Unsafe.Coerce.unsafeCoerce
17:02:00 <lambdabot> forall a. a -> a -> a
17:02:00 <lambdabot> parse error on input `in'
17:02:08 <Jesin> @type (>>=) `asTypeIn` \(>>=) -> Unsafe.Coerce.unsafeCoerce >>= Unsafe.Coerce.unsafeCoerce
17:02:09 <lambdabot> forall a b a1. (a1 -> a) -> (a -> a1 -> b) -> a1 -> b
17:02:15 <Jesin> yaaay
17:02:35 <joe6> i have something like this: concatMap (flip showHex "") . concatMap dpBytes
17:02:41 <ski> @type (>>=) `asTypeIn` \(>>=) -> Nothing >>= undefined
17:02:42 <lambdabot> forall a b. Maybe a -> (a -> Maybe b) -> Maybe b
17:02:43 <joe6> where dpBytes is a field of a record.
17:02:54 <joe6> is there a smarter/simpler way of writing it.
17:02:57 <ski> Jesin : ^ that seems a more sensible example, imo
17:03:36 <Jesin> hmm
17:03:43 <augur> ski: maybe somehow i could incorporate dead proof steps or something, kind of like a Nothing step vs. a Just x step
17:03:45 <ski> augur : i don't follow the "indeed; ..." comment
17:03:53 <Jesin> are there any other functions of type forall a b. a -> b
17:03:58 <Jesin> besides the unsafeCoerce one
17:04:00 <Jesin> :p
17:04:12 <ski> `undefined'
17:04:18 <augur> ski: oh, sorry, it was just to agree about the purpose of the functions and how they'd be forced to reduce first
17:04:26 <Jesin> ski, I meant specifically
17:04:30 <Jesin> though, hmm...
17:04:32 <Jesin> this might work?
17:04:39 <hpc> Jesin: fix ($)
17:04:43 <hpc> though that's undefined
17:04:52 <ski> Jesin : `const undefined' ?
17:04:54 <Jesin> ooh yay  :p
17:04:56 <Jesin> ok
17:04:56 <ski> @type undefined :: a -> b
17:04:57 <lambdabot> forall a b. a -> b
17:04:58 <Jesin> :t const undefined
17:04:59 <lambdabot> forall a b. b -> a
17:04:59 <hpc> ski: lol
17:05:03 <Jesin> that also works, awsome
17:05:21 <Jesin> "this might work?" yeah I thought of explicit type declaration, that works
17:05:50 <bos> @pl \v -> ((k,v):)
17:05:50 <lambdabot> (:) . (,) k
17:05:53 <augur> ski: also, do you think i should include implicit types, or should i let types be a part of the proof?
17:06:59 <Cookies> COOKIES
17:07:37 <BMeph> ...because the cake is...well, YOU know.
17:08:08 <monochrom> monochrom
17:08:33 <Jesin> Jesin
17:08:54 * Jesin Jesin
17:08:55 <hpc> haskell program coverage
17:08:58 <ski> note that, due to the presence of `seq', `undefined' and `const undefined' are not equal (if you care about behaviour for non-total arguments)
17:08:59 <ski> implicit as in inferred ?
17:08:59 <ski> augur : `rule :: (n >= 0) => foo n -> bar n' could be a way to add a side-condition, i suppose
17:09:05 * Jesin grammar-smasher
17:09:07 <Jesin> :p
17:09:25 <augur> ski: with types, you mean?
17:10:06 <Jesin> :t seq
17:10:07 <lambdabot> forall a t. a -> t -> t
17:10:11 <ski> what with types ?
17:10:17 <augur> ski: the pre-conditions
17:10:33 <edwardk> @tell roconnor pos :: StoreT s w a -> s; seek : s -> StoreT s w a -> StoreT s w a (your put), peek: s -> StoreT s w a -> a (my put), then seeks and peeks are your modify and my modify respectively. this gives easily read laws
17:10:33 <lambdabot> Consider it noted.
17:10:33 <ski> Jesin : `seq' in many ways causes lots of trouble to the semantics of Haskell programs ..
17:10:39 <Jesin> yeah
17:10:47 <Jesin> it's a strictness thing, I know
17:10:52 <augur> ski: i mean, you wrote it as ::, so it looks like a condition on the type
17:11:20 <edwardk> @tell roconnor x = seek (pos x) x; y = pos (seek y) x; seek y x = seek y (seek y x)
17:11:20 <lambdabot> Consider it noted.
17:11:23 <Jesin> apparently sometimes people try to use it for optimization but the compiler doesn't play nice with that so bang-patterns or ($!) are recommended instead
17:11:45 <edwardk> @tell roconnor er. seek y x = seek y (seek z x)
17:11:45 <lambdabot> Consider it noted.
17:12:04 <edwardk> @tell roconnor this also works nicely when store is instead instantiated as the pointer comonad
17:12:04 <lambdabot> Consider it noted.
17:12:06 <augur> ski: also, there are post conditions and "trans" conditions which are sort of constraints on the interaction between variable bindings between both sides
17:12:34 <Jesin> > (undefined :: a -> b) `seq` 3
17:12:36 <lambdabot>   *Exception: Prelude.undefined
17:12:40 <Jesin> > (const undefined :: a -> b) `seq` 3
17:12:41 <lambdabot>   3
17:12:45 <Jesin> :p
17:13:00 <roconnor> edwardk: these are the get/put laws?
17:13:08 <Jesin> :t cequal
17:13:09 <lambdabot> forall a. (Eq a) => ([Bool] -> a) -> ([Bool] -> a) -> Bool
17:13:18 <edwardk> roconnor: yeah just rephrased with the different names
17:13:31 <ski> augur : yeah, but note i said `=>' instead of `->', meaning to imply that you wouldn't pass an explicit argument of type `n >= 0', rather you'd make sure that that was trivially deducable from the current context 
17:13:31 <ski> augur : ah, yes. yes indeed
17:13:32 <roconnor> pointer comonad?
17:13:36 <edwardk> roconnor: that way you can clearly think of the stored state as the position
17:13:44 <edwardk> roconnor: same thing just with an array instead of a function
17:14:01 <edwardk> roconnor: (a i e, i)
17:14:21 <edwardk> roconnor: useful as an example because then cokleisli actions are things like image blur, etc.
17:14:30 <edwardk> ad the index i is the selected pixel
17:14:36 <edwardk> er and
17:14:43 <augur> ski: right, but it'd be a precondition on the type of the function, right? and it would make reference to the input values (so it'd be dependent, maybe?) thered also need to be post-condition versions as well
17:14:45 <augur> ehhhh
17:14:46 <ski> edwardk : those names sounds .. suggestive :)
17:14:47 <ski> > seq (undefined :: IO ()) ()
17:14:47 <lambdabot>   *Exception: Prelude.undefined
17:14:48 <ski> > seq (undefined >>= return :: IO ()) ()
17:14:49 <lambdabot>   ()
17:15:01 <edwardk> ski: hahaha
17:15:02 <ski> ^ PROOF THAT `IO' ISN'T A MONAD !
17:15:33 <monochrom> all-caps has been fashionable recently
17:15:34 <kevinburke> is there a way to define optional parts of a data type?
17:15:47 <ski> monochrom : indeed
17:15:49 <kevinburke> like data Factor = Factor (MultOp Term)
17:15:57 <kevinburke> where the Multop term are optional
17:16:13 <monochrom> use the Maybe type. data Factor = Factor (Maybe (MultOp Term))
17:16:25 <roconnor> edwardk: seems reasonable
17:16:45 <edwardk> roconnor: it also fits your moving head analogy
17:16:48 * ski idly wonders whether unicode contains other variants, like "small caps"
17:17:04 <ski> (.. i'd suppose not)
17:17:13 <monochrom> data Monochrom = Monochrom { email : Maybe String, age : Maybe Integer }
17:17:16 <edwardk> roconnor: now i need a better name for experiment ;)
17:17:36 <Eduard_Munteanu> monochrom: maybe your ageless?
17:17:43 <BMeph> edwardk: molest? ;þ
17:17:53 <edwardk> bmeph: hahahaa
17:17:55 <Eduard_Munteanu> *you're
17:18:08 <monochrom> maybe I don't reveal my age for privacy reasons
17:18:10 <roconnor> edwardk: moving head is one of the reasons I chose the store name
17:18:13 <edwardk> ski: those are there
17:18:35 <Eduard_Munteanu> Hm, maybe.
17:18:45 <edwardk> roconnor: yeah. i like this because it makes "Pointer" into an instance of a Store and the nomenclature fits
17:18:52 <joe6> > Word8 -> Word8 -> Word16
17:18:53 <lambdabot>   <no location info>: parse error on input `->'
17:19:11 <ski> edwardk : `y = pos (seek y) x' looks ill-typed ..
17:19:18 <Eduard_Munteanu> @hoogle Word8 -> Word8 -> Word16
17:19:18 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
17:19:18 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:19:18 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
17:19:47 <Eduard_Munteanu> joe6: you can just shift and 'or' them.
17:19:50 <Jesin> hmm
17:20:04 <edwardk> i think i dropped a variable in that
17:20:04 <roconnor> edwardk: what is the pointer comonad again?
17:20:05 <Jesin> @hoogle a -> b
17:20:06 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:20:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:20:06 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:20:07 <joe6> Eduard_Munteanu: i am trying to combine 2 Word8 into a Word16
17:20:19 <Eduard_Munteanu> Yeah, I suspected that.
17:20:19 <augur> hmm
17:20:26 <joe6> toWord16 $ x ++ y
17:20:31 <edwardk> ski: y = pos (seek y x)
17:20:32 <Jesin> hmm, I don't think I understand this:
17:20:34 <Jesin>     Illegal instance declaration for `Eq ([Bool] -> a)'
17:20:36 <Jesin>         (All instance types must be of the form (T a1 ... an)
17:20:38 <Jesin>          where a1 ... an are type *variables*,
17:20:39 <Jesin>          and each type variable appears at most once in the instance head.
17:20:41 <Jesin>          Use -XFlexibleInstances if you want to disable this.)
17:20:42 <joe6> Eduard_Munteanu: this is what I currently have: toWord16 $ x ++ y
17:20:53 <shapr> edwardk: Haskell meeting in Huntsville on Friday... jmcarthur talks about parallel awesomeness.. you should show up :-)
17:21:05 <augur> ski: what is   p => t   if p doesn't hold?
17:21:26 <SirFrancisDrake> Jesin: let me guess, your data is defined as type Something?
17:21:27 <edwardk> roconnor: data Pointer i e = Pointer (Array i e) i
17:21:37 <joe6> shapr: Huntsville, where?
17:21:45 <Eduard_Munteanu> joe6: what about (a `shiftL` 8) .|. b ?
17:21:50 <edwardk> roconnor: extract (Pointer a i) = a ! i — the rest is obvious
17:22:07 <edwardk> roconnor: its a memoized state with the array providing the universe of possible positions
17:22:13 <ski> edwardk : ok
17:22:22 <edwardk> shapr: sounds a bit far
17:22:33 <shapr> joe6: jmcarthur's talk is part of the monthly 2600 meeting here in HSV. It'll be at Newk's on University. If you want to attend, I can give you my phone number for possible getting lost.
17:22:38 <roconnor> edwardk: finite domained Store?
17:22:44 <Eduard_Munteanu> joe6: erm, with proper conversions.
17:23:03 <SirFrancisDrake> Jesin: quote your line starting from `instance` and the one defining whatever you are making an instance of Eq, please.
17:23:18 <edwardk> roconnor: yeah
17:23:18 <ski> Jesin : add `{-# LANGUAGE FlexibleInstances #-}' at the top of your file, as the message suggests
17:23:20 <Jesin> instance Eq a => Eq ([Bool] -> a) where
17:23:21 <Jesin>   f == g = cforall (\x -> f x == g x)
17:23:23 <Jesin>   f /= g = cforsome (\x -> f x /= g x)
17:23:32 <augur> ski: i mean, i know that if a :: p => t, and p holds, then a :: t, basically, but if p /doesnt/ hold..
17:23:33 <Jesin> ski, I'm not sure why FlexibleInstances are required for this
17:23:50 <ski> Jesin : though with `instance (Compact a,Eq b) => Eq (a -> b)', you don't need this
17:23:54 <Eduard_Munteanu> joe6: so it's adding fromIntegrals to that.
17:24:12 <edwardk> extend takes some function that knows how to generate one element in the target given the entire source, and iterates it over the entire source array, giving you a new array
17:24:13 <Jesin> huh.
17:24:21 <roconnor> edwardk: I'm not a big fan of the name, but sounds okay.
17:24:27 <Jesin> @hoogle Compact
17:24:27 <lambdabot> Text.Html compact :: HtmlAttr
17:24:27 <lambdabot> Text.XHtml.Transitional compact :: HtmlAttr
17:24:32 <edwardk> roconnor: it was sigfpe's name
17:24:33 <joe6> shapr: where is HSV? I am not sure if I live nearby. I am in Atlanta
17:24:44 <Jesin> ski, where would I find Compact?
17:24:45 <joe6> Eduard_Munteanu: Thanks, will check it out.
17:24:47 <ski> Jesin : without `FlexibleInstances' the only allowed form of `???' in `instance ... => ???' is `C x y ...' where `C' is a type constructor and `x',`y' are all distinct type *variables*
17:24:52 <Jesin> or would I have to make my own class for that
17:24:55 <shapr> joe6: HSV is the airport code for Huntsville, AL
17:25:06 <Eduard_Munteanu> edwardk: btw, did you invent the names 'duplicate' and 'extend' or were they published / used before?
17:25:21 <roconnor> edwardk: it isn't really a pointer at all.  It is an array with a highlighed location
17:25:26 <edwardk> Eduard_Munteanu: i think i stole them from dave menendez
17:25:28 <shapr> joe6: It'll take you about four hours to drive from ATL to HSV
17:25:33 <ski> Jesin : you'd define it yourself, as `class Compact a where forAll :: (a -> Bool) -> Bool' (or maybe `Sierpinski' instead of `Bool' .. hm)
17:25:34 <Jesin> like, class Compact where {find; forsome; forall} -- with appropriate type declarations?
17:25:42 <Jesin> ...
17:25:45 <Jesin> Sierpinski?
17:25:50 <Jesin> I haven't heard of this type
17:25:52 <Jesin> :p
17:25:55 <kevinburke> monochrom: i'd have to write a = Factor (Just MultOp Term) then, right?
17:26:00 <edwardk> yep, i did. http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
17:26:01 <ski> augur : if `p' doesn't hold, then `p => t' is "true", meaning that you can't apply the operation :)
17:26:10 <ski> @where impossible
17:26:11 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
17:26:16 <ski> @where topology
17:26:16 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
17:26:16 <lambdabot> dvi|ps)> by Martn Escard
17:26:35 <edwardk> at the time i was concerned with compatibility with his category-extras. boy did that change ;)
17:26:37 <Eduard_Munteanu> Jesin: his type invented some strange carpets and what not
17:26:39 <Eduard_Munteanu> :P
17:26:44 <Jesin> lol
17:26:46 <shapr> joe6: and four hours to drive back... though I am trying to organize weekly knitting & haskell meetings at the local hackerspace.
17:26:48 <ski> Jesin : you should take a look at both those two blog articles, as well as at least the initial part of the latter paper
17:26:56 <augur> ski: wait what
17:26:58 <augur> hrmph
17:27:00 <Jesin> I read the first blog article
17:27:00 <augur> afk
17:27:09 <monochrom> > 15000000 :: Int
17:27:10 <lambdabot>   15000000
17:27:34 * ski shakes head, unbelieving, at augur :)
17:27:36 <SirFrancisDrake> are comonads related to monads as vectors to covectors?
17:27:43 <ski> sortof
17:27:50 <Jesin> > maxBound :: Int
17:27:51 <lambdabot>   9223372036854775807
17:27:59 <dolio> Covectors?
17:27:59 <SirFrancisDrake> thanks
17:28:04 <Jesin> logBase 2 $ fromIntegral (maxBound :: Int)
17:28:13 <Jesin> > logBase 2 $ fromIntegral (maxBound :: Int)
17:28:14 <lambdabot>   63.0
17:28:21 <Jesin> > logBase 2 $ fromIntegral (maxBound :: Word)
17:28:22 <lambdabot>   64.0
17:28:26 <Jesin> :p
17:28:27 <SirFrancisDrake> dolio: linear functions on vectors
17:28:42 <SirFrancisDrake> ehm, afair
17:29:42 <Jesin> hmm
17:29:48 <Eduard_Munteanu> Never heard of those. Do you hint to vectors in dual vector spaces?
17:29:58 <ski> Jesin : so i suppose you maybe want `instance (Compact a,Overt a,Eq b) => Eq (a -> b)' .. (`Overt' is for `forSome') .. hm
17:30:02 <Eduard_Munteanu> *those either
17:30:11 <Jesin> wait, what
17:30:13 <SirFrancisDrake> I certainly do.
17:30:15 <Jesin> how is Overt for forSome
17:30:33 <SirFrancisDrake> In Russian, they are referred to as covectors. 
17:30:33 <Eduard_Munteanu> I see.
17:30:39 <Jesin> I thought forSome p = not (forAll (not . p))
17:31:00 <dibblego> FYI, forSome is a scala keyword for existential types
17:31:22 <SirFrancisDrake> hm, I thought that was an 'international' name for them.
17:31:23 <ddarius> Covectors is fairly common terminology.
17:31:25 <edwardk> covectors are mappings from a vector space to a field, no?
17:31:26 <Jesin> w/e, I'm ignoring scala for now
17:31:27 <Jesin> :p
17:31:31 <ManateeLazyCat> Hi folks.
17:31:32 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
17:31:37 <ddarius> edwardk: Yes.  V -> R (typically)
17:31:40 <Eduard_Munteanu> Well in linear algebra duality is moving one level up to homomorphisms, but in category theory it's more like a matter of flipping arrows, so I'm not sure the analogy holds.
17:31:52 <Eduard_Munteanu> Or rather reversing a duality result.
17:31:57 <ddarius> There are also relations to the exterior calculus (and then to the geometric calculus.)
17:32:04 <edwardk> *nods*
17:32:16 <ski> Eduard_Munteanu : i've suggested `scaffold' instead of `duplicate'
17:32:16 <ski> Eduard_Munteanu,edwardk : and `preserve' instead of `extend' ..
17:32:22 <Jesin> hmm, ski, what are Compact and Overt for and how are they different
17:32:48 <Eduard_Munteanu> ski: hm, I know about your 'scaffold' proposal, but what's with 'preserve'?
17:32:49 <ski> Eduard_Munteanu : vectors in `V' are linear transformations from `I' (the field, regarded as a vector space) to `V', and covectors are linear transformations in the other direction
17:32:51 <Jesin> can't you get forAll and forSome if you have a definition of one, by De Morgan thing?
17:32:55 <edwardk> ski: at this point in time i'm pretty happy with the names, i realize they aren't for everyone, but there are only so many times i can repaint the bikeshed ;)
17:33:15 <ski> Eduard_Munteanu : given `w a -> b' it produces a `w a -> w b' function, which preserves the `w' in the result type
17:33:46 <ski> to me `extend' is forever `Monad m => (a -> m b) -> (m a -> m b)'
17:33:50 <Eduard_Munteanu> ski: isn't that true of '>>=' as well?
17:33:58 <ski> no
17:34:10 <edwardk> i actually wanted to use 'split' originally for duplicate, but it was taken
17:34:10 <ski> `(>>=)' is `flip extend'
17:34:19 <Jesin> also, I think the definitions I have for "forsome" and "forall" on this cantor space
17:34:20 <ski> and `(=>>)' is `flip preserve'
17:34:45 <Eduard_Munteanu> Hrm... I thought (=>>) = flip extend
17:34:47 <edwardk> (>>=) is the wrong direction for that function to go
17:34:48 <ski> Jesin : as for `Overt', read the paper ! :)
17:34:58 <edwardk> Eduard_Munteanu: different people, different terminology
17:35:06 <Eduard_Munteanu> Ah.
17:35:07 <ddarius> Jesin: De Morgan's laws rely on excluded middle (for some of the laws)
17:35:19 <Eduard_Munteanu> At least what was in category-extras.
17:35:23 * ddarius also recommends reading whatever paper it is that ski is suggesting.
17:35:23 <edwardk> yeah
17:35:26 <Jesin> are really for data Cantor a = a :| Cantor a
17:35:36 <Jesin> err
17:35:38 <Jesin> sorry
17:35:52 <Jesin> ...basically, infinite lists of bools where [] never shows up
17:35:53 <Jesin> :p
17:36:00 <edwardk> ski is handy, because you can always get an opinion from him. you may not always agree with it, but he's at least passionate ;)
17:36:01 <ski> Jesin : in the paper, `forSome' and `forAll' is (initially at least) only defined for semi-observable properties .. those that only terminate in the case when they hold
17:36:25 <Jesin> hm?
17:36:33 <Jesin> ah...
17:36:38 <Eduard_Munteanu> Yup, ski's been helpful to me lots of times :)
17:36:41 <ski> Jesin : `data Sierpinski = Terminated', where the valus of `Sierpinski' are `Terminated' (means "true") and `_|_' (means "false")
17:36:48 <Jesin> so it's for different guarantees of where you don't get _|_
17:36:50 <Jesin> ok
17:36:52 <ski> edwardk ;)
17:36:53 <Jesin> ...
17:36:56 <Jesin> woow
17:37:08 <Jesin> so it's for () basically
17:37:12 <Jesin> Sierpinski = ()
17:37:15 <Jesin> yes?
17:37:28 <Jesin> well
17:37:33 <Jesin> type Sierpinski = ()
17:37:39 <Jesin> but yeah ^ that
17:37:42 <Jesin> is that right
17:37:43 <Jesin> :p
17:38:45 <Jesin> so only True is observable, yes?
17:39:35 <djahandarie> Hmm typeclasses feel clunky when you start using them for just making random terms depend on the type
17:39:56 <ddarius> djahandarie: That's probably by design.
17:40:18 <Jesin> and the topology on Sierpinski is { {}, {True}, {True, _|_ } }
17:40:25 <Jesin> am I getting this right  :p
17:40:28 <djahandarie> Why would that be by design?
17:40:33 <conal> ski: i'm with you about extend. (>>=) never felt right to me.
17:40:55 <ski> Jesin : and `Compact a' is for `forAll :: (a -> Sierpinski) -> Sierpinski' (terminating for every total function input) and `Overt a' is for `forSome :: (a -> Sierpinski) -> Sierpinski' (similarly with that one)
17:40:55 <ski> hm, no, terminating in case every *total* value in `a' has the property, rather
17:40:55 <ski> (and in the `Overt' case, terminating if there exists a *total* value in `a' which has the property)
17:40:55 <ski> anyway, read the paper .. i might be misremembering stuff :)
17:40:55 <ski> Jesin : re `()' .. yes, but we definitely don't ignore the `_|_' in `Sierpinski'
17:41:11 <ski> edwardk : re names : i understand .. it's just that i find the current names sometimes even misleading (i think `a -> (a,a)' when i read `duplicate', e.g.)
17:41:12 * djahandarie thinks ski's connection was lagging
17:41:19 <edwardk> conal: well the argument in favor of flipping (>>=) comes down to the fact that flipped it takes a kleisli arrow to an arrow in the base category.
17:41:36 <ski> djahandarie : yes, it's been laggy for a while now .. no idea why
17:41:39 <Jesin> hmm
17:41:52 <Jesin> why the thing where False never terminates?
17:41:54 <Jesin> is that just easier?
17:42:02 <ski> (and the fact that i'm attempting to communicate with too many people at the time doesn't help, of course)
17:42:15 <edwardk> conal: what is nice about that version is it doesn't depend on exponentials in the base category. which means you can use it for monads in other categories
17:42:15 <Jesin> also, should I use data InfList a = a :| InfList a
17:42:59 <ski> conal : sometimes i think we should be able to make an infix operator, which in non-operator-use would take the arguments in the other way (or inside a pair) ..
17:43:32 <conal> edwardk: yep. that's what fits for me.
17:44:07 <edwardk> conal: plus, it also cleanly dualizes giving the comonadic definition
17:44:20 <andres_> hello everybody
17:44:21 <conal> edwardk: yep. lovely.
17:44:30 <Eduard_Munteanu> andres_: hi
17:44:39 <edwardk> (w a ~> b) -> w a ~> w b — can be seen mapping arrows in the target category
17:45:19 <edwardk> now i just need to get everyone to give up their monads and comonads and come play with semifunctors with me ;()
17:45:27 <Eduard_Munteanu> BTW, do comonad transformers make sense? I've seen some talk around here.
17:45:39 <edwardk> Eduard_Munteanu: yes. i have a whole library of them
17:45:52 * Eduard_Munteanu looks on Hackage then...
17:45:53 <edwardk> Eduard_Munteanu: they have 'lowerings' rather than liftings =)
17:45:54 <andres_> some could explain to me what are the "Phantom types" ?
17:45:57 <edwardk> comonad-transformers
17:45:58 <Eduard_Munteanu> Heh.
17:46:03 <edwardk> is the package
17:46:05 <Jesin> umm
17:46:09 <edwardk> @hackage comonad-transformers
17:46:09 <lambdabot> http://hackage.haskell.org/package/comonad-transformers
17:46:13 <Jesin> could someone give an example of a use of comonads
17:46:16 <Jesin> :p
17:46:24 <SirFrancisDrake> second that
17:46:31 <ski> SirFrancisDrake : anyway, yes comonads are related to monads by "reversing the arrows", like vectors vs. covectors
17:46:34 <edwardk> jesin: you can do cellular automata with them very easily
17:46:42 <Jesin> ...
17:46:43 <Eduard_Munteanu> Jesin: did you see sigfpe's blog post on cellular automata and comonads?
17:46:45 <Jesin> whaaat
17:46:47 <SirFrancisDrake> ski: thanks.
17:46:53 <ski> conal : yes, `extend' and `preserve' are the basic operations in terms of CT (unless you go with `join' and `scaffold' instead)
17:47:01 <Jesin> no, I didn't
17:47:23 <ski> Jesin : yes, that's the relevant topology
17:47:33 <Eduard_Munteanu> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
17:48:30 <copumpkin> conal: happy birthday!
17:48:53 <djahandarie> Happy birthday conal
17:48:58 <conal> copumpkin: thanks! i'm having a great day.
17:49:02 <conal> djahandarie: thanks :)
17:49:05 <Jesin> class Comonad m where
17:49:06 <Jesin>   extract :: m a -> a
17:49:08 <Jesin>   duplicate :: m a -> m (m a)
17:49:15 <Jesin> :t join
17:49:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:49:16 <Jesin> :t return
17:49:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:49:30 <kevinburke> monochrom: i tried data Term   = Factor (Maybe (MultOp Term))
17:49:34 <Eduard_Munteanu> andres_: they're types (or type variables) that aren't used per se. They're meant to enforce some sort of constrain or deduce some sort of typing relation.
17:49:41 <ski> Jesin : having properties where "false" doesn't terminate is more general .. e.g. assume you have a decidable property on natural numbers .. now you want to know whether there exists a natural number which satisfies the property .. so you start checking them, one more and one more .. this is a semi-observable property
17:49:41 <ski> (Jesin : btw, i often call it `data Stream a = Cons {head :: a , tail :: a}')
17:49:44 <edwardk> jesin" i've refactored it a bit since then
17:49:48 <ski> (Jesin : s/tail :: a/tail :: Stream a/)
17:49:49 <Eduard_Munteanu> andres_: just like in runST.
17:49:50 <kevinburke> and got Kind error: `MultOp' is applied to too many type arguments
17:49:53 <Eduard_Munteanu> :t runST
17:49:54 <lambdabot> forall a. (forall s. ST s a) -> a
17:50:33 <conal> i wonder: was the Monad interface messed up into the current version in order to accommodate imperative programmers?
17:50:38 <edwardk> jesin: http://hackage.haskell.org/packages/archive/comonad/1.0/doc/html/Control-Comonad.html
17:50:59 <ski> conal : the argument in favor of `ma >>= amb' is that typically `amb' is a larger expression than `ma'
17:51:05 <edwardk> conal: it is easy to read, nicely infixes, and logically helps you follow control flow
17:51:08 <Jesin> I can kind of understand
17:51:27 <Jesin> why the Functor Applicative Monad hierarchy hasn't been put in the language yet
17:51:31 <Jesin> (it would break code)
17:51:33 <Jesin> bt
17:51:34 <Jesin> *but
17:51:43 <Jesin> I don't get why join is outside the Monad typeclass
17:51:47 <ski> (hence me possibly wanting `(>>=)' to take arguments in opposite order, while keeping the `ma >>= amb' order in infix use)
17:51:53 <edwardk> jesin: meh, its only getting worse. and i wind up having to write roughly 2-3x as much code as i would otherwise coz its not there.
17:51:54 <Eduard_Munteanu> Jesin: technically it shouldn't.
17:51:58 <hpc> Jesin: indeed, and putting that inside wouldn't break anything
17:52:09 <hpc> dunno why that hasn't
17:52:14 <Eduard_Munteanu> Being outside it means you can't just specify the monad in the CT way.
17:52:26 <Jesin> so
17:52:39 <Jesin> the rest of the Functor hierarchy proposal doesn't get implemented yet, but
17:52:41 <Jesin> ...
17:52:46 <Jesin> oh wait.
17:52:51 <andres_> Eduard_Munteanu: thanks
17:52:56 <Jesin> Monad isn't required to have fmap.
17:53:06 <Jesin> riiiight.
17:53:22 <Jesin> they should put liftM inside it too then
17:53:24 <Jesin> :p
17:54:04 <edwardk> honestly the functor hierarchy is one of the reasons why i stopped writing so much haskell, it was just such a pain in the ass to work around with all these WrappedFoo types
17:54:44 <Eduard_Munteanu> andres_: well, ignore the rank-2 there though. The idea is having 's' (and always the same 's') appear in the type ensures the types match. As in ST s (STArray s a).
17:54:59 <edwardk> i sadly have many thousands of lines of code duplication because some folks don't want to write 2 lines here and there.
17:55:10 <ski> Jesin : imo, they should put `instance Functor m' inside of `class Functor m => Monad m' ;)
17:55:11 <edwardk> and in some cases can't even give the general construction
17:56:02 <Jesin> class Monad m where
17:56:03 <Jesin>   return
17:56:05 <Jesin>   liftM f m = m >>= (return . f)
17:56:06 <Jesin>   join m = m >>= id
17:56:07 <Jesin>   m >>= f = join $ fmap f m
17:56:08 <Eduard_Munteanu> Another, simpler example might be stuff like maxBound, although I'm not sure it's part of the phantom type thingy.
17:56:12 <Eduard_Munteanu> :t maxBound
17:56:12 <lambdabot> forall a. (Bounded a) => a
17:56:19 <augur> hm
17:56:24 <Jesin> ski: I agree with this
17:56:29 <augur> ski: sorry can you explain the p => t stuff again/
17:56:32 <Jesin> it would break code though so people don't wanna do it
17:56:34 <Eduard_Munteanu> Effectively you supply a value it isn't use to get out the bound of the underlying type.
17:56:39 <augur> or link me so i dont have to bug you? :p
17:56:43 <Jesin> Augur: it's a type restriction
17:56:45 <Eduard_Munteanu> *used
17:56:52 <Jesin> it basically says "p has to hold"
17:57:07 <Jesin> before you're allowed to supply an instance
17:57:11 <augur> Jesin: yeah i know, and i get how its used, i just want to know more about the formal aspects of it
17:57:11 <edwardk> jesin: the break code complaints have largely relaxed. it is just the 'causes us more code' people who seem to still be bitching
17:57:12 <Jesin> of whatever the new thing is
17:57:17 <Jesin> ah, ok
17:57:23 <ski> augur : compare with `maximum :: Ord a => [a] -> a' .. if `Ord a' isn't true, then you can't use the operation `maximum' .. simple as that
17:57:31 <Jesin> ...what
17:57:35 <augur> like, a :: p => t isnt merely t, its t contingent on p holding, but if p _doesnt_ hold what does that mean
17:57:41 <Jesin> but "causes us more code"
17:57:43 <Jesin> but
17:57:44 <augur> ski: no no i know that :p
17:57:49 <Jesin> that's an argument in both directions
17:57:53 <edwardk> jesin: exactly
17:57:55 <ski> augur : if `p' doesn't hold, then you can't use `a' as having type `t' .. just that
17:58:14 <ski> augur : so if `a' is a rule, this means that you can't apply the rule in that case
17:58:19 <Eduard_Munteanu> ski: what's the argument here, is it like '=>' is a second/higher-order implication?
17:58:21 <augur> ski: i just mean, if Ord doesnt hold, does that cause a type error, and if so, why? is it because maximim with ~ Ord a is of type Bottom, and bottom has no inhabitants so its a type error
17:58:27 <edwardk> jesin: in my case i can point to many thousands of lines. in their case, people can point to a half dozen lines here and there. i think the burden of proof falls that way ;)
17:58:28 <ski> Eduard_Munteanu : more or less, yes
17:58:46 <augur> how is the unable-to-apply cached out in type terms
17:58:49 <kmc> @seen Cale
17:58:49 <lambdabot> Unknown command, try @list
17:58:49 <preflex>  Cale was last seen on #haskell 14 hours, 53 minutes and 28 seconds ago, saying: For linear algebra, Roman's book is exceptional, but is aimed at graduate students.
17:58:53 <edwardk> jesin: i am perfectly willing to refactor mine to remove the painful redundancy
17:58:59 <kmc> preflex, seen RyanT5000
17:59:00 <preflex>  RyanT5000 was last seen on #haskell 112 days, 9 hours, 26 minutes and 55 seconds ago, saying: what is ghci's ":print" based on?
17:59:15 <copumpkin> kmc: he was here a couple of days ago
17:59:16 <Eduard_Munteanu> I also think of instances as proofs and classes as theorems.
17:59:16 <Jesin> ...waaargh, the monad-comonad duality is trippy
17:59:19 <augur> because i presume there's a reason its a type constraint for a reason, as opposed to like p => a :: t
17:59:20 <augur> or something
17:59:21 <kmc> which copumpkin?
17:59:23 <copumpkin> preflex: seen ryant5000_
17:59:23 <preflex>  ryant5000_ was last seen on #haskell 1 year, 230 days, 21 hours, 42 minutes and 49 seconds ago, saying: ah
17:59:27 <copumpkin> preflex: seen ryant50000
17:59:28 <preflex>  Sorry, I haven't seen ryant50000
17:59:35 <copumpkin> hmm, I could've sworn I saw him here a couple of days ago
17:59:39 <kmc> odd
17:59:58 * kmc is wondering what the situation with iPwn is
18:00:09 <kmc> especially whether they got my Android GHC stuff and had time to review it
18:00:47 <copumpkin> preflex: seen ryant50001
18:00:48 <preflex>  ryant50001 was last seen on #haskell 2 days, 22 hours, 43 minutes and 44 seconds ago, saying: ddarius: ah, yeah, i know the semantics are different (_|_ versus (_|_, _|_), and all that); i'll have to figure out the performance at some point, as that's very important to me
18:00:53 <copumpkin> there we go
18:00:56 <ddarius> ski: SHE can do something like: class Monad m where { ...; instance Functor m where fmap = liftM }
18:01:31 <Jesin> SHE=?
18:01:57 <edwardk> thats what SHE said
18:02:00 <kmc> @where she
18:02:00 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
18:02:15 <ski> augur : not `Bottom' .. i suppose you *could* see it as having type `Top'/`()' .. so there's only one (uninteresting) value, in case `Ord a' is false
18:02:16 <Eduard_Munteanu> ski: though I'd rather think of '(Class a) => a -> b' as 'forall a. C a -> b', just as in logic where you stipulate theorems holding just for _some_ (specific) 'a'.
18:02:24 <ski> edwardk : well, the question is more like how many lines in other third party code would need to also change, if their code changed ..
18:02:25 <Jesin> by the way
18:02:38 <edwardk> every time i see the name strathcylde haskell enhancement i always see conor standing there saying it like the announcer in the enzyte commercials
18:02:44 <ski> (edwardk : .. though i think you're probably right, anyway)
18:02:47 <kmc> hahaha
18:02:51 <Eduard_Munteanu> So on a higher order C :: a -> Bool
18:02:52 <augur> ski: or that. are you sure? i mean, wouldnt you want it to be undefined, and thus bottom?
18:03:17 <Jesin> http://www.haskell.org/haskellwiki/Class_system_extension_proposal <-- how about this, for the people who are complaining about "too much code"
18:04:06 <edwardk> jesin: i would kill to see some variation on those extensions implemented.
18:04:21 <Jesin> who would you kill  :P
18:04:24 <ddarius> edwardk: But would you hack?
18:04:31 <Jesin> ^ better question
18:04:46 <edwardk> jesin: probably one of the people on the other side of the functor superclass of monad debate ;)
18:04:49 <ski> augur : imo, `p => a :: t' and `a :: p => t' is more or less the same thing .. cf. `forall a. length :: [a] -> Int' vs. `length :: forall a. [a] -> Int'
18:05:08 <ski> ddarius : oh, that looks as it could be what i was thinking of .. ty
18:05:21 <augur> ski: ok. so its not so much necessary to think of it as a type constraint so much as simply a constraint wherever
18:05:49 <Eduard_Munteanu> A set and an associated belongs_to map?
18:06:35 <ski> augur : yeah, and types/formulae is where we typically attach them, at least when we want to be able to nest them inside other types/formulae
18:06:44 <ddarius> edwardk: I like section 2 of that: "Explicit import/export of instances" with no discussion of ramifications.
18:06:52 <augur> ski: ok so that brings me back to the question of types; should they be implicit like in haskell, or explicit like in Martin-Loef? the proof system _does_ have syntactic unification, so inference like stuff is (i think?) entirely possible in the explicit cases anyway
18:07:15 <Kaidelong> I'm not sure who proposed that
18:07:17 <ski> Eduard_Munteanu : i don't see how your `Class' and `C' are related .. that comment looks weird, imo
18:07:29 <ski> anyway, i need to leave now
18:07:35 <Kaidelong> but I can't help but think "Breadth-First Search" when it comes to the multiple-inheritance issue he pointed out
18:07:38 <Jesin> but, as far as I can tell
18:07:45 <Jesin> the "class system extension proposal"
18:07:47 <ski> sorry folks, you can have the priviledge of speaking to me another time
18:07:50 <ski> ;P
18:07:59 <Jesin> would allow you to make a Monad instance that defines return and (>>=)
18:08:00 <augur> :X
18:08:02 <augur> bye ski <3
18:08:09 * ski flees out fast
18:08:15 <Kaidelong> Jesin: we can already do that.
18:08:20 <Kaidelong> what it allows would be:
18:08:26 <Jesin> and then the Functor instance would just happen and get the default fmap
18:08:29 <Jesin> :p
18:08:34 <Kaidelong> you could have Monad as a subclass of Applicative (and Functor by extension)
18:08:40 <Kaidelong> without needing to explicitly define them, yes
18:09:37 * ddarius thinks of what he can do with some frozen vegetables, ground beef, and rice.
18:09:51 <ski> (ddarius : yeah, explicit import/export is dangerous, at least in general .. we sure want to keep coherence)
18:10:07 <Eduard_Munteanu> ski: C and Class are the same, I chose C because it looked like a second-order logic proposition.
18:10:22 <copumpkin> ddarius: a veggie, beef, and rice smoothie!
18:10:24 <Eduard_Munteanu> erm, predicate
18:10:27 <Jesin> btw, are there any problems with for example inlining, if you use typeclass methods instead of external functions?
18:10:45 <Jesin> I would think the compiler could infer types well enough to inline in most cases...
18:11:06 <Eduard_Munteanu> Jesin: you need specialize pragmas to inline
18:11:19 <Jesin> I thought SPECIALIZE was deprecated
18:11:22 <monochrom> put frozen vegetables in frozen array. unsafeThaw.
18:11:27 <Eduard_Munteanu> At least for external stuff.
18:11:46 * copumpkin slaps monochrom 
18:12:01 <monochrom> @slap monochrom
18:12:01 * lambdabot would never hurt monochrom!
18:12:06 <monochrom> hrm!
18:12:10 * copumpkin was just fooling around right next to the unsafeThaw# primop earlier today
18:12:18 * ddarius had the thaw step down.
18:12:20 <Jesin> and you would just use a RULE that says for example "join = concat"
18:12:27 <Jesin> though
18:12:34 <Jesin> there's no reason to *have* concat
18:12:35 <copumpkin> ddarius: like mubarak?
18:12:36 <Jesin> :p
18:12:38 <Jesin> hmm
18:12:44 <monochrom> hahaha
18:12:57 <Jesin> [21:26:42]	<Eduard_Munteanu>	Jesin: you need specialize pragmas to inline
18:12:58 <jmcarthur> ideally join would just be a part of the Monad class
18:12:59 <Jesin> whyyy
18:12:59 <Eduard_Munteanu> Erm, deforestation rules aren't the same thing as specialization rules
18:13:14 <Jesin> jmcarthur: yes, that's how the whole discussion got going
18:13:17 <copumpkin> jmcarthur: BUT ZOMG EFFICIENCY!!! WE'LL  BE CARRYING AROUND AN EXTRA POINTER WITH US!!11!!1!! OMGWTFHAX
18:13:27 <Jesin> ...
18:13:29 <Jesin> wat
18:13:36 <Jesin> ok the way join is done NOW
18:13:37 <jmcarthur> don't most dictionaries get compiled out anyway?
18:13:46 <Eduard_Munteanu> Jesin: because typeclass functions can get any type.
18:13:47 <copumpkin> jmcarthur: I didn't think so
18:13:49 <Jesin> you're just carrying around whatever "extra pointer" that would be with >>=
18:13:50 <Jesin> :p
18:13:53 <ddarius> jmcarthur: It doesn't matter.  They get copied by reference.
18:13:55 <Eduard_Munteanu> It's akin to the vtable problem in OO languages.
18:14:12 <ddarius> Eduard_Munteanu: Only not as bad.
18:14:28 <ddarius> Which is to say, the vtable "problem" is already a non-issue.
18:15:09 <monochrom> join will join the monad class.
18:15:25 <Jesin> ooh that sounds refreshingly definite
18:15:29 <Jesin> is it?  :p
18:15:36 <copumpkin> of course not
18:15:37 <monochrom> just pun
18:15:47 <copumpkin> first we have yaks to shave and then we need to decide what color to paint the shed
18:15:48 <monochrom> should join join the monad class?
18:16:00 <copumpkin> and then everyone will argue about the color so much that nobody will remember what they wanted to do
18:16:16 <ddarius> copumpkin: They wanted to argue about color.
18:16:20 <monochrom> they wanted to learn haskell. I remember.
18:16:22 <ddarius> Seems easy enough to remember.
18:16:56 <monochrom> also we should use green for comments
18:18:21 <tlorenz> anyone know a ready reactive gui framework for haskell?
18:18:52 <tlorenz> I looked at grapefruit a bit, but it seems like nothing is quite there yet
18:20:04 <ddarius> tlorenz: I had one that was going to revolutionize everything, but then I ran out of space in the margin of my notebook.
18:20:26 * hackagebot comonad-transformers 1.5.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.0 (EdwardKmett)
18:20:45 <edwardk> roconnor: there ya go, pos, seek, peek til you go blue
18:20:50 <tlorenz> sorry to hear that
18:21:52 <kmc> edwardk, not sremrofsnart?
18:22:01 <kmc> rolls off the tongue
18:22:31 <tlorenz> so nothing that is ready to go yet? - I don't do gui the "non-haskell way" e.g. gtk+
18:25:20 <edwardk> kmc: sounds good. i'll change it now
18:25:22 <ddarius> tlorenz: Yampa is the most mature.
18:25:45 <ddarius> Hmm.  It smells like glue randomly...
18:25:54 <tlorenz> ddarius: thnx I'll look it up - it is reactive right (no IO)?
18:26:10 <copumpkin> tlorenz: he isn't lying
18:26:12 <edwardk> yampa makes me throw up in my mouth a bit, but it gets the job done
18:26:15 <copumpkin> he really did run out of space in the margin of his notebook
18:26:16 <accel> besides the haskell source code, what's the best documentation of various compiler transformations?
18:26:26 <copumpkin> and quite a notebook it is
18:27:10 <tlorenz> ddarius: found the website - looks like what I was looking for 
18:27:12 <kmc> "haskell source code"?
18:27:19 <edwardk> roconnor: the only problem with the pos name is that 'gets' has a crappy name 'poss'
18:27:50 <edwardk> otoh, i guess gets is kinda silly in comonad land
18:27:54 <tlorenz> edward: what's not nice about yampa?
18:28:06 <edwardk> tlorenz: it has arrows sticking out of it everywhere.
18:28:22 <tlorenz> edwardk: ?
18:29:07 <edwardk> tlorenz: its arrow based frp. this makes it hard to write code that changes the shape of computation based on what has come before but helps it avoid leaking memory like a sieve like other frp frameworks
18:29:19 <bos> edwardk: do we have a handy semilattice class anywhere?
18:29:30 <copumpkin> man, so many semilattices today
18:29:41 <edwardk> bos: i might have one in an old version of monoids, not sure. checking
18:29:42 <copumpkin> bos: I don't think so
18:30:00 <copumpkin> bos: unless you count the "lattice" class in Hoopl :)
18:30:07 * bos needs a join semilattice for the riak client
18:30:08 <copumpkin> but that carries a string with it too
18:30:13 <bos> really, using Monoid is cheating
18:30:20 <copumpkin> yeah
18:30:21 <tlorenz> edwardk: gotcha
18:30:24 <copumpkin> it's closer to a semigroup if anything
18:30:28 <edwardk> bos: it looks like all my lattice code was written in actual applications not in libraries =/
18:30:32 <edwardk> bos: monoid ftw ;)
18:30:35 <bos> edwardk: ah
18:30:50 <bos> copumpkin: sort of
18:30:55 <edwardk> yeah you can use my semigroups library =)
18:30:59 <copumpkin> it's a commutative idempotent semigroup
18:31:14 <bos> edwardk: i just might!
18:31:19 * ddarius agrees with edwardk re throwing up.
18:32:00 <edwardk> bos: plus there are all sorts of things built on semigroups now. take a look at semigroupoids and the Data.Semigroup.Traversable and Data.Semigroup.Foldable classes
18:32:14 <bos> edwardk: it's a bit underdocumented?
18:32:21 <edwardk> bos: that lets you apply it over containers of at least one member
18:32:40 <edwardk> bos: semigroups? well, there is an associative law, whats to document? =) i'll add some docs though
18:32:52 <bos> edwardk: not clear what the Option newtype is for
18:33:13 <edwardk> bos: its Maybe with a better monoid instance
18:33:27 <ddarius> It's the left adjoint to the obvious functor Monoid -> Semigroup.
18:33:37 <ddarius> (or at least I assume that's what it is without looking)
18:33:56 <edwardk> bos: the monoid instance for maybe is stupid it lifts a monoid into a monoid by using Nothing for empty and just never uses the underlying Monoid. but what it really wants to do is lift a SEMIGROUP into a monoid
18:34:12 <edwardk> er never uses the underlying monoid's mempty
18:34:25 <edwardk> so to use the existing monoid instance for maybe you have to make a broken monoid instance first.
18:34:41 <bos> ah
18:34:55 <edwardk> Option lets you factor that out by lifting a semigroup into a monoid by adding Nothing as a unit. 
18:35:13 <edwardk> this lets me use the shinier First and Last and Min and Max semigroups which aren't monoids
18:35:22 <copumpkin> bos: what do you need it for in riak? some way of having multiple nodes agree on something?
18:35:24 <edwardk> and lift them into monoids with Option (First a), Option (Max a), etc.
18:35:32 <bos> copumpkin: precisely.
18:35:37 <edwardk> or if a is Bounded, you can use the Max a monoid directly
18:35:52 <edwardk> bos: i really need to port my paxos code to haskell
18:35:53 <ddarius> bos: Would Conal's improving values make sense?
18:35:56 <bos> copumpkin: if two different nodes try to store a value, they will be told there's a conflict, and have to resolve it
18:36:06 <bos> ddarius: i haven't looked to tell
18:36:22 <copumpkin> yeah, I'd like to have a semilattice typeclass (don't really care whether we call the operation meet or join, as algebraically I don't think there's much of a difference)
18:36:44 <edwardk> copumpkin: clearly you need both meet and join semilattices so you can build lattices on top ;)
18:36:56 <copumpkin> well :P
18:36:59 <bos> copumpkin: so right now i'm using Monoid, but that's just wrong, because i (a) don't need a unit, and (b) the "agree on a new value" operation must commute (hence semilattice)
18:37:12 <copumpkin> and be idempotent!
18:37:19 <bos> i see a lattice package
18:37:29 <bos> i looked at the numeric prelude, and barfed, and looked away again
18:37:33 <copumpkin> lol
18:37:50 <bos> it tries to be better than prelude, but it's just more complex
18:38:12 <edwardk> the problem with the numeric prelude is that it has been henning'd. you can't find anything in it coz everything is named T and C.
18:38:19 <conal> bos: i have lub and glb on haskell values.  and information-ordered (definedness-ordered) lattice.
18:38:21 <bos> edwardk: right
18:38:29 <bos> conal: oh?
18:38:32 <copumpkin> granted, I think someone finally pushed a patch to haddock that will show qualified names
18:38:37 <copumpkin> not sure if henning has been informed
18:38:56 <ddarius> copumpkin: Why would he need to be informed?
18:39:05 <copumpkin> I think he's the only one who cared
18:39:30 <ddarius> copumpkin: And yet he's the person whose behavior is least likely to change due to it.
18:39:39 <ddarius> Other than, I guess, complaining less.
18:39:46 <Jesin> we should have more typeclasses in the standard library
18:39:48 <copumpkin> :P
18:39:54 <Jesin> and they should be better integrated
18:40:03 <Jesin> semigroup for example
18:40:10 <copumpkin> Jesin: I'm wary of using typeclasses for data structures though
18:40:18 <copumpkin> but yeah, I wouldn't mind having some common algebraic structures in there
18:40:18 <Jesin> hm?
18:40:44 <Jesin> also we should do this http://www.haskell.org/haskellwiki/Class_system_extension_proposal
18:40:45 <roconnor> edwardk: is seek defined as peek composed with duplicate?
18:40:47 <Jesin> :p
18:41:13 * copumpkin is writing a haskell package with a c part called piggie
18:41:32 <edwardk> roconnor: yeah
18:41:43 <ddarius> copumpkin: ... (?)
18:41:44 <edwardk> roconnor: similarly seeks is defined in terms of peeks
18:41:58 <edwardk> and peeks has a default definition in terms of peek and pos, so all an instance needs is peek and pos
18:42:15 <copumpkin> ddarius: I finally got back to that libopcodes binding I was talking about back in the day, and have a "piggie in the middle" dealing with the ugliness of libopcodes and in particular its varargs callback
18:42:23 <edwardk> which means i can gut the complexity of comonads-fd's store class, since i don't have to special case all of them any more.
18:42:28 <copumpkin> I couldn't be bothered to come up with a more meaningful name for it
18:42:50 <ddarius> copumpkin: "Back in the day" was like a couple of weeks ago.  Unless you mean you got back into it a couple of weeks ago from further back in the day.
18:43:05 <copumpkin> yeah, a couple of weeks ago ;)
18:43:41 * ddarius thinks his fibration article will come out well if he ever finishes it.
18:43:46 <roconnor> edwardk: heh, isn't that inefficent?
18:44:04 <edwardk> roconnor: its admitted as a default definition. the class provides all 5 functions
18:44:15 <roconnor> :O
18:44:24 <joe6> anyone used atom?
18:45:37 <conal> @hackage lub -- for bos
18:45:37 <lambdabot> http://hackage.haskell.org/package/lub -- for bos
18:45:40 <edwardk> roconnor: plus they are flagged to inline, so the default definitions of lowerFoo should inline away for the most part
18:45:47 <roconnor> ya
18:46:00 <roconnor> edwardk: duplicate is a coalgebra
18:46:02 <conal> bos: might not be what you're looking for.
18:46:32 * hackagebot comonads-fd 1.5.0 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.5.0 (EdwardKmett)
18:46:38 <bos> conal: thanks for the pointer
18:46:44 <copumpkin> ddarius: I look forward to it, if you ever finish it
18:46:55 <edwardk> roconnor: sure.
18:47:03 <ddarius> copumpkin: I think I actually will in a reasonable time.  I don't forsee any catches.
18:47:22 <roconnor> edwardk: and coalgebras for Store are lenses
18:47:29 <conal> bos: you bet.
18:47:31 <roconnor> edwardk: so duplicate is a lens for Store
18:47:35 <conal> dinner time. later, all.
18:47:38 <edwardk> roconnor: cute
18:47:47 <roconnor> edwardk: it lets you get and set the head
18:47:51 <roconnor> I presume
18:47:56 <roconnor> oh ya, it does
18:48:03 <edwardk> roconnor: sounds like a good comment for your paper ;)
18:48:04 <roconnor> I remember checking that it did
18:48:08 <roconnor> :)
18:48:09 <ddarius> I have another article I started long ago about... I'm not sure what 2-categories and homotopy I guess.  It's pretty great until the part where I don't want to go to ω-categories but I also don't really want to quotient.
18:48:36 <roconnor> ddarius: ω-categories is all the rage now with Univalent Foundations
18:49:25 <ddarius> The article is titled "Basic 2-Category Theory" but it's so pretty until one wants to actually stop at 2.
18:49:33 * hackagebot adjunctions 0.5.2.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.5.2.1 (EdwardKmett)
18:51:12 <joe6> is there any language that can build the source code, if you give it the tests that the sourcecode must pass?
18:51:26 <djahandarie> Should a ByteString uncons really be over 3x slower than a String uncons?
18:51:46 <edwardk> joe6: there are several little toy languages based on trying to inductively guess implementations from tests.
18:51:49 <djahandarie> ByteString.Char8 to be specific
18:51:59 <joe6> i know it is not haskell-specific, but given the users' experience on this forum, thought I might get some responses.
18:52:23 <joe6> edwardk: don't you think that something like that would be cool?
18:52:26 <edwardk> joe6: look up igorII off the top of my head: http://www.cogsys.wiai.uni-bamberg.de/aaip09/aaip09_submissions/porting.pdf
18:52:42 <edwardk> joe6: none of the conditions i am interested in testing are likely to be found by such a tool ;)
18:52:46 <joe6> edwardk: thanks.
18:53:03 <edwardk> i know some folks using it for biology research though
18:53:21 <ddarius> djahandarie: String uncons is do a case and build a tuple of the components of the (:) [in the (:) case].  ByteString uncons is do a case and maybe another case and a bit of calculation and then select the first byte and build a new bytestring header for the remainder.
18:54:31 <edwardk> they define the steady state of the cell, then model it based on observations after state transitions caused by environmental effects, given the fact that metabolic pathways must be in balance on a microsecond basis because gene expression takes time, etc. then they try to induce to find what transitions occurred, and how those must be expressed in the genes, etc.
18:55:11 <ddarius> So the basis of my article on 2-categories is taking the example of a space of points with the points as objects and the arrows paths as the motivating example.  It's makes the constructions very concrete and intuitive, and it teaches homotopy as a side benefit.
18:55:25 <ddarius> Quotienting = abstraction
18:55:54 <djahandarie> Hm
18:56:05 <Eduard_Munteanu> ddarius: is that somewhere online?
18:58:04 <copumpkin> see, this is why ddarius needs a blog, or a website of some sort! so we don't have to wait for the infrequent TMR releases
18:58:10 <edwardk> =)
18:58:21 <edwardk> ddarius-getting-a-blog++
18:58:35 * hackagebot semigroupoid-extras 0.2 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2 (EdwardKmett)
18:59:37 <edwardk> because you can never have enough semigroupoids
19:00:03 <copumpkin> your big diagram doesn't show the nice connection between apply and the *1s and semigroups though!
19:00:05 <Eduard_Munteanu> Ah, so it's on the Monad Reader?
19:00:11 <Jesin> wait what
19:00:12 <copumpkin> Eduard_Munteanu: nope
19:00:13 <Jesin> semifunctor
19:00:15 <Jesin> what's a semifunctor
19:00:16 <edwardk> copumpkin: sadly
19:00:22 <Eduard_Munteanu> Hrmpf.
19:00:27 <edwardk> jesin: a functor that doesn't necessarily preserve identity arrows
19:00:44 <Jesin> oh
19:00:45 <edwardk> jesin: a semigroupoid is a category without requiring identity arrows
19:00:58 <edwardk> jesin: a semifunctor is a "functor" between semigroupoids
19:01:13 <Jesin> so it doesn't preserve fmap id = id
19:01:15 <Jesin> ?
19:01:16 <edwardk> in haskell this is useful because i can nicely define product semigroupoids
19:01:30 <edwardk> correct. but it does preserve fmap f . fmap g = fmap (f . g)
19:01:41 <ddarius> Eduard_Munteanu: It's incomplete and what is there is mostly in a (larger) notebook of mine.  I started making the diagrams in Inkscape, and they are somewhere on one of my two computers.  I don't know if I started translating the text.
19:01:52 <ddarius> Probably, as that's much less of a hassle than making the diagrams.
19:02:01 <roconnor> doesn't parametericy say that fmap id = id?
19:02:06 <edwardk> roconnor: no
19:02:22 <roconnor> ok
19:02:26 <bos> bleh, semilattice is too much work to worry about
19:02:29 <edwardk> data Foo b = Foo Int b —  fmap f (Foo i b) = Foo 0 (f b)
19:02:59 <edwardk> parametricity gives fmap f . fmap g = fmap (f . g) _given_ fmap id = id, but the fmap id = id law you have to check
19:03:24 <edwardk> bos: give in and call it a semigroup. i might even be talked into making an idempotent semigroup class just for you =P
19:03:44 <ddarius> edwardk: A "higher-order" parametricity that, I don't think has yet been fully justified, but it seems like it should be right.
19:04:05 <bos> edwardk:  :-)
19:04:22 <bos> edwardk: the commutativity part is important too
19:04:23 <gwern> hrm. anyone familiar with System.Random? it's unclear to me how I get a Bool with 2/3s probability
19:04:34 <edwardk> bos: greedy ;)
19:04:45 <bos> edwardk: that's me!
19:04:58 <edwardk> bos: gratz on the startup btw
19:05:06 <bos> edwardk: thanks!
19:05:08 <gwern> I could use randomR(1,10) and turn it into True if >=6, but that's not exactly 2/3s
19:05:36 <gwern> bos: I was wondering what machine learning algorithms you were planning on using; post didn't cover that iirc
19:05:36 <edwardk> gwern: why not (1,3) =P
19:05:41 <bos> gwern: you'll have to do some approximation like that
19:05:51 <gwern> edwardk: ...
19:05:56 <gwern> dammit
19:06:10 <ddarius> edwardk: But it's much more challenging with a coprime factor.
19:06:17 <edwardk> =)
19:06:57 <edwardk> er sorry (0,3)
19:07:11 <roconnor> gwern: IIRC given a stream of random bits it is impossible to get a 2/3 biased coin with a finite number of bits.
19:07:13 <edwardk> those closedness of the interval is unfortunate
19:07:19 <roconnor> ... I guess that is kinda obvious
19:07:27 <edwardk> but inevitable, as roconnor points out
19:07:55 <roconnor> gwern: but you can get 2/3 biased coin if you are willing to recast and possibly take unbounded time.
19:08:18 <gwern> roconnor: well, yeah, but I could hope that under the cover it'd be equivalent to an approximation like 1,100000 and then conditionalizing on > 66666 or wjayever
19:08:48 <roconnor> gwern: you can get arbitrarily close to 2/3 in bounded time.
19:08:53 <gwern> roconnor: as opposed to specifying the approximation myself
19:09:11 <bos> wow, iteratees and enumerators are all over the place these days
19:09:18 <edwardk> bos: yeah
19:09:35 <bos> not sure what i think about that
19:09:39 <edwardk> the space usage of parsec was so bad that they exploded ;)
19:09:51 <monochrom> in soviet russia, oleg iterates you!
19:09:58 <bos> bloody difficult things to use
19:10:00 <edwardk> monochrom: in the type system
19:10:12 <edwardk> bos: btw- i ported attoparsec to scala at some point
19:10:12 <ddarius> edwardk: Parsec wasn't meant for shovelling data as fast as possible incrementally.
19:10:22 <edwardk> ddarius: just trolling. =)
19:10:29 <bos> edwardk: neat
19:10:54 <bos> edwardk: i ended up unwrapping the state inside attoparsec into explicit arguments. made the code much hairier, but it's faster.
19:11:02 <edwardk> bos: https://github.com/ekmett/scala-attoparsec/blob/master/src/main/scala/attoparsec/Parser.scala
19:11:51 <bos> edwardk: neat!
19:12:01 <edwardk> it is pretty much a literal port, though the parser combinators do provide a bit more backtracking via their toString's
19:12:11 <edwardk> er a bit better tracking of where you went wrong
19:12:54 <edwardk> i wrote it in a fit of pique over how annoying it was to extend the main packrat parser they have
19:13:21 <co_dh> Happy new year, guys. Chinese new year tomorrow :)
19:13:42 <Pseudonym> Happy Lunar New Year to you, too.
19:13:58 <co_dh> Pseudonym :) 
19:14:00 <Pseudonym> And since I missed it out, Happy Gregorian New Year for a month ago.
19:15:07 <monochrom> onoes, someone else knows about chinese new year :)
19:16:42 <ddarius> monochrom: Don't worry.  It's just you, Pseudonym, co_dh, and a couple billion others.
19:17:04 <co_dh> lol
19:17:25 <co_dh> I believe Mantee knows too.
19:17:37 <Maxdamantus> When someone says "IO monad", does it refer to the set of types `IO a` or the value of `main`, or any value of type `IO a` or ..?
19:18:05 <copumpkin> it refers to IO and a couple of functions attached to it through the Monad instance
19:18:16 <copumpkin> the IO type constructor, that is
19:18:28 <Jesin> @kind IO
19:18:29 <lambdabot> * -> *
19:18:36 <Jesin> @kind IO String
19:18:37 <lambdabot> *
19:18:45 <Jesin> @kind String
19:18:45 <lambdabot> *
19:18:47 <Jesin> :p
19:19:03 <Maxdamantus> Hm. Odd.
19:19:16 <monochrom> scala-attoparsec? blasphemy! I mean awesome!
19:20:36 <monochrom> you have "instance Monad IO where" not "instance Monad (IO a) where" so "IO monad" really refers to just IO.
19:21:09 <Maxdamantus> Ah. That makes sense then.
19:23:17 <Jesin> :t (<*>) `asTypeIn` \(<*>) -> (<*>) (x :: IO String)
19:23:18 <lambdabot>     Couldn't match expected type `IO String'
19:23:18 <lambdabot>            against inferred type `Expr'
19:23:18 <lambdabot>     In the first argument of `(<*>)', namely `(x :: IO String)'
19:23:28 <Jesin> :t (<*>)
19:23:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:23:36 <Jesin> :t (<*>) `asTypeIn` \(<*>) -> (<*>) (undefined :: IO String)
19:23:37 <lambdabot>     Couldn't match expected type `a -> b'
19:23:37 <lambdabot>            against inferred type `[Char]'
19:23:37 <lambdabot>       Expected type: IO (a -> b)
19:23:56 <Jesin> :t (<*>) `asTypeIn` \(<*>) -> (<*>) (undefined :: IO (()->()))
19:23:56 <lambdabot> IO (() -> ()) -> IO () -> IO ()
19:24:15 <Jesin> :t (<*>) `asTypeIn` \(<*>) -> (<*>) (undefined :: IO (String -> Integer))
19:24:16 <lambdabot> IO (String -> Integer) -> IO String -> IO Integer
19:24:20 * Kaidelong wonders what he is looking at
19:24:37 <Jesin> @src ap
19:24:37 <lambdabot> ap = liftM2 id
19:24:43 <Jesin> @src liftM2
19:24:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:24:44 <Kaidelong> oh someone discovered the FUN in applicative FUNctor
19:24:49 <dibblego> @type (<*>)
19:24:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:25:45 <Jesin> @unpl do { x1 <- m1; x2 <- m2; return (x1 x2) }
19:25:45 <lambdabot> do { x1 <- m1; x2 <- m2; return (x1 x2)}
19:25:50 <Jesin> @pl do { x1 <- m1; x2 <- m2; return (x1 x2) }
19:25:50 <lambdabot> (line 1, column 4):
19:25:50 <lambdabot> unexpected "{"
19:25:50 <lambdabot> expecting variable, "(", operator or end of input
19:25:55 <Jesin> ...right.
19:26:03 <djahandarie> undo it first
19:26:06 <Jesin> I should probably be doing this in privmsg
19:26:35 <djahandarie> @. pl undo do { x1 <- m1; x2 <- m2; return (x1 x2) }
19:26:35 <lambdabot> (m2 >>=) . (return .) =<< m1
19:26:51 <co_dh> Jesin: doesn't matter, as least I learned from what you typed.
19:26:52 <Jesin> what's @.
19:26:56 <Jesin> oh
19:26:58 <Jesin> undo
19:27:00 <Jesin> I didn't know that
19:27:09 <djahandarie> @. composes two lambdabot commands.
19:27:09 <lambdabot> Plugin `compose' failed with: Unknown command: "composes"
19:27:10 <Jesin> @undo do { x1 <- m1; x2 <- m2; return (x1 x2) }
19:27:10 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (x1 x2)
19:28:21 <Jesin> asTypeIn = const :: a -> (a -> b) -> a
19:28:30 <Jesin> asTypeOf = const :: a -> a -> a
19:28:44 * Jesin learned this earlier today
19:28:56 <Maxdamantus> :t const
19:28:56 <lambdabot> forall a b. a -> b -> a
19:29:24 <co_dh> Is Yonada lemma useful  for programmer ?  I have trouble to understand that lemma.  
19:29:45 <Jesin> @src const
19:29:45 <lambdabot> const x _ = x
19:29:47 <Jesin> :p
19:31:05 <Jesin> @src seq
19:31:05 <lambdabot> Source not found. There are some things that I just don't know.
19:31:09 <Jesin> hmm
19:31:15 <Jesin> I think seq could be defined as
19:31:29 <Jesin> seq !x = id
19:31:44 <monochrom> yes
19:32:05 <Jesin> are bang patterns part of the language spec btw
19:32:09 <Jesin> or is that a GHC thing
19:32:09 <Axman6> no
19:32:10 <monochrom> no
19:32:21 <monochrom> not in language spec. ghc thing.
19:32:23 <Jesin> k
19:32:57 <Jesin> ~ is in the spec though?
19:33:15 <monochrom> but ! in "data X = C !a" is in the language spec, and you can use that to get seq
19:33:21 <monochrom> ~ is in the spec
19:33:39 <Axman6> how can you use ! in data to get seq?
19:33:40 <monochrom> oops data X = C !Int
19:33:56 <Jesin> or even just
19:34:03 <Jesin> data X a = C !a
19:34:16 <Jesin> yes?
19:35:04 <Axman6> i guess if you write seq as say... data X a = C !a | N, and have seq as something like seq a b = case C a of C a -> b, that might do it
19:35:25 <Axman6> thinking that you'd need to pattern match on the constructor to avoid ...something...
19:35:32 * Axman6 needs more/less sleep
19:36:07 <Jesin> umm
19:36:09 <Jesin> why the |N
19:36:26 <Jesin> the only | N we need here is _|_
19:36:28 <Jesin> :p
19:38:12 <ddarius> co_dh: Yes.
19:38:38 <co_dh> ddarius: do you have an example of Yonada in haskell?
19:39:24 <ddarius> co_dh: Talk to edwardk.
19:39:50 <ddarius> co_dh: That said.  The proof of Yoneda is very simple and even more simple in Haskell.
19:51:03 <copumpkin> how can I use the FFI to export a function as a FunPtr to be called back by C code?
19:52:41 <ddarius> foreign export dynamic ?
19:53:49 <copumpkin> looks promising!
19:56:27 <accel> typeclases -- how do they differ from a C++ purely abstract iheritance ?
19:56:58 <accel> in fact, is "typeclass" anything more than saying "anything that derives from this typeclass must support the following functions" ?
19:58:07 <copumpkin> accel: first of all, there isn't always just one receiver, and it may not be an input to the function
19:58:15 <copumpkin> read for example is polymorphic on its return value
19:58:25 <copumpkin> there are multiparameter typeclasses that cover more than one type
20:01:42 <Jesin> also I'm pretty sure C++ doesn't do transformer classes  :p
20:02:44 <accel> Jesin: link on transformer clases?
20:02:54 <accel> Jesin: not sure what to read from Google's results
20:03:04 <accel> Jesin: transformers or Monad Transformers ?
20:03:04 <Gulanzon> List comprehensions basically read right to left, yes?
20:03:39 <copumpkin> oh wait
20:03:42 <Gulanzon> um, and hello everyone :)
20:03:43 <copumpkin>  the foreign export dynamic didn't work
20:04:01 <mafs> From where can I get lambdabot source? Was going to write a plugin for it, but darcs get http://code.haskell.org/lambdabot isn't working.
20:04:03 <Jesin> monad transformers, is what I was thinking
20:04:04 <Jesin> :p
20:08:39 <ddarius> @where ffi
20:08:39 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:12:03 <Jesin> @src head
20:12:04 <lambdabot> head (x:_) = x
20:12:04 <lambdabot> head []    = undefined
20:12:07 <Jesin> @src tail
20:12:07 <lambdabot> tail (_:xs) = xs
20:12:07 <lambdabot> tail []     = undefined
20:12:33 <Jesin> > tail []
20:12:33 <lambdabot>   *Exception: Prelude.tail: empty list
20:16:07 <Gulanzon> I guess my question was a bit vague
20:16:25 <Gulanzon> I'm reading Learn You A Haskell and I'm just trying to wrap my head around comprehensions inside comprehensions.
20:16:53 <Gulanzon> [ [ x | x <- xs, even x ] | xs <- xxs]  <- trying to translate this into English
20:17:35 <Axman6> for each list in xss, call it xs, and then for each element in xs, which is even, put it in a new list
20:17:49 <Gulanzon> It looks like, "take xs from whatever xxs is, then take x from xs, provided it's even, then spit it out"
20:18:06 <Axman6> so you give it a list of lists of numbers, and you end up with a list of lists of even numbers
20:18:14 <Jesin> @src sequence
20:18:15 <lambdabot> sequence []     = return []
20:18:15 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:18:15 <lambdabot> --OR
20:18:15 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:18:31 <Gulanzon> So logically it flows right to left, right?
20:18:46 <copumpkin> anyone know what happened to "foreign export dynamic" ?
20:18:56 <copumpkin> I can find old GHC docs that mention it existing and doing what I want
20:19:03 <copumpkin> but I just get a parse error these days
20:19:58 <Gulanzon> Cheers :)
20:20:49 <Jesin> @. undo src sequence
20:20:49 <Axman6> > (\xss -> [[x | x <- xs, even x] | xs <- xss]) [[1,2,3],[4,5,6]]
20:20:49 <lambdabot> ()
20:20:50 <lambdabot>   [[2],[4,6]]
20:21:15 <Jesin> @undo do v <- x; vs <- sequence xs; return (v:vs)
20:21:15 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
20:21:18 <accel> eval :: Expr a -> a
20:21:19 <accel>    eval (Mul e1 e2) = eval e1 * eval e2
20:21:19 <accel>    eval (Eq  e1 e2) = eval e1 == eval e2
20:21:25 <accel> how is that possible with algebraic data types?
20:21:32 <accel> since Eq can be applied to Int's too
20:21:54 <Axman6> well, that won't work, you need some constraints
20:22:01 <accel> http://en.wikibooks.org/wiki/Haskell/GADT
20:22:06 <accel> i'm looking at the section right under GADT
20:22:09 <accel> it looks like complete code
20:22:10 <Axman6> eval :: (Num a, Eq a) => Eval a -> a
20:22:13 <ddarius> copumpkin: The FFI should say what it is now.  You can definitely do what you want with the FFI.
20:22:14 <accel> i'm just baffled how it works
20:22:27 <ddarius> copumpkin: If GHC no longer implements the FFI, then something is horribly wrong.
20:22:33 <Axman6> ah, gadts might change things there
20:22:55 <accel> wtf is gadts
20:23:19 <Axman6> GADTs
20:23:39 <ddarius> There are several papers on how GADTs work.
20:24:22 <copumpkin> ddarius: I don't know where to find the "official" FFI addendum. The one on chak's site doesn't seem to mention import dynamic or export dynamic, so I feel it must be an earlier draft
20:24:30 <copumpkin> I don't think h2010 report is released yet is it?
20:24:39 <Axman6> hmm, in that example, i think Eq :: Expr a -> Expr a -> Expr Bool would work better
20:25:05 <accel> real question, not troll: how are haskell users acceptable with the fact that certain compiler transforms can change the big-OH space usage of a haskell program?
20:25:12 <accel> this seems _very_ distrubing
20:26:11 <copumpkin> accel: which transforms?
20:26:23 <Axman6> i really wonder why you haven't gone back to just using C++, you obviously can;t seem to see what's so good about haskell, and you only complain that it doesn't do things that C++ does
20:27:25 <comex> way to encourage people to try a new language
20:27:34 <copumpkin> comex: oh come on
20:27:53 <copumpkin> <accel> wtf is gadts
20:28:27 <accel> how is that not a serious question?
20:28:28 <comex> I said the same thing!
20:28:29 <Axman6> comex: accel has been complaining for days about haskell, after only just starting with it, without trying to learn how things are done on his own. and tbh, it's really starting to piss me off
20:28:33 <accel> I _still_ don't understand gadts
20:28:38 <comex> well, I'm just as bad, though
20:28:55 <Axman6> accel: no, because they;re a fairly advanced feature, and you still haven't learnt the basics of haskell
20:29:15 <copumpkin> accel: saying wtf are they isn't going to help you learn them. And asking loaded questions isn't going to make the people in here feel particularly inclined to help you learn
20:29:16 <accel> Axman6: it soudns like you're just jealous at the rate I'm absorbing haskell knolwedge
20:29:20 <Axman6> comex: i haven't seen anything you've said, but i'd be surprised if you are
20:29:29 <comex> okay, I changed my mind at that last comment :p
20:29:32 <copumpkin> accel: keep that up and you'll be absorbing knowledge elsewhere
20:30:08 * comex likes to intersperse his attempts to understand pieces of Haskell code with complaints about the language
20:30:13 <comex> sometimes they're even justified!
20:30:17 <copumpkin> comex likes to troll in general, but we love him
20:30:18 <accel> http://www.haskell.org/pipermail/haskell-cafe/2006-September/018447.html
20:30:22 <Axman6> accel: i don't believe you understand the basics of haskell well enough to be asking the questions you are
20:31:29 <accel> http://www.haskell.org/pipermail/haskell-cafe/2006-September/018447.html <-- -O causing O(N) space rather than O(1) space
20:31:42 <Axman6> accel: the fact that you can;t look at that code and see why it blows up in memory usage proves to me that you do not understand the basics of haskell
20:32:15 <accel> learning is the process of continuously finding shit you don't understand, then mastering it
20:32:31 <Axman6> accel: ghc is performing an optimisation that often produces good speedups, but can occasionally cause problems
20:32:31 <copumpkin> accel: wait, that isn't saying that
20:32:57 <Axman6> accel: the thing is, you don't understand the simple things you need to understand the more complex things you're asking about
20:33:29 <comex> as far as I can see, the issue is merely that a compiler transform doesn't *decrease* the space complexity
20:33:31 <Axman6> it's like trying to learn how to do double integrals without knowing how to integrate
20:33:50 <comex> last year I had to learn physics without knowing how to integrate
20:34:07 <copumpkin> accel: in fact, it seems to be wishing that GHC would do that automatically, but doesn't
20:34:14 <Axman6> comex: it's doable
20:34:17 <codolio> My entire high school physics course didn't use any calculus.
20:34:25 <copumpkin> same here
20:34:26 <accel> copumpkin: my bad; I meant to paste this: http://hackage.haskell.org/trac/ghc/ticket/917
20:34:27 <comex> well, I knew how to integrate, but the course didn't use calculus
20:34:28 <ddarius> copumpkin: You want foreign import wrapper.
20:34:34 <accel> copumpkin: that is the actual bug report; I pasted the wrong link
20:34:39 <comex> it's doable, but some of the fun parts are gone :p
20:34:50 <Axman6> comex: such as?
20:35:12 <copumpkin> accel: so a bug report by someone unrelated to GHC who wants that behavior, and people saying it's hard and that they won't do it?
20:35:15 <Jesin> @hoogle initlast
20:35:16 <lambdabot> No results found
20:36:12 <copumpkin> ddarius: where can I find the docs on that? the FFI seems very fragmented
20:36:15 <copumpkin> the spec of it
20:36:18 <Axman6> accel: how do you propose to fix that bug? you seem to know a lot more than most people, so how do we fix it?
20:36:25 <copumpkin> I can find one on sigbjorn's site, one on chak's, and they're both ancient
20:36:36 <comex> being able to derive various types of formulas rather than memorizing loads of them
20:37:02 <copumpkin> comex: you should take that webdesign course I suggested earlier!
20:37:31 <lispy> copumpkin: I assume you've already looked at the FFI addendum to the H98 report?
20:37:40 <ddarius> copumpkin: It hasn't changed.
20:37:43 <copumpkin> lispy: I'm trying to find a canonical place for it to be
20:37:49 <copumpkin> lispy: chak's site?
20:37:51 <accel> Axman6: it seems like we need to go down both last, i.e. the length & the last at the same time
20:38:11 <accel> Axman6: the fact this can be done in O(1) space relies on teh fact ath we only need to pass through the entire list once
20:38:19 <Axman6> accel: sure. but how can you turn that into a general optimisation that applies to more than just this situation?
20:38:21 <copumpkin> I'm going by http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3
20:38:22 <lispy> copumpkin: hmm...Now that's a good question.  I would have looked at the same site as the h98 report.  Let me google it.
20:38:32 <copumpkin> lispy: I'd have expected the same
20:38:43 <accel> Axman6: I'm actually not sure why list fusion wouldn't solve this
20:38:51 <comex> speaking of trolling
20:38:56 <Axman6> accel: the usual solution is to write something like the second initLast given there. it's the same with writing an average function
20:38:57 <copumpkin> accel: because it's about having one thunk update another
20:39:02 <accel> Axman6: it eppears that (1) length init and (2) last ... can both be solved thorugh 1 pass through the list
20:39:06 <comex> be happy that you're using a language that at least cares about speed
20:39:11 <comex> the other big functional language doesn't :p
20:39:16 <Axman6> accel: yes, but there's no optimisation that can see that
20:39:21 <copumpkin> comex: ocaml?
20:39:27 <comex> lisp
20:39:33 <copumpkin> but stalin scheme!
20:39:34 <comex> actually
20:39:35 <copumpkin> omg so fast
20:39:37 <lispy> copumpkin: this page is linked at the bottom of the page you linked: http://haskell.org/definition/
20:39:51 <lispy> copumpkin: it has an "official" link to the FFI addendum
20:39:53 <copumpkin> lispy: yeah, so chak's site
20:40:03 <comex> I don't even know what I'm talking about.
20:40:05 * comex needs to go to sleep
20:40:08 <copumpkin> but that addendum is ancient, and still mentions jvm and dotnet, and doesn't talk about dynamic
20:40:10 <Axman6> accel: if you want speed, you often have to write faster versions of things that could be written obviously. this is the same in any language.
20:40:14 <damex> is there are haskell syntax highlight for nano editor?
20:40:19 <lispy> copumpkin: Hmm
20:40:30 <lispy> copumpkin: Next stop is GHC source ;)
20:40:31 <copumpkin> ddarius: where'd you find the wrapper thing?
20:40:38 <Axman6> accel: for example, average xs = sum xs / fromIntegral (length xs) is obvious right?
20:40:46 <copumpkin> ddarius: it's currently just giving me a syntax error
20:41:05 <Axman6> accel: but,m if you try that on a long list, you'll see that it performs very bagly, with horrible space usage
20:41:28 <accel> Axman6: yeah; it can't gc the xs
20:41:48 <copumpkin> and isn't smart enough to see the two traversals can happen in parallel
20:42:10 <Axman6> accel: the common way to fix it is to define something like average xs = go 0 0 xs where go !s !n (x:xs) = go (s+x) (n+1) xs; go s n [] = s / fromIntegral x
20:42:18 <codolio> The answer to how Haskell programmers accept that fact is that the program in that bug report doesn't come up very often.
20:42:31 <codolio> GHC doesn't usually introduce space leaks.
20:42:42 <Jesin> and if it does
20:42:47 <lispy> copumpkin: did you find this?  It's old too: http://www.haskell.org/ghc/docs/6.6/html/users_guide/sec-ffi-ghc.html
20:42:48 <Jesin> you just do something to make it not do that
20:42:50 <Jesin> :p
20:42:52 <Axman6> accel: you'll notice that this is probably exactly the same way you'd write it if it were in C using a linked list (though, laziness isn't a factor there, but still)
20:43:41 <accel> Axman6: yeah; but the faster version breaks "composability"; i.e. instead of composing it out of a sum & a length; we now have to compute it separtaetly, which is slightly utly
20:43:45 <accel> s/utly/ugly
20:43:48 <copumpkin> lispy: aha, that worked
20:43:48 <codolio> And as Axman6 says, when you have a space leak in Haskell, the alternative in another language is that the same thing would never, ever work anyway.
20:43:53 <Jesin> umm
20:43:58 <copumpkin> lispy: seems unspecified by the addendum though?
20:44:03 <Jesin> accel, "composability" isn't really a thing
20:44:10 <Axman6> accel: fast code is often kind of ugly
20:44:15 <lispy> copumpkin: a more recent version of the same document: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/ffi.html
20:44:39 <Jesin> [23:59:51]	<Axman6>	accel: fast code is often kind of ugly
20:44:44 <Jesin> this seems language-independent
20:44:46 <Jesin> :p
20:44:46 <copumpkin> lispy: found that, but the wrapper thing is gone in that one
20:45:03 <Axman6> Jesin: it's ugly in C too
20:45:10 <Jesin> yes, that's what I just said
20:45:22 <Axman6> oh, right.
20:45:33 <ddarius> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-150004
20:45:34 <Jesin> sorry, I guess that could've been interpreted the other way
20:45:36 <lispy> hmm
20:45:47 <Axman6> Jesin: no, i just missed the 'in' :)
20:45:59 <Jesin> ah, ok
20:46:06 <lispy> copumpkin: Sorry, I mistook the function referred to as wrapper to be the "wrapper" you wanted.  Sorry Mario, but your wrapper is in another castle!
20:46:16 <copumpkin> :P
20:46:21 <copumpkin> anyway, it seems to be compiling now
20:46:25 <copumpkin> now I just get link errors
20:46:27 * copumpkin sighs
20:46:41 <lispy> Link errors?  I blame GNU LD
20:46:57 <lispy> Haskell doesn't need any stinking linkage
20:47:09 <copumpkin> :P
20:47:11 <copumpkin> I'm in osx
20:47:30 <lispy> Does OSX use it's own linker?  I thought they still used gnu ld, just patched
20:48:10 <shapr> What about using spigot algorithms in place of non-gc'able functions like that definition for average?
20:48:23 <lispy> shapr: Hiya.
20:48:33 <shapr> Is there a heuristic for transforming to spigot algorithms?
20:48:43 <ddarius> lispy: GHC has it's own linker...
20:48:44 <shapr> god morgon lispy!
20:49:04 <lispy> shapr: I thought you called me a moron for a second there :)
20:49:08 <shapr> haha
20:49:10 <copumpkin> lispy: nah, not gnu
20:49:15 <copumpkin> don't think
20:49:19 <shapr> lispy: that's what it sounds like too, "Hello my good moron!"
20:49:46 <lispy> copumpkin: see ddarius's comment.  GHC should be using gnu ld regardless, I Think
20:49:59 <copumpkin> GHCi has its own linker
20:50:13 <copumpkin> it still uses the system ld for compilation
20:50:26 <lispy> I know the windows ghc ships with it's own gcc/ld.
20:51:07 <Axman6> i wonder if you could write a fask linker in haskell
20:51:12 <lispy> Anyway, this is getting pretty far from the point.  And my fault for making a off-handed comment to blame gnu ld when you had a totally unrelated link error :P
20:51:12 <Axman6> fast*
20:51:23 <lispy> Axman6: memory efficient is important too
20:51:33 <Axman6> fasking linkers... how do they work?!?
20:51:35 <lispy> Axman6: gnu ld's algorithm really hates split-objs
20:51:37 <copumpkin> gah
20:51:39 <copumpkin> anyway
20:51:45 <copumpkin>   Extra-libraries:     opcodes, bfd
20:51:48 <copumpkin> it builds fine
20:51:54 <Axman6> lispy: sure, i'd be interested to see if you could write a fast and memory efficient linker in haskell
20:51:55 <copumpkin> then when I try to figure up ghci and test the module
20:52:02 <copumpkin> it complains about not being able to find a symbol that's in libopcodes
20:52:50 <lispy> Axman6: You know I bet you could.  Do you know what are the hard parts of linkers traditionally?  I'm guessing it's hard to test them due to the low level nature of it.  And possibly finding good documentation about all the cases you need to hit/cover might be hard?
20:53:02 <accel> Is it possible to write haskell compiler passes w/o hacking the ghc source?
20:53:10 <accel> Is it possible to write haskell compiler optimization passes w/o hacking the ghc source?
20:53:13 <Axman6> i know very little to nothing about linkers
20:53:19 <lispy> Axman6: it's certainly something I've wanted before...Having a good C tool chain written in Haskell
20:53:36 <copumpkin> accel: when GHC plugins are merged in (should be soon), yes, for some layers of the compiler
20:53:50 <lispy> copumpkin: oh, I hadn't heard about that.
20:53:50 <accel> copumpkin: so not even in 7.0 ?
20:54:03 <Axman6> lispy: if you're intertested, the guy who wrote the gold linker has some very interesting posts on what linkers do and how they do it
20:54:03 <lispy> copumpkin: is it anything like the plugin-api for GCC?
20:54:06 <copumpkin> accel: no, it isn't even merged into the repository yet
20:54:13 <copumpkin> lispy: no idea, haven't tried either :)
20:54:46 <lispy> copumpkin: some mozilla guy gave a talk about using javascript plugins with gcc on the moz project
20:54:55 <Jesin> as it is, it seems http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html and code-refactoring are most of what you can do
20:55:03 <accel> copumpkin: oh; where does it exist?
20:55:24 <copumpkin> accel: you'd have to ask thoughtpolice about that, or its original author max bolingbroke, who isn't usually on IRC
20:55:52 <lispy> copumpkin: basically, you specify a phase of gcc's compilation that you want to link into, the types you want access too and then write some code.  Often an AST traversal/transformation.  But you can also add new keywords and barf on them.  He gave a singleton example.
20:57:08 * edwardk returns
20:57:24 <accel> where can I get the haskell source? I only see binaries on http://www.haskell.org/haskellwiki/Haskell
20:57:25 <lispy> accel: To answer your question.  It really depends on what you're doing.  Template Haskell lets you do some code transformations at compile time, and there are also RULES pragmas that let you do some other transformations
20:58:05 <lispy> accel: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources?redirectedfrom=GhcDarcs
20:58:10 <accel> lispy: yeah; but for the problem mentioenda bove; solving it requies source, not just basic transforms
20:58:27 <lispy> accel: There is also a more recent git tree than the one at the bottom of that page but I'm not sure where it lives. You might check github
20:58:53 * copumpkin pures
20:58:56 <shapr> Axman6: Have you seen "gold" the next iteration of gnu ld?
20:59:11 <shapr> Axman6: I've only had it fail miserably once and I've been using gold in place of gnu ld for months.
20:59:18 <Axman6> shapr: I have, i mentioned it only minutes ago :P
20:59:19 <edwardk> shapr: for some definition of next iteration
20:59:21 <lispy> shapr: Axman6 just mentioned it to me :)
20:59:26 <shapr> oh
20:59:28 <shapr> oops
20:59:43 <edwardk> shapr: x86 only, etc. random limitations, etc.
20:59:44 <Axman6> the author's posts on linkers are really interesting
20:59:54 <edwardk> shapr: unless its come along since i last looked
21:00:00 <Axman6> there's also work i believe on an LLVM linker, might be wrong about that
21:00:01 <edwardk> i do love the idea though
21:00:12 <Axman6> edwardk: ELF only too
21:00:16 <Axman6> so, no mac love
21:00:23 <accel> http://www.haskell.org/ghc/download_ghc_7_0_1#sources <-- found it
21:00:24 <lispy> Axman6: if we had a linker in Haskell, I think I would shoot for correctness assurances instead of speed/space.
21:00:27 <edwardk> Axman6: yeah that was lumped in 'other limitations' ;)
21:00:32 <joe6> anyone used usb-safe?
21:00:50 <edwardk> at the level of linking i favor speed/space ;)
21:01:14 <joe6> i am using system.usb, but I am not sure about upgrading to usb-safe or not? it appears to be a big change.
21:01:36 <joe6> wondering if anyone has any experiences?
21:01:54 <accel> whoa, the entire ghc source is only 400K LOC ?
21:01:58 <lispy> edwardk: I think I do too for 99.99% of what I do, but then one argument against formal methods is often that the compiler/linker might have bugs and your executable can still have bugs.
21:03:13 <edwardk> fair nuff
21:03:34 <edwardk> lispy: needs vary by problem domain =)
21:03:53 <lispy> accel: here is the break down by language type and a comparison to gcc: http://blog.codersbase.com/2010/08/more-fun-pointless-code-metrics.html
21:05:09 <copumpkin> gcc is a monster
21:05:32 <shapr> copumpkin: but it mostly works, for just about any target...
21:05:33 <edwardk> gah you can't use anything in this language without an extension. even arrays
21:05:44 <lispy> copumpkin: to be fair that's all of the Gnu Compiler Collection, not just the source for the gnu c compiler
21:05:47 <copumpkin> edwardk: OMG TROLL
21:06:08 <shapr> copumpkin: I recently built or downloaded gcc for CPUs msp430 and rx62n 
21:06:12 <Axman6> edwardk: what're you trying to do?
21:06:19 <edwardk> copumpkin: legitimate whine. i wanted to put an array memoizing store transformer in comonad-transformers =(
21:06:21 <shapr> edwardk: just like my taxes!
21:06:28 <copumpkin> edwardk: yeah, just being silly
21:06:41 <Jesin> @help djinn
21:06:41 <lambdabot> djinn <type>.
21:06:41 <lambdabot> Generates Haskell code from a type.
21:06:41 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:06:52 <lispy> accel: you should use the source I linked.  That tarball you linked doesn't have any version control.
21:06:55 <Jesin> @djinn a -> a
21:06:55 <lambdabot> f a = a
21:07:00 <lispy> accel: You really want a copy of either the darcs or git trees.
21:07:14 <lispy> accel: in case you make changes and want to submit them (after you fix that bug)
21:07:32 <edwardk> Axman6: data Pointer a i e = Pointer (a i e) i as a ComonadStore
21:07:53 <lispy> That's bad grammar
21:08:04 <lispy> Who as, "I as a ComandStore."  Srsly.
21:08:09 <lispy> er, ssay
21:08:16 <Axman6> edwardk: what extension do you need for that?
21:08:22 <edwardk> lispy: hah
21:08:31 <edwardk> axman6: IArray is an MPTC
21:08:39 <Axman6> ah right
21:08:53 <Jesin> @djinn f ? ((((a -> Bool) -> a) -> Bool) -> ((a -> Bool) -> a)) -> ((a -> Bool) -> a)
21:08:53 <lambdabot> Cannot parse command
21:08:58 <Jesin> @djinn ((((a -> Bool) -> a) -> Bool) -> ((a -> Bool) -> a)) -> ((a -> Bool) -> a)
21:08:58 <lambdabot> f a b =
21:08:58 <lambdabot>     a (\ _ -> False) (\ _ -> b (a (\ _ -> False) (\ _ -> False)))
21:09:11 <edwardk> Axman6: time to add another package =/
21:09:23 <edwardk> comonad-extras ftw
21:09:26 <Axman6> you'll go over the hackage limit, don't do it!
21:09:31 <edwardk> hah
21:09:40 <Axman6> you'll kill us all!
21:09:52 <edwardk> axman6: i'm relatively curious who does have the most packages on hackage
21:10:16 <Axman6> it's got to be between you, dons and snoyman
21:10:31 <lispy> Wasn't dons on a schedule of 1 package a week for a while when hackage was new?
21:10:33 <Axman6> ask dons to put that in his next hackage state post!
21:10:50 <lispy> State of the Hackage union
21:10:54 <ddarius> edwardk: If lambdas were good enough for Church, they should be good enough for you.
21:11:17 <edwardk> meh i gave up church to have more time to code a long time ago
21:11:30 <shapr> lispy: HC&AR is the State of the Haskell, right?
21:11:45 <lispy> shapr: I dunno, does anyone still read it?
21:11:56 <shapr> I don't know.
21:12:39 <lispy> Pardon me if I'm rude/wrong, but I think HCAR is part of a bygone era of the Haskell community.  We're all reddit/twitter/blogosphere these days, I think
21:12:56 <kevinburke> hey, i'm trying to learn haskell, i set up some test cases using hunit, they compiled okay, but then after the first test case, I got cases 6 tried 1 errors 0Segmentation fault
21:13:00 <kevinburke> what could cause that?
21:13:04 <lispy> I stopped reading -Cafe, but I may be a bit of a rebel there.
21:13:17 <kevinburke> i've never used C or C++ either
21:13:40 <sm> bah lispy..  twittersnapper
21:13:43 <lispy> kevinburke: Hmm...Is your code in a repository somewhere that we could look at it?
21:13:48 <Axman6> kevinburke: that's... odd, care to share the code?
21:13:55 <kevinburke> It's only three files or so
21:14:05 <kevinburke> i'll hpaste them, hang on a sec
21:14:17 <ddarius> lispy: Cafe is insane.  I can take massive amounts of abuse, and I eventually gave up.
21:14:28 <cafesofie> hm?
21:14:39 <ddarius> lispy: People love HC&AR.
21:15:11 <Axman6> i stopped reading -cafe very quickly because it's too high volume
21:15:21 <ddarius> It's grown over time.
21:15:27 <ddarius> As you might imagine...
21:15:41 <kevinburke> @hpaste 43535
21:15:41 <lambdabot> Haskell pastebin: http://hpaste.org/
21:15:42 <Axman6> i think it should be split into different mailing lists, like haskell-performance, haskell-announce, haskell-newbs etc
21:15:45 <kevinburke> http://hpaste.org/43535/segfault
21:15:53 <applicative> damex, I keep getting cut off, but here's a start http://cimarosti.blogspot.com/2009/04/nano-text-editor-syntax-highlighting.html
21:16:57 <applicative> damex, I used to use it as my default editor for :e in ghci, it needed a bit of work :)
21:17:38 <lispy> ddarius: ah, interesting.  I don't read hcar, I figure lots of people don't.  Do you know what demographic within the Haskell community reads it?  Say, professors mostly?  Grad students?  Redditors?
21:17:52 <damex> applicative: wow, thx :P
21:18:04 <kevinburke> here's the error in ghci
21:18:05 <damex> i was just thinked over moving to the "yi" :P
21:18:05 <kevinburke> http://hpaste.org/43537/segfault_ghci
21:18:13 <kevinburke> here's the parse file
21:18:28 <applicative> damex, well don't let this stop you...
21:19:30 <Axman6> kevinburke: just fyi, i don't know many people who use hunit
21:19:46 <kevinburke> ok
21:19:47 <kevinburke> http://hpaste.org/43538/parse_class
21:20:07 <kevinburke> i just googled haskell unit tests and that seemed like the easiest to set up.
21:20:10 <damex> applicative: ^_^
21:21:51 <kevinburke> i just tried running it again and got a segmentation fault in a different place
21:23:41 <joe6> can I concat [ByteString]? or do I need a specific function to unpack and then concat them?
21:24:06 <joe6> Axma6: why do you say that? I use HUnit. I think it is awesome.
21:24:15 <c_wraith> :t BS.concat
21:24:15 <lambdabot> [BSC.ByteString] -> BSC.ByteString
21:24:28 <joe6> c_wraith: Thanks.
21:24:45 <kevinburke> http://hpaste.org/43540/newsegfaults
21:24:54 <kevinburke> oops that's not right
21:25:04 <shapr> joe6: QuickCheck is a general solution to testing, HUnit is rather specific. Even so, there are hackages that allow you to use both flavors of tests together.
21:25:11 <Axman6> joe6: i say that because of all the people i know, you're one of the first who uses hunit ;)
21:25:20 <ddarius> lispy: I have no idea, but there is a lot of stuff that is only covered in the HC&AR.
21:25:24 <jan247> hi guys, projects.haskell.org isn't available?
21:25:30 <Axman6> joe6: no
21:25:32 <Axman6> uh, jan247 
21:25:42 <Axman6> it's being moved to a new server
21:25:48 <ddarius> You bloggers/twitters/redditors only think you're abreast of everything.
21:25:58 <joe6> Axman6: really? I use it to run usb device testing and I think it is pretty flexible too.
21:26:27 <shapr> Axman6: I've used HUnit lots!
21:26:30 <jan247> any other mirrors available?
21:26:32 <Axman6> joe6: the fact you like it and the fact not many people use it are orthogonal ideas :P
21:26:38 <Axman6> joe6: what do you need it for?
21:26:42 <Axman6> uh, jan247 
21:26:48 <stepcut> I've written libraries to allow you to use both flavors of tests together :p
21:26:52 <Axman6> damnit, one of you change nicks! :P
21:26:55 <shapr> stepcut: Which libraries?
21:27:02 <kevinburke> http://hpaste.org/43542/newsegfaults
21:27:31 <joe6> Axman6: I use it run tests on a usb device. I think Quickcheck is mostly for generating test data. But, I have very specific sets of data and expect a certain set of results.
21:27:31 <kevinburke> is there a way to post those directly to #haskell? hpaste asks which channel when you do a paste
21:28:11 <Axman6> joe6: sure, that's a good place for unit testing. you use wuickcheck for property testing
21:28:28 <Axman6> kevinburke: no, it was turned off because of abuse
21:29:14 <joe6> Axman6: so, both have their respective domains, don't they? it is not like quickcheck can replace HUnit.?
21:29:22 <Axman6> yes
21:29:28 <shapr> actually
21:29:37 <joe6> Axman6: ok, just wanted to make sure that I was not down the wrong path.
21:29:44 <Axman6> well, it's possibly for quickcheck to replace hunit i think, but may not be convenient
21:29:45 <shapr> I think QuickCheck can replace HUnit, for some value of replace.
21:29:56 <Axman6> -y
21:30:54 <joe6> QuickCheck is for testing the haskell code that you put together. For testing something else using Haskell, I think HUnit is the library to use.
21:30:56 <shapr> I wrote about that at great length years ago, and thus certain changes made it into QuickCheck 2, yay!
21:31:05 <shapr> joe6: Oh I disagree
21:31:24 <ddarius> "Do you ever feel like you're alone when you are a in a crowd of people?"  That's a question people ask.  No one ever asks, "do you ever feel like you're in a crowd of people when you're alone?"
21:31:34 <shapr> joe6: http://www.haskell.org/haskellwiki/QuickCheck_as_a_test_set_generator
21:31:46 <joe6> shapr: thanks, will check it out.
21:31:49 <shapr> ddarius: Did you come up with that?
21:32:33 <ddarius> shapr: One of my many buddies here with me by myself told me it.
21:32:51 <copumpkin> lol
21:34:00 <ddarius> Grammar has difficulty with that sentence.
21:34:25 <drbean> That's irc
21:38:11 <adu> hi
21:40:30 * ddarius attempts to induce a meat coma.
21:40:51 <edwardk> hah its official, dons currently maintains more packages than i do
21:41:21 <copumpkin> wow, even after void?
21:41:21 <edwardk> but by the time i finish factoring out category extras that will cease to be the case. muahahaha ;)
21:41:29 <copumpkin> you should release a couple more packages, one called one, and the other two
21:41:30 <edwardk> copumpkin: yeah, he has 3 more than me =)
21:41:32 <ddarius> edwardk: But does he have more -versions- of packages than you do?
21:41:48 <edwardk> ddarius: nah i think i hold the record there. snoyman may have me beat though, checking ;)
21:42:35 <adu> YEY
21:42:58 <ddarius> When you take out the "running tests and checking for a green bar" barrier, you can shrink that code-compile-package loop to mere seconds.
21:43:14 <edwardk> hah, i lose to snoyman!
21:43:15 * hackagebot language-go 0.6 - A library for analysis and synthesis of Go code.  http://hackage.haskell.org/package/language-go-0.6 (AndrewRobbins)
21:43:22 <adu> thats me :)
21:43:24 <edwardk> 696 versions to his 796
21:43:37 <copumpkin> holy shit
21:43:40 <edwardk> but we both beat dons and his piddly 563
21:43:50 <djahandarie> That is pretty scary
21:44:02 * djahandarie sports one package and one version of that package
21:44:26 <edwardk> djahandarie: but it speaks well that that is one of the packages i actually considered depending on ;)
21:44:29 <adu> I have 2 packages :)
21:44:37 <adu> o wait, 3
21:44:56 <djahandarie> \o/
21:45:03 <edwardk> i am somewhat disturbed that i have something like 41 packages out there though
21:45:39 <copumpkin> I don't even know how many packages I have up
21:45:43 <adu> edwardk: one package must be like sneezing for you
21:45:46 <copumpkin> probably a couple
21:45:58 <edwardk> copumpkin: 43 versions =)
21:46:05 <copumpkin> me?
21:46:07 <copumpkin> wtf :P
21:46:31 <edwardk> copumpkin: enumerable, hmatrix-mmap, spoon, vector-mmap, vector-static
21:46:45 <copumpkin> I don't even remember doing hmatrix-mmap
21:46:53 <djahandarie> Maybe it's counting all the versions of the packages that you are the current maintainer of
21:47:01 * ddarius just makes package combining operators because providing a new means of combining packages increases the possibilities combinatorially.
21:47:04 <djahandarie> Rather than all the versions that you were the maintainer on
21:47:06 <adu> edwardk: ooo hmatrix-mmap sounds fun/useful
21:47:09 <edwardk> oh you got double counted a couple of times in that version count
21:47:15 <copumpkin> ah okay
21:47:27 <copumpkin> adu: I can't make any guarantees about it, because I don't even remember writing it
21:47:30 <copumpkin> @hackage hmatrix-mmap
21:47:30 <lambdabot> http://hackage.haskell.org/package/hmatrix-mmap
21:47:40 <copumpkin> whoa
21:47:41 <copumpkin> I didn't
21:47:47 <edwardk> copumpkin: 11 versions
21:47:48 <adu> anyways, I just got all expressions "working" in language-go, the statements have lots of missing pieces
21:48:12 <edwardk> copumpkin: i just grepped and hand filtered you for the fast response ;)
21:48:19 <copumpkin> I see ;)
21:48:19 <adu> wha?
21:48:31 <copumpkin> so I'm not going crazy
21:48:43 <ddarius> copumpkin: That's a conclusion too far.
21:48:46 <Axman6> edwardk: how're you getting these stats?
21:48:49 * shapr uploads hackage-spam designed to improve your hackage stats
21:48:54 <copumpkin> I didn't write hmatrix-mmap, but I think he based it off code I had written for vector-mmap so added me to the authors list
21:49:03 <edwardk> Axman6: i downloaded 00-index.tar.gz and slapped together 6 lines of perl
21:49:11 <Axman6> heh
21:49:17 <copumpkin> ddarius: :P
21:49:20 <Axman6> where do I sit? pretty low i'd assume
21:49:24 <Axman6> think i have 4 packages
21:49:35 <djahandarie> Perl?!?!?!
21:49:47 <adu> hmmm lots of these packages have 0.0.0.1 versions
21:49:54 <adu> should I have used more zeros?
21:49:54 <edwardk> Axman6: AVar, HARM, TernaryTrees, and array-utils?
21:49:57 <ddarius> The reason edwardk writes so many Haskell packages is to ward the Perl from penetrating his heart.
21:50:12 <edwardk> ddarius: most of the time it works. sometimes i slip up, like now
21:50:21 <copumpkin> @remember ddarius The reason edwardk writes so many Haskell packages is to ward the Perl from penetrating his heart.
21:50:21 <lambdabot> It is forever etched in my memory.
21:50:25 <joe6> is there a way to do an "assertException" with HUnit?
21:50:30 <edwardk> Axman6: you're above the long tail of 1-packagers =)
21:50:44 <Axman6> edwardk: hoorah :)
21:50:59 <adu> Axman6: and me
21:51:14 <adu> I made language-go, only, and mucipher
21:51:18 <Axman6> the thing about my packages, is that no one has ever used any of them
21:51:22 <edwardk> my problem is i'm represented in the author list in several ways, so i have to glue 5 versions of me together ;)
21:51:24 * ddarius seriously considers what it would take to have package combining operators be useful.
21:51:42 <shapr> ddarius: How would you combine packages?
21:51:45 <copumpkin> ddarius: some sort of package-level module system that defines interfaces for them?
21:52:00 <ddarius> copumpkin: Yes, it would seem you'd want/need some kind of interfaces.
21:52:03 <edwardk> ddarius: in what sense? two packages that when added bring in their orphans, etc?
21:52:14 <adu> ddarius: shapr: isn't that called installing them on the same computer?
21:52:16 <edwardk> or package interfaces?
21:52:25 <Axman6> edwardk: also, technically HARM isn't mine, i just found it on someone's course4 website, and offered to 'maintain' it on hackage
21:52:27 <ddarius> adu: That's but one way of combining packages.
21:52:33 <edwardk> Axman6: fair nuff
21:52:37 <copumpkin> I've definitely wanted the union of two packages bringing in orphans that don't belong in either
21:52:48 * Axman6 wishes someone would use array-utils so he can find bugs :(
21:52:49 <edwardk> Axman6: i feel the same way about reflection though i've taken much greater liberties than i expected to when i added it to hackage
21:52:53 <lispy> adu: oh, you made language-go.  I was actually working on a similar package back when issue9 was announced, but alas I did not make it far enough to post on hackage
21:53:01 <lispy> adu: anyway, kudos!
21:53:05 <ddarius> One could imagine shadowing and general "set" operations of various sorts.
21:53:07 <adu> lispy: feel free to patch away!
21:53:16 <adu> lispy: thanks :)
21:53:16 <ddarius> It would lead to wanting some interesting packages...
21:53:17 <lispy> adu: I don't actually have a use for it :)
21:53:31 <lispy> adu: which is actually, a siginificant reason why I didn't finish
21:53:38 <edwardk> i should upload the half-dozen packages i've been sitting on until i felt their were more polished and take dons' throne ;)
21:54:09 <Axman6> i was going to write an interface for the new wolfram alpha API... but turned out to have what i feel is a horrible API
21:54:11 <copumpkin> I should do the same
21:54:17 <copumpkin> well, not taking dons' throne
21:54:21 <edwardk> copumpkin: the desire for that has been one of the second-system fixes that has made kata hard to build ;)
21:54:22 <ddarius> You could have packages parameterized by packages.
21:54:26 <Axman6> plus you're limited to 2000 queries per month per API key, wtf?
21:54:27 <adu> lispy: well, I do, it is the closest thing I can think of that has the concurrency needed for optimization, the syntax required by script kiddies, and the feel of Mathematica
21:54:29 <copumpkin> but I could move up the list a bit if I got off my ass and cleaned all these projects up
21:54:30 <ddarius> Potentially higher-order package operators...
21:54:50 <adu> lispy: basically, I want to rewrite Sage in/with/for Go
21:54:51 <edwardk> (the desire for orphanless mixin packages that is)
21:54:58 <lispy> adu: what is Sage?
21:55:14 <copumpkin> ddarius: now, how would you have any kind of tractable solver for dependencies on products of these things?
21:55:17 <adu> http://www.sagemath.org/
21:55:48 <adu> lispy: it's an ad hoc melting pot of math software with a Python interface
21:55:53 <ddarius> copumpkin: Why would you need them?  You would describe the package set you wanted in the package calculus.  Some amount of inference may be nice.
21:56:00 <lispy> adu: ah
21:56:18 <copumpkin> ddarius: hm, fair enough
21:58:05 <adu> lispy: I shouldn't bash it, it has many features that commercial CASs don't, and combines paradigms in ways other CASs don't
21:58:40 <ddarius> adu: Did you bash it?
21:59:03 <adu> ddarius: yes, I used the phrase "ad hoc", to me that's bashing
21:59:15 <ddarius> adu: Is it false?
21:59:19 <adu> no
21:59:55 <lispy> adu: I'm still waiting for the "try online" link to do something
22:00:15 <lispy> I guess their server is down
22:00:24 <lispy> I wonder if they hosted it at community.haskell.org :P
22:00:56 <adu> it's really neat, they use a web server for GUI
22:01:15 <lispy> Will your version use snap?
22:01:16 <bos> argh, finalizers!
22:01:18 <adu> so the "try online" isn't anything special, its just the primary interface
22:01:31 <adu> lispy: what's snap?
22:01:50 <Axman6> @where snap
22:01:52 <adu> I was thinking my version should use FastCGI and OpenCL
22:01:55 <lispy> adu: A Haskell based web framework + server that is pretty popular these days
22:02:00 <Axman6> you suck lambdabot 
22:02:09 <lispy> ?bs
22:02:10 <lambdabot>  Done.
22:02:16 <lispy> hmm
22:02:18 <lispy> ?where
22:02:18 <lambdabot>  @where <key>, return element associated with key
22:02:20 <Axman6> wut
22:02:25 <lispy> ?where pizza
22:02:25 <lambdabot> I know nothing about pizza.
22:02:26 <Axman6> @bs
22:02:26 <lambdabot>  Done.
22:02:29 <lispy> ?where snap
22:02:33 <Axman6> @help bs
22:02:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:02:33 <lispy> hmm
22:02:43 <adu> lispy: ah I've been out of the loop in terms of webservers, I usually stick to apache + mod, and I know that makes me old
22:02:46 <lispy> Axman6: bs = bf = brainfuck
22:03:00 <adu> as in mod_*
22:03:16 <Axman6> ah right
22:03:17 <lispy> adu: That's fine I think.  You could use a reverse proxy to server up snap stuff.  I do.
22:04:02 <lispy> adu: Now getting snap to support some exotic apache only thing...that's harder.  But if you only need snap to serve data then you can get apache to use the mod and the reverse proxy gets snap to serve up content
22:04:48 <adu> lispy: sounds overly complicated
22:04:49 <ddarius> lispy: First you might want to make a case for adu to use snap.
22:05:17 <lispy> 1. Snap RULES
22:05:25 <lispy> 2. Reimplement Sage
22:05:27 <lispy> 3. ??
22:05:30 <lispy> 4. Profit
22:05:37 <adu> lol southpark
22:06:19 <lispy> adu: Anyway, to address what ddarius said.  You would want to use snap if that made it easier to serve content (by being patched into your webserver).
22:06:37 <kevinburke> is there any kind of haskellflakes for vim, so that you can see typecheck errors inline?
22:06:48 <lispy> Snap can be its own webserver without apache too.  But if you're already using apache that's when the revrse proxy is nice
22:07:45 <Axman6> if you were going to repimplement sage, i'd highly recommend not using apache, and just using snap -- Quiet etabot!
22:08:04 <adu> lispy: Axman6: ok, I'll use snap
22:08:23 <lispy> Er, I don't want to feel like I forced you :)  I just meant check it out for yourself
22:08:25 <accel> ! = makes variable strict; is there somethign like inverse-!, which tells the compiler "whenever possible, make this lazy; don't optimize this into strict" ?
22:08:42 <lispy> accel: You probably want ~
22:08:55 * ddarius doubts that.
22:08:55 <lispy> accel: haskell is lazy by default
22:09:05 <Axman6> > let f (x,y) = 2 in f undefined
22:09:06 <lambdabot>   *Exception: Prelude.undefined
22:09:11 <Axman6> > let f ~(x,y) = 2 in f undefined
22:09:12 <lambdabot>   2
22:10:12 <adu> lispy: so how does snap relate to cgi/fcgi?
22:10:13 <ddarius> And it begins snowing again.
22:10:14 <lispy> accel: some people get even more precise and split hairs about lazy vs. non-strict
22:10:35 <edwardk> ddarius: i'm not looking forward to going to work tomorrow through this
22:10:48 <edwardk> somehow i think dons has a few more users than i do though ;)
22:11:09 <yitz> accel: what Axman6 means is that although haskell is usually lazy by default, one case where it ends up being strict by default is when pattern matching forces strictness. The ~ overrides even that case and makes it lazy.
22:11:11 <edwardk> :1
22:11:20 <yitz> accel: is that the case you were asking about?
22:11:22 <edwardk> er wrong window
22:11:54 <lispy> adu: bit of a warning, I've used code written for snap but I haven't written any snap code myself.   My understanding is that with snap you write a URL handler that can serve content.  With fcgi, you'd write a program that reads/writes to stdin/stdout and the cgi wrapper handles the communication with the browser.
22:12:27 <adu> that's right
22:13:00 <lispy> adu: So, in snap your custom app is *built into* the web server
22:13:12 <lispy> adu: That should help performance
22:13:28 <adu> fcgi has the distinct advantage of 1 process to many requests, cgi is 1 process to 1 request
22:13:38 <ddarius> CGI is a pile of crap.
22:13:44 <adu> it is
22:14:02 <c_wraith> Think of snap as a library for building a web server.
22:14:10 <lispy> ddarius: You're thinking of computer generated imagery, I think
22:14:16 <adu> c_wraith: isn't that all web frameworks?
22:14:35 <c_wraith> adu: In haskell, sure.  In the java or rails world, not at all
22:14:35 <Axman6> not really
22:14:43 <adu> like xmonad: the config file _is_ the window manager
22:15:13 <Axman6> snap doesn't really have any direct support for rendering web pages, you use something like heist or blaze to do that
22:15:28 <lispy> ddarius: I think CGI is nice due to the simplicity of the model (uses stdin/stdout, process level separation).  I think it certainly has some merit even if better things exist.
22:15:53 <adu> you guys should check out fcgi, it's not terrible
22:16:18 <lispy> adu: Yeah, I use fgci to put lambdabot on the web back in like '06 :)
22:16:22 <lispy> ?quote skynet
22:16:22 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
22:16:39 <lispy> It was kind of cool
22:16:44 <adu> hehe
22:17:53 <lispy> Someone else write the ajax, and I helped with the fcgi wrapper around lambdabot 
22:17:58 <lispy> wrote*
22:18:23 <adu> anyways, I've tried writing web pages in html and xhtml (the hackage modules) and neither of them really worked for me
22:18:27 <ddarius> FCGI is fine.
22:18:27 <lispy> The site was up for a time, but eventually someone rewrote lambdabot in a way that broke my wrapper so I gave up.
22:19:18 <adu> fcgi does have support issues, being the underdog and all
22:19:24 <lispy> adu: These days I think the cool kids are using blaze (and yesod?) to generate html.  I can't speak for them directly but I've heard lots of praise.
22:19:43 <alpounet> edwardk, that's because of the names of your packages
22:19:59 <adu> lispy: I use M4
22:20:09 <lispy> Wow, hardcore.
22:20:18 <lispy> adu: Do you use autoconf too?
22:20:20 <adu> lispy: no, configurable
22:20:35 <pikhq> lispy: Not hardcore enough.
22:20:41 <pikhq> Straight M4sh. :)
22:20:53 <pikhq> AKA "ouch".
22:20:57 <adu> lispy: no, M4, bash, and sometimes a Gimp call with script-fu stuff in scheme
22:21:11 <adu> I'm a weird webdeveloper
22:21:17 <lispy> Indeed :)
22:21:25 <lispy> OTOH, if it works for you then good on you
22:21:42 <adu> the Gimp scripts were just in the makefile, none of that is actually happening per-request
22:22:10 <adu> but the M4 macros would make sure to only generate images which didn't exist
22:22:16 <lispy> adu: Does Gimp include a scheme implementation or does it provide a set of functions and someone write a scheme binding?
22:22:34 <shachaf> lispy: They use Guile.
22:22:38 <adu> lispy: it's one of the worst scheme implementations I've come across
22:22:42 <lispy> ah
22:22:50 <lispy> I know of Guile
22:23:07 <adu> no not guile, maybe now, but a while ago Gimp was using SIOD (scheme-in-one-day)
22:23:11 <lispy> Hmm...Too bad.  If they had exposed a C api we could make a Haskell binding for writing Gimp plugins :)
22:23:21 <adu> or one-defun...
22:23:38 <shachaf> lispy: They also have a Python interface, so I assume there's some sort of exposed API.
22:23:41 <adu> lispy: oh there is a C api
22:23:59 <lispy> I wonder if there are any apps I use regularly, say pidgin or thunderbird, which I would customize more if they had Haskell-fu.
22:24:13 <shachaf> lispy: I wrote some scripts for Pidgin in Perl a while ago.
22:24:30 <lispy> I'm basically perl illiterate though :)
22:24:32 <adu> it's called libgimp, but it was designed to be used by plugins while running in Gimp, so context init/quit functions are really hard to use
22:25:08 <lispy> My Pidgin crashes everyday >: and I'm thinking about ditching it for something else, but nothing else really supports the stuff I'm accustomed to without me using 3 separate programs.
22:25:09 <shachaf> lispy: So am I. :-)
22:25:42 <shachaf> lispy: Pidgin crashes every day? How?
22:25:56 <lispy> Whenever I resume my laptop in the morning, pidgin has crashed.  It's really weird.  I think it's crashing in my twitter plugin but I'm not sure.
22:25:57 * shachaf hasn't had it crash for quite a while now.
22:25:58 <adu> lispy: apparently we're both wrong, Gimp moved from SIOD to TinyScheme
22:26:38 <shachaf> lispy: Ah, well, plugins.
22:26:39 <lispy> shachaf: I tried twice to run pidgin in gdb so I could get a trace and both times my computer failed to resume correctly so I gave up on that.
22:26:59 <lispy> (this is on linux)
22:27:05 <shachaf> lispy: You can always write a Haskell frontend for libpurple. :-)
22:27:37 <lispy> shachaf: Yeah, and then my own twitter plugin.  Hmm....I want something more fun to hack on now that I think about it :)
22:27:51 <adu> lispy: guile is one of the better schemes (not as good as racket), but it implements a large portion of the SRFI's that people like
22:28:12 <shachaf> lispy: Yes, sensible. :-)
22:28:15 <lispy> adu: I see.  BTW, didn't racket change names recently?
22:28:22 <shachaf> lispy: Again?
22:28:23 <adu> lispy: yes, from PLT to racket
22:28:32 <lispy> ah, okay
22:28:46 <adu> but mzscheme (which is part of PLT) is still mzscheme
22:28:49 * lispy can never keep name changes straight.
22:29:35 <adu> PLT was like 5 different scheme dialects and they called the most popular dialect "Racket" and made it a brand and stuff
22:29:56 <lispy> clever
22:30:31 <lispy> I started writing an emacs lisp implementation in Haskell, but I didn't get past code generation.
22:30:50 <shachaf> lispy: Why emacs of all LISPs?
22:30:57 <lispy> shachaf: yi
22:31:03 <adu> lispy: I'm still working on parsing! if i had chosen a lisp dialect, I probably would have been done by now
22:31:09 <shachaf> Oh. Bah.
22:31:30 <adu> lispy: what's so great about elisp?
22:31:36 <lispy> shachaf: basically, to give yi support for existing emacs code until someone rewrites said extensions to be native yi.
22:31:37 <shachaf> adu: It's used in emacs.
22:31:44 * shachaf can't think of anything else good about it.
22:31:52 * shachaf might be exaggerating.
22:32:00 <adu> shachaf: me too, I just don't customize it other than mv X ~/.emacs.d
22:32:10 <shachaf> After all, "used in emacs" isn't all that good in itself. :-)
22:32:31 <adu> shepheb: oops i thought you said you use emacs
22:32:35 <lispy> I think if I were to start over on that project that I would instead translate from elisp to a special monad in Haskell that supports dynamic scope.  That would surely make interfacing with yi easier.
22:33:02 <adu> lispy: sounds like liskell
22:33:12 <joe6> type ControlAction a = RequestType -> Recipient -> Request -> Value -> Index -> a: this is the type synonym and I want to write a function with a type definition of f :: Int -> ControlAction
22:33:18 <joe6> is that possible?
22:33:34 <lispy> adu: as in *the* liskell?  Or were you just naming the monad?
22:33:44 <adu> lispy: is there any way to extend/modify liskell to support elisp?
22:33:46 <shachaf> joe6: ControlAction is a type constructor; you have to give it an argument.
22:33:47 <joe6> I guess there is no typeConstructor here?
22:33:56 <joe6> shachaf: ok, thanks.
22:33:59 <shachaf> Er, never mind.
22:34:17 <adu> lispy: I was just having a brain-fart, don't mind me
22:34:22 <lispy> adu: I have no idea actually.  As I recall, liskell has a hybrid syntax
22:34:25 <lispy> :)
22:34:48 <adu> I was talking about the liskell
22:34:51 <adu> btw
22:35:01 <lispy> http://www.liskell.org/
22:35:13 <accel> liskell is the best ever
22:35:26 <adu> ooo I wonder if I could add Go syntax highlighting to Yi
22:35:28 <joe6> shachaf: it says, Not in scope: data constructor `ControlAction'
22:35:43 <shachaf> joe6: There's no data constructor.
22:35:58 <shachaf> joe6: It's a type synonym. There's only a type constructor.
22:36:01 <joe6> so, I cannot just do: f = ControlAction .... 
22:36:11 <shachaf> joe6: No, because it's not a separate data type.
22:36:33 <joe6> so, I can do: f = ... and ghc will automatically take ... as ControlAction?
22:37:35 <shachaf> "type" is almost a #define.
22:37:56 <shachaf> type Foo a = [a] -- Anywhere you type "Foo a", it means the exact same thing as "[a]".
22:38:59 <lispy> type is easy to overuse.  It has some good uses, but often people want data/newtype instead of just type.
22:39:09 <lispy> (something to keep in mind)
22:39:17 * shachaf wishes newtype was more convenient.
22:39:34 <lispy> shachaf: as in, fewer restrictions?
22:39:40 <pastorn> shachaf: it is, with GeneralizedNewtypeDeriving
22:39:40 <lispy> or something else?
22:39:40 <shachaf> lispy: As in, I don't know.
22:39:45 <lispy> heh
22:39:55 <shachaf> It should be used everywhere, though, but it's just so annoying to make a newtype for the thing you want to do.
22:40:09 <shachaf> So you don't do it.
22:40:28 <joe6> shachaf: but, I have type Foo d = a b c d, and I want to do f :: Int -> Foo d; f 1 = 1 2 3 4 does not seem to work
22:40:38 <joe6> shachaf: does that make sense?
22:40:48 <shachaf> joe6: What's that supposed to mean exactly?
22:40:50 <joe6> shachaf: it is basically returning multiple values?
22:40:57 <lispy> shachaf: Sounds like you want local contexts of assumptions.  Like, "with in this block of code, when I say Foo I mean Bar."
22:40:59 <shachaf> joe6: No, it has nothing to do with that.
22:41:15 <shachaf> joe6: If you want to return multiple values, use a tuple or a data type.
22:41:27 <joe6> Foo is a type synonym for 3 types and I am wondering if I can have a function that can return the Foo?
22:41:28 <shachaf> lispy: For instance, why is FilePath a type and not a newtype?
22:41:35 <joe6> shachaf: oh, ok. 
22:41:43 <shachaf> joe6: A type synonym is a synonym for exactly one type.
22:42:08 <kfr> Why do people say synonym when they mean homonym? :|
22:42:27 * hackagebot yst 0.2.4.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.2.4.1 (JohnMacFarlane)
22:42:33 <joe6> shachaf: http://hackage.haskell.org/packages/archive/usb/0.7/doc/html/System-USB-IO-Synchronous.html#t:ControlAction
22:42:36 <shachaf> kfr: Huh? No they don't.
22:42:47 <joe6> shachaf: i got that idea of a synonym from that link.
22:42:59 <shachaf> joe6: OK?
22:43:23 <lispy> shachaf: You want FilePath to be a newtype of String but requires construction via a sanitization smart constructor?
22:43:31 <shachaf> That means that whenever you type "ControlAction α", the compiler will substitute it with "RequestType -> Recipient -> Request -> Value -> Index -> α". Nothing more.
22:43:53 <shachaf> lispy: I'm not sure what it should require. All the overhead is the annoying part of it.
22:44:12 <joe6> yes, I have quite a few places where I am building up that ControlAction and was wondering if I could substitute all those patterns with a function that can return a ControlAction.
22:44:41 <joe6> shachaf: i understand what you are saying, but am wondering if there is a different way of doing it.
22:45:05 <joe6> make a function return multiple parameters to a function, such as
22:45:07 <lispy> shachaf: yeah, programmers tend to be lazy.  So you want to make the "right way" the easy way.  With something so fundamental as FilePath I'm not sure what "the right way" is and so it's hard to know what the easy way is.
22:45:11 <lispy> I should crash
22:45:17 <lispy> good night, #haskell!
22:45:19 <shachaf> joe6: It's just a #define. I don't know what you want from the poor thing.
22:45:26 <edwardk> what haskell implementations out there _don't_ support the arrays package?
22:45:27 <Axman6> adu: it was you that was thinking of doing a haskell version of sage right?
22:48:00 <joe6> http://hpaste.org/43545/joe -- this is the code I have and I am wondering if I can replace all those patterns of (stRequestType setupmsg)...
22:48:06 <joe6> does that make sense?
22:49:18 <joe6> something like a multiple-value-bind of lisp might help.
22:49:43 <jan247> hi guys, can anyone help me with haxml? i'm cofused with Content and CElem. new with haskell btw.
22:49:51 <joe6> but am not sure how it can be done in haskell.
22:52:14 <adu> Axman6: maybe, don't remember having that thought tho
22:53:10 <joe6> shachaf: any thougts, please?
22:54:01 <Axman6> adu: well, after looking at sage, i think that would be an awesome project, and i'd love to see it happen ;)
22:54:33 <joe6> adu: any links to sage?
22:55:01 <Axman6> @google sage python
22:55:02 <lambdabot> http://www.sagemath.org/
22:55:02 <lambdabot> Title: 30 Sage: Open Source Mathematics Software
22:55:05 <Axman6> that one
22:55:12 <joe6> ok, cool
22:56:03 <joe6> Axman6: Any suggestions on how I can get rid of (stRequestType setupmsg)... patterns from http://hpaste.org/43545/joe
22:57:46 <adu> Axman6: o I was workinf on a det/matric inerse algo in hs
23:03:50 <kfr> <shachaf> kfr: Huh? No they don't.
23:03:57 <kfr> type makes a type homonym
23:04:00 <kfr> Not a synonym :|
23:04:12 <kfr> I mean every homonym is a synonym but it's misleading
23:04:25 <shachaf> joe6: I still don't know what you want to do.
23:04:38 <shachaf> kfr: No, homonyms aren't synynyms.
23:04:59 <kfr> How so? Synonymous means similar in meaning
23:05:09 <kfr> Whereas homonymous means identical in meaning
23:05:09 <shachaf> Homonyms are spelled the same but have different meanings; synonyms are spelled differently but have the same meaning.
23:05:20 <pastorn> joe6: in controlTxn2Assertion you seem to be doing the some thing over and over
23:05:31 <kfr> Homonymous terms are similar in meaning to each other, even identical in meaning to each other
23:05:36 <pastorn> joe6: maybe you could use case/of to reduce copy/paste-coding
23:05:41 <shachaf> @dict-all homonym
23:05:42 <lambdabot> Unknown command, try @list
23:05:48 <kfr> shachaf? Oh hmm I thought the definition was different
23:05:52 <shachaf> @all-dicts homonym
23:05:54 <lambdabot> *** "Homonym" gcide "The Collaborative International Dictionary of English v.0.48"
23:05:54 <lambdabot> Homonym \Hom"o*nym\, n. [Cf. F. homonyme. See {Homonymous}.]
23:05:54 <lambdabot>    A word having the same sound as another, but differing from
23:05:54 <lambdabot>    it in meaning; as the noun bear and the verb bear. [Written
23:05:54 <lambdabot>    also {homonyme}.]
23:05:56 <lambdabot> [19 @more lines]
23:06:04 <kfr> Oh snap
23:06:44 <joe6> pastorn: the calls are different, one of them is readControl and the other writeControl and the other just Control.
23:06:48 <kfr> How misleading :'(
23:06:56 <joe6> pastorn: the arguments are different too.
23:07:18 <joe6> pastorn: i am just checking out TH to se if it can help.
23:07:33 <pastorn> joe6: another thing is that you apply a lot of selectors to setupmsg
23:07:53 <pastorn> you could do that a bit nicer with a where-clause
23:08:27 <shachaf> kfr: Why misleading?
23:08:58 <shachaf> "homonym", as in "same name".
23:09:19 <joe6> pastorn: yes, that is what I want to do. there is just too much boilerplate code that I want to get rid of..
23:10:01 <pastorn> joe6: hang on... trying to modify it...
23:13:15 <joe6> pastorn: don't. let me do it.
23:13:24 <joe6> pastorn: and then you can comment.
23:14:34 * hackagebot gitit 0.7.3.12 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.12 (JohnMacFarlane)
23:16:33 <joe6> so, any module defined must have a data constructor? 
23:17:06 <joe6> how can I import a haskell source file which does not have a data constructor?.
23:17:11 <pastorn> http://codepad.org/TAzBX3gr
23:18:01 <pastorn> joe6: ^^^^
23:18:09 <joe6> pastorn: thanks.
23:19:48 <joe6> pastorn: it is actually pretty cool. It is simpler too. Thanks.
23:20:33 <pastorn> maybe you'll need separate do:s after the case instead of getting the result
23:20:41 <pastorn> but whatever, you'll figure it out
23:22:15 <joe6> pastorn: yes, that makes it a very big function. is that a good idea?
23:22:20 <pastorn> joe6: there's some way to expose the fields as variable names on input variables
23:22:48 <joe6> pastorn: yes, I read about it.
23:22:52 <pastorn> you do something like "f rec@(Construct { ... }) = body"
23:23:13 <pastorn> and since you have a record in a record you could perhaps expose that again
23:23:29 <joe6> pastorn: ok, thanks. will do so.
23:23:32 <pastorn> having that giant "where" is kind of annoying
23:24:57 <pastorn> joe6: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html
23:30:00 <Axman6> aaannnnddd, the award for the most spam comments on a haskell blog goes to....
23:30:14 <Axman6> LENNART AUGUSTSSON! congratulations!
23:30:32 <pastorn> Axman6: lolwat?
23:30:59 <Axman6> https://www.blogger.com/comment.g?blogID=25541020&postID=3941171818143196666
23:46:06 <Apes> Any good haskell plugins for vim?
23:46:15 <kevinburke> any good vim haskell plugins i should know about?
23:46:26 <djahandarie> That was creepy.
23:46:30 <Apes> what
23:46:39 <ion> :-D
23:46:41 <Axman6> ha
23:46:49 <Axman6> 17:01 < Apes> Any good haskell plugins for vim?
23:46:50 <Axman6> 17:01 -!- kevinburke [~kevin@int-166-231.resnet.claremontmckenna.edu] has joined #haskell
23:46:51 <pastorn> kevinburke: there's extra syntax highlighting for haddock
23:46:53 <Axman6> 17:02 < kevinburke> any good vim haskell plugins i should know about?
23:47:24 <kevinburke> haha whoa
23:47:32 <Apes> Did you do that on purpose?
23:47:34 <kevinburke> no
23:47:38 <kevinburke> i just joined the chatroom
23:48:10 <djahandarie> But re: Apes, kevinburke, I only know of haskell-mode for emacs and it's what I use
23:48:22 <djahandarie> Not sure what's out there for vim, I haven't heard of anything like that
23:48:36 <pastorn> kevinburke, Apes: there is a haskell mode, i know a guy who uses it
23:48:47 <pastorn> i'm fine with just syntax highlulzing myself
23:49:46 <kevinburke> i've been using the tabular plugin, its nice for lining up equals signs
23:49:51 <kevinburke> it just got a vimcast too
23:50:14 <pastorn> kevinburke: oh, do you have a link for that?
23:51:38 <kevinburke> sure http://vimcasts.org/episodes/aligning-text-with-tabular-vim/
23:53:42 <Apes> Tabularize looks like a nice plugin
23:55:18 <jtummond> @pl  f hs = map (\x -> sum (map (*x) hs)) 
23:55:19 <lambdabot> f = map . (sum .) . flip (map . (*))
