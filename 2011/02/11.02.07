00:00:04 <Axman6> you should come say hi!
00:00:18 <adu> Axman6: are you in japan?
00:00:30 <Axman6> aye, with kfish 
00:00:49 <xplat> adu: i have to say ‘i am so jealous’ in english so it doesn't sound too rude and 「頑張って！」 in japanese so it doesn't sound too silly :)
00:00:53 <adu> hmm, sounds fun, maybe we can meet up in a big city
00:01:13 <adu> hehe
00:01:18 <Axman6> well, you're in the middle of Tokyo
00:01:32 <xplat> helps sometimes to have multiple languages to work with :)
00:01:44 <adu> おお
00:02:12 <adu> so that's the kanji for gambatte? i should learn that, it's my favorite japanese word
00:02:34 <adu> Axman6: I'll be in Osaka
00:02:43 * ddarius just missed Osaka.
00:04:00 <xplat> i can never decide what's my favorite, but i'm also pretty fond of 'ganbatte'.  and 'shimau', as an auxiliary verb.  the only thing in english that comes close is 'gone and' ...
00:04:20 <nosila> hey
00:04:32 <nosila> anyone know how to do a system "cls" in win ghci??
00:04:47 <nosila> (by code)
00:04:50 <taotree> how do you type japanese chars in here?
00:04:58 <Wooga>  taotree you need IME
00:05:02 <nosila> install the japanese translator IME
00:05:14 * Wooga prefers UIM + Anthy
00:05:52 <adu> xplat: what does shimau mean? shutup?
00:05:58 <xplat> taotree: i installed the SCIM framework and the anthy IME, i can now type japanese into any Gtk or Qt app and a lot of others
00:06:30 <adu> xplat: oh wait that's shimatte
00:06:41 <taotree> shimau is something like : completely and unfortunately did something
00:07:27 <taotree> often used as a secondary verb... but sometimes used by itself "shimatta" to mean something like "I messed up"
00:07:28 * ddarius should perhaps install anthy.
00:07:29 <adu> taotree: I have macosx, it has Japanese builtin
00:07:44 <Wooga> m, can someone helo me with constructing from scratch minimal Iteratee by hand in ghci; from iteratee-0.7.0.0 package?
00:07:56 <Wooga> it has recursive Iteratee in it's definition
00:08:01 <Wooga> i have no idea how to manage this
00:08:16 <xplat> adu: Xtte shimau, sometimes contracted to Xchau, means to do something completely or finally, or otherwise in a way that nothing can be done about, although it's generally implied that the speaker wishes something could be done about it
00:08:23 <Wooga> http://paste.pocoo.org/show/333567/
00:08:33 <xplat> as i said, the closest english translation is 'gone and Xed'
00:08:37 <adu> Wooga: that looks good
00:08:51 <Wooga> adu: but how do i make own one?
00:09:01 <Wooga> (without using things lie icont or idone)
00:09:31 <adu> xplat: another one of my favorites is "-ちゃった”
00:09:48 <xplat> that's the same thing
00:09:50 <taotree> adu, same word
00:09:50 <adu> xplat: it has a similar meaning, i think
00:09:53 <xplat> it's just a contraction
00:10:00 <taotree> it's the past tense contraction
00:10:03 <adu> oh ok, i didn't realize that
00:10:25 <xplat> yeah, it took me a long time to get that too
00:10:53 <adu> fascinating
00:11:21 <xplat> books that cover contractions are rare and often they don't even mention the long form, similarly books that cover the full form rarely mention contractions
00:11:35 <adu> but ya, I'll probably be on IRC like 1 hour per day while I'm in japan
00:11:50 <xplat> except really common ones that are almost obligatory
00:12:23 <adu> obligatory?
00:12:44 <xplat> so i ended up figuring it out from context long before i found any reference
00:13:36 <xplat> well, kedo was originally a contraction, and the no->n' before d is /actually/ obligatory now afaict
00:13:53 <kfish> adu, what haskell company do you know in osaka?
00:14:07 <adu> kfish: starling-software.com
00:14:14 <adu> oh it's not in Osaka
00:14:30 <ddarius> Yeah, it's in Shinjuku, Tokyo.
00:14:30 <Axman6> heh...
00:14:31 <adu> I'm going there to teach English
00:14:47 <kfish> adu, starling aren't operational any more, effectively folded into tsuru capital (where we are)
00:14:59 <adu> Haskell is just my favorite language in the universe, that's all
00:14:59 <sgronblo> Was it easy to get an english teaching job there?
00:15:02 <kfish> we are in kamiyacho, moved out of shinjuku last july
00:15:04 <ddarius> kfish: Interesting.
00:15:14 <xplat> adu: have you done any specific studying on Ōsaka-ben?
00:15:15 <ddarius> kfish: So you guys -were- in Shinjuku.
00:15:36 <taotree> xplat, Osaka ben... heh, fun. I lived in the Kansai area for 2 years
00:15:42 <adu> xplat: 大坂べんわからへん
00:16:14 <adu> xplat: yes, my favorite osakaben is "Donkusai"
00:16:15 * ddarius has forgotten most of what tiny bit of Kansai-ben he knew.
00:17:00 <sgronblo> Are any of you working in IT in Japan atm?
00:18:33 <adu> sgronblo: for me, yes, I've done it before
00:19:05 <xplat> adu: if you go to tokyo after spending a while there you'll probably be even more of an object of amaz/usement than the average american walking the streets :)
00:19:10 <adu> kfish: ya, I noticed the disclaimers on the website
00:19:19 <shapr> Bunches of awesomeness happening in Tokyo, I wish I could hang out at the Tokyo hackerspace
00:19:43 <adu> xplat: amuzement? how so?
00:20:00 <adu> shapr: oooo hackerspace
00:20:29 <Wooga> how do i create types, that have recursive declaration and only one constructor ?
00:20:55 <adu> Wooga: Maybe?
00:21:26 <Wooga> adu: no, not wrapped into Maybe
00:21:44 <adu> then I would say it's impossible
00:22:01 <Wooga> then maybe i am getting something wrong
00:22:06 <Wooga> please, look at this: http://paste.pocoo.org/show/333570/
00:22:14 <xplat> adu: well, whenever someone who would normally be expected to have an ethnic accent has a strong regional accent instead/in addition, it tends to cause a certain reaction in a lot of people anywhere because of the cognitive dissonance
00:22:16 <kfish> Wooga, type-level fix?
00:22:22 <Wooga> kfish: eh?
00:22:55 <kfish> http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
00:23:00 <xplat> except of course if it's the same region as you, then you just think their <your language> is uncommonly good
00:24:29 <xplat> adu: data RoseTree a = RoseTree a [RoseTree a]
00:24:39 <adu> xplat: like people from India having Texas accents... lol
00:24:55 <shapr> Have you guys tried to write up a GF grammar for Japanese? :-)
00:25:17 <xplat> adu: yes, pretty much exactly like that
00:27:04 <sgronblo> So umm since you're discussing this in here, does this mean that some of you are working in IT in Japan atm or?
00:27:56 <adu> xplat: my osaka accent is めっちゃうまい
00:28:34 <xplat> adu: just to put a cap on the subject of verbs: i have an entire book that is on different clausal and phrasal forms (both simple and compound) of japanese verbs and adjectives.  and i know dozens of them that are not in it.  and i still run across ones i don't know pretty regularly
00:30:11 <xplat> english can be a little like that, but japanese is a lot like that :)
00:33:04 <xplat> i mean, that aspect is actually a lot of fun once you get into it a little, but early on it is really daunting
00:35:50 <xplat> but i think if the channel wasn't so slow right now this conversation would have been banished to blah an hour ago ...
00:36:03 <kfish> or #haskell.jp :)
00:41:27 <manju__> I am trying to do some CGI in haskell
00:41:30 <manju__> I am newbie
00:41:33 <manju__> http://hpaste.org/43720/cgi_example
00:42:06 <manju__> so in this code I want to the first set of radio buttons to be dependent on the second set of radio buttons
00:42:22 <manju__> The the arch and then the interconnect type
00:42:48 <manju__> only the last seems to get executed can anyone help me ?
00:42:50 <Wooga> i still can't understand... if i have type ``
00:43:06 <Wooga> if i have type `newtype Test = Test (Int -> Test)`, how do i make value of type Test ?
00:44:37 <c_wraith> That type appears to be hard to make a useful value of
00:44:48 <Wooga> c_wraith: Iteratee using same thing
00:45:22 <Wooga> but i can't understand how they working with it
00:45:24 <c_wraith> let a = const b ; b = Test a
00:45:32 <c_wraith> that's a horrible example
00:45:33 <c_wraith> But it works
00:45:34 <c_wraith> :)
00:46:33 <c_wraith> Honestly, that type is useless
00:46:42 <c_wraith> I'm assuming the iteratee internals are a bit less useless
00:47:36 <xplat> the internal iteratee type has about 3-5 constructors depending which library iirc
00:47:45 <Wooga> c_wraith: here is iteratee implementation: http://paste.pocoo.org/show/333576/
00:48:08 <c_wraith> ah, you're looking at the CPS version
00:48:17 <Wooga> whats this?
00:48:21 <xplat> oh, yeah, i forgot they did that
00:48:23 <c_wraith> have you looked at any other data type in CPS style?
00:48:30 <Wooga> no
00:48:37 <c_wraith> err, that's a bit redundant.  Continuation Passing Style style :)
00:48:53 <dafis> RAS syndrome
00:49:00 <xplat> that will die out about the same time as ATM machine
00:55:51 <Wooga> whoa
00:55:59 <Wooga> haskell gentoo overlay switched to git
00:56:41 * hackagebot bindings-levmar 0.2.0.1 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-0.2.0.1 (BasVanDijk)
00:56:43 * hackagebot levmar 0.3 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-0.3 (BasVanDijk)
00:59:22 <nosila> xplat
00:59:25 <nosila> u here?
00:59:48 <nosila> wanna know the most osumeeee thing?
01:00:05 <nosila> 1h untill the exam / delivery of the project
01:00:38 <adu> lol
01:00:57 <nosila> the teacher sends me an email saying it will be postponed to 15 of february
01:02:18 <silver> that's cool if you're not ready
01:03:36 <nosila> soso, been awake all night to finish this and havent study yet
01:10:11 <Palmik> Hi guys, is there some tutorial on HaskellDB? All I found was a 1.5 page paper using functions that no longer exist
01:13:59 <Palmik> ok, they do exist, sorry :)
01:15:48 <gienah> Palmik: the paper is longer than 1.5 pages
01:16:24 <gienah> http://haskelldb.sourceforge.net/haskelldb.pdf
01:16:25 <Palmik> Hmm, maybe we are talking about different paper then?
01:16:54 <Palmik> Yeah, that one is no longer there... I!m talking about this one http://www.mijnadres.net/published/HaskellDB.pdf
01:17:02 <Palmik> *I'm
01:17:39 <gienah> Palmik: will see if I can find it ...
01:17:57 <Palmik> that would be great, thanks :)
01:18:31 <gienah> Palmik: maybe here: http://www.mijnadres.net/published/HaskellDB.pdf
01:18:48 <gienah> oh but that is the one you mentioned
01:21:11 <gienah> Palmik: hmm, can not find it, but well I have it, will up load it ...
01:21:55 <Palmik> Ok, thank you :)
01:25:33 <gienah> Palmik: I just placed it here temporarilly: http://www.users.on.net/~markwright/haskelldb.pdf
01:26:14 <Palmik> Aa, nice, got it :)
01:26:43 <gienah> Palmik: great
01:29:14 <taotree> Trying to use HDBC-sqlite, getting error from my lack of understanding:  http://hpaste.org/43721/run_conn
01:29:56 <taotree> ack, nevermind
01:30:04 <taotree> found missing []
01:31:52 <Wooga> hello, is there any way to get rid of st <- ... in this piece of code: http://paste.pocoo.org/show/333588/ ?
01:32:30 <Wooga> to apply Iteratee to Enumerator at one line
01:36:09 <Peaker> Wooga, I don't see "st <- " in there
01:36:44 <Wooga> Peaker: main = do st <- runIteratee head' :: IO (Step a IO (Maybe a))
01:36:48 <Wooga> 12th line
01:37:00 <Peaker> Wooga, I think you put the wrong paste?
01:37:09 <Peaker> oh, you edited it?
01:37:15 <Peaker> I got a wrong paste at first
01:37:45 <Wooga> no, this pastebin does not supports editing existing pastes
01:37:48 <Peaker> Wooga, you can use: run_ (enumList 1 [1..10]) =<< runIteratee head'
01:38:20 <Peaker> Wooga, do { a <- b ; c <- d ; ... } is de-sugared to:  b >>= \a -> d >>= \c -> ...
01:40:28 <Peaker> if you have a pure function you want to apply to a non-pure arg, you can use:   pureFunc <$> nonPure    if you have a non-pure func you want to apply to a non-pure arg, you can use:  nonPureFunc =<< nonPureArg
01:40:57 <Wooga> Peaker: still not working for me. http://paste.pocoo.org/show/333591/
01:42:56 <taotree> How do I convert a Float to and from SqlValue so I can use it in HDBC?
01:43:10 <Peaker> Wooga, this paste site of yours is *realllly* slow for me :)
01:43:39 <Wooga> Peaker: here the another one: http://paste2.org/p/1233409
01:45:03 <Peaker> Wooga, oh, I made a mistake.. you had run_ $ (..) st   so that can first be converted to:  run_ . (..) $ st   and then the $ can be replaced by =<<
01:45:31 <Wooga> Peaker: oh, thank you a lot! now it is working!
01:46:15 <Peaker> Wooga, You can think of $ as a pure func apply to pure arg
01:46:21 <Peaker> Wooga, <$> as  pure func to non-pure arg
01:46:27 <Peaker> Wooga, =<<  as non-pure func to non-pure arg
01:47:04 <ddarius> Peaker: Then what would you call (<*>)?
01:47:26 <Wooga> hm
01:47:28 <Peaker> a different form of non-pure func to non-pure arg? :)
01:47:45 <Wooga> does that means that Iteratees are impure in Data.Enumerator?
01:47:56 <Peaker> Wooga, something like:   f . g=<< h    is sort of a "pipe-line" that performs h, then g, then f,   and the 'h' and 'f' here are allowed to have effects
01:48:31 <Peaker> Wooga, I use "impure" as informal slang.. maybe better to say "wrapped"
01:49:06 <Peaker> so, $ for unwrapped applied to unwrapped.  <$> to apply unwrapped to wrapped.  =<< to apply wrapped-result-func to wrapped-arg,  and <*> to apply wrapped func to wrapped arg
01:49:35 <Wooga> ah, i see now. thank you for explainations
01:49:42 <Peaker> (where wrapped means wrapped by a type that happens to be a functor, monad or applicative, for <$>, =<< and <*> respectively
01:52:25 <taotree> Wow, I never thought just trying to convert between Float and Double would be so messy
01:54:54 <ion> > fromRational . toRational $ (42 :: Float) :: Double
01:54:56 <lambdabot>   42.0
01:59:14 <dafis> taotree: For Float -> Double conversion, you can use realToFrac (if you compile with optimisations, that gets rewritten to float2Double) or floatToDouble if you import GHC.Float, that's much faster and doesn't clobber NaNs
01:59:39 <dafis> s/floatToDouble/float2Double/
02:01:06 <augur> copumpkin!
02:01:27 <taotree> hayoo doesn't find floatToDouble
02:03:27 <taotree> dafis, thanks!
02:04:15 <dafis> taotree: typo, float2Double, and it's only in a GHC module, so it won't be in hayoo or hoogle
02:04:55 <dafis> taotree: so if you want to be portable, use realToFrac and compile with optimisations
02:06:36 <taotree> how non-portable is GHC module?
02:24:12 <frederik> 
02:29:47 <jsvc> Can I define a class which will only accept as instances types which only contain _|_?
02:31:44 <quicksilver> no.
02:31:52 <quicksilver> you can't make any restrictions on what kind of type can be an instance of a class
02:32:06 <quicksilver> beyond "must be able to write definitons for the methods"
02:32:20 <quicksilver> which, if you're considering _|_, is not a real restriction.
02:33:58 <jsvc> Thanks
02:35:33 <olsner> I guess that something like "class Foo a where foo :: b" is not legal?
02:37:22 <olsner> but "foo :: a -> b" would at least mention a, so I think that would be accepted
02:37:52 <jutaro> When will code.haskell.org be usable again?
02:38:05 <quicksilver> olsner: I'm not sure if it's illegal but it's certainly not useful.
02:38:39 <quicksilver> however with associated types you can, of course, do : class Foo a where type B a; foo :: B a;
02:44:17 <taotree> If I have an IO [[a]] and I want to map a function [a] -> b across it to get an IO [b] out... how do I do that inside a do block?
02:46:26 <comak> map?
02:46:59 <taotree> right... but just plain map gives error
02:47:17 <taotree> because it's not monadic kind of thing... yes, it's an easy question but I just haven't figured out this do block and monads yet
02:47:25 <comak> liftM map
02:49:30 <taotree> thanks
02:56:26 <Saizan> quicksilver: which is still usesless :)
02:57:06 <quicksilver> Saizan: ah yes, it has to be a data to be useful.
03:45:43 <Wooga> how do i perform IO action inside of enumerator: http://paste.pocoo.org/show/333638/ ?
03:49:16 <sgronblo> addtolast l toadd = (init l) ++ (toadd:(last l))
03:49:25 <sgronblo> Any idea what I am doing wrong here
03:49:43 <sgronblo> I think haskell is complaining about my use of the :
03:50:17 <pastorn> @type init
03:50:18 <lambdabot> forall a. [a] -> [a]
03:50:24 <nlogax> @type last
03:50:24 <pastorn> @type last
03:50:25 <lambdabot> forall a. [a] -> a
03:50:26 <lambdabot> forall a. [a] -> a
03:50:27 <nostrand> sgronblo: change to [last l]
03:50:29 <dafis> sgronblo: init l ++ [toadd,last l], probably
03:50:59 <sgronblo> but l should be a list of lists
03:51:24 <sgronblo> so last l should also be a list?
03:51:43 <dafis> preflex: seen tibbe
03:51:43 <preflex>  tibbe was last seen on #haskell 13 hours, 1 minute and 59 seconds ago, saying: dafis: thanks
03:52:14 <sgronblo> addtolast ["foo", "baar"] 'c' should return ["foo", "cbaar"]
03:52:54 <dafis> sgronblo: init l ++ [toadd:last l], then
03:55:06 <sgronblo> aah of course
04:00:04 * hackagebot graph-rewriting 0.5.2 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.5.2 (JanRochel)
04:01:05 <Wooga> i tried to use liftIO, but it didn't helped: http://paste.pocoo.org/show/333644/
04:07:11 <dafis> Wooga: What's runIteratee? I can't find it in the iteratee docs.
04:07:29 <Wooga> dafis: not iterate-, enumerator package
04:07:36 <Wooga> http://hackage.haskell.org/packages/archive/enumerator/0.4.6/doc/html/Data-Enumerator.html
04:07:45 <dafis> Ah
04:08:11 <Wooga> i tried to apply examples at http://docs.yesodweb.com/blog/enumerators-tutorial-part-2/ . but it didn't worked
04:16:04 <dafis> Wooga: The docs say that if m is a MonadIO, so is (Iteratee a m). GHC seems to disagree, the typical suspect for such incidents nowadays is an mtl-version conflict. You have imported Control.Monad.Trans, which is an mtl module, while enumerator depends on transformers (there, MonadIO is defined in Control.Monad.IO.Class). With mtl-2.*, that doesn't matter since that is just a wrapper around transformers, so I suspect you have mtl-1.
04:16:04 <dafis> * and ghc looks for an instance of a different class than is provided. Change the import to Control.Monad.IO.Class and try again.
04:18:17 <Wooga> dafis: thank you very much! this worked! so, it is better to upgrade to mtl-2 ?
04:18:47 <Wooga> i see them in haskell overlay, yet they are masked
04:19:08 <Wooga> not just by ~amd64, but with [M]
04:19:57 <dafis> Wooga: That depends. If you have libraries built against mtl-1.*, you'd have to recompile them, which can be a hassle. But getting rid of mtl-1 and installing mtl-2 would at least prevent further such issues.
04:20:42 <gienah> Wooga: if this is gentoo we try to convince stuff to compile with mtl-2 with ghc 7
04:21:54 <Wooga> so i need both ghc7 and mtl-2 ? won't it bite that they are hard-masked?
04:22:09 <Wooga> yep, it is gentoo
04:22:47 <dafis> Wooga: You could also cabal install stuff.
04:23:26 <gienah> Wooga: I build stuff with ghc 7 and mtl 2 in the gentoo overlay, I just great a large /etc/portage/package.keywords file which is symlinked to /etc/portage/package.unmask to unmask it :-)
04:24:42 * gienah opened a pull request to bump yesod to 0.7 and snap to 0.4 in the gentoo overlay
04:29:25 <aib> I'm following a beginner's tutorial and just wondered if it would be possible to write a "AND predicates together" function: (andp even odd), which would return a predicate that would return true if both parameters would return true
04:30:36 <dafis> aib: sure it's possible, and p q x = p x && q x
04:31:09 <dafis> aib: There are some elegant combinators to achieve that too, but that's for next month :)
04:31:17 * hackagebot HipmunkPlayground 5.2.0.3 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.3 (FelipeLessa)
04:31:23 <aib> dafis: and currying would take care of multi-parameter boolean functions?
04:31:41 <dafis> aib: yes
04:32:16 <dafis> another way to write it is andp p q = \x -> p x && q x
04:32:46 <aib> dafis: right. somehow I just thought (p && q) would be enough, and now I think it's clearing up
04:32:50 <aib> dafis: excellent. thanks a lot.
04:36:11 <parcs> > let f &.& g = \x -> f x && g x in (odd &.& (<10) &.& (>0)) 5
04:36:12 <lambdabot>   True
04:36:35 <dafis> :t ((uncurry (&&) .) .) . (&&&)
04:36:37 <lambdabot> forall (a :: * -> * -> *) b. (Functor (a b), Arrow a) => a b Bool -> a b Bool -> a b Bool
04:37:09 <dafis> :t ((uncurry (&&) Prelude..) Prelude..) Prelude.. (&&&)
04:37:09 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
04:38:26 <parcs> :t uncurry (&&) .: (&&&)
04:38:27 <lambdabot>     Couldn't match expected type `Bool' against inferred type `(c, c')'
04:38:27 <lambdabot>       Expected type: (Bool, c) -> (Bool, c') -> (Bool, Bool)
04:38:27 <lambdabot>       Inferred type: (Bool, c) -> (Bool, c') -> (Bool, (c, c'))
04:38:29 <aib> o_O I really hope those weren't meant for me
04:38:46 <parcs> :t uncurry (&&) .:: (&&&)
04:38:46 <lambdabot> Not in scope: `.::'
04:38:49 <parcs> :(
04:39:09 <dafis> :t (.:)
04:39:10 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:39:19 <parcs> aib: what looks like magic now will look very familar very soon
04:40:19 <aib> I was looking for how to make it into a binary function, too, so I could define an operator. I think the \ thing does it. I cannot wait to learn more
04:42:50 <aib> though work calls. gotta context switch back to my PHP mindset *shudder*
04:43:02 <dafis> commiserations
04:52:28 <astroboy> I am building a simple hakyll website, but syntax highlighting doesn't seem to work
04:53:03 <astroboy> I mean if I compile pandoc with -fhightlighting it inserts spans and stuff like that, but am I supposed to write a custom css file?
04:53:55 <Boxo> > liftM2 (&&) odd (==3) 3
04:53:56 <lambdabot>   True
04:54:00 <Boxo> > liftM2 (&&) odd (==3) 4
04:54:02 <lambdabot>   False
04:57:33 <dafis> > (&&) <$> odd <*> (< 6) $ 5
04:57:35 <lambdabot>   True
05:19:13 <inetic> hi, every single forum entry about parsing binary data points to Binary.Get lazy and strict version, but I can't find a way to seek using this API, which I think makes those libraries very restricted. Or am I missing something?
05:20:15 <dankna> @hackage binary
05:20:16 <lambdabot> http://hackage.haskell.org/package/binary
05:20:39 <dankna> (that was just for me to see it, I haven't used it before myself)
05:21:07 <dankna> looks like it works on lazy bytestrings.  so you want to use the bytestring library to do the actual reading, then binary to do the decoding.
05:21:36 <dankna> you can seek around in the file with the normal functions from System.IO, then do an hGet or whatever it's called from Data.ByteString.Lazy.
05:21:42 <dankna> does that help you?
05:25:05 <inetic> dankna, thanks, but it doesn't help. I guess the confusion on my part is how to get together the seeking and reading. this is my situation in particular:
05:25:16 <dankna> if you're about to paste a large chunk of code
05:25:18 <dankna> use hpaste instead
05:25:28 <dankna> @where hpaste
05:25:29 <lambdabot> http://hpaste.org/
05:25:38 <inetic> no no, just gonna describe the problem
05:25:55 <dankna> okay
05:26:32 <inetic> I've got a huge file (~4GB) which represents a tree structure, one node of the tree contains offsets to its childs
05:27:20 <inetic> so, I need to be able to jump to a distant offsets after reading the list of child offsets
05:27:37 <dankna> :t hseek
05:27:38 <lambdabot> Not in scope: `hseek'
05:27:41 <dankna> :t hSeek
05:27:42 <lambdabot> Not in scope: `hSeek'
05:27:54 <dankna> bah
05:28:01 <dankna> well, http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/System-IO.html search in page for hSeek
05:28:12 <inetic> I understand that I can seek using hSeek and that I can parse data using data.binary, but I don't see how to do both things at once
05:28:18 <dankna> well
05:28:21 <dankna> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.9/doc/html/Data-ByteString-Lazy.html
05:28:37 <dankna> hGet :: Handle -> Int -> IO ByteString on that page
05:29:01 <dankna> you would do a seek on the handle, then an hGet of some safe number of bytes, at least as many as you're going to want to decode.  I presume your nodes are fixed-length structures so that should be easy.
05:29:22 <dankna> but if they were variable-length you would do the length field and then separately do the rest of it
05:29:50 <dankna> doing the hGet (using the version of hGet from the bytestring library, not from base) will give you a lazy ByteString
05:29:57 <dankna> which you can then call the methods from binary on
05:31:02 <sinisa> Is there a way to use Text.Printf.printf in combination with Data.Text? I'd like to supply printf with Data.Text.Text values and have it return a Data.Text.Text value. Can this be done efficiently?
05:31:03 <hvr> I've got about 20 (!!) operations in a concurrently executing program, of which one fails with `Prelude.(!!): index too large`; what's the recommended way to find out which source-location triggeres the error?
05:31:39 <dankna> hvr: there is no special trick to it, that's why functions that throw errors from pure code are things to be avoided :(
05:31:52 <dankna> hvr: you can try commenting them out one at a time
05:32:16 <inetic> dankna, you type fast! :-) thanks. gonna try it
05:32:17 <dankna> sinisa: I'm certain it can be done but I don't know how
05:32:23 <dankna> inetic: thanks hehe, good luck :)
05:33:24 <hvr> dankna: I hoped there would be some ghc-extension that could annotate the error-site somehow with source-locations...
05:33:34 <dankna> hvr: yeah, I hoped that once too :(
05:33:42 <dankna> the problem is that even if it did that
05:33:59 <dankna> the actual thing that triggers the error can be later, when the value is forced, rather than immediately when that line is executed
05:34:19 <hvr> yeah, but that's not a problem for me...
05:34:20 <dankna> because that's the meaning of pure code, it doesn't need to happen in any particular order
05:34:27 <hvr> I want the location of the (!!)
05:34:33 <hvr> not the place where it exploded :)
05:34:33 <dankna> no, but it would be a problem for the compiler if it tried to tell you that
05:34:50 <dankna> anyway, it might be possible to have such an extension someday, but we don't right now
05:35:29 <hvr> would a debugger like 'hat' be of any help?
05:35:35 <dankna> oh hey
05:35:37 <dankna> I googled a bit
05:35:44 <dankna> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:assert
05:35:59 <dankna> try replacing every call to (!!) with something like
05:36:24 <hvr> looks good... thx for the pointer
05:36:31 <dankna> assert (length myList > myIndex) (myList !! myIndex)
05:36:37 <dankna> I didn't know that existed
05:36:40 <dankna> np
05:51:01 <jonkri> what does it mean when r is a function in (:t ReaderT:) ReaderT :: (r -> m a) -> ReaderT r m a? how do access it using ask?
05:51:41 <quicksilver> "myfun <- ask; return (myfun someparameter)" ?
05:55:30 <jonkri> ah, of course :)
05:56:41 <quicksilver> obviously you don't have to use 'return' 
05:56:48 <quicksilver> it was just an example of how you might use the function.
05:59:17 <xplat> 05:48 < jsvc> Can I define a class which will only accept as instances types  which only contain _|_?
05:59:39 <xplat> you CAN do this
06:00:11 <xplat> at least if you ignore that someone can implement a method as 'undefined' too
06:00:38 <jonkri> @src runReaderT
06:00:38 <lambdabot> Source not found. My pet ferret can type better than you!
06:00:57 <yitz> @hoogle runReaderT
06:00:57 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
06:00:59 <xplat> just require one method to be a function from the instance type to a type that only contains _|_
06:02:03 <jonkri> @src Control.Monad.Reader.runReaderT
06:02:04 <lambdabot> Source not found.
06:02:10 <jonkri> @src Control.Monad.Reader runReaderT
06:02:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:03:07 <jonkri> @src Control.Monad.Reader.ReaderT
06:03:07 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:03:15 <jonkri> @src Control.Monad.Reader ReaderT
06:03:16 <lambdabot> Source not found. Sorry.
06:03:20 <jonkri> ok, enough spamming :P
06:03:23 <xplat> if you were in something like agda you could probably require the method to be total, then you would have it absolutely, but in haskell you have to trust the user to implement it without 'cheating', so it's not a completely reliable check
06:04:07 <hpc> xplat: i think you can still safely trust haskell programmers
06:04:33 <hpc> the monad laws are a good example of how well those sorts of rules are followed
06:07:16 <Saizan> class Void v where void :: v -> b
06:07:39 <Saizan> with a default definition void = undefined :)
06:07:49 <xplat> man, i wish people wouldn't use Data.Enumerator and help its popularity
06:08:30 <opqdonut> how come?
06:08:37 <tab> xplat: huh ?
06:09:22 <jonkri> if you wanted to add a certain monad transformer on top of an arbitrary monad, with its behavior customized by a number of input arguments, how would you do it? how can you "initialize" it (from like a do block)?
06:09:39 <xplat> an interface should be simple enough, but not too simple.  Data.Enumerator's interface is not simple enough, but is too simple.  you can't even use a bytestring as a chunk.
06:10:12 <tab> xplat: you can ..
06:10:58 <xplat> unless the interface was changed, a chunk can only be a list
06:12:10 <tab> and a bytestring is a list of word8
06:12:29 <xplat> so you have to wrap a bytestring in a needless list, which means you either need an extra level of folding or an unenforceable assumption that your chunk is in the image of maybeToList
06:14:08 <xplat> tab: a bytestring is a bytestring.  a lazy bytestring has a list of strict bytestrings inside but that is not exposed in the interface, you would have to unwrap and rewrap with toChunks and fromChunks which is confusing since now you have two kinds of chunks.  a strict bytestring is not a list of anything, even internally.
06:14:46 <xplat> and converting a strict bytestring to a list of Word8 is expensive
06:15:40 <tab> if you're using strict bytestring, it shouldn't matter to you
06:15:52 <tab> and using lazy bytestring, is transparent as it's a list underlying
06:16:25 <xplat> tab: why shouldn't it matter to me if i am using strict bytestring?
06:16:59 <tab> because you shouldn't have big strict bytestring
06:17:21 <xplat> i don't want a big strict bytestring, just chunk-sized
06:17:47 <hpc> :t toChunks
06:17:48 <lambdabot> Not in scope: `toChunks'
06:18:02 <tab> xplat: that's exactly what toChunks is doing then :)
06:18:04 <xplat> :t BSL.toChunks
06:18:06 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
06:18:10 <jix> xplat: I can imagine a use case for getting passed multiple chunks in one step, but I agree it's not a good default
06:18:42 <xplat> i want strict bytestring the size of an iteratee chunk, not bytestring chunk :)
06:19:32 <jix> If you do some processing that gets faster when you have larger amounts of data to process at once... but that should be an exception
06:19:46 <xplat> bytestring chunk is fine for intermediate trees but too small for OS-level IO
06:24:38 <xplat> anyway if i was going to simplify iteratees for programmers, the thing to do is write better docs and better combinators for handrolls
06:26:01 <xplat> not mess around eliminating important typeclasses that help to achieve the advantages that make people try to understand iteratees in the first place
06:32:52 <jonkri> is there a haskell api for darcs? i can't seem to find anything about it on darcs.net
06:35:37 <dankna> jonkri: I don't believe so, I think just the command-line tool.  Why, what are you trying to do?
06:35:50 <dankna> jonkri: but it does have the useful --xml option for getting information into other programs
06:39:34 <jonkri> dankna: i was just thinking about how hard it would be to create a darcs repository web application in haskell
06:40:08 <jonkri> just curious
06:41:16 <xplat> i guess i forgot to note this: no matter how much i hate their interface decisions, i have to have some respect the brain of someone who can create a working iteratee/enumerator library at all ...
06:41:18 <dankna> jonkri: I'm not sure what darcsweb is written in
06:41:32 <dankna> jonkri: it would be a nice thing, and it's somewhere down my to-do list
06:41:47 <dankna> jonkri: the output of "darcs annotate", in particular, is of marvelous utility
06:41:59 <quicksilver> darcsweb is in python
06:42:05 <quicksilver> and I think it parses the XML you mentioned.
06:42:44 <jonkri> dankna: you have a long todo list too?:)
06:43:02 <jonkri> i see
06:43:22 <xplat> oh man, todo lists
06:43:41 <xplat> if i rolled up mine and threw it at somebody's head, they would die
06:43:50 <jonkri> :P
06:44:00 <dankna> quite so
06:44:06 <dankna> xplat: yours is thin enough to roll up?
06:44:43 <dankna> if you have the time and expertise, you could always go and make an API for it
06:44:45 <jix> my todo list developed significant gravitational pull..
06:44:51 <dankna> the code is pretty clean as I recall
06:44:53 <xplat> dankna one long piece of paper, not leaves :)
06:44:58 <dankna> xplat haha okay then
06:46:24 <jonkri> i'm afraid i have neither, but some day hopefully :)
06:47:00 <dankna> nodnod
06:55:40 * edwardk waves hello.
07:06:08 <tromp> hi edward. how do you emote again?
07:14:42 <Younder> \emote hi
07:15:04 <chrisdone> Dons isn't in here? :/
07:16:06 <mun> If i have a bunch of rules, incl. "x=1 --> y=1" where x and y are variables, is there a way I can quantify over the condition to check whether there's a condition in my rules such that "y=1"? If I have "exists P. P --> y=1", which seems to be what I want, but it's trivially True. Is there another way to formulate it?
07:16:15 <mun> assume I'm working in HOL.
07:16:20 <edwardk>    /me
07:17:16 * tromp waves back
07:17:21 <tromp> thx
07:17:34 * edwardk is having fun with the semigroupoid lib, it lets me make a category-like object out of matrices
07:18:02 <edwardk> Matr_k is a fairly traditional category and it always galled me that i couldn't encode it using the Category class
07:20:35 <edwardk> build a lib of zeroless-binary based natural numbers the other day, this is nice because vectors indexed by them obviously can provide logarithmic access, and tries for those vectors are just binary trees.
07:26:14 <tromp> what's the point of being zeroless?
07:26:55 <merijn> > let x = [41, 32, 28, 37, 41, 42] in (sum x) / (length x)
07:26:57 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
07:26:57 <lambdabot>    arising from a use o...
07:27:08 <merijn> Any clues what I'm doing wrong?
07:27:27 <tromp> > 3/2
07:27:28 <lambdabot>   1.5
07:27:37 <edwardk> tromp: a lot of operations on arbitrary precision binary numbers want you to normalize the representation. e.g. you want to not have any 0's before the 'infinite tail of zeros'
07:27:37 <tromp> > 3 / (2::Int)
07:27:38 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
07:27:38 <lambdabot>    arising from a use o...
07:28:05 <merijn> > let x = [41, 32, 28, 37, 41, 42] in (sum x) / (fromIntegral $ length x)
07:28:07 <lambdabot>   36.833333333333336
07:28:13 <merijn> That's dumb...
07:28:19 <edwardk> tromp: working with zeroless binary each place in the number retains its same value, the nth digit is still worth 2^n, but the values you use are 1 and 2, instead of 0 and 1, therefore the only 0, is the 'infinite tail of 0s'
07:28:24 <tromp> that's strong typing
07:28:34 <Maxdamantus> @pl \(a,b) -> (f a, g b)
07:28:35 <lambdabot> f *** g
07:28:47 <Maxdamantus> :t (***)
07:28:48 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:29:06 <merijn> > 3 / (2 :: Integer)
07:29:07 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
07:29:08 <lambdabot>    arising f...
07:29:41 <Maxdamantus> :t (/)
07:29:42 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:29:50 <Maxdamantus> :info Integer
07:29:52 <tromp> right; edward, i remember even discussing that in a paper of mine
07:30:13 <merijn> Maxdamantus: Integer is just the arbitrary precision variant of Int
07:30:20 <Maxdamantus> I know.
07:30:20 <edwardk> tromp: the nice thing is that you don't have to contort to retain this invariant
07:35:41 <tromp> so zeroless means not using the digit 0, you still have a representation for zero, namely the empty string
07:42:02 * hackagebot HDBC-odbc 2.2.3.2 - ODBC driver for HDBC  http://hackage.haskell.org/package/HDBC-odbc-2.2.3.2 (JohnGoerzen)
07:47:36 <applicative> do people have much experience with c2hs? or is it hopelessly difficult?
07:55:32 <thoughtpolice> applicative: i actually like c2hs, although other people have gone other routes, e.g. the bindings-* libraries. i'll say c2hs doesn't have spectacular documentation or examples, though
08:08:07 <zelvosaur> hello, what library would you recommend for parsing simple xml? I've been looking at HaXml, but so far I was not able to find any usable tutorial to get me started
08:11:00 <quicksilver> tagsoup is good for simple jobs.
08:11:03 <quicksilver> and some less simple ones.
08:11:50 <zelvosaur> thanks, I'll have a look at it
08:13:22 <mun> I have a somehow logic-centric question: if i have a bunch of rules, incl. "x=1 --> y=1" where x and y are variables, is there a way I can quantify over the condition to check whether there's a condition in my rules such that "y=1"? If I have "exists P. P --> y=1", which seems to be what I want, but it's trivially True. Is there another way to formulate it? assume i'm working in HOL.
08:13:32 <Philonous> applicative: c2hs is actually quite easy to use. Unfortunately the documentation is less than stellar.
08:18:51 <tony_> timer 3 /help
08:24:53 <kfr> http://hackage.haskell.org/package/regex-pcre-0.94.2 <- urgh I wish I knew how to use this
08:27:13 <kfr> I just want to perform PCRE replacements hm
08:28:48 <kfr> Oh actually I don't even need the Perl one
08:30:45 <kfr> Hm not even .+? is allowed then though? :[
08:30:47 <kfr> Is that already PCRE?
08:34:27 <kfr> Bah, I don't know which regex package to use, there are so many
08:43:31 <kfr> mkRegex fill fail with a.+?b hm
08:46:01 <mun> in haskell, how does one demonstrate let-polymorphism?
08:47:14 <kfr> What do you mean by that?
08:47:30 <kfr> > let f x = (x, x) in (f 1, f "olol)
08:47:32 <lambdabot>   <no location info>:
08:47:32 <lambdabot>      lexical error in string/character literal at end o...
08:47:39 <kfr> > let f x = (x, x) in (f 1, f "olol")
08:47:40 <lambdabot>   ((1,1),("olol","olol"))
08:47:48 <ClaudiusMaximus> > let f = floor ; x = 4.5 :: Double in (f x, f y) :: (Int, Integer)
08:47:49 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
08:47:49 <lambdabot>    arising from a us...
08:47:54 <ClaudiusMaximus> oops...
08:48:02 * ClaudiusMaximus heads back afk
08:48:24 <hape01> Hi, in an IO Action   i have an [FilePath] variable, which I want to print out to screen. When I putStrLn x it says coulnt match expected type Char against inferred type [Char] - expected Type Stirng: Inferred Type: [FilePath]. How do I print this to screen?
08:48:50 <kfr> type FilePath = String
08:48:56 <kfr> That's a list of paths
08:49:03 <kfr> :t unwords
08:49:05 <lambdabot> [String] -> String
08:49:17 <hape01> kfr: I have an array of FilePaths [...]
08:49:24 <kfr> No, a list
08:49:26 <kfr> An array is not a list
08:49:27 <mun> right
08:49:34 <kfr> putStrLn $ unwords listOfPaths
08:49:39 <kfr> Something like that perhaps
08:50:07 <hape01> kfr: You saved my day :-)
08:50:21 <hape01> kfr, mun, lamdabot: Thank you
08:50:30 <kfr> putStrLn . unwords $ map (\x -> "\"" ++ x ++ "\"") listOfPaths
08:50:33 <kfr> lambdabot is a bot
08:50:36 <kfr> It requires no thanks
08:50:51 <djahandarie> @vixen Do you require thanks?
08:50:52 <lambdabot> good question
08:51:06 <djahandarie> @botsnack
08:51:07 <lambdabot> :)
08:51:45 <ClaudiusMaximus> @check (\x -> "\"" ++ x ++ "\"" == show x)
08:51:46 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\372388\"\n"
08:51:49 <hape01> :-)
08:52:44 <kfr> So uhm how do you perform Perl compatible regex replacements in Haskell?
08:55:25 * hackagebot anatomy 0.4 - Anatomy: Atomo documentation system  http://hackage.haskell.org/package/anatomy-0.4 (AlexSuraci)
08:55:27 * hackagebot atomo 0.4 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.4 (AlexSuraci)
08:55:45 <djahandarie> Fun!
08:56:13 <djahandarie> Ah, I remember this
08:56:51 <dankna> okay so
08:56:56 <dankna> I don't need help with this code; I got it working
08:57:02 <dankna> I need sympathy for what I had to go through
08:57:02 <dankna> http://hpaste.org/43733/sympathize_with_me
08:57:45 <dankna> as you can see, I have to do a particularly nasty trick where I suppress inclusion of <limits.h> /by including it first/ and then undefining everything it defines
08:57:53 <dankna> the obvious simpler strategy doesn't work, for reasons explained in the paste
08:58:00 <Veinor> ]d]on[YwkAdrA[: haha, ouch
08:58:05 <Veinor> ... how did that happen
08:58:07 <dankna> I had hoped to get away from cpp in haskell, but ah well
08:58:11 <dankna> thanks Veinore :)
08:58:13 <djahandarie> hahaha Veinor
08:58:19 <Veinor> on, i hit don and tab-completed, and weechat ignores brackets apparently
08:58:22 <monochrom> wait, don't you just #define _LIMITS_H_ or something?
08:58:27 <dankna> monochrom: read the paste
08:58:34 <dankna> monochrom: I researched and explained why that doesn't work
08:58:39 <monochrom> nevermind
08:58:40 <dankna> haha
08:59:15 <dankna> anyway, one step closer to making direct-cocoa work :)
09:00:11 <monochrom> the linux version of limits.h uses _LIBC_LIMITS_H_
09:00:27 * dankna nods
09:00:31 <kulakowski> dankna: I empathize. The C preprocessor hasn't aged gracefully.
09:00:38 <dankna> thanks kulakowski :)
09:00:51 <dankna> well, I do at least have the luxury of assuming this code will only run on a Mac, as its purpose is Mac-specific
09:01:11 <dankna> even for cases where the library it generates will be run on other systems, the generation itself will have to be on a real Mac
09:01:38 <monochrom> I carefully said "or something" to allow for the exact name not being _LIMITS_H_. I'm almost certain every platform uses a different name.
09:01:44 <dankna> oh absolutely
09:01:51 <dankna> but in fact I saw behavior where cpp flat out ignored my #define
09:02:06 <dankna> I tested with invoking cpp by hand to be sure it wasn't some quirk of how ghc calls it
09:02:55 <dankna> I don't care enough to read the gcc/cpp source, but I speculate that it's a quirk designed to keep users from accidentally preventing limits.h from loading
09:03:14 <mun> if a logic has type variables but no let-polymorphism, then is it still polymorphic?
09:04:19 <monochrom> I don't sympathize yet because I am still skeptical.
09:04:31 <dankna> well
09:04:41 <dankna> maybe I DO care enough to read the cpp source :)
09:04:45 <monochrom> "unknown reason but I guess" is bad science.
09:05:10 <dankna> yeah, but it's cpp.  I find it hard to care about WHY it works as long as it does (and keeps working).
09:05:54 <Saizan> mun: System F is also called "the polymorphic lambda calculus" so i'd say yes
09:06:35 <djahandarie> mun, let polymorphism is only one type of polymorphism, there are other kinds.
09:09:14 <Blkt> good evening everyone
09:09:18 <djahandarie> Though it's worth noting that any language using Hindley-Milner will be using let polymorphism
09:09:25 <djahandarie> I'm fairly sure at least
09:11:49 <mun> ah ok
09:17:25 <mun> djahandarie, but what makes Hindley-Milner significant?
09:18:00 <djahandarie> Do you care about type inference? :P
09:19:31 <dankna> monochrom, I'm looking at the cpp source now.  I found that it definitely has special-casing for macros that surround an entire file.
09:19:56 <dankna> I found a snippet of code which looks to me as though it makes such macros invalid when they occur outside that file itself
09:20:00 <dankna> if so, this is arguably a cpp bug
09:20:19 <Veinor> file it!
09:20:27 <dankna> *snrk* not worth it
09:20:52 <monochrom> it looks at filename and decides to reject some #define's?
09:20:54 <dankna> they'd just say "but the standard allows macros starting with _ to have special behavior", which is true
09:21:23 <dankna> monochrom: yes.  it has a little state machine that detects the #define's in question.
09:22:32 <kfr> Odd, this thing doesn't work for me when decoding HTML entities: http://hackage.haskell.org/package/web-encodings
09:22:44 <kfr> Prelude Web.Encodings> decodeHtml "a&nbsp;b"
09:22:44 <kfr> "a&nbsp;b"
09:22:44 <dankna> it's part of an optimization to avoid having to lex the entire file repeatedly, see
09:22:46 * kfr puzzled
09:23:05 <kfr> Prelude Web.Encodings> decodeHtml "&#32;"
09:23:05 <kfr> " "
09:23:09 <kfr> At least that one works
09:23:13 <monochrom> what is the semantics of decodeHtml? nevermind the "meaningful" name.
09:23:21 <dankna> what would you like it to be translated to, kfr?  does nbsp have a Unicode codepoint?
09:23:29 <kfr> dankna: " "
09:23:44 <dankna> that's incorrect.  it's not a space.  it's a nonbreaking space.
09:24:00 <monochrom> Did you read the doc? "Note: this does not support all HTML entities available. It also swallows all failures."
09:24:17 <kfr> nbsp is like the most basic one :/
09:24:31 <kfr> The library I used in Ruby supported this just fine hmm
09:24:40 <kfr> I really don't want to write my own from scratch, bah
09:24:42 <quicksilver> yes, unicode has several non-breaking-space type chars.
09:24:51 <kfr> Doesn't matter, I want that mapped to " "
09:24:59 <kfr> Just like in every other HTML entitity decoding lib I've used before
09:25:01 <dankna> kfr: cabal unpack web-encodings and get cracking
09:25:15 <monochrom> HXT does what you want.
09:25:50 <mun> djahandarie, right. then is let-polymorphism central to type inference?
09:25:52 <kfr> monochrom: Text.XML.HXT.Parser.XhtmlEntities?
09:26:08 <kfr> Oh that's just a list of tuples
09:26:12 <monochrom> or more simply Text.XML.HXT.readDocument
09:26:40 <Maxdamantus> > toEnum 0xa0 :: Char
09:26:41 <lambdabot>   '\160'
09:26:55 <Maxdamantus> > text $ toEnum 0xa0 : ""
09:26:56 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
09:27:54 <monochrom> err, Text.XML.HXT.Arrow.ReadDocument.readDocument . it also ought to be re-exported somewhere.
09:27:55 <djahandarie> mun, that's how HM was originally presented. And rank-n polymorphism breaks type inference I think you need to stick to let polymorphism. But I'm not an expert here so I could be wrong
09:28:04 * djahandarie runs to class
09:29:03 <kfr> monochrom that appears to be a full XML parser :| whereas I am not even dealing with markup
09:29:36 <monochrom> or a full HTML parser
09:31:39 <gwern> when does the summer of code start taking applications, anyone remember?
09:32:43 <dankna> meh
09:33:12 <dankna> I'd love to participate in SoC, but I can't because I don't meet the eligibility criteria :(
09:33:47 <gwern> I can't either, but I'm still interested in what makes a good SoC project and how past ones have succeeded or failed
09:33:51 * gwern is updating http://www.gwern.net/Haskell%20Summer%20of%20Code.html
09:33:57 <Wooga> what is "transformator" in context of haskell? where i can read more about that?
09:33:58 <dankna> gotcha
09:34:14 <monochrom> never heard of transformator
09:34:17 <Wooga> transformer*
09:34:19 <Wooga> sorry
09:34:50 <dankna> Wooga: monad transformer; look for the mtl or transformers packages (two alternate versions of the same thing)
09:35:13 <aristid> i guess Wooga wants a tutorial, not reference documentation
09:35:25 <Wooga> yes, i need basic understanding of what it is
09:35:25 <dankna> yeah, I'm not good at finding tutorials :)
09:35:39 <aristid> i don't remember where i learned what transformers are :/
09:36:10 <Wooga> hm, sorry once again
09:36:15 <Wooga> i should try google first
09:36:18 <Wooga> http://en.wikibooks.org/wiki/Haskell/Monad_transformers
09:36:51 <aristid> MaybeT \o/
09:43:52 <djahandarie> What are the criteria for a SoC?
09:44:49 <gwern> be a college student, mostly
09:45:24 <gwern> preflex: seen gracenotes
09:45:25 <preflex>  gracenotes was last seen on #haskell 1 day, 12 hours, 11 minutes and 42 seconds ago, saying: ...roughly
09:46:44 <djahandarie> http://hackage.haskell.org/trac/summer-of-code/ticket/1541 looks like fun
09:49:54 <djahandarie> gwern, http://www.google-melange.com/document/show/gsoc_program/google/gsoc2011/faqs#timeline perhaps relevant if you haven't already gone there yourself
09:50:15 <gwern> djahandarie: thanks
09:51:16 <gwern> hm. does anyone use the new cabal test support?
09:51:28 <tibbe> gwern, I've tried it yes.
09:51:43 <tibbe> gwern, it will get easier once cabal-install 0.10 is released
09:51:43 <dcoutts> gwern: there are a few users so far, it's not that easy yet since cabal-install-0.10 is not released yet
09:51:49 <gwern> tibbe: but do you *use* it in a published package?
09:52:00 <dcoutts> gwern: there are already a few on hackage
09:52:01 <tibbe> gwern, do I, hashable I guess?
09:52:14 <tibbe> gwern, the package should still build with Cabal-1.8
09:52:25 <gwern> dcoutts: hm. I don't know the details, why does one need cabal-install 0.10?
09:52:29 <djahandarie> edwardk, still interested in mentoring that GSoC task I linked? ;)
09:52:47 <tibbe> dcoutts, does "Making persistent data structures faster using hashing" makes sense as a title of a talk?
09:52:57 <tibbe> dcoutts, I'm giving one about my two hash map implementations
09:53:00 <dcoutts> gwern: one needs to use Cabal 1.10 to be able to actually run the test suite, that's easier if you're using a cabal-install that's built against Cabal 1.10
09:53:44 <dcoutts> tibbe: sure, or perhaps snappier "Faster persistent data structures through hashing"
09:53:49 <gwern> tibbe: I'd prefer 'Hashing for faster persistent data structures' or maybe the opposite, 'x with hashing'
09:54:53 <tibbe> dcoutts, gwern, thanks!
09:55:34 <gwern> tibbe: was the test support useful and easy to use? do you think many will use it?
09:56:02 <edwardk> djahandarie: back was afk
09:56:09 <tibbe> gwern, I'm biased, I mentored the project
09:56:13 <gwern> oh :(
09:56:15 <tibbe> gwern, but yes, I think so
09:56:22 * gwern will mark it successful with a question mark, then
09:56:32 <edwardk> djahandarie: link?
09:56:40 <tibbe> gwern, the output could need a little polishing but it's quite easy to convert e.g. a test-framework test suite to use it
09:56:43 * tibbe gotta run
09:56:47 <djahandarie> edwardk, http://hackage.haskell.org/trac/summer-of-code/ticket/1541
09:56:50 <tibbe> ttyl!
09:57:12 <edwardk> ahh. i remember now
09:57:23 <gwern> djahandarie: that reads like a masters or phd thesis than a SoC project for the masses :)
09:57:36 <gwern> *more like
09:57:39 <edwardk> definitely put in an application, but it may have trouble making the cut
09:57:53 <djahandarie> I'm sure I could make it sound interesting somehow
09:58:00 <edwardk> typically with gsoc, the ones that appeal to the masses get selected
09:58:05 <edwardk> *nods*
09:58:53 <ray> needs more buzzwords
09:59:05 * djahandarie buzzes around
09:59:17 <edwardk> hrmm, 3 weeks before i can put in the application for haskell.org for gsoc for this year.
09:59:33 <edwardk> marking it on the calendar
09:59:35 <gwern> edwardk: well, my understanding was that they were supposed to be efforts that were useful to FLOSS but hadn't been done because they required too much solid development effort. not for research
10:00:39 <edwardk> gwern: well, there are a number of these little type level programming libraries out there, so its not entirely a research effort. more a matter of stitching together stuff that has been done and trying to do some api design on tp
10:01:15 <edwardk> but like i said, its a bit of a hard sell when it goes up against someone who wants to extend the llvm back end or work on the gc, or  hack on primops or something
10:02:24 <gwern> the llvm backend work seems surprisingly successful to me
10:02:32 <djahandarie> I don't know why anyone would want to hack on GHC unless they are a masochist
10:02:45 <gwern> I would have predicted it would ultimately be scrapped or sidelined wiht 70-80% odds, but no, it seems to be the future now
10:02:46 <djahandarie> Or planning to get hired by Microsoft Research
10:02:49 <edwardk> yeah, it really drew in a different crowd
10:09:48 <gwern> well. the gobject SoC was a failure, as I predicted
10:09:51 <gwern> no one uses it
10:10:22 * Maxdamantus knows a guy who uses Seed.
10:10:53 <Maxdamantus> nvm, probably talking about some Haskell binding.
10:24:58 <harlekin> @pl (\f g a -> (f a) ++ (g a))
10:24:59 <lambdabot> liftM2 (++)
10:28:23 <gwern> ok, next topic. The Immix GC algorithm. http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760695 . I don't seem to see any mentions in the GHC repo history except an offhand 2009 remark by marlow that some change will make immix a little easier in the future
10:29:59 <zygoloid> gwern: there's a little info here: http://marcotmarcot.wordpress.com/
10:30:32 <gwern> zygoloid: http://marcotmarcot.wordpress.com/2010/08/20/immix-on-ghc-summer-of-code-final-report/ is kind of damning
10:30:51 <gwern> well, not damning, but I think justification to mark it unsuccessful
10:31:35 <aavogt> but you have a tendency to call gsoc projects unsuccessful
10:32:58 <aristid> aavogt: they aren't?
10:33:20 <aavogt> I dunno, they are successful enough to get payment
10:33:24 <gwern> aavogt: I don't think I do. there's a clear trend in recent years towards success
10:33:41 <gwern> aavogt: it's just the failures I ask about because no one minds being labeled a success, but they do mind being labeled a failure
10:34:24 <aavogt> no, labels are universally bad
10:34:26 <gwern> for 2010, I have 3 successes, 2 unknowns, and 2 unsuccessfuls
10:34:46 <gwern> and I expect at least 1 unknown to be updated to a success by next year
10:35:17 <zygoloid> i don't think marcot failed, but i don't think he succeeded either. if he comes forward with a couple of fixes, immix could easily become a success.
10:35:26 <copumpkin> or someone else
10:35:37 <zygoloid> (equally i think learning the ghc gc is at least as good as a decent immix implementation would count as success)
10:35:40 <copumpkin> edwardk said he's going to try to get us more GSOC slots this year
10:36:44 <gwern> zygoloid: well, something like GC has a threshold. if you miss by an inch it's as good as a mile
10:37:35 <gwern> you don't get it half-done and call it a pretty good job, like you could with optimization. ('oh, I know it theoretically could run at 5% of the original runtime, but I only got it down to 10%. well, that's still a major improvement.')
10:37:58 * hackagebot atomo 0.4.0.1 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.4.0.1 (AlexSuraci)
10:38:26 <alexsuraci> hooray for dependency hell. 0.4, i barely knew ye
10:38:59 <gwern> ('why, this is hell, nor am I out of it.')
10:39:21 <aristid> alexsuraci: dependency hell?
10:39:55 <aavogt> @nixon known knowns?
10:39:56 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
10:39:58 <alexsuraci> aristid: wasn't too bad, just annoying. a minor library I used set "cabal version >= 1.10", so no one could built it without manually fixing that
10:40:07 <alexsuraci> *build
10:40:16 <gwern> the only thing worse than dep hell is having so few libraries/apps that there is no dep hell
10:40:19 <gwern> or johnny depp
10:40:41 <aristid> alexsuraci: 1.10? a lot of people are on 1.8
10:40:51 <aavogt> scissorhands cuts through dep hell
10:40:54 <gwern> aavogt: if you're really offended, feel free to read http://www.gwern.net/Haskell%20Summer%20of%20Code.html#section-4 and tell me where I have erred
10:41:03 <alexsuraci> aristid: yes, that was the problem
10:41:19 <aavogt> gwern: nope, I'm a devils advocate at the moment
10:41:22 <aristid> alexsuraci: what did you do?
10:41:28 <gwern> aavogt: how appropriate
10:41:30 <aristid> (to fix it)
10:42:15 <alexsuraci> aristid: specified the "sane" version of the library, and re-released
10:42:36 <aristid> gwern: i think blaze can definitely be considered successful
10:42:41 <alexsuraci> which I probably should have done in the first place, didn't expect a small library to wreak such havoc though
10:43:07 <gwern> aristid: yes, but *why*? it doesn't have that many users. not nearly as many as xhtml
10:43:19 <aristid> gwern: blaze-builder is pretty popular
10:43:33 <q0tw4> I have complied yesod-0.7.0 with ghc-7.0.1 but devel server is not working because http://hackage.haskell.org/packages/archive/hint/0.3.3.1/logs/failure/ghc-7.0 :(
10:43:33 <aristid> snoyman and snap use it everywhere
10:43:36 <gwern> aristid: its popularity should be covered by the reverse deps shouldn't it?
10:43:48 <gwern> or does blaze-builder not depend on blaze-html?
10:43:58 * gwern assumed that it did, and didn't check
10:44:20 <aristid> gwern: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/blaze-builder
10:44:35 <gwern> oh, it doesn't
10:44:40 <gwern> what's up with that
10:44:55 <gwern> ok, 51 indirect deps is pretty succesful
10:45:11 <aristid> yeah :)
10:45:22 <aristid> blaze-html is just much less interesting than blaze-builder
10:45:30 <olsner> cool, hackage displays reverse dependencies
10:45:51 <gwern> olsner: well, that's one site that uses the new hackage, iirc. there's another demo of the new hackage
10:45:53 <aristid> gwern: but blaze-html also has 19 indirect
10:46:05 <aristid> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/blaze-html-0.4.0.0
10:46:16 <gwern> I was using http://sparky.haskell.org:8080/package/blaze-html-0.4.0.0/reverse
10:46:23 <gwern> which lists 12
10:46:26 <olsner> haha, didn't even notice that wasn't the real hackage
10:46:38 <gwern> olsner: you must get phished a lot -_-
10:47:12 <olsner> gwern: not that I've noticed :)
10:47:20 <olsner> ... yet
10:48:23 <stepkut> ooo. real xhtml, 'Content-Type: application/xhtml+xml'
10:48:26 <stepkut> from sparky
10:48:32 <stepkut> xesh
10:48:40 <stepkut> s/xesh//
10:50:15 <djahandarie> gwern, iteratees have been adopted pretty widely and that was originally from oleg
10:50:19 <djahandarie> (Re: footnote 3)
10:50:43 <gwern> djahandarie: yeah, I need to update that one. but we don't use oleg's code, just his ideas and he wasn't the one who spread it, was he?
10:51:09 <thoughtpolice> well, lato and oleg initially collaborated on the iteratee package and lato still maintains it
10:51:15 <gwern> (when I wrote that, iteratees hadn't appeared in the radar, IIRC, or maybe had some code on oleg's homepage and not much more)
10:51:24 <thoughtpolice> iteratee is considered rather 'heavyweight' though - once john's enumerator package hit, people started using it like crazy
10:51:30 <thoughtpolice> because conceptually it's simpler and more contained, IMO
10:51:34 <thoughtpolice> which is a good thing
10:52:05 * hackagebot graph-rewriting-trs 0.1 - Evaluate a first-order term rewrite system interactively using graph reduction  http://hackage.haskell.org/package/graph-rewriting-trs-0.1 (JanRochel)
10:52:09 <djahandarie> gwern, I suppose LogicT is also important?
10:52:19 <aavogt> @hackage haskelldb
10:52:20 <lambdabot> http://hackage.haskell.org/package/haskelldb
10:52:22 <Oejet> Hi, I could use a hint for implementing a monad with a certain signature: "getUser :: MyAppMonad (Maybe Text)". It will be used like this: foo :: Splice MyAppMonad / foo = do user <- liftM getUser .... I'm not sure where to begin?
10:52:44 <gwern> djahandarie: I dunno, is it?
10:52:51 <djahandarie> Zippers too
10:53:06 <djahandarie> gwern, I actually haven't used it myself but I constantly hear it mentioned
10:53:11 <gwern> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/logict-0.4.2#direct isn't very impressive
10:53:24 <zygoloid> Oejet: what's Splice here?  a type synonym?
10:53:32 <djahandarie> Zippers I do use when I need 'em though
10:53:39 <djahandarie> And they made it into LYAH too
10:53:53 <djahandarie> That site doesn't load for me :(
10:53:58 <gwern> and heck, I think lambdabot only depends on logict as a courtesy to mueval and people who want to play with logict in #haskell
10:54:38 <gwern> djahandarie: well, there's just 4 direct or indirect users. stream-monad, cflp, djinn-th, and lambdabot
10:54:53 <djahandarie> That is not very impressive. :P
10:55:07 <djahandarie> I guess it's just in here that it's mentioned a lot
10:55:17 <gwern> it's interesting, but not useful, is my take.
10:55:31 <zygoloid> Oejet: i'm not sure what you're trying to do, but there's at least one type error in your snippet. "liftM getUser" won't work unless MyAppMonad is (->) a
10:55:41 <aavogt> this is roughly the same thing http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/control-monad-omega#direct
10:55:44 <Oejet> zygoloid: Yes, type Splice m = TemplateMonad m Template, but is that important?
10:56:09 <gwern> aavogt: not much better :)
10:56:11 <Oejet> zygoloid: Aha.
10:56:35 <aavogt> well there don't seem to be any monopolies in the haskell library market
10:56:39 <aavogt> besides maybe base
10:57:27 <aristid> aavogt: monopolies?
10:57:36 <gwern> aavogt: well, I'm not asking that logict have the >100 indirect/direct users of blaze, but I think 10 or 20 would make sense if logict was useful
10:57:41 <aavogt> aristid: that there are no alternatives
10:57:45 <zygoloid> Oejet: is TemplateMonad a MonadTrans? if so, you probably want: user <- lift getUser
10:57:48 <djahandarie> Man Oleg's site is so damn confusing to navigate
10:58:06 <aavogt> the content is more confusing
10:58:08 <djahandarie> If he added breadcrumbs or something this would be much easier
10:58:26 <sproingie> what, you don't maintain a WebsiteZipper in your head?
10:58:30 <gwern> djahandarie: breadcrumbs have no convenient expression as delimited continuations, so that is no surprise
10:58:31 <Oejet> zygoloid: Indeed, that is what the sample code uses: lift getUser. I just thought it was an error.
10:58:40 <djahandarie> lol
10:58:46 <Jesin> > id == id
10:58:47 <lambdabot>   *Exception: (==): No overloading for function
10:58:49 <Jesin> :p
10:58:51 <Jesin> hmm.
10:59:04 <djahandarie> @check \x -> id x == id x
10:59:05 <lambdabot>   "OK, passed 500 tests."
10:59:06 <sproingie> Jesin: when you can make that work in the general case, go collect your Turing Award
10:59:43 <Jesin> I know
10:59:51 <Jesin> I was just wondering
10:59:53 <Oejet> zygoloid: My current idea is: class Monad m => MyAppMonad m where getUser :: m (Maybe Text)
10:59:53 <djahandarie> Now all I need is a machine that has infinite time and space
11:00:02 <Jesin> how Cale managed to make functions an instance of Num
11:00:09 <tg_> is someone in here developing additions to lambdabot?
11:00:12 <djahandarie> Cale didn't do it, vector-space did
11:00:16 <djahandarie> tg_, nope
11:00:17 <Jesin> without defining (==)
11:00:18 <Oejet> zygoloid: However then I'm stuck at writing the instance.
11:00:18 <aavogt> Jesin: you can write the instances yourself
11:00:19 <zygoloid> Oejet: do you want MyAppMonad to be a class or a type?
11:00:20 <Jesin> ok, whoever, then
11:00:25 <djahandarie> Jesin, by writing the Eq instance
11:00:40 <Oejet> zygoloid: It does not matter!
11:00:48 <aavogt>  instance Eq (a -> b) where (==) = error "No overloading for function"
11:00:50 <Jesin> where (==) = error "No overloading for function"
11:00:53 <Jesin> yeah
11:00:54 <Jesin> ok
11:01:22 <zygoloid> Oejet: well, the types you've given so far suggest you would like it to be a type
11:01:40 <Oejet> zygoloid: Aha. Hm.
11:01:41 <sproingie> we have some extra instances for functions in \bot
11:01:42 <sproingie> > id
11:01:43 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:01:43 <lambdabot>    arising from a use of `...
11:01:49 <djahandarie> Jesin, http://hackage.haskell.org/packages/archive/vector-space/0.7.2/doc/html/src/Data-NumInstances.html relevant
11:01:54 <sproingie> huh
11:01:59 <sproingie> > succ
11:02:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:02:01 <lambdabot>    arising from a use of `...
11:02:13 <sproingie> guess it needs a type
11:02:26 <djahandarie> sproingie, one comes from smallcheck, another one comes from somewhere else I think
11:02:28 <Oejet> type MyAppMonad a = ...?
11:02:30 <sproingie> > succ :: Integer
11:02:31 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
11:02:32 <lambdabot>         against inf...
11:02:38 <sproingie> fumblefingers
11:02:48 <djahandarie> Which makes me wonder why smallcheck is even included in mueval as usual
11:02:52 <sproingie> > succ :: Integer -> Integer
11:02:54 <lambdabot>   Overlapping instances for GHC.Show.Show
11:02:54 <lambdabot>                              (GHC.I...
11:03:09 <sproingie> i now officially give up.  fix the bot :p
11:03:10 <djahandarie> Because all of the smallcheck stuff is in the IO monad anyways
11:03:11 <Oejet> zygoloid: How can you tell, that it looks more like a type?
11:04:43 <zygoloid> Oejet: there's no =>, so everything in the type annotation is a type.
11:05:11 <zygoloid> things on the left of the => are of the form (typeclass type type ...)
11:05:36 <djahandarie> gwern, HList too
11:05:47 <gwern> djahandarie: no. just... no.
11:05:56 <djahandarie> Haha
11:07:06 <Oejet> zygoloid: Got it, but those => might be hidden by type definitions? Hm, so MyAppMonad would be a data declaration?
11:09:19 <zygoloid> Oejet: yes, with certain extensions you can put contexts in type synonyms. it sounds like MyAppMonad should be a data or a newtype.
11:10:05 <zygoloid> Oejet: one common way to define a Monad instance is to build it from a pre-existing monad (or monad transformer stack), wrap a newtype around it, and use GeneralizedNewtypeDeriving to derive the Monad instance.
11:11:14 <Oejet> zygoloid: That is something like this: newtype MyAppMonad = MyAppMonad { runMyAppMonad :: ... }?
11:12:38 <Oejet> zygoloid: If "data MyAppMonad = MyAppMonad { user :: Text }", I'm not sure how to to implement a "getUser :: MyAppMonad (Maybe Text)".
11:19:13 <kfr> Hmm how do you translate the PCRE /^ *(.+) *$/ to Parsec?
11:19:19 <kfr> monochrom was good with this!
11:19:35 <kfr> It obviously starts out with skipMany $ char ' '
11:20:02 <mauke> many (char ' ') *> many1 anyChar <* eof
11:20:15 <kfr> Oh wow, I don't even know those operators
11:20:22 <mauke> hmm, not quite right
11:20:27 <kulakowski> there's no program to do spit that out?
11:20:33 <byorgey> needs another skipMany (char ' ') at the end
11:20:38 <mauke> byorgey: no
11:20:42 <kfr> kulakowski hmm yeah somebody should code that!@
11:20:46 <zygoloid> Oejet: if you want your monad to be a simple reader monad, start with something like this:
11:20:53 <kfr> byorgey it doesn't work like that :p
11:21:11 <kfr> You need to implement backtracking manually in Parsec basically
11:21:32 <zygoloid> Oejet: newtype MyAppMonad a = MyAppMonad { runMyAppMonad :: Reader MyAppData a }, with data MyAppData = MyAppData { user :: Text; ... }
11:21:36 <byorgey> oh, right, so put the many1 anyChar in a call to 'try'?
11:21:47 <mauke> do { t <- many1 anyChar; eof; let { s = dropWhile ' ' t }; return $ if null s then " " else s }
11:22:04 <mauke> wait, why am I even doing this in parsec?
11:22:21 <zygoloid> hah :)
11:22:30 <djahandarie> Because it's fun to be slow
11:22:32 <kfr> mauke because I asked you to? :[
11:22:38 <mauke> f " " = " "; f s = case dropWhile ' ' s of "" -> fail; s' -> s'
11:22:58 <mauke> if this code seems weird it's because the original regex was crap
11:23:05 <zygoloid> dropWhile isSpace / dropWhile (== ' ')
11:23:15 <mauke> oh, right
11:23:25 <kfr> Well this is part of a larger Parsec parser hm
11:23:40 <kfr> Although I could try to parse using non Parsec within it I suppose
11:23:48 <mauke> well, see do { t <- many1 anyChar; eof; let { s = dropWhile ' ' t }; return $ if null s then " " else s }
11:24:03 <djahandarie> and = ala All foldMap; or = ala Any foldMap; any = ala' Any foldMap; all = ala' All foldMap; sum = ala Sum foldMap; product = ala Product foldMap; concat = foldMap id; concatMap = foldMap;
11:24:13 <mauke> but depending on your needs you may want noneOf "\n" instead of anyChar
11:25:14 <Oejet> zygoloid: I'll try to implement getUser under this definition...
11:26:46 * djahandarie goes to class and hopes this one isn't canceled
11:27:51 <gwern> why not?
11:28:26 <djahandarie> Because I would have been on campus for like 5 hours doing nothing if it was canceled :P
11:31:52 <kfr> mauke but that is such a hack! :[
11:32:04 <mauke> why?
11:32:21 <Oejet> zygoloid: getUser :: MyAppMonad (Maybe Text) ---- getUser = ask >>= \appData -> return $ Just (user appData)   This fails with "No instance for (MonadReader MyAppData MyAppMonad)". Is that completely wrong?
11:32:29 <mauke> it's fairly simple and requires no backtracking
11:32:33 <kfr> Because you just parse it erroneously and post porcess it basically
11:33:12 <mauke> again, blame the original regex
11:33:17 <kfr>  /^ *(.+)(?:asdfa?sd?f|a?s?df|as?df?asd?f|asdferg?er)*$/
11:33:18 <mauke> its soul is ugly
11:33:23 <kfr> How would you do that?
11:33:36 <Gracenotes> gwern: oh pst the indirect dependencies on sparky use all versions of blaze-html, not just of 0.4.0.0
11:33:36 <mauke> kfr: exactly the same way
11:33:36 <dankna> very carefully
11:33:41 <kfr> I mean you don't want post processing hacks for that
11:33:42 <kfr> Now do you?
11:33:46 <mauke> kfr: exactly the same way
11:33:46 <kfr> Oh comeon.
11:33:53 <Gracenotes> gwern: it is a complete mirror, except for a few packages (which will be taken care of switching to cabal 0.10). gonna try to get people pointing cabal at it soon.
11:33:56 <mauke> kfr: that regex is equivalent to the first one
11:34:21 <zygoloid> Oejet: that's fine, but you need to wrap it in your MyAppMonad constructor.
11:34:26 <dankna> except for subexpression capturing, of course
11:34:32 <mauke> no
11:34:36 <mauke> exactly equivalent
11:34:41 <gwern> Gracenotes: really, you should've gotten hackage 2.0 wrapped up during january vacation :)
11:34:47 <dankna> oh, you mean because of greediness
11:35:30 <Gracenotes> gwern:  :P you speak truth... I should have. but I spent my time reading books and writing an OS and working on the Stony Brook HPC
11:35:35 <gwern> (what were you doing during that entire month. I bet silly things like hanging out with friends)
11:35:51 <gwern> Gracenotes: the stony brook what? I didn't know it had any decent clusters
11:35:57 <Gracenotes> thankfully I minimized that activity, not hard to do upstate
11:36:29 <gwern> Gracenotes: but you failed to finished hackage 2.0 so you must linger on the list of shame as **Unknown**
11:36:36 * gwern is cruel but fair
11:36:44 <Gracenotes> gwern: there should be ganglia on http://vogon.ams.sunysb.edu/.. seems to be down
11:37:07 <Gracenotes> gwern: sad to say, deploying wasn't part of finishing it
11:37:13 <gwern> it is to me
11:37:21 <Gracenotes> read the project proposal :)
11:37:51 <gwern> obvious ass-covering
11:38:10 <Oejet> zygoloid: Great, it compiled.
11:38:41 <Gracenotes> it did overwhelmingly became the focus closer to the end. for good reason, too. but, I'm serious, it's an infrastructure for the future hackage server. I guess everyone wants me to be the sysadmin-for-life, so with my free time, that's what I'm doing.
11:38:50 <kfr> mauke: I believe you meant (== ' ') or isSpace instead of ' ' and your code did not get rid of the whitespace on the right side, did it?
11:39:15 <pumpkin> can view patterns depend on bound variables in other patterns?
11:39:15 <mauke> kfr: right, I meant (== ' ')
11:39:31 <pumpkin> f (x : xs) (myView x -> (y, ys)) = ...
11:44:13 <harlekin> How can I extract the number of seconds of a day passed since some UTCTime?
11:44:40 <harlekin> I see DiffTime stores that, but using fromEnum gives something weird.
11:44:48 <aristid> harlekin: diffUTCTime
11:44:54 <aristid> harlekin: that ignores leap seconds tho :)
11:44:59 <aristid> (deliberately)
11:46:11 <harlekin> Using that I can compare two UTCTimes. utctDayTime is what fits better. However, I cannot convert it to Int or something.
11:47:01 <harlekin> Mh, floor . toRational . utctDayTime seems to work. But it seems awkward.
11:47:56 <JackieXu> Ah, finally, a free nick.
11:48:32 <aristid> harlekin: (`div'` 1)?
11:48:41 <aristid> div' is from Data.Fixed
11:49:17 <Oejet> zygoloid: Using "user <- lift getUser" GHC now complains: "No instance for (Monad MyAppMonad) arising from a use of `lift'". This must mean, that I should make an instance Monad MyAppMonad...
11:49:19 <harlekin> aristid, thanks. That'll do for now.
11:49:22 <aristid> :t (`div'` 1) . utctDayTime
11:49:23 <lambdabot> Not in scope: `utctDayTime'
11:49:26 <aristid> :/
11:49:29 <aristid> :t div'
11:49:30 <lambdabot> forall a b. (Real a, Integral b) => a -> a -> b
11:49:35 <aristid> well at least that
11:50:41 <Jesin> It would be nice if introducing superclasses were easier.
11:51:52 <copumpkin> @ask Cale can you join lambdabot to ##smt ?
11:51:52 <lambdabot> Consider it noted.
11:53:17 <Jesin> so we didn't have to do stuff like instance Monad m => Functor (WrappedMonad m), and instance Monoid m => Semigroup (WrappedMonoid m)
11:53:45 <tromp> this is called a close poll: http://blog.laptopmag.com/os-bowl-final-webos-vs-windows-phone-7-voting-ends-tuesday-28-at-9-a-m
11:54:00 <fryguybob> > let myView a as = (a, as); f (x : xs) (myView x -> (y, ys)) = y:ys in f "abc" "def"
11:54:01 <lambdabot>   "adef"
11:54:53 <zygoloid> Oejet: you can derive the Monad MyAppMonad instance with the GeneralizedNewtypeDeriving extension.
11:55:04 <Gracenotes> not many new tickets for gsoc though
11:55:34 <Gracenotes> gwern: are you gonna ask people to add them sometime?
11:56:56 <gwern> Gracenotes: not really. if people want to apply for gsoc, do they need my urging?
11:57:20 <Gracenotes> gwern: nah, I mean adding project ideas to the trac
11:57:36 <gwern> Gracenotes: oh, I don't have any new ideas. I'm just good at criticizing existing ones
11:57:39 <Gracenotes> by people who want student slaves to work on their pet project
11:57:57 <Gracenotes> erhem, rather, who see a void to be filled in the haskell ecosystem
11:57:59 <gwern> Gracenotes: I suppose I should have a section for that - 'I looked at the GSoC Trac and here's the ones that struck me as really good and really atrocious'
11:58:16 <Gracenotes> well, the most recently posted ones are early 2010
11:58:49 <gwern> Gracenotes: unfortunately, I'm just about out of time (taekwondo starts at the gym today and if I want to make it there dressed by 3:50 I need to leave now)
11:59:03 <gwern> Gracenotes: I might be back on around 5:30 or 6
11:59:11 <Gracenotes> gwern: yup. I mean a bit closer to gsoc project proposal time though
11:59:33 <Gracenotes> have fun
12:00:29 * hackagebot case-insensitive 0.2 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.2 (BasVanDijk)
12:02:46 <Oejet> zygoloid: Got that working. For actually running the reader I get this: "Couldn't match expected type `MyAppMonad (Maybe (Builder, MIMEType))' against inferred type `IO (Maybe (Builder, MIMEType))'".
12:03:32 <zygoloid> Oejet: you need to figure out where that IO has come from :)
12:04:11 * copumpkin cordially invites people who are interested to ##smt
12:04:11 <Oejet> zygoloid: I don't know how to handle a Reader inside a MyAppMonad.  Something like runReader ($ runMyAppMonad $ ...) (Just "Dogbert").
12:05:05 <Oejet> zygoloid: It's easy. The line is: main = do ... t <- renderTemplate ts "loginout". This is where the monad should be run.
12:05:51 <zygoloid> Oejet: what's the type of renderTemplate?
12:06:31 <Oejet> zygoloid: renderTemplate :: Monad m => TemplateState m -> ByteString -> m (Maybe (Builder, MIMEType)).
12:07:36 <Oejet> zygoloid: The example code proposes: t <- runMyAppMonad $ renderTemplate ts "index" 
12:07:45 <alex404> Does anyone have experience with the gnuplot haskell package? I can't get even the most basic thing working.
12:08:13 <zygoloid> Oejet: that assumes that runMyAppMonad :: MyAppMonad a -> IO a, since you're using the result in main, which is :: IO ()
12:09:26 <zygoloid> Oejet: since your monad is 'pure' (no IO), you would use: "let t = ..." rather than "t <- ..."
12:11:49 <Oejet> zygoloid: let t = runMyAppMonad $ renderTemplate ts "loginout".
12:13:01 <zygoloid> Oejet: something like that. does runMyAppMonad not need you to pass in a name?
12:15:46 <Oejet> zygoloid: Yes, I would expect that. Does it work exactly  as runReader? Here's the full code so far and error message: http://hpaste.org/43741/fun_with_heist
12:19:44 <zygoloid> Oejet: ok, you need a better run function for your monad: http://hpaste.org/paste/43741/fun_with_heist_annotation#p43743
12:22:25 <zygoloid> Oejet: i'm off home now, i'm sure another friendly #haskeller will help you if you need it :)
12:24:07 <NemesisD> when defining modules like ParentMod.NestedMod, is the . purely superficial or do you get any access to the parent module?
12:24:29 <hpc> NemesisD: there need not be a parent module
12:24:31 <NemesisD> i ask because i've unwittingly set up a cyclical dependency between the ParentMod and NestedMod
12:24:38 <Oejet> zygoloid: Thank you so much!
12:24:47 <hpc> you can have X.Y without having X
12:24:59 <hpc> importing X.Y doesn't give you X
12:25:21 <NemesisD> ParentMod imports NestedMod, NestedMod needs a type constructor from ParentMOd, do i have any recourse other than breaking out the shared part to a 3rd module?
12:25:53 <hpc> NemesisD: there's a way to resolve those sorts of things, but it's ugly as all hell
12:26:07 <hpc> the solution i see on hackage is to make X.Types
12:26:09 <hpc> X.Y
12:26:10 <hpc> and X
12:26:24 <NemesisD> ah i see
12:26:25 <hpc> and X.Z or whatever
12:26:35 <hpc> and X will typically re-export X.Y and X.Z
12:26:38 * hackagebot yices 0.0.0.9 - Haskell programming interface to Yices SMT solver  http://hackage.haskell.org/package/yices-0.0.0.9 (KiYungAhn)
12:27:11 <hpc> the last part isn't necessary, but i like the idea of X.Types, as a one-stop-shop for a collection of modules)
12:28:19 <Peaker> Oejet, "ask >>= \appData -> return $ Just (user appData))" = "(\appData -> Just (user appData)) <$> ask" = "Just . user <$> ask" = "asks (Just . user)"
12:30:54 <Oejet> Peaker: Good suggestion, thanks.
12:30:58 <Peaker> Oejet, why is getUser wrapped in Maybe?
12:31:08 <Peaker> (If it is always Just?)
12:31:27 <Peaker> @pl (\(b,m) -> toByteString b)
12:31:27 <lambdabot> toByteString . fst
12:31:34 <Peaker> Oejet, I love point-less notation :)
12:32:13 <Oejet> Peaker: It's from a code documentation example: "...Assume you have a function   getUser :: MyAppMonad (Maybe Text) that gets the current user."
12:32:23 <spetrea-home> where are the Haskell dogs ?
12:33:41 <ion> I’m here, dawg
12:33:44 <sm> ARF!
12:35:29 <Peaker> Oejet, ah. I suppose your monad will evolve more layers in the transformer stack too?
12:36:23 <whodevil> hello all, I'm trying to build a haskell project and it's not finding the correct library. I verified the library is in ~/.cabal/lib but I think the problem is that dir is not in my environmental variables anywerhe. Should this go on $LIB or $PATH?
12:37:01 <dcoutts> whodevil: ghc-pkg list shows the library packages that are registered
12:37:15 <dcoutts> whodevil: no env vars are required for finding libraries
12:38:16 <whodevil> oh hmm, it looks like it is in ghc-pkg list
12:38:22 <Peaker> dcoutts, hey, lots of newbies I know are burnt by cabal-install re-installing at the user-side core packages overriding the global ones that came with ghc... any easy way to solve this?
12:38:23 <whodevil> so maybe I'm doing something else wrong 
12:38:25 <whodevil> LOL
12:38:52 <Peaker> whodevil, Are you using "cabal install" or "cabal build" to try to build the package?
12:38:58 <Oejet> Peaker: I don't know exactly what that means, but the current error (http://hpaste.org/43745/error) to the code (http://hpaste.org/43744/fun_with_heist) might be related: No instance for (MonadIO MyAppMonad).
12:39:14 <dcoutts> Peaker: not yet, but we hope to solve it in a future release
12:39:34 <dcoutts> Peaker: using --dry-run lets people see what will happen
12:39:49 <Peaker> dcoutts, they don't know it is a problem
12:40:55 <whodevil> oh it looks like whatever version of xmonad-contrib I have doesn't have the bluetile stuff in it, when I try to recompile xmonad with "import XMonad.Config.Bluetile" it fails
12:42:46 <Peaker> Oejet, what do you want it to do?
12:43:22 <Peaker> Oejet, your use of renderTemplate forces the "m" in the type of "ts" to be MyAppMonad, and the same "m" is in emptyTemplateState, where it is required to be MonadIO
12:45:45 <Peaker> Oejet, There's an easy "fix", but it's best to only do it if you understand what you're doing :)
12:46:08 <tibbe> my bday is coming up in a few weeks and I'm at a loss of what to wish for. Any really good CS books out there I should definitely read?
12:46:20 <Peaker> Oejet, do you want an easy fix or to understand what's going on?
12:52:35 <Oejet> Peaker: I don't know what I am doing, yet. That getUser function was more difficult to implement, than I expected. Without that function (using just a constant: Just "Dogbert"), I had the code working.
12:54:33 <Oejet> Peaker: Preferably understand what's going on. :)
12:55:12 <Peaker> Oejet, Are you looking at the types of all these functions you're using? :)
12:55:57 <whodevil> ok, so I found the source for the bluetile module, but I'm not really sure how to build it so that GHC will see it?
12:57:57 <aperiodic> hi all, i'm having some issues getting haskell-SDL to work on OS X
12:58:38 <Oejet> Peaker: Not looking hard enough!
12:58:58 <aperiodic> i'm pretty sure that it's something to do with haskell-SDL and not SDL, since i can get SDL programs written in C to compile and run fine
12:59:03 <elliott> Is there a portable way to get the number of bytes in an integral type?
12:59:09 <elliott> e.g. foo (undefined::Int32) = 4
12:59:20 <elliott> Using Bounded perhaps?
12:59:37 <jix> elliott: Data.Bits.bitSize
13:00:22 <elliott> jix: thanks!
13:01:37 <zenzike> does anybody know if there's a way to specify an end of tag in hakyll? I'd like to write "$root" and append "foo" to the end, but writing "$urlfoo" is obviously wrong, and "$url foo" inserts a space I don't want.
13:01:49 <JohnnyDG> Does anyone know about iteratees?
13:01:56 <dons> alternaely, elliott 
13:01:57 <dons> > Data.Bits.bitSize (undefined :: Int) `div` 8
13:01:57 <dons> 8
13:01:58 <lambdabot>   8
13:02:08 <elliott> dons: indeed :)
13:02:08 <dons> oh. jix wins
13:02:11 <elliott> yep!
13:02:13 <elliott> haha
13:02:31 <Peaker> aperiodic, There's a README that explains the OSX sdl situation
13:02:34 <dons> > Foreign.sizeOf (undefined :: Int)
13:02:34 <dons> 8
13:02:35 <lambdabot>   Not in scope: `Foreign.sizeOf'
13:02:40 <dons> for Foreign things though.
13:02:44 <Peaker> aperiodic, it has to do with an ugly preprocessor trick SDL (C) uses to compile on OS X
13:02:44 <dons> but you know that.
13:03:45 <JohnnyDG> instance Monad (IterV el) where return x = Done x Empty m >>= f = case m of \ Done x str -> case f x of Done x’ _ -> Done x’ str Cont k	-> k str \ Cont k -> Cont (\str -> k str >>= f)
13:04:03 <elliottt> hi elliott :)
13:04:08 <elliottt> you apparently confused dons :)
13:04:12 <elliott> hello :P
13:04:13 <JohnnyDG> That is: instance Monad (IterV el) where return x = Done x Empty m >>= f = case m of \ Done x str -> case f x of Done x’ _ -> Done x’ str Cont k	-> k str \ Cont k -> Cont (\str -> k str >>= f)
13:04:18 <elliott> sorry dons :D
13:04:29 <zenzike> jaspervdj: ^do you happen to know?
13:04:44 <JohnnyDG> I'm concerned about case 2. The remainder from the 2nd iteratee is discarded.
13:04:45 <aperiodic> Peaker: ah, didn't think to check the package source. thanks!
13:05:04 * aperiodic spoiled by brew
13:05:13 <JohnnyDG> Anyone have a reason why this isn't a terrible thing?
13:06:39 <Peaker> JohnnyDG, can you use a paste site so it is formatted sanely? :)
13:09:10 <mjhan> Hi, does anyone know what's with haskellmode-vim? The project dir on projects.haskell.org is empty.
13:10:00 <JohnnyDG> http://hpaste.org/43750/monad_instance_for_iteratee
13:10:03 <tibbe> dons: !!!
13:10:05 <JohnnyDG> There you go.
13:10:09 <tibbe> dons: you're alive ;)
13:10:37 <JohnnyDG> Please explain how it is sane to simply discard the remainder for the 2nd iteratee.
13:13:31 <owst> Do you mean the Done x' case? If you do, then the second iteratee has not done any "processing" (remember the f takes some value to return an iteratee) so it is catching the case that the iteratee is already "done", without requiring any input. The example I think I saw mentioned somewhere was in the case of the iteratee "drop 0". (Anyone please correct this if it's a horrible lie :))
13:13:59 <elliott> How does one get the current year, month, day, hour, minute and second in UTC with the stdlib? getCurrentTime works but I can't figure out how to extract the time components.
13:14:35 <aristid> elliott: convert it to a LocalTime in the utc timezone
13:14:42 <elliott> aristid: heh
13:15:04 <elliott> aristid: and simultaneously use Data.Time.Calendar?
13:15:05 <aristid> that's the "right" way *shrug*
13:15:11 <elliott> hmm, no
13:15:11 <Oejet> Peaker: So MyAppMonad have to be an instance of MonadIO because of emptyTemplateState.
13:15:20 <Peaker> Oejet, Yeah
13:15:21 <JohnnyDG> Done x’ _ -> Done x’ str
13:15:22 <elliott> can't see how to get year/month/date from that
13:15:23 <elliott> *day
13:15:30 <aristid> elliott: yeah, for month, day, hour, you need toGregorian or so
13:15:40 <aristid>  :t toGregorian 
13:15:40 <aristid> toGregorian :: Day -> (Integer, Int, Int)
13:15:46 <Peaker> Oejet, Which means your monad stack in MyAppMonad ought to have IO in it.  You can replace Reader ...  With ReaderT ... IO
13:15:47 <elliott> aristid: right, but then I need a Day
13:15:58 <elliott> which I can't seem to get from a UTCTime
13:16:01 <aristid> data LocalTime
13:16:01 <aristid>   = LocalTime {localDay :: Day, localTimeOfDay :: TimeOfDay}
13:16:08 <elliott> ah
13:16:17 <elliott> wasn't the time library _redesigned_ a while back? :P
13:16:23 <aristid> UTCTime actually also contains a Day value
13:16:34 <aristid> but you need LocalTime for the hour/min/sec anyways
13:16:41 <aristid> elliott: yes, this is the new one
13:16:47 <Jesin> :t \m1 m2 -> m1 >>= (`fmap` m2)
13:16:47 <lambdabot> forall (m :: * -> *) a b. (Functor m, Monad m) => m (a -> b) -> m a -> m b
13:16:51 <Jesin> :t ap
13:16:52 <elliott> heh :)
13:16:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:16:53 <aristid> elliott: i think it's pretty nice now :)
13:16:58 <elliott> yeah, just not used to it yet
13:17:06 <Jesin> @pl \m1 m2 -> m1 >>= (`fmap` m2)
13:17:06 <lambdabot> (. flip fmap) . (>>=)
13:17:14 <Jesin> @unpl ap
13:17:14 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:17:22 <Jesin> eh.
13:17:22 <Peaker> Oejet, do you understand monad transformers?
13:17:38 <JohnnyDG> There's no guarantee the 2nd iteratee hasn't done any processing. That iteratee could have itself been returned from an enumerator.
13:17:50 <Peaker> Oejet, if not, I suggest: http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial
13:18:20 <elliott> aristid: but how do I get a TimeOfDay given a LocalTime?
13:18:22 <elliott> oh
13:18:23 <elliott> it's inside
13:18:24 <elliott> heh
13:18:39 <aristid> ...
13:18:56 <aristid> elliott: ghci and :info are your friends :)
13:19:03 <elliott> i'm looking at the docs now
13:19:03 <Oejet> Peaker: I'll read it right away!
13:19:07 <elliott> just glossed over it :D
13:19:30 <aristid> elliott: docs alone are sterile. interactive ghci makes it come to life!
13:21:50 <Jesin> hmm
13:22:10 <Jesin> how do I install packages from hackage?  Or, where's a good tutorial on how to do that?
13:23:18 <sm> Jesin: http://www.haskell.org/haskellwiki/Cabal-Install
13:24:32 <elliott> aristid: err, still though, I don't see how to get a LocalTime that represents a UTC time
13:24:38 <elliott> without having it converted to the current time zone
13:24:43 <elliott> oh
13:24:44 <elliott> :D
13:24:45 <elliott> there we go
13:25:01 <aristid> elliott: utcToLocalTime utc
13:25:05 <elliott> yep
13:30:57 <adnap> does it make sense to want something like this: http://hpaste.org/43751/hm
13:33:14 <adnap> weird... where is everyone?
13:33:50 * EvanR-work tumbleweed blows through the channel
13:34:01 <adnap> coo-caw!
13:34:02 <jmcarthur> adnap: that's fine if you don't want any other instances of A
13:34:21 <Jesin> @unpl ap
13:34:21 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:34:25 <adnap> jmcarthur: i do though.  i'm not sure how i can express what i want.
13:34:43 <jmcarthur> adnap: there's overlapping instances or incoherent instances or whatever, but i highly recommend against those
13:34:45 <Gracenotes> suppose you have a type which is an instance of B. which instance of A do you use? both apply.
13:34:56 <Jesin> @unpl \d e -> d >>= (`liftM` e)
13:34:57 <lambdabot> \ d e -> d >>= \ a -> liftM a e
13:35:03 <Jesin> @unpl liftM
13:35:04 <lambdabot> liftM
13:35:11 <Gracenotes> if you say "the more specific one", well, that's kinda vague to formalize
13:35:19 <adnap> i want any instance of B automatically be an instance of A
13:35:32 <adnap> *B to automatically
13:35:51 <adnap> but to be an instance of B, you have to be an instance of A
13:35:58 <Jesin> @src ap
13:35:58 <lambdabot> ap = liftM2 id
13:35:59 <adnap> and then your functions get redefined
13:36:05 <Jesin> @src liftM2
13:36:05 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:36:10 <Jesin> @. undo src liftM2
13:36:11 <lambdabot> ()
13:36:26 <Jesin> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:36:26 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
13:36:29 <Gracenotes> er.. hm.. it depends on which other types are defined like that. anyway, things are fragile-ish here.
13:36:38 <adnap> here's an example
13:37:02 <adnap> well, actually, let me post a new example
13:37:12 <parcs> @undo do { _ <- return () }
13:37:12 <lambdabot>  Parse error at "}" (column 21)
13:39:01 <Jesin> @undo do _ <- return ();
13:39:01 <lambdabot>  Parse error at end of input
13:39:07 <Jesin> @undo do return ()
13:39:07 <lambdabot> return ()
13:39:49 <parcs> @undo do { _ <- do { _ <- undefined; undefined }; undefined }
13:39:49 <lambdabot> undefined >>= \ _ -> undefined >>= \ _ -> undefined
13:40:03 <Jesin> Prelude> do { _ <- return () }
13:40:05 <Jesin> <interactive>:1:5:
13:40:06 <Jesin>     The last statement in a 'do' construct must be an expression
13:40:08 <Jesin> ghci agrees
13:40:21 <Peaker> adnap, Haskell's instance declarations are pretty limited
13:40:21 <parcs> i know, i was just curious as to how it handles that case
13:40:31 <JackieXu> Hi there
13:40:34 <Peaker> adnap, GHC has some extensions, but it may not be a good idea to abuse them :)
13:41:50 <Peaker> adnap, I don't think what you pasted is a good idea.. what do you have in mind?
13:42:47 <jaspervdj> zenzike! I just wanted to pong you back
13:42:49 <adnap> yeah, i see the dilemma
13:43:23 <adnap> i guess what i want is: being a member of some class gets your functions for another class redefined.  is that good?
13:43:50 <adnap> let's say you're a member of a class Physical, and you have a mass, postion, velocity, and acceleration
13:44:12 <Oejet> Peaker: I got it to work by adding "instance MonadIO MyAppMonad where liftIO = liftIO"! I have no idea why it works, but I'm still reading the monad transformers tutorial.
13:44:17 <EvanR-work> if those are numbers or vectors, doesnt sound like a class
13:44:38 <adnap> now you're an instance of Gravitational, and you have a universe of other physical objects.  your position, velocity, and acceleration get redefined in terms of the other objects in the universe
13:45:25 <tg_> adnap: that doesn't make too much sense
13:45:31 <tg_> at least in the things you quantified
13:45:39 <tg_> but that might be nitpicking
13:45:53 <Peaker> Oejet, that's wrong
13:46:01 <tg_> if you have [position] and [velocity] you don't need [acceleration]
13:46:04 <tg_> or rather, you already havei t
13:46:06 <tg_> it
13:46:07 <adnap> well let's say you want some physical objects that aren't influenced by gravity and some that are
13:46:07 <Oejet> Peaker: But, but!
13:46:18 <Peaker> Oejet, You should not define the MonadIO instance manually like that, and what you defined is simply an infinitely-recursive liftIO
13:46:31 <Peaker> Oejet, Haskell will accept any definition of any "x" defined as: x = x
13:46:41 <adnap> i guess maybe a better thing to do is have phyiscal objects that respond to forces
13:46:46 <adnap> and have gravity be a force
13:46:52 <Peaker> Oejet, (roughly) same semantics as writing x = undefined   or   x = error "infinite recursion here!"
13:47:03 <tg_> adnap: are you actually trying to do this?
13:47:06 <Oejet> Peaker: Hm.
13:47:11 <tg_> or are we talking for learning something about haskell?
13:47:32 <adnap> i was thinking about doing it
13:47:56 <adnap> i wanted to play with Reactive
13:48:07 <Peaker> adnap, You probably shouldn't use type-classes for something like Gravitational..  Type-classes are for ad-hoc polymorphism, why not have the objects just have a gravitational attribute or such? Why do you need the polymorphism?
13:48:12 <tg_> adnap: I brought the question up the last few days, that I was interested in encoding the concept of Dimensions into haskell in some way that was sort of decorating
13:48:29 <Oejet> Peaker: I thought the right hand side of liftIO = liftIO might have been a different function.
13:48:32 <tg_> instead of at the type level
13:48:41 <imc> hello! I'm trying the yogurt MUD client... with a basic example as on the Yogurt Wiki. I get a "Not in scope `connect'" error
13:48:56 <adnap> yeah, i was thinking there could be other laws of physics
13:49:13 <adnap> so, instead of gravity you have other classes which behave differently
13:49:33 <tg_> i'm just not sure if it's appropriate that it go into types at all
13:49:36 <Peaker> Oejet, it has the same type, so it must be invoking the same method of the same instance, thus infinitely recursive
13:49:37 <adnap> other laws as in made up laws
13:49:50 <adnap> i think maybe i need to just have forces
13:49:56 <Oejet> Peaker: Understood.
13:50:08 <Peaker> Oejet, do you understand Functor, Applicative, Monad type classes?
13:50:24 <imc> oh, got it
13:50:37 <Oejet> Peaker: Not much.
13:50:42 <tg_> adnap: you can either have the [particles] with [forces] picture or the [fields] with [potentials] picture
13:50:52 <tg_> they will usually end up being equivalent
13:50:59 <adnap> i don't know about fields and potentials
13:51:03 <tg_> but to say you should only express one of them and not the other is a severe limitation
13:51:08 <Jesin> hmm
13:51:18 <hpc> Oejet: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
13:51:29 <JackieXu> Could anyone help me with setting up some kind of upper limit to the input set of a list comprehension?
13:51:37 <kfr> Can you make null x || length x > 2 any shorter?
13:51:40 <adnap> is it something easy to understand if you know about forces and particles?
13:51:49 <Jesin> so, when the implementation of "fmap f m" results in a simpler expression than "m >>= return . f" (which is liftM)
13:51:58 <kfr> Ah using [1..2] and elem perhaps?
13:52:02 <Jesin> m1 <*> m2 = m1 >>= (`fmap` m2)
13:52:05 <tg_> adnap: is what easy to understand?
13:52:11 <Jesin> might be a better alternative to (<*>) = ap?
13:52:14 <Jesin> :p
13:52:15 <tg_> there are things which are easier to understand in one picture or he other
13:52:50 <adnap> the entire concept of fields and potentials
13:52:56 <adnap> assuming you know particles and forces
13:53:05 <tg_> adnap: there are symmetries which connect them
13:53:12 <adnap> i get that
13:53:18 <tg_> adnap: but some things you'll want to calculate
13:53:23 <tg_> will be infinite in one picture, and not in the other
13:53:36 <adnap> i'm saying, is it easy to see how they connect?
13:54:22 <tg_> adnap: hmm. it depends on what you're trying to learn, I guess. Yes, it should be.
13:54:43 <Oejet> hpc: Thank you.
13:54:56 <Peaker> Oejet, well, I'd classify Functor as simple, Applicative is a bit harder, Monad as pretty advanced/harder still, and Monad Transformers as a bit harder than Monads.  They are easy in retrospect but initially understanding them is hard. I'd work them in that order
13:55:05 <adnap> are functions in type classes essentially "set in stone" once they are defined?
13:55:24 <opqdonut> yes
13:55:30 <adnap> it seems like manipulating them later is cumbersome
13:55:45 <hpc> i thought functor and applicative were pretty trivial to learn
13:55:48 <adnap> i was trying to do it by tring to make a narrower class
13:55:51 <tg_> adnap: and one needs to deal with non-dimensionality
13:55:56 <hpc> fmap is "apply a function inside a thing"
13:56:04 <Peaker> adnap, they are called "methods". GHC supports overlapping instances which lets you override instances definition of methods with more specific ones
13:56:05 <hpc> and applicative is "apply a function in a thing to something in a thing"
13:56:31 <adnap> Peaker: yeah, i'm not sure it's even a good idea.  it could be hard to reason about.
13:56:33 <Peaker> hpc, Functor is pretty simple (don't say trivial, even grasping the kind (* -> *) is probably not trivial)
13:56:48 <tg_> adnap: what I was interested in doing is dimensional analysis
13:56:52 <tg_> there are some haskell libraries out there to do that
13:57:01 <tg_> adnap: might be a good place to start?
13:57:08 <Peaker> hpc, Applicative may be simple but its consequences (allowing liftAn) and limitations and the consequences of the limitations are not trivial
13:57:48 <Peaker> hpc, how would you describe the difference between Applicative and Monad?
13:57:51 <adnap> tg_: man, i don't think i can write the most general physics sim ever.  my knowledge consists mainly of a basic understanding of newtonian phyiscs. lol
13:57:53 <Peaker> Don't say "join" :)
13:58:18 <tg_> adnap: yes, depending on what you're interested in doing/accomplshing
13:58:22 <tg_> I would want to help
13:58:36 <adnap> tg_: i think it would be overkill too.  i want this to be strictly newtonian.
13:58:43 <adnap> tg_: for graphical applications
13:59:08 <tg_> adnap: what kind of applications? general purpose? ipad? cell phone? cpu?
13:59:32 <adnap> tg_: i don't know why the platform is relevant
13:59:34 <hpc> lol Peaker 
14:00:12 <adnap> i'm thinking a Physical type class is probably the wrong way to go if i want to be able to change things
14:00:15 <Peaker> hpc, more non-trivialities are relationships to the Category/Arrow classes (Applicative+Category ~= Arrow)
14:00:18 <hpc> Peaker: was going to say "bind" :3
14:00:30 <Peaker> hpc, bind can be expressed in terms of fmap and join
14:00:34 <tg_> adnap: from what little I understand about haskell, I agree - but where do you turn to next?
14:00:49 <adnap> tg_: that's kind of vague
14:00:53 <monochrom> "physical" http://www.youtube.com/watch?v=vWz9VN40nCA :)
14:00:55 <adnap> tg_: what do you mean?
14:00:57 <tg_> adnap: template haskell?
14:01:00 <Peaker> hpc, and IME join is always simpler than bind, so the Monad class is not formulated nicely
14:01:02 <tg_> a DSL?
14:01:15 <Peaker> hpc, (simpler to implement, fundamentally smaller)
14:01:23 <adnap> uh
14:01:26 <tg_> here's a slide set "Types for Units of Measure" http://research.microsoft.com/en-us/um/people/akenn/units/units.ppt
14:01:26 <adnap> i don't know
14:01:44 <adnap> i just wanted to write a simple newtonian physics sim using Reactive
14:02:00 <Peaker> hpc, it's easy to mistake something that's well understood for something that's trivial :) We measure non-triviality in difficulty of comprehending or thinking about something. Once it becomes easy for us to think about something complicated we think it is trivial :)
14:02:09 <adnap> so position :: Behavior Vector3, velocity :: Behavior Vector3, etc.
14:02:23 <tg_> conal: here?
14:02:34 <conal> tg_: yep. hi
14:02:40 <adnap> ha ha
14:02:43 <Peaker> hpc, But if you try to explain these things to a newbie you'll see none of them are trivial.. For example,  if Functor is trivial,  how do you trivially explain why  (a->) is a Functor but not (->a) ?
14:02:48 <hpc> Peaker: fyi, i said "trivial to learn" not "trivial"
14:02:59 <tg_> conal: any thoughts on encoding abstract dimensions in a system which plays with Reactive?
14:03:02 <Peaker> hpc, well, I guess it depends on the depth of learning
14:03:18 <tg_> for my want, to do standard dimensional analysis...
14:03:28 <tg_> for adnap's, to make a newtonian simulator (evidently)
14:03:32 <conal> tg_: no. other than i'd expect the two to be orthogonal.
14:03:41 <conal> neat.
14:03:42 <hpc> and i think you can make a (->a) functor, with a newtype
14:04:11 <conal> hpc: could you express fmap?
14:04:18 <tg_> conal: yeah, I think I realized that I disagree with you on that specific point some time ago, but I still can't tell you exactly how.
14:04:22 <tg_> I need to get my haskell chops in gear
14:04:26 <kuznero> Hi Gents, does anybody know where can I get haskellmode.vba for vim?
14:04:42 <conal> tg_: cool. please keep working on it.
14:04:51 <kuznero> Old good 'http://projects.haskell.org/haskellmode-vim/vimfiles' does not seem to have it any longer :(
14:05:01 <adnap> i suppose if my universe was deterministic, i could most definitely say what position, velocity, and acceleration "are" in terms of the other objects in the universe
14:05:25 <tg_> adnap: if you had the exact position and velocity of every interacting particle
14:05:32 <tg_> you can write (and solve) a lagrangian
14:05:45 <adnap> i was going to do something like euler integration
14:05:47 <tg_> which will completely determine everything that can happen
14:05:47 <hpc> :t fmap
14:05:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:05:52 <adnap> Reactive has integral
14:05:58 <monochrom> newtonian laws are deterministic
14:06:09 <tg_> yes, with newton's laws
14:06:10 <adnap> right, but i was thinking about interactive behavior
14:06:18 <adnap> influencing the position of an object
14:06:20 <tg_> all you need is the position of each particle
14:06:26 <adnap> right
14:06:37 <tg_> for any interaction other than gravity
14:06:49 <tg_> newton's laws won't work, and you'll need position and velocity
14:06:50 <adnap> velocity = ticks `integral` acceleration
14:06:52 <kuznero> I'm sure there are lots of those who uses Vim :)
14:06:53 <tg_> q and qdot
14:07:04 <adnap> position = ticks `integral` velocity
14:07:13 <tg_> i mean, to do anything that solve the situation where particles go toward each other
14:07:19 <kuznero> Haskellmode.vba ???
14:08:04 <adnap> the thing is, i want the notion of physical objects that don't respond to gravity and those that do
14:08:04 <monochrom> there are a lot of vim users. just wait for them to appear.
14:08:19 <tg_> adnap: I gathered. That system isn't compatible with newton's laws
14:08:25 <adnap> yeah
14:08:29 <adnap> it's more of a mixed bag
14:08:34 <tg_> there's a specific reason
14:08:39 <kulakowski> adnap: So have separate inertial and gravitational masses.
14:08:58 <adnap> kulakowski: oooh
14:09:01 <tg_> kulakowski: that's... a weird suggestion
14:09:02 <monochrom> but I can't explain why they are all away.
14:09:04 <adnap> kulakowski: so gravitational mass could be 0
14:09:16 <tg_> adnap: that won't work
14:09:20 <adnap> why not?
14:09:26 <hpc> huh, it seems i can't
14:09:32 <hpc> conal: ^
14:09:43 <tg_> you won't be able to solve for things that repel
14:09:43 <adnap> m = m_g + m_i, right?
14:09:44 <tg_> instead of attract
14:09:58 <tg_> no, energy = kinetic + potential
14:10:07 <tg_> and also
14:10:14 <tg_> action (lagrangian) = kinetic - potential
14:10:54 <adnap> man, i don't know what you're talking about.  i don't know enough physics.
14:11:01 <accel> what's the best way to install haskell 7.0 on ubuntu 10.10 ?
14:11:03 <hpc> shouldn't this be blah?
14:11:09 <tg_> hpc: ->
14:11:12 <accel> what's the best way to install haskell 7.0 on ubuntu 10.10 ? (i'd prefer to rip out 6.12 afterwards)
14:13:11 <Peaker> hpc, Yeah, because Functor instances must have their type parameter appear only in "positive" locations (a -> b)  "a" is negative and "b" is positive.  Positive/negative locations can be specified for all sub-terms of a type (AFAIK)
14:13:41 <Peaker> hpc, In: (a -> b) -> c   the (a -> b) is negative, so the "a" is positive again, the "b" is negative, and the "c" is positive
14:13:53 <aperiodic> so, I've got an Int that i'd like to pass to a function that wants GL.GLsizei's. ghc complains that the types don
14:14:07 <parcs> accel: in 4 days a new version of HP will be released that contains ghc 7.0.1. maybe ubuntu's repository will be updated then
14:14:14 <aperiodic> don't match-is this something I can solve by writing an additional constructor for GL.GLsizei?
14:14:22 <accel> parcs: what's HP ?
14:14:23 <Peaker> hpc, so you can make (_ -> b) -> c   a Functor, or (a -> b) -> _   but not (a -> _) -> c
14:14:30 <parcs> accel: haskell platform
14:14:39 <accel> parcs: I don't mind installing from source
14:14:45 <accel> parcs: I'm just not sure how to rip out 6.12
14:14:52 <Peaker> @djinn (a -> a') -> ((a -> b) -> c) -> ((a' -> b) -> c)
14:14:52 <lambdabot> f a b c = b (\ d -> c (a d))
14:15:02 <Peaker> @djinn (b -> b') -> ((a -> b) -> c) -> ((a -> b') -> c)
14:15:02 <lambdabot> -- f cannot be realized.
14:15:09 <Peaker> @djinn (c -> c') -> ((a -> b) -> c) -> ((a -> b) -> c')
14:15:09 <lambdabot> f a b c = a (b c)
14:15:13 <pumpkin> if you have Contravariant, you can make (a -> _) -> c into a (contravariant) functor but neither of the other two
14:15:17 <Oejet> Peaker: I think, I got it now.
14:15:23 <pumpkin> actually
14:15:27 <Peaker> Oejet, got monad trans?
14:15:42 <parcs> accel: did you install 6.12 from source?
14:15:43 <pumpkin> it's backwards, but that's the idea
14:15:49 <accel> parcs: no, 6.12 is from apt-get
14:16:00 <Peaker> pumpkin, why backwards I think what you said first was right?
14:16:17 <pumpkin> oh you're right
14:16:21 <Oejet> Peaker: Yes, with ReaderT: MyAppMonad { unMyAppMonad :: (ReaderT MyAppData IO a) } deriving (Monad, MonadIO)
14:16:27 <Peaker> Oejet, Yep!
14:16:34 <Peaker> Oejet, do you understand what ReaderT does?
14:16:37 <pumpkin> @hackage contravariant
14:16:37 <lambdabot> http://hackage.haskell.org/package/contravariant
14:16:46 <Peaker> @unmtl ReaderT MyAppData IO a
14:16:46 <lambdabot> MyAppData -> IO a
14:17:13 <parcs> accel: ah. then install ghc from source with PREFIX=/usr/local, confirm that it works, then apt-get remove --purge ghc
14:17:29 <parcs> (or whatever the package is named in the ubuntu repos)
14:17:45 * scooty-puff is wondering why the Reader type exists
14:18:08 <accel> parcs: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable <-- what versio ndo I want?
14:18:08 <parcs> scooty-puff: you mean monad?
14:18:24 <scooty-puff> newtype Reader ...
14:18:50 <scooty-puff> seems like (->) satisfies it MonadReader properly, yes?
14:19:08 <parcs> accel: i'd get just ghc: http://www.haskell.org/ghc/download_ghc_7_0_1
14:19:23 <Oejet> Peaker: No, not completely. The transformer tutorial has the insight, I think.
14:19:37 <Peaker> Oejet, Do you understand what Reader does?
14:19:55 <Peaker> Oejet, how (>>=), return and ask are implemented in the reader monad?
14:19:57 <elliott> Are "where" clauses per-guard or per-clause?
14:20:09 <Peaker> elliott, per-clause, common to guards
14:20:20 <elliott> yay
14:20:30 <Peaker> I think that's supposed to be the main difference between them and "let".  I like that they don't require "in" :)
14:20:32 <Oejet> Peaker: I could not implemented, but I have an idea.
14:20:46 <Peaker> Oejet, What hides behind "Reader r a" ?
14:20:57 <int80_h> :t Maybe
14:20:58 <lambdabot> Not in scope: data constructor `Maybe'
14:21:23 <int80_h> Maybe has a type, right?
14:21:38 <aperiodic> is there any way to tell if a given datatype is part of a given typeclass in ghci?
14:22:07 <parcs> aperiodic: :info Type
14:22:12 <harlekin> Is there a function doing the same as mapM id?
14:22:18 <Peaker> int80_h, Maybe *is* a type (constructor), it has a kind
14:22:19 <int80_h> :info Maybe
14:22:43 <Peaker> you can use @type and @hoogle to find out
14:22:46 <Peaker> @type mapM id
14:22:47 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
14:22:48 <parcs> harlekin: sequence?
14:22:54 <accel> parcs: is there a way to install ghc 7.0.1 via cabal-install ?
14:22:55 <parcs> @type sequence
14:22:56 <Peaker> @hoogle (Monad m) => [m b] -> m [b]
14:22:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:22:57 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:22:57 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:22:57 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
14:23:05 <Oejet> A record with one member: A function, runReader :: r -> a.
14:23:06 <harlekin> parcs, seems to be it. Thanks. (:
14:23:09 <int80_h> cool. 
14:23:14 <Peaker> harlekin, @type -> @hoogle reveals it is sequence without sentient thought needed :)
14:23:27 <parcs> accel: no
14:23:34 <Peaker> @kind Maybe
14:23:35 <lambdabot> * -> *
14:24:00 <Peaker> Oejet, if it's a record of just one member, we don't need the record
14:24:11 <Peaker> Oejet, oh you're looking at the newtype's record syntax
14:24:12 <harlekin> Peaker, I'll remember that. Thank you.
14:24:46 <Oejet> Peaker: Yes.
14:24:46 <Peaker> Oejet, so,  what would the type of bind and return be for Reader?
14:25:14 <Peaker> Oejet, it's safe to safe   Reader r a   is essentially   r -> a   (with a newtype wrapper, but that's less important for understanding)
14:25:44 <Peaker> Oejet, what are the types of bind and return in general?
14:26:02 <Oejet> Peaker: return :: a -> m a.
14:26:30 <conal> hpc: on the other hand, Contrafunctor
14:27:04 <Oejet> Peaker: (>>=) :: m a -> (a -> m a) -> m a
14:27:15 <Oejet> Peaker: That's from memory.
14:27:18 <pumpkin> m b
14:27:56 <Oejet> pumpkin: right, the function is (a -> m b).
14:28:32 * ddarius recommends Oejet buys a new memory.
14:29:13 <Peaker> Oejet, (>>=) :: m a -> (a -> m b) -> m b
14:29:28 <Peaker> Oejet, what's the kind of "m"?
14:29:46 <Oejet> Peaker: return :: a -> Reader r a
14:30:02 <Oejet> Peaker: * -> *
14:30:22 <Oejet> Peaker: I have no idea what a kind is. That's just a guess. :P
14:30:23 <Peaker> Oejet, right. In the case of Reader, what is "m" equal to?
14:30:41 <Peaker> Oejet, hehe, so let's take a step back
14:30:46 <Oejet> m = Reader r
14:31:07 <Peaker> Oejet, Which of these types are valid types of actual values?   Int, String Int, [], Char, [] Char?
14:31:41 <Oejet> All but number two.
14:32:51 <Twey> Missing one
14:32:52 <ski> `[]' isn't a valid type of actual values
14:32:58 <ski> @kind []
14:33:00 <lambdabot> * -> *
14:33:05 <Twey> Gave it away :þ
14:33:05 <ski> @kind String Int
14:33:07 <lambdabot>     `String' is applied to too many type arguments
14:33:07 <lambdabot>     In the type `String Int'
14:33:14 <Oejet> Oh, indeed.
14:33:23 <Twey> String :: *, [] :: * -> *
14:33:33 <Twey> A type is something of kind *
14:33:42 <Oejet> Aha.
14:33:43 * ski would say a "concrete type"
14:33:55 <Twey> * -> * we call a ‘type constructor’ — it yields a concrete type when applied to another type
14:34:16 <Twey> Much like functions to values, except that functions are values, but type constructors cannot be used as concrete types
14:34:35 <mauke> (* -> *) -> *
14:34:42 <ski> (and i would not call `Either Int' a "type constructor", though both `Either' and `Int' i would call that)
14:35:06 <Twey> ski: But Int is a type
14:35:14 <ski> as well, yes
14:35:16 <Twey> I would probably call Either Int a type constructor
14:35:21 <Twey> Either too
14:35:28 <ski> `True' is a data constructor, as well as a value
14:35:38 <Peaker> Oejet, So the kind system is basically a very simple type system for types for Haskell to figure out which types are valid and which aren't
14:35:41 <Twey> Aye
14:36:10 <Peaker> Oejet, * is the kind of types that have values.   * -> *  is the kind of type constructors that take types-that-have-values, and return types-that-have-values
14:36:36 <Peaker> Oejet, Using * and (->) between kinds, you can build infinite kinds:  * -> *,  (* -> *) -> *,  (* -> *) -> * -> *,  and many of these are actually useful! :)
14:36:57 <ddarius> ski: I think you can make a good argument for "type" unadorned meaning "type of kind *" to use Report terminology.
14:36:57 <Twey> Well
14:37:06 <mauke> data T f = C (f Int)
14:37:20 <Twey> I'm not convinced that ‘many’ of the infinite possible kinds are valid, mathematically speaking
14:37:40 <Twey> In fact, I'd say that the use of almost all would result in my wanting to hit someone
14:37:44 <Peaker> Twey, I should have said "all" since "these" are just those I mentioned :)
14:37:51 <Twey> Ah, okay :þ
14:38:26 <ddarius> Twey: Why wouldn't they be mathematically valid?
14:39:02 <ski> ddarius : yes .. i'm questioning whether that meaning of the word is sensible, in the long run
14:39:16 <Twey> ddarius: It's the ‘many’ to which ‘mathematically speaking’ applies
14:39:30 <Peaker> Oejet, so another important thing to mention is that type-classes in Haskell specify what kind their instances should have
14:39:31 <Twey> Countably infinite set, and all that.
14:39:39 <Oejet> Peaker: A Reader is quite boring, since all it can do is "ask": do { x <- ask; x <- ask; return x }.
14:40:01 <Peaker> Oejet, so what is the m equal to in the case of the Reader instance?
14:40:28 <Oejet> Peaker: m = Reader r
14:40:41 <Peaker> Oejet, great
14:40:49 <ski> right, so `Reader r' is a monad (for every `r'), `Reader' itself is not a monad
14:40:51 <Peaker> Oejet, so what is the type of return and bind for the Reader case?
14:41:49 <Oejet> return :: a -> Reader r a,  (>>=) :: Reader r a -> (a -> Reader r b) -> Reader r b.  Hmm.
14:42:02 <Peaker> Oejet, then try to replace  (Reader r a) with (r -> a). If we can implement the type like that, implementing it with the newtype wrapping/unwrapping too will be easy
14:43:21 <ddarius> ski: The key thing for me is that for values v, v :: T only if T :: *.
14:44:07 <Oejet> Argh, return :: a -> (r -> a),   (>>=) :: (r -> a) a -> (a -> (r -> b)) -> (r -> b).
14:44:43 <ski> (Twey : re giving it away, i didn't spot that being a "rhetorical"(that's not quite it, but i can't come up with the right term) question .. i thought Peaker was asking Oejet about that because Peaker was unsure)
14:45:05 <Oejet> * (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b).
14:45:06 <accel> http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html <-- how do I say: depends on "base GLUT" ?
14:45:21 <ski> ddarius : yes. i agree that's the most important part here
14:45:31 <ddarius> ski: "pedagogical"
14:45:38 <dcoutts> accel: "build-depends: base, GLUT" but it's usual to specify versions
14:45:50 <accel> base -any, GLUT -any? :-)
14:45:54 <ski> ddarius : i was thinking about that term, but i wasn't sure if it'd be correct
14:45:55 <dcoutts> accel: see http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#buildinfo
14:46:03 <ski> (i.e. if it would be specific enough)
14:46:35 <Peaker> Oejet, Yep!
14:46:38 <accel> dcoutts: thanks
14:46:49 <ddarius> ski: Well, you could use "Socratic" as well, but I wouldn't characterize Peaker and Oejet's conversation as quite a Socratic dialogue.
14:46:51 <Peaker> Oejet, so try to implement a value with that type
14:47:54 * ski imagines Peaker with a long grey beard, refusing to eat beans ..
14:50:59 <Oejet> (ra >>= f) = f (ra r), where does r come from?
14:51:16 <elliott> If I use foldl to process a bytestring byte-by-byte, will using lazy bytestrings be more efficient?
14:51:50 * ski has wondered whether it would be possible and sensible to invent a term syntax for `v :: T' such that `T :: * -> *' (and where `T' is, say, an applicative functor)
14:51:54 <Cale> Oejet: Where does that equation come from?
14:51:55 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:52:18 <Cale> lambdabot: @join ##smt
14:52:20 <Oejet> Cale: It's supposed to be the bind function of a Reader r a.
14:52:30 <Peaker> Oejet, Remember f = \x -> \y -> ...  can be expressed:  f x y = ...
14:52:34 <Cale> (ra >>= f) r = f (ra r) r
14:52:52 <Peaker> Oejet, also remember that (->) for function type is right-associative
14:52:57 <Cale> I think someone lost some bits of the definition
14:53:18 <Peaker> Oejet, so: (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)      can drop the last ():   (>>=) :: (r -> a) -> (a -> (r -> b)) -> r -> b.
14:53:32 <Peaker> Oejet, is it clearer where the "r" comes from?
14:53:54 <Peaker> Oejet, to avoid a bit of confusion, maybe you should name your definition bind, rather than (>>=) at first
14:54:20 <jmcarthur> elliott: it depends on the size and producer of the bytestring
14:54:38 <elliott> jmcarthur: Like 100K, and readFile.
14:54:39 <Oejet> Hm! (>>=) takes three arguments!
14:54:51 <elliott> Oejet: Only in the ((->) r) monad.
14:55:04 <jmcarthur> elliott: if the producer of the bytestring is lazy and the size is pretty large, yes, for space reasons it's possible that a lazy bytestring might be faster
14:55:16 <elliott> jmcarthur: Mm. Seemed not though.
14:55:17 <elliott> @hoogle mmap
14:55:18 <lambdabot> No results found
14:55:21 <jmcarthur> elliott: but not by much, if any
14:55:23 <elliott> I think what I really want is mmap of some kind. :-)
14:55:27 <elliott> Isn't there a module for that>
14:55:28 <elliott> *that?
14:55:30 <jmcarthur> yeah
14:55:39 <jmcarthur> i've never used it and can't comment on how nice it is or is not
14:55:47 <jmcarthur> s/ or is not//
14:55:50 <elliott> http://hackage.haskell.org/package/bytestring-mmap
14:55:51 <Oejet> elliott: Yes, only with those types.
14:55:52 <elliott> Promising.
14:56:02 <dabblego> What is a semigroup called without associativity necessarily?
14:56:19 <jmcarthur> dabblego: so... just a binary operation?
14:56:25 <jmcarthur> a magma, i guess
14:56:31 <dabblego> Yes, have a name?
14:56:37 <jmcarthur> magma
14:56:40 <dabblego> Oh yeah I guess
14:56:44 <dabblego> Thanks
14:56:46 <jmcarthur> np
14:56:52 <aristid> that's a weird name oO
14:57:04 <elliott> Or groupoid.
14:57:13 <jmcarthur> i thought groupoid was different
14:57:14 <aristid> that's less weird
14:57:14 <Peaker> Oejet, btw you didnt implement return too
14:57:16 <elliott> [[In French, the word "magma" has multiple common meanings, one of them being "jumble". It is likely that the French Bourbaki group referred to sets with well-defined binary operations as magmas with the "jumble" definition in mind.]]
14:57:22 <elliott> groupoid is an ugly word though.
14:57:25 <elliott> Everyone should say magma instead.
14:57:33 <jmcarthur> groupoid is different
14:57:38 <aristid> elliott: magma makes me think of lava
14:57:39 <jix> jmcarthur: groupoid is a different thing in category theory
14:57:45 <jmcarthur> oh, okay
14:57:47 <elliott> jmcarthur: "In abstract algebra, a magma (or groupoid; not to be confused with groupoids in category theory) is a basic kind of algebraic structure."
14:57:48 <elliott> yeah
14:57:51 <elliott> ambiguity -> don't say that
14:57:52 <elliott> say magma :P
14:57:54 <elliott> aristid: AND?!
14:58:13 <aristid> elliott: i don't want to be burned by a set with a binary operation
14:58:16 <jmcarthur> i thought a groupoid was basically a group but with a partial function
14:58:32 <elliott> the burning of all things is inevitable. mwahahaha
14:58:39 <elliott> what i'm saying is: arson
14:59:09 <jmcarthur> i think a magma still requires totality, doesn't it?
14:59:14 <jmcarthur> i guess i should just check wikipedia
14:59:18 <jix> jmcarthur: a magma does
14:59:56 <aristid> jmcarthur: you can't enforce totality in haskell anyways :)
15:00:06 <jmcarthur> according to wikipedia the algebraic and category-theoretic definitions of groupoid are equivalent
15:00:27 <jmcarthur> aristid: no, but you can document it as a law for a type class
15:00:32 <Peaker> Oejet, I'm gonna go sleep soon
15:00:50 <jix> jmcarthur: surely a magma isn't a category groupoid
15:00:52 <jmcarthur> maybe with the qualification that inputs are not _|_
15:00:53 <ski> (jmcarthur : .. or simply for a datatype)
15:01:00 <Peaker> Oejet, you can toy with @djinn, e.g:
15:01:09 <Peaker> @djinn (r -> a) -> (a -> (r -> b)) -> r -> b
15:01:09 <lambdabot> f a b c = b (a c) c
15:01:15 <jix> jmcarthur: but the groupoid you described (non total) could be a category groupoid
15:01:25 <Peaker> @djinn a -> (r -> a)
15:01:25 <lambdabot> f a _ = a
15:01:25 <adnap> does this make more sense than a Physical type class: http://hpaste.org/43752/physics
15:01:44 <Oejet> Peaker: return :: a -> (r -> a)  ... return :: a -> r -> a ... return x = \r -> x
15:01:48 <jmcarthur> jix: the algebraic description of groupoid here doesn't look the same as a magma to me http://en.wikipedia.org/wiki/Groupoid
15:01:55 <Peaker> adnap, IMO, yes
15:01:59 <jmcarthur> oh doh!
15:02:02 <jmcarthur> it links to magma though
15:02:12 <dolio> It's probably an algebraic description of the category theoretic groupoid.
15:02:19 <jmcarthur> it just gives an algebraic definition for the category-theoretic groupoid there
15:02:21 <adnap> this is more like a "has-a" relationship than an "is-a" relationship
15:02:21 <Peaker> Oejet, what other syntax is there besides:  return x = \r -> x ?
15:02:26 <jmcarthur> yeah :)
15:02:30 <jmcarthur> okay now i see
15:02:38 <adnap> every physical object would have to "have" a Physical
15:02:39 <Oejet> Peaker: ... return x r = x, as djinn suggested.
15:02:45 <adnap> rather than be a Physical
15:02:52 <Peaker> Oejet, Yeah, or _ to emphasize it's not used
15:02:59 <Peaker> Oejet, do you know the "const" function?
15:03:04 <Peaker> @src const
15:03:04 <lambdabot> const x _ = x
15:03:06 <Peaker> @type const
15:03:07 <lambdabot> forall a b. a -> b -> a
15:03:08 <adnap> i just don't see how to have a Physical type class if you want to manipulate the object
15:03:20 <Oejet> Peaker: return = const
15:03:28 <Peaker> Oejet, yep!
15:03:34 <adnap> but semantically, it makes more sense to "be" a Physical than to have one
15:03:49 <Peaker> Oejet, what about bind, did you manage to follow the type and implement it on your own?
15:04:08 <Peaker>  (>>=) :: (r -> a) -> (a -> (r -> b)) -> r -> b   <-- can you eliminate the last redundant () in there?
15:04:31 * hackagebot pwstore-fast 2.0 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.0 (PeterScott)
15:04:33 * hackagebot pwstore-purehaskell 2.0 - Secure password storage, in pure Haskell.  http://hackage.haskell.org/package/pwstore-purehaskell-2.0 (PeterScott)
15:05:16 <Oejet> bind :: (r -> a) -> (a -> r -> b) -> r -> b
15:05:28 <Peaker> Oejet, now implement it :)
15:05:55 <accel> what's an Data.IORef? (seeing it in the OpenGL tutorial) is it basically like a global variable holder ?
15:05:58 <jmcarthur> adnap: contrary to common OO dogma, i don't personally think the difference between "has-a" and "is-a" is very useful for most code, and constraining yourself to those kinds of relationships is likely to lead to a fairly narrow-minded approach and weird, unnatural code in the end
15:06:06 <jmcarthur> accel: it's a mutable reference
15:06:21 <jmcarthur> accel: like a variable in impure, imperative languages
15:06:24 <accel> ~/bin/haq 
15:06:25 <accel> Stack space overflow: current size 8388608 bytes.
15:06:25 <accel> Use `+RTS -Ksize -RTS' to increase it.
15:06:30 <Oejet> Peaker: bind ra arb r = arb r (ra r)
15:06:34 <accel> jmcarthur: got it; thanks
15:06:42 <accel> wtf does my above error mean?
15:06:45 <ski> accel : yes, an `IORef a' is an index into the global state which is accessed by `IO'-actions
15:06:45 <accel> it looks bad-ish
15:06:58 <Peaker> Oejet, arb takes the "a" first
15:07:15 <jmcarthur> accel: it means you have a space leak (probably related to improper use of laziness or strictness)
15:07:29 <jmcarthur> well, a specific kind of space leak, that is
15:07:35 <accel> jmcarthur: is there an equiv to "gdb; run; ... and get a stack trace" ?
15:07:37 <Oejet> Peaker: Ah, bind ra arb r = arb (ra r) r
15:07:39 <jmcarthur> which is that you have a crazy thunk chain going on
15:07:56 <Peaker> Oejet, yep. and you can replace bind with (>>=):
15:07:58 <jmcarthur> accel: the stack that's overflowing is not a call stack like in C
15:08:08 <Peaker> (>>=) ra arb r = arb (ra r) r
15:08:17 <Peaker> Oejet, and then you're allowed to place the (>>=) infix between the first two args:
15:08:25 <monochrom> there is no equiv to "gdb; run; stack trace". it is impossible. ghc execution model is not c execution model.
15:08:27 <Peaker> (ra >>= arb) r = arb (ra r) r    <-- but you need () there
15:08:28 <jmcarthur> accel: what's probably happening is you have an accumulator somewhere and you aren't forcing it to be evaluated as you recurse
15:09:20 <accel> jmcarthur: I'm copying/pasting from: http://www.haskell.org/haskellwiki/OpenGLTutorial2
15:09:22 <Peaker> Oejet, or you could write:  ra >>= arb  =  \r -> arb (ra r) r 
15:09:38 <Peaker> Oejet, anyway, let's now implement it "properly" with the Reader newtype wrapper
15:10:57 <Oejet> Peaker: Let me give it a shot...
15:11:23 <elliott> Is there a System.Process.system-alike that takes a ByteString?
15:11:33 <jmcarthur> accel: i'm going to make a guess that the idle callback is being called very fast and the angle is being added to without being forced
15:11:56 <jmcarthur> accel: or maybe your display callback isn't using the angle at all?
15:12:06 <Peaker> Oejet, anyway, I'm gone to sleep! night!
15:12:30 <accel> jmcarthur: http://hpaste.org/43753/accel how do I force the addition?
15:12:38 <Peaker> Oejet, you should also figure out the type of "ask" and how to implement that, and then "runReader" and then you have the interesting part of "reader" done
15:13:40 <jmcarthur> accel: you could try this: http://hpaste.org/paste/43753/accel_annotation#p43754
15:13:50 <jmcarthur> accel: i don't *know* that this is the problem though
15:13:52 <Oejet> Peaker: return a = Reader (\r -> a),  (ra  >>= arb) = Reader $ \r -> arb (ra r) r.
15:14:02 <int80_h> http://hpaste.org/43755/first_attemp_using_writer_mona
15:14:03 <Oejet> Peaker: Thank you!! Good night.
15:14:15 <accel> jmcarthur: is there an operator X s.t. $=!   = $= . X ?
15:14:17 <jmcarthur> i don't even remember if there is a max frequency that GLUT will call the idle callback
15:14:22 <accel> jmcarthur: I want to separate out the "forcing" and the IORef assignment
15:14:44 <jmcarthur> accel: i'll annotate again
15:14:48 <ski> Oejet : `ra' is a `Reader r a', not a `r -> a', so `ra r' is a type error
15:14:55 <Oejet> Ups, (ra  >>= arb) = Reader $ \r -> (ra r).
15:15:13 <ski> well, that doesn't even use `arb', so it's got to be wrong
15:15:14 <accel> jmcarthur: I don't see your new annotation
15:15:33 <accel> jmcarthur: ah, i see it now
15:15:37 <jmcarthur> i only just added it
15:15:53 <jmcarthur> oops
15:15:56 <accel> shoulnd't athat be: a' `seq` (angle $= a') ?
15:15:58 <jmcarthur> make that last a, an a'
15:16:01 <jmcarthur> yeah
15:16:02 <ski> (Oejet : and you should only use the brackets on the left-hand side there, if you're going to add some more arguments to the left of the `=' .. otherwise you'll get a syntax error)
15:16:12 <jmcarthur> i typoed
15:16:21 <accel> jmcarthur: can I use $! as in http://users.aber.ac.uk/afc/stricthaskell.html#seq ?
15:16:37 <jmcarthur> i'll annotate one more time with that
15:16:46 <Oejet> ski: Okay. Thank you too for your help.
15:17:00 <AmunRa> Hello! I've been looking for examples but can't find'em.. can I use a guard simply as an expression? (on the right hand side of an = ?)
15:17:19 <Oejet> I will let my brain rest now.
15:17:21 <jmcarthur> accel: http://hpaste.org/paste/43753/accel_annotation#p43757
15:17:37 <accel> jmcarthur: got; thanks for all 3 annotations
15:17:42 <jmcarthur> np
15:17:56 <jmcarthur> let me know if it works. if it does, i'll try an update the wiki
15:18:13 <AmunRa> I'd like to avoid `if (something1 x) then A else (if (something 2 x) then B else C)
15:18:24 <jmcarthur> if it doesn't, i was trying to be too fast when reading over it
15:18:30 <ski> AmunRa : guards attach to a defining equation (and to branches in `case') .. you can use `if'-`then'-`else' .. or `case () of () | foo -> ... | bar -> ...'
15:19:07 <ski> AmunRa : or of course define a new helper in a `let' or `where', using guards, and then call that
15:19:48 <AmunRa> case x of x | something1 -> A           | something 2 -> B        | otherwise -> C    ?
15:20:08 <AmunRa> let me try that
15:20:42 <ski> i would use `()' instead of `x' ..
15:21:46 <jmcarthur> accel: does it work?
15:21:59 <int80_h> http://hpaste.org/paste/43755/first_attemp_using_writer_mona#p43758
15:22:12 <int80_h> ski: hiya ski, care to talk to me about the Writer monad?
15:23:01 <ski> > map (unfoldr $ \i -> case () of () | i == 1 -> Nothing | even i -> Just (i,i `div` 2) | otherwise -> Just (i,3 * i + 1)) [1 ..]
15:23:02 <lambdabot>   [[],[2],[3,10,5,16,8,4,2],[4,2],[5,16,8,4,2],[6,3,10,5,16,8,4,2],[7,22,11,3...
15:23:38 * hackagebot graph-rewriting-gl 0.6.4 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6.4 (JanRochel)
15:24:37 <monochrom> int80_h: findCookies headerFile :: Writer [String] ()
15:24:38 * hackagebot graph-rewriting-trs 0.1.1 - Evaluate a first-order term rewrite system interactively using graph reduction  http://hackage.haskell.org/package/graph-rewriting-trs-0.1.1 (JanRochel)
15:25:18 <int80_h> monchrom: Hah! cool thanks I will try
15:25:40 <monochrom> this is not specific to MonadWriter. generally all overly general type signatures suffer the same problem.
15:25:47 <int80_h> monochrom, could you also explain what the contraint in the the function type means?
15:26:56 <monochrom> (MonadWriter [String] m) = (whatever you choose m to be, you need an "instance MonadWriter [String] m" present for it)
15:28:18 <monochrom> if you don't already know multiple parameter type class (ability to "class/instance ClassName T1 T2" not just "class/instance ClassName T1") give us a shout.
15:28:45 <int80_h> shout!
15:28:56 <int80_h> I don't know about that.
15:29:28 <monochrom> I wonder if haskellwiki has a tutorial on it.
15:29:37 <monochrom> does LYAH have it?
15:29:50 <int80_h> I'll bet it does. I will go there and look
15:31:07 <int80_h> monochrom, I did what you suggested and got another error. I'll paste it.
15:32:56 <monochrom> LYAH just sticks with Writer [String] (). I think you should too for the moment. Don't go overly general.
15:33:29 <Cin> How do I avoid this problem? http://hpaste.org/43759/blah_blah_is_less_polymorphic
15:33:37 <int80_h> monochrom: okay, also the error I thought I had was just me trying to print something without a Show instance. Not a real problem.
15:34:04 <adnap> how can you write a lifted function in infix style?
15:34:16 <adnap> liftM2 (+) (Just 2) (Just 3)
15:34:46 <adnap> i mean, i guess you could do (+.) = liftM2 (+)
15:34:53 <ski> > let (<+>) = liftM2 (+) in Just 2 <+> Just 3
15:34:55 <lambdabot>   Just 5
15:34:57 <adnap> and then (Just 2) +. (Just 3)
15:35:05 <Ferdirand> :t (<^)
15:35:07 <lambdabot> Not in scope: `<^'
15:35:07 <adnap> yeah, is that the only way?
15:35:22 <accel> http://hackage.haskell.org/trac/haskell-prime/wiki/deep_seq <-- what does seq/! not take care of that we need deep_seq ?
15:35:30 <Ferdirand> there's some package that allows you to do Just 2 <^(+)^> Just 3
15:36:09 <adnap> i guess there's no way to do it on the fly
15:36:19 <adnap> like `liftM2 (+)` doesn't make any sense
15:39:00 <ski> Cin : you want `getReverse :: Monad m => m (forall a. [a] -> [a])', i think
15:39:45 <Ferdirand> would  "instance (Applicative f, Num a) => Num (f a)" be an abomination ?
15:40:04 <doserj> yes
15:41:13 <ski> semantically, you couldn't guarantee commutativity of addition
15:41:51 <Cin> skaar: Ah, I needed to add the forall on both the declaration and use of getReverse.
15:41:55 <accel> jmcarthur: okay; it all works now :-)
15:42:08 <accel> jmcarthur: any idea how to have the rotation happen at a fixed interval, say 60fps, rather than idle function?
15:42:12 <zygoloid> well, addition need not be commutative for a Num instance :)
15:42:29 <Cin> ski: Thanks, I'll try this in my real code exhibiting the much messier type error. ;-)
15:42:46 <zygoloid> 's not like there are Num laws (sadly)
15:43:28 <doserj> well, (+) and (*) should distribute, IMO
15:44:38 <ski> Cin : you may need `{-# LANGUAGE ImpredicativeTypes #-} or something like that (which, iiuc, has been disabled/removed in later releases of GHC)
15:44:55 <adnap> how do i tell cabal that i want a package that uses an older version of another package, rather than the latest?
15:45:16 <adnap> like, if some package has dependency foo >= 0.1
15:45:22 <adnap> and foo is at version 0.2
15:45:34 <adnap> but foo 0.2 breaks the package
15:45:44 <adnap> so i want it to use foo 0.1
15:45:47 <ski> zygoloid : fwiw, i usually assume (not necesarrily commutative) ring axioms ..
15:46:02 <ski> (with multiplicative unit)
15:46:10 <Cin> ski: Yeah, it does.  ... Great.
15:46:55 <adnap> doesn't this situation happen often?
15:46:58 <ski> Cin : in case it has been removed, you can workaround by `data Foo = Wrap (forall a. [a] -> [a])' and `getReverse :: Monad m => m Foo'
15:48:15 <Cin> ski: I'll try that.
15:48:18 <ski> (which needs `Rank2Types' or `PolymorphicComponents' (more specific) i think)
15:48:55 * Cin nods
15:49:43 * hackagebot listlike-instances 0.1 - Extra instances of the ListLike class  http://hackage.haskell.org/package/listlike-instances-0.1 (JohnLato)
15:53:41 <Cin> Bah, I have to change my functions to get it to work.
15:53:52 <Cin> I'll try it tomorrow when I have the energy to rewrite half my code base.
15:53:59 <Cin> ski: Thanks for your help.
15:54:04 <ski> yeah, that's why this is a workaround
15:54:32 <Cin> Even the impredicative one requries lots of rewriting.
15:54:51 <Cin> Buh.
15:55:18 * ski isn't really sure why the impredicative types were to be scrapped ..
15:55:35 <ski> (maybe some correctness or termination concern ..)
15:59:12 <dolio> I think the claim was that they made the previous implementation too complex for some reason.
15:59:53 <dolio> But I'm not sure why that would be.
16:02:08 <Ferdirand> http://pastebin.com/sMQ1C75q
16:02:22 <Ferdirand> this may be an abomination
16:02:57 <Ferdirand> 2 * [1,2,3] becomes valid :o
16:05:34 <djahandarie> Is there a class with only point/pure/return and mzero/mempty?
16:09:06 <ivanm> djahandarie: yes to the former
16:09:12 <ivanm> and probably to the latter as well
16:09:21 <ivanm> see edwardk's comonad split-up
16:10:08 <djahandarie> I meant together :P
16:10:35 <ivanm> oh, probably not
16:12:28 <djahandarie> And I'm not sure if there is a Pointed class yet in edwardk's new split up actually
16:14:31 <djahandarie> Ugh, Hackage being slow is so irritating
16:14:43 <elliott> How does one catch IOExceptions in a StateT foo IO?
16:14:48 <elliott> With Control.Exception.
16:16:04 * djahandarie switches to github
16:17:10 <Gracenotes> @type \a b s -> liftIO $ catch (runStateT a s) b
16:17:11 <lambdabot>     Ambiguous occurrence `liftIO'
16:17:12 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
16:17:12 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
16:17:22 <djahandarie> Nice thing about category-extras was that everything was in one place
16:17:28 <Gracenotes> @type \a b s -> Control.Monad.Error.liftIO $ catch (runStateT a s) b
16:17:29 <lambdabot> forall (m :: * -> *) s a. (Control.Monad.Error.MonadIO m) => StateT s IO a -> (IOError -> IO (a, s)) -> s -> m (a, s)
16:17:33 <Gracenotes> hmmm. :/
16:17:58 <elliott> Gracenotes: you need Control.Exception.catch
16:18:08 <elliott> but err
16:18:14 <elliott> I'm not sure that runStateT is a good idea there
16:18:22 <Gracenotes> ah right
16:18:30 <adnap> is it possible to automatically derive a monad instance for a type that is essentially a 2-tuple?
16:18:30 <Gracenotes> but same principle
16:18:53 <Gracenotes> elliott: hm.. types are a bit off
16:19:07 <djahandarie> I wonder if I can summon edwardk somehow to ask him questions
16:19:20 * djahandarie takes out his ancient scrolls
16:20:13 <elliott> hmm
16:20:15 <elliott> :t catch
16:20:16 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:21:36 <elliott> aha
16:21:40 <elliott> just using catch itself will work, I think
16:21:40 <elliott> maybe
16:21:48 <elliott> except for ...
16:21:50 <elliott> :t catchT
16:21:51 <lambdabot> Not in scope: `catchT'
16:21:53 <elliott> gah
16:21:55 <elliott> how do you do this :D
16:22:56 <Gracenotes> @type \a b -> StateT $ \s -> Control.Exception.catch (runStateT a s) b
16:22:57 <lambdabot> forall s a e. (GHC.Exception.Exception e) => StateT s IO a -> (e -> IO (a, s)) -> StateT s IO a
16:23:08 <Gracenotes> I think you do have to unwrap the state
16:23:31 <elliott> Gracenotes: >_<
16:23:35 <elliott> isn't there some standard function for this?
16:23:50 <Gracenotes> and you could make the "b" into an (\e -> runStateT (b e) s)
16:23:55 <Gracenotes> there is now? :P
16:25:12 <Gracenotes> I'm not sure the Error monad would help you.. the structure of haskell exceptions is sorta in the identity monad, it's just all bottoms.
16:25:29 <Gracenotes> but catching them isn't
16:25:32 <elliott> yeah
16:26:04 <elliott> @type \a f -> StateT $ \s -> Control.Exception.catch (runStateT a s) (runStateT b s)
16:26:05 <lambdabot>     Couldn't match expected type `StateT s ((->) e) a'
16:26:05 <lambdabot>            against inferred type `Expr'
16:26:05 <lambdabot>     In the first argument of `runStateT', namely `b'
16:26:06 <djahandarie> Is there someway to hijack the [a] datatype so I can continue using its syntax?
16:26:10 <elliott> @type \a b -> StateT $ \s -> Control.Exception.catch (runStateT a s) (runStateT b s)
16:26:11 <lambdabot>     Couldn't match expected type `IO (a, s)'
16:26:11 <lambdabot>            against inferred type `(a1, s)'
16:26:12 <lambdabot>     In the second argument of `Control.Exception.Base.catch', namely
16:26:25 <elliott> djahandarie: with NoImplicitPrelude, maybe. except i don't think the definition of [] is valid haskell.
16:26:28 <elliott> so probably not. but maybe!!
16:26:30 <Gracenotes> catch arg 2 needs an \e
16:26:39 <elliott> @type \a b -> StateT $ \s -> Control.Exception.catch (runStateT a s) (\e -> runStateT (b e) s)
16:26:40 <lambdabot> forall s a e. (GHC.Exception.Exception e) => StateT s IO a -> (e -> StateT s IO a) -> StateT s IO a
16:26:48 <Gracenotes> pretty type at least
16:26:49 <elliott> yay!
16:27:02 <djahandarie> elliott, yeah, I'm more interested in figuring out how to do [a] and such
16:28:09 <adnap> did anyone see my question?
16:29:22 <Gracenotes> adnap: is a monad instance possible?
16:29:48 <adnap> is it possible to automatically derive a monad instance for a type that essentially wraps a 2-tuple
16:30:00 <adnap> whever everything basically operates on one of the elements
16:30:08 <adnap> *where
16:31:14 <Jesin> we need to just put join in the Monad class already
16:31:59 <ski> adnap : how does the two-tuple look like ?
16:32:15 <Jesin> so we can stop writing stuff like
16:32:16 <ski> is this a variant of `Writer' ?
16:32:17 <Jesin>   m >>= f = join (fmap f m) where
16:32:18 <Jesin>     join m = [...]
16:32:37 <ski> Jesin : yes
16:33:24 <adnap> yeah, i guess the one element would have to have a way of being combined, like being an instance of Monoid or something
16:33:28 <adnap> i forgot about that
16:33:34 <Jesin> it seems people are complaining about "oh noes, that means more monad laws"
16:33:35 <adnap> i need to think about how i want my type to work again
16:33:57 <Jesin> but really
16:34:06 <Gracenotes> just to make sure I'm not forgetting something, there's no ((,) a) monad instance.. right?
16:34:18 <Gracenotes> that follows the rules.
16:34:25 <ski> adnap : so basically you want `instance Monoid w => Monad ((,) w)' ?
16:34:31 <Jesin> in that case, why are (<) and (>) and (>=) in the Ord typeclass?
16:34:40 <adnap> there is if a is a monoid
16:34:44 <Gracenotes> well, if you have mempty...
16:34:54 <ski> Gracenotes : there is a `instance Monoid w => Monad ((,) w)' instance .. or at least should be in libs
16:34:55 <Jesin> or (<=) for that matter
16:34:57 <Jesin> :p
16:35:10 <Gracenotes> Jesin: more efficient implementations
16:35:10 <adnap> ski: i'm not sure.  i just said i forgot about that and i need to think about how it should work.  i'm pretty sure monoid makes no sense for what i want.
16:35:35 <homekevin> OK, I haven't even gotten to the I/O section of the tutorial yet, but I was watching a video where it was said that the type of a function tells you if it has side-effects.
16:35:40 <Jesin> Gracenotes: yes, putting "join" in Monad would allow things to be more efficient too
16:35:53 <homekevin> If that's correct, isn't debug logging really hard?
16:35:54 <Gracenotes> makes me wonder why modify is not in MonadState
16:36:19 <adnap> ski: if i were to want that, could i automatically an instance of my type, if it was just a newtype wrapper for a 2-tuple?
16:36:29 <adnap> ski: *derive an instance
16:36:39 <Jesin> for any monad where join is simpler than (>>=), and fmap is more complicated than (.)
16:37:04 <Jesin> putting join in Monad would allow those monads to be more efficient
16:37:19 <ski> adnap : you'd typically do `newtype Foo a = MkFoo (WriterT YourMonoid (...) a) deriving (Functor,Monad)' or something like that
16:37:30 <ski> @src Writer
16:37:30 <lambdabot> Source not found. My mind is going. I can feel it.
16:37:44 <homekevin> Bots don't got feelings
16:37:46 <ski>   newtype Writer w a = Writer {runWriter :: (a,w)}
16:37:56 <ski>   newtype WriterT w m a = WriterT {runWriterT :: m (a,w)}
16:38:07 <ski> (i would prefer `(w,a)' in there, though)
16:38:32 <Jesin> instance Functor (S b) where
16:38:34 <Jesin>   fmap f (F g) = F $ \p -> f (g (p . f))
16:38:36 <Jesin> instance Monad (S b) where
16:38:37 <Jesin>   return x = F (const x)
16:38:39 <Jesin>   m >>= f = join (fmap f m) where
16:38:40 <Jesin>     join (F fnd) = F $ \p -> finder (fnd $ \xs -> p $ finder xs p) p
16:38:46 <Jesin> ^ this code would be more efficient if I could have just defined "join" there
16:39:12 <ski> is that related to the "search" monad ?
16:39:20 <Jesin> possibly
16:39:29 <Jesin> I don't know what the "search" monad is, but this is basically that
16:39:39 <Jesin> I have newtype S b a = F {finder :: (a -> b) -> a}
16:39:53 <ski>   type J r a = (a -> r) -> a  -- or something like that
16:39:56 <Jesin> though maybe I should take out the b parameter, and just fix that at Bool
16:40:31 <ski> nah, why be specific, when you can be generic ?!
16:40:31 <Jesin> the Functor and Monad instances for S nonBoolType
16:40:34 <Jesin> seem kind of useless
16:40:58 <Jesin> for example, if you have a root finding algorithm (Double -> Double) -> Double
16:41:29 <Jesin> then fmap f (F rootfind) is pretty much equivalent to (F rootfind)
16:41:32 <Jesin> :p
16:41:45 <Jesin> well
16:41:53 <Jesin> it does restrict the result to stuff that is in the range of f
16:42:01 <ski> the argument function giving a result whose deviation from zero would express roughly how much the argument deviated from the root ?
16:42:38 <Jesin> umm, well
16:42:40 <Jesin>   fmap f (F g) = F $ \p -> f (g (p . f))
16:42:42 <Jesin> so in this case
16:42:59 <Jesin>   fmap f (F rootfind) = F $ \h -> f (rootfind (h . f))
16:43:04 <ski> so that `\x -> find (\y -> x^2 - y)' might express a square root function .. hm
16:43:45 <Jesin> so finder (fmap f (F rootfind)) == \h -> f (rootfind (h . f))
16:44:06 * ski wants an improving intervals implementation of reals, in Haskell !
16:44:32 <Jesin> which takes an argument h, finds x such that h(f(x)) == 0
16:44:38 <ski> (Jesin : s/==/=/ :)
16:44:38 <Jesin> and then returns f(x)
16:44:53 <Jesin> ski, either way works
16:44:55 <Jesin> :p
16:45:12 <ski> not all types has a computable `(==)' operation
16:45:23 <Jesin> ski, we already said
16:45:31 <Jesin> rootfind :: (Double -> Double) -> Double
16:45:40 <Jesin> so (==) is computable here.
16:46:16 <ski> you have a computable `(==)' over `(Double -> Double) -> Double' ?
16:46:37 <Jesin> ski, I said "finds x such that h(f(x)) == 0"
16:46:43 <ski> <Jesin> so finder (fmap f (F rootfind)) == \h -> f (rootfind (h . f))
16:46:51 <ski> was what i was (primarily) reacting to :)
16:47:24 <djahandarie> Is there a category-theoretical way to make a distinction between foldr and foldl?
16:47:30 <Jesin> huh
16:47:32 <Jesin> hmm.
16:47:34 <Jesin> ok
16:47:38 <int80_h> http://hpaste.org/43761/general_advice_on_function_des
16:47:49 <Jesin> so, let's see
16:47:56 <ski> djahandarie : `foldr' is the catamorphism over right-associated lists. `foldl' is the catamorphism over left-associated lists
16:48:07 <int80_h> function design, looking for discusion on my choices...
16:48:08 <Jesin> fmap (f :: Double -> nonDouble) (F rootfind)
16:48:12 <Jesin> might be useful?
16:48:28 <ski> djahandarie : in Haskell, imagine a right-associated list is implicitly converted to a left-associated one, when using `foldl'
16:48:48 <Jesin> fmap (f :: Double -> Double) (F rootfind) is basically (F rootfind), which is not a very useful fmap
16:49:00 <djahandarie> Is there a way to do that explicitly while keeping it a noop?
16:49:18 <ski> djahandarie : consider `data ListR a = NilR | a :< ListR a' and `data ListL a = NilL | ListL a :> a'
16:49:23 <djahandarie> Right
16:49:37 <dolio> Those are isomorphic.
16:50:55 <ski> so `foldl_ListR snoc nil = foldl_ListL snoc nil . reverseR2L'
16:51:46 <ski> Jesin : .. i'm not following how you reach `F rootFind', there
16:51:55 <djahandarie> Couldn't I just have one datatype with a newtype wrapper with a different instance for 'folding' the other way?
16:52:07 <ski> you could
16:52:28 <ski> (but then you couldn't use infinite `ListL a's, of course)
16:53:24 <djahandarie> Could this also apply to the anamorphism?
16:53:42 <djahandarie> I suppose it would
16:54:29 <ski> i suppose `ListL a' is basically `Dual (ListR a)'
16:54:55 <djahandarie> Can you define Dual in such a way that it'd also do the same for more complex structures?
16:55:19 <ski> (djahandarie : btw, Richard Bird's and Oege de Moor's "Algebra of Programming" talks some on left- vs. right- associated lists)
16:55:26 <Jesin> ski: I meant that finder (fmap (f :: Double -> Double) (F rootfind))
16:55:27 * djahandarie downloads
16:55:42 <Jesin> still finds a root of whatever argument you give it
16:55:58 <djahandarie> Except it isn't a pdf, drat
16:56:17 <ski> you might find it at your local uni library
16:56:29 * djahandarie doubts that but goes to check anyways
16:56:42 <ski> (or you could try inter-library loan)
16:57:38 <djahandarie> Nice, it has it!
16:58:02 <ski> Jesin : yeah, i suppose so .. i can't saw i see this root-finding very clearly
16:58:17 <ski> (s/saw/say/ :)
16:58:40 <Jesin> newtype S b a = F {finder :: (a -> b) -> a}
16:58:42 <Jesin> instance Functor (S b) where
16:58:43 <Jesin>   fmap f (F g) = F $ \p -> f (g (p . f))
16:59:00 <Jesin> so in this case
16:59:36 <Jesin> finder $ fmap f (F rootfinder) = \h -> f (rootfinder (h . f))
16:59:55 <Jesin> (rootfinder h) returns x such that h(x) == 0
17:00:29 <Jesin> finder (fmap f (F rootfinder)) h returns f(x) such that h(f(x)) == 0
17:00:35 <Watermind> I know this may be obvious and I'm surprised I only now thought about it, but using a Reader monad, more than being a way to simplify an algorithm by having to pass less arguments around, provides a way to impose important restrictions at the level of function types
17:01:47 <ski> Jesin : yeah .. iow, `y' such that `h y = 0'
17:01:52 <Watermind> ops brb
17:07:05 <nosila> hi
17:08:06 <nosila> anyone knows how do you "deploy" a haskell project'
17:08:07 <nosila> ?
17:08:11 <dolio> @djinn ((a -> r) -> a) -> (a -> (b -> r) -> b) -> (b -> r) -> b
17:08:12 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
17:08:14 <nosila> have it in .exe or something
17:08:27 <alpounet> nosila, ghc --make ?
17:08:38 <nosila> in winghci
17:08:42 <nosila> is the same?
17:08:51 <dolio> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
17:08:52 <lambdabot> f a b c = a (\ d -> b d c)
17:09:51 <Jesin> ski: what does "iow" mean by the way?
17:10:06 <ivanm> in other words?
17:10:12 <Jesin> k
17:10:25 <Jesin> that makes sense
17:11:09 <nosila> anyone ever worked with haskell integrated in C?
17:11:45 <Jesin> but, this fmap definition
17:11:47 <gienah> nosila: as in: calling haskell from C?
17:12:06 <nosila> yep
17:12:11 <Jesin> if we define findInList :: [a] -> (a -> Bool) -> a
17:12:13 <gienah> yes
17:12:15 <Jesin> findInList [x] _ = x
17:12:17 <Jesin> findInList (x:xs) p = if p x then x else findInList xs p
17:12:49 <Jesin> then fmap f (F $ findInList xs) == F $ findInList (fmap f xs)
17:13:04 <nosila> gienah: how is it? easy to work with? i wanted to use haskell to manage a data structure
17:13:38 <gienah> nosilla: its sort of easy to work with, but difficult to build due to weird linking stuff
17:13:46 <gienah> nosilla: https://github.com/markwright/antlrc-examples/tree/master/src/tapl/arith
17:14:31 <ski> Jesin : interesting
17:14:53 <nosila> gienah: heard that making the linker to work killed the C and Haskell portability, true?
17:15:29 <Jesin> ski, another interesting thing about this monad
17:15:38 <Jesin> instance Functor (S b) where fmap f (F g) = F $ \p -> f (g (p . f))
17:15:39 <Jesin> instance Monad (S b) where
17:15:41 <Jesin>   return x = F (const x)
17:15:42 <Jesin>   m >>= f = join (fmap f m) where
17:15:44 <Jesin>     join (F fnd) = F $ \p -> finder (fnd $ \xs -> p $ finder xs p) p
17:15:50 <gienah> nosilla: I don't know, but I could not figure out how to create a portable build system for C that calls Haskell
17:15:52 <Jesin> is that the function "sequence"
17:16:02 <Jesin> err, well
17:16:16 <Jesin> if you treat S Bool as a monad for searchable sets
17:16:20 <nosila> gienah: anw, if not C, any other language that can do that trick? i'm really positive that having haskell dealing with data structures would improve the performance of my program
17:16:27 <Jesin> then "sequence" acts as a cartesian product :D
17:17:10 <gienah> nosilla: anyway, it seems useful for some stuff, like I can use the ANTLR parser generator to generate C lexer and parser, then do type checking in Haskell
17:17:37 <Jesin> finder $ sequence $ repeat $ F ($ True)
17:17:39 <Jesin> results in a function ([Bool] -> Bool) -> [Bool]
17:17:47 <ski> @type (fst *** fst) &&& (snd *** snd)
17:17:48 <lambdabot> forall c b a b1. ((c, b), (a, b1)) -> ((c, a), (b, b1))
17:18:01 <Jesin> that searches the set of infinite bitstrings for one that satisfies a predicate
17:18:10 <gienah> nosilla: it might help the performance, maybe, if the main() is in C, I'm not sure
17:18:42 <ski> @type \(+) -> curry (join (***) (uncurry (liftM2 (+))) . ((fst *** fst) &&& (snd *** snd)))
17:18:43 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> (m a1, m a1) -> (m a2, m a2) -> (m r, m r)
17:18:54 <gienah> nosilla: as in, the haskell docs seem to not like haskell calling C, then the C calling back to the haskell
17:19:45 <gienah> nosilla: so I was thinking: have the C in main, start processing in C calling Haskell, then just transfer to doing the rest of the stuff in Haskell later after parsing the input files
17:20:38 <ski> (iirc, there shouldn't be a problem of Haskell calling C, which calls back into Haskell)
17:21:22 <dolio> You need to make sure you don't make your foreign imports unsafe, I think.
17:21:25 <dolio> Other than that...
17:21:40 <ski> edwardk : you're late. djahandarie summoned you more than an hour ago ..
17:22:22 <Philonous_> Can I use type families to peel types out of type contructors? E.g.  type family UnFunPtr a :: *; type instance UnFunPtr (FunPtr a) = a
17:22:38 <edwardk> ski: room was still spinning then ;)
17:23:04 * ski didn't notice any spinning ..
17:23:19 <edwardk> ski: (have an annoying inner ear thing going)
17:23:21 <dolio> ski is on some planet that doesn't spin.
17:23:42 <edwardk> ski: perhaps it is a matter of rate. observe the sky for 24 hours, see if you notice any changes.
17:24:13 <ski> it's more a matter of being able to keep up concentration for that long, i should think
17:25:15 <djahandarie> edwardk, hey!
17:25:40 <djahandarie> Has Functor.Pointed be extracted out of category-extras yet? I think I looked through everything and I haven't seen it
17:25:47 <edwardk> i'm killing it dead
17:26:05 <djahandarie> ...
17:26:10 <djahandarie> Lost me :P
17:26:13 <edwardk> it doesn't provide you any laws other than something that is already a free theorem.
17:26:49 <djahandarie> I really just want point in its own class
17:26:58 <ski> (yeah .. i can imagine you have to do "lub"-classes, to regain composite laws in some cases)
17:27:42 <djahandarie> What I /really/ want is point and mzero in its own class
17:28:02 * djahandarie is trying to lift Maybe into a minimal typeclass form
17:28:06 <edwardk> djahandarie: in the work i've been doing with the various semigroupoid classes i've been able to flip things around so that whatever was consuming something i had to make pointed, could be make an instance of Apply or some such instead. this gave me more laws
17:28:40 * ski wants `point' and `click' in a class of their own ..
17:28:59 <djahandarie> I'll just give up and lift it into MonadPlus
17:29:21 <edwardk> there is a Plus class, but i don't give you point/pure/return with it
17:29:54 <edwardk> Plus works because only one little monadplus law is actually used. the others are strangely optional.
17:31:37 <thierry`> hi, I have a program working with ClockTime and I was wondering if ClockTime has lazy evaluation or not. if it did, it could be problematic because when I call ClockTime, I want the time now, not in a few seconds
17:31:48 <edwardk> djahandarie: given point and mzero, how do you stitch the computations together after that?
17:32:29 <djahandarie> Do I need to stitch them together? :P
17:32:53 <edwardk> thierry`: getClockTime  is an IO action, it happens when you call it
17:32:57 <edwardk> not later
17:33:01 <djahandarie> If you're curious as to what I'm doing, I'm trying to generalize Prelude as hardcore as possible
17:33:23 <thierry`> edwardk : thanks :)
17:33:25 <djahandarie> Which means I'm having fun reading through all your stuff right now
17:33:27 <edwardk> djahandarie: the problem there is that you can 'inject' values, but you have no laws saying how they relate in either case
17:34:08 <djahandarie> edwardk, it's not like whatever has Plus and Pointed instances won't have a Monad instance also
17:34:13 <edwardk> you need some kind of associativity on the result or ability to glue them together to be able to ever _use_ that resulting computation, so my challenge to you is to flip around your perspective to the use site ;)
17:34:14 <djahandarie> Or a MonadPlus in this case
17:34:26 <edwardk> sure they might not, what if they are Alternative?
17:34:41 <djahandarie> They might not
17:34:56 <djahandarie> But if they want to glue stuff, then they need one
17:34:58 <djahandarie> Leave it up to them
17:34:59 <edwardk> i'd probably go with Alternative rather than MonadPlus that way you can work with weaker structures
17:35:14 <edwardk> you can glue just fine with Alternative =)
17:35:36 <djahandarie> Yeah Alternative is probably better if I'm coping out
17:35:52 <djahandarie> copping*
17:36:16 <edwardk> well, alternative isn't really a cop out, you need a law for empty to how it relates to pure, and pure needs to relate somehow to how you glue stuff together or you have no semantics to reason about
17:37:00 <djahandarie> So you're saying anything non-Alternative but only Point+Plus would be entirely useless?
17:37:05 <dolio> You don't *need* a law. You could just be creating a class for all the types that can internalize Maybe.
17:37:08 <edwardk> basically, yes
17:37:14 <edwardk> true
17:37:29 <edwardk> it just seems kinda pointless
17:37:37 <dolio> But then as Conor says, Maybe is initial, so just use that.
17:37:43 <edwardk> yep
17:37:45 <adnap> how does this seem?: http://hpaste.org/43763/physical
17:37:45 <djahandarie> It does seem kind of pointless but this whole project is so it won't stop me
17:37:49 <djahandarie> Initial?
17:38:03 <djahandarie> Unrelated: is it possible to uh.. provide constructor synonyms?
17:38:05 <dolio> There is a unique function Maybe a -> m for every m in the class.
17:38:06 <edwardk> every instance of such a class could be defined as a function from Maybe
17:38:15 <adnap> does it seem like an okay design?
17:38:20 <dolio> Or, non-unique, I guess, since bottoms muck things up.
17:38:35 <djahandarie> Hmmm
17:38:53 <edwardk> you could factor any function that used your class into a function to maybe then injected the values into your class
17:39:06 <edwardk> er and then
17:39:18 <djahandarie> Also, more about constructor synonyms...  Nil = Fix . NilP  or something, so I can pattern match on Nil
17:39:48 <edwardk> adnap: very imperative ;)
17:40:05 <adnap> edwardk: what do you mean?
17:40:14 <edwardk> adnap: you asked how it seemed
17:40:19 <adnap> ahhh
17:40:24 <adnap> how?
17:41:12 <edwardk> in that you are building up 'particle objects' and then updating them using a state monad. it is awkward to compose or deal with multiple particles that way
17:41:14 <dolio> Actually, there may not even be a unique function in this case anyway. Since (const zero :: Maybe a -> m) is also a possibility.
17:41:47 <dolio> However, if you assume that we're at least talking about a functor with pure and zero, then Maybe should be the initial such functor, I think.
17:42:01 <adnap> i just want to have the notion of physical objects, and i suppose most physical objects will just carry a particle
17:42:18 <dolio> Where we're now talking about a natural transformation Maybe -> m.
17:42:24 <adnap> so, the object itself doesn't really do anything, while the particle gets forces applied to it and stuff
17:42:45 <dolio> That preserves pure and zero.
17:43:10 <edwardk> adnap: i'm with you until you define Physical, then it seems like that State monad is adding a lot of boilerplate
17:43:34 <adnap> yeah, it kind of is
17:44:09 <adnap> but i don't want to talk about particles
17:44:13 <adnap> i want to talk about physical objects
17:44:45 <edwardk> then define a lens or accessor to get access to some particle from your object, and factor your apply force method through that lens
17:44:54 <edwardk> rather than make your objects into some state monad
17:44:59 <gwern> another day, another spammer on hawiki. and I don't have checkuser to ban their IP
17:45:02 <adnap> eventually, there may be something like
17:45:19 <adnap> well
17:45:24 <adnap> i guess you can't do this with type
17:45:26 <adnap> but imagine
17:45:50 <adnap> type (Collidable a) => Physical a = State a Particle
17:46:11 <adnap> bah
17:46:13 <adnap> i don't know
17:46:29 <edwardk> adnap: are you familiar with fclabels/data accessor?
17:46:33 <adnap> no
17:46:40 <edwardk> i just want to turn your thinking inside out a bit on this.
17:46:50 <adnap> okay
17:47:08 <adnap> i don't really know what you were talking about with the lens thing
17:47:13 <edwardk> import: http://hackage.haskell.org/packages/archive/data-accessor/0.2.1.5/doc/html/Data-Accessor.html
17:47:19 <edwardk> an Accessor is a pair of functions
17:47:39 <edwardk> a getter that takes an an a -> b, and a setter than is a -> b -> a
17:48:02 <thierry`> hey I have vague question, I'm working on a master degree in constraint programming and I love haskell. Is there any way to match haskell and constraint programming? I'm talking about an already existing solid solver such as Choco in Java or Gecode in C++.
17:48:32 <edwardk> the getter can be like any record field autogenerated by haskell, the setter, is just the setBar y x = y { bar = x } — equivalent
17:48:42 <edwardk> so far so good?
17:49:14 <edwardk> now instead of building Colldable, make class Collidable t where particle :: Accessor t Particle
17:49:47 <edwardk> so you now have access through particle to a particle given your object t, so now you can 'apply' forces to the object.
17:50:29 <djahandarie> edwardk, also, why do you write Base instances in Functor.Foldable for non-recursive types? Can that be used for anything at all?
17:50:52 <djahandarie> Foldable instances rather
17:50:54 <edwardk> djahandarie: mostly out of curiosity to see how bad they are ;)
17:51:06 <edwardk> i only did a couple as a nod to the fact that you can do it
17:51:15 <djahandarie> But do they... do anything?
17:51:23 <gwern> 'Mind you, he also has won a couple of parallel-programming contests put on by Intel, and he’s running a lovely series of writeups on the issues over at 1024Cores, including (ahem) Wide Finder 2, from which I quote: “The program contains 17 times more LOC than the initial Ruby program, and is 479 times faster.”'
17:51:32 <edwardk> they are technically correct if you view them as a fixed point that doesn't actually bother to recurse ....
17:51:37 <gwern> yeah, parallel programming can suck that way
17:51:46 <adnap> So, is there an f :: (a -> a) -> Accessor a r -> Accessor a r -> Accessor a r?
17:51:50 <edwardk> but kind pointless
17:51:55 <adnap> wait
17:51:59 <adnap> sorry
17:52:02 <adnap> So, is there an f :: (a -> a) -> Accessor a r -> Accessor a r
17:52:06 <adnap> or
17:52:08 * djahandarie defines it for his own types anyways to see if anything cool comes out of it
17:52:12 <adnap> So, is there an f :: (a -> b) -> Accessor a r -> Accessor b r
17:52:40 <edwardk> adnap: (^:) :: Accessor r a -> (a -> a) -> r -> r
17:53:23 <edwardk> so particle ^: apply    — would be how i would write your current apply instead
17:53:53 <edwardk> no, but there is a Category for accessors
17:53:56 <edwardk> so you can build
17:54:16 <edwardk> (.) :: Accessor b c -> Accessor a b -> Accessor a c
17:54:32 <edwardk> and you can make instance Collidable Particle where particle = id
17:54:54 <adnap> whoa
17:54:57 <nosila> gienah: sorry for the late answer, please write nosila, with only one 'l' so this can alert me xD anw, that was what i had in mind
17:54:58 <adnap> this is kind of confusing
17:55:10 <nosila> gienah: for example, having a binary search tree
17:55:26 <adnap> so, an accessor is kind of like a dummy thing, and then something else that you get and set?
17:55:42 <adnap> or is the dummy more than a dummy?
17:55:44 <edwardk> no, an accessor doesn't contain the dummy thing, just provides the actions to get and set it
17:56:12 <edwardk> an accessor provides you with a 'path to a value'. you still need to supply the thing the path describes
17:56:17 <edwardk> lets build one
17:56:26 <Philonous> What do I need to do to to able to speak in #haskell-in-depth ?
17:56:26 <nosila> gienah: the C only had to give the haskell the "strings" + ints and stuff, haskell then would have functions to add new "things" to the tree
17:56:32 <nosila> and manipulate it
17:56:37 <nosila> would be sweet i think
17:56:49 <adnap> man, i wish this hackage page didn't use all kinds of different letters that don't correspond
17:56:50 <edwardk> fstAccessor = fromSetGet (\(_,b) a -> (a, b)) fst
17:57:02 <edwardk> T = Accessor
17:57:11 <edwardk> its unfortunate but the package was henning'd ;)
17:57:27 <adnap> what is T?
17:57:45 <edwardk> T is whats used all over the page. internally he likes to name his data types T and classes C.
17:57:55 <edwardk> Accessor is an alias exposed by Data.Accessor
17:58:02 <adnap> I see
17:58:37 <adnap> so he has Accessor r a
17:59:01 <adnap> is r the thing you set/get?
17:59:04 <edwardk> yes, now the fstAccessor above defines an accessor that knows how to get the first element out of a pair or change it
17:59:21 <edwardk> yeah r is the container, a is the thing down inside the container you want to tweak
17:59:37 <edwardk> fstAccessor :: Accessor (a,b) a
17:59:55 <adnap> i guess fromGetSet is the same as accessor?
17:59:59 <adnap> sorry
18:00:02 <adnap> fromSetGet
18:00:13 <edwardk> yeah
18:00:15 <adnap> i don't see it on the hackage pagfe
18:00:19 <adnap> okay
18:00:25 <edwardk> that works, args are flipped. Data.Accessor.Basic provides the other
18:00:33 <edwardk> accessor is perfect
18:00:34 <elliott> ghc: panic! (the 'impossible' happened)
18:00:34 <elliott>   (GHC version 6.12.3 for x86_64-unknown-linux):
18:00:34 <elliott> 	TcTyFuns.flattenType: synonym family in a rank-n type
18:00:37 <elliott> wat
18:00:46 <elliott> please tell me that's a known bug :-)
18:00:54 <edwardk> fstAccessor = accessor fst $ \(_,b) a -> (a,b)
18:01:25 <adnap> i think i get it
18:01:27 <elliott> hmm, I like the idea of defining virtual accessors
18:01:30 <edwardk> setVal fstAccessor 1(2,3) — returns (1,3)
18:01:32 <djahandarie> edwardk, I just defined a Foldable instances and it feels like all I'm doing is stripping Fix off something. Did I do it wrong?
18:01:33 <adnap> r is the container
18:01:34 <elliott> seriously though, that GHC error... wow
18:01:38 <adnap> and r should have an a in it
18:01:45 <adnap> in this case, the container is (a, b)
18:01:48 <adnap> and a is a
18:01:50 <adnap> ha
18:01:58 <edwardk> djahandarie: what is the instance?
18:02:18 <edwardk> djahandarie: that is exactly what it should be doing in the case of 'out'
18:02:28 <edwardk> djahandarie: i wanted something cheap ;)
18:02:55 <adnap> type Physical a = Accessor (Particle, a) Particle
18:02:57 <djahandarie> data ListP a b = NilP | ConsP a b; type List a = Fix (ListP a); instance Foldable (List a) ...;
18:03:16 <djahandarie> (Doing what you did in your class but the opposite way
18:03:31 <djahandarie> I like the Base/Prim thing you did though, it's neat
18:03:44 <edwardk> thats fine, you don't even need to define an instance, just use the definition of Base for Fix
18:03:44 <adnap> or maybe
18:03:52 <adnap> type Physical a = Accessor a Particle
18:04:09 <edwardk> adnap: thats fine, but if you make it a class, then you can avoid having to pass them around ;)
18:04:23 <djahandarie> edwardk, oh heh, I missed that
18:04:26 <adnap> make Physical a class?
18:04:30 <edwardk> class Physical a where particle :: Accessor a Particle
18:04:37 <adnap> ooh
18:05:08 <edwardk> instance Physical Particle where particle = id
18:05:13 <adnap> niiiice
18:05:15 <adnap> i like
18:05:29 <djahandarie> So if I recursively define the type and make it a Functor I get the Foldable/Unfoldable for free basically?
18:05:42 <edwardk> yeah
18:05:46 <adnap> i guess particle should be more like center of mass or something
18:05:48 <djahandarie> Neato
18:05:56 <adnap> since that's essentially what it describes
18:06:09 <edwardk> Fix is implicitly unfoldable. you only need to make up new definitions of Base when you don't explicitly tie the knot with Fix, Mu or Nu
18:06:19 <edwardk> adnap: feel free to rename ;)
18:06:19 <djahandarie> Yeah, I see it now
18:06:36 <djahandarie> Though I still don't see where I'm suppose to use Mu/Nu but I suppose it'll be clear in time
18:07:29 <edwardk> adnap: then impulse :: Physical t => Force -> t -> t ; impulse f t = t :^ apply f
18:07:55 <edwardk> djahandarie: they exist as sort of pathological cases they demonstrate there are two other ways to tie the knot
18:09:13 <djahandarie> So if I'm able to define Mu or Nu for my type I can do the exact same thing as if I defined it with Fix
18:09:25 <djahandarie> (Which means I should be able to define Mu or Nu for it, I suppose)
18:10:44 <adnap> edwardk: yes, this is lookin' good
18:11:25 <adnap> edwardk: i'm going to use FRP.Reactive, so the particles acceleration, velocity, and position will be behaviors
18:11:27 <djahandarie> edwardk, just wonderin though, won't this Foldable end up conflicting with Data.Foldable and get annoying? :P
18:11:27 * hackagebot qd 0.4.1 - double-double and quad-double number type via libqd  http://hackage.haskell.org/package/qd-0.4.1 (ClaudeHeilandAllen)
18:11:34 <adnap> i hope it all works out
18:11:46 <edwardk> djahandarie: the name is somewhat unfortunate
18:12:16 <djahandarie> Don't you have some scarier name you can drop in there? :P
18:12:44 <djahandarie> Though I guess this Foldable does everything Data.Foldable.Foldable does...
18:12:49 <edwardk> i'm deliberately trying _not_ to be scary ;)
18:12:50 <ClaudiusMaximus> (that qd release has a 4 char diff - but no longer crashes when you decodeFloat large numbers...)
18:12:57 <djahandarie> Yeah I noticed this time around lol
18:13:51 <edwardk> recursion-schemes was mostly just a ploy to get that content out of category-extras
18:14:26 <edwardk> because it uses so many language extensions i can't really use it in the core of my own work
18:15:22 <djahandarie> It would be nice having examples of all these stranger morphisms
18:15:37 <edwardk> djahandarie: what about zygoHistoPrepro :: (http://hackage.haskell.org/packages/archive/recursion-schemes/0.4.0.3/doc/html/Data-Functor-Foldable.html#t:Unfoldable t, http://hackage.haskell.org/packages/archive/recursion-schemes/0.4.0.3/doc/html/Data-Functor-Foldable.html#t:Foldable t) => (http://hackage.haskell.org/packages/archive/recursion-schemes/0.4.0.3/doc/html/Data-Functor-Foldable.html#t:Base t b -> b) -> (forall c. http://hacka
18:16:31 <edwardk> djahandarie: you are welcome to skim through uustalu and vene and jot down examples and i'll include them ;) its just kind of on the fringe of my interests atm
18:16:59 <djahandarie> Hah okay
18:17:18 <djahandarie> I don't think my fu is high enough to read uustalu and vene yet
18:17:59 <adnap> what do i do if i'm trying to get a package from cabal, and one of its dependencies broke the package by upgrading or something?
18:18:12 <edwardk> i also need to get around to adding Data.Bifunctor.Foldable at some point to provide the bifunctor equivalents
18:18:20 <Philippa> djahandarie: read stuff, decide if you would benefit from re-reading having gained more fu later
18:18:27 <edwardk> those tend to work more nicely for things like [a], etc.
18:18:47 <adnap> i'm trying to install fieldtrip
18:19:16 <edwardk> adnap: ghc-pkg unregister helps, then you can cabal install the other to fix things up
18:19:25 <edwardk> but its easy to break your configuration entirely so be careful
18:19:29 <adnap> and it says that the opengl package doesn't export Vector2
18:19:44 <adnap> so unregister my opengl package?
18:19:57 <adnap> i think opengl changed and broke fieldtrip
18:20:25 <djahandarie> Philippa, well I've skimmed it before and noted that I should gain consideribly more fu before even trying :P
18:20:40 * djahandarie has just been going through easier texts and doing exercises in his free time
18:20:48 <augur> @tell copumpkin are you godofpumpkins?
18:20:49 <lambdabot> Consider it noted.
18:20:52 <djahandarie> Yes.
18:20:59 <djahandarie> @ augur
18:21:05 <augur> :o
18:21:33 <augur> ive got a cheap unification-based type inference system :T
18:21:42 <djahandarie> HM? :P
18:21:54 <augur> and it handles parametric polymorphism and type operators!
18:22:00 <augur> djahandarie: i dont know if its HM
18:22:42 <adnap> edwardk: so, unregister the package that breaks the package i want to install?
18:22:48 <edwardk> yeah
18:23:07 <Philippa> if it generalises on let, instantiates on variable use and otherwise just does equality constraints on monotypes-with-variables-in-them, it's pretty much HM
18:23:38 <adnap> edwardk: it's going to break a bunch of other stuff.  i guess i have to?
18:24:20 <Philippa> if it's actually handling parametric polymorphism properly rather than just catching stuff that's still unconstrained when you get back up past top level again, that's probably what you're doing
18:27:32 <adnap> ah
18:27:35 <adnap> it still fails
18:27:54 <adnap> is there any way to tell cabal to use an older version of a dependency?
18:28:25 <djahandarie> Hm, catMaybes is proving to be really annoying to write with the recursively-defined List type
18:28:39 * djahandarie isn't sure how to properly talk about 'skipping a value'
18:29:04 <djahandarie> In fact this is exactly what catMaybes does, so it's more like I'm not sure how to break down skipping values into smaller things :P
18:29:40 <elliott> Dear Diary: Today, I had to use unsafeCoerce. I am sorry.
18:29:54 <djahandarie> Repent!
18:30:04 <Axman6> had to?
18:30:06 <edwardk> elliott: i have code on hackage that uses it like 5 times in a line ;)
18:30:16 <elliott> djahandarie: that _was_ my repenting
18:30:19 <djahandarie> Every time you unsafeCoerce, God kills a lambdacat
18:30:36 <kfish> djahandarie, things worth keeping vs. things that can be skipped :-)
18:30:36 <elliott> Axman6: well, I can either make my internal interface much less awesome, or avoid one unsafeCoerce that is absolutely safe, it's just that GHC isn't smart enough to see that it is
18:30:54 <elliott> specifically, I have this existentially quantified list, and I find a specific element in it, and return the associated value.
18:31:05 <elliott> but this won't type, because I can't prove that the state I return _is_ of the type of the query.
18:31:15 <elliott> so I just unsafeCoerce it. :p
18:31:17 <edwardk> djahandarie: sok, it provides an excuse to go out and get a new lambdakitten
18:31:30 <elliott> at least it's contained
18:31:42 <elliott> -- AIEEE!
18:31:42 <elliott> import Unsafe.Coerce (unsafeCoerce)
18:31:48 <elliott> see, I'm being really unhappy about it
18:31:56 <kulakowski> edwardk: a better, cuter lambdakitten
18:31:57 <djahandarie> kfish, which is exactly what Maybe is. The problem is it's really annoying to discard values without a list comprehension / monads since it isn't a fmap anymore
18:32:11 <edwardk> well, it is okay to do dirty moral unethical things as long as you make a sad face and sound aggrieved.
18:32:39 <djahandarie> I'll just write it very naively and see if I can notice any patterns
18:33:07 <elliott> edwardk: what's more, this is in an actual programmy program!
18:33:10 <elliott> at least it's just one module.
18:33:59 <edwardk> lol i just realized i never exported the type constructor in http://hackage.haskell.org/packages/archive/stable-maps/0.0.1/doc/html/src/System-Mem-StableName-Map.html
18:34:10 <djahandarie> lol
18:34:36 * djahandarie growls at hackage.haskell.org to stop lagging on his connection
18:34:46 <elliott> here's my confession: http://hpaste.org/43765/fingerprints
18:34:50 <elliott> forgive me
18:34:59 <Axman6> you better be crying
18:35:34 <elliott> nah, the rest of it works too beautifully for that
18:35:39 <adnap> whhoa, that's scary
18:35:52 <elliott> the way I see it, if the Haskell type system was powerful enough, I could use dependent types to prove to the compiler that it's okay
18:35:56 <elliott> so this is just a workaround ;)
18:36:01 <elliott> adnap: yeah i can't believe it actually works
18:36:03 <elliott> but it does
18:36:49 <edwardk> bless you my child, fix the lint error, and read ten lambda the ultimates and all is forgiven.
18:37:11 <adnap> can somebody else try install fieldtrip?
18:37:15 <adnap> *installing
18:37:23 <adnap> it just breaks every time for me
18:37:43 <adnap> i need to tell cabal to use an older version of opengl i think
18:38:33 <elliott> edwardk: I did!
18:38:36 <elliott> I fixed it as soon as I saw it.
18:38:56 <elliott> I don't actually feel all that guilty about using unsafeCoerce, might I be a sociopath?
18:39:24 <edwardk> nothing wrong with a bit of sociopathy
18:39:28 <adnap> what does it do?
18:39:59 <adnap> is it like type casting or something?
18:40:27 <elliott> adnap: unsafeCoerce itself?
18:40:29 <adnap> yes
18:40:31 <elliott> unsafeCoerce :: a -> b
18:40:33 <shapr> elliott: What kind of fingerprints? I'm amused to see you pushing roman numeral values onto the state.
18:40:33 <elliott> It's pretty evil.
18:40:37 <adnap> ha ha
18:40:40 <adnap> type casting
18:40:56 <elliott> shapr: Befunge-98 fingerprints. If you know Befunge, then Befunge-98 is just like Befunge, except absolutely insane.
18:40:57 <shapr> > unsafeCoerce 1 'A'
18:40:59 <lambdabot>   Not in scope: `unsafeCoerce'
18:41:26 <c_wraith> that should just segfault
18:41:35 <elliott> shapr: Fingerprints are basically extension modules.
18:41:44 <elliott> (There's enough of them that there's an IRC bot written in Befunge-98.)
18:42:12 <elliott> The thing is that they can keep their own state and you load them dynamically at runtime, so representing this nicely in Haskell is a bit awkward. But I have tamed the beast!
18:42:14 <elliott> Tamed it with unsafeCoerce!
18:42:24 <elliott> "The function unsafeCoerce# allows you to side-step the typechecker entirely. That is, it allows you to coerce any type into any other type. If you use this function, you had better get it right, otherwise segmentation faults await. It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed." <-- see, the GHC manual even validates my use
18:42:24 <elliott> case.
18:42:50 <djahandarie> I'm sure you could somehow 'prove' it in the type system since it sucks it anyways
18:42:51 <adnap> yeah
18:43:16 <adnap> i've never run into a situation like that
18:43:20 <edwardk> elliott: be warned your code no longer ports to compilers other than ghc generally. things like nhc internally change the representation in ways that unsafeCoerce has different semantics
18:43:27 <elliott> adnap: then you're not using enough LANGUAGE pragmas.
18:43:33 <adnap> i
18:43:33 * hackagebot stable-maps 0.0.2 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.2 (EdwardKmett)
18:43:35 <elliott> edwardk: I'm pretty sure it does: the two types are the exact same type.
18:43:37 <adnap> i'm not
18:43:43 <adnap> i don't know all the fancy new stuff
18:43:53 <adnap> well, i recently read about GADT
18:44:03 <elliott> edwardk: the types are literally correct (well, if the interface is used correctly; since it's my code, it will be, and you'd have to try on purpose to break it internally), GHC just can't tell
18:44:04 <adnap> that's about it though
18:44:13 <djahandarie> It would be neat if someone came up with a one liner to just entirely lie to the type system without using unsafeCoerce or anything evil like that
18:44:14 <adnap> i want to know what this universal quantification is about
18:44:15 <elliott> edwardk: so it's just using unsafeCoerce to convince GHC that fp1 is actually fp, which it is
18:44:23 <elliott> adnap: it's actually existential quantification
18:44:27 <edwardk> elliott: *nods* you're injecting something with a key then extracting it with the same key
18:44:28 <adnap> oh
18:44:32 <adnap> well then
18:44:34 <adnap> that
18:44:37 <adnap> lo
18:44:37 <elliott> edwardk: yep
18:44:53 <elliott> edwardk: (if you gave two fingerprints the same fpName, this would break, but I'm planning to use Template Haskell to define fpName automatically anyway)
18:45:01 <adnap> oh yeah
18:45:04 <adnap> and template haskell
18:45:10 <elliott> yes. tools of the dark arts.
18:45:16 <edwardk> elliott: of course at this point you could just use Dynamic and be done with the moral grey area ;)
18:45:24 <edwardk> since that is exactly what typeable is
18:45:24 <adnap> oh no
18:45:31 <adnap> it says compile time metaprogramming
18:45:33 <adnap> that can't be good
18:45:37 <elliott> adnap: it's like Lisp macros, for Haskell.
18:45:44 <elliott> except that Haskell's AST is slightly less clean than Lisp's.
18:45:46 <djahandarie> Except worse
18:45:47 <djahandarie> A lot worse
18:45:48 <elliott> so it gets ... fun!
18:45:48 <djahandarie> lol
18:45:50 <elliott> VERY FUN
18:46:00 <elliott> edwardk: I could, but it seems like a lot to pull in for what's essentially me telling GHC to shut up.
18:46:14 <djahandarie> I've heard that people are trying to make TH better these days though
18:46:22 <edwardk> well, i'm just eyeballing if you could just make fp a subtype of Typeable
18:46:26 <edwardk> er FingerPrint
18:46:41 <elliott> Fingerprint :P
18:46:45 <elliott> edwardk: I could possibly
18:47:00 <elliott> btw is this true:
18:47:01 <elliott> -- a real implementation would use a map of some sort (although I'm
18:47:01 <elliott> -- not sure that's possible; it might require copumpkin's fancy
18:47:01 <elliott> -- dependent map stuff)
18:47:01 <elliott> type FungeState = [FPEntry]
18:47:03 <elliott> I think it might be
18:47:11 <elliott> since I don't think you can do that kind of existential trickery with a Map
18:47:13 <elliott> since the key and value are separated
18:47:23 <elliott> but I know copumpkin made some sort of value-type-depends-on-key-type map recently, so...
18:47:25 <edwardk> clearly you should just use my stable-maps ;)
18:47:36 <absentia> I'll be right here.
18:48:05 <djahandarie> You'll need to submit a new version with the constructor exposed to hackage first, won't you? :P
18:48:11 <elliott> edwardk: haha, do they support that?
18:48:19 <elliott> how many unsafeCoerces/line, it's a measure of code quality
18:49:11 <edwardk> elliott: insert :: StableName a -> f a -> Map f -> Map f — the structure of each slot depends on the type of the stablename
18:49:23 <elliott> edwardk: I'm scared.
18:50:39 <elliott> copumpkin!
18:50:41 <elliott> what a good time!
18:50:44 <copumpkin> hhullo
18:50:44 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
18:50:47 <elliott> copumpkin: that dependent map thing you made.
18:50:55 <elliott> copumpkin: was it that the type of the value could depend on the key?
18:50:56 <copumpkin> augur: yes
18:51:03 <elliott> augur: no
18:51:05 <copumpkin> elliott: yeah, on the type of the key
18:51:17 <Gracenotes> sounds like magic
18:51:18 <elliott> copumpkin: yesss
18:51:23 <elliott> copumpkin: was it, you know, relatively efficient?
18:51:32 <copumpkin> it just used Data.Map behind the scenes
18:51:45 <Gracenotes> and no typeable? :o
18:51:48 <augur> copumpkin: :D
18:51:55 <Gracenotes> or sekrit typeable
18:52:04 <elliott> copumpkin: got a paste?
18:52:07 <copumpkin> Gracenotes: no secret typeable, but Any and unsafeCoerce behind the scenes
18:52:14 <copumpkin> elliott: hmm, should be up there somewhere
18:52:21 <Gracenotes> CLOSE ENOUGH :o
18:52:28 <copumpkin> http://hpaste.org/42845/fancy_maps
18:52:38 <djahandarie> I'm sure he wrote it in Agda first though so that means it's okay!
18:52:44 <elliott> copumpkin: I've just perpetrated the only elegant hack to ever use unsafeCoerce, myself, and I'm just looking to replace FungeState with a map: http://hpaste.org/43765/fingerprints
18:52:48 <djahandarie> That is, if you trust Agda
18:52:55 <elliott> WITH OUR HACKS COMBINED I WILL BE UNSTOPPABLE
18:53:01 <copumpkin> djahandarie: I didn't actually :)
18:53:14 <Gracenotes> oh wow.
18:53:22 <edwardk> shh.. just smile and nod, and appeal to the authority of type systems beyond mortal ken
18:53:30 <elliott> copumpkin: hmm, I don't think you need all that fancy wrapping stuff, if you used more unsafeCoerce
18:53:41 <copumpkin> elliott I do use it
18:53:41 <elliott> copumpkin: actually ... could you do existentials with that?
18:53:52 <elliott> i.e.: data FPEntry = forall fp. (Fingerprint fp) => FPEntry fp (FPGlobalState fp)
18:53:52 <elliott> type FungeState = [FPEntry]
18:53:52 <copumpkin> elliott: the point is to be typesafe :P
18:53:58 <elliott> I instead want FungeState to be a map
18:54:03 <elliott> from fp to FPGlobalState fp
18:54:07 <elliott> except that fp can't be Eq... eurgh
18:54:10 <elliott> well it can
18:54:14 <elliott> but that doesn't really help
18:54:17 <elliott> but anyway, is that possible? :p
18:54:25 <copumpkin> how do you plan on looking it up?
18:54:35 <elliott> copumpkin: by feeding a value
18:54:39 <elliott> copumpkin: fp is (Fingerprint fp) =>
18:54:56 <copumpkin> well, you still can't have dependent types, unless you use a GADT as the key
18:55:05 <elliott> it isn't dependent
18:55:39 <copumpkin> hmm dunno
18:55:47 * copumpkin is eating
18:55:51 <djahandarie> lol
18:56:00 <elliott> cp fptest.hs fptest.hs.lists
18:56:05 <elliott> i'll just hack it up MYSELF
18:56:30 * copumpkin eats popeyes biscuits
18:56:47 <elliott> hmm, is there a non-ghc portable way to get Any? :-D
18:56:51 <djahandarie> It feels really busy in here for some reason tonight
18:56:53 <elliott> as in, something other than GHC.Base
18:57:12 <copumpkin> elliott: no
18:57:20 <elliott> oh well
18:57:24 <elliott> who cares about other compilers :)
18:59:45 <elliott> are ImpredicativeTypes gone in GHC 7?
19:00:06 <dolio> No.
19:00:35 <elliott> yay
19:00:37 <elliott>     No instance for (Ord Any)
19:00:37 <elliott>       arising from a use of `Map.!'
19:00:38 <elliott> :)
19:00:42 <copumpkin> I thought 7.0.1 didn't have them
19:00:49 <elliott> wonder how to fix that, haha
19:00:50 <dolio> No, it has them.
19:00:55 <copumpkin> oh ok
19:03:24 <monochrom> there is enough care about other compilers. don't say "who cares about other compilers". however "I want to focus on ghc" is fine.
19:04:38 <elliott> hey, i know people who used _hugs_ until recently
19:04:47 <elliott> i'm all about the other implementations, except when they can't offer me Any
19:04:55 <monochrom> there is also jhc
19:11:54 <lispy> UHC is the new upstart
19:11:59 <lispy> I'm hearing good things about it
19:12:13 <lispy> I'm sticking with GHC for the foreseeable future though
19:12:20 <dolio> Both JHC and UHC have existentials, I think. UHC's, at least, is incompatible with GHC's.
19:12:33 <lispy> dolio: syntatically or semantically?
19:12:38 <dolio> Syntactically.
19:12:38 * copumpkin shamelessly promotes ##smt (guess what it's for)
19:12:51 <dolio> UHC has an exists keyword.
19:12:59 <copumpkin> I think JHC does too doesn't it?
19:13:06 <dolio> I don't know.
19:14:13 <dolio> So where in GHC you'd write 'data Any = forall a. Any a' in UHC you'd write 'data Any = Any (exists a. a)'. Or maybe newtype, who knows?
19:15:27 <elliott> Cannot match a monotype with [blah]
19:15:33 <elliott> hmm, is that what happens when you use ImpredicativeTypes?
19:16:05 <dolio> Type checking higher-rank types got a little iffy in 7.0.1.
19:16:13 <dolio> There are still kinks to work out.
19:16:35 <dolio> If that's what you're talking about.
19:16:40 <elliott> dolio: No, this is 6.12.3.
19:16:48 <elliott> Might be one of the other ten language extensions I have.
19:17:09 <elliott> GHC infers this function as push :: (MonadIO m, Show a) => a -> m (), but doesn't let me type it as push :: Value -> Shiro ():
19:17:13 <elliott> push x = liftIO $ putStrLn ("### Pushed " ++ show x)
19:17:18 <elliott>     Cannot match a monotype with `StateT FungeState IO'
19:17:19 <elliott>       Expected type: Shiro ()
19:17:19 <elliott>       Inferred type: m ()
19:17:23 <elliott> So it's... telling me I have to be polymorphic?
19:18:39 <dolio> What's Value?
19:19:04 <dolio> Not that that should matter.
19:19:10 <FunctorSalad> why does cabal installing my program with --enable-executable-prof double the runtime when running without profiling? (and is this expected or am I doing something wrong)
19:19:34 <lispy> FunctorSalad: it's expected
19:19:45 <dolio> Building in profiling mode still adds all kind of stuff for when profiling happens.
19:19:48 <lispy> FunctorSalad: GHC instruments all your function calls
19:20:12 <FunctorSalad> ok :)
19:20:22 <djahandarie> Holy smokes it's FunctorSalad!
19:20:33 <elliott> <dolio> What's Value?
19:20:34 <elliott> Int.
19:20:47 <FunctorSalad> hello djahandarie :)
19:21:02 <djahandarie> Where've you been for the past few months? :P
19:21:04 <dolio> elliott: Okay. I don't really understand why it's giving that error, then.
19:21:13 <lispy> If Functors make salad, what do we make with Monads?
19:21:28 <dolio> I'd need more context.
19:21:45 <int80_h> Mallards, Monads make Mallards. DOn't they cover that freshman year anymore?
19:21:59 <elliott> dolio: I'll see if I can work my way out of this first. :)
19:23:01 <int80_h> I have a list I want to map over, but am only interested in the final result. Is there a better way than generating a list, and just keeping the final value in it?
19:23:36 <elliott> int80_h: f (last xs)?
19:23:56 <lispy> int80_h: how is the list generated?
19:24:02 <int80_h> elliott: doesn't that just do what I said I was trying not to do?
19:24:11 <elliott> int80_h: then i don't understand
19:24:16 <elliott> ah, i see
19:24:18 <int80_h> lispy: with mapM
19:24:20 <lispy> int80_h: well, it will only keep the last element but it will traverse the spine of the list to that element
19:24:56 <lispy> int80_h: can you modify the generator to only generate the last element?
19:25:04 <int80_h> lispy, you are saying that about mapM or what elliott suggested?
19:25:27 <FunctorSalad> guess I confused it with --enable-library-prof performance-wise, which should have no impact on non-profiling operation because a separate library is compiled...
19:25:56 <dolio> Yes, that only doubles your compile time. :)
19:26:47 <djahandarie> Something other than compile time exists?
19:26:53 <lispy> did int80_h just leave?
19:27:02 <lispy> hard to help if you're gone!
19:27:18 <djahandarie> With the message "changing server" so maybe he'll be back
19:28:14 <int80_h> lispy: sorry somethign wierd was happening
19:28:21 <int80_h> I will re-prepare my response
19:29:23 <lispy> int80_h: If you generate a list and then 'map f xs' then when you ask for 'last (map f xs)' the last function will do a traversal of the list.
19:29:37 <int80_h> lispy: I'm simulating an open session on a server. The function that does so returns whatever cookies were generated in the header during the GET. But I only need the cookies from the last GET. But the intermediate GETS are there to assure the server is in the right state
19:29:38 <lispy> int80_h: it won't cause the elements of the list to be evaluated, only the spine of the list
19:30:12 <lispy> int80_h: So if you really only want the last one, you could possibly change your generator so that you don't map f over a list to begin with
19:30:41 <int80_h> lispy: Well, I need those intermediate steps to make sure the server is in the right state.
19:30:50 <lispy> Even if you don't do that, then last is order O(n) where n is the length of the list.  The upside is that in Haskell you don't also pay the cost of making the elements of the list
19:31:07 <lispy> int80_h: Then I don't see anything better for you here
19:31:31 <int80_h> lispy: okay, I wanted to make sure there wasn't a better way before I do this.
19:31:44 <elliott> edwardk: I admit defeat; Dynamic it is
19:32:08 <copumpkin> elliott: fail
19:32:29 <djahandarie> Only noobs use dynamic
19:32:37 <elliott> unsafeCoerce is like XML and violence, if it doesn't work you're not using enough of it ...
19:32:52 <elliott> preferably, just unsafeCoerce every single expression
19:33:38 <Gracenotes> but but.. it's *reflection*. wasn't reflection the biggest craze of.. .. the 90s.. or something?
19:48:58 <elliott> edwardk: works out much better with Data.Dynamic too...
19:48:58 <elliott> http://hpaste.org/43766/fingerprints_2 :p
19:49:11 <args0> TTimo: hi! Hope you are well, just wanted to say hi :)
19:49:38 <edwardk> kinda figured
19:56:51 * hackagebot hmatrix-nipals 0.1 - NIPALS method for Principal Components Analysis on large data-sets.  http://hackage.haskell.org/package/hmatrix-nipals-0.1 (AlanFalloon)
19:56:57 <elliott> hmmmm...
19:57:26 * elliott has [(FP, Dynamic)] where FP is an existential over ((Fingerprint fp) => fp) and the Dynamic always contains (FPGlobalState fp) for the corresponding fp
19:57:33 <edwardk> i really can't read that package name without thinking its cold in here.
19:57:34 <elliott> furthermore, (FPGlobalState fp) is guaranteed to have a Show instance
19:57:42 <elliott> is there any way to show all the values?
19:58:06 <elliott> or even just one specific value, given the key?
19:58:13 <elliott> i.e. show one (FP, Dynamic)
19:58:15 <elliott> like that
20:00:26 <int80_h> would a let/in construct be considered a haskell expression?
20:00:45 <dolio> Yes.
20:01:07 <Gracenotes> > let in "the dog"
20:01:08 <lambdabot>   "the dog"
20:01:39 <int80_h> so if I get a compiler error saying "last statement in a do construct must be a statement" and the last construct is a let/in, woul that suggest a spacing error?
20:01:52 <Cale> yeah, probably
20:02:03 <Gracenotes> int80_h: are you doing x <- let .. in ?
20:02:04 <Cale> Paste your code on hpaste and we can probably spot it
20:02:24 <int80_h> Gracenotes: no
20:02:25 <Gracenotes> last line shouldn't have <- if that's the thing
20:02:27 <Gracenotes> hm
20:02:32 <int80_h> I can paste the function
20:02:34 <Gracenotes> yeah, pasty
20:03:38 <int80_h> http://hpaste.org/43767/let_is_an_expression_dammit
20:04:21 <Gracenotes> hm.. let in a do statement is not the same as let in an expression
20:05:04 <Cale> the 'do' is extraneous there anyway
20:05:13 <Cale> but...
20:05:14 <drbean> What's the purpose of the dynamic types of Data.Dynamic. and why would a newbie want to use them? When you want the program to create new types?
20:05:15 <Gracenotes> you can get rid of the "in" or get rid of the "do" and it would work fine. I think it assumes the lets are assignments and won't consider the let/in interpretation
20:05:22 <rwbarton> that parses as two commands in the do block, a let-command, and an "in"-command (which doesn't exist)
20:05:24 <Gracenotes> some sort of shift-reduce thingy
20:05:34 <Cale> the problem is that the 'in' is on a new line of the do-block
20:05:48 <int80_h> hmm, okay 
20:05:57 <c_wraith> drbean: No, you'd use Data.Dynamic when you're passing around values in a way that you can't prove to the type system that you're preserving the type correctly.
20:06:00 <rwbarton> you can also indent the 'in' line some
20:06:01 <Cale> If you indent the in by one more space, the problem should go away
20:06:15 <Gracenotes> I'm not sure why the monadic context is important if it's a string..
20:06:59 <c_wraith> drbean: In a recent case, I used Data.Dynamic when I was storing 3 different types in a single structure, in a way that the path to the item uniquely determined its type, but the structure wasn't designed for that.
20:07:11 <int80_h> Gracenotes, I'm taking a function that had a monadic context and removing it. I hadn't done away with the do, as I thought it needed to be there when you weren't doing pattern matching
20:07:49 <c_wraith> drbean: Data.Dynamic allowed safely casting the stored values back to their original type, in a way where any programming error would become clear when the cast was attempted.
20:08:18 <Gracenotes> int80_h: hm? like, you can't have id x = x, it has to be id x = do x? o.o
20:09:24 <int80_h> Gracenotes: my way of learning comes from C. I picked up on language patterns and could use them long before I understood what particular language constructs meant. That however, seems of little value in the Haskell world.
20:10:02 <int80_h> I mean, I can get only so far with pattern regocniztion skills
20:10:05 <int80_h> eep
20:10:30 <Gracenotes> yeah, a lot of C is faking it until.. well.. it compiles and doesn't segfault
20:12:44 <Gracenotes> whether do is useful or not depends a bit on the return type, I guess. if it's an IO String or application-specific monad, it might be. if it's an Int, prolly not. *shruggeh*
20:13:07 <jsvc> What is a singleton type?
20:14:10 <Gracenotes> like.. unit? http://en.wikipedia.org/wiki/Unit_type
20:26:24 <revenantphx> Well, I thought of something useful to do.
20:26:38 <revenantphx> There's that one LLVM tutorial (how to write a language that compiles to llvm)
20:26:43 <revenantphx> the Kaleidoscope one.
20:26:50 <revenantphx> And there are C++ and OCaml implementations.
20:26:56 <revenantphx> Maybe I should try it in haskell instead :).
20:27:10 <drhodes> revenantphx: what language do they use?
20:27:11 <dolio> I'm not sure where you're seeing "singleton type," but sometimes it's used to mean an indexed family of types where each member of the family has one value.
20:27:45 <revenantphx> drhodes: note, C++ and OCaml
20:27:47 <dolio> Like Nat n, indexed by type-level naturals. So Zero :: Nat Z, Suc Zero :: Nat (S Z), etc.
20:27:51 <revenantphx> (tutorial is available in both)
20:28:13 <drhodes> revenantphx: they implement a c++ and OCaml compilers as a tutorial?
20:28:20 <revenantphx> oh, no lol
20:28:28 <drhodes> didn't think so :)
20:28:33 <revenantphx> some little demo language they call Kaleidoscope
20:28:45 <revenantphx> it's basically super basic addition ,substraction, functions, and all variables are double.
20:28:47 <avpx> Hey everyone. I've encountered something with the Haskell type system that I can't seem to work out, and I'd appreciate some help. Here is the code: http://pastebin.com/WspjyZNx. What I'm wondering is, in particular, if it is possible to indicate a type explicitly for line 33. When I try "Set.Set (WeightedEntry (Tree a))" for its type, I get the error here: http://pastebin.com/k5witzBv
20:29:10 <drhodes> revenantphx: that sounds like a great resource because I'm doing something similar
20:29:13 <avpx> GHC infers the type by itself, but I'd like to explicitly write that type.
20:29:17 <drhodes> but for a language called a++
20:29:32 <drhodes> it's a minimal language for lambda calculus
20:29:36 <revenantphx> I see :\
20:29:54 <drhodes> the grammar is 4 productions
20:29:56 <drhodes> 5
20:30:07 <revenantphx> one minute.
20:30:17 <drhodes> http://www.lambda-bound.com/book/lambdacalc/node42.html
20:30:53 <drhodes> but that's exactly what I'm looking for, I'm really glad you brought that up, because going from internal representation to llvm is next.
20:31:01 * hackagebot intel-aes 0.1.1 - Hardware accelerated AES encryption and RNG.  http://hackage.haskell.org/package/intel-aes-0.1.1 (RyanNewton)
20:31:23 <revenantphx> http://llvm.org/docs/tutorial/
20:33:34 <revenantphx> gogogo brew.
20:34:38 <stoltene2> avpx: Looks like Set (WeightedEntry Int a)
20:35:42 <revenantphx> the idea of parsers and lexers kind of fall apart with Parsec and haskell...
20:35:45 <revenantphx> well, not quite but
20:35:49 <revenantphx> it's just so EASY to implement the AST XD
20:36:02 <revenantphx> data Token = ...
20:36:06 <avpx> stoltene2: Eh? The type is WeightedEntry a
20:36:14 <avpx> stoltene2: WeightedEntry Int a is a constructor
20:36:38 <revenantphx> Actually, I can see Haskell as being really nice for writing compilers in.
20:36:45 <avpx> I think the issue is that the compiler doesn't recognize the two a's as being the same
20:36:58 <revenantphx> Parsec is immensely elegant and very clear, and ADT's let you model the AST and such w/o any fuss.
20:37:32 <avpx> And I can't think of a way to indicate that the types are the same
20:37:46 <avpx> The inference works just fine, but I've never encountered a situation where I couldn't explicitly give types
20:37:56 <Gracenotes> two as being the same? ScopedTypeVariables to the rescue?
20:38:13 <avpx> Gracenotes: Ah, now that's the idea I'm looking for
20:39:00 <ManateeLazyCat> Hi all. :)
20:39:13 <Gracenotes> very very useful for ST. and less extreme polymorphism too. (well, maybe extreme is a bit of an exaggeration given what else haskell can do)
20:39:56 <avpx> Gracenotes: Do you see a way to structure that that does not require a language extension?
20:39:59 <stoltene2> avpx: Sorry drop the Int
20:40:46 <avpx> Gracenotes: That is to say, do you see a way to restructure that code so that I can avoid this issue?
20:41:03 * hackagebot intel-aes 0.1.2 - Hardware accelerated AES encryption and RNG.  http://hackage.haskell.org/package/intel-aes-0.1.2 (RyanNewton)
20:44:34 <revenantphx> Excuse me, could someone in here help me with the haskell llvm bindings?
20:44:41 <revenantphx> On OS X it cannot find the C bindings.
20:45:08 <Gracenotes> avpx: well, it's not possible without the extension really
20:45:26 <avpx> Gracenotes: That's fine. Thanks for the pointer! I couldn't find exactly what language extension I was looking for
20:45:31 <Gracenotes> if you want the type signature
20:45:51 <Gracenotes> avpx: http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables ? it's been in GHC for a while now
20:46:04 <revenantphx> Ello?
20:48:42 <Gracenotes> revenantphx: does /usr/include/llvm-c or /usr/local/include/llvm-c exist.. or something?
20:49:04 <revenantphx> the latter.
20:49:08 <drbean> I keep forgetting a list can't end with ','. Editing, I think I will have to prepend additions, rather than append.
20:49:42 <revenantphx> as well as a much more populated /usr/local/include/llvm folder.
20:49:59 <rwbarton> one style is to put each comma on the same line as the next element of the list, with the final ] on its own line
20:50:00 <Gracenotes> revenantphx: hm.. looking at cabal options.. maybe need --extra-include-dirs=?
20:50:33 <revenantphx> well if it fails at compile time, it'll likely fail at runtime.
20:50:52 <revenantphx> (since it won't be able to find them where it expects)
20:51:08 <Gracenotes> runtime shared library resolution is usually much nicer than compile-time shared library resolution
20:51:26 <revenantphx> hm, someone did it here
20:51:26 <revenantphx> http://fp.okeefecreations.com/2010/05/cabal-installing-haskell-llvm-module-on.html
20:51:46 <revenantphx> But I have LLVM
20:51:53 <revenantphx> I even have the complete suite through brew.
20:52:00 <revenantphx> (in addition to the minimal default installed stuff)
20:52:19 <Gracenotes> well does including the dirs work?
20:52:55 <revenantphx> that's not the right command
20:52:57 <revenantphx> looking for the right one
20:53:10 <revenantphx> my brew installation is in /usr/local/Cellar/llvm/2.8/include/llvm
20:53:13 <revenantphx> and is up to date.
20:53:23 <Gracenotes> I have not much idea what brew is
20:53:29 <revenantphx> It's a package manager for OS X
20:53:33 <revenantphx> on top of ruby and git
20:53:38 <Gracenotes> you have shared libraries on mac, right?
20:53:50 <revenantphx> Define shared library?
20:53:57 <mee> brew is so misguided :(
20:54:08 <Gracenotes> things ending in .so in /usr/lib/
20:54:14 <revenantphx> At the least, brew doesn't fuck everything up like port
20:54:28 <revenantphx> they're .dylib on os x tough Gracenotes 
20:54:37 <revenantphx> You just mean dynamically linked libs though?
20:54:46 <Gracenotes> that's what they are yes
20:54:56 <revenantphx> They exist in dylib form, and embedded in frameworks in /System(/Library)/Frameworks
20:55:07 <revenantphx> (both are mach-o dylibs tho)
20:55:14 <Gracenotes> but .so's are.. not a bad system, when you consider hit
20:55:14 <mee> revenantphx: I think you have it backwards, macports doesn't use your system libs -- it's totally separate by design
20:55:18 <Gracenotes> *it
20:55:47 <revenantphx> mee: brew stays segregated from the preinstalled stuff, which is annoyingly fragile.
20:56:18 <revenantphx> Everything is installed in /usr/local/Cellar/ and only "replaces" system installed stuff if it precedes it in your PATH.
20:56:35 <revenantphx> Gracenotes: okay ,what was the command to add an include path?
20:56:49 <revenantphx> --extra-include-dirs doesn't seem to ork
20:57:14 <Gracenotes> if the files are in /foo/blah/llvm-c, set --extra-include-dirs=/foo/blah
20:57:32 <Gracenotes> because they seem to be imported as <llvm-c/baz.h>
20:57:38 <revenantphx> yep, using /usr/local/Cellar/llvm/2.8/include/
20:57:43 <revenantphx> (inside are llvm-c and llvm)
20:57:48 <dankna> so
20:57:59 <revenantphx> doesn't work in the end.
20:58:03 <revenantphx> could not find LLVM C bindings.
20:58:06 <dankna> I see by inspection of the GHC source that it includes libffi but doesn't use it for much of anything
20:58:08 <dankna> which is weird to me
20:58:11 <Gracenotes> hummmm. what's the error in particular, if any
20:58:18 <dankna> (ghci does, but not compiled code)
20:58:23 <revenantphx> configure: error: could not find LLVM C bindings
20:58:23 <revenantphx> cabal: Error: some packages failed to install:
20:58:23 <revenantphx> llvm-0.9.0.1 failed during the configure step. The exception was:
20:58:24 <revenantphx> ExitFailure 1
20:58:35 <dankna> I'm actually wondering if anyone knows why it's included at all.  is it purely for ghci?
20:58:35 <revenantphx> I'm going to look at the package itself. It might be looking in a hardcoded location.
20:58:53 <revenantphx> libffi is often used as a convenient way to mprotect pages.
20:58:59 <revenantphx> Never really seen it used otherwise.
20:59:01 <dankna> hm
20:59:02 <dankna> okay
20:59:06 <TimeCat> So I might just be doing something wrong but I think capri is checking versions incorrectly: http://hpaste.org/43769/version_checking anyone mind taking a look?
20:59:10 <dankna> it er, doesn't really do that I don't think, does it?
20:59:11 <revenantphx> I don't know why libffi would be used with mprotect
20:59:15 <revenantphx> No, it doesnt do it,
20:59:23 <revenantphx> but it's used for say, dynamically creating/copying functions.
20:59:31 <revenantphx> At least, I've heard of it used in that way.
20:59:37 <dankna> hm
20:59:45 <dankna> that's not really what it does either :)
20:59:56 <dankna> oh come to think of it it is used one other place that I was able to identify
20:59:56 <revenantphx> I know :P
20:59:58 <dankna> heh okie
21:00:05 <revenantphx> The uses i've seen are cheating.
21:00:10 <dankna> which is in the trampoline generator for systems that don't have a native one written
21:00:12 <revenantphx> generating function pointers and such.
21:01:22 <Gracenotes> it's in a configure script :/
21:01:33 <dankna> what is?
21:02:04 <dankna> oh, TimeCat's thing
21:02:17 <Gracenotes> with Autoconf O_O
21:03:28 <revenantphx> okay this is just weird
21:03:46 <revenantphx> I have symlinks in usr/local/include which is specified as the default dir in the configure script
21:06:04 <Gracenotes> revenantphx: and llvm-c/Core.h exists there too?
21:06:11 <revenantphx> Yep
21:06:20 <revenantphx> I cleared out the brew copy just to try with only sys version
21:06:23 <revenantphx> well, the version from xcode
21:07:07 <revenantphx> oh hm
21:07:16 <revenantphx> on second glance, the system one doesn't seem to expose the headers anywhere
21:07:16 <revenantphx> wtf
21:07:30 <revenantphx> it only exposes the gcc/g++ front ends
21:07:54 <revenantphx> Well, reinstalling again then.
21:08:14 <Gracenotes> strangeness
21:08:30 <revenantphx> brew symlinks everything nicely though.
21:08:46 <revenantphx> in /usr/local/include and /usr/include/
21:08:55 <revenantphx> so it *should* be able to find the headers >_>
21:09:30 <revenantphx> Actually, brew has one REALLY annoying facet.
21:09:49 <revenantphx> It almost exclusively installs packages with x86_64 only.
21:09:52 <revenantphx> >_>
21:10:05 <revenantphx> But that wouldn't affect the headers. That issue would/could/should manifest at compile time.
21:10:37 <Gracenotes> the configure script. it makes no sense. be gone hence, autoconf demon
21:11:32 <revenantphx> lolyep
21:16:45 <TimeCat> any one have an idea?
21:17:30 <revenantphx> Gracenotes: okay I reinstalled and the headers exist
21:17:42 <revenantphx> -v isn't showing where cabal is looking though
21:17:47 <revenantphx> seems the issue is the configure script.
21:18:03 <revenantphx> It dun get it.
21:19:32 <revenantphx> ill solve it tomorrow
21:19:33 <revenantphx> sleepy now
21:22:35 <taotree> So... I heard the statement "You can't pattern match on types" and it made me think.... pattern matching is on runtime information. Is that correct? Constructors are available at runtime, but types are not.
21:23:10 <Jesin> computations are containers!
21:23:16 <Jesin> I understand monads now :>
21:23:22 * Jesin is enlightened
21:23:24 <Jesin> :p
21:23:39 <ivanm> taotree: I'm not sure if that's right...
21:24:01 <ivanm> the core _equivalent_ of constructors would be available...
21:24:51 <taotree> ivanm, right, I think that's what I meant. The information necessary to pattern match on constructors is available. Whereas the information about types is not so you cannot pattern match on them.
21:25:11 <ivanm> well, how/why would you "pattern match" on types?
21:25:37 <taotree> ivanm, you can't, see? :) sorry... I'm just gradually working on understanding things...
21:25:52 <monochrom> because dynamic runtime typing is the mainstream prejudice
21:26:04 <ivanm> monochrom: here you mean?
21:26:14 <monochrom> not here
21:26:44 <monochrom> dynamic runtime typing as the mainstream prejudice is the reason why mainstream people want to case-analyse over types
21:26:48 <ivanm> ... isn't dynamic runtime typing what python, etc. do?
21:27:07 <monochrom> yes
21:27:56 <ivanm> gah, I misinterpreted what you said
21:27:59 * ivanm needs sleep...
21:28:28 <taotree> My situation, I have a data structure: IceCream { f1, f2, f3 } but that comes in two fundamentally different flavors, Chocolate and Vanilla. I'd like to put that at the type level to enforce that noone tries to call a function that expects Chocolate with Vanilla
21:28:36 <Jesin> someone needs to put semigroups in the standard library, as a superclass of monoid
21:29:13 <Jesin> umm
21:29:29 <ivanm> taotree: sounds like IceCream is a class and the flavours are individual types then
21:29:31 <Gracenotes> using typeclasses to represent algebraic structures in haskell.. harder than it looks... apparently
21:29:43 <Jesin> maybe you should make IceCream a typeclass or type constructor?
21:29:52 <Jesin> or
21:29:54 <Jesin> a type family!
21:30:10 * Jesin does not understand type families yet and has not bothered with them
21:30:11 <taotree> ok
21:30:12 <Jesin> but
21:30:21 <ivanm> Jesin: don't think they apply here...
21:30:26 <Jesin> http://haskell.org/haskellwiki/Type_families
21:30:28 <Jesin> k.
21:30:30 <djahandarie> Gracenotes, mainly because algebraic structures are primarily laws, and it's pretty hard to represent any of those laws in the type system :)
21:30:48 <taotree> ok, so if I think of it as: a type parameter is like a parameter to a function that returns a type
21:30:52 <Gracenotes> detailed attempts of doing so usually run into very non-DAG structures
21:31:03 <Gracenotes> the "with chocolate" seems doable. "without vanilla".. well..
21:31:04 <taotree> which is quite different than a type class...
21:32:21 <ivanm> Gracenotes: yeah
21:32:46 <ivanm> taotree: can you give a more detailed example of what you want to do and why you're having trouble implementing it?
21:36:00 <taotree> maybe if I can find my way back to it...  I'll dive back into it and see if I can find where I had a problem again, since it's eluding me now
21:36:56 <Jesin> so, the computations/containers analogies are great for monads
21:37:08 <Jesin> anyone have a similar thing for Arrows?
21:37:21 <Jesin> ...
21:37:48 <Jesin> it's 3 minutes until 1 AM, I don't have time to understand Arrows tonight
21:37:51 <Jesin> oops
21:37:53 <Jesin> :p
21:42:27 <o^_^o> I am trying to write a cgi program using haskell
21:43:24 <o^_^o> I really do not understand the haskell I/O
21:43:31 <o^_^o> why can't I do something like
21:43:38 <o^_^o> blah <- getInput "bleh"
21:44:15 <o^_^o> if (blah == (Just "blarg")) then blih <- getInput "blurg" else ...
21:44:42 <Jesin> umm
21:44:42 <o^_^o> it says parse at the second getInput
21:44:48 <o^_^o> parse error
21:44:59 <Jesin> try if (blah == "blarg")
21:45:07 <Jesin> without the Just
21:45:11 <o^_^o> ok
21:45:18 <dankna> the "then" creates a new lexical scope
21:45:24 <c_wraith> you can only use <- syntax inside of do blocks.  The cases of an "if" statement are not do blocks
21:45:26 <o^_^o> nope
21:45:39 <dankna> you cannot define blih in there and have it be usable outside
21:45:49 <dankna> if you want blih to be defined, you have to do something like
21:46:10 <dankna> blih <- if (blah == Just "blarg")) then getInput "blurg" else ...
21:46:28 <dankna> of course, in the event that the test fails, the result of the else will be the new value of blih
21:46:55 <dankna> take the time to understand what c_wraith said, too
21:46:57 <o^_^o> ok...
21:48:03 <Jesin> this would be easier if we had "if True x _ = x; if _ _ y = y"
21:48:06 <Jesin> but, whatever
21:48:19 <Jesin> I'll forgive that if we just put join inside the Monad class
21:48:22 <Jesin> :p
21:48:44 <dankna> I'd rather take fail out of Monad than put join in :)
21:48:54 <Jesin> nobody cares about fail
21:49:06 <Jesin> it's even given a default implementation
21:49:11 <Jesin> and nobody ever uses it
21:49:18 <dankna> :t join
21:49:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:49:31 <Jesin> fail is an embarrassment, perhaps, but it's not actively inconvenient
21:49:52 <o^_^o> I can't seem to figure out how to do anything useful with haskell
21:49:56 <c_wraith> I don't know.  people try to use fail
21:49:59 <o^_^o> even though I've finished half the book
21:50:09 <c_wraith> Given that people try to use it, I think fail is actively harmful
21:50:10 <Jesin> o^_^o, what useful tasks have you thought of?
21:50:31 <o^_^o> Jesin, ok my boss wants me to prototype a web based app
21:50:41 <djahandarie> Jesin, Arrows are for function-like things. (Functions are included in function-like of course.)
21:51:02 <o^_^o> my team has decided to use CGI form for it and I've been given the task to prototype this
21:51:09 <djahandarie> Most common use of them you'll see in here is code golf ;)
21:51:26 <Jesin> then you should probably use a language you already know, that works well with CGI
21:51:34 <o^_^o> I thought I would use haskell to prototype this
21:51:39 <Jesin> why?
21:52:08 <Jesin> if you're so focused on doing something "useful" that your boss told you to do
21:52:46 <Jesin> then use a language that's good for that job, and come back and learn haskell when you have time for interesting new concepts
21:52:48 <Jesin> :p
21:53:46 <dankna> I largely agree with what Jesin is saying.  That said, I use Haskell for CGI (well, FastCGI) stuff, but I know the language well enough that I can do that.  It's not really a for-beginners task in Haskell.
21:53:55 <Jesin> ^ that
21:54:04 <djahandarie> Jesin, if you haven't read typeclassopedia check it out btw
21:54:11 <djahandarie> I think it touches on Arrows in there
21:54:35 <djahandarie> Someone really ought to port that to HTML/wiki form
21:54:54 <Jesin> a guy in a computer systems lab I'm in is using Haskell to fetch and parse data from large databases, because lazy evaluation is very convenient for that
21:55:32 <ulfdoz> In my opinion prototypes are a fine opportunity to play with new stuff including programming languages. If you don't find a place within your job will often find no place at all for doing it.
21:55:58 <Jesin> ah.
21:56:00 <Jesin> hmm
21:56:05 <djahandarie> As long as it doesn't need to be done well by a certain date.
21:56:11 <Jesin> ^ that
21:56:14 <Jesin> :p
21:56:25 <dankna> ulfdoz: mm, if that holds for your job you may have to consider whether your job or your freedom to work on what you like is more important.
21:56:26 <shapr> djahandarie: Not that established practices can guarantee that either.
21:56:29 <djahandarie> Because then you'll get stressed, and come to hate the language more than anything else. :)
21:57:13 <dankna> personally I /always/ have found time for my recreational coding projects no matter what else was going on in my life, so I can't really understand the viewpoint that paying work is the only way to get a chance to do something
21:57:16 <djahandarie> shapr, yes, but randomly doing stuff basically guarantees the opposite ;)
21:57:33 <o^_^o> I have a deadline, but I can do it in python if haskell doesn't work and it is small enough that it will take me a very short time in python, which is why I am trying it with haskell...
21:57:41 <djahandarie> dankna, I agree with that
21:57:41 <djahandarie> I'd be stuck doing PHP for life if I didn't do stuff on my own anyways
21:57:42 <shapr> djahandarie: Eh, I've had great success using 'new' tech to accomplish business goals.
21:57:44 <ulfdoz> dankna: My job is actually more important. However, as long as both works for me, I see no problem.
21:57:50 <o^_^o> if I don't do things like this in haskell, I never get a chance to learn it 
21:57:53 <dankna> djahandarie, yeah, makes sense
21:58:11 <dankna> ulfdoz, yeah, that's fair.  I'm just saying it's a decision that you need to make for yourself.
21:58:13 <djahandarie> o^_^o, if you have a fallback plan, go for it
21:58:19 <shapr> Yah, fallback plans are good.
21:58:36 <o^_^o> yes, but how do I do 2 CGI web pages :p in haskell then
21:58:40 <djahandarie> Just don't get too caught up then realize you need to crank something out in 2 hours and get screwed
21:58:46 <djahandarie> o^_^o, by learning the whole language first.
21:58:50 <djahandarie> It isn't a beginners task
21:58:50 <o^_^o> djahandarie, got it
21:59:05 <djahandarie> Do you have a guide?
21:59:06 <o^_^o> djahandarie, ok
21:59:17 <o^_^o> yes I have the real world haskell book
21:59:33 <djahandarie> You should take a look at http://learnyouahaskell.com too
21:59:35 <ulfdoz> dankna: The only thing, which is sometimes hard to argument: I want the right to throw away prototypes anytime. However, in practice the problem is not that big, you learned enough from it, that you can rewrite the functionally faster and nicer.
21:59:37 <Jesin> yeah... CGI sounds like it's really IO and state intensive
21:59:54 <djahandarie> Learn You A Haskell (LYAH) works more on fundementals
22:00:04 <djahandarie> RWH then shows you neat stuff you can do
22:00:13 <dankna> ulfdoz, yes, indeed.  if it's small enough to build a prototype of it's small enough to build two prototypes of :)
22:00:24 <c_wraith> hmm.  is there an Exp pretty-printer in TH that prints to valid haskell code?
22:00:36 <djahandarie> Some balance of both is usually what most people need
22:00:44 <dankna> c_wraith: I would assume not, because it would require an indenter and there is no indenter for Haskell code, is there?
22:01:01 <c_wraith> dankna: it could use semicolon format
22:01:02 <dankna> c_wraith: I'm also fairly sure I would have noticed if there were
22:01:11 <djahandarie> o^_^o, my recommendation is to get familiar with Haskell syntax and libraries before fooling with IO
22:01:25 <djahandarie> (Complex IO at least. Printing stuff is probably fine ;))
22:01:26 <c_wraith> I just want an expression as both literal code and an Exp
22:01:44 <dankna> c_wraith, what's the motivation?
22:01:51 <Jesin> and today, I feel like I fully understand monads really well now :D
22:01:57 <Jesin> it was fun ^_^
22:02:23 <dankna> c_wraith, you might also check whether haskell-src-exts has a printer (I wouldn't call it a pretty-printer, but even an ugly-printer would be fine, depending on what you're doing)
22:02:35 <c_wraith> dankna: writing template haskell code to generate ghc-api calls.  >_>
22:02:41 <accel> jmcarthur: did you fix the http://www.haskell.org/haskellwiki/OpenGLTutorial2 ? this line looks different: angle $=! a+0.1 postRedisplay Nothing
22:02:54 <jmcarthur> accel: yeah i did
22:03:07 <dankna> c_wraith, hmmmm....  I see.
22:03:14 <dankna> sounds like you really need the functionality then
22:03:20 <jmcarthur> accel: basically a search "angle $=" and replace "angle $=!"
22:03:50 <c_wraith> dankna: What I'd really love is the ability to take in an Exp, walk it to get the modules necessary for all the names in it, and then print it to a string to be evaluated by the ghc api
22:03:55 <dankna> http://hackage.haskell.org/packages/archive/haskell-src-exts/1.10.1/doc/html/Language-Haskell-Exts-Pretty.html
22:04:24 <dankna> of course, you'll need to write a translator between the TH data types and the LHE ones.
22:04:26 <c_wraith> yeah
22:04:29 <c_wraith> that sounds painful
22:04:31 <dankna> yeah
22:04:44 <accel> jmcarthur: I had to change it to writeIORef to get it to compile; though maybe i screwed somethign else up
22:05:22 <jmcarthur> accel: well the StateVar package documentation says that it exposes ($=!)
22:05:33 <dankna> oh hey look, http://haskell.org/ghc/docs/7.0-latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH-Ppr.html
22:07:51 <c_wraith> does that print it as haskell code, or just pretty-print the AST?
22:07:56 <c_wraith> I suspect the latter
22:08:16 <dankna> oh
22:08:18 <dankna> you're right
22:09:25 <accel> jmcarthur: yeah, but there's some weird typing error
22:10:11 <jmcarthur> accel: well, it's not due to ($=!), because it has the same type as ($=)
22:11:10 <dankna> if you use the { ... ; ... ; ... } notation it shouldn't take /that/ long to write your own printer
22:11:14 <edwardk> hrmm, wellm the ppr stuff led me to finally discover the CONLIKE INLINE pragma modifier ;)
22:11:18 <dankna> I think that's how I'd handle it
22:11:28 <dankna> edwardk, never heard of it, what is it?
22:11:38 <edwardk> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html#conlike
22:12:11 <edwardk> lets RULES pragmas be less paranoid about duplicating works
22:12:32 <dankna> hm, I see!
22:12:38 <lars9> @instances Monad
22:12:40 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
22:12:52 <shapr> @instances OOP
22:12:53 <lambdabot> Couldn't find class `OOP'. Try @instances-importing
22:14:48 <lars9> @pl do{f; g}
22:14:49 <lambdabot> (line 1, column 3):
22:14:49 <lambdabot> unexpected "{"
22:14:49 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
22:15:02 <Jesin> @pl do f; g
22:15:02 <lambdabot> (line 1, column 5):
22:15:02 <lambdabot> unexpected ";"
22:15:02 <lambdabot> expecting variable, "(", operator or end of input
22:15:14 <dankna> @pl do { f ; g }
22:15:14 <lambdabot> (line 1, column 4):
22:15:15 <lambdabot> unexpected "{"
22:15:15 <lambdabot> expecting variable, "(", operator or end of input
22:15:16 <Jesin> @. pl undo do f; g
22:15:16 <lambdabot> f >> g
22:15:35 <Jesin> @undo do {f; g}
22:15:35 <lambdabot> f >> g
22:16:00 <dankna> @. vixen pl
22:16:00 <lambdabot> i'm half white and half mexican
22:16:07 <dankna> ah, that didn't do anything interesting
22:20:03 <drbean> http://haskell.org/haskellwiki/Type_families
22:20:26 <drbean> I didn't find the analogy with type classes helpful.
22:20:35 <drbean> http://hpaste.org/43772/type_family_analogy
22:20:50 <dankna> I agree
22:20:57 <dankna> I found it very unhelpful when I was learning that area, in fact
22:20:59 <drbean> Is it okay to say type families are to types as functions are to values?
22:21:11 <dankna> hmm
22:21:20 <dankna> I have no objection to that wording, but.
22:21:57 <drbean> I don't see a type class as something to overload functions.aa
22:22:04 <dankna> indeed
22:22:10 <lars9> :t (>=>)
22:22:12 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
22:22:13 <dankna> well, I see where that's coming from
22:22:22 <djahandarie> A typeclass is just polymorphism
22:22:26 <djahandarie> Make values depend on types.
22:22:42 <djahandarie> Also something to note: "Type families" means type families, data families, associated type synonyms
22:23:44 <djahandarie> The "function on the type level" kind of works for a  type family / type instance  setup but beyond that it breaks down
22:24:58 <drbean> ok. Misleading.
22:29:32 <drbean> The 2 types of type family: data families and associated type synonyms.
22:30:00 <djahandarie> That's fairly misleading itself. You can do it with three different syntax.
22:31:41 <drbean> Wait. Both data families and type synonym families can be defined in a standalone manner or associated with a type class.
22:31:51 <shapr> y0 mah brother... you're in my type family.
22:32:36 <djahandarie> drbean, yeah, so I guess four technically. (I was grouping the associated ones together.)
22:39:48 <drbean> The wiki article, http://haskell.org/haskellwiki/Type_families
22:40:16 <drbean> .. continues with an interesting example: http://hpaste.org/43773/type_family_example
22:44:55 <drbean> That's the 'data family' flavor in the standalone manner.
22:45:16 <accel> are there any tutorials for GLSL shaders in haskell ? All I have is the API: http://hackage.haskell.org/packages/archive/OpenGL/latest/doc/html/Graphics-Rendering-OpenGL-GL-Shaders.html ... but I would prefer a tutorial
22:45:23 <accel> or just some sample code
22:45:44 <shapr> accel: http://nehe.gamedev.net/data/articles/article.asp?article=21 ?
22:46:00 <accel> shapr: does that come in haskell? :-)
22:46:21 <shapr> I doubt it
22:46:44 <shapr> I that case I'd suggest asking google for "OpenGL filetype:hs"
22:47:05 <accel> shapr: that's brilliant
22:47:10 <accel> http://conal.net/repos/shady-gen/src/Shady/Language/GLSL.hs
22:48:09 <shapr> accel: What can I say, I'm awesome, brilliant and especially modest.
22:48:51 <o^_^o> shapr, you are awesome!
22:49:32 <o^_^o> I wanted some website built with haskell CGI, didn't know what to search for and kept running into walls, "CGIResult filetype:hs" magic incantation!
22:49:54 <shapr> yay!
22:53:39 <kfr> How do Unicode bytestrings work?
22:53:45 <kfr> I mean, how are they stored internally?
22:54:29 <accel> unicode bytestrings filetype:hs
22:55:26 <accel> http://haskell.1045720.n5.nabble.com/Finally-GLSL-support-td3196870.html <-- why is the darcs OrangeBook link there broken?
22:57:23 <accel> why does haskell perfel lowerCamelCase rather than cool_under_scores ?
22:58:48 * Maxdamantus thought camel humps were cool.
23:00:53 * accel writing a 3d graphics app in haskell
23:00:57 <accel> how do I tell haskell to uber optimize ?
23:01:01 <Maxdamantus> Hm, quite the opposite apparently.
23:01:01 <accel> it's kinda slowish riht now
23:01:12 <accel> and it's only showing a sphere
23:02:22 <shapr> accel: The easy approach is to get a PhD from Oxford.
23:02:23 <koala_man> it's usually your fault more than haskell's
23:03:11 <shapr> accel: But seriously, I'd suggest trying the profiling tools
23:03:25 <accel> shapr: which ones?
23:03:33 * accel <-- haskell n00b
23:03:36 * accel <-- haskell n00b^2
23:03:42 * accel <-- haskell n00b^newb
23:03:44 <shapr> <-- haskell n00b^1
23:03:49 <Cale> kfr: Do you mean Data.Text?
23:04:10 <shapr> accel: already seen http://www.haskell.org/haskellwiki/Performance ?
23:04:53 <accel> shapr++
23:04:58 <accel> err,
23:05:20 <accel> do a <- get shapr \n shapr $= a + 1
23:05:33 <shapr> @get-shapr
23:05:34 <lambdabot> shapr!!
23:07:36 <accel> However, bear in mind that strictness annotations can make performance worse. A strictness annotation forces the compiler to ensure that the field is fully evaluated before building the constructor, and if it turns out that the field was already evaluated then this is just wasted work. <-- what does that mean? why doens't it get cached?
23:07:41 <accel> http://www.haskell.org/haskellwiki/Performance/Data_Types
23:09:59 <accel> whoa
23:10:08 <accel> how do I stick +RTS -hc -hb -p into my *.cabal file?
23:10:59 <kfr> Cale: I don't know anything about Data.Text really
23:11:09 <kfr> I was talking about Data.ByteString.UTF8\
23:11:25 <kfr> Is Data.Text an efficient implementation for large amounts of Unicode data?
23:12:11 <shapr> accel: What are you trying to do?
23:12:39 <accel> shapr: i'm building with cabal
23:12:48 <accel> I want to build by default with profiling in my app
23:13:18 <shapr> As far as I know, +RTS options are for running an executable.
23:13:24 <accel> I'man idiot
23:14:21 <shapr> accel: I could be wrong... happens often :-)
23:14:40 <taotree> I have this working: "(execute . (mapL print)) msgs"  .   msgs is some kind of ListT or something. I want to change it to a fold on a lambda. But I can't seem to get the types to work right.
23:15:16 <shapr> @pl (execute . (mapL print)) msgs
23:15:16 <lambdabot> execute (mapL print msgs)
23:16:29 <accel> With the BangPatterns GHC extension enabled (either explicitly or with "-fglasgow-exts"), the above can be written as
23:16:32 <accel> suminit xs !len !acc = …
23:16:35 <accel> that is awesome
23:16:39 <taotree> ok, so I just need to replace mapL print with some type of fold...
23:17:58 <accel> how do I tell cabal to build with optiosn of:
23:17:59 <accel> ghc -prof -auto-all
23:18:41 <taotree> what's the equivalent fold for that mapL?
23:19:36 <joe6> hello
23:26:52 <lispy> :t malpL
23:26:53 <lambdabot> Not in scope: `malpL'
23:26:55 <lispy> :t mapL
23:26:56 <lambdabot> Not in scope: `mapL'
23:29:32 <taotree> I think I found it, it's foldlL, but... just can't get it to work
23:29:40 <taotree> tried this: execute (foldlL (\a b -> a) 0 msgs)
23:30:10 <taotree> no go
23:31:19 <Cale> kfr: yeah.
23:32:03 <Cale> kfr: Data.ByteString.UTF8, iirc just has some UTF8 encoding and decoding functions. ByteStrings really just represent sequences of bytes like their name suggests, and not characters.
23:32:35 <kfr> What advantages does String have over Text?
23:35:55 <Zao> kfr: Being a list.
23:36:07 <kfr> Whereas Text works how?
23:36:15 <kfr> Inflated fixed size entries in an array?
23:36:20 <Zao> Magical sequence with functions that look listish.
23:36:53 <Zao> Internally it's WTF-16 or somesuch, with a nice Char-like interface.
