00:23:10 <mbuf> joe6: thanks
00:32:43 <sholmes> I was here before
00:33:52 <Axman6> did you leave your hat?
00:34:01 <Axman6> if so, you can find it at the front desk
00:37:54 <shachaf> Axman6: We have a front desk?
00:38:03 <shachaf> This channel has gotten advanced since the last time I was here.
00:39:22 <c_wraith> yes, but no one specified what it was in front of
00:39:29 <c_wraith> (hint: it has quite large teeth)
00:44:55 <jonrafkind> what does this error mean? Module 'Control.Exception' does not export 'Exception(ExitException)' ?
00:45:12 <jonrafkind> maybe my version of haskell is too old?
00:45:26 <ksf> setup: Can't find transitive deps for haddock  
00:45:28 <ksf> wut?
00:45:31 <joe6> show . map (flip showHex "") $ ([8,9,10]::[Word8])
00:45:34 <joe6> > show . map (flip showHex "") $ ([8,9,10]::[Word8])
00:45:36 <lambdabot>   "[\"8\",\"9\",\"a\"]"
00:46:00 <joe6> i am trying to convert the "a" to "0a". Any suggestions, please?
00:46:18 <joe6> > show . map printf "02x" . map (flip showHex "") $ ([8,9,10]::[Word8])
00:46:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
00:46:19 <lambdabot>         against inferred ty...
00:46:34 <joe6> > show . map (printf "%02x") . map (flip showHex "") $ ([8,9,10]::[Word8])
00:46:34 <lambdabot>   Ambiguous type variable `b' in the constraints:
00:46:35 <lambdabot>    `Text.Printf.PrintfType ...
00:46:56 <sholmes> Axman6, no I didn't leave anything. Other than good talk. :D
00:51:23 <sipa> is there a way of searching for unused and unexported definitions in a .hs file?
00:52:16 <Egbert9e9> so IO is the type name and there's nothing to it o-o
00:52:42 <joe6> > putStrLn . map (printf "%02x") . map (flip showHex "") $ ([8,9,10]::[Word8])
00:52:43 <lambdabot>   No instance for (Text.Printf.PrintfType GHC.Types.Char)
00:52:43 <lambdabot>    arising from a u...
00:52:43 <Egbert9e9> something like, data IO = IO ()
00:53:41 <Egbert9e9> and all these functions that deal with IO return IO ()
00:54:01 <joe6> any suggestions on how I can get this working, please?
00:54:12 <Egbert9e9> finally getting it
00:54:16 <joe6> > show . map (printf "%02x") . map (flip showHex "") $ ([8,9,10]::[Word8])
00:54:17 <lambdabot>   Ambiguous type variable `b' in the constraints:
00:54:17 <lambdabot>    `Text.Printf.PrintfType ...
00:54:27 <kfr> joe6 isn't that last $ unnecessary?
00:54:47 <kfr> (random remark)
00:55:42 <Egbert9e9> is there a way to autocomplete modules in ghci?
00:56:03 <Egbert9e9> without ":m + [tab]"
00:56:10 <shachaf> kfr: Nope.
00:56:26 <Axman6> Egbert9e9: works fine for me, what are you trying?
00:56:30 <shachaf> Egbert9e9: What's wrong with :m +?
00:56:54 <Axman6> in ghc7 you can use import Foo.Bar.Baz as B
00:56:56 <Wooga> i have modules autocompletion working too
00:56:59 <Axman6> which is lovely :()
00:57:01 <Axman6> :)*
00:57:17 <shachaf> Axman6: You can do that in ghci 7?!
00:57:18 <kfr> > ((+0) 0, (+0) $ 0)
00:57:19 <lambdabot>   (0,0)
00:57:21 * shachaf is behind the times.
00:57:24 <kfr> shachaf: How so?
00:57:33 <quicksilver> kfr: because of the .s
00:57:37 <Egbert9e9> it only shows the loaded modules
00:57:40 <Egbert9e9> which is Prelude
00:57:48 <vegai> shachaf: also in 6.12.1
00:57:57 <quicksilver> kfr: a . b $ c = (a . b) c which is entirely different from a . b c = a . (b c)
00:57:59 <shachaf> vegai: Not here.
00:58:04 <Egbert9e9> Axman6, isn't it supposed to be qualified?
00:58:04 <kfr> Oh, right
00:58:11 <vegai> shachaf: may depend on a compile time library dependency
00:58:15 <quicksilver> kfr: in fact this is the purpose of $ - to be a low precedence composition.
00:58:24 <Egbert9e9> shachaf, i donno, i don't like typing weird characters
00:58:25 <vegai> libedit, I'd guess
00:58:32 <Egbert9e9> shift characters, that is
00:58:33 <shachaf> vegai: Library dependency? For "import X as Y"?
00:58:48 <vegai> and I seem to remember that in ghc7, that part was implemented in pure haskell
00:58:50 * shachaf wishes Haskell had fewer keywords.
00:59:03 <vegai> shachaf: for the tab completion
00:59:11 <Egbert9e9> Axman6, as in import qualified foo.bar as b
00:59:15 <Egbert9e9> or somesuch
00:59:27 <shachaf> vegai: No one is disputing the existence of tab completion.
00:59:36 <vegai> shachaf: oh, right. I missed one your comments.
00:59:48 <Egbert9e9> shachaf, keywords?
01:00:03 <shachaf> vegai: Ah, OK. :-)
01:00:07 <shachaf> Egbert9e9: Keywords.
01:00:18 <Egbert9e9> shachaf, Keywords?
01:00:24 <Egbert9e9> :-o
01:00:25 <Egbert9e9> err
01:00:27 <Egbert9e9> :-p
01:00:54 <Egbert9e9> shachaf, i've got monads, btw. now i need to learn how to use them
01:01:02 <Egbert9e9> shachaf, give me a cookie!
01:01:07 <Egbert9e9> I DEMAND A COOKIE
01:01:37 <Axman6> i found learning how to use monads was much eas\sier than learning what monads are
01:01:40 <Axman6> easier*
01:02:00 <Egbert9e9> i know! someone should make a tutorial about making monads
01:02:02 <Egbert9e9> <_<
01:02:23 <Axman6> i think someone should write a tutorial about how to write a monad tutorial
01:02:25 <shachaf> Egbert9e9: Hmm? Monads?
01:02:33 * shachaf ate a monad yesterday.
01:02:42 <shachaf> I mean burrito.
01:02:46 <kfr> I can't even think of a reason to make my own monads any time soon, I'll just keep on using ReaderT and StateT, that's pretty much all I need, I think
01:02:57 <shachaf> kfr: Nah, you need Cont.
01:03:16 <kfr> ContStuff? Contiuations?
01:03:25 <Egbert9e9> o-o weird.
01:03:30 <shachaf> Cont is the best monad.
01:03:44 <kfr> I might use Identity
01:03:46 <kfr> Never heard of COnt
01:03:48 <kfr> Cont*
01:03:59 <shachaf> Egbert9e9: Any reason to tell me in particular about the monads?
01:03:59 <kfr> type Cont r = ContT r Identity
01:04:06 <Egbert9e9> i've never heard of anything other than IO ()
01:04:14 <Egbert9e9> shachaf, you were here
01:04:24 <shachaf> IO is the worst monad.
01:04:32 <kfr> IO is the best
01:04:36 <Egbert9e9> and the monadic lover
01:04:48 <Egbert9e9> which is extremely sleazy
01:04:49 <shachaf> Egbert9e9: By the way, if it's the only one you've encountered, saying you "got monads" is meaningless.
01:05:07 <Egbert9e9> shachaf, well, i've read http://stackoverflow.com/questions/1779431/creating-monads-in-haskell
01:07:26 <koala_man> dibblego!!
01:08:11 <shachaf> dibblego!
01:09:18 <Egbert9e9> whats a dibblego
01:09:49 <shachaf> The best kind of go.
01:09:55 <pozic> Egbert9e9: the nick of someone.
01:11:38 <Egbert9e9> that's freaky
01:12:01 <xshay> good evening
01:12:05 <Egbert9e9> Axman6, what should i use it for?
01:12:24 <xshay> can anyone point me in the direction of defining a type that covers the chars "1" | "2" | ... ? Is this possible?
01:12:35 <xshay> I want to pattern match using it
01:12:49 <sipa> xshay: can you be a bit more specific?
01:13:18 <xshay> sipa: I have two strings "add thing", and "add 123 things"
01:13:44 <xshay> sipa: I want processIt ("add":xs) = ... something ... for the latter
01:14:27 <xshay> sipa: and something like processIt ("add":"1"|"2"|"3"+:xs) = ... for the former
01:14:47 <xshay> sipa: not even sure if this is possible, I basically want to handle those two strings separately
01:15:06 <xshay> sipa: actually sorry, they're [String], so ["add", "123", "things"]. (from getArgs)
01:15:13 <sipa> ah
01:15:35 <sipa> looks you need a parser library :)
01:16:32 <sipa> you can write processIt ("add":x) = case x of { "thing" -> ...; _ -> ... }
01:16:44 <joe6> is there a better way of writing this: (\x -> printf "%02x " x :: [Char])
01:17:07 <xshay> sipa: perhaps rather than pattern matching I could use guards + a regex
01:17:17 <sipa> yes
01:20:41 <joe6> > words
01:20:41 <lambdabot>   Overlapping instances for GHC.Show.Show
01:20:41 <lambdabot>                              (GHC.B...
01:20:53 <joe6> xshay: check out words
01:22:57 <xshay> sipa: joe6 thanks guys, I've just installed Text.Regex.Posix and will have a play
01:28:03 <Egbert9e9> okay, tab completion wouldn't be too great anyways
01:29:13 <Wooga> hello, is it possible to write completly functionaly pure BrainFuck interpreter in haskell? i tried to, but stuck on reading values from terminal: it requires IO, which is impure. is there any way to bypass this (excluding unsafe IO transformations) ?
01:32:07 <quicksilver> Wooga: make a pure model of the terminal.
01:32:16 <sipa> Wooga: i think it should be possible, writing it as a function that takes a list of input values, and produces a list of output values
01:32:17 <Saizan> you can interpret a brainfuck program as a function from input to output
01:32:24 <quicksilver> right, what they said.
01:33:27 <kevinburke> hey, i'm struggling with learning how to do dynamic programming in haskell
01:33:58 <kevinburke> any tips?
01:35:23 <shachaf> kevinburke: That's somewhat general. Just... The usual way, except in Haskell.
01:35:33 <Wooga> sipa: but doesn't it means that you have to perform all input actions at once before actualy evaluting bf source?
01:36:37 <sipa> Wooga: enter haskell's lazyness :)
01:36:45 <shachaf> kevinburke: Are you trying to implement some particular algorithm?
01:36:57 <sipa> you can do a lazy read of your input, and feed that to your pure function
01:37:10 <sipa> causing the I/O to happen as necessary only
01:40:14 <quicksilver> sipa: that's not laziness.
01:40:17 <quicksilver> that's interleaved IO
01:40:20 <quicksilver> which is much more sinister.
01:40:24 <sipa> agree
01:40:25 <quicksilver> Useful, sure, but sinister.
01:40:35 <sipa> but it wouldn't be possible without lazyness
01:40:47 <quicksilver> there are other solutions - you could implement the BF interpreter over a polymorphic monad
01:41:10 <quicksilver> and instantiate it to something pure (something like State) for pure testing, and instantiate it to IO to get efficient IO.
01:48:47 <MarcWeber> Is the Haskell community server out of service for some reason? I tried pushing a commit to MarcW@code.haskell.org
01:49:25 <gienah> MarcWeber: maybe the ssh key changed
01:49:58 <gienah> the ip address changed, so another thing to check is you don't have the old one in /ec/hosts or something
01:50:42 <MarcWeber> gienah: Do you have the new one?
01:50:43 <gandalfcome> I'm going to be blunt: What's so great about a functional languages? (no rethoric question, I really wanna know)
01:50:55 <MarcWeber> 178.63.91.44 it resolves to this here.
01:51:12 <gienah> MarcWeber: no, sorry
01:51:13 <MarcWeber> gandalfcome: Depends on the use case. You don't have to care about state that much.
01:52:17 <gandalfcome> MarcWeber: I met this person Guy Steele and he suggested functional languages are great in science. I personally use python, but am not a computer scientist… Can you elaborate?
01:52:46 <MarcWeber> gandalfcome: You know about self? That's the internal state of objects.
01:53:01 <MarcWeber> Its hard to test because the outcome of class.foo() depends on the internal state of the object.
01:53:17 <MarcWeber> In Haskell there is no such state (usually). There are ways to get something similar.
01:53:27 <MarcWeber> So when calling foo(x) you always get the same result.
01:53:28 <gandalfcome> MarcWeber: yes, which is a good thing I guess….
01:54:06 <MarcWeber> gandalfcome: Depends. If you read the code of yi handling some user configurations you see python would have been cleaner to implement this particular piece of problem.
01:54:09 <sjoerd_visscher> How do I say in my cabal file that my code is Haskell2010?
01:54:11 <MarcWeber> In general: yes
01:54:29 <dcoutts_> sjoerd_visscher: default-language: Haskell2010
01:54:34 <dcoutts_> sjoerd_visscher: requires Cabal 1.10
01:54:50 <MarcWeber> Wow. :) Didn't knew about it.
01:54:51 <gandalfcome> MarcWeber: but if I have an object ball, and I say ball.get_position(). I don't want this to be always the same answer.
01:55:15 <sjoerd_visscher> dcoutts_: thanks, does Hackage understand that?
01:55:16 <MarcWeber> gandalfcome: That's why you have getBall :: Ball -> Position in Haskell
01:55:22 <MarcWeber> You always pass the reference explicitely.
01:55:53 <dcoutts_> sjoerd_visscher: should do, I think the hackage scripts are using a recent Cabal lib version
01:56:58 <dcoutts_> sjoerd_visscher: should do, I think the hackage scripts are using a recent Cabal lib version
01:58:24 <gandalfcome> MarcWeber: Thanks for explaining. I'm trying to get my head around this. Are there variables and things in haskell, or is the variable a function….
01:59:13 <gandalfcome> MarcWeber: I might ask stupid questions…. sorry
02:00:23 <MarcWeber> the latter.
02:01:18 <MarcWeber> gandalfcome: Its not only about testing also about reasoning. Its easier to proof that code behaves correctly.
02:03:24 <gandalfcome> MarcWeber: Do people use languages like haskell a lot in the real world? Or is this more like a academic language, that is need to play with? (sorry no offense, I hope you know what I mean...)
02:03:30 <sjoerd_visscher> dcoutts_: how can I use cabal-install with Cabal 1.10?
02:03:32 <gandalfcome> need=neat
02:04:08 <dcoutts_> sjoerd_visscher: currently you have to get cabal-install from darcs
02:05:04 <MarcWeber> gandalfcome: See haskell.org and the haskellers website. Depends on the use case. If you change technology you have to write much from scratch. So naturally there will be less users using Haskell.
02:05:22 <MarcWeber> gandalfcome: If you watch users in this room you'll notice that there are more and more..
02:06:35 <MarcWeber> gandalfcome: You should always pick the best tool for a task. Often Haskell is competitive or superiour but not always.
02:07:00 <MarcWeber> Eg if you want to create fast JS Haskell is bad. Maybe even using COM on Windows should be done using native tools etc.
02:08:23 <gandalfcome> MarcWeber: I do most of my things in Python. It works well for me, but I define working well from a phycisists view rather than from a computer science view (probably most of my programming is more or less dirty hacks ;-) ). 
02:10:19 <taotree> Why is x not in scope?   http://hpaste.org/43573/x_scope
02:11:06 <tab> taotree: the where scope happens before the body of your function
02:11:24 <jaj> haskell is probably the most mainstream of functional languages
02:12:08 <tab> taotree: i.e. in the where you only p1 and p2 defined so far
02:12:26 <jaj> gandalfcome: and even people who are not into programming use programs written in haskell like xmonad or darcs
02:12:31 <taotree> ah... the where clause is supposed to be in the lambda, but it's not is it?
02:14:19 <taotree> can it be?
02:15:54 <quicksilver> taotree: not without slight contortion, but you can put a 'let' inside the lambda more easily.
02:16:56 <taotree> ok, switched it to let... in instead
02:17:05 <taotree> thanks
02:19:39 * hackagebot data-category 0.3.1.1 - Restricted categories  http://hackage.haskell.org/package/data-category-0.3.1.1 (SjoerdVisscher)
02:25:20 <shapr> Botje: Yes, I still have bunches of Cell processors, and I'm hoping to get that system online again this weekend.
02:31:59 <joe6> Xshay: also check Data.List.Split
02:32:09 <xshay> joe6: cheers
02:33:09 <Palmik> Hi guys, I'm trying to parse an expression like this http://codepad.org/notexZj8 (simplified for test case), but the problem is that it probably gets into an infinite recursion, how would you handle situation like this? :)
02:35:29 <mm_freak> Palmik: first of all, look at applicative style
02:36:41 <mm_freak> next, don't use 'try' on the last alternative
02:37:08 <mm_freak> and finally i don't see the infinite recursion here
02:38:05 <Palmik> oh, sorry, parseExpression should have been expression like this http://codepad.org/FblEOrbd
02:38:13 <mm_freak> i assumed so =)
02:38:58 <joe6> which debugger do you use? i am getting a weird error from a libusb binding and want to see what parameters were sent. any suggestions, please?
02:40:51 <Palmik> mm_freak, hmm to me it seems that it tries operatorCall, which then tries operatorCall itself etc. ad infinitum
02:41:57 <mm_freak> true
02:42:07 <mm_freak> that makes sense
02:42:28 <dibblego> koala_man!!
02:42:31 <dibblego> shachaf!!
02:42:46 <Palmik> but it never finishes on expression like "1+1"
02:43:17 <quicksilver> yes, left-recursion.
02:43:29 <quicksilver> expression -> operatorCall -> expression
02:43:54 <quicksilver> you need to re-express your grammar in a way which avoids left recursion.
02:44:41 <Palmik> ah, ok :) will have to look it up, thanks for pointing me in the right direction though :)
02:44:42 <mm_freak> like don't allow the left operand to be a non-parenthesized expression
02:46:42 <dafis> preflex: seen int80_h
02:46:42 <preflex>  int80_h was last seen on #haskell 5 hours, 43 minutes and 49 seconds ago, saying: useful info, will help me with style. But no clue as to what is wrong.
03:17:36 <shapr> SHAZAM!
03:50:41 <joe6> how can I trace a function call with ghci? I notice that trace or traceshow has no output. I just want to see all the parameters that the function is called with?
03:51:21 <dafis> joe6: Debug.Trace?
03:51:53 <joe6> dafis: trace has no output. I do not know if that is expected?
03:52:03 <joe6> it just shows the label that I put in the call
03:52:20 <joe6> trace "some label" function == just shows "some label"
03:52:46 <Bynbo7> trace is a very simple function...
03:53:09 <dafis> joe6: trace ("functionname " ++ show(arg1,arg2,...,argn)) (rhs of function)
03:53:14 <Bynbo7> it's something like: trace s x = unsafePerformIO $ do { putStrLn s; return x}
03:53:16 <Bynbo7> that's all
03:54:53 <joe6> dafis: so I have to list out all the arguments in the trace call. I was thinking that it does that automatically.
03:55:06 <Wooga> what should i read in order to understand what liftIO does, how it works and what it good for?
03:55:15 <dafis> joe6: no, trace just prints out the String you give it
03:55:43 <Bynbo7> Wooga: it's there do you can perform IO in a monad transformer which IO at its base, that's it
03:56:11 <Bynbo7> so, if you're working in StateT Int IO String, then you can print things using liftIO $ print x
03:56:41 <Wooga> ...then i should to know what monad transformers are first
03:57:23 <Wooga> i think i am understending what regular monads are, thanks to lyah
03:58:01 <dafis> Wooga: roughly, monads wrapping other monads
03:58:32 <Wooga> like lists of lists?
03:59:01 <dafis> newtype StateT s m a = SatetT { runStateT :: s -> m (a,s) }
03:59:18 <dafis> Wooga: rather, lists of Maybes
03:59:34 <dafis> but those aren't very interesting
04:00:33 <dafis> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }, typo'ed
04:00:44 <Wooga> k, thanks for answering. i've got my keywords now
04:00:49 <dafis> State transformer wrapping m
04:01:28 <dafis> for example, if m = [], you get a list of (result,nextstate) pairs
04:02:07 <dafis> everytime the list has more than one element, it branches for the following actions
04:02:33 <dafis> makes for very easy (but not very efficient) backtracking parsers
04:03:51 <jacobian> @pl \ o x ->  f o (p x)
04:03:52 <lambdabot> (. p) . f
04:06:43 <MSJ> hello
04:06:50 <MSJ> i want to learn haskell
04:06:52 <MSJ> please
04:07:03 <Bynbo7> @where lyah
04:07:03 <lambdabot> http://www.learnyouahaskell.com/
04:07:13 <Bynbo7> MSJ: ho to that web site
04:07:18 <Bynbo7> go*
04:07:21 <MSJ> ok thanks
04:07:40 <MSJ> bye
04:07:50 <Bynbo7> heh
04:07:57 <quicksilver> another satisfied customer.
04:08:08 <Bynbo7> my work is done
04:08:18 * Bynbo7 goes to get dinner
04:09:49 <Persian> hi
04:10:53 <dafis> ho
04:11:34 <nicwr> @joe6 i can't get trace to work either. i've tried tracing an expression and using a breakpoint, but neither seems to work.
04:11:34 <lambdabot> Not enough privileges
04:11:36 <nicwr> @dafis not the function Debug.Trace, the ghci command :trace.
04:11:37 <lambdabot> Unknown command, try @list
04:14:14 <dafis> nicwr: I think joe6 asked about Debug.Trace.trace, can't help you with the ghci debugger, I've never used it
04:14:34 <pozic> I used the debugger and it is a waste of time to use it :)
04:15:02 <pozic> It was just an academic project and now the academic has left the building.
04:15:09 <xplat> what does Control.Applicative.some do?
04:16:40 <pozic> xplat: if the documentation does not say so, file a bug.
04:17:24 <nicwr> dafis: ok. thanks.
04:17:52 <nicwr> pozic: but did you manage to get a stack trace though =)
04:18:13 <nicwr> s/stack/call
04:18:32 <xplat> i probably wouldn't have asked here if firefox on this machine weren't messed up
04:19:38 <dafis> xplat: the docs say "One or more."
04:20:03 <dafis> like many1 in parsec
04:20:15 <xplat> ah, thanks
04:21:08 <pozic> nicwr: there is no such thing as a stack trace. 
04:21:19 <pozic> nicwr: there is a similar thing, and the manual explains how to get that. 
04:22:05 <nicwr> poznic: i know, meant to say call trace. reading the manual now.
04:22:48 <pozic> nicwr: the best way is to write your programs such that you don't need those tools, though.
04:23:07 <pozic> nicwr: you should be able to explain in just a few words what something does.
04:23:08 <dafis> pozic: easier said than done?
04:23:20 <kfr> Type classes: do you need to provide a function for every function of the type class which does not have a default implementation when you make something an instance?
04:23:23 <xplat> i guess the combinator i am looking for is (foldr (<|>) empty)
04:23:32 <kfr> Or is that voluntary?
04:23:59 <nicwr> pozic: sure.
04:24:56 <dafis> kfr: you need not, if a method without implementation is called, you get undefined
04:26:01 <xplat> huh, i'd've thought that would be enforced
04:26:15 <kfr> xplat same
04:26:16 <dafis> kfr: it would however be more user friendly to at least implement those methods as error "method foo not implemented for type Bar"
04:26:26 <xplat> you could get out of it easy enough if it's your own typeclass, after all
04:26:35 <kfr> I bet -Wall would complain about it anyways though
04:26:44 <dafis> kfr: it does
04:27:30 <dafis> kfr: but it won't complain if all methods are implemented via defaults and you provide no method to break the loop
04:37:22 * hackagebot TableAlgebra 0.1.5 - Ferry Table Algebra  http://hackage.haskell.org/package/TableAlgebra-0.1.5 (JeroenWeijers)
04:39:23 * hackagebot FerryCore 0.4.5 - Ferry Core Components  http://hackage.haskell.org/package/FerryCore-0.4.5 (JeroenWeijers)
04:41:23 * hackagebot Pathfinder 0.4 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.4 (GeorgeGiorgidze)
04:47:25 * hackagebot DSH 0.4 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.4 (GeorgeGiorgidze)
04:47:52 <xplat> well, it's halting-hard to figure out if there's a method loop
04:48:02 <xplat> except in simple cases
04:48:56 <pozic> The halting problem does not even exist in the real world. 
04:49:34 <pozic> Most people also say semi-decidable instead of halting-hard.
04:51:02 <xplat> well, yes, semi-decidable is more standard but halting-hard is more accessible for people with an algorithmics rather than a logic background
04:51:17 <xplat> also, it means something different
04:52:33 <xplat> halting-hard means at least as hard as the halting problem, semidecidable is more precise
04:54:42 <xplat> and also, yes, deciding if things halt in ~10^120 transitions or not would be plenty for the real world for the foreseeable future ...
04:54:44 <pozic> xplat: Google has never heard of "halting-hard".
04:55:15 <pozic> xplat: I think halting-hard is just something you made up, since I have an algorithms background and never heard of it. 
04:55:20 <xplat> okay, so semidecidable is a LOT more standard
04:55:50 <quicksilver> it's 'something he made up' in the sense that all sentences are something you make up.
04:55:57 <quicksilver> it was perfectly understandable.
04:56:16 <pozic> There is no need to inflate the vocabulary. Sure, I could understand it. 
04:56:33 * zygoloid is also on the side of "good communication is comprehensibility not conformity"
04:57:03 <pozic> Good communication is not just throwing words around and hoping they mean something.
04:57:07 <zygoloid> (though great communication is both)
04:57:18 <basvandijk> Is there a good reason why the tuple in a WriterT is defined as (a, w) instead of (w, a)? The latter has the advantage that it's more consistent with the Functor instance on tuples: instance Functor ((,) w) where fmap f (x,y) = (x, f y).
04:57:48 <basvandijk> Is this just historical "accident"?
04:58:16 <quicksilver> pozic: there is no 'hope' involved.
04:58:21 <xplat> pozic: i had both a precise meaning in mind and an idea of the process by which that meaning would be constructed in readers' minds
04:58:23 <dafis> basvandijk: I think it's an accident to match State's order
04:58:23 <quicksilver> "X-hard" means "at least as hard as the problem X"
04:58:29 <quicksilver> it is completely standard and completely precise.
04:59:00 <quicksilver> the fact of whether or not it has been previously applied to a particular X is not relevant to its comprehensibiliyt.
04:59:05 <zygoloid> basvandijk: i have on several occasions wished Writer and State were the other way around.
04:59:14 <basvandijk> dafis: OK.
04:59:18 <dafis> basvandijk: If I'm right, then the historical accident for State is without reason
04:59:19 <basvandijk> zygoloid: me too
04:59:39 <xplat> 0'-hard would have meant the same thing, but i deliberately used halting-hard instead because only people who've paid some attention to formal recursion theory know what 0' is and 'everyone' knows what halting is
04:59:54 <basvandijk> I wonder if a proposal to change the order of the StateT and WriterT tuples can make it through
05:00:11 <dafis> basvandijk: I doubt it, would break way too much code
05:00:12 <basvandijk> (I would surely break lots of code)
05:00:53 <zygoloid> basvandijk: you could use instance Monoid m => Monad ((,) m) instead, i suppose.
05:01:59 <basvandijk> zygoloid: indeed.
05:02:10 <zygoloid> the compatible way to change it would be to use a new type, in a different module/package, and wait for the whole world to transition
05:02:23 <zygoloid> (because what haskell needs is more monad transformer packages...)
05:03:40 <dafis> zygoloid: now with the transformers/mtl thing out of the way, surely there's room for new mayhem?
05:07:51 <pozic> Did anyone ever demonstrate an alternative to monad transformers showing how you can combine IO with various functionality (writers, readers, state, etc.)?
05:08:41 <xplat> people have demonstrated alternatives to monad transformers, like effect algebras
05:08:49 <xplat> not sure they have handled IO though
05:10:45 <xplat> i can give you a reference once i get on the machine with working web browser
05:11:45 <basvandijk> pozic: This might also interest you: http://tomschrijvers.blogspot.com/2010/03/bruno-oliveira-and-i-are-working-on.html
05:16:53 <xplat> there's the idea ancestral to monad transformers, too, where you take two actual monads and just combine them with a custom distributive law relating them.  monad transformers were really just a way of organizing that idea and making it tractable, afaict.
05:17:44 <pozic> evalMem2 still contains an explicit lift.
05:19:35 <Wooga> is `ListT IO String` monad with liftIO inside of it impure?
05:20:20 <sipa> depends whether you call IO impure
05:20:25 <Bynbo7> heh
05:41:35 <mm_freak> how can i force in GHC that a certain source file depends on another file?
05:41:45 <mm_freak> the other file is not a haskell file
05:41:54 <mm_freak> but gets included via TH
05:42:03 <Wooga> maybe thats the matter of Make rather then GHC?
05:42:19 <Wooga> or what build system do you use?
05:42:25 <mm_freak> no, it's not, because 'make' isn't even involved, but rather ghc --make
05:42:36 <mm_freak> i use cabal
05:43:01 <mm_freak> i thought i could #include the other file as a comment via CPP, but that's rather ugly
05:43:10 <dcoutts> mm_freak: sorry, not possible with ghc --make
05:43:16 <mm_freak> and i'm not sure whether GHC detects this
05:43:19 <dcoutts> nope
05:43:26 <mm_freak> hmm, ok
05:44:14 <mm_freak> ah, i have an idea…  i could create a Dummy.hs, which i 'touch' via a Makefile
05:45:11 <quicksilver> if you're using a makefile anyway
05:45:18 <quicksilver> then just use the makefile to delete the .o file
05:45:39 <mm_freak> well, the Makefile can't easily detect which files depend on which
05:45:52 <mm_freak> but yeah, i can delete Dummy.o
05:49:24 <mm_freak> hmm, that only recompiles Dummy.hs =/
05:50:29 <Wooga> try to switching to Make completly. it's not that hard and good enough if you don't have conditional includes
05:51:28 <mm_freak> but isn't that inconvenient?  each time you change the imports of a module you would need to adjust the Makefile
05:51:40 <quicksilver> you can get GHC to automatically generate .depend files
05:51:47 <quicksilver> which you then include into your makefile
05:51:47 <Wooga> no, you don't
05:51:54 <mm_freak> ah, ok
05:51:57 <quicksilver> however, ghc --make is faster
05:52:08 <quicksilver> possibly not in a way which will bother you
05:52:40 <hpc> another possibility is to write a shell script
05:52:52 <hpc> so you have precise control over what happens when, and what gets included
05:52:56 <Wooga> here is simple makefile for cpp prijects: http://paste.pocoo.org/show/331613/
05:53:03 <hpc> that could be verbose, though
05:53:05 <Wooga> it can be easily adjusted to haskell ones
05:53:08 <mm_freak> Wooga: i know how to write Makefiles
05:53:17 <mm_freak> that's not the problem
05:53:36 <Wooga> mm_freak: that makefiles frees you from editing it once you setted up compile options
05:53:44 <mm_freak> i just don't want to give up the convenience cabal provides
05:54:03 <mm_freak> also i would still need to write the dependencies manually, because GHC doesn't cover the TH deps
05:54:25 <quicksilver> Wooga: that does not look like a correct makefile to me.
05:54:38 <Wooga> quicksilver: it works fine for all of mine cpp projects
05:54:43 <quicksilver> Wooga: it makes no attempt to work out which .o files depend on which .h files
05:54:45 <mm_freak> quicksilver: it is a correct GNU make file
05:55:04 <dcoutts> mm_freak: a general solution for the case of TH reading external files is pretty tricky since the build system cannot get any insight into it
05:55:13 <quicksilver> you could change an interface in a .h file, recompile only one of the files dependent on it, and get a crash
05:55:14 <mm_freak> quicksilver: that's true, though
05:55:18 <dcoutts> mm_freak: ultimately I'd like to handle #includes correctly though
05:55:23 <mm_freak> i could use an old Makefile i've written for my C++ projects
05:55:28 <mm_freak> it uses a .depend file
05:55:34 <mm_freak> but it doesn't really solve my problem
05:55:48 <Wooga> hm
05:56:13 <mm_freak> dcoutts: i wouldn't have a problem with manually mentioning the external files somewhere
05:56:28 <mm_freak> but without hackery like deleteing .o files
05:56:36 <dcoutts> mm_freak: I generally don't like such solutions because it's possible to get it wrong
05:56:42 <mm_freak> exactly
05:56:45 <dcoutts> untracked deps leads to chaos
05:57:33 <mm_freak> hmm…  as a dirty solution i could include the external files as literate haskell
05:58:16 <mm_freak> my current solution is slow, but very clean:  if any file in 'templates' changes, do 'cabal clean' before compiling
06:00:52 <mm_freak> hpc: btw, Makefiles are like shell scripts, but they let you express dependencies much cleaner…  in general i prefer Makefiles over shell scripts, where possible, including non-programming tasks
06:01:05 <hpc> mm_freak: ah, k
06:01:17 * hpc hasn't read much on makefiles
06:01:26 <mm_freak> then you should =)
06:01:39 <mm_freak> if you like writing shell scripts, you'll love writing Makefiles
06:02:13 <mm_freak> i always think of Makefiles like functional shell scripts
06:03:00 <Ke> only that nothing practically is pure =oP
06:03:22 <Ke> recursive yes functional hardly
06:03:37 <pastorn> mm_freak: how do you change $PWD in makefiles?
06:03:42 <sjoerd_visscher> just wondering: is there a good reason why it takes so long for packages to get built after uploading them on Hackage?
06:03:53 <mm_freak> pastorn: by using submakefiles
06:04:04 <hpc> sjoerd_visscher: iirc it does builds overnight
06:04:05 <pastorn> i.e. i couldn't get cd lol && ./scrypthere.sh
06:04:06 <pastorn> to run
06:04:35 <Wooga> interesting point
06:04:45 <pastorn> mm_freak: could you show me how that specific task is done?
06:04:46 <mm_freak> pastorn: that works, but it's not the proper way to do this
06:04:48 <aleator> \me wonders if you could use ghc as shell inside makefiles..
06:04:59 * Wooga ond day grindied cross-platform shellscripting, but never tried to apply same thing for Makefiles
06:05:23 <pastorn> mm_freak: when i tried it the "cd lol" wasn't remembered... or maybe i tried to do this on multiple lines...
06:05:24 <mm_freak> pastorn: create a Makefile in 'lol' and in the top Makefile do this:  $(MAKE) -C lol
06:05:28 <mm_freak> possibly with a target
06:05:41 <mm_freak> pastorn: it won't work on multiple lines
06:05:45 <pastorn> mm_freak: oh, cool :)
06:06:25 <mm_freak> pastorn: each line in a target rule is one separate shell invocation
06:06:41 <mm_freak> you can write multiline commands by using '\'
06:06:58 <pastorn> mm_freak: is there some good Makefile 4 newbz tutorial you know of?
06:07:13 <mm_freak> pastorn: just read the 'info' file of GNU make
06:07:16 <mm_freak> % info make
06:07:34 <pastorn> ehm... wtf is info?
06:07:42 <mm_freak> a better 'man' =)
06:08:23 <mm_freak> navigation is simple:  use cursor keys…  when on a link, press enter to follow it
06:08:23 <hpc> info has the same... info as man
06:08:42 <mm_freak> hpc: then the texinfo file of make is not installed on your system
06:08:51 <Bynbo7> inf always confused me, and felt bulky and slow in comparison to man
06:08:55 <hpc> probably, it's ubuntu
06:09:32 <pastorn> mm_freak: i like man/less bettar
06:10:26 <mm_freak> 'man' is not suitable for long, comprehensive documentation the way 'info' is
06:10:48 <pastorn> mm_freak: i'm pretty comfortable reading the mplayer docs with man
06:10:54 <mm_freak> 'info' is a full-fledged browser with emacs-style key bindings, hyperlinks, etc.
06:11:01 <pastorn> lol emacs
06:11:03 <MasseR> How does haskell optimize function calls with same arguments. I have a function which is called ~100-200k times per run, and many of the times the arguments are the same
06:11:10 <pastorn> @slap mm_freak 
06:11:10 * lambdabot hits mm_freak  with an assortment of kitchen utensils
06:11:17 <pastorn> that's for emacs
06:11:20 <mm_freak> pastorn: then try reading the 'zshall' using 'man' ;)
06:11:40 <saml> lol emacs lol
06:11:50 <pastorn> saml: exactly
06:11:55 <mm_freak> MasseR: you can give the function call a name
06:12:05 <mm_freak> MasseR: let myTake = take 3
06:12:12 <saml> is there a way to turn haskell function to C shared library?
06:12:19 <zygoloid> mm_freak: i've generally found 'man zshall' pretty reasonable
06:12:28 <saml> i mean.. easy way. like in clojure, they have gen-class or something
06:12:35 <hpc> saml: it involves invoking the haskell runtime
06:12:37 <mm_freak> MasseR: but it doesn't really depend on the number of times the function is called, but rather on the number of times it's mentioned in the source code
06:12:39 <hpc> it would be difficult
06:12:51 <saml> hpc, why? can it be efficient binary?
06:12:52 <mm_freak> MasseR: if you mention it multiple times with the same arguments, give it a name, otherwise don't bother
06:12:57 <MasseR> mm_freak: Not applicable. fitness x = ...; for every generation run fitness function on every member
06:13:08 <saml> can you change backend so that intermediate language is C or something?
06:13:23 <Bynbo7> -fvia-C?
06:13:27 <MasseR> The member is random, but for the first 100 parts it's likely to be same
06:13:33 <hpc> saml: the via-C flag is deprecated, i thought
06:13:34 <MasseR> *times per generation
06:13:34 <mm_freak> pastorn: well, then i don't care…  use google
06:13:37 <saml> what's point of high level language when you cannot compile it to shared lib?
06:13:37 <mm_freak> your problem
06:14:26 <mm_freak> MasseR: then don't focus on the function call, but rather on the argument itself
06:14:32 <mm_freak> MasseR: make sure it uses sharing
06:15:24 <MasseR> "uses sharing"? I was thinking of having the the member remember their fitness. If there's mutation or mating, the fitness would be changed to something that dignifies that a new fitness must be calculated
06:15:38 <hpc> hmm, i might be wrong
06:15:44 <MasseR> But it requires a big refactoring, so I was wondering whether the compiler does something for me :P
06:15:50 <hpc> http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries <- talks about writing vim plugins, etc
06:15:51 <pastorn> mm_freak: zshall?
06:15:59 <pastorn> mm_freak: did you mean zsh ?
06:16:14 <hpc> zshall not pass!
06:16:15 <dafis> pastorn: zsh*all*
06:16:30 * pastorn doesn't get it :(
06:16:49 <dafis> pastorn: have you tried $ man zshall?
06:17:00 <pastorn> $ man zshall
06:17:01 <pastorn> No manual entry for zshall
06:17:02 <dafis> it's all zsh man pages glued together
06:17:11 <mm_freak> MasseR: GHC is very good at optimizing these things…  generally when you want to write well performing code, you should understand sharing well
06:17:13 <dafis> where it exists
06:17:22 <pastorn> and ubuntu doesn't give any recomended packages when i try to run it
06:17:26 <mm_freak> MasseR: http://haskell.org/haskellwiki/Sharing
06:17:35 <MasseR> mm_freak: Oh sharing really is a term. Could .. oh you did provide a link
06:18:03 <dafis> pastorn: Because  zsh  contains  many  features, the zsh manual has been split into a
06:18:04 <dafis>        number of sections.  This manual page includes all the separate manual pages
06:18:04 <dafis>        in the following order
06:18:45 <mm_freak> MasseR: yes, though unfortunately that page is not very comprehensive
06:18:48 <MasseR> mm_freak: not applicable :(. I can't create a let variable for every possible string combination :
06:18:51 <MasseR> :P
06:19:56 <pastorn> mm_freak: HOLY SH*T! 25000 lines!
06:20:06 <copumpkin> THAT'S OVER 9000!!!!11!!!!!
06:20:13 <wto> rofl
06:20:31 <mm_freak> pastorn: you get the point ;)
06:20:51 <mm_freak> MasseR: then really, don't care ;)
06:21:03 <mm_freak> MasseR: but the 'Performance' page on haskellwiki is an interesting read
06:21:29 <mm_freak> you may be interested in this subpage: http://haskell.org/haskellwiki/Performance/Strictness
06:21:36 <pastorn> mm_freak: ok, so my marker is at "zshzle" in the beginning of the file, how do i jump to its section?
06:22:45 * Wooga re-implementing lazyread using hGetContents :/
06:22:53 <MasseR> mm_freak: Altough I do have; let diffx = fitness x; Would this benefit from sharing?
06:23:21 <Wooga> isn't there any better way to perform lazy IO ?
06:24:26 <mm_freak> pastorn: enter
06:24:35 <Wooga> like directly specifying some "lazy" getLines ?
06:24:55 <mm_freak> MasseR: if you use diffx multiple times, yes
06:24:57 <Wooga> instead of reading result of hGetContents char-by-chat until encountering ''
06:25:00 <Wooga> '\n'*
06:25:07 <MasseR> mm_freak: Only once in the in block
06:25:19 <pastorn> mm_freak: nothing happends :(
06:25:22 <mm_freak> Wooga: well, the usual answer to this question is 'iteratees'
06:25:33 <Wooga> mm_freak: thanks
06:25:48 <mm_freak> pastorn: make sure you're looking at the texinfo page of zsh, not at the manpage
06:26:02 <mm_freak> if 'info' doesn't find a texinfo file, then it calls the manpage by the same name
06:26:03 <pastorn> mm_freak: i just ran "info zshall"
06:26:13 <mm_freak> pastorn: no, run "info zsh"
06:26:19 <pastorn> ah, says *manpage* at the top
06:26:37 <pastorn> same with zsh :(
06:26:57 * pastorn doesn't seem to have any of these magical texinfo pages
06:27:14 <mm_freak> pastorn: arch linux? ;)
06:27:37 <pastorn> mm_freak: lolbuntu 10.04
06:27:46 <mm_freak> Wooga: http://docs.yesodweb.com/blog/enumerators-tutorial-part-1/
06:28:06 <mm_freak> pastorn: you might need to install the texinfo files separately, because they are usually much larger than manpages
06:29:00 <pastorn> zsh-doc is 6 MB
06:29:06 <pastorn> this is insane
06:33:11 <mm_freak> sounds like HTML
06:33:22 <Wooga> more like pdf
06:33:36 <mm_freak> or both
06:53:13 * hackagebot Pathfinder 0.4.1 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.4.1 (GeorgeGiorgidze)
06:53:15 * hackagebot DSH 0.4.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.4.1 (GeorgeGiorgidze)
06:53:31 <kulakowski> I had a question about ghc 7. On the download page, there are two binary packages for OS X. The descriptions are identical. Is there any real difference?
06:56:40 <dafis> kulakowski: prepared by different people, perhaps they used different flags, but unlikely to make much of a difference
06:57:59 <dafis> you're talking of the two x86_64 binaries, I suppose
06:58:29 <kulakowski> Ah, yes.
07:01:25 <jonkri> mm_freak: hey, sorry i had to leave so abrupt yesterday. have you taken a look at the "unsafeInterleaveIO'd" writer monad?
07:01:26 <lambdabot> jonkri: You have 1 new message. '/msg lambdabot @messages' to read it.
07:01:29 <jonkri> ah
07:04:02 <mm_freak> =)
07:08:16 <jonkri> so to summarize the logging stuff for myself: a state monad is a good way to go to implement logging. if the program is concurrent, you have a separate thread that receives logging data through mvars or similar. if not, we can just log into the state of the same thread
07:08:49 <Wooga> isn't Writer is more like for logging?
07:09:21 <kfr> I would use neither for logging
07:09:25 <pastorn> @t runWriter
07:09:25 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:09:30 <kfr> I would just wrigte stuff to a file.
07:09:31 <pastorn> @type runWriter
07:09:32 <lambdabot> forall w a. Writer w a -> (a, w)
07:09:33 <kfr> Like, a log file.
07:10:04 <edwardk> preflex: xseen ddarius
07:10:05 <preflex>  ddarius was last seen on freenode/#haskell 7 hours, 36 minutes and 19 seconds ago, saying: Axman6: I presume you are already familiar with an assembly language.
07:10:10 <merijn> kfr: Yeah, but you probably want some sort of ordering in the writing to said logfile, hence something like the writer monad?
07:10:15 <pastorn> jonkri: each computation gives you a collection (monoid) of messages that gets put in a log
07:10:38 <merijn> jonkri: When using a separate thread I'd say it's more convenient to use a Chan then mvars
07:11:41 <kfr> merijn: Well, it's not like the order of IO is undetermined in Haskell now is it?
07:11:52 <kfr> When you do x >> y
07:12:04 <merijn> kfr: You are assuming you only want to log IO
07:12:23 <merijn> What if I want to log pure functions? The only IO would be the logging
07:13:15 <EvanR-work> log pure functions doesnt make sense
07:13:22 <EvanR-work> log what
07:13:34 <merijn> EvanR-work: Computational state?
07:13:35 <zygoloid> merijn: for debugging, use Debug.Trace.trace
07:13:41 <EvanR-work> there is no computational state
07:13:48 <EvanR-work> but yeah debug.trace is nice
07:13:53 <edwardk> clearly you should use a traced comonad ;)
07:13:57 <pastorn> EvanR-work: haven't you seen the n-queens solution with Writer?
07:14:05 <merijn> EvanR-work: So functions are now contextless? Anyway, I wasn't even the one asking >.>
07:14:11 <EvanR-work> they always have been
07:14:24 <EvanR-work> pastorn: no but sounds interesting
07:14:43 <merijn> jonkri: Anyway, come to think of it you might not need Writer in a threaded program
07:14:45 <pastorn> http://www.refactory.org/s/n_queens_problem_using_the_writer_monad/view/latest
07:15:09 <merijn> jonkri: I'd just use Control.Concurrent.Chan and have the log thread read from there and everyone else write to it
07:15:30 <merijn> EvanR-work: That's patently untrue. Functions have context
07:15:44 <EvanR-work> that would make them unpure
07:15:51 <merijn> EvanR-work: No it doesn't
07:16:01 <merijn> Or are you saying Haskell doesn't have pure closures?
07:16:04 <EvanR-work> k, terminology tarpit then
07:16:15 * edwardk just realized that every representable functor is a monad
07:16:17 <EvanR-work> ... pure closures?
07:16:18 <edwardk> (in Hask)
07:16:23 <merijn> free variables = context, no?
07:16:52 <EvanR-work> its equivalent to partial application
07:16:56 <EvanR-work> super combinators
07:16:57 <roconnor> edwardk: what is the relationship between representable functors and Yoneda?
07:17:27 <merijn> EvanR-work: Yes, but that does not make them context-less, and context doesn't affect purity if it is immutable
07:18:27 <merijn> Now maybe I'm using a weird connotation of context, but I've seen multiple type theory papers calling free variables of a function the "context"
07:18:57 <scooty-puff> can anyone think of a function that matches  Applicative m => m (a -> b -> c) -> m a -> m (a -> b) -> m c
07:19:13 <merijn> @hoogle Applicative m => m (a -> b -> c) -> m a -> m (a -> b) -> m c
07:19:13 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
07:19:13 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:19:13 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
07:19:14 <ddarius> merijn: The free variables of a term are usually contained in a context.
07:19:34 <edwardk> roconnor: they are relatively closely connected. see the wikipedia article, but in general, its an isomorphism between (x -> a) and f a — which if you write rep :: (x -> a) -> f a — you can see the signature of Yoneda
07:19:41 <EvanR-work> merijn: alright fine. call it a context.
07:20:03 <roconnor> @type \f a g -> f <*> a <*> (g <*> a)
07:20:04 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f (a -> a1) -> f b
07:20:13 <EvanR-work> but once you have a function value, that context might as well be part of the definition of the function
07:20:14 <edwardk> class Monad f => Representable x f | f -> x where rep :: (x -> a) -> f a; unrep :: f a -> x -> a
07:20:31 <edwardk> then you can make a class for finitely representable things
07:20:43 <edwardk> class Representable (Trie a) => HasTrie a where type Trie a :: * -> *
07:20:44 <merijn> EvanR-work: Sure, but you could still want to log those values
07:21:24 <edwardk> the monad comes from the obvious isomorphism to reader
07:21:41 <EvanR-work> logging implies explicit time of execution, and that really only occurs between IO operations. so might as well do it in the IO 
07:21:44 <roconnor> @type \f g a -> f <*> a <*> (g <*> a)
07:21:45 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f (a -> a1) -> f a -> f b
07:21:48 <merijn> EvanR-work: Example: multiplayer game server, I might want to log the info of non-IO things inside the game world. This is not IO and tracing is obviously not suited to this
07:21:50 <edwardk> so i suppose i should strengthen that to MonadReader x f => Representable x f
07:22:06 <EvanR-work> merijn: im not sure you really do want that
07:22:58 <EvanR-work> if the game is a semi infinite sequence of states, and you are rendering some of the states, and using each state to determine how to do IO, might as well do logging at that point
07:23:40 <merijn> I agree in principle, but I think in practice it could well be to annoying to extract the stuff you want to log from the IO action?
07:23:40 <pastorn> merijn: i'd have a thread which just reads from a Chan where you put all the messages
07:23:40 <EvanR-work> no reason to embed the logging code into the game evolution algorithm
07:24:04 <edwardk> roconnor: HasTrie gives a nice guide to constructing Representable functors
07:24:06 <EvanR-work> merijn: you mean extract the stuff you want to log from the game state
07:24:25 <EvanR-work> :: World -> IO ()
07:24:26 <merijn> pastorn: That's already what I recommended to the person that asked the original question, now I'm just arguing I think the other approach applies in some situations
07:24:31 <roconnor> edwardk: representable functors seem kinda boring
07:24:33 <EvanR-work> doesnt sound difficult, thats just a function of the game
07:24:43 <merijn> Anyhoo, I should probably stop arguing hypothetical situations and get back to work :>
07:25:32 <ddarius> Category theory is about representable functors.
07:25:44 <edwardk> roconnor: as they should be
07:25:56 <jonkri> so what is http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html used for?
07:26:05 <jonkri> how is it related to monads?
07:26:15 <EvanR-work> when you failed to write your code simply enough to verify yourself ;)
07:26:16 <pastorn> jonkri: that's used for caveman debugging
07:26:18 <edwardk> roconnor: but you can build lots of structure out of them
07:26:33 <jonkri> pastorn: caveman? isolated processes?
07:26:40 <pastorn> jonkri: lolz
07:26:45 <jonkri> (note to self: threads! in haskell, it's threads, not processes!)
07:26:47 <roconnor> @quote oasis
07:26:47 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:26:48 <pastorn> jonkri: for printing stuff to the terminal
07:26:53 <pastorn> @type trace
07:26:54 <lambdabot> Not in scope: `trace'
07:26:55 <EvanR-work> jonkri: prints out the value of an expression when its evaluatd
07:26:57 <pastorn> @hoogle trace
07:26:57 <lambdabot> Debug.Trace trace :: String -> a -> a
07:26:57 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
07:26:57 <lambdabot> module Debug.Trace
07:27:00 <scooty-puff> roconnor, thanks, just saw it
07:27:08 <jonkri> obliged
07:27:21 <hvr> pastorn: ..what's a better way to debug? ;)
07:27:22 <roconnor> scooty-puff: it is kinda like an S combinator on the applicive level
07:27:41 <roconnor> scooty-puff: which is ironic since `ap` is the S combinator for the reader monad.
07:27:56 <pastorn> hvr: i know none :D
07:28:00 <EvanR-work> hvr: dont make functions too large and complex that you cant immediately verify them by just testing some values
07:28:01 <roconnor> scooty-puff: so I was trying to see if I could compose the reader applicative with the f applicative to get it all on one go
07:28:07 <roconnor> scooty-puff: but I couldn't figure it out
07:28:40 <EvanR-work> hvr: beware of functions that may crash under some input
07:28:45 <EvanR-work> > head []
07:28:46 <lambdabot>   *Exception: Prelude.head: empty list
07:28:59 <EvanR-work> you need a proof that those inputs never occur
07:29:09 <roconnor> use listToMaybe instead of head, and use drop 1 instead of tail
07:29:10 <edwardk> typically i find i only need trace when i did a crappy job breaking down my combinators into easily testable parts
07:30:09 * roconnor notes that edward really breaks down his combinators
07:30:13 <roconnor> *edwardk
07:30:21 <edwardk> roconnor: =)
07:30:31 <edwardk> what, not everyone builds their types up from semigroupoid?
07:30:55 <EvanR-work> yeah its best to make your data structures impossible to represent invalid date ;)
07:31:02 <EvanR-work> data
07:31:12 <copumpkin> I agree
07:31:19 <roconnor> and then use total functions everywhere
07:31:24 <copumpkin> I agree
07:32:05 <roconnor> wow, that sums up a good chunk of typed functional programming style.
07:32:05 <edwardk> total functions ftw
07:32:28 <jix> writing tests for this will be fun... I'll just check that my IntSet works like container's IntSet :)
07:32:43 <Bynbo7> steal all their tests!
07:32:45 <copumpkin> jix: criterion benchmarks too!
07:32:55 <roconnor> jix: why test when you can prove. :P
07:33:03 <Bynbo7> jix: what're you working on?
07:33:07 <sjoerd_visscher> @type liftA3 (<*>)
07:33:08 <lambdabot> forall c a d (f :: * -> *). (Applicative f) => f (c -> a -> d) -> f (c -> a) -> f c -> f d
07:33:32 <Saizan> edwardk: i have a question about kata!
07:33:40 <jix> Bynbo7: an IntSet supporting map (+n) someSet in O(1) combined with efficient union
07:33:55 <Bynbo7> nice
07:34:04 <copumpkin> jix: a rewrite rule for map (+n) and map (n+)! :P
07:34:20 <edwardk> to the #kata cave!
07:34:31 <copumpkin> jix: however it isn't quite as asymptotically efficient as an IntSet due to it no longer being a trie, right?
07:34:32 <jix> copumpkin: heh... but it would be a _huge_ performance hit if it doesn't triggers
07:34:37 <djahandarie> How do you define a coslice category in terms of a slice category?
07:34:45 <copumpkin> jix: pff
07:34:49 <djahandarie> Just A/C = C^op/A ?
07:35:03 <ddarius> That should work.
07:35:18 <jix> copumpkin: well for union IntSet states O(n+m)... finger trees are better than that
07:35:35 <copumpkin> jix: yeah, I meant for lookup and insertion
07:35:52 <djahandarie> Cool
07:36:06 <jix> copumpkin: yeah I'm not O(1) there as I don't use the fact that Int has a limited amount of bits
07:36:18 <copumpkin> yeah
07:36:37 * djahandarie wonders what the #kata cave is
07:36:59 <Bynbo7> jix: can you only store maxBound :: Int - minBound :: Int numbers?
07:37:01 <copumpkin> you should follow us there
07:37:12 <djahandarie> I was told not to follow strangers!
07:37:16 <djahandarie> This is very shady...
07:37:38 <jix> Bynbo7: ?
07:38:07 <Bynbo7> i was thinking there'sa way you could fudge it being O(1) because it has a bounded size, so all operations would have a bounded time :P
07:39:17 <jix> Bynbo7: ;) yeah but I won't get down to IntSet's constant factor then
07:39:36 <Bynbo7> details!
07:40:05 <Bynbo7> haven't you ever done an algorithms couse? constants don't matter!
07:40:19 <jix> also I could generalize this to work for all linearly-ordered abelian? groups
07:40:24 * ddarius is pretty sure algorithms courses don't say that.
07:40:47 <jix> They say constants do matter! but eh let's forget them...
07:42:17 <EvanR-work> you only have 4G of ram, all operations are O(1)
07:42:27 <EvanR-work> for some large value of 1
07:42:30 <kfr> What is a total function in the context of Haskell?
07:42:48 <kfr> One that does not throw exceptions and always halts?
07:43:08 <Bynbo7> i don;t think it has to halt
07:43:14 <doserj> it has
07:43:22 <dschoepe> Bynbo7: if it didn't, it would be the same as using undefined
07:43:23 <EvanR-work> that it never produces _|_?
07:43:46 <Bynbo7> ah fair enough, I've never heard a definition of what a total function was
07:44:01 <doserj> although lazyness makes the notion of "halting" more interesting
07:44:21 <ddarius> doserj: Not really.
07:44:43 <EvanR-work> Bynbo7: when you evaluate an application it can produce a value or _|_, i think
07:44:47 <dschoepe> I think it just makes several non-halting functions more useful
07:45:05 <EvanR-work> _|_ is usually bad ;)
07:45:13 <dolio> In (typical) set theory, where you define functions as relations, total functions are ones for which the relation has a pair (x,y) for every x in the domain, while a partial function may not.
07:46:13 <quicksilver> well, non-strict evaluation means that you can have f(x) = _|_ but g(f(x)) /= _|_
07:46:31 <ddarius> dolio: Applying that to the functions used in domain theory gives the wrong result; however, for domain theory a total function is one that never returns bottom.
07:46:48 <quicksilver> (of course, just replace 'f(x)' with y for a simpler statement but the functions gives a better intuition to doserj's remark)
07:49:35 <Maxdamantus> @pl \a b -> a:b:[]
07:49:35 <lambdabot> (. return) . (:)
07:50:19 <dolio> Yes, I suppose to group the two under one definition, you'd have to say something like, "a total function is one for which every point of the domain has a well-defined result."
07:50:32 <dolio> Where "well-defined" means something different in each case.
07:50:58 <EvanR-work> class WellDefined 
07:51:01 <djahandarie> Which really doesn't say much does it
07:51:12 <djahandarie> Except that a total function is some property relating to the domain
07:51:49 <EvanR-work> _|_ is not a well defined result?
07:51:52 <EvanR-work> ;)
07:52:58 <Maxdamantus> @pl \a -> foldr showHex "" . map fromIntegral . concat . map ((\(a, b) -> [a, b]) . (`divMod` 16)) . toOctets $ sha512Ascii a
07:52:58 <lambdabot> foldr showHex [] . map fromIntegral . join . map (ap (:) return . snd . (`divMod` 16)) . toOctets . sha512Ascii
07:53:14 <mm_freak> how can i write record fields in GADT notation?
07:53:17 <Maxdamantus> Hm .. :\
07:53:49 <EvanR-work> Maxdamantus: yeah its almost already pl
07:54:08 <Maxdamantus> I know.
07:54:33 * Maxdamantus wonders if there's some nice fixed-width version of showHex.
07:54:34 <ddarius> concatMap
07:55:05 <ddarius> And you may as well move the fromIntegral inside the first map.
07:55:59 <Maxdamantus> If there's a fixed-width showHex I can get rid of the concat :(
07:56:29 <Bynbo7> printf "%02x"
07:56:34 <ddarius> @hoogle showIntAtBase
07:56:35 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
07:56:36 <Maxdamantus> Eugh.
07:56:54 <Bynbo7> > map (printf "%02x") [1..16]
07:56:55 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:56:55 <lambdabot>    `Text.Printf.PrintfType ...
07:57:00 <Bynbo7> > map (printf "%02x") [1..16] :: [String]
07:57:01 <lambdabot>   ["01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f"...
07:57:03 <Maxdamantus> showIntAtBase doesn't do it, afaics
07:57:13 <ddarius> No, it doesn't.
07:57:22 <Bynbo7> > map (printf "%02x" . (2^)) [1..16] :: [String]
07:57:24 <lambdabot>   ["02","04","08","10","20","40","80","100","200","400","800","1000","2000","...
07:57:26 <tromp_> :t fold
07:57:27 <lambdabot> Not in scope: `fold'
07:57:32 <tromp_> :t foldl
07:57:33 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:57:38 <astroboy> How can I get the value of a define from a C lib?
07:57:49 <ddarius> Use CPP.
07:59:29 <astroboy> ddarius: what is that?
07:59:52 <dafis> astroboy: preprocessor
08:00:07 <Maxdamantus> C Preprocessor
08:01:25 <astroboy> so... I know how to call C functions
08:01:31 * hackagebot Pathfinder 0.4.2 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.4.2 (GeorgeGiorgidze)
08:01:44 <astroboy> but let's say I want to get #define foo 0 from lib.h
08:02:32 * hackagebot DSH 0.4.2 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.4.2 (GeorgeGiorgidze)
08:04:47 <dafis> astroboy: #include "lib.h"; val = foo -- defines val as the macro foo
08:13:18 <astroboy> dafis: thanks
08:21:01 <djahandarie> @djinn (Not a, Not b) -> Not (Either a b)
08:21:01 <lambdabot> f (a, b) c =
08:21:01 <lambdabot>     case c of
08:21:01 <lambdabot>     Left d -> a d
08:21:01 <lambdabot>     Right e -> b e
08:22:25 <mm_freak> @src Not
08:22:25 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:22:32 <djahandarie> type Not x = (forall a. x -> a)
08:23:18 <mm_freak> (,) means 'and', right?
08:23:30 <kfr> So hmm I'm currently writing a small web dev framework in Haskell and I was wondering about how I should deal with handling the requests. In general the request handlers can't have a simple signature like handler :: Arguments -> ByteString because you might want to have IO and a State monad in there, right? So what you should basically use is a monad transformer from which you extend the stuff in in your handlers? And if you don't want to use it, you use Iden
08:23:31 <kfr> tity, if you want to use it, you add your own monads to that stack, right?
08:23:57 <maxJadi> Any idea how I can define two dimension list in haskell ? (Something "list a [][]"  in java) ?
08:24:06 <kfr> [[a]]
08:24:48 <djahandarie> mm_freak, yep
08:24:50 <mm_freak> kfr: in yesod a request handler is just a monad
08:25:07 <kfr> Snap had this SnapExtend m a thing for that
08:25:23 <mm_freak> i think that's true for virtually all web frameworks in haskell
08:25:24 <kfr> And now I finally get why
08:25:37 <djahandarie> A proof A & B is the same as both proof A and be B being provided, i.e., (A,B)
08:25:37 <kfr> Now that I've actually dealt with all the fundamental monads
08:25:40 <copumpkin> maxJadi: [[a]] ?
08:25:51 <copumpkin> maxJadi: a list of lists
08:26:49 <djahandarie> Hom(X x Y, Z) is isomorphic to Hom(X, Z^Y), in other terms
08:26:54 <djahandarie> i.e., currying
08:27:38 <maxJadi> Yap thanks :)
08:28:03 <maxJadi> copumpkin, Yap thanks :)
08:28:48 <djahandarie> nb: that only holds in CCC ;)
08:29:09 <Veinor> djahandarie: so not in NF!
08:29:10 <merijn> maxJadi: It's good to remember that the a in "[a]" (and other type signatures) means ANY type can go into it. [a] is just another type :)
08:30:22 <djahandarie> Who cares about NF!
08:30:41 <Maxdamantus> Hm .. why are there so many ByteString types .. ? is there something to convert between them or something?
08:30:50 <djahandarie> I like my set theories to be toposes
08:30:58 * ddarius doesn't see what the adjunction defining exponents has to do with most of what djahandarie said.
08:31:28 <merijn> I like my set theories like I like my women! :>
08:31:43 <merijn> (Inconsistent and incomprehensible)
08:32:27 <djahandarie> ddarius, not much actually, no clue why I mentioned it now
08:32:53 <kulakowski> merijn: ha
08:33:01 <djahandarie> Semi-related I suppose
08:33:24 <merijn> I'm thoroughly disappointed in Haskell that I only got one "ha" from that :<
08:33:46 <mm_freak> wikipedia states: "The empty set is the unique initial object in the category of sets"…  why is that?  what would be the only possible morphism from the empty set to ℕ?
08:33:49 <ddarius> Why would you want your women to inconsistent and incomprehensible?
08:33:50 <Veinor> merijn: haha
08:34:07 <ddarius> mm_freak: The empty function.
08:34:17 <merijn> ddarius: All the others appear to be corpses or under the age of 8 :p
08:34:17 <Veinor> yeah, the empty function
08:34:41 <mm_freak> ddarius: what about the infinite number of constant functions?  are you saying that they are all equivalent to the empty function?
08:34:44 <idnar> > foldr f 0 [x, y, z]
08:34:44 <lambdabot>   Ambiguous type variable `b' in the constraints:
08:34:45 <lambdabot>    `SimpleReflect.FromExpr ...
08:34:59 <ddarius> mm_freak: They don't have domain {}.
08:35:18 <djahandarie> > foldr f 0 [x, y, z] :: Expr
08:35:19 <lambdabot>   f x (f y (f z 0))
08:35:36 <ddarius> mm_freak: A function in set theory from A to B is a subset of the cartesian product AxB.  If A is {}, then AxB is {}.
08:35:50 <mm_freak> ddarius: ah, makes sense
08:35:51 <mm_freak> thanks
08:36:06 <mm_freak> well, one question remains…
08:36:22 <djahandarie> Does function usually mean total function or just function (total or partial)?
08:36:35 <copumpkin> mm_freak: if you had a data type T with no constructors, how many functions T -> Int could you write?
08:36:37 <mm_freak> constOne _ = 1; constTwo _ = 2  -- those are the same functions, when the domain is {}, right?
08:36:47 <ddarius> djahandarie: It depends on the context.  But, in a mathematical context it almost universally means total function.
08:37:03 <ddarius> mm_freak: They aren't functions with domain {}.
08:37:29 <copumpkin> mm_freak: assuming no undefined, that is
08:37:30 <jonkri> using emacs: if i write a function type definition, is there then a short to have the function name printed again (to start defining the function)?
08:37:39 <mm_freak> ddarius: disregard bottom
08:37:47 <copumpkin> mm_freak: you aren't
08:37:57 <copumpkin> mm_freak: what values could your _ take?
08:38:18 <mm_freak> copumpkin: i'm disregarding bottom, so there are no values _ may take
08:38:34 <copumpkin> so you have a function from nothing to something?
08:38:36 <mm_freak> i'm in Set, not in Hask, so it's just pseudocode
08:38:44 <stianhj> jonkri, just press tab twice on the next line
08:38:50 <mm_freak> copumpkin: yes
08:39:03 <stianhj> jonkri, if you're using haskell-mode that is
08:39:11 <jonkri> stianhj: already tried that, it doesn't work :S i do use haskell-mode
08:39:15 <copumpkin> mm_freak: it doesn't "make sense" to do that
08:39:30 <copumpkin> mm_freak: you're treating the domain as if it had a value by even putting that _ for it
08:39:32 <jonkri> maybe some mode isn't activated...
08:39:39 <mm_freak> copumpkin: i see
08:39:51 <dolio> constOne and constTwo are both valid functions from _|_ to Nat in Agda.
08:39:52 <dafis> Maxdamantus: there are only two ByteString types, strict and lazy
08:40:00 <jonkri> i have doc-mode and indentation-mode
08:40:16 <dafis> ther .Char8 modules just offer a different interface to them
08:40:21 <mm_freak> copumpkin: maybe i shouldn't think in haskell, but in set theory
08:40:28 <dolio> And they are extensionally equal, although you can't prove their equality in Agda.
08:40:36 <stianhj> jonkri, add (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) to your .emacs
08:40:40 <mm_freak> {}xB = {}, as ddarius said
08:40:45 <djahandarie> Why can't you prove it in Agda?
08:41:00 <dolio> Because equality is intensional in Agda.
08:41:12 <stianhj> jonkri, and which version are you using?
08:41:40 <mm_freak> stianhj, jonkri: no need to edit .emacs…  you can easily configure everything using (customize-group haskell)
08:41:50 <mm_freak> at least with the latest haskell-mode
08:42:01 <dolio> So two functions are only provably equal if their definitions are convertable.
08:42:24 <ddarius> mm_freak: If you consider what {}xB = {}, you should be running into another problem.
08:42:33 <ddarius> +implies
08:42:34 <dolio> Possibly with the aid of induction on some non-function types.
08:42:45 <Saizan> Void should have some "eta-rules" too.
08:43:12 <Saizan> (in the "i think it'd make more sense" sense)
08:43:17 <mm_freak> ddarius: could you give me a hint?
08:43:28 <djahandarie> Why would you need induction on non-function types? If the type is inductive?
08:43:29 <dolio> You could, however, prove them equivalent under the relation (forall x -> f x == g x).
08:44:28 <ddarius> dolio: Trivially...
08:44:46 <dolio> djahandarie: I mean, you could (I think) prove 'forall k -> (\n -> n + (k + 0)) == (\n -> n + k)' even though those two functions are not directly convertable as written.
08:45:08 <dolio> You could prove it by proving that k + 0 = k via induction on k.
08:45:32 <djahandarie> I see
08:47:35 <ddarius> mm_freak: Actually, I guess it's an issue that comes up for any non-surjective function and is somewhat minor and technical anyway.
08:47:55 <dolio> If k were any particular value, like '2', it would reduce on its own. But k + 0 does not automatically reduce to k, because + is defined by recursion on the first argument.
08:48:51 <copumpkin> unless you define + by recursion on its second argument :P
08:49:10 <dolio> Sure, but then you can rearrange to get the same problem.
08:49:13 <copumpkin> or an ugly + that recurses on both :o
08:49:26 <djahandarie> How about a + that recurses on neither and just disregards one entirely
08:49:41 <dolio> That wouldn't be +, presumably.
08:49:48 <djahandarie> :
08:49:49 <djahandarie> P
08:52:20 <mm_freak> ddarius: isn't every function in {}xB non-surjective?
08:52:38 <ddarius> Except for B = {}, yes.
08:53:17 <mm_freak> does the function in {}x{} even have that property?
08:53:59 <dolio> For all 0 elements of the codomain, ...
08:54:02 <ddarius> Surjection is forall y. exists x. f x = y so it holds vacuously if the codomain is empty.
08:54:23 <mm_freak> i see
08:54:34 <mm_freak> but i don't see the problem
08:54:51 <Veinor> or, if you think about it in terms of morphisms, every arrow into {} is epic :)
08:55:24 <ddarius> mm_freak: What's your definition of "function" in set theory?
08:57:53 <mm_freak> ddarius: a function from A to B is a subset of A×B
08:58:23 <mm_freak> well, almost
08:59:04 <copumpkin> (such that you have a fundep a -> b :P)
08:59:42 <copumpkin> (and you'd want to keep the sets around too, just in case)
09:00:23 <mm_freak> a function f from A to B is a subset of A×B such that for every element x ∈ A there exists exactly one element y ∈ B
09:00:50 <ddarius> mm_freak: Now what are the arrows of the category of sets?
09:01:28 <mm_freak> ddarius: subsets of products
09:03:27 <ddarius> mm_freak: copumpkin is a bit more careful than you.  Categorical arrows have the operations dom and cod defined for them (if for no other reason than to define "composable pair of arrows".)
09:09:39 * mux has more and more fun with type families, discovering that from the 4 different ways to define type-level addition emerges as many different recursion schemes at the value level
09:09:50 <mux> I already need 3 of those "recursion schemes"
09:10:00 <mm_freak> ddarius: being more precise, in the category of sets an arrow f : A → B is a function relation A×B
09:10:21 <kfr> Unicode :D
09:10:44 <mm_freak> ddarius: but i guess that's not what you're getting at
09:10:46 <kfr> mm_freak oh I just realised that this basically forces the entire server to be polymorphic, right?
09:11:01 <mm_freak> kfr: ?
09:11:30 <kfr> Since it has to operate on a particular monad, specified by the user of the framework hmm
09:12:38 <mm_freak> kfr: ah, you're talking about your web framework…  well, you can implement it as a monad transformer the way happstack does
09:13:39 <mm_freak> that allows you to run the entire server in a certain user-defined monad transformer, but it kills concurrency, unless you generalize concurrency to arbitrary monads
09:14:55 <kfr> Oh, because forkIO requires a transfer of the environment, which is specific to a monad?
09:15:01 <mm_freak> yes
09:15:02 <mux> reverse :: Vec n a -> Vec (n :^: Z) a
09:15:04 <mux> :D
09:15:10 <kfr> I wrote some stuff for ReaderT and StateT for that purpose because I encountered that problem already
09:15:13 <mux> :^: is just some kind of +
09:15:34 <kfr> mm_freak isn't there some way to do it for arbitrary monads really?
09:15:42 <mm_freak> kfr: you don't need to reinvent the wheel…  there are ready-made libraries for that purpose
09:15:53 <mm_freak> no, there isn't
09:16:11 <kfr> Right, because not all of them even let you retrieve the environment, right
09:16:18 <kfr> So you couldn't pass it on anyways
09:16:21 <kfr> Even if you knew how
09:16:26 <mm_freak> because it doesn't even make sense for some monads
09:16:35 <copumpkin> mux: you can write that without the :^: Z and a foldl
09:16:47 <kfr> Somebody told me there's a library which deals with the forkIO issue
09:16:49 <dolio> mm_freak: A lot of times, morphisms in Set are defined to be (A, f, B), where f is a (total) functional relation on A and B.
09:16:52 <mux> copumpkin: no I can't, it doesn't type-check in that case
09:16:53 <kfr> I already forgot its name though
09:17:00 <dolio> Or something similar. Often not just f.
09:17:02 <copumpkin> mux: it's tricky, but it's possible
09:17:35 <copumpkin> http://hpaste.org/41453/foldl_on_vec
09:18:05 <mm_freak> kfr: http://hackage.haskell.org/package/forkable-monad
09:18:26 <magicman> Will I break my setup when I do "cabal install Cabal"? It's only trying to update "base" that's a Bad Idea, right?
09:18:28 <kfr> Downloading
09:18:32 <dolio> You can get rid of A, because it's equal to {x | (x,y) \in f } provided f is total.
09:18:48 <kfr> Although that is not the one that was first linked to me hmm
09:19:03 <mux> copumpkin: mmm, looks nice
09:19:21 <mm_freak> kfr: but 'forkable-monad' is rather incomplete…  if you don't mind an extra type parameter you can use my variant:  http://hackage.haskell.org/packages/archive/contstuff/1.2.4/doc/html/Control-ContStuff-Classes.html#g:5
09:19:23 <dolio> However, f on its own does not determine B, unless f is surjective.
09:19:23 <kfr> Heh it's very short
09:19:33 <kfr> mm_freak is ContStuff yours?
09:19:52 <mm_freak> kfr: yes
09:20:01 <copumpkin> mux: there's more here: http://hpaste.org/41479/more_vec_crap
09:20:13 <mm_freak> so far nobody sent me a patch, so yes, it's mine yet =)
09:20:55 <copumpkin> mux: there's a cleaner transpose possible, but I didn't know that at the time
09:21:17 <mux> copumpkin: nice! this is what I have now: https://bitbucket.org/mumux/stuff/src/ff1a34a2934a/Vector.hs
09:21:17 <dolio> I think Cale once gave a definition of arrows in Set where you could get rid of B, but not A, but I forget what it was.
09:22:22 <mm_freak> dolio: i get that, but i don't get ddarius' point
09:22:33 <kulakowski> dolio: Yeah, I was just typing up something about that. Fun exercise: I give you a bunch of arrows and tell you which ones compose (and I suppose a promise that they really do form a category), and you tell me what you can about the objects.
09:22:41 <copumpkin> mux: ah nice, you have the clean transpose via Traversable :)
09:23:31 <copumpkin> mux: your type for take is wrong
09:23:46 <mux> copumpkin: yeah I guess that's why it's commented out, it won't compile
09:23:47 <copumpkin> if you want that type you need something like a BoundedVec
09:23:50 <mux> but I was looking at other things
09:24:18 <mux> copumpkin: do you know of a way I could define interlave without adding a new type family as explained in the big comment above?
09:24:24 <copumpkin> you want take :: n -> Vec (n :+: m) a -> Vec n a
09:24:34 <dolio> mm_freak: I'm not sure what he was getting at, either.
09:24:41 <copumpkin> but you're going to want more information about n and m there
09:25:45 <kulakowski> mm_freak: I think he meant that you don't just need a pile of arrows, you also need the data about which compose. One way to do that is to tag each arrow with its source and target.
09:26:00 <kulakowski> And implicitly that your definition didn't include that data.
09:26:08 <copumpkin> mux: nah, I think that's a fairly clean way of doing it, if you can translate from x :!: y to x :+: y and back again (but that'd probably be quite tricky and would require some proving)
09:26:32 <mm_freak> kulakowski: got that, too, but he mentioned a technical problem with {}xB = {}
09:27:42 <ddarius> mm_freak: It's a problem with all non-surjective functions (with the typical definition of function.)  It's just particularly extreme in that case.
09:28:01 <ddarius> Hom({}, B) = {{}} = Hom({}, C) forall all B and C.
09:29:31 <mm_freak> ddarius: yeah, i saw that, but why exactly is that a problem?  different arrows have the same meaning?
09:29:35 <djahandarie> copumpkin, I swear to god we had a nicer reverse definition at one point
09:30:11 <copumpkin> djahandarie: hm! :P
09:30:20 <ddarius> How do you define cod({}) to be different from cod({})?
09:30:24 <jonrafkind>  what does this error mean? Module 'Control.Exception' does not export 'Exception(ExitException)' ?
09:30:24 <copumpkin> in agda I don't need that newtype crap
09:30:36 <mm_freak> ddarius: ah, now i see it
09:30:59 <djahandarie> copumpkin, I've searched for the hpaste where I think you wrote it but I can't find the paste at all
09:31:06 <copumpkin> djahandarie: but I don't see how it'd be possible without the newtype
09:31:16 <copumpkin> of course, I may be dumber than myself, if I wrote something more clever before
09:31:27 <mm_freak> ddarius: but in CT do we even talk about {}?  i think we talk about {} : A → B
09:31:34 <dolio> kulakowski: Back in his thesis, Lawvere actually formulated category theory with just a pile of arrows. :)
09:31:42 <ddarius> mm_freak: You have to define what the arrows are.
09:31:50 <djahandarie> copumpkin, it was in response to http://hpaste.org/41413/lol
09:32:08 <dolio> There are no objects, just identity arrows (which are in correspondence with objects in the more standard formulation these days).
09:32:14 <mm_freak> ddarius: so an arrow is only complete with its domain, codomain and the corresponding relation?
09:32:17 <djahandarie> copumpkin, actually, maybe not
09:32:22 * djahandarie is perhaps misremembering
09:32:53 <ddarius> mm_freak: You have to define cod and dom as well (as well as id and ∘.)
09:33:02 <djahandarie> But that paste definitely exists somewhere and I'm not sure where it went
09:33:10 <copumpkin> lol
09:33:11 <kfr> mm_freak that's an impressive amount of comments in that first one btw
09:33:22 <kfr> It's like 20 lines of code vs. 80 lines of comments :p
09:33:26 <dolio> Of course, you still can't just use set-functions as arrows, then.
09:33:31 <mm_freak> kfr: hehe, but that's good
09:33:39 <copumpkin> djahandarie: sure it isn't the one I linked to before? it's one day later
09:33:44 <mm_freak> kfr: many libraries on hackage are poorly commented
09:34:03 <ddarius> dolio: I don't see any value in the "arrows only" perspective of category theory.  Objects are much clearer and cleaner.  The "arrows only" way looks pretty ad-hoc and isn't "deep" at all.
09:34:13 <djahandarie> copumpkin, hmm... it had some stuff where you were doing neat stuff with rank-2 types also
09:34:23 <copumpkin> :O
09:34:42 <mm_freak> kfr: note btw that haddock is usually not just some API documenter…  it's perfectly valid to write an entire handbook using haddock
09:35:23 <dolio> ddarius: It unifies a few things. But it isn't a big deal. And I gather it isn't as pleasant to actually work with.
09:36:12 <mm_freak> ddarius: an arrow is (A, B, f) where f is a function from set A to set B, then dom((A, B, f)) = A and cod((A, B, f)) = B
09:36:16 <mm_freak> ddarius: is that reasonable?
09:36:24 <monochrom> objects almost don't do anything. they're there just for type-checking of arrow composition etc.
09:36:35 <ddarius> Yes, that's usually how it's defined if people care to be that precise.
09:37:03 <ddarius> dolio: It doesn't really unify them though.  You end up having to talk about arrows with the "identity property" and making a lot of use of the partiality of ∘ to define what that means.
09:38:35 <dolio> ddarius: Yes, defining composition as a partial operation like that is ugly.
09:39:01 <jonkri> can someone please give me a simple and plain english explanation on how i should interpret "a" in "runAppT :: MonadIO m => AppT m a -> m a", and what that function would be doing? (type AppT = StateT LogConfig) :P
09:39:32 <dolio> What I mean is, "functors take objects to objects and identities to identities" is rendered redundant.
09:39:39 <dolio> That says the same thing.
09:39:45 <ddarius> True.
09:40:00 <ddarius> But you would need to show that functors preserve the "identity property"
09:40:29 <dolio> And "a subobject is a monomorphism" is minorly less weird if objects are already morphisms.
09:40:33 <Bynbo7> jonkri: if you have something of type AppT IO Int, then runAppT will take that, and give you back an IO Int action
09:40:37 <mm_freak> ddarius: ok, thanks
09:41:55 <dolio> Of course, those are my only two examples, and I don't think they counteract the ugliness of defining composition the bad way.
09:44:41 <dolio> Saying that composition has a type like {A B C: Obj} -> Hom(A,B) x Hom(B,C) -> Hom(A,C) is miles ahead of saying it's a partial function Arr x Arr -> Arr.
09:46:59 <RichardBarrell> dolio: um, isn't the definition of Arrow that composition is a *total* function Arrow a b -> Arrow b c -> Arrow a c?
09:47:33 <dolio> RichardBarrell: Some presentations of category theory don't do it that way.
09:48:13 <dolio> They say it's a partial function Arr x Arr -> Arr, where Arr is the collection of all arrows of the category.
09:48:36 <dolio> And it's defined at (f, g) exactly when cod f = dom g.
09:49:55 <Maxdamantus> @pl \n -> foo n >>= putStrLn
09:49:56 <lambdabot> (putStrLn =<<) . foo
09:50:48 <doserj> foo >=> putStrLn
09:51:21 <dolio> Oh, I thought of one more nice thing it does: monoids determine a single category, where the arrows are the elements of the monoid, rather than infinitely many categories, where there is a single arbitrary object M, and there is an arrow with type M -> M for each element of the monoid.
09:53:04 <RichardBarrell> dolio: is that analogy the place where the typeclass's name "Monoid" comes from in the first place?
09:54:03 <dolio> Eh? Monoids come from regular old abstract algebra.
09:55:04 <RichardBarrell> Oh. Yes.
09:55:04 <copumpkin> Dioids are cool too!
09:55:16 * dolio goes to grab some lunch.
09:55:21 <jmcarthur> i am not familiar with dioids
09:55:39 <copumpkin> jmcarthur: it's a name for an idempotent semiring
09:55:43 <RichardBarrell> copumpkin: what's that typeclass look like?
09:56:23 <copumpkin> it has +, *, one, zero, 
09:56:25 <copumpkin> and some properties
09:56:28 <doserj> copumpkin: like the tropical rings?
09:56:30 <RichardBarrell> Ah, so it's like a semiring instead of like a semigroup.
09:56:35 <copumpkin> doserj:yeah
09:56:57 <jacobian> What's the right way to go from Maybe a -> Error a 
09:56:59 <copumpkin> which are actually used in viterbi or other belief propagation instantiations
09:58:40 <jonrafkind> does controll.exception still throw ExitException? Or was it renamed to ExitCode?
09:59:49 <copumpkin> anyone feel like making me a nice dependent language with extensible records?
09:59:55 <copumpkin> I'd love to experiment with it
10:00:28 <ddarius> copumpkin: Can't you just encode extensible records?
10:01:07 <copumpkin> ddarius: yeah, but it gets pretty ugly :/ I started doing that a while back for a "universal algebra" module in agda, but started ripping my hair out
10:01:40 <RichardBarrell> copumpkin: Get an assistant. Rip their hair out instead.
10:01:57 <copumpkin> RichardBarrell: I'd love to have an assistant (or multiple minions to write code for me)
10:04:02 <roconnor> copumpkin: are you edwardk's minion?
10:04:13 <copumpkin> roconnor: sometimes :P but only voluntarily
10:04:23 <copumpkin> I like to tell myself that, anyway
10:07:25 <copumpkin> preflex: seen chrisdone
10:07:26 <preflex>  chrisdone was last seen on #haskell 21 hours, 57 minutes and 44 seconds ago, saying: My crappy internet went off. Did anyone answer my cry for help or did it bathe in silence as per?
10:08:00 <copumpkin> @ask chrisdone any idea why hpaste sometimes goes into "bad gateway" mode? 
10:08:00 <lambdabot> Consider it noted.
10:09:21 <pozic> Do we even have just one dependent programming language in which all of the rules are layed out in simple to understand language (next to the symbolic language (which sometimes is wrong))? 
10:10:55 <c_wraith> copumpkin: usually that means the server crashed.
10:12:40 <luite> I think he uses fastcgi, and the error means that the web server couldn't contact the fastcgi daemon
10:16:05 <monochrom> wild conjecture: the haskell program behind hpaste dies of "invalid argument (Invalid or incomplete multibyte or wide character)"
10:17:27 <djahandarie> lol
10:19:52 <Dae> Hey
10:20:02 <djahandarie> Hey!
10:20:42 <Dae> I have a cabal problem. I'm trying to install hmatrix. it gave me an ExitFailure 1 when doing "cabal install hmatrix"
10:20:49 <aristid> monochrom: wouldn't the obvious solution be a restarter script that always restarts the program when it crashes?
10:21:21 <Dae> when I tried to install it manually, it keep complaining that I don't have storable-complex, but cabal install claims I do....
10:21:24 <djahandarie> s/solution/hack/
10:22:07 <luite> aristid: most fastcgi implementations already do that, but not always for the same request
10:22:07 <Dae> sorry, what?
10:22:21 * djahandarie was talking to aristid
10:22:42 <Dae> ohh, sorry, my bad
10:22:50 <aristid> djahandarie: well, people ARE promoting crash-only as a valid methodology :D
10:23:18 <djahandarie> Dae, is it complaining about profiling libs? Do the version line up?
10:23:24 <djahandarie> Could http://hpaste.org some output for us
10:23:29 <djahandarie> ... if it's up right now
10:23:34 <djahandarie> Which it isn't
10:23:43 <djahandarie> http://pastebin.com some output instead :P
10:24:09 <aristid> luite: nginx does not automatically restart fastcgi programs
10:24:18 <aristid> luite: and hpaste.org uses nginx
10:25:04 <Dae> djahandarie, pastebin.com/LMdKiNUe
10:25:07 <djahandarie> Why doesn't it just use snap or something
10:25:23 <Dae> djahandarie, http://pastebin.com/LMdKiNUe
10:25:41 <aristid> djahandarie: it could even use snap behind nginx, with a reverse proxy
10:25:48 <djahandarie> Dae, how about just cabal install, (if you can)
10:25:53 <Bynbo7> or just snap directly :\
10:26:24 <aristid> Bynbo7: well, with a reverse proxy you don't need to place it in /
10:26:57 <Dae> djahandarie, http://pastebin.com/Vz75Dh6
10:27:03 <dafis> Dae: if you try to install manually, I suppose it's runhaskell ./Setup.hs command? That tries a global install by default, and if you cabal installed storable-complex, that'll be a user install, so it's not available for global installs; you could try runhaskell ./Setup.hs configure --user
10:27:19 <aristid> dafis: unknown paste id
10:27:19 <aristid> argh, i mean Dae
10:28:14 <Dae> sorry, http://pastebin.com/Vz75Dh6p
10:30:09 <dafis> Dae: in the hmatrix directory, try cabal clean && cabl install --no package name
10:30:16 <monochrom> "Setup.lhs" defaults to "global" install. "cabal install" defaults to "user" install. see my http://www.vex.net/~trebla/haskell/sicp.xhtml for what this means.
10:30:23 <dafis> cabal install*
10:30:41 <luite> aristid: ah I see
10:30:58 <monochrom> in particular, when doing "global" install, "user"-installed packages are invisible.
10:32:00 <Dae> dafis, same output as cabal install hmatrix
10:32:15 <interferon> what's the best way to get an overview of how GHC works? the entries on the GHC wiki?
10:32:19 <Dae> monochrom, I see. The configure part works when I add --user
10:32:31 <dafis> Dae: and runhaskell ./Setup.hs configure --user?
10:32:58 <dafis> Dae: in case of install failure, rerun with -v and paste the output
10:33:47 <monochrom> it's probably very confusing to do "cabal install hmatrix" right inside an hmatrix source tree
10:34:20 <Dae> dafis, http://pastebin.com/tpVdDJFB
10:34:34 * hackagebot hmatrix-mmap 0.0.3 - Memory map Vector from disk into memory efficiently  http://hackage.haskell.org/package/hmatrix-mmap-0.0.3 (AlanFalloon)
10:36:04 <Dae> monochrom, yes. Wasn't my first try, just wanted to show you what the issue was
10:37:25 <dafis> Dae: I thought of "cabal install -v", that should output more information. Nevertheless, `runhaskell ./Setup.hs build' didn't produce any errors?
10:38:34 <alej> wow this verizon interface is so bad
10:38:43 <alej> there's a select list for phone brand/os
10:38:57 <alej> if you select one, you still get a drop-down, but you have to select all before you select a different brand/os
10:39:15 <Dae> dafis, No, actually it appears to be working now... still no idea why it wouldn't cabal install
10:39:37 <Dae> -v didn't really give any light on the situation
10:40:27 <monochrom> probably because you didn't clean when you switched strategies.
10:40:43 <Dae> monochrom, perhaps. But why not in the first place?
10:41:44 * Dae suddenly suspects the aging version of cabal that comes with fedora these days
10:42:10 <aristid> Dae: cabal install cabal-install and add $HOME/.cabal/bin to your path
10:42:35 <monochrom> probably because it's an undecidable problem to determine whether the current content of the dist directory is good content or bad leftover content.
10:48:36 <Dae> aristid, Thanks. Didn't solve the problem
10:48:41 <Dae> though
10:48:49 <Dae> But thank you everyone!
10:49:45 <dafis> Dae: cd ~; cabal install -v2 hamtrix; paste output
10:52:33 <Dae> dafis, http://pastebin.com/wDCMKvjw
10:54:03 <andres_> hello everybody
10:54:45 <andres_> anyone knows how to install cabal with ghc 7.0.1?
10:55:50 <fryguybob> Dae: Your log says: Please run "cabal clean" first.  Did you try that?
10:56:21 <monochrom> in this case "cabal clean" is unnecessary because it's a "cabal install hmatrix"
10:56:41 <monochrom> as opposed to a "cabal install" inside a source tree
10:57:41 <Dae> dafis, but don't worry about it. I did manage to install it. Just curious why cabal didn't work
10:58:15 <Dae> and other things install just fine
10:58:15 <dafis> Dae: Ah, okay. Very strange.
10:58:33 <dafis> I've no idea what's up there
10:59:43 <jonkri> mm_freak: about the logging stuff... you might want to put a commant at "Should we need the ability to log events, we can add a WriterT layer." at http://book.realworldhaskell.org/read/monad-transformers.html :)
11:05:54 <tromp_> i'm trying to solve the february Ponder This challenge by brute force
11:06:30 * roconnor wishes Sebastian Fischer's blog entries had dates attached to them
11:07:49 <tromp_> http://hpaste.org/43575/search_for_a_number
11:08:02 * jonkri believes he has a too low iq for monad transformers
11:08:03 <tromp_> wonder why it's using more and more memory
11:08:32 <roconnor> jonkri: don't worry.  No one understands monad transformers
11:09:52 <jonkri> somehow i doubt that :P
11:10:00 <roconnor> it is true
11:10:24 <Dae> Well, no human being understands monad transformers
11:10:39 <copumpkin> you need to apply the MonadTransformerUnderstander transformer to your mind monad to understand monad transformers
11:10:55 <jonkri> haha ok
11:10:57 <applicative> do some people understand some of the monads that result from applying a monad transformer to a some monad or other?
11:11:06 <ddarius> Monad transformers are just morphisms in the category of monads.
11:11:36 <roconnor> ddarius: I think they are more than that
11:11:36 <mm_freak> "just"
11:11:45 <copumpkin> roconnor: why?
11:11:54 <mm_freak> applicative: i understand IdentityT Identity
11:12:13 <roconnor> copumpkin: because when you monad transform say a Cont monad, it ought to still have some sort of callCC function
11:12:14 <mm_freak> jonkri: the easiest monads to understands are those reflecting functions
11:12:20 <jonkri> ok, let me ask this: what is the least amount of code that creates a StateT monad on top of an IO monad?
11:12:21 <applicative> mm_freak, that was going to be my first example of one i can grok
11:12:22 <mm_freak> monads → monad transformers
11:12:38 <mm_freak> jonkri: StateT MyState IO
11:12:45 <roconnor> copumpkin: and similarly when you use a ConT monad transfomer it should generate some sort of callCC function.  Thought I think this part is well understood
11:12:55 <mm_freak> jonkri: just consider what StateT is:  s -> m (a, s)
11:12:58 <mm_freak> jonkri: in that case m = IO
11:13:14 <copumpkin> roconnor: that's doesn't make them not morphisms though. You just need some extra stuff to model the things you care about?
11:13:36 <mm_freak> so StateT MyState IO Result = MyState -> IO (Result, MyState)
11:14:12 <roconnor> copumpkin: I said that they are more than just monad morphisms
11:14:24 * jonkri is processing...
11:14:47 <mm_freak> jonkri: don't try to understand "monad transformer"…  rather try to understand specific monad transformer stacks…  it's not that far-fetched that nobody understands monad transformers =)
11:14:47 <copumpkin> roconnor: oh, sure :P Hask is more than a category, too?
11:14:52 * applicative isn't sure jonkri should be processing *all* of this
11:14:59 <mm_freak> jonkri: it's an abstract concept, so there isn't really much to understand
11:15:18 <roconnor> copumpkin: even so, these are more than just Hask monad morphisms
11:15:43 <roconnor> copumpkin: or maybe they are not.  Maybe ddarius is right, and monad morphisms automatically perserve things like callCC
11:15:45 <applicative> jonkri, why worry about monad transformers, if you want (s-> IO (a,s)) then define it.  
11:15:48 <jonkri> applicative: thanks, i'm just processing the simplest parts of it :)
11:15:54 <roconnor> copumpkin: if so, I'd like to see that argument written out
11:16:16 <roconnor> @type callCC
11:16:17 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:16:39 <mm_freak> (it would be much easier, if we could create instances of partially applied type synonyms)
11:16:56 <tolkad> If you want a numerically indexable array data type with a known size at compile time, what are the trade-offs between using immutable arrays vs. tuples + case expressions for indexing?
11:17:05 <Dae> Is it possible to understand haskell and not explicitly understand category theory? And if not, where would be a good place to start?
11:17:14 <copumpkin> Dae: it is
11:17:18 <applicative> Is the only standard version of an ordinary state s -> (s,a) or s -> (a,s) that's around in the standard bunch of libraries, the StateT Identity one?
11:17:26 <tolkad> Dae: very possible. I don't know any category theory
11:17:30 <mm_freak> hmm
11:17:35 <mm_freak> nobody understands category theory
11:17:51 <jonkri> what's "(a, s)" in "m (a, s)" if m is io?
11:18:03 <applicative> Dae, the category theory in haskell is very thin, you don't need to understand any of category theory itself
11:18:09 <jonkri> in the case of StateT
11:18:15 <mm_freak> jonkri: the result of the IO action
11:18:26 <Dae> copumpkin, tolkad, Very glad to hear that ;) I'm not bad at math per se, but I'm a physicist, so it's a little more abstract than what I'm used to
11:18:28 <tolkad> Dae: Monads are really just a type class with a few rules instances should follow and an associated magic syntatic sugar
11:18:32 <jonkri> so a is anything and the s is a new state?
11:18:45 <ddarius> Considering Hask doesn't form a category (at least in the naive way), understanding category theory seems not too relevant.
11:18:45 <copumpkin> Dae: hah, physicists (certain fringe kinds of them) love category theory!
11:18:47 <mm_freak> jonkri: yes
11:18:56 <pozic> Dae: one can also question whether complicated monad stacks are actually a good idea.
11:18:56 <applicative> Dae, in *reflecting* on the matter people can go category wild, same as they can with anything, there are categorical approaches to everything.
11:19:17 <Dae> tolkad, I understand monads... I think... but monad transformers and monomorphisms.....
11:19:22 <pozic> Dae: first year students don't do anything with monads and they produce working programs too.
11:19:26 <mm_freak> jonkri: a computation of type StateT Int IO Float is essentially a function Int -> IO (Float, Int)
11:19:35 <category> Man, I'm being highlighted like crazy. ;o)
11:19:48 <copumpkin> Dae: haskell's monomorphism restriction aren't category theory's monomorphisms
11:19:49 <pozic> In that category I can remark that...
11:19:51 <Dae> pozic, working programs yes, but elegant ones?
11:19:55 <copumpkin> *isn't
11:19:56 <pozic> category: hi ;)
11:20:00 <applicative> Dae, but inside haskell, we use about four concepts from category theory, and they needn't have come from it at all, it needn't have existed.  They might have made nice examples if you were going to invent category theory.
11:20:14 <mm_freak> category: just like in #perl you shouldn't call yourself $_
11:20:19 * category grins.
11:20:25 <pozic> Dae: in fact, cabal install works like this ;)
11:20:29 <ddarius> Hask doesn't even form a semigroupoid.
11:20:31 <copumpkin> Dae: in haskell, monomorphism just means not polymorphism 
11:20:42 <Dae> copumpkin, I think I had some category theory when doing quantum field theory, but I was never able to connect it to what is used in haskell
11:20:45 <pozic> No, I am confused. 
11:21:07 <ddarius> @google rosetta stone baez
11:21:10 <lambdabot> http://math.ucr.edu/home/baez/rosetta.pdf
11:21:10 <lambdabot> Title: Physics, Topology, Logic and Computation: A Rosetta Stone
11:21:12 <augur> Dae: crazy. ive never been able to connect CT to QFT!
11:21:22 <djahandarie> What is Hask anyways? (Besides the category of Haskell types)
11:21:24 <pozic> Some much used programs use this simplistic programming style. 
11:21:34 <mm_freak> Dae: at least there is a quantum monad in haskell
11:21:53 <pozic> The relation between computation and the universe is more interesting, imho.
11:21:55 <tromp_> @src replicateM
11:21:55 <lambdabot> replicateM n x = sequence (replicate n x)
11:22:09 <pozic> Computing with a black hole FTW. 
11:22:11 <tromp_> @src sequence
11:22:11 <lambdabot> sequence []     = return []
11:22:11 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:22:12 <lambdabot> --OR
11:22:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:22:37 <mm_freak> i wonder why 'sequence' is a monadic function
11:22:42 <mm_freak> and why there is no sequenceA
11:22:49 <Dae> pozic, sure. I managed to do some rather advanced quantum simulations in haskell without creating a single monad. Not sure if it was very optimal though
11:22:49 <djahandarie> There is
11:22:51 <ddarius> @hoogle sequenceA
11:22:51 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:22:51 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
11:22:57 <mm_freak> oh, indeed
11:23:08 <pozic> Dae: monads only make your code slower.
11:23:17 <mm_freak> pozic: ?!
11:23:21 <mm_freak> no, they don't
11:23:25 <pozic> mm_freak: yes, they do. 
11:23:26 <applicative> djahandarie, Hask is the haskell types with (->) as the morphism. 
11:23:29 <Dae> augur, ahh, sorry. I'm confusing category and group theory....
11:23:37 <djahandarie> applicative, well, yeah.
11:23:41 <djahandarie> I'm looking for something more :)
11:23:50 <pozic> mm_freak: please provide evidence that all monad transformer indirections are all compiled away.
11:23:52 <applicative> ... like a programming language?? 
11:23:58 <mm_freak> pozic: Maybe and Either make your code slower, but that's related to the way they are defined and not at all to monads
11:24:03 <pozic> mm_freak: nobody has ever shown that, AFAIK. 
11:24:09 <djahandarie> Like more interesting category theoretic properties of Hask that don't apply to Set :)
11:24:15 <mm_freak> pozic: see contstuff…  all monads in contstuff are newtypes
11:24:27 <pozic> mm_freak: URL?
11:24:29 <jonkri> mm_freak: what about the "s m a ->" part of StateT?
11:24:33 <mm_freak> including MaybeT, EitherT, ChoiceT (lists), etc.
11:24:43 <mm_freak> pozic: http://hackage.haskell.org/package/contstuff
11:24:51 <augur> Dae: i dont know how groups and QT connect either x3
11:24:54 <jonkri> nevermind :)
11:24:57 <tolkad> Dae: monad transformers can be understood by calculating the combined, unwrapped type. for example: « MaybeT m a » contains « m (Maybe a) ». « StateT s m a » contains « s -> m (a, s) ». « MaybeT (StateT s Indentity) a » contains « (StateT s Identity) (Maybe a) » which contains « s -> Identity (Maybe a, s) »
11:25:02 <mm_freak> jonkri: don't confuse types with values ;)
11:25:15 <tromp_> is there a variation of sequence that deals with xs before dealing with x?
11:25:16 <tolkad> Dae: there's actuall a lambdabot command to do it
11:25:23 <jonkri> mm_freak: i was looking at runStateT :P
11:25:24 <Dae> pozic, heh. Yes insisting on doing numerics in haskell is a bit strange. I have spent way too much time trying to get high array performance out of haskell.
11:25:36 <Dae> Still, more fun than Fortran
11:26:01 <mm_freak> Dae: high array performance is not a problem in haskell, though you'll probably get faster code with fortran
11:26:03 <ddarius> tromp_: Just use that foldr definition with the "other" liftM2.
11:26:04 <tolkad> @tf MaybeT Identity Int
11:26:04 <lambdabot>  Done.
11:26:19 <applicative> Dae, none of the new fangled libraries are up to par yet?  like Vector and so on? 
11:26:24 <jonkri> Dae: isn't big parts of octave written in fortran?
11:26:31 <jonkri> s/Dae: /
11:26:40 <tolkad> what's the command to show monad transformer types? lambdabot's command list server is offline
11:26:40 <mm_freak> Dae: on the other hand you might have finished calculating the result with haskell long before you've finished writing your fortran program…  performance is not only about code speed
11:27:14 * applicative was surprised how handsome fortran is, with syntax highlighting, when he was trying to read some not long ago.
11:27:18 <Dae> augur, you need group theory for quantum field theory. Like the electromagnetic force is U(1) (I think), the strong force is SU(3) (I think). It does make my head hurt sometimes
11:27:29 <tolkad> ah, @unmtl
11:27:43 <Dae> applicative, sure. but this was 3 years ago. Vector wasn't there ;)
11:27:44 <applicative> @unmtl StateT Identity
11:27:44 <lambdabot> err: `StateT Identity' is not applied to enough arguments.
11:27:54 <applicative> @unmtl StateT Identity a b
11:27:54 <lambdabot> err: `Identity' is not applied to enough arguments, giving `/\A. A'
11:27:57 <tolkad> @unmtl MaybeT (StateT s Identity) a
11:27:58 <lambdabot> s -> (Maybe a, s)
11:28:04 <applicative> i forget everthing
11:28:11 <augur> Dae: crazy
11:28:15 <tolkad> @unmtl StateT s (MaybeT Identity) a
11:28:15 <lambdabot> s -> Maybe (a, s)
11:28:34 <tolkad> @unmtl StateT s (MaybeT (ErrorT String Identity)) a
11:28:35 <lambdabot> s -> Either String (Maybe (a, s))
11:28:51 <applicative> Dae, Oh, I see.  I think there has been progress, but it's an active topic.  The fancy parallelism business is still in infancy I guess.
11:29:00 <Dae> jonkri, not sure actually. I've spent most of my master thesis writing Fortran 77 though, and missing haskell terribly
11:29:17 <PhilRod_> Dae, augur: it kinda boils down to Noether's theorem, which is really cool (and applies in non-quantum cases too)
11:29:18 <tolkad> see? once you calculate the actual type monad transformers are wrapping it's pretty easy to understand their semantics
11:29:35 <jonkri> Dae: sorry about that
11:29:35 <augur> PhilRod_: maybe! it might helpif i knew more about quantum theory x3
11:29:51 <applicative> noether's theorem is so wonderful, it makes me want to study physics...
11:30:25 <Dae> applicative, I was rather surprised how much progress actually. Vector is looking very nice, and there are even semi-decent plotting packages now
11:30:45 * Dae joines the "Love Noether's theorem" club
11:30:49 <pozic> Physics is like computer science, just with a bigger machine. 
11:31:00 <jonkri> how can i check the type of a "type = StateT TestState"? :t TestT gives a not in scope error
11:31:02 <Dae> augur, Did you ever do classical mechanics?
11:31:15 <augur> not lagrangian
11:31:29 <applicative> Dae, What is good under the head of plotting packages, and what is needed?
11:31:37 <monochrom> your machine is so big, it is non-Euclidean globally
11:31:39 <augur> Dae: i still need to work through SICM
11:32:28 <jonkri> sorry, type TestT = StateT TestState
11:32:58 <Saizan> jonkri: try :k TestT
11:33:18 <jonkri> Saizan: nope
11:33:53 <Saizan> :\ then you're stuck with :k StateT TestState
11:34:15 <applicative> @kind TestT
11:34:16 <jonkri> Saizan: not in scope on TestState in that case :(
11:34:16 <lambdabot> Not in scope: type constructor or class `TestT'
11:34:31 <jonkri> applicative: that's my type
11:34:37 <jonkri> so is TestState
11:34:57 <mm_freak> how long did it take you guys to understand limits and colimits?  i'm trying for hours without results
11:35:06 <applicative> what, you assume the liberty to define your own types? In Haskell??
11:35:13 <Dae> applicative, looking into that right now actually. But things like chart and plot are still lacking guis, and you can't output jpgs. For instance. Was hoping to help fix it
11:35:20 <Dae> augur, SICM?
11:35:47 <ddarius> mm_freak: It depends on what you mean by "understand" them and what your background is.
11:36:00 <tolkad> If you want a numerically indexable array data type with a known size at compile time, what are the trade-offs between using immutable arrays vs. tuples + case expressions for indexing?
11:36:06 <augur> Dae: structure and interpretation of classical mechanics, the physics counterpart to SICP
11:36:07 <applicative> Dae, http://mitpress.mit.edu/sicm/
11:36:21 <augur> @where sicm
11:36:21 <lambdabot> I know nothing about sicm.
11:36:24 <augur> D:
11:36:34 <ddarius> mm_freak: Broadly, limits are the categorical way of solving a system of equations in the most general manner and colimits are the categorical way of glueing things together in the least destructive manner.
11:36:37 <augur> @where structure and interpretation of classical mechanics
11:36:37 <lambdabot> I know nothing about structure.
11:36:46 <pozic> Dae: I am pretty sure you can output jpg.
11:36:50 <mauke> @where+ sicm http://mitpress.mit.edu/sicm/
11:36:50 <mm_freak> ddarius: my background is that i now understand categories, functors, initial/terminal objects and (co-) products
11:36:50 <lambdabot> It is forever etched in my memory.
11:36:55 <augur> mauke: \o/
11:37:04 <pozic> Dae: you get some kind of cairo object at some point. 
11:37:04 <mauke> @flash
11:37:04 <lambdabot> Not enough privileges
11:37:21 <pozic> Dae: you can do everything with those using cairo APIs.
11:37:21 <ddarius> mm_freak: Well if you then understand (co)equalizers then you will, technically, understand all (co)limits.
11:37:21 <augur> @streak
11:37:21 <lambdabot> Unknown command, try @list
11:37:23 <augur> @dog
11:37:23 <lambdabot> ()
11:37:26 <augur> ..
11:37:28 <augur> wat
11:37:37 <tolkad> I ask because it would be entirely possible for ghc to see that your case expressions associate sequential integers with certain tuple elements and optimize this into a memory address offset
11:37:38 <augur> @list
11:37:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:37:39 <mm_freak> ddarius: does that mean that (co-) equalizers are even more general?
11:37:49 <ddarius> mm_freak: No.
11:37:50 <Eelis> do i understand correctly that gtk2hs is *not* on hackage?
11:38:05 <tolkad> how exactly does ghc compile case expressions?
11:38:17 <mauke> @flash
11:38:18 <ddarius> mm_freak: All (co)limits can be built from (co)terminal objects, (co)products, and (co)equalizers.
11:38:43 <Saizan> Eelis: the packages that compose it are
11:38:56 <mm_freak> ddarius: ah, thanks…  then i'll look into (co-) equalizers…  what are coterminal objects?  initial objects?
11:39:02 <ddarius> Yes.
11:39:10 <mm_freak> ok, thanks a lot
11:39:18 <Dae> augur, ahh, right. It's a surprisingly useful tool
11:39:21 <Eelis> Saizan: hm
11:39:24 <ddarius> Really, you'd be better off understanding (co)ends and their variety of useful properties.
11:39:30 <Saizan> Eelis: e.g. gtk
11:39:37 <monochrom> gtk2hs is on hackage. assuming you have the gtk+ dev files (*.h, *.so, *.a), first "cabal install gtk2hs-buildtools", then "cabal install gtk".
11:39:42 <augur> Dae: its just hard for me to picture whats going on in CM
11:39:47 <mm_freak> ddarius: ok, i'll look into them
11:39:49 <Eelis> monochrom: thanks, i'll give that a try
11:39:49 <augur> SICM wasnt bad to get into but it was a bit over my head
11:40:00 <Dae> pozic, yes. But that's my point it's not as easy as 'plot x y "output.jpg" '
11:40:13 <mm_freak> btw, i generally practice CT using the quite simple poset categories…  is this a bad habit?
11:40:32 <pozic> Dae: that would have to change the type of plot.
11:40:40 <Dae> augur, CM? Centre of mass?
11:40:50 <augur> Dae: classical mechanics!
11:40:53 <augur> well, lagrangian
11:40:57 <augur> newtonian is easy
11:41:10 <pozic> Dae: a disadvantage of the pure vs impure types.
11:41:11 <tolkad> How does ghc compile case expressions if they are not trivial enough to be simply optimized away? A branch table? A branch tree? Sequentially test each case?
11:41:35 <ddarius> mm_freak: Well, CT generalizes order theory in a natural manner and much of the intuition from order theory comes over readily, but certainly some things are trivial in poset categories that aren't in arbitrary categories.
11:41:46 <ddarius> @google category theory as coherently, constructive lattice theory.
11:41:48 <lambdabot> http://www.cs.nott.ac.uk/~rcb/MPC/CatTheory.ps.gz
11:42:23 <mm_freak> tolkad: sequentually test each case
11:42:42 <pozic> What is a "family of morphisms"? on http://en.wikipedia.org/wiki/Limit_(category_theory) I get the morphisms part. 
11:42:46 <Dae> augur, ahh right. Sorry. Too many things going on around me. It becomes a lot easier later on. QM becomes more intuitive under the lagrangian formalism, and CM IS an easier place to start
11:43:14 <tolkad> mm_freak: even if they are sequential integers starting at 0?
11:43:34 <tolkad> mm_freak: the patterns that is
11:43:50 <monochrom> I say "X is a family of morphisms" when X_0, X_1, X_2... are each a morphism. Or some other indexing scheme. Or I just use function application: X 0, X 1, X 2...
11:44:04 <mm_freak> tolkad: likely yes, unless later optimizations optimize that away, but i doubt it
11:44:05 <Dae> pozic, yes. I wasn't proposing making plot impure. But if I just want a quick look at my data, it's annoying to have to write 10 lines of haskell
11:44:07 <Eelis> Saizan, monochrom: seems to work, thanks again
11:44:18 <mm_freak> tolkad: you'll want the most likely patterns at the top
11:44:33 <pozic> Dae: so, put a package on Hackage with those 10 lines.
11:45:03 <tolkad> mm_freak: ugh, for things like characters I had been assuming it would generate something of at least log n run time
11:45:04 <Dae> pozic, that was my plan ;) 
11:45:18 <mm_freak> tolkad: on the other hand, a good pattern usually can't be reordered…  if it can, then chances are there is a combinator for whatever you're doing
11:45:51 <mm_freak> tolkad: in that case a Map might be your answer
11:45:57 <mm_freak> and not a pattern match at all
11:46:13 <Dae> pozic, would be nice to have something as powerful as pythons matplotlib for haskell. Though preferably with a better api for more advanced things. I was hoping to help make that happen
11:46:32 <pozic> tolkad: if you want to know, just build an example with 1000 cases yourself.
11:46:40 <pozic> tolkad: you can inspect the resulting asm. 
11:46:53 <pozic> tolkad: you can also download the compiler source code, or send an email to the developers list.
11:47:06 <jmcarthur> mm_freak: "a good pattern usually can't be reordered"  <- neat rule of thumb there
11:47:28 <shamster> could anyone explain the 'Maybe' term in a type definition?
11:47:30 <pozic> Dae: isn't matplotlib 2D only?
11:47:37 <mauke> @src Maybe
11:47:38 <lambdabot> data Maybe a = Nothing | Just a
11:48:14 <djahandarie> 'Maybe' is type constructor. 
11:48:25 <djahandarie> Meaning you see it only on the type level
11:48:32 <djahandarie> (Normally after a :: sign)
11:48:35 <tolkad> ugh I just stapled my finger
11:48:45 <tolkad> this is all the ghc developers fault
11:49:01 <Dae> pozic, well it does have 3D features, but.... 2D would be a very nice start. 3D plots are a bit overrated for many things
11:49:02 <shamster> djahandarie: What does it do?
11:49:22 <djahandarie> shamster, Maybe takes another type (e.g., Integer) and turns it into Maybe Integer
11:49:25 <tolkad> :P
11:49:41 <pozic> Dae: I think all those overloaded interfaces are often complicated.
11:49:59 <pozic> Dae: a page with everything you can do without typeclasses is easier to understand, imho. 
11:50:11 <shamster> djahandarie: that sounds almost useful! Is there a time we'd need to use a Maybe Integer? or a Maybe Type?
11:51:19 <djahandarie> shamster, sure. When you don't know if you have a value or not. Like   middleName :: Maybe String
11:51:27 <djahandarie> Some people don't have middle names
11:51:51 <tolkad> or lets say you have a function that tells you how long an algorithm will run on a certain input
11:51:54 <jmcarthur> some people don't have last names, even
11:51:59 <shamster> djahandarie: ah... and if the middleName is null, or just nothing, then it returns null?
11:52:00 <Dae> pozic, in matplotlib? Perhaps. But again it's very useful for a quick and dirty plot, and is advanced enough to be useful for publishing
11:52:21 <Dae> he left.. right
11:52:25 <kamatsu> why would you represent an optional string with a Maybe
11:52:28 <kamatsu> can't you just use ""?
11:52:36 <jmcarthur> "" can mean something else
11:52:38 <tolkad> it can return a Maybe Integer, returning Just runTime if the algorithm halts and Nothing if the algorithm doesn't halts
11:52:43 <jmcarthur> "the string that contains no characters"
11:52:51 <jmcarthur> as opposed to "no string"
11:53:01 <shamster> empty string
11:53:32 <jmcarthur> but there is something interesting in there. i doubt that "" would be a valid last name ;)
11:53:39 <jmcarthur> *middle name
11:53:52 <tolkad> jmcarthur: but people can't have empty middle names and avoiding the use of Maybe could save you a couple precious words of memory
11:54:18 <shamster> in haskell, it seems to me, there are no null types. Even an empty list is astill a list...
11:54:20 <jmcarthur> tolkad: i doubt they are precious in the first place :P
11:54:34 <mauke> shamster: well, yes. that's what Maybe is for
11:54:44 <shamster> So does Maybe get used in place of null checks?
11:54:53 <mauke> what's a null check?
11:55:07 <shamster> mauke: checking for a NULL * in c++, for instance
11:55:09 <jmcarthur> tolkad: i'd say that that use of "" could make sense *in this particular case*, and even then you'd probably be better off using a newtype wrapper or something to prevent you from using it incorrectly
11:55:12 <RichardBarrell> Maybe gives you an explicit Nothing value.
11:55:21 <mauke> shamster: huh?
11:55:32 <Tomsik> shamster: null check is more of checking a == Nothing
11:55:34 <RichardBarrell> Ideally, you never ever have an implicit NULL.
11:55:58 <shamster> RichardBarrell: ideally, but certain languages don't have too many ways around it in particular situations
11:56:06 <shamster> or any ways around it
11:56:28 <jonkri> oh, i had the wrong module loaded, although using :k on my type TestT = StateT TestState type didn't reveal much: (* -> *) -> * -> *
11:56:36 <shamster> Tomsik: yes
11:56:54 <RichardBarrell> > let { indexOf v [] = Nothing; indexOf v (a:as) = if v == a then Just 0 else fmap (1+) (indexOf v as); } in (indexOf 5 [1,2,3,4,5,6], indexOf 7 [1,2,3,4,5,6])
11:56:55 <lambdabot>   (Just 4,Nothing)
11:56:59 <jmcarthur> whereas some languages just allow null in almost any place, haskell only allows it in places that you say it's allowed, and then you are *required* to check for it
11:57:01 <RichardBarrell> Yay, \bot.
11:57:41 <Eduard_Munteanu> Well, 'newSTRef undefined' is somewhat like NULL.
11:57:53 <Twey> Except undefined, which you can use anywhere and you can't check for ;)
11:58:01 <shamster> so if I create a 'data Maybe a', then how does the constructor handle the null case?
11:58:02 <tolkad> shamster: yeah the only reason it makes sense for haskell is because haskell doesn't have implicit mutability. haskell's mutable types have implicit NULLs (MVar) or require a value at the point of definition (IORef)
11:58:04 <monochrom> write-only null
11:58:10 <dafis> jmcarthur: although you can obviate that requirement if you really want to
11:58:19 <mauke> shamster: why would you create a 'data Maybe a'? it already exists
11:58:20 <RichardBarrell> Eduard_Munteanu: undefined isn't the same as NULL since you can't check for it. Nor can you check for infinite loops or segfaults.
11:58:24 <Eduard_Munteanu> It's some sort of implicit null check, as Haskell will check if it's undefined.
11:58:28 * djahandarie went idle in the middle of explaining something, oops
11:58:41 <jvogel> Sorry for being newb, but how the hell do I get haskell mode to work in emacs on Arch Linux?
11:58:58 <shamster> mauke: I guess I'm not sure. Still trying to wrap my head around haskell's syntax and also figuring out how to use Maybe
11:58:58 <jvogel> On debian, I installed the same damn package and it just worked.  I didn't think I had to touch .emacs
11:59:16 <jmcarthur> dafis: sure... explicitly
11:59:24 <djahandarie> shamster, it might be helpful to think of it as a type instead of a type constructor.    data MaybeI = NothingI | JustI Integer
11:59:33 <jmcarthur> dafis: alternatively, you could use _|_ in place of null, but then you can't check for it at all
11:59:34 <mauke> shamster: I think you need to learn about types in general
11:59:34 <RichardBarrell> jvogel: That's 'cuz Debian installs the initialisation code that would have gone into your .emacs into an auto-init directory.
11:59:37 <tolkad> shamster: I think Java should have made returning or passing null to a function throw an exception though. that way it would have been clearly defined where the responsibility was to handle it
11:59:47 <Twey> jvogel: Same, I think
11:59:48 <djahandarie> @quote glorious.stero
11:59:48 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
11:59:50 <djahandarie> @quote glorious.stereo
11:59:50 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
12:00:03 <Twey> I don't have anything in my .emacs.d for Haskell
12:00:06 <jvogel> RichardBarrell: debian didn't touch my .emacs
12:00:15 <Twey> OTOH, maybe ergoemacs does it for me; I don't remember
12:00:17 <jvogel> I'm using the same .emacs
12:00:30 <RichardBarrell> jvogel: indeed, it doesn't. There's a directory full of .el files somewhere which get run before .emacs does.
12:00:50 <RichardBarrell> /etc/emacs/site-start.d/*.el in Ubuntu (and I'm almost certain Debian, too)
12:00:52 <shamster> mauke: I love learning! Thanks.
12:00:56 <monochrom> jvogel: http://hpaste.org/43576/emacs  some lines may be omitted for you. some directory names may need change.
12:00:59 <jvogel> RichardBarrell: ah, ok.
12:01:03 <djahandarie> shamster, so yeah, try to understand the simpler case before the more abstract Maybe
12:01:21 <RichardBarrell> Ubuntu calls the file "50haskell-mode.el"
12:01:47 <RichardBarrell> jvogel: want a copy of its contents? Or was that enough information to go on?
12:01:59 <tolkad> :t Mu
12:02:00 <lambdabot> Not in scope: data constructor `Mu'
12:02:05 <tolkad> :k Mu
12:02:06 <lambdabot> (* -> *) -> *
12:02:23 <monochrom> its data constructor is In
12:02:25 <djahandarie> shamster, here is a function that uses my example MaybeI type:    f :: MaybeI -> String; f NothingI = "Nada."; f (JustI x) = "You have a "++(show x)
12:02:29 <tolkad> @unmtl Mu Integer
12:02:29 <lambdabot> Mu Integer
12:02:39 <tolkad> @unmtl Mu Maybe
12:02:40 <lambdabot> Mu Maybe
12:02:42 <Eduard_Munteanu> mtl?
12:02:53 <Eduard_Munteanu> It's not a monad transformer.
12:03:00 <monochrom>  @unmtl is not a silver bullet.
12:03:07 <monochrom> or google
12:03:12 <jonkri> can someone please explain this to me, especially why it s is in the first two parameters:
12:03:13 <djahandarie> shamster, basically you pattern match on every part of your data type and act accordingly
12:03:13 <jonkri> :t runStateT
12:03:14 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
12:03:14 <applicative> @unmtl IO
12:03:15 <lambdabot> IO
12:03:20 <edwardk> ah, neat. if we define class that provides 'mapWithKey', the representable functors all admit an instance of that. similarly we can strengthen memotries to provide 'TraversableWithKey' or even a 'TraversableWithKey1' that admits traversal by 'Bind' alone.
12:03:39 <boegel> has the swap function been added to Data.Tuple in base recently?
12:03:48 <mauke> jonkri: s is the state
12:03:51 <boegel> I'm getting this: 
12:03:53 <Eduard_Munteanu> jonkri: it's a phantom type, you're supposed to leave it polymorphic in type sigs.
12:04:03 <boegel> solution.hs:141:33: Not in scope: `swap'
12:04:04 <mauke> Eduard_Munteanu: wat
12:04:07 <dafis> boegel: yes
12:04:15 <boegel> but I'm using fst in the same file, and that's ok...
12:04:18 <Eduard_Munteanu> Oh, crap.
12:04:26 <dafis> boegel: it's in Data.Tuple in GHC 7
12:04:26 <Eduard_Munteanu> I thought I saw ST, nevermind.
12:04:35 <Eduard_Munteanu> It's the state type here.
12:04:42 <boegel> dafis: ah, and where was it before (if anywhere)
12:04:50 <jvogel> RichardBarrell: Sorry I haven't messed with this stuff in a while so I'm working on figuring it out without having to bug you all with stupid shit
12:05:01 <dafis> boegel: in everybody's own code
12:05:08 <RichardBarrell> jvogel: http://hpaste.org/43577/50haskellmodeel
12:05:12 <tolkad> @pl (\a b c d e f g h i j k l m n o p) -> ((\q r s t u v w x y z) -> h s d a q w u o p w q i u a d b c z m x k l s a w e t b) ((\q r s t u v w x y z) -> d j f w i d q a m s p l e o w y a z x h s q w u e t i r i o p j d h s a l e s j)
12:05:12 <lambdabot> (line 1, column 34):
12:05:12 <lambdabot> unexpected ")"
12:05:12 <lambdabot> expecting pattern or "->"
12:05:28 <tolkad> @pl (\a b c d e f g h i j k l m n o p) -> (\q r s t u v w x y z-> h s d a q w u o p w q i u a d b c z m x k l s a w e t b) (\q r s t u v w x y z -> d j f w i d q a m s p l e o w y a z x h s q w u e t i r i o p j d h s a l e s j)
12:05:28 <lambdabot> (line 1, column 34):
12:05:28 <lambdabot> unexpected ")"
12:05:28 <lambdabot> expecting pattern or "->"
12:05:35 <jvogel> RichardBarrell: Ah I got haskell mode to load, it just doesn't go automatically for .hs :P
12:05:40 <tolkad> @pl (\a b c d e f g h i j k l m n o p -> (\q r s t u v w x y z -> h s d a q w u o p w q i u a d b c z m x k l s a w e t b) (\q r s t u v w x y z -> d j f w i d q a m s p l e o w y a z x h s q w u e t i r i o p j d h s a l e s j)
12:05:40 <lambdabot> (line 1, column 225):
12:05:40 <lambdabot> unexpected end of input
12:05:40 <lambdabot> expecting variable, "(", operator or ")"
12:05:42 <boegel> dafis: ah :)
12:05:48 <djahandarie> tolkad, give up while you're ahead
12:05:49 <boegel> dafis: so it will be in mine too ^_^
12:06:13 <RichardBarrell> jvogel: ah yeah. See the (setq auto-mode-alist...) sexpr at the top of that paste? Copy that in.
12:06:21 <dafis> boegel: or get a new GHC 
12:06:24 <jvogel> RichardBarrell: Can I PM you?
12:06:28 <tolkad> @pl (\a b c d e f g h i j k l m n o p -> (\q r s t u v w x y z -> q h s d a q w u o p w q i u a d b c z q m q x k l s q a w e q t b) (\q r s t u v w x y z -> d j f w i d q a m s p l e o w y a z x h s q w u e t i r i o p j d h s a l e s j)
12:06:28 <lambdabot> (line 1, column 235):
12:06:28 <lambdabot> unexpected end of input
12:06:28 <lambdabot> expecting variable, "(", operator or ")"
12:06:35 <RichardBarrell> tolkad: please stop that.
12:06:39 <RichardBarrell> jvogel: please, feel free.
12:06:43 <jonkri> mauke: why is the s in both "StateT s m a" and "s"
12:06:56 <mauke> jonkri: er, why not?
12:07:11 <Eduard_Munteanu> It's just a type variable name.
12:07:17 <mauke> StateT s m a is a state transformer. it has to know which type it transforms
12:07:19 <tolkad> yes, why not? that's haskell's philosophy
12:07:26 <mauke> and the other "s" is the initial state
12:07:31 <jonkri> ok
12:08:11 <jonkri> thanks, and sorry for asking stupid questions... i am really trying here, and you're saving me a lot of headaches :)
12:08:21 <mauke> :t runState
12:08:22 <lambdabot> forall s a. State s a -> s -> (a, s)
12:08:22 <jonkri> or migranes perhaps, as i already have a bit of a headache :P
12:08:32 <mauke> @unmtl State s a
12:08:32 <lambdabot> s -> (a, s)
12:08:34 <tolkad> why associate * and + with Num making it hard to make instances for vectors?
12:08:36 <tolkad> why not?
12:08:53 <monochrom> tolkad you should stop being annoying.
12:08:57 <boegel> dafis: yeah, well, not an option
12:09:11 <boegel> dafis: I'm preparing for a programming contest, and they're using the Haskell Platform
12:09:12 <dafis> boegel: why not?
12:09:19 <dafis> oh
12:09:45 <boegel> dafis: so, I need to make sure the code Im writing in preparation works with that
12:09:48 <dafis> boegel: when? the new platform with GHC 7 is due around the 11th
12:10:00 <applicative> tolkad was just missing a parenthesis (\a b c d e f g h i j k l m n o p -> (\q r s t u v w x y z -> q h s d a q w u o p w q i u a d b c z q m q x k l s q a w e q t b)) (\q r s t u v w x y z -> d j f w i d q a m s p l e o w y a z x h s q w u e t i r i o p j d h s a l e s j)
12:11:11 <Eduard_Munteanu> Well you can't rely on them having the latest HP.
12:11:30 <Eduard_Munteanu> But what's the problem, really?
12:11:59 <kulakowski> I was curious, why isn't the haskell platfrom updated to say so? It still says January on the main page.
12:17:03 <boegel> dafis: in March, but they won't be changing the environments anymore, they're fixed now
12:17:30 <jonkri> "let test = StateT TestState IO" -> "not in scope, data constructor io"?
12:17:32 <dafis> okay, so have swap in your own code
12:17:37 <boegel> dafis: it's not just Haskell, but a whole bunch more, and they've fixed the version of every language used already (which makes perfect sense, of course)
12:17:43 <boegel> dafis: yeah, not too bad :)
12:18:15 <Eduard_Munteanu> jonkri: that's a type, how does that 'let' make sense?
12:18:19 <dafis> shorter than sort for example :)
12:18:29 <Eduard_Munteanu> Even so...
12:18:32 <Eduard_Munteanu> :t StateT
12:18:33 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
12:18:47 <Eduard_Munteanu> You need three parameters.
12:19:10 <jonkri> then allow me to rephrase my earlier question: what is the least amount of code that i can put in a do block to construct a StateT on top of the IO monad?
12:20:29 <monochrom> do { return () } :: StateT s IO ()
12:20:33 <Eduard_Munteanu> jonkri: runStateT $ do { ... }
12:20:35 <boegel> dafis: true enough :)
12:20:46 <Eduard_Munteanu> or evalStateT, or execStateT, depending on what you want.
12:21:13 <monochrom> perhaps replace s by TestState if you like
12:21:41 <Eduard_Munteanu> :t evalStateT
12:21:42 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
12:22:02 <monochrom> when you wrote "StateT TestState IO" you were trying to write a type. but you need a value when you write "let test = ..."
12:22:43 <Eduard_Munteanu> '::' makes sense though, instead of '='
12:25:50 <monochrom> but then "StateT TestState IO" isn't a complete type either.
12:26:46 <jonkri> yeah, it needs the result type too right?
12:27:35 <andres_> anybody knows how to install the iconv?
12:27:38 <mm_freak> shamster: either Maybe or exceptions
12:27:45 <jonkri> monochrom: i tried to put your "do" code above in main but got an error saying "couldn't match expected type IO t against inferred type StateT s IO ()"
12:27:53 <mm_freak> in fact Maybe is a special case of a monad supporting exceptions
12:30:17 <jonkri> main = do { return () } :: StateT s IO ()
12:30:31 <jonkri> no explicit type definition on main, also tried TestState instead of s
12:30:41 <mm_freak> jonkri: main is always some IO type
12:31:11 <mm_freak> jonkri: a monad transformer is usually reduced to a computation in its underlying monad by some 'run*' function
12:31:15 <mm_freak> in that case runStateT
12:31:21 <mm_freak> (or evalStateT or execStateT)
12:31:41 <mm_freak> runStateT takes a StateT computation over 'm' and converts it to an 'm' computation
12:31:45 <mm_freak> :t runStateT
12:31:46 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
12:33:56 <tromp_> @src findIndex
12:33:57 <lambdabot> findIndex p     = listToMaybe . findIndices p
12:34:37 <Eduard_Munteanu> > evalStateT (do { a <- lift $ get; print a }) 5
12:34:38 <lambdabot>   Ambiguous occurrence `lift'
12:34:38 <lambdabot>  It could refer to either `Control.Monad.Trans....
12:34:54 <Eduard_Munteanu> :t lift
12:34:55 <lambdabot>     Ambiguous occurrence `lift'
12:34:55 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
12:34:55 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
12:35:00 <Eduard_Munteanu> Grr.
12:35:09 <Eduard_Munteanu> > evalStateT (do { a <- Control.Monad.Trans.lift $ get; print a }) 5
12:35:09 <lambdabot>   Not in scope: `Control.Monad.Trans.lift'
12:35:35 <Eduard_Munteanu> Anyway, something like that should do.
12:36:43 <aristid> :t Control.Monad.Trans.State.lift
12:36:44 <lambdabot> Not in scope: `Control.Monad.Trans.State.lift'
12:36:51 <aristid> :t Control.Monad.Trans.Class.lift
12:36:52 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
12:37:03 <Eduard_Munteanu> > evalStateT (do { a <- Control.Monad.Trans.Class.lift $ get; print a }) 5
12:37:04 <lambdabot>   Not in scope: `Control.Monad.Trans.Class.lift'
12:37:12 <aristid> wtf
12:37:33 <aristid> :t Control.Monad.Error.lift
12:37:34 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
12:37:51 <Eduard_Munteanu> > evalStateT (do { a <- Control.Monad.Error.lift $ get; print a }) 5   --maybe?
12:37:53 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
12:37:53 <lambdabot>        ...
12:38:04 <aristid> Eduard_Munteanu: progress!
12:39:17 <Eduard_Munteanu> > evalStateT (do { a <- Control.Monad.Error.lift $ get; print a }) 5 >> return ()   --maybe?
12:39:18 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
12:39:18 <lambdabot>        ...
12:39:23 * Eduard_Munteanu gives up
12:41:33 <mauke> > evalStateT (do { a <- get; Control.Monad.Error.lift $ print a }) 5 >> return ()
12:41:33 <lambdabot>   <IO ()>
12:42:52 * scooty-puff test
12:52:37 <edwardk> @instances (->)
12:52:38 <lambdabot> Couldn't find class `(->)'. Try @instances-importing
12:52:44 <edwardk> blah
12:54:56 * edwardk just realized (with compumpkin's help) that representable functors are instances of Distributive
12:55:21 <edwardk> *copumpkin
12:55:47 * pumpkin compounds compumpkin weekly
12:55:52 <dolio> > error $ error "foo"
12:55:52 <lambdabot>   *Exception: *Exception: foo
12:56:02 <dolio> > (\f x -> f x) error (error "foo")
12:56:02 <edwardk> > fix error
12:56:03 <lambdabot>   *Exception: foo
12:56:03 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:56:04 * pumpkin compulsively compounds compumpkin
12:56:17 * applicative is looking up type class Distributive
12:56:27 <pumpkin> applicative: it's Traversable, backwards
12:56:46 <edwardk> http://hackage.haskell.org/packages/archive/distributive/0.1/doc/html/Data-Distributive.html
12:57:30 <djahandarie> What's Foldable backwards
12:57:47 <edwardk> elbadloF, obviously
12:58:01 <djahandarie> > reverse "Foldable"
12:58:02 <lambdabot>   "elbadloF"
12:58:04 <djahandarie> How did you know?!
12:58:16 <edwardk> actually I have an Unfoldable class, but its a bit different
12:58:24 * djahandarie is reminded of an Asimov story...
12:58:26 <aristid> > reverse "Traversable"
12:58:27 <lambdabot>   "elbasrevarT"
12:58:39 <aristid> pumpkin: Distributive = elbasrevarT?
12:59:11 <djahandarie> http://downlode.org/Etext/power.html is what I was reminded of :)
12:59:33 <edwardk> http://hackage.haskell.org/packages/archive/recursion-schemes/0.2.2/doc/html/Data-Functor-Foldable.html provides the Unfoldable class
12:59:45 <edwardk> yep
13:00:17 <djahandarie> Why do you previde Nu and Mu edwardk? Convenience?
13:00:37 <djahandarie> provide*
13:00:50 <edwardk> djahandarie: they are different types
13:00:58 <djahandarie> Aren't they isomorphic?
13:00:59 <edwardk> not just in spirit, in implementation here
13:01:18 <edwardk> newtype Mu f = Mu (forall a. (f a -> a) -> a)
13:01:26 <djahandarie> I didn't realize you could meaningfully differentiate the two in Haskell
13:01:31 <edwardk> is a folding of a datatype in elimination form
13:01:41 <edwardk> vs. newtype Fix f = Fix (f (Fix f))
13:01:42 <edwardk> and
13:02:00 <Palmik_> Hmm, does lines work on Mac line endings?
13:02:06 <edwardk> data Nu f where Nu :: (a -> f a) -> a -> Nu f
13:02:18 <edwardk> palmik: you always see line endings as '\n' in haskell
13:02:30 <edwardk> even if they are '\n\r' or \'r' on your platform
13:02:39 <edwardk> the IO subsystem swaps em out for you theoretically
13:02:46 <applicative> what are other obvious examples of  Control.Category.Distributive   the module just has instance Distributive Hask (,) Either ?  
13:03:03 <edwardk> applicative: 'every representable functor.
13:04:03 <edwardk> and as a consequence every functor with a left adjoint
13:04:14 <aristid> Palmik_: Mac OS X uses LF for its line endings
13:04:14 <tromp_> :t foldl
13:04:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:04:34 <dolio> > (\f -> \x -> f x) error (error "foo")
13:04:35 <lambdabot>   *Exception: foo
13:04:56 <Palmik_> edwardk, aah, nice :)
13:05:41 <edwardk> i should go add that requirement to Adjunction in my adjunctions package actually
13:05:46 * pumpkin eats seafood 
13:06:19 <Palmik_> edwardk, so in parsec (char '\n') is enought for eol?
13:06:21 * hackagebot hatt 0.2 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-0.2 (BenedictEastaugh)
13:06:28 <seafood> pumpkin: Food eating food? That's just weird :)
13:06:40 <dolio> > let g f x = f x in g error (error "foo")
13:06:41 <lambdabot>   *Exception: foo
13:07:01 <mrd> Palmik_: remember to cut off '\r' on certain platforms :)
13:07:24 <edwardk> palmik: should be
13:07:34 <edwardk> mrd: actually reading the file should do that for you in haskell
13:07:50 <edwardk> mrd: file IO is a bit magic 
13:07:55 <applicative> Palmik_ it should be, the Char you're calling '\n' is the Haskell Char
13:08:12 <Palmik_> ok :)
13:08:14 * djahandarie wonders if that is different with ByteString.readFile
13:09:10 <edwardk> i might be wrong on that, but that was my understanding
13:09:16 <edwardk> since real world haskell disagrees with me, take it with a grain of salt
13:09:20 <Palmik_> btw, what is wrong with endBy integer (char '\n')
13:09:32 <applicative> Palmik_, right, what djahandarie says .  I'm just thinking of the Haskell string/char business, not bytestrings etc
13:09:52 <Palmik_> edwardk, yeah, I have seen that the have their own eol in rwh handling all kinds of endings :)
13:11:52 * Dae hates when a tiny side project turns into "implement latex equations in haskell. From scratch"
13:11:58 <mrd> pretty sure i did some line parsing and got '\r's but it's been a while
13:12:01 <pumpkin> dolio: playing with the email to haskell-cafe about $?
13:12:14 <dolio> pumpkin: Yes. I have no explanation.
13:12:30 <mrd> also i may have been using bytestring
13:12:34 <applicative> Is there a $ risis
13:12:36 <applicative> crisis
13:12:48 <dolio> It seems to be specific to ($) and (.).
13:13:00 <dolio> I can use their definition instead, and it doesn't happen.
13:13:20 <pumpkin> dolio: maybe some hacks/special cases relating to ST and $?
13:13:20 <dolio> > (\f g x -> f (g x)) error error "foo"
13:13:21 <lambdabot>   *Exception: foo
13:13:53 <pumpkin> applicative: there really is
13:13:55 <dolio> > (.) error error "foo"
13:13:57 <pumpkin> did you see the thread?
13:13:57 <lambdabot>   *Exception: *Exception: foo
13:14:08 <Dae> mrd, '\r's?
13:14:15 <pumpkin> > error (error "foo")
13:14:16 <lambdabot>   *Exception: foo
13:14:19 <pumpkin> > error $ error "foo"
13:14:20 <lambdabot>   *Exception: *Exception: foo
13:14:31 <pumpkin> I hope you find that disturbing
13:14:34 <mrd> Dae: also known as '\ah's in new england
13:14:38 * pumpkin goes off to get some water
13:15:50 * Dae senses a joke he isn't getting
13:15:58 <kulakowski> mrd: boo
13:17:20 <pumpkin> dolio: when compiled on my latest GHC 7 (from a couple of days ago) it seems to work fine
13:17:32 <pumpkin> but when interpreted
13:17:44 <pumpkin> it behaves as he describes
13:18:19 <dolio> Is lambdabot interpreting as well?
13:18:38 <pumpkin> yeah, I think so
13:18:40 <dolio> Anyhow, when compiled I wouldn't be surprised if 'f $ x' gets turned into 'f x' when possible.
13:18:46 <pumpkin> yeah
13:18:49 <Palmik_> hmm... might be the reason that my parser in the form (myParser `endBy` (char '\n)) fails on (line 2, column 1) be that myParser eats trailing spaces (myParser indeed does that).
13:20:20 <applicative> > ($) sqrt (error "foo")
13:20:21 <lambdabot>   *Exception: foo
13:20:31 * hackagebot http-types 0.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.1 (AristidBreitkreuz)
13:20:42 <applicative> > (,) 3 (error "foo")
13:20:43 <lambdabot>   (3,*Exception: foo
13:21:01 <applicative> > ($) error (error "foo")
13:21:01 <lambdabot>   *Exception: *Exception: foo
13:21:22 <applicative> I'm not seeing the problem exactly. 
13:21:46 <dolio> > error (error "foo")
13:21:47 <lambdabot>   *Exception: foo
13:21:57 <dolio> That's a different error message.
13:22:18 <pumpkin> > id error (error "foo")
13:22:19 <lambdabot>   *Exception: *Exception: foo
13:22:24 <pumpkin> > error (error "foo")
13:22:25 <lambdabot>   *Exception: foo
13:22:31 <applicative> yes, it should be, shouldn't it. 
13:22:35 <dolio> Why?
13:23:11 <applicative> > ( (\f x -> f x) error) (error "foo") -- it's pretty complicated
13:23:11 <lambdabot>   *Exception: foo
13:23:22 <applicative> uh oh, 
13:24:12 <dolio> It's not a problem, because they're both bottoms. It's just weird.
13:24:35 <applicative> I thought I was understanding it with the analogy
13:24:46 <applicative> > (,) 3 (error "foo")
13:24:47 <pumpkin> I guess it has to do with what Antoine Latter just wrote
13:24:47 <lambdabot>   (3,*Exception: foo
13:25:02 <pumpkin> the compiler feels free to rearrange bottoms as it pleases (in unexpected ways) ?
13:25:11 <applicative> > ($) error (error foo)
13:25:12 <lambdabot>   Not in scope: `foo'
13:25:17 <applicative> > ($) error (error "foo")
13:25:18 <lambdabot>   *Exception: *Exception: foo
13:25:20 <dolio> Get this: in the interpreter, if you do "let g f x = f x ; g error (error "foo")" you get the double exception.
13:25:41 <dolio> If you do "let g f x = f x in g error (error "foo")", you get the single exception.
13:26:44 <dolio> Wow, K-lined.
13:27:32 <pumpkin> lpsmith is a bad person
13:29:04 <EvanR-work> i imagine klining to be metaphorically equivalent to sixteen military police busting in and brutally beating the hell out of the person
13:29:58 <EvanR-work> the character of the society rests on what kind of people get that kind of treatment and how often ;)
13:30:09 <applicative> if you say let foo = error "foo" then error foo gives the double exception
13:31:07 <dolio> > let foo = error "foo" in error foo
13:31:08 <lambdabot>   *Exception: foo
13:31:08 <monochrom> no, your character rests on what kind of unsubstantiated metaphors you imagine
13:31:45 <applicative> dolio, right, all in one line it does that.  I was replicating your distinction but with error "foo" rather than ($)
13:31:53 <dolio> Yeah. Weird.
13:32:02 <EvanR-work> its irc, everything is unsubstantiated
13:32:53 <edwardk> added distributive instances for compositions and products of distributive functors
13:33:03 <monochrom> yes, it's just irc, some admins banning someone or some IP is not remotely like either sixteen whatever or brutal beating
13:33:36 * hackagebot distributive 0.1.1 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.1.1 (EdwardKmett)
13:33:36 <monochrom> at best it's just some mall saying "you aren't welcome".
13:36:30 <dafis> > error undefined
13:36:31 <lambdabot>   *Exception: *Exception: Prelude.undefined
13:36:55 <scooty-puff> http://hpaste.org/43578/suggestions
13:37:04 <scooty-puff> does anyone have any code or style, or anything, suggestions?
13:37:14 <scooty-puff> a friend of mine used this as an example of haskell insanity
13:38:26 <monochrom> I think it's just fine. Nothing insane about it.
13:38:55 <monochrom> People always look at an example of foreign languages and say those are insane. Tautology.
13:39:46 <dafis> Well, I'd indent the <$> getU30 and so on a bit farther than the ABCFile, but that's just me
13:39:56 <monochrom> see also my http://article.gmane.org/gmane.comp.lang.haskell.cafe/44899/
13:40:55 <lewis> I am confused as to how to make a haskell program that will run in GHCi
13:41:42 <monochrom> you could just write functions in a file, then tell ghci to load that file, then you can use those functions at the prompt.
13:41:45 <jmcarthur> you mean a module you can load and play with in ghci?
13:42:01 <lewis> yes a module I can load and play with
13:42:25 <lewis> I attempted to make the one called Main.hs but to know avail
13:42:27 <jmcarthur> make a file named Foo.hs, make the first line "module Foo where", and write your definitions below
13:42:36 <monochrom> lewis: if you document what g does, it helps.
13:42:44 <monochrom> oops not lewis
13:42:44 <kamaji> or you could just do "ghci Main.hs"
13:43:00 <monochrom> scooty-puff: if you document what g does, it helps.
13:43:10 <lewis> ghci main.hs at the prompt?
13:44:11 <scooty-puff> monochrom, thanks
13:44:13 <scooty-puff> dafis, thanks
13:44:22 <kamaji> lewis: yeah
13:44:25 <kamaji> lewis: i.e. not inside ghci :P
13:44:37 <lewis> oh
13:44:38 <lewis> I got a not in scope reply
13:46:18 <lewis> where can I save such a text file so that I won't need to provide a path
13:46:43 <kamaji> lewis: in your current directory
13:46:45 <jmcarthur> you must be using windows
13:46:52 <lewis> osx
13:46:59 <lewis> 10.4.11
13:47:08 <jmcarthur> if you just cd into the correct directory then you won't have to provide long paths and stuff
13:48:14 <lewis> I have very little experience with computing. I was hoping to learn haskell to supplement my mathing
13:48:14 <jmcarthur> (same applies to windows. it's just that windows users tend to be more averse to this sort of thing)
13:48:18 <jmcarthur> ah
13:48:25 <monochrom> I hope your editor and your ghci are both using your home directory
13:48:28 <lewis> i have no idea what directory what that I am in
13:48:45 <jmcarthur> lewis: "cd /path/to/your/files/directory"
13:48:55 <jmcarthur> lewis: then you can just say "ghci Main.hs"
13:49:11 <glguy> Without a comment node in Template Haskell's Dec type, how do I generate haddock documentation for my generated data types?
13:49:14 <jmcarthur> lewis: and you can edit the file while ghci is running, then just type ":r" to reload the module after you save changes to it
13:49:44 <kamaji> jmcarthur: wat.
13:49:49 <kamaji> jmcarthur: that would have saved so much trouble :p
13:49:52 <jmcarthur> haha
13:50:12 <tolkad> I'm finding more and more that to ensure my code doesn't have ridiculous asymptotic runtime relative to input size I need to understand some ghc implementation details
13:50:22 <heatsink> Is there a library of statically sized lists?
13:50:27 <jmcarthur> lewis: and in the shell you can always use the "pwd" command to see what your current directory is
13:50:30 <jmcarthur> btw
13:50:49 <applicative> lewis, in the terminal, pwd tells you the directory.  inside ghc you add a :! Prelude> :! pwd
13:51:26 <applicative> rather inside ghci.  :! foo  goes outside ghci and tells the system to do foo
13:51:33 <heatsink> tolkad: What kind of details?
13:51:34 <lewis> ok now I have the directory
13:51:57 <tolkad> for example, although this is not asymptotic, parsec's oneOf uses the Prelude "elem" function. with a finite list of characters known at runtime, will they be tested sequentially or in a more optimal fashion?
13:52:01 <tolkad> known at compile time*
13:52:32 <lewis> before the change of directory do I need a colon?
13:52:42 <monochrom> for asymptotic costs you just need lazy evaluation. this is nothing ghc-specific since it's the same story with hugs jhc etc.
13:52:48 <Eduard_Munteanu> heatsink: um, tuples?
13:52:58 <monochrom> for the constant multiplier you will need ghc details.
13:53:06 <Eduard_Munteanu> Or do you mean stuff a-la dependent types with static guarantees?
13:53:21 <heatsink> tolkad: oh, you mean library implementation details
13:53:44 * hackagebot adjunctions 0.6.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.6.0 (EdwardKmett)
13:53:50 <tolkad> heatsink: no. I already checked the implementation of oneOf and it is implemented in terms of a Prelude function
13:53:55 <tolkad> "elem"
13:54:04 <applicative> lewis, are you inside ghci, or just inside Terminal.app?
13:54:04 <heatsink> tolkad: Prelude is a library
13:54:15 <lewis> inside ghci
13:54:55 <tolkad> heatsink: oh I thought Prelude functions were kind of magic in that ghc can optimize specifically on them
13:55:12 <applicative> then you do :cd  this is ghci specific, it just looks like the cd of the system.  :! cd would do something different
13:55:12 <Eduard_Munteanu> Primops and other stuff are magic though.
13:55:15 <heatsink> Eduard_Munteanu: I would like some static length guarantees.  I'd like to wrie a function f : (List n T1) -> (List n T2 -> IO T3) -> IO T4
13:55:56 <Eduard_Munteanu> There was stuff based on peanos, lemme remember...
13:56:24 <applicative> lewis, :cd ~/lewis/myhaskell should work. In general you should just open ghci when you're in the directory you want to be in
13:56:44 <heatsink> tolkad: You can even look at the source code of Prelude, there are links on http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Prelude.html
13:57:09 <Eduard_Munteanu> heatsink: this one IIRC: http://hackage.haskell.org/package/Vec
13:57:12 <heatsink> You're right that you need to know a lot of implementation details to avoid space leaks on large data.
13:57:16 <thoughtpolice> heatsink: there's someone (yav AKA iavor) working on integrating numeric types directly into GHC, so you don't have to encode shit with peano numbers etc
13:57:23 <applicative> lewis, if in ghci you do :? theres some helpful information, it could be a  little clearer.
13:57:31 <tolkad> oh, another question: this one can effect asymptotic runtime. What kind of expressions/thunks are saved once they have been evaluated once? any subexpression without free variables? any subexpression bound to a name? any subexpression bound to a top level name?
13:57:49 <applicative> lewis, what editor are you using to compose your module?
13:57:51 <tolkad> oh, another question: this one can effect asymptotic runtime. What kind of expressions/thunks are saved once they have been evaluated once? any subexpression without free variables? any expression bound to a name? any expression bound to a top level name?*
13:58:00 <lewis> text edit
13:58:07 <heatsink> thoughtpolice: Cool!
13:58:08 <tolkad> sorry those last two should have just been "expression" not "subexpression"
13:58:14 <thoughtpolice> so you can have types like f :: (x + y ~ z) => Bar x -> Foo y -> Baz z -> ... and it'll typecheck for example, if you have a 'Bar 5' a 'Foo 3' and a 'Baz 8'
13:58:26 <heatsink> Eduard_Munteanu: That looks like what I want, thanks!
13:59:04 <applicative> lewis, i see.  Something more programmerly would have an associated haskell package that would open the module in ghci automatically
13:59:37 <lewis> what do you recommend
14:00:22 <applicative> lewis, I'm trying to think of a free one that isnt vim or emacs :)  
14:00:39 <heatsink> tolkad: Any expression's value is a thunk.  All thunks are saved once they have been evaluted once.
14:00:54 <applicative> lewis, I use textmate a lot, very nice, but it's a pay app. you need to use git to get the haskell bundle
14:01:10 <lewis> I have heard of emacs, would that not work
14:01:20 <lewis> I will look into textmate
14:01:28 <tolkad> heatsink: subexpressions too?
14:01:29 <kamaji> lewis: you definitely want vim instead~
14:01:35 <applicative> lewis, it will, emacs is wonderful, but  grasping it is a major undertaking.
14:01:36 <lewis> vim
14:01:44 <lewis> ok
14:01:50 <heatsink> tolkad, yes
14:02:19 <lewis> Thank you for your time and patience. I will log out now and track vim down. thank you
14:02:29 <kamaji> lewis: the emacs/vim thing is a joke. You should pick whatever you think is best 
14:02:35 <applicative> lewis, i've never used vim , but the mac app version is stunningly beautiful compared to emacs i just noticed the other day.  The full screen font rendering made me want to cry
14:03:01 <Eduard_Munteanu> And since Vim is best, there isn't much to ponder upon :P
14:04:20 <Eduard_Munteanu> Actually I think there are lots of Emacs-ers around.
14:04:30 <tolkad> they should redesign all the old unix programs to be more like modern desktop apps
14:04:59 <tolkad> so vim would come with a feature to send tweet every time you edit a file
14:05:25 <scooty-puff> C-x C-t on mine
14:05:27 <Eduard_Munteanu> last.fm for coders? :P
14:05:27 * mauke won't link to vi(m)gor
14:05:27 <groovy2shoes> Since Vim is the best (and you agree with me, right?), no need to debate.
14:05:29 <scooty-puff> er, emacs
14:05:36 <tolkad> It's always annoying when applications don't integrate with social networking websites
14:05:49 <applicative> lewis, it occurs to me you can try textmate like any other app, you don't need git to get the haskell bundle the download button gives you zip of it https://github.com/textmate/haskell.tmbundle
14:05:52 * hackagebot http-types 0.1.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.1.1 (AristidBreitkreuz)
14:08:43 <applicative> lewis, the other obvious advantage of these proper editors is syntax highlighting, which actually does help comprehension.
14:09:17 <groovy2shoes> Syntax highlighting is overrated.
14:09:48 <applicative> groovy2shoes, I was implicitly agreeing. Only affirm that it was possible to under rate it
14:09:59 <ddarius> edwardk: Every representable functor preserves all limits if that's of any use.  (That's, ultimately, where adjoints get their continuity properties.)
14:12:59 <groovy2shoes> applicative: I know too many people who (for some reason) can't read code without the highlighting. I feel that most of the time, the highlighting is just a distraction. But occasionally I'll find a theme that's not distracting and actually helps me see what's going on.
14:14:17 <groovy2shoes> When my peers bitch about lack of highlighting, that's one of the times when I fear for the future of programming.
14:14:44 <edwardk> ddarius: yeah
14:15:49 <silver> Feyman used highlighting heavily 
14:15:53 <edwardk> ddarius: question, given f -| g, g is distributive (because of that limit property on the fact that it is representable), can you show that f is Traversable ?
14:15:53 <olsner> I almost can't read code without highlighting
14:15:54 <silver> Feynman
14:16:04 <olsner> it just becomes a heap of characters without meaning
14:16:21 <tolkad> groovy2shoes: highlighting is useful where it prevents you from having to read over an entire segment of code to understand its semantics
14:16:40 <tolkad> groovy2shoes: things like matching parentheses and string beginnings/endings
14:16:42 <heatsink> groovy2shoes: My field of vision for discriminating colors is much larger than my field of vision for discriminating characters.  I think that's a good reason for using syntax highlighting.
14:16:51 <silver> I think it depends on person
14:16:52 <applicative> lewis, but in any case, there's nothing wrong with text edit.  Just make a folder haskell say under your main directory lewis.   Save the files MyModule.hs in that folder. then in the Terminal do " cd haskell " to go to that directory , "ls " to show the files there .  then do " ghci MyModule.hs " to get the file loaded. 
14:17:14 <groovy2shoes> I don't disagree with those statements. But I've seen highlighting that uses a myriad of colors, and every little thing is colored.
14:17:15 <buttonsMagee> I guess color blind people make shit programmers then..
14:17:51 <silver> no!
14:18:06 <groovy2shoes> When my eyes are being bombarded by colors, I consider that a distraction.
14:18:07 <tolkad> groovy2shoes: I'd just like comments, strings, and keywords to be hilighted
14:18:24 <applicative> buttonsMagee, they just have to use red and green for the same syntactical features
14:18:59 <tolkad> groovy2shoes: that's just 4 colors total, hardly a bombardment
14:19:28 <tolkad> (5 if you include the background)
14:19:56 <kulakowski> I only find highlighting annoying when the syntax is so horrendous that it's prone to breaking.
14:20:14 <groovy2shoes> tolkad: those things are useful to be highlighted. It's nice to be able to quickly recognize where comments and strings start and end. When you start getting into random punctuation, variables, constants, etc., there's too much going on visually.
14:20:36 * applicative is highlighting the vowels separately like Rimbaud!
14:20:39 <tolkad> kulakowski: *cough* perl *cough*
14:21:04 <groovy2shoes> Perl is the ugliest language I've ever seen. Uglier than APL, even.
14:21:09 <kulakowski> tolkad: I was actually thinking of ruby, but yes. Is << a shift or a heredoc?
14:21:29 <tolkad> kulakowski: perl syntax depends on turing complete semantics
14:22:08 <edwardk> ddarius: i'd settle for Distributive as well ;)
14:22:27 <mauke> tolkad: so does C++ and Lisp
14:22:29 <mauke> meh.
14:22:37 <ion> groovy2shoes: Look at PHP some time. :-)
14:22:54 <groovy2shoes> ion: I've done lots of PHP. I still find Perl to be far uglier :p
14:23:07 <mauke> groovy2shoes: your opinion is now invalid
14:23:13 <tolkad> ion: parsing PHP isn't that bad though. when writing it you constantly feel like you are accommadating the parser
14:23:30 <tolkad> ion: it's like the PHP developers are morally opposed to syntatic sugar
14:23:31 <ddarius> edwardk: The question with Traversable is the same one as before with the monad transformers from UTF.
14:23:44 <edwardk> ddarius: was kind of afraid of that
14:24:11 <edwardk> ddarius: so i can at least provide class (Functor f, Distributive g) => Adjunction f g | f -> g, g -> f where
14:24:16 <groovy2shoes> sub hello { my ($name) = @_ ; print 'hello, ' . name; 1 }   versus   function hello($name) { print 'hello, ' . name; }
14:24:22 * applicative thinks ""J'inventai la couleur des voyelles ! - A noir, E blanc, I rouge, O bleu, U vert."
14:24:31 <mauke> groovy2shoes: I'm pretty sure that's a syntax error in php
14:24:41 <mauke> groovy2shoes: also, why the 1 in perl?
14:24:47 <edwardk> and then just have the traversable hold for all the ones i happen to actually have found so far
14:24:57 * applicative was unaware there were syntax errors in php.  that would be so constraining
14:25:06 <tolkad> mauke: no, that's not a syntax error
14:25:20 * applicative caused anger on stack overflow when he pointed out there are no syntax errors in Markdown.
14:25:22 <sproingie> print "hello $name", which works in both.  php got formal args, that's about all it managed to improve on
14:25:26 <mauke> ah, I see
14:25:27 <groovy2shoes> mauke: because that's part of our conventions at work. "Make your subs always explicitly return some value." ugh.
14:25:35 <tolkad> mauke: PHP will look for a constant named "name", if it can't find it, it will throw a notice and use the string "name"
14:25:38 <mauke> groovy2shoes: print returns some value
14:25:46 <tolkad> mauke: it will always print "hell, name"
14:25:56 <tolkad> mauke: it will always print "hello, name"
14:26:02 <mauke> tolkad: nice
14:26:19 <sproingie> perl at least has 'use strict' that forbids barewords 
14:26:34 <groovy2shoes> mauke: frowned upon. A lot of B.S. if you ask me. I'd still rather look at named parameters and avoid "pronouns" in my code.
14:26:51 <sproingie> if php works for you, rock on with it
14:26:52 <mauke> groovy2shoes: yes, named parameters would be a big improvement
14:26:52 <hpc> barewords are evil
14:27:10 <ion> And Perl has had stuff like namespaces and closures for ages. :-)
14:27:20 <groovy2shoes> I'm not saying I like PHP, just that I think Perl is uglier. Of course that's completely opinion.
14:27:20 <sproingie> it's a bucket of poop for me and everyone else who has to work with its utterly broken _semantics_
14:27:22 <mauke> still, sub f { my ($x, $y, $z) = @_; ... } instead of sub f($x, $y, $z) { ... } is not so bad. it's just annoying to type
14:27:42 <hpc> perl is uglier, but it's fun
14:27:47 <sproingie> and it's not broken
14:28:07 <hpc> yeah, you can make a script in it without your server getting shitcanned
14:28:11 <groovy2shoes> It's not a betterness contest, just a prettierness one.
14:28:24 <mauke> groovy2shoes: php is ugly on the inside :-(
14:28:44 <groovy2shoes> mauke: Yeah... :/
14:28:50 <mauke> I curse every time I want to do a regex search/replace
14:29:15 <applicative> mauke how do you do regex replace in haskell?
14:29:37 <tolkad> one ugly thing about haskell is when people are porting libraries from other languages and want to keep the constant naming conventions so they end up with cONSTANT nAMES lIKE tHIS
14:29:53 <hpc> oH gOD wHY
14:29:58 <Twey> Ha
14:30:04 <Twey> Not Haskell's fault, mind :þ
14:30:06 <hpc> CAP_CONSTANTS are evil
14:30:09 <mauke> applicative: I don't
14:30:27 <groovy2shoes> tolkad: that reminds me of some C code I saw years back, where the programmer did #define begin {   and   #define end }
14:30:41 <applicative> mauke, I figured.  It's funny the regex libraries don't seem to support anything like it, or not when I looked.
14:30:54 <kulakowski> hpc: I find them ok in languages that lack the semantics to enforce constancy, so they fall back to a social convention.
14:31:44 <tolkad> groovy2shoes: #define parameter_list_begin (\n#define parameter_list_end )
14:31:45 <hpc> huh, it might be a good project to write a regex replace monad
14:31:45 <applicative> tolkad, maybe if they just put an 'h' in front of everything?  or just replaced the first letter with h?  Or are you tired of that joke.
14:31:58 <hpc> either using regexes or parsec
14:32:11 <applicative> hpc, how would it be a monad?  Im thinking...
14:32:28 <mauke> applicative: I haven't found a good regex library yet, but then I haven't really looked either
14:32:38 <hpc> applicative: well, you would want to be able to programatically manipulate $1-$9
14:32:39 <tolkad> applicative: that would conflict with the naming convention for functions relating to handles
14:32:43 <hpc> before putting them back
14:32:53 <hpc> like the /e flag of perl regexes
14:33:03 <mauke> hpc: why limit to $9?
14:33:12 <mauke> hpc: the /e flag doesn't affect regexes; it's part of the s/// operator
14:33:15 <mauke> FDJSKAJDF
14:33:15 <groovy2shoes> tolkad: some people get very uncomfortable outside of some language. My friend  said, "People get very uncomfortable when you take away their curly braces." ;)  Although he was talking about Python.
14:33:17 <hpc> mauke: i wouldn't, but using the perl example
14:33:18 <tolkad> hpc: yeah after $9 it becomes ${10}
14:33:26 <mauke> no, $10
14:33:28 <mauke> WHY THE { }
14:33:50 <hpc> mauke: s/// is the behavior we are talking about replicating
14:34:08 <mauke> yes
14:34:41 <hpc> so /e would be a useful flag to have the behavior of
14:34:42 <tolkad> groovy2shoes: maybe we could just define XML schemas for programming language syntax, then people could have their editors render it however they want
14:34:58 <mauke> hpc: trivial, just pass a function as the replacement part
14:34:58 <tolkad> groovy2shoes: Plus, I mean, we would be using XML, it would be enterprise-ready
14:35:12 <groovy2shoes> tolkad: lol
14:35:13 <mauke> hpc: javascript does this
14:35:17 <ddarius> tolkad: Ideas like that have come up again and again.
14:35:25 <mauke> perl doesn't because it's weird and because s/// is older than functions
14:36:06 <hpc> mauke: so if we want to pass $1, $2, and $5, how do we specify those are the parameters?
14:36:15 <hpc> or use a struct-y ADT?
14:36:28 <mauke> wat
14:36:34 <hpc> like
14:36:35 <mauke> you pass a list of captures
14:36:41 <hpc> ah
14:37:18 <hpc> huh, that would work
14:37:21 <mauke> [Maybe (Int, Int, String)]
14:37:31 <mauke> that looks bad
14:37:44 * hpc somehow got in his head that there was more context to a regex than captures
14:37:52 <mauke> [Maybe (Int, ByteString)]
14:37:53 <mauke> better
14:38:02 <hpc> why Maybe?
14:38:10 <mauke> (a)|b
14:38:15 <hpc> oh
14:38:37 <hpc> neat, and that would differentiate between ignored capture and empty capture
14:39:03 <mauke> this is pretty no-brainy so far
14:39:17 <mauke> perl gives me undef there, which translates to Nothing in haskell
14:39:36 <mauke> the Int is the match offset
14:40:51 <hpc> then to line everything up stylistically, you would have a function r :: String -> [Match] -> String
14:41:06 <hpc> where the first parameter is something like "foo$1:$2" or whatever
14:41:22 <mauke> do we really need to have this? :-/
14:42:00 <hpc> so s/foo(bar)(baz)/foo$1:$2/ translates into similar-looking code
14:42:35 <mauke> I don't consider that desirable
14:42:50 <ddarius> edwardk: Adjoint functors are usually not themselves representable (they usually aren't Set valued to start.)
14:42:52 <mauke> we don't even have variables called $1 and $2
14:43:03 <mauke> so why use that syntax?
14:43:18 <nlogax> weird. installing pandoc with -fhighlighting works fine, pandoc -v says it's all good. then after installing hakyll, i have the same version of pandoc, but without highlighting
14:43:33 <hpc> mauke: historical reasons
14:43:40 <nlogax> so it never works in hakyll. any ideas what i'm doing wrong? :)
14:43:44 <mauke> historical would be using \1 and \2
14:43:53 <hpc> ah, well that then
14:43:58 <mauke> no
14:44:15 <mauke> then you'd have to write "\\1:\\2" and \\\\ to insert a single \
14:44:39 <hpc> if "historical reasons" is not a good reason, people would just learn parsec
14:44:55 <ddarius> People usually just learn Parsec.
14:44:56 <hpc> i personally prefer perl's regex style
14:45:51 <hpc> for simple stuff, parsec is more verbose than regexp
14:45:59 <ddarius> and slower
14:46:04 <mauke> and less powerful
14:46:07 <mauke> and can't replace
14:47:16 <dolio> I thought \1 and the like were only used for those non-regular 'regex' abominations, for referring to captures earlier in the expression.
14:47:45 <mauke> in the regex itself, yes
14:47:51 <jix> hmm is it correct that cabal test is pretty stupid in the current released version?
14:47:59 <ddarius> dolio: Aren't most modern "regex" libraries "non-regular abominations"?
14:48:02 <mauke> but some programs also use them in the replacement part
14:48:10 <dolio> ddarius: Yes, unfortunately.
14:48:34 <Pseudonym> There is a difference between "regular expression" and "regex".
14:48:44 <jix> so what would be the best way to bundle tests in a cabal package?
14:49:03 <ddarius> "regex" - "recursively enumerable generating expression"
14:49:52 <mauke> oh, btw: preflex has a re command with a completely non-standard syntax
14:50:19 <ddarius> Completely non-standard syntax!  Sounds positively delightful!
14:50:33 <mauke> you don't know half of it
14:50:52 <hpc> preflex: help re
14:50:53 <preflex>  re "REGEX" STRING - test STRING against REGEX
14:50:59 <hpc> how specific
14:51:06 <mauke> awesome features (part 1): to escape a character, you write X!, not \X
14:51:08 <jix> Hmm calling runhaskell from Setup.hs to run the tests seems to be the nicest solution right now
14:51:11 <mauke> also, everything is a valid regex
14:51:25 <hpc> preflex: re "123" 12345
14:51:26 <preflex>  match: [0-3: 123]
14:51:46 <hpc> preflex: re "*.$%8*#x" 5
14:51:47 <preflex>  no match
14:51:49 <hpc> lol
14:52:28 <mauke> I'mma continue in #haskell-blah
14:53:16 <jonkri> mm_freak: if you don't mind me asking you directly about what we were talking about yesterday: why do i want a monad at all for logging when i can just spawn a thread and use a channel for the log entries?
14:54:58 <dcoutts> jix: Cabal 1.10 has much improved test support, but if you need compatibility then you'll have to stick to the old method for the moment
14:56:28 <jix> dcoutts: is cabal 1.10 released?
14:56:43 <rphl> excuse me, i am new to haskell - can anyone please tell me if the GHC uses haskell 2010 or 98?
14:56:45 <jix> I guess i'd switch as soon as it's in the current haskell platform
14:57:00 <rphl> GHC in ubuntu repos, sorry
14:57:30 <dcoutts> jix: right, wait for the next HP release
15:00:54 <edwardk> @pl \f k -> k f
15:00:54 <lambdabot> flip id
15:01:45 <tolkad> it's kind of strange that certain libraries have < 1.0 version numbers
15:02:22 <tolkad> even the really essential ones like bytestring, containers, and array
15:02:30 <tolkad> packages*
15:02:43 <edwardk> tolkad: bos mentioned once he always starts down there, then never really feels they are finished
15:03:15 <edwardk> ddarius gives me crap than i never ship a 1.0 library either. (so i mixed it up and started marking a few things 1.0) ;)
15:03:16 <olsner> the 1.0 release is the one that removes the entire library because it's deprecated :)
15:03:30 <edwardk> er that i
15:06:05 <jmcarthur> what the heck does 1.0 even mean? it just means you changed everything beyond recognition, to me
15:06:27 <tolkad> jmcarthur: it usually means that the software is out of beta
15:06:39 <jmcarthur> not with a sane version numbering policy
15:06:45 <jmcarthur> like, where it's not arbitrary
15:07:23 <tolkad> jmcarthur: it's not arbitrary, you just increment it whenever you want customers to have to buy it
15:07:27 <jmcarthur> i mean, it could be that you suddenly switch policies once you hit 1.0
15:07:28 <hpc> edwardk: you should make the first release 1.0
15:07:39 <hpc> then add a digit with each release
15:07:45 <jmcarthur> exactly! the number has nothing to do with the software and everything to do with marketing
15:07:47 <hpc> so the next version is 12.0
15:07:53 <jmcarthur> at least with that numbering scheme
15:08:01 <hpc> and in a few years, 123456789.0
15:08:09 <jmcarthur> do it knuth style
15:08:19 <jmcarthur> 3, 3.1, 3.14, etc.
15:09:16 <tolkad> jmcarthur: still, I think < 1.0 meaning the software is still in development and not ready for production or use in code that you want to advertise as "stable" is a useful convention
15:09:27 <tolkad> jmcarthur: especially since it is already widely interpreted that way
15:09:37 <jmcarthur> it's okay from a marketing standpoint
15:09:39 <jonkri> i usually call the first product i consider "finished" and "marketable" 1.0, and the first usable version 0.1
15:09:48 <jmcarthur> it's just not very informative aside from "it's not done"
15:09:52 <jmcarthur> but when it is *ever* "done"?
15:10:09 <tolkad> jmcarthur: it's not that it's not "done", it's that it's not "stable"
15:10:25 <tolkad> jmcarthur: 1.0 is the first stable release
15:10:25 <hpc> i take 1.0 to be "this is everything i wanted to code when i started this project"
15:10:26 <jmcarthur> those are the same thing, to me
15:10:33 <jonkri> how can i rewrite a "StateT Int IO ()" function "do { return () }" so that it doesn't use do?
15:10:42 <ddarius> jmcarthur: Knuth already has π.  I recommend γ.
15:10:49 <hpc> jonkri: remove the do?
15:10:57 <jmcarthur> ha!
15:11:00 <hpc> @unpl do {return ()}
15:11:01 <lambdabot> do { return ()}
15:11:04 <jmcarthur> one-upping knuth
15:11:04 <hpc> er
15:11:09 <hpc> @undo do {return ()}
15:11:09 <lambdabot> return ()
15:11:28 <tolkad> @unpl const const const const const const const const const const const const const
15:11:28 <lambdabot> (\ l _ -> l)
15:11:39 <hpc> ddarius: power sets of the digits of pi!
15:11:41 <jonkri> i thought i tried that, sorry all
15:11:53 <tolkad> @unpl fix id
15:11:54 <lambdabot> fix (\ a -> a)
15:11:58 * jonkri has decided to try to avoid do
15:11:59 <tolkad> aww
15:12:10 <tolkad> who told unpl to ignore fix?
15:12:38 <shachaf> > fix unpl
15:12:40 <lambdabot>   Done.
15:12:41 <hpc> tolkad: i thought it always was like that
15:12:57 <tolkad> hpc: some devious person must have coded it like that though
15:13:04 <Jesin> ??
15:13:13 <hpc> i thought it was just that unpl didn't build let expressions
15:13:14 <jmcarthur> :t unpl
15:13:14 <lambdabot> Not in scope: `unpl'
15:13:20 <jmcarthur> shachaf: wtf?
15:13:21 <hpc> which is what you need to make it work
15:13:34 <shachaf> What?
15:13:40 <jmcarthur> > fix unpl
15:13:41 <lambdabot>   Not in scope: `unpl'
15:13:53 <Jesin> @help fix
15:13:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:14:07 <Jesin> :t fix
15:14:08 <lambdabot> forall a. (a -> a) -> a
15:14:10 <hpc> @src fix
15:14:11 <lambdabot> fix f = let x = f x in x
15:14:13 <jmcarthur> > fix unpl
15:14:15 <lambdabot>   Done.
15:14:17 <jmcarthur> ha!
15:14:22 <hpc> or more readably, fix f = f (fix f)
15:14:30 <Jesin> ..
15:14:40 <Jesin> what did you do jmcarthur
15:14:41 <jmcarthur> shachaf: i'm on to your games
15:14:42 <dafis> > fix unpl
15:14:42 <lambdabot>   Not in scope: `unpl'
15:14:44 <tolkad> > fix unpl
15:14:45 <lambdabot>   Not in scope: `unpl'
15:14:49 <tolkad> > fix unpl
15:14:50 <lambdabot>   Not in scope: `unpl'
15:14:51 <jmcarthur> :D
15:14:52 <dafis> @src fix
15:14:52 <lambdabot> fix f = let x = f x in x
15:14:54 <dafis> > fix unpl
15:14:55 <lambdabot>   Not in scope: `unpl'
15:15:01 <Jesin> D:
15:15:10 <jmcarthur> you guys are just doing it wrong
15:15:10 <dafis> :t fix
15:15:11 <lambdabot> forall a. (a -> a) -> a
15:15:14 <tolkad> some unicode trick?
15:15:16 <Jesin> > fix my brain
15:15:17 <lambdabot>   Not in scope: `my'Not in scope: `brain'
15:15:29 <jmcarthur> i shall not tell
15:15:29 <tolkad> oh wait I have an idea
15:15:36 <jmcarthur> tolkad: you probably got it then ;)
15:15:46 <Jesin> [18:30:44]	<hpc>	or more readably, fix f = f (fix f)
15:15:46 <dafis> > fix unpl
15:15:47 <lambdabot>   Not in scope: `unpl'
15:15:47 <Jesin> yes, why is it not implemented like this?
15:15:54 <Jesin> is it harder to inline, or some such?
15:16:01 <hpc> Jesin: sharing, i would guess
15:16:10 <Jesin> hmm
15:16:13 <Jesin> explain?
15:16:21 <hpc> the let version makes it clear to the compiler not to recompute the previous element
15:16:31 <jmcarthur> Jesin: bound variables are always shared
15:16:42 <jmcarthur> Jesin: if it's not bound, it's not shared. decent rule of thumb at least
15:16:49 <hpc> take fix (1:)
15:16:58 <hpc> or better,
15:17:03 <hpc> fix (complexThing:)
15:17:08 <hpc> where complexThing ultimately is 1
15:17:15 <hpc> so it computes x, which is 1
15:17:26 <hpc> then it appends fix f
15:17:43 <jmcarthur> Jesin: so, in fix f = f (fix f), since "fix f" isn't bound to anything, it's not shared
15:17:44 <hpc> which needs to calculate x
15:17:50 <hpc> but yay! it's already 1
15:17:56 <jmcarthur> Jesin: but in let x = f x, x is shared! :D
15:19:00 <dafis> @let nfix f = f (nfix f)
15:19:00 <lambdabot>  Defined.
15:19:25 <tolkad> > fix unpl
15:19:26 <lambdabot>   Not in scope: `unpl'
15:19:36 <hpc> > nfix (100! `seq` 1:)
15:19:37 <lambdabot>   <no location info>: parse error on input ``'
15:19:43 <hpc> > nfix (100! `seq` (1:))
15:19:44 <lambdabot>   <no location info>: parse error on input ``'
15:19:45 <tolkad> > fix unpl
15:19:46 <lambdabot>   Not in scope: `unpl'
15:20:02 <tolkad> > fix unpl
15:20:03 <lambdabot>   "Done."
15:20:12 <tolkad> yup, got it
15:20:35 <hpc> :t unpl
15:20:36 <tolkad> you just found some wrapper data type around string with a different show instance?
15:20:36 <lambdabot> Not in scope: `unpl'
15:20:41 <tolkad> jmcarthur: that it?
15:20:41 <hpc> wait, wtf?
15:21:34 <dafis> > let fibs = nfix ((0:) . scanl1 (+) . (1:)) in fibs !! 20
15:21:35 <lambdabot>   Not in scope: `nfix'
15:21:49 <dafis> @let nfix f = f (nfix f)
15:21:50 <lambdabot>  Defined.
15:21:52 <dafis> > let fibs = nfix ((0:) . scanl1 (+) . (1:)) in fibs !! 20
15:21:54 <lambdabot>   6765
15:22:00 <int80_h> hey daif, I'm putting together an hpaste. You going to be around?
15:22:03 <dafis> > let fibs = nfix ((0:) . scanl1 (+) . (1:)) in fibs !! 23
15:22:04 <lambdabot>   Not in scope: `nfix'
15:22:04 <int80_h> erm
15:22:09 <dafis> @let nfix f = f (nfix f)
15:22:09 <lambdabot>  Defined.
15:22:12 <dafis> > let fibs = nfix ((0:) . scanl1 (+) . (1:)) in fibs !! 23
15:22:13 <lambdabot>   Not in scope: `nfix'
15:22:16 <hpc> wtf?
15:22:18 <int80_h> dafis, I'm putting together an hpaste. You going to be  around?
15:22:27 <dafis> int80_h: for a bit
15:22:27 <hpc> who keeps calling @undefine?
15:22:34 <dafis> @let nfix f = f (nfix f)
15:22:35 <lambdabot>  Defined.
15:22:38 <dafis> > let fibs = nfix ((0:) . scanl1 (+) . (1:)) in fibs !! 23
15:22:39 <lambdabot>   Not in scope: `nfix'
15:22:50 <dafis> wtf
15:23:14 <dafis> > let nfix f = f (nfix f); fibs = nfix ((0:) . scanl1 (+) . (1:)) in fibs !! 23
15:23:16 <lambdabot>   28657
15:23:24 <tolkad> that was hilarious
15:23:24 <dafis> > let fibs = fix ((0:) . scanl1 (+) . (1:)) in fibs !! 23
15:23:26 <lambdabot>   28657
15:23:46 <Jesin> hmm
15:23:48 <Jesin> so
15:23:54 <hpc> > let fix f = f (fix f); fibs = fix ((0:) . scanl1 (+) . (1:)) in fibs !! 23
15:23:55 <lambdabot>   28657
15:24:04 <hpc> > let fix f = f (fix f); fibs = fix ((0:) . scanl1 (+) . (1:)) in fibs !! 25
15:24:05 <lambdabot>   75025
15:24:07 <Jesin> fix f = let x = f x in x
15:24:15 <hpc> > let fix f = f (fix f); fibs = fix ((0:) . scanl1 (+) . (1:)) in fibs !! 50
15:24:17 <lambdabot>   12586269025
15:24:21 <hpc> hmm
15:24:48 <Jesin> hmm, k  :p
15:24:52 <dafis> lambdabot compiles stuff, doesn't it?
15:24:55 <tromp_> is there a largest common prefix function?
15:24:55 <tolkad> > error "test"
15:24:56 <lambdabot>   *Exception: test
15:25:02 <tolkad> > error "\n"
15:25:03 <lambdabot>   *Exception:
15:25:05 <int80_h> http://hpaste.org/43582/best_way_to_capture_cookies
15:25:14 <tolkad> > error "\nquit"
15:25:14 <dafis> so the optimiser shares nfix f
15:25:15 <lambdabot>   *Exception:
15:25:15 <Jesin> > putStr "test"
15:25:15 <lambdabot>  quit
15:25:16 <lambdabot>   <IO ()>
15:25:36 <tolkad> > error "\n\n\n\n\n\n\n\n\n\nlol"
15:25:37 <lambdabot>   *Exception:
15:25:37 <lambdabot>  
15:25:37 <lambdabot>  lol
15:25:41 <hpc> lol
15:25:54 <tolkad> > error (replicate "\nlol" 10)
15:25:55 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:25:55 <lambdabot>         against inferred type ...
15:26:00 <tolkad> > error (replicate 10 "\nlol")
15:26:01 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:26:01 <lambdabot>         against inferred type...
15:26:11 <tolkad> > error (concat $ replicate 10 "\nlol")
15:26:12 <lambdabot>   *Exception:
15:26:12 <lambdabot>  lol
15:26:12 <lambdabot>  lol
15:26:12 <lambdabot>  lol
15:26:12 <lambdabot>  lol
15:26:14 <lambdabot> [6 @more lines]
15:26:15 <davekong> ?
15:26:22 <tolkad> @more
15:26:22 <lambdabot>  lol
15:26:23 <lambdabot>  lol
15:26:23 <lambdabot>  lol
15:26:23 <davekong> stop the abuse
15:26:24 <lambdabot>  lol
15:26:26 <lambdabot>  lol
15:26:28 <lambdabot>  lol
15:26:29 <Jesin> > error $ join $ repeat
15:26:30 <lambdabot>   Ambiguous occurrence `error'
15:26:32 <lambdabot>  It could refer to either `L.error', defined a...
15:26:32 <applicative> nlogax, what version of pandoc was installed with hakyll?
15:26:35 <dafis> int80_h: can you insert line breaks?
15:26:37 <tolkad> > error (concat $ replicate 1000 "\nlol")
15:26:38 <lambdabot>   Ambiguous occurrence `error'
15:26:38 <lambdabot>  It could refer to either `L.error', defined a...
15:26:40 <Jesin> I intentionally didn't finish that
15:26:43 <int80_h> dafis, sure
15:26:44 <tolkad> @undef
15:26:46 <tolkad> > error (concat $ replicate 1000 "\nlol")
15:26:46 <lambdabot>   *Exception:
15:26:46 <lambdabot>  lol
15:26:47 <lambdabot>  lol
15:26:47 <lambdabot>  lol
15:26:47 <lambdabot>  lol
15:26:47 <Jesin> that would've been horrible
15:26:48 <lambdabot> [9 @more lines]
15:26:49 <Jesin> :p
15:26:51 <tolkad> @more
15:26:51 <lambdabot>  lol
15:26:52 <lambdabot>  lol
15:26:53 <Saizan> tolkad: stop plese.
15:26:54 <lambdabot>  lol
15:26:56 <lambdabot>  lol
15:26:57 <Saizan> *please.
15:26:58 <lambdabot>  lol
15:27:00 <tolkad> ok
15:27:00 <lambdabot> [4 @more lines]
15:27:12 <Jesin> @undefine
15:27:15 <Jesin> @clear
15:27:15 <lambdabot> Messages cleared.
15:27:16 <int80_h> daifs, what do you mean by line breaks?
15:27:20 <Jesin> ...
15:27:23 <Jesin> @help clear
15:27:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:27:27 <Jesin> ...
15:27:30 <Jesin> @help @clear
15:27:30 <int80_h> dafis, what do you mean by line breaks?
15:27:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:27:34 <Jesin> @help help
15:27:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:27:39 <Saizan> Jesin: you too
15:27:47 <wagle> hi -- is there an editor around that refactors haskell?
15:27:54 <Jesin> it doesn't @help though...  =/
15:28:08 <dafis> int80_h: your explanations, not the code, I have to scroll horizontally until I'm halfway to Siberia
15:28:12 <tolkad> @help pl
15:28:12 <lambdabot> pointless <expr>. Play with pointfree code.
15:28:25 <tolkad> it works, it just doesn't have help files for all commands
15:28:29 <nlogax> applicative: 1.8.0.1, same as before, but without highlighting
15:29:04 <nlogax> applicative: so it reinstalls it for some reason i can't figure out
15:29:12 <Jesin> k
15:29:21 <Jesin> hmm
15:29:39 <Jesin> does lambdabot do data or newtype declarations?
15:29:46 <tolkad> it does not
15:29:46 <applicative> nlogax, i'm trying to replicate it. just as sec
15:29:48 <Jesin> k
15:29:58 <tolkad> has plenty in scope though
15:30:18 <tolkad> whatever you want is probably in scope
15:31:04 <nlogax> applicative: did the same thing on my rackspace VPS (debian), worked just fine there. locally (OS X) it always reinstalls :)
15:31:09 <dafis> int80_h: nevermind, it was only the three lines
15:32:18 <applicative> nlogax, did you try both at once, that seems to be working:  cabal install hakyll pandoc -fhighlighting
15:32:29 <nlogax> applicative: i did not! will try
15:33:24 <int80_h> http://hpaste.org/43584/best_way_to_capture_cookies_f
15:33:30 <int80_h> dafis, doh, I fixed it
15:34:26 <int80_h> dafis, also what I need most is to think through what needs to be done. 
15:35:16 <elliott> What's the point-free Applicative way to write ((<$> f) . (:<)) =<< g?
15:35:37 <Jesin> hmm
15:35:40 <DevHC> @pf ((<$> f) . (:<)) =<< g
15:35:40 <lambdabot> Maybe you meant: bf pl
15:35:42 <Jesin> what's (:<)?
15:35:47 <Jesin> anything special?
15:35:57 <sipa> @pl \f g -> (((<$> f) . (:<)) =<< g)
15:35:57 <lambdabot> (=<<) . (. (:<)) . flip (<$>)
15:36:55 <elliott> Jesin: no
15:37:01 <elliott> just a binary op I defined
15:37:02 <applicative> nlogax, that seems to have worked here. I hadn't installed the shiny new pandoc yet as it happened. 
15:37:06 <elliott> nothing Applicative-related or anything
15:37:11 <Jesin> hmm
15:37:11 <heis> I'm in the beginning stages of working out Monad Transformers for myself, and I'm trying not to reference the official sources).  Can StateT be made by combining ReaderT and WriterT?
15:37:17 <elliott> sipa: the point is to get rid of the =<< which is Monad only :)
15:37:27 <sipa> oh
15:37:30 <elliott> I may bite the bullet and just make it non point-free, but ew. :(
15:37:39 <Jesin> umm
15:37:47 <elliott> heis: why not consult the official sources?
15:37:47 <Jesin> how about you give us the non-pointfree version
15:37:50 <Jesin> and we pointfree it?
15:37:59 <elliott> heis: I *think* so put don't quote me on that.
15:38:05 <Jesin> umm
15:38:11 <Jesin> what kind of monad is g, anyway?
15:38:17 <heis> elliot: I'm trying to figure them out from my own understanding.  It's an exercise.
15:38:17 <elliott> What kind of monad? Eh?
15:38:21 <Jesin> it's just general
15:38:24 <elliott> heis: Alright.
15:38:27 <elliott> Jesin: I don't understand.
15:38:28 <Jesin> ok, I was just wondering what the context was
15:38:45 <Jesin> you're probably making a function to work with general Applicatives though
15:38:46 <dafis> int80_h: in curlResp, you get the CurlResponse, resp. The easies thing would be to let hdr = respHeaders resp; newCookies = getCookiesFromHeader hdr; then, liftIO (unless (null newCookies) (appendFile "cookies.txt" $ unlines newCookies))
15:38:48 <elliott> Well, in do notation it's (do x <- g; xs <- pUL; return (x :< xs))
15:38:49 <Jesin> hmm
15:38:53 <jmcarthur> :t \f g -> ((<$> f) . (:<)) =<< g
15:38:54 <elliott> But of course that is Monad-only too because do notation is.
15:38:54 <lambdabot> Not in scope: data constructor `:<'
15:38:58 <nlogax> applicative: that worked here too! thanks a lot :)
15:39:01 <jmcarthur> doh
15:39:03 <elliott> just swap h in for (:<)
15:39:04 <Jesin> @unpl ((<$> f) . (:<)) =<< g
15:39:04 <lambdabot> (g >>= \ d -> (((:<)) d) <$> f)
15:39:22 <Jesin> @undo do x <- g; xs <- pUL; return (x :< xs)
15:39:22 <lambdabot> g >>= \ x -> pUL >>= \ xs -> return (x :< xs)
15:39:53 <jmcarthur> elliott: liftA2 (:<) g pUL  -- you want something like this?
15:40:17 <Jesin> @unpl liftA2 (:<) g pUL
15:40:18 <lambdabot> liftA2 (:<) g pUL
15:40:19 <elliott> jmcarthur: quite possibly
15:40:24 <elliott> @do liftA2 (:<) g pUL
15:40:24 <lambdabot> liftA2 (:<) g pUL
15:40:28 <elliott> hmph
15:40:29 <tromp_> @pl \f g s -> f s && g s
15:40:30 <lambdabot> liftM2 (&&)
15:40:56 <jonkri> is this tutorial outdated or something? search for "stateIntString = State fromStoAandS", that code gives me an error about State data constructor not in scope (:k State works though)
15:40:56 <jmcarthur> :t liftA2
15:40:57 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
15:41:04 <Jesin> @src liftM2
15:41:04 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:41:06 <elliott> jmcarthur: woo, now it's point-free and unreadable!
15:41:09 <elliott> but at least i lost a pair of parents
15:41:12 <elliott> ~so happy~
15:41:14 <jmcarthur> elliott: unreadable?
15:41:19 <Jesin> WAIT I think I got it
15:41:21 <Jesin> hmm
15:41:23 <elliott> jmcarthur: well, it's in a parsec parser
15:41:25 <int80_h> dafis, thanks that helps alot!
15:41:37 <elliott> "liftM2 (:>) (char '(' *> pUL <* char ')') pUL" is not the height of readability :)
15:41:45 <jmcarthur> sure it is
15:41:49 <Jesin> [18:55:10]	<elliott>	Well, in do notation it's (do x <- g; xs <- pUL; return (x :< xs))
15:41:52 <Jesin> ok yeah
15:41:52 <dafis> int80_h: http://hpaste.org/paste/43584/capture_cookies#p43585
15:41:57 <Jesin> that looks like liftA2
15:41:59 <elliott> yeah
15:42:05 <Jesin> and, well
15:42:07 <elliott> jmcarthur: well, I guess it's reasonably enough ordered, yeah.
15:42:16 <applicative> nlogax, oh good. I"m using hakyll too as it happens. 
15:42:18 <jmcarthur> you can use some newlines to help a bit
15:42:21 <dafis> int80_h: to write getCookiesFromHeader is left as an exercise for the reader
15:42:35 <Jesin> liftA2 f a b = f <$> a <*> b
15:42:40 <jmcarthur> i find that it's normally just grouping that throws me off, and if i can make that obvious enough then it's fine
15:43:11 <jmcarthur> the parts in isolation are certainly easy to understand
15:43:14 <int80_h> dafis: I can do that. I like exercies, if I know what I am supposed to be doing.
15:43:38 <jmcarthur> you use pUL inside a couple parens, pUL by itself, and put them together with :>
15:44:08 <dafis> int80_h: and I haven't the foggiest how to get cookies from a header, I don't kow the protocol ;)
15:44:15 <dafis> know*
15:44:24 <int80_h> dafis, that I can do. I just needed to capture the headers
15:44:40 <int80_h> which i needed help on, and you provided. So thanks again. :)
15:44:59 <dafis> int80_h: I give no guarantees, let me know if it worked
15:45:57 <Jesin> :k [::]
15:45:58 <lambdabot> parse error on input `::'
15:45:58 <int80_h> dafis, sure no problem. It looks right. If you message me your email I can let you know that way. I realize we are in different time zones and you are prolly about to go to sleep where I am just getting started.
15:46:03 <tromp_> :t join
15:46:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:46:15 <Jesin> I was just looking at the list of Monad instances
15:46:22 <int80_h> plus, my work day doesn't being until noon or so
15:46:23 <Jesin> and apparently [::] is one of them?
15:46:25 <Jesin> but
15:46:32 <Jesin> I can't find anything about what [::] means
15:46:37 <Jesin> :k ([::])
15:46:38 <lambdabot> parse error on input `::'
15:46:39 <Jesin> hmm.
15:46:40 <dafis> int80_h: I responded to your mailing list posts, you should have my email
15:46:56 <int80_h> dafi, oh cool! I gave up on that as it was the wrong thing to do anyway
15:47:05 <tromp_> @hoogle app
15:47:05 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
15:47:05 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
15:47:06 <lambdabot> Language.Haskell.TH.Syntax AppE :: Exp -> Exp -> Exp
15:47:17 <applicative> elliot, obviously you need she's idiom brackets :)  -- (|  (char '(' *> pUL <* char ')')  :>  pUL |) 
15:47:33 <dafis> int80_h: what was the wrong thing to do? mailing list questions?
15:47:48 <tromp_> @pl \f g x (f x)(g x)
15:47:48 <lambdabot> (line 1, column 11):
15:47:49 <lambdabot> unexpected "x"
15:47:49 <lambdabot> expecting operator or ")"
15:47:55 <tromp_> @pl \f g x -> (f x)(g x)
15:47:55 <lambdabot> ap
15:48:35 <heis> I did check the source for instance Applicative WriterT, and it's like Monoid w =>  m (a, w) -- like (f, w) <*> (x, w') -> (f x, mappend w w').  This seems to not be what StateT would do, but I feel like there could be alternative legal instances for WriterT without this restriction, which could be combined with ReaderT to make StateT, but I don't see this having been done anywhere.  So is it possible / not a dumb idea?
15:49:27 <int80_h> daifs: well that. As you pointed out. But relying on side effects is wrong. I'm convinced my initial approach was too fragile. INstead of trying to fix a broken design I should come up with a better one.
15:49:55 <tromp_> @pl \h f g x (h (f x))(g x)
15:49:56 <lambdabot> (line 1, column 13):
15:49:56 <lambdabot> unexpected "("
15:49:56 <lambdabot> expecting operator or ")"
15:50:02 <tromp_> @pl \h f g x -> (h (f x))(g x)
15:50:02 <lambdabot> liftM2
15:50:15 <applicative> Jesin [: ;} is parallel arrays, or did someone say that?
15:50:38 <Jesin> hmm
15:50:43 <Jesin> ok, why does it give a syntax error?
15:50:47 <Jesin> :k [: :]
15:50:48 <lambdabot> parse error on input `:'
15:50:53 <Jesin> :k ([: :])
15:50:54 <lambdabot> parse error on input `:'
15:50:56 <hpc> it's TH
15:51:02 <Jesin> TH?
15:51:07 <hpc> lambdabot is not all-singing and all-dancing
15:51:09 <hpc> template haskel
15:51:09 <dafis> int80_h: you could of course add a writer to the stack and have curlResp `tell' the cookies, but you have IO anyway, might as well immediately write them to file
15:51:12 <hpc> *haskell
15:51:15 <int80_h> dafis, also I just filtered out all mail from the beginners list and I don't see any responses. Was this recent?
15:51:38 <Jesin> [19:07:29]	<hpc>	lambdabot is not all-singing and all-dancing
15:51:40 <aavogt> hpc: \bot doesn't know about template haskell
15:51:42 <Jesin> it likes to show off though
15:51:44 <Jesin> :t (.)
15:51:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:51:46 <Jesin> :p
15:51:53 <Jesin> and even worse
15:51:55 <Jesin> :t flip
15:51:56 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:52:01 <hpc> that's caleskell
15:52:05 <Jesin> yeah
15:52:10 <hpc> TH is extensions
15:52:23 <dafis> int80_h: for example http://www.haskell.org/pipermail/beginners/2011-January/006275.html
15:52:29 <aavogt> > let x = [| Just 5 |] in $(tupE (replicate 5 x))
15:52:29 <ray> :t cale
15:52:29 <lambdabot>   <no location info>: parse error on input `|'
15:52:30 <lambdabot> Not in scope: `cale'
15:52:45 <int80_h> dafis, I ask because somethign fishy may be going on with my mail account.
15:52:52 <elliott> 18<Jesin> it likes to show off though
15:52:52 <elliott> 18<Jesin> :t (.)
15:52:55 <elliott> that's just Caleskell
15:52:57 <elliott> oh, hpc said so already
15:53:04 <elliott> :t sequence
15:53:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:53:10 <elliott> hmm, where's the MonadLogic one
15:53:14 <Jesin> wait, what
15:53:16 <Jesin> MonadLogic
15:53:18 <elliott> yeah
15:53:19 <dafis> int80_h: What fishiness do you suspect?
15:53:41 <tromp_> @pl \i h f g x -> i . (h (f x)) . g $ x
15:53:42 <lambdabot> flip flip id . ((flip . ((flip . (ap .)) .)) .) . (. (((flip . ((.) .)) .) . (.))) . (.) . (.) . (.) . (.)
15:53:42 <elliott> :t interleave
15:53:43 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
15:53:44 <elliott> BEHOLD
15:53:45 <elliott> MONADLOGIC
15:53:47 <ray> (.) should have its own typeclass
15:53:50 <jmcarthur> i didn't know lambdabot had that
15:53:57 <ray> it's not general enugh yet
15:54:05 <jmcarthur> ray: Category?
15:54:06 <elliott> jmcarthur: It's part of the advanced technologies included in the 2011 Caleskell Report.
15:54:07 <heis> Is there a way to use this @pl thing offline?
15:54:17 <elliott> heis: I think GHCi on Acid can do it, no idea if that's still maintained
15:54:18 <jmcarthur> :t (Control.Category..)
15:54:18 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
15:54:22 <Jesin> yeah really (.) does already have its own typeclass, except that's shared with id
15:54:24 <tolkad> I hav been thinking about learning details of ghc internals is this a good place to start? http://darcs.haskell.org/ghc/driver/mangler/ghc-asm.lprl
15:54:25 <jmcarthur> heis: pointfree package on hackage
15:54:28 <elliott> jmcarthur: That also includes symbolic capabilities!
15:54:30 <Pseudonym> Woo!  MonadLogic!
15:54:31 <elliott> > iterate f x
15:54:32 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
15:54:34 <ray> not general enough yet
15:54:42 <heis> Oh, it's the same thing as pointfree?
15:54:45 <jmcarthur> ray: ?
15:54:48 <elliott> ALL AVAILABLE IN THE GLORIOUS GLASGOW CALESKELL COMPILER (GCC)
15:54:59 <Jesin> XD
15:55:01 <heis> Sweet., thanks.
15:55:01 <ray> (.) :: a -> b -> c at least
15:55:10 <Veinor> haha
15:55:12 <Jesin> :t iterate
15:55:13 <lambdabot> forall a. (a -> a) -> a -> [a]
15:55:18 <elliott> (.) :: [a] -> () -> MonadLogic 3 <- whoops
15:55:20 <elliott> that's the one true type
15:55:30 <Jesin> > iterate
15:55:30 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a -> [a])
15:55:30 <lambdabot>    arising f...
15:55:32 <int80_h> dafis: oh that's you! I was looking at my most recent mail.
15:55:37 <Jesin> OVERLAPPING
15:55:43 <Jesin> :(
15:55:48 <tolkad> > f
15:55:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:55:49 <lambdabot>    `SimpleReflect.FromExpr ...
15:55:53 <Jesin> > fix
15:55:54 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
15:55:54 <lambdabot>    arising from a u...
15:55:57 <int80_h> dafis: I thought some mail was being marked as spam perhaps
15:56:01 <jmcarthur> ray: you mean you want some crazy multiparameter type class thing?
15:56:03 <tolkad> :t f
15:56:04 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:56:08 <tolkad> :t a;sdjflksdj
15:56:09 <lambdabot> parse error on input `;'
15:56:12 <tolkad> :t asdjflksdj
15:56:13 <lambdabot> Not in scope: `asdjflksdj'
15:56:24 <jmcarthur> ray: "hey look, here's a type class for an arbitrary binary operator"?
15:56:24 <int80_h> dafis: falsly marked I mean.
15:56:26 <lispy> tolkad: lambdabot provides certain single letter constants
15:56:32 <ray> yes
15:56:35 <Jesin> lol
15:56:38 <dafis> int80_h: so you never whoised?
15:56:51 <ray> the joke is that . gets overloaded to mean everything already
15:57:01 <jmcarthur> *sigh*
15:57:03 <tolkad> lispy: of course. it's a standard for caleskell implementations
15:57:09 <int80_h> dafis: heh. Never thought to. I barely know any irc commands
15:57:41 <Jesin> also
15:57:41 <dafis> int80_h: I always like to know with whom I'm talking
15:57:44 <int80_h> dafis, which is silly. Considering I have been here alomst every day for a few years.
15:57:54 <Jesin> > (2*) + 4
15:57:55 <lambdabot>   Ambiguous occurrence `+'
15:57:55 <lambdabot>  It could refer to either `L.+', defined at <local...
15:58:02 <Jesin> ....
15:58:05 <Jesin> whaaaaat
15:58:11 <Jesin> > (2*) Prelude.+ 4
15:58:12 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
15:58:12 <lambdabot>    arising from a use of `...
15:58:22 <Jesin> > 3 + 2
15:58:23 <lambdabot>   Ambiguous occurrence `+'
15:58:23 <lambdabot>  It could refer to either `L.+', defined at <local...
15:58:29 <Jesin> @undefine
15:58:30 <applicative> heis, once you have the executable, you add :def pf \str -> return $ ":! pointfree \"" ++ str ++ "\"" to your .ghci
15:58:32 <Jesin> > 3 + 2
15:58:32 <lambdabot>   5
15:58:37 <Jesin> that's better.
15:58:37 <dafis> > ((2*) Prelude.+ 4) 5
15:58:38 <lambdabot>   14
15:58:55 <jmcarthur> ((2*) + 4) 5
15:58:55 <tolkad> > 1 + 2
15:58:56 <lambdabot>   3
15:59:02 <jmcarthur> > ((2*) + 4) 5
15:59:03 <lambdabot>   14
15:59:05 <Jesin> > 3 2
15:59:06 <lambdabot>   3
15:59:09 <Jesin> :P
15:59:11 <sm> what's the very simplest way to build a github post-receive server, I wonder ? Ie listen for http POST and run some action. Yesod and other frameworks I'm thinking of seem overkill
15:59:19 <tolkad> > 3 + 2
15:59:20 <lambdabot>   Ambiguous occurrence `+'
15:59:20 <lambdabot>  It could refer to either `L.+', defined at <local...
15:59:29 <Jesin> @undefine
15:59:33 <jmcarthur> nothing that is easy is overkill
15:59:33 <Jesin> > 2 + 3
15:59:34 <lambdabot>   Ambiguous occurrence `+'
15:59:34 <lambdabot>  It could refer to either `L.+', defined at <local...
15:59:40 <Jesin> @undefine
15:59:42 <Jesin> > 2 + 3
15:59:42 <lambdabot>   5
15:59:45 <Jesin> > 2 + 3
15:59:46 <lambdabot>   Ambiguous occurrence `+'
15:59:46 <lambdabot>  It could refer to either `L.+', defined at <local...
15:59:49 <Jesin> D:
15:59:51 <jmcarthur> wtf
15:59:52 <ray> jeez
16:00:06 <Jesin> why does it break like that I don't get it
16:00:12 <revenantphx> When you don't understand a random weighted choice algorithm, sitting in the room over from a math professor who teaches a stochastics course is very convenient.
16:00:31 <tolkad> lol I love messing with lambdabot in private messages
16:00:38 <ray> clearly you are redefining stuff in messages
16:00:46 <Jesin> I wondered if someone was doing that
16:01:16 <Jesin> but still
16:01:21 <Jesin> num instance for functions
16:01:28 <Jesin> :p
16:01:31 <tolkad> id + id
16:01:37 <tolkad> > id + id
16:01:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:01:38 <lambdabot>    arising from a use of `...
16:01:43 <tolkad> >  + id
16:01:44 <lambdabot>   <no location info>: parse error on input `+'
16:01:46 <jmcarthur> > id + id $ 1
16:01:47 <lambdabot>   2
16:01:47 <tolkad> > 1 + id
16:01:48 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:01:48 <lambdabot>    arising from a use of `...
16:01:55 <jmcarthur> > id + id $ 5
16:01:56 <lambdabot>   10
16:01:59 <Jesin> > 3 + id
16:02:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:02:00 <lambdabot>    arising from a use of `...
16:02:04 <jmcarthur> > 3 + id $ 5
16:02:05 <lambdabot>   8
16:02:07 <tolkad> Jesin: it's all standard caleskell
16:02:10 <jix> > 1 2 3
16:02:11 <Jesin> yeah
16:02:11 <lambdabot>   1
16:02:12 <jmcarthur> it's not caleskell
16:02:16 <jmcarthur> it's part of the vector-space package
16:02:22 <Jesin> wait what
16:02:26 <jmcarthur> > 1 ^+^ 1
16:02:27 <lambdabot>   2
16:02:34 <lambdabot> I love pestering people in private messages too.
16:02:57 <tolkad> 0_0
16:03:00 <dafis> jmcarthur: (^+^) is the Batman operator?
16:03:13 <Jesin> hmm...
16:03:20 <djahandarie> I think that the particular set of packages that are imported in lambdabot do sort of go by the name 'caleskell' though, along with the custom stuff
16:03:37 <lambdabot> I also love messing with the heads of people who don't realise that I have a sockpuppet mode.
16:04:06 <dafis> @slap lambdabot
16:04:06 * lambdabot smashes a lamp on lambdabot's head
16:04:24 <tolkad> lambdabot: ah, I thought so. either that, or jmcarthur found a custom Show instance that printed out the raw string
16:04:42 <aavogt> > text "hi"
16:04:43 <lambdabot>   hi
16:04:43 <int80_h> sockpuppet!
16:04:47 <tolkad> lambdabot: although I guess that would have been indented
16:04:51 <Pseudonym> Note the space, though.
16:04:58 <maurer_> code.haskell.org appears down...
16:05:02 <jmcarthur> tolkad: what aavogt did
16:05:08 <lispy> maurer_: yes.  Down until further notice :(
16:05:15 <lispy> maurer_: there is a team working on it though
16:05:22 <maurer_> lispy: Is there a static archive of stuff that was up there?
16:05:23 <aavogt> maurer_: http://www.haskell.org/pipermail/haskell-cafe/2011-February/088829.html
16:05:24 <Pseudonym> dons went to a lot of trouble to stop people sockpuppeting lambdabot via the eval mechanism.
16:05:30 <tolkad> maurer_: it got hacked and they're using the oportunity to upgrade it
16:05:39 <Pseudonym> Mostly because I kept finding ways to do it.
16:05:39 <tolkad> opportunity*
16:05:44 <Jesin> :t text
16:05:44 <lambdabot> String -> Doc
16:05:56 <jmcarthur> dafis: ^+^ is addition in the AdditiveGroup type class
16:06:20 <Jesin> > 8 ^-^ 2
16:06:21 <lambdabot>   Ambiguous occurrence `^-^'
16:06:21 <lambdabot>  It could refer to either `L.^-^', defined at <l...
16:06:32 <Jesin> @undefine
16:06:37 <Jesin> :t (^-^)
16:06:38 <lambdabot> forall v. (AdditiveGroup v) => v -> v -> v
16:06:44 <Jesin> ...
16:06:45 <dafis> jmcarthur: I figured something like that, but with that look, it needs an eary name, Batman or Spock
16:06:45 <Jesin> srsly.
16:07:02 <aavogt> @hackage vector-space
16:07:02 <lambdabot> http://hackage.haskell.org/package/vector-space
16:07:03 <Jesin> people are using emoticons for functions...
16:07:12 <maurer_> tolkad: Yeah, I see that now. Is there anywhere that one can get non-fancy read only repo access in the meantime?
16:07:29 <lispy> maurer_: I don't think so
16:07:34 <lispy> maurer_: what do you need access to?
16:07:48 <Jesin> > 8 >.> 2
16:07:50 <lambdabot>   1.5625e-2
16:08:11 <tolkad> dafis: there should be a Unicode Spock
16:08:17 <Jesin> > 8 <.< 2
16:08:18 <lambdabot>   3.90625e-3
16:08:29 <Jesin> @src (>.>)
16:08:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:08:45 <Jesin> @. pl undefine
16:08:45 <lambdabot> (line 1, column 1):
16:08:45 <lambdabot> unexpected end of input
16:08:45 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:09:03 <fryguybob> Jesin: The ^ is referring to vector so ^+^ is addition with vectors on both sides.
16:09:03 <fryguybob> @type (*^)
16:09:04 <lambdabot> forall v. (VectorSpace v) => Scalar v -> v -> v
16:09:07 <fryguybob> @type (^*)
16:09:08 <lambdabot> forall v. (VectorSpace v) => v -> Scalar v -> v
16:09:22 <int80_h> dafis I have a question about line 9
16:09:46 <int80_h> dafis, what am I lifting into? Usually I see the results of a lift bound to a name.
16:09:48 <jix> hmm I guess if I upload this to hackage I'll notice everything I've done wrong 2 minutes later....
16:10:28 <maurer_> lispy: I was hoping to grab the code for running hackage.
16:10:35 <lispy> jix: generally, yes that's how it happens :)
16:10:40 <lispy> maurer_: hmm
16:10:41 <maurer_> lispy: It's not vital or anything though.
16:10:45 <elliott> hmm, Parsec's many is complicated
16:10:46 <dafis> int80_h: the type of appendFile is FilePath -> String -> IO (), so the result is (), not particularly interesting
16:10:47 <lispy> maurer_: I wonder if that's on github
16:10:50 <elliott> implementation, that is
16:10:58 <elliott> (trying to reimplement it for a non-[] list structure)
16:11:09 <int80_h> dafis: gotcha
16:11:19 <dafis> int80_h: it's just appending the new cookies to the jar
16:11:20 <lispy> maurer_: if you want a personal hackage you can use yackage: https://github.com/snoyberg/yackage
16:11:44 <maurer_> lispy: I tried that, but I can't get web-quasi-routes to build. I suppose I could downgrade my ghc...
16:11:53 <int80_h> dafis: well, that is what caused this new re-design. the cookie jar is not actually being created.
16:12:10 <lispy> maurer_: Hmm...
16:12:16 <int80_h> dafis: But I don't need one if I can just capture the headers and parse the cookies out of that.
16:12:42 <lispy> maurer_: I'm out of ideas.  One reason for not having a read-only mirror is that the data files of the projects needs to be verified/valified post-compromise to make sure it's not malicious.
16:13:02 <lispy> maurer_: there is a lot of work :(
16:13:11 <maurer_> lispy: Sure, I just figured there was a good chance of there being backups. Thanks though.
16:14:25 <dafis> int80_h: now we're being quite explicit about it, try it out; if you're not satisfied with that, you could also change the type of curlResp to return (String,[String]), the list being the new cookies, and collect those and at the very end, hmm, write them to a file?
16:16:26 <jix> ah... heh hackage has manually activated user accounts...
16:16:36 <int80_h> dafis: yup, that's where this is going I think. I didn't write this initial type for curlResp. See the return type m String? What is the difference between m String and returning just a string?
16:16:57 <jix> I guess I can't upload my first package today then :( 
16:17:38 <dafis> int80_h: curlResp is a monadic action, so it necessarily has a result type m something
16:18:12 <dafis> int80_h: and since you're doing some curl stuff, it has to be a MonadIO
16:18:26 <int80_h> dafis: okay then a change to (String,String) would look like this "m (String, String)"
16:18:34 <dafis> int80_h: yup
16:19:11 <dafis> int80_h: I thought of m (String, [String]) though, for the list of cookies
16:19:42 <int80_h> dafis: I've learned more in doing this work project than I ever did trying out tutorials. Thanks for the help. I'm going to go try some stuff now.
16:19:56 <int80_h> oh yeah [String]. I would have gotten there.
16:20:39 <mm_freak> jonkri: because you need to pass that Chan/MVar around
16:20:52 <mm_freak> jonkri: with a reader monad you can make it implicit
16:20:54 <dafis> int80_h: in generateResourceHtml and probably some other functions, you would have to bind the result of curlResp to capture the cookies; explicitly writing them to file in curlResp would minimise code changes
16:21:10 <jonkri> i see :)
16:22:39 <int80_h> dafis: hmm that brings up design issues. I plan a total re-write anyway. I suspect my style has noobie written all over it. So I have no problem with doing any re-writes if it means I have cleaner, more maintainable code when I am done
16:22:51 <jonkri> mm_freak: why did you suggest to have the logging function in the state?
16:24:30 <int80_h> dafis: My intuition doesn't like hiding the main function of this code inside another function. Though, it does seem most convinient at the moment.
16:24:54 <dafis> int80_h: If you're doing a complete rewrite anyway, choose the design you find best.
16:25:13 <dafis> int80_h: The main goal of it all is to get the cookies?
16:25:29 <int80_h> dafis: well, when I have something working, I was going to submit the code to the mailing list for a critique
16:25:52 <int80_h> dafis: yup. Everything I am doing is to get the cookies that express a session state
16:26:00 <revenantphx> Happy Zero-Remaining-Unallocated-IPv4-Addresses-Day everyone!
16:26:08 <companion_cube> \o/
16:26:38 <sipa> that was yesterday here!
16:26:43 <hpc> revenantphx: :D
16:26:48 <dafis> int80_h: do you ever actually need the response body?
16:26:51 <int80_h> dafis: I don't like all my let bindings. I have this inarticulate feeling that I am just doing it wrong
16:27:05 <luite> revenantphx: bah I was already running ipv6 before it was cool
16:27:06 <int80_h> dafis: yeah I do
16:27:10 * hpc eagerly awaits Everyone Figuring Out that Running out of Something isn't Fun Day
16:27:49 <dafis> int80_h: yes, for example in generateResourceHtml: let makeIDPage = ... in runErrorT makeIDPage; why not runErrorT $ do ...
16:27:53 <int80_h> dafis: there's a stage where I am trying to produce a page of html that has particular data in it. That data is needed to get the server in the proper state
16:28:15 <revenantphx> luite: same here.
16:29:04 <luite> even though my adsl modem didn't work properly with native (non-tunnel) ipv6 until the latest firmware update from earlier this week
16:29:13 <dafis> int80_h: Okay, so think about adding a MonadState constraint and have the state collect the cookies
16:29:41 <int80_h> dafis: yeah that's the kind of critique I mean. Well I can work with that for now. And see what other changes I need to make later.
16:29:48 <dafis> int80_h: seems cleaner to me than having curlresp's result type be (String,[String])
16:30:12 <int80_h> dafis: okay that's something I need to learn how to do.
16:30:24 <ddarius> "And the people who benefit most are breaking bread with their benevolent host."
16:31:39 <int80_h> Monads are still new to me, though I'm over the "monads r scaary" part.
16:32:13 <elliott> Is there a "simple" way to write an equivalent of Parsec's "many" for a non-[] list type?
16:32:21 <elliott> <revenantphx> Happy Zero-Remaining-Unallocated-IPv4-Addresses-Day everyone!
16:32:27 <elliott> revenantphx: wrong, zero remaining unallocated /8s
16:32:35 <elliott> RIR depletion is still a few months off
16:32:35 <sipa> wrong
16:32:45 <sipa> zero remaining unallocated unicast /8s
16:32:48 <elliott> well, there's also reserved ones
16:32:51 <elliott> sipa: touche :)
16:32:55 <elliott> PEDANT WAR
16:33:02 <elliott> but revenantphx's was quite misleading :p
16:33:28 <ddarius> Don't worry.  There wasn't anybody making a beeline to IPv6.
16:33:48 <hpc> ddarius: oh, phew
16:33:50 <ddarius> Braille(?) glider unicode.
16:33:56 <hpc> as long as that's not happening, everything's fine
16:35:48 <dafis> int80_h: just start using Monads, understanding then comes from use
16:36:05 <revenantphx> elliott: que?
16:36:16 <elliott> revenantphx: there are plenty of unallocated addresses.
16:36:20 <elliott> it is /8s that we're out of.
16:36:27 <elliott> RIR depletion is when "we" run out of addresses
16:36:35 <revenantphx>  /8's being?
16:36:44 <elliott> revenantphx: segments of the ipv4 address space.
16:36:48 <revenantphx> mmk
16:36:52 <elliott> if you don't know, maybe don't make bold statements :)
16:36:58 <ddarius> dafis: Yeah.  I used monads for a week and then was like "Of course, these are just lax functors from the terminal bicategory into Cat."
16:37:14 <sipa> k.x.y.z
16:37:30 <sipa> is a /8
16:37:44 <sipa> eg 169.x.y.z
16:38:02 <revenantphx> ah, first 8 bits.
16:38:20 <revenantphx> so all of those blocks are allocated then.
16:38:32 <revenantphx> ?
16:38:36 <sipa> yes
16:38:47 <sipa> well, no
16:38:54 <sipa> they are assigned
16:39:18 <dafis> sipa: what's the difference?
16:39:21 <sipa> to the regional instances
16:40:05 <mm_freak> jonkri: what would you pass around?
16:40:12 <roconnor> should I reference Kieburtz's unpublished paper Codata and Comonads in Haskell?
16:40:36 <Pseudonym> I guess it depends why.
16:41:08 <roconnor> I'm looking for a statement of the comonad laws.
16:41:22 <roconnor> maybe I should just write out the laws
16:42:08 <hpc> you can mention the unpublished paper in a footnote, perhaps
16:42:49 <kulakowski> Tell people to look at the monad laws in a mirror.
16:43:16 <monochrom> the same laws in a mirror. enjoys parity symmetry.
16:45:07 <poincare101> Hello everyone. I'm trying to get some code running in haskell (newbie). its supposed to print out the first 7 fibonacci numbers here it is: http://codepad.org/vX06i0ys Why won't it compile? I understand imperative statements must be undera do block, but, where is the all the show stuff coming from?
16:46:16 <hpc> poincare101: you print a fibprint call
16:46:18 <hpc> not a fib call
16:46:38 <hpc> also, you don't need the do block for that
16:46:38 <jonkri> mm_freak: hmm... i was thinking to pass around the channel and the logging state (like configuration) and to have an exported function in a logging module that takes that and a log message and logs according to the configuration
16:47:07 <monochrom> I am not sure what "fibprint n = print (fibprint (n-1))" is supposed to accomplish. but try "fibprint n = print (fib n)" for starters
16:47:33 <poincare101> hpc: hw about this: http://codepad.org/Ru69arIS
16:47:48 <poincare101> monochrom: doesn't that only print ONE fibonacci number?
16:47:55 <monochrom> yes
16:48:13 <ddarius> One is more than zero.
16:48:17 <dafis> poincare101: that's an infinite recursion
16:48:18 <hpc> poincare101: no; re-read what i said above, and consider what your code will do
16:48:29 <dafis> poincare101: you need a stopping condition
16:48:38 <dafis> fibprint 0 = print 0
16:48:47 <monochrom> and frankly I don't see how "print (fibprint (n-1))" should print more, even taking into account beginner thinking.
16:48:49 <ddarius> Probably more of a type error...
16:49:08 <dafis> fibprint n = do { fibprint (n-1); print (fib n); }
16:49:25 <poincare101> http://codepad.org/dOQBN7zV
16:49:29 <poincare101> that works! thanks a lot!
16:49:47 <monochrom> even with beginner thinking, "print (fibprint (n-1))" expands to "print (print (print (print ..." what do you think nesting "print" means?
16:50:04 <poincare101> monochrom: oh, that makes sense.
16:51:29 <mm_freak> jonkri: i'd just pass a logging function as part of the application state…  note that such a logging function doesn't necessarily take a String, but rather a logger command
16:52:18 <MrWish> hey, where can I get a good introductory text on lambda calculus online?
16:52:38 <mm_freak> MrWish: wikipedia should suffice as an introduction
16:52:47 <ddarius> @google lambda calculus introduction
16:52:49 <lambdabot> ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf
16:53:28 <jonkri> mm_freak: how do you configure the logging environment through this function? (what file to write to, for example) does this function look different for different applications?
16:54:36 <elliott> hmm, what's the correct parsec for the invalid "many (noneOf foo)"?
16:56:10 <mm_freak> jonkri: newtype LoggerT m a = LoggerT (ReaderT (LoggerCmd -> IO ()) m a)
16:56:23 <monochrom> what is foo? (do you think it matters?)
16:56:45 <hpc> monochrom: i think he is looking for something like takeUntil
16:56:54 <hpc> or whatever would be named that
16:57:01 <monochrom> because for example (many (noneOf "xyz")) is pretty valid.
16:57:04 <jonkri> thanks for all your help mm_freak 
16:57:07 <jonkri> good night people
16:58:31 <ddarius> monochrom loves things defined by meaningful names.
16:58:52 <Philippa> mm_freak: I have deja vu
16:59:42 <elliott> monochrom: many (noneOf "foo") is _not_ valid
16:59:48 <elliott> *** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
17:01:02 <dolio> Do you think that's air you're breathing?
17:01:23 <mm_freak> Philippa: ?
17:02:26 <Philippa> mm_freak: I've been away from chan for a day and it's on the same topic when I get back, 'sall
17:02:53 <mm_freak> Philippa: logging is a complicated topic in haskell =)
17:03:26 <monochrom> Prelude Text.ParserCombinators.Parsec> parseTest (many (noneOf "foo")) "abcf"
17:03:26 <monochrom> "abc"
17:03:32 <monochrom> no error for me
17:04:36 <elliott> hm
17:05:01 <elliott> oh, hm
17:05:02 <elliott> ah
17:05:07 <elliott> never mind :)
17:09:48 <mjrosenb> if I have a tree stucture with lots of redundancy, is it possible to write a map function that will leave this redundancy in tact?
17:11:12 <aavogt> mjrosenb: redundancy like     let x = expensive computation in [x,x,x] ?
17:11:28 <mjrosenb> aavogt: yes.
17:15:55 <shachaf> jmcarthur: Onto my tricks?
17:16:21 <shachaf> > fix fiх
17:16:23 <lambdabot>   How about this?
17:18:08 <aavogt> mjrosenb: if you could write the tree including a function as argument
17:18:22 <Jesin> @undefine
17:18:25 <Jesin> > fix fix
17:18:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:18:28 <Jesin> :P
17:18:58 <aavogt> otherwise you can detect sharing with some unsafe functions from the ghc api
17:19:26 <shachaf> Jesin: What?
17:19:44 <mjrosenb> aavogt: you mean like have the function that is eventually going to be mapped be part of the tree?
17:19:54 <aavogt> yes
17:20:34 <aavogt> otherwise you're not supposed to be able to tell the difference between values which are equal (as per ==) and those that were actually the same value (in a let binding)
17:20:58 <azaq23> @let head = undefined
17:20:59 <lambdabot>  Defined.
17:21:01 <azaq23> @type head
17:21:02 <lambdabot>     Ambiguous occurrence `head'
17:21:02 <lambdabot>     It could refer to either `L.head', defined at <local>:2:0
17:21:02 <lambdabot>                           or `Data.List.head', imported from Data.List at State/L.hs:35:0-33
17:21:04 * jix is nervous
17:21:05 <azaq23> @undefine
17:21:40 <mjrosenb> i don't need to know if they are the same, i just want the mapped tree to not take up exponentially more space than the original tree :(
17:22:25 <aavogt> mjrosenb: suppose you have memoized f and use a normal map function...
17:23:02 * hackagebot translatable-intset 0.1 - Integer sets with a constant time translate operation.  http://hackage.haskell.org/package/translatable-intset-0.1 (JannisHarder)
17:23:03 <mjrosenb> ok, that isn't entirely true; i also want this to happen during reduce/fold as well;
17:23:15 <mjrosenb> gues this isn't going to be pretty :(
17:23:29 <jix> there it is, my first hackage package :)
17:25:47 <mjrosenb> jix: cool!
17:27:03 <aavogt> mjrosenb: maybe a tree isn't the only thing you should have
17:27:03 * hackagebot ChasingBottoms 1.3.0.1 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.1 (NilsAndersDanielsson)
17:28:01 <aavogt> mjrosenb: you could split it up like    type SharedMap k v = (Map k Int, IntMap v)
17:29:03 <aavogt> (or using IntegerS for linking the two)
17:29:07 <sbshah> hello guys
17:29:26 <jix> copumpkin: you might be interested
17:29:32 <mjrosenb> aavogt: yeah, that was my backup plan :(
17:29:36 <copumpkin> jix?
17:29:41 <copumpkin> oh
17:29:47 <copumpkin> cool :)
17:29:47 <aavogt> mjrosenb: what's so bad about that approach?
17:30:11 <copumpkin> jix: I'm making sushi right now but will try it out in a bit
17:30:23 <aavogt> deletes will be expensive (or keep garbage around)
17:30:32 <mjrosenb> aavogt: it doesn't look as pretty, and is more annoying to pattern match against
17:30:43 <aavogt> use view patterns
17:31:45 <mjrosenb> aavogt: that sounds more annoying to me :-p
17:37:13 <{aaron}> hi guys, i have ghc 6.12.3 on fedora but when i attempt to install a certain package via cabal i get this confusing error: "There is no available version of ghc that satisfies >6.6"
17:37:29 <{aaron}> any ideas?
17:37:35 <dcoutts> {aaron}: 'ghc' in this case is a package
17:37:41 <{aaron}> ahh
17:37:44 <dcoutts> the ghc api package
17:37:48 <roconnor> @hoogle Prefix
17:37:48 <lambdabot> Data.Data Prefix :: Fixity
17:37:48 <lambdabot> Text.Parsec.Expr Prefix :: ParsecT s u m (a -> a) -> Operator s u m a
17:37:49 <lambdabot> Text.ParserCombinators.Parsec.Expr Prefix :: GenParser tok st (a -> a) -> Operator tok st a
17:37:57 <dcoutts> {aaron}: it comes with ghc and cannot be upgraded
17:38:22 <{aaron}> dcoutts, then i'm still confused
17:38:23 <dcoutts> {aaron}: sounds like cabal thinks your ghc package is missing/corrupt
17:38:26 <dcoutts> use ghc-pkg check
17:38:28 <{aaron}> yeah..
17:38:29 <{aaron}> ok
17:38:59 <{aaron}> nada
17:39:10 <{aaron}> i have a --user install (which afaik is standard)
17:39:52 <{aaron}> "cabal: There is no package named ghc. Perhaps you need to run 'cabal update' first?" just did
17:40:20 <dcoutts> {aaron}: ghc-pkg list ghc ?
17:40:38 <dcoutts> {aaron}: the ghc package is not available from hackage, it only comes with ghc
17:41:03 <{aaron}> i get two dirs, that's end in package.conf.d... is that normal
17:41:11 <dcoutts> yes
17:41:19 <dcoutts> and is ghc listed there?
17:41:22 <{aaron}> one in lib64 (must be the system install) one in my home dir ~/.ghc
17:41:25 <{aaron}> yes
17:41:26 <dcoutts> the package called ghc
17:42:07 <{aaron}> http://hpaste.org/43586/ghc
17:42:23 <dcoutts> oh ok, so it's not there
17:42:36 <dcoutts> well that explains why cabal thinks it's not there :-)
17:42:53 <{aaron}> :/
17:42:56 <dcoutts> {aaron}: given that the ghc package always comes with ghc, there's something fishy with your setup
17:43:01 <{aaron}> ok
17:43:08 <{aaron}> so what are those two lines telling me?
17:43:23 <dcoutts> those are the names/locations of the global and user dbs
17:43:37 <int80_h> @hoogle liftIO
17:43:37 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
17:43:37 <dcoutts> {aaron}: see what it looks like for example if you do: ghc-pkg list base
17:43:40 <{aaron}> oh.  is list just doing a regex or something?
17:43:41 <{aaron}> ok
17:43:47 <Maxdamantus> Hmm .. sequence isn't lazy?
17:43:54 <{aaron}> oh i see now
17:44:12 <{aaron}> ok will check my distro to see if there is a known issue with the ghc they provide
17:44:15 <dcoutts> {aaron}: no, it's breaking the listing into sections by the database (global or user)
17:44:17 <drbean> I want to add items to a 'lexicon' function defined in Eijck and Unger's        +Computational Semantics with Functional Programming ( http://gist.github.com/810608 )
17:44:36 <dcoutts> {aaron}: right, try reinstalling the fedora ghc
17:44:44 <aavogt> Maxdamantus: it can't be infinite, but it can contain things that could not be fully evaluated
17:44:49 <Maxdamantus> Ack nvm.
17:44:59 <aavogt> actually, you mean the function sequence?
17:44:59 <drbean> This is quite laborious the way they have set the String -> [Cat] function up.
17:45:11 * aavogt was thinking of Data.Sequence
17:45:29 <Maxdamantus> Dunno what the function sequence is .. I meant Prelude.sequence but nvm, I see my failed logic now.
17:45:35 <Maxdamantus> :t sequence
17:45:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:45:42 <drbean> I have a function men :: String -> [Cat], men a = [Cat a "NP" [Thrd,Masc,Sg] []]
17:45:44 <aavogt> @src sequence
17:45:44 <lambdabot> sequence []     = return []
17:45:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:45:44 <lambdabot> --OR
17:45:44 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:46:11 <aavogt> it depends on the Monad instance
17:46:52 <drbean> ow do I do something like, lexicon as = map men as
17:48:19 <int80_h> how do I specify in ghci that I want a let binding to be of type "CurlResponse_ headerTy bodyTy"
17:49:01 <Olathe> > let f x = let y :: Integer; y = 5 in y in f 2
17:49:02 <aavogt> int80_h: you have a specific headerTy bodyTy in mind?
17:49:02 <lambdabot>   5
17:49:55 <int80_h> aavogt: respHeaders
17:50:06 <aavogt> those are still type variables
17:50:16 <int80_h> aavogt: I tried to do this "let hdr = respHeaders resp"
17:50:23 <int80_h> and I got a type mismatch
17:51:30 <int80_h> where it expected a String. I want to explicitly give it the above mentioned type
17:52:11 <int80_h> bbl, dinner
17:53:52 <roconnor> how does local work with anonymous pipes and stdin?
17:53:57 <roconnor> *locale
18:02:02 <mafs> If not already known, code.haskell.org seems to be down
18:02:40 <copumpkin> mafs: people have been "knowing" it non-stop for the past week :P
18:03:04 <mafs> copumpkin: haha, oops. I swear it wasn't down yesterday!
18:03:18 <copumpkin> it was! :P
18:03:23 <dolio> It may not have been down, but it was blank.
18:04:08 <copumpkin> on the wikipedia page on modal logic
18:04:12 <copumpkin> it says " Traditionally, there are three "modes" or "moods" or "modalities" represented in modal logic, namely, possibility, probability, and necessity."
18:04:33 <copumpkin> it then goes on to talk about possibility and necessity, but what about that "probability" one?
18:04:34 <copumpkin> it seems more awkward and they don't talk about it
18:04:43 <dolio> Never heard of it.
18:04:46 <copumpkin> I haven't come across it before
18:04:47 <copumpkin> yeah
18:05:00 <dolio> But there are others.
18:05:07 <dolio> "Lax" for instance.
18:05:15 <copumpkin> what's that?
18:05:35 <dolio> It's similar to possibility, but not quite the same.
18:05:40 <dolio> I can't remember what it's used for.
18:06:14 <copumpkin> aha, there's some on http://blog.sigfpe.com/2006/04/modal-logic-of-near-certainty.html
18:06:18 <copumpkin> in neel's comment
18:06:44 <copumpkin> conveniently looks just like a monad!
18:07:03 <dolio> Well, possibility is a monad, I believe.
18:07:10 <dolio> And necessity is a comonad.
18:07:14 <copumpkin> A /\ OB => O(A /\ B) looks more like strength
18:07:25 <dolio> Yes.
18:08:02 <copumpkin> interesting
18:08:59 <dolio> Of course, linear logic has modalities, too, for embedding non-linearity.
18:09:53 <jix> Now the documentation of my first pkg is online too :)
18:10:12 <copumpkin> jix: yay
18:11:03 <Bynbo7> jix: link?
18:11:24 <jix> http://hackage.haskell.org/package/translatable-intset
18:11:51 <drbean> I have 2 functions f and g with different arguments but of the same String      +type. I want to make a third function, h with the arguments and values of f and g.
18:12:22 <drbean> I want to do it without writing out the arguments.
18:16:28 <Olathe> @pl \x -> (f x, g x)
18:16:28 <lambdabot> liftM2 (,) f g
18:16:57 <Cale> drbean: Can you be more specific about the types of f and g, I don't think I understand the question.
18:18:46 <copumpkin> QFBAPA is where it's at
18:18:48 <copumpkin> mm
18:19:36 <drbean> Cale: I will be back.
18:26:23 <Bynbo7> jix: how often do people want to be able to add to each element in an intset anyway?
18:26:32 <mdmkolbe1> Is there a good/standard library for heterogenious association lists that reflect the values types in the type of the association list?  I need this for implementing the environment of a GADT based interpreter.  I can write the code myself but using an existing/well-known library would be nice.
18:27:47 <Bynbo7> mdmkolbe: how would that be typesafe?
18:28:10 <mdmkolbe> Bynbo7: only if the types are reflected in the type of the list
18:28:45 <Bynbo7> but does't that mean it wouldn't be heterogenious?
18:28:48 <jix> Bynbo7: well I wrote this because it was exactly what I needed
18:28:56 <Bynbo7> jix: fair enough =)
18:29:03 <Bynbo7> what were you using it for?
18:29:50 <jix> Bynbo7: I'm working on code that uses raltive offsets to store references between sequences which get concateneated
18:30:35 <jix> Bynbo7: And I have to add a bunch of references stored at one position to another position and things like that
18:30:39 <mdmkolbe> Bynbo7: The most basic example of what I'm talking about would be nested tuples.  (Int, ()) and (Char, (Int, ()) would respectively represent a list with a single Int in it and a list with one Char and one Int in it.
18:30:54 <jix> so I have to add an offset to all elements and merge
18:31:45 <Bynbo7> mdmkolbe: maybe you could use something like: data HList a = a :< (forall b. HList b) | Nil?
18:32:00 <Bynbo7> though, that doesn’t really keep the types visible
18:32:55 <mdmkolbe> Bynbo7: Like I said, I know how to write the code.  I'm just asking if there is a known library already for doing that.
18:32:56 <copumpkin> yeah, a universally quantified thing like that would be effectively a natural
18:33:17 <copumpkin> mdmkolbe: hlist?
18:33:33 <copumpkin> http://hackage.haskell.org/package/HList
18:33:47 <copumpkin> not the prettiest thing ever
18:34:34 <mdmkolbe> copumpkin: That's what comes to my mind, but I couldn't figure it out the last time I tried it.
18:48:34 <azaq23> HDiff HNil x HNil HProjectByHNats HNil HNil HNil HTypes2HNats HNil l HNil HDeleteMany e HNil HNil totally readable
18:48:34 <gwern> @quote hlist
18:48:34 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
18:48:34 <lambdabot> HList syntax or something.
18:48:53 <gwern> @quote hlist.*answer
18:48:53 <lambdabot> gwern says: if hlist is the answer, I don't want to know the question
18:49:31 <Eduard_Munteanu> It looks a bit insane.
18:49:50 <Eduard_Munteanu> Though I remember the paper looked instructive.
18:49:56 <Eduard_Munteanu> Or intriguing.
18:50:00 <xplat> if HList is the answer, you wouldn't be able to read the question.
18:51:09 <gwern> it's a lot of fun to read through the quotes file
18:51:13 <xplat> i mean, HList is one of those amazing things that falls just short of being impossible on one side and just short of being practical on the other
18:52:03 <xplat> like boost::proto
18:52:25 <Eduard_Munteanu> Hrm, about that, where can I get lambdabot's quote file? Should make for some laughs.
18:52:40 <gwern> Eduard_Munteanu: repo. cat ./State/quotes | gunzip
18:52:55 <gwern> Eduard_Munteanu: alas, you don't seem to be in there
18:53:12 <gwern> I don't remember a lot of mine
18:53:13 <gwern> <gwern> closures are a poor man's object <ddarius> objects are a poor man's closure <Berengal> objects are a rich man's structs <Jafet> Poor programmers should start unions
18:53:21 <Eduard_Munteanu> gwern: oh, so #haskell's lambdabot actually records stuff into the main lambdabot package?
18:53:32 <Eduard_Munteanu> Hm, yeah, I don't remember being quoted.
18:53:35 <gwern> Eduard_Munteanu: yep. the serialized state is part of the revision history
18:53:44 <gwern> Eduard_Munteanu: was last updated a few months ago
18:53:56 <Bynbo7> @quote Eduard_Munteanu
18:53:56 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
18:53:59 <Bynbo7> :(
18:54:01 <Eduard_Munteanu> Thanks, I'll have a look.
18:54:40 <gwern> ok, I do remember this one: also, now my keyboard has a nice toasty feeling.  maybe I should blowdry my keyboards more often
18:55:08 * gwern had spilled hot chocolate or something, and put it through the dishwasher
18:55:14 <Eduard_Munteanu> Ouch.
18:55:38 <xplat> hot chocolate sounds like just the thing not to spill on your keyboard
18:56:06 <gwern> @quote hiredman
18:56:06 <lambdabot> hiredman says: I used to think "dons" was a title, like people who were recognized as being really good at haskell were called dons
18:56:46 <xplat> not ... ENTIRELY untrue.
18:56:57 <Eduard_Munteanu> Dons like gents?
18:57:12 <xplat> like in the haskell mafia
18:57:20 <gwern> @quote jamesbritt
18:57:20 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
18:57:22 <Eduard_Munteanu> Heh.
18:57:51 <gwern> @quote fluxbox
18:57:52 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
18:57:52 <lambdabot> for your entire program.")
18:57:52 <xplat> who do you think really forces all those thunks anyway
18:58:27 * sproingie
18:59:05 <xplat> wow, first null emote i've seen on irc.  i knew this was my kind of place.
18:59:37 <gwern> @quote kmc
18:59:37 <lambdabot> kmc says: one of the fun things about FP is that you can invert your program's control flow seven times without noticing
18:59:39 <tolkad> if a data type has a lot of constructors, is there nothing you can do to get log n case expressions?
18:59:57 <tolkad> where n is the number of cases
19:00:14 <xplat> you can nest constructors
19:00:36 <gwern> @quote largos
19:00:36 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
19:00:45 <tolkad> xplat: internally they are represented as words though. it's kind of annoying that ghc wont just optimize this automatically since I can't
19:01:07 <tolkad> xplat: it seems it would be easy to generate a jump table
19:01:21 <gwern> @quote hlint
19:01:21 <lambdabot> lispy says: jkramer> I think since the last update, hlint suggests weird/wrong things <lispy> jkramer: like, "Instead of eta reduction, try a Factory pattern." ?
19:01:22 <Eduard_Munteanu> I suppose it could use some sort of radix tree.
19:01:34 <Eduard_Munteanu> Hah.
19:01:36 <tolkad> Eduard_Munteanu: or sequential word values
19:01:38 <xplat> like data Widget a = A (A a) | B (B a); data A (A a) = AA (AA a) | AB (AB a); ...
19:01:47 <tolkad> Eduard_Munteanu: then just subtract a constant and jump
19:02:23 <gwern> @quote metaperl
19:02:23 <lambdabot> metaperl says: I never thought anyone could be on IRC as much as you and look that good
19:02:40 <Eduard_Munteanu> I'm not sure it's common to have so many constructors and do pattern matching on them like that.
19:03:17 <taotree> Question on error here: http://hpaste.org/43587/gadt_rigid
19:03:33 <taotree> "GADT pattern match in non-rigid context"
19:03:52 <gwern> @quote punching
19:03:52 <lambdabot> mreh says: I feel like I just made a joke and everyone is laughing, except they're not, they're punching me
19:03:57 <xplat> tolkad: it would be easy to generate a jump table if you were guaranteed to have a nice set of non-overlapping patterns that only matched on the outermost constructor of the first argument.  for all i know maybe it does that, even
19:04:14 <tolkad> xplat: that's what I'm curious about
19:04:50 <xplat> but that doesn't seem to be how people usually use pattern matching
19:05:11 <Eduard_Munteanu> taotree: have you tried following its advice?
19:05:20 <Eduard_Munteanu> taotree: "Probable solution: add a type signature for something"
19:05:32 <taotree> Eduard_Munteanu, the "something" part is what I'm not sure about
19:05:38 <mdmkolbe> xplat: are we talking about jump tables as an internal part of compilation or coding up jump tables at the user level?
19:05:42 <gwern> @quote oklopol
19:05:42 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
19:06:12 <mdmkolbe> @mdmkolbe
19:06:12 <lambdabot> Unknown command, try @list
19:06:17 <mdmkolbe> @quote mdmkolbe
19:06:18 <lambdabot> chessguy says: [mdmkolbe just wrote gunzip in Haskell] mdmkolbe, what was it, about 8 lines of code? :)
19:06:30 <Eduard_Munteanu> Heh.
19:06:45 <gwern> @quote pl0nk
19:06:45 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
19:06:46 <MrWish> did whatever he was trying to implement have some hilariously freudian connotation?
19:06:51 <MrWish> thats what I would like to know
19:07:13 <Eduard_Munteanu> taotree: I'd start with testOther
19:07:21 <xplat> mdmkolbe: internal for jump tables, though i mentioned a way to get trees explicitly (and you could get an OO-like version of lookup tables by using an existentially-wrapped typeclass, too)
19:07:22 <tolkad> Eduard_Munteanu: here's an example in hackage: http://hackage.haskell.org/packages/archive/simpleirc/0.2.0/doc/html/Network-SimpleIRC-Core.html#t:IrcEvent
19:08:31 <tolkad> Eduard_Munteanu: an even bigger one: http://hackage.haskell.org/packages/archive/network/2.3.0.1/doc/html/Network-Socket.html#t:Family
19:08:51 <gwern> @quote remember
19:08:51 <lambdabot> remember says: the 5th of november
19:09:07 <Eduard_Munteanu> tolkad: hm, well it's only Disconnect there that makes a difference, otherwise it could be factored into an enumeration
19:09:28 <Bynbo7> hey, that's my birthday!
19:09:37 <Eduard_Munteanu> tolkad: and Family is easy to take care of if you 'derive Enum'
19:09:51 <gwern> @quote Ubuntu
19:09:51 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
19:10:02 <tolkad> Eduard_Munteanu: the derived Enum instance will still have to use an case expression
19:10:58 <mdmkolbe> xplat: ah.  sounds doable, but probably needs some benchmarks to figure out where the break-even point is.  (Yeah, there's some fidley parts to keep consistency with the semantics of pattern match order, but nothing too hard.)
19:10:58 <Eduard_Munteanu> tolkad: not really, I suppose you could dispatch some other way, after all you can get a number out of it.
19:11:02 <xplat> i thought it meant "I can't build firefox from source"
19:11:21 <Bynbo7> heh, speaking of which: http://www.reddit.com/r/Compilers/duplicates/fexet/comparison_of_firefox_compiled_with_clang_and_gcc/ >_>
19:11:25 <ksf_> hmmm. why does yesod pretend everything is a directory?
19:11:28 <gwern> @quote sheep1e
19:11:28 <lambdabot> sheep1e says: The fourth character presumably represents both "runtime" and "Writer monad", a kind of Haskell pun in Japanese.
19:11:33 <ksf_> I'd leave away the trailing / of every url
19:11:48 <mdmkolbe> xplat: Nah, I just means "It's not worth my time to build firefox from source"
19:12:04 <gwern> @quote sheep1e
19:12:04 <lambdabot> sheep1e says: Note to self: do not mess with gwern, he is capable of destroying you with his ninja-like use of everyday tools such as Google Calendar.
19:12:07 <tolkad> Eduard_Munteanu: how would you implement Enum on a type like that without a case expression?
19:12:11 <tolkad> Eduard_Munteanu: it isn't possible
19:12:44 <taotree> ROFL: GHC just gave me the error: "My brain just exploded."!
19:13:11 <mdmkolbe> ksf_: forgetting the slash when the server think's it is a directory sometimes results in an extra roundtrip due to a redirect
19:13:15 <Eduard_Munteanu> Bynbo7: that seems to say building is faster on clang
19:13:16 <ksf_> Gentoo, an ancient african word meaning "You do the thinking for me".
19:13:22 <xplat> tolkad: by magic
19:13:29 <gwern> @quote Gentoo
19:13:29 <lambdabot> Cale says: Gentoo is a massive waste of electricity.
19:13:30 <Bynbo7> Eduard_Munteanu: yes, that is one of the main goals of clang
19:13:35 <ksf_> mdmkolbe, yesod *is* the server.
19:13:41 <gwern> @quote Gentoo
19:13:41 <lambdabot> Cale says: Gentoo is a massive waste of electricity.
19:13:45 <gwern> @quote Gentoo
19:13:45 <lambdabot> Cale says: Gentoo is a massive waste of electricity.
19:13:49 <ksf_> it's canocalising every url to include a trailing slash.
19:13:50 <Eduard_Munteanu> tolkad: say Map k a where k = Family, a = some computation you'd do.
19:13:51 <Bynbo7> the other being COMPLETE AND UTTER DOMINATION OF GCC
19:14:14 <gwern> hm. if I were rewriting lambdabot, I would try to avoid letting quotes repeat too quickly
19:14:19 <tolkad> Eduard_Munteanu: and how does it write the Ord instance for k?
19:14:24 <gwern> @quote segfauled
19:14:25 <lambdabot> gwern says: Gentoo segfauled for your sins
19:14:28 <tolkad> Eduard_Munteanu: you can't unless you already have the Enum instance
19:14:41 <Eduard_Munteanu> tolkad: well it's easy to get Ord, especially if you can get Enum.
19:14:45 <xplat> g++ leaves a lot of room for building speed improvement, or did last i checked
19:14:46 <tolkad> Eduard_Munteanu: at some point you need a case expression
19:14:59 <Eduard_Munteanu> And I suppose standalone deriving is one way.
19:15:35 <edwardk> preflex: xseen dolio
19:15:35 <preflex>  dolio was last seen on freenode/#haskell 1 hour, 6 minutes and 37 seconds ago, saying: Of course, linear logic has modalities, too, for embedding non-linearity.
19:15:51 <dolio> Eh?
19:16:15 <Eduard_Munteanu> tolkad: not really, instead of pattern matching you do a map lookup.
19:16:15 <xplat> tolkad: or unsafeCoerce
19:16:27 <ksf_> oh, I see. it's forbidding trailing slashes for last path elements containing a dot, and requires them otherwise.
19:17:11 <tolkad> Eduard_Munteanu: but the map lookup will be implemented in terms of Ord, Ord must be implemented in terms of a case expression
19:17:26 <Eduard_Munteanu> tolkad: no, you can simply derive Ord :)
19:17:38 <tolkad> Eduard_Munteanu: but the generated instance for Ord will have to include a case expression
19:17:46 <Eduard_Munteanu> Or if you already have Enum, you can do it in terms of fromEnum
19:18:06 <tolkad> same with the generated instance for Enum, you can't write them in haskell without a case expression
19:18:06 <Eduard_Munteanu> a < b = fromEnum a < fromEnum b
19:18:21 <Eduard_Munteanu> You don't write it, GHC derives it for you.
19:18:34 <tolkad> yes but GHC will have to use a case expression when it generates the haskell
19:18:35 <xplat> this argument can probably be settled, like most others, by inspecting core and seeing if the derived instance plods or cheats
19:18:55 <Eduard_Munteanu> Ah, I'm not sure about the internals, yeah.
19:19:26 <Eduard_Munteanu> But it seems reasonable to have something like a number-based implementation of it.
19:19:35 <Eduard_Munteanu> *representation
19:19:42 <tolkad> I just learned case expressions were sequential. I thought they were log n because it's entirely computable to optimize it so that they are ALL that way
19:20:06 <Eduard_Munteanu> Yeah, I think so.
19:21:44 <ksf_> tolkad, ghc *could* do that, for certain types of expressions.
19:22:01 <xplat> you can't get O(log n) on overlapping deep case matches
19:22:08 <ksf_> there's also perfect hashing.
19:22:26 <Eduard_Munteanu> I think he means pattern matching on constructors, rather.
19:22:39 <xplat> like f 1:_ = 0; f _:1:_ = 1; f _:_:1:_ = 2; ...
19:23:16 <tolkad> xplat: ah, I mean log n on constructors of a single type
19:23:20 <tolkad> xplat: not on depth
19:23:33 <tolkad> xplat: I never expected it to optimize to log n on depth
19:24:11 <xplat> you can fail to optimize to log n on a single constructor, consider the above f with a long tuple instead
19:24:47 <xplat> i mean, there's still depth, but it's constant depth
19:26:06 <xplat> and patterns with only one-constructor depth can overlap when you have a function 'of multiple arguments'
19:26:44 <xplat> f 1 _ _ _ _ = 0; f _ 1 _ _ _ = 1; f _ _ 1 _ _ = 2; ...
19:27:37 <xplat> or use True if you don't consider 1 sufficiently constructor-ish
19:28:53 <xplat> i mean, it's basically doable, and certainly computable, to find the optimizable situations and optimize them, but it's not trivial
19:29:48 <Eduard_Munteanu> I suppose it should do it at least for matching a single, Enum-ish value.
19:29:57 <Eduard_Munteanu> Then you can do your own optimization in terms of maps etc.
19:30:06 <tolkad> Eduard_Munteanu: or a one-constructor-depth case expression
19:30:08 <int80_h> @hoogle liftIO
19:30:09 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
19:30:24 <Eduard_Munteanu> Yeah.
19:30:41 <Eduard_Munteanu> Like data Foo = One | Two | Three ... deriving (Ord, Enum)
19:31:53 <Eduard_Munteanu> Heck even for data Foo a b c = One a | Two b | Three c so you don't bother.
19:32:34 <xplat> data Runt = Strawberry | Cherry | Orange | Banana | /* Lime | Watermelon | */ SourApple | Grape
19:32:51 <Eduard_Munteanu> (though in the latter case I agree, code size can explote if it does too much optimization)
19:32:56 <Eduard_Munteanu> *explode
19:37:23 <taotree> Follow on question: I added a type sig and get brain explosion: http://hpaste.org/43591/gadt_explosion
19:38:33 <xplat> i'm not sure i should look at something that caused a brain that SPJ built to explode :)
19:41:57 <tolkad> Eduard_Munteanu: this should probably reduce code size
19:42:08 <tolkad> Eduard_Munteanu: the single constructor case that is
19:42:12 <Eduard_Munteanu> (p1o1 :*: p1o2) -- it seems there's only a type sig without any binding
19:42:19 <ksf_> "A fun exercise could be writing a web application that serves data simply using the default Show instances of datatypes, and then writing a web client that parses the results using the default Read instances."
19:42:22 <ksf_> hell y.es
19:42:26 <Eduard_Munteanu> But I'm not an expert on GADTs.
19:42:44 <Eduard_Munteanu> tolkad: yeah.
19:42:45 <taotree> binding?
19:43:03 <Eduard_Munteanu> taotree: where foo :: Bar; foo = ...
19:43:10 <Eduard_Munteanu> You've only got the first part.
19:43:39 <homekevin> Man, I suck at Haskell.
19:43:52 <Eduard_Munteanu> It's like writing foo = x where (x:xs) :: [Integer]
19:44:22 <taotree> got it, that explains the parse error when trying to convert to a case like it suggested. working on that...
19:44:54 <lispy_> taotree: I'm on the phone right now but I can help with the brain explosion when I get off the phone
19:45:18 <tolkad> I'm trying to read ghc's asm output but it is incomprehensible
19:45:28 <tolkad> is this core thing better?
19:45:37 <Eduard_Munteanu> Surely.
19:45:48 <Bynbo7> homekevin: no, you're just learning it lazily, it takes a while :P
19:46:24 <Eduard_Munteanu> I presume even STG is better than GHC asm
19:47:01 <ksf_> core is readable, if you know some basics.
19:47:40 <ksf_> in a nutshell, let introduces a thunk, case destroys one, and case matches are pretty-printed in the wrong direction.
19:48:00 <ksf_> try to ignore everything involving a typecast.
19:48:39 <Eduard_Munteanu> '-ddump-simpl' showed you core, IIRC.
19:48:51 <ksf_> cabal install ghc-core
19:49:06 <taotree> lispy_, Thank you. This might look a little familiar. It's related to something you helped me with before.
19:49:15 <Eduard_Munteanu> ksf_: what would be the difference?
19:49:29 <ksf_> a way superiour interface.
19:49:38 <Eduard_Munteanu> Ah.
19:49:40 <ksf_> incl. syntax highlighting
19:50:04 <ksf_> it's a wrapper around ghc, hscolour and less
19:50:51 <tolkad> I think it did turn out to be log n
19:51:08 <Eduard_Munteanu> Really?
19:51:19 <Eduard_Munteanu> Erm, how did you tell?
19:51:26 <tolkad> the core is still pretty incomprehensible, but it transformed it into a bunch of nested case expressions on Bools
19:51:37 <Eduard_Munteanu> Nice.
19:52:16 <Eduard_Munteanu> I'd try to leave Prelude out and define a really simple expression.
19:52:24 <tolkad> wait no
19:52:24 <lispy_> taotree: back
19:52:33 <tolkad> that was pattern matching on integers
19:52:35 <lispy_> taotree: I'll read over your code first
19:52:56 <taotree> lispy_, thanks. I annotated twice getting other errors
19:53:16 <tolkad> pattern matching on constructors generates a core case expression that looks pretty much like the haskell one
19:53:25 <tolkad> so I'm guessing it's sequential? idnk
19:53:29 <tolkad> idk
19:53:54 <tolkad> Eduard_Munteanu: but pattern matching on integral types seems to generate a big tree of Bool case expressions
19:54:02 <lispy_> taotree: it's e1 and e2 that are 'bad', do you know what ghc is getting at?
19:54:18 <Maxdamantus> Hm. Would it make sense for sequence to be lazy? sequence something >>= writeFile "foo"
19:54:28 <Maxdamantus> Hm. Would it make sense for sequence to be lazy? sequence something >>= writeFile "foo" . show
19:54:39 <taotree> lispy_, no
19:54:53 <lispy_> taotree: where/let are polymorphic
19:55:06 <lispy_> taotree: functions are monomorphic when they pattern match
19:55:14 <lispy_> taotree: do you know the difference there/
19:55:41 <lispy_> taotree: functions like: f :: a -> [a], are polymorphic but they get applied at a specific type (monomorphic)
19:55:57 <taotree> ah, that explains why the function pattern matching works
19:55:59 <lispy_> taotree: This distinction is very important inside a type checker
19:56:04 <lispy_> right
19:56:32 <lispy_> So, this "my brain exploded" thing relates to using an existential type in a place where a type must be made polymorphic (instead of monomorphic)
19:57:06 <lispy_> taotree: in your definition of (:*:), e1 and e2 are existential
19:57:18 <lispy_> I think...
19:57:31 <Eduard_Munteanu> They can't be anything else :/
19:57:45 <lispy_> taotree: So, the easy/dumb thing to do there...
19:57:59 <Eduard_Munteanu> Not to mention 'e' isn't used there.
19:58:13 <Eduard_Munteanu> So maybe 'data Spec a e1 e2' makes more sense.
19:58:19 <lispy_> taotree: Give an obviously wrong type signature for the expression that it is complaining about (the best two are either 'a' or 'Int', depends on what ghc is expecting)
19:58:44 <lispy_> taotree: Then GHC will complain that your obviously wrong type signature is not what it expects, and it will give you a clue as to what it expects
20:00:57 <Eduard_Munteanu> If anything, 'a' should be existential I think.
20:01:02 <ksf_> "setup: Can't find transitive deps for haddock"
20:01:08 <ksf_> what's that supposed to mean?
20:01:10 <taotree> It just keeps telling me invalid type sig
20:01:20 <taotree> This line:        (p1o1 :*: p1o2) :: Int    ?
20:01:25 <lispy_> taotree: another solution is to use a locally defined function (inside a where clause) or use a case-expression
20:01:56 <lispy_> taotree: maybe the error is happening before that line
20:02:10 <homekevin> OK, so you can't add an Int and an Integer
20:02:22 <lispy_> homekevin: right, they are different types
20:02:32 <lispy_> homekevin: but you can convert the Int to Integer
20:02:38 <lispy_> homekevin: look at fromIntegral
20:02:55 <Eduard_Munteanu> :t (+)
20:02:56 <lambdabot> forall a. (Num a) => a -> a -> a
20:03:15 <lispy_> taotree: where does your parameter come from?
20:03:29 <taotree> lispy_, which param?
20:03:33 <lispy_> taotree: exactly :)
20:03:42 <lispy_> taotree: something is wrong with the type of your function
20:03:49 <homekevin> I'm not quite getting this yet. They have typeclasses in common that support +, don't they?
20:04:25 <lispy_> homekevin: That's correct, but that's not enough.  The type signature of (+) requires that both things be the SAME instance of Num
20:04:36 <homekevin> Oh, OK.
20:05:10 <lispy_> homekevin: the type that would do what you want would be more like (+) :: (Num a, Num b) => a -> b -> {- what goes here? -}
20:07:18 <homekevin> OK, so I was actually trying to add an Int and something that only had to be "Integral", and that gives a type error.
20:07:24 <homekevin> I think I see why, thoug.h
20:07:37 <lispy_> taotree: oh, I get your syntax error now
20:07:52 <homekevin> "Integral" can be things other than Int, and + needs them to agree.
20:08:05 <lispy_> taotree: You can't put a type signature on an expression 1 line and then also give the definition.  You can put a type sig on the same line as a name though
20:09:05 <homekevin> What does it mean when :t 1 shows (Num t) => t? is 1 not a specific type?
20:09:08 <lispy_> homekevin: yeah, in the type sig of (+) the 'a' has to be used consistently.  So once we fix 'a = Int' it has to be 'Int' for the whole signature
20:09:15 <lispy_> homekevin: correct
20:09:23 <lispy_> homekevin: 1 is polymorphic
20:09:51 <homekevin> Hm, kind of like maxBound I guess
20:10:06 <lispy_> :t maxBound
20:10:07 <lambdabot> forall a. (Bounded a) => a
20:10:12 <lispy_> homekevin: exactly
20:10:20 <homekevin> But it's a bit less weird with 1, because at least its value stays the same for all types.
20:10:42 <taotree> lispy_, So, if I use a function and tuple'ize it, it works. But I was hoping to avoid that if I could, since I don't need the tuple for anything.
20:10:45 <lispy_> > (1 :: Int, 1 :: Complex Double, 1 :: Double)
20:10:46 <lambdabot>   (1,1.0 :+ 0.0,1.0)
20:10:58 <lispy_> homekevin: is that the same for each of those? :)
20:11:18 <lispy_> taotree: You could use a case
20:11:35 <lispy_> taotree: did you paste the working code?  I could make suggestions possibly
20:11:38 <homekevin> Separated from type I'd say the value is the same.
20:12:20 <homekevin> :t (==)
20:12:21 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:12:43 <homekevin> Same kind of thing there. I guess types have to match exactly in a lot of cases.
20:13:07 <lispy_> homekevin: the definition of fromInteger determines how the literal 1 is interpreted.  You could, if you wanted to be evil, make it so that fromInteger 1 = 5 
20:13:10 <taotree> lispy_, I'm not sure how to do a case that would do what I want. And when I try to do a case, I get that GADT pattern match in non-rigid context again
20:13:23 <lispy_> homekevin: and fromInteger is something you define when you make a Num instance
20:13:59 <lispy_> taotree: The case may need an extra type sig.
20:14:09 <scooty-puff> is using ReaderT or Reader kind of cheating as a mean to get to pointfree form?
20:14:14 <lispy_> taotree: So a local function probably is best, but what is the extra tuple?
20:14:22 <scooty-puff> *means
20:14:43 <scooty-puff> runReaderT $ ask >>= ... >> ask >>= ...
20:14:44 <scooty-puff> etc.
20:14:48 <glguy> scooty-puff: There are no rules when paring something down to show in an IRC channel !
20:14:56 <Bynbo7> why not just use the (->) monad?
20:15:07 <scooty-puff> go on..
20:15:08 <taotree> lispy_, How would I do a local function that would not tuple'ize it? 
20:15:14 <Bynbo7> > (+1) >>= (*) $ 7
20:15:14 <lambdabot>   56
20:15:18 <scooty-puff> glguy, you mean put up on hpaste?
20:15:22 <lispy_> taotree: please paste your working code :)
20:15:46 <glguy> scooty-puff: If you are putting it on hpaste you have enough room that you don't have to butcher it
20:15:52 <scooty-puff> k
20:16:29 <scooty-puff> http://hpaste.org/43594/reader
20:16:34 <scooty-puff> starts at putABCFile
20:16:40 <taotree> lispy_, this compiles:   http://hpaste.org/paste/43591/gadt_explosion_annotation#p43595
20:16:47 <scooty-puff> haven't written it all, note the ellipse
20:17:34 <glguy> scooty-puff: there isn't a good reason to try for point-free style at that cost in source code you are putting in a file
20:17:35 <lispy_> taotree: in testOther, I doubt ghc constructs your tuple
20:18:01 <scooty-puff> k
20:18:13 <lispy_> taotree: you could also move tupling into the where-clause of testOther
20:18:17 <believa> Using the cabal framework, is there a way to enforce the existence of a particular binary being installed on the system you're installing a cabal package on? What would you need to add to the package's Setup.hs - would you create a handler for "preConf" and somehow return an error if it doesn't exist?
20:18:27 <scooty-puff> guess replacing ask with "return x" for arg x
20:18:50 <lispy_> The new hpaste has some weird features.  How do I edit the code from the previous paste??
20:19:36 <taotree> lispy_, not sure how I could move it in there.
20:19:39 <lispy_> I guess I have to copy&paste, that seems like a step backwards
20:19:44 <taotree> lispy_, or do you mean a local function?
20:20:06 <glguy> lispy_: you need a time-machine, I suspect
20:20:27 <lispy_> taotree: hit reload :)
20:20:38 <scooty-puff> where can you import the Monad ((->) a) instance?
20:20:57 <lispy_> glguy: I really prefered your hpaste.  Now I have to enter (and always re-enter) a name.  I use dpaste now :(
20:22:03 <taotree> lispy_, ok, right. If you hit reload again, though, you'll see yet another fun thing. I didn't really want to convert it to Maybe but... maybe I have to
20:22:24 <lispy_> taotree: you could make tupling so that it doesn't return both.  That would get rid of the tuple.
20:22:40 <taotree> lispy_, But I need both--to use later on in that where clause
20:22:56 <taotree> lispy_, That's the whole point--I'm just trying to unwrap that :*: thing
20:23:15 <lispy_> If you just want to unwrap it, then you want to switch to case + type signature
20:23:18 <djahandarie> scooty-puff, it's in the module Control.Monad.Instances
20:23:24 <lispy_> taotree: OR
20:23:24 <scooty-puff> k
20:23:39 <lispy_> taotree: write all the logic you need in the locally defined function that has the pattern match
20:23:54 <lispy_> foo (a :*: b) = ....
20:24:30 <lispy_> taotree: untested, but I think you can be rid of the weird type errors with a forall
20:24:53 <lispy_> tupling :: Spec (Double :*: Double) NonEmpty -> (forall _1 _2. (Spec Double _1, Spec Double _2)) -- untested
20:25:44 <taotree> lispy_, no go on the forall, same error
20:26:19 <taotree> lispy_, Problem with writing all that logic is that those unwrapped values may be used multiple times in that where. And I'll be doing this unwrapping multiple times.
20:26:26 <lispy_> taotree: the only other trick I know is ugly.
20:28:24 <lispy_> taotree: FWIW, I had to deal with similar things here: http://files.codersbase.com/thesis.pdf
20:28:35 <lispy_> taotree: chapter 4-5
20:28:47 <taotree> lispy_, To give an example, I've pasted there what I want to be able to do.
20:33:25 <lispy_> taotree: http://hpaste.org/paste/43591/gadt_explosion_annotation#p43599
20:34:12 <lispy_> taotree: that won't compile as-is, because I don't know here p1 comes from
20:34:18 <lispy_> or x
20:35:22 <lispy_> taotree: I don't like to suggest existential types to people because of this mess :(
20:38:16 <taotree> lispy_, sorry, but I can't figure out how to specify the type signature inside the case
20:39:03 <lispy_> taotree: somewhere on the left of "->" :)
20:40:16 <lispy_> taotree: sorry I'm not more helpful at this part.  I'm at a loss as to what to suggest.  This part of GADTs is really quite painful.
20:43:18 <glguy> http://hpaste.org/43591/gadt_explosion is this the original source code for the question at hand?
20:43:26 <taotree> lispy_, I really appreciate your help
20:43:46 <taotree> glguy, yes
20:44:08 <ddarius> > let f ((,) x -> p) x = p in f True False 
20:44:09 <lambdabot>   (x,True)
20:44:18 <ddarius> > let f x ((,) x -> p) = p in f True False 
20:44:19 <lambdabot>   (True,False)
20:45:04 <glguy> what the what?
20:45:18 <lispy_> glguy: the problem here is the way existentials get treated in let/where
20:45:50 <lispy_> ddarius: is that a view pattern?
20:47:31 <Bynbo7> oh hey, that could be useful... sort of
20:49:08 <Bynbo7> > let f x ((x ==) -> True) = "They're the same :o" in f 1 1
20:49:09 <lambdabot>   "They're the same :o"
20:49:12 <Bynbo7> > let f x ((x ==) -> True) = "They're the same :o" in f 1 2
20:49:13 <lambdabot>   "*Exception: <interactive>:3:4-47: Non-exhaustive patterns in function f
20:49:38 <Bynbo7> seems so close to being abe to do the f x x thing in erlang
20:53:01 <edwardk> bynbo7: that is { case (x, `x`) => … } in scala ;)
20:53:23 <edwardk> `x` is 'compare' to this value in scope.
20:53:49 <Bynbo7> > let f x ((\y -> (x == y)) -> (True,y)) = "They're the same :o" in f 1 2
20:53:50 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:53:50 <lambdabot>         against inferred type ...
20:54:01 <Bynbo7> > let f x ((\y -> ((x == y),y)) -> (True,y)) = "They're the same :o" in f 1 2
20:54:01 <lambdabot>   "*Exception: <interactive>:3:4-65: Non-exhaustive patterns in function f
20:54:06 <Bynbo7> > let f x ((\y -> ((x == y),y)) -> (True,y)) = "They're the same :o" in f 1 1
20:54:07 <lambdabot>   "They're the same :o"
20:54:14 <Bynbo7> > let f x ((\y -> ((x == y),y)) -> (True,y)) = "They're the same :o" ++ show y in f 1 1
20:54:16 <lambdabot>   "They're the same :o1"
20:54:16 <edwardk> bynbo7: the funny thing is haskell explicitly removed that language feature. it is present in miranda
20:54:27 <Bynbo7> really? interesting
20:54:43 <Bynbo7> i can see how it might cause problems, but it's pretty easy to avoid those problems
20:55:06 <edwardk> i think it was mostly to reduce the amount of magic syntax, and to avoid patterns introducing class dependencies
20:55:16 <Bynbo7> yeah
20:55:27 <edwardk> witness the lack of monadfail ;)
20:56:18 <lispy_> taotree: hmm...I've added type sigs in all the usual places to no avail either :(
20:58:08 <taotree> lispy_, I'
20:59:17 <taotree> lispy_, I'm thinking I might know why... The types are set up to enforce that there has to be a Some in there somewhere. Well... the way I'm using this... I wonder if it's not able to enforce that. And so... it's doing what I told it to and not allowing writing code that doesn't enforce that.
21:00:19 <lispy_> taotree: if that's the case you could write a projection function that takes it out of the Some type
21:00:24 <lispy_> er, Spec type
21:00:59 <mbuf> I am trying to work out foldr for map' as given at http://learnyouahaskell.com/higher-order-functions, let map' f xs = foldr (\x acc -> f x : acc) [] xs
21:01:35 <taotree> lispy_, yeah, like the fromSpec I just wrote :)   But I think I'm going to get rid of that restriction. There's just no way it's going to work, I think. Because there will be times where I have to create an all None type--and I'll have to look for it and do something based on it
21:01:36 <mbuf> if foldr is to be evaluated from right, shouldn't it be like foldr \xs acc -> f xs : acc) [] x ?
21:02:20 <mbuf> sorry, foldr (\xs acc -> acc : f xs) [] x
21:03:29 <Bynbo7> > foldr f x [a,b,c]
21:03:30 <lambdabot>   f a (f b (f c x))
21:03:47 <Bynbo7> > foldr (\x acc -> f x : acc) x [a,b,c]
21:03:48 <lambdabot>   Couldn't match expected type `[a]'
21:03:48 <lambdabot>         against inferred type `SimpleRef...
21:03:58 <taotree> lispy_, But if I remove that (the e/e1/e2 you saw in the type), can I make this not a GADT at all, but still have the really nice :*: syntax?
21:04:19 <lispy_> taotree: yes
21:04:19 <Bynbo7> > foldr (\x acc -> f x : acc) x [a,b,c] :: [Expr]
21:04:20 <lambdabot>   Couldn't match expected type `[a]'
21:04:20 <lambdabot>         against inferred type `SimpleRef...
21:04:23 <Bynbo7> bah
21:04:34 <lispy_> taotree: in fix type constructors are Haskell98
21:04:57 <lispy_> taotree: er, sorry.  infix DATA construtors are H98
21:05:17 <lispy_> taotree: you can enable infix TYPE constructors with a rather harmless extension
21:06:03 <lispy_> oh, you're already using it: TypeOperators
21:06:09 <Bynbo7> to get a `Map` b?
21:08:20 <taotree> Using is one thing, understanding is another :)
21:08:23 <taotree> data Sp a b = Sp a :**: Sp b | Non | Som a  ;  type DD2 = Sp (Double :**: Double) -- Not in scope: type constructor or class :**:
21:09:18 <Bynbo7> :**: isn't a type, it's a constructor
21:09:30 <Bynbo7> yo probably want SP Double Double
21:10:08 <glguy> lispy_: using Agda I get the error: http://hpaste.org/paste/43591/gadt_explosion_annotation#p43600
21:10:11 <taotree> ah... I see.
21:10:12 <lispy_> taotree: data a :*: b = a :*: b -- I think this is valid
21:10:24 <glguy> lispy_: Perhaps your problem is not GADTs in the Haskell example but the type families
21:10:58 <lispy_> glguy: Yeah, I was starting to think that
21:11:06 <lispy_> I like one-point-oh : Double :)
21:12:27 <lispy_> glguy, taotree: http://hpaste.org/paste/43591/gadt_explosion_annotation#p43601
21:12:30 <lispy_> that seems a bit fishy to me
21:13:10 <taotree> lispy_, Yes, I was getting that same error trying to do the case
21:13:15 <lispy_> What about it doesn't match exactly?
21:13:46 * lispy_ has been meaning to actually learn type families
21:13:57 <copumpkin> they're very simple
21:14:00 <copumpkin> they're just type functions :P
21:14:31 <lispy_> copumpkin: but they're not injective! :)
21:14:41 <copumpkin> functions don't have to be either :P
21:14:47 <taotree> yeah, I was reading the dummies guide to GADT the other day on the wiki. Interesting. I look forward to when I understand it
21:14:59 <lispy_> copumpkin: mostly, I don't want to grossly misunderestimate them
21:15:11 <copumpkin> misunderestimation is key to goo learning
21:17:25 <lispy_> taotree: Sorry, but i'm out of ideas for today
21:17:37 <lispy_> taotree: I think glguy has a good idea there prototyping it in agda :)
21:18:10 <glguy> lispy_: pattern matching on types in agda where the types are computed with functions is almost always a nightmare :) (and I imagine that it isn't agda's fault)
21:18:32 <lispy_> glguy: hmm...That makes sense actually.
21:18:38 <lispy_> glguy: but, I had never thought about it
21:19:14 <lispy_> You'd have to troll through the inverse image
21:19:49 <taotree> Thanks again for all your help
21:20:06 <lispy_> taotree: you are totally welcome :) That's how this channel works
21:21:04 <lispy_> copumpkin: did you see the "web browser" in agda today?
21:21:38 <lispy_> copumpkin: more like an FFI binding to webkit
21:22:06 <copumpkin> hpaste was down when I saw the link
21:22:22 <lispy_> copumpkin: it came back up within 5 min though
21:22:37 <lispy_> copumpkin: I think the link is still on reddit
21:22:59 <lispy_> ah, yup: http://hpaste.org/43574/webkit_for_agda
21:24:05 <taotree> This creates a type constructor :*:, right?   data Spec a where (:*:) :: Spec a -> Spec b -> Spec (a :*: b)
21:24:11 <taotree> is there some way to do the same thing without GADT?
21:26:31 <lispy_> taotree: I gave you an example earlier but maybe you missed it
21:26:51 <adu> FFI? WebKit? C++?
21:26:53 <lispy_> taotree: using the normal syntax, the TYPE constructor apperas on the right of the '=', and the data constructor on the left
21:26:54 <adu> wut
21:27:01 <taotree> taotree: data a :*: b = a :*: b -- I think this is valid
21:27:02 <lispy_> adu: agda!
21:27:27 <lispy_> taotree: yeah, so the usage on the right is a type constructor and the one on the left is a data constructor
21:27:57 <taotree> thanks... I had it commented out... oops!
21:28:10 <lispy_> taotree: haha.  I'm stupid.  I have my left and right mixed up :(
21:28:24 <lispy_> taotree: Turns out, when I said right I meant left and when I said left I meant....yeah.  Sorry!
21:29:20 <taotree> lispy_, it's ok, I knew that
21:31:13 <lispy_> taotree: heh, you already knew I was stupid?  That's reassuring ;)
21:32:09 <Wooga> where i can find implementation of return of State monad?
21:32:22 <edwardk> return a = State $ \s -> (a, s)
21:32:29 <taotree> lispy_, no! sorry
21:32:32 <Wooga> thanks
21:32:47 <lispy_> glguy: I'm signing up for minecraft :)
21:32:55 <edwardk> in reality its based on StateT now so its return a = State $ \s -> return (a, s)
21:33:05 <edwardk> where return is over the Identity monad
21:33:17 <Pai> Is it easier to write cross-platform code in Haskell?
21:33:33 <lispy_> Pai: it's usually pretty easy.
21:33:34 <edwardk> pai: if you don't need much out of your platform, yes
21:33:36 <Zao> Pai: If you don't use libraries that are hard/impossible to build everywhere, it's not horribly hard.
21:33:51 <shachaf> Pai: Easier than in assembly.
21:33:54 <lispy_> Pai: sometimes if you do certain things (mostly using some libraries) it becomes a bit trickier.
21:34:27 <Pai> edwardk, I just need basic file operations and threading support
21:35:32 <edwardk> then you are golden
21:35:39 <edwardk> those work beautifully cross platform
21:36:18 * edwardk is torn between making a 3x3 eyes reference or a 'when come back bring pai' reference.
21:37:08 <pai> edwardk, nice
21:38:49 <taotree> If I haven't overstayed my welcome.... I'm trying to convert the afore discussed mess to non-GADT... http://hpaste.org/43602/gadt_to_non
21:38:54 <taotree> but not sure how to do so
21:40:09 <lispy_> taotree: do you know about kinds?
21:40:24 <taotree> lispy_, I know generally what they are, but not in detail
21:40:38 <lispy_> taotree: types like Int have kind *, Maybe has kind * -> *, and Maybe a, has kind *
21:40:50 <lispy_> taotree: Spec has kind * -> * -> *
21:41:03 <lispy_> taotree: and thus, D2 has kind * -> *
21:41:11 <lispy_> taotree: but you use D2 as if it has kind *
21:41:47 <lispy_> taotree: basically, you need to specify more type variables somewhere
21:43:33 <taotree> ok... so type D2 = Spec (Double :*: Double) () works, but I have no need of that () so... am I doing something wrong to require it there...
21:43:59 <taotree> It's the b in Spec a b, right?
21:45:29 <lispy_> taotree: oh, you actually want something more like data a :*: b = a :*: b | None | Some a
21:45:43 <lispy_> taotree: that Spec (Double :*: Double) is kind of funky
21:45:51 <lispy_> taotree: that would actually be Spec Double Double
21:46:02 <NemesisD> anyone have a good rule of thumb for when to use records instead of tuples?
21:46:16 <bvck> hi folks, I have been playing around with Jones & Lester 'Implementing Functional Languages'. Couple of questions...(1) Is 1.11 the latest version and (2) Does anyone know where I can get my grubby hands on the 'tutorial' file set?
21:46:21 <taotree> lispy_, well... like I said, I'm trying to get the same syntax I had with the GADT, but without the GADT
21:46:25 <NemesisD> every time i read anything about records people seem to be pretty iffy on them
21:46:42 <lispy_> NemesisD: records are nice.  I use them a lot
21:47:14 <lispy_> taotree: well, you're doing something a bit strange here.
21:47:44 <lispy_> taotree: the data constructor for the type a :*: b is called Spec and the data constructor for Spec a b is called (:*:)
21:47:50 <taotree> lispy_, yeah, not surprising :)  I just took the GADT code and tried to remove the GADT part and make it work
21:48:50 <taotree> it had data a :*: b  with no right side at all... I had put that other thng in just trying to get it to compile
21:56:51 <ksf_> haddock: could not execute: /home/ian/local/bin/gcc
21:57:00 <ksf_> NO I DON"T WANT TO KNOW WHY THAT HAPPENED
21:57:04 <ksf_> I'm scared.
21:59:20 <sproingie> excve failed: nethack: no such file or directory
22:02:59 <ksf_> hmmm. apparently, the haddock that comes with my nightly ghc is borked.
22:03:26 <ulfdoz> /home mounted noexec?
22:03:34 <ulfdoz> dead link?
22:04:08 <ksf_> time to nuke it.
22:04:29 <ksf_> nah.
22:04:49 <ksf_> a) I use ~/usr to install stuff
22:05:05 <ksf_> b) in the case of ghc, ~/ghc
22:05:18 <ksf_> c) my user is called "ksf", not "ian"
22:06:43 <Zao> ksf_: Isn't there some Haskeller named Ian?
22:06:59 <ddarius> Zao: There are probably quite a few.
22:07:00 <kfr> Ian Peyton Jones
22:07:23 <ddarius> Zao: But you're probably thinking of Ian Lynagh
22:07:29 <Pseudonym> Ian Wadler?
22:07:38 <Zao> ddarius: Probably.
22:07:40 <ksf_> the one that happens to administer the buildbot?
22:08:06 <Zao> The point I'm trying to make, is that there may be some path hardcoded either manually or when building some artifact in the past.
22:08:57 <ksf_> such stuff just shouldn't happen
22:09:28 <ksf_> I don't even see why haddock should want to execute gcc, even more so a specific version
22:09:39 <Zao> ksf_: For preprocessor, maybe?
22:09:56 <Zao> If memory serves me right, things love to invoke ${CC} -E
22:10:38 <Zao> Well, I might be thinking of GHC itself - http://www.dmpots.com/blog/2010/05/08/building-ghc-with-clang.html
22:10:51 <ksf_> then it should bleeding use /usr/bin/gcc
22:11:32 <ksf_> or, actually, /usr/bin/env gcc
22:11:59 * ksf_ can't stand people who use #!/usr/bin/runhaskell
22:12:07 <ksf_> it's #!/usr/bin/env runhaskell
22:13:23 <glguy> lispy_: another complication with that pattern match is that None and Some could actually have the types Spec (a :*: b) e
22:13:41 <glguy> lispy_: since you could store a value of a :*: b in a some, or not store one in a none
22:14:08 <glguy> so you don't know anything about the value of a  Spec (Double :*: Double) (calc nonempty nonempty) 
22:29:30 <ksf_> ah bugrit.
22:29:36 <ksf_> I'm changing back to 6.12.3
22:30:09 <accel> if I put ! all over the place, do I pretty much get to use haskell like ocaml?
22:30:51 <ksf_> nah, you'd still have superiour syntax.
22:31:17 <shachaf> ksf_: Except for all the !s.
22:31:22 <ksf_> also, define "all over the place".
22:31:28 <accel> can I get most of the advantages of ocaml
22:31:35 <accel> by putting ! all over the place
22:31:38 <ksf_> you will have *massive* problems putting it everywhere.
22:31:40 <ddarius> O'Caml has advantages?
22:31:40 <shachaf> It's not really that simple.
22:32:13 <ksf_> > let fibs = 1:1:zipWith (+) fibs (tail fibs)
22:32:14 <lambdabot>   not an expression: `let fibs = 1:1:zipWith (+) fibs (tail fibs)'
22:32:17 <ksf_> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
22:32:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:32:24 <ksf_> ...add a !. I dare you.
22:33:16 <accel> !
22:33:16 <ksf_> if you want to be sure something is evaluated there's things like deepseq, but that doesn't make haskell ocaml.
22:34:09 <ddarius> Also if you want O'Caml, it's right over there.
22:34:24 <accel> i like typeclasses
22:34:26 <accel> and haskell syntax
22:39:44 <Bynbo7> accel: why do you refuse to learn how to use things, instead of trying to turn them into what you know? you'relike those people who go and buy a macbook pro, and just install windows on it. it's idiotic
22:40:44 <NihilistDandy> Bynbo7: I've been here 2 minutes, and already I like you
22:40:49 <accel> Bynbo7: not windows, ubuntu
22:40:54 <Bynbo7> excellent :)
22:40:59 <Bynbo7> accel: no, windows
22:41:21 <Bynbo7> linux would be even more idiotic,it kills macs because it's got horrible thermal support for them
22:41:25 <accel> Bynbo7: no, I have a macbook pro; and it's ubuntu, not windows that is installed on it
22:42:14 <NihilistDandy> Bynbo7: I had a gentoo build on a partition at one point that handled things without too much trouble.
22:42:16 <Bynbo7> i'm very strongly considering ignoring you
22:43:00 <ddarius> Bynbo7: Do you have your answer?
22:43:19 <Bynbo7> i do
22:43:24 <accel> do you guys feel threaened by ocaml
22:43:34 <accel> i feel like if I wnated haskell to be like C; you'd be tellling me how great haskell is
22:43:41 <accel> whereas ocaml, it's close enough that there is a threat
22:43:57 <Bynbo7> if you wanted haskell to be like C, we'd be telling you to use C
22:44:11 <Bynbo7> if you want to use ocaml because you can't understand how to program in haskell, use ocaml
22:44:24 <NihilistDandy> That's basic programming logic, really
22:44:55 <mjrosenb> category theory is hard, lets hack in ocaml?
22:46:41 <NihilistDandy> Or let's just learn category theory and stop pussy-footing about
22:46:52 <Bynbo7> or just learn the basics of haskell
22:47:01 <glguy> You hardly need to know any category theory to use Haskell
22:47:08 <Bynbo7> indeed
22:47:12 <ksf_> you don't need *any*.
22:47:14 <glguy> rather I'm not sure it even helps
22:47:15 <NihilistDandy> ^^
22:47:16 <mjrosenb> NihilistDandy: want to buy me a book on category theory? i'll gladly read it
22:47:16 <Bynbo7> i wouldn't say i know any CT
22:47:29 <NihilistDandy> mjrosenb: I have some books in PDF, if you like
22:47:30 <Bynbo7> glguy: unless you're edwardk
22:47:43 <glguy> Bynbo7: well, then it helps you do things with category theory in Haskell
22:47:45 <ksf_> knowing that Haskell's functors are endofunctors in Hask isn't particularily helpful.
22:49:04 <mjrosenb> ksf_: i'd imagine that it would make it easier to understand the relationships between all of the modules in Control.*
22:49:55 <ksf_> nope, it won't.
22:50:29 <ksf_> whether you understand the relationships in terms of CT or lambda calculus or wishful thinking doesn't matter much.
22:51:02 <ksf_> it's like saying "you need to grok OOP to do fourier analysis"
22:51:35 <NihilistDandy> Well, I should probably clarify that I'm a math major :/
22:51:39 <glguy> You need to grok OOP to do *fast* fourier analysis?
22:51:39 <ksf_> ...just because some popular fourier code happens to be organised in a roughly OOP-resembling way.
22:51:42 <NihilistDandy> I was mostly just poking fun
22:52:15 <ddarius> mjrosenb: The name Caml and thus O'Caml comes from "Categorical Abstract Machine."
22:52:47 <mjrosenb> ksf_: no, but you do need to grok OOP to understand how to use a fft library that has a very oop-ish interface
22:53:00 <mjrosenb> ddarius: you're no fun.
22:53:18 <ddarius> mjrosenb: Well, in (O')Caml's defense.  It is no longer based on the CAM.
22:53:50 <ddarius> But that doesn't change the name any, and (O')Zincl doesn't have the same ring.
22:54:16 <glguy> same group at least?
22:54:38 <ksf_> mjrosenb, no you don't need to understand what an AbstractImplementationFactoryDispatchPatternFactory is.
22:54:50 * ddarius likes how SML and Caml are clearly in the same family, the ML family, but the "ML"s in their names mean rather different things.
22:54:52 <glguy> ksf_: What's that?
22:54:59 <ksf_> hell if I know.
22:55:15 <ksf_> but I'm quite sure you can construct it.
22:55:21 <ksf_> just like zygohistomorphic prepromorphisms.
22:55:39 <glguy> ddarius: the L's stand for that same thing, at least
23:13:21 <ksf_> cabal is too heavy-weight.
23:13:52 <ksf_> compiling setup.hs usually takes longer than compiling the rest of the package...
23:14:03 <ksf_> though that should mostly be the linker.
23:19:27 <glguy> Why compile Setup.hs?
23:19:37 <ksf_> ask portage
23:19:46 <glguy> portage: Why compile Setup.hs?
23:19:58 <accel> paul hudak's haskell school fo epression of fucking brilliant
23:20:00 <ksf_> actually, ask cabal-install
23:20:04 <ksf_> it's doing the same.
23:20:10 <mjrosenb> glguy: you can use runhaskell :-p
23:24:08 <ksf_> compiling isn't the actual problem, that's fast enough. the problem is linking, to which the solution is dynamic linking.
23:24:34 <ksf_> even interpreted code would've to be typechecked and compiled down to bytecode, anyways.
23:34:35 <taotree> What does this mean when output when running a haskell program: "learn: <<loop>>"   infinite loop or something?
23:35:20 <ksf_> yep.
23:35:48 <pastorn> taotree: do you have something like "f x = f x"?
23:35:51 <ksf_> in particular, you're trying to evaluate a thunk you're already evaluating.
23:36:30 <ksf_> ...which is the most common type of infinite loop compiled code can detect
23:37:23 <dolio> f x = f x will actually not be caught.
23:37:33 <dolio> Unless some optimizations change it.
23:38:02 <ksf_> sure it will
23:38:26 <dolio> Try it.
23:38:35 <ksf_> once f is entered your thunk is black-holed, then f is entered again, thus you're stepping into it.
23:39:20 <dolio> That is not a circular thunk.
23:39:38 <ksf_> wut?
23:40:59 <ksf_> I hate to admit it, but evidence suggests you're right.
23:41:25 <dolio> f is a function that vacuously calls itself.
23:41:27 <ddarius> f is in WHNF so there's no thunk and no need to update or blackhole it.
23:41:41 <dolio> It isn't a thunk that is self-referential.
23:41:49 <ksf_> so it's sloppy thinking on my part.
23:42:21 <ksf_> ghc should arguably catch that one, though.
23:42:53 <shachaf> How do you make ghci catch loops?
23:42:57 <ksf_> ...it's easy enough to prove that it's bottom.
23:43:06 <ksf_> shachaf, you precompile the code.
23:43:34 <ddarius> ksf_: The only reason it catches the other ones is because it is free to do so.  This feature wasn't added to be helpful.
23:43:57 <shachaf> ksf_: Aw.
23:43:59 <kfr> What's wrong with loops
23:44:52 <ksf_> they don't have any meaning.
23:45:07 <Taejo> kfr: loops like "x = x"
23:47:42 <taotree> tricky to track down...
23:51:58 <joe6> i am checking a package called bindings-libusb. It provides bindings to the libusb package. I am wondering whether installing such a bindings package through cabal automatically install the underlying libusb package?
23:52:27 <kfr> Nope, I would think not
23:52:47 <kfr> Considering you can install stuff as non-root
23:53:17 <joe6> kfr: thanks.
23:54:52 <taotree> oh, shame on me. I had sum = sum + x. I think I need a precompiler that if it sees anythiing like that it thwaps me on the head.
23:55:21 <shachaf> taotree: That's perfectly valid with an appropriate (+).
23:56:01 <opqdonut> though most meanings of + aren't idempotent
23:56:18 <opqdonut> or rather, they don't have idempotent elements
