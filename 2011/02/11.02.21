00:16:41 <jonkri> i was recommended to talk to someone here about gtk2hs, and i lost the nick. anyone knows who it might have been? thanks
00:22:05 <dons> jonkri: dcoutts? hmm. manateelazycat?
00:24:42 <jonkri> dons: thanks, it was manteelazycat :)
00:24:54 <jonkri> @seen manteelazycat
00:24:54 <lambdabot> Unknown command, try @list
00:24:54 <preflex>  Sorry, I haven't seen manteelazycat
00:25:53 <mux> 7.0.2rc2 is out, yay
00:26:49 <dankna> so I saw
00:35:13 <accel_> anyone having trouble installing the haskell platform on the Mac?
00:48:11 <siracusa> jonkri: Here was here 3 hours ago.
00:48:27 <jonkri> siracusa: thanks :)
00:55:31 * hackagebot Pathfinder 0.5.2 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.5.2 (GeorgeGiorgidze)
00:56:31 * hackagebot DSH 0.5 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.5 (GeorgeGiorgidze)
00:57:57 <quuuux> oh, hey, DSH. Has anyone tried it out properly yet?
01:02:20 <markus3> hi! a question: I have a OCR'ed text and I'm trying to parse it. It has a lo
01:02:36 <Jonno_FTW> a lo?
01:02:52 <theorbtwo> A lot of surpurflous newlines?
01:02:59 <markus3> t of random spaces and newlines and it is therefore hard
01:02:59 <markus3> yep
01:03:11 <Jonno_FTW> words ?
01:03:22 <markus3> and i thougt if i just tokenize it and then parse it
01:03:25 <markus3> like parse a list of string
01:03:41 <Jonno_FTW> words "here is a     lot of new\nlines"
01:03:50 <Jonno_FTW> > words "here is a     lot of new\nlines"
01:03:51 <lambdabot>   ["here","is","a","lot","of","new","lines"]
01:03:58 <markus3> but i have a hard time of figuring out, how should the code look like -- whats the type?
01:03:59 <markus3> im using parsec
01:04:19 <markus3> yes yes, i have the list ow words
01:05:09 <markus3> now previously when i had a string I could do: MyDataConstr <$> many1 letter <* spaces
01:05:10 <Jonno_FTW> or do you mean there is spaces and stuff in the middle of words?
01:05:48 <markus3> but now i have a list of strings, and i don't know how to apply that idiom... :(
01:05:48 <markus3> no, not in the middle of words
01:07:44 <markus3> what i basically want is like: sentence = Sentence <$> (concat <$> many1 word)
01:08:20 <markus3> do I have to define my own monad wrapping the parsec functuonality?
01:09:34 <earthy> nope
01:09:47 <markus3_> (sorry, I think i timed out)
01:10:10 <markus3_> did anyone say anything ? :p
01:10:23 <earthy> nope, you don't have to define your own monad wrapping parsec
01:10:34 <earthy> but you may want to deal with a tokentype other than Char
01:11:02 <markus3_> how do you mean?
01:11:23 <earthy> the Parsec type Parser a is a type synonym for GenParser Char () a
01:11:36 <markus3_> yup
01:11:47 <earthy> that Char is the type of the tokens that you read
01:11:57 <markus3_> yes
01:12:05 <earthy> so, you could also have the type GenParser String () a
01:12:16 <markus3_> yes
01:12:16 <markus3_> but now i think i nead String?
01:12:30 <earthy> but you'd have to restructure your parser to deal with tokens that are strings
01:12:34 <earthy> rather than chars
01:12:40 <markus3_> yes
01:13:00 <markus3_> i have all the parsers, but all working on a token type of char
01:13:08 * earthy nods
01:13:39 <earthy> your grammar is not dependent on chars though, is it, after you've split off the tokens?
01:13:42 <markus3_> hmm
01:14:00 <earthy> so, rewrite the tokenrecognizing part of the grammar
01:14:04 <markus3_> no i think not
01:14:09 <earthy> so that it'll work on strings
01:14:19 <earthy> then the rest should still work and be type correct
01:14:54 <markus3_> hmm, just rewrite the tokenizer?
01:14:59 <earthy> assuming you've constructed an appropriate AST or somesuch as the parser's return value
01:15:08 <markus3_> yes
01:15:10 <earthy> markus3_: the tokenizing part of the grammar, yes
01:15:23 <earthy> (it's not a separate tokenizer as such ;))
01:16:07 <markus3_> right now it essentially does what the function words does
01:16:25 <earthy> well... ;)
01:16:33 <earthy> go try :)
01:17:27 <markus3_> okay, but *just* rewrite the tokenizer? :)
01:18:03 * earthy nods
01:18:08 <earthy> that should do the trick
01:18:42 <earthy> if it doesn't you've made the rest of the grammar dependent on the exact type of the input stream that is tokenized
01:25:42 <hu_xue> hello
01:27:02 <hu_xue> I'm working through the wikibook about Haskell and I've come to a part where it says 'write a program which asks the user for the base and height of a triangle'... only it never explained how to make a program file.  Is that the same as making a .hs file and only putting a function into it?
01:27:21 <earthy> it is
01:27:40 <hu_xue> I'm unsure how to call the program to run after I have written it also.
01:27:49 <earthy> runhaskell
01:28:27 <earthy> suppose you've made a file  helloworld.hs   consisting of just    main = putStrLn "Hello World!"
01:28:40 <hu_xue> yeah?
01:28:57 <earthy> then   runhaskell helloworld.hs   would run that program and display      Hello World!
01:29:07 <hu_xue> sorry to be such an airhead about it, but how tod do that?
01:29:18 <earthy> what OS are you on?
01:29:23 <hu_xue> yes, but to to run that script?
01:29:32 <hu_xue> window
01:29:45 <earthy> guessed as much. :) you familiar with cmd.exe at all?
01:29:56 <hu_xue> yes
01:29:59 <hu_xue> the command line - right?
01:30:02 <earthy> yup
01:30:19 <earthy> at the commandline, in the folder in which the .hs file is
01:30:22 <hu_xue> en, i know it
01:30:29 <earthy> type   runhaskell file.hs
01:30:38 <hu_xue> you suggest i run it from there without entering GHCi?
01:30:38 <hu_xue> oh... i see
01:30:47 <hu_xue> that simple eh?
01:30:51 <earthy> that simple. ;)
01:31:01 <hu_xue> earthy++
01:31:01 <hu_xue> 3q so much he he
01:31:12 <hu_xue> (i hope that works to give you 'chat karma')
01:31:31 <hu_xue> is that the correct way to give it?
01:31:33 <earthy> no clue
01:31:42 <earthy> I don't karmawhore :)
01:32:02 <hu_xue> but it would appear that you do reddit
01:32:14 <earthy> um. I read reddit
01:32:28 <earthy> and I've been on the net long enough to know about karma and -whoring
01:32:47 <hu_xue> i'm only familiar with the whoring part
01:33:08 <hu_xue> ok, need to go.  ZAJIAN
01:41:58 <markus3> earthly: I still don't get it... I think i have to lift my parsers to the string level, so that when I combine them, they track their state in between strings they parse
01:43:36 <earthy> okay, now I'm not following
01:43:44 <earthy> in   GenParser Char () a   the state type is ()
01:44:02 <earthy> so, there *is* no state tracked in between chars...
01:44:14 <earthy> other than that built up in the result value of typ a
01:45:49 <markus3> hmm, maye I said it wrong. When parsec parses, it does do it in a sequence of how you apply the parsers
01:46:12 <markus3> but when i have a list of strings, when the string ends, it like "drops the state" or something
01:47:45 <earthy> 'a sequence of how you apply the parsers'?
01:47:51 <markus3> I can see, that it is got to do something with the stream type of being char, and not string, but i just cant figure out, how to combine my parsers as string parses (as opposed to char parsers)
01:48:06 <earthy> okay
01:48:41 <markus3> yup, like: MyConstr <$> many1 letter <* spaces <*> many1 digit
01:48:57 <earthy> letter and digit are *Char* parsers
01:51:11 <markus3_> (something wrong w my connection..)
01:51:28 <markus3_> I menat to say, that i still need to parse the chars in the strings
01:52:16 <markus3_> so in there i need to apply the char parsers, but somewhere at the upper level they need to go in sequence
01:52:32 <earthy> so what you want is   MyConster <$> (token >>= (\a -> if (all isLetter a) then return a else fail) <*> (token >>= ... )
01:52:59 <earthy> ofcourse, token needs to be handed the right functions to generate the String and SourcePos from your input stream
01:53:16 <earthy> oh, wait, easier
01:53:41 <markus3_> go on! go on! :D
01:54:03 <earthy> token id ... (\a -> if (all isLetter a) then Just a else Nothing)
01:55:12 <earthy> given an appropriate function to fill in for ... (can't be arsed to look up a dummy that'd work) that'd parse tokens consisting of just letters
01:55:56 <markus3_> so if I have: < parse (sepBy K.token K.spaces) "" string >, then I'd need to modify the K.token part somehow? or the function K.token itself?
01:56:26 <jonkri> how can i go from a bytestring with random elements to a random list of characters with contents like a-z, 0-9?
01:56:32 <earthy> markus3_: yup
01:59:40 <earthy> markus3: basically, look at the source of Text.ParserCombinaters.Parsec.Char and realize that you're going to have to replicate that
02:00:26 <markus3_> earthy: thank you very much! ;-) I'll go and try to figure out a solution
02:00:45 <earthy> tip: try it out on a mini grammar
02:01:24 <earthy> e.g. one that recognizes all strings 'a a a a a a a' and 'b b b' but not 'a b a b'
02:21:15 <mmaruseacph2> @pl f x = trace (show x) error "Not implemented"
02:21:15 <lambdabot> f = flip (flip trace error . show) "Not implemented"
02:21:35 <mmaruseacph2> @pl f x = trace (show x) ""
02:21:35 <lambdabot> f = flip trace [] . show
02:21:51 <mmaruseacph2> @pl f x = trace (show x) "asdf"
02:21:51 <lambdabot> f = flip trace "asdf" . show
02:41:45 * vegai just learned that ICFP 2011 will be in Tokyo
02:41:53 * vegai drools
02:42:13 <ivanm> vegai: you been under a rock or something? :p
02:42:21 <vegai> well.... yes.
02:42:30 * szbalint thought he'd join as he's sitting in a haskell class
02:42:38 <vegai> my love for Haskell fluctuates 
02:42:55 <vegai> and with that, my participation 
02:42:57 <ivanm> :o
02:45:34 <Adamant> my love for Haskell is like a truck, berserker
02:45:47 <Jonno_FTW> what?
02:45:49 <szbalint> it is not a series of tubes?
02:46:02 <Adamant> Jonno_FTW: paraphrase from "Clerks"
02:46:07 <Jonno_FTW> right
02:46:29 <Jonno_FTW> I wish they taught FP at my university ;__;
02:47:35 <blbrown_win3> they teach math?
02:47:45 <Jonno_FTW> yes
02:47:57 <Jonno_FTW> but not functional programming
02:48:11 <blbrown_win3> I tried to draw a connection there 
02:48:13 <Jonno_FTW> the maths topics use maple/matlab/mathematica
02:48:34 <Cozminsky> miranda was the first language I learnt at university
02:49:29 <blbrown_win3> I was cursed by basic when I was young.  20 years later and I only think in imperative style of coding
02:49:53 <Jonno_FTW> they made us learn Java in the intro to programming course
02:50:53 <phrackSipsin> is there a function to convert integer to float?
02:51:04 <harlekin> phrackSipsin, fromIntegral
02:51:07 <digitteqnohippie> i had that too.. when looking for an intro to programming video lectures.
02:51:12 <digitteqnohippie> bloody java
02:51:17 <phrackSipsin> thanks
02:51:53 <blbrown_win3> BASIC is worse
02:52:32 <digitteqnohippie> hehe.  i liked BASIC, back in the day.    ... never did anything more with it than make the screen flash n have it print text on screen tho. ^_^
02:52:38 <harlekin> @seen baldo
02:52:39 <lambdabot> Unknown command, try @list
02:52:39 <preflex>  baldo was last seen on #haskell-in-depth 218 days, 17 hours, 43 minutes and 45 seconds ago, saying: thx
02:52:50 <harlekin> @seen sargon
02:52:51 <lambdabot> Unknown command, try @list
02:52:51 <preflex>  Sorry, I haven't seen sargon
03:06:56 <Cozminsky> is there any equivalent to dh-make-perl for cabal packages?
03:08:16 * hackagebot ghc-pkg-autofix 0.1.3 - Simple utility to fix BROKEN package dependencies.  http://hackage.haskell.org/package/ghc-pkg-autofix-0.1.3 (HiromiIshii)
03:10:45 <ivanm> Cozminsky: what does that do?
03:12:26 <Cozminsky> ivan: turns a CPAN module into a native debian package
03:14:11 <ivanm> there are some people working on an equivalent
03:14:23 <ivanm> preflex: seen blackdog 
03:14:23 <preflex>  blackdog was last seen on #haskell 3 days, 10 hours, 59 minutes and 16 seconds ago, saying: Igloo's pretty good about taking patches so long as you don't break it for anyone else;)
03:14:35 <ivanm> Cozminsky: ^^ blackdog is one of them
03:14:38 <aristid> blbrown_win3: bah, maybe knowing BASIC makes it harder to learn the functional p
03:14:53 <aristid> blbrown_win3: bah, maybe knowing BASIC makes it harder to learn functional paradigms, but it doesn't make it impossible
03:27:00 <arcatan> jaspervdj: i see hakyll3 depends on hinotify. that's not very portable - only Linux has inotify.
03:33:18 <Daerim> aristid, It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration. - Dijkstra
03:33:40 <mux> this quote used to actually worry me
03:33:54 * mux started with locomotive basic 1.0 on amstrad cpc 464
03:34:03 * sipa started with gwbasic
03:34:10 * arcatan started with qbasic
03:34:19 <mux> you younguns!
03:34:48 <jaspervdj> arcatan: Yes, I know, but I'm going to make it optional
03:34:57 * opqdonut started with perl
03:34:58 <jaspervdj> arcatan: i.e. cabal install -finotify hakyll
03:35:01 * Daerim started with Delphi... of all things
03:35:04 <aristid> Daerim: i _did_ learn BASIC (QuickBasic and VisualBasic, to be precise), and while i struggled while trying to learn haskell, i think i have made some progress. of course i could never claim to actually be good at haskell
03:35:10 <aleator> Daerim: You too?
03:35:30 <arcatan> jaspervdj: yeah, i was going to suggest just that
03:36:13 <jaspervdj> okay, sweet :-)
03:36:20 * mux still remembers the joy of discovering the "renum" command
03:36:26 <arcatan> would be handy if there was a portable file system monitoring library
03:37:03 <merijn> arcatan: Filesystems are inherently non-portable
03:37:24 <jaspervdj> merijn: you could add a transparent library on top
03:37:26 <Daerim> aristid, well, arogance in CS is measured in nano-Dijkstra, so I'm not sure how serious I would take that quote 
03:37:28 <merijn> Most formats are wildly incompatible in features they support
03:37:52 <Daerim> aleator, yes. Not that bad a language I think. Not that I'd use it today, but still
03:38:08 <merijn> Also, Dijkstra lived in a different age of computing. Now I think its mostly Java and UML which are to blame for people being incapable of learning programming
03:38:20 <mux> ugh, delphi. I liked turbo pascal 7 better :-)
03:39:13 <aleator> Daerim: Well, you make guis with it ok, but the rest wasn't so jolly
03:39:33 <Daerim> aleator, I honestly haven't touched it for 8 years, so I
03:39:42 <Cozminsky> languages don't kill programming, programmers do
03:39:46 <Daerim> 'm not quite sure how bad it really was
03:39:50 <aristid> merijn: i'm looking forward to the age when people will blame haskell for people's incapability of learning programming ;) [and that said, off to lunch]
03:40:17 <mux> at least haskell is one of the few languages that don't bind you to the von-neumann paradigm
03:41:06 <merijn> I can't wait for more practical languages in the style of Epigram :>
03:41:52 <arcatan> zeta-omg, snap supports file uploads nowadays.
03:42:14 <gienah> merijn: there's Ur
03:42:39 <merijn> gienah: That's the dependently typed language with web dev support, right?
03:43:20 <merijn> That's not the same, though
03:44:21 <gienah> merijn: yes: http://www.impredicative.com/ur/
03:44:22 <merijn> The thing is I really like Conor's ideas on how programming should be (and Epigram is his attempt to make it work), dependent types themselves are not interesting without better ways of programming
03:44:49 <merijn> Look at Coq and Agda, they're awful languages for getting actual work done (unless your actual work happens to be type theory)
03:45:17 <hu_xue> how to determine if an irc server is logging the chats or not?
03:45:28 <sipa> it won't tell you
03:45:39 <merijn> hu_xue: You can't know
03:45:49 <merijn> Any person in the room could be logging the chats too
03:45:53 <hu_xue> en
03:46:13 * sipa logs
03:46:14 <gienah> merijn: yes coq seem great for type theory stuff, can generate coq from ott, generate haskell from the coq
03:46:22 <hu_xue> on what authority do you know this to be the case?
03:46:45 <hu_xue> i mean... where can i find that information online?   I have tried googling it... but i dont find anything.
03:46:55 <hu_xue> :$
03:46:56 <sipa> what do you expect to find?
03:47:06 <merijn> hu_xue: IRC protocol information and how servers actually work. However, all this is not on-topic for #haskell
03:47:11 <sipa> you could look at the configuration manuals of irc server software
03:47:15 <hu_xue> some kind of specification about irc i guess
03:47:23 <sipa> and it may or may not have something about logging
03:47:26 <sipa> but indeed, off-topic
03:47:33 <bradleyayers> BONUS: where should i tell you about problems with lyah?
03:47:50 <hu_xue> ok, thankyou, you have helped me.
03:49:10 <merijn> gienah: I know, but I want dependent types for practical programming :p I did/am doing a literature study on dependent types, but instead of covering type theory my end presentation will end up just being a talk on programming ideology and how we're all doing it wrong now :p
03:49:43 <ksf> is anyone at all working on a solution to http://stackoverflow.com/questions/5057136/real-world-applications-of-zygohistomorphic-prepromorphisms ?
03:49:55 <gienah> merijn: that's great, would like to read it when you are finished :-)
03:50:12 <vegai> would it be feasible if pure code could not throw exceptions?
03:50:38 <vegai> could functions like div and head return Maybes?
03:50:46 <vegai> ...without driving programmers crazy
03:50:48 <merijn> gienah: Tentative title "Type theory as programming tool -or- Conor McBride for Dummies -or- Programming is a search problem" :p
03:51:24 <vegai> somehow, in midst of all this safety, pure functions being able to throw exceptions seems odd
03:51:33 <gienah> merijn: thanks
03:51:57 <merijn> gienah: I'm currently trying to get some clear examples going, which is mostly the hardest part (as my end paper was supposed to only be 10 pages and I got material for 100), was planning on dumping it here when it was done anyway
03:52:23 <gienah> merijn: thats great
03:57:38 <Saizan> vegai: total programming languages would solve that :)
03:58:28 <gienah> vegai: for head on empty list there is: http://hackage.haskell.org/package/safe-failure
04:02:05 <Daerim> vegai, hmm... not sure how you'd do array in such a way that it could be used purely, and not being able to throw exceptions
04:04:30 <merijn> @hoogle [a] -> Maybe a
04:04:31 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
04:04:31 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:04:31 <lambdabot> Prelude head :: [a] -> a
04:05:32 <merijn> vegai: You want stuff like listToMaybe and then you can avoid exceptions, not sure if there is an equivalent for div
04:05:36 <merijn> :t div
04:05:36 <lambdabot> forall a. (Integral a) => a -> a -> a
04:07:23 <merijn> I must say I think that "div 1 0" should probably return NaN or whatever is appropriate according to IEEE754 instead of throwing an exception
04:07:35 <merijn> Although then you're stuck with just floats I guess
04:08:13 <quuuux> merijn: doubly worrying when you want integer division :)
04:08:48 <merijn> > (1 :: Int) / (0 :: Int)
04:08:49 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
04:08:49 <lambdabot>    arising from a use o...
04:09:33 <merijn> Dependent types to the rescue? :>
04:14:14 <quuuux> I wonder if writing code that uses `div' in a pattern-matching style (like is done to avoid using head/tail on lists) would be more or less painful than just using the Maybe monad
04:14:55 <quuuux> oh, wait. Can't pattern match directly, so scratch that
04:19:27 <bradleyayers> merijn: so is haskell getting dependent types?
04:20:51 <aristid> bradleyayers: no
04:21:01 <aristid> but there seems to be a patch for type-level naturals :)
04:21:22 <aristid> http://hackage.haskell.org/trac/ghc/ticket/4385
04:22:01 <aristid> :t div
04:22:02 <lambdabot> forall a. (Integral a) => a -> a -> a
04:22:21 <aristid> merijn: div only works on Integral types, and i know of no integral types that even support NaN
04:22:27 <mux> dependent types are overrated, you can do so much with singleton types already, as show in Omega
04:22:40 <aristid> merijn: so demanding IEEE754 behavior from div is a bit weird :P
04:25:11 <merijn> mux: Yes, but I *get* dependent types and I haven't bothered to read the paper on Omega yet so I can't make any qualified claims on that
04:25:38 <merijn> It's easier to be enthusiastic about things you grok :p
04:26:00 <quuuux> I beg to differ, I'm very enthusiastic about things I don't understand at all
04:26:34 <aristid> quuuux: it makes life an adventure?
04:26:42 <merijn> I didn't say you couldn't be enthusiastic about things you don't understand (I'm excited about FRP for one thing)
04:26:50 <mux> merijn: dependent types basically make my head hurts; singleton types in Omega are eazsy to understand, they're no more different than what you can already do in haskell with a few extensions to get type-level numerals
04:26:57 <merijn> I just said it was *easier* to be enthusiastic about things you understand
04:28:15 <merijn> I don't think dependent types are that bad, just so far the languages implementing it aren't that great
04:29:28 <aleator> Is it just me, or is it getting rather difficult to get consistent sets of packages by cabal nowadays?
04:31:18 <gienah> aleator: I do not know, as I get consistent sets of packages by creating gentoo pkgs, hacking the cabal files to  bump the dependencies, then patching the breakages :-)
04:32:50 <aristid> mux: it looks like GHC might get type-level numerals :)
04:33:15 <aleator> gienah: I am getting multiple copies of same packages, breakage of Cabal and other nicities today
04:34:23 <mux> aristid: yep, seen that, it's pretty cool
04:34:28 <aleator> process-1.0.1.4-8a2130a640d0360b11f08ed7267cf2ea is shadowed by package process-1.0.1.4-2a42745dbb9dd3c8087608f127411124
04:34:31 <aleator> Huh?
04:34:43 <bradleyayers> what are the implications of type-level naturals vs integer?
04:35:31 <merijn> bradleyayers: People won't have to keep implementing Peano numbers in the type system over and over to encode lengths/what-not
04:36:19 <Saizan> one could implement them once
04:36:51 <gienah> aleator: process is a ghc core library, whenever I have got that error the only way that I know of to recover has been removing every haskell package, ghc, and starting from scratch, maybe someone might know a less extreme recovery method
04:37:05 <Saizan> the problem is that a) you don't get decimal syntax b) the general constraint solver in ghc can't figure out basic arithmetic facts
04:37:25 <aristid> gienah: yeah there's a less extreme method, but it's much easier to remove all haskell packages. you don't have to remove ghc, tho
04:37:45 <aleator> gienah: Oh Joy!
04:37:45 <Saizan> ..you just have to unregister the process in the user db..
04:38:00 <aleator> Saizan: That seems to break everything
04:38:10 <gienah> artisid, Saizan: thanks
04:38:30 <Saizan> removing the one in the user db will only break some other packages in the user db at worse
04:39:10 <Saizan> though after that you've to pay attention to what cabal will want to do, there's a chance the reason it installed a second process is still present
04:39:19 <Saizan> so, run it with --dry-run -v first
04:39:23 <aleator> Saizan: Any idea how it got to the user db?
04:40:40 <Saizan> aleator: you might have upgraded for some reason a dependency of process, that can cause cabal to want to rebuild process against that newer version of the dependency
04:41:18 <Saizan> ah, use --user when you unregister
04:44:34 <aleator> Hmm. I think it would be easier, if there was some config file where you would put everything you want from cabal and let it work it out.
04:44:46 <aleator> Instead of package at a time.
04:45:49 <quuuux> the real problem's with ghc, imo. There are some silly holdovers in the code where only the package name and version are considered, not the binary hash
04:46:30 <quuuux> cabal's not hard to patch to make it sane (I have such a patch lying around myself), but that's no good if ghc-pkg gets in the way
04:46:58 <gienah> aleator: on gentoo, I bump a low level pkg like text, then run haskell-updater, it rebuilds over 250 pkgs that I have installed, in multiple phases, until almost everything is consistent
04:47:14 <Saizan> aleator: you can ask for multiple packages at once on the command line
04:47:20 <gienah> then run haskell-updater again, maybe a few times, and then *everything* is consistent
04:47:55 <aleator> Well, I'm running os x+brew so not so much luck on tools
04:48:06 <gienah> (as in, sometimes haskell-updater has a few pkgs that failed, running it again fixes some or all of the remaining ones)
04:48:07 <aleator> Though at this rate I will start making tools
04:48:30 <Saizan> quuuux: where is that in ghc-pkg ? or do you meant the fact that ghc and ghci will shadow eagerly?
04:49:22 <gienah> aleator: is os x+brew macos?
04:49:27 <Saizan> s/meant/mean/ -- sleep deprivation shows so easily in my english
04:49:48 <quuuux> Saizan: ghc definitely can't dynamically load two packages that only differ in binary hash. It's also nagging at me that ghc-pkg shares the same limitation, but I don't remember if that's true or not
04:50:35 <aleator> gienah: Yeah
04:51:29 <Saizan> quuuux: yeah, the symbols would clash
04:52:19 <gienah> aleator: I wonder if we might be able to get gentoo prefix to run haskell stuff on macos, if you wanted to help you could ask us in #gentoo-haskell
04:52:40 <quuuux> Saizan: right. I've no idea how hard it would be to fix ghc-pkg to use the triple (name, version, hash), but (at least, as I understand it) that's the only unsolved problem
04:52:53 <Saizan> quuuux: ghc-pkg is quite fine imo
04:53:04 <Saizan> quuuux: the problem is in the generated code
04:53:25 <Saizan> if the object files contain symbols with the same names it's a mess for the linker
04:53:31 <aleator> Ok, now I need to update cabal-install but that wants the duplicate process.
04:53:46 <akamaus> does anybody know whether "HPorter: Using Arrows to Compose Parallel Processes" paper is available for free?
04:53:55 <Saizan> aleator: --dry-run -v should also tell you why it wants it
04:56:21 <aleator> Ah. It wants newer directory.
04:57:21 <aleator> Wait no, older one and that pulls everything with it.
04:57:34 <Saizan> can you paste the output?
04:57:37 <gienah> aleator: that is dangerous, as directory is a ghc core library as well
05:00:01 <Saizan> maybe the best idea would be for .cabal to bump the version number of the package if it's reinstalling an existing version :)
05:01:01 <quuuux> Saizan: I'd rather cabal printed a honking great warning and needed --force passed
05:01:58 <Saizan> yeah, maybe both
05:02:13 <aleator> Geez. This is nasty
05:07:43 <aleator> Back to installing via setup.hs's..
05:09:23 <aleator> base-4.2.0.2 was excluded because of the top level dependency base -any ?
05:11:16 <Saizan> you can't install base separately from ghc
05:11:33 <Saizan> the error message is buggy though
05:12:06 <gienah> aleator: I am guessing, I would try hacking the .cabal file with s/base -any/base >= 4 \&\& <5/
05:12:37 <aleator> gienah: But it is already <5
05:13:35 <Saizan> aleator: what are you trying to install, currently?
05:13:45 <gienah> aleator: I was wondering if it wants a range specified rather than -any in the .cabal file of whatever you are trying to install
05:14:09 <Saizan> no, the "top level dependency base -any" is a red herring
05:14:16 <aleator> Saizan: derive
05:14:35 <Saizan> aleator: and which version of base do you have installed?
05:15:39 <aleator> Saizan: 4.3
05:15:56 <aleator> But I think I managed to get it going..
05:17:01 <Saizan> ok, so you just got worried by the nonsensical error message :)
05:17:27 <aleator> Nope, it stopped, then I installed something else and it went away. I think.
05:17:44 <gienah> derive 2.4.2 just works with ghc 6.12.3 and 7.0.1 on gentoo, no patching necessary, so it should work on other os as well
05:19:10 <lutza> how to define function ?
05:19:43 <Zao> f x y = x + y * 9001
05:19:54 <Zao> (at top-level scope, that is)
05:20:09 <Zao> let if inside a function, or where to have local definitions
05:20:19 <Zao> Have you've considered reading one of the fine books?
05:20:23 <Zao> @where rwh
05:20:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:20:26 <Zao> @where lyah
05:20:26 <lambdabot> http://www.learnyouahaskell.com/
05:21:42 <lutza> thanks
05:36:36 <hape01> real world haskell is to complex for beginners.  As I am a such i prefer the haskell wikibook tutorial e.g.
05:36:58 <merijn> hape01: I feel Learn You a Haskell is superior to the wikibook
05:37:17 <hape01> merijn: IÂ´ll have a look :-)
05:37:24 <merijn> (I'd agree a complete newcomer will probably be overwhelmed with RWH, though)
05:37:28 <merijn> @where lyah
05:37:28 <lambdabot> http://www.learnyouahaskell.com/
05:38:14 <hape01> @where am I
05:38:14 <lambdabot> I know nothing about am.
05:44:17 <ocharles> I like RWH, but I feel they went too far with the practical side
05:44:24 <ocharles> trying to implement RFCs word for word and such
05:46:12 * hackagebot grammar-combinators 0.2.4 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2.4 (DominiqueDevriese)
05:47:21 <MaskRay> Hi all. I have just installed NumberSieves by `cabal install NumberSieves', but failed to compile a haskell source contained only one line `import NumberTheory.Sieve.Phi'. ghc said it could not find the module.
05:48:17 <jaspervdj> MaskRay: it's Math.Sieve.Phi iirc
05:48:18 <Lemmih> MaskRay: Try Math.Sieve.Phi
05:49:18 <MaskRay> Lemmih: jaspervdj: Thanks. Has this package changed its name?
05:50:00 <jaspervdj> MaskRay: No, but package names do not necessarily match module names
05:51:57 <ManateeLazyCat> I'm research P2P protocol recently, any good resource or link are welcome! :)
05:52:58 <jaspervdj> There's a well-documented bittorrent implementation iirc
05:53:47 <jaspervdj> https://github.com/jlouis/combinatorrent
05:54:03 <ManateeLazyCat> jaspervdj: Thank you very much, i will look it. :)
05:55:13 <ManateeLazyCat> jaspervdj: Any more haskell project? ;)
05:57:13 <TheKingsRaven> Hello, I've got a quick question. Is it impossible to have a function that prints a String than returns it unchanged, without wrapping it in the IO monad. I think it's impossible but I want to know for sure.
05:57:34 <jaspervdj> ManateeLazyCat: Hmm, not that I can think of directly. I think there also was a DHT, but I don' remember the name
05:57:45 <drhodes> TheKingsRaven: Debug.Trace
05:57:46 <Botje> TheKingsRaven: look at the Debug.Trace module
05:58:08 <merijn> TheKingsRaven: Depends, what are you trying to do?
05:58:12 <ManateeLazyCat> jaspervdj: Ok, thanks again, above link much help. :)
05:58:36 <int-e> TheKingsRaven: but please use this only for debugging. when exactly the string is printed (or whether it it printed at all) is unpredictable.
05:58:52 <int-e> @type Control.Monad.join Debug.Trace.trace
05:58:53 <lambdabot> String -> String
05:59:05 <TheKingsRaven> Thanks drhodes, Botje. Merijn, I'm running a lot of string transformations in sequence. I wanted to know if its possible to output it at the middle (not debugging, actual output) 
05:59:26 <merijn> TheKingsRaven: It's possible, but don't do that
05:59:32 <Botje> you want to wrap it in a Writer at least, then
05:59:34 <dschoepe> TheKingsRaven: in that case you should use the Writer monad
05:59:45 <dschoepe> damn, too slow
05:59:45 <ManateeLazyCat> jaspervdj: I try to research P2P protocol to write a new software to wrap apt, then many people can download upgrade package and don't need center server. :)
05:59:49 <TheKingsRaven> K, I'll look at the Writer Monad. Thank you
05:59:56 <merijn> TheKingsRaven: What problem do you have which makes it necessary to do this outside the IO monad?
06:00:15 <ManateeLazyCat> jaspervdj: I know have apt-p2p, but i want write new one to understand P2P technology. :)
06:00:43 <jaspervdj> alright, interesting project
06:02:13 <TheKingsRaven> Mostly that I'm already using a different monad (this is an experiment in learning to write monads). I was having trouble transforming to the IO monad and since I only needed a simple function to write a line I thought there might be an easier way than transfrming from one monad to another.
06:02:19 <xarch> jaspervdj: do you plan to do something like a common interface for BlazeHtml?
06:02:28 <xarch> for the HtmlM monad
06:02:28 <ManateeLazyCat> jaspervdj: Do you know any good book about P2P?
06:02:47 <jaspervdj> ManateeLazyCat: No, I don't know much about it myself
06:02:54 <xarch> that would be useful, for example if I want to pass a state containing a function for localization
06:03:00 <xarch> and put it in a Reader
06:03:07 <jaspervdj> xarch: I'm not sure what you mean by a common interface?
06:03:11 <xarch> like
06:03:12 <ManateeLazyCat> jaspervdj: ok. :)
06:03:16 <xarch> a MonadHtml
06:03:22 <xarch> typeclass
06:03:39 <Botje> ManateeLazyCat: you might want to look up distributed hash tables and tuple spaces
06:04:54 <jaspervdj> xarch: Hmm, that would be pretty tricky. I'd recommend using a WriterT Html instead, if possible.
06:05:20 <xplat> v< earthy> token id ... (\a -> if (all isLetter a) then Just a else  Nothing)
06:05:28 <xarch> hm
06:05:48 <xarch> but I need a ReaderT, not a WriterT
06:06:06 <ManateeLazyCat> Botje: I want read some protocol detail, then use Haskell implement protocol, yes, i heard DHT many times, looks it's best way to look for peer in P2P network, and you know, i'm still P2P newbie. :)
06:06:09 <javache> jaspervdj: SHOULDNT YOU BE PAYING ATTENTION IN CLASS?
06:06:14 <xplat> this would be word (guard $ all isLetter) i think
06:06:22 <xarch> ah
06:06:27 <xplat> where word is token id <somethingorother>
06:06:28 <xarch> hm
06:06:48 <xarch> that would require using a liftHyml kind of function, no?
06:06:51 <Botje> javache: paying attention is optional :P
06:06:53 <xarch> liftHtml*
06:06:54 <jaspervdj> xarch: Right, I meant something like ReaderT Locale (WriterT Html x)
06:07:57 <xarch> what's the Writer for ?
06:08:01 <jaspervdj> javache: can't do, gotta help people on #haskell
06:08:25 <jaspervdj> xarch: collecting the HTML
06:08:30 <xarch> ah.
06:08:55 <xarch> the HtmlM monad isn't enough?
06:09:24 <jaspervdj> xarch: You could then make your decisions in the monad stack and use 'tell someHtml' to collect some HTML
06:09:42 <HugoDaniel> http://www.joelonsoftware.com/items/2006/08/01.html  reminds me of how great haskell is
06:09:43 <xarch> hm, well ok
06:09:44 <nudded> How is in a mathematical sense an Applicative Typeclass different from a Monad?
06:09:52 <xarch> yes actually that should be good
06:10:00 <ManateeLazyCat> Have any irc channel for P2P technology discuss?
06:10:05 <javache> nudded: yes
06:10:22 <xarch> I feared I would have to write a lot of boilerplate to get the Html values down the stack
06:10:35 <jaspervdj> xarch: The HtmlM monad is purely there for syntactic reasons
06:10:49 <xarch> but actually that's good, I think.
06:10:53 <xarch> hm ok
06:11:05 <jaspervdj> Yeah, a Writer should be fairly simple
06:11:26 <jaspervdj> I've used that approach in an app as well
06:12:02 <shachaf> nudded: What does "in a mathematical sense" mean?
06:12:10 <xarch> thanks!
06:12:17 <jaspervdj> shachaf: I think nudded is a troll
06:12:25 <nudded> shachaf: not strictly related to programming
06:18:02 <tswett_> Hm.  I have a quadratic equation (specifically, f(x) = 3x^2 - 3x + 1).  Given y, I need to find the smallest positive x such that f(x) >= y.
06:18:27 <srobertson> Any way to import hidden modules, or otherwise override their hidden status? (aside from hacking and recompiling / editing package.conf)
06:18:51 <tswett_> Is using floating-point arithmetic the best solution here, or is there some nice and fancy way that sticks to the integers?
06:19:37 <opqdonut> tswett_: is x an integer?
06:19:59 <opqdonut> if so, then sure you can stick with integers
06:20:10 <opqdonut> nothing fancy involved
06:20:32 <tswett_> opqdonut: yes, it is.
06:21:01 <opqdonut> but I'm not going to do your homework for you, sorry :)
06:21:32 <tswett_> Good call.  :)
06:22:31 <mux> heh, ghc-pkg-autofix is kinda wild
06:24:08 <zygoloid> tswett_: do you have an approach in mind?
06:24:56 <ManateeLazyCat> mux: ghc-pkg-autofix easy to use? I'm laugh when i first seen it's name. :)
06:24:56 <tswett_> zygoloid: the approach is to start with x = 1 and increase it until f(x) >= y holds.
06:25:04 <tswett_> Which is fast enough, since y is always pretty small.
06:25:11 <zygoloid> tswett_: you can do much, much better than that. :)
06:25:34 <Tomsik> tswett_: f(x)-y >= 0, that's still a quadratic equation
06:26:03 <mux> ManateeLazyCat: I haven't tried using it yet but I like the name too :-)
06:26:08 <Tomsik> check for roots and anything outside that interval is okay
06:26:09 <tswett_> zygoloid: perhaps I can, but y is going to be in the thousands at the very most.  I guess there's no harm in pondering it, though.
06:26:28 <zygoloid> tswett_: do you know how to find the roots of a quadratic?
06:26:53 <tswett_> zygoloid: I know the quadratic formula, but I don't know a good way that doesn't use sqrt.
06:27:17 <zygoloid> tswett_: you usually don't need to perform the sqrt for this.
06:28:16 <tswett_> No?  Let's suppose y = 30; then I want to find the smallest x such that 3x^2 - 3x + 1 >= 30; or, stated Tomsik's way, such that 3x^2 - 2x - 29 >= 0.
06:28:36 <Cale> tswett_: On the positive integers, your polynomial is monotone increasing.
06:28:39 <tswett_> (The smallest integer x, that is.)
06:28:57 <Cale> tswett_: So some sort of doubling/bisective search would work.
06:28:58 <mm_freak> does Data.Vector.Storable have any advantage over the normal Data.Vector?
06:29:13 <zygoloid> you have four distinct cases to consider: f(x)-y is always positive, f(x)-y is only negative for nonpositive x, f(x)-y is only negative for nonnegative x, f(0)-y is negative
06:29:39 <zygoloid> i claim you can tell which case you're in without performing the sqrt, and you can answer your question without performing the sqrt in all cases but the last
06:30:04 <tswett_> zygoloid: f(0) is 1, and y is almost always greater than 1.
06:30:35 <Cale> f(1) is also 1
06:30:44 <Cale> and then it increases from there
06:31:02 <zygoloid> tswett_: what's wrong with using sqrt anyway?
06:31:20 <tswett_> Cale: I could use some search algorithm, but that would be significantly more complicated than the single line of code I'm currently using.
06:31:45 <tswett_> zygoloid: well, I could get rounding error, and end up taking the ceiling of 30.00000001, expecting to get 30 but actually getting 31.
06:31:58 <tswett_> Or something like that.
06:32:35 <zygoloid> tswett_: i'd be very upset if sqrt on a positive square less than a thousand didn't give an exact answer
06:32:57 <tswett_> zygoloid: you have a point, there.
06:33:08 <Cale> What if y is larger than the maximum representable floating point number?
06:33:16 <Cale> ;)
06:33:19 <tswett_> Cale: it never will be.  :P
06:34:04 <Cale> anyway, you should probably round down here
06:34:08 <tswett_> This problem is modeling a beehive with a certain number of cells.  If the beehive has more than about two billion cells, the scientist is not going to bother counting that high.  :P
06:34:18 <Cale> and then search forward a bit, if you're worried about rounding error
06:35:13 <tswett_> Seriously, this solution will probably work just fine: \y -> head (dropWhile (\x -> 3*x^2 - 2*x + 1 < y) [1..])
06:35:21 <tswett_> > (\y -> head (dropWhile (\x -> 3*x^2 - 2*x + 1 < y) [1..])) [1..]
06:35:22 <lambdabot>   No instances for (GHC.Num.Num [t], GHC.Enum.Enum [t])
06:35:22 <lambdabot>    arising from a use...
06:35:44 <tswett_> > map (\y -> head (dropWhile (\x -> 3*x^2 - 2*x + 1 < y) [1..])) [1..]
06:35:45 <lambdabot>   [1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
06:35:58 <tswett_> Turns out that's wrong, but that's okay.  :P
06:36:15 <tswett_> Oh, I've got an obvious typo.
06:36:18 <tswett_> > map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:36:19 <lambdabot>   [1,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
06:38:48 <tswett_> So far, this function I'm writing is about 20 lines long, and 2 of those are neither comments nor blank.  :P
06:46:38 <Twey> > group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:46:38 <lambdabot>   [[1],[2,2,2,2,2,2],[3,3,3,3,3,3,3,3,3,3,3,3],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
06:46:46 <Twey> > group . group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:46:47 <lambdabot>   [[[1]],[[2,2,2,2,2,2]],[[3,3,3,3,3,3,3,3,3,3,3,3]],[[4,4,4,4,4,4,4,4,4,4,4,...
06:47:01 <Twey> D'oh
06:47:04 <Twey> > length . group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:47:08 <lambdabot>   mueval-core: Time limit exceeded
06:47:13 <Twey> > map length . group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:47:17 <lambdabot>   mueval-core: Time limit exceeded
06:47:23 <Twey> :-\
06:47:38 <aristid> > take 2 . map length . group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:47:40 <lambdabot>   [1,6]
06:47:44 <aristid> > take 5 . map length . group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:47:46 <lambdabot>   [1,6,12,18,24]
06:47:55 <aristid> > take 20 . map length . group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:47:57 <lambdabot>   [1,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114]
06:48:15 <aristid> Twey: that sequence grows pretty slow, no idea why lambdabot decided to die
06:48:43 <Twey> Not *that* slowly
06:49:07 <aristid> > take 50 . map length . group $ map (\y -> head (dropWhile (\x -> 3*x^2 - 3*x + 1 < y) [1..])) [1..]
06:49:09 <lambdabot>   [1,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,1...
06:49:19 <aristid> *shrug*
07:05:56 <adamvh> I apologize in advance if this is off-topic for this channel, but I'm thinking of starting a blog on scientific computing in Haskell.  The trouble is, scientific computing is all I know - I have no idea where to even start setting up a web site.  So, I need mathjax and Haskell syntax highlighting, flexibility with the design, and my own domain.  Should I just use Wordpress or something like that?  Or is it worth doing it in 
07:05:56 <adamvh> Yesod/Happstack or something?  What kind of hosting should I get?  Any pointers in the right direction would be much appreciated.
07:06:22 <fram> Is there an extension enabling us to do things like : updateField::a->(a->b)->b->a  , updateField data accessor value = data{accessor=value}  ?
07:06:43 <opqdonut> fram: not an extension but a library, called FRef
07:06:50 <opqdonut> there are other options too I guess
07:06:53 <Itkovian> adamvh: there are many possibilities, the questions you should ask yoursefl - imo - is what you aim for? interaction, simple bog + comments, ...
07:06:58 <fram> thx!
07:07:00 <Itkovian> Some form of community?
07:07:43 <opqdonut> fram: Data.Accessor might be the good one
07:09:06 <adamvh> Itkovian: (Malazan reference btw?) - Basically I plan on writing a series of articles, with accompanying code (hosted on github) about computational neutron transport, with the code in Haskell - I'd also like a CV/about me section, and maybe some way to coalesce the series of posts into one document when they're all out
07:09:10 <pesco> adamvh: you should be able to find out if wp has haskell syntax hilighting. don't know about math notation...
07:09:40 <Itkovian> adamvh: also take a look at snap/hakyll/...
07:09:45 <adamvh> So basically a personal website, but with a lot of math / figures / code
07:10:08 <Itkovian> adamvh: yeah. #malazan
07:10:11 <pesco> adamvh: you could roll your own, but make sure building a blog engine is actually what you want to do
07:10:44 <adamvh> pesco:  I think it might be kind of fun - it should probably be in my toolkit
07:11:07 <adamvh> pesco: which of the major Haskell web frameworks would you recommend for something like that?
07:11:07 <pesco> well, it's a popular exercise. just saying, don't be surprised if it turns out to take longer than a week s)
07:11:14 <Itkovian> adamvh: I would recommend you to focus on content then. The underlying system is not what you should be concerned about. Just make sure you can migrate to something else, should you ever desire to, i.e., pick something that's open.
07:11:16 <pesco> s/s)/;)/
07:11:32 <Itkovian> adamvh: hakyll :-) ask jaspervdj 
07:14:21 <adamvh> Ah, Hakyll looks like the right sort of thing, actually
07:15:43 <Jesin> Itkovian: i.e. means "that is"
07:16:01 <Jesin> :p
07:16:05 <fram> is it me or does haskell tend to make you write more higher-order-general-purpose-functions than actual code? I'm starting to get lost in all the "helper" functions I have been writing for my project
07:16:24 <Jesin> (sorry for random grammarnazi strike)
07:16:34 <Itkovian> Jesin: no worries
07:16:46 <Itkovian> I tend to abuse it.
07:16:47 <fram> latin for id est
07:17:32 <Jesin> you probably wanted e.g.
07:17:33 <fram> not to be mistaken for Internet Explorer, that didn't exist at the time...
07:17:34 <Jesin> :p
07:21:01 <pesco> Itkovian: thanks for the pointer to hakyll. i run my own static generator but it needs replacing. maybe i'll switch... ;)
07:22:43 <pesco> fram: wasn't that a valid use of "i.e."? (to continue wild tangent) ;)
07:23:26 <Itkovian> Jesin, nah e.g. is not appropriate here either, I think I should have put "therefore"  
07:24:16 <Jesin> "Just make sure you can migrate to something else, should you ever desire to, i.e., pick something that's open."
07:24:22 <pesco> fram: sorry, misaddressed. should have been Jesin.
07:24:52 <tswett_> "Just make sure you can migrate to something else, should you ever desire to, that is, pick something that's open."
07:25:08 <Jesin> we addressed that part already tswett_
07:25:10 <Jesin> :p
07:25:19 <Jesin> I don't see how "therefore" fits there, though
07:25:35 <Jesin> that doesn't look like a premise-conclusion relationship
07:25:57 <tswett_> There's always "n.b."  :P
07:26:23 <copumpkin> et al.
07:26:36 <copumpkin> that one belongs
07:26:48 <tswett_> b.f., p.g., l.f.
07:26:55 <tswett_> Bona fide, persona grata, lingua franca.
07:27:04 <tswett_> m.o.: modus operandi.
07:27:08 <copumpkin> m.s.
07:27:54 <xplat> is there an easy way to make an attoparsec parser stateful?
07:28:27 <sipa> put a StateT around it?
07:29:14 <tswett_> copumpkin: mundus senescit?
07:29:28 <xplat> i guess that would mean i'd have to lift all the basic parsers?  and what about things like 'many'?
07:29:35 <copumpkin> musa sapientum
07:30:02 <hape01> > dropWhile(\x->x==4) [-6..6]
07:30:03 <lambdabot>   [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6]
07:30:13 <hape01> somehow I miss one point... ?hmmm
07:30:54 <copumpkin> > dropWhile(\x->x/=4) [-6..6]
07:30:56 <lambdabot>   [4,5,6]
07:31:03 <copumpkin> > tail . dropWhile(\x->x/=4) [-6..6]
07:31:04 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
07:31:04 <lambdabot>    arising from a use...
07:31:22 <hape01> Now I am confused...
07:31:48 <copumpkin> what are you trying to do?
07:31:51 <xplat> oh, i guess many is general enough to work automatically, provided i have an Alternative instance
07:32:12 <hape01> I want to have a list -6 to +6 where 4 is left out
07:32:26 <copumpkin> > filter (/= 4) [-6..6]
07:32:27 <lambdabot>   [-6,-5,-4,-3,-2,-1,0,1,2,3,5,6]
07:32:34 <Jesin> > tail $ dropWhile (/= 4) $ [-6..6]
07:32:34 <lambdabot>   [5,6]
07:32:43 <Jesin> but yes
07:32:47 <Jesin> filter
07:32:51 <sipa> > [-6..3] ++ [5..6]
07:32:53 <lambdabot>   [-6,-5,-4,-3,-2,-1,0,1,2,3,5,6]
07:32:56 <Jesin> or that
07:32:58 <Jesin> :p
07:33:12 <copumpkin> > [-6..6] \\ [4]
07:33:13 <hape01> thank you
07:33:13 <lambdabot>   [-6,-5,-4,-3,-2,-1,0,1,2,3,5,6]
07:33:31 <Jesin> sipa's solution is probably best
07:33:42 <sipa> i like copumpkin's one most :)
07:33:49 <Jesin> which one
07:33:56 <sipa> both
07:33:58 <Jesin> k
07:34:24 <jonkri> please tell me that when i look up "($$) :: (Monad m) => (Data.Enumerator.Step a m b -> Data.Enumerator.Iteratee a' m b') -> Data.Enumerator.Iteratee a m b -> Data.Enumerator.Iteratee a' m b'" the a in the first function argument does not have to be the type of the a in the second argument, Data.Enumerator.Iteratee a m b!
07:34:26 <jonkri> :P
07:34:36 * copumpkin proved that natural isomorphism is an equivalence relation o.O
07:34:56 <Jesin> ...??
07:35:02 <Jesin> "natural isomorphism"
07:35:04 <ezyang> I think laziness is a technology ahead of its time, unfortunately :-( 
07:35:17 <copumpkin> ezyang--
07:35:38 <asflierl> I think Haskell is a technology ahead of its time.
07:36:46 <jonkri> asflierl: word!
07:36:49 <ezyang> Perhaps better rephrased as "I fear". I would love for it to work. 
07:36:51 <copumpkin> Jesin: two natural transformations such that they go back and forth, if you know what I mean
07:36:58 <copumpkin> ezyang: what makes you say that?
07:37:34 <Jesin> hmm
07:37:36 <Jesin> k
07:37:42 <Jesin> I have to go now
07:37:44 <Jesin> bye
07:38:47 <ezyang> copumpkin: It's re the Strict types proposal on libraries right now. It's becoming more and more obvious to me that Haskell is a huge win, not just in modularity, but also in optimization ability. But it clashes hugely against existing practice for "optimizing" Haskell programs. 
07:39:11 <copumpkin> wait, did you forget something from that sentence?
07:39:52 <ezyang> *laziness in Haskell 
07:39:58 <copumpkin> I see
07:40:57 <ezyang> I fear that, with our current compiler technology, the situations in which we can do amazing things with fusion will be incomprehensible to most people. 
07:41:21 <ezyang> I recall SPJ admitting that "on a good day, all the rewrite rules are firing and all is well" 
07:43:02 <ezyang> But more concretely, right now I'm trying to understand RL's DPH rewriting example, and I keep thinking "a sufficiently smart compiler would be able to figure that out" 
07:43:33 <ezyang> but I don't have a good sense for what's easy and what's hard. 
07:49:06 <ezyang> I sort of feel like there should be a decoupling between denotational code and operational code, and laziness is a good substrate for denotation but we've not figured out the operational bit yet. 
07:55:53 <jmcarthur> ezyang: RL's DPH rewriting example?
07:56:13 <ezyang> jmcarthur: Yeah. 
07:56:29 <ezyang> I look at it, and I just see all sorts of opportunities for compiler cleverness; I have no bad idea filter. 
07:56:35 <jmcarthur> ezyang: i'm also intrigued by your last statement about decoupling denotational and operational code, and how we haven't figured out the operational bit. not sure i see what you mean yet
07:57:27 <ezyang> jmcarthur: So, historically, when we want to write clear code, we pay a performance cost, and if we want it fast, we have to destruct it into low-level code. But what if we wrote clear code, and then wrote appropriate optimizations (rewrites) to make it into the fast code? 
07:57:31 <ezyang> Then we'd get the best of both worlds! 
07:57:42 <jmcarthur> ezyang: oddly enough, literally the second before i read what you said, i was thinking about what it might be like to have an interactive session with the compiler's optimizer to have kind of a back-and-forth conversation about program transformations
07:57:56 <ezyang> Yes! 
07:58:13 <ezyang> That would be one way of doing it, and would certainly make it a lot easier to do rewrites. 
07:58:17 <jmcarthur> i had just come from reading a little about program transformation
07:58:50 <jmcarthur> anyway, my idea is that maybe there could be the programmer-visible code and some other files representing the transformations that the programmer was wanting the compiler to use
07:58:52 <Gracenotes> optimizations are pretty much a->a functions in mainly Core/also STG, right? ... with a *lot* of Reader envvars
07:59:01 <jmcarthur> where the latter stuff is generated via an interactive session
07:59:42 <jmcarthur> in a sense, the latter stuff is the actual code, and the former stuff could be high level enough to be considered just a specification
07:59:45 <ezyang> jmcarthur: Yeah. I'm not sure how well this would work when you want to go and change the code, but I guess you could have the compiler tell you what transforms stopped firing. 
07:59:48 <thoughtpolice> Gracenotes: basically yes, mostly something looking like '[CoreBind] -> CoreM [CoreBind]' is a pass
08:00:10 <Gracenotes> mm, top-level bindings
08:00:32 <jmcarthur> ezyang: no, even better than that... when you compile, any time something has changed you get a chance to interact with the compiler to tell it how you want the new parts to be treated
08:00:43 <thoughtpolice> Gracenotes: see ghc/compiler/simplCore/CoreMonad.hs
08:00:52 <jmcarthur> ezyang: and of course you could also force it
08:01:01 <Gracenotes> I've looked through it before, but that might have been many rewrites ago :P
08:01:05 <thoughtpolice> also ghc/compiler/simplCore/SimpleCore.hs
08:01:13 <ezyang> Hmmmmmm.. 
08:02:25 <jmcarthur> but anyway, i think the interactivity would be a cool way to not only have fine-grained control over optimizations, but also have a way for the compiler to *remind* you of potentially useful transformations. currently we have to do all the thinking about rewrite rules ourselves without even getting to see the various stages of optimizations
08:02:57 <jmcarthur> and of course we are also limited to basically just things like rewrite rules. this might open doors to other kinds of transformations, maybe safer or more general
08:03:37 * ezyang nods 
08:03:57 <ezyang> This is very interesting. I will be thinking about it. 
08:04:07 <jmcarthur> this of course would cater to the kinds of people that like or need to superoptimize, but it could probably be made to work with more typical workflows somehow
08:04:15 <kulakowski> Can lambdabot @tell multiple people the same message?
08:04:35 <ezyang> I've gotta run. Thanks for the thoughts. :-) 
08:04:40 <jmcarthur> np!
08:04:53 <jmcarthur> ezyang: i'd like to talk about it more if you're still interested later
08:05:00 <jmcarthur> ezyang: it's a fresh idea right now
08:07:40 <aristid> i wonder if xml-enumerator is the "right way" to parse XML
08:18:24 <sm> hmm. In the feed package, there seems no way to get item update date vs item publish date. getItemDate is a synonym for getItemPublishDate
08:18:48 <sm> and in the case of an atom feed, it looks like this actually gets the updated date: http://hackage.haskell.org/packages/archive/feed/0.3.8/doc/html/src/Text-Feed-Query.html#getItemDate
08:22:12 <heatsink> > null (read ("[" ++ cycle "1,") :: [Int])
08:22:15 <lambdabot>   mueval-core: Time limit exceeded
08:22:23 <heatsink> Shouldn't read be lazier?
08:23:41 <rwbarton> not really
08:23:55 <rwbarton> > read "[1,1,fdgdfxgf" :: [Int]
08:23:56 <lambdabot>   *Exception: Prelude.read: no parse
08:24:00 <Jafet> It cannot be
08:24:27 <Jafet> > reads ("[" ++ cycle "1,") :: [(Int, String)]
08:24:29 <lambdabot>   []
08:24:44 <Maxdamantus> head (read "[1,1,fdgdfxgf" :: [Int])
08:24:45 <Jafet> Erm
08:24:48 <Maxdamantus> > head (read "[1,1,fdgdfxgf" :: [Int])
08:24:49 <lambdabot>   *Exception: Prelude.read: no parse
08:24:52 <Jafet> > reads ("[" ++ cycle "1,") :: [([Int], String)]
08:24:56 <lambdabot>   mueval-core: Time limit exceeded
08:25:07 <Jafet> Oh well, it just doesn't have to be
08:25:34 <heatsink> okay
08:26:21 <Jafet> > readList ("[" ++ cycle "1,") :: [Int]
08:26:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:26:22 <lambdabot>         against inferred type ...
08:26:24 <rwbarton> reads still has the same problem, it needs to know whether a ] or a parse error comes first
08:26:50 <Jafet> > readList ("[" ++ cycle "1,") :: [([Int], String)]
08:26:54 <lambdabot>   mueval-core: Time limit exceeded
08:27:04 <heatsink> So I can count on (evaluate . read =<< readFile path) to close the file
08:27:15 <Jafet> Hah
08:27:24 <copumpkin> when people say composition of functors is associative, do they mean up to natural isomorphism between the functors?
08:27:51 <rwbarton> heatsink: ... yes, I think so
08:28:05 <rwbarton> Until it reads to EOF it doesn't know whether there's trailing garbage
08:28:11 <rwbarton> Unless there is a parse error
08:28:19 <rwbarton> then it might not read the whole file
08:29:18 <rwbarton> copumpkin: I guess it might depend on your setup but normally I would say that (FG)H and F(GH) are actually equal
08:29:36 <copumpkin> hmm okay, but what does it mean to be "actually equal" for functors?
08:29:51 <copumpkin> they map the same morphism to equal morphisms
08:29:51 <rwbarton> equal as functions Ob C -> Ob D and Mor C -> Mor D
08:29:52 <copumpkin> ?
08:29:53 <heatsink> That's enough in this case, since I'm using 'show' to create the file contents in the first place.
08:29:54 <heatsink> thanks
08:30:12 <copumpkin> rwbarton: what if I don't have equality on objects? :)
08:30:22 <rwbarton> I suspect your mind is being clouded by non-extensional equality :P
08:30:23 <rwbarton> oh
08:30:44 <copumpkin> no, I'm parametrizing over an equivalence relation on morphisms
08:30:51 <copumpkin> so I don't have any builtin equality to rest on :P
08:30:56 <copumpkin> forces me to think a lot more about what equality means
08:30:59 <rwbarton> well, then, I guess your functors only form a setoid to begin with, right?
08:31:47 <hape01> in which package Do Do I find Data.Time and how Do you search if you dont now?
08:31:47 <rwbarton> this is in agda right?
08:31:48 <copumpkin> well, I've made them into a setoid with natural isomorphism as my equivalence relation o.O
08:31:50 <copumpkin> rwbarton: yeah
08:32:21 <copumpkin> but natural isomorphism feels odd here
08:32:40 <copumpkin> especially when I went to prove that composition of functors is associative
08:32:57 <copumpkin> it was uncomfortably easy to show that there's a natural isomorphism between the "reassociated" compositions
08:34:21 <rwbarton> try to make a setoid out of "there is a natural isomorphism between" sounds dangerous to me
08:34:25 <rwbarton> *trying
08:34:34 <rwbarton> because there may be many natural isomorphisms which are different
08:34:40 <copumpkin> I already have such a setoid, but it feels useless :P
08:34:44 <copumpkin> yeah
08:34:45 <rwbarton> can I see your definition of category?
08:34:50 <copumpkin> sure
08:35:18 <rwbarton> I think you'll want a setoid relation == on functors for which F == G if forall x. F x == G x
08:35:20 <copumpkin> if I go for a more traditional equality of functors as equality of morphisms
08:35:29 <copumpkin> I need heterogeneous equality
08:35:30 <copumpkin> https://github.com/pumpkin/categories/blob/master/Category.agda
08:35:33 <rwbarton> hmm
08:35:47 <rwbarton> yeah that's going to be a problem with the rest of my statement
08:36:07 <copumpkin> yeah, I tried that first
08:36:22 <copumpkin> maybe I should rework my whole thing to allow equality to be heterogeneous
08:36:24 <copumpkin> but that makes me sad
08:36:44 <rwbarton> there's an annoying chain of problems here
08:36:57 <rwbarton> you have objects forming a Set not a Setoid?
08:37:25 <copumpkin> yeah I figured I could get away with that
08:37:57 <rwbarton> but now I think you run in to the problem of lacking extensional equality on functions
08:38:05 <copumpkin> why?
08:38:23 <copumpkin> only if I ever run into functions as objects of a category?
08:38:32 <copumpkin> which I haven't yet
08:38:34 <rwbarton> oh, ok
08:38:41 <copumpkin> since I do have a setoid of morphisms
08:39:38 <copumpkin> it's been sufficient to do a lot of things so far
08:39:50 <copumpkin> but the homogeneous equality is biting me for functor equality
08:40:12 <rwbarton> When I tried proving Yoneda's lemma in Agda, I ran into this problem
08:40:23 <rwbarton> because I wanted to write down functor categories
08:40:34 <rwbarton> but I couldn't prove that composition of natural transformations was associative
08:40:41 <copumpkin> ah
08:40:50 <copumpkin> I have both compositions but haven't yet proven them associative :/
08:41:01 <rwbarton> I guess you're ok there since natural transformations are the morphisms and you have a setoid there
08:41:18 <copumpkin> oh, you were working with builtin equality?
08:41:27 <rwbarton> yeah
08:41:30 <copumpkin> oh okay
08:41:46 <copumpkin> yeah I can do funky things like the arrow category and have it work fairly painlessly
08:41:54 <copumpkin> without having to prove proofs equal
08:41:56 <rwbarton> well, then I realized I needed to do some kind of setoid thing and then gave up :P
08:42:09 <copumpkin> yeah, that was the whole reason I started this effort
08:42:14 <copumpkin> apart from learning more about category theory :P
08:42:23 <copumpkin> lots of setoid-less category theory out there
08:42:33 <copumpkin> and the one I did find with setoids for morphisms used --set-in-set
08:42:52 <rwbarton> that's the Set : Set axiom?
08:42:55 <copumpkin> yeah
08:43:01 <copumpkin> makes me uncomfortable
08:43:21 <copumpkin> also, we have universe polymorphism so might as well use it
08:45:08 <xplat> copumpkin: a setoid based on 'naturally isomorphic' seems like the wrong thing to me as well, since it collapses the 2-category structure of Cat to a 1-category
08:45:13 <rwbarton> somehow where you have Functor C D : Set you really need it to be a setoid
08:45:36 <copumpkin> xplat: yeah, it's weird. I felt really odd proving that natural isomorphism formed an equivalence relation :P
08:45:36 <rwbarton> both because of the extensional equality on functions thing
08:45:47 <copumpkin> it is though!
08:45:50 <copumpkin> just in case you were wondering
08:46:02 <copumpkin> at least according to the definition of equivalence relation I'm using :P
08:46:04 <rwbarton> and because on morphisms you have a map between setoids and two such maps should be considered equal if they're merely equal in the setoid
08:46:29 <rwbarton> wait why did this need heterogeneous equality again?
08:47:14 <rajeshsr> hi all
08:47:46 <rajeshsr> i am trying to use foldM but its initial value is not defined. I want the function to operate from the first element in the list...
08:47:48 <rajeshsr> any help?
08:48:11 <copumpkin> well, for functors F : C -> D and G : C -> D to be equal, I want forall f : X -> Y. F f == G f, where F f : F X -> F Y and  G f : G X -> G Y
08:48:45 <rwbarton> right, but before that, you also want F X = G X and F Y = G Y
08:48:46 <xplat> maybe you need to use refl equality for F X and G X?
08:48:54 <rwbarton> not just ==, but refl equality, right
08:48:59 <copumpkin> oh yeah
08:49:00 <copumpkin> hmm
08:49:08 <rwbarton> I'm not totally sure how to express the "order" of those statements in agda, but it seems possible
08:49:19 <copumpkin> yeah, I'd have to "prove" the type of the equality axiom
08:49:28 <copumpkin> but I've done stuff like that before
08:49:34 <copumpkin> hmm
08:50:16 <copumpkin> hmm, so does that mean I also want a functor axiom that functors preserve definitional equality of objects?
08:50:23 <copumpkin> (I already have the setoid equality on morphisms)
08:51:16 <copumpkin> or do I just need that when I define functor equality
08:51:30 <xplat> it seems like that should be automatic, but it might not be automatic *enough* without an axiom, i dunno
08:51:40 <copumpkin> oh you're right
08:51:51 <copumpkin> I think that just follows from cong
08:52:24 <copumpkin> okay, let me draft up a functor equality
08:53:06 * copumpkin wonders whether it's worth keeping all this useless functor up to natural isomorphism stuff around to build a cute but useless category out of it
08:54:06 <copumpkin> ah well, I'll scrap it for now and it'll live on in my git history :P
08:54:07 <xplat> probably worth taking a copy in case it turns out to be useful in a 'skeleton of a 2-category' kind of way later ...
08:54:21 <xplat> but yeah, git history might be good enough
08:55:15 <copumpkin> tedious as fixing all this stuff is
08:55:18 <copumpkin> I really enjoy it :P
08:55:43 <copumpkin> I've always felt uncomfortable about how much CT seemed to gloss over equality, so spelling it out in a machine-checkable way makes me feel way better
08:55:58 <xplat> yeah, same here
09:01:45 <rajeshsr> hi all
09:02:23 <rajeshsr> so, just wrote an extremely dumb external sorting. Looks a lot like imperative code. Need your feedbacks for improving it to Haskell style!
09:02:26 <rajeshsr> link: https://gist.github.com/837378
09:03:31 <monochrom> haskell I/O is still imperative
09:05:11 <rajeshsr> monochrom: hmm, yeah! BTW, am curious about mergeResults. Will that memory exceed for huge file. I hope not, beacuse i expect it to be lazy and i don't need Haskell to have the initial head of the list
09:05:17 <rajeshsr> when processing the list...
09:07:58 <rajeshsr> anyone?
09:08:05 <xplat> i'd be more worried about running out of filehandles with that lazy IO.  you wouldn't see it maybe with that test program, but if you use it in a larger program ...
09:08:13 <monochrom> it won't consume much memory
09:08:44 <monochrom> it won't run out of file handles either. every readFile is completely consumed promptly.
09:11:05 <xplat> well, i don't see much problem then.  it might not even OOM on a 2GB line if there isn't another one just like it
09:11:38 <xplat> (that would be an interesting thing to add to a test suite :)
09:12:29 <xplat> if you do have two 2GB lines that are identical it will definitely fail, though
09:13:33 <xplat> you could make one that handles that case for exact string equality, but it probably wouldn't be worth the trouble, especially since it wouldn't generalize to comparator sorts like case-insensitive and numeric
09:16:17 <rajeshsr> intersting! Now that you mentioned about readFile, it can't close fileHandle, because it has to do lazy I/O. 
09:16:32 <rajeshsr> so, i may get too many fileHandles open indeed!
09:17:07 <rajeshsr> hmm, but a single merge is dealing with only 2 fileHandles...
09:17:11 <rajeshsr> make sense! :)
09:18:32 <xplat> yeah, readFile will close the handle when you have forced the entire file (which you do reliably here) or maybe when the tail is GC'd (which you can never count on, and i can't remember if it's implemented anyway)
09:19:35 <rajeshsr> xplat: hmm!
09:19:42 <rajeshsr> let us do some testing! :)
09:26:37 <brad_larsen> For my curiosity: is there a simple way to define a control structure like 'bracket' that *does not* require you to put your code in continuation-passing style?
09:27:02 <hpc> @src bracket
09:27:02 <lambdabot> bracket before after thing = block $ do
09:27:02 <lambdabot>     a <- before
09:27:02 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
09:27:02 <lambdabot>     after a
09:27:02 <lambdabot>     return r
09:27:09 <hpc> :t block
09:27:09 <lambdabot> Not in scope: `block'
09:27:11 <brad_larsen> @type bracket
09:27:12 <lambdabot> Not in scope: `bracket'
09:27:17 <hpc> :t bracket
09:27:17 <lambdabot> Not in scope: `bracket'
09:27:20 <hpc> :)
09:27:20 <brad_larsen> hmm
09:27:23 <hpc> (*
09:27:26 <brad_larsen> :t Control.Exception.bracket
09:27:27 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:27:40 <hpc> @src block
09:27:40 <lambdabot> Source not found.
09:27:42 <quicksilver> I would not describe that as CPS.
09:27:47 <hpc> :t Control.Exception.block
09:27:47 <lambdabot> forall a. IO a -> IO a
09:28:14 <brad_larsen> hmm, perhaps i used the wrong terminology
09:28:51 <rajeshsr> xplat: took 1m28s to sort a 22M file! :)
09:29:28 <brad_larsen> using bracket, you have to write things like 'bracket before after $ \v -> do ...'
09:31:07 <brad_larsen> I'd like to be able to wrap up the before-thing-after control flow in a monad, I suppose, so that I could write 'do v <- bracket before after; ...' and have the 'after' action run after all the '...' part
09:31:51 <xplat> so basically you want to sugar bracket to look like RAII?
09:31:59 <brad_larsen> exactly!
09:32:20 <brad_larsen> i don't know if it's a fool's errand
09:33:50 <quicksilver> brad_larsen: is that really very different from v <- bracket before after $ do .... ?
09:34:13 <quicksilver> brad_larsen: I think the general "withFoo $ do ..." pattern does resemble RAII.
09:34:17 <xplat> it doesn't really seem like you could make it look like that with a monad, maybe an arrow ...
09:34:44 <xplat> oh, maybe you could with a monad
09:34:49 <brad_larsen> quicksilver: you are right about the "withFoo $ do ..." resemling RAII
09:35:19 <rwbarton> I suspect you can
09:35:21 <xplat> you'd have to have >>= remember the pending 'afters'
09:35:26 <brad_larsen> quicksilver: although usually the action to run is a function, so it would be "withFoo $ \foo -> do ..."
09:35:39 <rwbarton> sort of like a combination of the forward state monad and the backward state monad
09:35:40 <quicksilver> with GHC's rather controversial NonDecreasingIndentation you don't even waste indentation stops
09:35:41 <brad_larsen> I just want nicer syntax
09:38:04 <xplat> you could probably just use WriterT on a monoid whose mappend is >> in the underlying monad
09:38:22 <Jafet> ...I thought that was standardized haskell
09:40:26 <jmcarthur> brad_larsen: the only issue i see with your proposal is that the '...' portion doesn't have a clear "end", so i don't expect that 'after' would be executed at all
09:40:36 <xplat> (or maybe flip (>>) or (<<) or flip (<<)) ... and then you run the accumulated action in runBrackets
09:40:59 <jmcarthur> brad_larsen: unless you had bracket also return a cleanup action, which defeats the purpose entirely
09:41:04 <xplat> jmcarthur: it would run at the end of the 'do'
09:41:13 <jmcarthur> brad_larsen: well, i suppose 'after' could be executed if there's an exception
09:41:23 <jmcarthur> xplat: where is the end of the 'do'?
09:41:28 <brad_larsen> jmcarthur: it's possible that the 'after' wouldn't be executed if '...' never terminates, for example
09:41:32 <xplat> owait, i see what you mean
09:41:36 <jmcarthur> xplat: what if you use the action in a larger action?
09:41:38 <jmcarthur> yeah
09:41:51 <xplat> it would run at the end of the runRAII $ do, rather
09:41:58 <rwbarton> the end of the ..., right.
09:42:00 <jmcarthur> brad_larsen: my point is that it only terminated after the entire program is done
09:42:04 <jmcarthur> brad_larsen: at least if we are talking about IO
09:42:17 <xplat> obviously we aren't talking about IO
09:42:42 <brad_larsen> jmcarthur: I was hoping for something more specialized, some RAII transformer or something
09:42:43 <jmcarthur> ah, if we have a runRAII monad then yeah, all the finalizers would run at once at the end of runRAII
09:42:44 <rwbarton> @hoogle atExit
09:42:45 <lambdabot> No results found
09:42:57 <jmcarthur> well it would be easy to implement, i think
09:43:04 <jmcarthur> it just wouldn't do what you hope for
09:43:14 <jmcarthur> because it just can't, really
09:43:30 <jmcarthur> brad_larsen: maybe you want something more like monadic regions?
09:43:41 <augur> copumpkin: tell me something about initial algebras.
09:43:51 <rwbarton> it would be no different from, say, 'atomically'
09:43:55 <augur> copumpkin: specifically, tell me, wouldnt it be the case that a type-0 language is an initial algebra?
09:44:45 <jmcarthur> brad_larsen: monadic regions allow you to give a scope for a resource, and the regions package on hackage even allows you to move resources from one scope to another, but as soon as the resource leaves scope its finalizer is guaranteed to run
09:45:05 <augur> i know a guy named brad larson
09:45:06 <brad_larsen> jmcarthur: I've looked at that work some, but it seems awfully complex
09:45:10 <augur> crazy times
09:45:29 <jmcarthur> brad_larsen: yeah it takes some getting used to and it's questionable whether it's worth the syntactic overhead
09:45:59 <jmcarthur> i personally think bracket is usually reasonable enough
09:47:07 <brad_larsen> jmcarthur: yeah, I was just hoping for nicer syntax, and that this might be something others have tackled before
09:47:20 <jmcarthur> i don't think the syntax is that bad
09:47:51 <jmcarthur> the inherent idea is that it's scoped, so there's no way you could use the same do block
09:48:01 <brad_larsen> jmcarthur: you're right, using bracket as-is isn't terrible
09:48:55 <jonkri> how can i go from a bytestring with random elements to a random list of characters with contents like a-z, 0-9?
09:49:47 <rajeshsr> @hoogle mkstemp
09:49:48 <lambdabot> No results found
09:50:07 <brad_larsen> jmcarthur: although, in my actual problem, the use of 'bracket' will be extensive, with the effect of turning the program a bit inside out
09:50:23 <jmcarthur> inside out how?
09:51:09 <jmcarthur> brad_larsen: another possibility could be to attach finalizers to your resources for the GC to call later, but you lose any sort of guarantee that the finalizer will be run
09:51:28 <jmcarthur> brad_larsen: and it's also tough to assign finalizers reliably for some data types
09:51:40 <jmcarthur> but still, that's a reasonable solution sometimes
09:51:48 <brad_larsen> it's a library for binary decision diagrams.  Every BDD value is reference counted, and I want the ref count to be decremented when a BDD value goes out of scope
09:52:13 <brad_larsen> Every library operation that returns a BDD will then use 'bracket'
09:52:21 <jmcarthur> brad_larsen: could you explain what a BDD value is without going into operational details?
09:52:58 <jmcarthur> brad_larsen: this doesn't sound to me like something that needs to be in IO at all
09:53:14 <brad_larsen> Just think of a value of type BDD as a reference-counted resource
09:53:21 <brad_larsen> jmcarthur: oh, but it's a foreign library  :-)
09:53:33 <jmcarthur> that doesn't necessarily mean the interface your bindings expose must be in IO
09:53:37 <jmcarthur> you could make a pure wrapper
09:54:11 <brad_larsen> jmcarthur: there are many library operations, with types like 'BDD -> BDD -> IO BDD'
09:54:23 <jmcarthur> my point still stands
09:54:53 <jmcarthur> what is the *meaning* of a BDD?
09:55:23 <monochrom> a data structure.
09:55:59 <brad_larsen> jmcarthur: every returned BDD needs to have its reference count incremented, and have that count decremented (hopefully) in a timely fashion, so if I use 'bracket' to ensure this, then all the library functions have to get different types, 'BDD -> BDD -> (BDD -> IO a) -> IO a'
09:56:20 <jmcarthur> according to wikipedia, a BDD is a way to implement boolean functions
09:56:21 <brad_larsen> jmcarthur: that kind of looks like CPS to me
09:56:25 <jmcarthur> sounds like a pure idea to me
09:56:29 <brad_larsen> jmcarthur: yes, sorry, slow at typing
09:56:45 <jmcarthur> brad_larsen: i agree. this IO interface looks problematic
09:56:51 <jmcarthur> i'm trying to open your mind to an alternative :)
09:57:00 <brad_larsen> jmcarthur: ideally I'd love a pure interface, but there are some technical issues that make it difficult
09:57:07 <monochrom> except there are all sorts of in-place updates done to this data structure.
09:57:13 <brad_larsen> exactly!
09:57:37 <brad_larsen> so I can imagine an ST monad interface to it, but that's not all that much better than IO, really
09:57:37 <monochrom> depending on your POV, the updates may or may not be considered referentially transparent.
09:57:47 <jmcarthur> so then the interface is transformations on BDDs, not BDDs themselves
09:57:48 <Jafet> unsafeIOtoST and whistle a happy tune
09:58:28 <jmcarthur> or you could use ST and freeze the result, as Jafet hints
09:58:40 <jmcarthur> the then the result would just have a finalizer
09:59:21 <brad_larsen> I was looking into finalizers the other day.  But of course, the story is more complicated...
09:59:53 <jmcarthur> well, finalizers make the implementation of the library harder, but then client code as *far* simpler
09:59:56 <jmcarthur> *is
10:00:04 <Jafet> (That'll only work on ghc, won't it?)
10:00:16 <jmcarthur> finalizers are in the FFI spec i think
10:00:25 <jmcarthur> but ghc's implementation has slightly stronger guarantees i think (?)
10:00:31 <jmcarthur> only barely though
10:01:45 <jmcarthur> what library are you binding to?
10:01:51 <brad_larsen> There are actually a couple related types, BddMgr s and Bdd s.  A value of type 'Bdd s' is sort of a reference into a value of type 'BddMgr s'.  I'm using Rank2Types to ensure that 'Bdd s' values are only used with the manager that they came from
10:02:02 <brad_larsen> jmcarthur: it's one I've written myself
10:02:15 <jmcarthur> ah
10:02:41 <xplat> so you're trying to save your investment in painfully writing this in C?  :)
10:02:47 <xplat> (or C++?)
10:03:47 <jmcarthur> xplat: by making a painful haskell interface! ;)
10:03:55 <xplat> this sounds like exactly the kind of problem monadic regions would be good at, but i'm not sure how good the monadic regions libraries are in practice ...
10:03:57 <brad_larsen> Anyway, when a 'Bdd s' value dies, its reference count (in its corresponding manager) should be decremented, and when a 'BddMgr s' dies, it should be freed.  It's really bad news if the finalizer for the manager is called before the finalizer for its corresponding Bdd values
10:04:26 <jmcarthur> xplat: my experience with monadic regions is positive, but i wouldn't want to expose it in a library interface unless i absolutely have to
10:04:41 <xplat> jmcarthur: why not?
10:05:06 <jmcarthur> xplat: because it's basically just exposing operational details. i prefer pure interfaces
10:05:12 <brad_larsen> The ForeignPtr docs warn about trying to enforce orderings between finalizers
10:05:15 <jmcarthur> it's also just plain complicated
10:05:35 <brad_larsen> so I'm looking at methods other than finalizers.
10:05:41 <xplat> well, yes, a pure interface would be ideal
10:05:52 <led> @djinn Monad m => (([a] -> m [a]) -> ([a] -> m [a])) -> (a -> (([a] -> m [a]) -> ([a] -> m [a]))) -> (([a] -> m [a]) -> ([a] -> m [a])
10:05:53 <lambdabot> Cannot parse command
10:05:55 <led> bah
10:06:05 <xplat> but it seems like there's a long distance between the native interface and what could be called pure
10:06:06 <brad_larsen> xplat: yes, the library is C, but I'd rather not use it from such a low-level language
10:07:05 <Jafet> The reference counting is all done in the library code?
10:07:08 <xplat> brad_larsen: so what is a use case for having two BddMgrs?
10:07:14 <brad_larsen> jmcarthur: the operational details here are kind of important.  :-)
10:07:24 <jmcarthur> brad_larsen: i honestly doubt that :)
10:07:26 <brad_larsen> Jafet: yes, ref counting done in the library code
10:07:47 <Jafet> I find that a pretty weird situation
10:07:51 <brad_larsen> xplat: you ask a pointed (albeit good!) question
10:07:57 <jmcarthur> yeah that's pretty crazy
10:08:36 <jmcarthur> brad_larsen: xplat may be hinting that you could just have a global BddMgr and never finalize it :)
10:08:37 <brad_larsen> xplat: I don't have a use case for two managers.  I think most clients of BDD libraries need only a single
10:10:05 <jmcarthur> the hard part would be making sure it's thread safe
10:10:06 <xplat> indeed i am hinting that all these rank 2 types and ordered finalizers may fall under YAGNI
10:10:10 <jmcarthur> but that wouldn't be too bad i think
10:10:16 <brad_larsen> YAGNI?
10:10:20 <jmcarthur> you ain't gonna need it
10:10:42 <monochrom> I won't why it is not YWNI or YDNI
10:10:55 <jmcarthur> yagni is more fun to pronounce
10:11:11 <monochrom> yeah, obsession with pronounciation.
10:11:13 <jmcarthur> and ain't could be replaced with aren't if you want :P
10:11:32 <monochrom> like how people ask "how do you pronounce <+>?"
10:11:35 <sshc> If I have a large, slightly hierarchical State and will be heavily using the State monad, should I make the type strict by prefixing each type of each field with a '!', or leave them lazy?
10:11:38 <sm> http://c2.com/cgi/wiki?YouArentGonnaNeedIt
10:12:04 <hpc> monochrom: circled plus, judging from how <*> becomes a circled "*"
10:12:07 <jmcarthur> sshc: i typically make record fields strict, regardless of state monad
10:12:14 <hpc> or "closed addition"
10:12:32 <xplat> hpc: yes, that confuses me, i want them to be diamond-plus and diamond-star
10:13:01 <brad_larsen> xplat: Freeing the 'BddMgr s' is maybe not so important, but freeing of unused 'Bdd s' values is very important, since otherwise one is likely to run out of memory on real problems
10:13:04 <monochrom> is there a use case for pronouncing either <+> or YAGNI in a text medium such as IRC for most of us? (i.e., it seems none of us uses a speech synthesizer)
10:13:10 <xplat> i guess it's because diamond-dollar is uncomfortably tall?
10:13:33 <monochrom> in fact, is there a use case for any of us ever actually pronouncing YAGNI out loud?
10:14:12 <sshc> jmcarthur: Why do you?  What are the advantages (particularly regarding performance) of doing so?
10:14:24 <xplat> brad_larsen: yes, i'm not sure a lot of people in this discussion are quite grasping how big BDDs get in typical applications like model checking
10:14:25 <monochrom> face it, you aren't gonna need pronounce YAGNI.
10:15:08 <periodic> I pronounce everything in my head, I just don't assume anyone else has any idea what I'm thinking.
10:15:11 <brad_larsen> xplat: sounds like you know. :-)
10:15:38 <Jafet> IRC just isn't meant to be spoken.
10:15:48 <periodic> And everyone knows "<+>" is pronounced angle-cross.
10:16:05 <periodic> or was it angle-plus...
10:16:51 <mauke> plangle
10:16:51 <Jafet> http://rijndael.info/audio/rijndael_pronunciation.wav
10:17:10 <monochrom> I pronounce most in my head too. but it gets more interesting. for unpronounced things like <+> I just embed a picture in my voice stream.
10:17:18 <brad_larsen> xplat: I'd prefer a nice applicative interface to the library, but it's not clear to me how do that while allowing the control over performance needed for real apps
10:17:51 <brad_larsen> so I'm opting for a lower-level interface in IO.
10:19:29 <brad_larsen> Thanks for the discussion, guys.
10:19:45 <xplat> it seems like this sort of thing would be a natural for linear lambda calculus
10:19:54 <Jafet> Why might applicative have less performance?
10:20:20 <xplat> Jafet: might keep around unneeded BDDs too long
10:20:40 <jp3> A little help here please. Take two functions f & g that consumes a whole list, e.g. f = length and g = last. Those functions obviously can run in constant space. Is there any way of making \x -> (f x, g x) run in constant space?
10:21:24 <jmcarthur> sshc: i don't do it for performance so much as to document that the fields don't rely on laziness. performance comes as a bonus
10:21:38 <Jafet> xplat: yeah, but I don't see why that follows
10:22:10 <xplat> model checking is extremely bottlenecked on memory consumption, in practice the main limitation on its usefulness is that it tends to run you out of memory for larger programs
10:22:22 <periodic> jp3: I could see doing something that is a fold, but then you'd need to write special lenght/last functions to work with an accumulator.
10:22:56 <periodic> jp3: And I assume you mean constant space in addition to the linear space required to hold the list. :P
10:22:58 <jmcarthur> sshc: *the structure doesn't rely on laziness
10:23:01 <Jafet> I mean, why an applicative interface would keep them around too long
10:23:29 <periodic> oh, I guess if the list were generated it might be constant space.
10:23:30 <periodic> huh.
10:23:44 <jp3> periodic: yah, I was hoping now having to rewrite it to use an accumulator.
10:24:03 <periodic> jp3: actually, if you have your list, won't (f x) and (g x) both run in constant space already?
10:24:03 <jmcarthur> sshc: the main performance benefit i know of is that for monomorphic fields you can inline the constructor into the structure and eliminate an indirection by using the UNPACK pragma or the -funbox-strict-fields flag
10:24:10 <xplat> Jafet: it might be that it wouldn't, depending how you did it.  but the most obvious way would, and it's not obvious that there's a less obvious way that wouldn't, or what that way might be ...
10:24:12 <jp3> (and it won't need space to hold the list if it is being generated lazily)
10:24:15 <monochrom> the question is better modified to "how to make ((\x -> (f x, g x)) producer) constant space"
10:24:17 <periodic> jp3: then running both of them should also be constant space?
10:24:47 <xplat> (i hope that statement was not too hard to parse ...)
10:25:03 <jp3> (\x -> (length x, last x)) $ [1..2^63]
10:25:09 <jp3> ...watch ghc blow up
10:25:09 <periodic> jp3: isn't `let {f' = f x; g' = g x} in (f, g)` just make two passes over the list but still be constant space?  Both functionsa are disbarding as they go?
10:25:14 <periodic> jp3: :(
10:25:33 <periodic> jp3: okay, this is too advanced for my Haskell understanding.  Sorry. :(
10:25:42 <jp3> periodic: np
10:25:49 <periodic> I'm going to go back to finishing my Java work today...
10:25:59 <jp3> I might just have to bite the bullet and write my functions using accumulators
10:26:35 <ski> periodic : possibly if you step through the results in lock-step ..
10:26:51 <periodic> jp3: yeah, i guess since you're evaluating on x twice it is keeping x around and not discarding as it goes...
10:26:59 <xplat> periodic: x will be shared, and so the lazy evaluator will force it during whichever of f and g is forced first and keep it around for the other
10:27:08 <periodic> Right, just realized that.
10:27:32 <xplat> jp3: if you write them as folds or something you can just tuple the folds
10:28:05 <monochrom> perhaps (\x -> let {fx=f x; gx = g x} in (fx `par` gx) `pseq` (fx,gx)) helps :)
10:28:18 <periodic> jp3: if your f and g are pretty complex, hopefully someone already wrote them as folds. :D
10:28:50 <jp3> xplat: my functions needs to look arbitrarily ahead, so it would have been nice to be able to do without the accumulator a fold implementation would entail
10:28:57 <xplat> foldrBoth f g f0 g0 = foldr (f *** g) (f0,g0)
10:29:28 <rwbarton> you could try using par or something
10:29:30 <Jafet> I like where monochrom is going
10:29:34 <rwbarton> oh heh
10:29:38 <hpc> @pl foldrBoth f g f0 g0 = foldr (f *** g) (f0,g0)
10:29:38 <lambdabot> foldrBoth = flip flip (,) . (((.) . (.) . foldr) .) . (***)
10:29:42 <hpc> ew
10:29:45 <hpc> :t curry
10:29:46 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:29:53 <hpc> :t uncurry
10:29:54 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:29:55 <xplat> jp3: hm, i don't know a recursion scheme offhand that lets you have arbitrary lookahead easily, maybe edwardk or dolio would ...
10:30:57 <ski> jp3 : iirc, edwardk's <http://comonad.com/haskell/Origami.hs>, as well as (someone else's) <http://squing.blogspot.com/2008/11/beautiful-folding.html> was about such single-pass traversals
10:31:21 <xplat> :t flip flip
10:31:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
10:31:37 * ski idly wonders whether the blog article related to `Origami.hs' has been lost ..
10:32:02 <jp3> monochrom: nope, no luck =/
10:32:44 <monochrom> need to hint it to use 2 cpus or something, like -N2
10:33:00 <ski> (also the "repmin" problem is also about single-pass traversals .. but when some of the inputs depend on some of the outputs, of the *same* call)
10:34:20 <monochrom> the non-strict/lazy solution to repmin cheats. the thunk built mirrors the structure of the input tree.
10:35:23 <monochrom> it is not clear to me that evaluating that thunk counts as 0 passes.
10:37:04 <xplat> the problem with the 'par' solution is that if one function gets ahead it will keep consing, there's no 'governor' to keep the two from getting out of step
10:38:32 <Jafet> You'd also want speculative evaluation, perhaps
10:38:36 <dolio> ski's links are the best I can think of.
10:39:04 <Jafet> Except it's not really speculative but forced from below -- hoisted evaluation?
10:39:25 <xplat> i was distressed to learn today that there's a way to build general recursion out of catamorphism + fmap
10:39:34 <dolio> The idea being: you have two algebras (so to speak) that you're using to reduce the list. To compute both functions at the same time, with the same nice properties, you form some kind of product algebra, and reduce with that.
10:39:37 <ski> (maybe <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#Selectorthunks> is somewhat related to the discussion, as well ..)
10:39:54 <monochrom> wait, fmap is also a catamorphism
10:40:00 <jmcarthur> :t foldr
10:40:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:40:37 <jmcarthur> @djinn (a -> b -> b, b) -> (a -> c -> c, c) -> (a -> (b,c) -> (b,c), (b,c))
10:40:37 <lambdabot> f (a, b) (c, d) = (\ e (f, g) -> (a e f, c e g), (b, d))
10:40:46 <xplat> monochrom: that's what i would have said, but i heard it on edwardk's blog, so i'm forced to give a lot of credence even without a demonstration ...
10:41:07 <dolio> Do you have a link?
10:41:11 <ski>   cata :: Functor f => Algebra f r -> (Mu f -> r)
10:41:15 <aristid> monochrom: fmap is both a catamorphism and an anamorphism, isn't it?
10:41:17 <monochrom> correction. fmap is usually a catamorphism
10:41:21 <ski>   type Algebra f r = f r -> r
10:41:53 <aristid> why only usually?
10:41:57 <ski> (so i suppose we want a product `Algebra f r0 -> Algebra f r1 -> Algebra f (r0,r1)' ?)
10:42:21 <xplat> dolio: http://comonad.com/reader/2008/rotten-bananas/
10:42:47 <xplat> search for 'general'
10:42:59 <ski> (so that `cata phi0 &&& cata phi1 = cata (product phi0 phi1)', i.e.)
10:43:31 <copumpkin> omg it's edwardk 
10:43:33 <copumpkin> in blog form
10:44:43 <dolio> Well, I don't know what he's talking about, except that "general" should instead be "primitive."
10:45:53 <xplat> hm, primitive recursion isn't so bad.  still more than i'd have expected to get from cata + fmap
10:46:01 <dolio> Paramorphisms are primitive recursion, as opposed to catamorphisms' structural recursion.
10:46:33 <jp3> Thanks a lot for the help, I think I have a few ideas to try now.
10:47:12 <ski> (um, i meant of course <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks> before ..)
10:49:48 <Philonous> I'm playing around with continuations and I've come up with "shift f = ContT $ \c -> runContT (f (\a -> ContT $ \r -> c a >>= r )) return" and "reset m = lift $ runContT m return". They seem to do what one would expect for composable continuations. I wonder whether this is a good approximation of schemes shift and reset and if not where the problem ist
10:53:20 <ski> Philonous : if you want, you can define  evalContT = (`runContT` return)  and then `reset = lift . evalContT'
10:53:36 <ski> @type let shift f = ContT $ \c -> runContT (f (\a -> ContT $ \r -> c a >>= r )) return in shift
10:53:37 <lambdabot> forall a r (m :: * -> *) a1. (Monad m) => ((a -> ContT r m a1) -> ContT a1 m a1) -> ContT a1 m a
10:54:28 <Philonous> ski: Well, I have that as fromCC, but reset should really stay in ContT
10:54:44 <xplat> hm, does that type allow result-type-changing shift?
10:54:50 <Philonous> ski: Oh, I misread
10:54:59 <Philonous> ski: Yes, that would be equivalent
10:56:35 <ski> also, `\a -> ContT $ \r -> c a >>= r' can be replaced by `lift . c'), i think
10:56:50 <ski> @type let shift f = ContT $ \c -> runContT (f (lift . c)) return in shift
10:56:51 <lambdabot>     Ambiguous occurrence `lift'
10:56:51 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
10:56:51 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
10:56:59 <ski> @type let shift f = ContT $ \c -> runContT (f (Control.Monad.Trans.lift . c)) return in shift
10:57:00 <lambdabot> forall a (t :: (* -> *) -> * -> *) (m :: * -> *) r. (Monad m, Control.Monad.Error.MonadTrans t) => ((a -> t m r) -> ContT r m r) -> ContT r m a
10:57:22 <ski> well, it's the same, only more general
10:57:35 <ski> and this hints at any change, which changes the interface
10:58:06 <sshc> What standard library should I use for general 2D vectors?
10:58:11 <ski> since the continuation passed to the function argument will always be a function which performs no continuation effects, it can be nicer in some cases to pass it as a plain function
10:58:15 <ski> so
10:58:26 <sshc> s/standard//
10:58:27 <ski> @type let shift f = ContT $ \c -> runContT (f c) return in shift
10:58:28 <lambdabot> forall a (m :: * -> *) r. (Monad m) => ((a -> m r) -> ContT r m r) -> ContT r m a
10:58:32 <ski> which is
10:59:09 <ski> @type let evalContT = (`runContT` return); shift f = ContT (evalContT . f) in shift
10:59:10 <lambdabot> forall a (m :: * -> *) r. (Monad m) => ((a -> m r) -> ContT r m r) -> ContT r m a
10:59:44 <ski> xplat : no, that would be the next step
10:59:57 <ski> i.e., to generalize to
11:00:29 <ski>   newtype ContT2 o p m a = MkContT2 {runContT2 :: (a -> m p) -> m o}
11:00:58 <ski> then one can express a more general `shift' operation
11:01:19 <ski> Philonous : i think Wadler has a paper about composable continuations, which talks about this
11:01:27 <sshc> AC_Vector looks promising
11:02:11 <ski> @type forM
11:02:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
11:02:13 <Philonous> I wonder why there is no library with that
11:02:57 <ski>   MkContT2 . forM :: Monad m => [a] -> ContT2 [o] o m a
11:02:58 <xplat> ContT2 is very handy for 'representing' other monads
11:03:02 <ski> is an interesting combinator
11:03:18 <xplat> a la Filinski
11:03:35 <ski> it can be used for factoring out e.g. two looping levels in nested loops, without factoring out the loop body
11:03:42 <ski> so, if you define
11:03:44 <xplat> (not a la representable functors)
11:03:48 <ski>   collect = MkContT2 . forM
11:03:55 <ski> then you can change from
11:04:08 <ski>   do as <- collect ass
11:04:15 <ski>      a <- collect as
11:04:24 <ski>      lift (a_to_b a)
11:04:28 <ski> to
11:04:43 <ski>   do a <- loopTwice ass
11:04:44 <ski>      lift (a_to_b a)
11:04:45 <ski> where
11:04:52 <ski>   loopTwice ass = do
11:05:01 <c1de0x> why are you looping your ass
11:05:02 <ski>     as <- collect ass
11:05:10 <ski>     a <- collect as
11:05:13 <ski>     return a
11:05:21 <povik> :D
11:05:28 <xplat> yeah, this would be easier to keep a straight face through if you used x
11:05:47 <ion> c1de0x: I hear itâs popular in certain communities.
11:06:04 <ski> .. except that we can't use the nice `do'-notation with these *indexed* monads, so we have to resort to manual  collect ass `bind2` \as -> ...  things, instead
11:06:25 <Philonous> ski: I heard you can with -NoImplicitPrelude 
11:06:35 <c1de0x> ion what'ever floats your boat
11:06:35 <Philonous> -X*.
11:06:42 <xplat> i thought someone wrote a custom prelude that allowed indexed monads, once
11:06:48 <ski> xplat : yeah. Philonous : check out Andrzej Filinskis "Representing Monads" for that
11:07:16 <ski> well, maybe it's possibly with rebindable syntax .. i haven't tried
11:07:59 <Philonous> ski: Does that mean my shift-operator is actually useful, because than I will try to wrap my head around it. I've already written some interesing combinators with it (I begin think the continuation monad is underappreciated)
11:08:16 <Philonous> ski: Not only useful but also does what it advertises?
11:08:33 <ski> (in case it isn't obvious, the above looping basically does `forM ass $ \as -> forM as $ \a -> a_to_b a', so it's really a nested loop)
11:08:57 <ski> advertise ?
11:09:28 <Philonous> Well, is it actually shift? 
11:10:02 * ski went nuts with factoring out loops like above on a laboration once .. unfortunately the examiner thought that my solution was "too complicated" (*phah*)
11:10:29 <ski> Philonous : yes, relative to the monad in question
11:11:02 <Philonous> I had a hard time understanding the semantics of shift. That's why I'm asking, to see if I understood it correctly. 
11:11:05 <Philonous> Ok, thanks
11:11:16 <monochrom> does "factoring out loops" mean "eliminate nested loops"?
11:11:39 <xplat> Philonous: your shift always performs a real shift when you can use it, but iiuc even in ContT there are a few places where you can use shifts that you can't use your function
11:14:03 <ski> (Philonous : of course we can't get true composable-continuation-*side*-effects in haskell, since we don't do side-effects (but see "Fun with Linear Implicit Parameters" at <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> by Thomas JÃ¤ger (TheHunter)))
11:14:25 <xplat> (and the most general form of shift can't even be written in ContT)
11:15:05 <ski> monochrom : i mean it like expressing `loopA {loopB {foo}}' as `do loopA; loopB; foo' and then factoring out `do loopA; loopB', roughly
11:15:18 <ski> (similar to factoring out `f . g' from `f (g x)')
11:17:48 <Philonous> Well then I'll go and trying to figure out whether (and how) I can have control and *0
11:17:48 <xplat> it's fun to do things like factor out matrix product from the underlying ring
11:17:59 <xplat> useful, too, if you have really big matrices
11:18:01 <ski> (e.g. note that `reify (reflect [0,2] + reflect [0,1]) :: [Int]
11:18:32 <xplat> (or sparse matrices, or whatever)
11:18:33 <ski> ' evaluates to `[0,1,2,3]', using that the-monad-reader code)
11:19:22 <xplat> that's just what the scala version does iirc
11:19:51 <drhodes> I'm trying to get my haskell libraries up to snuff for profiling, it's almost working except for containers-0.4.0.0. I've set the two profile flags in ./cabal/config to True, and tried $ cabal install --reinstall containers;  No err msgs.  When I go back to $ ghc -prof ... still ghc persists in "Maybe you should try recompiling containers with profiling..." like nothing changed.
11:19:58 <xplat> in the paper about the compiler plugin for shift/reset
11:22:39 <ski> xplat : paper for scala compiler ?
11:23:17 <ski> what do you mean, more specifically, with "factor out matrix product from the underlying ring" ?
11:23:47 <ski> do you mean (somehow) factoring out the underlying ring multiplication, from the matrix multiplication definition ?
11:25:20 <xplat> like matrix_product (*) (+), or matrix_product (+) min
11:25:45 <xplat> you can also do it with a semiring typeclass and newtypes for the different semirings
11:25:54 <copumpkin> oh I did that with reflection at some point
11:25:59 <copumpkin> I think the code is sitting on hpaste somewhere
11:27:05 <xplat> semirings with + as product are popular for graph algorithms
11:27:07 <ski> xplat : ok .. i was thinking you were talking about factoring it out, by using `shift' ..
11:27:11 <copumpkin> xplat, rwbarton: I'm failing horribly at the definitional object equality + morphism equality, by the way
11:27:42 <copumpkin> xplat: there are also graph algorithms that enjoy tropical semirings
11:27:56 <copumpkin>  guess that's it
11:28:12 * copumpkin shuts up
11:28:30 <xplat> copumpkin: too bad about the equality troubles :(
11:29:14 <copumpkin> I think DrSyzygy is telling me that the natural isomorphisms I had before weren't useless though
11:29:19 * ski wonders whether copumpkin is talking about something in Agda2 ..
11:29:24 <copumpkin> ski: I am!
11:29:54 <ski> which categorical concepts are you trying to capture ?
11:30:08 <yrlnry> I just tried to install "gloss" and "gloss-examples" (http://trac.haskell.org/gloss/) and it appeared to be successful.   But when I run "gloss-hello", it fails, saying "drmRadeonCmdBuffer: -22. Kernel failed to parse or rejected command stream. See dmesg for more info."   
11:30:23 <xplat> i'd be tempted to help if i knew more than a bare smattering of agda
11:30:44 <yrlnry> Am I correct in supposing that this has nothing at all to do with gloss or with haskell, and is a video or GL library configuration problem of some sort?
11:31:12 <xplat> what's the equivalent of hello world for theorem proving?  cogito ergo sum?  :)
11:31:23 <xplat> anyway, i haven't even written it
11:31:25 <copumpkin> a meaningful notion of functor equality (I'm parametrizing my categories over morphism equality equivalence relation) for future endeavors. I've built functor equality as natural isomorphism, proved functors with natural isomorphism form a setoid, and then shown that functor composition is associative and has a unit with that equality
11:31:59 <copumpkin> the more obvious functor equality would be to have F == G iff (forall f. F f == G f)
11:32:09 <copumpkin> where f are morphisms
11:33:51 <yrlnry> Ignore my question above, please; it now seems clear that it is not an error anywhere on the Haskell side of things.
11:34:08 <ski> xplat : maybe proving that sized list concatenation transforms lists of length `m' and `n' into a list of length `m + n' .. or something of a similar vein
11:34:23 <copumpkin> ski: and since I'm sort of using definitional equality on objects, I figured I could use definitional equality on the functors' object mappings, then use that to rewrite my axiom of morphism equality so I wouldn't need heterogeneous morphism equality
11:34:36 <copumpkin> but now my goal types have proofs in them :(
11:34:48 <yrlnry> xplat:  Peano arithmetic proof that 1+1=2 seems like a possibility.
11:35:16 <copumpkin> xplat: there's a fairly decent agda intro tutorial pdf
11:35:22 <copumpkin> and also #agda
11:35:54 <monochrom> hello world of theorem proving: "true or false".
11:36:01 <ski> copumpkin : the definitial being `data Equal {A : Set} (a : A) : A -> Set where Refl : Equal a a', basically ?
11:36:06 <copumpkin> lol
11:36:07 <copumpkin> ski: yeah
11:36:10 <monochrom> make it "2b or not 2b"
11:36:18 <copumpkin> or I should say propositional equality
11:36:44 <ski> monochrom : excluded middle :(
11:36:52 <robryk1> i've got a probably simple problem with cabal. when installing agda i get a confusing error: `cabal: dependencies conflict: ghc-6.12.3 requires array ==0.3.0.1 however array-0.3.0.1 was excluded because ghc-6.12.3 requires array ==0.3.0.2'
11:37:43 * monochrom believes in excluded middle
11:38:01 <ski> copumpkin : why is "goal types have proofs in them" bad ?
11:38:02 <robryk1> array-0.3.0.1 is in my global pkgs and array-0.3.0.2 is in my user pkgs
11:38:17 <copumpkin> ski: cause it's a real pain to do anything with
11:38:32 <ski> (also, i'm not fully sure if `F == G iff (forall f. F f == G f)' is sensible ..)
11:39:01 <ski> an example of "goal types have proofs in them" ?
11:39:10 <copumpkin> Category._â¡_ D (Functor.Fâ G f)
11:39:10 <copumpkin>       (â£-substâ (Category.Hom D) (â£-sym (â£-sym (preserveâ .A)))
11:39:10 <copumpkin>        (â£-sym (â£-sym (preserveâ .B))) (Functor.Fâ F f))
11:39:32 <copumpkin> ski: what would be more sensible?
11:39:33 <ski> ok
11:39:45 <ski> copumpkin : i'm not sure :/
11:40:04 <ski> but i'm not convinced yet that that is the(/a) right way
11:40:16 <copumpkin> the natural isomorphism one was working fairly well
11:40:29 <copumpkin> the only other effort I've seen to abstract over equality in CT in agda punts on this
11:40:48 <copumpkin> it just uses propositional equality on objects and heterogeneous propositional equality on morphisms
11:40:50 <ski> i mean, there's a difference between reasoning about objects, such that the results are true up to isomorphism over the objects .. and reasoning about isomorphism classes of objects
11:41:28 <copumpkin> ski: my category code is https://github.com/pumpkin/categories/blob/master/Category.agda
11:41:48 <copumpkin> then functors with natural isomorphisms are https://github.com/pumpkin/categories/blob/master/Category/Functor.agda
11:42:13 <ski> the monomorphisms from `Fin 3' to `Fin 5' are not the same as the same monomorphisms, up to isomorphism over the domain `Fin 3' (and hence automatically up to equivalence of the resulting sub-objects of `Fin 5')
11:42:16 <copumpkin> I never bothered to do right identity because it was "too easy"
11:42:47 <copumpkin> hmm
11:42:58 <ski> how is "heterogeneous propositional equality" defined ?
11:43:10 <copumpkin> http://www.cse.chalmers.se/~nad/listings/lib/Relation.Binary.HeterogeneousEquality.html#731
11:43:24 <copumpkin> it allows the sets to be superficially different, but the only inhabitant forces them to be the same again
11:43:36 <ski> is it more or less `data JMEqual (A : Set) (a : A) : Set -> A -> Set where JMRefl : JMEqual A a A a' or something like that ?
11:43:45 <copumpkin> yeah, that's it
11:44:14 <ski> *nod*
11:44:25 <ski> ("John-Mayor Equality", iirc)
11:44:35 <copumpkin> major
11:44:36 <copumpkin> I think
11:44:41 <ski> ok
11:44:49 <copumpkin> can't remember the reasoning behind him giving it that name :P
11:44:49 * ski always confuses that :/
11:45:24 <copumpkin> but if I accept heterogeneous equality for my morphism equality, I don't have an issue anymore
11:45:45 * ski vaguely seems to remember "You can buy a car of any color, as long as it's black.", but maybe that's re another thing
11:45:50 <copumpkin> functors are equal if the mapped objects are propositionally equal and mapped morphisms are equal by the heterogeneous equivalence relation
11:46:09 <copumpkin> that seems fairly reasonable to me, but I'm no expert :)
11:46:49 <copumpkin> assuming I can actually encode that
11:47:19 <copumpkin> since I'd be talking about a general heterogeneous equivalence relation
11:47:26 <copumpkin> not one of those nice refl-thingies
11:47:57 <ski> (it would be something like `(x : A) -> x == b -> P x')
11:48:05 <dankna> (thats Henry Ford, not John Mayor)
11:48:19 <dankna> (er, I have no idea who the John- and -Mayor are, but yeah)
11:48:39 <ski> oh, right .. (so i'm probably misremembering which thing was associated to what)
11:48:42 <copumpkin> John Major was the prime minister of the UK
11:48:46 <copumpkin> several years back
11:49:42 <dankna> oh, okay
11:51:26 <augustss> John Mayor equality...
11:51:28 <augustss> Major even
11:51:33 <Philonous> ski: Btw. what did you mean by "true composable-continuation-*side*-effects"? ContT IO gives me continuations on effectful computations, isn't that enough to approximate continuation side effect?
11:51:48 <copumpkin> maybe he should just change his name to John Mayor :)
11:51:49 <augustss> We can all aspire to be equal. 
11:53:08 <ski> Philonous : Haskell doesn't have *side*-effects. Haskell allows modelling *effects*
11:53:45 <ski> in `f :: String -> IO Int' there's no side-effects, but it it was `f :: String -> Int', and still did I/O, there'd be side-effects
11:53:56 <ski> (since the effects were not declared properly in the type)
11:54:34 <copumpkin> to add to that, you can think of it as building a description of what effects to have, in that IO type
11:54:39 <augur> copumpkin!
11:54:40 <copumpkin> without actually running them 
11:54:43 <copumpkin> ohai augur 
11:55:17 <copumpkin> augustss: you haven't been blogging much recently! :(
11:55:43 <augur> sup copumpkin
11:56:00 <augustss> No, but the spammers have lots of comments on my blog. 
11:56:08 <copumpkin> augur: getting frustrated with trying to describe equivalence/equality of functors in agda :(
11:56:27 <copumpkin> and trembling at the thought of reworking the entire library to support it more nicely
11:56:28 <Philonous> ski: Well, yes, but what difference does it make? If we assume that in impure languages all functions have a "silent" IO in the return type, don't we get the same effect?
11:56:42 * ski idly wonders how common it would be to do stuff like `(P : |N -> Set) -> (n : |N) -> (n == Z -> P n) -> ((m : |N) -> n == S m -> P m -> P n) -> P n'
11:56:45 <copumpkin> Philonous: we get to pass around unevaluated IO actions
11:57:02 <copumpkin> Philonous: between threads, in lists, trees, etc.
11:57:14 <hpc> also, the thing about "silent" IO...
11:57:20 <ski> instead of `(P : |N -> Set) -> P Z -> ((m : |N) -> P m -> P (S m)) -> (n : |N) -> P n', i mean
11:57:22 <hpc> if you have foo :: IO String in haskell
11:57:25 <Philonous> copumpkin: You can have thunks in sml
11:57:31 <hpc> then when you do s <- foo
11:57:47 <hpc> s is pure, but in other languages, it's IO String still
11:57:50 <hpc> because it can mutate
11:57:51 <xplat> i think Apply might be the best class to describe most impure languages
11:58:11 <hpc> so you have IO all the way down, so to speak
11:58:21 <ski> Philonous : yes, whether something has side-effects or not is about the concrete syntax used
11:58:42 <xplat> because most of them don't even have a notion of pure value to parameterize a kliesli arrow on, or pass to pure
11:58:42 <copumpkin> Philonous: furthermore, if something is pure, GHC can reorder it and run it twice and so on
11:58:47 <copumpkin> with no worries about breaking semantics
11:58:59 <ski> Philonous : the difference is that with no *side*-effects, we allow modes of reasoning (substitution) which is not always allowed, with side-effects
12:00:44 <xplat> in Apply the index type can basically become a phantom type and it allows even 'weird' effects like breaking open a function body to be modelled
12:01:02 <rwbarton> has anyone actually tried adding the Apply class to ghc?
12:01:15 <copumpkin> rwbarton: what Apply class are you talking about?
12:01:28 <copumpkin> edwardk has one that's Applicative minus pure
12:01:34 <rwbarton> something like class Apply a b c where apply :: a -> b -> c
12:01:44 <rwbarton> probably with a fundep or type family or something
12:01:47 <copumpkin> oh
12:01:53 <copumpkin> I've played with the type family version a bit
12:02:04 <rwbarton> where function application is actually overloaded to be apply
12:02:26 <mercury^_> Is there a link to what you are talking about?
12:02:37 <rwbarton> Me?
12:02:39 <mercury^_> Yes.
12:02:42 <xplat> i was talking about edwardk's version
12:03:00 <hpc> overloaded application?
12:03:01 <copumpkin> class Apply a b c | a -> b c where
12:03:08 <copumpkin> ($) :: a -> b -> c
12:03:14 <hpc> why not "class Apply a b c where ($) :: a -> b -> c?
12:03:14 <rwbarton> I made it up (a while ago), as did some othe people, I don't know of a link
12:03:15 <hpc> "
12:03:16 <copumpkin> then you can define composition on those
12:03:33 <rwbarton> a -> b c?
12:03:33 <ski> xplat : `Apply' ?
12:03:40 <rwbarton> a b -> c?
12:03:45 <Philonous> ski: You seemed to say that composable continuations are less useful in haskell because haskell doesn't have side effects, and I wondered why that takes anything away as we _can_ have effects
12:03:46 <ski> oh
12:04:00 <copumpkin> class Mapping f where type Domain f :: *; type Codomain f :: *; ($) :: f -> Domain f -> Codomain f
12:04:12 <rwbarton> oh right
12:04:20 <ulfdoz> Gott sei dank, kein Gaddafieber.
12:04:22 <xplat> ski: edwardk's Apply class, which has Applicative's <*> but no <$> or pure
12:04:23 <ulfdoz> ewin
12:04:34 <copumpkin> ulfdoz: yes, I agree
12:05:30 <ski> Philonous : i was merely claiming that we don't get composable continuations *side*-effects (since we don't get side-effects at all, only effects modelled by monads (or possibly applicative functors and such))
12:05:32 <mercury^_> What was that talk about `weird effects such as function bodies breaking open'?
12:06:11 <ski> Philonous : but yes, without composable continuations *side*-effects one can't (directly) encode Filinski's monadic reflection `reflect' and `reify' constructions
12:06:44 <xplat> mercury^_: in the Apply class f (a -> b) doesn't need to be able to hold real functions, so you can use data structures as function-oids instead
12:07:06 <xplat> mercury^_: and then they can be inspectable like in, for example, some lisp variants
12:07:13 <mercury^_> Ok. It sounds considerably less exciting when you put it like that.
12:07:18 <ski> Philonous : the monad reader article i linked to shows how to cheat with side-effects in Haskell, to get e.g. `reify (reflect [0,1] + reflect [0,2]) :: [Int]' (equals `[0,2,1,3]')
12:07:21 <Philonous> ski: Oh, ok. I will have to read about that. Thanks again
12:07:28 <rwbarton> This is sort of the reason I wanted overloaded function application
12:07:46 <copumpkin> (=<<) as application? :P
12:07:47 <Philonous> Atm I'm reading Wadlers paper
12:07:52 <mercury^_> But it is still a useful thing to have I think.
12:07:55 <rwbarton> for building up ADTs to translate into instances
12:07:56 <copumpkin> pity I can't have overlapping instances that way
12:08:08 <rwbarton> *SAT instances
12:08:41 <ski> Philonous : roughly speaking, `reflect :: Monad m => m a -> a' (returning something with `m'-*side*-effects), and `reify :: Monad m => a -> m a' (reifying an `m'-side-effectful computation into a normal pure monadic action)
12:09:39 <Philonous> ski: What's the motivation for that?
12:09:56 <hpc> Philonous: it's Enterprise!
12:09:58 <mercury^_> But would it not reduce the optimisations at the compiler's hand by a lot if every application corresponds to sort of a virtual member function call?
12:10:19 <xplat> mercury^_: you can still use reflect and reify to reflect other monads into the ContT2 indexed monad
12:10:23 <xplat> er
12:10:29 <ski> Philonous : to be able to first implement a monad, like a parser monad in Haskell, e.g., then *reflect* that into the language as a new side-effect, without having to change the compiler to support the new kind of side-effects
12:10:29 <xplat> ski: that
12:11:06 <ski> xplat : yes .. i called that "indirect", since you are still (in the types) inside a monad
12:11:29 <rwbarton> ski: where was this link? I don't see it
12:11:33 <xplat> yeah ... it's less useful when you already have polymorphism over monads
12:11:54 <xplat> but there are cases it can be easier than building transformer stacks
12:12:09 <ski> <ski> (Philonous : of course we can't get true composable-continuation-*side*-effects in haskell, since we don't do side-effects (but see "Fun with Linear Implicit Parameters" at <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> by Thomas JÃ¤ger (TheHunter)))
12:12:16 <ski> rwbarton : ^
12:12:26 <rwbarton> thanks
12:12:43 <ski> also, see Andrzej Filinski's paper "Representing monads"
12:12:52 <ski> (and one more of his, but i forget the name)
12:15:09 <xplat> is it a better idea these days to use mtl2 or monads-tf?
12:15:34 <monochrom> depends on whether you like fundeps or type families
12:16:30 <xplat> will either one cause me interop grief with other libraries?
12:18:17 <nominolo> xplat: in my experience most use mtl2/monads-fd
12:18:57 <xplat> (packages with overlapping namespaces are all fun and games until someone uses a type or class from one in a public interface :()
12:20:02 <hpc> xplat: moral of the story, invent every wheel yourself :P
12:21:39 <xplat> hpc: i don't like this story :(
12:21:57 <hpc> xplat: but it's safe for kids! in this version, only hope dies
12:22:52 <FUZxxl> Anybody out there?
12:23:05 <FUZxxl> Can somebody help me on Parsec?
12:23:43 <xarch> FUZxxl: don't ask to ask
12:23:56 <FUZxxl> I have a Data.Map table :: Map String SomeEnum
12:25:19 <FUZxxl> And I want a Parsec parser, that parses a string and returns the elem of the Map that matches or fails, if there is no such elem. (The parser parses till the next whitespace). I'm new to Parsec, please help me.
12:25:59 <Philonous> ski: Btw. I think Dan Piponi made a case that we should replace monads indexed monads anyway. His example was was state iirc
12:26:07 <Philonous> +with
12:27:02 <FUZxxl> So my parser had type parseMyEnum :: ParsecT String u m SomeEnum
12:27:13 <FUZxxl> *would have
12:27:48 <ski> Philonous : yes, state and composable continuations are the most common cases of indexed monads
12:27:57 <xplat> :t maybe mzero return
12:27:58 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
12:28:21 <FUZxxl> No. It would have type parseMyEnum :: Stream s m Char => [Char] -> ParsecT s u m MyEnum
12:28:29 <ski> @type foldr (mplus . return) mzero
12:28:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
12:28:37 <FUZxxl> hm.. I'm confused.
12:28:43 <ski> @type msum
12:28:44 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:28:52 <ski> @type listToMaybe
12:28:52 <lambdabot> forall a. [a] -> Maybe a
12:29:00 <ski> @type maybeToList
12:29:00 <lambdabot> forall a. Maybe a -> [a]
12:29:29 <FUZxxl> :h
12:29:37 <ski> xplat : imo, `maybe mzero return' and `foldr (mplus . return) mzero' should be in libs, e.g. under names `maybeToM' and `listToM'
12:30:00 * hackagebot matrix-market-pure 0.2 - Pure and composable reader and writer of the Matrix Market format.  http://hackage.haskell.org/package/matrix-market-pure-0.2 (SergeyAstanin)
12:31:10 <ski> FUZxxl : i don't think you want a `[Char]' argument to the parser
12:31:23 <xplat> let { maybeToM = maybe mzero return; table = Data.Map.empty } in (maybeToM . lookup table) =<< manyTill isSpace
12:32:26 <FUZxxl> ski: No. SO the type should be Stream s m Char => ParsecT s u m MyEnum or something like this. I'm new to parsec and a bit confused.
12:34:21 <ski> @type let { maybeToM = maybe mzero return; table = Data.Map.empty } in (maybeToM . Data.Map.lookup table) =<< Text.ParserCombinators.Parsec.Combinator.manyTill (Text.ParserCombinators.Parsec.Char.satisfy isSpace)  -- hm
12:34:22 <lambdabot>     Couldn't match expected type `M.Map (M.Map k a) b'
12:34:22 <lambdabot>            against inferred type `Text.ParserCombinators.Parsec.Prim.GenParser
12:34:22 <lambdabot>                                     Char st [Char]'
12:34:47 <ski> FUZxxl : "no" what ?
12:35:00 <rwbarton> :t Data.Map.lookup
12:35:01 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
12:35:07 <FUZxxl> ski: There's no argument.
12:35:18 <xplat> oh, needs flip lookup
12:35:24 <ski> FUZxxl : generally, the parsers will consume their string (or whatever) input implicitly
12:35:30 <xplat> that one always gets me
12:35:48 <FUZxxl> Got that.
12:35:50 <ski> FUZxxl : any explicit arguments of the parsers should be parameters which change which specific parser is used
12:36:07 <ski> @hoogle satisfy
12:36:07 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
12:36:07 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
12:36:07 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
12:36:39 <ski> here the `Char -> Bool'-typed argument is a predicate which says which kinds of characters the parser should succeed eating
12:37:17 <ski> .. i'm not familiar with the class `Stream' which you use above, though
12:37:32 <FUZxxl> ski: I copied the type signature. I copied the wrong one... 
12:38:06 <rwbarton> Stream is from Parsec3 I think
12:38:08 <FUZxxl> Hm. How about a simple Parser then?
12:38:15 <xplat> :t let { maybeToM = maybe mzero return; table = Data.Map.empty } in (maybeToM . flip Data.Map.lookup table) =<< Text.ParserCombinators.Parsec.Combinator.manyTill Text.ParserCombinators.Parsec.Char.isSpace
12:38:16 <lambdabot>     Not in scope: `Text.ParserCombinators.Parsec.Char.isSpace'
12:38:17 <FUZxxl> So, just using strings?
12:38:40 <FUZxxl> :t Text.Parsec.String.Parser
12:38:41 <lambdabot> Couldn't find qualified module.
12:38:42 <ski> @type let { maybeToM = maybe mzero return; table = Data.Map.empty } in (maybeToM . (`Data.Map.lookup` table)) =<< Text.ParserCombinators.Parsec.Combinator.manyTill (Text.ParserCombinators.Parsec.Char.satisfy isSpace)  -- hrm
12:38:43 <lambdabot> forall b st end. (MonadPlus ((->) (Text.ParserCombinators.Parsec.Prim.GenParser Char st end)), Ord (Text.ParserCombinators.Parsec.Prim.GenParser Char st [Char])) => Text.ParserCombinators.Parsec.
12:38:43 <lambdabot> Prim.GenParser Char st end -> b
12:38:55 <FUZxxl> :i Text.Parsec.String
12:39:22 <ski> xplat : *nod* i always think the argument of the `lookup's are in the wrong order, as well
12:39:24 <FUZxxl> So you think, the easiest way is to build it up from basic combinators?
12:39:28 <ski> @index isSpace
12:39:28 <lambdabot> Data.Char
12:39:38 <ski> @type isSpace
12:39:39 <lambdabot> Char -> Bool
12:40:12 <accel> does haskell platform run well (with cabal, hoogle) on the Mac?
12:40:34 <ski> FUZxxl : presumably there's an instance of `Stream s m t' where `s' is `String', though ..
12:41:02 <xplat> oh, manyTill is missing an argument :(
12:41:05 * hackagebot feed2lj 0.0.3.1 - (unsupported)  http://hackage.haskell.org/package/feed2lj-0.0.3.1 (SergeyAstanin)
12:41:11 <xplat> takeTill or something would be better
12:41:51 <xplat> these qualified names kind of get in the way of concentrating on the actual functions
12:42:26 <ski> indeed
12:43:23 <ski> @type let { maybeToM = maybe mzero return; table = Data.Map.empty } in \p -> (maybeToM . (`Data.Map.lookup` table)) =<< Text.ParserCombinators.Parsec.Combinator.manyTill p (Text.ParserCombinators.Parsec.Char.satisfy isSpace)
12:43:24 <lambdabot> forall b st a. (Ord a) => Text.ParserCombinators.Parsec.Prim.GenParser Char st a -> Text.ParserCombinators.Parsec.Prim.GenParser Char st b
12:43:40 <ski> @hoogle takeTill
12:43:40 <lambdabot> No results found
12:44:01 <sober> Hello
12:44:16 <xplat> @hoogle (Char -> Bool) -> GenParser a b c
12:44:16 <lambdabot> No results found
12:44:19 <sober> can somebody assist in installing yesod using cabal please ?
12:44:24 <FUZxxl> How about many (satisfy $ not . isSpace) >>= maybe (fail "Expecting ...") return (flip lookup table)
12:44:24 <ski> @hoogle satisfy
12:44:25 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
12:44:25 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
12:44:25 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
12:44:26 <FUZxxl> Yes.
12:44:31 <FUZxxl> Gor it.
12:45:06 <FUZxxl> thx.
12:45:13 <sober> I'm getting this error:
12:45:26 <sober> "yesod-0.7.1 depends on language-javascript-0.4.2 which failed to install"
12:46:21 <ceii> sober: try running "cabal install language-javascript-0.4.2" and see what the error is
12:46:45 <sober> or to be more specific: http://pastebin.com/TiKzuUPe
12:47:21 <monochrom> "cabal: The program happy is required but it could not be found"
12:47:37 <monochrom> you could "cabal install happy"
12:47:41 <ceii> you need to cabal install happy
12:47:55 <ceii> since it's an executable and not a library, cabal doesn't install it automatically
12:47:58 <xplat> or else you just need to add ~/.cabal/bin to your path
12:48:24 <monochrom> it is an executable-only package, therefore needs manual intervention because cabal-install cannot track executable-only packages
12:48:57 <xplat> (or does cabal handle that itself when it tries to run programs?)
12:49:16 <xplat> (it's probably a good idea regardless, though)
12:49:18 <monochrom> cabal-install cannot modify your PATH either
12:49:22 <sober> so I need to install happy and add ~/.cabal/bin to my $path ?
12:49:31 <ceii> yes
12:49:52 <sober> I see, will check it, thank you very much
12:49:59 <ceii> you might get the same error about alex, since it often goes together with happy; just install it too
12:51:01 <robryk1> i also have a problem with cabal
12:51:35 <robryk1> i've got `cabal: dependencies conflict: ghc-6.12.3 requires array ==0.3.0.1 however array-0.3.0.1 was excluded because ghc-6.12.3 requires array ==0.3.0.2'
12:51:39 <robryk1> when trying to install agda
12:51:42 <monochrom> I see what you mean by "does cabal handle that itself when it tries to run programs?". that would solve half of the problem, and also create another surprise.
12:52:00 <robryk1> array-...1 is in global and array-...2 is in user
12:52:08 <monochrom> kill the user
12:52:10 <robryk1> what is actually wrong here?
12:52:14 <robryk1> ok
12:53:09 <ceii> how the hell does this error happen? -_-
12:53:36 <robryk1> hmm.. a stupid question: how do i do it? i cannot find an `uninstall' action in cabal nor ghc-pkg
12:53:47 <ceii> ghc-pkg unregister
12:53:49 <monochrom> ghc-pkg unregister array-0.3.0.2
12:53:51 <robryk1> thanks
12:54:07 * hackagebot happstack-hsp 6.0.1 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.0.1 (JeremyShaw)
12:54:53 <monochrom> two classes of scenerios. (1) cabal-install heuristic error. (2) human error: one of the scenerios described in my http://www.vex.net/~trebla/haskell/sicp.xhtml
12:55:00 <robryk1> but what was actually the problem?
12:55:33 <monochrom> would need complete history of your computing to find out.
12:55:39 <robryk1> nope, after installing haskell i never installed anything otherwise than cabal install --user
12:56:09 <monochrom> normally I don't trust human memory of detailed history
12:56:42 <robryk1> it's short -- on this machine i have haskell for a few weeks, but point taken
12:56:46 <monochrom> if your file system had complete log of every transaction, I would trust that.
12:57:33 <robryk1> but if it were one of the scenarios described there, why uninstalling array from user would help?
12:57:59 <monochrom> because it approximates undo
12:58:56 <robryk1> i don't quite follow -- were one of those scenarios correct, the last of problemaic actions would be installing something globally, right?
12:59:15 <monochrom> not sure what you mean.
12:59:46 <robryk1> by approximating undo i understand going to a state which used to exist
13:00:04 <robryk1> if one of those scenarios were correct, i would need to go to a state before some install to global, right?
13:02:19 <monochrom> yes
13:03:01 <robryk1> so how can i end up in that by undoing an install to user?
13:03:06 <monochrom> no, not "need to". you have only named one choice, there is another.
13:03:09 <djahandarie> ddarius, have there been any particularly interesting insights gained about differential equations via. its connection to synthetic differential geometry?
13:03:45 <monochrom> one choice kills the global. another choice kills the user. neither is "need to".
13:03:48 <robryk1> oh, ok, i see
13:04:20 <robryk1> thank you
13:05:21 <djahandarie> ddarius, you know, I think I just stumbled upon a PDF you linked to before: Toposes of Laws of Motion by Lawvere
13:06:22 <sober> regarding issue with yesod installation, it worked
13:06:31 <sober> thank you, guysl that made my day
13:12:46 <ddarius> djahandarie: I'm not the best one to ask.  There's certainly some interesting things like fractional exponentiation and a "better" language in some ways, but SDG is somewhat in the "rebuilding everything" stage.
13:14:06 <xplat> what is fractional exponentiation?
13:15:05 <xplat> i mean, the obvious answer doesn't seem to have anything to do with SDG ...
13:16:04 <djahandarie> All I can find about it is a PDF which seems to assume you know what it is. :P "For any given a.t.o.m. T, the fractional exponent B/T is well-defined, for any objec tB; but for T /= 1 the multiplication of these is no longer commutative"
13:16:24 <c_wraith> Hmm.  I've got a MPTC here using a fundep.  I suspect it'd be cleaner as a type family, but I don't know how to express it that way.
13:16:48 <ddarius> For an atom T, the right adjoint to (-)^T is often written (-)^(1/T).
13:17:31 <c_wraith> mostly because I don't really understand the type family extension
13:19:21 <c_wraith> So...  Can anyone give a pointer as to how I'd implement this with type families?  http://hpaste.org/44203/fundep
13:20:03 <chessguy> 0x3A28213A
13:20:18 <chessguy> (sorry, couldn't resist: http://xkcd.com/138/)
13:20:23 <copumpkin> class Cache c where type Key c :: *; 
13:20:25 <c_wraith> Seems like a segfault
13:20:34 <djahandarie> c_wraith, http://hackage.haskell.org/packages/archive/newtype/0.1/doc/html/src/Control-Newtype.html#Newtype does this help? (See commented code)
13:21:13 <copumpkin> instance (Ord key) => Cache (LRU key) where type Key (LRU key) = key
13:22:43 <c_wraith> I guess I really don't understand what's going on in the type definition in the instance.
13:22:56 <copumpkin> it's a type function
13:23:00 <copumpkin> that just happens to be attached to a class
13:23:04 <djahandarie> Get it to typecheck, then try manually desugaring it to the non-associative type family
13:23:22 <copumpkin> so classes can contain value functions and type functions (and non-functions, but whatever)
13:23:33 <xplat> ddarius: and 'atom' is defined as an object T where (-)^T has a right adjoint?
13:23:57 <c_wraith> Hmm.  I *think* I'm starting to grasp it.  Give me ten minutes to see if I'm making proper sense of it
13:24:23 <djahandarie> I'll only give you five!
13:25:02 <ddarius> xplat: That's one way, but there are others where that would be a theorem.
13:25:18 <c_wraith> Oh.  I want an associated type, not associated data.  This is starting to fit together
13:28:24 <c_wraith> so...  in the line "type Key (LRU key) = key"...  It really is a function, on the type level.  The name of it is Key, the argument is pattern-matched against the type the instance is being defined on, and the result is returned?
13:28:28 <ddarius> xplat: One way of getting atoms is microlinearity which states in a simple case that f : RxR -> T -> R; f(x,m)(t) = x + mt is an isomorphism.
13:29:15 * hackagebot unpack-funcs 0.1.0 - Monad transformers that mirror worker-wrapper transformations.  http://hackage.haskell.org/package/unpack-funcs-0.1.0 (LouisWasserman)
13:29:30 <c_wraith> Oh.  It's applied to whatever type argument is given to it.
13:29:35 <c_wraith> makes even more sense
13:31:16 * hackagebot iteratee 0.8.1.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.1.0 (JohnLato)
13:31:49 <c_wraith> Ok.  I have a ton more to learn, but this is a toehold.  And look, this only uses one extension, instead of three. http://hpaste.org/44204/typefamily
13:32:24 <djahandarie> c_wraith, now desugar it ;)
13:32:38 <djahandarie> (For more clarity)
13:32:45 <c_wraith> djahandarie: I have no clue how to desugar this
13:33:33 <c_wraith> In fact, I have no clue what it de-sugars *into*
13:34:11 <djahandarie> By writing the type family outside of the class.
13:34:15 <djahandarie> And writing type instances
13:35:40 <c_wraith> I honestly have no clue what that process looks like here.
13:36:09 <djahandarie> type family Key c :: *; type instance ...
13:37:45 <c_wraith> Never have used those constructs before.  I don't know a thing about them
13:39:13 <djahandarie> c_wraith, http://www.haskell.org/haskellwiki/GHC/Type_families#Instance_declarations_2
13:39:36 <djahandarie> It makes the idea of "type function" much clearer than the associated version imo
13:39:59 <vote_accel_4_ops> has anyone here written an iOS app in haskell?
13:43:22 <bradleyayers> BONUS: where should i tell you about problems with lyah?
13:44:14 <BONUS> best if you email me usually :) although i have a backlog of emails through which i have to go because im lazy
13:44:19 <BONUS> what kind of problem have you found
13:44:25 <vote_accel_4_ops> BONUS: you wrote LYAH ?
13:44:27 <bradleyayers> just really minor stuff
13:44:32 <BONUS> vote_accel_4_ops: yeah :)
13:44:40 <bradleyayers> only two things so far
13:44:47 <vote_accel_4_ops> BONUS: did you draw the figures too? it almost reads like a manga
13:44:54 <BONUS> yeah i drew the pics as well
13:45:00 <vote_accel_4_ops> BONUS: except not enough female chars
13:45:00 <BONUS> bradleyayers: which two things
13:45:05 <BONUS> hehe
13:45:09 <djahandarie> BONUS, next version, make everyone have anime eyes
13:45:12 <djahandarie> ugguu kawaii
13:45:14 <bradleyayers> "Previously, we mentioned that when writing types, the [Char] and String types are equivalent and interchangeable. That's implemented with type synonyms."
13:45:20 <BONUS> lol, yeah sure
13:45:31 <bradleyayers> the highlighting on "String" goes into the trailing space
13:45:43 <bradleyayers> "So we can use this type to encapsulate a value of one type or another and then when we get a value of typeEither a b, we usually pattern match on both Left and Right and we different stuff based on which one of them it was."
13:45:43 <BONUS> aha, i'll fix that
13:45:47 <vote_accel_4_ops> BONUS: you can draw and you understand haskell; how are you both artistically and technicalyo skilled? doesn't that violate the 4th law of thermodynamics
13:45:55 <bradleyayers> "we different stuff"
13:46:02 <bradleyayers> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
13:46:06 <bradleyayers> (on that page)
13:46:19 <BONUS> vote_accel_4_ops: i'm kind of a jack of all trades. ok in lots of stuff but excellent in nothing
13:46:43 <bradleyayers> i'd say lyah is excellent
13:46:52 <BONUS> bradleyayers: thanks, i'll fix those. i went over the whole text with an editor and then a copyeditor
13:47:10 <bradleyayers> no worries, ill make a note of anything else i find
13:47:13 <BONUS> and i'll upload the improved text in a month or so, which should have most dumb errors like this one fixed
13:47:17 <BONUS> cool
13:47:36 <bradleyayers> thanks for writing it :)
13:47:44 <BONUS> thanks for reading :)
13:47:48 <vote_accel_4_ops> can i download RWH as a targz / zip for offline reading?
13:59:22 * hackagebot pwstore-fast 2.1 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.1 (PeterScott)
14:00:24 * hackagebot pwstore-purehaskell 2.1 - Secure password storage, in pure Haskell.  http://hackage.haskell.org/package/pwstore-purehaskell-2.1 (PeterScott)
14:06:49 <xplat> so in my google search i found out that fractional exponentiation is something that John Baez failed to understand without help, and maybe even with help.  surely i am doomed :(
14:09:53 <copumpkin> rwbarton: I took a break from functors, but have shown that (vertical) natural transformation composition is associative and the identity NT is its identity
14:09:59 <copumpkin> working on horizontal now
14:10:23 <copumpkin> should be quite straightforward, once I can actually formulate it
14:10:59 <copumpkin> assuming agda doesn't eat all my RAM before I get there
14:11:15 <Twey> xplat: Fractional exponentiation?
14:13:22 <copumpkin> Twey: if he knew, he wouldn't be complaining! :P
14:14:05 <Twey> Heheh
14:15:00 <xplat> Twey: google "amazingly tiny object model" if you'd like to share my confusion
14:21:30 * hackagebot unpack-funcs 0.1.1 - Monad transformers that mirror worker-wrapper transformations.  http://hackage.haskell.org/package/unpack-funcs-0.1.1 (LouisWasserman)
14:23:06 <hpc> > chr 1110
14:23:07 <lambdabot>   '\1110'
14:29:15 <xplat> > text $ chr 1110
14:29:15 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:29:16 <lambdabot>         against inferred typ...
14:29:31 <Dunearhp> Hi, Does anyone know if there exists a full featured telnet client library for Haskell?
14:29:49 <xplat> > text $ [chr 1110]
14:29:50 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
14:29:56 <dons> Dunearhp: telnet??
14:30:17 <dons> use the curl lib to talk telnet, perhaps
14:30:20 <dons> http://hackage.haskell.org/package/curl 
14:30:29 <xplat> > text [chr 161]
14:30:30 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
14:30:33 <dons> there's an ssh lib
14:30:34 <Dunearhp> interacting with an embedded device
14:30:39 <dons>  http://hackage.haskell.org/package/ssh
14:30:52 <dons> Dunearhp: ah i see. you could use curl, or one of the serial port libs?
14:31:04 <dons> should also be easy to script up a simple telnet lib
14:31:27 <Dunearhp> curl seems optimized for single shot requests
14:31:33 <xplat> does it actually care about telnet, or would simple interactive tcp do?
14:32:05 <Dunearhp> it only supports telnet
14:32:16 <Dunearhp> but it is ont on an open network
14:32:21 <dons> http://collectionofsolutions.blogspot.com/2009/07/haskell-telnet-client-to-run-command-on.html ?
14:32:23 <Dunearhp> is not
14:32:47 <xplat> Dunearhp: no, i mean, does it use telnet's extra capabilities over raw tcp in an essential way when you interact with it?
14:33:40 <Dunearhp> It only really needs the connection persistence
14:34:04 <xplat> so you can really just use the network library, then
14:34:33 * hackagebot unpack-funcs 0.1.2 - Monad transformers that mirror worker-wrapper transformations.  http://hackage.haskell.org/package/unpack-funcs-0.1.2 (LouisWasserman)
14:35:26 <Dunearhp> xplat:  you are probably right, thanks for the link dons
14:35:44 <Dunearhp> that is probably enough to get started
14:36:38 <dons> unpack-funcs eh?
14:36:40 <dons> interesting.
14:37:03 <c_wraith> djahandarie: is http://hpaste.org/44205/desugar the transformation you were talking about?  Seems...  rather rote, in my case :)
14:39:16 * ddarius doesn't understand why Wildberger uses a simple and obvious argument to show that A^1 is not homeomorphic to A^2 but doesn't use the obvious generalization for A^2 and A^3 and instead appeals to Borsuk-Ulam.
14:41:08 <alpounet> what are the A^n here ?
14:43:29 <ddarius> alpounet: The affine n-space.
14:43:45 <ddarius> Say R^n if you'd like.
14:43:54 <alpounet> ok
14:44:28 <grobins> I just realized C++ sucks
14:44:29 <xplat> has a different topology than the usual one for R^n though
14:44:47 <grobins> People always tell me I can turn off this and that
14:44:49 <xplat> which is kind of important when you're talking homeomorphisms ...
14:45:33 <tswett> Is there a Haskell library implementing the monster group?
14:45:57 <tswett> I have no idea how that would be useful, but still.  :P
14:45:58 <grobins> imho all this category theory is not very useful
14:46:01 <grobins> in any way
14:46:08 <grobins> even for studying structure
14:47:43 <grobins> oh this was topology
14:47:46 <xplat> > log 808017424794512875886459904961710757005754368000000000 / log 2
14:47:47 <lambdabot>   179.07657543388052
14:47:54 <grobins> I thought it sad homomorphism
14:48:14 <grobins> well topology is not very useful either
14:48:25 <xplat> hm, 180 bits minimum ...
14:48:39 <tswett> I will be really impressed if someone comes up with a way of efficiently representing an element of the monster group in 180 bits.
14:48:41 <kulakowski> tswett: A couple years ago I had a class about sphere packing, and I remember it being news then (2006, I think) that someone had found an explicit representation of the monster group. 196882x196882 matrices are fun.
14:49:05 <copumpkin> grobins: "is not useful" is a function of the person making the statement
14:49:19 <kulakowski> tswett: This dude: http://www.maths.qmul.ac.uk/~raw/research.html
14:49:35 <copumpkin> "to me, X is not useful" vs. "X is inherently not useful" vs. "I have not yet found a good use of X"
14:49:53 <hpc> copumpkin: isomorphic, the lot of them :3
14:50:05 <grobins> It is only useful if it directly leads to valuable results
14:50:35 <tswett> kulakowski: aye, but Wikipedia says there have been found other, more efficient ways of representing it.
14:50:43 <grobins> imho a lot of these dirty things are just mental masturbation.
14:50:51 <copumpkin> grobins: you ignored my point
14:51:03 <copumpkin> I guess the imho bit acknowledged it implicitly :)
14:51:13 <xplat> look guys, don't feed the math troll
14:51:17 <monochrom> why are you spending time on this?
14:51:18 <tswett> It'd rather not have to use four and a half gigabytes to represent things that could theoretically be represented in 180 bits.  :)
14:51:48 <monochrom> even stronger: don't feed random ramblers
14:52:32 * tswett ponders a lookup table for the monster group, and decides it's going to be a while before we have enough space to store 808,017,424,794,512,875,886,459,904,961,710,757,005,754,368,000,000,000^2 numbers.
14:53:20 <grobins> No but step back for a moment and observe the absurdity in it. It is as if we are a crowd of people and each day we study each other's shits. We pick them up and weigh them. We carefully note their shapes and sizes. We combine lesser shits to become bigger shits. Note the bigger shits properties and smell. For what purpose?
14:53:37 <bradleyayerswork> tswett: you probably want a different approach
14:53:55 <tswett> grobins: it has been said that the moment you find a use for an area of mathematics, you have ruined it.
14:54:09 <bradleyayerswork> haha 
14:54:11 <xplat> yeah, i think that would use up approximately all the bits in the state space of the universe actually
14:54:14 <tswett> grobins: in any case, I hear it happens quite often that an area is studied for many years, and only after many years is a use for it found.
14:54:32 <Philonous> @pl \f -> ConT $ evalCont . f
14:54:32 <lambdabot> ConT . (evalCont .)
14:54:44 <grobins> Why is it useful to study each others mental shits?
14:54:46 <monochrom> this is a silly "debate". could we please just stop?
14:54:54 <copumpkin> also, category theory has already been ruined by tswett's definition
14:54:55 <grobins> When it has no applications
14:55:07 <monochrom> grobins please just stop
14:55:18 <xplat> tswett: grobins already either knows this or doesn't care to know, e is just making trouble
14:55:31 <monochrom> xplat please just stop
14:55:40 <grobins> monochrom: why can't I implore for introspection?
14:55:45 --- mode: ChanServ set +o monochrom
14:55:48 <copumpkin> grobins: because you're assuming you know
14:55:56 <copumpkin> and that others are engaging in some mass hysteria
14:56:00 <copumpkin> it's not an open-minded position to be in
14:56:08 <copumpkin> and is frustrating to attempt to talk to
14:56:15 <grobins> Okay, well maybe it is useful
14:56:23 <grobins> but when do we draw the line?
14:56:23 <copumpkin> that's a better attitude
14:56:23 --- mode: monochrom set +q *!*@*88.89.197.179
14:56:31 <copumpkin> :)
14:56:33 --- mode: monochrom set -o monochrom
14:56:53 * ddarius doesn't understand why this takes so long some times.
14:57:08 <kulakowski> tswett: I just looked at Wilson's publications, and he has a preprint 'P. E. Holmes, R. A. Wilson, A Monster computer package in MAGMA, in preparation.'
14:57:38 <copumpkin> ddarius: "due process" :P we get chewed out by certain people who shall not be named for getting rid of people who haven't demonstrated true trollishness
14:57:47 <Philippa> <grobins> well topology is not very useful either <- y'know, I think the field of non-linear dynamics might have something to say about that
14:58:20 <Philippa> it's only been a significant part of one of the major scientific shifts of the last 100 years, but YMMV
14:58:40 <ddarius> copumpkin: In this case someone joins the channel and just starts spewing non-Haskell related nonsense.  I think you can safely +q in less than ten minutes.
14:58:50 <copumpkin> ddarius: fair enough
14:59:12 <Philippa> copumpkin: yeah, I'm in the "prod sooner" category, much as I fancy feeding trolls on occasion
14:59:35 * geheimdienst feeds trolls to his cat
15:00:06 <copumpkin> meow
15:02:01 * ddarius doesn't care about "trolling."  He cares about noisy, off-topic people who otherwise provide no value.  You may get by with two out of three of these.
15:03:20 <copumpkin> On Conor's John Major equality (thanks to jlouis): "I call this âJMeq', because it widens aspirations to equality without affecting the practical outcome"
15:05:28 <geheimdienst> ddarius: well, no one warned the guy about being off-topic
15:06:04 <monochrom> so warn earlier too
15:06:14 <jsgf> hey all - I've got a function with type "Foo -> [(b, Thing)]".  I just need the Things for now, so I'm doing a "map snd" on its results.  However, the compiler is complaining because the context doesn't let it work out the type of b.  How can I satisfy it?  (The caller doesn't know or care what b is at this point.)
15:06:15 <copumpkin> he's on webchat and the first thing he does upon joining #haskell is talk about C++
15:06:19 <copumpkin> seems pretty clear in retrospect
15:08:20 <hpc> jsgf: pastebin code and error, so someone here knows how to help
15:12:24 <jsgf> hpc: http://pastebin.com/ekgyA0WY
15:13:46 <jsgf> I worked around it by defining "snd' :: a -> (a, b) -> b" to define a version of snd that constrains the type of both halves of the pair
15:16:34 <dmwit> jsgf: Simple way is "vc <- ... `liftM` (getMulti c b k :: IO [(SomeConcreteType, R.VClock)])".
15:16:50 <hpc> :t asTypeOf
15:16:51 <lambdabot> forall a. a -> a -> a
15:16:51 <dmwit> jsgf: Also, saying "The caller doesn't know or care what b is at this point." is not correct.
15:16:56 <hpc> @src asTypeOf
15:16:56 <lambdabot> asTypeOf = const
15:17:08 <hpc> > 5 `asTypeOf` id
15:17:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
15:17:08 <lambdabot>    arising from a use of `...
15:17:11 <dmwit> jsgf: The caller does care, because the implementation of getMany depends on what b is.
15:17:17 <hpc> > 5 `asTypeOf` 8
15:17:18 <lambdabot>   5
15:17:22 <hpc> > 5 `asTypeOf` 0.5
15:17:23 <lambdabot>   5.0
15:17:27 <hpc> > 5 `asTypeOf` (1%2)
15:17:27 <lambdabot>   5 % 1
15:18:03 <hpc> so you want "blahblahblah `asTypeOf` v" somewhere
15:18:22 <dmwit> I thought asTypeOf was a throwback to the days when we didn't have type ascription.
15:18:24 <hpc> @hoogle asTypeOf
15:18:24 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:18:35 <hpc> dmwit: probably, but it's still cool
15:19:43 * hackagebot TypeCompose 0.8.3 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.8.3 (ConalElliott)
15:22:47 * hackagebot functor-combo 0.0.8 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.8 (ConalElliott)
15:23:42 <jsgf> dmwit: you're right, the caller does care, but it wants it to be the same type as the argument 'v' argument 
15:24:39 <jsgf> hpc: yes, asTypeOf looks like what i've hacked up with "snd'"
15:26:45 <hpc> er, actually
15:27:01 <hpc> asTypeOf wouldn't be that good here
15:27:08 <hpc> since you want to constrain only part of the type
15:27:12 <hpc> go with what dmwit said
15:27:54 <jsgf> hpc: I don't have a concrete type on hand though
15:28:26 <hpc> jsgf: you have 'c' in scope though
15:28:40 <hpc> "vc <- ... `liftM` (getMulti c b k :: IO [([c], R.VClock)])"
15:28:45 <hpc> i think
15:29:01 <hpc> yeah
15:29:11 <hpc> er, minus the extra []
15:30:14 <jsgf> hpc: er, OK, I can put an expression in there?  I would be (head v)
15:30:22 <jsgf> *it* would be
15:30:39 <hpc> it should work
15:30:59 <hpc> when you call that function, the 'c' type gets made concrete, both in the top signature and inside
15:34:12 <jsgf> hpc: this doesn't work: http://pastebin.com/HLqy0uks
15:36:14 <hpc> jsgf: http://pastebin.com/i3U8Hvvi
15:36:47 <hpc> basically, the 'c' we are talking about is the monoid-y type
15:36:55 <hpc> when we call getMulti, it doesn't know what monoid to use
15:37:05 <hpc> so we say "use the same monoid as this function is using"
15:37:07 <hpc> and all is good
15:37:10 <jsgf> hpc: ah, OK.  I was getting confused by type and value vars
15:37:15 <hpc> np
15:37:19 * hpc thinks it will work
15:38:07 <jsgf> hpc: hm
15:38:32 <jsgf> hpc:     Could not deduce (Monoid c1, R.IsContent c1)
15:38:32 <jsgf>       from the context (Eq c, Monoid c, R.IsContent c)
15:38:32 <jsgf>       arising from a use of `getMulti'
15:38:47 <jsgf> looks like it isn't picking up the 'c' from the signature
15:38:49 <hpc> bah
15:39:11 <hpc> probably something im too tired to see
15:39:44 <xplat> don't you need ScopedTypeVars to do that kind of trick?
15:39:59 <jsgf> xplat: sounds like the right sort of extension name ;)
15:41:40 <BMeph> To keep your type functions Minty Freshâ¢, use ScopedTyeVars! ;Ã¾
15:41:43 <xplat> in haskell98 typevars are scoped to the ::, not the function
15:42:15 <dmwit> ScopedTypeVars, plus you need to add a "forall" for each variable you want to capture.
15:42:57 <dmwit> (Which sounds so backwards to me, but such is life for backwards-compatible features.)
15:44:10 <jsgf> dmwit, hpc, xplat: thanks all.  That got it: http://pastebin.com/5kNCUfDJ
15:45:16 <xplat> dmwit: yes, it is backwards, but there's a limit to how far you can avoid success and still avoid failure ...
16:03:03 <Guest4309> hello
16:05:15 <copumpkin> rwbarton: I proved both kinds of composition now :) just working on interchange law
16:05:52 --- mode: ChanServ set +o monochrom
16:06:29 --- mode: monochrom set -q *!*@*88.89.197.179
16:06:36 --- mode: monochrom set -o monochrom
16:06:54 <ddarius> copumpkin: Just prove that * is a bifunctor.
16:07:09 <copumpkin> * being?
16:11:54 <ddarius> Actually, give me a second.
16:12:24 <hpc> copumpkin: whatever you want it to be! :D
16:12:25 <copumpkin> I doubt this proof will be much work, once I get all the yak shaving done to actually state
16:12:34 <copumpkin> state the property
16:12:39 <copumpkin> it's kind of ridiculous
16:13:16 <copumpkin> since I have to quantify all my variables explicitly, I have to take the four natural transformations back to the functors they're over, and the categories those are over, and the universe levels those are over
16:13:55 <copumpkin> which led to my horizontal composition proof of associativity mentioning 12 universe levels
16:16:27 <xplat> it sounds like there's some work to be done on managing these things in a more automated fashion ...
16:16:33 <copumpkin> yeah :P
16:16:40 <copumpkin> epigram would be way nicer here
16:16:44 <copumpkin> assuming it ever materializes
16:17:28 <xplat> watching the development of epigram so far has been kind of like watching a transporter accident that way, hasn't it?
16:18:26 <xplat> it was ALMOST there, admittedly not as nice, but then second system syndrome set in before the first system was done ...
16:18:43 <xplat> i can't condemn, though, it happens to me too ...
16:19:45 <hpc> second system syndrome is when you go "screw it, trash the whole thing and make 2.0"?
16:21:09 <ddarius> copumpkin: F is a bifunctor, if it is a functor F : CxD -> E.  That means it takes a composition (f,g) o (h,k) = (f o h, g o k) to F(f,g) o F(h,k), i.e. F(f o h, g o k) = F(f,g) o F(h,k).  Changing notation, (f o h)*(g o k) = (f*g) o (h*k)
16:21:45 <xplat> no, it's when you say, 'okay, i made this system that was kind of good, but not perfect.  now i'm doing basically the same thing again, but i could do this and this better.  oh, and this.  and that and those.  hm, actually these are all one thing if you look at it the right way.  refactor, refactor ... (10 years go by) ... almost done, but wait, what if ...
16:21:50 <kulakowski> hpc: http://en.wikipedia.org/wiki/Second-system_effect
16:23:02 <kulakowski> "See also: OS/2." Ha.
16:23:04 <dolio> ddarius: Oh, that's even nicer than I thought.
16:23:29 <hpc> lol
16:23:41 <hpc> like the external links
16:24:19 <xplat> hm, my definition seems to be slightly off from the canonical one too
16:24:42 <hpc> close enough
16:25:02 <dolio> I was thinking about defining an (n+1)-category as a category enriched (more or less) in an n-category. But I was kind of assuming I'd have to state an interchange law of some sort.
16:25:22 <dolio> I didn't realize that merely being a bi-n-functor was sufficient.
16:26:43 <xplat> dolio: 'category enriched in an (n-1)-category' is an okay definition for strict n-categories, but unfortunately nobody cares about those ...
16:27:15 <xplat> i don't think it works out nicely for weak n-categories
16:27:48 <dolio> xplat: I don't believe in equivalences that are inappropriate for n-categories, so the identity and associativity laws are automatically weak.
16:30:07 <copumpkin> ddarius: I'm not sure how proving that would be easier than proving this (and stating it is harder than proving it :/)
16:30:45 <xplat> mmmaybe you could stretch it to globular weak n-categories by abusing the definition of 'enriched' a little bit, but that still wouldn't get you the versions that are better to work with
16:31:33 <xplat> (simplicial and operadic)
16:33:00 <ddarius> copumpkin: It's probably not any simpler.  Instead you should just prove that Cat is cartesian closed and that Cat(2,C) is isomorphic to Arr(C).
16:33:18 <copumpkin> ack :P
16:33:33 <copumpkin> what's Cat(2,C) ?
16:33:47 <ddarius> Hom in Ca.
16:33:48 <xplat> Hom(2,C) in Cat
16:33:49 <ddarius> +t
16:33:50 <copumpkin> oh okay
16:33:59 <xplat> presumably this is with the ordinal 2
16:35:40 <xplat> which is famous for being the smallest category with two different objects and one non-iso arrow between them
16:39:39 <copumpkin> I really want epigram to just figure this bit out for me
16:45:45 <ddarius> copumpkin: Epigram?
16:46:02 <copumpkin> it doesn't require you to explicitly introduce all quantified type variables
16:46:06 <copumpkin> and will figure stuff out for you
16:47:10 <copumpkin> here I need to figure out all the types of the natural transformations, and their functors, and their categories :P
16:47:17 <copumpkin> which I've done now, but it's annoying
16:49:12 <jmcarthur> epigram 2 seems like it will never come
16:50:47 <Adamant> Duke Nukem Forever is due for release in May
16:50:55 <copumpkin> anyway, what I was bitching about was having to figure out this type: http://snapplr.com/p8mr
16:50:57 <Adamant> hope springs eternal from the human breast
16:50:58 <BMeph> ...2012. ;)
16:51:04 <copumpkin> the bit at the bottom is the nice clean statement of it
16:51:08 <Adamant> BMeph: :P
16:51:14 <copumpkin> the rest is crud
16:51:17 * BMeph chortles evilly!
16:52:22 <dolio> Oh, your categories have three levels.
16:52:38 <Adamant> when you hit the fourth you can do inception
16:52:48 <copumpkin> dolio: didn't want equality to feel left out ;)
16:52:53 <dolio> Right.
16:53:10 <copumpkin> that's how I managed the amazing feat of quantifying over 12 universe levels
16:53:26 <copumpkin> in that other proof
16:54:16 <ddarius> copumpkin: Perhaps you should use a proof assistant rather than a proof assistant that dreams of being a programming language.
16:54:16 <copumpkin> seems kind of interesting to think about these proofs combinatorially though
16:55:12 <copumpkin> if I tell you that I'm proving something about 4 categories, 6 functors, and 3 natural transformations, and that it's the most general statement of the proof, can you tell me what it is?
16:55:27 <copumpkin> or in this case, 3 categories, 6 functors, and 4 natural transformations
17:00:31 <ddarius> copumpkin: Perhaps you should start proving theorems about proving theorems.
17:07:28 <copumpkin> ddarius: seems fun :P
17:08:44 <monochrom> and yeah, use a proper theorem prover rather than a web-scale programming language that dreams of having a GÃ¶del-complete type system.
17:09:15 <copumpkin> lol
17:09:24 <ddarius> Is it bad that I see monads in basic arithmetic?
17:09:52 <monochrom> yes, very bad
17:10:41 <copumpkin> seek help now!
17:11:38 <Mathnerd314> I could see monoids, but not monads...
17:12:23 <copumpkin> Mathnerd314: gotta look harder, I guess :)
17:12:49 <ddarius> Mathnerd314: The natural numbers are the free monoid over (), i.e. [()].  Addition is mplus and multiplication is (>>).
17:13:40 <Mathnerd314> :t (>>)
17:13:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
17:14:01 <ddarius> And indeed, one way of thinking about multiplication is that you view 3, say, as 1+1+1 and you replace each 1 with 4, say, if doing 3*4, getting 4+4+4.
17:14:19 <ddarius> This "substitution" is a very monadic thing.
17:15:47 <copumpkin> interesting
17:16:14 <Mathnerd314> what would exponentiation be?
17:16:24 <monochrom> moar substitutions
17:16:25 <Bynbo7> replicateM?
17:17:00 <Twey> > replicateM 3 [(), ()]
17:17:01 <lambdabot>   [[(),(),()],[(),(),()],[(),(),()],[(),(),()],[(),(),()],[(),(),()],[(),(),(...
17:17:10 <Twey> > length $ replicateM 3 [(), ()]
17:17:11 <lambdabot>   8
17:17:19 <Twey> Hmm
17:17:36 <Twey> It sort of works :Ã¾
17:19:05 <Mathnerd314> it's the wrong type; you want [(), (), ()] not 3
17:19:24 <Bynbo7> replicateM . length?
17:20:03 <Mathnerd314> > replicateM_ (length [(),(),()]) [(), ()]
17:20:03 <lambdabot>   [(),(),(),(),(),(),(),()]
17:20:58 <Bynbo7> > let pow = replicateM . length in pow [(),(),()] [(),()]
17:21:00 <lambdabot>   [[(),(),()],[(),(),()],[(),(),()],[(),(),()],[(),(),()],[(),(),()],[(),(),(...
17:21:08 <Bynbo7> > let pow = replicateM_ . length in pow [(),(),()] [(),()]
17:21:09 <hpc> Mathnerd314: [(), (), ()] >> [(), ()]
17:21:10 <lambdabot>   [(),(),(),(),(),(),(),()]
17:21:15 <hpc> > [(), (), ()] >> [(), ()]
17:21:16 <lambdabot>   [(),(),(),(),(),()]
17:21:20 <hpc> er
17:21:35 <Mathnerd314> that's multiplication, as ddarius said
17:21:38 <hpc> > [(), ()} >> [(), (), ()]
17:21:39 <lambdabot>   <no location info>: parse error on input `}'
17:21:43 <hpc> > [(), ()] >> [(), (), ()]
17:21:44 <lambdabot>   [(),(),(),(),(),()]
17:21:49 * hpc surrenders
17:24:27 <Mathnerd314> > [(),()] *> [(),(),()]
17:24:28 <lambdabot>   [(),(),(),(),(),()]
17:24:45 <Mathnerd314> > [(),()] <|> [(),(),()]
17:24:46 <lambdabot>   [(),(),(),(),()]
17:24:54 <hpc> Mathnerd314: oh, length has a dumb off-by-one problem
17:25:00 <hpc> i think
17:25:00 <kmc> > join [[(),()],[(),(),()],[(),(),(),(),()]]
17:25:01 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
17:25:09 <hpc> > repicateM_ 0 [()]
17:25:10 <lambdabot>   Not in scope: `repicateM_'
17:25:15 <hpc> > replicateM_ 0 [()]
17:25:15 <lambdabot>   [()]
17:25:27 <hpc> or replicateM_
17:26:18 <pedro3005> Is there a way to clear the terminal screen from Haskell?
17:26:51 <hpc> pedro3005: /usr/bin/clear :D
17:27:02 <hpc> (call it with system)
17:27:28 <hpc> ((the actual clear utility just prints the magic clear character, which varies from shell to shell))
17:28:16 <pedro3005> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html#v%3Asystem using this?
17:31:30 <hpc> pedro3005: exactly that
17:32:25 <hpc> there's other cool functions in there that i should probably play with
17:39:48 <c_wraith> > replicateM 3 "01"
17:39:49 <lambdabot>   ["000","001","010","011","100","101","110","111"]
17:40:04 <c_wraith> look, replicateM can count in base-whatever!
17:40:14 <c_wraith> > replicateM 2 "0123"
17:40:14 <lambdabot>   ["00","01","02","03","10","11","12","13","20","21","22","23","30","31","32"...
17:48:13 <dmwit> Um. The clear character doesn't vary by shell, but by terminal.
17:48:30 <dmwit> And even then, I don't think I've heard of any terminal that doesn't keep VT10x's clear code.
17:49:20 <blbrown_win3> I was using leksah (just downloaded most recent) for win32, I click on the figure pane and then it crashes (exits).  Anyone see this or know another way to configure a package 
17:51:24 <dmwit> putStr "\ESC[2J" works here for clearing the screen; you'll probably want to follow it up with "\ESC[H" to move the cursor to the top left.
17:54:05 <dmwit> blbrown_win3: Configuring a package is usually as easy as typing "cabal configure" from within the project's directory. Have you tried that?
17:54:31 <dmwit> Also, what package are you trying to build?
17:56:30 <blbrown_win3> dmwit, I was just seeing what options were available in the window pane
17:56:47 <blbrown_win3> I sent an issue
17:57:06 * dmwit nods
17:57:08 <dmwit> That is probably sanest.
18:03:26 <elliott> So if I were to ask how to turn an Int# into an Int, how long would it take me to get kicked out of disgust? :)
18:03:58 <dmwit> p. long, I suspect
18:03:59 <c_wraith> I#
18:04:05 <dmwit> ?src Int
18:04:05 <lambdabot> data Int = I# Int#
18:04:08 <c_wraith> ...  That's my answer, not random typos :)
18:04:10 <dmwit> easy as pie
18:04:27 <dmwit> ?index I#
18:04:27 <lambdabot> GHC.Exts
18:05:11 <elliott> ah, I was trying S#, but ofc that's not right
18:05:32 <elliott> | I# (reallyUnsafePtrEquality# x y) == 1 =
18:05:40 <elliott> yeah i do not have a good feeling about that guard
18:05:44 <sshc> Are guards allowed in case expressions?
18:05:47 <c_wraith> yes
18:06:42 <dmwit> ?instances-importing GHC.Exts Num
18:06:42 <lambdabot> Double, Float, Int, Integer, Word
18:06:43 <kmc> there's also an equality operator on Int#
18:06:48 <kmc> probably eqInt# or something
18:07:02 <kmc> instance Eq Int where { I# x == I# y = eqInt# x y }
18:07:58 <elliott> heh
18:08:00 <elliott> that's FASTER!
18:08:25 <elliott> eqInt# (I# (reallyUnsafePtrEquality# x y)) 1#
18:08:26 <elliott> thanks kmc
18:08:31 <elliott> you made my code even better than it was
18:08:34 <elliott> i didn't think that was possible
18:08:41 <elliott> oops, extraneous I#
18:09:17 <elliott> kmc: eqInt# doesn't seem exported though
18:09:27 <kmc> GHC.Prim?
18:09:50 <kmc> it might be named something else
18:09:54 <kmc> also it probably returns Int
18:10:01 <kmc> or even Int# :/
18:10:03 <elliott> already imported GHC.Prim :-P
18:10:33 <Igloo> I'd say it's better with the I#
18:10:54 <Igloo> Easier to read, and GHC should optimise them to be the same anyway
18:11:10 <elliott> Igloo: "Easier to read". Nice.
18:11:31 <elliott> dataToTag# :: a -> Int#Source
18:11:31 <elliott> tagToEnum# :: Int# -> a
18:11:34 <elliott> Now that looks like FUN.
18:11:59 <kmc> heh
18:12:07 <kmc> nice, lets you unbox any enum type
18:12:13 <ddarius> "Last year my daughter had been taught subtraction in a way that I do not approve of."
18:12:14 <elliott> kmc: no, ANY type!
18:12:18 <elliott> I see no Enum constraint!
18:12:25 <kmc> elliott, sure, that will end well...
18:12:28 <xplat> :t ap .: ap .: fmap
18:12:29 <lambdabot> forall a b a1 a2. (a2 -> a1 -> b) -> (a -> a2) -> ((a -> a1) -> a) -> (a -> a1) -> b
18:12:34 <elliott> as well as haskell code involving # usually does
18:12:37 <kmc> it's too bad lambdabot doesn't let us play with these things
18:12:43 <elliott> yeah. and unsafeCoerce.
18:12:45 <elliott> and unsafePerformIO.
18:12:48 <elliott> i have to, like, test that locally.
18:12:48 <kmc> haskell is like sausages
18:12:52 <xplat> :t (ap .: ap) .: fmap
18:12:52 <lambdabot> forall (m :: * -> *) a b a1 a2. (Monad m, Functor m) => (a2 -> a1 -> a -> b) -> m a2 -> m a1 -> m a -> m b
18:13:04 <elliott> kmc: you never know what you're gonna get?
18:13:14 <elliott> <kmc> EXACTLY!
18:13:27 <xplat> :t ((ap .: ap) .: ap) .: fmap
18:13:27 <lambdabot> forall (m :: * -> *) a b a1 a2 a3. (Monad m, Functor m) => (a3 -> a2 -> a1 -> a -> b) -> m a3 -> m a2 -> m a1 -> m a -> m b
18:15:41 <ivanm> dammit, I had the brilliant idea of re-implementing the behaviour of "dot -Tcanon" within graphviz, but now I'm stuck on how to deal with graph attributes :s
18:15:50 <bradleyayerswork> c_wraith: how does replicateM work :O
18:16:02 <bradleyayerswork> what's the action it's using?
18:16:14 <c_wraith> bradleyayerswork: it's using >>= in []
18:16:39 <bradleyayerswork> why?
18:16:49 <ivanm> bradleyayerswork: why not?
18:16:52 <ivanm> @src replicateM
18:16:52 <lambdabot> replicateM n x = sequence (replicate n x)
18:16:58 <ivanm> @src sequence
18:16:58 <lambdabot> sequence []     = return []
18:16:59 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:16:59 <lambdabot> --OR
18:16:59 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:17:18 <elliott> pah, in enterprise Caleskell, replicate works on any monad
18:17:29 * hackagebot hashable 1.1.1.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.1.1.0 (JohanTibell)
18:17:42 <xplat> 20:20 < copumpkin> anyway, what I was bitching about was having to figure out  this type: http://snapplr.com/p8mr
18:17:48 <xplat> what is that i don't even
18:17:58 <dmwit> xplat: Agda is pretty, isn't it?
18:18:27 <copumpkin> xplat: I like the pattern of the 6 functors going into the NTs
18:18:31 <dmwit> Every language should support all of Unicode and mixfix.
18:18:44 <copumpkin> next up, non-BMP characters in my source
18:18:49 <bradleyayerswork> thanks ivanm, c_wraith, i don't know haskell well enough to fully understand, but it'll give me something to look into later
18:19:04 <elliott> the great thing about agda code is that writing all the unicode distracts you from the fact that it's a pain to use.
18:19:07 <kmc> i use klingon for all my identifiers
18:19:11 <elliott> sorry, i said nothing
18:19:20 <kmc> copumpkin, do you have enough RAM to do category theory yet?
18:19:30 <copumpkin> elliott: you're just sad cause I quantify over more universes than you do
18:19:34 <dmwit> On his hardware or his wetware?
18:19:35 <copumpkin> kmc: yeah, haven't run out of memory yet
18:19:47 <copumpkin> most I've seen was 1.4GB 
18:19:51 <elliott> copumpkin: Yeah, my universal universe quantification is sorely lacking.
18:19:57 <elliott> dmwit: On his Unicode computer.
18:20:00 <elliott> Every serious Agda hacker has one.
18:22:02 <augur> cat theory people: how is it that B^A ~ A -> B does not conflict with A^2 ~ A*A?
18:22:42 <augur> A^2 ~ A*A allows inhabitants to have the same cars
18:22:46 <augur> while A -> A does not
18:23:05 <doserj> A^2 = Bool -> A, not A->A
18:24:02 <augur> mm..
18:24:22 <augur> ahh yes right
18:24:33 <augur> cause A -> B is really {A*B} not A*B
18:24:37 <augur> right ok
18:24:44 <ddarius> augur: You should explicitly implement the isomorphism.
18:24:54 <augur> ddarius: nevermind, its sorted. :)
18:27:18 <augur> ok, now to figure out where to learn about algebras. probably i should just read more about CT
18:27:22 <augur> damn CT :|
18:27:55 <xplat> the Agda code looks pretty, but i can't quite tell what i'm reading
18:28:32 <augur> xplat: so true x.x
18:29:51 <xplat> what is going on with the first line (first three binders after the â)?
18:30:37 <dolio> Those are all names.
18:30:57 <dolio> â can be used to tell agda to infer the types of arguments.
18:31:28 <dolio> So instead of {o0 t0 e0 : Level} you can write â{o0 t0 e0}
18:31:52 <dolio> I don't know why he broke them into three groups. I guess because they go together in some sense.
18:32:06 <xplat> well, each goes with one category
18:32:50 <xplat> so why do the categories need to be supplied explicitly in the definition, but not the levels or the functors?
18:34:01 <dolio> If he didn't write out 'Category o0 t0 e0', it wouldn't know that o0 t0 and e0 are supposed to be levels, and be parameters to the category.
18:34:28 <copumpkin> yeah, I broke them into groups cause they're associated with different categories
18:34:35 <copumpkin> I haven't quite decided what I like doing
18:35:07 <dolio> Using them with Category that way is enough to determine their type, though, so he doesn't have to write their type.
18:35:35 <copumpkin> I still haven't actually proved that
18:35:42 <copumpkin> had to go out and made a phone call
18:36:05 <xplat> oh, i understand now why there's no â: Levelâ in the type sig of interchange
18:36:23 <copumpkin> forall tells it to "infer"
18:36:25 <augur> copumpkin: list :: a -> (b -> [b] -> a) -> [b] -> a   ;   list z _ [] = z ; list _ f (x:xs) = f x xs
18:36:44 <copumpkin> augur: yes? :)
18:37:17 <xplat> i now just don't understand why the next line, the (incomplete) definition of interchange, includes the natural transformations and categories but none of the rest
18:37:23 <augur> ~ foldr :: a -> (b -> a -> b) -> [b] -> a   ;   foldr z _ [] = z ; foldr z f (x:xs) = f x (foldr z f xs)
18:37:49 <augur> what are these things
18:37:51 <copumpkin> xplat: I'm binding the names cause I'll need them in a bit
18:37:51 <xplat> in the argument list
18:38:02 <copumpkin> xplat: I actually bound them wrong in that screenshot
18:38:04 <copumpkin> they're positional
18:38:12 <copumpkin> and I was binding things to the universe levels, that I definitely don't care about
18:38:46 <copumpkin> http://snapplr.com/kcrm etc.
18:38:56 <xplat> oh, so you put only the things you care about, and you haven't spaced them apart with _ or whatever agda uses
18:39:09 <xplat> but you will need to do that later
18:39:10 <augur> fold im guessing is some notion of recursion, so i feel like if you have fold for lists, and this list function, there should be analogs to fold for other data type equivalents like maybe, either, and bool
18:39:15 <copumpkin> well, because they're implicit arguments, I don't have to include any of them (they're in { })
18:39:29 <copumpkin> augur: eliminator?
18:39:37 <augur> as if you could say foldr = f list
18:39:37 <copumpkin> not really sure what one would call the non-recursive form of it
18:39:43 <ddarius> Watching (ultra)finitists is entertaining.
18:39:51 <augur> foldMaybe = f maybe
18:39:51 <augur> etc
18:39:56 <xplat> oh, { } makes them all implicit?
18:40:04 <copumpkin> yeah
18:40:32 <xplat> and each { } is all or nothing as to whether you decide to include it?
18:40:56 <copumpkin> nah, I have to match individual variables independently all the time
18:41:02 <copumpkin> even if I group their types in implicit blocks
18:41:31 <xplat> what does the grouping actually do then?
18:41:39 <copumpkin> just saves me some typing
18:41:42 <augur> copumpkin: where can i learn all about algebras and f-algebras, do you think?
18:41:45 <copumpkin> if multiple things have the same type, I can put them together
18:42:36 <copumpkin> I'm the wrong person to ask :P most of the little I know about math came from wikipedia, and I'm slowly filling in the skeleton with actual books on the topics
18:43:00 <ddarius> @google gibbons chapter algebra
18:43:02 <lambdabot> http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/acmmpc-optimization.pdf
18:43:02 <lambdabot> Title: Chapter 8 Algebraic Methods for Optimization Problems
18:43:14 <ddarius> Almost.
18:43:30 <augur> that might be useful tho :x
18:43:47 <augur> since im looking to understand algebras partially to help me understand a certain class of optimization problems
18:44:04 <ddarius> http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/acmmpc-calcfp.pdf
18:44:05 <xplat> and if binding is positional, aren't you mixing up your functors?
18:44:23 <copumpkin> xplat: yeah, I did :P I've since fixed that too
18:44:32 <copumpkin> you can also bind by name, as you see with the C0
18:44:47 <copumpkin> but once you've done that, it shifts position over, so I can avoid naming the other ones
18:44:58 <xplat> when you bind by name, do you still have to bind in order and it just lets you skip ahead some?
18:45:12 <xplat> or can you reorder as well?
18:45:20 <augur> i should probably just read more about CT, huh ddarius
18:45:23 <copumpkin> I can reorder I think, if I bind by name
18:45:32 <copumpkin> not sure what happens if there's a parameter dependency though
18:45:34 <ddarius> augur: No, you should probably read what I recommended.
18:45:41 <augur> im going to!
18:46:27 <copumpkin> dude all the cool kids are doing it
18:46:32 <ddarius> God made the natural numbers, but I don't believe in God.
18:46:48 <xplat> i guess you don't get much freedom to reorder things when dealing with dependent types, the dependencies can constrain you pretty strongly
18:46:49 <Pseudonym> God is real, unless declared integer.
18:47:26 <copumpkin> xplat: yeah :/
18:47:34 <xplat> ddarius: you godless ultrafinitist!
18:47:36 <copumpkin> the flip function is pretty neutered with dependent types
18:47:41 <ddarius> Good ole telescopes.
18:48:09 <luite> I thought that He created the integers... unless you don't believe in Stephen Hawking
18:48:32 <Adamant> like Belgium, he's a myth
18:48:55 <augur> copumpkin: false = flip true
18:48:55 <augur> :o
18:48:56 <xplat> how could anybody believe in a guy who solves the wheeler-dewitt equation in his head?
18:48:57 <kmc> anyone here used the Diff package?
18:49:03 <kmc> know if it's supposed to perform decently well?
18:49:24 <copumpkin> kmc: it's haskell, of course it's slow
18:49:28 <xplat> i mean come on, how gullible do they think we are?
18:49:38 <kmc> ;P
18:49:38 <augur> copumpkin: i wonder if this is sort of true of all dual relationships in LC logic
18:49:58 <kmc> for reference, this algorithm was designed to run decently fast on the PDP10
18:50:22 <kmc> and my input is on the order of 10,000 "lines"
18:50:31 <xplat> true = const, false = flip true
18:50:34 <kmc> but i bet i'm doing something else wrong
18:50:42 <augur> exlevan: exactly!
18:50:48 <augur> ..
18:50:50 <augur> xplat: exactly!
18:50:52 <augur> :x
18:51:41 <augur> and = \a b -> a b false   ;   or = \a b -> a true b
18:52:17 <augur> flip and = \a b -> b a false =/= or
18:53:04 <xplat> titleWords = (fst . foldr1 $ first . (uncurry $ (++) .: (++))) <$> many1 titleWord
18:53:10 <shlevy> Hi all. I'm very new to Haskell (just finished reading Learn You A Haskell last week) and am trying to do as many of my upcoming projects in functional style as possible to see if the results are better than imperative styles. My next project is to write a custom /init executable for an initramfs. It needs to mount /proc and /sys, assemble some fakeraid arrays, load some kernel modules, mount the root filesystem, and then chroot and 
18:53:10 <copumpkin> I love doing this stuff, despite the tedium
18:53:10 <shlevy> the real /sbin/init. No matter how I look at it, I keep seeing this as a purely imperative problem, but I wanted to check here to see if there's a functional way to approach this before I do it in C
18:53:24 <augur> copumpkin: what stuff
18:53:29 <xplat> ... not the most readable line of haskell i've ever written ...
18:53:36 <copumpkin> the proofy stuff, and CT
18:53:44 <augur> o ok
18:54:23 <copumpkin> math in general I suppose
18:54:27 <tibbe> Anyone know why BangPatterns didn't make it into Haskell 2010, given that they are so frequently used?
18:54:33 <augur> copumpkin: when can i teach you linguistics? :D
18:55:14 <ddarius> augur: When you formalize it so it can be checked in a proof assistant.
18:55:30 <djahandarie> c_wraith, (had to go to class), but yep
18:55:44 <xplat> shlevy: i wouldn't say that was an inherently imperative problem, but it's probably not a good project for someone new to haskell
18:55:48 <augur> ddarius: i wasnt talking to you, but i intend to do it with haskell, so while there might not be proofs involved, there will definitely be runnable code :D
18:55:49 <copumpkin> what ddarius said :)_
18:56:02 <augur> or pseudohaskell, anyway
18:56:05 <copumpkin> augur: ddarius is my agent
18:56:16 <adamvh> shlevy: don stewart did a presentation on using Haskell for scripting with sysctl's in BSD
18:56:17 <copumpkin> a secret one, at that
18:56:23 <augur> copumpkin: i dont deal with agents
18:56:28 <augur> we start next weekend, copumpkin!
18:56:29 <adamvh> shlevy: might make interesting reading for that sort of problem
18:56:31 <augur> prepare yourself!
18:56:32 <copumpkin> :O
18:56:34 <copumpkin> okay
18:56:49 <kmc> shlevy, Haskell is a good imperative language
18:56:53 <kmc> shlevy, but I think C is still more appropriate here
18:56:58 <shlevy> xplat: Any reason why?
18:56:59 <kmc> especially since you're new to Haskell
18:57:13 <adamvh> shlevy: http://www.galois.com/~dons/talks/semicolon.pdf
18:57:24 <shlevy> adamvh: Thanks, I'll check it out
18:58:05 <shlevy> kmc: Yeah, I know I can use it imperatively but if I'm going to do that I might as well use C. If there's a more functional way to do it, though, I'd rather do it that way.
18:58:17 <kmc> shlevy, that's totally not true
18:59:08 <kmc> Haskell has many advantages over C
18:59:15 * ddarius thought copumpkin was his agent via edwardk, but he doesn't really remember how it went.
18:59:20 <kmc> which don't all go away if you're writing imperative code
18:59:28 <copumpkin> ddarius: mutual (circular?) agent-ship?
18:59:46 <shlevy> kmc: Sorry, I didn't mean to say "if the problem is imperative you should use C", what I meant was: the reason I'm learning Haskell is to learn functional style of programming, and I don't want to let myself approach problems imperatively in Haskell until I've got a good grasp of solving problems funcitionally
18:59:51 <adu> kmc: fascinating
19:00:20 <kmc> shlevy, oh, that makes sense
19:00:30 <xplat> shlevy: you might find gaps in the library bindings for what you're doing, which means you'd have to mess with the FFI; it's harder to get haskell to use something like dietlibc than it is with C; a lot of things must be done out-of-process anyway; all the people who are really knowledgeable about writing inits tend to do it in C because of tradition so there would be fewer people to ask
19:01:23 <kmc> shlevy, these "paradigms" are a bullshit idea anyway
19:01:38 <kmc> good languages let you use the best techniques from each "paradigm" together
19:01:43 <xplat> the main advantage of using haskell is it would be easier to set up a robust dependency-based planner for making sure everything's done in the right order
19:01:44 <copumpkin> who the fuck spells paradime as paradigm anyway
19:01:51 <copumpkin> (another reason they're bullshit)
19:02:11 <xplat> who the fuck spells pair o' dimes as paradimes?
19:02:15 <shlevy> xplat: Can you explain "dependency-based planner" in a better way?
19:02:19 <shlevy> Sorry
19:02:29 <shlevy> Not "better way", just a bit more detailed?
19:02:32 * copumpkin sees the light at the end of the tunnel for this interchange proof
19:02:33 <adu> i think "paradigm" means that which is not mixed up
19:02:45 <djahandarie> copumpkin, death by interchange proof?
19:03:05 <copumpkin> nah :)
19:03:12 <xplat> shlevy: okay, so say you are mounting a filesystem which is in an lvm volume which is in turn in a dm-crypt volume which is on an mdraid
19:03:33 <shlevy> xplat: Sounding close to reality here :D
19:03:47 <adu> shlevy: I think imperative Haskell is the best way of reasoning about C :)
19:03:59 <xplat> shlevy: if it's always in just that order, you can come up with some phases and hardcode the sequence
19:04:49 <xplat> but what if someone wants to crypt inside the individual lvm volumes instead?
19:05:02 <ivanm> *sigh* looks like my plans to re-implement "dot -Tcanon" are unfeasible :(
19:06:02 <xplat> then you'll try to uncrypt the volumes before the vg is activated and your boot will fail
19:06:04 <copumpkin> yay
19:06:06 <copumpkin> I haz interchange
19:06:24 <shlevy> xplat: Ok, following so far.
19:06:46 <copumpkin> so I can compose my NTs in two directions and swap them, and also both compositions are associative and have identity
19:06:53 <copumpkin> I think that's most of what I want to say in this module
19:07:08 <xplat> so really what you want to do is have some way to adapt the boot sequence to what depends on what.  either when building the initramfs or maybe even dynamically at boot time.
19:07:58 <xplat> it's a lot easier to do THAT kind of thing in haskell than C
19:08:34 <shlevy> xplat: Ah, ok. Makes sense, thanks
19:11:01 <shlevy> Now a somewhat more general question: For those who came to Haskell from imperative/OO languages: How long did it take for you to be able to look at a problem and see the functional solution as easily as you can see the imperative solution? What resources did you use/projects did you undertake to get there?
19:11:20 <ivanm> shlevy: I found the functional approach much more intuitive
19:11:28 <ivanm> and picked it up almost immediately
19:11:55 <ivanm> I had done some scheme beforehand, but that was about 3 years before that IIRC
19:11:57 <copumpkin> yay! it typechecks
19:11:59 * copumpkin commits
19:12:48 <djahandarie> copumpkin, that's all anyone else is going to do with it, so no problem with committing it ;)
19:12:58 <djahandarie> Does anyone actually run Agda code? :P
19:13:00 <copumpkin> nope
19:13:09 <copumpkin> https://github.com/pumpkin/categories/blob/master/Category/NaturalTransformation.agda
19:13:14 * copumpkin beams
19:13:16 <shlevy> ivanm: Interesting. It's still too early to tell (haven't actually written anything on my own yet), but while functional programming appeals to me more theoretically I'm worried I'll get stuck in a "do this, then that, then that" mindset
19:13:27 <djahandarie> copumpkin, scary
19:13:34 <copumpkin> the module structure (and having to import a crapload of stuff for each proof) is still a mess, but I'll clean that up later
19:13:41 <ivanm> I see FP-style programming as "pipelining": transform the data this way, and then this way
19:13:44 <xplat> copumpkin: so, ready to attack functors again, or going to do some more training first?
19:14:15 <copumpkin> xplat: I'm scared of attempting the heterogeneous stuff cause it might change everything (if I'm lucky it won't, though)
19:14:44 <xplat> copumpkin: i just can't see why the heterogenous stuff would be necessary
19:15:18 <xplat> maybe if i understood John Major equality better i would, though
19:16:02 <shlevy> ivanm: Interesting. That approach might help, thanks.
19:16:08 <ivanm> np
19:17:10 <xplat> shlevy: i found it a lot easier to understand functional programming after i'd gotten good at SQL
19:17:23 <djahandarie> copumpkin, I feel like I don't understand this record syntax well enough
19:17:31 <copumpkin> which part of it?
19:17:44 <djahandarie> What it does. :P
19:17:53 <shlevy> xplat: Huh, interesting. Any idea what it was about SQL that made it click for you?
19:18:10 <dolio> Raw agda files?
19:18:24 * ivanm wonders if he should just give in and write proper library bindings to Graphviz
19:18:46 <copumpkin> xplat: equality of functors F and G would mean (possibly) forall (f : A -> B). F f == G f. so F f : F A -> F B and G f : G A -> G B, so I can't compare those directly
19:18:49 <djahandarie> Raw, hardcore, 18+ only Agda.
19:19:04 <copumpkin> dolio: I've never generated HTML
19:19:14 <copumpkin> also feels weird to commit it to a repository
19:19:44 <dolio> Yes, it's a bad idea to do version control on agda html.
19:19:53 <xplat> shlevy: SQL is also abstracted from 'do this, then do that'.  not totally, but on the individual statement level.  and a statement in SQL can do a lot.
19:20:00 <Chaze> @pl  (\a b -> a:b:[])
19:20:00 <lambdabot> (. return) . (:)
19:20:26 <Chaze> :t (. return) . (:)
19:20:26 <lambdabot> forall a. a -> a -> [a]
19:20:32 <Chaze> :t (.) . (:)
19:20:32 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
19:20:49 <xplat> so going from sequences of tiny queries to large, complex queries is sort of a slider from imperative to functional
19:21:41 <xplat> or imperative to declarative, anyway, which is more important since that's the direct contrast
19:22:44 <shlevy> xplat: Ah, ok. What would you say the contrast to functional is?
19:24:13 <sbahra> Cale: Ping?
19:24:15 <xplat> nonfunctional?  :)
19:24:44 <shlevy> :D No functions allowed
19:24:50 <dibblego> dysfunctional truly is the only contrast
19:24:50 <sbahra> copumpkin: Is Cale still the person to talk to re:lambdabot?
19:24:56 <shlevy> I guess the closest would be Java
19:24:59 <copumpkin> yeah
19:25:07 <dibblego> shlevy: http://functionaljava.org/
19:25:33 <shlevy> dibblego: I should have specified: idiomatic Java
19:25:38 <Gracenotes> FORTRAN 77. no recursion allowed. AMAZING
19:25:47 <dibblego> shlevy: what you call idiomatic, I call dysfunctional
19:26:54 <adamvh> Gracenotes: yeah, FORTRAN 77 is about as unfunctional as you can get
19:27:10 <adamvh> Fortran 90's got kina-sorta first class functions though
19:27:12 <Gracenotes> languages are functional to the degree they have traits which are functional.
19:27:13 <adamvh> believe it or not
19:27:44 <dibblego> all 51 of Java's operators are functional, as are all the libraries mentioned in the language specification
19:27:48 <adamvh> (or maybe it's 95/2003, but anyway)
19:28:13 <Gracenotes> opposite is.. non-existence of those traits? I suppose you could conflate that with mutually exclusive traits occurring in other models, but, not everything has an opposite
19:28:22 <Gracenotes> *unique
19:37:21 <shlevy> Thanks for the help everyone. 
19:38:32 <augur> regarding the universal mapping property, when we say that a monoid homomorphism f has an underlying function |f|, does this mean that f-qua-arrow corresponds to some function over the underlying elements?
19:42:35 <dmwit> augur: yes
19:46:34 <nanothief> I was attempting to write an instance of Monoid for StateT s m a. I came up with this definition: http://hpaste.org/44207/undecidable_instances_with_mon . While it appears to work as expected, it requires undecidable instances to compile. Is this a problem that could come back to bite me?
19:47:36 <nanothief> I get why it is classed as undecidable (same number of type variables in assertion and the head), but I don't understand what is so "undecidable" about that
19:47:44 <jmcarthur> nanothief: http://hpaste.org/paste/44207/undecidable_instances_with_mon#p44208
19:48:05 <jmcarthur> as for your actual questions
19:48:09 <jmcarthur> *question...
19:48:12 <kmc> nanothief, the question is whether class resolution will always terminate
19:48:29 <kmc> there are by default some conservative rules that ensure it always will
19:48:48 <jmcarthur> nanothief: basically, the constraint solver isn't very amazing and has some rules that potentially rule out some valid constraints
19:49:57 <nanothief> I see, so the rules guarantee that there are no loops in the type checker, but it also blocks some always-terminating types
19:50:06 <jmcarthur> nanothief: if you write that instance and your code using it happens to compile, it shouldn't introduce any runtime bugs
19:50:33 <jmcarthur> nanothief: right. this extension just means that the type checker might get stuck in a loop
19:51:11 <jmcarthur> nanothief: anyway, as my annotation to your paste shows, in this case you don't actually need undecidable instances
19:51:23 <jmcarthur> my constraints aren't complete btw
19:51:33 <jmcarthur> probably need Monad m at least
19:51:53 <augur> ok time to out
19:52:07 <nanothief> jmcarthur: yeah, I'm trying out your definition with my existing code, looks a lot cleaner than my def
19:52:36 <jmcarthur> nanothief: it's not the same semantics, btw
19:53:13 <jmcarthur> nanothief: yours uses a Monoid instance on the inner monad. mine uses a Monoid instance on the type parameter
19:53:44 <jmcarthur> nanothief: so if you were actually needed the semantics that your instance implemented, mine unfortunately won't work for you
19:53:49 <jmcarthur> *needing
19:54:47 <nanothief> yeah, I think I'll stick with my original definition then
19:54:54 <jmcarthur> i can't think of any cases right now where they aren't equivalent, actually, but that doesn't mean they are equivalent.
19:55:09 <jmcarthur> okay i guess i can
19:55:17 <jmcarthur> if m ~ [], for example
19:55:28 <nanothief> exactly the case I have :P
19:55:57 <jmcarthur> @instances Alternative
19:55:58 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
19:56:05 <nanothief> thanks though for the explaination of undecidable instances though
19:56:05 <jmcarthur> @instances-importing Control.Applicative Alternative
19:56:06 <lambdabot> Either e, ErrorT e m, Maybe, ReaderT r m, StateT s m, WrappedMonad m, WriterT w m, []
19:56:18 <nanothief> jmcarthur: my definition is identical to MonadPlus
19:56:23 <jmcarthur> nanothief: it might be more sensible to use Alternative or MonadPlus instead of Monoid
19:58:22 <nanothief> yeah, I will think about using MonadPlus in this case then. Anyway, thanks for the explaination of undecidable instances, it has always been a bit of a mystery to me
19:58:34 <foofy> Stupid question: how do I prevent Haskell from printing out floats using Scientific notation (i.e, 5.34234e-2)?
19:58:41 <jmcarthur> nanothief: in fact, according to lambdabot, StateT already has an alternative instance, and may have a MonadPlus instance :)
19:58:49 <jmcarthur> @instances MonadPlus
19:58:50 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
19:58:53 <jmcarthur> hey hey!
19:59:24 <nanothief> I got the definition of mempty and mappend straight from the source code of MonadPlus :P
19:59:36 <jmcarthur> ha
20:05:36 <CompleteNab> Might this be a place to search for help concerning C++ and Graphics?
20:07:13 <jmcarthur> CompleteNab: sorry, this channel is about the haskell programming language
20:07:22 <CompleteNab> Okay, thanks
20:08:25 <copumpkin> I wonder how people end up in here
20:08:35 <Adamant> probably just new to IRC
20:10:34 <rothwell> i think #c++ probably told them to try #haskell, sarcastically
20:11:15 <djahandarie> copumpkin, I think Google turns up a webchat to this room for "programming chat"
20:11:17 <shachaf> Maybe going by the biggest-channel list.
20:11:30 <djahandarie> copumpkin, or at least it used to before the +s flag... I don't think it does anymore
20:11:34 <copumpkin> I see
20:11:56 <shachaf> Ha, Google: "Haskell Chat Rooms - Chat with singles in your area now!"
20:12:19 <djahandarie> hi any1 here single & looking??
20:13:10 * ivanm comes into the channel and instantly goes "wtf?!?!?"
20:13:41 <djahandarie> I have brown eyes, dark hair, and mad haxing skills...
20:14:00 <djahandarie> Enjoy long SSH sessions...
20:29:35 <djahandarie> I apparently killed the hell out of this room with that.
20:29:46 <augur> hello then.
20:30:07 <djahandarie> Hello!
20:30:23 <augur> djahandarie: whats your name come from
20:30:39 <copumpkin> his name comes from his name, I think
20:30:45 <djahandarie> My nick comes from my name, Darius Jahandarie. My name is Iranian.
20:31:18 <djahandarie> Darius means something like "great adventurer" or something, I don't remember exactly. :P
20:31:44 <c_wraith> :t (fmap (fmap ?f) ?xs)
20:31:45 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?f::a -> b, Functor f, ?xs::f1 (f a), Functor f1) => f1 (f b)
20:32:00 <c_wraith> :t fmap fmap fmap ?f ?xs
20:32:01 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1, ?f::a -> b, ?xs::f (f1 a)) => f (f1 b)
20:32:18 <augur> i think it means father of xerxes :P
20:32:29 <augur> i think http://tunes.org/wiki/induction_20and_20co-induction.html is wrong
20:38:50 <Adamant> I thought he was DJ ahandarie at first. which is almost as awesome.
20:39:10 <Adamant> (says not an 80's singer)
20:40:17 * copumpkin is tempted to tell dibblego something about tool support and haskell
20:40:37 <dibblego> RAR!
20:40:45 <augur> copumpkin: im so lost about the distinction between data and codata/recursion and corecursion
20:40:46 <augur> :\
20:40:47 <copumpkin> I didn't do it!
20:40:57 <copumpkin> augur: data needs a base case
20:41:02 <copumpkin> or rather, recursion does
20:41:07 <copumpkin> data must be finite
20:41:07 <augur> ok
20:41:11 <augur> i dont get that tho.
20:41:15 <augur> why must data be finite
20:41:17 <copumpkin> data has constructors, codata has destructors
20:41:22 <copumpkin> or "observers"
20:41:31 <augur> i dont follow
20:41:52 <augur> whats a destructor/observer
20:42:11 <copumpkin> something like uncons
20:42:18 <copumpkin> Stream a -> (a, Stream a)
20:42:18 <augur> er?
20:42:50 <copumpkin> it lets you take the data apart to look at it
20:42:55 <copumpkin> you can't construct it directly
20:42:58 <augur> erm
20:42:59 <copumpkin> by data I mean codata
20:43:09 <augur> you mean accessors?
20:43:11 <augur> head/tail?
20:43:22 <copumpkin> yeah, sure
20:43:30 <augur> but then isnt List both data and codata?
20:43:34 <copumpkin> haskell'
20:43:37 <copumpkin> s list is codata
20:43:43 <augur> how is it not data?
20:43:46 <augur> it has constructors!
20:43:50 <augur> and it can be finite!
20:44:00 <copumpkin> it's potentially infinite
20:44:05 <augur> its also potentially finite!
20:44:08 <dmwit> augur: I think I can help.
20:44:11 <dmwit> augur: You need to take a step back.
20:44:23 <augur> ok
20:44:29 <dmwit> augur: Have you heard of least fixed points and greatest fixed points?
20:44:39 <augur> ive heard the words :P
20:44:46 <dmwit> augur: We start out with a function F. F takes pieces of information, and constructs new pieces of information.
20:45:05 <augur> ok
20:45:13 <augur> example?
20:45:46 <dmwit> For example, let's take F(S) = {zero} U {succ(x) | x <- S}.
20:46:04 <augur> ok
20:46:05 <dmwit> It's the simplest interesting function F.
20:46:22 <dmwit> Now, there are sets S that are *fixed points* of F.
20:46:29 <dmwit> That is, there are sets S such that F(S) = S.
20:46:44 <augur> sure
20:46:53 <dmwit> One of these is the usual one -- the set of natural numbers.
20:47:07 <augur> ok
20:47:26 <dmwit> Another more exotic one has the natural numbers, plus (say) one infinite number -- that is, a value that's just an infinite stream of "succ"s.
20:47:32 <dmwit> Good so far?
20:47:41 <augur> sure
20:47:46 <dmwit> There may be other fixed points, too.
20:47:52 <dmwit> But there are two especially interesting fixed points.
20:48:15 <dmwit> The least fixed point X is the one such that any other fixed point Y has X \subset Y.
20:48:32 <augur> ok
20:48:36 <dmwit> It turns out that the set of natural numbers has this property. (You should think about how to prove this.)
20:49:00 <dmwit> The greatest fixed point X has the opposite property: any other fixed point Y has X \superset Y.
20:49:19 <augur> i see
20:49:33 <dmwit> So, for example, we know that the infinite stream of "succ"s is definitely in the greatest fixed point, since it's in some fixed point.
20:50:02 <dmwit> Okay. With that background, data and codata are easy: data are the values in a least fixed point of one of these functions, and codata are the values in a greatest fixed point.
20:50:39 <augur> i see. so data is necessarily finite, codata is not necessarily finite
20:50:50 <dmwit> My mental model of how to tell the difference is: a thing is "data" if it has a finite reason for being so, and a thing is "codata" if there's no finite reason for it not to be.
20:50:58 <dmwit> Yes, exactly.
20:51:31 <dmwit> copumpkin: Feel free to chime in and correct me when I say wrong things. I'm sure it will happen eventually. =P
20:51:37 <augur> ok, so the constructor/destructor thing is somewhat irrelevant
20:51:41 <copumpkin> dmwit: dude you know way more about this stuff than I do :P
20:51:57 <monochrom> it has already happend, but morally not a big deal
20:52:28 <dmwit> Well, I'm not sure that the constructor/destructor thing is irrelevant.
20:52:37 <dmwit> But I will admit that I don't fully understand the relationship there.
20:53:43 <dmwit> monochrom: Even if not for augur, but for me, I'd love for you to chime in and say what was wrong...
20:54:08 <kmc> anyone here used the "Diff" package?
20:54:43 <monochrom> firstly in the setting of set theory there is no greatest fixed point, unless you first designate a set U and declare you just want the largest subset G of U satisfying F(G)=G.
20:55:04 <augur> dmwit: codata can still have always-terminating functions defined over it tho
20:55:04 * hackagebot hmatrix-mmap 0.0.5 - Memory map Vector from disk into memory efficiently  http://hackage.haskell.org/package/hmatrix-mmap-0.0.5 (AlanFalloon)
20:55:13 <monochrom> secondly least fixed point does not always guarantee "finite data only". it depends on F.
20:55:15 <dmwit> augur: Oh, definitely.
20:55:30 <dmwit> Ah. Both great points.
20:55:37 <augur> ok.
20:55:41 <dmwit> Infinite data might be a base case. =P
20:56:09 <augur> dmwit: was that to me or to monochrom?
20:56:28 * monochrom has the greatest fixed points
20:56:35 <dmwit> It was in response to monochrom's second correction.
20:56:39 <augur> ok
20:57:36 <augur> and recursive doesnt entail data
20:57:47 <augur> since fold is recursive not corecursive but applies to codata
20:59:30 <augur> dmwit: the ump is very confusing :\
20:59:59 <dmwit> It's a bit surprising the first few times you see it, yeah.
21:00:05 <dmwit> Like most math. =)
21:00:05 <augur> its not that
21:00:13 <augur> its that i dont understand how the pieces relate to one another
21:03:34 <augur> dmwit, monochrom: do either of you know if (mutually) inductively definable data is equivalent to Type 0 languages?
21:04:31 <dmwit> Hm. It sounds plausible.
21:05:30 <dmwit> I would guess that inductive data (as we think of it in Haskell) is basically context-free, in fact.
21:05:46 <augur> haskell minus parametric types is
21:05:55 <augur> with parametric its at least partially CS
21:06:11 <copumpkin> augur: it might help to look at other universal things
21:06:14 <copumpkin> and find the common theme
21:06:20 <augur> copumpkin: how do you mean
21:06:32 <copumpkin> CT is full of universal properties
21:06:49 <dmwit> augur: Just learn about universal cones and specialize to the particular cone you're interested in. ;-)
21:07:11 <augur> ya what
21:07:15 <dmwit> augur: Less facetiously, have you seen the way category theoreticians define products?
21:07:17 <augur> universal cones? D:
21:07:36 <augur> im not sure about products. lets say no, just in case
21:07:42 <dmwit> Cool.
21:08:07 <dmwit> ...do you know what a category is? (Just thought I'd check.)
21:08:28 <augur> im on p26 of awodey's CT book, so i'd better know by now :p
21:08:30 <ivanm> OK, can someone with more C-fu than myself help me work out where exactly Graphviz defines how it does its canonical output stuff?
21:08:44 <dmwit> Okay. =P
21:09:17 <dmwit> So, yeah, given two objects A and B, a product of A and B is an object C and arrows pi_1 : C -> A and pi_2 : C -> B with the "universal" property.
21:10:07 <dmwit> The "universal" property says that for any *other* object D with arrows f : D -> A and g : D -> B, there's a unique arrow h : D -> C making everything commute.
21:10:23 <dmwit> Where "everything" means h;pi_1 = f and h;pi_2 = g.
21:10:25 <rwbarton> copumpkin: cool
21:10:41 <rwbarton> did you use the setoid equality on functors we were discussing?
21:10:43 <copumpkin> rwbarton: it's up on github :) still haven't resolved what to do about functors though
21:10:51 <augur> wait wait hold on lemme read this
21:10:52 <dmwit> Now, why does that definition correspond to the one we know and love from set theory?
21:10:58 <dmwit> yep, ok
21:11:04 <kmc> copumpkin, is there an active Agda channel?
21:11:07 <copumpkin> rwbarton: not yet, it got ugly to even make an equivalence relation
21:11:09 <kmc> where would i go to become more leet with agda
21:11:15 <copumpkin> kmc: #agda , yep
21:11:18 <copumpkin> it's pretty quiet
21:11:18 <kmc> (haskell is too mainstream now)
21:11:21 <copumpkin> lol
21:11:26 <kmc> i used to lurk #agda long ago
21:11:46 <copumpkin> it livens up when someone starts talking about stuff and others are awake
21:12:09 <copumpkin> rwbarton: haven't decided yet what I want to do about functors, so I just went on and worked out natural transformations
21:12:23 <copumpkin> but they seemed to work out okay
21:12:32 <rwbarton> I think you can't make functors into a category, right
21:12:50 <copumpkin> I can definitely do it with the natural isomorphism thing I had before
21:12:58 <copumpkin> whether I want that or not is another question
21:13:14 <rwbarton> well, maybe you can by encoding the setoid relation as morphisms in the category
21:13:17 <copumpkin> I can also make functors the object of a category with what I just constructed
21:13:22 <rwbarton> I think that's painful though
21:13:36 <copumpkin> https://github.com/pumpkin/categories/blob/master/Category/NaturalTransformation.agda
21:13:43 <copumpkin> that's what I have right now for NTs
21:13:47 <augur> dmwit: ok
21:13:55 <dmwit> augur: Drawing the commuting diagram will help immensely. I just can't do it via IRC. =(
21:14:08 <augur> i was drawing it in my head :p
21:14:13 <Pseudonym> @free naturalTransformation :: F a -> G a
21:14:13 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
21:14:37 <copumpkin> augur: basically it's saying the product is uniquely determined by its projections. so x = (fst x, snd x)
21:14:59 <copumpkin> well, fully determined
21:17:45 <augur> sure
21:23:23 <Chaze> what's an easy way to "(a -> b) -> [a] -> [(a,b)]"
21:24:09 <monochrom> \f xs -> zip xs (f xs)
21:24:28 <augur> dont you mean map f xs
21:24:30 <Chaze> map f xs
21:24:31 <Chaze> yeah
21:24:36 <monochrom> oops
21:24:41 <augur> <3
21:24:52 <Chaze> @pl \f xs -> zip xs (map f xs)
21:24:52 <lambdabot> ap zip . map
21:25:06 <augur> what the
21:25:20 <augur> @src ap
21:25:20 <lambdabot> ap = liftM2 id
21:25:31 <augur> @src liftM2
21:25:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:25:56 <aleator> List monad has confusion inducing properties :)
21:26:27 <copumpkin> :t map . (arr id &&&)
21:26:27 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
21:26:30 <augur> er.. oh, liftM2 f = \xs ys -> xs >>= \x -> ys >>= \y -> return $ f x y
21:26:32 <augur> right, ok
21:26:51 <augur> liftM2 just lifts a binary function into the monads of its arguments
21:26:53 <augur> ok
21:33:12 * hackagebot hmatrix-nipals 0.2 - NIPALS method for Principal Components Analysis on large data-sets.  http://hackage.haskell.org/package/hmatrix-nipals-0.2 (AlanFalloon)
21:34:45 <kmc> nipples?
21:35:35 <prsteele> is the a mechanism to name a group of types without defining new constructors for them? For example, if I have types A, B, and C, I want to define types D = (A or B) and E = (B or C)
21:36:51 <djahandarie> :t map . runState . gets
21:36:52 <lambdabot> forall a a1. (a -> a1) -> [a] -> [(a1, a)]
21:36:58 <djahandarie> Mo' nads!
21:37:22 <dibblego> prsteele: Data.Either
21:37:38 <mzero>  oh - that is a clever way to get a function I always want
21:37:39 <dibblego> there is also the data keyword 
21:38:05 <mzero> :t (\f -> map (\x -> (f x, x)))
21:38:05 <lambdabot> forall a t. (a -> t) -> [a] -> [(t, a)]
21:39:57 <prsteele> dibblego: if I use 'data', though, the constructors have to be unique. I might be using the wrong language, but given data types A, B, and C, (data A = ..., data B = ..., data C = ...) I want to specify 'f :: (A or B) -> ...', without defining some 'data D = A | B'
21:40:11 <copumpkin> prsteele: you want polymorphic variants I think
21:40:14 <copumpkin> and no we don't have them
21:40:30 <copumpkin> they basically give you subtyping of some sort
21:41:03 <prsteele> copumpking: hm. I probably need to re-think what I'm doing then. Probably an easier way.
21:41:10 <copumpkin> there usually is
21:41:18 <copumpkin> ocaml does have them though, so you're not alone in wanting them
21:41:25 <copumpkin> anything subtypey tends to not be inferrable though
21:41:34 <copumpkin> which is often a concern in haskell type system features
21:41:48 <prsteele> copumpkin: I can see how that would cause problems
21:42:10 <djahandarie> Anything not-exactly-what-Haskell-has tends to cause problems for Haskell's type system
21:43:00 <djahandarie> s/system/inference/
21:43:22 <Chaze> @pl (\f (a,b) (c,d) -> (c, f b d))
21:43:23 <lambdabot> (. snd) . flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (,))) .)
22:07:24 <solrize> anyone know why cabal install gets old versions of stuff?  i'm still on ghc 6.12, is that way out of date by now?
22:07:41 <kmc> Haskell Platform for GHC 7 hasn't come out yet, i think
22:07:52 <solrize> maybe i need cabal update, trying that
22:08:03 <kmc> so in a sense GHC 6.12 is the latest version for "end-users"
22:08:37 <solrize> oh ok, just needed cabal update, it's not like git where it checks the repo
22:08:45 <solrize> thanks
22:11:58 <c_wraith> dons was suggesting the next version of the haskell platform is due in two weeks or so
22:12:36 <Chaze> i guess this is where lift comes in: i need to multiply Int with (Maybe Int), and want a Maybe
22:12:46 <Chaze> how do I lift (*) to the Maybe Monad?
22:12:47 <kmc> :t fmap (2*)
22:12:47 <lambdabot> forall t (f :: * -> *). (Num t, Functor f) => f t -> f t
22:12:55 <kmc> > fmap (2*) (Just 3)
22:12:55 <lambdabot>   Just 6
22:12:58 <kmc> > fmap (2*) Nothing
22:12:58 <lambdabot>   Nothing
22:13:08 <kmc> fmap = liftM, roughly speaking
22:13:16 <kmc> but this use requires only a Functor, not a full-fledged Monad
22:13:23 <dmwit> > do { x <- Just 3; return (2 * x) }
22:13:24 <lambdabot>   Just 6
22:13:30 <dmwit> > do { x <- Nothing; return (2 * x) }
22:13:30 <kmc> @src liftM
22:13:30 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:13:31 <lambdabot>   Nothing
22:16:32 <Chaze> it seems for my piece of code, liftM and fmap are interchangeable
22:17:31 <Chaze> i am utterly guessing here, but fmap for the ListMonad is simply a map?
22:19:22 <jmcarthur> except for cases where a type is only defined for Functor or only for Monad, liftM and fmap are in general interchangeable
22:19:34 <jmcarthur> and yes, fmap for lists is the same as map
22:19:46 <Pseudonym> And you're right, map should be the generic version.
22:22:19 <btutt> Ugh. Figuring out non-constant space uses is making my head hurt
22:23:00 <vegai> btutt: you use profiling, I guess?
22:24:04 <btutt> yeah. the graphs help, but if you need to look at Core dumps the pain multiplies
22:27:47 <btutt> http://hpaste.org/44209/nonconstant_space
22:28:26 <btutt> I'm using TagSoup, curl, and Data.Text to scarf in some web pages
22:29:51 <btutt> *notes the irony of how non-simple -ddump-simpl output is*
22:33:16 <btutt> Monadic expansion doesn't make it easy to read either of course.
22:36:40 <jmcarthur> btutt: i'm thinking that extractFurtherStories evaluates tags, but stories is holding on to it
22:38:11 <jmcarthur> it's not really "inlining" as your comment suggests though. it's just lazy evaluation
22:38:31 <btutt> oh, maybe if I make nextUri strict then
22:39:45 <jmcarthur> yeah, if you force that then you can remove the dependency on tags. i don't really know what nextUri is, but if it's just a simple value and not a huge list then that could be a win
22:40:00 <btutt> yeah, nextUri really is just a URL
22:40:12 <jmcarthur> cool, i bet that will fix it then
22:41:28 <jmcarthur> actually
22:41:30 <jmcarthur> won't help
22:41:36 <jmcarthur> stories holds on to it anyway
22:41:53 <jmcarthur> btutt: ^^
22:43:08 <btutt> ah yes
22:44:03 <jmcarthur> btutt: if i'm right, i have a different suggestion. the quick and easy version of it would be to leave nextUri unevaluated, use unsafeInterleaveIO on your use of extractFurtherStories, and return $ stories ++ furtherStories
22:44:09 <jmcarthur> hmm...
22:44:18 <jmcarthur> no, still won't help. just delays the problem
22:44:28 <jmcarthur> stories would evaluate tags and then further stories would hold on to it
22:44:33 <jmcarthur> *furtherStories
22:45:08 <Maxdamantus> Hmm .. have many projects tried to incorprate a runtime module loading/unloading system? What sort of interfaces would they use?
22:45:20 <kmc> in Haskell?
22:45:26 <Maxdamantus> Yes.
22:45:41 <btutt> yeah. I just got really lucky when nextUri/furtherStories are commented out to get constant space. Yay.
22:45:57 <Maxdamantus> A Haskell program that can load Haskell-written modules which may have been compiled since the start of the program.
22:45:59 <kmc> see: plugins, hint, mueval, direct-plugins, safe-plugins
22:46:05 <Maxdamantus> Mk.
22:46:06 <kmc> all of which are on hackage
22:46:23 <kmc> they use the GHC API, but wrap it into a more user-friendly form
22:47:46 <Jafet> Is there one that doesn't require a copy of ghc around?
22:48:08 <Jafet> I think that's closer to what max wants
22:48:52 <Maxdamantus> Dunno. I was just thinking of writing a really simple init/services system, but primarily for my laptop, so the runtime module system wouldn't be very important, just wondering.
22:48:57 <kmc> well, the "copy of GHC" is some library code linked into your binary
22:49:02 <kmc> like any other Haskell library
22:49:08 <Maxdamantus> (Since I don't care about rebooting it)
22:49:17 <kmc> Maxdamantus, you can also look at "dyre"
22:49:18 <luite> except htat it makes your binary about 20MB bigger:)
22:49:24 <kmc> if you want xmonad-style configuration by recompiling
22:49:31 <Maxdamantus> (I mostly just use it to attach to tmux via ssh from somewhere)
22:51:22 <Jafet> @hackage toilet
22:51:22 <lambdabot> http://hackage.haskell.org/package/toilet
22:51:26 <Jafet> wtf
22:51:45 <jmcarthur> heh. i remember when that was uploaded
22:51:49 <solrize> zz
22:52:24 <Maxdamantus> Yeah, one major advantage of just having everything integrated, without runtime modules wolud be that configuration is just like Xmonad, as in you just define your own main.
22:54:11 <solrize> @hoogle String -> [Word8]
22:54:12 <lambdabot> Prelude fail :: Monad m => String -> m a
22:54:12 <lambdabot> Control.Monad fail :: Monad m => String -> m a
22:54:12 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
23:09:24 <geheimdienst> @pl f (g x) x
23:09:24 <lambdabot> f (g x) x
23:24:59 <fabjan> lambdabot: hi
23:30:18 <btutt> Well, if a one pass approach doesn't get me constant space, I'll try a two pass approach. ;)
23:30:31 <btutt> Fetch uris first and then extract the data
23:36:59 <kmc> anyone implemented "patience diff" in Haskell?
23:37:00 <kmc> http://bramcohen.livejournal.com/73318.html
23:49:04 <mm_freak> is there a network library based on the 'iproute' package?
23:49:21 <mm_freak> dealing with handles or sockets (i'd prefer the former)
