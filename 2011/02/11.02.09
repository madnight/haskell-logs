00:00:15 <Axman6> > 5 ** 6
00:00:16 <lambdabot>   15625.0
00:00:20 <Axman6> > 5 ** 5
00:00:21 <lambdabot>   3125.0
00:01:08 <dancor> :t 5
00:01:09 <lambdabot> forall t. (Num t) => t
00:01:16 <dancor> :t 5 4
00:01:17 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
00:01:18 <dagle> so 5 ** 5 is 3125 but (id ** id) 5 is not? O_o
00:01:40 <Axman6> :t (id ** id) (const 5) 6
00:01:41 <lambdabot> forall t. (Floating t) => t
00:01:43 <shachaf> dagle: Sure it is.
00:01:54 <dagle> > (id ** id) 5
00:01:55 <lambdabot>   3124.999999999999
00:02:00 <shachaf> dagle: The 9s keep going in 3124.999...
00:02:04 <dancor> > 5 ** 5 == (id ** id) (const 5)
00:02:05 <lambdabot>   *Exception: (==): No overloading for function
00:02:26 <dagle> shachaf: Yes, but why does it give that answer?
00:02:42 <dagle> > (5 * 5  == (id ** id) 5)
00:02:43 <lambdabot>   False
00:02:51 <dagle> > (5 ** 5  == (id ** id) 5)
00:02:52 <lambdabot>   False
00:03:13 <dancor> > (5 + 5 == (id + id) 5)
00:03:14 <lambdabot>   True
00:03:33 <yitz> ok, what is the latest weird thing someone has done to lambdabot?
00:03:47 <dancor> :t (id + id) 5
00:03:47 <lambdabot> forall a. (Num a) => a
00:03:48 <yitz> a num instance for a->a or something?
00:03:50 <dancor> :t (id + id)
00:03:51 <lambdabot> forall a. (Num a) => a -> a
00:03:54 <dancor> it must be..
00:04:09 <shachaf> Latest?
00:04:13 <shachaf> This has been around for quite a while.
00:04:42 <yitz> lambdabot used to be useful
00:04:43 <dancor> > signum $ (id + id) 5
00:04:44 <lambdabot>   1
00:04:48 <dancor> > signum $ (id + id) (-5)
00:04:49 <lambdabot>   -1
00:05:18 <shachaf> > ((sqrt + 1)^2) 5
00:05:19 <lambdabot>   10.47213595499958
00:05:25 <joe6> i am using :set -i to use a module from a different directory. That module has a parseFromFile "./test.dat". Now, ghci says openFile: does not exist (No such file or directory)
00:05:34 <shachaf> dancor: That's the reason for the "const instance".
00:05:46 <joe6> it appears that though the module is imported the functions in that module get the current directory context
00:05:55 <dancor> > ('a':) + 4
00:05:56 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
00:05:56 <lambdabot>    arising from the literal ...
00:06:08 * shachaf enoughs.
00:06:12 <joe6> so, any openFile in the module have to be absolute directory and not relative directory. Does that make sense?
00:06:37 <dancor> must be: instance (Num a) => Num (a -> a) where ..
00:06:55 <dagle> :t log
00:06:56 <lambdabot> forall a. (Floating a) => a -> a
00:07:06 <dancor> > log + 4
00:07:07 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
00:07:07 <lambdabot>    arising from a use of `...
00:07:12 <yitz> @vixen so, when did you acquire a Num instance for functions?
00:07:12 <lambdabot> i am just a fun girl!
00:07:21 <dancor> a functional girl
00:07:27 <joe6> is there a way to make the module load a file irrespective of where the module is loaded from?
00:07:28 <dancor> or, now, dysfunctional
00:08:06 <dancor> joe6: maybe something insane with template haskell?
00:08:08 <yitz> joe6: where the module was loaded from does not affect open files
00:08:19 <joe6> yitz: it seems to be.
00:09:11 <dancor> joe6: couldn't you install the module you want to load as a library?
00:09:12 <yitz> joe6: it always interprets relative paths based on the current directory
00:09:12 <joe6> yitz: openFile: does not exist (No such file or directory) even though i can see that the .dat file exists in the module directory.
00:09:29 <yitz> joe6: it doesn't look in the module directory
00:09:46 <joe6> yitz: yes, that makes sense. Is there a way to make it look at the directory where it is located in?
00:09:50 <dancor> :t log + 4
00:09:51 <lambdabot> forall a. (Floating a) => a -> a
00:09:54 <yitz> joe6: it looks relative to the current directory in ghci
00:09:58 <dancor> > log + log
00:09:58 <joe6> dancor: sounds like a good idea. I should probably do that.
00:09:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
00:09:59 <lambdabot>    arising from a use of `...
00:10:16 <dancor> i think that's what installed libraries are really all about
00:10:39 <joe6> dancor: ok, i am off to search for how to install a library.
00:10:48 <yitz> joe6: no. the module should behave identically
00:10:58 <yitz> joe6: no matter where you load it from.
00:11:02 <yitz> that is a feature.
00:12:06 <joe6> yitz: oh, ok. so, anyone calling the module can have their own data files. makes sense. i need a library.
00:13:15 <dancor> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html
00:14:00 <dancor> tho i don't think you actually need a Setup.hs these days
00:14:42 <ddarius> yitz: That instance comes from the vector-space package.
00:15:29 <yitz> ddarius: why would i want that package in scope by default?
00:15:30 <dancor> ya i deleted Setup.lhs for a project of mine and cleaning and reinstalling still worked
00:16:14 <joe6> oh, i make the library and then install it to my .cabal directory using cabal install?
00:16:35 <joe6> all i need is teh .cabal file,then.
00:16:36 <ddarius> yitz: Who said that you wanted it??
00:16:46 <ddarius> And how did I end up with two question marks?
00:17:00 <dancor> idk why that manual doesn't mention that a Setup.hs is actually optional
00:17:23 <yitz> @vixen I don't want the vector-space package in scope. Please turn it off.
00:17:23 <lambdabot> i'm 19
00:17:31 <joe6> ok, anyway, those 2 files and i can do a cabal install?
00:17:38 <dancor> joe6: ya
00:17:52 <c_wraith> dancor: cabal sdist actually tells you Setup.hs is *not* optional
00:18:11 <dancor> c_wraith: ah.
00:18:30 <dancor> not optional for hackage
00:21:15 <joe6> user error (Using 'build-type: Custom' but there is no Setup.hs or 
00:21:21 <joe6> without the setup.hs
00:21:29 <joe6> anyway, it is just 2 more lines.
00:21:57 <dancor> maybe my install worked without Setup.hs bc i have build-type: Simple
00:22:13 * dancor exposed as ignorant
00:25:24 <ddarius> @ask edwardk What makes you think that we don't use unfoldr/destroy fusion?
00:25:24 <lambdabot> Consider it noted.
00:26:10 <joe6> dancor: where did you have that in the .cabal file?
00:27:10 <joe6> Unknown fields: build-type (line 12)
00:27:26 <joe6> that is what it said when I had that in the .cabal file?
00:29:22 <Saizan> joe6: e.g. http://hackage.haskell.org/packages/archive/syb-with-class/0.6.1.1/syb-with-class.cabal
00:31:00 <joe6> Saizan: are you Simon PJ?
00:34:50 <o^_^o> so guys...is anybody taking a haskell course here in school ?
00:34:52 <joe6> Saizan: thanks for that file.
00:34:59 <joe6> i think pastorn was.
00:35:03 <o^_^o> like either as a student or as a teacher
00:35:07 <o^_^o> ok...
00:35:11 <o^_^o> pastorn, ?
00:35:18 <joe6> he is very helpful too.
00:35:32 <joe6> and pretty knowledgeable
00:35:47 <o^_^o> thanks joe6 
00:36:04 <o^_^o> me and my friends are trying to learn haskell by ourselves and we need some homework problems and probably the course syllabus
00:36:26 <Zao> o^_^o: Have you've looked at RWH and LYAH?
00:36:37 <Zao> @where LYAH
00:36:37 <lambdabot> http://www.learnyouahaskell.com/
00:36:38 <Zao> @where RWH
00:36:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:36:38 <Axman6> o^_^o: i'll be tutoring one this semester
00:36:46 <o^_^o> Zao, yes
00:36:57 <o^_^o> Axman6, do you have the syllabus ?
00:37:32 <o^_^o> Zao, yes we have the books, but we lack structured learning like in school and I am also getting old :-(
00:37:42 <Axman6> if you're up for learning functors and monads more throughly, check out http://blog.tmorris.net/20-intermediate-haskell-exercises/
00:38:04 <cwb> We used Introduction to Functional Programming using Haskell at uni back in 2004/2005. That has exercises.
00:38:04 <o^_^o> Axman6, hmmm...
00:38:36 <Axman6> ah, i love Clem: http://cs.anu.edu.au/student/comp1100/lectures.php
00:39:07 <Axman6> seems he's taken down all the exercises though
00:39:13 <Axman6> and all the lectures
00:39:39 <o^_^o> ah... :-(
00:39:54 <cwb> Whether Bird will suit you or not I'm not sure.. Why are you learning Haskell?
00:40:40 <o^_^o> cwb, I just want to learn haskell...
00:40:55 <o^_^o> cwb, I am unable to give you a good enough reason
00:40:59 <o^_^o> it looks like fun
00:41:51 <joe6> i want to add in a data file to the library. How do I add that?
00:42:05 <joe6> it is not in haskell format, but a text file
00:42:11 <cwb> o^_^o, ok, no problem, I think you should of course.. :) Bird is somewhat academic and dry, but it it's pretty handholding and has exercises so might be worth checking out.
00:42:32 <joe6> what is Bird?
00:42:46 <medfly> hah, I thought this is #math and was like "wow... peopel discussing Haskell!"
00:42:56 <cwb> Otherwise, as Zao mentioned, LYAH is an easy going introduction.
00:43:00 <ddarius> medfly: #math would never be so interesting.
00:43:03 <medfly> I really need to pay more attention to which channel I'm on
00:43:16 <medfly> I have to say that I don't find #haskell interesting
00:43:24 <medfly> it always talks about stuff I don't understand
00:43:29 <o^_^o> blashphemy!
00:43:30 <medfly> #math is a little better
00:43:30 <ddarius> medfly: That's not in contradiction with what I said.
00:43:31 <cwb> Bird: http://www.amazon.co.uk/Introduction-Functional-Programming-Prentice-Hall-Computer/dp/0134843460/
00:43:37 <ddarius> Okay, the last part is.
00:43:48 <medfly> I totally helped this one guy. kick ass
00:44:20 * ddarius found #math to be basic linear algebra and calculus without application, i.e. boring as hell.  #not-math was better.
00:44:26 <o^_^o> 50 GBP !
00:44:30 <o^_^o> oh...well
00:45:09 <medfly> well... basic linear algebra and some calculus is all I know!
00:45:30 <medfly> people here are too smart for me
00:46:00 <medfly> although slowly it's improving. I used to find #math impossible almost all the time too :)
00:46:28 <cwb> o^_^o, yeah, ridiculous, I know. Library might have it, but I'm not sure it's worth it. Why are you not keen on LYAH?
00:46:46 <o^_^o> cwb, I like LYAH!
00:46:51 <medfly> if he is using it for a course he may not have a choice
00:47:12 <medfly> homework may be all "problem x,y,z on book"
00:47:13 <o^_^o> cwb, did I say anything about LAYH....
00:47:17 * o^_^o scrolls back
00:47:46 <o^_^o> cwb, I am using LYAH and the other bug book
00:47:55 <o^_^o> RWH
00:48:37 <pastorn> joe6: hello
00:49:18 <joe6> pastorn: hello
00:50:10 <o^_^o> pastorn, are you taking a course in haskell ?
00:50:16 <cwb> o^_^o, sorry, maybe I read to much into your replies. Ok, and you want a bit more structure and exercises?
00:50:24 <o^_^o> cwb, yes
00:50:54 <o^_^o> cwb, atleast if someone can tell me/us the exercises in RWH in some order it would be nice
00:52:08 <pastorn> o^_^o: not currently, wai?
00:52:29 <o^_^o> pastorn, do you have the syllabus and homework problems ?
00:52:46 <cwb> o^_^o, all my old tutorial sheets (exercises) refer to Bird so can't be of much help I'm afraid.
00:52:55 <o^_^o> cwb, it is ok!
00:53:22 <o^_^o> cwb, I can probably import Bird 
00:53:26 <pastorn> o^_^o: you don't take "no" for an answer, do you?
00:53:43 <o^_^o> pastorn, sorry, I didn't mean to impose
00:54:15 <pastorn> o^_^o: it's not that... read the log a bit more carefully :p
00:56:48 <o^_^o> pastorn, I haven't had my evening coffee yet...
00:56:59 <pastorn> o^_^o: hehe :)
00:57:04 <pastorn> so what do yuo want?
00:57:33 <pastorn> lab instructions for a haskell 101 course?
00:58:24 <o^_^o> pastorn, yes...please
00:58:50 <pastorn> http://www.cse.chalmers.se/edu/year/2010/course/TDA555/labs.html
00:59:22 <o^_^o> pastorn, waw...soooper
00:59:36 <ddarius> It's a trap!
01:00:14 <o^_^o> pastorn, which country are you in ?
01:00:20 <pastorn> sweden
01:00:31 <o^_^o> shipping beer maybe difficult
01:02:19 <pastorn> o^_^o: i'll have one of these; it will suffice: http://classicfun.ws/wp-content/uploads/internet-high-five-place-hand-here-right-480x444.jpg
01:03:07 <o^_^o> pastorn, a girl walking by saw me putting my hand on the monitor and probably thinks I am permanently deranged...
01:03:19 <o^_^o> also I was giggling
01:03:27 <ddarius> o^_^o: She's an astute judge of mental state.
01:03:28 <c_wraith> good grief, that's like high-fiving a 5 year old
01:03:32 <c_wraith> such a small hand
01:03:58 <o^_^o> ddarius, my stupid name in IRC is not helping my cause any
01:04:13 <o^_^o> c_wraith, yes...I thought that too
01:06:00 <Itkovian> Can anybody sched any light on the reason for the difference in these types? http://hpaste.org/43808/different_types
01:07:13 <ddarius> Itkovian: The monomorphism restriction and generalized defaulting.
01:07:32 <Itkovian> ddarius: thx
01:07:47 <c_wraith> It's like the different between :t 1  and let x = 1    :t 1
01:07:55 <c_wraith> err, that last one should be :t x
01:09:22 <Saizan> joe6: heh, no
01:11:12 <ddarius> Attempting to join #not-not-math sent me to #math.  Freakin' Boole.
01:11:13 <_mpu> I heard of a combinators library to create io channels between several parallel computation units, what can it be ?
01:11:39 <_mpu> I can't remember the name
01:11:41 <Axman6> @remember ddarius Attempting to join #not-not-math sent me to #math.  Freakin' Boole.
01:11:41 <lambdabot> Okay.
01:11:46 <Axman6> @flush
01:11:46 <lambdabot> Not enough privileges
01:11:49 <Axman6> :(
01:15:13 <Saizan> _mpu: CHP maybe?
01:49:23 <Wooga> how do i combine two enumerators into one; in iteratee-0.7.0.0 package?
01:54:24 <taotree> How do I create a NaN Float ?
01:54:35 <quicksilver> > (1/0) / (1/0) :: Float
01:54:36 <lambdabot>   NaN
01:54:42 <quicksilver> not sure if there is a better way ;)
01:55:01 <ddarius> > 0/0
01:55:02 <lambdabot>   NaN
01:56:32 <merijn> Question for the people more versed in type theory then me, what's your opinion of the speakers/topics at the Oregon PL summer school? (http://lists.seas.upenn.edu/pipermail/types-announce/2011/002241.html) I'm considering applying but being a poor student it costs a significant amount of money, so I'd rather be sure it'd actually be worth it.
01:57:44 <NihilistDandy> Quick question about cabal, if anyone's around
01:58:32 <ddarius> merijn: I don't know about how well they present, but most of those are pretty big names.  For fuck's sake, there's Dana Scott.
01:59:13 <quicksilver> merijn: there are some excellent researchers on that list and at least some of them are also excellent presenters.
01:59:35 <quicksilver> also, as ddarius says, some pretty famous people.
02:00:33 <ddarius> merijn: I would say the main thing you'd have to worry about is preparing yourself to make the most of it.
02:01:24 <merijn> ddarius: That was one of the things I was interested in, I only recently started looking into type theory so I'm mostly familiar with old names (and Conor McBride whose papers are now my nemesises...)
02:02:40 <ddarius> Unless by "old names" you mean Frege, certainly Scott, Pfenning, and Harper have been around for a -long- time.
02:03:38 <merijn> ddarius: Perhaps, but not in the papers *I've* been reading about type theory :p
02:04:30 <ddarius> merijn: Pfenning in particular, is an awesome resource.  I recommend his home/publications page.
02:07:11 <quicksilver> Pfenning's publications page is a stretch in the space-time continuum.
02:07:28 <quicksilver> it's clearly not possible for anyone to publish that much without having a local distortion to take advantage of.
02:07:54 <merijn> quicksilver: So, sort of Gauss like phenomena? :p
02:08:28 <merijn> Anyway, they claim its aimed at 1st/2nd year grad students with "knowledge about programming languages at the level provided by an undergrad survey course", so I hope that I'm reasonably ready with the PL stuff I learned so far and the type theory I've been reading up on.
02:10:12 <kfr> PL = ?
02:10:35 <merijn> kfr: Programming Language
02:10:47 <kfr> Oh :|
02:13:53 <joe6> getDataFileName "test.dat" 
02:13:59 <joe6> cabal "Data-Files" seems broken. Any thoughts, please? error when I try to use the function opening the datafile: "openFile: does not exist (No such file or directory)", function that opens the data file: 
02:14:04 <joe6> getDataFileName "test.dat" 
02:15:48 <Saizan> after you've installed the package?
02:15:49 <joe6> is there anything I can check to debug such occurrence?
02:16:05 <joe6> Saizan: yes, I did cabal install in the dir.
02:16:12 <joe6> do i have to do anything more?
02:16:19 <Saizan> no
02:16:31 <Saizan> you could check what getDataFileName "test.dat" returns
02:16:40 <joe6> ok, thanks. will do.
02:17:26 <joe6> I probably will have to import the Paths_.. to where I am using the library..
02:18:17 <joe6> no, that is not it.. it is a hidden module in the package 
02:18:31 <joe6> or, may be exposing it might help.
02:20:38 <joe6> should it be exposed? that does not make sense, then I would have to import both the library name and the Paths_.. when any function uses a datafile.
02:21:00 <Saizan> i don't understand your situation
02:21:52 <joe6> Saizan: i have a library that uses a data-file. It is actually more than one data-file. I have included the data-files in the .cabal file using "Data-File'
02:22:48 <joe6> and then changed the functions using the data-files to use getDataFileName as in: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
02:23:20 <joe6> and, then I added the Paths_<library> to the Other-modules of the .cabal file. cabal install builds and installs the package
02:23:38 <Saizan> ok
02:23:39 <joe6> When I use the function that uses a datafile somewhere else, i get the openFile error.
02:24:23 <joe6> That is the process, correct? The only catch is that data-file has more than 1 data-file and the others are in a different dir and I used ../<thatdir>/datafilename for such files.
02:25:02 <Saizan> you really used .. ?
02:25:20 <Saizan> anyhow, that's the correct process
02:25:56 <zmv> np: Nightwish - The Siren (live version)
02:25:58 <zmv> oops
02:25:59 <zmv> sorry
02:26:26 <zmv> muscle memory made me type "/np" instead of "/topic"
02:26:46 <Saizan> joe6: does the openFile error tell you which path it's trying to open? otherwise you could add a debug statement in your library
02:26:52 <joe6> Saizan: yes, anyway just created symlinks and removed the directory path for the datafiles
02:27:18 <joe6> Saizan: that is a good idea. will add the debug statement.
02:29:18 <Wooga> how do i combine enumerators from iteratee-0.7.0.0 package?
02:29:49 <freiksenet> is there any work on extending HM unification so that it supports "or" constraints, so constraints from which only one has to be true at the same time?
02:30:12 <joe6> Saizan: no, even the symlinks did not work. will try the debug statement next.
02:30:15 <freiksenet> s/at the same time/ so that typing is valid
02:30:28 <HugoDaniel> Not in scope: data constructor `State'  --> why is this happening when i try to install the "encoding" pkg in ghc 7 ?
02:30:55 <Saizan> HugoDaniel: my guess is that it doesn't support mtl-2
02:31:04 <HugoDaniel> oh
02:31:09 <HugoDaniel> mtl again :/
02:31:26 <HugoDaniel> what can i do to solve this ?
02:31:44 <Saizan> try --constraint="mtl < 2"
02:32:57 <HugoDaniel> Overlapping instances for Monad (Either DecodingException)
02:33:01 <HugoDaniel> :/
02:33:16 <Saizan> heh
02:33:27 <HugoDaniel> i already sent an email to the maintainer
02:34:35 <Saizan> joe6: btw, that blog post you linked suggests to create your own Paths_foo module, have you done that? if so that could be your problem
02:37:19 <HugoDaniel> Connection.hsc:47:17: fatal error: sql.h: No such file or directory
02:37:22 <HugoDaniel> now is hdbc-odbc
02:37:25 <HugoDaniel> that is breaking
02:38:11 <Wooga> how do i combine enumerators in thus expression: run $ joinIM $ (enumPureNChunk [1..10] 5)  `whatTheCombineOperator?` (enumPureNChunk [11..20] 5) $ (Data.Iteratee.length)
02:38:14 <Wooga> ?
02:39:29 <Saizan> HugoDaniel: you've to install the needed C headers 
02:41:37 <Saizan> Wooga: how would you compose two functions a -> m a ?
02:41:44 <Saizan> Wooga: given Monad m
02:41:55 <joe6> Saizan: this is what it has: "./test.dat" *** Exception: ./test.dat: openFile: does not exist (No such file or directory)
02:41:58 <Wooga> Saizan: >>= ? but this don't work
02:42:12 <joe6> i changed the filename from "test.dat" to "./test.dat" just to be sure.
02:42:16 <dibblego> why does ghci read ~/.ghci before ./.ghci ?
02:43:04 <joe6> Saizan: getDataFileName "./test.dat" >>= >>= (\x -> trace (show x) (return x)) 
02:43:15 <joe6> Saizan: that was the debug statement that I added.
02:43:31 <Saizan> joe6: have you manually created Paths_<yourpackagename>.hs in your source tree?
02:43:35 <dibblego> oh wait, :set -fno-warn followed by :set -Wall moots the no-warn
02:43:40 <joe6> yes. as in the html file.
02:44:05 <joe6> http://neilmitchell.blogspot.com/2008/02/addi
02:44:06 <joe6> ng-data-files-using-cabal.html
02:44:07 <Saizan> joe6: then delete it 
02:44:12 <joe6> oh, ok.
02:44:58 <Saizan> joe6: it gets automatically generated by Cabal with the right paths during the installation, neil is suggesting to have that file only during developement
02:44:59 <banisterfiend> anyone know any good video paysites where i can watch a lot of good movies in high quality?
02:45:10 <Saizan> Wooga: almost
02:45:49 <Saizan> Wooga: you've to use \x -> f x >>= g
02:45:52 <joe6> Saizan: So, just curious, do I need to create the file everytime I tinker around with that library?
02:46:52 <Saizan> Wooga: which is the definition of (>=>) from Control.Monad
02:47:28 <joe6> Saizan: no luck. Should I get rid of the "import Paths_picUsbTesting" from the library file opening the datafile. That would not make sense, then. I think it should be there? Same error message about not opening the file.
02:47:44 <Saizan> joe6: it should be there, yes
02:47:51 <Wooga> Saizan: oh, thank you!
02:48:08 <Saizan> joe6: and you should use "test.dat", not "./test.dat"
02:48:24 <joe6> ok, thanks. will doe
02:48:29 <joe6> s/doe/do./
02:50:29 <zmv> joe6: hm, dvorak typo :)
02:53:19 <sroberts> hi all, I have some questions about reactive. I am trying to implement the following function: queue :: Double -> Event a -> Event a. The input events queue up to get processed one by one. All events are processed in a constant amount of time. The output is the stream of events being released from the queue after being processed.
02:53:54 <sroberts> I don't think I really understand how to use reactive properly, or perhaps it is not really built for this task.
02:57:24 <sroberts> (btw, this is my first time on irc, and I am not sure of the best way to paste code to the channel)
02:57:49 <Wooga> solarus: use pastebins
02:58:05 <Wooga> http://codepad.org/ or http://paste.pocoo.org/ for example
02:58:19 <Wooga> oh
02:58:21 <Wooga> i mean sroberts 
02:58:22 <Wooga> sorry
02:59:08 <ddarius> writeBS, no pussy-footing around there.
03:00:59 <sroberts>  
03:00:59 <sroberts> ERC> http://hpaste.org/43811/queue_function
03:00:59 <joe6> zmv: yes.
03:01:08 <sroberts> hope that works
03:01:18 <zmv> joe6: I see.
03:02:44 <Saizan> joe6: https://github.com/Saizan/test-data <- this is an example of using data-files that works for me
03:03:01 <sroberts> a few things I don't like about my queue function: it doesn't seem anywhere near as clear as the imperative description of a queue, and it performs really badly
03:03:32 <HugoDaniel> i just got rid of the dependency i had for encoding, im now using the Data.ByteString.UTF8
03:03:40 <HugoDaniel> i still have to properly test this though
03:04:34 * frerich (not being a native speaker) wonders what "pussy-footing" could be, but doesn't dare to fantasize too much.
03:04:48 <opqdonut> pussy-footing means treading carefully
03:05:49 <dafis> where eagles dare
03:08:52 <joe6> Saizan: http://pastebin.com/vh6MZ3mz http://pastebin.com/wDeg5E0C http://pastebin.com/XsJQbrAW . this is what i have. oh, just noticed your link, will check it.
03:12:18 <merijn> frerich: pussy-footing is saying "Your implementation of this algorithm might slightly sub-optimal" instead of "Holy $@*&, your implementation is freaking crap and your an idiot for trying to do it this way!" :p
03:13:49 <Wooga> i am missing someone telling me about my mistakes in second way :P
03:14:53 <merijn> Wooga: Main reason I hang around in #python a lot, lots of regulars who'll yell at me for doing stupid things :p
03:15:57 <Wooga> yeah, same thing you may encounter at #bash, especialy for useless use of cat (UUOC) or ls | grep things
03:17:05 <merijn> #bash has...other issues. Mostly concerning whether "@$^$(@&(%@$**)" looks like readable code or not :p
03:17:22 <Wooga> thats more about perl or sed
03:17:33 <Wooga> imo
03:17:38 <zmv> I always do "ls | grep" :P
03:18:02 <kfr> What's next, cat ... | grep? :[
03:18:25 <merijn> I sense fans of cat-v.org :p
03:18:37 <kfr> HugoDaniel hmm why do you use Data.ByteString.UTF8 over Data.Text?
03:19:04 <accel> @src newIORef
03:19:05 <lambdabot> newIORef v = stToIO (newSTRef v) >>= \ var -> return (IORef var)
03:19:10 <accel> :t newIORef
03:19:11 <lambdabot> Not in scope: `newIORef'
03:19:12 <zmv> I like cat-v.org
03:19:19 <accel> what's the type of newIORef ?
03:19:47 <HugoDaniel> kfr, im not familiar with Data.Text, and i need proper iso8859-1 to utf8 encoding/decoding... im not sure if i can get it with either
03:19:49 <merijn> Speaking of which, I need an encyclopedia to find whether there is already a unix tool which does what I need since I expect most of the stuff I do is already covered by existing tools :p
03:20:55 <tab> HugoDaniel: you can have it through text and text-icu
03:21:36 <accel> how do I convert a Double to a FLoat ?
03:21:51 <accel> or rathern, a Double to a GLfloat ?
03:21:52 <tab> HugoDaniel: although converting iso8859-1 is absolutely trivial, since unicode has first characters maps liked iso8859-1
03:22:03 <Saizan> joe6: it works here, maybe you need to run cabal clean and then cabal install again, to make sure it's using the generated Paths module
03:22:06 <merijn> @hoogle Double -> GLfloat
03:22:06 <lambdabot> Warning: Unknown type GLfloat
03:22:06 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:22:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:22:12 <quicksilver> merijn: realToFrac
03:22:24 <HugoDaniel> tab, i know, but for some strange reason i can't get proper encoding/decoding from a msql database :(
03:22:45 <HugoDaniel> maybe m$ doesn't use iso8859-1 but something "compatible"... you know, like the IE6 approach
03:23:58 <tab> HugoDaniel: on windows, isn't everything utf16 ?
03:24:39 <Zao> HugoDaniel: You should be able to query the DB for what the default encoding is.
03:24:46 <Zao> And probably set it per connection.
03:25:21 <Zao> If it's a narrow one, it's probably 1252 or UTF-8.
03:26:13 <HugoDaniel> thanks
03:26:16 <accel> merijn , quicksilver : realToFrac worked -- thanks
03:26:17 <HugoDaniel> im going through odbc
03:26:42 <HugoDaniel> ill check on that
03:29:15 <accel> given a Rect x y z
03:29:21 <accel> how do I extract the xyz components?
03:29:31 <opqdonut> use pattern matching
03:29:38 <accel> can I break it apart in a let?
03:29:41 <opqdonut> yes
03:29:48 <accel> how so?
03:29:55 <opqdonut> like this: let Rect x y z = rect in x+y+z
03:30:06 <Wooga> is there any unified way of combining all possible combinations of (a -> m b) and (a -> b m (a))  functions with single operator?
03:30:08 <opqdonut> where rect is the thing given
03:30:24 <accel> opqdonut: trying it; thanks
03:30:27 <Wooga> (given (Monad m))
03:30:31 <opqdonut> Wooga: a -> b m (a)??
03:30:41 <Wooga> opqdonut: type Enumeratee sFrom sTo m a = Iteratee sTo m a -> Iteratee sFrom m (Iteratee sTo m a)
03:30:45 <mux> there's a kind error in this type signature
03:30:52 <accel> let CameraState angle = state
03:30:59 <accel> Not in scope: data constructor "CameraState"
03:31:06 <accel> however, I have a "import CameraState" at the top of my file
03:31:17 <accel> and CameraState.hs has:
03:31:19 <accel> module CameraState(CameraState) where
03:31:34 <dafis> accel: that is the tyoe without constructors
03:31:35 <opqdonut> accel: needs to be CameraState(CameraState(..)) 
03:31:38 <quicksilver> accel: that exports the type but not the constructor.
03:31:40 <opqdonut> to export all constructors
03:31:54 <quicksilver> module CameraState(CameraState(CameraState))) 
03:32:13 <quicksilver> (yo dawg?)
03:32:14 <opqdonut> or that :)
03:32:17 <opqdonut> indeed
03:32:26 <accel> dafis , opqdonut , quicksilver : works now; thanks
03:34:56 <Wooga> well, i thought Iteratee sTo m a == 'a' and Iteratee  sFrom 
03:35:14 <Wooga> * and Iteratee sFrom m a == 'b'
03:36:46 <Wooga> myabe a -> b m (c) would be right?
03:37:06 * Wooga needs a human-level compiler
03:41:41 <accel> does haskell offer optimized Vec3 and Quaternion? (both using Double)
03:46:06 * hackagebot monad-control 0.2 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.2 (BasVanDijk)
03:48:56 <accel> how do I export all defs of a module without listing them 1 by 1
03:49:00 <accel> module CameraState(..) where
03:49:02 <accel> gives me a compile error
03:49:14 <accel> parse error on input '..'
03:49:18 <dafis> accel: module Thing (module Thing) where
03:49:39 <jix> isn't that the default behaviour without export list too?
03:49:40 <dafis> exports all top-level bindings
03:49:52 <dafis> jix: yes, that too
03:50:07 <accel> so just "module CameraState where" ?
03:50:12 <jix> yeah
03:50:16 <accel> noted; thanks
03:50:50 <dafis> accel: but if you want to re-export some imported entities, you have to use the export list
03:51:18 <dafis> accel: module Thing (module Thing, import1, import2) where
04:04:49 <joe6> Saizan: ok, thanks. I wanted to check if that is a library issue or something. Thanks, will do cabal clean and then install again.
04:06:50 <joe6> Saizan: Thanks for your help. cabal clean did the trick. Sorry for the bother.
04:06:53 <ManateeLazyCat> Hi, all.
04:08:41 <Jonno_FTW> hello
04:10:47 <jaspervdj> zenzike: https://github.com/jaspervdj/hakyll/commit/9e07d1ba364ca401cc1c6f5704023b1df1006779
04:12:31 <accel> does haskell provide optimized Vec3 / Quat ?
04:12:47 <augur> hello you beautiful people you
04:14:33 <banisterfiend> ManateeLazyCat: are you really chinese
04:14:50 <ManateeLazyCat> banisterfiend: Yes
04:15:56 <companion_cube> http://haskell.pastebin.com/nBGqFJJj could anyone help me to improve the style of this, please?
04:17:40 <Bynbo7> looks pretty good to me, in terms of code style anyway. i didn't check the parsers too closely
04:18:07 <companion_cube> thanks :)
04:19:16 <Bynbo7> readTrail looks like it could be done with sequence or something, but maybe not
04:19:30 <Bynbo7> it has the feel of sequence anyway
04:20:16 <accel> is there a more elegant way of wrigint this? : http://hpaste.org/43812/accel
04:21:51 <companion_cube> Bynbo7, the point is I don't know how to make it stop when 0 is parsed
04:21:58 <accel> also, is there a more elegant way of writing this: http://hpaste.org/43813/accel .. I feel like the get followed by a writeIORef must be a common pattern
04:22:04 <Bynbo7> companion_cube: yeah, me either =)
04:22:36 <Bynbo7> yes, drop the $!
04:24:34 <augur> anyone know of any techniques to turn non-recursively defined propositions into recursively defined ones?
04:25:53 <quicksilver> accel: it's weird to mix get and writeIORef
04:26:11 <quicksilver> accel: the natural pairs are get/$= and readIORef/writeIORef
04:26:22 <dafis> companion_cube: many nonzeroInt; where nonzeroInt = try (do { i <- int; when (i == 0) parsecZero; return i; })
04:26:32 <pacak> Suppose i have lazy function f :: FilePath -> IO [Item], how can i make lazy  f' :: [FilePath] -> IO [Item]? f' = concat `fmap` mapM f eats a lot of memory, while f runs in constant space
04:26:45 <accel> quicksilver: ah; thanks
04:26:47 <companion_cube> thanks dafis 
04:26:52 <dafis> pacak: unsafeInterleaveIO
04:26:58 <quicksilver> accel: in each case there is a 'modifier' version: $~ and modifyIORef
04:27:20 <quicksilver> accel: I would write that as camera_state $~ (\cs -> update cs 0.1)
04:27:35 <quicksilver> accel: or, possibly, camerat_state $~ flip update 0.1
04:27:41 <quicksilver> but I've never liked flip.
04:27:56 <accel> quicksilver: not a big fan of point free style?
04:28:19 <quicksilver> not an excessive fan.
04:28:33 <quicksilver> I find reading chains of flips a higher cognitive load
04:28:43 <quicksilver> although one flip along is OK; I just find that subjectively ugly.
04:28:59 <quicksilver> lambda notation is really quite clear, compared to many alternatives.
04:29:12 <mm_freak> what was the record field pattern matching syntax again?
04:29:25 <accel> :t $~
04:29:26 <lambdabot> parse error on input `$~'
04:29:34 <accel> :t ($~)
04:29:34 <lambdabot> Not in scope: `$~'
04:29:41 <accel> :t modifyIORef
04:29:42 <lambdabot> Not in scope: `modifyIORef'
04:29:46 <accel> #src modifyIORef
04:29:52 <accel> @src modifyIORef
04:29:52 <lambdabot> modifyIORef ref f = writeIORef ref . f =<< readIORef ref
04:30:52 <pacak> dafis: Where exactly should I put it?
04:31:42 <yitz> accel: i don't think pointfree for it's own sake is good.
04:32:08 <dafis> @src mapM
04:32:08 <lambdabot> mapM f as = sequence (map f as)
04:32:08 <Bynbo7> i completely agree
04:32:29 <Bynbo7> if making the code pointfree makes it more difficult to parse, you've failed
04:32:31 <yitz> accel: but when you can factor a calculation into a series of steps composed one after the other, in combinator style, it makes code much easier to read and maintain
04:32:42 <dafis> pacak: I think, mapM (unsafeInterleaveIO f)
04:32:49 <yitz> accel: that happens to be point free. but not all point free is combinator style.
04:33:25 <yitz> provided that each step makes sense and is readable, of course
04:33:57 <accel> yitz: that I believe
04:34:02 <accel> if teh data flow ends up being linear
04:34:09 <yitz> i agree with quicksilver that more than one flip in a given step disqualifies it
04:34:10 <accel> then yeah, it's elegant / cool to not have all the lambads lying around
04:34:28 <accel> is there a one line way to write this? ( think involving >>= ?) 
04:34:29 <accel>   cs <- get camera_state 
04:34:29 <yitz> i also avoid slices of (.)
04:34:29 <accel>   CameraState.use cs
04:34:39 <accel> I want to make my code look like as if i'km not a haskell newb
04:35:20 <yitz> accel: if you're trying to impress someone, than make it as geeky and unreadable as you can
04:35:24 <dafis> accel: get camera_state >>= CameraState.use
04:35:29 <accel> dafis: thanks
04:35:55 <pacak> dafis: It works as concat <$> unsafeInterleaveIO (mapM (unsafeInterleaveIO . f))
04:36:24 <pacak> dafis: Thanks :)
04:36:29 <dafis> pacak: aha, I never remember how many unsafeInterleaveIO's are necessary
04:36:49 <accel> does Haskell ahve an optimized Vec3, or am I supposed to rolll my own?
04:37:02 <Bynbo7> optimised how?
04:37:08 <accel> as in packed + using SSE
04:37:08 <zenzike> jaspervdj, nice one, thanks :-)
04:37:16 <Y_Less> Why?  What's more important - elegant/cool code you need to sit down with a paper to work out or less elegant code you can actually read (or, more importantly, other people can read)?
04:37:29 <Bynbo7> no, there's (currently) no access to SSE instructions etc in GHC
04:37:40 <accel> Y_Less: code that's readalbe, of course, but preferably idiomatic
04:37:51 <Bynbo7> Y_Less: or you have to read r months later
04:37:53 <Bynbo7> 6*
04:37:54 <accel> http://hackage.haskell.org/packages/archive/applicative-numbers/0.0.2/doc/html/Data-Numeric-Vec.html#t:Vec3 <-- is that the best Vec3 ?
04:39:15 <Bynbo7> if you need good speed, that will not be a good implementation
04:39:36 <accel> i want good speed
04:47:08 <accel> is v+ an invalid function name?
04:47:26 <hpc> accel: no, it mixes symbols and letters
04:47:27 <Bynbo7> yes
04:47:30 <Bynbo7> no?
04:47:32 <hpc> er, yes
04:47:34 <accel> http://hpaste.org/43814/accel <-- help me debug / optimize this
04:47:35 <Bynbo7> yes :P
04:47:36 <hpc> it's invalid
04:47:44 * hpc misread
04:47:54 <accel> http://hpaste.org/paste/43814/accel_annotation#p43815
04:47:56 <quicksilver> dafis: you need an unsafeInterleaveIO at each point that you want execution to be (able to) stop.
04:48:00 <accel> fixed that, now what shoudl I do to optimize it?
04:48:38 <accel> http://hpaste.org/paste/43814/accel_annotation#p43816
04:48:42 <accel> okay, that's better
04:48:59 <accel> how do I mark the x y z fields as strict?
04:49:01 <quicksilver> you can't improve the algorithm.
04:49:06 <quicksilver> you could make the fields strict
04:49:16 <quicksilver> and you could use a pattern match to make it look nicer
04:49:32 <Bynbo7> ok, accel: data Vec3 = Vec3 {-# UNPACK #-} !Double {-# UNPACK #-} !Double {-# UNPACK #-} !Double, (.+) :: Vec3 -> Vec3 -> Vec3; (Vec3 a b c) .+ (Vec3 x y z) = Vec3 (a+x) (b+y) (c+z)
04:49:51 <accel> whoa
04:49:52 <quicksilver> v_add (Vec3 x0 y0 z0) (Vec3 x1 y1 z1) = Vec3 (x0+x1) (y0+y1) (z0+z1) is how I would write it.
04:49:55 <accel> mind = blown
04:50:00 <accel> you can define functions like that?
04:50:12 <quicksilver> that's what pattern matching is.
04:50:21 <quicksilver> f (Just x) = x+1
04:50:22 <quicksilver> etc.
04:50:40 <Bynbo7> accel: ... this is extremely basic stuff man :\
04:50:48 <dafis> accel: you should think about {-# UNPACK #-} pragmas for the fields (maybe the optimiser will unpack them on its own, you'd have to check)
04:50:49 <Bynbo7> this is the bread and butter of haskell programming
04:50:59 <accel> Bynbo7: I'm an extremem n00b, man :\
04:51:12 <hpc> accel: have you gone through learn you a haskell yet?
04:51:23 <accel> nah; i'm trying to write an MMORPG
04:51:29 <Bynbo7> accel: and this is why i keep telling you to learn the basics of haskell, like all n00bs are supposed to
04:51:35 * hpc suggests that before coming here; we assume knowledge you probably don't have
04:52:05 <hpc> and writing an mmo in a language you don't know, all by yourself?
04:52:07 <hpc> bad idea
04:52:16 <hpc> every step is a disaster waiting to happen
04:52:24 <accel> whatcould possibly go wrong
04:52:51 <hpc> accel: first you have to learn haskell, then the graphics libs (they are not fun to learn)
04:52:53 <accel> http://hpaste.org/43817/accel <-- cool anything else I should do to this?
04:52:59 <hpc> then you have to actually make an MMO
04:53:02 <accel> hpc: I have GLSl shaders working arleady
04:53:04 <hpc> which is really damn hard
04:53:09 <dagle> disaster :: Code -> Either Learning Worse
04:53:11 <accel> i've worked on a MMO before; just not in ashkell
04:53:41 <accel> @src +
04:53:41 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:53:44 <Bynbo7> follow the advice of HLint there
04:53:44 <accel> :t +
04:53:45 <lambdabot> parse error on input `+'
04:53:51 <dagle> :t (+)
04:53:52 <lambdabot> forall a. (Num a) => a -> a -> a
04:53:52 <hpc> :t (+)
04:53:53 <lambdabot> forall a. (Num a) => a -> a -> a
04:53:56 <dafis> accel: you want to do thecalculations with Doubles and then let OpenGL render it per GLfloats?
04:54:00 <accel> whoa, HLint
04:54:02 <xplat> well, it helps that you already know about one of the two things you absolutely must know about to proceed, but :)
04:54:21 <accel> dafis: yeah; for physics sims, I don't trust floats
04:54:50 <accel> collision detection + LCP solving kinda dwarfs rendering
04:55:26 <hpc> @src GLFloat
04:55:26 <lambdabot> Source not found.
04:55:42 <accel> :t Add
04:55:44 <lambdabot> Not in scope: data constructor `Add'
04:55:48 <accel> @src Add
04:55:49 <lambdabot> Source not found.
04:56:06 <hpc> `type GLFloat = Double' iirc
04:56:36 <accel> given "mul" can only have one type, is it impossible to ahve a "mul" taht works for both: Vec3 -> Double -> Vec3 & Double -> Vec3 -> Vec3 ?
04:56:48 <accel> it seems kinda silly to ahve two muls, depending on the order
04:56:57 <xplat> accel: if you're as smart as you think you are you should be able to blow through RWH or LYAH in a week, two tops, and get back to what you're doing.  if you're not as smart as you think you are, you have no chance jumping in and doing this ...
04:57:27 <hpc> not to mention, blowing through lyah and rwh is going to be necessary anyway
04:57:55 <zygoloid> accel: it's certainly possible. the one type for 'mul' would need to be big enough to contain Vec3 -> Double -> Vec3 and Double -> Vec3 -> Vec3 though
04:58:13 <Bynbo7> xplat: I've been telling him things like this for the last two weeks, the guy won't listen
04:58:22 <Bynbo7> I'm just going to stop trying to help
04:58:48 <dafis> accel: Be careful which version of OpenGL you use. In the early versions, GLfloat was a type synonym for Float, with optimisations, that gives a fast conversion. Later it became a newtype wrapper, but there were no rewrite rules for conversions, so what realToFrac gives you is (fromRational . toRational); with the rather naive implementations of toRational and fromRational, that produces awesomely slow code. I don't know whether rew
04:58:48 <dafis> rite rules have been added now, if not, wave performancegood bye with the newer OpenGLs.
04:58:55 <accel> #haskell is so helpful; and I find I learn best by tackling projects (i.e. when I'm forced to meet a problem IRL, then suddenly it amtters, and I start reading up on how to resolve it)
05:00:18 <xplat> the thing that bothers some people here is that even though you're tackling problems irl you are NOT appearing to read up on them
05:00:27 <zygoloid> #haskell is great, but it shouldn't be your only resource
05:00:57 <hpc> not to mention, asking #haskell basic stuff will make us annoyed
05:01:06 <hpc> since you don't seem to know basic stuff...
05:01:09 <hpc> go read lyah and rwh
05:02:34 <quicksilver> dafis: well, in some situations simply changing your code to use GLFloat everywhere works fine
05:02:52 <quicksilver> dafis: but if you're interface with an external library which uses a different type then you do have to be a little careful, yes.
05:03:24 <quicksilver> dafis: having said that, the VBO calls don't actually care what type of data you stuff in the VBO so you're free to put Float (not GLFloat) into your VBOs if you know they are the same.
05:04:28 <dafis> quicksilver: yes, but while GLfloat is a newtype wrapper around CFloat (which is a newtype wrapper around Float), not having rewrite rules is pretty darned stupid IMO
05:04:44 <quicksilver> sure.
05:04:51 <quicksilver> patches welcome? ;)
05:04:53 <dafis> (analogous for GLdouble, of course)
05:05:17 <quicksilver> I'm not sure it's as big a problem as you're suggesting, since any serious volume of Float data should certainly be in buffer objects anyway
05:05:32 <quicksilver> not passed direct to single calls expecting GLFloat (that sounds like immediate mode)
05:06:15 <accel> quicksilver++
05:06:32 <dafis> quicksilver: http://www.haskell.org/pipermail/beginners/2010-September/005349.html
05:07:02 <quicksilver> dafis: yes. Immediate mode.
05:07:12 <quicksilver> dafis: that code was always going to be stupidly slow.
05:07:23 <dafis> quicksilver: what's immediate mode?
05:07:27 <quicksilver> immediate mode became "non-preferred" 10 years ago and deprecated 4 years ago
05:07:58 <quicksilver> GL.renderPrimitive/GL.vertex is immediate mode
05:08:20 <quicksilver> I wouldn't be surprised if the overhead of using immediate mode far outweighs the cost of those painful realToFracs, in fact.
05:09:56 <dafis> quicksilver: I know nothing about graphics, but for that code (I take your word that it is bad), achieving a sane conversion brought a huge speedup. 
05:16:40 <mm_freak> in a pattern match how can i say that all fields should be in scope with some name?
05:16:59 <mm_freak> val@(Type {}) doesn't work
05:17:03 <mm_freak> but there was a way to do it
05:18:14 <Bynbo7> well using record puns will make for less typing, but you still need to list them all
05:18:40 <mm_freak> ah, RecordWildCards
05:18:43 <mm_freak> cool
05:18:50 <mm_freak> val@(Type {..})
05:18:58 <Bynbo7> ah nice :)
05:20:13 <Johan> bye
05:21:00 <quicksilver> mm_freak: FWIW, I don't think that is nice, because I hate the idea of shadowing things under different types.
05:21:35 <xplat> Wooga: >.
05:21:46 <mm_freak> quicksilver: yes, but my type has lots of fields and i just want to manipulate a few of them in a very trivial function
05:21:53 <xplat> or did somebody already say that?
05:22:09 <mm_freak> one final question:  limit = maybe id max tableMinLimit . maybe id min tableMaxLimit $ limit'
05:22:23 <mm_freak> maybe someone has a more elegant way to write this
05:26:25 <xplat> what does that even do?  (it doesn't do any of the things i would have thought based on the name ...)
05:27:03 <xplat> (it doesn't even look like it should compile if the types of the other symbols are anything i thought they might be)
05:27:41 <quicksilver> well, tableMinLimit is either "Nothing" or "Just 5" depending if there is a min limit
05:27:57 <quicksilver> if it's Nothing, that maybe evaluates to 'id' which does.. nothing.
05:28:08 <xplat> oh, i get it now
05:28:12 <quicksilver> if it's Just 5, it evaluates to the (partially applied) (max 5)
05:28:23 <quicksilver> I don't think there is a better way of writing it, really.
05:28:38 <quicksilver> although I do wonder if mm_freak is writing a poker server ;)
05:29:34 <mm_freak> quicksilver: no, it's "table" as in <table> =)
05:29:42 <mm_freak> i'm writing a table view library for yesod
05:29:57 <quicksilver> there's more money in poker servers.
05:29:58 <mm_freak> and yes, i dropped RecordWildCards in favor of mentioning the fields explicitly
05:30:06 <mm_freak> all in all it makes the code easier to read
05:31:02 <accel> @src setUniform
05:31:02 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:31:08 <accel> my, lambdabot is useless
05:31:29 <quicksilver> accel: @src is useless, yes.
05:31:34 <quicksilver> I recommend no one uses it, ever.
05:31:46 <xplat> nah, you don't want to write a poker server without a 'sponsor' to keep the (other) mafia off you
05:31:46 <accel> quicksilver: are you saarcastic? I can't tell
05:31:47 <quicksilver> in fact I recommend it's removed from lambdabot.
05:31:51 <quicksilver> accel: nope.
05:32:00 <accel> quicksilver: it's nice for things in prelude
05:32:04 <quicksilver> no it's not.
05:32:05 <accel> but it oens't seem to ahve any of the packages I use loaded
05:32:20 <accel> quicksilver: why not?
05:32:32 <quicksilver> it is a hand-maintained, occasionally incorrect, selection of definitions (although it's not really incorrect any more - the problems were mostly fixed)
05:32:41 <quicksilver> and it stands in the way of learning the proper tools.
05:32:50 <quicksilver> all the library source is online, indexed, and browsable
05:32:55 <quicksilver> and that's a much more useful tool than @src
05:33:07 <accel> quicksilver: hmm, I don't know the proper tools
05:33:09 <accel> what are they?
05:33:11 <quicksilver> right.
05:33:15 <accel> (peanut gallery: plese don't say RWH)
05:33:18 <quicksilver> and @src stood in your way.
05:33:28 <accel> alright, now that I'm not using src
05:33:30 <xplat> yes.  if @src consulted hackage it might be useful, but as it is ...
05:33:32 <accel> what are the higher level tools?
05:33:45 <quicksilver> accel: no need to use derogatory terms about the rest of the channel
05:33:52 <quicksilver> let's focus on helpinf people with haskell.
05:34:02 <accel> sure
05:34:06 <accel> what is the right tool?
05:34:10 <quicksilver> well http://www.haskell.org/ghc/docs/latest/html/libraries/ is a good starting place
05:34:19 <quicksilver> for all the bits that come with GHC 
05:34:25 <accel> is there something local + searcahble?
05:34:27 <quicksilver> full docs and full source.
05:34:38 <quicksilver> you can arrange for haddock to run locally
05:34:43 <quicksilver> on all your locally installed packages
05:34:55 <accel> quicksilver: that would be ideal
05:34:58 <accel> to have all the right versions and the such
05:35:10 <xplat> and if you browse any package on hackagge, the docs for each module have a link to the source
05:35:11 <accel> how do I do this?
05:36:31 * hackagebot Pathfinder 0.5 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.5 (GeorgeGiorgidze)
05:37:22 <yitz> accel: cabal install haddock, then there's a flag to cabal install that tells it to create haddocks when you install something
05:37:32 * hackagebot DSH 0.4.3 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.4.3 (GeorgeGiorgidze)
05:37:40 <accel> yitz: hmm, so I need all my apckges to be installved via cabal; rathern than apt-get ?
05:37:58 <quicksilver> there is a ghc-docs package isn't there?
05:38:01 <yitz> accel: but to be honest i never bothered with that. it's easier to read the source directly from the hackage site when you need them.
05:38:53 <yitz> accel: perhaps there are debian packages that install the source for modules that you install via apt
05:39:12 <yitz> accel: or you can just download a package without installing it and run haddock on it
05:39:14 <accel> installign cabal now
05:40:06 <yitz> accel: again, i find it easiest just to read the source on hackage. and on the ghc site as quicksilver pointed out.
05:41:15 <accel> yeah; but I often code on my water proof laptop
05:41:20 <accel> while canoying down the amazon
05:41:24 <accel> without satellite internet
05:41:42 <quicksilver> I code on the laptop sometimes, and find it annoying.
05:41:46 <accel> shit, haddock requires base ==4.3 and ghc >= 7.0
05:41:51 <quicksilver> The haskell platform comes with docs.
05:42:01 <accel> argh
05:42:05 <accel> so install the haskell platform binaries
05:42:09 <accel> and rip out ubuntu's ghc 6.12 ?
05:42:22 <quicksilver> well, I would hope ubuntu has a ghc-docs package
05:42:28 <quicksilver> which should provide the basic docs
05:42:37 <accel> apt-cache search ghc-docs
05:42:37 <quicksilver> if it doesn't, that's an ubuntu bug I woudl say
05:42:38 <accel> brings up nothing
05:42:42 <quicksilver> hmm
05:43:03 <accel> eh; whatever, let me build from source
05:43:20 <accel> oh wait; I think I need to eanble the universe packages
05:43:30 <quicksilver> ghc-doc, according to a quick google
05:43:32 <quicksilver> (no 's')
05:43:44 <quicksilver> or ghc6-doc
05:43:48 <quicksilver> sources differ....
05:44:22 <xplat> ghc6-doc
05:45:10 <accel> got it
05:45:11 <accel> thanks
05:45:40 <accel> quicksilver: where do you work that lets you spend all this time on haskell?
05:45:54 <accel> so ghc6-doc is a bunch of html files
05:46:05 <accel> do I have to use a browser, or is there some commandline way to search for stuff?
05:46:21 <dafis> accel: grep
05:46:29 <quicksilver> I don't spend much time at all on haskell, accel.
05:46:39 <quicksilver> mostly train journeys to/from work.
05:47:39 <dagle> I also used to do that. But I always fell asleep.
05:47:58 <xplat> it's nice to be able to take trains to places.  cars are a little quicker, but you can't do much to reclaim the time.
05:48:51 <xplat> so trains are effectively faster even though they're actually slower
05:49:19 <dagle> Or 2 hours late.
05:49:31 <xplat> (or they're just faster period, if you're going far enough and there's an express train)
05:50:10 <dagle> This xmas my friend went by a train that was 14 hours late... XD
05:50:13 <accel> err, not in the US
05:50:16 <accel> what countires are you guys in?
05:51:39 <quicksilver> my train is certainly faster than driving would be.
05:51:45 <quicksilver> driving to central London is a fool's errand.
05:51:48 <accel> quicksilver: are you in japan?
05:51:55 <accel> oh, london
05:57:26 <accel> is there a tool via Haddock that provids the following
05:57:32 <accel> I type in a function name, like postRedisplay
05:57:37 <accel> then it lists all HTML files that documents this function?
05:57:45 <accel> I'd prefer this to grep, which just does dumb text string matching
05:57:52 <aristid> accel: hoogle?
05:58:17 <accel> hmm; can anything local?
05:59:27 <aristid> you can install hoogle locally
06:00:21 <aristid> it contains a HTTP server
06:00:30 <aristid> and a command line tool
06:00:31 <accel> err, can it run locally
06:00:36 <accel> or does it require google to run?
06:00:42 <aristid> what?
06:00:56 <accel> does running hoogle
06:00:58 <kfr> accel: Hoogle does not use Google
06:01:00 <accel> require quirying extrnal services
06:01:00 <kfr> At all
06:01:05 <kfr> No
06:01:26 <accel> alright, cool; @hoogle  @src
06:01:26 <zygoloid> hoogle-the-command-line-tool queries a local database built by haddock
06:01:32 <accel> let's see how to install this locally
06:02:53 <badkins> I have a couple types, tuples, that differ only in one having an additional String:
06:02:54 <badkins> type Driver  = (String, String, (Int, Int, Int, Int, Int, Int, Int))
06:02:58 <badkins> type Vehicle = (String, String, String, (Int, Int, Int, Int, Int, Int, Int))
06:03:32 <merijn> badkins: Ugh, you should probably use record syntax
06:03:39 <badkins> Is there some way to make use of this similarity that I'm missing? I think I'll just have to add a String to Driver that is always empty to avoid having multiple selector functions to pull them out.
06:03:46 <Bynbo7> that's horrible :(
06:03:56 <badkins> merijn: well, I was trying to get away from my OO background :)
06:04:10 <badkins> brand new newbie here
06:04:15 <Bynbo7> records aren't really related to OO
06:04:27 <Bynbo7> they just give names to each field in a constructor
06:04:30 <merijn> badkins: Not to be mean, but you didn't really succeed if your data types look like that :p
06:04:39 <merijn> badkins: Which book/tutorial are you reading?
06:04:41 <badkins> they seem to be downplayed, at least the two books I have don't even describe them.
06:04:56 <badkins> merijn: I don't expect to "succeed" first time around :)
06:05:15 <badkins> "Programming in Haskell" and "The Craft of Functional Programming"
06:05:20 <merijn> badkins: Screw books, go read Learn You A Haskell first and then proceed to Real World Haskell
06:05:23 <merijn> @where lyah
06:05:23 <lambdabot> http://www.learnyouahaskell.com/
06:05:27 <merijn> @where rwh
06:05:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:05:38 <merijn> (RWH also has a print version if you prefer that)
06:05:51 <Bynbo7> badkins: you could also replace the extra string by a Maybe String
06:06:00 <badkins> oh, right
06:06:21 <merijn> Learn You a Haskell is amazingly awesome despite (scratch that, because) of the drawings :>
06:06:40 <Bynbo7> LYAH will soon have a print version too:)
06:06:51 <merijn> Great
06:07:53 <merijn> I swear that guy has probably done more for Haskell's understandability for newbies then anyone else in FP history :p
06:08:01 <badkins> merijn: in particular, what is so bad about those types by the way?
06:08:42 <badkins> just the fact that I should've used records instead?
06:09:07 <merijn> badkins: Well, nothing bad specifically. But they just scream OO to me, which may not by itself be a bad solution to your problem. But usually it means that people don't understand how to approach it functionally
06:09:08 <aristid> badkins: you should have type reuse
06:09:15 <badkins> agreed :)
06:09:21 <aristid> (Int, Int, Int, Int, Int, Int, Int)
06:09:32 <aristid> why isn't this a type synonym, and what the heck are all these numbers?
06:09:34 <badkins> oh, I do in the real code I think, I "flattened" out the def for irc
06:09:38 <merijn> It might turn out that there is no better way then a type like that, but even if that's true record syntax would make it a lot better
06:09:47 <badkins> e.g. type MarioAttributes = (Int, Int, Int, Int, Int, Int, Int)
06:09:53 <aristid> badkins: why did you flatten it out? to make it look even worse? :D
06:09:55 <badkins> type MarioEntity = (String, String, MarioAttributes)
06:10:01 <merijn> badkins: hpaste.org is your friend ;)
06:10:04 <badkins> type Driver  = MarioEntity
06:10:09 <mzero> merijn? of CodeMirror fame?
06:10:11 <badkins> merijn: sure :)
06:10:26 <merijn> mzero: I have no clue what CodeMirror is, so probably not
06:10:50 <mzero> ah - see - they lie - the Internet isn't really all that small!  :-)
06:11:14 <badkins> aristid: to have fewer lines and not require people to click a link to somewhere else
06:11:19 <merijn> Also, his name is apparently spelled with an 'a' :p
06:11:40 <aristid> badkins: the MarioEntities type is relevant tho
06:11:50 <mzero> ah - right you are 
06:15:21 <rothwell> 'lo. anyone happen to know what ghc warning setting i need to disable to squash the pages of warnings caused by 'alex'? ->  Warning: Bindings containing unlifted types must use an outermost bang pattern:
06:25:54 <badkins> merijn: so regarding the right approach here, the goal is to have a set of Mario Kart drivers and vehicles, and create a cartesian product where the attributes are summed.
06:26:30 <badkins> I suppose in another language I'd use a Hash for the attributes (speed, weight, etc.)
06:26:59 <merijn> You mean to name all the Int's in your tuple?
06:27:03 <badkins> over a couple decades of OO experience is a challenge to overcome, but I like learning new things
06:27:21 <badkins> merijn: yes, I'll need to name them, I used selectors like this:
06:27:31 <EvanR-work> data Driver = Mario | Peach | Luigi | ...
06:27:35 <merijn> badkins: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
06:27:39 <badkins> speed :: IntAttr
06:27:39 <badkins> speed (f, _, _, _, _, _, _) = f
06:27:39 <badkins>  
06:27:42 <EvanR-work> table :: Map Driver Whatever
06:27:51 <Zao> | Baby Driver | ...
06:27:56 <badkins> type IntAttr    = MarioAttributes -> Int
06:27:59 <merijn> badkins: We Haskell programmers are extremely lazy. We let the compiler generate such boiler plate
06:28:02 <EvanR-work> data Whatever = (Int,Int,Int,Int,...) or some record
06:28:15 <badkins> merijn: I definitely sensed unnecessary tedium when writing it :)
06:28:28 <badkins> I'll checkout the link - thx
06:28:45 <EvanR-work> type classes here would be stupid
06:28:51 <merijn> badkins: You should really just checkout the entire Learn You a Haskell, it is excellent for beginners to functional programming
06:28:56 <badkins> I probably accidentally threw out the baby with the bath water
06:29:19 <merijn> EvanR-work: Who said anything about type classes? It's a link to record syntax :>
06:29:34 <EvanR-work> you did, yes
06:29:40 <badkins> EvanR-work: isn't that what I started with? type MarioAttributes = (Int, Int, Int, Int, Int, Int, Int)
06:29:49 <EvanR-work> whats the point of calling it mario
06:29:58 <badkins> to use it later
06:30:04 <badkins> type MarioEntity = (String, String, MarioAttributes)
06:30:10 <EvanR-work> thats silly
06:30:29 <badkins> what would you recommend instead?
06:30:47 <EvanR-work> do all the drivers have the same kind of attributes?
06:30:51 <badkins> yes
06:30:54 <EvanR-work> then its not specific to mario 
06:30:59 <EvanR-work> its just attributes
06:31:04 <EvanR-work> i called it Whatever
06:31:09 <badkins> no, Mario is not a driver :)
06:31:20 <EvanR-work> if i remember correct he is
06:31:20 <badkins> it's the game - Mario Kart
06:31:31 <EvanR-work> Driver is a player?
06:31:40 <badkins> just think MarioKartAttributes when you see MarioAttributes - sorry
06:31:42 <merijn> Cale: You didn't manage to save anything of your site yet?
06:31:47 <EvanR-work> then s/Driver/Character/
06:31:50 <badkins> no,Driver is a class of drivers
06:32:05 <badkins> I didn't use Character because I thought it might conflict with a Haskell type
06:32:08 <EvanR-work> no
06:32:29 <badkins> I don't feel the name is that important in this case however.
06:32:40 <badkins> driver vs. character
06:32:48 <EvanR-work> so far its the only way youve been able to relate what the data means
06:33:02 <EvanR-work> which is as import or more important as the raw representation
06:33:03 <merijn> badkins: Cale had a really nice example showing how to approach game objects from a different perspective. Unfortunately his site died, lemme see if I can find an archived version
06:33:41 <EvanR-work> badkins: i dont recommend putting Mario or MarioKart on the front of all your names
06:33:44 <EvanR-work> theres a module system for that
06:34:01 <badkins> EvanR-work: that might be fine for later, but it's not the area I'm pressing into really.
06:34:07 <udoprog> could someone give me an example of a function with the signature: foo :: [String] -> IO(Maybe String, Maybe String) ?
06:34:08 <EvanR-work> well itll save you typing
06:34:12 <badkins> the main question is the best representation for the types
06:34:27 <EvanR-work> the attributes could be a big tuple, buts it a good place for a record
06:34:29 <merijn> udoprog: Did you try Hoogle?
06:34:30 <badkins> EvanR-work: agreed, just not the highest priority currently
06:35:08 <badkins> EvanR-work: you may have jumped in late, the original question had to do with the fact that Vehicle has one extra String attribute, so I was trying to find out how to reuse concepts between Driver and Vehicle
06:35:22 <badkins> the tuple idea seemed to be breaking down
06:35:33 <badkins> that and the fact that having a bunch of selectors seems "wrong"
06:35:35 <EvanR-work> one extra string attribute?
06:35:38 <EvanR-work> whats the string?
06:35:45 <badkins> yes the type of vehicle - kart vs. bike
06:35:53 <EvanR-work> thats not a good use for a string
06:35:57 <badkins> I'll paste the whole thing...
06:35:57 <EvanR-work> design your data so it cant be invalid
06:36:09 <EvanR-work> type XYZ = Kart | Bike
06:36:12 <merijn> badkins: You'd normally define a data type for things like that
06:36:14 <EvanR-work> data*
06:36:19 <udoprog> merijn: was more into the declaration, not a documented existing function
06:36:22 <merijn> data Vehicle = Kart | Bike
06:37:06 <merijn> udoprog: What you want to know about the declaration? It defines a function which takes a list of strings and returns a tuple of Maybe String's inside the IO monad
06:37:13 <badkins> http://hpaste.org/43818/mariokart_example
06:37:50 <badkins> EvanR-work: good idea re: not using a String - thx
06:38:02 <EvanR-work> in javascript or php, we often have no other choice.
06:38:07 <badkins> although again, low priority refinement in this case :)
06:38:10 <udoprog> merijn: so an example of how to return a tuple of Maybe String's?
06:38:22 <EvanR-work> badkins: i thought you were asking how to choose a good data model?
06:38:45 <badkins> yes, but more specifically how to reuse the very similar tuples that only differ by a String, or in your case a XYZ
06:39:29 <EvanR-work> dont use strings, dont use tuples
06:39:36 <badkins> I'm used to a more exploratory approach to development since I use dynamically typed languages. So I started coding driver/vehicles before I realized I needed the kart/bike distinction.
06:39:41 <EvanR-work> not in general, i mean not for this
06:39:53 <EvanR-work> yeah, start with your data
06:40:01 <badkins> EvanR-work: are you're suggesting records ?
06:40:09 <EvanR-work> but if you make a mistake you can go change the data types, and the compiler will usually tell you where you need to change the code
06:40:14 <Eelis> how's the new Haskell Platform release coming along? the webpage says: "Next release: January 2011", and the timetable says the release was planned to take place a week ago
06:40:39 <Eelis> and will it include GHC 7 ?
06:40:42 <EvanR-work> badkins: for large tuples, its better to use a record, for a multiple choice value, use a simple data type consisting of n nullary constructors
06:40:51 <magthe> foo
06:41:18 <badkins> EvanR-work: yeah, I felt like the tuple was getting large when you have: acceleration (_, _, f, _, _, _, _) = f   :)
06:42:06 <massysett> Sorry if this has been asked, but is something wrong with http://projects.haskell.org ? I get a list of folders and all of them are empty.
06:42:32 <EvanR-work> badkins: you can factor out repeated patterns of data types
06:43:10 <merijn> badkins: This is still bad, but you'd do something more like : http://hpaste.org/paste/43818/mariokart_example_annotation#p43819
06:43:27 <EvanR-work> if you have (A,B,C,D) and (A,B,C) you could instead do X=(A,B,C), D, Y = Y X D
06:43:33 <merijn> badkins: Also, in Haskell I do exploratory approach entirely different then in dynamically typed languages
06:43:35 <yitz> massysett: not all of them
06:43:52 <yitz> massysett: yeah we are in the process of recovering from a hack attac
06:43:54 <EvanR-work> extreme example
06:43:56 <badkins> merijn: thx for the example
06:44:29 <massysett> OK thanks, just wanted to make sure somebody knew.
06:44:37 <merijn> badkins: I start by writing down type signatures for functions (using non-existent data types) and then start defining said types, refining the type signatures and data types iteratively as I go
06:44:40 <yitz> massysett: most of what was in projects previously is back now
06:45:03 <merijn> badkins: Once that is mostly done, only *then* do I actually start writing code to match the signatures
06:45:10 <yitz> massysett: there are a few that still need auditing to determine if the hacker planted anything nasty there
06:45:41 <EvanR-work> merijn: actually i find that that works in real life too, in js and (uhg) php
06:45:49 <EvanR-work> write the functions first
06:45:52 <merijn> badkins: You should use the type system as a safety net and guiding light in figuring out what you are trying to do. If you just start coding you will find the type system an obstacle and get annoyed with it
06:46:03 <badkins> EvanR-work: I'm missing something with your example above - maybe formatting in irc ?
06:46:19 <EvanR-work> badkins: i doubt it. note that its not value haskell code
06:46:23 <EvanR-work> valid*
06:46:27 <merijn> badkins: If instead you let the types guide your program you will find the type system an indispensable tool
06:46:27 <badkins> ah, ok :)
06:47:00 <massysett> I'm looking for http://projects.haskell.org/haskellmode-emacs and it's empty, so I started clicking randomly on other ones and they're mostly empty too. Clicked at least 20 and I think only one was not empty.
06:47:04 <EvanR-work> badkins: alternatively if some values of your data have the extra value and some dont, you can make it Maybe
06:47:11 <merijn> badkins: EvanR-work's example is similar to mine, except my annotation uses record syntax
06:47:30 <badkins> merijn: yes, I need a paradigm shift - the main reason I chose Haskell to learn statically typed functional programming is for its type system and purity.
06:47:43 <badkins> I didn't want to fall back on imperative, state mutating habits
06:47:48 <merijn> Actually, there's some typo's in my example (forgot to remove parenthesis and add braces)
06:47:53 <EvanR-work> statically typed is good, functional is good
06:48:03 <badkins> merijn: I got the gist of it anyway
06:48:07 <EvanR-work> they are independent, and haskell happens to be both! ;)
06:48:16 <badkins> yup
06:48:39 <merijn> badkins: Good :p As I said, first think of what you want to do, imagine what the type signatures of function to do that look like, write those down and work from there
06:48:49 <djahandarie> Has there been any work towards doing constraint programming in Haskell (rather than something like Curry)?
06:49:00 <merijn> djahandarie: Oleg, probably? :p
06:49:07 <merijn> In the type system, of course
06:49:18 <djahandarie> Maybe, I'll check out his page
06:50:19 <merijn> badkins: For example, in a game you'd probably have an "update :: GameWorld -> GameWorld" function
06:50:24 <djahandarie> What I'm really interested in is somehow merging constraint programming with the goodness of the curry howard correspondence
06:51:04 <badkins> merijn: it's actually not a game, I just want to permute drivers and vehicles and be able to sort by speed, weight, etc.
06:51:33 <teki> question: is there a way to clear the prompt in ghci (other than doing say putStrLn $ replicate 40 '\n' which is not really a solution)
06:51:36 <badkins> some drivers have better speed, worse weight; and vehicles likewise - just a little reporting app
06:52:26 <badkins> it seemed simple enough to be able to actually finish even with my Haskell skills :)
06:52:42 <rwbarton> teki: is ctrl-L what you want?
06:53:18 <teki> rwbarton: nope, seems to have done something funky
06:53:54 <teki> essentially just an analogue of clear in bash or cls in cmd
06:54:02 <teki> is what i would like
06:54:17 <rwbarton> yeah, that's what ctrl-L does on linux
06:54:40 <teki> yes, but not all of us are on linux :\
06:54:51 <rwbarton> yeah, I don't know then, sorry
06:54:55 <rwbarton> Kinda weird that it isn't the same really
06:55:03 <xplat> badkins: hm, you always combine attributes by simple addition?
06:55:28 <teki> rwbarton: i mean there is the cls in command line but that isn't accessible from ghci
06:55:40 <teki> oh well i suppose i can probably figure something out
06:55:40 <badkins> xplat: yes
06:55:47 <teki> or just do the putstrln solution :P
06:56:30 <merijn> badkins: Well, in that case the question becomes "What sort of information do I want to get from my permutations?"
06:56:46 <badkins> merijn: that link to record-syntax is awesome - he walks through exactly what I tried to do first and then refines :)
06:57:03 <merijn> badkins: Of course, hence why I said Learn You a Haskell rocks :>
06:57:17 <badkins> merijn: I'd like to be able to know the fastest driver/vehicle combination for example.
06:57:28 <badkins> later maybe give weights to attributes and pick the optimum
06:57:39 <xplat> badkins: then if i were you i would make a data AttributeLabel = Speed | Weight | ... deriving (Eq, Ord) and type MarioAttributes = Data.Map.Map AttributeLabel Int
06:57:42 <badkins> i.e. I favor speed & handling as important, so what's best
06:58:08 <badkins> xplat: whoa - need some time to digest that
06:59:01 <badkins> xplat: basically code to create the type?
06:59:41 <xplat> if it was a larger app i would use a record, but here you have more columns in the type than you have uses of it, basically
06:59:47 <rwbarton> teki: what version of ghc are you running?
07:00:27 <xplat> so using a Map lets you write the functions on it quickly
07:00:34 <badkins> xplat: how would I retrieve the speed from an instance then?
07:00:52 <badkins> at first glance (with my background) records seem the way to go
07:00:55 <xplat> :t M.get
07:00:56 <lambdabot> Couldn't find qualified module.
07:01:45 <xplat> er
07:02:29 <merijn> :t Data.Map.get
07:02:30 <lambdabot> Not in scope: `Data.Map.get'
07:02:33 <merijn> hmm
07:02:47 <xplat> i usually use lookup that returns a Maybe, but in your case you want the other one i never use :)
07:03:23 <badkins> xplat: I may need to wait until my Haskell chops increase a bit before I use that approach.
07:03:45 <merijn> badkins: So, what would the function signature be of those questions? Probably "[(Driver, Vehicle)] -> Criteria -> (Driver, Vehicle)"
07:04:28 <badkins> merijn: I already have a type for "Combo", so I would simply want a sorted list of Combos
07:04:56 <badkins> make_combos :: [ Driver ] -> [ Vehicle ] -> [ Combo ]
07:05:02 <xplat> oh, you want !.  you would do someAttributes ! Speed
07:05:03 <badkins> that gives me the permuted list
07:05:16 <merijn> @hoogle [a] -> [b] -> [(a,b)]
07:05:16 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
07:05:17 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
07:05:17 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
07:05:48 <badkins> then I'd need a function to sort the list based on a weighted list of attributes I think, or initially based on a single attribute
07:06:06 <mun_> hi
07:06:21 <rwbarton> teki: I don't know whether this works in windows either, but try:  :!cls
07:06:22 <mun_> if i have a function of a function of a function, what's the term for this depth?
07:06:53 <xplat> and adding all the attributes in two sets would just be unionWith (+) attrs1 attrs2
07:07:03 <kfr> mun_: A function
07:07:15 <badkins> merijn: with a Hash in other languages, I could simply pass a key into the sort function, can I do that with records in Haskell?
07:07:32 <merijn> :t sort
07:07:33 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:07:34 <badkins> in other words, what exactly is "speed" in the MarioAttributes type?
07:07:57 <xplat> :t sortBy
07:07:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
07:07:59 <merijn> badkins: It's a function taking a MarioAttributes and returning the speed entry
07:08:08 <mun_> kfr, i mean, the number of arguments of a function is called arity, but what is the number of levels a function can be nested in an argument?
07:08:13 <badkins> merijn: ok, that should work then
07:08:18 <merijn> Ah, yeah. You want sortBy
07:08:31 <badkins> cool - thx
07:08:32 <merijn> badkins: Guess what it does from the type signature
07:08:42 <badkins> yeah, I see that
07:08:54 <rwbarton> mun_: third-order function, I guess
07:09:09 <merijn> So you want a function "Combo -> Combo -> Ordering"
07:09:16 <badkins> merijn: not sure what "Ordering" is though - I'm guessing it's not { -1, 0, 1 }  :)
07:09:26 <merijn> @info Ordering
07:09:26 <lambdabot> Ordering
07:09:28 <Botje> data Ordering = LT | EQ | GT
07:09:34 <badkins> lol - awesome
07:09:38 <merijn> hmm, lamdabot is failing me :(
07:09:44 <mun_> rwbarton, right. thanks
07:09:46 <badkins> why use ints when you can have a type ;)
07:09:48 <merijn> But yeah, what Botje said
07:09:53 <merijn> badkins: Exactly
07:10:02 <merijn> badkins: Easier to read and less error prone
07:10:25 <badkins> well, thanks to all, I think I can wrap this thing up now and go on to other Haskell goodness
07:11:09 <merijn> badkins: Another pro-tip is to bookmark Hoogle, which basically lets you search the Haskell libraries by type signature
07:11:12 <merijn> @where hoogle
07:11:12 <lambdabot> http://haskell.org/hoogle
07:11:20 <badkins> great - thx
07:11:49 <merijn> So if you ever think I need a function "a -> [b] -> [(a, b)]" or something odd, you can probably find it already exists :p
07:12:06 <merijn> @hoogle a -> [b] -> [(a,b)]
07:12:06 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
07:12:07 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
07:12:07 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
07:12:22 <badkins> merijn: that does seem to be a benefit of static typing - classification and searchability of existing code
07:12:26 <xplat> there should really be a sortOn for the whatshisname transform, too, but there isn't yet unfortunately, at least not in Data.List
07:12:52 <merijn> badkins: Yes, and it becomes more useful with a polymorphic approach like Haskell's
07:13:16 <hpc> > chr 12
07:13:17 <lambdabot>   '\f'
07:14:03 <xplat> but you can import Data.Function and write it as sortOn f = sortBy $ compare `on` f
07:14:34 <merijn> I wish there was a prelude function "\x -> (==0) . (`rem` x)" that would make so many of my number mangling code prettier :\
07:15:06 <teki> rwbarton: sorry, was coding for a bit and didn't see your suggestion
07:15:11 <merijn> I should start making my own "utility.hs" library :>
07:15:19 <teki> rwbarton: :!cls did the trick!  thanks very much
07:15:21 <Martty> merijn: and there's something stopping you from making it? :D
07:15:42 <merijn> Martty: Laziness and having to redefine it every time :p
07:16:14 <xplat> (but that is not efficient unfortunately, you need more like sortBy (compare `on` fst) . map (f &&& id) )
07:17:14 <Silex> is there anything for doing guis in haskell or does that fall a bit out of the logical scope for haskell?
07:17:25 <xplat> merijn: k  n = (n `rem` k) == 0
07:17:34 <teki> Silex: look into wxHaskell
07:17:41 <Silex> teki: thanks
07:17:55 <xplat> (should be k|n but that's taken :( )
07:17:57 <stianhj> Silex, or Gtk2Hs
07:18:18 <merijn> :t (|)
07:18:20 <lambdabot> parse error on input `|'
07:18:42 <merijn> Reserved character I guess?
07:18:52 <xplat> used in case guards
07:19:46 <elliott> Can Template Haskell generate LANGUAGE pragma lines? Didn't think so :)
07:19:55 <xplat> mathematicians use it that way too -- they distinguish by context and whitespace, which is not feasible for haskell
07:20:22 <elliott> disambiguation by whitespace in Haskell? ++
07:20:31 <elliott> that would be fun!
07:20:41 <jmol> :!cls
07:20:42 <jmol> info:  doesn't work in windows ghci
07:20:43 <chopin_> hi
07:21:07 <teki> jmol: uhh
07:21:12 <marcot> http://paste.debian.net/107060/
07:21:23 <marcot> Can't writeFile work with UTF-8?
07:21:23 <teki> jmol: pretty sure :!cls works in ghci on windows for me
07:21:41 <teki> jmol: also :info works too...
07:21:46 <chopin_> im trying to install haddock, but i have a problem ? Can anyone help me ?
07:22:36 <jmol> teki: :) good to you
07:22:58 <teki> jmol: what problems are you having with it?
07:24:25 <jmol> :teki only curious about your problem just check http://hackage.haskell.org/trac/ghc/ticket/3062
07:24:36 <chopin_> by typing runhaskell Setup configure, it returns " At least the folloing depedencies are missing : ghc -paths -any
07:27:16 <yitz> chopin_: do you have the haskell platform installed?
07:27:33 <chopin_> yes the version 2.0.0
07:28:02 <yitz> chopin_: use cabal install
07:28:41 <yitz> chopin_: what are you trying to install?
07:28:55 <chopin_> haddock
07:29:13 <yitz> chopin_: type: cabal install haddock
07:29:40 <chopin_> thanks ! i will try
07:29:55 <chopin_> im waiting for cabal update
07:30:50 <yitz> chopin_: sounds good
07:31:10 <chopin_> cannot configure haddock -2.0.1 it requires base == 4.3.* and ghc >= 7.0 && 7.2
07:31:21 <chopin_> :s lol
07:32:35 <chopin_> yitz> i have to reinstall something ?
07:32:45 <yitz> chopin_: hmm try getting an explicit version of haddock that doesn't require ghc 7
07:32:45 * kfr uses ghc 6
07:32:50 * kfr uses ghc 7 *
07:32:59 <kfr> Move on to ghc 7! Screw 6!
07:33:09 <kfr> The sooner, the better!
07:33:29 <accel> function names should be camelCase -- should varaible names also be camelCase ?
07:33:30 <chopin_> one told me it could makes conflicts
07:33:49 <accel> so make variables_like_this ?
07:33:57 <Veinor> i use camel case for everything
07:34:03 <kfr> accel: I use camelCase for everything
07:34:09 <kfr> SomeType
07:34:11 <kfr> someVariable
07:34:33 <dmhouse> The most common Haskell convention is to use camel case for both, accel.
07:35:05 <kfr> I hate how people randomly mix them in Ruby :[
07:35:07 <yitz> hi dmhouse haven't seen you in a while
07:35:12 <accel> kfr , dmhouse : cool, thanks
07:35:50 <dmhouse> yitz: tend to be a bit busy during term time. Just came on here to ask a question in #
07:35:53 <dmhouse> *#math
07:36:07 <yitz> chopin_: try cabal install haddock-2.9.0
07:36:48 <yitz> dmhouse: thanks for stopping by here on the way
07:37:25 <chopin_> yitz > the same it requires >=7.0
07:37:27 <chopin_> :s
07:38:01 <yitz> chopin_: ah right. 2.8.1 then. :)
07:38:38 <yitz> chopin_: you can browse around the versions here: http://hackage.haskell.org/package/haddock-2.8.1
07:38:42 <chopin_> yeaah
07:38:45 <chopin_> it works !
07:38:50 <yitz> \o/
07:38:58 <chopin_> i was afraid about having conflicts
07:39:10 <chopin_> thanks !
07:39:15 <yitz> np
07:39:43 <Blkt> good day everyone
07:40:00 <yitz> hi Blkt 
07:40:10 <Blkt> hi
07:40:38 <MarcWeber> nnjk
07:41:41 <chopin_> yitz do you know if it s easy to use haddock ?
07:42:11 <yitz> it's easy and highly recommended, at least to include haddock-style comments in your code
07:42:50 <chopin_> my code is already commented
07:42:52 <yitz> chopin_: i don't build haddock documentation locally usually. it gets built automatically when you upload to hackage.
07:43:15 <chopin_> ah
07:43:38 <accel> is it possible to define a single "mul" that can handle: Vec3 `mul` Double       ... and ...      Double `mul` Vec3 ?
07:43:46 <chopin_> what do you call "haddock style" ?
07:43:55 <yitz> chopin_: you should in include the markers in your comments that tell haddock which  comments are associated with what, and that allow haddock to create hyperlinks
07:44:03 <marcot> Using System.IO.UTF8 doesn't help.
07:44:59 <marcot> I think the problem is on getEnvironmnet
07:45:03 <yitz> chopin_: http://www.haskell.org/haddock/doc/html/index.html
07:45:53 <yitz> chopin_: see especially chap. 3: http://www.haskell.org/haddock/doc/html/markup.html
07:46:42 <chopin_> i m on it, thanks !
07:46:49 <yitz> marcot: what are you trying to do?
07:47:04 <badkins> merijn: so I'm reworking tuples to records and I get an error regarding multiple definitions of a record "label"
07:47:13 <badkins> data Driver = Driver { name :: String, size :: Size, attributes :: Attributes }
07:47:16 <badkins> data Vehicle = Vehicle { name :: String, size :: Size, vehicle :: Vehicletype, attributes :: Attributes }
07:47:27 <badkins> is "name" not scoped to Driver and Vehicle ?
07:47:32 <yitz> badkins: no
07:47:40 <accel> http://hpaste.org/43821/accel <-- is there a way to say: update the angle field, but keep everything else the same?
07:47:41 * badkins is sad
07:47:43 <xplat> badkins: ah, yeah, you can use the same name for two different constructors, but only if they are the same type
07:47:46 <yitz> badkins: you can't use the same label name twice
07:48:18 <merijn> badkins: Yes, that is one minor wart. People have been thinking about alternative approachs for a while now, but nothing yet
07:48:18 <yitz> except like what xplat said ^^
07:48:22 <badkins> so people just prefix everything? driver_name, vehicle_name ? that seems a little odd
07:48:47 <xplat> accel: if you would rtft you would know these things already
07:48:49 <yitz> badkins: yeah. i usuall abbreviate. dName vName or whatever
07:48:59 <badkins> interesting, ok, I'll deal with it :)
07:48:59 <yitz> s/usuall/usually/
07:49:15 <merijn> badkins: No, I'd rename Driver to "Entity" or something else and define Vechicle as "data Vehicle = Vehicle Vechicletype Entity"
07:49:26 <xplat> accel: it is okay to ask some basic questions on #haskell, but you have exceeded your quota
07:49:53 <marcot> yitz: http://paste.debian.net/107060/
07:49:58 <yitz> quota?
07:50:04 <accel> xplat: guess it' time I get a new nick
07:50:17 <merijn> badkins: I mean, most of the datatypes are the same, so why duplicate that work? :p
07:50:41 <badkins> merijn: definitely agree, I just didn't know the syntax for reuse
07:50:58 <marcot> yitz: It seems that getEnvironment is not reading the values correctly.  If I use writeFile "teste" $ decodeString $ fromJust $ lookup "DEBFULLNAME" env it works.
07:51:09 <badkins> very glad to know my first impressions of Haskell being less concise are unfounded
07:51:20 <marcot> yitz: Either Prelude's or System.IO.UTF8's.
07:52:57 <empt> ghci: a=3 would get an exception, it's that a feature?
07:53:31 <merijn> badkins: A data type definition like "data Vehicle = Vehicle Vehicletype Entity" basically say "Vehicle is a new type, which has one constructor "Vehicle" which takes one value of type Vehicletype and one value of type Entity". Constructors can take any type as argument so you can reuse things like that
07:53:35 <jmol> empt: in ghci you must write let a = 3
07:53:47 <empt> jmol: thanks
07:53:55 <empt> I was wondering
07:54:01 <copumpkin> you can never write pure assignment in isolation
07:54:12 <copumpkin> except maybe at the top level of a file :)
07:54:12 <merijn> badkins: It is similar to storing a instance of class Foo inside a class Bar instead of Bar inheriting from Foo
07:54:19 <yitz> accel: CameraState {angle = angle camera_state + time}
07:54:24 <copumpkin> and it's not what I'd call assignment
07:55:08 <merijn> badkins: This is slightly more tedious when accessing members of the inner data type, but pattern matching removes most of that annoyance
07:55:18 <empt> copumpkin: it's interesting. 
07:56:33 <yitz> marcot: oh. annoying.
07:56:45 <badkins> merijn: so it doesn't "flatten" it out, you have to drill down to subcomponents then
07:56:55 <badkins> (a, (b, c)) vs. (a, b, c)
07:57:05 <badkins> (in effect)
07:57:09 <xplat> badkins: yes
07:57:28 <merijn> badkins: Yes, but if you don't nest to much its not usually a problem
07:57:44 <xplat> if you have a really deep hierarchy where that gets painful, you could make typeclasses for convenience
07:57:45 <badkins> yes, I guess the benefits of reuse (both in the type and functions) is worth it
07:57:56 <kulakowski> Is the 11th still the date for the new Platform?
07:58:42 <merijn> badkins: For more complex situations you can usually simplify using typeclasses, but I don't think you've encountered those yet and they may be a bit to advanced for where you are now
07:59:01 <xplat> but in general if your hierarchy is that deep you are abstracting and so you'd usually only drill down 2 or 3 levels tops in a single function
07:59:02 <badkins> agreed :)
07:59:04 <merijn> LYAH explains those pretty well
07:59:32 <merijn> Also, what xplat said :p
07:59:46 <accel> can haskell records have default values?
08:00:07 <merijn> accel: No, but you could create a default instance of your type, I suppose
08:00:25 <xplat> no, but you can create 'factory' functions that set defaults
08:00:27 <yitz> marcot: what platform?
08:00:38 <accel> xplat: hey; you are't pointing me to rwh/lyah :-)
08:00:52 <marcot> yitz: Linux amd64.  I have the same behaviour in ghc 6.12.1 and 7.0.1
08:00:56 <accel> xplat: I ende up using: update :: Double -> CameraState -> CameraState
08:00:56 <accel> update time camera_state = camera_state { angle = (angle camera_state) + time }
08:01:01 <marcot> yitz: I'm asking on #ghc
08:01:05 <accel> but there's a way to do that with "#" right?
08:01:09 <accel> I couldn't find that syntax
08:01:25 <yitz> marcot: isn't an environment variable value just bytes on unix?
08:01:39 <xplat> accel: in this case your answer was likely to be of use to badkins too, so it was worth answering
08:01:51 <yitz> marcot: so if you want to interpret it as if it were utf-8 you'd have to do that yourself.
08:02:20 <yitz> marcot: as for then using it as a file name, see http://hackage.haskell.org/trac/ghc/ticket/3307
08:02:20 <marcot> yitz: well, echo $DEBFULLNAME > teste works...
08:02:37 <merijn> yitz: It's locale sensitive I think
08:02:43 <copumpkin> gwern: as for alp's GSOC, he cancelled it early because his only computer died at the beginning of the summer
08:02:59 <Botje> aww :(
08:03:02 <yitz> merijn: what is?
08:03:37 <marcot> yitz: But yes, you may be right.
08:03:45 <gwern> copumpkin: oh.
08:04:02 <yitz> marcot: getEnvironment gives you raw bytes, decoded into a String byte-by-byte.
08:04:35 <marcot> yitz: Do you think this information is worth including on #3307 or #3309?
08:04:43 <yitz> marcot: it really ought to be a Data.ByteString, but that's what it does for historical reasons
08:04:50 <merijn> yitz: The encoding in ENV variables
08:05:03 <copumpkin> gwern: also, a minor point, but DPH is all strict and unboxed, so none of those issues arise there. You're right that nobody uses it, but for CUDA I don't think there are any doubts that it would help significantly, due to the restricted kinds of computations you can perform in DPH
08:05:38 <yitz> merijn: i don't think so. it's just bytes. if your shell locale is a certain encoding, it will display those bytes via the encoding just as it displays any other bytes.
08:05:55 <merijn> You can't really display in an encoding
08:05:59 <copumpkin> gwern: but overall (apart from our disagreement about plugins) I think it's a good summary :)
08:06:06 <merijn> An encoding is just which bytes are stored
08:06:17 <gwern> copumpkin: sure, but then you have interface issues - 'why does my performance suck' <goes away and profiles and tweaks for an hour> 'oh my input was lazy and boxed, even though the dph/cuda operations were strict and unboxed'
08:06:32 <merijn> So the OS treats them as "just bytes" but the programs setting/modifying them will use the current locale for encoding
08:06:43 <copumpkin> gwern: fair enough, I guess the boundary is still vulnerable
08:07:34 <yitz> marcot: perhaps. i think it's a bit of a different issue, and i'm not even sure that what it is doing is wrong, apart from the old Haskell 98 API of using String instead of bytestrings.
08:07:37 <merijn> Or at least, the program *should* use the current locale, what they actually do might be absolute mystery, of course
08:07:57 <merijn> Anyhoo, time to head home
08:08:01 <gwern> copumpkin: ok, so I should mark alp's LLVM work as unsuccessful (albeit not really his fault)?
08:08:20 <yitz> merijn: yes, and one of the programs is the shell. so when it displays bytes, it uses the encoding specified in the locale. but the actual value of the environment variable is just bytes.
08:10:30 <copumpkin> gwern: I'd mark as invalid or something, since it really doesn't say anything about the merit of the project, the organization, or the student
08:10:51 <copumpkin> it was just unfortunate
08:11:07 <copumpkin> it may still be worth commenting on the project idea though
08:11:19 <gwern> mm. I don't like excepting bad luck but quietly taking advantage of good luck
08:11:32 <gwern> (if one SoC died because of bad luck, then we should wonder how many succeded only by good luck)
08:11:33 <copumpkin> how so?
08:11:43 <copumpkin> it's not really that
08:12:07 <gwern> or are we arguing there is no such thing as good luck? :)
08:12:53 <djahandarie> gwern, perhaps it's just more important to provide more information than be 100% fair?
08:13:07 <djahandarie> We know for sure when something is bad luck, we don't really know when something is good luck
08:13:24 <copumpkin> I just don't think it should count against anyone that someone's computer died. No matter how much luck was involved in any of the other successes, the students put lots of work into them, so luck isn't 100% of their success or lack of it. Here, bad luck is 100% of the failure
08:13:46 <gwern> djahandarie: I find that fairness seems to involve a psychological asssessment of intentions - 'alp intended well so his not delivering shouldn't really count as a unsuccessful SoC'
08:14:02 <copumpkin> I'm not saying it would have succeed
08:14:07 <copumpkin> so I'm not saying it should count as successful either
08:14:13 <copumpkin> it just shouldn't count for anything, because it never started
08:14:36 <gwern> copumpkin: never started? but it was accepted else it wouldn't've been listed on the pages I consulted
08:14:48 <copumpkin> it was accepted, and then his computer died
08:14:52 <yitz> what we should have done is gotten together as a community and made sure that person had use of a working computer for a few months, if that was the only problem
08:15:08 * gwern wonders what Alp's personal situation is like given that he couldn't get even a dinky little $200 laptop or something to work on
08:15:19 <copumpkin> gwern: that's his business :P
08:15:34 <yitz> if that was the problem i'm sure we could have helped
08:15:50 <copumpkin> I dunno, ask him :)
08:16:18 * gwern isn't *that* curious
08:16:23 <yitz> you can rent a laptop for 3 months for a lot less than $200.
08:16:40 <copumpkin> he may have lost work too, I really don't know
08:16:46 <copumpkin> I just don't think it's relevant to the question at hand
08:17:22 <yitz> oh that could be, wasn't backed up or something
08:17:25 <gwern> copumpkin: incidentally, I only have your word on Alp's problem so what name do you want me to use?
08:17:39 <gwern> 'copumpkin'?
08:17:55 <xplat> obviously c0w
08:17:57 <copumpkin> well, you can just ask alpounet for details :) I just haven't seen him talk much recently
08:18:05 <gwern> preflex: seen alpounet 
08:18:05 <preflex>  alpounet was last seen on #haskell 1 day, 15 hours, 10 minutes and 50 seconds ago, saying: nosila, ghc --make ?
08:18:12 <copumpkin> gwern: sure, or my real name. I don't really care, either way
08:18:15 <gwern> a day? I can't wait a whole day!
08:18:18 <copumpkin> :)
08:18:35 <gwern> copumpkin: well, I don't know your real name. the Map of nick->realName is too big for me to remember
08:18:41 <gwern> why I asked
08:23:26 <yitz> hi SyntaxNinja 
08:23:32 <magicman> @type runContT
08:23:33 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
08:25:09 <yitz> gwern: there used to be a wiki page containing that map, but it hasn't been kept up to date.
08:25:29 <gwern> yitz: tempus edax rerum, eh
08:26:53 <yitz> gwern: actually i think it was spamus edax rerum
08:27:16 <djahandarie> My nick makes it easy to remember!
08:27:29 <djahandarie> And my /whois makes it even easier!
08:27:37 <yitz> djahandarie: once we remember the nick that is
08:28:17 <djahandarie> Well supposedly you'd be reading it :P
08:28:27 <yitz> :)
08:41:35 <luite> is it possible to quickly find out which hackage packages depend on a specific package, directly or indirectly?
08:42:00 <edwardk> luite: there is a reverse deps version of hackage somewhere but its not in the main one
08:42:00 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
08:42:28 <gwern> luite: actually, I was about to look one up myself - http://sparky.haskell.org:8080/packages/ is one
08:42:31 <gwern> there's another
08:43:15 <luite> thanks
08:43:53 <quicksilver> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/hslogger-1.1.3 is the other one
08:44:00 <yitz> luite: http://packdeps.haskellers.com/
08:44:08 <quicksilver> hmm, another other one ;)
08:44:25 <luite> yitz: hmm, that one seems to be rather incomplete
08:44:44 <yitz> luite: i don't think so, it's dynamically updated
08:45:45 <luite> yitz: ah I was looking at the wrong results
08:46:03 <luite> it lists even more reverse deps than sparky
08:46:46 <luite> but some of those results are duplicates
08:46:48 <yitz> luite: it's dealing with a specific issue though, for the forward dependencies
08:47:17 <yitz> upper version bounds that block a newer version
08:51:37 <kulakowski> Not quite haskell related, but I saw someone here the other night talking about Nix, which I've been curious about. Was that anyone here?
08:52:09 <tg_> like *nix?
08:52:35 <tg_> oh no, the purely functional package manager
08:52:38 <kulakowski> Yeah
08:52:50 <jmcarthur> i wasn't here, but i've been playing around with it and it's nice so far
08:52:51 <tg_> also a moon of pluto
08:52:58 <kulakowski> I just joined their channel, I think it was roconnor I saw talking about it.
08:53:14 <tg_> it's in competition with things like dpkg, etc?
08:53:17 <jmcarthur> i haven't found it entirely trivial to create a nix expression for a new package, but i'm a newb, so...
08:53:59 <kulakowski> tg_: There is Nix, which is just package management, and also NixOS, which puts everything under its control (config files in /etc, and so on).
08:54:10 <tg_> kulakowski: yes, I see that.
08:54:12 <jmcarthur> the unstable nix channel surprisingly has many packages that even arch linux's AUR doesn't have (yet)
08:54:26 <luite> yitz: is it still recommended to add such bounds, like "text >= 0.11 && < 0.12" for all dependencies?
08:54:46 <jmcarthur> at least packages relevant to purely functional languages and such... kind of predictable, i guess
08:54:53 <kulakowski> jmcarthur: Packages that it doesn't include at all, or newer versions of packages?
08:55:00 <jmcarthur> i was able to install Ur with nix yesterday. crazy
08:55:07 <jmcarthur> kulakowski: stuff not in AUR at all
08:55:14 <jmcarthur> kulakowski: e.g. Ur ^^
08:55:37 <kulakowski> jmcarthur: What platform are you on?
08:55:42 <jmcarthur> arch linux
08:56:45 <tg_> aur = arch unstable repo?
08:57:16 <jmcarthur> tg_: Arch User Repository
08:57:27 <jmcarthur> tg_: users can upload any package they want to it without screening
08:57:29 <kulakowski> To what extent do you use it? Like are the majority of your packages installed with it, or just a few things that Arch doesn't get you?
08:57:31 <jmcarthur> so it has *tons* of packages
08:57:38 <tg_> jmcarthur: like ubuntu's user repos
08:57:50 <tg_> hmm. I switched from ubuntu to debian yesterday.
08:58:06 <tg_> i asked someone to convince me to use arch
08:58:10 <tg_> nobody took up the challenge
08:58:32 <jmcarthur> kulakowski: currently i mainly use the arch repos and aur. i just have nix managing a few packages and that's it. e.g. i have ghc 7 under nix and ghc 6 under pacman, although i could feasibly have both under nix
08:58:46 <jmcarthur> kulakowski: of course, i *can't* have both under pacman :\
08:59:39 <jmcarthur> tg_: i like arch because it's an easy system to understand. there's not much installed that you aren't made aware of, configuration is transparent, etc.
09:00:14 <jmcarthur> tg_: linux is complex, and rather than attempting to hide the complexity like, say, ubuntu does, arch just exposes it so you have a reasonable chance of tracking down any issues you may have
09:00:23 <jmcarthur> ymmv
09:00:26 <kulakowski> jmcarthur: Ok. For what it's worth I'm on OS X, and trying to decide whether to jump to Nix from homebrew or what else.
09:00:28 <tg_> jmcarthur: how does it do this?
09:00:37 <tg_> i mean, what are the principles that it enforces that allow this?
09:01:27 <jmcarthur> tg_: https://wiki.archlinux.org/index.php/The_Arch_Way
09:02:05 <tg_> ty
09:03:21 <quicksilver> jmcarthur: I think debian would agree with those 5 statements (although presumably differ with some of the ways they are implemented)
09:03:48 <kulakowski> jmcarthur: I think the one big question I had was how you do hackage's package management. What is the interaction between stuff you have installed with GHC 6 on arch and GHC 7 on nix?
09:03:48 <jmcarthur> quicksilver: as would most distros. it's the text underneath the headings that i think makes it more unique
09:04:02 <Rotaerk> jmcarthur, the problem with the KISS mentality is that it's occasionally used when it shouldn't be
09:04:06 <jmcarthur> kulakowski: there is no interaction
09:04:13 <jmcarthur> Rotaerk: such as?
09:04:17 <kulakowski> jmcarthur: That is what I was hoping.
09:04:30 <jmcarthur> kulakowski: that has nothing to do with the package managers though. that's more Cabal's doing
09:04:30 <elliott> Can you do $(someTHFunction (a :: T)) and then access the relevant T from inside someTHFunction? I assume not, it'd have to be [| a::T |] right?
09:04:48 <Rotaerk> jmcarthur, introducing complexity in the tools often increases the simplicity of the product
09:04:54 <kulakowski> Rotaerk: As simple as possible, but no simpler, eh
09:05:16 <jmcarthur> Rotaerk: the candy shell, so to speak?
09:05:23 <gwern> man, does *anyone* use YHC except malcolm wallace these days?
09:05:31 <Rotaerk> dunno what you're referring to
09:05:38 <Kamx> Hi, I have a question related to lazyness and "bottom"
09:05:38 <jmcarthur> Rotaerk: i understand that it is not always as superficial as a colorful candy shell
09:06:33 <jmcarthur> Rotaerk: i see a lot of the complexity that distros like ubuntu introduce as a kind of syntax sugar, but unlike with most programming languages, ubuntu documentation doesn't even try to explain what it "desugars" to
09:06:44 <jmcarthur> if that makes sense
09:07:07 <jmcarthur> Kamx: just ask
09:07:09 <tg_> jmcarthur: do you use Xmo on top of arch?
09:07:18 <jmcarthur> tg_: xmonad?
09:07:23 <tg_> aye
09:07:25 <jmcarthur> yes
09:07:37 <Kamx> jmcarthur: I pasted example code and a question here: http://hpaste.org/43823/question_related_to_lazyness_a
09:07:40 <tg_> do you use any display manager with Xmonad?
09:08:11 <jmcarthur> tg_: i have used xcompmgr and cairo-compmgr, but i'm not using one anymore
09:09:55 <gwern> heh. I'm suffering from semantic satiation. 'successful' and 'unsuccessful' no longer look like meaningful or correctly spelled words
09:10:05 <jmcarthur> Kamx: the reason the second one works is because the Show instance doesn't force the value at all
09:10:33 <jmcarthur> Kamx: it works for the same reason that (show void) works
09:10:39 <kulakowski> gwern: I'd say they aren't, but I don't think you'd fall for it.
09:10:54 <gwern> kulakowski: my spellchecker assures me that they are :)
09:10:59 <Kamx> jmcarthur: ah, okay, so "g undefined" isn't evaluated, right?
09:11:11 <quicksilver> Kamx: exactly.
09:11:29 <kulakowski> gwern: As I figured.
09:11:29 <jmcarthur> correct
09:11:50 <Kamx> quicksilver, jmcarthur: okay, thanks :-) It twisted my brain...
09:12:17 <quicksilver> most show instances are strict
09:12:27 <quicksilver> and we tend to get used to assuming this fact
09:14:05 <chopin_> yitz > Still here ?
09:14:19 <yitz> just got back :)
09:14:23 <chopin_> hehe
09:14:39 <chopin_> i commented my code like you said
09:14:56 <chopin_> but hen i type haddock MyFile.hs
09:15:29 <chopin_> i have "could not find link destinations for : GHC.Types.Int GHC.Base.String etc...
09:15:41 <chopin_> and when I type cabal configure
09:15:49 <chopin_> "No cabal file found"
09:16:37 <Kamx> Hmmm.. is there anything about the difference between () and an empty data type, that would make you want to use IO () instead of IO Void (with Void being an empty data type)?
09:16:57 <gwern> copumpkin: ok, a bunch of changes and your comments are live at http://www.gwern.net/Haskell%20Summer%20of%20Code.html
09:17:18 <Kamx> I mean.. do you ever make use of the value ()....
09:17:38 <yitz> chopin_: for haddock - yeah i'm not sure what you need to do to get haddock to find everything to link to, i don't generally run haddock locally.
09:17:39 <hpc> it's so you can say "return ()"
09:17:40 <copumpkin> gwern: thanks, I'll check it out
09:17:44 <hpc> rather than "return undefined"
09:17:52 <chopin_> aaah
09:17:57 <hpc> one is a bit nicer, stylistically
09:18:00 <chopin_> it worksss
09:18:00 <yitz> chopin_: for cabal - you need to "cabalize" your package.
09:18:08 <chopin_> i used -h
09:18:10 <yitz> oh, great!
09:18:12 <hpc> the other is scary and looks like failure
09:18:12 <chopin_> to havec html files
09:18:16 <Kamx> hpc: but that's just a matter of style.... but having () as value seems kind of unneccessary
09:18:46 <hpc> it isn't
09:18:51 <Kamx> of course there are historical reasons too... i just wonder, how you'd design it from scratch...
09:19:00 <yitz> chopin_: i think you also want hscolour installed, to get haddock to colorize the html
09:19:00 <hpc> i would keep ()
09:19:16 <hpc> consider: Maybe isn't necessary, since you can just use Either ()
09:19:38 <hpc> (yes, i am ignoring a few things, but the point remains)
09:19:39 <yitz> @where cabal
09:19:39 <lambdabot> http://www.haskell.org/cabal
09:20:46 <hpc> also, large tuples are not necessary since you can nest tuples
09:21:03 <pastorn> hpc: ugh...
09:21:19 * hpc is not seriously advocating either of those
09:21:21 <Kamx> hpc: My point is something else, I want to ask, if you sometimes match on () for any reason
09:21:32 <xplat> () is good to have because then you can write total functions
09:21:41 <hpc> ^
09:22:15 <Kamx> Btw., I only want to ask to understand some concepts better, not because I suggest changing the language ;-)
09:22:23 <Kamx> what are total functions?
09:22:36 <hpc> Kamx: a total function is a function that is defined for every input
09:22:41 <kulakowski> jmcarthur: Are you running nix from svn, or a 0.16 tarball, or something else?
09:22:44 <jmcarthur> i think the difference between IO () and IO Void is pretty much meaningless
09:22:52 <jmcarthur> kulakowski: i installed nix from AUR
09:22:54 <xplat> or if you don't understand why that's good, consider that bottom is a weird 'value' and you might like to have a type with one 'normal' value to work with
09:22:54 <hpc> *for every non-bottom input
09:23:19 <jmcarthur> kulakowski: so probably a tarball, since the package isn't called nix-svn
09:23:23 <jmcarthur> i don't remember for sure which version
09:23:49 <jmcarthur> 0.16 it says
09:24:09 <kulakowski> jmcarthur: ok. also nix is very hard to search for...
09:24:18 <jmcarthur> xplat: unfortunately () has both a normal value *and* a weird value
09:24:34 <Kamx> xplat: why do you need () to write total functions?
09:24:41 <xplat> jmcarthur: can't be helped
09:24:48 <hpc> Kamx: because otherwise you would be outputting undefined
09:24:57 <gwern> kulakowski: they could rename it 'nixy' which is easier to search for and has an obvious logo - the 'y' is an upside down lambda
09:25:00 <Kamx> jmcarthur: "unfortunately () has both ..." <- thats where i see some redundancy
09:25:10 <xplat> Kamx: you need () to write total functions into.  the functions out of Void are of course (trivially) total
09:25:10 <hpc> for a function to be total, it cannot output undefined ever
09:25:17 <yitz> @google nix
09:25:17 <lambdabot> http://www.nixlice.com/
09:25:18 <lambdabot> Title: Nix Head Lice Treatment Solution, Headlice Prevention & Lice Elimination Product ...
09:25:18 <jmcarthur> Kamx: and i agree, but it's not a very important issue
09:25:19 <Kamx> hpc: not exactly!
09:25:31 <jmcarthur> Kamx: we pretend that haskell is a total language very often anyway, even though it's not
09:25:36 <yitz> @google nix linux
09:25:37 <lambdabot> http://www.linux.com/archive/feature/155922
09:25:37 <lambdabot> Title: Linux.com :: Nix fixes dependency hell on all Linux distributions
09:25:43 <Kamx> hpc: undefined is of type "forall a. a", while "undefined :: Void" is of type "Void"
09:26:35 <jmcarthur> Kamx: but _|_ is a member of every type in haskell. undefined is undefined, in any case
09:27:40 <jmcarthur> Kamx: and hpc was correct. a total function must never, ever give _|_
09:28:40 <chopin_> yitz > How can i say to haddock to return at line
09:28:44 <chopin_> in my comment ?
09:29:13 <xplat> also, in practice, you may sometimes want a strict function on ()
09:29:16 <yitz> chopin_: blank comment line?
09:29:44 <xplat> strict functions of type Void -> a are either impossible or useless, i forget which
09:29:54 <hpc> xplat: impossible
09:30:04 <hpc> since they can't produce a non-bottom value
09:30:27 <hpc> unless you want to be crazy and accept wtf = const (unsafeCoerce 5)
09:31:03 <yitz> hpc: that's bottom
09:31:03 <xplat> ah, but that's not strict
09:31:15 <hpc> oh, strict in the argument
09:31:19 <xplat> yeah
09:31:27 <Kamx> okay, undefined is _|_ and undefined :: Void is _|_ too...
09:31:29 <hpc> perhaps wtf = id?
09:31:45 <hpc> if that doesn't count, it's impossible
09:32:10 <hpc> Kamx: indeed; anything that isn't useful is bottom
09:32:19 <chopin_> yitz > It ignores blank comments
09:32:30 <hpc> Kamx: infinite loop, exception, exploding power supply, you name it
09:32:31 <chopin_> do you use html output or something else usually ?
09:32:43 <hpc> (the last is cheating :P)
09:32:44 <yitz> chopin_: paste an example
09:32:45 <xplat> for functions that return () but are undefined on error, a strict function will propagate a failure further while a nonstrict one will ignore it
09:33:16 <Kamx> xplat: yes, that's what i was asking for. Is it practically used?
09:33:19 <chopin_> Here is the comment printed :
09:33:21 <chopin_> Context of a genealogy constrain1: Test of: Sup and App Verify if: age(Pierre) > age(Patrick)
09:33:28 <xplat> and this is not very useful for pure functions, but is more useful for IO
09:33:30 <Kamx> -asking for +aiming for
09:33:31 <hpc> Kamx: i have never heard of it used that way
09:33:44 <chopin_> Here is what i want :
09:33:46 <chopin_> -- | In The module 'OCL': -- OCL data structure, -- Model data structure,-- eval and listing functions
09:33:58 <chopin_> i returned at line for each comment
09:34:49 <xplat> (that's just because pure functions returning () are not so useful in general)
09:35:17 <xplat> but more important as a use for (), it behaves better wrt polymorphism than Void
09:35:33 <hpc> Kamx: to be clear, too; there is a difference between return undefined, and undefined
09:35:41 <Kamx> xplat: But do you sometimes indicate failure by return undefined instead of return () ?
09:36:12 <hpc> in IO, you can have "return undefined", but you don't evaluate the resulting () inside
09:36:13 <yitz> chopin_: oh, for that use a bullet list
09:36:18 <hpc> or plain old undefined
09:36:22 <hpc> which is :: IO ()
09:36:29 <hpc> and wrecks the sequencing of IO
09:36:42 <chopin_> a bullet list ?
09:36:42 <Kamx> hpc: as there is a differnce between "Void" and "IO Void"?
09:36:54 <hpc> yes
09:37:27 <hpc> this applies to any parameterized type
09:37:27 <yitz> chopin_: 3.8.9. Itemized and Enumerated lists
09:37:29 <Kamx> hpc: and when are both variants practically used?
09:37:33 <hpc> so [Void], etc
09:37:40 <Kamx> hpc: the values _|_ and return _|_ i mean
09:37:43 <yitz> chopin_: precede each paragraph with a * or a -
09:37:49 <hpc> "return undefined" is never used, i think
09:38:09 <hpc> and regular "undefined" isn't used either, but error is
09:38:18 <hpc> because error produces a meaningful message
09:38:20 <ski> hpc : i used it, before changing to `M Void', which obviated any need for `undefined' :)
09:38:20 <hpc> :t error
09:38:21 <lambdabot> forall a. [Char] -> a
09:38:53 <Kamx> hpc: my point would be then: IF "return undefined" was never used, THEN you could replace IO () by IO Void, or am I wrong?
09:39:21 <hpc> wrong, for the reason xplat gave
09:39:26 <hpc> i was just disambiguating
09:39:36 <ski> jmcarthur : `IO Void' is for an `IO'-action which never returns
09:39:59 <opqdonut> how can I write a Word8 into a handle?
09:40:01 <opqdonut> easiest way
09:40:10 <ski> @hoogle exitWith
09:40:10 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
09:40:22 <ski> that could have used `IO Void' instead (as could `forever')
09:40:27 <yitz> opqdonut: use Data.ByteString
09:40:52 <TimeCat> I seem to be having an issue with dependency resolution in capri does this make sense to anyone?: http://hpaste.org/43769/version_checking
09:41:00 <xplat> forall a. IO a is a nicer alternative to IO Void in a lot of ways
09:41:14 <jmcarthur> ski: sure. iirc, i've even supported that proposal before
09:41:18 <xplat> it still has no defined values, but you can use it anywhere
09:41:21 <jmcarthur> ski: you still would never say "return void" though
09:41:24 <yitz> opqdonut: you have hWriteFile, hPutStr, etc.
09:41:40 <opqdonut> ok
09:41:43 <xplat> which makes sense if it actually never returns
09:42:09 <Saizan> TimeCat: "ghc-pkg list ghc" ?
09:42:10 <xplat> the continuation is unused so it can accept any type :)
09:42:52 <TimeCat> Saizan: ghc 6.12.1
09:42:58 <ski> Kamx : `void = undefined :: Void' and `instance Show Void where show _ = "void"' are bad .. `Void' isn't to be used in that way
09:42:59 <Saizan> TimeCat: it's talking about the haskell library called ghc, not about the compiler itself
09:43:18 <ski> jmcarthur : *nod*, `void :: Void' is bad
09:43:19 <Saizan> TimeCat: can you paste the whole output?
09:43:45 <ski> xplat : yes
09:44:01 <TimeCat> saizan: sure i'll annotate the paste, just a sec
09:44:20 <xplat> it's a mistake, in general, to treat bottom the same as other values
09:44:48 <xplat> in fact, calling it a value is kind of a misnomer in itself
09:44:52 <Kamx> you don't treat it like other values, if you'd use IO Void, i think... As you'd never look at any value at all....
09:45:52 <xplat> Kamx: that would work fine until you try to sequence it with a polymorphic strict function
09:46:03 <ski> Kamx : you can match on `()' to force the evaluation of parts of datastructures that such a value depends on
09:46:13 <Saizan> TimeCat: ok, so you do have that package, i've never used capri so i wouldn't know why it can't see it
09:46:26 <xplat> like, say, 'show'
09:46:44 <ski> Kamx : the main useful function on `Void' is `void :: Void -> a', which ideally would be defined as `void v = case v of {}', if that syntax were allowed
09:46:53 <xplat> (you can't have polymorphic strict functions without a class context for obvious reasons)
09:47:02 <TimeCat> Saizan: I just want to make sure that it doesn't think that 6.12.1 < 6.6.x; there is no chance of that though right?
09:47:28 <hpc> xplat: bang patterns!
09:47:30 * hpc unhelps
09:47:40 <Saizan> TimeCat: that would be a major screw up :)
09:47:58 <xplat> hpc: actually, that's kind of helpful.  or you could use 'seq'
09:48:15 <ski> (Kamx : another workaround definition of `void' would be `void !_ = error "will never be reached"')
09:48:19 <xplat> which is itself a polymorphic strict function, duh.  i was being a little too idealistic :)
09:48:26 <TimeCat> Saizan: the thing that concerns me is that it says that "There is no available version of ghc that satisfies >6.6", when it is supposed to downlad and install dependencies
09:48:47 <ski> Kamx : and so the proper `Show' instance is `instance Show Void of showsPrec _ v = void v'
09:48:57 <Saizan> TimeCat: there's no ghc package on hackage
09:49:12 <copumpkin> cabal install ghc
09:49:21 <Saizan> TimeCat: can you try "cabal install --dry-run -v hint" ?
09:49:22 <dcoutts> heh
09:49:36 <Saizan> TimeCat: to see if cabal alone could install the package
09:49:45 * Saizan has no idea what capri is doing
09:49:54 <TimeCat> Saizan: well that makes sense, now I have to figure out what IS going on; yes i'll try that
09:50:07 <ski> Kamx : if/when you use `IO Void' (or `M Void' for any monad/applicative functor/functor `M'), then you shouldn't use `undefined :: Void' at *all*
09:50:47 <TimeCat> Saizan: ran into an issue, mostly that I already have hint installed, in my user package db
09:50:52 <badkins> I had a large tuple type that had the disadvantage of needing functions like the following: speed (f, _, _, _, _, _, _) = f
09:51:08 <Kamx> ski: Your point is, that empty data types are for situations, when you never want to describe any value of the type?
09:51:12 <badkins> with the help of folks here, I've changed to records, etc. as follows: http://hpaste.org/43825/mariokart_example
09:51:27 <badkins> but now I *still* have to create extra functions just to get at the data, so I think I'm missing something.
09:51:56 <badkins> given an instance of Driver, as an example, isn't it possible to extract pieces of it more directly ?
09:52:36 <elliott> Is there any library to modify the env vars? http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html has nothin'. Just getting.
09:52:46 <Saizan> if you had defined it like data Driver = Driver { entity :: Entity }, then entity would be already defined as an accessor for you
09:52:47 <ski> Kamx : yes .. just like `Either a b' is for situations when you want to described values which are either of type `a' or of type `b'
09:53:05 <badkins> Saizan: thx
09:53:09 <Saizan> but driver_name would still be a composition of name and driver 
09:53:21 <Saizan> *name and entity
09:53:47 <ski> Kamx : e.g. assuming `data Expr var = Var var | Int Integer | Add (Expr var) (Expr var)', then a (total) value of type `Expr Void' would represent an expression with no free variables
09:53:55 <badkins> so then: name (entity d)
09:53:57 <accel> > [1..10]
09:53:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:54:02 <accel> > True ? 0 : 1
09:54:03 <lambdabot>   Not in scope: `?'
09:54:15 <accel> does haskell provide C style expressions like ?: ?
09:54:23 <tromp> yes
09:54:23 <ski> Kamx : while `Expr String' would represent expressions where free variables are indicated by strings
09:54:32 <accel> tromp: what does it look like?
09:54:35 <tromp> it's called if then else
09:54:40 <ski> > if True then 0 else 1
09:54:40 <hpc> lol
09:54:40 <lambdabot>   0
09:55:00 <hpc> if-then-else behaves like ternary-if would in any other language
09:55:00 <accel> amazing
09:55:05 <accel> got it; thanks
09:55:14 <Kamx> ski: Okay... and is there is "standard" Void type in the libraries?
09:55:17 <hpc> ternary-if is an affront to decent people everywhere
09:55:19 <tromp> > ()
09:55:20 <lambdabot>   ()
09:55:22 <hpc> :P
09:55:23 <badkins> Saizan: awesome - that's what I was missing.
09:55:34 <ski> (note that `if'-`then'-`else' forms *expressions* in Haskell, not commands)
09:55:41 <accel> yeah
09:55:45 <xplat> it's only two functions, you should just be able to compose them where needed
09:55:46 <hpc> "commands" is not a concept in haskell :D
09:56:04 <ski> Kamx : unfortunately not, that i can remember (maybe category-extras has one .. ask edwardk)
09:56:33 <ski> hpc : well, it is, but it wasn't to that which i was referring ..
09:56:36 <tromp> closest thing to if command is when
09:56:41 <tromp> :t when
09:56:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:57:00 <ski> `do {command; ...; expression}'
09:57:15 <Kamx> so thanks for your answers... I
09:57:21 <Kamx> I'll probably think a bit more about that...
09:57:43 <hpc> ski: ach! don't confuse the newbies like that!
09:58:03 <ski> (hpc : you can probably define `_?_:_' in Agda2, btw :)
09:58:12 <hpc> > do {1; 2; 3; 4}
09:58:13 <lambdabot>   No instances for (GHC.Num.Num (m a),
09:58:13 <lambdabot>                    GHC.Num.Num (m a1),...
09:58:21 <hpc> > do {1; 2; 3; 4} 5
09:58:22 <lambdabot>   <no location info>: parse error on input `5'
09:58:27 <fryguybob> > let p ? (a, b) = if p then a else b in True ? (1, 2)
09:58:28 <lambdabot>   1
09:58:31 <hpc> > (do {1; 2; 3; 4}) 5
09:58:32 <lambdabot>   4
09:58:34 <fryguybob> > let p ? (a, b) = if p then a else b in False ? (1, 2)
09:58:35 <hpc> ha!
09:58:35 <lambdabot>   2
09:58:42 <ski> > do ()
09:58:43 <lambdabot>   ()
09:58:44 * hpc loves the Num monad
09:59:01 <hpc> (aka, caleskell functions)
10:00:07 * yitz wishes it were possible to turn off caleskell mode to demonstrate regular haskell 
10:00:19 <yitz> caleskell is fun though
10:00:27 <hpc> preflex: eval 5
10:00:39 <hpc> hmm, preflex doesn't mueval
10:00:52 <yitz> hpc: preflex is written in C
10:01:00 <hpc> humbug!
10:01:34 <yitz> @vixen are you better than preflex?
10:01:34 <lambdabot> i truely am
10:02:19 <edwardk> Kamx: the void package has one
10:02:30 <hpc> @vixen who is the bestest bot in the whole wide #haskell?
10:02:30 <lambdabot> Ooh, functional programmers are so hot!
10:02:34 <edwardk> Kamx: i pulled it out of category-extras and put it there
10:02:55 <accel> does haskell have a builtin for True -> 1, False -> 0 ?
10:03:07 <hpc> > fromEnum True
10:03:07 <Kamx> edwardk: ah thanks
10:03:08 <accel> i.e. convert x = if x then 1 else 0
10:03:08 <lambdabot>   1
10:03:12 <accel> fromEnum True
10:03:13 <hpc> > fromEnum False
10:03:14 <lambdabot>   0
10:03:19 <accel> hpc: thanks
10:03:25 <hpc> enums: they work, bitches
10:03:27 <hpc> :D
10:03:39 <hpc> fyi, this is covered in lyah
10:03:42 <hpc> and rwh
10:03:48 <hpc> which you should really read
10:04:01 <TimeCat> Saizan: so the issue seems to be something else, when I capri bootstrap and capri list I don't end up with ffi in my list, I think because when I ghc-pkg list it isn't their either...
10:04:31 <accel> man
10:04:40 <accel> are you guys going to form a "accel should read rwh" facebook fan club?
10:05:02 <jmcarthur> ye
10:05:03 <xplat> do {1; (+2)} $ 5
10:05:12 <xplat> > do {1; (+2)} $ 5
10:05:13 <lambdabot>   7
10:07:12 <xplat> accel: that's a good idea
10:07:27 <accel> alright; if it hits 20 ppl
10:07:54 <xplat> i'd do it right now but i'm not on facebook
10:07:55 <accel> then for each day,
10:08:07 <accel> I will not ask haskell questions on IRC, unless I first read a chatper of RWh that day
10:08:21 <accel> xplat: ha; neiter am I; counting on haskell types to remain off facebook
10:08:51 <yitz> > let convert = length . filter id . (:[]) in map convert [False, True]
10:08:52 <lambdabot>   <no location info>: lexical error at character '\FS'
10:09:23 <yitz> > let convert = length . filter id . (:[]) in map convert [False, True]
10:09:25 <lambdabot>   [0,1]
10:10:40 <accel> > fromIntegral (fromEnum False)
10:10:41 <lambdabot>   0
10:10:46 <accel> > fromIntegral (fromEnum True)
10:10:47 <lambdabot>   1
10:10:54 <hpc> yitz: enterprise!
10:11:04 <hpc> spock would be pleased by your needless layering
10:11:17 <Philonous> When creating a FunPtr from a haskell function via a ffi wrapper, will that prevent any captured objects from going out of scope? And is that why I need to call freeHaskellFunPtr ?
10:11:45 <yitz> hpc: thanks. my only regret is that my use of monads was only implicit
10:12:15 <hpc> you can also use Category.id
10:12:21 <hpc> (<<<) instead of (.)
10:12:25 <yitz> hpc: good ideas
10:12:28 <hpc> and return instead of (:[])
10:12:37 <hpc> or better, pure
10:12:48 <hpc> then instead of map
10:13:08 <hpc> use (\f -> (pure f) <*>))
10:13:15 <edwardk> hpc: or Category..
10:13:19 <hpc> :D
10:14:01 <mux> I'd rather use <$> :-P
10:14:05 <hpc> don't forget to add some synonyms for id in there
10:14:12 <hpc> for fun and extraneous line noise
10:14:17 <edwardk> mux: yeah
10:14:28 <hpc> bonus points for writing the entire function pointfree, with no spaces
10:14:45 <edwardk> or parentheses
10:14:46 <mux> I just did
10:14:57 <mux> without parentheses it's harder :-P
10:14:58 <hpc> no, parens are enterprise synergy
10:15:06 <hpc> and they make your code webscale :D
10:15:07 <mux> well
10:15:08 <mux> fmap
10:15:42 * hackagebot ListLike 3.0.1 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-3.0.1 (JohnLato)
10:16:56 <elliott> Is there no "safe" way to index a list without checking its length? I was sure there was, but it seems like you'd have to do !! and catch the exception.
10:17:29 <hpc> elliott: write !?! perhaps
10:17:42 <hpc> and replace the error with Nothing
10:17:58 <mux> find (== x)
10:18:01 <elliott> hpc: !?!. nice.
10:18:05 <elliott> mux: requires Eq.
10:18:16 <mux> oh, indexing
10:18:17 <mux> sorry
10:18:23 <elliott> yeah
10:18:32 <hpc> > let (!?!) = (+) in 5 !?! 4
10:18:33 <lambdabot>   9
10:18:35 <elliott> find ((== 3) . fst) . zipWith [0..]
10:18:37 <elliott> WOO
10:18:38 <elliott> :-D
10:18:39 <mux> indexing is bad anyways
10:18:41 <mux> :-)
10:18:44 <mux> well, for lists
10:18:51 <c_wraith> elliott: if you're indexing more than once, you probably don't want a list anyway
10:18:53 <elliott> getEnvironment returns a list, it's not my fault :-P
10:18:57 <elliott> I don't really have a choice
10:19:06 <hpc> using !! on the environment is icky
10:19:11 <elliott> hpc: Not my fault.
10:19:12 <hpc> shove it in a map
10:19:14 <elliott> I explicitly have to implement that.
10:19:18 <elliott> nope
10:19:21 <hpc> D:
10:19:25 <elliott> it's literally "get the Nth environment variable"
10:19:26 <mux> why would you want an environment variable at a specific index?!
10:19:35 <elliott> mux: because that's what I have to do
10:19:37 <elliott> don't blame me
10:19:37 <hpc> oh god, it's homework isn't it?
10:19:49 <mux> sounds retarded; I _don't_ blame you though :-)
10:20:01 <elliott> hpc: no
10:20:11 <elliott> hpc: http://www.rcfunge98.com/rcsfingers.html#EVAR <-- behold the nonsensicality
10:20:53 <zygoloid> @type (listToMaybe .) . drop -- elliott 
10:20:54 <lambdabot> forall a. Int -> [a] -> Maybe a
10:20:56 <mux> :t listToMaybe . dropWhile ((<=i) . snd) . zip [1..]
10:20:57 <lambdabot> forall a. (Num a, Enum a) => [Expr] -> Maybe (a, Expr)
10:21:00 <mux> uhoh
10:21:02 <hpc> wow
10:21:13 <hpc> a funge interpreter
10:21:14 <mux> yeah; just drop, my version is just retardedly more complicated
10:21:19 <elliott> hpc: yep
10:21:34 <zygoloid> elliott: is this a constant index?
10:21:35 <hpc> ooh, drop is clever
10:21:46 <hpc> > drop 100 [1..4]
10:21:47 <lambdabot>   []
10:21:55 <elliott> zygoloid: no
10:22:03 <hpc> why bother zipping? you just drop i
10:22:03 <xplat> so you have legacy software in befunge that needs supported?
10:22:10 <zygoloid> haha
10:22:13 <mux> hpc: I already said that was stupid :-)
10:22:18 <hpc> oh lol
10:22:19 <mux> no need to rub my nose in it
10:22:24 <hpc> didn't see that
10:22:26 <mux> it's wrong also, it missed a final fst :-P
10:22:44 <elliott> <xplat> so you have legacy software in befunge that needs supported?
10:22:45 <elliott> absolutely
10:22:50 <elliott> mission-critical legacy software
10:23:00 <elliott> btw: no portable way to set environment variables in haskell = sad
10:23:17 <hpc> yeah, i wanted that too, for my website
10:23:20 <hpc> i forget why, now
10:23:34 <c_wraith> wanted to shell out to some other program that needed some env variables set?
10:24:40 <xplat> wow, sometimes haskell has some really inexplicable library omissions ...
10:25:06 <edwardk> xplat: ?
10:25:08 <zygoloid> yeah, like an unmolested argv[0] would be nice too
10:25:27 <xplat> not being able to set environment variables (portably)
10:25:38 <elliott> <c_wraith> wanted to shell out to some other program that needed some env variables set?
10:25:41 <elliott> no: again, it's in the fingerprint spec
10:25:54 <edwardk> ah
10:25:56 <c_wraith> elliott: I was asking hpc if that's why he wanted to set env args
10:25:58 <elliott> ah
10:26:33 <xplat> there are lots of good reasons though, for example a program could need env variables set, or you could be writing a shell
10:26:36 <mux> xplat: that's normal: getenv() is in the C standard, setenv() is only in POSIX
10:26:51 <mux> xplat: so it totally makes sense for Haskell to only export setEnv in System.Posix.env
10:27:32 <xplat> well, i guess that's a good point
10:27:46 <hpc> oh, i remember now
10:27:56 <hpc> it was something stupid to do with lighttpd
10:28:06 <hpc> and somehow that seemed like the way to fix it at the time
10:28:21 <hpc> that was before i made my CGI monad sane
10:28:38 <zygoloid> why should a /language/ standard (for a language other than haskell) be more significant than an /operating system/ standard?
10:28:43 <elliott> mux: wow, that's stupid on C's behalf
10:29:07 <zygoloid> i agree that what's in posix isn't really relevant since haskell wants to target windows etc, but why is the C standard library especially relevant?
10:29:26 <hpc> isn't windows written in C?
10:29:28 <mux> elliott: it's not like setenv() is all that useful or even sane
10:29:46 <elliott> mux: I have to do it :P
10:29:59 <TimeCat> ok so I seem to need package ffi, does any one know where to find it? Is it obsolete?
10:30:09 <mux> elliott: the only time you're supposed to need to set environment variables is for subprocess, and C doesn't deal with forking process, it's oustide its territory
10:30:13 <hpc> @hackage ffi
10:30:14 <lambdabot> http://hackage.haskell.org/package/ffi
10:30:15 <mux> subprocesses*
10:30:37 <elliott> mux: Or when implementing Funge :P
10:30:42 <mux> and execve() allows you to set the environment
10:30:45 <mux> of course
10:31:06 <mux> so it makes setenv() relatively useless
10:31:16 <mauke> yitz: preflex is (mostly) haskell
10:31:26 * mux bbl &
10:32:21 <zygoloid> mux: on the other hand, execve is not in the C library. system is, but doesn't support setting env vars
10:32:25 <TimeCat> 404 Not Found
10:32:27 <TimeCat> The requested resource was not found: no such package 'ffi'
10:32:33 <edwardk> zygoloid: mostly because you can't really rely on said operating system standard to be implemented portably. With NT, microsoft started offering a "POSIX" subsystem, but to use it you had to cut off access to basically everything that made Windows usable. they did it to be able to claim compatibility and win bids, but nobody uses it.
10:33:19 <zygoloid> edwardk: that's not really what i'm asking. not, "why not posix?", rather "why c?". the only reason i can see is convenience.
10:33:44 <elliott> Is there a high-resolution clock interface other than the clock package on hackage which seems posix-only?
10:34:09 <edwardk> elliott: lemme know if you find one, i need one too
10:34:15 <elliott> edwardk: oh joy
10:34:26 <zygoloid> for instance, i don't know of any platform which can provide getenv but not setenv. so why does haskell only provide getenv?
10:35:45 <sproingie> edwardk: interix has replaced the posix subsystem now, so it's pretty compatible.  problem is its still a different subsystem so you can't mix them.
10:36:17 <yitz> mauke: oh, i apologize. glad to hear that it's haskell!
10:36:34 <elliott> Interix is fun :P
10:36:41 <elliott> edwardk: actually. doesn't the time library offer picoseconds?
10:36:48 <elliott> pretty sure the seconds field is fixed-precision picoseconds
10:36:58 <yitz> mauke: i thought i remember you saying it was in C a long time ago, in its early days. but i must be mistaken
10:37:41 <Cin> Has anyone called Haskell from PostgreSQL as a C-Language function?
10:38:19 <FunctorSalad> getting started with gtk2hs and changed the tutorial http://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro to use widgetShowAll instead of widgetShow because otherwise it wouldn't display any widgets... just checking whether this is the proper thing to do ;)
10:38:56 <zygoloid> *summon ManateeLazyCat*
10:39:10 <thoughtpolice> Cin: i haven't seen anything from it, but you should be able to 'foreign export' your function to the C world and load it as a shared library and call (i have limited postgres knowledge, so i'm just guessing that's the correct route)
10:39:25 <FunctorSalad> (the window in that tutorial doesn't *have* any child widgets, but I added some and was surprised that they weren't there)
10:39:36 <thoughtpolice> Cin: you will need to make sure you set up the ghc runtime before calling your function, though. check the GHC manual for details
10:40:00 <thoughtpolice> (normally just a call to __hs_init, followed by your function, then call __hs_exit when you're done)
10:40:39 <Cin> I was just curious, not planning on doing it. But thanks anyway. :p
10:41:18 <FunctorSalad> (going to try to make a tree view displaying arbitrary Data.Data.Data, seems easy enough :))
10:44:22 <edwardk> elliott: on paper. in practice it is nigh unusable, because you can't get it out without going through Rational, because ashley is paranoid about exporting constructors, and he doesn't provide any access to any high resolution timers to populate it at anything better than millisecond resolution
10:44:52 <elliott> edwardk: indeed
10:45:16 <edwardk> elliott: i actually had to resort to making up my own time types for reactor because i couldn't use those out of time.
10:45:22 <edwardk> which strikes me as a terrible design flaw
10:46:58 <edwardk> i just haven't been willing to sink the time into an alternate time library and deal with the community noise that would result when its just an ancillary concern for me
10:48:02 <elliott> Using the FFI to talk to perl's C API to implement a Funge interpreter. Where did I go wrong?
10:51:41 <aristid> elliott: you're doing everything right.
10:52:23 <elliott> aristid: Totally.
10:52:32 * sproingie ponders, staticly typed Befunge.  StrongFunge.
10:53:20 <elliott> sproingie: There's A Fingerprint For That. OK, there isn't, but there could be. There's one for time travel and another for multiple Funge universes, strong typing would be weak in comparison.
10:53:32 <edwardk> spoingie: we need dependently typed strongfunge
10:53:41 <elliott> edwardk: What have I wrought.
10:53:58 <aristid> what about strongly typed unlambda?
10:54:16 <aristid> that's another big market segment, and closer to haskell's spirit
10:54:34 <sproingie> simply typed unlambda calculus?
10:54:55 <elliott> But Unlambda is impure!!!
10:54:59 <elliott> Clearly you mean Lazy K.
10:57:24 <ski> @type (listToMaybe .) . drop
10:57:25 <lambdabot> forall a. Int -> [a] -> Maybe a
10:57:40 <aristid> elliott: ok. strongly typed lazy k
10:57:55 <ski> elliott : ^
10:58:10 <aristid> ski: safeIndex?
10:58:11 <elliott> aristid: good luck with that
10:58:15 <elliott> it's basically just SKI calculus anyway
10:58:21 <elliott> ski: already done :)
11:00:25 <ski> aristid : yeah, elliott asked for it
11:00:48 <ski> (though i'd s/drop/genericDrop/ (and possibly add a `SPECIALIZE' pragma))
11:01:38 <TimeCat> I am having trouble understanding packages that have a dependency on GHC and how it is resolved, anyone have any hints?
11:06:03 <xplat> i'm working on making it possible to extend postgresql in haskell, but i haven't got past preliminary research yet because there's too much you can only do in C functions so i'm trying to find a sneaky way to make haskell functions look like C
11:06:18 <xplat> (without doing it for each function individually)
11:06:26 <pedro3005> is "factorial n = product [1..n]" an inefficient implementation? Or is haskell's laziness smart enough to compute that efficiently?
11:06:58 <xplat> and they would have to look a lot like C, including having a symbol the dynamic loader could find
11:07:35 <xplat> all factorials are inefficient :)
11:07:56 <pedro3005> I said inefficient implementation though
11:08:08 <pedro3005> so I'm comparing to other implementations
11:09:07 <tibbe> pedro3005: that's a reasonable implementation
11:09:25 <tibbe> pedro3005: not quite as efficient as as a direct recursive definition
11:09:36 <Lemmih> pedro3005: But laziness doesn't come into play.
11:09:45 <accel> I want to learn about serialization in Haskell. What chapter of what book is good to read?
11:09:57 <pedro3005> well, I thought, when I do for instance factorial 10, it wouldn't actually generate the list [1..10] would it?
11:10:22 <accel> I want to learn about serialization in Haskell. What chapter of what book is good to read? (More complicated than show/read ... I need to store world state + all world objects, also curious about things like how deserialization works when types changes, etc ..)
11:10:39 <tibbe> accel: e.g. http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html
11:10:45 <ski> pedro3005 : it would only generate as much of the list as needed for `product' to proceed, in each step
11:11:06 <pedro3005> ski, 'product' is implemented as a fold?
11:11:06 <thoughtpolice> accel: look into the binary package. in general, deserializing things when your types change is rather nontrivial. you'd need an upgrade path
11:11:22 <xplat> foldl' (*) 1 is more efficient than product
11:11:23 <tromp> @src product
11:11:23 <lambdabot> product = foldl (*) 1
11:11:29 <tibbe> accel: Data.Binary.Put/Get provide low-level serialization of basic values (e.g. Ints, Words) and Data.Binary specifies a particular data format for type like lists and Maps
11:11:32 <accel> tibbe , thoughtpolice : thanks
11:11:41 <ski> (pedro3005 : so for long lists, the part before the "current element" can be GCed before the rest of the list is even generated, making it `O(1)' in space)
11:12:00 <ski> pedro3005 : if list fusion kicks in, you even avoid generate the cons cells at all
11:12:06 <tibbe> accel: Google's protocol buffers specify a data format that's robust for (some kind) of changes to the data types
11:13:01 <thoughtpolice> tibbe: yeah, the scope is limited to certain things (like, you cannot re-arrange fields in messages, nor can you remove required fields, and a few other things, etc) but it's very useful if you construct your messages properly
11:13:11 <tibbe> accel: most languages don't offer a story for data types that change, instead you have to look at libraries
11:13:18 <thoughtpolice> (we use protobufs here at work. tell the guys at google thanks for me tibbe :P)
11:13:24 <pedro3005> After I "folded" some element of the list, it is thrown away, correct?
11:13:30 <tibbe> thoughtpolice: heh
11:13:33 <pedro3005> during the folding process
11:13:42 <pedro3005> hmmm, I wonder..
11:13:45 <pedro3005> @src foldl
11:13:45 <lambdabot> foldl f z []     = z
11:13:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:13:47 <tibbe> thoughtpolice: I wish we had a super fast Haskell implementation
11:14:25 <ski> pedro3005 : yes, as long as nothing else references the initial elements of the list, they are garbage
11:15:02 <pedro3005> so would factorial n = fold' (*) 1 [1..n]  be as efficient as the classic recursive definition?
11:15:09 <pedro3005> err
11:15:11 <pedro3005> foldl'
11:15:11 * ski finds a potion labelled "N.I.K.E."
11:15:40 <ski> the accumulator version or the direct recursive version ?
11:15:59 <pedro3005> factorial 1 = 1; factorial n = n * factorial (n-1)
11:16:02 <thoughtpolice> tibbe: are the protobuf packages on hackage not that great?
11:16:02 <accel> tibbe: it's called a cluster
11:16:12 <accel> oh wait, of protobuf ?
11:16:26 <ski> pedro3005 : it should be more efficient that that (which is the nave, direct version)
11:16:29 <thoughtpolice> tibbe: never tested them for speed, so I couldn't be sure.
11:16:33 <tibbe> thoughtpolice: I haven't looked in depth but from what I've heard it could need some speed
11:16:44 <ski> (pedro3005 : also s/factorial 1/factorial 0/)
11:16:57 <pedro3005> factorial 1 is 1...
11:17:02 <pedro3005> oh
11:17:05 <ski> and `factorial 0' is also `1'
11:17:12 <pedro3005> yeah if I tried 0 it would break
11:17:30 <pedro3005> by accumulator version are you talking about a tail call recursion?
11:18:04 <ski> `factorial = loop 1 where loop acc 0 = acc; loop acc n = loop (acc * n) (n-1)'
11:18:17 <ski> is the accumulator version
11:18:29 <ski> (which also is tail-recursive, yes)
11:19:09 <thoughtpolice> pedro3005: looking at core, if you specialize factorial to Int (ghc will assume Integer by default it seems,) factorial n = foldl' (*) 1 [1..n] gets unboxed into a nice, tight loop
11:19:37 <ski> (`factorial n = loop n id where loop 0 k = k 1; loop n k = loop (n-1) (\f -> k (f*n))' is also tail-recursive, but isn't the (usual) accumulator version)
11:21:49 <gwern> arrgh why is reddit still down so I can't submit my SoC page
11:21:53 <gwern> what did I do to deserve this
11:22:12 <c_wraith> used reddit?
11:22:20 <gwern> well played sir
11:22:33 <ski> (damn c_wraith and his fast fingers :P)
11:24:51 <xplat> > foldl' (*) 1 $ take 1000000000 $ repeat (1 :: Int)
11:24:55 <lambdabot>   mueval-core: Time limit exceeded
11:25:02 <xplat> > foldl' (*) 1 $ take 100000000 $ repeat (1 :: Int)
11:25:06 <lambdabot>   mueval-core: Time limit exceeded
11:25:23 <xplat> > foldl' (*) 1 $ take 10000000 $ repeat (1 :: Int)
11:25:24 <lambdabot>   1
11:25:53 <ski> > foldl' (*) 1 (replicate 100000000 (1 :: Int))
11:25:57 <lambdabot>   mueval-core: Time limit exceeded
11:26:07 <ski> uh .. it worked just a moment ago
11:26:13 <ski> > foldl' (*) 1 (replicate 100000000 (1 :: Int))  -- tries again
11:26:17 <lambdabot>   mueval-core: Time limit exceeded
11:26:33 <xplat> i had the same experience ... 10^8 works in pm, not in the channel
11:26:37 * ski leaves this as an exercise for the reader ..
11:27:32 <ski> i think it might be that the timeout is not measuring time per query .. so if there's several queries at once, all suffer
11:27:32 <gwern> xplat: I figure it has something to do with muevals already running or OS caching
11:27:59 <gwern> ski: no, each request is a separate mueval with per-process kills
11:28:39 <pedro3005> @src foldl'
11:28:39 <lambdabot> foldl' f a []     = a
11:28:39 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:28:57 <ski> gwern : ok. i stand corrected
11:29:48 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
11:30:08 <ski>   foldl' f a (x:xs) = foldl' f $! f a x $ xs  -- if `$!' and `$' were left-associative ..
11:31:17 <xplat> fold' f a (x:xs) = foldl' f .! f a x $ xs   :)
11:31:37 <ski> @hoogle (.!)
11:31:38 <lambdabot> No results found
11:33:30 <xplat> (f .! g) x = let !y = g x in f y
11:33:42 <xplat> i guess my above def'n of foldl' might be wrong
11:35:37 <ski>   foldl' f a (x:xs) = (foldl' f .! f a) x xs  -- i suppose
11:35:58 <ski>   foldl' f a (x:xs) = foldl' f .! f a $ x $ xs  -- or this, with left-associative `$'
11:39:19 <kniu> Yo
11:39:37 <kniu> what was that library that lets me use (.) as fmap?
11:39:43 <banisterfiend> what's a typical application of foldr that you cant do with a foldl?
11:39:48 <xplat> it seems like with the extremely limited interface that goes along with dlopen my best bet is to just create a bunch of dummy entry points and associate them with real functions at load time
11:40:09 <xplat> banisterfiend: anything on infinite lists
11:40:37 <zygoloid> kniu: import Prelude hiding ((.)); (.) = fmap
11:40:40 <zygoloid> no library required
11:40:43 <kniu> well
11:41:06 <banisterfiend> xplat: can u give more of an example, i dont quite get waht u mean :/\
11:41:08 <zygoloid> using a library for this would require /more/ keystrokes, since you'd still need to hide (.) from the Prelude
11:41:15 <kniu> I usually don't like to use the Prelude.
11:41:20 <xplat> foldl on an infinite list is an infinitely high tower of applications that can't be built nevermind run, foldr on an infinite list is an infinitely deep stairwell you can go down lazily
11:42:04 <pedro3005> but wouldn't a foldr "start at infinity" and then regress?
11:42:15 <Philippa> is there any situation where a foldl might consume less memory than a foldl'?
11:42:30 <Philippa> (I've a feeling there ought to be, but I'm not thinking clearly enough to characterise it)
11:42:45 <kniu> I think what I'm trying to ask is,
11:42:57 <xplat> pedro3005: if you write a foldl or a foldr, the foldl will begin with an infinite number of parens, but the foldr has them at the end
11:43:12 <kniu> what was that library with a whole bunch of other useful stuff that also redefines (.) to be fmap,
11:43:28 <kniu> and is also something Arrow related?
11:43:39 <pedro3005> xplat, hmmm... can you give an example perhaps?
11:43:42 <zygoloid> the arrow-related one does not define (.) to be fmap.
11:43:53 <zygoloid> it defines (.) to be (<<<), which is flip (>>>)
11:44:16 <kniu> zygoloid, okay thanks
11:44:21 <kniu> I must have remembered it wrong.
11:44:54 <zygoloid> that's in Control.Category (or Control.Arrow for older versions of base)
11:47:03 <ski> Philippa : not sure this is a good example, but `last = fromJust . foldl (flip (mplus . Just)) Nothing' ?
11:47:14 <copumpkin> > liftM2 (=<<) zip (tail . tails) [1..4]
11:47:15 <lambdabot>   [(1,2),(2,3),(3,4),(1,3),(2,4),(1,4)]
11:47:31 <ski> @type \a b -> mappend a (b `asTypeOf` Nothing)
11:47:31 <lambdabot> forall a. (Monoid a) => Maybe a -> Maybe a -> Maybe a
11:47:36 <ski> @type \a b -> mplus a (b `asTypeOf` Nothing)
11:47:38 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
11:48:48 <ski> (as people have mentioned before, the former ought to be `Semigroup a => Maybe a -> Maybe a -> Maybe a')
11:49:00 <copumpkin> omg it's a tibbe
11:50:22 * ski . o O ( "Schniarf !" )
11:50:29 <aristid> tibbe == Johan Tibell?
11:50:49 <ski> try `/whois tibbe tibbe' :)
11:51:02 <aristid> ah, right.
11:51:07 <gwern> tibbe sounds like a funny verb
11:51:10 <gwern> obscene, even
11:51:17 <tibbe> aristid: yes
11:51:29 <gwern> 'As I squirmed under the mirror ceiling, I could feel her tibbeing me over and over'
11:51:33 <copumpkin> lol
11:52:04 <aristid> tibbe: i just got a mail from michael snoyman, saying "Also, I had a conversation with Johan Tibell, who gave me some ideas for WAI/http-types we might want to consider concerning representation of ASCII data."
11:52:14 <aristid> tibbe: could you tell me what those ideas were? *curious*
11:52:29 <tibbe> aristid: in a bit, little wrapped out atm
11:52:34 <tibbe> but later, sure
11:52:39 <aristid> k, thanks
11:52:56 <xplat> @type ($ repeat ()) . ($ undefined) . foldr . const
11:52:57 <lambdabot> forall a. (a -> a) -> a
11:53:05 <gwern> so, can anyone think of any way to measure the popularity of a package besides either reverse dependencies or package download stats? reddit traffic maybe?
11:54:00 <xplat> (a function which is exactly what its type suggests)
11:54:17 <aristid> gwern: weighted sum of reverse dependencies and package download stats.
11:54:29 <gwern> aristid: -_-
11:54:39 <aristid> ok, that was a cheap answer, sorry :D
11:54:44 <gwern> aristid: maybe then I can fit it to a nonlinear regression smoothed for annual variation!
11:54:53 <aristid> gwern: yay!
11:55:09 <aristid> gwern: actually i would use a linear regression tho :P
11:56:25 <copumpkin> gwern: google code search :P
11:56:34 <aristid> github search
11:57:11 <xplat> @type \f -> foldr (const f) undefined (repeat ())
11:57:12 <lambdabot> forall b. (b -> b) -> b
11:57:45 * aristid pats himself on the should for slightly varying old ideas to create new ideas.
11:57:51 <xplat> (a more pointed definition of the same)
11:57:51 <aristid> -should+shoulder
11:58:36 <aristid> @pl \f -> foldr (const f) undefined (repeat ())
11:58:36 <lambdabot> flip (flip foldr undefined . const) (repeat ())
11:58:46 <aristid> @pl \f u -> foldr (const f) u (repeat ())
11:58:46 <lambdabot> flip flip (repeat ()) . foldr . const
11:58:54 <aristid> @pl \u f -> foldr (const f) u (repeat ())
11:58:54 <lambdabot> flip flip (repeat ()) . flip (foldr . const)
11:59:10 <aristid> ok, \f u wins
11:59:24 <maltem> gwern: If hackage had some form of user comments, those could be a usable measure
11:59:35 <Kaidelong> how rude
11:59:39 <aristid> or reviews
12:00:17 <hpc> :t foldr . const
12:00:18 <lambdabot> forall a b. (b -> b) -> b -> [a] -> b
12:00:27 <gwern> aristid, copumpkin: what would a google code or github search reveal that reverse deps wouldn't?
12:00:36 <gwern> maltem: that would be nice, but it doesn;
12:00:44 <aristid> gwern: a weighted sum of downloads, reverse dependencies, google code search results, github search results, number of user comments, number of reviews, positivity of reviews
12:01:06 <copumpkin> projects/nonlibraries that aren't on hackage that use the package and more importantly, specific modules in it
12:01:08 <aristid> gwern: not all haskell stuff is on hackage, so a google code/github search would broaden the base
12:01:09 <gwern> aristid: there aren't any user comments or reviews! your weights = +0!
12:01:28 <aristid> gwern: i'm ready for the future!
12:01:39 <gwern> aristid is enterprise-ready
12:01:53 <aristid> haha yay
12:02:01 <xplat> aristid is ready for a 5 year mission
12:02:24 <aristid> but i don't want to live on mars
12:02:27 <gwern> or a three hour tour
12:02:29 <gwern> a three hour tour
12:03:19 <aristid> gwern: ??
12:03:34 <xplat> has GHC been ported to coconuts yet?
12:03:40 <gwern> aristid: 'the weather started getting rough' ...?
12:03:51 <aristid> xplat: GHC's bootstrapping has been broken for a while
12:04:05 <aristid> gwern: is that from an ad? i don't tend to receive english ads here
12:04:08 <xplat> better fix that first ...
12:04:16 <xplat> aristid: an old tv show
12:04:27 <gwern> aristid: it's from the theme to _Gilligan's Island_
12:04:28 <aristid> ok, same problem
12:04:35 <aristid> gwern: which i never heard of
12:04:38 * gwern feels old
12:04:40 <thoughtpolice> xplat: ghc's bootstrapping for porting is incredibly fragile from what I understand; it worked for a time before ghc 6.12 was released, but broke incredibly fast
12:04:48 <thoughtpolice> (like, within 3 days)
12:04:56 <gwern> hahah. ha?
12:05:11 <xplat> it would probably work better if ghc could crosscompile properly ...
12:05:24 <thoughtpolice> xplat: combined with the fact it's practically impossible (or at least ridiculously hard) to roll back GHC, *and* rollback the stuff in libraries/ to the proper state via darcs and, well...
12:05:26 <aristid> "and aired for three seasons on the CBS network, from September 26, 1964, to September 4, 1967"
12:05:34 <aristid> gwern: you saw that in the original?!
12:05:38 <thoughtpolice> xplat: simon m has some notes on actual cross compilation, and it's something that should be done IMO
12:05:41 <gwern> xplat: maybe someone will pick up the LLVM crossport work. that's one of my favorite SoC proposals
12:05:44 <gwern> aristid: no
12:05:52 <thoughtpolice> xplat: http://hackage.haskell.org/trac/ghc/wiki/CrossCompilation < proposed idea
12:06:16 <aristid> gwern: cause you would REALLY be old then :P
12:06:18 <thoughtpolice> xplat: personally I would like to see all effort directed towards actual cross compilation support instead of people just going off and randomly hacking the GHC build system to 'sorta work'
12:06:32 <gwern> aristid: I'd be in my 50s. come on
12:06:33 <copumpkin> same
12:06:38 * ski read that as "CPS network" ..
12:06:42 <xplat> aristid: it's considered a 'classic' tv series in the US and has been rerun almost continuously for decades, probably to thehis very day
12:06:46 <thoughtpolice> see: halvm (which goes through some insane tricks to work,) or ghc-iphone, which just had a lot of extra stuff that was never accepted mainline (because it wasn't of good enough quality)
12:07:04 <kmc> or my android patches (to be released soon?) which are 10x worse
12:07:08 <aristid> gwern: i guess SPJ or augustss might have seen it in the original
12:07:12 <aristid> xplat: i see
12:07:15 <gwern> aristid: see?
12:08:21 <aristid> gwern: so, which rerun did you see?
12:08:27 <gwern> aristid: 90s
12:08:27 <thoughtpolice> if GHC could cross compile, it would make an insane amount of headaches go away. I mean, until linux 2.6.34 or something, ARM distros couldn't even address more than 256mb of RAM - have fun compiling GHC on that
12:08:44 <aristid> gwern: i actually watched tv back then! but not american tv.
12:08:54 <thoughtpolice> (and i've done it before, when I compiled GHC on the PS3 when linux was still supported - only 256mb RAM on the main PPU. you better have about 9 hours to spare)
12:09:55 <gwern> give me enough swap and a place to stand...
12:09:56 <aristid> thoughtpolice: i hope cross-compiling is sufficiently high on the list of priorities
12:10:17 <thoughtpolice> maybe after I get plugins into GHC HEAD, I'll take a stab at talking to simon m or igloo about it, because I think it would be incredibly beneficial to a huge amount of people
12:10:24 <xplat> thoughtpolice: you can probably put linux on the PS3 again now, since the signing key was broken
12:11:22 <Igloo> thoughtpolice: I'm pretty sure Debian Arm had ghc before that
12:11:29 <kmc> isn't it a wonderful feeling to pay $600 for a piece of hardware and then have to wait three years for some dodgy haxors to crack it so that you can use your own property?
12:11:49 <copumpkin> > Data.Set.singleton (+1)
12:11:50 <lambdabot>   Not in scope: `Data.Set.singleton'
12:11:57 <copumpkin> > S.singleton (+1)
12:11:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:11:58 <lambdabot>    arising from a use of `...
12:12:05 <copumpkin> :O
12:12:06 <hpc> kmc: isn't it more wonderful when functionality you had when you bought it is retroactively taken away?
12:12:18 <thoughtpolice> Igloo: yeah I noticed that, i think they still do have 6.8 binaries for ARM available, it's just not fun. having a stage2 compiler that runs on x86 and just emits ARM binaries (using the codesourcery toolchain or something) would be a hell of a lot better, IMO
12:12:20 <copumpkin> kmc: you calling me dodgy?
12:12:24 <copumpkin> oh I see
12:12:24 <kmc> copumpkin, yes!
12:12:39 <kmc> Debian has GHC 6.12 binaries for ARM
12:12:43 <thoughtpolice> really?
12:12:44 <kmc> (unregisterised via-C)
12:12:45 <kmc> yep
12:12:47 <thoughtpolice> i've been out of the loop, then
12:12:50 <Igloo> thoughtpolice: Oh, yes, cross compilation would certainly be good
12:13:17 <thoughtpolice> Igloo: and I'm sure you don't have a lot of fun when it comes time to update the porting infrastructure to work (i.e. when people complain a ton :P)
12:15:25 <monadic_kid> i'd like to see more people working on jhc, it's got a lot better in the recent few months, the only problem I've had with it now is trying to use transformers package, the package itself is built in jhc but if you try to use a monad transformer stack that includes IO jhc can't compile it
12:16:14 <monadic_kid> well John will look into at some point and hopefully he can figure out but i wish more people would help him out
12:16:36 <thoughtpolice> the fact that JHC requires special tweaks because the parser/typechecker has bugs resulting in erroneous code, meaning you have to specifically 'shift things around' for JHC to understand it properly, makes it a non-starter for me. also, jhc has a radically different compilation model, and is relatively undocumented. there are lots of parts of the code that can subtly break if you aren't aware of almost everything
12:16:56 <thoughtpolice> (me and Lemmih went through this a lot when the first revision of LHC was based on JHC - luckily john took a bunch of our patches into his repo)
12:17:02 <thoughtpolice> john is very receptive and quick to fix bugs, though
12:17:07 <thoughtpolice> it's just hard to contribute to, IMO
12:17:14 <monadic_kid> thoughtpolice: that's mostly fixed
12:17:23 <monadic_kid> thoughtpolice: i've been helping out on that
12:17:49 <xplat> with respect, it doesn't sound 'mostly fixed' if it can't compile a monad transformer stack with IO
12:18:16 <thoughtpolice> monadic_kid: last time I checked, jhc still can't properly compile pidigits from the shootout properly; the results are garbage. i also tested the latest JHC about a week ago on a simple program that simply did not even execute because of an RTS abort
12:18:48 * kmc has compiled GHC for ARM using GHC for ARM inside qemu-system-armel on a Core 2 Duo
12:18:51 <kmc> it's not *that* bad
12:19:03 <monadic_kid> xplat: I'm talking about erroneous C code not everything
12:19:33 <Lemmih> This reminds me, I should upload the new benchmark results.
12:19:43 <thoughtpolice> monadic_kid: to be fair though, I should definitely report this to john, i just haven't had time (and won't for the next few days since I'll be at the hackathon working on GHC plugins)
12:20:27 <thoughtpolice> JHC does tend to kick a ton of ass when it works though, i'll give it that. john has done some really interesting work if you ask me
12:21:21 <monadic_kid> thoughtpolice: I've managed to get various small apps working since I've been contributing to bug reports and John's been fixing them. There was some serious issues before when trying to use Haskell C binding APIs and most of the erronous C code generation is sorted.
12:22:11 <gwern> thoughtpolice: it's kind of a pity that John is such a contrarian about cabal
12:22:27 <dcoutts> aye
12:22:42 <jmcarthur> yeah i don't really understand that
12:22:51 <hpc> cabal does need a lot of work, to be fair
12:22:54 <dcoutts> e.g. if we had a little more communication then I expect cabal could work with jhc reasonably well
12:22:55 <gwern> I mean, I can sort of understand opposing early cabal. there were a *lot* of problems. but 2011 cabal is pretty decent stuff, and definitely better than autotools
12:23:04 <hpc> the user/global libs thing causes lots of trouble
12:23:09 <monadic_kid> thoughtpolice: I've managed to compile quite a few of more lazyfoo SDL ports working JHC, had it working on Wii  homebrew as well. All i've been doing is testing and emailing bug reports and John tends to look into them,
12:23:11 <thoughtpolice> monadic_kid: if you have the time, please tell him to look at pidigits! http://shootout.alioth.debian.org/u64/program.php?test=pidigits&lang=ghc&id=4
12:23:15 <jmcarthur> makefile magic seems much more complicated to me
12:23:17 <thoughtpolice> monadic_kid: i'd really like to see how well JHC does there
12:23:24 <Egbert9e9> is darcs still the haskellian choice or git is getting accepted too?
12:23:36 <jmcarthur> and didn't somebody get jhc to work with cabal and stick it on hackage? (an old version by now)
12:23:38 <thoughtpolice> monadic_kid: it compiles and executes for the most part, but the actual results are garbage.
12:23:49 <jmcarthur> or maybe they just did by hand some of what the makefile does
12:23:55 <gwern> jmcarthur: well, that happened with drift
12:23:57 <thoughtpolice> jmcarthur: lemmih did, shortly before we forked JHC and made the first revisioin of LHC, based on it
12:23:58 * gwern did that
12:24:09 <thoughtpolice> *revision
12:24:12 <hpc> the large hardon compiler?
12:24:14 <hpc> :P
12:24:14 <Lemmih> thoughtpolice: I thought that was because jhc doesn't support bignums.
12:24:16 * hackagebot throttle 0.1.1 - Throttle TCP/IPv4 connections to a given server.  http://hackage.haskell.org/package/throttle-0.1.1 (ChrisDone)
12:24:26 <dcoutts> jmcarthur: I was thinking of the other way round, cabal has been able to build packages using jhc, I suspect it doesn't work with current jhc releases
12:24:46 <jmcarthur> Egbert9e9: a lot of people use git, hg, darcs, whatever. use what you are comfortable with
12:24:47 <dcoutts> and jhc is nowhere near being able to build cabal itself
12:24:52 <dcoutts> at least not last time I tried
12:24:53 <thoughtpolice> Lemmih: ah, you may be right. most of my JHC knowledge is gone these days
12:25:08 <jmcarthur> ah, yeah that's a shame as well
12:25:23 <Egbert9e9> jmcarthur, I see. thanks
12:25:24 <gwern> (there's a lot of haskell on github these days. the future doesn't look too great for darcs)
12:25:27 <gwern> (worse is better)
12:25:42 <jmcarthur> Egbert9e9: but if you are at all curious about darcs, i recommend it! :D
12:26:04 <gwern> hm. my drift repo is corrupted.
12:26:17 <jmcarthur> Egbert9e9: there are features git has that darcs doesn't, though, like stash and in-place branches
12:26:23 <thoughtpolice> i don't know if i agree with the implication that git is worse than darcs, but darcs definitely still has usability down compared to git, no competition there
12:26:45 <Egbert9e9> i don't even know what do they mean... -_-
12:26:52 * hpc just uses svn
12:27:00 <gwern> oh good, drift-cabalized still installs. no need to edit or upload a new one
12:27:02 <Egbert9e9> * < cvs
12:27:02 <hpc> it's easy to install and is just good enough
12:27:07 <thoughtpolice> but for example, in GHC, darcs makes it extremely complicated to roll back patches to get the tree to a previous state, because you not only have to roll back GHC, but also base, template-haskell, etc, because GHC changes affect all of those
12:27:16 <thoughtpolice> and that is a HUGE pain in the ass if you're trying to figure some things out
12:27:19 <kmc> Egbert9e9, i'm a haskell fanatic and i much prefer git
12:27:24 <jmcarthur> thoughtpolice: is that really darcs's fault though?
12:27:24 <kmc> and yes git has a steep learning curve
12:27:38 <Egbert9e9> kmc, i've used git a bit for really basic stuff
12:27:41 <jmcarthur> git is worse than darcs on very specific criteria
12:27:44 <aristid> thoughtpolice: would it really be better with another system?
12:27:45 <Egbert9e9> like, push and pull
12:27:51 <Egbert9e9> that's all, basically
12:27:54 <hpc> aristid: lol
12:27:59 <Egbert9e9> oh, and there's commit
12:28:01 <aristid> hpc: ?
12:28:05 <kmc> Egbert9e9, what's ironic to me is that Git, despite being written in C and bash, has a very Haskell-ish internal data model
12:28:11 <hpc> aristid: it's funny because it's true
12:28:19 <copumpkin> darcs has grown on me a lot recently
12:28:20 <kmc> so i think the Haskell fanatics who support Darcs solely because it's written in Haskell are missing the point
12:28:28 <kmc> not to say there aren't other reasons to support Darcs
12:28:39 <aristid> kmc: git's data model is awesome and inspiring :)
12:28:43 <copumpkin> darcs has an interesting model
12:28:44 <thoughtpolice> jmcarthur: i'm not sure, if the libraries were tracked with GHC instead of independent repositories, it would make the problem basically non-existant, but that's currently not the case. i'm also not sure to what extent e.g. git submodules help
12:29:00 <aristid> thoughtpolice: git submodules are a piece of shit.
12:29:02 <kmc> aristid, yes, and git's command set is so big and crazy that the data model is the only thing to keep you sane
12:29:06 <jmcarthur> the appeal to darcs, to me, is that i just don't have to worry so much about what i do and don't want from another branch/repo
12:29:08 <thoughtpolice> also, the fact the GHC developers seem content with having base libraries in two different VCSs is, IMO, complete insanity
12:29:25 <gwern> kmc: even if darcs weren't better than git, we'd still have reason to support it. good PR, spinoff libraries (bytestring?), profiling stress, etc
12:29:29 <MarcWeber> The one thing I love about git is having remotes.
12:29:32 <hpc> thoughtpolice: quite a bit of GHC is insanity
12:29:33 <copumpkin> thoughtpolice: it's hard to transition everything over at once
12:29:39 <MarcWeber> That's why reasen to prefer it.
12:29:53 * hpc would keep the GHC source valid h98
12:30:06 <copumpkin> hpc: why?
12:30:07 <kmc> gwern, i'm not sure it's good PR... my small experience with using Darcs on the GHC tree has pretty well soured me on it
12:30:10 <copumpkin> fuck h98
12:30:11 <jmcarthur> MarcWeber: you mean such that you don't have to type our full URLs?
12:30:13 <hpc> so it can potentially be compiled by something other than itself
12:30:13 <thoughtpolice> copumpkin: I understand, I just think it'll bring everyone into a world of hurt before then. hopefully it won't take absurd amounts of time, though
12:30:20 <jmcarthur> *out
12:30:21 <aristid> gwern: and the fact that github already has tons of users and haskell is one of the most popular languages there
12:30:25 <jmcarthur> MarcWeber: or something else?
12:30:31 <kmc> and yes i realize that the GHC repo is not a typical case but... again, PR
12:30:36 <gwern> kmc: ok, how about bad PR? 'haskell community abandons only real application' 'Haskellers confess: Haskell intrinsically slow and painful'
12:30:40 <MarcWeber> jmcarthur: No, the ability to track many remote repositories easily using git remote add name url && git fetch name
12:30:50 <MarcWeber> without having to create a new direcotry fo reach.
12:30:58 <kmc> haha
12:31:00 <jmcarthur> MarcWeber: ah you mean having local copies of them
12:31:03 <thoughtpolice> since when has acquiring success been a part of the haskell community? :P
12:31:07 <jmcarthur> yeah, that is a nice feature
12:31:10 <gwern> kmc: even the people who don't normally pay attention to trolls like harrop will note any abandonment of darcs and correctly infer there are problems
12:31:15 <kmc> i think xmonad is a better example but w/e
12:31:16 <kulakowski> thoughtpolice: I thought the opposite was true
12:31:25 <aristid> gwern: but darcs is not haskell
12:31:38 <copumpkin> gwern: the problems are with the darcs model, not its implementation language, though
12:31:40 <jmcarthur> somebody should just settle the matter by remaking git in haskell
12:31:48 <thoughtpolice> someone already did
12:31:52 <gwern> copumpkin: and how should someone know that?
12:32:04 <thoughtpolice> evan laforge I think? it wasn't a total reimplementation, but it could read the git pack files and whatnot and reconstruct history
12:32:10 <monochrom> screw PR. screw NIH. screw advocacy. screw the proles.
12:32:10 <thoughtpolice> (i think he called it 'gat')
12:32:14 <jmcarthur> thoughtpolice: i only know of a very limited one
12:32:14 <copumpkin> gwern: by examining the algorithmic complexity of the operations
12:32:17 <jmcarthur> i think that's it, yeah
12:32:22 <kmc> monochrom, if there is any hope, it's with the proles
12:32:27 <aristid> monochrom: avoid popularity at all costs
12:32:37 <aristid> @quote at.all.costs
12:32:37 <lambdabot> Elly says: Rule 1 of malloc is the same as rule 1 of air travel: "Attempt at all costs to keep your number of landings equal to your number of takeoffs."
12:32:52 <monadic_kid> thoughtpolic: a few months ago I was testing out jhc with my haskell ports of lazyfoo SDL. At the time I had problems with jhc generating erronous C code (and shifting problem), bugs with forieng pointers coming from C bindings due to gcc strict-aliasing optimization, and the default option of using no garabage collector (region inference) casusing problems too. I sent various bug reports with test code, since then the latest version of jhc
12:32:52 <monadic_kid>  has all of those fixed (well i think I still had one time where C compile errors but I can't remember if that was a previous darcs version or the latest one). The only problem I have left with getting all of my lazyfoo ports working is the fact that I was using monad transformers with IO, I've sent a bug report about that about a week or 2 ago
12:33:06 <monochrom> the proles are irrational. there is no hope in the proles.
12:33:32 <aristid> monochrom: you are irrational too.
12:33:41 <hpc> monochrom: indeed; we must express hope as a proper fraction, so they join our cause
12:34:56 <thoughtpolice> monadic_kid: good! i would like to see JHC go places, it's just my (and Lemmih's) initial impressions when we tried to hack the code was "it was quite hard" and it was something of a turn off. i'd love to see JHC really usable, though, it's an amazingly interesting design space
12:35:15 <kmc> yeah, i think it's really important that there's work going into these non-GHC compilers
12:35:18 <kmc> even if most people will never use one
12:35:28 <thoughtpolice> monadic_kid: i do keep track of the development from time to time though, and see john has gotten rid of a lot of magic and added a lot of tests
12:35:32 <blueonyx> what monad(transformer?) thingy would you suggest if you have a monster of nested case .. ofs and ifs which handles different commands and a lot of JSON parsing and therfore Error handling?
12:35:32 <kmc> JHC, UHC, and Hugs have all spawned interesting ideas both in language and in implementation
12:35:36 <thoughtpolice> which is +++++++ good
12:35:52 <kmc> http://hackage.haskell.org/package/jspath  blueonyx
12:35:54 <kmc> not a monad
12:36:00 <kmc> just a little EDSL
12:36:55 <monadic_kid> thoughtpolice: the code base is quite huge and can be scary, my main interests in our easy cross-compiling with minimal dependencies on posix interfaces, and the obvious one being that it's a whole optimizing compiler 
12:36:59 <thoughtpolice> kmc: yes, I find JHC the most interesting personally. i think i remember john said he did somethings so differently "just to be different from GHC and explore the possible designs"
12:37:26 <kmc> i'd like to see a compiler that makes it really easy to add language extensions
12:37:29 <kmc> i think UHC is supposed to be that
12:37:41 <thoughtpolice> monadic_kid: for sure, and JHC has come a very, very long way since I remember it. hello world? jhc circa 2007 needed about 800mb of RAM and 20 minutes. jhc now? about 1mb of ram and 10 seconds
12:37:42 <copumpkin> alexsuraci: find a fix for your reddit issue?
12:38:05 <alexsuraci`> copumpkin: deleted my reddit cookies for now
12:38:14 <copumpkin> alexsuraci`: just browsing logged out?
12:38:17 <thoughtpolice> monadic_kid: but yes, the code base is very huge and scary, I can tell you that. there are lots of undocumented invariants and rules, and a large portion of the compiler exists in IO + IORefs, making certain things really hard to reason about
12:38:19 * hackagebot pvd 1.1.0 - A photo viewer daemon application with remote controlling abilities.  http://hackage.haskell.org/package/pvd-1.1.0 (RickardNilsson)
12:38:26 <alexsuraci`> copumpkin: yep
12:40:04 <thoughtpolice> monadic_kid: there was also lots of scary magic inside the compiler related to things like unboxing and integral/num etc. i think john has removed most of the integral/num magic, but I think parts of the magic to support things like directly unboxed values still linger (because john didn't account for them when he first did the design, and ended up adding them later. i think this was one of his biggest regrets)
12:41:09 <thoughtpolice> it's still a fraction of the size of GHC, though
12:41:26 <thoughtpolice> (i think jhc is like 30k LOC, GHC proper, excluding the runtime is something like 200k)
12:41:35 <thoughtpolice> probably more now
12:42:02 <monadic_kid> thoughtpolice: I just tried the pidigits code, I get an empty list error
12:42:17 <saml> @type const
12:42:18 <lambdabot> forall a b. a -> b -> a
12:42:41 <Lemmih> monadic_kid: What arguments did you use?
12:42:56 <Lemmih> monadic_kid: You might get that error if you didn't give it any.
12:42:57 <monadic_kid> ahhh
12:43:04 <thoughtpolice> monadic_kid: run it with 'pidigits 1000' for example
12:43:05 <monochrom> pidigits giving an empty list sounds scary. pi has no digits. :)
12:43:36 <thoughtpolice> there is no pi, only zuul.
12:43:47 <jmcarthur> pidigits gives apparrentaly valid output to me, but it's still the incorrect result
12:43:52 <jmcarthur> with jhc
12:44:40 <mcnster> q: is there a hs lib with bindings to the unix socket(2) call?
12:44:46 <jmcarthur> thoughtpolice: sloccount reports 240761 lines of haskell code in my slightly out of date checkout of the ghc repo
12:45:12 <monochrom> I think Network.Socket exposes enough of socket(2)
12:45:20 <jmcarthur> and sloccount doesn't include whitespace and comments
12:45:21 <monadic_kid> yeah I'm getting freaky values from it
12:45:28 <thoughtpolice> jmcarthur: for the whole tree? or the stuff under ./compiler?
12:45:39 <jmcarthur> thoughtpolice: ah that was including libs and junk
12:45:46 <thoughtpolice> (there's lots of random build tools and whatnot throughout the tree, including libraries)
12:45:57 <jmcarthur> thoughtpolice: 118791 under compiler
12:46:25 <blueonyx> kmc: nice one, but i already got Text.JSON.JSON instances for my datatypes, how do i get MyDataType from a Text.JSONb.JSON?
12:46:26 <kmc> mcnster, the 'unix' package has most of POSIX wrapped in a pretty direct way
12:46:28 <thoughtpolice> jmcarthur: i guess i made that same mistake when I measured last time, thanks. :) i'm running cloc on it now
12:46:40 <kmc> use the jsonb library insetead?
12:46:46 <thoughtpolice> jmcarthur: cloc reports:
12:46:47 <thoughtpolice> Haskell                        414          38081          63641         129226
12:47:02 <jmcarthur> i'm gonna pull new changes and try again
12:47:14 <thoughtpolice> (414 files, 38081 blank lines, 63641 comments, 129226 lines of actual code)
12:47:29 <jmcarthur> i was only counting haskell code, not all code
12:47:33 <thoughtpolice> jmcarthur: this repo is from early this week
12:47:47 <thoughtpolice> (this is also under ./compiler, not the main tree)
12:48:16 <jmcarthur> with a fresh pull:  haskell:     116199 (98.58%)
12:48:28 <mcnster> monochrom, kmc:  found it.  thanks much. :)
12:48:44 <jmcarthur> yacc:          1253 (1.06%); ansic:          390 (0.33%); perl:            34 (0.03%)
12:49:28 <gwern> if anyone is interested in reading material, I've posted http://www.gwern.net/Haskell%20Summer%20of%20Code.html to http://news.ycombinator.com/item?id=2199364
12:49:34 <gwern> got tired of waiting on reddit to stop being broken
12:49:54 <thoughtpolice> jmcarthur: cloc reports about 28k of source code for jhc-0.7.7, for the code under src/
12:50:02 <thoughtpolice> so, GHC proper is about 3x bigger
12:50:39 <gwern> not sure that speaks well of jhc
12:50:43 <gwern> ghc proper offers a lot
12:52:31 <kulakowski> gwern: I doubt it's a linear scale though. 2x code isn't 2x functionality.
12:52:42 <thoughtpolice> i feel that's a somewhat unfair comparison, considering JHC does not offer nearly as many features - why would it be surprising that it has much less code? the scale of features to code is not linear
12:53:14 <thoughtpolice> gwern: also, with any luck, you should be able to change that 2008 GSoC project for max's work into a 'success' soon :>
12:53:18 <gwern> my sentiment is that in between jhc's fewer features, being written largely by 1 guy, having a solid theoretical base, etc etc. it ought to be less than 1/3
12:53:21 <jmcarthur> ghc is 3.8 times more lines of code in all languages by my counts
12:53:27 <thoughtpolice> i've been pushing simon et al really hard to merge it, and i also have plans to extend it further
12:53:35 <thoughtpolice> so you can write cmm plugins
12:53:37 <gwern> thoughtpolice: yes yes we've discussed it before, until it's merged I can't in good faith mark it a success
12:53:45 <gwern> thoughtpolice: being merged is necessary but not sufficient
12:53:51 <monadic_kid> John did mention that at some point when the stability of jhc is much better he'd consider adding type family support, i don't think multi-param type-classes will ever be supported
12:54:07 <thoughtpolice> yes, operative word is 'soon'
12:54:09 <jmcarthur> and counting only haskell, ghc is 4.1 times more
12:54:27 <jmcarthur> this is comparing to a jhc stable version though, not the head of its repo
12:55:43 <thoughtpolice> hm wtf
12:55:48 <thoughtpolice> i'm CC'd on the ghc plugins trac ticket
12:55:52 <thoughtpolice> but I didn't see people replied!
12:55:53 <thoughtpolice> *gasp*
12:56:19 <monadic_kid> thoughtpolice: I'm kind of surprised that code doesn't work since I've had larger programs involving binding libraries working
12:56:35 <thoughtpolice> monadic_kid: yeah, it's somewhat hit or miss it seems
12:56:40 <monadic_kid> thoughtpolice: the output is really strange
12:59:07 <monadic_kid> thoughtpolice: I'll send an email about it
13:09:11 <monochrom> gwern: in these days of modern technology, don't forget that haskell-cafe and comp.lang.haskell still stand guard for thee!
13:10:09 <thoughtpolice> monadic_kid: awesome! like I said I should have but haven't had time, i'd like to see JHC kick some ass on the shootout programs (except the ones that are GHC specific, of course...)
13:13:37 <blueonyx> i dont get JSONb nor jspath :( are there any more examples/articles/blogs about them other than hackage and github? 
13:14:27 <xplat> holy toledo, postgresql-8.4 source is 17 megs
13:15:18 <int80_h> I have a reqState :: InfoValue. Now, InfoValue looks alot like a [String]. Is there a simple way to convert an type that looks like a [String] to a real one so I can then perform list operations on it?
13:15:32 <sgronblo> What exactly is the difference between currying and partial application? They sound pretty similar to me.
13:16:07 <kmc> the way i think about it is
13:16:08 <monochrom> related
13:16:21 <kmc> "currying" is a convention for how to encode multi-arg functions in a language that doesn't support them (like Haskell)
13:16:33 <kmc> you encode "A,B -> C" as "A -> B -> C"
13:16:44 <xplat> technically, currying is turning a function with multiple arguments, or a tuple of arguments, into a function that takes 1 argument and returns a function that takes 1 argument, and returns ... etc
13:16:57 <kmc> and you can also use the word "currying" to describe an operation which produces a function of this form from a function using a different convention
13:16:58 <kmc> :t curry
13:16:59 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:17:07 <xplat> but people often use the word 'currying' for partial application, informally
13:17:30 <kmc> strictly speaking Haskell has no "partial application" because every function has only one arg
13:17:42 <kmc> you can't apply only some of the args if there's only one
13:18:14 <third_contra_guy> Hi everyone
13:18:22 <kmc> but using the curried convention + having good syntax for it makes the language look a lot like it supports multi-arg functions and partial application of them
13:18:24 <xplat> i guess you could 'partially apply' in a different sense
13:18:54 <kmc> of course it's totally different at GHC's implementation level
13:19:07 <xplat> like length ==> \xs -> length [1:xs]
13:19:09 <kmc> it will uncurry your functions based on their syntactic definition, and create "partial application" objects in the heap as necessary
13:19:15 <sgronblo> so if you create function in a language which has multi-parameter functions (like javascript) that allows you to fill in part of the parameters and return a new function for that, it wouldn't be currying, but rather partial application?
13:19:34 <kmc> sgronblo, yeah
13:19:36 <xplat> sgronblo: right
13:19:47 <xplat> but people might call it 'currying' anyway
13:19:58 <sgronblo> yeah i guess it doesnt matter that much
13:20:33 <kmc> curry :: ((a,b) -> c) -> (a -> b -> c);  partialApply :: (((a,b) -> c), a) -> (b -> c)
13:20:54 <sgronblo> if the language doesn't have currying built in, then you're probably not gonna write your functions in a "curried style" and therefore it doesn't make any difference what you call your partialApplication function in that language :)
13:20:55 <kmc> so partialApply = uncurry curry?
13:20:59 <kmc> :t uncurry curry
13:21:00 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
13:21:54 <Eduard_Munteanu> :t uncurry (uncurry curry)
13:21:55 <lambdabot> forall b b1 c. (((b, b1) -> c, b), b1) -> c
13:22:11 <adu> Eduard_Munteanu: wow
13:23:00 <Eduard_Munteanu> Why wow?
13:23:19 <int80_h> I have a reqState :: InfoValue. Now, InfoValue looks alot like a [String]. Is there a simple way to convert an type that looks like a [String] to a real one so I can then perform list operations on it?
13:24:05 <third_contra_guy> I'm a complete haskell newbie, and my background is mostly object oriented languages. I want to write simple game in Haskell, and my problem is representation of objects, that have a state changing while program executes. What is the best way to do this in object oriented language?
13:24:14 <spetrea-home> guess what
13:24:17 <spetrea-home> I'm cooking fish
13:24:18 <spetrea-home> again
13:24:20 <spetrea-home> in a big way
13:24:52 <Eduard_Munteanu> int80_h: erm, what is InfoValue exactly?
13:25:05 <third_contra_guy> sorry, I meant functional lanuage
13:25:14 <elliott> How can one do truncate read-write and append read-write mode with System.IO? It apperas to have no such support (System.Posix.IO does)
13:25:41 <sproingie> third_contra_guy: that's one of the tricker problems in haskell.  FRP is one such approach.  The Yampa Arcade paper has a decent explanation of that.
13:25:41 <Eduard_Munteanu> third_contra_guy: you might want to look at the ST and State monads.
13:25:47 <monochrom> haskell is different enough from your past experience that diving-in does not work. I suggest learn haskell for its own sake first before writing a simple game.
13:26:06 <Eduard_Munteanu> and STRef/IORef
13:26:10 <monadic_kid> third_contra_guy: there are quite a few ways to go about this, the first step is try to think how you would emulate state changes? just think about it you'll probably get it quite quickly
13:26:28 <Eduard_Munteanu> Yeah, and what monochrom says. I doubt FRP is a first thing to go with.
13:26:42 <jmcarthur> or the final one either
13:26:46 <sproingie> third_contra_guy: the other is liberally using state in an overarching Game monad, then refactoring out pieces to pure code.
13:26:48 <jmcarthur> frp isn't done cooking yet
13:26:53 <Eduard_Munteanu> Yeah.
13:26:57 <int80_h> Eduard_Munteanu : http://hackage.haskell.org/packages/archive/curl/1.3.5/doc/html/Network-Curl-Info.html#t:InfoValue
13:27:02 <jmcarthur> at least not the general kind of frp that we're wanting to eventually have
13:27:24 <monadic_kid> third_contra_guy: what would be your initial guess? 
13:27:27 <elliott> Aha, figured it out.
13:27:33 <monochrom> but if you insist on what I see as self-implosion, firstly there are mutable variables in most haskell compilers too as a last resort, secondly state transition could be just a function S->S and you keep iterating over it if you want to be functional.
13:27:36 <sproingie> yah i can't quite get myself doing FRP til i can see how to easily do discrete events with it without some handwaving about how they're really just the same as continuous time
13:28:03 <int80_h>  Eduard_Munteanu: does that answer the question?
13:28:11 <Eduard_Munteanu> int80_h: well it seems it doesn't always look like a [String]. You'll probably have to pattern match for each case and extract info from it.
13:28:16 <third_contra_guy> I have done some problems from 99 haskell problems, so I can express algorithms in this language, I have rather problem with grasping the concept of immutable data
13:28:25 <monadic_kid> most small games i've seen don't even state monads even though it would clean up quite abit of boiler-plate code
13:28:44 <int80_h> Eduard_Munteanu: It does the way I use it. I just want a CookieList.
13:29:03 <int80_h> and it's always going to look like a [String], I'd like to do list operations on it
13:29:16 <jmcarthur> sproingie: some frp libraries model events discretely and have continuous behaviors as entirely different things
13:29:20 <jmcarthur> sproingie: reactive, for example
13:30:29 <blueonyx> how to find packages with cabal/hackage which depend on a specific package?
13:30:30 <jmcarthur> (it happens that Event is part of Behavior's implementation, but that is not important to the semantics)
13:31:03 <monochrom> actually an S->IO() function and it tail-calls itself with new parameter for state change
13:31:06 <dcoutts> blueonyx: reverse dependencies, see e.g. http://sparky.haskell.org:8080/package/mtl/reverse
13:31:14 <third_contra_guy> monadic_kid: initial guess is to create some records, and functions taking record, creating new record that is exact copy of old one but with one field changed, but this is simply object-oriented approach
13:31:39 <blueonyx> thanks dcoutts :)
13:31:40 <Eduard_Munteanu> int80_h: then you could have something like fromInfoValue :: InfoValue -> [String]; fromInfoValue (IList a) = a; fromInfoValue _ = error "error message"
13:31:50 <sproingie> third_contra_guy: that's also a functional approach
13:32:07 <monochrom> no, this is not object-oriented because there is no inheritance virtual-whatever etc.
13:32:32 <monochrom> at best it is just 1970s Jackson structured programming.
13:32:43 <monadic_kid> tihird_contra_quy: the first step is transforming arguments, so you have an initial state, a function that transforms it and returns a new state, then you pass the new state onto the next function and so on. This is explicit plumbing of state, there will be repeative boiler-plate code with non-trivial state transformations so the next step is to refactor the boiler-plate pattern, this is what the state monad gives
13:32:54 <third_contra_guy> sproingie: but I have to write all modifiers myself, and I thought that there is moer elegant way of doing so
13:33:00 <monochrom> go look it up to find out that 99% of "oo" is just that, and be horrified
13:33:03 <Eduard_Munteanu> int80_h: or something in the Maybe monad if you want to handle error gracefuly.
13:33:08 <Eduard_Munteanu> s/fuly/fully/
13:33:25 <third_contra_guy> monochrom: you are right
13:33:40 <int80_h> Eduard_Munteanu:Thanks. I will add graceful error handling when alpha version is done and I'm ready to do the Beta
13:34:34 <monochrom> anyway there is no need to go political and say "I must do it oo" or "I must do it non-oo". anything you can express in haskell succintly is fair game.
13:34:58 <monochrom> perhaps s/political/partisan/
13:35:03 <sproingie> simulations with a lot of state do lend themselves pretty well to OO languages
13:35:16 <jmcarthur> except when you actually try it
13:35:26 <monadic_kid> tihird_contra_quy: does that make sense?
13:35:27 <monochrom> all programming paradigms converge to each other at time infinity
13:35:29 <jmcarthur> in my experiences, OO doesn't actually fit game dev very well
13:35:31 <jmcarthur> surprisingly
13:35:39 <third_contra_guy> monadic_kid: but state will be some kind of object, and it can have multiple fields, so I'll end up writing getters and setters
13:35:59 <third_contra_guy> monochrom: at time of deadline
13:36:17 <sproingie> lots of games have to use flyweights that end up never getting reified.  so a lot of the time they end up working around OO
13:36:17 <third_contra_guy> jmcarthur: why?
13:36:29 <jmcarthur> third_contra_guy: every tried it?
13:36:31 <jmcarthur> *ever
13:36:41 <Eduard_Munteanu> Surely there are things to learn from OO, but OO isn't the endpoint. Haskell allows for more generality there.
13:36:53 <third_contra_guy> jmcarthur: yes, but small projects only
13:37:08 <monadic_kid> tihird_contra_quy: you don't need to write getters/setters for records, haskell records generate functions and you have pattern match to deconstruct them, update them, etc
13:37:57 <sproingie> there's no real shame in keeping a big tree of game state, then replacing pieces of it as you go.  this is what you're doing in imperative languages anyway, haskell just keeps you honest about it.
13:38:11 <jmcarthur> third_contra_guy: there are several ways to do it. the most common first-attempt is to have some sort of generic game entity object that all other objects inherit from. that tends to turn into a huge mess. the next thing people tend to try is break that up into several smaller heirarchies. it tends to be less cluttered, but still not quite there. typically by the time you write clean code for a game, 
13:38:13 <jmcarthur> it's not very OO in the first place
13:38:42 <jmcarthur> third_contra_guy: there's also the policy of never using inheritance, which helps
13:38:48 <Eduard_Munteanu> The inheritance thingy just emulates typeclasses and polymorphism IMHO and it's better suited for other languages.
13:38:57 <Eduard_Munteanu> Like 'class Object'
13:38:59 <third_contra_guy> getters and setters were just a metaphore, and I wonder how can I avoid writing functions to change record fields
13:39:13 <sproingie> records are kinda a mess
13:39:15 <int80_h> a metaphor for what?
13:39:15 <kmc> third_contra_guy, did you look at libraries like lenses, fclabels, and data-accessor?
13:39:47 <third_contra_guy> kmc: no, this will be my first real haskell program
13:39:56 <monadic_kid> tihird_contra_quy: yes those libraries kmc just pointed out can make using records with/without state monads very expressive
13:39:57 <sproingie> i'd start smaller.  or with a small game.
13:40:15 <kmc> third_contra_guy, what fake haskell programs have you written?
13:40:40 <jmcarthur> third_contra_guy: the top answer to this question tends to be what most well-designed games eventually converge to http://gamedev.stackexchange.com/questions/8186/optimal-game-loop-for-2d-side-scroller
13:40:43 <third_contra_guy> kmc: sorts, trees, hulls, etc.
13:40:47 <kmc> cool
13:40:52 <kmc> how many lines of code?
13:41:06 <third_contra_guy> <100
13:41:08 <kmc> haskell is really not a "jump in and write a 3d game / blog engine" sort of language
13:41:21 <ddarius> kmc: Why not?
13:41:21 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
13:41:29 <kmc> that way lies frustration and disappointment and (if you want some reddit karma) a blog post "debunking" the "hype"
13:41:41 <hpc> haskell can be a "jump in and write a blog engine" language
13:41:50 <hpc> if you don't mind writing the rest of the stack too :P
13:41:55 <jmcarthur> third_contra_guy: he made sure to point out that the approach isn't fundamentally incompatible with OO design, and i agree, but my point typical OO design practices don't really lead you directly to it
13:42:04 <monochrom> jmcarthur: is the top answer "Actually, deep hierarchies are generally worse... trending towards shallowing, aggregation-based approaches" ?
13:42:12 <hpc> or going through all the hackage stuff to find the good ones
13:42:16 <Eduard_Munteanu> 100 LoC of Haskell code can be a lot of C code considering the habits of the latter category :P
13:42:19 <monadic_kid> making a 3D game is not something you jump into in any langauge
13:42:22 <jmcarthur> monochrom: yes
13:42:53 <third_contra_guy> sproingie: can you explain idea of state tree a little bit?
13:43:17 <ddarius> @tell edwardk Matt is ridiculously good at his job, and if I approach this the right way and the way Matt will probably push me, this may turn out to have been a very good choice for me.  Like, a life-changing choice.
13:43:17 <lambdabot> Consider it noted.
13:43:24 <third_contra_guy> game is going to be 2d, two players on football field bouncing a ball
13:43:46 <ricree> Hypothetically, if one were to try a game, what libraries are generally recommended for things like sound  and display?
13:43:48 <monadic_kid> third_contra_guy: organize your data into various records, sub-records and modify parts of the "state
13:43:52 <Eduard_Munteanu> third_contra_guy: something like a scene graph
13:43:56 <ddarius> @tell edwardk unfoldr/destroy is different from the stream-fusion stuff.
13:43:56 <lambdabot> Consider it noted.
13:44:05 <sproingie> third_contra_guy: imagine a small adventure game, where you have a Game record that a Player record with a list of Inventory items.  also in your Game is a Map, maybe a list of Monsters, etc
13:44:16 <ddarius> ricree: Probably the SDL/OpenGL bindings.
13:44:22 <ddarius> Depending on your needs.
13:44:25 <sproingie> third_contra_guy: if you were to describe it in, say, json, it'd be one giant object
13:44:55 <monadic_kid> Eduard_Munteanu: I don't think he means scene graph, just data organization with records. Scene graphs are particularly useful for games, better for modellers or intermidate game format
13:45:07 <sm> ricree: graphics-drawingcombinators is also useful, and fungen would be if updated
13:45:21 <monadic_kid> Eduard_Munteanu: *are not particularly useful
13:45:23 <hpc> a scene graph is really whatever you make of it
13:45:24 <sproingie> third_contra_guy: the idea of having One Big Object That Contains Everything seems kind of horrifying to start, but it's not really any different than what an imperative program does
13:45:37 <hpc> it's just a specific term for "this thing contains more things..."
13:45:55 <sproingie> just that instead of a Game, it's probably some singleton class
13:46:10 <thierry`> hi, I think I'm missing something of the IO concept. Is it normal that I have to create a bunch a little functions like this : http://haskell.pastebin.com/pZxNNC5D to get some other functions working properly with IO String?
13:46:29 <third_contra_guy> sproingie: thanks. But how shall I technically exchange parts of the tree? Pattern matching and returning new object?
13:46:32 <jmcarthur> thierry`: appendString = liftM2 (++)
13:46:50 <sm> ricree: haskgame is another incomplete lib that might be worth a look
13:46:50 <Egbert9e9> so I want to write a game in haskell. What library should I be using? the SDL bindings?
13:46:52 <jmcarthur> thierry`: there are a lot of nice functions to help you out. generally you should be able to just use them inline
13:46:57 <Eduard_Munteanu> monadic_kid: I don't have much experience with game development, but I've seen things using an extended scene graph (that is, having both rendering resources and game state) like OpenSceneGraph.
13:47:18 <monadic_kid> hpc: scene graphs in the traditional sense are transform graphs augmented with bounding volume hierarchies and the kitchen sink thrown in, we don't use them for in game formats
13:47:23 <Egbert9e9> oh, you're already talking about gaming
13:47:27 <ddarius> jmcarthur: But appendIO is probably an indicator of "Doing It Wrong"
13:47:39 <sgronblo> has haskell been used for any larger games at all?
13:47:41 <hpc> Egbert9e9: sdl is a good start; i tried learning the opengl libs and got as far as a purple cube that moves left
13:47:52 <Egbert9e9> hpc, lol
13:48:10 <mathijs> Hi all, I was looking at thread-safe data structures, learned about CAS, wanted to find out what haskell had available. I found http://www.scribd.com/doc/28336206/Multicore-programming-in-Haskell which talks about "atomicModifyIORef" and how it works together with laziness...
13:48:13 <third_contra_guy> sgronblo: check out frag, quake3 in haskell
13:48:17 <gwern> monochrom: does comp.lang.haskell actually exist or is that just a shell around a mailing list for really old fogies?
13:48:41 <monochrom> actually exists independently
13:48:43 <thierry`> ddarius : I can post my full code, I'm wondering if I'm doing it wrong too
13:48:47 <sproingie> third_contra_guy: pretty much.  making deep updates elegant is something i'm not all that familiar with myself.  i have to look into stuff like uniplate to figure it out
13:48:49 <mathijs> now I have a question. if a calculation (thunk) is stored somewhere in memory, and 2 threads need to evaluate it. what happens?
13:48:57 <ddarius> gwern: I would think SMTP/POP is older than NNTP, but I'd have to check to be sure.
13:49:05 <Egbert9e9> hpc, i'm a bit confused with the sdl lib
13:49:10 <jmcarthur> mathijs: it's possible that both threads will redundantly evaluate it, but that's not dangerous
13:49:26 <monadic_kid> Eduard_Munteanu: OpenSceneGraph is over kill, we don't use scene graphs in (console) games, they are typically a "jack-of-all-trades-and-master-of-none". They are best as a modelling format or intermediate format but they are not good for games.
13:49:26 <Egbert9e9> hpc, and really has no clue how to even write a pong
13:49:39 <aristid> ddarius: isn't SMTP older than POP?
13:49:41 <Egbert9e9> have
13:49:47 <Eduard_Munteanu> Ah, I see.
13:49:52 <jmcarthur> mathijs: the worst that happens is both threads write the same data to the same thunk
13:49:59 <sgronblo> third_contra_guy: oh. look at that. well has anyone read that guys paper. what did he think about making the game with haskell? was it easy or hard?
13:50:19 <mathijs> jmcarthur: ok, but it will lead to a performance hit right? and will it be a space "leak" (evaluated thunk will be in mem twice) ?
13:50:30 <hpc> Egbert9e9: i am probably a bad person to ask right now; im working on some numerical analysis homework and only idly watching the chan
13:50:35 <mathijs> jm: ah ok... so it's in-place
13:50:45 <Egbert9e9> hpc, no problem
13:50:46 <thierry`> ddarius , jmcarthur : here is my full code : http://haskell.pastebin.com/PL8UeuCC , I'm simply trying to deep-first search in a binary tree and log where I went at which time
13:50:51 <sm> Egbert9e9: here's a simple pong: http://joyful.com/darcsweb/darcsweb.cgi?r=fungen;a=headblob;f=/pong/pong.hs
13:50:51 <Egbert9e9> hpc, thanks
13:50:52 <jmcarthur> mathijs: however, i believe there is some sort of light weight blocker for most cases. like if one threads starts evaluating it *and then* another one comes along, it's not redundant. i could be wrong about that though
13:50:58 <Egbert9e9> sm, zomg.
13:51:01 <jmcarthur> mathijs: either way, it's not really performance or space issue
13:51:25 <ddarius> jmcarthur: The blackholing will cause the second thread to block.
13:51:35 <jmcarthur> ddarius: ah, yes, that's what i was thinking of
13:51:36 <mathijs> jmcarthur: nice. but you say it might not actually be lock-free internally?
13:51:48 <Egbert9e9> sm, so fungen is alright, too?
13:52:00 <jmcarthur> mathijs: nono, there are no heavy locks there. ddarius might be able to explain better ^^
13:52:04 <Egbert9e9> sm, the documentation is lacking, i think
13:52:05 <kmc> mathijs, did you read through Real World Haskell's chapters on concurrency?
13:52:18 <sgronblo> also which vcs is the most used in the haskell community?
13:52:20 <sm> Egbert9e9: yes, although there is some docs at the original fungen site.
13:52:21 <mathijs> kmc: yes
13:52:25 <jmcarthur> i'm not sure how blackholing really works
13:52:30 <kmc> sgronblo, darcs and git are both pretty popular; use whichever you like
13:52:39 <Egbert9e9> sm, it's a shame, really
13:52:41 <hpc> lol, fungen
13:52:42 <third_contra_guy> sgronblo: I haven't read entire paper, just section about performance. But fact that one guy implemented q3 alone is still interesting.
13:52:46 <hpc> last updated in 2002
13:52:51 <sm> fungen is the most capable game engine for haskell. There's two versions, the one I linked and FunGEn on hackage. Either one needs some work to compile with current ghc
13:53:04 <banisterfiend> sm: is it build on opengl?
13:53:10 <Egbert9e9> oh my
13:53:18 <jmcarthur> personally i think q3 is a low bar if the point is to show that haskell can make it for heavier kinds of games
13:53:20 <ddarius> jmcarthur: All that happens is when evaluation enters a thunk, it overwrites the thunk with a blackhole entry (that will print out the <loop> message for sequential programs, and block threads in threaded programs).
13:53:45 <sgronblo> oh so darcs is written in haskell, didnt know
13:53:49 <ddarius> This is done in sequential programs to plug a nasty space-leak in the naive implementation of lazy functional programs.  In the threaded case, there's a harmless race-condition.
13:53:49 <jmcarthur> ah okay
13:53:55 <sm> I forget.. I can say that I once built fungen and all three examples do work
13:53:56 <Egbert9e9> sm, you can put a patch in the repository, can't you?
13:54:25 <jmcarthur> ddarius: okay that matches my loose understanding of it
13:54:30 <sm> sure, my repo is unofficial but I think it's the only one, patches welcome
13:54:30 <mathijs> ddarius: so that's a lot lighter than a mutex?
13:54:41 <ddarius> mathijs: It's free.
13:54:46 <jmcarthur> mathijs: it's not a lock at all.
13:54:46 <sm> banisterfiend: yeah it used OpenGL and GLUT
13:54:54 <jmcarthur> i wouldn't say free though
13:54:57 <Eduard_Munteanu> Is that an atomic write?
13:54:58 <accel> I'm currently not using cabal. How do I tell ghc to use the "glut" and "OpenGL "modules?
13:55:00 <monadic_kid> Egbert9e9: SDL is nice but there some things missing that make doing 2D games efficent, lack of alpha blending modes (if you want to do fast per-pixel collision detection with xor blending), no hardware accelerated stencil operations but you can write those using pixel operations in software which i have done
13:55:04 <jmcarthur> due to memory bandwidth between cores
13:55:21 <ddarius> jmcarthur: Not doing it (blackholing) isn't really an option.
13:55:26 <jmcarthur> yeah
13:55:32 <monadic_kid> Egbert9e9: you can do alpha blending with SDL but you don't have any options for blend modes
13:55:50 <mathijs> ok, my understanding of "block" is probably a bit wrong then :)  to me that sounds like a cpu waiting and doing nothing for a short time
13:55:52 <ddarius> So it isn't free to do, but you -have- to do it anyway.  It doesn't cost any more in the threaded/multicore case.
13:56:08 <dcoutts> accel: if you're just using ghc --make, then there's nothing to do, just import them and use them (assuming they're installed)
13:56:09 <Eduard_Munteanu> ddarius: is it because future sharing implies handling concurrent writes to that thunk?
13:56:11 <ski> sgronblo : you could still say `(lambda (x y) (lambda (z) ..x..y..z..))' (in Scheme. i don't recall the ECMAScreipt, atm), and that would be a curried function, so you should still distinguish between "curry" and "partially apply"
13:56:17 <jmcarthur> mathijs: what else is the thread to do during that time? ;)
13:56:27 <accel> dcoutts: nice; thanks
13:56:28 <jmcarthur> monadic_kid: i just use SDL to set up an opengl context and do event handling and stuff
13:56:35 <Egbert9e9> so all libraries are lacking and it'll be a serious trade off decision?
13:56:36 <sm> someone should probably port of flixel or flashpunk to haskell and be done with it
13:56:37 <jmcarthur> monadic_kid: you don't have to use SDL's graphics interface
13:56:46 <accel> jmcarthur: you do OpenGL in Haskell too?
13:56:52 <jmcarthur> accel: yeah
13:57:02 <ski> btw, note that some people think that a (properly) curried function should only refer to one with type `.. -> (.. -> ..)' where the function actually does some computation when passed only the former argument
13:57:05 <accel> jmcarthur: cool; are any of the OpenGL links in the haskell wiki yours?
13:57:07 <jmcarthur> i'm making a pseudo-3D library right now
13:57:14 <jmcarthur> accel: not that i know of
13:57:24 <ddarius> Eduard_Munteanu: I don't understand your question.  Concurrency has nothing to do with why blackholing is done.
13:57:33 <accel> jmcarthur: what do you do with OpenGl then?
13:57:36 <edgar> Hi, I need help to solve a problem related to concurrency and parallel execution. The question is posted on: http://stackoverflow.com/questions/4920077/parallelism-on-divide-conquer-algorithm
13:57:40 <jmcarthur> i only have one graphics-related package on hackage, and it's just OpenGLRaw21
13:57:48 <jmcarthur> accel: i'm *using* it :P
13:57:54 <monadic_kid> jmcarthur: i know but OpenGL isn't very friendly to someone who doesn't understand the graphics pipeline and all the termonolgy used for 3D graphics programming while trying to do 2D, a starter isn't going to understand what 2D orthographic projection matrix is for example
13:57:56 <accel> jmcarthur: to do what?
13:58:14 <jmcarthur> accel: eventually to make a game, but currently to make a library for pseudo-3D graphics
13:58:15 <Eduard_Munteanu> Hrm, then I probably have to look it up and read about it.
13:58:40 <ddarius> sm: I hear you're porting flixel or flashpunk to Haskell.
13:58:42 <jmcarthur> monadic_kid: agreed, but there are opengl libraries that could just use a context and provide a higher level interface
13:58:44 <sm> heh
13:59:03 <accel> the point of OpenGL isn't to be easy to use
13:59:08 <accel> the point of OpenGL is to be performance
13:59:12 * sm notes graphics-drawingcombinators is a great easy 2d wrapper for opengl
13:59:16 <accel> i.e. OpenGL should be about as easy to use as x86 assembly
13:59:28 <jmcarthur> sm: but not a very fast or flexible one :(
13:59:35 <jmcarthur> but i agree, it's simple and nice
13:59:41 <monadic_kid> my point is somebody has to write that high-level api to giving you
13:59:46 <banisterfiend> sm: what is a fombinator
13:59:46 <ClaudiusMaximus> ski: function arcHandler(p) { return function(q) { return function(r) { arcDo (p, q, r); return nullHandler; }; }; }  /* actual code from one of my ecmascript things - probably i should have written curry3() */
13:59:49 <banisterfiend> combintor*
13:59:52 <sm> I don't think that matters for most would-be haskell game devs right now.. a nice pong would be a great start
13:59:56 <jmcarthur> monadic_kid: i'm trying to do that!
14:00:09 <hpc> sm: or at least an up-to-date pong ;)
14:00:10 <Eduard_Munteanu> Well, OpenGL 4 (IIRC?) kinda replaced the crappy state machine prior versions used.
14:00:26 <jmcarthur> well
14:00:29 <accel> jmcarthur: have you paleyd with GLSL haders in OpenGL?
14:00:29 <ddarius> sm: There are nicer things than pong already out there.
14:00:33 <jmcarthur> OpenGL 3 was supposed to, but a lot of that is still there
14:00:35 <Egbert9e9> what i want right now is ease of use
14:00:36 <jmcarthur> accel: yes
14:00:40 <Eduard_Munteanu> Similarly to how DX10/11 (I don't remember the actual numbers here either) did.
14:00:44 <monadic_kid> jmcarthur: somebody should make haskell bindings to SFML which uses OpenGL as backend
14:00:47 <Egbert9e9> so, should i choose drawing combinators?
14:00:48 <accel> jmcarthur: cool; so I have the basic brick shader from the orange book working
14:00:48 <jmcarthur> accel: part of my library is actually a DSL to generate shaders
14:00:51 <accel> jmcarthur: can I PM you?
14:01:08 <jmcarthur> Egbert9e9: that's certainly an easy one :)
14:01:27 <jmcarthur> accel: not sure how much help i'd actually be. there's an ##OpenGL channel (which i'm in)
14:01:44 <jmcarthur> accel: they can be kind of rude, but they know more than me
14:01:46 <sm> there are some fine games on hackage, but knocking out simple games in haskell isn't yet easy.. pretty major time/research required, or am I all wrong
14:01:47 <Egbert9e9> i wrote a pong in javascript. that's the farthest i ever got
14:01:52 <Eduard_Munteanu> For really simple 2D stuff, I think GTK + Cairo (with the OpenGL backend) might also do.
14:02:10 <sm> it's not yet a well-beaten path, anyway
14:02:15 <mrd> i did a 3d demo with hopengl, fairly easy, but i already know opengl
14:02:16 <jmcarthur> accel: there used to even be a channel dedicated to making games in haskell. not sure what happened to that
14:02:27 <monadic_kid> Egbert9e9: If I was you i'd start small & simple, use SDL or something equivalent to it.
14:02:31 <kmc> i think if you know how to write a simple game in C++ or Java, and you also know Haskell decently well, then a straightforward translation of the OpenGL / SDL code to Haskell is not hard
14:02:34 <kmc> i learned OpenGL in Haskell
14:02:34 <sm> #haskell-game, died due to lack of support
14:02:46 <kmc> however the result is mostly imperative code and may not live up to the exacting standards of haskellers
14:02:46 <nostrand> sm: yeah, simple games in haskell is pretty easy =)
14:02:56 <Egbert9e9> monadic_kid, sm and jmcarthur say DrawingCombinator is simple
14:03:01 <kmc> if you want to use something cool and functional like FRP then you're in for a bunch of research and headaches
14:03:03 <banisterfiend> doesn't gosu (http://libgosu.org) have a haskell port?
14:03:20 <kmc> FFI-importing your favorite C or C++ game library is not that hard
14:03:24 <hpc> FRP is a headache on the best of days
14:03:27 <jmcarthur> sm: well... i just joined, and i'll add it to my autojoins
14:03:37 <ddarius> kmc: Importing C++ libraries is probably not going to be easy.
14:03:51 <Egbert9e9> i'm totally agnostic right now
14:04:19 <monadic_kid> i've always wanted to start or see a website for games in functional languages
14:04:37 <Eduard_Munteanu> Getting a decent interface to an external lib isn't really easy I think.
14:04:45 <monadic_kid> I wanted to make interest group on Haskellers but there is no interface to start one
14:04:59 <ddarius> Eduard_Munteanu: It depends on the external library.  Usually it isn't that hard unless it's particularly convoluted or large.
14:05:00 <monadic_kid> plus some how my account got wiped
14:05:01 <kmc> ddarius, true
14:05:54 <kmc> much of the difficulty in wrapping C libs is a matter of differing expectations -- Haskell programmers expect automatic resource management and threadsafety by default
14:06:00 <ski> ddarius : is that the same leak as is described by <http://srfi.schemers.org/srfi-45/srfi-45.html> ?
14:06:05 <kmc> you can make libraries which lack these but it will upset people much more than the equivalent in C would
14:06:13 <sm> jmcarthur: looks like you and I will have some great game-dev chats in there :)
14:06:19 <jmcarthur> heh
14:06:23 <ddarius> ski: Give me a second to look, but I don't think so.
14:06:27 <jmcarthur> we can probably get some of the old crowd back
14:06:28 <kmc> there are some pretty good techniques for providing it though
14:06:29 <ddarius> If it's the one I think you mean.
14:06:58 <ddarius> ski: It's not a matter of "building up thunks" but just a matter of keeping things live.
14:07:05 <ski> ddarius : look at the `(define (loop) (delay (force (loop))))'
14:07:22 <sm> alrighty, adding #haskell-game to autojoin too.. I'll still listen in the big channel though
14:09:10 <sm> #haskell-game lives again, add it to your autojoin if interested in hs game dev!
14:13:11 <FunctorSalad> 'constrFields' should return a Maybe rather than throwing exceptions...
14:13:33 <djahandarie> Type safety? Who needs it.
14:13:39 <drhodes> Does anyone know were I could find a parser built with parsec that produces solid error messages? 
14:13:59 <ski> > constrFields (toConstr (Node () []))
14:13:59 <lambdabot>   ["rootLabel","subForest"]
14:14:02 <ski> > constrFields (toConstr ())
14:14:03 <lambdabot>   []
14:14:30 <FunctorSalad> > constrFields (toConstr 1)
14:14:31 <lambdabot>   *Exception: constrFields
14:14:46 <FunctorSalad> I guess I could check for non-AlgRep
14:15:20 <hpc> :t constrFields
14:15:21 <lambdabot> Constr -> [String]
14:15:58 <sm> for the record, there is also a #haskell-web, add that to autojoin if interested in hs web dev!
14:16:09 <FunctorSalad> > constrFields (toConstr (id::()->()))
14:16:10 <lambdabot>   *Exception: toConstr
14:16:53 <blueonyx> kmc: understood how to use your jspath lib, but how does it help when i expect a the 4th entry of a array to be a number but it really is a string or not existent?
14:18:29 <FunctorSalad> > dataTypeRep (dataTypeOf (id::()->()))
14:18:30 <lambdabot>   NoRep
14:20:27 <elliott> mycotemp.tmp: openBinaryFile: resource busy (file is locked)
14:20:29 <elliott> What's that about.
14:20:36 <elliott> (Just after closing that file.)
14:20:42 <elliott> (IO mode is ReadWriteMode.)
14:22:10 <kmc> sounds like an error at the system call level
14:22:17 <kmc> a UNIX system? try strace or similar
14:22:22 <elliott> kmc: Yes, Unix.
14:22:40 <quicksilver> did you hGetContents the file?
14:22:46 <quicksilver> if so, your close didn't really close it.
14:22:46 <elliott> kmc: Yikes. rt_sigprocmask sure is called a heck of a lot.
14:22:49 <elliott> quicksilver: No.
14:23:01 <elliott> quicksilver: I use ByteString's hGet only. Also, hGetLine.
14:23:06 <elliott> (strict bytestrings)
14:23:25 <elliott> only other io functions i call: hSetFileSize, hSeek, hTell
14:23:31 <elliott> oh, and hPutStr
14:23:49 <kmc> yeah, it's a solid plan to ignore all but the last few lines of strace
14:23:57 <kmc> also you can filter its output in various ways
14:24:57 <quicksilver> strace -e'trace=file' might be useful in your case. perhaps.
14:25:39 <shachaf> rt_sigprocmask? Why?
14:26:44 <elliott> Indeed it does not get properly closed.
14:26:52 <elliott> Any way to really-really-close-file? :-)
14:27:02 <c_wraith> don't use lazy IO?
14:27:11 <elliott> Um, I _don't_.
14:27:14 <elliott> <elliott> quicksilver: I use ByteString's hGet only. Also, hGetLine.
14:27:14 <elliott> <elliott> (strict bytestrings)
14:27:14 <elliott> <elliott> only other io functions i call: hSetFileSize, hSeek, hTell
14:27:14 <elliott> <elliott> oh, and hPutStr
14:27:16 <kmc> i don't think any of those are lazy IO functions
14:27:38 <c_wraith> hmm.  in that case..  closing it really should close it.
14:27:51 <elliott> Possibly hGetLine is lazy?
14:28:03 <quicksilver> nope
14:28:07 <ddarius> Even if he were using lazy IO hClosing it would still close it.
14:28:46 <jmcarthur> EvanR-work: we're trying to get #haskell-game going again
14:29:21 <kmc> trying to get the band back together
14:29:32 <EvanR-work> jmcarthur: oh good
14:29:35 <jmcarthur> EvanR-work: apparently you own the channel, right?
14:29:49 <EvanR-work> i do, but i will give it away if someone better is available
14:30:01 <int80_h> what would be a good way to convert a list with always two values into a pair?
14:30:13 <EvanR-work> \[x,y] -> (x,y)
14:30:15 <jmcarthur> EvanR-work: if you no longer want to maintain it i don't mind taking ownership, but i don't really care either way
14:30:36 <int80_h> neat!
14:30:39 <revenantphx> @hoogle [a] -> (a,a)
14:30:39 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
14:30:40 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
14:30:40 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
14:30:46 <revenantphx> Yea, that's just the best way >_>
14:30:50 <revenantphx> (lambda I mean)
14:31:04 <EvanR-work> the function isnt total
14:31:13 <EvanR-work> your best bet is not to have a list with exactly two items in the first place
14:31:25 * ddarius agrees with EvanR-work.
14:31:42 <int80_h> well this operation I do will always return the last two values in a list
14:32:02 <int80_h> those are the values I need, and I thought they would be better organized into a tuple
14:32:06 <EvanR-work> and you have a proof that the list has at least two things
14:32:13 <ski> > getZipList (liftA2 (,) `join` ZipList [0,1])
14:32:14 <lambdabot>   [(0,0),(1,1)]
14:32:16 <EvanR-work> a proof that requires maintenance ;)
14:32:49 <quicksilver> it's not that uncommon to know you have exactly two items.
14:33:01 <int80_h> yes, I start with exactly 7.
14:33:05 <int80_h> I drop the first 5
14:33:07 <EvanR-work> would be not if the compiler could guarantee it
14:33:08 <quicksilver> > map (take 2) . iterate (drop 2) $ [1..]
14:33:09 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21...
14:33:18 <EvanR-work> would be nice*
14:33:36 <quicksilver> sure, but it's nice having an always-terminating type system, too.
14:33:39 <quicksilver> there's no free lunch.
14:33:50 <quicksilver> I'm quite happy sometimes having properties the type system doesn't know about
14:33:53 <EvanR-work> s/take 2/takePaid/ ;)
14:33:57 <EvanR-work> takePair
14:33:57 <revenantphx> pffff
14:33:58 <revenantphx> https://gist.github.com/819508
14:33:59 <ski> @type \f -> map (fst . f) . iterate (snd . f)
14:34:00 <lambdabot> forall a b. (b -> (a, b)) -> b -> [a]
14:34:04 <revenantphx> dependencies = totally broken
14:34:19 <revenantphx> ghc-6.12.3 requires containers ==0.4.0.0 however containers-0.4.0.0 was excluded because ghc-6.12.3 requires containers ==0.3.0.0
14:34:21 <revenantphx> MAKE UP YOUR MIND.
14:34:38 <ski> @type unfoldr . (Just .)
14:34:39 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
14:34:47 <c_wraith> containers is pinned to the GHC version.  uninstall all ghc 0.4 on your system
14:34:51 <elliott> <quicksilver> sure, but it's nice having an always-terminating type system, too.
14:34:57 <elliott> you can have dependent types and a terminating type system
14:35:07 <c_wraith> err, containers 0.4.0.0
14:35:30 <EvanR-work> quicksilver: since i already know everything and have everything else... i think nows the time to start searching for a free lunch ;)
14:35:36 <EvanR-work> ill tell you about it when i find it
14:36:31 <revenantphx> ghc 0.4?
14:36:32 <revenantphx> lol
14:36:39 <revenantphx> what was it again?
14:36:41 <revenantphx> ghc-pkg something?
14:36:43 <revenantphx> then delete it?
14:36:48 <c_wraith> ghc-pkg unregister
14:36:52 <Raynes> revenantphx: If I had a dollar for every retarded message similar to that one I've gotten from ghc-pkg, I'd be rich.
14:36:58 <revenantphx> heh
14:36:58 <c_wraith> You can skip deleting it
14:37:11 <c_wraith> That error message has a specific cause.
14:37:17 <revenantphx> I need to like get the list then stuff and stuff
14:37:26 <revenantphx> unregister?
14:37:30 <c_wraith> The cause is "you're using global and user package databases at the same time"
14:37:35 <int80_h> can I tets lambdas in ghci? If so, how?
14:37:36 <c_wraith> Don't do that.
14:37:37 <int80_h> test
14:37:52 <revenantphx> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
14:37:52 <revenantphx>    containers-0.3.0.0
14:37:53 <revenantphx>    containers-0.4.0.0
14:38:00 <revenantphx> One is in the GHC.framework,
14:38:02 <revenantphx> the other is ... not
14:38:12 <c_wraith> I'm assuming 0.3 is the one in the framework?
14:38:19 <tibbe> someone asked me a question earlier but I forgot whom :/
14:38:31 <c_wraith> since that's the version that actually belongs with the version of ghc you're using
14:38:57 <harlekin> readFile fn >> writeFile fn "foo", results in openFile: resource busy (file is locked). Is this due to lazyness of there functions or isn't this Haskells fault at all?
14:39:12 <elliott> harlekin: haha! i just ran into that same issue
14:39:14 <revenantphx> erp
14:39:14 <elliott> yes, that's because of lazy IO
14:39:20 <revenantphx> deleting it would break half my libraries
14:39:21 <elliott> (my issue was the same except I wasn't using strict IO)
14:39:22 <revenantphx> you know what?
14:39:23 <revenantphx> fuck it.
14:39:26 <revenantphx> Today I'm purging GJC.
14:39:27 <revenantphx> GHC*
14:39:31 <revenantphx> and installing ghc7 64bit.
14:39:33 <revenantphx> >_>
14:39:35 <harlekin> elliott, are there strict variants of these functions?
14:39:37 <kfr> Where can I buy ghc?
14:39:37 <revenantphx> enough with the architecture issues.
14:39:46 <kfr> Is there an evaluation version online?
14:39:46 <elliott> Of readFile I believe you need to read your own. You could try seq'ing it.
14:39:56 <elliott> revenantphx: That's nearly impossible on OS X.
14:40:09 <revenantphx> elliott: wry? there are prebuilt installers.
14:40:17 <elliott> revenantphx: not for 64-bit.
14:40:19 <harlekin> elliott, the result is evaluated before writeFile is called. So seq wouldn't help, I guess.
14:40:20 <elliott> at least afaik.
14:40:22 <revenantphx> Yep, there are.
14:40:22 <mm_freak> kfr: i would sell it for $ 2000
14:40:23 <dschoepe> harlekin: there's strict-io on hackage
14:40:24 <elliott> Oh.
14:40:30 <kfr> Luckily the ghc devs broke bootstrapping 2 years ago and it hasn't been fixed since then :[
14:40:30 <elliott> revenantphx: Good luck, nothing supports GHC 7 :-P
14:40:41 <revenantphx> Most of the libraries I care about do :P
14:40:55 <kfr> And there's still no LLVM cross compilation either because... of RTS issues?
14:40:56 <mm_freak> revenantphx: do their dependencies?
14:40:59 <revenantphx> Except parsec apparently.
14:41:06 <harlekin> dschoepe, I try. Thanks.
14:41:23 <djahandarie> Parsec worked fine for me on GHC 7.
14:41:31 <djahandarie> (The latest version of it, 3.1, I think)
14:41:41 <ddarius> @hackage parsec
14:41:41 <lambdabot> http://hackage.haskell.org/package/parsec
14:42:03 <revenantphx> oh, 3.1 does.
14:42:04 <revenantphx> hah.
14:42:08 <monochrom> I don't understand the point of readFile fn >> writeFile fn "foo". why not just writeFile fn "foo".
14:42:20 <revenantphx> FFFFFF
14:42:24 <revenantphx> purging ghc did not remove cabal
14:42:29 <revenantphx> How can I purge all cabal and all ghc-pkg
14:42:30 <revenantphx> ever
14:42:34 <revenantphx> start fresh.
14:42:34 <jmcarthur> EvanR-work: so are you interesting in carrying the torch for #haskell-game, or would you rather pass it on to somebody else?
14:42:37 <jmcarthur> *interested
14:42:37 <c_wraith> just remove ~/.ghc and ~/.cabal
14:42:44 <revenantphx> and the binaries?
14:42:56 <mm_freak> c_wraith: don't suggest deleting ~/.cabal
14:42:59 <revenantphx> .ghc is gone with the unisntaller for ghc
14:43:02 <revenantphx> too late
14:43:05 <mm_freak> that can seriously break stuff
14:43:13 <revenantphx> Can't break what's not there :D
14:43:19 <revenantphx> I'm purging GHC from my system to reinstall clean.
14:43:24 <ddarius> mm_freak: If you're deleting everything, that shouldn't really matter.
14:43:25 <dcoutts> mm_freak: it's ok to delete both ~/.ghc and ~/.cabal together
14:43:42 <dcoutts> mm_freak: it's only deleting ~/.cabal without deleting ~/.ghc that really messes things up
14:43:44 <banisterfiend> can someone tell me a common use for foldr? i think i know how to use foldl, but im just confused as to the utility of foldr
14:43:46 <revenantphx> where's the cabal binary?
14:43:50 <revenantphx> I want to purge that too.
14:43:57 <dcoutts> revenantphx: depends where you installed it
14:43:58 <revenantphx> whereis isn't working.
14:44:02 <revenantphx> it was frm the Platform.
14:44:05 <mm_freak> no  you would suggest deleting my cabal configuration, which includes, among other things, my hackage username and password
14:44:20 <c_wraith> mm_freak: why are you storing that there? :)
14:44:30 <revenantphx> I don't have a hackage username/password >_>
14:44:30 <EvanR-work> jmcarthur: id better transfer ownership, i dont think i have the time right now for gamedev
14:44:49 <dcoutts> mm_freak: yeah, it'd do that, there are more target approaches like deleting ~/.cabal/lib
14:44:53 <dcoutts> targeted
14:45:12 <mm_freak> i don't see a point of deleting .cabal at all, unless you run into space issues
14:45:20 <mm_freak> (.cabal can grow large over time)
14:45:21 <dcoutts> that's quite true
14:45:26 <jmcarthur> EvanR-work: okay, that's fine
14:45:57 <jmcarthur> EvanR-work: i'm not sure how an ownership transfer works. i assume i don't really have to do anything myself?
14:46:03 <revenantphx> oh, cabal's in /usr/local/bin
14:46:08 <revenantphx> baletted.
14:46:08 <mm_freak> c_wraith: i'm storing them there for convenience
14:46:10 <revenantphx> baleeted*
14:46:24 <EvanR-work> jmcarthur: i will go to freenode staff tonight, and they will probalby ignore me. but ill keep trying
14:46:33 <ski> > fromJust . (`evalLinear` [0,1]) $ liftM2 (,) `join` grab
14:46:34 <EvanR-work> someone else can register it i guess
14:46:35 <lambdabot>   (0,1)
14:46:36 <ski> > (`evalLinear` [0,1]) $ liftM2 (,) `join` pick :: [(Int,Int)]
14:46:38 <lambdabot>   [(0,1),(1,0)]
14:46:44 <dcoutts> c_wraith: you can put your hackage username and/or passwd in ~/.cabal/config so that you're not prompted on upload
14:47:43 <revenantphx> which one D:?
14:47:44 <revenantphx> http://cl.ly/4UiP
14:47:50 <revenantphx> Which person sounds more trustworthy
14:48:13 <revenantphx> I'll go with the Maeder build....
14:50:35 <shamster> what's the difference between function composition and application in the following: '(f . g) x' and 'f $ g x' ?
14:51:09 <mm_freak> shamster: in h98 there is no difference
14:51:24 <mm_freak> there may be a difference using some extensions like RankNTypes
14:51:37 <shamster> just checking my sanity
14:51:39 <shamster> thanks
14:51:54 <mm_freak> shamster: note that the latter doesn't use function composition
14:51:56 <ski> as values, they are equal
14:52:00 <mm_freak> ($) is application
14:52:09 <revenantphx> GHCi, version 7.0.1: http://www.haskell.org/ghc/  :? for help
14:52:11 <revenantphx> wow.
14:52:12 <revenantphx> That was...
14:52:14 <revenantphx> REALLY easy.
14:52:18 <revenantphx> ./configure; make install
14:52:20 <revenantphx> >_>
14:52:24 <revenantphx> Took like 20 seconds too.
14:52:24 <mm_freak> ski: only in h98 this is guaranteed
14:52:26 <revenantphx> Suspiciously fast.
14:53:02 <elliott> revenantphx: Well it didn't compile it obviously.
14:53:03 <shachaf> revenantphx: You should use make -j if you have a multicore system.
14:53:08 <elliott> shachaf: It's a binary build.
14:53:13 <shachaf> Oh.
14:53:14 <elliott> That would be rather pointless.
14:53:22 <elliott> 20 seconds to copy some files :-P
14:53:27 <revenantphx> Also, its x86_64
14:53:33 <ski> mm_freak : i wasn't talking about whether they would both be allowed under the same condition, but that when both are allowed, they have the same value
14:53:40 <revenantphx> And for OS X....
14:53:48 <revenantphx> all OS X 64bit computers have been multicore.
14:53:55 <ski> mm_freak : or do you have an example of them evaluating to different values ?
14:53:56 <revenantphx> so it'd be fair to assume they remembered that.
14:54:01 <shachaf> make -j is still a good habit. :-) And sometimes it makes sense even when you're doing mostly I/O.
14:54:12 <mm_freak> ski: not without caleskell =)
14:54:17 <elliott> revenantphx: Remembered it how?
14:54:25 <elliott> They can't just inject make flags. Well they can but that's evil.
14:54:30 <shachaf> Well, OS X is evil.
14:54:35 <elliott> That's true.
14:54:36 <ski> is there an example, even with `(.) = fmap' ?
14:54:54 <shachaf> I wouldn't be surprised if they exported MAKEFLAGS="-j" by default or something.
14:54:56 <revenantphx> elliott: It's precompiled.
14:55:09 <revenantphx> Also, how on earth is OS X evil.
14:55:10 <elliott> shachaf: They don't.
14:55:14 <revenantphx> Is Apple evil? Yes.
14:55:15 <shachaf> revenantphx: -j is for running multiple make targets in parallel.
14:55:19 <revenantphx> Is OS X evil? not imo.
14:55:31 <elliott> revenantphx: OS X is evil because it ships old versions of libraries and tools and upgrading those is almost impossible.
14:55:40 <elliott> Also a really old gcc.
14:55:49 <elliott> (because you're meant to use clang which only works on OS X at the best of times.)
14:55:55 <revenantphx> ...?
14:55:58 <revenantphx> it's *always* worked for me >_>
14:56:00 <elliott> (because Apple won't do GPLv3 so they can't ship a newer gcc.)
14:56:05 <revenantphx> Yep.
14:56:06 <elliott> revenantphx: then you're not trying hard enough :)
14:56:10 <revenantphx> clang is just better than gcc anyways.
14:56:14 <elliott> except when it doesn't work
14:56:16 <revenantphx> It's never failed me in over a year.
14:56:17 <elliott> which is usually, on OS X 
14:56:22 <shachaf> Well, GPLv3 is kind of evil too.
14:56:27 <shachaf> Though not nearly as evil as OS X.
14:56:41 <dagle> Code is pretty evil.
14:56:42 <revenantphx> There's nothing stopping you from upgrading libraries.
14:56:49 <revenantphx> Install in /usr/local/, add to path.
14:56:51 <revenantphx> holy shit that was hard.
14:56:54 <revenantphx> >_>?
14:56:55 <mm_freak> :t ($)
14:56:56 <lambdabot> forall a b. (a -> b) -> a -> b
14:57:15 <monochrom> "add to path" is easier said than done
14:57:34 <mm_freak> ski: well, i'm not sure, but probably no
14:57:45 <elliott> revenantphx: add to path? not that easy.
14:57:53 <elliott> that doesn't handle include headers libraries etc.
14:58:01 <dagle> Is there any way to ask lambdabot for the infix precedence?
14:58:02 <mm_freak> you might set ($) = id and think of some really crazy edge case involving bottom
14:58:06 <elliott> also, either you have to recompile EVERY SINGLE LIBRARY OS X ships with (almost impossible due to Apple patches),
14:58:08 <elliott> or you'll get conflicts.
14:58:09 <monochrom> but of course you could concede to "alert user to add to path" and that's easy and fair.
14:58:13 <mm_freak> @src (+)
14:58:14 <lambdabot> Source not found. Where did you learn to type?
14:58:15 <shachaf> dagle: No, but you can ask ghci.
14:58:20 <revenantphx> elliott: /usr/local/lib and /usr/local/include
14:58:22 <dagle> shachaf: How? :)
14:58:26 <shachaf> :i
14:58:29 <revenantphx> AKA, standard places 99% of programs look.
14:58:36 <shachaf> @vixen What's the infix precedence of $?
14:58:36 <lambdabot> let's don't talk about that
14:58:42 <shachaf> See?
14:58:46 <elliott> revenantphx: haha. i wish doing this was as easy as you seem to think it is.
14:58:50 <dagle> shachaf: Thx. Never noticed that it printed that. XD
14:58:53 <revenantphx> It is, I've been doing it for a long time.
14:59:03 <revenantphx> Nearly 2-3 years now.
14:59:05 <revenantphx> elliott: In addition, you don't need to ever to recompile anything built into os x.
14:59:11 <elliott> 4 here.
14:59:11 <revenantphx> I just leave that shit alone.
14:59:15 <elliott> (years)
14:59:17 <elliott> revenantphx: Yes you do.
14:59:19 <gwern> monochrom: but I've taken your advice and emailed -cafe
14:59:21 <revenantphx> I use my own Python 3.1, my own ruby 1.9, etc.
14:59:25 <elliott> Because libraries you compile requires newer versions of libraries OS X ships with.
14:59:28 <monochrom> \/
14:59:28 <revenantphx> my own llvm...
14:59:34 <elliott> (If this has never happened to you, then you just don't install enough libraries.)
14:59:36 <elliott> revenantphx: those are progarms.
14:59:36 <revenantphx> elliott: once again, /usr/local/
14:59:37 <elliott> *programs.
14:59:41 <elliott> revenantphx: and?
14:59:47 <elliott> as i said, eventually you end up with an impossible situation
14:59:49 <elliott> this is off-topic.
14:59:50 <gwern> I looked up my original 2009 email and -cafe seemed to find Summers of Code an interesting topic, so maybe I'll actually get some readers this time (as opposed to Hacker News where it languishes with no readers or comments)
14:59:50 <revenantphx> I installed llvm from source easily.
14:59:56 <elliott> but it's not nearly as painless as you think.
14:59:59 <revenantphx> Even though it's installed by the dev-tools cd.
15:00:03 <elliott> llvm isn't a library. (it is, but it's not primarily a library)
15:00:07 <revenantphx> I'm only claiming it's as painless as I've found it to be.
15:00:17 <revenantphx> elliott: Which is why it contains over 10 static libraries.
15:00:29 <revenantphx> libLLVMCore.a, libLLVMAnalysis.a, libLLVMJIT.a, etc etc etc
15:00:32 <elliott> "(it is, but it's not primarily a library)". you're just trolling at this point. anyway, whatever
15:00:49 <revenantphx> I'm not trolling, I'm stating reality as I've experienced it. 
15:01:07 <shachaf> Reality inside the Apple Reality Distortion Field.
15:01:12 <revenantphx> >_>
15:01:21 <elliott> yeah once I installed Ubuntu on this thing I was like
15:01:31 <quicksilver> elliott: some cases of dependent types, yes. What most people would consider 'full' dependent types requires compile time turing completeness.
15:01:34 <elliott> wow, I forgot that when you use an OS run by people who actually update libraries everything is so easy!
15:01:36 <taotree> if ghc-pkg check shows lots of broken packages... how do I fix it?
15:01:46 <elliott> quicksilver: That's not true.
15:01:46 <revenantphx> elliott: I agree it's irritating that they use old libraries,
15:01:48 <revenantphx> no question.
15:01:55 <revenantphx> But that doesn't mean it's not easy to have your own setup.
15:01:56 <elliott> quicksilver: You just have to ensure that types terminate.
15:02:06 <elliott> quicksilver: Do you not consider Coq, Agda, Epigram full dependent types?
15:02:41 * ski whispers "Cayenne"
15:03:19 <monochrom> revenantphx: you should blog how you did things so other people can benefit.
15:03:24 * gwern whispers back 'Absolut Cayenne'
15:03:31 <revenantphx> monochrom: Probably, I keep thinking about it.
15:03:38 <elliott> monochrom: "mkdir /usr/local. install things. ignore breakage."
15:03:38 <revenantphx> But I usually get the "well, I doubt anyone cares" sense.
15:03:46 <revenantphx> And then I think "also, I can't think of a blog name. Screw it"
15:04:05 <monochrom> use your irc nickname for blog name
15:04:10 <gwern> revenantphx: so write a text file and when you have 20 or 100, start up a blog
15:04:21 <revenantphx> haha, release weekly, never write for a year.
15:04:33 <revenantphx> hm, right of the bat, issue with cabal
15:04:35 <revenantphx> wonderful.
15:04:39 <revenantphx> Configuring Cabal-1.8.0.2...
15:04:39 <revenantphx> Setup: At least the following dependencies are missing:
15:04:39 <revenantphx> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
15:04:43 <gwern> really, you should keep notes regardless
15:04:43 <revenantphx> I have base 4.3.0.0 >_>
15:04:52 <kmc> is Apple evil? is Java dying? how to be a Real Hacker.  optimize your Javascript with HTML5
15:04:52 <gwern> add little to little and soon you will have a big pile
15:05:01 <monochrom> alternatively you can send email to haskell-cafe instead of create blog site.
15:05:05 <revenantphx> kmc: Webscale!
15:05:07 <gwern> kmc: yes, yes, already done, and huh?
15:05:22 <revenantphx> Thank goodness java is dying.
15:05:36 <revenantphx> Java is just... so bland.
15:05:42 <revenantphx> It has no "personality" as a language.
15:05:46 <shachaf> kmc: Netcraft now confirms: Java is dying.
15:05:51 <revenantphx> Unless you consider shit a personality.
15:11:04 <monochrom> java dies but its spirit c# lives.
15:11:39 <dcoutts> revenantphx: sorry about the error message, it's making an unhelpful suggestion about which packages are missing (since it has to backtrack there are multiple possibilities)
15:11:42 <Sgeo_> C# at least has lambdas
15:11:52 <monochrom> however since c# enjoys an industrial-strength verification story (spec#) I am not complaining :)
15:12:06 <dcoutts> revenantphx: but as you've gathered, the problem is that the constraints for that version of Cabal are not compatible with the libs you have installed with ghc-7
15:12:20 <revenantphx> I'm installing cabal from source :P
15:12:50 <accel> :t .
15:12:51 <lambdabot> parse error on input `.'
15:12:52 <accel> :t (.)
15:12:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:13:02 <dcoutts> revenantphx: note that no released version of cabal-install compiles with ghc-7
15:13:03 <revenantphx> C# is really just Java + neat features + a bunch of features obviously planted by Microsoft Research people.
15:13:07 <accel> @src .
15:13:07 <lambdabot> (f . g) x = f (g x)
15:13:07 <lambdabot> NB: In lambdabot,  (.) = fmap
15:13:12 <revenantphx> dcoutts: lol wonderful.
15:13:40 <dcoutts> revenantphx: but any recent version you have installed already will continue to work with ghc7
15:13:41 <accel> f . g = \x -> f $ g x ?
15:13:53 <revenantphx> ...I baleeted it.
15:13:54 <revenantphx> >_>
15:13:55 <dcoutts> revenantphx: if you really want a new one, you can use the darcs version
15:14:00 <revenantphx> that's what I was about to do.
15:14:03 <dcoutts> revenantphx: or compile it using an older ghc
15:14:15 * dcoutts is working on a new release
15:14:18 <Sgeo_> revenantphx, what features are Microsoft Research ones?
15:14:24 <elliott> revenantphx: this is why you use 6.12 instead
15:14:29 <revenantphx> Oh I don't know, LINQ?
15:14:32 <elliott> or at least you'll agree once you try and install some cabal package.
15:14:38 <revenantphx> The not so subtle list-monad?
15:14:46 <revenantphx> ALL OF F#?
15:14:48 <monochrom> yeah, use ghc 6.12.3 to build released cabal-install, then switch ghc to 7
15:15:11 <Sgeo_> revenantphx, F# is not a part of C# >.>
15:15:27 <accel> jmcarthur: do you see any example that does texturing + GLSL? in the Hakell GLUT directory, I see the GLSL brick example, and the redbook texturing examples; but no GLSL + texturing examples
15:15:32 <monochrom> (and since you know all about /usr/local/mydir and add-to-path, it should be easy)
15:15:43 <revenantphx> Sgeo_: Yes but many features have leaked over.
15:16:06 <monochrom> speaking of which, perhaps I should add that to my blog.
15:16:25 <jmcarthur> accel: head to #haskell-game :) we're bringing it back
15:16:27 <revenantphx> dcoutts: 
15:16:42 <revenantphx> darcs says to convince you to run darcs optimize --upgradw with darcs 2.40 or higher.
15:16:50 <dcoutts> revenantphx: yep, I know
15:16:52 <revenantphx> It says perhaps I could persuade you.
15:16:54 <elliott> Upgradw.
15:17:55 * dcoutts is waiting for darcs on darcs.haskell.org to be upgraded to 2.4 or higher
15:19:11 <oe0w0ei10u-3u2-9> :t .
15:19:12 <lambdabot> parse error on input `.'
15:23:29 <FunctorSalad> revenantphx: LINQ works with arbitrary monads actually... but I'm not sure whether using it for something like the Either Exception monad clarifies or obscures things ;)
15:23:34 <revenantphx> :O
15:24:34 <FunctorSalad> (you just need Select and one of the SelectMany overloads on your type)
15:24:53 <revenantphx> cabal's built :)
15:25:51 <olsner> FunctorSalad: do one for the reverse state monad
15:27:31 <FunctorSalad> hmm... class RWS<R,W,S,A> { readonly Func<R,S,Tuple<S,W,A>> value; readonly MonoidStructure<W> ms; }? ;)
15:27:43 <FunctorSalad> oh, reverse state, not rws
15:28:11 <kmc> to me it seems like Java and C# started from about the same set of (reasonable) design decisions; the difference is that Java's designers decided that their users are idiots and crippled its power intentionally
15:29:55 <kmc> and are adding features decades late (generics, basic FP) because they realized that even the supposed idiots will create better code this way
15:30:11 <djahandarie> drbean, .jp? :)
15:31:00 <nanothief> Has anyone used haskell for writing iPhone apps? I found this page: http://ipwnstudios.com/node/5 which says they have got it working, but the link to the project page, http://projects.haskell.org/ghc-iphone/ doesn't have anything. There is also a mailing list where people seem to have got it working at http://projects.haskell.org/ghc-iphone/
15:32:18 <monochrom> Cale is one. but he works for the same ipwnstudios. projects.haskell.org has fallen sick.
15:34:44 <nanothief> monochrom: ah right, didn't realize projects.haskell.org was down. Looking at the cached version of the page gave a lot more info, as well as info about a newer patch http://www.alpheccar.org/cross-compiling-haskell
15:37:14 <revenantphx> hm
15:37:21 <revenantphx> so llvm-0.9.0.1 fails :\
15:38:03 <djahandarie> How does it fail?
15:38:14 <revenantphx> also, what's -read_only_relocs?
15:38:21 <djahandarie> It directly calls things like 'opt', so you need to make sure they are the proper version
15:38:24 <revenantphx> I keep seeing messages saying it doesn't work with x86_64
15:38:29 <revenantphx> >_>
15:38:29 <djahandarie> (i.e., version 2.7)
15:38:46 <kmc> relocations in read-only data sections maybe/
15:38:54 <revenantphx> as well as "warning: #warning Setup.hs is guessing the version of Cabal. If compilation of Setup.hs fails use -DCABAL_VERSION_MINOR=x for Cabal version 1.x.0 when building (prefixed by --ghc-option= when using the 'cabal' command)"
15:39:08 <revenantphx> it's a message from ld
15:39:11 <revenantphx> ld: warning: -read_only_relocs cannot be used with x86_64
15:40:44 <revenantphx> I always see warnings about deprecated exceptions styles too :P
15:42:33 <benedikt> Should the haskell compiler not optimize code like this? http://codepad.org/xmA76pJt
15:43:21 <djahandarie> benedikt, optimize it how?
15:43:24 <revenantphx> https://gist.github.com/819624
15:43:27 <kelvie_> Is it expected for the HaXmL Xtract tool to use 1.2gigs of memory on a 18M xml file?
15:43:58 <djahandarie> revenantphx, is this not GHC 7?
15:44:10 <djahandarie> Latest llvm bindings may only work with 7
15:44:15 <benedikt> djahandarie: instead of calculating each value everytime it requested (will happen a lot) it stores it (Memoization)
15:44:25 <benedikt> (I'm new to haskell)
15:44:25 <revenantphx> It is GHC 7
15:44:29 <revenantphx> 7.0.1
15:44:29 <djahandarie> benedikt, no, it would be a bad idea to do that automatically.
15:44:59 <djahandarie> benedikt, but it's easy to do it if you import a module and use a function from there.
15:45:07 <benedikt> djahandarie: funtions like this are vrey well suited for dynamic programming
15:45:23 <benedikt> djahandarie: import this as a module?
15:45:29 <Bynbo7> benedikt: ghc doesn't do any automatic memoisation of functions, because in general it's either slower than recomputing the value, or uses a lot of memory
15:45:44 <Bynbo7> benedikt: then you should use dynamic programming :P
15:45:53 <djahandarie> benedikt, nope. Download another package which handles memoizing functions for you.
15:46:09 <djahandarie> See the package "MemoTrie"
15:46:12 <djahandarie> @hackage MemoTrie
15:46:12 <lambdabot> http://hackage.haskell.org/package/MemoTrie
15:46:15 <benedikt> Bynbo7: ok thanks. Yes, thats what I will do. I was just curious to how haskell would handle this
15:46:54 <djahandarie> You 'cabal install MemoTrie', then in your code, 'import Data.MemoTrie', then   memoizedF = memo f   , and call memoizedF from then on.
15:47:27 <Bynbo7> you need to replace the recursive call with memoisedF too i think
15:47:39 * FunctorSalad likes haddock's new instance-documentation feature
15:47:51 <mm_freak> is there a CT term for "monad transformer"?  i think that they are just morphisms in some category
15:48:19 <djahandarie> A lot of things are just morphisms in some category :P
15:48:46 <revenantphx> Any ideas on the llv?
15:48:47 <Bynbo7> they're morphisms in the category of endoautobotfunctors
15:48:48 <revenantphx> llvm*
15:49:15 <mm_freak> Bynbo7: joke?
15:49:21 <djahandarie> revenantphx, it's a fairly odd break.
15:49:25 <Bynbo7> yes :P
15:49:28 <revenantphx> yeah...
15:49:42 <revenantphx> It's a type error at that.
15:49:49 <Bynbo7> it would be very awesome if it weren't a joke though
15:49:59 <djahandarie> revenantphx, yes, that's why it's odd.
15:50:29 <revenantphx> oh, look at the case statement for 'packageDb'
15:50:32 <Bynbo7> revenantphx: talk to dcoutts about it, i think i had the same problem before, and i don't remember how i fixed it
15:50:35 <revenantphx> xs -> xs doesn't have to be a list?
15:50:42 <revenantphx> though i'd think flagToList
15:50:44 <revenantphx> would give you a list.
15:50:45 <revenantphx> so wtf
15:50:49 <revenantphx> dcoutts: OU.
15:50:50 <revenantphx> OY*
15:50:53 <revenantphx> this is a cabal issue, halp
15:51:02 <elliott> Is there a way to do "data T = T {-# UNPACK #-} !X {-# UNPACK #-} !Y" as a tuple?
15:51:03 <elliott> i.e.
15:51:05 <elliott> type T = (X,Y)
15:51:11 <elliott> I want to strictify-and-unpack both elements.
15:51:15 <elliott> Do I have to change to a non-tuple data type?
15:51:31 <djahandarie> mm_freak, I think the general idea is that you express the transformers as monad alyerings, which are then just monad morphisms
15:51:34 <dcoutts> elliott: unless you want to use even less portable ghcisms
15:51:40 <elliott> dcoutts: Sounds good, what do I need?
15:51:57 <dcoutts> elliott: there's unboxed tuples (# x, y #)
15:51:58 <ski> elliott : maybe `type T = (# X , Y #)'
15:51:58 <FunctorSalad> there are unboxed tuples, but they have some strong restrictions which I don't remember
15:52:16 <dcoutts> revenantphx: what's the problem?
15:52:16 <elliott> dcoutts: I can't pattern-match on them with (x,y). :p
15:52:24 <dcoutts> elliott: indeed
15:52:25 <djahandarie> > (# 1, 2 #)
15:52:26 <lambdabot>   Illegal binding of unboxed tuple e_112 :: (# t_a3cN, t_a3cP #)
15:52:29 <elliott> If I have to change pattern-matching and such, I'll just jump straight to a new constructor.
15:52:29 <mm_freak> djahandarie: so it's valid to call them morphisms?  i'm asking because i need to translate "monad transformer" to german and "monadentransformierer" sounds really funny
15:52:35 <elliott> But I'd reaaaally rather keep it being a tuple :-(
15:52:51 <ski> > case (# 1 , 2 #) of (# x , y #) -> x + y
15:52:51 <lambdabot>   3
15:52:58 <FunctorSalad> > let f (# x, y #) = x+y in f (# 1,29 #)
15:52:59 <lambdabot>   Couldn't match kind `(#)' against `??'Couldn't match kind `(#)' against `??'
15:53:05 <revenantphx> dcouts, lemme paste
15:53:06 <ski> > let (# x , y #) = (# 1 , 2 #) in x + y
15:53:07 <lambdabot>   3
15:53:11 <revenantphx> https://gist.github.com/819624
15:53:11 <revenantphx> http://code.haskell.org/llvm/Setup.hs
15:53:14 <djahandarie> mm_freak, no, that wouldn't be true.
15:53:15 <revenantphx> (error, and relevant file)
15:53:25 <Bynbo7> > case (# 1::Int, False #) of (# x,b #) -> x
15:53:26 <lambdabot>   1
15:53:42 <ski> FunctorSalad : i think it's sortof silly that you can't have unboxed tuples as arguments ..
15:53:45 <mm_freak> djahandarie: "monad function" might work, but that may be very misleading
15:54:08 <djahandarie> mm_freak, read http://blog.sigfpe.com/2007/02/monads-for-vector-spaces-probability.html?showComment=1172511660000#c8246574813074210288 and down
15:54:53 <mm_freak> djahandarie: do i really need to study a whole article to come up with a good term?  sigfpe's articles are usually not very short
15:54:53 <elliott> Hmm, is there any way to get "(!A, !B)" working at least?
15:54:58 <ski> mm_freak : in any case "monad morphism" isn't good .. since that refers to things like `listToMaybe' and such
15:55:01 <elliott> Then I could use -funbox-strict-fields or whatever it's called.
15:55:07 <elliott> mm_freak: he linked to a comment
15:55:19 <mm_freak> ski: "listToMaybe" is rather a natural transformation
15:55:24 <elliott> But that article is short FWIW.
15:55:25 <revenantphx> dcoutts: any idea?
15:55:31 <ski> mm_freak : it is. it is also a monad morphism
15:55:40 <mm_freak> ski: i see
15:55:41 <djahandarie> mm_freak, it's a link to a comment (a long one though). Either way, monad morphism isn't a good idea for monad transformer
15:55:49 <ski> mm_freak : a monad morphism being a natural transformation that preserves `return' and `join'
15:55:50 <mm_freak> ok
15:56:21 <ski> mm_freak : so monad morphisms are morphisms between monads (being objects in the category of monads (on `Hask'))
15:56:36 <ski> mm_freak : what you want is morphisms in some category where monads are *values* of some object
15:56:36 <dcoutts> revenantphx: what version of Cabal are you using now?
15:56:41 <revenantphx> one moment.
15:56:49 <dcoutts> revenantphx: that Setup.hs works with Cabal-1.10
15:56:59 <mm_freak> but aren't monad transformers also morphisms in some functor category?
15:57:01 <drbean> djahandarie: Yes, until next week, when I return to Taiwan.
15:57:07 <ski> mm_freak : presumably one object would be the monads of `Hask'/`*', and another be the monads of `* -> *', &c.
15:57:48 <FunctorSalad> Func(Monad(Hask),Monad(Hask))?
15:57:52 <djahandarie> Where / is a slice category?
15:58:01 <ski> where `/' means "aka"
15:58:02 <FunctorSalad> with Monad(Hask) having the morphisms ski just described
15:58:05 <djahandarie> Ah.
15:58:14 <djahandarie> Was wondering why kinds were in Hask
15:58:28 <FunctorSalad> though class MonadTrans doesn't actually lift natural transformations between monads
15:58:45 <FunctorSalad> but IIRC it does in some other library
15:58:50 <FunctorSalad> (than mtl)
15:59:19 <mm_freak> i only know a library, which derives monads from isomorphic monads (monadLib)
15:59:31 <djahandarie> mm_freak, either way, there is no simple answer here if that's all you're looking for
15:59:43 <mm_freak> hmm, ok
16:00:19 <djahandarie> drbean, neat, what are you there for?
16:00:39 <dcoutts> revenantphx: sorted out?
16:00:47 <revenantphx> no sorry, back
16:01:04 <revenantphx> dlukesmacbookpro:cabal-install dlukes$ cabal --version
16:01:04 <revenantphx> cabal-install version 0.9.5
16:01:04 <revenantphx> using version 1.10.0.0 of the Cabal library 
16:01:10 <revenantphx> dcoutts: ^
16:01:28 <revenantphx> I got the newest off of darcs.
16:01:39 <djahandarie> mm_freak, but in case you are still interested, this paper looks like it will answer everything http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#combining-monads
16:01:57 <djahandarie> Though I haven't read it
16:01:58 <mm_freak> djahandarie: thanks
16:03:33 <revenantphx> I'm baffled personally  dcoutts 
16:04:27 <dcoutts> revenantphx: does ghc-pkg list indicate Cabal-1.10 is registered?
16:04:27 <djahandarie> MonadSalat perhaps...
16:04:51 <revenantphx> tes
16:04:52 <revenantphx> https://gist.github.com/819665
16:04:53 <revenantphx> yes*
16:04:55 <dcoutts> revenantphx: remember that cabal has to compile the Setup.hs and it will use the ghc that you're running now, not the one it was compiled with
16:05:08 <revenantphx> It was compiled with 7.0.1
16:05:12 <revenantphx> I totally purged all old GHC.
16:05:50 <dcoutts> revenantphx: can you past the output with -v so we can see how cabal compiles Setup.hs
16:05:53 <revenantphx> mmk
16:06:18 <revenantphx> https://gist.github.com/819671
16:07:27 <dcoutts> revenantphx: ohh !
16:07:30 <revenantphx> I also confirmed the ghc at /usr/local/bin/ghc is in fact ghc 7.01
16:07:36 <revenantphx> figured it out?
16:07:40 <dcoutts> revenantphx: the Setup.hs that you gave me is not the one in the released package
16:07:47 <dcoutts> revenantphx: they've fixed it in the darcs version
16:07:52 <dcoutts> is my guess
16:07:59 <revenantphx> :|
16:08:02 <revenantphx> oh, hah.
16:08:16 <revenantphx> It installed before under 6.12.3
16:08:25 <dcoutts> right, using older Cabal lib version
16:08:35 <revenantphx> I'll pull it from darcs then
16:08:35 <dcoutts> they've fixed the darcs version to work with Cabal 1.10
16:08:51 * dcoutts disappears
16:08:57 <djahandarie> Magic!
16:12:52 <drbean> djahandarie: In  I'm visiting family and friends. In , I'm working.
16:13:16 <djahandarie> I see
16:13:43 <djahandarie> I only speak some  but I can infer what the second one means. ;)
16:14:11 <djahandarie> In fact, I think that's what it is in Japanese too
16:14:18 * djahandarie checks
16:14:44 <djahandarie> Heh, it is.
16:17:16 * djahandarie wishes he could go to Japan again but has no time/money
16:18:27 <revenantphx> If I get into CMU and do well, I'm considering Japan as a study abroad destination.
16:21:44 * ski . o O ( if time is money, then `time / money = 1' .. but maybe it would be better to say that there's a constant converting between the different magnitudes )
16:23:24 <stepkut> any idea if 'doesDirectoryExist' returning True implies that it is also readable ?
16:23:34 <Eduard_Munteanu> I wish I could speak some of that square square square.
16:25:49 <Saizan> i wish my font didn't truncate kanjis like that, ni looked like exists at first.
16:26:02 <stepkut> time = A * money + C
16:26:41 <dschoepe> stepkut: Probably not.
16:27:06 <dschoepe> stepkut: Since you can create a directory, then chmod it to 0000 and still see it, but not enter it
16:27:30 <drbean> data Money  = Time | Money
16:28:16 <ski> stepkut : i couldn't when i tried basically what dschoepe described
16:28:39 * stepkut realizes he could have just tried this as well
16:29:03 <ski> well, the more evidence, the better, right ?
16:29:46 <stepkut> ok, so I will also check for readability
16:30:01 <ski> beware of race conditions, of course
16:30:25 <c_wraith> race conditions are so...  imperative
16:31:00 <ski> (possibly the best would be just try to use `getDirectoryContents', and catch the readability permission exception, if any)
16:31:12 <monochrom> newtype US'Economy = X (Money -> US'Economy)
16:32:04 <Eduard_Munteanu> Is that like a Hungry economy? :P
16:32:22 <monochrom> Yes!
16:32:24 <ski>   newtype US money = X (money -> US money)  -- this better ?
16:32:31 <revenantphx> :D
16:32:32 <monochrom> even better
16:32:48 <revenantphx> brew install llvm + darcs get --partial http://code.haskell.org/llvm + cabal install =
16:32:53 <revenantphx> 64 bit llvm haskell bindings, easy :D
16:33:37 <monochrom> this lesson teaches you that just because the type is called "US money" doesn't mean you can "how do I extract money from that type?"  No no, you get it wrong, you have to put money into it...
16:35:00 <monochrom> use this to answer people who ask "how do I extract Money from IO Money"
16:37:02 <revenantphx> unsafePerformIO ;D
16:37:29 <monochrom> unsafePrintMoney
16:37:37 <monochrom> unsafeQE
16:37:42 <revenantphx> that's a fan favorite up at the Federal Reserve.
16:37:49 <monochrom> yeah
16:37:58 <copumpkin> extractMoney :: IO Money -> Money; extractMoney = extractMoney
16:38:01 <copumpkin> that's the easiest way
16:38:03 <revenantphx> My prediction:
16:38:15 <revenantphx> for some random reason china says "pay debt now or else"
16:38:21 <revenantphx> US prints trillions of dollars
16:38:25 <revenantphx> currency becomes SHIT.
16:38:44 <int80_h> I have a [[String]]. Each inside [String] has two elements,["foo","bar"]. So I have something like [["foo","bar"],["baz","bong"]]. I would like to do something like this. It's incorrect code but I think it gets the idea across. I think I need to make a lambda for the middle part. map (head ++ "=" ++ last) fCookie. The question is, how do I form the lambda for the (head ++ "=" ++ last) part?
16:39:47 <FunctorSalad> is it possible to *get* a signal/event handler for a widget in gtk2hs somehow?
16:39:58 <c_wraith> (\x -> head x ++ "=" ++ last x)
16:40:02 * ski . o O ( "the credit card transform" )
16:40:22 <FunctorSalad> (trying to remap keys on a TreeView so "j" does the same as cursor-down etc)
16:40:26 <c_wraith> though, you might do better with just: (intercalate "=")
16:40:26 <int80_h> close, it's a header Cookie transform
16:40:41 <int80_h> and by close I mean not related in any way.
16:40:42 <monochrom> no, I think you can't. but when you "on" (register) a handler, you get a handle on it, you can use the handle to unregister later.
16:41:04 <int80_h> @hoogle intercalate
16:41:04 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
16:41:04 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:41:04 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
16:41:13 <c_wraith> > map (intercalate "=") [["one", "two"], ["three", "four"]]
16:41:13 <FunctorSalad> monochrom: hmm, I think I'd need to get the default handler
16:41:14 <lambdabot>   ["one=two","three=four"]
16:41:26 <monochrom> oh, you want to override? register your own handler and have it return True to indicate you want to override
16:41:29 <int80_h> oh neat!
16:41:41 <ski> > ((return . head) ++ return "=" ++ (return . last)) "abcd"
16:41:43 <c_wraith> You'll have to import that from Data.List
16:41:43 <lambdabot>   "a=d"
16:42:02 <int80_h> I'm using Data.List for other things as well.
16:42:02 <monochrom> also for keyboard/mouse events you have to turn something on
16:42:19 <FunctorSalad> monochrom: yes, but the override for "j" is supposed to invoke the default for "down" :)
16:42:43 <ski> int80_h : ^ that good enough ?
16:42:44 <FunctorSalad> moving down in a tree view is a bit tricky since it depends on current visibility of nodes...
16:42:52 <monochrom> something about EventMask
16:42:56 <elliott> Is there anything wrong-looking about this?: StateT $ \s -> runStateT blah s `catch` \(_::IOException) -> runStateT handleThatError s
16:43:04 <int80_h> ski: show off :)
16:43:12 <int80_h> intercalate is exactly right
16:43:15 <monochrom> well then I don't know
16:43:28 <ski> > msum (((:[]) . head) ++ return "=" ++ ((:[]) . last)) "abcd"  -- clearer, but maybe uglier
16:43:28 <lambdabot>   Couldn't match expected type `[m a]'
16:43:29 <lambdabot>         against inferred type `[GHC.Ty...
16:43:31 <ski> er
16:43:33 <int80_h> almost done with alpha release!
16:43:34 <ski> > (((:[]) . head) ++ return "=" ++ ((:[]) . last)) "abcd"  -- clearer, but maybe uglier
16:43:35 <monochrom> IMO obsession with vi's hjkl is sick anyway.
16:43:35 <lambdabot>   "a=d"
16:44:03 <monochrom> the people who want to use hjkl for cursor keys is a dying breed.
16:44:15 <elliott> nethack player.s
16:44:17 <elliott> *players.
16:44:33 <FunctorSalad> monochrom: I try to find applications that support it whenever possible :) (pdf viewer, browser, ...)
16:44:52 <ski> yeah, everyone uses `^B^N^P^F' these days ..
16:44:53 <HugoDaniel> monochrom, i use hjkl for cursor keys
16:44:56 <FunctorSalad> it's just much more ergonomic than reaching for the cursor keys imho (or I'm too lazy to move my arm)
16:45:21 <FunctorSalad> aptitude supports it too, luckily
16:45:33 <accel> must haskell file names start with a capital letter?
16:45:47 <elliott> haskell module names must.
16:45:54 <elliott> usually you want to treat haskell files as modules.
16:45:54 <elliott> so yes.
16:45:58 <elliott> but one-off program files don't have to be
16:46:05 <FunctorSalad> (and anyway, expand/collapse is not even on right/left in gtk, but on -/+ ...)
16:46:08 <accel> hmm; how can I get around this?
16:46:12 <FunctorSalad> *+/-
16:46:14 <c_wraith> you don't.
16:46:23 <accel> it screws up my typing to ahve to hit shift right after e
16:46:28 <accel> i.e. right now, stuff is
16:46:32 <monochrom> the Main module could be called $12e-6.hs if you like
16:46:40 <accel> "e <shift>Cam<tab>"
16:46:45 <accel> whereas, I just want to type "e cam<tab>"
16:46:59 <accel> so there's no way to tell haskell "also search for lowercase version of module name" ?
16:46:59 <c_wraith> then use case-insensitive tab-expansion
16:47:00 <drhodes> have the build script rename the files
16:47:11 <accel> drhodes: can cabal do this automaticaly?
16:47:14 <drhodes> no idea
16:47:15 <monochrom> use symbolic links.
16:47:24 <ski> or hard links ..
16:47:25 <elliott> accel: Just get used to it.
16:47:31 <elliott> As far as languages complaints go that's a pretty silly one.
16:47:34 <monochrom> some editors break hard links
16:47:35 <elliott> Destroying consistency for the sake of the shift key?
16:47:53 <ski> hm, granted
16:48:29 <monochrom> you see "destroying consistency for the sake of the shift key" and "hacking gtk for the sake of hjkl" are comfortably in the same league
16:48:40 <FunctorSalad> :)
16:48:58 <FunctorSalad> (well, it adds consistency for people who expect hjkl :))
16:48:59 <accel> monochrom: who ahcked gtk for the sake of hjkl ... taht person is a vim user, and my friend
16:49:14 * monochrom does not understand going out of one's way for such tiny trivialities.
16:49:18 <c_wraith> eh.  I don't use vim.  I use hjkl because of nethack. :)
16:49:49 * lispy waits for someone to say they used it for emacs viper mode
16:50:07 <FunctorSalad> I did when I used emacs :)
16:50:16 <monochrom> "this font displays the letter t with 0.5 too many subpixels than I want. I will turn the whole world upside down to fix this."
16:50:27 <accel> emacs viper mode was the worst thing ever ... it was like a super model zombie
16:51:04 <kulakowski> FunctorSalad: what do you use now?
16:51:04 <revenantphx> Well, I have a similar issue to before.
16:51:05 <revenantphx> Loading package llvm-0.9.1.0 ... can't load .so/.DLL for: LLVM-2.8 (dlopen(libLLVM-2.8.dylib, 9): image not found)
16:51:10 <revenantphx> Except, llvm has no dylib.
16:51:15 <revenantphx> It's entirely static libraries D:
16:51:19 <ski> (monochrom : indeed, there must be some proportionality here. obviously everything should conform to my wishes)
16:51:25 <BMeph> Does anyone on have a ballpark guess as to when GHC 7.0.2, or .3 is coming out, and thus we'll see HP 2011.2?
16:51:40 <FunctorSalad> kulakowski: vim, mostly due to getting too frustrated with my initscript/library ;)
16:51:49 <FunctorSalad> (in emacs)
16:52:13 <monochrom> Bikeshed colours look so much more important when people can readily divide over one shift key.
16:52:50 <FunctorSalad> they add up, imagine the energy use!
16:52:53 <FunctorSalad> ;)
16:53:06 <monochrom> anyway, symbolic link
16:53:47 <monochrom> you can pretty please call your file's true name "$12e-6.exe" if you symlink ImportantModule.hs to it.
16:53:53 <FunctorSalad> though I happen to support mandatory capitalization rules since it's one less thing to remember and arbitrarily decide
16:54:31 <FunctorSalad> (remember how the identifier you need was capitalized, that is)
16:54:54 <shachaf> FunctorSalad: It would be better if capitalization was just eliminated completely.
16:55:01 <shachaf> Wait, is this about Haskell or English?
16:55:34 <FunctorSalad> haskell/programming
16:56:20 * hackagebot hsgsom 0.2.0 - An implementation of the GSOM clustering algorithm.  http://hackage.haskell.org/package/hsgsom-0.2.0 (StephanGuenther)
16:57:48 <revenantphx> In my high school CS course we're having a sorting algorithm shootout.
16:57:52 <revenantphx> In 5 categories.
16:58:03 <revenantphx> I'm hoping to get away with using Cocktail Sort for the Bubble Sort :3
17:00:08 <shachaf> Why do people even talk about bubble sort?
17:00:16 <c_wraith> it's optimal*!
17:00:52 <FunctorSalad> imagine parallel bubble sort, like real bubbles!
17:01:45 <c_wraith> Bubblesort is the optimal sort in the case when you can only fit two elements in memory at a time, swaps are expensive, and seeks are expensive :)
17:02:06 <int80_h> http://hpaste.org/43834/another_type_error
17:02:53 <revenantphx> So, if I were to start a blog to document how to get stuff working, how would you recommend I do so?
17:03:12 <mauke> int80_h: you can't "lift out of" IO
17:03:12 <revenantphx> Something with a nice syntax highlighting module >_>
17:03:14 <elliott> Is there a way to override StateT's pattern match failure stuff? (I realise this is a horrid thing to want.)
17:03:15 <int80_h> use Yesod!
17:03:31 <int80_h> mauke: hmm then I misunderstand what liftIO is doing
17:03:34 <revenantphx> I actually don't have a webserver or domain to host on at the moment actually.
17:03:36 <mauke> :t liftIO
17:03:37 <lambdabot>     Ambiguous occurrence `liftIO'
17:03:37 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
17:03:37 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
17:03:43 <mauke> oh fuck you
17:03:50 <mauke> :t Control.Monad.Error.liftIO
17:03:50 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
17:04:01 <int80_h> ah!
17:04:08 <mauke> int80_h: it generalizes IO a to m a for some MonadIO m
17:04:16 <revenantphx> Any recommendations?
17:04:24 <revenantphx> worst case I just use a wordpress >_>
17:04:33 <revenantphx> Since I believe I can dump posts to transfer them.
17:04:34 <mauke> i.e. it wraps IO actions in some other stuff
17:04:50 <revenantphx> To be honest, getting GHC 7.0.1 + LLVM installed has been enough of an ordeal to document it.
17:04:52 <int80_h> and <- unwraps an IO action right?
17:05:03 <elliott> maybe I'll just put ContT in my monad stack. what can go wrong!
17:05:27 <elliott> StateT s (ContT IO) -- this lets you do a continuation jump without backtracking state, right?
17:05:40 <int80_h> mauke: and <- unwraps an IO action right?
17:05:45 <int80_h> :t <-
17:05:46 <lambdabot> parse error on input `<-'
17:05:50 <int80_h> hmm
17:05:57 <mauke> int80_h: you can't "unwrap" an action
17:06:01 <mauke> int80_h: you can only run it
17:06:10 <mauke> int80_h: except you can't, because that would be impure
17:07:02 <int80_h> I wish I could ask a more precise question, but I can't think of one. Can you give me a clue to the solution?
17:08:00 <mauke> well, IMHO the real solution is learning what >>= does
17:08:14 <int80_h> good enough, I'll go read
17:08:17 <mauke> but if you just want to make your code work, yes
17:08:32 <mauke> if 'x <- y' and y :: m a, then x :: a
17:08:33 <int80_h> well yeah, but  I picked haskell for this project to learn it better
17:09:03 <mauke> so you need one <- for the result of getInfo, and none for fromInfoValue
17:09:05 <Ferdirand> > do { a <- [1,10]; b <- [2,3] ; [a*b
17:09:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:09:08 <Ferdirand> oops
17:09:19 <Ferdirand> > do { a <- [1,10]; b <- [2,3] ; [a*b] }
17:09:20 <lambdabot>   [2,3,20,30]
17:10:32 <copumpkin> preflex: seen j-invariant
17:10:32 <preflex>  j-invariant was last seen on #haskell 5 days, 24 minutes and 32 seconds ago, saying: data a := b where Refl :: a := a
17:13:11 <int80_h> :t >>=
17:13:12 <lambdabot> parse error on input `>>='
17:13:40 <int80_h> mauke: that seemed to work. It compiles anyway
17:14:23 <mauke> http://mauke.dyndns.org/stuff/haskell/how-to-io.html is an incomplete braindump of my thoughts about IO
17:15:20 <revenantphx> okay so
17:15:26 <revenantphx> it works in ghci, but not compiled
17:15:27 <revenantphx> https://gist.github.com/819755
17:15:37 <revenantphx> Even if I explicitly link in the interpreter this occurs.
17:15:49 <revenantphx> ghci works perfectly though, no issues.
17:16:31 <revenantphx> In the end the trick was compiling llvm with the --shared flag.
17:18:00 <seydar> blackdog: hey
17:18:14 <seydar> don't know what time it is in australialand
17:18:20 <blackdog> seydar: hey there
17:18:24 <blackdog> lunchtime
17:18:31 <int80_h> :t writeFile
17:18:32 <lambdabot> FilePath -> String -> IO ()
17:19:11 <seydar> blackdog: superb! so i can't get hubris to install. i need to go back and take another look to figure out why (i wish i had written it down)
17:22:05 <int80_h> what's the opposite of >>= ?
17:22:13 <revenantphx> =<<?
17:22:19 <int80_h> that's it
17:22:22 <revenantphx> :t (=<<)
17:22:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:22:26 <revenantphx> :t (>>=)
17:22:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:22:31 <Axman6> @src (=<<)
17:22:31 <lambdabot> f =<< x = x >>= f
17:22:34 <revenantphx> it's just flip.
17:22:45 <int80_h> :t flip
17:22:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:23:01 <revenantphx> that's such a succinct definition.  
17:25:30 <int80_h> I can't understand that definition
17:25:43 <int80_h> I mean I don't
17:27:50 <Axman6> it's just (=<<) f x = (>>=) x f
17:28:18 <int80_h> from LYAH
17:28:21 <int80_h> >>= allows us to feed a monadic value to a function that takes a normal one. 
17:28:34 <int80_h> alrighty then. That's far clearer
17:29:04 <int80_h> :t writeFile
17:29:04 <lambdabot> FilePath -> String -> IO ()
17:32:36 <int80_h> okay, stumped again. Paste forthcoming
17:41:27 <int80_h> if I have a function with a pure return type, say [String], that gets put into IO if the last line of a do construct is return [foo]. Right?
17:41:50 <int80_h> also, I'm calling this function from main
17:41:54 <mauke> do-blocks don't matter
17:42:05 <mauke> 'return' is the IO constructor
17:42:21 <int80_h> okay I need to change some things around
17:43:43 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml  new gimmick :)
17:44:43 <int80_h> http://hpaste.org/43835/i_got_the_io__blues
17:46:01 <monochrom> you have too few parameters for fmap
17:46:19 <monochrom> also fmap is not appropriate for this. mapM_
17:46:49 <monochrom> but then calling writeFile many times, one per line or something, is stupidly slow.
17:47:03 <int80_h> hmm
17:47:08 <monochrom> writeFile "formattedcookies.txt" =<<  fmap concat (obtainCookies curl body)
17:47:25 <revenantphx> Now that LLVM works (in ghci at least), I can start researching for my project :D
17:47:38 <revenantphx> Next year for my independent study I'm going to write an LLVM-backed language.
17:47:43 <revenantphx> I'm still brainstorming featurees.
17:47:50 <revenantphx> It shouldn't be super hard though, mind you.
17:48:02 <monochrom> Agda to LLVM
17:48:08 <revenantphx> relatively simple language, with one or two really unique features (or at least that a high school teacher wouldn't know)
17:48:17 <monochrom> or ATS to LLVM if you like. same difference.
17:48:21 <revenantphx> Are they simple?
17:48:30 <revenantphx> ATS keeps raping the language shootout charts.
17:48:34 <revenantphx> That's all I know about it.
17:49:01 <monochrom> perhaps ATS is simpler because it already enjoys existing work.
17:49:19 <revenantphx> So how complex is the language?
17:50:46 <Axman6> it can get very complex
17:50:48 <monochrom> you probably don't care. you care how complex is translating the language to LLVM. this can be highly independent of the language if someone already has written a compiler in which an intermediate form is used. This means you should ask how complex is the existing intermediate form.
17:51:05 <revenantphx> Well remember, I've had no experience with language/compiler design
17:51:06 <revenantphx> Ever.
17:51:14 <revenantphx> I'm only 16 for god's sake.
17:51:22 <Axman6> http://www.cs.bu.edu/~hwxi/ATS/EXAMPLE/MISC/listquicksort.dats
17:51:23 <revenantphx> This is supposed to be an "intro/research" type project.
17:51:27 <monochrom> more reason to rape an existing compiler
17:51:30 <revenantphx> Something I can finish in a school year.
17:51:40 <Axman6> that's quicksort in ATS, where the types guarantee the results will be sorted
17:52:14 <revenantphx> monochrom: Well I suppose I have plenty of time to try simpler languages during the summer.
17:52:29 <monochrom> intermediate forms are always simpler
17:52:35 <revenantphx> I could start with scheme in LLVM perhaps.
17:52:45 <revenantphx> Or something I know minimizes the parsing/lexing work.
17:52:54 <revenantphx> As long as you don't introduce sugar, scheme is pretty easy.
17:53:01 <revenantphx> (though desugared lisp is just painful to write)
17:53:09 <monochrom> you are not listening.
17:53:26 <revenantphx> I get that outputting to an intermediate form is easier.
17:53:41 <monochrom> No. You are inputting from an intermediate form.
17:54:21 <revenantphx> Okay I think we're not on the same page here >_<. Explain what you mean?
17:54:39 <int80_h> what's the opposite of tail?
17:54:46 <revenantphx> head
17:54:53 <Ferdirand> define opposite
17:54:56 <int80_h> that is returns all but the last element of a list
17:55:00 <Ferdirand> init
17:55:02 <revenantphx> Oh, iit
17:55:04 <revenantphx> ^
17:55:15 <copumpkin> init, innit?
17:55:20 <revenantphx> yep
17:55:32 <revenantphx> monochrom: So...
17:55:51 <monochrom> In other words, for example, suppose you plan to do, on the surface, "ATS->LLVM". What you really do: forget ATS, steal the existing ATS compiler, steal its intermediate form, do "intermediate form -> LLVM". Your program never sees ATS source code.
17:56:03 <revenantphx> Hah, not a bad idea.
17:56:51 <revenantphx> I need to learn LLVM assembly and more 'bout SSA and such anyhow
17:57:04 <monochrom> This is called "stand on the dead body of Hongwei Xi" or something.
17:57:05 <Philippa> revenantphx: start with STLC->LLVM?
17:57:44 <Philippa> getting as far as a miniML ought to impress the hell out of a highschool teacher anyway :-)
17:58:33 <revenantphx> My lack of knowledge of lambda calculus bears its fangs once more.
17:59:00 <revenantphx> I need to read through TaPL. Until college applications are in though ,it'll be hard to get enough time to sit down and do exercises.
17:59:05 <Saizan> extra bonus points for implementing lazyness
17:59:09 <revenantphx> TaPL's been all lonely-like sitting on my desk.
17:59:10 <revenantphx> :(
17:59:10 <copumpkin> revenantphx: take a moment to learn it. 5 minutes later you'll know all about how lambda calculus works :p
17:59:18 <revenantphx> STLC you mean?
17:59:42 <revenantphx> what's "it"?
17:59:43 <revenantphx> > it
17:59:44 <lambdabot>   Not in scope: `it'
17:59:44 <copumpkin> revenantphx: it's the world's simplest programming language, and like most programming languages learning the basic rules takes very little time, but understanding their implications might take forever :)
17:59:49 <gwern> http://www.haskell.org/haskellwiki/User_talk:Lover_of_justice#Recent_contributions <-- some people...
17:59:53 <revenantphx> copumpkin: heh.
17:59:54 <copumpkin> revenantphx: you just said you didn't know LC
18:00:12 <gwern> revenantphx: funny thing, I ordered TaPL and when I got it, I opened it up and realized I didn't have nearly the background to understand it
18:00:16 <gwern> I hate when that happens
18:00:25 <Philippa> revenantphx: STLC is the fragment of haskell such that - you have variables, applications and single-variable lambdas and that's it, and the type system consists of primitives of kind * and ->
18:00:33 <revenantphx> gwern: That's why I ordered Concrete Mathematics, as well as a book on set theory.
18:00:41 <Philippa> (optionally you can have an explicitly-typed version, in which lambdas all have annotations on their single parameters)
18:00:47 <revenantphx> -> is function yes?
18:00:48 <revenantphx> * is what?
18:00:50 <Philippa> exception: you have a bit more leeway about evaluation
18:00:51 <Philippa> yep
18:00:58 <Saizan> TaPL looked fairly self-contained to me
18:01:13 <revenantphx> TaPL is fairly self contained, they even introduce all of the ideas used from set theory
18:01:16 <Philippa> it's a 'nullary' type constructor
18:01:20 <revenantphx> though it's a very terse and incomplete section.
18:01:27 <copumpkin> self-contained is always with respect to the reader, as much as people try to deny it :p
18:01:29 <revenantphx> It took me a bit to parse what they were saying about relations.
18:01:34 <revenantphx> copumpkin: ^
18:01:41 <copumpkin> many people claim awodey's CT book is self-contained
18:01:50 <Philippa> yeah, mostly the set theory bit's a "here's my syntax" section
18:01:51 <copumpkin> it's self-contained if you're satisfied with understanding none of the examples
18:01:52 <revenantphx> I got awodey's CT book as well to read later.
18:01:54 <revenantphx> >_>
18:02:02 <Tau> # cylinder :: (RealFloat a) => a -> a -> a   what does (RealFloat) stands for ?
18:02:05 <Tau> -s
18:02:06 <revenantphx> I literally have aaaaaall of these books queued up to read ;D
18:02:22 <revenantphx> If I go through and don't understand them, I'll go find awodey
18:02:29 <revenantphx> he works some 20 minutes from my house walking.
18:02:40 <Philippa> (you can write a lambda calculus evaluator that uses eager evaluation btw, and I'd recommend doing that first because if nothing else it'll shit your teacher less - you might want to add fix as a builtin though because you can't type it otherwise)
18:02:43 <Saizan> well, if it explains how to read inference rules what else do you need?:)
18:02:50 <Philippa> (alternatively letrec is just as good)
18:03:02 <revenantphx> so... hm
18:03:05 <revenantphx> explain * a bit more?
18:03:08 <revenantphx> I saw that in haskell too.
18:03:16 <Philippa> * is the kind of type-level things that're actually types
18:03:24 <revenantphx> So it's a metatype?
18:03:25 <Philippa> as opposed to Maybe, which has kind * -> *
18:03:28 <revenantphx> its the type of types?
18:03:31 <revenantphx> >_<???
18:03:32 <Philippa> yeah
18:03:52 <revenantphx> :t Maybe
18:03:53 <lambdabot> Not in scope: data constructor `Maybe'
18:03:56 <copumpkin> :k Maybe
18:03:56 <Philippa> :k Maybe
18:03:56 <lambdabot> * -> *
18:03:57 <lambdabot> * -> *
18:04:02 <revenantphx> oh no, what's k?
18:04:06 <copumpkin> kind :)
18:04:06 <Philippa> "kind"
18:04:10 <revenantphx> :k ReaderT
18:04:10 <lambdabot> * -> (* -> *) -> * -> *
18:04:14 <revenantphx> >_>
18:04:19 <revenantphx> :k Either
18:04:20 <copumpkin> :k RWST
18:04:20 <lambdabot> * -> * -> *
18:04:21 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
18:04:29 <Philippa> the thing about STLC is it's /simple/. So you don't need kinds
18:04:31 <Philippa> stop showing off, guys
18:04:40 <revenantphx> I see, so "Either a b" boils down to
18:04:44 <revenantphx> Type -> Type -> Type
18:04:46 <copumpkin> :(
18:04:48 <revenantphx> or
18:04:51 <revenantphx> a -> b -> Either a b
18:04:53 <Philippa> :k Either a b
18:04:54 <lambdabot> Not in scope: type variable `a'
18:04:54 <lambdabot> Not in scope: type variable `b'
18:04:54 <Philippa> :k Either
18:04:55 <lambdabot> * -> * -> *
18:04:58 <revenantphx> aha!
18:04:58 <Philippa> :k Either Bool Int
18:04:59 <lambdabot> *
18:05:02 <revenantphx> so here -> is analogous to x?
18:05:09 <Philippa> -> is ->
18:05:11 <revenantphx> or isomorphic, I forget the term.
18:05:29 <copumpkin> revenantphx: (->) is magic in many different ways
18:05:42 <Philippa> it's the same -> as in types, only in kinds
18:05:48 <revenantphx> copumpkin: I noticed.
18:05:54 <Philippa> if I write data Flibble a = ...,
18:05:57 <Philippa> a is a parameter
18:06:05 <Philippa> just as if I write func a = ...
18:06:12 <revenantphx> But it seems to me (i've noted this before), that types in haskell are a lot like set relations.
18:06:27 <Philippa> in fact they're /more/ like logical relations
18:06:31 <Philippa> 'scalled the Curry-Howard isomorphism
18:06:38 <revenantphx> Yeah, seen that before.
18:06:49 <copumpkin> typeclasses are pretty close to relations between sets
18:06:51 <Philippa> anyway, I should go sleep
18:06:58 <revenantphx> I wasn't thinking about typeclasses :\
18:07:01 <revenantphx> I was thinking more like
18:07:08 <revenantphx> if you have MyType a b
18:07:27 <revenantphx> then all possible "values" of MyType are represented by the product of all possible values for a and b
18:07:38 <copumpkin> well, not necessary
18:07:39 <revenantphx> same as how a function is the product of the domain/codomain
18:07:50 <revenantphx> or rather, all of the sets of points.
18:07:51 <copumpkin> MyType might even ignore one or both of its parameters
18:08:01 <revenantphx> I'm assuming it uses both of them XD
18:08:16 <copumpkin> I'd just consider it a function on types, which is a special kind of relation
18:08:21 <copumpkin> so yeah
18:08:27 <revenantphx> interesting connections here.
18:08:27 <copumpkin> but typeclasses take that further
18:08:35 <revenantphx> typeclasses + math = oh god my head.
18:08:44 <revenantphx> I'm not sure I want to jump in that rabbit hole TT_TT
18:09:52 <revenantphx> I need to look at STLC now I think...
18:15:30 <revenantphx> egasp
18:15:42 <revenantphx> TaPL chapter 9: Simply Typed Lambda Calculus
18:15:43 <revenantphx> :O
18:16:07 <Pseudonym> Chapter 8: Even more simply typed lambda calculus
18:16:14 <revenantphx> Dependency chart says read 8,5 and 3 first tho
18:16:15 <Pseudonym> Chapter 7: Simplistically typed lambda calculus
18:16:18 <copumpkin> revenantphx: here, http://pumpkinpat.ch/moo.html :P
18:16:31 <copumpkin> revenantphx: that's a slightly less simply typed lambda calculus, but pretty close
18:16:55 <copumpkin> of course, you might have to understand agda syntax before reading that
18:17:00 <revenantphx> yeah >_<
18:17:14 <revenantphx> TaPL looks like one of those books you can read in a year, but never really fully *get*.
18:17:19 <revenantphx> It's intimidating.
18:17:28 <copumpkin> too much unicode?
18:17:33 <copumpkin> cause otherwise it looks pretty much like haskell
18:18:10 <owst> revenantphx: Agree, it's a little scary to begin with ;-).
18:18:32 <revenantphx> i saw gamma in tapl too.
18:18:45 <revenantphx>  has something to do w/ forall or something >_>?
18:18:45 <djahandarie> I'd say it's on the lower / more relevant end of the difficulty/what-the-hell spectrum.
18:18:48 <revenantphx> I don't remember. :(
18:19:15 <revenantphx> djahandarie: that's the scariest part.
18:19:22 <copumpkin>  _is_ forall
18:19:28 <revenantphx> derp.
18:19:30 <copumpkin> gamma is the typical symbol for a context of some sort
18:19:39 <revenantphx> I saw the word context in there, yeah
18:19:47 <copumpkin> revenantphx: the vast majority of that code is setting up a data type for my language
18:19:50 <djahandarie> copumpkin, was linking that Agda code suppose to make anything clear? :P
18:19:58 <copumpkin> revenantphx: there's very little actual "code" in there
18:20:05 <copumpkin> djahandarie: it makes it more concrete, I'd hope :P
18:20:10 <copumpkin> I can go through it line by line if you want
18:20:18 <Pseudonym> copumpkin: Sequent calculus _is_ code.
18:20:20 <copumpkin> it was really a test of my agda syntax highlighter
18:20:38 <copumpkin> Pseudonym: well, "code" in the usual sense of it doing something
18:20:42 <seydar> how's haskell's IO? like, is it known to be slow? is it super speedy?
18:20:43 <copumpkin> at runtime
18:20:54 <copumpkin> seydar: IO is usually bound by the OS and underlying devices
18:21:10 <copumpkin> so it's as speedy as your underlying system can get, if you don't do it in silly ways
18:21:14 <seydar> copumpkin: zomg a pumpkin
18:21:15 <copumpkin> almost as speedy, anyway
18:21:25 <Pseudonym> seydar: No, the dual of a pumpkin.
18:21:25 <Axman6> seydar: depends on how you're doing the IO, it can be extremely fast
18:21:37 <seydar> that's good to hear. just making sure it's not "weellllllllll, it's kinda super duper schlow"
18:21:42 <djahandarie> A pumpkin doesn't have any arrows to flip :(
18:21:45 <Axman6> using Strings for IO is a bad idea though
18:21:47 <Pseudonym> Every language's IO library is fast when you're doing what the designers anticipated.
18:21:53 <seydar> copumpkin: what are you doing with your life now?
18:21:58 <seydar> oh right you're in boston
18:22:02 <copumpkin> seydar: enjoying myself in boston, yep
18:22:03 <seydar> what's the company again?
18:22:10 <copumpkin> clarifi/capital iq
18:22:26 <revenantphx> copumpkin: I wouldn't mind that actually :P
18:22:38 <revenantphx> query if it's more convenient for you or if the channel picks up though
18:22:42 <revenantphx> ah, one moment
18:23:00 <djahandarie> Or #agda :)
18:23:14 <copumpkin> #agda seems more on-topic for this particular conversation
18:23:23 <copumpkin> and I never turn down a change to bring more people in there :P
18:23:29 <copumpkin> *chance
18:24:47 <revenantphx> >_>... fine
18:28:00 <elliott> hSeek handle RelativeSeek n where n is negative should work should it not?
18:28:55 <seydar> copumpkin: what languages do you use at work?
18:29:38 <copumpkin> seydar: mostly scala, occasionally a bit of java, and we often think and/or prototype in haskell
18:30:17 <seydar> hey, that's pretty cool
18:30:24 <seydar> y'all need an intern this summer?
18:30:39 <seydar> it's only fair since we were supposed to get lunch last year but never did
18:32:17 <elliott> prototyping in haskell then converting it to scala, I have a new definition of perversity to remember
18:34:31 <roconnor> elliott: why convert to scala?
18:34:39 <elliott> <copumpkin> seydar: mostly scala, occasionally a bit of java, and we often think and/or prototype in haskell
18:35:24 <seydar> elliott: yeah, i know. it still sounds cool
18:35:44 <elliott> Ignore me, my job is just to troll whenever copumpkin's around because he can't bring himself to ban me. now watch as he does
18:36:54 <copumpkin> lol
19:06:30 * Kaidelong really thinks that a breaking change to the standard haskell libraries might be in order. Along with an end to the prelude.
19:07:00 <Kaidelong> Or the implicit prelude anyway
19:07:19 <Axman6> really? :\
19:07:50 <Kaidelong> Axman6: silly things that can only be attributed to legacy like Monad not requiring Applicative
19:08:33 <Kaidelong> and "import Prelude" is not really that hard
19:09:06 * roconnor more or less agrees
19:10:40 <Axman6> i do think there are some obvious changes that should be made anyway,. like removing fail from Monad (though that breaks all the work on monad comprehensions)
19:11:05 <Axman6> and class Applicative m => Monad m ...
19:11:44 <Kaidelong> the other thing about that is that then Monad would only have to require that mu is defined
19:11:48 <Kaidelong> so, join
19:12:57 <Kaidelong> (well it already requires the other things)
19:15:26 <Kaidelong> also there is too much emphasis on lists as a data structure. They're a lovely control structure though.
19:16:05 <Kaidelong> but people probably shouldn't use things like !! or //
19:17:10 <ivanm> especially since // is wrong
19:17:17 <ivanm> > [1,2,1] // [1]
19:17:18 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
19:17:18 <lambdabot>         against inferred t...
19:17:26 <ivanm> or \\, whatever it is...
19:17:29 <ivanm> > [1,2,1] \\ [1]
19:17:30 <lambdabot>   [2,1]
19:17:59 <Kaidelong> \\
19:18:07 <Kaidelong> I always get those confused
19:18:37 <ivanm> yeah
19:20:12 <Kaidelong> people's thought process should be that lists are a great way to construct or traverse over other data structures like sets or vectors
19:20:56 <Kaidelong> I guess that is one thing a word like "iterator" makes clear, actually
19:21:45 <Kaidelong> (and some people would say that haskell lists are not really lists anyway)
19:24:16 <ivanm> Kaidelong: why aren't they?
19:25:22 <Kaidelong> ivanm: structural recursion on haskell lists is not guaranteed to terminate
19:25:30 <ivanm> ... so?
19:26:17 <Kaidelong> well that's the reason
19:26:19 <roconnor> Free theorems say that (forall a. F a -> G a) is always a natural transformation if F and G are functors, right?
19:26:20 <pikhq> Kaidelong: The same is true of lists in many other languages.
19:26:29 <pikhq> Kaidelong: Circular linked lists exist, y'know.
19:27:01 <ivanm> pikhq: exactly
19:27:15 * Kaidelong wasn't saying that he feels that way
19:27:34 <ivanm> oh, right
19:27:40 <ivanm> you were just talking about crazy people... :p
19:27:56 <pikhq> I'm pretty sure that if you can construct a linked list type in a language you can manage to make an instance of one that's circularly linked, in general.
19:28:17 <Kaidelong> pikhq: I am not sure. You'd have to admit some kind of recursive definition
19:28:48 <ivanm> hmmm.....
19:29:06 <ivanm> I do recall "learning" about linked lists in my data structures course by implementing them with Java arrays :s
19:29:14 <pikhq> Hmm. I suppose hypothetically you *could* have a sub-Turing language with linked lists.
19:29:21 <mjrosenb> pikhq: you cannot have a circular linked list in sml.
19:29:30 <ivanm> and how would you make a scheme list circular? tying the knot or something?
19:30:05 <pikhq> ivanm: Modify cons cells? :P
19:30:23 <ivanm> pikhq: hmmm...
19:30:40 * Kaidelong seems to recall a paper that distinguished "lists" that are always finite from "co-lists"
19:31:16 <djahandarie> data vs codata perhaps
19:31:35 <Kaidelong> they used a different notation for co-lists in their language proposal
19:31:45 <Kaidelong> something like <> as co-cons instead of :
19:35:25 <djahandarie> pikhq, Agda isn't turing complete and it has tons of goodies
19:36:05 <pikhq> djahandarie: Ah, yeah, there are actually useful sub-TC languages, aren't there?
19:36:12 <djahandarie> Yes.
19:36:20 <djahandarie> It is only sub-turing because all functions are total.
19:36:43 <Kaidelong> pikhq: turing completeness is not a desirable thing really
19:36:48 <djahandarie> You need to be able to have a program that goes on forever for it to be TC.
19:36:53 <djahandarie> It is if you want a tarpit!
19:37:06 * djahandarie plays in the tarpit
19:37:08 <pikhq> Kaidelong: It actually often is.
19:37:20 <pikhq> Kaidelong: It's just not *necessarily* what you want.
19:37:21 <Kaidelong> pikhq: example?
19:37:49 <Kaidelong> it is true that you can't make a language that admits all, and only, the useful turing machines
19:38:07 <Kaidelong> but if you had one it'd be absolutely better than anything turing complete
19:38:23 <pikhq> Hmm. Okay, actually, technically no, you don't want TC. You want it to have the subset of TC that you care about.
19:38:35 <pikhq> And everything else is kinda irrelevant.
19:39:06 <pikhq> And it's a good thing, too, as I'm afraid I don't have an infinite tape handy.
19:40:34 <effigies> If anybody's got any experience with hmatrix, I'm running into issues where the interpreter doesn't agree with the docs about what instances are defined.
19:40:44 <c_wraith> dcoutts: ping
19:43:39 <ivanm> effigies: could be a matter of importing another module
19:44:22 <c_wraith> effigies: yeah, ivanm is right.  the list of instances haddock produces come from all the modules in the package.  The instance is probably declared in another module
19:44:55 <effigies> Ought I to import the whole lot of hmatrix modules to see if that fixes it?
19:45:11 <c_wraith> or grep the code for instance :)
19:45:27 <ivanm> effigies: which class and which data type?
19:45:33 <ivanm> are you importing the modules that define both?
19:45:43 <effigies> Num (Matrix a)
19:45:50 <ivanm> (assuming no orphan instances)
19:46:33 <effigies> I'm importing Foreign.Storable, Numeric.Container, Data.Packed.Vector, and Data.Packed.Matrix.
19:47:59 <effigies> Okay, actually, importing everything did get the num instance.
19:48:22 <c_wraith> woo, orphan instances! :)
19:48:39 <ivanm> effigies: Numeric.LinearAlgebra
19:48:53 <ivanm> that's where the instances come from
19:48:59 <effigies> Ha. Now, I need to find the instance for Container Vector t.
19:49:20 <ivanm> Numeric.Container
19:49:25 <ivanm> (would be my guess)
19:49:45 <ivanm> c_wraith: yeah, in cases like these where you have to hunt this stuff down I agree that orphan instances are bad
19:49:45 <gwern> Data.Packed.Vector eh. from storablevector?
19:50:01 <ivanm> gwern: no, from hmatrix
19:50:06 <effigies> ivanm: Yeah, I've been importing that one.
19:50:10 <gwern> oh
19:50:31 <gwern> ivanm: offhand, Data.Packed.Vector sounds generic. what's it doing in hmatrix?
19:50:36 <seydar> yo homefries
19:50:45 <ivanm> gwern: http://hackage.haskell.org/packages/archive/hmatrix/0.11.0.0/doc/html/Data-Packed-Vector.html
19:50:51 <ivanm> I think you can use normal vector for that
19:50:54 <seydar> how easy is it to uninstall ghc 7.0.1 when it has been installed from the binary package for mac os x?
19:51:52 <ivanm> seydar: *shrug* I have no idea how to uninstall stuff on OSX
19:53:21 <ikeg> seydar: `locate ghc-7.0.1` tells you a large list of files
19:53:39 <ikeg> however, it is not safe to remove manually, though
19:57:24 <seydar> ikeg: is there an uninstaller?
19:58:01 <ivanm> seydar: you're the one who has it installed... :p
19:58:24 <seydar> ivanm: no i haven't yet
19:58:33 <ivanm> oh...
19:58:45 <seydar> wanted to make sure it was safe to play with my kids
19:58:51 <seydar> and by kids i mean other installations of ghc
19:59:18 <ivanm> you might need to use some wrapper scripts when dealing with multiple ghcs
20:00:02 <ikeg> Haskell Platform for MacOSX should have its uninstaller
20:00:17 <ivanm> ikeg: yeah, but he's not talking about the platform
20:00:31 <ikeg> well, ah
20:03:28 <ikeg> I don't recommend my way, but, I often use GNU stow to install ghc on my Mac laptop
20:03:42 <dankna> I use stow for just about everything
20:03:54 <dankna> not ghc though, since it builds such a nice .pkg
20:04:04 <dankna> and not cabal stuff either, obviously
20:05:07 <dankna> anyway, the current binary package is NOT the .pkg though
20:05:18 <dankna> I built the .pkg myself from HEAD, which makes it 7.1.something
20:05:35 <dankna> and I can send that file to anyone who wants it but it's, you know, unstable and has some regressions in it that have come to light on the bugtracker
20:06:07 <dankna> the .pkg has an uninstaller
20:06:23 <dankna> what the two versions that are up right now give you, though, is a .tar.gz
20:06:31 <dankna> you unpack it and invoke "make install" from inside it
20:06:48 <dankna> this will install into /usr/local/ by default.  I don't remember whether you can change that.
20:07:00 <dankna> if you can, the command to do it is make install prefix=/usr/local/stow/ghc-7.1
20:07:14 <dankna> and the command to test before you do that is make -n install prefix=/usr/local/stow/ghc-7.1
20:07:33 <dankna> (that path, obviously, is if you want to use stow; if you want it somewhere else, do that instead)
20:08:18 <dankna> if you do want to use stow, what you then do is cd to /usr/local/stow and invoke stow with the single parameter ghc-7.1 (the name of the subdirectory you installed into)
20:08:29 <seydar> managing ghc installations is a bitch and a half
20:08:33 <dankna> it will then create symlinks from /usr/local/bin/ghc -> /usr/local/bin/stow/ghc-7.1/bin/ghc and so on
20:08:36 <dankna> it is, yes
20:08:42 <seydar> a haskell version of rvm would be sweet
20:08:45 <dankna> the .pkg makes this pretty seamless which is why I really prefer it
20:08:48 <seydar> http://rvm.beginrescueend.com/
20:08:52 <dankna> looking
20:09:15 <dankna> mm
20:09:39 <dankna> fine, but you get to be the one who convinces dcoutts to merge the patch which you get to write to cabal-install :)
20:09:46 <seydar> oh man
20:09:49 <dankna> haha
20:09:50 <seydar> that was fucking painless
20:10:00 * allbery_b renamed all of the non-versioned programs in the ghc depot collection so he could use a symlink mangler or specify which to use by name or path
20:10:19 <dankna> just to finish my directions, when ghc-7.2 comes out you cd to /usr/local/stow and do
20:10:25 <dankna> stow -D ghc-7.1 ; stow ghc-7.2
20:10:39 <seydar> Mr. Wright has a beautiful binary all ready for mac os x
20:10:41 <dankna> if you want both concurrently you can arrange that too, you just have to look at what's in ghc-7.1 and maybe rename it a bit
20:10:46 <allbery_b> (that would be the depot that was the inspiration for stow)
20:10:53 <dankna> allbery_b, ah cool
20:10:54 <seydar> ./configure --prefix=$PREFIX && make install
20:10:54 <seydar> BOOM
20:11:14 <dankna> yes, we know you can install that way :D
20:11:23 <dankna> it's the uninstall that's at issue
20:11:26 <allbery_b> oddly enough, CMU uses depot a lot :)
20:11:42 <dankna> I approve of the general approach
20:11:48 <allbery_b> stow should be able to remove it fairly easily
20:12:00 <dankna> yeah, stow is great for managing things that don't manage themselves
20:12:15 <dankna> really though the best is to use the .framework version, if you're on a Mac.
20:12:27 <allbery_b> and some things that do, but do so poorly
20:12:31 <dankna> indeed
20:12:47 <dankna> because that way they just all coexist painlessly and the only thing you have to worry about is which version the symlink that doens't have a version number after it points to
20:12:56 <dankna> which you'd have to pay attention to no matter what you did
20:13:24 <dankna> for anything installed by cabal, multiple versions already exist painlessly, although you have to customize where the documentation goes if you want multiple versions simultaneously
20:13:31 <dankna> (specifically you have to add $compiler to the path for it)
20:13:39 * allbery_b finds himself ondering yet again if depot^Wstow and modules would play together nicely for one-offs
20:13:51 <dankna> how do you mean?
20:13:55 <allbery_b> and even wondering
20:13:56 <dankna> sounds like an interesting idea
20:14:04 <allbery_b> http://modules.sourceforge.net
20:14:44 <allbery_b> in theory, you should be able to (auto?)create modules for non-installed stow collections and then run them one-off by adding the appropriat'e module to your shell
20:15:04 <dankna> I approve of that
20:15:13 <dankna> although personally I just maintain my .bashrc by hand
20:15:21 <allbery_b> it *ought* to work, except various platforms make it harder than it should be (notably AIX and *sigh* OSX)
20:15:28 <dankna> yes
20:15:57 <allbery_b> both of which hardcode full paths to shared objects, and while you can override them it risks breaking everything *else*)
20:16:57 <dankna> that's why what seydar said was subtly wrong above
20:17:08 <seydar> dankna: wait which part
20:17:27 <dankna> you don't do ./configure --prefix=/usr/local/stow/ghc-OVER-NINE-THOUSAND, because that will hardcode the path in the binaries
20:17:34 <dankna> you do ./configure --prefix=/usr/local
20:17:36 <dankna> then
20:17:41 <seydar> i'm more comfortable going around and fucking shit up if it's in ~/local
20:17:45 <dankna> make install prefix=/usr/local/stow/ghc-OVER-NINE-THOUSAND
20:17:56 <dankna> then you run stow as I explained above
20:18:11 <dankna> now ghc can find its shared objects, because the symlinks exist in /usr/local/lib/whatever
20:18:23 * allbery_b knows that all too well since *everything* had to be done that way at CMU
20:18:26 <dankna> but you can still remove them safely, because they're actually stored in /usr/local/stow/ghc-OVER-NINE-THOUSAND
20:18:53 <dankna> and you don't run the risk of it creating configuration files in /usr/local/stow/ghc-OVER-NINE-THOUSAND and then not being able to find them
20:18:57 <dankna> because the binaries don't know that path exists
20:19:01 <int80_h> hey I completed a major milestone in my project, thanks in part to the people here.
20:19:03 <dankna> the hardcoded path is /usr/local
20:19:08 <dankna> int80_h: great :) what was it?
20:19:30 <allbery_b> dankna: except when they do because the package is stupid and bakes in paths during the install phase
20:19:42 <int80_h> danka: I had to do some screenscraping and manual cookie capturing
20:19:53 <dankna> allbery_b: yeah, :( that's why you do make -n first
20:19:55 <allbery_b> luckily most stuff got broken of that by Linux package managers.  emphasis on "most"
20:20:19 <dankna> since makefiles are always autogenerated by fans of autoconf, which is a tool that can go to hell if it's not already there
20:20:24 <dankna> so reading the makefile directly is impossible
20:20:30 <dankna> but at least you can read what commands it tries to execute
20:20:35 <int80_h> I'll be posting to haskell-cafe and beginners the results in the hopes I get some feedback on how to make it better. I have nearly zero error handling right now and it's clearly written by a person who hasn't let go of the imperitive model in his head.
20:21:01 <dankna> also, Time Machine backs up my /usr/local :D
20:21:15 <dankna> so I can always uninstall THAT way if I do accidentally mess something up and get crap spewed all over it
20:21:40 <allbery_b> you must be lucky if everything you deal with is autoconfiscated.  I've had to deal with Imake, and random build systems.  And Perl's/Python's/Ruby's module build/install insanity
20:21:42 <dankna> int80_h gotcha.  well that's cool.
20:21:54 <dankna> yeah, I've had to deal with that crap too
20:22:04 <dankna> the worst I've ever seen is... oh man I'm blanking on the name... oh right... Scons
20:22:24 <joe6> is there a different irc for haskell-llvm?
20:22:30 <dankna> the build system was totally opaque and I seem to remember, don't quote me on this, that the build system was built BY ITSELF
20:22:45 <dankna> joe6: don't believe so
20:22:45 <int80_h> ouch that hurt
20:22:53 <joe6> dankna: ok, thanks
20:23:09 <dankna> int80_h: oh!  the "that crap" was directed towards allbery_b
20:23:23 <int80_h> heh no I was referring to the build system that built itself
20:23:28 <int80_h> ouchie
20:23:31 <dankna> Perl is actually okay, CPAN is very impressive and hackage could learn some lessons from it *cough*mirroring*cough*
20:23:36 <dankna> yeah indeedy
20:24:04 <dankna> Java's ant is also a pain, although it gets points for being declarative instead of imperative in the way it's configured
20:24:06 <int80_h> I'm so excited. this is my first programming job and they let me use haskell :)
20:24:16 <dankna> ant wants crap spewed all over your system directories
20:24:17 <dankna> hehe awesome :)
20:24:20 <int80_h> it's checked in and being tested tomorow
20:24:23 <dankna> nodnod
20:24:32 <dankna> Python's system I know nothing about
20:24:39 <dankna> Ruby Gems.... unless it's changed, is a piece of crap
20:24:44 <allbery_b> CPAN is mostly impressive.  Some commonly used Perl modules, not so much
20:24:48 <int80_h> of course, I'm still learning haskell but in the few months it took me to do this I know more than I did.
20:24:52 <dankna> I vividly remember a dialogue that happened between Ruby Gems and the Debian people
20:25:10 <dankna> the Debian people were saying "there has to be a hook in the build system so we can inform it of packages we have installed"
20:25:12 <int80_h> oh did Gems get buthurt? I remember something like that on the mailing list
20:25:13 <allbery_b> Python eggs and Ruby gems require digging to find all the knobs but I got them to play nicely with depot eventually
20:25:16 <dankna> the Gems guy.... yes
20:25:21 <dankna> got very angry
20:25:27 <int80_h> I remember that!
20:25:29 <int80_h> hah
20:25:32 <dankna> "Packaging is not Debian's responsibility, it is Ruby's responsibility"
20:25:36 <allbery_b> none of the Ruby developers understand the concept of backward compatibility.  Or release engineering.
20:25:40 <int80_h> made me think ruby was no good nd I should move on 
20:25:43 <dankna> basically saying the Debian project shouldn't even EXIST
20:25:47 <seydar> dankna: sorry, just jumping back in, why are rubygems crap?
20:25:47 <dankna> yeah
20:25:56 <dankna> seydar: well, read my last couple messages and my next couple :)
20:25:58 <int80_h> lispy!
20:26:04 <allbery_b> Or system packaging, eyh.
20:26:11 <dankna> he downright refused to add the hook
20:26:19 <int80_h> lispy helped me out alotlispy: I just finished a major milestone for my work project. Haskell!
20:26:22 <dankna> and argued strenuously that Debian has no business packaging ANYTHING for Ruby
20:26:22 <allbery_b> Anyone who has to maintain more than an individual system would spit in that Ruby freak's eye
20:26:32 <dankna> that they're getting in his way and being pests
20:26:41 <seydar> do you know who the gems guy is?
20:26:44 <dankna> they even offered to do the work for him
20:26:48 <int80_h> lispy, I'll be posting my work to the mailing lists in the hopes I get feedback helping me with style
20:26:57 <dankna> I don't remember, all I remember is the horrible negative impression it made on me, but I'm sure it's googleable
20:27:05 <dankna> this conversation took place, I think, on a Debian mailing list
20:27:10 <dankna> if it wasn't there it was on the Gems ML
20:27:23 <int80_h> yeah it made it to GEMS ML
20:27:24 <allbery_b> but in any case it's just more evidence that the Ruby devs don't have a clue about system configuration management
20:27:28 <dankna> exactly
20:27:32 <allbery_b> and *like* it that way
20:27:32 <int80_h> and some blowback on the main mailing list
20:27:34 <dankna> it really speaks for itself
20:27:48 <seydar> i happen to really like rubygems
20:27:50 <dankna> I don't even need to explain to this audience why those are bad things
20:27:56 <seydar> but yeah, specific versioning is a bit of a hitch
20:28:00 <allbery_b> http://lwn.net/Articles/423732/
20:28:14 <int80_h> all you have to do is be in a work environment to know why it's bad.
20:28:19 <allbery_b> Ruby is a bunch of very nice ideas hindered by being implemented by idiots
20:28:20 <seydar> and the debian bit... I don't know much about it, but I know that this conflict happened
20:28:21 <c_wraith> @tell dcoutts it'd be nice if cabal configure, when it changes the compile options, would cause a recompile of the whole project.
20:28:21 <lambdabot> Consider it noted.
20:28:41 <seydar> @tell copumpkin awesomesauce
20:28:41 <lambdabot> Consider it noted.
20:28:45 <dankna> the other reason I don't like Ruby is that performance is awful
20:28:49 <allbery_b> that LWN article is an overview of the Debian spat and should have references
20:28:51 <dankna> it's seriously ten times slower than Perl
20:28:52 <dankna> ten times
20:29:01 <dankna> look at the shootout if you don't believe me :)
20:29:19 <dankna> ah good, I'll have to remember the LWN article exists for next time this comes up
20:29:38 <dankna> it's one area where Haskell is great
20:29:47 <dankna> really strikes the right balance between new features and standardization
20:29:53 <dankna> I love the idea of the LANGUAGE flags in ghc
20:29:54 <seydar> dankna: yeah, ruby is slow as balls, but pretty unnoticeable for me and what I do
20:30:12 <dankna> yeah, I understand that it has areas it's suitable for, I would never argue for its extermination
20:30:15 <seydar> my friend and I rewrote mercurial in ruby and got it to be very close, speedwise
20:30:25 <dankna> if nothing else they have Rails, which until my own FruitTart comes out is a very nice interface
20:30:31 <int80_h> exterminate!
20:30:41 <dankna> (CakePHP imitates it but leaves out some crucial features, like the ability to have multiple-column primary keys)
20:30:49 <dankna> (because the PHP people don't understand databases)
20:30:53 <Kaidelong> Haskell is awful. That said, I haven't seen anything better yet.
20:30:58 <c_wraith> what?  Rails is a *horrible* interface, the instant you want to do something that they don't think you should want to do.
20:31:09 <allbery_b> my *big* beef with ruby, though?  I risked writing *one* script in Ruby for work.  Someone then asked for a Ruby upgrade for their Rails project --- and it promptly broke on a couple hundred systems
20:31:09 <dankna> (not saying the Ruby people do; they viewed that as an exotic feature when it's a crucial feature.  but at least they implemented it.)
20:31:34 <dankna> Kaidelong: ah, you're taking the long view :D
20:31:57 <allbery_b> sounds like a sysadmin.  "All hardware sucks, all software sucks"
20:32:01 <dankna> Kaidelong: "Everything we use is awful, why can't we all just use [name censored by the time-travel police]?  So what if it doesn't exist yet?"
20:32:07 <FunctorSalad> hmm, I'm trying to make a "find all references" thing working with the GHC API, at the typechecked source level... it seems that the name I get with 'parseName' isn't the same as that actually occuring in the AST at most places
20:32:11 <seydar> c_wraith: i disagree, but to each his own
20:32:28 <FunctorSalad> (apparently 'parseName' gives me a qualified name)
20:32:40 <Kaidelong> dankna: I'm more talking about Haskell the libraries than Haskell the language here, so that's probably fixable
20:32:40 <dankna> c_wraith, I'd be very interested, as the author of a not-yet-released competing framework (in Haskell), in your observations about Rails
20:32:48 <dankna> Kaidelong, ah good :)
20:32:48 <c_wraith> seydar: rails is great for doing exactly what they think you should do.  If you want to do something new and fundamentally different, it'll get in your way every step.
20:33:05 <Kaidelong> dankna: but only if you disregard backward compatibility
20:33:11 <seydar> allbery_b: rails is pretty big. ruby versions tend to change a bunch. i've got to say, upgrading ruby for their rails project was a rookie mistake
20:33:16 <seydar> allbery_b: especially without testing it before
20:33:19 <dankna> Kaidelong: that's why the LANGUAGE pragma is such genius
20:33:22 <int80_h> dankna: have you looked at yesod?
20:33:25 <dankna> we can have our standards and eat them too
20:33:39 <c_wraith> dankna: I've only written one subsystem of snap.  I'm not the primary author in any way.  I just chose to use (and improve) snap because it had the least "this is how your application needs to work" feel.  It was the most open-ended.
20:33:39 <dankna> int80_h: I have not, no, I need to - they are using my direct-fastcgi package (at least in some configuration)
20:33:44 <allbery_b> seydar: when a prof asks for it we usually don;t get to tell them "rookie mistake"
20:33:54 <dankna> I will mention right at the outset that the biggest difference between my own FruitTart and Rails is that I don't have an object-relational mapping
20:34:02 <dankna> I focus on letting you write whatever SQL you want and getting it executed fast
20:34:21 <dankna> I thought about it long and hard and decided I don't believe in ORMs, categorically
20:34:21 <seydar> c_wraith: true, though we're both being very vague here. rails was made by DHH for what he needed. it is not a panacea, nor should it be
20:34:35 <dankna> but I kept the controller-action model of dispatching requests
20:34:47 <seydar> allbery_b: doesn't mean upgrading the interpreter for a major piece of code without testing beforehand isn't a rookie mistake
20:34:53 <seydar> it's something you do once, and then never again
20:34:55 <dankna> I agree that being open-ended is a good thing for these frameworks
20:35:14 <stepkut> c_wraith: why do you feel that snap is more open ended than happstack ?
20:35:25 <dankna> I can't even install happstack :(
20:35:27 <seydar> alright
20:35:29 <dankna> it breaks on my ghc :(
20:35:30 <seydar> night kids
20:35:31 <seydar> be safe
20:35:35 <seydar> make good choices
20:35:36 <c_wraith> stepkut: At the time, happstack just had overwhelming complexity.  Snap was refreshingly simple in comparison
20:35:41 <seydar> and call in every three hours
20:35:45 <dankna> I don't have the energy to maintain more than one build of ghc at a time, so I track HEAD every three months or so
20:36:00 <dankna> so I shouldn't expect a big system like happstack to work, obviously, because HEAD is not that stable
20:36:00 <c_wraith> stepkut: I understand you've made great strides in simplifying happstack's interface, though.
20:36:04 <dankna> but anyway, I can't install it
20:37:01 <dankna> c_wraith: so, what can you tell me (or show me to read) about Snap's architecture?
20:37:33 <stepkut> c_wraith: yes and no... I think happstack was misleading complex.. things like WebT were exposed in the 'external' API even though WebT is really an 'internal' item. So now that division is clearer.. the Internal things are clearly in Happstack.Server.Internal.* so you can easily recognize that you should ignore them :)
20:38:03 <allbery_b> seydar: very few of my former coworkers were quite as paranoid about testing stuff as I was, but even so I really don't think stuff should break the way it did; it was a backward-incompatible change of the sort Ruby makes all the time when anyone else wouldn't
20:38:07 <jmcarthur> i've been toying with the Ur language for web dev. it's neat
20:38:45 <dankna> what IS the Ur language?
20:38:49 <stepkut> c_wraith: at the same time, snap started too simple (IMO) and is increasingly becoming more complex. For example, it used to only have the Snap monad, but I think it now has a class SnapMonad class.. it used to only have getParam, but now there is work to distinguish between QUERY_STRING params vs form data values..
20:38:53 <jmcarthur> has confusing (due to experience, no doubt) type error messages though
20:38:56 <c_wraith> dankna:  Not sure if I'm the one to ask there.  I didn't design it, and I've only learned as much about it as necessary to implement the things I want...  And almost all of what I've done has been on top of the existing framework.
20:38:57 <jmcarthur> dankna: it
20:38:58 <jmcarthur> oops
20:39:08 <mjrosenb> dankna: it is a language for writing web things iirc
20:39:13 <jmcarthur> dankna: it's a language for making domain specific languages
20:39:15 <Gracenotes> ur language sounds.. like the name would be significant
20:39:19 <dankna> c_wraith, well, okay.  that's fair.  I guess you've told me what attracted you to it already.
20:39:20 <jmcarthur> mjrosenb: that would be Ur/Web
20:39:21 <mjrosenb> dankna: /join sml.  the main dev lurks in there
20:39:30 <mjrosenb> jmcarthur: right, my bad.
20:39:35 <dankna> okay
20:39:40 <jmcarthur> there's a #ur channel, too
20:39:52 <allbery_b> (and that the coworker didn't warn me ahead of time was also not so good)
20:40:18 <jmcarthur> Gracenotes: it's apparently named after the supposed first natural language
20:40:19 <dankna> jmcarthur, confusing type error messages?  unthinkable! :)
20:40:22 <dankna> well
20:40:28 <dankna> Ur was the first CITY
20:40:30 <jmcarthur> dankna: much more confusing that ghc's
20:40:31 <Gracenotes> jmcarthur: yeah, I'm wondering how that applies to programming
20:40:36 <allbery_b> Gracenotes: seems significant to me, but you may have to think about it.  (language for making DSLs... so it's an ur-DSL)
20:40:42 <dankna> in Mesopotamia
20:40:44 <c_wraith> stepkut: I agree with that, too.  Snap has definitely become more complicated...  It really helps my understanding that I've been around to see it develop that complexity.  I bet Happstack would make a lot more sense to me now. :)
20:40:49 <stepkut> c_wraith: or, for example, ServerPartT was originally deemed too complex with the suggestion that there should only be ServerPart. But then there was work to to add a SnapT to snap (though it has not actually happened yet)
20:40:55 <jmcarthur> dankna: i just read it off the site
20:40:57 <dankna> so the word has become a generic term for the first anything
20:41:00 * jmcarthur shrugs
20:41:05 <Gracenotes> ah, DSLs? ... so I hope it'd have a good stdlib sset
20:41:06 <dankna> or the most archetypical anything
20:41:15 <allbery_b> yeh
20:41:24 <jmcarthur> Gracenotes: Ur/Web is basically its main thing right now
20:41:27 <FunctorSalad> . o O ( ur-behemoths )
20:41:35 <c_wraith> ur-quan
20:41:45 <dankna> FunctorSalad, yes exactly
20:41:52 <dankna> also
20:41:59 <dankna> "I'm in Ur, killing Ur doods."
20:42:06 <jmcarthur> it's cool though. it has tons of type safety, functional reactive javascript, simple ajax rpc, etc.
20:42:17 <dankna> that's neat
20:42:24 <allbery_b> (Ur-k!)
20:42:25 <dankna> I want ghc's javascript backend to work again :(
20:42:32 <dankna> then I would never need to write Javascript by hand!
20:42:33 <djahandarie> Functional reactive javascript? O.o
20:42:34 <allbery_b> ghc's?
20:42:39 <stepkut> c_wraith: i hope so :) The biggest 'easy of understanding' improvements in happstack for the next release are (1) spliting Happstack.Server.SimpleHTTP into smaller pieces with better organazation and better distinction between internal vs external stuff (2) a much better introduction to the framework (aka, the Crash Course)
20:42:41 <dankna> it was an experimental project
20:42:45 <allbery_b> I thought it was yhc that had the javascript backend
20:42:49 <dankna> ghc had one too
20:42:53 <dankna> the author implemented stg in js
20:42:54 <djahandarie> allbery_b, google ghc-js
20:42:57 <djahandarie> I think that was the name
20:43:01 <allbery_b> ah
20:43:09 <dankna> I actually invested some effort already into resurrecting it (it broke)
20:43:29 <dankna> what I determined was that it would be too much trouble to do that without first making another big change which I would have to advocate to the ghc team
20:43:32 <allbery_b> you'll probably have to wait until they have the new backend stuff done; it's still in flux
20:43:46 <dankna> which is making the compiler capable of building to multiple backends and architectures from a single build of the compiler itself
20:43:51 <allbery_b> but if you do have such a big change, *now* is when ti propose it before the backend interface gets frozen in stone
20:43:51 <dankna> rather than using #ifdefs
20:44:04 <dankna> well
20:44:09 <dankna> I'm not even sure who to talk to, to be honest
20:44:13 <allbery_b> ...that said, I thought *that* was part of what the new backend stuff did
20:44:22 <dankna> I'm more familiar with the ghc codebase (I'm decently oriented in it) than I am with the developers :)
20:44:28 <dankna> also they're in the process of switching to git :(
20:44:30 <dankna> from darcs :(
20:44:35 <dankna> this is breaking news as of a couple weeks ago
20:44:36 <allbery_b> #ghc or glasgow-haskell-users@haskell.org
20:44:44 <dankna> yeah, I'm on that list and sometimes in that channel
20:44:48 <dankna> but the channel is always dead
20:44:52 <allbery_b> not so breaking, they first floated it, hm, close to a year ago?
20:44:57 <dankna> I obviously need to start paying more attention on the list
20:45:05 <dankna> yes, I know, but it still surprised me at least that they went through with it
20:45:24 <allbery_b> in my experience the channel is fairly active when the devs are awake and working on something, but the list is rather quiet
20:45:35 <dankna> I hate git.  Nobody has ever been able to explain to me what it means to "stage" a commit, why it would be desirable, or how to do it.
20:45:52 <dankna> and my workflow involves commuting patches fairly often
20:46:02 <dankna> oh?  well, I guess I need to be there more during business hours then
20:46:07 <dankna> they must just not be night owls
20:46:10 <jmcarthur> djahandarie: yeah, Ur has a javascript DSL that models the entire HTML page as a function that can vary based on signals that are changed by events
20:46:11 <dankna> how dare they have Haskell day jobs :)
20:46:35 <dankna> and also the one time I tried to use git for anything besides obtaining somebody else's code initially, it deleted a file on me
20:46:38 <dankna> and I lost an hour's work
20:46:48 <dankna> it was probably my mistake
20:46:55 <dankna> but I love how darcs is super-super-clear about the consequences of everything
20:47:12 <dankna> I even love the prompt where you have to type "I understand the consequences of my action" with correct spelling and punctuation
20:47:14 <banisterfiend> dankna: that's ok you think that
20:47:20 <aavogt> my understanding is that you have to understand this super simple model that git apparently has
20:47:24 <dankna> banisterfiend, pardon?
20:47:32 <dankna> aavogt: yeah exactly!  hahaha
20:47:40 * aavogt doesn't either
20:47:41 <stepkut> dankna: git makes me sad... linus pooped out a giant turd, and his minions declared it to be to be awesome and then worked desperately to justify their claims
20:48:04 <dankna> stepkut: I think I'm not competent to judge git
20:48:07 <allbery_b> pretty much.  I like darcs and mercurial (oddly, they seem to be the most similar)
20:48:19 <c_wraith> well.  git's *fast*.  It did succeed in that much
20:48:22 <Zao> Fossil looks rather nice, but I haven't had the opportunity to use it in a project yet.
20:48:24 <dankna> I will note that the Linux kernel is a codebase an order of magnitude larger than a compiler is.
20:48:32 <dankna> and they maintain, what, four active forks of it.
20:48:32 <Zao> Has integrated issue tracking and all, which is rather cool.
20:48:36 <c_wraith> Most of its design decisions were about making it fast, rather than easy to use/understand
20:48:45 <Zao> Single-binary too, unlike the 20k files that a Git deployment has.
20:49:01 <dankna> a good issue-tracker database will integrate with any VCS though
20:49:01 <stepkut> dankna: sure.. but it was bigger than a compiler when they used CVS... so that is not saying much ;)
20:49:09 <dankna> by reading the commit messages and looking for tags in them
20:49:28 <dankna> so I don't think that's a killer feature on Fossil's part
20:49:37 <dankna> stepkut: true :)
20:49:42 * allbery_b does have one rather big issue with darcs, in that it seems to go out of its way to ensure that one can *never* get a darcs1-format or hashed archive to talk to a darcs2 archive
20:49:44 <Zao> dankna: It's still monolithic though, and requires connectivity. The one in Fossil is properly distributed, just like the reposes.
20:49:57 <allbery_b> wait, when did linux use CVS?
20:49:58 <dankna> allbery_b: well.... they had some bad bugs related to trying to do that
20:50:02 <Zao> Which while is a cool concept, might not work out horribly cleanly.
20:50:11 <Zao> allbery_b: Before BitKeeper, maybe?
20:50:21 <stepkut> dankna: the other important thing to note is that all revision control systems suck.. some just suck less for your particular needs
20:50:26 <dankna> Zao: oh?  that's cool!  I briefly tried to do that for my homegrown issue tracker
20:50:29 <dankna> stepkut: that's very true
20:50:33 <allbery_b> linus worked by the seat of his pants until the inevitable happened, then there was bitkeeper, then Larry McVoy pissed off all the free software folks and Linus spat out git
20:50:44 <dankna> what was the inevitable by the way?
20:50:58 <allbery_b> nuking his working tree
20:51:01 <dankna> yeah, I was in sympathy with McVoy wanting to make money, haha
20:51:02 <dankna> oh!
20:51:03 <dankna> wow
20:51:23 <allbery_b> what usually happens to people who theink they're 1337 nenough to work without version control
20:51:25 <c_wraith> dankna: staging a commit in git is like using darcs record in a super-clumsy way. :)
20:51:29 <dankna> agreed
20:51:50 <dankna> c_wraith: yes I see that much, hahaha.  I was just reading the HaskellWiki's "git for darcs users" earlier today in fact.
20:51:54 <dankna> to get myself up to speed for the ghc change.
20:52:19 <dankna> by the way, have there been substantial performance problems with darcs for ghc?
20:52:25 <dankna> or what was it that made them dissatisfied?
20:52:29 <Zao> dankna: Somewhat.
20:52:33 <mjrosenb> dankna: got for darcs users sounds super helpful
20:52:34 <dankna> I know an initial pull is really slow
20:52:41 <Zao> Things like "blame" being unfeasibly slow.
20:52:47 <dankna> mjrosenb: it is, but it still doesn't make the model clear
20:53:02 <dankna> http://hackage.haskell.org/trac/ghc/wiki/GitForDarcsUsers
20:53:12 <dankna> my mistake, the ghc wiki, not the haskell one
20:53:13 <allbery_b> (just from the name, yoi can tell that Linus knew what a mess git was, but the sycophants don't seem to have gotten it)
20:53:18 * hackagebot phybin 0.1.2.1 - Utility for binning phylogenetic trees in Newick format.  http://hackage.haskell.org/package/phybin-0.1.2.1 (RyanNewton)
20:53:39 <dankna> (allbery_b: indeed)
20:53:52 <dankna> blame, eh
20:53:55 <dankna> I see
20:54:00 <allbery_b> darcs has always had performance issues with large projects, because it does everything in terms of patches and has to reintegrate them all the time
20:54:04 <dankna> right, of course
20:54:13 <dankna> but I /like/ that, I consider it worth the tradeoff
20:54:20 <dankna> patches are the primary thing in how I think of versions now
20:54:27 <dankna> granted that's because I'm used ot it
20:54:33 <allbery_b> 2.4/2.5 is much better than earlier versions, but there's no real way around the basic problem when you have a tree with a lot of patches in it
20:54:43 <dankna> and they seemed to be doing okay with the darcs-all script for subrepositories
20:55:53 <joe6> does anyone know of any efforts that used haskell to build an llvm backend?
20:55:57 <allbery_b> there needs to be some way to do something like darcs1's --partial, only with an internal-format patch database instead of a baseline
20:56:26 <allbery_b> joe6: meaning?  ghc has an experimental llvm backend
20:56:44 <dankna> allbery_b: could you expand on that?
20:57:05 <allbery_b> I think you would need to build ghc HEAD from source with the right options to get it, possibly also apply some patches
20:57:23 <allbery_b> dankna: expand on which?
20:57:31 <dankna> internal-format patch database instead of a baseline
20:57:36 <dankna> I'm not clear on what that means precisely
20:57:44 <dankna> but it sounds like an important insight
20:58:08 <allbery_b> darcs --partial would let you work with a baseline tree and a set of patches, but you couldn't do anything ibvolving patches before the baseline
20:58:31 <joe6> allbery_b: once we have llvmIR, the backend converts it to x86 asm or any any other asm that the device needs.
20:58:32 <allbery_b> I'm saying, integrate the patches and then serialize the result to disk
20:58:36 <dankna> oh!
20:58:37 <dankna> yes
20:58:42 <dankna> I had the same thought ages ago now that you mention it
20:58:49 <joe6> ghc llvm backend, i think generates the llvm IR
20:58:59 <joe6> but it is backend for ghc but frontend for llvm.
20:59:05 <dankna> so it would just need to store a tarball of the tree for each tag, surely
20:59:10 <dankna> couldn't be that hard to implement
20:59:24 <allbery_b> it's more than that, I think
20:59:51 <dankna> well, for compression you'd actually want a ... pay attention now... a gzip of a tar of tars
20:59:52 <allbery_b> the tarball-of-a-tree thing was how --partial worked, more or less, but it had many restrictions
21:00:20 <dankna> the gzip configured with the extra-large-window option so as to catch the duplicated files
21:00:30 <dankna> hmmm
21:00:33 <allbery_b> to do this stuff right you need to serialize the actual internal integrated patches --- which means not the resulting tree, but all the indiividual patches and their interrelationships
21:00:46 <dankna> okay, yeah
21:00:52 <dankna> you have me intrigued by the problem now
21:00:59 <dankna> how hard is it to get into the darcs codebase?
21:01:00 <allbery_b> which dumping the final tree loses, and which is what darcs *needs* to do its job
21:01:25 <allbery_b> I'm not sure.  They were supposedly working on making it easier in darcs2 but I don;t know details
21:01:33 <dankna> okay
21:01:34 <dankna> well.
21:01:45 <allbery_b> you can check darcs.org for that
21:01:47 <dankna> yeah
21:01:53 <dankna> hmm
21:02:22 <dankna> how much do you know about what sorts of queries it needs to be able to do?
21:02:36 <copumpkin> @tell revenantphx the same thing in haskell: http://hpaste.org/paste/43836/stlc_annotation#p43839
21:02:36 <lambdabot> Consider it noted.
21:02:58 <dankna> because I bet I could whip up a backend optimized for particular query types, I have that kind of expertise, but it would clearly take a long time to understand what needed to be done
21:03:06 <allbery_b> (as far as darcs is concerned, a given tree is the result of a particular traversal of the internal patch "tree" --- and patches aren;t necessarily in terms of files, consider for example "replace" patches)
21:03:14 <dankna> true
21:03:26 <dankna> I wonder if they've considered moving to a relational database for patch storage
21:03:30 <dankna> sqlite for example
21:03:40 <dankna> it might not help
21:03:41 <allbery_b> not sure a relational db would do what's needed here
21:03:42 <allbery_b> ot
21:03:45 <dankna> if it were all blobs anyway, it would be orthogonal
21:03:57 <allbery_b> to get decent performance they need some highly specific data astructures and organization
21:03:58 <dankna> but that's the kind of question I don't know enough about the algorithms to answer
21:04:09 <allbery_b> an old-style network database might have worked
21:04:16 <dankna> well, a relational db can do whatever data model you specify
21:04:23 <dankna> you just have to specify it cleverly
21:04:48 <allbery_b> it can, yes, but it will do so poorly in many cases (most relational dbs handle self-joins poorly, for example, and the patches will have a *lot* of those)
21:05:36 <allbery_b> which is why you want a custom data structure which is optimized specifically for this.  an sqlite backend would be workable but performance would make darcs1 look blazing fast
21:05:40 <dankna> that's true enough
21:05:42 <dankna> okay.
21:05:51 <dankna> you've convinced me
21:06:04 <dankna> I do think we should be looking at binary formats though
21:06:09 <allbery_b> the darcs folks have done a *lot* of work on tuning things for maximum performance
21:06:16 <dankna> paged files with transactions implemented through locks on pages
21:06:29 <dankna> it's scary in that it's harder to recover from a corrupt thing
21:06:36 <dankna> but it seems like we've reached the point where we need it
21:06:47 <dankna> actually
21:06:54 <dankna> sorry, we don't need ACID
21:07:00 <dankna> specifically we don't need the C :)
21:07:12 <dankna> so I shouldn't be thinking about locking mechanisms
21:07:31 <dankna> yeah, they really have done a lot of work, I appreciate that
21:11:15 <dankna> well.
21:34:14 <savask> Hello, I would like to ask a one question. There are guides like "Write a Lisp interpreter in Haskell", "Write Lisp interpreter in Lisp" and so on. But is there a tutorial as "How to write a Haskell interpreter in Haskell"?
21:34:35 <shachaf> savask: There's JHC.
21:34:49 <shachaf> And there are various lambda calculus tutorials.
21:35:21 <savask> Hmm, isn't JHC a compiler?
21:35:30 <shachaf> Haskell as a full language is a bit complex to implement in a tutorial.
21:35:51 <shachaf> savask: It was originally a project to learn Haskell (or so I understand).
21:36:19 <savask> Okay, thanks. And what is a "lambda calculus"?
21:36:31 <nanothief> I think those guides are for beginners of compiler/interpreter writing, and lisp is hands down the easiest language to write one of them for. Writing a compiler for haskell would be a much more difficult job
21:37:09 <savask> It shouldn't be so hard to write an _interpreter_ of a Haskell.
21:37:12 <shachaf> @wiki Lambda calculus
21:37:12 <lambdabot> http://www.haskell.org/haskellwiki/Lambda_calculus
21:37:26 <savask> Thanks.
21:37:35 <copumpkin> savask: yes it should
21:37:39 <copumpkin> although
21:37:48 <shachaf> savask: It's rather more complicated than LISP. :-)
21:37:50 <copumpkin> http://web.cecs.pdx.edu/~mpj/thih/thih.pdf covers some of it
21:38:32 <savask> Thanks, I'll look at it. It's something about Haskell types, isn't it?
21:38:45 <copumpkin> the type system is definitely a big part of what makes it hard to implement 
21:38:51 <copumpkin> but other things like pattern matching are tricky too
21:39:05 <copumpkin> parsing it is no joke too
21:39:11 <copumpkin> with variable fixities and precedences
21:39:14 <c_wraith> There is a big book on implementing STG machines
21:39:28 <c_wraith> which is the fundamental abstraction underlying GHC's compilation strategy
21:42:32 <shachaf> savask: If you don't care about types, or complicated syntax, then an untyped lambda calculus interpreter is very simple.
21:43:27 <savask> shachaf: And what abilities will it give to me?
21:43:52 <shachaf> The Power of Teleportation.
21:43:58 <copumpkin> you can write any program possible
21:44:07 <shachaf> That too.
21:44:48 <savask> Teleportation... Sounds good...
21:45:47 <savask> So, making a simple lambda calculus interpreter is like writing an interpreter of a simple functional language?
21:47:03 <copumpkin> it's the simplest functional language, yes
21:47:23 <copumpkin> and you can implement it in a handful of lines of haskell
21:47:34 <shachaf> copumpkin: The simplest?
21:49:17 <shachaf> I suppose that depends on how you measure simplicity.
21:49:58 <shachaf> Hmm, I suppose you can have Haskell autogenerate a parser for you. :-)
21:50:14 <copumpkin> shachaf: describing its behavior has the lowest kolmogorov complexity of any language
21:50:14 <savask> ?
21:50:17 <copumpkin> I have a proof of this
21:50:33 <copumpkin> but this IRC buffer is too small to contain it
21:52:07 <savask> I hope I will be able to write a lambda calculus interpreter, it will be a good way to understanding Haskell structure. Thanks for directing.
21:52:48 <banisterfiend``> is this channel logged?
21:52:53 <banisterfiend``> are th elogs online?
21:53:17 <shachaf> banisterfiend``: No. Yes.
21:53:53 <shachaf> (Actually they're at <http://tunes.org/~nef/logs/haskell/>.)
21:54:01 <copumpkin> banisterfiend``: it says so right in the topic.
21:54:34 <shachaf> copumpkin: We have a topic?!
21:54:43 <banisterfiend``> copumpkin: not in the topic i can see
21:54:49 <banisterfiend``> it just has a link to hpaste
21:54:52 <banisterfiend``> and says 'haskell platform 20
21:55:01 <copumpkin> http://snapplr.com/sh1t
21:55:04 <copumpkin> you don't see that?
21:55:05 <shachaf> banisterfiend``: Try "/topic".
21:55:29 <banisterfiend``> no
21:56:24 <dankna> regarding "write a Haskell interpreter in Haskell", Haskell is hard to parsea
21:56:33 <dankna> and if you use haskell-src-exts you aren't learning anything
21:57:31 <shachaf> "write a Haskell interpreter in Haskell" sounds like a good exercise in a book.
22:03:51 <joe6> error on cabal install llvm: http://pastebin.com/4DtKXgTt , 
22:04:17 <joe6> it does not seem that they would release the module which such a basic error. could i be missing some library or something?
22:04:32 <joe6> dankna: why do you say " haskell-src-exts you aren't learning anything"
22:05:02 <dankna> joe6: because surely the only reason for the exercise would be to teach yourself compiler theory
22:05:19 <dankna> if you use haskell-src-exts you're missing out on all of parsing
22:05:30 <joe6> oh, ok.
22:06:02 * dankna nods
22:17:24 <joe6> @hoogle registerPackage
22:17:25 <lambdabot> No results found
22:18:37 * hackagebot authenticate 0.8.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.8.0.1 (MichaelSnoyman)
22:18:39 * hackagebot persistent 0.4.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.4.0.1 (MichaelSnoyman)
22:19:41 * hackagebot yesod-core 0.7.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.7.0.1 (MichaelSnoyman)
22:25:39 * hackagebot yesod-form 0.0.0.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.0.0.1 (MichaelSnoyman)
23:08:54 <edwardk> folks are talkative today
23:08:54 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:15:09 <bogner> edwardk: Yep, they keep saying "has joined" and "has quit"...
23:16:18 <edwardk> =)
23:20:51 * hackagebot iteratee 0.7.0.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.7.0.1 (JohnLato)
23:21:52 * hackagebot iteratee 0.8.0.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.0.0 (JohnLato)
23:22:25 <Axman6> hmm, what dangers are there with using UndecidableInstances?
23:22:56 <c_wraith> none, practically
23:23:09 <c_wraith> It can make the typechecker loop, but it has a built-in depth limit
23:23:21 <c_wraith> So it will terminate if it ends up in a loop
23:23:29 <Axman6> ok
23:23:43 <Axman6> it's possible what I have will loop, but we'll see i guess
23:24:09 <Axman6> what about IncoherentInstances?
23:24:14 <c_wraith> that one scares me
23:24:19 <Axman6> >_<
23:24:29 <c_wraith> It makes things behave....  in ways that are really hard to predict
23:24:51 <Axman6> :(
23:25:13 <Axman6> at compile time though?
23:26:32 <c_wraith> no, runtime.
23:26:44 <c_wraith> I don't understand instance resolution with incoherent instances
23:26:52 <Axman6> hmm
23:26:55 <c_wraith> and I don't think there are many people who do :)
23:27:37 <c_wraith> anyway.  time to sleep for me.
23:33:54 * hackagebot cryptocipher 0.2.4 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.4 (VincentHanquez)
23:38:25 <edwardk> hrmm, i rather don't like the internals of data-accessor. i just bothered to look at how they are implemented under the hood =(
23:38:44 <Axman6> they should use more packages!
23:38:46 <Axman6> :P
23:38:49 <edwardk> get tosses around undefineds
23:40:05 <edwardk> i was looking to see if i could cleanly dualize roconnor's lenses as store comonad coalgebras argument to make lenses as state monad algebras, which is actually the approach henning takes in data-accessor, but it requires you to inject 'undefineds' to perform get.
23:41:24 <Axman6> it's sentences like that that scare newbies away from #haskell
23:41:34 <o^_^o> Can anyone tell me why I am getting the widgets twice in this code http://hpaste.org/43840/cgi_example
23:41:38 <edwardk> yes, but did you successfully parse it?
23:41:46 <o^_^o> and how do I get it one time
23:42:16 <Axman6> no, because i don't know anything about lenses, comonads, monad algebras etc.
23:43:04 <edwardk> store comonad: (s, s -> a), state monad: s -> (a, s),       lens as a store comonad coalgebra a -> (s, s -> a) is isomorphic to a getter a -> s, and a setter a -> s -> a
23:43:11 <o^_^o> ok in the last line of cgiMain it should be (x3 +++ x4) and not (x1 +++ x2)
23:43:48 <edwardk> with a couple of laws saying that if you set something then get it you get it back, and if you set then set again you get the new thing, and getting then setting the value to what you got doesn't change anything else
23:45:11 <Axman6> i really do hope there's a blog post in your future that explains that stuff, how it's useful and where people would like to use it
23:45:20 <edwardk> a state monad coalgebra is how henning appears to encode them, which is much less pretty to my eyes, a -> s -> (a, s)  but ho do you get the value a out of s without an 'a' to hand in in that case?
23:46:08 <edwardk> here is one from jeremy gibbons http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
23:48:14 <edwardk> but really dualizing this we would want (s -> (a, s)) -> a
23:48:51 <edwardk> which is rather nonsensical looking
23:54:25 <edwardk> i still don't really get what christian maeder is trying to accomplish with his strange fork of parsec 3
