01:48:15 --- topic: '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
01:48:15 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Fri Jan 28 14:21:19 2011]
01:51:00 <Bynbo7> tibbe: perhaps CStringLen would make more sense?
01:51:34 <tibbe> Bynbo7, right CStringLen is (Ptr CChar, CInt)
01:51:38 <tibbe> ~
01:51:51 <Bynbo7> yeah
01:52:10 <Bynbo7> i was just thinking it would be more useful
01:52:28 <Bynbo7> but perhaps I'm missing the main point of the discussion =)
01:57:28 <tibbe> Bynbo7, I guess the gist of it is that perhaps we only need a single polymorphic array type and not all these monomorphic types like ByteString
01:57:50 <tibbe> Bynbo7, I'm in favor if someone could actually make it work
01:58:20 * ksf thinks we need arrays with arbitrary product types as elements
01:58:30 <ksf> that is, struct arrays.
01:58:52 <Bynbo7> eh?
01:59:10 <Bynbo7> Array can do that no?
01:59:19 <ksf> the whole thing could be done by doing tuple instances, and then providing a mapping from whatever product ADT you want to save.
01:59:31 <ksf> nope, you can't have an Array (Int, Word)
01:59:48 <c_wraith> isn't this what StorableArray does?
01:59:55 <c_wraith> Though I guess Storable is rather slow
02:00:35 <ksf> well, yes and no.
02:00:58 <Bynbo7> you can do Array ix (Int, Word)
02:01:07 <ksf> while you can combine different Storable things to a single struct, it doesn't do it at least semi-automatically.
02:01:16 <ksf> but not unboxed.
02:01:18 <Bynbo7> UArray you can't easily
02:01:20 <ksf> sorry should've said that.
02:01:21 <Bynbo7> yeah
02:01:25 <Bynbo7> :)
02:01:56 <ksf> why's storable slow?
02:02:04 <ksf> is that why my Ptr-based code is so slow?
02:03:58 <Bynbo7> actuslly, if UArrau were a typle family, you could define instance (UArray a, UArray b) => UArray (a,b) where data UArray (a,b) = UArrayPair (UArray a) (UArray b)
02:04:00 <tibbe> ksf, Storable shouldn't be slow, pokes of basic types like Int should be as efficient as possible
02:04:32 <tibbe> Bynbo7, that's what Data.Vector does
02:05:06 <Bynbo7> yeah
02:06:06 <ksf> but you can't nest those UArrayPairs, can you?
02:08:04 <Bynbo7> what do you mean?
02:08:32 <ddarius> tibbe: For basic types, Storable is fine.  For non-basic types, you are essentially constantly marshalling and unmarshalling.
02:08:40 <ksf> UArray (a,b,c) or UArray (a,(b,c))
02:09:02 <tibbe> ddarius, yes, a Storable vector is not good for many types
02:09:06 <harlekin> @pl (\f -> fmap f a)
02:09:07 <lambdabot> flip fmap a
02:09:29 <ddarius> ksf: Of course you could.
02:10:47 <ksf> what's uarraypair supposed to be, in any case? google doesn't know it.
02:11:13 <ksf> having two UArrays of course works, but that doesn't unbox both values of the tuple next to each other.
02:11:44 <ksf> when looking at cache asymptotics, that's a huge difference.
02:11:54 <Bynbo7> yeah
02:12:57 <Bynbo7> maybe you could have something like data UPair a b = UPair !a !b, and have a storable instance for Storable a, Storable b => Storable (UPair a b)
02:19:27 <kingping> hello
02:19:59 <kingping> > [1..10] >>= (return . (+2))
02:20:00 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
02:20:13 <kingping> > [1..10] >>= $ return . (+2)
02:20:13 <lambdabot>   <no location info>: parse error on input `$'
02:20:25 <kingping> :i >>=
02:29:54 <dcoutts> tibbe: show should return something that can be read back, but you can still make improvements within that constraint
02:30:05 <dcoutts> tibbe: e.g. look at the show for Data.Map
02:30:39 <tibbe> dcoutts, right
02:30:40 <dcoutts> tibbe: which then has the advantage that writing literals gets to use the same nice syntax
02:30:58 <tibbe> dcoutts, actually the Data.Map Show instance assume Data.Map is imported unqualified to work
02:31:13 <dcoutts> tibbe: still, better than nothing
02:31:16 <tibbe> dcoutts, right, so I'll add both Show/Read with a nice syntax
02:31:19 <tibbe> dcoutts, right
02:31:44 <dcoutts> tibbe: if I had my way, read/show would use an intermediate structured term and so you'd be forced to make something sane
02:31:58 <dcoutts> unlike say, show instances in the time package
02:32:31 <dcoutts> but it'd also mean we could pretty print and do binary serialisation
02:42:30 <nanothief> What version of GHC was the function classInstances in Language.Haskell.TH added? I have 6.12.1, and it doesn't appear to be present
02:47:10 <harlekin> How can I obtain file system information in Haskell, like how full a hard drive is.
02:47:15 <harlekin> s/.$/?/
02:47:41 <shapr> harlekin: How would you get file system information in some other language?
02:47:59 <harlekin> shapr, I'd use statfs in C for instance.
02:48:57 <shapr> @hoogle statfs
02:48:57 <lambdabot> No results found
02:49:01 <shapr> @hoogle stat
02:49:02 <lambdabot> module Control.Monad.State
02:49:02 <lambdabot> Test.HUnit.Base data State
02:49:02 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
02:49:43 <mauke> foreign import ccall "sys/vfs.h statfs" c_statfs :: Ptr CChar -> Ptr Statfs -> IO CInt
02:49:52 <mauke> but instance Storable Statfs is going to be annoying
02:50:05 <shapr> Is Storable the Haskell version of Python's repr?
02:50:18 <shapr> Or is that Serializable?
02:50:33 <mauke> Storable is Byteable
02:50:35 <shapr> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-Storable.html ?
02:50:51 <mauke> can be serialized to C compatible memory chunks
02:50:56 <shapr> aha
02:51:45 <mauke> shelling out to df may be easier
02:56:50 <nanothief> ahh I solved my problem, it was introduced classInstances was introduced in GHC 7
03:25:33 <dagle> Hi. What does "mkUsageInfo: internal name? r{tv ahn}" mean?
03:28:10 <dagle> Nobody?
03:29:48 <dagle> All I find is that it's a bug in the renamer in the compiler.
03:30:51 <osfameron> dagle: I have no idea - but perhaps some context would help anyone that does know...
03:31:14 <osfameron> you could paste the code and command that's triggering the problem to hpaste.org
03:31:46 <geheimdienst> i've wondered about those messages myself. i believe i've seen them when building haddock
03:31:58 <pou_> given a certain initial F-algebra, is there a way of automatically calculating its catamorphism ?
03:31:59 <geheimdienst> or towards the end of a cabal build
03:33:51 <ziman> pou_, yes, see "cata" here: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Cata.html
03:34:20 <ziman> (although i'm not sure whether i understood your question correctly)
03:34:37 <dagle> osfameron: http://hpaste.org/43778/mkusage
03:34:59 <osfameron> dagle: address to the whole channel please ;-) (I already admitted to not having a clue ;-)
03:35:09 <pou_> I am not sure to correctly understand my question neither. Thanks ziman 
03:35:37 <osfameron> dagle: you might want to mention how you're compiling it too though - which version of ghc?  what command-line? etc. 
03:35:40 <dagle> http://hpaste.org/43778/mkusage
03:35:58 <boegel> hiya y'all
03:36:07 <geheimdienst> hey boegel
03:36:10 <boegel> I keep running into this, and now I really want to grasp this fully....
03:36:20 <boegel> I have a function that recurses over a list
03:36:36 <boegel> but I want to make it more strict, because it's using waaay to much memory
03:36:39 <boegel> see http://hpaste.org/43779/enforce_scrictness_on_list
03:36:52 <boegel> the length + deepseq trick isn't helping me
03:36:57 <boegel> I want to avoid huge thunks
03:38:36 <dagle> http://hpaste.org/43778/mkusage , ghc and ghci gives the "error" "mkUsageInfo: internal name? r{tv ahn}" , ghc --version = 6.12.3
03:40:55 <shapr> preflex: seen simonpj
03:40:55 <preflex>  simonpj was last seen on #ghc 2 years, 150 days, 20 hours, 53 minutes and 6 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
03:42:29 <dagle> Bbl. Hopefully somebody have found some info by then. :)
03:52:58 <boegel> no-one to help me out with a memory issue caused by laziness?
03:55:12 <Tau> how can i change the 'prelude>' ?
03:55:32 <Wooga> hello, can anyone suggest any tutorials about enumeratees from (Data.)Enumerator package?
03:55:50 <Wooga> *in addition to ones at http://john-millikin.com/software/enumerator/
03:56:43 <ksf> if you're relying on tutorials, iteratees aren't for you.
03:57:06 <Wooga> well, i got how iteratee and enumerator are working
03:57:17 <Wooga> but stuck a bit with enumeratees
03:57:25 <ksf> so far I've yet to meet someone who understood them before implementing their own toy library
03:57:55 <Wooga> ah, i did that for emumerator and iteratee
03:58:01 <Wooga> using Oleg's paper
03:58:07 <shapr> Iteratees are pretty much what boegel is asking for, right?
03:58:40 <ksf> yes and no
03:58:42 <Wooga> "boegel" ?
03:58:48 <gienah> Wooga: http://docs.yesodweb.com/blog/enumerators-tutorial-part-1
03:59:04 <Wooga> gienah: this is no addition to http://john-millikin.com/software/enumerator/
03:59:10 <Wooga> it listed there
03:59:13 <shapr> Wooga: boegel is the guy who started the #haskell-blah channel and has done much nifty stuff in the Haskell community.
03:59:17 <ksf> I think boegel wants to figure out how to implement dynamic programming for his case in pure code
03:59:36 <gienah> Wooga: http://themonadreader.files.wordpress.com/2010/05/issue16.pdf
04:00:00 <Wooga> gienah: oh, thank you!
04:00:08 <ksf> oh and I'd advise against using data.enumeratee, the api is broken by design.
04:00:27 <Wooga> because of seperated Error state?
04:00:40 <ksf> because of the messed up chunk type
04:01:02 <ksf> it doesn't parametrise over the container type but just uses lists
04:01:26 <ksf> compare the head function for the bytestring and list versions, they're inconsistent.
04:02:36 <boegel> shapr: don't give me too much credit here :P
04:02:49 * geheimdienst gives boegel debit
04:02:50 <Wooga> just looking at those two functions don't makes me understand whats wrong with them :P
04:02:52 <ksf> yeah, give it to me
04:03:47 <boegel> ksf: I just want to avoid huge thunks... the list the function is working on has bout 250K elements... so, if it's not handled strictly, it'll comsume huge amounts of memory
04:04:14 <ksf> head :: Monad  m => Iteratee  ByteString  m (Maybe  Word8)   vs    head :: Monad  m => Iteratee  a m (Maybe  a)
04:04:46 <ksf> note that to the right, the parameter to Iteratee is the same as the return type, whereas to the left the parameter to Iteratee is the container type.
04:05:01 <ksf> consistent would be head :: Monad m => Iteratee [a] m (Maybe a)
04:06:16 <ksf> or, generically, for a class "List" with associeted type for the elements, head :: (Monad m, List l) => Iteratee l m (Maybe (Elem l))
04:06:42 <ksf> enumeratee is supposed to dumb things down as far as possible, but that was *too* much.
04:07:24 <Wooga> so enumerator package was oversimplified?
04:07:32 <ksf> yep.
04:07:36 <ksf> or rather, missimplified
04:09:09 <ksf> @remember Einstein Make everything as simple as possible, but not simpler.
04:09:09 <lambdabot> Okay.
04:10:05 <geheimdienst> @remember Einskell Make everything as monad as possible, but not monadder.
04:10:05 <lambdabot> Okay.
04:11:02 <vegai> but the question is, should we start from simple and complexify gradually
04:11:07 <vegai> or start from complex and simplify
04:12:14 <ksf> it's not about changing the thing, but looking at the same thing from another perspective
04:12:22 <ksf> one that is still complete, but simpler.
04:18:42 <vegai> does the Yesod project have a dedicated channel?
04:20:26 <ksf> #yesod doesn't exist, so I'd wager no.
04:20:38 <shapr> vegai: create it!
04:21:14 <ksf> the only other haskell channels that ever took off are -blah and #xmonad
04:21:41 <ksf> -in-depth sees a couple of lines every couple of days, but I would'nt call that taking off
04:21:48 <ksf> #yi is just dead.
04:22:46 <vegai> shapr: !
04:23:51 <vegai> well, Freenode has #yesod now, then.
04:33:43 <Lemmih> Has the Haskell Symposium been announced yet?
04:36:33 <dcoutts> not, sure but I know the date
04:37:50 <dcoutts> Lemmih: Friday 22nd September for the Symposium, and 23rd for the Implementers' Workshop 
04:38:22 <Lemmih> dcoutts: It shares datelines with the ICFP, I assume?
04:38:32 <Lemmih> *deadlines
04:39:01 <dcoutts> Lemmih: submission deadlines? no, it's usually arranged so that if you're rejected from ICFP then you can submit to the HS
04:40:07 <Lemmih> dcoutts: Ah, okay. Thanks.
04:49:17 <Cale> ghc: panic! (the 'impossible' happened) (GHC version 6.12.3 for i386-unknown-linux): initC: srt_lbl
04:51:21 <Cale> FFFFUUUUUUU....
04:52:55 <Cale> ah, apparently guards + arrow syntax don't mix well
04:53:18 <Bjorn`> RayNbow`TU ja hij zit er nog/weer
04:55:28 <Wooga> is folowing design of brainfuck interpreter good: (Enumerator reading lines from stdin) -> (Enumeratee containing actual brainfuck evaluation) -> (Iteratee performing IO actions based on output of enumeratee) ?
04:55:57 <Cale> I probably wouldn't bother using iteratees...
04:56:12 <Wooga> and make interpreter impure?
04:56:23 <Cale> No, I'd just write it as a pure function.
04:56:41 <Wooga> but how are you supposed to get input in that pure function?
04:56:50 <Cale> take it as a string?
04:56:56 <ClaudiusMaximus> :t interact
04:56:57 <lambdabot> (String -> String) -> IO ()
04:56:58 <Wooga> no, it is not solvable as this
04:57:04 <Cale> Sure it is
04:57:12 <Wooga> you are may need input in middles of BF program
04:57:13 <Cale> ^^ interact
04:57:16 <Wooga> or may not need at all
04:57:16 <Cale> mhm
04:57:17 <Wooga> hm
04:57:19 <Wooga> lazy IO ?
04:57:22 <Cale> yeah
04:57:28 <Wooga> isn't that worse then iteratee?
04:57:34 <Cale> Well...
04:57:53 <Wooga> just Oleg criticizing lazy IO
04:58:00 <Wooga> and suggests iteratee in exchange
04:58:13 <Cale> Yeah, but iteratees are 1000 times more complicated to use
04:58:38 <quicksilver> that may be slightly harsh, Cale :P
04:58:53 <Cale> maybe
04:59:00 <quicksilver> but it's true that it does seem hard to get the abstraction right in its most general case
04:59:33 <Wooga> well, oleg's papers are pretty clear
04:59:39 <Wooga> but actual implementations are not
04:59:59 <Cale> Wooga: another option is to think about your interpreter as a pure function which compiles your BF program into an IO action
05:00:39 <Wooga> but how do i glue resulting list of IO actions with code's logics?
05:00:40 <Cale> Of course, that's  BF -> IO (), which you can think of as an impure interpreter if you prefer to :)
05:02:09 <Wooga> i just have no idea
05:02:54 <Wooga> maybe creating special iterators and conditional jump actions...
05:03:08 <Wooga> ...but this seems to be much more complicated then using iteratees
05:20:41 <Guest79927> hello haskell world
05:21:13 <Bynbo7> Hello person formally known as fred_
05:27:52 <mauke> did you mean: formerly
05:30:26 <vegai> is the OverloadedStrings extension discouraged?
05:31:46 <freiksenet> is it possible to match Data.Sequence with a head/tail deconstructoring like lists? (aka (x:xs))
05:32:50 <kosmikus> freiksenet: there are viewl and viewr
05:35:03 <Bynbo7> vegai: why would it be?
05:35:16 <Bynbo7> mauke: i did indeed, my bad
05:35:21 <freiksenet> kosmikus: aha, that works. thanks
05:36:04 <vegai> Bynbo7: the Yesod book uses them but mentions in an info box alternatives to it
05:36:26 <vegai> so I was left wondering whether they're generally thought of as ... distasteful
05:37:38 <Bynbo7> i wouldn't think so
05:37:57 <cizra> Hi
05:38:23 <Cale> freiksenet: You may even consider using the pattern views extension along with those
05:38:39 <Cale> er, view patterns, right :)
05:38:46 <Cale> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
05:38:51 <cizra> I have an IO action returning in do-block, followed by a pure function on that data. How do I give it a name? I've been writing bla <- return $ func data, but it doesn't look nice.
05:39:19 <Cale> let?
05:39:33 <cizra> hmmm
05:39:46 <Cale> cizra: do ... ; let bla = func data; ...
05:39:49 <freiksenet> Cale: ok, thanks
05:40:07 <cizra> ahh. Looks like ghci
05:40:33 <Cale> yeah, ghci's syntax is designed to look a bit like the inside of a do-block
05:40:49 <cizra> *nod* I had forgotten you can do it in do-block
05:41:18 <boegel> @pl compare (third3 t1) (third3 t2)
05:41:18 <lambdabot> compare (third3 t1) (third3 t2)
05:41:27 <boegel> @hlint compare (third3 t1) (third3 t2)
05:41:28 <lambdabot> No module "compare (third3 t1) (third3 t2)" loaded
05:41:37 <boegel> @hlint help
05:41:38 <lambdabot> help provides: help
05:41:40 <ion> cale: Ooh, i hadn’t realized that.
05:41:41 <cizra> Cale: Thanks for help!
05:41:45 <boegel> @hlint
05:41:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:41:56 <kfr> <lambdabot> help provides: help
05:41:58 <kfr> Recursion
05:42:28 <Cale> cizra: no problem!
05:42:29 <Cale> :)
05:42:44 <ion> cale: That is, i hadn’t realized e.g. “foo <- getLine” works in ghci.
05:42:46 <ClaudiusMaximus> @pl \t1 t2 -> compare (third3 t1) (third3 t2)
05:42:46 <lambdabot> (. third3) . compare . third3
05:42:59 <Botje> what, no compare `on` third3 ?
05:43:01 <ClaudiusMaximus> @pl \third3 t1 t2 -> compare (third3 t1) (third3 t2)
05:43:01 <lambdabot> flip =<< (((.) . compare) .)
05:43:37 <Cale> ion: ah :)
05:43:55 <fryguybob> @type comparing
05:43:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:44:16 <boegel> @hoogle  (a -> b) -> a -> a -> Ordering
05:44:21 <boegel> fryguybob: aha, thx
05:44:24 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:44:25 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:44:25 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
05:44:31 <Botje> or compare `on` f
05:44:39 <Botje> \bot seems laggy
05:44:52 <fryguybob> @type (compare `on`)
05:44:53 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
05:45:49 <boegel> fryguybob: I figured something like this had to exist, thx :)
05:46:17 <sioraiocht> is there any operational difference between add x y = x + y and add x = (\ y -> x + y)
05:46:22 <fryguybob> boegel: Yeah.
05:49:06 <tibbe> sioraiocht, I don't think so
05:49:14 <tibbe> sioraiocht, it affects inlining but that's all I know
05:49:18 <sioraiocht> tibbe: thanks, someone was asking =)
05:49:28 <sioraiocht> and I didn't think so, but didn't want to steer a n00b wrong
05:50:52 <ion> I can’t help reading \bot as a LaTeX-style command instead of as a Haskell-style pseudo lambda, whereas λbot would be obvious. :-)
05:52:15 <Botje> \definecommand{\bot}{}{Lambdabot}
05:52:16 <ion> (In fact \bot means ⊥ in LaTeX.)
05:52:18 <Botje> happy? :P
05:55:42 <jaspervdj> zenzike: ping
05:55:51 <zenzike> jaspervdj, pong!
05:56:02 <zenzike> I ended up using the hamlet templates instead
05:56:07 <zenzike> that worked fine :-)
05:56:11 <jaspervdj> zenzike: Ok :-)
05:57:02 <zenzike> out of curiosity though, is there a terminator symbol for the default template language? I couldn't see it in the code ...
05:57:26 <zenzike> (I browsed through some of the Hakyll internals)
06:00:37 <scooty-puff> fail vs. throwError - is it better to operate in just Monad or MonadError?
06:00:45 <AnAdorableNick> s\la
06:06:35 <freiksenet> why does import Data.Sequence (ViewL) doesn't import :< (ViewL constructor)?
06:07:13 <freiksenet> s/does/
06:07:27 <mauke> s/doesn't//, s/does/doesn't/
06:07:33 <mauke> probably needs (ViewL(..))
06:09:08 <freiksenet> mauke: ah, ok. now it works ) thanks
06:10:14 <revenantphx> Hey, has anyone gotten the llvm haskell bindings functioning on OS X?
06:10:26 <revenantphx> It's finding the llvm-c/Core.h header, but it apparently isn't linking now.
06:10:31 <jaspervdj> zenzike: No, there isn't
06:10:33 <revenantphx> (since it can't find the symbol)
06:10:44 <jaspervdj> zenzike: I should add it though, I guess
06:11:10 <zenzike> jaspervdj, I think so too, but then you'd need a way to escape it
06:11:13 <revenantphx> https://gist.github.com/816516
06:11:24 <zenzike> jaspervdj, I actually quite like the hamlet $foo$ way of doing things
06:11:57 <jaspervdj> zenzike: Yeah, perhaps I should switch to $xxx$ as well
06:12:25 <zenzike> you could make the trailing $ optional, but I expect it would get messy
06:12:52 <zenzike> jaspervdj, eg, the behaviour of "$url blah blah $root" might catch people out
06:13:14 <jaspervdj> I don't really care about breaking backward-compatibility for hakyll 3 so that's alright :-D
06:15:54 <zenzike> ha! :-) that makes things a lot easier then
06:16:33 <Bynbo7> revenantphx: i have
06:16:43 <revenantphx> Oh wonderful, do yo uknow how to fix this issue?
06:16:54 <revenantphx> It's just failing at finding the path
06:16:54 <revenantphx> brb
06:16:56 <zenzike> I suppose things aren't so bad if identifier names can't have non alphanumerics
06:16:59 <Bynbo7> i used the homebrew version of llvm
06:17:23 <Bynbo7> which is the version that the llvm bindings have been updated to (2.8 instead of whatever OS X shipps with)
06:19:28 <revenantphx> Same.
06:19:32 <revenantphx> I use the brew version.
06:19:37 <revenantphx> I also brew link'd it.
06:19:47 <revenantphx> dd you have this linking issue?
06:21:38 <revenantphx> Bynbo7?
06:22:33 <Bynbo7> nope, i think it worked fine when i just used cabal install llvm, though i may have specified --extra-libs-dir=/usr/local/lib and --extra-includes-dir=/use/local/include
06:22:36 <Bynbo7> usr*
06:23:13 <freiksenet> is there any simple and crude function to measure execution time in haskell (ghci?) like "time" in Common Lisp?
06:23:38 <Lemmih> freiksenet: :set +s
06:23:56 <freiksenet> Lemmih: awesome, thanks a lot
06:24:00 <EvanR-work> wow
06:24:23 <EvanR-work> Lemmih: what is the byte count?
06:25:17 <Lemmih> EvanR-work: Allocated memory. But take it with a grain of salt.
06:25:23 <EvanR-work> i get zero most of the time ;)
06:25:35 <EvanR-work> 5
06:26:14 <EvanR-work> hmm
06:29:16 <revenantphx> il brb bynbo, thanks
06:47:50 <Jonno_FTW> anyone in here?
06:48:22 * geheimdienst sleepily looks at Jonno_FTW and meows a little
06:48:33 <noteventime> Jonno_FTW: About 712 last I saw :)
06:48:36 * geheimdienst purrs
06:48:41 <Jonno_FTW> ...
06:48:54 <Jonno_FTW> well I'm running lambdabot 4.2.3.2
06:49:03 <Jonno_FTW> and whenever I run anything in eval I get: 
06:49:14 <Jonno_FTW>  Could not find module `Math.OEIS':
06:49:32 <Jonno_FTW> even thoughoeis is installed
06:49:35 <geheimdienst> @hoogle OEIS
06:49:35 <lambdabot> No results found
06:50:06 <portnov> hi all
06:50:10 <noteventime> Maybe it's some issue with user vs. global packages?
06:50:21 <portnov> any plans on HaskellPlatform release? :)
06:50:37 <Jonno_FTW> I am running the bot and installs as rot
06:50:40 <Jonno_FTW> *root
06:50:57 <noteventime> Jonno_FTW: How did you install oeis?
06:51:05 <Jonno_FTW> cabal install oeis
06:51:09 <Jonno_FTW> as root
06:51:15 <noteventime> And same with lambdabot?
06:51:31 <Jonno_FTW> I compiled from source
06:51:33 <geheimdienst> when you do sudo ghci, can you import Math.OEIS?
06:51:34 <dcoutts> portnov: waiting on ghc-7.0.2
06:51:47 <Jonno_FTW> geheimdienst: no
06:51:57 <noteventime> As root or as sudo?
06:52:11 <Jonno_FTW> root
06:52:16 <dcoutts> Jonno_FTW: default is to do a per-user install, so sounds like you did an install only for the root user, rather than a global install
06:52:26 <dcoutts> Jonno_FTW: --global is what you want
06:52:28 <geheimdienst> hm ... does ghc-pkg check mention oeis?
06:52:33 <Jonno_FTW> ok
06:52:52 <Jonno_FTW> ghc-pkg check returns nothing
06:53:08 <geheimdienst> listen to dcoutts, the resident guru
06:53:57 <Jonno_FTW> ok
06:54:25 <Jonno_FTW> dcoutts: but I am running cabal and lambdabot aas root
06:54:56 <noteventime> Jonno_FTW: Did you run ghci as root when you tried to import oeis?
06:55:10 <dcoutts> Jonno_FTW: if you do a per-user install as root and then also run it as root then it should be fine
06:55:34 <dcoutts> Jonno_FTW: the only problem is doing a per-user install just for the root user, and then expecting to be able to access/run the stuff as a non-root user
06:55:47 <dcoutts> for the latter you need to do a global install
06:56:14 <Jonno_FTW> noteventime: yes
06:56:23 <Jonno_FTW> ok
06:56:36 <noteventime> Would a global install, in general, have the same result as installing a distro package?
06:56:44 <ricree> what's the easiest way to check which version of a library I have installed?
06:56:51 <Jonno_FTW> so do I run cabal --global install oeis ?
06:57:12 <dcoutts> noteventime: more or less, yes
06:57:29 <dcoutts> Jonno_FTW: as root, yes. That will make it available to all users.
06:57:36 <Jonno_FTW> ok
06:57:46 <noteventime> dcoutts: Where, in general, are global packages installed then?
06:57:56 <dcoutts> noteventime: default is /usr/local
06:58:02 <noteventime> ok
06:58:12 <boegel> has anyone ever tried to get force evaluation of a graph created with mkGraph (FGL) to limit memory requirements?
06:59:13 <Jonno_FTW> now I get more horrible errors
06:59:50 <Wooga> is there any place where i can see examples of Enumeratee made with iteratee ~0.7.0.0 package?
07:00:09 * hackagebot xmlhtml 0.1.2 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.2 (ChrisSmith)
07:00:33 <Jonno_FTW>  Could not find module `ShowIO':
07:00:41 <Jonno_FTW>  It is a member of the hidden package `sh...
07:00:57 <Jonno_FTW> how do I make it not hidden or so the bot can use ut?
07:01:03 <boegel> how many bytes does an Int take? any smaller integer types? WordX?
07:01:20 <Wooga> boegel: word32, i think
07:01:28 <noteventime> Jonno_FTW: You get that error when compiling OEIS or when trying to run lamdabot?
07:01:33 <Wooga> ah ,wait
07:01:37 <Wooga> that depends on your system
07:01:38 <Jonno_FTW> when I run lambdabot
07:01:38 <Botje> an unboxed int is at least a pointer + an int
07:01:46 <Wooga> on amd64 that will be word64
07:02:04 <Jonno_FTW> noteventime: OEIS installed fine
07:02:20 <boegel> Wooga: Int == Word32?
07:02:29 <Wooga> boegel: at least have same boundaries
07:02:37 <geheimdienst> wasn't Int the platform-dependent one?
07:02:55 <Wooga> on x86 that will be Word32
07:03:04 <noteventime> @hoogle ShowIO
07:03:04 <lambdabot> No results found
07:03:52 <noteventime> Hmm, why would Show be hidden :¦
07:03:55 <Botje> err, s/unboxed/boxed/
07:04:00 <Jonno_FTW> : There is no package named ShowIO. Perhaps you need to run 'cabal
07:04:17 <noteventime> Jonno_FTW: It's from a package called "show"
07:04:21 <boegel> what about Double? what are the (smaller) options there? does Float take significantly less space than Double?
07:04:24 <Jonno_FTW> ahh
07:04:30 <geheimdienst> boxed cat has uniform representation!
07:04:34 <geheimdienst> scnr
07:04:50 <Wooga> ah, one moment also
07:05:09 <Wooga> though Int and WordX are seems to take same space, WordX is unsigned
07:05:10 * hackagebot wumpus-core 0.43.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.43.0 (StephenTetley)
07:05:12 * hackagebot wumpus-basic 0.16.0 - Basic objects and system code built on Wumpus-Core.  http://hackage.haskell.org/package/wumpus-basic-0.16.0 (StephenTetley)
07:05:23 <noteventime> Jonno_FTW: Any particular reason for now installing lambdabot through cabal-install?
07:05:32 <Jonno_FTW> uhh
07:05:34 <Jonno_FTW> one sec
07:06:03 <Jonno_FTW> ok it might be good idea
07:06:11 * hackagebot wumpus-drawing 0.2.0 - High-level drawing objects built on Wumpus-Basic.  http://hackage.haskell.org/package/wumpus-drawing-0.2.0 (StephenTetley)
07:06:49 <Jonno_FTW> noteventime: installing from hackage now
07:06:58 <boegel> using Word16 as a drop-in replacement for Int when handling integers < 10K should work, right?
07:07:17 <scooty-puff> a general question - when you write haskell, how important is it to use a clean style, such as applicative (or just pointfree)?
07:07:40 <boegel> hmm, wait, no, Word16 is unsigned, crap
07:07:42 <geheimdienst> > 2^16
07:07:44 <lambdabot>   65536
07:07:51 <scooty-puff> i have written a function that converts a "raw" binary parse of a constant pool, CpoolInfo, to a type ConstantPool
07:07:54 <scooty-puff> and it looks like crap..
07:07:55 <quicksilver> there is Int16, I expect
07:07:59 <geheimdienst> > minBound :: Int16
07:08:00 <lambdabot>   -32768
07:08:05 <geheimdienst> boegel ^^
07:08:11 * hackagebot wumpus-tree 0.14.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.14.0 (StephenTetley)
07:08:24 <Botje> scooty-puff: write crap then clean it up :)
07:08:32 <Botje> scooty-puff: if you put it on hpaste or similar we can give some suggestions
07:08:33 <boegel> geheimdienst: ah!
07:08:35 <quicksilver> boegel: be aware that in most contexts an Int16 is not smaller than an Int, though.
07:08:45 <scooty-puff> ok, just putting the function, not other datatype definitinos
07:08:46 <boegel> quicksilver: in which contexts?
07:09:08 <quicksilver> boegel: almost everything except an UArray or UVector.
07:09:17 <boegel> urgh, crap, apparently FGL can't handle fully-connected bi-dir graphs of 500 nodes efficiently
07:10:06 <boegel> memory-wise, that is
07:10:19 <scooty-puff> Botje, http://hpaste.org/43780/crappy_code
07:10:20 <boegel> maybe I'm just creating it the wrong way
07:10:30 <geheimdienst> scooty-puff: i wouldn't take pointless style too seriously. it's easy to overdo it and make the code terribly unclear, imho
07:11:13 <scooty-puff> http://hpaste.org/paste/43780/crappy_code_annotation__cpo#p43781
07:11:19 <scooty-puff> for the CpoolInfo parse - this one i like
07:11:33 <scooty-puff> (<#>) and (<&>) are comparable to <$> and <*>
07:11:51 <quicksilver> there is a serious point to pointless style. This point is, I believe : it is not always helpful to name something which is used exactly once.
07:11:54 <boegel> does anyone have any suggestions to make this more efficient for reasonable-sized graphs?
07:13:18 <scooty-puff> Botje, i have not checked for compilation, so it is definitely rough
07:13:44 <boegel> http://hpaste.org/43782/memory_hog_graph_creation_500
07:14:15 <Botje> scooty-puff: could you maybe reuse your Convertible typeclass for all those safeConvertFrom... things?
07:14:47 <accel> what's good tutorial on haskell exceptiosn? http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html is a bit hard to read
07:14:53 <scooty-puff> i would, except that to convert to a namespace, multiname, etc., the string pool is needed
07:15:32 <scooty-puff> safeConvertFromMultiname ::'ish - string array -> namespace array -> namespace set array -> m multiname
07:15:59 <scooty-puff> i tried putting them in a reader monad, but that added more than it helped
07:16:10 <accel> what's the haskell equiv of exit(-1) ?
07:16:21 <scooty-puff> :t System.Exit.exitFailure
07:16:21 <mauke> accel: nothing, I hope
07:16:22 <lambdabot> forall a. IO a
07:16:29 <mauke> accel: what the hell is that supposed to do?
07:16:46 <accel> mauke: after I catchan exception; I want to print a message and exit
07:16:47 <scooty-puff> :t System.Exit.exitWith (-1)
07:16:48 <lambdabot>     No instance for (Num GHC.IO.Exception.ExitCode)
07:16:48 <lambdabot>       arising from a use of syntactic negation at <interactive>:1:22-23
07:16:48 <lambdabot>     Possible fix:
07:16:50 <Botje> scooty-puff: you don't need the safeConvertFromNamespaceInfo'
07:16:59 <mauke> accel: ok, but why -1?
07:17:02 <Botje> you can just write mapM (safeConvertFromNamespaceInfo sarr)
07:17:04 <accel> mauke: the -1 is unnecessary
07:17:11 <mauke> s/unnecessary/wrong/
07:17:15 <scooty-puff> Botje, that is true
07:17:28 <scooty-puff> mostly it was the line length being the reason for doing that
07:17:31 <accel> mauke: that's how I terminate all my C progs on errors; what is the right way to do it in haskell ?
07:17:38 <mauke> no.
07:17:46 <mauke> the right way in C is exit(EXIT_FAILURE)
07:17:46 <scooty-puff> error "holy crap"
07:18:05 <mauke> accel: exitFailure
07:18:24 <Botje> scooty-puff: also, will the counts ever be different from the lists you get?
07:18:37 <jix> boegel: have you checked if your allPairs' works with 500 entries?
07:18:39 <scooty-puff> always either 0 or one more
07:18:44 <scooty-puff> *one greater
07:18:54 <scooty-puff> or should be..
07:19:02 <scooty-puff> if the file is not properly formed
07:19:04 <scooty-puff> maybe not
07:19:13 <Botje> ah. otherwise you could drop the counts and just take the length of those lists
07:19:28 <scooty-puff> thats something i had been undecided about
07:19:49 <scooty-puff> currently, i have a few Binary instances that are pretty much just a description of the file format
07:20:03 <scooty-puff> and then these Convertible instances to make them more usable
07:20:15 <Botje> also, the 'listArray' nc <$> mapM f' thing could be abstracted into a function
07:21:01 <Botje> and you could inline iarr, uarr, ... into the return ConstantPool ..
07:21:03 <scooty-puff> maybe safeConvertToArray or something along those lines...
07:21:12 <scooty-puff> ok
07:21:15 <accel> mauke: thanks for the clarifications
07:22:45 <Botje> and the rest of your function is hindered by the crappy record syntax
07:22:59 <scooty-puff> ok, that part was something that had really been bothering me
07:23:01 <scooty-puff> the record syntax
07:23:12 <Botje> you could use something like fc-labels instead
07:23:18 <Botje> but i don't have much experience with that.
07:23:22 <scooty-puff> ok
07:23:28 <HugoDaniel> http://hpaste.org/43783/some_simple_type_classes
07:23:42 <HugoDaniel> i sometimes feel "this is wrong" when i add those one function type classes
07:24:41 <Wooga> does anyone know any examples of usage of iteratee ~0.7.0.0 package; including enumeratees ?
07:25:24 <scooty-puff> Botje, i had considered record wildcard syntax, but that would only help with the argument, and i'm not sure if it is worth it
07:25:31 <Wooga> all i can find - obsolete ~0.3 or ~0.4 versions
07:25:34 <scooty-puff> *syntax -> extension
07:27:24 <duairc> Wooga: Most people seem to have moved to the enumerator package. Snoyman's blog has a good three-part tutorial on using that package specifically: http://docs.yesodweb.com/blog/enumerators-tutorial-part-1
07:27:59 <Wooga> dmead: but ones says that Enumerator package is defective by design due to oversimplicity
07:28:26 <boegel> jix: why wouldn't it?
07:29:19 <boegel> jix: Prelude Main> length . allPairs' $ zip [1..] [1..500]
07:29:19 <boegel> 249500
07:29:29 <jix> boegel: nm, I misread the implementation
07:29:44 <boegel> jix: the problem is the graph imho
07:30:58 <xplat> boegel: length . allPairs' is maybe not a good test, maybe length . show . allpairs'?
07:31:33 <Jonno_FTW> I installed lambdabot from hackage but I still get the same error
07:31:36 <jix> but yeah it should work... the recursion is only on the right of ++
07:31:55 <Wooga> ugh
07:31:57 <Wooga> i mean duairc *
07:32:23 <xplat> jix: well, ideally it would be using dlists since it still does O(n) concats, but that's only a small constant factor
07:32:26 <Wooga> first tab-completed nick is not the right one :P
07:34:03 <duairc> Wooga: What do you mean "ones"?
07:35:17 <boegel> xplat: almost instantly: Prelude Main Data.Graph.Inductive.Graph> length . show $ allPairs' (zip [1..] [1..500])
07:35:17 <boegel> 5273433
07:35:46 <xplat> boegel: okay, looks good then
07:35:54 <Navigium> Hello.. I'm looking for some help. I started writing some application to administer classes, students and their grades in exams. So I have some different data type I would like to persist. Now, what's the best way to do that. I suppose it's not serializing to a file using show and read...
07:36:06 <boegel> xplat: well, yeah, the problem doesn't lie there, at least
07:36:16 <Wooga> duairc: http://paste.pocoo.org/show/334391/
07:36:21 <boegel> xplat: it mkGraph which is the memory hog it seems
07:36:36 <Navigium> (ah, and I should mention, it should be a desktop app that can be used by teachers. So running a SQL server it a no-go
07:36:56 <xplat> boegel: yeah, how much memory does it allocate per edge for smaller graphs?
07:38:05 <boegel> xplat: hmm, not sure how to tell
07:38:21 <boegel> xplat: for ~100 nodes it's less than 120MB
07:38:24 <xplat> navigium: that's probably completely workable up to a few hundred students, depending how many exams
07:39:22 <kfr> Navigium: Well, there's sqlite
07:39:23 <Lemmih> Navigium: You might use CVS or JSON if you don't like read/show.
07:39:25 <kfr> For light weight stuff
07:39:37 <Navigium> xplat: you mean with show and read? It should be a personal administration tool for teachers. So I don't think anyone uses it on more than a few hundert students..
07:39:48 <kfr> Lemmih: Don't you mean CSV? :p
07:40:17 <Lemmih> kfr: Err, yes.
07:40:27 <xplat> duairc: kfr and myself are 'ones'
07:40:29 <Navigium> kfr: is there some useable sqllite-wrapper for haskell?
07:41:07 <kfr> Navigium: Possibly, I don't know honestly
07:42:22 <Navigium> kfr: well.. there is one. But I don't know anything about its quality ;)
07:43:16 <ricree> Navigium: I've used Database.HDBC.Sqlite3 a bit.  Didn't seem that bad
07:43:19 <boegel> hmm, seems like the PatriciaTree representation of graphs is a lot more memory-efficient...
07:44:31 <xplat> Navigium: yes, i mean with show and read ... up to a few hundred students, one user per installation it should work plenty well
07:45:26 <Navigium> ricree: thanx. That one looks better than Database.SQLite
07:45:29 <xplat> opening a window will create more startup delay than reading the file
07:46:06 <Navigium> xplat: I think I'll give it a try then. After all it's the easiest way to code it.. 
07:47:05 <xplat> just remember to always write to a temporary name, move old file to backup name, then move temporary name to real name, when you save
07:48:37 <Navigium> isn't it enough to move the file to backup name and then save to real name?
07:49:44 <xplat> navigium: not in my experience
07:51:13 <Navigium> then I'll trust your experience, I'm sure you've got more of it than I do...
07:55:29 <revenantphx> Bynbo7: 
07:55:37 <revenantphx> I tried with --extra-lib-dirs, and no such luck.
08:02:35 <revenantphx> aha!
08:02:39 <revenantphx> I found the issue I think Bynbo7.
08:02:45 <revenantphx> My installation of LLVM is 64bit.
08:03:16 <revenantphx> I could theoretically edit the autoconf script to force it to use 64bit...
08:03:23 <revenantphx> but I worry it would break with 32bit ghc/ghci then
08:03:42 <hape01> Navigium: When I had a look at yesod Web framework, I've seen the use of sqlite+persistent
08:07:05 <xplat> i would complain about all the issues in the 64/32 bit transition, but i still remember the 8/16 data register transition and the 16/32 transition and this is nothing
08:07:34 <xplat> first time we threw out all our computers and rewrote our software
08:08:50 <xplat> second time, at least kept the same architecture, but had to handle moving to multitasking and memory protection at the same time, ouch
08:09:27 * hackagebot citeproc-hs 0.3.2 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.2 (AndreaRossato)
08:13:15 <EvanR-work> is there a more standarder type for Either a a, or (a,Bool) or something?
08:13:36 <roconnor> EvanR-work: not that I'm aware of
08:13:57 <kmc> is there a good way to create (Ptr CFile) values in Haskell code?
08:18:19 <Guest41119> EvanR-work: for me that mostly comes up in the form of something like data Foo a = ThisKind a | TheOtherKind a
08:18:57 <EvanR-work> Guest41119: right
08:19:08 <EvanR-work> in this case, Checked | Unchecked
08:19:57 <quicksilver> EvanR-work: I think I would go for: data State = Checked | Unchecked; type Foo a = (State,a);
08:20:00 <kmc> the problem there is that you'll often be wanting a function like f (ThisKind x) = x; f (OtherKind x) = x
08:20:07 <kmc> i mean it depends
08:20:13 <quicksilver> EvanR-work: that gets you access to 'fmap' and 'snd' on the a
08:20:21 <kmc> if it's only an accident of implementation that the two x'es have the same type, then it makes sense to have two ctors
08:20:24 <quicksilver> EvanR-work: and you still get your own custom type for the checked/unchecked part.
08:20:39 <kmc> if they're logically the same sort of value with an extra bit attached, then a product makes more sense than a sum
08:20:57 <EvanR-work> ah
08:21:06 <EvanR-work> (a,Bool)
08:21:09 <quicksilver> one of the trade-offs is between type safety (fresh types) and re-use of existing combinators.
08:21:15 <quicksilver> no, (Bool,a) :)
08:21:18 <accel> is ghc / haskell usable with only 2GB of RAM ?
08:21:19 <quicksilver> you want 'fmap' to work.
08:21:22 <quicksilver> or you probably do.
08:21:30 <quicksilver> accel: sure.
08:21:31 <ion> accel: What? :-D
08:21:37 <accel> 2GB for entire machine
08:21:43 <accel> i.e. part of it will be used up by kernel / ubuntu
08:21:44 <EvanR-work> the data is clear now
08:21:46 <EvanR-work> (tm)
08:21:46 <quicksilver> I had a 1G machine until quite recently, it's fine.
08:22:02 <ion> I love how people can come up with the phrase “only 2 GB of RAM” these days.
08:22:08 <quicksilver> and I've run small haskell programs in a 256MB VM
08:22:12 <accel> my desktop has 16GB
08:22:21 <jmcarthur> there are some projects where that's not enough memory, but it takes... special circumstances
08:22:21 <accel> well, not quite 16, but > 8
08:22:34 <jmcarthur> for ghc, that is
08:22:41 <yitz> i have a machine with 192 MB of RAM running debian etch. ghc 6.8.2 works fine there.
08:22:46 <accel> okay; maybe i heard incorrectly, I thought ghc was a memory hog
08:22:48 <accel> during compilation
08:22:58 <accel> and haskell progs tend to gobble up memory like pacman eats dots
08:23:04 <jmcarthur> the biggest problem with memory is *usually* ld, not ghc
08:23:14 <tibbe> accel, did you have a performance problem earlier today?
08:23:28 <accel> tibbe: I had problems running the GLUT example of the brick GLSL shader
08:23:35 <tibbe> accel, I see
08:23:40 <jmcarthur> well, it's common for beginners to introduce space leaks, which i think contributes to haskell's misplaced reputation for being a memory hog
08:24:06 <accel> jmcarthur: yeah; so many innocent things become memory leaks
08:24:16 <jmcarthur> they aren't so innocent once you get used to it
08:24:23 <accel> ! is my new best friend
08:24:30 <ClaudiusMaximus> on x86 with 256MB ram running squeeze, i couldn't "cabal install cabal-install" until i "aptitude install binutils-gold", after that it worked ok
08:24:42 <xplat> when you stop being a haskell n00b it doesn't use more memory than perl or python, say
08:24:48 <jmcarthur> accel: don't overuse it
08:25:00 <accel> jmcarthur: I still don't understand when ! will cause duplicate calculation
08:25:03 <jmcarthur> accel: you can introduce even more space leaks with it if you don't know what you're doing
08:25:05 <accel> i.e. why eosn't haskell cache the results of a !
08:25:06 <dcoutts> ClaudiusMaximus: interesting, perhaps gold uses a lot less memory than ordinary gnu ld
08:25:11 <jmcarthur> huh?
08:25:19 <accel> better question to ask is this:
08:25:28 <accel> in scheme, I can visualize the execution in terms of cons cells
08:25:32 <jmcarthur> it will never cause duplicate calculation
08:25:33 <ClaudiusMaximus> dcoutts: yes, in a rough test (watching 'top') it was 80MB vs 330MB
08:25:36 <accel> in haskell, how do I visualize what's strict & what's lazy ?
08:25:44 <dcoutts> ClaudiusMaximus: great
08:26:21 <jmcarthur> accel: a function f is strict if f undefined = undefined
08:26:41 <jmcarthur> accel: that's not exactly what you're looking for i think, but it's how you know if a function is strict
08:27:26 <jmcarthur> accel: i'm not completely sure what it is that you mean to ask though
08:27:32 <quicksilver> dcoutts: yes, gold uses much MUCH less memory.
08:27:40 <jmcarthur> accel: are you just wanting to know more about the execution model?
08:27:49 <quicksilver> dcoutts: and it's much faster, too. (probably partly for the same reason)
08:27:55 <EvanR-work> weak head normal form is your friend
08:28:10 <accel> jmcarthur: I want to know more about the execution model
08:28:12 <dcoutts> quicksilver: right, I'd heard about the speed but not about the memory use
08:28:23 <accel> jmcarthur: I want to be able to look at a piece of haskell code; and visualize mentally how the code executes
08:28:57 <jmcarthur> accel: if so, the basic idea is that bound variables are not evaluated unless you force them somehow, and strict (which is the default) pattern matching will force variables
08:29:06 <quicksilver> dcoutts: manatee is a big fan because, for whatever reason, manatee takes absurd amounts of memory to link
08:29:22 <accel> jmcarthur: where does it state that 'pattern matching forces evaluation' ?
08:29:28 <accel> jmcarthur: this is new to me
08:29:36 <jmcarthur> it may not be a part of the spec. it might just be ghc
08:29:41 <jmcarthur> i'm not sure exactly
08:29:42 <dcoutts> quicksilver: probably due to using most of gtk2hs :-)
08:29:56 <jmcarthur> i think it's in the spec though... lemme check
08:29:58 <EvanR-work> a case expression is not in WHNF?
08:30:26 <jix> accel: how can you match a value without first evaluating it?
08:30:37 <jmcarthur> EvanR-work: if you need to result of a case expression then it forces whatever constructors are necessary to match the pattern
08:30:39 <accel> jix: I have no idea; but haskell is full of balck magic
08:30:41 <jix> accel: just binding a value doesn't force it
08:30:49 <dcoutts> quicksilver: splitobjs on big packages is the worst case for ld really
08:30:49 <jmcarthur> none of it is black magic
08:30:56 <jix> accel: but if you match it against a constructor it will be forced
08:30:58 <accel> it's black magic until I understand it
08:31:06 <accel> jix: can you give me code example?
08:31:11 <accel> sorry, i'm a haskell nowb
08:31:15 <EvanR-work> jmcarthur: like, i ask you to 'evaluate the case' then that means evaluate just enough of the inner expr to get the constructor?
08:31:16 <accel> and although what you say kinda makes sense
08:31:28 <accel> if I can see different pieces of code, one which is lazy, one which is strict
08:31:30 <accel> it'd be enlightening
08:31:33 * hackagebot web-routes-quasi 0.6.3.1 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.3.1 (MichaelSnoyman)
08:31:39 <quicksilver> dcoutts: *nod*
08:32:00 <EvanR-work> accel: arithmetic is strict, IO is strict, strict patterns are strict...
08:32:16 <jmcarthur> accel: it's in the spec http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
08:32:16 <jix> accel: f (a,b) = [a,b] -- here forcing the return value of f (1,2) will force the pair, but not the values inside the pair
08:32:38 <EvanR-work> strict constructors are strict
08:32:47 <EvanR-work> the !
08:33:16 <accel> jmcarthur: thanks; reading
08:33:25 <jmcarthur> it's kind of dense, as it's a spec
08:33:30 <xplat> strict constructor is strict
08:33:38 <jmcarthur> accel: read the informal semantics section, mainly
08:34:13 <quicksilver> accel: you have a cognitive mismatch.
08:34:21 <quicksilver> accel: "two pieces of code, one which is lazy one which is strict"
08:34:34 <quicksilver> a piece of code won't be lazy or strict in a global way like that.
08:34:34 <accel> quicksilver: err, one which forces , and one which does not
08:35:03 <jmcarthur> > case undefined of (_,_) -> "foo"
08:35:04 <lambdabot>   "*Exception: Prelude.undefined
08:35:07 <jmcarthur> > case undefined of ~(_,_) -> "foo"
08:35:08 <lambdabot>   "foo"
08:35:18 <jmcarthur> the first forces it and the second doesn't
08:35:21 <xplat> quicksilver: but there is a certain amount of that, for example you often read in haskell forums things like 'function f is too strict' or 'function f is too lazy'
08:35:48 <jmcarthur> that's pretty bad terminology, perhaps
08:36:17 <jmcarthur> not sure what else to say though, right now
08:37:23 <accel> jmcarthur: thanks 
08:37:49 <quicksilver> xplat: yes, you see people say it, (including me, probably), but it's not good terminology and not a good starting point for comprehension.
08:38:14 <quicksilver> xplat: especially since lazy is not supposed to be the opposite of strict (that's non-strict)
08:44:50 <jix> ouch you are allowed to match against floating point literals?
08:45:15 <jix> > case 1 - 0.9 of 0.1 -> "lol"
08:45:15 <lambdabot>   "*Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
08:46:14 <dcoutts> > 1 - 0.9 == 0.1
08:46:15 <lambdabot>   False
08:46:23 <dcoutts> jix: not so surprising
08:47:09 <jix> yeah the result isn't surprising and exactly that makes it surprising that you are allowed to match against fp literals
08:47:21 <dcoutts> jix: if you want to ban pattern matching on floats, then you probably also want to ban ==
08:47:38 <dcoutts> but == on floats is still useful in certain cases
08:47:46 <jix> dcoutts: == has a valid use, == with a literal not that much
08:48:32 <jix> but yeah as it's a builtin type and there is no other way to destruct it it's probably just consistent
08:49:00 <kmc> what's the valid use of == on non-literals?
08:49:29 <kmc> i think (== 0) on floats is pretty legit
08:49:36 <kmc> of course easily misused by the clueless
08:49:43 <zygoloid> there's nothing wrong with pattern matching against Floats (or indeed == on them) so long as you know what it /means/
08:50:23 <kmc> > 1 - 0.9
08:50:24 <lambdabot>   9.999999999999998e-2
08:51:06 <xplat> you could have a class that uses FP literals but doesn't have rounding errors
08:51:22 <kmc> yeah, the FP literals aren't floating point at all -- they're Rationals
08:51:35 * kmc wonders if GHC Haskell's Double on 32-bit x86 is 64-bit IEEE or 80-bit x87 extended precision
08:51:39 <jix> xplat: but you can't use pattern matching on those, can you?
08:51:40 <quicksilver> > 1 - 0.9 == 0.1 :: Rational
08:51:41 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
08:51:41 <lambdabot>         against inferred t...
08:51:42 <xplat> i guess not for a full implementation including trig functions, but in practice people let unimplemented transcendentals go
08:51:54 <quicksilver> > 1 - 0.9 == (0.1 :: Rational)
08:51:55 <lambdabot>   True
08:52:14 <quicksilver> > case 1 - 0.9 of (0.1 :: Rational) -> "lol"
08:52:15 <lambdabot>   "lol"
08:52:25 <jix> oh
08:52:26 <Jonno_FTW> :t Left
08:52:27 <lambdabot> forall a b. a -> Either a b
08:52:38 <quicksilver> kmc: on old GHCs, 64 bit most of hte time with smatterings of 80-bit
08:52:39 <Jonno_FTW> :t Right
08:52:40 <kmc> there were recently some embarrassing PHP and JVM bugs related to x87 excess precision
08:52:40 <lambdabot> forall b a. b -> Either a b
08:53:01 <kmc> quicksilver, that's what i'm afraid of -- the exact results depend on how the compiler optimizes your code
08:53:30 <xplat> heh, that's right ... floating literals are in Fractional and not Floating anyway, so my waffling doesn't even apply
08:54:02 <kmc> this is always true of floatingpoint with sufficiently aggressive optimizations, but on the x87 the optimization "make use of the FPU's registersC is sufficient to cause such behavior
08:54:10 <kmc> s/C/"/
08:54:35 <quicksilver> kmc: on GHC 7 I *think* they ditched it in favour of using the SSE registers everywhere.
08:55:23 <quicksilver> kmc: well, it used to not be a problem with the -fvia-C backend because that used GCC which, by default, clips to 64 bit everywhere.
08:55:45 <quicksilver> kmc: it only became a problem when that native codegen became default (6.8 or 6.10, I don't remember)
08:55:51 <zygoloid> kmc: in our codebase we turn off x87 extended precision and don't have any problems :)
08:56:36 <kmc> zygoloid, by setting the FPU control word?
08:56:55 <kmc> quicksilver, does that mean GHC 7 code won't run on chips that don't support SSE2?
08:57:01 <zygoloid> kmc: asm ("fnstcw %0" : "=m" (*&cw)); cw &= ~0x300; cw |= 0x200; asm ("fldcw %0" : : "m" (*&cw));
08:57:12 <zygoloid> (ick)
08:57:35 <quicksilver> kmc: I think so, yes.
08:57:40 <kmc> istr seeing a function that does that zygoloid
08:57:43 <kmc> somewhere in glibc
08:57:44 <kmc> shrug
08:57:53 <quicksilver> kmc: unless you choose a different backend, I guess.
08:57:58 <quicksilver> via-C or llvm.
08:58:05 <kmc> interesting
08:58:08 <quicksilver> kmc: I could be wrong about the whole thing ;)
08:58:13 <kmc> SSE2 is not that old
08:58:58 <quicksilver> 10 year is fairly old for a computer.
08:59:06 <zygoloid> kmc: yeah, in fpu_control.h. we don't use it because it's not available on x86 solaris :D
08:59:10 <kmc> haha
08:59:19 <kmc> inline asm is available on every OS ;)
08:59:43 <kmc> also (*&cw) ?
08:59:46 <zygoloid> (we stopped supporting solaris 4 years ago but its legacy lives on!)
09:00:12 <zygoloid> *shrug* i don't understand gcc's inline asm stuff, i /guess/ there's a reason for that :)
09:00:46 <systemfault> Because GCC can't do anything right.
09:03:47 <shachaf> zygoloid: It doesn't work without it?
09:04:54 <kmc> you should also use asm volatile to avoid the fldcw being reordered around a fpu op hurf durf
09:06:08 <shachaf> kmc: I encountered that issue a few days ago.
09:06:16 <shachaf> Rather annoying.
09:07:46 <shachaf> asm volatile doesn't have any effect for a top-level block, though, right?
09:09:06 <kmc> dunno
09:11:29 <navaati> hi
09:11:46 <kmc> hi navaati
09:13:42 <navaati> does anyone here play with the jack audio connection kit ? i can't make the binding work
09:16:38 <elliott> What can I do to get an unGetChar?
09:20:12 <accel> has anyone written an ipad app in  haskell?
09:21:12 <kmc> not to my knowledge, but there is a port of GHC to target iOS
09:21:23 <kmc> it lived at http://projects.haskell.org/ghc-iphone/ but that's down now, i hope temporarily
09:21:47 <Jesin> hm
09:21:56 <Jesin> I wonder if there's a port of LLVM for iOS?
09:22:29 <kmc> i expect so -- clang is Apple's pet compiler project, and uses LLVM
09:22:50 <Jesin> yaaaay
09:22:52 <kmc> LLVM mostly doesn't care about your OS though, unless you mean running the LLVM tools themselves on iOS
09:23:12 <Jesin> so, with the LLVM backend for GHC
09:23:14 <kmc> if your OS provides a C syscall ABI, you can call that stuff through LLVM
09:23:24 <Jesin> wouldn't that give us an iOS port of GHC basically for free?
09:23:34 <kmc> no
09:23:40 <Jesin> k
09:23:43 <Jesin> I'm new at this :
09:23:45 <Jesin> *:p
09:24:01 <Jesin> well, I mean
09:24:14 <kmc> GHC cares about architecture-specific and OS-specific stuff
09:24:16 <Jesin> besides IO libraries
09:24:18 <kmc> LLVM doesn't attempt to hide those at all
09:24:26 <Jesin> right
09:24:29 <Jesin> k
09:24:48 <kmc> you're right that LLVM makes it easier though, especially if you want good performance
09:25:19 <kmc> because GHC's "portable C" output mode, while not totally portable, is also 2x slower than "registerized C", native code output, or LLVM
09:25:32 <kmc> brbm
09:25:45 <Jesin> right, ok
09:27:24 <quicksilver> yeah, llvm makes it much easier but as far as I know no attempt has been made that way
09:27:44 <quicksilver> the ghc-iphone stuff is via the portable C kmc refers to.
09:27:55 <dagle> Would apple ever allow haskell on iphone anyway?
09:29:17 <c_wraith> They already do
09:29:28 <Jesin> I don't see why they would forbid it
09:29:29 <Jesin> :p
09:29:43 <c_wraith> The current developer license is "you can use any source language, so long as you don't download code"
09:29:48 <Jesin> they might not actively work to make it easy or keep it easy
09:29:52 <Jesin> but yeah
09:30:01 <c_wraith> The previous developer license *did* forbid using haskell
09:30:04 <zygoloid> so no internet-connected lisp then? ;)
09:30:10 <shachaf> "Don't run downloaded code", presumably?
09:30:16 <c_wraith> well, yes
09:30:18 <dagle> c_wraith: by that they mean it have to be compiled?
09:30:24 <shachaf> That's pretty vague. At what point does something stop being data and start being code?
09:30:25 <c_wraith> dagle: not necessarily.
09:30:31 <Jesin> [12:49:43]	<c_wraith>	The previous developer license *did* forbid using haskell
09:30:42 <Jesin> it basically only allowed ObjC, or some such?
09:30:51 <c_wraith> well, it was 3 languages, but yeah
09:31:18 <Twey> What were the other two?
09:31:46 <shachaf> The fact that Logo-for-the-iPhoo isn't allowed is somewhat sad.
09:31:50 <c_wraith> I don't remember.  there should be many angry blog posts about it if you want to look it up
09:32:25 <copumpkin> kmc: still interested in SMT? :P
09:32:27 <elliott> iPhooooooooo
09:32:42 * copumpkin whores out the new SMT channel some more
09:33:01 <zygoloid> copumpkin: SMT?
09:33:03 <c_wraith> what does SMT stand for today?
09:33:09 <copumpkin> satisfiability modulo theories
09:33:14 <copumpkin> SAT on steroids
09:33:16 <zygoloid> Symmetric Manganese Toasters
09:33:17 <c_wraith> ah.  like an SMT-solver
09:33:19 <FunctorSalad> . o O ( preimage calculator for ghc ABI hashes )
09:33:37 <copumpkin> ##smt if you're interested
09:34:20 <FunctorSalad> (you know, if you accidentally reinstalled a builtin package, breaking everything, and need to rereinstall it with the original configuration... I never seem to achieve that)
09:45:29 <kmc> copumpkin, yes plz
09:46:33 <kmc> no, the current iphone developer license is "we can reject your app at any time for any or no reason"
09:46:53 <kmc> whatever "rules" apple gives are neither necessary nor sufficient for approval
09:47:07 <dagle> "we can't read haskell, let's reject it"
09:47:18 <kmc> they don't get source iirc
09:47:27 <kmc> anyway you could give them the C output of GHC
09:47:31 <Jesin> lol
09:47:34 <kmc> that's a lot more readable ;)
09:47:38 <dagle> ;)
09:47:41 <Jesin> that is an awesome solution
09:47:43 <Jesin> :p
09:48:18 <Jesin> hmm, doesn't GHC use some GCC-specific extensions?
09:48:25 <kmc> not in "unregisterized" mode
09:49:17 <kmc> in registerized mode it uses some GCC extensions (such as pinning global variables to registers) as well as a postprocessing step on GCC's assembly output (to eliminate C function preludes and implement tail calls)
09:49:25 <kmc> the latter is accomplished by a Perl script known as the Evil Mangler
09:50:07 <Jesin> hmm, k
09:50:18 <Jesin> ...
09:50:22 <Jesin> wow
09:50:34 <kmc> oh, and for implementing tables-next-to-code
09:50:38 <kmc> which is another important optimization
09:50:38 <Jesin> I heard something about perl
09:50:42 <Jesin> I didn't hear it had a name
09:51:01 <Jesin> and yeah that's apparently one thing LLVM does not support as of May 2010
09:51:05 <kmc> yeah
09:51:11 <jmcarthur> the evil mangler is basically on its way out now that the C backend is deprecated though, right?
09:51:12 <Jesin> does it now?
09:51:13 <kmc> i think they hacked it in, with a (much smaller, less evil) mangler
09:51:25 <Jesin> k
09:51:35 <kmc> the appeal of LLVM is largely to do the same things as registerized via-C in a much cleaner way
09:52:29 <Jesin> that optimization could be useful in other languages too, though, couldn't it?
09:52:39 <kmc> i'd think so
09:52:41 <Jesin> haskell would tend to have more function calls than average I expect
09:52:43 <Jesin> but
09:52:44 <Jesin> yeah
09:52:49 <kmc> which one?
09:52:51 <kmc> tables next to code?
09:52:56 <Jesin> ^ that
09:53:30 <Jesin> brb
09:53:31 <kmc> one issue is that it's not portable to Harvard architectures
09:53:34 <kmc> but it's arguable that nobody cares
09:53:43 <kmc> even AVR lets you put read-only tables in code storage
09:53:46 <Jesin> I dunno what a harvard architecture is
09:54:10 <kmc> code and data in separate address spaces
09:54:18 <Jesin> and, couldn't LLVM just ignore that option on those architectures?  :p
09:54:27 <kmc> yeah or not support it
09:55:25 <kmc> each dynamic object in the GHC heap has a pointer to an "info table", which is a static read-only table, roughly one per data type constructor and one per lambda
09:56:10 <kmc> that table has various metadata needed for evaluation and garbage collection but by far the most commonly accessed field is the pointer to the "entry code" for values of that sort
09:56:28 <kmc> which code gets called whenever the value is evaluated or pattern-matched, roughly
09:57:29 <kmc> so rather than dereferencing an info pointer and then an entry pointer, let's point directly to the entry function and put the info table (of known size) right before it
09:57:38 <kmc> saving an indirection on every evaluation
09:57:42 <kmc> that's table next to code
10:02:49 <zygoloid> for extra fun, the table isn't a fixed size :)
10:03:40 <kmc> oh?
10:03:50 <kmc> does it end with a "length" field or something?
10:04:02 <zygoloid> no, in tables-next-to-code mode, the new fields go at the start :)
10:04:10 <kmc> heh
10:04:13 <zygoloid> (and some of the fields turn from being pointers into being offsets)
10:04:19 <kmc> ok
10:04:39 <zygoloid> it's a "barrel of laughs" writing code which can understand the memory layout :)
10:06:27 <c_wraith> Oh, right.  You were working on code that could examine the haskell heap at runtime, weren't you?
10:06:43 <c_wraith> err, s/haskell/GHC/
10:06:57 <zygoloid> yeah. fun times :)
10:07:47 <kmc> oh, you were working on Hades weren't you?
10:08:34 <kmc> i was learning how to use ptrace and wanted to write some haskell tools
10:08:36 <c_wraith> Uh.  control.monad.st.  That's your blog, isn't it?  :)
10:08:40 <kmc> nothing nearly so cool or ambitious though
10:08:43 <c_wraith> I'm putting things together now :)
10:08:57 <kmc> was going to start with a breakpoint-based live profiler
10:09:16 <kmc> "in the past 10 seconds, what sorts of closures did my program force"
10:10:58 <c_wraith> I still want an extension of vacuum that will allow examining the values being retained by closures in unforced thunks
10:11:22 <zygoloid> c_wraith: then hades is the lib for you :)
10:11:28 <c_wraith> zygoloid: sweet :)
10:11:30 <zygoloid> (some restrictions may apply)
10:11:50 <kmc> offer void where prohibited
10:12:21 <zygoloid> your process is at risk if you do ... anything with hades right now :)
10:13:01 <c_wraith> anything?  It has no "examine without totally breaking" mode? :)
10:13:31 <roconnor> everytime I write a Haskell paper that talks about monads do I have to cite Wadler?
10:13:40 <zygoloid> c_wraith: it has no "now is a /really bad time/ to perform a GC" mode
10:14:11 <xplat> huh, so the current iOS dev license forbids writing a web browser
10:14:22 <c_wraith> roconnor: depends on if the people reviewing your paper are deciding based on the length of your citation list
10:14:34 <c_wraith> xplat: indeed.  executing javascript downloaded from the web is forbidden
10:15:16 <roconnor> c_wraith: I'm going to submit this to ICFP
10:15:40 <zygoloid> i suspect ICFP have heard of monads before ;)
10:15:53 <c_wraith> Wait, what is nomadic programming?
10:15:57 <copumpkin> roconnor: and moggi, and mac lane, and lawvere, while you're at it
10:16:07 <c_wraith> Is that when you take your laptop and wander from coffee shop to coffee shop?
10:16:23 <roconnor> copumpkin: people can find those via transitivity
10:16:47 <copumpkin> roconnor: nah, bibliographies should contain the whole transitive closure
10:17:03 <copumpkin> :)
10:17:13 <c_wraith> What paper is the root of the graph?
10:17:13 * zygoloid just hopes no-one invents time travel or that could get messy
10:17:14 <roconnor> clearly
10:17:27 <c_wraith> I'm assuming there's a single root to the entire field of computer science :)
10:17:44 <c_wraith> Euclid's Elements?
10:17:44 <kmc> when you talk about monads you should cite leibniz
10:18:30 <kmc> zygoloid, so when Hades performs a GC in its own heap, this can harm the traced process?
10:18:57 <roconnor> @type (=<<)
10:18:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:19:25 <c_wraith> At least the type of (=<<) makes the order of effects clear, in the cases where it matters.
10:19:30 <c_wraith> :t (<<)
10:19:31 <lambdabot> Not in scope: `<<'
10:19:49 <c_wraith> heh.  (<<) would be ambiguous.  Is it <* or flip (>>) ?
10:20:48 <Jesin> they should be equivalent
10:20:56 <Jesin> but we have a weird hierarchy
10:21:05 <Jesin> :t (<*)
10:21:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
10:21:10 <Jesin> :t flip (>>)
10:21:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
10:21:42 <Jesin> ...wait
10:21:46 <Jesin> or is the sequencing wrong
10:21:49 <Jesin> =/
10:22:02 <kmc> flip (>>) performs the right action first
10:22:08 <xplat> yeah, it's the sequencing
10:22:08 <kmc> (<*) performs the left action first
10:22:16 <revenantphx> Hey Bynbo7 
10:22:20 <revenantphx> could you help me out here?
10:22:34 <revenantphx> I really just can't figure out the issue >_<
10:22:56 <kmc> it does bug me that function composition goes RTL and most monadic combinators go LTR, but people seem not to like code that's full of (=<<) or (>>>)
10:23:20 <roconnor> kmc: I think function application is backwards
10:23:34 <kulakowski> roconnor: yes!
10:23:55 <copumpkin> zygoloid: did you have a different username on IRC a while back? or have you always been zygoloid?
10:24:08 <copumpkin> I vaguely remember you saying zygoloid was some transformation of something else
10:25:18 <kmc> roconnor, i took a math course from a professor who wrote "xf" instead of "f(x)"
10:25:25 <kmc> in an attempt to fix this
10:25:35 <Jesin> lol, yaaay
10:25:36 <Jesin> :p
10:25:53 <Jesin> it would make sections nicer
10:25:55 <revenantphx> Where woudl I find this bryan o'sullivan fellow.
10:26:02 <Jesin> ...no wait it wouldn't
10:26:04 <revenantphx> To get him to fix his autoconf.
10:26:08 <roconnor> kmc: that must of been nausiating
10:26:15 <kmc> shrug
10:26:30 <kulakowski> kmc: What did they teach?
10:26:34 <kmc> i don't mind doing things differently for the sake of doing them better
10:26:35 <revenantphx> After so much haskell function application,
10:26:40 <kmc> that's why i learned Haskell ;P
10:26:41 <revenantphx> I see z(x,y) as z (x,y)
10:26:43 <kmc> kulakowski, algebra
10:26:50 <kmc> hehe revenantphx
10:26:53 <kmc> it kind of is, though
10:26:57 <Jesin> ^ that
10:26:58 <revenantphx> yeha.
10:27:01 <Jesin> really
10:27:07 <revenantphx> And then all of a sudden, cartesian products.
10:27:10 <revenantphx> out of nowhere.
10:27:18 <xplat> they're isomorphic in the usual categories, anyway
10:27:18 <revenantphx> And then all preconceptions of what makes a function, shattered.
10:27:21 <revenantphx> blargh.
10:27:26 <revenantphx> anyways, fucking autoconf :(
10:27:34 <Jesin> A x A -> A is isomorphic to A -> A -> A
10:27:44 <Jesin> hmm
10:27:46 <Jesin> also
10:27:46 <kmc> not in Haskell, though
10:27:47 <Jesin> [13:47:02]	<revenantphx>	And then all preconceptions of what makes a function, shattered.
10:27:49 <Jesin> how?
10:27:58 <kmc> (A x A) has an extra bottom
10:27:58 <revenantphx> Well, I mean you think about it differently
10:28:16 <xplat> wait, that means Hask is not a CCC
10:28:21 <xplat> insanity!
10:28:25 <Jesin> CCC=?
10:28:29 <kmc> cartesian closed category
10:28:35 <revenantphx> I really wish someone would help with this llvm stuff.
10:28:41 <kmc> maybe they are isomorphic but not obviously so
10:28:55 <Jesin> "In category theory, a category is cartesian closed if, roughly speaking, any morphism defined on a product of two objects can be naturally identified with a morphism defined on one of the factors."
10:28:57 <Jesin> hmm
10:29:28 <kulakowski> Jesin: a CCC is a category in which currying makes sense
10:29:41 <Jesin> lol, ok :p
10:29:56 <kmc> also A -> (B -> C) has distinguishable values ⊥, (const ⊥), and (const $ const ⊥)
10:29:59 <kmc> stupid seq
10:30:00 <roconnor> Jesin: also, lambda terms can be interpreted in any CCC.
10:30:02 <Jesin> and... _|_ :: (a,b) ruins this?
10:30:16 <Jesin> umm
10:30:20 <Jesin> ⊥
10:30:21 <Jesin> ...
10:30:24 <Jesin> WHY
10:30:33 <Jesin> does my client display this as a "female" sign
10:30:38 <revenantphx> ø.ø
10:30:38 <Jesin> except when it's in the input box
10:30:40 <kmc> haha
10:30:45 <kmc> bad font or bad encoding?
10:30:46 <revenantphx> ß_ß
10:30:47 <xplat> jesin: you have a bad font
10:30:52 <Jesin> ...
10:30:56 <kmc> we speak UTF-8 round these parts
10:30:58 <Jesin> bottom = female >.<
10:31:05 <kmc> if UTF-8 was good enough for Jesus then it's good enough for #haskell
10:31:07 <Jesin> yeah, I thought this was set to UTF-8
10:31:09 <revenantphx> most good OS'es will switch a glyph to another font that has the character, if it can't find it.
10:31:09 <xplat> naughty font
10:31:10 <Jesin> my home computer is
10:31:27 <revenantphx> •-•
10:31:29 <roconnor> @src liftM
10:31:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:32:14 <xplat> @src liftA
10:32:15 <lambdabot> liftA f a = pure f <*> a
10:32:25 <Jesin> liftM f m = m >>= return . f
10:32:43 * roconnor wanted to double check the definition of liftW
10:33:18 <revenantphx> Okay, really.
10:33:25 <revenantphx> This llvm/cabal thing is ridiculous.
10:33:31 <revenantphx> someone must have seen something similar before.
10:33:44 <revenantphx> It can fidn the headers, but apparently it can't find a method when it links it in.
10:33:55 <revenantphx> Even though I can confirm gcc/g++ can find libLLVMCore just using -l
10:34:00 <revenantphx> doesn't even need -L
10:34:07 <kniu> Is there a version of !! that doesn't throw an exception?
10:34:07 <xplat> liftW f w = w =>> (f . extract)
10:34:08 <Jesin> :t \m1 m2 -> m1 >>= (`fmap` m2)
10:34:09 <lambdabot> forall (m :: * -> *) a b. (Functor m, Monad m) => m (a -> b) -> m a -> m b
10:34:11 <xplat> ?
10:34:11 <revenantphx> and the method is DEFINITELY in the header >:(
10:34:37 <ClaudiusMaximus> @hoogle safeAt
10:34:37 <lambdabot> No results found
10:34:53 <Jesin> ap m1 m2 = m1 >>= (`fmap` m2) -- wherever fmap = liftM, which it always should
10:34:58 <xplat> @hoogle Int -> [a] -> Maybe a
10:34:58 <lambdabot> Prelude (!!) :: [a] -> Int -> a
10:34:59 <lambdabot> Data.List (!!) :: [a] -> Int -> a
10:34:59 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
10:35:04 <shachaf> listToMaybe . drop n
10:35:17 <revenantphx> https://gist.github.com/816976
10:35:21 <zygoloid> kmc: the problem comes from trying to use hades in-process, ala vacuum. if it's in a separate heap and can pause the executing code (outside of the GC) then all should be ok
10:35:25 <revenantphx> please someone help me with this, it's ridiculosuly annoying.
10:35:25 <shachaf> revenantphx: Perhaps it's linking against another version of the library?
10:35:29 <revenantphx> And I know the solution should be simple.
10:35:39 <xplat> i'm surprised there isn't (!!?) or lookup or something 
10:35:52 <revenantphx> Only the brew installation exposes the lib.
10:35:58 <ClaudiusMaximus> kniu: http://hackage.haskell.org/packages/archive/safe/0.3/doc/html/Safe.html#v:atMay
10:35:58 <revenantphx> and its in /usr/local/lib
10:36:25 <revenantphx> I thought maybe it might be a 32/64 bit issue,
10:36:30 <revenantphx> that it just won't tell me about.
10:36:35 <revenantphx> Since my LLVM install is 64bit only.
10:36:40 <shachaf> revenantphx: You could strace it to see what it's actually using. :-)
10:36:48 <revenantphx> do teach me?
10:37:10 <zygoloid> > map (++zipWith ($) (cycle [pred.pred.pred, succ.succ.succ]) "lilac") ["co", "zygo"] -- copumpkin
10:37:11 <lambdabot>   ["coilid`","zygoilid`"]
10:37:26 <copumpkin> lol ok
10:37:26 <shachaf> strace -fo OUTPUT myprogram; vim output; /open
10:37:32 <copumpkin> preflex: seen lilac
10:37:33 <preflex>  lilac was last seen on #haskell 1 year, 87 days, 14 minutes and 58 seconds ago, saying: ksf: well, the C version uses evil such as: "Integer to float conversions are faster if the integer is signed"
10:38:23 <zygoloid> i assume that's re: the language shootout :)
10:39:02 <revenantphx> OS X has "dtrace"
10:39:05 <revenantphx> need to see how it differs
10:42:24 * ksf doesn't remember that conversation
10:42:51 <shachaf> revenantphx: Oh, you're using OS X.
10:42:54 <shachaf> That explains it.
10:42:58 <revenantphx> hm?
10:43:04 <shachaf> Apple is evil.
10:43:11 <revenantphx> >_>
10:43:27 <revenantphx> My install of LLVM is not from apple anyhow.
10:43:45 <revenantphx> now that you've venting about unrelated issue, how about helping to solve my problem :)?
10:44:00 <shachaf> dtrace isn't so evil, however. But it's not really the same thing.
10:44:05 <revenantphx> I'm looking at twhat's its opening here now.
10:44:14 <revenantphx> 'dtruss cabal install llvm' spits out a lot of stuff
10:44:21 <revenantphx> not sure what it is, not it calls dtrace it seems
10:45:49 <revenantphx> It's just spitting out all of the syscalls.
10:46:41 <revenantphx> it never even touches a lib/llvm or lib/llvm-c directory as far as I can see
10:49:25 <revenantphx> hackage has a failure log jsut like mine, but for ghc 6.10...
10:49:48 <revenantphx> I'm using 6.12 tho
10:49:57 <revenantphx> and thats for a much older version
10:51:28 <revenantphx> I really wish I could just have a 64 bit GHC 7
10:51:38 <revenantphx> So I can just not worry about 32/64 bit >_
10:52:35 <revenantphx> i'm going to install llvm from source manually forcing it to universal mode
10:54:12 <shachaf> revenantphx: Why can't you?
10:54:14 <kmc> zygoloid, oh, makes sense.  i didn't know it even supported in-process mode
10:54:27 <revenantphx> shachaf: OS X is still second tier platform, it's not pariticularly stable or nice.
10:54:33 <revenantphx> Plus, I don't want to break ghc-pkg again.
10:54:39 <revenantphx> It's something to try later I suppose.
10:54:54 * shachaf agrees about OS X being a second-tier platform.
10:54:58 <shachaf> (Ahem.)
10:54:59 <revenantphx> >_>
10:55:08 <c_wraith> What's that make windows?  fifth-tier?
10:55:40 <revenantphx> there's a prebuilt GHC 7.0.1 i386
10:55:44 <revenantphx> but I'd like x86_64
10:55:55 <shachaf> revenantphx: Oh, they do have 64-bit packages.
10:56:03 <revenantphx> Ah you're right.
10:56:05 <shachaf> "community supported"
10:56:06 <revenantphx> I just found one.
10:56:09 <revenantphx> Mm yeah
10:56:21 <revenantphx> who sounds more trustworthy
10:56:23 <monochrom> my ipod touch is my 1st-tier platform. all other platforms tie as 2nd-tier platforms.
10:56:30 <revenantphx> Gregory Wright, or Christian Maeder
10:56:34 <revenantphx> monochrom: wut lol?
10:56:56 <monochrom> trying to say that there can be ties.
10:57:37 <iliketomatos> when i have a case expression in an anonymous function, i get "Pattern syntax in expression context" - http://pastebin.com/a3xKcGEd
10:58:07 <shachaf> iliketomatos: You're missing a \.
10:58:20 <iliketomatos> oh. Thanks!
10:58:29 <monochrom> hackage "build status" is slowly becoming useless
11:00:58 <revenantphx> so, what're the downsides to using 64bit binaries?
11:01:12 <copumpkin> pointers take twice as much memory
11:01:19 <revenantphx> Well yeah, but you can have a lot more memory
11:01:20 <copumpkin> that's about it
11:01:25 <revenantphx> Since you can index higher.
11:02:02 <revenantphx> what's the address range of a 32 bit computer?
11:02:11 <revenantphx> ah 4GB
11:02:13 <monochrom> I can't use 64-bit when I am in a virtual machine since my CPU is castrated.
11:02:25 <revenantphx> so if I'm on this machine with 8GB of ram,
11:02:32 <revenantphx> can a 32bit binary ONLY use 4GB of it at most?
11:02:42 <revenantphx> Or does it have some sort of way to cheat?
11:02:46 <kfr> revenantphx: The problem is more complex than you think
11:02:51 <kfr> I suspect you are talking about an IA-32 CPU?
11:02:56 <revenantphx> I have no clue.
11:02:58 <revenantphx> :)
11:02:59 <kfr> And not just a generic 32-bit CPU?
11:03:34 <kfr> Now with IA-32 there is the PAE bit which essentially gives you another layer of address translation to go beyond 4 GiB
11:03:35 <olsner> a 32 bit comuter should have an address range from bit 0 to bit 31
11:03:45 <olsner> *computer
11:03:54 <zygoloid> revenantphx: it depends on the OS and the hardware :)
11:04:15 <kfr> However, in reality the operating system usually still limits to less than 4 GiB of usable address space, I think
11:04:21 <mrd> a 32-bit application can only address 32-bits of virtual memory.  however most operating systems reserve at least 1GB of virtual space for themselves.
11:04:29 <kfr> *still limits this
11:04:48 <revenantphx> I usually only have about 5GB of "free" physical memory
11:04:52 <kfr> Yeah, usually the upper 2 GiB or 1 GiB in such an address space are reserved for the kernel address space
11:04:56 <mrd> every application can have its own separate virtual space, but the OS reserves 1+ GB in every single space
11:04:56 <revenantphx> If I start running virtualized windows, it goes to 500MB.
11:05:07 <revenantphx> Since I allocate 2GB to windows, and parallels eats up plenty of its own
11:05:19 <revenantphx> llvm installing slowly in background >_>
11:05:23 <revenantphx> So in conclusion
11:05:26 <revenantphx> can we ditch 32bit yet?
11:05:27 <kfr> With the move from IA-32 to AMD64 this becomes even more complicated in some ways
11:05:38 <kfr> Since not all of the 64-bit are actually addressable on current hardware
11:05:45 <kfr> There's a "hole" in the middle
11:05:51 <revenantphx> so is AMD64 only for AMD processors?
11:05:52 <mrd> however, even 32-bit machines (IA-32) can have up to 36-bits of addressable physical memory (it's called PAE).  separate address spaces can be mapped to this physical memory in different ways.
11:05:57 <revenantphx> is there an IA-64?
11:06:09 <mrd> Itanium
11:06:09 <revenantphx> (and AMD32?_
11:06:13 <zygoloid> revenantphx: yeah, but we don't talk about it
11:06:14 <kfr> revenantphx: AMD64 was the original name of the architecture designed by AMD, it was then licensed by Intel
11:06:29 <kfr> And they basically marketed it as Intel EM64T and now Intel 64
11:06:34 <kfr> But Intel 64 is essentially AMD64
11:06:39 <kfr> With some minor differences
11:06:54 <mrd> AMD64 = Intel 64 = EM64T = x86-64 = IA-32e mode
11:07:01 <mrd> it's a little nutty
11:07:28 <kfr> Well, they are not quite the same, their behaviour is different for some instructions, but for the most part they are identical, yeah
11:07:33 <zygoloid> of course, x86-32 has segments too, so a process can access rather a lot more than 4GB
11:07:33 <revenantphx> :O
11:07:42 <kfr> revenantphx: IA-64/Itanium is a completely different architecture unrelated to x86
11:07:48 <revenantphx> interesting
11:07:51 <revenantphx> anyhow
11:07:59 <kfr> It's an EPIC/VLIW inspired architecture
11:08:17 <kfr> But it was a commercial failure because they didn't manage to write good compilers for it, for one
11:08:31 <mrd> zygoloid: the linear address space is not larger than 4GB
11:08:52 <zygoloid> mrd: it is with PAE, isn't it?
11:09:05 <mrd> zygoloid: no, that's physical address space (what I mentioned above)
11:09:06 <zygoloid> or at least, you can address >4GB
11:10:22 <zygoloid> mrd: terminology abuse aside, a process can still access more than 4GB
11:10:22 <kfr> zygoloid: You don't even need segmentation for that, you could use all kinds of tricks to address more than that while still using the same virtual address space
11:10:32 <mrd> zygoloid: the only way you can access >4GB physical is to have the PML4 entries in the page directory structure
11:10:33 <kfr> Messing with the TLB and the page directory/tables etc
11:10:38 <revenantphx> Hrm, if I had some sort of hand in a "new" unix replacement (w/ some sort of brand new paradigm),
11:10:48 <revenantphx> I'd want package managing to be thoroughly built into the OS.
11:10:51 <zygoloid> kfr: sure, but it's easy to forget that x86 pointers are actually 48 bits wide in protected mode
11:10:53 <mrd> zygoloid: no actually the terminology is crucial, segmentation isn't what gets you there
11:10:53 <revenantphx> So it's really ... clean?
11:11:08 <burp> package managing build into OS and clean? o0
11:11:11 * hackagebot direct-fastcgi 1.0.3 - Native implementation of the FastCGI protocol.  http://hackage.haskell.org/package/direct-fastcgi-1.0.3 (DanKnapp)
11:11:12 <monochrom> there is no way this is more contrived than EMS.sys!
11:11:17 <kfr> zygoloid right
11:12:01 <kfr> revenantphx: That doesn't make much sense to me, that's a rather peripheral aspect
11:12:17 <kfr> Which doesn't require interaction with the kernel beyond the regular file system API
11:12:47 <kfr> But sure, proper package management is great
11:12:52 <kfr> It's one of the things I miss on Windows.
11:13:04 <burp> windows has surely build it into the kernel :P
11:13:12 <revenantphx> Part of the OS, not part of the kernel.
11:13:22 <revenantphx> windows has surely best OS in can into world.
11:13:25 <zygoloid> mrd: oh, i see, the LDT uses linear addresses :)
11:13:35 <mrd> zygoloid: there's a nice chart in 3.1 of manual 3A
11:14:38 <olsner> zygoloid: I think at best you could have 33-bit addresses in protected mode, if you imagine the cpu taking the base address and using the carry when adding your effective address to it
11:15:18 <olsner> but in reality, I'm pretty sure it rather wraps at 32 bits
11:15:49 <revenantphx> I need to learn this stuff.
11:16:12 <mrd> some OS designers do use effective address wraparound during boot before setting up page tables and such
11:17:01 <zygoloid> olsner: like an A33 analog of the A20 line mess?
11:17:14 <gwern> http://www.reddit.com/r/haskell_proposals/top/?t=all <-- it's really dead, isn't it?
11:17:26 <revenantphx> pffff
11:17:30 <kfr> gwern looks like it
11:17:39 <kfr> Use the LLVM backend to turn GHC into a cross-compiler (self.haskell_proposals) <- !!!!!!!!!
11:18:26 <gwern> kfr: does the current llvm backend already do that?
11:18:29 <kfr> Nope
11:18:34 <monochrom> PAE is kind of A20
11:18:42 <kfr> gwern: The bootstrapping process has been broken for close to two years now, too
11:18:55 <kfr> i.e. ghc hasn't been ported to new architectures in two years...?
11:19:05 <kfr> There isn't an AMD64 version for Windows lol
11:19:10 <kfr> In 2011 :/
11:20:48 <aristid> no bootstrapping? :/
11:21:56 <kfr> aristid yep
11:22:06 <kfr> And there still is no cross compiling either
11:22:10 <monochrom> byorgey++ haha cute stanza
11:22:22 <kfr> I'm honestly not sure what the ghc devs are currently aiming for
11:23:02 <xplat> i would build package management into the standard userspace, and some basic support for it into the filesystem
11:23:13 <kfr> Into the filesystem? What?
11:23:35 <xplat> well, making the filesystem transactional for one
11:24:03 <xplat> that already makes package management much cleaner/easier
11:24:42 <gwern> kfr: have you ever looked into NixOS?
11:24:52 <revenantphx> Oh hey, LLVM targets Cell SPU's
11:24:54 <revenantphx> neato.
11:24:54 <byorgey> monochrom: thanks =)
11:25:10 <olsner> zygoloid: heh, something like that
11:26:21 <kfr> gwern: I have not
11:26:45 <Twey> NixOS is neat
11:26:56 <kfr> xplat ah, I see
11:27:01 <Twey> It was going to be my current system, but they had some issues with locale
11:27:17 <Twey> I'm not sure I like how the package lists are distributed at the moment
11:28:58 <gwern> certainly are a lot of stale SoC tickets
11:30:34 <revenantphx> NixOS seems neat. Kind of what I was thinking of earlier.
11:30:53 <revenantphx> llvm's been compiling for 30-40 minutes now...
11:31:01 <revenantphx> I don't want to cancel it in the middle though D:
11:31:09 <revenantphx> I have to leave soon erp
11:31:21 <revenantphx> It already did the libs, its in tools...
11:31:22 * roconnor is running NixOS right now
11:31:25 <revenantphx> oh, unittests
11:31:26 <revenantphx> awesome.
11:32:00 <revenantphx> god these are slow
11:32:19 <monochrom> test is slow. let's go proving.
11:32:39 <revenantphx> test
11:32:42 <revenantphx> test's are slow you say?
11:32:44 <revenantphx> Prove it.
11:33:44 <revenantphx> hasn't even make install'd yet >_>
11:33:54 <shachaf> roconnor: NixOS is runnable?
11:34:00 <roconnor> yes
11:34:15 <Twey> Yeah
11:34:23 <roconnor> I've been running it since Oct 2009
11:34:47 <roconnor> on my laptop
11:35:08 <Gracenotes> @botsmack
11:35:08 <lambdabot> :)
11:35:13 <revenantphx> w00t finished
11:35:28 <roconnor> Gracenotes: lambdabot is into S-m-n
11:35:28 <revenantphx> gogogogo sudo make install
11:35:36 <revenantphx> cp cp cp cp cp cp....
11:35:49 <kfr> Yaay, child pornography
11:35:56 <revenantphx> cabal install now......
11:35:59 <revenantphx> WOT.
11:36:02 <revenantphx> :O
11:36:02 <monochrom> @bothack
11:36:02 <lambdabot> :)
11:36:03 <revenantphx> It worked
11:36:16 <revenantphx> Yay.
11:36:45 <revenantphx> So as far as I've seen, w/ the new calling convention, the only issues with LLVM as a haskell backend,
11:36:53 <revenantphx> are that one optimization in the function structs or something,
11:36:56 <revenantphx> and garbage collection.
11:37:03 <revenantphx> what're the stories there?
11:37:09 <monochrom> @batsack
11:37:09 <lambdabot> :)
11:37:21 <revenantphx> @ballsack
11:37:21 <lambdabot> Unknown command, try @list
11:37:28 <monochrom> edit distance of 2
11:37:30 <revenantphx> @bothack
11:37:31 <revenantphx> @botsack
11:37:31 <lambdabot> :)
11:37:31 <lambdabot> :)
11:37:36 <Twey> @botsmile
11:37:36 <lambdabot> Unknown command, try @list
11:37:42 <Twey> Heh
11:37:49 <gwern> ok, that's a little better. not sure some of the SoC tickets still need closing, but http://hackage.haskell.org/trac/summer-of-code/report/1 looks much more sensible
11:37:49 <Twey> It's just the auto-correct, huh
11:38:15 <Twey> ‘Priority: good’?
11:38:19 <monochrom> don't underestimate auto-correct
11:38:32 <monochrom>  @define becomes @undefine
11:38:40 <Twey> I thought they were usually things like ‘unimportant’, ‘major’, ‘blocker’, ‘ARGH MY HOUSE IS ON FIRE’
11:38:48 <Twey> This is unusually positive
11:38:50 <Twey> monochrom: Argh
11:39:29 <gwern> hah, most of the entries in the haskell SoC subreddit are so old I can't even reply to comments anymore
11:39:36 <monochrom> @ship monochrom
11:39:36 <lambdabot> Maybe you meant: show slap
11:39:37 <kfr> Maybe I should pretend to be 40 people and flood the mailing list/ghc trac with requests for LLVM cross compilation
11:39:45 <kfr> To cahnge their focus
11:39:47 <gwern> kfr: you mean http://www.reddit.com/r/haskell_proposals/comments/b7ol7/use_the_llvm_backend_to_turn_ghc_into_a/
11:39:50 <kfr> Screw fixing bugs
11:39:53 <monochrom> @slurp monochrom
11:39:53 <lambdabot> I don't perform such side effects on command!
11:39:58 <monochrom> hehe
11:40:24 <kfr> gwern hmm how big is the RTS?
11:40:30 <gwern> dunno
11:41:41 <chopin> hi, is there a fonction that return the number of the current line ?
11:42:40 <monochrom> only Control.Exception.assert does, but not return, rather print and exit.
11:42:58 <mrd> lines don't exist at run-time, it would need to be some kind of compiler macro or pragma
11:42:59 <kfr> chopin uhm you could use CPP for that I suppose
11:43:05 <chopin> i ll look at that thanks !
11:43:42 <mrd> gcc's CPP has a macro for it, dunno about the CPP ghc uses
11:44:19 * hackagebot fullstop 0.1.2 - Simple sentence segmenter  http://hackage.haskell.org/package/fullstop-0.1.2 (EricKow)
11:51:53 <elliott> Is there any package with data-accessor Accessors for lists?
12:10:41 <roconnor> elliott: that sounds error prone
12:10:54 <elliott> roconnor: But useful.
12:11:07 <roconnor> partial functions are never useful :P
12:11:54 <copumpkin> unless you really need to build the category of sets and partial functions, and can't think of what morphisms to use
12:12:39 <roconnor> copumpkin: total functions?
12:12:54 <copumpkin> then it wouldn't be the category of sets and partial functions!
12:12:54 <roconnor> that would be my first inclination of what to use
12:12:59 <roconnor> hmm
12:13:14 <copumpkin> it'd just be the category of sets and total functions
12:13:17 <roconnor> copumpkin: how about a Klelsi category.
12:13:28 <copumpkin> you mean on Maybe?
12:13:30 <roconnor> ya
12:13:38 <copumpkin> that's a roundabout way to go about it!
12:13:42 <roconnor> yay
12:13:43 <copumpkin> just apply spoon
12:17:22 <kmc> regarding CPP, i believe that __LINE__ is in the C standards, but also GHC's builtin CPP doesn't respect the C standard fully
12:17:54 <copumpkin> I've used __LINE__ in my GHC stuff I think
12:18:05 <kmc> when you really need a real CPP you can use {-# OPTIONS_GHC -pgmP /usr/bin/cpp #-} with obvious caveats
12:20:24 <roconnor> should I call a monad transformer a type constructor constructor, or is that just silly?
12:22:11 <pao> any news aboutn 7.0.2 and 2011 HP?
12:22:45 <jmcarthur> roconnor: i higher order type constructor?
12:22:46 <jmcarthur> *a
12:23:09 <xplat> configure: error: The OpenGL C library is required
12:23:28 <jmcarthur> yeah i really thing OpenGL doesn't belong in the platform
12:23:32 <jmcarthur> *think
12:23:47 <jmcarthur> that error is reported a lot
12:23:59 <roconnor> jmcarthur: thanks
12:24:11 <jmcarthur> i think you can arrange for it not to install opengl if you don't want it
12:24:24 <jmcarthur> roconnor: that was more of a speculative guess than a suggestion
12:25:24 <kmc> it's important to show that Haskell is usable not just for useless maths, but also for real-world tasks such as rendering teapots
12:26:03 <copumpkin> @remember kmc it's important to show that Haskell is usable not just for useless maths, but also for real-world tasks such as rendering teapots
12:26:03 <lambdabot> Done.
12:26:16 <roconnor> jmcarthur: I liked it
12:26:47 <dagle> kmc: And 3D lambdas. :)
12:27:42 <monochrom> see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml for the c libs required for building the haskell platform
12:28:48 <NemesisD> could someone take a look at http://hpaste.org/43791/single_io_argument I'm pretty new and i'm having some trouble with monadic arguments
12:29:57 <Botje> NemesisD: defaultConfig >>= execute m 
12:30:18 <Botje> NemesisD: although in this case I think you can cheat and do defaultConfig = unsafePerformIO $ do ...
12:30:38 <monochrom> don't need to cheat
12:31:03 <NemesisD> that function name is sufficiently scary for me to want to stay away from it
12:32:15 <monochrom> (defaultConfig >>= execute m) is also (do { c <- defaultConfig; execute m c }) if you want to view it that way.
12:32:36 <navaati> how can I make a programm pause his main thread forever ? System.Posix.Unistd.sleep (-1) doesn't work
12:32:42 <monochrom> the type of c there is Config
12:33:32 <NemesisD> ah >>=, the continual bane of my haskell existence
12:41:40 <xplat> there sure are a lot of warnings when building platform 2010
12:43:41 <xplat> i like >>=
12:43:58 <duairc> Can the CPP be used with GHC to define and expand macros in Haskell code? I've only ever seen it used for ifdefs and stuff like that
12:44:22 <Lemmih> duairc: yes.
12:44:37 <xplat> you could, but i think people prefer template haskell for that
12:45:32 <duairc> Does it do that by default? It keeps saying that the things which I want to be macros (which are uppercase) are data constructors. How do you tell it that, no, they're not, they're a macro you're supposed to be expanding?
12:46:30 <Lemmih> duairc: Enable the CPP extension with -XCPP or {-# LANGUAGE CPP #-}
12:46:39 <duairc> I've done that.
12:47:09 <duairc> Oh, actually maybe this is a different problem.
12:47:11 <duairc> Sorry, gimme a sec.
12:47:44 <harlekin> When running hsc2hs I get expected ; before ) token errors. Is this the header file or my .hsc file being wrong?
12:49:29 <Galathalion> gawd dayum
12:49:44 <jmcarthur> ?
12:49:48 <jmcarthur> number of people?
12:49:54 <Galathalion> ya
12:50:02 <jmcarthur> we see that reaction a lot ;)
12:50:07 <Galathalion> :D
12:50:23 <copumpkin> jmcarthur: interested in SMT at all? :)
12:50:27 * copumpkin is such a whore
12:50:35 <Galathalion> #haskell on efnet is not even close
12:50:37 <jmcarthur> copumpkin: omg you are
12:50:48 <jmcarthur> copumpkin: not particularly, though
12:50:55 <copumpkin> ah well
12:51:00 <dagle> #haskell on freenode have all the haskellusers. ;)
12:51:07 <copumpkin> dagle: surprisingly, not even!
12:51:22 <monochrom> I used to run efnet #haskell but there was insufficient interest
12:51:37 <Kaidelong> Try DALnet!
12:51:40 <hvr> is there a mirror somwhere for http://www-users.cs.york.ac.uk/~ndm/uniplate/ ?
12:51:44 * Kaidelong totally serious
12:51:54 <monochrom> in fact I used to run efnet #mercury and #fp too
12:51:57 <Galathalion> DALnet is sooo the 90's
12:52:24 <Galathalion> you have a haskell-bot in this channel?
12:52:37 <dagle> Yes.
12:52:43 <dagle> lambdabot is kinda botish.
12:52:55 <Galathalion> i c
12:52:57 <monochrom> yes, you invoke her with some kind of @blah commands.
12:53:15 <Galathalion> sweet
12:53:35 <monochrom> @undo do { c <- defaultConfig; execute m c }
12:53:35 <lambdabot> defaultConfig >>= \ c -> execute m c
12:53:52 <Galathalion> nice
12:53:54 <monochrom> there is also evaluation, prefixed by "> "
12:53:57 <olsner> @pl do { c <- defaultConfig; execute m c }
12:53:58 <lambdabot> (line 1, column 4):
12:53:58 <lambdabot> unexpected "{"
12:53:58 <lambdabot> expecting variable, "(", operator or end of input
12:54:02 <monochrom> > True && False
12:54:03 <lambdabot>   False
12:57:29 <jmcarthur> > fix error
12:57:30 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:57:59 <tromp> :t fix error
12:58:00 <lambdabot> [Char]
12:58:33 <jmcarthur> > take 20 $ fix error
12:58:34 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:58:38 <jmcarthur> :P
13:00:36 <olsner> > head $ fix error
13:00:37 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:00:42 <FunctorSalad> > take 20 undefined `seq` "It isn't strict!"
13:00:42 <lambdabot>   "*Exception: Prelude.undefined
13:01:50 <harlekin> Regarding FFI, what's wrong with line 26 and the following lines in peek? http://hpaste.org/43792/haskell_ffi
13:07:53 <augur> anyone familiar with proof theory
13:21:13 <dmwit> > take 20 (undefined:undefined) `seq` "It isn't strict!"
13:21:13 <lambdabot>   "It isn't strict!"
13:22:08 <dmwit> augur: You should probably just ask your question. If somebody knows enough to answer it, they will.
13:22:21 <jmcarthur> it only has to evaluate the (:) constructor ^^
13:22:38 <jmcarthur> of the result from take
13:25:24 <dmwit> jmcarthur: I know. I was illustrating that for people who might mistakenly think that seq evaluated the entire first argument, just in case.
13:25:33 <augur> dmwit: im not looking for an answer, im looking for a person to talk to! :|
13:26:17 <jmcarthur> dmwit: i was saying that for either you or for whoever else might be reading along, without concern for whether you actually knew that already :)
13:26:20 <augur> ok, heres an actual question
13:26:37 <augur> are there techniques for generating example objects satisfying certain constraints?
13:26:42 <augur> this sounds like an SMT problem.. hmm
13:27:21 <dagle> Is there a price for saying SMT today? :)
13:27:45 <augur> dagle: no, but it seems to be coming up a lot so copumpkin made the channel :P
13:27:56 <dagle> :)
13:28:58 <augur> or how about this, are there ways to define datastructures that satisfy logical constraints? like a transformation or a mapping of some sort?
13:29:28 <xplat> still having a hard time grokking what you're asking for
13:30:22 <Heffalump> anyone know what's happened to GHC 7.0.2? The RC was back in December but nothing since that I can find.
13:31:16 <acowley> augur: that's too vague a question, a function is a data structure and arguably a witness to a logical proposition
13:31:28 <augur> xplat: well, lets go with the second idea. suppose C is a set of constraints. is there some way to transform this into D(C), an ADT who's members are (isomorphic to) all and only the objects that satisfy C?
13:31:58 * hackagebot filemanip 0.3.5.2 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/filemanip-0.3.5.2 (BryanOSullivan)
13:33:08 <acowley> augur: For arbitrary C? Probably not. But if your constraints are an inductive definition, then that is precisely what an ADT gives you.
13:33:49 <augur> acowley: maybe for some class of constraints. i dont care, honestly.
13:34:24 <augur> if it has to be inductive then maybe a question should be are there algorithms for turning non-inductively defined sets into inductively defined sets?
13:35:20 <augur> i mean, not that it MUST be possible to make it inductively defined, but
13:36:01 * hackagebot http-types 0.3.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.3.1 (AristidBreitkreuz)
13:36:34 <xplat> augur: it really matters what kind of constraints you are dealing with
13:36:48 <augur> xplat: sure, and therefore im looking for discussions on that!
13:36:55 <acowley> augur: are you familiar with dependent types?
13:37:01 <augur> acowley: slightly.
13:37:11 <acowley> augur: you'll like them! :)
13:37:25 <augur> xplat: im not looking for anything in particular. if there are discussions of this _at all_, then im interested
13:37:30 <augur> acowley: why?
13:37:34 <xplat> and what kind of objects, too.  herbrand trees?  feature structures?  unlabeled graphs?
13:37:41 <acowley> augur: because they let you express more interesting logical properties in types
13:38:20 <acowley> augur: so a common use is to pass around purely logical objects that don't necessarily have any role at runtime but serve to enforce logical constraints at compile time
13:38:41 <xplat> acowley: you need proof irrelevance to get isomorphisms to subsets, though, and irrelevance is a pain
13:39:42 <acowley> xplat: Yes, but we can stick to disjoint Prop and Type universes
13:40:04 <acowley> it just seems that what augur wants is what Agda and Coq are selling
13:42:29 <augur> acowley: it might be. i mean, consider for instance the possible grammars for the language a^n b^n
13:45:33 <revenantphx> Does GHC 7 fix ghc and ghci being *fucking moronic* about library/include paths
13:45:48 <Peaker_> Is ghc 7 not yet in the platform? 
13:46:01 <xplat> augur: that's a lot of possible grammars
13:46:25 <revenantphx> Additionally, it keeps looking for libLLVM-2.8.dylib
13:46:30 <revenantphx> THERE IS. NO DYLIB. >_<
13:47:00 <augur> xplat: indeed it is!
13:47:00 <augur> :p
13:47:16 <augur> but like, you could think of this as defined by the set of constraints { s = as ++ bs, stringOf(as,'a'), stringOf(bs,'b'), length(as) == length(bs) }
13:47:19 <revenantphx> "Loading package llvm-0.9.0.1 ... can't load .so/.DLL for: LLVM-2.8 (dlopen(libLLVM-2.8.dylib, 9): image not found)"
13:47:30 <revenantphx> LLVM is split into a bunch of static libs.
13:47:53 <xplat> well, that kind of is a grammar
13:48:12 <revenantphx> it's very clear here on that
13:48:13 <augur> xplat: well, sort of
13:48:13 <revenantphx> http://llvm.org/docs/UsingLibraries.html
13:48:14 <xplat> all those constraints are on strings, not grammars
13:48:18 <shachaf> revenantphx: Still at it?
13:48:23 <revenantphx> Well, I got it installed.
13:48:28 <augur> but, are there ways to either enumerate such instances (which i suppose would be a CSP) or more interesting, are there ways to transform such a thing into a recursively defined grammar
13:48:33 <revenantphx> I installed LLVM from source myself, and cabal installed the llvm module perfectly.
13:48:51 <revenantphx> However now ghci won't work since it can't find a nonexistant shared lib.
13:49:01 <revenantphx> And ghc won't work because it silently fails and tells me 
13:49:09 <revenantphx> LLVMTest: user error (Interpreter has not been linked in.)
13:49:16 <augur> like, s(""). s("a" ++ xs ++ "b") :- s(xs).
13:49:16 <revenantphx> despite using ghc --make
13:49:21 <augur> or something like that?
13:49:51 <roconnor> does data (f :+: g) e = Inl (f e) | Inr (g e) require any Haskell extensions?
13:50:09 <revenantphx> it also seems to think that EVERYTHING IT IS TRYING TO LOAD IS DYNAMIC 
13:50:11 <mauke> roconnor: I think so
13:50:25 <revenantphx> i.e
13:50:25 <revenantphx> https://gist.github.com/817385
13:50:47 <revenantphx> oh erp, wrong comamnd there XD
13:50:53 * dagle gives revenantphx a hug.
13:51:10 <thoughtpolice> roconnor: TypeOperators I think
13:51:11 <revenantphx> oh look, interpreter not linked in. TT_TT
13:51:13 <acowley> roconnor: I didn't think so?
13:51:29 <acowley> I thought only infix data constructors needed an extension
13:51:33 <xplat> augur: obviously you could do it for that example (i mean, you just did it) but it's unclear what class of logical constraints you are working with
13:51:41 <jmcarthur> i thought TypeOperators was only required for "lowercase" type operators but upper case ones were fine without it
13:51:52 <revenantphx> oh whats this
13:51:57 <revenantphx> seems it was caching something
13:51:58 <revenantphx> lets see now
13:52:00 <augur> xplat: like i said, i dont care what the class is. any example would be interesting.
13:52:04 <revenantphx> ah of course not.
13:52:21 <xplat> augur: there is a fairly large body of work on what sorts of logic over strings correspond to what classes of languages
13:53:04 <revenantphx> https://gist.github.com/817385
13:53:05 <revenantphx> hahaha
13:53:12 <revenantphx> down on line 99 or so
13:53:17 <xplat> augur: someone did a detailed investigation of 'monadic second-order logic' in particular in that connection, with software.  searching on that would give you pointers into that literature.
13:53:21 <augur> xplat: ok then. refs?
13:53:22 <revenantphx> it links in every LLVM lib under the sun
13:53:28 <revenantphx> but stil lsays "interpreter not linked"
13:53:31 <revenantphx> FFS IT IS LINKED TT_TT
13:53:43 <revenantphx> -lLLVMInterpreter is RIGHT THERE.
13:53:43 <xplat> i think the library/tool was called MONA
13:53:57 <augur> monadic second order logic??
13:54:12 <HugoDaniel_II> im reading through the code of blaze-html, good stuff
13:54:18 <gwern> hm. is anyone applying for this year's SoC? I see next to zero new activity related to SoC
13:54:32 <Botje> it's a bit early still, no?
13:54:39 <gwern> one would think people would be mentioning and discussing their ideas
13:54:45 <xplat> augur: i think it's usually considered a branch of model theory, actually
13:55:02 <Botje> gwern: that and midterms have only just ended (at least in .be)
13:55:57 <gwern> Botje: well, that's .be. in the US, the second semester has just begun. it's the ideal time for speculation and starting new projects
13:56:16 <gwern> assuming they weren't speculating and starting during the immediately preceding vacation...
13:56:49 <augur> xplat: hows this as a question: are there classes of constraints for which satisfiers can be enumerated without a filter-like step?
13:57:30 <augur> xplat: ie, there are ways of axiomatizing the constraint system so that it's strictly constructive?
13:58:24 <xplat> augur: yes.  the standard sort of herbrand constraints used in prolog have that property.
13:58:44 <augur> by herbrand constraints...
13:58:53 <revenantphx> augustss: oy you.
13:59:01 <revenantphx> You had a blog post on this, maybe you know.
14:00:08 <xplat> augur: prolog abbreviates them as trees with holes in them.  since all sets of them can be abbreviated that way, the filter-freeness is obvious by inspection.
14:00:56 <xplat> (well, you can have sharing constraints too, and you need to throw in names to abbreviate those, but they don't break the property)
14:01:17 <augur> xplat: do you have any examples of this in practice that you can point me to?
14:02:11 <Botje> gwern: starts next week here
14:02:26 <Botje> the poor students are all exhausted from studying so hard :p
14:03:57 <snhmib> is it safe (buf' won't get gc'd?) to do something like this: http://hpaste.org/43793/pointerstuffs
14:03:57 <gwern> yes, they study so hard
14:04:34 <snhmib> or should i keep buf' inside loop somehow?
14:05:09 <xplat> augur: probably what you really want is an introductory textbook on finite model theory
14:05:34 <augur> xplat: perhaps.
14:05:40 <xplat> (the word 'finite' is key)
14:06:21 * snhmib not sure how unsafe unsafeInterleaveIO really is :P
14:06:48 <xplat> or you can start looking into henriksen's paper on mona
14:06:56 <shepheb> snhmib: violently.
14:08:09 <xplat> unsafeInterleaveIO is even more dangerous than unsafePerformIO, because it looks safer!
14:08:27 <Peaker> It exposes evaluation order unless you're in denial and claim the io effects were just never guaranteed to execute in any specified time. 
14:08:56 <Gracenotes> hm, what sort of argument does ghc-pkg unregister expect?
14:09:02 <copumpkin> the name of a package
14:09:25 <Peaker> But that denial is usually used as a justification for it and only lasts till the first actual use of it :)
14:09:30 <Gracenotes> I tried to give it random-1.0.0.2-b570f45bd00b7a1bc98159f55cd12ecc, but it didn't like it
14:09:58 <Peaker> Drop the hash part? 
14:10:12 <Gracenotes> but I want to unregister that (the cabal version), and not random-1.0.0.2-156803737564049405b3380fdb96ac75 (the apt-installed one)
14:10:12 <snhmib> Peaker: i want to call a c function that needs some bytes and return a "list"
14:10:15 <monochrom> "random" or "random-1.0.0.2".
14:10:17 <xplat> Peaker: honestly, they executed at completely random times.  it just so HAPPENED, COINCIDENTALLY, that those were the same times thaat the GHC runtime evaluated those terms!
14:10:31 <Gracenotes> I don't think it'll let me specify :/
14:10:44 <Peaker> Yeah I hate that silly justification
14:10:59 <monochrom> the "cabal version"? is it in --user? just add --user if yes.
14:11:31 <snhmib> Peaker: it seems valid to me :(
14:11:38 <Gracenotes> hm. it would break some packages. I suppose I could recompile those though.. I hope
14:11:41 <monochrom> and see my http://www.vex.net/~trebla/haskell/sicp.xhtml so you never run into the same trouble again
14:12:26 <roconnor> newtype Foo t a = Foo (Product Identity (t (Foo t a)) deriving Monad -- can newtype deriving handle this?
14:12:36 <monochrom> people should really stop suggestion "mix apt-get and cabal-install at will"
14:12:37 <Gracenotes> I've tried to use my own GHC in the past, but I suck just as hard at registering things into databases
14:12:39 <Peaker> Snh: in real use cases, everyone just falls back to exposed evaporation order. People don't give up closing their files, etc. 
14:12:41 <copumpkin> roconnor: sure, why not?
14:13:24 <roconnor> copumpkin: I don't know.  Cause Foo t a needs to be a monad for it to see that it can be a monad.
14:13:41 <copumpkin> that would be a constraint on the Monad instance
14:13:42 <monochrom> at best you can only apt-get up to a certain point, and after that stick to cabal-install. or else chase your own dependencies.
14:13:44 <copumpkin> doesn't affect the newtype
14:14:26 <roconnor> copumpkin: right, but I'm wondering if it can derive the Monad Instance given the monad instance for Product
14:14:34 <Gracenotes> monochrom: random comes with ghc6.
14:14:38 <Peaker> Snh: it sucks that users of unsafeinterleaveio aren't themselves marked unsafe and so we don't have an easy way of knowing we are never allowed to close a handle on which getContents was ever used
14:14:48 <Gracenotes> meaning the apt package
14:15:16 <snhmib> Peaker: i know, but the C function only operates on these bytes from the bytestring, so the only thing that could break is that if i do the dropping of foreignptr to ptr wrong
14:15:26 <copumpkin> roconnor: wait
14:15:32 <monochrom> then I wonder how cabal-install would pull another copy of random-1.0.0.2 into --user.
14:15:37 <kmc> roconnor, you might have to write it with StandaloneDeriving
14:15:40 <copumpkin> you say Foo t a needs to be a Monad for Foo t a to be a Monad?
14:15:47 <Gracenotes> I have no idea :(
14:15:49 <Peaker> hGetContents, that is
14:15:51 <copumpkin> -XStandaloneDeriving, -XGeneralizedNewtypeDeriving, deriving instance Monad (...) => Monad (Foo t a)
14:15:54 <copumpkin> what's in the ... ?
14:16:01 <copumpkin> Foo t a would make it an instant lop
14:16:02 <copumpkin> loop
14:16:03 <Gracenotes> however, it does say: ghc-pkg: unregistering random-1.0.0.2 would break the following packages: happstack-state-0.5.0.4 happstack-server-0.5.0.4 happstack-data-0.5.0.3 haskell98-1.0.1.1 happstack-util-0.5.0.3 hint-0.3.3.1 heist-0.4.0.1 (use --force to override)
14:16:06 <kmc> deriving instance (Monad (t (Foo t)) => Monad (Foo t)
14:16:07 <kmc> or some such
14:16:11 <kmc> you can derive Show for Mu this way :FD
14:16:12 <copumpkin> oh okay
14:16:13 <kmc> :D *
14:16:18 <copumpkin> yeah, I've done that
14:16:22 <monochrom> you need to unregister them all from --user
14:16:28 <copumpkin> but he said that Foo t a needs to be a Monad for Foo t a to be a Monad
14:16:34 <Peaker> Snh, if your c function is actually pure, it's totally fine
14:16:36 <kmc> yeah i'm suspicious of that
14:16:39 <Gracenotes> :/ the hash is hardcoded... ah well.. k
14:17:07 <roconnor> copumpkin: I require something like MonadTrans t =>
14:17:15 <copumpkin> what else?
14:17:19 <monochrom> more pointedly, you need to unregister them all from --user so you can rebuild them against your --global instance of random-1.0.0.2
14:17:39 <monochrom> see my article for why the hash is so important and hardcoded.
14:17:46 <snhmib> Peaker: i know, but i'm worried about the bytestring i get the bytes from if i do like this (http://hpaste.org/43793/pointerstuffs)
14:17:56 <roconnor> copumpkin: in theory that is it.
14:18:01 <monochrom> "Ignorance is not bliss anymore. You will know. You are forced to know."
14:18:17 <snhmib> i.e. do i need to loop on the bytestring and get a ptr in loop or is it ok like that?
14:18:22 <copumpkin> roconnor: so write that?
14:19:07 <roconnor> copumpkin: I don't want to write the instance.  It is idenitcal to the instance for Product ... except for the constraints... damn
14:19:10 <kmc> snhmib, it should be safe anyway to loop on the ForeignPtr and unpack it to Ptr in each iteration
14:19:15 <copumpkin> roconnor: did you try what I wrote?
14:19:20 <roconnor> no
14:19:32 <Jesin> instance of what
14:19:34 <Gracenotes> according to ghc-pkg, there are no packages which depend on a non-global version of random
14:19:38 <Gracenotes> *dump
14:19:39 <copumpkin> -XStandaloneDeriving, -XGeneralizedNewtypeDeriving, deriving instance MonadTrans t => Monad (Foo t a)
14:19:41 <Jesin> roconnor what are you writing  :p
14:19:42 <kmc> or you could throw caution to the wind and use unsafeForeignPtrToPtr and touchForeignPtr
14:19:43 <copumpkin> if you're lucky, it might work
14:19:45 <copumpkin> I sort of doubt it though
14:19:47 <Jesin> huh
14:19:54 <roconnor> Jesin: cartesian state monad
14:20:03 <Jesin> GeneralizedNewtypeDeriving I like, what's StandaloneDeriving btw?
14:20:10 <Gracenotes> BUT it still installs it O_O
14:20:14 <snhmib> kmc: yea, i'll guess i do that just in case :) I'll find out how interleaveIO works later. maybe :)
14:20:22 <roconnor> copumpkin: oh what if I make it easier
14:20:33 <mm_freak> roconnor: what's that?
14:20:35 <roconnor> newtype Foo a = Foo (Product Identity (StateT (Foo a)) deriving Monad -- can newtype deriving handle this?
14:20:37 <Gracenotes> it re-installs the local random even when there's no trace of it in the system
14:20:41 <roconnor> mm_freak: it is that
14:20:57 <mm_freak> and what is Product?
14:20:58 <roconnor> copumpkin: now the instance has no constraints
14:21:02 <Peaker> Snh: I'm not an expert on Haskell FFI, sorry
14:21:12 <roconnor> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Data-Functor-Product.html#t:Product
14:21:27 <monochrom> what triggers pulling in random? happstack something?
14:22:02 <monochrom> eh? having a --user haskell98-1.0.1.1 is a really bad sign
14:22:03 <snhmib> np :)
14:22:24 <mm_freak> roconnor: i don't understand your code…  your parentheses are not balanced
14:22:35 <Gracenotes> monochrom: according to ghc-pkg list, it doesn't exist as user
14:22:43 <roconnor> newtype Foo a = Foo (Product Identity (StateT (Foo a))) deriving Monad
14:23:01 <roconnor> newtype CartesianStore a = CartesianStore (Product Identity (StateT (Foo a))) deriving Monad
14:23:04 <Gracenotes> but.. if it's saying what it says it's saying, apparently removing the local random will cause global haskell98 to get all screwed up
14:23:15 <roconnor> newtype CartesianStore a = CartesianStore (Product Identity (StateT (CartesianStore a))) deriving Monad
14:23:36 <monochrom> oh, I remember now, you're at ghc-6.12.1? that is seriously broken. see my article.
14:23:56 <roconnor> oops
14:24:01 <roconnor> I mean CartesianState
14:24:12 <roconnor> newtype CartesianState a = CartesianState (Product Identity (StateT (CartesianState a))) deriving Monad
14:24:19 <copumpkin> that works?
14:24:25 <Gracenotes> monochrom: oh, lol
14:24:29 <roconnor> copumpkin: clearly
14:24:30 <mm_freak> roconnor: i don't see how that can work…  i see a kind error, but i might be wrong
14:24:31 <copumpkin> excellent!
14:24:33 <snhmib> monochrom: what article?
14:24:39 <monochrom> essentially ghc 6.12.1 bug implies --global can shadow --user just because the hashcode is big enough
14:24:40 <roconnor> mm_freak: oh you are right
14:24:42 <roconnor> god damn it
14:24:45 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml
14:24:47 <Gracenotes> monochrom: I'm finding b570f45bd00b7a1bc98159f55cd12ecc  grepping through the dist/ folder of a package
14:24:52 <roconnor> newtype CartesianState a = CartesianState (Product Identity (StateT (CartesianState)) a) deriving Monad
14:24:54 <Gracenotes> which I'm installing
14:25:04 <roconnor> newtype CartesianState a = CartesianState ((Product Identity (StateT CartesianState)) a) deriving Monad
14:25:08 <roconnor> there
14:25:14 <Gracenotes> arg but it still happens. anyhow.
14:25:17 <mm_freak> roconnor: still a kind error, no?
14:25:18 <roconnor> math is hard
14:25:29 <mm_freak> roconnor: Product expects both arguments to be * -> *
14:25:34 <Peaker> What's Product? 
14:25:38 <mm_freak> you have a * -> * -> * argument there
14:25:43 <roconnor> mm_freak: Identity is * -> *
14:25:52 <roconnor> StateT is (* -> *) -> * -> *
14:25:59 <roconnor> ooh
14:26:00 <mm_freak> roconnor: but StateT (Foo a) isn't
14:26:00 <roconnor> oops
14:26:02 <roconnor> right
14:26:12 <roconnor> newtype CartesianState s a = CartesianState ((Product Identity (StateT s CartesianState)) a) deriving Monad
14:26:18 <roconnor> math is very hard
14:26:24 <copumpkin> lol
14:26:26 <mm_freak> hehe
14:26:38 <roconnor> but this works for any monad transformer
14:26:40 <copumpkin> roconnor: so what can I do with it?
14:26:47 <roconnor> copumpkin: I don't know
14:27:13 <Gracenotes> monochrom: how hard is it really to install ghc7 from scratch? not sure how well it's stabilized, and.. I'm not sure how much I'm going to like updating it
14:27:32 <mm_freak> roconnor: what's the point of this anyway?  two computations, one identity and one StateT, which uses another such product
14:28:23 <monochrom> I recommend 6.12.3 for now, which is not hard.
14:28:42 <roconnor> mm_freak: it is isomorphic to Id * StateT s Id * (StateT s)^2 Id * ...
14:28:58 <roconnor> mm_freak: although this isomorphis doesn't hold for all monad transformers.
14:29:50 <Gracenotes> :| fair enough. so updating ghc... you have to keep a list of all the files it uses so you can wipe it out and install the next version?
14:29:55 <Jesin> now that I finally understand monads
14:30:03 <Jesin> maybe next I should do monad transformers
14:30:07 <Gracenotes> it does sort of splurge all over the place. like, yeah, other applications.
14:30:07 <monochrom> However I have just tried ghc 6.12.1, cabal-install 0.8.0 using Cabal lib 1.8.0.2, "cabal install --dry-run happstack-state" does not try to pull in random.
14:30:10 <Jesin> anyone know a good place to start?
14:30:11 <roconnor> which is in turn isomoprhic to Id * StateT s Id * StateT (s^2) Id * ...
14:30:44 <mm_freak> Jesin: nobody understands monad transformers =)
14:30:51 <roconnor> which is in turn isomoprhic to State () * State s * State (s^2) * ...
14:31:11 <Jesin> aww.
14:31:11 <mm_freak> roconnor: yes, but is that useful?
14:31:15 <Jesin> people use them, though...
14:31:16 <monochrom> I just do ./configure --prefix=/usr/local/haskell-platform-2010.2.0.0 so I can just erase that directory later.
14:31:18 <roconnor> so you see that it lets you run State (s^n) in parallel all n
14:31:26 <roconnor> mm_freak: presumably it is useful for something :P
14:31:41 <Jesin> I don't suppose there is a single monad transformer for every monad?
14:32:03 <copumpkin> ListT only has half of one
14:32:08 <copumpkin> or [] I should say
14:32:13 <Jesin> =/
14:32:29 <mm_freak> Jesin: i think the unit monad doesn't have a (meaningful) transformer
14:32:38 <mm_freak> newtype Unit a = Unit
14:32:56 <roconnor> newtype UnitT w a = UnitT
14:33:04 <Jesin> is that simply the current state of the library, or is [] proven to have no full monad transformer?
14:33:21 <Jesin> hmm
14:33:25 <monochrom> you could also stick with ghc 6.12.1 but you must always ensure that the bug is not triggered.
14:33:32 <roconnor> there exists a propert ListT transformer
14:33:36 <Jesin> mm_freak: what are the Functor and Monad instances for Unit?
14:33:51 <roconnor> fmap f Unit = Unit
14:33:56 <roconnor> return s = Unit
14:34:00 <copumpkin> :P
14:34:03 <Jesin> k
14:34:05 <acowley> Unit is the best
14:34:11 <copumpkin> oh, it's acowley!
14:34:11 <Jesin> join Unit = Unit, I suppose?
14:34:18 <roconnor> yes
14:34:22 <acowley> it is I!
14:34:23 <Jesin> yaaay
14:34:28 <Jesin> lol
14:34:33 <acowley> Jesin: this is why Unit is so great
14:34:37 * roconnor give Jesin a level 2 monad gold star
14:34:48 * Jesin binds it to his shirt
14:34:50 <Jesin> :D
14:34:57 <copumpkin> roconnor: your problem is that UnitT doesn't preserve the original effects of the transformed monad
14:35:07 <roconnor> copumpkin: really?
14:35:16 <copumpkin> oh
14:35:20 <copumpkin> you could make it I guess
14:35:35 <copumpkin> fair enough
14:36:04 <Jesin> I want a monad transformer tutorial :p
14:36:07 <roconnor> newtype UnitT m a = m Unit
14:36:36 <Peaker> Jesin, I wrote one
14:36:46 <Jesin> k, link?
14:36:50 <Peaker> Well, intro, not comprehensive
14:36:52 * Jesin will give it test drive
14:36:54 <Jesin> k
14:37:19 <Jesin> [17:52:55]	<Jesin>	is that simply the current state of the library, or is [] proven to have no full monad transformer?
14:37:21 <Jesin> [17:53:23]	<roconnor>	there exists a propert ListT transformer
14:37:22 <Jesin> hmm
14:37:26 <Jesin> and, it's not in the library for
14:37:36 <copumpkin> roconnor: what is the proper ListT?
14:37:37 <monochrom> don't learn "monad transformer". learn StateT, ReaderT, WriterT.
14:37:38 <Jesin> historical reasons, I would guess?
14:37:57 <monochrom> in particular StateT and ReaderT are pretty easy.
14:38:01 <Jesin> hmm, that sounds good :p
14:38:03 <Jesin> oh
14:38:14 <Jesin> I never really understood Reader very well
14:38:18 <Jesin> is it ever used for anything?
14:38:37 <acowley> Jesin: monochrom is right
14:38:41 <Jesin> (the Reader monad is the monad instance for ((->) r) if I remember correctly?)
14:38:51 <smarmy> reader kinda provides read-only globals over the scope of a computation
14:38:51 <Gracenotes> Reader Foo a is just a function you always pass Foo to. not sure if that'll help though.
14:38:55 <acowley> monad transformers are pretty fustrating to build from the ground up for yourself
14:39:02 <Jesin> fmap = (.)
14:39:03 <monochrom> Reader is a newtype over ((->) r).
14:39:08 <Jesin> return = const
14:39:10 <Jesin> join f x = f x x
14:39:14 <roconnor> copumpkin: copumpkin: something like data ListT m a = Nil | Cons
14:39:15 <roconnor> er
14:39:18 <roconnor> forget that
14:39:19 <copumpkin> lol
14:39:23 <roconnor> copumpkin: http://www.haskell.org/haskellwiki/ListT_done_right
14:39:40 <roconnor> BTW, X's cut and paste mechanism blows
14:39:43 <copumpkin> ah
14:39:48 <Peaker> Jesin http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial
14:39:59 <copumpkin> I see
14:40:27 <Jesin> [17:58:54]	<monochrom>	Reader is a newtype over ((->) r).
14:40:41 <copumpkin> Reader r is
14:40:43 <copumpkin> ;)
14:40:59 <monochrom> @slay copumpkin
14:41:00 <lambdabot> I don't perform such side effects on command!
14:41:04 <monochrom> whee!
14:41:05 <copumpkin> :(
14:41:10 <Jesin> monochrom, if I recall correctly, the Monad for Reader was the same as the one for (->) r defined in Control.Monad.Instances
14:41:12 <Peaker> Night! 
14:41:12 <copumpkin> monochrom wants me slain
14:41:25 <monochrom> "the same" up to newtype.
14:41:32 <Jesin> instance Functor ((->) r) where
14:41:33 <Jesin>         fmap = (.)
14:41:42 <Jesin> instance Monad ((->) r) where
14:41:44 <Jesin>         return = const
14:41:45 <Jesin>         f >>= k = \ r -> k (f r) r
14:42:04 <int80_h> I have a foo :: IO [String], how can I perform an operation bar :: [a] -> a  on foo?
14:42:10 <Gracenotes> you can implement a lambda calculator evaluator using Reader, and using regular functions. you can see how they're similar, and what >>= operationally means
14:42:50 <int80_h> I thought liftIO is what I needed, but that seems to be wrong
14:42:56 <int80_h> :t liftIO
14:42:57 <lambdabot>     Ambiguous occurrence `liftIO'
14:42:57 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
14:42:57 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
14:43:25 <int80_h> :t Control.Monad.Error.liftIO
14:43:26 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
14:43:30 <Jesin> so, essentially, the Reader instance for monad is what you would get if you wrote
14:43:35 <monochrom> liftM bar foo :: IO String.  you could s/liftM/fmap
14:43:36 <Gracenotes> fmap bar foo?
14:43:41 <Jesin> newtype Reader r a = Reader { runReader :: r -> a } deriving (Functor, Applicative, Monad)
14:43:49 <Jesin> with LANGUAGE GeneralizedNewtypeDeriving?
14:44:03 <int80_h> so I could either use liftM or fmap?
14:44:18 <Gracenotes> int80_h: the way to do it with monad syntax would be, intuitive-ish-ly, foo >>= \strings -> return (bar strings)
14:44:30 <monochrom> I don't know. But if you s/deriving/human-deriving/ and s/GeneralizedNewtypeDeriving/HumanIntervention/ then yes.
14:45:01 <Gracenotes> turns out that if you can do it applicatively, and don't fully need a monadic context, fmap/liftM are just peachy..
14:45:22 <Jesin> "Instead of associating a monadic side effect with a list of values (m [a]), it lets each element of the list have its own side effects"
14:45:53 <monochrom> well ListT may be more advanced.
14:46:07 <Jesin> I thought something like that would be common sense
14:46:11 <Jesin> =/
14:46:38 <Gracenotes> if you try to shoehorn it onto good ol' [], which would be the initial approach, you'd find your common sense running out
14:46:39 <monochrom> State and Reader are trivial, StateT and ReaderT are just one inch above State and Reader.
14:47:21 <Jesin> "There is also a ListT done right alternative." - I hope these two are equivalent?
14:48:21 <monochrom> of course not, why do you think someone calls it "done right"?
14:48:42 <kmc> @quote done.right
14:48:42 <lambdabot> LinusTorvalds says: The slogan of Subversion for a while was 'CVS done right', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do
14:48:43 <lambdabot> CVS right.
14:48:53 <Jesin> lol...
14:49:08 <Jesin> hmm
14:49:18 <Jesin> should I do monad transformers first or should I start with Arrow?
14:49:31 <monochrom> monad transformers. or just StateT
14:50:20 <Jesin> "newtype ListT m a = ListT { runListT :: m (Maybe (a, ListT m a)) }" -- ok, I think I like the one that doesn't shove Maybe in there
14:50:59 <Jesin> especially since it *also* implements the Maybe version with another function
14:51:01 <Jesin> :p
14:51:32 <mm_freak> Jesin: http://hackage.haskell.org/packages/archive/contstuff/1.2.4/doc/html/src/Control-ContStuff-Trans.html#ChoiceT
14:51:36 <mm_freak> how about that one? ;)
14:51:42 <Jesin> GAH
14:51:44 <Jesin> XD
14:52:18 <Jesin> newtype ChoiceT r i m a = ChoiceT { getChoiceT :: (i -> a -> (i -> m r) -> m r) -> i -> (i -> m r) -> m r }
14:52:21 <Jesin> that's hilarious
14:52:24 <roconnor> can I write type declariation in instance declarations?
14:52:35 <monochrom> no
14:52:56 <roconnor> damn it
14:53:06 <mm_freak> type families?
14:53:08 <monochrom> but I should check for real
14:54:16 <monochrom> disallows type declarations
14:55:12 <roconnor> phooy
14:55:18 <roconnor> *phooey
14:55:40 <FunctorSalad> it does sound like associated types
14:56:16 <monochrom> type family business may be different. I only checked haskell 2010.
14:56:35 <roconnor> actually I'm just writing a paper
14:56:50 <roconnor> I was hoping to get away with not writing out the class definition of applicative explicitly
14:56:50 <monochrom> haha, write a comment
14:58:32 <int80_h> :t flip
14:58:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:59:58 <fergie> Can any one help with the following cabal error: "FileManipCompat-0.16 failed during the building phase. The exception was: ExitFailure 1"
15:01:16 <Jesin> int80_h: yeah, I figured out that in lambdabot
15:01:25 <Jesin> flip f x = fmap ($ x) f
15:02:12 <mm_freak> fergie: scroll up and find out the real error message
15:02:34 <mm_freak> fergie: often when such an error occurs some external tool (like happy) is needed
15:03:40 <fergie> mm_freak: putting error message in hpaste...
15:04:16 <fergie> mm_freak: doesn't mention anything about happy
15:07:13 <fergie> Full error message at http://pastie.org/1542913
15:10:25 <fergie> mm_freak: have found a mailing list thread which says it may be because FileManipCompat depends on mtl<2
15:11:13 <xplat> :t \f x -> fmap ($ x) f
15:11:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
15:11:25 <xplat> :t \f x -> fmap (<$> x) f
15:11:26 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f a -> f1 (f b)
15:12:47 <Jesin> :t \a b -> a >>= (`fmap` b)
15:12:48 <lambdabot> forall (m :: * -> *) a b. (Functor m, Monad m) => m (a -> b) -> m a -> m b
15:12:56 <Jesin> :t (<*>)
15:12:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:12:59 <Jesin> :t ap
15:13:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:13:19 <Jesin> :t \a b -> (`fmap` b) =<< a
15:13:20 <lambdabot> forall a b (m :: * -> *). (Functor m, Monad m) => m (a -> b) -> m a -> m b
15:13:38 <xplat> it seems like the existence of lambdabot's 'flip' is equivalent to the existence of fmap
15:13:41 <xplat> :t fmap
15:13:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:14:38 <xplat> hm, maybe not ...
15:15:07 <xplat> anyway, they seem closely related ...
15:15:58 <xplat> i wonder what you need to write flip'' :: f (f1 b) -> f1 (f b)
15:18:41 <Jesin> xplat, would "flip" even be properly a specialization of that?
15:18:52 <dobblego> oh wait, Boolen
15:19:03 <dobblego> oop
15:19:18 <Jesin> actually
15:19:20 <Jesin> [18:35:50]	<xplat>	i wonder what you need to write flip'' :: f (f1 b) -> f1 (f b)
15:19:29 <xplat> jesin: f = (->) a, f1 = (->) b
15:19:32 <Jesin> I don't think you can do that with a regular Functor
15:19:59 <Jesin> :t flip
15:20:00 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:20:08 <xplat> Jesin: no, i don't think you can either in general which is why i left the context empty instead of making them both Functor
15:20:38 <Jesin> hmm
15:20:44 <Jesin> I think I've seen something like that
15:20:55 <xplat> @hoogle a -> f b -> f (a -> b)
15:20:56 <lambdabot> No results found
15:21:22 <xplat> :t >>=
15:21:23 <lambdabot> parse error on input `>>='
15:21:30 <xplat> :t (>>=)
15:21:30 <Jesin> :t (>>=)
15:21:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:21:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:21:32 <Jesin> doesn't do it
15:21:33 <datakid> hola, after running cabal upgrade I keep getting the msg: "Note: there is a new version of cabal-install available. To upgrade, run: cabal install cabal-install" I follow the directions and then when I run upgrade again, the msg comes back...
15:21:37 <datakid> any ideas?
15:22:33 <int80_h> http://hpaste.org/43795/help_me_make_sense_of_this_err
15:22:37 <xplat> Jesin: yeah, now that i think about it it seems more like a comonadic thing
15:22:59 <Jesin> I think I read about it in the context of combining monads and comonads?
15:23:50 <xplat> Jesin: hm, was that the type of a distributive law?
15:24:23 <Jesin> it may have been called "commutes"
15:24:25 <Jesin> I dunno
15:24:35 <xplat> i guess it is ... so reader gets a free one-way distributive law with everything?
15:24:43 <djahandarie> You can write that trivially if you have a copoint.
15:24:48 <djahandarie> (Along with a point)
15:25:53 <xplat> djahandarie: yeah, i was just starting to think that myself.  both point and copoint is a kind of restrictive assumption, but a lot of comonads do have a point
15:27:29 <dobblego> is there a module to copy a string to the paste buffer?
15:27:59 <int80_h> http://hpaste.org/43795/help_me_make_sense_of_this_err
15:28:12 <NemesisD> is it possible/does it make sense to make a type constructor an instance of a typeclass? so if data Foo = Bar | Baz, instance Show (Bar) where ...
15:28:13 <xplat> zippers over monadic containers inherit the point from the monad, and Store gets one when the underlying type has a distinguished constant
15:28:23 <xplat> er, the underlying argument type
15:28:33 <Jesin> djahandarie: where "point" is pure/return?
15:28:35 <dobblego> NemesisD: yes to type constructors, but you have data constructors there, also yes
15:28:39 <djahandarie> Jesin, yes.
15:28:42 <c_wraith> datakid: probably a path issue.  cabal install cabal-install will install to ~/.cabal/bin.  If you have a different cabal binary in your path, that explains the situation
15:28:54 <xplat> or you could cheat and use bottom for all of them :)
15:29:01 <Jesin> XD
15:29:08 <Jesin> that doesn't count
15:29:09 <Jesin> :p
15:29:24 <Jesin> btw, is Unit a comonad as well?
15:29:57 <Jesin> probably not, I think extract (aka coreturn) would have to be const _|_
15:30:12 <xplat> well, i meant pure x :: (s, s -> a) = (undefined, const x)
15:30:14 <byorgey> NemesisD: it does not make sense to make a data constructor an instance of a typeclass.
15:30:23 <byorgey> NemesisD: only types and type constructors can be instances of type classes.
15:30:32 <xplat> that might kind of count
15:31:03 <monochrom> int80_h: s/screenScraping responseBody/(screenScraping responseBody)/ :)
15:31:52 <xplat> Jesin: you want Zero, an empty type, whose methods are all undefined
15:33:02 <NemesisD> byorgey: im pretty concerned on the terminology. say if i wanted Bar and Baz to show differently, you are saying that isn't possible
15:33:05 <Jesin> I've heard that called Void I think
15:33:14 <xplat> in the subcategory with only total functions the methods could be anything since you'll never call them
15:33:26 <Jesin> its only member is _|_ as are all its methods and it is an instance of everything
15:33:28 <Jesin> :p
15:33:31 <xplat> or rather, never evaluate them
15:33:38 <djahandarie> I think you need (RepresentableFunctor g, Functor f) => f (g a) -> g (f a)
15:33:43 <NemesisD> Jesin: sorry i shoulda put more filler in my code
15:33:54 <byorgey> NemesisD: well, that would be possible, just by giving different implementations for them in your Show instance for Foo
15:34:05 <xplat> yeah, it's kind of an instance of everything, but it's a comonad in a slightly more meaningful sense
15:34:23 <int80_h> monochrom: thanks
15:34:23 <byorgey> instance Show Foo where    show Bar = ...   show Baz = ...
15:34:25 <djahandarie> duplicate m = tabulate (\m -> tabulate (index a . (<>) m))
15:34:38 <NemesisD> byorgey: ohh i see
15:34:45 <xplat> in that everything about Void being a comonad is dual to the way Unit is a monad
15:34:59 <Jesin> lol
15:35:08 <djahandarie> tabulate . index = id; index . tabulate = id; tabulate . return f = return f;
15:35:52 <int80_h> monochrom: got another error now
15:36:02 <int80_h> posting
15:36:02 <djahandarie> Representable is stronger than Applicative but weaker than Monad i think
15:36:30 <Jesin> hmm
15:36:37 <Jesin> what other methods does it need to define?
15:37:37 <int80_h> monochrom: http://hpaste.org/paste/43795/help_me_make_sense_of_this_err#p43796
15:38:32 <djahandarie> You need tabulate. tabulate :: (Key f -> a) -> f a. Key and index come from Indexable (see keys package)
15:38:53 <Gracenotes> monochrom: funnily enough, I have the exact same problem with random-1.0.0.2 on a 6.12.1 system I've ssh'd into
15:39:16 * djahandarie grabs some food
15:39:47 <monochrom> int80_h: perhaps you really mean "return $ liftM last $ the rest"?
15:39:49 <int80_h> the error barf is confusing to me, I'd like to be able to get the meaning from it.
15:39:57 <int80_h> ah yes
15:40:02 <int80_h> that's what I mean
15:40:18 <int80_h> ghc should know what I mean!
15:40:25 <monochrom> also the type of "obtainCookies :: Curl -> String -> IO ()" will be wrong.
15:40:38 <int80_h> > import psychic.Monad.Control
15:40:39 <lambdabot>   <no location info>: parse error on input `import'
15:40:54 <Bynbo7> @ask tibbe Will your talk at Galois be recorded? I'd be very interested in watching it.
15:40:54 <lambdabot> Consider it noted.
15:42:15 <int80_h> monochrom: right now I'm trying to put the results of obtainCookies into IO ()
15:42:45 <int80_h> monochrom: in what way is it wrong. Yes I am getting another type error. Probably due to what you mentioned
15:42:55 <monochrom> well you could see a general pattern "couldn't match X against Y->Z" to occur when parentheses are wrong therefore some functions don't get enough parameters and some other functions get too many.
15:43:30 <int80_h> gotcha
15:43:41 <monochrom> you could erase the type signature of obtainCookies and then ask ghci for :type obtainCookies
15:43:53 <int80_h> good!
15:44:02 <monochrom> (I am too lazy to infer the type of flip (curlResp2 curl) resourceOpts)
15:44:18 <int80_h> monochrom: yeah I have been typing things in by hand to figure out types
15:44:53 <monochrom> delete "return $".
15:45:27 <int80_h> monochrom: DOn't I need that to put a pure type inside IO?
15:45:31 <monochrom> usually it is "return $ pure value here" or "IO thingy here", seldom "return $ IO thingy here"
15:45:51 <monochrom> "liftM last $ mapM etc" is hardly pure.
15:45:55 <c_wraith> What?  I've been writing "return $ IO thingy here" code all day!  Nesting IO ftw!
15:46:40 <monochrom> yeah yeah there is a case you do "return $ IO thingy here" but it's one of those "if you have to ask you are not ready to know"
15:46:55 <int80_h> oops, I should have a String.
15:47:13 <monochrom> afk
15:47:36 <int80_h> I thought return $ last liftM ... would take the list from the monadic context, perform last on it 
15:49:11 <dmwit> Just plain "liftM last" does that.
15:49:20 <int80_h> ah
15:49:20 <dmwit> No return necessary.
15:49:23 <int80_h> okay
15:49:32 <dmwit> :t liftM last
15:49:33 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m a
15:49:34 <int80_h> I guess I haven't got the syntax yet
15:49:55 <sproingie> "last liftM" makes liftM an argument to last, which doesnt typecheck
15:49:57 <int80_h> dmwit: What does that type say?
15:50:31 <int80_h>  forall a (m :: * -> *). (Monad m) => m [a] -> m a
15:50:32 <dmwit> Given a way to compute a list (with some side effects described by m), I now have a way to compute an element of that list (with some side effects described by m).
15:56:40 <int80_h> hmm, I am going to change the function type to what ghci says it should be
15:56:47 <int80_h> and see what happens
15:56:54 <revenantphx> Is there something like twisted for Haskell?
15:56:56 <revenantphx> out of curiosity
15:57:08 <c_wraith> IO.  >_>
15:57:10 <int80_h> Haskell made me twisted
15:57:21 <c_wraith> Well, the IO manager
15:57:23 <int80_h> I was a normal person once.
15:57:52 <revenantphx> IO manager?
15:59:43 <c_wraith> The thing that makes non-blocking event-driven IO appear to be blocking multi-threaded IO
15:59:58 <Twey> revenantphx: Haskell has proper support for OS threads *and* lightweight runtime threads.
16:00:01 <Twey> No GIL.  ☺
16:00:05 <revenantphx> :)
16:00:18 <revenantphx> Well, I was wondering more about a nice network system off the bat
16:00:25 <revenantphx> to abstract away actually doing TCP accept/etc
16:00:32 <revenantphx> not really necessary I suppose.
16:00:33 <Twey> Oh, there are a bunch on Hackage
16:00:37 <Twey> I think
16:00:39 <revenantphx> yeah, like what?
16:00:55 <Twey> Good question *has a look*
16:01:06 <revenantphx> and is there anything like Construct (python)?
16:01:17 <revenantphx> I mean, Data.Binary is generally fine, but lazy io is icky
16:01:24 <revenantphx> and combining with iteratee's gets complex fast.
16:01:35 <revenantphx> in short, is there a good binar parsing lib
16:01:41 <revenantphx> with support for peeking and meta-sized arrays
16:02:30 <bos> @pl \a b->[a]++
16:02:31 <lambdabot> (line 1, column 12):
16:02:31 <lambdabot> unexpected end of input
16:02:31 <lambdabot> expecting white space or simple term
16:02:36 <bos> \a b->[a]++b
16:02:43 <bos> @pl \a b->[a]++b
16:02:44 <lambdabot> (:)
16:03:12 <companion_cube> \o/
16:03:22 <Twey> revenantphx: network-fancy looks neat
16:03:30 <Jesin> @pl \a b c -> [a,b] ++ c
16:03:30 <lambdabot> ((++) .) . (. return) . (:)
16:03:34 <Jesin> lol.
16:03:50 <Twey> revenantphx: Or maybe network-server
16:03:51 <Jesin> @pl ([a]++)
16:03:51 <lambdabot> (a :)
16:03:56 <Jesin> @pl ([a,b]++)
16:03:56 <lambdabot> ([a, b] ++)
16:04:09 <Twey> Hm, I think -fancy supersedes -server
16:04:16 <Jesin> @pl ((a:b:[])++)
16:04:16 <lambdabot> ([a, b] ++)
16:05:02 <revenantphx> Maybe I should put together a simple TCP system in the IO monad.
16:05:11 <revenantphx> With support for sending Binary types.
16:05:18 <revenantphx> When i have time maybe I'll do that.
16:07:54 <Twey> revenantphx: I don't think Data.Binary uses lazy I/O?
16:08:29 <Twey> Oh, the encodeFile/decodeFile convenience functions
16:09:23 <revenantphx> Twey: and binary-protocol i.e
16:09:36 <revenantphx> Either way, it'd be nice to have a real binary parsing library >_>
16:09:42 <revenantphx> Iteratee based or sumshit.
16:10:15 <Twey> No
16:10:38 <Twey> It would be nice to rewrite binary-protocol to use iteratees
16:10:51 <Twey> Parsing itself should be independent of the protocol from which you obtain the data
16:11:13 <Twey> Hm, I guess you could do some clever stuff with iteratees there to get partial parses where appropriate
16:15:39 <mm_freak> revenantphx: you can use attoparsec for binary parsing
16:16:04 <revenantphx> yeah it's not really that great for binary though
16:16:10 <revenantphx> no sized integer parsing for example
16:16:35 <revenantphx> I'd have to read out blocks of data then use Data.Binary
16:16:36 <mm_freak> yes, but it's a start and works well with 'enumerator'
16:16:44 <revenantphx> mm yeah true
16:16:48 <revenantphx> Thats what I tried befor
16:16:51 <revenantphx> it got a tad messy tho
16:16:58 <revenantphx> especially when I was trying to get it to loop forever >_>
16:17:23 <mm_freak> what's the matter with that?
16:33:15 <parcs> what's wrong with lazy IO for network communication?
16:35:08 <kmc> by "lazy IO" you mean the unsafeInterleaveIO hacks?
16:36:09 <chopin> Hi
16:36:21 <chopin> http://pastebin.com/6nLpLxKy is ther a problem there?
16:36:42 <chopin> i cant succeed in catching the Int ord
16:36:49 <chopin> for Value
16:37:13 <Zao> parcs: Networking is an error-rich domain, which has a tendency to crumble at any moment.
16:37:30 <kmc> chopin, what's the errorV
16:37:33 <kmc> error?*
16:37:49 <Zao> Unlike files, which have a tendency to be reasonably reliable.
16:38:19 <Zao> You also tend to have lots of sockets in a network server, so you have a much larger risk of FD exhaustion too.
16:38:34 <parcs> kmc: whatever Network uses
16:38:59 <parcs> Zao: hadn't thought of that
16:39:15 <banisterfiend> hi is there anything like SICP for haskell?
16:39:20 <banisterfiend> or an SICP version for haskell?
16:39:28 <elliott> What's the magic to get hs-boot files? "ghc --make" is complaining about recursive module dependencies.
16:39:35 <Twey> banisterfiend: There's a Haskell translation
16:39:40 <Twey> But really, just do it in Scheme
16:39:43 <Zao> elliott: Write them manually?
16:39:46 <Twey> The language isn't the point
16:39:56 <elliott> Zao: Oh, is that what you're meant to do?
16:40:00 <elliott> Uglyy. :)
16:40:00 <Zao> elliott: Dependency breaking is something that's fairly tricky, I believe.
16:40:03 <ezyang> Bits of SICP would be pretty unpleasant to do in Haskell. anyway. 
16:40:11 <elliott> I know what I'll do! SEPARATE IT OUT
16:40:18 <Twey> Yeah
16:40:27 <augustss> elliott: Just write it by hand.  Not to hard.
16:40:29 <elliott> Augh, that doesn't even work I don't think.
16:40:46 <elliott> augustss: Is there any documentation?
16:41:43 <elliott> Can't find it in the manual.
16:42:37 <chopin> kmc : i made fonctions which play with Value
16:42:42 <chopin> some values
16:42:48 <Zao> elliott: Checked the dev wiki?
16:43:00 <elliott> Zao: oh joy :)
16:43:00 <chopin> i want to have an order on it, the same as Int
16:44:39 <Zao> http://hackage.haskell.org/trac/ghc/ticket/1409 <- relevant ticket on what would be needed to be done to compile strongly connected modules together.
16:44:43 <Zao> "doable, but lots of work"
16:45:13 <elliott> Is it OK if module A depends on module B, module B depends on module C, but module C only depends on module A and not B explicitly?
16:45:16 <elliott> Grasping at straws here.
16:45:28 <elliott> And A has no direct dependency on module C.
16:45:51 <ezyang> elliott: No. 
16:45:58 <elliott> OH WELL :-)
16:46:01 <ezyang> unless you write a bootstrap file. 
16:46:11 <elliott> I should probably do that.
16:46:37 <ezyang> I'd first see if you can resolve the circular dependency by factoring a module out. But sometimes it's cleaner to bootstrap. 
16:48:09 <elliott> ezyang: That's what I tried to do -- the problem is that I have a record that I define another monad as a StateT (with that record being the state), but that record has a field which is defined in another module which has to use the monad functions.
16:48:13 <elliott> Quite thoroughly ugly.
16:49:05 <ezyang> yeah, that sounds pretty textbook bootstrap plz 
16:49:25 <elliott> Yeah.
16:49:43 <ezyang> Though, I'm not sure, but can't you put all the data declarations in one module? 
16:50:01 <ezyang> (this may not make sense for your stuff) 
16:50:27 <elliott> ezyang: No. The record field in the state whose type is from the second module is a map from an existential type class wrapper to Dynamic. The type class in question has functions in it whose types are monadic actions.
16:50:37 <elliott> What do you mean I'm insane?
16:50:39 <ezyang> fair enough. 
16:50:56 <elliott> Hmm, is there a standard method for choosing which module to give an hs-boot file? :-P
16:52:52 <parcs> the one with less reverse dependencies?
16:57:18 <kmc> ugh hs-boot
16:57:56 <kfish> ugg.hs boot
16:58:10 <elliott> ezyang: Actually I'm not even sure I can write an hs-boot!
16:58:18 <elliott> I might have to just cat the two modules together at this rate.
16:58:40 <accel> anyone here find that for vim, their startup time is reallyr eally slow when editing a *.hs file?
16:58:53 <jix> elliott: you could put them in one internal module, and then reexport them using two modules
16:59:01 <ezyang> accel: No. But have you tried disabling whatever syntax module you have for hs? 
16:59:21 <elliott> jix: This is mainly just for code organisation, not exporting purposes.
16:59:26 <accel> ezyang: how do I disable that?
16:59:55 <ezyang> accel: Mmm, I usually fuck around with my system files, there's probably a better way though..... 
17:01:08 <elliott> Is it always possible to write an hs-boot file? :-)
17:01:21 <kmc> accel, i use vim, have not disabled anything, and have no trouble
17:01:26 <kmc> startup time is much quicker than emacs :D
17:01:49 <shachaf> I used to have very slow vim startup time.
17:01:50 <accel> hmm, weird thing is, it's only slow on the first *.hs file load
17:02:09 <accel> i.e., if I do "vim"; ":e foo.hs" ":e bar.hs" , then foo.hs is slow to load, but bar.hs is very quick
17:02:38 <ezyang> elliott: Should be. 
17:03:06 <elliott> ezyang: Except that no matter how I arrange it, either the modules don't see enough of each other, or the hs-boot file ends up circular.
17:04:42 <int80_h> :t writeFile
17:04:43 <lambdabot> FilePath -> String -> IO ()
17:05:15 <chopin> kmc > Can you look at my problem please? it s a detail that makes me crazy; i have data Value(int or string), i have Exp which can be a value, and i want to define < and > for them, by using "<"
17:05:37 <chopin> that s why i try to make an instance of (Ord Value)
17:07:31 <acowley> I have a dirty data structure that seems to leak when I put it in a Chan, but there is just no way at all to make a simple test case out of this to figure out what's wrong. MVars are fine, so that's what I'm using for my "queue" now.
17:08:45 <elliott> I'd just like to share this compiler error with you all: http://hpaste.org/43798/aaaargh
17:08:52 <int80_h> how can I use lambdabot to find out what module a function lives in?
17:09:01 <int80_h> err.. s/module/package
17:10:03 <elliott> Is there any way to avoid specifying the contents of a class in an hs-boot file? >_<
17:12:42 <acowley> int80_h: I guess you'd want a Hayoo plugin, but I don't know if such a thing exists
17:13:04 <elliott> ezyang: Eh, thanks for your help; I'm giving in and merging the two modules.
17:15:51 <elliott> Oh god, that just creates another cyclic dependency. It is unstoppable!
17:16:36 <ezyang> elliott: Perhaps incrementally rebuilding the modules will be a good thing to do. 
17:17:10 <elliott> ezyang: Let's put it this way: I think I understand why Foo.Types modules are so popular now.
17:17:19 <elliott> In fact I'm going to create one right now.
17:18:34 <int80_h> http://hpaste.org/43799/so_close_need_to_get_this_do
17:19:51 <dafis> Arrrrgh. I spent most of yesterday and today trying to fix a 20-25% performance regression and 50+% allocation increase with ghc-7 vs 6.12. I have no idea why that is, core is nearly identical. The main difference is that 6.12 produced $w$j1_sK7 :: GHC.Prim.State# GHC.Prim.RealWorld -> Hipp.Hipp let bindings while 7 left out the State# RealWorld, could that be it?
17:20:39 <elliott> int80_h: you need to run obtainCookies as a monadic action
17:20:48 <acowley> int80_h: You're too deep in the monads
17:20:50 <elliott> you can't treat it as a String
17:21:16 <elliott> int80_h: writeFile "formattedCookies.txt" =<< obtainCookies curl body
17:21:17 <elliott> should do it :)
17:21:26 <elliott> :t (=<<)
17:21:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:21:29 <elliott> just the reverse of >>=
17:21:33 <elliott> flipped, that is
17:21:36 <dmwit> do { s <- obtainCookies curl body; writeFile "fromattedCookies.txt" s } -- if you want to use do syntax
17:22:03 <acowley> -- but using =<< or >>= would be nicer
17:22:08 <acowley> :P
17:22:18 <Jesin> @undo do { s <- obtainCookies curl body; writeFile "fromattedCookies.txt" s } -- if you want to use do syntax
17:22:18 <lambdabot> obtainCookies curl body >>= \ s -> writeFile "fromattedCookies.txt" s
17:22:32 <Jesin> @. pl undo do { s <- obtainCookies curl body; writeFile "fromattedCookies.txt" s } -- if you want to use do syntax
17:22:32 <lambdabot> writeFile "fromattedCookies.txt" =<< obtainCookies curl body
17:22:42 <int80_h> dmwit: well, on one hand I want to use do syntax for the non-haskellers that will be reading my code. On the other hand I need to learn what is really going on and can benift from the de-sugared version.
17:23:06 <Jesin> the >>= version is not that hard to read
17:23:48 <Jesin> really I think
17:23:49 <Jesin> obtainCookies curl body >>= writeFile "formattedcookies.txt"
17:23:56 <Jesin> makes it pretty clear what's going on
17:24:31 <int80_h> hey you're right!
17:24:40 <int80_h> I should throw away that assumption
17:24:52 <Jesin> like, even non-haskellers should be able to understand that
17:25:02 <Jesin> if they can understand the do-notation
17:26:57 <int80_h> hmm, file is empty. After dinner I will step through my logic and see where things went wrong.
17:27:02 <Jesin> if you wanna be evil and obfuscating, you could do something like 
17:27:24 <int80_h> no evil! I am trying to inflitrate my company with Haskell
17:27:28 <Jesin> (fmap join fmap) (writeFile "formattedcookies.txt") . obtainCookies curl $ body
17:27:37 <Jesin> but yeah I just did that because it was fun to write
17:27:40 <Jesin> :p
17:27:47 <int80_h> well Haskell *is* fun.
17:28:00 <dafis> :t fmap join fmap
17:28:01 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
17:28:01 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
17:28:01 <lambdabot>     In the second argument of `fmap', namely `fmap'
17:28:06 <Jesin> aww
17:28:09 <Jesin> I got it wrong?
17:28:11 <Jesin> =/
17:28:16 <Jesin> oh wait
17:28:18 <Jesin> I remember now
17:28:27 <int80_h> bbl
17:28:47 <Jesin> (fmap join $ fmap (writeFile "formattedcookies.txt")) . obtainCookies curl $ body
17:28:49 <Jesin> there it is
17:28:51 <Jesin> :p
17:29:40 <Mathnerd314> :t fmap join . fmap
17:29:41 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
17:30:24 <Jesin> :t (=<<)
17:30:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:30:50 <Jesin> :t (.) join . fmap
17:30:51 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
17:31:00 <Jesin> waiiit
17:31:04 <Jesin> caleskell
17:31:06 <Jesin> right
17:31:33 <Jesin> :t (fmap :: (b -> c) -> (a -> b) -> a -> c) join . fmap
17:31:34 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
17:31:38 <Jesin> yaaaay
17:32:28 <Jesin> incidentally, ap a b = a >>= (`fmap` b) wherever liftM == fmap, which it always should
17:49:32 <gwern> I wonder how many people use threadscope
17:49:43 <gwern> I don't see much traffic mentioning it on the wiki, -cafe, or reddit
17:57:28 <copumpkin> gwern: pretty sure Simon Marlow found it pretty useful
17:57:46 <copumpkin> he mentioned it in one of his talks as being very handy for debugging subtle issues with GC and threading
17:57:50 <copumpkin> iirc
17:58:04 <gwern> the arch download statistics have it about 250 downloads, which looks to be near the median
18:06:52 <Gracenotes> k, I've worked out the rest of the kinks for hourly mirroring packages to http://sparky.haskell.org:8080/recent
18:07:52 <copumpkin> Gracenotes: so what's missing for a full move now?
18:07:59 <heis> Could somebody kindly explain what the RWS monad/transformer is for?  It's referenced all over the mtl, but isn't explained at all beyond reference to a Mark P Jones paper, which doesn't mention it by name.
18:08:17 <copumpkin> heis: gives you reader writer and state at once, from what I can tell
18:08:25 <copumpkin> although I had the same trouble finding out what it was
18:08:44 <heis> What is an example of its use?
18:09:01 <gwern> well, perhaps bounded logs
18:09:09 <Gracenotes> @unmtl RWS r s w a
18:09:09 <lambdabot> r -> w -> (a, w, s)
18:09:31 <gwern> the reader part is your usual configuration data; the writer is your logging info; and in the State, you keep track of how big the writer is and if it gets too long, you dump it and start over
18:09:53 <Gracenotes> @unmtl ReaderT r (Writer w a) a
18:09:53 <lambdabot> err: `(a, w)' is not a type function.
18:09:54 <heis> Thank you very much, makes quick sense
18:09:58 <Gracenotes> @unmtl ReaderT r (Writer w) a
18:09:59 <lambdabot> r -> (a, w)
18:10:13 <Gracenotes> @unmtl ReaderT r (WriterT (State s) w) a
18:10:14 <lambdabot> r -> w (a, State s)
18:10:24 <gwern> heis: I made that up entirely, I have no idea whether anyone would want to use the RWS transformer that way
18:10:25 * Gracenotes will stop spamming channel
18:10:39 <gwern> (although it seems possible or I wouldn't've said it)
18:10:53 <Gracenotes> copumpkin: http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0/Switchover
18:11:16 <gwern> '11. ["Webkit-based browser written in Haskell, similar in architecture to Xmonad"](http://www.reddit.com/r/haskell_proposals/comments/98vxo/webkitbased_browser_written_in_haskell_similar_in/): This is probably the worst single idea in the whole bunch. A web browser these days is an entire operating system, but worse, one in which one must supply and maintain the userland as well; it is a thankless task that will not benefit the Haskell community ...
18:11:19 <copumpkin> cool
18:11:22 <gwern> ... (except incidentally through supporting libraries). It is an infinite time sink - the only thing worse than this sort of SoC failing would be it succeeding.'
18:11:25 <Gracenotes> so... step 1 :)
18:11:31 <gwern> haha. I can be so mean. but I can't help it, I like that final quip
18:11:51 <djahandarie> lol gwern...
18:11:58 <copumpkin> gwern: I think it could be interesting, but probably not for the reason it was proposed
18:12:11 <Gracenotes> plenty of step 2 is done, and steps 6-9 are kind of all together
18:13:08 <gwern> hm. is DPH even usable right now?
18:13:42 <djahandarie> I think it's usable. Not sure if it's useful (yet).
18:14:27 <Gracenotes> I tried to build it once. don't seem to recall succeeding.
18:14:31 <djahandarie> Useful as in "Hey my program is a little slow, would be nice if I could make it faster: *tweak* done". Maybe "easy to use" would be a better phrase :)
18:16:24 <shepheb> anyone got an example of sending authenticated (not necessarily SSL/TLS) SMTP from Haskell? sendmail is broken on my shared host.
18:17:58 <banisterfiend> shepheb: hi, interesting question. However im very new to haskell -- my book just arrived in the mail after waiting more than a month --- so I can't help you with your question. Nonetheless im hoping that within the next short time period (hopefully no longer than a month) I will indeed be in a position where I can offer helpful advise and useful "tidbits" (which may include advice but probably more refers to sharing idioms and tips). Thanks.
18:18:29 <mmaurer> shepeb: Try checking the darcs source? I know it can send mail, but don't know if it relies on sendmail (I don't _believe_ it does, but haven't checked)
18:18:41 * djahandarie raises eyebrow
18:19:24 <Gracenotes> :o
18:20:05 <shapr> shepheb: install postmaster? http://gitorious.org/postmaster/mainline :-)
18:20:07 <heis> Would the difference between: (ReaderT s (WriterT s m) a) -- if that's actually a thing... I haven't actually tried using monad transformers yet, this is part of my initial noob stutter towards intuition -- and (StateT s m a), be that ReaderT/WriterT keeps its history and StateT does not?
18:21:30 <Gracenotes> throw a http://hackage.haskell.org/package/hsgnutls over it? o.o
18:21:58 <shepheb> snoyberg's Network.SMTP.Client uses sendmail
18:22:03 <shepheb> postmaster might work
18:22:17 <Funktorsalat> @unmtl ReaderT s (WriterT s m) a
18:22:17 <lambdabot> s -> m (a, s)
18:22:37 <mmaurer> heis: ReaderT/WriterT does not allow you to read and write the same state
18:22:47 <mmaurer> heis: You get one global constant, and one clobal data dump
18:22:49 <mmaurer> *global
18:22:55 <mmaurer> They don't get to be the same.
18:23:02 <Gracenotes> @unmtl ReaderT r (WriterT w m) a
18:23:03 <lambdabot> r -> m (a, w)
18:23:11 <heis> Why not?
18:23:16 <Gracenotes> like that, but r and w *happen* to be the same type
18:23:18 <Funktorsalat> yeah, the ReaderT's 'ask' will always return the argument passed to runReaderT
18:24:01 <Funktorsalat> while 'get' in the StateT will return whatever you last 'put'
18:24:46 <dafis> Holy Shit, I have a 7000 line monster
18:25:00 <dafis> I think I will try with NOINLINE :)
18:26:14 <Gracenotes> just 2000 more lines
18:26:40 <heis> ಠ_ಠ
18:27:17 <Funktorsalat> what happens when you exceed 9000? :o
18:27:46 <Funktorsalat> (anyway, are you somehow counting lines after inlining here?)
18:29:13 <dafis> Funktorsalat: core, that's what GHC made of a specialisation, thanks to inlining
18:31:27 * hackagebot haskell-src-exts-qq 0.4.0 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.4.0 (MathieuBoespflug)
18:32:24 <dafis> the specialisation for Int scores a measly 400 lines
18:38:18 <slack1256> i need an advice
18:38:25 <slack1256> which is the best monad tutorial from http://www.haskell.org/haskellwiki/Tutorials#Using_monads
18:38:48 <reacocard> slack1256: the best one is the one that works for you :)
18:38:49 <slack1256> a tutorial that cover all the monad (reader, writer) plus arrow 
18:39:32 <slack1256> i want something like "learn you a haskell for the great good" for monads :-)
18:42:12 <drbean> byorgey++ "Typeclassopedia"
18:45:02 <slack1256> mm from the monad.Reader issue 13
18:47:11 <kmc> slack1256, LYAH has a chapter on monads now
18:47:23 <kmc> i would avoid dedicated "monad tutorials"
18:47:35 <kmc> "Monad" is just the name of a generic API with lots of different, unrelated types that use it
18:47:42 <periodic> I've given up on monad tutorials.  I came to my own understanding of them by just using them.
18:47:45 <kmc> focusing too much on the API is bound to lead to trouble
18:47:47 <kmc> @where burrito
18:47:47 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
18:47:52 <kmc> see above ^^^^
18:48:36 <periodic> So I just learned about the Haskell Hackathon this weekend.
18:49:02 <periodic> I was wondering if the Yesod folks hang out in here or have their own channel.
18:49:09 <periodic> As that's what I wanted to work on this weekend.
18:49:34 <slack1256> mmm i know how to use then, but i want to master them >:-)
18:49:36 <monochrom> A very simple API (just 2 or 3 operators) with many different examples. But people tend to ignore the examples and become armchair philosophers by just hallucinating over the simple API.
18:50:23 <periodic> just keep using them.
18:50:35 <periodic> and use various libraries to be exposed to various ways they are used.
18:50:45 <monochrom> if you can use and create some of your own, you already master it.
18:51:03 <periodic> yeah, it's probably when I started making my own that it started making more sense.
18:51:10 <monochrom> people look for "deep insight" where there is none.
18:51:24 <periodic> though it feels like 90% of the monads I use are just Reader, Writer, Maybe, Either, State, and IO or some combination there of.
18:51:40 <monochrom> there are deeper "insights" in numerology than in numbers or monads.
18:51:51 <slack1256> mm maybe you are right monochrom, periodic
18:51:58 <slack1256> maybe just write my own monads
18:51:58 <dafis> periodic: no lists?
18:52:22 <periodic> dafis: I should stay the ones I make
18:52:40 <periodic> List is probably the monad I use the most.
18:55:18 <HaskellNoob> hello
18:55:30 <periodic> hi
18:55:42 <HaskellNoob> first time using IRC Haskell
18:56:20 <HaskellNoob> i barely started reading the "Real World haskell" book
18:56:45 <HaskellNoob> I am very excited about Haskell. It was a tough decision deciding between Haskell and Earlang
18:57:22 <mzero> are you in the SF bay area, HaskellNoob?
18:57:26 <banisterfiend> HaskellNoob: considerniug you cant even spell erlang i dont think it could be so tough
18:57:36 <tg_> albequcue?
18:57:39 <HaskellNoob> lol
18:57:39 <tg_> however you spell that name
18:57:45 <mzero> duke, duke, duke, duke of Earl(ang).....
18:57:46 <banisterfiend> mzero: $10 says he's from bombay
18:57:53 <monochrom> unless you have only half a year to live, there shouldn't be a tough decision between any pair of languages.
18:57:55 <tg_> i think i mixed a city and a type of sauce
18:57:59 <HaskellNoob> nope, USA baby
18:58:00 <djahandarie> banisterfiend, hey, keep it friendly man, lol
18:58:04 <tg_> monochrom: here here
18:58:12 <tg_> hear hear!
18:58:20 <banisterfiend> djahandarie: hehe, sorry
18:58:31 <HaskellNoob> let me tell you, it was a tough decision
18:58:52 <mzero> it should be no decision: you should learn a language a month!  Learn 'em both
18:59:00 <HaskellNoob> Haskell is better as a language than Earlang but with no real job opportunities
18:59:11 <djahandarie> I think it might be hard to learn Haskell hard in a month :)
18:59:11 <mzero> well, if you're in the Bay Area there is a "Learn Haskell Workshop" free this weekend
18:59:12 <tg_> now that's not as good of advice
18:59:25 <Gracenotes> mzero: time to book a flight!
18:59:29 <HaskellNoob> a language a month??
18:59:35 <tg_> unless you're a savant or d. knuth, I think it might be appropriate to spend more than a month
18:59:48 <banisterfiend> does haskell have anything like gem-testers.org ?
18:59:50 <slack1256> if it isn't C#/php/java you also have not real job opportunities
18:59:56 <gwern> 'learn a new language in 10 years'
19:00:04 <djahandarie> HaskellNoob, there are job opportunities if you're good.
19:00:12 <tg_> banisterfiend: I don't think so
19:00:36 <HaskellNoob> I know but not as many as Java or C++. You know mainstream languages
19:01:08 <djahandarie> http://functionaljobs.com/ not _all_ of these are Haskell jobs, but Haskell would probably look good on your resume for any of those jobs ;)
19:01:08 <tg_> HaskellNoob: quality > quantity
19:01:18 <HaskellNoob> I currently program in python but I started to love Haskell
19:01:36 <HaskellNoob> hard to change the way you think about solving problems
19:01:52 <Gracenotes> life is too short for learning languages
19:02:18 <monochrom> lift is too short for more than 10 real job opportunities actually
19:02:55 <HaskellNoob> Why everybody complains about Nomads??
19:03:08 <HaskellNoob> I heard they are hard to understand and to use?
19:03:12 <copumpkin> because they're silly, and they're monads
19:03:20 <copumpkin> don't worry about them
19:03:21 <HaskellNoob> lol, sorry
19:03:26 <copumpkin> people make a bigger deal of them than they're worth
19:03:36 <HaskellNoob> so what are they??
19:03:55 <copumpkin> I don't mean to sound condescending, but you don't have the knowledge to understand the answer without learning a lot more haskell :P
19:04:11 <tg_> life's too short to not be learning every day.
19:04:13 <monochrom> resumably if you are good, you already have a secure job (or you have enough bargaining chips to get any job you want). from then on whatever reason you learn another language, it is not for jobs, you already have one.
19:04:16 <copumpkin> they're an abstract way of thinking about how computation works
19:04:20 <copumpkin> or certain forms of it do
19:04:23 <monochrom> s/resumably/presumably/
19:04:29 <HaskellNoob> you may be right, but give it a try
19:04:51 <gwern> nomads are problematic because if you give them too much money, they'll blow it on camel races, and if too much weapons, they'll blow you away. and they smell.
19:05:15 <monochrom> conversely if you are bad, knowing all the world's languages won't help you very far
19:05:15 <HaskellNoob> lol, I already learned that they are called Monads
19:05:15 <copumpkin> HaskellNoob: I can't answer "what are they" without scaring you off, but I can say that they're a "design pattern" that we can represent as concrete code, and they often correspond to what many would call an EDSL
19:05:28 <tg_> gwern: I think you're thinking of gypsies. Nomads are a computational abstraction related to category theory.
19:05:47 <gwern> tg_: how dare you! my grandmother was sold a bad horse by a nomad!
19:05:53 <copumpkin> HaskellNoob: the special feature the EDSL provides is the ability to bind variables in the language
19:06:16 <monochrom> "what is ___" is a counterproductive philosophical question. what are you? who cares. ask how to use ___ .
19:06:18 <djahandarie> (EDSL is kind of a Haskell term so it might be useful expanding that acronym :P)
19:07:00 <copumpkin> not really a haskell term
19:07:06 <HaskellNoob> I do a lot of python web programming, how good is haskell at web programming??
19:07:08 <copumpkin> but it's an embedded domain-specific language
19:07:09 <Gracenotes> EDSL used to exist in other languages, but they were so terrible now we own the trademark
19:07:17 <djahandarie> "Not really". But it's really only used commonly here
19:07:24 <kmc> there are lots of C++ EDSLs marketed as such
19:07:35 <kmc> you can go down that rabbit hole if you like
19:07:37 <Gracenotes> hah yeah. like that CFG parser? omfg
19:07:39 <copumpkin> HaskellNoob: there are three (or two) main "live" web frameworks these days
19:07:44 <kmc> i don't recommend it for getting work done, but C++ is an interesting esolang
19:08:01 <gwern> huh. it's kind of sad that I have to go to the internet archive to get Google Summer of Code proposals from befoer 2009. if even google can't keep its webpages up for more than a year or two...
19:08:16 <gwern> digital dark ages. we haz them.
19:08:23 <kmc> they had software in 2009? i thought people wrote on clay tablets back then
19:08:55 <gwern> kmc: progress has been so blinding in the '00s that you can be forgiven for being off by a year or two
19:09:12 <HaskellNoob> only two main web frameworks?? How about webservers??
19:09:51 <monochrom> some web frameworks come with servers
19:10:02 <HaskellNoob> Is it easy to host a haskell web application? Does it use CGI??
19:10:34 <HaskellNoob> python is now using WSGI
19:10:36 <Gracenotes> this is a fun EDSL: http://www.boost.org/doc/libs/1_45_0/libs/spirit/doc/html/spirit/introduction.html
19:10:52 <monochrom> but I am not sure of the merit of "does L have a web server" whenever you encounter another language L.
19:11:06 <Gracenotes> the one I was looking for. Boost Spirit. if x is a symbol, (*x) is the kleene star of it
19:11:16 <Gracenotes> << is concatenation
19:11:22 <Gracenotes> etc.
19:11:57 <Gracenotes> | is union of course.
19:12:09 <blueonyx> :t uncurry
19:12:10 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:12:24 <monochrom> is it arabic regular expressions? i.e., you write "b << *x" for "x* d"? :)
19:13:06 <HaskellNoob> monochrome: How do you host a Haskell web application. Are there any web hosts that support haskell??
19:13:18 <monochrom> I don't know. I haven't done it.
19:13:25 <HaskellNoob> anybody??
19:14:13 <parcs> HaskellNoob: you'll need a VPS to host a Haskell web application
19:14:20 <gwern> wow. revising the 2008 SoC judgements, it was an atrocious year
19:14:43 <gwern> just 2 out of 7 were clear successes
19:15:22 <copumpkin> that's cause I wasn't a member of the community at the time
19:15:32 <gwern> I flipped gmap to unsuccessful when I saw there were *0* reverse dependencies on it, which is pretty rubbish for a data structure library, and the ghc pass plugin since it *still* hasn't been merged into HEAD
19:15:46 <gwern> 3 years! still languishing as a ticket
19:15:51 <copumpkin> gwern: I'd consider that a success anyway
19:15:55 <copumpkin> people keep saying it should be
19:15:59 <gwern> copumpkin: which one/
19:16:07 <copumpkin> it's not unmerged because of any of its own shortcomings
19:16:10 <copumpkin> the plugins
19:16:22 <HaskellNoob> Are there any commercial web applications running that use Haskell??
19:16:23 <copumpkin> thoughtpolice is pushing for it extra hard now
19:16:27 <gwern> copumpkin: if it's not merged, it can't be used. if it's not used, it's a failure
19:16:28 <copumpkin> HaskellNoob: probably
19:16:41 <copumpkin> gwern: that's a silly metric
19:16:55 <gwern> copumpkin: no, it's a perfectly fine metric that isn't the one you are using
19:17:01 <HaskellNoob> Ok I will do some research on Haskell web Apps
19:17:09 <copumpkin> gwern: fine, be caustic
19:17:14 <HaskellNoob> See ya guys
19:17:31 <gwern> copumpkin: SoC isn't about 'oh let's pay some students to write some interesting stuff to throw away'
19:17:37 <gwern> that's what universities are for
19:18:00 <copumpkin> my point is that there's been a lot of talk recently (past couple of weeks) in #ghc about merging it
19:18:31 <gwern> copumpkin: well, when they do, I'll flip it back to 'Successful?'
19:18:42 <monochrom> if it is merged, will you flip it from "failure" to "success"?
19:18:53 <monochrom> lag. nevermind.
19:19:36 <shachaf> gwern: Are you coming to the Hackathon?
19:19:59 <gwern> shachaf: dunno. I have yet to be arsed to buy a plane ticket although I managed to beat procastination on a number of things today
19:20:19 <monochrom> haha
19:20:30 <Gracenotes> I'll be in the bay area in the summer
19:20:45 <Gracenotes> you could delay it by a few months ;)
19:21:03 <shachaf> gwern: It's this weekend, you know.
19:21:10 <gwern> I know!
19:21:26 <shachaf> Gracenotes: I'm not to blame for the schedule.
19:21:54 <periodic> I only just found out about it today via a comment on HackerNews.  That's what I get for being out of touch with the community lately.
19:22:02 <periodic> Good thing I live close by.
19:22:17 <Gracenotes> :P
19:22:18 <periodic> Sounds like attendance will be pretty strong.
19:22:29 <shachaf> periodic: Yes, I hear it'll be a big event.
19:22:35 <shachaf> *Dozens* of Haskell programmers.
19:22:52 <periodic> One Java terrorist and the whole language would die out.
19:23:16 <copumpkin> preflex: seen edwardk
19:23:17 <preflex>  edwardk was last seen on #haskell 21 hours, 11 minutes and 45 seconds ago, saying: lets RULES pragmas be less paranoid about duplicating works
19:23:39 <copumpkin> man, we need to get edwardk to arrange for the boston haskell meetup to coincide with conor's visit
19:23:53 <shachaf> periodic: How in-the-area are you?
19:24:00 <periodic> Santa Clara
19:24:05 <periodic> < 10 mi away
19:24:09 <NemesisD> is it considered harmful to implement an instance of show for the sake of pretty-printing a type rather than using it as a counterpart to read?
19:24:11 <shachaf> Ah.
19:24:21 <periodic> Friday also happens to be the last day of my job, which is also in Mountain View.
19:24:44 <periodic> What better way to celebrate freedom than a Haskell hackathon? I'm excited.
19:25:31 <shachaf> periodic: There's a Bay Area Haskell meeting tomorrow too, I hear.
19:25:52 <periodic> Is that a regular thing?
19:26:00 <shachaf> Monthly, I believe.
19:26:06 <sproingie> where is that?
19:26:07 <periodic> I tried to look around about a year ago for bay area haskell groups but couldn't find anything.
19:26:15 <shachaf> San Francisco.
19:26:24 <djahandarie> I've been to that and I don't even live in SF!
19:26:27 <djahandarie> Or california!
19:26:31 <djahandarie> Or the west coast!
19:26:43 <periodic> Do you guys usually meet up on the peninsula?
19:26:51 * shachaf has only been to one meeting.
19:27:08 <periodic> found the google group...  Doesn't allow free membership?
19:27:14 <shachaf> Free?
19:27:19 <periodic> as in you can just join
19:27:26 <shachaf> They make you run a Haskell program or something to subscribe.
19:27:30 <shachaf> But you can still see the messages.
19:27:34 <periodic> there's an "apply for group membership" link
19:27:39 <shachaf> I guess they had a spam problem.
19:27:51 <periodic> oh, I see.
19:27:54 <rothwell> lovely... jhc actually built
19:27:58 <rothwell>  \o/
19:28:12 <periodic> yay fibonacci sequences.
19:28:12 <gwern> rothwell: now you just need a few gigs of spare ram to compile hello world
19:28:20 <periodic> I could write a book about the Fibonacci sequence...
19:28:29 <gwern> rothwell: but on the plus side, hello world will be like 1k and run instantly
19:28:36 <rothwell> hehe
19:28:54 <rothwell> i have 11873mb free... should cover it, hopefully!
19:28:55 <shachaf> periodic: Where was your day job in Mountain View? Did they not allow Haskell? :-)
19:28:58 <gwern> reportedly HEAD JHC can also compile fibonacci
19:29:07 <companion_cube> http://pastebin.com/TjptTZM8 could someone help me improve the style of this ? (parsec)
19:29:16 <periodic> CyberSource, now owned by Visa
19:29:23 <periodic> it was a soul-crushing enterprise software job.
19:29:28 <periodic> Java, and bad Java at that.
19:29:32 <periodic> I lasted 7 months.
19:30:00 <rothwell> periodic: i'm just about to work with the cybersource SOAP API for my job...
19:30:30 <periodic> rothwell: I'm allowed to caution you. :P
19:30:38 <rothwell> periodic: argh!
19:30:38 <periodic> er, I'm not sure I'm allowed
19:30:39 <periodic> I mean.
19:30:52 <rothwell> i'll just be horribly, horribly afraid and leave it at that
19:31:19 <periodic> I have to admit, they do process a lot of transactions with good uptime, so for that I applaud them.
19:31:25 <periodic> I left mostly because it's not my style.
19:32:07 <periodic> They have a very corporate culture that fears change.  But the whole payment industry is like that I hear.
19:32:16 <periodic> So now I'm going to start some freelancing, and hopefully work some more Haskell into it.
19:33:21 <shachaf> periodic: Will you be at the Hackathon? :-)
19:33:41 <periodic> shachaf: I'm planning on it.  Signed up today and cleared my weekend.
19:33:41 <gwern> shachaf: as one of the unemployed, I'm sure he will
19:34:03 <periodic> gwern: hey, I have meetings on Friday!
19:34:14 <gwern> yeah, meetings with your guild amirite
19:34:28 <shachaf> gwern: I'm sure that the majority of the unemployed will not be there.
19:34:46 * shachaf is employed but plans to be there.
19:34:46 <periodic> exit interviews, end-of-sprint demo and retrospective
19:34:57 <shachaf> (To be fair, I work next door to the building it'll be in.)
19:35:23 <periodic> shachaf: where do you work?
19:36:06 <gwern> whoa
19:37:49 <shachaf> periodic: E Dana St.
19:38:46 <periodic> I meant the company you keep.  I know where the Dojo is.
19:38:59 <gwern> periodic: he keeps the finest company, as evidenced by #haskell
19:39:21 <periodic> gwern: obviously.
19:39:26 <periodic> why do I ask such silly questions.
19:39:27 <djahandarie> Indeed.
19:39:36 <shachaf> periodic: RethinkDB.
19:39:39 * djahandarie smokes an expensive cigar
19:39:42 <gwern> there is much worse company. 'I broke my fast with a troop of thieves, who laughingly assured me they had dined on the rarests of meats. Shuddering, I was grateful to leave their company.'
19:39:42 <shachaf> No Haskell, sadly.
19:40:36 <Gracenotes> RethinkDB! :D
19:40:53 <periodic> shachaf: well, sounds reasonably interesting at least.
19:41:45 <shachaf> periodic: Yes, it's fun. And ~half of the people here are Haskellers, so it's almost OK. :-)
19:41:49 * shachaf tries to stay on-topic.
19:42:27 * djahandarie notes that shachaf's picture on that site is just some geometrical shape rather than a real picture like all the other ones
19:42:43 <Gracenotes> he's a multidimensional being
19:42:52 <shachaf> djahandarie: I'd argue that geometrical shapes are much more real than any of those other pictures.
19:43:15 <Gracenotes> that's his most anthropomorphic projection into our world
19:43:22 <djahandarie> The other pictures are fake? :P
19:43:44 <shachaf> djahandarie: Well, they're as "real" as photographs can get.
19:43:52 <djahandarie> ...I see.
19:43:53 <periodic> I feel a little weird in that I don't seem to meet real Haskellers out in the world. 
19:44:08 <Funktorsalat> geometrical shapes live several turtles below photos?
19:44:21 <djahandarie> I don't meet any unless I actively try :P
19:44:33 * djahandarie has been to a Boston Haskell meetup also
19:44:46 <periodic> djahandarie: that's how I feel.  Makes me wonder if I'm a little crazy sometimes.
19:45:05 <Funktorsalat> gwern: that doesn't yield any google results. Did you make it up? ;)
19:45:19 <djahandarie> According to haskellers.com there is only one other Haskeller in my state
19:45:25 <Funktorsalat> or is it literature that is :O not on the web
19:45:40 <djahandarie> I imagine that isn't true since Yale is in my state but apparently those people don't care about meeting other people. :P
19:45:46 <Gracenotes> when will next boston/phi/nyc meetup be? :o
19:45:52 <gwern> Funktorsalat: yeah, it came to me while walking
19:45:57 <shachaf> djahandarie: Maybe they don't need the Internet to meet other Haskellers.
19:46:02 <shachaf> djahandarie: Since they're all there.
19:46:03 <gwern> Funktorsalat: but it's a cool 2 sentences isn't it? it suggests a whole story
19:46:14 <djahandarie> shachaf, maybe...
19:46:53 <Funktorsalat> gwern: yes, though it seems like they're not just thieves if 'rarest of meats' means what I suspect :o
19:47:09 <gwern> Funktorsalat: and what's that?
19:47:49 <Funktorsalat> it sounds like... people. or maybe some endangered species
19:48:00 <gwern> so... rarest meats is people?
19:48:13 <Funktorsalat> I reckon it is pretty rare
19:48:19 <shachaf> Humans aren't all that rare.
19:48:30 * gwern stifles the chuckling. the things I do for a simple joke on 'soylent green is people'
19:49:38 <Funktorsalat> I suppose they were just talking about expensive regular meat they had stolen
19:49:56 <sproingie> who wants a spotted owl drumstick?
20:04:23 <gwern> ok, I guess I'm done with today's work on http://www.gwern.net/Haskell%20Summer%20of%20Code.html
20:04:33 <shepheb> why would a Network.Socket socket time out on a connect when telnet works perfectly from the same host?
20:04:41 <gwern> any comments before I submit it on reddit?
20:05:41 --- mode: holmes.freenode.net set +o ChanServ
20:27:13 <NihilistDandy> I'm looking for input on setting up emacs for Haskell. Any opinions on must-haves in .emacs? I've got haskell-mode and flymake hooked in right now
20:30:05 <danblick> I'm wondering, if "data Prod = Prod Int Int" is a product type and "data Sum = Left Int | Right Int" is a sum type, is there a good term for describing more complex types like "data Foo = Foo1 Int Int | Foo2 Int String"?
20:30:58 <rwbarton> You can call it a "sum of products"
20:31:04 <Cale> danblick: Algebraic type or polynomial type.
20:31:27 <Jesin> ooh
20:31:32 <Jesin> what about logarithms!  :P
20:31:51 <djahandarie> Define exponents first :)
20:32:08 <danblick> Good ideas, thanks :)
20:33:12 <Cale> log(1/(1-x)) would have a meaning, but log on its own, probably not :)
20:33:48 <djahandarie> (Maybe a display morphism? They are exponentiable in the category of contexts ;))
20:34:02 <djahandarie> Cale, what would that mean?
20:34:23 <shapr> NihilistDandy: iirc, there's a cabal-mode
20:34:29 * djahandarie hasn't actually seen logs or exponentiation used anywhere near type theory 
20:35:17 <Jesin> well
20:35:18 <shapr> I'm not even sure how to describe all of my .emacs customizations for Haskell, they've evolved over the past several years....
20:35:30 <Cale> Well, differentiating it gives (1/(1-x)) = 1 + x + x^2 + x^3 + ... which is the type of lists
20:35:30 <Jesin> there's R^3
20:35:40 <Jesin> but that's not type^type
20:35:43 <Cale> and so it's something which if you put a hole in it, you get a list
20:35:49 <Cale> What is like that? A cycle!
20:35:53 <Jesin> that's just iterated product
20:36:42 <Jesin> ...wait, putting in a hole is differentiating?
20:36:48 <NihilistDandy> shapr: Haha, yeah, mine's quite a thing, too
20:36:51 <Cale> yeah
20:37:08 <NihilistDandy> shapr: Though it covers Lisp, Scheme, Haskell, and Erlang, so...
20:37:23 <Jesin> how?
20:37:27 <Jesin> eh
20:37:28 <Cale> Think about the product rule: (fg)' = f'g + fg' -- a hole in a product is either in the left or right part
20:37:32 <Jesin> I have to go =/
20:37:39 <Jesin> cya
20:41:43 <int80_h> I have a [Maybe String], is there a function that will strip out the Nothings w/out returning an error? Example foo ["Just bar",Nothing] would return "bar". Or do I have to hardcode that?
20:42:07 <Gracenotes> :t catMaybes
20:42:08 <lambdabot> forall a. [Maybe a] -> [a]
20:42:11 * danblick is now trying to figure out analogs to (x + y) (x + y) = x^2 + 2xy = y^2
20:42:31 <int80_h> I used catMaybes, it throws an exception when it gets a Nothing
20:42:45 <Gracenotes> that's... not normal catMaybe behavior
20:42:45 <int80_h> would I have to right code to handle that?
20:42:56 <Gracenotes> you sure you're not assuming there's an element, using head or tail or something?
20:42:57 <int80_h> hmm, maybe I misunderstood my errorsa
20:43:04 <int80_h> yeah I used last
20:43:40 <int80_h> okay, I was going in the wrong direction.Misunderstood my error
20:45:34 <gwern> arrrrgggh why does reddit have to be done *today*
20:45:43 <periodic> done?
20:45:48 <gwern> *down
20:46:07 <periodic> there are days it isn't down?
20:46:16 <NihilistDandy> gwern: http://www.reddit.com/r/nihilism/
20:46:33 <gwern> how soothing
20:46:50 <NihilistDandy>  /r/nihilism is always working
20:47:27 <int80_h> yeah, but what's the point of going to /r/nilhism?
20:47:31 <Gracenotes> so is http://www.reddit.com/r/rainbowbar
20:48:00 * int80_h was amused by his own joke.
20:48:11 <NihilistDandy> :D
20:48:17 <NihilistDandy> I linked to /r/nihilism in another channel, and no one got it :/
20:48:37 <Gracenotes> /r/nihilism is the only rational response to the absurdity of reddit being down
20:48:53 <periodic> Ha, I love the nihilism sub-reddit.
20:48:58 <periodic> what happens if you add it to your home page?
20:49:00 <periodic> can you?
20:49:15 <NihilistDandy> What would be the point of that?
20:49:19 <int80_h> reddit can't be down! I can't hear you *la* *la* *la*
20:49:49 <periodic> I'd just enjoy making the nihilism page my reddit home page to remind me to get back to work.
20:50:14 <Gracenotes> what other responses are their there to absurdity? /r/dada?
20:50:21 <NihilistDandy> periodic: That's actually not a bad idea
20:50:36 <int80_h> /r/flaxtonne
20:50:39 <Gracenotes> so, anyone planning on contributing poems or artwork to Monad.Reader?
20:51:00 <int80_h> what's the due date?
20:51:05 <Gracenotes> compose a lovely Pushkin sonnet
20:51:19 <NihilistDandy> The 18th
20:51:27 <Gracenotes> grafitti haskell symbols all over Glasgow
20:51:45 <shapr> NihilistDandy: Clearly there should be a HaskellWiki page dedicated to emacs awesomeness.
20:51:56 <Gracenotes> tape meetup advertisements squirrels
20:52:00 <Gracenotes> +to
20:52:04 <shapr> NihilistDandy: I had a list around here somewhere... it included hlint and a bunch of other nifty tools.
20:52:14 <int80_h> well, my life *was* forever changed when I met haskell. I could write a love poem.
20:52:20 <NihilistDandy> shapr: Well, there is, to some degree, but I enjoy getting input from other people
20:52:26 <int80_h> it was rough at first. One again and off again.
20:52:30 <int80_h> s/one/on
20:52:37 <gwern> eh. I'm happy with my ghci/hlint integration
20:52:49 <gwern> on a side note, .ghci is one of the foulest extension mechanisms I've ever dealt with
20:52:51 <int80_h> I was too young for the kind of commitment haskell needed
20:53:18 <shapr> gwern: What would be better? ~/.GHCI.hs ?
20:53:36 <gwern> shapr: something like xmonad.hs would not be amiss
20:56:59 <NihilistDandy> On a different note, any packages I absolutely should get to improve the overall haskell experience? Getting hlint, now
21:03:46 <int80_h> http://hpaste.org/43803/trying_to_use_mapm
21:04:24 <int80_h> any le help?
21:06:08 <dafis> int80_h: if you use the results, use mapM and not mapM_
21:06:33 <dafis> mapM_ is for when you want to throw away the results
21:06:40 <dafis> :t mapM_
21:06:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:06:56 <int80_h> ack
21:07:28 <int80_h> new error
21:08:25 <int80_h> http://hpaste.org/paste/43803/trying_to_use_mapm__annotatio#p43804
21:08:40 <int80_h> dafis: thanks for catching that. It revealled the real problem.
21:08:43 <dafis> int80_h: obtainCookies gives an m [String], so mapM (obtainCookies ...) gives an m [[String]]
21:08:55 <int80_h> hmm
21:09:04 <dafis> writeFile wants a String, so two concats
21:09:20 <dafis> or unlines and concat
21:09:25 <dafis> or something
21:09:39 <int80_h> concat $ concat $ fooString
21:09:43 <int80_h> is that rigt?
21:10:03 <dafis> int80_h: I suppose obtainCookies returns the list of cookie-texts
21:10:18 <dafis> :t concat . concat
21:10:19 <lambdabot> forall a. [[[a]]] -> [a]
21:10:27 <dafis> :t unlines . concat
21:10:28 <lambdabot> [[String]] -> String
21:10:40 <int80_h> yeah, I'm not sure what it looks like. I assumed the last element would be the string I wanted. I'm just going to print them all
21:11:45 <int80_h> >     Right body -> unlines . concat $ mapM (obtainCookies curl body) >>= writeFile "formattedcookies.txt"
21:11:46 <lambdabot>   <no location info>: parse error on input `->'
21:11:54 <int80_h> is that right?
21:12:01 <int80_h> because I'm still getting an error
21:12:14 <dafis> int80_h: for writing to file, I expect mapM (obtainCookies ...) >>= writeFile "Foo" . unlines . concat to be the method of choice
21:12:43 <int80_h> dafis: hmm, the order there is baffling
21:13:09 <dafis> why?
21:13:17 <int80_h> unlines . concat is the same as (unlines(concat)) right?
21:13:47 <dafis> int80_h: no, (unlines . concat) strings == unlines (concat strings)
21:14:30 <int80_h> hmm, okay I see that
21:14:41 <dafis> int80_h: you could also use `fmap {- or liftM -} (unlines . concat) (obtainCookies ...) >>= writeFile "Foo"
21:15:14 <int80_h> ooh I like that. I need to get used to fmap. I see it everywhere
21:15:28 <int80_h> besides, it lookes closer to how I imagine the flow
21:16:13 <dafis> int80_h: for any law-abiding Monad (which also has a Functor instance), it's the same as liftM
21:16:54 <int80_h> doh, I'm almost there
21:17:09 <int80_h> >     Right body -> fmap (unlines . concat) (obtainCookies curl body) >>= writeFile "formattedcookies.txt"
21:17:10 <lambdabot>   <no location info>: parse error on input `->'
21:17:27 <int80_h> isn't what I did, what you said?
21:17:46 <dafis> int80_h: indentation?
21:17:58 <int80_h> expected type IO [[String]]
21:18:10 <int80_h> inferred type IO [String]
21:18:29 <int80_h> I've got this all on one line. I'll indent when I have it working.
21:18:36 <int80_h> I'll paste it
21:19:16 <int80_h> http://hpaste.org/paste/43803/trying_to_use_mapm__annotatio#p43805
21:19:19 <dafis> int80_h: yah, got fooled by the mapM_, you obtainCookies only for one String, so leave out the concat, unlines is what you want
21:20:00 <int80_h> j00 roolz!
21:20:04 <int80_h> well it compiles anyway
21:20:14 <int80_h> let's see if I can write a file with text in it
21:20:36 <int80_h> shit, still empty
21:20:56 <dafis> int80_h: can you try a little printf-debugging?
21:20:56 <int80_h> hmm, I just have to step through my logic
21:21:07 <int80_h> oh yeah I just learned we have printf
21:21:33 <dafis> int80_h: you need not use that, putStrLn is fine
21:22:10 <dafis> int80_h: I meant, that you let it print out what it gets while it runs, may help pinpointing the problem
21:22:30 <int80_h> dafis: yeah prior to haskell that was my primary debugging tool
21:23:01 <int80_h> I've been at this for about 9 hours. I'll pick this up tomorrow
21:23:06 <int80_h> thanks for your help :)
21:23:57 <dafis> int80_h: so, in obtainCookies, for example, list <- mapM (flip ...) ...; liftIO (print list); return (catMaybes list)
21:24:16 <dafis> to see whether you get anything at all
21:24:19 <int80_h> hmm I'll just try this now. Okay :)
21:29:24 <int80_h> dafis: the mystery embiggins. I get a list of Nothings
21:30:02 <dafis> int80_h: Okay, so add debugging output to curlResp2
21:30:08 <int80_h> yup
21:30:23 <int80_h> I htink I know where the nothing comes from, ust don't know why
21:30:33 <dafis> int80_h: where?
21:31:09 <dafis> int80_h: code for curlResp2?
21:31:11 <int80_h> dafis: in getCookies
21:31:20 <dafis> code for that?
21:31:27 <int80_h> lookup returns a Nothing if it doesn't find the searched for string
21:31:37 <int80_h> pasting...
21:31:37 <dafis> int80_h: right
21:31:39 <banisterfiend> dafis: do you think ducks can learn haskell
21:31:40 <banisterfiend> im a duck
21:31:44 <banisterfiend> just wondering if im wasting my time
21:32:09 <dafis> banisterfiend: if humans can, why shouldn't ducks?
21:32:25 <int80_h> http://hpaste.org/paste/43803/trying_to_use_mapm__annotatio#p43806
21:32:35 <banisterfiend> dafis: cos i all i care about is bread crumbs and swimming, and raising my young duck family
21:32:47 <int80_h> well, ducks have been held back since the "No Ducks Here" Act of 1890
21:32:59 <banisterfiend> ye
21:33:02 <banisterfiend> quack
21:33:15 <dafis> :t find
21:33:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:34:32 <int80_h> I'd like to see what hdr
21:34:48 <dafis> int80_h: replace lookup "Cookie" with find (("ookie" `isInfixOf`) . fst) and `fmap snd' the result
21:35:52 <dafis> or (uncurry (++)) instead of fmap snd, to see what the header title is
21:37:05 <dafis> getCookies = fmap (uncurry (++)) . find ("ooki" `isInfixOf` . fst)
21:38:40 <int80_h> else printparse error
21:38:43 <int80_h> I mean
21:38:45 <int80_h> parse error
21:39:18 <int80_h> > getCookies = fmap (uncurry (++)) . find ("ooki" `isInfixOf` . fst)
21:39:18 <dafis> getCookies = fmap (uncurry (++)) . find (("ooki" `isInfixOf`) . fst)
21:39:18 <lambdabot>   <no location info>: parse error on input `='
21:39:21 <dafis> oops
21:39:26 <int80_h> SessionCreator.lhs:145:62: parse error on input `.'
21:39:54 <dafis> that's without the new parens, is it?
21:40:01 <int80_h> ya
21:40:05 <int80_h> compiling new parens
21:40:11 <dafis> should work with 'em
21:40:32 <int80_h> ZI need to import moudle for find and isInfixOf
21:40:40 <dafis> int80_h: for isInfixOf, you need Data.List
21:40:45 <int80_h> @hoogle find'
21:40:45 <lambdabot> No results found
21:40:48 <int80_h> @hoogle find
21:40:49 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
21:40:49 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
21:40:49 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
21:41:03 <dafis> also for find
21:41:59 <int80_h> dafis: Getting closer. It picks up the "Set-Cookie" lines
21:42:09 <int80_h> I need it to pick up the "Cookie" lines
21:42:12 <int80_h> almost there
21:42:47 <dafis> @hoogle (a -> Bool) -> [a] -> [a]
21:42:48 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
21:42:48 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
21:42:48 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
21:43:25 <dafis> int80_h: s/find/filter/ and change the type to [String]
21:43:57 <dafis> or try ("Cook" `isPrefixOf`) in find
21:44:37 <int80_h> I'll try Cook, I would need to change alot of code changing Maybe String
21:46:06 <int80_h> dafis: Warrior needs slep, badly. But you have given me a direction to go in
21:46:17 <pastorn> int80_h: use the maybe monad :)
21:46:24 <int80_h> almost therebtw, "Cook" yields same output. It's grabbing all the Set-Cookie lines
21:46:44 <dafis> int80_h: isPrefixOf instead of isInfixOf
21:46:53 <int80_h> ah!
21:47:40 <int80_h> list of Nothings again
21:47:54 <int80_h> I need to examine the raw data
21:48:07 <int80_h> I htink I know what is there. But there's a discrepency
21:48:48 <int80_h> can you help me print out hdr?
21:49:18 <int80_h> else liftM print hdr ; return newCookies
21:49:30 <int80_h> is that what the new curlResp2 looks like?
21:49:51 <dafis> int80_h: I've no idea how curlResp2 looks like
21:50:39 <dafis> int80_h: maybe insert a `liftIO (print hdr)' unconditionally
21:50:46 <int80_h> http://hpaste.org/paste/43803/trying_to_use_mapm__annotatio#p43806
21:51:18 <dafis> that was getCookies
21:51:53 <int80_h> http://hpaste.org/paste/43803/trying_to_use_mapm__annotatio#p43807
21:52:52 <int80_h> dafis: it would seem I am only getting the server response, which has no Cookie field
21:52:53 <dafis> int80_h: okay, else liftIO (print hdr) >> return newCookies
21:53:03 <int80_h> so I am asking for the wrong thing!
21:53:04 <int80_h> doh
21:56:27 <int80_h> dafis: thanks, you helped me pinpoint this
21:56:38 <int80_h> now I have to stay to see this through. though I am dead tired
21:56:56 <dafis> int80_h: I'm curious, where are the cookies supposed to be?
21:57:36 <dafis> int80_h: if it helps, I'm up nearly 24 hours now and haven't slept the night from Sunday to Monday :)
22:02:21 <int80_h> dafis: in the request header. I've been farming the response header
22:02:35 <int80_h> I'm learning HTTP & Haskell at the same time
22:02:45 <int80_h> anyway I gotta sleep
22:03:10 <dafis> int80_h: I don't know HTTP, can't help you much there
22:05:10 <Axman6> http is something that you shouldn't have to know all that well, that's what libraries are for
22:46:12 <Wooga> how do i construct Iteratee from iteratee-0.7.0.0 package by hand; on low level; without things like idoneM and runIter ?
22:46:44 <Wooga> it's type hase Iteratee itself inside of it and i have no idea how to manage such recursion
22:47:23 <Wooga> here it's type: newtype Iteratee s m a = Iteratee{ runIter :: forall r. (a -> Stream s -> m r) -> ((Stream s -> Iteratee s m a) -> Maybe SomeException -> m r) -> m r}
22:49:48 <o^_^o> Deprecated: "menu generates strange XHTML, and is not flexible enough. Roll your own that suits your needs."
22:53:39 <joe6> hello, i currently use gnu m4 for some macro processing. It's syntax is a bit weird and i am thinking of substituting a haskell program instead. Any suggestions/wisdom, please?
22:56:49 <shapr> joe6: Are you familiar with DSLs?
23:02:18 <joe6> shapr: not really.
23:03:39 <ddarius> shapr: Digital Subscriber Lines?  Sure.
23:04:08 <banisterfiend> ddarius: ruby.
23:07:13 <ddarius> banisterfiend: DSL is a weird acronym for ruby.
23:07:56 <banisterfiend> ddarius: i think i probably prefer kiki's delivery service to spirited away. what about you?
23:08:00 <o^_^o> is there a way I can convert [[Char]] to [Char] ?
23:08:13 <banisterfiend> o^_^o: just get rid of the outer []
23:08:13 <Wooga> concat
23:08:23 <o^_^o> thanks
23:08:44 <banisterfiend> o^_^o: no problem.
23:09:08 <o^_^o> I said thanks to Wooga 
23:09:34 <banisterfiend> <---- banisterfiend, not Wooga, but thx anyway.
23:11:13 * shapr blinks
23:12:04 <shachaf> @let-shapr
23:12:04 <lambdabot> shapr!!
23:12:23 <shapr> shachaf: You screamt?
23:12:42 <joe6> shapr: do you mean to suggest using haskell as a dsl processor?
23:12:48 <shachaf> shapr: That was lambdabot.
23:13:18 <shapr> joe6: Yes. I don't know how you're using m4, but you may be able to use a Haskell DSL to do the same thing.
23:18:28 <joe6> i use m4 for preprocessing some asm macros. i am not sure if by going with a Haskell DSL i would be reinventing the wheel.
23:18:33 <joe6> ,which I want to avoid.
23:19:10 <joe6> but the gnu m4 syntax is weird and i am just getting back to it after an year or so and it feels like gibberish now.
23:40:10 <joe6> i want to include a module from a different folder into the current haskell source file. I could use the ghci -I option at the command line. It is a static option, which means that it cannot be set in the Options_GHC pragma. I could use the :set and set it in the .ghci, but am just curious of what others do. Are there other alternatives?
23:50:03 <dancor> > 4 5
23:50:04 <lambdabot>   4
23:50:05 <dancor> why
23:51:19 <fcksltwhr> what is haskell?
23:51:41 <shapr> joe6: Wait what? I'm confused.
23:51:44 <dancor> fcksltwhr: http://en.wikipedia.org/wiki/Haskell_(programming_language)
23:52:11 <fcksltwhr> dancor: thanks!
23:55:19 <ddarius> dancor: 5 is clearly the multiplicative unit.
23:56:04 <shachaf> > 5 4
23:56:05 <lambdabot>   5
23:56:17 <geheimdienst> > 9 4
23:56:18 <lambdabot>   9
23:56:33 <dancor> uh huh and we must have -XNullOperatorIsMultiplicationNotApplication
23:57:23 <dancor> > "lol" "nation"
23:57:24 <lambdabot>   Couldn't match expected type `t1 -> t'
23:57:24 <lambdabot>         against inferred type `[GHC....
23:57:28 <shachaf> > (id + id) 5
23:57:29 <lambdabot>   10
23:57:57 <geheimdienst> :t (id + id)
23:57:58 <lambdabot> forall a. (Num a) => a -> a
23:58:18 <dancor> > a b
23:58:19 <shachaf> > (id ^ id) 5
23:58:19 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
23:58:20 <lambdabot>         against infe...
23:58:20 <lambdabot>   No instance for (GHC.Real.Integral (a -> a))
23:58:20 <lambdabot>    arising from a use of `GHC....
23:58:20 <yitz> :t (+)
23:58:21 <lambdabot> forall a. (Num a) => a -> a -> a
23:58:22 <shachaf> > (id ^^ id) 5
23:58:23 <lambdabot>   No instance for (GHC.Real.Integral (a -> a))
23:58:23 <lambdabot>    arising from a use of `GHC....
23:58:29 <shachaf> > (id ** id) 5
23:58:30 <lambdabot>   3124.999999999999
23:59:05 <shachaf> Time to goto sleep;
23:59:07 * shachaf >>= undefined
23:59:10 <dancor> is 5 being casted to (const 5)?
23:59:23 <dancor> > (id ** id) (const 5)
23:59:24 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
23:59:24 <lambdabot>    arising from a use of `...
23:59:44 <yitz> :t id
23:59:45 <lambdabot> forall a. a -> a
23:59:54 <Axman6> > (is ** id) (const 5) 6
23:59:55 <lambdabot>   Not in scope: `is'
23:59:58 <Axman6> > (id ** id) (const 5) 6
23:59:59 <lambdabot>   3124.999999999999
