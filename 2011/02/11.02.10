00:05:06 <hymnusalae> Excuse me, I have tried the following code in ghci:
00:05:15 <hymnusalae> let f c x:xs = case xs of { [] -> (x c); _ -> (x (f c xs))} in f 0 [((+) 3), ((+) 5), ((+) 7)]
00:05:22 <hymnusalae> and I got pattern match error.
00:05:30 <Axman6> you almost certainly want (x:xs) not x:xs
00:05:43 <hymnusalae> Axman6, ... so fast. and thank you!
00:06:04 <Axman6> also, you can't match on ((+) 5), (+) isn't a constructor
00:06:32 <Axman6> oh hang on, ignore that
00:07:34 <Axman6> i think you've just defined a version of foldr... ut it's hard to tell
00:07:38 <Axman6> but*
00:07:54 <hymnusalae> Axman6, yes?
00:08:24 <Axman6> your code is very quite confusing, that's all :)
00:08:28 <Axman6> to me anyway
00:08:49 <hymnusalae> Axman6, :) just read the foldl/foldr part of rwh, and want to try something.
00:08:58 <Ferdirand> so... the state monad is a computation that invoves a hidden state, and the store comonad is a state that involves hidden computation ?
00:09:17 <edwardk> Ferdirand: a reasonable assessment
00:09:30 <Ferdirand> mind == blown
00:09:54 <edwardk> ferdirand: i find the difference to be more obvious when looking at the indexed state monad and indexed store comonad
00:10:21 <Ferdirand> sorry, i don't know what indexed means in this context
00:10:29 <edwardk> if we break up s into i and j, so that the input and output of the computation can be different
00:10:51 <edwardk> newtype IState i j a = IState { runIState :: i -> (a, j) }
00:11:20 * Axman6 would prefer it if it were i and o, for clarity >_>
00:11:28 <edwardk> you can compose them. IState i j a -> (a -> IState j k b) -> IState i k b
00:11:59 <edwardk> Axman6: yeah but that makes picking a third name harder for composition
00:12:06 <Axman6> o'?
00:12:10 <edwardk> blech
00:12:13 <Axman6> :)
00:12:18 <Ferdirand> wait wait
00:12:27 <Axman6> i',m not a fan of o' either
00:12:57 <Ferdirand> ah, I did not spot the funny composition type
00:13:05 <Ferdirand> is this a valid haskell monad ?
00:13:34 <edwardk> no
00:13:36 <Axman6> i don't believe so
00:13:38 <edwardk> let me paste a short module
00:13:48 <edwardk> technically it is when i = j
00:13:59 <edwardk> but you want the indexed monad so i can vary from j
00:14:02 <Axman6> it's like how Enumerators (i think) don't directly match Monad, so Iteratee provides >>==
00:14:11 <Ferdirand> ah well, but then it is just the plain state monad, right ?
00:14:18 <edwardk> @hpaste
00:14:18 <lambdabot> Haskell pastebin: http://hpaste.org/
00:14:39 <edwardk> http://hpaste.org/43841/indexed_comonads
00:14:56 <Ferdirand> ah, i'm a step behind, sorry
00:14:59 <Axman6> hmm, would be cool if @hpaste (or @lastpaste) would give the url to the last paste you pasted in the last hour or so
00:15:23 <edwardk> i made it use noimplicit prelude for clarity, but you could of course rename those methods
00:15:46 <Axman6> why do you need IFunctor? doesn't (m i j) already match the types needed for Functor?
00:16:13 <edwardk> Axman6: but i can't make IxApply, etc. depend upon that being a functor for all choices of i and j
00:16:45 <Axman6> i don't see any IxApply...
00:17:10 <edwardk> IApply
00:17:27 <Ferdirand> sorry, i'm not familiar with rank-2 polymorphism. Is it when you are allowed to have type variables of other kind than * ?
00:17:54 <edwardk> its needed for the type of shift way at the bottom
00:19:28 <hymnusalae> Axman6, i was asking you how to make it in using foldr, and i finally find it should be something like: let f a b = a b in foldr f 0 [blahblahblah]
00:19:41 <hymnusalae> Axman6, but is there something ready for f a b = a b ?
00:19:48 <Axman6> yes, that's id
00:19:57 <hymnusalae> Axman6, thank you very much.
00:20:02 <Axman6> > let f a b = a b in f (+1) 4
00:20:03 <lambdabot>   5
00:20:07 <Axman6> > let f a b = a b in id (+1) 4
00:20:08 <lambdabot>   5
00:20:42 <Axman6> i think you may also find that foldr (.) id also does the same thing. i could be wrong
00:20:50 <Ferdirand> edwardk: this is madness. But i've got a glimpse of intuition on it now, thanks
00:21:13 <hymnusalae> Axman6, thanks. :)
00:21:47 <Axman6> :t foldl (.)
00:21:48 <lambdabot> forall a b. (a -> b) -> [a -> a] -> a -> b
00:21:59 <Axman6> :t foldr (.)
00:22:00 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
00:22:03 <Axman6> argh
00:22:12 <Axman6> :t foldr Prelude.(.)
00:22:13 <lambdabot> Not in scope: data constructor `Prelude'
00:22:20 <Axman6> :t foldr (Prelude..)
00:22:21 <lambdabot> forall c a. (a -> c) -> [c -> c] -> a -> c
00:22:27 <edwardk> Ferdirand: in any event, you can view the indexed monad for state sort of organically growing a state action outward by composing fragments from i -> (a, j) together.
00:22:28 <Axman6> :t foldr (Prelude..) id
00:22:28 <lambdabot> forall a. [a -> a] -> a -> a
00:22:33 <Axman6> :t foldl (Prelude..) id
00:22:34 <lambdabot> forall a. [a -> a] -> a -> a
00:22:56 <edwardk> you can view the indexed comonad for store trying to find a way to fill the gap between a value i, and a function j -> a that you want to apply it to
00:23:00 <edwardk> er apply to it
00:23:53 <Ferdirand> it's funny
00:24:16 <edwardk> oh?
00:24:43 <Ferdirand> i was hesitating between the position of i and j for the store comonad. I don't grok yet what it does, but as the dual of a monad, it seems strangely natural
00:25:19 <edwardk> http://hackage.haskell.org/package/comonad-transformers provides a whole bunch of dual versions of monads
00:25:40 <Ferdirand> so it fact
00:25:59 <Ferdirand> with the state monad, i write pieces of stateful computation and the monad threads them by carrying the state
00:26:00 <edwardk> instead of lift for MonadTrans with a ComonadTrans you can lower, etc.
00:26:06 <edwardk> i even tried to keep the operations basically the same
00:26:20 <edwardk> Store = dual to State, Env = dual to Reader, Traced = dual to Writer
00:26:47 <Ferdirand> with the store comonad, i write pieces of moving state and they get threaded with a hidden computation, the other way around
00:26:49 <edwardk> well, technically store is the opposite way to compose the adjunction for state, and env and traced are adjoint to their monadic cousins
00:27:29 <edwardk> that is a reasonable intuition for how to use store.
00:28:22 <edwardk> read 'pos' as 'get' and 'seek' as 'put' and seeks as 'modify' and it has the same operations
00:39:27 <Ferdirand> mhh, so a comonad is kind of like a monad, except we exchange the magic of the combinator (>>=, =>>) and the magic in the monadic expression
00:39:42 <edwardk> yeah
00:40:25 <opqdonut> well put
00:57:13 <adnap> anybody awake?
00:57:32 <Axman6> never
00:59:38 <edwardk> nope
01:01:52 <yitz> zzzz
01:29:33 <forgesteel> Hi, I need a help to solve the lack of parallelism in my code. I've posted it on: http://stackoverflow.com/questions/4920077/parallelism-on-divide-conquer-algorithm 
01:30:21 <forgesteel> I've added some strictness, but no results
01:32:51 <Axman6> hm, there's quite a lot of code to take in there
01:34:03 <forgesteel> Those are just different version that I've tried
01:34:46 <Axman6> what;s the type of s1 and s2?
01:35:58 <Axman6> forgesteel: ?
01:36:03 <forgesteel> they are: IO ([Simplex], [Edge]) 
01:36:14 <Axman6> that's probably your problem then
01:36:39 <Axman6> using s1 `par` ... don't evaluate the result of the IO action, so it basically does nothing
01:37:16 <Axman6> hmm
01:37:18 <forgesteel> How can I force it?
01:37:31 <lostman> forgesteel: why is that in IO anyway?
01:37:47 <Axman6> lostman speaks :O
01:38:30 <Axman6> so your forkIO version makes more sense
01:38:37 <forgesteel> I have to generate a UID for some triangulations, so I've used MVar's 
01:38:38 <lostman> hmm, I don't think sparks and IO monad mix well
01:39:23 <Axman6> i think you need to use takeMVar twiice to get the results you want
01:39:43 <forgesteel> How can I use QSemN (semaphores)? 
01:39:54 <Axman6> also, there's no guarantees about the ordering if your results in that MVar
01:40:19 <forgesteel> I can Fki
01:40:26 <forgesteel> sorry
01:41:39 <Axman6> i think you should use two MVars 
01:41:50 <forgesteel> I can use forkIO but I don't know how synchronize them (wait and merge)
01:42:01 <Axman6> using two MVars
01:42:04 <av> hi guys, need a quick solution to a stupid problem:
01:42:35 <forgesteel> Axman6: What u mean two MVar's?
01:42:40 <av> under windows, System.Posix.Unistd isn't available -- how to i get something similar to "usleep" under windows?
01:42:46 <quicksilver> at the end of each thread, put the result in an mvar
01:42:52 <quicksilver> have the main thread pool them out
01:42:56 <quicksilver> av: threadDelay
01:42:57 <int-e> av: threadDelay?
01:43:14 <av> cool, thanks (...of hoogling...)
01:43:21 <int-e> @type Control.Concurrent.threadDelay
01:43:21 <lambdabot> Int -> IO ()
01:43:54 <Baughn> av: threadDelay!
01:44:01 <forgesteel> Axman6: I will try that
01:44:11 <av> chanksg guys, will use that. it's windows-specific, isn't it?
01:44:15 <int-e> (but what was the unit? *tries* microseconds
01:44:49 <int-e> av: not windows specific, will work on posix systems too.
01:45:08 <Baughn> av: Anything that isn't specifically names as system-specific will work everywhere. :)
01:45:16 <av> int-e: even better. thanks a lot
01:45:23 <Axman6> forgesteel: http://hpaste.org/43843/parallel_stuff
01:46:02 <int-e> Baughn: now that's a dangerous claim with all the third party libraries out on hackage :)
01:46:06 <Baughn> av: I should probably mention that the usleep call would require the runtime to create a new OS thread specifically for sleeping, which threadDelay doesn't.
01:46:09 <Axman6> though, it would be better if you you didn't fork s1
01:47:30 <Axman6> the first mv2 should be mv1 :)
01:47:52 <forgesteel> Axman6: Why?
01:48:12 <Baughn> [mv1, mv2] <- replicateM 2 (newMVar ([],[])
01:48:15 <paolino> hi, I have a problem with cabal: every time I run cabal install on my project it reinstalls cgi library from hackage. It's a fresh installation of haskell platform
01:48:36 <Axman6> forgesteel: this is better: http://hpaste.org/paste/43843/parallel_stuff_annotation#p43844
01:49:14 <Axman6> forgesteel: if you fork them both, then the original thread is sitting there doing nothing, when it could be computing s1 in parallel with s2
01:49:20 <Axman6> you reduce overhead
01:49:55 <quicksilver> don't think it really matters
01:49:59 <quicksilver> haskell threads are very lightweight
01:50:03 <Axman6> sure
01:50:09 <quicksilver> a thread doing nothing does not consume significant resource
01:50:16 <teven> quicksilver: not as lightweight as you think
01:50:18 <Axman6> but depending on the number of them, you start using more memory
01:50:39 <quicksilver> teven: how do you know what I think? :)
01:50:49 <Axman6> i'm well aware how lightweight they are, but nothing is gained by having an extra thread here
01:51:16 <Axman6> where an is some exponential number
01:52:19 <Axman6> forgesteel: any luck? if it works, i'll answer on stackoverflow too so that others can see the answer
01:52:31 <quicksilver> arguably you gain some code symettry
01:52:36 <Axman6> sure
01:52:41 <quicksilver> but having all the work done in worker threads and the main thread waiting
01:52:45 <quicksilver> s/but/by/
01:53:08 <Axman6> but each worker thread forks two worker threads, so the notion opf a main thread doesn't make much sense
01:53:25 <forgesteel> I'm running it, wait 
01:54:49 <forgesteel> The 1st didn't work: Parallel GC work balance: 1.44 (14678866 / 10175422, ideal 8)
01:55:01 <forgesteel> SPARKS: 0 (0 converted, 0 pruned): from GHC -sstderr
01:55:07 <Axman6> o.O
01:56:31 <Axman6> it should also be noted that if the state you have is supposed to be unique, you do not at all guarantee that the way you're running this
01:58:21 <quicksilver> forgesteel: explicit threads will not show as sparks
01:58:23 <quicksilver> (maybe you know this?)
01:58:41 <quicksilver> you can see if the parallelism is helping by comparing the runtimes of -N1 and -N2
01:59:48 <forgesteel> quicksilver: ops:-[ 
01:59:52 <Axman6> oh right, threads aren't sparks, sparks are only created by par. there are two different forms of parallelism going on here
02:00:25 <quicksilver> run it with "time ./executeable +RTS -N1" and "time ./executable +RTS -N2"
02:00:37 <quicksilver> if the second one is consistently faster, you have 'useful' thread usage.
02:01:18 <Axman6> http://stackoverflow.com/questions/4920077/parallelism-on-divide-conquer-algorithm/4955861#4955861 is my SO answer
02:02:19 <paolino> is there a specific channel for questions on cabal ?
02:02:25 <dcoutts> no
02:02:26 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:02:31 <forgesteel> Yes, it WORKS :)     I've used threadScope and it is there!
02:02:46 <Axman6> :)
02:03:04 <Axman6> i would imagine its performance isn't great though, you probably have too many threads
02:03:06 <forgesteel> Thank you guys!!! 
02:03:35 <quicksilver> Axman6: (a1,b1) <- s1 >>= evaluate -- this evaluate is pointless.
02:03:37 <paolino> dcoutts, what can it be that cabal install insist on reinstalling CGI ?
02:03:42 <Axman6> forgesteel: it might be worth adding a parameter that stops forking once you reach a certain depth
02:03:51 <quicksilver> Axman6: the tuple match is already forcing it to WHNF
02:04:14 <Axman6> ah yes, that one is. the first one might not be though
02:04:42 <dcoutts> paolino: do you have the same version of CGI installed in the global and user package dbs? current cabal versions gets confused in that case (they pick the wrong one sometimes)
02:05:11 <quicksilver> Axman6: the first one is probably quite important, yes.
02:05:18 <Axman6> edon: does evaluate only evaluate to WHNF?
02:05:31 <quicksilver> Axman6: although I dislike evaluate, so I'd say "putMVar mv2 $! s2"
02:05:46 <quicksilver> Axman6: od course. what else could it do? 
02:05:47 <Axman6> uh, sorry edon, mistype
02:05:57 <quicksilver> there is nothing else, without a typeclass
02:05:59 <quicksilver> (e.g. NFData)
02:06:12 <quicksilver> (or Control.*.Strategy)
02:06:29 <paolino> dcoutts, yes, one came from haskell platform I suppose
02:06:35 <Axman6> well, i thought the point was to evaluate thunks, which might involve going deeper than WHNF, but that doesn't really make sense
02:07:08 <dcoutts> paolino: get rid of the one in the user db and avoid re-installing the same version locally
02:07:14 <dcoutts> paolino: --dry-run helps
02:07:16 <forgesteel>  Axman6: like the length of the list as a criteria  
02:08:26 <paolino> dcoutts, it happens because I have the dependency in my cabal file, it will reinstall if I take it away
02:08:51 <paolino> ?
02:09:10 <dcoutts> paolino: why can't it use the global one?
02:09:29 <dcoutts> paolino: you're saying you've already got it installed in the global package db right?
02:09:41 <Axman6> forgesteel: huh?
02:11:13 <paolino> dcoutts: yes from the platform
02:11:28 <paolino> it should use that
02:11:51 <paolino> but it seems it doesn't
02:12:05 <dcoutts> paolino: paste the output of --dry-run -v somewhere
02:12:43 <forgesteel> Axman6: I could use the lenght of ([Simplex], [Edge]) as a criteria to stop forking
02:13:42 <Axman6> you could, sure. i find that just having two functions, one that forks and decrements the depth, and another that doesn't fork, which is called by the first when it reaches 0 works quite well
02:14:15 <forgesteel> Axman6: That's funny, your 1st solution didn't work 
02:14:38 <paolino> dcoutts: http://hpaste.org/43846/dryrun
02:14:43 <Axman6> forgesteel: huh?
02:14:43 <quicksilver> forgesteel: the first one doesn't work because it doesn't actually force the work to be done in those threads
02:14:55 <Axman6> well, the first solution i posted had a tyoe, did you fix it?
02:14:57 <quicksilver> forgesteel: the threads just stuff a thunk in the mvar
02:15:05 <quicksilver> and the main thread causes evaluation.
02:15:12 <dcoutts> paolino: ok, so if you look at the last 3 lines it says: cgi-3001.1.7.2 (reinstall) changes: network-2.2.1.7 -> 2.3.0.2
02:15:32 <forgesteel> Yes, i did
02:15:38 <quicksilver> his final one, which has 'evaluate' in the subthread, forced the subthread to actually do something.
02:15:45 <dcoutts> paolino: so if you want to not rebuild cgi, then what is the solution?
02:16:15 <paolino> use a different network version ?
02:16:21 <dcoutts> paolino: right
02:16:33 <dcoutts> in particular the version of network that cgi already uses
02:16:44 <paolino> how should I guess it ?
02:16:54 <dcoutts> the message there says what it is
02:17:24 <paolino> can't parse it, sorry, too ermetic for me
02:17:31 <dcoutts> changes: network-2.2.1.7 -> 2.3.0.2
02:18:11 <dcoutts> paolino: so use --constraint="network==2.2.1.7"
02:19:30 <paolino> dcoutts: I didn't get it, but anyway, what is wrong with the global installed cgi ?
02:20:06 <dcoutts> paolino: there's nothing wrong with it, but if you're going to use a different version of network, then the cgi package has to use the same one
02:20:24 <dcoutts> paolino: you've installed a new network package, but the cgi package uses the original one
02:20:59 <paolino> the global one
02:21:01 <dcoutts> paolino: so either one has to rebuild cgi to use the new one, or to stick to the old network package
02:21:06 <dcoutts> paolino: right
02:21:26 <paolino> ok , so it rebuilds it in the user repo
02:22:03 <paolino> and next time don't see it is ok ?
02:23:35 <paolino> it should pick the user (and dependency correct one) , but it doesn't see it, right ?
02:23:47 <dcoutts> paolino: right, that's the bug.
02:23:53 <paolino> ok, thanks
02:24:04 <paolino> I correct my cabal
02:24:33 <dcoutts> paolino: there's nothing wrong with your .cabal file
02:25:14 <paolino> it uses a wrong (for the bug) network
02:26:05 <dcoutts> paolino: the simplest solution is to not use the later network package (e.g. unregister it)
02:26:59 <paolino> oh, I didn't tell it to , that is another bug
02:27:13 <forgesteel> Axman6: quicksilver: Thank you both. I will work on it and publish the results on stackoverflow!
02:27:24 <Axman6> forgesteel: excellent :)
02:27:44 <forgesteel> Now I will have lunch, bye
02:27:56 <Axman6> forgesteel: it's veey easy to write parallel programs in haskell, the problem is you often write them to be too parallel, and lose performance. getting this right is the hard part
02:27:57 <paolino> dcoutts: the only constraint I have in cabal is  base  >=4.2 
02:28:00 <Axman6> very*
02:28:04 <Axman6> forgesteel: good luck :)
02:28:32 * Axman6 heads home
02:28:38 <paolino> dcoutts: which I think is in the global, yes
02:28:39 <quicksilver> Axman6: understanding how to make sure enough work is forced in each spark/thread is also hard, in my experience :)
02:31:25 <paolino> dcoutts: http://hpaste.org/paste/43846/dryrun__annotation#p43848 , my cabal
02:31:46 <dcoutts> paolino: that's fine
02:31:59 <paolino> probably HTTP-4000 asked the newest network
02:32:42 <paolino> but it should stick with a version supporting the network-2.2.7
02:32:57 <paolino> which is what I have already
02:33:42 <paolino> ops I didn't see the "care, dependency hell" notice
02:36:47 <paolino> no HTTP-4000 has no constraints on network 
02:40:46 <HugoDaniel> i need tips in writing a good DSL with haskell
02:40:49 <HugoDaniel> where can i get them ? :)
02:41:04 <paolino> dcoutts, I unregistered HTTP and network , which seems the only one to depends on network, but --dry-run still asks 2.3.0.1
02:42:18 <paolino> it seems to ignore tha fact that we have a global network-2.2.7
02:44:29 <dcoutts> paolino: the default behaviour is to try to use the latest version that is installed, you have both network-2.2.7 and network-2.3.0.1 installed.
02:45:01 <paolino> no 2.3.0.1 is unregistered
02:48:30 <geheimdienst1> is there a command line option for ghci to import ad module?
02:48:45 <geheimdienst1> might be obvious, but i spent some time in the user's guide now and can't find it ...
02:48:55 <geheimdienst1> s/ad/a
02:48:57 <quicksilver> geheimdienst1: I don't think so.
02:49:26 <quicksilver> geheimdienst1: but you can probably get it to run some commands on startup
02:49:58 <geheimdienst1> yeah ... what doesn't work is echo ":m +Thing" | ghci
02:50:09 <geheimdienst1> that immediately quits after running the :m
02:50:35 <geheimdienst1> this is surprisingly difficulter than i thought
02:50:57 <paolino> dcoutts: ok, I restricted the problem after unregistering network , if I set the contraint <= 2.2.1.7, it cannot compile because it selects scgi-0.3.3. Now, why not scgi-0.3.2 which doesn't ask for network >= 2.3 and there is no scgi package installed ?
02:51:11 <Saizan> maybe you can point it to a .ghci file
02:51:31 <dcoutts> paolino: because the dep solver is not very smart
02:51:55 <paolino> doesn't trace back ?
02:52:00 <dcoutts> paolino: no
02:52:06 <paolino> oh
02:52:12 <dcoutts> paolino: we're working on a cleverer algorithm
02:52:40 <kfr> paolino why don't you want it to use the new network?
02:52:47 <geheimdienst1> hm ... i guess i'll go with create a temp directory, write a .ghci file with ":m +Blah" in it, then start ghci, then delete the stuff
02:52:56 <geheimdienst1> this feels bass-ackward, but whatever ...
02:54:50 <paolino> kfr I had no preferences but there is a bug in cabal which doesn't like 2 same versions packages compiled with different dependencies in global and user. It all came from that
02:55:06 <paolino> if I got it right
02:57:07 <paolino> dcoutts, we need genetic search, or the constraint of determinism still holds ?
02:57:29 <dcoutts> paolino: determinism and good error messages are important
02:58:11 <paolino> well if back tracking is unfeasable, I don't know how to think about that
03:00:11 <paolino> sure, this specific case was easy solvable ‎even backtracking
03:00:37 <paolino> anyway I set scgi <= 0.3.2 and see what happens
03:04:30 <paolino> dcoutts: it used the network installed! At least I understood the problem, thanks
03:04:43 <dcoutts> :-) sorry for the mess
03:04:59 <tibbe> aristid: was it you who had a question for me yesterday?
03:06:19 <paolino> dcoutts: well, solving the first bug is not going to save us anyway, unless we have per project repository, maybe sharing sharable libraries
03:06:49 <dcoutts> paolino: fixing the first bug would go a long way
03:07:07 <dcoutts> paolino: the eventual solution will look a lot like nix
03:07:29 <quicksilver> gwern: ping
03:07:48 <tibbe> dcoutts: we need to think about gsoc projects
03:08:16 * dcoutts grumbles that he has too many things to think about
03:08:18 <dcoutts> :-)
03:08:38 <tibbe> dcoutts: same here
03:08:51 <tibbe> dcoutts: but this is an opportunity to get someone else to do one of them
03:08:58 <dcoutts> aye
03:09:15 <tibbe> dcoutts: I was happy with the testing support
03:09:22 <dcoutts> yes
03:09:39 <tibbe> so we should find a similarly sized project
03:13:59 <geheimdienst1> gsoc project 2011: think about gsoc projects for 2012
03:14:01 <geheimdienst1> ;)
03:17:29 <joe6> is there some simple command to upgrade all packages installed by cabal.
03:17:41 <dcoutts> joe6: not yet
03:17:44 <joe6> some combination of ghc-pkg list --user --simple-output | .. . cabal..
03:18:11 <dcoutts> joe6: in the next version there's a "world" target, e.g. cabal install world
03:18:32 <dcoutts> but the problem is, you cannot always install/upgrade the whole lot consistently
03:18:43 * geheimdienst1 quickly uploads a package named world to hackage ... heehee
03:19:36 <joe6> dcoutts: why do you say that? cabal install <my modules> --reinstall does not cut it?
03:19:52 <HugoDaniel> is there a signed eight-byte integer data type in haskell ?
03:20:02 <dcoutts> Hugglesworth: Int64
03:20:12 <HugoDaniel> thanks dcoutts 
03:20:17 <dcoutts> joe6: there's no guarantee that it is possible to install all those consistently at the same time
03:20:28 <accel> is there a way to run haskell "interpreted" rather than "compiled" ?i.e. i'm making lots of small changes, and would prefer instant feedback to faster program
03:20:34 <dcoutts> joe6: they may require conflicting versions of dependencies
03:20:37 <quicksilver> accel: runghc or runhaskell
03:20:48 <dcoutts> accel: or just ghci
03:20:54 <quicksilver> (or just run from within ghci, which is what I do 99% of the time)
03:23:27 <accel> how do I tell them I need the OpenGL and GLUT modules?
03:23:52 <joe6> dcoutts: ok, thanks.
03:50:06 <joe6> how do i get to Cabal-1.10.0.0 from cabal-1.8.0.6 . i tried cabal install and it seemed to install the cabal 1.10 library but not the exe
03:50:24 <joe6> i am trying cabal install cabal-install --reinstall, but that does not seem to work.
03:51:01 <joe6> http://pastebin.com/kZFG98fk
03:51:56 <joe6> let me try: cabal install cabal-install-1.10.0
03:54:56 <Jafet> Perhaps you forgot --user
03:57:22 <joe6> Jafet: same message with --user too.
03:58:27 <geheimdienst1> so, what am i doing wrong when putting this line in .cabal/config? haddock-option: --source
03:58:49 <geheimdienst1> i thought it supported --<sometool>-option
03:59:27 <revenantphx> Hurray.
03:59:28 <lambdabot> revenantphx: You have 1 new message. '/msg lambdabot @messages' to read it.
03:59:31 <revenantphx> Scored 2290 on my SAT.
04:00:23 <joe6> out of 2300?
04:01:19 <companion_cube> what SAT ?
04:01:55 <Botje> revenantphx: pfft. I have a SAN score of 100 :P
04:02:01 <revenantphx> SAN?
04:02:06 <Botje> sanity :P
04:02:07 <revenantphx> Out of 2400
04:02:19 <revenantphx> 800, 740 and 750 in each section
04:02:33 <joe6> i am realising that it is better to build from darcs than using cabal. Is there a smarter way to darcs get all the relevant modules?
04:02:36 <Botje> nice!
04:02:46 <joe6> revenantphx: cool
04:02:58 <revenantphx> But my lowest was in math which isn't good >_>
04:03:32 <revenantphx> anyways, off to school.
04:05:35 <geheimdienst1> sorry, got disconnected :-(
04:09:09 <rumbold> hrm, how do i reopen my old package in leksah? :/
04:10:04 <hamishmack> rumbold: Right click in the workspace pane and choose Add Package
04:11:36 <rumbold> do i have to open the old workspace before? whats the file extension for workspaces?
04:17:18 <taotree> I get the following error doing "cabal install derive":   http://hpaste.org/43849/derive_install   did I do something wrong or should I contact package maintainer or... ?
04:24:13 <Saizan> taotree: mh, probably some underspecification in the .cabal file
04:26:13 <Saizan> taotree: try with an earlier version, e.g derive-2.4
04:26:31 <augur> Saizan!
04:27:05 <Saizan> yes?:)
04:27:37 <augur> sup doodles
04:27:39 * hackagebot hsc3-process 0.5.0 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.5.0 (StefanKersten)
04:27:51 <augur> hows the life saizanian
04:30:13 <taotree> Saizan, tried 2.4. Got same error
04:31:09 <Saizan> taotree: it's hard to judge which one will work because it doesn't specify any version constraint on the template-haskell dep :\
04:31:30 <taotree> sounds like contacting package maintainer wouldn't be out of line then?
04:31:40 * hackagebot grammar-combinators 0.2.3 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2.3 (DominiqueDevriese)
04:32:20 <Saizan> taotree: yeah, though i suspect 2.3.0.2 would build, (2.4.1 builds on 6.12.3 btw)
04:32:40 * hackagebot hsc3-process 0.5.1 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.5.1 (StefanKersten)
04:33:05 <taotree> oh... maybe I should upgrade ghc to 6.12.3... I'm on 6.12.1
04:34:28 <joe6> what do i do for these kind of warnings: Warning: The 'build-type' is 'Configure' but there is no 'configure' script.
04:34:37 <joe6> can I get it to generate the configure script?
04:34:45 <kik_> hey! could you help me with haskell. I am preparing for my exam. I need to write a function, that will through away all repetitives in string. in:"abbccxxba" out :"abcba" http://codepad.org/8C6fQKZb that is what I made. but it doesnt work when I have "abba" it gives me back "abba". I guess that promlem is in ignore function. but i dont know how to modify it
04:35:04 <joe6> i see configure.ac and other config stub files.
04:35:13 <Bynbo7> kik_: not abcxba?
04:35:33 <Saizan> joe6: i think you've to run autoconf yourself
04:35:38 <kik_> Bynbo7: yeah. sorry. out should be like you wrote
04:35:47 <int-e> kik_: shouldn't the result for abbccxxba be abcxba?
04:35:58 <kik_> int-e: it should be
04:36:11 <joe6> got this: http://www.haskell.org/ghc/docs/5.02.3/building/sec-building-from-source.html
04:36:29 <joe6> Saizan: thanks.
04:37:17 <int-e> kik_: ok, why is ignoreDouble [x] =[]
04:37:18 <int-e> ?
04:37:48 <taotree> Saizan, 2.3.0.2 doesn't build either. I'm going to look into upgrading ghc and see where that gets me
04:37:51 <Saizan> joe6: are you building ghc from the repository?
04:38:02 <Bynbo7> > map head . group $ "abbccxxba"
04:38:04 <lambdabot>   "abcxba"
04:38:10 <Bynbo7> don't use that kik_ :P
04:38:16 <kik_> int-e: m... I dont know.. ok.. it should be [x] or this line should not be there at all
04:38:26 <kik_> Bynbo7: why?
04:38:53 <Bynbo7> because you didn't come up with it, and I'm guessing that if you're doing this for study, you should be writing all the definitions yourself
04:39:10 <int-e> kik_: the other mistake is that x : [y]  is a two element list (same as [x, y])
04:39:16 <Bynbo7> kik_: why are you using ord x == ord y? why not x == y?
04:39:48 <Saizan> joe6: if so: http://hackage.haskell.org/trac/ghc/wiki/Building
04:39:50 <rumbold> hmm, i think my problem is that my harddrive is full because there are tons of ghcsometihng folders in /tmp/ that arent being deleted (i only have a small harddrive cause im running linux in a vm)
04:39:54 <int-e> (I wondered that, too, but I thought functionality should come first)
04:40:55 <int-e> > group "abbcccdeefff" -- probably not helpful either.
04:40:55 <kik_> Bynbo7: I am comparing their numbers, well. yeah. I could compare the digits themselves. but it doesnt play a role
04:40:56 <lambdabot>   ["a","bb","ccc","d","ee","fff"]
04:41:38 <int-e> kik_: the advantage would be that then it would work for more other types instead of Char.
04:41:39 <Bynbo7> kik_: sure, it's just unnecessary (and it would show a lack of understanding in an exam) not a big thing though :)
04:41:55 <kik_> int-e: yeah. but like y should be added to x if they are different
04:42:21 <kik_> Bynbo7: yeah. ok, I got it=)
04:42:22 <int-e> kik_: no, y will be added later.
04:42:24 <joe6> Saizan: no, i cannot llvm to install. It wants the latest version of cabal and i am trying to get that.
04:42:26 <HugoDaniel> any tips on writing a DSL with haskell ?
04:42:35 <int-e> kik_: it's part of the recursive call to ignoreDoubles, right?
04:43:13 <int-e> kik_: (technically that is a different y, of course. but in the call to  ignore  that you worry about, y has the same value as it had in ignoreDoubles)
04:43:19 <kik_> int-e: yeah, it is. it should be added to a list
04:43:55 <kik_> int-e: yep. but doest it play a role?
04:44:08 <joe6> almost all the ./configure scripts are failing with: config.status: error: cannot find input file: `include/HsBaseConfig.h.in'
04:44:21 <joe6> some different .in file  in the include directory.
04:44:42 <Bynbo7> earthquake!
04:44:44 <Bynbo7> :O
04:45:04 <joe6> are those package from darcs expected to work?
04:45:06 <int-e> kik_: yes, that's why "abba" becomes "ab" ++ "" ++ "ba" ++ "" instead of "a" ++ "" ++ "b" ++ "" (the other mistake is that here the last string is empty instead of "a")
04:47:21 <Saizan> joe6: which in particular?
04:47:35 <kik_> int-e: so you mean that because of the same names of variables my funkrions donest work properly?
04:47:50 <int-e> kik_: No! I don't mean that at all.
04:48:03 <HugoDaniel> http://lpenz.github.com/articles/hedsl-sharedexpenses/index.html found this in reddit :D
04:48:07 <joe6> Saizan: base, directory
04:48:27 <joe6> Saizan: those are the 2 packages I have tried
04:49:04 <int-e> kik_: There are two problems with the code. 1) a base case of ignoreDouble is wrong. 2) ignore returns two characters at once instead of one.   You seem to be confused about what  ignore  should do in order to make the code work.
04:49:37 <kik_> int-e: ooh. I got it I guess
04:49:54 <Saizan> joe6: ah, i've never tried to build base indipendently of ghc, it might not be intended to, directory should work but you might need the darcs version of ghc too
04:50:45 <kik_> int-e: http://codepad.org/f6MpRcaC
04:52:56 <quicksilver> it's hard to build base independently of GHC and not *normally* useful
04:53:05 <quicksilver> normally you always want the base version to match your GHC version
04:53:08 <kik_> int-e: should ignore be written that way?
04:53:21 <int-e> kik_: Phew, one step in the right direction, two steps back. I don't know what to say. Yes, ignore would make sense that way.
04:53:24 <joe6> Saizan: oh, ok.
04:53:26 <quicksilver> (obviously the process of building a new GHC does involve, at some point, building a different base version ;)
04:54:06 <kik_> int-e: but not ignoreDouble yeah?=))
04:54:19 <joe6> the bootstrap.sh of cabal-install fails with this error message: Could not find module `Distribution.Simple':
04:55:54 <int-e> joe6: it's missing the Cabal library, which should come bundled with ghc
04:58:57 <joe6> int-e: ok, i will just rebuild everything from scratch and source.
05:10:57 <kik_> int-e: sorry but I really dont understand it with the main line of ignoreDouble
05:14:58 <Itkovian> Anybody know of efforts underway to enhance the state of machine learning libs in Haskell?
05:15:24 <mmaruseacph2> @ap f x x
05:15:24 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:19:28 <taotree> Itkovian, I don't know but if you find anything out I'd like to know :)
05:19:51 <Itkovian> taotree: likewise
05:21:16 <taotree> I'll probably be looking into ML in haskell in a few weeks
05:21:35 <Botje> @pl \x -> f x x -- did you mean this, mmaruseacph2 ?
05:21:36 <lambdabot> join f
05:22:01 <mmaruseacph2> yeah, solved it in private with lambdabot 
05:22:02 <mmaruseacph2> :D
05:22:46 <Botje> ok, cool
06:05:06 <katja> hey! I have been here already. I asked about repetitives digits. in "abbxxs" out "abxs" http://codepad.org/VZzhXufQ I have this thing, but it tells me that I have pattern error in ignoreDouble1
06:06:35 <Saizan> katja: ignoreDouble1 handles only empty lists and lists with 2 or more elements, you need to add a case to handle lists of length 1
06:08:32 <katja> Saizan: you mean ignoreDouble1 [x] = [x] ?
06:09:10 <Saizan> katja: yeah
06:10:12 <katja> Saizan: ok but then I have in:"aabbxxcaaaa" out "abxcaa"
06:11:09 <gwern> quicksilver: pong
06:12:04 <Saizan> katja: try ignoreDouble1 [x] = []
06:14:04 <katja> Saizan: yep. it works. thank you very much
06:15:05 <quicksilver> gwern: your styling is a bit ugly on that writeup about the SoC, you need more {margin:} around your LIs in my opinion.
06:15:44 <quicksilver> gwern: the "verdicts" are closer to the text of the following item than they are to the preceding item (which is the one they refer to)
06:15:46 <gwern> quicksilver: how do you mean? there's a solid space between the <li> and their following text
06:16:09 <gwern> quicksilver: oh. yeah, I don't know how to fix that
06:16:52 <quicksilver> gwern: li { margin-top: 1em } seems like a possible fix.
06:18:40 <quicksilver> gwern: (tested using chrome inspector, it certainly looks nicer to me)
06:19:04 <gwern> quicksilver: yes, it does look a little better. any idea on how to reduce the interior whitespace between the data & judgement?
06:19:32 <quicksilver> gwern: li p { margin: 0.5em }
06:19:41 <quicksilver> (which will reduce it from the current 1em
06:20:03 <kfr> CSS talk in #haskell, didn't see that coming
06:20:31 <gwern> quicksilver: looks even better. give me a minute or three to sync
06:21:50 <gwern> kfr: sooner or later, we discuss everything
06:22:21 <kfr> I use, or rather _try_ to use Haskell for webdev, so I am not displeased
06:23:12 <hpc> kfr: you might like http://98.169.17.243:8000/blog
06:23:19 <hpc> (sorry i don't have a better url atm)
06:24:03 <kfr> http://98.169.17.243:8000/blog/view.cgi?id=5 :o
06:24:46 <hpc> i need to expand on that post...
06:25:00 <kfr> I wrote an SCGI server
06:26:01 <hpc> neat; i just used lighty
06:26:16 <gwern> quicksilver: ok, synced.
06:28:35 <kfr> The next thing I have to do is to parse all the different ways of passing data to the server :|
06:29:22 <kfr> Boundary encoding, nooo
06:29:28 <kfr> Mixed Unicode/binary data, nooo
06:30:10 <quicksilver> gwern: certainly looks better to me. Thanks.
06:31:18 <revenantphx> ahahaha >:D
06:31:35 <revenantphx> My teacher okay'd me using Cocktail Sort for the Bubble Sort category of our sorting shootout.
06:31:45 <revenantphx> Provided no one else knows about it, I win :).
06:34:59 <geheimdienst1> you win in the ... bubble sort category?
06:35:13 <hpc> lol
06:35:42 <geheimdienst1> is that like winning a race in the car-with-one-wheel-missing category?
06:36:03 <geheimdienst1> ;)
06:36:08 <hpc> i first read that as winning a race in the car-with-one-wheel category
06:36:15 <revenantphx> geheimdienst1: Pretty much.
06:36:15 <hpc> which would have been AWESOME!
06:36:25 <revenantphx> We're competing in Bubble, Insertion, Selection, Merge and Quick
06:36:40 <revenantphx> I'm trying to optimize the hell out of the lower end ones, since most people are considering them too slow to be worth the effort.
06:36:48 <zygoloid> you might not do too badly in the sorting-mostly-sorted-lists category...
06:36:50 <revenantphx> Merge I'll probably do an iterative sort.
06:36:56 <Jafet> It's like winning the nucleotide shootout with hash tables
06:37:03 <revenantphx> zygoloid: No shell sort here :P.
06:37:42 <zygoloid> what're the rules on the bubble sort category? are you restricted to only performing swaps with adjacent elements?
06:37:51 * geheimdienst1 holds a sorting competition with the categories Quick, Ridiculous Speed, and Ludicrous Speed
06:38:01 * zygoloid enters timsort
06:38:24 <geheimdienst1> that's the thingy that python switched to 1-2 years ago, right?
06:38:27 <zygoloid> yeah
06:38:30 <hpc> geheimdienst1: the ship's never gone to ludicrous speed before!
06:39:52 <zygoloid> geheimdienst1: how about good-guess-sort, where you hardcode some likely sorted lists and do a single pass to check for them, and invoke a real sorting algorithm if you guess wrong?
06:40:06 <zygoloid> i'd wager that quite a few tests will have 1..n as the sorted list :)
06:40:38 <ClaudiusMaximus> gnargh. Text.EditDistance.levenshteinDistance :: EditCosts -> String -> String -> Int  -- why not :: Eq a => EditCosts -> [a] -> [a] -> Int
06:41:20 <Jafet> Or if their pseudorandom generator has a linear time distinguisher
06:42:55 <zygoloid> ClaudiusMaximus: possibly to allow natural extension to distances which take distance in qwertyspace into account?
06:43:16 <zygoloid> (though (EditCosts a) would be the natural generalization there i guess)
06:43:46 <ClaudiusMaximus> zygoloid: well, i looked at the code and it uses STUArray ... Char quite a bit...
06:44:14 <ClaudiusMaximus> zygoloid: and the description says "heavily optimized", wish there was a simple/slow/generic version too though
06:48:11 <zygoloid> hmm, you shouldn't need random access into the string to compute the edit distance, so a generic version shouldn't be /massively/ slower
06:49:48 <gwern> any ja speakers? what is 'gwern さん、辛口やなあ…'? (google translate is nonsense)
06:50:10 <geheimdienst1> gwern, the first word of this probably means gwern
06:50:19 <gwern> geheimdienst1: fascinating! do go on
06:56:24 <djahandarie> gwern, "gwern, that's pretty harsh..."
06:57:21 <gwern> hrm. ikegami has never been involved with the Summers of Code; I don't think any Japanese have. maybe it's just a general comment
06:57:41 <djahandarie> Yes, probably a general comment.
06:58:34 * gwern has noticed more than a few comments in that vein. maybe haskellers just can't handle the truth :)
06:59:30 <revenantphx> Nice...
06:59:43 <copumpkin> that's pretty harsh?
06:59:48 <copumpkin> where was that comment?
06:59:55 <quicksilver> gwern: you are certainly not gentle.
06:59:57 <revenantphx> I cut my run times from 130000ish to 110000ish for  n=100000
07:00:01 <quicksilver> gwern: but there is no particular point mincing words.
07:00:04 <revenantphx> er, 11000ms
07:00:10 <quicksilver> gwern: I support your "robust" approach.
07:00:13 * copumpkin thinks gwern is very gentle
07:00:27 * gwern doesn't play fast and loose with the practical reasoning
07:00:29 <quicksilver> copumpkin: in his write-up of SoC rather than in general.
07:01:11 <copumpkin> gwern: I guess you got your answer about immix
07:01:17 * djahandarie nods and agrees that gwern's SoC writeup was useful
07:01:17 <copumpkin> and if not, marcot will probably repeat it for you :)
07:01:36 <gwern> copumpkin: I did; so I can flip my little parenthetical comment to a flat negative
07:01:41 <gwern> 'complete failure'
07:01:51 <marcot> copumpkin: =)
07:01:56 <gwern> nah, just kidding. I'll mark it unsuccessful, quote him, and move on
07:02:00 <copumpkin> gwern: I propose "epic fail"
07:02:11 <djahandarie> What what happened with the immix gc?
07:02:15 <djahandarie> Wait*
07:03:03 <gwern> djahandarie: it failed. abandoned. never going to be in ghc. pining for the fjords.
07:03:20 <djahandarie> :(
07:03:48 <djahandarie> Because it was too hard to finish, or because it wouldn't help even if it was finished?
07:04:14 <marcot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Immix
07:04:22 <djahandarie>  Ah, thanks
07:04:40 * djahandarie goes to class before he's late
07:04:42 <marcot> djahandarie: Feel free to continue the work.
07:05:08 <marcot> Is there a haskell API for querying hackage, or should I just use cabal-install and parse its results?
07:05:11 <gwern> interesting details. didn't know it worked or was better on some benchmarks
07:07:39 <geheimdienst1> marcot: cabal list has a switch --simple-output that is more parseable ...
07:08:05 <marcot> geheimdienst1: Yes, that's what I'm planning to use if I don't find something better.
07:08:47 <preyalone> MissingH won't update. http://pastebin.com/DUt1wuxU
07:09:07 <geheimdienst1> what data are you looking for? if it's in the *.cabal files, you can always just extract 00-index.tar and grep through it. it's all plaintext
07:09:31 <preyalone> (I'm using cabal-install 0.8.2 / Cabal 1.8.0.6 / GHC 6.12.3 / Mac OS X 10.6.6)
07:11:57 <marcot> geheimdienst1: I want the list of packages, and then download the .tar.gz of a specific one.  I think using cabal install is a good enough option.
07:12:32 <geheimdienst1> marcot, sure
07:21:29 <HugoDaniel> hi
07:21:46 <HugoDaniel> im trying to do a edsl in haskell to produce sql
07:22:31 <HugoDaniel> what would be the best way to represent two word commands, like "CREATE TABLE" and others like it  ?
07:25:19 <Jafet> data Command = ... | CREATE Table ...
07:25:24 <Jafet> data Table = TABLE
07:25:49 <HugoDaniel> yeah
07:26:03 <HugoDaniel> and then how would i represent the CREATE SCHEMA ?
07:26:46 <HugoDaniel> the thing is that in SQL these are diff commands, with different synopsis :/
07:27:07 <Jafet> Uh we are discussing this facetiously right
07:27:12 <HugoDaniel> :)
07:27:14 <HugoDaniel> sorry
07:28:30 <Jafet> If you care about the look, you can make a TH preprocessor
07:36:56 <HugoDaniel> ah okey
07:37:00 <HugoDaniel> yeah, i care about the look :)
07:39:27 <zygoloid> HugoDaniel: switch to lowercase :)
07:40:41 <roconnor> @where TTFP
07:40:41 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
07:43:42 <roconnor> heh, I just got a email address to every Haskeller in the world
07:44:22 <copumpkin> roconnor: you broke haskellers.org?
07:44:34 <copumpkin> I love that book by the way
07:44:37 <copumpkin> (TTFP)
07:44:52 <roconnor> I don't think I broke haskellers.org
07:45:03 <roconnor> James Spencer may have though
07:47:17 <djahandarie> Broken? How did it break
07:49:16 <roconnor> I don't know how James Spencer harvested his emai list
07:49:24 <roconnor> probably not haskellers.org
07:49:35 <roconnor> since there are pleanty of other ways to get a list of all haskell users :)
07:49:47 <djahandarie> I didn't get an email so probably not haskellers
07:49:50 <zygoloid> roconnor: not every haskeller :) i don't think you'll have my email address there
07:50:03 <copumpkin> who's James Spencer and how do you know he has all those emails?
07:50:15 <copumpkin> oh I see
07:50:24 <copumpkin> 120k gbp doesn't sound too shabby
07:50:36 <roconnor> copumpkin: because he has a huge list of emails in the To: field of the email I just got
07:50:45 <copumpkin> yeah, I see that now :)
07:51:18 <djahandarie> Can't even use BCC? Sad
07:51:38 <dankna> hm.  somebody spammed a job posting to --
07:51:40 <dankna> oh haha
07:51:51 <copumpkin> it's just a recruiter
07:51:54 <dankna> he probably scraped Cabal if I had to guess
07:51:58 <copumpkin> that company should just use functionaljobs
07:52:06 <dankna> you're right, it's just a recruiter
07:52:16 <djahandarie> Would certainly make them look less :evil: at least
07:52:20 <dankna> indeed
07:52:33 <dankna> well, recruiters do things that neither party would approve of
07:52:39 <copumpkin> :P
07:52:41 <dankna> I've heard of them falsifying applicant resumes!
07:52:41 <zygoloid> djahandarie: i got a mail a while ago which hadn't had the BCC list scrubbed (!)
07:52:46 <dankna> without telling the applicants they were doing so
07:54:23 <dankna> thanks for telling me about functionaljobs :)
07:55:10 <dankna> unfortunately my problem is a high level experience but complete lack of academic qualifications or experience in a corporate setting, so I'm certainly not qualified for any of these jobs, at least as far as the employers are concerned :(
07:55:12 <dankna> but hey
07:55:41 <djahandarie> I'm sure some of those people would value experience as much as or more than a degree
07:56:31 <dankna> I can hope.  My resume right now is a list of personal and group open-source projects I've been on, because, well, I don't have anything else.
07:56:48 <dolio> It's probably a list of people from haskell-cafe or something.
07:56:48 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
07:57:06 <dankna> right now I don't see anything in locations I can handle, except Jane St has an NYC office but they only interview you once per lifetime so I'm waiting till I look better on paper before I waste my shot :)
07:57:19 <dankna> but yeah, anyway, thank you for the encouragement
07:58:09 <copumpkin> they only interview once per lifetime?
07:58:11 <copumpkin> interesting
07:58:26 <djahandarie> You will never improve so we'll only interview you once!
07:58:27 <dankna> yes, I heard that from a friend who interviewed there
07:58:40 <copumpkin> crazy
07:58:42 <dankna> it is
07:58:57 <gwern> well, it doesn't seem to be too disastrous for them
07:58:58 <Jafet> Sounds like quickcheck
07:59:04 <gwern> they're still quite profitable I hear
07:59:59 <dankna> oh yes, they're very successful
08:00:08 <copumpkin> despite the horrible syntax!
08:00:08 <copumpkin> omg
08:00:15 <zygoloid> sounds like a sensible policy to me. in my experience, the difference between a "yes" candidate and a "no" candidate is almost never marginal.
08:00:44 <dankna> I have no opinion on whether it's a sensible policy or not, I can certainly imagine that it could be
08:00:59 <dankna> yesterday I was reading some thread where somebody was asking about how to raise rlimit on file descriptors on OS X
08:01:10 <dankna> and the guy who responded was like "YOU DON'T NEED TO DO THAT go away"
08:01:29 <dankna> in great depth and very repetitively
08:01:56 <dankna> I found that rather obnoxious.  it's true that there are many areas for which using hundreds or thousands of fds would be a significant design flaw.
08:02:12 <dankna> but there are also things where it's essential - massively concurrent network services; load generators.
08:02:26 <dankna> without knowing anything about it, how can you judge?
08:02:39 <copumpkin> zygoloid: depends if it's HR saying he doesn't have the academic qualifications they want, I'd guess?
08:02:42 <copumpkin> which can actually change
08:02:46 <dankna> so I don't think I can judge whether their interviewing policy is reasonable, because my own experience with hiring people is very limited :)
08:02:48 <Jafet> High volume social interactions require fast filtering.
08:03:53 <zygoloid> copumpkin: sure. but if HR are saying you don't check enough boxes, i'd think you wouldn't get an interview in the first place?
08:04:02 <copumpkin> zygoloid: true that
08:05:28 <dankna> Jafet: that's not necessarily true.  in AI boardgame algorithms, what's important is not how many nodes you traverse (well, less important) but how good your evaluation function is at each node.
08:05:50 <dankna> Jafet: not saying interviewing is the same.  only saying that merely being high-volume does not imply that you have to traverse nodes quickly to do well.
08:08:30 <Jafet> Not really, you can use a really bad evaluation function and still have a good evaluation. Anyway that's a bad analogy
08:08:41 <dankna> yes, it is
08:08:55 <Jafet> Um, which boardgame
08:09:07 <dankna> let's say Go for the sake of argument, because it's the one I know the most about
08:09:18 <dankna> obviously in games that are small enough to solve, things are different
08:09:38 <dankna> but you're right, it's a bad analogy
08:09:44 <dankna> the only thing they have in common is that they're searches
08:09:53 <dankna> they're not even the same type of search, as boardgames are recursive
08:09:57 <dankna> recursing on humans would be "interesting" :)
08:10:04 <Gracenotes> well, size does have some inverse correlates. For example, one of the largest problems in AI is making tic-tac-toe fun.
08:10:10 <Gracenotes> I don't believe anyone has succeeded
08:10:11 <xplat> > let {glue x ys@(y:_) | x == y = ys; glue x ys = x:ys} in foldr glue [] "aaabbccxxbaaa"
08:10:11 <dankna> true!
08:10:12 <lambdabot>   "abcxba"
08:10:12 <Jafet> Ask any financial analyst
08:10:13 <dankna> haha
08:10:49 <Jafet> Oh hm, they're financial analysts
08:12:46 <dankna> yes, they are, haha
08:14:58 <McManiaC> hmmm the profiles on haskellers.com are messed up
08:15:31 <Bynbo7> yeah... i have two now -_-
08:15:45 <Bynbo7> from the same google openid login
08:15:58 <McManiaC> I mean their layout :)
08:16:05 <McManiaC> or is it just me?
08:16:13 <kmc> what's interviewing to what now
08:16:53 <djahandarie> Bynbo7, ask snoyman to delete one
08:17:09 <dankna> nobody's interviewing to anything, but we were /talking/ about interviewing to Jane St and the fact that they only interview you once per lifetime
08:17:18 <Bynbo7> why, I've got twice the exposure now :P
08:17:28 <djahandarie> lol
08:18:07 <Botje> why would they interview someone multiple times?
08:18:34 <gwern> Botje: perhaps not all of their people are available to interview you en masse
08:18:39 <Gracenotes> what they really do is they put you through a skill-set-freezing machine after they interview you. so they don't have to interview you again.
08:18:45 <gwern> and gang-bang interviews can be very unpleasant
08:18:48 <dankna> Gracenotes: egads!
08:18:58 <Gracenotes> and wipe your memory
08:18:58 <gwern> serial interviews are a little less stressful
08:19:00 <jmcarthur> huh wha interviews?
08:19:02 <Jesin> hmm
08:19:03 <Botje> oh. I thought you were talking about interview-fail-retry
08:19:20 <Jesin> could somebody explain how the monomorphism restriction works in this case:
08:19:24 <dankna> obviously there needs to be (to borrow videogame terminology) a cooldown period on interviews
08:19:30 <dankna> you can't just spam interview-interview-interview
08:19:52 <Jafet> Wouldn't their policy lead to a space leak
08:20:06 <gwern> jmcarthur: is there another term for interviews where a whole group of guys pile onto the subject and ask probing questions?
08:20:07 <Jesin> elemBy eq = go where
08:20:10 <Jesin>   go x (y:ys) = eq x y || go x ys
08:20:12 <Jesin>   go _ [] = False
08:20:13 <dankna> no, the space usage storing records of people already interviewed is bounded by the population of the planet :)
08:20:14 <Jesin> -- this results in elemBy :: (a -> b -> Bool) -> a -> [b] -> Bool
08:20:15 <Jesin> myElem = elemBy (==)
08:20:28 <djahandarie> Rogue paste?
08:20:55 <Jesin> hmm, I'll put this on hpaste
08:20:58 <Botje> Jesin: can you put that paste on hpaste.org or something? otherwise it will scroll right off
08:21:03 <gwern> dankna: but that's not a constant, it's growing at O(n)!
08:21:23 <dankna> gwern: the second derivative of it is negative
08:21:25 <Jafet> So are hard drive sizes, I guess
08:21:32 <gwern> dankna: I was hoping you didn't know that :)
08:21:37 <dankna> hahahahaha
08:21:52 <xplat> HugoDaniel: if you care about the look and you want to not depend on TH, you can follow that paper than implemented LR parsers in the type system ...
08:21:52 * gwern makes the little 'darn!' fist motion
08:22:16 <dankna> LR parsers in the type system?!
08:22:26 <jmcarthur> gwern: aside from gang bang interviews?
08:22:33 <jmcarthur> what's wrong with that one? :P
08:22:52 <Jafet> Is SQL LR?
08:22:54 <gwern> jmcarthur: I think white interviewers might be offended by being likened to black people
08:23:33 <HugoDaniel> xplat, can you give me the paper ?
08:23:36 <Jafet> I don't think we need that level of detail in this analogy
08:23:40 <HugoDaniel> a link to it
08:23:47 <xplat> HugoDaniel: i'm trying to find it
08:23:51 <HugoDaniel> thanks
08:23:59 <HugoDaniel> im looking at TH, and it is ugly :(
08:24:44 <zygoloid> gwern: "group interviews"
08:24:49 <gwern> zygoloid: hee hee
08:25:10 <Jesin> http://hpaste.org/43856/myelem_monomorphism_restricti
08:25:24 <djahandarie> You're trying to encode a SQL Parser in the type system?
08:25:26 <djahandarie> ...
08:25:27 <dankna> Jafet: SQL is in LR(1) yes
08:25:38 <dankna> Jafet: look at my language-sqlite to get you started.  it's written in Happy.
08:25:45 <Jesin> ...lol...
08:25:57 <HugoDaniel> dankna, its me
08:26:03 <Jafet> I was hoping for that question to be left unanswered, it's more jovial for everyone that way
08:26:18 <dankna> HugoDaniel, oh, okay, whoops
08:27:06 <Jesin> I'm not sure I understand the nuances of the monomorphism restriction
08:27:17 <Jafet> @quote dreaded
08:27:17 <lambdabot> No quotes match. You untyped fool!
08:27:22 <Jesin> it seems that GHC should be able to infer the type of myelem in http://hpaste.org/43856/myelem_monomorphism_restricti
08:27:29 <djahandarie> Turn it off and see what happens
08:27:42 <Jafet> Jesin: it did, but haskell 98 forbids it to do so
08:27:51 <Jafet> So, er, it didn't
08:28:22 <Jesin> ooh
08:28:29 <Jesin> is that changed in haskell 2010?
08:29:08 <dankna> HugoDaniel, what are you doing precisely that involves a type-level parser of SQL? :)
08:29:12 <HugoDaniel> what i want is to generate SQL code with haskell in a simple way 
08:29:24 <Jesin> I don't have the latest compiler, and I don't have package-installing privileges on this computer (I'm at school)
08:29:47 <HugoDaniel> and i can't find a good way to specify those two word sql commands
08:29:54 <HugoDaniel> like create table, create schema etc...
08:29:57 <Jesin> it infers the types fine when I use NoMonomorphismRestriction
08:29:58 <HugoDaniel> in haskell
08:30:05 <dankna> HugoDaniel: I did a /lot/ of work on modeling SQL for language-sqlite
08:30:06 <Jesin> but is that standard Haskell 2010?
08:30:24 <dankna> HugoDaniel: I'd have to check the details of how I did it, but I'd be /fascinated/ by patches for other engines
08:30:32 <HugoDaniel> yeah
08:30:37 <HugoDaniel> im trying to look for you sqlite
08:30:43 <dankna> and language-sqlite is both a parser and a generator
08:30:43 <HugoDaniel> s/you/your
08:30:49 <dankna> @hackage language-sqlite
08:30:49 <HugoDaniel> good stuff
08:30:49 <lambdabot> http://hackage.haskell.org/package/language-sqlite
08:30:54 <dankna> whoops
08:30:56 <dankna> did I never release it!
08:31:03 <HugoDaniel> :D
08:31:08 <dankna> http://dankna.com/software/darcs/language-sqlite/
08:31:10 <dankna> no darcsweb sorry :)
08:31:18 <HugoDaniel> i would be very happy to provide a patch for postgresql
08:31:26 <Jesin> Jafet?
08:31:34 <HugoDaniel> sqlite is going to allow me to keep on going with my project
08:31:39 <dankna> I have to think a bit about how to parametrise things on backend
08:31:52 <dankna> but write your patch and then I'll see where it differs and how to merge it
08:32:04 <fryguybob> Jesin: look at this: http://hackage.haskell.org/trac/haskell-prime/wiki/NoMonomorphismRestriction
08:32:41 <dankna> if it simplifies things for you, you can simply do a straight port to postgresql instead of making it support both, and I'll take on maintainership and try to invent a way to make it one version
08:32:56 <dankna> but if you feel up to the challenge of doing that part too, go ahead
08:33:16 <dankna> my email is dankna@gmail.com if you need to reach me for any reason and I'm not on IRC, and you can also gtalk/Jabber to that address
08:33:17 * edwardk waves hello.
08:34:24 <HugoDaniel> dankna, a module with 2400+ lines  :)
08:34:40 <dankna> HugoDaniel, yeah, but it's very regular in structure, I didn't feel splitting it was the best approach :)
08:34:46 <dankna> let me know how readable you find the code, please
08:34:54 <dankna> you are to my knowledge the first one to look at it besides me
08:35:14 <dankna> I got bogged down in trying to build a bridge to allow the parser and generator to be used from C
08:35:21 <dankna> that's what those stray files not yet included in the build are for
08:35:34 <HugoDaniel> oh
08:35:41 <HugoDaniel> right now
08:36:07 <HugoDaniel> im trying to find a way to generate sql code
08:36:09 <dankna> right now?
08:36:12 <Jafet> Jesin: the type of elemBy (==) is t -> [t] -> Bool, which is polymorphic in t. Binding that to myElem without a type annotation is forbidden and is called the monomorphism restriction
08:36:20 <dankna> yes, this is both a parser AND a generator
08:36:42 <dankna> the type-class ShowTokens turns a snippet of SQL syntax into a list of SQL tokens
08:37:02 <dankna> and the Show instance on [Token] then prints it out
08:37:26 <Jafet> Jesin: that's pretty much what the monomorphism restriction is
08:37:31 <Jesin> Jafet: and this is around in Haskell 2010?
08:37:34 <Jafet> @where monomorphism restriction
08:37:34 <lambdabot> I know nothing about monomorphism.
08:37:43 <Jafet> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:38:00 <dankna> Tools.hs contains an example function which generates a set of queries to change a table schema in sqlite, which doesn't support the full ALTER TABLE syntax, requiring this workaround which is painful to do by hand
08:38:28 <Jafet> Jesin: probably not. Though you don't need to go all the way to hs' to get rid of it, or even language pragmas -- just use a type annotation and it goes away
08:38:47 <Jesin> yes
08:38:47 <HugoDaniel> data CreateTable'
08:38:47 <dankna> each query (and indeed, each little snippet of syntax) is a Haskell value with all its constructors exported, so to generate them, you simply construct them, as shown there
08:38:48 <HugoDaniel> :/
08:38:50 <Jesin> but
08:38:52 <Jesin> hmm
08:38:58 <Jesin> -- This is not allowed
08:39:00 <Jesin> f4 = show
08:39:23 <Jesin> I can understand why you might want the restriction in tuples
08:39:24 <Jesin> but
08:39:26 <dankna> HugoDaniel, why is that a ":/" thing?
08:39:37 <Jesin> how does that generalize to cases like "f4 = show"
08:39:53 <dankna> HugoDaniel, the types with ' after them exist to be witnesses for the Statement GADT
08:39:54 <Botje> Jesin: because show :: Show a => a -> String
08:40:03 <HugoDaniel> shift/reduce conflicts:  18
08:40:04 <Botje> so that's not *one* type
08:40:08 <dankna> eep!
08:40:10 <dankna> let me check that
08:40:19 <dankna> I could have sworn I got it to zero
08:40:24 <dankna> I don't regard shift/reduce conflicts as acceptable
08:40:24 <HugoDaniel> oh
08:40:36 <Jesin> hmm
08:41:03 <dankna> hold on, I had unpushed patches
08:41:06 <dankna> I'm syncing that repo for you
08:41:46 <dankna> okay, go ahead and pull.  sorry!
08:42:44 <dankna> oh wowwwww, the patch that added complete documentation to Types.hs was one of the unpushed ones
08:44:19 <McManiaC> what's the name of those "foo :: (a ~ b) => a -> c" predicates?
08:44:35 <dankna> unification constraints?
08:44:48 <dankna> unification is the operation of taking two data structures and turning them into one
08:45:07 <McManiaC> hmhm
08:45:10 <dankna> the a ~ b expresses that a must unify with b, that is, must be possible to combine with it as if they are equal
08:45:58 <Jafet> @hoogle (~)
08:45:58 <lambdabot> Test.HUnit.Base (~:) :: Testable t => String -> t -> Test
08:45:58 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
08:45:58 <lambdabot> Test.HUnit.Base (~?) :: AssertionPredicable t => t -> String -> Test
08:46:41 <McManiaC> is something like this possible? http://npaste.de/xG/
08:46:53 <McManiaC> (it compiles, but it doesn't do what I want it to do :) )
08:47:35 <McManiaC> I might need some other approach…
08:48:49 <dankna> HugoDaniel, I reproduce your 18 shift/reduce conflicts and am debugging now.
08:49:33 <dankna> HugoDaniel, it's apparently unreleased code for a reason, but I hope I can persuade you to collaborate with me to meet your needs rather than reinventing something else :)
08:55:04 <latros> class Foo e a | e -> a where
08:55:07 <latros> ^wtf
08:55:17 <aristid> that's a functional dependency
08:55:19 <latros> I have not seen | in typeclass definitions; how does this work
08:55:22 <dankna> multiple-parameter type classes with functional dependencies
08:55:28 <latros> functional dependencies
08:55:30 <quicksilver> I think that spam was based on haskell-cafe contributors.
08:55:31 <latros> ok, now I have a name to look up
08:55:37 <dankna> do you understand the meaning of class Foo e a where, by itself?
08:55:41 <accel> is there a way to tell cabal to build in .dist rather than dist ?
08:55:42 <latros> yeah
08:55:45 <HugoDaniel> yeah dankna :)
08:55:48 <latros> Foo is a typeclass that takes two type parameters e and a
08:55:49 <dankna> HugoDaniel, good :)
08:55:50 <quicksilver> I'm not on haskellers.com or hackage.
08:55:51 <HugoDaniel> lets work together
08:55:56 <latros> so it's a thing of kind * -> * -> *
08:55:57 <dankna> great!
08:55:59 <copumpkin> accel: that'd be nice, ask dcoutts or put a ticket on the cabal trac?
08:55:59 <latros> er
08:56:03 <latros> the constructor is anyway
08:56:06 <accel> copumpkin: so, currently, no ?
08:56:12 <HugoDaniel> i was reading up on the sqlite docs, they seem to cover a good subset of the sql language
08:56:13 <aristid> accel: --builddir
08:56:23 <copumpkin> accel: oh maybe in your cabal config
08:56:24 <aristid>     --builddir=DIR      The directory where Cabal puts generated build files
08:56:24 <aristid>                         (default dist)
08:56:26 <HugoDaniel> at least it seems compatible with the other dbms's
08:56:36 <aristid> copumpkin: it's a command line option :P
08:56:39 <dankna> yes, they cover all the finicky bits language-wise, they just lack support for certain features that they regard as out of scope
08:56:49 <copumpkin> aristid: yeah, but those tend to be mirrored in cabal config file
08:56:51 <dankna> like things that nothing but Oracle really has a good solution for anyway
08:56:55 <copumpkin> aristid: so with any luck you can change it permanently!
08:56:58 <aristid> copumpkin: dunno, maybe.
08:58:22 <accel> aristid: what is the corresponding option in my blah.cabal file? 
08:58:30 <aristid> accel: no idea.
08:58:32 <copumpkin> .cabal/config
08:58:44 <quicksilver> latros: you're right that the typeclass takes two parameters.
08:58:53 <quicksilver> latros: typeclasses aren't really constructors.
08:58:55 <accel> copumpkin: ?
08:59:02 <copumpkin> you should have a ~/.cabal/config
08:59:04 <quicksilver> but the point is that "pairs of types" are instances of Foo.
08:59:08 <copumpkin> you might be able to set the option in there
08:59:12 <latros> right
08:59:15 <quicksilver> latros: for example : instance Foo Int Bool ....
08:59:21 <latros> yeah
08:59:26 <latros> I know that much, and now I think I see what this is
08:59:30 <latros> I needed a name to look up
08:59:31 <quicksilver> latros: you could describe it as a 'relation between classes'
08:59:35 <quicksilver> erm
08:59:37 <quicksilver> types!
08:59:39 <latros> not that
08:59:40 <quicksilver> latros: you could describe it as a 'relation between types'
08:59:43 <latros> the functional dependency bit
08:59:48 <latros> I didn't know the name
08:59:53 <latros> I think I'm clear now though, ty :)
09:00:02 <quicksilver> ok good, I'll stop rambling ;)
09:00:39 <copumpkin> I like the "relation between types" view of it
09:00:46 <copumpkin> not sure how to fit superclasses into that though
09:02:32 <aristid> copumpkin: relation between constrained polymorphic types?
09:02:34 <dankna> HugoDaniel, my memory on these conflicts is hazily returning.  I believe it's a case where sqlite does a poor job of documenting what the correct parse is.  Double-checking that now.
09:02:53 <HugoDaniel> yeah :/
09:03:04 <dankna> oh, you're also looking at the grammar debug?
09:03:10 <dankna> mind you, you can still use the GENERATOR with no problem at all
09:03:29 <HugoDaniel> right now im just looking at the sqlite docs 
09:03:34 <dankna> okay
09:03:41 <HugoDaniel> i miss a few features i use a lot in postgresql
09:03:49 <dankna> I'm curious what those are?
09:03:52 <HugoDaniel> like the possibility to write functions
09:03:59 <HugoDaniel> schemas are also handy
09:04:09 <xplat> i'm having real trouble finding that paper, i felt sure it would cite leijen and meijer's "domain specific embedded compilers", or else be cited by it, neither seems to be the case
09:04:11 <dankna> oh, yes.  well you can do functions but not in an embedded language, you have to do them in C.
09:04:20 <dankna> by schemas you mean enforced constraints?
09:05:28 <HugoDaniel> sql schemas, like namespaces that allow me to set user permissions
09:05:50 <dankna> oh, gotcha
09:05:55 <dankna> yes.  well sqlite has no server process.
09:06:13 <dankna> the database resides in a single file (it's a paged format with page-level locking)
09:06:21 <dankna> so if you have write permission to that file you have the theoretical ability to delete everything
09:06:39 <dankna> if you need user permissions, you need to implement a layer on top of sqlite to provide them
09:06:45 <HugoDaniel> alter column is also a nice good thing to have
09:06:49 <dankna> on the other hand in sqlite it's cheap to create a new database
09:06:55 <dankna> yes, alter column I really miss
09:07:00 <edwardk> preflex: xseen roconnor
09:07:00 <preflex>  roconnor was last seen on freenode/#haskell 1 hour, 16 minutes and 26 seconds ago, saying: copumpkin: because he has a huge list of emails in the To: field of the email I just got
09:07:05 <dankna> and I miss it without ever having had it :)
09:07:35 <dankna> part of my objective in writing this package was to make it possible to write tools that could generate queries for me to automate some of these tasks that have to be done by hand in sqlite as things stand
09:07:42 <dankna> like the alter-table example I showed before
09:08:01 <dankna> that example isn't heavily tested so don't rely on it in a production environment, btw
09:08:13 <dankna> or at least just read the queries through before you execute them
09:09:10 <jystic> Hi all, I'm trying to install hlint and cpphs fails to install with this error: Something is amiss; requested module  haskell98:Char differs from name found in the interface file haskell98-1.1.0.0:Char
09:09:22 <jystic> has anyone seen that before / know how to fix it?
09:10:05 <kulakowski> dankna: way late to this conversation, but I'd never heard the once-per-lifetime. I know a couple people who work there or have applied.
09:10:23 <kulakowski> kulakowski: once-per-lifetime interview at jane st, rather
09:10:27 <dankna> kulakowski, yes.  it's secondhand information so there's always the possibility my source misunderstood.
09:11:19 <kulakowski> dankna: I enjoyed a lot of the relayed interview questions, but imagine it would have been rather more stressful in the actual interviews.
09:11:33 * dankna nods
09:12:52 <kulakowski> The final interview day especially.
09:13:02 <dankna> HugoDaniel, ah, three of the eighteen conflicts were low-hanging fruit, a typo :)
09:13:07 <gwern> kulakowski: how would you move Mt Fuji and that sort of thing?
09:13:15 <dankna> Nukes.
09:13:16 <dankna> Lots of nukes.
09:13:38 <dankna> But also, I'd have to know the purpose for which it was being moved.
09:13:43 <dankna> How important is it that it wind up intact at the other end?
09:13:57 <dankna> Is the object just to get rid of it, or do we actually want a scenic mountain elsewhere?
09:14:09 <gwern> I have no idea. I was never actually able to get a copy of that Poundstone book
09:14:12 <dankna> Does the new mountain have to be composed of physically the same atoms as the old mountain, or can we just destroy it and recreate it?
09:14:16 <dankna> no, I'm saying, that's my answer
09:14:19 <gwern> so I remain ignorant of the parameters of Microsfot's question
09:14:35 <dankna> the purpose of that sort of question isn't to get an answer, it's to get a /type/ of answer.
09:14:45 <kulakowski> gwern: Nah, two sorts of questions. One series of questions I remember was order of magnitude things. E.g. how many cells in the average human brain, and your certainty of your guess. And then they have more like riddle or combinatorial math type questions.
09:15:04 <gwern> kulakowski: oh, I'm good at the magnitude questions. they're an awful lot of fun
09:15:07 <dankna> the "correct" type is one that shows creative thinking
09:15:07 <dsgsdfhS> Hello, is isqrt x >>= isqrt evaluted like isqrt (x >>= isqrt) or (isqrt x) >>= isqrt
09:15:29 <dankna> and ability to reason independently.  "I'd ask an expert in mountain-moving" is probably not a good answer
09:15:31 <kulakowski> But the last day, they give you x amount of poker chips, and when you say you are 90% certain that there are 10e12 brain cells, you actually make a bet at those odds. And so on for other types of like simulated trading questions.
09:15:38 <dankna> oh neat!
09:15:41 <Bynbo7> dankna: the latter
09:15:46 <Bynbo7> uh, dsgsdfhS*
09:15:46 <quicksilver> dsgsdfhS: the second
09:15:52 <gwern> kulakowski: are you betting your money or theirs?
09:16:12 <quicksilver> dsgsdfhS: function application binds tighter than any binary operator
09:16:14 <edwardk> @pl \a -> StoreT (set a) (get a)
09:16:14 <lambdabot> liftM2 StoreT set get
09:16:15 <dankna> do you have time to research the order-of-magnitude questions before the betting phase?
09:16:18 <edwardk> duh
09:16:24 <dankna> or is it purely based on what you can do off the top of your head?
09:16:34 <gwern> dankna: off the top of your head.
09:16:37 <dsgsdfhS> ok, thanks
09:16:38 <dankna> I see!
09:16:43 <Bynbo7> quicksilver: it's binding power goes to 11!... almost
09:16:50 <dankna> well, I know cells are visible individually at 1000x magnification
09:16:54 <Jesin> hmm
09:16:59 <kulakowski> gwern: It's more to test how good you are at judging your certainty. That's why you give both an answer and a range or a certainty.
09:17:09 <dankna> that implies that an individual cell is about five feet divided by 1000 in diameter
09:17:14 <Jesin> is the type system turing complete, or is that only with GHC extensions or not at all or what?
09:17:27 <dankna> wait no
09:17:40 <dankna> well, anyway, if I thought about it a little more I could use that information to get a bound on the size of cells
09:17:44 <gwern> dankna: for example, with the brain question, I would start reasoning as follow - I know there are around 0-10 trillion cells in the human brain, so I'll say there are 5 trillion. I weigh 200 pounds and my head is around 10 pounds, so it's 5% of my weigh. what's 5% of 5 trillion? etc
09:17:50 <quicksilver> Bynbo7: :)
09:18:03 <dankna> right, but I can't start that way because I don't remember the 0-10T figure
09:18:12 <quicksilver> Jesin: turing complete with UndecidableInstances
09:18:22 <quicksilver> Jesin: can't remembr if you also need Overlapping. I don't think so.
09:18:32 <gwern> dankna: as it happens, I'm off by a factor of 10 - WP tells me that the adult body has somewhere under 100 trillion, not 5 trillion
09:18:43 * dankna nods
09:18:55 <Jafet> If we're talking about the effective number of brain cells, there are various estimation methods
09:19:10 <saml> how can i do dependency injection ?
09:19:28 <gwern> saml: what does dependency injection mean in a haskell context?
09:20:10 <gwern> Jafet: if I were asked the number of neurons, I'd pull out of my ass a vaguely remembered factoid that there are something like 10 glial and other cells to every neuron, so I'd multiply by 10% whatever I previously got
09:20:14 <saml> gwern, that was my question
09:20:37 <saml> give me category that is dependency injection
09:20:58 <kmc> finance industry _loves_ the puzzle interview questions
09:21:04 <kmc> even for programmers
09:21:09 <kmc> i think they've fallen out of favor in most of the rest of programming
09:21:29 <kmc> i like puzzles and like asking them in interview but i'm not sure they're actually valuable for assessing candidates
09:21:33 <saml> like, let's say i'm in Foo monad.  but Foo monad uses Bar monad
09:21:42 <kmc> you anyway have to know how to interpret the results
09:21:42 <dankna> for finance industry puzzles make sense
09:21:48 <saml> so you automatically form monad transformer for Foo
09:21:50 <dankna> because the industry is all about critical thinking
09:21:58 <saml> that's dependency injection
09:21:59 <kmc> dankna, not for programmers in finance industry
09:22:08 <copumpkin> kmc: I think it's very important to be able to reason verbally about how many grains of sand are caught in your navel after 6 hours 42 minutes at the beach on a hot day
09:22:15 <kmc> also what industry isn't about critical thinking
09:22:25 <kmc> copumpkin, navel gazing? :O
09:22:40 <edwardk> i'm kinda sick of puzzle interviews
09:22:41 <dankna> kmc: I'd think even programmers in that industry would be expected to be able to catch major conceptual flaws.  Sometimes they're the only ones in a position to say "um, there is no algorithm that does X, did you mean you wanted an approximation Y?"
09:22:42 <gwern> kmc: 'you cannot proceed from the informal to the formal by formal methods'; where the critical thinking hits the metal, you still want the code monkeys to be able to roll basic sanity checks
09:23:03 <gwern> ...what a bizarre sentence that is
09:23:18 <kmc> saml, if you want to turn monads into monad transformers the way to do it is to write the monad transformer first and then define the monad as that transformer applied to Identity
09:23:18 <dankna> yes, where the mixed metaphors are spoiled by too many different drummers...
09:23:21 <saml> yah puzzle interviews are hard
09:23:22 <edwardk> i prefer to do interviews by drilling into whatever area the candidates claim are their focus areas until i find where their knowledge stops
09:23:27 <kmc> too many drummers in the kitchen
09:23:41 <copumpkin> too many cooks in the orchestra
09:23:43 <edwardk> then sound around other areas until i get a feel for the breadth and depth of their knowledge base
09:23:44 <dankna> haha
09:23:48 <kmc> gwern, dankna i agree in principle but i'm not sure most finance companies see their programmers this way
09:23:50 <dankna> copumpkin: that's a good variant!
09:23:55 <dankna> kmc: okay.  that's fair.
09:23:56 <saml> i wanna do this:   class Foo @Depends(Bar)
09:24:07 <edwardk> too many pumpkins in the Met.
09:24:07 <saml> and i can specify instance of Bar to use during runtime
09:24:20 <saml> that's dependency injection
09:24:23 <gwern> kmc: perhaps. I suspect jane street does, and it was their puzzles who start the conversation, so...
09:24:24 <kulakowski> kmc: A different sort of question they did was a mock trading thing. They would state, one at a time, a series of buy or sell bids on different items, and you say which if any you would take. The idea being to spot the (sometimes complex) arbitrage opportunities.
09:24:29 <kmc> gwern, yeah
09:24:42 <saml> puzzle interview is hard
09:24:49 <saml> you have to be smart to get it right
09:24:49 <gwern> edwardk: that sound slike a good strategy if you have enough depth yourself to compete with them
09:25:16 <saml> edwardk, to do that, you have to be better than the candidate
09:25:22 <edwardk> gwern: i've probably hired 60-70 programmers with it over the last 15 years and it has paid off nicely.
09:25:22 <saml> your knowledge have to be larger
09:25:25 <dankna> I enjoy arbitrage.  I bought maelstrom crystals before the disenchanting fix, held them for four weeks while people cleared their inventories, and sold them for a net profit of about 5000 gold.  ummmm..... real life?  what? :)
09:25:35 <gwern> edwardk: but aren't you a pretty atypical programmer?
09:25:45 <kmc> well of course if the candidate is better than you then you need to say "no hire" anyway, for job security
09:25:46 <kmc> ;)
09:25:47 <dankna> I think everyone in this room is an atypical programmer
09:25:48 <edwardk> gwern: there is that factor
09:25:58 <saml> how can i work under exceptional programmer boss?
09:26:00 <dankna> at least everyone who talks :)
09:26:02 <kmc> dankna, it's really not that different
09:26:08 <kmc> saml, start your own company
09:26:10 <gwern> dankna: I don't think I'm very good, imo
09:26:12 <dankna> kmc: yeah, I know.  I was half joking and half serious.
09:26:15 <saml> kmc, but then i have no boss
09:26:20 <dankna> gwern: I didn't say exceptional, I said atypical. :)
09:26:20 <kmc> saml, then you are your own boss
09:26:27 <saml> i'm not exceptionall
09:26:28 <gwern> dankna: now I feel even worse
09:26:29 <latros> that assumes that you are exceptional :p
09:26:32 <latros> lol
09:26:33 <dankna> gwern: lol
09:26:36 <latros> saml and I think alike apparently
09:26:38 <edwardk> well, when the applicant can go deeper than me about an area i happen to care about, i hire the guy, then learn what he knows =P
09:26:46 <edwardk> so it works out for me either way
09:26:49 <quicksilver> edwardk: and then fire him? ;)
09:26:53 <HugoDaniel> dankna, like handicapped ?
09:27:02 <saml> edwardk, can you interview me here?
09:27:04 <periodic> How are you going to get better if you don't have people at least as good as you if not better around?  If they're so good, get better than them.
09:27:07 <gwern> 'I HAVE CONSUMED YOUR KNOWLEDGE; LEAVE ME LEST I CONSUME YOUR FLESH AS WELL'
09:27:08 <saml> to figure out my depth of knowledge
09:27:16 <djahandarie> LOL gwern 
09:27:27 <dankna> HugoDaniel, nah haha.  I just mean that we have strong ideas about what good programming is - probably many of those ideas in common with each other, but many different too
09:27:37 <HugoDaniel> hmm
09:27:42 <dankna> I think many run-of-the-mill programmers don't really think about the deep questions
09:27:48 <HugoDaniel> right now i feel the height of the SQL mountain that is ahead of me :(
09:27:49 <edwardk> sami: at some point, i don't really have the bandwidth at this exact moment in time though
09:27:54 <HugoDaniel> that kind of leaves me depressed
09:28:01 <djahandarie> Yeah he's on 56k right now
09:28:07 <saml> edwardk, ok poor canadian
09:28:12 <saml> upgrade ISP
09:28:16 <dankna> HugoDaniel, don't worry!  it's doable!  language-sqlite was only a couple weeks for me and it's a total model of what sqlite can do (not counting those conflicts)
09:28:31 <dankna> and you'll have help :)
09:28:57 <Jafet> sqlite is 90% of SQL for 10% of the complexity
09:29:02 <edwardk> gwern: i usually go with 'SOUL' but thats pretty much it
09:29:07 <copumpkin> @remember gwern [quoting a hypothetical edwardk] 'I HAVE CONSUMED YOUR KNOWLEDGE; LEAVE ME LEST I CONSUME YOUR FLESH AS WELL'
09:29:07 <lambdabot> Okay.
09:29:09 <periodic> and 5% of the performance
09:29:12 <dankna> Jafet: I hope you're wrong
09:29:14 <Jafet> Granted, I don't even use 10% of that 90%
09:29:22 <saml> lambdabot is dead
09:29:29 <gwern> @quote gwern
09:29:29 <lambdabot> gwern says: I made so many compilation errors because I can't spell lambdab right
09:29:35 <gwern> seems alive to me
09:29:37 <copumpkin> saml: doesn't look like it, and either way it's irrelevant
09:29:44 <dankna> HugoDaniel, if you could start things off by coming up with a rough list of the features PostgreSQL has that SQLite doesn't?
09:29:46 <saml> i mean nasdaq bug is not fixed
09:29:49 <monochrom> hehehe lambdab
09:29:58 <saml> like @google nasdaq:goog
09:30:15 <edwardk> That leaves me with disturbing visions of gwern dancing the lambada calculus.
09:30:16 <HugoDaniel> i need to generate SQL for my datatypes, create tables, and some predefined functions to read, show and query those tables
09:30:30 * dankna nods
09:30:44 <gwern> edwardk: at least I'm putting my degree in modern interpretive dance to work
09:30:46 <dankna> that's very much the sort of thing I want to support
09:31:21 <accel> I find that formodules I write; to avoid name clashes, I tend to always use "import qualfied" rather than "import"; is this bad?
09:31:32 <HugoDaniel> sqlite seems the right tool, can i use haskell to generate a static compiled binary that bundles sqlite ?
09:31:37 <edwardk> Breath deep, you need to feeeeel the eta contraction.
09:31:53 <dankna> HugoDaniel, yes you can.  see the direct-sqlite package, also by me.
09:32:20 <dankna> HugoDaniel, there are other alternatives but, well, I explain why I couldn't use them in the package description - no UTF8, no BLOB, or both
09:32:41 <HugoDaniel> yeah, i am definetly needing UTF8
09:32:58 <dankna> HugoDaniel, direct-sqlite doesn't currently bundle a copy of sqlite.c, but it could easily do so, let me know if you need that.  there's a ticket on my issuetracker which explains how to modify the .cabal to build with it, link in a sec
09:33:02 <HugoDaniel> can i get a product up and runing in the "real world" with these by next week  ?
09:33:14 <gwern> HugoDaniel: how fast do you write?
09:33:16 <HugoDaniel> :D
09:33:18 <dankna> it depends on how big a product, but I'll be available to help
09:33:21 <HugoDaniel> i write FAST :)
09:33:24 <dankna> they are both existing packages, not things in need of inventing
09:33:26 <HugoDaniel> cool
09:33:35 <HugoDaniel> ill add you to my gchat and we talk there :)
09:33:57 <dankna> great :)
09:34:45 <periodic> Why so fast?
09:37:53 * hackagebot Pathfinder 0.5.1 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.5.1 (GeorgeGiorgidze)
09:46:06 <xplat> HugoDaniel: somehow although i found this paper TWICE by accident i can't find it on purpose now :7
09:46:56 <lowasser> Has anybody else ever tried to implement AVL trees, enforcing the balancing constraint in the type system?
09:47:15 <xplat> yes
09:47:16 <HugoDaniel> xplat, no problem, im going to work with language-sqlite :)
09:47:16 <HugoDaniel> thanks
09:49:48 <c_wraith> lowasser: That'd be pretty easy with type-level naturals.  Even if the obvious way isn't the most efficient.
09:50:05 <lowasser> yeah, no, it's actually looking quite nice right now
09:50:06 <xplat> lowasser: you should be able to do it with a nested type or with a type-level natural and boolean
09:50:23 <lowasser> mostly I'm just trying to work out minor little details now
09:50:29 <lowasser> like how to implement fromDistinctAscList ;)
09:51:08 <xplat> the fun thing is when you have dependent types and you can enforce the search tree property too
09:51:39 <lowasser> heh
09:51:46 <lowasser> interesting
09:57:43 <marcot> When I run cabal list --simple-output as root, it shows an empty line.  It's generated because of an empty InstalledPackage.  Can you reproduce that?
09:58:10 <accel> does haskell have a generational gc option for real time apps?
09:58:36 <kmc> GHC's garbage collector is generational but doesn't make any RT guarantees
09:58:44 <kmc> other Haskell implementations are free to implement other garbage collection strategies
09:59:04 <accel> kmc: where can I read up more on gc in ghc ?
09:59:10 <kmc> the ghc developers' wiki
09:59:11 <kmc> and the ghc manual
09:59:20 <accel> kmc: thanks
09:59:20 <kmc> GHC Haskell has been used for soft realtime stuff in the 10s of ms response time range
09:59:32 <accel> kmc: that's good enough for me; I need only 30fps
09:59:34 <accel> which is like 66ms
09:59:35 <kmc> but i wouldn't use it for anything in the microsecond range
09:59:49 <accel> kmc: no worries, I'm not in HFT
09:59:54 <kmc> :D
10:00:02 <kmc> ah; i know some games use Haskell for game logic, AI, etc., communicating with a C or C++ thread that does the realtime render loop
10:00:14 <Jafet> If 66ms is like 30ms
10:00:19 <kmc> similar for setting audio parameters vs. rendering audio to the soundcard
10:00:31 <accel> I'm using Haskell for the render loop ....
10:00:40 <accel> I don't see why that would be a problem if I can get gc's to be 10ms
10:00:45 <kmc> some day GHC will have independent per-core garbage collectors and that should improve the latency a lot
10:00:47 <Twey> Jafet: Hmm?
10:00:55 <kmc> accel, pretty sure you will have occasional GC larger than 10ms
10:00:57 <Twey> T = 1 / f
10:00:58 <kmc> but anyway, try it out
10:01:17 <saml> can you eliminate GC from haskell? GS is not web scale
10:01:25 <saml> or give me an example where GC is used. 
10:01:25 <accel> kmc: actually, the machine is multi core, so is there a way to have a dedicated haskell thread to do rendering?
10:01:32 <accel> kmc: or does the current gc stop all threads?
10:01:36 <saml> should be used... like recursive data structure?
10:01:49 <periodic> There's no way to switch GC to be manually stopped/started by some sort of monitor thread, is there?
10:01:53 <kmc> accel, the latter
10:02:11 <kmc> accel, GHC has a parallel garbage collector but all OS threads run it at once
10:02:21 <dcoutts> periodic: you can trigger GC early, but what do you want to do when a GC is required?
10:02:24 <accel> kmc: got it; thanks for insights
10:02:37 <accel> dcoutts: how do you force trigger a gc?
10:02:49 <accel> dcoutts: I may, say, trigger one after every glutPostRedisplay
10:02:59 <dcoutts> System.Mem.performGC
10:03:03 <kmc> accel, i think the plan is to eventually move to a per-core heap for young objects and a totally independent per-core gen0 collector
10:03:24 <dcoutts> kmc: but that will not do anything for old generation collections
10:03:28 <kmc> right
10:03:35 <Jafet> Make less garbage!
10:03:45 <periodic> dcoutts: I was wondering if you had a loop like accel wants if you could do incremental GC based on how much time you had left before your next frame.
10:03:45 <dcoutts> kmc: so it'll reduce the number of pauses, but not the latency of a major collection
10:04:17 <dcoutts> periodic: the thing to do is simply to schedule GC at times when you know you have some time available
10:04:27 <periodic> just a thought.  i know nothing about how the GC is actually implemented.
10:04:31 <periodic> dcoutts: exactly.
10:04:35 <accel> dcoutts: ha, my current system runs fine with a performGC after every frame :-)
10:04:51 <dcoutts> accel: sounds fine
10:04:54 <roconnor> Dazzle mine eyes, or do I see three suns?
10:04:58 <periodic> heh, that sounds about right.
10:05:12 <Jafet> Mightn't that substantially decrease performance?
10:05:37 <dcoutts> Jafet: sure, but accel cares about timing/latency not performance
10:06:36 --- mode: ChanServ set +o copumpkin
10:06:40 --- mode: copumpkin set -o copumpkin
10:06:41 <copumpkin> whoops
10:06:55 * accel notes to not annoy copumpkin
10:07:20 <copumpkin> it really was a mistake, not a muscleflex :P
10:07:30 <Jafet> It sounds like a fishy tradeoff to me, unless the latency has a measurable effect
10:07:30 <copumpkin> I was trying to op myself in another channel and mechanically typed #haskell
10:07:47 <edwardk> hah
10:07:48 <accel> copumpkin: I aspire to one day be capable of such mistakes
10:10:50 <kmc> haha
10:12:04 <kmc> accel, did you also play with the various +RTS options for garbage collector tuning?
10:12:19 <accel> kmc: no, I haven't looked ito any of that, tell me more
10:13:13 <kmc> http://donsbot.wordpress.com/2010/07/05/ghc-gc-tune-tuning-haskell-gc-settings-for-fun-and-profit/
10:13:31 <accel> kmc: whoa; pretty pictures; thanks
10:13:43 <kmc> i've had good success improving computational throughput by increasing -A
10:13:53 <kmc> it should make GC more rare but also take longer, so it might not be good for your application
10:14:02 <accel> in ghc, is everything heap allocated
10:14:09 <accel> or when it's smart enough to stack allcoate stuff
10:14:10 <kmc> anyway the RTS options are described here: http://haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
10:14:13 <accel> it just stack allocate it then pops it off?
10:14:24 <kmc> accel, "heap" and "stack" have a very different meaning than in C
10:14:40 <kmc> when GHC allocates something in the heap it looks like a C program allocating in the stack
10:14:44 <kmc> it just increments a pointer
10:14:48 <kmc> there's no need to walk a free list, etc.
10:15:02 <accel> so when it gc's it "jumps off the tower" and collets the stack ?
10:15:06 <kmc> in fact there's no "free this object" operation in the runtime system
10:15:15 <kmc> it just accumulates garbage sequentially and then GCs
10:15:16 <kmc> yeah
10:15:30 <kmc> and GHC programs have a "stack" too
10:15:51 <kmc> which holds not function call frames, but pattern-match continuations
10:16:11 <kmc> and also function args sometimes 
10:16:29 <accel> kmc: this reminds me of certain implementatiosn of scheme w/ CPS
10:16:42 <shepheb> okay, GHC is telling me the patterns "r" and "roll" are overlapping.
10:16:50 <shepheb> OverloadedStrings is on, if that matters.
10:16:52 <shepheb> 6.12.1
10:17:17 <kmc> when you say "case e of [stuff]" it has to jump into the code which evaluates e, but it needs to remember the continuation "case _ of [stuff]"
10:17:21 <kmc> and so that record goes on the stack
10:18:46 <kmc> accel, but the answer to "is everything heap allocated" is "yes", if by "everything" you mean "all closures"
10:19:09 <kmc> and what GHC means by a closure is not only a function in normal form but also an unevaluated thunk, a partial application of a function, an algebraic data object, and some other stuff
10:19:50 <kmc> and actually that's a lie because there are some statically-allocated closures... no need for "Nothing" to live in the heap when there's globally one "Nothing" value
10:20:08 <accel> hmm
10:20:15 <shepheb> uh... now it's telling me that ['r'] and ['r','o','l','l'] are overlapping.
10:20:21 <accel> so are unboxed values heap allocated too?
10:20:33 <kmc> accel, no
10:20:45 * shepheb suppresses the warning and carries on. 
10:20:50 <kmc> an unboxed value has its direct machine representation
10:21:03 <asdfhadfhq> I just realised I can do sequence [getLine, getLine]
10:21:04 <accel> suppose I have add (Vec3 a b c) (Vec3 x y z) = Vec3 (a+x) (b+y) (c+z); then I do add add add (Vec3 1 2 3) (Vec3 4 5 6) ... seems like there's lots of heap allocated objects that can, at compile time be realized "I don't need this after this calculation"
10:21:07 <asdfhadfhq> you must be kidding me
10:21:12 <kmc> an Int# is just a machine int; a Double# is a machine double, and a State# T is nothing at all (0-bit object)
10:22:00 <periodic> asdfhadfhq: I have learned to love sequence.
10:22:01 <c_wraith> hmm.  I just blew up haskell-mode
10:22:23 <asdfhadfhq> periodic: that that line of code is possible is just amazing stuff
10:22:33 <c_wraith> apparently, a 20k string literal causes the indentation mode to fail.
10:22:56 <c_wraith> every time I hit enter or tab, I just get error messages!
10:22:58 <Jafet> Or replicateM 2 getLine
10:22:59 <asdfhadfhq> also
10:23:02 <asdfhadfhq> this gives me an idea
10:23:08 <periodic> asdfhadfhq: It's great for doing stuff like (sequence . map print)
10:23:10 <asdfhadfhq> if we sequence one of those triangles
10:23:27 <asdfhadfhq> where you are supposed to find shortest path (the one with lowest sum)
10:23:37 <asdfhadfhq> you can just sum the sub-lists
10:23:42 <asdfhadfhq> or am I wrong?
10:24:09 <kmc> accel, in that particular case i'd count on inlining to save the day
10:24:20 <kmc> there was at one point a "vectored returns" optimization
10:24:46 <kmc> where you have say "case e of Nothing -> ...; Just x -> ..."
10:25:01 <kmc> rather than pushing a single continuation which inspects a heap object, it would push two continuations, one for each branch
10:25:17 <kmc> and then the code for evaluating "e" would jump to one of those directly, with the Just's field in a machine register
10:25:27 <kmc> i think this optimization was removed as it was determined to no longer be a benefit
10:25:57 <asdfhadfhq> my feets smell
10:26:11 <Jafet> I would find it weird if the vector addition didn't get inlined
10:26:29 <asdfhadfhq> Jafet: well, one has to consider cache optimizations
10:26:36 <earthy> kmc: otoh, especially for Maybe, the tag is encoded in the LSB of the pointer to the value
10:26:47 <Jafet> Though it's often the bigger optimizations that count, and LLVM supposedly does well at those
10:26:54 <earthy> (but that holds true for all datatypes that have less than 4 constructors)
10:26:58 <kmc> earthy, yeah, but that's still a pointer into the heap
10:27:05 <asdfhadfhq> >mfw when arch still doesn't have ghc 7
10:27:25 <earthy> yeah, but you don't need to walk the pointer to the constructor and *then* the pointer to the value anymore
10:27:36 <kmc> accel, if you need to return multiple values and you need assurance that GHC won't allocate a heap object to contain them, you can use an unboxed tuple
10:28:09 <kmc> if i have "f n = (# n+1, n+2 #)" then f simply loads n+1 and n+2 into two STG registers (which are usually hardware registers)
10:28:30 <kmc> which is why there's so many restrictions on unboxed tuples -- they are not persistent objects
10:29:04 <Jafet> I usually just dump core to get the assurance, which is usually there
10:29:33 <accel> kmc: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html ?
10:29:38 <Jafet> Anyway, manually specifying unboxed tuples feels to me like you just need a bigger optimizer
10:29:53 <earthy> jafet: yes and no
10:30:29 <earthy> the optimizer need not have access to as much of the program's scope that you as a programmer have
10:30:41 <earthy> especially in the case of libraries
10:31:25 <kmc> the optimizer is also conservative
10:31:34 <kmc> it will refrain from things that might be a big net loss
10:31:49 <kmc> the programmer can make a judgement call (or an empirical observation!) that it's actually a net win
10:31:58 <kmc> accel, yep
10:32:30 <kmc> anyway unboxed values / tuples are the sort of thing you'd use in your critical inner loop after profiling and other optimizations
10:32:31 <Jafet> Well, what I'm saying is, look at the core first, it's probably already there
10:32:35 <kmc> yeah
10:32:42 <accel> kmc: cool; thanks for sharing all this
10:32:43 * earthy nods
10:32:50 <earthy> core reading good
10:33:01 <kmc> if you're doing stuff with Ints locally, then it's likely that GHC will infer strictness, and if so, it will probably unbox them
10:33:16 <earthy> or words even
10:33:33 <kmc> and if you're doing stuff non-locally, but you define your data types with strict fields, then likewise
10:33:37 <kmc> see also -funbox-strict-fields
10:33:39 <kmc> one place this can go wrong is polymorphism
10:34:10 <kmc> if your function is generic for all Num values, then there's no way for it to unbox, unless it decides to generate a separate specialized version for Int
10:34:18 <accel> kmc: hang on
10:34:20 <accel> this is over my head
10:34:20 <kmc> there are directives to indicate that it should do so
10:34:23 <kmc> fair enough accel
10:34:33 <accel> let me ask you this later, after I've read up on dons blog post + ghc wiki + the unboxed stuff and played with it
10:34:36 <kmc> sure
10:34:38 <kmc> have fun :)
10:34:45 <accel> thanks
10:34:57 <periodic> kmc: I'm supposed to be working, not reading up on unboxing...
10:35:34 <periodic> strictness annotations and forcing evaluation is something I need to learn more about.
10:35:46 <kmc> periodic, me too :)
10:35:53 <periodic> Understanding when to force an evaluation, how to do so, and how deeply to do so.
10:35:53 <kmc> supposed to be working
10:36:11 <kmc> i think "how deeply" should almost always be "whnf only"
10:36:35 <kmc> it's useful sometimes to do a full traversal, but it's expensive; much preferable to design your code so it does the whnf-forcing at each step
10:36:39 <kmc> as it does whatever other work
10:36:50 <periodic> Yeah, I think I remember wanting to walk the spine of a list once, but I forget the application..
10:36:59 <kmc> a cute way to do that is "map id"
10:37:16 <periodic> kmc: heh, that's a good one.
10:37:47 * auger thwarts kmc's cute way with a tactical rewrite rule
10:37:59 <kmc> "fix (1:)" takes a tiny constant amount of heap but "map id $ fix (1:)" will rapidly use up all the memory on your system
10:38:01 <kmc> hehe auger
10:38:53 <periodic>  It's sort of unfortunate that something like "map id" which does nothing conceptually can change the performance of a program drastically.
10:38:57 <kmc> yes
10:39:29 <asdfhadfhq> with great power comes great customizability
10:39:38 <periodic> Probably my biggest constraint about haskell is when we have to go in and start specifying how things are executed.
10:39:45 <kmc> and i think it's fundamentally impossible to make a useful language which lacks such unfortunate aspects
10:39:51 <kmc> though of course we can aspire to do better
10:39:56 <asdfhadfhq> kmc: never say never
10:40:11 <asdfhadfhq> kmc: look at python, they have some good stuff going on there
10:40:11 * kmc puts off saying "never" until his turing machine halts
10:40:16 <kmc> hahaha
10:40:18 <aristid> doesn't GHC try pretty hard to eliminate known instances of this problem?
10:41:06 <elliott> edwardk tell me about these fabled ``new lenses''
10:43:59 <ski> kmc : i think that multi-continuation idea (cf. Olin Shivers' "Multi-return function call" <http://www.ccs.neu.edu/home/shivers/papers/mrlc-jfp.pdf> 2004) could achive the same as manual CPS-transforming of monads
10:44:47 <ski> (kmc : do you have a link re "this optimization was removed as it was determined to no longer be a benefit" ?)
10:46:43 <kmc> ski, not atm, sorry
10:47:23 <accel> http://hpaste.org/43860/accel looks ugly; i want it to be less ugly; any idea how?
10:47:25 * hackagebot direct-sqlite 1.1 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-1.1 (DanKnapp)
10:47:33 <duckinator> hi
10:48:40 <periodic> accel: personally I'd push those do indentations out or put things on one line without do.
10:48:56 <periodic> and make the data not on one line.
10:49:03 <periodic> but I can't comment on the actual substance of the code. :P
10:50:11 <accel> periodic: can you paste an annotation?
10:50:24 <marcot> Do you have an explanation for that?  It seems to be a bug in cabal: http://paste.debian.net/107183/
10:50:37 <periodic> accel: http://hpaste.org/paste/43860/accel_annotation#p43861
10:50:56 <accel> periodic: I like the change to data Shape
10:51:00 <walt> I am trying to find a functional language, that is easily deployable as native code on windows and linux. I would like that to be haskell, but I would need to ship a runtime right? Or os there some kind of packaging utility that I have not found?
10:51:09 <walt> how do people ususally deploy haskell software?
10:51:09 <asdfhadfhq> duckinator: yo dawg
10:51:11 <asdfhadfhq> duckinator: it's me
10:51:19 <periodic> accel: yeah, I like the datas lined up like that.  Nice and pretty.
10:51:20 <asdfhadfhq> asdfhadfhg
10:51:45 <asdfhadfhq> walt: there is no real-world haskell software
10:51:46 <accel> periodic: the >> on Colored i nice too; making it single line
10:51:50 <periodic> accel: oh, might also move the List function above translated so it looks nicer.  I like function defs to go from shortest to longest.
10:51:56 <duckinator> asdfhadfhq: do I know you, or do you just like 3-line greetings? :P
10:52:03 <ski> accel : what happens on `draw (Colored c0 (List [Colored c1 (Cube d0),Cube d1]))' ?
10:52:18 <asdfhadfhq> duckinator: you probably know me as Mr.Awesome
10:52:21 <accel> ski: crap, I don't preserve color
10:52:26 <accel> ski: suggested change?
10:52:30 <duckinator> asdfhadfhq: oh, so you're a flying turtle?
10:52:45 <asdfhadfhq> duckinator: among other things, yes
10:53:06 <asdfhadfhq> duckinator: so I like just discovered how awesome sequence [getLine, getLine] is
10:53:07 <asdfhadfhq> try it
10:53:17 <ceii> wait: GHC generates fully statically linked executables by default
10:53:27 <ceii> you can ship those as-is
10:53:30 <duckinator> asdfhadfhq: why do i feel like that's not a good idea... *tries anyways*
10:53:40 <walt> ceii: thank you
10:53:41 <ski> accel : one solution is to keep the current color in an argument / `ReaderT (GL.Color3 Double)' monad transformer, and restore to that, after processing `Colored c s'
10:53:53 <asdfhadfhq> duckinator: then try it without the sequence
10:54:08 <asdfhadfhq> Egbert9e9: I like your taste of nicknames
10:54:13 <accel> ski: can you post annotation? I would like to learn this; but from example would be fastest
10:54:17 <ski> accel : but maybe GL already has some way to describe color environments (as it has with transformation matrices)
10:54:27 <accel> ski:  I like your idea; there's more state I want captured
10:54:30 <accel> things that GL does not necesairly cover
10:54:49 <duckinator> asdfhadfhq: gets two lines from STDIN? interesting
10:54:50 <Egbert9e9> o-o
10:54:52 <ski> accel : is there a way to ask GL about the current color ?
10:54:59 <accel> ski: there is, but I want to see the readerT solution
10:55:11 <accel> ski: you're proposing a ontrol pattern I don't know how to use
10:55:14 <accel> and I would like to learn it
10:55:14 <asdfhadfhq> duckinator: it is indeed interesting, but try it without the sequence
10:55:38 <duckinator> that error makes my brain hurt
10:55:56 <sm> walt: examples: http://hledger.org/DOWNLOAD.html
10:55:56 <adnap> man, i found out that the problem i'm having installing fieldtrip has been in existence for over a year and has to do with the hopengl guy not updating is code
10:56:08 <duckinator> or, nevermind
10:56:14 * duckinator failed at reading, apparently
10:56:21 <adnap> http://fieldtrip-haskell.1564939.n2.nabble.com/Vector2-error-td4092987.html
10:56:25 <sm> however it may be more work than you think to make portable binaries
10:56:57 <monochrom> portable binaries?! oxymoron?
10:57:22 <sm> true enough.. but commercial software vendors seem to do it to some extent
10:57:24 <adnap> what's to stop anyone from snagging the code and fixing it?
10:57:26 <copumpkin> .class files are portable
10:57:31 <copumpkin> mostly
10:57:36 <copumpkin> and they're a binary format
10:57:52 <asdfhadfhq> monochrom: I see what you did there
10:57:54 <adnap> i don't understand why conal said he is waiting on svenpanne to fix it
10:58:27 <monochrom> I forgot jvm bytecode
10:59:02 <monochrom> but the prospect of a machine code polyglot caught me
10:59:13 <duckinator> monochrom: or any VM bytecode, really...
10:59:15 <asdfhadfhq> monochrom: that's so deep man
10:59:32 <asdfhadfhq> duckinator: depending on the actual H-reading
10:59:45 <duckinator> ..?
10:59:49 <adnap> can only the original author of the code upload an update to hackage for a library?
10:59:54 <Zao> adnap: No.
11:00:09 <Zao> It's rude though.
11:00:12 <asdfhadfhq> iirc, the last time I saw something this cozzy was when I liked an alligator much so
11:00:12 <adnap> hm... so i could fix it!
11:00:40 <adnap> it's been like a year and a half since the guy last updated
11:00:51 <xplat> the problem with other people uploading updates is, if people do it too much, it'll stop working
11:00:52 <Zao> adnap: Tried contacting him?
11:01:22 <Saizan> which package is this?
11:01:25 <Zao> You could always fork?
11:01:25 <adnap> hopengl
11:01:36 <adnap> read this though: http://fieldtrip-haskell.1564939.n2.nabble.com/Fwd-ColorComponent-amp-VertexComponent-td4095498.html
11:01:38 <harlekin> adnap, if I recall correctly fieldtrip should be used along with reactive which isn't developed at the moment.
11:01:59 <adnap> harlekin: that's reactive-fieldtrip
11:02:00 <Zao> adnap: It's not like something like HOpenGL changes much over time.
11:02:18 <xplat> forking would be a great solution presuming cabal had (versioned) Provides:, but i don't think it does?
11:02:35 <adnap> it seems like a simple fix.  i don't understand why conal was asking the guy to do it.
11:02:51 <Zao> adnap: I believe that VertexComponent is restricted to proper GL types for a reason.
11:03:11 <adnap> you mean like GLFloat?
11:03:14 <adnap> instead of Float?
11:03:15 <Zao> As 'Float' might be rather unrelated to proper native ones.
11:04:13 <Zao> adnap: I don't know what the exact names of the types HOpenGL exposes are, but something along those lines.
11:04:25 <Zao> (it's been a good while since I did much with Haskell)
11:04:48 <adnap> i'm wondering if that's related to this: http://fieldtrip-haskell.1564939.n2.nabble.com/Vector2-error-td4092987.html
11:05:58 <adnap> in fieldtrip, there are instances for Vector3 in conal's linear algebra library (vector space, additive group, etc.)
11:06:20 <adnap> i guess i could just snag those if it can't be fixed
11:09:21 <accel> http://hpaste.org/43862/accel <-- is there a better way to do this?
11:10:03 <kmc> what do you want to improve?
11:10:09 <accel> perferably stick the color
11:10:12 <accel> in some type of moand or something
11:10:24 <accel> since if I have more state, (like shaders)
11:10:30 <accel> I don't want to manually keep track of all this
11:10:33 <accel> does my request make sense?
11:10:36 <kmc> yes
11:10:38 <adnap> man, if fieldtrip was working...
11:10:45 <kmc> you could use the Reader monad, it's true
11:10:48 <adnap> it has a bunch of stuff you want
11:10:53 <kmc> but i'm not convinced it's an improvement
11:11:00 <kmc> since you'd have to make it play nice with IO also
11:11:05 <accel> kmc: i'v elooked over: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader.html
11:11:10 <kmc> i'd just keep passing the state explicitly, but put it in a record
11:11:11 <accel> kmc: and I see no way how to use it
11:11:18 <adnap> why are you putting the translation in the constructor?
11:11:33 <accel> adnap: why not?
11:11:42 <kmc> data State = State { color :: GL.Color3 Double, shader :: GL.Shader, ... }
11:11:50 <kmc> then i'd do something like
11:11:54 <kmc> draw :: State -> Shape -> IO ()
11:12:04 <kmc> draw State{..} (Cube d) = ...
11:12:10 <kmc> using GHC's RecordWildCards extension
11:12:16 <accel> kmc: hmm; I see that working; thanks
11:12:18 <kmc> that will unpack variables locally named "color" and "shader" etc
11:12:28 <adnap> accel: what does a translation have to do with a shape?
11:12:39 <accel> adnap: i'm rendering a scene
11:12:41 <adnap> accel: why not a function that translates shapes?
11:12:42 <kmc> a shape is a cube or it's a translated shape or ...
11:12:49 <accel> adnap: maybe I should call it a scene rather than a shape
11:13:07 <accel> like a robot transformer is a shape
11:13:11 <adnap> accel: have you heard of scene graphs?
11:13:17 <accel> and it's basically a bunch of translated cubes
11:13:19 <accel> adnap: yes
11:13:25 <kmc> accel, also note that calling "GL.color" is already setting the color in global state
11:13:40 --- mode: ChanServ set +o monochrom
11:13:41 <kmc> OpenGL is full of global state and it might not make sense to duplicate it at the Haskell level
11:13:58 <accel> kmc: yes; this is adressing a problem ski brouht up earlier
11:14:11 <accel> of Color Red [ .... Blue0cube ... cube ]
11:14:14 <accel> the last cube should be Red, not blue
11:14:27 <accel> which GL doesn't take care of unless I start pushing/popping attribs
11:14:27 <adnap> i would try to separate the geometry from the colors and the transformations
11:15:26 <mux> I'm seeing strange out of memory failures with GHC 7.0.1 using criterion on a simple benchmark
11:15:52 <mux> anyone heard about this?
11:16:36 <argiopeweb> Having an ambiguity error with cabal install on vacuum-cairo: http://hpaste.org/43863/vacuumcairo_install_error
11:17:21 <dcoutts> argiopeweb: it needs adjusting for changes in the gtk package
11:17:33 <argiopeweb> mux: I'm assuming you're not actually running out of memory?
11:17:43 <dcoutts> alternatively, use a different gtk package version
11:17:48 <argiopeweb> dcoutts: Care to offer some pointers?
11:18:04 <mux> argiopeweb: no, otherwise it wouldn't be that strange ;-)
11:18:10 --- mode: monochrom set +q $a:Nibble
11:18:11 <dcoutts> argiopeweb: if you want to fix the code, it's just a matter of fixing the imports
11:18:12 <argiopeweb> Indeed, indeed.
11:18:17 --- mode: monochrom set -o monochrom
11:18:18 <mux> I've taken this to #ghc though, more appropriate
11:22:13 <argiopeweb> dcoutts: I'm guessing that involves a decompress/change/recompress of the vaccuum-cairo tar.gz downloaded by cabal?
11:22:33 <dcoutts> argiopeweb: right, or alternatively use a different version of the gtk package
11:23:47 <edwardk> elliott: ?
11:23:49 <luite> argiopeweb: you don't need to recompress if you just want to install it though. just cabal unpack vacuum-cairo, then change the files and run cabal install from the directory where you uncompressed it
11:24:01 <elliott> edwardk: blame copumpkin
11:24:10 <edwardk> elliott: they are just the store comonad transformer based version of the usual lenses.
11:24:44 <edwardk> they have nice properties for dealing with modify efficiently, and don't involve tossing around undefines like henning's version
11:25:03 <elliott> data-accessor has undefined? ew.
11:25:22 <jmcarthur> i love the "it's just <blah blah blah>" snippets that appear here every once in a while and confound visitors
11:25:48 <aristid> @quote ennobunctor
11:25:49 <lambdabot> No quotes match. It can only be attributed to human error.
11:25:50 <elliott> edwardk: What I came up with in ~3 seconds back when copumpkin complained about inefficient modify was "type Aspect t a = (a -> a) -> t -> (a, t)" where the fst is the original element and the snd is the structure with the modified element, but I'm sure what you've come up with is better :-P
11:25:55 <aristid> @quote ennobunktor
11:25:56 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
11:29:02 <edwardk> newtype LensT w a b = Lens { runLens :: a -> StoreT b w a }
11:29:26 <argiopeweb> luite: Ah, true.  Regardless, looks like I'm going to need to change my gtk version.  Graphics.UI.Gtk.Gdk.Events is complaining about not exporting Key even though it pretty clearly does work in GHCi
11:31:46 <aristid> edwardk: we need @uncomtl :)
11:31:47 <luite> argiopeweb: oh if you're going to actually change dependencies and stuff, you may need to increase the package version number in the .cabal file. I'm not sure about that though :)
11:32:41 <edwardk> data StoreT s w a = StoreT (w (s -> a)) s
11:33:16 <edwardk> aristid: when w = Identity, then you get Lens = a -> (s -> a, s)  — which is isomorphic to a -> s, a -> s -> a
11:33:51 <aristid> edwardk: oh, cool
11:34:06 <aristid> so Lens is a comonad?
11:34:17 <edwardk> aristid: nah, its a coalgebra of a comonad
11:34:30 <aristid> is this a comonad? Monoid w => Lens w
11:35:24 <edwardk> not sure. my intuition says no. the traced comonad has the arrow in the opposite position
11:36:23 <edwardk> @hpaste
11:36:23 <lambdabot> Haskell pastebin: http://hpaste.org/
11:36:42 <edwardk> http://hpaste.org/43864/more_lens_transformers
11:37:13 <aristid> is this a comonad? Monoid w => Flip Lens w
11:37:17 <argiopeweb> Hehe, managed to fix it with an additional qualified name instead of other alternatives. Lucky break on my part that it only used it 5 times...
11:37:51 <edwardk> by opposite position i mean w (m -> a) instead of m -> w a
11:38:18 <edwardk> actually i stand corrected, if your function is defined in some kind of torsor of the monoid then yes
11:38:58 <edwardk> you have something for StoreT m w a where m is a monoid   — thats actually implemented in my streams package
11:40:41 <edwardk> but as for lens, both a and b occur in both positive and negative position, so i'd hazard no (co)monad for you
11:45:47 <Egbert9e9> problem 7 in ninety nine haskell problems, what's wrong with this definition? data P07 = P07List [P07] | P07Elem Int
11:46:57 <c_wraith> Not knowing the problem, my first guess would be: Maybe you wanted a recursive type, and that isn't one?
11:47:17 <kmc> it's recursive
11:47:19 <c_wraith> Oh, nevermind, it is
11:47:22 <c_wraith> sorry
11:47:44 <kmc> Egbert9e9, why do you assert that something is wrong with it?
11:47:59 <Egbert9e9> oh
11:48:06 <Egbert9e9> then my function is the faulty thing
11:48:19 <Egbert9e9> i'm trying to flatten a weird list
11:49:12 <Egbert9e9> nested list
11:51:42 <kmc> well that's a fine data type for an arbitrarily-nested list
11:51:45 <kmc> aka a rose tree
11:51:57 <kmc> aka Data.Tree.Tree
11:53:42 <5EXAB6XK6> hey guys
11:53:50 <Egbert9e9> oh, so it's an n-leaf tree O_O
11:53:57 <5EXAB6XK6> is haskell going to gsoc 2011 this year?
11:54:01 * ski annotated "accel" with "using an environment" at <http://hpaste.org/paste/43860/using_an_environment#p43865>
11:54:01 <Egbert9e9> err, n-brach?
11:54:05 <edwardk> 5EXAB6XK6: yes
11:54:26 <5EXAB6XK6> edwardk: ok how many ppl usually apllying?
11:54:46 <ski> @tell accel * ski annotated "accel" with "using an environment" at <http://hpaste.org/paste/43860/using_an_environment#p43865>
11:54:46 <lambdabot> Consider it noted.
11:54:47 <edwardk> 5EXAB6XK6: we usually get about 15-20 students applying and get about 5-9 slots
11:55:24 <5EXAB6XK6> edwardk: ok sound good, how much experience do I need with haskell? I only done a game for the school
11:55:29 <5EXAB6XK6> sounds*
11:55:47 <kmc> Egbert9e9, yeah, arbitrarily-deeply-nested lists are equivalent to arbitrary-fanout trees
11:56:07 <edwardk> we try to focus on folks who have a fair bit of experience, mostly because they are the ones most likely to finish, but a good project proposal can get you a long way. ;)
11:56:13 <kmc> a list with k elements is a k-child node and a non-list is a leaf
11:56:14 * edwardk <- org admin
11:56:21 <Egbert9e9> kmc, i'm a total ignorant with all concerning to data structures
11:57:17 <Egbert9e9> can random folks apply for gsoc?
11:57:55 <edwardk> ultimately what we tend to do is take a bunch of seasoned haskell folks who want to be mentors and let them vote on which ones we do, so there is no one party that has full authority who says yay or nay on any given application, so the key is finding something that appeals to the community, benefits the community, and which the community as a whole thinks you can carry to completion
11:58:18 <edwardk> Egbert9e9: you need to be a student with some sort of university affiliation, but beyond that there aren't a ton of restrictions
11:58:57 <Egbert9e9> ah. i'm not up to it anyways, just curious
11:59:40 <Egbert9e9> i procrastinate studying biology by trying to learn haskell
11:59:40 <edwardk> Egbert9e9: np. i was planning on hacking up the wiki to talk about this year when i get back from a trip next week
12:00:10 <edwardk> i've got the org application ready to go, so beyond that its mostly waiting for the 28th for me at this point.
12:00:46 <Egbert9e9> do they have any bioinformatics stuff?
12:01:21 <sm> mubarak speech imminent at http://www.youtube.com/aljazeeraenglish
12:02:07 <edwardk> Egbert9e9: as in have we had any bioinformatics focused gsoc projects? not to my knowledge. there are some random bioinformatic hackage packages though
12:02:40 <Egbert9e9> ah
12:03:09 <edwardk> I used to do a lot of bioinformatics work, and would be willing to mentor a good gsoc bioinformatics package proposal, but the trick is trying to find a way that it isn't a pie-in-the-sky research project
12:04:38 <Egbert9e9> edwardk, so a lot of proposals are vapourware?
12:04:51 <elliott> Is there a variant of hGetLine that appends a newline iff the line ends with a newline? The last line in a file, for instance, might not end with an \n.
12:04:59 <elliott> Right now hGetLine cannot distinguish the files "foo" and "foo\n".
12:05:05 <elliott> (files containing only, that is)
12:05:08 <edwardk> Egbert9e9: its party of the filtering process. we tend to favor proposals that are improvements for existing projects, or where the person has a demonstrable expertise in some area
12:05:26 <Egbert9e9> ah
12:05:30 <edwardk> er part
12:06:04 <xplat> okay, wtf
12:06:17 <xplat> how can firefox have saved a cookie without a name?
12:06:30 <5EXAB6XK6> easy hax
12:06:48 <xplat> is that allowed in the cookie spec?
12:07:38 <Egbert9e9> edwardk, so just random cloning of existing tools into haskell won't do
12:07:56 <Egbert9e9> waste of effort, right?
12:07:59 <xplat> i've never seen this before, i have no idea what it means, and it's crashing my session editor
12:08:44 <edwardk> Egbert9e9: depends, if its something the community as a whole can leverage that may work out nicely, but if its a domain specific tool its a harder sell
12:09:03 <Kamx> Should I use System.getArgs or System.Environment.getArgs ?
12:09:06 <Egbert9e9> interesting
12:09:33 <kmc> Kamx, they are the same
12:09:43 <kmc> System re-exports stuff from other System.* modules
12:09:53 <Kamx> kmc: Is one of them deprecated or preferred?
12:10:03 <Kamx> kmc: So System.Environment.getArgs is the "original"?
12:10:12 <edwardk> kamx: the System.getArgs is the old haskell 98 flat namespace
12:10:24 <edwardk> so i'd use System.Environment.getArgs
12:10:24 <kmc> Kamx, yes, but System.getArgs is the one specified by the language standard
12:10:37 <kmc> i find it convenient to "import System" and get a bunch of stuff, but maybe that's bad practice
12:10:38 <xplat> it's not so much deprecated as reduced to a convenience package
12:11:11 <Kamx> I think i'll go for System.Environment.getArgs
12:11:33 <edwardk> the stuff in System changes slower than the stuff out in System.Foo, often detrimentally, because it keeps bad habits longer, since its harder to change
12:11:51 <edwardk> no difference in this case
12:12:26 <elliott> Maybe I'll just write my own hGetLine but I have a feeling it'd be rather slow.
12:12:37 <elliott> I don't see any way to do it other than character-by-character since you can't put stuff back into GHC's IO buffer.
12:13:19 <xplat> speaking of hard to change and detrimental, i really wish Show/Read supported Data.Text :(
12:15:21 <edwardk> elliott: start with http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/src/GHC-IO.html#hGetLine then adapt the hGetLineBufferedLoop
12:15:56 <elliott> edwardk: Looks very portable :-P ... but it looks like it just uses hGetChar?
12:16:03 <elliott> Or does hGetChar not buffer?
12:16:09 <xplat> when using haskell as a postgres procedural language, which i'm working on making possible, the obvious thing to do is to use show/read for the textual representation of a datatype which is required by postgresql
12:16:09 <elliott> I guess it doesn't unless you're in that block buffering mode.
12:16:13 <elliott> :-/
12:16:41 <KitB> Is there a module that will provide me with a map from which I can extract the maximum *value* rather than maximum key?
12:16:46 <edwardk> if you are in block or line buffered mode it slurps in larger amounts
12:16:52 <edwardk> which is exactly as it should be
12:17:04 <edwardk> otherwise its not safe to read ahead
12:17:14 <xplat> but that means things are liable to get pushed through a 'linked list of characters' step
12:17:37 <NemesisD> anyone here ever use cmdargs?
12:17:59 <edwardk> NemesisD: yeah
12:18:00 <elliott> edwardk: Right. But stdout starts in character-buffered mode; doesn't hGetLine buffer in that instance?
12:19:34 <megajosh2> Hey, can anybody tell me why there's a syntax error here? http://hpaste.org/43866/cant_figure_out_the_syntax_er
12:19:35 <5EXAB6XK6> edwardk: haskell is opensource right?
12:20:14 <NemesisD> edwardk: could you take a look at this (it isn't complete but its the gist of the issue) http://hpaste.org/43867/cmdargs
12:20:14 <edwardk> stdout line buffers to a terminal, and buffers to a file by default iirc, stderr is unbuffered
12:20:30 <edwardk> 5EXAB6XK6: yes, its available under a bsd-like license
12:20:52 <NemesisD> edwardk: everything works okay but its taking the field name as a flag, even though i specify it as argPos, id like the command to be like: checkpt add THENAME
12:21:14 <xplat> 5EXAB6XK6: most well-known haskell implementations are, and so are most of the usual implementations of standard libraries, but haskell is defined by a standard rather than an implementation so it need not be
12:21:30 <edwardk> NemesisD: hrmm. not sure i ever used the argpos stuff
12:21:45 <edwardk> xplat: good point
12:22:36 <edwardk> 5EXAB6XK6: ghc is the mainstream haskell implementation, its BSD-like licensed, others are GPL'd or what have you. I don't currently know any closed source Haskell implementations except for the one used by Bluespec which has a distant ancestor in hbc.
12:22:53 <Cale> megajosh2: Where does the close paren on line 67 open?
12:22:56 <edwardk> but in their case its hardly Haskell any more
12:23:11 <megajosh2> Cale: ...oh wow
12:23:13 <megajosh2> I better check that
12:23:36 <5EXAB6XK6> edwardk: xplat: ok thanx for the info
12:23:38 <megajosh2> Vim doesn't give me a match
12:23:44 <megajosh2> Okay the error is gone
12:23:47 <megajosh2> Cale: Thanks
12:23:51 <Cale> no problem
12:30:42 <Egbert9e9> oh, now realized what was my error
12:31:26 <Egbert9e9> p07 (P07Elem x) = x; p07 (P07List (x:xs)) = [(p07 x)] ++ [(p07 xs)]
12:31:33 <Egbert9e9> supposed to be 
12:31:44 <Egbert9e9> p07 (P07Elem x) = [x]; p07 (P07List (x:xs)) = (p07 x) ++ (p07 xs)
12:32:08 <Egbert9e9> wait, doesn't work -_-
12:33:10 <Egbert9e9> oh, i see
12:33:18 <byorgey> Egbert9e9: surely p07 can't be called on both x and xs, they have incompatible types
12:33:36 <Egbert9e9> ya, saw that right now
12:33:40 <Egbert9e9> thanks :)
12:33:52 <byorgey> perhaps you want map?
12:34:02 <Egbert9e9> hmm
12:34:10 <Egbert9e9> i really don't know
12:44:42 <shamster> I've been looking at lots of examples of using folds and they all make sense, but the minute I try to implement something using them I can't get started, let alone make progress. Is there some resource that's relevant to mastering use of folds?
12:45:04 <shamster> for example: how do I get started using a foldr/foldl to create my own concat function?
12:46:13 * copumpkin knows what byorgey is doing!
12:47:35 <mrd> shamster: one suggestion might be to write out on a sheet of paper an example of the operation you want to do.  for example, summing a list of numbers [1,2,3,...,10] is 1 + (2 + (3 + ... (10 + 0) ... ))
12:48:39 <mrd> shamster: the three facts you can pull out of that are: you are using the binary operation (+), the base case is 0, and it is right-associative
12:49:07 <mrd> (of course in this case it could be left associative too)
12:49:34 <shamster> mrd: so relating to my concat example, and let's just say 'let test_case = [[4,5,3],[4,3,1],[6,7,5]]'
12:49:49 <shamster> mrd: the result will be [4,5,3,4,3,1,6,7,5]
12:50:02 <shamster> mrd: and 'concat' :: [[a]] -> [a]'
12:50:12 <shamster> mrd: would the base case be [] ?
12:50:36 <mrd> shamster: try expanding it the way I did above and see what makes sense
12:51:06 <shamster> (4:5:3:[]) : (4:3:1:[]) : (6:7:5:[]) : []
12:51:17 <shamster> yesno?
12:51:23 <mrd> >  (4:5:3:[]) : (4:3:1:[]) : (6:7:5:[]) : []
12:51:24 <lambdabot>   [[4,5,3],[4,3,1],[6,7,5]]
12:51:31 <mrd> that just gives you the original list
12:51:53 <shamster> mrd: yes, and what I'd like is --
12:52:06 <shamster> > 4:5:3:4:3:1:6:7:5:[]
12:52:06 <lambdabot>   [4,5,3,4,3,1,6,7,5]
12:52:17 <mrd> so what change could you make that would give you that result?
12:52:57 <shamster> > 4:(5:(3:(4:(3:(1:(6:(7:(5:[]))))))))
12:52:58 <lambdabot>   [4,5,3,4,3,1,6,7,5]
12:53:07 <shamster> looks like a right fold in that sense
12:53:12 <Egbert9e9> hurrah! works
12:53:14 <shamster> base case is []
12:53:19 <Egbert9e9> p07 is finished
12:53:32 <mrd> shamster: however you are dealing with [4,5,3] not 4 alone
12:53:35 <mrd> etc
12:53:41 <shamster> mrd: ah... yes...
12:54:03 <mrd> shamster: but you have revealed that "foldr (:) []" on a list will reform the same list, which is a nice little tidbit
12:54:17 <Egbert9e9> what's wrong with "P07Elem a" in: data P07 = P07List [P07] | P07Elem a deriving (Show)
12:54:24 <shamster> mrd: let's see...
12:54:38 <Egbert9e9> if i s/a/Int/ , it works fine
12:54:40 <homie> is list comprehension breadth first in haskell ?
12:55:03 <shamster> > (4:5:3:[]) : ((4:3:1:[]):((6:7:5:[]):[]))
12:55:04 <lambdabot>   [[4,5,3],[4,3,1],[6,7,5]]
12:55:13 <aristid> > let (|:) = flip (:) in [] |: 4 |: 3 |: 2 |: 1
12:55:15 <lambdabot>   [1,2,3,4]
12:55:24 <Egbert9e9> it says the type variable is not in scope
12:55:30 <c_wraith> Egbert9e9: the a is an unbound variable.  To do what you really want, you'd need to use:  data P07 a = P07List [P07] | P07Elem a
12:55:43 <shamster> mrd: base case is still the []...
12:55:43 <Egbert9e9> ah, weird.
12:55:49 <mrd> > foldr (:) []  [[4,5,3],[4,3,1],[6,7,5]]
12:55:50 <lambdabot>   [[4,5,3],[4,3,1],[6,7,5]]
12:56:25 <mrd> shamster: so we know that using foldr (:) [] basically acts as an identity function on lists, so that isn't concat
12:56:25 <xplat> :t join (:)
12:56:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
12:56:27 <lambdabot>       Expected type: a -> a -> a1
12:56:27 <lambdabot>       Inferred type: a -> [a] -> [a]
12:56:37 <c_wraith> Egbert9e9: That tells it where the a comes from...  In that case, the a is part of the type.  So P07 isn't a full type by itself.  Instead, "P07 Int" is an example of a P07-based type
12:56:42 <Egbert9e9> c_wraith, so w/e name that comes after the new type and before the '=' sign will be a type variable thingie?
12:56:47 <shamster> mrd: right... there's go to be some recursion in there to get into the nested lists
12:56:55 <FunctorSalad> what does the grouping in the "stacktrace" produced by +RTS -xc mean? e.g. <foo,bar><baz,batz>
12:57:04 <Egbert9e9> i seee
12:57:05 <shamster> mrd: and then bring those out to cons them with the others
12:57:10 <mrd> shamster: not quite. fold is all we need.  let's look at this from a different angle.
12:57:19 <xplat> :t (:) >>= (:)
12:57:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = [[a] -> [a]]
12:57:20 <lambdabot>       Expected type: a
12:57:21 <lambdabot>       Inferred type: [[a] -> [a]]
12:57:31 <Egbert9e9> c_wraith, wooo, compiles!
12:57:52 <accel> Doesn't the ability to stick an IORef inside of a record screw around with the notion of purity?
12:57:52 <lambdabot> accel: You have 1 new message. '/msg lambdabot @messages' to read it.
12:57:58 <copumpkin> :t (:) >=> (:)
12:57:59 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
12:57:59 <lambdabot>       Expected type: [a]
12:57:59 <lambdabot>       Inferred type: a
12:58:01 <c_wraith> Egbert9e9: Yes, type variables are put before the equals sign.  They're used to create polymorphic types.
12:58:04 <mrd> shamster: suppose I give you two lists [1,2,5] and [6,2,7].  using a haskell function, how do I concatenate two lists?
12:58:41 <xplat> accel: the IORef is only the name of the reference cell, you can't dereference it except in IO
12:58:41 <Egbert9e9> c_wraith, shape shifters! i'll convince them into turning into bread and then eat them whole! :-D
12:58:43 <shamster> mrd: normally I'd :
12:58:47 <periodic> accel: but you can't actually do any IO until you're in the IO monad, right?  So you can pass around IO values just like any other type.
12:58:50 <shamster> > concat [1,2,5] [6,2,7]
12:58:51 <lambdabot>   Couldn't match expected type `[t1] -> t'
12:58:51 <lambdabot>         against inferred type `[a]'
12:58:58 <accel> ski: received your message; man that's complicated, but reading up on it now
12:58:59 <shamster> er...
12:59:10 <shamster> mrd: damn, I'm stumped :)
12:59:18 <geheimdienst_> :t concat
12:59:19 <lambdabot> forall a. [[a]] -> [a]
12:59:21 <ski> accel : it contains several variants
12:59:36 <xplat> :t join ((:) . (:))
12:59:37 <lambdabot>     Occurs check: cannot construct the infinite type:
12:59:37 <lambdabot>       a = [[a]] -> [[a]]
12:59:37 <lambdabot>     Probable cause: `:' is applied to too few arguments
12:59:38 <mrd> shamster: do you know how to append lists?
12:59:45 <ski> accel : and no, an `IORef a' is a pure value, like a list/array index
12:59:45 <Kaidelong> copumpkin: I dunno if "([a] -> [a])" would really be a monad on a, would it?
13:00:04 * hackagebot Unixutils 1.36 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.36 (JeremyShaw)
13:00:12 <Kaidelong> and (r -> [a]) has [a] as a parameter and not a
13:00:22 <shamster> > [2,5,1] ++ [4,3,1]
13:00:24 <lambdabot>   [2,5,1,4,3,1]
13:00:29 <mrd> alright :)
13:00:32 <shamster> mrd: there is it... ++ :)
13:00:48 <mrd> so can you append three lists? :)
13:00:53 <shamster> mrd: sure
13:01:04 <periodic> > foldr (++) [] [[1], [2..4], [5..9]]
13:01:05 <shamster> mrd: so foldr (++) [] myList?
13:01:06 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:01:09 <Kaidelong> > msum [[2,5,1],[4,3,1],[2,3,5]]
13:01:09 <lambdabot>   [2,5,1,4,3,1,2,3,5]
13:01:21 <mrd> seems you got it
13:01:28 <Kaidelong> @ty msum
13:01:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
13:01:32 <Kaidelong> @ty mconcat
13:01:33 <lambdabot> forall a. (Monoid a) => [a] -> a
13:01:50 <homie> where is forall defined ?
13:01:59 <periodic> homie: everywhere!
13:02:00 <Kaidelong> homie: forall is a keyword
13:02:04 <xplat> :t fmap (.) (:) (:)
13:02:05 <lambdabot> forall (f :: * -> *) a. (Functor f) => f [a -> [a] -> [a]] -> f [a -> [a] -> [a]]
13:02:09 <homie> :info forall does not tell anything here
13:02:09 <shamster> mrd: far out! :) Let's see if I can figure another one out. It still feels like magic
13:02:14 <shamster> mrd: and thanks!
13:02:15 <periodic> forall a let forall a = forall a
13:02:20 <Kaidelong> homie: although it may not be a standard Haskell 98 keyword
13:02:24 <homie> ah
13:02:27 <xplat> :t fmap (Prelude..) (:) (:)
13:02:27 <Kaidelong> but it is a keyword
13:02:27 <lambdabot> forall a a1. (a -> [a1 -> [a1] -> [a1]]) -> a -> [a1 -> [a1] -> [a1]]
13:02:51 <Kaidelong> homie: you can think of forall as a sort of type lambda, but that's not entirely right
13:03:01 <homie> ok
13:03:02 <Kaidelong> @ty runST
13:03:03 <lambdabot> forall a. (forall s. ST s a) -> a
13:03:17 <xplat> :t fmap (Prelude..)
13:03:18 <lambdabot> forall b c a (f :: * -> *). (Functor f) => f (b -> c) -> f ((a -> b) -> a -> c)
13:03:19 <FunctorSalad> is there any point in 'evaluate' returning a value except for convenience? it evaluates the original "reference" too, or not?
13:04:04 <xplat> :t (:) (.:) (:)
13:04:05 <lambdabot>     Couldn't match expected type `[(a -> b) -> f (g a) -> f (g b)]'
13:04:05 <lambdabot>            against inferred type `a1 -> [a1] -> [a1]'
13:04:05 <lambdabot>     In the second argument of `(:)', namely `(:)'
13:04:22 <xplat> :t (:) .: (:) -- argh
13:04:23 <lambdabot> forall a. a -> [a] -> [[a]] -> [[a]]
13:04:35 <obcode> Hi all! Anyone who has haskellmode-20090430.tar.bz2 lying arround and can send it to me. I need it, but projects.haskell.org is still not back with everything :-(
13:04:48 <FunctorSalad> (the closure pointed to by it, not the reference itself0
13:04:51 <FunctorSalad> )
13:06:17 <Kaidelong> FunctorSalad: If I am understanding corrently, you need to bind the result from the IO action to force the evaluation
13:06:30 <Kaidelong> correctly
13:07:02 <FunctorSalad> Kaidelong: yes, but assuming you do, is there any difference between going on to use y or y' after "y' <- evaluate y"?
13:07:25 <FunctorSalad> as I understand it, the closure pointed to by y is mutated too
13:07:34 <Kaidelong> FunctorSalad: I doubt it
13:07:35 <homie> how can i define the derivative ?
13:07:37 <FunctorSalad> (unobservably - I mean it's memoized)
13:08:18 <Kaidelong> homie: http://conal.net/blog/posts/beautiful-differentiation/
13:08:34 <Kaidelong> enjoy~
13:08:51 <accel> > "" == []
13:08:52 <lambdabot>   True
13:09:00 <ski> > [] :: String
13:09:01 <lambdabot>   ""
13:09:08 <accel> why oes "" == [] ? "" = empty list of Char, [] = empty list of 'a
13:09:13 <accel> why does "" == [] ? "" = empty list of Char, [] = empty list of 'a
13:09:17 <kulakowski> Anyone have a pointer to the current build or repository of haskell emacs mode?
13:09:30 <copumpkin> :t (==)
13:09:31 <lambdabot> forall a. (Eq a) => a -> a -> Bool
13:09:32 <ski> `[]' is empty list of values of any type `a', so e.g. `a' could be `Char'
13:09:33 <copumpkin> accel: that's why
13:09:34 <ski> @src String
13:09:35 <lambdabot> type String = [Char]
13:09:42 <copumpkin> == forces the  two parameters to be the same type
13:09:55 <ceii> accel: because [] is polymorphic, so it gets specialized to list of Char
13:09:58 <accel> copumpkin: ah, beacuse for the == to be valid, the "" and [] have to be of the same type
13:10:01 <shamster> mrd: how about implementing zip using a fold?
13:10:05 <accel> so the == specializes the [] to list of Char ?
13:10:09 <copumpkin> accel: yeah
13:10:09 <accel> copumpkin , ceii : thanks
13:10:12 <copumpkin> it forces them to unify
13:10:15 <FunctorSalad> > typeOf ([] :: forall a. [a]) -- hmm :)
13:10:16 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:10:16 <lambdabot>    `Data.Typeable.Typeable a...
13:10:40 <ski> accel : not the `(==)' operation itself, but the context it imposes
13:11:08 <ski> accel : did you see what i did in my paste ?
13:11:09 <accel> > [] :: [Int]
13:11:10 <lambdabot>   []
13:11:18 <accel> > "" == ( [] :: [Int] )
13:11:19 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:11:19 <lambdabot>         against inferred type...
13:11:24 <ski> > [] :: [Char]
13:11:25 <lambdabot>   ""
13:11:54 <Taslem> Hello.
13:12:04 <copumpkin> Hello indeed.
13:12:11 <Taslem> How do you set the order in which an infix function is defined?
13:12:16 <accel> ski: not yet; currently in "reading RWH" mode, when I context switch back into building MMORPG mode, understanding your paste will be the first thing I work on
13:12:25 <Taslem> Order of precedence / left to right, etc.
13:12:30 <periodic> Taslem: the first argument is the LHS, second is RHS...
13:12:30 <Philonous> > let x = [] in x == "abc" || x == [1 :: Int]
13:12:31 <lambdabot>   False
13:12:37 <accel> Bynbo7 , xplat : you guys should be proud of me; I just finished chapter 1 of RWH
13:12:45 <Taslem> No that.
13:13:00 <Kaidelong> homie: if you want to play with that, automatic differentiation is on hackage somewhere,and that'd be the better way to do it
13:13:00 <Taslem> I'm referring to this:   (a ... b ... c)
13:13:10 <xplat> accel: good job
13:13:11 <periodic> oh, what is it... infixr?
13:13:14 <Taslem> How can you tell it whether to do:  (a ... b) ... c 
13:13:15 <Taslem> or
13:13:20 <Taslem> a ... (b ... c)
13:13:28 * mrd has to run, sorry
13:13:40 <periodic> Taslem: it's a varition on an infix declaration...
13:13:42 <ski> Taslem : `a b c' means `(a b) c'
13:13:46 <periodic> I haven't done it for a whiel though.  Let me see.
13:13:49 <ceii> Taslem: declare either inflxl or infixr
13:13:49 <Cale> Taslem: infixl and infixr
13:13:58 <Taslem> How do one do that, exactly?
13:14:22 <periodic> So you'd have something like 'infixl 5 (+); infixl 6 (*)'
13:14:32 <Taslem> Ah, okay, thanks.
13:14:33 <periodic> which should make them both left-associative but * will bind tighter than +
13:14:39 <Kaidelong> periodic: that's backward I think
13:14:46 <Taslem> Does Haskell let you change the arithmetic operators?
13:14:48 <periodic> Kaidelong: oh, maybe.  I'm making it up as I go.
13:14:49 <mauke> no ( )
13:14:49 <Cale> actually, I'm not sure you want the parens there
13:14:59 <c_wraith> higher numbers bind more tightly.
13:15:04 <ceii> Taslem: only in a local scope
13:15:19 <ceii> > let a + b = 1 * b in 2 + 3
13:15:20 <lambdabot>   3
13:15:28 <xplat> > let cons² = liftA2 (.) (:) (:) in foldr cons² [] "test"
13:15:29 <lambdabot>   <no location info>: lexical error at character '\178'
13:15:30 <c_wraith> You can shadow the arithmetic operators.  You can't *change* the ones other code is using
13:15:30 <Taslem> What is the default for infix operators defined as:   a ... b = etc
13:15:35 <Kaidelong> > let 2 + 2 = 5 in 2 + 2
13:15:36 <xplat> awwww
13:15:36 <lambdabot>   5
13:15:40 <periodic> I was just using arithmatic operators because everyone would undersatnd the precedence of them.
13:15:42 <Cale> http://haskell.org/onlinereport/decls.html#sect4.4.2
13:15:58 <xplat> > let conses = liftA2 (.) (:) (:) in foldr conses [] "test"
13:15:59 <lambdabot>   "tteesstt"
13:16:23 <Kaidelong> > "test" >>= replicate 2
13:16:24 <lambdabot>   "tteesstt"
13:16:35 <periodic> Taslem: in GHCI do ":info (op)"
13:16:43 <Taslem> Thanks.
13:16:49 <accel> :t compare
13:16:50 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:16:55 <periodic> It will tell you the infix precedence
13:16:57 <accel> @src Ordering
13:16:57 <lambdabot> data Ordering = LT | EQ | GT
13:17:03 <Taslem> Actually.... it doesn't...
13:17:05 <Taslem> That's odd.
13:17:13 <periodic> Taslem: oh, maybe if it's not set it doesn't...
13:17:25 <Taslem> Any idea what the default is?
13:17:26 <Kaidelong> default is 9, I believe
13:17:30 <periodic> damn, I don't know the default.
13:17:42 <xplat> i wonder what is actually allowed in an identifier anyway ... probably should check the report
13:17:42 <accel> Are records implemented as tuples?
13:18:07 <periodic> the default is higher than infixl 7.  I just tested that. :D
13:18:16 <c_wraith> accel: records are implemented the same as any other product type.
13:18:34 <c_wraith> accel: The only thing different about records is that they give you some extra syntax and auto-define some functions
13:18:48 <Kaidelong> periodic: I am pretty sure the default is infixl 9
13:18:55 <Taslem> Thanks. Well, you learn something new every day.
13:19:00 <accel> c_wraith: are tuples product types ?
13:19:00 <Taslem> I think it is infixl 9.
13:19:01 <ski> accel : records are a layer of syntactic sugar on top of algebraic data types
13:19:03 <ceii> default is infixl 9
13:19:08 <c_wraith> accel: yes, tuples are product types
13:19:15 <periodic> Kaidelong: thanks.  Looks like you're right.
13:19:31 <accel> ski, c_wraith : algebraic data types = sum + product right? where product = like a C struct, and sum = "|" one of these options ?
13:19:40 <Cale> http://haskell.org/onlinereport/decls.html#sect4.4.2 -- this section of the Haskell report I linked to earlier says so :)
13:19:48 <c_wraith> accel: correct
13:19:57 <Kaidelong> Cale: but that would require reading and we can't do that
13:20:02 <accel> c_wraith: cool; thanks
13:20:11 <ceii> accel: sum, product and recursion
13:20:17 <EvanR-work> sum type is like union + discriminator field
13:20:28 <Kaidelong> what is non-associativity?
13:20:34 <Kaidelong> oh
13:20:35 <Kaidelong> easy
13:20:40 <Kaidelong> a -> a -> b
13:20:41 <periodic> Cale: way to bring documentation into it.  You just killed the debate!
13:20:43 <Kaidelong> is not associative
13:21:35 <accel> if/then/else <-- are these functions, or syntactical constructs? (i'm going with the latter, since I can't do ":info if")
13:21:48 <ceii> they're syntax
13:22:42 <Kaidelong> unnecessary syntax
13:22:49 <accel> Kaidelong: how so?
13:22:58 <c_wraith> Yeah, they're syntax, but most of us would prefer they be removed from the language entirely :)
13:23:01 <Kaidelong> accel: pattern matching is enough to define it
13:23:05 <accel> aren't operator precedence levels between 1 and 9? then, why do we have:
13:23:09 <accel> > :info $
13:23:10 <lambdabot>   <no location info>: parse error on input `:'
13:23:15 <Taslem> Just curious... How exactly can a recursive type be a member of the Ord typeclass?
13:23:15 <accel> :info ($)
13:23:19 <accel> > :info ($)
13:23:20 <lambdabot>   <no location info>: parse error on input `:'
13:23:23 <ceii> because they're between 0 and 9 :p
13:23:23 <c_wraith> accel: 0-9
13:23:27 <accel> ah
13:23:31 <accel> Kaidelong: got it; thanks
13:24:10 <ceii> Taslem: look at the instance for lists
13:24:14 <Kaidelong> actually defining if would make a nice exercise to introduce pattern matching
13:24:15 <xplat> @info ($)
13:24:16 <lambdabot> ($)
13:24:18 <c_wraith> There are also some "other" precedence levels.  like function application (binds more tightly than 9), record update syntax binds more tightly than function application, etc
13:24:39 <periodic> oh, record syntax...
13:24:49 <ceii> the precedence of record update always shocks me
13:25:00 * accel just finished chapter 2 of RWH. Where is my gold star?
13:25:09 <ceii> *
13:25:15 <ceii> is this one okay?
13:25:19 <accel> it's light green
13:25:21 <periodic> it's white to me...
13:25:22 <Kaidelong> > let (?) x = {case x of True -> const; False -> flip const} in True ? 5 $ 6
13:25:23 <lambdabot>   <no location info>: parse error on input `{'
13:25:25 <ceii> :(
13:25:31 <Kaidelong> > let (?) x = case x of {True -> const; False -> flip const} in True ? 5 $ 6
13:25:32 <lambdabot>   5
13:25:57 <ceii> nice
13:26:22 <periodic> Gold star for Kaidelong!
13:26:33 <accel> in Haskell, "type A = B" is basically C's "typedef A B" ?
13:26:37 <aristid> :t flip fmap
13:26:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
13:26:50 <aristid> @hoogle f a -> (a -> b) -> f b
13:26:50 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:26:50 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:26:50 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:26:54 <Kaidelong> :t (<**>)
13:26:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
13:27:01 <xplat> 07★00
13:27:02 <c_wraith> accel: yes.  It creates a type alias...  Another way of specifying the same type.
13:27:15 <aristid> xplat: a yellow star!
13:27:15 <accel> xplat: nice; thanks; how did you inject color into my irssi client?
13:27:16 <c_wraith> wow, xplat.  colored and unicoded.  impressive
13:27:42 <aristid> Kaidelong: unnecessary f (...) in the second parameter :/
13:27:50 --- mode: ChanServ set +o monochrom
13:27:54 --- mode: monochrom set +c
13:27:55 <Kaidelong> aristid: Yeah, that's not what you want
13:28:00 <monochrom> no more colours!
13:28:05 --- mode: monochrom set -c
13:28:08 --- mode: monochrom set -o monochrom
13:28:12 <aristid> i have: (</> ".aws-keys") <$> getHomeDirectory
13:28:16 <monochrom> (end of "no more colours")
13:28:23 <Kaidelong> @ty (>>>)
13:28:24 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
13:28:30 <aristid> that's ugly. getHomeDirectory <$$> (</> ".aws-keys") would be nicer
13:28:42 <Kaidelong> > [1,2,3] >>> (^2)
13:28:43 <lambdabot>   Couldn't match expected type `cat a b' against inferred type `[a1]'
13:29:04 <Kaidelong> oh
13:29:14 <aristid> monochrom: monochrom does not use colors because he is monochrome.
13:29:14 <xplat> accel: used Ctrl+C 0 7 to turn yellow, Ctrl+C 0 0 to turn back.  i don't see the colour on my irssi input line, just a reverse C and the two numbers, looks kind of lik C07
13:29:20 <Kaidelong> @ty (<<<)
13:29:21 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
13:29:23 <monochrom> hehehe
13:29:36 <accel> "type A1 = (Double, Double)\n type A2 = (Double, Double)" <-- A1/A2 can be interchanged, "data A1 = A1 Double Double\n data A2 = A2 Double Double" <-- A1 A2 can't be interchagned; is that correct?
13:29:50 <Kaidelong> wait I am thinking of a different >>> I think
13:29:51 <ceii> accel: yes
13:30:11 <Kaidelong> @instances Arrow
13:30:12 <lambdabot> (->), Kleisli m
13:30:28 <Kaidelong> @instances Category
13:30:29 <lambdabot> Couldn't find class `Category'. Try @instances-importing
13:30:36 <Kaidelong> @instances-importing Category
13:30:36 <lambdabot> Couldn't find class `Category'. Try @instances-importing
13:30:50 <Kaidelong> @instances-importing Arrow
13:30:50 <lambdabot> (->), Kleisli m
13:30:54 <Kaidelong> eeh
13:31:01 <Kaidelong> What's the class Category for in lambdabot then?
13:31:11 <accel> ceii: got it; thanks
13:31:34 <ceii> @instances Control.Category.,Category
13:31:34 <lambdabot> Couldn't find class `Control.Category.,Category'. Try @instances-importing
13:31:41 <ceii> @instances-importing Control.Category.,Category
13:31:42 <lambdabot> Couldn't find class `Control.Category.,Category'. Try @instances-importing
13:31:47 <blancNoir> @help
13:31:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:31:47 <ceii> hmm
13:31:57 <ceii> @instances-importing Control.Category.Category
13:31:58 <lambdabot> (->), Kleisli m
13:32:00 <aristid> ceii: remove the , in the moddle
13:32:05 <ceii> ah typo :)
13:32:18 <Kaidelong> weren't functors supposed to be categories?
13:32:18 <accel> so I'm on page 60 of RWH; hapter 3, talking about reporting errors ... and how does error interact with purity?
13:32:28 <aristid> Kaidelong: no, wrong kind
13:32:34 <accel> suppose I see a function [a] -> a ; ... the fact it can throw an exception is kinda weird
13:32:40 <ceii> accel: in pure code, errors just crash through eveything
13:32:46 <ceii> you can catch the in IO
13:32:52 <ceii> you can catch them in IO
13:33:23 <aristid> Kaidelong: i wonder if every category is a functor. hmm, probably not, functor laws may be too strong?
13:33:27 <accel> ceii: so if it was [a] -> Maybe a <-- taht I can accept; but throwing exceptions seems weird
13:33:33 <cadabra> Must all `data Foo = Foo` definitions be at the top level?
13:33:35 <Kaidelong> hmm well then what were functors then?
13:33:39 <Kaidelong> predicates on categories?
13:33:42 <aristid> accel: listToMaybe
13:33:45 <xplat> catching errors thrown from pure code is kind of a dirty business.  not as dirty as spoon, though.
13:34:02 <ski> accel : more like `typedef B A' .. (except not quite, due to C's idiosyncrazies of signatures/prototypes)
13:34:03 <ceii> accel: from the pure point of view, it's not weirder than a function [a] -> a that doesn't actually terminate
13:34:59 <ceii> but using errors in pure code is definitely bad practice
13:35:17 <xplat> yeah, it's not throwing the errors that can harm purity, it's catching them
13:35:44 * Kaidelong seems to recall that a functor just mapped the morphisms in the categories that were its objects to its own morphisms
13:36:17 <Kaidelong> or something like that
13:36:23 <Kaidelong> or was that an endofunctor?
13:36:28 <ski> a functor is a morphism between categories
13:36:41 <ceii> A functor maps a category into another, by transforming both the objects and morphisms
13:36:55 <ceii> an endofunctor is a functor from a category to itself
13:37:06 <Kaidelong> oh that makes sense
13:37:20 <Kaidelong> so functors are more like predicates on categories
13:37:42 <xplat> Kaidelong: well, the relationship between functors and categories in Haskell is a little screwed up compared to straight category theory because for Functors and Monads the type is the object type and for Categories and Arrows it's the arrow type
13:37:42 <ski> no, like morphisms
13:39:08 <Kaidelong> ski: "for all objects and morphisms in category A, there is an object or a morphism in category F(A) such that..."
13:39:23 <Kaidelong> was what I was thinking
13:39:32 <Kaidelong> although that'd boil down to the same thing as a morphism
13:39:55 <augustss> howdy
13:40:04 <xplat> Kaidelong: so if you have a Haskell type constructor Functor f => f then you have source category object types: a, b;
13:40:18 <accel> xplat: alright, I'm working on chapter 4 now, when I finish, I'm expecting a _blinking_ gold star
13:40:37 <ski> hello, augustss
13:40:45 <xplat> target category object types: f a, f b; source category arrow types: a -> b, target category arrow types: f a -> f b
13:41:24 <xplat> accel: i'm not sure irssi will let me create something quite that annoying
13:41:39 <Kaidelong> xplat: mm haskell functors would not be functors in category theory then?
13:41:56 <Kaidelong> since they only imply morphisms from morphisms to lifted morphisms
13:42:03 <Kaidelong> and not morphisms from objects to lifted objects
13:42:05 <ski> Kaidelong : Haskell functors are endofunctors on the category `Hask'
13:42:25 <ceii> Kaidelong: (Maybe, fmap) defines a functor in the categorical sense
13:42:34 <ceii> Maybe transforms the objects (the types)
13:42:41 <ceii> and fmap transforms the arrows
13:43:21 <xplat> Kaidelong: for a haskell (Category c) => c, you only have one category (not source/target), objects are: a, b; arrows are: a `c` b
13:43:56 <copumpkin> I have a Category instance in haskell that isn't a functor
13:43:58 <ski> (where `a' and `b' are in `*')
13:44:16 <xplat> so the direction things vary is different and you have to do some gymnastics to relate one to the other
13:44:39 <accel> > length [1..]
13:44:42 <xplat> they're both special cases of the mathematical definitions, but they are not directly analogous special cases
13:44:43 <lambdabot>   mueval-core: Time limit exceeded
13:44:55 <accel> why can't haskell output infinity?
13:45:07 <copumpkin> accel: are you serious?
13:45:28 <alej> you mean if it knows that the computation isn't going to complete, why can't it just output infinity? :D
13:45:48 <copumpkin> it can output infinity if you have lazy natural numbers in scope, and you write genericLength
13:45:52 <accel> yeah, beacause given that it's lazy and sees the definition of [1..]
13:46:05 <accel> oh wait; i guess this requires solveing the halting problem
13:46:10 <ski> indeed
13:46:11 <ceii> but length is defined by recursing on the list
13:46:15 <accel> like if I start enumerating all progrmasms that halt or not
13:47:55 <accel> @src and
13:47:55 <lambdabot> and   =  foldr (&&) True
13:48:28 <accel> is it important whether and is foldr or foldl ?
13:48:33 <ski> yes
13:48:34 <augustss> yes!
13:48:47 <mauke> > and (repeat False)
13:48:48 <lambdabot>   False
13:48:56 <accel> > repeat False
13:48:56 <ski> > foldl (&&) True (repeat False)
13:48:56 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
13:49:00 <lambdabot>   mueval-core: Time limit exceeded
13:49:06 <accel> and True : repeat False
13:49:09 <accel> > and True : repeat False
13:49:13 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
13:49:13 <lambdabot>         against inferred typ...
13:49:20 <accel> > and True : (repeat False)
13:49:21 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
13:49:21 <lambdabot>         against inferred typ...
13:49:27 <accel> > True : (repeat False)
13:49:27 <ski> > and (True : repeat False)
13:49:28 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
13:49:28 <lambdabot>   False
13:49:44 <ski> > and (False : repeat True)
13:49:45 <lambdabot>   False
13:49:49 <accel> > and (False : (repeat True))
13:49:50 <lambdabot>   False
13:49:52 <accel> got it; thanks
13:50:03 <accel> @sum
13:50:03 <lambdabot> Maybe you meant: bug run src
13:50:07 <accel> @src sum
13:50:07 <lambdabot> sum = foldl (+) 0
13:50:14 <accel> dumb question ... why are funtions like sum defined to be foldl
13:50:24 <ceii> because it's tail recursive
13:50:24 <mrd> mistake
13:50:26 <ion> Function application has the highest precedence, so and foo : … means (and foo) : …
13:50:27 <mauke> stupidity
13:50:29 <mrd> it should be foldl'
13:50:39 <ion> and … : repeat bar means … : (repeat bar)
13:50:50 <accel> ion: got it; thanks
13:51:10 <accel> @src foldl
13:51:11 <lambdabot> foldl f z []     = z
13:51:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:51:17 <accel> @src foldr
13:51:17 <lambdabot> foldr f z []     = z
13:51:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:51:18 <ion> As you remember reading from LYAH
13:51:29 <accel> no, I'm reading RWH right now; haven't readLYAH
13:51:48 <accel> ah, so foldr allows short circuiting
13:51:59 <accel> whereas foldl allows tail recursion
13:52:09 <accel> but the (f z x) can still srewn you over by creating thunks on the heap
13:52:35 <accel> > False : repeat True
13:52:36 <lambdabot>   [False,True,True,True,True,True,True,True,True,True,True,True,True,True,Tru...
13:52:42 <accel> > map not (False : repeat True)
13:52:43 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
13:52:51 <accel> > or map not (False : repeat True)
13:52:53 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
13:52:53 <lambdabot>         against inferred typ...
13:52:58 <accel> > or $ map not (False : repeat True)
13:52:59 <lambdabot>   True
13:53:04 <accel> intresting
13:53:34 <Kaidelong> accel: foldr can be tail recursive in a sense, for example with something like "foldr (:) []", the identity on lists, if you evaluate the tail it is sort of like a tail call
13:53:34 <Kaidelong> it just doesn't look that way in the definition
13:53:52 <accel> @src foldr
13:53:52 <lambdabot> foldr f z []     = z
13:53:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:54:14 <accel> Kaidelong: how can do you amke taht tail recursive?
13:54:22 <accel> seems like the f x ... <-- the f x must be kept along
13:54:25 <Kaidelong> accel: right, depending on the semantics of f, you may end up just throwing away everything but its second argument
13:55:26 <Kaidelong> > foldr (flip const) 5 [1..1000]
13:55:30 <lambdabot>   mueval-core: Time limit exceeded
13:55:38 <manzyuk> Hello everybody.  I am curious: what is the idiomatic to write something like let g = do { line <- getLine; if line == "quit" then return [] else liftM (l:) g } in g?  Basically, I am trying to read lines from a handle until "OK" is encountered.  My first attempt was liftM (takeWhile (/= "OK")) . sequence . repeat $ hGetLine handle, but it doesn't work (I assume it reads all the available response and then blocks).  Is there a way to
13:55:38 <manzyuk> write the above g without explicit recursion?
13:56:13 <Kaidelong> ah so haskell can't figure that one out
13:56:15 <Kaidelong> shame
13:56:25 <Kaidelong> err
13:56:26 <Kaidelong> whoops
13:56:38 <Kaidelong> > foldr1 (flip const) [1..1000]
13:56:41 <lambdabot>   1000
13:56:48 <Egbert9e9> how do i stick type classes inside type declaration's type variables?
13:56:50 <Kaidelong> that is what I meant
13:57:00 <accel> @src const
13:57:00 <lambdabot> const x _ = x
13:57:46 <dino-> Egbert9e9: You mean like this? : foo :: (Bar a) => a -> b
13:57:47 <Egbert9e9> i want one of the type variables to belong to the Integral typeclass
13:57:50 <accel> > map (- 1) [1 2 3]
13:57:51 <lambdabot>   [-1]
13:57:57 <ion> manzyuk: ‘let f = blah f in f’ can be written as ‘fix $ \f -> blah f’ (and for that specific example the point-free form would be ‘fix blah’)
13:58:00 <accel> > map (+ 1) [1 2 3]
13:58:01 <lambdabot>   [2]
13:58:05 <mauke> hahaha
13:58:21 <accel> > map (+ 1) [1, 2, 3]
13:58:22 <lambdabot>   [2,3,4]
13:58:24 <mrd> > [ 1 2  3 ]
13:58:25 <lambdabot>   [1]
13:58:27 <Egbert9e9> dino-, exactly, but with "data newType (Bar a) = etc etc"
13:58:27 <accel> > map (- 1) [1, 2, 3]
13:58:28 <lambdabot>   [-1,-1,-1]
13:58:29 <dino-> Egbert9e9: Bar is your typeclass there
13:58:36 <ujihisa> > map (subtract 1) [1, 2, 3]
13:58:37 <lambdabot>   [0,1,2]
13:58:39 <ceii> @instances Num
13:58:39 <mauke> accel: -1 is -1
13:58:41 <lambdabot> Double, Float, Int, Integer
13:58:44 <Egbert9e9> dino-, something like that
13:58:49 <Kaidelong> accel: what would happen would be "flip const x (foldr (flip const) xs)"
13:58:49 <ujihisa> > map (-1 +) [1, 2, 3]
13:58:50 <lambdabot>   [0,1,2]
13:58:55 <accel> > map ((-) 1) [1, 2, 3]
13:58:56 <lambdabot>   [0,-1,-2]
13:58:56 <dino-> Egbert9e9: Oh, you do it in a diff declaration. Do your data and then instance it in a separate decl.
13:59:01 <mrd> lambdabot bug? [1 2 3]?
13:59:05 <Kaidelong> accel: that is actually just "foldr (flip const) xs"
13:59:06 <accel> > map (flip (-) 1) [1, 2, 3]
13:59:08 <lambdabot>   [0,1,2]
13:59:13 <Kaidelong> so it is sort of like tail recursion
13:59:18 <mauke> mrd: not a bug
13:59:20 <ujihisa> . map ((-) 1) [1, 2, 3] == map (1 -) [1, 2, 3]
13:59:20 <Egbert9e9> dino-, oh, with the instance thingie
13:59:25 <Kaidelong> err
13:59:27 <Kaidelong> well that's not right
13:59:32 <Kaidelong> but it shows the *general* idea
13:59:33 <Egbert9e9> dino-, weee, i'll finally get to use it
13:59:33 <shachaf> mrd: http://blogs.pcworld.com/tipsandtweaks/archives/feature.jpg
13:59:38 <ujihisa> > map ((-) 1) [1, 2, 3] == map (1 -) [1, 2, 3]
13:59:38 <mrd> hehe
13:59:39 <lambdabot>   True
14:00:03 <ion> shachaf: Hah
14:00:13 <Egbert9e9> wait, no, that's for typeclasses
14:00:37 <mauke> > (sqrt + 1) 2
14:00:38 <lambdabot>   2.414213562373095
14:00:55 <accel> on chapter 4, section on space leaks & strict evaluation
14:01:05 <accel> when ahskell says "it forces its first argument to be evaluated" what does it mean?
14:01:21 <Kaidelong> accel: it means the first argument becomes head strict
14:01:22 <companion_cube> haskell is lazy
14:01:36 <shachaf> Haskell sure goes to a lot of trouble to be lazy.
14:01:36 <Kaidelong> accel: sometimes you want to do this, like with foldl
14:01:43 <shachaf> It would seem to defeat the purpose.
14:02:13 <Kaidelong> shachaf: but it doesn't go to the trouble to be lazy, but rather to be non-strict
14:02:39 <Kaidelong> you could do stuff like speculative parallelism and be non-strict while being kind of eager
14:02:49 <manzyuk> well, I copied the expression from GHCi, so it's more of an accident that it has this particular form.  What bothers me is that it uses explicit recursion, although the pattern is very simple.
14:02:58 <Kaidelong> lazy evaluation is just one approach to being non-strict
14:03:17 <Kaidelong> and I am starting to think it is not the best one (and reading Conal's blog he's been thinking the same sorts of things)
14:03:22 <shachaf> Kaidelong: But it's more complicated than some approaches.
14:03:53 <xplat> shachaf: what is simpler?  call by name?
14:04:14 <shachaf> xplat: Isn't it?
14:04:50 <dino-> Egbert9e9: There's probably lots of better things to read, but this may help: http://en.wikibooks.org/wiki/Haskell/YAHT/Type_advanced
14:04:53 <xplat> well, it is a little, but hey whoa look at these exponential time leaks!
14:05:30 <shachaf> xplat: Well, yes. Hence "goes to a lot of trouble to be lazy".
14:05:35 <shachaf> Though I suppose I did mean non-strict.
14:05:46 <dino-> Oh, I'm a dork, how about Learn You http://learnyouahaskell.com/types-and-typeclasses#believe-the-type
14:05:47 <shamster> is I have a list of partial functions, and another list of values, how can I create a list of all the partial functions applied to the values?
14:05:54 <shamster> s/is/if
14:06:04 <Botje> shamster: zipWith ($)
14:06:09 <kmc> partial functions?
14:06:13 <Kaidelong> shachaf: that makes sense
14:06:13 <shamster> Botje: brilliant! thanks
14:06:18 * hackagebot iteratee 0.7.0.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.7.0.2 (JohnLato)
14:06:19 <accel> > let x = error "WTF" in x `seq` 0
14:06:20 * hackagebot iteratee 0.8.0.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.0.1 (JohnLato)
14:06:21 <lambdabot>   *Exception: WTF
14:06:25 <Kaidelong> but it goes to a lot of trouble to be lazy to be non-strict in a good way
14:06:25 <accel> > let x = error "WTF" in (x,x) `seq` 0
14:06:26 <lambdabot>   0
14:06:32 <accel> why in the latter, does WTF not get thrown?
14:06:45 <Kaidelong> accel: seq only does WHNF
14:06:56 <Kaidelong> (_|_,_|_) is not _|_
14:06:56 <accel> wtf is whnf
14:06:57 <Botje> because seq only evaluates up until the first constructor, which is (,) here
14:07:19 <xplat> you could say it goes to exponentially less trouble to be non-strict than a CBN evaluator
14:07:19 <kmc> accel, weak head-normal form
14:07:20 <Kaidelong> seq only guarantees _|_ if the first argument is _|_
14:07:34 <kmc> accel, whnf means the outermost thing is not a functnion application
14:07:39 <kmc> could be a lambda or a data constructor
14:07:41 <xplat> the runtime implementor works more, the runtime works less
14:07:52 <kmc> means that the outermost expression can't be reduced further
14:07:54 <kmc> but inner stuff might be
14:08:03 <sproingie> > let x = error "WTF" in (Product 123) `seq` 0
14:08:04 <lambdabot>   0
14:08:06 <kmc> Just (2 + 2) is in WHNF but not normal form, since you can reduce inside to get Just 4
14:08:09 <accel> > let x = error "WTF" in (!x,!x) `seq` 0
14:08:10 <lambdabot>   A section must be enclosed in parentheses thus: (! x)A section must be encl...
14:08:27 <Kaidelong> accel: ! is only for patterns
14:08:30 <accel> > data Lazy = Lazy Int Int; let x = error "WTF" in (Lazy x x) `seq` 0
14:08:31 <lambdabot>   <no location info>: parse error on input `data'
14:08:34 <sproingie> doh
14:08:36 <kmc> the reason Haskell cares about WHNF is that the most primitive form of pattern-matching is to ask "what's the outermost constructor", and WHNF is exactly as much as you need to answer that question
14:08:38 <sproingie> > let x = error "WTF" in (Product x) `seq` 0
14:08:39 <lambdabot>   *Exception: WTF
14:08:47 <kmc> we can match Just (2+2) against Just x without evaluating the (+)
14:08:55 <sproingie> newtype doesn't count here?
14:09:02 <Kaidelong> sproingie: no
14:09:05 <Kaidelong> newtypes just go away
14:09:08 <Kaidelong> at compile time
14:09:11 <shachaf> sproingie: newtype is just a new type.
14:09:21 <Kaidelong> sproingie: that is actually also the whole point
14:09:45 <Kaidelong> the whole idea is that newtype "constructors" are strict in their arguments, so they can be eliminated at compile time
14:09:56 <Kaidelong> (they also must use only one argument)
14:10:12 <revenantphx> :t (>>=)
14:10:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:10:16 <mauke> sproingie: newtype Void = V Void  -- how many values are in this type?
14:10:57 <accel> > data Lazy = Lazy Int Int
14:10:58 <lambdabot>   <no location info>: parse error on input `data'
14:11:02 <accel> err, what's wrong with that?
14:11:08 <mauke> accel: it's not an expression
14:11:27 <accel> so I can't feed it to ghci / lambdabot?
14:11:37 <Kaidelong> nope
14:11:49 <xplat> ghci and mueval do not accept data declarations (well, ghci does but only through :load, not command line)
14:11:50 <Kaidelong> easy enough to just make a hs and run it in ghci though
14:12:02 <Kaidelong> with :load, yes
14:12:39 * Kaidelong is glad to see accel is sticking around so long
14:13:02 <sm> accel: making some headway ?
14:13:17 <xplat> it kind of makes sense, because ghci accepts things that could go in the do block in main = do { ... }
14:13:34 <periodic> I've been wanting a way to quickly define data types in ghci without having to write a temporary file.
14:13:34 <xplat> and you can't put type declarations or imports in a do block
14:13:37 <accel> sm: into what?
14:14:00 <xplat> ghci accepts imports, but that's basically a hack, especially before GHC7
14:14:19 <sm> accel: it looked like you were doing some opengl experiments
14:14:36 <sm> just curious
14:15:01 <accel> sm: the OpenGL stuff is working fine, I'm blocking on some ahskell stuff at the moment
14:15:24 <sm> cool
14:16:25 <sm> yeah, it's a pity but ghci doesn't accept arbitrary haskell code, just "expressions". Trips up most learners
14:19:32 <xplat> of course, with the stuff lambdabot has loaded you could probably fake up any 'interesting' algebraic type you want
14:20:09 <shachaf> Is there a reason @let doesn't allow data declarations?
14:20:11 <mauke> type Lazy = (,) Int Int
14:20:55 <accel> I'm confused on what the keyword "isntance" does in the context o typeclasses
14:20:56 <Kaidelong> shachaf: perhaps it could allow you to escape the jail somehow
14:21:07 <mauke> accel: it makes instances
14:21:11 <Kaidelong> I am not sure how you could do that without being able to declare instances though
14:21:12 <accel> lol
14:21:13 <shamster> I'd like to create a project module with sub-modules... i.e. import Project.PartA, import Project.PartB... etc. Do I create a directory called 'Project' and then populate it with 'PartA.hs' and 'PartB.hs' ?
14:21:22 <shachaf> @let import System.IO.Unsafe
14:21:22 <lambdabot>  Invalid declaration
14:21:33 <ceii> shamster: yes
14:21:37 <Kaidelong> accel: classes are interfaces, instances are classes, to use a loose java analogy
14:21:53 <Kaidelong> instances implement classes
14:21:56 <accel> Kaidelong: concretely, typeclass is something like "Show/Ord/Equal" ?
14:22:02 <accel> Kaidelong: and instances are shit like data MyDataType ?
14:22:07 <monochrom> yes
14:22:10 <mauke> not quite
14:22:11 <Kaidelong> basically
14:22:14 <mauke> an instance is not a type
14:22:16 <shamster> ceii: it doesn't seem to be working that way, even though I'm told it should
14:22:18 <accel> Kaidelong: and instances are shit like data MyDataType ? --> instance Show MyDataType ?
14:22:20 <mauke> an instance is a bundle of operations
14:22:30 <Kaidelong> an instance is a proof that a data type is a member of a type class
14:22:44 <Kaidelong> that is one way to think of it
14:22:45 <accel> hmm, is this like generics in common lisp object system s?
14:23:03 <shamster> ceii: at the top of PartA.hs, I have 'module Project.PartA (.....) where' and then all my code...
14:23:10 <monochrom> I don't know.
14:23:11 <xplat> a little, but that's probably not a helpful way to think of it
14:23:13 <shamster> ceii: is that about right?
14:23:16 <blueonyx> the forkIO doc says: The newly created thread has an exception handler that discards the exceptions BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, and __ThreadKilled__. but how to kill a child process then?
14:23:41 <mauke> what child process?
14:24:10 <xplat> accel: have you ever used postgresql?
14:24:34 <monochrom> note that having "an exception handler that discards blah" does not help the thread "recover" or "ignore" blah.
14:24:36 <blueonyx> mauke: the forked one?
14:24:43 <mauke> blueonyx: what?
14:24:51 <accel> xplat: never
14:25:07 <blueonyx> monochrom: okay, then my problem is something else :/
14:25:07 <accel> xplat: might have set it up once; but I have SQL
14:25:16 <xplat> accel: too bad, there's something a lot like typeclasses in there
14:25:22 <mauke> blueonyx: forkIO doesn't create processes
14:25:26 <revenantphx> I got bored.
14:25:32 <revenantphx> I implemented the Maybe monad in Objective-C.
14:25:38 <revenantphx> NSNumber *num = [NSNumber numberWithInteger:10];
14:25:38 <revenantphx> NSLog(@"%@", [[[Maybe returnM:num] bindM:multiplyByTwo] bindM:multiplyByTwo]);
14:25:45 <revenantphx> (result is "Just 40")
14:25:59 <revenantphx> (if the contained value is nil I mark it as Nothing, which isn't exactly great :P)
14:26:17 <revenantphx> (but it works)
14:26:32 <blueonyx> mauke: of course :)
14:26:36 <monochrom> in the year 2011 people still confuse unix signals with catch-throw exceptions
14:26:55 <byorgey> copumpkin: yes, having my mind blown =D
14:26:57 <revenantphx> Those are different?
14:27:02 <revenantphx> ;)
14:27:08 <monochrom> yes
14:27:17 <copumpkin> byorgey: yeah, I'm used to that now
14:28:53 <xplat> accel: basically a class is a spec of some operations you would like to have work on multiple different types
14:29:00 <ceii> shamster: make sure you're calling ghc or ghci from the root directory, the one that contains Project
14:29:16 <blueonyx> monochrom: can you explain this? i use forkIO and killThread doesn't kill the forked thread
14:29:30 <xplat> accel: and an instance tells you how the operations are actually implemented for some of those types
14:29:32 <monochrom> I cannot because it works for me.
14:30:11 <blueonyx> monochrom: explain the unix signal/cath-throw exception confusion
14:31:01 <sm> a class declaration specifies an interface that a type supports, an instance declaration specifies the implementation of same
14:31:12 <Cale> blueonyx: If you're using something other than GHC, check that the ThreadId type isn't ()
14:31:15 <monochrom> you can set yourself up to ignore a signal. you can write a signal handler that at the end says "resume what I have been doing". these are not available to java exceptions and haskell exceptions.
14:31:20 <shamster> ceii: I'm in the directory ./ and it contains ./Project/, that in turn contains ./Project/PartA.hs
14:31:24 <Cale> blueonyx: I believe that hugs doesn't support killThread
14:31:30 <shamster> ceii: I run 'ghci -iProject/' 
14:31:42 <blueonyx> Cale: i use ghc
14:31:54 <shamster> ceii: but I still can't do 'import Project.PartA' or 'import PartA' or anything without an error
14:31:59 <Cale> Then it really ought to work...
14:32:16 <ceii> shamster: what about if you remove the -i argument?
14:32:47 <shamster> ceii: then it still doesn't work
14:32:58 <tolkad> Why doesn't haskell support existentials in type signatures?
14:33:02 <ceii> then I have absolutely no idea what's wrong
14:33:07 <Cale> blueonyx: So if you write this in GHCi, what happens?  do tid <- forkIO (forever (putStrLn "a")); killThread tid
14:33:10 <tolkad> Why do you have to hide them inside types
14:33:15 <tolkad> like you're ashamed of them
14:33:16 <Cale> (with Control.Monad and Control.Concurrent loaded)
14:33:54 <xplat> tolkad: to save a reserved word ...
14:34:10 <tolkad> xplat: is that seriously the reason?
14:34:33 <tolkad> xplat: hardly anyone uses more than one-letter type variables anyway
14:34:49 <shamster> ceii: to summarize see this: http://codepad.org/aOhyrdrs
14:34:56 <kmc> Haskell doesn't support existentials, period
14:35:08 <kmc> GHC supports them but not in a first-class way
14:35:17 <kmc> UHC supports them in a first class way, but with other limitations
14:35:21 <monochrom> Cale's code probably hangs blueonyx's computer :)
14:35:23 <xplat> tolkad: really i'm speculating, you'd have to ask a GHC implementor
14:35:26 <edwardk> tolkad: not entirely, it also has to do with certain messy issues with impredicative type signatures, and allows the compiler to only have to deal with them in certain places in ghc, for instance matching on a newtype can't bring into scope equality constraints, matching on a data constructor can, so they can use this in newtype deriving
14:35:28 <shamster> ceii: not sure how to import those
14:35:31 <copumpkin> :t True ==> exists x. x
14:35:32 <lambdabot> Not in scope: `exists'
14:35:55 <Cale> monochrom: apparently :)
14:36:01 <blueonyx> Cale: this works
14:36:09 <edwardk> in fact the few bugs that have been filed with ghc on the  topic asking for stuff like this on newtypes have been flagged wontfix or notabug ;)
14:36:21 <ceii> shamster: and how do you import them?
14:36:27 <Cale> blueonyx: So if that stops printing a's, your problem isn't that killThread itself doesn't work
14:36:33 <blueonyx> monochrom: no i tried to replace my sh -c "while true;.." with forever, but then it doesn't start anything :/
14:36:59 <xplat> oh, exists x. could break newtype deriving?  i don't want it anymore either :)
14:36:59 <shamster> ceii: That's the problem... I don't know how to import them
14:37:23 <shamster> ceii: I thought I could launch ghci from the root dir and do a 'import Project.PartA', but it's not found
14:37:29 <monochrom> I didn't have shell scripts in my. I had #include <signals.h> or something.
14:38:25 <Cale> blueonyx: Can I see what you're trying to write? Is it simple?
14:38:33 <blueonyx> hang on
14:39:03 <ceii> shamster: seems import in ghci doesn't import local files
14:39:15 <ceii> shamster: use :l Project.PartA
14:39:26 <blueonyx> Cale: http://friendpaste.com/maN7t7ZHGbF6ZGiRX8PnL
14:39:56 <accel> man
14:40:00 <accel> chapter 6 of RWH makes no sense to me
14:40:12 <accel> Is there an alternatite treatment of typeclasses I can read first/
14:40:31 <Kaidelong> accel: LYAH goes over them
14:40:43 <Kaidelong> @where LYAH
14:40:44 <lambdabot> http://www.learnyouahaskell.com/
14:40:55 <monochrom> it looks scary to spawn infinitely many mplayer instances
14:41:09 <blueonyx> its an stream
14:41:24 <tolkad> is it bad to write monads like « data (a ~ b) => MyMonad a b = MyMonad a »?
14:41:24 <monochrom> and then killThread will only kill the spawner.
14:41:32 <shamster> ceii: even then, I still have to do ':l Project/PartA' not ':l Project.PartA'
14:41:49 <tolkad> so that you can then write seperate instances for different type parameters
14:41:50 <blueonyx> but its not even killing the sh
14:42:04 <monochrom> killThread does not kill anyone's sh.
14:42:04 <shamster> ceii: oh... n/m, I had a typo
14:42:05 <Cale> right, you should be able to kill that thread, but killing the thread won't kill the sh
14:42:06 <tolkad> like you could write « instance Monad (MyMonad ()) », etc.
14:42:09 <monochrom> not its job
14:42:15 <shamster> ceii: that seems to work for ghci... thanks!
14:42:18 <Cale> It'll just kill the thread
14:42:25 <ceii> you're welcome
14:42:40 <Cale> (which will prevent it from creating more mplayers)
14:42:50 <monochrom> the thread does not "own" all those sh's and mplayer's it spawns. entirely difference processes.
14:43:41 <cyphunk> what is the proper name for the '$' so i can rtfm?
14:43:43 <monochrom> whereas the thread does "own" whatever putStrLn it executes, so if you killThread you can stop the putStrLn's
14:43:49 <Cale> You should use the API from http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
14:44:02 <Cale> and get a ProcessHandle which you can use to kill the process later
14:44:30 <Cale> (using terminateProcess)
14:44:34 <tolkad> cyphunk: http://www.haskell.org/hoogle/?hoogle=%28%24%29
14:44:56 <cyphunk> tolkad: thanks
14:45:31 <Kamx> Question: How do I avoid of overlapped pattern matches in the expression (\x -> case x of SomeConstructor _ -> True; _ -> False)
14:45:41 <Kamx> Question: How do I avoid the warning of overlapped pattern matches in the expression (\x -> case x of SomeConstructor _ -> True; _ -> False)
14:45:49 <tolkad> Kamx: that doesn't make any sense
14:46:01 <tolkad> Kamx: oh nevermind misread it
14:46:06 <Cale> Kamx: Your pattern matches are overlapping by design
14:46:17 <Cale> Kamx: Ignore the message, it is silly.
14:46:20 <monochrom> > case Nothing of Just _ -> True; _ -> False)
14:46:21 <lambdabot>   <no location info>: parse error on input `)'
14:46:24 <cyphunk> tolkad: do i have ti import Prelude to use $?
14:46:26 <monochrom> > case Nothing of Just _ -> True; _ -> False
14:46:27 <lambdabot>   False
14:46:32 <tolkad> Kamx: -fno-warn-overlapping-patterns
14:46:32 <Kamx> I want a function returning True, if SomeConstructor matches, False otherwise
14:46:39 <Cale> cyphunk: Prelude is always imported by default
14:46:48 <Cale> cyphunk: But yes, it must be in scope
14:46:49 <cyphunk> tis what i thought. bah, ghci :/
14:47:09 <Kamx> Cale, tolkad: so it's not bad style to overlap pattern matches?
14:47:19 <blueonyx> Cale: thanks, ill look into it
14:47:24 <Cale> Kamx: I wouldn't say so. It's good style in some cases.
14:47:31 <monochrom> I get no warning for overlapped pattern matches
14:47:37 <Cale> Kamx: Particularly with a catch-all case at the end.
14:47:42 <kmc> :t toConstr
14:47:43 <lambdabot> forall a. (Data a) => a -> Constr
14:47:49 <Cale> monochrom: Do you have -Wall turned on?
14:47:53 <monochrom> no
14:47:56 <Cale> -Wall is obnoxious
14:48:01 <kmc> @let sameConstr = (==) `on` toConstr
14:48:02 <lambdabot>  Defined.
14:48:09 <monochrom> perhaps this is why I denounce -Wall
14:48:11 <kmc> > sameConstr (Just 3) (Just 'x')
14:48:12 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:48:12 <lambdabot>    arising from the literal `3...
14:48:15 <Cale> Most of the additional warnings it gives are spurious junk.
14:49:00 <tolkad> If your code compiles with warnings it means you are a bad programmer and your code is probably unstable and full of security vulnerabilities
14:49:09 <ski> @type sameConstr
14:49:10 <lambdabot> forall a. (Data a) => a -> a -> Bool
14:49:23 <ski> @define
14:49:38 <ski> @let sameConstr a0 a1 = toConstr a0 == toConstr a1
14:49:39 <lambdabot>  Defined.
14:49:41 <tolkad> s/probably/certainly/
14:49:46 <Kamx> Cale: There is no other way than matching against _ for a default entry in the case construct?
14:49:48 <Cale> tolkad: Or it just means that the compiler warnings are overzealous.
14:49:54 <ski> > Just 3 `sameConstr` Just 'x'
14:49:56 <lambdabot>   True
14:50:03 <Cale> Kamx: Well, you could match against a simple variable.
14:50:16 <Cale> Kamx: That will also overlap though.
14:50:34 <Cale> Kamx: Because it would match anything which all the previous cases matched.
14:50:34 <tolkad> Cale: then it will give you a warning about an unused variable
14:50:35 <tolkad> XD
14:50:45 <Cale> Yeah, that too. Stupid -Wall.
14:50:57 <accel> ski: still around?
14:51:15 <ski> accel : somewhat
14:51:26 <tolkad> Kamx: -fno-warn-overlapping-patterns <-- just put this in the ghc-options of your cabal file
14:51:40 <accel> ski: cool; taking break from RWH; parsing your code; might interrupt you at random intervals
14:52:08 * ski . o O ( `instance Random Interval where ..' )
14:52:10 <Kamx> I'll make the warning to be ignored then... however is there a nicier expression for (\x -> case x of SomeConstructor _ -> True; _ -> False) ?
14:52:22 <Kamx> It reads a bit odd...
14:53:10 <accel> ski: drawWithColor is basically teh solution I ended up inventing; /me moves on to newer solutions
14:53:19 <ceii> Kamx: there isn't, but some types have a predefined function for that, like null or isJust
14:53:23 <Cale> Kamx: Normally I'll define a function  isSomeConstructor  if I'm going to need that
14:53:31 <Kamx> if i want to use it as argument to filter, then list comprehensions seem to be a nice way: let portOpts = [ x | x@(Port _) <- opts ]
14:53:48 <Cale> absolutely, yeah
14:53:56 <Kamx> but i wonder, if there is another general way to make it look nicier
14:54:32 <accel> draw shape = runReaderT (drawWithColor shape) =<< getCurrentColor <-- how does taht compile given drawWithColor :: Gl.COLOR3 Double -> Shape -> IO () ?
14:54:38 <accel> ski: ^^
14:54:41 <ski> accel : yes, except i make a local `draw' to avoid having to mention the `currentColor' argument all the time
14:55:25 <tolkad> Kamx: you could write it as a function and pattern match in the argument
14:55:36 <tolkad> Kamx: but that's semantically equivalent
14:55:38 <ski> accel : er, sorry, i forgot to rename `drawWithColor' to `drawColored' in that alternative definition of `draw'
14:55:45 <accel> ski: ah; makes sense now, thanks
14:55:57 <accel> @src runReaderT
14:55:57 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:56:01 <accel> :t runReaderT
14:56:02 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
14:56:07 <ski> @src ReaderT
14:56:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:56:17 <tolkad> :t lift . runReaderT
14:56:18 <lambdabot>     Ambiguous occurrence `lift'
14:56:18 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
14:56:18 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
14:56:25 <ski>   newtype ReaderT r m a = ReaderT {runReaderT :: r -> m a}
14:56:26 <accel> lol
14:56:28 <tolkad> wtf
14:56:34 <Kamx> ceii, Cale, tolkad: okay, thanks..
14:56:37 <accel> @hoogle runReaderT
14:56:37 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
14:56:41 <tolkad> @src lift
14:56:41 <lambdabot> Source not found. Are you on drugs?
14:56:43 <ski> @type Control.Monad.Logic.lift
14:56:44 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
14:57:09 <ski> @type Control.Monad.Trans.lift . runReaderT
14:57:10 <lambdabot> forall (t :: (* -> *) -> * -> *) r (m :: * -> *) a. (Control.Monad.Error.MonadTrans t) => ReaderT r m a -> t ((->) r) (m a)
14:57:41 <tolkad> Kamx: YOU COULD USE PATTERN GUARDS
14:58:14 <tolkad> then ghc might not even bother to notice that they are overlapping. possible
14:58:17 <ski> tolkad : would that make the warning disappear ?
14:58:29 <tolkad> ski: maybe, I don't know
14:58:32 <accel> ski: I'm getting the impression I should read the RWH chapters on monad transformers then come back to this
14:58:45 <accel> ski: the runReaderT, lift, are confusing me; I don't get what's going on
14:58:53 <tolkad> accel: just use @unmtl
14:58:55 <accel> nor why you ahve to do stuff to perservingMatrix
14:58:58 <accel> @unmtl
14:58:58 <lambdabot> err: Parse error
14:59:03 <tolkad> @unmtl ReaderT m a
14:59:03 <lambdabot> err: `ReaderT m a' is not applied to enough arguments, giving `/\A. m -> a A'
14:59:09 <tolkad> @unmtl ReaderT r m a
14:59:09 <lambdabot> r -> m a
14:59:15 <ski> accel : in this case, `lift :: IO a -> ReaderT (GL.Color3 Double) IO a'
14:59:18 <tolkad> @unmtl ReaderT r (StateT s m a) a
14:59:18 <lambdabot> err: `s -> m (a, s)' is not a type function.
14:59:26 <tolkad> @unmtl ReaderT r (StateT s m) a
14:59:27 <lambdabot> r -> s -> m (a, s)
14:59:31 <Kamx> tolkad: let me check pattern guards... i think i didn't use them yet..
14:59:37 <tolkad> Kamx: it's an extension
15:00:13 <accel> ski: I understand "IO a" as (World) -> (World, a) ... how should I understand ReaderT as ?
15:00:17 <tolkad> @unmtl ReaderT r (StateT s (r->)) a
15:00:18 <lambdabot> err: Parse error
15:00:24 <tolkad> @unmtl ReaderT r (StateT s ((->)r)) a
15:00:24 <lambdabot> r -> s -> (->) r (a, s)
15:00:45 <ski> accel : so `lift (GL.color currentColor) :: ReaderT (GL.Color3 Double) IO ()'
15:01:00 <Kamx> tolkad: aren't they included in Haskell 2010?
15:01:02 <tolkad> accel: a function returning something wrapped in a monad
15:01:06 <tolkad> Kamx: I don't know
15:01:19 <accel> :t lift
15:01:20 <lambdabot>     Ambiguous occurrence `lift'
15:01:20 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
15:01:20 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
15:01:29 <accel> :t Control.Monad.Logic.Lift
15:01:30 <lambdabot>     Not in scope: data constructor `Control.Monad.Logic.Lift'
15:01:31 <ski> @unmtl ReaderT (GL.Color3 Double) IO a
15:01:31 <lambdabot> GL.Color3 Double -> IO a
15:01:36 <ski> accel : ^
15:01:39 <Kamx> tolkad: they are: http://www.haskell.org/pipermail/haskell/2009-November/021750.html
15:02:03 <ski>   newtype ReaderT r m a = ReaderT {runReaderT :: r -> m a}  -- cf.
15:02:14 <accel> ski: "ReaderT (Gl.Color3 Double) IO a" is a function thta takes "GL.Color3 Double" and returns an "IO a" ?
15:02:18 <tolkad> personally, I can't believe how HierarchicalModules got in
15:02:32 <ski> accel : yes, behind the covers, that's it
15:03:11 <accel> fuck; time to bring out pencil & paper
15:03:14 <ski> accel : but doing it this way hides the distributing of the `GL.Color3 Double' argument to all the actions, and also lets us use `ask' and `local'
15:03:35 <ski>   ask :: ReaderT (GL.Color3 Double) IO (GL.Color3 Double)
15:03:56 <tolkad> :t asl
15:03:57 <lambdabot> Not in scope: `asl'
15:03:58 <tolkad> :t ask
15:03:59 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
15:04:09 <ski>   local :: (GL.Color3 Double -> GL.Color3 Double) -> (ReaderT (GL.Color3 Double) IO a -> ReaderT (GL.Color3 Double) IO a)
15:04:16 <ski> in this case
15:04:45 <Kamx> tolkad: but how do pattern guards help me simplify my expression?
15:05:57 <tolkad> f x | (SomeConstructor _) <- x = True
15:06:02 <tolkad> f _ = False
15:06:35 <tolkad> wow that's brilliant
15:06:42 <tolkad> I surprise myself with my genius sometimes
15:07:01 <copumpkin> what's the point of that?
15:07:07 <Kamx> tolkad: is it ironic?
15:07:33 <tolkad> Kamx: no, it's named "f"
15:07:39 <accel> ski: drawColored (Cube d)                 = lift (Cube.cube d) <-- this line, you rewrite the right side?
15:07:43 <accel> @src lift
15:07:43 <lambdabot> Source not found. Maybe you made a typo?
15:07:51 <accel> @t lift
15:07:51 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:07:56 <accel> :t lift
15:07:57 <lambdabot>     Ambiguous occurrence `lift'
15:07:58 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
15:07:58 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
15:08:04 <accel> :t Control.Monad.Logic.Lift.lift
15:08:05 <lambdabot> Couldn't find qualified module.
15:08:15 <accel> :t Control.Monad.Logic.lift
15:08:16 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
15:08:20 <accel> @src Control.Monad.Logic.lift
15:08:20 <lambdabot> Source not found. Sorry.
15:08:21 <tolkad> copumpkin: I'm kidding about the geniusness. it might possible trick ghc into not realizing it's overlapping?
15:08:33 <Kamx> tolkad: i barely get those jokes.. especially as i'm quite a beginner ;-)
15:08:38 <copumpkin> where was stuff overlapping before?
15:08:59 <tolkad> copumpkin: Kamx didn't like the fact his equivalent case expression was causing an overlapping warning
15:09:07 <copumpkin> hm okay
15:09:33 <ski> accel : yes, since i changed from the `IO' to the `ReaderT (GL.Color3 Double) IO' monad, and `Cube.cube d' is an `IO'-action, i had to lift it to an `ReaderT (GL.Color3 Double) IO'-action, by using `lift'
15:09:52 <ski> @type Control.Monad.Trans.lift
15:09:53 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
15:09:59 <ski> accel : ^ that's the one
15:10:00 <accel> ski: hmm, actually, sorry to change again, maybe perservingCOlor is the right first function to understand
15:10:06 <accel> ski: so we get the currentColor via "ask"
15:10:09 <ski> yes
15:10:18 <accel> ski: then we do "a <- action"
15:10:22 <accel> then we set the current color
15:10:30 <accel> immediate question is ... how does "ask" know to do the right thing?
15:10:46 <accel> ask is a global function right?
15:10:55 <accel> where do we pass it the readerT monad?
15:11:11 <ski> `ask' just gets the current environment from the `ReaderT (GL.Color3 Double) IO' monad
15:11:20 <ski>   ask :: ReaderT (GL.Color3 Double) IO (GL.Color3 Double)
15:11:40 <ski> there is no passing of monads
15:11:52 <ski> a monad is a type, together with some associated operations
15:11:53 <accel> ski: where is ask defined?
15:12:02 <ski> in `Control.Monad.Reader'
15:12:02 <accel> ski: is ask defined the ReaderT monad?
15:12:05 <ski> @index ask
15:12:05 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
15:12:10 <edwardk>  tolkad: [-# OPTIONS_GHC -fno-warn-overlapping-patterns #-}
15:12:26 <Philippa> accel: the "magic" is in ReaderT's >>= and in runReaderT
15:12:37 <accel> ski: http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Reader.html  ... okay
15:12:59 <ski> accel : yes, for `ReaderT r m', `ask' is defined as `ask = ReaderT (\r -> return r)'
15:14:05 <ski> so, under the covers, `ask' is just a function that when passed the current environment, will give an action that does nothing, and gives the current environment back
15:15:48 <periodic> accel: you're only on chapter 3, right?  What are you doing in chapter 19?
15:16:00 <accel> periodic: no, I went to chapter 7
15:16:11 <ski> (`ask' is a class method, so it is specified in a class `MonadReader' .. but there's an instance for `r',`ReaderT r m')
15:16:17 <periodic> Monad transformers is chap. 18.
15:16:24 <periodic> I know, I read that chapter about 10 times.
15:16:25 <accel> ski: could you rewrite preservingColor int erms of >>= and >> ?
15:16:27 <periodic> :P
15:17:03 <accel> ski: that, plus me drawing out the transforms via the ReaderT amcos will clear this up, I'm still baffled how preservingColor works
15:17:12 <accel> periodic: http://hpaste.org/43865/using_an_environment
15:17:16 <accel> periodic: join the fun :-)
15:17:22 <nostrand> Could not find module `Control.Monad.Trans.Writer':
15:17:22 <nostrand>       It is a member of the hidden package `transformers-0.2.1.0'
15:17:26 <ski> @undo preservingColor action = do currentColor <- ask; a <- action; GL.color currentColor; return a
15:17:26 <lambdabot> preservingColor action = ask >>= \ currentColor -> action >>= \ a -> GL.color currentColor >> return a
15:17:27 <nostrand> why is that?
15:17:29 <ski> accel : ^
15:17:32 <periodic> accel: not much else to do here this afternoon. 
15:17:38 <c_wraith> nostrand: you have mtl and transformers installed.
15:17:39 <accel> ski: cool; thanks
15:17:45 <c_wraith> nostrand: just hide one or the other of them
15:18:00 <nostrand> c_wraith: ah, thanks. How? ;)
15:18:18 <monochrom> "ghc-pkg expose x" and "ghc-pkg hide y"
15:18:22 <c_wraith> nostrand: to do it long-term, use ghc-package hide"
15:18:29 <c_wraith> err, yes.  ghc-pkg
15:18:36 <nostrand> c_wraith: just found that option =)
15:18:44 <accel> ski: alright, so ask takes no arguments ... where does it retrieve the monad environment from?
15:18:49 <monochrom> dr jekyll and mr hide
15:18:51 <nostrand> thanks monochrom =)
15:18:55 <accel> ski: is there only one monad environment?
15:19:06 <ski> (periodic : see <http://hpaste.org/paste/43860/using_an_environment#p43865> for the context of that)
15:19:27 <periodic> accel: from the outermost monad.  You have to use lift if you want to take it in a few layers.
15:19:29 <ski> (periodic : oh, and <http://hpaste.org/43862/accel>)
15:19:37 <accel> fuck
15:19:42 <kmc> ask doesn't really do anything
15:19:44 <accel> I feel like Im lost + wasting ppl's time.j
15:19:46 <kmc> the plumbing is in (>>=)
15:19:52 <kmc> reader monad is maybe not the simplest one
15:19:53 <accel> Let me read those moand chapters, then I'll be back in a few hours.
15:20:00 <ski> accel : `ask = ReaderT (\r -> return r)'
15:20:01 <kmc> start with the Maybe monad
15:20:02 <periodic> ski:  I remember the original.  He's come a long way since then.
15:20:16 <kmc> and ask yourself "how does Just know to return success"
15:20:21 <ski> accel : so, "secretly" `ask' is a function that when *given* the current environment will ..
15:20:26 <accel> so basically chapters 14, 15, and 18 in RWh right?
15:20:31 <c_wraith> accel: don't worry, the reader monad, and monad transformers...  not the easiest things to really grasp.  Don't worry if you don't grasp them immediately
15:20:34 <accel> hmm
15:20:36 <kmc> and then look at (>>=) instead
15:20:41 <accel> ski: current environment == World ?
15:20:58 <periodic> accel: if you're in Reader st a, then the environment is st.
15:21:01 <ski> accel : current environment, in this case, is something of type 'GL.Color3 Double'
15:21:03 <periodic> world is the environment for IO.
15:21:06 <periodic> sorta...
15:21:21 <monochrom> Phil Wadler's http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf is still the best monad tutorial
15:21:38 <ski> accel : because that's the first type argument in `ReaderT (GL.Color3 Double) m'
15:22:10 <ski> accel : in `ReaderT r m' (and in `Reader r' as well), `r' is the type of the "environment" that is kept track of, by these monads
15:22:11 <accel> ski: your patience is amazing
15:22:19 <accel> ski: let me bug you again after I've read through these chatpers
15:22:29 <kmc> Reader actions (and State actions) are secretly functions
15:22:29 <accel> I feel like I'm trying to build a helicopter with rocks and sticks
15:22:38 <kmc> "secretly" = "under a newtype wrapper, which >>= unwraps"
15:22:44 <ski> accel : in your case, `r' is the type 'GL.Color3 Double', simply because that's what we wanted to hide under the covers
15:22:56 <kmc> that's how actions like "ask" and "modify" have access to what looks like implicit state
15:23:01 <periodic> > runReaderT (ask >>= liftIO . print) (15)
15:23:02 <lambdabot>   Ambiguous occurrence `liftIO'
15:23:02 <lambdabot>  It could refer to either `Control.Monad.IO.C...
15:23:10 <periodic> oh, boo.
15:23:12 <kmc> they're really functions that take the state as a parameter
15:23:37 <kmc> accel, one important thing to realize is that, in Haskell, the type "M a" need not have anything to do with the type "a"
15:23:37 <ski> periodic : `World' is more like the *state* for `IO' ..
15:23:56 <kmc> it could be a wrapper for "a" or "a -> Char" or even "Int -> Bool" (ignoring the 'a' parameter entirely)
15:24:09 <periodic> accel: I do really suggest reading through chapter 10 then chapter 14 maybe.
15:24:37 <periodic> It will show you the pattern that the state/reader/writer monads are abstractions of.
15:24:54 <companion_cube> accel, relax, monad transformers are not trivial... you should try to understand well monads before
15:25:14 <periodic> Basically, it shows you might end up with a bunch of functions that are "state -> (state, output)"
15:25:31 <ski> (.. if only)
15:25:33 <periodic> meaning they are functions that take some state and use it to produce some value and maybe create a new state.
15:25:40 <companion_cube> i found Maybe and List monads simpler to understand than Reader, Writer or State
15:25:56 <periodic> And you can chain those together, so the output state of one function is used as the input state of another.
15:26:13 <periodic> Then you can sort of monad-ify it and it becomes just "M output"
15:26:33 <periodic> it's just one type of monad, but it made state/reader/writer make more sense for me.
15:26:38 <homekevin> Could you write the 'true' and 'false' programs without monads?
15:27:04 <periodic> homekevin: you'd still have to use IO.
15:27:20 <homekevin> For exit codes?
15:27:21 <ski> homekevin : what does "without monads" mean ?
15:27:27 <monochrom> I can write a false prophet without monads
15:27:42 <periodic> homekevin: well, the function main has the type "IO ()", which is a monad...
15:27:43 <ski> homekevin : would  main = putStr (repeat 'y')  be ok ?
15:27:46 <homekevin> I don't really know, ski. I don't even understand monads yet.
15:27:55 <ski> (`IO ()' is not a monad. `IO' is a monad)
15:28:13 <periodic> ski: right, I should say it uses a monad.
15:28:21 <homekevin> ski: I think you are thinking of the 'yes' program, maybe
15:28:33 <ski> you could say `main' is a monadic action (more specifically, an `IO'-action)
15:28:43 <ski> homekevin : oh, you're right
15:28:43 <periodic> I think true would be "main = return ()"
15:28:49 <ski> *nod*
15:29:20 <homekevin> But if there's no flexibility in main's type, I think the answer to the question I meant to ask is "no"
15:29:40 <monochrom> main = exitSuccess / exitFailure
15:29:43 <periodic> homekevin: you can write things in GHCI which don't use monads.
15:29:52 <ski> (actually, the type of `main' can be `IO a', for any type `a' .. not that i think this is really useful)
15:30:03 <periodic> it will implicitly call print on the output, but you won't actually have to touch a monad yourself.
15:30:22 <periodic> ski: oh, I assumed it was IO ().  I guess I never checked.
15:30:26 <kmc> homekevin, if you're just doing IO, the fact that IO is a monad is entirely irrelevant
15:30:27 <homekevin> Touching a monad sounds dirty
15:30:39 <kmc> understanding monads is neither necessary nor sufficient for doing IO
15:30:48 <monochrom> imonad touch
15:30:48 <periodic> homekevin: just don't touch _|_.
15:30:51 <oc> touching your monad
15:31:01 <kmc> it's kind of like asking "can you add 2 and 2 without using Show"?
15:31:08 <kmc> true, Int is an instance of Show, but that's irrelevant
15:31:10 <oc> my functor touched…
15:31:18 <ski> periodic : hm .. should `evaulate' be renamed to `touch' ?
15:31:29 <Guest1779> I'm trying to install Haskell Platform on Mac OS but I keep getting an "installation failed" message and saying I should contact the manufacturer.  Is there any way to get more verbose error reporting so I can figure out why it's failing?
15:31:45 <mzero> have you installed Xcode?
15:31:48 <oc> Guest1779: using brew?
15:31:51 <periodic> Guest1779: does running the installer in a terminal give any better output?
15:31:52 <kmc> if you write "main = exitWith ExitSuccess" then you've written "true" without calling anything overloaded on Monad
15:31:59 <accel> http://book.realworldhaskell.org/read/monads.html <-- where is the actual source code for logger.hs? :-)
15:32:03 <accel> I want to see how record is defined
15:32:24 <Guest1779> mzero: Yes, Xcode is installed.
15:32:38 <periodic> accel: it's in that chapter, right?  It's spread out though.
15:32:42 * hackagebot darcs 2.5.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.5.1 (GaneshSittampalam)
15:32:46 <Guest1779> periodic: I haven't tried the terminal yet.  I didn't know if this was a known issue or something.
15:32:48 <accel> periodic: ah, foudn it now
15:32:53 <mzero> and you are installing the two installers in the right order, right? GHC first, then HP
15:33:20 <mzero> installing from a terminal won't give you any more detail than looking in the logs (via the Console application) will, I think
15:33:27 <ski> homekevin : see what kmc said above
15:33:31 <periodic> Guest1779: I've only installed it on OS X once, so I don't know the details.  That's just usually the first thing I try when I don't get a good error message.  "open Installer.app"
15:34:46 <Guest1779> mzero: It looks like GHC wasn't installed.  I uninstalled the old one and then got sidetracked and never installed the new one.  Thanks for the tip, all is well now.  :)
15:35:17 <mzero> woot
15:35:34 <mzero> next version of HP for Mac OS will feature only one installer --- so you can't forget!
15:37:02 <Guest1779> mzero: One installer is always nice.
15:38:02 <monochrom> eh?! this reminds me. tomorrow is supposedly the next version of haskell platform!
15:38:07 <mm_freak> kmc: main = return ()
15:38:36 <mm_freak> or for even shorter code: main = return 0
15:38:47 <monochrom> uses "return" which is from Monad and we were trying to golf it away
15:38:58 <mm_freak> well
15:39:01 <mm_freak> main = pure 0
15:39:05 <kmc> right
15:39:08 <monochrom> haha
15:39:09 <mzero> well - tomorrow dons (and others) start chugging on it to get it out.  I won't have the Mac OS installers ready until Sunday
15:39:17 <kmc> it wouldn't be unreasonable or unsafe for System.IO to export returnIO and bindIO or such
15:39:30 <shachaf> mzero: I heard dons was coming to the Hackathon.
15:39:30 <kmc> being whatever primitives it uses to implement return and (>>=)
15:39:41 <mzero> he is!
15:39:51 <mzero> as are 70 other people! 
15:39:57 <shachaf> 70?
15:39:57 <kmc> where's the hackathon?
15:40:01 <mzero> well - that's how many are signed up - we'll see who shows
15:40:08 <mzero> in Mtn. View, California
15:40:09 <shachaf> kmc: Mountain View, CA.
15:40:14 <kmc> fun times
15:40:15 <kmc> when?
15:40:16 <companion_cube> what's the hackaton ?
15:40:19 <shachaf> kmc: Tomorrow.
15:40:20 <companion_cube> +h
15:40:21 <kmc> heh
15:40:24 <shachaf> kmc: You should come!
15:40:25 <kmc> i won't make it, then
15:40:33 <shachaf> It goes on until Sunday.
15:40:56 <mzero> details: http://haskell.org/haskellwiki/BayHac2011
15:41:12 <shachaf> mzero: Were you at bahaskell yesterday?
15:41:23 <mzero> nope
15:44:05 <companion_cube> the yices EDSL seems interesting :/
15:44:42 <copumpkin> which one?
15:44:48 <copumpkin> also, ##smt :)
15:44:57 <copumpkin> the land of everything SMT!
15:45:28 <spanish_horse> copumpkin: stfu
15:45:36 <spanish_horse> that sounds so cheesy and stupid
15:45:40 <spanish_horse> "the land of everything SMT!"
15:45:42 <spanish_horse> just stfu, pls
15:45:44 <copumpkin> spanish_horse: o.O
15:45:51 <periodic> So, HP only supports OS X 10.5 and up now, eh?
15:46:02 <copumpkin> spanish_horse: please be cordil
15:46:02 <periodic> My laptop I was going to bring to the hackathon is still running 10.4...
15:46:05 <copumpkin> cordial, even
15:46:18 <periodic> Guess I'll use ssh liberally...
15:46:23 <shachaf> periodic: Just install a different OS on it.
15:47:00 <periodic> shachaf: Last time I tried Ubuntu I couldn't get the kernel to boot, but that was years ago...
15:47:22 <shachaf> periodic: The person sitting next to me is running Ubuntu on a Mac Mini.
15:47:37 <shachaf> periodic: So apparently it's possible on some hardware nowadays, at least.
15:47:52 <periodic> I know they've improved it.  I had a MacBook Air at my last job and got ubuntu running on it.
15:48:09 <periodic> My laptop is a 2006 model I think.  No one tries to support it anymore. :(
15:48:16 <periodic> oh how fast technology changes.
15:48:24 <shachaf> Or run a VM. :-)
15:48:26 <periodic> Maybe I'll give it another shot tonight. 
15:48:27 <shachaf> Ah, maybe not.
15:48:37 <periodic> Schmallon: why run a VM when I can just SSH into whatever system I need?
15:48:43 <periodic> oops, wrong auto-complete.
15:48:57 <Schmallon> :)
15:48:58 <shachaf> perlite: Fair enough, I suppose.
15:49:06 <periodic> sorry, Schmallon.
15:49:12 <shachaf> There, we're even.
15:49:28 <periodic> I have a VPS I can use, or I can throw up an EC2 micro.
15:49:43 <periodic> well, maybe not micro... those things are slow to compile...
15:54:30 <periodic> Yes! I get to do manual QA for the rest of the day!
15:54:56 <accel> for Monads, since a Monad is just a type constructor, is it important to keep the accessors to the Monad type private?
15:55:16 <accel> i.e. in IO a = (World, a) ... it's really important that one can't retrieve the World/a fields directly right?
15:55:16 <periodic> accel: it can be handy for creating a coherent interface and enforcing decoupling.
15:55:36 <periodic> It's like defining public/private functions in OOP.
15:56:17 <periodic> if you have a library, it is very helpful to hide the implementation details, because then you're free to change things without breaking them.
15:56:53 <periodic> If I want to switch my library from using Strings to ByteStrings for efficiency, I don't want to break all the code out there because it expects the internal type to be a data structure with a String record.
15:57:00 <shachaf> accel: IO a isn't (World, a) by any reasonable representation.
15:57:04 <accel> for libraries, it's nice
15:57:12 <accel> but for Monads, it's _necessary_ isn't it?
15:57:24 <accel> shachaf: why not? i'm pulling that model from Simon Peyton Jone's awkward squard paper
15:57:47 <shachaf> "awkward squared"
15:58:02 <accel> squad
15:58:10 <periodic> sqrd
15:59:18 <shachaf> accel: He gives type IO a = World -> (a, World)
15:59:24 <shachaf> accel: Which is veryh different.
15:59:41 <accel> ah
15:59:44 <accel> good call :-)
16:03:11 <ski> accel : for any type, it can be important to keep the "accessors" private, to ensure invariants are kept (i.e. implementing subtypes and quotient types)
16:03:27 * sm uploads https://github.com/simonmichael/graphics-drawingcombinators-example : g-d adapted to build on mac OSX
16:04:00 <accel> ski: in a pure language, why can't types be 'naked' ?
16:04:12 <ski> what does "naked" mean ?
16:04:23 <periodic> I think he means that there may be invariants that need to be preserved for the code to work.
16:04:24 <geheimdienst1> ski, not wearing clothing
16:04:33 <ski> geheimdienst1 : thank you
16:04:58 <periodic> for example, if you had some weird type with a list and an integer which is supposed to track the length of the list.  If people go just add to the list, you might have issues later allocating the correct size bytestring because you expected the integer to match the lenght.
16:05:24 <accel> periodic: but you can't modify the datatype
16:05:32 <accel> so in C++/Java, there are private members
16:05:37 <accel> because we don't want ppl writing to them
16:05:41 <periodic> I thought we were talking about the internal accessors though?
16:05:55 <accel> I'm thinking about record members
16:05:59 <accel> are we discussing the same thing?
16:06:10 <periodic> e.g. if you have a function "add :: a -> List a -> List a"
16:06:16 <accel> go on
16:06:33 <periodic> and "data List a = List { length :: Integer, data :: [a] }"
16:07:03 <ski> accel : consider `newtype Natural = PromiseNonNegative Integer', we don't want to expose the `PromiseNonNegative' constructor, because we want to ensure that only non-negative `Natural's are constructed (so we're making a subtype of `Integer', represented as `Integer')
16:07:16 <periodic> you don't want someone writing "somethingThatDependsOnLength $ myList { data = [1,2,3] }"
16:07:27 <ski> accel : but we can of course expose a `toNatural :: Integer -> Maybe Natural' operation
16:07:27 <periodic> Assuming myList was already in scope as a List a
16:08:16 <accel> periodic ski : okay, you guys are right; I'm wrong. thanks for the clarification
16:08:40 <periodic> accel: the other approach is just to document it and tell people it's their fault if they break it.
16:08:47 <periodic> or just not document it and blame them anyway...
16:08:53 <periodic> but then you'd have very few users.
16:09:20 <ski> accel : another example, `data Rational = Divide Integer Integer', here we want the second `Integer' to not be `0', as well as consider `Divide 3 4' as the same as `Divide 9 12', so we can't expose the constructor here either. (this is making a quotient type)
16:09:24 <shachaf> Or just not document it and take the blame yourself when it breaks.
16:09:51 <accel> shachaf: I prefer not documenting it, and not being around when someone is looking for someone to blame.
16:09:59 <FunctorSalad> does a StrictList type make any sense? my aim is to catch exceptions at the right time, not performance
16:10:05 <ski> accel : then on top of making subtypes and quotient types, there's also the issue of decoupling interface from implementation, so that one can change the implementation without changing the interface
16:10:23 <periodic> I thought the point of haskell was to make things provably correct in the type system and then blame GHC when it breaks.
16:10:26 <FunctorSalad> guess I could just use one of the arrays ;)
16:10:37 <accel> periodic ski : this is cool, I'm learning haskell for the guarantee of (1) types and (2) purity; I didn't realize it can be purshed further to make more guarantees on the program sttate
16:10:58 <periodic> accel: This is done in any language though. What languages have you learned in the past?
16:11:44 <periodic> My current example is Java, where it's traditional to have private vars and public getters/setters. That way you can enforce a little extra logic instead of having people go in and set the object to an invalid state.
16:11:48 <accel> periodic: c/c++/x86assembly/scheme
16:11:53 <FunctorSalad> (I know I could use rnf, but it seems better to have the types guarantee things than remember to put rnf everywhere)
16:12:42 <periodic> accel: so it would be like in C++ where you have a private member variable and a public getter/setter.
16:13:09 <periodic> It's the same system of maintaining a valid state in the object for things that aren't captured in the types.
16:13:55 <periodic> anyway... I'd focus on understanding haskell in one file first. :P
16:14:00 <periodic> That's what I'm working on.
16:14:34 <Adman65> Hey guys
16:15:58 <periodic> hey, Adman65 
16:15:59 <monochrom> indeed Data.Map and ByteString etc are all examples of using private data so you can't create an invalid map or bytestring.
16:16:29 <periodic> the nice thing about that abstraction is then when you build on the library you don't have to worry about it, because all of that logic is enforced by the interface.
16:16:39 <Adman65> what you would guys recommend for someone trying to learn haskell?
16:16:44 <periodic> I like to think about as little as possible.
16:16:59 <periodic> Adman65: get it installed and start reading Real World Haskell or Learn Yourself A Haskell
16:17:03 <monochrom> even ST and IO are like that
16:17:40 <periodic> Adman65: for installation, lookup the Haskell Platform http://hackage.haskell.org/platform//
16:17:57 <periodic> huh, double // at the end there...
16:18:13 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
16:18:27 <periodic> Adman65: then come back here and ask questions when you're confused.
16:18:34 <accel> chapter 14 is impsosible to read
16:18:40 <accel> I can feel my brain cells comitting sepaku
16:18:49 <periodic> Adman65: if you're in the Bay Area you can come to the haskell intro class in Mountain View on Saturday.
16:18:58 <Adman65> o really
16:18:59 <accel> hopefully it's all the dumb ones dying to form smarter ones
16:19:05 <Adman65> link?
16:19:07 <periodic> accel: by the third reading all the weak cells will be dead and you'll start making progress.
16:19:21 <homie> lol
16:19:21 <accel> periodic: perhaps alcohol can speed up this process
16:19:27 <periodic> Adman65: http://wiki.hackerdojo.com/w/page/32992961/Haskell-Hackathon-2011
16:19:31 <ski> accel : re blame : "Well-typed programs can't be blamed" at <http://homepages.inf.ed.ac.uk/wadler/topics/blame.html#blame-esop> by Philip Wadler,Robert Bruce Findler in 2009
16:19:50 <ski> @where blame
16:19:51 <lambdabot> I know nothing about blame.
16:20:04 <ski> @where+ blame "Well-typed programs can't be blamed" at <http://homepages.inf.ed.ac.uk/wadler/topics/blame.html#blame-esop> by Philip Wadler,Robert Bruce Findler in 2009
16:20:04 <lambdabot> I will remember.
16:20:16 <accel> here's what I don't get; why does the state moand not contain state, and instead merely contains a function s -> (a, s) ?
16:20:32 <periodic> accel: s is the state
16:20:41 <ski> accel : a state monad action is a state *transformer*
16:21:03 <monochrom> state transition function
16:21:04 <ski> accel : *given* any current state, it produces the next state, together with a result value
16:21:30 <accel> hmmm
16:21:39 <accel> and an IO Monad is a _WORLD transformaion_ function?
16:21:55 <monochrom> very approximately
16:22:00 <ski> accel : consider e.g. the function `modify (+ 1) :: State Integer ()', this adds one to the current state .. in itself, though, it doesn't contain the `Integer' state which is to be incremented
16:22:35 <ski> it only contains a transformation/function that tells how to transform *any* given input state
16:23:27 <ski> accel : s/IO Monad/IO Monad action/
16:23:35 <periodic> I have trouble now that I think about just about everything as transformations.
16:23:39 <ski> @type getLine
16:23:40 <lambdabot> IO String
16:23:41 <periodic> Doesn't translate well to stateful OOP.
16:23:45 <monochrom> observe how imperative programming is just functional programming if you omit I/O. the C code "x=y+1" is a function from old state to new state.
16:23:48 * shachaf wishes the word "monad" was just banned from this channel.
16:23:50 <xplat> the >>=s and dos stick together all the state transformers into one big transformer
16:23:51 <ski> `getLine' is *not* "an IO Monad"
16:24:00 <ski> `getLine' is an `IO'-*action*
16:24:10 <xplat> and then runState finally applies it to an actual state
16:24:39 <accel> ski: ah, IO String = IO Action = World Monad ?
16:24:50 <accel> X Monad = function that transforms X and produces a result?
16:24:59 <ski>   writeIORef x =<< liftM (+ 1) (readIORef x)
16:25:01 <accel> no, Monad m = m a -> ( a -> m b) -> m b
16:25:04 <xplat> shachaf: i don't think things would be any better if people said 'burrito' or 'spacesuit' instead
16:25:22 <monochrom> and the C code "y=z*z; x=y+1" is function composition. surprise! you have been doing pointfree programming all along, never writing out the pervasive old-state-parameter and the new-state-return-value.
16:25:31 <accel> xplat: i would feel better if we called it kthxbye
16:25:36 <periodic> I have some AI code in a project of mine that returns a set of state transformations that represent the desired action it wants to take.  So it returns something of type "World ()" but it isn't actually in the World monad.  it's in a different monad that represents the AI's perception of the world.  Then I can just run that transformation against the actual state of the simulated world.
16:25:38 <ski> accel : `IO String' is a type. any *value*, having that type, can be called an `IO'-action
16:25:45 <shachaf> xplat: At least they wouldn't be as wrong if they said that "getLine is a burrito".
16:26:05 <xplat> shachaf: technically they would be even more wrong
16:26:18 <ski> accel : a monad is a type, together with a couple of operations associated with that type
16:26:27 <accel> newtype State s a = { runState :: s -> (a, s) }
16:26:47 <accel> so a "State s a" is basically a function :: s -> (a,s)  .... right?
16:26:55 <monochrom> yes
16:26:56 <periodic> basically.
16:26:57 <ski> accel : you can't pass around a monad, just like you can't pass around the type `Int' (as opposed to passing around a *value* *having* type `Int')
16:27:27 <shachaf> > gеtLine
16:27:28 <lambdabot>   burrito
16:27:46 <periodic> oh man, the debates we're going to have at the hackathon about monads during the sessions...
16:27:52 <shachaf> xplat: At least "a burrito" is a type.
16:27:53 <accel> returnState :: a -> State s a \n runState a = State $ \s -> (a, s) .... so returnState is a function, which on input "a", produces a "State s a"
16:27:54 <periodic> I better bring some burritos for demonstrational purposes.
16:28:10 <accel> now; bindState looks like black magic
16:28:11 <monochrom> and apple and orange
16:28:15 <shachaf> And a space suit.
16:28:20 <shachaf> And tiny chocolate robots, please.
16:28:25 <xplat> accel IO is a monad, IO Int is a type of IO actions, do { l <- getLine; return $ read l } :: IO Int is an IO action
16:28:30 <accel> bindState m k = State $ \s -> let (a, s') = runState m s in runState (k a) s'
16:28:31 <monochrom> bindState looks like passing parameters
16:29:00 <periodic> Ha, we should start the beginner Haskell session by holding a burrito aloft and saying "This is a monad! A monad is this!"
16:29:01 <accel> xplat: similarly, State is a monad; and State Double is a type of State actions?
16:29:19 <periodic> Then we can drive away all the newcomers and stay smug about not being mainstream.
16:29:20 <shachaf> accel: I'd suggest not thinking about "monads" until you've implemented a few.
16:29:25 <accel> periodic: this is SV? I might drop by
16:29:34 <accel> shachaf: I've implemented th Logger Monad, now working on the State Monad
16:29:36 <periodic> accel: Mountain View
16:29:44 <shachaf> accel: Just think: "How would I do State in Haskell?", and then write that.
16:29:51 <accel> periodic: when/where?
16:29:55 <xplat> accel: no, State Double is a type of state transformers
16:29:57 <shachaf> Tomorrow, Hacker Dojo.
16:30:00 <ski>   bindState m k = State foo
16:30:02 <ski>     where
16:30:04 <periodic> the beginner stuff is Saturday
16:30:05 <ski>     foo s0 = runState (k a) s1
16:30:07 <ski>       where
16:30:09 <ski>       (a, s1) = runState m s0
16:30:18 <ski> accel : ^ that's another way of writing it
16:30:23 * shachaf has no Haskell project to work on.
16:30:28 <shachaf> Someone propose something.
16:30:38 <monochrom> type explainer
16:30:48 <sbahra_> shachaf: Interested in writing some Haskell bindings for http://repnop.org/.ck/? :-P
16:30:50 <xplat> accel: the noun (actions/transformers) is particular to the monad they are associated with
16:31:14 <sbahra_> shachaf: Various MD atomics, lock-less data structures and SMR.
16:31:32 <accel> xplat: so action/transformer basically mean the same thing
16:31:39 <accel> xplat: i.e. they have no semantic difference
16:31:41 <sbahra_> Bindings are so fun!
16:32:08 <shachaf> sbahra_: It'll be released Nov 2010, yes?
16:32:14 <ski> accel : in this context, "transformer" is only used as in "state transformer"
16:32:15 <xplat> accel: 'actions' is generally used when the monad is used to encapsulate black magic in the runtime, like with IO and STM
16:32:33 <ski> `action' can be used with any monad
16:32:34 <accel> ski: okay; I thiNK I understnd this now
16:32:41 <sbahra_> shachaf: Clearly it isn't up to date, I'm still working on documentation.
16:32:56 <ski> (accel : there's also the term "monad transformer", which is not to be confused with the above)
16:32:57 <sbahra_> shachaf: Updated to reflect planned date.
16:33:22 <monochrom> "state transformer" is too pompous
16:33:36 <ski> "state transition", if you prefer ..
16:33:39 <sbahra_> (Real job called)
16:33:44 <xplat> accel: this is basically because it's the generic term, so it's used by default when the implementation is opaque
16:33:58 <monochrom> yes I prefer state transition. or even just write out function from old state to new state
16:34:04 * hackagebot highlighter 0.2 - source code highlighting  http://hackage.haskell.org/package/highlighter-0.2 (AlexSuraci)
16:34:09 <ski> xplat : as well as when being polymorphic
16:34:29 <xplat> accel: but a lot of monads have their own term, which as you can see people can't even always agree on
16:35:08 * ski recalls reading papers which defined `newtype ST s a = ST (s -> (s,a))', the `ST' standing for "State Transformer"
16:37:24 <xplat> ski: hasn't the ST constructor always been particular to when it's polymorphic in s and so you can use STRefs and so on?
16:37:34 <monochrom> different ST
16:37:44 <ski> yes, that `ST' is more recent
16:38:09 <xplat> hm, i didn't think people ever used ST for State ... i guess it's been too long since i looked over the older monads papers
16:38:10 <monochrom> you see the damage of using a pompous name. it tends to clash with other names.
16:38:27 <xplat> monochrom: non-pompous names have that problem too
16:39:07 <ski> @type Control.Monad.ST.stToIO
16:39:08 <lambdabot> forall a. ST GHC.Prim.RealWorld a -> IO a
16:39:20 <ski> ("non-polymorphic `ST')
16:40:05 <ddarius> ski: If by "more recent" you mean 1993 or so.
16:40:28 <monochrom> statistically non-pompous names have less of that problem, thanks to human beings' tendency to over-glorify their ideas by glamorous naming
16:41:02 <accel> alright; since I like pain & suffering, time to read chapter 15
16:41:18 <ddarius> monochrom: I'll call that the Pompousity Prediction Principle.
16:41:35 <sbahra_> shachaf: Well, if there's interest, you can reach me on IRC for a snapshot before a release. The bindings are something I'd like to do down the road.
16:42:33 <monochrom> people get excited and think "no, mere 'function' doesn't do justice to my deep insight, I must call it 'transformation'". Well, since every else does that, no one will compete with me for the use of the word 'function'.
16:43:49 <lowasser> Would anybody be interested, out of curiosity, in the following extension of record syntax: when a field is a function, and we're doing a record expression, allowing the field to have an LHS, like so: Foo{bar x y = something y x}
16:44:21 <xplat> if categorists liked plain naming when they tried it, we'd be talking about the 'IO triple'
16:44:29 <aavogt> lowasser: is    Foo{ bar = \x y -> something y x } much worse/different?
16:44:37 <ski> lowasser : imo, that would be very nice
16:44:51 <ski> aavogt : loss of multiple equation matching
16:45:06 <lowasser> ski: I'm assuming we're only allowing one equation
16:45:13 <ski> .. why ?
16:45:16 <lowasser> (though that could be cool)
16:45:17 <aavogt> at the same time that space might be nice for a function which computes a record label
16:45:28 <aavogt> or could be confused with such
16:45:35 <monochrom> at least we don't speak like "IO presheafification"
16:45:48 <lowasser> the whole point of record syntax is to make things nice
16:45:49 <xplat> there's definitely no worthwhile advantage for one equation, because of what aavogt said
16:46:05 <lowasser> I'm not convinced, actually, even in the case aavogt considers
16:46:15 <ski> lowasser : yes .. but the field vs. field accessor dichotomy isn't nice
16:46:40 <lowasser> yeah, I knoes
16:46:40 <ddarius> monochrom: I know what the sheafification functor does, but what would a presheafification functor do?
16:46:51 <monochrom> I don't know
16:46:55 <ski> lowasser : imo, it doesn't make sense to say `data Foo = MkF {bar :: Bar,...}' but then have `bar :: Foo -> Bar'
16:47:07 <lowasser> wait, that's not what I'm saying at all
16:47:09 <lowasser> oh
16:47:13 <lowasser> well, yes
16:47:14 <ski> either `bar' should have type `Bar', or it should have tyoe `Foo -> Bar'
16:47:43 <lowasser> I claim that record syntax satisfies the claim "you know what I mean"
16:47:53 <lowasser> redundant claim is redundant
16:47:54 <xplat> or it should have type Lens foo bar
16:48:03 <xplat> er, Lens Foo Bar
16:48:07 <ski> i.e. either we should change the syntax for accesing fields, or we should change the syntax for constructing and updating records
16:48:28 <lowasser> I'm going to come out against any changes in that respect, actually
16:48:31 <ski> xplat : yea, that's similar to `Foo -> Bar' :)
16:49:05 <lowasser> I think the current approach goes for the most natural *syntax*,  even if it's not the most natural semantics
16:50:34 <xplat> the current syntax makes haskell into a lisp-2 :)
16:50:53 <lowasser> and given that records are pretty much syntactic sugar in the first place, I think it's okay to focus on making the sugar as sweet as possible
16:51:08 <ski> OCaml has `aFoo #bar', for accessing the `bar' field of `aFoo', e.g.
16:51:25 <lowasser> anyway. all of this is beside the point
16:51:34 <ski> lowasser : i don't agree about most natural syntax ..
16:52:04 <lowasser> I'm not interested in arguing about Haskell's decisions on accessors vs. setters =P
16:52:22 <xplat> the problem with the current record syntax is it desugars to something way too far from the sugar
16:52:35 <lowasser> right now I'm just interested in making a small change to setters, in the case where the field is a function
16:52:39 <lowasser> that's really all I'm interested in
16:52:47 <accel> @src liftM
16:52:47 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:52:52 <ski> one problem with the current record syntax is that it is painful to do nested updates
16:53:00 <accel> :t liftM
16:53:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:53:05 <xplat> there are abstraction opportunities that are apparent in the syntax but don't actually exist at the semantic level
16:53:14 <accel> liftM = run this pure function in this monad?
16:53:22 <ski> xplat : elaborate ?
16:53:23 <lowasser> ::sigh:: I'm going to leave now and come back after y
16:53:29 <lowasser> y'all are done having this argument =P
16:53:37 * ski smiles
16:54:04 <accel> :t liftM2
16:54:05 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:54:09 <accel> :t liftM3
16:54:10 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:54:21 <xplat> lowasser: how dare you!  we're trying to paint a bike shed here!
16:54:26 <ski> accel : `liftM f ma', create a new action, that when run, runs `ma', and calls `f' on the result
16:54:44 <shachaf> accel: Monads have nothing to do with purity.
16:54:53 <monochrom> @quote monochrom polymorphi
16:54:55 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
16:55:15 <ski> shachaf : well, see "Reflecting Monads" by Andrzej Filinski ..
16:55:47 <xplat> ski: the connection between foo { bar = baz } and bar foo is purely syntactic, the 'bar' in the first one doesn't refer to any entity at all, never mind the same entity as the second
16:55:59 <monochrom> Filinski's reflecting and reifying monads is easily implemented in sml but not so easily in haskell
16:56:08 <ski> xplat : yes, and that's the problem
16:56:48 <ski> xplat : presumably `=' was used for a reason there .. i'd prefer to be able to interpret `bar = baz' as a logical statement
16:57:06 <xplat> ski: so you'd think you could abstract a bunch of settings and gettings of 'bar' over 'bar' but there is no 'bar'
16:57:12 <spanish_horse> sbahra_: let's be friends, i can teach you about x86 assembly, and you can teach me about haskell
16:57:25 <ski> (this is also why i'm uncomfortable with patterns which can't be interpreted as expressions)
16:57:32 <sbahra_> spanish_horse: haha
16:57:48 <ski> xplat : but there *ought* to be :)
16:57:55 <sbahra_> spanish_horse: I would ask the same of other people. :-)
16:58:12 <accel> ho ho ho; the reader monad is in  hapter 15
16:58:18 <spanish_horse> sbahra_: i prefer you because i have the same poweful feelings stirred by the eruptions in egypt as you do
16:58:26 <spanish_horse> sbahra_: we are both people of the book, and i am a son of allah
16:59:17 <ski> xplat : anywa, elaborate on "abstraction opportunities that are apparent in the syntax but don't actually exist at the semantic level" ?
16:59:24 <sbahra_> spanish_horse: Sorry, I definitely know more about IA32 than I do Haskell. :-)
16:59:35 <sbahra_> spanish_horse: Actually, I'm agnostic, but that is off-topic.
17:01:25 <xplat> ski: well, that is pretty much what i did.  maybe it's a less impressive concept than it sounds like ...
17:01:58 <kyl> hi, i'm trying to parse some data with data.binary, but if i try to read a lazy bytestring of a specific length then print it, it says there are ``too few bytes''.  any solutions? (http://pastie.org/private/jgmr0i0g0cokzyehsbemg)
17:02:08 <xplat> i would like to be able to do things like compute record fields and use them in an update, though
17:02:11 <ski> i'm not sure of what abstraction opportunities you were referring to ..
17:02:25 <ski> .. maybe ones which abstract over which field they operate on ?
17:02:38 <ski> hm
17:02:55 <ski> i suppose this is something that lenses sortof do
17:03:03 <xplat> ski: yes.  and also, you can currently pass a field to a function, but then the field for update falls apart from the field for access
17:03:32 <ski> well, what happens is that you only pass the field accessor function, as a function value
17:03:40 <xplat> lenses solve that, but unfortunately the compiler won't build them for you
17:03:41 <ski> (unless you pass a lense)
17:04:11 <xplat> ski: yes, 'bar' and 'bar' look like the same thing, but they are really two things that just happen to have the same name
17:04:13 <ski> well, maybe we should nag GHC developers to build lenses, when asked ..
17:04:38 <roconnor> data.accessor.deriving will build lenses for you
17:05:51 <roconnor> http://hackage.haskell.org/package/data-accessor-template
17:05:57 <roconnor> sorry data.accessor.template
17:07:38 <accel> @src >>=
17:07:38 <lambdabot> Source not found. :(
17:07:40 <accel> :t >>=
17:07:41 <lambdabot> parse error on input `>>='
17:07:46 <accel> :t (>>=)
17:07:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:07:53 <accel> :t (>>= :: ReaderT)
17:07:54 <lambdabot> parse error on input `::'
17:07:59 <xplat> it seems like nested updates in record syntax should look like ‘foo { bar = 1, baz { quux = "o hai" } }’
17:08:27 <periodic> I've been using fclabels for my accessors/mutators.  Similar to data.accessor.deriving?
17:08:42 <roconnor> periodic: yes, but better
17:08:44 <roconnor> ... mostly
17:08:46 <periodic> better!
17:08:50 <roconnor> yes
17:08:57 <periodic> crap, time to upgrade my code again!
17:08:57 <ski> @src ReaderT (>>=)
17:08:57 <lambdabot> Source not found. My pet ferret can type better than you!
17:08:59 <roconnor> more integration with MonadState
17:09:20 <xplat> hm, yes, that aspect is helpful
17:09:41 <roconnor> periodic: if you don't need integration with monad state you are not missing much
17:09:47 <ski>   ReaderT r_ma >>= a_rmb = ReaderT (\r -> r_ma r >>= \a -> runReaderT (a_rmb a) r)
17:09:52 <roconnor> granted integrating with monad state is fairly common
17:10:19 <ski>   (>>=) :: Monad m => ReaderT r m a -> (a -> ReaderT r m b) -> ReaderT r m b
17:10:23 <xplat> when i wrote my own front end to some scala json library i got a lot of mileage out of integrating with the state monad
17:12:06 <ski> xplat : yes, as opposed to the current `foo { bar = 1,baz = (baz foo) { quux = "o hai" } }'
17:12:09 <periodic> roconnor: well, I am actually using them a lot with a few StateT/ReaderT monads
17:12:47 <xplat> and that was pretty primitive, even.  i didn't have, for example, lifters
17:12:49 <periodic> plenty of `(get fieldName) <$> get`
17:13:05 <periodic> er.. wait, that's two gets...
17:13:09 <periodic> I must have one of the qualified...
17:14:57 <xplat> (a lifter would be like do { set foo 1; workUnder baz $ do { set quux "o hai" } }
17:16:41 <xplat> s/set/setField/g
17:19:24 <xplat> (as opposed to any of the many other things i could mean by 'lifters')
17:27:14 <mjkb> @pl \c -> ciChar c <?> "case-insensitive " ++ show str
17:27:15 <lambdabot> (++ show str) . (<?> "case-insensitive ") . ciChar
17:27:27 <mjkb> @pl \c -> ciChar c <?> "case-insensitive "
17:27:28 <lambdabot> (<?> "case-insensitive ") . ciChar
17:29:10 <kyagrd> GHC needs more fine grained control of extensions
17:29:36 <c_wraith> ...  Than per-file?  Really?
17:29:45 <kyagrd> Yeah
17:29:58 <BMeph> What, like multiple modules in a file?
17:29:59 <c_wraith> You can't just move whatever needs that extension into its own file?
17:30:21 <kyagrd> GADTs breaks many inferrable things with RankNTypes
17:30:22 <periodic> Seems like things would get confusing if one function uses an extension and then the next one doesn't.
17:30:49 <copumpkin> kyagrd: like what?
17:32:06 <djahandarie> periodic, that technically already happens with imported functions
17:32:16 <kyagrd> If you have a mendler-style catamorhism operator
17:32:31 <kyagrd> newtype Mu0 (f :: * -> *) = In0 { out0 :: f (Mu0 f) }
17:32:49 <kyagrd> mcata0 :: (forall x . (x -> b) -> f x -> b) -> Mu0 f -> b
17:33:17 <kyagrd> mcata0 s = s (mcata0 s) . out
17:33:39 <kyagrd> Then things kile really dumb function that is inferrable don't work
17:34:21 <kyagrd> For example, p'' :: Mu0 T -> (Mu0 T -> ())
17:34:39 <kyagrd> p'' = mcata0 phi where phi _ _ = const ()
17:35:03 <kyagrd> In this p'' function (without GADTs) GHC can infer the type of phi
17:35:14 <periodic> djahandarie: imported ones, sure.  I meant the implementation of two functions in the same file.  Where saying the exact same thing in two different contexts can mean very different things
17:35:18 <kyagrd> However when you turn GADTs on it requires you a type signature
17:35:37 <kyagrd> a really dumb one like phi :: a -> b -> c -> ()
17:36:11 <copumpkin> NoMonoLocalBinds ?
17:36:11 <copumpkin> fwiw I think it was a conscious decision
17:36:12 <kyagrd> Even though T is not a GADT datatype
17:36:25 <kmc> also GADTs now implies MonoLocalBinds
17:36:42 <kmc> er yeah copumpkin mentioned that
17:36:58 <djahandarie> :lag:
17:37:03 <kmc> and it's intentional; generalizing let bindings in the presence of type coercion kinds is apparently a real pain
17:37:17 <thoughtpolice> the simplest answer is just to give a generalized let binding the polymorphic type you want
17:37:22 <thoughtpolice> instead of just attempting to let GHC infer it
17:37:24 <thoughtpolice> because it won't anymore
17:37:44 <kyagrd> GHC does infer it when you don't turn on GADTs
17:37:56 <copumpkin> it's the MonoLocalBinds doing that though
17:38:02 <copumpkin> I guess you want the option to turn that off in certain contexts
17:38:04 <copumpkin> that aren't per-file
17:38:33 <kyagrd> So, one trick is to break down a module into two parts that use GADT and doesn't use GADT and put all the non-GADT stuff in that file and re-export
17:38:45 <c_wraith> Isn't that what I suggested? :)
17:38:55 <copumpkin> or just write the type annotation :P
17:39:01 <kyagrd> Well but it's kind of sad :(
17:39:05 <thoughtpolice> yeah, i don't see the big deal with writing the type signature normally
17:39:09 <spanish_horse> copumpkin: pls
17:39:19 <thoughtpolice> it's a small price to pay for the overhauled type checker, which can now correctly typecheck a lot more programs
17:39:26 <copumpkin> spanish_horse: you at it again?
17:39:30 <thoughtpolice> that involve things like GADTs and type families
17:39:37 <spanish_horse> copumpkin: ffs, PLS.
17:39:41 <kyagrd> The thing is GADTs break non-related things that has nothing to do with GADTs
17:39:52 <thoughtpolice> (and i've had a few bugs that caused ghc 6.12 to hang, that 7.0 gets right, so I'm fine with it personally)
17:39:58 <copumpkin> spanish_horse: pm please
17:40:01 <kyagrd> just because they are in same module and this is GHC 7
17:40:08 --- mode: ChanServ set +o copumpkin
17:40:08 <djahandarie> kyagrd, that is a little odd, true.
17:40:28 --- mode: copumpkin set +b spanish_horse!*@*
17:40:28 --- kick: spanish_horse was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
17:40:29 <djahandarie> Maybe MonoLocalBinds should be on by default ;)
17:41:08 <copumpkin> (http://hpaste.org/43871/spanish_horse_context)
17:41:18 --- mode: copumpkin set -o copumpkin
17:41:20 * hackagebot language-sqlite 1.0 - Full parser and generator for SQL as implemented by SQLite3  http://hackage.haskell.org/package/language-sqlite-1.0 (DanKnapp)
17:41:32 <codolio> SPJ wants to make it impossible to turn off, even.
17:41:32 <Bynbo7> o.O
17:41:42 <thoughtpolice> there's really a frighteningly small amount of code that uses generalized let bindings
17:41:49 <thoughtpolice> i think SPJ had some numbers in his paper on the matter
17:42:54 <kyagrd> So, it would be nice if that (No)MonoLocalBind can be turned on per-top-level-definition
17:43:26 <dolio> I don't think that's going to happen.
17:43:32 <kyagrd> Or yet another keyword letmono wheremono @.@
17:44:36 <dolio> letpoly would be your new keyword.
17:45:16 <djahandarie> Will be added shortly after let is seperated into let and letrec!
17:45:20 <Mathnerd314> so I propose an alternate method: desugar every let binding into a top-level definition
17:45:27 <copumpkin> kyagrd: SPJ definitely does not want polymorphic inferred local bindings
17:45:28 <thoughtpolice> i don't see why adding type signatures is a pain when people want to add keywords and split things into multiple modules and all this other crazy stuff
17:45:42 <thoughtpolice> unless adding a type signature is just an absurd burden
17:45:45 <thoughtpolice> for some reason, i doubt it is
17:46:07 <dolio> Inference of definitions is overrated.
17:46:08 <djahandarie> Maybe some of those cases would be solved with a -good- meta-language for Haskell
17:46:11 <copumpkin> has anyone here ever seen spanish_horse speak apart from the episode earlier today?
17:46:30 <thoughtpolice> considering that in return you get a typechecker that *can* correctly infer a lot more stuff and not break as much in the presence of multiple extension interacting
17:46:32 <accel> ski: i'm an idiot and lost the link to your paste
17:46:36 <thoughtpolice> like rankntypes, gadt's and type families
17:46:36 <accel> ski: do you still have it?
17:46:44 <kyagrd> I can bear annotating top level definitions but I would like to have local definitions to be inferred as much as possible
17:46:52 <djahandarie> copumpkin, his nice used to be 'teven' according to my logs
17:46:57 <djahandarie> nick*
17:47:06 <copumpkin> djahandarie: did (s)he ever say anything useful?
17:47:20 <kyagrd> GHC works pretty well with this as long as GADTs which implies NoMonoLocalBind isn't on
17:47:28 <djahandarie> copumpkin, before that it was banisterfiend...
17:47:30 <djahandarie> Coming together...
17:47:32 <copumpkin> oh okay
17:47:38 <copumpkin> now I feel much better
17:47:41 <djahandarie> :P
17:48:10 <copumpkin> preflex: seen banisterfiend
17:48:10 <preflex>  banisterfiend was last seen on #haskell 21 hours, 1 minute and 35 seconds ago, saying: dankna: that's ok you think that
17:48:19 --- mode: ChanServ set +o copumpkin
17:48:22 --- mode: copumpkin set +b banisterfiend!*@*
17:48:26 --- mode: copumpkin set -o copumpkin
17:48:28 <thoughtpolice> i think SPJ currently gives you the option to both say GADTs and NoMonoLocalBinds, but whether or not it works is 'up to debate' i think
17:48:33 <copumpkin> not that it'll stop him from trolling under another nick, but whatever
17:48:34 <dankna> he was addressing me?  I didn't even notice
17:48:45 <copumpkin> dankna: probably because there was no content
17:48:46 <thoughtpolice> "The -XGADTs or -XTypeFamilies pragmas switch on MonoLocalBinds but, if you want, you can override it with -XNoMonoLocalBinds (or the equivalent LANGUAGE pragma). The type checker will then do its best to generalise local bindings, and your program will almost certainly work. However, I don't know how to guarantee any good properties of the type inference algorithm. So I think this is ok as as short term fix, but I'd like to encourage you to add
17:48:51 <dankna> copumpkin: quite so
17:49:07 <thoughtpolice> from http://hackage.haskell.org/trac/ghc/blog/2010/9
17:50:04 <kyagrd> Oh, I can overrride it didn't know that
17:50:13 <kyagrd> thanks for mentioning it
17:50:15 <thoughtpolice> so, tl;dr you can do it, it's just not encouraged
17:50:27 <copumpkin> Mathnerd314: it doesn't work the same way
17:50:31 <copumpkin> Mathnerd314: the desugaring you propose
17:50:34 <thoughtpolice> i personally think it's a fair trade, but others are free to disagree of course.
17:51:04 <copumpkin> there's some kind of inference, that conor once described it as
17:51:04 <djahandarie> copumpkin, http://hpaste.org/43872/logs
17:51:06 <copumpkin> for local bindings
17:51:10 <Mathnerd314> copumpkin: you just add extra arguments... when does it differ?
17:51:39 <copumpkin> Mathnerd314: the inferred type in the where clause is affected by how you use it in the function owning the where clause. A top-level binding isn't
17:51:53 <copumpkin> or is it?
17:52:07 <copumpkin> I mean, is the inferred local type affected by the function use
17:52:11 <copumpkin> I'd expect it to be
17:52:51 <Mathnerd314> copumpkin: top-level bindings are inferred too (at least with NoMonomorphismRestriction)
17:53:08 <copumpkin> sure
17:53:10 <copumpkin> I don't mean that
17:53:49 <copumpkin> djahandarie: I feel better now :) "...and nothing of value was lost"
17:54:09 <xplat> well, unlike a top-level binding, a where binding can use (implicitly, or explicitly with ScopedTypes) a type the outer definition is polymorphic over
17:54:36 <copumpkin> hmm, that's not what I'm talking about either
17:54:41 <copumpkin> let me craft up an example
17:58:36 <copumpkin> hmm, can't think of one
18:05:09 <accel> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-HashTable.html <-- is this waht I want if I want a mapping from Strings to Objects ? or is there something faster?
18:05:31 <copumpkin> don't use HashTable
18:05:33 <copumpkin> use Data.Map
18:05:50 <accel> I'm certain you're right; but enlighten me -- why?
18:06:04 <copumpkin> hashtables aren't very functional structures
18:06:08 <copumpkin> they're based on arrays
18:06:22 <copumpkin> which means they can't be modified efficiently without doing so in place
18:06:27 <copumpkin> and we don't usually do things in place
18:06:42 <accel> hmm; what if I have a static hashtable
18:06:49 <accel> i.e. i build an array; then I convert it to a hashtable
18:06:57 <accel> and as a hashtable, I only do lookups, never writes
18:06:59 <accel> s/array/list
18:07:10 <copumpkin> it won't kill you
18:08:37 <accel> since insert is pure
18:08:43 <accel> this means the old map exists too right?
18:08:50 <copumpkin> yeah
18:08:54 <accel> got it
18:08:57 <accel> is it a red balck tree under neath?
18:09:07 <copumpkin> not quite, but it is a balanced tree
18:09:14 <c_wraith> no, it's something even less structured
18:09:32 <accel> okay, so it's O(log n) ...
18:09:40 <accel> why don't I want to use hashtable and get O(1) expected time?
18:09:42 <c_wraith> It's like...  A structure that goes out of its way to do absolutely minimal rebalancing while still maintaining O(log n)
18:09:53 <accel> so it's a lazy red black tree
18:09:55 <c_wraith> two problems.
18:10:07 <c_wraith> One, writes to a hashtable will be O(n)
18:10:11 <accel> is it basically what's covereted in purely functional data structures?
18:10:28 <accel> what's the 2nd proble?
18:10:48 <c_wraith> Two, hashing is probably slower than you think.
18:10:59 <accel> yeah; but hashing can be done in cache
18:11:06 <accel> whereas traversing a binary tree, you have to load shit from ram
18:11:22 <accel> hashing: burn the CPU, find where to jump in array
18:11:22 <c_wraith> until you actually determine it's a bottleneck, stop optimizing :)
18:11:53 <c_wraith> Unless your array holds something that can be unboxed, don't think an array lookup doesn't jump all over the place either
18:11:54 <accel> I ahve a CS degree and I want to show off my worthless book knowledge
18:13:53 <copumpkin> accel: to actually hash the value being passed in, you need to jump all over the place anyway
18:14:00 <copumpkin> i.e., your string
18:14:04 <accel> why?
18:14:05 <copumpkin> it's a singly linked list 
18:14:25 <copumpkin> you need to do a load of memory accesses to even read the list to compute your hash function
18:14:38 <accel> haskell strings are stored as a linked list?
18:14:45 <copumpkin> yeah
18:14:48 <copumpkin> a Data.Map using the lexicographic ordering on strings might not even have to traverse the entire list
18:14:56 <kmc> accel, binary trees suck for performance, but high-arity trees are good
18:14:57 <copumpkin> to compare two strings
18:15:14 <kmc> judy arrays make each node basically as big as will fit in one cache line
18:15:57 <kmc> also trees are good for pure functional update-by-slight-copy while hash tables are pretty much all or nothing
18:16:14 <accel> i still can't believe haskell strings are linekd lists
18:16:38 <blackdog> accel: you'd usually go straight to bytestrings now
18:16:42 <kmc> no no no
18:16:48 <kmc> ByteStrings hold Word8 not Char
18:16:56 <kmc> if you want to store text efficiently, use Data.Text
18:16:59 <djahandarie> I would generally go straight to String or Text
18:17:02 <blackdog> sorry, misspoke :)
18:17:16 <accel> haskell has all this black magic
18:17:19 <djahandarie> I like how Strings are lists still.
18:17:19 <accel> that I know nothing of
18:17:23 <kmc> sorry to yell at you in particular blackdog, but i see this lie about ByteStrings repeated all over
18:17:30 <blackdog> it probably made sense originally - you get all of the list functions for free
18:17:39 <kmc> i think String makes perfect sense
18:17:44 <djahandarie> Does anyone actually use Data.Judy?
18:17:51 <kmc> it's simple (define it yourself in one line!) and easy for beginners, and maximally lazy
18:17:54 <blackdog> kmc: you are right to yell at me, especially as i've seen that before :)
18:18:01 <kmc> why should the Prelude version be the super optimized complicated one?
18:18:04 <kmc> i object to Int in prelude too
18:18:19 <c_wraith> But it never made sense.  The show hack that's there *purely* for strings is a pretty strong indicator that making String = [Char] is not a good design.
18:18:28 <kmc> Integer is probably good enough and has nicer properties
18:18:32 <shachaf> kmc: And Float/Double instead of Rational?
18:18:36 <kmc> *nod*
18:19:39 <djahandarie> Seems like no single package uses HsJudy or judy.
18:19:56 <djahandarie> Too bad, since judy arrays/tries are pretty cool.
18:19:57 <copumpkin> I think pugs did at some point
18:20:08 <c_wraith> At least make String opaque, with something like asList :: ([Char] -> [Char]) -> String -> String
18:20:10 <djahandarie> Yeah, read that on gwern's thing I think.
18:21:02 <c_wraith> You still get to apply list functions, you don't need a hack for show.
18:21:38 <c_wraith> And the internal representation can be made more efficient without mucking up the external interface
18:22:25 <copumpkin> c_wraith: how about all the functions people like to define inductively on them?
18:22:33 <copumpkin> give them a foldr?
18:24:00 <c_wraith> Or any number of other things.  My main point is..  The benefits to String = [Char] are overstated (most list functions make little sense on strings), the limits are understated (everyone just ignores that you can't create String and [a] instances for a class trivially)
18:24:57 <Mathnerd314> copumpkin: so, you can't think of any examples and thus I'm right?
18:25:02 <kmc> djahandarie, nobody uses them because everyone learns in CS 101 that O(1) is omg so much faster than O(log n)
18:25:20 <djahandarie> lol
18:25:21 <kmc> never mind that your judy trees will never, ever be deeper than four levels
18:25:31 <copumpkin> Mathnerd314: if it were that simple, I'm sure we'd have it already
18:26:05 <djahandarie> Everything is that simple.
18:26:29 <djahandarie> It's just hard to get there. :)
18:26:41 * djahandarie actually has no idea what is being discussed but decided to interject
18:30:13 <shachaf> kmc: O(1) as in hash tables?
18:32:23 <blackdog> i think people don't use judy trees because it's hard to accept that fast code has to be ugly...
18:32:58 <Axman6> well, doesn't always have to, but it's often true
18:33:02 <shachaf> blackdog: It doesn't *always*.
18:35:15 <xplat> 21:39 < kmc> why should the Prelude version be the super optimized complicated  one?
18:35:33 <xplat> because the prelude version is what gets used in typeclasses
18:35:37 <Axman6> why shouldn't it
18:35:43 <blackdog> shachaf, Axman6: that reaction is exactly what i'm talking about:)
18:35:53 <blackdog> and i get it too. at least the judy interface is nice.
18:36:23 <shachaf> blackdog: Some fast code is unnecessarily ugly.
18:36:43 <Mathnerd314> copumpkin: I read SPJ's paper, and it seemed like an obvious solution, although it was never mentioned...
18:38:00 <blackdog> shachaf: that's true too.
18:38:04 <drbean> +-
18:38:10 <xplat> fast code doesn't have to be ugly, but it sure helps
18:38:19 <Axman6> lots of fast code is necessarilly ugly too :P
18:38:29 <blackdog> Axman6: oh, so that's your excuse :P
18:39:07 <liyang> (yo mama is necessarily ugly.)
18:39:10 <xplat> Axman6: just means they didn't build a big enough rug yet to sweep the ugly under :)
18:39:15 <Axman6> well it's necessarry until the compiler is smart enough to turn your pretty code into the ugly code you want
18:39:28 <shachaf> @quote sufficiently.smart
18:39:28 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
18:39:32 <shachaf> Aw.
18:39:49 <xplat> @quote sufficient
18:39:49 <lambdabot> ksf says: Furthermore, I'm challenging my solution's alleged ineffectiveness with the sufficient smart compiler conjecture.
18:40:58 <shachaf> > dwim
18:41:00 <lambdabot>   Not in scope: `dwim'; GHC is not yet sufficiently smart
18:41:40 <blackdog> "a sufficiently smart compiler: it looks like you're trying to write a random-access algorithm on a list. do you think you could, y'know, not do that?"
18:42:08 <copumpkin> lol
18:42:17 <blackdog> seriously, it'd be clippy...
18:42:26 <shachaf> A sufficiently-smart compiler would rewrite it for you.
18:42:27 <Axman6> "Error: List random access. You're obviously an idiot, i refuse to compile your code from now on"
18:42:29 <blackdog> it'd be even more galling when it was right
18:42:45 * shachaf shudders at the thought of a Clippy that rewrote your code without asking.
18:43:23 <blackdog> yeah. you run into that awful problem that you're relying on certain transformations in order to get into the right asymptotic class
18:43:31 <blackdog> jiggle it a bit, and suddenly you lose
18:44:03 <shachaf> blackdog: That compiler is clearly not suffiently smart.
18:44:08 * shachaf has an all-purpose response.
18:45:21 <dankna> Any technology, distinguishable from magic, is insufficiently advanced!
18:46:14 <blackdog> shachaf: i'm sure you could pervert a halting argument into a non-existence of a SSC
18:46:21 <xplat> hm, magic doesn't work, neither does this program.  it must be very advanced!
18:46:50 <shachaf> xplat: Huh? Of course magic works.
18:47:03 <Axman6> the magic that doesn't work isn't magic
18:47:11 <Axman6> therefore all magic works
18:47:14 <shachaf> "magic" = "something you don't understand", no?
18:47:18 <accel> is ahskell's runtine written in C?
18:48:40 <dankna> accel: yes.  mostly.  there's a tiny bit of asm on some platforms.
18:49:04 <dankna> you can find it in ghc's source tree under rts/ if you are curious.  why do you ask?
18:49:33 <dankna> imo "magic" = "something that works AND you don't understand it"
18:49:52 <dankna> so it works, see, but doesn't exist :)
18:50:06 <accel> dankna: because I thoguht haskell was all ahskell all the way down
18:50:17 <dankna> if it doesn't have to exist it can satisfy any set of properties, even contradictory ones
18:50:33 <blackdog> accel: has to be transistors at some point
18:50:37 <Axman6> accel: how would you interact with the system? ie, make calls to open() etc?
18:50:49 <dankna> well, no, you could make calls to open() with a Haskell-based RTS too.
18:50:54 <dankna> you'd do it the same way C did it.
18:50:59 <accel> Axman6: FFI
18:51:08 <Axman6> accel: that would be using C...
18:51:14 <dankna> not exactly FFI, but rather native support for the calling convention
18:51:33 <accel> dankna: yeah; taht's waht I meant
18:51:39 <dankna> however, you generally want to use the system's libc
18:52:00 <dankna> anyway, it would be theoretically possible to design things such that there was no C in GHC's tree itself
18:52:06 <kulakowski> blackdog: but how do you think the transistors know how to work? they sure aren't running C
18:52:08 <dankna> in the same way as GCC has no Haskell in it
18:52:24 <dankna> but it's not clear that it's desireable
18:52:35 <dankna> if the GHC maintainers find the code manageable, and really the rts is only *pauses to run wc*
18:52:54 <dankna> .... 105,000 lines of code, I retract the "only"
18:53:14 <dankna> ... if the GHC maintainers find the code manageable, why does it matter?  C is a fine language.
18:53:20 <Jafet> Run WC?
18:53:21 <accel> wait, the C backend is 100K LOC?
18:53:32 <accel> dankna: because a faster ghc compiler does not speed up the C runtime
18:53:47 <kmc> accel, the Haskell standard says nothing about what language you must write the RTS in
18:53:52 <kmc> or indeed whether there is an RTS
18:53:53 <dankna> oh!
18:53:56 <dankna> sorry no it's not
18:54:01 <dankna> I had some build products in that directory which got counted
18:54:13 <kmc> every Haskell compiler I know of has some kind of runtime system written in C
18:54:34 <kulakowski> Jafet: wc, word count, which is I think used more often to count lines than words
18:54:36 <kmc> you could use any language providing sufficiently low-level access
18:54:39 <dankna> something's funny here, these numbers don't seem to add up to the total row
18:54:45 <Mathnerd314> I'd guess that it's pretty hard to write a garbage collector in a garbage-collected language...
18:54:46 <kmc> and the level of low-level you need depends also on how much performance you need
18:54:55 <chowder> I just got here so forgive me if I'm intruding on the conversation with my newbish question but what does C have that Haskell doesn't?
18:54:58 <kmc> Mathnerd314, no, it's actually very easy
18:55:05 <Jafet> Oh, wc
18:55:06 <kmc> ;)
18:55:33 <monochrom> C has macros that Haskell doesn't.
18:55:34 <kmc> accel, to write a Haskell runtime system in "Haskell" you'd probably want to extend the language with various low-level constructs -- primitive types, explicit memory management, explicit datastructure layout, etc
18:55:45 <Jafet> chowder: lots of people using operating systems written in it.
18:55:52 <kmc> some of which GHC already does
18:55:55 <kmc> see also Habit
18:55:59 <Jafet> Unix is written in C, so it makes sense to use C to implement Haskell on Unix.
18:56:03 <blackdog> kmc: so the GRIN approach that john meacham has taken is one way of going there too
18:56:09 <Mathnerd314> kmc: do you have examples of these garbage collectors?
18:56:09 <kmc> accel, also, GHC C backend != GHC runtime system
18:56:16 <accel> kmc: isn't there some project to write an OS in haskell?
18:56:20 <kmc> accel, several
18:56:31 <chowder> Jafet: wouldn't it be possible to do all of the low-level stuff in haskell?
18:56:36 <accel> kmc: how do they get aroudn this problem? or do they also use the C runtime?
18:56:39 <kmc> Mathnerd314, SICP culminates with writing a garbage collector for Scheme in Scheme
18:56:43 <kmc> accel, House uses parts of the GHC runtime
18:56:50 <kmc> as does HaLVM i expect
18:57:03 <Jafet> chowder: what is this "haskell"?
18:57:06 <dolio> The RTS isn't all C, either.
18:57:12 <kmc> some of it's Cmm ;)
18:57:16 <dolio> Yes.
18:57:17 <dankna> anyway, the short answer is that it would be possible to be turtles all the way down, but it would probably be at least a bit harder, and for no obvious benefit besides pride
18:57:31 <kmc> there are also projects written in Haskell code that runs and generates C code which is then used as an OS / embedded control program
18:57:41 <NemesisD> anyone ever used cmdargs?
18:57:47 <kmc> yep
18:57:48 <kmc> NemesisD,
18:57:55 <Jafet> chowder: you can extend haskell in a way that it lets you do "low-level stuff" for a particular type of platform
18:59:01 <chowder> Jafet: I imagine that an OS would be far more robust written in a language like Haskell. I'm still learning Haskell myself.
18:59:41 <kmc> of course we think of C as low-level because it's very close to the machine
18:59:58 <kmc> if your machine is designed to run Haskell (see: Reduceron) then in some sense Haskell is low-level
18:59:59 <Jafet> From the way things are going, I don't think robustness is a major design criterion for operating systems
19:00:00 <dolio> Not anymore, as folks will tell you.
19:00:15 <kmc> also "the machine" is just another polite fiction
19:00:48 <dolio> Machine code isn't even "close to the machine" for certain definitions thereof.
19:01:06 <dolio> Since it usually needs to be translated to microcode these days.
19:01:15 <blackdog> chowder: another interesting approach that the sel4 guys at UNSW have taken is to prove correspondences between the meaning of C code and Haskell code
19:01:33 <blackdog> so the code that runs is C, but they can reason about it in haskell
19:02:16 <djahandarie> Does cabal install --ghc-options support multiple options at once?
19:02:27 <Jafet> PCC embeds correctness proofs of machine code
19:02:27 <Axman6> "-ffoo -fbar"
19:02:29 <Axman6> i believe
19:02:42 <djahandarie> Okay, thanks, that's what I thought, just wanted to double check
19:02:47 <chowder> blackdog: I see. I do something similar with my coding. My uni teaches Java (much to my dismay) but I find myself writing the code in haskell before doing it in Java. Not always, though. I'm still very green.
19:02:49 <dankna> I'm a big fan of the concept of PCC
19:03:04 <dankna> it doesn't appear ready to use on a full scale, however
19:03:21 <djahandarie> Unrelated, can Flexible instances make any code that previously compiled stop compiling?
19:03:29 <djahandarie> I can't think of anything but might as well poke the hive mind
19:03:43 <Jafet> In fact, their semantics (for a load-store subset) look simpler than the semantics people try to ascribe to C
19:04:05 <blackdog> chowder: condolences. java's an awful language to teach to undergrads.
19:04:36 <blackdog> i think you can start at the top with haskell, or start at the bottom with C/asm/OS level stuff. starting in the middle just leaves you adrift.
19:05:08 <blackdog> (and by haskell i mean scheme/ml/prolog/haskell, of course)
19:05:24 <dankna> I've had undergrads who knew only Java ask me questions like "What O() is an integer multiplication?"
19:05:43 <blackdog> dankna: a trickier question than it seems :)
19:05:46 <dankna> granted :)
19:05:47 <Axman6> it's a good question
19:05:50 <dankna> but that wasn't what they meant :)
19:06:06 <chowder> blackdog, yeah. I have a great love of mathematics and I found that Haskell is very math-like. That is what initially drew me to it
19:06:09 <Jafet> blackdog: of course not, I'm sure you just meant haskell
19:06:19 <dankna> anyway it may say more about them than about the language, but I think there's a case to be made that Java obscures what's really going on by mixing expensive abstractions and cheap ones
19:06:43 <blackdog> Jafet: c'mon, we're a broad church, right? :) i'm sure some of us even go so far as scala, tiptoeing onto the all-feared jvm...
19:06:45 <dankna> at least they were asking the question though, and not just making assumptions, so I give them credit for that
19:07:14 <accel> isn't multiplication O(1) ?
19:07:26 <dankna> accel: multiplication of what?  bignums?
19:07:30 <blackdog> accel: for fixed-width integers, sure.
19:07:58 <Jafet> Multiplication is O(1) multiplications
19:08:03 <Axman6> multiplication of integers ranged from O(1) to O(n) (for the naive case)
19:08:17 <Axman6> ranges*
19:08:29 <accel> for fixed width, of course
19:08:46 <Axman6> why of course?
19:09:03 <dankna> oopsie, netsplit :(
19:09:05 <chowder> whoa
19:09:15 <Axman6> we deal with Integers all the time, and mutiplication of arbitrary sized integers cannot be O(1)
19:09:25 <blackdog> accel: we are functional programmers, we know only S and Z
19:09:28 <Jafet> Sure it can. O(1) multiplications.
19:09:45 <dankna> IRC is such a horrible protocol.  I'd have to measure it, but I don't buy the notion that the distributed nature of the network decreases load.  Every server needs virtually every line of traffic anyway.
19:10:01 <accel> blackdog: what's S anx Z?
19:10:31 <blackdog> accel: i'm being silly. it's Peano notation - Z is zero, and S(X) is the number after X, where X is some other thing in peano notation
19:10:42 <accel> ah
19:10:43 <Axman6> S (S (S Z)) = 3
19:10:45 <accel> how do you subtract?
19:10:50 <dankna> carefully
19:10:57 <blackdog> *boomtish*
19:10:58 <accel> I wish my bank used only S and Z
19:16:48 <chowder> I wish my bank accepted checks written in base i
19:16:53 <joe6> any thoughts on this, please: http://pastebin.com/3AYVcz6H
19:17:08 <medfly`> yeah, but not every server sends every line of traffic to all the users, and it's pretty insignificant to share data between the servers
19:18:07 <monochrom> multiple-server IRC was not for load. probably just for "there is a server near you". recall it was the 1990s. if you as end-user casually connect to another country it's dog slow. but if you connect to a server in your own country and it in turn connects to another country over a fairly dedicated OC-3 (because there are two universities paying for it) it's much faster.
19:19:27 <copumpkin> @type \f x -> uncurry id $ liftA2 (,) f x
19:19:28 <lambdabot> forall c a b. (Monoid c) => ((a, b) -> c, a) -> ((a, b) -> c, b) -> c
19:19:57 <copumpkin> where the hell is that monoid constraint coming from?
19:19:57 <copumpkin> oh
19:19:59 <copumpkin> I see
19:20:44 <djahandarie> @type \f x -> liftA2 (,) f x
19:20:45 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
19:21:02 <copumpkin> I was looking for 
19:21:05 <copumpkin> @type \f x -> fmap (uncurry id) $ liftA2 (,) f x
19:21:06 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
19:21:13 <djahandarie> @type uncurry id .: liftA2 (,)
19:21:14 <lambdabot> forall c a b. (Monoid c) => ((a, b) -> c, a) -> ((a, b) -> c, b) -> c
19:21:19 <djahandarie> Heh
19:25:11 <Jafet> :t (.:)
19:25:12 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:25:16 <Jafet> Figures
19:25:43 <djahandarie> :t (Prelude..) (Prelude..) (Prelude..) -- being the nicer looking one of course
19:25:44 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:39:16 <copumpkin> when we talk about solving an equation or other logical statement, how does one allocate quantifiers on the variables in it
19:39:36 <copumpkin> if I say solve 5x^2 - x + 3 = 0, it seems clear that the x there is existential
19:39:44 <Axman6> woah...
19:40:11 <copumpkin> ax^2 + bx + c = 0, it's forall a b c. exists x. 
19:40:52 <copumpkin> so informally, "unknowns" are existentials, and "constants" are universals?
19:41:02 * copumpkin is just trying to figure out if there's a consistent convention
19:41:58 <drbean> Or "bound" and "free?"
19:42:05 <copumpkin> and a solver for such an expression would take all universals as input and return all existentials
19:42:15 <copumpkin> well, I'm just trying to give it a precise logical interpretation
19:42:32 <Mathnerd314> copumpkin: "solve" mostly means to rewrite the equation so one variable is in terms of the others
19:42:32 <monochrom> a solver for such equations is a constructive proof of ∀a,b,c ∃x ax^2 + bx + c = 0. hope this helps. generally inputs are ∀, answers are ∃
19:42:38 <luite> you should use z instead of x ;)
19:42:42 <copumpkin> monochrom: exactly, cool
19:42:43 <Mathnerd314> copumpkin: so it would be "solve for x"
19:42:49 <copumpkin> drbean: I'm wary of "bound" because we have two binders here :)
19:43:13 <copumpkin> Mathnerd314: ah, true
19:44:25 <copumpkin> Mathnerd314: but that's effectively doing the same thing from a different viewpoint
19:44:50 <monochrom> Of course I implicitly assume "solve for x" rather than "solve for c".
19:44:58 <copumpkin> yeah
19:45:11 <Mathnerd314> copumpkin: not really... you're just using the field axioms to good effect.
19:45:54 <copumpkin> Mathnerd314: sure it is. You're using the axioms (who says it's a field?) to give you a function that returns the existential and takes in the universals as parameters
19:46:13 <monochrom> well you could go generally to "solve for x in P c x" now there is no field.
19:46:37 <monochrom> and only smt :)
19:46:38 <copumpkin> yeah, in a more general setting that's what I want to be doing, and encoding nicely
19:47:41 <monochrom> a mathematician is a constructive proof for ∀P,c ∃x P c x
19:47:49 <Mathnerd314> monochrom, copumpkin: that sounds more like an optimization problem.
19:47:57 <copumpkin> why?
19:48:13 <monochrom> yes, optimize from False to True
19:48:36 <monochrom> "try your best to make P c x true"
19:49:17 <Mathnerd314> yeah... that's what you're doing.
19:49:52 <monochrom> there is indeed some optimization tarpit equivalent to the gödel tarpit. you could encoding everything as optimization.
19:50:34 <copumpkin> well, I'm thinking about it in the case of presburger. I can write any universally and existentially quantified statement involving the primitive operations and relations, and it can tell me whether it's true or not. But what would "solving" such a statement mean?
19:50:54 <copumpkin> it seems to be an assignment to all the existentials in terms of the universals
19:50:59 <monochrom> in a roundabout way by a trick of Mateyavich, you could also map optimization back to diophantine equation solving!
19:53:46 <kulakowski> monochrom: calling that a trick is selling it a bit short, I think
19:55:41 <FunctorSalad> 'c' is the coffee?
19:55:44 <monochrom> it is a comical sentence rather than a technical sentence.
19:56:06 <copumpkin> byorgey: so I hear the 'opedia is gonna grow :)
20:01:06 <copumpkin> http://www.reddit.com/r/haskell/comments/fj3w8/ams_any_of_you_guys_looks_at_ats_with_supports/c1gbr5u?context=3
20:01:07 * copumpkin coughs
20:02:10 <monochrom> why do you people mock him/her so with your "ams"s?
20:02:27 <copumpkin> I'm not mocking him/her
20:02:31 <copumpkin> I'm speaking his/her language
20:02:32 <dolio> Mock whom? Skwisgaar Skwigelf?
20:02:34 <copumpkin> it's clearly by choice
20:02:40 <dolio> The fastest guitar player in history?
20:06:01 <copumpkin> I kinda like that power metal
20:06:17 <FunctorSalad> the reply by DrMoreau69 is pretty good :) (independent of mockery)
20:06:26 <dolio> The Metalocalypse soundtracks are pretty good.
20:06:55 <dolio> Possibly better than most actual metal bands.
20:07:06 <pastorn> copumpkin: nice mocking of chinese people :)
20:07:13 <copumpkin> pastorn: ??
20:07:36 <pastorn> copumpkin: at least to me that looks like an obvious case of chinese english
20:07:41 <copumpkin> I'm speaking skwisgaar's english
20:07:43 <copumpkin> it isn't at all
20:07:50 <copumpkin> and I know quite a few chinese people :P
20:08:00 <copumpkin> skwisgaar is a fictional character
20:08:10 <copumpkin> I would never mock actual bad english if it didn't look intentional :P
20:08:22 <dolio> It's fictional Swedish English.
20:08:34 <pastorn> dolio: swedish?
20:08:38 <dolio> Yes.
20:08:45 <dolio> Skwisgaar is from Sweden.
20:09:00 <copumpkin> so is pastorn
20:09:04 <copumpkin> maybe pastorn IS skwisgaar!
20:09:07 <pastorn> that doesn't look like bad english from sweden
20:09:25 <pastorn> it doesn't have the grammatical mistakes it ought to have ;)
20:09:27 <copumpkin> pastorn: it's from a comedy show. You guys don't say bork bork either :P
20:09:37 <dolio> http://www.youtube.com/watch?v=Jtz3Zj2dNKs
20:10:32 <monochrom> I expect more bork bork bork and der chicken
20:11:14 <pastorn> lolz... leave it to american to always fail when doing accents
20:11:26 <copumpkin> it's not even trying to be accurate :P
20:11:51 <dolio> There's a guy from Norway (I believe) who talks the same way. Would that be more accurate?
20:12:56 <pastorn> dolio: neither :p
20:13:43 <dolio> The Wisconsin accent is pretty good, at least.
20:13:48 <copumpkin> I must say, I've spent my life in italy and have never actually heard an italian  "Mamma mia, that's-a spicy meat ball-a!"
20:13:59 <copumpkin> *say
20:14:05 <sproingie> what about "it's-a-me, mario!"
20:14:24 <copumpkin> yeah, that's italian for "I think your fly is undone"
20:14:29 <copumpkin> so it's fairly common
20:14:48 <sproingie> crazy italians.  always trying to steal my arctic circle-candy
20:14:56 <pastorn> dolio: it sounds like a mixture of russian and italian and maybe a little french
20:16:19 <xplat> so basically like a salad dressing for the indecisive
20:16:44 <monochrom> @let germanize = concat . words
20:16:45 <lambdabot>  Defined.
20:16:49 <copumpkin> lol
20:16:58 <monochrom> > germanize "programmen sprachen"
20:17:00 <lambdabot>   "programmensprachen"
20:17:08 <monochrom> or something like that
20:17:14 <copumpkin> @remember monochrom @let germanize = concat . words
20:17:14 <lambdabot> Good to know.
20:17:22 <monochrom> haha
20:17:45 <pastorn> heh, we do the same in swedish, we're theoretically able to create words of infinite length
20:17:54 <monochrom> SuSE really scared me. softwareengineering is one word?! :)
20:18:27 <copumpkin> a context-free word grammar?
20:18:44 <copumpkin> seems like you'd want some sort of coding on the words to determine boundaries
20:18:51 <xplat> regular grammars can do that too
20:19:01 <monochrom> camel case
20:19:09 <copumpkin> monochrom: too easy
20:19:17 <copumpkin> xplat: might as well make it as powerful as possible
20:19:32 <pastorn> copumpkin: you can concatenate nouns to get more specific ones, all the "pre"-nouns gets an 's' at the end
20:19:32 <FunctorSalad> "programmiersprachen" :)
20:19:33 <xplat> antidisestablishmentarianism
20:19:36 <drbean> typeclass or type class?
20:19:46 <copumpkin> drbean: depends on my mood
20:20:10 <drbean> byorgey says it's 2 words.
20:20:15 * Mathnerd314 wonders if there's a "soft space"
20:20:23 <pastorn> english is really difficult on that point
20:20:35 <djahandarie> I use typeclass if I'm explaining the concept to who isn't familiar with it
20:20:39 <pastorn> it's "cornfield" not "corn field" but it's "type class" and not "typeclass"
20:20:49 <djahandarie> (Because it's less ambiguous than type class)
20:20:52 <monochrom> the haskell 98 report and the haskell 2010 report use "type class". I stick to them.
20:21:13 <monochrom> I consider them official
20:21:27 <FunctorSalad> they are really classes (sets) of types, but not every set of types is a typeclass (I think)
20:21:30 <monochrom> I also use them to settle "is 'Maybe' a type?"
20:21:34 <drbean> pastorn: Yes, reasonable people can disagree.
20:21:48 <xplat> monochrom: but in english it's pretty normal for compounds to start with a space and then lose it over time
20:22:18 <monochrom> yes I did watch "web site" becoming "website"
20:22:19 <FunctorSalad> well, if 'Maybe' a type of kind * -> *, then it is a type
20:22:19 <FunctorSalad> ;)
20:22:32 <kfish> omgoleg
20:22:35 <FunctorSalad> unless 'type of kind blah' is an atom
20:22:37 <djahandarie> FunctorSalad, I don't think it's particularly useful to think of them in that way really
20:22:45 <djahandarie> (As a set of types)
20:23:10 <copumpkin> djahandarie: I do!
20:23:24 <xplat> * is the kind of types
20:23:29 <djahandarie> And I suppose every set of types could be a typeclass. Just not all of those typeclasses would be particularly useful
20:23:37 <monochrom> but then "homepage" became dominant pretty early. "home page" had a very brief period.
20:23:40 <xplat> * -> * are type constructors or families
20:24:33 <FunctorSalad> djahandarie: data Zero a; data One a; let S := the ()-terminated Zero/One strings that encode halting haskell programs when interpreted as UTF-8? :(
20:24:43 <FunctorSalad> s/:(/:)/
20:25:18 <xplat> that would actually be an extremely useful typeclass
20:25:37 <xplat> too bad it's unimplementable
20:25:56 <monochrom> You can just turn on UndecidableInstances and pray
20:26:34 <xplat> heh
20:27:37 <monochrom> omg oleg
20:28:06 <monochrom> (now I know why "omgoleg". haskell-cafe post just in)
20:28:14 <FunctorSalad> last time I checked it only went 20 levels or so deep :p
20:28:18 <FunctorSalad> (UndecidableInstances)
20:28:23 <monochrom> ("How to write type-level lambda-abstractions at the value level") !!!
20:29:06 <FunctorSalad> though that limitation is arguably not part of the type class that's being defined (*sophistisise*)
20:32:42 <seydar> dynamic libraries on mac os x. what is their status?
20:32:49 <seydar> somebody knows the answer
20:32:51 <seydar> and i will find them
20:33:56 <seydar> y'all got quiet on me
20:34:12 <dankna> seydar: I can test 7.1.20110125-x86_64 for you real quick, but that won't tell you what's happened since then
20:34:37 <seydar> dankna: ah, i've been using 7.0.1 which may be the issue. is 7.1 more stable and fun and stuff?
20:34:43 <dankna> no, less stable
20:34:44 <dankna> more bugs
20:34:46 <dankna> bugs make compiler fun
20:34:55 <seydar> oh yeah, fun, of course
20:34:59 <dankna> odd-numbered points are unstable releases, even numbered ones are stable
20:35:08 <seydar> k
20:35:08 <dankna> 7.2 will be the next stable release, therefore
20:35:10 <seydar> thank you
20:35:11 <dankna> but doesn't exist yet
20:35:12 <dankna> sure
20:35:26 <seydar> 7.0.1 says it's missing the dyn library in base
20:35:34 <seydar> which makes me go WTF
20:35:35 <dankna> I figure you can do the test yourself on 7.0.1, you don't need me to tell you the status
20:35:43 <blancNoir> when i try to install Haskell Platform 2010.2.0.0 on an intel mac os x 10.5.8 the "Install" button is greyed out for the pkg to install the "new ghc"
20:35:58 <dankna> blancNoir, I'm not sure if that's a known problem to the team but it's known to me
20:36:00 <seydar> i assume my error is because dynamic library support is mysteriously missing
20:36:10 <dankna> blancNoir, you have to a) wait a few seconds and b) click "install for all users"
20:36:11 <seydar> blancNoir: do you have developer tools installed?
20:36:19 <dankna> even though "install for all users" is already selected, you have to click it again
20:36:35 <blancNoir> ok, i'll see what happens
20:36:36 <dolio> "Solving a problem in an unusual language by first writing a lambda-calculus interpreter in that language is a good strategy." Heh.
20:36:37 <blancNoir> thanks
20:36:39 <dankna> np
20:37:11 <kulakowski> dolio: source?
20:37:17 <dolio> Oleg's e-mail.
20:37:36 <dolio> That message renewed my resolve to never try HList.
20:37:50 <monochrom> you can find it at http://thread.gmane.org/gmane.comp.lang.haskell.cafe/86255
20:37:54 <blancNoir> seydar: i don't have xcode installed
20:38:06 <blancNoir> i know that's a requirement for MacPorts, wasn't sure if that's the case here too
20:38:08 <dankna> seydar: I get "pointer in read-only segment not allowed in slidable image" from ld
20:38:10 <blancNoir> i figured it would have complained about that
20:38:15 <seydar> blancNoir: you're gonna need those. I just saw this question on reddit i think. 
20:38:28 <dankna> seydar: so I believe that means support is currently broken for even building dylibs, let alone linking against them
20:38:30 <blancNoir> k
20:38:45 <seydar> blancNoir: yeah, it should, but evidently that feature isn't implemented in the pkg installer. boo.
20:38:52 <seydar> blancNoir: install the developer tools and try again
20:38:53 <dankna> btw I did that with cabal configure --ghc-options=-shared
20:39:08 <seydar> dankna: bleh stupid stupid stupid. how do i fix them i want them fixed now
20:39:22 <dankna> how experienced are you?  do you think you might be able to do it yourself?
20:39:33 <blancNoir> will do, i was just using the tryhaskell.org interpreter but it seems it doesn't let me use.."let"
20:39:36 <dankna> we should try to find the ticket for this
20:39:41 <dankna> and add ourselves to its cc list
20:40:07 <dankna> people who are doing fewer things at once than me could use ghc trac's search feature to do that :D
20:42:11 <dankna> seydar, okay, so now I understand the distinction between -static and -shared
20:42:11 <dankna> er
20:42:15 <dankna> wow that sounded stupid
20:42:23 <dankna> I meant to say between -shared and -dynamic
20:42:27 <seydar> dankna: i am inexperienced
20:42:43 <dankna> -shared affects what you are building.  -dynamic affects your dependencies.
20:42:52 <seydar> so... what?
20:43:00 <dankna> so I believe correct configuration would be cabal configure --ghc-options=-dynamic,-shared
20:43:01 <seydar> that is over my head
20:43:02 <dankna> trying it now
20:43:10 <seydar> can you explaina again the difference?
20:43:16 <seydar> dynamic affects what i can load
20:43:23 <seydar> shared affects what i can produce?
20:43:32 <dankna> correct
20:43:44 <dankna> erdynamic means "whenever you try to load a module outside the current package, look for a shared library corresponding to it"
20:44:09 <seydar> gooooootcha
20:44:14 <dankna> shared means "when compiling this package, prepare the code and do the linking in such a way that it functions as a shared library"
20:44:24 <seydar> when would i run cabal configure --ghc-options=-dynamic,-shared?
20:44:34 <dankna> immediately prior to running cabal build
20:44:45 <dankna> if you just want to install a package, you aren't working on it,
20:44:47 <dankna> you can instead do
20:44:53 <dankna> cabal install --ghc-options=-dynamic,-shared
20:45:29 <dankna> also the result of cabal configure --various --options will stick around until the next time you do cabal clean, or manually rm -rf dist/ in the project directory, or edit the project's .cabal file.
20:45:29 <seydar> hm. but my issue is that ghc is pretending to not know what `dyn` is
20:45:33 <dankna> oh, that
20:45:34 <seydar> when we all know that it's a fucking liar
20:45:51 <seydar> like my entire system just glares at ghc
20:45:55 <dankna> that error is saying "there is no .dylib version of base installed"
20:45:57 <seydar> and is like "seriously? this again? come on"
20:46:02 <dankna> because that's an option when ghc itself is compiled
20:46:19 <dankna> one obvious reason that that option would be off would be if -shared doesn't work
20:46:22 <seydar> god dammit
20:46:30 <dankna> I'm testing a couple things now 
20:46:32 <seydar> so now i have to compile ghc from scratch instead of using a nice prebuilt binary
20:46:39 <dankna> welcome to my world
20:46:43 <dankna> but
20:46:46 <seydar> breaking my balls. but it's cool because this should be fun
20:46:48 <dankna> let me test for you whether it works
20:46:54 <dankna> before you waste four hours of your life
20:47:00 <seydar> k
20:47:04 <seydar> here's the error:     Could not find module `Prelude':
20:47:05 <seydar>       Perhaps you haven't installed the "dyn" libraries for package `base'?
20:47:11 <dankna> yes, I got that as well
20:47:33 <seydar> and it's like "ghc don't play dumb with me. i'll pull you into my basement"
20:47:46 <dankna> duly noted
20:48:10 <dankna> okay, so, yeah
20:48:25 <dankna> I can confirm that I see the same behavior when providing both -shared and -dynamic as I mentioned above for just -shared
20:48:33 <dankna> the "pointer in read-only segment not allowed in slidable image" one
20:48:35 <seydar> damn
20:48:36 <dankna> one sec, I'll search trac for you
20:48:38 <seydar> thank you, though
20:48:50 <dankna> sure
20:48:55 <seydar> you have to tell me about yourself though in exchange for helping me
20:49:01 <dankna> sure thing
20:49:06 <dankna> I'm just this guy, you know.
20:49:09 <dankna> what would you like to know?
20:49:27 <seydar> job, programming xp, cool projects, etc.
20:49:32 <seydar> and country
20:50:15 <dankna> I teach computers to middle-school students at the private school that is the family business.  I am thirty years old and have been programming full-time (but, not for money :( ) since I was seven, so I like to brag that I have 20+ years of experience.  http://dankna.com/software/ has some small things I've done.
20:50:18 <dankna> NYC area in the USA
20:50:36 <djahandarie> ikeg, is this ikegami__ on twitter?
20:51:07 <seydar> teaching computers is good
20:51:09 <seydar> i respect that
20:51:21 <dankna> thanks, yeah, it is
20:51:39 <dankna> I volunteered some of my time next week to help a young student build a Debian virtual machine
20:51:45 <dankna> mostly because I found it pretty cool that he was interested
20:52:01 <dankna> http://hackage.haskell.org/trac/ghc/ticket/3712 seems relevant
20:52:42 <dankna> also see discussion on http://hackage.haskell.org/trac/ghc/ticket/3705
20:52:52 <dankna> which further points to http://hackage.haskell.org/trac/ghc/ticket/3713
20:53:13 <dankna> retrying my test with -fPIC added to the ghc-options
20:53:56 <dankna> nope, still get the same error
20:54:20 <seydar> oh jesus that looks fucking hard
20:54:25 <seydar> if i somehow did that
20:54:27 <seydar> with much guidance
20:54:40 <seydar> i would instantly become like lvl 40 programmer
20:54:46 <seydar> and i would get a mount
20:54:53 <dankna> you get mounts at level 20 now
20:54:55 <ikeg> djahandarie: sure
20:54:55 <dankna> for 5g
20:54:55 <dankna> it's lame
20:55:00 <seydar> i'd get a cigar and y'all would have to call me chief
20:55:12 <dankna> indeed
20:56:04 <djahandarie> ikeg, ah, I just got your latest tweets. Sorry for the bad Japanese, I'm just trying to practice :). I'm curious, what package is breaking?
20:56:36 <seydar> dankna: on a scale of 1-10, how hard do you think it would be to get dynamic libraries to work right in ghc?
20:57:21 <djahandarie> ikeg, and are you upgrading from 6.* -> GHC HEAD or from 7.0.1 -> GHC HEAD?
20:57:54 <dankna> seydar: I think fixing the flags as described on the ticket for that is probably about a 3.  fixing the problem, distinct from the flags-are-confusing issue, that you can't make this work on OS X at all right now, is probably a 6 or a 7.
20:58:08 <ikeg> djahandarie: 6.* -> GHC HEAD
20:58:30 <seydar> what is an equivalently hard problem?
20:58:52 <ikeg> djahandarie: -XFlexibleInstance is needed: network-2.3.0.1; -XBangPatterns : text-0.11.0.5, and so on...
20:58:53 <dankna> hmm
20:59:33 <djahandarie> ikeg, it doesn't make sense to me that you need extensions because of a GHC upgrade
20:59:34 <dankna> implementing a simple ELF-based linker from scratch (one without any advanced or subtle features) 
20:59:40 <dankna> is roughly as difficult, I'd say
20:59:42 <ikeg> djahanndarie: I can understand your tweet in Japanese, quite well
21:00:04 <copumpkin> ikeg: I can't say I'm surprised :P
21:00:05 <dankna> both require understanding what linking really is, and being able to read and comprehend low-level platform docs to understand why what it is doing is not what it needs to be doing
21:00:18 <Kaidelong> what does FlexibleInstances do again? Allow you to put class constraints in instance declarations?
21:00:28 <djahandarie> copumpkin, why would you need BangPatterns for something in GHC HEAD but not in anything else?
21:00:33 <seydar> ok so i will not be able to do that
21:00:38 <copumpkin> djahandarie: ?
21:00:42 <seydar> but i can make some SERIOUSLY good brownies
21:00:47 <seydar> so i will encourage others to do it
21:00:54 <dankna> BangPatterns is no longer implied by MagicHash in HEAD
21:01:00 <djahandarie> Ah
21:01:05 <dankna> I didn't follow the rest of your discussion, djahandarie, but that might be relevant
21:01:08 <copumpkin> the behavior changed slightly and it broke the agda build
21:01:09 <djahandarie> Figures it's something weird like that
21:01:10 <ikeg> I don't follow the talk yet: I should read IRC log right now...
21:01:14 <copumpkin> it isn't related to MagicHash though
21:01:26 <dankna> okay.  there are a lot of extensions no longer implied by other extensions in HEAD.
21:01:35 <dankna> so if you figure out which one it is, document it somewhere
21:01:41 <dankna> maybe on a "migrating to 7.2" wiki page
21:01:45 <djahandarie> ikeg, just trying to figure out why the extensions are needed in HEAD but not 7.0.1
21:02:08 <dankna> seydar, brownies are helpful :)
21:02:30 <FunctorSalad> hmm http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances
21:02:50 <djahandarie> ikeg, if you want a stable 7 version, get http://www.haskell.org/ghc/download_ghc_7_0_1
21:02:58 <ikeg> djahandarie: well, I tried 7.0.1 on MacOSX leopard, however I met often that ghc-pkg check and error...
21:03:06 <FunctorSalad> I need it (or maybe FlexibleContexts) all the time but never looked up what it does :)
21:03:45 <dankna> FunctorSalad, oh - right, I remember now.  it lets you have parameters which are arbitrary type expressions of kind * rather than just type names
21:03:53 <djahandarie> ikeg, which error?
21:05:31 <djahandarie> ikeg, もしが7.0.1はミスする、それはやばいです
21:05:32 <ikeg> djahandarie: I didn't keep it, sorry
21:05:39 <FunctorSalad> any particular reason why it didn't get accepted into 2010 or 2011? I always thought of it as unproblematic
21:05:41 <dankna> seydar: also I just found http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport which has a useful table
21:05:58 <FunctorSalad> (I don't know what problems it raises in detail though)
21:06:00 <joe6> can I register to ghc-pkg different lib directories? such ghc-6.12. an also ghc-7.1 ?
21:06:02 <djahandarie> ikeg, I see. Well HEAD will be difficult
21:06:04 <dankna> ... which claims that it works, and I don't find a ticket for this problem, it may be a regression
21:06:10 <djahandarie> (difficult to use)
21:06:27 <joe6>  i installed the latest ghc 7.1 and it does not have any entries of ghc-6.12 libraries.
21:06:35 <dankna> I'm about to do a build of HEAD, I'll throw in --enable-shared when I do it and see what happens
21:06:51 <djahandarie> ikeg, but using --ghc-options like you're doing is your best shot if you're trying to get stuff from cabal, I guess.
21:06:53 <seydar> dankna: i found a ticket the other day for 6.12
21:06:54 <joe6> dankna: of ghc? or cabal-install?
21:07:04 <seydar> and i was told that there was a patch merged in to make it work for 7.x
21:07:13 <dankna> seydar, can you link me to that ticket?
21:07:20 <dankna> joe6, of ghc, sorry
21:07:45 <dankna> joe6 -- regarding the library things, each ghc version has its own ghc-pkg databases
21:07:57 <dankna> joe6 -- because they are not binary-compatible with each other
21:08:30 <seydar> dankna: trying to find it, but no luck thus far
21:08:45 <joe6> dankna: i installed the latest ghc and it seems that it just has the ghc-7.1 libraries and yes, you are correct, it has its' own cache. Can I add other libraries to that cache?
21:09:11 <joe6> for example, one of the dependencies wants an old base, which I can see as installed in ghc-6.12.3
21:09:15 <djahandarie> joe6, you'd want all of them to be compiled by 7.1 otherwise you'll have problems
21:09:25 <dankna> joe6: yes - but not base.  the old base has gone away.
21:09:48 <dankna> joe6, what platform are you on?
21:09:51 <joe6> the HTTP-4000 latest head wants an old base and the one with cabal-install will not build
21:09:53 <djahandarie> joe6, cabal install -w /path/to/ghc7 blah  is what you want in general
21:10:06 <djahandarie> Latest HTTP wants an old base?
21:10:14 <seydar> dankna: http://hackage.haskell.org/trac/ghc/ticket/3550
21:10:23 <joe6> yes, the one from the git repository.
21:10:28 <dankna> joe6, note that if you just built ghc 7.1 from source, you probably want to install cabal-install before you do anything else
21:10:30 <joe6> unless I have an old re
21:10:31 <joe6> p
21:10:53 <joe6> dankna: yes, that is what I am doing and cabal-install fails with errors in HTTP-4000 library.
21:10:56 <dankna> seydar: thanks, hmm
21:11:05 <djahandarie> joe6, afaik the latest version compiles on 7 so it should accept later bases
21:11:10 <joe6> So, I am trying to see if I can get the HTTP from the source and get it to build.
21:11:17 <dankna> joe6: yes, I asked what platform you're on because if you're on Mac OS X 64-bit I can give you my binaries which were built with considerable pain
21:11:34 <joe6> dankna: no, I am on debian x86
21:11:35 <dankna> although they're a couple weeks old.  I'll have newer ones tomorrow.
21:11:37 <dankna> oh, drat then.
21:11:50 <dankna> well, hold on a second
21:11:51 <joe6> let me get the source repository link
21:12:02 <dankna> because I think I already made the requisite changes to HTTP
21:12:07 <dankna> and can save you the effort
21:12:10 <dankna> the same goes for most of the other patches
21:12:23 <joe6> git clone git://code.galois.com/HTTPbis.git
21:12:54 <joe6> dankna: yes, the network failed and I got it from source and it compiled and next is the HTTP-4000
21:13:12 <dankna> gotcha
21:13:15 <joe6> unless i have the wrong source link. I got that from the .cabal file of HTTP-4000
21:13:18 <dankna> yeah, it's fortunately not a huge set of patches
21:13:35 <dankna> er, of packages I meant to say
21:13:45 <djahandarie> What is the version of base in HEAD?
21:13:59 <dankna> 4.3.1.0 in my build, might be newer now
21:14:20 <joe6> base-4.3.1.0 for 7.1
21:14:28 <joe6> with HEAD as of yesterday.
21:14:30 <djahandarie> The HTTP from hackage has the version marked as < 4.4
21:14:48 <djahandarie> So it shouldn't try to grab an older one
21:14:56 <joe6> so, I have the wrong HEAD link. let me see if hackages has a different link or something.
21:15:11 <djahandarie> It's possible that it was on the community server and is killed right now
21:15:21 <djahandarie> Which should REALLY get fixed, I'm not sure where that's at
21:15:51 <ikeg> anyhow I'm satisfied with GHC 6.12.3. I want to switch to GHC 7 sometimes for just fun.
21:15:54 <dankna> I'm not sure how much they want this spread around, but the machine was compromised and recovering has been a royal pain
21:16:06 <joe6> yes, it is a wrong repository, so the .cabal file was wrong.
21:16:07 <dankna> that's why it's taking so long - there are more issues than just technical ones
21:16:43 <djahandarie> ikeg, it is fun :) If you want to try 7.0.1 again, someone might be able to help with the errors
21:16:43 <dankna> I mention this so you can know that the admins are on the case and not slacking
21:17:19 <seydar> dankna: have you worked on GHC's code before?
21:17:25 <djahandarie> dankna, last I checked, no one was sure where it was at, but we resolved that I think it was at Igloo (I think), but I'm not sure if it's progressed since then.
21:17:34 <seydar> have you submitted patches and are you some hobbit who has been into the depths of mordor and back?
21:17:52 <dankna> seydar: I've done several things that involved reading GHC's code, and interoperating with it through the API (direct-plugins being the biggest, and that's really quite small)
21:18:15 <djahandarie> I tend to avoid GHC if I can, really
21:18:20 <djahandarie> (GHC code I mean)
21:18:28 <joe6> Network/BufferType.hs:57:10: Illegal instance declaration for `BufferType String'
21:18:31 <dankna> seydar: but I haven't submitted patches, no, although just this morning I took the initial steps towards working to improve cross-compilation support
21:18:37 <dankna> it's pursuant to that that I'm prepping to build it now
21:18:49 <joe6> Use -XFlexibleInstances if you want to disable this.
21:19:03 <joe6> should I just enable flexibleinstances to this module?
21:19:06 <djahandarie> Heh, same thing ikeg was getting :)
21:19:10 <dankna> I have been immersed in ghc source all evening; I just finished updating Igloo's patch to fix conflicts which have arisen.
21:19:25 <joe6> or would it screw something up if i do that.
21:19:39 <dankna> joe6: go ahead and enable it
21:19:48 <joe6> dankna: ok, thanks.
21:20:02 <djahandarie> dankna, just curious if you know, why did FlexibleInstances stop working?
21:20:09 <dankna> no clue, sorry
21:20:12 <djahandarie> I can't imagine that is implied by many things
21:20:21 <dankna> I'm not an expert on any of this, I'm just someone who pays attention :)
21:20:22 * djahandarie looks
21:20:38 <joe6> that did the trick with that error.
21:21:01 <dankna> good
21:21:08 <joe6> same error with Network/TCP.hs too.
21:21:22 <dankna> another big issue in porting packages to HEAD that you're likely to encounter is that they changed the syntax of the layout rule
21:21:31 <dankna> if you get "empty do block" and the do block is clearly not empty
21:21:35 <dankna> add NondecreasingIndentation
21:21:51 <joe6> dankna: good to know. Thanks.
21:22:04 <dankna> if you really feel up to doing some community service, add a wiki page with these tips on it, and don't forget to submit your changes to these packages to their maintainers :)
21:22:08 <djahandarie> dankna, I don't recall this many things breaking when moving to 7 :P
21:22:26 <dankna> djahandarie, true.  don't look at me!  I just code here.
21:22:38 * djahandarie glares at dankna
21:22:43 * dankna is glared at
21:23:21 <joe6> http://pastebin.com/F7qHL1sC: seems to be a more fundamental errore.
21:23:38 <dankna> the : at the end broke the link btw
21:23:48 <joe6> dankna: ok, will send the maintainer the errors.
21:23:57 <dankna> good
21:24:05 <dankna> well, hm, I understand this error
21:24:23 <dankna> let me pull the package and see what I can do
21:25:07 <dankna> argh!  everyone is using git now!  I can't use git! :(
21:25:16 <dankna> I don't understand git :(
21:25:23 <dankna> well, anyway, I can fix the error
21:25:25 <dankna> probably
21:25:44 <joe6> dankna: ok, thanks.
21:28:16 * hackagebot hamlet 0.7.0.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.7.0.2 (MichaelSnoyman)
21:32:50 <joe6> for the first error, should I just change it to return . pack $ [] from return []
21:33:28 <joe6> or change, e to unpack, return . unpack $ e
21:33:47 <dankna> depends on the intent, which is what I'm researching now
21:34:18 <joe6> dankna: ok, thanks.
21:37:29 <dankna> where did you pull your repo from?  I don't encounter the error you mentioned with HTTPbis.
21:37:45 <dankna> I also don't encounter it with HTTP-4000.1.1
21:37:53 <dankna> which are the two versions I can find
21:38:07 <dankna> it took me a while to duplicate what you've done to get it compiling, which is why the long delay in saying this
21:38:14 <joe6> git clone git://github.com/haskell/HTTP.git 
21:38:17 <dankna> oh!  okay
21:38:19 <joe6> seems to be the latest source.
21:38:40 <joe6> the HTTPbis wants base 3 and I think the link is wrong. The cabal file should be fixed.
21:38:48 <dankna> gotcha
21:40:11 <dankna> well, I don't encounter the problem with this repo either.
21:40:37 <dankna> let me hpaste my changes to you
21:40:52 <dankna> http://hpaste.org/43874/my_changes_to_http
21:40:57 <joe6> dankna: ok, thanks.
21:41:03 <dankna> as you can see, it's quite trivial
21:41:10 <dankna> possibly you did something else which broke it?
21:41:14 <dankna> or possibly we don't have identical versions
21:41:20 <dankna> if I understood git I would know how to check that
21:41:36 <joe6> git clone git://github.com/haskell/HTTP.git 
21:41:46 <dankna> yeah, that's what I just did ten seconds ago :)
21:41:46 <joe6> dankna: that is the command to get the repository.
21:41:57 <joe6> and it did not getthe repo?
21:42:00 <dankna> these changes are versus that repo as of ten seconds or so after you said it
21:42:02 <dankna> it got the repo
21:42:18 <dankna> I just have no clue how to determine whether my copy of it has different patches than your copy of it, or compare our working trees
21:42:35 <dankna> in darcs I would suggest hpasting the output of darcs whatsnew at me
21:42:54 <dankna> sorry, I'm a little bitter about the ghc move to git :)
21:43:21 <joe6> oh, ok. let me git clone again. maybe they fixed while we speak.
21:43:28 <dankna> quite possible.
21:43:46 <dankna> maybe the maintainer is in here listening to us! :D
21:44:36 <joe6> http://pastebin.com/g8zvQJu6
21:45:02 <joe6> no, they are still unfixed. did you do the same?
21:45:07 <dankna> okay, it must be an issue with my ghc or something
21:45:08 <dankna> one sec
21:45:17 <dankna> oh wait, I get it
21:45:29 <dankna> it's complaining about a function that it gets from the network package
21:45:33 <dankna> which you just manually built
21:45:56 <joe6> about network-2.3, oh, ok.
21:46:16 <joe6> so, the latest network HEAD breaks this package
21:46:28 <dankna> right.  roll back to the latest actual release of network for now.
21:47:12 <joe6> oh, ok, if i can get it to compile.
21:47:14 <joe6> let me try.
21:47:46 * dankna nods
21:47:49 <joe6> why not just change the HTTP stuff and move ahead, instea?
21:48:16 <joe6> i am not sure about the second error but the first seems easy to fix.
21:48:25 <joe6> or, would it have some other effects?
21:48:55 <dankna> well, if you can wait until tomorrow, I'll have a version of ghc similar to the version you're using and will probably reproduce your failure
21:49:07 <dankna> my version now is from two weeks ago and obviously there have been changes
21:49:20 <dankna> you could just try fixing the HTTP stuff
21:49:27 <dankna> the pack/unpack thing appears to be all that's needed
21:49:39 <dankna> it looks to me like network now implements three backends for send/recv
21:49:48 <dankna> one based on Strings, one on ByteStrings, and one on lazy ByteStrings.
21:50:06 <dankna> and it might be as simple as importing a different module to get the correct one
21:51:52 <joe6> oh, ok.
21:54:55 <FunctorSalad> do we have strict (but with arbitrary element type) immutable arrays somewhere? :)
21:55:06 <dankna> unsure
21:55:25 <FunctorSalad> (performance is hardly an issue, I need the strictness for correctness)
21:56:05 <FunctorSalad> currently I'm using a strict list but I guess it's better to reuse something for my interface
21:56:32 <FunctorSalad> (data StrictList a = SNil | SCons !a !(StrictList a))
21:58:31 <djahandarie> Wat'cha making FunctorSalad?
21:58:52 <FunctorSalad> djahandarie: http://i.imgur.com/5JlhG.png
21:59:06 <FunctorSalad> a sort of debugging view that's tolerant against bottoms...
21:59:09 <djahandarie> Wow O.o
21:59:13 <djahandarie> Damn cool!
21:59:30 <FunctorSalad> so I want them to evaluate under my 'catch', not when the TreeView widget tries to read them ;)
21:59:40 <ikeg> I noticed that why my ghc-pkg crashed because i build over two packages at the same time...
21:59:43 <djahandarie> What graphics library are you using?
21:59:51 <FunctorSalad> gtk
22:00:05 <djahandarie> gtk2hs? Is it any good?
22:00:16 <Jafet> Against most bottoms
22:01:17 <djahandarie> ikeg, I've never actually tried building two packages at once. I imagine there could be locking issues or something similar.
22:01:44 <FunctorSalad> Jafet: yes, I mean exceptions, not infinite loops ;)
22:01:55 <copumpkin> FunctorSalad: that view seems to show things that I know not to be true! are you interpreting the specific types to pretend a map is a container of pairs?
22:01:58 <copumpkin> :P
22:02:16 <Jafet> It isn't?!
22:02:24 <FunctorSalad> copumpkin: yes. in fact, the user can supply extra CustomHandlers for their types
22:02:30 <djahandarie> *shock*
22:02:37 * copumpkin stores (3, 5) and (3, 6) into Jafet's Map
22:02:37 <FunctorSalad> (using Typeable/Data for that)
22:02:45 <copumpkin> FunctorSalad: cool :)
22:02:46 <djahandarie> Ugh.
22:03:00 <djahandarie> I know there are 'proper uses' for those things but I still cringe whenver I see them
22:03:24 * Jafet segfaults
22:03:51 <FunctorSalad> (IIRC the Data instance of Data.Map doesn't reveal the innards anyway)
22:21:56 <joe6> dankna: do not get the head of HTTP. Though, it has the same errors as the version that cabal-install tries to install. Just fix the errors in the cabal-install downloaded HTTP-4000.* folder.
22:23:08 <dankna> joe6: okay, noted, thanks
22:25:33 <FunctorSalad> are strict lists a monad?
22:25:43 <FunctorSalad> (strict in head and tail)
22:25:56 <joe6> dankna: whereas for network, just get the head. 
22:26:01 * dankna nods
22:26:07 <dankna> okay, I appreciate your figuring this out
22:26:19 <joe6> dankna: please let me know if you want my fixes for the HTTP-4000 errors,
22:26:32 <dankna> if it's easy for you to send me a patch, by all means do
22:26:36 <dankna> if it's not, don't worry about it
22:26:37 <joe6> the flexibleinstances, i think you will put them in without a though.
22:26:40 <FunctorSalad> "return undefined >>= f = f undefined" fails, doesn't it...
22:26:50 <dankna> yeah
22:26:51 <joe6> i will put the file on pastebin. give me a sec
22:26:53 <dankna> okie
22:27:00 <FunctorSalad> (is that a good reason not to define a Monad instance?)
22:27:55 <djahandarie> FunctorSalad, I think State/Writer Strict tend to cheat there too
22:28:30 <djahandarie> > (return undefined :: Identity ()) `seq` ()
22:28:31 <lambdabot>   *Exception: Prelude.undefined
22:28:39 <joe6> dankna: here you go: http://pastebin.com/gbeLBZpc
22:28:41 <djahandarie> > runIdentity $ undefined >>= \_ -> return ()
22:28:42 <lambdabot>   ()
22:29:19 <dankna> thanks, one less thing that I'll have to do :)
22:43:04 <joe6> hello, any suggestions about this: http://pastebin.com/CdTHw6TQ  when i do make in llvm/examples
22:43:22 <joe6> seems to be some kind of linker issue.
22:44:56 <Axman6> joe6: which version of LLVM do you have?
22:47:30 <joe6> Axman6: 0.9.1.0 downloaded it from the HEAD
22:47:50 <joe6> the cabal install llvm had some errors about packageDB oslt
22:48:36 <joe6> when I did strings libHSllvm-0.9.1.0.a | grep -ir LLVMaddverifierpass , it was finding 2 instances of it.
22:49:44 <joe6> and i am using llvm 2.8
22:50:36 <Axman6> joe6: no, which version of LLVM do you have, not the haskell package
22:50:42 <Axman6> ah, missed that
22:50:45 <Axman6> which OS?
22:51:02 <wavewave> hello.
22:51:09 <joe6> Axman6: debian x86
22:51:37 <wavewave> can I install haskell platform without admin on Mac?
22:51:39 <joe6> 2.6.32-5-486 #1 Wed Jan 12 03:28:50 UTC 2011 i686 GNU/Linux
22:51:54 <joe6> wavewave: i think you can to the user dir
22:52:21 <wavewave> joe6: how? I cannot find instruction... 
22:53:24 <wavewave> my admin won't install haskell. 
22:54:14 <joe6> wavewave: download the src, and intead of "configure" do "configure --prefix=$HOME/<wherever>"
22:54:26 <Axman6> joe6: you need ghc instaslled to compile ghc
22:54:36 <joe6> i am not sure how the binary can be installed in this manner, though it probably can be
22:54:37 <Axman6> wavewave: install homebrew in your homedir, and use that
22:55:02 <joe6> Axman6: oh, ok.
22:55:13 <wavewave> Axman6: Thanks.
22:55:16 <wavewave> I will try. 
22:56:04 <wavewave> btw, what's difference between homebrew and macports?
22:56:25 <Axman6> homebrew sucks less
22:57:03 <franz_> you can run homebrew without admin... ah yeah that was suggested
22:57:12 <franz_> macports is kinda old by now, I agree
22:57:27 <wavewave> I see... thnx for the info. 
22:57:35 <Axman6> i've been a long time macports user, recently changed to homebrew. it's just nicer to work with (though lacking some nice fearures of macports too)
22:57:56 <franz_> same
22:57:57 <wavewave> I am a linux user for 12 yrs and recently forced to use mac :-/
22:58:04 <franz_> I just like the stow-like feature
22:58:08 <franz_> of keeping stuff separate
22:58:10 <Axman6> forced? pfft
22:58:15 <franz_> never really "liked" macports
22:58:21 <franz_> and yeah, install linux on that then haha
22:58:22 <Axman6> franz_: me either
22:58:50 <lostman> wavewave: instead of homebrew/macports, try prefix-portage
22:59:00 <Axman6> i liked universal builds and the better package info with macports (port info foo would actually tell you what the package was)
22:59:06 <lostman> http://www.gentoo.org/proj/en/gentoo-alt/prefix/
22:59:07 <Axman6> shut up lostman :P
22:59:14 <franz_> lol
22:59:22 <lostman> Axman6: want to fight?
22:59:28 <Axman6> yeah you girl
22:59:30 <wavewave> lostman: hmm, that's gentoo thing?
22:59:47 <franz_> don't listen to him, get something made for os x lol
23:00:11 <lostman> wavewave: its the package management system from Gentoo linux; works perfectly well on mac
23:00:26 <lostman> * for some definition of "working perfectly well"
23:00:42 <Axman6> your description of it makes it even less appeaking man :P
23:00:42 <joe6> Axman6: any thoughts on the llvm linker error, please?
23:00:44 <Axman6> l*
23:00:46 <lostman> it might be tricky to install, but its worth it!
23:01:05 <djahandarie> Axman6, do you know lostman irl?
23:01:06 <Axman6> joe6: sorry, no idea :( what are you trying to build? i managed to just cabal install llvm
23:01:16 <wavewave> lostman: thanks for the info. 
23:01:18 <Axman6> djahandarie: he's sitting 1.5m to my right :P
23:01:22 <djahandarie> Figured haha
23:01:30 <lostman> djahandarie: yeah, he sits next to me right now
23:01:34 <joe6> Axman6: oh, really. That failed with an error for me.
23:01:42 <Axman6> joe6: what sort of error?
23:01:43 <joe6> Axman6: what version of llvm are you on?
23:01:50 <Axman6> 2.8
23:02:02 <wavewave> anyway, pretty interesting to explore mac world. 
23:02:35 <wavewave> first thing I will do is just to install xmonad. 
23:02:59 <Axman6> wavewave: my advice, don't try and turn your OS X into a linux distro like to many other linux users do. it'll frustrate you, it won't work
23:03:04 <joe6> Axman6: can you please do "make" in the llvm/examples directory
23:03:06 <Axman6> urgh, you're a lost cause already
23:03:18 <joe6> Axman6: i want to see how the examples work.
23:03:26 <Axman6> joe6: not really, i installed this on my macbook pro which is at home
23:03:39 <Axman6> wavewave: you know OS X doesn't use X right?
23:03:47 <Axman6> so Xmonad won't be any use to you
23:04:50 <wavewave> Axman6: For native mac app, yes I know.. Most likely, I will use xterm. :)
23:05:25 <lostman> wavewave: first thing you should do is install visor: http://visor.binaryage.com/
23:05:33 <wavewave> if I have firefox or google-chrome on X, then that's it. 
23:05:49 <Axman6> wavewave: urgh
23:06:01 * djahandarie wonders why you would even use a mac
23:06:10 <lostman> also, I don't think you can use xmonad with os x in any sensible way
23:06:11 * Axman6 wonders why you wouldn't
23:06:12 <djahandarie> Just can't reformat or something? < wavewave 
23:06:22 <djahandarie> Axman6, I mean with this plan
23:07:10 <wavewave> djahandarie: this is my university machine and I do not have admin control.
23:07:26 <djahandarie> Heh. :(
23:07:27 <wavewave> and some program I need is installed here, so.. 
23:07:48 <wavewave> I am linux-only user for 12 yrs. 
23:07:59 <djahandarie> I'd probably just deal with Mac then. It isn't *that bad*, just kind of inconvenient compared to what I'm used to
23:08:27 <wavewave> I know.. In fact, all I need first is haskell. 
23:08:42 <wavewave> xmonad or whatever is just a bonus :)
23:09:17 <Axman6> X11 is a second class citizen on OS X, just as it should be
23:09:50 <lostman> djahandarie: agree... os x is weird when you start using it, but then you get used to how it works and it sort of just makes sense
23:10:11 <djahandarie> Either way, not looking to start an OS holy war in here ;)
23:19:12 <wavewave> installed homebrew :-)
23:20:30 <wavewave> now after installing homebrew on my user directory, how can I install ghc?
23:20:59 <Axman6> brew install ghc
23:21:03 <wavewave> aha.. I see.
23:21:06 <wavewave> I just figured it out. 
23:21:09 <Axman6> or, even better, brew install haskell-platform
23:21:43 <wavewave> Axman6: thanks.. I am doing that.. 
23:23:58 <wavewave> btw, is there any project like making foswiki in haskell?
23:24:29 <wavewave> i know we have gitit, but.. 
23:24:50 <wavewave> i like the idea of programmable wiki. 
23:25:14 <NemesisD> any of you happen to know anything about Text.JSON?
23:25:33 <Axman6> what's foswiki?
23:25:44 <wavewave> it's free open source wiki. :)
23:25:57 <wavewave> it's a successor of TWiki. 
23:25:58 <Axman6> why on earth would we need another one of those?
23:26:13 <wavewave> it's written in Perl, but quite slow.
23:26:34 <joe6> Implicit import declaration:  Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-1.1.0.0
23:26:40 <keep_learning> Axman6, your IO tutorial was too good 
23:26:42 <wavewave> I think TWiki/foswiki is quite unique among wikis. 
23:26:48 <joe6> any suggestions, on how I can fix the error, please?
23:26:52 <keep_learning> Axman6, i enjoyed it too much 
23:26:56 <Axman6> keep_learning: too good? D: oh no!
23:27:17 <keep_learning> Axman6, yes and infact now i started reading too much impure code :P
23:27:24 <wavewave> because it has lightweight macro system. 
23:27:40 <Axman6> noooooooo!
23:27:42 <wavewave> each wiki page can be regarded as a program.
23:27:44 <pelotom> hey, does anyone have a pdf of this paper or know where to find one? http://portal.acm.org/citation.cfm?id=5288
23:29:06 <keep_learning> Axman6, *reading was infact writing 
23:29:08 <wavewave> anyway, I think haskell's EDSL is perfect for this macro-able wiki.
23:29:36 <wavewave> write haskell code as a wiki command.
23:30:21 <wavewave> yeah! I got ghc now.
23:31:29 <Axman6> heh, ad in pastebin.com: Do you think in closures? We do too. Haskell programmers welcome! janestreet.com
23:32:50 <Gracenotes> I forget, is modal logic significant in any curry-howard sense?
23:33:17 <Gracenotes> someone I know apparently loves loves modal logic
23:34:24 <wavewave> cabal is so beautiful. 
23:34:38 <Gracenotes> hmmmm.. apparently it's not as specific to first-order logic as I thought
23:35:12 <Axman6> wavewave: you obviously haven't used cabal very much :(
23:35:32 <Gracenotes> :D the scale of its whole-system shared-library approach is not something you see every day
23:35:46 <pelotom> Gracenotes: the answer I accepted here mentions some modal logic concepts: http://stackoverflow.com/questions/2969140/what-are-the-most-interesting-equivalences-arising-from-the-curry-howard-isomorph
23:36:11 <Gracenotes> wow
23:36:44 <Gracenotes> nice
23:38:23 <dabblego> why IntMap instead of Sequence?
23:39:21 <Axman6> they serve different purposes no?
23:39:48 <Axman6> intmap is a Map with Int keys, a Sequence is a data type that supports O(1) prepend and appent
23:39:51 <Axman6> append*
23:40:13 <dabblego> Sequence has efficient lookup by Int
23:43:16 <joe6> i have a bunch of packages failing with this: http://pastebin.com/Jh0EnBZA
23:43:44 <joe6> any suggestions, please? i tried putting import Base.Prelude to a .hs file, but I am not sure which .hs file it is talking about.
23:44:14 <joe6> cpphs, MissingH are the 2 packages that are failing with that message.
23:44:52 <Axman6> dabblego: i think IntMap is more efficient than a sequence
23:45:04 <Axman6> also, they don't server the same purpose
23:45:37 <Axman6> an IntMap stores int value keys. which may not be consequtive
23:45:51 <joe6> dankna: are you still around?
23:46:01 <Axman6> a sequence gives you a somewhat array like way to index values in it
23:53:07 <FunctorSalad> haha "goto | jumping to conclusions" (in that stackoverflow Q)
23:53:19 <FunctorSalad> (curry-howard)
23:55:32 * hackagebot warp 0.3.2.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.3.2.1 (MichaelSnoyman)
23:55:39 <pelotom> :D
