00:10:59 <joe6> i install the template-haskell library with "runhaskell setup.hs install", but when I run cabal install on a dependent package, it starts the build for template-haskell again.
00:11:24 <joe6> i can see the template-haskell install from ghc-pkg list 
00:11:54 <joe6> is there a way to clean cabal failed installs?
00:14:57 <FunctorSalad> joe6: you should use the template-haskell version that comes with the ghc version you're using, not install template-haskell separately
00:15:20 <shachaf> A
00:15:25 <FunctorSalad> (what does ghc-pkg check say?)
00:15:50 <shachaf> s/.*//
00:15:59 <FunctorSalad> :)
00:16:09 <joe6> FunctorSalad: llvm-extra is installing that. I think there is a dependency of some sort.
00:16:39 <joe6> FunctorSalad: no output from ghc-pkg check
00:17:15 <joe6> FunctorSalad: as the dependency was failing, I installed it manually.
00:17:22 <FunctorSalad> hmm ok, no output means that no packages are broken
00:18:03 <joe6> is there a cache of previously failed installs that cabal keeps?
00:18:17 <joe6> and just goes back to restart when the same command is given?
00:19:37 <FunctorSalad> (to my knowledge, there isn't anything you can do if something depends on a template-haskell version that's different from the one built into your ghc, except update the depending package (if it depends on an older th) or ghc (if it depends on a newer one))
00:20:30 <joe6> FunctorSalad: the catch is that it is not different. It was failing and I untarred and installed it, to get through the failure.
00:20:45 <FunctorSalad> hmm strange, "cabal install --dry llvm-extra" tells me it's going to reinstall 2.5.0.0 too
00:20:47 <joe6> When I run cabal install llvm-extra again, it tries to install th again, the same version too.
00:20:53 <FunctorSalad> (which is the th I have)
00:20:58 <FunctorSalad> no idea then
00:21:08 <joe6> FunctorSalad: yes, that is what I am talking about.
00:23:03 <FunctorSalad> maybe it's trying to recompile th against container-0.3.0.0
00:23:30 <FunctorSalad> since llvm-extra depends on containers < 4
00:23:39 <FunctorSalad> I mean < 0.4
00:24:38 <FunctorSalad> you could try relaxing the llvm-extra -> containers dependency to allow containers-0.4.0.0
00:26:23 <joe6> oh, ok. will check up on that.
00:26:29 <joe6> thanks for that.
00:27:39 <joe6> FunctorSalad: doing the llvm-extra build by hand. if that fails, will do what you recommend.
00:28:12 <FunctorSalad> I meant by hand too... cabal unpack llvm-extra, then edit the cabal file
00:28:27 <FunctorSalad> I don't think it's possible via cabal command-line options
00:30:26 <joe6> yes, i understand that. I was doing the "runhaskell..." on each of the dependencies.
00:31:41 <joe6> yes, now I see the error that you are talking about.
00:32:40 <FunctorSalad> ah, installing the dependencies separately may not work properly because if A depends on B and C, and B depends on C, you may be building B against C-1.0, but A may demand C-2.0
00:32:57 <FunctorSalad> so when you try A again, it will rebuild B against C-2.0
00:32:59 <joe6> FunctorSalad: but, it gives a better error message.
00:33:14 <joe6> and I changed the .cabal file as you recommended.
00:33:53 <FunctorSalad> btw, that only applies if your ghc uses containers-0.4 of course :)
00:34:08 <FunctorSalad> (I think that is the case since ghc 7, but maybe earlier)
00:34:09 <joe6> i am sure there is a way to see the configure error message from cabal too..
00:34:13 <joe6> but i do not know that.
00:34:21 <joe6> ok, thanks.
00:57:12 <joe6> any suggestions on how I can fix this message, please: source http://pastebin.com/24xkSd5Z  , error http://pastebin.com/GxAz9Lnx
00:57:29 <joe6> in brief, about   Ambiguous type variable `s1' in the constraints:
01:05:41 <akamaus> Hi! I have ghc-6.12.1, binary-0.5.0.2 and bytestring-0.9.1.5 installed. But ByteString lacks the Binary instance. Why is that?
01:18:05 <quicksilver> akamaus: bytestring doesn't really need a binary instance.
01:18:22 <quicksilver> akamaus: a binary instance is a way of converting something to a bytestring, but a bytestring already is a bytestring...
01:19:02 <merijn> Can someone give me a short explanation of what the uniqueness of identity proofs entails? Google is suitably useless as usual...
01:20:40 <akamaus> quicksilver, well, http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html states bytestring has one
01:21:06 <quicksilver> akamaus: maybe you need a different version of bytestring.
01:21:08 <quicksilver> (I don't know)
01:21:44 <FunctorSalad> doesn't it still need one to be self-delimiting?
01:22:57 <quicksilver> FunctorSalad: well, yes you'd need to put a length indicator in some form.
01:23:02 <akamaus> quicksilver, please try :i Binary in ghci. Do you have the instance for bytestring?
01:23:03 <quicksilver> FunctorSalad: but Binary isntances are basically a bad idea.
01:23:25 <quicksilver> akamaus: I don't have binary installed :P
01:23:48 <quicksilver> akamaus: I'm guessing that the binary instance exists in bytestring-0.9.1.8 but not 0.9.1.5 but I can't easily check that.
01:24:00 <quicksilver> I recommend using Get + Put directly and ignoreing hte binary class
01:24:12 <quicksilver> (except, possibly, as a simple source of Get + Put methods for simple types)
01:24:45 <FunctorSalad> akamaus: do you have Data.ByteString imported?
01:24:46 <akamaus> I looked at the source documentation, it's the binary module who defines instances
01:25:07 <FunctorSalad> it does, but I think ghci only *shows* instances for types in scope
01:26:11 <quicksilver> the binary module has a particular broken instance for bytestring.
01:26:16 <quicksilver> it's not 32/64bit sane.
01:26:20 <quicksilver> safe.
01:26:48 <quicksilver> put (fromIntegral (L.length bs) :: Int)
01:27:37 <ddarius> merijn: Just consider id . id' where id and id' both satisfy the identity laws.
01:30:12 <akamaus> FunctorSalad, yes I do. Moreover, I've tested on my second near identical system, it has the instance. That's strange. Probably I should look closer at installed packages
01:30:52 <FunctorSalad> akamaus: I did :m +Data.Binary Data.ByteString ; :i ByteString and it shows up
01:31:28 <FunctorSalad> binary-0.5.0.2
01:32:00 <merijn> ddarius: So pretty much just the notion of having id and id', both satisfying the identity laws but not being equal is silly
01:32:47 <FunctorSalad> (maybe the instance is conditionally compiled due to what quicksilver just mentioned? random guess)
01:32:51 <merijn> And then of course mathematicians have to ruin my day by claiming such an intuitive notion doesn't necessarily hold...
01:34:46 <FunctorSalad> nevermind, apparently that isn't the case
01:35:13 <akamaus> FunctorSalad, And I have this: http://hpaste.org/43876/instance_binary_bytestring_is
01:37:15 <FunctorSalad> merijn: the point is to show that if you have two, they *are* equal
01:37:38 <ddarius> merijn: There's no need to set it up as a contradiction problem, just say id and id' both satisfy the identity laws then id = id . id' = id'.
01:39:45 <Saizan> quicksilver: isn't put for Int 32/64 bit safe?
01:39:48 <FunctorSalad> ddarius: btw, I think merijn means something else, like forall a b. forall p1 p2 : a = b, p1 = p2
01:40:15 <FunctorSalad> (p1 and p2 being proofs)
01:40:23 <merijn> FunctorSalad: Well, as far as I understood what I've been reading the entire point is that showing that id and id' are equal is non-trivial (at least not derivable within the type theory where they are used)
01:40:57 <FunctorSalad> (but I don't know what exactly that principle entails)
01:43:19 <ddarius> merijn: http://flint.cs.yale.edu/cs428/coq/doc/faq.html#htoc40
01:44:28 <merijn> ddarius: Thanks
01:45:33 <ksf> @pl (\(Iteratee it) -> it >>= g)
01:45:33 <lambdabot> (line 1, column 13):
01:45:33 <lambdabot> unexpected "i"
01:45:33 <lambdabot> expecting operator or ")"
01:45:49 <ksf> @pl (\( it) -> it >>= g)
01:45:50 <lambdabot> (g =<<)
01:46:15 <merijn> :t (=<<)
01:46:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
01:46:42 <ksf> @pl (x -> f x)
01:46:43 <lambdabot> (line 1, column 4):
01:46:43 <lambdabot> unexpected ">"
01:46:43 <lambdabot> expecting variable, "(", operator or ")"
01:46:47 <ksf> @pl (\x -> f x)
01:46:48 <lambdabot> f
01:46:59 <ksf> what am I thinking
01:47:35 <akamaus> FunctorSalad, I reinstalled both binary and bytestring and all is ok now.
01:49:07 <harlekin> I get the error "inferred type is less polymorphic than expected" here http://hpaste.org/43879/less_polymorphic in the function named value. Can anyone tell me what exactly that means?
01:50:25 <harlekin> GHC reports, that s begin mentioned in line 7, 8 and 1 is causing the problem.
01:50:45 <Cale> can you give more of the error message?
01:51:06 <Cale> It means that you supplied a type signature which was more polymorphic than the actual type of the definition you wrote
01:51:48 <harlekin> Cale, http://hpaste.org/paste/43879/less_polymorphic_annotation#p43880
01:52:25 <harlekin> Cale, I kind of get what it means. But I don't see where I am ,,more polymorphic" than I expected myself to be.
01:53:41 <ksf> Is there a standard class that gives me mempty, but not mappend?
01:54:27 <Saizan> not anymore, unless edwardk has a FunctorZero somewhere
01:54:51 <ksf> ...that'd be essentially a typeclass for Maybe
01:55:03 <ksf> how was that package called that gives typeclasses for bool etc?
01:55:40 <ksf> yep, it's in Control.Functor.Extras
01:55:47 <quicksilver> Saizan: well it's not that 'put' is unsafe.
01:55:56 <Cale> harlekin: Where's the definition of this type with the envSupplies field?
01:55:58 <quicksilver> Saizan: it's that it always 'put's the length as an Int, which is not a fixed length.
01:56:17 <quicksilver> Saizan: so a ByteString "putted" on a 32 bit machine can't be "getted" on a 64 bit machine.
01:56:21 <harlekin> Cale, http://hpaste.org/paste/43879/less_polymorphic_annotation#p43881
01:56:25 <quicksilver> Saizan: that's not good for a file format or a network protocol.
01:56:37 <quicksilver> Saizan: (might be OK for session caching in a webserver or some other application)
01:56:57 <Cale> okay, so the envSupplies field must consist of a polymorphic list of elements?
01:57:19 <Cale> harlekin: Are you sure this is really what you want?
01:57:57 <ksf> .oO( typeclass synonyms )
01:58:21 <harlekin> Cale, I hope so. :D I want to maintain a Map of keys to state. I want my keys to be expandable using a class and for every key has only one state.
01:58:32 <harlekin> It hought I could express that with the forall a s . Suplly a s.
01:58:45 <harlekin> (And the fun-dep in class Supply)
01:59:05 <Saizan> quicksilver: "instance Binary Int where put i = put (fromIntegral i :: Int64)" so it shouldn't matter
01:59:57 <ksf> is category-extras supposed to work with mtl 2?
02:00:28 <Cale> harlekin: So the list you supply must be so polymorphic that 'a' and 's' can be any types for which there's an instance of Supply, and the same definition will work.
02:00:34 <quicksilver> Saizan: Oh. My mistake in that case. Apologies ;)
02:00:47 <Cale> Just a specific instance of Supply won't do.
02:01:40 <harlekin> Cale, I think I'm getting to see the problem. I cannot extract a specific a from the list if I use forall, right?
02:01:58 <Cale> harlekin: So since supply in the line: put $ st { envSupplies = (supply, ref):envSupplies st } is going to be some specific type of value, you can't just add it to the list there
02:02:17 <Cale> You can extract all you want, at any type you want.
02:02:30 <Cale> It's just hard to put stuff in because that stuff has to be extremely polymorphic
02:02:46 <harlekin> Cale, I see. Thanks.
02:04:14 * ksf doesn't like that Functor f =>  context of FunctorZero
02:06:33 <aristid> ksf: what's FunctorZero? it's not in hoogle
02:08:42 <ksf> category extras
02:08:42 <ufopp> ls
02:08:47 <ksf> mempty without mappend
02:10:39 <kaf3ii> is there a "CInt -> Char" function ? 
02:10:41 <aristid> ksf: there's some Default class or such somewhere
02:10:44 <aristid> @hoogle Default
02:10:45 <lambdabot> Data.ByteString.Lazy.Internal defaultChunkSize :: Int
02:10:45 <lambdabot> Text.Regex.Base.RegexLike defaultCompOpt :: RegexOptions regex compOpt execOpt => compOpt
02:10:45 <lambdabot> Codec.Compression.GZip DefaultCompression :: CompressionLevel
02:11:04 <aristid> kaf3ii: chr . fromIntegral
02:11:13 <aristid> :t chr . fromIntegral
02:11:13 <lambdabot> forall a. (Integral a) => a -> Char
02:11:15 <ksf> I'd rather have Nullable
02:11:18 <kaf3ii> aristid: thanks
02:11:24 <ksf> that is, empty and null
02:11:25 <ksf> :t null
02:11:26 <lambdabot> forall a. [a] -> Bool
02:11:35 <ksf> aka maybe
02:12:11 <ksf> :t maybe
02:12:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:12:15 <aristid> ksf: write it.
02:12:18 <ksf> ...just make that a typeclass
02:12:29 <ksf> well...
02:12:56 <ksf> in principle, you're right, in practice I can give null a default implementation a class further down the hierarchy.
02:13:01 <ksf>     null = decons False (const . const $ True)
02:13:46 <ksf> I'm just not going to care, for now.
02:35:53 * paolino guesses haskell jedis put language extensions at the beginning of a module before the compiler complains
02:36:21 <merijn> I think it's mandatory to have language extension pragma's at the start of a file
02:36:41 <ksf> {-# LANGUAGE AbsoluteSithStatements #-}
02:37:09 <aristid> Sith?!
02:37:26 <ksf> only siths deal with absolutes.
02:37:31 <aristid> wtf
02:37:37 <aristid> i don't get the joke
02:38:09 <ikeg> I watched the Haskell Platform Trac. What does mean 'Blue Sky'? : http://trac.haskell.org/haskell-platform/milestone/Blue Sky
02:38:29 <ikeg> %20
02:39:07 <ikeg> i guess tickets not tie together the version...
02:39:59 <paolino> back to computation, what is the least complex implementation of holing :: [a] -> [(a,[a])] ?
02:40:23 <ksf> ikeg, http://www.alphadictionary.com/goodword/word/blue-sky
02:40:52 <ikeg> ksf: thanks, aha!
02:41:22 <ikeg> i am look forward to the next Haskell platform
02:41:38 <ksf> ...be glad that you're not looking at the _|_ milestone
02:41:55 <paolino> holing' ys (x:xs) = (x,reverse ys ++ xs):holing' (x:ys) xs is my guess
02:42:56 <paolino> I wonder how it competes with threading (ys ++ [x])
02:43:26 <paolino> and not using reverse
02:48:50 <jonkri> @type Reader
02:48:51 <lambdabot> Not in scope: data constructor `Reader'
02:49:23 <jonkri> has Reader been replaced by ReaderT or something? if not, how can "readerTest :: Reader Int String" fail with a `Reader' not in scope type error when i import Control.Monad.Reader?
02:50:48 <quicksilver> jonkri: works for me.
02:50:59 <quicksilver> jonkri: maybe you didn't import the type from the module?
02:51:11 <ksf> type Reader r = ReaderT  r Identity
02:51:15 <ksf> http://hackage.haskell.org/packages/archive/mtl/2.0.0.0/doc/html/Control-Monad-Reader.html
02:51:49 <quicksilver> yeah, in mtl-2 it's a type synonym, in mtl-1 it's a newtype
02:51:51 <quicksilver> but it exists in both.
02:56:33 <jonkri> quicksilver: i imported the whole module. if i import Reader specifically the import line doesn't cause an error; the error is on the readerTest :: Reader Int String line
02:57:32 <quicksilver> jonkri: show the code.
02:57:40 <jonkri> i;m trying to follow the tutorial at http://www.maztravel.com/haskell/readerMonad.html , maybe it's outdated
02:58:56 <jonkri> quicksilver: import Control.Monad.Reader | readerTest :: Reader Int String | readerTest = let f x = show (x + 1) in Reader f
02:59:11 <quicksilver> jonkri: the error is "Reader f"
02:59:18 <quicksilver> the type signature is fine.
02:59:29 <quicksilver> jonkri: it's just that Reader is not a constructor.
02:59:38 <jonkri> oops
03:00:23 <quicksilver> there is a 'pseudo constructor' called 'reader'
03:00:26 <quicksilver> small r.
03:00:34 <quicksilver> "reader f" might work.
03:01:01 <jonkri> it did. thanks
03:01:27 <jonkri> @type reader
03:01:43 <lambdabot> forall r a. (r -> a) -> Reader r a
03:02:18 <aristid> :t asks
03:02:19 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
03:02:25 <quicksilver> jonkri: well, that's not really the supported way to build readers
03:02:28 <aristid> :t asks :: (r -> a) -> Reader r a
03:02:30 <lambdabot> forall r a. (r -> a) -> Reader r a
03:02:40 <aristid> so reader = asks
03:03:16 <quicksilver> the 'normal' way is : { do e <- ask; return (show (e+1)) } 
03:03:33 <quicksilver> or ask >>= show . (+1) if you like such things.
03:03:53 <quicksilver> or asks (show . (+1)) indeed
03:04:00 * quicksilver hopes he got all those types right.
03:06:43 <aristid> quicksilver: i think you got the second one wrong.
03:06:57 <aristid> it would have to be (show . (+1)) <$> ask
03:07:10 <quicksilver> oh yes, I can't elide the return.
03:07:17 <quicksilver> ask >>= return . show . (+1)
03:07:28 <aristid> i want left-to-right fmap :)
03:13:04 <jonkri> i want to construct a LoggerT (newtype LoggerT m a = LoggerT (ReaderT (LogMessage -> IO ()) m a)) with an "askable" LoggerState. how should i do this? does it make sense to create a function that calls runReader?
03:14:08 <jonkri> like runLoggerT?
03:14:42 <aristid> is there an English/Maths name for Control.Category.Category's (<<<)?
03:15:48 <accel> Bynbo7: ping
03:16:04 <accel> xplat: ping
03:18:46 <ddarius> aristid: "compose"
03:19:02 <aristid> ddarius: thanks
03:19:32 <aristid> :t (<=<)
03:19:33 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
03:20:00 <shapr> ddarius: Dude, when do you sleep? I respect your #haskell-fu is stronger than mine!
03:22:08 <accel> wtf is a monad transfer; is it like a moand inheriting from anotner monda?
03:23:32 <accel> window 3
03:24:38 <aristid> accel: you mean a monad transformer?
03:24:59 <aristid> accel: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
03:25:05 <accel> yeah, monad transformers
03:25:40 <lostman> accel: http://book.realworldhaskell.org/read/monad-transformers.html
03:26:02 <accel> lostman: yeah; I was reading the chapter in RWH
03:26:07 <accel> lostman: and I still don't get the motivation
03:26:16 <ddarius> shapr: Actually, lately I've been falling asleep pretty much when I get home.  It's kind of annoying since I haven't gone grocery shopping in a while and when I wake up nothing is open, so I have no food.
03:26:28 <accel> lostman: perhaps it'll make sense after I've used moands enough to go "damn, I have all this repetition, I wish I could do X ... and then X turns out to be reinventing monad tranformers"
03:27:07 <aristid> accel: yeah, that's pretty much it.
03:27:07 <lostman> accel: its just using more than one monad at the same time
03:27:13 <ddarius> shapr: On the plus side, this gives me plenty of time to shave which is good because straight razor shaving can't be rushed.
03:27:35 <lostman> StateT is a good example
03:28:07 <aristid> :t execStateT
03:28:07 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
03:28:28 <lostman> there used to be State monad but it rarely made sense to have something using just State and nothing else
03:29:11 <lostman> so now its StateT; because you usually want to add state to something
03:29:17 <shapr> ddarius: Yah, Boston/Somerville is weird about everything being closed after 10pm or so. Lots of good places for food here, but nothing has wifi for #haskell coding :-(
03:30:36 <aristid> shapr: be glad you're not in vienna, where everything closes at 6-7 pm :D
03:32:04 <shapr> I'd rather find people who want to sit around and write Haskell with me at an all-night coffee shop.
03:32:20 <lostman> shapr: what?! no friendly neighborhood Starbucks?
03:32:43 * ddarius doesn't think he's ever been to an "all-night" Starbucks.
03:32:56 * ddarius has been kicked out of Starbuckses before though.
03:33:13 <shapr> lostman: Nah, I'm in 35630
03:46:24 <jonkri> @type pure
03:46:25 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
03:46:47 <accel> @src pure
03:46:47 <lambdabot> Source not found. I am sorry.
03:47:33 <shapr> @src Data.Arrow.pure
03:47:34 <lambdabot> Source not found. That's something I cannot allow to happen.
03:47:38 <shapr> @hoogle pure
03:47:38 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
03:47:49 <shapr> @src Control.Applicative.pure
03:47:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:47:53 * shapr smacks lambdabot 
03:48:08 <ddarius> shapr: pure is a method.
03:49:49 <quicksilver> also, @src is almost-useless :) 
03:49:59 <quicksilver> what would be much more useful would be an extensnion to @hoogle that contained the link
03:50:03 <quicksilver> (like the online hoogle does)
03:50:13 <quicksilver> (in this case, to http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:pure )
03:50:20 <ddarius> quicksilver: Feel free to hack lambdabot.
03:50:36 <shapr> I tried to hack lambdabot recently, was total fail because of cabal install problems.
03:50:47 <dcoutts> :-(
03:50:51 <jonkri> is it correct that pure Just returns nothing in ghci?
03:51:36 <dcoutts> :t pure Just
03:51:36 <dcoutts> pure Just :: (Applicative f) => f (a -> Maybe a)
03:51:37 <lambdabot> forall a (f :: * -> *). (Applicative f) => f (a -> Maybe a)
03:51:51 <homie> :t pure
03:51:52 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
03:51:53 <dcoutts> jonkri: which can be defaulted to IO
03:52:01 <quicksilver> well, ghci assumes IO monad if it doesn't know better
03:52:10 <quicksilver> so that is "return (Just)" :: IO (a -> Maybe a)
03:52:17 <quicksilver> i.e. you're returning the function into IO
03:52:22 <quicksilver> and there isn't a Show instance for functions
03:52:25 <quicksilver> so ghci is silent.
03:52:54 <quicksilver> ddarius: quite. Sadly, not enough time, I don't think this is an easy fix.
03:53:07 <quicksilver> ddarius: (because lambdabot uses the offline hoogle I don't think it has access to those links)
03:58:08 <dibblego> do any of you have xmobar checking your gmail with a template?
04:08:20 <Saizan> quicksilver: it depends on how the hoogle database got built, the default one has them, you need to invoke hoogle with --info
04:08:37 <ksf> Control.Monad.Trans.Peel is really nice
04:09:09 <ksf> it's one of those things that are too easy to be obvious
04:09:16 <ksf> or rather, simple.
04:12:38 <Saizan> @hoogle --info pure
04:12:39 <lambdabot> Parse error:
04:12:39 <lambdabot>   --count=20 "--info pure"
04:12:39 <lambdabot>              ^
04:13:17 <quicksilver> Saizan: ah, interesting. Might be quite a small change.
04:14:07 <quicksilver> Saizan: (unless LB is using an older hoogle which IIRC it was at one point)
04:20:01 <Saizan> i guess the command could be called @haddock
04:23:29 <accel> weird question: does haskell provide deconstructors? i.e. [brickProg] <- genObjectNames 1 ... this brickProg is an integer, but it holds an opengl reference, and when this brickProg is no longer needed, I want deleteObjectNames [brickProg] to be called
04:25:10 <aristid> ksf: peel :: (Monad m, Monad n, Monad o) => t n (t m a -> m (t o a))
04:25:15 <aristid> ksf: that type is NOT simple
04:26:18 <aristid> hmm, i wonder how haskell code would look if it had native support for kleisli arrows
04:26:45 <Bynbo7> accel: ForeignPtr's are a pointer with a destructor which is called by the GC when it sees something is out of scope i believe
04:26:50 <aristid> :k Kleisli
04:26:51 <lambdabot> (* -> *) -> * -> * -> *
04:27:07 <aristid> Kleisli m (t m a) (t o a)
04:32:15 <quicksilver> Saizan: well there is also @docs and @index
04:32:33 <Saizan> @docs pure
04:32:33 <lambdabot> pure not available
04:32:41 <Saizan> @docs Data.List
04:32:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
04:32:45 <quicksilver> @index pure
04:32:46 <lambdabot> Control.Arrow
04:32:49 <quicksilver> @docs Control.Arrow
04:32:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
04:32:56 <quicksilver> (it's wrong, you'll observe :P )
04:33:15 <Saizan> heh
04:33:39 <Saizan> it should just replace @docs then :)
04:34:03 <quicksilver> rather than have 3-4 different commands with related functionality
04:34:05 <aavogt> accel: you could use these instead of integer http://haskell.org/ghc/docs/latest/html/libraries/base-4.3.0.0/Foreign-ForeignPtr.html
04:34:22 <quicksilver> it would be nice to havea  single one which you can give an indentifier or a type or a module
04:34:29 <quicksilver> (or a class, etc...)
04:34:39 <quicksilver> and expect to get (a) some useful information and (b) a link to more information.
04:34:51 <quicksilver> hoogle seems like a promising starting point since it already works for most of those things
04:37:32 <aristid> quicksilver: maybe a new bot that is more maintainable would help?
04:38:43 <Saizan> we could sort of combine @index and @docs by taking the output of hoogle --info and stripping the haddock comments away, the output would probably take 2 lines
04:38:52 <hellohaskell> hey
04:39:06 <hellohaskell> why 'fst' works only with 2-argument tuples?
04:39:15 <hellohaskell> i cannot do something like: fst (1,2,3)
04:39:19 <Saizan> and it seems it's giving precendence to modules, so hoogle --info Monad points to Control.Monad rather than the Monad class
04:39:20 <quicksilver> Saizan: and it would work for a wide range of things
04:39:49 <quicksilver> hellohaskell: because it has a simple type: fst :: (a,b) -> a
04:40:29 <hellohaskell> ok, thanks
04:40:35 <quicksilver> hellohaskell: the different sized tuples are unrelated types as far as haskell is concerned, although you can imagine type classes to unify them. (There are a couple of libraries on hackage which do this)
04:41:17 <hellohaskell> i'm trying to learn some functional programming and i choosed Haskell for that
04:41:29 <hellohaskell> is it a good choice?
04:41:42 <quicksilver> I think so :)
04:42:07 <hellohaskell> could You recommend me any online-resources about funcional programming with exampels in Haskell?
04:42:12 <kuribas> hellohaskell: As functional as you can get :)
04:42:26 <quicksilver> hellohaskell: http://learnyouahaskell.com/ is good
04:42:37 <quicksilver> although it's about haskell programming specifically not functional in general.
04:44:34 <hape01> I have three datatypes A, B, C of type data A = A_ Int; data B = B_ Int; data C = C_ Int . I want having a heterogenoues list of .e.g.  three elements of type A, A, B  .    When I say  let l = [A 1, A 2, B 1] he says that he cant match expected type A against inferred type B.  Who do i mix different element types in one list?   Do I need an abstract data type  data X = A | B | C ?
04:44:35 <hellohaskell> thanks a lot
04:46:02 <hape01> Sorry: "How do i mix different element types in one list?"
04:46:07 <hape01> Sorry: "*How do i mix different element types in one list?"
04:46:11 <hape01> Sorry: "*How* do i mix different element types in one list?"
04:46:29 <earthy> hape01: you don't
04:46:47 <earthy> you put the element types that you want to mix in a union type and put elements of the union type in the list
04:46:52 <Zao> hape01: Lists are homogeneous.
04:47:07 <hape01> earthy, zao: Ok i need an union type.
04:47:19 <Saizan> hape01: yep
04:47:20 <earthy> so, make data AorBorC = IsA A | IsB B | IsC C
04:47:28 <hape01> type data x = A | B | C.   Then X is an union type.
04:47:37 <hape01> no
04:47:39 <hape01> oops
04:47:46 <hellohaskell> another question, i don't example how 'let' works, I put something like that: 'let x=4 in x*x', Haskell showd me '16'
04:47:49 <earthy> you need distinguishing constructors. ;)
04:47:55 <hellohaskell> but i still cannot use x
04:48:05 <earthy> well, you just did!
04:48:07 <Zao> hellohaskell: Use where?
04:48:21 <hellohaskell> Zao: in any expression
04:48:26 <Zao> hellohaskell: You can use it anywhere inside the 'in' expression.
04:48:32 <earthy> > let x = 4 in {- scope where you can use x -} x * x
04:48:32 <hellohaskell> imo x+5 should return me 9, right?
04:48:33 <lambdabot>   16
04:48:44 <Zao> hellohaskell: Show code where you attempt to do this, and fail.
04:48:52 <Zao> (hpaste is nice)
04:49:09 <aavogt> > (let x = 4 in x, x :: Integer)
04:49:10 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
04:49:10 <lambdabot>         against inf...
04:49:22 <Saizan> hellohaskell: the definition of 'x' is visible only inside the expression enclosed in the 'in'
04:49:35 <hellohaskell> Zao, i'm just putting in terminal 'let x = 4 in x*x' [enter] 'x+5'
04:49:46 <earthy> aavocht :: (let (x = 4 :: Integer) in x)
04:49:59 <earthy> (there may be too many parentheses there
04:49:59 <earthy> )
04:50:08 <Zao> hellohaskell: I assume you mean GHCi.
04:50:14 <Zao> Or Hugs, or whatever.
04:50:22 <hellohaskell> Zao, yup
04:50:36 <earthy> yeah, that's a confusing bit of behaviour
04:50:41 <Zao> In GHCi you can just say   let x = 9001
04:50:47 <Zao> And then use it forever after that.
04:50:57 <earthy> let without in binds a name in the toplevel environment
04:51:08 <earthy> let with in makes a name available in the expression after in
04:51:10 <hellohaskell> so why should i use "in" ?
04:51:21 <earthy> hellohaskell: to not pollute the toplevel environment
04:51:45 <earthy> plus, the let without in only works inside do blocks in the ordinary syntax
04:51:51 <earthy> whereas the let with in works in pure settings
04:52:07 <hellohaskell> oh, now i see that
04:52:17 <hellohaskell> but how can i put more instructions after "in"?
04:52:35 <earthy> what do you mean with 'instructions'
04:52:56 <earthy> > let x = 4 in ( x * x , x + 5, sqrt(x) )
04:52:57 <lambdabot>   (16,9,2.0)
04:53:17 <earthy> that's a single expression generating a tuple of 3 values
04:53:21 <Bynbo7> > let x = 7; y = 4 in x^y
04:53:22 <lambdabot>   2401
04:53:44 <hellohaskell> earthy, yup, something like that, thanks
04:54:11 <hape01> earthy, zao, Saizan: Thank you for your help with union types. that seems to work well.. :-)   is it correct that I have to set parantheses around... eg .   let l = [  IsA (A_ 10), IsB (B_ 20)  ]  ?
04:54:30 <earthy> yup
04:54:33 <Zao> hape01: Yes, as otherwise it's interpreted as (IsA A_) 10
04:54:45 <Zao> Well, IsA A_ 10, which is what I said.
04:55:12 <hape01> Zao: Without Parantheses I got errors
04:56:34 <hape01> let l = [  IsA A_ 10, IsB B_ 20  ]          leeds to errors 
04:56:44 <hape01> but     let l = [  IsA (A_ 10), IsB (B_ 20)  ]        works... 
04:57:00 <Zao> hape01: Which is because it's interpreted as IsA A_ 10, which is (IsA A_) 10
04:57:05 <Zao> Which clearly does not make sense.
04:57:26 <hape01> yes i understand now. I tested even with $ sign to separate. that seems to work also.
04:57:33 <hape01> well, thats fun :-) Thank you very much
04:58:03 <hape01> zao +1  :-)
05:05:29 <deech> Hi all, where can I learn more about dependent types? I know there's a bunch of papers floating around but are there any tutorials that speak to the application programmer?
05:06:27 <hape01> In a module I have exported an data type and want use that in an other module. In the other module, when I want use this data constructor, ghc says that this data constructor is not in scope....  Do I have to export data constructors in an special way?
05:06:50 <Zao> hape01: Yes.
05:07:00 <dafis> hape01: module Foo(Type(..)) where exports the constructors of Type
05:07:33 <dafis> hape01: or, if you want to export only some, list them explicitly: module Foo(Type(Con1,Con2)) where
05:08:10 <dafis> hape01: or leave out the export list entirely to export all top-level bindings of the module
05:10:01 <hape01> Zao, dafis: That is magic! Thanks for helping :-)
05:10:08 <dafis> de nada
05:25:45 <Saizan> deech: you could start with "why dependent types matter"
05:34:16 * hackagebot yesod-tableview 0.1.0 - Table view for Yesod applications  http://hackage.haskell.org/package/yesod-tableview-0.1.0 (ErtugrulSoeylemez)
05:44:54 <jonkri> @type ReaderT
05:44:55 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
06:12:28 * hackagebot data-rope 0.3 - Ropes, an alternative to (Byte)Strings.  http://hackage.haskell.org/package/data-rope-0.3 (PierreEtienneMeunier)
06:13:01 <jonkri> why do i get "couldn't match expected type LoggerState against inferred type `m a' in def :: IO (), def = do { logChannel <- newChan; loggerState <- LoggerState { channel = logChannel }; ...?
06:13:50 <Bynbo7> you probably want let loggerState = LoggerState ...
06:13:54 <Lemmih> jonkri: let loggerState = ...
06:14:44 <jonkri> oh thanks
06:16:34 <jonkri> why do i get parse error on anything i put below that line (let loggerState = LoggerState { channel = logChannel };), like "return ()"?
06:17:52 <dafis> jonkri: because by the semicolon, the compiler thinks the let continues
06:18:08 <dafis> jonkri: try without the semicolon
06:18:37 <dafis> or, let { loggerState = LoggerState {...}; }
06:20:22 <jonkri> :)
06:28:13 <quuuux> hi, I have a Haskell proxy sitting between my client and a service, but I'm finding that it's too slow (the latency could be better but I can live with it; it's the throughput that's really suffering). How can I investigate what's causing that in a multi-threaded STM application?
06:31:12 <ksf> @pl (\x xs -> result xs x)
06:31:12 <lambdabot> flip result
06:31:22 * ksf is the definition of laziness
06:33:45 <hpc> @pl \f x -> f x
06:33:46 <lambdabot> id
06:34:52 <ksf> you know what? I *hate* it when ghc doesn't accept the inferred type as type signature.
06:35:19 <hpc> example of that happening?
06:35:25 * hpc can't imagine that being possible
06:35:55 <ksf> an associated type is involved
06:36:00 <hpc> ah
06:36:04 <dafis> hpc: polymorphic recursion
06:36:05 * hpc doesn't extensions
06:36:36 <jonkri> why do i get "couldn't match expected type (LoggerState -> Chan LogMessage) -> t against inferred type LoggerState" at line 62 at http://paste.pocoo.org/show/336492/
06:36:47 <quuuux> there can also be issues with modules not exporting the types necessary
06:37:15 <hpc> jonkri: what's the type of loggerState, on line 62?
06:37:24 <ksf> nah, they're all locally defined.
06:37:24 <hpc> jonkri: then what's the type of ask
06:37:34 <jonkri> LoggerState?
06:37:47 <hpc> right, so now look at line 63
06:37:47 <ksf> loggerstate isn't a function
06:37:51 <ksf> but you're using it as one.
06:37:59 <ksf> "channel" is the argument
06:38:32 <dafis> I think it should be 'channel loggerState'
06:38:41 <jonkri> oh, channel should be the function!
06:39:03 <jonkri> it's a little inconvenient that the records you define (and the functions that are generated) cannot be checked in ghci
06:39:23 <hpc> sure they can
06:39:26 <hpc> :t runReaderT
06:39:27 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
06:39:29 <ksf> what do you mean by "checked" ?
06:39:37 <dafis> jonkri: what do you mean, 'cannot be checked in ghci'?
06:40:20 <ksf> quuuux, in general, threadscope
06:40:33 <jonkri> dafis: my bad, i must have tried when my code was not compiled
06:40:48 <dafis> aha
06:40:51 <ksf> my crystal ball is telling me that you want to deepSeq (or similar) your data structures before sending them over channels
06:41:24 * quicksilver borrows ksf's crystal ball and goes to buy a lottery ticket.
06:41:26 <ksf> as shovling data between cpus can easily eat all performance you get by going multithreaded
06:42:23 <quuuux> ksf: ooh. That looks interesting, thanks. And that's an entirely plausible explanation too
06:43:04 <ksf> quuuux, you might want to read the blog posts associated with combinatorrent, it's heavily multithreaded
06:43:09 <ksf> ...and *fast*
06:43:25 * Bynbo7 helped write some of that :)
06:43:36 <Bynbo7> only a little though, mainly the binary parsing stuff
06:43:58 <hpc> ksf: why would a torrent client take lots of cpu?
06:44:00 <ksf> deepseq'ing a map or such might be a bad idea, mind you, you don't want to force those things completely. just look up elements after inserting them and you're fine.
06:44:08 <hpc> or do i just suck at finding fast torrents?
06:44:37 <ksf> let's say it's using less cpu than any other client I know of
06:45:17 <ksf> it's very efficient when it comes to cpu/megabyte
06:45:18 <quuuux> ksf: nah, it's ADTs made of strings that get passed around in channels
06:45:59 <dafis> that might be suboptimal, performancewise
06:46:07 <ksf> you might want to make those bytestrings, as those are easier to shove from cpu to cpu
06:46:19 <ksf> but first have a look at those fancy threadscope graphs
06:48:23 <ksf> now ghc eats my type, with an added fundep.
06:48:54 <ksf> headI :: (Iteratee c i, Chunk c) => i (Elem c)
06:49:00 <ksf> I think that's about as clear as it gets
06:49:06 <quuuux> wow, glib is fussy to install. I had to chase 3 different dependencies manually
06:49:31 <dino-> Interesting, cabal list in cygwin fails somewhere in the lowercase d's with "<stdout>: invalid argument", but seems to know packages after that when I install one.
06:50:07 <dcoutts> perhaps a unicode encoding problem with cygwin
06:50:33 <dcoutts> dino-: what is the last one it shows?
06:50:35 <ksf> also,
06:50:38 <ksf> class Iteratee c i | i -> c where
06:50:38 <ksf>     step :: (c -> i a) -> i a
06:50:38 <ksf>     result :: c -> a -> i a
06:51:47 <Bynbo7> is this yet another iteratee library?
06:53:16 <HugoDaniel> yes
06:53:29 <copumpkin> I see
06:54:47 <Bynbo7> uh wow? 329 people split?
06:55:12 <dafis> Bynbo7: that's nothing
06:55:30 <dafis> occasionally, we're left with a dozen or so connected
06:55:49 <quuuux> is hackage down for anyone else?
06:56:04 <Bynbo7> dafis: when that happens, it means you've been split off, not everyone else ;)
06:57:29 <dafis> quuuux: It's just you. http://hackage.haskell.org is up. says downforeveryoneorjustme
07:00:25 --- mode: holmes.freenode.net set +o ChanServ
07:00:54 <dcoutts> dino-: how about zip-archive instead?
07:01:56 <dcoutts> dino-: it's pure Haskell, so should be much easier to build on windows
07:02:43 * dcoutts doesn't think much of any of the bindings-* packages
07:03:12 <dino-> It's coming from my dep on LibZip
07:04:11 <naypalm> http://hpaste.org/43883/another_one_joins_the_ranks
07:04:21 <naypalm> what am I doing wrong..
07:04:36 <dino-> Wow, loads of reconnecting going on here today
07:04:43 <Botje> you don't need the 'let' there
07:04:49 <Botje> you only need let if you're defining stuff in ghci itself
07:04:55 <naypalm> ok the let is gone
07:04:57 <naypalm> oh okay
07:05:19 <naypalm> it says indentation may be wrong?
07:05:19 <dino-> dcoutts: Will see if maybe I can adapt my thing to use zip-archive instead. Thank you
07:05:24 <quuuux> we have not offered sufficient sacrifices to shub-IRC recently
07:05:26 <naypalm> I said something up there before the mass join
07:05:43 <quuuux> naypalm: you're saving it as a .lhs file, right? And not .hs?
07:05:48 <tab> it's getting quite private here ..
07:05:50 <naypalm> yes I am
07:06:06 <dcoutts> naypalm: you don't need the let
07:06:08 <naypalm> I love the idea of latex or otherwise outlining your code lines
07:06:10 <naypalm> removed the let
07:06:22 <naypalm> code.lhs:7:1: parse error (possibly incorrect indentation)
07:06:42 <djl1> Remove the signature line
07:06:43 <quuuux> naypalm: oh. It's expecting you to define `main'
07:06:54 <djl1> ah, right
07:06:56 <naypalm> isn't that done with `> main`
07:07:13 <djl1> you have no body for it
07:07:40 <quuuux> right. `> main = return ()' should fix that
07:08:03 <naypalm> it did!
07:08:20 <naypalm> so what's going on here? main is a function that needs to be assigned?
07:08:26 <naypalm> jesus netsplit
07:08:41 <dafis> naypalm: main needs to be defined in C or Java too
07:08:46 <quuuux> naypalm: right. `main' is just a name
07:08:48 <naypalm> indeed
07:09:13 <dino-> But if you're just going to call that inc function from some other code, say, or from within ghci, you may not even need a main.
07:09:15 <naypalm> is the fact that `return ()` is required likely beyond my understanding at this point?
07:09:29 <ksf> when I have two MonadStates in my stack, how can I be oblivious of their order?
07:09:41 <djahandarie> naypalm, what 'main' is, is a 'recipe' for what to happen at runtime
07:09:51 <djahandarie> naypalm, return () is like a recipe that says "do nothing"
07:09:52 <naypalm> an entry point?
07:10:13 <dafis> naypalm: you just have to have a value for main (or you could remove the '> main' until you have a sensible main function)
07:10:28 <naypalm> ok
07:10:35 <dafis> naypalm: yes, entry point
07:11:11 <teki> suppose i have a tuple (IO a, IO b).  how can I make this into a IO (a,b)?
07:11:28 <dino-> dcoutts: Ah, I remember now. I did try to use zip-archive way back for this.
07:11:30 <quuuux> ksf: you can't if you leave them 'bare'. Wrap them in newtypes and define typeclasses for it
07:11:39 <quuuux> :t liftM2 (,)
07:11:39 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
07:11:47 <dafis> teki: foo (ma, mb) = liftM2 (,) ma mb
07:11:56 <quuuux> :t liftM2 (,) . uncurry
07:11:57 <lambdabot> forall a1 a2 a b. (a -> b -> a1) -> ((a, b) -> a2) -> (a, b) -> (a1, a2)
07:12:07 <dino-> What I found is that there seems to be quite a bit of sloppyness when zip files are created out there in the world.
07:12:16 <ksf> quuuux, graaagh
07:12:19 <dafis> :t uncurry (liftM2 (,))
07:12:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
07:12:39 <dino-> And while the C zip library seems to be quite capable of dealing with this disaster, that pure zip-archive not so much yet.
07:12:41 <djahandarie> If you want more than a 2-tuple, check out the Data.Tuple.Sequence in the tuple package on Hackage
07:12:46 <djahandarie> @hackage tuple
07:12:46 <lambdabot> http://hackage.haskell.org/package/tuple
07:13:03 <djahandarie> All you need to do if you have that is sequenceT (your,tuple,here)
07:13:20 <dcoutts> dino-: interesting, perhaps send the author some samples
07:13:34 <teki> djahandarie: i actually need a 4-tuple, but it's easier just to write a stupid little function to do that for me
07:13:35 <Saizan> ksf: http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html maybe
07:13:51 <dcoutts> dino-: e.g. for my tar package I've tried to have modes where it checks for strict compliance but also modes where it'll tolerate junk
07:14:11 <djahandarie> He was fast to leave :P
07:14:53 <dino-> dcoutts: It's kind of sad that these things are such a mess, and the world is full of invalid files that have to be worked with.
07:15:05 <dcoutts> dino-: aye
07:15:45 <ksf> Saizan, yep.
07:16:12 <ksf> ...though I prefer not using ints as state but newtypes
07:16:26 <ksf> so stuff auto-tags itself
07:17:01 <djahandarie> augustss should update tuple to work with nats instead of providing sel1, sel2, sel3, sel4, etc
07:20:52 <uberfry> hi everybody
07:20:57 <uberfry> can someone check this please? http://hpaste.org/43886/stirling_annotation
07:21:31 <Botje> note that n+k patterns are deprecated
07:21:34 <dafis> uberfry: needs NPlusKPatterns
07:21:50 <roconnor> stirling n n = 1 -- not legal
07:21:51 <uberfry> import NPulsKPatterns ?
07:21:54 <hpc> also, the second pattern isn't legal
07:22:02 <hpc> or you all can be ninjas :P
07:22:08 <uberfry> lolwut
07:22:11 <uberfry> rename them?
07:22:33 <dafis> uberfry: {-# LANGUAGE NPlusKPatterns #-}, but better rewrite it to not use them
07:22:49 <uberfry> rewrite to what please?
07:23:10 <dafis> uberfry: stirling n m | n == m = 1
07:23:18 <uberfry> ahhh ok thanks
07:23:21 <uberfry> I'll try sec
07:23:52 <dafis>      | otherwise = stirling (n-1) (m-1) + m*striling (n-1) m
07:25:35 <uberfry> thanks alot :0
07:25:36 <uberfry> :)
07:29:32 <dino-> Huh, didn't know you could do that, name to bind to given twice.
07:30:15 <dino-> It looks positively Erlangian
07:30:27 <djahandarie> Why does oleg avoid GADTs at all costs?
07:31:05 <dafis> a GADT stole his girlfriend?
07:31:33 <djahandarie> As far as I can tell it usually just makes his code more complex
07:32:46 <Saizan> djahandarie: "see, we can do everything you do with gadts without fancy type system extensions", talking about his finally tagless interpreters
07:33:01 <Saizan> a bit ironic, i'd say :)
07:33:06 <quuuux> hmm. It looks like my threads are spending a lot of time GCing
07:34:24 <djahandarie> He's using EmptyDataDecls, TypeOperators, and TypeFamilies in that code. All of those are just fancy extensions for convenience also
07:35:00 <hpc> why would he need EmptyDataDecls?
07:35:08 <hpc> all that does is let you make a bottom type
07:35:28 <hpc> wouldn't () have sufficed?
07:35:31 <Botje> he's kind of big on doing stuff in the type system, remember
07:35:41 <hpc> bleh
07:35:51 <hpc> doing stuff is what the values are for
07:35:55 <hpc> types just keep you sane
07:36:03 <djahandarie> A lot of people here would disagree with you ;)
07:36:05 * djahandarie included
07:36:22 <hpc> you all can use agda then >:3
07:36:34 * hpc should learn agda eventually
07:37:08 <djahandarie> Even in Haskell, types can write a lot of code for you
07:38:02 <hpc> djahandarie: i know, just being annoying
07:38:29 <hpc> much of the "doing stuff in the type system" that i have seen looks like it's trying to make the compiler turing-complete
07:38:49 <hpc> which seems counter-productive
07:38:57 <djahandarie> The type system has already been made turing-complete multiple times :P
07:39:17 <quuuux> multiply turing-complete is better than singly turing-complete!
07:39:35 <djahandarie> Nothing like an inconsistent type system!
07:39:38 <hpc> now we just need to make a halting oracle!
07:39:52 <hpc> then try and compile GHC with it XD
07:40:20 <Saizan> type system being inconsistent /= undecidable type checking
07:40:26 <copumpkin> you can do loads of great and useful stuff without the type system being turing complete
07:40:29 <Saizan> haskell 98 is already inconsistent :)
07:41:00 <djahandarie> Saizan, I know, but an inconsistent type system is required if you want to buring turing-complete (due to bottoms being required)
07:41:10 <djahandarie> ...how did 'buring' get in there?
07:41:13 <djahandarie> be*
07:41:27 <hpc> @wn buring
07:41:28 <lambdabot> No match for "buring".
07:41:32 <hpc> haha
07:42:46 <EvanCarroll> It just happened -- Mubarak's veep just annouced the Egyptian government has colapsed and given control to the army (not the veep)
07:42:56 <hpc> yay
07:43:01 <hpc> finally progress
07:43:15 <EvanCarroll> ++ /foreach chan, (got a lot of tells)
07:43:20 <dafis> don't be too sure, might become worse
07:43:36 <quuuux> unsafePerformPoliticalChange
07:44:00 <sipa1024> lol
07:44:04 <naypalm> code.lhs:19:0: parse error (possibly incorrect indentation)
07:44:08 <naypalm> I keep getting this!
07:44:11 <hpc> i don't think things will get worse
07:44:12 <shepheb> unsafeCoerce
07:44:12 <naypalm> is it because of my main?
07:44:17 <quuuux> naypalm: code?
07:44:19 <dafis> naypalm: paste?
07:44:30 <djahandarie> Oleg instegates revolutions, in the type system!
07:44:31 <naypalm> sec
07:44:35 <hpc> there's too many people pushing for democracy for one person to become a dictator again
07:44:46 <dafis> hpc: nobody thpought that in 1979 when the Shah was overthrown
07:44:55 <naypalm> http://hpaste.org/43887/aoeuaoeuaoeuaoeu
07:45:18 <djahandarie> btw political discussion should probably moved to -blah since it can get long ;)
07:45:38 <hpc> naypalm: your last line
07:45:42 <dafis> naypalm: you can't have just a value at the top level
07:45:50 <quuuux> naypalm: at the top level of a module, you can only write statements (like defining names, type signatures, etc). The last line is an expression
07:45:59 <naypalm> oh
07:46:08 <hpc> in languages like python, you can put stuff at the top level like that
07:46:13 <naypalm> so similar to a perl module where you'd put 1; at the end of the file?
07:46:14 <hpc> but only because python scripts are run top to bottom
07:46:18 <hpc> in haskell, it's meaningless
07:46:38 <hpc> because there's no evaluation order besides what needs to happen to make main run
07:46:52 <hpc> if it did somehow compile
07:46:55 <naypalm> is the a paradigmial statement to say "I have a thing at the end"
07:46:59 <hpc> your list down there wouldn't ever evaluate
07:47:11 <hpc> and it has no name, so you can't use it anywhere
07:47:12 <naypalm> hmm
07:47:16 <hpc> so why even have it?
07:47:25 <naypalm> I'm learning
07:47:40 <hpc> yeah, im just guiding you through the thought process
07:47:42 <roconnor> what is the name for the revese process of distributing multiplication over addition?
07:47:53 <hpc> roconnor: factoring?
07:47:53 <quuuux> roconnor: factoring?
07:47:54 <naypalm> oh I get you
07:47:57 <naypalm> so you define it
07:47:57 <hpc> lol
07:47:59 <roconnor> :)
07:48:09 <roconnor> factoring is the term I'm currently using
07:48:11 <quuuux> we only need one more person to say it to get a proof for an engineer
07:48:14 <naypalm> so you could write evens_one_to_ten = [x ..... ]
07:48:29 <hpc> naypalm: indeed; and then it compiles and you can use the list
07:48:33 <hpc> assuming the comprehension is right
07:48:36 <naypalm> I get you
07:48:43 <hpc> which it is
07:51:02 <quuuux> roconnor: for a few years at my secondary school they insisted on calling the process 'simplification', which confused me because it really doesn't always look simpler
07:51:05 <naypalm> main is running very very fast if it's actually doing factorial 200
07:51:31 <roconnor> quuuux: thanks
07:51:47 <roconnor> I was looking for the secondary school term
07:51:53 <quuuux> naypalm: are you forcing its evaluation (e.g., by printing it)? Otherwise, it's probably not being evaluated
07:51:58 <roconnor> ... but now that I know it I won't use it :P
07:52:08 <quuuux> roconnor: glad to help!
07:52:36 <hpc> factorial of 200 is easy stuff
07:52:42 <hpc> > 200!
07:52:42 <naypalm> no I'm not :(
07:52:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:52:46 <naypalm> bloody lazy!
07:52:52 <hpc> > factorial 200
07:52:53 <lambdabot>   Not in scope: `factorial'
07:53:00 <roconnor> > product [1..200]
07:53:01 <lambdabot>   788657867364790503552363213932185062295135977687173263294742533244359449963...
07:53:04 <dafis> > product [2 .. 200]
07:53:05 <lambdabot>   788657867364790503552363213932185062295135977687173263294742533244359449963...
07:53:11 <dafis> > product [2 .. 2000]
07:53:12 <lambdabot>   331627509245063324117539338057632403828111720810578039457193543706038077905...
07:53:12 <roconnor> > product [3..200]
07:53:13 <lambdabot>   394328933682395251776181606966092531147567988843586631647371266622179724981...
07:53:17 <naypalm> :|
07:53:18 <hpc> showoff :D
07:53:29 <hpc> > product [1..10000000]
07:53:37 <hpc> <.<
07:53:39 <dafis> that would take a while
07:53:40 <roconnor> 45239845239457324570923852350924952357234852893475982384520340523045289...
07:53:45 <naypalm> ha
07:53:50 <hpc> D:
07:53:54 <quuuux> @src product
07:53:55 <hpc> mueval isn't stopping!
07:54:02 <lambdabot> product = foldl (*) 1
07:54:03 <lambdabot>   thread killed
07:54:03 * roconnor pounded randomly on his keyboard
07:54:03 <poucet> roconnor: did you really evaluate that?
07:54:03 <hpc> i broked the bot!
07:54:14 <poucet> roconnor: thought so :D
07:54:15 <quuuux> oh. foldl, the bane of efficiency!
07:54:16 <hpc> poucet: no he did it by hand
07:54:45 <quuuux> > foldl' (*) 1 [1..10000000]
07:54:46 <poucet> > product [1..100000]
07:54:52 <lambdabot>   mueval: ExitFailure 1
07:54:52 <lambdabot>  mueval-core: Time limit exceeded
07:54:52 <lambdabot>   mueval: ExitFailure 1
07:54:52 <lambdabot>  mueval-core: Time limit exceeded
07:55:02 <Bynbo7> > foldl' gcd 1 [1..10]
07:55:04 <lambdabot>   1
07:55:11 <Bynbo7> > foldl' gcd lcm [l..10]
07:55:12 <lambdabot>   Couldn't match expected type `a -> a -> a'
07:55:12 <lambdabot>         against inferred type `S...
07:55:13 <Bynbo7> uh
07:55:17 <Bynbo7> > foldl' lcm 1 [1..10]
07:55:18 <lambdabot>   2520
07:55:22 <Bynbo7> > foldl' lcm 1 [1..100]
07:55:22 <lambdabot>   69720375229712477164533808935312303556800
07:55:26 <Bynbo7> > foldl' lcm 1 [1..1000]
07:55:28 <lambdabot>   712886527466509305316638415571427292066835886188589304045200199115432408758...
07:56:30 <naypalm> enough fun guys
07:56:54 <hpc> @let unsafeCoerce = fix ($) -- i like fun though
07:56:56 <lambdabot>  Defined.
07:57:11 <hpc> :t unsafeCoerce
07:57:12 <lambdabot> forall a b. a -> b
07:57:16 <naypalm> will never know what that is
07:57:31 <dafis> > unsafeCoerce (const True)
07:57:35 <lambdabot>   mueval-core: Time limit exceeded
07:57:43 <dafis> > unsafeCoerce (const True) :: Bool
07:57:56 <lambdabot>   mueval: ExitFailure 1
07:58:01 <hpc> > unsafeCoerce True :: ()
07:58:16 <lambdabot>   thread killed
07:59:23 <dafis> @botsnack
07:59:24 <lambdabot> :)
08:05:25 <ksf> http://www.youtube.com/watch?v=BWP-AsG5DRk
08:06:02 <ksf> Not everyday is a day when I deem it appropriate to post politics to #haskell, but today seems to be different.
08:09:46 <EvanR-work> ksf: so today its appropriate to post politics to #haskell? all day?
08:09:54 <EvanR-work> can of worms.com ;)
08:10:11 <quicksilver> ksf's opinion is not binding on the channel moderators, though :)
08:10:13 <Veinor> @pl \x y -> f x + g y
08:10:14 <lambdabot> (. g) . (+) . f
08:10:49 <gwern> there's something really messed up with the hawiki rss feed. keeps on repeating itself
08:10:50 <Philonous> Isn't it rather too early to celebrate anyway?
08:11:29 <ksf> erm, no.
08:11:37 <ksf> the normative force of the factual, you see.
08:12:10 <dafis> ?
08:12:41 <ksf> ...you might know it or not, but the fall of the berlin wall was caused by a miscommunication
08:13:06 <ksf> ...the borders were supposed to be opened after people went home, again.
08:13:50 <ksf> but once the word was out and people dared to be happy, there was no way to take anything back
08:15:05 <sgronblo> Why is the camera work so shitty in this Taste of haskell video...
08:15:39 <sgronblo> What's the point of filming this guy most of the time
08:16:21 <sgronblo> Oh there's a tiny link to the slides down there!
08:16:49 <sm> morning all
08:17:03 <dafis> evening
08:17:55 <sgronblo> comic sans.......
08:19:05 <sm> hell yeah go egypt
08:21:54 <ksf> "this guy"?
08:22:08 <ksf> that's peyton `simon` jones
08:22:22 <Saizan> the great.
08:22:29 <ksf> he's the official ghc mascot
08:24:27 <sgronblo> heh no offense intended
08:25:17 <quicksilver> SPJ's love affair for comic sans is one of the seven great mysteries of the world.
08:25:26 <quicksilver> I suspect there is a dark secret agenda behind it.
08:25:29 <sgronblo> He seems like a pretty good speaker, I just got annoyed because I watched through half the video before realizing there was a link to the slides and then got a bit shocked at the use of comic sans
08:25:34 <quicksilver> But I forgive him, because I always enjoy his talks.
08:25:46 <Philippa> does comic sans have enough greek letters in it?
08:25:58 <quuuux> ionic sans?
08:26:03 <Philippa> (also, does SPJ use keming too?)
08:26:04 <quicksilver> Philippa: IIRC, he uses MS Word's equation editor for greek bits
08:26:10 <Philippa> *wince*
08:26:19 <sgronblo> Also shouldn't X11 window managers be taboo for a microsoft researcher? :)
08:26:53 <Philippa> sgronblo: consider that GHC uses LGPL code, wouldn't you think that would be rather more so?
08:27:13 <quicksilver> (or, I suppose, the manifestation of the same thing in powerpoint; I've never really used powerpoint)
08:28:25 <ksf> microsoft pays spj so he can serve as a fly trap for less capable researchers, who are then forced to work on .NET
08:28:59 <sgronblo> btw which is better of hugs and ghci?
08:29:09 <ksf> ghci
08:29:18 <Bynbo7> no one uses hugs these days
08:29:22 <sgronblo> oh heh
08:29:39 * dankna wanders in and speaks just in case lambdabot has messages for him
08:29:52 <sgronblo> i took an FP course a loooong time ago where we used hugs
08:29:59 <quicksilver> hugs is faster and easier to port to new systerms.
08:30:05 <quuuux> a bunch of universities use hugs currently
08:30:12 <ceii> faster wut?
08:30:25 <quicksilver> ghci is more powerful, can use compiled code, supports many more extensions, etc...
08:30:43 <quicksilver> ceii: it's not a big difference but as I recall hugs does interpret simple code faster.
08:30:55 <ceii> oh, thought it was the opposite
08:31:09 <quicksilver> well ghci has the big advantage that it can load and run compiled modules
08:31:22 <quicksilver> and, in a normal setup, all your libraries (like Data.List and friends) are compiled with -O2
08:31:28 <quicksilver> or -O maybe
08:31:30 <dafis> ceii: hugs loads faster, ghci in general runs faster
08:31:44 <roconnor> are there any uses of monoidal monads in haskell?
08:31:46 <quicksilver> so that means that most of the time, ghci isn't interpreting.
08:31:50 <sgronblo> Also I noticed the install for the haskell-platform was rather effing huuuge. Out of curiousity what's the smallest dependency needed to run haskell programs?
08:31:53 * dixie just going to install hugs to explore
08:32:14 <sgronblo> ghci loads nearly instantaneously for me
08:32:25 <quicksilver> sgronblo: you can just install ghc if you just want to explore. The haskell-platform bundles various common libraries and all their documentation.
08:32:34 <dixie> hugs98 is about ~5 MB of source code. that is very nice
08:33:53 <sgronblo> quicksilver: So I guess I could google this up myself, but do haskell programs compile to executable units or do they compile to something like java classes that need to be run using a haskell interpreter?
08:34:09 <ceii> ghc compiles them to statically linked machine code
08:34:12 <quicksilver> sgronblo: GHC compiles to real executables.
08:34:24 <quicksilver> the interpreter is just for convenient developing.
08:34:49 <quicksilver> it is very convenient to be able to load one of your program files and try out functions interactively
08:35:20 <sgronblo> So how big does a hello world type program become?
08:35:39 <Bynbo7> pretty big
08:35:58 <Bynbo7> because all libraries needed are statically linked, and there's also the runtime system linked in there too
08:36:48 <ksf> pretty small when you link dynamically...
08:37:19 <ceii> statuc hello world is 552K here
08:37:23 <ceii> static*
08:37:27 <sgronblo> and dynamic?
08:37:46 <ksf> don't forget to strip
08:38:10 <quicksilver> I get 730K unstripped, 470K stripped.
08:38:17 <quicksilver> but my GHC can't do dynamic linking
08:38:21 <ceii> stripped is 364K
08:38:34 * quicksilver bets ceii is on an ELF platform
08:38:59 <ceii> x86 Linux
08:39:10 <shamster> how does one import a module from a parent directory?
08:39:15 <sgronblo> ok interesting
08:39:30 <quicksilver> yeah, ELF is much better than Mach-O for executable size.
08:39:46 <quicksilver> shamster: generally, you don't. You put your modules in a directory structure which matches their names
08:39:51 <quicksilver> shamster: and then it finds them automatically.
08:40:00 <quicksilver> e.g. Foo/Bar.hs contains the module Foo.Bar
08:40:22 <quicksilver> (there are flags to GHC if you want to arrange your directories differently)
08:43:23 <ceii> oh, my GHC can actually do dynamic linking
08:43:40 <ceii> dynamically linked hello world is 8K
09:29:37 <dino-> Wow, this is such a disaster. Can't configure because of incorrect pkg-config version.
09:29:39 <dino-> bleh, Haskellwiki Windows page doesn't say anything about pkg-config.
09:40:08 * ksf wants a typeclass-scope type variable but not be able to fill it in for instances
09:42:09 <shamster> quicksilver: thanks
09:42:49 <alpounet> ksf, what would the use case be ?
09:45:22 <shamster> Re: module arrangements - I have a directory Fundamentals/ that has several modules for some basic tasks I perform (i.e. Fundamental.Algebra, Fundamental.Geometry) and then I've got a directory for a GeometryProject/ with modules like GeometryProject.TriangleGame and GeometryProject.SquareFuntTime. How do I import Fundamentals.Geometry into my GeometryProject.SomeModule if the Fundamentals directory is not a subdirectory of GeometryProject?
09:46:54 <Saizan> you can add more include paths to ghc/ghci with -i
09:47:08 <Saizan> the default is equivalent to "-i."
09:47:17 <ksf> alpounet, http://hpaste.org/43890/iter
09:47:39 <Saizan> or you could make a cabal package out of fundamentals and install it as a library
09:47:42 <ksf> afaiu, I only need s to be the same in both functions for stuff to work out
09:48:00 <ksf> actually, I should get rid of c, too.
09:48:28 <shamster> Saizan: thanks, I think that could work. Do you know what the environment variable is to set the module search path?
09:48:45 <ksf> what I want is a data family, I think.
09:48:55 <Saizan> shamster: no
09:52:05 <aavogt> shamster: you can put   :set -isome/path    in your ~/.ghci
09:52:37 <shamster> aavogt: I was hoping to have something similar to $CPATH or $PYTHONPATH for when I compile via ghc
09:52:50 <shamster> aavogt: but thanks, I'll update my dotfile
09:53:01 <aavogt> put those modules in cabal packages
09:53:19 <shamster> aavogt: I stilled haven't played with cabal enough to know how to do that
09:53:42 <ksf> ooooh
09:54:04 <ksf> vastly less invasive to the rest of my code, I could just tuple up runIteratee and go
09:54:13 <aavogt> shamster: you could also have a script call ghc or ghci with the appropriate flags added
09:54:51 <shamster> aavogt: that's what I've been doing so far. I'd like to update my environment, though, with things specific to GHC..
09:55:20 <aavogt> make the script look at environment variables
09:56:31 <shamster> aavogt: yes, got that so far. Thanks.
09:57:17 <iago> hi all, AFAIK haskell-src-exts is able to handle CPP and literate haskell, but I don't find the way, can someone point me how/where I can found that info?
10:00:10 <Saizan> do you have {-# LANGUAGE CPP #-} at the top of the file? above module .. where ?
10:00:23 <felixl> hi
10:01:23 <felixl> what is the type of coap?
10:01:36 <ksf> I think you also have to enable the extensions in the parser
10:01:45 <dafis> coap? Nevr heard of that.
10:02:05 <dafis> :t coap
10:02:06 <lambdabot> Not in scope: `coap'
10:02:30 <iago> Saizan, after a copyright notice and a OPTIONS_GHC pragma
10:03:10 <aavogt> by default haskell-src-exts doesn't look at LANGUAGE pragmas
10:03:17 <felixl> dafis: that's the dual of (<*>)
10:03:28 <felixl> well, I think.
10:03:32 <aavogt> reverse the arrows
10:03:41 <aavogt> @ty (<*>)
10:03:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:03:48 <aavogt> but which ones?
10:04:13 <felixl> :t extend
10:04:14 <lambdabot> Not in scope: `extend'
10:04:17 <felixl> hmm
10:04:43 <iago> aavogt, I know, but I'm specifying CPP extension in ParseMode
10:05:22 <iago> anyway if I run cpp by myself and then use haskell-src-exts it continues without parsing any .lhs file
10:05:32 <dafis> coap :: CoMonad c => (c a -> c b) -> c (a -> b) ???
10:06:07 <Saizan> felixl: easier to dualize liftA2 (,);, instead of (f a, f b) -> f (a , b), you've f (Either a b) -> Either (f a) (f b)
10:07:22 <ksf> enumStdin'
10:07:22 <ksf>   :: (MonadIO m, Iteratee iter) => iter ByteString m a -> m a
10:07:27 <ksf> now that's a type signature.
10:07:28 <felixl> hmm ok, thanks!
10:07:38 <ksf> headI :: (Iteratee iter, Monad m, Chunk c) => iter c m (Elem c)
10:07:43 <iago> no idea_
10:07:44 <iago> ?
10:07:44 <copumpkin> dafis: how would you write that?
10:08:01 <felixl> I actually tried to reverse with (f a, f b) -> f (a, b) but didn't think of using sums
10:08:09 <dafis> exercise is left for the reader ;)
10:08:12 <copumpkin> :P
10:08:20 <felixl> I thought it would rather be something like f (a, b) -> (f a, f b)
10:08:41 <felixl> but it seemed not to be that so well
10:14:07 <Saizan> the dual of the product is the coproduct
10:23:50 <dankna> @hackage haskell-src-exts
10:23:50 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
10:24:03 <felix1> Monad transforms are used so we can move something from one monad into another, correct?
10:25:30 <Nibble> did anyone recieve that? I am having problems with freenode
10:25:48 <Saizan> more to compine the features of different monads
10:27:15 <Nibble> Saizan: from what I can understand it allows you to wrap a monad into another monad, like this example I found. MaybeT m a  I just want to be sure I am understanding this correctlyu
10:28:31 <Nibble> lambdabot: how do I use you to search for  functions
10:28:59 <Nibble> ah
10:29:01 <Nibble> Control.Monad
10:29:43 <Saizan> yeah, "MaybeT m" is a monad that combines the features of Maybe and m
10:30:13 <Saizan> but you're right that we then have a way to transform m a actions into MaybeT m a ones
10:30:30 <Nibble> Saizan: this just makes a lot more sense that doing it imperatively
10:30:43 <Nibble> why didn't I start with haskell as my first language
10:31:11 <copumpkin> I
10:31:16 <copumpkin> I'm glad I didn't
10:31:20 <copumpkin> I appreciate it a lot more now
10:31:49 <periodic> I'm not sure haskell makes a good starter language.
10:31:55 <Nibble> I am sure it does
10:31:56 <periodic> But I'd hate to say that I appreciate it more now...
10:31:59 <HaudRex> sure it does
10:32:04 <copumpkin> periodic: I think it would
10:32:13 <Nibble> main = putStrLn "Hello, World! This is a useless hello world example."
10:32:20 <Nibble> doesn't get any shorter than that?
10:32:23 <copumpkin> in fact, one australian university published a report with their findings with it
10:32:26 <copumpkin> and I think it was generally positive
10:32:30 <copumpkin> UNSW?
10:32:40 <periodic> It would be like saying I appreciate this relaxing evening more because I get physicall beaten during the day.
10:32:40 <Nibble> copumpkin: probably dons?
10:32:41 <Philippa> haskell makes a great starter language so long as you're not intending to do lots of GUI work or similar right at the start
10:32:59 <copumpkin> Nibble: no
10:33:25 <periodic> I guess I'm thinking from the perspective of people who might be brand-new to programming and don't have a strong math background.
10:33:28 <Nibble> copumpkin: sure? Isn't he somehow related with unsw?
10:33:32 <copumpkin> he is
10:33:34 <periodic> For me it might have been a good starter language.
10:33:43 <copumpkin> but he likes haskell because they taught it to him
10:33:45 <copumpkin> not vice versa :P
10:34:03 <teki> can i do an @-pattern-match on a tuple?
10:34:04 <teki> like
10:34:08 <teki> all@(a,b)
10:34:19 <aristid> teki: yes.
10:34:22 <periodic> teki: just try it and find out!
10:34:27 <periodic> That's the fun of GHCI
10:34:33 <aristid> or even lambdabot
10:34:36 <HaudRex> > let all@(a, b) = (1, 2) in all
10:34:37 <lambdabot>   (1,2)
10:35:00 <copumpkin> > let f a@b@c@d@e = a + b + c + d + e in f 5 -- someone did this the other day
10:35:01 <lambdabot>   25
10:35:07 <aristid> > let all@[] = [1] in all
10:35:08 <lambdabot>   *Exception: <interactive>:3:4-15: Irrefutable pattern failed for pattern (a...
10:35:12 <aristid> > let all@[_] = [1] in all
10:35:13 <lambdabot>   [1]
10:35:28 <ksf> http://hpaste.org/43891/loop
10:35:47 <ksf> someone tell me why I get an endless loop in test, I'm obviously too dense
10:35:54 <djahandarie> copumpkin... whoa
10:36:02 <Nibble> now here comes the problem
10:36:17 <copumpkin> I guess it goes to show that @ is right-associative
10:36:23 <periodic> huh, so v@ really just binds another variable to whatever comes after the @
10:36:32 <Nibble> if I have a function MaybeT IO () and want to use it in an IO () function
10:36:36 <byorgey> periodic: right
10:36:40 <Nibble> I am sure there is a way, how do I do it?
10:36:40 <periodic> neat
10:36:59 <periodic> Nibble: you'll have to run the MaybeT to get the IO value out if you want to actually do the IO.
10:37:04 <Nibble> aaah
10:37:10 <byorgey> Nibble: runMaybeT
10:37:30 <periodic> if you want to get to IO functions while in MaybeT IO (), you'll want liftIO
10:38:01 <djahandarie> > let x@(a,b)@(c,d) = (a+c, b+d) in x (1,2)
10:38:02 <lambdabot>   <no location info>: parse error on input `@'
10:38:17 <djahandarie> > let (x@(a,b))@(c,d) = (a+c, b+d) in x (1,2)
10:38:18 <lambdabot>   <no location info>: parse error on input `@'
10:38:20 <djahandarie> :(
10:39:16 <periodic> djahandarie: I think you need to pull the x off to name the function
10:39:29 <pi8027> > let x@((a,b)@(c,d)) = (a+c, b+d) in x (1,2)
10:39:30 <lambdabot>   <no location info>: parse error on input `@'
10:39:30 <Nibble> Couldn't match expected type `()' against inferred type `Maybe ()'
10:39:31 <Nibble> hmm
10:39:36 <periodic> Otherwise you're trying to bind some variables to itself.
10:39:38 <djahandarie> Oh
10:39:39 <djahandarie> Haha
10:39:51 <djahandarie> > let f x@(a,b)@(c,d) = (a+c, b+d) in f (1,2)
10:39:52 <lambdabot>   <no location info>: parse error on input `@'
10:40:30 <djahandarie> And hello pi8027
10:40:38 <pi8027> hello
10:41:39 <Nibble> pi8027: hello
10:41:45 <pi8027> pattern ::= ... | ident@pattern | ...
10:41:59 <djahandarie> Ah
10:42:23 <adnap> i just realized memcpy is kind of like a fold
10:42:30 <djahandarie> > let x a@(b,c)@d@(e,f) = (b+c, e+f) in x (1,2)
10:42:31 <lambdabot>   <no location info>: parse error on input `@'
10:42:33 <naypalm> http://hpaste.org/43892/length_noob
10:42:34 <naypalm> Multiple declarations of `Main.length'
10:42:39 <naypalm> :|
10:42:40 <aristid> adnap: how so?
10:42:47 <adnap> it is an implicit loop
10:43:03 <djahandarie> Oh, it'd have to be all identifiers and only a pattern at the end :(
10:43:05 <djahandarie> No fun
10:43:13 <aristid> adnap: then multiplication of two integers is a fold too
10:43:32 <naypalm> I thought you could redefine things in haskell
10:43:39 <aristid> naypalm: no
10:43:42 <Tomsik> catamorphism, man, that's the wooord
10:43:44 <copumpkin> aristid: only with a dumb representation of them
10:43:44 <Tomsik> duude
10:43:45 <adnap> how is multiplication of two integers like an implicit loop?
10:43:51 <naypalm> well
10:43:53 <aristid> copumpkin: you mean like Integer?
10:44:03 <copumpkin> how is that a fold?
10:44:08 <naypalm> like add on to them for alternative arguments
10:44:17 <aristid> copumpkin: multiplying two Integers requires a loop :)
10:44:21 <copumpkin> meh :P
10:44:34 <aristid> copumpkin: plus, many older processors did not have a multiplication instruction
10:44:38 <naypalm> so do I just have to rename `length`?
10:44:47 <copumpkin> aristid: you have to go pretty far back in time for that :P
10:45:04 <aristid> naypalm: no, you have to defined foo properly
10:45:10 <Tomsik> copumpkin: not really, I guess some microcontrollers still don't have it
10:45:14 <earthy_> 6502 anyone? :)
10:45:18 <Tomsik> except they're like 0.2$ now ;]
10:45:26 <naypalm> foo = len...?
10:45:28 <copumpkin> Tomsik: sure :P that's not relevant to the vast majority of people here
10:45:48 <copumpkin> I'm not saying not (exists p. nomultinsn(p))
10:46:05 <ksf> and neither is it relevant for new microcontroller code.
10:46:08 <ksf> there's ARM.
10:47:31 <copumpkin> there are still plenty of things that don't run ARM :)
10:47:42 <naypalm> aristid how did I fail in defining foo?
10:47:46 <ksf> well, then put one into it.
10:48:09 <ksf> license costs for ARM schematics approach 0 cents
10:48:34 <earthy> ARM doesn't go anywhere near as low power as e.g. an ATMega AVR
10:48:41 <earthy> and some AVR's doen't have MUL
10:49:50 <Nibble> earthy: that obviously has to do with complexity
10:49:54 <theorbtwo> Hm, are you sure, earthy?  They don't have hardware fp, but I thought they did have integer mul.
10:50:39 <fryguybob> naypalm: foo needs to be on the left hand side for its definition.
10:51:15 <naypalm> okay done fryguybob, now it says length is ambiguous with the Main.length
10:51:47 <Tomsik> theorbtwo: depends on how small and how cheap ones you want to buy
10:52:02 <fryguybob> naypalm: Right, length is already defined in the Prelude.
10:52:05 <theorbtwo> True.
10:52:44 <naypalm> so I have to say GHC.List.Length when defining it?
10:52:57 <tromp_> @src length
10:52:58 <lambdabot> Source not found. My brain just exploded
10:53:33 <fryguybob> naypalm: I'm not clear on what you are trying to do.
10:54:00 <tromp_> @src foldr
10:54:00 <lambdabot> foldr f z []     = z
10:54:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:54:12 <naypalm> I'm working through my lectures, but the lecturer just has a list of code in powerpoints so I'm to work out what they actually do..
10:54:19 <naypalm> I want to define length
10:54:32 <naypalm> and it'll be polymorphic and give the amount of arguments
10:54:43 <naypalm> but there's one in main causing a shitfest?
10:54:58 <theorbtwo> naypalm: Name your function something other then "length".
10:55:29 <fryguybob> Or add import Prelude hiding (length) to the top of your file.
10:56:29 <naypalm> I'll just call it len
10:56:39 <naypalm> the alternative sounds hard!
10:59:20 <naypalm> thankya
10:59:23 <Nibble> naypalm: the standard thing to do is to call it length'
10:59:33 <naypalm> ok
10:59:41 <Nibble> that is also what many people do if they have internal function
10:59:42 * naypalm wants to be paradigmally correct
10:59:46 <Nibble> but don't bother about that
11:00:00 <Nibble> naypalm: so you study where?
11:00:33 <naypalm> Heriot-Watt Edinburgh
11:04:50 <naypalm> Type signature given for an expression...
11:04:56 <naypalm> you what
11:05:10 <copumpkin> paradismally
11:05:33 <naypalm> that's an error?!
11:06:53 <dafis> naypalm: there are places where you can put a type signature, in others you can't
11:07:13 <rajeshsr> Long time since i did anything in Haskell. Feels like hacking on it this weekend. Any ideas?
11:07:21 <dafis> naypalm: where did you try to put one so the compiler complained?
11:07:39 <xarch> rajeshsr: reimplement Charity in Haskell :P
11:08:10 <hpc> rajeshsr: see how much of a website you can make in a weekend
11:08:10 <naypalm> I've changed it now
11:08:12 <naypalm> it was
11:08:15 <hpc> :P
11:08:28 <naypalm> data Point a = Pt a a
11:08:31 <Nibble> website
11:08:34 <Nibble> haskell
11:08:39 <Nibble> equals snap framework
11:08:43 <naypalm> Pt 2.0 2.0 :: Point Float
11:08:54 <hpc> Nibble: from scratch :D
11:08:56 <copumpkin> naypalm: make it a functor! and an applicative! and a monad!
11:08:57 <rajeshsr> xarch: what is Charity?
11:09:03 <Nibble> hpc: glhf with that :P
11:09:10 <naypalm> copumpkin ETNSUHOLEUCRHHOELURHC
11:09:12 <hpc> Nibble: i did
11:09:26 <copumpkin> naypalm: fair enough
11:09:27 <rajeshsr> hpc: You mean with Haskell as a CGI? Or write a webserver?
11:09:29 <Nibble> hpc: cgi is not something I would touch with a stick
11:09:35 <xarch> rajeshsr: a purely functional language
11:09:45 <hpc> it's not that bad...
11:09:48 <xarch> with ideas coming from category theory
11:09:49 <naypalm> you can't reuse variables?
11:09:54 <c_wraith> CGI should be avoided at all costs.  fastcgi isn't horrible, but it's still a poor proxying protocol
11:09:54 <naypalm> multiple definitions of temp..
11:09:54 <rajeshsr> xarch: that's interesting! :)
11:10:00 <lispy> yeah, cgi is not that bad.  And fcgi makes it even less that bad.
11:10:00 <xarch> and it's strongly normalizing
11:10:01 <naypalm> declarations*
11:10:15 <copumpkin> naypalm: of course not
11:10:16 <djahandarie> copumpkin, and bifunctor! And comonad!
11:10:19 <Nibble> hpc: it is
11:10:22 <naypalm> but
11:10:23 <copumpkin> djahandarie: not a bifunctor!
11:10:35 <djahandarie> Ah, damn, yeah, same type :P
11:10:38 <naypalm> I want to reuse my $_
11:10:44 <copumpkin> naypalm: sucks for you
11:10:49 <hpc> lol $_
11:11:15 <rajeshsr> BTW, is there some doc on writing Haskell wrappers for C++ libs?
11:11:17 * hpc hasn't seen anyone use $_ seriously in a program
11:11:18 <naypalm> so I have to define three temp variables and give each a type and then assign them or there are errors?!
11:11:31 <copumpkin> rajeshsr: wrap the c++ lib in c first, then it's simple
11:11:43 <hpc> yeah, what copumpkin said
11:11:52 <copumpkin> by wrapping it in c, I mean extern "C" an interface from C++
11:11:56 <hpc> c++ and haskell have runtimes that like to fight with each other
11:11:57 <copumpkin> unless you like mangled names
11:12:11 <copumpkin> c++ really doesn't have much of a runtime
11:12:18 <rajeshsr> copumpkin: ok! So, is there a doc for Haskell wraper for C lib?
11:12:25 <hpc> copumpkin: it's enough to cause issues, i thought
11:12:26 <copumpkin> rajeshsr: just search for haskell FFI
11:12:28 * geheimdienst thought c++ was pretty impossible to use from other languages?
11:12:33 <xarch> do you have a good introduction to adjoint functors and what they "represent" ?
11:12:45 <rajeshsr> anyway, am curious why C and not C++?!
11:12:49 <rajeshsr> what was the problem?
11:12:50 <copumpkin> hpc: I think the main issues are that you can't touch the templates in anything foreign, and the name mangling will make grown men cry
11:12:53 <Nibble> rajeshsr: haha, C++
11:12:57 <Nibble> made me lool
11:13:03 <hpc> copumpkin: ah
11:13:07 <copumpkin> xarch: what do monads "represent"?
11:13:28 <xarch> ok so that's not the good word
11:13:31 <hpc> rajeshsr: C and not C++ because C is close to machine language, so easy to interface with
11:13:36 <hpc> C++ is a huge mess
11:13:42 <copumpkin> xarch: as with many CT topics, I find the poset/preorder view of them fairly informative
11:14:00 <copumpkin> xarch: they have a different name in order theory
11:14:04 <dolio> rajeshsr: C++ mangles all the names in the code it generates, and the mangling is almost certainly compiler-specific.
11:14:04 <copumpkin> http://en.wikipedia.org/wiki/Galois_connection
11:14:08 <Nibble> hpc: I wouldn't even call it a mess
11:14:09 <thoughtpolice> ah, bayhac is about to start!
11:14:11 <Nibble> C++ doesn't exist
11:14:14 <xarch> ok, thanks
11:14:28 * thoughtpolice gets his GHC-fu ready
11:14:31 <rajeshsr> hmm, so name mangling is the whole problem! Interesting!
11:14:35 <copumpkin> thoughtpolice: you going there?
11:14:40 <dolio> rajeshsr: So, to import functions into Haskell from a C++ library, you need to figure out the mangled names, and import those.
11:14:53 <dolio> Unless the C++ library provides an 'extern C' interface.
11:14:57 <dankna> calling conventions also
11:14:59 <copumpkin> rajeshsr: it isn't all of it, but the calling conventions aren't always fully specified for c++ functions, and the mangling varies depending on whose compiler you're using
11:15:00 <dolio> Or something along those lines.
11:15:01 <dankna> not just name mangling
11:15:06 <copumpkin> rajeshsr: so it's safest to just export as c
11:15:11 <Nibble> The compilers out there actually target a language named cpp, C-Pick-Pocket
11:15:26 <dolio> Yeah, I don't know too much about what other difficulties there are.
11:15:28 <Nibble> It will steal your credit card information if given a chance
11:15:28 <rajeshsr> dolio: ha, i see the problem! Thanks for the insights!
11:15:41 <copumpkin> xarch: some people like to say adjunctions are about "generalization" or "optimization"
11:15:49 <xarch> hmm
11:15:50 <naypalm> > temp[1..3] :: Point
11:15:51 <lambdabot>   Not in scope: type constructor or class `Point'Not in scope: `temp'
11:15:52 <naypalm> :(
11:15:57 <thoughtpolice> copumpkin: already here!
11:15:59 <copumpkin> xarch: common examples of them are free algebraic structures
11:15:59 <dolio> There was a tutorial a while ago that showed how to do this stuff, but I couldn't tell you where it is, and it may not even work in general.
11:16:02 <naypalm> don't evaluate my shit
11:16:07 <thoughtpolice> copumpkin: i'm helping mark set up
11:16:15 <copumpkin> xarch: but I still think the order view on them is clearest to get an idea of the "shape" of them
11:16:22 <xarch> free algebraic structures?
11:16:24 <thoughtpolice> bos, tibbe and dons are on the way apparently
11:16:30 <xarch> hm, ok
11:16:59 <fryguybob> @botsnack
11:17:00 <lambdabot> :)
11:17:00 <copumpkin> xarch: given an X, make a Y out of it "automatically". For example, given a set, make a monoid out of it. That's called the free monoid construction and turns out to be strings/lists
11:17:21 <copumpkin> xarch: for most common algebraic structures, that is possible
11:17:25 <dolio> rajeshsr: And, C++ has to do the mangling, too. Because the name of a function isn't a unique identifier in C++. The name plus the type (of the arguments) is necessary to resolve overloading.
11:17:31 <dolio> C doesn't have to deal with that.
11:17:32 <copumpkin> you can even have a "free category" over a graph, and things like that
11:17:51 <rajeshsr> dolio: yeah, I know that.
11:18:36 <copumpkin> xarch: in the case of free, we see that as a functor from e.g. sets to the category of whatever algebraic structure you're going to. There's another functor back from there, that "forgets" the additional laws and structure. Those two functors are adjoint
11:18:36 <naypalm> http://hpaste.org/43893/rate_my_tripe
11:19:09 <xarch> hmm ok, thanks!
11:19:11 <naypalm> can not believe I have to do lines 65+
11:19:42 <naypalm> any glaring mistakes in my codeL
11:19:46 <copumpkin> naypalm: you don't need to write types on them
11:19:47 <naypalm> anything that makes you hurl?
11:19:56 <naypalm> types on what
11:20:06 <copumpkin> lines 64,65,66
11:20:22 <copumpkin> it can figure out all but 64 for you (it picks a more general type for 64)
11:20:54 <naypalm> so you can pick..
11:21:02 <naypalm> just Point? that didn't work
11:21:05 <djahandarie> Well it's a top level declaration, so it doesn't hurt
11:21:10 <copumpkin> you can just leave it out completely
11:21:13 <accel> show/read <-- are these things that are implemented in haskell; or do they require special compiler support?
11:21:17 <naypalm> :o
11:21:22 <copumpkin> accel: plain ol' haskell
11:21:27 <accel> @src show
11:21:27 <lambdabot> show x = shows x ""
11:21:41 <naypalm> ohhhhhhhhhhhh my god copumpkin
11:21:44 <accel> copumpkin: how does it, for a given type, automatically get a list of all it's record fields/names ?
11:22:06 <copumpkin> accel: oh, the deriving (Show) mechanism
11:22:11 <copumpkin> yeah, that's magic, but won't be soon
11:22:17 <hpc> :t show
11:22:18 <lambdabot> forall a. (Show a) => a -> String
11:22:20 <hpc> :t shows
11:22:21 <lambdabot> forall a. (Show a) => a -> String -> String
11:22:22 <sproingie> the magic will be in haskell anyway
11:22:26 <hpc> @src shows
11:22:26 <lambdabot> Source not found.
11:22:29 <accel> copumpkin: explain "but won't be soon"
11:23:07 <dolio> Someone's writing support for telling the compiler how to derive things.
11:23:22 <dolio> UHC has it, they're writing it for GHC.
11:23:38 <copumpkin> there already was some nasty support for it, but nobody used it
11:23:56 <dolio> Well, the existing support is the generic type classes stuff.
11:24:19 <dolio> I'm not sure that's for deriving. Just for defining an entire class by induction on the type.
11:24:31 <copumpkin> oh, I see
11:24:40 <copumpkin> I played with it once and got frustrated
11:24:41 <dolio> Not that I've looked at that extension in a while.
11:24:49 <djahandarie> Sounds interesting
11:25:18 <dolio> Oh, I guess it is for giving default implementations of the methods.
11:25:56 <Nibble> How is dph progressing?
11:26:08 <dolio> In that case, I'm not exactly sure what the difference will be, other than "deriving Foo" instead of "instance Foo Bar".
11:26:09 <Nibble> Does it have capability to use GPU yet?
11:26:35 <accel> Bynbo7: ping
11:26:37 <accel> xplat_: ping
11:27:23 <Bynbo7> Nibble: i don't believe tht's ever been one of the gaols of dph
11:27:42 * naypalm upgrades to haskell 7
11:27:44 <dafis> Bynbo7: gaols?
11:27:51 <Bynbo7> goals
11:28:00 <dafis> makes more sense
11:28:00 <naypalm> ohh it compiled another exe!
11:28:09 <thoughtpolice> Nibble: gpu's aren't the goal of DPH. there are other projects with similar aims, though
11:28:13 <djahandarie> There is something seperate from DPH that Chakravarty has worked on though, targeting GPUS.
11:28:15 <thoughtpolice> Nibble: look at the 'accelerate' package on hackage
11:28:23 <thoughtpolice> it can target CUDA for array computations
11:28:27 <copumpkin> they aren't the goals
11:28:27 <djahandarie> Paper: http://www.cse.unsw.edu.au/~chak/papers/LCGK09.html
11:28:31 <copumpkin> but they are an eventual wishlist item
11:28:34 <copumpkin> I'm reasonably sure
11:28:44 <copumpkin> there's even some stuff in the DPH repo about distributed computation
11:28:51 <copumpkin> which hasn't seen much love in a while
11:30:10 <djahandarie> That paper in slide form http://corp.galois.com/~dons/slides/08-09-lee.pdf
11:30:11 <thoughtpolice> it'll be nice at least when we can use the dph libs off hackage with 7.0.2, whenever it's due
11:30:26 <thoughtpolice> i don't know if chak has fixed the apparent problems with HEAD yet, though
11:30:33 <Nibble> it would be nice if someone fixed arch's ghc packages
11:30:38 <djahandarie> Everything seems to have apparent problems with HEAD
11:31:16 <thoughtpolice> in this case, I think the new typechecking overhaul broke something relating to the vectoriser
11:31:42 <thoughtpolice> er, well, not really the vectoriser, but broke some assumptions the vectoriser had about the typechecked code
11:31:44 <jmcarthur> Nibble: what's wrong with arch's ghc packages?
11:31:49 * djahandarie -> class
11:31:56 <thoughtpolice> since DPH touches almost every part of GHC, it seems
11:33:55 <dschoepe> If one sees a preorder (A,) as a category with there being an arrow from A to B iff A  B, then the monic arrows would be all arrows with a maximal element of A as a target, right?
11:34:12 <naypalm> > data Point a = Pt a a
11:34:14 <lambdabot>   <no location info>: parse error on input `data'
11:34:28 <naypalm> is it Point, Pt or a that's polymorphic there?
11:34:30 <naypalm> or the whole thing
11:34:36 <naypalm> or some combination of everything?
11:34:55 <dolio> Aren't all arrows monic in a preorder?
11:35:28 <Funktorsalat> yes
11:35:29 <dolio> f . g = f . h ==> g = h, because there is at most one arrow between any pair of objects.
11:35:39 <Funktorsalat> conclusion is always true
11:35:39 <dolio> So g must equal h.
11:36:02 <dschoepe> oh, right, thanks
11:37:41 <monochrom> "Point" or "Point a" is a polymorphic type, I am not sure which. "Pt" is a polymorphic constructor.
11:37:48 <jmcarthur> naypalm: i'm not completely sure what question you mean to ask. 'a' is a type variable, so it can be any type. it makes the Pt constructor a polymorphic function, and Point is a type constructor (which in haskell is always monomorphic)
11:37:49 <Nibble> jmcarthur: not up to date
11:38:04 <Nibble> Version        : 6.12.3-1
11:38:15 <Funktorsalat> "Point a" is a type expression with a free variable? ;)
11:38:16 <jmcarthur> Nibble: ghc 7 doesn't support all the haskell packages in the arch repos yet though, i don't think
11:38:19 <monochrom> "Pt" is a polymorphic constructor in the same sense that "length" is a polymorphic function.
11:38:34 <Funktorsalat> (unless it's at the toplevel)
11:38:49 <Nibble> jmcarthur: oh
11:38:57 <Nibble> jmcarthur: so that is where the problem is coming from
11:39:12 <Funktorsalat> naypalm: I'd say 'Pt' is polymorphic
11:39:13 <Nibble> My idea is to ditch all haskell packages and make people use cabal
11:39:15 <Nibble> as god intended
11:39:19 <naypalm> ok
11:39:53 <naypalm> that was a harder question than I expected, woo
11:40:12 <monochrom> "Point" or "Point a" is a polymorphic type in the same sense that list and Maybe are polymorphic types.
11:40:39 <monochrom> i.e. people say "haskell lists are polymorphic"
11:40:57 <naypalm> they are if you use some variable? :|
11:41:01 <naypalm> expecting to be wrong here
11:41:17 <naypalm> like urrrrrrr
11:41:31 <monochrom> I'm pretty sure at the end of the day people just say "___ is polymorphic" loosely.
11:41:47 <Funktorsalat> agreed
11:42:31 <Nibble> in the end of the day people say anything to get home
11:47:06 <sproingie> or to go home with someone else
11:49:24 <mzero> we're BayHac'in!
11:49:29 <kevinburke> let's say I have a string and I want to output how many times each character appears in the string
11:49:41 <shachaf> mzero: Already?
11:49:51 <kevinburke> that sounds like a problem you could solve with a map and reduce
11:49:57 <shachaf> I thought it was at 14:00.
11:50:17 <kevinburke> in haskell you'd use foldl right? but foldl would condense all elements into one - how do you keep the different chars in a foldl?
11:50:22 <mauke> kevinburke: more like a sort and a group
11:50:32 <mauke> or foldl' with a Map
11:50:34 <kevinburke> ok
11:50:45 <shachaf> > map (head &&& length) . group . sort $ "abecaeddabc"
11:50:46 <lambdabot>   [('a',3),('b',2),('c',2),('d',2),('e',2)]
11:50:47 <mzero> shachaf: Folks are here!
11:50:50 <dafis> kevinburke: foldl'
11:51:01 <shachaf> mzero: I'm next door! Does that count?
11:51:02 <dafis> with a Map, like mauke said
11:51:11 <dafis> and insertWith' (+)
11:51:17 <kevinburke> ok
11:51:19 <mzero> shachaf - how close?
11:51:28 <shachaf> mzero: 152 E Dana St.
11:51:35 <mzero> wow - 
11:51:50 <dafis> kevinburke: but if it's an ASCII string, accumArray on a UArray Char Int is faster
11:51:57 <shachaf> mzero: I'll be there at one point today, at least.
11:52:04 <shachaf> mzero: Is dons there? :-)
11:52:26 <mzero> he's havin' lunch in Mtn. View -- bos said they'll be here in about 40 min
11:52:32 <kevinburke> shachaf: what's the runtime? sort is nlogn, group is n, map is n so nlogn?
11:52:34 <thoughtpolice> bayhac represent!
11:52:47 <shachaf> thoughtpolice: You're there too?
11:52:57 <dafis> kevinburke: yep, n*log n
11:53:06 <shachaf> kevinburke: You didn't specify anything about efficiency. :-)
11:53:23 <thoughtpolice> shachaf: yep!
11:53:24 <kevinburke> Yeah i'm more interested in how you'd do it than getting the fastest possible implementation
11:54:38 <dafis> kevinburke: foldl' (flip (uncurry Map.insertWith' (+))) Map.empty $ zip string (repeat 1)
11:54:39 <mzero> shachaf -- my company used to be in 152!
11:54:43 <kevinburke> &&& combines two elements in a tuple?
11:54:58 <dafis> :t (&&&)
11:54:59 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:55:16 <shachaf> mzero: What company was that? When?
11:56:01 <dafis> @let charCount string = foldl' (flip (uncurry Data.Map.insertWith' (+))) Data.Map.empty $ zip string (repeat 1)
11:56:02 <lambdabot>  <local>:3:41: Not in scope: `Data.Map.insertWith''
11:56:02 <lambdabot>  
11:56:02 <lambdabot>  <local>:3:68: Not in s...
11:56:18 <dafis> :t member
11:56:18 <lambdabot> Not in scope: `member'
11:56:37 <dafis> :t Map.member
11:56:38 <lambdabot> Couldn't find qualified module.
11:56:43 <aristid> :t M.member
11:56:44 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Bool
11:56:48 <dafis> gracias
11:57:04 <dafis> @let charCount string = foldl' (flip (uncurry MinsertWith' (+))) Mempty $ zip string (repeat 1)
11:57:05 <lambdabot>  <local>:3:41: Not in scope: data constructor `MinsertWith''
11:57:05 <lambdabot>  
11:57:05 <lambdabot>  <local>:3:60:...
11:57:12 <dafis> @let charCount string = foldl' (flip (uncurry M.insertWith' (+))) Mempty $ zip string (repeat 1)
11:57:13 <lambdabot>  <local>:3:61: Not in scope: data constructor `Mempty'
11:57:20 <dafis> @let charCount string = foldl' (flip (uncurry M.insertWith' (+))) M.empty $ zip string (repeat 1)
11:57:21 <lambdabot>  <local>:3:55:
11:57:21 <lambdabot>      Couldn't match expected type `(a -> a -> a, b)'
11:57:21 <lambdabot>          ...
11:57:33 <dafis> @let charCount string = foldl' (flip (uncurry $ M.insertWith' (+))) M.empty $ zip string (repeat 1)
11:57:34 <lambdabot>  Defined.
11:57:51 <dafis> > charCount "This is just a stupid example"
11:57:52 <lambdabot>   fromList [(' ',5),('T',1),('a',2),('d',1),('e',2),('h',1),('i',3),('j',1),(...
11:58:35 <dafis> > charCount "oooooooooooooooooooooooooooooooooohhhhhhhhhhhhhhhhhhhhh"
11:58:36 <lambdabot>   fromList [('h',21),('o',34)]
12:00:25 <aristid> > M.fromList . map (head &&& length) . group . sort $ "oooooooooooooooooooooooooooooooooohhhhhhhhhhhhhhhhhhhhh"
12:00:26 <lambdabot>   fromList [('h',21),('o',34)]
12:00:59 <aristid> > M.fromDistinctAscList . map (head &&& length) . group . sort $ "oooooooooooooooooooooooooooooooooohhhhhhhhhhhhhhhhhhhhh"
12:01:00 <lambdabot>   fromList [('h',21),('o',34)]
12:01:23 <aristid> dafis: i think mine is more readable despite being point-free :)
12:01:37 <aristid> well yours is almost point-free too
12:02:22 <dafis> aristid: I won't deny that yours is more readable. Actually, with the new sort, it might not even be slower anymore.
12:02:38 <Twey> There's a new sort?
12:02:43 <aristid> new sort \o/
12:03:28 <dafis> well, still a mergesort, the old YHC code, it's just faster on average than the old implementation
12:03:49 <dafis> I think it didn't come in before 7.0
12:03:52 <aristid> dafis: yours looks almost like "map-reduce" (or is it map-fold? ;)
12:04:43 <dafis> aristid: I thought map-reduce was more or less a fold, never looked up what it really was supposed to be
12:05:18 <aristid> dafis: doesn't it also have to be an associative operation?
12:05:37 <aristid> something like a monoid
12:05:38 <dafis> aristid: don't know
12:05:54 <aristid> dafis: because it might be done in any order
12:06:07 <monochrom> since map is also a fold, map-reduce is fold-fold is just fold. unless you really mean google's map-reduce which is different, just different.
12:06:10 <naypalm> so I've got a wee bit of code in my file
12:06:12 <Twey> dafis: Ah
12:06:20 <naypalm> and main = return ()
12:06:32 <dafis> aristid: but Map Char Integer is a Monoid, and instead of insertWith' (+) imagine unionWith (+) (singleton c 1)
12:06:33 <naypalm> how would I go about testing these functions in the ghci for example
12:06:44 <Twey> naypalm: :l yourfile.hs
12:07:36 <naypalm> everything's not in scope
12:07:57 <Twey> Then you did something wrong
12:08:26 <naypalm> main=return() ?
12:08:49 <Twey> That's fine
12:09:00 <monochrom> is that the sole content of your file? just that line, no other lines?
12:09:11 <naypalm> no there are other lines
12:09:16 <monochrom> then should work
12:09:22 <naypalm> nothing looks like it should change the scope
12:09:39 <monochrom> ":load yourfile.hs" then "main". does nothing but at least no error.
12:10:00 <naypalm> yeah main works
12:10:00 <dafis> naypalm: you wrote literate code, name your file file.lhs and :l file.lhs
12:10:02 <naypalm> without error
12:10:33 <monochrom> well then problem solved.
12:10:45 <naypalm> but I don't only want main!
12:10:56 <monochrom> what else do you what?
12:10:57 <dafis> Ooooh!
12:11:01 <naypalm> what about fib!
12:11:05 <dafis> I know
12:11:15 <monochrom> there is no fib defined in yourfile.hs.
12:11:37 <dafis> naypalm: without a module declaration, the declaration is assumed to be "module Main (main) where"
12:11:39 <naypalm> there should be
12:11:43 <monochrom> oh misread, you have other lines. well they should work too.
12:11:53 <naypalm> fib :: Integer -> Integer
12:11:57 <dafis> naypalm: just put a "module Foo where" at the top
12:12:07 <Twey> dafis: It's not being imported as a module, though
12:12:32 <monochrom> no dafis, since it is a ":load" and it is interpreted not compiled, internal functions are still exposed.
12:12:45 <dafis> Twey: yeah, right, loading in ghci gives you *Main>, not Main>
12:12:53 <Twey> Right
12:12:57 <fryguybob> naypalm: Have you already built your file with GHC?
12:13:04 <naypalm> yes
12:13:12 <monochrom> oh I see.
12:13:18 <naypalm> I have my binary
12:13:24 <monochrom> well you should have revealed more secrets like this.
12:13:29 <naypalm> and a .hi file waving at me
12:13:48 <monochrom> ":load *yourfile.hs"
12:13:55 <dafis> Okay, then it's probably the module header
12:14:23 <naypalm> that worked!
12:14:24 <monochrom> I wouldn't call it "module Foo". defeats the purpose of "main".
12:14:49 <dafis> monochrom: what purpose does "main = return ()" have?
12:15:01 <monochrom> placeholder for future code.
12:15:06 <Funktorsalat> allowing you to compile an executable? ;)
12:15:17 <Funktorsalat> to check out the rts options maybe ;)
12:15:47 <dafis> I go with monochrom's offer
12:16:01 <naypalm> soooooooo
12:16:18 <naypalm> `:load *` works if you've already compiled your code?
12:16:46 <monochrom> the * means you want non-exported functions exposed
12:17:15 <naypalm> ok
12:17:22 <monochrom> and the story is long because if you haven't compiled your code, you don't need * and you still get your non-exported functions exposed.
12:17:57 <monochrom> this is why I do not always recommend ghc to beginners. ghci itself is a whole thing to learn in itself.
12:18:00 <naypalm> what
12:18:11 <naypalm> ok
12:18:22 <Funktorsalat> monochrom: I didn't know about the * either :)
12:18:29 <monochrom> see the whole chapter http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html and be scared
12:18:30 <naypalm> so if I don't compile with ghc I just do :load code.lhs
12:18:42 <naypalm> if I have compiled and want my modules exported then I do :load *code.lhs
12:19:08 <monochrom> this :load and * business is in http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-compiled.html in particular
12:19:22 <dafis> naypalm: you need the * only if you want to access top-level bindings which are not exported from the module
12:20:23 <fryguybob> Building with cabal also avoids the issue :P
12:20:28 <mzero> shachaf - it was my own company - called Glyphic Technology
12:21:07 <shachaf> mzero: When was that?
12:21:13 <naypalm> oh my god why is it so complicated!
12:21:30 <dafis> naypalm: what is complicated?
12:21:32 <mzero> hmmm.... 1999 ~ 2001 in that location
12:21:35 <mzero> methinks
12:21:37 <monochrom> see? use hugs instead, much simpler.
12:22:13 <shachaf> Ah, some time ago, then.
12:26:49 <adimit> Quick question: is it possible to import a module (in ghc) and hide an instance it declares? Say M1 declares C1 AD
12:27:03 <adimit> i'd like to 'import M1 hiding (C1 AD)
12:28:16 <doserj> adimit: no
12:29:54 <doserj> adimit: in case you missed it: hiding instance declarations is not possible
12:30:11 <adimit> doserj: I missed it indeed. Thank you doserj 
12:30:50 <adimit> Quite a pity. Can I shadow instance declarations then? ghc (rightly) complains about duplicate instances if I redeclare some
12:31:21 <adimit> TBH, I believe I'm overthinking how elegant my xmonad.hs really has to be
12:32:11 <periodic> adimit ah, xmonad.hs is a great place to overcomplicate things.
12:32:40 <adimit> periodic: yeah, at least it doesn't hurt anyone but yourself.
12:32:59 <doserj> adimit: no. It is a quite fundamental constraint that there is only one instance declaration per type and class.
12:33:02 <aavogt> in a way -XOverlappingInstances lets you shadow instances. But that's only possible if you have a more specific type in mind than the original instance
12:34:07 <periodic> doserj: that makes sense, since the instance has to sort of follow the data around wherever it goes, in a sense.
12:34:19 <periodic> Wouldn't want to have dictionary conflicts.
12:34:23 <aavogt> the strategy to work around it is to make a newtype of the old one
12:34:36 <periodic> That's what it's called, right? The dictionary? Where it looks up class instances?
12:34:45 <adimit> aavogt: Which I don't. OK, thanks, I'll just work around the problem. I guess putting customizable behaviour into default instances for a certain type was a bad idea by the module author.
12:35:15 <aavogt> adimit: what is the module?
12:35:36 <adimit> aavogt: GridSelect. I'm talking about the colorizing.
12:35:45 <doserj> periodic: yes. Just consider putting two things in a Map with conflicting Ord instances...
12:35:46 <aavogt> then blame me
12:36:28 <adimit> aavogt: but isn't Clemens Fruhwirth the author?
12:36:33 <adimit> or are you the maintainer?
12:36:54 <aavogt> I added that part
12:38:19 <aavogt> an arbitrary constraints at the time included backwards compatibility
12:38:42 <aavogt> adimit: it's not too bad to specify the instance you want by using a newtype
12:39:14 <adimit> well, I thought it's a bit awkward that in order to override the colorizing behaviour, i can't just put it in something like defaultConfig {gs_colorize = foo}
12:39:37 <aristid> adimit: somehow my brain tells me that the name must be Frhwirth, but http://clemens.endorphin.org/aboutme claims otherwise. GAAAH
12:39:48 <adimit> aavogt: but, yeah, it's not too bad to just do it any other way. i'm thinking too much about it.
12:40:17 <aavogt> instead the list of choices needs a     map (\(a,b) -> (Newtype a,b))
12:40:21 <adimit> aristid: I just copied it from the doc file at http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-GridSelect.html
12:40:26 <aavogt> and you have to unwrap the newtype
12:40:51 <aristid> adimit: yeah. he seems to write it this way himself
12:40:53 <aavogt> oh, the tuple is in the other order
12:41:22 <adimit> aavogt: i think that's gonna be one hoop to many to jump through, so I'll stick with the way it's in the docs. Just considered that a bit awkward.
12:41:37 <aavogt> it's not suggested that way in the docs?
12:42:02 <adimit> aavogt: it's suggested to use buildDefaultGSConfig
12:42:19 * Funktorsalat likes http://www.vim.org/scripts/script.php?script_id=3423
12:42:19 <adimit> now I'm confused :-\
12:42:47 <Funktorsalat> (new haskell completion addon for vim, not by me)
12:43:02 <aavogt> adimit: oh, you can just set   conf{ gs_colorizer = foo }
12:43:31 <aavogt> with minor issues relating to the type of the default conf... so use buildDefaultGSConfig
12:43:31 <adimit> aavogt: no, you can't. It says the instance is not visible.
12:43:46 <adimit> not instance, field.
12:43:48 <adimit> bah.
12:44:09 <adimit>  `gs_colorize' is not a (visible) constructor field name -- that's the exact error message.
12:44:32 <aavogt> try gs_colorizer
12:44:59 <aavogt> unfortunately ghc doesn't have a "did you mean: x" mode
12:45:31 <adimit> aavogt: my dear, the times I've made an upheaval about something not working when it was just misspelled.
12:45:33 <adimit> uncountable
12:45:47 <adimit> thanks for the hint.
12:45:59 <aavogt> well you will run into issues with the 'a' in defaultGSConfig :: HasColorizer a => GSConfig a
12:46:21 <adimit> aavogt: I know, but that's easy to work around by just adding type signatures (I think.)
12:46:28 <aavogt> because when you replace the  gs_colorizer, it doesn't know which type to use for the original
12:46:44 <aavogt> not that it actually matters
12:46:59 <aavogt> but in some situations is can matter
12:47:27 <aavogt> *it
12:48:45 <aavogt> the values of the other fields could depend on a function which is chosen based on the 'a'
12:49:12 <adimit> aavogt: I see. So that's why the buildDefaultGSConfig is the way to go, eh?
12:49:19 <aavogt> I guess so
12:49:41 <adimit> ok, thanks for your help :-)
12:49:43 <aavogt> ghc probably could/should default the 'a' to (), but if I recall correctly, it doesn't
12:50:00 * aavogt guesses it might with appropriate extensions
12:50:10 <aavogt> -XExtendedDefaultRules
12:51:49 <tct13> hi
12:51:50 <adimit> aavogt: doesn't seem to work in my case, though I'm using a dummy 'undefined.' But the colorizing function has the signature HasColorizer a =>  I'll look into the matter :-)
12:52:37 <aavogt> no, the function you replace it with doesn't need that constraint
12:52:57 <tct13> please help: http://hpaste.org/43896/foldr
12:53:17 <tct13> i don't know how to use fold
12:53:23 <adimit> yeah, you're right.
12:53:29 <aavogt> you should have a number before the list
12:53:41 <aavogt> tct13: you're missing an argument
12:53:59 <aavogt> @src product
12:53:59 <lambdabot> product = foldl (*) 1
12:54:30 <tct13> aavogt: thanks
12:55:13 <aristid> @src ($!)
12:55:13 <lambdabot> f $! x = x `seq` f x
12:55:33 <aristid> @src foldl'
12:55:34 <lambdabot> foldl' f a []     = a
12:55:34 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:56:05 <shamster> > :t foldl
12:56:07 <lambdabot>   <no location info>: parse error on input `:'
12:56:38 <periodic> :t foldl
12:56:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:58:56 <dino-> dcoutts: Oh hey, tried zip-archive again since it had been a year after since I tried last. Seems to be way way better at dealing with filthy zips now.
12:59:09 <accel> is there a good tutorial on _implementin_ gui systems in haskell?
13:00:03 <dino-> s/after//
13:00:37 <dino-> This rocks. Building bindings-libzip was so not working in Windows.
13:02:18 <geheimdienst> so, what's the general public's opinion on this? http://flyingfrogblog.blogspot.com/2011/01/io-throughput-haskell-vs-f.html
13:02:21 <geheimdienst> sound plausible?
13:07:03 <c_wraith> I'd say it sounds like a plausible bug, but I'm not sure it's a significant one.
13:07:47 <copumpkin> lol, more jdh bullshit?
13:08:10 <geheimdienst> i wonder why haskell would crash on 3gb but not on 4 ...
13:08:12 <c_wraith> yeah.  apparently a strict bytestring can't be more than 4GB on a 32-bit system
13:08:30 <c_wraith> I don't think that's really a significant problem
13:08:38 <c_wraith> But it does sound plausible
13:09:05 <periodic> That's sort of a standard behavior in programs, isn't it?
13:09:30 <periodic> Once you have more data than you have room to index weird stuff has to happen or you need a bunch of backend overhead.
13:10:10 <c_wraith> I suspect the best way to deal with it is some form of error message when attempting to read/construct a strict bytestring that big
13:10:14 <c_wraith> Instead of silent corruption
13:10:36 <geheimdienst> silent corruption is kinda always a bug
13:10:50 <sm> ack.. can anyone give me an example of the push address for darcsden repo ?
13:11:03 <periodic> yeah, silent corruption is no good, that's true
13:11:05 <accel> geheimdienst: how do you get silent corruption in haskell?
13:11:26 <c_wraith> accel: bytestring is implemented as unsafe C operations under the hood.
13:11:47 <c_wraith> (give or take.  Unsafe foreign haskell ops mostly, actually)
13:11:51 <accel> so there are bugs in the core haskell library?
13:12:03 <c_wraith> Well.  There are bugs in every core library
13:12:08 <c_wraith> This one is an extreme corner case
13:12:27 <geheimdienst> accel, the dude in this blog entry claims that haskell's bytestrings corrupts files of several gigabytes http://flyingfrogblog.blogspot.com/2011/01/io-throughput-haskell-vs-f.html
13:12:42 <accel> hmm; not surprising ti's by those ocaml guys eh?
13:12:44 <periodic> And you can always end up with weird ones like the small float infinite-loop thing.
13:12:56 <accel> periodic: wtf is small float infinite loop?
13:13:02 <companion_cube> Obj.magic <3
13:13:29 <periodic> There's a certain small float that when the routine to transform it from a strnig to a double is called on it will send a certain algorithm into an infinite loop.
13:13:36 <periodic> It's in, or was in, PHP and Java.
13:13:46 <accel> yeah; but it is in haskell too?
13:13:54 <periodic> accel: I don't actually know.
13:14:20 <periodic> It came up at work because I had to go through and check that all the parseDouble calls were safe in our Java apps in case someone passed that value in a few times and tied up our servers
13:14:35 <copumpkin> pretty sure GHC doesn't suffer from it
13:15:00 <periodic> Yeah, it's just this certain parseDouble routine as implement on some Intel processors.
13:15:09 <periodic> But it's a good case of weird bugs that don't turn up for years.
13:15:26 <mreh> they aren't bugs
13:15:33 <mreh> they're called errors
13:15:50 <periodic> But "bug" makes it sound friendlier and cuddlier.
13:16:08 <periodic> My attempt to get the culture to call them "puppies" was turned down though. :(
13:17:02 <mreh> it's easier to smash puppies with hammers
13:17:05 <pumpkin> is there an instance (Ord a, Ord b) => Ord (Either a b) ?
13:17:08 <pumpkin> @instances Ord
13:17:09 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:17:16 <pumpkin> I guess so :)
13:18:03 <periodic> Huh, what does Either do when it has to compare Left a and Right b?
13:18:19 <mreh> @src Ord
13:18:20 <lambdabot> class  (Eq a) => Ord a  where
13:18:20 <lambdabot>     compare      :: a -> a -> Ordering
13:18:20 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
13:18:20 <lambdabot>     max, min         :: a -> a -> a
13:18:22 <mreh> it's not about that
13:18:26 <geheimdienst> a new take on the familiar pattern of asking a question and quitting before anyone can answer: asking a question and answering it yourself before anyone else can
13:18:27 <c_wraith> > Left 1 < Right "a"
13:18:28 <lambdabot>   True
13:18:29 <mreh> comparing elements of the same set
13:18:34 <c_wraith> apparently Left < Right
13:18:48 <periodic> huh.  Good to know.
13:18:49 <mreh> oh right, misunderstood
13:19:09 <geheimdienst> > (3 < 4) :: Either a b
13:19:09 <lambdabot>   Couldn't match expected type `Data.Either.Either a b'
13:19:10 <lambdabot>         against infer...
13:19:14 <geheimdienst> > (3 < 4) :: Ord (Either a b)
13:19:15 <lambdabot>   Class `GHC.Classes.Ord' used as a type
13:19:23 <geheimdienst> whatever
13:21:18 <dino-> Speaking of Java, I'm interviewing for a Scala job next week.
13:21:31 <periodic> Neat.
13:21:42 <mreh> does scala run on the JVM?
13:21:46 <periodic> I could see myself enjoying Scala or Clojure.  
13:21:46 <dino-> mreh: yes
13:21:50 <mreh> or are there scala JVM compilers
13:22:04 <periodic> scala was designed to run on the JVM and interface directly with Java code.
13:22:06 <mreh> aren't they lisps?
13:22:13 <periodic> Clojure is lisp-based
13:22:28 <periodic> Scala is a strongly-typed OOP language.
13:22:50 <periodic> Though it does have support for closures and anonymous functions which Java doesn't.
13:22:57 <dino-> So, sure, we'd love Haskell to be welcomed at a place like this as a liberator. But this isn't a bad thing for getting FP concepts to start infiltrating a company.
13:23:18 <periodic> dino-: gotta take what wins you can et.
13:23:19 <periodic> *get
13:23:26 <dino-> periodic: absolutely
13:23:34 <periodic> I honestly don't think most people will like Haskell.
13:24:01 <periodic> Just like there are people who prefer to be coding in C++.
13:24:07 <accel> is it better for a piece of code to throw an exception or return a Maybe?
13:24:26 <accel> i.e. f :: Int -> Double (might throw exception)  ... or ..... f :: Int -> Maybe Double (guarantees to run fine)
13:24:50 <thoughtpolice> accel: Maybe makes the fact f might fail explicit in the type
13:24:51 <periodic> accel: probably maybe.
13:25:03 <thoughtpolice> that's a hell of a lot better, because people can forget to catch exceptions
13:25:08 <thoughtpolice> but not forget to check for Nothing
13:25:25 <accel> if that's the case
13:25:28 <accel> why do we have exceptins in the first place
13:25:37 <accel> why isn'te everything Maybe based?
13:25:59 <periodic> Exceptions would be for things like a socket getting unexpectedly closed, when you have a flow of logic and it gets interrupted.  Maybe is for when you have something that might succeed or might fail.
13:26:19 <lispy> Maybe can break laziness when used poorly
13:26:23 <accel> so suppose i have to load some vertex/fragment shaders from disk, compile them, and link them
13:26:27 <accel> shoudl that be exception or Maybe based?
13:26:27 <thoughtpolice> Maybe has the semantics of 'this can fail, or it will succeed' - exceptions are for rare occurrences that generally deal with IO itself
13:26:27 <dino-> accel: Well, there's stuff like Error monad, which I use a lot.
13:26:40 <thoughtpolice> IMO, at least
13:26:42 <thoughtpolice> lispy: how so?
13:26:54 <periodic> Yeah, exceptions make sense for IO more than other things.
13:27:18 <periodic> Also, you can chain Maybe as a monad.
13:27:30 <lispy> thoughtpolice: http://www.haskell.org/haskellwiki/Maintaining_laziness#Laziness_breakers
13:27:43 <accel> I have a piece of code that is String -> String -> ... ? where it reads two filenames, loads the files, compiles them into shaders, links them, and then uses them. Should this be excetion or Maybe based?
13:27:48 <accel> window 3
13:27:59 <periodic> accel: both!
13:28:10 <periodic> accel: if the file isn't found you're looking at more of a maybe situation.
13:28:11 <dino-> And if you need more than Nothing for the failure, you can get Error on it and the Either type
13:28:40 <accel> dino-: hmm interesting; I like this Error monad
13:28:42 <periodic> but if you're in the middle of reading and there is an IO error I think you're looking at more of an exception.
13:28:47 <periodic> or maybe error monad.
13:29:05 <periodic> I can't remember the last time I threw an exception.
13:29:06 <monochrom> go with your heart, but document it thoroughly. for example say what exceptions you throw for what, say what your Nothing means ie what will cause Nothing.
13:29:54 <dino-> But it's generally considered good that we're not in the Java boat where there's really only exceptions (or returning null, bleh) and you MUST catch most of them.
13:30:16 <monochrom> the only sin and the worst sin is the doc just says "openFile. this opens a file."  OK cool but which exceptions should I catch? you didn't say.
13:30:21 <dixie> hmm, how to export Instance ? I'm getting orphaned instance warning 
13:30:22 <lispy> Yeah, in Java they could have named them Norms instead of Exceptions
13:30:26 <periodic> dino-: I hate null.  IT should really be Maybe.
13:30:38 <dino-> periodic: Another win for Scala with the Option type.
13:30:56 <dino-> But you do still have to deal with the dirty nulls of things you import. So blah.
13:31:57 <dino-> btw, my wife tells me people in the Java world are in full-blown checked-excpetion revolt. Building exception types with the bases you don't have to catch.
13:32:39 <c_wraith> checked exceptions are nice in theory, but often so cumbersome to use that, well, yes.  Everything derives from RuntimeException
13:32:42 <lispy> dino-: interesting
13:32:51 <lispy> dino-: When I did Java I much preferred checked exceptions.
13:33:06 <periodic> dino-: could you explain that a bit clearer?
13:33:07 <c_wraith> What that implies is that the idea is good, but the implementation needs to involve less boilerplate
13:33:37 <periodic> They build exception types for the cases they don't have to catch? and aren't catching them?
13:33:42 <lispy> Exceptions in Haskell are a mess for some application domains.  Actually, that seems to be more at the heart of the issue.  Some people need to care about all the exceptions they can trigger, and others are just annoyed by it.
13:33:44 <hpc> c_wraith: if only there was some sort of type they could use... like Nothing or Either :P
13:34:11 <c_wraith> hpc: Either is pretty much checked exceptions.  They still show up in your type signature.
13:34:15 <monochrom> I think dino- means the revolters deliberately choose to throw unchecked exceptions only.
13:34:18 <periodic> Here they just throw Exception all the time.  Minimal boilerplate, minimal undersatnda bility.
13:34:20 <hpc> lispy: agreed; my first step writing my website was to write a function that lifts exceptions into Either
13:34:36 <hpc> c_wraith: but you have sequencing operations like >>=
13:34:51 <hpc> so the explicit handling vanishes until the very end, where it's one line
13:34:52 <dino-> Yes, and build your own exception types using, what is it? RuntimeException?
13:35:00 <lispy> hpc: interesting.  So you made your exceptions implicit in the code you write, but explicit in the monad used?
13:35:10 <c_wraith> hpc: the issue with checked exceptions is the fact that they make writing method signatures even more tedious
13:35:46 <lispy> hpc: so anyone who sees your monad knows they have to deal with exceptions, but the code itself isn't littered with handlers (well really it is, they just look like >>=)
13:36:14 <monochrom> checked exceptions in haskell via type class constraints: http://www.haskell.org/pipermail/haskell/2004-June/014271.html
13:36:36 <hpc> lispy: it's more to get rid of the horrible inconsistencies of exceptions
13:36:50 <hpc> and so i can use "fail" as pure code
13:36:57 <hpc> and handle every problem the same way
13:37:17 <periodic> mmm... I've avoided fail for the most part because it seems inconsistent
13:37:31 <periodic> And because things throw exceptions by default, right?
13:37:35 <periodic> or something...
13:37:42 <c_wraith> I think the fact that most error monads make throw equivalent to fail is a horrible mistake
13:37:43 <periodic> I should use fail more
13:37:50 <c_wraith> I think no one should use fail, ever
13:37:51 <periodic> or maybe not...
13:38:03 <periodic> okay, let me put it this way: I should understand fail better
13:38:10 <periodic> So I know why I'm not  using it.
13:38:21 <hpc> fail is how you pretend to get some continuation behavior
13:38:22 <c_wraith> Fail was originally created for pattern-match failures in <-
13:38:24 <hpc> namely the funky super-goto stuff
13:38:25 <periodic> I think I read the caution about it in RWH and basically just avoided it ever since.
13:38:37 <c_wraith> lines like Just x <- foo
13:38:45 <c_wraith> What do you do when foo is m Nothing?
13:38:59 <c_wraith> answer:  you call fail
13:39:11 <monochrom> I pretty much agree: don't call fail yourself, but it is provided for "... >>= \ (Just x) -> ..."  Don't laugh, it's useful for the list monad.
13:39:21 <c_wraith> But I feel like that's not behavior that really has any need to be in the Monad class
13:39:57 <hpc> i use fail on my website, along with wrappers for each html element
13:40:05 <hpc> so if you do something inside an element, and get an error
13:40:18 <hpc> the error appears inside that element, instead of what would normally be there
13:40:23 <c_wraith> useful as it is for making catMaybes really short, I think not having special behavior for irrefutable pattern match failures in a Monad context would have been better design
13:40:28 <c_wraith> @src catMaybes
13:40:28 <lambdabot> catMaybes ls = [x | Just x <- ls]
13:40:33 <tibbe> could someone do me a favor and make sure that the latest (2.3.0.2) network builds on windows?
13:40:36 <tibbe> just cabal install it
13:41:09 <monochrom> well you could say it should go into a MonadZero type class...
13:41:37 <c_wraith> but it sure does make catMaybes short.  Look at that. :)
13:41:38 <hpc> i could, but i like knowing that any failure whatsoever will get caught
13:42:52 <hpc> there's some sql boilerplate shit, that i can only tersely remove with a pattern match like Just x <- foo
13:42:54 <monochrom> I am too old to revolt. I just accept the status quo and pretend "Monad really means MonadZero and fail really means mzero".
13:42:58 <hpc> or with an exception
13:43:04 <hpc> er
13:43:07 <hpc> with an extension
13:43:35 <hpc> and i like not having pragmas all over my code
13:44:07 <monochrom> (and so the mzero err fail for IO is a catchable exception which is fine for IO)
13:45:00 <monochrom> (whereas mzero for State is likely something I should just avoid)
13:45:23 <dixie> @type 10 `div` 2
13:45:24 <lambdabot> forall t. (Integral t) => t
13:45:32 <ezyang> Hey guys! Turing machines are like zippers! 
13:45:42 <monochrom> oh noes
13:45:49 <dixie> > 10 `div` 100
13:45:50 <lambdabot>   0
13:45:51 <pumpkin> it's a trap!
13:45:57 <dixie> > 10 `div` 100 == 0
13:45:58 <lambdabot>   True
13:46:08 <monochrom> in what perverted sense is turing machine like zipper?
13:46:31 <ezyang> The most natural representation for the Turing machine tape is the zipper of a list. 
13:46:44 <pumpkin> same for its state graph!
13:46:48 <pumpkin> a double zipper
13:46:50 <ezyang> Which makes me wonder if I can have, like, bifurcated tape for zippers of other things. 
13:46:53 <ezyang> Mmmmmm! :-) 
13:47:06 <monochrom> I disagree. mutuble cells are more natural.
13:47:51 <pumpkin> god gave us mutability to test our faith
13:48:11 <monochrom> no, god gave us referential transparency to test our faith
13:49:00 <monochrom> anyway see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/22537/ for really natural ingredients
13:49:54 <monochrom> I like my Campbell soup part. :)
13:50:02 <ezyang> ++ 
13:50:11 <ezyang> Though I wouldn't call Campbell soup natural... 
13:50:18 <monochrom> and of course the "C programmers have to consult us for performance tips" part :)
13:50:24 <ezyang> Bah, the Strathclyde Haskell Enhancement doesn't compile. 
13:51:49 * sm is shocked
13:52:48 <aristid> SHOCKED
13:52:59 <Cin> What's the bot that logs #haskell?
13:53:20 <byorgey> Cin: clog
13:53:22 <ezyang> Conor used it in his presentation today... :^) 
13:53:32 <ezyang> I guess it'sa libraries updating time. 
13:53:45 <Cin> byorgey: is it open source?
13:53:49 <byorgey> Cin: no idea.
13:53:55 <aristid> who runs clog?
13:53:55 <djahandarie> Not sure who maintains that actually
13:54:24 <ezyang> I see clog-parse on hackage... not quite :-) 
13:54:40 * byorgey is pretty sure clog is not written in Haskell
13:54:42 <ezyang> Anyone in here understand Oleg's latest post about multihole zippers and isolation modes? 
13:55:05 <djahandarie> Later than his HList-related one?
13:55:09 <ezyang> yeah 
13:55:10 * djahandarie goes to look
13:55:18 <ezyang> http://okmij.org/ftp/Haskell/Zipper2.lhs 
13:55:24 <djahandarie> Thanks
13:55:24 <Cin> Mmkay.
13:55:33 <Cin> I'll just write a simple bot to log myself. No biggie.
13:55:44 <ezyang> I mean, it sounds pretty cool, and also should be relatively easy to understand... once I understand it :-) 
13:55:55 <ezyang> "i.e. like monads" 
13:57:49 <djahandarie> ezyang, I think the clock on his server stopped... like 6 years ago
13:58:26 <ezyang> What makes you say that? 
13:58:28 <tibbe> ugh, container-0.4 is not tagged in the darcs repo, how am I supposed to know what's in the released version?
13:58:37 <djahandarie> ezyang, the date at the top of that file
13:59:01 <ezyang> oh, that's curious. 
13:59:31 <djahandarie> It does also say Feb 2011 in the X-comment so who knows lol
13:59:36 <ezyang> I wonder why the server suddenly thought it was updated. 
13:59:36 <pumpkin> tibbe: ask whomever didn't tag it ;)
13:59:52 <tibbe> pumpkin: I think I know who that is
13:59:54 <pumpkin> (to tell you what state the repo was in when they didn't tag it)
13:59:55 <pumpkin> ah
13:59:58 <ezyang> Oh, he must have updated it for delimcc, but I never saw it the first time :-) 
14:00:13 <ezyang> Well, rediscovering Oleg is always fun :-) 
14:00:37 <djahandarie> It's crazy that he was doing all this insane stuff before I even knew what Haskell was
14:00:51 <djahandarie> Hell, I barely knew PHP :P
14:01:40 <ezyang> Hmm, what was I doing when I was 15... 
14:01:55 <ezyang> probably nothing important. ahhh childhood. 
14:02:01 <djahandarie> Haha
14:03:02 <periodic> I think I was writing really really bad BASIC.
14:03:17 <monochrom> I was writing good BASIC.
14:03:30 <periodic> I never wrote good BASIC.
14:03:39 <periodic> Because I had no idea how to program back then.
14:03:53 * ddarius had already stopped writing BASIC at 15.
14:04:24 <monochrom> I hand-convert structural programming and procedural programming into BASIC's feeble goto and gosub.
14:04:53 <periodic> I remember how excited I was when I learned about returning from subroutines.
14:04:59 <periodic> You could actually have it return to where you called it from!
14:05:39 <monochrom> yeah but it excitement worn out in 5 minutes because "but what about parameters and return values"
14:05:42 <lispy> I recall being really excited in VB3.0 when I realized that you could return primitive values from function
14:06:08 <lispy> Until that point I had only use procedures
14:06:15 <monochrom> "ok I could designate a few global variables for them. but this stinks."
14:07:10 <periodic> monochrom: I didn't know better.
14:07:12 <monochrom> some years later I went to university and they gave us pascal. "oh finally a sensible language! what, I can recurse too? even better!"
14:07:35 <dankna> yeah, I had the same issue with BASIC
14:07:48 <lispy> I recall thinking C was a huge upgrade from VB
14:07:54 <periodic> And of course after BASIC I think I learned Perl...
14:07:58 <lispy> "Wow, it's so much easier to do stuff!"
14:07:58 <periodic> That did not make my code cleaner.
14:07:58 <dankna> except my next language was C, around age 12, so I learned the real way of doing things soon enough
14:08:04 <dankna> hahaha
14:08:05 <dankna> indeed
14:08:39 * ezyang is always a bit intimidated by people who started so early :-) 
14:08:44 * ddarius went from QBASIC to machine code to C-ish C++.
14:08:46 <dankna> hehe
14:08:50 <ousado> lispy: and you're not thinking that anymore?
14:09:42 <lispy> ousado: Well...C vs VB3, yes I still think that :)
14:09:52 <lispy> ousado: but C vs modern languages, not really
14:11:53 <R3van> is it possible to use pattern matching inside of a lambdafunktion in foldr?
14:12:04 <ddarius> 0xB8 0x05 0x00
14:12:31 <lispy> R3van: use a case
14:12:49 <lispy> R3van: a normal lambda gives you room for just 1 pattern
14:13:01 <lispy> > (\ Just n -> n) Nothing
14:13:02 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
14:13:20 <ddarius> lispy: More parentheses.
14:13:25 <monochrom> you can use (\x y -> case ...)
14:13:55 <lispy> > (\ (Just (n)) -> (n)) (Nothing)
14:13:56 <lambdabot>   *Exception: <interactive>:3:1-19: Non-exhaustive patterns in lambda
14:14:03 <ddarius> @smack lispy
14:14:04 <lambdabot> I won't; I want to go get some cookies instead.
14:14:09 <ddarius> Me too.
14:14:09 <djahandarie> More parentheses!!!
14:14:39 <monochrom> @snack monochrom
14:14:39 <lambdabot> Come on, let's all slap monochrom
14:14:40 <shachaf> > (\ (->) ((Just) (n)) (n)) (Nothing)
14:14:41 <lambdabot>   <no location info>: parse error on input `->'
14:14:43 <monochrom> ...
14:14:50 <djahandarie> Haha
14:14:56 <dankna> lol
14:14:59 <R3van> lispy: Thanks nice to know
14:15:03 <djahandarie> That's what you get for trying to steal cookies from lambdabot monochrom
14:15:14 <lispy> R3van: But a case removes the restrictiion
14:15:23 <djahandarie> shachaf, too bad value-level -> isn't a function. :P
14:15:30 <lispy> > (\n -> case n of Just n -> n; Nothing -> 0) Nothing
14:15:31 <lambdabot>   0
14:15:36 <lispy> R3van: ^^
14:15:39 <djahandarie> (So it's technically not value-level either, I guess)
14:15:50 <shachaf> Syntax-level.
14:15:53 <ddarius> djahandarie: Correct.
14:15:57 <R3van> lispy: i need a pattern matching in lamda because constructors got different number of parameters
14:16:11 <shachaf> I just left the Haskell Hackathon to get some work done and here I am in #haskell.
14:16:18 * shachaf >>= away
14:16:23 <lispy> R3van: use a case like my example above then.  Should work swimmingly
14:16:31 * djahandarie just wanted to differentiate it from the type-level (->)
14:16:36 <R3van> lispy: no sry that wasnt right... they got same number of parameter (1) but i need to handle differnt
14:16:42 <R3van> lispy: ok ill try
14:16:52 <monochrom> lispy's example satisfies "constructors got different number of parameters" no?  Just has 1 parameter, Nothing has 0 parameter.
14:17:00 <djahandarie> I feel like I've been saying a whole lot of uninteresting stuff these days.
14:17:39 * ddarius should probably drink something.
14:17:52 <ddarius> djahandarie: Just stop talking.
14:18:21 * ezyang takes a drink 
14:18:46 <pumpkin> ezyang: drunkard!
14:18:51 <djahandarie> ddarius, that sounded rather harsh. :P
14:19:06 <ddarius> djahandarie: That's one way of reading it.
14:19:26 <djahandarie> ...
14:19:28 <monochrom> it sounded neutrally rational to me.
14:20:24 <ddarius> djahandarie: It worked for John Francis.
14:22:35 --- mode: ChanServ set +o monochrom
14:22:43 --- mode: monochrom set -q $a:Nibble
14:22:47 --- mode: monochrom set -o monochrom
14:24:02 <mzero> 17 folks at BayHac already
14:24:18 <pumpkin> mzero: I hope y'all are hardcore enough to not sleep at all
14:24:25 <pumpkin> 24-hour hacking for three days straight
14:24:41 <ksf> First, you claim that everything about the world is understandable in terms of code. Some time later, you realise that code is more expressive and have proof that all your real-world metaphors are utterly and finally broken.
14:24:47 <ddarius> That's what pumpkin does every day.
14:24:59 <pumpkin> sleep is for the weak
14:25:02 <ksf> yay platonism
14:25:07 <ezyang> ksf: Sounds like math to me. 
14:25:23 <ksf> quite. cps and stuff
14:25:35 <shachaf> pumpkin: You should come keep us awake.
14:25:43 <mzero> pumpkin - I've hung out with the haskellers before -- I KNOW that beer at about 8pm take precedence over coding with these blokes
14:25:45 <pumpkin> shachaf: oh I'll just hop on a plane :P
14:25:48 <ddarius> pumpkin: Not just sleep, living in only 1G is too.   How else are you going to fit 72 hours into 24?
14:25:52 <Tomsik> I was quite sad by realization (um, inspired by some reading) that busy beaver numbers grow faster than any computable functions
14:25:56 <ezyang> But I still think pictures have a really important part in helping understanding. 
14:26:08 <ezyang> Tomsik: How so? 
14:26:13 <shachaf> pumpkin: Exactly!
14:26:14 <pumpkin> Tomsik: they're kind of designed to :P
14:26:20 <pumpkin> or "by construction"
14:26:51 <Tomsik> yeah, but then came realization (quite late) that there will never be a nice math formula for non-P problems
14:27:08 <ezyang> Enh, not necessarily :-) 
14:27:23 <ezyang> It also depends on your definition of "math formula" 
14:28:06 <R3van> lispy: wow works very well thanks
14:28:19 <sciolizer> How do I update lambdabot's hoogle index?
14:28:27 <Tomsik> I mean, if there was a formula that you could compute in polynomial time, it'd be a contradiction
14:28:51 <Tomsik> so, no easy specification of what graphs are 3-colourable, if P != NP
14:29:06 <ezyang> Oh, sure non-P != NP 
14:29:18 <ezyang> But in that light your statement is trivial 
14:29:21 * ksf wonders whether he can visualise this code where upended parts upend the stuff that upended them with some fancy 4d-topology
14:29:39 <ezyang> ksf: upend? 
14:29:45 <pumpkin> non-P == NP if non stands for nondeterministic!
14:29:55 <ksf> evert
14:30:00 <ksf> turn inside out
14:30:11 <ksf> fold back
14:30:13 * hackagebot DataTreeView 0.1 - A GTK widget for displaying arbitrary Data.Data.Data instances  http://hackage.haskell.org/package/DataTreeView-0.1 (DanielSchuessler)
14:30:17 * ezyang thinks of the game... 
14:30:21 <ksf> umstlpen , you know.
14:32:03 <Cale> Tomsik: Well, what's a "nice" formula? :)
14:32:15 <ksf> the kind of code where the first type-checking try is trivial and false, the next one is less trivial and an endless loop, and... well. I grabbed a beer.
14:32:24 <Tomsik> One that is not pernament of a matrix
14:32:25 <Tomsik> :p
14:32:32 <geheimdienst> cale: needs no more than 3 alphabets to write
14:33:04 <Tomsik> Beer is good
14:33:09 <Tomsik> B12 all the way, or something
14:33:32 <Tomsik> especially after most of exams ;)
14:33:51 * ksf still has 0.833 l of that
14:34:40 <ksf> It's not like I'm not in scandinavia, but this piece of land formally belonging to germany does have *one* benefit: the beer is affordable.
14:35:10 <Tomsik> Well, I heard that in scandinavia et al beer is like 3.5$
14:35:11 <Tomsik> %
14:35:17 <Tomsik> of ethanol
14:35:33 <Tomsik> two cans gone, 4x0.5 left in fridge to beat :p
14:35:54 <ksf> 0.5 l of 4.8 and .33 of 4.9, here.
14:36:26 <ksf> 4.5 to 5 is just standard for any pilsner
14:37:03 <NihilistDandy> I heard beer and metric
14:37:21 <ksf> there's no cans here. 25 cents deposit a can killed them
14:37:51 <Tomsik> I dunno, it's 5.6% right now, usually I drink something more like 7-8%
14:37:57 <ksf> and while I didn't think german streets could get any cleaner, they actually did.
14:37:58 <Tomsik> but it's Poland, so who knows
14:38:17 <Tomsik> heh
14:38:49 <Tomsik> some time ago, on one channel I knew I guy who basically lived off collecting cans
14:39:00 <Tomsik> punks or something
14:39:07 <ezyang> yeah, that's a pretty common thing for homeless people to do. 
14:39:39 <NihilistDandy> We should start #homeless
14:40:05 <Tomsik> * ChanServ (ChanServ@services.) has joined #homeless
14:40:05 <Tomsik> * services. gives channel operator status to ChanServ
14:40:05 <Tomsik> * ChanServ (ChanServ@services.) has left #homeless
14:40:06 <ksf> in germany there's one guy who collects cans and lives in the train.
14:40:17 <Tomsik> somebody /has/ thought of that before
14:40:24 <NihilistDandy> Damn
14:40:49 <Tomsik> he was a discordian anyway
14:40:57 <ksf> ...it's something like 1k euro for a year-long netpass, so it's not that hard to do.
14:41:07 <Tomsik> like, it was a channel called #eris and we all were discordian
14:41:50 <ksf> wasn't discordianism this new cover of the satanists?
14:42:07 <Philippa> what? Not one of you up to being a non-discordian just to make the point?
14:44:35 <ksf> yay we sucessfully made #haskell and -blah switch places.
14:44:58 <Tomsik> sssh
14:44:59 <Tomsik> :p
14:45:52 <Tomsik> It's not like there's a distinction anyway
14:46:13 <Tomsik> it just make a possibility of two unrelated threads to happen at once without interleaving
14:46:52 <aristid> ksf: according to the #haskell-blah topic, this is the case since january 25
14:46:56 <Philippa> not sure -blah's conversation is on-topic per se anyway
14:47:01 * ksf is constantly surpised by the amount of non-hacker discordians
14:47:34 <Tomsik> usrj
14:47:35 <Tomsik> yeah
14:47:44 <ksf> if you look anywhere outside of the usual places, the artsy (and/or utterly insane) type is the majority.
14:48:24 * ezyang doesn't really understand discordians 
14:48:33 <Philippa> yeah, the hacker's appreciation for discordianism is a little different
14:49:42 <NihilistDandy> Blah, discordians
14:49:48 <Tomsik> blah blah
14:50:14 <hape_> Where do I find haskell-mode-2.8 for emacs .tar? cant find the download anymore...
14:50:22 <Tomsik> I dunno, discordians to me seem to be more of woodstock/psychodelic/punk types
14:50:29 <Tomsik> omg ontopic
14:50:47 <NihilistDandy> Tomsik: All the Discordians I knew in college were just a more annoying variant of atheist :/
14:50:55 <ksf> or, you know, people actually reading (and even understanding) carroll et al
14:51:05 <ksf> yeah. that's the other kind.
14:51:27 <Tomsik> NihilistDandy: there's two kinds of discordians
14:51:31 <ksf> those that could just as well be pastafari
14:51:32 <Tomsik> the annoying hot-dog ones
14:51:45 <Tomsik> and the ones with more buddhist background
14:51:52 <NihilistDandy> ksf: Yeah. Pastafarians were the other annoying group
14:52:28 <ksf> the "omg religion is stupid hey that there is funny no I'm not interested in why a gazillion people dig religion" knid
14:52:32 <ksf> kind, even.
14:52:35 <NihilistDandy> Yup
14:52:37 <lispy> I thought Pastafarians were just in the kindom of loathing (or maybe that was Pastamancers)
14:53:34 <NihilistDandy> Then again, perhaps I'm not the best person to ask about which quasi-religious groups are annoying. :D
14:57:42 <monochrom> hape_: I see the usual location has lost it. If you trust me, my copy is at http://www.vex.net/~trebla/tmp/haskell-mode-2.8.0.tar.gz
14:58:07 <kfr> That one contains an elisp root kit
14:58:11 <mreh> vim support for haskell is poor
14:58:11 <ksf> don't trust him, he's greyface reincarnate!
14:58:38 <kfr> It uses a local privilege escalation to root your box through emacs
14:58:39 <hape_> monochrom: that is nice
14:58:42 * ksf reads his last sentence and realises he's bored
14:58:49 <kfr> Works up to and including 2.6.37
14:59:24 <NihilistDandy> Wow, I think my haskell-mode is way out of date :D
14:59:41 <parcs> monochrom: any reason not to trust you? :P
14:59:43 <mreh> whatever happened to yi becoming the haskell editor of choice?
14:59:58 <sm> pshhh
14:59:59 <hape_> haskell mode 2.8.0 runs well
15:00:18 <monochrom> yi becomes the haskell editor of choice by lazy evaluation
15:00:26 <shachaf> mreh: I think byorgey took over that.
15:00:36 <NihilistDandy> Oh, nevermind. The version number's just funky
15:00:48 <NihilistDandy> I just got it through darcs
15:00:51 <shachaf> Or, hmm, "Daniel Santa Cruz".
15:01:05 <ksf> yi's problem is that its backends are kinda buggy, and, most importantly, that it isn't integrated with leksah
15:01:18 <mreh> people use leksah?
15:01:22 <aristid> @quote leksah
15:01:22 <lambdabot> geheimdienst says:  i totally didn't realize that leksah = reverse haskel. i thought leksah was what the lolcats said for lexer
15:01:27 <ksf> ...as that would be a valid reason to switch to a vi that dares to leave out 99.9% of ex
15:01:44 <ksf> oh, and let's not forget hare.
15:02:01 <mreh> krishna krishna
15:02:06 <NihilistDandy> hare hare
15:02:11 <ksf> but hare really, really needs to start to grok sources with extensions
15:02:19 <periodic> Yeah, I wish there were better support for haskell in Vim.  mostly just semantic-checking-on-save.
15:02:22 <ksf> even if it bails out when it doesn't understand something.
15:02:22 <monochrom> @quote leksah.fur
15:02:22 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
15:02:28 <periodic> I wonder if I could get that working...
15:02:59 <aristid> monochrom: this is the one i expected, but the other one is good too
15:03:42 <ksf> iirc yi doesn't even understand range modifiers for ex substitutions, not to mention generalises the whole thing.
15:04:13 <mreh> any hoodlums here?
15:04:31 <NihilistDandy> All hoodlums
15:04:48 <mreh> (haskell users' group)
15:09:34 <accel> what should I read up on for fast arrays in haskell; it's okay if updates are destructive
15:11:05 <monochrom> Data.Array.Unboxed
15:12:11 <monochrom> oops that's immutable.
15:12:36 <monochrom> Data.Array.MArray, then look for IOUArray and STUArray.
15:16:35 <tibbe> accel: the vector package is also very good
15:16:46 <monochrom> I am writing "<code>const</code>" in html. I accidentally "<const>const</const>".
15:17:04 <ddarius> monochrom: Too much C++.
15:17:25 <monochrom> no C++. this is our const function.
15:18:23 <accel> monochrom , tibbe : thanks
15:18:31 <tibbe> accel: you're welcome
15:20:26 * hackagebot snap-core 0.4.0.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.4.0.1 (GregoryCollins)
15:20:41 * pumpkin tries to decide which of several projects to work on tonight
15:20:55 <ddarius> pumpkin: Want to go somewhere to eat instead?
15:21:06 <pumpkin> ddarius: sure, that sounds better :P
15:21:28 <pumpkin> have anywhere in mind?
15:21:45 <ddarius> Nowhere in particular in your area.
15:21:57 <pumpkin> I can go over to your area!
15:22:09 <ddarius> I wouldn't mind sushi, but I also wouldn't mind killing myself with beef either.
15:22:45 <tibbe> pumpkin: how about array copy ;)
15:22:51 <pumpkin> tibbe: it works :P
15:23:03 <aristid> beef.
15:23:04 <pumpkin> tibbe: or rather, I uploaded a version with the bug that JaffaCake1 pointed out fixed
15:23:14 <ezyang> Compromise: Steak Tartare :-) 
15:23:15 <pumpkin> tibbe: so I'm just waiting on him now
15:23:19 <pumpkin> I love steak tartare
15:23:27 * hackagebot snap-server 0.4.0.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.4.0.1 (GregoryCollins)
15:23:42 <tibbe> pumpkin: ok, does he know that you're waiting for him?
15:24:00 <periodic> I'm trying to figure out what to work on tonight.  Any ideas for an intermediate Haskeller?
15:24:01 <pumpkin> tibbe: I didn't explicitly notify him, nope. I assumed he was on the ticket cc list but maybe not, now that I think of it
15:24:11 <tibbe> pumpkin: ok
15:24:21 <pumpkin> ddarius: know any good steak or sushi places? 
15:24:22 <periodic> I was thinking of trying to find some of the Yesod folks and see if there were some bugs or docs I could work on as I learn the framework.
15:24:32 <hape_> periodic: Yesod makes fun I think, i would do that if I would be an intermediate Haskeller hihi
15:24:42 <periodic> Where are you guys?  MV?
15:24:57 <djahandarie> periodic, Yesod folk(s) is mainly snoyman
15:24:59 <shachaf> periodic: Hacker Dojo.
15:25:12 <ddarius> pumpkin: The sushi place that I go to isn't any good, but there's another one I haven't gone to, but I doubt it's as good as the places around you.  Redbones is a pleasant place for meat.
15:25:14 <periodic> there's a good sushi place by 82 and 85.
15:25:22 <periodic> It's at El Camino and Americana
15:25:35 <djahandarie> ddarius and pumpkin are on the other side of the country :P
15:25:35 <ezyang> ++redbones 
15:25:35 <periodic> It's not in walking distance though.
15:25:39 <periodic> oh.
15:25:41 <periodic> ppft.
15:25:47 <djahandarie> Definitely not in walking distance
15:25:49 <ddarius> periodic: Sure it is.
15:25:51 <periodic> I thought shachaf was answering for them.
15:26:29 <periodic> hape_: My background is primarily web dev, so web frameworks are something I actually feel qualified to work on.
15:26:36 <periodic> hape_: and yeah, it's fun.
15:26:44 <djahandarie> Nope, he was answering where he was, and where a fairly large Haskell hackathon is going on right now
15:26:55 <periodic> djahandarie: I plan to be there later tonight.
15:27:13 <periodic> If only I could get all my work stuff finished up.
15:27:20 <djahandarie> :-) I'm closer to pumpkin and ddarius though so you won't see me ;)
15:27:31 <ddarius> pumpkin: If you are interested in Redbones, it's a short walk from the Davis Square stop on the Red Line.
15:27:34 <gwern> > 250 * 0.5
15:27:35 <lambdabot>   125.0
15:27:44 <ddarius> djahandarie: Well certainly not if you don't start walking.
15:27:45 <mrd> ppl are in boston?
15:27:57 <ddarius> mrd: No, just sheep.
15:27:59 <pumpkin> ddarius: sounds good
15:28:05 <mrd> sheeple i c
15:28:09 <ddarius> mrd: No, just sheep.
15:28:23 <hape_> What is the desugared of "data Typus2 = Abc { aaa :: String }"
15:28:44 <ddarius> hape_: What makes you think that that is sugared?
15:29:22 <mrd> P.S. the red line is a disaster right now
15:29:24 <periodic> Correct me if I'm wrong, but record types are all just "Constructor Type Type" and our record names a basically just `name (Constructor _ var _ _) = var` and similar, right?
15:29:27 <pumpkin> it's desugared into typedef struct Typus2 { HSString* aaa; } Typus2;
15:29:51 <periodic> That doesn't explain the record syntax that modifies only certain fields though...
15:29:53 <hape_> pumpkin: that is c?
15:29:57 <ddarius> periodic: Close.
15:29:59 <pumpkin> hape_: I'm just kidding :P
15:30:18 <hape_> :-)
15:30:29 <ddarius> Yeah, there should be an extra indirection there.
15:30:30 <periodic> ddarius: Alright, I'll take that to mean I don't have to make a fundamental shift in my thinking just yet. :P
15:31:13 <hape_> ddarius: dont know unfortunatelly
15:31:18 <pumpkin> unlike a certain language whose name I shan't mention where records are actually different from data in nontrivial ways
15:31:27 <ddarius> pumpkin: What time is good for you?
15:31:30 * hackagebot hog 0.1 - Simple IRC logger bot.  http://hackage.haskell.org/package/hog-0.1 (ChrisDone)
15:31:41 <periodic> Damnit, why am I stuck at work.  I'm excited to go meet other people who actually like Haskell.
15:31:42 * djahandarie wonders what pumpkin and ddarius discuss over the dinner table
15:31:52 <djahandarie> Oh wow, that was chris who was asking about that?
15:31:53 <periodic> I was lucky to find one other person at this company who even knows what Haskell is.
15:31:55 <ddarius> djahandarie: Mostly djahandarie.
15:32:01 <pumpkin> djahandarie: yeah, just you
15:32:07 <djahandarie> That's a bit strange.
15:32:30 <djahandarie> There must be some wider common ground than me :P
15:32:45 <pumpkin> djahandarie: murder, torture, etc.
15:32:49 <aristid> djahandarie: they probably discuss how to pronounce your name
15:33:02 * djahandarie takes not to not ask this sort of question again
15:33:02 <aristid> "is he a real DJ?"
15:33:07 <pumpkin> ddarius: it'll take me about 45 minutes to get there from here, probably, but any time >= now + 45 minutes
15:33:08 <djahandarie> note*
15:33:19 <ddarius> aristid: Not likely as his name is my nick (uh, minus a d.  But -which- d?)
15:33:39 <djtiesto> djahandarie: I'm more famous than you
15:33:49 <djahandarie> :-(
15:34:03 <djahandarie> You have more twitter followers than me anyways, even on your normal nick!
15:34:13 * ddarius really wants to go to a DJ Tisto concert some time.
15:34:16 <djahandarie> By a factor of like, 1000x I'm pretty sure :P
15:34:27 <aristid> ddarius: your ds are as equivalent as id and id'
15:34:32 * hackagebot hog 0.1.1 - Simple IRC logger bot.  http://hackage.haskell.org/package/hog-0.1.1 (ChrisDone)
15:34:37 <copumpkin> djahandarie: hah, probably not that bad
15:34:40 <copumpkin> ddarius: me too!
15:34:53 <ddarius> aristid: But how many proofs of them being equivalent can you find?
15:35:27 <ddarius> copumpkin: By "probably not that bad" copumpkin means > 1000x
15:35:42 <aristid> > 'd' == 'd'
15:35:43 <lambdabot>   True
15:35:46 <aristid> qed
15:36:11 <djahandarie> @check const ('d' == 'd')
15:36:11 <lambdabot>   "OK, passed 500 tests."
15:36:14 <djahandarie> QED
15:36:27 <djahandarie> wb Cin
15:36:27 <ddarius> > not ((1/0) /= (1/0) -- QED
15:36:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:36:33 <ddarius> > not ((1/0) /= (1/0)) -- QED
15:36:34 <lambdabot>   True
15:36:59 <aristid> Double is broken
15:37:20 <aristid> at least in this regard
15:37:23 <Philippa> ddarius: why tiesto? He's always struck me as a mediocre latecomer, though maybe I missed something
15:37:53 <djahandarie> ddarius has never heard mediocre music before so he feels like he has to at least once
15:37:58 <NihilistDandy> Does the name Jon Harrop mean anything to anyone?
15:38:02 <ddarius> Philippa: Because his concerts have a lot of people and the music is adequate.
15:38:03 <copumpkin> NihilistDandy: it sure does!
15:38:22 <Philippa> NihilistDandy: I think it's next to "trolling arsehole" in the dictionary, why?
15:38:23 * djahandarie would prefer a Denki Groove concert
15:38:25 <NihilistDandy> Good/bad?
15:38:26 <blackdog> NihilistDandy: he's a very enthusiastic OCaml plugger
15:38:27 <blackdog> to be as kind as possible.
15:38:34 <NihilistDandy> I noticed
15:38:35 <copumpkin> blackdog: nah, he hates ocaml these days
15:38:39 <Philippa> actually, worse - he's admitted to trolling for profit
15:38:41 <ddarius> blackdog: What about F#?
15:38:42 <blackdog> oh, really? F#, then?
15:38:42 <copumpkin> blackdog: he's all for F# these days
15:38:46 <blackdog> ah, gotcha.
15:38:48 <NihilistDandy> I keep running across his name in Haskell and Lisp threads
15:38:55 <NihilistDandy> All F# this, F# that
15:39:14 <Philippa> F### Harrop? (...no thanks)
15:39:18 <djahandarie> Haha
15:39:26 <accel> i think he's just a big ocaml fan
15:39:38 <accel> i.e. didn't he write ocaml for scientists?
15:39:50 <Philippa> accel: to put it another way, he has commercial interest in ocaml
15:39:56 <NihilistDandy> He's everywhere. I don't know how he finds the time to work his way into every conversation I've read
15:40:02 <Philippa> and yes, he really has openly admitted to trolling to draw in consulting gigs
15:40:12 <accel> Philippa: he has commerical interest in people feeling inferior & deciding they need to learn ocaml via "Ocal for Scientists"
15:40:19 <NihilistDandy> He needs a new web designer
15:40:22 <NihilistDandy> For real
15:40:36 <djahandarie> ddarius, http://www.youtube.com/watch?v=tRfqWOOmNXk
15:40:40 <NihilistDandy> http://www.ffconsultancy.com/
15:40:45 <NihilistDandy> What a mess
15:40:46 <djahandarie> (If your internet can handle youtube videos)
15:40:51 <aristid> NihilistDandy: don't link to the evil!
15:40:55 <NihilistDandy> lol
15:41:33 <NihilistDandy> I had honestly started thinking he was some elder evil stalking my thoughts around the internet
15:41:40 <NihilistDandy> Man has no life
15:41:49 <Philippa> so, in paranoid mode, the next question'd be: is NihilistDandy actually trying to draw hits to Harrop's site?
15:41:52 <djahandarie> NihilistDandy, you seem unnaturally angry
15:41:58 <djahandarie> lol Philippa
15:42:11 <NihilistDandy> lol, no. I was just curious if I was the only one that had noticed this
15:42:13 <accel> bad publicity is better than no publiity
15:42:20 <NihilistDandy> This'll be the last word I speak of him :D
15:42:23 * geheimdienst is delighted to see anybody who actually knows denki groove
15:42:44 <djahandarie> geheimdienst, probably one of my favorites :)
15:43:03 <djahandarie> I've been trying to figure out when their next concert/tour is but it's proving to be hard
15:43:12 <ddarius> djahandarie: Too much singing, not enough rhythm.
15:44:17 <blackdog> djahandarie: any recommendations? could use some new music.
15:45:05 <NihilistDandy> djahandarie: I've heard these people before, but I can't begin to think of where. Has their music been in anything?
15:45:19 <Cin> The only reason I'm glad JH exists is so that I have a true, pure example of a troll that I can point to when explaining the concept.
15:45:24 <djahandarie> blackdog, of a Denki Groove song?
15:45:30 <djahandarie> NihilistDandy, anime
15:45:35 <NihilistDandy> lol, that might be it
15:45:44 <blackdog> djahandarie: one you'd recommend
15:45:53 <djahandarie> ddarius, most of their songs are decently heavy on the lyrics
15:45:58 <blackdog> Cin: almost a Platonic troll?
15:46:29 <blackdog> none of this shadows on the wall stuff...
15:46:47 <ddarius> djahandarie: I'm looking more for trance, and I don't care for vocal trance.
15:47:38 <ddarius> And anyway, most singers shouldn't.
15:48:17 <djahandarie> blackdog, my favorite is probably the one I linked already. http://www.youtube.com/watch?v=p8Qa4e-9Y8c here is the album version
15:48:20 <Cin> ddarius: http://www.youtube.com/watch?v=TAt0X2nlXZo
15:48:22 <djahandarie> ddarius, http://www.youtube.com/watch?v=0Wo0BDFupqo something like this?
15:48:31 <djahandarie> Listen to both! At the same time!
15:48:32 <blackdog> djahandarie: oops, not watching the channel :) thanks
15:48:41 <djahandarie> np
15:49:05 <blackdog> been a bit stuck in an indie groove lately. can't be all Menomena and Les Savy Fav
15:49:09 <djahandarie> Cin, it's too bad only some of deadmau's stuff is good
15:49:27 <NihilistDandy> Nothing wrong with Menomena
15:49:43 <djahandarie> Cin, by that I mean it's particularly hit-or-miss with him
15:49:57 <Cin> I only like this track.
15:50:08 <blackdog> NihilistDandy: no, they're great - saw them at the Factory in Marrickville on Monday
15:50:29 <NihilistDandy> Neat
15:50:48 <ksf> periodic, yi if you don't mind
15:50:53 <NihilistDandy> You know Margot and the Nuclear So-and-sos?
15:51:27 <ddarius> Cin: A little too slow so far, but definitely closer.
15:51:36 <ksf> there's a lot to do concerning the emulations, which requires some thought and possibly inginuity to get elegant, but it's not magic
15:52:19 <Cin> ddarius: Yeah, I surmised that you'd be after something more upbeat. I can't think of much lyricless trance.
15:52:32 <periodic> ksf: hm, yeah, yi does need some work.
15:52:49 <ddarius> Cin: That's odd.  I identify trance with mostly lyricless music.
15:52:57 <blackdog> NihilistDandy: nah, haven't heard them. good?
15:53:04 <Philippa> it's definitely mostly lyricless regardless of the vocals
15:53:14 <Philippa> far more so than eg house
15:53:15 <NihilistDandy> blackdog: I quite enjoy them. You might like. Let me find a YouTube link
15:53:23 <ddarius> Philippa: Indeed.  I don't mind ooo's and aaa's and choir effects.
15:53:26 <periodic> ksf: is yi active, or did it stop getting much attention recently?
15:53:39 <NihilistDandy> blackdog: http://www.youtube.com/watch?v=0AovtZ1Zxdw
15:53:55 <ddarius> Philippa: Do you have a good trance song recommendation?
15:54:02 <Philippa> ddarius: got any preferred sounds within the genre? I seem to mostly go for classic, progressive and acid trance myself
15:54:42 <Philippa> (I'm also mostly too lazy to keep track within it though - aside from a couple of compilations from around the tail end of the trance boom here I just grab a stream off DI and listen to that normally)
15:54:42 <ddarius> Philippa: I'm not that refined.  I don't listen to any trance music most of the time.
15:55:04 <NihilistDandy> blackdog: Actually, everything off the Daytrotter Sessions EP is pretty great as an introduction
15:55:05 <ddarius> copumpkin: How does ~8:15 soundL
15:55:06 <Philippa> http://www.assortedtrance.com/ <- plenty of mixes here to play around with
15:55:10 <ddarius> s/L/?
15:55:12 <copumpkin> ddarius: good!
15:55:21 <Cin> ddarius: Are you aware of di.fm?
15:55:30 <aristid> ddarius: syntax error
15:55:32 <Cin> (Checkout the trance station on that)
15:55:34 <Philippa> and yeah, was about to mention DI more explicitly
15:55:44 <Philippa> not just the main trance stations, there're several subgenre ones now
15:55:53 <aristid> Philippa: dependency injection?
15:55:58 <ddarius> Cin: I've actually had it mentioned to me just yesterday, but I hadn't heard of it before and haven't gone to it.
15:56:31 <ksf> periodic, http://groups.google.com/group/yi-devel seems active
15:56:34 <Philippa> DI's well worth listening to both for new tracks and genres you haven't played around with enough
15:56:55 <Cin> My only problem with DI is the ads.
15:57:07 <Cin> Soma fm's trance stream is mostly instrumental with no ads: http://somafm.com/play/tags
15:57:09 <ddarius> There's a band that that person told me to look at (not trance related, he described it as "alternative folk")
15:57:25 <Philippa> yeah. I've actually got a paid DI membership though, they've been good to me over the years
15:57:51 <Cin> I might get a paid membership.
15:57:57 <periodic> ksf: I'm a little wary of making yet another editor.  Most people already have an editor they are comfortable with, and it will takea  lot to get people to switch.  People are also pretty fanatic about their editor.
15:58:00 <Philippa> did Soma ever resurrect House Party after they went off-air during the RIAA/play fees mess 8 years back?
15:58:09 <blackdog> NihilistDandy: it's a bit twee, but it's cute.
15:58:22 <ksf> I'm fanatic about my keybindings, not about the code that implements them.
15:58:24 <Mathnerd314> hmm, it ought to be easier to just make your own mixes... (they're mostly just repeated special effects, right?)
15:58:24 <Cin> Recently I've been listening to soundtracks. I've been listening to Call of Duty's soundtrack, quite good.
15:58:43 <ksf> ...and I couldn't vimscript myself out of a wet paperbag
15:58:44 <aristid> so who's actually talking about haskell? i guess yi almost qualifies
15:58:54 <Philippa> Mathnerd314: if it's so easy, why aren't you a superstar DJ already?
15:58:56 <NihilistDandy> blackdog: They have better stuff, mind you. It was just the first youtube auto-complete
15:58:57 <NihilistDandy> :D
15:59:15 <Cin> Philippa: D'no, I was always a Groove Salad/Secret Agent/Drone Zoner myself.
15:59:44 <ksf> I'd hack on the vi emulation myself it my mind wouldn't be insisting on hacking on iteratee stuff
16:00:01 * ddarius tries to remember what old game he used to play that had a trance-y soundtrack that was well-matched to the game.
16:00:24 <lispy> ddarius: pacman?
16:00:26 <Philippa> there've been a few
16:00:30 <aristid> ksf: tough decisions :)
16:00:31 <hape_> it compiles but it does not print out.  I think the   instance Show ... is incomplete. Any tips for me?  http://hpaste.org/43898/records__show
16:00:41 <blackdog> aristid: good point. i _am_ trying to get hubris out today - i got a bit of a kick up the arse from noticing it's the second-most watched Haskell repo on github, and still almost completely uninstallable...
16:00:46 <NihilistDandy> blackdog: http://www.youtube.com/watch?v=d81alZAYQ8g
16:00:49 <NihilistDandy> May be more your taste
16:00:52 <Philippa> wip3out did alright, though a lot of people were a bit irritated because it was more populist for the time than earlier games in the series had been with their soundtracks
16:00:52 * Cin chases lispy around a maze
16:01:01 <periodic> ksf: yeah, I'm mostly using Vim right now, and I feel like the best improvement to my workflow would be a few extra integrations with Vim.  That way I can still leverage all the existing vim features and plugins.
16:01:12 <Cin> One game soundtrack I love is Goldeneye 64's.
16:01:37 <aristid> blackdog: what's hubris?
16:01:37 * ezyang should figure out how autocomplete in vim works... 
16:01:37 <ddarius> Philippa: It was a game similar to Star Fox in perspective and game-play, but faster-paced and with a cyberspace theme.
16:01:39 <Philippa> Unreal Tournament's is excellent
16:01:43 <Cin> It has that running-through-corridors edge about it.
16:01:47 <Philippa> Rez?
16:01:47 <ddarius> It was a PC game.
16:01:51 <Cin> True, UT's is good too.
16:01:57 <ddarius> Philippa: No.
16:02:04 <Philippa> though Rez is well worth a go too
16:02:12 <Cin> (Though I personally always played Prodigy when playing UT.)
16:02:36 <ddarius> This would have been like mid-90's or so.
16:03:45 <Philippa> eh, I'd definitely take the UT soundtrack over anything the Prod've done for UT itself
16:03:55 <Philippa> amongst other things it was very well-matched to the game itself
16:04:08 <blackdog> aristid: haskell-ruby bridge
16:04:22 <Cin> http://www.youtube.com/watch?v=CgROKIAeS3Y -- They really took the Bond theme and made awesome stuff out of it for GE64.
16:04:27 <blackdog> it does work, you just have to sacrifice a goat to Bathomet to get the bastard installed
16:04:34 * copumpkin quite likes certain ATB songs
16:04:37 <djahandarie> Something nice I stumbled upon randomly the other day http://www.youtube.com/watch?v=M-_6wk99Xlw
16:04:38 * copumpkin hides in shame
16:04:46 <copumpkin> by the way, why are we talking about music in #haskell?
16:04:47 <blackdog> NihilistDandy: nice track, thanks
16:04:57 <thoughtpolice> best thing i've seen today inside GHC's RTS:
16:05:04 <thoughtpolice>  ASSERT(2+2 == 5);
16:05:04 <copumpkin> I'd be a bad op if I didn't ask the question at least
16:05:08 <Cin> copumpkin: 'Cause conversation doesn't happen in threads in IRC. :p
16:05:10 * copumpkin goes back to doing other things
16:05:10 <NihilistDandy> blackdog: Glad you liked it. :)
16:05:22 <djahandarie> thoughtpolice, hah
16:07:28 <Philippa> ddarius: no idea about the game, anyway
16:08:46 <jmcarthur> thoughtpolice: wtf
16:09:09 <jmcarthur> "not supposed to get here" kind of thing?
16:09:16 <djahandarie> I hope it is
16:09:40 <djahandarie> Maybe "if you get here you better be inconsistent enough to assert this"?
16:10:16 <shachaf> Isn't ASSERT typically only checked in debug mode?
16:10:18 * jmcarthur watches smallcheck melt his cpu
16:10:28 <jmcarthur> sometimes smallcheck is awesome and sometimes it's not :)
16:11:00 <jmcarthur> guess i should whip out quickcheck for this one
16:11:08 <ezyang> hehe 
16:11:21 <copumpkin> GHC's assertions are deeply magic
16:11:25 <copumpkin> people should use them more
16:11:33 <monochrom> "if you get here, we now rule Oceania, so we can now tell people 2+2==5 and they will obey"
16:11:41 <dankna> smirk
16:12:43 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v:assert
16:12:44 <copumpkin> that 
16:13:00 <monochrom> yes that one is very nice
16:13:10 <ezyang> Oh, I thought you were talking about assertions in GHC itself :-) 
16:13:22 <copumpkin> ezyang: nah, but the nice thing about that assert
16:13:25 <monochrom> we are talking about both
16:13:25 <copumpkin> is that it puts in the source location
16:13:27 <copumpkin> magically!
16:13:35 <copumpkin> and disappears with -O
16:13:41 <jmcarthur> copumpkin: wtf
16:13:50 <copumpkin> it's a rewrite rule
16:13:51 <thoughtpolice> jmcarthur: yep
16:13:59 <copumpkin> it's not too voodooish
16:14:04 <jmcarthur> special rule?
16:14:04 <copumpkin> but still pretty voodooish
16:14:10 <copumpkin> I think so, yeah
16:14:11 <periodic> Huh, that's handy.
16:14:11 <thoughtpolice> jmcarthur: it exists inside the monster that is Linker.c
16:14:17 <periodic> I should use assert more..
16:14:38 <copumpkin> ddarius: leaving now
16:14:48 <periodic> assert doesn't break laziness?
16:15:04 <copumpkin> why would it?
16:15:07 <periodic> will it force evaluation of its first argument?
16:15:16 <monochrom> you could arrange assert to break or not break laziness
16:15:18 <periodic> Dunno, maybe it has something to do with knowing the source location or something.
16:15:43 <copumpkin> oh, it will change the behavior of your program based on -O if your program depends on whatever you pass in as the Bool not being evaluated
16:15:48 <jmcarthur> i'm intrigued by the 'lazy' function above it in the same file, too
16:15:53 <periodic> copumpkin: good point.
16:16:20 * copumpkin disappears
16:16:27 <periodic> copumpkin: but if it's a pure Bool it should really only change performance, not correctness, right?
16:16:54 <monochrom> "let x=undefined in assert x 0" breaks laziness. but this is not how you use it anyway.
16:17:58 <monochrom> "let x=y+y in assert (x/=0) (5/x)" it is not like you are really lazy about x or y.
16:19:42 <periodic> Yeah, I guess it is just a function that does force its first argument to be a Bool or not, then returns the second argument.
16:21:20 <ddarius> Philippa: Delta V
16:22:49 <Philippa> ddarius: ah, don't think I ever played that
16:23:05 <ddarius> I need to find it and see if it is as good as I remember it being.
16:23:20 <ddarius> But right now I have to leave.
16:25:09 <periodic> Alright, off to the Dojo!  Time for a weekend of Haskell.
16:28:03 <Cin> Enjoy.
16:30:09 <ksf> import Magic.CrystalBall
16:30:21 * ksf 's code needs to look into the future
16:31:49 <Veinor> makeOfflineAlgorithm yourCode
16:32:22 <ksf> ...the problem being that MonadPeel doesn't like it when the inner action needs a variable amount of outer actions to be performed.
16:33:40 <ksf> ...and I can't just "capture the state" as the haddock says because that state lives in IO.
16:34:05 <ksf> ...and I can't hack around that with forkIO because I don't have MonadIO available in the function
16:38:05 <parcs> is the new version of the platform scheduled to be released today?
16:39:01 <Philippa> what're the usual recommendations for 'intro to category theory' texts around here at the moment?
16:39:09 <Veinor> the awodey pdf?
16:39:25 <Eduard_Munteanu> Is that still available?
16:39:27 <Veinor> http://elephant-closet.com/awodey.pdf
16:40:49 <Eduard_Munteanu> Doesn't bcpierce also have a book on CT?
16:40:58 <Eduard_Munteanu> I wonder how it compares to Awodey's.
16:42:58 <gienah> Eduard_Munteanu: bcpierce book on category theory by other peoples accounts is not anywhere near the same standard as his book on type theory
16:43:08 <ksf> .oO( unsafePerformIO newIORef )
16:43:22 <ksf> that is, blackhole the thing.
16:43:45 <djahandarie> I'm reading Awodey's currently
16:44:15 <Eduard_Munteanu> I am too.
16:45:17 <gienah> I have been *trying* to buy this book, I sent 3 emails, no response so far: http://crm.umontreal.ca/pub/Ventes/desc/PM023.html
16:45:42 <djahandarie> I hear it's good
16:46:20 <hape_> bye
16:46:35 <gienah> Guess I try sending more pleading emails, change please to pretty please with sugar on top, love you for life ...
16:46:58 <djahandarie> Or try to get it from a library? :P
16:47:11 <djahandarie> Or from someone in here, I'm sure someone has it
16:47:45 <Eduard_Munteanu> Hrm, is it so hard to just put up a PDF online when something goes out of print?
16:48:21 <gienah> thanks, will keep trying. Its still in print, just that uni of montreal is the only place that sells it as far as I know
16:49:57 <Eduard_Munteanu> Bah, enough sleep deprivation, I'm out :)
16:50:12 <gienah> Eduard_Munteanu: good night
16:50:22 <Eduard_Munteanu> G'night there too.
16:57:31 <Cale> gienah: do you have Awodey's book?
16:58:12 <Cale> gienah: It's not specifically about the relationship of CT to CS, but it's fairly self-contained, and good for interested computer scientists.
16:58:46 <Cale> Oh, other people have already mentioned it :)
16:59:34 <gienah> Cale: no, thnaks, maybe I should try Awodey's book
17:04:53 <Funktorsalat> is there a way to write apply :: Typeable b => (forall a. Typeable a => F a -> R) -> b -> Maybe R, even using unsafeCoerce?
17:05:06 <Funktorsalat> (given Typeable1 F)
17:05:34 <Funktorsalat> I can't cast the 'b' to 'exists a. F a' :)
17:05:48 <Funktorsalat> (and I don't think an existential wrapper would work)
17:07:33 <Funktorsalat> I can take apart the TypeRep of the 'b' and thus determine whether it is of the form F a, but that still won't let me apply the function in case it's true
17:08:03 * hackagebot snap-core 0.4.0.2 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.4.0.2 (GregoryCollins)
17:08:50 <Cin> byorgey: https://github.com/chrisdone/hog there we go. :-)
17:09:03 * hackagebot snap-server 0.4.0.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.4.0.2 (GregoryCollins)
17:10:23 <Cin> http://hackage.haskell.org/package/hog or in Hackage flavor.
17:12:49 <aristid> @hackage hog
17:12:49 <lambdabot> http://hackage.haskell.org/package/hog
17:15:10 <gwern> @quote
17:15:10 <lambdabot> dentists says: suck
17:15:24 <gwern> @forget dentists suck
17:15:24 <lambdabot> Done.
17:15:34 <gwern> they are a noble breed who do useful work
17:15:58 <shachaf> @quote
17:15:58 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
17:16:15 <gwern> shachaf: you broke @quote!
17:16:18 <shachaf> @forget Plugin `quote' failed with: getRandItem: empty list
17:16:18 <lambdabot> No match.
17:16:24 <shachaf> Ah, well. It was worth a try.
17:16:45 <shachaf> @quote
17:16:46 <lambdabot> elpolilla says: <elpolilla> no se, me desperte pq tenia ganas de cagar | <elpolilla> y termine cagando, banandome y despues en la pc xD
17:16:55 <Funktorsalat> (this is for DataTreeView, which is supposed to be able to display nodes of the Data tree in user-definable ways... I wouldn't write such parametricity-breaking stuff normally :p)
17:16:55 <aristid> @quote leksah
17:16:55 <lambdabot> geheimdienst says:  i totally didn't realize that leksah = reverse haskel. i thought leksah was what the lolcats said for lexer
17:17:06 <aristid> gwern: @quote still works
17:17:12 * gwern didn't realize leksah meant anything at all
17:17:13 <Veinor> haha
17:17:31 <aristid> it should be LLeksah
17:17:40 <shachaf> @localtime gwern
17:17:45 <aristid> the Llama of text editors
17:17:48 <aristid> @time gwern
17:17:53 <aristid> @time shachaf
17:17:54 <lambdabot> Local time for shachaf is Fri Feb 11 17:40:01 2011
17:17:56 <aristid> @time aristid
17:17:57 <lambdabot> Local time for aristid is Sa. Feb 12 02:40:04 2011
17:18:03 <aristid> gwern: you evil time disabler
17:18:10 <shachaf> gwern: ?
17:18:19 <gwern> it's not paranoia when they're out to find out your local time!
17:18:24 <aristid> shachaf: where are you?
17:18:40 <shachaf> aristid: In the same time zone as my IRC client, but this is a complete coincidence.
17:19:04 <aristid> shachaf: clearly you would set the time zone on a remote irc client to your local one.
17:19:32 <shachaf> aristid: Clearly I would not care enough about the time zone on a remote IRC client to change it from the default.
17:19:44 <aristid> > 26-(14-8)
17:19:45 <lambdabot>   20
17:19:57 <aristid> shachaf: you must be 3 hours earlier than new york?
17:20:19 <shachaf> s/earlier/better/
17:20:37 <aristid> i suppose that means yes
17:20:42 <aristid> so, west coast of the usa?
17:20:44 <shachaf> I get three more hours every day than they do.
17:20:50 <gwern> greetings to shachaf from the FUUUTTTUUUUUREEE!!!!
17:20:58 <shachaf> gwern: So you're not here? :-(
17:21:02 <gwern> nope
17:21:11 <gwern> airplane tickets are dawg expensive
17:21:21 <aristid> bah, timezones are silly, everybody is in the past
17:21:25 <aristid> gwern: you're in the past
17:21:29 <aristid> shachaf: you are too
17:21:31 <shachaf> gwern: Especially when you don't make up your mind until the day of the tickets.
17:21:37 <gwern> aristid: yes, but that's not a funny thing to say
17:21:45 <gwern> shachaf: no, I was regularly checking ticket prices
17:22:05 <shachaf> aristid: Actually, I read that message after you wrote it. I'm futurier than you.
17:22:27 <aristid> shachaf: no, i'm futurier than you
17:22:31 * shachaf notes dawg as a new unit of currency.
17:22:35 <aristid> actually presentier
17:23:01 <aristid> i wonder which atom of my brain is the present, because every other atom is in the past (by tiny amounts of time)
17:23:11 <ReinH> are there any good resources on queueing theory in haskell? Libraries? Blog posts? Etc?
17:23:15 * shachaf suspects gwern is actually at BayHac but doesn't want to disclose his identity.
17:23:26 <augustss> time is an illusion
17:23:27 <ReinH> wondering how easily I can, for instance, generate a poisson distribution
17:23:44 <Gwern-away> @quote dawg
17:23:44 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
17:24:01 <aristid> augustss: what is real, then? entropy?
17:24:15 <ReinH> augustss: lunchtime, doubly so
17:24:22 <augustss> aristid: could be entropy
17:25:53 <aristid> gwern: lisp jokes are like, unacceptable here
17:26:07 <Gwern-away> pjdelport said it, not I
17:26:34 <ReinH> you dawg, we heard you like cons?
17:26:45 <augustss> ReinH: check hackage, otherwise generating poisson distributions isn't that hard
17:27:11 <djahandarie> Neat golfing technique for recursive programs: m@main = ... m ...
17:27:23 <Veinor> haha
17:28:27 <aristid> djahandarie: and it's valid?
17:28:38 <djahandarie> Can't see why not.
17:28:45 <aristid> hhhhhhmmmm
17:30:28 <blackdog> so, somehow alex and happy have come in as deps in my cabal project
17:30:37 <blackdog> how do i work out what's requiring them?
17:34:25 <ReinH> augustss: I think this is relevant to my interests http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a
17:36:52 <dankna> :t <>
17:36:53 <lambdabot> parse error on input `<>'
17:36:57 <dankna> :t `<>`
17:36:58 <lambdabot> parse error on input ``'
17:37:05 <dankna> @hoogle <>
17:37:06 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
17:37:06 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
17:37:07 <djahandarie> ()
17:37:09 <ReinH> oh hello Statistics.Distribution.Poisson, I didn't see you there
17:37:20 <djahandarie> @typ (<>)
17:37:21 <lambdabot> Doc -> Doc -> Doc
17:37:26 <dankna> oh, thanks
17:37:31 <djahandarie> @typ (><)
17:37:33 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
17:37:36 <dankna> so it is some manner of concatenation operator
17:37:54 <djahandarie> > (text "a ") <> (text "b")
17:37:55 <lambdabot>   a b
17:38:09 <dankna> nifty
17:39:03 <djahandarie> Useless knowledge gained from using lambdabot too much
17:39:16 <dankna> haha
17:39:19 <dankna> well, it's not useless to me
17:39:25 <dankna> I needed to know it didn't do anything weird
17:39:38 <djahandarie> Ah
17:40:02 <dankna> > (text "a") >< (text "b")
17:40:03 <lambdabot>   Not in scope: `><'
17:40:49 <augustss> dankna: use hoogle
17:40:59 <dankna> @hoogle ><
17:41:00 <lambdabot> Data.Sequence (><) :: Seq a -> Seq a -> Seq a
17:41:00 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:41:10 <dankna> > (text "a") Data.Sequence.>< (text "b")
17:41:11 <lambdabot>   Not in scope: `Data.Sequence.><'
17:41:15 <dankna> well, whatever
17:41:17 <dankna> that one was just curiosity
17:41:22 <djahandarie> Docs aren't Seqs. :P
17:41:29 <dankna> oh, haha
17:41:41 <dankna> so they're completely unrelated operators
17:41:47 <djahandarie> Indeed.
17:41:56 <djahandarie> (At the moment)
17:42:01 * dankna would rather it be called something longer, like docConcatenate
17:42:08 <dankna> even though that would mean typing it everywhere
17:42:13 <djahandarie> Or for it to just not care and use the monoid instance
17:42:17 <dankna> yes, or that
17:42:29 <djahandarie> > (text "a ") `mappend` (text "lol")
17:42:30 <lambdabot>   No instance for (Data.Monoid.Monoid Text.PrettyPrint.HughesPJ.Doc)
17:42:30 <lambdabot>    arisi...
17:42:35 <djahandarie>  (`)
17:42:45 <aristid> dankna: to me, concatenate implies that it's of type [x] -> x
17:42:47 <dankna> hahaha I see your kanji-drawing but can't interpret it
17:43:00 <aristid> :t mconcat
17:43:01 <lambdabot> forall a. (Monoid a) => [a] -> a
17:43:06 <dankna> aristid: okay.  that's a fair point.  what is an appropriate name for a -> a -> a then?
17:43:13 <aristid> dankna: append?
17:43:16 <dankna> yeah, okay :)
17:43:20 <luite> if I use hint to let a user evaluate expressions (entered by the user), but I don't execute IO actions. The modules I load are determined by the program (and they don't import unsafePerformIO, although some imported functions use unsafePerformIO under the hood), are there any security issues I should know about for this?
17:43:20 <aristid> :)
17:43:45 <dankna> luite: the mueval page has a list of clever things people have done
17:44:38 <dankna> ah -- here's the list I was thinking of
17:44:40 <dankna> http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
17:44:56 <luite> hmm, the mueval page seems down, code.haskell.org
17:45:10 <dankna> scroll down to 2. Exploits
17:45:29 <luite> thanks
17:45:31 <dankna> most of these are ways to not terminate, or fill memory, but also beware of injection of code that isn't Haskell
17:45:32 <dankna> sure thing
17:45:58 <luite> yeah I've already set resource limits and run the interpreter in a separate process so that it can be killed easily
17:46:04 <djahandarie> Definitely juse use mueval
17:46:06 <dankna> good
17:46:08 <djahandarie> It already has all this done for you
17:46:16 <djahandarie> just*
17:46:18 <djahandarie> @hackage mueval
17:46:19 <lambdabot> http://hackage.haskell.org/package/mueval
17:46:19 <dankna> well, hint is a different approach from mueval
17:46:24 <dankna> it's an interpreter, or something
17:46:25 <dankna> @hackage hint
17:46:25 <lambdabot> http://hackage.haskell.org/package/hint
17:46:30 <luite> djahandarie: nah that has some problems that make it unusable, mainly startup overhead and restrictions on modules that can be loaded
17:47:05 <djahandarie> dankna, erm, mueval uses hint
17:47:12 <djahandarie> It's just that hint can't catch everything
17:47:18 <dankna> oh!  okay
17:47:30 <dankna> I thought they were parallel projects
17:47:56 <dankna> also, the mueval repo is up at http://code.haskell.org/mubot/
17:48:34 <luite> djahandarie: I run this thing as a backend for interactive graphics on the web, so the ~300ms startup time of mueval (including loading the right modules) is really noticeable
17:49:10 <dankna> can't you use fastcgi instead of cgi to cache the mueval instance?
17:49:22 <djahandarie> luite, just curious, do you know why it takes so long to start anyways?
17:49:25 <dankna> or do you need a fresh one every load?
17:49:33 <luite> dankna: I already switched from fastcgi to snap :)
17:49:34 <djahandarie> Because lambdabot spawns a new one every command so it would benifit also
17:50:37 <dankna> oh, haha, okay
17:50:38 <luite> dankna: it keeps a set of worker interpreters, each with a specific set of modules loaded. if one with the correct modules is available, it uses that one (~5ms for a simple expression), otherwise it loads the correct modules in the least recently used interpreter
17:50:51 <luite> which takes a few hundred ms
17:51:09 <dankna> it was djahandarie who asked that, not me, but.
17:51:14 <aristid> luite: do you regularly kill some workers, too?
17:51:16 <luite> oh sorry :)
17:51:32 <luite> aristid: only if they don't respond anymore, then they get restarted automatically
17:51:45 <luite> I might set a limit on the number of requests though
17:51:49 <djahandarie> tryhaskell would also benefit from a faster mueval
17:51:58 <luite> djahandarie: tryhaskell already uses a patched version
17:52:09 <djahandarie> Ah, it does?
17:52:22 <luite> yeah it keeps the process running
17:52:36 <luite> but with mueval, and a fixed set of modules loaded
17:52:52 <luite> I want to be able to add things, for example code that I want to show, or weblog posts as .lhs files
17:53:02 <luite> mueval isn't really suitable for that
17:53:15 <aristid> luite: can you add an irc bot frontend? :)
17:53:30 <luite> djahandarie: snap works better than fastcgi though, because it's multithreaded. with fastcgi, all requests are handled in a single thread, so slow queries may block others
17:53:45 <dankna> direct-fastcgi allows you to pass your choice of forkIO or forkOS, actually
17:54:01 <dankna> I thought fastcgi did too
17:55:19 <luite> hmm, I thought that fastcgi used a single socket to the web server, and that each request had to be handled in order... but I might be wrong 
17:56:44 <dankna> it does use a single socket, but with a packetized format
17:57:06 <dankna> so independent streams are multiplexed
17:58:47 <luite> ah ok, then this would've been possible with fastcgi too, with the right client library :)
17:59:10 <luite> or server, what's this side of the connection called :p
18:00:20 <luite> aristid: not sure if it's suitable for irc, since the requests include the modules that need to be loaded, the interpreter process itself just loads them, doesn't check anything, so the client needs to be trusted in some way
18:00:50 <aristid> luite: for irc, you would have a pre-defined list of modules
18:03:10 <luite> dankna: ah the fastcgi package also supports forkOS request handlers
18:04:23 <dankna> yeah, I thought I remembered that
18:05:24 <luite> still snap also works nicely, although I had some issues with the ghc 7.0.1 io manager. fixed in ghc 7.0 head though :)
18:06:06 * dankna nods
18:08:29 <luite> but I still don't know a way to get a hint typechecker error without exiting the interpreter monad :(
18:12:24 <luite> this is the code by the way, http://hpaste.org/43900/hint_code
18:13:38 <dankna> I see
18:15:07 <luite> the InterpreterError is handled outside the runInterpreter call, so it needs to restart the interpreter after each error
18:16:02 <luite> which is done immediately, so as long as the next request doesn't come directly after the one with the error, the user shouldn't notice, but it causes more load than necessary
18:42:41 <erg0t> does any function like "elem" exists that I can pass a function (a -> Bool) instead of a value? 
18:43:42 <aavogt> @ty find
18:43:43 <Draconx|Laptop> erg0t, find
18:43:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:44:21 <luite> args0: any
18:44:23 <luite> or all
18:44:26 <erg0t> yeah I'm using find but I want something that just returns a Bool
18:44:40 <luite> > any even [1,3,5]
18:44:41 <lambdabot>   False
18:44:44 <luite> > any even [1,3,5,8]
18:44:45 <lambdabot>   True
18:44:52 <erg0t> luite: thanks :)
18:46:13 <accel> is it possible to use Haskell as a _scripting_ language for generating TeX documents? (I'm not asking about literate haskell; I'm about writing a haskell DSl that generates TeX -- especially useful in the context of math formulas)
18:50:27 <aavogt> @hackage pandoc does this accel
18:50:27 <lambdabot> http://hackage.haskell.org/package/pandoc does this accel
18:51:02 <aavogt> but nobody is going to write the haskell data which represents a subset of TeX
18:53:40 <accel> http://johnmacfarlane.net/pandoc/ ?
18:53:52 <accel> hmm
19:08:59 <NihilistDandy> So what's the feeling on emacs vs yi for Haskelling?
19:11:14 <shachaf> NihilistDandy: vim
19:11:16 <byorgey> yi is fun because it's easy to customize: it has a really nice DSL for customizing it, and no need to learn another language just to configure your editor
19:11:31 <byorgey> but practically speaking I think emacs is still more convenient
19:11:34 * jmcarthur likes emacs and hasn't given yi a very fair shot
19:11:38 * NihilistDandy nods
19:12:03 <byorgey> it's faster, and there's lots of Haskell-mode emacs goodness
19:12:38 <NihilistDandy> I've been Lisping/Scheming/Haskelling/Erl..ang...ing? for a while, so my .emacs is pretty dense, but I just cabal'd yi to play with it
19:13:17 <NihilistDandy> Didn't know if there was much love for it or not
19:14:49 <echosystm> hi guys, i'm trying to work out what language to learn as my first functional language
19:15:10 <adu> echosystm: scheme!, then haskell!
19:15:13 <shachaf> echosystm: Scheme or Haskell or lambda calculus.
19:15:15 <echosystm> can someone explain in lay terms, or point me to a simple explanation, of monads?
19:15:35 <adu> echosystm: there are millions of monad tutorials
19:15:42 <shachaf> @quote endofunctor
19:15:43 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
19:15:43 <echosystm> yes, but they all assume you know haskell
19:15:44 <NihilistDandy> I'd say say Scheme, Haskell, or LC first, depending on what you like
19:15:47 <byorgey> echosystm: no, go learn a functional language first =)
19:15:53 <adu> echosystm: no, they don't
19:16:14 <shachaf> @quote endofunctor
19:16:14 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
19:16:17 <shachaf> Bah.
19:16:19 <adu> echosystm: the best monad tutorials talk about fish, or rockets, or missiles
19:16:30 * adu likes the missiles
19:16:31 <erg0t> echosystm: learn Functors, then Applicative Functors, and then Monads
19:16:33 <shachaf> echosystm: Don't learn about "monads".
19:16:53 <NihilistDandy> echosystm: http://learnyouahaskell.com/a-fistful-of-monads
19:17:00 <adu> echosystm: the simplest definition of a monad is that it is an interface
19:17:13 <NihilistDandy> There is a really cool pig on that page
19:17:13 <adu> echosystm: beyond that, you get fish and missiles
19:17:17 <NihilistDandy> That should explain everything
19:17:24 <echosystm> thanks NihilistDandy 
19:17:24 <sproingie> launchFish
19:17:37 <NihilistDandy> That pig is as cool as they come
19:17:39 <adu> sproingie: lolol
19:17:44 <gwern> @quote fish
19:17:44 <lambdabot> <monochrom> says: the selfish program's motive is to fool the programmer
19:19:08 <adu> gwern: wut
19:19:22 <gwern> adu: I have no idea
19:19:56 <adu> echosystm: anyways, when you do learn scheme, try and use "map" as much as possible
19:20:10 <NihilistDandy> Scheme's lovely :)
19:20:55 <NihilistDandy> Scheme and Haskell are my favorites, really, but I'm a math major, so...
19:20:58 <adu> NihilistDandy: it is, and I'm glad that the creator of JavaScript thought so too
19:21:20 <adu> NihilistDandy: did you know that the first version of JS _was_ scheme?
19:21:40 <NihilistDandy> I did not
19:21:55 <NihilistDandy> Is there a link to something to that effect? I'd be interested in reading
19:21:57 <adu> NihilistDandy: yes, then Netscape said "uh, no, add some curly braces" so he did
19:22:03 <NihilistDandy> haha
19:23:00 <NihilistDandy> I don't understand why brackets and parens aren't switched on keyboards. Are people really using brackets? Ever?
19:23:23 <NihilistDandy> Braces on shift I can understand, but brackets?
19:23:55 <byorgey> They are good for editorial comments [like this -ed.]
19:24:20 <adu> NihilistDandy: the closest I can find is http://inventors.about.com/od/jstartinventions/a/JavaScript.htm
19:25:00 <adu> or http://brendaneich.com/2010/07/a-brief-history-of-javascript/
19:25:29 <NihilistDandy> Fair point, byorgey, but I'd say that on balance, parentheses are getting used much more often
19:26:22 <adu> byorgey!
19:28:25 <NemesisD> anyone ever done any work with text.json?
19:28:29 <teki> yes
19:28:55 <teki> NemesisD: yes
19:29:30 <NemesisD> teki: im going to be picking your brain ;) i love how easy it is to do automatic parsing with typeable, but i have one case i nee to handle manually and cannot figure out the typing to save my life
19:29:50 <teki> alright, shoot
19:36:07 <NemesisD> sorry, working out a minimal case
19:37:02 * monochrom has a cunning plan. /ban *!*@*.hackerdojo.com :)
19:37:21 <NemesisD> teki: http://hpaste.org/43902/textjson_parsing
19:37:53 <monochrom> but more seriously... where is haskell platform 2011 ?!?!!!!11!!!
19:38:19 <NemesisD> so there it is complaining that fmap has an inferring a type JSObject JSVALUE, expecting JSObject (JSObject e)
19:38:23 <byorgey> hi adu!
19:38:34 <adu> byorgey: what have you been up to?
19:38:54 <byorgey> adu: you know, PhD-ish things...
19:38:57 <byorgey> lots of writing recently
19:39:04 <adu> wow cool
19:39:13 <adu> I've just been working on a parser: hackage.haskell.org/package/language-go
19:39:28 <teki> NemesisD: okay, give me a minute
19:39:28 <byorgey> nice
19:40:07 <adu> byorgey: it's the biggest parser I've ever written
19:40:24 <byorgey> adu: why base == 3 ?
19:40:56 <adu> because I don't have 4.x installed
19:41:30 <byorgey> what version of ghc do you have?
19:41:40 <teki> NemesisD: OHHHHHHHHHHHHHHHHHHHHHHHHHHHH
19:41:43 <adu> 6.10.4
19:42:01 <byorgey> fair enough.
19:42:02 <teki> NemesisD: I remember figuring out this exact same f***ing problem, although in my case I was just writing JSON.
19:42:17 <byorgey> adu: doing anything July 29-31?
19:42:41 <NemesisD> teki: because of JSON.Generic, i should be able to get that for free, if the JS object matches the haskell record, it "just works" but i need sometimes in my real app to parse the outer structures as alists instead of records, with the innards being records
19:42:46 <NemesisD> teki: thats good news!
19:42:49 <adu> byorgey: well, I'm in Japan right now, will be back in DC area in may tho
19:43:08 <teki> NemesisD: essentially the problem is that you need your JSValue to be "double-wrapped" in JSObject
19:43:08 <adu> o wait July is after May
19:43:12 <byorgey> japan! cool
19:43:15 <NemesisD> teki: i was having such a good time having JSON.Generic do all the hard work, then hours upon hours of of type hell :P
19:43:19 <byorgey> yes, it is =)
19:43:29 <teki> NemesisD: lemme find the code that I figured out how to fix this with
19:43:31 <adu> byorgey: what's happening then?
19:43:47 <byorgey> adu: Hac phi 3!
19:44:02 <adu> byorgey: cool! is that in PA?
19:44:18 <byorgey> yup
19:44:46 <adu> byorgey: I'll try to make it, I went to the 2009 one iirc
19:44:50 <teki> NemesisD: okay lemme try and explain what's going on
19:45:21 <teki> so for some god-forsaken reason that I cannot comprehend (which probably means I haven't thought about it enough)
19:45:46 <teki> a variable of type JSObject JSValue is NOT a JSValue
19:46:24 <teki> but a variable of type JSObject (JSObject JSValue) IS a JSValue
19:46:38 <teki> so
19:46:40 <teki> in your code
19:46:45 <teki> where you implement readJSON
19:47:16 <teki> wait, hold up
19:47:21 <teki> nvm, that's not the error
19:47:47 <teki> i suspect it is somehow related though...
19:47:57 <NemesisD> yeah theres weird wrapping stuff going on
19:49:10 <NemesisD> i think the fmap part needs to specify that it wants to read a JSObject ( JSObject Foo ) not a JSObject JSValue (that whole datatype is extraordinarily confusing to me)
19:51:03 <teki> but that's the thing
19:51:26 <teki> obj should be of type JSObject JSValue
19:52:10 <NemesisD> i can't figure out how to work with JSValue
19:52:50 <NemesisD> fromJSObject :: JSObject e -> [(String, e)]
19:53:26 <teki> yeah i am looking at the code i wrote
20:24:17 <teki> NemesisD: fuck, this reminds me why i hated this library
20:24:29 <NihilistDandy> lol
20:26:07 <mjrosenb> teki: what library?
20:26:21 <teki> mjrosenb: Text.JSON
20:26:39 <teki> mjrosenb: NemesisD asked me to take a look at some type problems
20:26:45 <teki> mjrosenb: about an hour ago
20:27:02 <NemesisD> it makes my head hurt
20:27:50 <NemesisD> and not the good kind
20:28:05 <teki> NemesisD: let's change the definition of readJSON to Error (fst $ head $ fromJSObject obj)
20:28:29 <teki> and then if we whip up a double-wrapped JSObject JSValue
20:28:53 <teki> like so: let jso = showJSON $ toJSObject [("level1",toJSObject [("level2",showJSON 42)])]
20:29:12 <teki> and we do readJSON jso :: Result FooSet
20:29:20 <teki> we see that we get Error "level1"
20:31:06 <NemesisD> hmm yes im seeing that in my test file
20:31:26 <teki> and we would like to get Error level2 right?
20:31:30 <teki> somehow?
20:32:15 <teki> because then we could just do snd instead of fst and pull out our bloody FooSet
20:32:23 <NemesisD> yeah, because of typeable, i would be able to decode the Foo easily, i believe. with decodeJSON
20:32:37 <teki> yeah, sometihng like that
20:32:52 <teki> god, this makes me so glad i only had to write JSON
20:33:11 <teki> anyways
20:33:53 <NemesisD> in the program i'm using this in, almost all of the data types can be straight decoded into a record, its just that top level object that has to have an alist
20:34:13 <teki> alright so i think this is the real problem
20:34:17 <teki> if we try doing
20:34:31 <teki> (JSObject (JSObject jsv)) on the LHS
20:34:35 <teki> then we get type errors
20:35:02 <teki> so for whatever reason readJSON is not recognizing that JSObject (JSObject obj)) should be a JSValue
20:35:20 <teki> wait, lemme think
20:36:05 <teki> okay
20:36:10 <teki> in your original code
20:36:15 <teki> try wrapping obj in
20:36:24 <teki> readJSON :: JSOBject JSValue
20:37:23 <NemesisD> hmm, it complains of a misplaced type signature when i do it in the instance, do i need to define another function elsewhere to get the type in?
20:37:44 <teki> nah
20:37:49 <teki> i just tried it, didn't work
20:38:03 <teki> but i think we're missing either a readJSON or a showJSON somewhere
20:38:21 <teki> i am getting a good feeling
20:38:24 <teki> about this
20:38:42 <NemesisD> id hope it would be a read
20:39:07 <teki> yeah, but you need a lot of showJSONs too
20:39:17 <NemesisD> thats for serialization though isn't it?
20:39:26 <teki> nope
20:39:27 <NemesisD> oh nm didn't see the type
20:41:26 <teki> okay
20:41:38 <teki> can we read JSValues to a Foo?
20:41:43 <teki> i don't think so
20:42:16 <teki> i have a type error now that contains no JSObjects
20:42:16 <teki> so
20:42:21 <teki> it's in the last line
20:42:27 <teki> i hate that this feels like such a great success
20:43:12 <NemesisD> lol!
20:43:24 <teki> you're going to hate what i did
20:43:32 <NemesisD> i think the showJSON might be as simple as showJSON f = makeObj $ foos f
20:43:38 <teki> fs <- fmap fromJSObject (readJSON $ showJSON obj :: Result (JSObject JSValue))
20:43:41 <tg_> <prof. farnsworth> Good news, everyone! I've taught the toaster to feel love!
20:44:00 <teki> and somehow i don't get a type error
20:44:12 <teki> i didn't believe it
20:44:17 <teki> but that statement is valid
20:46:22 <NemesisD> teki: i get expected [(String Foo)] against inferred [(String JSValue])
20:47:55 <teki> yep
20:48:27 <teki> so now you just have to implement readJSON for Foo
20:48:32 <NemesisD> oh god no
20:48:44 <NemesisD> what about the generic magic?
20:48:49 <teki> umm
20:48:52 <teki> i dunno mate
20:49:48 <NemesisD> ill die inside if implementing instance JSON for one means i have to do it for all of them
20:50:04 <teki> i already died inside from using this library
20:50:13 <teki> alright
20:50:27 <teki> so let's figure out logically if you have to implement JSON for Foo
20:50:39 <NemesisD> actually, if i can rip out the snd from that pair, i think i can use fromJSON
20:51:04 <NemesisD> fromJSON :: Data a => JSValue -> Result a
20:51:20 <teki> oh, then that would work
20:51:34 <teki> i didn't know about fromJSON
20:53:08 <teki> so from there it should be a sequence and a liftM2 and some work and you can go from [(String,JSValue)] to [(String,Foo)]
20:54:36 <NemesisD> god damn that Result monad
20:55:05 <teki> here, i'll do it for you
20:55:08 <teki> you deserve it
20:55:09 <teki> so
20:55:42 <NemesisD> lol im so close, it would totes work if there was no Result monad :P
20:55:50 <teki> here wait 3 minutes
20:55:53 <teki> i'll get it
20:57:47 <heis> My version of the standard library is missing mfilter.  How can I update the base stuff?  It isn't apparent if you can do it with cabal.
20:58:06 <NihilistDandy> heis: cabal upgrade base should do it
20:58:38 <NihilistDandy> I think. I dunno, I'm chasing deps, at the moment and barely paying attention
20:58:44 <heis> cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda
20:58:53 <NihilistDandy> Yeah, I got the same
20:59:10 <NihilistDandy> Just cabal install mfilter
20:59:29 <heis> mfilter's in Control.Monad
20:59:36 <heis> Only the newest version
20:59:45 <NihilistDandy> Ah
20:59:58 <heis> Gotta stop programming, people here.  Fffffuuuuck
21:00:20 <heis> Haskell beats interaction
21:01:16 <NemesisD> interact?
21:05:49 <teki> okay, what am i doing wrong
21:06:03 <teki> liftM2 (,) has type Monad m => m a -> m b -> m (a,b)
21:06:23 <teki> oh, never mind
21:09:14 <NemesisD> hmm, isn't the string part of the tuple not in a monad?
21:09:29 <NemesisD> or is there some sort of >>= witchcraft going on
21:09:53 <teki> yeah
21:09:59 <teki> but you can just return it into a monad
21:10:14 <teki> and then uncurry (liftM2 (,)) has type (m a, m b) -> m (a,b)
21:10:32 <teki> which is what you would like for m = Result
21:10:46 <teki> i am trying to figure out some of these type errors myself
21:11:07 <NemesisD> wasn't even aware of uncurry
21:14:30 <teki> NemesisD: GOT IT 
21:14:32 <teki>                              fmap wrapfooset $ sequence $ map (uncurry (liftM2 (,))) $  map (\(a,b) -> (return a, fromJSON b :: Result Foo)) fs
21:14:32 <teki>                              	where wrapfooset fs = FooSet {foos = fs}
21:14:38 <teki> FUCK YEAHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
21:14:44 <teki> holy shit that is ugly
21:15:22 <NemesisD> holy god
21:15:52 <NemesisD> im never parsing json with haskell again after this :P
21:16:17 <teki> oh btw liftm2 is in control.monad in case you didn't know
21:16:27 <teki> everything else is prelude
21:16:43 <teki> alright that was way too hard
21:17:17 <dolio> Did I miss a drinking game in here?
21:17:39 <teki> dolio: if you call using Text.JSON a drinking game, then yes
21:17:41 <NemesisD> teki: do you have a full paste i could compare against?
21:17:46 <spacefelix> O hai.
21:17:46 <teki> yeah sure
21:17:52 <teki> lemme put it up on hpaste
21:19:09 <teki> http://hpaste.org/43903/textjson_parsing_ii
21:19:20 <NemesisD> i wonder if its just the problem domain that's hard or if Text.JSON is poorly designed, i don't know nearly enough about haskell to tell, since everything is hard to me
21:19:42 <teki> i think it's probably a combination of the JSON standard and Text.JSON's implementation
21:20:49 <teki> specifically w/r/to JSObject
21:20:53 <teki> that's not done well at all
21:21:17 <NemesisD> ok good then it's maybe not just me
21:21:47 <NemesisD> teki: thank you so much for helping me with this, i've spent an embarrassing amount of time trying to figure this out and would definitely not have arrived at the conclusion you did
21:22:29 <teki> NemesisD: hey, it's alright
21:22:41 <teki> i ask enough stupid questions here that i figure i probably owe somebody
21:22:47 <teki> you just happened to be that lucky somebody
21:23:02 <teki> also, i can't believe that the readJSON $ showJSON worked
21:23:21 <teki> i have to say that of all the Haskell i've written, that's the only part that felt kludge-y
21:24:15 <teki> anyways, hope that this code is put to good use :) enjoy
21:24:50 <NemesisD> teki: one toy haskell app comin right up ;)
22:32:21 * copumpkin yawns
22:33:18 <ddarius> copumpkin: Alive I see.
22:34:03 <copumpkin> ddarius: I gave in and took a taxi. I got onto the bus and got accosted by two drunk men on some sort of drug, and then offered drugs and they made some awkward conversation with me. The bus sat there for another 20 minutes and I decided I was just going to go find a cab so I did :P
22:37:21 <ddarius> Welcome to Somerville.
22:39:50 <sproingie> week back there was a lady on bart that i saw, who announced how she didn't want to do this, but she needed money, just $46, and she was desperate and she had her two kids with her, etc, and was asking everyone for what they could spare
22:39:55 <sproingie> this was the fourth time i saw her
22:40:02 <ddarius> copumpkin: See, since walking is un-American, that's how you avoid Americans.
22:40:03 <sproingie> asking for exactly the same amount
22:40:12 <copumpkin> lol
22:40:18 <sproingie> i fucking lost it, got up, and screamed at her about her bullshit scam
22:40:39 <copumpkin> ddarius: he asked me if I had any friends who wanted weed, but I said no
22:40:41 <copumpkin> also, crack
22:40:46 <sproingie> should have just gotten off.  whatever.
22:40:47 <copumpkin> hope you don't mind
22:41:44 <ddarius> copumpkin: Less drunkenness and more prostitution and during daylight and you have my experience of New Orleans.
22:41:52 <copumpkin> lol
22:41:55 <copumpkin> sounds like fun
22:42:23 <copumpkin> I was sitting in the back of the bus, and they sat next to me and one put his leg up across where I'd be getting out from
22:42:32 <copumpkin> so it was kinda menacing, but they just seemed kinda out of it
22:42:44 <sproingie> organized scam sounds like
22:42:56 <copumpkin> nah, they were just high and drunk
22:44:43 <edwardk> copumpkin: sounds like an interesting night
22:44:49 <copumpkin> indeed!
22:45:05 <copumpkin> how's your ear?
22:45:21 <edwardk> still messed up
22:46:17 <thoughtpolice> copumpkin: you should have started acting like a jesus freak
22:46:24 <copumpkin> lol
22:46:30 <thoughtpolice> that way you turn the tables and they want to get the fuck away from you
22:46:37 <edwardk> i have an appointment being made for when i get back from new york, and a couple more prescriptions
22:48:29 <sproingie> that's always how i got rid of jehovah's witnesses
22:48:35 <sproingie> out-weirded them
22:49:05 <copumpkin> :)
22:49:16 <copumpkin> edwardk: I'm sure you'll be able to find someone in NYC if necessary
22:49:30 <sproingie> i never see JW's knocking on doors anymore
22:49:35 <thoughtpolice> sproingie: good tactic.
22:49:52 * ddarius just shoots them.
22:49:56 <thoughtpolice> sproingie: i was planning on trolling my friends and having mormons come by their house, you can get someone to come to your door and talk to you
22:50:12 <sproingie> i greeted a pair at the door wearing just my boxers and a pentagram, and asked them if they wanted to come in and get stoned
22:50:30 <sproingie> i'd have been really embarassed if they took me up on that since i didn't have anything for them to get stoned on
22:50:42 <ddarius> sproingie: You didn't have soda or coffee?
22:51:47 <sproingie> didnt think of it that way
22:52:14 <sproingie> (jesus just pinged out)
22:52:31 <tensorpudding> he'll reconnect in three days
22:52:44 <sproingie> \o/
23:11:58 <adnap> what are semantic equality and syntactic equality?
23:12:25 <dolio> Where are you seeing those words?
23:12:31 <adnap> conal's blog
23:13:10 <copumpkin> "profoundly equal" and "superficially equal"? :P
23:13:22 <adnap> i guess so
23:13:26 <dolio> Then semantic equality of two terms x and y probably means [x] = [y], where [_] is the semantic function.
23:13:27 <adnap> like (+ 2 3) and 2 + 3
23:13:41 <dolio> As in denotational semantics.
23:14:34 <dolio> While syntactic compares the terms without that level of reduction.
23:14:56 <adnap> the semantic function is the one that takes the type to the model of the type, right?
23:15:21 <dolio> Yes.
23:15:23 <adnap> [Map k v] = (k -> v)
23:16:23 <adnap> and the model is a type itself?
23:17:06 <dolio> Generally the model would probably be a set.
23:17:15 <adnap> of what?
23:17:18 <dolio> If you're not thinking too carefully.
23:17:22 <Kaidelong> well k -> Maybe v in haskell
23:17:40 <adnap> are we talking about map specifically here?
23:17:58 <dolio> The model of Haskell's Integer type might be the mathematical set of integers.
23:18:06 <adnap> oh, whoops
23:18:14 <adnap> i mistook Kaidelong post for dolio's
23:18:24 <dolio> And Haskell terms of type Integer would be taken to particular integers.
23:18:47 * Kaidelong read that same paper, incidentally
23:18:57 <dolio> If you want to be precise, there's not place to put bottom, so you need to be fancier.
23:19:01 <adnap> the model is like an illusionary type
23:19:05 <adnap> the ideal
23:19:34 <dolio> Or rather, the mathematical set of integers has no bottom, so there's no denotation of non-terminating expressions.
23:19:56 <dolio> So instead you use a domain, with a bottom element, and each integer above it.
23:20:43 <dolio> And functions aren't set-theoretic functions, but domain-theoretic monotone functions or something along those lines.
23:21:23 <adnap> what's your favorite book on denotational semantics?
23:21:28 <adnap> a beginner book
23:21:41 <dolio> I don't think I have one.
23:21:58 <adnap> have you read any?
23:22:09 <dolio> I actually don't find the technicalities of denotational semantics that interesting.
23:22:36 <adnap> what do you mean by the technicalities?
23:23:43 <edwardk> (basically you work with monotone functions in an omega-CPO to model the behavior of bottom)
23:24:54 <adnap> okay, i don't know what an omega-CPO model is, but denotational semantics is realted to information ordering?
23:25:52 <dolio> I mean, there are all sorts of models for Haskell-like languages. Complete partial orders, coherence spaces, linear coherence spaces, partial equivalence relations....
23:26:02 <edwardk> once you introduce bottom into the mix you can't just reason using functions on sets.
23:26:17 <dolio> And people who are interested in denotational semantics are probably in the business of inventing new ones.
23:26:21 <edwardk> hahaha
23:26:31 <adnap> so the answer is "yes"?
23:26:49 <edwardk> the answer is 'in this case, yes'
23:26:59 <edwardk> if you had a total language you might get away from that
23:27:12 <dolio> But I'd rather hear about the least amount categorical structure that is required to interpret the stuff in Haskell.
23:27:59 <dolio> Or, if it's a novel feature in a supposedly total language, I'd rather hear about normalization than models.
23:28:10 <edwardk> dolio: stuff like dana scott's interpretation of the lambda calculus in a CCC or the semi-CCC version of the same?
23:28:18 <adnap> so denotational semantics is realted to the model of the language you use?
23:29:25 <dolio> edwardk: Yes. Or, 'extensional type theory is the internal language of toposes.' Something like that.
23:30:01 <adnap> i asked if "denotational semantics is realted to information ordering", and you said "there are all sorts of models for Haskell-like languages"
23:30:07 <edwardk> personally i'm more fond of finding an operational model that has desirable performance characteristics, and then trying to figure out what the semantics of that model are, than I am of starting with a purely theoretical model that denotes the semantics of what my system should be and trying to find some way to make that efficient
23:30:23 <ddarius> dolio: You may like my article on fibrations when I finish it.
23:30:53 <adnap> so denotational semantics builds on a model of the language?
23:30:59 * ddarius is fond of finding an operational model that has merely feasible performance characteristics.
23:31:59 <adnap> if so, does that mean that the application of denotational semantics is often specific to the underlying model that semantics are built upon?
23:33:19 <edwardk> adnap: you can build multiple semantics, big step semantics, small step semantics, describe things in terms of omega-CPOs, or very different things, this is one reason why i tend not t start from a denotational perspective
23:33:19 <edwardk> my bias puts me at loggerheads some times with conal. ;)
23:33:55 <edwardk> adnap: that is my experience
23:34:46 <edwardk> ddarius: in practice i find that i wind up having to start somewhere in the middle as well, i want to be able to reason about the resulting monstrosity after all ;)
23:34:55 <dolio> The idea practically would probably be that you can reason about program transformations by checking that the denotation is the same before and after.
23:35:17 <dolio> However, algebraic rules are probably more useful for that than precise denotational semantics.
23:36:02 <adnap> that sounds like the semantic function
23:37:43 <adnap> man, i'm tiredddddddddddd
23:38:06 <adnap> gnight
23:39:19 <dolio> ddarius: Yeah, probably. If I don't finish the Phoa book first. :) (Not that I've been exactly blazing through.)
23:45:04 <Jonno_FTW> how can I load an extra module in ghci without unloading everything else?
23:45:19 <c_wraith> :m + module
23:45:27 <Jonno_FTW> ah
23:45:27 <thoughtpolice> Jonno_FTW: you can just say 'import Module.Name'
23:45:39 <thoughtpolice> or yeah, :m + Module.Name
23:45:41 <c_wraith> You can also use :m - module to remove one loaded module
23:46:00 <Jonno_FTW> and how do I set the prompt so it doesn't have all the module names?
23:46:55 <Jonno_FTW> nvm
23:47:36 <Jonno_FTW> how can I do a qualified import in ghci?
23:49:10 <ddarius> dolio: Don't worry.  I haven't been blazing through my article either.
23:50:20 <thoughtpolice> Jonno_FTW: that's a recent feature
23:50:27 <thoughtpolice> it was in GHC 7
23:50:48 <Jonno_FTW> so I have to upgrade to ghc 7?
23:50:52 <thoughtpolice> Jonno_FTW: if you have 7.0.1, you can say 'import Module.Name as M' or whatever - i actually believe the full import syntax is supported
23:51:11 <thoughtpolice> Jonno_FTW: yes, otherwise if you import two modules that e.g. have the same functions, you have to use the fully qualified name
23:51:26 <thoughtpolice> i.e. Data.ByteString.map and Data.List.map or whatever
23:51:36 <thoughtpolice> yes, it sucks, but it's been fixed finally at least :(
23:52:24 <Jonno_FTW> but I am using Data.ByteString.Lazy.Char8
23:52:25 <Jonno_FTW> for real
23:53:34 <thoughtpolice> yeah, Data.ByteString is probably the worst offender on that note since SO many people use it, but almost all of its exported functions have the exact same name as ones defined by other modules
23:53:45 <thoughtpolice> a real PITA
23:54:33 <Kaidelong> typeclassssssssses
23:54:37 <Kaidelong> please!
23:55:18 <Jonno_FTW> Kaidelong: wut?
23:55:20 <thoughtpolice> what, for things like Data.ByteString or Text and the other 1,000,000 different string types?
23:56:03 <thoughtpolice> (obvious hyperbole, but i think the real number is around 7 or so, since you have to classify lazy text/bytestrings differently from strict ones)
23:57:18 <Kaidelong> thoughtpolice: basically
23:57:18 <Kaidelong> all these name conflicts just says that people aren't using overloading enough with typeclasses
23:57:31 <Kaidelong> particularly with obvious offenders like "map"
23:57:34 <Jonno_FTW> ...
23:58:22 <thoughtpolice> i think someone mentioned something like that at the hackathon today, johan maybe? i don't know if there's any consensus/plans/design on that sort of thing
23:58:28 <Kaidelong> and then also some others that probably should be methods like "toList", "fromList", "length" etc
23:58:38 <thoughtpolice> in any case
23:58:43 <c_wraith> Kaidelong: sometimes kinds get in the way.  map on a ByteString can't be fmap, because ByteString has kind *, not * -> *
23:58:43 * thoughtpolice --sleep
23:59:45 <Kaidelong> c_wraith: but then couldn't you make ByteString t a functor?
