00:00:09 <thoughtpolice> glguy: hah, good stuff. i mean, i only run my own server too and everything
00:01:04 <glguy> If you're a minecrafter, have you looked at any of the Haskell code for the protocol?
00:05:12 <makpo1> Has anyone here worked much with repa?
00:08:04 <accel> glguy: there's a haskell implementation for minecraft?
00:08:12 <accel> glguy: there's a haskell implementation *of* minecraft?
00:09:44 <glguy> Just of the binary protocol for multiplayer as used for a proxy server
00:09:56 <accel> http://opencraft.sourceforge.net/ <-- apears to be only the server, not the client
00:21:05 <xpika> i am having trouble on how to use Database.HaskellDB.Database.dbQuery
00:21:54 <xpika> i can't find an example 
00:42:19 <drbean> @where realworldhaskell
00:42:19 <lambdabot> http://www.realworldhaskell.org/
00:49:45 <dankna> anybody awake and have a moment to help me figure out how I'm misusing SYB?
00:49:46 <dankna> http://hpaste.org/43680/not_using_listifymkq_correctl
00:49:59 <dankna> I've read the papers but it was a while ago
00:50:09 <dankna> and the Haddock is, er, unhelpful at best
00:50:51 <gienah> xpika: http://hpaste.org/41546/fixing_the_type_error
00:51:57 <gienah> xpika: http://haskelldb.sourceforge.net/haskelldb.pdf
00:52:24 <dankna> it looks as though it's saying the type of the structure to be traversed into isn't fixed
00:52:32 <dankna> but how can that be, when I'm providing a literal instance of that structure?
00:53:49 <xpika> gienah: thankyou i'll try and use that
00:55:37 <geheimdienst> dankna: i annotated your paste, but i don't know why that works :-/
00:56:33 <dankna> oh!  well thank you, haha
00:56:45 <dankna> that doesn't even seem correct
00:56:46 <edwardk> hrmm, i'm looking to try to make a Traversable instance walk down two structures at the same time by weaving the traversal actions together from each. can anyone think of a combinator or library that provides this?
00:57:04 <dankna> it's NOT a Thing -> Bool, it's a generic-to-Bool
00:57:14 <dankna> but I can't knock it if it works, haha
00:57:43 <dankna> oh, the second parameter to mkQ is a Thing -> Bool, okay
00:58:01 <edwardk> e.g. i'm traversing data EitherTrie f g a = EitherTrie (f a) (g a) — where both f and g are potentially infinitely large so i want to yield results from each if you view the resulting monad and its lazy or commutative
00:58:33 <dankna> I wonder if it's a compiler limitation/bug?  doesn't infer types of functions from signatures on pattern variables in their parameters?
00:59:25 <edwardk> i can implement the Foldable case by weaving together the resulting contents, so i should be able to do the same thing for Traversable
01:00:14 <dankna> edwardk: interesting problem, with which I cannot help :)
01:03:40 <geheimdienst> dankna, i don't understand it either. i couldn't even remove the ":: Thing" from "it", because again ghc would complain. it all seems very redundant
01:04:28 <dankna> geheimdienst: I understand about the :: Thing, I can explain that bit to you if you wish
01:04:38 <makpo1> Has anyone who is on now done much with Repa?
01:04:45 <dankna> basically ((mkQ False ((\it -> True) :: Thing -> Bool)) :: (Thing -> Bool)) also works
01:05:25 <dankna> remembering that what mkQ does is construct a "generic" function, a function which can be called on any type at all (as long as it implements Data)
01:05:35 <geheimdienst> well yeah. ghc can infer that True is a Bool. i would be disappointed if it couldn't
01:05:45 <dankna> haha
01:06:08 <dankna> it needs to know the type that I want the inside function to be specialized on
01:06:21 <dankna> so I need to either put the pattern signature like I originally had it, or put a signature someplace else like here
01:07:03 <dankna> in a more "normal" function I might get away with it because the type of "it" would be clear from how it was used, but since I don't in fact use it...
01:07:14 <dankna> so that much is normal and expected
01:07:23 <dankna> what troubles me now is not that I need to put the second signature on it
01:07:35 <dankna> because I can almost see a need for a second signature - there are two types after all
01:07:43 <dankna> but rather that the second signature seems flat-out wrong
01:08:22 <dankna> hmmm
01:08:24 <dankna> here's a clue
01:08:52 <dankna> if I change the outside signature to [Thing] -> Bool, which is still wrong,
01:08:57 <dankna> then it compiles but outputs an empty list
01:09:26 <dankna> I'd like to understand syb before I move to uniplate, because syb has, you know, papers written about it :)
01:09:43 <dankna> even though people do tell me uniplate is better, it seems like for didactic purposes I should go in the order they were invented in
01:09:54 <ClaudiusMaximus> dankna: :set -XNoMonomorphismRestriction ?
01:10:10 <dankna> I'll try it
01:10:51 <ClaudiusMaximus> removes the need for the outside signature here (i get a "no Show instance" in ghci instead of "ambiguous type variable")
01:11:07 <dankna> seems to get same behavior for me, but if you've tested I'll play further.
01:11:13 <dankna> what ghc version are you on?
01:11:13 <Jonno_FTW> has lambdabot been broken in the latest build?
01:11:28 <Jonno_FTW> because I keep getting:  mueval-core: unrecognized option `--no-imports'
01:11:31 <ClaudiusMaximus> dankna: The Glorious Glasgow Haskell Compilation System, version 6.12.3
01:11:35 <dankna> ah
01:11:41 <dankna> okay.  I'm on 7.1.longnumber
01:11:57 <dankna> so there could easily be a difference in the typechecker, but who knows
01:12:21 <ClaudiusMaximus> dankna: concretely, this is what i tested: (mkQ False ((\it -> True) :: Either Bool Bool -> Bool))
01:12:28 * dankna blinks
01:12:55 <timBaum> can somebody tell me what functions tell me the current size of a widget and of the display in Gtk2hs?
01:13:14 <geheimdienst> the "glorious glasgow haskell compilation system" seems to suggest that there's also an inglorious system somewhere
01:13:26 <dankna> indeed it does
01:13:38 <dankna> that would probably be the evil mangler
01:14:12 <ziman> that reminds me of http://xkcd.com/90/
01:14:13 <dankna> Claudius: can't reproduce that behavior here, it still requires the outside signature for me
01:15:57 <ClaudiusMaximus> dankna: i pasted here (and after i hit submit i saw you might have a related paste i could have annotated?) http://hpaste.org/43682/generics
01:15:59 <dankna> if we were sure this wasn't somehow intended behavior, I could file a ticket and be happy
01:16:06 <geheimdienst> another thing: mkQ is listed as giving a (r, a -> r) http://hackage.haskell.org/packages/archive/uniplate/latest/doc/html/Data-Generics-SYB.html#v:mkQ
01:16:10 <dankna> yes, I do, at http://hpaste.org/43680/not_using_listifymkq_correctl
01:16:25 <dankna> you're looking at the uniplate version of mkQ
01:16:32 <geheimdienst> yeah?
01:16:35 <dankna> @hackage syb
01:16:35 <lambdabot> http://hackage.haskell.org/package/syb
01:16:52 <dankna> http://hackage.haskell.org/packages/archive/syb/0.3/doc/html/Data-Generics-Aliases.html#v:mkQ
01:17:13 <geheimdienst> teh packeges, dey is confusing me
01:17:29 <dankna> uniplate is another implementation of the same basic ideas as syb, as I understand it.
01:17:46 <dankna> I don't have a strong preference for syb, but I want to learn both of them before I decide on one.
01:17:58 <dankna> I am however being hampered in that studious endeavour by the fact that my code doesn't work :D
01:18:53 <pastorn> i want to align stuff with vim
01:19:06 <dankna> pastorn: I want to align stuff period.  good luck with that.
01:19:18 <pastorn> (all instances of '=' in a block, i.e.)
01:19:24 <pastorn> what's a good module for this?
01:19:25 <dankna> ClaudiusMaximus, yeah, well, no instance for show in the example you pasted is expected behavior, it needs to be used inside a call to something else to make sense
01:20:37 <ClaudiusMaximus> dankna: ah, shows how little i know about generics!
01:20:53 <dankna> ClaudiusMaximus, hehe I appreciate the efforts regardless
01:21:24 <ClaudiusMaximus> Traversable is about as 'generic' as i've got, which is hardly generic at all
01:21:34 <dankna> anyway I can reproduce your behavior in ghci, oddly.  that might be because it's pulling in uniplate instead of syb.
01:21:48 <dankna> my ghci-fu is not strong enough to know how to check that
01:22:02 <pastorn> dankna: found this http://www.vim.org/scripts/script.php?script_id=294
01:22:17 <pastorn> dankna: but i'd like to know if there's any better i should use instead
01:22:19 <dankna> Pastorn: looks nice, good luck with it
01:22:24 <dankna> pastorn: I bet there's a vi-related channel
01:22:45 <pastorn> i bet there is 
01:22:47 <pastorn> ;)
01:23:27 <dankna> I can't convince myself that I'm seeing a bug here... but I also can't convince myself I'm not
01:23:38 <dankna> I think I'm going to file a ticket on ghc and let dons tell me why I'm wrong :)
01:24:05 <geheimdienst> dankna: i made another annotation
01:24:10 <dankna> looking
01:24:22 <Jonno_FTW> it looks like the interface between lambdabot and mueval is broken
01:24:25 <dankna> oh you defined your own mkQ to be safe eh
01:24:39 <Jonno_FTW> is 4.2.3.2
01:24:55 <geheimdienst> mkQ is declared as «r -> (b -> r) -> a -> r», so i kinda see why you need to 2x tell it "b is a Thing" and "a is a Thing"
01:25:07 <dankna> yeah, I kinda see that too
01:25:08 <dankna> but
01:25:11 <dankna> the catch is
01:25:20 <dankna> notice that I'm not providing mkQ with all its parameters
01:25:23 <dankna> that's exactly the point, in fact
01:25:35 <dankna> I provide it with an r, False, and a (b -> r), (\_ -> True)
01:25:45 <dankna> that leaves the type of the expression as a -> r
01:25:49 <geheimdienst> yeah
01:25:50 <dankna> then I pass that to listify
01:26:17 <geheimdienst> but listify as its first arg takes a function (r -> Bool)
01:26:20 <geheimdienst> http://hackage.haskell.org/packages/archive/syb/latest/doc/html/Data-Generics-Schemes.html#v:listify
01:26:24 <dankna> yeah
01:26:32 <geheimdienst> so that works out
01:26:34 <dankna> and as its second arg, an r
01:26:47 <dankna> wait!
01:26:47 <dankna> no
01:26:59 <dankna> the full type of listify if you expand the GenericQ is
01:27:27 <dankna> Typeable r => (r -> Bool) -> (forall a . Data a => a -> [r])
01:27:29 <dankna> I believe
01:27:45 <dankna> or without the contexts, for readability
01:27:55 <dankna> (r -> Bool) -> a -> [r]
01:28:11 <dankna> so it's expecting the predicate to take specifically a parameter of the result type
01:28:25 <dankna> why would that be?  how does that even make sense?
01:28:34 <dankna> oh!
01:28:36 <dankna> because
01:28:44 <dankna> I'm misusing syb
01:28:51 <dankna> (r -> Bool) is not a generic function!
01:29:50 <dankna> I need to take out the call to mkQ
01:29:56 <dankna> indeed, mkQ is ambiguous
01:30:09 <dankna> for the other "schemes", as syb calls them, like everything and everywhere and so on,
01:30:14 <dankna> you do want a generic function
01:30:33 <dankna> but here you're actually collecting results, so a generic doesn't make sense
01:30:42 <dankna> okay
01:31:04 <dankna> thank you both for your time, geheimdienst, ClaudiusMaximus.  I understand how to fix my code now, and you may not feel you did much but I wouldn't have solved it on my own.
01:31:42 <geheimdienst> we've been rubberduckies. that's an important function.
01:31:47 <dankna> indeed so!
01:31:52 <geheimdienst> ;)
01:33:10 * geheimdienst has just discovered http://typeable.org/
01:33:43 <dankna> hm
01:33:43 <dankna> neat
01:34:01 <geheimdienst> looks nice, but i'm not sure it's useful yet
01:34:29 <dankna> yeah
01:34:32 <ddarius> Yeah... it doesn't seem to do anything.
01:35:49 <geheimdienst> i expect somebody was just trying out something
01:35:50 <dankna> well, it's trying to be a repository of ontologies
01:36:06 <dankna> a standard place to put these things
01:36:15 <dankna> I know that I would not use its linguistics things if I were doing language work though :/
01:36:16 <geheimdienst> in summary, i like the five-pointed stars. i hope they add soviet sickles somewhere
01:36:20 <dankna> haha
01:36:27 <edwardk> hrmm. i think i can't do the interleaved traversal without at least a monad =(
01:36:58 <edwardk> as i wind up needing join
01:38:20 <edwardk> maybe not, maybe i can get by with a monad on lists and use something like that as an intermediate structure
01:39:13 <edwardk> my first attempt was to derive something iteratee-ish and use that to do fair interleaving
02:04:55 <edwardk> hrmm i have the multitraversal, but its rather stricter than i'd like
02:05:04 <edwardk> not sure it can be made any more lazy though
02:06:14 <edwardk> @hpaste
02:06:14 <lambdabot> Haskell pastebin: http://hpaste.org/
02:06:32 <edwardk> http://hpaste.org/43686/simultaneous_traversal
02:06:37 <edwardk> ideas?
02:40:02 <joe6> edwardk:  "make a Traversable instance walk down two structures at the same time"  - I used TH to do this.
02:40:12 <joe6> please let me know if you want to check out the code.
02:40:23 <edwardk> joe6: i don't think i can, because i need it to be polymorphic
02:40:44 <edwardk> i have a lot of things like EitherTrie f g a = EitherTrie (f a) (g a) — i need to walk f and g
02:41:03 <edwardk> but i know nothing about them other than that they are traversable
02:41:09 <joe6> edwardk: dreixl did that for me using instant-generics. but, I could not understand his code and used TH.
02:41:18 <edwardk> *nods*
02:41:25 <joe6> edwardk: i am not sure if you want to look at that code.
02:41:26 <edwardk> the version i have now works pretty well
02:41:40 <edwardk> but if i decide to drop th into the solution i'll follow up =)
02:42:19 <joe6> edwardk: ok, cool.. btw, dreixl used the instant-generics module which also uses TH to do something though I do not know for what exactly.
02:42:36 <edwardk> yeah. i need to stick to something thats haskell 98 in this case
02:42:43 <joe6> ok, good luck.
02:42:45 <edwardk> the hpaste above works nicely
02:42:55 <edwardk> it interleaves the effects from both
02:43:03 <edwardk> now i'm generalizing it to my weaker forms of traversable
02:44:12 <edwardk> the generalizations are much uglier than the simple one
02:44:13 <edwardk> http://hpaste.org/paste/43686/simultaneous_traversal_annota#p43687
02:44:26 <joe6> edwardk: looks pretty cool and also simple (sign of good code, I believe)
02:44:56 <edwardk> yeah, kind of annoying that i need to rely on the hidden invariant to make refill work
02:45:17 <edwardk> if i was smarter i'd figure out a way to cps it and avoid the explicit list
02:46:05 <edwardk> some coroutine-like monad for bouncing back and forth, then just traverse using that
02:46:34 <edwardk> but my attempts at doing that relied on me having a monad, not an applicative =/
02:49:50 <joe6> edwardk: what kind of structures are you looking at? 
02:49:56 <joe6> any record structure?
02:50:12 <edwardk> joe6: representable functors, so they'll tend to be polynomial functors in general
02:50:22 <joe6> ok, thanks.
02:50:33 <edwardk> using them as a form of memo-trie
02:51:29 <edwardk> trying to make things like the instances for https://github.com/ekmett/representable-tries/blob/master/Data/Functor/Representable/Trie/List.hs more fair
02:51:47 <edwardk> conal does this in MemoTrie by weaving, but i want traversable, so i need to weave harder =)
02:54:03 <joe6> the code is pretty interesting.
02:54:53 <edwardk> trying for clean
02:55:11 <edwardk> but mostly what i want is a set of memo-tries that isn't hellish to extend for newtypes, etc.
02:55:37 <ddarius> Why do humans want to make everything complicated?
02:55:48 <edwardk> so i'm abusing my representable-functors library to build up a bunch of basic trie structures, then, repreentable-tries puts a thin veneer on that using embedding projection pairs for the keys
02:55:58 <edwardk> coz we can
02:56:17 <radishexp> Easy things aren't as interesting
02:56:39 <edwardk> the only difference in my world between a trie and a representable functor is that i want tries to be representable functors that admit a TraversableWithKey1 instance ;)
03:00:45 <maltem> Slightly OT, is anyone aware of research that characterizes all the possible lambda-terms of a given type? (in whatever sense this would be decidable problem)
03:06:23 <shemale_magic> you know its a bitova bugger to get haskkell installed without a binary ghc on some unixes eh
03:06:35 <shemale_magic> I think its a mistake to not have the isntall use gcc etc
03:06:49 <shemale_magic> anyhow whats new haskleres?
03:07:03 <edwardk> hrmm traverseBoth1 had a bug
03:10:44 <maltem> shemale_magic, to fix this "mistake" you'd have to write a Haskell compiler in C (more or less from scratch)
03:11:05 <edwardk> shemale_magic: that was what hugs was originally, no?
03:11:45 <ddarius> maltem: Type rules are usually presented in a relational style, so you could simply view the types as input and generate terms as output.
03:12:56 <maltem> ddarius, "relational style"?
03:13:20 <ddarius> You'd want a somewhat different rule set for this purpose since you'd probably only want (eta long) beta normal forms.
03:15:07 <maltem> ddarius, do you mean to enumerate the terms by applying typing rules backwards?
03:15:54 <maltem> I would actually wish for something smarter :)
03:16:18 <shemale_magic> ok
03:16:31 <maltem> edwardk, has Hugs ever been a compiler?
03:17:13 <kfr> maltem: Well, strictly speaking pretty much every interpreter is a compiler since compilation basically just describes the conversion of source code to some other format
03:17:25 <edwardk> maltem: i just meant haskell implementation written in c. i don't think so
03:17:26 <kfr> May it be bytecode or natively executable opcodes
03:17:50 <maltem> ok
03:19:09 <shemale_magic> ok so i know a little tcl and some bash and some basic lisp
03:19:15 <shemale_magic> how is haskell ncier than say tcl?
03:19:22 <ddarius> ...
03:19:45 <ddarius> Just about everything is nicer than tcl.
03:20:09 <shemale_magic> ok I work mainly as a unix admin
03:20:25 <shemale_magic> so say I was using haskell to manage servers running linux
03:20:30 <shemale_magic> or making a wiki
03:20:36 <shemale_magic> would haskell be more fun to use?
03:20:42 <edwardk> @hpast
03:20:42 <lambdabot> Maybe you meant: part paste
03:20:44 <shemale_magic> where would I see the greatest gains?
03:20:46 <edwardk> @hpaste
03:20:46 <lambdabot> Haskell pastebin: http://hpaste.org/
03:21:14 <edwardk> http://hpaste.org/43688/lots_of_fair_traversals
03:21:20 <edwardk> yay tedium
03:22:19 <geheimdienst> shemale_magic: for me the selling point is that in haskell, you rarely need to debug much. it's kinda hard to get something to compile, but once it does, usually it won't have many bugs anymore
03:23:11 <geheimdienst> that's because haskell has a type system that is really helpful. the compiler will make sure about all kinds of things
03:23:34 <geheimdienst> compare that with python or perl, where the compiler (interpreter) doesn't make sure of anything much. i view it as terribly unhelpful.
03:24:52 <kfr> That's more of a question of static typing vs. dynamic typing
03:25:05 <geheimdienst> yeah sure
03:25:18 <kfr> In Java and C# you generally have far fewer runtime problems than in Python, Ruby, Lisps, etc
03:25:34 <kfr> Although they still have null pointer exceptions ;p
03:26:04 <kfr> It's basically like most stuff in Java and C# are wrapped in a Maybe and default to Nothing, hehe
03:26:22 <kfr> s/are/is/
03:26:28 <kfr> s/default/defaults/
03:26:47 <geheimdienst> yes, the trouble about java or c# is that you need to write the types all the time. public static void main(String[] args) { for (String s in args) ...
03:27:07 <kfr> Yes, there's no inference
03:27:08 <geheimdienst> i feel the String-String-String hassle almost eats all the advantages of static typing
03:27:15 <kfr> Inference can be incredibly annoying at times, too, though
03:27:37 <geheimdienst> haskell gives you a very helpful type system but gets out of your way because of the inference
03:27:39 <kfr> Frequently the type problems I have in Haskell originate in places other than the line it has problems with
03:27:57 <kfr> And then you need to start adding types line by line until you have discovered the culprit
03:28:25 <geheimdienst> you mean an "inferred/expected" mismatch? i don't find that hard to fix if you read the compiler message closely ...
03:28:36 <geheimdienst> maybe depends on the kind of code you're working with
03:28:46 <jix> some haskell source to colorized html converter that adds all inferred types to the terms as title or something would be useful
03:29:09 <geheimdienst> jix, yeah, good idea actually
03:30:46 <maltem> As for "inferred/expected" error messages, I find it usually hard to visually map the quoted types onto my source code. That's really the only thing where I'd love to have an editor that assists in type-checking
03:31:18 <ddarius> maltem: Look up type error slicing and Chameleon's type debugger.
03:32:29 <ddarius> kfr: Recommended practice is to have type annotations for your top-level functions.  This usually limits the range of a type error and also has the benefit of making the monomorphism restriction irrelevant.
03:32:47 <kfr> But even when I know all the types I frequently still don't know what I'm doing wrong lol
03:33:03 <pastorn> joe6: stop with the poke+ignore methods 
03:33:07 <pastorn> :'(
03:33:45 <ddarius> geheimdienst: C# has some amount of local type inference now.
03:33:49 <maltem> I've never seen Chameleon before, thanks for the pointer
03:33:58 <kfr> It's part of his scheme to make Haskell programmers depressed to eventually drive them into suicide, pastorn
03:34:07 <ddarius> for(var s in args)
03:34:23 <pastorn> kfr: thanks for painting me that colourful future
03:34:52 <ddarius> pastorn: Feel free to kill people other than yourself.
03:35:51 <pastorn> ddarius: Couldn't match expected type 'IO Suicide' against inferred type 'IO Homicide'
03:36:30 <ddarius> pastorn: If you are adamant about killing yourself then, feel free to include many others with you.
03:37:03 <pastorn> ddarius: maybe i can solve this with CaML imports... i hear you can do nifty stuff with them
03:38:17 <ddarius> What the hell is CaML?
03:38:31 <pastorn> O'CaML prequel?
03:38:42 <ddarius> I think you mean either CAML or Caml then.
03:39:04 <pastorn> i thougt the ML was capitalized
03:39:06 <pastorn> SORRY
03:39:11 * pastorn runs away crying
03:39:19 <ddarius> What did you think the Ca meant?
03:39:54 <pastorn> i didn't... i assumed it was made up to make it to an animal name, like all french programming language names
03:40:34 <ddarius> Well, just for future reference, CAML stands for "Categorical Abstract Machine Language."  SML is "Standard Meta Language"
03:40:53 <ddarius> However, I think I will start telling people that they are Sulfur ML and Calcium ML now.
03:41:22 <pastorn> hmm... ML stands for MetaLanguage
03:41:51 <pastorn> noone cares about consintency :(
03:42:23 <dark> jix, is there some emacs mode for doing online type inference? i think it would be wonderful
03:42:41 <pastorn> dark: there is if you use the yi editor
03:42:43 <dark> i saw some IDEs (like eclipse) doing things like that, with java
03:43:02 <dark> pastorn, uhm..
03:43:06 <pastorn> it has an "incremental parser" which has the syntax tree that you're coding on
03:43:15 <pastorn> dark: and it has emacs bindings
03:43:26 <edwardk> ml and sulfur go together. the faint whiff of brimstone is common around o'caml users.
03:43:36 <dark> pastorn, is yi wrappeable? like, a headless mode like mplayer mode, that would let one to hook another GUI
03:43:38 <dark> ahh
03:43:44 <dark> interesting õ.o
03:43:48 <ddarius> edwardk: Sulfur would be for SML though.
03:44:11 <dark> so i could install this yi mode like *now*? (in emacs)
03:44:13 <edwardk> ddarius: the taint is much stronger there. ;)
03:44:27 <pastorn> dark: i don't know too much about it, i'm satisfied with VIM, but check hackage... there are a bunch of packages, i think there might be some GTK fontend (not sure)
03:44:40 <pastorn> dark: no, it's a standalone editor
03:45:05 <dark> i could use yi editor if it is really good, but the overhead for switching editors is pretty high (and i don't do haskell very often)
03:45:27 <dark> pastorn, but what this 'emacs bindings' are worth then?
03:45:40 <jix> dark: key-bindings
03:45:49 <jix> I assume
03:46:00 <pastorn> dark: i have a friend who does haskell in emacs, so he calls ghc from emacs and lets it typecheck whatever he works on and goes to the error or whatever
03:46:10 <kfr> http://code.haskell.org/yi/ I am puzzled
03:46:13 <kfr> Where did Yi go?
03:46:18 <pastorn> jix, dark: yes, the key bindings
03:46:23 <dark> pastorn, i do that too
03:46:23 <jix> kfr: c.h.o is broken
03:46:29 <kfr> Oh snap
03:46:57 <dark> what i would like is to run this yi as a background process, and talk with emacs through a pipe .-.
03:47:26 <dark> but i don't know a lot of either elisp or haskell, so, nevermind .-.
03:47:31 <kfr> dark use eshell with Vty?
03:47:35 <pastorn> dark: hehe... i think you might be better of using it directly... and what's so advanced that you have to keep track of the syntax tree while coding?
03:47:39 <kfr> I know some emacs Lisp and Haskell
03:47:42 <maltem> kfr, there is http://groups.google.com/group/yi-devel (btw the google-groups interface has got really annoying over time)
03:47:54 <dark> pastorn, no, i just think it is useful
03:48:13 <shemale_magic> hmm
03:48:33 <dark> pastorn, i used eclipse for a while and wow, emacs feels a bit less magic now
03:48:34 <shemale_magic> so haskell is way more fun than lisp or tcl?
03:48:53 <dark> shemale_magic, for some values of fun, sure
03:48:56 <pastorn> dark: ehm... maybe you should look at "leksah" for your IDE needs
03:49:30 <pastorn> i don't know about keeping the syntax tree in state, but i know it has some cool refactoring tools
03:50:30 <dark> uhm, right now i don't really want another environment besides emacs (the cost for switching is pretty high, and i suppose both leksah and yi are too haskell-oriented). but i could use them if i did some serious emacs code, thanks
03:50:55 <dark> when i needed to do some java thing, i looked at eclipse, said wow, but in the end i didn't used it either
03:51:28 <geheimdienst> shemale_magic: i would say haskell is more fun. i've noticed since getting into haskell, i have not much tolerance for any dynamic language anymore, whether it's python or shell scripts
03:51:29 <ddarius> Yi is no more Haskell-oriented than Emacs is Lisp-oriented.
03:52:08 <dark> ddarius, would it have a reasonable ruby mode, for example?
03:52:44 <ddarius> Depends on whether someone has written one yet.
03:52:44 <dark> the thing with emacs is that it has a lot of useful things already written
03:52:57 <dark> yes, that was what i meant by 'haskell-oriented'
03:53:01 <ddarius> Yi is much younger and has fairly little development for its age.
03:53:27 <shemale_magic> now what about for deleting files n stuf fon nix?
03:53:31 <shemale_magic> better use shell or tcl?
03:53:34 <dark> i suppose that if yi had the same amount of love that emacs receives, it could as well be better
03:53:47 <dark> shemale_magic, shell script is perfect for that, imo
03:54:00 <ddarius> It depends on what you are doing.
03:54:04 <shemale_magic> ok
03:54:05 <dark> because you already got a REPL interpreter for it, and you probably use it a lot
03:54:14 <ddarius> Certainly just writing rm foo is simpler than writing a program to do it.
03:54:21 <dark> (i use one called bash)
03:54:57 * geheimdienst feels that a few lines in a shell script is good, but as it gets longer, there's more incentive to switch to a real language
03:55:00 <ddarius> If you need to read a bunch of commands from an XML file and delete based off of that, shell script seems less compelling.
03:55:26 <dark> but then ruby becomes very interesting
03:55:34 * jix was thinking why should you read comonads from an XML file....?
03:56:08 <ddarius> Just for you information, there are companies that use Haskell for their system administration tools, e.g. Linspire or whatever the heck it's called nowadays.
03:56:53 <dark> how are leksah and yi related?
03:57:17 <shemale_magic> hmm
03:57:26 <accel> leksah :: yi = emacs :: vi
03:57:28 <shemale_magic> so for web is haskell nice?
03:57:38 <accel> leksah has everything except a full featured editor
03:58:09 <gienah> leksah has a use flag to enable it to use yi
03:58:20 <maltem> Leksah aims to be more of an IDE a la eclipse etc. rather than an editor
03:58:31 <geheimdienst> dark, i don't agree about ruby. my experience is that i will make mistakes when programming. haskell does much to catch those early. dynamic languages try to postpone reaching the mistakes as long as possible, hoping that we'll never hit them
03:58:32 <jutaro> dark: their is an effort to integrate yi in leksah as editor component, but it is not usable yet 
03:58:42 <dark> shemale_magic, the frameworks for doing web apps seem pretty cool, but i ended up using ruby's sinatra
03:58:43 <geheimdienst> that's too much "hope" and too little engineering for my taste :)
03:59:08 <shemale_magic> why use haskell is its not msot fun for programs you want to write?
03:59:17 <shemale_magic> whats nice about ruby sinatra?
03:59:20 <astroboy> shemale_magic: snapframework.com
03:59:20 * gienah did mention that leksah has a yi use flag
04:00:01 <accel> gienah: have you tried using it?
04:00:33 <geheimdienst> shemale_magic: i think haskell is great fun once you get the hang of it. i use haskell for every possible task, given half a choice
04:00:34 <gienah> accel: not very much as I could not persuade yi to compile with ghc 7
04:00:48 <dark> shemale_magic, it's.. simple. but there also clones for node.js and lua
04:02:00 <dark> geheimdienst, oh, this also hits me. i was doing a project with an ocaml component that did hard work connected to a database, and a ruby webapp to display it. the ocaml thing statically verified if the code typing agreed with the db (it connected to the db at compile time). in the beginning the type errors was a bit crazy, but bugs there was way rarer, and a lot easier to diagnose
04:02:16 <Feuerbach> I'm getting "hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)" while trying to read a file consisting of a single unicode character. Reproduced with ghc 6.12.1 and 7.0.1, independently of locale (POSIX, UTF-8). Any ideas?
04:02:44 <geheimdienst> dark: yes i agree, that's what i mean
04:02:58 <Botje> Feuerbach: what encoding does your file use?
04:03:12 <Feuerbach> Botje: UTF-8
04:03:36 <geheimdienst> Feuerbach: i recall people discussing this just 1-2 weeks ago, but i don't remember their solution ... grep the channel's logs ...?
04:03:43 <Saizan> you could open the file in binary mode
04:03:51 <Saizan> that way there's no automatic decoding
04:03:55 <gienah> accel: I did ensure though that if you do emerge app-editors/leksah on gentoo with the yi use flag that it does build with ghc 6.12.3, with ghc 7.0.1 it yi gets a weird type error with rank2types that I could not understand
04:04:15 <Saizan> if with an utf-8 locale it can't read an utf-8 file it sounds like a bug though
04:04:16 <maltem> Feuerbach, does hGetEncoding say something interesting?
04:04:36 <Feuerbach> Botje, geheimdienst, maltem: disregard, it was my stupid mistake :)
04:05:02 <accel> gienah: is understanding haskell type errors like deciphering c++ boost template errors?
04:05:28 <Palmik> hardly :P
04:05:28 <Feuerbach> (I had test file "x" and test program x.hs, so that compiled version overwrote the original test file)
04:05:46 <gienah> accel: I find C++ boost template errors easier to understand :-)
04:06:04 <geheimdienst> catching stupid mistakes is something that #haskell and ghc seem to have in common
04:06:30 <maltem> Feuerbach, fwiw I'd refrain from ghc's handling of text encoding most of the time. Most of the time you want binary I/O anyways
04:07:03 <Feuerbach> maltem: if you don't care much about the contents, then yes
04:22:36 * hackagebot control-monad-exception 0.9.1 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.9.1 (PepeIborra)
04:23:37 * hackagebot control-monad-exception-mtl 0.8.0.4 - MTL instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-mtl-0.8.0.4 (PepeIborra)
04:23:38 * hackagebot control-monad-exception-monadsfd 0.9.1 - Monads-fd instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-monadsfd-0.9.1 (PepeIborra)
04:23:40 * hackagebot control-monad-exception-monadstf 0.9.1 - Monads-tf instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-monadstf-0.9.1 (PepeIborra)
04:32:57 <shemale_magic> hmm
04:33:13 <wkoiking> I have been trying to install Chart package using cabal-install and got "unknown symbol `_cairo_surface_destroy'", any help?
04:34:02 <kfr> wkoiking have you installed libcairo on your system?
04:34:31 <wkoiking> At least, I think so..
04:34:50 <kfr> wkoiking what OS?
04:35:00 <wkoiking> windows :(
04:35:05 <kfr> http://haskell.1045720.n5.nabble.com/GHCi-Cairo-Windows-td3366434.html
04:38:23 <wkoiking> hmm it seems to be the same problem
04:39:16 <wkoiking> ktr thanks for the info
04:41:33 <ToRA>   foo :: a b -> (forall c . b c -> d c) -> a d
04:41:45 <ToRA> what would people call foo / the class of a?
04:42:17 <ToRA> e.g. class Fooable a where foo :: ....
04:52:40 <wto> :t liftM2
04:52:41 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:54:50 <Jafet> :t ((<*>).).(<$>)
04:54:51 <lambdabot> forall (f :: * -> *) a b a1. (Applicative f) => (a1 -> a -> b) -> f a1 -> f a -> f b
04:55:19 <wto> :t join
04:55:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:58:20 <wkoiking_> I almost always fail at cabal-install...
04:58:37 <wkoiking_> I wonder is that because of OS?
04:58:45 * hackagebot representable-tries 0.3 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3 (EdwardKmett)
04:58:45 <kfr> Yes
04:58:54 <kfr> wkoiking_: We Windows users are third class citizens
04:59:11 <kfr> Prepare for 10-20 lines of "just use Linux"
04:59:25 <kfr> Or "why aren't you using Linux?"
04:59:56 <kfr> wkoiking_ also notice how there is no AMD64 build for Windows because it hasn't even been ported yet
05:00:00 <wkoiking_> How often you fail at cabal-install, Linux citizens?
05:00:22 <dark> you fail with which messages? o.o
05:00:36 <dark> i have never failed i think (gentoo)
05:01:17 <dark> most things i install through "cabal" is really through an automatically-generated ebuild, from the cabal file
05:01:37 <Jafet> Why aren't you using mingw? Just use mingw
05:01:50 <dark> i don't actually understand a lot of it, but i use the gentoo-haskell overlay
05:02:07 <wkoiking_> umm Im using mingw
05:04:40 <shemale_magic> so haskell realy kicks ass?
05:04:47 <shemale_magic> can you make videogames liek wow in it?
05:04:59 <shemale_magic> run raby or amazon kinda site?
05:05:02 <shemale_magic> ebay
05:05:21 <kfr> No, it's terrible
05:05:36 <kfr> shemale_magic: Most people who start Haskell eventually end up losing all interest in programming
05:05:59 <edwardk> kfr: true that
05:06:15 <adu> kfr: that's not quite true
05:07:02 <adu> kfr: people who learn Haskell well, usually find other programming languages lacking in every way
05:07:54 <kfr> "You know how they say that when you have a problem and you decide to use regular expressions to solve it, you now have two problems? Well, Haskell is the opposite in that regard. You start out with a problem, then you go through a lot of trouble to actually learn the language and then you no longer have the problem in the first place because you have lost interest in programming." - by Philip Wadler, from "Faith, Evolution, and Programming Languages", April 
05:07:54 <kfr> 2007
05:07:56 <jix> s/other/all
05:08:01 <kfr> Lack of slash
05:08:09 <kfr> sed hates you
05:08:37 <adu> kfr: lol
05:08:52 <kfr> @quote SPJ cheerful
05:08:52 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
05:09:07 <adu> I thought he made Haskell
05:09:10 <Saizan> you seem to attribute too much weigth to funny quotes
05:09:39 <adu> kfr: Haskell is a show-stopper, yes we get it
05:10:31 <vegai> that's quite accurate, actually
05:10:37 <kfr> :D
05:10:46 <adu> I wonder why tho
05:11:02 <kfr> Because Haskell makes you hate programming
05:11:15 <kfr> In the end you just talk about category theory on IRC
05:11:23 <edwardk> kfr: hey!
05:11:25 <kfr> Without ever doing anything practical in your private time anymore
05:11:32 <kfr> edwardk: Hay hay!
05:11:40 <adu> is it because Haskell teaches you how to live without the constant/variable distinction, or the statement/expression distinction, or the data/code distinction...
05:11:46 <vegai> or perhaps it's just age that makes one hate programming
05:11:55 <adu> vegai: I think that's it
05:11:56 <edwardk> adu: it is the zen path to enlightenment
05:11:57 <vegai> and by the time you've learned Haskell, you're bound to be old
05:12:01 <kfr> It's already happening to me, my creative output has greatly diminished since I started coding in Haskell
05:12:07 * geheimdienst attributes weight to funny quotes only when there is a cat shown behind them
05:12:08 <adu> vegai: lol
05:12:19 <drbean>  How do I coerce the string "Foo" into the data constructor Foo?
05:12:22 <edwardk> in the end you are content to live with just the spineless tagless g-machine. i mean look at that name, it is all about what isn't present, not what is ;)
05:12:32 <kfr> In one year from now I might no longer be a programmer
05:12:35 <kfr> Just watch me
05:12:40 <kfr> Haskell did it, people!
05:12:47 <vegai> also, there's the risk that learning Haskell makes you hate every other language
05:12:51 * hackagebot pappy 0.1.0.1 - Packrat parsing; linear-time parsers for grammars in TDPL.  http://hackage.haskell.org/package/pappy-0.1.0.1 (ChrisDone)
05:13:01 <Saizan> drbean: there's no generic way to do that
05:13:15 <jix> vegai: and as soon as you've looked at dependent types you hate every language
05:13:21 <adu> vegai: I wouldn't call that a risk, so much as an innevitability 
05:13:25 <edwardk> drbean: usually with the "Read" instance for your class
05:13:31 <hpc> jix: lol
05:13:39 <edwardk> > read "Left 12" :: Either Int Bool
05:13:39 <lambdabot>   Left 12
05:13:47 <jix> haskell sucks because it isn't agda... but agda sucks because it isn't haskell
05:13:50 * hpc still doesn't hate perl, somehow
05:13:52 <kfr> jix: Agda/Coq will make you hate Haskell?
05:13:55 <adu> vegai: learning Haskell == hating [x | x <- other languages]
05:14:00 <Saizan> jix: make one yourself!
05:14:19 <edwardk> drbean: but that only lets you build the fully saturated type
05:14:30 <jix> Saizan: if I knew how to make one that is better
05:14:32 <adu> or [x | x <- Languages, x /= Haskell]
05:14:46 <adu> :)
05:15:03 <edwardk> jix: clearly you need to program in the intersection, writing code that is both valid agda and haskell.
05:15:11 <shemale_magic> learnign haskell makes you lose interest in programming????
05:15:12 <adu> jix: wanna make a new Agda with me?
05:15:12 <edwardk> you may find this a bit limiting, however.
05:15:59 <adu> shemale_magic: no, I love programming, and I've only been using Haskell for 10 years
05:16:05 <aristid> edwardk: limitations are a source of inspiration.
05:16:07 <Saizan> at least haskell programs are meant to be run most of the time..
05:16:15 <adu> shemale_magic: but I do hate all languages that aren't Haskell
05:16:24 <aristid> adu: even agda?
05:16:36 <adu> aristid: dunno, never used Agda, but I like the theory of Agda
05:16:53 <adu> how does one install Agda anyways?
05:17:01 <aristid> cabal install agda
05:17:03 <edwardk> adu: clearly you should refactor that into do sugar with a guard statement. what happens when you need to add a bit of envionment or want logging? =)
05:17:13 <adu> macports doesn't have it
05:17:16 <adu> :P
05:17:51 <aristid> adu: who uses macports anyways these days? i thought homebrew was the shit. but then, i only use ubuntu myself.
05:17:51 <adu> do x <- Language; x /= Haskell; return x
05:17:53 <kfr> shemale_magic: Yes, when people learn Haskell they're about to bite the programming dust
05:17:57 <adu> aristid: i do
05:18:14 <adu> it has decent-ish versions of ghc and hs-platform
05:18:24 <aristid> adu: Language is a constructor of some monadic type?
05:18:30 <edwardk> adu: guard (x /= Haskell)
05:18:44 <adu> aristid: language :: [Language], sorry about the incorrect case
05:18:54 <edwardk> kfr: hence why i'm trying to get all my productivity in while i can
05:19:11 <adu> data Language = Haskell | ...
05:19:17 <aristid> adu: but again, cabal install agda :)
05:19:25 <adu> aristid: I don't use cabal
05:19:33 <aristid> adu: you should use it :)
05:19:53 * hackagebot gd 3000.6.1 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.6.1 (ChrisDone)
05:19:55 <adu> I just: tar -xvzf ; for X in configure build install ; do runghc Setup $X ; done
05:19:57 <edwardk> clearly you should use Dynamic there or a string otherwise you'lll have to restart your brain every time a new language comes out
05:20:04 <kfr> Agda people are even more academic programming haters than the Haskell crowd, right?
05:20:20 <kfr> Maybe I should upgrade to Agda, then I can finally stop coding
05:20:29 <kfr> And dedicate my life to eating, writing music and playing video games
05:20:31 <hpc> kfr: seeing as how they can't even make complete programs in it, yes :P
05:20:43 <kfr> Oh? It's not a practical language?
05:20:49 <aristid> adu: well, that should work for agda, too.
05:20:52 <kfr> I thought it wasn't a formal proof system like Coq
05:20:53 <hpc> it's not turing complete
05:20:55 <hpc> it's a proof language
05:20:58 <kfr> Oh :C
05:21:00 <edwardk> i find agda folks are perfectly willing to code in other languages. mainly because it lets them take a break from agda. it can be a bit headachy to code in all the time
05:21:05 <adu> aristid: oh, ok, cool
05:21:05 <hpc> in fact, it can't be turing complete
05:21:28 <hpc> or it can write fix :: (a -> a) -> a, which is "if a implies a, then a is true"
05:21:32 <hpc> which is "everything is true"
05:21:43 <Saizan> you can have perfectly fine complete programs in a non-turing-complete language
05:21:53 <edwardk> hpc: or 'assuming the hypothesis' in type form
05:22:05 <jix> hpc: but you can write turing complete stuff using codata and some not written in agda runtime
05:22:25 <hpc> jix: ah, cool
05:22:27 <adu> wow my head just exploded
05:22:32 <edwardk> jix: codata in agda still has to be productive. thats not turing complete
05:22:55 <adu> hpc: that sounds like a disproof of that whole Curry-Howard isomorphism thingy
05:22:55 <kfr> adu do you require medical assistance?
05:23:06 <aristid> clearly agda is shit, and brainfuck is much better
05:23:10 <aristid> being turing complete.
05:23:17 <adu> aristid: forth FTW
05:23:22 <jix> edwardk: what does productive mean? (I really don't know a lot of this)
05:23:23 <hpc> INTERCAL!
05:23:26 <edwardk> adu: no. curry howard still holds, its just the logic you are in is degenerate. every type is inhabited by bottom
05:23:52 <aristid> there's an ass in every haskell type :D
05:23:53 <edwardk> adu: therefore "undefined" or bottom is a proof of every proposition in the logic given by Haskell types.
05:24:00 <adu> aristid: lol
05:24:20 <kfr> "Haskell - the /b/ of programming languages."
05:24:28 <adu> i prefer the term "initial object"
05:24:37 <edwardk> adu: curry howard doesn't care about degeneracy of your logic though
05:24:58 <adu> or sometimes when I'm feeling really snobby, "coterminal object"
05:25:25 <adu> o which reminds me of a really funny category theory joke
05:25:33 <adu> what's another name for a sequence?
05:25:50 <aristid> transpose?
05:26:15 <geheimdienst> monoid in the category of endofunctors?
05:27:04 <adu> nope
05:27:10 <ToRA> Set?
05:27:13 <adu> nope
05:27:13 <edwardk> gehemdeinst: is that basically the category theory equivalent of writing '42' down for a calculus problem?
05:27:33 <adu> I'll give you a hint
05:27:45 <hpc> edwardk: perhaps the equivalent of "this margin is too small"
05:28:04 <adu> a sequence is defined as (Integer -> a)
05:28:19 <adu> give up?
05:28:22 <geheimdienst> edwardk: you know the reference, right?
05:28:34 <geheimdienst> @google brief mostly wrong history of programming
05:28:35 <lambdabot> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
05:29:04 <aristid> @quote ennobunktor
05:29:06 <adu> a co-bag! (the multiplicity of each element in a bag is (a -> Integer))
05:29:19 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
05:29:30 <edwardk> adu: hopefully you mean natural in both cases =)
05:29:41 <adu> edwardk: oh oops, yes
05:29:57 <adu> edwardk: but Haskell doesn't have a natural type, so i had to improvise
05:30:21 <jacobian> <edwardk> i find agda folks are perfectly willing to code in other languages. mainly because it lets them take a break from agda. it can be a bit headachy to code in all the time
05:30:22 <jacobian> LOL
05:30:38 <edwardk> jacobian: =)
05:31:34 <adu> anyways, this is why it's funny: http://www.urbandictionary.com/define.php?term=cobag
05:31:39 <ddarius> Free at last, free at last.  Thank God Almight, free at last.
05:31:39 <aristid> adu: writing a Natural type in haskell is perfectly possible :)
05:31:52 <aristid> @free ddarius
05:31:53 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `ddarius'\n\n"
05:32:11 <edwardk> ddarius: from?
05:32:46 <ddarius> edwardk: Ice.
05:32:57 <edwardk> ah
05:33:03 <ddarius> +y
05:33:56 <ddarius> edwardk: Wildberger defines rational multisets.
05:34:46 <ddarius> edwardk: Too bad I'll still need to go to a dealership tomorrow morning to get a side mirror replaced.
05:35:36 <edwardk> and you can allow virtual species to have bags with negative elements
05:35:55 <ddarius> Saying Agda folk are "perfectly willing to code in other languages" suggests that Agda folk code in Agda.
05:36:47 <aristid> ddarius: it only SEEMS to suggest it.
05:36:54 <thecod> Not sure that there is much "real world" code in Agda
05:37:21 <thecod> Agda people probably use Haskell for the most part...
05:37:37 <kfr> thecod that's the impression I get
05:37:43 <thecod> it would be quite fun to bootstrap a language like Agda though :)
05:37:45 <edwardk> ddarius: i'm sure they'd be perfectly willing to code in agda as well, assuming the compiler could be convinced to finish compiling their program with the amount of memory available to them
05:37:59 <edwardk> thecod: its been done with coq. there is a coq-in-coq implementation
05:38:19 <aristid> oO the visual jokes must be suppressed
05:38:52 <kfr> aristid: You mean docking?
05:38:57 <thecod> edwardk: true, though of course the real Coq compiler isn't at all written in Coq
05:38:59 <edwardk> aristid: turducken or porn?
05:39:11 <ddarius> edwardk: Clearly turducken porn.
05:39:16 <edwardk> ddarius: =)
05:40:05 * ddarius thinks of a good place to put the () Introduction rule.
05:40:27 <kfr> ddarius what's that?
05:42:10 <thecod> edwardk: also i believe that it's only the CIC and not the full CIC with universes and coinductive types that is in Coq in Coq
05:42:22 <edwardk> thecod: very likely
05:42:23 <thecod> plus of course the termination of the system is postulated
05:43:36 <beastaugh> is there a way, when installing a package with cabal-install, of passing a flag to a dependency that's being compiled with it?
05:45:18 <beastaugh> I would install them separately, but there's some kind of butterfly effect thing going on and it always wants to recompile the dependency, regardless of whether it's already installed
05:51:07 <Navigium> Hello...
05:51:23 <kfr> Navigium: So you're just starting out with Haskell?
05:52:08 <Navigium> kfr: Basically yes. I just read the first 120 pages of real world haskell.
05:52:21 <kfr> Damn, I'm good.
05:52:37 <systemfault> I found RWH to be very difficult :P
05:52:43 <lysgaard> Anyone have or know of a working RPC solution or something that could replace RPC in Haskell. There are msgpack-rpc and yaml-rpc but both are broken.
05:52:47 <geheimdienst> cale: ping? lambdabot fell out the window
05:53:05 <Navigium> But my problem a the moment is not directly concerning haskell. I try to get haskell-emacs-mode running on my freeBSD box. But the site seem to be down.
05:53:10 <beastaugh> lysgaard: can't you fix one of them up? :)
05:53:10 <zygoloid> geheimdienst: did she fall or was she pushed? :)
05:53:14 <cdsmithus> systemfault: RWH is a great book; but if you haven't done Haskell before it does pay to take it slowly and experiment a lot rather than just plow through
05:53:17 <Navigium> Anyone any idea where it has gone?
05:53:19 <kfr> geheimdienst: A defenestrated bot?
05:53:27 <Navigium> kfr: how did you guess?
05:53:41 <kfr> Navigium because nobody else would bother to greet a channel
05:53:48 <kfr> Anyways, I can give you a tar ball
05:54:06 <geheimdienst> zygoloid, the incident involved somebody i decline to identify in #haskell-blah saying "> transpose $ concat cake" ...
05:54:20 <lysgaard> beastaugh: msgpack is missing iteratee and yaml has some problem with transformers
05:54:27 <zygoloid> geheimdienst: i saw it. i thought it wasn't fair for you to hide your shame ;)
05:54:48 <Navigium> kft: that would be great... there is no port in freeBSD..
05:54:53 <beastaugh> Navigium: there are some mirrors on GitHub, e.g. https://github.com/jwiegley/haskell-mode
05:54:54 <lysgaard> beastaugh: I'm not too confident in Haskell. I'd love to fix them if i knew how ;)
05:55:10 <geheimdienst> i don't see what everyone is going on about. normally she is very supportive of our fooling around
05:55:26 <zygoloid> :D
05:55:28 <beastaugh> lysgaard: ok, fair enough :)
05:55:42 <kfr> Navigium: http://siyobik.info/misc/haskell-mode.7z is the version I am using with emacs
05:56:24 <kfr> code.haskell.org has been broken for quite a while now
05:56:27 <kfr> I bet it was hosted there?
05:56:34 <Navigium> beastaugh: thanx
05:56:45 <Navigium> kfr: yep... thanx for your version!
05:57:13 <kfr> If you find the hidden rootkit you get a cookie!
05:59:31 <ubuntuhaskell> Hi.What package are recommended for coding environment for haskell in ubuntu
05:59:58 <ubuntuhaskell> that makes it easier to code
05:59:58 <Zao> Install the Haskell Platform, then use whatever floats your boat.
06:00:00 <hpc> ubuntuhaskell: i personally use vim and ghc6
06:00:01 <ubuntuhaskell> :)
06:00:09 <cdsmithus> There should be a haskell-platform in apt.  Then install stuff with cabal-install from there
06:00:11 <Zao> I prefer a decent editor, but some madmen use Leksah or EclipseFP.
06:00:27 <hpc> i tried leksah on windows
06:00:32 <ubuntuhaskell> so leksah i tryed
06:00:35 * hpc will never make that mistake again
06:00:39 <ubuntuhaskell>  but didnt like it
06:01:00 <ubuntuhaskell> so editor like nao or eclipsefp
06:01:03 <ubuntuhaskell> what else
06:01:05 <dschoepe> Emacs
06:01:09 <ubuntuhaskell> ok
06:01:11 <cdsmithus> Leksah is an interesting concept, but definitely lacks UI stability, IMO, to be used day to day.
06:01:11 <dschoepe> (+ haskell-mode)
06:01:12 <parcs> ubuntuhaskell: now's a good time to learn emacs or vim :)
06:01:17 <parcs> (or both)
06:01:24 <ubuntuhaskell> is there plugin for vim
06:01:31 <ubuntuhaskell> for haskell
06:01:32 <parcs> yeah, also called haskell-mode
06:01:39 <ubuntuhaskell> ok. :)
06:01:41 <hpc> i suggest not using plugins, unless you already know the editor
06:01:57 <hpc> learn it vanilla first, so you know how it works in stock config
06:01:57 <ubuntuhaskell> ok
06:02:13 <hpc> it might even be enough for you, without the haskell-mode perks
06:02:32 <cdsmithus> I tend to just use some combination of gedit, lpe, or whatever happens to pop up when I double-click a file. :)
06:03:04 <parcs> what kind of perks does haskell-mode for vim offer, anyway?
06:03:13 <hpc> not sure, actually
06:03:24 <hpc> i can't imagine it being much more than what a ghci window would have
06:03:28 <ubuntuhaskell> does emac or vim offer auto-completion
06:03:35 <hpc> ubuntuhaskell: no
06:03:37 <ubuntuhaskell> of keywords
06:03:40 <ubuntuhaskell> and so on
06:03:41 <hpc> not by default at least
06:03:41 <beastaugh> I know some people swear by haskell-mode etc., but I find a decent text editor with syntax highlighting is not just good enough to write Haskell in, but works fine for any language
06:03:46 <hpc> it highlights syntax though
06:04:02 <ubuntuhaskell> ghci offers autocompletion
06:04:11 <beastaugh> the time I spend typing is tiny compared to the time I spend thinking, so it's not something I really need to optimise
06:04:16 <hpc> the only editor i have found that does completion well is eclipse
06:04:35 <hpc> (it actually does a lot right; it's just so fat when it does)
06:04:43 <ubuntuhaskell> ?
06:04:59 <cdsmithus> beastaugh: exactly
06:05:55 <hpc> i think all i would need from a haskell mode is typechecking
06:06:18 <hpc> so bad functions have their type signature highlighted red
06:06:34 <ubuntuhaskell> yes also that does eclipse offer that
06:06:37 <ubuntuhaskell> :)
06:06:55 <ubuntuhaskell> or \i could google it .
06:06:58 <ubuntuhaskell> xD
06:07:09 <cdsmithus> Personally, I've found Eclipse to be very unstable on Ubuntu.  Just a heads up.
06:07:18 <plan9erlang> From now on all names are OS + functional language
06:07:32 <plan9erlang> sup ubuntuhaskell 
06:07:59 <hpc> http://en.wikipedia.org/wiki/HP-UX
06:08:06 * hpc is hp os, and c
06:08:08 <hpc> :D
06:08:21 <Zao> Poor soul.
06:08:44 <ubuntuhaskell> :)
06:08:58 <haskellnoob> here is a small problem for which i know a "procedural" answer, but am looking for the cute haskell three-word solution. the input is a finite list of integers, and the question is to find an index i such that the sum of the entries before i is equal to the sum of those after. the empty list is assumed to contain zero, and if there is no such i, the answer should be -1.
06:09:25 <haskellnoob> what would be a "functional" way of doing this?
06:09:33 <ubuntuhaskell> eclipse is still in beta
06:09:39 <ubuntuhaskell> Leksah  is more stable
06:09:46 <ubuntuhaskell> so leksah it is :/
06:10:01 <cdsmithus> haskellnoob: Looks like scanl is your friend there.
06:10:12 <haskellnoob> cdsmithus: let me check scanl out
06:10:28 <hpc> a combination of length, scanl, and takeWhile
06:10:39 <hpc> it could probably even be done pointlessly
06:10:56 <hpc> or in pointfree style, even :P
06:11:05 <haskellnoob> :)
06:11:06 <ddarius> haskellnoob: First thing I would do is change the problem.
06:11:11 <geheimdienst> which of those is more pointless?
06:11:13 <haskellnoob> ddarius: so that..?
06:11:37 <hpc> haskellnoob: a good start might be to return Maybe Int
06:11:42 <ubuntuhaskell> ok. Thank you.Have a nice day. :)
06:11:44 <hpc> or accept an infinite list
06:12:21 <hpc> returning -1 is an icky thing to do in a language like haskell
06:12:29 <ddarius> haskellnoob: Given xs, find ys and zs such that xs == ys ++ zs and sum xs == sum ys or return Nothing if there is no such splitting.
06:13:22 <thecod> sum ys == sum zs
06:13:28 <ddarius> thecod: Yse.
06:13:39 <hpc> :t zip
06:14:14 <ddarius> This even captures the, at first arbitrary seeming, condition that "the empty list is assumed to contain zero."
06:14:32 <hpc> \xs -> zip (inits xs) (tails xs)
06:14:39 <hpc> ^ would be a good place to start
06:14:59 <zygoloid> or... given xs, find ys (left partial sums) and zs (right partial sums), then find index i such that ys and zs agree at position i.
06:15:07 <aristid> hpc: zip <$> inits <*> tails
06:15:09 <ddarius> hpc: From there it's just a straightforward filter for a brute-force solution.
06:15:10 <haskellnoob> ddarius, hpc: thanks
06:15:27 <haskellnoob> let me think these over. thank you all.
06:15:27 <hpc> aristid: ooh, that tricky function applicative
06:16:00 <aristid> hpc: trickay
06:16:13 <hpc> tricksy functionses
06:16:19 <hpc> they wants my precious
06:16:45 <category> f o g
06:16:49 <category>   ^ the ring
06:17:03 <ddarius> Looks like an o to me.
06:17:11 <category> ddarius: Throw it on a fire, I guess.
06:17:14 <hpc> looks like °
06:17:27 <ddarius> ∘ is what people are going for
06:17:44 <hpc> whoa, putty accepts my unicode input now?!
06:17:58 * hpc :D
06:18:14 <hpc> oh, it doesn't
06:18:18 <hpc> that just happened to be ascii
06:18:20 <hpc> :(
06:20:02 <Navigium> kfr: Don't expect your rootkit to be of any use. I chose the github version because I have git installed, but not 7zip ;)
06:20:23 <ClaudiusMaximus> > let l = [1,2,3,0,1,3,2] in True `elemIndex` zipWith (==) (scanl (+) 0 l) (scanr (+) 0 l)  -- was my effort, though they left..
06:20:29 <parcs> hpc: by default putty doesn't accept unicode. have you configured its settings?
06:20:42 <hpc> parcs: a bit
06:20:49 <cdsmithus> ClaudiusMaximus: Lambdabot is asleep
06:20:49 <hpc> just enough for `tree' to work
06:20:54 <hpc> and my numpad
06:20:59 <parcs> ah
06:21:10 <ClaudiusMaximus> so should i be; but alack, the sun arose
06:21:40 <thecod> ClaudiusMaximus: nice!
06:21:45 <zygoloid> ClaudiusMaximus: i got this: findIndex id . uncurry (zipWith (==)) . (scanl (+) 0 &&& tail . scanr (+) 0)
06:21:52 <hpc> parcs: you wouldn't happen to know off the top of your head what setting to change?
06:22:10 <thecod> who says haskell code is obtuse?
06:22:28 <hpc> thecod: everyone
06:22:29 <hpc> :D
06:22:37 <jix> is there something that can autogenerate newtype wrapping code for me when the functions I want to wrap aren't member of some class?
06:22:38 <thecod> abstruse
06:22:40 <thecod> rather
06:22:55 <parcs> hpc: no, i'm afraid not. i haven't used putty in a while
06:23:00 <hpc> ah, k
06:23:43 <ddarius> jix: Yes.
06:25:08 <zygoloid> findIndex id . liftM2 (zipWith (==)) (scanl (+) 0) (tail . scanr (+) 0)
06:25:48 <Saizan> jix: related http://hackage.haskell.org/packages/archive/newtype/latest/doc/html/Control-Newtype.html
06:27:52 <jix> Saizan: I want to use a newtype to hide the implementation of something but still exposing most of the operations of the original type. Afaics this won't help me
06:28:10 <hpc> jix: make the newtype a functor
06:28:21 <hpc> er
06:28:27 <jix> hpc: that makes no sense
06:28:27 <hpc> sort-of functor, rather
06:28:39 <jix> because I just have Type not Type a
06:28:41 <hpc> so say you have
06:28:47 <hpc> newtype X = X Y
06:28:59 <hpc> apply f (X y) = X . f
06:29:02 <hpc> er
06:29:07 <hpc> apply f (X y) = X . f $ y
06:29:14 <jix> hpc: that doesn't work for Y -> a
06:29:44 <hpc> apply f (X y) = f y -- this then
06:29:49 <hpc> the idea is what's important :P
06:29:49 <jix> hpc: I have some type without Ord because ordering has no meaning... But the wrapped type has Ord and I want to supply efficient sets
06:30:00 <jix> hpc: I have both
06:30:29 <jix> so I'm going to write a FooSet (IntSet alike) that is a Set for Foos
06:30:50 <jix> but basically it's just a Set for Bars (if i have newtype Foo = Foo Bar)
06:31:09 <jix> and I don't feel like manually wrapping/unwrapping all of Data.Set
06:31:28 <jix> ddarius: And what would that be?
06:33:04 <ddarius> jix: I misread your question originally, but I'm pretty sure that DriFT/derive can be made to do this rather easily if they don't already do it.
06:33:56 <jix> ddarius: thanks, will have a look at it.
06:54:07 <mm_freak> can i safely transfer .cabal and .ghc to other computers, as long as the architectures are the same?
06:54:32 <mm_freak> reason is:  i want to do package installations on my fast home host, while developing on my slow mobile host
06:54:42 <Jafet> "Well, can you?"
06:56:48 <parcs> can anyone point to me to an example of creating a relation for haskelldb?
06:57:08 <parcs> the documentation is very obtuse
07:02:58 <kfr> <Navigium> kfr: Don't expect your rootkit to be of any use. I chose the github version because I have git installed, but not 7zip ;)
07:02:59 <kfr> Curses.
07:03:27 <paczesiowa> what's the status of yhc->js (or any other way to embed haskell in js)?
07:09:06 <roconnor> is it fair to say that writing a type for a function only constrains the extensional behaviour of the function and gives no intensional restrictions?
07:09:33 * roconnor is thinking of conor's comment that a type is a starting point for program refinement)
07:10:03 <Saizan> where is it?
07:10:16 <roconnor> in my IRC logs
07:11:44 <roconnor> <pigworker>       type classes provide an example of program inference
07:11:45 <roconnor> <pigworker>       types, as a high level document of structure are a good cue to program generation
07:11:47 <roconnor> <pigworker>       the people who talk of types solely in terms of error-policing are selling them massively short
07:11:48 <roconnor> <pigworker>       The text under a type signature need not be a mechanism in itself: it need merely describe the refinement of the type to a mechanism.
07:12:42 <roconnor> I've been thinking recently that ideally types provide the extentional properties (the what) of your function, and then you have to refine it further to give the intenstional properties of your function (the how)
07:12:56 <roconnor> (here I'm thinking of powerful dependent type systems)
07:13:06 <Saizan> sounds fair to me
07:13:17 <roconnor> this also explains why types make good documentation
07:13:33 <roconnor> you don't generally care about the intentional properties of functions to use them
07:13:38 <Saizan> of course, sometimes the what is so specific that there's not much choice on how
07:13:47 <roconnor> yep
07:14:30 <roconnor> of course types also don't always constrain the extenstional properties of functions entirely either
07:14:36 <Saizan> i find that i often care about the strictness properties of a function, so maybe that should go into the types too :)
07:14:48 <thecod> it can
07:15:02 <thecod> there are type systems that can express strictness
07:15:34 <roconnor> Saizan: :)  I suppose that in Agda/Coq that issue dissappears
07:15:53 <thecod> roconnor: why?
07:16:02 <Saizan> roconnor: not entirely, in proofs at least
07:16:05 <dolio> It doesn't.
07:16:11 <roconnor> because you cannot pass partial values to functions since partial values don't exist
07:16:31 <dolio> Well, strictness by definition disappears, I suppose.
07:16:54 <Saizan> roconnor: open computation getting stuck on some neutral term is a very similar issue though
07:16:55 <thecod> You could imagine a lazy Coq or a lazy Agda
07:17:03 <dolio> However, what you really want is information about evaluation order.
07:17:27 <Saizan> and then there's memory/speed for when you execute the programs.
07:17:36 <roconnor> thecod: conversion in coq is lazy
07:17:44 <dolio> Agda does use lazy evaluation.
07:17:56 <thecod> So there you have it :)
07:18:00 <dolio> But it's (intended to be) total.
07:18:20 <thecod> There is some work on using PTSses to mark strictness of certain arguments
07:18:22 <roconnor> but I don't think a strict coq/agda would even make sense
07:18:30 <thecod> actually it was on dead code elimination
07:18:40 <roconnor> if conversion were strict .. would it be transitive?
07:18:48 <thecod> ???
07:19:10 <thecod> yes
07:19:25 <Saizan> they are supposed to be strongly normalizing, so evaluation order should matter for type checking
07:19:26 <thecod> confluence guarentees that you can evaluate pretty much how you want
07:19:26 <dolio> Usually in total theories, evaluation order is irrelevant to results.
07:19:43 <Saizan> *shouldn't
07:20:05 <roconnor> Saizan: exactly ... though techinically Coq is only weakly normalizing.   Which is maybe why conversion is lazy
07:20:25 <thecod> roconnor: ah yes good point
07:20:42 <thecod> but this is more of a bug in the guardedness check than anything else
07:21:10 <roconnor> perhaps
07:21:36 <thecod> in fact it is possible to write non-weakly normalizing terms.
07:21:51 <thecod> They just hang at type-check-time
07:21:57 <roconnor> in Coq?
07:22:55 <thecod> yea the kernel needs to do unfolding to check the guard condition
07:23:19 <dolio> Is this related to the bad coinductive stuff?
07:23:28 <thecod> no it's even worse...
07:23:32 <dolio> Oh.
07:23:48 <thecod> coq tries to reduce terms before checking the guard condition
07:23:57 <dolio> Okay.
07:24:38 <thecod> back to the original question: It seems that there are type systems that strongly constrain the intentionnal behaviour of programms
07:24:49 <thecod> typically runtime, resource use
07:25:39 * roconnor would like to see a definition of a non-normalizing term in coq
07:25:44 <thecod> um
07:26:01 <thecod> here i'll try to find one
07:29:00 <roconnor> typically non-normalizing terms are used to prove false
07:29:28 <thecod> yes but these terms don't actually type-check
07:29:43 <thecod> coq tries to unfold constants when trying to show decrease
07:29:49 <thecod> and it's this unfolding that doesn't terminate
07:30:07 <Saizan> ah, ok, so it's just the typechecker being partial
07:30:16 <thecod> in a way yes
07:30:34 <thecod> it could also timeout after a second and just say that it doesn't pass the guard condition...
07:32:13 <thecod> well darn
07:32:23 <thecod> can't find a term that illustrates
07:32:33 <burp> > map log $ zipWith (-) (map (2^) [10,20..]) (map (10^) [3,6..])
07:32:33 <thecod> hope i'm not saying anything stupid
07:32:41 <roconnor> then I don't believe you. ;)
07:33:16 <roconnor> actually I kinda believe you
07:33:58 <thecod> ugh
07:34:07 <aristid> @let if' a b c = if a then b else c
07:34:09 <thecod> it was in a talk by Hugo on the guard condition
07:34:16 <aristid> DAMN
07:34:19 <aristid> no lambdabot
07:34:23 <aristid> geheimdienst: I BLAME YOU
07:34:30 <thecod> hehe
07:42:58 <thecod> aha!
07:43:20 <thecod> Fixpoint F n := let x := F n in 0.
07:43:30 <thecod> Eval compute in F 0.
07:43:39 <thecod> oh well...
07:45:09 <roconnor> thecod: isn't that the standard weakly but not strongly normalizing term?
07:45:45 <thecod> pretty much
07:45:53 <thecod> i therefore redact my previous statement
07:46:04 <roconnor> hmm
07:47:28 <thecod> so my final statement is: if subject reduction holds, then typing can only express "extentional" properties
07:47:30 <thecod> in a sense
07:48:10 <thecod> but there are properties that can be considered "intentionnal" and that may be expressed by a suitable type system
07:48:23 <thecod> e.g. memory usage
07:48:32 <thecod> though Coq can't say much about that
07:48:35 * hackagebot graph-rewriting 0.5.1 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.5.1 (JanRochel)
07:48:39 <thecod> (except maybe "finite")
07:48:48 <roconnor> thecod: interesting
07:54:13 <jacobian> yeah, in order to type check, using reduction, you need to have some rules to control unfolding. 
07:54:31 <jacobian> I've a system that applies something like a guardedness condition to supercompiled terms. 
07:54:38 <jacobian> You first check that weak soundness. 
07:54:47 <jacobian> Then you have a controlled unfolding and folding
07:54:55 <jacobian> Then you check to see if the term is total
07:55:45 <jacobian> You can't have uncontrolled reduction prior to type-checking for somewhat obvious reasons :) 
07:56:21 <thecod> what does type-checking guarentee?
07:56:45 <aristid> thecod: that the types check
07:57:49 <thecod> aristid: nice :)
07:57:55 <jacobian> ;) 
07:58:06 <thecod> jacobian: how is termination guarenteed concretly?
07:58:32 <jacobian> I end up with a cyclic proof that has cycles guarded with constructors, or with structural recursion. 
07:58:53 <jacobian> It can convert some programs which do not meet the guardedness condition into ones that do. 
07:59:16 <jacobian> The cyclic proof can be "reified" to a new program with the same semantics. 
08:01:08 <thecod> i don't get it i'm afraid
08:01:24 <thecod> jacobian: how do you proceed on recursive calls?
08:01:26 <jacobian> I'll get a picture
08:02:21 <thecod> thx
08:05:02 <jacobian> yarg, my server is down
08:05:11 <thecod> hehe
08:05:17 <thecod> just link to the paper...
08:06:46 <jacobian> http://webcache.googleusercontent.com/search?sclient=psy&hl=en&q=cache%3Awww.evil-wire.org%2F~jacobian%2FProductive.pdf&aq=f&aqi=&aql=&oq=&pbx=1
08:07:33 <jacobian> I'm working on a revised version of it right now
08:08:58 <Phantom__Hoover> What happened to lambdabot???
08:08:58 <thecod> on a sunday?
08:09:06 <Phantom__Hoover> He was my FRIEND
08:09:12 <thecod> Phantom__Hoover: crashed
08:09:14 <geheimdienst> she is a she
08:09:35 <Phantom__Hoover> thecod, how?
08:10:12 <aristid> Phantom__Hoover: geheimdienst crashed it
08:10:17 <aristid> *crashed her
08:10:20 <Phantom__Hoover> geheimdienst, WHY
08:10:47 <aristid> he did not know that transposing a concatenated cake would crash her
08:10:59 <geheimdienst> aristid: i'm never gonna live that down, am i?
08:11:44 <aristid> geheimdienst: once lambdabot is back, everybody will forget it
08:12:23 <thecod> jacobian: thanks for the paper
08:12:47 <Veinor> wait, why does transpose $ concat cake crash \bot?
08:13:10 <Phantom__Hoover> What is cake?
08:13:23 <geheimdienst> veinor, that's not the issue. the issue is that geheimdienst is an evil partypooper to all of the haskell world
08:13:25 <Veinor> oh, concat $ transpose
08:13:41 <monochrom> strange questions you people ask.
08:13:58 <thecod> jacobian: not sure what the problem is with sumlen though
08:14:01 <aristid> monochrom: bring her back!
08:14:09 <thecod> not big on codata...
08:15:21 <Veinor> Phantom__Hoover: it's an array of 42 relatively short strings
08:15:27 <Veinor> er, list
08:30:05 <jacobian> csucc (x + (sumlen xs)
08:30:41 <jacobian> Call to a recursive function which has an application elimination step. 
08:31:10 <jacobian> er implication elimination 
08:31:29 <thecod> um
08:31:34 <thecod> i don't see the problem
08:31:45 <thecod> sumlen is called on xs, which is guarded
08:31:54 <thecod> and the whole term is guarded by csucc
08:32:13 <jacobian> but is the result of the application guarded. 
08:32:44 <jacobian> x + , could potentially consume any infinite number of constructors from sumlen
08:32:59 <jacobian> It obviously doesn't, but you can't tell that without looking into +
08:33:04 <thecod> ah wait yea i get it
08:33:48 <thecod> um
08:33:50 <thecod> no
08:34:01 <thecod> + is productive if it's arguments are productive
08:34:10 <thecod> x is productive by hypothesis
08:34:22 <thecod> and sumlen xs is productive by coinductive hypothesis
08:34:56 <thecod> or is it?
08:35:45 * hackagebot xmlhtml 0.1.0.1 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.0.1 (ChrisSmith)
08:35:47 * hackagebot snap-core 0.4.0 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.4.0 (GregoryCollins)
08:37:01 <jacobian> sumlen xs is productive by coinductive hypothesis if all cycles involving sumlen have a constructor guarding them. 
08:37:45 * hackagebot snap-server 0.4.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.4.0 (GregoryCollins)
08:37:48 * hackagebot heist 0.5.0.1 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.5.0.1 (DougBeardsley)
08:37:49 <thecod> ah ok
08:37:50 * hackagebot snap 0.4 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.4 (GregoryCollins)
08:37:57 <thecod> i get it now
08:37:59 <thecod> thanks
08:38:28 <jacobian> we wouldn't want f = f to pass 
08:38:36 <jacobian> So there has to be something getting larger
08:38:45 <thecod> ok
08:39:07 <thecod> How does your method compare to the size-types approach
08:39:16 <tibbe> dcoutts: ugh, hackage rejects latest network due to a `other-extensions: NondecreasingIndentation` behind a `if impl(ghc >= 7.0.2)`
08:39:17 <thecod> i see you are aware of Andreas' work
08:39:21 <tibbe> dcoutts: that doesn't seem right
08:39:22 <jacobian> I've been told that the size-types approach is better
08:39:32 <tibbe> 400 Error in upload
08:39:32 <tibbe> Unknown extensions: NondecreasingIndentation
08:39:33 <jacobian> I need to look into how they compare more closely 
08:39:35 <tibbe> dcoutts: ^^
08:39:57 <thecod> The size-types approach needs brains to figure out the annotations
08:40:18 <thecod> if you are "brainless" then i'm not convinced it's much different
08:40:59 <thecod> i mean if you infer the size-types using some standard fix-point technique
08:41:08 <thecod> in fact the approaches are quite similar
08:47:11 <elliott> who killed lambdabot? :(
08:47:22 <aristid> elliott: geheimdienst
08:47:28 <elliott> geheimdienst: I HATE YOU
08:47:31 <elliott> that is all
08:47:38 <elliott> i have to like, tab to my browser, to hoogle now
08:47:41 <elliott> it's painful
08:48:03 <aristid> elliott: you can install hoogle locally
08:48:21 <elliott> well... maybe :P
08:48:47 <Palmik> Weird, I have Parsec 3.1.1 but calbal is says, when resolving dependecies for other packages, that "2.x version was selected instead" what does that mean and how do I select the 3.1.1 version? :D
08:49:01 <aristid> Palmik: use parsec3 instead.
08:49:25 <aristid> Palmik: when other packages want parsec 2, let them use it, though
08:49:41 <Saizan> Palmik: --constraint="parsec == 3.1.1"
08:49:56 <aristid> Saizan: ugh.
08:50:03 <Palmik> I installed parsec like this cabal install 'parsec >= 3.0'
08:50:15 <Palmik> Now I have installed parsec3
08:50:15 <Saizan> aristid: ?
08:50:21 <elliott> Palmik: it probably means that they requires Parsec 2, not Parsec 3.
08:50:27 <elliott> both can be installed at the same time so this is okay.
08:50:30 <Saizan> parsec3 is seen as a completely unrelated package
08:50:40 <Palmik> But I still get this http://codepad.org/y2CGYrzD
08:50:42 <aristid> Saizan: sure, but for his own stuff he can use parsec3
08:50:43 <elliott> parsec3 should arguably have been a different package, just for all the whiners :D
08:50:58 <aristid> Saizan: for other packages who use parsec without 1/2/3, let them use parsec 2.x
08:51:05 <elliott> Palmik: er. that is strange
08:51:19 <aristid> elliott: parsec3 IS a different package now
08:51:24 <elliott> oh, it is?
08:51:28 <aristid> yes
08:51:33 <elliott> what's it called, parsec3? :P
08:51:36 <aristid> yes
08:51:45 <elliott> heh
08:51:53 <Saizan> Palmik: use if --constraint="parsec >= 3" doesn't fix it, then run ti with --dry-run -v to see why it needs to use parsec-2.x
08:52:02 <Palmik> Ok
08:52:35 <Palmik> It seems ok for now with the  --constraint="parsec >= 3"
08:52:46 <Palmik> Thanks :)
08:52:57 <Saizan> np
08:53:47 <Saizan> cabal-install's contraint solver is not a complete one, so it needs such hints occasionally
08:55:06 <elliott> Saizan: integrate that fancy SMT thing into cabal-install!
08:55:11 <elliott> waht could possibly go wrnog!!!!!
08:55:38 <Saizan> that's probably the plan
08:55:50 <thecod> yea honestly it's a pretty good idea
08:56:00 <elliott> haha seriously?
08:56:12 <elliott> i'm going to become famous jokingly suggesting perfect solutions to problems
08:56:18 <Saizan> nah
08:56:34 <Saizan> it has been already discussed ages ago
08:56:41 <thecod> go ahead try P=NP
08:56:44 <Palmik> Does anyone know about some abstraction layer over HDBC where I would not have to write SQL queries as a string?
08:56:46 <elliott> well then i'm as smart as all those people combined obviously :)
08:57:07 <Saizan> not necessarily with that specific fancy SMT thing
08:57:24 <Saizan> the main concern is to keep error messages comprehensible
08:58:13 <Saizan> Palmik: there's haskelldb
08:58:19 <elliott> Saizan: just steal  
08:58:20 <elliott> erm
08:58:26 <elliott> Saizan: just steal apt's :P
08:58:35 <Saizan> apt is not complete either
08:58:43 <elliott> Saizan: it can solve sudoku. that's good enough.
08:58:56 <elliott> and the error messages are pretty simple
08:58:59 <Saizan> i'm pretty sure cabal-install can solve sudoku too :)
08:59:29 <Palmik> Saizan, looks just like what I was looking for :)
08:59:32 <Palmik> thanks
09:00:57 <thecod> Why does it have to be SMT?
09:01:02 <thecod> isn't SAT sufficient?
09:01:36 <aristid> thecod: if i understand it correctly, SMT is easier to use
09:02:02 <Saizan> isn't that like saying why do you want built-in naturals, isn't church encoding sufficient?
09:02:33 <dolio> No, Church encoding is not sufficient.
09:02:47 <Saizan> scott encoding?:)
09:03:35 <thecod> With which theory?
09:03:41 <thecod> linear arithmetic?
09:03:59 <Saizan> something for version ranges
09:04:12 <dolio> I don't know if there are well-behaved systems that type the Scott encoding.
09:07:52 <sm> morning all
09:08:25 <thecod> good evening all!
09:08:42 <hpc> mediocre afternoon, somebody!
09:09:13 <sm> I need to draw and move some sprites around, handle click events on them etc. Which lib would be the best starting point ?
09:09:40 <sm> works-on-my-machine is enough, this is just for prototyping
09:09:58 <hpc> sm: sdl?
09:10:47 <sm> I'm hoping for something higher level. I'm thinking FunGEn or graphics-drawingcombinators
09:10:54 <geheimdienst> html, jquery?
09:11:00 <sm> in haskell
09:12:53 * hackagebot network 2.3.0.2 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.2 (JohanTibell)
09:12:55 <nosila> hi, having a problem
09:12:59 <nosila> http://hpaste.org/43689/exercice
09:13:24 <nosila> my mediaAux funcition is returning an exception, *** Exception: r_Teste 2010 - 1.hs:26:0-114: Non-exhaustive patterns in function mediasAux
09:13:40 <nosila> > http://hpaste.org/43689/exercice
09:13:43 <sm> the target is an actionscript arrange-the-letters-to-make-a-word game, I want to prototype in haskell
09:13:51 <mauke> nosila: wrong
09:13:56 <sm> aha, graphics-drawingcombinators has some kind of Sprite
09:14:01 <mauke> nosila: your mediasAux function is returning an exception
09:14:15 <nosila> (just wanted to test if that works lol )
09:14:33 <nosila> mauke: yes, because of the argument 'total'
09:14:43 <mauke> nosila: dude
09:14:54 <mauke> nosila: it's not mediaAux returning an exception, it's mediasAux
09:15:17 <nosila> ***face palm***
09:15:26 <hpc> oh wow
09:15:31 <hpc> that was subtle
09:15:44 <nosila> FML
09:15:46 <nosila> anw, thansk ;)
09:15:51 <mauke> slightly less subtle if you notice that the "Aux" don't line up
09:17:25 <nosila> another thing
09:17:37 <nosila> how do i cast an int from the length to Float?
09:17:49 <hpc> fromIntegral
09:17:53 <nosila> OR, how do i cast the int to float when i need to do (/)
09:17:54 * hackagebot hakyll 2.4.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.4.2 (JasperVanDerJeugt)
09:17:55 <hpc> :t fromIntegral
09:18:00 <nosila> :t fromIntegral
09:18:05 <mauke> preflex: seen lambdabot
09:18:05 <preflex>  lambdabot was last seen on #haskell-blah 3 hours, 35 minutes and 26 seconds ago, saying:   "."
09:18:23 <mauke> nosila: you usually want Double, not Float
09:18:24 <hpc> ghci> :t fromIntegral
09:18:25 <hpc> fromIntegral :: (Integral a, Num b) => a -> b
09:18:39 <nosila> that's from a test
09:19:01 <nosila> hum, anw, how do i get the int to double then??
09:19:10 <mauke> fromIntegral
09:19:24 <nosila> lol kk gonna try it ;)
09:21:25 <nosila> damn.... was missing some ( ) <_<
09:22:24 <nosila> its working now
09:22:25 <nosila> http://hpaste.org/paste/43689/exercice_annotation#p43690
09:23:00 <nosila> mauke: do you know anyway to "optimize" that? with foldr perhaps
09:23:41 <BMeph> nosilla: mauke knows at least three ways. Lucky you, you now know mauke. You win! ;)
09:24:20 <nosila> LOL
09:24:29 <nosila> how can i do that then?
09:26:47 <BMeph> nosilla: Watch, listen and learn! :)
09:27:01 <mauke> medias [] = (0, 0, 0); medias xs = (sum mins / total, sum maxs / total, sum preps / total) where total = fromIntegral (length xs); (_, mins, maxs, preps) = unzip4 xs;
09:27:37 <byorgey> oooh, unzip4
09:32:07 <nosila> damn
09:32:09 <nosila> :t unzip4
09:32:24 <Wooga> hello, i am still trying to figure out how iteratees work. here i am trying to rise an exception after first line Iteratee get: http://paste.pocoo.org/show/333142/ ; but for some reason it rises only after second line. how do i fix that?
09:49:54 <nosila> http://hpaste.org/paste/43689/exercice_annotation#p43691
09:49:59 <dschoepe> If I want to use a generic programming library, e.g. syb, with another library that defines _a lot_ of data types but doesn't Typeable and Data for them, is there an easier solution than redefining all the missing instances with -XStandaloneDeriving?
09:50:03 <nosila> anyway of doing that in where total???
09:50:08 <dschoepe> *doesn't derive
09:50:16 <nosila> or i just need to do one more function for that?
09:51:13 <dschoepe> (I guess I could use TH in conjunction with haskell-src-exts, but that seems somewhat crude)
09:52:26 <maltem> nosila, what's the question?
09:52:35 <nosila> the total part
09:52:39 <nosila> where total | ....
09:52:59 <maltem> yeah, what's the question :p
09:53:03 <gwern> @wn fen
09:53:10 <nosila> it gives me a error,  parse error (possibly incorrect indentation)
09:53:21 <nosila> i think it's from that, was that supposed to work?
09:53:36 <maltem> it looks legit to me
09:54:02 <nosila> getting the error in the next line so i suppose it's from that but let me recheck
09:55:22 <nosila> dont i need ; there??
09:56:13 <rwbarton> you're missing an = after otherwise
09:56:42 <maltem> ah indeed
09:57:27 <nosila> true, true
09:57:28 <nosila> damn
09:57:29 <nosila> my bad
09:59:16 <aristid> preflex: seen lambdabot
09:59:17 <preflex>  lambdabot was last seen on #haskell-blah 4 hours, 16 minutes and 39 seconds ago, saying:   "."
09:59:31 <dschoepe> Is there a way to use TH to generate type class instances with -XStandaloneDeriving instead of having to define the methods myself?
10:00:02 <dschoepe> Dec doesn't seem to offer an appropriate constructor for that
10:00:30 <tibbe> congratz on the release guys
10:01:05 * hackagebot MonadCatchIO-mtl 0.3.0.2 - Monad-transformer version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-mtl-0.3.0.2 (DanielGorin)
10:01:52 <Wooga> why here: http://paste.pocoo.org/show/333142/ excpetion rises only after second line; not after first one?
10:03:08 <elliott> Is there a way to use Data.IntMap with a non-Int key? e.g. Int32.
10:03:15 <elliott> Or, is there a package somewhere on Hackage that can do this?
10:04:24 <copumpkin> elliott: there will be soon, but no
10:04:40 <elliott> copumpkin: how soon :)
10:05:09 <copumpkin> I think the sf hackathon
10:06:33 <Silvah> Let's assume that I've written a useful library. How can I submit it to Hackage?
10:07:12 <byorgey> dschoepe: yeah, looks like TH doesn't support standalone deriving yet
10:07:27 <byorgey> dschoepe: I tried using TH to parse one and got an empty declaration list
10:07:52 <dschoepe> byorgey: okay, thanks for checking
10:09:43 <geheimdienst> Silvah: i guess you'd need a hackage account, which i believe you can request via email
10:10:42 <beastaugh> Silvah: email Ross Paterson <ross@soi.city.ac.uk> to request a Hackage account
10:10:50 <beastaugh> username format is FirstnameLastname
10:17:39 <Silvah> Okay, thanks.
10:21:14 <dschoepe> If I want to add an import declaration with haskell-src-exts, do I really have to manually construct a SrcLoc for it?
10:21:38 <nosila> http://hpaste.org/43695/sd
10:21:52 <nosila> wth is wrong with the apenas2010? -.-"
10:22:03 <nosila> isnt that possible?
10:23:17 <doserj> nosila: indentation?
10:23:38 <nosila> parse error on input `apenas2010'
10:24:28 <doserj> remove the semicolons, align the apenas with total in the line above
10:25:00 <nosila> (had one thing worng)
10:25:04 <nosila> anw, is that even possible?
10:25:08 <doserj> also the (_, mins, maxs, preps)
10:25:10 <Philonous_> Is it acceptable to use foreign pointers to free unused resources or should I rather explicitly reap memory that is no longer in use?
10:25:39 <nosila> for that, didnt i had to have the apenas2010 in the mediasPro2010 function?
10:28:37 <nosila> http://hpaste.org/paste/43695/sd_annotation#p43696
10:28:38 <nosila> or that
10:29:19 <glguy> ((_,_,year),_,_,_)   this is how you know that it is time to define a new data type :)
10:30:24 <copumpkin> glguy++
10:30:24 <kmc> Philonous_, more context?
10:30:55 <kmc> glguy, yeah, it woud be so much nicer to write "Foo { fooDate = Date { dateYear = year } }" ;P
10:31:31 <doserj> nosila: http://hpaste.org/paste/43695/proper_indentation#p43697
10:32:27 <Wooga> is here anyone understanding Data.Iteratee iteratees?
10:32:46 <earthy> I have some idea of how they work and can be used.
10:33:05 <earthy> however, question 1: what version of the iteratee package?
10:33:13 <Wooga> 0.7.0
10:33:16 <earthy> ah
10:33:23 <earthy> I didn't progress pass 0.3.6
10:33:34 <Wooga> earthy: can you tell why here: http://paste.pocoo.org/show/333142/ excpetion rises only after second line, not after first ?
10:34:02 <Wooga> (guess not all changed since 0.3.6)
10:34:36 <glguy> Is lambdabot offline for good?
10:34:45 <earthy> wooga: the question has basically nothing to do with iteratees and everything with laziness
10:35:01 <Wooga> oh
10:35:06 <Philonous_> kmc: I'm writing on an interface to a library that has it's own String representation and uses some kind of reference counting for garbage collection, so I have to decrease the reference count when I'm done with the marshaled string, and I wonder whether it is a good idea to just put that part into a Foreign pointer and forget about it or if I should rather use some withString construct
10:35:08 <earthy> the value of abc is not forced until the putStrLn is evaluated
10:35:29 <earthy> plus, you don't seem to construct abc in a strict fashion
10:36:13 <geheimdienst> glguy: some complete dipweed crashed lambdabot earlier today. cale doesn't seem to be around to restart her
10:36:21 <nosila> doserj: what did you change? just the identation? 
10:36:34 <doserj> nosila: and the semicolons
10:36:38 <kmc> Philonous_, i'd go with ForeignPtr, in order to provide the simplest API to the user
10:36:52 <earthy> oh, another thing to note: enumFileLines == lines <$> enumHandle  (if I'm reading your code right)
10:36:54 <kmc> unless you are concerned about performance or about reclaiming that memory quickly
10:37:04 <Philonous_> The problem with foreign pointer seems to be that one could accidently hold onto them and thereby introduce leaks
10:37:14 <Philonous_> So maybe I will just go with both
10:37:14 * hackagebot Hipmunk 5.2.0.2 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.2 (FelipeLessa)
10:37:23 <kmc> Philonous_, yes, but that's the same as any other haskell value
10:37:33 <Wooga> earthy: i have to manualy catch expcetions from iteratee to perform output
10:37:34 <kmc> perhaps ForeignPtr is no simpler though, because the user will just use withForeignPtr anyway
10:37:43 <nosila> deserj: dont know why the f*** notepad++ put a "normal" tab in there instead of the spaces because here it was "well idented", i've just noticed that it wasnt in hpaste
10:37:48 <earthy> wooga: err, make that   enumFileLines hndl == lines <$> enumHandles hndl
10:38:31 <earthy> you want to output a log of the lines read, as they are read?
10:38:46 <nosila> deserj: any "secure" haskell IDE or wtv that only tab's with spaces? i'm having problems with notepad++, everytime i boot the PC it changes that setting dunno why
10:38:47 <Wooga> earthy: no, i want to make iteratee work in both ways
10:39:06 <Wooga> earthy: not only getting input from enumerator, but also makeing enumerator output something
10:39:37 <Philonous_> kmc:  No, the representation will be opaque one way or the other. But thinking about it I realize that it may be a bad idea to expose marshalling code in the first place. The user prolly never have to worry about how I represent strings in the library and only see haskell strings
10:39:38 <Wooga> earthy: i am writing brainfuck interpreter, which have to both read and print values
10:39:56 <Philonous_> should*
10:40:03 <earthy> I still don't see the problme
10:40:11 <doserj> nosila: I know nothing about windows editors
10:40:33 <nosila> kk ;)
10:40:34 <nosila> thanks
10:41:19 <earthy> mapIteratee can let you take the monadic values generated, and return them while generating output
10:41:52 <Philonous_> kmc:  Sorry to have bothered you with that, it may turn out to be a complete non-issue
10:41:53 <earthy> e.g. mapIteratee (\m -> do v <- m; putStrLn v; return v) 
10:42:13 <earthy> err, there's some {} missing there
10:42:38 <earthy> mapIteratee (\m -> do {v <- m; putStrLn v; return v})
10:42:42 <hpc> > do return 5; Just 5
10:42:51 <zygoloid> do you really need those braces?
10:42:56 <Wooga> earthy: well, let's start from begining: impure enumerator reads values from terminal and giving them to the iteratee. iteratee processes values and generates exceptions, which enumerator catches and prints to the terminal string contained in excpetion
10:43:09 <Wooga> *while iteratee stays pure
10:43:18 * hackagebot HipmunkPlayground 5.2.0.1 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.1 (FelipeLessa)
10:43:24 <earthy> um. right.
10:43:34 <earthy> so how do you build the impure enumerator? :)
10:43:58 <earthy> by factoring out the impurities into distinct pieces
10:49:53 <systemfault> :(
10:50:08 <Wooga> earthy: i still don't understand how to make my enumerator strict. also, <$> operator seems to be deprecated in current Data.Iteratee version and just missing
10:51:26 <geheimdienst> wooga, you can import Control.Applicative to get <$>
10:51:54 <geheimdienst> i'm pretty sure it's not deprecated, probably they just said, we don't our own thing in Iteratee, we'll use the standard one
10:55:50 <tarrasch> Hello, how's the easy way to define multiSplitRegularly :: Int -> [a] -> [[a]]. (like doing never-stopping splitAts)?
10:56:08 <Botje> look at Data.List.Split
10:57:44 <tarrasch> Botje, wow, a whole module dedicated to splitting, really bad hoogle doesn't know of it
10:58:04 <Wooga> earthy: btw, are you sure that this is laziness, not iteratee initial state?
10:58:24 <geheimdienst> tarrasch, if you happen to have missingH installed, you can also use that. it's in Data.List.Utils, iirc
10:58:44 <Botje> http://hackage.haskell.org/packages/archive/split/0.1.3/doc/html/Data-List-Split.html
10:59:42 <tarrasch> Thanks guys!
10:59:46 <cizra> Hello. I'm having difficulties with type signatures
10:59:49 <cizra> http://hackage.haskell.org/packages/archive/hsndfile/0.5.0/doc/html/Sound-File-Sndfile.html#v:readFile
11:00:02 <cizra> There's a function readFile :: (Sample e, Buffer a e) => FilePath -> IO (Info, Maybe (a e))
11:00:29 <cizra> When I just try to call it, ghc says it needs hints about what types a and e are
11:00:45 <Botje> so give it an explicit type
11:00:46 <cizra> So I tried to figure out I'd need something like this
11:00:49 <cizra>   (info, chunks) <- Sndfile.readFile "whistle.wav" :: IO (Sndfile.Info, Maybe (Double, Double))
11:00:51 <monochrom> yes, I would need hints too.
11:00:53 <Botje> or use it in a way that ghc can deduce it
11:01:15 <Botje> cizra: is there a Buffer Double Double instance?
11:01:20 <glguy> cizra: (Double, Double) probably isn't a   (Sample e, Buffer a e) => a e
11:01:21 <monochrom> I don't think you have an instance of "Buffer Double Double"
11:01:41 <cizra> umm
11:01:45 <glguy> Sample instances: Double Float Word16 Word32
11:01:53 <monochrom> more likely "Buffer BysteString Double"
11:01:54 <cizra> *nod* That much I figured out, about Sample
11:02:13 <Saizan> you'd need Buffer ((,) Double) Double actually
11:02:20 <glguy> For concrete instances see for example the hsndfile-vector package http://hackage.haskell.org/package/hsndfile-vector.
11:03:01 <cizra> Ahh! Examples!
11:03:02 <glguy> The 'a' in that type signature has kind *->*
11:03:13 <monochrom> oops
11:05:05 <cizra>     Illegal signature in pattern: BV.Buffer Double
11:05:06 <cizra>         Use -XScopedTypeVariables to permit it
11:05:23 * hackagebot HipmunkPlayground 5.2.0.2 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.2 (FelipeLessa)
11:05:39 <cizra> Hmm, I'll try to move the type out of the pattern
11:06:54 <cizra> nope
11:07:05 <Stevethepirate> hello
11:07:09 <cizra> hi
11:07:20 <Stevethepirate> how are ya'll?
11:07:46 <cizra> I'm great, I got my hello world working!
11:08:06 <cizra> Thanks Botje, glguy and others!
11:08:13 <Botje> have fun!
11:10:37 <Stevethepirate> This is fun
11:10:48 <Stevethepirate> I wish other languages had this
11:10:53 <Stevethepirate> would be great
11:11:08 <ion> This?
11:11:31 <Stevethepirate> ya
11:11:32 <cizra> c++ has this!
11:11:35 <Stevethepirate> the try haskell
11:11:44 <Stevethepirate> the lessons and such
11:12:05 <ion> “Other languages” do have it.
11:12:06 <aristid> cizra: and it's a pointer
11:12:18 <Stevethepirate> I have never seen it
11:12:30 <ion> http://tryruby.org/
11:12:30 <aristid> ghci has it
11:13:03 <aristid> you can use it to get the value (and monomorphic type) of the last expression
11:13:23 <cizra> aristid: excusi moi? Are you talking about C++ or what?
11:13:36 <aristid> cizra: no, ghci
11:13:41 <elliott> I feel this an appropriate time to mention that the Haskell record system is indescribably terrible.
11:13:55 <Veinor> ho w so?
11:13:57 <Stevethepirate> i was hoping for something like c
11:14:02 <zygoloid> python underscores the feature
11:14:12 <ion> elliott: That’s well-known. :-)
11:14:23 <elliott> ion: yes, just checking that nobody's forgotten
11:14:30 <elliott> while i stare at my code dreading having to write the next function
11:14:33 <ion> OTOH i’d say it’s better than Erlang’s record system. ;-)
11:14:35 <elliott> :(
11:14:38 <Veinor> what exactly is wrong with record syntax?
11:15:52 <elliott> Veinor: not just the syntax
11:16:13 <elliott> the fact that it defines accessor functions but /writing/ is almost impossible without the stupid special syntax that makes it necessary to write verbose, ugly, non-point-free functions, etc...
11:16:20 <geheimdienst> everybody has bones to pick with the records system
11:16:28 <Stevethepirate> i have a question, there is an empty set automatically included in ['a','b']  ??
11:16:29 <elliott> all my bones pick the record system :)
11:16:37 <elliott> Stevethepirate: huh?
11:16:45 <Stevethepirate> i type   
11:17:06 <Stevethepirate> 'a' : 'b' : [] == ['a','b']       
11:17:09 <Stevethepirate> and that equals true
11:17:32 <ion> Yes, the latter is syntactic sugar for the former.
11:17:47 <Stevethepirate> ok, so there is an empty set in the second form too
11:17:48 <elliott> Stevethepirate: ['a','b'] is the same as:
11:17:51 <elliott> 'a' : ('b' : [])
11:17:53 <elliott> one, these are lists, not sets
11:17:57 <Stevethepirate> ok
11:18:00 <Stevethepirate> so an empty list
11:18:02 <elliott> Stevethepirate: what a:b means is "a, followed by the elements in the list b"
11:18:03 * zygoloid suggests: class Accessor (<->) where fromLens :: (r -> a) -> (a -> r -> r) -> (r <-> a)
11:18:05 <jix> Stevethepirate: First, these are lists not sets. A list consits of a first element, called head, and the rest, called tail. A list ends if the tail is the empty list
11:18:10 <elliott> so it's 'a', followed by 'b', followed by no more elements
11:18:12 <elliott> so it's ['a','b']
11:18:18 <Stevethepirate> ok
11:18:42 <geheimdienst> don't worry about that "[]" too much. you could also write 'a' : ['b'] if you want
11:18:57 <Stevethepirate> ok
11:19:02 <Stevethepirate> this is very similar to lisp
11:20:05 <edwardk1> preflex: xseen copumpkin
11:20:05 <preflex>  copumpkin was last seen on freenode/#haskell 49 minutes and 42 seconds ago, saying: glguy++
11:20:13 <geheimdienst> Stevethepirate: yes, it is a similarity
11:21:00 <dolio> @karma glguy
11:21:24 <edwardk1> zygoloid: abstracting over fclabels/accessor?
11:21:56 <kuznero> Good day!
11:22:59 <kuznero> Have a question regarding IO... I'm quite a newby in Haskell and cannot understand why my program is not running as I expect...
11:23:15 <kuznero> promptLine :: String -> IO String
11:23:15 <kuznero> promptLine prompt = do
11:23:15 <kuznero>     putStr prompt
11:23:15 <kuznero>     getLine
11:23:15 <kuznero> main = do
11:23:16 <kuznero>     name <- promptLine "Enter your name: "
11:23:18 <kuznero>     putStrLn ("Hello, " ++ name)
11:23:55 <kuznero> Problem is that when I run it I don't see prompt "Enter your name"... but instead it tries to get input right a way... and then does the rest.
11:24:01 <kuznero> Can somebody help me with that?
11:24:21 <args0> I am new to Haskell and functional programming, a student studying the material, I need help in solving an exercise, mention me if you can help, thanks
11:24:21 <ben> Output is line-buffered by default, flush it explicitly
11:24:38 <kuznero> Can you show me the code example, please?
11:25:00 <geheimdienst> kuznero: have you tried sayign putStrLn instead of putStr?
11:25:22 <kuznero> Nope, does not seem to be conceptually different
11:25:37 <dankna> hFlush stdout
11:25:57 <Botje> kuznero: you are running into buffering issues. print a newline or flush explicitly
11:26:14 <sbahra> Internally, output will be buffered on a line by line basis or up to a certain number of bytes.
11:26:16 <geheimdienst> yes, but it avoids the line-buffering problem you've been having. text will only show up once the line is complete.
11:26:45 <args0> kuznero: can i share links here?
11:26:54 <ion> stevethepirate: The graph in http://en.wikipedia.org/wiki/Linked_list might be helpful. Think of [] as what is represented as ☒ and : as the operator that given 12 and (99:(37:☒)) returns 12:(99:(37:☒)).
11:27:12 <args0> kuznero: sorry i thought you were addressing me, never mind
11:27:23 <kuznero> args0: ok
11:27:59 <jonkri> i'm thinking about how i would do integration testing on my haskell app... does it differ from other programming languages?
11:28:12 <kuznero> Thanks, gents! Will digg into flushing buffers :)
11:28:42 <args0> I'd like some help solving this please: http://pastebin.com/SWDyfwds
11:29:45 <jacobian> How do I get -fglasgow-exts to be permanent?  Is there a .ghci or something
11:31:50 <Stevethepirate> why do you have to say     map toUpper "Chris"    and not just  toUpper "Chris"      Does the map tell toUpper that you aren't just dealing with a character but with a string?
11:32:00 <dankna> that is precisely correct
11:32:05 <Botje> Stevethepirate: yes. toUpper only works on Chars
11:32:23 <dankna> a string is a list of chars, not just conceptually but actually; String is a synonym for [Char]
11:32:25 <geheimdienst> (a Char being one single letter)
11:32:33 <dankna> map takes a function that operates on one thing and applies it to each thing in a list
11:32:45 <Stevethepirate> nice'
11:33:04 <Stevethepirate> and "chris" == ['c','h','r','i','s']
11:33:13 <dankna> correct
11:33:29 <Stevethepirate> sweet
11:33:41 <Stevethepirate> and ('c','h')  is a tupple
11:34:18 <nosila> Anyway to have a data comparable to another data of the same "type" and comparable to Int??
11:34:20 <glguy> args0: Do you have a specific question about that?
11:34:30 <lispy_> jacobian: yes there is and yeah that's how you'd make it permanent.  But....I wouldn't want every extension on all the time.
11:34:51 <lispy_> jonkri: I'm not sure.  We use hudson + cabal-
11:34:56 <lispy_> jonkri: I'm not sure.  We use hudson + cabal-dev at work for that
11:35:27 <elliott> DON'T YOU MEAN JENKINS, sorry, had to offer my totally useless input there
11:35:32 <args0> glguy: I have no idea how to start, I should satisfy all the rules, do you think its simple?
11:35:47 <Botje> nosila: you could use a hash function
11:36:03 <lispy_> elliott: yeah, I guess hudson became jenky
11:36:09 <elliott> totally jenksome
11:36:10 <nosila> explain please
11:38:29 <jonkri> lispy_: thanks :)
11:39:12 <pumpkin> edwardk1: you called?
11:39:31 <lispy_> jacobian: usually for ghci you just want things like no monomorphism and maybe a few other things like overloaded strings
11:41:37 <edwardk1> pumpkin: i dashed together a vector library as part of my work on the representable tries package, then realized i'd basically reinvented vector-static with some extra instances
11:41:46 <pumpkin> hah
11:42:07 <edwardk1> somewhat torn. thinking about just using that instead because of the ability to piggyback on vector's goodness
11:42:33 <edwardk1> but i can't quite get there orphan free without compromising the 98'ness of some packages =/
11:42:53 <djahandarie> Does anyone maintain vector-static? I recall it being too annoying to maintain due to vector always updating or something like that
11:42:56 <pumpkin> oh well, if it helps, I consider vector-static a failure
11:43:08 <edwardk1> why so?
11:43:12 <pumpkin> I made it and then jmcarthur and Saizan made some changes
11:43:34 <pumpkin> it's a pain to do anything meaningful with because you need to prove all sorts of basic properties about naturals and operations over them
11:43:39 <pumpkin> I tried writing some trivial algorithms on it
11:43:45 <pumpkin> with the new typenats it'll be quite nice
11:43:49 <pumpkin> but until then it's a real pain
11:44:03 <lispy_> djahandarie: Vector slowed down didn't it?
11:44:34 <djahandarie> Perhaps, I dunno. :P
11:44:54 <djahandarie> And I can't check either since hackage stopped loading for me again! ;_;
11:45:08 <edwardk1> basically i was working with my representable tries, but wanted to fix up the representations of integers, which looked a bit like conal's old memotrie instances prior to this. sadly those instances reify Ints as a [Bool] — but there are lots of unused entries in that mapping, which cause it to pay for comparing unused slots
11:46:00 <edwardk1> so i added a vector type, with given length and a trie for the vector, but then the vector themselves can be viewed as a trie of Data.Fin for the same bound as the vector.
11:46:14 <edwardk1> this lets me use them to memoize Enum's, etc.
11:46:14 <zygoloid> edwardk1: yeah, as a backend-agnostic class for the compiler to target
11:46:48 <edwardk1> zygoloid: sexy =)
11:47:34 * hackagebot wai-handler-devel 0.2.0.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.2.0.1 (MichaelSnoyman)
11:48:16 <edwardk1> hrmm i wonder if there is a more efficient representation of those by dualizing the nicer form of MonadState i use in functorial.
11:48:36 * hackagebot wai-handler-webkit 0.2.0 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-0.2.0 (MichaelSnoyman)
11:48:38 * hackagebot warp 0.3.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.3.2 (MichaelSnoyman)
11:49:35 <edwardk1> in functorial (a scala fp lib) my MonadState class is represented by a single function state :: s -> (a, s) — which provides the embedding of the basic monad action, this is nicer than, say, get, put and/or modify, because it doesn't require the use of the monad to glue together any or all of those operations
11:49:53 <edwardk1> and lets you use state actions even in an applicative context.
11:49:58 <nosila> hey, i have a function that returns Maybe a data i created, or Nothing
11:50:09 <nosila> :r
11:51:07 <aristid> edwardk1: what do you think about the fact that the next version of scala is said to have dynamic method lookup? :)
11:51:40 <edwardk1> i wonder if a similar 'store' function makes sense for the idealized ComonadStore class
11:51:42 <elliott> does anyone actually use data-accessor? :)
11:51:46 <elliott> i think it might be the solution to my problems
11:51:59 <edwardk1> elliott: i've used both it and fclabels in the past
11:52:01 <nosila> now i dont know how i'm supposed to use that in some functions that return IO ..
11:52:15 <elliott> edwardk1: which do you prefer? my current problem is that modifying fields in the state monad is an unholy pain
11:52:30 <edwardk1> data-accessor has fewer annoying dependencies
11:52:34 <elliott> so I want to try out one of these fancy accessor packages
11:52:40 <edwardk1> fclabels needlessly drags in mtl
11:52:52 <edwardk1> while accessor uses the transformers
11:52:56 <elliott> mm
11:53:07 <elliott> I'd prefer to stay without any such magic, but I doubt this code is gonna get any uglier without one of them.
11:53:13 <edwardk1> which is compatible with the mtl but doesn't shut the doors to using it with packages that are silly and use monads-tf
11:53:27 <edwardk1> they really clean up code
11:53:41 <edwardk1> i find them very nice to use when dealing with big composite state monads
11:53:56 <elliott> it's not a very big composite -- only two fields
11:54:04 <elliott> maybe I'll just write the put/modify functions manually
11:54:34 <edwardk1> i tend to make something like class HasFoo t where t :: Accessor t Foo
11:55:00 <edwardk1> then take whatever accessors i build and build a set of them that are composed with the HasFoo class's member
11:55:11 <edwardk1> er where foo :: Accessor t Foo, not t :: ;)
11:55:33 <dankna> there's also StateVars, the one used by the OpenGL binding.  it seems nice and terse...
11:55:37 <edwardk1> this lets me pass in big composite states
11:56:14 <edwardk1> dankna: those are very io-centric though
11:56:24 <dankna> that's true
11:56:58 <edwardk1> copumpkin: i'm surprised you didn't add a nice induction principle to your vector-static stuff anyways
11:57:09 <dolio> roll :: (s -> (a, s)) -> m a, unroll :: w a -> (s, s -> a)
11:57:13 <pumpkin> I was going to, but got frustrated with it :P
11:57:16 <edwardk1> class IsNat n where ind :: f Z -> (forall m. IsNat m => f m -> f (S m)) -> f n
11:57:17 <pumpkin> I had lots of nice plans for it
11:57:32 <edwardk1> *nods*
11:58:35 <djahandarie> newtype Rick a = Roll { unroll :: Rick a -> a }; y f = (\x -> f ((unroll x) x)) (Roll (\x -> f ((unroll x) x)))
11:59:26 <Saizan> pumpkin: n-ary hoas->debrujin seems to require a newtype, though since one would mostly use the variables as arguments to some application operator it might not be that bad?
11:59:49 <pumpkin> how do you mean?
12:00:44 <elliott> how long until \bot is back :(
12:01:48 <aristid> lispy_ runs lambdabot, right? or am i mistaken?
12:01:55 <pumpkin> Cale, on lispy's machien
12:02:45 <djahandarie> Someone should hack in some restart code in lambdabot
12:03:40 <silver> this is guilt talking
12:03:48 <silver> :-)
12:04:27 <lispy_> silver: what I really need is someone I trust to volunteer to run lambdabot :)
12:05:01 <Saizan> pumpkin: i mean that in forall (\x y -> ..) x and y could be of type Var n where newtype Var n = Var (forall m. Leq (S n) m => Expr m), so you can't use them directly as Expr's
12:05:02 <djahandarie> Cale does it well, it's not like he can be here 24/7
12:05:14 <pumpkin> Saizan: oh I see
12:05:23 <geheimdienst> while true; do lambdabot; end
12:05:29 <geheimdienst> ;)
12:05:54 <Saizan> pumpkin: but if you have a canonical consumer for such variables it could manage the unwrapping
12:06:02 <pumpkin> yeah
12:06:58 <lispy_> geheimdienst: that would work as a script, but the maintainer also needs to keep lambdabot up to date with patches, make sure the processes haven't gone rogue (happens more often than it should), and so on
12:08:48 <pumpkin> Saizan: I'll play with the idea in a bit :)
12:09:23 <elliott>     No instance for (Applicative (StateT Foo IO))
12:09:31 <pumpkin> fucking applicative
12:09:33 <elliott> ಠ_ಠ
12:10:24 <elliott> how did geheimdienst break \bot anyway :P
12:11:05 <geheimdienst> i said something like "concat $ transpose cake"
12:11:20 <geheimdienst> i still don't know what's so bad about it
12:12:39 * hackagebot yesod-examples 0.7.0 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.7.0 (MichaelSnoyman)
12:12:57 <elliott> geheimdienst: :D
12:13:11 <elliott> what are the Applicative things for monads again?
12:13:14 <elliott> or functors i guess
12:13:16 <elliott> well, no, monads
12:15:46 <parcs> ap? return? liftM*?
12:16:05 <jacobian> What do you call a datastructure that tells you how to walk down a tree data structure? 
12:16:07 <aristid> ap and liftM suffice
12:16:16 <jacobian> And is that somehow related to derivatives 
12:16:34 <aristid> well, maybe return is needed too
12:16:36 <aristid> not sure
12:17:15 <pumpkin> aristid: you need return for pure
12:17:35 <aristid> pumpkin: but pure is needed only relatively rarely, i think
12:17:42 <pumpkin> really?
12:17:51 <aristid> most of the time i use Applicative only like liftM*
12:18:17 <Philonous_> jacobian: Maybe you mean a zipper?
12:18:25 <pumpkin> I guess
12:18:31 <pumpkin> that's the reason behind edwardk1's Apply
12:19:19 <cizra> How do I convert a Vector into CArray? 
12:19:43 <pumpkin> cizra: Vector.Storable?
12:20:15 <cizra> umm
12:20:33 <cizra> "Extract the Data.Vector.Storable.Vector from a Buffer. " -- I guess yes
12:21:07 <cizra> Hey, this stuff is confusing! http://hackage.haskell.org/packages/archive/hsndfile-vector/0.4.0/doc/html/Sound-File-Sndfile-Buffer-Vector.html#t:Buffer
12:21:14 <cizra> data Buffer a Source
12:21:14 <cizra> Newtype wrapper for Data.Vector.Storable.Vector. 
12:21:26 <cizra> -- so Buffer is the same thing as Data.Vector.Storable.Vector?
12:21:37 <cizra> Why do we have fromBuffer :: Buffer a -> Vector a then?
12:22:06 <cizra> Hmm, no, it's a _wrapper_. Anyway, how do I make it a CArray?
12:23:22 <jacobian> Philonous_: yup
12:24:18 <cizra> I feel there's a need for an example for the Math.FFT module )=
12:25:03 <cizra> I read sound data out of a audio file with libsndfile. Now I'm trying to get its spectrum, but I don't know how to tie the interfaces together.
12:26:07 <cizra> I guess I should be using this function:
12:26:08 <cizra> dftRC :: (FFTWReal r, Ix i, Shapable i) => CArray i r -> CArray i (Complex r)
12:26:29 <Botje> eep.
12:27:59 <cizra> So, uh, assuming I have a Data.Vector.Storable, how do I make it into CArray?
12:29:02 <cizra> This one sounds slightly like what I want:
12:29:02 <cizra> unsafeByteStringToCArray :: (Ix i, Storable e, IArray CArray e) => (i, i) -> ByteString -> Maybe (CArray i e)
12:29:30 <cizra> Or maybe this:
12:29:31 <cizra> unsafeArrayCArray :: (MArray IOCArray e IO, Storable e, Ix i) => (i, i) -> [(Int, e)] -> e -> IO (CArray i e)
12:31:03 <cizra> No, wait, ByteString is not what I want -- I have a list of elements, not a bunch of bytes.
12:34:04 * Saizan loves ~
12:34:20 <aristid> Saizan: ~ as in $HOME?
12:34:28 <aristid> :t (~)
12:34:38 <aristid> *sigh*
12:35:29 <copumpkin> (~) isn't an operator
12:35:38 <copumpkin> it's closer to a typeclass
12:37:51 <shamster> on first reading Real World Haskell, did anyone else find it fragmented and missing several key points in every other paragraph?
12:38:19 <shamster> For this first-time reader and haskell newb, there's a lot of hand-waving going on in the book
12:39:45 * hackagebot happstack-facebook 0.28 - A package for building Facebook applications using Happstack  http://hackage.haskell.org/package/happstack-facebook-0.28 (JeremyShaw)
12:40:23 <Saizan> shamster: it goes a bit fast from what i gather, you should try LYAH
12:40:27 <silver> yeah, it is hard to use it for first-time meeting with haskell I guess
12:40:29 <Saizan> as a start anyway
12:40:33 <Saizan> @where LYAH
12:40:44 <copumpkin> @where lambdabot
12:40:46 <copumpkin> ;)
12:40:48 <silver> my path was sicp -> RWH
12:41:08 <silver> if I remember correctly >.>
12:41:13 <Saizan> http://learnyouahaskell.com/chapters
12:41:46 <Saizan> *Main> ln (\f x y -> f $$ y $$ x)
12:41:47 <Saizan> Lam (Lam (Lam (App (App (Var 2) (Var 0)) (Var 1))))
12:41:51 <shamster> I'm on the wikibooks for haskell right now and it's pretty clear and lucid. It doesn't assume mush background
12:42:12 <shamster> SICP was my route through lisp, followed by practical common lisp... I was hoping for similar in haskell. 
12:42:25 <shamster> s/mush/much/
12:42:37 <silver> http://en.wikibooks.org/wiki/Haskell ?
12:42:42 <copumpkin> Saizan: oh nice
12:42:46 <shamster> silver: 
12:42:49 <shamster> silver: yeah
12:43:02 <Twey> It's not very complete though
12:43:15 <Twey> LYAH and RWH have much more info
12:43:20 <copumpkin> Saizan: why are you taking the \f as a parameter though?
12:43:26 <shamster> Twey: I'm hoping to get there eventually
12:44:02 <copumpkin> Saizan: I suppose just because you can :)
12:44:08 <Saizan> copumpkin: yeah :)
12:44:24 <kfr> http://siyobik.info/pastebin_download.php?id=588 <- do you think that explicit recursion is bad style in this case?
12:44:41 <copumpkin> Saizan: with a suitable typeclass I think I could make that work for my case too
12:45:09 <kfr> Not sure if you can make that any shorter really
12:45:12 <elliott> Is fusion performed on strict bytestrings?
12:45:18 <copumpkin> yes
12:45:22 <elliott> Ah, yes.
12:45:22 <hpc> kfr: it looks fine to me
12:45:25 <kfr> But in general people told me not to use explicit recursion when a standard function can do it
12:45:39 <kfr> Alright
12:45:39 <hpc> any further work would be inside the let
12:45:50 <copumpkin> kfr: it's often more efficient to have someone else recurse for you
12:46:01 <hpc> explicit recursion isn't inherently bad
12:46:06 <kfr> Man, this really looks like homework, doesn't it? Amazingly enough I actually needed this privately
12:46:07 <kfr> Hahaha
12:46:26 * hpc only uses built-ins for recursion when they make code easier to read
12:46:28 <kfr> This really looks like some undergrad homework
12:46:34 <gwern> anyone want to test this link? http://dl.dropbox.com/u/5317066/haskell/2010-dec-yi-repo.tgz
12:46:44 <copumpkin> hpc: the point is that they're often more efficient
12:46:44 <kfr> Well the performance really isn't an issue in this case
12:46:46 <copumpkin> due to fusion rules etc.
12:47:11 <copumpkin> Saizan: what's your code look like for that?
12:47:56 <A1kmm> Hi, what is the recommended academic citation to use for GHC?
12:48:06 <glguy> kfr: that function assumes that you'll always run out of money :)
12:48:16 <kfr> glguy yeah
12:48:24 <elliott> Hmm, is there a function like split on ByteString but that accepts an arbitrary ByteString as the splitter?
12:48:28 <elliott> Or, preferably, a list of ByteStrings?
12:48:35 <xplat> not just that they're more efficient--they can also be easier to understand.  at a deep level, that is
12:48:35 <gwern> A1kmm: iirc, you link to their homepage
12:48:42 <elliott> I'd like to split on "\r\n", "\n", and "\r".
12:48:46 <kfr> glguy I was just trying to determine when I'd run out of money if I didn't work at all
12:48:51 <gwern> elliott: doesn't BS already have lines/unlines?
12:48:54 <xplat> for example, it's easier to do time/space analysis when you use builtins than explicit recursion
12:48:55 <copumpkin> elliott: not isSpace ?
12:49:10 <Saizan> copumpkin: https://github.com/Saizan/jigger/blob/master/Jigger.hs
12:49:11 <elliott> gwern: oh, maybe in .Char8
12:49:19 <elliott> copumpkin: that would also accept " " i presume
12:49:21 <A1kmm> gwern: So there is no application note or other review of GHC functionality?
12:49:31 <elliott> Foo.Char8's ByteString type is the same as Foo's, right?
12:49:33 <copumpkin> Saizan: cool, thanks
12:49:37 <glguy> elliott: Data.ByteString.Char8.lines
12:49:38 <gwern> A1kmm: well, there's a GHC book from a decade or two ago or something
12:49:40 <elliott> i.e. I can import both Data.ByteString and Data.ByteString.Char8
12:49:45 <glguy> exists, but it might not do exactly what you wanted 
12:50:02 <elliott> glguy: Well. How does it behave on "\n\nx"?
12:50:09 <xplat> if you care especially about a specific feature of ghc there is probably at least one paper describing it
12:50:15 <glguy> elliott: I don't know :)
12:50:19 <copumpkin> Saizan: it'll be interesting to see how much nicer this stuff will be with TypeNats :)
12:50:21 <elliott> yay :P
12:50:24 <xplat> otherwise homepage is a good place to cite, or the reference manual
12:50:26 <elliott> copumpkin: is TypeNats going to be an actual feature?
12:50:30 <copumpkin> Saizan: although I'm a little concerned at how ad-hoc TypeNats is looking 
12:50:34 <copumpkin> elliott: yeah, it's mostly implemented, too
12:50:38 <glguy> elliott: otherwise you might write something quickly with Data.Binary or Data.Serialize (depending on your strictness needs)
12:50:38 <aavogt> there is also a lines for utf8-bytestrings
12:50:47 <elliott> copumpkin: meh. why can't we just get automatic lifting of data-types to data-kinds.
12:50:49 <elliott> BAH HUMBUG
12:50:58 <elliott> glguy: a manual parser is probably for the best here
12:51:05 <copumpkin> elliott: because that isn't as powerful
12:51:05 <copumpkin> you want smarter unification for things you know about
12:51:08 <xplat> i think homepage is more accepted these days, used to be people would cite the manual more
12:51:26 <elliott> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.9/doc/html/src/Data-ByteString-Char8.html#lines
12:51:29 <elliott> I like the commented out lines after that
12:51:34 <elliott> very... elegant :D
12:51:36 <A1kmm> gwern: I found this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.6555 but it is from 1992 and calls it the Glasgow rather than Glorious compiler.
12:51:55 * xplat notes that numbers get special treatment even at the value level
12:52:04 <gwern> A1kmm: when to call it Glasgow and when ti call it Glorious is the secret shibboleth of haskellers
12:52:13 <aristid> A1kmm: it's The Glorious Glasgow Haskell Compilation System
12:52:16 <Saizan> copumpkin: the only ad-hoc part is the nicer constraint solver, no? (and syntax, but that's just aesthetic :)
12:52:39 <gwern> elliott: hah. 'just as fast, but more complex' <-- if you read that quickly, it sounds like a good thing
12:52:42 <copumpkin> Saizan: well, I'm just not sure how well it interacts with all the other features, like GADTs and stuff. Maybe it'll be nice
12:52:48 <copumpkin> Saizan: like the example I gave on the ticket
12:52:49 <elliott> gwern: hehe, indeed
12:52:55 <copumpkin> do you follow the ticket?
12:53:06 <gwern> the ticket signed my t-shirt at the last concert
12:53:07 <Saizan> ah, no
12:53:07 <elliott> gwern: i like the 0x08 part, i bet that's much faster than writing it in decimal
12:53:08 <xplat> lifting datatypes to datakinds is a nice idea too
12:53:15 <copumpkin> (about REPA, and refining the type index to a multiplication of naturals)
12:53:15 <Saizan> i've missed it
12:53:21 <copumpkin> maybe it'll work fine
12:53:26 <copumpkin> but it seems damn hard
12:53:27 <xplat> or else just defining datakinds would be nice
12:53:36 <elliott> this channel is so high-traffic nowadays, copumpkin, you should just ban half of the people in here
12:53:42 <xplat> of course then people will want kindclasses
12:53:50 <gwern> elliott: who knows, maybe it is! ghc isn't too good at the low-level doncha know
12:53:55 <copumpkin> Saizan: and the fact that there's no "principled" fallback beyond unsafeCoerce if the solver can't figure something out, yet
12:54:00 <Saizan> copumpkin: which number is it?
12:54:03 <copumpkin> let me see
12:54:09 <elliott> gwern: I bet "q == nullPtr" is SLOW, that should be "isNullPtr# q"
12:54:16 <elliott>                     then return [PS x (s+n) (l-n)]
12:54:17 <copumpkin> Saizan: http://hackage.haskell.org/trac/ghc/ticket/4385
12:54:18 <elliott> SHOULD BE RETURN $!
12:54:28 <elliott> this guy's an amateur at Haskell benchmark game code!
12:54:29 <Saizan> copumpkin: can you write instances for the typenats as if they were peanos?
12:54:35 <gwern> elliott: mm, I'd want to check the Eq instance. maybe it is defined as isNullPtr#
12:54:38 <copumpkin> Saizan: I don't think so
12:54:43 <A1kmm> thanks - I think I'll cite the '92 paper and also the URL.
12:54:45 <elliott> gwern: what, "x == _ = isNullPtr# x"?
12:54:47 <copumpkin> I haven't actually run it yet
12:54:51 <elliott> best Eq instance ever
12:54:54 <copumpkin> just been reading the docs and examples
12:55:00 <gwern> elliott: er. ok, maybe a rewrite rule then
12:55:03 <copumpkin> elliott: yeah, it is rather noisy, isn't it
12:55:09 <copumpkin> elliott: it is all on-topic at least
12:55:29 <glguy> moderation discussions are off-topic :-p take it to #haskell-ops 
12:55:32 <gwern> elliott: or is there some problem with rewriting 'x == nullPtr' to 'isNullPtr# x'?
12:55:39 <copumpkin> glguy: oh good point :P
12:55:47 <elliott> gwern: yes, what if the compiler doesn't recognise it because it doesn't know that "x" is a pointer
12:55:50 <elliott> I hear GHC is stupid
12:55:56 <elliott> (is trolling on-topic?_
12:55:57 <copumpkin> glguy: o shit you just talked about what was on-topic, which is itself off-topic!
12:55:57 <elliott> *?)
12:56:01 <gwern> elliott: we'll override it with some pragmas
12:56:07 <elliott> gwern: that's your solution to everything
12:56:08 <shamster> can two constructor functions have the same name but different types?
12:56:10 <gwern> we can use pragmas in rewrite rules can't we? :)
12:56:14 <elliott> i say make GHC use g++ as a backend
12:56:18 <elliott> then it'll be fast
12:56:22 <copumpkin> elliott: shush
12:56:25 <elliott> (think I might get banned for that one)
12:56:41 <xplat> shamster: technically yes, practically no
12:57:19 <gwern> elliott: but seriously, is that a bad rewrite rule?
12:57:22 <elliott> gwern: no :)
12:57:23 <elliott> i'm just joking
12:57:36 <elliott> map (map fromIntegral . B.unpack) . B8.lines . B.filter (/= fromIntegral ff) <-- hmm, I should possibly iterate over the lines rather than doing this ...
12:57:44 <gwern> where would it go, anyway
12:57:45 * copumpkin is really pushing haskell's type system with his latest random hack
12:57:53 <shamster> xplat: I attempted it but got an error. I'm still stuck in the c++ constructor method paradigm allowing for type matching (and matching # of arguments)
12:58:07 <xplat> @hoogle f (b -> c) -> f (a -> b) -> f (a -> c)
12:58:37 <dibblego> @type liftA2 (.)
12:58:47 <c0w> I wonder if these types will kill me later
12:58:56 <xplat> shamster: yeah, you'll want to run away from that paradigm fast if you're doing haskell (or ml)
12:59:11 <shamster> xplat: that seems to be the case
12:59:26 <xplat> dibblego: yeah, i was just wondering if it wasn't called <.> because it had some other name
12:59:36 <companion_cube> lambdabot is sick ?
13:00:07 <shamster> xplat: is it more idiomatic, then, to have each constructor with a separate name, even though the data types are accomplishing the same thing?
13:00:43 <xplat> shamster: yes.  in fact, even if it's the same data type, the constructors should have different names.
13:01:13 <shamster> xplat: thanks
13:01:37 <xplat> (you can't even have two constuctors with the same name for the same datatype, in fact.  you can only have that, in the full sense, by declaring two datatypes and stuffing about with the linker.)
13:02:36 <Saizan> c0w: mh, they do look somewhat fragile from yours and adam's comments
13:03:07 <c0w> m00
13:03:32 <c0w> m00 Maybe ~ Nat
13:03:36 <shamster> xplat: The message seems to be about putting more thought into types instead of making a single type universal
13:03:39 <args0> I'd like some help solving this please: http://pastebin.com/SWDyfwds (I'm willing to reward whoever can help with a paypal payment, needed urgently please)
13:03:42 <azaq23> apt-get moo
13:03:42 <Saizan> ...
13:03:54 * hackagebot happstack-facebook 0.30 - A package for building Facebook applications using Happstack  http://hackage.haskell.org/package/happstack-facebook-0.30 (JeremyShaw)
13:03:57 <xplat> møø?
13:04:18 <xplat> shamster: indeed
13:04:37 <c0w> Saizan: yeah :/ it seems like a pretty tough problem to do nicely (especially considering the undecidable problem) but a design document explaining its interaction with all the existing type system machinery would be nice
13:04:40 <elliott> glguy: you mislead me, lines doesn't support \r or \r\n
13:04:45 <c0w> led
13:04:58 <elliott> I want blood!
13:06:55 <xplat> args0: you're paying people to do your homework?  not cool ...
13:06:56 <c0w> I _really_ wish I had closed type families
13:07:18 * Saizan realizes that git is not that fast either at cloning ghc's repo
13:07:27 <monochrom> paying for homework is fine, as long as you pay well, IMO
13:07:35 <c0w> Saizan: well, not as fast as darcs lazy, but it is fetching the entire thing
13:07:49 <TTimo> also, I'd ask to have in escrow before starting
13:07:52 <glguy> Saizan: you won't have to replay all of the patches, at least :)
13:07:53 <c0w> or is it slower than a full darcs get too
13:08:10 <args0> xplat: I am lagging a lot with my studies, and working full time...i need help really badly here, I agree with you
13:08:25 <monochrom> for example "I'll pay you us$5 this is good money for you considering how poor you are!" is not pay well. it's insulting. make it us$500.
13:08:55 * hackagebot hakyll 2.4.3 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.4.3 (JasperVanDerJeugt)
13:09:30 <glguy> args0: This is not a homework doing channel. You are welcome to ask specific questions about things you don't understand.
13:10:57 <args0> glguy: answering my homework will make me both of us happy, its just a matter that i dont have time going through the material, still amateur in functional programming
13:11:46 <xplat> args0: putting programmers on the market with fake credentials to compete with me for jobs doesn't make me happy
13:11:47 <monochrom> arguing homework ethics is not productive
13:12:05 <elliott> more productive than arguing homework payment
13:12:06 <Botje> you will have to learn FP anyway, might as well do it now
13:12:29 <monochrom> heh
13:12:45 <nosila> Hi
13:12:53 <monochrom> but competition is a good point. no one wants more competitors.
13:12:56 * hackagebot pwstore-fast 1.0 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-1.0 (PeterScott)
13:13:01 <nosila> i need to write a BinarySearchTree to a file
13:13:20 <nosila> the leafs are a data that i created
13:13:21 <Botje> make it an instance of both Show and Read
13:13:27 <nosila> anyone knows a tutorial for that ??
13:13:50 <nosila> dont know how to do the Read instance =/
13:14:00 <maurer_> nosila: Look up the "deriving" keyword
13:14:03 <Botje> data Tree a = .... deriving (Show, Read)
13:14:03 <tarrasch> nosila, can you use deriving?
13:14:14 <args0> im learning Haskell as we speak, I'm reading "the craft of functional programming' by Simon Thompson
13:14:23 <monochrom> Read instances are harder to write. You write a parser.
13:14:47 <maurer_> args0: None of the empty sections in that program correspond to anything where laziness or the fact that you are using a functional programming language will come in to play.
13:15:06 <maurer_> You _can_ use those features, but there is really no need for them in this sample.
13:15:07 <edwardk1> copumpkin: tempted to try to feed my newer type level numerics back into vector-static, using zeroless binary numbers to retain uniqueness, but get the right asymptotics for stuff
13:15:32 <args0> maurer_: ah ok I see, this is my first assignment that's why...
13:15:56 * hackagebot pwstore-purehaskell 1.0 - Secure password storage, in pure Haskell.  http://hackage.haskell.org/package/pwstore-purehaskell-1.0 (PeterScott)
13:16:13 <nosila> yeah i know what the read is suposed to do
13:16:26 <nosila> i just wanted to see some code with that
13:16:41 <maurer_> nosila: After driving read and show, if you want it to be a slightly better serialization look to Codec.Compression.GZip
13:16:46 <nosila> maybe i'll figure something out, but first i will just put deriving Show, read as you've said ;)
13:17:20 <maurer_> nosila: If you decide to write your own serialization, look into Data.Binary or cereal
13:17:33 <nosila> oh man not really, i just want to finish this damn project 
13:17:52 <maurer_> But deriving (Show, Read) + GZip is generally pretty good by itself, and requires no code :)
13:18:00 <nosila> the file reading / writing just have to work,  optimization is not a priority
13:18:03 <xplat> maurer_: wouldn't binary-generic or binary-syb be a lot easier to work with than gzipping read/show?
13:18:21 <maurer_> xplat: Possibly. I'm not familiar with those packages though.
13:18:39 <maurer_> All the syb packages have appeared dark magic to me, I really should go read them more carefully at some point.
13:18:47 <maurer_> xplat: Would you reccomend one of those?
13:19:36 <nosila> main diference between using the Gzip and using writeFile??
13:19:49 <nosila> just compression?
13:20:13 <maurer_> nosila: Yeah.
13:20:16 <Peaker> @hoogle Read a => String -> Maybe a
13:20:32 <xplat> nosila: using Gzip is basically the same as just using read/show with command-line gzip
13:20:32 <azaq23> args0: The module first implements "BitStrings" up to 5, meaning a string of the form "01011" (5 characters, all 0 or 1) to represent truth (boolean) values for the four / five rules. You have to implement the truth tests for the rules
13:20:32 <Peaker> Where was readM that I remember exists somewhere?
13:20:44 <maurer_> nosila: Read and Show will by default be using an extremely non-dense implementation
13:21:12 <azaq23> args0: and for legal and legal' (corresponding to four / five rules), generate all combinations of four / five bitstrings using the functions given to you, that's basically all
13:21:18 <maurer_> azaq23: I think he knows this already, he just wants to take money to write them.
13:21:23 <xplat> except if you want to embed it in another file it becomes a little easier
13:21:30 <maurer_> err, wants someone to take money
13:21:55 <Peaker> @botsnack
13:22:00 <Peaker> What gives?
13:22:10 <nosila> hum thaks
13:22:26 <nosila> later i will try those tips ;)
13:22:29 <nosila> thanks*
13:22:50 <cizra> Yay, I think I figured out how to convert Vector.Storable into CArray (=
13:23:16 <cizra> However, the documentation is kind of hazy on the arguments of CArray constructor
13:23:21 <Peaker> cizra, Ideally you'd ask Hoogle and it'd find a function or composition of functions that satisfies the type :)
13:23:26 <cizra> CArray !i !i Int !(ForeignPtr e)
13:23:37 <cizra> Peaker: umm.. Why didn't I think of that?
13:23:56 <xplat> Peaker: hoogle with built-in djinn?  wacky.
13:23:59 <Peaker> cizra, hoogle will only find a direct function if one exists, if it requires a composition it won't find it
13:24:09 <Peaker> xplat, or djinn with a lot more types inside
13:24:12 <xplat> (or would it be the other way around?)
13:24:22 <aavogt> args0: is going to have lots of trouble to produce valid code while not removing the given  ...
13:24:38 <Peaker> xplat, djinn with the entire stdlib in there would be useful, even without recursive types (maybe with fake types for lists and other stuff it can't define)
13:25:03 <xplat> Peaker: technically it'll find a few cases where a composition is needed (say, with flip), it just won't tell you what the necessary composition is
13:25:11 <cizra> Anyhow, does anybody have tips on reading the CArray doc?
13:25:26 <Peaker> xplat, pl . djinn :)
13:25:37 <cizra> What are those bangs? What do those arguments contain?
13:26:05 <maurer_> cizra: Look up the BangPatterns extension
13:26:14 <maurer_> cizra: They're essentially strictness annotations
13:26:24 <cizra> oh!
13:26:36 <cizra> Of course! I've seen them, but I've never touched any.
13:27:00 <Peaker> cizra, http://hackage.haskell.org/packages/archive/carray/0.1.5/doc/html/src/Data-Array-CArray-Base.html ?
13:27:03 <cizra> Okay, second question stands: nobody documents what should those arguments contain.
13:27:09 <args0> azaq23 aavogt thanks for your input, I'm working on it now
13:27:19 <cizra> Peaker: That's what I'm staring at, yes
13:27:29 <maurer_> cizra: Yeah, they probably expect you ot use things other than the actual constructor
13:27:32 <Peaker> cizra, I can guess that the first two are first-index, last-index, the Int is probably the count (or size?) and the last is a ptr to the base offset, most probably
13:27:39 <cizra> unsafeForeignPtrToCArray :: Ix i => ForeignPtr e -> (i, i) -> IO (CArray i e)
13:27:46 * elliott 's unsafe alarms go off
13:27:52 <elliott> BEEEEP, BEEEEEP, BEEEEEEEEEP!
13:28:03 <maurer_> My guess is CArray lowerbound upperbound ? rawPointerToData
13:28:05 <cizra> -- I guess this one sounds useful, but .. yeah, unsafe
13:28:14 <xplat> DANGER, WILL ROBINSON!
13:28:23 <Peaker> cizra, hmm.. it seems the Carray data constructor isn't even exported
13:28:24 <cizra> .. and no doc either.
13:28:35 <Peaker> cizra, ah, that function is indeed the one you may want
13:28:38 <maurer_> cizra: Using the naked CArray constructor is likely more dangerous
13:28:44 <xplat> typical for abstract types anyway
13:28:51 <Peaker> mauke, seems unexported
13:29:06 <Peaker> oops
13:29:06 <Peaker> maurer_, seems unexported
13:29:07 <ricree> Is anyone here familiar with the Haskell LLVM bindings?  I'm a bit confused by the process for constructing a function with them.  Most of the examples I've seen pass a haskell function with the correct arguments to LLVM's defineFunction, but I'm a bit confused as to how it would work if one was creating the function based of of an AST or somesuch where the variable count isn't known till after parse time.
13:29:58 <cizra> Okay, let's assume it's (lowerbound, upperbound). hmm.
13:30:04 <maurer_> ricree: First question, are you trying to produce a compiler? If so, the Haskell LLVM bindings won't do what you want.
13:30:13 <aavogt> does anybody see a way to convert the colorbrewer ones here to Data.Colour http://hackage.haskell.org/packages/archive/graphviz/latest/doc/html/Data-GraphViz-Attributes-Colors.html ?
13:30:29 <xplat> what will the haskell llvm bindings do anyway?
13:30:38 <maurer_> ricree: I tried to do tehe same, but it turns out that the type of an argument to the "call" function encodes how to call it.
13:30:58 <maurer_> ricree: Which means you need to know the type of every function you will ever produce at compile time of your compiler
13:31:08 <maurer_> xplat: They are designed to allow JITting in a semi-typesafe fashion
13:31:29 <xplat> hm, that might be able to do what i want
13:31:41 <elliott> Is there nothing like the split package for ByteStrings? http://hackage.haskell.org/package/stringsearch seems promising, but it only supports "heavy" search algorithms, whereas I just literally want to split on \r\n, or \r, or \n.
13:31:49 <maurer_> xplat: They're fairly well done, just not useful for a compiler toolkit, which is sad.
13:32:09 <maurer_> @hoogle Data.ByteString.unlines
13:32:22 <aavogt> elliott: attoparsec, or maybe the bytestring lines in utf8-string
13:32:24 <maurer_> @hoogle unlines
13:32:34 <xplat> i am looking to produce compiled subs to call haskell from C as if they were loaded from a DLL
13:32:41 <aavogt> unlines adds \n between elements of the list
13:32:49 <elliott> aavogt: attosplit seems to be splitting based on attoparsec
13:32:51 <elliott> maurer_: lines only supports \n.
13:32:58 <ricree> maurer_: ah, too bad.  Up until this, I could kind of get how to use it for what I wanted.  At least for the toy language I was playing around with
13:33:04 <maurer_> elliott: Oh :/
13:33:05 <xplat> i was about to suggest attosplit too!
13:33:08 <elliott> aavogt: but it seems a bit much overhead for what i want
13:33:31 <maurer_> ricree: For my compiler, I just wrote out llvm assembly with a pretty printer
13:33:44 <maurer_> ricree: It wasn't as nice as if we had bindings, but it worked.
13:33:57 <xplat> what if you used GADTs and/or type families to synthesize the right types?
13:34:12 <elliott> Isn't attosplit strict anyway?
13:34:16 <elliott> Can it do fusion?
13:34:24 <elliott> Or would I go through the string once to split, and then once to do my loop over the lines?
13:34:29 <elliott> That would be Inefficient(TM).
13:34:40 <maurer_> xplat: A type at some point in the program would have to be different depending on the data going in.
13:34:55 <xplat> elliott: damned if i know, i just read the summary line on hackage
13:35:00 <maurer_> xplat: As the call function actually uses the information in that type to exploit the calling convention
13:35:02 <elliott> xplat: I AM DISAPPOINTED
13:35:52 * Saizan should write an example program where "types" differ according to runtime data
13:36:24 <elliott> Saizan: WELCOME TO AGDA
13:36:30 <maurer_> Saizan: Does GHC not monomorphize during compilation?
13:36:48 <ricree> maurer_:  thanks
13:36:50 <elliott> [[Split a lazy bytestring into a lazy list of lazy bytestrings at boundaries defined by an attoparsec parser. The result of a matching parse is included at the beginning of the lazy bytestring which begins at that point.]]
13:36:52 <elliott> attosplit won't work then
13:36:54 <c0w> Saizan: like what? I'm doing something similar in my current project
13:36:55 <elliott> i'm using strict bytestrings
13:37:47 <xplat> what are you doing after you split them?
13:37:49 <Saizan> maurer_: what do you mean? anyhow, dictionaries can end up being dynamically constructed at runtime, and that's what matters here
13:38:58 <maurer_> Saizan: Monomorphizing is when a compiler takes all occurrences of polymorphism in a program and turns them in to straight calls to one thing or another.
13:39:00 <Saizan> c0w: dunno, something about naturals like in oleg's implicit configurations maybe
13:39:14 <c0w> ah
13:39:41 <maurer_> Saizan: Dictionaries?
13:39:57 <Saizan> maurer_: typeclass dictionaries
13:40:10 <Saizan> which is how GHC implements them
13:40:25 <xplat> it's perfectly possible to use GADTs, or even a lot of the typeclass extensions, to create data that is dependently-‘enough’ typed for most purposes
13:41:10 <maurer_> Saizan: Can you point me to how you can generate dyanmic dictionaries at runtime? I was unaware we could do this.
13:42:38 <Saizan> maurer_: http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf <- here it's taken to the extreme
13:42:44 <maurer_> |
13:42:45 <maurer_> |(13:57:22) Saizan: c0w: dunno, something about naturals like in oleg's        |
13:42:48 <maurer_> |implicit configurations maybe                                                 |
13:42:49 <maurer_> |(13:57:33) PhilRod [~phil@cpe-67-247-83-59.rochester.res.rr.com] entered the  |
13:42:51 <maurer_> |room.                                                                         |
13:42:54 <maurer_> |(13:57:36) c0w: ah                                                            |
13:42:57 <maurer_> |(13:58:02) maurer_: Saizan: Dictionaries?                                     |
13:42:58 <maurer_> |(13:58:19) Saizan: maurer_: typeclass dictionaries                            |
13:43:00 <xplat> maurer_: a simple example os a nested type that is an instance of something if its argument is
13:43:00 <maurer_> |(13:58:22) Luke [~Luke2@99.23.133.75] entered the room.                       |
13:43:03 <maurer_> |(13:58:31) Saizan: which is how GHC implements them                           |
13:43:03 --- mode: ChanServ set +o c0w
13:43:06 <maurer_> |(13:58:46) xplat: it's perfectly possible to use GADTs, or even a lot of the  |
13:43:08 --- mode: c0w set +q maurer_!*@*
13:43:27 --- mode: c0w set -q maurer_!*@*
13:43:56 --- mode: c0w set -o c0w
13:44:20 <shachaf> c0w: What happened to w?
13:44:28 <xplat> maurer_: in that case, the runtime will construct a dictionary for any level of nesting it actually encounters in the runtime value
13:45:10 <maurer_> Oops, my bad, I didn't meamn to paste that huge thing in channel.
13:45:12 <maurer_> My apologies
13:45:36 <Saizan> maurer_: seen the link?
13:46:10 <maurer_> Saizan: Yes, reading.
13:47:04 * hackagebot xmlhtml 0.1.1 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.1 (ChrisSmith)
13:47:18 <cizra> This stuff looks weird. Can I dispense with the temporary monadic values?
13:47:19 <cizra>   (ptr, beg, end) <- return $ V.unsafeToForeignPtr (BV.fromBuffer b)
13:47:19 <cizra>   A.unsafeForeignPtrToCArray ptr (beg, end)
13:48:01 <cizra> Hmm, I could stuff the two lines into return $ let (...
13:49:31 <cizra> Nope.. I'm out of ideas
14:04:21 <blueonyx> hi, i'm playing with hint, made some little (i think) changes and now it throws GhcException "unable to load package `mypackage`" at me. any pointers whats wrong?
14:05:17 <c0w> Saizan: your jigger has FZ :: Fin n
14:08:45 <luite> has anyone had the error "openBinaryFile: resource exhausted (Resource temporarily unavailable)" when cabal installing something?
14:15:04 <c0w> what would you call a property forall x y. not (x < y && y < x)?
14:16:00 <companion_cube> symmetry of the related <= relation, i guess
14:18:35 <Saizan> c0w: ah, oops
14:20:03 <c0w> well, now I have a nice presburger/peano EDSL
14:20:18 <c0w> still no n-ary quantifiers, but I'm mostly satisfied
14:20:25 <c0w> now I just need to write the actual algorithm
14:21:41 <Saizan> :O
14:22:23 <c0w> Saizan: it's painfully strongly typed, and I'm pretty sure it's going to bite me when I try to do anything with it
14:22:26 <c0w> but so far it's quite pleasant
14:22:47 <c0w> I have http://hpaste.org/43700/statements
14:23:27 <c0w> where Ord and Eq are parametrized over a "truth type" for the domain
14:23:34 <c0w> so == on my relations gives me a relation
14:23:39 <c0w> but == on naturals gives me a bool
14:23:50 <c0w> and the truth type must be a boolean algebra
14:24:44 <Saizan> nice
14:25:15 <c0w> and then I have two copies of the AST, one more strongly typed than the other, with an existential conversion
14:25:29 <c0w> so the algorithm will presumably work over the more strongly typed version
14:25:57 <c0w> prove :: Theory m => Rel m Z -> Maybe Bool
14:26:02 <c0w> and cooper :: Rel Presburger Z -> Bool
14:26:36 <c0w> and I preserve the presburgerness or peanoness throughout all constructions of expressions and relations as type indices
14:26:59 <c0w> almost feels silly, but it's fun too
14:27:18 <TTimo> ok this is silly, but: if I am in ghci and I have a .hs script, how do I "run" it? e.g. evaluate the main IO action ?
14:27:27 <c0w> type main
14:28:13 <TTimo> ah!
14:28:14 <TTimo> ty :)
14:28:34 <blueonyx> there is also :main
14:29:24 <copumpkin> you can have material implication for any boolean algebra, right?
14:29:27 <Saizan> copumpkin: the aim is to implement a better solver for type-nats?
14:29:29 <edwardk1> copumpkin: http://hpaste.org/43701/zerolessbinary_type_nats
14:29:32 <copumpkin> it's just not x or b
14:30:07 <copumpkin> Saizan: sort of, yeah. It falls back on presburger for anything it can handle, and has heuristics (but can return Nothing) for peano, as well
14:30:22 <copumpkin> edwardk1: ack :P
14:31:04 <edwardk1> i had a 2s complement type level library, so i wondered if i'd get benefits out of actually building it with a zeroless number representation
14:31:12 <copumpkin> Saizan: I may have gone overboard though. I even handle the case of multiplication of a variable by 0 eliminating it (so if you have (0 * x) * y, it doesn't consider that to be a peano-worthy constraint
14:31:41 <edwardk1> carry is a bit ugly, but it admits a nice recursively indexable vector implementation
14:31:49 <copumpkin> I think that in particular will make this very painful to work with :P
14:31:53 <copumpkin> and I'll probably go running home to agda 
14:33:18 <copumpkin> edwardk1: it's an interesting representation
14:33:44 <edwardk1> it gives logarithmic time indexing and cons if you really want it ;)
14:34:03 <copumpkin> now prove addition is associative and commutative etc. :P
14:34:21 <edwardk1> meh. unsafeCoerce is my god now ;)
14:34:25 <copumpkin> :)
14:34:31 <medfly> isn't addition defined as being associative/commutative
14:34:44 <copumpkin> not really
14:34:46 <medfly> or are you trying to say that you should prove something is a correct implementation of addition
14:34:47 <edwardk1> medfly: no
14:34:50 <copumpkin> it's defined however you define it :P
14:35:02 <edwardk1> medfly: plenty of algebraic structures have non-commutative addition
14:35:02 <medfly> I meant to include the word "usually"
14:35:11 <Saizan> copumpkin: neat, i didn't realize that the shape of the expression automatically determined the theory to use 
14:35:38 <copumpkin> Saizan: yeah, my current implementation of prove is
14:35:39 <copumpkin> prove :: Theory m => Rel m Z -> Maybe Bool
14:35:39 <copumpkin> prove r | Presburger <- theory r = Just (cooper r)
14:35:39 <copumpkin> prove r = Nothing
14:35:40 <copumpkin> :P
14:35:48 <copumpkin> so just don't feed it any peano
14:36:06 <copumpkin> I haven't actually implemented cooper yet, and I'm kind of scared to
14:36:38 <copumpkin> I'm thinking of procrastinating a bit and encoding normalization into another type index, for extra ridiculousness
14:36:42 <edwardk1> I've never fed anyone a piano before, but i can't imagine it is good for the digestion
14:36:54 <copumpkin> lol
14:37:18 <NemesisD> anyone have any experience with Distribution.Simple.Command from the cabal source?
14:38:15 <copumpkin> I have a lot of semilattice type families in this code :P
14:38:33 <copumpkin> it's a pattern I'd love to abstract out, if GHC supported that
14:39:20 <dafis> tibbe: have you a little time?
14:39:28 <tibbe> dafis: sure
14:39:41 <tibbe> dafis: it's a little late so I can't guarantee that my brain works
14:40:15 <dafis> It's about the container library you wrote about to the cafe, can one get a sneak preview?
14:40:40 <copumpkin> @remember smerdyakov Some might argue that you can derive False from a sentence containing both "dependent types" and "contract programming."
14:40:51 <dafis> I'd like to try it out, I have a calculation that is a bit slow with Data.Map
14:40:51 <tibbe> dafis: http://github.com/tibbe/unordered-containers
14:40:57 <dafis> thanks
14:41:03 <tibbe> dafis: there's nothing interesting from an API perspective yet
14:41:22 <tibbe> dafis: I've been working on performance, I've gotten 4x better lookup times than Data.Map
14:41:31 <tibbe> dafis: inserts are on par
14:41:32 <dafis> tibbe: all I need is singleton and insertWith
14:41:36 <NemesisD1> darn wireless
14:41:40 <tibbe> dafis: that's what I'm currently working on
14:41:59 <tibbe> dafis: hmm, I will add insertWith but right now you'll have to use lookup and insert
14:42:06 <tibbe> dafis: likely to be faster than Data.Map still
14:42:20 <tibbe> dafis: unless the Map is very small (I haven't optimized for that case yet)
14:42:41 <tibbe> dafis: we're working on some GHC changes that will improve the speed of insert quite a bit
14:42:56 <NemesisD> i should rephrase: anyone know of the easiest way to set up an executable with subcommands? cabal has a Distribution.Simple.Command but the documentation is pretty minimal and there are no guides to speak of 
14:42:57 <dafis> tibbe: I'll try it out, and let you know; my maps will be 100,000 to a few million entries
14:43:00 <tibbe> dafis: I haven't made the functions value string yet so remember to insert $!
14:43:11 <tibbe> dafis: ok, it's made for that kind of maps
14:43:19 <dafis> tibbe: I need a Map Integer Integer
14:43:23 <tibbe> dafis: in particular if your load is read heavy
14:43:31 <tibbe> dafis: that should work, do you really need Integer?
14:43:35 <dafis> I'll see where strictness is needed
14:43:58 <dafis> tibbe: yes, Int may overflow
14:44:20 <tibbe> dafis: if you go back in the git history of the project you'll find another implementation which might work better for you, it has faster inserts and insertWith (called updateWithDefault I believe)
14:44:23 <dafis> tibbe: perhaps Int64 will suffice, but I'm not sure
14:44:24 <tibbe> dafis: Int64?
14:44:38 <tibbe> dafis: Integer is rarely what you want, unless you're doing Crypto
14:44:44 <dafis> tibbe: I'm on a 32-bit system :(
14:44:53 <tibbe> dafis: should still be faster I think
14:44:55 <tibbe> benchmark :)
14:45:02 <dafis> tibbe: yup
14:45:18 <tibbe> dafis: in fact, I don't remember if I added a hashable instance for Integer yet
14:45:20 <dafis> but I don't know, that may overflow
14:45:56 <tibbe> dafis: https://github.com/tibbe/unordered-containers/commit/4954cdf589e2789f3dca7d1e0feca30f93a7bc28
14:46:05 <tibbe> dafis: that's the version with faster inserts but slower lookups
14:46:19 <tibbe> dafis: 2^64 is pretty big, what are you doing?
14:46:30 <dafis> tibbe: if there isn't, I'll write one, it needn't be terribly good since most entries will be small
14:46:42 <dafis> tibbe: counting primes
14:46:52 <copumpkin> Saizan: the stuff is still very dirty: https://github.com/pumpkin/peano
14:47:02 <tibbe> dafis: 2^64 ~ 1.8*10^19
14:47:11 <tibbe> dafis: that's a lot of primes
14:47:21 <tibbe> copumpkin: added a test for sizeofArray
14:47:25 <dafis> tibbe: I know, but some intermediate coefficients get pretty big
14:47:26 <copumpkin> tibbe: oh, great
14:47:40 <tibbe> dafis: ok, I'm sure you know what you need better than me
14:48:04 <tibbe> copumpkin: JaffaCake gave me some interesting code for copy/clone, but unfortunately it segfaulted
14:48:21 <copumpkin> tibbe: oh yeah, he said he was working on fixing some other stuff because of that
14:48:57 <dafis> tibbe: I suppose I can have the keys Int64, for limits larger than 2^63, memory won't be large enough yet
14:49:20 <tibbe> dafis: right
14:49:51 <Saizan> copumpkin: much cleaner than my code :)
14:49:57 <dafis> thanks, and I'll let you know what I find about the performance
14:50:08 <tibbe> dafis: thanks
14:50:09 <copumpkin> Saizan: yeah but mine doesn't actually do anything yet :P
14:51:07 <Saizan> all those functions in the indices would be a huge pain in haskell
14:51:14 <Saizan> *agda
14:51:24 <copumpkin> Saizan: yeah, they're a pain in Haskell too :P
14:51:36 <copumpkin> functions in indices are generally a bad idea, I guess
14:52:11 <copumpkin> but it's fun to experiment
14:54:43 <copumpkin> Saizan: however, in agda I can always manipulate things manually until they work
14:54:46 <copumpkin> in Haskell, that's less true :(
14:55:17 <mun> hi
14:55:27 <mun> does anyone know what the identify function means in the real-world? what does it correspond to?
14:55:51 <copumpkin> mun: "gimme what I gave you"
14:55:51 <copumpkin> :P
14:55:58 <shachaf> A scroll of identify, presumably.
14:56:06 <copumpkin> it's forced to be honest because it's blindfolded
14:56:06 <mun> *identity
14:56:18 <copumpkin> it can't go grab anything from its secret stash of crap to give you instead
14:57:07 <mun> hmm
14:59:49 <luite> is it safe to use IORef in the following way: multiple threads acquire resources from a pool. the pool is synchronized with a QSem and MVar, so only one thread can get the same resource at a time. each thread uses withResource, a cps function that first extracts a suitable resource from the pool, then runs the action and finally returns the resource to the pool. 
15:00:09 <luite> the resources contain an IORef, that may be updated by each of the threads
15:00:56 <copumpkin> Saizan: if this works, I'll make a real-closed fields solver on CReal, for ultimate slowness ;)
15:01:05 <Saizan> well, if they are forced to mutate them only from within withResource there should be no problem
15:02:18 <luite> yeah they shouldn't leak the IORef, but I don't think I can enforce that
15:02:22 <Saizan> copumpkin: yay! now we need some type to index by reals..
15:02:33 <copumpkin> Saizan: lol, not even going to try that :P
15:02:44 <copumpkin> I can't even begin to imagine trying to index by reals, even in agda
15:02:52 <copumpkin> it's like indexing by a function, only worse
15:02:59 <Saizan> hehe
15:03:14 <monochrom> no way reals are worse than functions
15:03:17 <copumpkin> lol
15:03:25 <copumpkin> fine, they're as bad as functions
15:03:50 <Saizan> luite: yeah, that's usually left to common sense in these "with" functions, since otherwise you've to go ST-style
15:03:55 <copumpkin> I wish someone would do the hard work and make a nice Real type for agda
15:05:02 <monochrom> indexing X by Y is merely a function Y->X
15:05:50 <copumpkin> I mean a type index of an inductive family
15:06:00 <codolio> Reals are a quotient of a function space.
15:06:55 <luite> but updates to an IORef are guaranteed to be visible by other theads when used this way? I remember having to synchronization in java to enforce visibility, and I'm not sure whether the current QSem+MVar is enough, since they only lock the pool
15:07:32 <Saizan> luite: yep they are visible automatically
15:07:33 <monochrom> yes updates to IORef are visible to all threads
15:07:57 <Saizan> luite: there's also atomicallyModifyIORef if you need it
15:08:10 <codolio> I doubt you could even usefully index by the reals. It'd probably be all constant families if you're speaking R -> Set.
15:08:23 <monochrom> (the java semantics gives less guarantees to enable more parallelization)
15:08:26 <luite> yes I noticed, but it said something about being only useful for a single IORef
15:09:43 <c_wraith> atomicallyModifyIORef is strange
15:09:57 <chopin> Hi, i have a problem there : http://pastebin.com/AHwE5Mk6 ; with i = 3 for example, this fonction plays for i=3, i=2, and i = 1; i want it to play just for i=3 and not for the i before ?
15:09:59 <Saizan> how so?
15:10:28 <c_wraith> It can lead to horrible performance problems, depending on how it's used.
15:10:40 <copumpkin> the function it calls under the covers is even more strange
15:10:43 <copumpkin> its type in particular
15:10:51 * copumpkin rants some more
15:11:08 <Saizan> ah, yeah, you need to be careful wrt evaluation
15:11:08 <copumpkin> atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (#State# s, c#)
15:11:27 <c_wraith> Hmm.  Looks like unwrapped IO
15:11:37 <copumpkin> c_wraith: something should look funny in there
15:11:59 <c_wraith> where is c# coming from?
15:12:12 <copumpkin> it's Snd b, of course ;)
15:12:17 <c_wraith> in fact...  wtf does it mean to put a magic hash on a type variable?
15:12:21 <Saizan> chopin: guards are tried in order, the first alternative that matches is taken
15:12:26 <copumpkin> that isn't a hash on a type variable
15:12:28 <copumpkin> it's #)
15:12:33 <c_wraith> oh, right
15:12:38 <c_wraith> ok, that makes a lot more sense
15:12:53 <copumpkin> really?
15:12:56 <copumpkin> it's an evil type signature
15:12:59 <copumpkin> evil evil
15:12:59 <luite> hehe it does look a bit confusing :)
15:13:43 <copumpkin> evil evil evil
15:13:51 <codolio> @type atomicModifyIORef
15:13:59 <codolio> Oh, right.
15:14:04 <chopin> Saizan: it s the problem i want a function which make (App (App k s) s) for i = 2
15:14:31 <chopin> at the moment make fonction make (App (App k s) s) AND  (App k s) 
15:14:35 <copumpkin> luite, c_wraith: the basic point is that b should be (a, c)
15:14:38 <c_wraith> Cale still hasn't resurrected the bot?
15:14:46 <copumpkin> because it gets treated like (a, c) behind the scenes
15:14:50 <copumpkin> however, the type doesn't say that
15:14:52 <c_wraith> yes, that type signature is crazy.
15:14:56 <Cale> c_wraith: couldn't do it last night
15:15:09 <Cale> ah, I can ssh now :)
15:15:21 <c_wraith> Cale: that sounds bad...  Was the machine just down?
15:15:36 <Cale> Apparently just its internet connection
15:15:43 <Cale> Since my screens are still running
15:15:49 <c_wraith> hmm
15:17:19 <chopin> it plays for i, i-1, i-2... but i want it to play just for i
15:17:46 <monochrom> @botsnack
15:17:50 <lambdabot> :)
15:36:42 * hackagebot case-insensitive 0.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.1 (BasVanDijk)
15:45:04 <augur> happy = (1==) . zipWith (+) 0 . map (**2) . digits
15:46:22 <mauke> what Num instance is that?
15:46:47 <augur> oh no its not that sorry
15:46:52 <augur> it needs to cycle
15:47:00 <augur> happyStep = that
15:47:24 <mauke> huh?
15:47:48 <augur> sorry im backwards here
15:47:57 <augur> happyStep = zipWith (+) 0 . map (**2) . digits
15:48:05 <augur> you iterate this until it either equals 1 or repeats
15:48:05 <mm_freak> zipWith (+) 0?
15:48:08 <mauke> what Num instance is that?
15:48:22 <augur> er.. Int?
15:48:36 <mauke> can't match inferred type Int against expected type [a]
15:48:46 <augur> what
15:49:09 <augur> :t zipWith (+) 0
15:49:09 <mauke> also, you can't ** Int
15:49:10 <lambdabot> forall a. (Num a, Num [a]) => [a] -> [a]
15:49:19 <augur> :t zipWith (+) 0 . map (**2)
15:49:20 <lambdabot> forall a. (Floating a, Num [a]) => [a] -> [a]
15:49:32 <augur> > digits
15:49:33 <lambdabot>   Not in scope: `digits'
15:49:42 <augur> well pretend thats defined ey
15:49:55 <mm_freak> :t zipWith
15:49:55 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:50:06 <augur> it type checks, only with floats not ints. whatever.
15:50:12 <mauke> no
15:50:15 <augur> no?
15:50:22 <mauke> it typechecks with [Float], not Float
15:50:31 <augur> yes, with a == Float
15:50:33 <mauke> see the Num [a] constraint?
15:51:16 <mm_freak> augur: try to give your 0 in 'zipWith (+) 0' an explicit type signature
15:51:23 <mm_freak> like:  zipWith (+) (0 :: Something)
15:51:25 <augur> i could do!
15:51:28 <mm_freak> do it
15:51:41 <augur> :t zipWith (+) (0 :: Float) . map (**2)
15:51:41 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Float'
15:51:42 <lambdabot>     In the second argument of `zipWith', namely `(0 :: Float)'
15:51:42 <lambdabot>     In the first argument of `(.)', namely `zipWith (+) (0 :: Float)'
15:51:58 <Bynbo7> zipWith takes two lists...
15:52:04 <augur> oh thats right
15:52:06 <augur> my brain isnt working
15:52:07 <mauke> .oO( toldyaso )
15:52:10 <augur> X3
15:52:15 <mauke> sum?
15:52:24 <augur> mauke: you told me nothing, you just beat around the bush to look smart
15:52:36 <augur> obviously it was supposed to be fold
15:52:43 <mauke> wasn't obvious to me
15:52:45 <augur> i had zip on the brain x3
15:52:59 <augur> :t foldr (+) (0 :: Float) . map (**2)
15:53:00 <lambdabot> [Float] -> Float
15:53:17 <mauke> ok, what's a happyStep?
15:53:37 <mm_freak> mauke told you the right thing, but you didn't seem to understand where you were thinking into the wrong direction
15:53:38 <augur> :t foldr (+) 0 . map (**2) . digits
15:53:39 <lambdabot> Not in scope: `digits'
15:53:41 <augur> ah well.
15:53:45 <augur> its that, mauke!
15:54:07 <mauke> :t sum . map (^ 2) . ?digits
15:54:08 <lambdabot> forall a (f :: * -> *). (Num a, ?digits::f [a], Functor f) => f a
15:54:16 <augur> oh shut it :P
15:55:21 <augur> digits being a function that takes a number and returns the list of its decimal digits
15:55:35 <maurer_> Anyone know how to do something like runInteractiveCommand with [Word8] or ByteString instead of [Char] ?
15:55:37 <augur> digits 1729 = [1,7,2,9]
15:55:38 <augur> etc
15:55:45 <dankna> hmm
15:55:47 <maurer_> The program occasionally returns things which are not valid ASCII or UTF8
15:56:53 <mm_freak> @let digitsIn n = reverse . map (`mod` n) . takeWhile (> 0) . iterate (`div` n)
15:56:54 <lambdabot>  Defined.
15:57:02 <mm_freak> @let digits = digitsIn 10
15:57:03 <lambdabot>  Defined.
15:57:10 <augur> > digits 1729
15:57:12 <lambdabot>   [1,7,2,9]
15:57:31 <augur> > sum $ map (^2) $ digits 1729
15:57:33 <lambdabot>   135
15:57:37 <augur> \o/
15:57:39 <heatsink> maurer_: You can use decode :: [Word8] -> String
15:57:54 <mm_freak> for that skip the 'reverse' step
15:57:54 <augur> @let happStep = sum . map (^2) . digits
15:57:55 <lambdabot>  Defined.
15:57:58 <augur> @let happyStep = sum . map (^2) . digits
15:57:59 <lambdabot>  Defined.
15:58:01 <heatsink> :t runInteractiveCommand
15:58:02 <lambdabot> Not in scope: `runInteractiveCommand'
15:58:05 <augur> > happyStep 1729
15:58:07 <lambdabot>   135
15:58:10 <augur> > happyStep 135
15:58:12 <lambdabot>   35
15:58:15 <augur> > happyStep 35
15:58:17 <lambdabot>   34
15:58:19 <mm_freak> 'digits' is better as a least-significant-first function
15:58:19 <augur> > happyStep 34
15:58:21 <lambdabot>   25
15:58:23 <augur> > happyStep 25
15:58:25 <lambdabot>   29
15:58:27 <augur> > happyStep 29
15:58:29 <lambdabot>   85
15:58:31 <mauke> > iterate happyStep 1729
15:58:33 <lambdabot>   [1729,135,35,34,25,29,85,89,145,42,20,4,16,37,58,89,145,42,20,4,16,37,58,89...
15:58:36 <augur> :|
15:58:37 <mm_freak> augur: could you flood your local GHCi with that, please?
15:58:54 <augur> mm_freak: but then i cant answer mauke's question@
15:59:08 <augur> > any
15:59:08 <lambdabot>   Overlapping instances for GHC.Show.Show
15:59:09 <lambdabot>                              ((a ->...
15:59:49 <augur> @let happy = any (1==) . iterate happyStep
15:59:50 <lambdabot>  Defined.
15:59:55 <augur> > happy 1729
15:59:57 <mauke> :t elem
15:59:57 <mm_freak> augur: you can…  either paste to hpaste or use 'iterate'
15:59:58 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
15:59:58 <lambdabot>   mueval-core: Time limit exceeded
16:00:09 <augur> oh my. im guessing 1729 isnt happy
16:00:47 <augur> its not happy if it repeats, otherwise its happy if its ever 1
16:00:56 <elliott> Is Int ever smaller than 32-bits according to the report?
16:01:13 <mm_freak> > nub $ cycle [0..9]
16:01:24 <heatsink> elliott: The report only guarantees that Int contains [-2^29 .. 2^29]
16:01:28 <lambdabot>   thread killed
16:01:39 <mm_freak> > nub $ cycle [0..999]
16:01:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:01:45 <heatsink> Might be useful for implementations that use bit tags to distinguish ints and pointers
16:02:14 <augur> anyway, mauke, thats what makes a number happy. :p
16:02:21 <TTimo> args0: http://hpaste.org/43703/args0s_homework
16:02:52 <djahandarie> nub . cycle = nub ?
16:03:11 <elliott> heatsink: Heh.
16:03:12 <mm_freak> :t nub
16:03:13 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:03:15 <mm_freak> :t nub . cycle
16:03:16 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:03:17 <augur> oh actually its happy if it cycles at all
16:03:17 <augur> ok
16:03:19 <augur> thats it
16:03:25 <mm_freak> djahandarie: but still no
16:03:30 <djahandarie> I know
16:03:53 <mm_freak> well, "not always"
16:04:07 <augur> is there a function for testing for cycles?
16:04:08 <mm_freak> nub . cycle = nub for [1..]
16:04:16 <mm_freak> augur: see cycle finding algorithms
16:04:26 <augur> mm_freak: cycles in lists?
16:04:34 <mm_freak> augur: there is a wikipedia page about it
16:04:35 <mm_freak> yes
16:04:38 <augur> hm
16:05:02 <djahandarie> > take 5 . nub . cycle $ [1..]
16:05:05 <lambdabot>   [1,2,3,4,5]
16:05:05 <mm_freak> augur: http://en.wikipedia.org/wiki/Cycle_detection
16:05:08 <djahandarie> > take 5 . nub . cycle $ [1,2]
16:05:23 <heatsink> Hmm, the report also guarantees that Int is bounded, which would preclude an implementation using arbitrary-precision integers
16:05:24 <lambdabot>   thread killed
16:05:28 <mm_freak> and thanks to our beloved laziness…
16:05:33 <djahandarie> Are any of those "not always" cases actually useful?
16:05:43 <mm_freak> > take 500 . nub . cycle $ [1..]
16:05:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:05:48 * hackagebot graph-rewriting-cl 0.2.2 - Interactive graph rewriting system implementing various well-known combinators  http://hackage.haskell.org/package/graph-rewriting-cl-0.2.2 (JanRochel)
16:06:10 <mm_freak> djahandarie: certainly…  for example for optimizing purposes
16:06:36 <mm_freak> heatsink: on the other hand the report gives you Integer
16:07:49 <djahandarie> > take 6 . nub . cycle $ [1,1,2,3,4,5,5,6]
16:07:51 <lambdabot>   [1,2,3,4,5,6]
16:07:58 <djahandarie> > take 6 . nub $ [1,1,2,3,4,5,5,6]
16:08:00 <lambdabot>   [1,2,3,4,5,6]
16:10:54 <aristid> > nub . cycle $ [1,1,2,3,4,5,5,6]
16:11:09 <lambdabot>   thread killed
16:11:15 <aristid> oO
16:12:22 <augur> in base 2, all numbers are happy. how interesting!
16:12:55 <augur> same in base 4, apparently
16:12:58 <elliott> Is there a way to re-export a module without listing all explicit exports?
16:13:02 <heatsink> mm_freak: Some people want arbitrary precison integers to be the default.  Python 3 does it.
16:13:03 <augur> theres no other base where this is true less that 500m
16:13:06 <elliott> i.e. I have "module Foo where", and I don't want to list all the exports,
16:13:09 <elliott> but I want to re-export some modules.
16:13:16 <mm_freak> heatsink: they are the default in haskell
16:13:45 <TTimo> what should I use if I want to apply a bunch of functions to the same input?
16:13:45 <elliott> not really
16:13:48 <elliott> not when all the functions return Ints
16:14:01 <dobblego> TTimo: sequence
16:14:16 <dobblego> where bunch=Traversable
16:14:24 <mauke> elliott: module Foo (module Foo, module Bar) where ... -- IIRC
16:14:26 <mm_freak> elliott: those functions use non-defaults, but if you say just '3' and there is no further type constraint, then it defaults to 3 :: Integer
16:14:33 <elliott> mauke: Hmm, and that still exports all the other things in the module?
16:14:43 <elliott> mm_freak: yeah, but the stdlib is really part of the language.
16:14:43 <dobblego> sequence :: Traversable bunch => bunch (a -> b) -> a -> bunch b
16:15:20 <mm_freak> elliott: parts of it are part of the report, yes, what's wrong with that?
16:15:23 <heatsink> Huh, I didn't know Integer took precedence over Int.
16:15:31 <mm_freak> Int was chosen for list indexing for reasons of speed
16:15:34 <elliott> mm_freak: I just mean that it's a bit of an edge-case argument.
16:15:42 <mm_freak> it would be pointless to use Integer for indexing
16:15:42 <elliott> because using Integer everywhere is very hard in real code
16:16:37 <Saizan> elliott: module Foo (module Foo, ..) where ,,
16:16:48 <elliott> Saizan: that gives me a parse error on ..
16:16:48 <mm_freak> elliott: dunno, i write a lot of haskell, and almost never have to convert between Integer and Int
16:16:49 <elliott> oh
16:16:50 <elliott> I see
16:16:51 <elliott> clever!
16:16:53 <elliott> thanks
16:17:37 <elliott> @hoogle m a -> m ()
16:17:37 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
16:17:37 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
16:17:37 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
16:17:44 <elliott> hmm, isn't there an "ignore" function>
16:17:47 <elliott> *function?
16:17:56 <mm_freak> why would you want that?
16:18:00 <mm_freak> use (>>)
16:18:17 <mm_freak> if you insist:
16:18:23 <mm_freak> @let ignore = (() <$)
16:18:24 <lambdabot>  Defined.
16:18:51 <mm_freak> :t ignore
16:18:53 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
16:19:08 <elliott> mm_freak: that's exactly what i defined :)
16:19:13 <elliott> also, just because it reads better than >> return ()
16:19:53 <parcs> :t (<$)
16:19:54 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:20:14 <gwern> elliott: Control.Monoid.void is in ghc 7
16:20:15 <mm_freak> you might want to actually return the result of your computation instead of forcing your user not to care about it
16:20:27 <mm_freak> :t fmap . const
16:20:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
16:21:08 <gwern> every time I see someone ask after Control.Monad.void I feel that shoving it through the libraries@ process was worthwhile
16:21:12 <mm_freak> your user can still decide to ignore the result (by using (>>) instead of (>>=))
16:21:28 <mm_freak> gwern: what's that?
16:21:50 <gwern> mm_freak: it's fmap . const.
16:21:58 <gwern> the functor generalization
16:22:01 <elliott> gwern: unfortunately i'm on 6.12.3 :)
16:22:02 <gwern> of >> return ()
16:22:06 <TTimo> dobblego: ty .. (trying to make that work .. says "No instance for (Monad ((->) BitString))")
16:22:16 <elliott> IMO void should be called ignore though :P
16:22:18 <dobblego> import Control.Monad.Instances
16:22:24 <gwern> elliott: ah, but now you have a reason to upgrade! or at least leave yourself a note TODO: remove this when using GHC 7
16:22:34 <mm_freak> IMO it should never be used
16:22:35 <elliott> gwern: but i'd still need to alias it to ignore!
16:22:43 <TTimo> oh lol
16:22:46 <elliott> mm_freak: I _have_ to return m ()
16:22:49 <elliott> it's in an interpreter loop
16:22:56 <elliott> so that's what i'm doing, ignoring the result
16:22:59 <dobblego> TTimo: you could also use Data.Traversable.sequenceA (recommended imo)
16:23:04 <elliott> with a sugary function, is there anything wrong with sugar?
16:23:06 <gwern> elliott: well, I originally wanted ignore, but then dons or someone waltzed in and said 'but we already have a function like this in Foreign!' and I just wanted the damn function in, so I said 'fine we'll call it void, happy?'
16:23:17 <elliott> gwern: bah! :)
16:23:27 <elliott> gwern: lol, I'm gonna propose that data.map's functions are all renamed
16:23:29 <gwern> elliott: sausage making has nothing on FLOSS lobbying
16:23:30 <elliott> we have functions like that in Prelude!
16:23:43 <gwern> elliott: well, removing Data.Map.map was on my agenda
16:23:52 <mm_freak> elliott: so you're using a broken interface?
16:24:05 <dobblego> > Data.Traversable.sequenceA [(+1), (*2), (/7)] 493 -- TTimo 
16:24:06 <lambdabot>   [494.0,986.0,70.42857142857143]
16:24:15 <mm_freak> :t forkIO
16:24:16 <lambdabot> Not in scope: `forkIO'
16:24:24 <mm_freak> :t Control.Concurrent.forkIO
16:24:25 <lambdabot> IO () -> IO GHC.Conc.ThreadId
16:24:42 <elliott> mm_freak: Umm, no.
16:24:44 <TTimo> interesting
16:24:45 <elliott> I'm using a generic interface.
16:24:49 <elliott> One that pops a value from the stack and returns it.
16:24:59 <elliott> If you want to ignore that value, you can do >> return (), or, more elegantly, "ignore pop".
16:25:02 <elliott> So?
16:25:22 <mm_freak> elliott: my point is that the decision to ignore it is wrong in the first place
16:26:23 <elliott> mm_freak: ...why?
16:26:30 <elliott> mm_freak: It's an interpreter loop. Just like IO ().
16:26:33 <elliott> It has no result.
16:28:50 <mm_freak> is wrong → may be wrong
16:29:04 <parcs> @type fix $ forever . Control.Concurrent.forkIO -- haskell's version of a fork bomb
16:29:05 <lambdabot> IO ()
16:29:08 <mm_freak> but perhaps i'm thinking too much in the direction of 'forkIO', which has a stupid type
16:29:12 <parcs> try it!
16:29:36 <elliott> try it on all your machines!
16:29:40 <elliott> especially your production ones!
16:30:01 <mm_freak> parcs: shouldn't break anything
16:30:57 <parcs> mm_freak: it'll cause the system to swap like hell
16:31:03 <HRuivo> Hi, I'm fairly new to Haskell and I'm having a problem with data types using the read comand to read the list from a file
16:31:26 * heatsink wishes withMany weren't in Foreign, it's useful in general
16:31:27 <HRuivo> I'm getting an error (Ambiguous type variable `a' in the constraint) while doing that
16:31:34 <gwern> hm. I wonder if those forks would be non-allocating loops. that could be problematic
16:31:49 <mm_freak> parcs: +RTS -M32m saved me
16:31:53 <heatsink> HRuivo: Give an explicit type to your result
16:31:54 <HRuivo> I'm really lost on how to fix that. (heres the code for reference http://hpaste.org/43704/read)
16:32:02 <heatsink> HRuivo: let x = read y :: [Int]
16:32:08 <mm_freak> parcs: but there are much easier ways to kill your system
16:32:09 <gwern> heatsink: why not suggest it be moved, re-exported from Foreign, and toss into a warn pragma and then remove it from Foreign in a few years?
16:32:14 <mm_freak> > reverse [1..]
16:32:18 <lambdabot>   mueval-core: Time limit exceeded
16:32:36 <parcs> true
16:32:44 <parcs> *tries that(
16:32:53 <TTimo> legal bst = foldl (&&) True $ sequenceA [ rule1, rule2, rule3, rule4 ] bst -- dobblego ty :)
16:33:03 <HRuivo> heatsink I forgot to explicit the type, thanks, it worked :D
16:33:36 <heatsink> I don't know how to do that, gwern
16:33:48 <gwern> heatsink: you send emails to the libraries list. for a year or two.
16:33:51 <mun> is \lambda a b. a an identity function?
16:33:54 <heatsink> heh
16:34:00 <copumpkin> mun: no
16:34:12 <copumpkin> you in agda-mode?
16:34:21 <gwern> heatsink: I think it took a year and a few months from my first email to my patch being applied to GHC HEAd
16:34:24 <mun> ok
16:35:00 <heatsink> inertiaaaaa
16:35:21 <parcs> hmm, maybe forkOS would be deadlier..
16:35:27 <copumpkin> why?
16:35:34 <copumpkin> forkOS isn't anything special
16:35:59 <copumpkin> forkOS should live in Foreign.Something
16:36:19 <mkscrg> trivial question: is there a built-in function that takes a value x and makes a tuple (x, x)?
16:36:33 <mm_freak> gwern: i don't know what exactly a "non-allocating loop" is, but 'fix (fmap (const ()) . forkIO)' would kill me without -M
16:36:34 <parcs> :t join (,)
16:36:34 <dankna> hmm
16:36:38 <lambdabot> forall a. a -> (a, a)
16:36:49 <parcs> copumpkin: yeah, i misread the documentation
16:37:10 <dankna> so I'm thinking about how to handle garbage collection with my binding to Objective-C and Cocoa that I'm working on
16:37:27 <dankna> I'm not quite at the point of being ready to implement that just yet, but I'm getting there...
16:37:31 <gwern> mm_freak: the GHC RTS only runs when a thread requests more memory or something like that. if a thread never asks more memory but just loops... this means things like signals between threads or timeouts or whatnot are not guaranteed to work. that caused a lot of problems with mueval
16:37:43 <dankna> the big problem is that there are two heaps, the Haskell heap and the ObjC heap
16:37:51 <mm_freak> gwern: ah, i see
16:38:05 <dankna> and indeed, two garbage collectors, one on either side
16:38:10 <mkscrg> parcs: ah of course, thanks
16:38:21 <dankna> I looked into the feasibility of hooking Apple's GC somehow but it doesn't look like that's an option
16:38:39 <copumpkin> why bother using their GC?
16:38:51 <mm_freak> well, i think that forkOS is like masturbation without the payoff…  you can force a thread to be bound, but you can't force two threads to run in separate OS threads
16:38:55 <dankna> well, because we ObjC objects to be collected
16:39:10 <copumpkin> forkOS has a very specific purpose
16:39:11 <dankna> we can't have everything live on the Haskell side because we need to interoperate with libraries that need to do their own allocation
16:39:15 <copumpkin> if you need it, then you use it
16:39:19 <copumpkin> if you don't, then don't :P
16:39:20 <mm_freak> copumpkin: sure
16:39:26 <ddarius> forkOS: Brought to you by TLS
16:39:41 <mm_freak> but if you had a real "fork haskell thread with dedicated OS thread", you could easily write a safe timeout function
16:39:43 <copumpkin> if we put it in Foreign, people would stop mistaking it for something else
16:40:12 <mm_freak> well, at least rename it
16:40:16 <mm_freak> forkBound
16:40:24 <monochrom> forkScary
16:40:24 <copumpkin> forkBoundForForeignCalls
16:40:38 <monochrom> err, no camel'case! fork'scary
16:40:45 <copumpkin> mm_freak: it's still free to run on any capability for everything but foreign calls
16:40:51 <dankna> anyway, the situation if we do nothing clever is not that bad
16:40:59 <ddarius> We're getting to monochrom.
16:41:00 <dankna> each heap will be collected independently by its own collector
16:41:26 <dankna> objects referenced across the FFI boundary, however, will never be collected unless we do something at least mildly intelligent
16:41:50 <copumpkin> :t camel_case
16:41:51 <lambdabot> String -> String
16:42:10 <copumpkin> @botsmack
16:42:11 <lambdabot> :)
16:43:45 <dankna> ... I will continue this monologue in a sec, I need to take my laptop to the other room
16:46:29 <dankna> there.  so.  to be at least mildly intelligent we'd like to know when references across the boundary go away, so that we can return those objects to the general pool of things that are potentially GCable
16:46:47 <dankna> I'm not quite sure offhand how to do that, although I suspect weak pointers are involved somehow :)
16:47:01 <dankna> to be more intelligent, we want to deal with the case of cross-boundary garbage
16:47:31 <dankna> I'm currently reading some papers on generational GC, with the thought that it's similar to tracking references across generation boundaries.
16:47:50 <dankna> and hopefully something will occur to me.
16:47:54 <heatsink> I don't think you can do that without GC support.  Specifically, you can't detect cross-boundary garbage cycles without cooperation between both domains.
16:48:16 <elliott> Can you catch exitSuccess and the like from within IO/
16:48:17 <dankna> well - I can certainly have code written on either side
16:48:18 <elliott> *IO?
16:48:29 <dankna> what sort of cooperation do you think is necessary?
16:49:17 <dankna> finding the pointers across the boundary is not the problem; indeed, we have to go to some effort to create them at all
16:52:00 <dankna> I do think it's possible to at least hook into the write barrier of Apple's libauto, also
16:52:07 <dankna> although I haven't yet confirmed that
16:53:00 <heatsink> What you want is for an object to be retained if it's reachable from a root in the Haskell domain or a root in the ObjC domain.
16:53:09 <NemesisD> is there such a concept as record default values
16:53:14 <dankna> yes, indeed
16:53:27 <heatsink> However, the Haskell GC is conservative: it retains an object if it's reachable from a root in the Haskell domain, or if it's reachable from the ObjC domain.
16:53:55 <dankna> the corresponding thing is true of the ObjC GC, yeah
16:54:07 <heatsink> So essentially all cross-domain pointers are roots.
16:54:14 <dankna> yes, that's the default state of affairs
16:54:37 <dankna> but if you can detect that an object SHOULD be garbage, you can dispose of its StablePtr by hand
16:54:59 <chopin> i'm a beginner, i have something like this http://pastebin.com/aSBrm1sk, is it possible to make it construct with getLines, by asking number of Adults ? number of Children ? Names ... ?
16:55:02 <heatsink> If you have a garbage Haskell object pointing to a garbage ObjC object, then each collector conservatively assumes that its object is live, and concludes that the other object is also live.
16:55:18 <heatsink> ah, the ObjC object points back to the Haskell object to make a cycle
16:55:23 <dankna> yes, indeed.  that's what I want to avoid.
16:56:02 <dankna> I'm aware that this is a hard problem, possibly an unsolved one
16:56:18 <dankna> I'm interested in at least working on it for a little bit to see if I can make any headway
16:57:01 <heatsink> You might want to consider Python's GC's method
16:57:02 <dankna> for example, an analogous thing happens in webbrowsers with two heaps, one of DOM nodes and one of JS nodes
16:57:13 <dankna> why, what does Python do?
16:58:38 <heatsink> The Python runtime cannot find all the roots, because it can interoperate with C code that doesn't mark roots.  It uses reference counting, which collects non-cyclic garbage.
16:58:46 <dankna> hmm
16:59:02 <heatsink> I don't know the details of the GC, but it's kind of like mark-sweep
16:59:06 <dankna> well, I was assuming there would be a count of cross-heap references, yes
17:00:14 <heatsink> It involves decrementing reference counts each time it follows a reference to an object; if the reference count falls to zero, it's safe to deallocate.
17:00:23 <dankna> right
17:00:28 <dankna> oh, yes, I see
17:00:29 <heatsink> Otherwise it resets the reference count to its original value.
17:00:30 <dankna> that's clever
17:02:20 <dobblego> TTimo: I think you want foldr instead of foldl, and this function is in Data.Foldable (and)
17:17:36 <args0> TTimo: there?
17:18:20 * ddarius is glad he started straight razor shaving, but he isn't glad be bought a brush.
17:24:44 <args0> TTimo: I checked the output of the program, please get back to me thanks
17:35:04 <aavogt> does somebody know a better way to write this function http://hpaste.org/43705/diagonal_of_nested_lists ?
17:36:18 <Jafet> Not really the diagonal, eh
17:37:02 <Jafet> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/src/Control-Monad-Omega.html#diagonal
17:37:29 <Jafet> Bah, that one's also named diagonal
17:37:38 <aavogt> it does the same thing?
17:37:39 <nosila> http://hpaste.org/43707/project
17:37:43 * NemesisD shakes fist at cmdargs for being obtuse
17:37:55 <Jafet> I don't know; does it?
17:38:10 <nosila> the hell is worng with my case and the atribution of the SIM and NAO (data P = SIM | NAO in another module)
17:38:34 <mm_freak> > map head . zipWith drop [0..] $ ["abc", "def", "ghi"]
17:38:39 <lambdabot>   mueval-core: Time limit exceeded
17:38:53 <mm_freak> huh?
17:39:03 <monochrom> "penalizacao <- NAO" is very confused
17:39:13 <mm_freak> > zipWith drop [0..] $ ["abc", "def", "ghi"]
17:39:14 <lambdabot>   ["abc","ef","i"]
17:39:27 <aavogt> Jafet: it does, but I really don't want the concat in there
17:39:28 <nosila> dont really know how i'm suposed to do that monochrom: 
17:39:35 <mm_freak> > map head . zipWith drop [0..] $ ["abc", "def", "ghi"]
17:39:38 <lambdabot>   "aei"
17:39:38 <nosila> that was just a try
17:39:40 <monochrom> just delete both "penalizacao <- NAO" and "penalizacao <- SIM".
17:39:46 <Zao> nosila: You seem to be using extraneous swear words.
17:39:48 <mm_freak> lambdabot a bit unter load
17:40:02 <mm_freak> > map head . zipWith drop [0..] $ [[1,0,0], [0,1,0], [0,0,1]]
17:40:03 <nosila> Zao: hum what?
17:40:04 <lambdabot>   [1,1,1]
17:40:23 <nosila> if i do that it says GUI\UtenteUI.hs:149:4: parse error on input `return'
17:40:47 <mm_freak> @ aavogt 
17:40:49 <Zao> nosila: Out of curiousity, what were you trying to achieve by "penil <- NAO"?
17:41:25 <gwern> > 2011 - 1969
17:41:27 <lambdabot>   42
17:41:38 <jssanders> what is the best way to resolve the problem of a package that require two dependencies that each require a different version of mtl?
17:41:41 <nosila> Zao: changing that in a data
17:41:45 <monochrom> line 14 needs to be "    };" you need a semicolon there.
17:41:52 <TTimo> dobblego: you mean not having to do both a sequence and a fold? .. 
17:42:06 <dobblego> TTimo: I mean the foldl (&&) True
17:42:13 <Zao> nosila: It will not change anything, it will just make a local binding in the do block.
17:42:13 <dobblego> @type Data.Foldable.and
17:42:14 <lambdabot> forall (t :: * -> *). (Data.Foldable.Foldable t) => t Bool -> Bool
17:42:22 <mm_freak> or, well…
17:42:27 <dobblego> > Data.Foldable.and [True, True, False]
17:42:28 <lambdabot>   False
17:42:29 <nosila> Zao: like, i've data User with some types, i'm trying to do functions that change the User type that i want
17:42:34 <Zao> If you want to modify the field in u, you should modify the field in u.
17:42:36 <nosila> and after that i return the changed user
17:42:47 <nosila> how come?
17:42:54 <glguy> http://hpaste.org/paste/43707/project_annotation#p43709
17:42:58 <glguy> I'm guessing he meant this
17:42:58 <mm_freak> > zipWith (flip (!)) [0..] $ ["abc", "def", "ghi"]
17:42:59 <Zao> Something like  penil' <- case penil of { ... }; return u { penil = penil' }
17:43:00 <lambdabot>   Couldn't match expected type `GHC.Arr.Array a e'
17:43:00 <lambdabot>         against inferred t...
17:43:05 <mm_freak> > zipWith (flip (!!)) [0..] $ ["abc", "def", "ghi"]
17:43:07 <lambdabot>   "aei"
17:43:24 <mm_freak> there we go…  probably the fastest diagonal function you can get for lists
17:43:27 <Zao> That is, propagate out the new value from the case, and use that to update the field, yielding a new Utente.
17:43:30 <glguy> nosila: is that what you meant?
17:44:51 <aavogt> mm_freak: actually my example is what I'm looking for
17:45:28 <zzing> Does this mean anything, and if so what? (+) =<< join (+)
17:45:45 <glguy> ?unpl (+) =<< join (+)
17:45:45 <lambdabot> (((+) >>= \ a -> a) >>= (+))
17:45:58 <glguy> :(
17:46:00 <aavogt> mm_freak: so not really the diagonal, but the diagonals if you rotated the matrix
17:46:26 <zzing> glguy: Does that mean it isn't easy to figure out?
17:46:34 <zzing> :t join
17:46:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:47:05 <nosila> damn
17:47:08 <djahandarie> @. unpl pl id
17:47:09 <lambdabot> (\ a -> a)
17:47:27 <nosila> was hoping this worked like by reference  or something like that
17:47:30 <zzing> @src join
17:47:30 <lambdabot> join x =  x >>= id
17:47:35 <nosila> thanks for clearing things up
17:47:40 <aavogt> the stripe function linked in Control.Monad.Omega is exactly what I was looking for
17:47:48 <nosila> glguy: thanks ;)
17:47:50 <glguy> zzing: join (+) is   (2*)
17:47:52 <Axman6> zzing: for functions, join f x = f x x
17:48:04 <nosila> Zao: could you please put that code here  http://hpaste.org/paste/43707/project_annotation#p43709  ???
17:48:11 <glguy> (+) =<< (2*)  is    \ x ->  x + 2 * x
17:48:17 <TTimo> dobblego: would foldr take advantage of the lazy eval and stop checking at the first False? or I would have to use Data.Foldable.and for the purpose ?
17:48:31 <glguy> assuming commutativity :)
17:48:39 <dobblego> TTimo: yes foldr would do that, no you don't need to use Data.Foldable, there is and in Prelude, but it is specific to lists
17:49:03 <zzing> merci :-)
17:49:27 <glguy> (or just   (3*)
17:52:11 <Zao> nosila: http://hpaste.org/43710/field_updates
17:52:14 <mm_freak> aavogt: the antidiagonal?
17:52:21 <Zao> nosila: I won't update your code, as then you'll not learn anything :D
17:53:12 <nosila> Zao: no no i dont want you to update my code i just wanted to see yours a lilbit more explained ;)
17:53:38 <pedro3005> does haskell automatically memoize functions for me?
17:53:45 <Zao> pedro3005: No.
17:53:55 <pedro3005> odd, I heard somebody say that
17:53:58 <Zao> pedro3005: Some compilers might do some limited CSE, but that's about it.
17:54:18 <Axman6> pedro3005: it would be possible to do so, but it would not make much sense to do so in most cases
17:54:27 <pedro3005> how would I go about memoizing a function then?
17:54:40 <codolio> Shared values are memoized.
17:54:41 <Axman6> for example, (+) on Int64 would need to store 2^128 results
17:54:44 <Zao> > let x = 9001^3; print (x, x) -- x's thunk will likely only be evaluated once.
17:54:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:55:08 <Zao> Err, in, not ; :D
17:55:23 <Zao> pedro3005: Imagine if every single pure function call would be memoized. You'd run out of memory in a jiffy.
17:55:30 <codolio> Memoizing (+) on Int is probably a waste even if you have the memory.
17:55:39 <Axman6> very much so
17:55:54 <codolio> It would probably take longer to look up the answer than to compute it.
17:55:56 <shapr> lazy memoizing?
17:55:56 <Zao> pedro3005: You could do some memoizing by being in the Writer monad, and store any computed value.
17:55:59 <pedro3005> Axman6, well, you don't memoize all the values before-hand, you just keep the ones you already computed
17:56:08 <FauxFaux> codolio: Probably? :)
17:56:12 <Axman6> pedro3005: how would you do that efficiently?
17:56:26 <monochrom> there was a great plan to record a lot of prime numbers on a cdrom :)
17:56:36 <Zao> monochrom: I do that for my Eulers.
17:57:03 <Zao> Well, primes under 100 million, but that's a lot for most uses.
17:57:10 <Zao> (totients too, as they come in handy)
17:57:15 <aavogt> mm_freak: yes
17:57:16 <nosila> Zao: what's the diference between data Foo = Foo fooBar fooBaz  (having them previosly typed) ??
17:57:19 <monochrom> the great plan was "store large primes on a cdrom so you could crack RSA by trying those primes"
17:57:29 <mm_freak> > map last . zipWith ($) (iterate (init .) id) $ ["abc", "def", "ghi"]
17:57:31 <lambdabot>   "ceg"
17:57:35 <mm_freak> @ aavogt 
17:57:41 <Zao> nosila: Oh right, I for some reason thought that penil was a field.
17:58:02 <FauxFaux> Zao: 100 million?  O_o  Up to 75k has served me well. ¬_¬
17:58:05 <Axman6> monochrom: i found out the other day that you can store something like the first 20,000,000 prime numbers using one byte each if you just record the distance between the previous and next primes. 
17:58:10 <nosila> Zao: im lost.. looool
17:58:13 <Axman6> which i thought was kinda cool
17:58:14 <Zao> nosila: data Foo = Foo Int String  and  data Foo' = Foo' { fooBar :: Int, fooBaz :: String } are similar in structure.
17:58:34 <Zao> nosila: The only difference is that the former (with fields) can use the field names to access a particular part of the data.
17:58:41 <Axman6> > logBase 10 (2^64)
17:58:43 <lambdabot>   19.265919722494793
17:58:52 <Zao> nosila: You can say things like (fooBar u) to get the value of the fooBar field.
17:58:53 <ddarius> "I heard John say to Sally that Tim said that Mary said that she'd heard that all function were memoized in Haskell."
17:59:07 <nosila> uuhhmm
17:59:08 <aavogt> > zipWith ($) (iterate (init .) id) $ ["abc", "def", "ghi"]
17:59:10 <lambdabot>   ["abc","de","g"]
17:59:14 <Zao> Or (u { fooBar = 9001 }) to get a value like u, but with the fooBar field replaced.
17:59:50 <aavogt> mm_freak: basically http://hpaste.org/paste/43705/diagonal_of_nested_lists_anno#p43706 or the stripe here http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/src/Control-Monad-Omega.html#diagonal
17:59:58 <Zao> Can you show the definition of the Utente type?
18:00:47 <Zao> If you do not have any fields, you cannot do this any cleaner than extracting all the parts like you have done, and reconstructing it with the new ones.
18:01:01 <mm_freak> aavogt: how about not using lists in the first place?  lists are a bad datastructure here
18:01:05 <pordan30> If a variable isn't a member of a typing context, then if a term is well typed in a context it is well typed in a context with that variable by weakening. Is there a similar rule that lets you conclude that given a term M and a context (G, x : T), if x is not a member of FV(M) then M is well-typed in G? (i.e., a name for it).
18:01:15 <aavogt> mm_freak: the matrix is infinite
18:01:30 <nosila> Zao: so, with that you can change values of a data like you're changing a value "by reference" as in C# / Java? (the oposite of having to "create" a new one with the old values)
18:01:30 <mm_freak> aavogt: vertically infinite?
18:02:08 <aavogt> and horizontally infinite. Basically this method done lazily http://en.wikipedia.org/wiki/Romberg's_method
18:02:20 <nosila> data Utente = Utente_Empty | Utente Nome BI Tipo Profissao Morada ListaVeiculos Penalizado 	deriving (Show, Read)
18:02:50 <mm_freak> aavogt: a horizontally infinite matrix doesn't have an antidiagonal
18:02:52 <nosila> they are all Int's and Strings apart from 2
18:03:54 <Zao> nosila: In a pure context, you cannot modify anything. You can only create new and reuse parts of old.
18:03:56 <args0> TTimo: there?
18:04:03 <aavogt> mm_freak: I didn't say I wanted an antidiagonal. Look at my example code that works
18:04:17 <Zao> nosila: You need to use iorefs or other explicitly mutable things for that.
18:04:36 <nosila> Zao: hum ok, thanks a lot for the help.... lol that's a lil too much for me right now
18:04:39 <Zao> nosila: The key thing here is that you are not modifying the old data. You are just implicitly using most of the old data to construct new data.
18:04:50 <TTimo> args0: sure am
18:04:57 <nosila> true true
18:05:08 <mm_freak> aavogt: well, you said "yes", when i asked you
18:05:29 <args0> TTimo: is private chatting permitted here?
18:05:41 <aavogt> sorry about the confusion
18:06:23 <shapr> TTimo: I often get you confused with the Finnish Gnome graphic designer who uses the same irc nick.
18:07:22 <TTimo> does he use two T's as well
18:07:57 <TTimo> the Finnish guys usually go by simply 'timo' (which happens to be my username usually)
18:14:22 <shapr> Whoa, I just found http://codegolf.stackexchange.com/ !
18:16:30 <nosila> Zao: i'm getting GUI\UtenteUI.hs:146:8: parse error on input `NAO'
18:16:36 <nosila> in the case
18:16:40 <nosila> the pattern
18:17:43 <ddarius> pordan30: "strengthening"
18:20:22 <pordan30> I'm not sure whether I should be surprised by that. Thanks.
18:21:28 <pordan30> I wonder if there's an exhaustion lemma too
18:23:50 <nosila> http://hpaste.org/43711/error
18:24:09 <nosila> Zao: http://hpaste.org/43711/error
19:00:04 <xplat> 17:42 < c0w> and the truth type must be a boolean algebra
19:00:20 <xplat> booooo, where's the heyting algebra support?
19:00:56 * ddarius only uses logic that works in an arbitrary topos.
19:01:27 <Kaidelong> any idea when instance chaining might make it into GHC?
19:04:00 <slack1256> folks i need a tip, how do you know when use a parameter when declaring instances?
19:04:22 <slack1256> because sometimes i think for example that Maybe could be declared a monad as
19:04:59 <slack1256> "instance Monad (Maybe a ) where" instead "instance Monad Maybe where"
19:05:13 <Axman6> @src Monad
19:05:14 <lambdabot> class  Monad m  where
19:05:14 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:05:14 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:05:14 <lambdabot>     return      :: a -> m a
19:05:14 <lambdabot>     fail        :: String -> m a
19:06:21 <slack1256> yeah but for example this guy declared Either a monad like this
19:06:36 <slack1256> instance Monad (myEither a) where
19:06:46 <Kaidelong> :k (Monad m) => m
19:06:47 <lambdabot>     `m' is not applied to enough type arguments
19:06:47 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
19:06:47 <lambdabot>     In the type `(Monad m) => m'
19:06:56 <ddarius> When you start thinking it will be clear.
19:07:09 * Kaidelong hmms
19:07:10 <Kaidelong> @botsnack
19:07:10 <lambdabot> :)
19:07:15 <Axman6> Either takes two parameters, here m is (MyEither e), when the full type is MyEither E a
19:07:17 <azaq231> :k Monad
19:07:18 <Axman6> e*
19:07:18 <lambdabot>     Class `Monad' used as a type
19:07:18 <lambdabot>     In the type `Monad'
19:07:25 <slack1256> http://hpaste.org/43712/monad_maybe_and
19:07:32 <slack1256> here is ow is defined
19:07:34 <slack1256> *how
19:08:26 <Axman6> you could have a type: data Three a b c = One a | Two b | Three c and define a monad instance: instance Monad (Three a b) where
19:08:54 <Axman6> notice it's just missing its last parameter, like with Either
19:09:10 <slack1256> yeah 
19:09:58 <ddarius> All you have to do is substitute through for m in the methods, and it should be quite clear why it has to be one way and not another.
19:10:45 <slack1256> ooo now i see
19:11:03 <slack1256> axman you are right m == (MyEither e)
19:11:09 <slack1256> *Axman6
19:11:10 <Axman6> yes
19:17:32 * hackagebot piki 0.5.0 - Yet another Wiki format converter  http://hackage.haskell.org/package/piki-0.5.0 (KazuYamamoto)
19:18:21 <nosila> http://hpaste.org/43711/error ??
19:18:38 <nosila> anyone knows hows what's wrong with that?
19:18:49 <azaq231> slack1256: instance Monad (Maybe t) doesn't make sense, as t is then described as fixed, and there's nothing to apply (Maybe t) to in the type signature of (>>=), just to point that out - in (Either t), t is fixed as it is not relevant to the type signatures of the functions of the class Monad (and therefore, to the ensuing behaviour of the (Either t) monad).
19:20:00 <Axman6> nosila: x <- y doesn't set some variable called y like you seem to be using it. do yuo understand how do notation is desugared?
19:20:23 <Axman6> effectively what you've written in nao >>= \y ->
19:20:28 <Axman6> which doesn't mean anything
19:21:09 <Axman6> nosila: actually, which version are you asking for comments on?
19:22:49 <gwern> it's interesting to look at Hackage's upload log
19:22:59 <gwern> cabal had a really slow uptake, and yet now, it's unthinkable to not use it
19:23:03 <slack1256> \msg azaq231 but IIRC t in (Either t) define the Left type how it wouldn't be relevant
19:23:13 <stepcut> gwern: kind of like haskell itself ;)
19:23:17 * gwern is writing a little retrospective about my activities with cabal 2007-2009 or so
19:23:32 <gwern> stepcut: well, except for the 'unthinkable not to use it', part...
19:24:15 <stepcut> gwern: as far as I'm concerned -- if it can't be written in Haskell, it's not worth writing :)
19:25:05 <Kaidelong> could you make a commutative monad transformer transformer?
19:25:26 <ddarius> Kaidelong: There isn't much of a way to restrict it to only commutative monads.
19:26:18 <Kaidelong> knowing the monad transformers for both monads does not help here?
19:27:03 <azaq231> slack1256: Just look at the signatures of the functions of monad
19:27:04 <azaq231> :t (>>=)
19:27:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:28:31 <azaq231> slack1256: now what could (>>=) actually do to an Either t a which is a Left? Nothing.
19:30:48 <xplat> @tell dankna your magic google scholar keyword for the day is: distributed garbage collection
19:30:48 <lambdabot> Consider it noted.
19:30:59 <stepcut> is it just me or is the GHC 7.0.1 package for OS X really 7.0.0.20101028 ?
19:34:41 <stepcut> any word on when 7.0.2 is coming out ?
19:36:02 <slack1256> stepcut: had your distro shipped 7.0.1
19:36:18 <stepcut> slack1256: ??
19:37:35 <dankna> xplat: ooh!
19:37:36 <lambdabot> dankna: You have 1 new message. '/msg lambdabot @messages' to read it.
19:38:11 <slack1256> stepcut: sorry i didn't realize that you use OSX
19:38:11 <gwern> wow. looking over the upload log really impresses me. did I really do 150 Hackage uploads in 2008?
19:38:39 <ddarius> gwern: edwardk probably did 150 hackage uploads last week.
19:38:46 <stepcut> slack1256: ah
19:38:48 <gwern> haha. but that's just his style
19:46:41 <gwern> > 5174 - 519
19:46:43 <lambdabot>   4655
19:49:15 <gwern> hm. what is the right description for david roundy or john meachem, who refuse to use cabal?
19:49:39 <dankna> mainstreamers
19:49:45 <gwern> refuseniks, maybe
19:49:50 <dankna> mainstream being the opposite of cabal, see
19:49:52 <gwern> @wn refusenik
19:49:54 <lambdabot> No match for "refusenik".
19:49:56 <gwern> dankna: har har.
19:50:11 <dankna> http://www.wordnik.com/words/refusenik
19:50:11 <xplat> jams?
19:50:31 <xplat> wait, that would be if cabal refused them
19:51:12 <dankna> yeah, given the Soviet etymology listed there, I think the meaning is more of the thing refusing them permission to do something they want to do rather than of them refusing to use something with clear benefits
19:51:54 <xplat> actually i would go with ‘knights of djb’
19:52:34 <gwern> dankna: well, without any better term...
19:52:42 <gwern> I refuse to use luddite or conservative
19:53:03 <ddarius> gwern: Neither of those would be accurate.
19:53:05 <monochrom> purists
19:53:05 <dankna> yes, the political senses of those would overshadow the lighthearted nature of the whatchamacallit
19:53:32 <gwern> monochrom: well, I'm not sure purist is right either. I think both have their own build systems now. roundy has franchise and iirc meachem has... some sort of YAML based system
19:53:44 <dankna> Not Invented Hereians
19:53:50 <xplat> what do they call those people who build their own linux installations by just downloading tarballs and building them?
19:53:56 <gwern> dankna: a real phrase, please
19:54:01 <dankna> okay
19:54:11 <dankna> so acronymize it and tweak the spelling to make it pronounceable then
19:54:17 <dankna> NIH-ers
19:54:25 <xplat> oh, i got it
19:54:29 <xplat> NIHeretics
19:54:32 <dankna> nice
19:54:40 <gwern> it's just a parenthetical comment in a sentence on how Cabal has won, I don't want to have to link or explain a neologism!
19:54:54 <dankna> oh
19:54:55 <dankna> well
19:54:59 <dankna> holdouts
19:55:07 <dankna> I didn't understand the purpose for which you wanted the word :)
19:55:14 <gwern> unfortunately, I already used holdouts
19:55:16 <dankna> oh
19:55:20 <dankna> hm
19:55:24 <gwern> ' Long story short, Cabal has decisively defeated Autotools in the Haskell universe, and is the standard; the only holdouts are legacy projects too complex to Cabalize (GHC) or projects run by refuseniks like David Roundy and Jon Meachem.'
19:55:26 <dankna> backwards-thinkers
19:55:28 <xplat> hardcases?
19:55:49 <gwern> xplat: I'm not trying to condemn them! if I were I'd just use luddite and have done with it
19:55:55 <dankna> oh
19:55:55 <dankna> hm
19:56:01 <dankna> you know what
19:56:03 <dankna> you're overthinking this
19:56:05 <dankna> just say "people"
19:56:08 <xplat> er
19:56:29 <stepcut> gwern: now we just need to make it work !
19:56:42 <gwern> stepcut: cabal works fine
19:56:45 <xplat> eccentric is a little better than luddite
19:56:52 <gwern> xplat: still pejorative
19:57:02 <xplat> yeah, but less so
19:57:04 <stepcut> gwern: does not. I am hacking around a deficiency right now
19:57:06 <dankna> I don't think you need a special word for it
19:57:11 <ddarius> gwern: They're not Luddites either technically or by connotation.
19:57:20 <dankna> the context makes it so abundantly clear that "people" is all you need to say
19:57:20 <monochrom> the only exceptions are GHC or holdouts
19:57:23 <stepcut> gwern: it can't figure out that it should install network < 2.2.3 even though it should be able to
19:57:33 <ddarius> If they were "make is the only true way" then maybe you could use Luddite.
19:57:34 <gwern> ddarius: the implication of luddite is that they are anti-progress, which a cabal partisan would argue they are
19:57:42 <xplat> it's more just that they go off in their own direction than that they stay back, really
19:57:53 <gwern> monochrom: I'm not sure GHC is the only large haskell project which is too hard to cabalize
19:58:03 <monochrom> did I say that?
19:58:04 <xplat> dankna: only if people are familiar with at least one of the two already
19:58:14 <dankna> xplat: I'm not :)
19:58:26 <stepcut> gwern: also, cabal-install likes to install the same exact version of the package in the global and user package confs, but then when GHC merges the package databases things get all confused (because not all the code understands how to use the full package identifiers yet)
19:58:27 <gwern> monochrom: well, that's the implication of your disjunction. if something isn't using cabal, it's either GHC or it's by roundy/meachem.
19:58:40 <nosila> Axman6: sorry, wasnt here
19:58:56 <monochrom> fine. the only exceptions are legacy projects too complex to cabalize or a few holdouts
19:58:59 <gwern> stepcut: it still largely works. perfect software is rare
19:59:17 <dankna> ooh
19:59:20 <dankna> "individualists"
19:59:22 <nosila> Axman4: i really dont know, i just want it to work lol dont know how the hell am i supposed to do that... any, penalizacao there is a type = NAO | SIM
19:59:24 <xplat> honestly using ‘people’ sounds worse than almost any particular pejorative, because it's left to the reader's imagination what the hell is their problem :)
19:59:27 <nosila> http://hpaste.org/43711/error
19:59:37 <gwern> dankna: ok, that almost works :)
19:59:42 <xplat> oh, individualists is good
19:59:44 <dankna> thanks
19:59:46 <gwern> 'you damn... *individualists*'
19:59:51 <stepcut> gwern: given the number times people have recommend 'rm -rf ~/.ghc'.. I would say that it still fails far too often
19:59:52 <dankna> haha
19:59:57 <gwern> also has connotations of the Individual Eleven from anime :)
20:00:05 <dankna> nice haha
20:00:24 <gwern> You never hear about the Collectivist Eleven, do you
20:00:29 <stepcut> gwern: though it is still many times better than the pre-cabal era
20:01:02 <adu> I'm having trouble installing snap
20:01:05 <ddarius> dissenters
20:01:06 <xplat> Individual Eleven?  what is that from?
20:01:06 <adu> I installed all the deps
20:01:06 <monochrom> no, cabal-install does not like to install the same exact version of the package in the global and user package confs. the harmful advice "mix apt-get and cabal-install" does.
20:01:28 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for details
20:01:31 <adu> but now it's saying I need to install base-4.3 and I can't
20:01:40 <gwern> xplat: ghost in the shell SAC 2
20:01:42 * hackagebot yesod-json 0.0.0.1 - Generate content for Yesod using the json-types package.  http://hackage.haskell.org/package/yesod-json-0.0.0.1 (MichaelSnoyman)
20:01:43 <nosila> Hey
20:01:44 * adu cries
20:01:51 <nosila> i'm having a problem
20:01:55 <gwern> hm. franchise's homepage is dead. in fact roundy's whole domain seems dead
20:02:12 <xplat> gwern: ah.  i never got very far in the second series ...
20:02:17 <nosila> have a BinarySearchTree of a data i created, i need to change the data inside
20:02:28 <dankna> well, if they're no longer writing Haskell code, that simplifies your sentence!
20:02:37 <nosila> how am i suposed to do that?
20:03:12 <xplat> unfortunately you can never decide if a page is dead based on a single time sample ...
20:03:23 <dankna> archive.org it?
20:03:30 <gwern> dankna: well, franchise is still extant on github
20:03:32 <dankna> fair
20:03:41 <gwern> which is actually a little sad, the author of darcs using git...
20:04:03 <stepcut> monochrom: well, cabal likes to install the same exact version in my local package conf when I already have it in the global one and then things don't work
20:04:03 <xplat> nosila: you don't, you create a new BinarySearchTree that contains mostly the same data ...
20:04:18 <nosila> how come?
20:04:37 <monochrom> do you have apt-get-installed haskell lib packages?
20:04:39 <homie> why is the testsuite giving problems ?
20:04:39 <xplat> well, when you add 1 to 3, do you change 3?
20:04:45 <stepcut> monochrom: yep
20:04:50 <monochrom> there you go
20:05:22 <stepcut> monochrom: meh
20:05:45 <stepcut> monochrom: the option of only use debianized things or only use cabalized things is horrible
20:05:54 <dankna> you know
20:05:56 <dankna> I'm realizing
20:06:07 <dankna> wait
20:06:08 <dankna> never mind
20:06:11 <dankna> I'm not
20:06:16 <monochrom> if you have a pure-cabal-install suite and still see the phenomenon, I would like to know the exact sequence of events to reproduce it. if not then your situation is already covered in my exposition.
20:06:30 <nosila> xplat: how would you create a new tree like that? damn i should have used a list...
20:06:41 <monochrom> note also the ghc 6.12.1 bug. (did you read my exposition first?)
20:06:44 <xplat> stepcut: you're right, they should be able to coexist.  i don't think the fault can be entirely localized to either side, though, and those are the hardest problems to fix
20:06:56 <xplat> nosila: the same thing would apply to a list
20:07:26 <conal> i'm wondering: could we extend 'newtype' to multi-constructor, single-field-per-constructor data types when the result types are all incompatible? (for GADTs like Nat and Vec). can anyone think of a reason not to?
20:08:04 <xplat> nosila: what do you want, a tree with one more key in it?  a tree with one less key?
20:08:16 <conal> oh, hm. maybe i know a reason. for defining polymorphic functions.
20:08:24 <nosila> xplat: a tree with a key changed
20:08:31 <stepcut> monochrom: just fix it son I can mix debian and cabal installs. Then I won't have to care why it is broken :)
20:08:44 <conal> s/for //
20:09:09 <nosila> xplat: this tree is like a Users database, i need a function to change some "atributes" of a specific user
20:09:39 <monochrom> the fundamental assumption behind apt-get (generally distro installers) and the fundamental assumption behind cabal-install are in contradiction. there is no fix unless you re-architect either.
20:09:52 <xplat> nosila: oh, you want the same keys, but with a different associated value for one.  are you using an existing library?
20:10:20 <nosila> xplat: yeah that's right.... no no, i've created the tree
20:10:25 <monochrom> logically you cannot fix "b and (not b)" unless you completely flip it to "b and b" or "(not b) and (not b)"
20:10:41 <xplat> monochrom: what fundamental assumptions are in conflict?
20:11:01 <monochrom> distro installers assume monopoly. cabal-install assumes anarchy.
20:11:56 <xplat> nosila: well, you know how when you look up a key, you keep picking a child node to go down to, and return the result of calling lookup again on that node?
20:11:58 <monochrom> and then on top of it, the deb packages and rpm packages of haskell libs are broken. they circumvent the safety checks of "ghc-pkg register". see my article.
20:11:59 <nosila> xplat: the thing is, i havent implemented the remove from the tree, if i had that i would remove and then add it again, would "great" but would get the thing done... not having that i dont really know what to do
20:12:15 <monochrom> and then on top of both, ghc 6.12.1 is broken. see my article.
20:12:18 <nosila> xplat: yep
20:13:25 <stepcut> monochrom: well, apparently cabal-install is useless to me then. 
20:13:33 <xplat> nosila: well, you just make a function called ‘modify’, where you do like in lookup, except 1) you keep passing down the new associated data to each successive call
20:14:07 <monochrom> my perspective is that *.deb and *.rpm are useless for haskell packages.
20:14:13 <nosila> xplat: ooohh you gave me an idea, having a elementReplacer that works like the add, but with one more verification
20:14:38 <gienah> monochom: on gentoo the pkgs are built from the source code
20:14:52 <xplat> 2) instead of returning the modify of the child node directly, you build up an almost-copy that puts the result in place of the node you went down to, and returns that
20:15:20 <stepcut> monochrom: I work with a team of people. We often have to patch cabal packages to get the working correctly. How do you recommend we do that using cabal-install ?
20:15:23 <gienah> this makes it easier as can run haskell-updater to rebuild packages that are broken by updating dependent libraries
20:15:42 <monochrom> gentoo still does not solve the unsafeInteleaveInstall problem
20:15:56 <nosila> xplat: the shitty part is, i need to do another function to give me all of the tree that matches what i want to change insted of just the element in that leaf
20:15:57 <stepcut> monochrom: by debianizing things, we can apply patches, and make sure everyone is developing against the same set of libraries.
20:16:06 <monochrom> or rather, gentoo is still suspectible to the unsafeInterleaveInstall problem.
20:16:08 <xplat> monochrom: where is your article?
20:16:15 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml
20:16:16 <gienah> maybe I need to read your article to find out what the unsafeInteleaveInstall problem is ?
20:16:20 <nosila> xplat: oh well, thanks for clearing up things for me ;)
20:16:39 <xplat> nosila: np
20:18:11 <gienah> monochrom: the way 
20:18:48 <monochrom> "the way" = ?
20:19:07 <gienah> i avoid the unsafeInteleaveInstall problem on gentoo is to install all the pkgs as system pkgs, and the user is free to do this as well as you can create your own ebuilds on say /usr/local/portage using hackport
20:19:32 <monochrom> yes, this corresponds to setting points A and B.
20:19:51 <gienah> so if the pkg is not in the overlay, can hackport merge missing_pkg; emerge dev-haskell/missing_pkg
20:22:25 <xplat> monochrom: file bugs with debian that they don't register the package metadata correctly.  dpkg is perfectly capable of calling hooks to finish installation of packages.  rpm too for that matter.
20:23:57 <gwern> ok, I finished the introduction to http://www.gwern.net/Resilient%20Haskell%20Software.html . what do people think of my cabal propaganda^Wretrospective?
20:24:08 <nosila> xplat: *jiiz in the pants moment* compiled 1st time, now just have to test it loool  http://hpaste.org/43714/tree what do you think???
20:24:59 <gwern> for a moment, I thought nosila was talking about a new package to go along with loli and the others
20:25:41 <nosila> hum what?
20:25:41 <nosila> lol
20:26:29 <gwern> no joke, see http://hackage.haskell.org/package/loli
20:26:32 <nosila> anw, can someone please check this?? http://hpaste.org/43711/error
20:27:22 <xplat> nosila: that's (43714) probably not quite what you want
20:27:33 <monochrom> I think I know why they circumvent the safety check. There is hardly an alternative. If you call "ghc-pkg register" and it says no, you are just as hosed.
20:28:10 <nosila> xplat: (43714)?
20:28:26 <xplat> for one thing, you call addElement instead of recurse on replaceElement.  for another thing, that way when you replace a node you replace all child nodes under it too, which you probably don't want
20:28:45 <nosila> xplat: nevermind loool not what i want why?
20:29:20 <gienah> monochrom: I like your article, could explanation of the problem, thanks. Of course I sort of take the advice in the article, in an opposite sort of way: I install everything as a system package and never use cabal install :-)
20:29:35 <gienah> /s/could/good/
20:29:51 <xplat> you probably want a function with type Ord(a) => a -> BSTree a -> BSTree a
20:29:54 <nosila> xplat: i was thinking that, if i want a "new" data in there i need the rest of the tree.... am i wrong? is there another way to do this?
20:29:54 <monochrom> If you say, "apt-get install blah", and you don't have the "blah" package yet, and your postinst calls "ghc-pkg register", and it says no, sure, you could go back to delete files in theory. Even then, I don't think the debian framework allows this.
20:30:36 <xplat> nosila: well, actually tbh i'm having a little trouble figuring out where you store your associated data in that tree type
20:31:14 <monochrom> But if you have an old "blah" version and you "apt-get upgrade blah", well by the time you go into postinst and call "ghc-pkg register" and it says no, you're already hosed. Files have already been replaced. You lost the old version already.
20:31:21 <nosila> xplat: where i store? 
20:31:41 <nosila> xplat: didnt understood your question sorry
20:31:56 <monochrom> But perhaps you can say something about doing checks in preinst first. That may work.
20:32:13 <xplat> i figured you were making a record type with a custom Ord instance that ignores all but one field and using that as your key type for BSTree
20:32:16 <monochrom> thanks gienah
20:33:37 <xplat> but normally a tree with associated data would be declared like data BSTree a b = BSTree_Empty | Leaf a b (BSTree a b) (BSTree a b) so you don't have to make all those custom instances.
20:33:45 <xplat> (well, and for other reasons)
20:34:28 <nosila> xplat: yeah lol you're right ;) wait what? a b ???
20:34:57 <nosila> xplat: anw you were right, i only have to pass the element i want to change, gonna hpaste the code for you to see
20:35:10 <nosila> http://hpaste.org/paste/43714/tree_annotation#p43715
20:36:48 <xplat> nosila: you still call addElement in the body of replaceElement and i still think that is not quite right, but other than that looks better
20:36:59 <jetkoten> hi all
20:37:07 <nosila> oh yeah forgot about that lol
20:37:59 <jetkoten> quick question: in ghci how can i unbind a variable, so if i already had c=1 i can then do c=3?
20:37:59 <nosila> hum but what was you saying about "all of those instances"? 
20:38:17 <Wooga> jetkoten: let overrides previous values
20:38:50 <xplat> monochrom: yeah you can do checks in preinst to avoid most problems, you only have to worry about races
20:38:52 <nosila> jetkoten: let c=3  ?
20:39:00 <jetkoten> Wooga: does it forget them totally or just make a new scope for it to exist in?
20:39:39 <xplat> monochrom: and even in the case you still fail it should be more obvious what is wrong and what to do about it
20:39:41 <Wooga> jetkoten: done in upmost scope (ghci> let ...) previous value becames unaccessable
20:40:17 <jetkoten> nosila: both you and Wooga are saying that, so it's likely it, i just want c to forget 1 and be unbound until i say c=3 can i do that... no big deal if not, just wondering... :)
20:40:58 <xplat> Wooga: that is in ghci, and it still really creates a new scope
20:41:10 <jetkoten> like in erlang they have f(c) to "forget" what it wa bound to...
20:41:16 <jetkoten> wa=was
20:41:30 <xplat> there's no way to actually destroy an old binding in haskell, you can only shadow it
20:41:51 <jetkoten> xplat: very intersting :)
20:41:53 <monochrom> or let it go out of scope
20:42:38 <jetkoten> hmmm, so no global "forget" either then, besides restarting ghci... :)
20:42:59 <xplat> monochrom: yeah, but that's also different from destroying.  it is the thing to do if you want c to be invisible sometimes, though.  you can't really do it at top level in ghci, though ...
20:43:04 <monochrom> actually when you :load or :reload, a lot of things are forgotten
20:43:22 <jetkoten> xplat: so the shadowing, what's that then?
20:43:33 <jetkoten> monochrom: i see
20:43:33 <xplat> monochrom: hm, yeah, although it is sort of a side effect
20:43:42 <xplat> (in the other sense)
20:44:30 <xplat> jetkoten: shadowing is what it's called when you can't see a binding in an outer scope because you are in an inner scope that binds the same name
20:44:31 <nosila> anw about this http://hpaste.org/43711/error nothing? :(
20:45:03 <accel> dumb question: is there a tutorial on how to do an spinnning cube in opengl? The HOpenGL tutorials covers drawing traingles + key handing, but not animation.
20:45:34 <Wooga> i have a questiom about iteratee's (from package ieratee-0.7.0) and laziness: is here: http://paste.pocoo.org/show/333481/ exception rises after second line (when should after first one) due to initial state of iteratee or due to laziness?
20:45:37 <jetkoten> xplat: like when you're "in" a let?
20:47:04 <xplat> jetkoten: yes
20:47:29 <xplat> nosila: first error: last line in a ‘do’ cannot have <-
20:48:03 <jetkoten> xplat: great, thanks
20:48:11 <nosila> xplat: why is that?
20:48:19 <nosila> xplat: any special reason?
20:49:11 * jetkoten also thanks Wooga, nosila, monochrom... good bye all.
20:49:17 <xplat> nosila: because do needs to have a value, and <- doesn't produce a value
20:50:15 <xplat> nosila: also you are trying to bind penalizacao in the inner dos and use it in the outer do, but it will not be visible there
20:50:27 <xplat> *penalizacao'
20:51:28 <xplat> you should have ‘penalizacao' <- ’ before the ‘case’ and remove it from the insides
20:51:48 <nosila> xplat: true true, the second code there was done after someone here explain it to me, that i needed to create a new Utente
20:52:10 <mun> hi i have a quick question about formal notation. if i want to write that a formula f is to be rewritten such that every occurrence of t is to be replaced by u, which is an existential variable, can i write something like: "f |-> \exists u. f[t/u]"?
20:52:32 <nosila> no need for that i think, i can put the direct values as i have in the second code (btw, data Penalizacao = NAO | SIM )
20:53:29 <xplat> nosila: if you do as i said it will be better, because you don't write return (Utente a b c d e f ) twice
20:53:32 <ddarius> mun: Well [t/u] usually means replace u with t.
20:54:38 <mun> ddarius, oh right. but is the rest okay?
20:55:31 <xplat> you also don't need to use so much { and } and ;.  take them all away and it will be better style.
20:56:04 <nosila> xplat: you have a good point there, i tryed to do that without sucess, how would i put that? use >> ?
20:56:22 <ddarius> mun: But yes, that's fine notationally though a rather non-deterministic/ambiguous way of formalizing that.
20:56:39 <nosila> xplat: true true but i've already had problem's with missing ; and stuff, put them just to clear that out
20:56:47 <mun> ddarius, oh, how come?
20:58:34 <xplat> nosila: if you use the first version, and you put penalizacao' <- where i said (only in line 6), and you capitalize nao in line 9, and you delete all -- really all! -- of the { and } and ;, it will work
20:59:00 <nosila> LOL
20:59:02 <nosila> let me check that
20:59:04 <ddarius> mun: Which instances of 't' you want to replace is unspecified.
20:59:29 <mun> ddarius, i see. i hope to say all t's
20:59:45 <nosila> but
21:00:23 <mun> ddarius, can you suggest a way for that?
21:00:48 <nosila> xplat: how why put penalizacao' <- .... between line 6-7 if the "final" value depends of the initial one? that's why i have the case there
21:00:56 <dankna> @hoogle on
21:00:57 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:00:57 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
21:00:57 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
21:01:34 <ddarius> mun: Technically, that is what the notation states, it just may not be what you want always.
21:01:52 <mun> ddarius, ah okay. thanks
21:02:39 <xplat> nosila: in haskell case is not a statement like java or C ‘while’, it is an expression just like ‘1+1’ or anything else, just with different syntax.  ‘do’ is the same, it is an expression.  a do has a value, a case has a value
21:02:59 <xplat> the value of do is the value of the last line
21:03:17 <xplat> the value of the case is the value of whatever is after -> in the case that is selected
21:03:32 <nosila> oooohhhh
21:03:48 <nosila> damn, code time !!
21:04:39 <xplat> (actually the value of ‘do’ is a little more complicated than just the last line, but for now you can pretend it is until you start using ‘do’ for other than IO)
21:05:34 <nosila> oh man dont really care, have a project due to 12h TODAY
21:05:47 <nosila> and an exam of haskell @ 10h lol
21:05:55 <nosila> just want to get this done
21:06:37 <john_r_watson> so I find it odd that for every Monad instance you need to define separate definition if you want it to be an instance of Applicative, when almost all have the same definition where pure = return and (<*>) = ap.  It seems like it should be possible to define a "default" definition for a class of type monad... Is there talk of such support in upcoming versions of Haskell - something like:
21:06:37 <john_r_watson> instance (Monad m) => Applicative m where
21:06:38 <xplat> oh, i made a small mistake: line 9 should be ‘return NAO’ and line 13 should be ‘return SIM’ otherwise it is a type error
21:06:52 <shamster> is there an idiomatic way to name predicates in haskell? i.e. Lisp names predicates with a _p suffix...
21:07:07 <xplat> (later you will understand why it is a type error and not a syntax error ...)
21:07:57 <ddarius> mun: As an example, let M be 1 = 1 /\ p(1), M implies exist x. x = 1 /\ p(x) and when I use that I can recover that x was 1.  exists x.M[x/1] would be exists x. x = x /\ p(x) which is true, but I can't recover that x = 1 from it.
21:09:12 <xplat> john_r_watson: you could do that now, but it would break every Applicative that is not a Monad
21:09:38 <ddarius> It's better if you have something more like M(x) =def x = 1 /\ p(x), and M(t) => exists u. M(u)
21:09:39 <nosila> xplat: (later you will understand why it is a type error and not a syntax error ...) for me?
21:09:47 <xplat> nosila: yes
21:10:01 <mun> ddarius, right. so that's because x is free in M.
21:12:28 <nosila> xplat: hum ok... having a tuff time clearing up the errors i have
21:12:38 <dafis> shamster: there's a tendency to start predicates with an `is' (isLower, isDigit, ...)
21:12:57 <dafis> but of course, there's even and odd
21:13:11 <xplat> john_r_watson: the reason why is that when the typeclass system is trying to find an instance, it looks just at the shape of the type to decide what instances apply
21:15:09 <xplat> john_r_watson: so when you write instance (Monad m) => Applicative m, all types are of the shape ‘m’ so it tries to use that instance for every type
21:16:19 <xplat> nosila: what do you have now?
21:16:45 <nosila> gonna hpaste this
21:17:16 <shamster> dafis: thanks
21:17:23 <Wooga> who on the short hand with iteratees from iteratee-0.7.0.0.0 package (and, possibly, also with laziness), please, tell me, why here: http://paste.pocoo.org/show/333486/ enumFileLines enumerator stops executing only after second line when (as i understand) should after first one?
21:17:59 * hackagebot hamlet 0.7.0.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.7.0.1 (MichaelSnoyman)
21:18:15 <homie> lol
21:18:20 <homie> awful naming
21:18:41 <nosila> http://hpaste.org/paste/43714/tree_annotation#p43716
21:18:52 <john_r_watson> xplat: Hmmm I think I follwo you
21:19:18 <john_r_watson> xplat: so the part that bites you is that you can't override that if your type needs a different derivation and is also a type of Monad?
21:19:45 <Wooga> and how do i fix this?
21:20:26 <xplat> john_r_watson: no, even if your type is not a Monad, the system will try to use that instance and it will just fail
21:20:52 <xplat> john_r_watson: constraints for an instance are checked, but only after deciding which instance to use
21:21:09 <john_r_watson> xplat: do the pragmas not fix this ? {-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
21:21:49 <xplat> john_r_watson: they fix it somewhat, but they bring in new problems in exchange, so Control.Applicative would not want to depend on them
21:21:57 <john_r_watson> gotcha
21:22:44 <Wooga> ...anyone?
21:22:59 * hackagebot network-protocol-xmpp 0.3.2.5 - Client->Server XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.2.5 (JohnMillikin)
21:24:16 <xplat> nosila: what is the type of getUtenteById?
21:24:49 <nosila> is @ the end
21:25:12 <nosila> xplat: @ the end of the hpaste you have the signature of getUtenteById
21:25:13 <xplat> oh, sorry, i missed it
21:25:19 <nosila> np ;)
21:25:45 <dankna> hmm
21:26:23 <dankna> I'm thinking a namespace for each two-letter prefix Apple uses, for each framework that prefix is used in
21:26:27 <xplat> 11   getUtente :: BST_Utentes -> IO Utente
21:26:31 <dankna> import qualified AppKit.NS as NS, and so on
21:26:48 <dankna> that will give symbols like NS.Window
21:27:15 <dankna> they also have the convention of putting "k" before it for constants; I'll just bump the k to after, like CG.kSomethingCoreGraphicsy
21:27:33 <dankna> this will result in a lot of imports in every single module that interacts with ObjC
21:27:35 <dankna> but what can you do
21:27:57 <dankna> does anyone have opinions?
21:28:27 <ddarius> dankna: You can make modules that re-export other modules.
21:28:35 <dankna> can they re-export them qualified though?
21:29:14 <xplat> nosila: 16      return (fromMaybe Utente_Empty (getUtenteById arvore bi));
21:29:22 <dankna> it would not be desirable to mass-import these 14 thousand symbols with highly desirable names into every single module with no prefix whatsoever
21:29:31 <ddarius> dankna: No.
21:29:35 <dankna> (it is about 14,400; I checked)
21:29:44 <dankna> yeah.  so people can deal with copy-pasting the imports, I think.
21:29:53 <ddarius> dankna: You could still import the re-exporting module qualified and you can have subsets.
21:30:08 <dankna> it's too many symbols for me to sort through and put them in semantic subsets, is the thing
21:30:23 <dankna> any processing I do on the namespace has to be automated
21:30:50 <nosila> damn
21:31:04 <xplat> dankna: well, you could automatically dup-check namespaces that seem like they might be semantically related
21:31:20 <nosila> xplat: fighting ignorance is the worst thing lol was killing my head off trying to think of a way to do something that fromMaybe does
21:31:21 <dankna> xplat: I'm not sure what problem you're trying to solve with that?
21:32:04 <dankna> the namespacing is relatively flat as Apple gives it to me; those 14,000 symbols are divided into only about 20 namespaces
21:32:17 <dankna> I might be able to scrape header files to get it down further, not sure
21:32:42 <xplat> dankna: well, what i'm saying is you could sort them coarsely by module and prefix, instead of finely by individual function, and check automatically if they overlap
21:33:29 <dankna> I suspect there's very little or even no overlap
21:33:32 <dankna> among these symbols
21:33:39 <dankna> the problem is that they have names that the user probably wants for himself
21:33:50 <dankna> hence why in ObjC, they're all prefixed with the two-letter codes
21:34:23 <dankna> another option is that I could downcase the prefix codes and include them as part of the name
21:34:42 <dankna> then you'd have AppKit.NSWindow (a type) and AppKit.nsWindowList (a function)
21:34:54 <dankna> I can't say that approach thrills me either though
21:34:55 <xplat> dankna: ah, well, you could do something like look at any names that, unprefixed, overlap with a name defined in, say, all of cabal, and assume the rest are ok unqualified
21:35:22 <dankna> ideally this would be a rule the user can memorize
21:35:35 <dankna> that approach would require them to look it up every time
21:35:52 <dankna> searching all of hackage - what a concept :)
21:35:57 <xplat> well, you could make the unqualified ones available qualified as well so users don have trouble with the functions they don't use often
21:36:06 <dankna> hmm
21:36:21 <dankna> you mean define AppKit.Window and AppKit.NSWindow as synonyms
21:36:34 <nosila> xplat: i think i dont need return there because it's not going to IO
21:36:40 <dankna> that's a thought
21:36:55 <dankna> if I go with a heuristic approach I should definitely have the synonyms as a fallback
21:36:58 <xplat> nosila: if you use IO to write a prompt, it is in IO
21:37:26 <ddarius> dankna: If I go to the Apple documentation, what will I see?
21:37:30 <xplat> nosila: if you use getInt, it is also in IO
21:38:04 <nosila> but the infered type is what i had, Utente
21:38:07 <dankna> ddarius: you'll see lots of NSWhatevers
21:38:09 <nosila> and not IO Utente
21:38:13 <dankna> they do consider that part of the name
21:38:26 <dankna> but I have to change it regardless because of the uppercase/lowercase distinction in Haskell
21:38:50 <xplat> nosila: if you put the putStr and getStr in with it, it will infer an IO type
21:38:59 <ddarius> dankna: That's fine.  Haskell programmers will know to expect that.
21:39:06 <dankna> (as a real hat-trick, it might be possible to get Apple's documentation into haddock!  but that's after everything else works)
21:39:23 <dankna> ddarius: so you think I should just keep the prefixes as they stand?
21:39:47 <nosila> xplat: yea i understand that but the thing is, it isnt infering that (but i'm getting an weird error lol )
21:40:02 <ddarius> dankna: Yes.  I imagine most people using it will be using things built over it (or building those things.)
21:40:08 <dankna> mm
21:40:16 <nosila> xplat: in the last line of the code you did,  Couldn't match expected type `Utente' against inferred type `m b'
21:40:48 <dankna> applications programming tends not to be like that, I think.  even in the largest app I've personally written, more than half the modules still make extensive use of the system types.
21:40:48 <xplat> dankna: i would rather not keep the prefixes myself, but it would probably cause less controversy if you kept them
21:41:07 <dankna> I've never been one to worry about controversy
21:41:17 <dankna> I'm the one investing the effort, I'll make what I believe is the best decision on the technical merits
21:41:49 <ddarius> dankna: Things built over it can still re-export the "system" types with different names if they want.
21:41:52 <xplat> nosila: i think you still have the type signature getUtente :: BST_Utentes -> Utente.  that is what causes it to expect Utente, it is not inferred
21:41:56 <dankna> ddarius: well, that's a point
21:42:45 <nosila> if i put IO Utente it says that the inferred type is Utente
21:43:20 <xplat> nosila: oh, did you get rid of line 17?  i forgot to tell you that
21:43:26 <nosila> oh damn, missed this, it says that because of the BST_Empty part
21:43:35 <ddarius> dankna: Wrapping things nicely for Haskell requires a human.  So wrap everything in an ugly manner, and then wrap whatever you consider a useful subset in a nice manner (in a different package.)
21:43:42 <xplat> oh, ha
21:43:50 <dankna> ddarius: that's fair.  perhaps I shall do that.
21:43:56 <nosila> yes i did
21:43:58 <dankna> okay, it's decided.  the prefixes stay.
21:44:10 <xplat> yes, that has to be return Utente_Empty (you don't need a ‘do’)
21:44:51 <nosila> xplat:  FUUUU! ... oh well, 1 down, 2 to go
21:45:00 <nosila> xplat: once again, thanks ;)
21:45:03 <dankna> thanks for your opinions
21:47:00 <nosila> hey, i have data User = User_Empty | User ....
21:47:19 <nosila> then i have a function that returns a user
21:47:46 <nosila> in the middle of a do { } how can i compare if the return of that function is User_Empty or User?
21:47:58 <Axman6> with a case statement
21:48:06 <xplat> case expression
21:48:08 <nosila> (i have an if user /= User_Empty then )
21:48:26 <nosila> case is the only way i can check a pattern like that?
21:48:44 <Axman6> well no, but it's probably the easiest
21:50:30 <xplat> nosila: also, in line 7, replace ‘:min:’ with ‘ ++ show min ++ ’
21:50:54 <xplat> nosila: then do the same with ‘:max:’
21:51:15 <nosila> man
21:51:16 <nosila> you rock
21:51:17 <nosila> lol
21:51:24 <nosila> thanks ;)
21:51:29 <Axman6> :min:? o.O
21:52:07 <nosila> forget about it, i think my brain melted some hour's ago, i had done a code similar to that and couldnt even remember damn
21:55:09 <xplat> i am already impressed you can just ask for help in english.  i can't imagine asking for help in programming in any of the 3 languages i know except english
21:55:39 <xplat> because i just don't know them far enough to talk programming
21:57:33 <djahandarie> あの。。。そのzygohistoprepromorphismはいったい何なんだ
21:57:33 <nosila> lol my english (writing) is not the best but i can understand everything or almost everything
21:58:05 <xplat> mostly just ask people's health, buy things, understand some of the pop songs maybe if i'm lucky :)
21:58:23 <nosila> loooooool
21:58:30 <xplat> djahandarie: heh, i couldn't answer that one even in english :)
21:58:32 <Axman6> xplat: where are you?
21:58:56 <nosila> xplat: that code of the NAO | SIM
21:59:01 <xplat> Axman6: USA right now, east coast
21:59:05 <nosila> its still giving me an error
21:59:17 <xplat> nosila: what error?
21:59:19 <nosila> oh man i wish i could go there someday
21:59:30 <nosila>     Couldn't match expected type `IO b'            against inferred type `Penalizado'     In the expression: NAO
21:59:56 <ddarius> xplat: As an English speaker, talking about programming in other languages is relatively easy compared to the opposite situation.
22:00:04 * djahandarie didn't want to come up with zygohistoprepromorphism in Japanese. All I know is morphism: 射. :P
22:00:21 <ddarius> djahandarie: It'd probably be katakana anyway.
22:00:45 <nosila> i'm getting 2 errors, both from 'cases'
22:00:54 <djahandarie> isomorphism is 同形
22:01:00 <xplat> ddarius: yes, japanese is not french :)  or chinese ... and even chinese goes phonetic on those sometimes ...
22:01:21 <djahandarie> Homomorphism is 準同型
22:01:36 <ddarius> djahandarie: "Isomorphism" is a term, "zygohistoprepromorphism" is a name.
22:01:53 <xplat> djahandarie: can probably thank yoneda and his colleagues for those, but i doubt it reaches the exotics
22:02:00 <nosila> omfg i dunno how the hell am i going to do this project in time and face an exam of haskell lol
22:02:21 <ddarius> xplat: If you said "zygohistoprepromorphism" to a categorist, they'd have no idea what you are talking about.
22:02:33 <ddarius> Even the squiggolists would have almost no idea what you are talking about.
22:02:46 <adu> squiggolists?
22:02:47 <djahandarie> Therefore, no one in this room is a categorist
22:03:21 <ddarius> djahandarie: I wouldn't say everyone in this room has an idea what zygohistoprepromorphism is.
22:03:44 <djahandarie> And those people may be categorists?
22:03:45 <ddarius> Though of the people that do, none of them are categorists.
22:03:47 <xplat> ddarius: exactly.  and i don't think squiggol is big in japan like category theory ...
22:04:09 <djahandarie> Category theory is big in Japan? :P
22:04:26 <xplat> well, maybe it's more the other way around :)
22:05:42 <xplat> nosila: you never said what the errors were, just that they are from cases
22:05:57 <nosila> lool yes i have
22:06:21 <nosila> right after you asked, but w8 a sec, i'm hpasting this
22:07:16 <xplat> nosila: oh, you're right, but i need to know context to know what it means anyway
22:07:30 <xplat> so hpaste is good
22:07:36 <nosila> yep ;9
22:07:37 <nosila> ;)
22:09:45 <nosila> http://hpaste.org/43717/errors1
22:09:51 <nosila> xplat: http://hpaste.org/43717/errors1
22:11:28 <xplat> nosila: oh, you need return before NO and SIM on 58 and 63
22:11:36 <xplat> *NAO
22:11:49 <glguy>             otherwise -> return arvore
22:11:58 <glguy> Do you realize that this is assigning the value to otherwise
22:12:11 <glguy> it happens to work out as an "otherwise" branch
22:12:26 <xplat> i'm sure i said that, but i didn't say nosila: and anyway after all i missed i can't blame you :)
22:12:30 <glguy> but it is different than the otherwise :: Bool that you use guards
22:13:06 <xplat> glguy: yeah, it should really be _
22:14:25 <nosila> xplat: return before those lines?
22:14:40 <xplat> nosila: yes
22:14:53 <nosila> yeah yeah you right glguy: , i was just testing and left that there
22:15:03 <xplat> arvore = tree, utente = user?
22:15:24 <ddarius> glguy: nosila is building a program by generate and test with #haskell as the 'test' component.
22:16:02 <nosila> loooool something like that 
22:16:25 <nosila> but xplat, how am i supposed to return before those lines if there isnt "anything" to return?
22:16:34 <xplat> the Utente branch is wrong too
22:16:48 <franz_> ehhh
22:16:53 <franz_> japanese talk, in #haskell?
22:17:01 <xplat> nosila: you return NAO or SIM
22:17:06 <ddarius> franz_: It happens quite often.
22:17:18 <djahandarie> ddarius, it does? :P
22:17:54 <xplat> return doesn't actually return anything anyway, it just makes a regular value into an IO value
22:18:03 <ddarius> About as much as Svenska and certainly more than German.
22:18:31 <ddarius> Admittedly, the Svenska has been relatively scarce of late.
22:19:13 <nosila> xplat: is wrong where? anw, sorry im not following you, you're saying i need to return penalizacao' before the case?
22:19:22 <nosila> like return penalizacao'<- .... ?
22:19:57 <xplat> nosila: no, i am saying: in line 58 where you have ‘NAO’, write ‘return NAO’ instead
22:20:21 <nosila> ooohhhhhhhhhhh
22:20:39 <nosila> and the case returns to penalizacao'? damn
22:22:00 <xplat> well, as i said, return doesn't really return things, it just makes a regular value have an IO type
22:22:23 <djahandarie> return :: a -> IO a
22:22:51 <xplat> and then the <- takes it back off again, but only within that ‘do’
22:23:09 <nosila> damn, having to abstract years and years of imperative programing is becoming a hard task as hell
22:26:55 <nosila> 2 down, 1 to go lol
22:27:19 <xplat> in line 8, you have Utente -> case op of
22:28:31 <xplat> but utente' will never be Utente, Utente isn't a user, it's a function that returns users after you give it a lot of arguments
22:29:14 <xplat> so after Utente you need to have a lot of _ to represent the arguments that you don't care what they are, but you do care that they are there
22:29:17 <nosila> then how can i know wish one is it?
22:29:28 <nosila> oh i see
22:29:33 <nosila> that's makes sense
22:30:18 <nosila> really, how the eck was i supposed to figure out this type of mistakes by myself? lol
22:31:22 <xplat> with the book and you read it 8 or 10 times until you notice the right thing while reading :)
22:31:52 <dafis> nosila: if you don't care about the arguments, only about the constructor, you can also match on Utente{}
22:32:16 <nosila> to use that
22:32:17 <xplat> dafis: does that work if Utente wasn't declared with fields?
22:32:31 <xplat> i don't think it does
22:32:36 <nosila> wasnt i supposed to have done data Utente = Utente { .... } ??
22:33:03 <dafis> > case fail "Uh" of { Nothing{} -> True; _ -> False; }
22:33:04 <lambdabot>   True
22:33:14 <dafis> xplat: ^^
22:33:23 <xplat> dafis: once again i learn something in this channel :)
22:33:29 <nosila> LOL
22:33:34 <dafis> even when it was declared without arguments
22:33:36 <nosila> that's legit
22:35:16 <xplat> it works on Just too, so it's not just a special case for no arguments.  you can use it.
22:36:22 <nosila> nice, thanks
22:36:23 <nosila> using it
22:36:25 <nosila> buuuuuut
22:36:28 <nosila> still no good lol
22:36:37 <xplat> the last thing
22:36:51 <dafis> xplat, nosila: Yes, Constructor{} is a special case, works no matter how the constructor has been defined, it means `just inspect the constructor and ignore everything else'
22:36:58 <ddarius> Nothing{} is a bit unnecessary...
22:37:03 <xplat> all those 1 -> blah blah blah getUtente)
22:37:10 <dafis> ddarius: just to illustrate
22:37:25 <xplat> the getUtente should be utente' instead
22:37:55 <xplat> because you already got a user and you want to use that one, not get a new one
22:38:07 <xplat> and also because the type matches :)
22:38:27 <nosila> damn, i'm really seelping here lol
22:38:29 <nosila> thanks ;)
22:38:35 <xplat> if you really wanted to get a different user, you would have to use a do or >>=
22:39:35 <nosila> :t >>=
22:39:37 <lambdabot> parse error on input `>>='
22:39:43 <nosila> :t (>>=)
22:39:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:39:51 <nosila> :t (>>)
22:39:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
22:40:21 <xplat> here you can imagine all those m are just IO
22:41:00 <nosila> ;)
22:41:08 <nosila> one more parse error
22:41:09 <nosila> lol
22:42:49 <Wooga> hello, who in short hand with iteratees (iteratee-0.7.0.0), please, tell me, why enumFileLines in this piece of code: http://paste.pocoo.org/show/333543/ ends processing after second inputed line, not after first one?
22:45:41 <xplat> Wooga: i think helper is reading a line before it checks if iter' wants another line
22:46:16 <xplat> Wooga: but i am not that good with iteratees yet so i am not sure how to fix it, or even if i am right
22:47:08 <Wooga> i think it more because of something wrong in myiter definition, but also not sure what exactly
22:47:29 <xplat> Wooga: no, i think myiter is okay
22:48:20 <xplat> and if it is wrong, i can see why it would stop too late, and not too soon or never
22:48:50 <xplat> there is nothing about that definition that says 2
22:49:08 <Wooga> but iteratee has initial state
22:49:18 <Wooga> which is seems wrong to me
22:49:32 <xplat> but helper reads a line before it does anything with iter'
22:49:52 <xplat> so it cannot check if iter' is done until it has already read a line
22:50:04 <Wooga> iteratee has initial state
22:50:13 <Wooga> it should check this initial state
22:50:26 <Wooga> so it should over after first line is read
22:50:37 <Wooga> usualt initial state is continue
22:50:44 <Wooga> but i want to set it to done
22:50:50 <Wooga> but i don't know how to
22:51:12 <nosila> http://hpaste.org/paste/43717/errors1_annotation#p43718
22:51:22 <nosila> man, wth is wrong now? damn i'm freakin tired of this
22:52:10 <Wooga> or am i wrong?
22:53:37 <mun> given "foo c = 0", is is the statement "\exists r. foo c = r --> False" true? It should be false, right? since foo c = r can be evaluated to true, then true --> false is false.
22:53:50 <Axman6> nosila: what;s the type of getUtente?
22:54:16 <nosila> getUtenteById:: BST_Utentes -> Int -> Maybe Utente
22:54:47 <Axman6> well Maybe isn't IO, and you're working in the IO monad
22:55:46 <nosila> sorry, my bad Axman6
22:55:46 <nosila> getUtente :: BST_Utentes -> IO Utente
22:55:54 <nosila> gave you the wrong signature
22:56:03 <Axman6> ah, then why are you giving it two arguments?
22:56:09 <Axman6> it only takes one
22:56:50 <nosila> .....
22:56:52 <nosila> thanks
22:56:58 <nosila> *facepalm*
22:57:02 <Axman6> :)
22:59:32 <nosila> how can i take the IO from something??
23:00:13 <xplat> nosila: the <- does it
23:00:17 <shachaf> const undefined :: IO a -> a
23:00:26 <Axman6> heh
23:00:32 <dafis> shachaf: :D
23:00:37 <nosila> :t undefined 
23:00:39 <lambdabot> forall a. a
23:00:49 <shachaf> nosila: (Ignore me, please.)
23:00:49 <ddarius> shachaf: What do you need that const for?
23:00:50 <dafis> > undefined
23:00:51 <lambdabot>   *Exception: Prelude.undefined
23:01:35 <xplat> nosila: it doesn't actually take the IO off the value, but that is too long a story for tonight :)
23:01:47 <shachaf> ddarius: Æsthetics.
23:01:56 <shachaf> I suppose the two are completely indistinguishable without seq?
23:02:15 <dafis> shachaf: without seq, yes
23:02:18 <nosila> xplat: the thing is, some functions i use in those 1-> 2-> etc return IO Utente
23:02:22 <dafis> with seq, not
23:02:59 <nosila> tonight? 7:20am in Portugal lol
23:03:13 <xplat> nosila: you cannot take IO off at the top level, only inside of a do
23:03:41 <xplat> nosila: if you use IO in a function, you just have to have it return IO something
23:03:59 <nosila> that's the problem
23:04:09 <nosila> after that i need the return to be without the IO
23:04:36 <dafis> nosila: why? after all, main :: IO ()
23:04:54 <nosila> because of that stupid replacer i made ;D
23:05:20 <dafis> well?
23:05:21 <xplat> nosila: Utente {} -> do
23:05:29 <nosila> oh sorry, thought you were xplat
23:06:02 <xplat> nosila:   utente'' <- case op of
23:06:21 <xplat> nosila:     ...
23:06:49 <xplat> nosila:   return $ replaceElement arvore utente''
23:08:07 <ddarius> shachaf: Yes.
23:08:52 <xplat> nosila: you see how that lets you get the user value into replaceElement, and also keeps you from writing the same thing over and over?
23:09:54 <shachaf> ddarius: Misplaced aesthetics, then.
23:10:34 <shachaf> I was going to say something like (const 5) but nosila didn't provide a type so I had to give a partial function.
23:13:18 <xplat> nosila: you could also write ‘1 -> utenteAlterarNome utente' >>= replaceElement arvore’ and so on but that would not get rid of the repetition
23:14:06 <nosila> sorry, didnt follow the $
23:14:08 <xplat> sorry, that would be >>= (return . replaceElement arvore)
23:14:33 <xplat> nosila: oh, i though you would follow $ because i saw you use it with putStrLn
23:15:06 <nosila> i know what it does but i didnt get how that would solve the IO problem
23:15:23 <nosila> because i'm getting the error in replaceElement
23:15:41 <xplat> nosila: oh, the $ doesn't do anything to solve the IO problem, it's just incidental
23:15:57 <nosila> loool okok
23:16:08 <xplat> nosila: you could just as well use parentheses instead
23:17:03 <accel> why do haskell order precedence only go from 1 to 10, rather than say from -2^31 to 2^31 ?
23:17:23 <dobblego> because 10 should be enough for anybody
23:17:36 <dafis> wasn't that 640?
23:17:46 <accel> nah, that would be 640K
23:17:51 <xplat> it's not so much that 10 should be enough for anybody
23:18:03 <xplat> it's that much more than 10 should be too much for anybody
23:19:17 <xplat> precedence is to help humans read and write code, and it doesn't help anymore when you have too many levels
23:19:39 <shachaf> xplat: Would rational numbers really hurt it?
23:19:47 <xplat> machines would be much happier with s-exprs, if they cared about making their lives easier
23:20:44 <nosila> hey
23:20:46 <nosila> i can do 
23:20:48 <xplat> shachaf: rational numbers would actually be a lot less horrible than reams of integers
23:20:50 <nosila> 1 ->  replaceElement arvore (utenteAlterarNome utente')
23:21:12 <nosila> let utenteAux = utenteAlterarNome utente' in replaceElement arvore utenteAux
23:21:16 <xplat> shachaf: it would still be overcomplicated, but there would be a lot less problems with allocation
23:21:17 * shachaf wonders if it's a bad idea to recommend that all code be in English.
23:21:24 <nosila> 1-> do  ... (that) ?????
23:22:47 <xplat> nosila: utenteAlterarNome utente' must be after a <- (or before a >>=), using a let doesn't help ...
23:23:08 <nosila> then
23:23:51 <nosila> 1-> do{ utenteAux <- utenteAlterarNome utente'; replaceElement arvore utenteAux;}
23:23:52 <nosila> ???
23:24:04 <xplat> but, yes, you could have a do for 1, another do for 2, another for 3, another for 4 ...
23:24:17 <nosila> yeaaaahhhhh
23:24:24 <xplat> nosila: you still need a return for the replaceElement
23:24:27 <nosila> dont care lol
23:24:29 <nosila> okok
23:24:31 <nosila> thanks
23:24:37 <nosila> damn, so much to do =X
23:24:52 <xplat> it's bad style to repeat so much that is exactly the same, but i understand you are tired
23:25:03 <nosila> yep i know
23:25:05 <xplat> so am i, we might be in the same time zone
23:25:16 <nosila> not really
23:25:41 <nosila> what time is it there?
23:25:48 <xplat> 2:44 am
23:26:05 <nosila> but yes, in a imperative paradigm i would EVER do this
23:26:11 <xplat> omg, i didn't even think it was 2 yet
23:26:22 <nosila> man, almost 8am here ;)
23:27:27 <xplat> oh, you're in the original home of the language then?
23:28:10 <nosila> wouldn't*
23:28:18 <nosila> original home? 
23:29:50 <dafis> nosila: Portugal (not Brasil)
23:30:03 <xplat> well i first guessed brazil, but after i heard the time zone second guess is portugal
23:30:10 <nosila> ooohhh yeah yeah
23:30:19 <nosila> you know portuguese?
23:30:50 <xplat> only common romance stems and enough endings to recognize it
23:31:02 <xplat> couldn't speak the language though
23:31:25 <nosila> yep, portuguese is hard to learn
23:32:04 <xplat> everyone says that about their language
23:32:18 <xplat> sometimes i think all of them are right :)
23:32:41 <nosila> nah, english for instance is easier then portuguese
23:32:44 <nosila> a lot easier
23:33:00 <nosila> ex: the verbs
23:33:02 <dafis> xplat: only the proponents of artificial languages say learning those is easy (and they're oh so wrong)
23:33:25 <xplat> well, english verbs are pretty easy
23:33:39 <ddarius> dafis: My impression is that artificial languages are much easier than natural languages
23:34:15 <dafis> ddarius: I have the opposite impression
23:34:28 <xplat> only hard part is figuring out whether to double a letter before ‘ing’ or ‘ed’
23:34:35 <dafis> (not that I'm very good at learning languages anymore)
23:34:56 <maurer_> Is there any way to write to my own standard in?
23:34:57 <koala_man> english verbs are easy because everyone here speaks english
23:35:40 <nosila> nop, english verbs are easier because comparing to portuguese
23:35:46 <nosila> we have 2 types of You
23:36:29 <nosila> like, I You He/She/It We You They right?
23:37:14 <dafis> nosila: like tu/vous, Du/Sie, right?
23:37:17 <xplat> koala_man: no, english verbs really are easy because there are only 4 forms that vary, and 2 of the pairs are very simply related for all regular verbs, most mood and tense is done with auxiliaries and is completely indentical even for irregular verbs
23:37:56 <nosila> in portuguese those 2 You's difer, a lot actually.... the first is like what you can say when talking to a friend, the last one its not so used, only in country side or old ppl lol
23:38:11 <nosila> dafis: vous, that's french i think
23:38:17 <dafis> oui
23:38:29 <nosila> Eu Tu Ele/Ela Nós Vós Eles
23:39:08 <nosila> anw, all the foreign ppl say that the portuguese verbs kills them lol
23:39:36 <xplat> that is from latin, actually even older, you have it all over europe practically although the exact usage varies
23:39:49 <koala_man> xplat: compare to esperanto where there is one form of regular verbs and no irregular ones, and none of them vary for person or number
23:40:09 * adu <3 Esperanto
23:40:11 <xplat> it sounds like portuguese verbs are about as hard as french, maybe a little harder or easier
23:40:22 <xplat> german or russian verbs, now those kill :)
23:40:37 <dafis> wieso das denn?
23:41:24 <xplat> and chinese verbs are even easier than english, except to pronounce or write them :)
23:41:32 <nosila> yes Portuguese derives (Latin) /haskell pseudo geek mode off
23:42:07 <xplat> almost the same as esperanto
23:42:33 * adu <3 日本語
23:43:22 <xplat> adu: i bet you don't love it for the easy verbs, though :)
23:43:28 * ddarius <3 英語。
23:43:53 <adu> xplat: the verbs are actually pretty easy
23:44:36 <adu> xplat: -a (past tense), -e (command), -i (present tense), -o (together)
23:44:44 <ddarius> The "formal" grammar of Japanese isn't too bad.  The kanji and pragmatics are much harder.
23:45:49 <adu> yeah, like trying to learn where to put "only" in English
23:45:53 <ddarius> One nice thing about English is that, in many ways, it's pretty forgiving.
23:46:06 <nosila> FFUUUUUUUUUUUUUUUUUUU
23:46:16 <nosila> Ok, modules loaded:
23:46:17 <nosila> *.*
23:46:30 <adu> lolwut
23:47:07 <nosila> AND
23:47:08 <nosila> ITS
23:47:18 <nosila> F**KIN
23:47:20 <nosila> WORKING
23:47:23 <nosila> =D
23:47:39 <dafis> nosila: your caps lock!
23:48:11 <adu> dafis: don't tempt him, that's when they say "WOW, THAT MAKES IT SO MUCH EASIER"
23:48:15 <nosila> (sorry, capslock as jammed =PPP )
23:48:28 <nosila> looooooooooooooooool
23:48:53 <xplat> adu: あんなんで信じさせられないよ。
23:49:03 <nosila> was just kidding man, spent like 3 or 4 hours correcting errors
23:49:03 <kfr> [lu:l]
23:49:08 <nosila> thanks to xplat ;)
23:50:58 <xplat> *そんな
23:51:09 <adu> 信の漢字わかりません。
23:53:36 <adu> xplat: らいしゅうぼくわ日本にいきます。
23:53:50 <xplat> 信(シン)＝「believe」
23:54:06 <adu> ah ok
23:54:36 <adu> s/わ/は/
23:55:43 <manju__> Do other people also see japanese characters ?
23:55:49 <taotree> I do
23:55:53 <manju__> ok
23:56:07 <manju__> this is what happens if you peep into the IRC window once in a week
23:56:30 <xplat> adu: ああ、じゃ、漢字より音はずっと大事だね。
23:57:36 <adu> xplat: はい！勉強します。
23:59:00 <adu> xplat: also, there's a haskell company I'd like to check out while I'm there
23:59:34 <kfish> adu, in japan?
