00:09:18 <arcatan> jaspervdj: re hakyll3 and hinotify, hakyll still depends on hinotify even when built without -finotify
00:09:48 <turiya> convolution of (discrete) functions is too slow when compared to C. in my implementation the haskell code consumes 100 secs for convolving two functions of length 10000 whereas the C version is much faster consuming approximately 5 secs. I wonder if there is a way to improve the performance of the haskell version..
00:14:32 <kmc> probably
00:14:51 <kmc> do you have a simple code sample you could show us?
00:15:09 <kmc> for starters: you're building with ghc -O2 ?
00:17:00 <opqdonut> how are you representing the functions?
00:17:11 <opqdonut> lists? arrays?
00:17:55 <bicilotti> data Customer = Customer Int String [String] deriving (Show)
00:17:55 <bicilotti> customerID :: Customer -> Int
00:17:56 <bicilotti> customerID (Customer id _ _) = id
00:18:04 <bicilotti> what's the usefulness of "customerID :: Customer -> Int" line?
00:18:19 <turiya> kmc: http://hpaste.org/44264/conv_ths, building with -O2 does not have any noticeable effect
00:18:22 <bicilotti> it seem to work perfectly even without it
00:18:30 <opqdonut> bicilotti: it's a type signature for the function
00:18:48 <opqdonut> bicilotti: in the absense of a type signature the compiler will infer a type signature
00:19:00 <opqdonut> however, explicit type signatures for top-level definitions are considered good style
00:19:34 <bicilotti> what if my sig and the compiler inferred one differs?
00:19:35 <bicilotti> -s
00:19:55 <arcatan> then the compiler gives you an error message
00:20:01 <bicilotti> great
00:20:22 <turiya> kmc: test code: http://hpaste.org/44265/tesths
00:20:22 <opqdonut> you can actually give a signature that has a more refined type than the inferred type
00:20:42 <opqdonut> for example "id x = x", the inferred type is "id :: a -> a" but you could say "id :: Int -> Int; id x = x"
00:21:04 <bicilotti> kind of a subset then, I see
00:21:07 <opqdonut> this can be very useful in some cases, helps catch type errors elsewhere earlier
00:21:22 <turiya> opqdonut: i have used matrices
00:21:33 <turiya> from hmatrix
00:21:54 <opqdonut> I see
00:21:58 <jonkri> what does this error mean: "HXMPP.hs:25:15: The export item `HXMPPEvent(HEConnected, HEPresence, HESubscription, HEIQGet, HEIQSet, HEIQResult, HEIQError, HEDisconnected)' attempts to export constructors or class methods that are not visible here"? i have exported all types used in constructing the terms, i think (see line 321). code at http://paste.pocoo.org/show/343688/
00:22:23 <opqdonut> turiya: I can't say I know hmatrix well, but the "fromLists" call does seem like a bad idea
00:22:45 <bicilotti> this community is overly friendly and responsive, I bet there's a "conquer the world" scheme underneath. Thanks opqdonut and turiya 
00:23:44 <turiya> opqdonut: i did use lists and functions but it was slower than the matrix version
00:24:10 <jonkri> it should have been DisconnectED, not Disconnect, whoops :)
00:26:40 <turiya> bicilotti: are you sure if it was me that helped you?
00:27:09 <bicilotti> woops, opqdonut alone :P
00:27:59 <turiya> :)
00:33:50 <jaspervdj> arcatan: Oops, will fix
00:34:09 <arcatan> jaspervdj: also, you should probably export Hakyll.Core.CopyFile
00:36:06 <jaspervdj> arcatan: done, thanks
00:39:32 <bicilotti> talking about datatypes declaration, is "  isguest :: Bool, issuperuser   :: Bool " equal to " isguest, issuperuser :: Bool " ? 
00:49:09 <arcatan> jaspervdj: also: Hakyll.Core.Logger. And now I've managed to succesfully compile and run Hakyll 3 version of my website. yay.
01:37:22 <aleator_> Anyone tried bos's riak bindings? Which module exports Content so I can implement IsContent class?
01:39:35 <jaspervdj> arcatan: Okay, thanks, will fix
01:53:13 <jaspervdj> arcatan: Any feedback on hakyll 3 is welcome
01:54:16 <Blkt> good day everyone
02:07:44 <arcatan> jaspervdj: are those timed logs supposed to have negative times?
02:19:25 <arcatan> jaspervdj: is this a good way to do this?  http://hpaste.org/44269/hakyll_3
02:22:10 <sipa> @pl \x -> f x >>= return . g
02:22:11 <lambdabot> (g `fmap`) . f
02:37:23 <bicilotti> help! toList (Cons a b) = (Cons a : toList b) 
02:37:24 <bicilotti> toList Nil = [] 
02:37:46 <bicilotti> gives me a "No instance for (Show..." error. I'm not sure what to do 
02:38:31 <bicilotti> sorry
02:38:38 <bicilotti> figured out myself!
02:39:04 <aleator_> You have extra cons as well I think.
02:39:20 <bicilotti> (that was the problem indeed aleator_!)
02:39:24 <sioraioc_> is there optimised library for two dimensional arrays?
02:39:31 <sioraioc_> or is a Vector of Vectors the way to go?
02:39:45 <aleator_> sioraioc_: repa
02:39:58 <sioraioc_> pardon?
02:40:12 <sioraioc_> ah, I see
02:40:13 <aleator_> http://hackage.haskell.org/package/repa
02:40:15 <sioraioc_> thanks
03:02:04 <TheKingsRaven> Hello, I've got a question. Is it possible to check if you have an empty list within the IO monad when using guards, that is IO [] rather than IO [content1,content2...contentn]
03:02:43 <sipa> you mean return [] rather than [c1,c2,c2] ?
03:02:50 <sipa> you mean return [] rather than return [c1,c2,c2] ?
03:03:19 <sipa> the answer is probably no, except within the IO monad itself
03:03:53 <TheKingsRaven> ok, thank you. I'll think of another approach. 
03:04:53 <bicilotti> (ot) assange to sweden
03:07:06 <JuanDaugherty> bicilotti, come again?
03:09:07 <bicilotti> JuanDaugherty: Assange to be extradated to Sweden
03:09:18 <JuanDaugherty> ah
03:09:37 <bicilotti> (he'll prolly appeal, though)
03:20:10 <jaspervdj> arcatan: negative times aren't supposed to happen
03:20:52 <jaspervdj> arcatan: the extension case switch looks like something that should be in hakyll itself
03:30:58 <bicilotti> I'm a bit at loss with : tidySecond (_:x:_) = Just x
03:31:07 <bicilotti> it returns second element
03:31:35 <ben> Pattern matching?
03:31:37 <bicilotti> but as I read it (the (_:x:_) condition) is "a list with stuff before x and stuff after x"
03:31:59 <bicilotti> yes, yes ben, but i am unsure
03:31:59 <ben> a:b is a list where the first element is a and all the other elements are b
03:32:02 <sipa> the list [a,b,c] is syntactic sugar for a:(b:(c:[]))
03:32:16 <bicilotti> thanks ben and sipa 
03:32:17 <sipa> and [a,b] is a:b:[]
03:32:34 <sipa> so indeed _:x:_ is something before and something after, but that thing after may be the empty list
03:32:45 <bicilotti> right! I feel like a newborn :P
03:57:17 <ManateeLazyCat> juhp: It's very nice to talk with you, if not my bad English. :)
04:05:27 <Kaidelong> oh Manatee is an emacs user
04:05:31 <Kaidelong> that explains Manatee
04:05:44 <Kaidelong> (the program there in the second sentence rather than the user)
04:05:49 <Kaidelong> I always wondered about it
04:30:51 * hackagebot augeas 0.3.5 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.3.5 (JudeNagurney)
04:34:59 <ski> TheKingsRaven : were you having a function argument of type `IO [Something]' ? .. if so, it could be that you could pass `[Something]' instead (and then you could pattern-match directly)
04:35:34 <xplat> oh, right!  then we can already have yi vs manatee haskell editor wars, no need to wait for 'hmacs'!
04:54:59 * hackagebot hsc3-server 0.0.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.0.0 (StefanKersten)
05:03:00 * hackagebot ismtp 2.0.0 - Advanced ESMTP library  http://hackage.haskell.org/package/ismtp-2.0.0 (ErtugrulSoeylemez)
05:07:38 <arcatan> has anyone noticed that fromEnuming NominalDiffTime gives weird results on OS X?
05:07:54 <arcatan> http://hpaste.org/44274/fromenuming_nominaldifftime this code gives me very different results on OS X and Linux
05:08:29 <arcatan> (GHC 6.12.1 and 7.0.1 on Mac, 6.12.1 on Linux)
05:08:48 <arcatan> (time 1.2.0.4 on both)
05:09:27 <arcatan> no, wait, different time versions, hmm.
05:10:17 <arcatan> still the result is weird, though
05:11:53 <mm_freak> which version of GHC does a recent debian system have?
05:14:29 <merijn> mm_freak: Probably GHC6.10 or 6.12?
05:15:37 <Jafet> sid has 6.12.1
05:15:39 <quicksilver> mm_freak: http://packages.debian.org/ghc6
05:15:46 <mm_freak> thanks
05:18:28 <Entroacceptor> why would http://nopaste.linux-dev.org/?11138 happen?
05:20:53 <merijn> Entroacceptor: Which distro?
05:21:15 <Entroacceptor> ghc 6.12.1 in debian
05:22:02 <Entroacceptor> oh
05:22:06 <Entroacceptor> maybe I see why
05:22:23 <Saizan> try cranking up the verbosity
05:22:39 <Entroacceptor> oh
05:22:45 <Entroacceptor> yes, that kinda helped
05:22:48 <Entroacceptor> uh-oh
05:23:03 <Entroacceptor> nevermind, that's a filesystem/harddisk problem, not a haskell one
05:23:15 <Entroacceptor> (INSERT SWEARWORDS HERE)
05:23:45 <Entroacceptor> "cat /etc/alternatives/hsc2hs" gives me "# The PAM configuration file for the Shadow `passwd' service"
05:24:09 <Entroacceptor> that's not what you want to see
05:29:11 <quicksilver> Entroacceptor: *sympathy lol*
05:30:39 <Jafet> To last week's backup, eh
05:31:06 * hackagebot tabular 0.2.2.2 - Two-dimensional data tables with rendering functions  http://hackage.haskell.org/package/tabular-0.2.2.2 (EricKow)
05:33:19 <Entroacceptor> daaaman
05:33:51 <Entroacceptor> backups are for whimps
05:34:00 <saml> what?
05:34:03 <Entroacceptor> I wanted to move that server anyway
05:34:28 <Entroacceptor> saml: nothing, I just have file corruption on this server
05:34:46 <saml> why not use S3 for web scale?
05:36:25 <Entroacceptor> it's my fun private hobby machine, mainly
05:36:45 <parcs> is there any way to have ghc ignore unexhaustive pattern-matchings when using the Wall flag?
05:38:36 <parcs> nevermind, found it through ghci's handy tab completion 
05:40:53 <jonkri> is there a function in base which splits a list into multiple list using a delimiter? [1, 2, 1] and delimiter 2 gives us [[1], [1]]
05:41:17 <mauke> AFAIK no
05:41:24 <mauke> the closest thing is break
05:41:40 <jonkri> @hoogle break
05:41:41 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
05:41:42 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
05:41:42 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
05:41:51 <jonkri> ah
05:43:40 <saml> > split [1,2,1] 2
05:43:41 <lambdabot>   Couldn't match expected type `t1 -> t'
05:43:41 <lambdabot>         against inferred type `([t2]...
05:43:53 <mauke> :t split
05:43:54 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
05:44:29 <saml> > let f n | n <= 1 = 1 | otherwise = n * f (n - 1)  in f 70
05:44:30 <lambdabot>   119785716699698917960727837216890987364589381425464258575553628646280095827...
05:44:35 <saml> how come this is so fast?
05:44:42 <saml> it's not tail recurse
05:45:16 <copumpkin> saml: you have nothing to really compare it against
05:45:20 <saml> Y IT SO FAST???   щ(ﾟДﾟщ)
05:45:23 <copumpkin> that's a fairly tiny calculation by computer standards
05:45:30 <saml> > let f n | n <= 1 = 1 | otherwise = n * f (n - 1)  in f 700
05:45:31 <lambdabot>   242204012475027217986787509381235221859098338572920729945067966492993816021...
05:45:44 <saml> i mean no stack overflow
05:45:50 <saml> i think C version will fail
05:45:53 * saml tries
05:46:00 <mauke> not with a stack overflow
05:46:13 <copumpkin> saml: you have GMP lying around?
05:47:03 * Jafet quietly loads and cocks the mpz_fac_ui
05:47:11 <copumpkin> :P
05:47:39 <saml> oh c works. it outputs 0
05:47:40 <saml> nice
05:47:56 <Jafet> > let f n | n <= 1 = 1 | otherwise = n * f (n-1) in length.show$ f 100000
05:47:59 <lambdabot>   mueval-core: Time limit exceeded
05:48:49 <saml> hoa, python is fast too
05:49:33 <saml> > let f n | n <= 1 = 1 | otherwise = n * f (n - 1)  in f 100000
05:49:37 <lambdabot>   mueval-core: Time limit exceeded
05:49:48 <Jafet> > let bfold f z [] = z; bfold f z [x] = f x z; bfold f z xs = let (h,t) = splitAt (length xs`div`2) xs in f (bfold f z h) (bfold f z t); f n = bfold (*) 0 [1..n] in length.show$ f 100000
05:49:50 <lambdabot>   1
05:49:53 <copumpkin> saml: okay...
05:49:54 <Jafet> ..
05:49:55 <saml> oh i see. fac 700 is really not a big deal. python fails with fac(100000)
05:50:01 <Jafet> > let bfold f z [] = z; bfold f z [x] = f x z; bfold f z xs = let (h,t) = splitAt (length xs`div`2) xs in f (bfold f z h) (bfold f z t); f n = bfold (*) 1 [1..n] in length.show$ f 100000
05:50:03 <lambdabot>   456574
05:50:12 <Jafet> That's a crude approximation to what mpz_fac_ui does
05:50:35 <saml> > product [1..100000]
05:50:39 <lambdabot>   mueval-core: Time limit exceeded
05:50:50 <saml> wtf. so it's not the thing right?
05:51:04 <Kaidelong> > foldl1' (*) [1..100000]
05:51:05 <copumpkin> it's a big calculation, and will take a while....
05:51:08 <lambdabot>   mueval-core: Time limit exceeded
05:51:15 <copumpkin> run it on your ghci
05:51:22 <Kaidelong> (tail recursion had nothing to do with that failing)
05:51:30 <Kaidelong> (err I mean stack space)
05:51:36 <Kaidelong> (since that is in place)
05:52:05 <Kaidelong> err well perhaps not, I guess it might try to cache [1..100000]
05:52:17 <saml> so does ghc transforms my factorial to cps and optimize?
05:52:20 <Kaidelong> but that would be weird
05:52:34 <copumpkin> saml: do you realize that the vast majority of the time for factorial isn't spent in GHC?
05:52:38 <copumpkin> or your program
05:52:47 <saml> python for loop xrange version  is still running
05:52:48 <Jafet> bfold is a binary-splitting fold. It's faster because it's a better algorithm, not because ghc happened to like it more
05:52:54 <Ferdirand> in this case, you can no longer consider that the time for a multiplication is constant
05:53:36 <Kaidelong> jafet: wouldn't bfold have different semantics from foldr?
05:53:54 <Jafet> Not if f is a group operator
05:53:59 <saml> wow factorial is laarge
05:54:03 <Jafet> (And z is an identity)
05:54:08 <Kaidelong> Jafet: But it takes the length of xs
05:54:14 <Kaidelong> what if xs is not finite
05:54:38 <Jafet> Oh. Well, if you really think that is a problem, you can probably fix it
05:54:46 <Jafet> Process xs in increasing chunks
05:54:59 <xplat_> kaidelong: okay, it wouldn't have different semantics than foldl.  or foldr if f is strict in both arguments.
05:55:22 <copumpkin> omg a xplat_ 
05:55:25 <Jafet> I don't remember the last time I folded an infinite group
05:55:41 <xplat_> comg a copumpkin
05:55:48 <Kaidelong> also wouldn't taking the length itself impose a constant multiplier? Or is the compiler smart enough about that?
05:56:37 <Kaidelong> if your operation is commutative you could work around that though
05:56:39 <Jafet> It adds n * log n steps where n = length xs
05:57:34 <xplat_> taking the length isn't necessary if you just keep doubling, though
05:58:02 <Jafet> Only hairy academics do that sort of thing
05:58:06 <saml> so give me example function where stack overflow will be problem
05:58:16 <Jafet> > sum [1..1000000]
05:58:17 <lambdabot>   *Exception: stack overflow
05:58:19 <saml> i mean ghc does not use stack
05:58:34 <Kaidelong> Jafet: I thought they fixed that
05:58:38 <saml> oh why is that happening? but not product [1..100000]
05:58:46 <xplat_> i've done that in an incremental DHT calculator ...
05:58:51 <Kaidelong> > product [1..100000]
05:58:54 <lambdabot>   mueval-core: Time limit exceeded
05:59:05 <xplat_> Kaidelong: one less zero in yours anyway
05:59:13 <Kaidelong> > product [1..1000000]
05:59:14 <lambdabot>   *Exception: stack overflow
05:59:19 <Jafet> I thought ghc does use the hardware stack. And it does implement an evaluation stack. But probably not one with the other
05:59:24 <Kaidelong> how strange
05:59:41 <Kaidelong> I thought GHC was smart enough about + and * being strict to optimize those cases
05:59:52 <HugoDaniel> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline ahah this is great :D
05:59:53 <Kaidelong> but I guess it is not
05:59:53 <saml> why is sum [1..1000000] stack overflow? i don't get it
06:00:01 <Jafet> It does, if you ask it to optimize
06:00:03 <saml> it should use constant amount of memory
06:00:04 <Kaidelong> @src sum
06:00:04 <lambdabot> sum = foldl (+) 0
06:00:06 <xplat_> Kaidelong: maybe if you specialized sum on Int
06:00:21 <pozic> saml: 1 + 2 + 3 + 4 + 5 + 6 .. wouldn't your brain stack overflow too? 
06:00:21 <saml> why not foldr ?
06:00:33 <xplat_> but (+) is not strict for every Num
06:00:51 <Kaidelong> > sum [1..1000000] :: Int
06:00:52 <lambdabot>   *Exception: stack overflow
06:01:07 <xplat_> also ghci is less smart than ghc
06:01:13 <Jafet> HugoDaniel: like roman graffiti
06:01:14 <Kaidelong> > foldl' (+) 0 [1..1000000] :: Int
06:01:15 <lambdabot>   500000500000
06:01:19 <zygoloid> saml: foldr would stack overflow for strict (+).
06:01:21 <pozic> saml: it explicitly does not say evaluate(evaluate(1 + 2)+3)..
06:01:36 <saml> so how would you optimize it?  -O3 ?
06:01:52 <pozic> saml: O3 is there just for Gentoo users.
06:01:56 <saml> will sum [1..1000000] be optimized as for loop with -O3 ?
06:02:03 <Kaidelong> zygoloid: + is also associative so the compiler could potentially make it work even for foldr
06:02:20 <saml> or should i change my program somehow?
06:02:31 <xplat_> Kaidelong: the compiler would need a hint about the associativity though
06:02:36 <Kaidelong> but that would probably take something that is out of the scope of haskell
06:02:44 <Kaidelong> or something meta like what xplat just mentioned
06:02:50 <pozic> saml: sum [1::Int..1000000] could be opitmized, but you cannot depend on that.
06:02:57 <pozic> optimized*
06:02:58 <zygoloid> you could do that with a RULES, for foldr (+) -> foldl (+) (in the Int case)
06:03:07 <zygoloid> foldl' (+) rather
06:03:09 <xplat_> you could do it yourself with a RULE ... yeah, stereo
06:03:19 <saml> i want Integer
06:03:23 <Kaidelong> Well if you have something like .NET attributes, which I think we do?
06:03:29 <Kaidelong> you could mark it associative
06:03:41 <Kaidelong> and then make a rule for re-writing associative, strict operators in foldr
06:03:44 <pozic> saml: that could also be done, but GHC is not omniscient; far from it.
06:03:44 <Kaidelong> to foldl'
06:04:19 <saml> i mean in imperative languages, i can write for loop. is there a way to write for loop in haskell?
06:04:32 <zygoloid> @type forM
06:04:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
06:04:34 <saml> sum [1.. 100000000] :: Integer looks like for loop to me
06:04:58 <Jafet> saml: evaluate it by hand and see
06:05:07 <Kaidelong> zygoloid: mapM_ is closer to a for-loop IMO
06:05:19 <Kaidelong> saml: Yes you can write a for loop in haskell
06:05:23 <xplat_> foldl' (+) [1 .. 100000000] :: Integer is a fine loop
06:05:27 <Kaidelong> you just write the for loop, itself
06:05:32 <xplat_> *0
06:05:56 <Jafet> The problem is first to understand what a "for loop" is.
06:06:34 <Kaidelong> In this case it'd have a type like "m () -> (a -> Bool) -> m () -> (a -> m a) -> m a -> m a"
06:07:21 <Jafet> Also http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldl+%28%2B%29+0+[1%2C2%2C3%2C4%2C5]
06:07:32 <Kaidelong> err no
06:07:37 <Kaidelong> the result would be m ()
06:07:37 <Kaidelong> not m a
06:08:42 <pozic> fast_sum acc [] = acc;fast_sum s (x:xs) = let y = x + s in seq y (fast_sum y xs);my_sum = fast_sum 0 
06:08:55 <pozic> Something like that should also work. Using foldl' is the same. 
06:09:12 <pozic> This is just more explicit and easier to understand for beginners.
06:09:17 <ezyang> Wow. I think I wrote something like Hoopl when I was in High School. It wasn't as elegant, but it did sort of the same things. 
06:10:12 <pozic> saml: do you understand that?
06:11:20 <saml> http://codepad.org/8Wc6liPm  how would you do this in haskelll?
06:12:20 <Jafet> Heh, xrange
06:12:30 <pozic> saml: I just wrote that. 
06:12:34 <zygoloid> Kaidelong: for the flip or for the _?
06:12:37 <Jafet> I still cringe every time I see one
06:12:57 <Kaidelong> zygoloid: Asking in regard to what?
06:13:06 <zygoloid> mapM_ being closer to a for loop than forM
06:13:10 <saml> xrange is web scale
06:13:34 <pozic> saml is trollscale. 
06:13:36 <ManateeLazyCat> Haha, I'm reading "Core Python Programming": "List comprehensions come from functional language Haskell..." haha ... 
06:13:39 <Kaidelong> zygoloid: the _
06:13:41 <Kaidelong> @ty forM_
06:13:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
06:14:05 <zygoloid> ok, i'd agree with that. :)
06:14:09 <Kaidelong> ManateeLazyCat: Well they had to get it from somewhere
06:14:17 <Kaidelong> a lot of people think that generators come from Python now
06:14:23 <Kaidelong> sad, sad day
06:14:37 <ManateeLazyCat> Kaidelong: Because they just know Python. :)
06:14:44 <Jafet> Well, it doesn't involve thinking.
06:14:53 <Kaidelong> Oh but it does
06:15:11 <Kaidelong> figuring out how to code something in python that is relatively sane can be difficult
06:15:22 <mun__> in HOL, is "f(x) + g(x)" be a *term* of "f(x) + g(x) = 0"?
06:15:23 <Kaidelong> unless you accept imperative programming through and through
06:15:27 <Kaidelong> which I have trouble with
06:18:17 <ManateeLazyCat> Python looks very funny, some part from OOP, some part from functional language, and have code like this : "x if x < 2 else y"? Very funny....
06:18:55 <ManateeLazyCat> (x < 2 ? x : y)  isn't simpler?
06:19:07 <Jafet> The Dutch are well known for their drug culture
06:19:39 <ManateeLazyCat> Hehe. :)
06:21:33 <astroboy> ManateeLazyCat: You have x < 2 and x or y
06:21:40 <astroboy> wich is the ternary operator in python
06:21:45 <astroboy> *which
06:21:46 <ManateeLazyCat> astroboy: Oh, no.
06:22:02 <astroboy> ManateeLazyCat: well and or is ? : in python basically :P
06:22:09 <ManateeLazyCat> astroboy: Yeah, i just read "x < 2 and x or y", first feeling: "what?"
06:22:35 <astroboy> ManateeLazyCat: why? it makes sense to me
06:22:36 <zygoloid> x if x < 2 else y
06:22:49 <ManateeLazyCat> astroboy: I still think (condition ? true , false) is simpler expression.
06:23:01 <ManateeLazyCat> Less confuse
06:23:08 <astroboy> ManateeLazyCat: you are just replacing ? with and and : with or
06:23:10 <astroboy> but ok
06:23:15 <astroboy> matter of taste I guess
06:23:21 <Jafet> I want to name my values "then" and "else"
06:23:31 <ManateeLazyCat> astroboy: I'm Python newbie to feeling it's syntax. :) 
06:23:35 <Jafet> And "if", too
06:23:48 <zygoloid> x < 2 `if'` x $ y \o/
06:24:30 <Jafet> if' p t f = [t,f] !! fromEnum p
06:24:47 <Jafet> ("What infinite regression?")
06:25:09 <ManateeLazyCat> and "filter (lambda x: x % 2, seq)" waste my finger to type lambda, in haskell, just \x -> ... bla ...
06:26:14 <astroboy> ManateeLazyCat: I agree with you on that, but prefer Python's ternary over the C one :P
06:26:29 <ManateeLazyCat> :)
06:26:44 <astroboy> and there are way worse syntaxes than python's
06:27:12 <ManateeLazyCat> astroboy: So, i still prefer Haskell's syntax, simpler. :)
06:27:14 <astroboy> but it's hard to match haskell
06:27:21 <astroboy> well yeah I like it too eheh
06:27:39 <Kaidelong> python has nice syntax
06:27:41 <Kaidelong> that is not the problem
06:28:00 <ManateeLazyCat> astroboy: I'm try to learn Python to use it in linux system manage.
06:28:06 <astroboy> but you won't define much lambdas in python anyway
06:28:16 <astroboy> ManateeLazyCat: linux system manage?
06:28:19 <ion> Python’s lambda is crippled.
06:28:21 <Kaidelong> python is probably a good demonstration that syntax is important
06:28:59 <Kaidelong> python is not a very nice language to use but it is nice to look at
06:29:01 <merijn> ion: How so?
06:29:05 <Kaidelong> and that has helped it a lot
06:29:23 <Kaidelong> especially given that people were using things like Perl, bash, and Tcl before
06:29:28 <ManateeLazyCat> astroboy: Because I have linux version need to release, Python's library is builtin
06:29:30 <merijn> ion: Haskell's lambda can only contain expressions and so can python's.
06:29:38 <ManateeLazyCat> astroboy: We can't put Haskell compiler in it, too big.
06:29:44 <astroboy> Kaidelong: what's wrong with tcl?
06:30:04 <astroboy> I mean python and tcl are meant to do different stuff anyway
06:30:15 <Kaidelong> merijn: that's a good point actually. But if you extend python to allow its lambdas to be like Haskell's lambdas it wouldn't be idiomatic python anymore
06:30:25 <ManateeLazyCat> But i think Python is cleanest script language. :)
06:30:28 <merijn> Kaidelong: I think python is fairly nice as far as languages go. And I think readability is of critical importance in a language, hence why I think its so popular. (Readability is also why I think haskell rocks and ocaml sucks)
06:30:42 <Martty> haskell readable!?
06:30:51 <astroboy> ManateeLazyCat: python it's not meant to be a scripting language... I would rater use tcl eheh
06:30:51 <Jafet> Only if you want it to be.
06:30:52 <Martty> it's too terse to be readable
06:30:57 <astroboy> haskell is unreadable
06:31:00 <Kaidelong> merijn: that was my point exactly
06:31:00 <merijn> Martty: Haskell has pretty syntax and its fairly reasonable if people don't f- it up
06:31:02 <Martty> and there's no way to unterse it!
06:31:09 <Kaidelong> python has a lot of problems but it has nice syntax
06:31:15 <astroboy> Martty: I agree! and al those one-letter variable names
06:31:15 <Kaidelong> and syntax is important
06:31:18 <merijn> Martty: Sure there is, it's called type signatures and ":t"
06:31:25 <astroboy> and you have to look back a type classes and data types
06:31:27 <ManateeLazyCat> astroboy: I'm still in learning... correct me if i'm wrong. :)
06:31:44 <Martty> merijn: checking the docs helps too but that's out of the scope of reading code.. you turn to inspecting it :P
06:31:50 <Kaidelong> astroboy: A lot of things people write in haskell do not have any concrete explanations
06:31:54 <merijn> astroboy: Haskell is as readable as you make it, granted some people are experts in making it unreadable
06:31:57 <astroboy> I think it takes way longer to understand an haskell codebase compared to a python one
06:32:01 <Kaidelong> astroboy: for example, the "fmap" function
06:32:03 <fabjan> Kaidelong: that's not a fault of the syntax
06:32:13 <Kaidelong> fabjan: It is not a problem at all
06:32:21 <Kaidelong> but it explains single letter variable names and such
06:32:27 <ManateeLazyCat> astroboy: Yes, Haskell's one line include too many. :)
06:32:37 <Kaidelong> @src map
06:32:37 <lambdabot> map _ []     = []
06:32:37 <lambdabot> map f (x:xs) = f x : map f xs
06:32:46 <Jafet> astroboy: that just indicates that variable names are less important in Haskell.
06:32:48 <ion> merijn: Haskell has >>=, “let … in …” etc. to do more stuff in a single expression. In Python, the equivalent is a number of statements separated by newlines. I’ll be happy to be proven wrong, but you can‘t really put “more stuff” into a Python lambda.
06:32:53 <Kaidelong> what else would you use instead of f and x?
06:32:57 <Jafet> In fact, a lot of Haskell code has no letters.
06:33:10 <Martty> i like how type signatures help deduce what a function does which isn't present in python at all.. but im more concerned about the built in syntax of haskell that isn't as straight forward. it's probably just me not being entirely used to functional programing (just yet? :P)
06:33:15 <astroboy> merijn: I find myself spending more time understanding haskell the code, even if it's well written. you can't just take a chunk of code from a piece of software and read it
06:33:16 <fabjan> why would you use anything other than f or x? :)
06:33:27 <merijn> Martty: I'll grant you that 1 line of haskell can be harder to understand then 1 line of Python/C/Java, but when you look at entire codebase that one line of haskell may express a lot more functionality
06:33:36 * ManateeLazyCat Oh, war start...
06:34:04 <ManateeLazyCat> astroboy: That's true.
06:34:07 <Martty> it's a bit like in math.. you have the mathematical compact definition and you have it explained in laymens terms 
06:34:11 <Kaidelong> astroboy: part ofthe point of denotative programming is that you can talk about things in the abstract. Typeclasses turn out to help a lot with this, so in haskell people do it a whole lot
06:34:18 <merijn> ion: Yes, but let in are basically just syntactic sugar to not have to write an expression multiple times
06:34:31 <merijn> ion: You could manually duplicate the let's inside the expression for the same result
06:34:37 <merijn> You can do the same in python
06:34:37 <ManateeLazyCat> astroboy: You need math head to understand haskell code, then much simple. :)
06:34:39 <Kaidelong> abstract concepts can take a while to understand, even simple ones
06:34:40 <astroboy> Kaidelong: yeah that's why I call it "well written", but you still need some research to understand it
06:35:12 <astroboy> ManateeLazyCat: not really imho
06:35:24 <Kaidelong> astroboy: the benefits of programming in the abstract I think outweighs the problems of humans being bad at understanding the abstractions
06:35:34 <Kaidelong> they'll eventually use those abstract concepts in concrete code
06:35:55 <astroboy> Kaidelong: I agree completely. I still have to half an hour of haddock browsing before reading the code, that's it
06:35:55 <Kaidelong> and the abstract concepts are very versatile by nature
06:36:10 <Jafet> merijn: not exactly... let shares computation
06:36:21 <ManateeLazyCat> Kaidelong: But once you master abstract, then you have unusual power ... haha :)
06:36:27 <Jafet> In fact, let-binding is part of core
06:36:29 <Kaidelong> astroboy: I think it is more an inherent tradeoff rather than something haskell specific
06:36:39 <merijn> Jafet: Implementation detail
06:36:53 <astroboy> Kaidelong: yeah it's a problem older than haskell
06:37:01 <Kaidelong> so it's more a problem with "abstract programming" than with "haskell"
06:37:14 <Kaidelong> and the benefits of having that polymorphism outweight that
06:37:19 <Kaidelong> weigh even
06:37:28 <merijn> jafet; Lacking mutable state recomputing something and getting the same result is not semantically different from computing it once and using it multiple times
06:38:02 <Jafet> Another difference is with the dreaded monomorphism restriction
06:38:36 <merijn> astroboy: I'll agree with you that abstract programming is harder to understand. But you can write non-abstract haskell too. It'll be very verbose and annoying, but you could. So the problem is really "haskell programmers write more abstract/difficult programs" then "haskell is more difficult"
06:38:57 <astroboy> Kaidelong: yeah but python kind of sits in a sweet spot between abstraction and readability, and that's why it's nice. I still love haskell more but for small things that don't have to be "good" i'd go for python
06:39:24 <astroboy> merijn: well, haskell encourages that type of code
06:39:43 <Jafet> astroboy: that's fine, as long as you understand that this sweet spot is yours, not Haskell's nor Python's.
06:39:43 <merijn> astroboy: I think python's is also more convenient (convenient, not necessarily better) for "interactive code" i.e. UI's scriptable from inside the UI
06:39:48 <ManateeLazyCat> absentia: Yes, good point.
06:39:53 <Jafet> Many people don't, and this leads to problems.
06:40:05 <astroboy> Jafet: well yeah of course that's my experience
06:40:14 <Kaidelong> astroboy: I think Java actually lets me be more abstract about things
06:40:25 <ManateeLazyCat> merijn: You still can use haskell write interactive code. :)
06:40:30 <Kaidelong> since there is a clear seperation between prototypes and stateful instances
06:40:35 <Kaidelong> clearer, I should say
06:40:38 <astroboy> but sometimes stupidier code is better (for example GUIs)
06:40:47 <jonkri> what do you think about this do-block so far: [ http://paste.pocoo.org/show/343865/ ]... it feels a bit ugly but i don't know how to improve it
06:41:01 <astroboy> i don't know if that's an english word but whatever
06:41:02 <ManateeLazyCat> I don't like Java force me use OOP, but most time, it's good for project ...
06:41:06 <Kaidelong> I don't know, I think proper event handling and model-views make GUI work easier
06:41:09 <fabjan> astroboy: better as in faster to get out the door for beta testing?
06:41:16 <Kaidelong> ManateeLazyCat: OOP is nice
06:41:24 <Kaidelong> the problem with java is that it doesn't do it enough
06:41:31 <astroboy> fabjan: is better when you have to do stupid things
06:41:32 <Jafet> jonkri: what feels ugly about it?
06:41:35 <ManateeLazyCat> Kaidelong: yes, i know, i just don't want use OOP for *everything*
06:41:47 <astroboy> ManateeLazyCat: you have static functions in java
06:41:58 <astroboy> I don't see how python is less OOP than java ehe
06:42:14 <ManateeLazyCat> Kaidelong: In most Java programmer, then think: "world == OOP".
06:42:17 <Jafet> Oh dear, OOP in #haskell
06:42:22 <Kaidelong> ManateeLazyCat: If you mean that Java makes you use objects to do the work of higher order functions, yes, that's a problem
06:42:46 <ManateeLazyCat> Kaidelong: Infact, i still use Java for Android develop. :)
06:43:07 <Kaidelong> Yeah, I'm not a fan of java, but for any reasonably large project I'll take it over python
06:43:10 <jonkri> Jafet: hmm... the case... i'm a bit worried that it will be messy when i start validating the variables (like check that the realm is a certain host, etc)
06:43:16 <fabjan> Everything (well almost) is an object in Python, and yet writing classes is annoying because the language seems to frown on OOP
06:43:26 <Kaidelong> Although my current project is being done in a mix of OO and functional style in C#
06:43:49 <Jafet> jonkri: oh hm, I've never seen such a creative abuse of pattern matching before, actually
06:43:52 <ManateeLazyCat> Kaidelong: I always tell below words to my colleague, "This world not just have OOP..."
06:44:02 <Kaidelong> I must admit that C# is a pleasure to work with
06:44:04 <Kaidelong> even after haskell
06:44:12 <jonkri> Jafet: how are other people doing it? :)
06:44:16 <Kaidelong> although there are some weird things in there
06:44:22 <astroboy> ManateeLazyCat: well there is also the fact that Java OO is just one way of doing OO
06:44:23 <fabjan> super(Foo, self).__init__(*args, **kw)
06:44:29 <astroboy> the most popular way but still
06:44:32 <Kaidelong> like the lack of a generic "Set" data type in the standard libraries for some weird reason
06:44:32 <EvanR> Kaidelong: functional style in c# ???
06:44:50 <btutt> jonkri: What about using a view pattern instead of the r' == "jabber.org" bit?
06:44:51 <Jafet> jonkri: note that you can have guards on case-expressions: case foo of bar | baz -> quux
06:44:52 <Kaidelong> EvanR: Yeah, with C# 3.0 a lot of stuff is done with higher order functions
06:45:04 <EvanR> the syntax must be at least as bad as javascript
06:45:04 <Jafet> A view pattern is something rather different
06:45:06 <Kaidelong> IE "Aggregate" "Select" "Distinct" etc
06:45:14 <astroboy> EvanR: I love javascript! ehe
06:45:19 <ManateeLazyCat> astroboy: When i intro Haskell to my colleague, first reply is : "What? How to spell it? What is it?"   :)
06:45:27 * fabjan 's dayjob is in Smalltalk
06:45:28 <Kaidelong> EvanR: C# is getting to be a lot like Javascript.
06:45:39 <Kaidelong> but mostly in good ways
06:45:46 <Jafet> jonkri: also, you can use one "let" keyword to bind all those variables
06:45:58 <astroboy> JS is lovely I love the prototyping
06:46:03 <astroboy> and the functional side
06:46:05 <ManateeLazyCat> astroboy: How about Python's performance?
06:46:08 <EvanR> js could use a type system
06:46:23 <EvanR> type checking
06:46:32 <Kaidelong> ManateeLazyCat: People have managed to make python performant. Just not Guido's idea of python
06:46:34 <astroboy> EvanR: I don't know if I'd want a strongly typed js
06:46:37 <ManateeLazyCat> astroboy: I heard CPython, but haven't try. :)
06:46:43 <EvanR> i do, on a regular basis
06:46:45 <astroboy> ManateeLazyCat: it's ok, try cython if you need to go fast
06:47:08 <Kaidelong> EvanR: C# kind of resembles Javascript with a type system I guess
06:47:09 <ManateeLazyCat> astroboy: Oh, is cython, like jython, change name?
06:47:10 <ManateeLazyCat> :)
06:47:13 <btutt> JS lets you do interesting things, I don't think i'd ever call it lovely. I think its probably the most painful language I've ever dealt with following only directly after VB6's lame error handling
06:47:15 <EvanR> not necessarily statically typed, but at least some run time type checks
06:47:24 <EvanR> sanity checks, to be removed later
06:47:31 <jonkri> Jafet: hmm... what would that accomplish?
06:47:51 <EvanR> btutt: i guess you havent done any php yet
06:47:54 <Jafet> jonkri: nothing, except look prettier
06:47:55 <jonkri> btutt: that's useful to know, still don't know what i would case against if i checked all the conditions in guads though :)
06:48:04 <Kaidelong> C# could actually use some elegant syntax for currying
06:48:15 <btutt> EvanR: No, thank goodness.
06:48:24 <jonkri> thanks
06:48:28 <astroboy> btutt: Ok I don't like to work with JS, that's a pain, but I still like it
06:48:32 <Kaidelong> would be nice if "Func<Func<b,c>,a>" could be made easier to write
06:48:45 <astroboy> btutt: http://javascript.crockford.com/javascript.html
06:48:57 <EvanR> crockford is a serious jerk
06:48:58 <Kaidelong> you get "Func<c,a,b>" etc but that's not as general
06:49:26 <EvanR> Kaidelong: yeah in js i manually curry it
06:49:38 <Jafet> jonkri: http://paste.pocoo.org/show/343868
06:49:45 <astroboy> EvanR: lol why do you say that
06:49:46 <EvanR> i think 60% of my code is the word function and the word return
06:49:53 <Jafet> jonkri: your question still seems too vague
06:50:12 <Kaidelong> C# sort of lets you work around it by relying on type inference more
06:50:26 <Kaidelong> IE instead of some complex type you can write "var"
06:50:30 <EvanR> astroboy: an arbitrary personality cult centered around how to write code in a half assed scheme with C syntax
06:50:37 <Kaidelong> or use a lambda expression without any type signatures
06:50:42 <EvanR> its like a church or something
06:50:50 <astroboy> EvanR: I have no idea about the personality cult, I just browse his website sometimes
06:51:02 <Kaidelong> oh while we are speaking about stuff that isn't Haskell
06:51:05 <EvanR> well i hang out in the js channel
06:51:10 <Kaidelong> I'm really liking what I'm seeing of Liskell
06:51:14 <Kaidelong> does anyone here use it?
06:51:23 <EvanR> lisp without lisp syntax?
06:52:07 <astroboy> EvanR: I don't hang out in the js channel, so I don't know ehe
06:52:25 <jonkri> Jafet: that is pretty. i'm satisfied for now :)
06:52:37 <Jafet> Okay.
06:53:03 <Jafet> Where, of course, = is a syntax error and it should have been ->
06:53:48 <pozic> Kaidelong: I am not aware of anyone advertising that they use it, but it is a fairly good idea.
06:55:13 * ManateeLazyCat Haha, #haskell still so hot... :)
06:55:48 * ManateeLazyCat Reading "Core Python Programming", and sleep ...
06:55:59 <EvanR> its haskell, hes so hot right now
06:59:24 <ManateeLazyCat> Need sleep, good night all! :)
07:00:17 <saml> Y U SLEEP?
07:02:21 <Jafet> I only nanosleep
07:05:16 <Kaidelong> Y U SLEEP = (U (Y U)) SLEEP
07:05:55 <Omie_> Hi people !
07:06:04 <byorgey> hi Omie_ 
07:06:14 <Omie_> I need help to choose a book to buy
07:06:53 <byorgey> ok, ask away
07:07:39 <Omie_> I am trying to learn haskell from online resources since a month. but I am happy with my speed. Till now what I learnt about C/C++/Java/C#..VB.NET was using hard copy of book..
07:07:58 <Omie_> so.. I am giving up on online stuff for now and just getting a good book
07:08:03 <Omie_> I see number of options
07:08:10 <Omie_> not sure which one I should choose
07:08:29 <copton> Omie_: shich options do you see?
07:08:31 <Kaidelong> Ormie_: Bird & Wadler
07:08:35 <Kaidelong> is a good option
07:08:36 <Omie_> Real world Haskell is there
07:08:40 <Kaidelong> RWH too
07:08:49 <Omie_> Haskell (Programming Language) by Frederic P. Miller, Agnes F. Vandome, John Mcbrewster
07:08:55 <byorgey> Omie_: why are you learning Haskell/what do you want to use it for?
07:08:58 <Omie_> or just see this link http://www.flipkart.com/search-books?query=haskell&from=all
07:09:33 <Kaidelong> Ormie_: RWH is available online
07:09:37 <Omie_> hobby. I liked the functional way. Kindof tired of all common languages
07:09:39 <Kaidelong> and it is a good book
07:10:12 <Omie_> yea right.. but problem is I can't give much time to haskell when I am online. I get ample of time during travelling etc
07:10:22 <Omie_> so I just need a hardcopy for now
07:10:26 <Kaidelong> "Introduction to Functional Programming using Haskell" is quite a fine book
07:10:41 <Omie_> I've been here before if anyone remembers :-)
07:10:41 <Kaidelong> get a paperback copy
07:12:24 <roconnor> @seen dcoutts
07:12:25 <lambdabot> Unknown command, try @list
07:12:25 <preflex>  dcoutts was last seen on #haskell 6 days, 3 hours, 5 minutes and 57 seconds ago, saying: cheetah2003: it's due to changes in the libraries that lslplus depends on
07:12:42 <Kaidelong> http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089/ref=pd_sim_b_8
07:12:48 <Kaidelong> I've heard good things about this book
07:12:57 <Kaidelong> But I haven't actually read it
07:13:03 <Kaidelong> so I can't endorse it more than that
07:14:24 <saml> let's say  f :: IO Double     returns random number between 1 through 5.   how would you implement g :: IO Double that returns random number 1 through 7?
07:14:28 <Omie_> okay. Thanks. Looking at it
07:15:10 <copumpkin> saml: fmap fromIntegral
07:15:18 <saml> thanks
07:15:20 <copumpkin> ;)
07:15:26 <copton> I am strugling with RankNTypes. How can I make this example program to work? http://paste.pocoo.org/show/343887
07:16:38 <copumpkin> copton: you still can't make a list with Foo and Bar in it
07:16:42 <saml> how can I scale some thing ?  images
07:20:13 <Omie_> hey ! ordered RWH. Thanks :-)
07:21:01 <copton> copumpkin: so what's the difference between "f :: (forall t. (Typeable t) => [t]) -> Int
07:21:12 <copumpkin> what you're looking for is something like
07:21:15 <copton> copumpkin: and f :: (Typeable t) => [t] -> Int
07:21:32 <copumpkin> [exists t. (Typeable t) *> t] -> Int
07:21:43 <copumpkin> which you can't write in GHC directly
07:22:15 <copumpkin> data Blah = forall t. Typeable t => Blah t
07:22:22 <copumpkin> then you can write f :: [Blah] -> Int
07:22:30 <copton> copumpkin: oh, ic. Thanks
07:22:33 <copumpkin> and you'll have to wrap Foo and Bar into Blah
07:22:37 <copumpkin> to hide the actual types
07:22:42 <copton> yes, makes sense
07:22:43 <copton> thank you
07:23:24 <copumpkin> in JHC you can write first-class existential types, apparently
07:23:28 <copumpkin> I've never used it though
07:23:39 <jmcarthur> i always feel hesitant to teach existential types to people
07:23:54 <jmcarthur> so easy to fall back on habits common when using other kinds of type systems
07:24:23 <copumpkin> copton: oh yeah, DON'T USE EXISTENTIAL TYPES!!!
07:24:29 <copton> copumpkin: ;-)
07:24:36 <jmcarthur> i wouldn't go that far :P
07:24:46 <copton> copumpkin: if I knew what this exactly means...
07:24:49 <jmcarthur> treat it like fire
07:25:07 * copumpkin puts out the fire
07:25:17 <copumpkin> copton: DON'T USE EXISTENTIAL TYPES!!! RUN FOR YOUR LIFE
07:25:39 <copton> copumpkin: could anyone tell me how I recognize them? ;-)
07:26:24 <copton> copumpkin: seriously, Haskell books don't cover this. At least as far as I have seen. And from the online docu I don't get it.
07:26:54 <pozic> jmcarthur: why not use existentials?
07:27:13 <Jafet> "If you meet Sartre on the road, invite him to coffee"
07:27:14 <ccasin> yeah!  I think haskell existentials are great.  I use them all the time
07:27:32 <ccasin> copumpkin: why don't you like them?
07:29:26 <copumpkin> I use them all the time, but probably not where someone coming from another language would use them
07:29:41 <Kaidelong> jmcarthur: I do not generally use existential types but going without them seems like asking too much
07:30:17 <copumpkin> ccasin: cause the whole "existential with typeclass as interface" pattern is rather OO'ey, and can be expressed more nicely as a manual record of methods
07:30:39 <jmcarthur> Kaidelong: i never said that
07:30:40 <copumpkin> but I like using existentials to hide my stronger type guarantees in type indices
07:30:51 <Kaidelong> jmcarthur: Teaching them...
07:31:02 <jmcarthur> "hesitant"
07:31:09 <Kaidelong> yeah I know
07:31:09 <jmcarthur> not the same as "don't do it"
07:31:30 <jmcarthur> i just meant that i usually try to make sure they really need it before teaching it
07:31:31 <Kaidelong> I wasn't disagreeing with you
07:31:48 <jmcarthur> or that it's really the best way to go about it
07:32:15 <Kaidelong> There are some situations though where the information hiding provided by existential types is essential though
07:32:22 <jmcarthur> agreed
07:33:29 <jmcarthur> but the common pattern of  data Foo = forall a. Bar a => Baz a  is what most newbies first want existentials for, and i find that this is only rarely a good pattern to see
07:35:37 <Kaidelong> I do wonder why GHC cannot infer the type of stuff like [5,"c",True] though
07:35:43 <Kaidelong> or if it can
07:35:51 <Kaidelong> and the intention is just that you do not do so accidentally
07:36:29 <Jafet> Er, I cannot infer the type of that expression
07:37:35 <Kaidelong> http://www.haskell.org/haskellwiki/Existential_types#A_short_example
07:37:53 <Kaidelong> hiding the information is explicit
07:37:55 <ccasin> copumpkin: good point! I guess I just program with GADTs too much :)
07:38:43 * Kaidelong wonders what C# would do if he tried to make it infer that type
07:39:02 <Jafet> The explicit bit is telling ghc that its type is [forall a. Show a => a]
07:39:08 <Jafet> Or equivalent
07:39:13 <merijn> jmcarthur: What is a better way then using "data Foo = forall a. Bar a => Baz a" then?
07:39:34 <Jafet> I have no idea how it makes sense to infer a type for [5,"c",True]
07:39:57 <Kaidelong> Jafet: It is a list of things you cannot do any operations on
07:40:05 <Kaidelong> well those are all instances of show
07:40:18 <jmcarthur> merijn: it depends on what Bar actually is
07:40:21 <Kaidelong> actually now that I think of it
07:40:28 <Jafet> But you can probably hack up a semantics for that in ML.
07:40:29 <Kaidelong> doing that automatically might be intractable
07:40:53 <Kaidelong> unless you ignore typeclasses, in which case it just ends up being useless
07:41:04 <Jafet> Kaidelong: you can make up any new class or whatever other constraint that happens to apply to those values
07:41:27 <Kaidelong> (on the other hand, if the programmer explicitly hides the type information, checking that shouldn't be hard)
07:41:55 <Kaidelong> well I should say explicitly shows
07:42:12 <Jafet> Well, if you want to put it that way, you can say that it's programmer assisted type checking
07:42:25 <Jafet> Doesn't sound like a productive viewpoint to me though
07:42:35 <Kaidelong> Jafet: I was talking about inference though rather than checking
07:42:46 <Jafet> Er, right
07:42:49 <Kaidelong> I think inferring the best existential type might actually be intractable
07:42:55 <Kaidelong> so perhaps the explicitness is neccessary
07:43:13 <Jafet> If you have multiple classes that apply, there might be no "best"
07:43:19 <Kaidelong> F# has some automatic generalization mechanisms though
07:43:29 <Kaidelong> I am not sure how they work, but F# cannot infer types in general either
07:43:47 <JuanDaugherty> MS is really pushing F# 
07:43:51 <Jafet> It's ambiguous then, and the inferrer can only generate an obscure error miles down the code or pick a default
07:44:01 <Kaidelong> JuanDaugherty: Not really, but they should be
07:44:05 <JuanDaugherty> it's apparent one of the standard .net langs now
07:44:07 <Kaidelong> it's well designed
07:44:23 <Kaidelong> Yeah but it is not really a first class citizen yet
07:44:45 <Jafet> The important part is .net is the standard, not the languages
07:44:45 <JuanDaugherty> shows up in tabs with just c++, c#, and vb
07:44:46 <btutt> I like how they cleaned up the syntax so it was a little less Ocaml like.
07:44:50 <merijn> jmcarthur: Well a case where I'm using it is in a my umpteenth attempt of writing a game (multiplayer, so server) in Haskell. I have an "Event" type class and need a way to send events from the threads with a connection to a client so I have "data GameEvent = forall a. (Event a) => GameEvent a" and then use a "Chan GameEvent" to send everything to the main thread
07:44:55 <Kaidelong> I mostly use F# for scripting these days
07:45:01 <Kaidelong> not implementation
07:45:20 <merijn> Otherwise you'd have to have one chan per type that you want to send and everything becomes ugly quickly
07:45:23 <Kaidelong> but that's mainly due to the demands of my project
07:45:23 <jmcarthur> merijn: why not just an Event ADT? what does the Event type class actually provide?
07:45:43 <btutt> I'd like to try using F#'s async pattern sometime. Seems like a simpler syntax then doing the equivalent with the Task Parallel stuff in .net 4.0
07:45:55 <Kaidelong> btutt: the async monad is wonderful
07:46:11 <Kaidelong> Orc is somewhat similar
07:46:27 <Kaidelong> http://hackage.haskell.org/package/orc
07:46:37 <Kaidelong> you can use it for many of the same things, anyway
07:46:52 <merijn> jmcarthur: I remember there was a reason that didn't work, but since I haven't worked on it in a while so I don't remember exactly why
07:47:19 <jmcarthur> merijn: what does the client do with values of type GameEvent?
07:47:45 <Kaidelong> actually F#'s async monad might be pretty much exactly Orc
07:47:59 <jmcarthur> err
07:48:02 <jmcarthur> the main thread
07:48:13 <jmcarthur> i meant the receiver of GameEvents
07:52:24 <merijn> jmcarthur: Some update the game "state", some do not and they then get send on to 0 or more of the client threads to be send over the network. Which depends on the result of functions defined in the Event instance. I suppose you could pattern match on the constructors of an Event ADT and implement it like that, but that doesn't seem like a particularly clean solution?
07:53:11 <aristid> Kaidelong: "Provides an EDSL with Orc primitives." <- not very explanatory :/
07:53:15 <aristid> what is Orc?
07:53:48 <Kaidelong> aristid: It is a way for sequencing (and parallelizing) IO
07:54:16 <Kaidelong> IE "Orc a" could be seen somewhat like the F# "async<'a>"
07:54:26 <Kaidelong> although since it is in haskell and has to be pure
07:54:27 <aristid> i'm not familiar with F# or its async
07:54:49 <Kaidelong> runOrc gives you an IO () so you only use it for the side effects
07:55:15 <jmcarthur> merijn: well, an ADT sounds pretty clean to me, but i don't know the game
07:55:25 <Kaidelong> aristid: well, think of being able to say that things will happen on different threads, but not having to manage the resources yourself
07:55:46 <aristid> it would be really nice if it had documentation :)
07:55:50 <Kaidelong> IE "f <|> g" races two Orc's against each other
07:56:00 <jmcarthur> merijn: sounds to me like GameEvent could be a state function and a message to send via the network or something like that
07:56:11 <Kaidelong> aristid: there was a good paper on it in the last haskell symposium
07:56:44 <aristid> Kaidelong: yes? i'd like to read that
07:56:46 <Kaidelong> the lack of documentation is a bit odd
07:56:56 <aristid> odd? it's haskell.
07:57:01 <aristid> so that's normal :D
07:57:06 <jmcarthur> the orc paper is very good
07:57:24 <aristid> can you provide me a link to that paper?
07:57:33 <Kaidelong> http://code.galois.com/paper/2010/Hask-Orc-DRAFT.pdf
07:57:34 <Kaidelong> found it!
07:57:38 <aristid> thanks
07:58:01 <jmcarthur> i don't like orc's dependencies specification. they are given as weird version ranges. also, mtl 2 is still not included
07:58:32 <jmcarthur> the upper end of the range is given with <=
07:58:33 <aristid> i'm so glad i've got a duplex laser printer. *printing orc paper*
07:58:48 * jmcarthur envies
07:59:04 <aristid> jmcarthur: but you hopefully don't use an inkjet? :P
07:59:19 <jmcarthur> i *have* one, but that's different from using it
08:00:21 <rtharper> dcoutts: ping?
08:00:26 <aristid> jmcarthur: so you read that stuff on your computer screen?
08:00:35 <Kaidelong> it is well worth reading
08:00:43 <Kaidelong> I am sure you will enjoy it
08:01:41 <pastorn> hmm...
08:01:41 <jmcarthur> aristid: yeah
08:01:51 <pastorn> that "cut" function in the Orc paperL
08:01:53 <pastorn> ?
08:01:55 <pastorn> is that prolog cut?
08:02:20 * pastorn is just skimming through it at the moment
08:20:19 <rtharper> is there a flag to force ghc to recompile everything even when using --make
08:20:21 <tibbe> dcoutts: you there?
08:21:17 <Jafet> No, you need cabal for that
08:21:25 <kmc> rtharper, -fforce-recomp
08:21:28 <rtharper> cheers kmc
08:35:48 <aristid> Kaidelong: runOrc does not wait for the inner computation to finish, does it?
08:38:45 <Kaidelong> aristid: I imagine the point is that it does not block.
08:39:58 <Kaidelong> you'd have to use it for its side effects
08:41:07 <aristid> i checked it
08:41:08 <aristid> it blocks.
08:41:28 <aristid> runOrc (delay 5) in ghci does not give me a prompt until the 5 seconds have passed
08:42:46 <copton> does anybody see a way to generalize my merge function to work with arbitrarily large tuples? http://paste.pocoo.org/show/343929
08:43:48 <aristid> Kaidelong: so i think runOrc :: Orc a -> Orc [a] should be possible in theory. but you can implement it with side-effects and Chan, i guess
08:44:05 <djahandarie> copton, by not using tuples. :)
08:44:11 <aristid> runOrc :: Orc a -> IO [a] i mean
08:44:30 <copton> djahandarie: but I can't use a list, because the types of the things in the Maybes are all different.
08:44:40 <copton> djahandarie: at least I don't see how to do it with lists
08:44:54 <djahandarie> copton, no, you are correct.
08:45:09 <kmc> copton, generally not possible, because the different tuple types are totally unrelated
08:45:21 <kmc> http://hackage.haskell.org/package/tuple tries to hide this with type classes
08:45:30 <kmc> copton, what do you want to use this function for?
08:45:40 <Kaidelong> aristid: That actually makes sense. I guess computations inside it are non-blocking, but you want the whole computation to finish
08:46:00 <aristid> yes
08:46:26 <Kaidelong> Orc a -> IO [a]
08:46:30 <Kaidelong> you mean that?
08:46:57 <aristid> Kaidelong: i corrected myself above, so yeah.
08:47:05 <kmc> :t \(x,y) -> fromMaybe x *** fromMaybe y
08:47:05 <Kaidelong> ah I see
08:47:06 <lambdabot> forall t t1. (t, t1) -> (Maybe t, Maybe t1) -> (t, t1)
08:47:34 <Kaidelong> aristid: I guess the intention is to just make your main method call "runOrc" and do all the rest of your stuff in Orc and not IO, lifting IO into Orc
08:47:45 <aristid> Kaidelong: yes
08:48:04 <Kaidelong> err look at me using the word main method
08:48:10 <aristid> everything that needs to be in the parallel thingie
08:48:12 <Kaidelong> I guess it makes sense in a way
08:48:49 <roconnor> @free eta :: forall a. F a -> G a
08:48:50 <lambdabot> $map_G f . eta = eta . $map_F f
08:48:56 <copton> kmc: I am traversing a tree and I am invoking a handler function for each node I visit. Every handler can return a new node which replaces the old one. Given a node with say 2 children, as soon as any of them returns a new node I also have to create a new father node. This is where I need no merge the results of the handlers of the children.
08:49:20 <copton> kmc: and not all nodes of the tree have the same type. This is where my problem roots at.
08:49:47 <copumpkin> @free pure :: forall a. a -> F a
08:49:48 <lambdabot> $map_F f . pure = pure . f
08:51:25 <aristid> Kaidelong: Orc is parallel LogicT ;)
08:52:27 <jmcarthur> except concurrent, not parallel
08:52:50 <jmcarthur> well, parallel as well
08:53:02 <jmcarthur> s/except/more specifically/
08:53:08 <aristid> jmcarthur: i don't really have a clear mental separation of those two concepts
08:54:43 <ezyang> Concurrency is nondeterministic, parallelism not necessarily so. 
08:55:25 <kmc> concurrency is about nondeterministic semantics
08:55:31 <Kaidelong> concurrency can produce deterministic results
08:55:36 <kmc> parallelism is an implementation strategy for concurrency and for other things
08:55:52 <Kaidelong> although people usually talk about nondeterministic concurrency with IO
08:56:06 <aristid> doesn't concurrency have some strong requirements on the implementation strategy?
08:56:24 <Kaidelong> it basically says that computation can be interleaved or done in parallel
08:56:39 <kmc> there are useful systems with concurrent semantics that will never execute on more than one CPU core
08:56:58 <rtharper> what does the "@" sign signify in GHC core
08:57:11 <kmc> rtharper, a type argument i believe
08:57:23 <kmc> Core has explicit type lambda and type application
08:57:26 <kmc> as in System F
08:57:33 <rtharper> case GHC.List.filter @ Main.Route (\ (x_i14m :: Main.Route) ->
08:57:40 <rtharper> where Route is a type alias
08:57:57 <rtharper> is that saying filter where the type is [Route]?
08:58:00 <kmc> yep
08:58:03 <rtharper> cheers
08:58:12 <kmc> since filter's type starts with "forall a", the caller has to provide a type
08:58:51 <rtharper> aye
08:58:54 <rtharper> thanks =)
08:59:23 <roconnor> ddarius edwardk: do either you (or anyone else) know the standard order of arguments to horizontal composition of natural transformations (using the * operator)?
08:59:24 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
08:59:36 <aristid> Kaidelong: i think interleaved computation in the sense of non-cooperative multitasking (even on single-core computers) is often considered parallelism as well
09:00:33 <jmcarthur> aristid: concurrency is an abstraction. parallelism is an optimization.
09:00:42 <Kaidelong> aristid: I am not sure why you'd think of it that way. Parallelism is a concept that to me, suggests inherently being able to perform tasks in parallel, as opposed to simply interleaving them, and introduces considerations on run-time (and for unbounded parallelism, on complexity itself)
09:01:15 <Kaidelong> IE for a perfectly parallel machine a linear operation would become constant time
09:01:33 <aristid> Kaidelong: perhaps because the operating system provides the illusion of parallel tasks that are in reality interleaved
09:01:40 <quicksilver> http://www.haskell.org/haskellwiki/Parallelism_vs._Concurrency
09:01:46 <jmcarthur> aristid: more specifically, concurrency is when multiple threads/processes of computation execute independently and may interact with each other
09:01:53 <quicksilver> the terminology is not terribly consistent or standardised
09:02:00 <jmcarthur> aristid: parallelism is when you speed a computation up by dividing the work and performing the units at the same time
09:02:03 <Kaidelong> parallelism is more about actual parallelism I think
09:02:08 <jmcarthur> aristid: not that neither requires the other
09:02:10 <quicksilver> but all the academics I ever spoke to felt the two words had different meanings.
09:02:22 <Kaidelong> concurrency is general enough that you can do interleaving and call it concurrency
09:02:25 <jmcarthur> *note that
09:03:10 <jmcarthur> Kaidelong: "for a perfectly parallel machine a linear operation would become constant time"  <-- only if every step of that computation is independent of all others
09:03:14 <Kaidelong> I would say that parallelism implies concurrency but not vice versa, unless you take concurrency to mean nondeterministic concurrency specifically, but that is a whole new can of worms
09:03:23 <Kaidelong> jmcarthur: that's true
09:03:34 <quicksilver> JaffaCake's take : http://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/
09:03:38 <Kaidelong> that's also P=CP or whatever
09:04:01 <Kaidelong> I forgot the actual names of the classes
09:04:17 <tg_> are there 'denotational semantics' implementations for parallel things versus concurrent things?
09:04:25 <Veinor> PCP? we don't appreciate drug talk here. :D
09:04:27 <tg_> Wouldn't such a semantics help describe the difference?
09:04:42 <Kaidelong> but nobody has proven one way or another than there are computations that can't be parallelized. It seems unlikely that there wouldn't be, though
09:04:45 <jmcarthur> tg_: seems to me that the denotational semantics of something should be the same whether it has a parallel implementation or not
09:05:08 <jmcarthur> tg_: for example, [|par a b|] = b
09:05:15 <tg_> jmcarthur: I mean to focus on the difference between a parallel vs concurrent thing, not a [non-parallel] vs parallel
09:05:33 <jmcarthur> ah, concurrency very well could be assigned a denotational semantics
09:05:56 <jmcarthur> frp is one attempt, but it is meant to characterize continuous concurrency, whereas normally we think of concurrency as imperative and/or interleaved
09:06:01 <tg_> the question being, would doing so reveal insight into the difference in meaning?
09:06:31 <Kaidelong> jmcarthur: It is generally good to adopt continuous models though
09:06:40 <Kaidelong> they're more amenable to being analyzed
09:06:49 <jmcarthur> well
09:06:57 <jmcarthur> if the model can be discovered at all
09:07:08 <Kaidelong> (you can use continuous models to describe things that actually are not continuous after all)
09:07:10 <tg_> Kaidelong: as a quantum physicist, I would argue that
09:07:13 <jmcarthur> i agree in principle
09:07:36 <tg_> as do I, but it's more that they [discrete] versus [continuious] analysis are really distinct and incomparable in many senses
09:07:45 <tg_> at least for physical systems
09:07:55 <jmcarthur> agreed
09:08:11 <Kaidelong> tg_: I suppose that is where you'd run into problems, where no good continuous model exists
09:08:13 <tg_> it's true that you can setup a system where one is the limit of the other. But in general, you can't do this both ways
09:08:17 <Kaidelong> I think for most software that we work with in practice though, that is not the case
09:08:24 <jmcarthur> i wouldn't feel right modelling quantum physics in terms of fundamentally continuous axioms
09:08:34 <tg_> Kaidelong: more like, that's where you run into reality, or experiment, depending on what kind of physicist you are
09:08:53 <duckinator> hi
09:09:04 <Kaidelong> morning
09:09:21 <duckinator> afternoon :P
09:09:50 <tg_> jmcarthur: I am working on the problem, but I think there are good hints (mathematically explorable ones) that we should look at the justification for using Reals/Complexes so often instead of Integers or Rationals
09:10:14 <jmcarthur> Kaidelong: anyway, i'm with you that continuous semantics (or even better, semantics that generalize continuous and discrete models) tends to be simpler to use
09:10:52 <tg_> Kaidelong: in physics, the easiest (and honestly, the most correct) place that you can introduce quantization in physics, is at the commutator (so, Algabraic) level
09:11:19 <tg_> which is the relationship
09:11:30 <tg_> [a, b] = a*b - b*a = ih
09:11:43 <jmcarthur> calculus gets a bit more complicated when you deviate from Reals
09:11:54 <tg_> jmcarthur: yeah, but in physics it's not so bad
09:12:11 <tg_> because everything that'd in the dynamics is encoded in a unit circle
09:12:18 <tg_> s/that'd/that's/
09:13:20 <tg_> anyway, I agree with you in principle, which is why my route of investigation is on things which have dynamics which take [Z/nZ] to [C]
09:13:46 <rtharper> anyone ever had problems getting ghc-core to build on OS X from cabal-install?
09:13:52 <rtharper> or at all? ;)
09:14:07 <tg_> but for both of you, I think that using continuous versus discrete things in these places is still an open question; and I don't think we should be surprised to learn that our intuitions on the matter are wrong
09:14:48 <jmcarthur> tg_: agreed
09:15:38 <tg_> jmcarthur: I mean, we ought to admit, both our computers and our physical universe evidently prefer a discrete implementation
09:16:03 <Kaidelong> tg_: Certainly, but that doesn't mean it is easier to think about
09:16:15 <tg_> only recently have we invented circuits which aren't totally discrete (memristors)
09:16:24 <jmcarthur> http://en.wikipedia.org/wiki/Analog_computer :P
09:16:30 <tg_> Kaidelong: yeah, maybe so, but it also might be wrong
09:16:34 <Kaidelong> well you can compute with analog models
09:16:42 <tg_> jmcarthur: I mean, discrete circuit elements
09:16:42 <Kaidelong> it is just hard to make those computers programmable
09:17:41 <jmcarthur> i will admit that the suckiest thing for me in thinking about frp models is how to handle infinitesimals
09:17:48 <jmcarthur> or the lack thereof
09:18:39 <Kaidelong> jmcarthur: Well you don't have to, even if they should exist in the model that you're thinking of, to do calculus
09:19:11 <jmcarthur> Kaidelong: i'm still fuzzy on meaningful differences between limits and infinitesimals
09:19:18 <Kaidelong> but you could implement something convincingly enough like the continuous model that does not neccessarily have a sensible notion of infinitessimals
09:19:34 <tg_> jmcarthur: the sums view versus the intergrals view
09:20:10 <jmcarthur> tg_: you are referring to reimann sums?
09:20:17 <Kaidelong> actually the whole point of moving away from the discrete model in the first place is because you want to get rid of the burden of having to be exact about what you want
09:20:30 <tg_> jmcarthur: maybe?
09:20:36 <tg_> at least riemann sums
09:24:01 <tolkad> How do you force ghc to create a new function with each variable reference replaced by its value after a partial application?
09:24:30 <tolkad> From what I have heard, normaly if you partially apply it will just wait to evaluate until you have supplied all arguments
09:24:38 <tolkad> nromally*
09:25:00 <pozic> tolkad: you want a partially evaluated partial application?
09:25:10 <tolkad> pozic: yes
09:25:15 <pozic> tolkad: I suggest you modify GHC.
09:25:17 <jmcarthur> tolkad: you seem to be talking about lazy specialization. ghc will statically specialize partial applications, but can't do it dynamically
09:25:46 <tolkad> pozic: I think it's possible if you do something with CAF?
09:26:08 <jmcarthur> tolkad: the only way to do what you want would be to abandon the function representation of whatever you're doing and do a manual data representation for it
09:26:27 <jmcarthur> defunctionalization is not always obvious, but it's all i can suggest
09:26:53 <tolkad> huh, thanks
09:26:56 <pozic> Functions only make your code slower. 
09:27:23 <jmcarthur> tolkad: so you could have a function that take the first parameter and then performs some computations with it and gives some data as a result, then you can pass that data to another function along with the next parameter
09:27:24 <pozic> The more your code looks like the code have written for 30 years in C, the faster it will be on common hardware.
09:27:27 <jmcarthur> *takes
09:27:34 <jmcarthur> pozic: that's not always true
09:27:42 <pozic> jmcarthur: no, nothing is always true.
09:27:52 <mauke> pozic: paradox
09:27:57 <jmcarthur> i'm only talking about the specific case that you need this specialization dynamically
09:28:00 <tolkad> pozic: I'm not wanting this in general, just for a few specific functions I wrote
09:28:10 <tolkad> pozic: Apparently I need to rewrite them differently
09:28:17 <pozic> jmcarthur: it is virtually impossible to say anything if it has to be completely true. 
09:28:21 <monochrom> I'm pretty sure a substantial amount of 30-year-old C code is suboptimal.
09:28:38 <pozic> monochrom: I was referring to the machine point of view. 
09:28:41 <kmc> C compilers have changed a lot in 30 years
09:28:55 <jmcarthur> tolkad: there may be ways to convince ghc to improve things for you, but any advice to give would require a lot more detail than i care to absorb right now
09:28:58 <pozic> Forget I said anything. 
09:29:10 <kmc> a lot of the "clever tricks" of yore now produce worse machine code than the straightforward way
09:29:28 <jmcarthur> s/straightforward/higher level/
09:29:39 <monochrom> alright, from the machine point of view, and there is empirical evidence, using continuations (functions) is faster than dispatching on data.
09:29:41 <pozic> mauke: :)
09:30:10 <pozic> monochrom: where is this evidence? 
09:31:22 <jmcarthur> monochrom: do you mean, basically, that unconditional jumps are faster than conditional jumps?
09:32:03 <monochrom> monad-control is a faster rewrite of monad-control of monad-peel. monad-control uses CPS.
09:32:28 <jmcarthur> that sounds more like a compiler point of view than a machine point of view. am i missing something?
09:32:49 <monochrom> last year or so, someone experimented with modifying attoparsec to use continuations instead of data and also got faster results.
09:33:29 <monochrom> dispatching on data is a bit more than conditional jump. first you have to read the data...
09:33:50 <tolkad> pozic: imagine I am writing a calculator. This calculator has a function of type « String -> Rational -> Rational » where the string represents 1 of 50 operators. Now let's say my calculator has a "fold" function which takes an operator, and folds it through a list of numbers. I would not want to figure out which operator to use each time I apply it to a number in the list.
09:34:38 <Saizan> tolkad: ok, so you've to define that function like this: f str = \r -> ..
09:35:00 <monochrom> some iteratee/enumerator thing also enjoys speedup after using more continuations, but I don't remember the exact reference
09:35:25 <tolkad> Saizan: really? that works? I thought « f str r » and « f = \str -> \r -> » were semantically equivalent
09:35:46 <Saizan> tolkad: actually, f str = let op = determineOperator str in \r -> ..
09:35:54 <monochrom> it pays to subscribe to haskell-cafe because most of these experiments are reported only there
09:35:59 <lispy> monochrom: didn't tibbe show recently that CPS is no longer a win in GHC
09:36:10 <Saizan> tolkad: denotationally yes, operationally no
09:36:31 <Kaidelong> Saizan: Really?
09:36:37 <tolkad> Saizan: so ghc just makes an arbitrary distinction between them?
09:36:40 <pozic> monochrom: idiomatic Haskell loses pretty much every battle with idiomatic C on the mailing lists.
09:37:02 <lispy> pozic: um, relative to what?
09:37:09 <mauke> oh god, now there's battles
09:37:09 <Saizan> tolkad: it makes the natural distinction between them, actually
09:37:19 <lispy> pozic: I mean, idiomatic haskell is much easier to read/maintain
09:37:35 <tibbe> lispy: it's sometimes a win :/
09:37:47 <pozic> lispy: Haskell is fine for certain applications, but not for high-performance applications. 
09:37:59 <tibbe> lispy: e.g. making attoparsec completely non-CPS slows it down a lot
09:38:04 <kmc> pozic, consider how much real-world work is done in PHP, Python, and Ruby
09:38:07 <kmc> with their respective interpreters
09:38:13 <Kaidelong> pozic: You don't have to write every part of a haskell application in haskell
09:38:14 <xplat_> you spend longer waiting for the computer to finish running the program, but not as long waiting for the programmer to finish writing the right program?  :)
09:38:16 <tibbe> lispy: GHC seems to have problems with loops expressed using CPS
09:38:19 <kmc> GHC Haskell beats all of them soundly
09:38:23 <lispy> tibbe: I see.  So CPS isn't bad, it's just that you have to try it and see what you get?
09:38:25 <pozic> kmc: sure, but I do not count those as being high-performance. 
09:38:32 <tibbe> lispy: right
09:38:39 <copumpkin> just write everything in agda
09:38:43 <lispy> tibbe: in that case, it sounds like benchmarking as usual :)
09:38:44 <kmc> pozic, right -- my point is that your "certain applications" includes most things people do with computers
09:38:45 <copumpkin> its compiler is super efficient
09:38:52 <tibbe> lispy: I'm talking to Simon PJ about the issue and hopefully we could make it "always" be a win
09:38:53 <pozic> kmc: I might even agree with that.
09:38:59 <tibbe> lispy: always benchmark!
09:39:04 <lispy> tibbe: that would rock :)
09:39:07 <kmc> of course "idiomatic C" will be faster than idiomatic Haskell -- also much harder to write and debug
09:39:24 <pozic> Debugging C is pretty easy. At least there are tools.
09:39:39 <Kaidelong> kmc: But what if you use a C compiler that doesn't produce performant output
09:39:41 <lispy> the need to debug C is also greater in my experience
09:39:50 <kmc> i agree that Haskell could use better debugger tools
09:40:04 <kmc> but in practice i get by fine with ghci and the occasional Debug.Trace
09:40:09 <copumpkin> bug zygoloid 
09:40:11 <Ke> even C could use those
09:40:14 <copumpkin> he's writing an awesome debugger
09:40:17 <lispy> Although, even with good debugging tools, much of the C I write these days can only be debugging with printf or other means of output
09:40:19 <xplat_> pozic: one delayed-action memory-corruption bug can sometimes wipe out all the gains that tools give you in the lifetime of an application
09:40:23 <lispy> I often can't run gdb where my C runs
09:40:26 <kmc> it's just much easier to debug composable, side-effect-free code
09:40:37 <copumpkin> hades, I think he called it
09:40:39 <kmc> and that's true in c as well, but then you're far from "idiomatic C" and also far from good performance
09:40:41 <lispy> (maybe I'm not running C in the right places?)
09:40:44 <kmc> copumpkin, yeah, it's a really cool project
09:40:45 <tolkad> how do you use ghci with a cabal package?
09:40:46 <pozic> xplat_: delayed-action memory-corruption bug?
09:40:46 <Kaidelong> wasn't that actually something you could prove?
09:40:55 <lispy> tolkad: cabal-dev ghci
09:40:55 <Ke> xplat_: use valgrind
09:40:57 <kmc> tolkad, you mean under development?
09:41:12 <tolkad> kmc: like if the build depends on options in the .cabal file
09:41:23 <tolkad> kmc: like CPP options, extensions to enable, etc.
09:41:23 <mauke> @pl \ys -> fmap ($ ys) fs
09:41:23 <Kaidelong> that if your code is pure debugging it becomes much easier because you have less permutations to worry about
09:41:24 <lambdabot> flip fmap fs . flip id
09:41:28 <kmc> you'd do "cabal configure && cabal build" as usual
09:41:30 <kmc> and then http://mainisusuallyafunction.blogspot.com/2010/09/ghci-and-cabal.html
09:41:37 <xplat_> pozic: you access a freed pointer, it corrupts something deep in a large data structure, 220 minutes later when something dereferences that pointer, SEGV
09:41:38 <tolkad> kmc: thanks
09:41:55 <kmc> xplat_, but your program ran OMG SO FAST for those 220 minutes! :)
09:42:09 <kmc> who cares if the airplane crashes as long as it got there fast
09:43:56 <xplat_> Ke: admittedly tools have become better.  when i used to write C there was no valgrind, although there was purify if you could afford it
09:44:09 <tolkad> I like haskell because it is possible to avoid the design pattern madness that saturates OOP
09:44:22 <duckinator> kmc: the airplane landed 1 nanometer short of the target ;)
09:44:40 <pozic> xplat_: there is always some way to debug. You can write your own tools if there are no tools.
09:44:47 <Kaidelong> tolkad: I think design patterns are generally more a consequence of imperative programming and gimped language features than object oriented programming
09:44:51 <Ke> I still don't trust compiler to always to agree with you
09:44:59 <duckinator> pozic, xplat_: printf, PRINTF EVERYWHEREEEEEEEEE
09:45:06 <Ke> that's where really high level languages fail
09:45:33 <Kaidelong> object oriented programming is a great way of dealing with things that are inherently stateful and nondeterminstic in a sane way
09:45:33 <lispy> Instead of design patterns, we have FRP, category theory, monad transformers, DSLs
09:45:34 <pozic> xplat_: also, I try to write my programs in such a way that I know what it should do - and then I verify those properties at run-time if I really have a bug.
09:45:42 <pozic> xplat_: in the limit I have correctness, then. 
09:45:48 <duckinator> seriously, though, printf() spam is the most exciting method of debugging C ;)
09:45:57 <Kaidelong> lispy: To be fair a lot of those things are more general than design patterns
09:46:04 <kmc> tolkad, it doesn't pervade good OOP
09:46:14 <kmc> tolkad, just the poorly expressive languages like Java
09:46:20 <xplat_> pozic: haskell has assert, and it even has quickcheck too.
09:46:27 <Ke> some awesome set -xs like debugger with valgrindlike features for C would be awesome
09:46:31 <lispy> (I don't see design patterns as a bad thing, BTW)
09:46:32 <pozic> xplat_: yes, but you can write similar tools for C.
09:46:47 <Ke> with divine abilities to print only relevant information
09:46:48 <tolkad> kmc: oh. most of my experience with OOP is in Java and PHP
09:46:49 <pozic> xplat_: I am not saying Haskell is a bad application programming language. 
09:46:52 <Kaidelong> lispy: they are in numbers
09:46:56 <duckinator> i don't think the issue is OOP so much as bad implementations and side-effect galore ^^
09:47:01 <xplat_> pozic: why don't we have quickcheck for C then?
09:47:02 <tolkad> kmc: I still have nightmares about PHP OOP
09:47:10 <Ke> eg. llvm with excellent ui design
09:47:11 <pozic> xplat_: because nobody cared to write it.
09:47:16 <maurer_> tolkad: itym PHP
09:47:20 <Kaidelong> lispy: and some design patterns should not really have a reason for existing. Like the visitor pattern
09:47:22 <duckinator> tolkad: those are quite possibly the absolute worst non-esoteric (questionable?) languages i've used
09:47:36 <pozic> xplat_: there probably is no market for it.
09:47:54 <pozic> Developer tools always have had a bad market.
09:48:08 <duckinator> tolkad: perl is in the same ballpark, at least pre-6. haven't tried perl 6 so i can't say anything on that
09:48:13 <lispy> I think the law of averages has a bigger impact than we realize when debating languages paradigms.  Most programs get written in "OOP" languages.  Most programs are going to be somewhere around average.  Then with Haskell you tend to have people who care deeply about having correct or elegant programs writing them.  You get selection bias in the Haskell community.
09:48:15 <Kaidelong> actually you could argue that a design pattern is a sign that the language is interfering with reusability and making the programmer repeat themselves
09:48:16 <sproingie> there are things like quickcheck for C libraries.  fuzzers are an example.
09:48:31 <sproingie> not quite the same thing but the idea is similar
09:48:32 <pozic> sproingie: a fuzzer is slightly different. 
09:49:03 <tolkad> duckinator: meh, perl has its niche. small string processing scripts that don't need to be efficient
09:49:09 <lispy> I would argue that the secret sauce of Haskell being cool is selection bias.
09:49:13 <pozic> Kaidelong: Haskell without TH also has lots of repetition. 
09:49:17 <duckinator> tolkad: if you don't care about efficiency, use ruby. perl's horrifying :(
09:49:26 <mauke> duckinator: I like perl
09:49:42 <Jafet> fractran is horrifying. perl is queer.
09:50:01 <sproingie> a sophisticated fuzzer can be told to generate particular inputs, such as ones that actually are valid within the range, so as to test specified behavior.  agreed that it's not quite the same thing tho, but the idea applies
09:50:05 <xplat_> a fuzzer basically only checks the property of memory-correctness
09:50:26 <xplat_> which you get for free in haskell
09:50:40 <c_wraith> There are other kinds of fuzzers.
09:50:50 <tolkad> pozic: yeah I think it would be cool if we could use more type-level hackery in place of TH
09:50:50 <duckinator> mauke: admittedly half the issue is coders who write code in 20 seconds. hopefully you're a rarity, or a real good coder? :D
09:51:02 <xplat_> well, there are a couple of nontrivial properties you can check with fuzzers if you try a little harder, but it's still a lot less accurate and targeted than quickcheck
09:51:26 <duckinator> mauke: i still find the syntax repulsive either way, but half the problem is the coders (similar deal with java. it's got issues, but that's amplified by the huge amount of crap code)
09:51:51 <mauke> duckinator: I don't see what's so bad about the syntax
09:52:25 <tolkad> Just write your code as inefficient as you want and hope that one day the compiler will be able to optimize it
09:53:15 <xplat_> mauke: perl syntax for some things is very pretty, but for using references it can get pretty nasty
09:53:44 <xplat_> push @{$stacks->[$n]}, $frame
09:54:20 <mauke> $stacks->[$n]->$push($frame);  # cheating
09:54:24 <xplat_> and that's despite all the syntax sugar with ->
09:55:08 <tolkad> Is there a perl module for programming in Cthulu Mythos language?
09:55:37 <xplat_> mauke: $push = sub { my $a = shift; push @$a, @_ };?
09:55:54 <tolkad> @quote tolkad
09:55:54 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
09:56:08 <mauke> xplat_: yes, except not called '$a'
09:56:29 <duckinator> mauke: my issues are mainly: the indecision about whether parens are required, oddball syntax quirks (such as $_, <$x>, ...), and that it's 'strict' setting is not enabled by default
09:56:34 <xplat_> clever, and pretty, but kills speed.  perl has more of a bytecode transliterator than a compiler after all ... definitely doesn't lambda-lift
09:57:31 <duckinator> i do hope that lambdabot quote is a joke. calling PHP elegant or simple is like calling a Rube Goldberg machine simple..
09:57:33 <mauke> duckinator: $_ is regular syntax. I agree < > is bad. parens are required when they're required, which is pretty much like in haskell
09:57:40 <xplat_> or inline method calls either, even the ones that provide subrefs
09:57:41 <aristid> tolkad: did you really say what lambdabot claims you said?
09:57:58 <jmcarthur> tolkad occasionally dabbles in trolling ;)
09:58:07 <duckinator> mauke: print "foo"; print("foo");
09:58:13 <jmcarthur> but at least he's not a jerk :)
09:58:28 <mauke> duckinator: there the parens aren't required (just like in haskell)
09:58:59 <duckinator> mauke: what about with print("foo","bar")?
09:59:05 <mauke> same thing
09:59:13 <mauke> as in: parens not required
09:59:20 <duckinator> alright, so it's just indecision on behalf of the coder, in that case?
09:59:22 <xplat_> mauke: the slightly annoying thing is it matters if the first argument is parenthesized when you have multiple arguments
09:59:30 <mauke> duckinator: yeah, pretty much
10:00:00 <mauke> duckinator: btw, 'strict' is enabled by not-quite-default in 5.12
10:00:03 <xplat_> print ("foo"), "bar";  # will only print foo
10:00:13 <duckinator> mauke: 'not-quite-default'? care to elaborate?
10:00:40 <mauke> that is, if your program starts with 'use 5.12.0;', it automatically enables strict and all new 5.12 features
10:00:50 <duckinator> ah.. well, it's an improvement
10:01:05 <mauke> xplat_: C compatibility :-(
10:01:50 <mauke> xplat_: but how would you disambiguate otherwise?
10:02:02 <mauke> lisp-like (f x)?
10:02:07 <duckinator> isn't a language's inability to handle `print ("foo"), "bar"` properly usually due to not knowing (or at least not using knowledge of) the number of args a function expects? but i don't think it's possible to disambiguate that with a variable number of args...
10:02:14 <xplat_> not that i hate perl ... it's my favorite language other than haskell and scala, and i probably use it more than either in practice
10:02:34 <mauke> duckinator: define "properly"
10:02:41 <Kaidelong> I do not hate perl I guess
10:02:43 <mauke> duckinator: print sqrt 2; doesn't work in haskell either
10:02:51 <Kaidelong> but I could never really understand anything written in it
10:02:53 <mauke> even though it's "obvious" what it should do
10:02:59 <Kaidelong> just modify it half blind
10:03:04 <duckinator> mauke: not quite. different thing.
10:03:08 <mauke> duckinator: how so?
10:03:15 <Kaidelong> writing perl is quite a lot easier than changing existing perl, too
10:03:46 <xplat_> anyway, i feel like python is a read-only language as much as perl is write-only
10:03:47 <duckinator> mauke: if the function `foo` takes two args, shouldn't it be able to determine `foo (1), 2` is the same as `foo((1),2)`?
10:03:51 <Kaidelong> then again at that shop the java code they had was pretty awful too
10:04:01 <mauke> duckinator: ew
10:04:13 <Kaidelong> so perhaps it is more a function of the programmers (who were all physicists) than perl itself
10:04:22 <xplat_> and ruby looks nice but the culture ruins it.  too accepting of monkey-patching etc
10:04:22 <mauke> Kaidelong: oh, ouch
10:04:24 <duckinator> mauke: "ew" what?
10:04:47 <mauke> duckinator: shouldn't haskell be able to determine that print sqrt 2 is the same as print (sqrt 2)?
10:04:48 <duckinator> mauke: i'm not talking about the specific example, i'm talking about the idea.
10:04:59 <mauke> I mean, just look at the types
10:05:26 <duckinator> mauke: but perl doesn't give an error, i'm pretty sure haskell does. that's where the difference is
10:05:27 <roconnor> mauke: then haskell would become the HTML of programming languages
10:05:28 * duckinator double checks that
10:05:43 <roconnor> :)
10:05:45 <duckinator> yup, it gives an error
10:05:47 <mauke> well, you'll get a warning for 'print ("foo"), "bar";'
10:05:50 <mauke> or two
10:06:09 <xplat_> mauke: not as clear for sqrt sqrt 2, though.  in lambdabot sqrt is a Num :)
10:06:24 <mauke> > sqrt sqrt 2
10:06:25 <duckinator> mauke: well... `use strict; print (1), 2;` gave no warnings/errors...
10:06:25 <lambdabot>   1.189207115002721
10:06:31 <mauke> duckinator: use warnings;
10:06:36 <roconnor> xplat_: though the two different interpretations turn out to be identical
10:06:55 <xplat_> roconnor: heh, it's true
10:07:29 <duckinator> mauke: alright, that at least tells you it's doing something funky
10:07:38 <mauke> duckinator: anyway, doing that would require the function to be known at parse time
10:07:47 <mauke> that includes human readers
10:08:44 <duckinator> mauke: mmm, my point (which i poorly explained) was that it should either work as expected, or give a warning/error. not silently fail. `use strict; use warnings;` makes it quite a bit better, but i prefer that kind of functionality by default
10:09:50 <mauke> agreed, but 'use Sane::Defaults;' or whatever is a relatively small amount of boilerplate
10:10:07 <mauke> (where Sane::Defaults enables strict/warnings/whatever you like to include)
10:10:28 <mauke> heh. export PERL5OPT='-Mstrict -Mwarnings'
10:12:06 <mauke> heh, I just used loeb in a semi-real program
10:14:11 <mauke> main = interact $ (++ "\n") . concatMap show . take 3 . sortBy (flip compare) . loeb . map (score . line2nums) . lines
10:15:02 <gwern> 'That's a bit of an understatement. Basically all Squeak and VisualWorks images have been running since some time in the late '70s. They've been migrated from 16- to 32- to 64-bits and across chip architectures, but it's the same image. Other dialects were bootstrapped more recently, and some of them have retained the ability to create an image from scratch.' o.0
10:15:44 <duckinator> gwern: saywhatnow
10:36:54 <taotree> Is there an up to date gtk2hs tutorials?
10:37:38 <duckinator> taotree: if you find one, can you link me to it? i was looking for one the other day to no avail :(
10:38:41 <dankna> hmmm
10:38:54 <taotree> trying to do mouse handling and just isn't working for me. The thorough tutorial out there uses the old deprecated api, so... trying to use the new one
10:41:05 <dankna> I see http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/GHC-IO-Buffer.html
10:41:05 * roconnor realizes what he has been calling idomatic transformations are probably the same things as monoidal natural transformations.
10:41:24 <dankna> this looks like it's intended to be the new basis for ByteStrings, replacing ForeignPtr
10:41:43 <dankna> and it has the rather nice http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/GHC-IO-Encoding.html to go with it
10:44:03 <saml> is haskell the beset functional programming?
10:45:36 <sipa> that's like asking a politician who you should vote for
10:46:02 <lispy1> ?faq is Haskell the best programming language?
10:46:03 <lambdabot> The answer is: Yes! Haskell can do that.
10:46:53 <lemon> anyone using haskell on windows ?
10:47:06 <Kaide> lemon: I do from time to time
10:47:20 <lemon> did you tried Yi on Windows ?
10:47:25 <Kaidelong> no I have not
10:47:30 <Kaidelong> I would not recommend it
10:47:35 <lemon> why ?
10:47:39 <Adamant> ?faq will Haskell cure Frank Zappa of his need to put things up his nose?
10:47:40 <lambdabot> The answer is: Yes! Haskell can do that.
10:48:05 <Kaidelong> lemon: I could not even get it to build on windows when I tried
10:48:17 <lemon> I built it
10:48:21 <lemon> but have an error
10:48:24 <Kaidelong> lemon: I just use Notepad++ on windows, which is SciTE
10:48:47 <lemon> # yi.exe --frontend=pango
10:48:48 <lemon>  yi.exe: Panic: frontend not found
10:49:06 <lemon> it was built with cabal install yi -f -pango
10:49:15 <Kaidelong> try running it in the command line?
10:49:19 <Kaidelong> instead of with GTK
10:49:56 <Kaidelong> leksah actually deploys pretty easily on windows
10:49:58 <lemon> only Pango supported on Windows as I see
10:50:07 <Kaidelong> (but debugging was broken last I tried)
10:50:19 <Kaidelong> ah I take it Yi must use ncurses
10:50:24 <Kaidelong> for the command line
10:57:31 * hackagebot clash 0.1.2.3 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.2.3 (ChristiaanBaaij)
10:58:13 <Adamant> oh that's metal
11:01:20 <tg_> now that's a good quip
11:05:03 <Adamant> I was referring more to the level of intensity and the VHDL getting translated into real-world configs, but a The Clash joke works too
11:07:00 <roconnor> FreeTheorems++
11:17:54 * byorgey is having fun with the Logic monad
11:18:07 <edwardk> logically
11:20:24 * fryguybob wonders if IO is the Illogical monad...
11:21:48 <Jafet> A good spacesuit transcends reason
11:22:52 <kmc> if i'm defining a data type in a library
11:23:08 <kmc> is it considered polite to define instances for all the easy / standard / derivable classes
11:23:18 <kmc> or are there good reasons not to do this
11:23:18 <Veinor> i would assume so.
11:23:27 <gronliz> why can't we have unique types in haskell so we can allow for destructive updates without the crazy ST monad stuff
11:23:39 <gronliz> http://en.wikipedia.org/wiki/Uniqueness_type
11:23:46 <kmc> gronliz, what do you dislike about the "crazy ST monad stuff"?
11:24:12 <gronliz> too much mumbo jumbo going on
11:24:13 <kmc> gronliz, to me, uniqueness types seem like a special-case type system hack, while the ST monad is a nice application of some much more general type system features
11:24:20 * roconnor wishes free theorems would give free monoidal natural transformation theorems.
11:24:24 <byorgey> kmc: yes, otherwise others will end up making orphan instances.
11:24:37 <kmc> like, i can't think of any *particular* reason someone would need Read or Data for my type, but what the hell
11:24:50 <gronliz> kmc: more like a guarantee of a simple thing
11:25:24 <tg__> Adamant: ah. I read the joke as VHDL translation to hardware
11:25:25 <gronliz> kmc: that this thing will not be reference by anything other than this function
11:25:31 <gwern> > 16^2
11:25:32 <lambdabot>   256
11:26:08 <kmc> anyway the answer to "why can't we have it" is "you haven't submitted patches to GHC yet"
11:26:24 <kmc> unless you mean getting it in the standard
11:26:27 <kmc> which will be a very hard sell
11:26:32 <gronliz> why?
11:26:40 <gronliz> it should be in the standard
11:26:40 <kmc> because there are already ways of solving this problem
11:26:45 <Jafet> Because Haskell is already successful
11:26:45 <kmc> based on much more general type system features
11:27:08 <gronliz> including uniqueness types would not make it less general
11:27:16 <kmc> and because the standard is generally very conservative
11:27:21 <gronliz> you could still use ST
11:27:27 <gronliz> but I wouldn't of course
11:27:53 <Jafet> The type system features seem orthogonal to me. ST is just a way to do stateful computations directly, and its safety happens to be enforced by higher-rank typing
11:28:15 <edwardk> gronitz: uniqueness types come with a whole host of other issues, most notably they interfere with inference of advanced typing features, and they make closure capture a hell of a lot more difficult
11:28:52 <gronliz> really? What do they interfere with?
11:28:54 <tg__> @tell dankna I finished reading the GA papers I had on my docket. I got caught up in doing some QM-related toying with GA semantics. Will read your notes tonight.
11:28:54 <lambdabot> Consider it noted.
11:29:02 <edwardk> jafet: type system features are rarely orthogonal concerns. each extension needs to be considered within the context of each other extension.
11:29:57 <gronliz> I wonder why uniqueness types are considered a hack
11:30:12 <edwardk> lambda lifting in the presence of uniqueness types is tricky for instance
11:30:30 <edwardk> they aren't a hack, they are useful, but they aren't free.
11:30:45 <Jafet> As in, I suppose you could write ST using uniqueness typing
11:31:15 <Jafet> So the typing discipline is somewhat tangential to what ST does
11:31:16 <edwardk> jafet: sure, but you can also get there with a rank 2 type, which has fewer strange interactions
11:31:29 <Jafet> So I don't see so much the point of this discussion
11:32:34 <kmc> yeah, if GHC supported UT as a primitive, it would be useful in the implementation of IO and ST
11:33:27 <edwardk> the issue then is that you need to deal with some fairly arbitrarily complex constraint handling rules for inference of uniqueness annotations, and a notation foe encoding lubs and glbs, of uniqueness constraints, etc.
11:33:34 <edwardk> er for
11:34:01 <kmc> wonder if that's harder than understanding the ST "mumbo jumbo" gronliz ;)
11:34:38 <edwardk> i _like_ uniqueness types, and other substructural type systems, i just find them to be a bear to work with.
11:35:06 <gronliz> maybe I do not see the issues well enough
11:35:37 <gronliz> I certainly am not qualified to submit a patch for them in GHC
11:35:43 <kmc> gronliz, can you make your objection to ST more specific?
11:36:47 <edwardk> the nice thing about the ST hack is there is nothing ST-specific about it. I use the same hack in my automatic differentiation library to provide similar safety guarantees, there i _could_ plumb a uniqueness type through but that would induce a great deal more serialization than i want.
11:37:21 <edwardk> uniqueness types can't solve _all_ of the issues you can solve with rank n types
11:37:30 <edwardk> and vice versa
11:37:41 <gronliz> Don't like types of rank 2
11:37:45 <kmc> yeah, rank N types are also useful for things totally unrelated to substructural logic
11:37:48 <kmc> why not gronliz?
11:38:07 <Jafet> (Hm, where's gronliz coming from, that has uniqueness types?)
11:38:20 <c_wraith> Clean's the only thing I know of with uniqueness types
11:38:27 <kmc> to me unrestricted polymorphism a la System F seems simpler and more consistent
11:38:34 <gronliz> I just don't like the needless complexity
11:38:55 <kmc> gronliz, you didn't explain why it's needless
11:38:59 <c_wraith> I find Rank-2 types indispensible...  How else do you express that the function being passed in to your function needs to be polymorphic?
11:39:11 <edwardk> c_wraith: i implemented a language with a suite of substructural types a few years back, that is where my general dislike of the complexities they introduce ot the compiler comes from. by comparison supporting rank 2 types was trivial.
11:40:02 <c_wraith> They might possibly have a cleaner syntax than what GHC provides, but the feature is *really* good.
11:40:08 <edwardk> uniqueness typing and laziness have some interesting interactions
11:40:39 <edwardk> just because i have the only reference to something doesn't mean i _should_ mutate it in place, because i still may not need that answer. a uniqueness relevant or uniqueness strict type is more interesting to me
11:40:48 <kmc> this seems like a classic case of "the feature we don't have must be better, because we don't know the pitfalls yet"
11:41:00 <edwardk> that is the property you get out of linearity, but the issue is confused because people mix up uniqueness and linearity
11:41:25 <gronliz> edwardk: I disagree, when there is no harm in mutation it should be done
11:41:32 <kmc> hehe
11:41:37 <edwardk> gronliz: even if that introduces non-termination?
11:42:39 <edwardk> gronliz: if you add the full gamut of substructural types, you can say rather than your uniqueness but possibly irrelevant type should accumulate a chain of affine mutations that when it is forced will be evaluated. on the other hand a uniqueness relevant/strict type can be mutated directly 
11:43:42 <edwardk> this leads to a full model of substructural type annotations, in which somewhat amusingly linearity and uniqueness are both included, but at opposite ends of the lattice.
11:43:47 <gronliz> Uniqueness types are simpler to wrap your head around
11:43:53 <gronliz> thus imho they are better
11:44:09 <edwardk> but they solve a different problem that just happens to overlap for this one case.
11:44:36 <edwardk> you can't write out the yoneda lemma with uniqueness types.
11:44:42 <c_wraith> gronliz: you seem to be ignoring the more general use of rank-2 types:  specifying that an argument to a function must be polymorphic
11:44:52 <gronliz> true, but I fail to see the real value in rank 2 types whereas I see the value in uniqueness types
11:44:56 <kmc> gronliz, what makes you think Haskell is designed to be simple to wrap your head around?
11:45:10 <c_wraith> gronliz: then you haven't written many interesting higher-order functions yet. :)
11:45:22 <jix> gronliz: I don't think uniqueness types are simpler to understand/use
11:45:27 <kmc> gronliz, argument by lack of imagination?
11:45:28 <gronliz> kmc: Well it should be, or are we making C++ 2.0
11:45:43 <kmc> gronliz, the elegant language design is not always the beginner-friendly one
11:45:45 <edwardk> gronliz: newtype Mu f = Mu (forall a. (f a -> a) -> a)
11:46:00 <edwardk> newtype Yoneda f a = Yoneda (forall b. (a -> b) -> f b)
11:46:46 <edwardk> rank 2 types don't infect the rest of the language the way uniqueness types do. you introduce them to the language and you're stuck talking about them even when they are irreelvant
11:46:55 <gronliz> kmc: I have heard the same from Bjarne Stroustrup, look what he made... C++ is to C what a woman who has been through bukkake is to a nice, tidy and clean woman.
11:46:56 <kmc> gronliz, unrestricted side effects and strict evaluation would also be "easier to wrap your head around" than laziness and first-class IO
11:47:08 <Jafet> edwardk: pardon, what does "relevance" mean here?
11:47:10 <gronliz> don't want that with Haskell
11:47:11 <kmc> hehehehe
11:48:11 <gronliz> Besides I hear dons hates rank 2 types
11:48:12 <edwardk> jafet; a relevance says that given 'x' you must use it, so you can call 'f x x' with it, using it potentially more than once, but you can't ignore it.
11:48:15 <kmc> gronliz, i predict you will not last long here
11:48:26 <edwardk> jaft: affinity is the flip side, you can ignore it, but if you use it you use it at most once.
11:48:48 <edwardk> jafet: linearity is the combination of affinity and relevance. you must use the variable _exactly_ once.
11:49:19 <gronliz> is there a difference between linear types and uniqueness types
11:49:24 <edwardk> jafet: using more than once is contraction, forgetting is 'weakening'. linearity is a contract to neither contract nor weaken a variable again.
11:49:32 <gronliz> kmc: that comparison is very spot on
11:49:36 <Jafet> Ok, I recognize these from substructural logic
11:49:41 <edwardk> jafet: uniqueness is the property that you haven't contracted or weakened _yet_.
11:49:51 <edwardk> gronliz: yes
11:49:59 <Jafet> Though I never saw uniqueness typing stated in that logic before
11:50:01 <gronliz> edwardk: what is the differnece
11:50:31 <edwardk> gronliz: uniqueness is the backward facing temporal modality that limits access to contraction and weakening, linearity is the forward facing temporal modality limiting access to contraction and weakening
11:50:55 <edwardk> uniqueness says you haven't contracted yet, linearity says you won't contract or weaken again
11:51:33 <edwardk> jafet: its not commonly placed in the same framework. it was work i did back when i was collecting degrees.
11:52:04 <gronliz> kmc: You may think that comparison was funny, but it is probably What Ken would say to Bjarne if he ever asked
11:52:24 <Jafet> Collecting, huh
11:52:39 <edwardk> anyways, rank 2 types are necessary to a good 20% of the libraries i write, so you'll pry them out of my cold dead hands ;)
11:52:59 <edwardk> rank 3 types are even needed in places ;)
11:53:11 <tg__> we'll just cut off 20% (2) of your fingers instead
11:53:12 <bicilotti> http://pastebin.com/qMgvunu4 <-- I am quite puzzled by this example. In line 5 I dont understand how : can work (shouldn't that be ++ ?)
11:53:14 <edwardk> to properly type shift/reset
11:54:01 <kmc> call/cc has a rank-3 type
11:54:12 <edwardk> done right
11:54:17 <gronliz> okay I see linear types would also allow for mutation
11:54:24 <gronliz> I like linear types
11:54:28 <gronliz> we need that
11:54:29 <c_wraith> bicilotti: it works because of the type of the splitLines function, which is conveniently not listed in that example code.
11:54:35 <kmc> ((∀b. a → b) → a) → a
11:54:36 <edwardk> a linear type allows for mutation with a clear conscience.
11:54:49 <c_wraith> bicilotti: splitLines is String -> [String]
11:55:12 <kmc> bicilotti, pre :: String, and splitLines returns [String], no?
11:55:15 <c_wraith> bicilotti: So each element of the result list is a full string, not just a character
11:55:17 <gronliz> Would linear types be possible to incorporate into haskell?
11:55:23 <gronliz> without pain
11:55:25 <bicilotti> ohhhhhhhh
11:55:27 <edwardk> gronliz: no
11:55:28 <bicilotti> I am such a moron
11:55:42 <gronliz> edwardk: and why is that, you seem to know everything
11:55:49 <bicilotti> thanks c_wraith and kmc 
11:55:56 <edwardk> gronliz: whole swathes of compiler optimizations don't play nicely with them
11:56:41 <edwardk> gronliz: haskell makes it much easier to deal with partial function application than clean does. you don't see the problem in clean because you simply can't write the programs where they show up
11:56:56 <edwardk> it is more than a cosmetic change to the language
11:57:07 <gronliz> I do not even use clean, I just like to argue
11:57:19 <edwardk> i gathered there was a trolling element ;)
11:57:35 <gronliz> but I want mutation
11:57:46 <edwardk> but there was enough general interest to give in to the 'someone is wrong on the internets!' impulse.
11:57:51 <edwardk> gronliz: ST
11:57:59 <gronliz> I don't want ST
11:58:20 <kmc> ST is "hard" and "mumbo jumbo"
11:58:25 <kmc> that's what's wrong with it
11:58:29 <kmc> much like monads, am i rite?
11:58:37 <gronliz> monads are nice
11:58:41 <gronliz> I like them
11:58:56 <edwardk> gronliz: then go hack away in some language where folks were willing to — how did you put it — bukkake uniqueness types all over it, like clean or cyclone. ;)
11:59:23 <edwardk> oleg encoded a linear type system in haskell, but its very oleggy
11:59:26 <gronliz> no I think I want linear types instead
11:59:35 <gronliz> I am not sure
11:59:35 <mauke> gronliz: I think I want you to stop talking
11:59:56 <kmc> gronliz, you'd be more effective at trolling if you said those things about monads instead
12:00:01 <kmc> pro tip
12:00:03 <edwardk> =)
12:00:12 <Jafet> Tell him about the classic technique of IO String
12:00:16 <tg__> though don't do it now, we're on to your thing
12:00:21 <kmc> then like 50 people would demolish you, instead of just edwardk
12:01:03 <edwardk> gronliz: more ammunitition against me: 'monads are useless'. 'i don't see the point of applicative as a superclass of monad', 'who needs kan extensions anyways?'
12:01:21 <edwardk> or even 'num is just fine the way it is!' ;)
12:02:28 <Jafet> What's wrong with Num?
12:02:30 <kmc> "let's keep the monomorphism restriction"
12:02:30 <gronliz> No extensions are good. It is not like in C++ where all extensions are rammed into your ass. A lot of c++ nuts say "you don't pay for what you don't use" but that is an evil lie. Turning off exceptions is not in the standard so if you do it you are in the land of undefined behavior.
12:02:40 <edwardk> kmc: i'm okay with that one ;)
12:03:00 <mauke> gronliz: "not use" isn't the same as "turn off"
12:03:12 <gronliz> well you pay for it anyways
12:03:23 <mauke> I don't
12:03:24 <gronliz> in codesize and perfornance
12:03:37 <gronliz> If you use c++ you do
12:04:21 <kmc> another good way to troll #haskell: mention C++
12:04:39 <mauke> doesn't seem very effective
12:04:49 <gronliz> I have a strong hate for C++ for good well argue reasons
12:05:17 <lpsmith> cabal-install just decided to re-compile a package that was *already installed* and had the *same version* and as a result broke a bunch of other packages >:o    
12:08:22 <gronliz> it sucks when things beak, but instead of getting angry try to be happy that you now have something to fix
12:08:55 <gronliz> I want to be a manager and say that
12:09:11 <lpsmith> yes, well,  I don't have time to fix cabal-install right now.
12:11:32 <jiduga> hi guys, I'm looking for a function to check in a ist if there is duplicate elements
12:12:04 <lpsmith> jiduga,  is this list ordered or unordered?
12:12:22 <jiduga> lpsmith: no I just got Eq on my list
12:12:44 <jiduga> the list is small (less than 10 elements) so i don't need an efficient method
12:13:06 <mauke> :t (/=)<*>nub
12:13:07 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:14:24 <lpsmith> :t  \xs -> null [ () | (x:ys) <- tails xs,  y <- ys,  x == y ] 
12:14:25 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:14:33 <lpsmith> (it's a touch faster)
12:15:04 <jiduga> lpsmith: yes it's look what I mean
12:15:20 <jiduga> but is it the same as mauke proposed (I doesn't know <*> operator)
12:15:30 <gronliz> why are iteratees so damn hard to understand
12:15:50 <mauke> gronliz: shush, there's some actual haskell talk going on
12:16:16 <mauke> jiduga: (\x -> x /= nub x)
12:16:59 <jiduga> ha it's nub which is new for me in fact, why this name ?
12:17:33 <mauke> http://www.macmillandictionary.com/dictionary/british/nub
12:17:59 <jiduga> oh ok
12:18:04 <jiduga> thx a lot guys
12:18:09 <shachaf> @all-dicts nub
12:18:13 <lambdabot> *** "Nub" gcide "The Collaborative International Dictionary of English v.0.48"
12:18:17 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
12:18:19 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
12:18:21 <lambdabot>    [1913 Webster]
12:18:23 <lambdabot>  
12:18:25 <lambdabot> Plugin `dict' failed with: thread killed
12:18:40 <lpsmith> uhh,  my function might be the negation of mauke's,  but yes, they should be essentially equivalent
12:18:40 <lpsmith> Mine returns False when there are duplicate's,  Mauke's returns True when there are duplicates
12:19:26 <kmc> ok well hackagebot is dead but if y'all want some patience diff take a look at http://hackage.haskell.org/package/patience
12:19:44 <sm> urk
12:19:51 <mauke> preflex: seen hackagebot
12:19:52 <preflex>  hackagebot was last seen on #haskell 1 hour, 22 minutes and 23 seconds ago, saying: * hackagebot clash 0.1.2.3 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.2.3 (ChristiaanBaaij)
12:20:03 <roconnor> @type \g -> (g <*>) .) .
12:20:05 <lambdabot> parse error on input `)'
12:20:05 <sm> that's supposed to not happen
12:20:09 <roconnor> @type \g -> ((g <*>) .) .
12:20:10 <lambdabot> parse error (possibly incorrect indentation)
12:20:18 <roconnor> @type \g -> (((g <*>) .) .)
12:20:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *). (Applicative f, Functor f1, Functor f2) => f (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
12:20:28 <roconnor> @type \g -> (((g <*>) Prelude..) Prelude..)
12:20:29 <lambdabot> forall (f :: * -> *) a b a1 a2. (Applicative f) => f (a -> b) -> (a2 -> a1 -> f a) -> a2 -> a1 -> f b
12:21:40 <sm> "rss2irc error: run died with: <socket: 3>: hGetLine: resource vanished (Connection reset by peer), exiting".. happens once in a while
12:22:26 <lpsmith> Also, I just wrote a data-structure-agnostic JSON serialization library
12:22:37 <lpsmith> I'd love some feedback,  I hope to put it on hackage soon-ish
12:23:04 <lpsmith> https://github.com/lpsmith/json-builder/blob/master/src/Json.hs
12:25:18 <gronliz> mauke: I will come back when you are happier. I don't like this place when you are so grumpy.
12:26:16 * roconnor wants a normalization algorithm for applicative expressions
12:26:20 <jmcarthur> ...
12:26:36 <Eduard_Munteanu> 9;5~
12:26:43 <Eduard_Munteanu> Sorry.
12:27:02 <jmcarthur> mauke: you're such a grouch. good grief
12:27:44 <mauke> oh noes
12:29:35 <roconnor> ie. does (Battery <$> ((<*>) <$> (fmap (.)) <$> duplicate f <*> duplicate v) = (\g -> (g <*>) .)) <$> duplicate f <*> (Battery <$> duplicate v) ?
12:30:58 <Eduard_Munteanu> That looks like 42 to me :/
12:31:21 <dmwit> oh dear
12:31:42 <Eduard_Munteanu> Yeah, as impenetrable as that.
12:33:44 <dmwit> The second one doesn't even parse, does it?
12:34:30 <Eduard_Munteanu> Why doesn't :k work on values?
12:34:47 <dmwit> Values don't have kinds, they have types.
12:34:56 <dmwit> And all types have kind *, so it would be kind of pointless.
12:35:24 <dmwit> err... all the types that classify values have kind *, I mean.
12:35:51 <Eduard_Munteanu> Yes, I know that, but Philippa hinted to some kind trickery to write predicative types in impredicative systems.
12:36:22 <dmwit> Oh, well, you're definitely off the end of my expertise, then. =P
12:36:23 <Eduard_Munteanu> Specifically that there might be a predicative kind.
12:36:48 <Eduard_Munteanu> So my first attempt was to see if :k shows something different with -XImpredicativeTypes :)
12:37:15 <Eduard_Munteanu> It doesn't for Maybe, or such stuff.
12:38:29 <Philippa> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes suggests there's no predicative kind at present
12:38:48 <Philippa> (in GHC - plenty of PTSes with ** or similar)
12:39:01 <Eduard_Munteanu> Philippa: ah thanks, curiosity satisfied :)
12:39:03 <roconnor> I suppose using the interchange laws and the composition laws it is possible to write every applicative expression in the form f <$> a <*> b <*> ... <*> z
12:51:02 <tibbe> #haskell is much more quite when in the US west coast time zone.
12:52:03 <c_wraith> not if you log in from work :)
13:04:01 <lpsmith> yeah,  I'm not sure what's wrong,  but my cabal-install definitely has a proclivity for recompiling the same version of an installed package and breaking stuff
13:04:27 <lpsmith> and it's version 0.8.2
13:04:52 <lpsmith> and I have been using this executable for months and I've only started having trouble today,  with a couple different packages
13:05:11 <lpsmith> so I don't get it
13:06:31 <aristid> tibbe: it's probably loudest when the "day" overlap between relevant timezones (mostly europe + US) is greatest
13:06:40 <bos> lpsmith: is there a parsec dependency in there somewhere?
13:08:12 <lpsmith> bos:  indirectly.
13:09:21 <lpsmith> but definitely not for another package
13:10:39 <TheKingsRaven> This should be a simple one but I can't figure it out. I have a Monad containing a list. m [a] and a list [a]. How can I combine the two lists (like with ++). The result should be inside a Monad.
13:10:42 <tibbe> aristid: yeah
13:11:29 <tibbe> TheKingsRaven: do xs <- the_m[a]; return (xs ++ the_[a])
13:11:34 <lpsmith> TheKingsRaven,   try do {  x <- getList,   return (x ++ y) }
13:11:39 <aristid> preflex: seen Kaidelong
13:11:40 <preflex>  Kaidelong was last seen on #haskell 2 hours, 21 minutes and 19 seconds ago, saying: for the command line
13:11:55 <tibbe> TheKingsRaven: m [a] is an action that produces a list, <- "executes" it, producing a plain list
13:11:58 <kmc> :t liftM2 (++)
13:11:59 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
13:12:13 <lpsmith> bad kmc ;-)
13:12:37 <kmc> also that's using Caleskell ;P
13:12:37 <TheKingsRaven> Thanks. Trying all that now.
13:12:41 <tibbe> TheKingsRaven: In general (as long as you are a beginner) use the do notation and <- to access thing inside a monad (m <something> or IO <something>)
13:12:52 <kmc> TheKingsRaven, the value itself isn't called "a monad"
13:12:55 <kmc> a monad is a type
13:12:59 <kmc> or more precisely a type constructor
13:13:09 <tibbe> m [a] is a monad m that produces a list [a]
13:13:36 <tibbe> kmc: no one outside Haskell knows what Ia type constructor is a believe :)
13:13:53 <kmc> :/
13:13:58 <lpsmith> well,  tibbe's statment is better phrased as "m [a] is a action inside the monad m that produces a list [a]"
13:14:10 <kmc> they show up in many other languages
13:14:12 <lpsmith> But that usage is commonplace and has been for a long long time
13:14:23 <tibbe> lpsmith: thanks :)
13:14:38 <lpsmith> and probably will persist for some time,  even though we need to phase it out.   I know I'm guilty at times of perpetuating it :)
13:14:40 <tibbe> kmc: sure, as do monads, but people aren't likely to be familiar with the terminilogy
13:15:59 <kmc> the bigger problem is that the word "monad" is unusual and salient and so gets attached to too many things
13:16:26 <lpsmith> kmc, absolutely true :)
13:16:37 <kmc> and so it's used to mean things like "the way Haskell does IO", even though the monad-ness of IO is entirely secondary
13:17:31 <lpsmith> well, it reminds me a little bit of the language commonly used in algebra;   they tend to refer to a set as a "group" whereas a group is really a set with an appropriate binary operator.
13:18:06 <lpsmith> or a set *and* a binary operator, rather.
13:19:06 <TheKingsRaven> That seems to have worked. Thanks :)
13:19:07 <lpsmith> kmc,  don't you mean the IO is secondary to monads?
13:22:44 <kmc> lpsmith, both
13:23:20 <lpsmith> I guess I don't see it in the other direction then.
13:23:48 <kmc> well if i gave you functions return :: a → IO a, and (>>=) :: IO a → (a → IO b) → IO b
13:23:51 <kmc> you could do IO just fine
13:23:59 <kmc> and never notice or care that this structure generalizes
13:24:07 <kmc> you could call this "continuation-based IO" or simply "first-class IO"
13:24:23 <mauke> well, you should also give him putChar and getChar
13:24:25 <lpsmith> ok,  but IO is still a monad then,  although not a "Monad"
13:24:29 <kmc> what's unusual about IO in Haskell is that IO actions are inert first-class values
13:24:40 <kmc> not that IO actions are composable through a generic monad API
13:25:01 <kmc> lpsmith, yes, much as lists are still a monoid
13:25:27 <kmc> but rarely do beginners come to #haskell and say "i want to append two lists, but i don't understand all this Monoid business, i hear they're like taco salad"
13:25:44 <lpsmith> hahaha
13:25:57 <lpsmith> @remember kmc but rarely do beginners come to #haskell and say "i want to append two lists, but i don't understand all this Monoid business, i hear they're like taco salad"
13:25:58 <lambdabot> It is forever etched in my memory.
13:26:03 <lpsmith> I hope I did that right
13:26:17 <kulakowski> @quote taco salad
13:26:18 <lambdabot> No quotes for this person. stty: unknown mode: doofus
13:26:22 <kulakowski> derp
13:26:27 <kulakowski> @quote kmc taco
13:26:28 <lambdabot> kmc says: but rarely do beginners come to #haskell and say "i want to append two lists, but i don't understand all this Monoid business, i hear they're like taco salad"
13:26:38 <lpsmith> yay!
13:27:09 <lpsmith> Ok,  I think I understand where you are coming from,  kmc
13:27:41 <kmc> i'm not sure this observation really leads to any revelation about language design
13:27:45 <kmc> or about pedagogy
13:28:01 <lpsmith> If IO was a "separate" monad,  beginners probably wouldn't fret over "understanding monads" and instead focus on learning how to do IO
13:28:22 <smoge> is there a haskell mode for Emacs??
13:28:27 <lpsmith> yes
13:28:44 <lpsmith> smoge, called exactly that.  Google it  :)
13:29:01 <smoge> is it good?
13:29:05 <byorgey> ttp://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
13:29:06 <lpsmith> it's ok
13:29:14 <byorgey> um, but with an h
13:29:15 <smoge> I'm new to haskell, not sure what editor to use
13:29:48 <byorgey> smoge: if you're already comfortable with emacs, I definitely recommend using the emacs haskell mode
13:29:49 <kmc> smoge, use any editor you're comfortable with
13:29:59 <byorgey> but it's probably not worth learning emacs just to use it
13:30:12 <byorgey> unless you also independently want to learn to use emacs.
13:30:42 <byorgey> otherwise you could try leksah
13:31:34 <hpc> i could never get leksah working
13:31:59 <lpsmith> I use emacs.  I'm not particularly fond of emacs.
13:32:13 <lowasser> I use Kate, no complaints
13:32:28 <lowasser> it's an excellent general-purpose editor for programmers
13:32:50 <lowasser> 'cause when it comes down to it, all I really want is a good text editor with a built-in console
13:33:02 <lpsmith> I'm not sure I'd like Kate either.   I'm kind of a text-editor refugee
13:33:19 <lowasser> heh okay
13:33:38 <lowasser> I will claim that Kate is better than any other basic GUI text editor than I've used
13:33:38 <kulakowski> lpsmith: a refugee from where?
13:33:48 <lowasser> but then, I'm the type to use nano when I'm in a console = P
13:34:14 <revenantphx> I just use textmate >_>
13:34:18 <lpsmith> kulakowski, Turbo Pascal :)
13:34:22 <revenantphx> I'm not cool enough to use emacs (lol)
13:34:31 <revenantphx> I don't really care for it tbh.
13:34:47 <lpsmith> Emacs keybindings drive me nuts
13:34:48 <revenantphx> I use vim on occasion to do basic editing (like config files), but that's about it.
13:34:59 <revenantphx> nano if I'm drunk/lazy.
13:35:02 <lpsmith> way too modal
13:35:37 <kulakowski> lpsmith: I like the abstract idea of emacs, but the implementation leaves much to be desired.
13:36:00 <lpsmith> kulakowski, exactly
13:36:36 <smoge> Well, you can make your own emacs key bindings
13:36:38 <smoge> :-)
13:36:53 <icarus> can someone explain what the type ((->)t) means?  I've been trying to figure it out but ghci doesn't help at all
13:36:57 <lpsmith> smoge, the problem is more fundamental than that
13:37:13 <smoge> I like Kate too
13:37:20 <smoge> is there a plugin for Kate?
13:37:25 <lpsmith> I use cua-mode for sanity's sake,  but every now and then I have to turn it off to access infrequently-used keys
13:37:32 <Eduard_Munteanu> icarus: hint, (->) is the infix form of '->'
13:37:33 <ben> icarus: (->) a b means a -> b. (->) t is a type constructor that needs another type to be a function type.
13:37:44 <meiersi> dcoutts: Hi Duncan
13:37:52 <ben> Eduard_Munteanu: Surely -> is the infix form of (->)
13:38:04 <icarus> haha
13:38:11 <Eduard_Munteanu> Erm yeah.
13:38:22 <Eduard_Munteanu> Wait no.
13:38:36 <icarus> I thought it looked like the infix form but what does it mean?  is it any function on one argument?
13:38:59 <kulakowski> lpsmith: I have cua mode on and all the cua keys off, just for the rectangle mode
13:39:01 <Eduard_Munteanu> Anyway, ((->) t) behaves like t -> ...
13:39:15 <ion> The expression a + b can be written as (+) a b. The type a → b can be written as (→) a b.
13:39:25 * Eduard_Munteanu is tired.
13:39:38 <icarus> yeah, but (+) a == (+a)
13:39:39 <Eduard_Munteanu> It's just like partial application at value-level
13:39:57 <icarus> so this is partial application at type level?
13:40:11 <mauke> (+) a == (a+), actually
13:40:12 <ion> icarus: No, (+) a == (a +)
13:40:15 <mauke> icarus: yes
13:41:58 <icarus> so ((->)t) is a function on type t?
13:42:12 <revenantphx> :t (->)
13:42:13 <lambdabot> parse error on input `->'
13:42:15 <revenantphx> aw.
13:42:18 <icarus> lol yeah
13:42:26 <icarus> that's where I got stuck :p
13:42:27 <Eduard_Munteanu> icarus: not really
13:42:55 <mauke> icarus: (->) t isn't a complete type yet
13:42:56 <monochrom> ":t" takes a value argument (such as function, number)
13:43:00 <Philonous> icarus: ((->) t) is a type constructor that takes a type r and returns the type of functions from t to r
13:43:02 <icarus> oh, t is a type variable
13:43:04 <Eduard_Munteanu> Think of 'type FuncInt a = Int -> a'
13:43:04 <icarus> ?
13:43:25 <icarus> oh
13:43:39 <Eduard_Munteanu> FuncInt <something> is the type of functions that take an Int and return <something>
13:43:51 <Eduard_Munteanu> That's actually the same thing as (->) Int
13:43:53 <icarus> I was confused, when I saw (->) I was thinking lambda forms, but that doesn't make sense becaue -> in a type means something else
13:44:20 <monochrom> right, don't confuse the value level with the type level
13:44:25 <Eduard_Munteanu> Yes and there's yet another meaning at kind level
13:44:28 <icarus> ((->t)t) Int is a function on t -> Int?
13:44:28 <fryguybob> @kind (->)
13:44:30 <lambdabot> ?? -> ? -> *
13:44:37 <Philonous> icarus: Less formally it's "functions starting from t", but you have to tell where they go before you can use it as a type.
13:44:59 <hpc> the ?? and ? are GHC nincompoopery which you can safely ignore
13:45:07 <icarus> haha
13:45:10 <icarus> okay
13:45:10 <mauke> icarus: that's a syntax error
13:45:11 <hpc> (for learning, at least)
13:45:32 <icarus> mauke: which is a syntax error?
13:45:37 <mauke> icarus: (->) t Int is ((->) t) Int is t -> Int
13:45:45 <mauke> icarus: (->t) is a syntax error
13:45:53 <Philonous> " ((->) t ) Int " is functions from t to Int
13:46:04 <icarus> oops, I missed parens
13:46:06 <gwern> > (1254 - 27) * (1+(7/110))
13:46:08 <lambdabot>   1305.0818181818183
13:46:31 <icarus> (->) t Int
13:47:13 <icarus> so is there any way to play with that in ghci?  I think that would be helpful
13:47:23 <icarus> I think I have the idea now though
13:47:34 <Eduard_Munteanu> > let foo = id :: (->) Int Int in foo 3
13:47:35 <lambdabot>   3
13:49:13 <icarus> interesting
13:49:35 <icarus> so that takes a polymorphic function and creates one that will only work on Ints?
13:49:50 <icarus> sort of
13:49:59 <icarus> nevermind
13:49:59 <mauke> > (id :: Int -> Int) 3
13:50:01 <lambdabot>   3
13:50:03 <revenantphx> I think of it more as,
13:50:17 <revenantphx> it creates an equivalent function that is constrained to only Ints.
13:50:24 <revenantphx> that is, "foo" is undefined for non-integer values.
13:51:14 <icarus> okay
13:51:31 <revenantphx> actually I'd just be wrong :\
13:51:33 <Eduard_Munteanu> I think the proper name is specialization, isn't it?
13:51:38 <revenantphx> it's not "undefined", it just doesn't *work*.
13:51:44 <Eduard_Munteanu> (although not from a compiler standpoint)
13:51:45 <revenantphx> It'd be breaking the rules of a typed system XD.
13:51:48 <icarus> yeah, it would be a type error
13:52:07 <Eduard_Munteanu> (as in not the same thing as specialization pragmas)
13:52:15 <icarus> Eduard: the compiler wouldn't catch foo applie dot a string?
13:52:46 <Eduard_Munteanu> Applied to a string? Yes it would catch that.
13:52:52 <fryguybob> > let foo = id :: (->) Int Int in foo "blah"
13:52:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:52:54 <lambdabot>         against inferred type ...
13:53:06 <icarus> What did you mean "not from a compiler standpoint"?
13:53:41 <Eduard_Munteanu> We've also got specialization pragmas that generate a specialized (faster) version of a polymorphic function.
13:55:24 <icarus> okay, I thought you were refering to the comment that it wouldn't work because of types
13:57:01 <cyphunk> pad = 1 `shiftL` 1 -- results in error: Possible cause: the monomorphism restriction applied .... im sure im missing a basic concept. can someone point me to the right keyword to rtfm?
13:57:16 <hpc> :t 1 `shiftL` 1
13:57:17 <lambdabot> forall t. (Bits t) => t
13:57:24 <hpc> cyphunk: give it a type signature
13:57:34 <hpc> pad :: Bits t => t
13:58:20 <hpc> (generally, you want to put a type on everything that isn't constant strings, for documentation)
13:59:02 <ezyang> Hoopl question: What is the difference between debugFwdJoins and debugFwdTransfer? 
13:59:27 <icarus> thanks for the help everyone, I understand the exercise now
13:59:33 <cyphunk> hpc: thanks. is there some doc/keyword discussing this general rule?
14:00:06 <hpc> cyphunk: dunno where it is, but it is the monomorphism restriction
14:00:27 <cyphunk> hpc: thanks
14:02:11 <roconnor> can I just say that (f <$> (a <$> b <*> c)) = (\x y -> f (a x y)) <$> b <*> c) directly?
14:03:14 <mauke> why two args?
14:03:19 <roconnor> @type \f a b c -> f <$> (a <$> b <*> c)
14:03:20 <lambdabot> forall a b a1 a2 (f :: * -> *). (Applicative f) => (a -> b) -> (a1 -> a2 -> a) -> f a1 -> f a2 -> f b
14:03:44 <roconnor> @type \f a b c -> (\x y -> f (a x y)) <$> b <*> c
14:03:46 <lambdabot> forall a a1 t b (f :: * -> *). (Applicative f) => (t -> b) -> (a -> a1 -> t) -> f a -> f a1 -> f b
14:03:58 <dolio> That looks like it'd be provable from various applicative functor laws.
14:04:04 <mauke> oh
14:04:25 <roconnor> dolio: I'm wondering if I can in general copy the applicative pattern and lift it all directly out to the front in one step
14:04:41 <monochrom> w00t, haskell weekly news!
14:06:41 <dolio> roconnor: I imagine so.
14:06:54 <roconnor> okay
14:07:03 <roconnor> the reviewers won't even read my proof anyways, so who cares, right?
14:07:10 <dolio> Heh.
14:07:54 <monochrom> When I review papers, I scrutinize the proofs.
14:08:27 <roconnor> monochrom: want to review my paper?
14:08:34 <roconnor> :)
14:08:40 <monochrom> but perhaps I'm in the minority. I heard that most reviewers procratinate much more that I do.
14:09:00 <monochrom> not until an editor asks me to do it annoymously
14:09:19 <roconnor> fair
14:09:49 <roconnor> I think this proof would be more clear with some nicer notation
14:10:18 <roconnor> I need some sort of lambda like notation for applicative
14:11:21 <rly> monochrom: you can always claim that you do that, but since you are anonymous it would never be possible to find out that you didn't. 
14:11:53 <monochrom> the editors know
14:12:04 <rly> But they are supposed to keep that a secret, right?
14:12:15 <rly> Has it ever been disclosed?
14:12:27 <roconnor> (.) <$> x <*> y would be better written as x ^.^ y or some other generic way of lifting infix operators
14:12:38 <kmc> ^_____^
14:12:42 <monochrom> an editor can also say, without revealing secrets, "whenever monochrom reviews a paper for me, he scrutinizes the proofs, his report points out problems in the proofs"
14:12:50 <rly> I think students can better review than researchers, myself. 
14:13:00 <rly> Researchers do not have the time to do proper review.
14:13:42 <monochrom> methinks not so much time as attitude
14:13:48 <dolio> roconnor: http://hpaste.org/44281/applicitative
14:13:57 <rly> monochrom: what do you mean? 
14:14:22 <rly> monochrom: do you mean that the researchers lost interest in their own subject?
14:15:01 <roconnor> dolio: good, but it'd be nice to have a meta-theorem that works for all applicative expressions
14:15:05 <monochrom> what does attitude mean? it means "I care" or "I don't care".
14:15:16 <dolio> roconnor: Yeah, i'm not sure how to provide you with that.
14:15:30 <roconnor> I don't even know how to state my meta theorem.
14:15:44 <monochrom> many profs don't teach acceptably. it is also not so much time as attitude.
14:16:09 <dolio> Other than it seems like you could probably prove enough individual transformations to lift any expression you want.
14:16:23 <edwardk> roconnor: the (.) <$> x <*> y is what i use to state the static arrow associativity condition i place on Apply
14:16:50 <rly> monochrom: do you teach? 
14:16:53 <dolio> Reassociate right, use functor's composition munging, reassociate back. Etc.
14:16:59 <monochrom> I sometimes teach.
14:18:24 <roconnor> edwardk: oh yes, it is an imporant function, but it is hard to read
14:18:41 <roconnor> edwardk: (<*>) <$> x <*> y is even more confusing.
14:18:49 <edwardk> roconnor: yeah =)
14:19:04 <edwardk> i abuse that one a lot in the comonad-transformers package
14:19:16 <roconnor> Though if I was more confortable with combinator calculus it might not be so bad.
14:19:55 <edwardk> your f <$> (g <$> x) — can just be seen as fmap fusion
14:20:07 <dolio> roconnor: I suppose the question is, can you write any nested expression (\x y z ... -> f x (g y (h z ...))) as a composition pipeline like 'uncurry f . uncurry g . uncurry h . ...'?
14:20:18 <dolio> Plus a curry at the end.
14:20:27 <dolio> Enough curries, that is.
14:20:54 <dolio> If so, then you should be able to make use of an 'associative' property for applicatives.
14:22:42 <monochrom> reviewing a conference paper takes one afternoon. the deadline is usually 1-2 weeks. reviewing a journal paper takes 2 working days if you sample the proofs and just scrutinize the chosen samples (I don't mind people doing this), and the deadline is usually 1-2 months. there does not exist "not enough time" in practice. you have to really not care to feel "not enough time".
14:23:23 <fryguybob> f <$> x <*> y is (| f x y |) with She right?
14:23:36 <monochrom> bear also in mind that if you miss the deadline by 5 days, the editors are still happy.
14:23:50 <edwardk> monochrom: definitely right on both counts.
14:25:00 <monochrom> if you are on a committee of a conference and therefore have to go through 20% of all submissions, that's another story, I admit. but I'm talking about, say, a committee member for ICFP 2011 asking you to do just one paper to help him/her out.
14:25:04 <edwardk> It doesn't take very long to do a good thorough review unless you procrastinate to the point where you begrudge giving it _any_ time.
14:25:28 <roconnor> it takes me hours to do a good review
14:25:47 <roconnor> maybe a full day
14:26:05 <edwardk> Sure, but I can typically do that in two sittings, and in the process come back with a list of a dozen things the authors should probably fix up for publication.
14:26:22 <dolio> fryguybob: Yes.
14:27:18 <edwardk> For me, it is still a novel enough activity that I enjoy doing it. If you were only on the committee for the name recognition and it wasn't something you enjoyed doing, or you had to review things that you weren't familiar with because the scope of the committee was too broad, I could see how it would become a burden.
14:28:12 <Heffalump> I always agonise over whether my review is actually sensible. But having been on a few PCs now where I could read the other reviews, I'm less worried about that.
14:28:22 <edwardk> =)
14:29:08 <edwardk> In my case I usually just get asked to review stuff in my specialty area by folks on said committees, so its stuff I'd be reading for fun anyways.
14:29:13 <monochrom> I much sympathize with committee members, yes.
14:30:31 <roconnor> dolio: okay, now prove (.) <$> ((<*>) <$> a <*> (f <$> b)) = (\x y -> (.) ((<*>) a (f b))) <*> a <*> b
14:30:54 <roconnor> er
14:30:57 <roconnor> dolio: okay, now prove (.) <$> ((<*>) <$> a <*> (f <$> b)) = (\x y -> (.) ((<*>) a (f b))) <$> a <*> b
14:31:11 <roconnor> er
14:31:15 <roconnor> dolio: okay, now prove (.) <$> ((<*>) <$> a <*> (f <$> b)) = (\x y -> (.) ((<*>) x (f y))) <$> a <*> b
14:31:18 <roconnor> there
14:31:19 <roconnor> :)
14:31:41 <edwardk> roconnor: seems more tedious than difficult
14:32:01 <roconnor> edwardk: that's why I'd like a meta theorem that says I can always do this transformation
14:32:41 <edwardk> its obvious. you're the computer, not prove it ;)
14:32:45 <edwardk> er now prove it ;)
14:33:19 <roconnor> edwardk: where I copy the shape of the applicative term, removing all the <$> and <*> and lambda abstract over those terms that are preceeded by <*> and then follow that by <$> a <*> b ... for all the terms a b that were preceeded by <*>
14:33:48 <edwardk> *nods*
14:36:19 <edwardk> you can either whip out your coq or you can drop {- trivial -} comments between each use of these rewrites in your proof and shame the reviewers into accepting it.
14:36:47 <rly> Interesting choice of words ;)
14:37:49 <hpc> haha edwardk
14:38:29 <edwardk> i have a scheme syntax-rule macro for doing that rewrite lying around somewhere, you could probably adapt it to an inductive proof.
14:39:20 <edwardk> i wrote it in response to a comment by philippa about applicative do sugar
14:40:36 <hpc> applicative do being the |f x y| brackets?
14:40:58 <edwardk> do x <- foo; y <- bar; z <- baz a b c; return (quux x y z)  ~ quux <$> foo <*> bar <*> baz a b c — works as long as the terms other than the return don't reference the variables being bound.
14:41:15 <edwardk> hpc: nah, a slightly different 'do' where the variables being bound by <- only come into scope in the last line
14:41:23 <deech> Hi all, I'm having a brain fart. I want apply an 'f' to an 'a' 'x' times and return the result. The closest I can find on Hoogle is fix :: (a -> a) -> a when what I want is (a -> a) -> a -> Int -> a. What function is this?
14:41:36 <Heffalump> @type iterate
14:41:37 <lambdabot> forall a. (a -> a) -> a -> [a]
14:41:39 <edwardk> that scoping restriction is sufficient to give you a lack of context sensitivity, and limit you to what you can do in an applicative.
14:41:58 <edwardk> deech take the nth item out of the list returned from iterate.
14:42:27 <edwardk> > head $ drop 10 $ iterate (+1) 0
14:42:28 <lambdabot>   10
14:42:49 <deech> edwardk: Is that going to be inefficient for large 'x's? Aren't we generating storing all the values upto x?
14:42:50 <edwardk> > iterate (+1) 0 ! 10
14:42:50 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
14:42:51 <lambdabot>         against inferred t...
14:42:59 <edwardk> > iterate (+1) 0 !! 10
14:42:59 <lambdabot>   10
14:43:12 <edwardk> deech: not unless you look at them.
14:43:25 <Heffalump> you have to generate them anyway
14:43:36 <Heffalump> since applying f to a x times means first applying it x-1 times
14:43:50 <edwardk> the list itself doesn't necessarily get materialized as a data structure
14:43:58 <deech> s/generating storing/storing/
14:44:20 <edwardk> by the time ghc gets done with that it likely turns into what you'd write if you wrote it out by hand
14:44:25 <deech> edwardk : I didn't know that. 
14:44:28 <Heffalump> at worst they'll be GCed at the same rate they are produced (with more lumpiness)
14:44:53 <Heffalump> if deforestation kicks in then as edwardk says they won't even be produced (though I doubt that !! is a good consumer, so I suspect it won't)
14:45:17 <Heffalump> actually, it should be a good consumer
14:45:19 <edwardk> yeah the drop version is more likely to optimize
14:45:27 <edwardk> hrmm, checking
14:45:33 <hpc> @src (!!)
14:45:33 <lambdabot> xs     !! n | n < 0 = undefined
14:45:33 <lambdabot> []     !! _         = undefined
14:45:33 <lambdabot> (x:_)  !! 0         = x
14:45:33 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:45:45 <edwardk> hpc: @src just makes stuff up
14:46:07 <deech> Heffalump, edwardk : Dunno if this comes up often, but maybe it should be standard. 
14:46:08 <hpc> humbug
14:46:34 <edwardk> deech: its one of those things you can trivially implement by putting together a couple of more useful primitives
14:48:43 <edwardk> you can also build it by using the monoidal exponentiation in my monoids package: something like appEndo (Data.Monoid.Combinators.replicate (Endo f) n) z
14:48:53 <edwardk> but thats kinda silly
14:49:15 <dolio> roconnor: http://hpaste.org/paste/44281/applicitative_annotation#p44282
14:50:02 <deech> edwardk : Agreed. In fact I did implement it myself in a less elegant fashion than yours. But there are plenty of one-liners that have made it into the Prelude.
14:50:34 <edwardk> i think the real problem is there isn't a good name to use for it, iterate, repeat, cycle, replicate, etc. are all taken
14:50:55 <deech> apply or applyN
14:51:14 <edwardk> both are common names for others to use in their code
14:51:21 <edwardk> and for very different things
14:51:22 <deech> how about fixN?
14:51:31 <edwardk> but its not a fixed point
14:51:33 <rly> Which function?
14:51:44 <pedro3005> (== []) is O(1), right?
14:51:54 <edwardk> pedro3005: yes
14:52:15 <deech> rly : A function that takes applies a function to a given 'a' 'x' times.
14:52:16 <edwardk> fly: iterate f z !! n
14:52:20 <edwardk> er rly
14:58:53 <edwardk> hrmm, looks like neither drop nor (!!) act as good consumers
14:59:34 <smoge> Hi
14:59:45 <smoge> I'm looking for multimedia examples in haskell
14:59:49 <edwardk> going to go test now =)
14:59:52 <smoge> audio mostly
15:00:00 <smoge> is there a place for that?
15:00:07 <smoge> code examples
15:00:09 <deech> edwardk: Thanks for checking on that. I'll stick with what I have then.
15:00:14 <smoge> applications etc
15:00:23 <edwardk> prolly safer
15:00:24 <deech> smoge : Haskore, Euterpea
15:00:32 <smoge> thanks
15:00:47 <smoge> they are modules, right?
15:01:00 <smoge> I'd like to see some examples
15:01:06 <roconnor> dolio: I hope you are my referee
15:01:10 <smoge> like reding and writing audio files
15:01:18 <smoge> audio synths etc
15:01:31 <Bapuche> How do you traverse an n-ary tree like data Tree a = Empty | Leaf a | Node a [Tree a]?
15:01:50 <dolio> roconnor: Yeah. It'd be much easier if you could state your theorems and have the reviewer prove them. :)
15:01:58 <deech> smoge: The last I looked haskore-supercollider (http://hackage.haskell.org/package/haskore-supercollider) had examples.
15:02:00 <smoge> a jack client example... etc
15:02:09 <smoge> thanks
15:02:14 <smoge> ill check it out
15:02:42 <deech> smoge : It's difficult to get it running on Linux. 
15:02:58 <smoge> what? haskore???
15:03:09 <smoge> or sc3?
15:03:31 <smoge> deech: do you mean a jack client in haskell?
15:04:55 <deech> smoge  : Haskore's fine. It's the IO stuff that's a bear to install. I don't know about Jack client, but the implementation of the supercollider network protocol didn't install easily on windows as of Nov, 2009.
15:05:22 <smoge> I'm on linux (arch)
15:05:33 <deech> smoge : You're golden/
15:05:35 <smoge> and I'm a heavy sc3 user
15:05:48 <smoge> I will try this package, looks good
15:06:16 <Saizan> deech: so you meant "it's difficult to get it running on windows"?
15:06:43 <smoge> and I can't find examples....
15:06:44 <deech> Saizan: I didn't successfully do it because I gave up.
15:07:03 <smoge> I would like some code to get it started
15:07:18 <deech> smoge : I see Haskore.Interface.SuperCollider.Example
15:08:19 <deech> Saizan : I see where I miswrote. Ugh. Sorry.
15:19:16 <bl4sph3my_> test 
15:19:17 <HugoDaniel> i can't get tired of reading monad tutorials
15:19:25 <bl4sph3my_> ?
15:19:40 <bl4sph3my_> is it really that silent here ?
15:20:00 <HugoDaniel> there are so many of them! so many interesting approaches to the same warm fluffy thing 
15:22:11 <hpc> HugoDaniel: be careful
15:22:18 <hpc> it could be a kitty, or a grisly bear
15:22:55 <HugoDaniel> :D
15:23:14 <HugoDaniel> i really dont understand why are there so many benchmarks to haskell web servers now
15:23:35 <HugoDaniel> could someone plz create some bindings to nginx and kill it ?
15:23:44 <Pseudonym> Each one optimises for a different benchmark, so all of them are the best.
15:24:04 <HugoDaniel> Pseudonym, yeah, they all seem awfully biased
15:24:12 <HugoDaniel> but its a nice thing to see that kind of competition 
15:24:19 * Pseudonym is making that up, BTW.
15:24:22 <Pseudonym> No idea if it's true.
15:24:41 <HugoDaniel> well, they usually run the same benchmark
15:24:50 <c_wraith> actually, Snap and Yesod pretty much have agreed upon a set of benchmarks
15:24:56 <HugoDaniel> but they also carefully omit some other parts of it, dont know if its on purpose 
15:25:25 <Pseudonym> It is generally true that some web servers optimise for some things and not others.
15:25:34 <Pseudonym> Apache, for example, optimises for stability.
15:25:49 <HugoDaniel> now this is quite the feat: http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
15:25:54 <Pseudonym> It a) correctly implements all of HTTP, and b) has no known security holes in the core.
15:26:17 <hpc> apache is also kinda fat
15:26:19 <HugoDaniel> Pseudonym, where i work i find that nginx is more stable than apache :/
15:28:47 <hpc> HugoDaniel: it's missing the lyah page
15:29:23 <HugoDaniel> hpc its at the bottom
15:29:31 <haskellnoob> why are monoids so difficult
15:29:45 <haskellnoob> i need to understand monoids to write haskell but i dont get it
15:29:50 <HugoDaniel> hpc, its the 2nd tut from the end
15:30:05 <HugoDaniel> haskellnoob, dont use them
15:30:16 <haskellnoob> too much math to write even basic haskell
15:30:21 <HugoDaniel> haskellnoob, just wrap your type in a list, and there you go
15:30:23 <haskellnoob> if i want to add 2 numbers, i need to use monoid
15:30:23 <Bynbo7> HugoDaniel: why do you need to understand monoids?
15:30:25 <monochrom> /mode #haskell +q haskellnoob!*@unaffiliated/pumpkingod
15:30:40 <copumpkin> :(
15:30:41 <Bynbo7> bah
15:30:44 <monochrom> hehe
15:31:07 <hpc> lol
15:31:24 <kmc> tee hee
15:31:42 <c_wraith> also, no one complains about not understanding monoids. :P
15:31:47 <blackdog> copumpkin: mean, man. Bynbo7 was all geared up to fight the good fight :)
15:31:56 <copumpkin> I can fight some more if you want
15:31:58 <Bynbo7> yeah :L(
15:32:00 <Bynbo7> :(*
15:32:15 * Bynbo7 goes off and sulks while buying a new macbook pro
15:32:41 <blackdog> Bynbo7: i'd be sulking too. no SSD boot drive?
15:32:45 <monochrom> why is haskell still buggy on mac  <duck>
15:33:06 <Bynbo7> monochrom: that's is a legitimate question :(
15:33:07 <monochrom> oh, wait, no SSD boot drive, despite rumours?
15:33:15 <Bynbo7> nope
15:33:44 <Bynbo7> you can buy an SSD, but i won't be. when it getys old and slow, I'll replace the optical drive with a nice fast SSD
15:34:45 <thoughtpolice> monochrom: good question. i'm still trying to figure out an obscure ghci/dyld linker bug so plugins for ghc can work on mac. :(
15:35:00 <thoughtpolice> OS X seems to have lots of 'gotchas' like that
15:35:10 <monochrom> eww
15:36:10 <maurer_> monochrom: Mach-O is weird :/
15:36:24 <thoughtpolice> furthermore I still need a windows machine to test the plugins patches out on
15:36:33 <thoughtpolice> building GHC on windows seems like a fairly involved process though :(
15:43:00 <copumpkin> what's the site with all those formal proofs in the special language?
15:43:15 <monochrom> what special language?
15:44:37 <copumpkin> http://us.metamath.org/mpegif/mmset.html
15:44:40 <copumpkin> that's the one I was thinking of
15:45:53 <monochrom> gives bad name to formal proofs imo
15:46:06 <copumpkin> yeah, I'm not a fan of it, but there's a of stuff on it
15:46:37 <copumpkin> monochrom: what do you use?
15:47:04 <monochrom> main problem is deliberately choosing a "minimal" therefore unergonomic suite of rules to work with, everything is chore.
15:47:58 <monochrom> I use calculational proofs for myself, HOL or PVS when I doubt myself.
15:49:33 <monochrom> Dijkstra and others have shown how formal proofs can be easy to come up with, short, highlights the key, all at the same time. The trick is make it look like algebra, not natural deduction.
15:50:06 <monochrom> and certainly not Hilbert's original axioms
15:50:21 <dolio> Definitely not those.
16:03:49 <jeffz_> lyah offline?
16:05:37 <ddarius> monochrom: You don't like programming in combinatory logic?
16:12:09 * ddarius likes ergonomic axioms like ∀x.x.
16:12:21 <monochrom> I don't know. I don't think I'll like it.
16:12:23 <dolio> Yes, so much easier.
16:13:15 <hpc> ddarius: that looks a lot like the smbc symbol for "kick in the ass"
16:13:21 <polypus`> i have a basic hlist question: https://gist.github.com/843208
16:13:32 <hpc> http://www.smbc-comics.com/index.php?db=comics&id=2135
16:13:41 <dolio> There are no basic hlist questions! Zing!
16:13:49 <polypus`> there are for me :)
16:14:19 <sipa> he probably means ((basic hlist) questions), which are by definition not basic questions at all!
16:14:42 <djahandarie> lol @ that error
16:15:15 <roconnor> programming has turned into algebra
16:17:41 <roconnor> duplicate (f<*>(Battery v b)) = duplicate (Battery ((.)<$>f<*>v) b) = Battery (extend Battery ((.)<$>f<*>v)) b = Battery (Battery<$>(duplicate((.)<$>f<*>v))) b = ...
16:29:49 <edwardk> roconnor: it has always been algebra ;)
16:35:56 <roconnor> free theorems are nice
16:36:04 <roconnor> we should use more polymorphic functions.
16:36:48 * hackagebot pdfinfo 0.1.2 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-0.1.2 (ChrisDone)
16:37:03 <dobblego> @hoogle fromMaybeM
16:37:04 <lambdabot> No results found
16:37:07 <dobblego> boo
16:37:17 * roconnor proved that the horiziontal composition of two idomatic transformations is again an idomatic transformation.
16:45:20 <metrix> I would like to use haskell to parse a programming language, but I only need certain sections parsed.. is there a way to "partially parse" a language?
16:45:42 <blackdog> metrix: isn't that just fully parsing a part of a language?
16:45:47 <Pseudonym> It depends on the language.
16:46:32 <metrix> I doubt it's anything you have heard of.. I want to parse Genero.
16:46:35 <Pseudonym> And sometimes, regular expressions are enough.  Most syntax highlighting systems do that.
16:47:45 <metrix> what I want to extract functions, input variables and output variables. the problem is that it's not always on one line.
16:48:12 <Draconx> Pseudonym, I'd wager that most do not.  Consider a highlighter for haskell comments, which are not regular.
16:48:22 <Pseudonym> OK, regexes.
16:48:32 <Pseudonym> Which isn't the same thing.
16:48:43 <Pseudonym> The point is, most syntax highlighters only do a shallow parse, not a deep one.
16:49:01 <Pseudonym> Parsing Haskell requires, for example, analysing the operator declarations.
16:53:10 <metrix> I see..
16:54:13 <metrix> Thank you for the help!
17:20:43 <copumpkin> roconnor: horizontal composition of idiomatic transformations? is that like natural transformations??
17:20:59 <dolio> Monoidal natural transformations, I think.
17:21:26 <dolio> Which preserve the structure of monoidal functors between monoidal categories.
17:22:49 <ddarius> Monoidal monoids which monoidally monoidify the monoidaly categories.
17:23:12 <dolio> Exactly.
17:23:26 <ddarius> Hmm.  How did that 'y' get in there?
17:29:47 <Kaidelong> You got too carried away with the alliteration obviously
17:31:01 <monochrom> the y there is the y combinator
17:31:21 <Eduard_Munteanu> This looks interesting... http://www.j-paine.org/cgi-bin/webcats/webcats.php
17:33:58 <Pseudonym> I thought it was going to be pictures of cats with captions.
17:34:40 <Eduard_Munteanu> Heh, no, not lolcats, kittygory theory :)
17:35:03 <copumpkin> I see
17:35:10 <copumpkin> I need them in my library
17:35:17 <copumpkin> idiomatic transformations!
17:37:10 <Eduard_Munteanu> can haz idiomatic tranzformationz?
17:37:54 <Pseudonym> i made u a caturgory, but i transformd it
17:38:21 <copumpkin> oh god
17:38:26 <Eduard_Munteanu> oh noez!
17:38:30 <copumpkin> @quote lolcategories
17:38:31 <lambdabot> No quotes match. That's something I cannot allow to happen.
17:38:38 <copumpkin> @moarphisms
17:38:39 <lambdabot> Unknown command, try @list
17:38:40 <copumpkin> @quote moarphisms
17:38:40 <lambdabot> tensorpudding says: lolcategory demands moarphisms
17:38:58 <Eduard_Munteanu> :), knew that
17:39:09 <monochrom> hahaha
17:39:49 <Pseudonym> http://spl.smugmug.com/Humor/Lambdacats/eugenio/965006909_4eHkJ-S.jpg
17:40:20 <Eduard_Munteanu> Heh :))
17:40:53 <Pseudonym> The original lambdacats collector rejected that one on the grounds that it was too obscure.
17:41:19 <Eduard_Munteanu> Lambdacats? *needs to look that up*
17:41:29 <Pseudonym> And this one on the grounds that it was too much of an in-joke: http://spl.smugmug.com/Humor/Lambdacats/phillip/965006928_cXDUV-M.jpg
17:41:59 <dolio> Really?
17:42:02 <Pseudonym> Yeah.
17:42:09 <Pseudonym> Too many ones about people we knew.
17:42:10 <dolio> The rest weren't obscure in-jokes?
17:49:00 <shlevy> Howdy
17:49:29 <shlevy> Has anyone had any luck writing an Android app in Haskell, either through the NDK or tools like LambdaVM?
17:52:18 <shlevy> Related question: What kinds of C compilers will the C output of GHC compile on?
17:53:00 <b6> sorry, this is random. i converted some lat/lon pairs to lambert conformal conic easting/northings. i want to plot them in an image, but i don't know how to relate easting/northing meters to pixels.
17:53:53 <dmwit> shlevy: I believe there's some interest, though I don't know if there's been anything released for doing that.
17:53:56 <monochrom> gcc works for ghc-generated c code. this has been in use for years.
17:54:37 <roconnor> copumpkin: I call a natural transformation that preserves pure and <*> an idiomatic transformation
17:54:44 <shlevy> monochrom: I figured that. I was wondering how hard it would be to modify the code enough to compile using the Android NDK compilers
17:54:55 <roconnor> copumpkin: though I think it is actually the same as a monoidal natural transformation.
17:54:58 <monochrom> ah. I don't know.
17:55:07 <roconnor> copumpkin: given that applicative functors are really lax monoidal functors
17:55:11 <copumpkin> yeah
17:55:15 <djahandarie> shlevy, hard, I think.
17:55:18 <djahandarie> kmc might know something more
17:56:00 <monochrom> my recollection of the last time I looked at ghc-generated c code is that it uses pretty standard c even though very low-level
17:56:09 <shlevy> kmc: djahandarie says you might have some input on running Haskell apps on Android through the NDK. Thoughts?
17:56:40 <shlevy> Anyone have any general experience with lambdavm?
17:57:25 <ne> is there a summary of various haskell operators somewhere, with a description of what each operator does?  the concrete problem i have is that it's difficult to read haskell code when i don't know what various non-alphanumeric symbols mean.
17:57:49 <monochrom> @hoogle (<*>)
17:57:49 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:57:51 <shlevy> ne: Have you tried Hoogle? You can search for the operators
17:58:01 <djahandarie> ne, you can search them in hayoo. http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:58:12 <djahandarie> hoogle tends to have bad coverage of these sorts of things
17:58:18 <djahandarie> (i.e., not all of hackage)
17:58:24 <monochrom> and then look for Control.Applicative docs, for example enter it in the search box of hackage
17:58:52 <ne> shlevy: hoogle seems to be exactly what i was looking for.  thanks!
17:59:21 <ne> djahandarie: thanks as well, though it looks like hayoo couldn't tell me about the operator i was most recently puzzled by, @
17:59:51 <djahandarie> Ah, that isn't a function
17:59:51 <Eduard_Munteanu> ne: like f xss@(x:xs) = ... ?
18:00:15 <djahandarie> It's an as-pattern
18:00:21 <djahandarie> (Like what Eduard_Munteanu just did)
18:00:22 <monochrom> although, understand that the project of "one table of all haskell operators" is as doomed as "one table of all math operators"
18:00:30 <ne> E_M: yes; hoogle had a good pointer to a summary of what it means
18:00:43 <djahandarie> It's nice that hoogle does stuff like that
18:00:48 <djahandarie> I really wish it would just cover all of hackage.
18:00:50 <Eduard_Munteanu> It does?
18:00:56 <Eduard_Munteanu> Nice.
18:01:29 <ne> perhaps i mis-spoke by calling it an operator or function; in any case, hoogle seems to be the answer for now.
18:01:50 <dmwit> Wow, I didn't know hoogle did that.
18:01:51 <dmwit> hoogle++
18:01:55 <Eduard_Munteanu> Yeah, it's syntax, it's not defined by any library.
18:02:09 * hackagebot intel-aes 0.1.2.3 - Hardware accelerated AES encryption and RNG.  http://hackage.haskell.org/package/intel-aes-0.1.2.3 (RyanNewton)
18:02:10 <Eduard_Munteanu> @karma hoogle
18:02:11 <lambdabot> hoogle has a karma of 3
18:02:26 <dmwit> ?karma lambdabot
18:02:26 <lambdabot> lambdabot has a karma of 3
18:02:32 <dmwit> Wow, they're undervalued.
18:02:50 <djahandarie> ne, the Haskell Report is pretty extensive (full coverage :P) in terms of Haskell's actual syntax. There aren't *that* many weird symbols I don't think.
18:02:54 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17 defines @
18:03:07 <djahandarie> ne, but the Report is kind of dense of course.
18:03:24 <kmc> heh
18:03:26 <monochrom> "dense" complies with "summary" :)
18:03:35 <kmc> GHC does define some weird extension syntax though
18:03:42 <djahandarie> Well
18:03:44 <kmc> i never figured out the "arrow brackets" stuff or whatever
18:03:49 <djahandarie> GHC can go jump out a window
18:04:05 <kmc> if Haskell 98 was good enough for Jesus then it's good enough for us
18:04:13 <monochrom> GHC has already jumped out a window and flied and left you behind
18:04:26 * shlevy ducks from the flamewar
18:04:35 <Bynbo7> my girlfriend's grandmother has a similar saying "if the king james bible was good enough for Jesus, it's good enough for me!"
18:04:44 <djahandarie> shlevy, flamewar? We're throwing flowers at each other :P
18:04:58 * roconnor makes a new Haskell report that is nowhere dense
18:05:02 <monochrom> we are throwing each other out of windows
18:05:19 <djahandarie> Yes, straight into linux.
18:07:02 * copumpkin wonders idly if dozenth is a valid fraction
18:07:13 <Eduard_Munteanu> Yes, GHC even implements optimizations such as defenestration.
18:07:30 <djahandarie> Hahaha
18:07:49 <Philippa> copumpkin: if so, then is a baker'sdozenth 1/11?
18:08:47 <Bynbo7> not 1/13th?
18:08:57 <dmwit> Nope, gotta overcount. =)
18:08:59 <djahandarie> @remember Eduard_Munteanu [In response to "GHC can go jump out a window" and "GHC has already jumped out a window and flied and left you behind"] Yes, GHC even implements optimizations such as defenestration.
18:09:00 <lambdabot> I will remember.
18:09:00 <shlevy> Philippa: Or 13/144th
18:12:27 <Eduard_Munteanu> Hah, got quoted.
18:12:39 <gronliz> I have a quote for you
18:13:09 <gronliz> C++ is to C what a woman who has been through a bukkake is to a woman who has been through a shower
18:13:47 <gronliz> take that to the lol bank
18:13:48 <b6> i think you got it backwards. but i'm not sure and don't want to draw a diagram. :(
18:14:07 <djahandarie> cojoke
18:14:20 <Philippa> gronliz: the feminist lol bank reckons it's worth negative money, unfortunately
18:14:36 <gronliz> Philippa: you a woman?
18:14:41 <c_wraith> gronliz: there are women on the internet.
18:14:44 <copumpkin> even the non-feminist version doesn't find it particularly funny
18:14:45 <dmwit> Yeah, not even a feminist and I still find it somewhat off-color.
18:14:48 <copumpkin> gronliz: why is that relevant?
18:15:08 <Bynbo7> i think it's much funnier if it's a man
18:15:22 <gronliz> Okay I have a propostion
18:15:30 <djahandarie> Only in retrospect.
18:15:37 <Bynbo7> aye
18:15:37 <jmcarthur> o_O
18:15:50 * Pseudonym has never been propositioned on #haskell before
18:16:07 <djahandarie> gronliz, and I have a proof!
18:16:09 <djahandarie> Do I win?
18:16:09 <gronliz> Actually I am a woman
18:16:30 <Philippa> *shrug* so what?
18:16:32 <ddarius> Pseudonym: I'm sure your wife appreciates that.
18:17:02 <copumpkin> Pseudonym: hey babe, PM plz now
18:17:04 <gronliz> Oh and I have a proposition. The man in here who is able to make a useful Haskell program will get to ravish me. LOL, I feel pretty safe.
18:17:15 --- mode: ChanServ set +o copumpkin
18:17:31 <gronliz> that one always gets the nerds ragin
18:17:40 <copumpkin> nah, I don't particularly care
18:17:47 <copumpkin> but you're not contributing anything useful
18:17:51 <copumpkin> regardless of your gender
18:18:01 <Pseudonym> I know I can make useful Haskell programs. It's not tied to any part of my sexual identity.
18:18:08 <gronliz> uhm, you need to take care of the women copumpkin 
18:18:18 <gronliz> since I am one you must keep me here
18:18:24 --- mode: copumpkin set +b *!5859c5b3@gateway/web/freenode/ip.88.89.197.179
18:18:24 --- kick: gronliz was kicked by copumpkin (I disagree)
18:18:32 <roconnor> copumpkin: thanks
18:18:36 <Philippa> aw, I was going to go for it
18:18:48 <Philippa> I mean, I've got room for extra snark and all
18:18:52 <copumpkin> aw
18:19:09 <copumpkin> I'll unban her if you want the pleasure
18:19:29 <roconnor> it would be better to take it away from #haskell
18:19:47 --- mode: copumpkin set -o copumpkin
18:19:54 <Pseudonym> Actually, I'm kinda with roconnor on this one.  Might have been better to redirect to -blah.
18:19:55 <Philippa> it would, yeah. So no unban on those grounds, there's such a thing as taking a joke too far
18:20:07 <Eduard_Munteanu> That was quick, though.
18:20:12 <Philippa> nah, -blah doesn't need that class of crap either
18:20:22 <Pseudonym> We have far classier crap, true.
18:20:31 <copumpkin> -blah also has a less-than-ideal moderation situation
18:20:41 <dmwit> Personally, I'm glad that people are protecting the tone of #haskell in this way.
18:21:02 <ddarius> At any rate, I'm pretty sure I've heard exactly that same sentence before, so I don't think any people were harmed.
18:21:06 <Pseudonym> Maybe we should make a fake -blah which we redirect people to, where everyone is ignored.
18:21:30 <Pseudonym> That'd be funny, actually.
18:21:39 <dolio> I've heard it at least twice here.
18:21:43 <copumpkin> really?
18:21:47 <dolio> Yes.
18:21:48 <copumpkin> is it just a recurring troll?
18:22:17 <copumpkin> I guess so
18:23:27 <dolio> I don't really believe it's a "she" either.
18:24:06 <dolio> But maybe that's just me.
18:25:12 <Philippa> dolio: funny you should mention that
18:25:36 <Philippa> (there's a reason I didn't reply to "you a woman?")
18:25:56 <Pseudonym> Actually, there's more than one reason.
18:26:03 <Pseudonym> But you only need one.
18:27:25 <jmcarthur> heh
18:27:52 <gwern> @quote
18:27:53 <lambdabot> boegel says: * boegel goes to inflate Itkovian's balls
18:28:10 <monochrom> eww
18:46:44 <napping> Is there any way to make a type [exists t . (C t) -> A] ?
18:47:15 <copumpkin> if you wrap it
18:47:16 <copumpkin> sure
18:47:28 <napping> or swapped around
18:47:30 <copumpkin> data Wrapped = forall t. Wrapped (C t -> A)
18:47:49 <ddarius> copumpkin has strong beliefs about safe typed programming.
18:48:00 <napping> I'd like to avoid a separate wrapper around each elemnt
18:48:19 <copumpkin> napping: represent your list as a rank-2 fold? :P
18:48:20 <napping> peraphs a dual form?
18:48:54 <napping> [forall r. (forall t . ((C t) -> A) -> r) -> r]
18:48:58 <copumpkin> ddarius: my school taught me right
18:49:04 <monochrom> @quote monochrom you.only
18:49:04 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
18:49:04 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
18:49:10 <napping> then it's just ($ thing)
18:49:18 <djahandarie> My school hasn't taught me anything.
18:50:22 <ddarius> djahandarie: Don't say I didn't warn you.
18:52:07 <adnap> ha ha
18:52:08 <Eduard_Munteanu> napping: maybe that works with impredicative types.
18:52:35 <monochrom> I regretted "unsafePerformIO Is Not Enough" in retrospect. "RealWorld# Is Not Enough" is even better.
18:53:13 <copumpkin> napping: yeah, you'd need impredicative types for that. That's why I suggested the fold
18:53:27 <napping> No impredicative types?
18:53:33 <napping> what kind of programming language is this?
18:53:36 <ddarius> monochrom: Solution: Do no retrograde speculation.
18:53:57 <Eduard_Munteanu> napping: we do have them, see ImpredicativeTypes
18:54:00 <copumpkin> napping: granted, I think they're coming back soon
18:54:05 <copumpkin> they had a temporary laps
18:54:06 <copumpkin> e
18:54:08 <Eduard_Munteanu> (the extension)
18:54:22 <Eduard_Munteanu> They're here in 6.12 :/
18:54:35 <copumpkin> pretty sure they're gone in 7.0.1
18:54:38 <copumpkin> and will be back after that
18:54:57 <Eduard_Munteanu> Not everybody uses 7.x though.
18:55:26 <dolio> No, they were never actually gone.
18:55:35 <dolio> They were deprecated in 6.12 or so.
18:55:44 <copumpkin> ah, fair enough
18:55:56 <dolio> But the rewritten checker still has the option.
18:56:26 <copumpkin> SPJ changed his mind about killing them, right?
18:56:34 <dolio> They may have just wanted the option to get rid of them.
18:56:45 <dolio> At least temporarily.
18:57:18 <napping> hmm, Data.
18:57:29 <napping> Data.Binary has a silly instance for Float, doesn't it?
18:57:34 <copumpkin> yeah
18:58:59 <napping> is that in any way preferrable to not having an instance?
18:59:32 <copumpkin> if people want quick and dumb serialization, I guess it's fine
19:00:17 <napping> I suppose I should finish my MLF implementation before complaining too loudly about bad impredicative type support
19:02:41 <ddarius> Is () an incorrect implementation of Float?
19:04:25 <napping> Is there any reason to write (fromIntegral . toInteger)?
19:04:33 <ddarius> No.
19:05:10 <dolio> That is (fromInteger . toInteger . toInteger)
19:05:45 <monochrom> some reason to write (fromInteger . toInteger) but that's fromIntegral. fromIntegral enjoys some GHC optimization, you should prefer it.
19:06:47 <napping> well, this: https://github.com/acfoltzer/HaskellNBT/blob/master/NBT.hs uses *fromIntegral* . toInteger
19:08:22 <copumpkin> then it's silly
19:08:35 <napping> ok, that's what I thought
19:09:54 <napping> fore!
19:11:03 <ddarius> You shouldn't believe anything on the Internet, and instead you should put your trust into IRC which stands for Infallible Relay Chat.
19:31:24 <djahandarie> Infinitely relayed crap.
19:38:52 <roconnor> International reply coupon
19:42:56 <Philippa> Infinite Reconnection Confirmations?
19:43:17 <dsturnbull> good one
19:43:49 <lispy> Philippa: I think that was one of the names they considered for facebook
19:47:03 <adnap> do the same concurrency problems exist in haskell as in imperative languages?
19:47:22 <napping> they are highly attenuated
19:47:24 <adnap> does haskell offer interesting solutions to problems that aren't possible in other languages?
19:47:59 <ion> Laziness, anyone?
19:48:01 <adnap> just wondering.  i'm starting to learn to program with pthreads, but i've never spent any time learning concurrency in haskell.
19:48:20 <ion> Everything’s *possible* in any Turing-complete language, of course.
19:48:25 <conal> adnap: haskell allows for clear expressions of solutions that are obscured by conventional languages.
19:48:30 <napping> many things are more convenient than pthreads
19:48:41 <adnap> yeah, i know.  but it's for school.
19:48:57 <napping> One big thing is the mutable variables are fairly rare
19:49:17 <conal> adnap: are you asking about imperative or denotative/functional haskell? big difference.
19:49:35 <adnap> actually, we may be using something on top of pthreads.  i haven't had to write a program yet.  we're studying monitors and condition variables.
19:49:50 <napping> so it's much less likely to accidentally share state between thread - and races are bad news
19:50:22 <napping> conal: I believe "concurrent" implies imperative
19:50:55 <conal> napping: not to me. see, eg, FRP which is more concurrent than imperative models while fully denotative.
19:50:55 <adnap> conal: functional.  i know you can basically write programs analogous to their imperative counterparts in haskell, just like any other io code
19:51:02 <conal> adnap: imperative haskell is imperative programming but on steroids, since actions are first-class.
19:51:19 <conal> adnap: glad to hear.
19:51:36 <napping> does FRP actually have a nice denotational semantics?
19:51:39 <adnap> that kind of programming is super boring, so i avoid it if possible
19:52:04 <conal> napping: always has, since its inception in early 1995.
19:52:07 <napping> nicer than powerdomains?
19:52:17 <conal> napping: of course.
19:52:45 <adnap> i wrote some code code dealing with files using system.directory recently, and while it was much better than in other languages, it was still not a very fun experience
19:53:48 <napping> On the more imperative side, one nice thing is types ensuring that STM variables and only STM variables are used in transactions
19:53:52 <conal> napping: check out the literature. start with http://conal.net/papers/icfp97 and http://conal.net/papers/push-pull-frp
19:54:17 <adnap> so, there are still the usual pitfals associated with concurrent programming in haskell?  like deadlocks and race conditions?
19:54:30 <kmc_> adnap, STM largely replaces those with other pitfalls
19:54:44 <adnap> i just wasn't sure if haskell had some alternative solutions that made these easier to avoid
19:54:54 <adnap> okay
19:55:00 <kmc_> STM is basically invulnerable to deadlock but can livelock under heavy contention
19:55:10 <kmc_> it's a nicer more composable way to program, but not bulletproof
19:55:18 <roconnor> STM can more or less deadlock
19:55:19 <adnap> i definitely want to give the haskell stuff a try once i get some free time
19:55:21 <kmc_> adnap, maybe you want parallel processing instead of concurrent semantics?
19:55:23 <adnap> what about starvation?
19:55:24 <conal> adnap: those issues arise in *imperative haskell* (IO & STM), which don't have denotations, afaik.
19:55:26 <kmc_> there's a whole other set of stuff for that
19:56:05 <conal> adnap: IO by design and STM because of its connection with IO
19:56:09 <kmc_> you can write ordinary pure functional programs and then say "by the way, do this 'map' in parallel over 8 cores"
19:56:23 <kmc_> it's not foolproof either but it is nice because you basically can't change the semantics of your program by adding these annotations
19:56:30 <kmc_> and you don't have to dick around with threads or locks or chans
19:56:35 <adnap> conal: what's the alternative?  i've seen some of the stuff on your blog like `par`.  is this the sort of denotational parallelism you're referring to?
19:56:39 <roconnor> atomically retry -- this deadlocks
19:57:02 <adnap> kmc_: that's cool
19:57:23 <adnap> kmc_: is that separate from IO and STM?
19:57:28 <kmc_> adnap, yes
19:57:28 <adnap> kmc_: how does it work?
19:57:30 <conal> adnap: there are probably *a lot* of alternatives. frp is one neighborhood. see the refs i just gave to napping.
19:57:35 <adnap> kmc_: some sort of markup?
19:57:43 <kmc_> http://hackage.haskell.org/package/parallel
19:57:52 <adnap> conal: oh, thanks.  i missed that.
19:58:03 <kmc_> adnap, not quite, par is ostensibly a normal function
19:58:06 <adnap> grrr
19:58:09 <conal> adnap: dinner time for me. catch me online another time if you'd like more pointers about *denotative* thinking.
19:58:14 <kmc_> and its denotation is quite simple, «par _ x = x»
19:58:31 <adnap> ever since i install the firefox 4 beta, i can't open links via irc.  not sure what got screwed up.
19:58:39 <kmc_> but it has the operational "side effect" that «par y x = x» will speculatively force y to evaluate in the background, if there are idle resources
19:58:50 <monochrom> haskell concurrent program incorrectness is possible but less likely because you use much fewer shared variables. even eyeballing becomes feasible.
19:59:02 <conal> in contrast to par, concurrency is what makes the imperative programming model intractable to precise & simple reasoning.
19:59:09 <kmc_> adnap, dons gave a talk "multicore programming in haskell now" which is quite good
19:59:15 <kmc_> a lot of its "coming soon" predictions are now here
19:59:16 <conal> later, all.
19:59:25 <adnap> okay, cool
19:59:25 <kmc_> like a better IO manager in GHC
19:59:30 <adnap> i'll review all this later
19:59:46 <adnap> i just wanted to sort of see what was out there
20:00:00 <kmc_> concurrent IO is great; you basically write blocking IO using many threads, and GHC's runtime system converts it to all that kqueue()/epoll() event-based async IO that the node.js hipsters are going on about
20:00:06 <kmc_> but without you having to explicitly turn your program inside out
20:00:20 <adnap> also, i need to think up something fun to do that is inherently concurrent
20:00:25 <ne> shared state is, i think, more precisely what makes writing concurrent programs hard.  there's many ways to minimize the amount of thinking you have to do about shared state; functional programming is one but not the only way.  a well-known alternative would be mapreduce, which works perfectly well with imperative code.
20:00:26 <roconnor> BTW, "atomicModifyIORef" can get you a long way to useful concurrency
20:00:34 <shachaf> kmc_: You can do that in C too, of course.
20:00:41 <adnap> maybe i can go back and try to speed up some of my old haskell projects
20:01:56 <kmc_> shachaf, probably.  what approach would you use?
20:02:16 <kmc_> ne, mapreduce isn't really an alternative to functional programming
20:02:33 <ne> i never said it was; i said it's a way to minimize the amount of thinking you have to do about shared state.
20:02:48 <kmc_> "functional programming is one but not the only way.  a well-known alternative would be mapreduce"
20:02:51 <kmc_> anyway yes
20:02:54 <shachaf> kmc_: Coroutines that get switched to by a scheduler when the IO call is completed.
20:03:08 <kmc_> mapreduce works with imperative programs that don't talk outside their little shard
20:03:14 <kmc_> which is much like using par with runST
20:03:23 <kmc_> which is a not-crazy tactic
20:04:00 <shachaf> kmc_: As in http://www.rethinkdb.com/blog/2010/12/improving-a-large-c-project-with-coroutines/
20:04:10 <napping> Even if you did need to turn your program inside-out, you could just work in a continuation moand, and still not have to write it in an inside-out order
20:04:34 <kmc_> napping, but you have to be careful not to make ordinary blocking calls
20:04:46 <napping> there is that, I guess
20:04:48 <kmc_> in the same way that the concurrent Haskell programmer has to be careful not to make "foreign import unsafe" calls
20:05:07 <shachaf> kmc_: I also happen to beusing. I converted one explicit event-driven FSM to coroutines and it ended up less than half the size and much clearer.)
20:05:15 <napping> but you could make your monad not visibly MonadIO
20:05:19 <kmc_> nice
20:05:28 <kmc_> yeah napping
20:05:43 <kmc_> you could make a nice continuation-passing async-IO monad
20:05:52 <ne> most user-space threads implementations work in that way (e.g. old freebsd threads worked by having the user-space thread scheduler catch all blocking system calls)
20:05:53 <napping> Li and Zdancewic had a very nice thread library thing along those lines
20:06:09 <kmc_> i've heard this idea before and i think it's a good one :)
20:06:10 <kmc_> would like to see someone do it
20:06:11 <shachaf> Hmm, that last line got rather messed up.
20:06:13 <kmc_> ne, interesting, how do they catch syscalls?
20:06:18 <ne> compiler help
20:06:20 <kmc_> something like linux's ptrace?
20:06:22 <kmc_> oh
20:06:23 <shachaf> kmc_: Well, coroutines are just a special case of continuations, of course.
20:06:39 <kmc_> shachaf, what isn't ;)
20:06:40 <monochrom> what is a coroutine, without reading a lot of c++ code? does it mean just writing a callback and giving it to the system?
20:07:00 <ne> there's more portable versions that use ptrace but it's easy to juice out a little bit more performance by having your compiler / libc help you by intercepting read(), write(), etc
20:07:01 <napping> I think libcoroutine does some stack-switching
20:07:23 <shachaf> monochrom: In this case it's just a separate stack that you can switch awy from and back to.
20:08:15 <shachaf> This can be used with event-based callbacks, of course.
20:09:08 * shachaf doesn't understand why the node.js people are so pleased with the fact that they write all their code in explicit continuation-passing style.
20:09:43 <napping> as the Twisted people before them
20:10:30 <shachaf> At least those languages have closures, though...
20:10:30 <jmcarthur> "mapreduce works with imperative programs that don't talk outside their little shard"  <-- sounds like functional programming, actually
20:10:39 <kmc_> :t \f -> fmap concat . sequence . map (uncurry f)
20:10:40 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f, Monad f) => (a1 -> b -> f [a]) -> [(a1, b)] -> f [a]
20:10:56 <dobblego> jmcarthur: that's classic
20:11:14 <kmc_> shachaf, not only does Javascript have closures, but it's apparently the only such language
20:11:18 <kmc_> depending on who you ask ;)
20:11:29 <shachaf> kmc_: I've never heard that particular claim before.
20:11:30 <dobblego> kmc_: you looking for mapM?
20:11:31 <kmc_> it's funny how C++ and Java managed to set the bar absurdly low
20:11:50 <kmc_> dobblego, could be
20:11:58 <kmc_> yeah i guess there's a mapM there
20:12:40 <kmc> i need rewrite rules in my editor ;)
20:12:51 <dobblego> that would be great
20:13:05 <shachaf> kmc: Is this part of some "every sufficiently-powerful language is actually JavaScript in disguise" argument that they borrowed from LISP?
20:13:17 <napping> It's unfortunate writing signatures on lambda arguments takes ScopedTypeVariables
20:13:38 <jmcarthur> kmc: so rig up your editor to automatically apply advice from hlint :)
20:13:46 <jmcarthur> (if only hlint gave good advice *all* the time)
20:13:47 <kmc> actually what i really want is zipWithM elsewhere
20:14:25 <kmc> shachaf, no it's just there was a rash of breathless articles about javascript on reddit by java refugees
20:14:32 <kmc> talking about this amazing new feature
20:14:35 <djahandarie> :t \f -> fmapDefault join . sequenceA . fmap (uncurry f)
20:14:35 <lambdabot> Not in scope: `fmapDefault'
20:14:35 <lambdabot> Not in scope: `sequenceA'
20:14:38 <kmc> i think they're over it now
20:14:45 <jmcarthur> it's a CLODJURE
20:14:49 <djahandarie> :t \f -> Data.Traversable.fmapDefault join . data.Traversable.sequenceA . fmap (uncurry f)
20:14:49 <lambdabot> parse error on input `data'
20:14:56 <djahandarie> :t \f -> Data.Traversable.fmapDefault join . Data.Traversable.sequenceA . fmap (uncurry f)
20:14:56 <lambdabot> forall (m :: * -> *) a (t :: * -> *) a1 b. (Monad m, Data.Traversable.Traversable t, Data.Traversable.Traversable m, Applicative t) => (a1 -> b -> t (m a)) -> m (a1, b) -> t (m a)
20:14:57 <monochrom> Guy Steele certainly has his grip on javascript :)
20:15:25 <kmc> haskell has a similar phenomenon, people write a gushing blog article about "quicksort" and then two weeks later a bitter exposé "debunking the hype"
20:15:35 <djahandarie> Actually that fmapDefault would server better as an fmap, oops
20:16:00 <jmcarthur> i'm not actually sure what hype about haskell there is to debunk
20:16:13 <kmc> jmcarthur, the claim that anyone can write any program in Haskell
20:16:25 <jmcarthur> seems that overwhelmingly people have low expectations going in
20:16:29 <jmcarthur> hmm, i guess i could see that
20:16:44 <kmc> "i failed to understand monads after one day, therefore nobody anywhere could ever understand"
20:16:55 <kmc> or worse "therefore only the liberal elite academic eggheads could understand"
20:16:57 <jmcarthur> no, that's not the worst one
20:16:58 <kmc> anyway Haskell was the flavor of the month on Reddit before JavaScript was
20:17:11 <kmc> and there was a subsequent backlash
20:17:12 <shachaf> kmc: And then the monad tutorials, of course.
20:17:16 <jmcarthur> "i failed to understand monads, therefore monads are not worth the time"
20:17:30 <dobblego> "I do not understand X, therefore, X is not useful"
20:17:44 <kmc> i'm sure in a year they'll be fighting about whether Postscript or MUMPS is the hippest language
20:17:44 <jmcarthur> yeah. there's a name for that fallacy, isn't there?
20:17:49 <jmcarthur> or some variant of it
20:17:56 <dobblego> argumentum ad ignorantiam?
20:18:00 <jmcarthur> lol
20:18:11 <monochrom> hahaha postscript
20:18:14 <shachaf> Oh, come on. PostScript isn't that bad.
20:18:22 <jmcarthur> MUMPS dude, MUMPS
20:18:25 <kmc> after the release of the MUMPS on Motorcycles framework for RESTful cloud web apps
20:18:31 <jmcarthur> (wtf i've never even seen MUMPS source code)
20:18:40 <shachaf> kmc: To compete wih NeWS?
20:19:12 <djahandarie> I got the mumps, baby babe, I got the mumps
20:19:33 <jmcarthur> Mumps is a contagious disease that leads to painful swelling of the salivary glands. 
20:19:38 <jmcarthur> is that accurate?
20:19:42 <shachaf> NeWS was actually nice.
20:19:49 <shachaf> Or so I hear, at least.
20:20:07 <shachaf> Given that it was dead before I was born.
20:20:53 <augur> conor mcbride is rory williams
20:20:58 <kmc> MUMPS was invented only one ⊤ stop over from where Scheme was invented
20:24:34 <gwern> > 4 * 0.30
20:24:36 <lambdabot>   1.2
20:27:01 <kush> hello all
20:27:19 <kush> i m having some trouble with interactive haskell codes
20:27:23 <kush> can someone help me 
20:27:28 <kush> give some good reference
20:27:33 <kush> or sample codes
20:27:46 <napping> using ghci?
20:27:51 <kush> yes
20:28:56 <kush> u there?
20:29:36 <napping> ghci toplevel is mostly like the inside of a do-block
20:30:28 <kush> i want to write a batch-kinda program
20:30:42 <kush> like solving problems in programming contests and all
20:31:03 <kush> i get stuck wen it comes to reading :P
20:32:53 <kmc> :t getContents
20:32:54 <lambdabot> IO String
20:32:56 <kmc> :t interact
20:32:57 <lambdabot> (String -> String) -> IO ()
20:34:46 <kush> and if we have read numbers?
20:34:50 <augur> kush!
20:35:19 <augur> is kush your name, kush
20:35:29 <kush> its my nick name
20:35:30 <kush> y
20:35:40 <augur> but not your actual name?
20:36:17 <kush> i know there is 'read::Int' function
20:36:28 <kush> but kinda get stuck many times
20:36:39 <kush> can someone refer some sample examples
20:39:44 <co_dh> kush: I don't understand your problem. 
20:41:02 <kush> is there some simple function that simply reads a list of numbers
20:41:17 <co_dh> from the console? or a string? 
20:41:19 <napping> read :: String->[Int]?
20:41:24 <kush> yes
20:41:32 <kush> rather
20:41:48 <kush> read:: IO String -> [Int]
20:42:58 <co_dh> well, it would be better if it's 2 function. read :: IO String , then parse :: String -> [Int]
20:43:14 <co_dh> what's the format of the string ? comma seperated ? 
20:43:27 <napping> opposite of show
20:43:30 <kush> space separated
20:43:37 <napping> read never does IO
20:43:40 <Apocalisp> cabal: dependencies conflict: ghc-6.10.4 requires filepath ==1.1.0.2 however
20:43:41 <Apocalisp> filepath-1.1.0.2 was excluded because ghc-6.10.4 requires filepath ==1.1.0.4
20:43:48 <napping> read "[1,2,3  ,4]" ==> [1,2,3,4]
20:43:55 <Apocalisp> what does it mean?
20:44:11 <kmc> :O
20:45:05 <co_dh> read "[1,2,3,4]" :: [Int]
20:45:51 <napping> Apocalisp: that means something is very broken
20:46:11 <augur> conor mcbrideee
20:46:42 <napping> you could see what ghc-pkg says about the dependencies of that package
20:47:22 <co_dh> if you need space separated string, you might need parsec. 
20:48:04 <napping> words is probably enough
20:48:08 <napping> map read . words
20:48:54 * napping finishes 58 under par : http://hpaste.org/44290/golfing_haskellnbt
20:49:25 <co_dh> yep, words is good. cool. never used before :(
20:55:26 <napping> Hello conal
20:56:00 <napping> It seems there's not any nondeterminism in your FRP semantics
20:57:53 <conal> napping: right. as i said, the semantics are precise & simple. nondeterminism makes imperative approaches semantically complex and therefore begging for bugs.
20:58:10 <gwern> > 800000000 * 0.02
20:58:11 <lambdabot>   1.6e7
20:58:33 <napping> It seems like it must be considered if you want to make claims about behavior involving user interaction and feedback
20:58:39 <conal> it's popular myth that concurrency implies nondetermism.
20:59:23 <conal> napping: what kind of claims do you expect necessarily raise nondetermism?
21:02:36 <napping> A system where FRP code is interacting with an external system
21:03:12 <napping> could be modeled as closed system containing a nondeterministic components for the external stuff
21:03:41 <napping> Also, I'm just learning Actor semantics
21:04:10 <conal> the 'sin' function is deterministic and yet can be used with user interaction, e.g., via ghci.
21:04:29 <conal> if you want *also* to model the user, that's another question.
21:05:06 <napping> More like modelling the user, though I'm not quite sure what I would like to prove
21:05:07 <conal> (aside: which may or may not naturally involve nondeterminism.)
21:05:09 <boegel> has anyone ever looked at evolving actual Haskell programming using genetic programming?
21:05:10 <co_dh> napping : if your FRP just take input from external system, it should not be implemented as nondetermism. 
21:05:48 <boegel> I know there's a GP lib in Haskell, but that currently only support evolving simple expressions, no actual Haskell programs
21:06:25 <co_dh> napping: if your FRP code output a 2  ( for example ) to external system, and the external system might response with some different value, that might be nondeterministic
21:06:30 <conal> boegel: i met someone at the recent hackathon (bayhac) who's evolving typed programs. might be close to what you're asking.
21:06:51 <boegel> conal: any more info on that?
21:07:05 <conal> boegel: trying to remember. hm.
21:07:42 <co_dh> conal: nice to meet you here. I've read most of your paper , and like them :)
21:07:45 <augur> conal! \o/
21:07:54 <conal> boegel: he wanted to talk to me about it, and we ran out of time. not very helpful i know. though you could find him on the bayhac mailing list.
21:08:14 <conal> co_dh: thanks! :) 
21:08:22 <conal> augur: howdy!
21:08:27 <adu> howdy
21:08:48 <conal> co_dh: thanks for helping napping 
21:08:48 <boegel> conal: hmm, interesting
21:08:58 <adu> which paper?
21:09:24 <co_dh> conal : can you make a living with contract job? 
21:09:46 <conal> adu: i think co_dh meant "papers" (considering "them"). unsure.
21:10:00 <adu> hmm
21:10:10 <co_dh> yes, papers. English is not my first language. 
21:10:12 <conal> co_dh: i'm wondering the same. i think other people can. i don't know whether i can.
21:11:05 <conal> co_dh: i've been trying to turn my thoughts more toward what interests & inspires me that has clearly communicable value to others. it's a start.
21:11:05 <napping> Actually, I'd like to figure out what sort of properties we would like to state about GUI programs
21:11:25 <boegel> conal: address for bayhac mailing list?
21:11:29 <conal> napping: great question. will hopefully lead to some insights.
21:11:39 <boegel> conal: google is failing on me...
21:11:54 <conal> boegel: bayhac@googlegroups.com . you may have to join first.
21:12:05 <adu> conal: good luck, my inspiration comes from pure/theoretical things, which are hard to re-inspire people about
21:12:07 <boegel> conal: k, thx
21:12:43 <adu> although I do want to make a search engine
21:12:46 <adu> for math
21:12:51 <adu> that would be sweet
21:13:22 <conal> adu: much of my inspiration is mathish as well. plus art. also hard to translate into concrete terms for the mundane/practical-headed.
21:13:35 <boegel> conal: I have some ideas on how to implemeting evolving true Haskell programs, but I'm not sure whether it'll work out
21:13:57 <conal> boegel: nice. it sounds like a really great topic to me.
21:14:32 <boegel> need to finish up on some other projects first, but it's getting to the top of my list :)
21:14:36 <conal> boegel: i like conor mcbride's remarks about types narrowing the search space for programs.
21:14:42 <kmc> call me skeptical but are there any examples of anything where genetic programming is a better approach than others?
21:14:52 <conal> boegel: which reminds me of genetic programming.
21:14:53 <boegel> conal: I did some work with genetic algorithms for my PhD, but never got to using Haskell for it
21:15:11 <conal> kmc: you & me.
21:15:15 <kmc> GA is already pretty cargo-cult, GP seems to take it one big step further
21:15:24 <boegel> kmc: not sure, but it seems like a cool idea to just generate the program you want by specifying what you want it to do
21:15:29 <conal> kmc: ;)
21:15:30 <adu> I wonder if I could get away with trademarking Γooγλe
21:15:40 <boegel> conal: where?
21:15:43 <kmc> i'll believe GA is good at some things, but i also believe people overuse it due to cool-factor, when they could be using a much simpler optimization algorithm with nicer properties
21:15:44 <conal> adu: nice!
21:16:02 <augur> kmc: if only people understood the results of GAs
21:16:02 <boegel> kmc: GA is powerful, if used in the right way imho
21:16:09 <conal> boegel: twitter, recently
21:16:29 <boegel> augur: sometimes you don't need to
21:16:35 <adu> conal: wanna make a math search engine with me?
21:16:36 <augur> boegel: depends on your purposes!
21:16:43 <augur> but you're right, sometimes you dont need to
21:16:47 <boegel> augur: if it compiles, and does what you want it to do, who cares how it does it?
21:16:49 <kmc> anyway i'm all for cool factor and doing things because they're cool
21:16:52 <conal> adu: doesn't grab me yet, but feel free to try to inspire me.
21:16:55 <kmc> just wondering if GP is viable outside that space
21:16:58 <augur> boegel: how do you know it does what you want it to!
21:17:13 <boegel> augur: by testing/evaluating it thoroughly
21:17:17 <augur> testing is not a sufficient way of proving correctness!
21:17:30 <kmc> augur, clearly you should also evolve a proof of correctness
21:17:36 <boegel> augur: but I would add a tag "don't use this in a nuclear power plant", you're right
21:17:38 <augur> obviously what we need is GAs for Agda!
21:17:41 <boegel> kmc: ^_^
21:17:58 <conal> the more we use powerful/general types, the more tightly constrained our programs are, so i'd expect GP to work better than in other settings.
21:17:59 <boegel> conal: seen this? http://jpmoresmau.blogspot.com/2011/01/evolving-computer-with-tecs-and-genprog.html
21:18:10 <augur> Acgta  we can call it
21:18:13 <conal> boegel: no i haven't. thx for the pointer.
21:18:20 <kmc> hehe augur
21:18:40 <adu> conal: my goal is to have 1 page per equivalence class, meaning any time a function is specialized or generalized, that would have a page too
21:18:57 <conal> adu: "page"?
21:19:00 <boegel> conal: that's what got me really interested in it
21:19:26 <kulakowski> adu: I doubt you could get that registered as a trademark, but also doubt that google would come after you
21:19:47 <adu> conal: page meaning "entry" or "row" or "object" or "set of attributes" (roughly equivalent to Google's: Downloads, Manual, Documentation, Mailing List, etc...)
21:19:49 <augur> i had a wonderful insight trying to explain the idea behind Maybe to a friend the other night
21:19:52 <conal> boegel: neat. i bet you'd do even better with a more typed programming style.
21:19:58 <augur> Bool -> Maybe -> Either -> List
21:20:02 <boegel> conal: yeah, might be
21:20:08 <co_dh> what is GA? 
21:20:16 <augur> co_dh: genetic algorithm
21:20:40 <boegel> conal: the idea I had was to use hoogle somehow during the evolution to figure out the possibilities for tweaking an existing program
21:20:46 <co_dh> so what's the difference between GA and GP? 
21:20:53 <boegel> conal: e.g. just plug in stuff where the type fits
21:20:54 <conal> boegel: oh, wow. i like that idea.
21:21:22 <boegel> co_dh: genetic programming evolves something that does something, e.g. a program or expression
21:21:40 <conal> boegel: more *polymorphic* programs are more tightly constrained. that's what i was trying to say earlier.
21:21:44 <boegel> co_dh: GAs generate some passive entity, e.g. a list of values
21:21:49 <adu> conal: anyways, it would be a mixture of math and compsci
21:22:18 * boegel hurries up to patent the hoogle in GP idea
21:22:32 <adu> so not only would there be a "page" on integer gcd, there would be a "page" on int32 gcd, int64 gcd, int128 gcd, etc...
21:22:36 <ne> super-optimizers are one practical example where "GP" is (or at least used to be) useful.  although there isn't much "evolution" there; you just try random things until you find what you want.
21:23:02 <boegel> ne: you should always compare GA/GP with just random search
21:23:07 <adu> ooooo what's GP?
21:23:15 <boegel> adu: genetic programming
21:23:23 <adu> wow I want that in my life
21:23:34 <kmc> ne, i saw a cool paper that found candidate superoptimizations by random search, then proved them correct with a SMT solver
21:23:34 <co_dh> conal: what's your opinion on Yampa? 
21:23:57 <adu> superopt is cool in theory, but "superopt" is a terrible implementation of it
21:24:01 <conal> co_dh: i try not to have opinions. but i can answer other questions.
21:24:22 <conal> (seriously. i am *so* weary of opinions.)
21:24:54 <kmc> opinions are like assholes.  everyone has one and they like to show them off on reddit
21:25:01 <adu> lol
21:25:03 <co_dh> I found Yampa code are extremely hard to read. I'm totally lost in the Quake thesis in Yampa. 
21:25:05 <ne> kmc, indeed, that seems like a good plan.
21:25:23 <co_dh> also, Yampa seemed implemented in a state machine . 
21:25:36 <boegel> kmc: ok, how do I submit a quote for HWN? :)
21:25:43 <conal> kmc: hah.
21:26:07 <adu> fascinating
21:26:46 <conal> co_dh: i have a hard time reading yampa code also, but i hear that some people got used to it.
21:27:07 <kmc> boegel, it gets submitted for you
21:27:11 <kmc> by the Powers that Be
21:27:18 <kmc> but odds are higher if you @remember it, i guess?
21:27:22 <conal> co_dh: i dislike the linear/sequential look of the code.
21:28:04 <co_dh> conal: you mean imperative? 
21:28:08 <conal> co_dh: and i've been disappointed that my original denotative focus for frp is often set aside.
21:28:23 <boegel> kmc: submitted it to Daniel, you're going to be in HWN baby!
21:28:33 <kmc> wouldn't be the first time *sigh*
21:28:39 <boegel> @remember kmc opinions are like assholes.  everyone has one and they like to show them off on reddit
21:28:39 <lambdabot> Good to know.
21:28:42 <co_dh> I like denotative too, I support you :)
21:29:35 <napping> conal: Hopefully, a GUI could be implemented denotationally, with functions taking a description of widgets and screens into the FRP behaviours that present it
21:29:39 <conal> co_dh: no. i know yampa is at least fairly close to having a simple, continuous denotation. not like imperative programming (including haskell's IO). i mean something more superficial: the way that arrow notation leads to more sequenced style of programming.
21:30:21 <hskltyp> Is there a haskell package that can take as input: "a string / a Haskell AST representing a function", and as output; returns the compiled function
21:30:36 <conal> napping: yes. that was a direction explored somewhat in Genuinely Functional User Interfaces (http://conal.net/papers/genuinely-functional-guis.pdf)
21:31:32 <hskltyp> i.e. is there a package that allows haskell code to compile haskell code on the fly + load it int the current binary?
21:31:36 <conal> napping: i used the term "genuinely functional" where now i say "denotative".
21:32:10 <napping> Then you might want to prove things like "If a mouse event arrives at a time when a button is the most recently drawn things at that point, the interpretation will do the thing the GUI description calls for"
21:32:13 <co_dh> conal : how is the performance of Reactive now ? and memory usage ? are you using it on ipad or iphone?
21:32:21 <conal> @hackage plugins
21:32:22 <kmc> hskltyp, see: plugins, hint, mueval, direct-plugins, safe-plugins
21:32:22 <lambdabot> http://hackage.haskell.org/package/plugins
21:32:24 <conal> hskltyp: ^^
21:32:40 <conal> hskltyp: i think that package has been difficult to keep working over versions of ghc.
21:32:53 <conal> hskltyp: oh. kmc gave you way more info.
21:32:54 <hskltyp> conal: nice; thanks!
21:33:08 <kmc> hskltyp, all of which are based on the GHC API, which you can also use directly, but is kind of hairy
21:33:26 <kmc> for "String -> a" i would use "hint"
21:33:32 <conal> co_dh: i think it's still pretty bad. i've been working on other things. particularly high-level GPU programming. which i see as a killer app for denotative programming.
21:33:39 <hskltyp> kmc: so do these packages basically link ghc into my application>
21:34:00 <c_wraith> yes, they do
21:34:04 <kmc> hskltyp, yep
21:34:07 <conal> co_dh: i still noodle over frp in the background.
21:34:18 <hskltyp> so this would probably be a bad idea
21:34:18 <kmc> ghc is available as a haskell library that gets linked like any other
21:34:20 <hskltyp> for an iphone app?
21:34:25 <kmc> (i.e., statically, unless you try to do otherwise)
21:34:26 <kmc> heh
21:34:31 <kmc> it won't work on iphone for a number of reasons
21:34:40 <kmc> really too many to enumerate
21:34:46 <conal> and i really dislike the name "frp", as it omits what's always been important to me: continuous time and precise & simple denotation.
21:34:52 <kmc> you could use a different haskell compiler / interpreter
21:35:13 <blackdog> kmc: what won't work on iphone? ghc?
21:35:14 <kmc> send off haskell code to a server to be compiled into yhc bytecode, or something
21:35:23 <blackdog> or you mean including the interpreter?
21:35:26 <kmc> the latter
21:35:26 <conal> so i prefer "denotative continuous-time programming" (DCTP). i think jmcarthur and/or i came up with that term.
21:35:49 <co_dh> what do you mean by noodle over frp ? 
21:36:05 <kmc> i don't recall if ghci even works on ARM Linux, let alone ARM OS X
21:36:26 <kmc> and then there's all the iPhone's technical restrictions against code loading / generation
21:36:32 <kmc> and then the fact that Apple will ban your app anyway
21:36:37 <kmc> even if you don't break any of their official rules
21:36:50 <kmc> and also the fact that GHC probably won't run in the amount of RAM available
21:36:56 <kmc> and will be hellishly slow
21:37:28 <kmc> (it will run at at least a 2x extra speed penalty unless you put in the extra work to make the ghc-iphone cross compiler generate registerized code)
21:37:31 <conal> one nice exception to the Apple ban on code loading & generation is GPU code.
21:37:38 <co_dh> kmc : thanks, nice to know that. 
21:38:01 * hskltyp kmc: understood
21:38:05 <kmc> fuck the iphone
21:38:07 <kmc> just saying
21:38:12 <hskltyp> don't use ghc for iphone/ipad
21:38:24 <kmc> hskltyp, oh, you can use ghc on your computer to compile apps for iphone
21:38:31 <hskltyp> i meant for profit
21:38:32 <kmc> just don't try to run ghc on the iphone :)
21:39:13 <co_dh> I don't need run ghc on iphone, but program in haskell and run on iphone is good enough . 
21:39:21 <kmc> you can even do it for profit
21:39:22 <kmc> iPwn Studios is doing so
21:39:46 <kmc> well if they ever release their thing
21:39:59 <hskltyp> waht is iPwn Studios releasing?
21:41:07 <kmc> a video game
21:41:08 <kmc> with realtime graphics / sound in C++, and game logic, AI, UI, everything else in Haskell
21:41:08 <conal> i met someone at bayhac who's also trying to get ghc->iphone working. tim sears. a very smart fellow.
21:41:16 <kmc> talk to Cale or pastorn about it, they're on the team
21:41:29 <conal> i think ghc-iphone will come together.
21:41:41 <kmc> i did some work on a possible Android port but i think they've forgotten I exist
21:41:54 <kmc> i think, fuck the iphone
21:42:04 <kmc> not sure why we should put effort into supporting an adversarial platform
21:42:37 <conal> i talked with ryan trinkle early on about working with iPwn, but i couldn't get inspired about investing my energy in a violence-centered game.
21:42:38 <co_dh> kmc: what makes you so angry on iphone? 
21:42:58 <hskltyp> conal: bayhac <-- some haskell group in the bay area?
21:43:03 <shachaf> Well, Apple is evil.
21:43:12 <shachaf> hskltyp: A hackathon a couple of weeks ago.
21:43:15 <co_dh> I played violence game many many years, but that didn't make me a violent person. 
21:43:17 <btutt> how well do non-NCG/reg'd ports like arms perform?
21:43:28 <conal> shachaf: "don't blame the players. blame the game" (capitalism)
21:43:34 <hskltyp> kmc: what team is Cale/pastorn on?
21:43:35 <co_dh> In fact, I learned how to control my anger, especially in fight game, like street fighter. 
21:43:38 <shachaf> hskltyp: Hmm, are you at Stanford?
21:43:49 <shachaf> hskltyp: iPwn Studios.
21:43:49 <conal> co_dh: i'm not worried about becoming violent. i'm interested in helping humanity evolve.
21:44:03 <hskltyp> shachaf: technically, yes
21:44:10 <co_dh> to win, you have to calm down and watch your opponent. 
21:44:13 <hskltyp> shachaf: you?
21:44:15 <shachaf> hskltyp: Well, you're welcome to come to bahaskell in San Francisco, whenever the next meeting is. :-)
21:44:31 <shachaf> hskltyp: I live in (East) Palo Alto.
21:44:31 <conal> hskltyp: it's a recent hackathon held in mountain view.
21:44:36 <hskltyp> shachaf: am I welcome for being in the bay area or having a stanford IP?
21:44:45 <hskltyp> shachaf: ah, are you doing a startup in haskell?
21:45:03 <shachaf> hskltyp: Welcome for being a (presumably) Haskell person in the area.
21:45:16 <hskltyp> shachaf: is there a webpage?
21:45:17 * shachaf doesn't have the power to welcome people to bahaskell.
21:45:34 <kmc> btutt, registerized C is okay (competitive with NGC).  unregisterized is *bad*
21:45:37 <shachaf> hskltyp: <http://groups.google.com/group/bahaskell>. Not sure when the next meeting is.
21:45:50 <kmc> btutt, as in twice as slow or more
21:45:55 <btutt> oh ugh
21:46:01 <napping> conal: do you think things along those lines will be provable without involving nondeterminism?
21:46:07 <hskltyp> ipwn studios looks like a real game studio
21:46:11 <hskltyp> i.e. they have writers and artists
21:46:24 <hskltyp> is any of their tech oipen source?
21:46:30 <shachaf> hskltyp: I meant that you're generally welcome to come if you're looking for a Haskell group in the bay area. :-)
21:46:32 <kmc> btutt, a tail call goes from being "jump" to "push; return; pop; jump"
21:46:42 <conal> napping: i'm looking for context
21:46:47 <btutt> NCG for arm would sure be nice then :)
21:46:55 <shachaf> hskltyp: I work at a startup with some Haskellers, but doing no Haskell there, alas.
21:47:03 <napping> The example was using an FRP library to write an interpreter for GUI descriptions
21:47:03 <conal> napping: yesa.
21:47:07 <conal> yes*
21:47:08 <kmc> i work for a startup where everyone knows Haskell
21:47:10 <btutt> I program for some arm7 and arm9 variants at work
21:47:15 <kmc> they write Python code with Haskell type signatures in the docstrings
21:47:18 <hskltyp> kmc: what startup is that?
21:47:23 <napping> and proving for example that a mouse click on a position where a button was previously drawn leads to a correct transitions
21:47:23 <shachaf> kmc: Ksplice, right?
21:47:25 <kmc> http://www.ksplice.com/
21:47:27 <kmc> yep
21:47:55 <hskltyp> does ksplice actually make money? why do ppeople hate rebooting so much
21:48:04 <conal> napping: and more easily if you shift away from notions like "drawing". shift from presentation to modeling.
21:48:04 <kmc> hskltyp, because you have to coordinate a downtime with your users
21:48:06 <hskltyp> kmc: are you a MIT or Harvard graduate?
21:48:07 <shachaf> hskltyp: Presumably server people, not desktop people.
21:48:08 <kmc> and in the meantime you'll get hacked
21:48:10 <btutt> downtime costs money
21:48:24 <kmc> it's not just the downtime, it's the overhead of admins dealing with it
21:48:46 <btutt> oh sure. but its even more than that depending on the industry you're in
21:48:47 <hskltyp> kmc: ksplice seems like exactly the type of things that bored open source developers would replicate for fun
21:48:52 <conal> napping: just as it's more elegant to reason in terms of numbers than in terms of numerals.
21:48:59 <btutt> i.e. down time on oil rig systems costs serious money time really == $ ;)
21:49:00 <kmc> hskltyp, the code is already open source
21:49:10 <hskltyp> kmc: so why do people pay?
21:49:16 <conal> napping: and much easier than reasoning in terms of *drawing* numerals.
21:49:41 <napping> But ideally the proofs can be layered
21:49:51 <kmc> hskltyp, because you have to know what you're doing in using those tools
21:50:04 <btutt> Support, its all about a support contract
21:50:06 <napping> prove that drawings of numbers are an adequate representation of numerals, and numerals of numbers
21:50:06 <hskltyp> kmc: so profitability through obfuscation?
21:50:23 <napping> then just worry about numbers
21:50:25 <kmc> hskltyp, you're right, it's deliberately obfuscated, it's not like linux kernel programming is difficult or error prone ;P
21:50:28 <btutt> Its called paying to defer the problem to someone who cares enough about it. :)
21:50:33 <shachaf> The way CentOS does kernel backports is quite annoying.
21:50:42 <napping> Maybe silly for math, less silly for foundational verification of computer systems
21:50:47 <btutt> (and will answer the phone when you call)
21:50:52 <hskltyp> kmc: I bet the python do cstrings are deliberately wrong
21:51:00 <conal> napping: more or less.
21:51:06 <hskltyp> why don't you guys just use haskell if you're going to use python like haskell
21:51:38 <co_dh> kmc: how big is your company ? if it's not a business secret?
21:51:41 <conal> napping: i doubt you'd really have to map backwards from draw-ing (imperative) to picture (functional).
21:51:50 <kmc> co_dh, not sure they want us to say, but you should read through the blog
21:51:57 <conal> napping: if i understand what you mean by "adequate representation".
21:52:33 <napping> For the property about buttons, "drawing" just means presenting a picture
21:52:56 <napping> or something a tiny bit more complicated if you produce a stream of drawing commands rather then complete images
21:52:57 <hskltyp> kmc: does your background include the math olympiad trainig camp or the informatics training camp?
21:53:08 <kmc> no, no, and no i'm not a MIT or Harvard grad
21:53:09 <kmc> why?
21:53:32 <hskltyp> kmc: your nick looked familiar somehow
21:53:33 <conal> napping: i was going on "most recently drawn things". you don't need the notion of "recent" if you shift from imperative to functional/denotative.
21:53:38 <kmc> heh
21:53:49 <hskltyp> kmc: plus, ksplice is mostly a harvard/mit math/cs ppl right?
21:53:50 <conal> napping: and i'm probably straying from your main question of interest.
21:54:02 <kmc> yeah
21:54:13 <napping> If the picture is produces as a discrete rather than continuous stream, "most recent" is still sensible
21:54:24 <conal> napping: maybe it was habitual rather than deliberate phrasing
21:55:12 <napping> It is appropriate for the model I was thinking of
21:55:30 <napping> perhaps it would be better for the visual output to be handled as a continous stream
21:55:31 <hskltyp> does ipwn studios have a demo anywhere?
21:55:36 <conal> napping: of course you can make sense of draw-ing commands. i'm trying to give you advice about what'll make your reasoning simple. feel free to ignore, however.
21:55:36 <hskltyp> their tech sounds absurdly amazing
21:55:45 <hskltyp> as if they're going to just crush everyone
21:56:23 <adu> which tech?
21:56:36 <hskltyp> ipwn studios
21:56:38 <napping> I think nondeterminism starts to become more relevant when you have feedback from a system's output to the input
21:56:51 <adu> ipwn studios was going to hire me
21:56:53 <kmc> hskltyp, sure, the game is also 1+ years late
21:57:01 <napping> So probably unecessary even for user interfaces
21:57:05 <kmc> not like this is unusual for software
21:57:07 <conal> napping: if you maintain a disciplined denotational approach, you'll be able to measure simplicity accurately, and that measure will guide you.
21:57:08 <hskltyp> adu: what happened? they caught you using ocaml?
21:57:20 <napping> I doubt users can be modeled accurately enough to have that kind of feedback
21:57:21 <kmc> hskltyp, i'm curious how you know of ksplice
21:57:23 <adu> hskltyp: nope, I moved to Japan
21:57:26 <gwern> > 16.6 / 37.8
21:57:27 <lambdabot>   0.43915343915343924
21:57:40 <hskltyp> kmc: founders of ksplice is a friend of a friend
21:57:51 <kmc> oh cool, which one?
21:57:56 <conal> napping: even feedback needn't raise nondetermism. consider ODEs -- a classic feedback framework.
21:57:58 <napping> kmc: Is ksplice that obscure?
21:57:59 <copumpkin> I'd heard of ksplice before kmc mentioned it
21:58:04 <conal> nondeterminism*
21:58:06 <gwern> kmc: oh wait, ipwn studios still exists?
21:58:09 <kmc> napping, i'm really not sure
21:58:12 <copumpkin> then another friend of mine interned there too
21:58:13 <hskltyp> kmc: eh, this is IRC, I don't want to give out full legal names + SSN + bank account details
21:58:17 <adu> hskltyp: I think there was another reason, like I couldn't get Haskell hello world to work on Android, which was a prerequisite for working there
21:58:19 <gwern> I thought blodnight had been abandoned or something
21:58:22 <kmc> hskltyp, that's fair enough
21:58:27 <blackdog> kmc: i didn't realise you were working on something so applied :) your blog looks interesting.
21:58:31 <copumpkin> gwern: they're hunting bunny wabbits
21:58:32 <napping> It's been mentioned places - research, lwn, etc.
21:58:36 <hskltyp> kmc: where is your blog?
21:58:41 <copumpkin> that's why they're being vewwy vewwy quiet
21:58:42 <kmc> http://mainisusuallyafunction.blogspot.com/
21:58:46 <kmc> thanks blackdog
21:58:52 <adu> hskltyp: iirc, I got Haskell hello world to compile, but every time it ran it would coredump
21:58:52 <gwern> copumpkin: har har. maybe it's the silenceo f the grave, not the hunter
21:59:00 <kmc> or did you mean the ksplice blog (also interesting, mostly not by me)
21:59:05 <conal> napping: as you explore, i think you'll find that a lot of nondeterminism is accidental side-effect of imperative thinking.
21:59:24 <conal> napping: though please do explore, rather than taking my word for it.
21:59:32 <conal> s/though/and/
21:59:35 <adu> hskltyp: the core problem was/is that Android only implements about 60% of libc
21:59:40 <napping> conal: I will have quite a lot of it to work with in the Actor semantics
21:59:40 <hskltyp> adu: fun
22:00:38 <hskltyp> in korean dramas; why do the lab techs look like victoria secret models?
22:00:44 <conal> napping: quite a lot of what?  nondeterminism? accidental side-effects? imperative thinking?
22:00:52 <napping> hmm, probably all of the above
22:01:16 <conal> yeah. probably so. have fun!
22:01:29 <conal> (not my cup of tea.)
22:01:37 <napping> especially in the standard semantics where you have sets of possible runs which are arbitrary linearizations of events, and events include things like internal beta-reductions
22:01:48 <kush> hello
22:02:13 <kush> how can I debug a haskell program
22:02:18 <kush> step by step
22:02:22 <napping> I think our term project will by trying to recast some of that at least in terms of a causal preorder that avoids at least some of the accidental choices made in linearization
22:04:06 <napping> kmc: did you say why you didn't just program in Haskell, if you are writing types in comments?
22:06:52 <sshorm> fags
22:09:19 <allbery_b> *tweet* 30 yard penalty
22:09:37 <ulfdoz> wrong media ;)
22:09:58 <taotree> Any suggestions on this "cannot construct the infinite type" error:  http://hpaste.org/44291/infinitetype
22:10:13 <allbery_b> 2yos transcend media
22:11:38 <djahandarie> Heh, https://github.com/tanakh/hsux
22:11:40 <djahandarie> hsux
22:13:07 <kmc> kush, step by step isn't the right way to think about it
22:13:24 <ClaudiusMaximus> taotree: perhaps put "return $ " at the start of lines 12 and 16 ? (just a guess, from guessing what your intent might have been)
22:13:34 <kmc> kush, more like function by function.  use ghci to play with the functions you wrote until you find one that's misbehaving
22:13:40 <kmc> then pick apart the functions it uses, etc.
22:14:16 <taotree> ClaudiusMaximus, Thanks, but that just results in two cannot construct infiinite type errors.
22:14:56 <kmc> napping, not an easy question to answer
22:14:57 <kmc> certainly some of it could be rewritten in haskell
22:14:57 <kmc> it would be harder to find people to work on the code
22:15:11 <Eduard_Munteanu> taotree: "action' <- action" looks like a possible culprit
22:15:22 <taotree> start .. -> IO (stop's type) and stop's type is IO (start's type) so it is infinitely recursive... I can see that, but... what I'm trying to do should be possible
22:15:49 <napping> Oh, I assumed it was a worry about installed base
22:16:04 <allbery_b> it looks to me like stopDragAction invokes startDragAction invokes stopDragAction
22:16:08 * hackagebot Chitra 0.1 - Simple, VNC based graphics rendering system  http://hackage.haskell.org/package/Chitra-0.1 (KashyapChatamballi)
22:16:11 <napping> A working Python installation is probably a reasonable assumption
22:16:12 <taotree> Eduard_Munteanu, yes... the two functions return each other
22:16:39 <kmc> napping, not totally
22:17:03 <kmc> an advantage of haskell is that you can compile haskell code to a binary which only dynamically links standard C libraries
22:17:16 <kmc> in fact this is the default for GHC
22:17:37 <kmc> but some old distros like RHEL 4 actually provide a libc too old for modern GHC
22:17:41 <kmc> i know this from hard experience
22:17:42 * ClaudiusMaximus confused by the recursive do
22:17:52 <taotree> do I need to somehow hide the concrete types so they'll just think it's ok?
22:18:20 <allbery_b> you have recursion with no base case and insufficient unwrapping
22:19:08 <allbery_b> so it tries to do IO a ... IO (IO a) ... IO (IO (IO a...)) which is the infinite type
22:19:12 <Ke> kmc: once I can do this and load all the libraries at startup, and automatically detect all breakage
22:19:17 <taotree> allbery_b, yes
22:21:04 <allbery_b> but I am quite drunk at the moment and can't see how to fix it (literally; I need to use one eye because when I'm this drunk my brain fails to correct for my eyes having different focal points)
22:21:24 <taotree> allbery_b, lol
22:21:41 <allbery_b> (and relying on red squiggles o tell me where I typoed, which is pretty much everywhere)
22:25:26 <lispy> allbery_b: time for a nap
22:26:01 <Eduard_Munteanu> taotree: in order to do "action' <- action", action must be of type IO t. But then you unwrap it into 't' and call toggleHandler again.
22:26:16 <allbery_b> I get panic attacks when I'm this driunk.  (screwed up a bit) napping is kinda uot of the quesstion in this state
22:26:38 <allbery_b> gotta wait it out
22:27:26 <Eduard_Munteanu> I find it alcohol kinda interferes with my sleep.
22:27:55 <allbery_b> that too
22:28:45 <allbery_b> I did not intend to end up tis drunk; panic attacks suck hard
22:29:29 <taotree> Eduard_Munteanu, right. What I'm trying to do is set up a generic way for an event handler to get registered, and then when the event occurs, it disconnects and registers a different one, and next time event occurs, same thing, etc. So it toggles between event handlers
22:31:55 <Eduard_Munteanu>    toggleHandler (canvas `on` buttonPressEvent) (startDragAction window fixed canvas)
22:32:19 <taotree> I created a data type and made it compile, and now it does end up in an infinite loop... so just have to get it to not loop
22:32:26 <Eduard_Munteanu> How does it make sense for toggleHandler to be recursive?
22:34:41 <taotree> Eduard_Munteanu, well, it's not supposed to be directly recursive... the "recursion" occurs in the event handler
22:35:31 <Eduard_Munteanu> Is this Gtk2Hs?
22:35:36 <taotree> yes
22:35:36 <Eduard_Munteanu> I need some context here.
22:35:38 <Eduard_Munteanu> Ah.
22:37:22 <ClaudiusMaximus> taotree: yes, that's what i thought - did you insert the "return $ " where i suggested (otherwise you execute the next handler immediately..)
22:38:00 <taotree> ClaudiusMaximus, yes, but... since the other methods return IO (other), wouldn't return just wrap it again?
22:38:16 <taotree> s/methods/functions/
22:38:39 <Eduard_Munteanu> Ok so toggleEventHandler is supposed to switch between {start,stop}DragAction. How does it know or set the other handler?
22:38:40 <c_wraith> taotree: Nothing's wrong with wrapping IO in something else.  I've used the type IO (IO (Snap (), IO ())) before
22:38:46 <Eduard_Munteanu> I don't see it passed anywhere.
22:39:19 <taotree> yes, but then it will be infinitely wrapped.
22:39:29 <c_wraith> Not if you're careful
22:40:37 <taotree> Eduard_Munteanu, it sets the other handler because it switches actions. That's the crux of the issue. That's the action' <- action thing. It disconnects the old handler, registers a new one, executes the action, and curries the new action for the next time around
22:40:47 <c_wraith> :t fix In :: Mu IO
22:40:49 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
22:40:49 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
22:40:49 <lambdabot>       Expected type: f (Mu f)
22:41:01 <c_wraith> :t In
22:41:03 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
22:41:23 <c_wraith> > fix (In . return)
22:41:24 <lambdabot>   No instance for (GHC.Show.Show (f (L.Mu f)))
22:41:24 <lambdabot>    arising from a use of `M853...
22:41:27 <Bynbo7> :t (In . return) :: Mu IO
22:41:29 <lambdabot>     Couldn't match expected type `Mu IO'
22:41:29 <lambdabot>            against inferred type `Mu f -> Mu f'
22:41:29 <lambdabot>     In the expression: (In . return) :: Mu IO
22:41:36 <Bynbo7> :t fix (In . return) :: Mu IO
22:41:37 <lambdabot> Mu IO
22:41:43 <c_wraith> there.  infinite wrapping of IO.
22:41:47 <c_wraith> Not what you actually want.
22:41:48 <ClaudiusMaximus> ahh, i think i see:  you want to have something like   type Handler = ... -> IO Handler ; which is recursive, no good, but i suspect you can break the recursion with something like newtype Handler = H { runHandler :: ... -> IO Handler } -- untested
22:41:50 <c_wraith> But it's possible!
22:42:20 <c_wraith> Oh, right.  breaking infinite types requires data or newtype.  Type does nothing.
22:42:49 <taotree> ClaudiusMaximus, I did that, I think: data TogAction = TogAction { f :: IO (TogAction) }   but then it gets in an infinite loop
22:43:50 <Eduard_Munteanu> Oh, I see it now... you're returning the other action to be executed.
22:43:57 <ClaudiusMaximus> taotree: i think that might be coming from the do rec thing, i don't get how that is supposed to work
22:43:57 <taotree> Eduard_Munteanu, yes
22:44:23 <taotree> ClaudiusMaximus, yeah, that's a new thing to me. Apparently using mfix is another option to do that (just tried it with exact same behavior).
22:44:27 <Eduard_Munteanu> stopDragAction cid win layout target = do trace "disconnect in stop" $ signalDisconnect cid startDragAction win layout target
22:44:45 <taotree> the rec thing is so the cid that's outside the do block can be used inside
22:44:49 <Eduard_Munteanu> Shouldn't there be something like .... return $ startDragAction win layout target
22:45:31 <Eduard_Munteanu> And you should probably write type sigs.
22:45:45 <taotree> I have them now... I'll repaste
22:45:49 <ClaudiusMaximus> taotree: right, but i'm guessing there might be too much strictness there
22:45:59 <Eduard_Munteanu> That way, stopDragAction is ... -> IO (IO something), or similar
22:46:31 <Eduard_Munteanu> or whatever the outer monad is
22:46:56 <taotree> http://hpaste.org/paste/44291/infinitetype_annotation#p44292
22:46:58 <ClaudiusMaximus> i never used do rec (which is syntax sugar for mfix, or something along those lines) - there was a post recently on -cafe which had a cute example, i'll try find a link
22:47:02 <taotree> This one compiles now, but runs infinite loop
22:47:28 <taotree> ClaudiusMaximus, strictness does seem to cause the infinite loop to me, too
22:48:12 <ClaudiusMaximus> taotree: ah, in that annotation you're missing the "return $ ", so instead of returning the new handler, you're running it immediately
22:48:15 <Eduard_Munteanu> taotree: that should be stopDragAction :: ConnectId Window -> Window -> Fixed -> DrawingArea -> IO (IO TogAction)
22:48:27 <Eduard_Munteanu> (of course, and the code should be modified to reflect that)
22:48:50 <Eduard_Munteanu> You kinda need to return on the last line
22:48:54 <ClaudiusMaximus> and it probably should be  return . TogAction $ ...
22:49:18 <Eduard_Munteanu> ClaudiusMaximus: yeah, he's actually executing it there.
22:49:56 <ClaudiusMaximus> otherwise you'll be back at infinite type errors
22:51:32 <taotree> ok, but using the return, I'm back at infinite types basically because I would have to change the return types of the functions, but then that wraps the functions further...
22:51:39 <Eduard_Munteanu> And you should probably get rid of the TogAction wrapper.
22:52:13 <ClaudiusMaximus> taotree: can you paste enough code to have an example i could try to run?
22:52:20 <Eduard_Munteanu> taotree: no, it won't, action :: IO (IO t), binding it to action' reduces it to (IO t)
22:52:41 <Eduard_Munteanu> taotree: just revert to the initial version and use 'return'
22:53:55 <taotree> Eduard_Munteanu, it doesn't work. It wraps it each time. So I put a return in. Now I have to change the return types of the functions so it's IO (IO (a)). So then I'd have to somehow wrap that return again, but then I'd have to change the return types again... ad infinitum
22:54:41 <c_wraith> taotree: it works just fine
22:54:54 <c_wraith> taotree: you don't need infinite levels of wrapping.  One suffices.
22:55:32 <taotree> c_wraith, umm... I might be doing it wrong, but it doesn't work... I tried it
22:56:19 <taotree> I think this is enough to compile/run: http://hpaste.org/44293/infinitetype_annotation?pid=44293&lang_44293=Haskell
22:56:47 <taotree> oops, not yet
22:56:54 <c_wraith> I can't install gtk2hs, so I can't test
22:57:12 <taotree> this one: http://hpaste.org/paste/44293/infinitetype_annotation_ann#p44294
23:02:09 <ClaudiusMaximus> taotree: http://hpaste.org/paste/44293/seems_to_work_now#p44296 ?
23:03:11 <taotree> ClaudiusMaximus, I'm not seeing what you changed
23:03:45 <ClaudiusMaximus> taotree: hold on, i can paste a diff
23:04:42 <ClaudiusMaximus> taotree: if my diff isn't wrong, it's just:
23:04:44 <ClaudiusMaximus> -startDragAction :: Window -> Fixed -> DrawingArea -> IO (IO TogAction)
23:04:44 <ClaudiusMaximus> +startDragAction :: Window -> Fixed -> DrawingArea -> IO TogAction
23:05:10 <ClaudiusMaximus> and similarly for stopDragAction
23:05:15 <taotree> ClaudiusMaximus, weird... I thought I tried that
23:05:54 <taotree> Great, thank you all very much
23:06:41 <Eduard_Munteanu> Note TogAction was yet another layer!
23:06:50 <ClaudiusMaximus> taotree: cool :)  helpful for me too, because i'll want to implement something similar eventually
23:07:15 <ClaudiusMaximus> Eduard_Munteanu: that newtype or data layer is necessary to break the infinite type
23:07:52 <taotree> Right, could probably make TogAction just a simple newtype. I'm not using it as a record anyway
23:07:55 <Eduard_Munteanu> Hrm, I kinda suspected that, I've been trying a Mu IO variant on his code, but my gtk2hs install seems to be broken
23:08:28 <Eduard_Munteanu> Why didn't you simply modify the event handlers?
23:08:39 <taotree> ClaudiusMaximus, Right. I had a working version of stuff and as I refactored and abstracted I discovered this simple toggle control structure that's kind of handy
23:08:41 <Eduard_Munteanu> I think that's doable.
23:08:58 <taotree> Eduard_Munteanu, what do you mean by modify event handlers?
23:09:35 <Eduard_Munteanu> taotree: most certainly you can set a different event handler to run when an event occurs. 
23:10:21 <taotree> Eduard_Munteanu, that's what I had originally. As I was working with it, though, I discovered duplicate code and figured this control structure removes that duplication
23:10:55 <ClaudiusMaximus> taotree: i did somethign like that in some javascript code ( http://claudiusmaximus.goto10.org/g/compass/konstrukt/konstrukt3.svg )
23:10:56 <taotree> Now I have a general purpose toggle thing I can use
23:11:24 <taotree> I'm kind of bugged that you can't call widgetDelEvents after something is realized, though. I was hoping to turn that off and on, too
23:11:52 <taotree> and the doc doesn't mention that limitation
23:16:16 <ClaudiusMaximus> latest output from my haskell >> http://claudiusmaximus.goto10.org/g/mandelbrot/renormalized-distance-estimate-ascii.png right hand side is regular distance estimate, left hand side is distance estimate after renormalization (making the hairiness shaved off)
23:19:22 * hackagebot htime 0.1 - Timing utility for the command line  http://hackage.haskell.org/package/htime-0.1 (JosePedroMagalhaes)
23:36:54 <Eduard_Munteanu> taotree: you might want to try signalBlock from System.Glib.Signals
