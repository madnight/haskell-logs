00:06:22 * hackagebot marxup 1.0.0 - Markup language preprocessor for Haskell  http://hackage.haskell.org/package/marxup-1.0.0 (JeanPhilippeBernardy)
00:06:55 <taotree> Eduard_Munteanu, what are you suggesting signalBlock for? It won't affect the performance gains I was hoping by widgetDelEvents
00:07:45 <Eduard_Munteanu> taotree: just turning off your handler
00:09:00 <sopvop> Hello everyone. Is there a better way to write (+) here http://hpaste.org/44297/vectors ?
00:13:32 <Ptival> can someone explain me what's wrong with this? > http://hpaste.org/44298/
00:20:02 <taotree> Eduard_Munteanu, I think signalDisconnect does that for me. I'm not sure signalBlock would be better for what I'm working with.
00:21:44 <Eduard_Munteanu> Ptival: you need to lift, and twice, in the second
00:28:24 <Ptival> Eduard_Munteanu > I don't understand completely, I should lift tell twice?
00:29:14 <Eduard_Munteanu> Ptival: yes. Note Writer is wrapped in two layers of transformers.
00:29:33 <Ptival> ok
00:30:21 <Eduard_Munteanu> The error also hints you to that. It tells you 'tell' can't be used at that level.
00:30:32 <Eduard_Munteanu> Since it applies to ErrorT there.
00:31:23 <Ptival> ok, my understanding of transformers wasn't good enough
00:32:51 <osfameron> Ptival: they're robots in disguise.  That's all you need to understand really.
00:33:03 <Eduard_Munteanu> :t runErrorT
00:33:04 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
00:33:05 <Ptival> so I can throwError as is, but I need to lift get/put and lift twice tell...
00:34:00 <Ptival> osfameron: I don't understand
00:34:13 <Eduard_Munteanu> Yes.
00:34:30 <Eduard_Munteanu> Monad transformers aren't totally like combined monads.
00:35:05 <Eduard_Munteanu> That is, you need to 'lift', it's not all there at the same level.
00:35:08 <Ptival> yeah that's what I assumed
00:35:30 <Eduard_Munteanu> @src RWST
00:35:31 <lambdabot> Source not found. My mind is going. I can feel it.
00:35:39 <Eduard_Munteanu> :t runRWST
00:35:41 <lambdabot> forall r w s (m :: * -> *) a. RWST r w s m a -> r -> s -> m (a, s, w)
00:35:49 <aristid> lol. RWST.
00:35:53 <Eduard_Munteanu> That's a combined one.
00:35:57 <aristid> i know
00:36:04 <Ptival> actually I don't understand this type:
00:36:06 <aristid> it's a pretty wild combination tho
00:36:07 <Ptival> lift tell :: (MonadWriter w m, MonadTrans t) => t ((->) w) (m ())
00:36:10 <Eduard_Munteanu> aristid: I know you know, I wasn't telling you :)
00:36:53 <aristid> :t tell
00:36:54 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
00:37:05 <aristid> Ptival: you forgot to pass a value to tell before lifting it
00:37:11 <aristid> Ptival: lift (tell v) would be correct
00:37:15 <Ptival> ok
00:37:52 <aristid> now in theory lift tell is valid, too, but i don't think it's what you want
00:38:31 <Eduard_Munteanu> Or composition style, lift . tell . foo $ ...
00:38:57 <Eduard_Munteanu> :t lift . tell . show
00:38:58 <lambdabot>     Ambiguous occurrence `lift'
00:38:58 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
00:38:58 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
00:39:18 <Eduard_Munteanu> Ah, FFS, not that crappy error again.
00:40:00 <aristid> :t Control.Monad.Error.lift . tell. show
00:40:01 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *) a. (Control.Monad.Error.MonadTrans t, MonadWriter String m, Show a) => a -> t m ()
00:40:08 <Jafet> Logic Error
00:40:45 <Eduard_Munteanu> @quote hmm..
00:40:46 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
00:40:49 <Ptival> when I lift . lift . tell $ s ++ show Foo, I get a "No instance for (Error Value) in the first argument of (.) namely lift" :\
00:41:00 <Eduard_Munteanu> @quote hmm.module
00:41:01 <lambdabot> No quotes match. I am sorry.
00:41:24 <Eduard_Munteanu> (might not be there)
00:46:09 <Ptival> :t Control.Monad.Error.lift
00:46:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
00:46:36 <Eduard_Munteanu> :k ErrorT
00:46:37 <lambdabot> * -> (* -> *) -> * -> *
00:47:46 <jonkri> i find it hard to interpret the arm-related cells on http://hackage.haskell.org/trac/ghc/wiki/Platforms. do you think i would run into any problems getting my haskell/ghc app to run on a http://beagleboard.org/? should i consider some other compiler? any general advice?
00:54:07 <aristid> Ptival: note that lift is not actually from Control.Monad.Error. it's just that lambdabot is a bit confused there
00:54:17 <aristid> :t Control.Monad.Trans.lift
00:54:18 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
00:55:10 <Ptival> aristid: hum thanks, I think I got confused too
00:56:43 <Ptival> aristid: actually, are they different?
00:57:21 <aristid> no
00:57:37 <aristid> Ptival: Control.Monad.Error just re-exports the "real" one
00:57:45 <Ptival> yeah that's what I just read
00:57:46 <aristid> @index lift
00:57:46 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
00:57:47 <lambdabot> ParserCombinators.ReadPrec, Text.Read
00:57:57 <aristid> @hoogle lift
00:57:57 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
00:57:58 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
00:57:58 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
00:57:58 <Ptival> anyway, I can't find the right way to fix my code :\
01:00:15 <arnihermann> what does tilde (~) mean in signatures like the following:
01:00:18 <arnihermann> sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) => c1 -> c2 -> c2
01:01:22 <sipa> arnihermann: type equality
01:04:32 <arnihermann> sipa: thanks
01:20:56 <jonkri> how would you strip the surrounding quotations around a string? "\"abc\"" => "abc"
01:22:24 <quicksilver> if it's a haskell string you could use read
01:22:35 <quicksilver> that will also deal with escaped quotes inside it etc
01:22:40 <quicksilver> might not be what you want.
01:26:45 * hackagebot marxup 1.0.0.1 - Markup language preprocessor for Haskell  http://hackage.haskell.org/package/marxup-1.0.0.1 (JeanPhilippeBernardy)
01:32:16 <aristid> @time lambdabot
01:32:16 <lambdabot> I live on the internet, do you expect me to have a local time?
01:36:13 <Ptival> I can't get it right... http://hpaste.org/44299/lifting
01:36:13 <fabjan> @time fabjan 
01:36:16 <lambdabot> Local time for fabjan is Fri Feb 25 11:08:07 2011
01:36:57 <quicksilver> Ptival: why are you trying to use lift at all?
01:37:27 <Ptival> because that's what I've been told to try earlier :s
01:37:34 <quicksilver> anyhow "No instance for (Error Value) " is the problem.
01:37:42 <quicksilver> ErrorT needs Error instances to be a monad.
01:38:05 <quicksilver> you don't need to use lift with tell because tell is 'magically' pre-lifted - that's the point of the MonadWriter class.
01:38:45 <quicksilver> you can just write "instance Error Value where "
01:38:47 <quicksilver> (empty instance)
01:39:40 <Ptival> oh right
01:41:09 <quicksilver> the Error instance is so it knows what to do with 'fail "blah"' and 'mzero'
01:41:29 <quicksilver> if you're never going to use those then a vacuous instance is fine.
01:43:42 <Ptival> hum ok, I just want to use throwError and catchError, with the error being a Value
01:44:08 <Ptival> thanks
02:23:03 <sipa> @pl \f x -> f x
02:23:04 <lambdabot> id
02:36:26 <sipa> ghc: panic! (the 'impossible' happened)
02:36:27 <sipa>   (GHC version 6.12.1 for x86_64-unknown-linux):
02:36:27 <sipa> 	genDerivBinds: bad derived class base:GHC.Base.Monad{tc 28}
02:37:04 <sipa> do i report that somewhere?
02:43:41 <HugoDaniel> hi
02:43:53 <HugoDaniel> how do i transform a (a,b) type into a (a,b,c) type ?
02:44:02 <gienah> sipa: http://hackage.haskell.org/trac/ghc/ticket/3833
02:44:14 <HugoDaniel> oh \(a,b) c -> (a,b,c)
02:44:15 <HugoDaniel> not this
02:44:35 <HugoDaniel> i want to transform a n-tuple into a (n+k)-tuple
02:44:42 <HugoDaniel> is there any way to "append" a new type to a tuple ?
02:48:45 <dabblego> is there a package that is a good example of the use of the failure package?
02:52:12 <ezyang> HugoDaniel: you could always do (OldType, n1, n2, n3 ...) 
02:52:17 <fabjan> HugoDaniel: you want to take a tuple of any size and add an element?
02:52:28 <HugoDaniel> fabjan, yes
02:52:39 <HugoDaniel> ezyang, let me try that
02:52:49 <fabjan> I don't think you can have functions like that in Haskell
02:53:02 <HugoDaniel> i could also wrap my type in a datatype with a type var and add it in a list
02:53:09 <HugoDaniel> like the hdbc guys do
02:53:49 <HugoDaniel> im trying to write a monad instance to a datatype "Function a"
02:54:54 <HugoDaniel> the thing is that i want the return to always deliver a "Function FunctionResult"
02:55:50 <HugoDaniel> but that doesn't seem to be the "right" way, since i am not giving much use to the typevar
02:56:23 <HugoDaniel> meh, ill just code it and paste it
02:56:45 <HugoDaniel> im not very good at explaining myself in english
02:58:00 <Fuco> I've grabbed the haskell-mode for emacs from http://code.haskell.org/haskellmode-emacs/, but most of the stuff doesn't work or compleatly breaks emacs... is this mode not supported anymore?
02:58:30 <Fuco> for instance doing C-c C-t to show type disables RET... (error: Symbol's function definition is void: incf)
02:58:37 <Fuco> intendation doesn't work at all as well
03:15:33 <jonkri> i find it hard to interpret the arm-related cells on http://hackage.haskell.org/trac/ghc/wiki/Platforms. do you think i would run into any problems getting my haskell/ghc app to run on a http://beagleboard.org/? should i consider some other compiler? any general advice?
03:16:34 <quicksilver> jonkri: GHC/ARM works, but it's unregisterised which means relatively slow.
03:16:41 <quicksilver> for certain tasks that may not matter.
03:17:07 <quicksilver> jonkri: JHC works on ARM quite well, I believe, but within the limits of JHC - it can't compile large programs.
03:19:54 <Jhn> 2
03:20:05 <Jhn> @ 2
03:20:50 <Jhn> @ 2*2
03:22:35 <jonkri> quicksilver: thanks. could you elaborate a bit on "relatively slow"? :)
03:23:11 <jonkri> i'm developing an xmpp-based file server
03:23:24 <quicksilver> jonkri: not really :) It's hard to make it precise.
03:23:34 <quicksilver> jonkri: that doesn't sound like it would be CPU-bound, so you probably don't need to care.
03:23:44 <Jhn> @run 2
03:23:45 <lambdabot>   2
03:23:59 <jonkri> thanks :)
03:36:09 <jonkri> quicksilver: the jhc user manual doesn't say anything about the fact that it can't compile large programs as far as i can see... why is it limited on arm?
03:39:37 <augustss> jonkri: jhc is limited on all platforms
03:43:30 <sipa> gienah: it remains, even with generalized newtype deriving enabled
03:44:47 <gienah> sipa: I guess an obvious thing to try is ghc 7.0.1 or 6.12.3
04:23:53 <hygge> newbie question: in an else-clause, how does indentation work? i get a parse error if i have else then two lines as [space space] stm
04:24:27 <Cale> You should indent it like:
04:24:30 <Cale> if foo
04:24:31 <Cale>    then bar
04:24:34 <Cale>    else quux
04:24:45 <Cale> With the important thing being that 'then' and 'else' line up.
04:24:53 <Cale> and are more indented than 'if'
04:24:59 <hygge> but say i have a quux2?
04:25:02 <Cale> hm?
04:25:17 <hygge> i wanna call two functions 
04:25:19 <Cale> There are only 3 parts to an if expression. :)
04:25:20 <hygge> in the else
04:25:42 <Cale> Like  f (g x) ?
04:25:52 <hygge> im actually in a do-monad-block so thats why i want to line up my functions
04:26:08 <Cale> Oh, then you might want to start a do-block inside your else branch?
04:26:11 <Cale> if foo
04:26:15 <Cale>    then bar
04:26:21 <Cale>    else do quux1
04:26:26 <Cale>            quux2
04:26:40 <hygge> ok another do! i see
04:26:51 <Cale> The if expression is still just an expression
04:26:53 <Zao> else (quux1 >> quux2) -- lol
04:26:53 <hygge> a do inside an do?
04:27:00 <silver_> yeah
04:27:02 <Zao> hygge: Xzibit would be proud.
04:27:08 <Cale> Or you could do what Zao is saying
04:27:24 <pozic> > do do do putStrLn "do?"
04:27:25 <lambdabot>   <IO ()>
04:27:30 <Cale> hygge: do-expressions just glue together actions into larger actions
04:27:39 <hygge> yep
04:27:44 <hygge> ok
04:27:51 <hygge> so do's can be nestled. didnt know that
04:27:53 <pozic> > do do putChar 'a';do do return ()
04:27:53 <Cale> So you can put a do-block wherever you could have put an action
04:27:54 <hygge> will try
04:27:54 <lambdabot>   <IO ()>
04:28:39 <hygge> perfect. thanks guys
04:29:31 <tim__> Hey all, just wondering - has anyone else had  issues installing hmatrix on ubuntu? 'cabal configure' step fails as Distribution.Simple.Configure.maybeGetPersistBuildConfig returns Nothing yet the dist/setup-config file exists! Any idea what might be causing this?
04:30:36 <dcoutts> tim__: it still happens after cabal clean?
04:31:31 * ManateeLazyCat After mix C/C++/Java Python elisp Haskell in head, I still love Haskell, so simple, so abstract ... everybody should learn Haskell. :)
04:31:33 <tim__> dcoutts: yep!
04:31:48 <ManateeLazyCat> dcoutts: Hi, long time no see, how are you? ;p
04:31:52 <dark> maybe False (const True) , is there a standard function that does that?
04:31:59 <dark> :t maybe False (const True)
04:32:00 <lambdabot> forall a. Maybe a -> Bool
04:32:02 <tim__> dcoutts: which is rather confusing, as 'cabal clean' *removes* the file that that function tests for
04:32:09 <dark> @hoogle Maybe a -> Bool
04:32:10 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
04:32:10 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
04:32:10 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
04:32:59 <dark> (ok, isJust)
04:33:56 <dcoutts> tim__: right
04:35:09 <dark> is there a standard function that does \x y -> Data.Maybe.isJust $ lookup x y ?
04:35:29 <dark> @hoogle (Eq a1) => a1 -> [(a1, a)] -> Bool
04:35:30 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
04:35:30 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
04:35:30 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
04:35:44 <dark> @pl \x y -> Data.Maybe.isJust $ lookup x y
04:35:45 <lambdabot> (Data.Maybe.isJust .) . lookup
04:37:26 <dabblego> elem a . map fst
04:37:30 <dabblego> \a -> elem a . map fst
04:37:34 <quicksilver> dark: any ((==y).fst) x
04:38:10 <ManateeLazyCat> quicksilver: Hi. :)
04:38:20 <dark> why (==y) and not (y==) ? (seems to be the same, and people seems to prefer the former)
04:38:52 <dark> :t any
04:38:52 <quicksilver> not sure. I tend to write (+2) and (*3).
04:38:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
04:38:58 <quicksilver> ManateeLazyCat: hello
04:39:02 <dark> :t elem
04:39:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:39:44 <dark> is it considered 'better' to not wrap into Maybe and then escape from it?
04:39:47 <tim__> dcoutts: the excerpt from configure.hs that causes the error is here http://hpaste.org/44302/tim_cowlishaw
04:40:16 <tim__> but maybeGetPersistBuildConfig returns Nothing despite the file existing
04:42:29 <bicilotti> http://pastebin.com/ZJFUf0Wc <-- basic function (string to int) . Where's my error?
04:42:49 <bicilotti> (it doesn't recognise "-543", e.g.)
04:44:41 <tim__> aha! it looks it's a cabal version problem:  "Exception: user error (You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.8.0.6, now Cabal-1.10.0.0).)"
04:44:41 <dcoutts> tim__: so it's not just the file existence, it has to parse it
04:45:09 <tim__> dcoutts: aah ok, will take a look! I think I'm getting there. Thanks!
04:46:20 <ManateeLazyCat> Damn it, another user report gtk2hs failed on Windows.
04:46:28 <ManateeLazyCat> And gtk2hs site failed still.
04:46:39 <ManateeLazyCat> I need find time to fix gtk2hs site and Windows Installer.
04:46:54 <ManateeLazyCat> Windows can't install gtk2hs if haven't Installer.
04:50:10 <Entroacceptor> bicilotti: think about it
04:50:26 <Entroacceptor> '-' is the first char
04:50:50 <Entroacceptor> so b in fun is 0
04:51:28 <bicilotti> gracis Entroacceptor 
04:53:36 <Entroacceptor> try asIntf "12-3" :)
04:54:38 <siracusa> ManateeLazyCat: Hi! You need help testing gtk2hs on Windows?
04:55:15 <ManateeLazyCat> siracusa: No, i buy new computer to support VT technology, so i can run Windows in VirtualBox.
04:55:40 <ManateeLazyCat> siracusa: I need find some time to re-build gtk2hs site and provide a OneClick Windows Installer.
04:55:45 <ManateeLazyCat> siracusa: Just so busy now. :)
04:55:55 <ManateeLazyCat> siracusa: It's sad that gtk2hs site down.
04:56:09 <dark> @type filterM
04:56:10 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:58:06 <ManateeLazyCat> siracusa: Gtk2hs is good, but Gtk2hs Windows Installer is not good, infact is Gtk2hs' windows support is bad!  
04:59:10 <siracusa> ManateeLazyCat: But the darcs version builds fine on Windows?
04:59:18 <ManateeLazyCat> siracusa: I don't know.
04:59:23 <ManateeLazyCat> siracusa: I know Linux is fine.
04:59:43 <ManateeLazyCat> siracusa: Worse is gtk2hs site is down.
05:00:42 <ManateeLazyCat> siracusa: I'm so busy on Android and Python work, i think maybe next month i have time. :)
05:02:20 <dark> ManateeLazyCat, one can use python with android? so python compiles to its weird vm (dalvik?)?
05:02:43 <dark> or is there a python interpreter for that. or it just uses cpython?
05:02:59 <ManateeLazyCat> dark: No, i use Jave develop Android application, and use Python for build a Chinese Linux release version.
05:03:11 <dark> oh
05:03:24 <dark> but one couldn't use python? what about c++?
05:03:50 <dark> http://arstechnica.com/open-source/news/2009/06/android-goes-beyond-java-gains-native-cc-dev-kit.ars well hm
05:03:51 <ManateeLazyCat> dark: I think C/C++ can run on Android through NDK.
05:04:10 <ManateeLazyCat> dark: But you know, Android wrap many code on dalvik
05:04:25 <ManateeLazyCat> dark: Now, C++ perhaps just can use as library language.
05:04:32 <dark> "The NDK does not provide access to platform framework APIs."
05:05:08 <ManateeLazyCat> dark: IMO, Java still is most handy language for Android develop.
05:05:16 <dark> "Google says that native code should be used sparingly and is not appropriate for the vast majority of third-party Android applications. The company also points out that using it could reduce portability and have other negative consequences."
05:05:46 <dark> but using java have negative consequences as well
05:06:07 <ManateeLazyCat> dark: Yes, Google build framework you *must* follow, we can't change much on those.
05:06:09 <dark> but there is also this Android Scripting Environment
05:06:09 <ManateeLazyCat> :(
05:06:48 <bicilotti> Entroacceptor: thanks again for the tip, I found a solution. ( http://pastebin.com/dEx87rFA ) Do you think there is a simpler way to achieve that?
05:07:13 <ManateeLazyCat> dark: Infact, i think Google do good job on Java framework, API is easy to learn and use.... :)
05:07:14 <Entroacceptor> "read" ;)
05:07:47 <Entroacceptor> but your solution looks ok
05:08:07 <ManateeLazyCat> Entroacceptor: How do you do? :)
05:08:10 <bicilotti> thanks, since I'm moving my firsts steps in haskell, I'd like to be concise
05:08:32 <Entroacceptor> but I'm a newbie, too
05:08:42 <ManateeLazyCat> Just say hello with friends, i haven't login #haskell so long time.
05:08:46 <Entroacceptor> maybe you can make a one-liner out of it
05:08:49 <Entroacceptor> hi ManateeLazyCat  :)
05:08:56 <ManateeLazyCat> Entroacceptor: Hi. :)
05:09:53 <Entroacceptor> I'm not doing enough haskell
05:10:10 <dark> bicilotti, i'm sure that being clearer should come first (and your solution seems clear enough)
05:10:56 <Entroacceptor> ManateeLazyCat: how's manatee coming along?
05:11:00 <bicilotti> very good, very good dark
05:11:18 <ManateeLazyCat> Entroacceptor: I will rewrite many modules in next version.
05:11:47 <dark> i haven't liked this: foldl fun 0 xs vs foldl fun 0 (x:xs) but I see no other way for removing the -, using the code structure you have
05:11:51 <ManateeLazyCat> Entroacceptor: Include Clean input framework, and window framework to fix compatible with XMOnad.
05:12:20 <dark> I would try to make: asIntf (x:xs) is - (asIntf xs) for x = '-'
05:12:37 <ManateeLazyCat> Entroacceptor: Multiple manatee can running concurrent, very sub-module support command line, such as "manatee-browser http://www.google.com" etc..
05:12:42 <dark> but this have the ugly consequence of letting --1 being +1
05:13:01 <Entroacceptor> which would be ok, arguably :)
05:13:14 <ManateeLazyCat> Save/Restore framework to make you can work continue even shutdown/restart it.
05:13:16 <dark> so your solution seems more correct :P
05:13:24 <bicilotti> \o/
05:13:32 <ManateeLazyCat> Entroacceptor: And you know, next is IDE
05:13:55 <ManateeLazyCat> Entroacceptor: I haven't write haskell almost two month.
05:14:18 <ManateeLazyCat> Entroacceptor: Busy on look for job, lucky, i found one Android job.
05:14:24 <Entroacceptor> ah, congrats
05:15:16 <ManateeLazyCat> Entroacceptor: So i can continue to work on Manatee, though time is not too much, but now I can contribute to lasting
05:18:13 <ManateeLazyCat> I haven't receive any patches for Manatee recently, that's mean Manatee still not good enough, anyway, i will continue, hope haskeller can help me. 
05:46:39 * hackagebot hxt 9.1.0 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.1.0 (UweSchmidt)
05:47:39 * hackagebot hxt-charproperties 9.1.0 - Character properties and classes for XML and Unicode  http://hackage.haskell.org/package/hxt-charproperties-9.1.0 (UweSchmidt)
05:48:40 * hackagebot hxt-curl 9.1.0 - LibCurl interface for HXT  http://hackage.haskell.org/package/hxt-curl-9.1.0 (UweSchmidt)
05:50:40 * hackagebot hxt-expat 9.1.0 - Expat parser for HXT  http://hackage.haskell.org/package/hxt-expat-9.1.0 (UweSchmidt)
05:50:42 * hackagebot hxt-http 9.1.0 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.0 (UweSchmidt)
05:50:44 * hackagebot hxt-relaxng 9.1.0 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.0 (UweSchmidt)
05:50:46 * hackagebot hxt-tagsoup 9.1.0 - TagSoup parser for HXT  http://hackage.haskell.org/package/hxt-tagsoup-9.1.0 (UweSchmidt)
05:51:40 * hackagebot hxt-unicode 9.0.1 - Unicode en-/decoding functions for utf8, iso-latin-* and other encodings  http://hackage.haskell.org/package/hxt-unicode-9.0.1 (UweSchmidt)
05:51:48 <dark> How can I link to source code within haddock? Like the link 'source' at all definitions at hackage. (I'm looking http://www.haskell.org/haddock/doc/html/index.html but I can't find)
05:52:20 <dark> I think http://www.haskell.org/haddock/doc/html/ch03s08.html#id566045 puts inline code, not links to the source code itself
05:53:29 <dark> I mean like http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/src/Text-Parsec-Error.html#errorPos linked by http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec.html
05:53:40 * hackagebot hxt-xpath 9.1.0 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-9.1.0 (UweSchmidt)
05:53:42 * hackagebot hxt-xslt 9.1.0 - The XSLT modules for HXT.  http://hackage.haskell.org/package/hxt-xslt-9.1.0 (UweSchmidt)
06:07:01 <sipa> is there a haskell extension somewhere that extends the default-types rule for Num->Int and Float->Double to arbitrary types?
06:08:05 <copumpkin> no
06:08:22 <Saizan> arbitrary classes you mean?
06:08:33 <sipa> ah, there is a proposal here: http://hackage.haskell.org/trac/haskell-prime/wiki/Defaulting
06:08:38 <sipa> but it's not implemented anywhere
06:08:45 <sipa> ?
06:10:56 <quicksilver> there are four proposals on that page
06:10:58 * quicksilver likes Proposal 4 - remove defaulting
06:13:28 <doserj> at least, make the the default default default (). (Now, who could parse this sentence...)
06:14:49 <quicksilver> It seems to me that () is a poor default. It's such an atypical type.
06:14:54 <quicksilver> @check \a b -> a == b
06:14:55 <lambdabot>   "OK, passed 500 tests."
06:15:21 <doserj> quicksilver: default (), not default (())
06:15:42 <sipa> he means, by default, the list of default types defined should be empty
06:15:44 <quicksilver> ah.
06:16:00 <quicksilver> add me to the least of people who couldn't parse your sentence, please.
06:16:17 <doserj> done :)
06:16:59 <copumpkin> if you add a "to" to it
06:17:04 <copumpkin> I'd be able to parse it
06:17:14 <copumpkin> make the default default default to ()
06:17:35 <copumpkin> the double the confuses it though
06:18:22 <doserj> ups, yeah, didn't notice the "the the" (see, I added quotation marks to make it easier!)
06:19:49 <copumpkin> http://www.reddit.com/user/the-the
06:27:02 <dcoutts> tim_: any luck
06:27:59 <dcoutts> tim_: ah I know
06:30:07 <Heffalump> perhaps Void would be a good default
06:30:21 <sipa> :k Void
06:30:23 <lambdabot> Not in scope: type constructor or class `Void'
06:31:06 <Heffalump> it's not a standard type, but it's just data Void, i.e no non-bottom values at all
06:33:18 <b52> http://npaste.de/yk/ could someone explain me why the result isnt ["foo", "bar"] ?
06:33:29 <b52> I dont understand the result :/
06:35:20 <quicksilver> b52: [:blank:] matches, colons, bs, ls, as, ns, and ks,.
06:35:32 <quicksilver> b52: in your case it matched the "ba" of "bar"
06:35:39 <quicksilver> which is composed entirely of bs and as.
06:36:29 <quicksilver> b52: you want [[:blank:]]
06:36:36 <quicksilver> (a common mistake with posix character classes ;)
06:38:56 <dcoutts> tim_: I'm emailing the hmatrix maintainer, I can cc you if you give me an email address.
06:44:26 <wires> what is known about visualizing functional programs, similar in concept to ER diagrams, UML, call flows, protocols... I know about vacuum (have not gotten it to run nicely under os x), but I have not really thought about how to use it on a high level. Any links?
06:45:08 <b52> hmm, is setSocketOption broken?
06:45:20 <tim_> dcoutts: thanks, that'd be great! I'm tim@timcowlishaw.co.uk
06:45:33 <dcoutts> tim_: ok
06:45:33 <b52> setSocketOption ctrl RecvTimeOut 5
06:45:45 <b52> setSocketOption: invalid argument (Invalid argument)
06:45:49 <b52> :/
06:46:14 <tim_> dcoutts: got it to install eventually after downgrading cabal-dev to 7.1
06:46:39 <dcoutts> tim_: ah, I have another solution for you then
06:46:51 <tim_> dcoutts: it's got something to do with the discrepancy between cabal-install depending on Cabal 1.8.0.6, and cabal-dev depending on 1.10.0.0
06:47:51 <dcoutts> tim_: see the email I just sent, the flaw is in assumptions the hmatrix Setup.hs + configure are making
06:48:05 <tim_> dcoutts: aah. just got it. thanks so much for your help!
06:48:07 <dcoutts> tim_: a workaround would be to hide Cabal-1.10.0.0
06:50:17 <tim_> dcoutts: aah, that's a good idea. I'll re-upgrade my cabal-dev install and give it a go
07:01:17 <b52> none an ieda?
07:05:47 <hygge> hi again
07:05:49 <roconnor> the *> operation in the Haskell for Maths isn't the applicative operation is it?
07:06:01 <aristid> :t (*>)
07:06:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
07:06:20 <hpc> @src (*>)
07:06:20 <lambdabot> (*>) = liftA2 (const id)
07:06:20 <aristid> oh, (*>) is just generalized (>>)
07:06:31 <hygge> another newbie question: once i have used a do block, can i ever return something (from that function) that is not a monadic?
07:06:43 <aristid> hygge: it depends on which Monad
07:07:05 <roconnor> hygge: you can pass a do block to another function
07:07:19 <roconnor> > runIdentity (do return 5)
07:07:20 <lambdabot>   5
07:07:25 <hpc> > do {1;2;3;4;} 5
07:07:26 <lambdabot>   <no location info>: parse error on input `5'
07:07:31 <hpc> > (do {1;2;3;4;}) 5
07:07:32 <lambdabot>   4
07:07:36 <aristid> > do return 5 :: Maybe Int
07:07:37 <lambdabot>   Just 5
07:07:48 <Jonno_FTW> @src take
07:07:48 <lambdabot> take n _      | n <= 0 =  []
07:07:48 <lambdabot> take _ []              =  []
07:07:48 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
07:07:50 <aristid> hpc: wtf?
07:07:54 <aristid> oh right
07:08:07 <hpc> i love lambdabot
07:08:15 <aristid> :t do {1;2;3;4;}
07:08:16 <lambdabot> forall (m :: * -> *) a b a1 a2. (Monad m, Num (m a), Num (m a1), Num (m a2), Num (m b)) => m b
07:08:22 <roconnor> caleskell!!1
07:08:47 <aristid> hpc: and as soon as you use it as a function, the Num a => Num (e -> a) instance kicks in
07:08:47 <hpc> i love the extraneous type variables
07:09:01 <Jafet> I'm not sure if cale would approve of that instance
07:09:14 <roconnor> I thought Cale made that instance
07:09:17 <hygge> i want this function http://hpaste.org/44307/escape_monad to "escape" from its monad... my monad works sort of like the Maybe/Just-monad.
07:09:22 <Jafet> It's imported from vector-space
07:09:23 <aristid> it's from vector-spaces, iirc
07:09:27 <roconnor> :O
07:09:45 <Jafet> A package full of other mindscrew, judging from the haddock
07:09:47 <aristid> but this instances gives a lot of entertainment to #haskell
07:10:49 <roconnor> > deriv (4 . id) x
07:10:51 <lambdabot>   0
07:11:23 <roconnor> > deriv (4 . 5 . 6) x
07:11:24 <lambdabot>   0
07:11:37 <hpc> hygge: enough is wrong with that function that i would say to just start over
07:11:46 <hpc> for one, you are missing an argument
07:11:52 <hpc> i think
07:11:59 <Ke> @type deriv
07:12:00 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
07:12:12 <hygge> hpc: yes i know. its not finnished yet
07:12:13 <hpc> and i don't know how you want to get from your mystery monad to Bool
07:12:23 <aristid> :t deriv
07:12:24 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
07:12:27 <pngl> I am learning Haskell, and a complete beginner. There's something I want to make I understand. In Learn you a Haskell for great good, Chap.7, section Data.Map: doesn't the findKey version that uses foldr do useless processing by going through the whole list instead of stopping once a value is found?
07:12:33 <aristid> @hoogle deriv
07:12:34 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
07:12:43 <aristid> roconnor: where is deriv from?
07:12:48 <roconnor> > deriv (sin . tan) x
07:12:50 <lambdabot>   (1 * cos x * recip (cos x) + sin x * negate (1 * negate (sin x) * recip (co...
07:12:52 <aristid> :t id
07:12:53 <lambdabot> forall a. a -> a
07:12:56 <aristid> :t deriv id
07:12:56 <lambdabot> forall a. (Num a) => a -> a
07:12:57 <roconnor> aristid: numbers
07:13:14 <aristid> ah, so it's not edwardk's stuff :D
07:13:42 <aristid> > deriv sin x
07:13:43 <lambdabot>   1 * cos x
07:13:48 <aristid> > deriv sin 5
07:13:48 <lambdabot>   0.28366218546322625
07:13:57 <aristid> > cos 5
07:13:58 <lambdabot>   0.28366218546322625
07:14:02 <hpc> @hoogle deriv
07:14:02 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
07:14:14 <hpc> huh
07:14:35 <aristid> > deriv (sin * cos) x
07:14:36 <lambdabot>   1 * cos x * cos x + sin x * (1 * negate (sin x))
07:14:37 <hpc> that looks like what my bot does on foonetic only not rpn
07:14:53 <Jonno_FTW> > deriv (sin / cos ) x
07:14:54 <lambdabot>   1 * cos x * recip (cos x) + sin x * negate (1 * negate (sin x) * recip (cos...
07:14:55 <hpc> and magic, apparently
07:15:10 <aristid> > length $ show (deriv (sin / cos ) x)
07:15:11 <lambdabot>   95
07:15:18 <Jonno_FTW> > deriv (cos  / sin ) x
07:15:19 <lambdabot>   1 * negate (sin x) * recip (sin x) + cos x * negate (1 * cos x * recip (sin...
07:15:26 <Jonno_FTW> shouldn't taht be tan x?
07:15:31 <roconnor> hpc: no magic.  Just haskell
07:15:43 <hpc> :P
07:15:52 <hpc> referring to how it uses Num
07:15:54 <roconnor> Jonno_FTW: that is cos/sin = cot
07:16:02 <Jonno_FTW> oh woops
07:16:11 <quicksilver> pngl: no
07:16:15 <roconnor> hpc, still not magic, just haskell.
07:16:28 <quicksilver> pngl: because of lazy evaluation, when it gets to the case which find the key it never looks at 'acc'
07:16:34 <Jonno_FTW> is there an integral one as well?
07:16:37 <quicksilver> pngl: which means that the rest of the list is never actually traversed.
07:16:43 <quicksilver> pngl: it's an important clever trick.
07:16:53 <hpc> :t foldr
07:16:54 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:17:01 <roconnor> Jonno_FTW: I have one, but it doesn't work symbolically, and is incrediably slow.
07:18:23 <pngl> quicksilver: Doesn't "Just v" become the new acc at the next iteration?
07:18:55 <quicksilver> pngl: no
07:19:03 <quicksilver> pngl: the 'acc' is the recursive call to foldr
07:19:22 <quicksilver> pngl: (it takes the place of the recursive call to findKey in the handwritten version which doesn't use foldr)
07:19:37 <hpc> > foldr (+) 0 [1..5]
07:19:38 <lambdabot>   15
07:19:45 <hpc> > foldr (+) x [y,z]
07:19:46 <lambdabot>   y + (z + x)
07:19:48 <Jafet> > tail.dropWhile (/='+') $ drive (sin / cos) x
07:19:49 <lambdabot>   Not in scope: `drive'
07:19:51 <pngl> quicksilver: aha
07:19:52 <pngl> ok
07:19:58 <Jafet> > tail.dropWhile (/='+') $ deriv (sin / cos) x
07:19:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:19:59 <lambdabot>         against inferred ty...
07:20:00 <pngl> thank you
07:20:07 <Jafet> > tail.dropWhile (/='+') .show$ deriv (sin / cos) x
07:20:08 <lambdabot>   " sin x * negate (1 * negate (sin x) * recip (cos x) * recip (cos x))"
07:22:36 <hpc> confession: i still don't entirely grok folds
07:23:02 <ksf> @pl \x y -> (y `mod` x) == 0
07:23:02 <lambdabot> flip flip 0 . ((==) .) . flip mod
07:23:32 <ksf> wait.
07:23:37 <ksf> @pl \x y -> 0 == (y `mod` x)
07:23:37 <lambdabot> ((0 ==) .) . flip mod
07:23:39 <ksf> there.
07:23:53 <Jafet> Heh
07:25:22 <hpc> @src foldr
07:25:22 <lambdabot> foldr f z []     = z
07:25:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:25:40 <hpc> oh!
07:25:44 * hpc sees it now
07:25:48 <hpc> @src foldl'
07:25:48 <lambdabot> foldl' f a []     = a
07:25:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:26:01 <hpc> ick
07:26:03 <hpc> @src foldl
07:26:03 <lambdabot> foldl f z []     = z
07:26:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:26:46 <ClaudiusMaximus> @hoogle scanl'
07:26:46 <lambdabot> No results found
07:28:33 <hpc> @src scanl
07:28:34 <lambdabot> scanl f q ls = q : case ls of
07:28:34 <lambdabot>     []   -> []
07:28:34 <lambdabot>     x:xs -> scanl f (f q x) xs
07:29:10 <hpc> @src scanr'
07:29:10 <lambdabot> Source not found. Do you think like you type?
07:29:12 <applicative> b52, i think you want:  splitRegex (mkRegex "[[:blank:]+]") "foo bar", not splitRegex (mkRegex "[:blank:]+") "foo bar"
07:29:47 <b52> dude ... checkout the timestamp and the answers to that question...
07:30:24 <applicative> oh sorry, i just looked  at the screen , stuck in place
07:30:50 <quicksilver> although I note b52 never acknowledged my answer ;)
07:31:07 <b52> quicksilver: oh yeah, i forgot, thanks for the answer, was very helpful :)
07:31:16 <quicksilver> :)
07:34:37 <applicative> oh i see how i got muddled, b52.  i saw "none an ieda?", and looked back for the unsolved problem, but hit the wrong one.
07:44:47 <b52> yeah but that was to my setSockOption question
07:47:23 <tombee> how does one check whether a string ends in '\n' or not
07:47:42 <tombee> so I want a guard like structure, to check if a string ends in '\n'
07:48:00 <copumpkin> last xs == '\n'
07:48:07 <tombee> ah yes, thanks
07:48:07 <copumpkin> :P
07:48:11 <zygoloid> > last "" == '\n'
07:48:13 <lambdabot>   *Exception: Prelude.last: empty list
07:48:13 <tombee> that's what I was looking for :)
07:48:19 <copumpkin> it's kind of fragile though
07:48:19 <zygoloid> careful now
07:48:46 <zygoloid> last ('x':xs) == '\n' -- the sh way!
07:49:52 <hygge> can a function having a do also have a where-clause (for simple aliases often used in the do-block)?
07:49:55 <mauke> "\n" `isSuffixOf` xs
07:50:08 <mauke> functions don't have a 'do'
07:50:10 <applicative> hygge, yes
07:50:14 <mauke> do BLOCK is an expression
07:50:27 <copumpkin> hygge: yes
07:50:58 <hygge> ok, thx. so i made an error then
07:51:07 <roconnor> @type unfoldr
07:51:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:51:11 <dmwit> > (do {return 1}) 2 -- mauke, well, to be ultra-pedantic, a do-block *can* be a function...
07:51:12 <lambdabot>   1
07:51:14 <applicative> like any where clause, the where needs to be indented properly, and comes after the whole expresssion
07:52:23 <doserj> and with things like "x <- ...", the x is not in scope in the where clause. Typically, it is easier to use let
07:52:53 <roconnor> > (do ask) 2
07:52:54 <lambdabot>   2
07:53:01 <applicative> hygge, can you hpaste the offending definition?  its probably spacing
07:53:28 <quicksilver> zygoloid: (take 1 . reverse) == "\n" perhaps?
07:53:51 <roconnor> > (do {x<-ask; return (succ x)}) 2
07:53:52 <lambdabot>   3
07:54:18 <roconnor> > (do {x<-ask; y<-ask; return (x+y)}) 2
07:54:20 <lambdabot>   4
07:58:41 <dark> http://www.haskell.org/haskellwiki/GHCi_in_colour is there improvements on this?
08:01:51 <byorgey> dark: not that I'm aware of
08:02:35 <dark> do { res <- p; x; return res } is this idiom captured by some combinator?
08:02:50 <rwbarton> :t (*>)
08:02:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:02:54 <Saizan> p <* x
08:02:55 <rwbarton> :t (>*)
08:02:57 <lambdabot> Not in scope: `>*'
08:02:57 <rwbarton> :t (<*)
08:02:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:03:15 <Saizan> from Control.Applicative
08:03:16 <dark> but p is a monad, not applicative! or a parsec parser is also applicative?
08:03:28 <quicksilver> see also the useful comination (y >* p <* x)
08:03:34 <quicksilver> all monads are applicative.
08:03:41 <Saizan> every Monad can be made an Applicative, but parsec parsers should already be
08:03:51 <quicksilver> char '(' *> expression <* char ')'
08:03:51 <fryguybob_>  /query lambdabot
08:03:55 <rostayob> actually I don't think it is
08:03:58 <rostayob> (parsec)
08:03:59 <quicksilver> is quite a common way.
08:04:02 <rwbarton> yeah, at least it didn't use to be
08:04:04 <rostayob> at least it wasn't when I used it
08:04:06 <dark> is this automatic? functor isn't automatically derived from monad..
08:04:09 <quicksilver> rostayob: it is as of version something or other.
08:04:12 <hpc> @src (*>)
08:04:12 <lambdabot> (*>) = liftA2 (const id)
08:04:16 <rostayob> quicksilver: oh, ok
08:04:26 <hpc> s/A/M/ if you are really desperate
08:04:28 <quicksilver> dark: no, none of the classes are automatic.
08:04:32 <quicksilver> but they are trivial to write.
08:04:46 <rostayob> I mean the Text.ParserCombinators parsec is not applicative, I think
08:04:52 <quicksilver> instance Applicative (.....) where pure = return; (<*>) = ap
08:04:53 <hpc> :info Set
08:05:01 <hpc> bah
08:05:12 <dark> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Prim.html ok it is applicative
08:05:13 <Saizan> if you're writing a polymorphic function with a Monad m => context than you won't be able to use Applicative methods, but for specific cases that doesn't matter
08:05:34 <dark> Saizan, why not?
08:05:55 <quicksilver> Saizan: and if you're writing the function, it's normally no great problem to generalise the signature to (Monad m,Applicative m) =>
08:06:09 <quicksilver> unless you're trapped in a network of pre-existing APIs.
08:06:24 <hpc> and if you are trapped in a pre-existing API, being more specific won't kill you
08:06:44 <Saizan> dark: because it'll just look up if there's an Applicative instance for your specific type
08:06:45 <byorgey> a mazy of twisty pre-existing APIs, all alike?
08:07:01 <quicksilver> quite ;)
08:08:03 <roconnor> @ask edwardk what happend to the Lens transformers?
08:08:04 <lambdabot> Consider it noted.
08:08:05 <dark> but, why (Monad m, Functor m, Applicative m) => is needed, if "monads are applicative"? it should be set up in a way that (Monad m) really imply Functor and Applicative..
08:08:18 <byorgey> dark: you are right, it should.  but it isn't.
08:08:26 <byorgey> for hysterical raisins.
08:08:33 <dark> historical* ?
08:08:42 <hpc> historical reasons, except not very good ones
08:08:42 <hpc> :P
08:09:14 <roconnor> @hoogle <.>
08:09:15 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
08:09:15 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
08:09:48 <byorgey> dark: http://www.catb.org/jargon/html/H/hysterical-reasons.html
08:10:28 <hpc> type FilePath = String
08:10:59 <hpc> @src (<.>)
08:11:00 <lambdabot> Source not found. You untyped fool!
08:11:05 <b52> hmm, is setSocketOption broken (Network.Socket)
08:11:13 <b52> setSocketOption ctrl RecvTimeOut 5
08:11:24 <b52> setSocketOption: invalid argument (Invalid argument)
08:13:50 <dark> should haskell' get rid of this backwards compatibility, and then split the community in two like perl6 and python3?
08:14:54 <dark> i think a more elegant solution would be 'if the code specifies Monad and Applicative, ok; if not, build up automatically the Applicative instance'. except someone here said it isn't a good idea
08:15:03 <Tau> if a function is receiving a Int and returning a Float and i'm doing (x+y)/2 
08:15:08 <Tau> where x and y are Ints
08:15:13 <Tau> what should i do to make it work
08:15:28 <dark> put a fromIntegral $ i think
08:15:44 <Tau> dark, can you explain me how that works
08:15:54 <Tau> i mean, the 'fromIntegral'
08:15:54 <applicative> dark, i have a keybinding, or rather tab trigger, that writes instance Applicative % where pure = return; (<*>) = ap leaving the cursor at %
08:16:01 <roconnor> dark: Haskell is missing a good way to add superclass support.  There have been some proposals, good ones even.
08:16:39 <dark> :t fromIntegral
08:16:39 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:16:58 <dark> Tau, it is like a type-safe cast, that's how I see it
08:17:26 <Tau> i see.
08:17:31 <maurer_> roconnor: What's wrong with just using Overlapping Instances to accomplish this?
08:17:43 <dark> Float is part of Num and Int is part of Integral
08:18:11 <hpc> Integral is part of Num too, i think
08:18:17 <hpc> er
08:18:19 <hpc> Int
08:18:19 <dark> but hm if you want float division you need to cast x and y before doing the division I think
08:18:33 * hpc is being an idiot
08:18:46 <dark> yes so fromIntegral could cast Int to Int I guess but it can also cast Int to Float
08:19:18 <quicksilver> maybe Tau actually wanted integer division?
08:19:25 <hpc> :t div
08:19:26 <lambdabot> forall a. (Integral a) => a -> a -> a
08:19:28 <quicksilver> in which case (x + y) `div` 2 is what he wants.
08:19:30 <hpc> :t (/)
08:19:30 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:19:33 <hpc> :t (//)
08:19:34 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
08:20:32 <Tau> quicksilver, no , just floating division.
08:20:35 <Tau> but, i have fixed it.
08:20:53 <Tau> i'm feeling a bit weird at conversion of numbers.
08:21:05 <Tau> cause it doesn't convert automatically from ints to floats etc.
08:23:46 <dark> I think that the language shouldn't let the user define his own Applicative when there is already a Monad. The equivalence between some Applicative and Monad code is is yet another thing that is promised but doesn't show up at the types (so you can't rely on it like you rely on statically verified properties)
08:24:22 <dark> Tau, that's because the types are actually different, and haskell employs strong typing (no automatic cast)
08:24:37 <dark> unlike, say, C
08:24:57 <Saizan> dark: sometimes defining <*> manually you can get an optimized version
08:25:13 <Saizan> same reason we've (>>) in Monad
08:25:28 <Tau> dark, yea. i see.
08:26:28 <mux> dark: and what about the case where you only have one meaningful (as in, respects the monad laws) Monad instance but several possible Applicative ones? (eg lists)
08:26:29 <Saizan> also, Applicative came later than Monad in the stdlib, so it hasn't had a chance to influence Monad so far :)
08:26:59 <dark> mux, hm o.o
08:27:01 <Saizan> mux: you use newtypes for the Applicative instances that don't agree with the Monad one
08:27:37 <mux> Saizan: of course you use newtypes; the point is that you cannot always rely on the "default" Applicative instance that comes from the Monad instance
08:27:39 <Saizan> (you need to use newtypes anyway for all except one of the Applicative [] instances)
08:28:33 <Saizan> mux: dark was explicitly asking for some way to guarantee that's the one chosen
08:28:47 <mux> I guess I'm missing some context..
08:29:09 * dark is sure he is missing some background on this subject
08:29:55 <tombee> is there an easy way of turning [1,2,3,4,5] into "1 2 3 4 5"
08:30:03 <tombee> [Int] -> [Char]
08:30:15 <tombee> or should one write a separate function for that?
08:30:18 <dark> the monad laws are another thing that you often rely without knowing if they are being followed. I resent having lots of things like this, outside the type system (but I have no idea on how to encode Monad properties in the type system though)
08:30:36 <dark> tombee, there is interleave for adding the spaces
08:30:56 <tombee> dark thanks!
08:31:01 <mux> you most likely need a much more powerful type system for that, such as dependent typing
08:31:10 <dark> :t interleave
08:31:11 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
08:31:39 <Saizan> > intercalate ' ' . map show $ [1..5]
08:31:41 <lambdabot>   Couldn't match expected type `[a]'
08:31:41 <lambdabot>         against inferred type `GHC.Types...
08:31:48 <Saizan> > intercalate " " . map show $ [1..5]
08:31:49 <dark> I meant intercalate
08:31:50 <lambdabot>   "1 2 3 4 5"
08:31:55 <inad922> Hello
08:31:58 <tombee> ahh
08:32:25 <inad922> Is there a way to write scripts in haskell like in some scripting language like python or do I always need to compile the code?
08:32:26 * dark used it today, chunk h = intercalate "\n" $ ..
08:32:51 <dark> inad922, there is runhaskell
08:32:53 <maurer_1> inad922: The "runhaskell" command will run it
08:33:01 <inad922> thanks dark maurer_1 
08:36:25 <tombee> dark why is the $ required? :)
08:37:04 <applicative> tombee, in intercalate " " . map show $ [1..5]  ?
08:37:17 <tombee> yes 
08:37:44 <tombee> i understood the $ was syntactic sugar for brackets around the statement to the right of it
08:37:45 <applicative> it collects like so (intercalate " " . map show) 
08:38:20 <applicative> its just an infix operator with low precedence so things on either side tend to hang together
08:38:35 <tombee> ahah gotcha, I understand now kind of
08:38:58 <tombee> I was thinking it was just collecting map show, rather the entire left hand side
08:39:27 <tombee> (intercalate " "  (map show ys))
08:39:30 <applicative> he composed map show with intercalate " "
08:39:32 <tombee> its equivalent of something like that
08:40:06 <dark> tomaw, it was intercalate "\n" $ line h, the same as intercalate "\n" (line h). for the Saizan code, a $ b c $ d is a . b c $ d but not a . b c d o.o
08:40:25 <applicative> without the $ he'd have c*omposed* map show [1..5] with intercalate " " which doesn't makes sense
08:40:35 <dark> a . b c d is a . (b c d), a . b c $ d is (a . b c) d
08:41:05 <tombee> perfect, thanks :)
08:42:31 <applicative> > map (+1) . filter even . map read . words $ "11 12 13"
08:42:33 <lambdabot>   [13]
08:42:49 * dark is often confused by . at the code and is actually unsure if what he said was correct
08:43:03 <dark> > map (+1) $ filter even $ map read $ words "11 12 13"
08:43:04 <lambdabot>   [13]
08:43:34 <applicative> let foo = map (+1) . filter even . map read . words in foo "12 13 15"
08:43:44 <applicative> > let foo = map (+1) . filter even . map read . words in foo "12 13 15"
08:43:46 <lambdabot>   [13]
08:43:51 <dark> I once had this option, using .'s and $ at the end, or using $'s and nothing at the end; i found the second more readable (because I often can't understand code with .)
08:44:38 <tombee> Yes . and $ are kind of confusing, I'm sure you get used to how they are used though with more experience
08:44:45 <applicative> yes, it's okay that way, but you can't abstract a $ b $ c from a $ b $ c $ d, where are a . b . c is a unit in a . b . c $ d
08:44:54 <tombee> () fit in with conventional languages :)
08:45:07 <applicative> yes, it's just a little practice, I wish $ weren't so ugly
08:46:01 <dark> $ is fine imo :d I was trying once to find another symbol for it, maybe | ? there aren't many options
08:46:20 <hpc> | by itself is reserved
08:46:34 <monochrom> || is taken. you may like |||
08:46:40 <Tau> are you all professional haskell programmers ?
08:46:43 <hpc> :t (|||)
08:46:44 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
08:46:47 <hpc> lol
08:46:50 <monochrom> oh oops, ||||
08:47:04 <applicative> but there's the point that the $ is reused for application like things e.g. fmap as <$>
08:47:37 <monochrom> then use |||| and <||||>
08:47:38 <dark> Tau, me? just learning
08:47:56 <Tau> hum.
08:48:11 <Tau> me too.
08:48:24 <Tau> i came from c and python.
08:48:34 <hpc> composition becomes much easier after you had a math course take an entire chapter on composition
08:48:34 <Tau> i found some troubles in type conversion.
08:48:48 <applicative> and for strict application, i'll use |||!
08:48:48 <Tau> i always forget it has a strong typing system.
08:48:51 <dark> and in fact I may use haskell for my own projects and whatnot but I don't expect to get a haskell job anytime soon :P
08:49:20 <Tau> i'm doing just for fun.
08:49:26 <Tau> and learning purposes.
08:50:06 <hpc> out of the 700 people in here atm, i would guess that maybe 20 have haskell jobs
08:50:07 <applicative> my sense is that people have less trouble with composition than with the order: it seems it should follow the sequence of things happening
08:50:09 <hpc> max
08:50:30 <Fuco> this seems like a really good choice for an operator: <||||>
08:51:10 <tg__> a 4D wall?
08:51:42 <applicative> maybe for altenative,  a <||||> b means, do a , and if it really really fails and hope is lost then do b
08:53:16 <tg__> like double or?
08:53:35 <tg__> a or a or a or a or a or a ... or b
08:53:37 <tg__> hehe
08:54:53 <Tau> is there some function to delete an element from a list 
08:54:57 <Tau> w
08:54:59 <Tau> ?
08:55:08 <tg__> can't delete something that's immutable
08:55:20 <Tau> like del a[1]
08:55:25 <hpc> you can "delete" it
08:55:32 <hpc> but you are really making a new list with one element missing
08:55:34 <tg__> you can mark it as deleted
08:55:37 <tg__> but yeah
08:55:44 <Tau> hpc, yes
08:55:47 <Tau> how can i do
08:55:57 <hpc> :t delete
08:55:58 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
08:56:02 <hpc> hmm
08:56:02 <Fuco> > let x = [1,2,3] in delete 2 x
08:56:04 <lambdabot>   [1,3]
08:56:15 <hpc> > let x = [1, 3, 2] in delete 2 x
08:56:16 <lambdabot>   [1,3]
08:56:31 <Tau> k
08:56:49 <hpc> that doesn't delete at an index though
08:56:55 <hpc> it deletes the first matching element
08:57:03 <hpc> it shouldn't be too hard to write
08:57:26 <Fuco> yea, a nice excercise :P
08:57:45 <Tau> k
08:57:54 <hpc> my hypothesis is that the Prelude is missing very specific functions, just because they are a nice exercise :P
08:58:23 <Fuco> yea, implement them in terms of foldl for bonus points :D
08:58:57 <hpc> foldl would be bad :P
08:59:04 <hpc> zipWith would have nice strictness
09:16:44 <applicative> > let tau xs n = let (a,b) = splitAt n xs in init a ++ b in "abcdef" `tau` 3
09:16:46 <lambdabot>   "abdef"
09:17:19 <Veinor> wouldn't you want to splitAt n-1 and then a ++ tail b?
09:17:29 <applicative> yeah, i think i would
09:17:41 <applicative> splitAt doesn't work quite like i thought
09:17:59 <Veinor> i mean, in terms of speed, what with init being slow
09:18:03 <hpc> you would also want to write it to avoid using (++) i think
09:18:18 <applicative> oh i see, indeed, that's the main problem i was considering
09:18:33 <applicative> how would i do it with zipWith as hpc was saying
09:19:04 <applicative> or maybe he wasn't talking about that question
09:19:14 <Veinor> i think you'd want to do it with a fold?
09:19:17 <Tau> applicative, k
09:19:39 <applicative> Tau, they think definition is lame!
09:19:43 <applicative> right
09:19:45 <applicative> ly
09:19:59 <Tau> i'm trying for 20 trying to implement an algorithm to order a list.
09:20:59 <Tau> haskell really has a different way of reasoning upon data.
09:21:40 * Tau goes to play some chess
09:21:43 <applicative> Tau, you mean you want to sort a list, as they say? 
09:21:46 <applicative> ah
09:22:13 <c_wraith> Not really *that* different.  You just need to accept that list != array
09:22:17 <c_wraith> but whatever.
09:23:21 <applicative> maybe he should be working with an arrayish type.
09:34:13 <inad922> Is there any "special" version of read so that I don't have to give say :: [Int] and it still does the same?
09:34:18 <inad922> like some readInt?
09:35:21 <c_wraith> inad922: you only need to annotate the return type of read if it can't be inferred
09:35:33 <c_wraith> If it's unambiguous from use what the type is, no annotation is necessary
09:36:01 <Saizan> and if you really want you can make one readInt = read :: String -> Int
09:36:56 <inad922> I don't get this annotation
09:37:11 <inad922> How do I do that? Like when definiing a function?
09:37:35 <inad922> Sorry I'm kinda of a noob in this
09:37:56 <dark> inad922, if f expects an int, then f $ read n will work as expected
09:40:52 <inad922> umm my problem is that I read up a file(which contains only 1 integer on a line) with readFile to say vaiable f and I would like to transform it with "(map read . lines) f" How do I give here that it should be converted to an [Int]?
09:42:32 <dons> yow
09:42:50 <Saizan> inad922: what do you do with the result of that? or are you just playing around in ghci?
09:43:23 <Saizan> inad922: anyhow you can just say ((map read . lines) f :: [Int])
09:44:13 <inad922> Saizan: Ow that works? I mean the code snippet you put there
09:44:57 <Saizan> inad922: yes
09:45:32 <Saizan> > (map read . lines) "1\n2\n3\n4" :: [Int]
09:45:34 <lambdabot>   [1,2,3,4]
09:47:18 <chrisdone> dons: Hey there... just an idea, would it be awesome to have a trac/redmine-type thing on Hackage  when a new package is uploaded it could create a new project with the author as the owner of that project, and people could create tickets for that project. Right now the issue trackers for Hackage projects are basically (1) email, (2) Github, or (3) my-tracker-of-choice-that-may-or-may-not-be-available-in-three-weeks. We could pipe issue update
09:47:18 <chrisdone> s to the IRC. Not necessarily this channel as it could spam, but making the issues with packages public would encourage more people who wouldn't have otherwise known to contribute patches. But I'm still waiting for Hackage 2.0 to come up before thinking more about this kind of thing.
09:47:52 <aristid> chrisdone: github has an integrated issue tracker (admittedly not the best one)
09:48:01 <chrisdone> aristid: That's what I meant by "github" in my message.
09:48:17 <aristid> oh, damn i should have read the whole message *embarrassed*
09:49:06 <aristid> chrisdone: but your message was really long. it takes 10 (!) lines in my irc client
09:50:45 <Saizan> aristid: tl;dr: it'd be nice to have a centralized bug tracker for hackage packages
09:51:09 <chrisdone> Has dev on Hackage2 stalled or are we waiting for migration?
09:51:14 <dankna> Saizan: please no.  at least make it opt-in instead of opt-out.  I have my own bug tracker and I don't want to have to monitor an external one too.
09:51:25 <aristid> saizan: i figured as much by skimming it, but details like the mention of github fell through :)
09:51:34 <Saizan> dankna: i was just going to make that comment :)
09:51:47 * hackagebot attoparsec 0.8.5.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.5.0 (BryanOSullivan)
09:51:47 <dankna> okay, good :)
09:51:53 <chrisdone> dankna: The reverse could be said. I only want to monitor one bug tracker when submitting issues. ;-)
09:52:09 <dankna> chrisdone: I see that, but authors are the ones doing the heavy lifting - they get the priority :)
09:52:13 <chrisdone> (Not one per-project, each probably different, of differing stability)
09:52:31 <inad922> Saizan: Thanks it really works. The error was elsewhere. :)
09:52:54 <dankna> well, yes, but it's the author who has the real need to manage a large bulk of tickets
09:53:13 <dankna> the submitter mostly only needs to monitor in order to get the close-the-loop feel-good feeling
09:53:30 <chrisdone> dankna: I'm sure people said the same when Hackage came out. "I have my own web site to host packages, don't make me upload to two places." Turns out it's actually really great for collaboration when there's a central location of activity.
09:53:34 <dankna> as long as everyone's tracker supports sending opt-in emails on ticket changes
09:53:40 <dankna> well, Hackage is one thing
09:54:09 <dankna> the user is the one whose needs should be optimized for as far as acquiring packages goes
09:54:17 <chrisdone> (There are still many people who just don't upload to Hackage but have quality software, that few people will ever see as they would have otherwise...)
09:54:32 <dankna> oh sure.  Hackage is a great thing.  but bugs are a different issue.
09:54:49 * chrisdone applauds at the pun
09:55:27 <dankna> haha, thanks
09:55:48 * hackagebot aeson 0.2.0.0 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.2.0.0 (BryanOSullivan)
09:56:13 <chrisdone> dankna: From my perspective, I've gone to submit issues to Haskell projects, seen they have their own bug tracker and just not bothered. But that's me. Probably the average Haskeller is more hardcore at making the world right.
09:56:35 <aristid> chrisdone: probably not
09:56:38 <dankna> I get about as many tickets as I can actually handle on my private tracker
09:56:43 <aristid> or he would spend more time writing documentation
09:56:45 <dankna> so from my perspective, more reports would not be useful
09:56:52 <inad922> When I apply a concat of functions on an argument is there any way to avoid parentheses like write "(map read . tail . lines) f" without it?
09:57:02 <aristid> inad922: $
09:57:05 <inad922> ow
09:57:09 <aristid> map read . tail . lines $ f
09:57:16 <dankna> if I were getting virtually no tickets, then I'd agree that something needed to change
09:57:28 <chrisdone> dankna: At any rate, the tracker could just be optional.
09:57:46 <dankna> I want it to not have the ability to file reports on packages that haven't opted in
09:57:57 <dankna> perhaps opting in could be a mostly-automated process
09:58:17 <chrisdone> Tracked: yes
09:58:22 <chrisdone> In the Cabal file, possibly.
09:58:39 <dankna> for example it could integrate with Hackage and uploading a package that lists the Hackage issue tracker as its system creates a module corresponding to the package and version
09:58:54 <dankna> the Cabal file already has a field for a URL associated with the tracker
09:59:04 <dankna> and this would leverage that
09:59:18 <inad922> aristid: Cool! Thanks!
09:59:20 <chrisdone> Sounds good to me.
09:59:29 <dankna> okay, so I think we're agreed on what we should do :)
09:59:30 <Saizan> it'd be quite messy to have this per-version though
09:59:42 <aristid> inad922: haskellers tend to hate parentheses :)
09:59:50 <dankna> Saizan: well, not a module per version - it would have to be a tracker that supports a "version" field
09:59:55 <Saizan> but i guess maintaners would have to avoid being messi like that :)
09:59:59 <dankna> yes
10:01:02 <inad922> aristid: Yeah me too. I really don't consider myself as haskeller yet. What's the exact definition of $ I really can't search it up
10:01:16 <chrisdone> @src ($)
10:01:16 <lambdabot> f $ x = f x
10:01:27 <inad922> aha wow yeah I was stupid again
10:01:32 <inad922> thanks chrisdone 
10:01:43 <chrisdone> np
10:02:00 <aristid> inad922: the whole trick to ($) is that it has really low operator precedence
10:03:00 <c_wraith> > fst $ first (const 10) undefined
10:03:02 <lambdabot>   10
10:03:20 <c_wraith> ok, first is maximally lazy. :)
10:03:48 <inad922> aristid: How can 1 get/set an operator's precedence?
10:03:59 <aristid> inad922: with infixr and infixl
10:04:18 <aristid> that's for setting
10:04:29 <aristid> to introspect it, use :info $ from ghci
10:06:23 <inad922> thanks again aristid
10:39:04 <deech> Hi all, what is the best way of catching an error in an ErrorT monad and re-wrapping the exception to a custom exception type? I have some code up at (http://hpaste.org/44309/io_errort_handling). 
10:39:48 <deech> s/catching an error in an ErrorT monad/catching an error in an ErrorT monad without case matching/
10:39:53 <chrisdone> :t catchError
10:39:54 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
10:40:39 <deech> chrisdone: Yes, but I can't use catchError on (liftIO $ someIOOperation) because the error type it returns is not Errors. 
10:41:06 <deech> I'm trying catch the error without explicit pattern matching. 
10:42:06 <Saizan> you can't write a generic MonadError e1 m1, MonadError e2 m2 => m1 -> m2
10:42:22 <Saizan> even with (e1 -> e2)
10:43:25 <Saizan> ?type \f -> ErrorT . liftM (either f id) . runErrorT
10:43:27 <lambdabot> forall (m :: * -> *) e a a1. (Monad m) => (a1 -> Either e a) -> ErrorT a1 m (Either e a) -> ErrorT e m a
10:43:38 <Saizan> ?type \f -> ErrorT . liftM (f ||| id) . runErrorT
10:43:39 <lambdabot> forall (m :: * -> *) e a b. (Monad m) => (b -> Either e a) -> ErrorT b m (Either e a) -> ErrorT e m a
10:43:44 <Saizan> d'oh
10:43:49 <Saizan> ?type \f -> ErrorT . liftM (f +++ id) . runErrorT
10:43:51 <lambdabot> forall (m :: * -> *) e b b'. (Monad m) => (b -> e) -> ErrorT b m b' -> ErrorT e m b'
10:44:20 <Saizan> exploiting the fact that Either is a bifunctor and (+++) witnesses that
10:44:58 <deech> ?type (+++)
10:44:59 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
10:45:34 <deech> Interesting. That's pretty cool.
10:46:22 <Saizan> taking (a = (->)) you've that (+++) f g = either (Left . f) (Right . g), and of course either is just pattern matching on an Either expressed as a combinator
10:46:49 <Saizan> ?type either
10:46:50 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
10:47:16 <deech> Saizan: That's exactly what I'm doing manually!
10:47:20 * djahandarie notes that this can obviously have the (Functor f) constraint also
10:48:07 <Saizan> yeah you can s/liftM/fmap/ if you prefer Functor m => rather than Monad m =>
10:48:24 <deech> So in from your example function I can do something like this correct: \f -> ErrorT . liftM (f +++ throwError) . runErrorT
10:48:26 <hpc> or (<$>) for infix fun
10:49:06 <Saizan> ?type \f -> ErrorT . liftM (f +++ throwError) . runErrorT
10:49:08 <lambdabot> forall (m :: * -> *) e b b' (m1 :: * -> *) a. (MonadError b' m1, Monad m) => (b -> e) -> ErrorT b m b' -> ErrorT e m (m1 a)
10:49:34 <Saizan> deech: i'm not sure why you'd want that
10:50:13 <Saizan> you'd turn the result 'a' into an action that has 'a' as errors
10:50:40 <deech> Saizan: No it isn't. I basically want to run some operation 'f' that might throw Left (x :: A), catch it and rethrow Left (y :: B).
10:51:18 <deech> I can do it now by pattern matching, but I thought I might be doing extra work when I'm already in the ErrorT monad.
10:51:21 <Saizan> deech: the example in your hpaste would be written as: f = ErrorT . liftM (Errors +++ id) . runErrorT $ liftIO someIOOperation
10:51:57 <deech> Saizan: yes, that's awesome!
10:52:56 <Saizan> which is also equal to f = mapErrorT (liftM (Errors +++ id)) $ liftIO someIOOperation
10:53:00 <Saizan> ?type mapErrorT
10:53:01 <lambdabot> forall (m :: * -> *) e a (n :: * -> *) e' b. (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
10:55:39 <bos> Faster, better, cleaner: new aeson and attoparsec releases: http://www.serpentine.com/blog/2011/02/25/faster-better-cleaner-new-aeson-and-attoparsec-releases/
10:55:51 <jmcarthur> ooh
10:56:01 <djahandarie> Nice!
10:56:47 * djahandarie takes note to encourange bos to work on attoparsec-related things more often ;)
11:01:07 <djahandarie> "Instead of parsing via the Applicative typeclass, we now use a custom parsing monad, improving both ease of use and performance." Wasn't a major point of Applicative to be fast and natural for parsing?
11:02:49 <bos> natural yes, fast no
11:03:23 <bos> by using a concrete type, we avoid accidentally passing typeclass dictionaries, and don't force people to make some choice about which Applicative instance to use
11:04:12 <edwardk> preflex: xseen kmc
11:04:12 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:04:12 <preflex>  kmc was last seen on freenode/#haskell-blah 12 hours, 37 minutes and 26 seconds ago, saying: (to the extent classes even exist in JavaScript)
11:04:14 * hackagebot keys 0.2.2 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.2.2 (EdwardKmett)
11:04:52 <edwardk> @tell roconnor i put them aside for now, mostly because they got in the way of having a decent api, and i still don't have a use for them
11:04:52 <lambdabot> Consider it noted.
11:05:12 <djahandarie> bos, you could avoid the dictionary issues with specialize pragmas couldn't you?
11:05:26 <bos> djahandarie: yeah, but that would be silly
11:05:39 <bos> i'd have to know lots of types that people would be using
11:05:47 <bos> *and* they'd have to inline stuff carefully
11:05:59 <bos> this way, all that falls on my shoulders, which are reasonably capable
11:08:32 <Saizan> you can't specialize just on the functor type?
11:10:59 <bos> only if i know what it is
11:12:35 <aristid> edwardk: what did you put aside?
11:12:52 <edwardk> aristid: lens transformers
11:13:17 <aristid> what's your definition of lens?
11:13:36 <edwardk> aristid: newtype LensT w a b = LensT { a -> StoreT b w a }  where the Lens transformer is a store transformer coalgebra
11:13:52 <edwardk> i left a simpler version (without the T) in comonad-transformers
11:14:05 <aristid> a -> (b, b -> a)?
11:14:10 <edwardk> yeah
11:14:22 <edwardk> getter and setter smashed together
11:14:48 <aristid> i see. i don't really see what the transformer version would be, tho
11:15:07 <edwardk> a -> (b, w (b -> a))
11:15:20 <djahandarie> Haddock should let you click on an instance and automatically fill the function types in with what you clicked on
11:15:20 <aristid> oh, it already IS the transformer version
11:15:25 <edwardk> get still has the same meaning, but put is now a -> w (b -> a)
11:15:37 <aristid> i translated the StoreT but ignored the T :D
11:15:40 <edwardk> =)
11:16:17 <edwardk> while the lenses generalize in this direction, the api becomes a little more ugly
11:16:40 <aristid> and while lenses are useful, lens transformers are totally useless?
11:16:43 <edwardk> you'd ideally like b -> a -> a  to be the setter, that way way you can compose them, and partially apply them easily
11:16:46 <edwardk> not sure
11:16:57 <aristid> i know that lenses are useful
11:17:00 <edwardk> but with the lens transformer version you wind up having to flip that
11:17:34 <aristid> with pure lenses you can also do (a -> b, b -> a -> a), which is a bit clearer IMHO
11:17:50 <edwardk> yes, but it risks doing more work
11:18:00 <edwardk> it is actually equivalent up to isomorphism
11:18:19 <edwardk> but the work to get the b and to find where to stitch the b back in can wind up duplicated
11:18:21 <aristid> including bottoms?
11:18:34 <aristid> but i get that doesn't really matter where the bottoms are, there :D
11:18:36 <edwardk> yes, as long as you use the lazy store.
11:18:38 <aristid> -get+guess
11:19:04 <edwardk> if you use the strict store you start twiddling bottoms a bit differently
11:19:28 <edwardk> http://hackage.haskell.org/packages/archive/comonad-transformers/1.5.2.2/doc/html/Data-Lens-Common.html  is the implementation of the basic api
11:19:44 <edwardk> with refinements to the state monad: http://hackage.haskell.org/packages/archive/comonad-transformers/1.5.2.2/doc/html/Data-Lens-Lazy.html
11:20:01 <edwardk> or any monadstate instance: http://hackage.haskell.org/packages/archive/comonads-fd/1.5.2.2/doc/html/Data-Lens.html
11:21:08 <aristid> uncurry lens :D
11:21:31 <edwardk> blech
11:21:56 <edwardk> i don't tuple anything i don't have to =P
11:22:57 <edwardk> one nice thing is you can make strict put, modify, etc. out of these lenses
11:23:13 <bicilotti_> http://pastebin.com/M5NzTrA7 <-- simple program. if I try elemAt' "foo" 8 gives me error, but I'd expect a []. Any hint?
11:23:44 <aristid> edwardk: but Lense doesn't really seem to belong in comonad-transformers
11:23:47 <edwardk> which is why i have so many (!)'d variants on the various infix combinators
11:23:56 <aristid> it's not even a Comonad!
11:23:58 <bicilotti_> sorry, found out...
11:24:11 <aristid> and it seems to be particularly useful with StateT, which is a Monad
11:24:22 <edwardk> aristid: correct. i was originally going to package it separately, but then it becomes two packages, one haskell 98, and the other 'fd'd
11:24:44 <bicilotti_> meh capital letters
11:24:57 <aristid> edwardk: there are a couple competing lense packages (fclabels, lenses...)
11:25:08 <edwardk> i'm still debating about putting the lens transformers back in, if i do, the motivation will be stronger for it to be present in transformers
11:25:09 <edwardk> sure
11:25:22 <edwardk> but none of them are 98.
11:25:27 <aristid> maybe it's nice to have LenseT, but have Lense not be based on it
11:26:00 <edwardk> also, while data-accessor has the nicest surface api, its base implementation is shit.
11:26:05 <mauke> did you mean: lens
11:26:10 <aristid> edwardk: for completeness sake you should also add your own record field accessor library :P
11:26:16 <aristid> mauke: possibly
11:26:19 <edwardk> aristid: =)
11:26:31 <edwardk> aristid: i was looking at cloning the template haskell plumbing
11:26:43 <edwardk> but i mostly offered this up so that roconnor would have something to go with his paper
11:26:47 <aristid> fclabels never works for me :/
11:27:00 <aristid> i guess i'm too stupid to use it :D
11:27:23 <aristid> edwardk: "this" being lenses themselves? or the template haskell plumbing?
11:27:34 <edwardk> fclabels has the problem that it requires mtl all the way down, data-accessor has a bunch of henningisms and the needlessly wrong implementation as a state coalgebra which uses _undefined_ to define get.
11:27:51 <edwardk> this being the Data.Lens module here
11:28:18 <edwardk> i deliberately avoided trompling any third-party lens/functional-reference/accessor library's namespace
11:29:43 <edwardk> Data.Lenses is defined in a disturbingly oblique manner as well. i wanted a lens set that i could provide a semigroupoid instance for, but i can't use any of the third party versions without orphans, and the performance bugs me
11:30:31 <edwardk> plus i mostly started writing this to see what the transformers would mean ;)
11:30:40 <edwardk> sadly, they turn the api a bit side-ways
11:31:36 <aristid> maybe the transformers version is the more natural one and you just have the wrong taste
11:31:45 <Philippa> has anyone else here run across the book "Categories for Software Engineering"?
11:31:51 <edwardk> transformers version?
11:31:58 <aristid> edwardk: LenseT
11:32:08 <edwardk> ah the one i mentioned above. possibly.
11:32:12 <Philippa> It's definitely not a classic CS category theory book, but if I were employed at reasonable rate I'd probably take the hit anyway
11:32:19 <edwardk> this is why i left open the possibility that i'd reintroduce them
11:33:01 <edwardk> i want an actual usecase first though
12:07:02 <aristid> oh, Compose is actually in transformers
12:07:25 <b52> hmm, is setSocketOption broken (Network.Socket) ?
12:09:47 <inad922> Is there a way to automatically read in a line and convert it to some other type than String?
12:10:14 <chrisdone> > read "1" :: Int
12:10:15 <lambdabot>   1
12:10:43 <inad922> umm but how does this read from a handle like a file or cli?
12:10:56 <maurer_1> inad922: Which do you want to read from?
12:11:00 <inad922> cli
12:11:03 <handonson> I can't install cabal-install for GHC 7.0.1.
12:11:07 <chrisdone> :t fmap read getLine
12:11:07 <lambdabot> forall a. (Read a) => IO a
12:11:12 <mauke> chrisdone: readLn is superior
12:11:12 <handonson> Apparently this is the problem. http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg18744.html
12:11:21 <inad922> ow so its fmap
12:11:26 <inad922> thanks chrisdone 
12:11:32 <maurer_1> handonson: I have a patched HTTP
12:11:34 <maurer_1> One sec
12:11:39 <handonson> no, not HTTP.
12:12:11 <chrisdone> inad922: Wouldn't really recommend it, though. If it doesn't parse you get an exception.
12:12:14 <maurer_1> handonson: In any case, I have a yackage server I've been using to deal with GHC7 being differenter, and I have built cabal-install
12:12:33 <handonson> Please read further. The cabal-install itself is broken. (and there's no new release of cabal-install since.)
12:12:36 <chrisdone> inad922: Better is Safe.readMay or some such. Returns Read a => Maybe a
12:13:09 <chrisdone> mauke: readLn always seemed like a pointless function considering the problem above.
12:13:25 <mauke> chrisdone: readLn throws exceptions you can actually catch
12:13:43 <inad922> chrisdone: I guess the Maybe version is better practice and I'll check that, but for now I just want to submit something to spoj.pl :)
12:13:43 <hpc> :t readLn
12:13:44 <lambdabot> forall a. (Read a) => IO a
12:13:53 <maurer_1> handonson: Which cabal-install are you trying to install? The one on hackage? The one in darcs?
12:14:00 <fryguybob> b52: Can you paste some code that reproduces the problem you are having?
12:14:03 <handonson> The problem is, I really don't want to install darcs just in order to get the dev version of cabal-install
12:14:12 <fryguybob> @hpaste
12:14:13 <lambdabot> Haskell pastebin: http://hpaste.org/
12:14:13 <chrisdone> Oh, if there's Perl involved then all bets are off.
12:14:15 <handonson> maurer_1: http://haskell.org/cabal/download.html
12:14:16 <hpc> readLn seems like it would only really be helpful for pipes
12:14:23 <mauke> chrisdone: ...
12:14:31 <mauke> welcome to the internet, enjoy your poland
12:15:32 <maurer_1> handonson: OK, testing build on my system.
12:16:51 <b52> fryguybob: http://npaste.de/yl/
12:17:05 <maurer_1> handonson: My best guess is that you have a Cabal/cabal-install version mismatch.
12:17:19 <handonson> nah.
12:18:04 <handonson> Distribution/Client/IndexUtils.hs:80:9:
12:18:04 <handonson>     Couldn't match expected type `Maybe InstalledPackageIndex.PackageIndex' with actual type `InstalledPackageIndex.PackageIndex'
12:18:37 <maurer_1> Yes, but clearly that worked at some point or it wouldn't have been released...
12:18:59 <handonson> This doesn't look like a version problem... oh, wait. It does.
12:19:21 <maurer_1> Take heart though, it _is_ possible.
12:19:23 <maurer_1> maurer@daemon:~$ cabal --version
12:19:23 <maurer_1> cabal-install version 0.8.2
12:19:23 <maurer_1> using version 1.8.0.6 of the Cabal library 
12:19:23 <maurer_1> maurer@daemon:~$ ghc --version
12:19:23 <maurer_1> The Glorious Glasgow Haskell Compilation System, version 7.1.20110222
12:19:23 <maurer_1> maurer@daemon:~$ 
12:19:34 <fryguybob> b52: What ghc version are you running?
12:19:52 <handonson> maybe the type signature of getInstalledPackages (in Cabal) has changed at some point
12:20:00 <maurer_1> handonson: That is what I was suggesting.
12:20:07 <maurer_1> Try 1.8.0.6, what I've got working.
12:20:15 <b52> Version: 6.12.1-13
12:20:21 <inad922> Hmm why doesnt  "let x = fmap read hGetLine stdin" work?
12:20:34 <mauke> inad922: because fmap only takes 2 arguments, not 3
12:20:39 <hpc> :t fmap read
12:20:40 <lambdabot> forall a (f :: * -> *). (Read a, Functor f) => f String -> f a
12:20:51 <inad922> well ok with parentheses 
12:20:59 <hpc> fmap read (hGetLine stdin)
12:21:01 <inad922> I mean fmap read (hGetLine stdin)
12:21:03 <hpc> or fmap read getLine
12:21:03 <maurer_1> inad922: That works, but "x" then has type IO Thing"
12:21:08 <hpc> or read <$> getLine
12:21:13 <mauke> or readLn
12:21:24 <hpc> @src readLn
12:21:25 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
12:21:36 <hpc> @src readIO
12:21:36 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:22:30 <maurer_1> inad922: Until you figure out how monads work, might I suggest you use something like http://hpaste.org/44313/read_integer
12:22:45 <mauke> figuring out how monads work is unrelated
12:22:50 <maurer_1> inad922: fmap, <$>, etc are all things for doing fancy things with monadic actions.
12:23:04 <mauke> this is about IO
12:23:04 * hpc imagines "monads, how do they work?" meme
12:23:07 <fryguybob> b52: What OS?
12:23:08 <mauke> maurer_1: what is readLine?
12:23:12 <b52> debian5
12:23:18 <chrisdone> You might as well just use readLn. The point in suggestion fmap read getLine is that it follows naturally into the pattern of transforming a value from the getLine action and at some point reading it.
12:23:25 <maurer_1> mauke, inad922: Oops, meant getLine
12:23:28 <maurer_1> My bad.
12:23:41 <mauke> inad922: which problem are you trying to solve?
12:24:09 <inad922> maurer_1: That's the current version
12:24:21 <inad922> maurer_1: I would like to make it shorter
12:24:57 <inad922> mauke: The factorial 1. I just use those to learn haskell
12:25:03 <maurer_1> inad922: In that case, they are right to suggest fmap or <$>, but if you are trying to write "let x = fmap read getLine", I'm going to question whether you know what fmap does, or what the IO monad does.
12:25:09 <mauke> inad922: which factorial 1?
12:25:23 <mauke> s/the IO monad/IO/
12:25:36 <inad922> maurer_1: More or less. So I guess no...
12:25:37 <handonson> Okay, made cabal-install work, by.... changing the source code. Hope this doesn't break anything in future...
12:25:40 <fryguybob> b52: It looks like it just calls into setsockopt, I suppose you could see if you get the same behavior from C.
12:25:40 <inad922> mauke: http://www.spoj.pl/problems/FCTRL2/
12:25:55 <mauke> ah
12:26:01 <maurer_1> handonson: Try using the modded one ot bootstrap yourself into the original one.
12:26:08 <maurer_1> handonson: e.g. "cabal install cabal-install"
12:26:13 <mauke> inad922: that can be done with interact
12:26:22 <mauke> actually, I'd totally solve this with interact
12:26:32 <handonson> maurer_1: sounds right. i'm on my way.
12:26:41 <inad922> mauke: Yea ok but that's not really my goal..
12:26:54 <mauke> aww
12:26:58 <maurer_1> inad922: What's wrong with interact?
12:27:20 <hpc> interact is cool, but stateless
12:27:29 <inad922> maurer_1: I already know how to use it.
12:28:25 <mauke> then I'd use readLn + mapM_
12:28:46 <hpc> > readLn + mapM_ -- amidoingitrite?
12:28:47 <lambdabot>   Couldn't match expected type `GHC.Types.IO a'
12:28:47 <lambdabot>         against inferred type...
12:28:57 <maurer_1> inad922: One idiom I use sometimes is fmap (map read . lines) hGetContents, but others will say this makes me a bad person
12:29:25 <hpc> maurer_1: that's evil but i like it
12:30:02 <hpc> especially if you do it on say, a config file
12:30:09 <inad922> maurer_1: Is there a simple explanation who fmap read (hGetLine stdin) doesn't work or can you point me to a good tutorial on fmap?
12:30:12 <hpc> each line is a haskell value
12:30:25 <handonson> dammit, cabal-install is downgrading Cabal to 1.8!
12:30:25 <mauke> inad922: uh, it works fine
12:30:37 <mauke> inad922: why do you think it doesn't?
12:30:53 <maurer_1> fmap read (hGetLine stdin) works fine. The reason it didn't work for you was because you bound it in a let, and never used a <- to pull the value out of the IO monad
12:30:55 <inad922> mauke: tried and doesn't compile
12:31:07 <mauke> inad922: compiles fine
12:31:40 <maurer_1> handonson: Yes, as I mentioned, cabal-install _really_ wants to build against 1.8.0.6 at the moment.
12:32:03 <maurer_1> They'll probably catch up around the time that GHC7 gets a Platform release.
12:32:51 <maurer_1> Out of curiosity, what features of new Cabal are you looking to use?
12:32:54 <maurer_1> Test stanzas?
12:34:35 <inad922> mauke: yea now with "fmap read (hGetLine stdin) :: IO Int"
12:37:22 <maurer_1> Ah, so if you don't do something with the result of the computation, it doesn't know which read instance to use, thus why typesigning it helped you.
12:42:30 <yaxu> hi all, I'm having problems with the twitter package...  cabal install twitter works fine, but when I try "ghci Web.Twitter" it says "Could not find module `Web.Twitter'"
12:42:51 <yaxu> I tried wiping ~/.ghci and ~/.clutter and reinstalling my modules to no avail
12:43:58 <yaxu> the ~/.cabal/bin/twitter binary seems fine, but the library doesn't appear to have installed
12:45:20 <maurer_1> yaxu: Did you maybe mean hs-twitter?
12:45:43 <maurer_1> The twitter package is listed as an app, and hs-twitter is listed as API bindings
12:45:58 <yaxu> ah!
12:46:31 <allbery_b> if a program is segfaulting in base_ForeignziCziString_zdwa_info, ... what is the _zdwa_info?
12:46:46 <yaxu> thanks maurer_1, feeling stupid now :)
12:47:10 <allbery_b> (no backtrace so I have no clue aside from that I obviously botched my foreign import...)
12:48:01 <maurer_1> allbery_b: zdwa is part of the name mangling.
12:48:03 <allbery_b> yaxu, one oddity of cabal is you can't have libraries and programs in the same package, so they would need to be separate packages.  (I don't know why the program doesn't use the library, though)
12:48:12 <maurer_1> allery_b: A lie.
12:48:23 <maurer_1> Look at stanzas
12:48:25 <yaxu> hm, installing hs-twitter hasn't helped
12:49:23 <aristid> yaxu: to load an installed module, you don't invoke ghci Module.Name
12:49:35 <aristid> instead, you start ghc, and then +m +Module.Name
12:49:35 <maurer_1> yaxu: Type ":m Web.Twitter" at the ghci prompt
12:49:37 <maurer_1> What do you get?
12:49:39 <aristid> *ghci
12:50:25 <yaxu> Could not find module `Web.Twitter': it is not a module in the current program, or in any known package.
12:50:27 <maurer_1> ghc-pkg dump | grep Web.Twitter
12:51:04 <maurer_1> Err, shit, I've gotta go. Sorry. aristid might not know what's up though.
12:51:26 <maurer_1> err, I meant "might know"
12:51:35 <yaxu> ghc-pkg says Web.Twitter is exposed
12:51:40 <yaxu> np thanks maurer_1
12:54:12 <aristid> yaxu: did you restart ghci?
12:54:23 <aristid> yaxu: when you install new modules, you need to restart ghci :)
12:55:00 <yaxu> aristid: I did :)
12:55:33 <aristid> yaxu: and what does ghci -package hs-twitter say?
12:56:08 <yaxu> aristid: ah, some very interesting things about shadowing and unusable packages, thanks!
12:56:22 <aristid> so there are some funny problems
12:57:55 <yaxu> doing ghc-pkg unregister hs-twitter seems to have fixed it by unregistering the broken one
12:58:09 <yaxu> ace, thanks a lot
13:03:46 <allbery_b> *sigh* this is my day in a nutshell
13:16:36 <scooty-puff> given a case expression
13:16:44 <scooty-puff> for each possible match to an Int type
13:16:49 <scooty-puff> does it scale linearly?
13:17:25 <scooty-puff> i would hope for a binary search to be performed instead, but for the current style of code i'm using, linear would make that style more worthwhile
13:18:08 <edwardk> scootypuff: it is probably pretty dumb about doing lots of integer matches. if they were separate constructors, it'd be a big jump table.
13:18:51 <edwardk> but then again, marlow sneaks all sorts of crazy optimizations in there for odds and ends like this
13:19:37 <aristid> how sneaky
13:20:27 <edwardk> dunno. my mental haskell parser stack overflows around the 20th or 30th argument to a function, so its not very good at handling marlow code ;)
13:25:59 <scooty-puff> the big reason for the question
13:26:09 <scooty-puff> is in the either monad, doing
13:26:17 <scooty-puff> failable1 <|> failable2 <|> ...
13:26:31 <c_wraith> @instances Alternative
13:26:32 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
13:26:35 <aristid> that's more like the Either Alternative
13:26:41 <scooty-puff> right
13:26:42 <c_wraith> @instances-importing Control.Applicative Alternative
13:26:43 <lambdabot> Either e, ErrorT e m, Maybe, ReaderT r m, StateT s m, WrappedMonad m, WriterT w m, []
13:26:59 <aristid> scooty-puff: but what's your question?
13:26:59 <scooty-puff> anyways, each one does a single pattern match
13:27:10 <scooty-puff> if i really cared about performance
13:27:10 <edwardk> scooty-puff: yep
13:27:20 <scooty-puff> would that result in at best linear to each failable?
13:27:28 <aristid> yes.
13:27:39 <aristid> well, maybe the compiler can optimize it away
13:27:45 <edwardk> but i wouldn't count on it
13:27:47 <aristid> i don't know if GHC is _that_ smart
13:27:52 <scooty-puff> ok
13:33:05 <inad922> Whats the best way to deal with problems which needs arrays to solve them like linear algebra and stuff like that?
13:33:16 <inad922> needs -> need
13:33:30 <revenantphx> inad922: example?
13:33:37 <revenantphx> that's a really broad set of problems, heh.
13:33:50 <inad922> Jordan normal form of a matrix in haskell?
13:33:57 <inad922> or gauss elimination
13:34:21 * revenantphx hasn't taken a linear algebra course.
13:34:24 <inad922> or just use interfaces of C libraries?
13:34:28 <revenantphx> I'm not sure what's involved in those...
13:34:33 <revenantphx> how do you evaluate them?
13:34:50 <Saizan> inad922: there are bindings like hmatrix
13:34:52 <monochrom> there are some vector and/or matrix packages on hackage
13:34:58 <inad922> in gauss you just swap rows and delete add elements in rows
13:35:07 <revenantphx> @hackage matrix
13:35:07 <lambdabot> http://hackage.haskell.org/package/matrix
13:35:09 <revenantphx> er
13:35:13 <revenantphx> it's not a search is it
13:35:16 <revenantphx> anyhow, there are a bunch
13:35:18 <Saizan> no
13:35:28 <revenantphx> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=matrix
13:35:54 <revenantphx> http://hackage.haskell.org/packages/archive/Vec/0.9.8/doc/html/Data-Vec-LinAlg.html
13:35:57 <revenantphx> looks relevant.
13:36:03 <monochrom> the "vector" packages mean efficient array
13:36:13 <revenantphx> It even has a gaussElim function in there.
13:36:14 <revenantphx> :P
13:36:43 <revenantphx> and a a normalize function
13:36:53 <inad922> cool. Does hoogle search hackage as well?
13:37:10 <monochrom> no
13:37:45 <revenantphx> thats a pretty scary instance there
13:37:53 <revenantphx> (Fractional a, Map (:. a r) r (:. (:. a r) rs) rs_, Map r (:. a r) rs_ (:. (:. a r) rs), Pivot a (:. (:. a r) (:. (:. a r) rs)), GaussElim a rs_) => GaussElim a (:. (:. a r) (:. (:. a r) rs))
13:38:05 <inad922> lol
13:38:22 <inad922> yea I guess these kind of problems are not meant to be solved in this language
13:38:26 <monochrom> hahaha
13:38:35 <revenantphx> well, it looks like that signature could be easilt cleaned up
13:38:46 <revenantphx> alias (:. a r) as 't'
13:38:56 <revenantphx> and (:. t rs) as 'u'
13:39:06 <revenantphx> and it comes out to be not so bad.
13:41:08 <yaxu> after all that it seems hs-twitter is out of date with twitter oauth, ah well
13:42:07 <Veinor> yaxu: https://github.com/veinor/askitter
13:42:15 <Veinor> i should work on that some more
13:42:22 <Veinor> but it has basic functionality!
13:43:08 <roconnor> @type (\f x -> pure f <*> x)
13:43:09 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
13:43:45 <roconnor> If f is applicitive, dos the free theorems say that that has to be equal to fmap?
13:43:45 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
13:44:24 <roconnor> maybe not
13:44:29 <roconnor> though
13:44:54 <roconnor> if pure and ap satify the applicative laws
13:45:11 <roconnor> maybe that implies that (\f x -> pure f <*> x) = fmap
13:45:37 <yaxu> Veinor: thanks, I'll take a look
13:45:48 <monochrom> wait, an applicative is required to be an applicative functor, that is, a functor in the first place, is that right?
13:46:12 <roconnor> monochrom: right but it part of that requrirement is that (\f x -> pure f <*> x) = fmap
13:46:46 <roconnor> monochrom: however, I think if you prove the other applicative laws, then free theorems imply that  (\f x -> pure f <*> x) must be equivalent to fmap
13:47:18 <monochrom> I see.
13:49:02 <roconnor> monochrom: my proofs become a lot shorter if I can simply omit them :)
13:49:49 <Veinor> @quote leaks
13:49:49 <lambdabot> lilac says: linux kernel modules in haskell: now your gigabyte space leaks are in kernel mode!
13:49:51 <roconnor> pure (f . g) <*> x 
13:49:53 <Veinor> @quote leaks
13:49:53 <djahandarie> > undefined < 5
13:49:53 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
13:49:54 <lambdabot>   *Exception: Prelude.undefined
13:52:52 <roconnor> http://hpaste.org/44315/applicative_implies_functor
13:53:36 <gaze__> hey, is there a function that just does nothing in a monadic context? Just something with Monad m => m ()
13:53:51 <thoughtpolice> return ()
13:53:52 <thoughtpolice> ?
13:54:08 <Saizan> roconnor: nice
13:54:19 <djahandarie> gaze__, note, that would actually be a value, not a function. :-)
13:54:30 <roconnor> Saizan: one less thing to prove
13:54:40 <gaze__> oh... durr... thanks haha
13:55:18 <roconnor> @src guard
13:55:19 <lambdabot> guard True  =  return ()
13:55:19 <lambdabot> guard False =  mzero
13:55:36 <djahandarie> @type void
13:55:36 <lambdabot> Not in scope: `void'
13:56:06 <Saizan> roconnor: send a patch for the Control.Applicative documentation :)
13:56:19 <roconnor> Saizan: why, what does the documentation say?
13:56:43 <djahandarie> Prelude Control.Monad> :t void
13:56:43 <djahandarie> void :: Functor f => f a -> f ()
13:57:07 <roconnor> Saizan: Ah I see
13:57:57 <Saizan> that "should satisfy" is quite ambiguous, but looks like a requirement rather than a consequence of the above
13:58:12 <Saizan> s/a requirement/additional requirement/
14:04:36 <dankna> so I have a question
14:04:53 <dankna> I'm working on a package similar to utf8-strings but for other encodings
14:05:24 <dankna> what do you do if you want to fold on a "special kind of foldable" type like this, zipped with another type?
14:05:38 <dankna> is there some sort of "zippable-foldable" type?  either currently extant or that could be designed?
14:05:51 <roconnor> Saizan: which of the two functor laws do I not need to check?
14:06:35 <Twey> dankna: AFAIK, such explicit handling of encodings is now deprecated
14:06:43 <Twey> As of 6.12, everything goes through the Handle magic
14:06:49 <dankna> Twey: how do you mean?  it has to be built on top of something.
14:07:00 <dankna> this is built on ByteString, not on String
14:07:09 <Twey> Hm, alright
14:08:05 <dankna> I guess what I'd like to be able to do is write
14:08:24 <dankna> instance (ZippableFoldable a, ZippableFoldable b) => Foldable (a, b)
14:08:47 <dankna> but it's not clear to me what methods need to be in ZippableFoldable to make that possible
14:09:00 <dankna> or whether that's even a good name for it :)
14:10:10 <maurer_1> While it might not be efficient, on a basic level, if something is Foldable, you can generate a list out of it, which you can then zip and fold over...
14:10:23 <dankna> hmm
14:10:47 <dankna> true.  I'm not sure whether that's enough, with laziness.
14:12:16 <maurer_1> dankna: Assuming the structure doesn't do something inherently non-lazy in its implementation of fold, you're fine.
14:12:35 <maurer_1> dankna: The "toList" function provided in Data.Foldable is lazy on lazy structures.
14:12:44 <maurer_1> So then you'll be able to zip lazily, and fold over the result lazily.
14:13:16 <dankna> hmm.... but ByteStrings aren't lazy (not even the ones in Data.ByteString.Lazy).
14:13:38 <dankna> it becomes a complicated question of whether fold is lazy in the right sense
14:14:13 <maurer_1> dankna: Bytestrings are partially lazy if I remember right...
14:14:25 <maurer_1> They uses ropes, right?
14:14:31 <dankna> I thought it was the other way around
14:14:39 <dankna> a ByteString is a ForeignPtr under the hood in today's implementation
14:14:51 <dankna> though it will probably become a GHC.IO.Buffer at some point soon
14:14:58 <thatBlueThing> re: cabal in https://gist.github.com/844656 - for some reason I cannot get cabal to recognize the location of my source files
14:15:13 <maurer_1> I thought that a strict bytestring was, and a lazy bytestring was a collection of ForeignPtrs which got built up as more were requested.
14:15:21 <thatBlueThing> it must be something trivial that I'm overlooking... but I get Setup.lhs: can't find source for Main in ., dist/build/autogen
14:15:35 <dankna> a lazy bytestring is a list of non-lazy bytestrings, yes
14:16:14 <dankna> thatBlueThing: Main with the .cabal file you've written needs to be in a file Main.hs in the directory you are in when you invoke hackage
14:16:16 <maurer_1> dankna: So how would that not work here? That seems fine.
14:16:20 <dankna> capitalized just like that
14:16:35 <maurer_1> thatBlueThing: Either that or use Hs-Source-Dir
14:16:41 <dankna> maurer_1: that's for building them though, not for traversing them?
14:16:51 <maurer_1> dankna: Yeah, traversing them should be even lazier.
14:16:55 <dankna> hmm
14:17:10 <dankna> you're probably right.  I guess the details of when you do and don't get laziness are fuzzy to me.
14:17:13 <dankna> okay.
14:17:19 <dankna> then I won't worry about writing ZippableFoldable :)
14:18:11 <dankna> thatBlueThing: reading deeper, it looks like you want to put your Main.hs in the Decaf/ directory?  if that's what you want, it needs to say main-is: Decaf/Main.hs
14:18:24 <dankna> and you don't need to list Main in other-modules, by the way
14:18:49 <thatBlueThing> dankna: thanksyour suggestion to use hs-source-dirs did it in the end
14:19:00 <dankna> that was maurer_1's suggestion :) you're welcome
14:19:12 <thatBlueThing> oops, thanks maurer_1 (and dankna)
14:19:24 <thatBlueThing> dankna: though you are correct; I'm being redundant in including Main twice
14:22:22 <alex404> Is there a way to get bound variables inside a do block to be recognized as local variables with respect to a where binding? Is that a crazy thing to want?
14:22:52 <roconnor> @free fmap
14:22:53 <lambdabot> Expected variable or '.'
14:23:05 <monochrom> not crazy but no way
14:23:19 <Heffalump> you can use a let binding instead
14:23:21 <roconnor> @free foo :: (a -> b) -> f a -> f b
14:23:22 <lambdabot> Extra stuff at end of line
14:23:29 <revenantphx> alex404: consider how 'do' desugars
14:23:38 <roconnor> @free (a -> b) -> f a -> f b
14:23:38 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:23:42 <roconnor> bah
14:24:04 <revenantphx> What're you trying to do
14:24:14 <alex404> revenantphx: I know it doesn't make syntactic sense per say, I just wondered if there was some neato GHC extension
14:24:30 <alex404> Just foo <- bar
14:24:33 <alex404> and then 
14:24:39 <revenantphx> heh, well, if 'do' syntax was something special than yeah, but as it is, I'm pretty sure it's just a straight rewrite.
14:24:39 <alex404> where baz = fun foo
14:24:43 <Saizan> @free map
14:24:43 <revenantphx> :|
14:24:44 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
14:25:34 <benmachine> does anyone know a convenient way to establish what version of base introduced MonadFix?
14:27:43 <alex404> Another tricky little question: Does anyone know how from the vector package I can combine an 'imap' with a 'mapM'
14:28:32 <alex404> i.e. I want to map a monadic function which takes the index and the value of the elements of the vector
14:28:35 <Heffalump> @src mapM
14:28:36 <lambdabot> mapM f as = sequence (map f as)
14:28:43 <Heffalump> so you can just do a sequence after the imap
14:29:09 <aristid> :t Data.Traversable.mapM
14:29:10 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:30:10 <alex404> yah, but the vector package doesn't have sequence
14:30:53 <dankna> :t sequence
14:30:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:31:06 <alex404> oh
14:31:09 <alex404> right
14:31:17 <alex404> wait
14:31:18 <alex404> no
14:31:27 <alex404> I mean, I don't really want to have to convert it to a list first
14:31:43 <Heffalump> well, in principle that would fuse so you wouldn't pay any performance cost
14:32:04 <benmachine> :t Data.Traversable.sequenceA
14:32:05 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
14:32:08 <alex404> I was told crossing the vector/list boundary should be avoided if performance is a big deal
14:32:13 * benmachine doesn't know if that's any better
14:32:29 <robryk> you would pay some, but small, for evaluating subsequent closures
14:33:02 <robryk> you aren't crossing it really
14:33:14 <alex404> robryk: What do you mean exactly? evaluating subsequence closures?
14:33:25 <robryk> what will happen is that the list will get generated one element at a time and consumed at the same time
14:33:34 <alex404> right
14:33:47 <alex404> But what would the bad situation be?
14:33:49 <robryk> i mean that you will pay some small amount of time for these evaluations
14:33:53 <robryk> it isn't bad
14:34:01 <alex404> Yah I get it
14:34:03 <robryk> it just isn't zero
14:34:09 <fryguybob> alex404: I think the one you are wanting to avoid is:  toList :: Vector a -> [a]
14:34:26 <alex404> fryguybob: What else is there?
14:34:28 <robryk> i think it's comparable to cost associated with bounds-checking
14:34:31 <alex404> That's what I'd need here
14:34:57 <alex404> robryk: I mean we are talking about feeding a vector through toList and then, say, a sequence, right?
14:35:19 <fryguybob>  You are wanting to apply  imap :: (Int -> a -> b) -> Vector a -> Vector b  right?
14:35:35 <robryk> wait, need to look at toList, but i think it is a good list producer -- that it produces lists `one element at a time'
14:35:58 <alex404> fryguybob: Aye, except for (Int -> a -> m b)
14:36:11 <alex404> fryguybob: And then how would I sequence that?
14:36:21 <robryk> oh
14:36:22 <alex404> fryguybob: And now you're saying toList is bad...
14:36:31 <fryguybob> alex404: I see, I thought you wanted it for [Vector a]
14:36:34 <robryk> the problem isn't with tolist
14:36:51 <robryk> the problem will appear when you evaluate the m [a] which you get from sequence
14:37:01 <robryk> sorry
14:37:08 <robryk> disregard what i said
14:37:08 <alex404> So what is the problem?
14:38:46 <robryk> what do you want to have as the result of all these operations?
14:39:02 <robryk> m [a], m (Vector a) or m () ?
14:39:18 <alex404> Well, it doesn't really matter, so m ()
14:39:27 <alex404> but in some sense via m (Vector a)
14:39:38 <alex404> or m (Vector ())
14:40:15 <robryk> :t sequence_
14:40:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:40:30 <alex404> To be honest though now I think I'm going to change my approach
14:40:41 <robryk> would sequence_ . fmap (yourFun) . toList work?
14:40:49 <alex404> Essentially I'm dealing with a pixbuf from the gtk package
14:41:09 <alex404> I still was hoping for an imap
14:41:30 <alex404> so sequence_ . toList . imap fun
14:41:36 <alex404> Would work
14:41:45 <robryk> why do you want to use imap?
14:42:19 <alex404> So I can use the index, of course
14:42:37 <robryk> oh, silly me; right
14:43:06 <alex404> I have a more important question now with regards to reasoning about performance
14:43:14 <robryk> i would imagine that being somewhat slower, because what would happen at evaluation is that a new vector would get created first
14:43:23 <robryk> and it would be created whole
14:43:40 <alex404> If I've got something like this image PixBuf from gtk
14:43:57 <alex404> Do I want to use mutable array operations on it to change the image?
14:44:13 <alex404> Or can I stay pure and just create new ones all the time?
14:44:53 <robryk> i don;t know how does a pixbuf look like, but i would imagine it is similar to an array
14:44:59 <alex404> It is just an array
14:45:14 <alex404> So this is a question about arrays in general
14:45:32 <robryk> array change operation on immutable arrays copies whole array
14:45:53 <robryk> so that isn't very good for pictures
14:46:01 <robryk> do you know what ST is?
14:46:03 <alex404> Yah so I mean inside IO or ST
14:46:21 <benmachine> alex404: it depends on your usage pattern I think, e.g. how many elements you change at once
14:46:30 <benmachine> that sort of thing
14:46:44 <rly> It also depends on the hardware you have.
14:46:52 <alex404> How does hardware matter?
14:47:09 <robryk> you could put together a larger change into one copy by using ST
14:47:22 <alex404> I know
14:47:26 <alex404> I guess what I'm wondering is
14:47:30 <rly> If you have a piece of hardware with a massively parallel array of elements then copying would be extremely fast.
14:47:39 <alex404> If you're going to change the whole array anyway
14:47:45 <rly> (what the pure code would do)
14:47:49 <alex404> Is it worth doing it in ST or IO?
14:47:59 <robryk> oh, by the way: avoid freeze -- it often creates a huge list
14:48:09 <alex404> robryk: Good to know
14:48:19 <rly> If however, you have a standard PC, then mutating it is going to be faster.
14:48:49 <revenantphx> Haskell provides me with an infinite number of fun projects, hurray. ^_^
14:48:56 <robryk> rly: but wouldn't you need to have a very nonstandard compiler to use those features, like dph or something?
14:49:00 <alex404> rly: How are copying and mutating different?
14:49:01 <revenantphx> Trying to grasp CFG's and parsing stuff now.
14:49:05 <revenantphx> And lexical analysis. Fun.
14:49:13 <rly> robryk: yes
14:49:34 <alex404> rly: Besides the former being a case of the latter?
14:50:04 <rly> alex404: ?
14:50:38 <robryk> being a restricted version of the latter
14:50:49 <robryk> which you *can* use in pure code due to its restrictedness
14:51:03 <alex404> rly: I don't think I understood what you said. If you copy an element of an array to another, how is that different from mutation?
14:52:39 <benmachine> rly: copying in this context means copying the array, such that the new array has different stuff in it
14:52:48 <xplat> hm, about the whole 'ticket system for hackage' idea
14:53:36 <xplat> and being opt-in in case people would rather use something else
14:53:38 <xplat> while i do agree that having a place to submit tickets where they will be ignored is not helpful
14:53:42 <robryk> IO and ST should give you the same performance of the same operations
14:53:48 <rly> alex404: semantically it would copy.
14:54:17 <rly> alex404: that it happens to mutate it in the implementation is irrelevant.
14:54:20 <alex404> robryk: Yah, I guess for spiritual reasons I try and avoid ST, but in this case it'll be pretty required
14:54:47 <rly> alex404: if you want fast image processing code, just use C or OCaml.
14:54:53 <xplat> i think there are also a lot of tickets lost due to things like, 'oh, i need to create a new account to submit this ticket?'  and a lot of annoyance created
14:55:14 <revenantphx> I'm trying to jump in the deep end reading this http://wiki.di.uminho.pt/twiki/pub/Personal/Joao/--TwikiJoaoPublications/technicalReport.pdf
14:55:32 <revenantphx> Any suggestions would be, of course, very welcome.
14:57:05 <xplat> what would really be better is to have a ticket submission interface on hackage that can talk to other trackers
14:58:26 <xplat> you submit the ticket through hackage, sign up for notification through hackage
14:58:50 <xplat> maintainer manages the ticket through github or a private trac or whatever
14:59:38 <xplat> hackage handles submitting the ticket to that and signs itself up for notification, redirects it to the submitter
14:59:55 <revenantphx> So, kind of like github's service hook system?
15:00:10 <revenantphx> (it lets each repository broadcast to various different services, including generic PHP post request)
15:00:37 <xplat> something like that, yes
15:00:54 <revenantphx> http://cl.ly/4rIj
15:00:56 <revenantphx> brb
15:01:12 <dankna> xplat: yes - an API - but the problem with such an API is spam :(  I have CAPTCHAs on my tracker, will Hackage support them?
15:01:45 <xplat> really hackage should have its own CAPTCHAs
15:01:47 <dankna> revenantphx, Generalized LR parsing is something more than just LR parsing
15:02:00 <dankna> yeah, if it did and they were strong, I would give it the credentials it needed to skip the CAPTCHA on my end
15:03:32 <dankna> note that hs-captcha already exists and could be leveraged :)
15:06:11 <rly> dankna: do you have example captchas?
15:06:44 <dankna> rly: try reloading http://dankna.com/issues/create/ a couple times
15:07:31 <rly> dankna: what makes you think those are hard to crack?
15:08:11 <benmachine> I can't find numbered versions of base before 3
15:08:24 <dankna> rly: they use "chirps" rather than sine waves, which defeats attempts to simply reverse the algorithm, as there are no known algorithms for recognizing a chirp.  letter-recognition strategies based on number of paths might still succeed though.
15:08:42 <dankna> actually I mean no known cheap algorithms
15:08:43 <c_wraith> rly: good captcha-cracking software is better at solving them than a significant percentage of humans are.
15:08:59 <c_wraith> in that sense, captchas are a losing battle
15:09:05 <dankna> yeah.  but they're all we've got :(
15:09:31 <ezyang> What's wrong with the statement, (a, a) has two functor instances, one for fst and one for snd? 
15:09:49 <Adamant> c_wraith: we need new problems, then
15:09:49 <c_wraith> ezyang: in the context of haskell?
15:10:14 <ezyang> Mmm, not sure how that's relevant, but sure. 
15:10:15 <benmachine> ezyang: several things! (a, a) is the wrong kind to be a functor, the two type variables can't/shouldn't be the same
15:10:16 <rly> c_wraith: has the image rotation problem already been solved then?
15:10:17 <aristid> ezyang: it's wrong because (,) a a has only one argument order
15:10:49 <c_wraith> If you created a type that held a pair of values of the same type, it would have one functor instance :)
15:11:11 <ezyang> ah, so we get a bifunctor from (a,b) because we reorder the type arguments. Gotcha. 
15:11:11 <dankna> oh, yes.  relying on mere rotations is insufficient and does not prevent spam.
15:11:24 <dankna> captchas are small enough that brute-forcing the rotation works.
15:11:59 <rly> Why does recaptcha still run if it has been broken?
15:12:07 <dankna> inertia?  pride?
15:12:30 <benmachine> rly: well, your aim is to reduce spam as much as possible
15:12:42 <parcs> recaptcha helps digitize books
15:12:44 <revenantphx> dankna: Replace captchas with witty puns.
15:12:46 <revenantphx> :D
15:12:56 <revenantphx> Then again, I have my doubts about the intelligence of the average person so... maybe not.
15:13:02 <dankna> revenantphx, hah!  "please select the funnier of the following remarks"?
15:13:07 <benmachine> revenantphx: only witty people may post on my blog
15:13:07 <revenantphx> Exactly :P
15:13:13 <revenantphx> or more easily:
15:13:23 <dankna> I've also seen captchas which were based on NLP
15:13:24 <revenantphx> "Please select the most politically correct of the following remarks:"
15:13:42 <dankna> as in "Please type the fourth word of this sentence.  (Hint: this is not a trick question.)"
15:13:59 <revenantphx> Yeah, something like that'd work.
15:14:01 <dankna> but no large sites have adopted that yet
15:14:09 <benmachine> dankna: but captchas like that take as long to produce as they do to break in a sense
15:14:22 <dankna> benmachine: true, it's a problem
15:14:28 <benmachine> I mean, when someone learns the trick, they just search for "fourth" and then use that
15:14:33 <rly> How much CPU time can a spam decider take before people won't use it?
15:14:42 <revenantphx> I had an idea based on the card game Mao.
15:14:53 <dankna> fun card game
15:14:58 <Ptival> http://hpaste.org/44318/need_simplification   is there a way to avoid this case?
15:15:02 <revenantphx> Basically, that a card is presented, as well as a "rule" for what should be played on it.
15:15:08 <dankna> though I once saw someone break down into tears because of not getting the rules :(
15:15:15 <revenantphx> Such as "Ace of Spades" and "Odd black cards must be followed by red even cards"
15:15:16 <benmachine> basically, there are loads of captchas that will work once :)
15:15:20 <parcs> I visited a forum that asked "Which sentence uses the word "their" correctly?" before you can register
15:15:23 <dankna> benmachine: yes, that's the thing
15:15:30 <revenantphx> dankna: My favorite rule is something like what I just said.
15:15:30 <dankna> parcs: hah!  was it testycopyeditors.org?
15:15:40 <revenantphx> It's very easy to exploit on your own if you want to get rid of your own card.
15:15:45 <revenantphx> And people are generally slow to pick it up.
15:15:49 <parcs> don't think so
15:15:52 <dankna> haha oh well
15:15:54 <revenantphx> But it's perfectly reasonable, and only affects a quarter of the deck.
15:16:00 <benmachine> I wonder if dyslexics have trouble with these measures >_>
15:16:05 <dankna> benmachine: yes they do
15:16:10 <dankna> benmachine: that's another problem
15:16:30 <Adamant> so add another problem for dyslexics
15:16:38 <benmachine> heh
15:16:39 <benmachine> :(
15:16:41 <Adamant> same as audio captchas for the blind
15:16:43 <dankna> revenantphx: I once came up with a rule that said something like "For the purposes of all rules other than this one, spades numbered N count as if they were hearts numbered N+1"
15:16:43 <benmachine> hmm
15:16:45 <benmachine> oh true
15:17:14 <revenantphx> dankna: Playing Mao with a bunch of haskellers... would be so fun XD.
15:17:17 <dankna> it would
15:17:22 <Adamant> revenantphx: that reminds me of Zendo
15:17:53 <Adamant> where the goal is for a "Zen master" to come up with a rule and help everyone else discover it
15:18:01 <dankna> "Sevens perform fmap, applying the rule of the following card to the card after it..."
15:18:07 <dankna> yes, Zendo came later
15:18:07 <revenantphx> dankna: oh fuck...
15:18:12 <dankna> haha
15:18:13 <revenantphx> You can also come up with fun rules like
15:18:14 <benmachine> Ptival: what did you want to avoid?
15:18:16 <robryk> Ptival: you want to be able to use anything showable then?
15:18:19 <revenantphx> "All diamonds must be placed sideways"
15:18:25 <dankna> ooh that's a nice one
15:18:26 <revenantphx> though it's a bit dickish.
15:18:32 <dankna> there are also rules that require you to say things on certain triggers
15:18:39 <dankna> play a king and say "It's good to be the king."
15:18:43 <dankna> (movie reference)
15:18:45 <revenantphx> Too easy to figure out though.
15:18:51 <dankna> yes, but fun
15:18:54 <revenantphx> true.
15:19:02 <revenantphx> You want to know my favorite Mao rule?
15:19:06 <dankna> and then you could go the Magic: the Gathering: Unglued route
15:19:13 <revenantphx> "If you are female and play a queen, you must remove one item of clothing."
15:19:15 <dankna> "You must keep one hand on your head."
15:19:22 <Ptival> benmachine, robryk: Actually, I was thinking that I could somehow automatically extract the subtype whichever it was, but that wouldn't have any meaning if what is inside is not showable and is not unique...
15:19:38 <dankna> "You must move one hand in little circular motions at all times when it's not your turn."
15:19:41 <Ptival> so it might just be the right way to do it :)
15:19:50 * dankna rolls his eyes
15:20:10 <revenantphx> Strip Mao ;D
15:20:22 <robryk> you can do soething like forall t. (Show t) => Value t
15:20:26 <revenantphx> The only problem is generally everyone's naked before anyone's even figured out any rules.
15:20:44 <benmachine> Ptival: you can do, tell $ s ++ case v of ...
15:20:54 <benmachine> revenantphx: lol
15:21:00 <Ptival> benmachine: oh, cool, thanks
15:21:16 <revenantphx> As for harsh rules: "If you play a perfect square, you must calculate the determinant of the matrix formed by that cards number of card, and play a prime factor of the determinant"
15:21:18 <robryk> revenantphx: that rule about removing an item of clothing didn't preclude putting it back on immediately
15:21:25 <revenantphx> robryk: This is true.
15:21:28 <benmachine> revenantphx: augh D:
15:21:34 <Ptival> I guess I'm still too reluctant to use case as any other expression
15:21:37 <revenantphx> So if you play a 9, you have to form a matrix from that card and the previous 8
15:21:40 <revenantphx> and then take the determinant.
15:21:51 <rly> revenantphx: have you ever played this game?
15:21:55 <revenantphx> rly: Mao?
15:22:02 <benmachine> I haven't
15:22:04 <revenantphx> Yes, but I don't use rules that annoying :P.
15:22:08 <rly> revenantphx: it sound like a very bad joke. 
15:22:13 <benmachine> it sounds like it wouldn't be that interesting if you knew the rules?
15:22:18 <revenantphx> You don't.
15:22:23 <revenantphx> The idea of the game is you can't talk.
15:22:24 <benmachine> well *someone* has to :P
15:22:29 <revenantphx> a referee, or no one.
15:22:39 <revenantphx> Each person makes up a rule, and if someone breaks it they take an additional card.
15:22:40 <dankna> you each know the rules you created
15:22:46 <benmachine> ah
15:22:47 <benmachine> one each?
15:22:48 <revenantphx> you can motion with your finger to say "pick up a card"
15:22:53 <benmachine> also
15:22:56 <dankna> you get to make a new rule after winning a round
15:22:59 <dankna> the initial rules are the rules of Uno
15:22:59 <revenantphx> And generally, you're allowed to say either
15:23:04 <benmachine> games with no talking are a terrible idea :P
15:23:04 <revenantphx> "You didn't put the right card" 
15:23:05 <revenantphx> or
15:23:08 <revenantphx> "You didn't put enough cards".
15:23:10 <dankna> I usually play it with talking allowed though
15:23:15 <revenantphx> dankna: boo.
15:23:20 <dankna> you can also call a point of order
15:23:23 <benmachine> games are social >_<
15:23:46 <Ptival> benmachine: why can't I also extract the show? is this because now the case does not return a unique type?
15:23:55 <Ptival> would not*
15:24:12 <benmachine> Ptival: oh, erm, I didn't think of that but yes, the case needs to be well-typed
15:24:17 <rly> Ptival: you can write this without repetition with Template Haskell.
15:24:23 <revenantphx> dankna: fun game though :)
15:24:26 <benmachine> rly: overkill!
15:24:36 <rly> benmachine: I was not suggesting it. 
15:24:41 <Ptival> rly: plus I'm a beginner ^^
15:24:51 <benmachine> rly: that erm, sounded like a suggestion to me :P
15:24:56 <Ptival> well thanks it looks better now
15:25:16 <dankna> it is a fun game
15:25:58 <rly> I think you can write that program in Coq without repetition, but you might have to specify some more types.
15:26:35 <Ptival> :)
15:27:24 <rly> It is a fairly valid objection. You want to say 'just show the first element of the constructor'. 
15:27:58 <rly> If then there is no direct mapping (Template Haskell requires you to create a separate module, reorganize your code a bit), that's fairly annoying.
15:29:14 <roconnor> @unpl (\g -> (g f) a) . (.)
15:29:15 <lambdabot> (\ i -> i (f a))
15:29:20 * Philippa hands out cards to various people who've been taking the Chairman's name in vain
15:29:40 <roconnor> Philippa: point of order
15:30:08 <Philippa> roconnor: mmm. Don't you just love it when some arsehole says "end point of order" twice?
15:30:44 * roconnor hands Philippa a card for saying P of O in a P of O
15:31:20 <Philippa> hrmm. We appear to know slightly different rules for delimiting them :p
15:31:36 <roconnor> I don't remember the rules so well anymore
15:31:49 <Philippa> I ended the point of order when I said end point of order
15:31:59 <roconnor> damn it
15:32:34 <Philippa> yeah, that statement ought to amuse plenty of haskellers :-)
15:33:30 <roconnor> Saizan: actually all you need to do is prove that pure id <*> x = x and then it must be the case that fmap f x = pure f <*> x
15:33:42 <roconnor> Saizan: since the composition law is free
15:38:21 <roconnor> @unpl (\g -> g a) . (\g -> g f) . (.)
15:38:22 <lambdabot> (\ i -> i (f a))
15:40:05 <Kaidelong> ($ f a)
15:41:41 <Kaidelong> @ty (\g -> g a) . (\g -> g f) . (.)
15:41:42 <lambdabot> forall a b. (SimpleReflect.FromExpr a) => (a -> b) -> b
15:41:53 <Kaidelong> > (\g -> g a) . (\g -> g f) . (.)
15:41:54 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> b)
15:41:54 <lambdabot>    arising from a u...
15:44:11 <edwardk> roconnor: heh, just replied to ross about that, and then saw you'd given a much more thorough response than I did. oh well.
15:44:48 <Xilon> Is there a library for LZMA/LZMA2 (more specifically XZ) compression? A wiki page implies "compression" supports it, but I'm not able to find it: http://www.haskell.org/haskellwiki/Library/Compression
15:45:17 <roconnor> edwardk: I'm trying to prove the composition law for my applicative functor
15:45:19 <roconnor> what a pain
15:45:32 <edwardk> which one?
15:48:05 <ezyang> Out of curiosity, is there a formalization of the free theorems in some theorem prover? 
15:49:05 <edwardk> ezyang: there has been some talk about them in the agda community lately
15:49:15 <Saizan> yeah, a few papers and a poster :)
15:49:47 <Saizan> http://www.cs.cmu.edu/~rjsimmon/papers/2009abstractionposter.pdf
15:50:04 <edwardk> i don't think anyone has automated the reflection though
15:50:41 <edwardk> it'd be kinda fun to do in something like conor's reflective description language.
15:51:30 <Saizan> well, you also need to mess with lambda terms to get a proof of the properties
15:51:57 <edwardk> blech
15:52:41 <Saizan> there's a transformation that maps a type to the free theorem and a term inhabiting the type to the proof of the free theroem
15:53:18 <edwardk> thats not that bad i guess
15:54:27 <Saizan> http://perso.ens-lyon.fr/marc.lasson/articles/RealParam/RealParam.pdf <- the paper
15:55:08 <ezyang> Ooh, this discussion lead me to a paper of Conor's on how to implement a dependently typed lambda calculus. \o/ 
15:56:51 <Saizan> i think conor has ways of implementing a dependently typed lambda calculus as others have photograph albums
16:03:33 <xplat> 'lambda: the ultimate memento'?
16:04:51 <joelb> I have a c2hs question, how do I access a member struct that is not a pointer?
16:04:55 <ezyang> no no, pi. 
16:05:06 <ezyang> joelb: Ugh. 
16:05:07 <joelb> See here http://hpaste.org/44319/c2hs_struct
16:05:13 <ezyang> joelb: I'm not sure you can do it with c2hs. 
16:05:17 <joelb> in particular lines 15 and 50
16:05:45 <joelb> ezyang: what would you recommend doing in that case?
16:06:39 <ezyang> writing a wrapper C function, probably. 
16:07:19 <joelb> ok so it should take a pointer to the structure and return a pointer to the member struct?
16:07:51 <ezyang> You could do that. 
16:09:18 <joelb> Is that not what you would do?
16:10:46 <ezyang> Actually, I think struct embedded in structs work. 
16:10:59 <ezyang> Something like {#get foo.bar.baz #} 
16:11:24 <joelb> so you're telling me to directly access the the members of the member, right?
16:11:52 <ezyang> yeah. IIRC there wasn't an easy way to convince c2hs to give you just the offset; hsc2hs is better for that. 
16:13:00 <joelb> hm I may want to use hsc2hs instead
16:13:22 <joelb> my actual code has structs that are a lot more complex
16:13:56 <ezyang> you can always mix and match. 
16:13:57 <joelb> so it might be easier to do it with hsc2hs because I don't want to have to marshall each member
16:14:08 <ezyang> c2hs doesn't buy you much in terms of marshalling structs. It's good for functions. 
16:14:14 <joelb> oh yeah I was looking at the gtk2hs source and it looked like they were doing that
16:14:47 <joelb> ah so I could use hsc2hs for structs and c2hs for functions
16:14:51 <ezyang> http://hackage.haskell.org/trac/c2hs/ticket/22 
16:16:23 <roconnor> ezyang: I want to formalize my proofs but I'm using system F-omega, and these existing formalizations only work on system F.
16:16:30 <Draggor> I have used cabal to install HUnit, and i have it listed as a build-dep, configure works fine, but when I go to build, I get: Could not find module `HUnit'
16:17:03 <joelb> looks like it's not going to be part of c2hs anytime soon
16:17:11 <ezyang> yep. 
16:17:53 <joelb> Oh well hsc2hs will suffice
16:18:07 <joelb> I've been using your c2hs guide by the way, very helpful
16:18:11 <joelb> thanks!
16:18:26 <ezyang> Cool! :-) 
16:19:58 <roconnor> @unpl ((\g -> g a).) . (.) . ((.) <$> u)
16:19:59 <lambdabot> (\ l r -> ((\ f h i -> f (h i)) <$> u) l (r a))
16:21:00 <sm> ezyang: quite an awesome blog post today !
16:21:10 <dark> @hoogle flatten
16:21:11 <lambdabot> Data.Tree flatten :: Tree a -> [a]
16:21:11 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
16:21:11 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
16:21:20 <dark> where is list's flatten?
16:21:28 <dark> @hoogle [[a]] -> [a]
16:21:28 <lambdabot> Prelude concat :: [[a]] -> [a]
16:21:28 <lambdabot> Data.List concat :: [[a]] -> [a]
16:21:28 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:21:34 <dark> oh ok
16:21:57 <Kaidelong> @ty join
16:21:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:22:16 <dark> uhm yes
16:22:47 <Kaidelong> > [1..] >>= (enumFromTo 1)
16:22:48 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,...
16:23:23 <ddarius> byorgey: I think you will find that chooseBinding will need to become smarter and that adding this intelligence will require global changes (that perhaps can be caught in the monad.)
16:23:23 <Kaidelong> > join (fmap enumFromTo [1..]) --alternative primitive way to look at this
16:23:24 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
16:23:33 <Kaidelong> > join (fmap (enumFromTo 1) [1..]) --alternative primitive way to look at this
16:23:34 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,...
16:23:49 <Kaidelong> also join is ">>= id"
16:25:13 <dark> x >>= y is join (fmap y x) ? hm
16:25:32 <revenantphx> ...what?
16:25:37 <revenantphx> :t join
16:25:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:25:47 <ddarius> dark: Yes.
16:25:49 <revenantphx> :t fmap
16:25:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:25:52 <revenantphx> :t >>=
16:25:52 <lambdabot> parse error on input `>>='
16:26:01 <revenantphx> :t (>>=)
16:26:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:26:18 <dark> fmap id x is x, so it makes sense that x >>= id is join x
16:26:28 <ddarius> Indeed.
16:26:33 <revenantphx> 0.o
16:26:35 <revenantphx> confused...
16:26:36 <Kaidelong> @ty (>>= id)
16:26:37 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
16:26:39 <dark> revenantphx, well for Monad that also works as Functor
16:26:45 <revenantphx> Right.
16:26:50 <Kaidelong> dark: All monads do
16:27:11 <dark> Kaidelong, it seems that you first need to define as such
16:27:13 <Kaidelong> @src liftM
16:27:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:27:24 <Kaidelong> @ty liftM
16:27:25 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:27:32 <dark> liftM = monad's fmap?
16:27:37 <Kaidelong> unfortunately
16:28:05 <Kaidelong> but all monads are applicative functors, and all applicative functors are functors
16:28:27 <revenantphx> I still don't entirely understand applicatives.
16:28:32 <revenantphx> Or rather, how to use them.
16:28:40 <dark> uhm.. so.. it is more accurate to say x >>= y is join (liftM y x)
16:28:57 <revenantphx> @src (>>=)
16:28:57 <lambdabot> Source not found. :(
16:29:01 <revenantphx> @src bind
16:29:01 <lambdabot> Source not found. I am sorry.
16:29:02 <Kaidelong> revenantphx: Imagine you have some context, like IO. You can take a pure function, say (a -> b), and lift it into the IO applicative functor
16:29:04 <revenantphx> @src >>=
16:29:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:29:16 <revenantphx> Kaidelong: I'm not confused about that...
16:29:20 <Kaidelong> oh ok
16:29:27 <Kaidelong> well that's how you use them, basically
16:29:43 <dark> revenantphx, I had a very nice example. I had this code: do { res <- p; spaces; return res }, this is just p <* spaces as I discovered here
16:30:01 <revenantphx> oh yeah, I don't get <* at all >_>
16:30:02 <roconnor> dark: if m is a monad instance satifying the monad laws, and m is a functor instance satifying the functor laws, then you can prove that liftM = fmap
16:30:03 <revenantphx> never used it
16:30:05 <Kaidelong> revenantphx: (>>=) is a method, not a value
16:30:16 <revenantphx> Kaidelong: ...I know.
16:30:18 <dark> I still don't understand, but I can't deny that after writing this two or this times it proves to be useful
16:30:32 <Kaidelong> @src Maybe.>>=
16:30:32 <lambdabot> Source not found. stty: unknown mode: doofus
16:30:34 <Kaidelong> hmm
16:30:41 <roconnor> @src (>>=) Maybe
16:30:41 <Kaidelong> I forgot how to look up a method
16:30:42 <lambdabot> Source not found. You speak an infinite deal of nothing
16:30:46 <roconnor> @src Maybe (>>=)
16:30:47 <lambdabot> (Just x) >>= k      = k x
16:30:47 <lambdabot> Nothing  >>= _      = Nothing
16:30:48 <revenantphx> so a <* b just evaluates the right hand side, then returns the left.
16:30:52 <Kaidelong> ah there we go
16:31:09 <revenantphx> or rather, it evaluates the right hand side and left hand side, but only returns the result of the left.
16:31:10 <robryk> roconnor: you don't need any other relation between the instances?
16:31:11 <Kaidelong> @src (<*)
16:31:12 <lambdabot> (<*) = liftA2 const
16:31:16 <roconnor> robryk: turns out you don't
16:31:34 <roconnor> robryk: basically because there is at most one functor instance for a type constructor.
16:31:46 <Rotaerk> @src liftA2
16:31:47 <lambdabot> liftA2 f a b = f <$> a <*> b
16:32:15 <robryk> oh
16:32:17 <Kaidelong> Rotaerk: better to look at the type
16:32:24 <Kaidelong> @ty liftA2
16:32:25 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:32:49 <revenantphx> @src (*>)
16:32:49 <lambdabot> (*>) = liftA2 (const id)
16:32:50 <robryk> why is that? (if it isn't very short, where can i find such stuff?)
16:32:53 <Kaidelong> revenantphx: basically the answer is yes, by the way, I should have clarified that
16:32:57 <revenantphx> Kaidelong: heh.
16:33:01 <revenantphx> so *> is the opposite?
16:33:10 <revenantphx> so how does <*> "fit" that idea then?
16:33:33 <aristid> @src ap
16:33:33 <lambdabot> ap = liftM2 id
16:33:43 <aristid> revenantphx: (<*>) = liftA2 ($)
16:33:44 <dark> roconnor, even having limited understanding of haskell, as I understand any constraint not proven by the type system is wishful thinking. Or you see the code, or the type system proves to you, or it's a conjecture at best
16:33:54 <Kaidelong> revenantphx: I'm not really sure if it is right to think of <*> as related to <* and *>, but I might be wrong on that
16:34:03 <revenantphx> Kaidelong: true.
16:34:05 <roconnor> dark: this constraint is proved by the type system.
16:34:10 <Kaidelong> like >>, you define >> in terms of >>= I guess
16:34:21 <Kaidelong> and <* in terms of <*>
16:34:25 <BMeph> (<*) = liftA2 const; (*>) = liftA2 (const id); (<*>) = liftA2 id -- brilliant! ;)
16:34:29 <aristid> Kaidelong: if you consider liftA2 to be the primitive, you can draw nice parallels between (<*>), (<*) and (*>)
16:34:31 <revenantphx> <$> is just fmap yeah?
16:34:35 <revenantphx> @src <$>
16:34:35 <lambdabot> f <$> a = fmap f a
16:34:36 <dark> roconnor, interesting. o.o how do you demonstrate that a monad satisfy the monad laws?
16:34:38 <revenantphx> yeah, thought so.
16:34:43 <aristid> liftA2 ($), liftA2 const, and liftA2 (const id)
16:34:53 <robryk> roconnor: where can i find proofs of such facts?
16:34:54 <Kaidelong> aristid, BMeph: yeah true
16:35:13 <aristid> oh, didn't notice that bmeph said the same
16:35:18 <roconnor> dark: that wasn't my claim.  My claim was that *if* m's monad instance satifies the monad law, and *if* m's functor instance satifies the functor laws, then liftM = fmap
16:35:24 <roconnor> robryk: one sec
16:35:26 <aristid> also why is my tabl completion broken since yesterday? :(
16:35:29 <dark> oh ok
16:35:55 <ddarius> The tricky one is (<$).
16:36:04 <roconnor> robryk: http://www.haskell.org/pipermail/libraries/2011-February/015964.html
16:36:22 <aristid> Kaidelong: i had a question for you yesterday but you were away at that time... do you know if orc is efficient (in the sense of run-time performance)?
16:36:27 <aristid> :t (<$)
16:36:28 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:36:33 <BMeph> aristid: Not exactly; you keep using "liftA2 ($)," where I use the more sneaky "liftA2 id" form. :)
16:36:42 <Kaidelong> aristid: Galois claims that it is
16:36:47 <aristid> :t fmap . const
16:36:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
16:37:06 <aristid> BMeph: i like ($) because it is a little clearer
16:37:25 <aristid> ddarius: it's fmap . const, right?
16:37:35 <ddarius> :t liftA2 (ap const flip)
16:37:36 <lambdabot> forall b a b1 (f :: * -> *). (Applicative f) => f (b -> a -> b1) -> f b -> f (a -> b1)
16:37:43 <ddarius> aristid: Yes.
16:37:45 <robryk> thanks
16:37:55 <ddarius> aristid: The trickiness is in its usefulness.
16:38:17 <dark> @type filterM
16:38:18 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:38:19 <aristid> why? is it less useful than the others?
16:39:01 <ddarius> It's not as obviously useful as some.
16:39:10 * Kaidelong tries to think of an example of why you'd use applicative functors that does not involve effectful/nondeterminstic computation
16:39:27 <Kaidelong> well LYAH has one
16:39:30 <Kaidelong> but it is a bit silly
16:39:46 <Kaidelong> permutations of concatenations of strings IIRC
16:39:53 <aristid> :t (() <$)
16:39:53 <roconnor> Kaidelong: multiplate uses applicative functors parametrically
16:39:54 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
16:43:25 <Kaidelong> multiplate looks interesting
16:44:45 <roconnor> @pl (f.)
16:44:45 <lambdabot> (f .)
16:44:49 <Eduard_Munteanu> Is that the package that states it *only* requires rank-3 types and GADTs, or something like that?
16:44:56 <roconnor> @pl f . (.)
16:44:57 <lambdabot> f . (.)
16:45:00 <roconnor> er
16:45:03 <roconnor> @unpl (f.)
16:45:04 <lambdabot> (\ a d -> f (a d))
16:45:07 <dark> @let powerset = filterM (const [True, False])
16:45:08 <lambdabot>  <local>:8:0:
16:45:08 <lambdabot>      Multiple declarations of `L.powerset'
16:45:08 <lambdabot>      Declared at: <l...
16:45:09 <roconnor> @unpl f . (.)
16:45:10 <lambdabot> (\ g -> f (\ b c -> g (b c)))
16:45:15 <roconnor> @unpl (.) . f
16:45:15 <lambdabot> (\ g b c -> f g (b c))
16:45:21 <dark> :t powerset
16:45:22 <lambdabot> forall a. [a] -> [[a]]
16:45:31 <dark> oh it has only one namespace for declarations
16:45:36 <dark> > rs
16:45:36 <aristid> @index powerset
16:45:37 <lambdabot> bzzt
16:45:37 <lambdabot>   [("te",1),("bc",2)]
16:45:44 <aristid> oh you defined powerset yourself, lol
16:45:50 <dark> > powerset $ fmap fst rs
16:45:51 <Eduard_Munteanu> L. is defined by somebody here
16:45:52 <lambdabot>   [["te","bc"],["te"],["bc"],[]]
16:45:53 <aristid> > powerset [1,1,1]
16:45:55 <lambdabot>   [[1,1,1],[1,1],[1,1],[1],[1,1],[1],[1],[]]
16:45:59 <Eduard_Munteanu> *means it's
16:46:03 <aristid> > powerset [1,2,3]
16:46:05 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:46:27 <dark> I can do powerset in that list of (String, Int) to get a list of all substrings, but then I can't associate each substring to its corresponding int
16:46:45 <dark> (powerset definition taken from http://community.livejournal.com/evan_tech/220036.html )
16:47:22 <dark> oh actually
16:47:23 <dark> > fmap powerset $ fmap fst rs
16:47:25 <lambdabot>   [["te","t","e",""],["bc","b","c",""]]
16:47:56 <dark> the desired output was to be [("te", 1), ("t", 1"), .. ("bc", 2), ..]
16:48:16 <dark> but when I do fmap fst rs, in order to 'take' the strings, I discard the numbers..
16:48:27 <Eduard_Munteanu> You could sort by lexicographical order or something, then zip it with [1..]
16:48:30 <dark> > concat $ fmap powerset $ fmap fst rs
16:48:32 <lambdabot>   ["te","t","e","","bc","b","c",""]
16:49:01 <dark> oh, it isn't actually numbers in increasing order
16:49:06 <Kaidelong> @ty zip [1..]
16:49:07 <lambdabot> forall t b. (Num t, Enum t) => [b] -> [(t, b)]
16:49:17 <Eduard_Munteanu> > rs
16:49:18 <lambdabot>   [("te",1),("bc",2)]
16:49:28 <dark> (this is a contrived example)
16:49:29 <Eduard_Munteanu> > inits "te"
16:49:30 <lambdabot>   ["","t","te"]
16:49:40 <dark> @type inits
16:49:41 <lambdabot> forall a. [a] -> [[a]]
16:49:49 <Eduard_Munteanu> > inits "dark"
16:49:49 <lambdabot>   ["","d","da","dar","dark"]
16:50:09 <dark> hm o.o
16:50:32 <Eduard_Munteanu> > tails "dark"
16:50:33 <lambdabot>   ["dark","ark","rk","k",""]
16:50:40 <Kaidelong> @src inits
16:50:40 <lambdabot> inits []     =  [[]]
16:50:41 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
16:51:00 <Kaidelong> lovely
16:51:19 <Eduard_Munteanu> > map inits $ tails "dark"
16:51:19 <lambdabot>   [["","d","da","dar","dark"],["","a","ar","ark"],["","r","rk"],["","k"],[""]]
16:51:46 <Eduard_Munteanu> > concatMap inits $ tails "dark"
16:51:47 <lambdabot>   ["","d","da","dar","dark","","a","ar","ark","","r","rk","","k",""]
16:52:06 <dark> I think that with tail it would be easier, thanks. maybe i need to chain two maps or something
16:52:17 <dark> tails
16:52:26 <Eduard_Munteanu> What do you need exactly?
16:54:02 <dark> Actually what i need is.. inits. I need to match a command from a prefix. powerset doesn't make sense at all, and would explode in front of me if it were working :P
16:54:40 <Kaidelong> @ty let pset xs = case xs of { [] -> [[]]; (x:xs) -> (x:xs) : ((pset (xs)) ++ (map (x:) (drop 1 (pset xs)))) } in pset
16:54:41 <lambdabot> forall a. [a] -> [[a]]
16:54:58 <Kaidelong> let pset xs = case xs of { [] -> [[]]; (x:xs) -> (x:xs) : ((pset (xs)) ++ (map (x:) (drop 1 (pset xs)))) } in pset [1..5]
16:55:12 <Eduard_Munteanu> dark: sort of autocompletion/abbreviations?
16:55:18 <dark> Eduard_Munteanu, yes
16:55:38 <dark> I then use lookup from prelude
16:55:39 <dark> > let pset xs = case xs of { [] -> [[]]; (x:xs) -> (x:xs) : ((pset (xs)) ++ (map (x:) (drop 1 (pset xs)))) } in pset [1..5]
16:55:39 <Kaidelong> @botsnack
16:55:39 <lambdabot> :)
16:55:41 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[],[4],[3,5],[3],[3,4],[2,4,5],[2,...
16:55:52 <Eduard_Munteanu> Hrm... maybe you could use a tree of some sort.
16:56:01 <Xilon> dark: wouldn't a trie be perfect for that?
16:56:06 <xl> :/
16:56:13 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Prefix_tree
16:56:23 <Eduard_Munteanu> or a trie as Wikipedia says.
16:56:30 <Kaidelong> > let pset xs = case xs of { [] -> [[]]; (x:xs) -> (x:xs) : ((pset (xs)) ++ (map (x:) (drop 1 (pset xs)))) } in length $ pset [1..5]
16:56:32 <lambdabot>   32
16:56:37 <Kaidelong> so there are some duplicates
16:56:38 <Kaidelong> shame
16:56:46 <Kaidelong> > let pset xs = case xs of { [] -> [[]]; (x:xs) -> (x:xs) : ((pset (xs)) ++ (map (x:) (drop 1 (pset xs)))) } in length . nub $ pset [1..5]
16:56:48 <lambdabot>   32
16:56:54 <Kaidelong> oh!
16:56:57 <Kaidelong> right, lists are ordered
16:57:01 <dark> uhm, yes, but I suppose this would means adding one more external package
16:57:16 <Kaidelong> > let pset xs = case xs of { [] -> [[]]; (x:xs) -> (x:xs) : ((pset (xs)) ++ (map (x:) (drop 1 (pset xs)))) } in length . nub . fmap sort $ pset [1..5]
16:57:18 <lambdabot>   32
16:57:24 <Eduard_Munteanu> dark: it's easy to make your own
16:58:07 * Kaidelong wonders what the problem is here
16:58:23 <Kaidelong> I thought that should be 5^2 and not 2^5
16:58:28 <Kaidelong> or am I wrong?
16:59:10 <Bynbo7> powersets are always 2^n
16:59:13 <Kaidelong> oh
16:59:19 <Kaidelong> so I was just wrong and the code was fine
16:59:20 <Kaidelong> ok
16:59:41 <Eduard_Munteanu> Even the notation 2^A, where A is a set suggests so :)
17:00:19 <Kaidelong> I have a habit of confusing things like that
17:00:54 <Kaidelong> > let pset xs = case xs of { [] -> [[]]; (x:xs) -> (x:xs) : ((pset (xs)) ++ (map (x:) (drop 1 (pset xs)))) } in length $ pset [1..10]
17:00:55 <lambdabot>   1024
17:00:58 <Kaidelong> yay
17:08:34 <dark> @type concat $ map (\(x, s) -> map (\a -> (a, s)) $ inits x) rs
17:08:35 <lambdabot> forall t. (Num t) => [([Char], t)]
17:08:38 <dark> @type concat $ map (\(x, s) -> map (\a -> (a, s)) $ inits x)
17:08:39 <lambdabot>     Couldn't match expected type `[[a]]'
17:08:39 <lambdabot>            against inferred type `[([a1], t)] -> [[([a1], t)]]'
17:08:39 <lambdabot>     In the second argument of `($)', namely
17:09:05 <dark> how is that I can't define list' = concat $ map (\(x, s) -> map (\a -> (a, s)) $ inits x) but list' a = concat $ map (\(x, s) -> map (\a -> (a, s)) $ inits x) a works?
17:10:13 <Bynbo7> because $ is not the same as (.)
17:10:49 <dark> oh. so concat . map .. would work
17:10:58 <Bynbo7> you're applying concat to the first map, not the result of applying the map to a list and then giving it to concat
17:11:01 <Bynbo7> i think so
17:15:50 <augur> anyone know how to eliminate postconditions?
17:16:01 <dark> what is a postcondition?
17:16:26 <augur> a condition that is required to hold after some operation is performed, in order for the operation to be performable at all
17:17:17 <Bynbo7> augur: in what context
17:17:38 <augur> any, i suppose
17:17:51 <augur> im curious about techniques for turning post conditions into preconditions
17:18:42 <ddarius> You just push them through using Hoare triples.
17:18:56 <Kaidelong> why'd you want to get rid of postconditions?
17:19:01 <Kaidelong> they're testable at least
17:19:38 <Bynbo7> i don't think that removing post conditions is a very useful thing at all, because then you've lost all guarantees about what the code does
17:20:07 <ddarius> Bynbo7: Removing them isn't.  Translating them into post-conditions is fine.
17:20:35 <Bynbo7> huh?
17:20:45 <ddarius> s/post/pre/
17:21:08 <roconnor> @pl (\x -> h x a)
17:21:09 <lambdabot> flip h a
17:21:25 <ddarius> Bynbo7: augur's first question didn't make much sense.  His last sentence made a bit more sense.
17:22:19 <drhodes> if functions g and h rely on the postcondition of f, then g and h would need to both roll that into their preconditions, that's the idea, right?
17:23:26 <edu-rj> hi
17:23:29 <edu-rj> testingo
17:23:50 <ddarius> drhodes: I believe he wants something more the other way.  If I assert that after executing f a certain post-condition must hold, what pre-condition is required to guarantee it?
17:24:43 <augur> ddarius: hoare triples?
17:26:23 <augur> oic
17:26:33 <Bynbo7> {precond}program{postcond}
17:26:54 <ddarius> (In particular, Dijkstra's weakest precondition approach seems relevant.)
17:28:33 <cocon> is it possible to write GADT for the simply typed lambda calculus, indexed by the type?
17:28:40 <cocon> variables seem to cause trouble
17:29:09 <dark> I had a code with State and IO and was trying to convert to StateT m IO n. I expected a lot of headache with type errors. but the sole thing I changed was let (a, s) = runState (command $ c) state to (a, s) <- runStateT (command $ c) state. I haven't used lift a single time and my IO code doesn't reflect StateT in its type. Am I using StateT "right"?
17:29:39 <dark> should a more complex use actually show any use for "lifting the IO functions while inside the StateT"?
17:30:17 <ddarius> Why did you convert to StateT IO?
17:30:20 <Eduard_Munteanu> Maybe you used liftIO?
17:30:40 <Saizan> cocon: you've to index by the typing context too
17:30:45 <dark> I'm.. not sure, I wanted to learn it. someone said it was better. (and that $ was gratuitous too btw)
17:30:57 <dark> Eduard_Munteanu, no.. not a single lift or liftIO
17:31:18 <dark> the (a, s) <- .. receives an StateT, but it equals IO (a, s) so it is all ok..
17:31:30 <Eduard_Munteanu> Oh, you probably used IO outside of runStateT
17:31:40 <dark> yes
17:31:46 <cocon> Saizan: I briefly thought of that, but that seems very hard
17:31:49 <cocon> any hints?
17:31:52 <Eduard_Munteanu> Well if you want to use it inside you kinda have to lift.
17:32:05 <dark> should I make use of IO *inside* the monad passed to runStateT, to make StateT "useful"?
17:32:30 <Eduard_Munteanu> Well, kinda. Otherwise it's just State, not StateT.
17:32:45 <dark> I have no use for IO inside it. I think..
17:32:55 <Eduard_Munteanu> Then you have no use for StateT :)
17:33:36 <ddarius> If you can write what you want with just State then you don't need StateT unless you are manually passing the in the IO code.
17:33:59 <dark> what I wanted to do was to get rid of a handler function, in the IO part, that gets the state as parameter and do IO. I think with StateT I can avoid getting the state as parameter. Then maybe the handler would be a StateT itself, and since it does IO, it would need lift..
17:34:51 <ddarius> If you are doing something like do someIoAction; let (a, s) = runState m 0; anotherIoAction; let (b, s') = runState m2 s; etc. then that can be simplified with StateT. 
17:34:52 <Saizan> cocon: data Expr :: * -> * -> * where Var :: Var g a -> Expr g a; App :: Expr g (a -> b) -> Expr g a -> Expr g b; Lam :: Expr (a , g) b -> Expr g (a -> b); data Var :: * -> * -> * where Top :: Var (a , g) a; Pop :: Var g a -> Var (b , g) a
17:35:33 <dark> (it isn't getting in my way, but, in a earlier functional code, I was passing the state manually through like 10 functions. it became a lot of crufted, and I'm trying to learn how to effectively get away with state-passing in a functional program)
17:35:50 <thatBlueThing> dankna: though you are correct; I'm being redundant in including Main twice
17:36:15 <dark> (It was in ocaml. I was told that in haskell monads prevent it)
17:36:22 <dabblego> dark: interesting, I am giving a talk on exactly this on Monday
17:36:28 <dabblego> yes, the reader monad
17:36:37 <dabblego> (which you can also write in ocaml)
17:36:41 <cocon> Saizan: very nice!!
17:36:43 <cocon> thank you
17:37:04 <cocon> I didn't think of the unary representation of DeBruijn indices...
17:37:31 <dark> the.. reader monad?
17:37:51 <dabblego> dark: do you know (>>=) function?
17:37:53 <Saizan> yeah, it's quite cool that it corresponds to the type of membership proofs
17:37:55 <dark> uhimes my functions only read the state. other times
17:38:08 <dark> (partial message, sorry)
17:38:11 <dark> dabblego, yes
17:38:38 <dark> sometimes my functions only read the state. other times, it also "writes" (by returning the state, and then manually feeding it in the next loop iteration)
17:38:48 <dabblego> dark: assuming you do not modify the value to read (that would be state), then replace every occurrence of m with ((->) t)
17:38:56 <dark> it was, quite literally, the state monad unfolded
17:39:00 <dabblego> dark: right, that's another monad again (State)
17:39:29 <dark> replace every occurence of m where?
17:39:37 <dabblego> @type (>>=)
17:39:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:39:40 <dabblego> there
17:40:11 <dark> Reader = ((->) t) ?
17:40:24 <dabblego> yes
17:40:56 <dabblego> (t -> a) -> (a -> t -> b) -> t -> b
18:02:19 <augur> Saizan: :\
18:02:23 <augur> this is so frustrating
18:02:30 <dark> I have this loop: forever f s = f s >>= \s' -> forever f s' (I defined my own because I couldn't make the standard forever to work). But what I need isn't really forever: s is a state, and if s is Exit, it should quit. currently f, that returns an IO monad, calls System.Exit.exitSuccess. if I wanted to not call exit directly, forever should somehow check s himself, right? how is this usually modeled?
18:03:43 <dark> I was struggling to think how to make this work with this forever, and then give up
18:04:39 <cocon> Saizan: was that GADT previously mentioned somewhere or did you just come up with it?
18:05:24 <dabblego> dark: yourForever = fmap forever
18:06:26 <allbery_b> also, look at Control.Monad.guard, Control.Monad.when, Control.Monad.unless
18:07:27 <dark> you mean, theForeverINeed = fmap thisForeverIHave, or thisForeverIHave = fmap theStandardForever?
18:07:50 <dibblego> the latter
18:08:01 <dark> I came out with forever p f s = f s >>= \s' -> if p s' then forever f s' else return
18:08:17 <dark> then forever p f s' ..
18:08:20 <dibblego> you want to look at the combinators that allbery_b gave
18:10:27 <dark> oh. my insertion looks like a when
18:11:42 <dark> I think that in order to type check it will actually need, like, return () instead, and this is when (p s') $ forever p f s'
18:11:46 <dark> @src when
18:11:46 <lambdabot> when p s = if p then s else return ()
18:15:50 <dark> now, guard, how would I use it? forever p f s = do { s' <- f s; guard $ not $ p s'; forever p f s' } ?
18:16:23 <monochrom> guard is useful for MonadPlus only
18:16:28 <dark> I read something about how guard works, in the wikibooks book, and it just made things more confuse
18:16:51 <monochrom> and even then it may or may not mean what you want. summary: is mzero what you want?
18:16:53 <dark> I'm working with StateT and IO
18:17:06 <dark> uhm, what means this program: main = mzero ?
18:17:06 <monochrom> they are not even MonadPlus
18:17:16 <dark> oh
18:17:30 <monochrom> no mzero for IO. end of worries.
18:18:14 <monochrom> IO's forever does not quit, except for exceptions.
18:18:54 <dark> not even execing System.Exit.exitSuccess?
18:19:04 <monochrom> oh oops, that quits, yes.
18:20:24 <monochrom> but ghc conspires to save my strong assertion by using an exception to implement exitSuccess
18:22:31 <dark> sometimes I write a = do something
18:23:57 <ddarius> @instances MonadPlus
18:23:58 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
18:24:33 <monochrom> aww, sorry
18:25:13 <dark> so what is mzero? is it just a nop that won't otherwise short-circuit the path?
18:25:45 <monochrom> eh? which module defines "instance MonadPlus IO"?
18:25:53 <dark> I think that it is the contrary: mzero is supposed to short-circuit and return () will let the flow continue..
18:25:59 <dark> @src guard
18:25:59 <lambdabot> guard True  =  return ()
18:26:00 <lambdabot> guard False =  mzero
18:26:42 <dark> so do { a; mzero; b } is supposed to don't do b..
18:27:11 <monochrom> under suitable circumstances, it loses a too.
18:27:30 <monochrom> > Just "hey" >> mzero
18:27:31 <lambdabot>   Nothing
18:27:59 <monochrom> > do { x<-[1,2,3]; mzero; return 4 }
18:27:59 <lambdabot>   []
18:28:40 <monochrom> "instance MonadPlus IO" is not in Prelude or Control.Monad or System.IO
18:29:04 <dark> http://hackage.haskell.org/packages/archive/mtl/1.1.1.0/doc/html/src/Control-Monad-Error.html it's here
18:29:40 <dark> at ghci: let a = do { putStrLn "teste"; mzero; putStrLn "hah" } , teste
18:29:40 <dark> *** Exception: user error (mzero)
18:30:03 <monochrom> then IO's mzero there throws an exception
18:30:19 <xenocryst> is there a way for list comprehensions to terminate with an infinite sequence? For example, [x | x <- fibonacci_seq, x <= 100]
18:30:45 <dark> I don't want my program to end with this message :t but when doesn't display messages on failure=)
18:30:46 <dibblego> xenocryst: there is a take function, perhaps you want that
18:30:57 <dibblego> > take 10 [1..]
18:30:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:31:05 <monochrom> you can catch exceptions
18:31:18 <dark> xenocryst, the constraint x <= 100 at the comprehension itself seems like a guard
18:31:49 <xenocryst> ah, ok. Thanks guys! I am approaching this problem the wrong way
18:31:51 <dark> monochrom, I heard it was somewhat esoretic / not very haskellish
18:31:54 <dibblego> xenocryst: there is also takeWhile
18:32:13 <dibblego> > takeWhile even ([2,4,6,8,4,6,8] + [1..])
18:32:14 <lambdabot>   No instance for (GHC.Num.Num [a])
18:32:14 <lambdabot>    arising from a use of `e_124684681' at...
18:32:17 <dibblego> > takeWhile even ([2,4,6,8,4,6,8] ++ [1..])
18:32:18 <dark> xenocryst, no, I mean, if I knew more haskell, I could write the code the way you wrote, except it would work
18:32:19 <lambdabot>   [2,4,6,8,4,6,8]
18:32:21 <ion> let darksFunction p f = fix $ \loop s -> f s >>= liftM2 when p loop in (>= 0) (\n -> print n >> return (n-1)) 5
18:32:26 <monochrom> forever (do { s<-getLine; guard (not (null s)) }) `catch` (\e -> putStrLn "finally!")
18:32:46 <monochrom> I am non-partisan and I diss ideologies.
18:33:38 <xenocryst> dibblego: takeWhile seems like exactly what I am looking for. Thank you!
18:33:47 <dibblego> xenocryst: no worries mate
18:33:50 <monochrom> but of course there are more efficient ways to quit a loop than exceptions
18:35:01 <ion> in (>= 0)    in darksFunction (>= 0)
18:35:46 <dark> oh, it looks like guards won't work with infinite sequences. o.o
18:36:00 <monochrom> "in darkness bind them"? :)
18:38:36 <Ptival> is there a way to hide a Prelude function?
18:39:03 <Ptival> (maybe it's wrong habit...)
18:39:51 <monochrom> import Prelude hiding (id, seq, ($), ($!), fmap)
18:40:15 <Ptival> oh ok :)
18:40:20 <Ptival> thanks
18:45:28 <roconnor> fmap g (f <*> x)  = (fmap (g .) f) <*> x  -- is the free?
18:45:36 <Ptival> :t (<<=)
18:45:38 <lambdabot> Not in scope: `<<='
18:46:08 <roconnor> g <$> (f <*> x)  = (g .) <$> f <*> x  -- is the free?
18:46:20 <Ptival> :t (=<<)
18:46:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:49:45 <Ptival> is there no difference between return =<< m and m >>= return? Which one looks best? :)
18:50:02 <roconnor> Ptival: m is better
18:50:12 <Ptival> oh
18:50:14 <monochrom> heheh
18:50:25 <Ptival> right...
18:51:42 <dark> I think >>= is such a beautiful name for an operator
18:54:37 <Ptival> I think it's a good representation of what it does
18:55:29 * roconnor is unable to prove his theorem.
18:55:45 <Kaidelong> perhaps you do not have an applicative functor then?
18:55:52 <roconnor> nah
18:56:04 <roconnor> the rest of the theory is so beautiful, it has to be true :D
18:56:18 <dark> @hoogle liftIO
18:56:18 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
18:56:39 <Kaidelong> dark: mostly a way to deal with monads that control IO
18:56:41 <roconnor> hmm twanvl doesn't have a proof in his blog :(
18:57:40 <dark> no, I understood that within StateT m IO I would use liftIO to do IO
18:57:54 <dark> I just need to please the compiler now
18:58:34 <Eduard_Munteanu> I'm not sure why there's a separate lift for IO.
18:59:15 <dark> performance?
19:00:15 <Eduard_Munteanu> :t Control.Monad.Trans.lift
19:00:16 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
19:00:20 <Kaidelong> dark: yes
19:00:32 <Kaidelong> or so I've been told, anyway
19:00:36 <Eduard_Munteanu> Really, how so?
19:00:51 <Eduard_Munteanu> Also, the type sig for liftIO looks a bit unsafe.
19:00:57 <Kaidelong> IO has a co-point but it breaks purity if you use it in pure code
19:01:07 <Kaidelong> but if you go into another impure monad
19:01:10 <Kaidelong> it is fine to use it there
19:01:42 <Kaidelong> I imagine keeping a monad transformer around is more costly than just changing the wrapper
19:01:56 <Eduard_Munteanu> > lift $ putStrLn "Hello" :: Identity ()
19:01:56 <lambdabot>   Ambiguous occurrence `lift'
19:01:56 <lambdabot>  It could refer to either `Control.Monad.Trans....
19:02:02 <Eduard_Munteanu> > liftIO $ putStrLn "Hello" :: Identity ()
19:02:03 <lambdabot>   Ambiguous occurrence `liftIO'
19:02:03 <lambdabot>  It could refer to either `Control.Monad.IO.C...
19:02:13 <Kaidelong> @instances-importing MonadIO
19:02:13 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
19:02:22 <Eduard_Munteanu> > Control.Monad.Trans.liftIO $ putStrLn "Hello" :: Identity ()
19:02:22 <lambdabot>   Not in scope: `Control.Monad.Trans.liftIO'
19:02:32 <Kaidelong> well all of those are transformers
19:02:42 <Kaidelong> but "Orc" that we spoke of yesterday
19:02:55 <Kaidelong> is a MonadIO that is not a monad transformer
19:03:07 <Eduard_Munteanu> Well it still looks unsafe, say I use StateT s Identity
19:03:45 <Kaidelong> @src liftIO (StateT s m)
19:03:46 <lambdabot> Source not found. My mind is going. I can feel it.
19:03:57 <Kaidelong> @src (StateT s m) liftIO
19:03:57 <lambdabot> Source not found.
19:04:01 <Kaidelong> halp
19:04:08 <Eduard_Munteanu> :t liftIO
19:04:09 <lambdabot>     Ambiguous occurrence `liftIO'
19:04:09 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
19:04:09 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
19:04:15 <Kaidelong> @src StateT liftIO
19:04:15 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:04:21 <Eduard_Munteanu> :t Control.Monad.Error.liftIO
19:04:22 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
19:04:59 <Eduard_Munteanu> > Control.Monad.Error.liftIO putStrLn "Hello" :: StateT Int Identity ()
19:05:00 <lambdabot>   Couldn't match expected type `GHC.Types.IO
19:05:00 <lambdabot>                                 ...
19:05:11 <Eduard_Munteanu> > Control.Monad.Error.liftIO $ putStrLn "Hello" :: StateT Int Identity ()
19:05:12 <lambdabot>   No instance for (Control.Monad.IO.Class.MonadIO
19:05:12 <lambdabot>                     Data.Fu...
19:05:22 <Eduard_Munteanu> Anyway.
19:06:06 <Eduard_Munteanu> I thought that would recover unsafePerformIO
19:06:25 <dark> @type unsafePerformIO
19:06:26 <lambdabot> Not in scope: `unsafePerformIO'
19:06:33 <Eduard_Munteanu> :t unsafePerformIO
19:06:34 <lambdabot> Not in scope: `unsafePerformIO'
19:06:38 <Eduard_Munteanu> WTH?
19:06:44 <Eduard_Munteanu> it's simply   IO a -> a
19:06:44 <dark> IO a -> a
19:06:47 <dark> Hmm. o.o
19:07:04 <dark> so I could.. do I/O in pure code?!
19:07:16 <dibblego> uh oh
19:07:17 <Eduard_Munteanu> No, it breaks in many cases.
19:07:28 <dibblego> dark: you were not meant to see that
19:07:37 <Eduard_Munteanu> Some things work though, like Debug.Trace
19:07:54 <Eduard_Munteanu> :t trace
19:07:55 <lambdabot> Not in scope: `trace'
19:08:25 <Eduard_Munteanu> Yeah, you'd better forget about unsafePerformIO.
19:08:34 <dark> Indeed, it is possible to write coerce :: a -> b with the help of unsafePerformIO
19:08:38 <dark> .o
19:09:14 <Eduard_Munteanu> dark: yeah, consider writing to a buffer and reading it back in another interpretation.
19:12:27 <Eduard_Munteanu> The problem here is referential transparency: Haskell assumes (unlike many languages) that evaluating a given term always yields the same result. If it doesn't, it breaks.
19:31:27 <roconnor> writing coerce with unsafePerformIO is GHC specific
19:31:41 <roconnor> It doesn't work in Yhc IIRC.
19:32:08 <roconnor> because polymorphic values are functions
19:32:12 <roconnor> or maybe it was JHC
19:32:31 <Ptival> :info Arbitrary
19:33:16 <Ptival> :t forM
19:33:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
19:34:30 <Ptival> :t all
19:34:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:34:42 <Ptival> :t all id
19:34:44 <lambdabot> [Bool] -> Bool
19:35:09 <copumpkin> :t and
19:35:10 <lambdabot> [Bool] -> Bool
19:35:24 <Ptival> :)
19:41:46 <dark> @src forM
19:41:47 <lambdabot> forM = flip mapM
19:41:52 <dark> @src mapM
19:41:52 <lambdabot> mapM f as = sequence (map f as)
19:42:00 <dark> @src sequence
19:42:01 <lambdabot> sequence []     = return []
19:42:01 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:42:01 <lambdabot> --OR
19:42:01 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:42:56 <dark> @type mapM
19:42:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:43:01 <dark> @type sequence
19:43:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:45:20 <dark> > forM [1, 2, 3 3] $ \x -> Just x
19:45:22 <lambdabot>   Just [1,2,3]
19:45:28 <Ptival> :t \x y -> x || y
19:45:29 <lambdabot> Bool -> Bool -> Bool
19:45:32 <Ptival> :t (||)
19:45:34 <lambdabot> Bool -> Bool -> Bool
19:46:20 <dark> @instances Monad
19:46:21 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
19:46:56 <dark> > forM [Nothing, Just 1, Just 2] id
19:46:57 <lambdabot>   Nothing
19:47:09 <dark> > forM [Just 1, Just 2] id
19:47:10 <lambdabot>   Just [1,2]
19:47:23 <dark> > forM [Just 1, Just 2, Nothing, Just 3] id
19:47:24 <lambdabot>   Nothing
20:00:56 <Ptival> @hoogle test
20:00:57 <lambdabot> Test.HUnit.Base test :: Testable t => t -> Test
20:00:57 <lambdabot> Test.HUnit.Base data Test
20:00:57 <lambdabot> Test.QuickCheck class Testable a
20:01:06 <Ptival> @hoogle a -> [a]
20:01:08 <lambdabot> Prelude repeat :: a -> [a]
20:01:08 <lambdabot> Data.List repeat :: a -> [a]
20:01:08 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
20:09:43 <Ptival> :t forM [1..n]
20:09:45 <lambdabot> forall (m :: * -> *) b. (Monad m) => (Expr -> m b) -> m [b]
20:52:32 <p123> hi
20:52:57 <p123> anyone out there?
21:03:19 <Sgeo> Leksah seems to be having trouble not randomly dying
21:03:59 <Sgeo> Ah, that's why
21:05:03 * hackagebot yajl-enumerator 0.4 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.4 (JohnMillikin)
21:24:45 <co_dh> greeting, I just found the reverse function is an endo , contravariant functor , am I right ? 
21:25:29 <dibblego> co_dh: where did you find that?
21:25:38 <dibblego> Endo is an exponential functor, not contravariant
21:25:46 <co_dh> I find  it myself. 
21:25:57 <dibblego> where?
21:26:15 <co_dh> maybe I use the wrong term for endo . for endo , I  mean a functor from a Category C to itself. 
21:26:21 <dibblego> contravariant means F x -> (y -> x) -> F y
21:26:45 <co_dh> see:  reverse (xs ++ ys ) = reverse ys ++ reverse xs
21:27:38 <co_dh> the arrow (morphism)  in  this cateogry are [a], composition is ++ , and id is [] 
21:34:08 <co_dh> ?
21:35:56 <dolio> Yes, any monoid can be turned into a category, and monoid morphisms are functors for those categories.
21:37:10 <co_dh> thanks dolio. 
21:37:42 <co_dh> another question: is reverse the only contra variant functor of above category? 
21:38:02 <dolio> No.
21:38:31 <co_dh> endo, contravariant functor.  ( I forget the endo above)
21:38:38 <dolio> Still no.
21:38:44 <co_dh> dolio: can you give an counter example? 
21:38:55 <rwbarton> you could map everything to []
21:39:08 <dolio> const [] [] = [], const [] (xs ++ ys) = const [] ys ++ const [] xs
21:39:25 <co_dh> rwbarton, dolio: thanks !
21:39:25 <dolio> Also, you can compose any covariant morphism with reverse.
21:39:37 <dolio> On either side.
21:41:04 <co_dh> If I add: reverse [x] = [x], can that uniquely determine reverse function? 
21:41:54 <dolio> Probably.
21:42:37 <co_dh> I think we can prove it by induction. 
21:43:14 <co_dh> reverse [x] ++ [y] = reverse [y] ++ reverse [x] = [y,x]
21:43:50 <dolio> f [] = [] ; f (x:xs) = f ([x] ++ xs) = f xs ++ f [x] = f xs ++ [x]
21:43:57 <dolio> Which is a definition for reverse.
21:44:08 <co_dh> In fact, I'm reading the quickCheck: A lightweight tool for random testing of haskell programs. 
21:46:22 <co_dh> how many endo contravariant functors of above category are there ? 
21:48:37 <co_dh> in fact, I can map [x] -> [1]  for all [x]
21:48:38 <dolio> These homomorphisms are determined by where they take single element lists.
21:49:25 <co_dh> dolio: thanks. interesting. 
21:49:32 <dolio> If f [x] = g x, then f [] = [] by necessity, and f (x:xs) = f ([x] ++ xs) = f xs ++ g x, which defines f by induction.
21:50:29 <dolio> So there are as many as there are functions g : A -> [A].
21:50:51 <co_dh> agree, thanks. 
21:50:58 <dolio> If you're limited to not being able to inspect A, there are only 2. g x = [x] and g x = [].
21:51:01 <co_dh> dolio: may I ask your backgroud? math? 
21:51:23 <dolio> I studied computer science, but I took more math classes than were strictly necessary.
21:51:37 <dolio> And I learn stuff on my own.
21:51:45 <co_dh> I found #haskell is a good place to ask math , lol. 
21:52:22 <dolio> Oh, actually, I'm wrong.
21:52:25 <dolio> There are infinitely many.
21:52:37 <dolio> g x = [x,x], g x = [x,x,x], ...
21:52:38 <co_dh> even if you can not inspect A ? 
21:52:53 <co_dh> yep :)
21:53:42 <co_dh> then another question : how do you know if the laws are complete ? 
21:53:55 <co_dh> is there any mathematics about this? 
21:54:52 <co_dh> I mean , 2 laws can specify reverse function ,  but for example, I might just specify the endo functor law, how can I know that I am wrong? 
21:55:46 <dolio> You mean, how can you tell that f [] = [], f (xs ++ ys) = f ys ++ f xs doesn't determine f = reverse?
21:55:48 <co_dh> Is that logic goes? 
21:55:55 <co_dh> yes. 
21:57:52 <dolio> I don't think I have an answer for that.
21:58:31 <dolio> Well...
21:58:46 <dolio> [A] is the free monoid over A.
22:10:10 <co_dh> In fact, I still have question : in the category of ([A], ++, [] ) , what is the object ? 
22:10:57 <co_dh> for example, [1,2,3] is a morphism, so does [4,5] , but what is the object ? 
22:11:38 <co_dh> and a morphism always has a  domain and codomain, but , what's the domain of [1,2,3]??
22:11:55 <dolio> The object is arbitrary.
22:12:27 <co_dh> dolio: give a concrete example please.
22:12:28 <dolio> In theory you can have infinitely many categories for each monoid, with different objects but the same arrows.
22:12:51 <dolio> An example?
22:13:02 <copumpkin> co_dh: the object is a pineapple
22:13:04 <co_dh> I see. you can use "abc" as the only object . right?
22:13:21 <co_dh> I see, thanks, guys. 
22:13:21 <dolio> The object is the number 5. Morphisms 5 -> 5 are lists, identity is [], composition is ++.
22:13:25 <augur> copumpkin!
22:13:31 * augur eats copumpkin's pineapple
22:13:35 <rwbarton> usually one would call it something like *
22:13:39 <copumpkin> o.O
22:13:47 <copumpkin> rwbarton: I prefer pineapples
22:13:50 <copumpkin> but augur just ate mine :(
22:14:17 <augur> whats with the pineapple thing anyway
22:14:31 <copumpkin> it's tasty
22:14:42 <augur> yes well
22:15:08 <co_dh> so , in fact, it's the morphism that important,  
22:15:11 <co_dh> not the object. 
22:15:17 <copumpkin> that's generally true
22:16:03 <rwbarton> if you only have one object, how important could it be what you call it
22:16:08 <Veinor> isn't that true in general in category theory? :D
22:21:57 <co_dh> Can I define reverse as a catamorphism? 
22:22:06 <co_dh> I tried, but . 
22:22:09 <dolio> Yes.
22:22:26 <co_dh> reverse x : xs  =  reverse xs : reverse x   is wrong. 
22:22:46 <co_dh> dolio: how? 
22:23:01 <augur> so, initial/final algebras are about induction, yes? someone point me in the direction of a paper or 10 that introduces the concept?
22:23:18 <augur> or, well, F algebras rather
22:23:30 <dolio> co_dh: There was one in the discussion above.
22:23:48 <dolio> reverse [] = [] ; reverse (x:xs) = reverse xs ++ [x]
22:23:51 <dolio> That's slow, though.
22:24:43 <dolio> An Introduction to (Co)Algebras and (Co)Induction ...
22:24:48 <augur> reverse' [] ys = ys ; reverse' (x:xs) ys = x:ys
22:24:55 <co_dh> I want something as F algebras. like map [] to [],  : to what ? 
22:25:31 <augur> actually it should be the other way round
22:25:40 <dolio> f [] = z ; f (x:xs) = g x (f xs) ==> f = foldr g z
22:25:52 <augur> reverse' xs [] = xs ; reverse' xs (y:ys) = reverse' (y:xs) ys
22:25:58 <augur> then you can say reverse = reverse' []
22:26:05 <dolio> A Tutorial on (Co)Algebras and (Co)Induction.
22:26:17 <augur> thank you dolio :p
22:26:23 <dolio> There are probably more.
22:29:53 <co_dh> If I define data List1 a = [a] | [a] ++ List1 a , I can define reverse as catamorphism that map [] to [], (++) to swap (++)
22:30:03 <co_dh> where swap is defined swap f x y = f y x 
22:30:42 <co_dh> but how can I define reverse as that on List ? 
22:31:27 <Chaps> in the guide to monads at http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html , there is a section under "Side Effects: Debugging Pure Functions" that says "We can draw this diagrammatically as".  Can someone explain how the diagram relates to the preceeding paragraph?
22:31:57 <Chaps> in particular, how does it relate to: f',g' :: Float -> (Float,String)
22:32:24 <dolio> co_dh: You cannot define it that way for cons lists, because the only way Haskell allows you to define functions is by matching against their constructors.
22:32:30 <dolio> Not by arbitrary decomposition.
22:34:50 <Veinor> Chaps: you can think of f' as a 'box' that takes one input and returns two outputs
22:34:54 <Veinor> the outputs are f x and "f was called"
22:35:28 <Veinor> except since functions can only return a single value you have to tuple them together :)
22:36:04 <Chaps> so is it essentially a diagram of a recursive function?
22:36:16 <Veinor> no, f' and f are different functions
22:37:15 <Chaps> do not get :$
22:42:28 <reltuk> x goes into the function f' and the result is two values, f x and the string "f was called."
22:43:47 <Chaps> how did the string 'f was called' get in there?
22:43:54 <Chaps> was x = 'f was called'?
22:44:00 <reltuk> it's part of the output of f'
22:44:31 <reltuk> no, it's always part of the output...f' is like f except it returns two values, the seond of which is always returns "f was called."
22:57:39 <hskltyp> ping
22:58:00 <Veinor> pong
23:06:21 <augur> dolio: hm
23:07:22 <augur> dolio: im not sure this is quite what i need. :\
23:08:47 <augur> oh wait, maybe it is :D
23:09:08 <augur> section 5 maybe
23:22:15 <jystic> @pl f x = te x == "abc"
23:22:16 <lambdabot> f = ("abc" ==) . te
23:27:46 <augur> jystic: cmon, that shouldve been easy
23:29:12 <augur> f x = te x == "abc"   =>   f x = "abc" == te x   =>   f x = ("abc" ==) (te x)   f x = (("abc" ==) . te) x   f = ("abc" ==) . te
23:30:14 <Jafet> f (te -> "abc") = True
23:30:45 <augur> jystic: whats this -> operator you're using
23:30:50 <augur> :t (->)
23:30:51 <lambdabot> parse error on input `->'
23:31:00 <augur> > te -> "abc"
23:31:00 <lambdabot>   <no location info>: parse error on input `->'
23:31:03 <augur> :|
23:31:05 <augur> bad Jafet
23:31:28 <Jafet> Don't worry, my code was more pointless than yours
23:31:37 <augur> i can agree with that.
23:32:37 <Jafet> {-# ViewPatterns #-}
23:34:04 <btutt> I'm liking ViewPatterns
23:35:37 <btutt> Blah (== . Data.Text.Text.pack $ "foo" -> True) -> blahblah
23:39:22 <jystic> augur: if i didn't ask lambdabot to do my simple pointless conversions then no one would have anything to talk about :)
23:39:28 <jystic> but you're right, next time i shouldn't be so lazy
