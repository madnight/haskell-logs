00:00:02 <Kaidelong> or would you need a type level equivalent of flip?
00:00:09 <almostsix> Indeed not. It isn't a functor over anything
00:00:33 <Kaidelong> oh right
00:00:37 <c_wraith> Kaidelong: You need a wrapper with a phantom type to make it a functor.  And then that instance doesn't do anything, because the phantom type is never present.
00:00:48 <Kaidelong> well alright
00:01:17 <Kaidelong> in that case I suppose you could use a more verbose name than map
00:01:26 <Kaidelong> since you are doing something more specific
00:01:59 <Tomsik> aren't elements of the bytestring always the same type
00:03:44 <Jonno_FTW> see
00:04:00 <Jonno_FTW> it's quite annoying when you want to test a function like this: board `C.elem` $ C.filter (\x-> "class=\"boardlink\"" `C.elem` $ C.words x) $ C.lines s
00:10:42 <ManateeLazyCat> soul: It's me
00:11:06 <Tomsik> Jonno_FTW: "modfiyBS"? :p
00:12:48 <Jonno_FTW> @hoogle modifyBS
00:12:48 <lambdabot> No results found
00:13:08 <Tomsik> nah, just proposing a name
00:13:15 <Jonno_FTW> ahh
00:14:01 <Kaidelong> Tomsik: I like it
00:15:03 <Kaidelong> then again, "liftByteString" might be more sensible
00:18:05 <Jonno_FTW> could installing ghc 7.0.1 break my platform installation?
00:18:58 <Heffalump> it would probably override which GHC was on the path
00:19:05 <Heffalump> other than that it shouldn't cause any problems
00:19:15 <Jonno_FTW> i just want to use the latest ghci
00:19:37 <Heffalump> but the older ghc to compile things?
00:19:44 <Jonno_FTW> well
00:20:01 <Jonno_FTW> is code compatible between 6 and 7?
00:20:24 <Heffalump> mostly (and entirely if you're using standard Haskell rather than GHC extensions)
00:20:31 <Jonno_FTW> ok
00:20:37 <Jonno_FTW> I guess I'll move over to 7 then
00:20:48 <Heffalump> object code isn't, so if you compile .o files with GHC 6.12 and then use ghci from GHC 7, it won't use the object files
00:21:05 <Heffalump> there should be a new Haskell Platform with 7 quite soon
00:21:15 <Jonno_FTW> how long? 
00:21:18 <Jonno_FTW> next month?
00:21:22 <Jonno_FTW> next quarter?
00:21:24 <Heffalump> I believe dons is working on it at the Hackathon this weekend, though I don't know if it'll also wait for GHC 7.0.2 to be released.
00:21:38 <Heffalump> I would expect it to appear this month, perhaps even this weekend.
00:21:45 <Jonno_FTW> nice
00:22:02 <Jonno_FTW> I don't mind doing a complete reinstall, I have plenty of time
00:22:11 <ddarius> Object code isn't compatible between any versions of GHC.
00:22:35 <ddarius> (Unless you're willing to do a little bit twiddling and praying.)
00:26:29 <Tomsik> So, is 7.0 so much faster as they say?
00:26:37 <Jonno_FTW> we'll see
00:27:37 <mreh> what is the platform really? A nice distribution of precompiled things for you?
00:27:57 <ddarius> mreh: It's a list.
00:30:56 <mreh> why do so many people need to build GHC, that's what baffles me
00:31:04 <mreh> i've never found the need
00:31:13 <Raynes> I do it because I can.
00:31:14 <mreh> unsupported architectures??
00:31:20 <Raynes> My CPU fan is soothing.
00:31:30 <mreh> lol
00:31:30 <Jonno_FTW> mreh: for the same reasons people use gentoo
00:32:09 <Raynes> I believe the binary packages are quite a bit larger than the source packages. Building from source was faster (slow connection).
00:32:27 <Raynes> And it wasn't particularly difficult or time consuming.
00:32:32 <Kaidelong> Jonno_FTW: I run Gentoo and have never built GHC unless Gentoo has built it for me
00:32:43 <Kaidelong> which I do not believe it has
00:33:04 <mreh> i was under the impression it took hours
00:33:29 <ddarius> It's pretty quick nowadays.
00:34:16 <mreh> i suppose 7 is fast because of the LLVM backend
00:35:02 <Kaidelong> LLVM backend is not the default I believe
00:35:05 <mreh> not to copile, just what we were talking
00:36:16 <Jonno_FTW> I installed ghc7.0.1 but it can't access any of my installed packages
00:36:37 <c_wraith> different versions of ghc have different package databases
00:36:46 <c_wraith> they need to be rebuilt with the new version of GHC anyway
00:36:50 <Jonno_FTW> ok
00:39:20 <Jonno_FTW> the new ghc doesn't have cabal in bin/
00:40:34 <c_wraith> cabal-install (which creates the cabal binary) has never been part of ghc
00:40:51 <c_wraith> but you can use the cabal binary built with an older version just fine on a newer version
00:40:57 <Jonno_FTW> ok
00:41:17 <Jonno_FTW> so ghc7 can't use the old packages?
00:42:01 <c_wraith> not the compiled forms of them.
00:42:20 <c_wraith> after all, GHC 7 comes with a new version of base
00:42:27 <c_wraith> and basically every package compiles against base
00:42:57 <Jonno_FTW> ok
00:44:05 <Jonno_FTW> then how do I get the old cabal to install packages for the new version?
00:44:41 <c_wraith> just make sure that ghc 7 is the first version of GHC in your path
00:44:55 <c_wraith> or there are some environment variables/command-line flags you can use to tell it which GHC to use
00:46:02 <Jonno_FTW> ok
00:49:23 <Jonno_FTW> so
00:50:03 <Jonno_FTW> I should set datadir to C:\ghc\ghc7.0.1\lib ?
00:51:04 <c_wraith> That doesn't sound right, but this isn't something I've worked with personally, so don't trust my instincts :)
00:51:12 <Jonno_FTW> :|
00:52:08 <Jonno_FTW> well the cabal config has -- datadir: "C:\\Program Files (x86)\\Haskell", and I installed ghc7 to C:\ghc\
00:53:00 <c_wraith> that line's commented out
00:53:09 <Jonno_FTW> well
00:53:24 <c_wraith> I think it should probably figure that out from the environment
00:55:36 <Jonno_FTW> ok I got it
00:59:37 <Jonno_FTW> If only windows had an automagic package manager
01:04:23 * ksf can't wait for dynamic linking to become the default
01:05:14 <ksf> either link dynamically or full-program analyse, but just linking big blobs doesn't make much sense
01:08:05 * hackagebot derive 2.4.2 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.4.2 (NeilMitchell)
01:17:00 <ksf_> is anyone aquanted to monad-peel and/or monad-control?
01:18:02 <homie> are there any packages for emacs of ghc ?
01:18:07 <homie> or ghci or so
01:18:27 <ksf> there's haskell-mode, but I'd recommend against it.
01:18:33 <ksf> instead, you should upgrade to vim.
01:18:41 <homie> err, why ?
01:18:51 <ksf> because it's always good to upgrade.
01:18:58 <c_wraith> because that's what vim users say every time emacs is mentioned
01:19:00 <c_wraith> best to ignore them
01:19:26 <ksf> well, at least we're not in denial.
01:19:56 <c_wraith> I'm not in denial.  Of all the horrible options available, I prefer the one that doesn't feel like playing nethack :)
01:23:11 <mreh> I prefer not to be stricken with dibilitating bouts of capal tunnel personaly
01:27:46 <c_wraith> I'm testing out debilitating bouts of gout.  fortunately, not in my hands.
01:39:02 <Kaidelong> c_wraith: but emacs makes you put in two keys to do what you could with one!
01:39:09 <Kaidelong> that makes it so much harder to learn
01:39:17 <Kaidelong> clearly
01:42:37 <Jonno_FTW> :t elem
01:42:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
01:50:41 <ksf> should iteratees be able to inject data into the chunkstream?
02:03:17 * hackagebot language-cil 0.2.2 - Manipulating Common Intermediate Language AST  http://hackage.haskell.org/package/language-cil-0.2.2 (TomLokhorst)
02:06:26 <Jonno_FTW> :t split
02:06:27 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
02:08:33 <jesnor> OT: can you discriminate between lazy and strict evaluation in a pure functional language which doesnt allow circular references?
02:10:14 <Jonno_FTW> :t $!
02:10:15 <lambdabot> parse error on input `$!'
02:10:19 <Jonno_FTW> :t ($!)
02:10:20 <lambdabot> forall a b. (a -> b) -> a -> b
02:10:25 <Jonno_FTW> :t ($)
02:10:25 <lambdabot> forall a b. (a -> b) -> a -> b
02:12:44 <Jonno_FTW> @src ($!)
02:12:45 <lambdabot> f $! x = x `seq` f x
02:12:49 <Kaidelong> Jonno_FTW: the different between those two won't show up in a type signature
02:12:50 <Jonno_FTW> @src ($)
02:12:50 <lambdabot> f $ x = f x
02:12:54 <Kaidelong> difference
02:13:12 <Kaidelong> > const 5 $ 5
02:13:13 <lambdabot>   5
02:13:18 <Kaidelong> > const 5 $ undefined
02:13:19 <lambdabot>   5
02:13:20 <Jonno_FTW> @src seq
02:13:21 <lambdabot> Source not found. Where did you learn to type?
02:13:23 <Kaidelong> > const 5 $! undefined
02:13:24 <lambdabot>   *Exception: Prelude.undefined
02:13:51 <Kaidelong> Jonno_FTW: Think of seq like a "keyfunction" or something. You can not implement it in standard haskell
02:13:56 <Kaidelong> you could with bang patterns though
02:14:10 <Jonno_FTW> ahh
02:16:15 <Kaidelong> > let seq !x = id in undefined `seq` 5
02:16:16 <lambdabot>   *Exception: Prelude.undefined
02:16:30 <Kaidelong> there is one way to define it
02:16:37 <Kaidelong> (using a bang pattern)
02:16:47 <Jonno_FTW> what are bang patterns?
02:17:04 <Kaidelong> bang patterns force their argument to be evaluated strictly
02:17:09 <Kaidelong> err
02:17:13 <Kaidelong> well, the value in the pattern
02:17:24 <Kaidelong> > let seq !x = id in Just undefined `seq` 5
02:17:25 <lambdabot>   5
02:17:32 <Kaidelong> apparently only to WHNF
02:17:47 <Kaidelong> > Just undefined `seq` 5
02:17:50 <lambdabot>   5
02:18:04 <Kaidelong> okay so that doesn't make it different from seq, so that's fine
02:21:50 <monadic_kid> deepseq can dig deeper
02:23:43 <dixie> @src div
02:23:43 <lambdabot> Source not found. My brain just exploded
02:24:48 <Kaidelong> @src (div :: Integer -> Integer -> Integer)
02:24:48 <lambdabot> Source not found. You speak an infinite deal of nothing
02:25:10 <aristid> Kaidelong: div is not THAT clever :)
02:25:16 <Kaidelong> @ty div
02:25:17 <lambdabot> forall a. (Integral a) => a -> a -> a
02:25:18 <aristid> argh i mean @src
02:25:23 <Kaidelong> hmm
02:25:29 <aristid> @src Integer div
02:25:29 <lambdabot> Source not found. That's something I cannot allow to happen.
02:26:05 <Kaidelong> Well it might be foreign
02:26:09 <Kaidelong> should be, really
02:27:51 <aristid> yeah, also @src is just a hand-crafted file
02:27:58 <jesnor> is there a channel for discussion about total languages?
02:28:40 <aristid> jesnor: #agda maybe?
02:29:36 <jesnor> thx
02:29:46 <Kaidelong> well people probably will not slaughter you for trying to talk about them here
02:30:16 <Cin> I made an hour long video of my screen creating this IRC logger bot from scratch to uploading to Hackage. Would anybody be interested in me narrating it? Newbs, maybe?
02:30:34 <kamaji> How can I keep reading lines from stdin in like an infinite loop?
02:30:40 <Kaidelong> Cin: That actually seems like a good idea
02:30:43 <kamaji> obviously no loops...
02:30:53 <Cin> kamaji: fix $ \repeat -> do line <- getLine; repeat
02:31:03 <Cin> kamaji: Or: forever $ getLine
02:31:12 <Cin> Kaidelong votes yes!
02:31:15 <Cin> Okay.
02:31:26 <kamaji> Cin: what about if I want to exit that if I get an "exit" line?
02:31:40 <Cin> kamaji: Then don't use 'repeat'. :)
02:31:42 <Kaidelong> kamaji: You can use recursion for this
02:31:59 <Kaidelong> Cin: I don't think that's very useful, he probably wants to use the lines for something
02:32:06 <Kaidelong> @ty forever
02:32:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
02:32:18 <kamaji> Kaidelong: won't that stack overflow?
02:32:20 <Cin> The above is equivalent to: let repeat = do line <- getLine; repeat in repeat
02:32:30 <Kaidelong> kamaji: Why?
02:32:34 <jesnor> Kaidelong: ok :) my idea is to have a language which disallows cyclic function references thus guaranteeing termination (though recursive data types are allowed), im curious if there are similar existing languages?
02:32:40 <Cin> fix $ \repeat -> do line; if line == "exit" then return () else repeat
02:32:40 <Kaidelong> recursion does not automatically mean stack overflow
02:32:46 <kamaji> Kaidelong: /comesfromC
02:32:54 <Kaidelong> right
02:32:57 <Kaidelong> use recursion
02:33:01 <kamaji> ok :P
02:33:07 <Kaidelong> if it overflows the stack, then post it on codepad
02:33:11 <Cin> kamaji: I actually do this in my video to read lines from the IRC server. :P
02:33:11 <kamaji> haha, ok
02:33:15 <Kaidelong> and we can dissect the corpse and find out why
02:33:36 <kamaji> Cin: i'm just trying to find definitions of "fix"
02:33:43 <Kaidelong> @src fix
02:33:43 <lambdabot> fix f = let x = f x in x
02:33:54 <Kaidelong> what why
02:34:02 <kamaji> and "in" ...
02:34:02 <Kaidelong> fix f = f (fix f)
02:34:27 <Kaidelong> let binding = expression in expression that uses binding
02:34:33 <Jonno_FTW> what do I do about this error: http://hpaste.org/43906/bytestring_pack_error
02:34:34 <Kaidelong> it is the same as
02:34:48 <Kaidelong> (\binding -> expression that uses binding) expression
02:35:27 <gienah> jesnor: in Coq you have to specify the function parameters the structural recursion is occuring on
02:35:57 <Kaidelong> (basically "let" and "where" can just be desugared to lambdas, I'm probably handwaving some stuff here but I do not know exactly what)
02:36:33 <Cin> kamaji: Basically you give fix an expression and it applies that expression to itself. It can either use that parameter or ignore it, depending on whether you want to loop or not. Because it's lazily evaluated it's evaluated when you use it. Slightly shorter way to write loops than explicitly using let myrepeatedfunc = do ..; myrepeatedfunc in myrepeatedfunc
02:37:01 <kamaji> Okay.. I think i'm following :D
02:37:03 <Kaidelong> kamaji: fix does not make any sense in strict languages like ML, by the way, so it is kind of a haskell thing
02:37:12 <Kaidelong> it can be defined and it will compile
02:37:22 <Kaidelong> but it will never actually terminate for anything
02:38:02 <Cin> Jonno_FTW: How many versions of ByteString do you have installed? ghc-pkg list bytestring
02:38:48 <kamaji> erm, apparently "fix" isn't in scope
02:38:50 <kamaji> what module is it in?
02:38:55 <Kaidelong> Control.Monad.Fix
02:38:56 <Kaidelong> has it
02:38:59 <kamaji> thanks
02:39:04 <Kaidelong> but honestly you probably should not be using fix
02:39:11 <kamaji>  /cry
02:39:29 <Kaidelong> I would just think about it with recursion for now
02:39:33 <Kaidelong> for example:
02:39:44 <Kaidelong> to make a list of lines you got from input
02:39:44 <Tomsik> I've read that fix-based implementation was the fastest one by a large margin a few years ago
02:39:49 <Tomsik> wonder if it's still the case
02:40:26 <Jonno_FTW> Cin: I have to
02:40:29 <Jonno_FTW> *two
02:40:48 <kamaji> Kaidelong: ?
02:41:22 <Cin> Jonno_FTW: It may be that the libraries you're loading have been linked with two versions of ByteString.
02:41:51 <Kaidelong> kamaji: You could actually just use "repeat getLine" and then work through the IO actions one by one
02:42:01 <Jonno_FTW> Cin: I used ghc-pkg hide on the old version
02:42:12 <Kaidelong> with a fold, even
02:42:19 <Cin> Jonno_FTW: Okay. Then ghc-pkg check, then reinstall the ones that were broken/
02:43:12 <kamaji> is there a repeatM so I can put a do block inside it?
02:43:38 <Kaidelong> kamaji: there may be, but repeatM does not really make sense for IO
02:43:58 <Kaidelong> @hoogle (Monad m) => m a -> [m a]
02:43:58 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
02:43:59 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
02:43:59 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
02:44:00 <kamaji> ahh, so confused ;_;
02:44:46 <Kaidelong> @ty foldr
02:44:47 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:45:26 * hackagebot bytestring-trie 0.2.3 - An efficient finite map from (byte)strings to values.  http://hackage.haskell.org/package/bytestring-trie-0.2.3 (WrenThornton)
02:45:48 <Jonno_FTW> Cin: all fixced now :)
02:46:54 <Kaidelong> kamaji: foldr (\x y -> y >>= if y then return y else actionOn(x) >> checkForTermination(y)) . repeat $ getLine
02:47:01 <Kaidelong> that might be a basic idea to work with
02:47:32 <Kaidelong> or you could just do something like
02:47:40 * Kaidelong heads to codepad...
02:48:49 <Cin> Jonno_FTW: Awesome. :)
02:49:06 <Kaidelong> http://codepad.org/WbVYIikt @kamaji
02:49:26 <Kaidelong> that would echo lines until the user types stop
02:51:29 <Kaidelong> you could also define something like a while loop
02:52:51 <kamaji> Kaidelong: what does the >> operator do?
02:52:57 <kamaji> I assume it just means... cal?
02:52:58 <kamaji> call*
02:54:06 <Jonno_FTW> kamaji: I was just reading about that
02:54:17 <kamaji> Jonno_FTW: About main loops?
02:54:24 <kamaji> (or that sort of thing)
02:54:29 <Jonno_FTW> the >> operator
02:54:48 <Jonno_FTW> http://www.haskell.org/haskellwiki/Introduction_to_IO
02:55:26 <Jonno_FTW> "if x and y are IO actions, then (x >> y) is the action that performs x, dropping the result, then performs y  and returns its result."
02:55:27 <Kaidelong> kamaji: the >> operator takes something out of the monad on the left, throws it away, then runs the monad on the right
02:55:42 <Kaidelong> http://codepad.org/KiI7EFgC
02:55:45 <mauke> x and y are not monads
02:55:51 <mauke> nothing is "taken out"
02:55:56 <mauke> I are sad panda
02:56:12 <Kaidelong> well
02:56:22 <Kaidelong> > [1,2,3] >> [3,4]
02:56:22 <lambdabot>   [3,4,3,4,3,4]
02:56:50 <dibblego> > (+1) >> (*2) $ 7
02:56:51 <lambdabot>   14
02:57:03 <Kaidelong> @ty (>>)
02:57:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
02:57:30 <Kaidelong> http://codepad.org/KiI7EFgC @kamaji, again
02:57:33 <companion_cube> > [1,2,3] *> [4,5]
02:57:34 <lambdabot>   [4,5,4,5,4,5]
02:57:36 <Kaidelong> a while loop defined in haskell
02:57:47 <ion> > Just 42 >> Just 43
02:57:48 <lambdabot>   Just 43
02:58:04 <kamaji> Jonno_FTW, Kaidelong ok, thanks
02:58:13 <kamaji> oh
02:58:35 <Kaidelong> >> is the same as >>= \_-> by the way
02:58:42 <kamaji> ok so it's basically a sequential operator? :P
02:58:46 <Kaidelong> yeah
02:58:49 <Kaidelong> well, for IO
02:58:55 <kamaji> ok
02:59:16 <ksf> http://hpaste.org/43907/iteratee
02:59:19 <ksf> comments, please
02:59:41 <Kaidelong> (>> is defined in terms of >>= which is a method, and thus overloaded)
02:59:48 <ksf> I gave up trying to lift exception handling out of the iteratee, that way lies insanity.
03:00:58 <ksf> otoh, I think I pretty much nailed the Iteratee typeclass, though.
03:01:07 <Kaidelong> kamaji: Remember that order of things does not matter in haskell so where it does it will be explicit, or sugared by do syntax
03:01:18 <Kaidelong> well, some exceptions to that
03:01:21 <Kaidelong> like case statements
03:01:28 <Kaidelong> but I think that is something of a wart
03:01:39 <ksf> put bluntly, the semicolon can chose for itself whether it cares about ordering.
03:08:18 <kamaji> Kaidelong: I guess pattern matching is the only exception
03:08:21 <Kaidelong> err by the way that while loop I posted was wrong
03:08:27 <kamaji> you mean the codepad one?
03:09:15 <kamaji> oh nevermind, I see it
03:09:21 <Kaidelong> http://codepad.org/su3xYVsO
03:09:25 <Kaidelong> here is a correct one
03:09:37 <kamaji> the previous codepad worked?
03:09:49 * Kaidelong hasn't tested either!
03:09:58 <kamaji> lol
03:10:24 <ksf> "beware of the code, I have only proven it to be correct, not tested it"
03:11:00 <jonkri> i want to use ReaderT to create a newtype for a logging monad transformer, allowing the ReaderT "state" to contain a number of logging functions that developers can call. should i use a record for this?
03:11:23 <ksf> you should use one of the gazillion logging frameworks we have...
03:11:51 <Kaidelong> kamaji: the first one works, it echos until a user types stop
03:12:08 <Kaidelong> although with ""'s around the string, putStrLn instead of print will fix that
03:12:35 <Kaidelong> so perhaps what you want to do could be built around that paste
03:12:41 <jonkri> ksf: we have already reached the conclusion in this channel that making the logging framework that i want to have would be good for the haskell community
03:12:47 <Kaidelong> http://codepad.org/WbVYIikt <- for reference
03:13:23 <ksf> jonkri, either a record or a typeclass
03:13:31 <kamaji> Kaidelong: Yeah, the first one seemed to work well for me
03:13:34 <kamaji> (thanks, btw)
03:13:40 <ksf> so that your api can be used with different implementation
03:14:17 <Peaker> Jonkri: why not a WriterT? 
03:14:49 <Kaidelong> np~
03:14:50 <ksf> I don't think he's talking about WriterT logging
03:15:44 <jonkri> interesting. follow-up question: would it be possible to have the logging functions called through the record or typeclass instance to be able to access the channel to send the logging messages through, while hiding that channel to the loggers (thus abstracting the inner workings of the library)
03:16:24 <jonkri> Peaker: writers are not suitable for concurrent logging, apparently
03:16:56 <jonkri> s/the loggers/the developers using the logging utility
03:17:19 <ksf> jonkri, just don't export the function they're using to access it
03:17:48 <ksf> leave it out of the typeclass and put it in the implementation
03:18:44 <ksf> if you really, really, really have to expose it, make it completely opaque.
03:19:22 <jonkri> ksf: what do you mean by "opaque?
03:19:49 <ksf> such that you can only see the outer shell (i.e., type), but not its innards
03:20:22 <jonkri> thanks
03:28:16 <jonkri> ksf: how does the typeclass instance access the channel? would it be somehow contained in the type? (if so: how does the instance access the "variable"?)
03:28:44 <jonkri> s/the instance access/the instance functions access
03:29:12 <ksf> data Foo = Foo Chan; instance Logger Foo where log (Foo c) s = sendOver c s
03:29:56 <jonkri> interesting :)
03:30:01 <ksf> if you then fail to export Foo's constructor, noone can mess with your chan
03:30:24 <ksf> well, short of unsafeCoercing it.
03:30:46 <jonkri> i just want it to be usable and minimal/elegant :)
03:34:09 <romildo> Hi.
03:34:10 <ski> @tell accel <http://hpaste.org/paste/43860/using_an_environment#p43865>
03:34:10 <lambdabot> Consider it noted.
03:36:14 <romildo> I want to install iconv on windows. 'cabal install --global iconv' fails with the message "Missing (or bad) header file: hsiconv.h", although hsiconv.h is part of the iconv package. Any clues?
03:36:41 <Cin> Is it bad?
03:37:54 <romildo> Where does "cabal install --global <package>" unpacks the source code of <package> on Windows?
03:44:05 <ksf> c:\tmp?
03:44:23 <ksf> there's cabal unpack if you want to have the source.
03:44:30 <ksf> that's going to unpack into the current directory
03:44:43 <Cin> Man I've never done so much dependency/version battling in any other language as much as Haskell.
03:46:05 <romildo> Cin, it seems that iconv.h (which is included in hsiconv.h) was not being found.
03:46:27 <romildo> With 'cabal install --global --extra-include-dirs=/c/devel/MinGW/include --extra-lib-dirs=/c/devel/MinGW/lib iconv' it works.
03:47:44 <romildo> How do I make ghc uses my installation of MinGW automatically? I think it is using the MinGW that comes with ghc.
04:01:34 <bott> how would I go about creating the following datatype: it's a list of (positive) integers, together with, for each integer, that many other integers; e.g. ([2,2,1], [[1,2],[4,7],[5]])
04:02:06 <c_wraith> Well, you can't enforce that restriction without dependent types
04:02:26 <Blkt> good day everyone
04:03:28 <c_wraith> I'm not sure if one of the many ways to approximate dependent types in haskell could be used there.  But if it was possible, it wouldn't be pretty. :)
04:04:44 <bott> ah, ok, thanks
04:06:01 <bott> and is there a good way of say imposing conditions on a datatype, say I start with [Int] and want a datatype consisting of alternately even and odd integers for instance
04:07:06 <c_wraith> That's another example of dependent types.
04:07:27 <c_wraith> You want the type to depend on the values involved.
04:08:16 <bott> yeah, I just thought that might be a bit milder for it to be possible
04:08:20 <ezyang> Well, that you can fake. 
04:08:45 <ezyang> Use [Int] and define the even entries to be 2*n and the odd entries 2*n+1 
04:10:31 * pai got mind blown looking at haskell syntax
04:11:16 <bott> ezyang: sure, but I guess it was a more general question (and that was just a silly example)
04:11:21 <Kaidelong> what is so weird about haskell syntax pai?
04:11:23 <bott> so what do you recommend I do, just give up? :P
04:11:47 <c_wraith> use a language that supports dependent types.  If you want them
04:12:02 <bott> but I like Haskell :(
04:12:14 <Kaidelong> well at least one is based on haskell
04:12:26 <pai> Kaidelong, its almost like math but uses alternative syntaxes 
04:12:33 <dibblego> it is possible to like more than one language
04:12:47 <Kaidelong> pai: I never really thought of haskell looking too much like math
04:13:03 <Kaidelong> if anything it reminds me of lisp with less parenthesis
04:13:13 <dibblego> haskell syntax is what children expect, obviously
04:13:50 <Kaidelong> dibblego: haskell does make that hard, for what it is worth. I have been managing, but only barely
04:14:10 <dibblego> makes what hard?
04:15:17 <Kaidelong> liking more than one language
04:15:53 <Kaidelong> That said, haskell also makes it quite hard to love one language, let alone more than one
04:19:51 <gienah> pai: you can make haskell look more like maths by mapping operators to unicode maths operators in editors like yi, emacs
04:20:01 <gienah> @google haskell-mode "pretty lambda" emacs
04:20:03 <lambdabot> http://www.google.com.hk/url?sa=p&hl=zh-CN&pref=hkredirect&pval=yes&q=http://www.google.com.hk/search%3Fhl%3Den%26q%3Dhaskell-mode%2520%2522pretty%2520lambda%2522%2520emacs%26btnI%3DI'm%2BFeeling%
04:20:03 <lambdabot> 2BLucky&ust=1297514579827960&usg=AFQjCNG02144R-iWaLjClo7PGnLeI1upaw
04:20:03 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
04:20:24 <ezyang> Strathclyde Haskell Enhancement fakes dependent types. 
04:20:31 <ezyang> But I wouldn't recommend it for serious use 
04:21:29 <gienah> Coq has dependent types, you can generate Haskell from the Coq code, however Coq is specialized, the resulting Haskell code may have Peano numbers
04:21:42 <gienah> Ur has dependent types
04:21:53 <ksf> have a look at idris and agda
04:22:05 <gienah> ksf: thanks
04:22:25 <ksf> idris, in particular. while it's not ready, it's the one dependently typed language that's actually catering to programmers, not mathematicians.
04:22:36 <taotree> Is there a simple way to wait on multiple TChans that have different types params? I found waitAny, but it requires them all to have the same type
04:22:52 <ksf> coming with a theorem assistant, for example.
04:23:03 <Kaidelong> ACL2 caters to engineers and it sort of has dependent types. Or only has dependent types.
04:23:04 <gienah> I have not looked at Ur, the author is a Coq expert
04:23:27 <Philippa> taotree: collate them into one TChan via Either or similar
04:23:45 <ezyang> Or make more threads. 
04:23:55 <ezyang> Remember: Haskell threads are cheap. 
04:24:08 <bott> ksf: thanks. idris looks pretty neat
04:24:18 <taotree> making threads doesn't solve it since eventually it needs to be combined, but... using Either...
04:24:24 <vegai> ezyang: only when not using -threaded
04:24:25 <ski> (Ur is made by Smerdyakov)
04:24:31 <bott> I'd call myself a mathematician, but I'm not interested at all in theorem proving or anything
04:24:37 <vegai> ok, so they're not exactly expensive with -threaded either, but...
04:24:47 <Lemmih> taotree: You just want to know when one of the TChans can be read from?
04:24:58 <vegai> ...one can easily spend several gigabytes on threads with -threaded
04:25:25 <Kaidelong> bott: Well (perhaps exluding Cayenne and then Idris according to ksf) dependent types usually come with stuff for theorem proving
04:25:28 <taotree> right... So I can just use one single TChan that has something like a tuple of Maybes of all the types I want. Writers just plug in the one they have and leave Nothing for other
04:25:31 <gienah> A link to Ur: http://www.impredicative.com/ur/
04:25:35 <ksf> thereIsAProofButMyTemperIsToShortToFigureItOutCoerce
04:25:56 <Kaidelong> since you basically need a full fledged theorem prover to even stand a chance to implement dependent types
04:26:07 <ksf> idris comes with an assistant
04:26:11 <ksf> ...like coq.
04:26:19 <ksf> it's agda where you have to type all the proofs
04:26:25 <Kaidelong> there is also Dependent ML
04:26:39 <ksf> Theorem foo. auto. Qed.
04:27:03 <Lemmih> taotree: You can also use multiple TChans together with 'orElse'.
04:27:07 <ManateeLazyCat> Hi all. :)
04:27:15 <bott> that's interesting; it seems like dependent types is quite a pain to deal with
04:27:26 <Kaidelong> bott: Bingo!
04:27:27 <bott> what makes it such a trouble theoretically?
04:27:30 <taotree> Lemmih, right, but... that would just complicate things. I don't know of a reason not to just use one TChan
04:27:42 <Kaidelong> bott: type checking requires running the program
04:27:49 <Kaidelong> this is a problem in a language that isn't total
04:28:04 <Kaidelong> total languages tend to require you to prove that your programs terminate
04:28:08 <ksf> luckily, all sensible programs are total
04:28:09 <Lemmih> taotree: Just giving you options. Pick the one that suits you best.
04:28:15 <taotree> Lemmih, right, thanks
04:28:29 <Kaidelong> ksf: but the compiler might hang instead of giving a type error if your program isn't sensible
04:28:32 <Kaidelong> and there lies the rub
04:28:41 <Kaidelong> you could have it time out though
04:28:47 <Kaidelong> but then it might reject some valid programs
04:29:00 <Kaidelong> (and we just hit the halting problem...)
04:29:12 <ksf> g++ should start that timeout thing, sometime.
04:29:41 <bott> so are you basically saying that, aside from the main program, you sort of have to have something else that figures out all the type dependencies and can then verify your types are correct?
04:29:53 <bott> and that it's theoretically hard to verify the types work correctly?
04:30:12 <ksf> type inference is a big, big problem
04:30:53 <bott> is it basically the case that you can't figure out types in generality, so you can't expect to have like a side program that figures out the types and then everything would work out say just as it does in Haskell?
04:31:24 <Kaidelong> nonetheless there are places where dependent type like functionality could be really nice, for example functions that deal with arbitrary length tuples
04:31:44 <Kaidelong> but hopefully for those it'll turn out that you don't need the full power of dependent types
04:32:06 <Kaidelong> (actually I think people have figured that one out already)
04:32:32 <ksf> there's two insane record libraries for haskell, yes.
04:32:52 <bott> so is there some sort of theoretical result that type checking something full is not decidable or something? couldn't there be some sensible type constructor that still leaves things at a manageable level?
04:33:05 <ksf> also a vector library which is really nice
04:33:45 <tensorpudding> hindley-milner is decideable
04:34:11 <tensorpudding> but there are more powerful type systems that are not
04:34:23 <Kaidelong> tensorpudding: Haskell's type system is not hindley miller though. It's a decidable but enhanced version of it the name of which I forgot
04:34:31 <tensorpudding> yeah
04:34:38 <tensorpudding> it's hindley-milner + extra stuff
04:34:49 <Kaidelong> Damien-Something I think
04:34:51 <Biggles> how do you get into type theory / decidability of type systems stuff
04:35:36 <Biggles> (hi i'm an interloper with a tangental question)
04:36:01 <tensorpudding> H-M is a restriction on System F, which is undecideable
04:38:49 <tensorpudding> there are GHC extensions which make type annotations necessary though
04:39:06 <tensorpudding> presumably because they are not able to be inferred
04:39:19 <Kaidelong> tensorpudding: monomorphism restriction already does
04:39:32 <Kaidelong> although you can turn that off
04:39:53 <Kaidelong> so I guess they're not *really* neccessary
04:41:17 <Toxaris> Kaidelong: The monomorphism restriction leads to a specific type inferred when a more generic type would exists. So in type inference without the monomorphism restriction, that more generic type could (and would) be inferred.
04:42:06 <Toxaris> But other extensions add so many types, that there *is* no most generic type. And since the compiler can't read minds, it doesn't know *which* of the various concrete types it should infer. 
04:42:07 <Kaidelong> Toxaris: you can run into situations where defaulting does not work
04:42:33 <mreh> how would ErrorT String IO a be more useful that pure IO?
04:42:53 <Kaidelong> mreh: That baffles me. Maybe they want to avoid using fail.
04:43:21 <mreh> dons used it when he made a scripting monad
04:43:32 <Kaidelong> huh
04:43:46 <mreh> all the monad error instances are defined as error anyway
04:44:01 <Toxaris> why use "dirty" IO when there is a better solution available?
04:44:20 <Toxaris> so maybe you need IO for, say, file reading, but that's no reason to use it for, say, exceptions too
04:44:20 <tensorpudding> transforming over IO is cleaner?
04:44:35 <mreh> i supppose so
04:44:37 <Toxaris> yes.
04:44:51 <Toxaris> if you have some functions which need exceptions but don't need IO otherwise
04:45:01 <Toxaris> you can type them as: MonadError String m => m ...
04:45:18 <mreh> nah, I need IO for interacting with the shell
04:45:22 <Toxaris> so the type checker guarantuees that this function does not do any IO, and you can still call it 
04:46:08 <Toxaris> it is unfortunate that IO is so big. I would prefer a design with many small monads (or monad transformers, or capabilities, or whatever). 
04:46:32 <Kaidelong> Toxaris: Just to make sure I understand, shouldn't that context be "MonadError (m String)"
04:46:34 <Toxaris> ErrorT String (ShellT (DebugMessagesT Identity)) a
04:47:26 <mreh> i'm still not intuitively familiar with transformers
04:47:48 <Kaidelong> @ty lift
04:47:49 <lambdabot>     Ambiguous occurrence `lift'
04:47:49 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
04:47:50 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
04:47:53 <Toxaris> class Monad m => MonadError e m | m -> e
04:48:09 <Toxaris> so MonadError has two parameters, the first is the error type, and the second is the monad
04:48:33 <Toxaris> The context (MonadError String m) means: m is an error monad with error type String
04:49:40 <mreh> i wanted to do some list monad type computations in a shell environment, that would mean I should use a list transformer on the shell monad correct>
04:51:18 <Toxaris> Kaidelong: Yeah defaulting (or its absence) is annoying. But note that defaulting is not really about type inference, it is about runtime behavior. A generic type could be inferred, but it would not be clear which typeclass instance to use, then. So to actually run the program, we need a more concrete type.
04:51:33 <Toxaris> mreh: Or a Shell transformer on the list monad, depends :) 
04:51:41 <Kaidelong> Toxaris: Yeah, I kind of noted that
04:52:06 <Kaidelong> but it can cause situations where annotations are required when types can actually be inferred
04:52:07 <ksf> I bet we could come up with sane defaulting for typeclasses.
04:52:21 <mreh> I just want to sequence the computations in the shell monad
04:52:42 <ksf> like, if in doubt, use the default specified where the instance is declared.
04:52:46 <Toxaris> mreh: do you want to have something like [IO a], or something like IO [a]?
04:53:09 <ksf> trying a bit is definitely better than bailing out every single time.
04:53:24 <ksf> it works for Num, after all.
04:54:00 <ksf> though the monomorphism restriction would have to fall, first, or stuff would tend to be way too concrete.
04:54:13 <Toxaris> that would be good anyway :)
04:54:53 <Toxaris> how would such a cooler defaulting mechanism interact with separate compilation? Does it suffer from the same problems as OverlappingInstances?
04:55:17 <mreh> Toxaris: the first, so I need to work out how to turn it into IO [a] when it's finished
04:55:29 <mreh> sequence, i suppose
04:55:41 <Toxaris> mreh: looks like it :)
04:56:18 <phrackSipsin> anybody used shpider for webscraping?
04:58:42 <Toxaris> mreh: I'm too confused by ListT to say whether ListT IO would be the way to go. I guess not. 
05:03:00 <xplat_> 11:00 < djahandarie> The type system has already been made turing-complete  multiple times :P
05:03:12 <xplat_> 11:01 < djahandarie> Nothing like an inconsistent type system!
05:03:43 <xplat_> but isn't a turing-complete type system equivalent to an inconsistent KIND system?
05:05:28 <Toxaris> xplat_: Depends on what you mean by "inconsistent"
05:06:35 <Toxaris> xplat_: An undecidable type system means that the kind system does not guarantuee termination of type expressions. 
05:06:53 <Toxaris> But it might still guarantuee kind-safety.
05:07:04 <Toxaris> So no big deal. 
05:11:49 <neuUser> hi
05:12:20 <dafis> hi
05:14:45 <neuUser> great interactive haskell totorial you made on tryhaskell
05:16:48 <iago> does someone know if there is some library for combining predicates (a -> Bool)?
05:17:58 <dafis> iago: not directly, but you can use combinators from Control.Arrow, Applicative, Monad ...
05:18:08 <dafis> :t liftA2 (&&)
05:18:08 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
05:18:35 <dafis> > liftA2 (&&) even (> 6) $ 18
05:18:36 <lambdabot>   True
05:18:45 <dafis> > liftA2 (&&) even (> 6) $ 7
05:18:46 <lambdabot>   False
05:21:25 <koala_man> > "ø" =~ "^(.*)$" :: Bool
05:21:27 <lambdabot>   True
05:21:37 <koala_man> I get False here. what's up with that?
05:21:51 <koala_man> using Text.Regex.Posix
05:23:25 <iago> dafis, I see, thanks
05:23:34 <dafis> koala_man: I get False too, no idea why yet
05:25:12 <geheimdienst> koala_man: some locale issue maybe? i'd imagine a scandinavian locale would consider ø a letter, an american locale possibly not
05:25:34 <Kaidelong> whatever happened to arrows
05:25:44 <koala_man> geheimdienst: does "." match only letters?
05:26:18 <burp> no
05:26:28 <geheimdienst> no, i thought it matches any char except maybe newline or something. that's why i put so many "possibly" in my message ... it's kinda speculation
05:28:35 <koala_man> works with Text.Regex.TDFA instead
05:29:35 <geheimdienst> how strange
05:31:17 <burp> I consider it a bug
05:39:22 <parcs> @hoogle splitOn
05:39:23 <lambdabot> No results found
05:40:14 <parcs> anything like this in base or must i install split?
05:40:24 <dafis> koala_man: I suspect an encoding issue
05:40:35 <dafis> parcs: what do you want to split on?
05:41:47 <parcs> dafis: (Eq a) => a -> [a] -> [[a]]
05:42:19 <parcs> @hoogle  (Eq a) => a -> [a] -> [[a]]
05:42:20 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
05:42:20 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
05:42:20 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
05:42:31 <ksf> there isn't.
05:42:36 <ksf> but there's breakAt etc.
05:42:44 <ksf> :t break
05:42:45 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:42:55 <dafis> parcs: like splitOn ',' "This, I think, may be." = ["This", " I think", " may be"]?
05:43:11 <geheimdienst> parcs: it's an unfortunate state. i think you need the split package or the missingh package
05:43:15 <fryguybob> @hackage split
05:43:15 <lambdabot> http://hackage.haskell.org/package/split
05:43:16 <parcs> yes
05:43:30 <dafis> parcs: install split or write your own using break and unfoldr
05:43:57 <geheimdienst> ... as hundreds have before you ...
05:44:11 <dafis> and will after
05:44:14 <parcs> @type unfoldr
05:44:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:45:18 <ksf> a clear-cut case for h', I'd say.
05:45:32 <parcs> @type \x -> unfoldr (Just . break (== x))
05:45:33 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
05:46:05 <ksf> you might want to terminate at some time, though.
05:46:16 <dafis> parcs: that won't do it, you have to remove the match from the start of the second component
05:46:35 <ksf> that, too.
05:46:39 <ksf> but the direction is right
05:46:41 <taotree> How does one write a type for a function that has effects only? so it returns IO () but takes no params
05:46:55 <dafis> taotree: foo :: IO ()
05:46:57 <ksf> then it *is* IO ()
05:47:03 <ksf> (and doesn't return)
05:47:08 <ksf> </nitpick>
05:47:45 <taotree> right, ok
05:48:46 <chegibari> Hello. Does haskell have interfaces like Java and C#?
05:49:03 <c_wraith> no.
05:49:04 <ksf> no. but yes.
05:49:12 <c_wraith> It has things sort of like them.
05:49:19 <c_wraith> But they're really fundamentally different
05:49:28 <ksf> OOP metaphors just break down when dealing with haskell
05:49:34 <chegibari> ah
05:49:36 <geheimdienst> chegibari: haskell has something similar which (in our opinion) is more powerful. it's called typeclasses
05:50:02 <ksf> in the same way that Java and C# have problems expressing zygohistomorphic prepromorphisms
05:50:57 * ezyang has trouble expressing zygohistomorphic prepromorphisms 
05:50:57 * chegibari reaches for the dictionaries
05:51:03 <parcs> @type \x -> unfoldr (\y -> if null y then Nothing else Just . second tail $ break (== x) y)
05:51:04 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
05:51:11 <Ferdirand> ksf: i'd love to hear a layman's description of zygohistomorphic premorphisms
05:51:12 <parcs> would that?
05:51:19 <geheimdienst> chegibari: he's just kidding. nobody uses that crap. nobody even knows what it is.
05:51:29 <ksf> edwardk does
05:51:34 <ezyang> geheimdienst: I wouldn't say no one knows what it is... 
05:51:44 <ksf> speak of the devil
05:51:55 <ksf> oh, wait, edwardk /= ezyang
05:52:02 <ksf> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
05:52:04 <ksf> that's the one.
05:52:10 <joe6> quit
05:52:27 <jonkri> in "class HLogger a where start :: ??? -> IO a", is allowing multiple typeclass arguments the only way to have both "???" and "a" to be of arbitrary types? i want the instances to have arbitrary terms as both input and output
05:53:01 <ezyang> hahaha 
05:53:12 <dafis> parcs: replace tail with (drop 1) or you'll get an exception if the last Char isn't the specified
05:53:15 <ksf> a is no arbitrary type.
05:53:23 <ksf> it has to be one with an instance
05:53:25 <ezyang> This gem is from Knuth: What's a “topological bifurcating arborescence”? 
05:53:54 * chegibari reads http://www.haskell.org/haskellwiki/OOP_vs_type_classes
05:53:56 <parcs> dafis: thanks
05:54:04 <ksf> but are you sure you don't want class MonadIO m => HLogger m where start :: m a ?
05:54:13 <jonkri> ksf: aha, ok. so i can basically say "b -> IO a"?
05:54:27 <ezyang> (it's a binary tree) 
05:54:33 <ksf> yeah, but you won't be able to inspect that b, because you don't know what it is.
05:54:50 <ksf> make that start :: m ()
05:54:58 <geheimdienst> ezyang, omg "binary tree" is so mainstream. elitism please!
05:55:19 <geheimdienst> i like saying bifunctoring abhorrence better
05:55:43 <jonkri> ksf: why? what's "m" in that, and what about the parameter?
05:56:03 <ksf> m is your monad
05:56:42 <ksf> jonkri, I suggest starting with a MonadTrans instance for your transformer.
05:56:54 <ksf> when that's down the rest falls out more easily.
05:58:47 <jonkri> ksf: but i thought i didn't need monads for this step. i thought making this typeclass with functions and a channel would be enough, and then use that "object" as the state in a logger/reader monad transformer in the client later
06:04:01 <ksf> well, depending on implementation, you will want to use different monadic actions.
06:04:09 <ksf> as such, you have to parametrise them
06:05:07 <ksf> personally I'd start out with an implementation that doesn't use any transformers behind the scenes
06:05:17 <ksf> ...less confusing.
06:07:50 <jonkri> ksf: shouldn't it be m a instead of m ()?
06:07:58 <jonkri> a monad of the typeclass instance type
06:08:11 <jonkri> and also making that monad a MonadTrans?
06:08:17 <jonkri> s/monad/type
06:11:44 <ksf> jonkri, well, what should a be, if it isn't mentioned in the instance head?
06:11:59 <ksf> the only value you could construct of that type is "undefined"
06:14:37 <jonkri> ksf: a is the type of the instance of HLogger, such as SimpleHLogger
06:15:01 <jonkri> in instance HLogger SimpleHLogger where
06:21:27 <hal> I have just installed haskell, in order to install the latest pandoc
06:21:39 <aristid> hal: you mean you installed GHC?
06:22:01 <hal> I installed it as root, but now when I install another application it installs it to /root/.cabal/bin
06:22:13 <hal> aristid:  ah, possibly :)
06:22:42 <hal> I'm not too sure how haskell, cabal, and ghc work together, and what each does, exactly
06:23:15 <aristid> haskell is the language
06:23:19 <aristid> you can't install it
06:23:44 <dafis> aristid: my guess: hal installed the haskell platform
06:23:53 <aristid> dafis: oh, that would make some sense
06:23:54 <hal> yes I did
06:24:08 <aristid> hal: the haskell platform contains GHC and some other things :)
06:24:15 <hal> ah
06:24:19 <dafis> hal: ghc is the compiler, cabal is a tool for installing haskell packages
06:24:39 <hal> ah so it's probably cabal that I am having trouble with
06:24:47 <aristid> :D
06:24:52 <hal> because it's installing packages for a user rather than all users
06:25:10 <aristid> are you more than one user?
06:25:26 <hal> on my system, yes
06:25:34 <hal> root, and the standard user 
06:25:47 <hal> I'd like to install packages system wide, preferably
06:25:59 <parcs> hal: you don't want that
06:26:12 <hal> whyever not, parcs ?
06:28:41 <dafis> hal: in /root/.cabal/config, change the line "-- user-install: True" to "user-install: False" to have cabal install things globally
06:29:21 <hal> ok dafis . Do you know why parcs warns against it?
06:29:22 <dafis> hal: but if you're only one user (you as yourself and you as root), I'd rather go for user-installs
06:30:35 <parcs> cabal isn't bulletprof software; it frequently creates problems whose only solution seems to be to delete everything that cabal installed and to start over. if you instal system-wide, you lose taht convenience of being able to remove one folder to start over. cabal also doesn't keep track of the binaries that it installs.
06:30:38 <dafis> hal: if you screw something up, when you did user installs, you can just rm ~/.ghc and still have a working compiler, you just need to reinstall the packages, for global installs, things are more complicated to repair
06:31:24 <parcs> (man, wireless keyboard suck)
06:31:43 <gienah> dafis: on gentoo can run haskell-updater to repair the global installs :-)
06:32:14 <hal> dafis: ok, I will play it safe. Thanks for the explanation
06:33:46 <dafis> hal: then add ~/.cabal/bin to your path (before /usr/local/bin or whereever cabl is now) and copy or move the cabal binary there
06:34:07 <dafis> cabal*
06:34:52 <dafis> then run cabal update and you can cabal install stuff as user
06:59:03 <morphles> im haskell newbie, and im going thrue 99 haskell questions, and after i solve a problem in my way, i check solutions, now i just done problem 8, and looked at solutions, well mine isint where, like with some other problems:), just i think that my solution to problem 8 is kinda interesting, so i though i'd ask you maybe i should add it there? since 99 questions page seems to be wiki
07:01:11 <dafis> morphles: look at your solution again, if you still think it's interesting, add it
07:01:20 <morphles> i can show it :)
07:01:36 <dafis> or you could paste it and ask for opinions first :)
07:01:45 <dafis> @where paste
07:01:45 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
07:01:49 <morphles> what i like about my solution that it does not use any folds ++ or other functions, just if and :
07:01:52 <morphles> ko ill paste
07:02:43 <morphles> http://hpaste.org/43911/poblem_8_from_99_haskell_quest
07:05:27 <morphles> so how does it look, i hope its not too lame :)
07:05:54 <morphles> iirc fom learn you a haskell ++ is quite slower than :
07:06:30 <mauke> fails on []
07:06:43 <rwbarton> it's pretty good, yeah, you want to add a case for the empty list
07:06:49 <morphles> ah yeah
07:06:58 <Boxo> not using folds isn't considered a virtue :P
07:06:59 <jonkri> are there any kind of particular problems that you can run into when using haskell, ffi and c++/qt, exporting an api from haskell to c++?
07:07:48 <morphles> well i had it writen with foldl if and : only but i though ill rewrite it without fold :D 
07:08:00 <dafis> morphles: (++) isn't much slower here because you get terms like [x] ++ ([] ++ ([y] ++ (...))), but I agree that using (:) is preferable (looks cleaner, IMO)
07:08:08 <rwbarton> personally I think this is easier to read than any fold-based solution
07:08:46 <morphles> ah my fold solution had problem, ir returined compressed but reversed list
07:08:57 <morphles> thats why i decided to redo it without folds
07:09:01 <dafis> morphles: use foldr instead of foldl
07:09:49 <morphles> i tink ill then have problems doing patter matching, but i think after solution i pasted i can redo it with foldl and still have list not reversed
07:10:10 <dafis> > foldr (x ys -> case ys of { (y:zs) | y == x -> ys; _ -> x:xs }) [] "aaabbcdddeeaae"
07:10:11 <lambdabot>   Pattern syntax in expression context:
07:10:12 <lambdabot>      x ys -> case ys of {
07:10:12 <lambdabot>            ...
07:10:23 <dafis> > foldr (\x ys -> case ys of { (y:zs) | y == x -> ys; _ -> x:xs }) [] "aaabbcdddeeaae"
07:10:24 <lambdabot>   Not in scope: `xs'
07:10:30 <dafis> > foldr (\x ys -> case ys of { (y:zs) | y == x -> ys; _ -> x:ys }) [] "aaabbcdddeeaae"
07:10:31 <lambdabot>   "abcdeae"
07:11:56 <morphles> hm
07:12:31 <dafis> > foldr (\x ys -> x : case ys of { (z:zs) | z == x -> dropWhile (== x) zs; _ -> ys }) [] (repeat 'a')
07:12:33 <lambdabot>   "a*Exception: stack overflow
07:12:44 <chegibari> Do haskell people care much about reflection?
07:13:27 <tavelram> we're like vampires, we dont have one... or is that just me?
07:13:35 <dafis> chegibari: I don't think so.
07:14:34 <morphles> hm stackoverflow? compiled haskell programs shouldnt get stack overflows i guess?
07:14:53 <morphles> or is my guess wrong
07:14:54 <Jafet> morphles: ghc runs on pancakes
07:15:00 <morphles> :D
07:15:28 <Maxdamantus> > sum [1..1000000]
07:15:30 <lambdabot>   *Exception: stack overflow
07:15:30 <Jafet> And the computer's stack, for speed.
07:16:04 <morphles> maybe im just wrong thinking that all recursion in haskell is kidna tail end recursion that gets unrolled
07:16:14 <ion> :t sum'
07:16:15 <lambdabot> Not in scope: `sum''
07:16:24 <Maxdamantus> > foldl (\a b -> seq a $ a + b) 0 [1..1000000]
07:16:25 <lambdabot>   *Exception: stack overflow
07:16:29 <Maxdamantus> Meh.
07:16:34 <dafis> > foldr (\x ys -> x : case ys of { (z:zs) | z == x -> zs; _ -> ys }) [] (repeat 'a')
07:16:38 <lambdabot>   mueval-core: Time limit exceeded
07:16:43 <Jafet> Whouda thunk it
07:16:46 <ion> I take it there’s a reason for sum not being strict?
07:16:55 <mauke> ion: no
07:17:12 <Jafet> > foldl1' (+) [1..1000000]
07:17:13 <lambdabot>   500000500000
07:17:43 <dafis> morphles: you can't make everything tail-recursive
07:17:56 <Bynbo7> > foldr (x xs -> case xs of (y:ys) | x == y = y:ys; _ -> x:xs) [] "aabbccdeeefggg"
07:17:57 <lambdabot>   <no location info>: parse error on input `='
07:18:03 <Bynbo7> > foldr (x xs -> case xs of (y:ys) | x == y -> y:ys; _ -> x:xs) [] "aabbccdeeefggg"
07:18:04 <lambdabot>   Pattern syntax in expression context:
07:18:04 <lambdabot>      x xs -> case xs of {
07:18:04 <lambdabot>            ...
07:18:18 <Bynbo7> > foldr (\x xs -> case xs of (y:ys) | x == y -> y:ys; _ -> x:xs) [] "aabbccdeeefggg"
07:18:18 <lambdabot>   "abcdefg"
07:18:25 <dafis> morphles: besides, tail recursion isn't so important for Haskell because pratial results can be delivered immediately
07:18:27 <morphles> dafis: thats kinda what i expects
07:19:06 <dafis> partial* results
07:19:38 <morphles> hehe my compress doesnt cause stack overflow
07:23:04 <dafis> > let compress (x:y:zs) = if x == y then compress (x:zs) else x:compress (y:zs) in compress (repeat 'a')
07:23:07 <lambdabot>   mueval-core: Time limit exceeded
07:23:46 <dafis> morphles: but it fails on repeat 'a' nevertheless
07:23:52 <morphles> :D
07:24:11 <morphles> do
07:24:20 <morphles> take 100000 (repeat 'a')
07:24:33 <morphles>  > let compress (x:y:zs) = if x == y then compress (x:zs) else x:compress (y:zs) in compress take 10000 (repeat 'a')
07:24:46 <morphles> > let compress (x:y:zs) = if x == y then compress (x:zs) else x:compress (y:zs) in compress (take 10000 (repeat 'a'))
07:24:47 <lambdabot>   "*Exception: <interactive>:3:4-76: Non-exhaustive patterns in function comp...
07:24:49 <parcs> > map head . group $ repeat 'a'
07:24:53 <lambdabot>   mueval-core: Time limit exceeded
07:26:43 <chegibari> dafis: geheimdienst: thanks for the answers!
07:26:58 <morphles> dunno why but functional programming seems quite a bit more appealing to me than imperative/oop
07:27:11 <osfameron> morphles: Knuth disagrees! ;-P
07:27:51 <dafis> What does Knuth know about morphles' preferences?
07:27:55 <morphles> and besides functional programs seem to be more suited for multicore future
07:28:27 <Eduard_Munteanu> osfameron: really?
07:29:13 <osfameron> dafis: hehe, yeah, I did think of that ambiguity
07:29:14 <Jafet> Interesting compression
07:29:29 <Jafet> dafis: what doesn't Knuth know!?
07:29:45 <osfameron> Eduard_Munteanu: @pozorvlak was livetweeting a talk of his.  quoted something like "of the 300 programs I've written in the last year, 5 of them would have been improved by functional programming"
07:29:58 <morphles> so should i add? or maybe someone who already has account in wiki will add my solution? :)
07:30:03 <dafis> Jafet: What I'll have for dinner today, what morphles' preferences in programming are, ...
07:30:16 <Eduard_Munteanu> I see.
07:30:31 <Jafet> Well, I hear he has tamed a Laplacian demon
07:30:39 <osfameron> Eduard_Munteanu: http://twitter.com/#!/pozorvlak/status/35873207479177216
07:30:51 <Eduard_Munteanu> Thanks, *looking*
07:31:28 <osfameron> or http://twitter.com/#!/search/pozorvlak%20turinglecture for the whole lot
07:32:46 <Bynbo7> > foldr (\x xs -> case xs of (y:ys) | x == y -> y:ys; _ -> x:xs) [] $ repeat 'a'
07:32:47 <lambdabot>   "*Exception: stack overflow
07:32:51 <Bynbo7> :o
07:34:12 <dafis> > foldr (\x ys -> x : let ws = case ys of { (z:zs) | z == x -> zs; _ -> ys } in ws) [] (repeat 'a')
07:34:16 <lambdabot>   mueval-core: Time limit exceeded
07:34:27 <dafis> darned optimisations
07:34:39 <Jafet> > head $ foldr (\x ys -> x : let ws = case ys of { (z:zs) | z == x -> zs; _ -> ys } in ws) [] (repeat 'a')
07:34:40 <lambdabot>   'a'
07:35:18 <dafis> > foldr (\x ys -> x : let ws = case ys of { (z:zs) | z == x -> zs; _ -> ys } in ws) [] (replicate 1000000 'a')
07:35:20 <lambdabot>   "a"
07:35:23 <dafis> > foldr (\x ys -> x : let ws = case ys of { (z:zs) | z == x -> zs; _ -> ys } in ws) [] (replicate 10000000 'a')
07:35:27 <lambdabot>   mueval-core: Time limit exceeded
07:35:50 <dafis> > take 1 $ foldr (\x ys -> x : let ws = case ys of { (z:zs) | z == x -> zs; _ -> ys } in ws) [] (repeat 'a')
07:35:51 <lambdabot>   "a"
07:36:15 <dafis> > take 2 $ foldr (\x ys -> x : let ws = case ys of { (z:zs) | z == x -> zs; _ -> ys } in ws) [] (repeat 'a')
07:36:19 <lambdabot>   mueval-core: Time limit exceeded
07:36:54 <Jafet> > map (length &&& head) $ group $ sort "aaabbbbcccddefffgggg"
07:36:55 <lambdabot>   [(3,'a'),(4,'b'),(3,'c'),(2,'d'),(1,'e'),(3,'f'),(4,'g')]
07:38:09 <dino-> Ugh, I'm getting jammed by the regex-posix linker problem with Platform 2010.2.0.0 for Windows
07:39:16 <Eduard_Munteanu> I think -O was able to take some 'sum' or 'foldl' into strict versions, IIRC.
07:39:26 <Eduard_Munteanu> (was scrolling above)
07:39:56 <dafis> Eduard_Munteanu: yes, there are rewrite rules for Int, Integer, Float, Double
07:40:06 <dafis> (perhaps some other types)
07:41:12 <Eduard_Munteanu> So sum [1..1000] fails on lambdabot because it doesn't optimize?
07:41:32 <Eduard_Munteanu> (erm, something bigger)
07:42:04 <Saizan> yeah
07:42:12 <dino-> Woo, solution was `cabal install regex-posix ; cabal install --reinstall regex-compat`
07:42:24 <morphles> hm ghci doesnt fail sum
07:42:56 <dafis> > sum [1 .. 1000000] :: Int
07:42:58 <lambdabot>   *Exception: stack overflow
07:43:05 <morphles> eats ram as hell though...
07:43:15 <Eduard_Munteanu> That's not good either.
07:43:19 <dafis> morphles: compiled, interpreted?
07:43:28 <morphles> interactive
07:43:34 <morphles> so not compiled
07:43:46 <companion_cube> > sum [1.. 1000000] :: Integer
07:43:47 <lambdabot>   *Exception: stack overflow
07:43:50 <dafis> morphles: then you get an ever increasing thunk
07:44:04 <ManateeLazyCat> This channel still hot like before. :)
07:44:05 <companion_cube> how comes ? shouldn't it be tail-rec ?
07:44:23 <dafis> @src sum
07:44:23 <lambdabot> sum = foldl (+) 0
07:44:35 <Jafet> What does tail recursion mean in Haskell, exactly?
07:44:44 <dafis> companion_cube: the thunk doesn't get evaluated in each step, so
07:45:17 <morphles> Jafet: isint it same as in other programming language?
07:45:18 <dafis> (0+1) ~> ((0+1)+2) ~> (((0+1)+2)+3) ~> ...
07:45:32 <morphles> what i want to se is haskell function that uses recursion but that is not tail recursive
07:45:35 <companion_cube> and it cannot replace a thunk by another, the same way tail-call replaces a stack frame by another ?
07:45:38 <Jafet> morphles: no, not really.
07:45:53 <morphles> ie i think my compress is tail recursive
07:46:07 <roconnor> > sin (1*pi/18)*sin(5*pi/18)*sin(7*pi/18) :: CReL
07:46:08 <lambdabot>   Not in scope: type constructor or class `CReL'
07:46:09 <Saizan> yes, tail recursion is the same, it's just that tail recursion is not enough to guarantee O(1) stack use
07:46:10 <roconnor> > sin (1*pi/18)*sin(5*pi/18)*sin(7*pi/18) :: CReEAL
07:46:10 <dafis> companion_cube: the thunk grows bigger and bigger
07:46:11 <lambdabot>   Not in scope: type constructor or class `CReEAL'
07:46:13 <roconnor> > sin (1*pi/18)*sin(5*pi/18)*sin(7*pi/18) :: CReal
07:46:14 <lambdabot>   0.125
07:46:20 <Jafet> Creole?
07:46:24 <companion_cube> ah ok, i see
07:46:33 <companion_cube> so one would need sum to be eager
07:46:47 <dafis> companion_cube: strict
07:47:04 <roconnor> I hit capslock instead of 'a'.
07:47:04 <dafis> companion_cube: a source of many annoyances
07:47:21 <Saizan> since, in this case, it'll consume O(1) stack while building up the thunk since that operation is tail recursive, but reducing the thunk itself will require O(n) stack
07:47:41 <Eduard_Munteanu> Caps lock, indeed one of the most useless keys...
07:47:45 <Saizan> because the operations inside it are strict
07:47:46 <dafis> and storing the thunk requires O(n) heap
07:47:57 <morphles> dafis: eagernes/strictenss = source of many annoyances?
07:48:01 <companion_cube> so, if you want to perform the sum in constant space, you have to write it yourself ?
07:48:12 <Eduard_Munteanu> I usually 'shift' my way through whole sentences with my pinky on the right shift key, if needed :)
07:48:12 <Jafet> roconnor: but caps lock is all the way at the bottom left corner!
07:48:15 <dafis> morphles: the definition of sum being what it is
07:48:20 <morphles> ah
07:48:24 <dafis> worst of both worlds
07:48:30 <Saizan> companion_cube: either turn on optimizations, or use foldl' (+) 0
07:48:47 --- mode: ChanServ set +o copumpkin
07:48:52 <dafis> for lazy number types, foldr would be far better, for strict ones, you want foldl'
07:49:00 <Saizan> yeah
07:49:06 --- mode: copumpkin set -b *!~b@unaffiliated/pozic
07:50:26 --- mode: copumpkin set +b *!*@unaffiliated/pozic
07:50:34 --- mode: copumpkin set -o copumpkin
07:51:36 <Eduard_Munteanu> > foldr (+) 0 [1..100000]
07:51:37 <lambdabot>   5000050000
07:51:49 <Eduard_Munteanu> > foldl (+) 0 [1..100000]
07:51:50 <lambdabot>   5000050000
07:51:56 <Eduard_Munteanu> Meh, too small
07:53:08 <Eduard_Munteanu> > foldr (+) 0 [1..2000000]
07:53:10 <lambdabot>   *Exception: stack overflow
07:53:50 <Eduard_Munteanu> I'm still not sure how strictness screws foldr up because it's supposed to be a "good" producer.
07:54:08 <Eduard_Munteanu> Is it because it forces evaluation in the wrong spot?
07:54:46 <dafis> Eduard_Munteanu: if the f in foldr f is strict in its second argument, you have to traverse the entire list before being able to produce anything
07:55:14 <Eduard_Munteanu> Oh, makes sense, thanks.
07:55:43 <dafis> Eduard_Munteanu: foldr (+) 0 [1 .. 10] ~> 1 + (2 + (3 + ...( 10 + 0)...))
07:55:57 <Eduard_Munteanu> Yeah.
07:56:40 <Eduard_Munteanu> I wonder, would defaulting to non-strict numbers in Haskell make sense?
07:56:53 <Eduard_Munteanu> *number ops
07:58:00 <dafis> Eduard_Munteanu: you can have non-strict ops only for lazy number types, for such, the ops are usually implemented non-strict where possible
07:59:34 <Eduard_Munteanu> So why are they (Int, Float etc.) strict now? To get them unboxed?
08:00:27 <Eduard_Munteanu> I'd rather have foldr behave correctly and add annotations myself for strictness. :/
08:01:12 <dafis> Eduard_Munteanu: They're not entirely strict (those are Int#, Float# etc in GHC), but for performance, you have to have sufficiently strict types
08:01:15 <Eduard_Munteanu> Unless foldl' + strict is somehow better than foldr + lazy.
08:01:30 <dafis> Eduard_Munteanu: faster
08:01:38 <obiwahn> hi i am just startig haskell and read the yaht im am stuck at example 3.10. id like to add a funtion that prints the original list at the beginning of output and worte a function oprintlist using putStr. now i'd like to have a linebreak and thoght i could do it with a putStrLn and worte something like:
08:02:06 <dafis> where the laziness isn't really usable
08:02:34 <obiwahn> oprintlist [] = do \n\t putStrLn " "\n\t return ()
08:02:49 <obiwahn> what is wrong with that condition?
08:03:39 <dafis> obiwahn: superfluous return (); oprintList [] = putStrLn "" should do what you want
08:04:36 <dafis> obiwahn: what error message did the compiler give?
08:04:57 <Eduard_Munteanu> dafis: hm, lemme think, is it that foldl' (+) gets turned into an iterative sum directly on the underlying unboxed type, while foldr in the lazy case turns into an iterative sum on boxed types, best case?
08:05:00 <obiwahn> i get the message "Not in scope: data constructor `PutStrLn'" but do not understand what ghci --- dafis nope still same error
08:05:33 <dafis> obiwahn: you typo'ed putStrLn with a capital P
08:05:35 <Eduard_Munteanu> I'd expect foldl' to be able to do it in-place, and foldr not, right?
08:07:40 <dafis> Eduard_Munteanu: foldl' (+) can be turned into a tight loop (appropriate types assumed), foldr (+) can be turned into a lazy producer (like foldr (++)) for appropriate types, so which is better depends on your types
08:07:41 <obiwahn> dafis: thaks so much:) 20 min wasted ..
08:08:48 <dafis> But, if your number type contains negative and positive numbers, foldr (+) can't know whether the result is positive or negative before it's got to the end, so then you've lost the (possible) advantages of foldr
08:09:07 <dafis> then foldl' (+) is in any case not worse
08:09:08 <chrisdone> Is this as boring as I thought it would be? http://www.youtube.com/watch?v=0Al9agyo7U4
08:09:17 <chrisdone> @title
08:09:38 <chrisdone> Uhm.
08:10:19 <chrisdone> Just a little 'screencast' of me coding. ._.
08:10:46 <Jonno_FTW> chrisdone: Watching now
08:10:55 <dafis> chrisdone: will something happen?
08:11:00 <geheimdienst> is it me, or is chrisdone a fast-typer ...
08:11:02 <geheimdienst> ;)
08:11:12 <dafis> not just you
08:11:18 <Jafet> Probably just special effects
08:12:01 <Jonno_FTW> but he isn't talking quickly though
08:12:52 <Eduard_Munteanu> LOL.
08:14:41 <Eduard_Munteanu> He seems to be a fast reader too.
08:15:50 <Jonno_FTW> chrisdone: why don't you use control.applicative?
08:15:58 <obiwahn> http://hpaste.org/43913/no_good_title
08:16:22 <obiwahn> what exactly is wrong with the 2nd version?
08:16:31 <chrisdone> Jonno_FTW: Couldn't be bothered including it? :P
08:17:13 <obiwahn> i can use putStrLn on its own above
08:17:15 <Eduard_Munteanu> obiwahn: olistprint returns something of type IO String
08:17:35 <Eduard_Munteanu> Erm, IO ()
08:17:43 <Eduard_Munteanu> olistprint (h:t) = putStr(show(h) ++ " " ++ olistprint(t))
08:17:44 <chrisdone> geheimdienst: It's since I got the Das keyboard. ;-)
08:18:01 <dafis> obiwahn: olistprint is an IO-action which prints out a list, so you can't (++) it; olistprint (h:t) =  putStr (show h ++ " ") >> olistprint t
08:18:07 <Jafet> Great, product placement
08:18:14 <chrisdone> Jafet: :D
08:18:57 * chrisdone .oO( Can you do product placement in IRC? Does that count? )
08:19:24 <Jafet> If that fails, you can always sell your screencast to TV producers looking for authentic typing sequences
08:19:36 <Jafet> It helps if you use nmap somewhere
08:19:52 <Jonno_FTW> hehehe
08:20:09 <chrisdone> I don't think I'm cut out for that. I don't have any password crackers. None that display a progress bar anyway.
08:21:11 <Jonno_FTW> I was thinking of writing an IRC bot
08:21:19 <Jonno_FTW> s/bot/client/
08:21:28 <ManateeLazyCat> chrisdone: Hi, how are you?
08:21:33 <Eduard_Munteanu> Yeah, maybe they can feature chrisdone's stuff on CSI or something :P
08:21:40 <chrisdone> ManateeLazyCat: Good, thanks.
08:21:50 <Jonno_FTW> Are there any simple projects that I could do in haskell?
08:21:56 <Eduard_Munteanu> Especially since "hackers use IRC", or what was that ruse.
08:21:57 <chrisdone> ManateeLazyCat: How are you?
08:22:03 <Jafet> I'm sure lambdabot could do product placement, rather than insulting people's intelligence directly
08:22:04 <ManateeLazyCat> chrisdone: Busy. :)
08:22:11 <chrisdone> Eduard_Munteanu: Yeah, on, uh, Numb3rs.
08:23:09 * chrisdone supposes no one noticed he switched accents half way through
08:23:42 <obiwahn> :) works - thanks dafis 
08:24:16 <Jonno_FTW> chrisdone: I was wondering about that, I thought it was american then it sounded british then something else
08:25:19 <chrisdone> Jonno_FTW: Haha. I like the idea of it just slipping in without being obvious, but still somehow eerie.
08:25:58 <Jonno_FTW> kept me guessing the whole way through A+ def would watch again
08:26:50 <chrisdone> Just as planned. \(-_-)/
08:42:00 <ManateeLazyCat> @time
08:42:01 <lambdabot> Local time for ManateeLazyCat is Sun Feb 13 01:04:38 2011
08:42:04 <ManateeLazyCat> Night all! :)
08:42:45 <gwern> > 29 / 355
08:42:46 <lambdabot>   8.169014084507042e-2
08:42:52 <gwern> > (29 / 355) * 100
08:42:53 <lambdabot>   8.169014084507042
08:42:57 <aristid> > 29 % 355
08:42:58 <lambdabot>   29 % 355
08:43:19 <dafis> gwern: ?
08:43:40 <dafis> > 355 / 113
08:43:41 <lambdabot>   3.1415929203539825
08:43:48 <gwern> dafis: filing a bug report for Nevernote pointing out the absurdity that the export to verbose XML takes up 8% of the disk space of ~/.nevernote/'s binary formats
08:44:02 <gwern> dafis: do you have a problem with that?
08:44:03 <dafis> ah
08:44:15 <dafis> no, course not, was just curious
08:44:18 <mzero> can you upload packages to hackage with wildcard dependencies?
08:44:28 <mzero> like snap-server ==0.4.*
08:44:30 <gwern> https://sourceforge.net/apps/phpbb/nevernote/viewtopic.php?f=5&t=97
08:44:36 <dafis> mzero: wildcard dependencies?
08:44:37 <gwern> mzero: does cabal check complain? if not, then yes
08:44:46 <dafis> mzero: that, yes
08:44:47 <mzero> it complains
08:44:55 <mzero> The package uses wildcard syntax in the 'build-depends' field
08:45:02 <mzero> is the message
08:45:03 <dschoepe> I have a CT-question: If I have a function cp that maps a list of sets to the cartesian product of those sets, would that be, if it is one at all, a natural transformation from (list ∘ P) to (P ∘ list), where P is the powerset functor on Set?
08:45:21 <dafis> mzero: you have to specify Cabal-version >= 1.6 or so then
08:45:31 <mzero> ah - great
08:45:45 <dafis> mzero: I don't know when exactly Cabal got that
08:46:11 <mzero> i'll just put >= 1.8
08:46:12 <gwern> cabal check should've told you that it needs a higher cabal-version... it does with some other errors
08:46:15 <mzero> since that is what I have
08:46:50 <gwern> mzero: if you have time, install darcs cabal and see whether it fails to mention the cabal-version fix; if it does, file a bug report, I think
08:49:47 <Naypam> Prelude> take _ fire
08:49:47 <Naypam> <interactive>:1:6: Pattern syntax in expression context: _
08:49:56 <Naypam> where fire is [1,2,3]
08:50:06 <Naypam> I'm confused!
08:50:17 <rwbarton> so am I :)
08:50:26 <rwbarton> what are you trying to do?
08:50:33 <Jonno_FTW> ^
08:50:49 <Naypam> get the 1st element of the list through patern matching!
08:51:10 <rwbarton> let x:_ = fire in x
08:51:24 <Jonno_FTW> @src take
08:51:25 <lambdabot> take n _      | n <= 0 =  []
08:51:25 <lambdabot> take _ []              =  []
08:51:25 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
08:51:57 <Jonno_FTW> take isn't defined for the way you are trying to use it
08:53:22 <byorgey> chrisdone: you may be interested in the --no-comments or -m flags to cabal init =)
08:57:24 * hackagebot STMonadTrans 0.3.1 - A monad transformer version of the ST monad  http://hackage.haskell.org/package/STMonadTrans-0.3.1 (JosefSvenningsson)
08:58:00 --- mode: ChanServ set +o copumpkin
08:58:04 * BMeph wonders what Naypam was doing, too....
08:58:12 --- mode: copumpkin set -b *!*@unaffiliated/pozic
08:59:11 --- mode: copumpkin set -o copumpkin
09:12:25 <vegai> haskell on ARM isn't really an active project, is it?
09:13:54 <copumpkin> vegai: not really, but the llvm stuff could make it fairly easy, especially if dankna is successful making "runtime" cross-compilation work nicely
09:14:08 <copumpkin> but GHC definitely doesn't have its own ARM codegen
09:14:23 <copumpkin> JHC produces nice C code that you could compile with an ARM compiler
09:17:21 <jonkri> what does "ask = id" mean in "instance MonadReader r ((->) r) where"? how does it get the context of the monad?
09:17:47 <copumpkin> do you understand how the ((->) r) monad works?
09:18:25 <jonkri> no, never even heard of it
09:18:29 <copumpkin> oh okay
09:18:48 <copumpkin> well, I'd start by looking at that, maybe starting at functor and applicative :)
09:19:27 <copumpkin> instance Functor ((->) r) where fmap = (.)
09:19:34 <dcolish> I'm having some issues with Network and the redis client library. I've reduced the problem to something like this http://hpaste.org/43916/network_test
09:20:05 <dcolish> i'm really not sure why that error is being throw since the server is running an every other redis lib i've used can connect to it
09:20:52 <dankna> goooood afternoon
09:21:40 <jonkri> copumpkin: ok, thanks. i know what functor and applicative is
09:21:57 <copumpkin> jonkri: I mean for the ((->) r) type constructor though
09:21:59 <copumpkin> the instances :)
09:22:11 <copumpkin> > join (+) 5
09:22:11 <lambdabot>   10
09:22:58 <copumpkin> > liftM2 (+) (*2) (^3) 5
09:22:59 <lambdabot>   135
09:24:59 <jonkri> where can i look it up?
09:26:07 <periodic> copumpkin: ((->) r) as a functor still doesn't make sense to me...
09:26:31 <copumpkin> class Functor f where fmap :: (a -> b) -> (f a -> f b)
09:26:35 <periodic> Heck, ((->) e) as a type is something I haven't figure dout yet.
09:26:40 <copumpkin> let f = ((->) r)
09:27:03 <copumpkin> so fmap on that means (a -> b) -> (r -> a) -> (r -> b)
09:27:08 <Saizan> dcolish: as a guess, have you tried "127.0.0.1" rather than "localhost" ?
09:27:09 <copumpkin> how many functions to you know that fit that bill?
09:27:58 <jonkri> copumpkin: why parenthesis around (f a -> f b)?
09:27:58 <copumpkin> jonkri: not sure where the actual monad instance for that lives
09:28:07 <copumpkin> jonkri: because I think it makes the meaning of fmap clearer
09:28:11 <copumpkin> even if it's identical
09:28:36 <jonkri> i don't know if i agree, but ok :P
09:28:49 <accel> has anyone here released a Mac store app written in Haskell ?
09:28:49 <lambdabot> accel: You have 1 new message. '/msg lambdabot @messages' to read it.
09:28:59 <monochrom> no
09:29:26 <copumpkin> jonkri: "fmap takes any function a -> b to a function f a -> f b, working over the same types transformed by the functor f"
09:29:28 <accel> lambdabot: message
09:29:33 <accel> lambdabot: @message
09:29:33 <lambdabot> Maybe you meant: messages messages?
09:29:45 <jonkri> i know
09:30:04 <copumpkin> jonkri: so the parentheses make it clear that it's taking a function to a function
09:30:04 <jonkri> let me start by asking this: why would you want a function called "->"?
09:30:15 <jonkri> as that exact notation is used for something else (right?)
09:30:20 <copumpkin> no, it's the same one
09:30:21 <dcolish> Saizan: yup, first thing I did, the odd thing is that this code: https://github.com/bumptech/redis-haskell/blob/master/src/Database/Redis/Core.hs#L58, does connect correctly
09:30:30 <dcolish> its a different library thats not in hackage yet
09:30:45 <copumpkin> jonkri: it's a partially applied function arrow type
09:30:57 <copumpkin> jonkri: as I illustrated above in the functor instance for it
09:30:58 <srobertson> In TH, are the values (AppT (ConT n) (AppT (VarT a) (VarT b))) and (AppT (AppT (ConT n) (VarT a)) (VarT b)) equivalent? (that is, is AppT associative?)
09:31:46 <adnap> do you think pattern matching on value contructors should be avoided?  if you decide to change the order of any of the values in the constructor, the match breaks.
09:32:06 <Saizan> dcolish: i don't know then
09:32:41 <dcolish> ok thanks, I think it has to do with the first argument to getAddrInfo being None in the failing library
09:33:08 <monochrom> use record syntax. data X = X {a,b::Int};  f X{a=0} = True; f X{b=1} = True; f _ = False
09:33:13 <dcolish> but i would have hope that connectTo would put in sensible defaults for that if it is a higher level library
09:33:37 <monochrom> alternatively don't change order!
09:33:41 <jonkri> how can you tell from ((->) r) that it's partially applied?
09:33:48 <Saizan> preflex: seen tibbe
09:33:48 <preflex>  tibbe was last seen on #ghc 12 hours, 8 minutes and 51 seconds ago, saying: gcollins: snap is hang
09:34:23 <dcolish> hmm, maybe its something osx related, that works on linux
09:34:27 <adnap> how do you search hoogle in here?
09:34:36 <monochrom> @hoogle a->a
09:34:37 <lambdabot> Prelude id :: a -> a
09:34:37 <lambdabot> Data.Function id :: a -> a
09:34:37 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
09:35:01 <adnap> @hoogle (a, b) -> (a -> b)
09:35:02 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
09:35:02 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
09:35:02 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
09:35:02 <copumpkin> I'd expect not
09:35:02 <copumpkin> (f a) b ~ f (a b) ?
09:35:02 <copumpkin> when you write f a b, it's the former
09:35:02 <copumpkin> the latter applies a to b, and f to the result
09:35:35 <copumpkin> jonkri: (->) has kind * -> * -> *
09:35:39 <copumpkin> and it's applied to one parameter
09:35:48 <copumpkin> so the resulting type is of kind * -> *
09:36:14 <copumpkin> (ignoring that (->)'s actual kind is a superkind of that, but it's not relevant here, so no need to bring it up)
09:36:28 <Tinned_Tuna> mmm, categories
09:37:32 <jonkri> lol @ (->):: ?? -> ? -> *
09:37:45 <jonkri> but ok
09:38:08 <copumpkin> if that means something to you, that's fine
09:38:12 <copumpkin> but the same basic point applies :)
09:39:19 <jonkri> so it's a type constructor?
09:39:23 <copumpkin> yep
09:39:25 <jonkri> didn't someone say function above?
09:39:41 <copumpkin> it's the function arrow
09:39:46 <copumpkin> which happens to be a type constructor
09:39:51 <jonkri> oh ok
09:39:52 <copumpkin> and a function on types
09:40:22 <jonkri> i think i get ((->) r) now...
09:40:42 <copumpkin> the nice thing about it is that its functor/applicative/monad instances are almost forced
09:40:47 <jonkri> but why using the arrow at all? why not just add the times separated by spaces... like IO Int or whatever
09:41:03 <adnap> @hoogle (a -> b -> c) -> ((a, b) -> c)
09:41:04 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
09:41:04 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
09:41:04 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
09:41:04 <copumpkin> unless you want to go throwing bottoms around, there's only one possible instance
09:41:05 <jonkri> s/times/types
09:41:09 <copumpkin> jonkri: huh?
09:41:15 <adnap> ooh
09:41:26 <copumpkin> jonkri: oh, you're just wondering about haskell syntax?
09:41:39 <copumpkin> because IO Int and IO -> Int mean very different things (and the latter is badly formed)
09:41:42 <vegai> anyone know about the design philosophy of Yesod's persistent?
09:41:54 <jonkri> copumpkin: how are they different?
09:42:07 <copumpkin> IO Int = apply IO to Int
09:42:13 <vegai> from the Yesod book: "So let's explain the non-relationality of Persistent again: Persistent doesn't do joins. The data structure itself, however, can be completely relational. The burden is on the programmer to do this."
09:42:16 <copumpkin> IO -> Int = a function from IO (which isn't fully formed) to Int
09:42:29 <copumpkin> or rather, the _type_ of a function from IO (which isn't fully formed) to Int
09:42:37 <jonkri> aha ok
09:42:43 <vegai> this seems to mean that it doesn't use the rdbms for anything more than a key-value -store
09:43:06 <vegai> which is, of course, not very good if you ask any DBA..
09:43:16 <jonkri> so what is going on here:
09:43:17 <jonkri> instance MonadReader r ((->) r) where
09:43:17 <jonkri>     ask       = id
09:44:15 <jonkri> what is the relation between r and ((->) r)?
09:45:33 <periodic> vegai: could be.  I'm going to try to figure that all out today.
09:46:01 <mreh> how do i view the contents of darcs change?
09:46:02 <periodic> jonkri: r is just a place holder sort of.  ((->) r) is an r. :)
09:46:57 <copumpkin> jonkri: wait, do you see how Monad works for it? and what the ((->) r) "means"?
09:47:07 <copumpkin> also, what MonadReader "means"? :P
09:47:10 <dino-> mreh: YM like the actual changes to the file(s)? Like with --verbose
09:47:45 <byorgey> mreh: darcs changes -v, or darcs diff
09:48:24 <Saizan> copumpkin: have you converted vector-static to TypeNats, by chance?
09:48:34 <copumpkin> Saizan: I have not! but would welcome someone doing that :)
09:48:40 <copumpkin> Saizan: I haven't yet installed typenats
09:48:47 <mreh> ah
09:48:50 * Saizan tries
09:48:59 <copumpkin> Saizan: do you have a GHC with typenats working?
09:49:05 <mreh> what's all this +vvvvvvvvv and +^^^^^^^^^ business?
09:49:29 <dino-> mreh: merge conflict
09:49:42 <jonkri> copumpkin, periodic: no, i don't see that yet... and that ((->) r) is an r doesn't make any sense whatsoever in my head :P
09:49:52 <copumpkin> jonkri: it isn't an r
09:49:58 <dino-> mreh: This may help: http://wiki.darcs.net/ConflictsFAQ
09:50:11 <byorgey> mreh: conflict markers
09:50:12 <dcolish> Saizan: i've got it, the default addrFamily on osx turns out to be AF_INET6
09:50:14 <periodic> jonkir: Yeah, I may have just been confusing.
09:50:16 <copumpkin> jonkri: ((->) r) is often called "Reader" (wrapped in a type called Reader)
09:50:33 <copumpkin> jonkri: in the sense that it allows you to pass an "implicit" parameter around
09:50:39 <copumpkin> often called the environment
09:50:57 <copumpkin> and you don't have to worry about making all your functions take that environment
09:51:06 <copumpkin> MonadReader is an abstraction over readers of that sort
09:51:09 <mreh> dino-: byorgey thanks
09:51:14 <copumpkin> and ask is the function that you use to read the environment
09:51:27 <copumpkin> in ((->) r), r is the environment
09:51:42 <copumpkin> so instance MonadReader r ((->) r) is just saying that you can read r out from ((->) r)
09:51:52 <copumpkin> and the definition of ask is trivial
09:51:58 <periodic> time to change venues for me.  I look forward to copumpkin's thorough explanation.
09:54:11 <jonkri> how does this implicit parameter work? how is it provided to all functions in the reader monad?
09:56:01 <Peaker> Does the pure-fft package work correctly? I think it may be buggy and I want to look at a reference FFT implementation :)
09:57:11 <copumpkin> jonkri: not really sure how to explain that. a "monadic value" of the reader monad is a function from the environment to the type of the monadic value
09:58:16 <jonkri> i think i have an intuitional understanding of it now
09:58:31 <rwbarton> jonkri: maybe it's also useful to look at the definition of the MonadReader class:  class MonadReader r m where { ask :: m r ; {- other methods that are irrelevant -} }
09:58:39 * hackagebot barley 0.3 - A web based environment for learning and tinkering with Haskell  http://hackage.haskell.org/package/barley-0.3 (JohanTibell)
09:59:22 <rwbarton> so if m is ((->) r) then the type of ask would be ((->) r) r or r -> r
10:00:52 <jonkri> crazy
10:02:38 <Saizan> copumpkin: yep
10:02:44 <copumpkin> cool
10:02:57 <copumpkin> Saizan: have you tried refining a GADT index to a multiplication? :P
10:03:35 <roconnor> coming up with new abstractions is hard
10:03:40 <Saizan> copumpkin: like data Foo a b where FooC :: Foo a (a * a) ?
10:03:53 <copumpkin> Saizan: yeah
10:04:03 <copumpkin> just curious what it does
10:06:01 <roconnor> @pl \b f -> f b
10:06:01 <lambdabot> flip id
10:06:01 <mreh> say I need to correct a typo in a comment, or neaten up some lines, amend-record?
10:07:29 <roconnor> mreh: have you distributed your patch to any other repo?
10:07:42 <mreh> roconnor, nup
10:07:52 <Saizan> copumpkin: seems to work fine http://hpaste.org/43918/test_nats
10:07:54 <roconnor> then ammend-record is safe AFAIK
10:08:24 <roconnor> I use it all the time
10:08:40 <roconnor> ... granted I don't really collaborate with darcs
10:09:24 <mreh> I'm playing with it, but I suppose it's good to track what you've done atleast
10:09:34 <copumpkin> whoops, got disconnected
10:11:52 <dino-> amend-record is also good for when you screwed up and didn't include a change that logically should be part of a specific record.
10:11:54 <Tomsik> Admit it, you're all here because you're so hipster you won't use Java
10:12:04 <Saizan> copumpkin: seems to work fine http://hpaste.org/43918/test_nats -- resent
10:12:32 <copumpkin> [01:27:34 PM] <copumpkin> or even data Foo a where FooC :: Foo (a * a)
10:12:32 <copumpkin> [01:27:39 PM] <copumpkin> will it disallow Foo 17 ?
10:12:55 <copumpkin> I guess undefined :: Foo 17
10:18:31 <XniX23> will learning haskell really make me depressed? :(
10:18:40 <Saizan> copumpkin: http://hpaste.org/paste/43918/test_nats_annotation#p43919
10:18:52 <ceii_> XniX23: yeah Haskell is depressing
10:19:01 <ceii_> it still doesn't make programming easy
10:19:10 <ceii_> but every other language sucks compared to it
10:19:13 <copumpkin> Saizan: whoa,     Couldn't match type `n ^ 2' with `17'                                                                                                              
10:19:16 <ceii_> so there's no way out
10:19:24 <copumpkin> it saw n * n and wrote n ^ 2
10:19:24 <XniX23> ceii_: i was think about not being able to use haskell at work
10:20:12 <Saizan> yeah, there's some quite liberal simplication going on
10:21:31 <ceii_> XniX23: the problem with haskell is that the implementation is a bit heavyweight for stealth introduction
10:21:44 <ceii_> so you'll need to actually discuss it with others
10:22:10 <ceii_> and chances are they'll tell you they don't want a language they'd need months to learn
10:22:13 <ksf> compiled things are quite small and portable
10:22:50 <ceii_> ksf: true
10:23:23 <ksf> the best way to sneak haskell in is to say "I'm just going to prototype this", and then, incidentally, write production-quality code in 1/2 of the time a prototype would've taken you in the officialy endorsed language
10:23:53 <vegai> argh, that search button
10:23:53 <alex404_> Are there any examples of large scale industrial uses of functional programming?
10:25:02 <ksf> alex404_, http://cufp.org/
10:25:05 <ksf> read their propaganda
10:25:40 <alex404_> Is it more than propaganda? ;)
10:25:52 <ksf> everything is propaganda
10:26:14 <shapr> alex404_: At some level you could argue that Google is large scale use of functional programming. They use MapReduce, right?
10:27:16 <alex404_> shapr: Hmm... that's actually an interesting point...
10:28:13 <dankna> however, I think that would be a difficult argument to make.  Google has rules about what languages can be used; the set of first-tier languages is like ... Java and I think I heard two others but I'm not sure what they were.
10:28:44 <vegai> C++ & Python?
10:29:31 <alex404_> dankna: Indeed...
10:29:39 <alex404_> Well, here
10:30:26 <alex404_> here's the question someone recently asked me: Are typical functional programming languages suitable for large scale development?
10:30:41 <alex404_> My feeling leans towards no
10:30:41 <companion_cube> common lisp
10:30:59 <alex404_> Beyond emacs?
10:31:35 <gwern> alex404_: I suppose you could ask Orbitz
10:32:03 <alex404_> Ah, apparently this is the discussion I'm looking for: http://lambda-the-ultimate.org/node/2491
10:32:33 <Twey> ‘Beyond emacs’?
10:33:25 <alex404_> I meant emacs is the only widely used, highly developed piece of list code I could think of
10:33:35 <alex404_> (not that I know much about this stuff)
10:33:43 <smarmy> what's the most idiomatic way of using Writer for append these days?  i've been using Writer (DList a) and wrapping tell into a tell . DList.singleton helper
10:35:17 <Twey> alex404_: emacs isn't in Common Lisp
10:35:34 <Twey> (not that Common Lisp is really a functional language, at that)
10:35:48 <Twey> (but elisp, which is used in emacs [along with C] is even less of one)
10:35:52 <companion_cube> alex404_, also erlang, perhaps
10:36:01 <Twey> Yeah, Erlang's used in a lot of popular stuff
10:36:03 <companion_cube> used in routers
10:36:08 <companion_cube> in ejabberd
10:36:10 <Twey> And Facebook Chat
10:36:11 <Twey> Yeah
10:36:14 <Twey> I hear Twitter are using Scala these days
10:36:24 <Eduard_Munteanu> Maxima is also using clisp
10:36:58 <alex404_> Twey: Good to know
10:37:11 <periodic> Twey: for the back-end processing I think.  They still used Rails for their front end as of a year ago I think
10:37:12 <alex404_> companion_cube: Of course. Forgot about Erlang.
10:37:22 <Twey> There are some finance firms using Haskell
10:37:51 <Bynbo7> all our stuff is written in haskell
10:38:13 <Bynbo7> and it's making up monies :)
10:38:32 <companion_cube> or ocaml
10:38:37 <Twey> Yeah, OCaml is used there too
10:38:47 <Eduard_Munteanu> smarmy: um, Writer over plain lists?
10:38:50 <Twey> F# is starting to get popular, I hear
10:40:11 <Eduard_Munteanu> Meh, those are boring. :P
10:40:30 <Eduard_Munteanu> (Probably in the same way Haskell is boring for Coq-heads)
10:40:40 * monochrom invents the word "high-level-wise".
10:41:07 <Eduard_Munteanu> (erm, pun not intended)
10:41:09 * vegai smirks at "Coq-heads"
10:43:25 <djahandarie> I don't think much programming is actually done in Coq
10:43:53 <djahandarie> I've played with it a little and it seems awfully inconvenient for that
10:44:44 <Eduard_Munteanu> Well, I'm sure there are lots of math people thinking Haskell is boring / useless for them.
10:44:57 <Eduard_Munteanu> And they'd use Coq.
10:45:25 <Eduard_Munteanu> Damn those French for picking a name it's hard to be serious about.
10:45:33 <geheimdienst> Eduard_Munteanu: boring and useless describes quite well how i feel towards much of math ...
10:46:07 <companion_cube> djahandarie, there is at least the CompCert C compiler, written by INRIA
10:47:31 <Sa[i]nT> I'm on the "Try Haskell" page chatting haha.
10:47:38 <Sa[i]nT> This language is pretty neat.
10:48:03 <Eduard_Munteanu> You're on IRC (Freenode), actually
10:48:25 <babas> =0
10:48:52 <Sa[i]nT> Yeah I know, I hang on freenode. But in the C++ rooms and whatnot. I'm looking for another language. I guess classic curiousity.
10:49:39 <Eduard_Munteanu> Well, if you're looking for something different (e.g. not "yet another language"), perhaps you're in luck.
10:49:44 <companion_cube> :D
10:50:07 <Sa[i]nT> Yeah I'm liking the hell out of this one so far.
10:51:11 <Eduard_Munteanu> Wait till you get into monads :P
10:51:40 <jmcarthur> the fascination with monads is what turns non-haskellers off to the language, and i don't understand the fascination in the first place
10:51:50 <jmcarthur> they aren't particularly interesting or special
10:52:04 <systemfault> Hmm, the turn off so far for me is the terminology
10:52:18 <jmcarthur> well, yeah, i meant among other things
10:52:31 <Eduard_Munteanu> Surely they are, ask edwardk about monads, comonads, Yoneda, Kan extensions etc. :P
10:52:36 <Maxdamantus> Uninteresting compared to what?
10:52:42 <geheimdienst1> systemfault: the terminology is a big problem, unfortunately
10:52:43 <companion_cube> arrows ?
10:53:00 <jmcarthur> the terminology is so different just because it's very different from other languages and we kind of started with a clean slate and borrowed things from mathematics
10:53:12 <Maxdamantus> imo they're interesting, having never thought of something like a monad directly in another language.
10:53:15 <jmcarthur> Maxdamantus: uninteresting compared to things that are actually a part of the language
10:53:23 <systemfault> jmcarthur: I agree, I haven't given up on haskell :P
10:53:31 <companion_cube> but monads are part of the language
10:53:47 <companion_cube> and of many interesting libs, like parsec or STM
10:53:49 <jmcarthur> Maxdamantus: uninteresting because it's only one of many possible things you can implement in haskell and doesn't really deserve all this special attention
10:53:53 <Maxdamantus> :t \a -> do a
10:53:54 <lambdabot> forall t. t -> t
10:54:02 <jmcarthur> companion_cube: they are part of the standard library and have some syntax sugar and that's it
10:54:04 <geheimdienst1> jmcarthur: some terminology is blazingly clear, e.g. Either, Maybe, Nothing. but you're right, most of it is obscure math jargon
10:54:06 <Maxdamantus> > (\a -> do a) 42
10:54:07 <lambdabot>   42
10:54:09 <Maxdamantus> O_o
10:54:17 <jmcarthur> companion_cube: we don't go "omg lists" all the time...
10:54:22 <Maxdamantus> :t \a -> do { a; a }
10:54:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
10:54:31 <Eduard_Munteanu> Actually terminology had to be invented anyway.
10:54:33 <systemfault> Looks like there's no way to vulgarize the term "monad", I think I understand what they are... but still isn't 100% sure
10:54:52 * hackagebot dataenc 0.13.0.5 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.13.0.5 (MagnusTherning)
10:54:56 <monochrom> I was fascinating by monads because Wadler shows how it is a nice refactoring or modularization or whatever. http://groups.google.com/group/comp.lang.functional/msg/f42e5d7169837b37 http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
10:55:04 <Eduard_Munteanu> And using names like 'mappend' doesn't make it any better for generality.
10:55:15 <companion_cube> jmcarthur, there's "do" syntactic sugar, and it's amazing to see how powerful abstractions you can build on that
10:55:16 <jmcarthur> mappend is a terrible name
10:55:26 <jmcarthur> companion_cube: lists have syntactic sugar
10:55:29 <geheimdienst1> sometimes i feel one feynmanish guy with great clarity of thought came up with Either and so on, then walked off and the math-heads came in
10:55:47 <companion_cube> yeah, but not parsec or STM, afaik
10:55:58 <Eduard_Munteanu> IMHO, math names are okay, just stick math names to those objects, and a comment describing that stuff in common language.
10:56:19 <companion_cube> (and haskell is, in my knowledge, the only language with STM which really prevents IO from being performed within transactions) 
10:56:48 <systemfault> If you tell me that monads are some endofunctor math category stuff.. you lost me.
10:57:03 <jmcarthur> companion_cube: my point is that it's not monads but haskell's *other* language features that make these things possible
10:57:24 <Eduard_Munteanu> They are endofunctors in Hask, in Haskell, really :P
10:57:26 <jmcarthur> companion_cube: STM could lack the syntax sugar and have to use return and >>= directly, but would still have all the benefits it currently does
10:57:32 <companion_cube> yeah
10:57:40 <companion_cube> but "do" it what makes it really natural
10:57:43 <companion_cube> is*
10:57:44 <jmcarthur> and return and >>= could not be in some monad type class, and we'd still have all those benefits :)
10:58:02 <jmcarthur> (except for some of the convenient general monad functions)
10:58:02 <Eduard_Munteanu> 'return' is misleading at times though.
10:58:03 <companion_cube> well, if not in typeclass, you lose generic combinators on monads
10:58:06 <companion_cube> exactly
10:58:15 <jmcarthur> but that's not a huge contribution, honeslty
10:58:17 <jmcarthur> *honestly
10:58:23 <jmcarthur> there are only a handful of those
10:58:30 <McManiaC> grouping statements for monad comprehensions introducing a new "Control.Monad.Group" class: http://npaste.de/xN/
10:58:33 <McManiaC> :D
10:58:43 <companion_cube> ok, monads are only possible because of non-strictness and type system
10:58:44 <McManiaC> for lists it works just fine
10:58:46 <jmcarthur> it's important, IMO, but the presence of those in the language is not a language-defining thing
10:58:53 <jmcarthur> *in the library
10:58:58 <monochrom> oh the monad comprehension guy!
10:59:15 <companion_cube> jmcarthur, imho monads are what make haskell usable in real world
10:59:30 <jmcarthur> haskell would be just as useable without some expicit monad abstraction
10:59:33 <companion_cube> because otherwise, how do you perform IO in a clean way ?
10:59:39 <copumpkin> McManiaC: what's in the MonadGroup class?
10:59:41 <jmcarthur> IO exists regardless of Monad
10:59:41 <roconnor> monadic IO make haskell usable in the real world
10:59:55 <companion_cube> errr, how do you perform IO without the monad ?
10:59:55 <jmcarthur> didn't IO exist before Monad, even?
10:59:57 <Maxdamantus> Haskell itself isn't *that* interesting, afaics
10:59:57 <jmcarthur> in some form
11:00:02 <Eduard_Munteanu> Arrow-y IO is ok too.
11:00:07 <Maxdamantus> It's how you use what you do have.
11:00:10 <jmcarthur> companion_cube: the Monad instance is just build on returnIO and bindIO. it's not special
11:00:13 <jmcarthur> *built
11:00:14 <monochrom> Andrew Gordon's phd thesis shows how to perform I/O in 3 clean ways. Then again his tone seems to favour monad.
11:00:18 <Eduard_Munteanu> In fact there could be different constructions of IO I suppose.
11:00:18 <McManiaC> class Monad m => MonadGroup m where groupM :: Ord t => (a -> t) -> m a -> m (m a); instance MonadGroup [] where groupM = groupWith
11:00:24 <McManiaC> @ copumpkin 
11:00:37 <jmcarthur> companion_cube: you'd still be able to do IO without Monad
11:00:38 <companion_cube> Eduard_Munteanu, certainly, but that would not be haskell anymore
11:01:08 <monochrom> But note: there is also how to perform I/O in the Clean way. :)
11:01:14 <jmcarthur> companion_cube: it just so *happens* that IO forms an instance of Monad, and we use that a lot, but it's not necessary for what IO is
11:01:24 <Eduard_Munteanu> Ah, that too.
11:01:42 <monochrom> (nice to be able to play pun on "clean" :) )
11:01:43 <copumpkin> McManiaC: ah
11:01:45 <companion_cube> jmcarthur, you can program without non-strictness or closures
11:01:46 <Eduard_Munteanu> That's probably easier to comprehend without CT.
11:01:52 <jmcarthur> i do think the syntax sugar is what make IO catch on. it just looks pretty though
11:02:06 <jmcarthur> companion_cube: my point is that the Monad instance isn't necessary for IO to even be convenient
11:02:19 <jmcarthur> companion_cube: we could have just stuck the syntax sugar in for IO only and gotten away with that
11:02:29 <jmcarthur> or not, even
11:02:31 <companion_cube> yeah, but it would be a hack
11:02:38 <jmcarthur> Monad syntax sugar is a hack anyway
11:02:40 <companion_cube> and haskell is supposed to be elegant
11:02:46 <jmcarthur> i don't find do notation elegant
11:02:51 <companion_cube> a very small, syntactic only hack
11:03:08 <jmcarthur> it's just an attempt to make haskell look imperative, which i think has led to great disaster in declarative programming research
11:03:13 <jmcarthur> because now we pretend it's "solved"
11:03:16 <Eduard_Munteanu> jmcarthur: well I'm not sure there's any alternative for some flavours of imperative code.
11:03:32 <shachaf> jmcarthur: Except for conal. :-)
11:03:36 <jmcarthur> Eduard_Munteanu: that's begging the question
11:03:45 <jmcarthur> shachaf: and myself and a few others
11:03:58 <companion_cube> sometimes, you have to do imperative things, like "write something on the console"
11:04:20 <shachaf> companion_cube: Sometimes, you have to do imperative things, like "set x to the value of x plus 1".
11:04:25 <jmcarthur> companion_cube: conal calls this "proof by lack of imagination"
11:04:50 <companion_cube> shachaf, not really
11:04:51 <conal> :)
11:04:55 * monochrom retracts "high-level-wise" and goes for "coarsely speaking"
11:05:03 <periodic> Do is convenient though.
11:05:09 <periodic> Once you know what you're doing.
11:05:13 <jmcarthur> companion_cube: why must it be phrased as "write something on the console"? why not "the time-varying value of the console"?
11:05:14 <shachaf> companion_cube: Exactly.
11:05:17 <periodic> Though I guess I could just line up the >> with the =
11:05:20 <companion_cube> oh
11:05:32 <companion_cube> true, a FRP interface to the world would be nice
11:05:36 <companion_cube> let's write it !
11:05:39 <Eduard_Munteanu> Well, binding around is sometimes cumbersome, what's wrong with top-to-bottom, each statement on its line style when it's really difficult to write it differently?
11:05:49 <jmcarthur> companion_cube: that was but one suggestion, of course
11:06:15 <jmcarthur> companion_cube: there are probably tons of other ways to interact with "the real world" in meaningful ways
11:06:21 <jmcarthur> declarative ways, that is
11:06:52 <companion_cube> ok, you're right
11:07:11 <jmcarthur> this goes away from my original point though
11:07:25 <Eduard_Munteanu> Imperative is essentially "I can't tell you what 'x' is, but here's what you can do to get it...".
11:07:27 <companion_cube> haskell is still too imperative :D
11:07:27 <jmcarthur> which was just that the Monad instance isn't a necessary part of the IO functor :)
11:07:47 <jmcarthur> the *functionality* of that instance is important, though
11:08:23 <jmcarthur> Eduard_Munteanu: "... but here's what you can do to get it assuming you start with this initial state which may be just as hard to specify"
11:08:26 <companion_cube> anyway, history favoured monads in haskell, and now they are a feature of the language
11:09:06 <Eduard_Munteanu> Yeah, some sort of "YMMV up to state" :)
11:11:58 <dschoepe> The terminal objects in the category of functors from B -> A, are the constant functors that map each object of B to a terminal object in A, if there is one. Is that correct?
11:13:17 <rwbarton> yes
11:14:01 <dschoepe> rwbarton: thanks
11:14:59 <dschoepe> (ab)using #haskell for checking solutions for exercises from category theory books works really well :)
11:15:13 <rwbarton> in general all (co)limits in functor categores are computed objectwise and terminal object = the empty limit
11:21:27 <flippo> dschoepe, try a cargomorphism next time
11:25:46 <javagamer> Is there any reason span odd LIST would not do the opposite of span even LIST?
11:26:20 <aavogt> javagamer: how do you define opposite here?
11:26:22 <shachaf> jmcarthur: What does "opposite" mean?
11:26:22 <javagamer> span even works as expected, but spawn odd always has one list empty even when there are odd and even numbers
11:26:38 <dafis> > span odd [1,3,5,6,7,8]
11:26:39 <lambdabot>   ([1,3,5],[6,7,8])
11:26:52 <shachaf> javagamer: span is just takeWhile and dropWhile combined.
11:27:14 <copumpkin> > partition odd [1..10]
11:27:15 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
11:27:18 <copumpkin> > partition even [1..10]
11:27:19 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
11:27:30 <javagamer> http://pastebin.com/by4RU5tv
11:27:49 <copumpkin> you think span is partition
11:27:51 <copumpkin> use partition
11:27:54 <dafis> javagamer: your list starts with an even number
11:28:05 <copumpkin> your list is just such that span does what you'd expect partition to do, for odd
11:28:20 <dafis> not exactly
11:28:20 <javagamer> copton, alright, trying partition
11:28:28 <dafis> 10 is in the second part
11:29:53 <javagamer> Do I need to import something to get partition?  ghci can't seem to find it
11:30:06 <dafis> javagamer: import Data.List
11:30:58 <javagamer> dafis, thanks
11:32:26 <javagamer> It works now, thanks everyone
11:40:01 <byorgey> preflex: seen edwardk
11:40:01 <preflex>  edwardk was last seen on #haskell 12 hours, 5 minutes and 37 seconds ago, saying: ddarius: in practice i find that i wind up having to start somewhere in the middle as well, i want to be able to reason about the resulting monstrosity after all ;)
11:43:48 <byorgey> @tell edwardk Data.Distributive.fmapDefault is a lie: http://hpaste.org/43921/datadistributefmapdefault_is  Every Distributive is a Functor only because you have declared it to be so.
11:43:49 <lambdabot> Consider it noted.
11:53:16 <copumpkin> byorgey: damn! :P
11:53:43 <byorgey> copumpkin: what's wrong?
11:54:21 <byorgey> copumpkin: it doesn't seem like that big of a deal to me.
11:54:48 <byorgey> I'm in the process of typing up a bunch of notes based on my conversation with edwardk the other night
11:54:58 <copumpkin> ah
11:55:17 <byorgey> the claim that every Distributive is a Functor surprised me, so I tried to implement it myself without peeking.
11:55:27 <byorgey> after tenminutes of scratching my head I gave up and peeked.
11:56:13 <copumpkin> how is fmapDefault defined?
11:56:44 <dafis> indirectly, via fmap :)
11:57:15 <byorgey> dafis: indeed =)
11:57:16 <Saizan> copumpkin: https://github.com/Saizan/vector-static/commit/67b647bcd095ce60ca2581ecadd783aea4cf1508 <- done!
11:57:19 <byorgey> fmapDefault f = cotraverse (f . runIdentity) . Identity
11:57:35 <byorgey> cotraverse f = fmap f . distribute
11:57:38 <Saizan> copumpkin: do you still have around some example code using vector-static?
11:58:01 <copumpkin> Saizan: hmm, not on this computer :/ I wasn't really doing anything interesting with it anyway
11:58:06 * hackagebot barley 0.3.0.1 - A web based environment for learning and tinkering with Haskell  http://hackage.haskell.org/package/barley-0.3.0.1 (JohanTibell)
11:58:53 <copumpkin> Saizan: +type family (:+:) (a :: Nat) (b :: Nat) :: Nat ?
11:58:57 <copumpkin> Saizan: why not just use the +?
11:59:30 <Saizan> copumpkin: less to change in the other modules :)
11:59:38 <copumpkin> fair enough :)
12:00:07 <SonOfLilit> @pl \x -> x 1
12:00:07 <lambdabot> ($ 1)
12:00:12 <SonOfLilit> @pl \x -> x 1 1
12:00:12 <lambdabot> flip ($ 1) 1
12:00:18 <SonOfLilit> @pl \x -> x 1 1 1
12:00:18 <lambdabot> flip (flip ($ 1) 1) 1
12:00:35 <dafis> SonOfLilit: see a pattern?
12:00:41 <SonOfLilit> not very readable
12:00:45 <Saizan> copumpkin: later i might feel like using sed to inline it :)
12:01:01 <copumpkin> Saizan: you could make it a type synonym :P
12:01:17 <SonOfLilit> I was hoping there'd be something better than the (\x -> x qn 1 ()) prevalent through the haskore guide
12:01:29 <Saizan> copumpkin: oh, true! 
12:03:25 <dafis> SonOfLilit: if there's always three args, evalAt a b c f = f a b c
12:05:45 <SonOfLilit> @type evalAt
12:05:46 <lambdabot> Not in scope: `evalAt'
12:05:53 <SonOfLilit> ah
12:06:03 <blbrown_win3> I know this is semantics, but is there a difference between declarative programming and functional programming
12:06:09 <SonOfLilit> but right now it is always exactly the same expression
12:06:16 <SonOfLilit> so I can just define it
12:06:19 <SonOfLilit> thanks :)
12:06:27 <systemfault> functional programming is a form of declarative programming afaik
12:06:37 <dafis> :t (flip .) . flip . (flip id)
12:06:38 <lambdabot> forall a b a1 a2. a2 -> a1 -> a -> (a2 -> a1 -> a -> b) -> b
12:06:49 <pozic> systemfault: it is not.
12:07:26 <systemfault> pozic: So.. prolog for example is not declarative programming?
12:07:37 <pozic> systemfault: I would say no. 
12:07:57 <systemfault> Ok :)
12:08:02 <pozic> Declarative programming is like when you specify a set of constraints and some machine would solve it. 
12:08:07 <Cale> I'm not sure that "declarative programming" is a thing as such
12:08:17 <pozic> E.g in an ILP.
12:08:17 <companion_cube> prolog seems quite declarative
12:08:23 <Cale> A lot of functional programming is declarative in nature.
12:08:54 <Cale> As is a lot of logic programming.
12:09:51 <blbrown_win3> And it is clear that C is not declarative
12:10:00 <Cale> But neither is quite inherently declarative -- you can still specify a mechanism by which something should be computed, and not just what should be computed.
12:10:16 <rajeshsr_> str.getSubstring(5, 8) is also declarative! ;)
12:10:45 <Cale> It's quite hard to make C code with a declarative feel to it, but I wouldn't rule it out.
12:10:50 <pozic> It is declarative when you just specify e.g. the Z contract. 
12:10:56 <rajeshsr_> it is all in what layer of abstraction we view things?
12:11:07 <Cale> Yeah
12:11:15 <pozic> If you have to say anything about optimization, then it stops being declarative.
12:11:15 <rajeshsr_> Cale: yeah, totally agree!
12:11:22 <Saizan> EDSLs tend to drive code to the declarative side
12:11:28 <blbrown_win3> I guess it is better to pinpoint a block of code in a particular language and define it as declarative, functional, or not.
12:11:41 <blbrown_win3> as opposed to a sweeping generalization
12:12:02 <deech> Does any here use emacs and flymake to continously compile Haskell?
12:12:13 <rajeshsr_> probably you can say that some language is declarative(something subjective), when you get a feel of decalarativeness with minimal efforts(another subjective stuff)!
12:12:39 <pozic> rajeshsr_: I would say that is a property of humans, but has nothing to do with declarativeness. 
12:13:12 <rajeshsr_> yes, i meant "feel of declarativeness" which is anyway a subjective view.
12:13:38 <systemfault> I could say that C has a feel of OOP...
12:13:42 <systemfault> :#
12:13:59 <dafis> not my C
12:14:17 <companion_cube> you can do OOP in C, as in the linux kernel
12:14:40 <systemfault> It doesn't make C an OOP language though.
12:14:56 <systemfault> Having a fold function in a language doesn't make it functional.
12:15:13 <Saizan> no, you need (.)
12:15:41 <companion_cube> "functional" is quite a fuzzy notion :)
12:15:43 <Eduard_Munteanu> I bet I can write (.) in C :P
12:15:59 <rajeshsr_> Interesting, so what features characterizes a functional language?
12:16:09 <gigabytes> Eduard_Munteanu: printf("(.)"); LOL
12:16:12 <dafis> Eduard_Munteanu: but can you make it type safe?
12:16:16 <Eduard_Munteanu> :)
12:16:26 <Eduard_Munteanu> Ah, type safe maybe not.
12:16:28 <copumpkin> rajeshsr_: there are no formal definitions of terms like that
12:16:37 <jix_> dafis: since when do functional languages have to be type safe?
12:16:39 <systemfault> C++ is fairly typesafe :P
12:16:42 <pozic> rajeshsr_: basically if you do not actually use references would be a practical answer.
12:16:55 <dafis> jix_: the good ones are (more or less)
12:16:58 <pozic> rajeshsr_: the moment you add the IO monad, discussions become fishy.
12:17:02 <companion_cube> rajeshsr_, good question
12:17:09 <pozic> rajeshsr_: to the point you are programming in the C monad in C.
12:17:14 <jix_> dafis: but it isn't someting i'd include when defining what features make a language functional
12:17:25 <rajeshsr_> pozic: ha :)
12:17:29 <dafis> jix_: nor I
12:17:44 <systemfault> So, a real functional programming language can't exists because it wouldn't be able to communicate with the outside world? :P
12:17:53 <companion_cube> imho, "functional" is a mix of closures, anonymous functions, immutable data structures, higher order functions...
12:18:19 <augustss_> Eduard_Munteanu: I bet you can't write (.), not so you can use it an arbitrary number of times.  (Unless you use runtime code generation.)
12:18:24 <Eduard_Munteanu> void *dot(void *(*f)(void *), void *(*g)(void *), x) { return f(g(x)); }   // :)
12:18:43 <pozic> rajeshsr_: I am not joking :)
12:18:44 <Eduard_Munteanu> erm s/, x/void *x/
12:19:06 <geheimdienst> Eduard_Munteanu: no need for the correction, everyone saw that rightaway
12:19:36 <augustss_> Eduard_Munteanu: that's not (.).  The (.) function takes two arguments.  I need to be able to write 'h = dot(f, g);'
12:20:00 <Eduard_Munteanu> Yeah, you can't actually construct and return functions on the fly.
12:21:23 <Eduard_Munteanu> I suppose you can't actually do pointfree in C.
12:21:36 <copumpkin> nested functions sort of allow that, but not for this
12:21:47 <companion_cube> you cannot overload () in C, so having closures is hard
12:22:04 <sproingie> no nested functions in C tho
12:22:19 <Eduard_Munteanu> Yeah, it's a GCC extension.
12:22:47 <gigabytes> what about C++0x lambdas?
12:22:54 <companion_cube> that's not quite C :D
12:22:59 <gigabytes> of course
12:23:06 <rajeshsr_> gigabytes: with C++, you don't even need lambdas
12:23:11 * hackagebot barley 0.3.0.2 - A web based environment for learning and tinkering with Haskell  http://hackage.haskell.org/package/barley-0.3.0.2 (JohanTibell)
12:23:13 <sproingie> C++0x added lambdas?
12:23:22 <systemfault> sproingie: Welcome to 2009
12:23:25 <gigabytes> sproingie: yes
12:23:32 <rajeshsr_> you can do with class on which () is overloaded
12:23:48 <Eduard_Munteanu> Their version of typeclasses almost went in too.
12:23:58 <systemfault> Yeah.. but was killed :'(
12:24:03 <Eduard_Munteanu> Erm, not generics, what was it...
12:24:05 <systemfault> concepts were a good idea.
12:24:08 <Eduard_Munteanu> That.
12:24:21 <pozic> systemfault: do you know why they cancelled them?
12:24:30 <gigabytes> concepts were too complex for a little gain
12:24:39 <systemfault> Like gigabytes said..
12:24:41 <augustss_> bjarne thought they were to complex
12:24:43 <rwbarton> This is C++ we're talking about?
12:24:54 <Eduard_Munteanu> I remember when gcc/g++ folks switched from C to C++, they asked people to be conservative, e.g. don't use templates etc.
12:24:54 <rwbarton> :)
12:25:07 <monochrom> heh, I thought concepts were already very simple and easy to use.
12:25:12 <Eduard_Munteanu> C++ is a hella complex language.
12:25:29 <pozic> There was a paper showing the equivalence between Haskell and C++ which used concepts. 
12:25:29 <systemfault> Yes.. someone telling he knows C++ completely is a liar.
12:25:41 <companion_cube> apart from stroustrup, perhaps ?
12:25:41 <Eduard_Munteanu> That tends to be the case when you're not starting from some sort of lambda calculus.
12:25:49 <sproingie> i'm not even sure about stroustrup
12:25:51 <Eduard_Munteanu> Everything is syntax sugar.
12:26:00 <systemfault> companion_cube: Stroustrup is a pretty average C++ programmer..
12:26:00 <Eduard_Munteanu> (actually not sugar)
12:26:01 <companion_cube> Eduard_Munteanu, i find perl quite simple...
12:26:03 <companion_cube> oh, wait
12:26:17 <SonOfLilit> @pl \x a b c -> f $ g a b c
12:26:17 <lambdabot> const (((f .) .) . g)
12:26:18 <systemfault> companion_cube: The language evolved in a way he never thought it would..
12:26:18 <pozic> Since some libraries already were using it in the documentation it seemed to be a good idea. 
12:26:22 <Eduard_Munteanu> Features is a better word.
12:26:22 <companion_cube> systemfault, but i assume he knows the language very well
12:26:31 <companion_cube> oh, ok
12:26:35 <SonOfLilit> @pl \a b c -> f $ g a b c
12:26:35 <lambdabot> ((f .) .) . g
12:26:58 <aristid> companion_cube: i guess stroustroup knows c++, but he's not the one to put its features to use
12:27:04 <systemfault> companion_cube: People started to abuse C++'s typesystem with template metaprogramming... Stroustrup never thought people would do that.
12:27:05 <SonOfLilit> mm, I don't think I'd ever remember what I meant if I write this :P
12:27:10 <companion_cube> :)
12:27:31 <Eduard_Munteanu> SonOfLilit: heh, don't.
12:27:33 <companion_cube> but sometimes i wish e.g. java had templates instead of crapy generics
12:27:55 <gigabytes> D is the future :P
12:28:01 <systemfault> companion_cube: I wish java had real generics.
12:28:13 <SonOfLilit> I'd really expected this to be easily done in a readable way with point-free
12:28:32 <systemfault> companion_cube: Because in the current implementation, once compiled... they don't exists anymore because of "type erasure"
12:28:40 <sproingie> haskell uses erasure too
12:28:45 <sproingie> you just can't use unerased types
12:28:50 <sproingie> er erased types
12:28:58 <companion_cube> i know, systemfault 
12:29:12 <systemfault> sproingie: Perhaps you don't use as much reflection in haskell though ;)
12:29:13 <companion_cube> that's why i think they're crapy
12:29:16 <Eduard_Munteanu> Meh, runtime types.
12:29:27 <companion_cube> and also, they do not work for unboxed types
12:29:32 <sproingie> systemfault: no not so much
12:29:40 <Eduard_Munteanu> RTTI, IIRC.
12:30:11 <systemfault> RTTI in C++ isn't used much...
12:30:32 <systemfault> It's needed for typeid and dynamic_cast...
12:31:38 <sproingie> java's implementation of erasure is perhaps the ultimate in so-called "leaky abstractions"
12:31:55 <sproingie> oh well there's always scala
12:34:10 <companion_cube> at least, scala does not have covariant mutable types
12:38:14 <sproingie> java arrays are, generics aren't
12:38:45 <pedro3005> how do I get log_10 of something in haskell?
12:38:58 <dafis> pedro3005: logBase 10 x
12:39:12 <pedro3005> thanks
12:48:25 <tomh> Hmm, if you have a cabal file and want to have happy/alex run with certain parameters, how would you do that?
12:53:34 <Saizan> tomh: alex-options: and happy-options: in the .cabal file might work
12:53:50 <tomh> thanks, is there any documentation about that?
12:54:05 <Saizan> there should be in Cabal's user manual
12:56:34 <tomh> mm
12:58:40 <Saizan> i might just be wrong on their existence, sorry
12:59:04 <dino-> Building shell apps for Windows.. do I need to strip these? Surely that's not done with strip(1) ?
12:59:43 <tomh> Saizan: it seems possible as argument to cabal 
12:59:52 <Saizan> tomh: yeah
13:00:04 <tomh> not sure if its possible in the cabal file though
13:00:25 <tomh> I can't say the documentation is really helpful in that aspect :/
13:00:42 <tomh> but lets try!
13:02:02 <Saizan> tomh: in the end you could change the options by using a custom Setup.hs and altering the list of preprocessors
13:02:27 <Saizan> though it feels like there should be a better way
13:02:34 <tomh> yeah, but you probably need to mess with paths to alex and happy
13:02:50 <tomh> I'm just going to try the alex-options and happy-options
13:03:39 <Saizan> no, those would still be handled by Cabal
13:04:09 <dino-> heh, I ask a Windows Q -> <sound of crickets>  :D
13:04:31 <dafis> dino-: nobody knows windows
13:04:49 <mreh> do I need to striptease?
13:05:02 * dafis is impartial
13:07:36 <periodic> strip $ mreh
13:07:42 <Veinor> oh baby
13:07:57 <dino-> aaah, maybe -optl-s
13:08:04 <dino-> ghc arg
13:10:01 <dino-> Oh yeah that did it. Went from 8M to 3M
13:12:46 <nosila> hey
13:12:57 <nosila> i have a function that uses a data that i created
13:15:27 <Bynbo7> nosila: congratulations
13:15:35 <dino-> nosila: Go on.
13:19:01 <periodic> hjhg
13:19:24 <Feuerbach> What are the reasons why we need dictionaries to implement type classes? Is it just for separate compilation?
13:19:37 <Zao> periodic: Am I broken for trying to interpret that as a vi typo?
13:21:04 <mauke> Feuerbach: what about runtime constructed dictionaries?
13:21:53 <Feuerbach> mauke: for example? I don't see what you mean
13:21:58 <romildo> Which os should be tested for Windows on a cabal file?
13:22:04 <periodic> Zao: that was actually the wireless cutting out.  It wasn't locally echoing.
13:22:19 <periodic> And I'm running irssi in a screen on a remote system.
13:23:13 <mauke> > let foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in foo 2 'x'  -- does this count?
13:23:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
13:23:16 <periodic> And here at Bay Hac there are too many people on the wireless!
13:23:31 <mauke> > let foo :: (Show a) => Int -> a -> String; foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in foo 2 'x'  -- does this count?
13:23:32 <lambdabot>   "(('x','x'),('x','x'))"
13:24:17 <romildo> I am getting a linking error with my application on Windows. I am using the iconv package. I am getting the error: Linking Gui.exe ...
13:24:18 <romildo> C:\Program Files\Haskell\iconv-0.4.1.0\ghc-7.0.1/libHSiconv-0.4.1.0.a(hsiconv.o):hsiconv.c:(.text+0x8): undefined reference to `libiconv_open'
13:24:57 <Feuerbach> mauke: nice
13:25:21 <romildo> In the iconv.cabal file there is the following:
13:25:25 <romildo>   if os(darwin) || os(freebsd)
13:25:25 <romildo>     -- on many systems the iconv api is part of the standard C library
13:25:26 <romildo>     -- but on some others we have to link to an external libiconv:
13:25:26 <romildo>     extra-libraries: iconv
13:25:57 <romildo> Maybe I should add a check for windows. Which OS should I use for it?
13:26:17 <dafis> romildo: if os(windows)
13:26:20 <dafis> iirc
13:26:31 <nosila> hey
13:26:45 <dafis> nosila: hey, got disconnected?
13:30:41 <romildo> dafis, as I thought, adding ' || os(windows)' to the cabal file solved the problem. Thanks.
13:30:53 <dafis> de rien
13:31:03 <romildo> Maybe I should contact the mantainer and tell him that.
13:31:13 <dafis> romildo: good idea
13:47:30 <dixie> hmm, does the "radio playing static" means that noise when nothing is tunned ?
13:47:57 <geheimdienst> dixie: yes
13:48:04 <dixie> thanks
13:48:35 <dixie> i have been looking on this http://nahraj.to/1jP 
13:49:19 <ArchGT> http://learnyouahaskell.com/chapters looks nice anyone recommends it?
13:49:31 <companion_cube> lyah is great
13:49:37 <dafis> ArchGT: LYAH is pretty cool
13:49:40 <systemfault> lyah is the best.
13:49:43 <companion_cube> :D
13:49:45 <ArchGT> xDD
13:49:50 <ArchGT> great, thanks
13:50:06 <geheimdienst> lyah is 86% better than the best
13:50:13 <dafis> ArchGT: After getting started with LYAH, consider RWH
13:50:17 <dafis> @where RWH
13:50:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:50:25 <ArchGT> o.0
13:50:37 <dafis> gets a little more in-depth
13:51:23 <ArchGT> companion_cube, dafis, systemfault: thanks, will read
13:51:32 <dafis> have fun
13:51:54 <systemfault> He will! **evil laugh**
13:51:54 <monochrom> everyone here recommends learnyouahaskell.
13:52:26 * copumpkin recommends #haskell
13:52:27 <dafis> monochrom: that's because you get kicked if you don't?
13:52:42 <monochrom> that's because we are all cool people!
13:52:45 <dixie> :)
13:53:08 * shachaf recommends Hutton's _Programming in Haskell_.
13:53:10 * djahandarie recommends copumpkin
13:53:12 <shachaf> But admittedly it's not free.
13:53:21 * copumpkin blushes
13:53:23 * systemfault recommends caffeine
13:53:33 * geheimdienst recommends recommendations
13:53:59 <geheimdienst> Copumpkin™. Recommended By Leading Djahandaries™.
13:54:04 * dixie is writing down all recommendations
13:54:44 <copumpkin> djahandarie is certainly the world's best djahandarie 
13:54:56 * monochrom writes down "∀x,y x recommends y" succintly. a formula is worth a thousand pictures
13:55:11 <shachaf> monochrom: I don't recommend doing that.
13:55:19 <monochrom> haha
13:55:23 <geheimdienst> copumpkin: yeah, but recently djahandarie_ has caught up, imho
13:55:33 <copumpkin> seems like you'd want forall x, exists y. x recommends y
13:55:38 * companion_cube recommends not recommanding anything
13:55:42 * shachaf >>= fix undefined.
13:55:44 <z1pher> What does the pipe sign "|" mean in Haskell? Thank you.
13:55:46 <copumpkin> not necessarily forall x. exists y. y recommends x
13:55:51 <monochrom> no, just constrain x,y to be people in #haskell.
13:56:00 * djahandarie is confused
13:56:04 <shachaf> z1pher: What is the context? Thank you.
13:56:13 <byorgey> copumpkin: I would believe the latter much more readily than the former.
13:56:15 <geheimdienst> monochrom: everybody in a cross-recommending orgy?
13:56:36 <copumpkin> byorgey: really?
13:56:49 <z1pher> shachaf> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
13:56:51 * copumpkin wouldn't
13:56:54 <byorgey> copumpkin: sure. you can always find some schmuck who thinks anything is a good idea.
13:57:00 <shachaf> z1pher: Look up "list comprehension".
13:57:04 <shachaf> @wiki List comprehension
13:57:04 <lambdabot> http://www.haskell.org/haskellwiki/List_comprehension
13:57:09 <z1pher> Thanks!
13:57:18 <byorgey> copumpkin: but there are curmudgeonly nihilist grumps who don't recommend anything.
13:57:33 <copumpkin> oh fair enough
13:57:39 <copumpkin> the more cynical interpretation of reality :)
13:57:39 <tomh> when I run a runhaskell Setup.hs build -v and it doesn't give any output, what could be wrong?
13:57:48 <byorgey> hehe =)
13:58:15 <dafis> tomh: forgot to configure?
13:58:23 <tomh> no I did configure
13:58:33 <dafis> tomh: then try -v3
13:58:35 <monochrom> it outputs something even in the worst case
13:59:00 <monochrom> unless someone replaced your Setup.hs silently with main=return()
13:59:01 <tomh> no it doesn't output anyhting :(
13:59:21 <monochrom> I'll stick to my "you're compromised" theory then!
14:00:04 <tomh> i use defaultMainWithHooks
14:00:16 <monochrom> runhaskell is compromised
14:00:51 <dafis> tomh: try cabal build?
14:01:04 <tomh> that works, but it doesn't use my setup.hs then right?
14:01:39 <dafis> tomh: if you have build-type: custom, it does
14:01:48 <tomh> lemme try that
14:04:34 <tomh> it doesn't seem to do that :/
14:04:38 <tomh> or the hook is broken
14:05:22 <tomh> yeah the hook removes all verbosity :(
14:05:50 <roconnor> how would I prove, using program tranformation reasoning, that (forall x. map ($ x) l1 = map ($ x) l2) iff l1 = l2?
14:07:44 <monochrom> sounds like appeal to the "take lemma": xs=ys if ∀n:nat. take n xs = take n ys
14:07:56 <roconnor> monochrom:
14:08:11 <roconnor> actually I want to prove that (forall x. fmap ($ x) l1 = fmap ($ x) l2) iff l1 = l2?
14:08:12 <monochrom> in particular take n (map ($ x) l1) = take n (map ($ x) l2)
14:09:38 <monochrom> oh ha I'm dumb.
14:09:52 <roconnor> no, your answer is fair
14:10:04 <roconnor> I thought I'd start with an easier question, but it was too easy
14:11:42 <ezyang>  roconnor: That doesn't seem necessarily true. 
14:11:47 <roconnor> it might not be
14:11:56 <roconnor> oh
14:12:02 <roconnor> I can take the constant functor
14:12:13 <monochrom> yeah that breaks it.
14:12:15 <ezyang> You need some sort of constant functor with two values. 
14:12:16 <roconnor> to falsify it
14:12:22 <ezyang> Because otherwise l1 = l2 vacuously :-) 
14:12:37 <roconnor> so F = (Const Bool)
14:12:46 <roconnor> no wait
14:12:55 <roconnor> that doesn't seem to work
14:13:01 <roconnor> hmm
14:13:09 <ezyang> Why not? 
14:13:12 <xplat_> 05:13 < ksf> should iteratees be able to inject data into the chunkstream?
14:13:15 <monochrom> but something can be done to strengthen e.g. "the functor comes from an initial algebra etc"
14:13:16 <roconnor> ezyang: what is the counter example?
14:13:21 <xplat_> ksf: how would that actually work anyway?
14:13:33 <xplat_> 14:20 < Eduard_Munteanu> 'return' is misleading at times though.
14:13:54 <Eduard_Munteanu> Yes...?
14:13:55 <ezyang> Oh, I see. 
14:14:19 <xplat_> omg 'return' is such a terrible name, i actually hate it.  'pure' or 'inject' or anything but 'return'... even in IO it is misleading
14:14:27 <roconnor> xplat_: you can use pure
14:14:28 <ezyang> Ok, try this 
14:14:29 <roconnor> if you wish
14:14:36 <ezyang> data F = A | B 
14:14:42 <roconnor> > pure 3
14:14:43 <ezyang> fmap _ A = B fmap _ B = B 
14:14:43 <lambdabot>   No instance for (GHC.Show.Show (f t))
14:14:43 <lambdabot>    arising from a use of `M9037572448...
14:14:44 <hpc> pure only works for monads that are also applicative
14:14:48 <roconnor> > pure 3 :: [Int]
14:14:49 <lambdabot>   [3]
14:14:52 <hpc> (god, saying that hurts)
14:14:55 <ezyang> I /think/ this satisfies the functor laws. 
14:15:04 <Eduard_Munteanu> xplat_: in many cases 'return' acts really as a return, but in many others it doesn't.
14:15:19 <roconnor> hpc: you can use (unWrapMonad . pure . WrapMonad)
14:15:22 <Bynbo7> ezyang: except that the type has the wrong kind
14:15:23 <roconnor> hpc: I'll use pure
14:15:28 <ezyang> hpc: More precisely, it only works for monads that also have an Applicative instance defined. Since all monads are automatically applicatives 
14:15:36 <ezyang> oh, sure. data F a = A  B 
14:15:42 <ezyang> *A | B 
14:15:44 <dafis> ezyang: fmap id /= id
14:15:46 <roconnor> ezyang: fmap id A /= A
14:15:53 <hpc> ezyang: there's Set though
14:15:54 <ezyang> yeah, troublesome. 
14:16:06 <hpc> which has an Ord constraint to wreck the mathy gears
14:16:23 <Eduard_Munteanu> Well is there a free applicative for a monad?
14:16:45 <hpc> Eduard_Munteanu: indeed there is, assuming this is CT
14:16:57 <Eduard_Munteanu> No, I mean in Haskell.
14:16:59 <hpc> Set does dumb things
14:17:01 <hpc> ah
14:17:03 <copumpkin> WrappedMonad
14:17:17 <copumpkin> feels odd to call it free though
14:17:29 <ezyang> The need for equality seems a bit non-kosher. 
14:18:03 <hpc> ezyang: for a Set? it's the most integral part of it
14:18:16 <hpc> otherwise it would be a list, or a heap, or something
14:18:31 <ezyang> Erm, I'm musing on roconnor's 
14:18:35 <hpc> ah
14:19:18 <roconnor> prove that (forall x. fmap ($ x) l1 = fmap ($ x) l2) iff l1 = l2?
14:23:28 <ezyang> It is true. 
14:23:36 <ezyang> I can't prove it equationally, but I can prove it with a contradiction. 
14:23:52 <ezyang> Suppose that the statement was not true. We derive contradictions in both directions. 
14:24:11 <ezyang> Suppose l1 = l2 -> exists f. fmap f l1 != fmap f l2 
14:24:40 <ezyang> but fmap f l2 = fmap f l1 (rewrite), contradiction. 
14:24:52 <ezyang> In the other direction, suppose l1 != l2 -> forall f. fmap f l1 = fmap f l2. 
14:25:25 <ezyang> Select f = id 
14:25:53 <ezyang> Then fmap id l1 = fmap id l2, but by the functor laws fmap id l1 = l1 and fmap id l2 = l2, which contradicts the premise. 
14:25:55 <ezyang> Qed. 
14:26:09 <dafis> ezyang: roconnor was more restrictive, he allowed only ($ x)
14:26:11 <roconnor> ezyang: you seem to be proving something else
14:26:14 <ezyang> We then specialize this result by setting f = ($ x) to solve the original example. 
14:26:41 <roconnor> ezyang: that last step isn't kosher
14:26:43 <ezyang> Maybe that last step is bogus. Let me think about it... 
14:27:15 <Saizan> there isn't an x such that ($ x) is id, in particular
14:28:51 <ezyang> Oh, I see, we're proving things about Functor f => f (a -> b) 
14:28:53 <tomh> mm anyone knows where cabal installs packages on the mac by default?
14:29:26 <Luke> probably ~/.cabal if I had to guess
14:29:27 <stepkut> tomh: ghc-pkg list will show you everyplace that packages are installed
14:30:07 <ezyang> If we consider a system that permits infinite types, a -> a -> a -> a ... would admit ($ x) as identity. 
14:30:12 <stepkut> tomh: assuming you are on the mac in question..
14:30:22 <tomh> mm lemme check it out
14:31:58 <ezyang> e.g. f _ = f 
14:32:19 <ezyang> If we restrict ourselves to Hask, things are dicier, I suppose. 
14:32:33 <hpc> ezyang: that's "unfix" i suppose...
14:34:02 <kulakowski> tomh: It's ~/.cabal for me
14:34:11 <tomh> thanks
14:34:14 <tomh> found it too
14:35:41 <Saizan> ezyang: i don't think it's possible even in untyped lambda calculus, ap = (\f x -> f x), find me a single x such that for every f you've ap f x = f
14:36:34 <ezyang> Here's an illustrative alternate example: consider data Lat = L | R | T; Functor f => f Lat. We'd like to state (fmap up l1 = fmap up l2) <=> (l1 = l2). But if up L = T, up R = T, up T = T, this clearly is false. 
14:36:35 <rwbarton> certainly not, take f = KI
14:36:51 <ezyang> So it seems to be more a question about the nature of the type inside the functor, than the functor itself. 
14:37:09 <ezyang> Namely, (forall x. f x = g x) <=> f = g 
14:37:41 <roconnor> I'm presuming extensionality as you state above
14:37:42 <ezyang> Saizan: I'll have a try. 
14:38:01 <javagamer> Is there an easy way to make isPrime in this code return false as soon as the length of the list exceeds 2? http://pastebin.com/wALjJ7gX
14:38:13 <ezyang> rwbarton: Who are you referring to? 
14:38:58 <tomh> mm seems defaultMainWithHooks surpresses verbose output
14:38:59 <luite> javagamer: null.drop 2
14:39:03 <tomh> anyone knows what to do against it?
14:39:06 <mauke> javagamer: isPrime x = case factor x of [_, _] -> True; _ -> False
14:39:09 <dafis> javagamer: without looking: not (null $ drop 2 factors)
14:39:27 <dafis> or pattern matching :)
14:39:32 <ezyang> Why wouldn't fix (\f -> (\_ -> f)) work? 
14:39:48 <ezyang> > fix (\f -> (\_ -> f)) 
14:39:49 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
14:40:17 <ezyang> Heh, never thought I'd be glad to see that error message :-) 
14:40:27 <javagamer> Thanks everyone
14:40:32 <ezyang> roconnor: Ok, Imma gonna try and prove a more general result. 
14:40:36 <Saizan> why would it work, is the question :)
14:40:57 <Saizan> f (fix (\f -> (\_ -> f))) -- there's no useful reduction you can apply here
14:41:48 <Saizan> it only gets to f ((\f -> (\_ -> f)) (fix ..)) = f (\_ -> fix (..))
14:42:10 <ezyang> wait, f has escaped. I'm confused. 
14:42:20 <Sa[i]nT> What is the extension of a haskell source file?
14:42:22 <ezyang> fix (\f -> (\_ -> f)) x 
14:42:33 <rwbarton> for any x, KIx = I != KI
14:42:33 <Saizan> ?
14:42:40 <dafis> Sa[i]nT: .hs
14:42:42 <Saizan> ezyang: you're supposed to find x, not f.
14:43:01 <dafis> Sa[i]nT: or .lhs for literate Haskell
14:43:09 <Saizan> ezyang: exists x. forall f. f x = f is what you'd need
14:43:51 <ezyang> Yeah, that's weaker. I was hoping to find f such that forall x. f x = f. :-) 
14:44:26 <Saizan> that's unrelated, rather than stronger
14:44:57 <djahandarie> conal, you're at the hackathon? :o
14:45:07 <ezyang> Mmm, sure. 
14:45:59 <ezyang> Btw, if you grant me the reduction rule fix f = f (fix f), then fix (\f _ -> f)) = \_ -> fix (\f _ -> f) which seems to work fine... 
14:46:22 <ezyang> (which, from the existence of fixpoint combinators, seems like an ok assumption to make.) 
14:46:33 <conal> djahandarie: yep.
14:46:44 <conal> dons is starting to talk now.
14:46:56 <djahandarie> I wish I lived in the area :( Seems like everyone is there
14:47:02 <Kaidelong> @ty fix const
14:47:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
14:47:03 <lambdabot>     Probable cause: `const' is applied to too few arguments
14:47:04 <lambdabot>     In the first argument of `fix', namely `const'
14:47:11 <Kaidelong> that's what I thought
14:49:13 <ezyang> suppose x = forall a. a 
14:49:21 <BMeph> ezyang: I'm missing something there. What's a supposed to be? (where f's type is a -> a)
14:49:41 <ezyang> this makes it impossible for our function to inspect the value, so we might be able to use polymorphism to get what we want. 
14:50:14 <ezyang> BMeph: Well, we can't express fix const in Haskell, if that's what you mean? 
14:50:14 <xplat_> ezyang: that means f is id, which means f x = x
14:50:44 <Saizan> xplat_: also const something
14:50:58 <ezyang> Right. So if we add in the universal quantification over the types involved in the expression, I think the /only/ function we're allowed to use is id. 
14:51:07 <ezyang> So we can prove the original statement that way. 
14:51:34 <Saizan> ezyang: anyhow, see rwbarton counterexample above, KIx = I forall x. which means there's not x such that KIx = KI, hence exists x. forall f. f x = x is disproven
14:51:37 * ezyang feels better. Until another mistake in the proof is pointed out again. 
14:51:52 <BMeph> ezyang: Actually, I was looking at your 'f' function. If (\f _ -> f) is supposed to be of some 'a -> a' type, then what's a? Or are you trying to be untyped?
14:52:01 <xplat_> i think since the original statement uses extensional equality on functions, the best thing to do is desugar it and prove the desugared version
14:52:04 <ezyang> I'm being untyped. 
14:52:17 <roconnor> Saizan: so what is the solution?
14:52:31 <BMeph> exyang: I smell what you're stepping in. ;)
14:52:36 <tomh> anyone here used uuagc before?
14:53:00 <Saizan> roconnor: don't know :)
14:53:16 <ezyang> Yeah, I'm a little confused at the fact that it doesn't work with SKI. 
14:54:21 <ezyang> Oh, no, you're talking about the other statement. *phew* 
14:54:39 <xplat_> hm, i guess (forall x. fmap ($ x) l1 = fmap ($ x) l2) iff l1 = l2 doesn't desugar well since the functions in l1 and l2 are not at the top level ...
14:54:45 <ezyang> So, the last proof I proposed is to show that only id inhabits the forall f. 
14:55:06 <ezyang> so if we explicitly write out the types Coq style... 
14:55:39 <ezyang> forall A B. forall l1 l2. (forall x. fmap ($x) l1 = fmap ($x) l2) <=> l1 = l2 
14:55:44 <mzero> ~60 people here at BayHac listening to a talk by dons about Haskell in Industry
14:55:46 <ezyang> erm, I failed to write out the types 
14:55:48 <mzero> !
14:56:41 <ezyang> l1 : (A -> B), l2 : (A ->B). 
14:57:05 <ezyang> Actually, it's even worse, if I order the quantifiers that way: l1 and l2 are empty :-) 
14:57:13 <xplat_> i think we're missing a definition of l1 = l2
14:57:22 <ezyang> We were assuming extensional equality 
14:57:34 <ezyang> (forall x. f x = g x) <=> f = g 
14:57:50 <xplat_> i thought we were doing l1, l2: F (A -> B) for any F
14:58:35 <ezyang> Oh, yes. 
14:58:56 <xplat_> so then we need a definition of = for functors in terms of = for the elements
14:59:12 <ezyang> Good catch. 
14:59:29 <rwbarton> if I can take F = "the Set functor" then the statement is false
15:00:03 <rwbarton> e.g. l1 = {id}, l2 = {id, not} :: Set (Bool -> Bool)
15:00:07 <waterlaz> I'm making haskell bindings to one C library
15:00:26 <rwbarton> wait
15:00:35 <rwbarton> that's not what I want, but take l1 = {const True, const False}
15:00:40 <ezyang> I think x = y -> F x = F y is a safe place to start. 
15:00:41 <waterlaz> and it is nice to use foreign pointer at one point
15:00:57 <waterlaz> but is there a way to detach a finalizer from a foreign pointer?
15:01:33 <roconnor> rwbarton: interesting
15:01:34 <ezyang> waterlaz: Not easily. 
15:01:44 <waterlaz> that's bad
15:02:04 <rwbarton> so I think this is going to require some further specification of what you mean by "functor" and "="
15:02:24 <waterlaz> that damn library sometimes deallocates its resources
15:02:27 <waterlaz> and sometimes not
15:02:33 <ezyang> The way I'd deal is: a) don't do that, b) make the foreign pointer to a pointer to a pointer to the struct at hand. Null the first indirection if you'd like to fizzle the finalizer. 
15:02:55 <gienah> waterlaz: maybe make the finalizer some C code you write to figure out what to do
15:02:58 <rwbarton> (or maybe there is a better counterexample)
15:03:02 <Saizan> rwbarton: Set is a functor only over the category of order-preserving functions
15:03:17 <ezyang> Yeah, library-side deallocation is a pain. You can more reasonably manage (A) if you don't use foreign pointers when some memory might be nulled. 
15:03:22 <ezyang> *deallocated 
15:03:34 <rwbarton> I'm talking about the mathematical (covariant) power-set functor, not any haskell thing
15:03:35 <ezyang> This is good practice anyway, because you don't want pointers floating around in the Haskell heap to invalid memory locations. 
15:03:49 <rwbarton> but it demonstrates that there won't be a straightforward equational proof
15:04:00 <roconnor> Saizan: what f and g violate fmap (f . g) = fmap f . fmap g for set?
15:04:10 <waterlaz> ok, thanks
15:04:22 <ezyang> I ended up doing (A), because if you're publishing a Haskelly interface you're going to need to do copying anyway. 
15:04:50 <waterlaz> well that was my crappy idea of not copying
15:05:03 <roconnor> Saizan: rwbarton isn't talking about the Data.Set.  He is talking about the species set.
15:05:03 <ezyang> It's more pain than its worth. 
15:05:10 <ezyang> What kind of structures are you talking about? 
15:05:21 <waterlaz> this is a network library
15:05:24 <waterlaz> called "enet"
15:05:35 <waterlaz> and there is a packet struct
15:05:44 <waterlaz> which has a field with data
15:05:48 <ezyang> I suggest reimplementing the library completely in Haskell. 
15:05:54 <Saizan> roconnor: ah, ok then
15:06:14 <ezyang> It seems small enough, and you'll get lots of goodies from using a high-level language like Haskell, like concurrency safety and more comprehensible code. 
15:06:38 <waterlaz> sure but the whole point was to do a simple binding instead of writing lots of code
15:06:47 <waterlaz> maybe not lots bot still
15:06:48 <ezyang> Well sure, you can do that too :-) 
15:07:02 <rwbarton> roconnor: I think for polynomial functors your statement is probably true
15:07:08 <ezyang> Bindings end up writing lots of (boring) code. 
15:07:08 <roconnor> sure
15:07:17 <ezyang> If you try writing a nice binding, you'll end up writing lots of exciting code. 
15:07:27 <roconnor> rwbarton: do you think it is true for all ADTs I can write in Haskell?
15:07:29 <ezyang> Mutation is killer. Once it's in, you can't get it out again. 
15:07:29 <waterlaz> enet handles connections, garanteed packet delivery and packet ordering
15:07:44 <rwbarton> Not sure about, e.g., Cont?  That's what I would try to consider next
15:07:50 <roconnor> ya
15:07:52 <ezyang> rwbarton: What's a polynomial functor? 
15:08:00 <ezyang> As in, combinatorial species? 
15:08:27 <roconnor> @src fmap Cont
15:08:28 <lambdabot> Source not found. Just try something else.
15:08:33 <Tinned_Tuna> lol
15:08:41 <Tinned_Tuna> @src fmap
15:08:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:08:48 <rwbarton> Something you can make out of sums and products
15:09:01 <ddarius> @src Cont fmap
15:09:02 <lambdabot> fmap f m = Cont $ \c -> runCont m (c . f)
15:09:04 <ezyang> Sounds fair. 
15:09:13 <Tinned_Tuna> @src Cont
15:09:13 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
15:09:29 <roconnor> @pl \c -> m (c . f)
15:09:29 <lambdabot> m . (. f)
15:09:31 <rwbarton> I actually had something mildly more general in mind, but I'm not exactly sure what
15:09:52 <rwbarton> including [] for example
15:10:35 * roconnor tries to think of non-trival values of Cont r a
15:10:51 <rwbarton> It helps to specify r
15:10:54 <Tinned_Tuna> What ever you folk smoke, it's powerful stuff. I like that in a programmer.
15:11:10 <rwbarton> Cont { \f -> f 2 + f 3 } :: Cont Int Int
15:11:16 <ezyang> roconnor: You don't have much choice, as I see it. 
15:11:21 <rwbarton> In fact, you can probably make that into a counterexample
15:11:35 <ezyang> If r is universally quantified, as rwbarton says. 
15:15:12 <roconnor> Cont { \f -> f (const 0) + f succ } :: Cont Int (Int->Int)
15:16:53 <roconnor> fmap ($x) (Cont (\f -> f (const 0) + f succ))  =?= Cont (\f -> f 0 + f (succ x0))
15:16:54 <rwbarton> so you can take Cont { \f -> f (const False) + f (const True) } and Cont { \f -> f id + f not }
15:17:05 <roconnor> whee
15:17:06 <rwbarton> this might be the same idea as what you wrote
15:17:21 <roconnor> rwbarton:
15:17:23 <roconnor> rwbarton++
15:17:45 <roconnor> oh wat
15:17:57 <roconnor> rwbarton: are those two values extensioanlly different?
15:18:01 <rwbarton> then you need to verify that those are ... right
15:18:20 <rwbarton> But I think you can apply them to f g = if g False && g True then 1 else 0
15:19:02 <roconnor> rwbarton: you are genius
15:19:16 <roconnor> rwbarton: I didn't even serious think my claim was false
15:19:58 <rwbarton> I definitely believed it too at first
15:22:04 <beastaugh> does anyone have a copy of Hindley and Seldin's book on the lambda calculus and combinators lying around?
15:22:47 <xplat_> i think roconnor's statement is true for all functors that are 'containers' in conor mcbride's sense
15:23:11 <xplat_> or am i referring to the right person?
15:23:33 <roconnor> I was about to say: this sort of shows that functors are not always like containers
15:26:29 <rwbarton> this may well be a good definition of "containter" :P
15:26:38 <roconnor> :) maybe
15:26:49 <BobFunk> anybody here experienced with the hsmagick library?
15:27:04 <BobFunk> can't seem to get it to work
15:27:22 <roconnor> Cont is crazy!!
15:28:20 <Tinned_Tuna> roconnor: I really need to study Haskell more... Or just functional programming in General.
15:28:56 <roconnor> Tinned_Tuna: I think most people would find my question hard.
15:29:16 <BobFunk> made the simplest test of just reading in an image and writing it out again, and got a malloc problem:
15:29:19 <BobFunk> https://gist.github.com/824252
15:29:32 <Tinned_Tuna> I'm going to study category theory for my PhD. There we go, problem solved.
15:29:40 <roconnor> prefect
15:29:58 * roconnor has a PhD but still couldn't solve this problem.
15:30:06 <allbery_b> Cont will drive you insane.  Then you will understand it and drive others insane with you
15:30:25 <xplat_> Conthulhu
15:30:36 <rwbarton> BobFunk: most likely you need to call some kind of init function for the library
15:30:38 <Tinned_Tuna> roconnor: what did you do your PhD in, where, and how did you get funding?
15:30:55 <BobFunk> rwbarton: you're right - I'm stupid :)
15:30:57 <roconnor> I did it in Coq
15:30:59 <BobFunk> forgot that!
15:31:00 * allbery_b has traced through Cont and understood it --- every few months, in fact, because it never sticks
15:31:01 <roconnor> I went to the netherlands.
15:31:51 <BobFunk> rwbarton: hmm - ok - that didn't quite solve it :(
15:31:53 <xplat_> most people do that just to smoke pot, but you went straight for the hard stuff -- Coq
15:31:58 <Tinned_Tuna> Any particular institution? And how much did it cost you (I'm assuming you were EU to begin with, since that kind of helps with funding in some places)
15:32:00 <BobFunk> now I get a *** glibc detected *** ./Test: malloc(): memory corruption: 0x0000000002719a20 ***
15:32:10 <rwbarton> huh
15:32:14 <rwbarton> what platform?
15:32:21 <BobFunk> ubuntu
15:33:39 <BobFunk> added full output to the gist: https://gist.github.com/824252#comments
15:33:45 <xplat_> either hsmagick didn't build right or it must not be a very high-level mapping?
15:33:55 <xplat_> er, binding?
15:34:11 * maltem kind of feels the need for a tuna sandwich now
15:34:12 <BobFunk> seems to be an FFI binding
15:34:22 <Tinned_Tuna> maltem: well... no.
15:34:38 <maltem> ^^
15:34:49 <xplat_> maltem: dude, not cool
15:34:49 * roconnor is still trying to "see" why rwbarton's counter example works
15:35:00 <roconnor> I mean understand in what way Cont isn't like a container
15:35:10 <xplat_> Tinned_Tuna is *right here*
15:35:26 <pozic> BobFunk: you are doing it all wrong. You are expecting that a binding to a C library was not just a quick hack. 
15:35:47 <rwbarton> BobFunk: can you update the code too?
15:35:52 <pozic> BobFunk: not every library is a quality library. 
15:36:16 <rwbarton> I really want a library that will just transform between image files and nice haskell arrays of pixels.
15:36:32 <BobFunk> pozic: know of any good lib for image resizing / cropping ?
15:36:53 <BobFunk> rwbarton: sure will update
15:37:04 <Tinned_Tuna> BobFunk: well, for cropping you could go for the old fashioned way.
15:37:16 <pozic> BobFunk: openil
15:37:23 <periodic> ack! I was having conflicts between monadsfd and mtl, but now I have monadstf as well!
15:37:30 <xplat_> rwbarton: iwbni there were something like netpbm with some haskell types instead of .pnm files
15:37:35 <BobFunk> rwbarton: updated
15:38:00 <pozic> BobFunk: where does it crash? 
15:38:11 <pozic> BobFunk: during the read or the write?
15:38:34 <roconnor> I guess map ($x) forces the function being contained to only be run on one input. and thus the input that distingushed between the values before the fmap cannot be applied to distinguish them anymore.
15:39:07 <BobFunk> from the output it seems to be in "CloneImageInfo"
15:39:15 <roconnor> but really it is hard to see (Cont r) as a container
15:40:28 <rwbarton> BobFunk: works for me on debian
15:40:58 <rwbarton> also, I wonder whether it could be a 32-bit vs. 64-bit thing?
15:41:04 <rwbarton> you seem to be on 64-bit
15:41:10 <BobFunk> yeah
15:41:23 <BobFunk> running on a 64 bit virtual box ubuntu
15:41:38 <BobFunk> if I get it working it will need to run on a 64bit VM in the rackspace cloud
15:41:43 <BobFunk> so has to be 64 bit
15:41:44 <Tinned_Tuna> The library may have some bugs in 64bit mode, or at least some quirks.
15:41:59 <pozic> Heh, that library is full of unsafePerformIO. 
15:42:09 <rwbarton> I don't have any 64-bit machines to test on unfortunately
15:42:12 <Tinned_Tuna> let me evacuate the area via the nearest windo.
15:42:40 <BobFunk> pozic: yeah - looks pretty scary :/
15:43:18 <luite> cabal unpack wumpus-core
15:43:21 <aristid> preflex: seen kamatsu
15:43:21 <preflex>  kamatsu was last seen on #haskell 9 days, 3 hours, 57 minutes and 22 seconds ago, saying: can't you just use ""?
15:43:21 <luite> oops
15:43:22 <rwbarton> xplat_: right, I think that's what I want.
15:43:39 <rwbarton> I was thinking of wrapping sdl-image and copying out the image data to an array
15:44:06 <tomh> aristid: sup~
15:44:06 <rwbarton> Not sure whether that's the best library to use though
15:44:12 <pozic>   -- TODO: Worry about memory freeing.
15:44:19 <pozic> Sure, you do that. 
15:44:21 <pozic> :)
15:45:03 <aristid> tomh: heya
15:45:05 <pozic> -- this may very well be wrong
15:45:16 <rwbarton> Sounds like I won't be using hsmagick anyways
15:45:17 <pozic> Well, at least the author is humble. 
15:45:25 <tomh> aristid: do you have lots of cabal experience by any chance? :D
15:45:37 <BobFunk> rwbarton: yeah - gonna try to find something else
15:45:42 <BobFunk> not sure what though
15:45:44 <aristid> tomh: i use cabal, but if that counts? dunno
15:45:53 <aristid> tomh: what's the problem?
15:46:04 <tomh> I don't get output after running build :(
15:46:11 <tomh> (with a userhook)
15:46:41 <xplat> and maybe there could be some nice fusion laws
15:46:48 <rwbarton> BobFunk: I think the sdl/sdl-image libraries will do what you want; they looked the most trustworthy to me when I was investigating this earlier
15:47:27 <rwbarton> is there anything like a 2D version of Vector?
15:47:49 <rwbarton> I think I could make a Vector of vector-statics but that library has big unmaintained warnings on it
15:48:10 <BobFunk> what I'm actually looking for is something that can load a bytestring into an image, resize and crop it, and give me back a bytestring
15:48:27 <pozic> BobFunk: wx contains image functionality.
15:48:38 <pozic> BobFunk: but it still requires some work for you. 
15:48:50 <rwbarton> I'm pretty sure sdl & sdl-image is enough for that
15:49:05 <roconnor> http://hackage.haskell.org/package/AC-EasyRaster-GTK ?
15:49:24 <rwbarton> er... bytestring? That may be trickier
15:49:44 <Tinned_Tuna> rwbarton: but won't the conversion be trivial?
15:49:47 <xplat> yeah, if you bind C libraries they will often only work on an actual file :(
15:50:02 <Tinned_Tuna> assuming that each pixel maps to a constant number of bytes
15:50:12 <Tinned_Tuna> just take n ... : drop n ... 
15:50:15 <xplat> if they can handle a C array there's no big problem ...
15:50:24 <rwbarton> SDL has this RWops thing that you can surely munge a bytestring into... somehow
15:51:03 <pozic> roconnor's suggestion is pretty good. 
15:51:04 <BobFunk> think I might give GD a try http://hackage.haskell.org/packages/archive/gd/3000.6.1/doc/html/Graphics-GD.html
15:51:06 <rwbarton> (it's more or less the SDL abstraction for a handle)
15:51:23 <pozic> Andrew Coppin had basically the same problem and actually fixed it.
15:52:39 <danharaj> is Dr. Elliott around?
15:53:07 <aristid> maybe he is equivalent to elliottcable?
15:53:19 <danharaj> :o weren't those two distinct people at some point?
15:53:22 <aristid> tomh: cabal build -v?
15:53:24 <danharaj> Have they merged?
15:53:34 <aristid> danharaj: who knows.
15:54:48 <tomh> aristid: I tried that ofcourse :D
15:56:05 <aristid> tomh: no output AT ALL?
15:56:14 <tomh> nope
15:56:17 <tomh> nothing :/
15:56:33 <aristid> tomh: how do you invoke it?
15:56:46 <tomh> runhaskell Setup.hs build -v or cabal build -v
16:00:16 <tibbe> bos: I want to hack! Wanna hack with me? :)
16:00:32 <bos> tibbe: yeah!
16:00:38 <tibbe> bos: downstairs?
16:00:46 <bos> yup
16:00:58 <aristid> tomh: i cannot get cabal build not to produce output
16:01:03 <aristid> tomh: it ALWAYS says something
16:01:38 <tomh> aristid: maybe it is the userhook then which prevents it from outputting something
16:01:54 <aristid> tomh: maybe.
16:02:13 <aristid> tomh: but that is beyond my knowledge of cabal :) i just built normal packages with it
16:02:29 <tomh> im trying to do that too :P
16:02:45 <tomh> but its really hard to debug :/
16:02:58 <tomh> or rather, really anoying :P
16:04:19 <aristid> huh
16:05:10 <copumpkin> Saizan: how goes the vector-static?
16:05:30 <tomh> aristid: without output its hard to see whats going on 
16:18:08 <thoughtpolice> copumpkin: so, you going to go to the just-announced philly hackathon? :)
16:18:17 <copumpkin> probably :)
16:19:09 <thoughtpolice> copumpkin: i'm thinking about trying to make it, tickets would be cheap as hell if i bought them soon
16:20:12 <copumpkin> yeah
16:20:37 <xplat> @ask ksf what are you trying to accomplish with your iteratee hackery?  just self-edification, or the iteratee library to end all iteratee libraries?
16:20:37 <lambdabot> Consider it noted.
16:21:04 * dibblego reserves "the iteratee library to end all iteratee libraries" on hackage
16:22:19 <xplat> ‘literatee’ wouldn't be a bad name for a well-documented and comprehensible version ...
16:23:41 <xplat> (especially if it were all in .lhs)
16:25:39 <phrackSipsin> Hello, I'm trying to use the shpider library but I can't work out how to get at the result of a download action (http://hackage.haskell.org/packages/archive/shpider/0.1.1/doc/html/Network-Shpider.html) any help?
16:28:33 <Bynbo7> phrackSipsin: what do you mean?
16:28:55 <xplat> (status, page) <- download url
16:29:04 <BobFunk> 3
16:29:51 <phrackSipsin> xplat, ah, so simple
16:30:41 <xplat> to do anything with the page you have to import some functions from Network.Shpider.State, but they seem pretty self-explanatory
16:31:29 <luite> if I have a type class that can make default values (Strings) for various types, is it possible to generate valid expressions that involve a function with a specific type? for example: generateDefault not -> "not True", generateDefault (+1) -> "(+1) 0"
16:31:50 <copumpkin> so I'm thinking of writing a library with an interface ask :: String -> String 
16:31:56 <copumpkin> where you can put in questions in english
16:32:00 <copumpkin> and get answers back in english
16:32:11 <copumpkin> it'll use some unsafePerformIO behind the scenes, and isn't referentially transparent
16:32:18 <copumpkin> maybe I should put it in IO
16:32:22 <phrackSipsin> xplat, i want to run parse page but to do this i have to run download and then get the right part of the tuple and do a lookup on that but i can't really work out how.
16:32:28 <kfr> copumpkin: AI.Strong.ask?
16:32:37 <xplat> copumpkin: what does it do, unsafePerformIO a paste to #haskell?
16:32:38 <copumpkin> kfr: exactly
16:32:42 <geheimdienst> let me guess, ask submits the question to #haskell
16:32:49 <copumpkin> damn you guys :P
16:32:52 <kfr> Haha
16:33:26 <luite> the main problem would be to get a string representation for the function itself, I have no idea how to do that
16:33:52 <geheimdienst> i don't see how it would break referential transparence, though. whenever i ask something in #haskell, the answer is "blah blah blah monad"
16:34:02 <ray> > ask "can haskell be liberated from the von neumann paradigm?"
16:34:03 <lambdabot>   "can haskell be liberated from the von neumann paradigm?"
16:34:12 <geheimdienst> this shouldn't vary between queries
16:34:24 <djahandarie> Who is that kid at the hackathon? Is he a Haskeller too? :P
16:34:24 <xplat> phrackSipsin: the page will be parsed (lazily) if you do something like (_, page) <- download url; let parsed = tags page
16:35:02 <periodic> djahandarie: better be!@
16:35:02 <dmead> ?src concatMap
16:35:02 <lambdabot> concatMap f = foldr ((++) . f) []
16:35:19 <djahandarie> periodic, would be impressive since he looks like he's around 11 years old :P
16:35:22 <phrackSipsin> xplat, okay, i'll give it a go, thanks
16:35:27 <xplat> geheimdienst: you're using a semantics that doesn't distinguish between prefixes of monad ...
16:35:29 <periodic> I think he was going through the beginner stuff this morning.
16:35:30 <ray> there are actually 4 kinds of #haskell answer
16:35:31 <periodic> But I don't know him.
16:35:39 <djahandarie> I see
16:35:44 <ray> simple, dense, nonsense, and category theory
16:35:56 <ray> you should be able to pass this to the function
16:35:56 <periodic> He looked distracted during Johan's talk, so it was either over his head or he is so advanced it is trivial.
16:35:59 <periodic> I'm not sure which.
16:36:03 <djahandarie> Hahaha
16:36:27 <geheimdienst> djahandarie: are you looking at a web stream or something, or are you there?
16:36:32 <djahandarie> A picture
16:36:40 <djahandarie> http://yfrog.com/h31smzlj
16:36:53 <djahandarie> Someone should really be recording the talks there though...
16:37:07 <geheimdienst> okay, thanks
16:37:16 <Bynbo7> is that dons talking?
16:37:38 <djahandarie> Looks like it
16:38:15 <periodic> yeah, that's Dons
16:40:01 <copumpkin> dolio: that phao document is quite nice
16:40:20 <copumpkin> and by phao I mean phoa
16:41:51 <phrackSipsin> xplat, all I get is a "The last statement in a 'do' construct must be an expression" error.
16:42:51 <xplat> phrackSipsin: oh, i just gave you the beginning of a do, you still have to add something else involving parsed
16:43:07 <phrackSipsin> ah okay
16:44:19 <xplat> as a minimal example, you could just give ‘parsed’ on a line by itself, that will cause the do statement to be valid and a runShpider on it will just return the list of tags
16:44:46 <xplat> but you could also do something nontrivial there instead
16:46:08 <phrackSipsin> okay thanks, I'll keep trying
16:47:23 <periodic> It took me reading the RWH section on desugaring do blocks to really understand them.
16:47:39 <periodic> It's good practice to convert from do to >> and back to understand what is really going on.
16:47:44 <periodic> Assuming you understand >> and >>=
16:48:11 <xplat> and if you get stuck you can always ask lambdabot
16:48:27 <phrackSipsin> yeah, I'm not sure I understand much at this stage.
16:48:35 <xplat> @undo a <- x; return a
16:48:35 <lambdabot>  Parse error at "<-" (column 3)
16:48:48 <xplat> @undo do { a <- x; return a }
16:48:49 <lambdabot> x >>= \ a -> return a
16:48:52 <periodic> oh, nice.
16:49:11 <phrackSipsin> heh, neat
16:49:24 <xplat> phrackSipsin: btw i guess not ‘parsed’ but ‘return parsed’ to finish that do ...
16:49:50 <phrackSipsin> ah of course
16:50:17 <ddarius> ray: Category theory includes all of simple, dense, and nonsense.
16:50:57 <xplat> actually, category theory is simple, dense abstract nonsense
16:51:04 <ray> there's a technical definition for nonsense now?
16:51:48 <xplat> ray: yes, but you need 20 levels in category theory to understand it
16:52:29 <xplat> you only need 12 levels to understand the nonsense itself :)
16:53:02 <phrackSipsin> Is level 20 where we find out that haskell was written by aliens that dropped our souls in volcanoes?
16:53:09 <dolio> copumpkin: Fibrations, topos theory, effective topos and modest sets?
16:53:12 <ray> it's just math, it's not really that hard :)
16:53:34 <xplat> and at lv25 you can understand half the posts on the n-category cafe
16:53:40 <copumpkin> dolio: yeah
16:54:02 <dolio> I like it so far.
16:54:21 <copumpkin> I can't say I understand most of it, but it gives me more of a clue than I had before :)
16:54:30 <ray> i actually can't think of any hard math, just math i never bothered to study
16:54:32 <xplat> dolio: i'd like to understand more about those four topics ...
16:55:04 <dolio> Jacobs' book might be better, but it's a little out of my price range.
16:56:03 <xplat> copumpkin, dolio: which document are you two talking about?
16:56:14 <copumpkin> http://www.lfcs.inf.ed.ac.uk/reports/92/ECS-LFCS-92-208/
16:56:22 <xplat> ah, thanks
16:58:56 <xplat> the awodey book was mentioned earlier, and he says that category theory should really be called ‘archery’
16:59:11 <ddarius> dolio: You may want to read Benabou's "Fibered Categories and the Foundations of Naive Category Theory" after that, though it's not as easy to get.
16:59:12 <Cin> Oh, because of all the arrows. I get it.
16:59:27 <xplat> since i read that i've had to suppress the urge to write an ‘unlimited functor works’ chant
16:59:36 <kulakowski> xplat: yes please, re archery
17:00:27 * ddarius should probably find food before food ceases being easy to find.
17:01:11 <copumpkin> ddarius: or you could go find those guys who offered me crack last night
17:01:16 <copumpkin> crack > food from what I hear
17:02:23 <djahandarie> lol...
17:02:47 <djahandarie> copumpkin, did you and ddarius end up eating in some back alley or something?
17:03:13 <ddarius> djahandarie: No, the back alley place was full.
17:03:39 <thoughtpolice> tragic, i hear the view is great back there
17:05:49 <blackdog> copumpkin: where are you guys?
17:06:09 <copumpkin> blackdog: in boston
17:06:19 <blackdog> ah. conference on?
17:06:24 <copumpkin> nope, we both live here :)
17:06:38 <blackdog> heh. fair enough.
17:07:25 <xplat> ‘Some familiarity with `ordinary' logic and typed lambda-calculus is assumed.’
17:10:04 <xplat> someone was talking earlier (yesterday?) about tagging different readers in a monad transformer stack with phantom types
17:11:47 <xplat> it occurred to me while reading the referenced article that the relationship between that and the ‘regular’ way of doing stacked readers is (almost?) precisely the same as the relationship between ‘normal’ lambda terms and de bruijn-indexed ones
17:12:05 <xplat> number of lifts == de bruijn index
17:13:42 <xplat> phantom index type == variable name
17:15:14 <ddarius> xplat: It is.
17:22:38 <xplat> i wonder if it would be interesting to create a ski-calculus-based language that had a separate general mechanism for desugaring the use of scoped names rather than trying to force all naming through lambda/let
17:25:56 <xplat> i mean, if you have to do all your name binding through a single mechanism, lambda isn't a bad choice (and the dependent product version is even better) but i feel like it might be better to do that orthogonally because it still seems to make some things awkward to name
17:36:40 <nosila> anyone here?
17:36:45 <nanothief> Is there a library that implements the Data.List functions using the generic typeclasses like Functor, Foldable and Traversable?
17:36:52 <nanothief> yes :P
17:37:43 <djahandarie> nanothief, I was writing something like that but it ended up getting... really generic (catamorphisms, etc). I don't know if anything exists already, didn't bother looking
17:38:19 <c_wraith> well.  there's listlike
17:38:29 <c_wraith> It's not in terms of anything else, though
17:38:29 <djahandarie> Doesn'
17:38:31 <djahandarie> Yeah
17:38:33 <djahandarie> :P
17:38:33 <duckinator> hi
17:39:12 <wichobabas> =0
17:39:20 <c_wraith> though really, between Functor, Foldable, and Traversable, you have most of the not-really-specialized list api
17:39:32 <ddarius> Foldable is basically toList.
17:39:52 <c_wraith> I think the only things you don't get out of that are the unfolds
17:40:10 <c_wraith> (with a little work gluing them together)
17:40:18 <copumpkin> c_wraith: nothing gives you filter :(
17:40:24 <xplat> well, unfolds are a whole different ballgame
17:40:25 <copumpkin> except for filter
17:40:33 <c_wraith> you can't make filter out of foldr?
17:40:40 <copumpkin> you can if you know you have a list
17:40:43 <copumpkin> :P
17:40:44 <ddarius> :t \p -> filter p . Data.Foldable.toList
17:40:45 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> [a]
17:40:45 <c_wraith> Oh, I see
17:40:54 <xplat> you don't get anything where you need to make your own conses
17:41:04 <xplat> because, you know, conses
17:41:13 <copumpkin> foldable reduces you to another structure
17:41:22 <copumpkin> and traversable gives you the same one, but it must be the same "shape"
17:41:57 <xplat> Filterable would be pretty hard if you're not a sequence to begin with
17:42:14 <c_wraith> I guess a tree unfold is going to look entirely different than a list unfold.
17:42:48 <ddarius> Just make a generic catMaybes.
17:42:54 <xplat> for, say, inorder traversal of a binary tree it would be pretty hard to eliminate arbitrary nodes while keeping the same linearized order for the remainder
17:43:42 <xplat> and even when you figure it out it involves arbitrary choices of whether to lift the left or right child when both exist
17:44:04 <xplat> or i should say ‘hoist’ i guess, lift is too overloaded
17:44:14 <c_wraith> man.  after enough time working in haskell, non-purity seems strange to me
17:44:34 <ddarius> c_wraith: I probably warned you that it was all a trap in the beginning.
17:44:59 <c_wraith> "you mean I can just do IO *anywhere*?  That seems unsafe!"
17:45:09 <xplat> just scream ‘impure’ and make the sign of the lambda, the bad code will go away
17:46:25 <nanothief> so does thereI thought that every list function in data.list could be represented with Foldable, Traversable, Applicative and Monoid, does that tree example kill that possibility
17:46:51 <c_wraith> nanothief: Those don't cover unfoldr, either
17:47:20 <xplat> "you mean i need to know how many ones i want *before* i call ones?  what about all the code duplication?"
17:47:34 <ddarius> nanothief: Again, Foldable is just toList.  Every function in Data.Foldable can be represented as Data.List.foo . toList
17:48:18 <ddarius> Maybe we should call Foldable IEnumerable.
17:48:26 <nanothief> ddarius: isn't that only for functions that take a list type to start with?
17:48:48 <nanothief> eg filter :: (Foldable t) => (a -> Bool) -> t a -> t a doesn't seem possible to me
17:49:22 <nanothief> you can turn the input into a list, but then cannot convert back
17:50:25 <ddarius> nanothief: Yes, Foldable gives you a toList, it doesn't give you a fromList.  My point is simply that -all- Foldable provides is a generic conversion to lists.
17:51:13 <nanothief> I see, I think we were on the same page then
17:52:24 <Jesin> http://haskell.org/ghc/docs/latest/html/libraries/containers-0.4.0.0/Data-Set.html
17:52:36 <Jesin> ^ why is Data.Set.Set not an instance of Functor?
17:52:45 <ddarius> Jesin: Start writing the instance.
17:53:24 <c_wraith> One, you can't make the types work.  Two, it'd have to be really inefficient anywa
17:53:50 <ddarius> There's no reason it would have to be inefficient.
17:53:57 <copumpkin> ddarius: so if I parametrize a category by its notion of equivalence of arrows, what laws must that satisfy? must it be an equivalence relation or can I get by with something weaker?
17:54:13 <Jesin> umm
17:54:15 <c_wraith> ddarius, well, assuming it's still implemented as a binary search tree
17:54:17 <Jesin> map :: (Ord a, Ord b) => (a->b) -> Set a -> Set b
17:54:19 <Jesin> map f = fromList . List.map f . toList
17:54:24 <Jesin> is still in Data.Set
17:54:33 <c_wraith> Jesin: that type isn't the same as the type of fmap, though
17:54:42 <Jesin> it's just the Ord requirement, then?
17:54:44 <Jesin> =/
17:54:54 <xplat> c_wraith: only a log(n) factor worse than any ordinary container
17:55:03 <ddarius> c_wraith: If you can restrict to monotonic functions, which is a category where Set would be a functor, you could apply the function element-wise without changing the tree structure.
17:55:27 <c_wraith> ddarius: sure, but that restriction is really hard to express in haskell
17:55:29 <djahandarie> But then you'd probably want a way to label monotonic functions :)
17:55:41 <xplat> ddarius: you don't need monotonic functions to make Set a functor ...
17:55:50 <ddarius> xplat: I didn't say you do.
17:56:11 <c_wraith> also, you'd really want monotonically increasing
17:56:15 <ddarius> c_wraith: Yes, that part would be "one"
17:56:34 <c_wraith> because monotonically decreasing would break the tree amusingly :)
17:56:49 <xplat> hm, i guess monotonic-either-way would still be a category
17:56:52 <ddarius> c_wraith: Monotonic functions have to preserve the order.
17:57:19 <c_wraith> hmm.  I think we're using slightly different definitions of monotonic
17:57:26 <xplat> c_wraith: well, reversing the tree isn't a big deal to do, and if you know the function is monotonic you only have to make one comparison to decide
17:58:05 <c_wraith> xplat: you wouldn't even have to reverse the tree.  You could just store which direction to move on the result of a compare
17:58:26 <xplat> c_wraith: (that's worst-case, not best-case--compare the first and last, if they're the same it doesn't matter anyway)
17:59:17 <ddarius> c_wraith: For the function to reverse, you'd have to switch the ordering (i.e. the type) which is fine as the tree will be doing the "right thing" with the new ordering.
17:59:45 <xplat> if you store it as a finger tree, you can even put the decision off until you use the tree with no real loss of efficiency
17:59:48 <ddarius> copumpkin: I would say you'd need an equivalence relation.
18:00:50 * xplat notes that quotients on categories are defined with an equivalence relation on each homset
18:01:26 <copumpkin> ddarius: okay, yeah, it seemed like it'd probably be necessary
18:10:14 <xplat> at first glance charity looks pretty underwhelming given the expectations created by their sloganeering of CT
18:10:30 <ddarius> xplat: Look at CPL.
18:12:22 <xplat> i assume you don't mean the unweildy ancestor of C?
18:13:03 <xplat> *unwieldy
18:13:31 <ddarius> It's the programming language defined in Hagino's thesis.
18:13:32 <doserj> I guess he means hagino's thesis
18:15:15 <xplat> ah
18:15:33 <pedro3005> is this function correct?
18:15:36 <pedro3005> lowestPrimeFactor n = head $ filter ((== 0) . (mod n)) [2..]
18:16:02 <tromp_> i'd call it least.. though
18:16:22 <pedro3005> but it does the job?
18:16:31 <pedro3005> I wasn't sure if my assumption was correct
18:16:48 <copumpkin> :t find
18:16:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:16:50 <xplat> i think i've read this before
18:17:15 <tromp_> > let n = 51 in head $ filter ((== 0) . (mod n)) [2..]
18:17:16 <lambdabot>   3
18:17:20 <ddarius> xplat: Probably.
18:18:07 <tromp_> yes, it works
18:18:09 <mafs> Made a Haskell group on Convore btw, might work well for longer-term conversation https://convore.com/haskell/
18:18:21 <xplat> it's a nice general way of defining datatypes, but only scratching the surface of what a programming language with a thorough grounding in archery would involve ...
18:19:16 <ddarius> http://www.tom.sfc.keio.ac.jp/~sakai/hiki/?CPL
18:19:26 <xplat> pedro3005: might want to special-case 1, as it is your function will not terminate on input 1
18:19:51 <pedro3005> xplat, what would I do on 1 though?
18:20:06 <Jesin> @undefine
18:20:13 <xplat> which is appropriate in a way since there is no right answer, but you might want to fail to terminate in a shorter time than forever :)
18:20:20 <tromp_> produce undefined:)
18:20:27 <pedro3005> how do I do that?
18:20:39 <tromp_> you alrd did:)
18:21:11 <tromp_> lowestPrimeFactor 1 = undefined
18:21:21 <tromp_> if you want to be explicit
18:21:24 <xplat> but if you write lowestPrimeFactor 1 = undefined it will die with an error right away instead of spin forever
18:21:38 <Jesin> or how about this
18:22:04 <Jesin> hmm
18:22:06 <xplat> that has to go above the ‘real’ definition, if it goes below it will not be evaluated
18:22:06 <Jesin> :t find
18:22:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:22:50 <Jesin> @let leastFactor n = find ((0==) . mod n) [2..n]
18:22:51 <lambdabot>  Defined.
18:22:54 <Jesin> :D
18:23:14 <xplat> Jesin: find will never return Nothing ‘naturally’ in an analagous definition, but at least it gives the right type for the special case to return Nothing
18:23:24 <pedro3005> this is pretty neat
18:23:46 <xplat> leastFactor 6
18:23:58 <xplat> map leastFactor [6,7,0]
18:24:03 <xplat> > map leastFactor [6,7,0]
18:24:04 <lambdabot>   [Just 2,Just 7,Nothing]
18:24:19 <xplat> Jesin: yours fails
18:24:26 <Jesin> how?
18:24:40 <xplat> > 0 `mod` 2
18:24:41 <lambdabot>   0
18:24:43 <Jesin> oh
18:24:45 <Jesin> right
18:25:04 <Jesin> @undefine
18:25:58 <xplat> 0 is a cool number, because it has ALL the prime factors
18:26:05 <Jesin> @let leastFactor 0 = 2; leastFactor n = head $ filter ((0==) . mod n) [2..n]
18:26:06 <lambdabot>  Defined.
18:26:22 <Jesin> > map leastFactor [6,7,9,0]
18:26:24 <lambdabot>   [2,7,3,2]
18:26:32 <Jesin> > map leastFactor [6,7,9,0,1]
18:26:34 <lambdabot>   [2,7,3,2,*Exception: Prelude.head: empty list
18:26:38 <Jesin> :D
18:27:04 <Jesin> eh.
18:27:13 <Jesin> xplat, this is still undefined over the negatives, though
18:27:30 <xplat> right, that was my next nitpick :)
18:27:39 <Jesin> ...
18:27:43 <Jesin> you know what, fine
18:27:48 <Jesin> @undefine
18:28:27 <Jesin> @let leastFactor n = head $ filter ((0==) . mod n) [2 .. (2 + abs n)]
18:28:28 <lambdabot>  Defined.
18:28:44 <Jesin> :t leastFactor
18:28:45 <lambdabot> forall a. (Integral a) => a -> a
18:28:46 <Jesin> :t mod
18:28:47 <lambdabot> forall a. (Integral a) => a -> a -> a
18:28:49 <xplat> heh, that was my definition
18:29:09 <xplat> if you get rid of the arbitrary constant, you can lord it over me ...
18:29:16 <ddarius> m|n iff km = n for k in Nat.  For all n, 1|n and n|0.
18:30:06 <ddarius> s/for k/for some k/
18:31:27 <pedro3005> which one of these do you guys think performs better? http://paste.pocoo.org/show/337379/
18:31:50 <copumpkin> the latter
18:32:21 <pedro3005> yeah, I supposed
18:32:24 <Jesin> I would guess the latter yeah
18:32:28 <Jesin> because your ++ is horrible
18:32:36 <Jesin> you can fix that
18:32:40 <copumpkin> even then
18:32:55 <pedro3005> I'd have to reverse the list?
18:32:58 <copumpkin> you'll want to use quotRem 
18:33:00 <Jesin> no
18:33:05 <copumpkin> not div and mod
18:33:08 <copumpkin> and not separately
18:33:18 <Jesin> probably ^that
18:33:28 <pedro3005> will that be better than digits' ?
18:33:35 <Jesin> umm
18:33:38 <Jesin> you have to fix the (++)
18:33:40 <copumpkin> it might approach its speed
18:33:41 <Jesin> hang on a bit
18:33:58 <pedro3005> so not worth the trouble?
18:34:17 <ddarius> Why don't you wait until it's clear that there is trouble.
18:36:15 <Jesin> hmm
18:37:22 <Jesin> yeah you're probably better off with map digitToInt (show n)
18:39:14 <accel> is there any convex programming package that has haskell bindings?
18:41:48 <seydar> :t digitToInt
18:41:49 <lambdabot> Char -> Int
18:41:59 <seydar> i am enlightened
18:42:04 <seydar> lambdabot, you rock
18:43:41 <copumpkin> accel: not that I know of
18:44:11 <accel> damn it; how did haskell manage to go all this time w/o a convex programming package
18:44:58 <copumpkin> nobody needed it :)
18:45:06 <copumpkin> I did a while back, but I stopped needing it before I wrote a binding
18:45:41 <copumpkin> looks like the burden has fallen on you now!
18:46:06 <seydar> what's convex programming
18:46:34 <copumpkin> it's programming in the older sense used in linear programming, but not necessarily linear anymore
18:46:55 <ddarius> accel: I don't think most programming languages have bindings to/implementations of convex programming.
18:47:02 <sproingie> i thought it had something to do with convex polygons
18:47:10 <ddarius> sproingie: It does vaguely.
18:47:18 <djahandarie> ddarius, do you know of any connections between theorem proving and constraint programming
18:48:25 <ddarius> djahandarie: Constraints are basically just additional axioms on the data.
18:48:49 <accel> copumpkin: you're getting very very sleepy ... very very sleepy ... and you want to do convex programming in haskell .... think about it .... the purity of haskell ... and the power of convex programming ... very very sleepy
18:48:57 <copumpkin> lol
18:49:10 <accel> hypnosis only makes it easier for ppl to do things they've thought about oding anyway
18:49:29 <djahandarie> ddarius, do you think it'd be somehow possible to change some part of theorem proving into a constraint problem?
18:49:44 <accel> djahandarie: read about P vs NP
18:49:50 <accel> you can change all of theorem proving intoa  constriang problem
18:49:58 <accel> the constarints are, initla state = facts you know
18:50:01 <accel> final state = goal you want to prove
18:50:02 <Jesin> [22:12:05]	<accel>	hypnosis only makes it easier for ppl to do things they've thought about oding anyway
18:50:04 <Jesin> eh
18:50:08 <accel> constraints = internetiate stpes only follow each other
18:50:10 <Jesin> that's a bit simplistic
18:50:13 <luite> i've built some quasiconvex programming thingies in haskell (where only the lower contour sets are required to be convex), but the only bindings I used were for glpk
18:50:26 <accel> luite: cool, can you github it?
18:50:28 <Jesin> it doesn't make you do anything you have a problem with doing, if that's what you meant
18:50:34 <Jesin> :p
18:50:45 <accel> Jesin: you have phrased it far more elegantly
18:50:56 <accel> Jesin: mobs of people would follow you to the ends of the earth; whereas they would lynch me
18:51:12 <Jesin> umm
18:51:29 <ddarius> accel: Meaning Jesin follows Rule #1 from Zombieland and you don't?
18:51:29 <luite> accel: not yet, still working on it. but it's not a general quasiconvex programming solver, it's for specific problems
18:51:41 <Jesin> what
18:51:49 <accel> luite: how specific? I actually just want a quadratic minimizer over a convex polygon
18:51:49 <djahandarie> accel, I see
18:52:18 <accel> djahandarie: would you like to wire your tuition to me by paypal or direct deposit?
18:52:31 <djahandarie> :P
18:53:28 <djahandarie> What does this have to do with P vs NP though? Is it some colloquial problem to explain NP?
18:53:49 <djahandarie> Doesn't seem like something that most people would be interested in...
18:55:33 <accel> djahandarie: I learned about these reduction tricks from Cook's paper on P vs NP, where he reduces turing machines down to SAT
18:56:34 <luite> accel: quite specific :) it minimizes a = max_i(a_i),  a_i^(-w1i.x) + a_i^(-w2i.x) = 1  where wi1 and w2i are fixed, . is the dot product
18:57:20 <accel> luite: so the problem is that for every convex programming problem
18:57:30 <accel> luite: you have to write a new solver to calcualte the gradients
18:58:07 <luite> I calculate the gradients with automatic differentiation
18:58:24 <luite> although I did some of it manually
18:58:46 <luite> so not a fully general procedure :(
18:59:21 <accel> lright; i'll go simpler
18:59:26 <accel> do we even ahve any linear programming solvers in haskell?
18:59:37 <luite> yeah there's a glpk binding :p
18:59:42 <luite> on hackage
18:59:45 <luite> but use hmatrix-glpk
18:59:49 <luite> not glpk-hs
18:59:59 <luite> since the latter is unusable due to bugs
19:00:14 <luite> annoying bugs too, that don't show up with simple test problems
19:00:35 <luite> it incorrectly reports the status of the lp optimization
19:00:36 <accel> that only show up when you have like 1000 varaibles?
19:01:52 <luite> it only reports problems as infeasible if they are found infeasible by the glpk preprocessor
19:03:29 <luite> I've reported it to the author, it just uses the wrong way to read the glpk status, but he doesn't seem interested in fixing it
19:03:40 <luite> at least he hasn't uploaded a new version or responded to my mail
19:06:27 <luite> by the way, is there anything that can be done about this? I can send him another mail, but if he doesn't respond again, it would be better to remove it from hackage, or update it with a big warning message
19:23:15 <ezracooper> Just upgraded to 0.10 from something like 0.6.
19:23:28 <ezracooper> In previous versions, I could load cargo onto a ship just by dragging it.
19:23:33 <ezracooper> Now this doesn't seem to be the case.
19:23:36 <ezracooper> How do I do it?
19:25:41 <TTimo> you lost me at 'cargo onto a ship' 
19:27:04 <Botje> ezracooper: this is not the freecol irc channel
19:27:19 <BobFunk> what ubuntu package do I need for hlibev?
19:27:23 <ezracooper> doh
19:28:28 <lispy> BobFunk: hmm...I can't check easily, but I would have assumed libev-devel
19:31:14 <BobFunk> have it installed, but no go
19:31:31 <BobFunk> first error: Libev.hsc:183: error: ‘EVFLAG_SIGNALFD’ undeclared (first use in this function)
19:35:07 <blackdog> copumpkin: hey, do you remember why we can't make x86_64 binaries on Mac with GHC? is anyone working on it?
19:36:05 <copumpkin> I think there's one that works up on the gHC download page
19:36:08 <copumpkin> it just isn't the official one
19:36:15 <copumpkin> and I think the next release will support it out of the box
19:36:42 <blackdog> ... you serious?
19:36:53 <blackdog> argh. just spent hours trying to kick ruby into making 32 bit libs on mac
19:36:57 <copumpkin> :)
19:37:03 <copumpkin> I haven't tried it
19:37:09 <copumpkin> but I think it works
19:40:02 <blackdog> copumpkin: do you mean gregory wright's, or christian maeder?
19:40:15 <copumpkin> either
19:41:07 <seydar> wright's isn't showing me any love for dynamic libraries
19:43:48 <blackdog> copumpkin: so it actually makes x86_64 binaries, or the ghc binary itself is an x86_64 binary
19:43:51 <blackdog> ?
19:44:11 <copumpkin> blackdog: I'd hope both, since to make an x86_64 GHC you'd need to have produced x86_64 binaries from GHC at some point
19:44:17 <blackdog> true
19:45:38 <sproingie> can haz haskell platform 2011?
19:54:50 <copumpkin> the notion of equality of morphisms in a preorder category is trivial, right?
19:56:19 <olsner> copumpkin: yep, if it's not trivial for you then you're obviously stupid :P
19:56:21 <blackdog> seydar: ah, that's the one you grabbed? yeah, it doesn't seem to have dylibs built.
19:56:27 <copumpkin> olsner: oh that's good
19:58:05 <seydar> blackdog: you've tested out the other one?
19:58:11 <blackdog> no
19:58:12 <olsner> copumpkin: happy to help :D
19:58:13 <blackdog> downloading it now
19:58:23 <blackdog> i really wish they'd just distribute the recipe though :/
19:58:41 <seydar> homebrew recipe? yargh. i was working on it, but I couldn't get it to work
20:14:27 <ddarius> copumpkin: Assuming you have an equivalence relation on objects and a family of equivalence relations so as to provide each hom-set with its own equivalence relation, then you can define the skeleton of a category by simply setting each hom-set equivalence relation to the constantly true one.
20:16:19 <ddarius> copumpkin: Basically, what you should be doing is simply stating that you have a setoid of objects and hom-setoids.
20:20:05 <roconnor> you probably don't want/need to make objects into a setoid
20:22:44 <ddarius> roconnor: What about, for example, the poset category of computable real numbers?
20:23:41 <roconnor> I'm not sure.  I guess I'd normally expect different representations of the same real number to be isomorphic
20:24:03 <winxordie> anyone know how to get the accelerate library to work with cuda 3.2? (or alternatively get cuda-0.2.2 to work with cuda 3.2)
20:24:26 <copumpkin> ddarius: for specific categories, I can have more structure, but why would I need a setoid on objects?
20:27:21 <ddarius> copumpkin: I'd imagine for the same reasons you'd want them for arrows.
20:27:43 <copumpkin> ddarius: do I ever need to talk about equality on objects?
20:27:52 <ddarius> copumpkin: When you compose.
20:28:05 <copumpkin> hmm
20:28:49 <copumpkin> how so?
20:28:52 <ddarius> If 0 <= 0.99... and 1 <= 2, can I show 0 <= 2 ?
20:29:42 <copumpkin> well, for a particular instantiation I can have equality on its objects and use that to let myself compose them
20:30:01 <rwbarton> If you can show 0.99... and 1 are isomorphic you might not need to identify them as objects
20:30:08 <rwbarton> after all a setoid is a special kind of category
20:30:36 <ddarius> copumpkin: Why doesn't that work for arrows?
20:31:49 <copumpkin> ddarius: because the associativity law tells me that f . (g . h) = (f . g) . h
20:32:01 <copumpkin> so I need to be able to talk about equality of morphisms on every category
20:33:13 <copumpkin> same with id . f = f
20:35:59 <ddarius> I don't see how those laws are different from laws like dom (f . g) = dom g
20:36:28 <copumpkin> well, it should only be necessary to define one of them for the entire "typeclass" of categories, right?
20:36:54 <ddarius> One of what?
20:37:02 <copumpkin> equality on objects or equality on morphisms?
20:38:06 <rwbarton> it's not that you don't need to talk about equality on objects
20:38:27 <rwbarton> but you can always replace a category with a setoid of objects by an equivalent one with a set of objects
20:38:51 <rwbarton> so if you only care about categories up to equivalence you don't need to make the objects form a setoid
20:38:52 <ddarius> rwbarton: If you have quotients.
20:39:34 <ddarius> Well, you mean by "exploding" id essentially.
20:39:50 <rwbarton> You can take objects to be the elements of the underlying set and a morphism to be a composition of an equality in the setoid, a real morphism, and another equality
20:39:53 <rwbarton> Yes
20:40:05 <rwbarton> (Or something like that)
20:40:57 * ddarius will be back.
20:43:24 <copumpkin> I guess my question is will I get bitten down the line if I define category as http://snapplr.com/036p ?
20:52:54 <dino-> Ugh, hackage failing to respond to my upload.
20:54:00 <dino-> Wow, that took a long time.
20:54:17 * hackagebot epub-metadata 2.1.0 - Library and utility for parsing and manipulating ePub OPF package data  http://hackage.haskell.org/package/epub-metadata-2.1.0 (DinoMorelli)
20:55:05 <rwbarton> copumpkin: you're missing an axiom relating composition and Hom-equality
20:55:25 <rwbarton> that composition respects Hom-equality in each argument
20:55:42 <copumpkin> oh yeah, was just getting bitten by that right now
20:56:09 <rwbarton> Otherwise, I really don't know.  You might find it awkward to encode your objects as sets rather than setoids, depending on what you are trying to do.
20:57:11 <rwbarton> For example, if you want to form functor categories, you'll have to do something like I described above
20:58:49 <copumpkin> hmm, I don't see why it would be awkward to make functor categories here
20:58:59 <copumpkin> I guess I should go try to make them :P
21:02:43 <roconnor> copumpkin: have you seen spitters latest coq implementation of categories?
21:02:49 <copumpkin> nope
21:02:57 <roconnor> http://arxiv.org/abs/1102.1323
21:04:09 <djahandarie> When is an idea good enough to write a paper on it rather than just drop it on a webpage somewhere?
21:04:25 <copumpkin> djahandarie: when you want to appeal to academics
21:04:52 <djahandarie> Is that a property of the idea? :P
21:04:53 <roconnor> djahandarie: when it is awesome
21:05:02 <applicative> blog posts have revealed the true meaning of antecedent academic literature.
21:06:01 <copumpkin> "
21:06:01 <copumpkin> (The categorical arrow is distinguished from the primitive function space arrow
21:06:01 <copumpkin> by its length."
21:06:08 <ddarius> So what about arrow categories?
21:06:23 <ddarius> djahandarie: If it is publishable.
21:06:42 <copumpkin> given the quality of some papers I've seen, that doesn't seem to be much of a criterion
21:07:18 <ddarius> copumpkin: It isn't, but if you can get it published, that's a bit more reputation for yourself.  You can also put it on a blog/webpage if you want.
21:07:51 <copumpkin> ddarius: good point about the arrow categories :/
21:08:19 <copumpkin> bah
21:08:29 <roconnor> what about arrow categories?
21:08:58 <copumpkin> roconnor: arrows are objects, and if I want to build one using my definition, I need equality on them
21:09:10 <roconnor> why?
21:09:21 <roconnor> who says objects can't have equality
21:09:30 <copumpkin> I don't
21:09:32 <copumpkin> but I don't require it
21:09:35 <roconnor> so
21:09:45 <roconnor> just drop the setoid when you make the arrow category
21:09:46 <copumpkin> I can request one for constructs that need it
21:09:48 * roconnor hasn't tried this
21:10:11 <copumpkin> hmm
21:10:18 * roconnor really hasn't tried this
21:10:45 <rwbarton> It wouldn't really be the arrow category, then
21:10:54 <roconnor> maybe
21:10:58 <roconnor> but it might be good enough
21:12:06 <copumpkin> my reluctance to add equality on sets is that then I'd have to define equality on agda sets if I wanted to define the agda category
21:12:21 <roconnor> it's a good thing to be reluctant about
21:12:38 <copumpkin> and by equality on sets, I mean equality on objects in (all) my categories
21:12:49 <ddarius> Now that I've sown enough FUD, I'll return to watching Frank Pfenning talk about focused proofs.
21:12:54 <copumpkin> :P
21:13:00 <copumpkin> ddarius: thanks :)
21:13:05 <rwbarton> you can always choose the Refl equality relation if you like
21:13:23 <copumpkin> rwbarton: that feels like a hack :(
21:13:34 <copumpkin> wait, what?
21:13:39 <copumpkin> :P
21:14:08 <copumpkin> I guess I can define equality on agda sets easily if they are actually identical
21:14:43 <copumpkin> fucking notions of equality, always complicating things that are so clean and elegant otherwise
21:14:55 <roconnor> @quote equality
21:14:55 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
21:15:40 * copumpkin wonders whether to allow the two different equalities to be at different levels
21:15:51 <copumpkin> feels like overkill to parametrize my categories by four different universe levels
21:16:07 <rwbarton> is the Agda category the one whose objects are the collection Set?
21:16:17 <copumpkin> yeah, Set at any level
21:17:15 <rwbarton> kind of a weird category I guess, not very much like the real Set
21:18:11 <copumpkin> well, "forall levels L, Set L is a category" is how I have it set up right now
21:18:39 <copumpkin> Set L and the usual function arrow, which magically works at all levels
21:18:52 <rwbarton> oh, it's certainly a category, it's just that the terminology is poorly aligned with classical mathematics
21:19:14 <rwbarton> e.g. Set L appears to be missing lots of colimits, or possibly has the "wrong" ones
21:19:45 <copumpkin> it also has no subobjects :P
21:20:31 <copumpkin> hmm, does it?
21:21:30 <djahandarie> Whatever happened to that most recent P?=NP paper?
21:21:50 <copumpkin> djahandarie: "maybe" is much bigger news than "no"
21:22:25 <djahandarie> ...?
21:30:34 <ddarius> djahandarie: Presumably the same thing that happened to all the others.
21:33:23 <copumpkin> hmm, this equality on objects things makes me uncomfortable
21:34:49 <Jafet> Is there a decision procedure for determining whether a P=NP? paper is valid
21:46:55 <ddarius> Jafet: Yes for the appropriate notion of a validity.
22:06:35 * hackagebot plot-gtk 0.1.0.4 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.4 (VivianMcPhail)
22:26:59 <periodic> Is there an equivalent of (,) for lists?
22:27:07 <mauke> huh?
22:27:09 <periodic> oh, return...
22:27:15 <copumpkin> o.O
22:27:20 <periodic> I wanted a function `a -> [a]`
22:27:29 <copumpkin> (,) doesn't do that on tuples :P
22:27:29 <mauke> how is that like (,)?
22:27:31 <periodic> that I could use in a composition
22:27:52 <periodic> @t (,)
22:27:53 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:27:58 <mauke> :t [return, pure, (: [])]
22:27:58 <lambdabot> forall a. [a -> [a]]
22:28:07 <periodic> :t (,)
22:28:08 <lambdabot> forall a b. a -> b -> (a, b)
22:28:20 <periodic> oh, right (: []) is what I was thinking of.
22:28:45 <periodic> it my head I was looking for a partially applied infix operator I could wrap in some parens and use in a composition.  That's what I meant.
22:28:51 <periodic> but that's not what I said...
22:29:41 <periodic> but if I'm already using the list monad I can juse use return.
22:32:38 <periodic> I'm trying to find overly complex ways to do the examples in Barley
22:32:46 <periodic> anyway, it's late.  night
23:30:14 <Bynbo7> An interesting question came up on the comp sci reddit asking what language features could be improved by having direct hardware support. I was thinking that STM would be a good candidate (STM -> HTM)
23:31:08 <copumpkin> I was bitching about that a while back
23:31:17 <copumpkin> and how it should just be called TM in case we get hardware support someday
23:32:04 <ddarius> HTM is older than STM.
23:45:01 <jonkri> i want to create a simple monad transformer for logging. i also want to create a function which spawns the appropriate logging process, sets up the state of the logging transformer (including logging functions and channels) and attaches the logging transformer to the arbitrary io monad (or transformer on top of it) of the application that uses the logging framework. what would be the type of this logger initializing function?
23:46:37 <ddarius> @hoogle liftIO
23:46:37 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
23:47:08 <ddarius> MonadIO m => LoggerT m a -> stuff -> m a
23:56:33 <tibbe> .
23:58:49 <Jonno_FTW> ..
23:58:55 <copumpkin> ...
23:59:07 <Jonno_FTW> :t (..)
23:59:08 <lambdabot> parse error on input `..'
23:59:13 <Jonno_FTW> :(
23:59:34 <Jonno_FTW> @hoogle (..)
23:59:34 <lambdabot> No results found
