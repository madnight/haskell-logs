00:01:48 <Eduard_Munteanu> bradleyayers: do note it was last revised in 2000, it seems...
00:02:03 <bradleyayers> Eduard_Munteanu: yeah, i noticed that
00:02:12 <bradleyayers> so it's probably out of date anyway?
00:02:49 <Eduard_Munteanu> Well I don't think it's completely out of date, but there are better introductory materials.
00:02:52 <Eduard_Munteanu> @where lyah
00:02:52 <lambdabot> http://www.learnyouahaskell.com/
00:03:11 <Eduard_Munteanu> This seems to be recommended nowadays by people in here ^
00:03:42 <bradleyayers> thanks, ill give that a read
00:06:01 <Eduard_Munteanu> With respect to the standard, few things changed since 2000, but the problem is that introduction isn't that gentle anyway (at least according to some people, I don't think it's so bad :) )
00:07:36 <bradleyayers> well haskell does have a reputation for not being gentle.. after all
00:07:54 <bradleyayers> lyah is looking good though
00:08:12 * quuuux thinks Haskell should be renamed Warm Fuzzy Language to counter that impression
00:08:48 <bradleyayers> quuuux: that would probably only be a temporary fix
00:10:53 <Eduard_Munteanu> RWH has some useful material too, but that's more useful after you get going with LYAH.
00:10:56 <Eduard_Munteanu> @where rwh
00:10:56 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:12:37 * Eduard_Munteanu off
00:18:16 <bradleyayers> wouldn't 'empty' be a better name for null?
00:19:51 <bradleyayers> null ins't very warm and fuzzy
00:21:28 <ccvx> how can i convert Bytestring(strict) to IOVector Word32?
00:25:52 * hackagebot wikipedia4epub 0.0.10 - Wikipedia EPUB E-Book construction from Firefox history.  http://hackage.haskell.org/package/wikipedia4epub-0.0.10 (RadoslavDorcik)
00:37:21 <ivanm> bradleyayers: empty is typically used to define/create empty values
00:37:23 <ClaudiusMaximus> > M.null M.empty
00:37:24 <lambdabot>   True
00:38:35 <bradleyayers> ivanm: what module is this in, i do :t empty and get a not in scope error, so it's not in the prelude right?
00:38:58 <ivanm> bradleyayers: individual data types
00:39:29 <ClaudiusMaximus> like Data.Map.Map, Data.Set.Set, ...
00:40:58 <bradleyayers> ClaudiusMaximus: what is M that you used?
00:41:06 <ivanm> Data.Map
00:41:58 <ClaudiusMaximus> > S.null S.empty -- lambdabot imports some things qualified, with commonly used abbreviated names like M for Data.Map and S for Data.Set
00:41:59 <lambdabot>   True
00:42:37 <bradleyayers> thanks
00:43:03 <ClaudiusMaximus> "import qualified Data.Map as M" would be the syntax, qualified names are useful when different modules define the same names
00:46:15 <ClaudiusMaximus> http://www.haskell.org/hoogle/?hoogle=sqlite -- which of these 10 packages (or maybe something else not listed) should i use if i want to have my program keep its state between runs?
00:51:06 <ivanm> OK, I've worked out why my Text-based code is slower than my String-based one: explicit decoding is the problem
00:51:52 <ivanm> preflex: seen bos
00:51:52 <preflex>  bos was last seen on #ghc 1 day, 8 hours, 51 minutes and 14 seconds ago, saying: dcoutts: ah
00:54:15 <xyz88> hello
00:55:11 <xyz88> head' (x:_) = x   ? how does this fucntion work to take the head off of a list?
00:55:32 <bradleyayers> xyz88: pattern matching
00:55:37 <xyz88> yes
00:55:43 <ivanm> since : is the cons operator
00:55:48 <xyz88> yes
00:56:11 <bradleyayers> it doesn't modify the list, if that's what you were thinking
00:56:32 <ivanm> bradleyayers: well, not the original one... you could argue that it modifies the copy that it is given
00:56:40 <xyz88> if i put in any list of numbers, how does (x:_) work on it to output the 1st number in the list?
00:56:47 <ClaudiusMaximus> > (1:2:3:[]) == [1,2,3] -- syntax sugar
00:56:48 <lambdabot>   True
00:57:13 <ivanm> xyz88: because of pattern matching on the constructor
00:57:19 <ivanm> [] and : are the two constructors for lsits
00:57:20 <ivanm> *lists
00:57:38 <bradleyayers> ivanm: does it actually get a copy of the list?
00:57:40 <ClaudiusMaximus> > (1:2:3:[]) == (1:(2:(3:[]))) -- associativity
00:57:41 <lambdabot>   True
00:57:51 <ivanm> bradleyayers: Haskell is pass by value
00:58:00 <ivanm> in terms of implementation, no
00:58:38 <bradleyayers> always pass by value?
00:58:53 <bradleyayers> i guess since nothing can be modified
00:58:56 <ivanm> in terms of the semantics, yes
00:58:59 <xyz88> so, is haskell mapping x to the 1st component in the list then outputting it?
00:59:04 <ivanm> xyz88: yes
00:59:08 <ClaudiusMaximus> so, head [1,2,3] -> head (1:(2:(3:[]))) -> head (1:(...)) -> 1
01:00:49 <bradleyayers> i feel pretty useless, i do import Data.Map, i expected Map would be imported to current scope, but i do :t Map and get a not in scope error
01:01:20 <xyz88> ivanm++
01:01:20 <ivanm> bradleyayers: how/where are you doing it?
01:01:31 <ivanm> because that should work
01:01:38 <ivanm> (though you _should_ import it qualified...)
01:02:02 <bradleyayers> http://dpaste.com/432682/
01:02:22 <ivanm> wow, just "import" works in ghci now? :o
01:02:35 <ivanm> bradleyayers: Map and Set are types, not values/constructors!
01:02:39 <ivanm> :i Map
01:02:51 * ivanm mis-read bradleyayers's original message
01:02:54 <ClaudiusMaximus> import qualified Data.Map as M ; import Data.Map(Map)  -- is a common idiom for avoiding ambiguous names and not having to type M.Map all the time
01:03:09 <bradleyayers> ivanm: i thought :t was short for :type which would tell me about a type 
01:03:20 <ivanm> bradleyayers: :type gives you the type of a function/value
01:03:28 <ivanm> Map and Set _are_ types
01:03:32 <ivanm> so they have kinds, not types
01:03:37 <ivanm> (where kinds are the types of types :p)
01:03:41 <bradleyayers> ivanm: i see, makes sense
01:04:20 <bradleyayers> these are not easy questions to google
01:06:40 <ski> (ClaudiusMaximus : s/->/=/ :)
01:10:23 <ivanm> oh, great, my computer is screwing with me again: previously, my String-based code was faster than my Text-based one; now it seems to have swapped around for no apparent reason :s
01:11:14 <ClaudiusMaximus> ivanm: you did disable cpu frequency scaling? not running into thermal throttling issues either?
01:11:30 <ivanm> maybe
01:11:52 <ivanm> but when running the same script numerous times to compare the two the String-based one always just out-edged the Text one
01:12:50 <Tolu> hello
01:13:18 <alpounet> ivan, you should try a criterion bench
01:13:29 <alpounet> let it handle this weirdness for you
01:13:59 <alpounet> (since iirc it runs the benchs several times)
01:15:07 <ClaudiusMaximus> hm, direct-sqlite seems the best from my cursory inspection, though i worry about thread-safety now...
01:15:49 <ivanm> alpounet: it did, and it showed the Text version was faster
01:16:21 <ivanm> so I figured the difference must be in the IO, and when I started poking around in there I found that magically (even after I reverted the changes) the Text version was still faster :s
01:17:26 <alpounet> ugh
01:17:59 <ivanm> even when String was faster it wasn't by much anyway, so I might just leave it now
01:18:41 <ivanm> (though it's dissapointing that the parsing optimisations I added in the Text version just cancelled out the State-based stuff I added as well :s)
01:18:59 <jonkri> hi. would it be better to use c+gtk+ffi instead of gtk2hs for a complex and themed gui? also, does anyone know if someone is working on making bindings for gtk3 to haskell?
01:19:22 <ivanm> preflex: seen ManateeLazyCat
01:19:22 <preflex>  ManateeLazyCat was last seen on #haskell 21 hours, 13 minutes and 33 seconds ago, saying: When time release ghc-7.0.2?
01:19:31 <ivanm> jonkri: ^^ he's the one you want to talk to about gtk2hs
01:20:19 <jonkri> thanks ivanm :)
01:20:32 <alpounet> ivan, can't replace the State based stuff with CPS-based stuff ?
01:20:55 <bradleyayers> thanks all the help guys
01:22:04 <ivanm> alpounet: no idea ;-)
01:22:13 <ivanm> besides, isn't CPS slow in 7.0.1?
01:22:31 <ivanm> but I needed stateful printing and parsing
01:22:48 <ivanm> e.g. if a colorscheme is explicitly set, then parse based on that colorscheme
01:23:09 <alpounet> i don't know for 7.0.1 but I know that there's been some state to cps conversions in libraries last months resulting in speedups
01:24:19 <ivanm> wasn't the big thing in the binary conversion leading to a slowdown?
01:26:31 <alpounet> ivan, talking about http://lennartkolmodin.blogspot.com/2011/02/binary-by-numbers.html ?
01:26:58 <ivanm> yup
01:27:02 <ivanm> oh, it was for 64bit only
01:27:04 <ivanm> *shrug*
01:29:41 <alpounet> ivan, i don't remember which apps/libraries are concerned, but binary isn't the only one concerned with that to-cps conversion
01:29:59 <alpounet> you really might want to investigate this
01:30:30 <ivanm> yeag\h
01:30:32 <ivanm> *yeah
01:30:44 <ivanm> but I don't think it would make that much of a deal in my case
01:31:09 <ivanm> generally, the call to dot outweighs the actual printing/parsing requirements :p
01:32:56 <alpounet> oh yeah right, that's for your graph stuffs
01:38:56 <Feuerbach> Is this http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell still the easiest way to call C++ from Haskell?
01:39:11 <Feuerbach> (ghc-compiled Haskell)
01:39:57 <Feuerbach> It mentions cplusplus calling convention -- is it still not supported?
01:44:39 <monadic_kid> you're probably better off generating a C interface using SWIG all I've read that the C backend is a bit experimental still so I don't know how stable it is.
01:44:53 <monadic_kid> *although I've read that...
01:49:09 <accel> what's the best haskell web framework? happs, snap, or somethign else?
02:12:09 <joe6> /home/j/.cabal/lib/llvm-0.9.1.0/ghc-7.1.20110209/libHSllvm-0.9.1.0.a(Scalar.o): In function `skyz_info': (.text+0xd): undefined reference to `LLVMAddVerifierPass'
02:12:21 <joe6> i get the above error when I run make on the llvm/examples dir
02:12:47 <joe6> i figure it must be something wrong with the FFI .hsc files in the distribution.
02:13:16 <joe6> Are the .hsc files converted to .o files during the the setup of the module?
02:13:41 <joe6> any suggestions on how I can fix the above error?
02:14:32 <alpounet> joe6, do you have LLVM (the actual C++ libraries and programs) installed ?
02:14:44 <alpounet> are you sure the version is compatible with the one the llvm package is for ?
02:14:54 <alpounet> i had no trouble working with it a few months back
02:15:22 <snk_kid>  .hsc become .hs files
02:15:24 <joe6> alpounett, yes
02:16:35 <joe6> alpounet, the llvm package says that it is compatible with 2.8 and I have 2.8 installed in my ~/local/llvm and 2.7 in /usr/lib and I did this, --extra-lib-dirs="/home/j/local/llvm/lib" --extra-include-dirs="/home/j/local/llvm/include"
02:17:05 <alpounet> do you know which one it uses ?
02:17:57 <joe6> and I can see that when I do a grep in the llvm directory, I find a match for: include/llvm-c/Transforms/Scalar.h:void LLVMAddVerifierPass(LLVMPassManagerRef PM);
02:18:32 <alpounet> joe6, is that function in both 2.7 and 2.8 ?
02:19:09 <joe6> /home/j/.ghc/bin/ghc --make -package-name llvm-0.9.1.0 -hide-all-packages -fbuilding-cabal-package -i -idist/build -i. -idist/build/autogen -Idist/build/autogen -Idist/build -I/usr/lib/llvm-2.7/include -I/home/j/local/llvm/include -optP-I/usr/lib/llvm-2.7/include 
02:19:17 <joe6> this is what I see with configure -v
02:19:28 <joe6> alpounet, let me check the 2.7 library for that.
02:20:30 <joe6> alpounet, yes the 2.7 library does not have it.
02:20:52 <joe6> alpounet, Is there a way to tell configure to ignore the 2.7 dist and use the 2.8 dist
02:21:17 <joe6> alpounet, this is my configure command: cabal install --configure-option=--with-llvm-prefix="${LLVM_HOME}" --user --extra-lib-dirs="/home/j/local/llvm/lib" --extra-include-dirs="/home/j/local/llvm/include" -v
02:21:21 <joe6> in the llvm directory.
02:21:51 <alpounet> LLVM_HOME refers to /home/j/local/llvm, right ?
02:21:57 <joe6> alpounet, the ghc command above is pretty long. I just posted the initial paths.
02:22:01 <joe6> alpounet, yes
02:22:31 <joe6> echo $LLVM_HOME=/home/j/local/llvm
02:23:04 <joe6> should i do the runhaskell configure and change the configure file?
02:23:13 <alpounet> hm
02:23:44 <alpounet> isn't there any mention of /usr/lib/llvm-2.7 or somesuch in the cabal file ?
02:23:59 <alpounet> thus "asking your system" where to find llvm
02:25:58 <joe6> alpounet, I am just doing a grep in the llvm  dir to check for occurrences of 2.7
02:27:02 <joe6> config.log:LDFLAGS='-L/usr/lib/llvm-2.7/lib  -lpthread -lffi -ldl -lm  -L/home/j/local/llvm:{} '
02:27:44 <alpounet> ok so I guess
02:27:50 <alpounet> since /usr/lib comes first 
02:27:54 <joe6> llvm_version="`$llvm_config --version`"
02:27:59 <alpounet> it just takes it instead of your local version
02:28:03 <joe6> alpounet, yes
02:28:15 <joe6> and I think the llvm_version is coming from the above command of configure.ac
02:28:16 <alpounet> you now have to figure out why it pops up there
02:28:40 <joe6> alpounet, yes,  thanks for the guidance. Now, I think I can figure this out.
02:29:27 <joe6> alpounet, the reason seems to be this line in configure.ac: AC_PATH_PROGS(llvm_config, [llvm-config-2.7 llvm-config],
02:30:45 <alpounet> hm
02:31:06 <alpounet> I guess you also have to bring your "local" llvm binaries in scope in PATH
02:31:32 <alpounet> of course *BEFORE* 2.7's in the order of appearance
02:32:27 <joe6> alpounet, ok, thanks will do that.
02:33:10 <joe6> alpounet, you have no idea how much time and effort your advice has saved me. I have been messing with this since yesterday.
02:33:28 <alpounet> otherwise llvm-config will always refer to 2.7's, so you'll get 2.7 used by configure every time your run it
02:33:40 <alpounet> joe6, your problem isn't solved yet :P
02:34:43 <joe6> alpounet, I have the path and all the other stuff already set.: PATH="${LLVM_HOME}/bin":"${HOME}/local/cpik/bin":"${PATH}"
02:34:51 <joe6> CPPFLAGS="-I${LLVM_HOME}/include/":"${CPPFLAGS}"
02:34:59 <joe6> LDFLAGS="-L${LLVM_HOME/lib}":"{$LDFLAGS}"
02:35:53 <joe6> alpounet, I think was the missing piece of the puzzle and it is..
02:36:01 <joe6> alpounet, the examples are compiling.
02:36:36 <alpounet> cheers!
02:36:47 <alpounet> now try running them, just to check everything's working fine
02:36:58 <joe6> alpounet, yup, happy days. ok, will do that..
02:37:35 <joe6> ./HelloJIT.exe 
02:37:35 <joe6> Hello, JIT!
02:38:57 <alpounet> :)
02:40:11 <rajeshsr> hi all
02:40:50 <pastorn> hello
02:41:43 <rajeshsr> An off-topic discussion, but I think people here can answer it better! Can anyone make a distinction between NP Complete and NP Hard? Does non-decision version of NP Complete becomes NP Hard?
02:42:01 <tg_> NP hard problems are those that are in NP?
02:42:28 <Peaker> NP complete are problems that are reducible from one another. Solve one, solved them all.  NP hard cannot be solved by solving NP complete
02:42:34 <Peaker> (not sure if that's the only difference)
02:42:59 <sipa> NP hard = things that are at least as hard as NP-complete, no?
02:43:08 <rajeshsr> tg_: P is in NP too.
02:43:15 <tg_> NP hard ones don't have the ability to be verified quickly
02:43:20 <rajeshsr> sipa: yes! But what is more in NP-hard?
02:43:22 * hackagebot cryptohash 0.6.3 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.6.3 (VincentHanquez)
02:43:31 <Peaker> tg_, then what's the difference between NP hard and Exp?
02:43:31 <sipa> rajeshsr: exponential things?
02:43:38 <sipa> and worse
02:45:12 <rajeshsr> Well, something like: Given a graph find a TSP route that is optimal, is NP Hard. Find the route which is > k is NP-Complete. So, only decision things that are verifiable in ploynomial time comes in NPC
02:46:11 <rajeshsr> my question, is all the decision things coming under NPC? Is there any decision problem, not verifiable in polynomial time. The distinction is really not so clear to me! :(
02:46:44 <rajeshsr> I meant find route < k :) Obviously we want to reduce the cost!
02:52:43 <Peaker> Ah, I think all problems in NP are reducible to NP hard but not vice versa. Solve one NP complete problem, you solve all the NP complete problems. Solve one NP hard problem, you solve all NP problems.  Exp problems remain in Exp though
02:57:59 <Peaker> http://russell.lums.edu.pk/~archive/Algorithms/algorithms-uiuc/notes/21-nphard.pdf
03:27:41 <savask> Hello. Maybe somebody remembers how I asked about Haskell interpreter first, now I will ask about a compiler :-) I'm not very familiar with compiling techniques, but it looks to me as a top secret how can functional code be transformed to imperative. Can somebody explain me, how are lazy calculations compiled? And why there are no stack overflows when using recursion in Haskell? Are functions just substituted to other functions, or th
03:28:13 <Botje> @where ifp
03:28:13 <lambdabot> I know nothing about ifp.
03:28:14 <Botje> hmm
03:28:24 <Botje> savask: google for 'implementation of functional prgoramming languages'
03:28:33 <Botje> it's a book by SimonPJ and it gives a pretty good overview
03:28:38 <Botje> (and it's freely available online)
03:30:08 <ski> savask : re "no stack overflows when using recursion", you may want to check out "tail calls" and "proper tail recursion" (e.g. as in the language Scheme)
03:31:08 <savask> ski: Hmm. are these "tail calls" just a way of using cycles except of recursion, of what?
03:31:09 <ski> (many implementations of functional (and logic) programming languages using "tail/last call optimization". however in Scheme, the language mandates (a semantic version of) it, so it's not really an optimization anymore)
03:31:35 <ski> yes, using tail calls and tail recursion, iteration is seen as a special case of recursion
03:31:56 <ski> an iterative process can be implemented by a tail-recursive program
03:32:35 <ski> while recursive processes in general are implemented by, in general, not tail-recursive (but generally recursive) programs
03:32:45 <ski> see e.g.
03:32:47 <ski> @where SICP
03:32:47 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
03:32:48 <lambdabot> classes/6.001/abelson-sussman-lectures/>
03:33:44 <savask> So, and what about types then?
03:33:55 <ski> types are unrelated to this
03:34:04 <ski> s/unrelated/orthogonal/
03:35:19 <ski> as an example of implementing an iterative process by a recursive program :
03:35:22 <ski> @src until
03:35:22 <lambdabot> until p f x | p x       = x
03:35:22 <lambdabot>             | otherwise = until p f (f x)
03:36:17 <ski> the recursive call to `until' here is a tail call, since after that call, we need to "do" nothing more, but return the value that that call returned
03:36:58 <savask> Hmm.
03:38:02 <savask> Maybe I don't understand, but how implementing an iterative process by a recursive program will help me understanding how functional progs are translated to imperative?
03:38:13 <ski> savask : in terms of a stack implementation, you can think of the tail-recursive call of `until' as *reusing* the current activition frame on the stack, instead of uslessly keeping it and creating a new one for the call
03:39:15 <ski> well, it will help you to understand that the implementation of `until p f x', using tail-call-optimization, is basically the same as an imperative loop
03:39:34 <savask> Okay, tell more, please.
03:40:11 <ski> (so, we need no special constructs like `while',`for' to implement iteration, if we have tail-call-optimization. we can *define* `while' and `for', &c. as library functions)
03:40:42 <ski> (assuming we at least allow passing functions as arguments to other functions)
03:43:16 <savask> So, as I understand, if we want to make a loop from recursive calls in the "until" function, we just call a needed function without pushing it's value to stack, and when bound condition is approached, we write a result to somewhat place (in RAM, for example).
03:43:38 <savask> *pushing it's address
03:44:40 <ski> (in case it's not obvious, `y = until (\x -> test x) (\x -> transform x) x_0' corresponds more or less to `{T x = x_0; while (!test(x)) {x = transform(x);} y = x;}', if you can read the latter)
03:46:28 <xyz88> hi
03:46:37 <xyz88> [1,2,3,[]]
03:46:39 <ski> savask : yes, for the last function the body calls, instead of creating a new stack/activition frame for it, *reuse* the current frame (possibly enlarging/shrinking it, if this is not a recursive tail call)
03:46:47 <xyz88> why is it non-valid?
03:46:48 <ski> xyz88 : nonsense
03:46:59 <ski> every element of a list must have the same type
03:47:02 <xyz88> ...
03:47:18 <xyz88> ski++
03:47:40 <ski> consider e.g. `[1,2,3,[]] !! n'
03:47:59 <ski> how would you know the type of that expression, if you didn't knew what value `n' was, until run-time ?
03:48:18 <ski> and if you don't know the type of the expression, then how can you do anything with the result value
03:48:21 <ski> ?
03:48:42 <xyz88> beats me, this is my 1st programming language
03:48:51 <ski> ok
03:49:16 <ski> some other (not statically typed) programming languages allow the elements of a particular list to have differing types
03:49:22 <ski> this is called "heterogenous lists"
03:49:31 <ski> Haskell has "homogenous lists"
03:49:32 <kamaji> How can I remove empty lists from a list of lists?
03:49:40 <ski> kamaji : `filter' ?
03:49:41 <kamaji> I tried `filter (==[]) xs`
03:49:45 <quuuux> kamaji: filter (not . null)
03:49:46 <kamaji> it complains about a type error
03:49:47 <kamaji> oh
03:50:03 <kamaji> still type error
03:50:20 <ivanm> then something else must be wrong
03:50:23 <quuuux> kamaji: what's the type of xs?
03:50:33 <kamaji> filter (not . null) [1,2,3]
03:50:35 <xyz88> the book i'm working from says 'which of these lists are non valid, re-write the non-valid ones using cons (:).  So I put [1,2,3]:[]   I don't have the answers book.  Can you confirm that's right?
03:50:37 <kamaji> it's just integers
03:50:40 <kamaji> oh duh
03:50:41 <kamaji> lol
03:50:46 <ivanm> heh
03:50:49 <kamaji> herp derp
03:50:50 <kamaji> thanks...
03:50:53 <ivanm> xyz88: it's wrong
03:50:59 <xyz88> oh...
03:51:04 <ivanm> unless you wanted [[Int]]
03:51:05 <ski> kamaji : `(== [])' is ok, but probably not what you want, since it (needlessly) insists to know how to compare elements of the lists (even though the list `[]' there is empty, so no element comparision should be needed) .. hence `null' is a replacement for `(== [])', without this limitation
03:51:22 <kamaji> ski: ah I see, cheers
03:51:57 <ski> @src null
03:51:57 <lambdabot> null []     = True
03:51:57 <lambdabot> null (_:_)  = False
03:52:22 <ski> kamaji : generally, when checking for the "shape" of a value, it is better to use pattern-matching, than `(==)'
03:52:43 <savask> ski: Thanks for explaining. And what about functions substitutions? Does it substitute all functions into each other, or it calls them?
03:52:55 <xyz88> ski++
03:52:57 <xyz88> thanks again
03:53:30 <sipa> savask: what is the difference?
03:53:57 <quuuux> savask: since Haskell's pure, there isn't (shouldn't be) a difference there
03:54:42 <quuuux> well. Ignoring bottom and stuff
03:55:04 <savask> But maybe there are some speed improvements when substituting, or not...
03:55:19 <ski> xyz88 : in *some* cases, something like "heterogenous lists" *can* be useful (instead of using a tuple or a record as a well-typed replacement) .. for many of these cases, one can actually do them in Haskell, using either "existentially quantified types" or an alternate definition of "lists" -- i'm just mentioning this so that you don't get the impression that Haskell can't handle "heterogenous lists"; in many cases it can, though a bit indirec
03:55:47 <ski> (xyz88 : in any case, learning about how to do that is relatively advanced Haskell :)
03:56:17 <xyz88> ok, ski.  xie xie ni
03:57:17 <ski> savask : the Haskell standard doesn't specify how an implementation must act, in detail .. in principle, it could substitute, or it could use the more efficient environments (especially with by-need thunks)
03:57:32 <savask> Oh.
03:58:12 <savask> Okay, the last question for today :-) How are lazy computations simulated?
03:58:25 <ski> @babel lo en xie xie ni
03:58:25 <lambdabot> Plugin `babel' failed with: Error: Language lo not supported
04:01:02 <raek> @babel zh en xie xie ni
04:01:02 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
04:01:14 <ski> savask : one basic idea is to represent each (activition of an) expression as a "thunk", i.e. as a procedure that when "forced" (asked to compute the value of the expression), will do the relevant computation, and then *cache* the resulting value in the thunk, so that later forcing of the thunk doesn't recompute the value
04:01:23 <quuuux> @quote sprynge
04:01:24 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
04:01:34 <ski> consider
04:01:40 <ski>   square x = x * x
04:01:56 <ski> where we want to evaluate `square (2 + 3)'
04:02:06 <ski> using substitution, this goes like
04:02:11 <ski>      square (2 + 3)
04:02:22 <ski>   =  (2 + 3) * (2 + 3)
04:02:26 <ski>   =  5 * (2 + 3)
04:02:28 <ski>   =  5 * 5
04:02:31 <ski>   =  25
04:02:42 <ski> however, using by-need thunks, it would go like
04:02:48 <ski>      square (2 + 3)
04:03:09 <ski>   =  let x = 2 + 3 in x * x
04:03:17 <ski>   =  let x = 5 in x * x
04:03:19 <ski>   =  let x = 5 in 5 * x
04:03:24 <ski>   =  let x = 5 in 5 * 5
04:03:28 <ski>   =  5 * 5
04:03:31 <ski>   =  25
04:04:21 <ski> so `2 + 3' is not recomputed, instead it is cached in the `let x = ...' part (corresponding to a mutable place in memory, the thunk, which is updated with the value of the thunk, when computing it for the first time)
04:04:43 <ski> (the step from `let x = 5 in 5 * 5' to `5 * 5' corresponds to garbage-collecting the thunk)
04:05:06 <ski> savask : does this ^ help ?
04:05:27 <savask> Ohoh, it looks like a *cough* magic to me.
04:05:57 <ski> for details, check out the fine book Botje mentioned
04:06:00 <savask> So, when function is called it saves it's result somewhere in the RAM?
04:06:04 <ski> yes
04:06:27 <savask> ...and where this result can be used?
04:07:45 <ski> you can possibly implement a thunk of type `a' as initially being a tag together with a procedure that computes a value of type `a', then when it has been computed, the tag is changed to another tag, and the procedure is replaced by the computed value
04:08:11 <ski> .. or you can just replace the procedure with a new procedure which does nothing when invoked, save return the computed value
04:08:54 <ski> savask : look at `square x = x * x', when `square x' is called, `x' is (possibly) not computed yet, but all uses of `x' will reuse the same value, only computing it once
04:09:38 <savask> Can you give another example, please? With list, for example.
04:10:07 <ski> or consider `repeat x = x : repeat x', when `repeat x' is called, `x' is *not* computed at all, instead the thunk is stored in a list .. and later when someone wants the value of one element of the list, `x' will be forced, so that effectively, *all* elements of the list are now computed
04:11:05 <ski> (this is somewhat more complicated by the fact that the recursive call there is also not done when calling `repeat x', but only on demand .. but the same point i wanted to make holds for constructing an array)
04:11:41 <savask> Hmm.
04:11:48 <ski> i.e. you can construct a thunk `x', then pass that to lots of different places in your program, possibly storing it in data-structures, and taking it out, and storing it in other data-structures
04:13:03 <ski> and whenever any one of those references to the thunk are forced, the effect (saving recomputation) is that forcing the thunk through any of the other references is immediate
04:14:13 <ski> e.g. you can construct an array indexed by numbers between `2' and `10000', such that every element at prime index is the thunk `x', and every element at composite index is the thunk `y'
04:14:41 <ski> so, forcing the thunk at any prime index will make the element at every prime index already computed
04:15:01 * ski wonders whether the point is getting across to savask
04:15:14 <savask> I think mine problem is that I don't understand the "thunk" term right.
04:15:30 <ski> "thunk" is an implementation term
04:15:59 <ski> a thunk stands for an expression (with provided values/thunks for free variables of it)
04:16:31 <ski> either the thunk is not computed yet, in which case it will contain a procedure such that invoking that will compute the value
04:17:00 <ski> or the thunk is already computed, in which case the value is stored in the thunk, so you don't need to compute anything
04:17:44 <savask> Oh, no, this is too hard for me now. Thanks for the explanation, I'll read some books, learn lambda-calculus, and then return and reread your speech :-)
04:17:47 <ivanm> preflex: seen sinelaw
04:17:47 <preflex>  sinelaw was last seen on #haskell 24 days, 15 hours, 37 minutes and 47 seconds ago, saying: 'sup cts?
04:18:12 <ski> so, when computing ("forcing") the value of a thunk, you conceptually check whether it has already been computed before -- if so, you just give the value stored
04:18:42 <ski> if not, then you compute the value, and make sure to update the thunk so that any later forcing of the thunk will not recompute the value again
04:20:02 <ski> (i suspect that i'm probably attempting explanation at the wrong level of abstraction, or without enough background knowledge clear, for savask to understand what i was trying to get across)
04:20:25 <savask> But as I understand, thunk should return precalculated value only when it's arguments are the same as when it was calculated before. Or thunks are not functions?
04:20:35 <ski> savask : anyway, the basic concept of a thunk really is a simple concept
04:20:45 <ski> thunks are not functions
04:20:49 <ski> thunks don't take arguments
04:20:56 <savask> So, the are holding static values?
04:21:09 <ski> functions are a kind of values, at the level of the Haskell language
04:21:28 <pozic> savask: let x = 1 + 2 in x -- x is a thunk pointing at two constants. 
04:21:32 <ski> thunks is a way to *implement* "lazy values", so at an implementation level
04:22:03 <pozic> savask: then when x is needed by some computations, that thunk (box) is updated to point at 3.
04:22:21 <pozic> savask: the instructions which say 'add 1 + 2' are replaced with 3.
04:22:40 <pozic> savask: so, to evaluate a thunk in that case is simply returning 3 the next time. 
04:22:55 <savask> pozic: So, we save "2 + 3" in the thunk, and when it's needed we will replace it with 3?
04:23:10 <pozic> savask: 5
04:23:15 <savask> Oh
04:23:15 <pozic> savask: yes
04:23:22 <savask> epic fail
04:23:23 <ski> savask : you typically *don't* get general memoization of functions in Haskell (i.e. where functions remember their results for some/all arguments, to avoid recomputation)
04:23:33 <kamaji> hms, why can't I or a list of bools by doing "foldl (or) [True, True]"
04:23:42 <pozic> savask: memoization is indeed something completely unrelated. 
04:23:59 <ski> savask : consider `let x = 2 + 3 in x * x' in my "trace" above
04:24:32 <pozic> There we have a box containing two pointers to the same box. 
04:24:38 <ski> savask : let's say first the `x' left to the `*' is forced, this refers to a thunk `x = 2 + 3', which is forced (by computing `2 + 3' to `5')
04:25:08 <ski> savask : and the thunk is automatically updated with this value : `let x = 5 in x * x'
04:25:29 <ski> savask : and then the forcing of the thunk results in the value `5' : `let x = 5 in 5 * 5'
04:25:39 <pozic> savask: what we are describing is how you can imagine it works; it might work completely differently. 
04:25:59 <ski> next the `x' to the right is forced, which in this cases is just fetching the (cached) value `5', so we get `let x = 5 in 5 * 5'
04:26:07 <savask> So, a thunk is a "changeable constant"
04:26:15 <ski> yes
04:26:39 <ski> since `2 + 3' represents the same value as `5', it doesn't matter if we change from the former to the latter
04:26:39 <savask> Okay... it's like a little lazy piece.
04:26:50 <ski> it still represents the same value/constant
04:28:06 <ski> (savask : if you are familiar with splay trees, this is somewhat familiar. accessing (forcing) the thunk may change the representation of the thunk, as long as the observed behaviour (modulo efficiency, which is what we're trying to improve) is the same)
04:28:27 <ski> (er s/familiar/similar/)
04:28:55 <savask> You think good about me... Splay trees, heh.
04:30:13 * ski idly ponders what it would mean (for a person) to be similar to a splay tree
04:30:37 <savask> So, how are lists represented as thunks? [not haskell syntax] like (a = thunk 1):(b = thunk (a+1)):...
04:31:12 <savask> Is it so?
04:32:09 <ski> more like `<thunk: <thunk 0>:<thunk: <thunk 1>:<thunk: ..<thunk: []>..>>>'
04:32:35 <ski> i.e., not only the elements, but each cell of a list (in general) is a thunk)
04:32:44 <ski> (and each cell contains the next cell)
04:34:05 <ski> consider e.g. the following trace
04:34:26 <ski>      take 4 (map square [0 ..])
04:34:44 <ski>   =  take 4 (map square (enumFrom 0))
04:34:52 <ski>   =  take 4 (map square (0 : enumFrom 1))
04:35:06 <ski>   =  take 4 (square 0 : map square (enumFrom 1))
04:35:16 <ski>   =  square 0 : take 3 (map square (enumFrom 1))
04:35:22 <ski>   =  square 0 : take 3 (map square (1 : enumFrom 2))
04:35:31 <ski>   =  square 0 : take 3 (square 1 : map square (enumFrom 2))
04:35:44 <ski>   =  square 0 : square 1 : take 2 (map square (enumFrom 2))
04:35:52 <ski>   =  square 0 : square 1 : take 2 (map square (2 : enumFrom 3))
04:36:01 <ski>   =  square 0 : square 1 : take 2 (square 2 : map square (enumFrom 3))
04:36:10 <ski>   =  square 0 : square 1 : square 2 : take 1 (map square (enumFrom 3))
04:36:18 <ski>   =  square 0 : square 1 : square 2 : take 1 (map square (3 : enumFrom 4))
04:36:28 <ski>   =  square 0 : square 1 : square 2 : take 1 (square 3 : map square (enumFrom 4))
04:36:38 <ski>   =  square 0 : square 1 : square 2 : square 3 : take 0 (map square (enumFrom 4))
04:36:42 <ski>   =  square 0 : square 1 : square 2 : square 3 : []
04:37:21 <ski> this is what would be computed if e.g. we would try to compute the length of the original list
04:37:37 <ski> (computing the length of the lists needs to traverse the list, to find the end `[]')
04:38:38 <ski> if we were trying to `show' the list, then after generating the `square 0 :', `square 0' would be computed, and converted to a string, and then the same with `square 1 :' after that was computed above, &c.
04:38:46 <taotree> Any help on this compile error regarding rigid type mismatch?   http://hpaste.org/paste/44130/type_error_annotation#p44131
04:39:19 <savask> ski: This is okay, but why `<thunk: <thunk 0>:<thunk: <thunk 1>:<thunk: ..<thunk: []>..>>>'?
04:39:28 <ski> savask : so `take 4 (map square [0 ..])' is a thunk, that when forced evaluates to `square 0 : take 3 (map square (enumFrom 1))', where `square 0' and `take 3 (map square (enumFrom 1))' are two new thunks
04:40:13 <ski> savask : if we're only checking whether the list is empty or not, then the computation will stop above at step `square 0 : take 3 (map square (enumFrom 1))' (which is what forcing the first main thunk gives us)
04:40:14 <savask> Aahh
04:40:40 <ski> *only* if we then continue forcing the new thunk `take 3 (map square (enumFrom 1))' does the computation proceed as above
04:41:14 <ski> also, before forcing this, we can possibly do some other computation (e.g. converting the element to a string, which needs forcing `square 0')
04:41:28 <dolio> taotree: The return type of multiPipes specifies that all the TChan as in the list it returns have the same 'a', which is essentially passed in as an argument.
04:43:00 <ski> savask : so, in this case, the main `<thunk: ...>' is generating a value '<thunk 0> : <thunk: ...>' where `<thunk: ...>' in this case is `take 3 (map square (enumFrom 1))' .. hence the nested thunks
04:43:05 <gio123> ski
04:43:05 <dolio> However, what you're using to generate them is a bunch of existentially quantified 'a's, which do not necessarily match each other, or the universally quantified 'a'.
04:43:07 <gio123> :(
04:43:54 <taotree> dolio, right... they aren't the same
04:44:42 <savask> ski: If we will look deeper to implementing thunks, does this mean that a compiled Haskell program should have a little thunk-interpreter inside it?
04:45:01 <ski> if you want to call it that ..
04:45:22 <taotree> dolio, not sure how to resolve it though...
04:45:31 <ski> also, the above is only just a crude simple explanation of what is "essentially" happening in things like GHC and Hugs
04:45:59 <ski> the actual detail is more complicated
04:46:13 <dolio> taotree: Well, I don't know what you want to do. Just convert all the functions to chans? Then you need to return a list of existentially quantified chans or something.
04:46:23 <savask> ski: Okay, thanks :-) Hope that book will explain this in details.
04:46:37 <ski> savask : but the above model suffices to reason about how many thunks are forced
04:46:52 <ski> (of course optimizations can change that)
04:47:59 <taotree> dolio, backing up... doesn't the return type of multiPipes already return a list of exist. quant. chans?
04:48:11 <dolio> No.
04:48:21 <dolio> @type map
04:48:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:48:34 <dolio> Is the return type of map existentially quantified?
04:49:02 <dolio> @type fromInteger
04:49:02 <lambdabot> forall a. (Num a) => Integer -> a
04:49:05 <dolio> Or that?
04:50:21 <ski> @hoogle multiPipes
04:50:22 <lambdabot> No results found
04:50:26 <taotree> sorry, I'm new to the exquant thing... just trying to understand it
04:50:53 <dolio> Well, the answer to both my questions is, "no." :)
04:51:20 <dolio> fromIntegers type specifies that it can return any type the caller wants.
04:52:09 <taotree> so I need to set this up somehow so it can return an eq list?
04:52:12 <dolio> If it were Integer -> (exists a. Num a => a), it would return whatever Num type it wanted, and I would not know what it is.
04:52:43 <ski> taotree : to implement `multiPipes :: forall a. (OutputChannels a) => [OCWrap] -> IO [TChan a]', you must be prepared of the caller choosing any type `a' at all, so you should make sure to give an `IO'-action with result of type `[TChan a]', where the type `a' is chosen by the caller
04:53:19 <Peaker> I guess it would be correct to say that inside the *definition* of multiPipes, the "a" type is existentially quantified?
04:53:21 <taotree> ski, that sounds right
04:54:17 <ski> taotree : the `[OCWrap]' argument that you get from the caller is basically `[exists x. OutputChannels x *> TChan x -> IO ()]', i.e. a list where the caller may have chosen a different type `x' for each element, which then has type `TChan x -> ()', and the only thing you know about each `x' is that it is in the class `OutputChannels'
04:54:42 <taotree> ski, yes
04:54:57 <ski> taotree : as a thought experiment, if we assume that the `[OCWrap]' was actually just `OCWrap' (so no list), i.e.
04:54:57 <dolio> Peaker: I think 'rigid' which GHC uses, is probably less likely to cause confusion.
04:55:12 <ski>   multiPipes :: forall a. (OutputChannels a) => OCWrap -> IO [TChan a]
04:55:18 <ski> is then basically
04:55:29 <ski>   multiPipes :: forall a. (OutputChannels a) => (exists x. OutputChannels x *> TChan x -> IO ()) -> IO [TChan a]
04:55:34 <ski> which is basically
04:55:51 <ski>   multiPipes :: forall a x. (OutputChannels a,OutputChannels x) => (TChan x -> IO ()) -> IO [TChan a]
04:56:12 <ski> so, here is may be clearer that the caller will choose both the type `a' and the type 'x'
04:57:46 <ski> taotree : i'm not sure how much this helps in explaining the error, or in giving you a hint of what to do instead. i was just trying to explain better what the type signature that you had written means
04:58:18 <taotree> ok, but taking your approach, I get the same error with:
04:58:19 <taotree> multiPipes :: forall a x. (OutputChannels a, OutputChannels x) => (TChan x -> IO()) -> IO (TChan a)
04:58:19 <taotree> multiPipes x = newChan x
04:58:27 <Peaker> dolio, would there be a "formal" difference?
04:58:31 <ski> yes, of course
04:58:54 <ski> taotree : the error is preserved in your version, and in my "unwrapped" version
04:59:28 <ski> (taotree : i don't know what you're trying to do, so i don't know how to fix the error. i merely was trying to explain the error)
04:59:40 <taotree> ah, ok
04:59:51 <Peaker> dolio, I guess maybe both rigid and existential are "positive" type variables, but "rigid" is a param and existential is a product?
05:00:15 <ddarius_> There's a latex glove on the floor of my living room.
05:00:38 <ski> (taotree : and the error is that calling `newChan' there only works if `a' and `x' is the same type .. but the type signature says that the caller may choose `a' and `x' arbitrarily, e.g. to be *different* types)
05:02:23 <ddarius> Peaker: It wouldn't be correct to say that.  The difference is introducing a universal and eliminating one.
05:02:36 <ski> Peaker : universals and existentials can generate rigids/skolems, as well as "ordinary" type variables (ones that can be instantiated to any concrete type)
05:03:06 <ski> the difference is the polarity, as ddarius says
05:03:25 <ddarius> The variable usage is dual but, in the end, you need to actually produce a universal.  In a classical logic, you could use logical negation to more strongly witness this duality and reduce one to the other if you wanted.
05:14:15 <dolio> Peaker: When you open an existential, the type variable is rigid for you. When you're implementing a universal, it's also rigid for you.
05:14:36 <Peaker> so "rigid" is the word I should use
05:15:53 * ski uses "skolem", mostly
05:16:07 <ski> (i think i've seen some people use "eigenvariable", as well ..)
05:16:12 <Olathe> You can try with a different scansize than width and see what happens.
05:16:28 <Olathe> id~-3;3~
05:16:31 <dolio> Yeah, I think GHC 7 switched to calling them skolem variables/constants/something.
05:17:07 <ddarius> What might help motivate the term "rigid" is that you can only universally quantify a variable if it has been treated like a constant.  I.e. universally quantification introduces a fresh constant.
05:17:19 <ski> a skolem constant acts like a new, abstract type, wrt type checking
05:17:40 * ddarius highly recommends looking at how lambdaProlog's module system works.
05:18:07 <ski> (so implementing `forall a. [a] -> [a]' is then similar to implementing `[A] -> [A]', for some unknown type `A')
05:18:16 <Saizan> any recommended reference on lambdaProlog?
05:18:21 * ski seconds ddarius recommendation
05:19:35 <ski> (s/universally quantification introduces/universally quantification *introduction* introduces/)
05:20:41 <ddarius> Saizan: I recommend Dale Miller's page: http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/recentpapers.html
05:23:48 <Saizan> impressive.
05:26:50 <ski> @where lambdaProlog
05:26:50 <lambdabot> I know nothing about lambdaprolog.
05:27:00 <ski> @where+ lambdaProlog <http://www.lix.polytechnique.fr/~dale/lProlog/>
05:27:00 <lambdabot> Done.
05:33:15 <minn> Are there accessible resources on recursive types and fixed points lying around? For instance, that would give more coverage than "Types and Programming Languages"?
05:35:32 <kamaji> </quit
05:35:34 <kamaji> oops :D
05:47:03 <taotree> thanks for the help previously... I figured it out. I was using psuedo-hetero list as input to the function, but the output was a normal list, so of course it couldn't work. Answer is:
05:47:04 <taotree> multiPipes :: [OCWrap] -> [Wrapper]
05:47:04 <taotree> multiPipes xs = map (\(OCWrap x) -> Wrapper (newChan x)) xs -- Error
05:48:28 <taotree> Where [Wrapper] is another pseudo-hetero list thing.
05:48:41 <ddarius> http://www.lix.polytechnique.fr/Labo/Dale.Miller/humor/men-women.txt  I like the fifth one.
05:50:57 <merijn> Right, I need some advice on how to approach this problem: I have several types of things (say Foo, Bar and Baz) now I want to get a list of all permutations consisting of one Foo, one Bar and one Baz from a set of Foo's, Bar's and Baz's
05:51:40 <Botje> liftM3 f foos bars bazs
05:51:59 <Botje> where f either accepts a Foo, Bar, and Baz
05:52:09 <Botje> if you just want triples, substitute (,,) for f
05:52:25 <merijn> :t liftM3
05:52:26 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
05:53:04 <Botje> merijn: liftM3 (,,) .. is similar to [ (x,y,z) | x <- foos, y <- bars, z <- bazs ]
05:53:38 <merijn> Botje: Is there a way to extend this to less practical numbers of types (say, instead of three types Foo, Bar, Baz I have 12 types of thing)
05:53:43 <Twey> > liftM3 (,,) [1 .. 5] ['a' .. 'f'] [10 .. 12]
05:53:43 <lambdabot>   [(1,'a',10),(1,'a',11),(1,'a',12),(1,'b',10),(1,'b',11),(1,'b',12),(1,'c',1...
05:54:09 <Botje> merijn: are they the same type?
05:54:32 <Botje> merijn: and liftM only goes up to 7, sadly
05:55:16 <dolio> Yes, I can't count how many times I've needed liftM8.
05:55:29 <Twey> Heh
05:55:39 <Botje> is it zero or less? :P
05:55:57 <merijn> Botje: I don't have any concrete Haskell yet. I could implement a generic "data Thing = Thing ThingType", but then I wouldn't know how to generate permutations given a list of those
05:55:57 <hpc> hey, that was my joke
05:56:02 * Twey chuckles.
05:56:17 <hpc> <3 the set of counting numbers
05:56:35 <merijn> dolio: I'm open to other suggestions on how to generate permutations
05:57:37 <hpc> liftM3 f x y z is also f <$> x <*> y <*> z
05:57:39 <dolio> If you really need that many, then ap lets you lift arbitrary numbers of things.
05:57:47 <hpc> or ap
05:57:48 <merijn> :t ap
05:57:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:58:01 <hpc> ap = (<*>) for sane implementations
05:58:09 <dolio> f `liftM` x `ap` y `ap` z ...
05:58:30 <merijn> :t (<*>)
05:58:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:59:13 <tg_> that's like
05:59:15 <tg_> almost identical
05:59:23 <tg_> s/m/f/
05:59:27 <ddarius> Joshua Hodas became a lawyer...
06:00:18 <merijn> :t pure
06:00:18 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
06:00:55 <hpc> @pl \x -> (pure f <*> x)
06:00:55 <lambdabot> (pure f <*>)
06:01:07 <hpc> @pl \f x -> (pure f <*> x)
06:01:07 <lambdabot> (<*>) . pure
06:01:14 <merijn> Ok, I think I know how I can get what I want using <$> and <*>
06:01:16 <hpc> (that rule should be added to pl)
06:01:38 <hpc> merijn: liftMx f x1 x2 x... =
06:01:45 <merijn> Actually will probably saner too
06:01:46 <hpc> f <$> x1 <*> x2 <*> ...
06:01:54 <aavogt> > sequence ["abc","def","h"]
06:01:54 <hpc> you can expand it as far as you like with <*>
06:01:55 <lambdabot>   ["adh","aeh","afh","bdh","beh","bfh","cdh","ceh","cfh"]
06:02:20 <aavogt> this will work if you can work out getting all those types to be the same
06:02:30 <merijn> Instead of computing the permutations themselves I'll just directly compute the comparison value of each permutation which is what I wanted anyway
06:04:17 <merijn> aavogt: Well, conceptually all the things are the same type. The only difference between a Foo and a Bar is that I cannot have two Foo's but I can have a Foo and a Bar.
06:05:13 <aavogt> you can use this sequence instead http://hpaste.org/44132/hsequence
06:05:47 <merijn> aavogt: I'll take a look
06:06:10 <aavogt> and   data HNil = HNil; data HCons a b = HCons a b
06:07:41 <aavogt> so if you pick the  f = [], then you get to go from a type like   ([a],([b],([c],()))) -> [(a,(b,(c,())))]
06:11:25 <ski> merijn : btw,  f <$> x <*> y <*> z  is the same as  pure f <*> x <*> y <*> z  and similarly with  f `liftM` x `ap` y `ap` z  and  return f `ap` x `ap` y `ap` z
06:11:28 <ski> (also, this doesn't give you *permutations* at all)
06:14:21 <aristid> and in Apply, you only get f <$> x <*> y <*> z, but no pure :)
06:15:17 <ski> (`Apply' ?)
06:15:53 <merijn> ski: No, but if f returns a set of x y z and it's in the list monad it should end up with a set of permutations, no?
06:16:05 <ski> no
06:16:29 <ski> > return (,,) `ap` "01" `ap` "ab" `ap` "+-"
06:16:30 <lambdabot>   [('0','a','+'),('0','a','-'),('0','b','+'),('0','b','-'),('1','a','+'),('1'...
06:16:35 <ddarius> Saizan: So the most readable account of the way modules are approached in lambdaProlog is probably in Joshua Hodas' thesis on Lolli.
06:16:36 <ski> this is not permutations
06:16:48 <merijn> ski: Why not?
06:16:56 <ski> > permutations "abc"
06:16:57 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
06:17:00 <ski> that's permutations
06:17:08 <merijn> Keep in mind there are two common definitions of permutations
06:17:40 <merijn> Not to mention, the common english definition which I was using
06:17:45 <ski> one in terms of automorphisms, and one in terms of reordering a list ?
06:18:02 <merijn> According to my english dictionary "one of several possible variations, in which a set or number of things can be ordered or arranged"
06:18:29 <ski> yes, the set `{a,b,c}' can be ordered in six ways
06:18:43 <ski> (total orders)
06:19:23 <merijn> permutations abc is on a sequence, I wanted permutations of a set. i.e. all possible sets containing one Foo, one Bar, one Baz
06:19:46 <ski> well, that is not permutations of a set. that is an operations on three sets
06:20:21 <ski> probably what you're after is the term "cartesian product"
06:20:39 <merijn> ski: Yeah, if you make Foo, Bar and Baz actual separate sets you are right
06:21:24 <ski> if `Foo' is `{0,1}' and `Bar' is `{a,b}' and `Baz' is `{+,-}', then the cartesian product of those three sets is basically the  [('0','a','+'),...]  one above (using a specific representation of the set, as a list)
06:21:48 <ski> > sequence ["01","ab","+-"]
06:21:48 <lambdabot>   ["0a+","0a-","0b+","0b-","1a+","1a-","1b+","1b-"]
06:21:56 <Tomsik> no u
06:22:12 <ski> `sequence' in the list monad basically implements cartesian products of the corresponding sets
06:22:21 <ddarius> There is exactly one set containing Foo, Bar, Baz and nothing else and it is the same as the set containing two Foos and Bar and Baz and nothing else.
06:22:38 <Heffalump> Name Server:NS0.BLACKCATNETWORKS.CO.UK
06:22:38 <Heffalump> > Name Server:NS1.BLACKCATNETWORKS.CO.UK
06:22:38 <Heffalump> > Name Server:URCHIN.EARTH.LI
06:22:39 <lambdabot>   Not in scope: data constructor `Name'Not in scope: data constructor `Server...
06:22:39 <lambdabot>   Not in scope: data constructor `Name'Not in scope: data constructor `Server...
06:22:44 <merijn> But my original approach didn't separate them into separate sets, since they are subtypes of a same common type. To make it less ridiculously abstract, I'm trying to calculate an optimum combination of items, so I wanted permutations of sets of items obeying the constraint that you can't have multiple items in the same slot...
06:22:49 <ski> (and `(<*>)' and `ap' in the examples above also compute cartesian products)
06:23:56 <ski> merijn : ok, so you have cartesian product of subsets, then (not a very big difference, here)
06:24:30 <Tomsik> ddarius: Is that even expressible in a formalized language, that a set contains two elements that are the same?
06:24:50 <ski> Tomsik : `{Foo,Bar,Baz} = {Foo,Foo,Bar,Baz}'
06:25:01 <merijn> Tomsik: Maybe not, but as I said I was not using a formalized definition of permutation, I was using the english definition
06:25:12 <Tomsik> ski: that's some informal notation :p
06:25:21 <merijn> And I still do not see how that use is inconsistent with my case
06:25:48 <Tomsik> Sorry, I'm just walkin' in mid-discussion and bein' a rude guy :p
06:26:04 <ski> merijn : well, maybe you're right that there's an alternative sense of the word "permutation" in english. in any case, the sense you cited seemed to me to correspond to the mathematical concept of `permutation' which i was using ..
06:27:14 <ddarius> ski: It's the same sense, the only potential difference is that you may have different levels of equality, like Norman Wildberger's account of sets.
06:27:24 <Tomsik> <merijn> But my original approach didn't separate them into separate sets, since they are subtypes of a same common type. To make it less ridiculously abstract, I'm trying to calculate an optimum combination of items, so I wanted permutations of sets of items obeying the constraint that you can't have multiple items in the same slot...
06:27:28 <Tomsik> isn't that "subsets"
06:27:40 <Tomsik> or variations or something
06:27:46 <ski> (i.e. "one of .. a set or number of things can be ordered or arranged" seems to me to talk about the ways one can linearly order the elements of a set .. which for the set `{a,b,c}' e.g. is possible in six ways)
06:28:32 <merijn> ski: The two (mathematical) uses I know of have the difference is that in one permutations of "abc" length 3  "aaa" is valid and in the other it is not (since it does not contain all elements)
06:28:39 <ski> (ddarius : yes, the cited definitions seemed the same sense. i was only stating that maybe there's another sense that means "cartesian product" .. i don't know)
06:29:35 <merijn> The latter I guess may not be in common use? It was covered in high school and first year of university here, but on the interwebs it appears to be very uncommon...
06:29:43 <merijn> Eh, the former I mean
06:29:54 <ski> merijn : well, in the one in which `"aaa"' is valid, i think the usual term is "combinations"
06:30:11 <merijn> ski: Maybe translation error then?
06:30:11 <ski> > replicateM 3 "ab"
06:30:12 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
06:30:16 <ski> that's combinations
06:30:52 <merijn> In Dutch we call both "permutaties" (which obviously translates to permutation)
06:31:40 <merijn> This is why I stopped learning the Dutch names for mathematical concepts :p
06:32:01 <merijn> It only gets me hopelessly confused in English :p
06:32:44 <aavogt> hmm, is this dutch http://nl.wikipedia.org/wiki/Combinatie_(wiskunde) ?
06:33:11 <aristid> aavogt: of course it's dutch. it's on nl.wikipedia.org...
06:33:16 <ski> > replicateM 2 pick `evalAffine` "abc" :: [String]
06:33:17 <lambdabot>   ["ab","ac","ba","bc","ca","cb"]
06:33:21 <ski> that's permutations
06:33:40 <ski> (in a more general sense)
06:34:06 <aavogt> aristid: well it suggests that some Dutch people don't use the same word for permutations and combinations
06:34:10 <ski> > replicateM 3 pick `evalAffine` "abc" :: [String]  -- in the more restricted sense
06:34:11 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
06:34:14 <aristid> aavogt: yes.
06:34:22 <merijn> aavogt: Yes, but that page also uses the term "permutaties" and has a reference to permutations
06:35:11 <aristid> in german, i think the words are different. Permutation und Kombination (so the only difference to english is capitalisation and K instead of C, and of course pronunciation)
06:36:15 <merijn> aavogt: I've heard combinations used as well (forgot about it until someone mentioned it), in my memory they were used somewhat interchangeably. Then again, I'm not studying math so maybe the math people are less lax
06:36:46 <aavogt> you'd think that understanding english and german would help to understand dutch, but only slightly
06:37:22 <aavogt> like mogelijkheden -> moeglischkeiten or something
06:37:54 <merijn> The subject is usually called "combinatoriek" but the resulting sets of "n over k" were referred to as permutations in my classes (and on that wiki page)
06:40:23 <sgronblo> aavogt: it doesnt?
06:40:44 <aavogt> it does if you squint to ignore the odd orthography
06:42:20 <merijn> Understanding German is relatively doable if you know Dutch, and afaik the reverse is also true
06:42:27 <ski> "The set of all k-combinations of a set S is sometimes denoted by `S over k'." :)
06:42:51 <rwbarton> how about "S choose k"?
06:43:25 <merijn> Anyhoo, I think we've covered any remotely interesting parts of this, so back to work for me :p
06:43:54 <ski> (um, right, of course the `replicateM 3 "ab"' is "combinations with *repetitions*")
06:44:19 <rwbarton> interesting about "permutation", btw.  I often hear/read people use "permutation" to mean something like a word from an alphabet, and never thought it might be due to a difference between languages
06:46:04 <rwbarton> I'm curious now if you took a poll among, say, professional Dutch mathematicians, how they use the term "permutaties"
06:46:35 <merijn> I'll go ask some of my friends who are taking math and see what they think next time I see them
06:58:41 <sshc> Huh, 'subtract' is actually `flip (-)`
06:58:52 <sshc> With emphasis on "flip"
06:59:03 <sshc> I was unaware.
06:59:34 <aavogt> sections with - are a bit odd
06:59:41 <aavogt> > (- 5) 2
06:59:42 <lambdabot>   -5
06:59:48 <aavogt> > ( 5 -) 2
06:59:49 <lambdabot>   3
06:59:54 <aavogt> > (subtract 5) 2
06:59:55 <lambdabot>   -3
07:00:12 <aavogt> and obviously the first one shouldn't have worked :p
07:00:44 <Claudius1aximus> :t ((- 5), (5 -), subtract 5)
07:00:44 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1 -> t1, t2 -> t2)
07:01:26 <sshc> I thought subtract was defined as (-), not flip (-)
07:01:29 <sshc> > (-5) 2
07:01:30 <lambdabot>   -5
07:01:41 <sshc> > (-5)
07:01:42 <lambdabot>   -5
07:01:46 <sshc> :t (-5)
07:01:47 <lambdabot> forall a. (Num a) => a
07:01:51 <ClaudiusMaximus> @src subtract
07:01:51 <lambdabot> subtract x y = y - x
07:01:54 <sshc> let a = (-5) in a 2
07:01:58 <sshc> > let a = (-5) in a 2
07:01:59 <lambdabot>   -5
07:02:06 <aavogt> well it's that way because it covers the case stolen by  (- 5)
07:02:14 <ClaudiusMaximus> @instances Num
07:02:15 <lambdabot> Double, Float, Int, Integer
07:02:38 <aavogt> or maybe people read it as      subtract 5 {- from -} 2
07:04:08 <merijn> I'm guessing without lambdabot's evil "(- 5) 2" is a type error?
07:04:22 <byorgey> > ((+2) + (*3)) 6
07:04:23 <lambdabot>   26
07:04:27 <byorgey> merijn: yes
07:04:37 <sshc> :t magic
07:04:38 <lambdabot> forall a. (Num a) => a
07:04:40 <aavogt> it's a   no instance for  Num (a -> b) .. or so
07:04:48 <sshc> > magic 3
07:04:50 <lambdabot>   -5
07:04:51 <aavogt> > fix magic
07:04:53 <lambdabot>   -5
07:04:58 <merijn> Making numbers an instance of functor is evil
07:05:12 <byorgey> no, it's making functions an instance of Num
07:05:13 <ClaudiusMaximus> is it just me that uses `flip` infix?   kinda like: mapM_ (`with` (hPutBuf h `flip` sizeOf (0::Float))) [1 .. (10 :: Float)]
07:05:16 <sshc> > magic "_"
07:05:17 <byorgey> and I don't see what's so evil about it
07:05:18 <lambdabot>   -5
07:05:31 <sshc> clever
07:05:51 <sshc> :t magic
07:05:52 <lambdabot> forall a. (Num a) => a
07:06:01 <sshc> > let a = (-2) in a 1
07:06:02 <lambdabot>   -2
07:06:06 <byorgey> > ((+) + (*)) 3 6
07:06:06 <lambdabot>   27
07:06:12 <sshc> It ignores the paramet rthough
07:06:18 <sshc> Instead of actually subtracting
07:06:30 <ClaudiusMaximus> > 1 2 3 4 5
07:06:31 <lambdabot>   1
07:06:40 <byorgey> sshc: a numeric constant considered as a function is the constant function that returns that number
07:06:41 <rwbarton> lambdabot: an excellent instructional tool
07:06:50 <merijn> sshc: Numbers are functions which return themselves in lambdabot
07:07:01 <byorgey> so you can do things like
07:07:14 <byorgey> > ((+2) + 6 + (*3)) 5
07:07:15 <lambdabot>   28
07:07:19 <parcs> and
07:07:24 <byorgey> which is (5+2) + 6 + (5*3)
07:07:29 <parcs> > sin^2 + cos^2 $ pi
07:07:30 <lambdabot>   1.0
07:07:46 <byorgey> oh, nice example
07:08:00 <aavogt> @ty (**)
07:08:01 <lambdabot> forall a. (Floating a) => a -> a -> a
07:08:06 <byorgey> @check sin^2 + cos^2 == 1
07:08:06 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:08:06 <lambdabot>    arising from a use of `GHC.Real.^...
07:08:11 <sshc> Oh, huh
07:08:13 <sshc> I see, thanks
07:08:24 <aristid> ghc seems to consider mptcs with only one foreign type to be an mptc oO
07:08:33 <aristid> *to be an orphan
07:08:46 <sshc> THat's quite odd 
07:08:57 <byorgey> sshc: what is?
07:08:58 <sshc> I don't see the advantages of treating numbers as consttant functions
07:09:12 <byorgey> what else would you treat them as?
07:09:17 <aavogt> the orphanhood analogy seems to be broken
07:09:49 <byorgey> > (length + 2) [1,2,3]
07:09:50 <lambdabot>   5
07:10:11 <byorgey> if you treat them as functions which add themselves, or whatever, then you can only use functions from numbers
07:10:18 <byorgey> but this way you can use functions from any type
07:10:22 <aavogt> > (sum / (fromIntegral . length)) [1,2,3,4,5]
07:10:23 <pastorn> byorgey: wtf was that?
07:10:24 <lambdabot>   3.0
07:10:33 <sshc> byorgey: Functions aren't numbers
07:10:38 <byorgey> pastorn: I computed two more than the length of a list
07:10:57 <ddarius> "Not to perambulate the corridors in the hours of repose in the boots of ascension."
07:11:08 <pastorn> byorgey: how?
07:11:13 <aavogt> aristid: how many parents does an instance of a MPTC have?
07:11:21 <pastorn> looks like you cheated...
07:11:23 <byorgey> pastorn: lambdabot has an instance  Num a => Num (e -> a)
07:11:39 <byorgey> pastorn: which does arithmetic on functions by doing arithmetic pointwise on their results
07:11:49 <byorgey> pastorn: and treats numeric constants as constant functions
07:11:51 <pastorn> ugh...
07:12:04 <byorgey> I don't see why everyone is so put off by this.  it's quite beautiful.
07:12:17 <byorgey> it's the Num class that's ugly.
07:12:23 <aristid> aavogt: at least two.
07:12:52 <merijn> byorgey: It doesn't make errors more clear for new people here. Especially since they're not numbers in GHC
07:13:07 <byorgey> merijn: well, I agree with you there.
07:13:58 <byorgey> Haskell ought to have "language levels" like DrScheme
07:14:34 <aavogt> @gogle helium haskell
07:14:35 <lambdabot> http://en.wikipedia.org/wiki/Helium_(Haskell)
07:14:35 <lambdabot> Title: Helium (Haskell) - Wikipedia, the free encyclopedia
07:14:42 <sm> byorgey: +1
07:14:46 <Saizan> lambdabot has always been a place where newbies were exposed to such brain explosions ::)
07:15:02 <ddarius> Saizan is an alien!
07:15:22 <byorgey> ::O
07:15:37 <Saizan> look, byorgey too!
07:15:51 <byorgey> I thought I was the only one
07:16:27 <shepheb> agreed, and then we could have Caleskell-style fully general definitions of functions, monad comprehensions, etc.
07:19:24 <ddarius> "Efficient Radiosity for Daylight Simulation in Closed Environments"
07:21:03 <byorgey> if the environments are closed, where's the daylight coming from?
07:21:27 <Botje> maybe they have windows :P
07:21:40 <aristid> Botje: then it's not really closed, is it? :)
07:22:23 <Botje> aristid: depends how you define 'closed'
07:22:34 <Botje> airproof?
07:22:40 <byorgey> perhaps they just mean that the environments contain their boundaries
07:23:52 <aavogt> the environments contain the sun
07:24:57 * hackagebot temporal-media 0.1.1 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.1.1 (AntonKholomiov)
07:26:49 <ddarius> aavogt: Is the term "daylight" still appropriate then?
07:30:33 <jeltsch> Has the SSH fingerprint of the Haskell community server changed recently?
07:30:43 <Zao> jeltsch: Yes.
07:30:56 <jeltsch> Zao: Is the fingerprint published somewhere?
07:30:59 <Zao> jeltsch: Yes.
07:31:02 <jeltsch> Where?
07:31:07 <Zao> jeltsch: It was mentioned on -cafe.
07:31:11 <Zao> I'm trying to find the thread.
07:31:20 <Zao> Slow mailbox is slow.
07:32:14 <Zao> Or possibly another list, /me is lost.
07:32:36 <Zao> http://www.mail-archive.com/haskell-cafe@haskell.org/msg87347.html
07:32:38 <Zao> jeltsch: ^
07:33:00 <Zao> ( http://www.mail-archive.com/haskell-cafe@haskell.org/msg87328.html if you want Duncan's original mail )
07:33:20 <jeltsch> Zao: Thank you.
07:34:56 <ColonelJ> Anyone here used Bluespec?
07:37:00 * hackagebot temporal-media 0.2.0 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.2.0 (AntonKholomiov)
07:40:20 <stepkut> accel: IMO, happstack :)
07:42:05 <jeltsch> Hmm, when trying to log into community.haskell.org via SSH, I get Permission denied (publickey).
07:42:14 <jeltsch> Did anyone else experience this problem?
07:42:56 <Zao> jeltsch: Did they migrate keys automagically?
07:43:01 <Saizan> jeltsch: some keys couldn't be restored, you should mail support
07:43:14 <Zao> jeltsch: Considering it was due to prior malicious entry, I'd reckon there's a lot missing.
07:44:51 <Saizan> support -at- community.haskell.org
07:47:32 <byorgey> jeltsch: see http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85899/focus=86477
07:50:52 <jeltsch> byorgey: The SSH fingerprint stuff is a different issue (which I just had solved).
07:59:26 <Saizan> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85899/focus=86477 <- the relevant message is this one
08:00:01 <aavogt> who to email about restoring my account there? ross, duncan?
08:01:13 * aavogt thinks he should have been in the category of those people whose keys match the original ones
08:01:29 <Saizan> see my link :)
08:02:39 <aavogt> ah it's at support <at> community.haskell.org
08:12:03 <astroboy> Ok, how do I solve something like that: http://pastebin.com/GjQD6sUf ?
08:12:21 <astroboy> I have two different versions of blaze-html on my system
08:12:38 <astroboy> because digestive-functors-blaze wants <0.4
08:13:45 <aavogt> force the other one to install with <0.4?
08:14:03 <aavogt> astroboy: in any case, the solution is to use only a single version of blaze-html
08:14:37 <hpc> one could update digestive-functors-blaze
08:15:46 <astroboy> yeah but I already spent half an hour fixing digestive-functors-happstack for happstack 0.6
08:16:17 <astroboy> and that was an easy fix
08:16:27 <astroboy> uff
08:40:11 <tg_> are any of the n-category cafe guys in here?
08:41:39 <minn_> Are there good resources (accessible papers, etc.) on recursive types and fixpoints? E.g., which ones are recommended?
08:42:32 <dankna> ARGH cabal repositories :(
08:42:54 <dankna> broken packages, need to reinstall, but can't do that without wiping out the packages for the OTHER version of ghc that I have installed too
08:43:02 <dankna> tweaked config file so this won't happen again
08:45:07 <Saizan> dankna: ~/.ghc/ has subdirectories
08:45:36 <Saizan> dankna: each version of ghc stores the user db in a separate one
08:46:26 <dankna> Saizan: no help to me, I store everything in /usr/local/cabal/ instead
08:46:55 <dankna> the basic problem is that I want to reorganize that so that in future I can rm -rf /usr/local/cabal/$compiler/ without affecting another compiler
08:47:39 <dankna> but currently everything is in a halfway-default configuration where it's stored in /usr/local/cabal/{bin|lib|share|whatever}/$pkgid/$compiler/
08:48:06 <dankna> you see how that makes it harder to do the rm, but even if I went through all couple-dozen directories and did that, I wouldn't be able to do the reorg without breaking everything
08:48:32 <dankna> and the bottom line is that I know how to reinstall from scratch, heaven knows I get enough practice at it, and I don't know how to tweak ghc-pkg's database to recognize new locations
08:48:38 <Saizan> dankna: i'm talking about the metadata
08:48:42 <dankna> I know
08:49:00 <dankna> the thing is that I'm about to invalidate that metadata
08:49:11 <dankna> (by removing the targets it points to, heh)
08:49:31 <dankna> the targets are intermingled, per the directory structure that I explained above
08:49:41 <dankna> so I can't easily remove them for one compiler version without removing them for the other
08:49:58 <Saizan> you could just leave them all alone :)
08:50:11 <dankna> yeah, but then I wouldn't be able to build or install anything, cause it's broke :)
08:50:59 <Saizan> in most kind of broke removing the metadata is enough
08:51:03 <dankna> hmm
08:51:16 <dankna> yeah, but it really upsets me having two directory hierarchies on top of each other
08:51:27 <dankna> I see what you're saying now though
08:51:49 <dankna> I really do want to do the reorg, I think.  It'll only take me an hour, tops :/
08:53:52 <kulakowski> dankna: I get annoyed at things like that all the time. Trying to squeeze everything into a tree structure isn't always fun.
08:54:20 <dankna> kulakowski: it's more that it was the wrong tree structure because I hadn't previously thought things through all the way :)
08:54:26 <dankna> there's an obvious right way to do it now that I think of it
08:54:43 <dankna> so if you were about to say something about database-structured filesystems... hehe
08:54:47 <kulakowski> dankna: Ah. Oh I see, reading the scrollback now.
08:55:27 <kafee> can someone please tell me why this code does not work?: http://hpaste.org/44123/happstack
08:55:45 <kulakowski> dankna: I was going to say something about the slow convergence of version control, package management, filesystems, and databases, abstracting away the differences between different kinds of backing store etc.
08:55:59 <dankna> kulakowski: okay, haha, you may proceed with saying such a thing :)
08:56:40 <kulakowski> dankna: Well I would but I've been drinking, and I'm sure I don't have anything original to say on the subject.
08:56:41 <aavogt> kafee: what is Layout?
08:56:42 <dankna> well, that's an interesting way of looking at it - I would have thought version control was orthogonal to package management, and both were orthogonal to FSes and DBs, with the last two being the only ones converging
08:56:46 <dankna> kulakowski, haha okay then
08:57:18 <dankna> see, I think different kinds of backing store are important
08:57:34 <dankna> I agree that some convergence is happening but I don't think that's what's being abstracted in it
08:57:58 <dankna> part of the reason it's slow is that we have to really feel our way in the dark, taking steps only as they become clearly the best way
08:58:04 <kulakowski> dankna: I think they are, but I think that the computer should 95% of the time figure out whether it's better to put it on a flash drive or hard drive, or keep it on a ramdisk, or whatever, with a way to hint and also to force it to do what I want
08:58:35 <dankna> well, I can see something like that, okay
08:58:52 <kulakowski> dankna: Also, version control has been incorporated into filesystems before. Nothing like what modern dvcs do, but still.
08:58:57 <dankna> yeah, I know
08:59:26 <dankna> note that 95% is a bad amount - it's not high enough that "the computer told me to" kinds of users won't have to understand how to deal with things the other 5% of the time
09:00:28 <dankna> I just think that VC doesn't gain anything by being at the FS level
09:00:53 <dankna> indeed, it even loses some things - the ability to know where the repository root is and relate that to remote roots
09:01:36 <dankna> and package management... well... all it needs out of version control is a tag to jump to
09:02:06 <Jesin> hmm
09:02:23 <Jesin> I'm wondering what the MonadFix instance for [] does
09:02:27 <dankna> no idea
09:02:31 <kulakowski> dankna: Yeah. I think I mostly just get annoyed at having to keep track of things in multiple different package control systems.
09:02:39 <dankna> understood.  so do I.
09:02:41 <Jesin> and in what cases it's defined
09:02:50 <dankna> we could have tighter integration of end-user tools.
09:03:18 <kafee> aavogt: html tags from text.xhtml
09:03:55 <kulakowski> dankna: And that on just one system.
09:03:59 <dankna> indeed
09:04:09 <aavogt> kafee: anyways, I think your indentation is wrong
09:04:25 <aavogt> when I copy-paste the lines after the methodM don't align with the m
09:04:34 <aavogt> and they are suppsed to, based on the type of methodM
09:07:14 <peorOvO> `cell a b = matrix !! a !! b' -- this can be rewritten as `'cell a = matrix !! a !!' -- is there any way to rewrite it in a point free way removing also `a'?
09:07:43 <kulakowski> @pl cell a b = matrix !! a !! b
09:07:43 <lambdabot> cell = (!!) . (matrix !!)
09:08:05 <peorOvO> uh, didn't know of @pl, thanks!
09:09:01 <kulakowski> peorOvO: You can get the same on hackage. Also, don't overdo it. Readabililty counts.
09:09:20 <peorOvO> would you suggest writing it in that point free way? it looks to me a lot tougher to understand, but I'm still a newbie
09:10:06 <peorOvO> kulakowski, yes, I know I shouldn't overdo, but I want to get used to it...
09:10:50 <aristid> peorOvO: no, it cannot be rewritten as cell a = matrix !! a !!
09:11:01 <kulakowski> peorOvO: For completeness' sake there is also a pointful package
09:11:12 <jmcarthur> it's good to understand how to write point free code because it's often simpler to understand. if you find it harder to understand in point free form, you don't want to use point free form.
09:11:17 <aristid> @pl cell matrix a b = matrix !! a !! b
09:11:17 <lambdabot> cell = ((!!) .) . (!!)
09:11:29 <aristid> :t (!!) .: (!!)
09:11:29 <lambdabot> forall a. [[a]] -> Int -> Int -> a
09:11:40 <aristid> there we go :D
09:11:46 <jmcarthur> or at least not the particular point free form you came up with
09:11:52 <jmcarthur> :t (.:)
09:11:53 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
09:12:18 <aristid> jmcarthur: i don't actually use (.:) in real code anymore, tho
09:12:25 <aristid> but it's plenty of fun with lambdabot
09:12:25 <peorOvO> jmcarthur, but if I never use point free form I'll never get use to it and I'll never find it simpler...
09:12:46 <jmcarthur> peorOvO: there's a difference between never *trying* and never *using*
09:12:57 <peorOvO> aristid, `matrix' is not a parameter for `cell', it's a constant visible in `cell''s scope
09:13:07 <jmcarthur> peorOvO: i almost always *try* a point free version of a function if i suspect it may be cleaner, but i still may not use what i come up with
09:13:08 * roconnor is starting to get used to (f .) . g
09:13:14 <aristid> peorOvO: ok.
09:13:26 <aristid> roconnor: why is that better than (.:)?
09:13:26 <peorOvO> jmcarthur, ok, got it
09:14:00 <jmcarthur> basically, don't force yourself to use code you can't read. your style will change over time anyway
09:14:01 <roconnor> aristid: cause it entends  to ((f .) .) . g and (((f .) .) .) . g
09:14:26 <jmcarthur> but do force yourself to be open-minded and curious about alternative ways to write your code
09:14:31 <peorOvO> jmcarthur, I can read point free expressions, but find it a lot harder to write them...
09:14:48 <jmcarthur> ah, well, you'll get better at it with practice
09:14:51 <aristid> roconnor: you could use the SEC form, that's more extensible: ((.).(.).(.)) f g
09:15:14 <jmcarthur> fmap fmap fmap fmap fmap f g
09:15:17 <jmcarthur> :P
09:15:26 <aristid> jmcarthur: to keep it simple? :)
09:15:45 <peorOvO> `(!!) . (matrix !!)' this is OK to me, for example: `(matrix !!)' needs a parameter (`a') then returns its result. `(!!)' needs two parameters and get the one returned by `(matrix !!)' and then the one remaining...
09:15:50 <aristid> peorOvO: just play with @pl when you're bored, or want to annoy fellow #haskell users
09:16:11 <peorOvO> aristid: eheh :) ok
09:16:19 <jmcarthur> peorOvO: if you have no problem with it, use it. you may later change your mind, but that's up to you
09:16:28 <jmcarthur> just do what feels right
09:16:55 <peorOvO> ok :) thanks for suggestions!
09:17:31 <ski> @type uncurry . (!!) .: (!!)
09:17:32 <lambdabot> forall a. [[a]] -> (Int, Int) -> a
09:18:13 <ski> @type \a (i,j) -> a ! (i :: Int,j :: Int)
09:18:14 <lambdabot> forall e. Array (Int, Int) e -> (Int, Int) -> e
09:20:23 <s1024> Hi all! I wrote a simple program to dump hex contents of a file http://hpaste.org/44128/print_hex_dump_of_file . Can somebody take a look and make comments it? 
09:20:42 <dankna> that indeed looks like a simple program to dump hex contents of a file.
09:20:47 <dankna> not sure what you wanted me to say :)
09:21:32 <s1024> ok - I have questions: Is style is ok? Maybe would be better to use more smart types instead of String?
09:22:00 <aavogt> there's a type synonym   FilePath = String
09:22:17 <ski> > take 4 `map` mfix (\xs -> [0:xs,1:xs])  -- Jesin : a very simple example
09:22:18 <lambdabot>   [[0,0,0,0],[1,1,1,1]]
09:22:20 <aavogt> which might make the comment for processArg  redundant given the type signature
09:22:51 <kafee> aavogt: how do i deal with buttons cliked, things selected, how do i know which one recevied input?
09:23:20 <haskelln00b> Hi, this may be a stupid question but can anyone recommend a good IDE, etc.. for someone wanting to learn haskell on *nix
09:23:24 <dankna> Emacs :(
09:23:29 <haskelln00b> NOOO
09:23:41 <dankna> I hear good things about the Vim mode for Haskell, too
09:23:45 <haskelln00b> I use vim, etc.. for C/C++ 
09:23:55 <haskelln00b> But for things like Ruby I really like Netbeans
09:24:15 <haskelln00b> are there any IDE's on the level of Netbeans for haskell?
09:24:25 <haskelln00b> Or an eclipse plugin, or something?
09:24:28 <dankna> no.
09:24:30 <aavogt> kafee: the html that defines those buttons has to specify that the browser should do a POST or GET with some parameters
09:24:38 <dankna> (I also have absolutely no clue what Netbeans is)
09:25:15 <haskelln00b> Its an IDE a lot of people use for Java/Ruby/etc.. made by Sun/Oracle
09:25:28 <dankna> I see.
09:26:09 <haskelln00b> is haskell similar to lisp
09:26:18 <haskelln00b> I understand that its a functional programming language
09:26:24 <haskelln00b> (javascript is "functional" too
09:26:27 <dankna> not really.  they're both languages that encourage you to think in terms of functions as first-class objects.
09:26:33 <haskelln00b> ohh
09:26:35 <dankna> to a much greater extent than you'll see in Javascript.
09:26:44 <ski> ClaudiusMaximus : i sometimes use `flip' (and `map' and other things) infix
09:26:46 <dankna> but they're about as dissimilar as possible within that constraint.
09:26:52 <haskelln00b> hmm
09:26:54 <dankna> both syntactically and semantically.
09:27:11 <ski> > ((2 ^) `map`) `map` [[],[0],[1,2],[3,4,5],[6,7,8,9]]
09:27:12 <kafee> aavogt but get and post requests can be performed by any html control?
09:27:12 <lambdabot>   [[],[1],[2,4],[8,16,32],[64,128,256,512]]
09:27:18 <haskelln00b> I've been really interested in functional programming because Ruby incorporates some functional aspects
09:27:22 <dankna> yes, indeed.
09:27:26 <haskelln00b> I was thinking of learning LISP for fun
09:27:33 <siracusa> haskelln00b: There's an Eclipse plugin for Haskell. I don't know whether it's already out of date, though.
09:27:49 <dankna> you should learn either Haskell or Lisp (the all-caps version is archaic; it's "Lisp" these days)
09:27:54 <ski> > (`map` [[],[0],[1,2],[3,4,5],[6,7,8,9]]) $ \ns -> (`map` ns) $ \n -> 2 ^ n
09:27:55 <dankna> to stretch your brain
09:27:55 <lambdabot>   [[],[1],[2,4],[8,16,32],[64,128,256,512]]
09:27:57 <dankna> ideally you would learn both
09:27:59 <dankna> but not at the same time!
09:28:05 <dankna> too much stretching
09:28:09 <haskelln00b> LISP has been around forever and it seems to me that it's not as active as other languages
09:28:30 <dankna> well, there was a lot of energy in the Lisp community a few years ago, you might check planet.lisp.org and see what you think about it today
09:28:33 <haskelln00b> But, Haskell when I read up on it seemed really nice (it was started by a bunch of people with PHd's)
09:29:01 <haskelln00b> And I've found some really nice, modern guides and tutorials
09:29:04 <dankna> I do think Haskell is a superior language, but it's hard to make a direct comparison like that
09:29:25 <dankna> I will say that there is a ton of great work going into not just using Haskell but improving it
09:29:28 <ski> > ((2 ^) `graph`) `map` [0,1,2,3]
09:29:30 <lambdabot>   [(0,1),(1,2),(2,4),(3,8)]
09:29:38 <aavogt> kafee: I believe so
09:29:50 <dankna> now, you have to understand, both these languages are missing some libraries that you're used to taking for granted
09:29:52 <haskelln00b> Hmm, I know even at school I have a functional programming class and it's haskell
09:30:03 <dankna> that's good to hear!
09:30:12 <ClaudiusMaximus> dankna: thanks for direct-sqlite (if it was you?), nice and simple to get up and running (though, ghci is a bit awkward if you forget to s <- prepare ; without finalize s later, cannot close db ...)
09:30:33 <dankna> ClaudiusMaximus, it was me :) you are welcome!  always great to hear from users.  what are you doing with it?
09:30:43 <dankna> hmmmm, yeah, I see that....   not sure what I can easily do about it though.
09:30:59 <haskelln00b> Yeah, I've been drawn to haskell becasue it seems more modern and with alot more enthusiasm than lisp (ie. a lot of new and good tutorials for haskell, where LISP all I find are sites from the 90's)
09:31:04 * dankna nods
09:31:04 <kafee> aavogt: there's my select             select ! [name "humor", method "POST" ] << [option << "Selecione", option << "Alegre",option <<"Triste", option <<"Irritado"  ,option << "Calmo"] 
09:31:10 <dankna> sigh.... the 90s have no business being eleven years ago
09:31:14 <dankna> I remember the 90s.  I was there.
09:31:28 <dankna> using Lisp, in fact!  haha
09:31:39 <ClaudiusMaximus> dankna: eventually, caching values that take a long time to compute (minutes..), in case they might be needed later (between program runs)
09:31:46 <haskelln00b> wow, ok so what I want to know is what domains of problems is haskell good for
09:31:47 <dankna> ClaudiusMaximus, ooh, cool trick :)
09:31:55 <haskelln00b> ie.. if you say "PHP" people think web development
09:32:10 <ClaudiusMaximus> dankna: i can paste a snippet if you're curious?
09:32:15 <dankna> ClaudiusMaximus, yes, I am :)
09:32:42 <dankna> well, I personally treat it as a "better C" - I use it for system-development stuff.  but I'm somewhat of a heretic in this regard :)
09:33:09 <haskelln00b> Hmm,
09:33:20 <dankna> it's great for complicated algorithms, because if your program typechecks, it probably does something similar to what you meant it to do
09:33:31 <haskelln00b> Alright, sounds good
09:33:34 <dankna> and for research situations in general, where you don't know quite how to do what you want to do
09:33:42 <aavogt> well it doesn't help if you've got no clue what you want to do
09:33:47 <haskelln00b> I know even with ruby the funcitonal programming mindset seems different
09:33:55 * dankna nods
09:34:05 <rajeshsr> what is the best way to lazily fetch a line from the command line?
09:34:12 <haskelln00b> and ruby only has a small amount of functional programming concepts
09:34:16 <dankna> indeed
09:34:20 <rajeshsr> i mean a file from command line...
09:34:31 <minn_> Haskell's great for the interpreter/compiler/dsl crowd also.
09:34:36 <haskelln00b> wait??? Is haskell similar to scheme?
09:34:52 <dankna> Scheme is very like Lisp, stripped down.  so no, Haskell is not much like either of those.
09:34:53 <peorOvO> @pl: f g = g 1 2
09:34:53 <lambdabot> f = flip ($ 1) 2
09:34:57 <ClaudiusMaximus> dankna: http://hpaste.org/44139/directsqlite_example
09:35:14 <dankna> ooh, Complex QuadDouble :D
09:35:20 <rajeshsr> anyone?
09:35:42 <haskelln00b> hmm, well I found a nice tutorial for haskell (compared to a 90's one for lisp) http://learnyouahaskell.com/
09:35:51 <dankna> yeah, that's a good one
09:36:00 <haskelln00b> I like the illustrations lol
09:36:00 <kafee> i want to get the value selected and print it on a h1
09:36:03 <dankna> @where rwh
09:36:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:36:08 <dankna> that, also
09:36:17 <dankna> yes haha
09:36:45 <sepp2k> haskelln00b: Just for the record: Lisp was invented by people with Ph.D.s as well
09:36:53 <dankna> that's true enough, haha
09:36:55 <siracusa> rajeshsr: getContents
09:36:58 <haskelln00b> hmm, haskell is based on lambda calculus... hmm I have to do lambda calc next term
09:37:04 <dankna> for that matter, so was C
09:37:12 <dankna> PHP however was not!
09:37:21 <rajeshsr> siracusa: is that lazy? the files am going to have is really huge..
09:37:37 <dankna> ClaudiusMaximus, interesting sample, thanks for sharing.
09:37:50 <rajeshsr> lines.getContents will work lazily?
09:38:17 <siracusa> rajeshsr: Yes
09:38:23 <haskelln00b> hmm, the haskell site has a good write up on haskell
09:38:29 <rajeshsr> siracusa: thanks!
09:38:31 <haskelln00b> comparing it to imperative programming languages
09:38:34 * dankna nods
09:38:51 <ski> > (sum / genericLength) [1,2,3,4,5]  -- aavogt
09:38:52 <lambdabot>   3.0
09:38:53 <ClaudiusMaximus> dankna: am a bit hesitant about integrating it into the main program, as i fear threading issues might raise their head (though it does seem to be compiled threadsafe by default)
09:39:17 <ClaudiusMaximus> dankna: but they won't not be uninsurmountable
09:39:27 <dankna> ClaudiusMaximus: Hmm.  Does the main program use forkOS or only forkIO?  because the latter should be perfectly fine.
09:39:50 <xyz88> 88
09:39:55 <haskelln00b> is Hugs good for haskell?
09:40:07 <dankna> I would use ghc and ghci (ghci is the interactive version)
09:40:10 <haskelln00b> what interpreter/compiler should I use for haskell on Linux
09:40:19 <aristid> haskelln00b: GHC.
09:40:21 <ClaudiusMaximus> dankna: even with -threaded and +RTS -N2 ? i know gtk2hs goes mental when i forget postGUI(A)Sync
09:40:39 <ClaudiusMaximus> dankna: in the worst case i can make a db thread and pin it with forkOnIO
09:40:44 <ski> (dankna : Scheme is *a* Lisp :)
09:40:56 <dankna> ski: well, people usually mean Common Lisp when they say Lisp nowadays :)
09:41:11 <ski> well, those people are misleading :)
09:41:24 <dankna> ClaudiusMaximus, oh hmm.  well, I haven't done anything special to support it, above what sqlite already does.  which you can read about on their website.  (skip the screed about how threads should not be used and jump to the bit about how "... we support them anyway ..." haha)
09:41:41 <haskelln00b> thanks, GHC it is
09:41:54 <dankna> ClaudiusMaximus, I believe there's some constraint along the lines of you can't be using the same db handle on multiple threads simultaneously
09:42:12 <ClaudiusMaximus> dankna: yep i read that section, hehe
09:42:15 <dankna> hehe
09:42:20 <dankna> ClaudiusMaximus, if you think of anything direct-sqlite can do to mitigate the situation with regard to threads, please tell me
09:43:37 <haskelln00b> lmao, omg ruby is slow compared to haskell
09:43:45 <dankna> this is true
09:43:51 <aristid> i get the feeling that modelling messy APIs from haskell can be a challenge, because you feel the strong urge to abstract over the messiness
09:43:54 <haskelln00b> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
09:44:07 <aristid> haskelln00b: yeah, ruby is damn slow.
09:44:24 <haskelln00b> I like ruby alot though, it's a programmer's best friend (EXCEPT RAILS)
09:44:39 <dankna> aristid: well, I have a number of "direct-*" packages where I kinda try to practice my philosophy of not doing that, just providing the API in its original form so that higher abstractions can be built in separate packages
09:44:54 <dankna> but that said, I don't think sqlite is a messy API
09:45:48 <aristid> some APIs are not messy, i never claimed that sqlite was messy :)
09:45:55 <dankna> fair :)
09:46:06 <aristid> curl is an example of a messy API
09:46:11 <dankna> whoever did the win32 bindings, that person was a saint
09:46:17 <siracusa> rajeshsr: Wait, if you want to read a file use readFile, getContents is for reading from stdin.
09:46:27 <dankna> hGetContents for laziness
09:46:39 <aristid> readFile is equally lazy
09:46:41 <dankna> oh
09:46:49 <rajeshsr> siracusa: ha, ok!
09:46:51 <rajeshsr> thanks
09:47:20 <dankna> haskelln00b, what do you like about Ruby?  just curious
09:49:23 <haskelln00b> Ruby combines the best about everything
09:49:32 <haskelln00b> for example everything is an object
09:49:44 * dankna nods
09:49:49 * ski idly wonders how that is good
09:49:49 <haskelln00b> 10.times (the actual number ten is an instance of an object)
09:49:55 <haskelln00b> that's a loop
09:50:06 <haskelln00b> ruby has Gems which is a huge number of libraries
09:50:20 <dankna> everything in Haskell has precisely the same amount of object-ness, but it's kind of a matter of definition how much that is, since it's not a traditional OO model
09:50:24 <haskelln00b> ruby has some functional aspects through the use of procs, blocks, and lambda
09:50:33 * hackagebot svg2q 0.3.1 - Code generation tool for Quartz code from a SVG.  http://hackage.haskell.org/package/svg2q-0.3.1 (JanGreve)
09:50:58 <haskelln00b> what else, ruby has strong integration of regular expression and alot or perlish syntax
09:51:26 <haskelln00b> ruby, pretty much is a bit of a lot of different paradigms, and EVERYTHING is an object
09:51:38 <haskelln00b> you can do someting like this (puts is a print statement)
09:51:52 <haskelln00b> puts "Hello, World".upper.inverse.lower.whatever
09:52:07 <dankna> gotcha.
09:52:26 <sepp2k> haskelln00b: If you like perlish syntax, you'll be delighted to know that haskell's ability to define arbitrarily named infix operators allows you to produce line noise in Haskell as well.
09:52:35 <haskelln00b> hmmm
09:52:57 <dankna> haha
09:52:57 <aristid> if you like perlish syntax, i recommend perl. it has the most perlish syntax, and supports object-orientation too.
09:53:09 * ski . o O ( `(putString . whatever . map toLower . reverse . map toUpper) "Hello, World"' )
09:53:22 <haskelln00b> I have been reading around, on sites such as stackoverflow, and here's a good writeup: http://stackoverflow.com/questions/1012573/how-to-learn-haskell
09:53:54 <dankna> ah, indeed
09:54:55 <haskelln00b> someone wrote up a very good guide, I think I'll take his advice and aristid's (about GHC) and follow that
09:55:38 <aristid> really, there is little choice in compilers now. you have to use GHC.
09:55:53 <haskelln00b> oh, well thanks for letting me know what to use
09:56:05 <haskelln00b> I was having a hard time finding out what to use exactly
09:56:07 <dankna> GHC is the most up-to-date by far
09:56:14 <dankna> and supports the most language extensions
09:56:19 <haskelln00b> so GHC is a compiler?
09:56:25 <aristid> and an interpreter.
09:56:31 <dankna> yes, it produces native code, although it can also interpret
09:56:32 <haskelln00b> So unlike say perl, you can "compile" haskell and make portable apps?
09:56:34 <aristid> it supports both modes :)
09:56:44 <dankna> well, portable in the sense of not requiring the development environment to run, yes
09:57:08 <haskelln00b> I could in "theory" compile something in haskell on linux for windows and someone could run the "exe" on windows?
09:57:22 <lispy> haskelln00b: no not cross Os like that
09:57:27 * dankna coughs and looks at the ceiling
09:57:30 <haskelln00b> (I'm thinking here in the C/C++ sense with STL)
09:57:34 <tg_> haskelln00b: you can compile perl
09:57:37 <dankna> haha actually enabling that is what I'm working on at the moment
09:57:42 <lispy> haskelln00b: but you could compile it on windows and distribute a copy of the exe to your friend who has windows too
09:58:14 <tg_> specifically, you can do what lispy said, with perl
09:58:16 <tg_> as well
09:58:22 <haskelln00b> Alright, so haskell can be "compiled" and made portable in the C/C++ sense
09:58:23 <lispy> haskelln00b: distributing binaries on linux is much hander than on linux, but given the right assumptions it will work there too
09:58:40 <lispy> er, harder on linux than on windows :)
09:58:50 <haskelln00b> and I didn't know you can compile perl...
09:58:51 <dankna> because Linux environments tend to be more heterogenous
09:59:01 <haskelln00b> I always thought that was heresy to Larry...
09:59:03 <dankna> different libc versions, different kernel versions, different processors
09:59:04 <tg_> haskelln00b: there are a few free packages to do it, and one or two that cost money
09:59:20 <aristid> dankna: ghc executables seem to require pretty few things
09:59:24 <lispy> dankna: yeah, the irony is that linux ends up with far superior package managers as a result
09:59:27 <dankna> indeed, it's nice
09:59:27 <tg_> yeah, that's a key difference
09:59:32 <aristid> normal linux + libffi seems to suffice
09:59:42 <tg_> hello world, when compiled in Perl, could be a 8MB executable
09:59:49 <haskelln00b> ahh
09:59:50 <haskelln00b> heh
10:00:10 <haskelln00b> while on the topic of linux does anyone have any opinions on linux distributions
10:00:16 <tg_> I remember having to do that kind of compilation because I needed an executable on a Windows PE disc
10:00:25 <tg_> if you're new and you just want to jump in
10:00:31 <tg_> just try RedHat or Fedora or Ubunutu
10:00:33 <aristid> haskelln00b: maybe ask this in #haskell-blah? better not to derail #haskell with a distro flamewar.
10:00:37 <tg_> if you're a little more brave, try Debian
10:00:37 <lispy> haskelln00b: I've used (and liked) debian and referent fedora.
10:00:42 <haskelln00b> sorry
10:00:57 <tg_> if you have operating system OCD, try arch
10:01:01 <lispy> referent = recent, man Ican't type first thing in the morning
10:01:06 <dankna> I prefer Debian for servers, and for the desktop, my favorite Unix is OS X.  But yeah, let's not have this conversation.
10:01:16 <haskelln00b> I'll just stick with Gentoo/Arch/UBuntu
10:01:32 <tg_> i have a general question about Haskell
10:01:38 <dankna> feel free
10:01:44 <lispy> tg_: I have a general answer about Haskel
10:01:44 <tg_> is there a sense in which Haskell operates at a mathematical theory level?
10:01:53 <tg_> like, is Haskell fully compatable with all of the generalities of category theory?
10:01:57 <lispy> tg_: Laziness enhances composability
10:02:01 <dankna> tg_: I don't know category theory :)
10:02:07 <haskelln00b> what is category theory?
10:02:17 <tg_> haskelln00b: why, the theory of categories
10:02:17 <lispy> haskelln00b: it's a branch of math
10:02:23 <tg_> it's one of the most general branches of math
10:02:26 <dankna> a branch of mathematics that draws very high-level abstractions across other branches
10:02:33 <dankna> and I can't answer more because I don't know it
10:02:39 <dankna> Haskell borrows some terminology from it
10:02:41 <tg_> I just stumbled upon this page
10:02:51 <tg_> that has all of the physics group theory, etc, from current and speculative models
10:02:56 <tg_> evaluated in terms of category theory
10:02:59 <dankna> hm
10:03:00 <dankna> interesting
10:03:02 <dankna> where is it?
10:03:10 <haskelln00b> could you share the link (it may give me some topics to chat with my prof about)
10:03:17 <tg_> http://math.ucr.edu/~huerta/
10:03:19 <lispy> The thing I've heard about category theory is that everything is a category :)
10:03:26 <haskelln00b> thanks
10:03:31 <tg_> http://math.ucr.edu/home/baez/
10:03:43 <tg_> specifically "the algebra of grand unified theories"
10:03:47 <haskelln00b> I have a prof who's a real "purist" at math but he's a total noob at computers (and he's young.. he's not old)
10:03:53 <haskelln00b> Maybe I should get him to look at haskell
10:03:59 <tg_> "physics, topology, logic and computation: a rosetta stone"
10:04:44 <xplat> everything is a category, the hard part is figuring out how it's a category :)
10:04:55 <tg_> hehe
10:05:00 <haskelln00b> thank's for the advice everyone, I'm looking forward to these haskell 99 problems
10:05:00 <ski> (hehe, good old Baez :)
10:05:02 <tg_> all of these links stemmed from http://golem.ph.utexas.edu/category/
10:05:05 <xplat> and what other category-ish things it is
10:05:10 <dankna> kinda like that old paradox about the library of infinite size - it contains its own index, if only you could find it...
10:05:27 <xplat> dankna: and tell it from all the misleading indexes
10:05:29 <dankna> indeed
10:05:47 <tg_> this rings of godel's incompleteness
10:06:04 <ski> lispy : <http://mathoverflow.net/questions/22359/why-havent-certain-well-researched-classes-of-mathematical-object-been-framed-by>
10:06:06 <dankna> yes, it's related to oracle numbers, or whatever they are
10:06:43 <ddarius> lispy: Most things aren't categories (at least, not in natural ways.)
10:06:55 <tg_> ddarius: I thought pretty much all groups were?
10:07:12 <tg_> we need a chart
10:07:14 <Jesin> hmm
10:07:14 <ddarius> tg_: Yes, all groups can be viewed as special categories (modulo size issues.)
10:07:17 <dmwit_> All groups are categories, yes.
10:07:25 <tg_> ok
10:07:26 <tg_> that's good enough for me
10:07:34 <lispy> wow, UI fail.  I just started to log into xchat in a second instance while just meaning to change windows
10:07:34 <tg_> since my interests are in groups
10:07:40 <ddarius> tg_: But, for example, a graph is not a category in the "obvious" way unless it has certain properties (i.e. it is looped and transitive.)
10:07:50 <tg_> ddarius: yeah, ok. 
10:08:05 <tg_> but i get the feeling
10:08:16 <tg_> if I want to look at some group A, and then some group B which appears to be unrelated
10:08:17 <Jesin> regarding import syntax
10:08:23 <tg_> the language of category theory is likely to be my starting point
10:08:59 <Jesin> is there some syntax that says "import SomeModule hiding (everything that overlaps with existing functions)"
10:09:00 <ddarius> tg_: If you say so.
10:09:02 <dmwit> My new interpretation of category theory is just that it gives you the right questions to ask (and that it rarely tells you "answers" to things you want to know).
10:09:17 <Jesin> without having to specify what exactly those overlaps are?
10:09:27 <Jesin> eh
10:09:29 <dmwit> Jesin: No, you must list them by hand. However, you can import everything under shortened qualifier names.
10:09:32 <ski> (tg_ : maybe that `mathoverflow' question is of interest to you too)
10:09:35 <Jesin> right
10:09:37 <Jesin> ok
10:09:38 <rajeshsr> is there any doc on mkstemp? am not able to find it...
10:09:40 <Jesin> I guess that's probably best
10:09:43 <dmwit> Jesin: As in "import SomeModule as S".
10:09:51 <tg_> ski: I'll take a look
10:09:52 <Jesin> oh
10:09:59 <Jesin> I thought that was import qualified SomeModule as S
10:10:03 <ski> Jesin : did you get the `mfix' example ?
10:10:06 <Jesin> I guess the "qualified" is redundant there
10:10:08 <Jesin> no, I didn't
10:10:15 * Jesin scrolls up
10:10:25 <rwbarton> qualified means "don't import under the name SomeModule as well"
10:10:28 <dmwit> Jesin: "qualified" is orthogonal to "as"
10:10:44 <dmwit> rajeshsr: It's available at linux.die.net, at least.
10:10:46 <rwbarton> er, don't import with into this module rather
10:10:49 <Jesin> hmm, ok
10:10:59 <rwbarton> er, grammar
10:11:08 <ski> > take 4 `map` mfix (\xs -> [0:xs,1:xs])  -- Jesin
10:11:09 <lambdabot>   [[0,0,0,0],[1,1,1,1]]
10:11:15 <Jesin> hmm
10:11:17 <Jesin> ...
10:11:19 <Jesin> kthx...
10:11:29 * Jesin will work out how that does that now
10:11:36 <rajeshsr> dmwit: well, am talking about Haskell wrapper for that. What's the return type etc.?
10:11:38 * hackagebot temporal-music-notation 0.1 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.1 (AntonKholomiov)
10:11:41 <ski> (it's a very simple example, but should give some basic idea of what it does)
10:12:56 <dmwit> rajeshsr: lmhtfy
10:13:02 <dmwit> http://haskell.org/hoogle/?q=mkstemp
10:13:13 <lispy> ddarius: according to that article I have yet to learn the first thing about CT then :)
10:14:56 <Jesin> lol
10:15:00 <Jesin> '"To a man with a hammer, everything looks like a nail." Mark Twain  Andrey Rekalo Apr 23 at 15:19'
10:15:01 <rajeshsr> dmwit: thanks! BTW, i like LMHTFY :) Hoogle is Google here :)
10:15:13 <Jesin> ^ is this a good summary of abstract mathematics
10:15:14 <Jesin> :p
10:15:21 <dmwit> rajeshsr: =)
10:15:39 * hackagebot temporal-music-notation-western 0.1 - music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.1 (AntonKholomiov)
10:15:44 <dankna> "To a man with sour cream, everything looks like a potato."
10:16:05 <lispy> To a man with X, everything looks like an X-complement.
10:16:26 <tg_> dankna: I don't like sour cream on potatos. :(
10:16:30 <tg_> So, I'd say burrito.
10:16:31 <dankna> To a man with X11R6, everything looks like a good idea to include in the package.
10:16:39 <tg_> lol
10:16:40 * hackagebot csound-expression 0.3.0 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.3.0 (AntonKholomiov)
10:16:40 <lispy> heh
10:16:49 <dankna> hehe
10:17:14 <dankna> hm.  somebody's doing.... computational musicology? :)
10:17:24 <dankna> sound combinator library?  neat
10:17:50 <xplat> to a man with a combinator library, everything looks like a function
10:18:11 <ddarius> lispy: There's a difference between something -being- a category and the class of such things forming a category, though even the latter doesn't always happen.
10:18:21 <xplat> not funny, because he's right :)
10:18:28 * ddarius had some excellent sour cream recently.
10:18:54 <lispy> For some reason, I don't find learning CT compelling like I have other topics in math.
10:19:15 <ddarius> lispy: What other topics have you learned?
10:19:16 <lispy> I've been a Haskeller for years now but I haven't read more than a few pages from a CT book
10:19:25 <rajeshsr> siracusa: Even if it is lazy read, it won't be able to deallocate the previous lines, right? if i do: map id lines. That will exceed memory, if am not wrong!
10:19:36 <xplat> i feel like a lot of CT books are just not very good
10:19:37 <augur> whats codata
10:19:52 <lispy> ddarius: basic calc and real analysis, group theory, some coding theory, a bit of number theory, linear alg
10:19:54 <ddarius> Learning category theory for Haskell is not very rewarding, though it certainly is more so than for other languages.
10:20:01 <dolio> A lot of books on a lot of subjects aren't very good.
10:20:33 <xplat> category theory has only even been around since the 40s, and most of the good stuff the 60s or later
10:20:41 <lispy> ddarius: of those, group theory and lin alg are probably my favorite followed by coding theory and at the bottom real analysis
10:20:41 <ddarius> lispy: What made real analysis and number theory compelling to you?
10:20:52 <xplat> so even the recommended books mostly are no good
10:21:00 <siracusa> rajeshsr: Only if the result of map id lines is actually needed elsewhere.
10:21:14 <xplat> actually number theory was the one i could never get into
10:21:48 <augur> and whats a non-strictly positive data type?
10:21:52 <rajeshsr> siracusa: hmm, i think i need just hGetLine.
10:21:57 <ddarius> lispy: I suspect if you learn more algebra or more topology or more logic, category theory will begin to be more compelling, though it can be used to good effect in group theory.
10:22:18 <wires> there is nothing wrong with say, categories for the working mathematician, which is a good book. It just doesn't tell you much about how CT in relation to computer science...
10:22:19 <ski> rajeshsr : if you use the result incrementally, not keeping references to the whole (or most of the) result list, then it should probably only use constant space for the list
10:22:25 <lispy> oh, I took one class on topology.  I found it to a be a very hard subject :)
10:23:03 <ddarius> wires: If you wanted a book to link CT to computer science, why not choose a book that claims that as a goal?
10:23:16 * lispy has sadly forgotten much of what he once knew about the maths
10:23:16 <ddarius> Of which I can think of three off-hand.
10:23:25 <wires> ddarius: which?
10:23:37 <ski> augur : maybe you want to ask in #agda ?
10:24:00 <augur> ski: im asking in here cause presumably haskell has at least the latter :P
10:24:08 <ski> (but (very) roughly, `codata' are for infinite values, while `data' is for finite ones)
10:24:08 <augur> and i think people here have spoken of codata before
10:24:13 <wires> ddarius: i have this book, Basic Category Theory for Computer Scientists - Pierce
10:24:16 <Philippa> has anyone collected a list of CT book recommendations based on both the reader's background and areas of intended use?
10:24:17 <ddarius> Barr and Wells' book, Pierce's book, and another one whose author I don't recall.
10:24:19 <augur> ski: infinite values?
10:24:20 <lispy> ddarius: these days the maths I'm interested in studying more are type theory (dependent types), formal methods, and I refreshing my lin alg
10:24:37 <ddarius> lispy: Category theory is useful for type theory/logic.
10:24:45 <dolio> A strictly positive functor is one for which the argument only appears on the right of function arrows.
10:24:48 <roconnor> augur: data Y a = Y a -> a is the canonical example
10:24:53 <siracusa> rajeshsr: If you use GHC, it has a garbage collection, so unused/unreferenced data shouldn't be a problem at all, IMO.
10:24:56 <dolio> Anything else is not strictly positive.
10:25:03 <ddarius> lispy: You may also find Goguen's work interesting.
10:25:05 <augur> yahooooo: y'whaa
10:25:09 <lispy> siracusa: you could still have a space leak
10:25:12 <xplat> augur: a non-strictly-positive datatype is one that has a type constructor parameter appearing at an odd level of nesting-to-the-left-of-function-arrows
10:25:14 <rajeshsr> ski: hmm, Looks like the ref count will be non-zero for each line at some point of time in the code. hGetLine seem to make more sense.
10:25:15 <roconnor> augur: data Y a = Roll (Y a -> a) is the canonical example
10:25:16 <rajeshsr> thanks
10:25:31 <dolio> And types are named after the functors.
10:25:37 <augur> roconnor: is that (Y a) -> a or Y (a -> a)?
10:25:38 <xplat> type Foo a = b -> a -- strictly positive
10:25:46 <Philippa> (I think I'm in an awkward position because I don't just want to know it for compsci usage but most of the rest I basically only need intuitions for now)
10:25:46 <siracusa> lispy: Yeah, that's true
10:25:51 <xplat> type Foo a = a -> b -- not
10:25:59 <ddarius> xplat: There's a difference between strictly positive and positive.
10:26:06 <lispy> one of the myths of using GC is that your memory management problems will go away
10:26:19 <augur> xplat: ahh so this is positive and negative in the Belnap display logic sense
10:26:24 <lispy> GC actually just gets rid of the accidentally freeing something that is still in use and makes it trivial to allocate new stuff
10:26:29 <augur> maybe some other senses too, but thats where i know it from
10:26:51 <ski> rajeshsr : just fyi, ghc doesn't use reference counting
10:26:53 <xplat> ddarius: oh, hm.  what is the difference?
10:26:56 <ddarius> Philippa: Check out Goguen "Categorical Manifesto" (though it is not an introduction)
10:26:56 <lispy> ddarius: Or david spivak
10:27:11 <augur> xplat: ive never understood the positive/negative subformula thing. what is it about?
10:27:14 <dolio> xplat: Double negatives are positive, but not strictly positive.
10:27:14 <rajeshsr> ski: interesting! so, what's its GC strategy?
10:27:32 <ddarius> xplat: (a -> b) -> b is positive in a but not strictly positive in a.
10:27:38 <roconnor> augur: (Y a) -> a
10:27:43 <wires> lispy: daniel spivak
10:27:46 <augur> roconnor: ok, just checking.
10:27:50 <lispy> rajeshsr: ref counting wouldn't work well for haskell because we endup with cycles
10:27:56 <lispy> wires: thanks!  I'm terrible with names
10:27:56 <wires> lispy: oh no.. sorry
10:28:04 <roconnor> augur: see http://r6.ca/blog/20060919T084800Z.html
10:28:07 <wires> lispy: you were right :)
10:28:10 <lispy> ah
10:28:37 <lispy> rajeshsr: GHC uses a root set and then traverses from there to find reachable things
10:28:44 <augur> roconnor: you know, yesterday i explained Y to a friend, and for the first time in my experience of thinking about it (which is not much) Y actually made intuitive sense
10:28:47 <rajeshsr> lispy: ha, ok!
10:28:52 <lispy> rajeshsr: it has a couple collection strategies implemented
10:28:54 <ski> rajeshsr : `do ss <- liftM lines getContents; return (length ss)' should be fine, but replacing `return (length ss)' by `return (ss,length ss)' probably wouldn't (since keeping the top `ss' reference alive will keep it from being GCed incrementally)
10:29:14 <lispy> rajeshsr: an older compation scheme and I think the default is based on generations and copying
10:29:33 <lispy> compaction*
10:29:38 * lispy cannot type
10:30:04 <rajeshsr> lispy: hmm, ok!
10:30:27 <wires> ddarius: thanks for Goguen tip, interesting guy
10:30:50 <rajeshsr> ski: too subtle! Long time no touch with Haskell to appreciate it! :) Just embarking on a weekend hack to get started back!!
10:31:01 <augur> roconnor: it was a wonderful experience, to explain Y and just not have to think about it
10:31:08 <lispy> rajeshsr: this article might answer some questions: http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
10:31:18 <roconnor> augur: now learn mfix
10:31:35 <ddarius> lispy: The main compelling thing about category theory is that it provides a uniform perspective/language.  This is nice in and of itself, but it also allows things like talking about the type theory of topological spaces, if you wanted.
10:31:38 <augur> roconnor: thats not on that page tho is it
10:31:48 <augur> lets see, mfix huh
10:31:49 <roconnor> no
10:31:52 <roconnor> @type mfix
10:31:53 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:32:11 <lispy> > mfix Just
10:32:19 <lambdabot>   mueval-core: Time limit exceeded
10:32:29 <augur> 0.0
10:32:31 <lispy> > fix $ mfix Just
10:32:32 <lambdabot>   Couldn't match expected type `a -> a'
10:32:32 <lambdabot>         against inferred type `Data.M...
10:32:36 <hpc> > mfix (:[]) :: String
10:32:40 <lambdabot>   mueval-core: Time limit exceeded
10:32:43 <lispy> oh, man Haskell doesn't even know it's broken!
10:33:11 <ski> > take 4 `map` mfix (\xs -> [0:xs,1:xs])  -- augur
10:33:12 <lambdabot>   [[0,0,0,0],[1,1,1,1]]
10:33:12 <hpc> > mfix (const [5])
10:33:12 <lambdabot>   [5]
10:33:49 <augur> O_O
10:33:49 <augur> wat
10:33:51 <rajeshsr> lispy: thanks!
10:34:03 <roconnor> augur: I wrote an article about how to use mfix to write a DSL for an assembler in Haskell
10:34:10 <augur> horrible
10:35:03 <lispy> rajeshsr: dons wrote a GA to figure out what are the best GC options for a given program compiled by GHC.  But, that's probably beyond what you're looking for :)
10:35:15 <sshc> Hi.  I have class, 'Bar', defined with "class (Foo a) => Bar a where ...".  Every method in 'Bar' can have a default implementation based on the functions of 'Foo' (every function in 'Bar' has a default definition, making just "instance Bar Type" by itself possible).  But it is important to allow some types to define more efficient implementations for some functions in 'Bar', because in this case
10:35:17 <lispy> roconnor: link?
10:35:21 <sshc> performance is important.  My goal is to have the default definitions for any type that is an instance of 'Foo'; or, in other words, so that GHC will choose the most specific instance (or if there is none for a specific type, then the one defined for any 'Foo' type).  How do I do this?
10:35:24 <rajeshsr> lispy: Genetic Algo, you mean?!
10:35:29 <lispy> rajeshsr: yes
10:35:35 <povik> hi
10:35:36 <rajeshsr> interesting! :)
10:35:43 <roconnor> lispy: http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
10:35:53 <lispy> roconnor: thanks
10:36:11 <roconnor> augur, lispy: when I was trying to understand mfix it felt like learning recursion all over again
10:36:13 <povik> why does the haskell regexp implementation returns list of matches only as [[String
10:36:19 <povik> ]] type?
10:36:30 <roconnor> augur, lispy: now it feels so natural, I had no idea what my problem was
10:36:54 <lispy> roconnor: this is often the case when learning something.  It feels difficult at first then becomes oddly natural
10:37:01 <augur> roconnor: thats always how it is
10:37:14 <augur> when i first tried to understand Y it made _no_ sense
10:37:23 <augur> then yesterday it was so intuitively obvious
10:37:49 <Jesin> [14:03:57]	<roconnor>	augur, lispy: when I was trying to understand mfix it felt like learning recursion all over again
10:38:02 <sshc> I seem to recall that there might be an extension that enables GHC to choose the most specific instance definition; for example, if there is an instance for both "Maybe a" and "Maybe Integer", then the latter will be chosen for 'Integer' wrapped in Maybe and the former for anything else wrapped in Maybe.
10:38:03 <Jesin> I never understood how recursion confuses people
10:38:09 <Jesin> or if I ever did, I don't remember it
10:38:14 <augur> Jesin: its not the recursion part
10:38:16 <roconnor> Jesin: learn mfix
10:38:17 <Jesin> ...I mean, it's just function calls
10:38:17 <sshc> Is there an extension for this?
10:38:29 <augur> its how you get recursion without environments to bind functions
10:38:30 <Jesin> mfix is confusing yes
10:38:31 <augur> to names
10:38:36 <Jesin> "fix" was also confusing at first
10:38:40 <dolio> Putting on my monochrom hat...
10:38:47 <roconnor> fix is just recursion :D
10:38:48 <lispy> dolio: haha
10:38:58 <dmwit> sshc: Yes, OverlappingInstances, I think.
10:38:59 <dolio> Recursion confuses people because they're taught to execute programs to understand them.
10:39:01 <rwbarton> dolio: What color is it? :)
10:39:02 <Jesin> I never had trouble with recursion, but I didn't immediately understand how fix was used to implement it
10:39:03 <Jesin> then I did
10:39:05 <Jesin> :p
10:39:06 <roconnor> dolio: yes
10:39:19 <Jesin> [14:06:46]	<dolio>	Recursion confuses people because they're taught to execute programs to understand them.
10:39:21 <Jesin> umm
10:39:22 <Jesin> then
10:39:24 <roconnor> dolio: I think this causes 99.99% of all problems in CS.
10:39:28 <Jesin> ...
10:39:30 <Jesin> but
10:39:34 <Jesin> if they don't understand it
10:39:38 <Jesin> that means they're executing it wrong
10:39:39 <dolio> But executing recursion requires all kinds of stack management, which is hard to keep in your head at once.
10:39:39 <Jesin> :p
10:40:13 <ddarius> dolio: Why are you executing it in your head?
10:40:16 <Jesin> hmm
10:40:31 <dolio> ddarius: They're doing it because they're told to.
10:40:32 <Jesin> I guess the stack-based definition of fix would be
10:40:34 <Jesin> dup funcall
10:40:37 <dolio> That's how you understand programs.
10:40:38 <Jesin> :p
10:40:38 <roconnor> ddarius: because dolio is pretending to be a monoic programmer for this thought experiment
10:40:44 <roconnor> *moronic
10:40:47 <roconnor> :P
10:40:59 <roconnor> *monadic
10:41:00 <Jesin> umm
10:41:10 * ddarius incidentally does execute programs in his head all the time.
10:41:19 <roconnor> :(
10:41:22 <Jesin> [14:07:25]	<dolio>	But executing recursion requires all kinds of stack management, which is hard to keep in your head at once.
10:41:24 <Jesin> I think
10:41:26 <Jesin> I basically did that.
10:41:32 <Jesin> when I was learning about function calls.
10:41:56 <Jesin> If it gets hard to remember,
10:41:59 <Jesin> just make a note
10:42:27 <Jesin> :p
10:44:02 * ddarius also does abstract interpretation of programs in his head.
10:44:39 <Philippa> dolio: I think the bigger issue is people these days being scared to get out pen'n'paper when executing stuff?
10:44:39 <Jesin> the "functional" way of understanding recursion flows smoothly from the stack-based version, imo
10:44:58 <Jesin> lol, doesn't even need pen and paper
10:45:09 <sshc> dmwit: Ah, yes, that was it, thanks
10:45:12 <Jesin> I've done stack traces in IRC sessions
10:45:14 <Philippa> that's entirely dependent on the person in question and how well they understand it already
10:45:22 <lispy> Philippa: I agree. I have a hard time programming without something it write on
10:45:22 <sshc> dmwit: But GHC is failing with a different error now
10:45:24 <ddarius> Jesin: That seems odd because the most natural way to think of functions, arguably, doesn't have or require a stack.
10:45:27 <Philippa> *shrug* - yeah, that's a restricted pen'n'paper analogue though
10:45:35 <Jesin> yeah, it is
10:45:35 <sshc> Constraint is no smaller than the instance head in the constraint: Foo a (Use -XUndecidableInstances to permit this) In the instance declaration for `Bar a'
10:45:46 <Jesin> but if you don't wanna bother with paper, and you're working on a computer
10:45:50 <Jesin> just get out a text editor
10:45:52 <Jesin> :p
10:45:53 <Philippa> (and you're comfortable with the restrictions because /you know you don't need them/, the student isn't)
10:45:56 <dolio> Philippa: Using a pen and paper would help, probably. Using a better way of understanding recursive programs would probably help more.
10:46:01 * monochrom decloaks
10:46:03 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/51df24fbf33b7059
10:46:09 <lispy> Jesin: text editors don't work so well for a lot of things that I write down
10:46:27 <Jesin> they work pretty well for stack traces and term-rewriting, though
10:46:44 <Philippa> dolio: true in some ways, not in others. You really do want to execute by hand to get your head around why tail recursion is good, for example, because you need to see the activation records even if they're not a stack-over-an-array
10:46:46 <Jesin> @src ap
10:46:46 <lambdabot> ap = liftM2 id
10:46:49 <lispy> Yes, but don't you also draw diagrams of references?
10:46:49 <Jesin> @src liftM2
10:46:49 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:47:01 <lispy> and it's easier to draw an arrow between to things on a page when using paper
10:47:05 <monochrom> executing programs by pen and paper is a wee bit better, but still misses the forest for the trees
10:47:09 <Jesin> I started from those lines, and managed to transform that into
10:47:15 <Jesin> ap m1 m2 = m1 >>= (
10:47:17 <Jesin> err
10:47:17 <sshc> dmwit: Is it safe to enable 'UndecidableInstances' for this?
10:47:17 <roconnor> Jesin: I think how recursion in Haskell works is practically unrelated to how it works in "normal" langauges.
10:47:20 <Jesin> ap m1 m2 = m1 >>= (`liftM` m2)
10:47:27 <Jesin> well
10:47:37 <rajeshsr> what does hGetLine return at EOF?
10:47:40 * Philippa thinks things'll improve in another 5-10 years when everyone expects touchscreens everywhere, btw
10:47:48 <dolio> Philippa: Yes. Understanding the execution benefits of tail recursion probably requires going through the execution of programs. I can agree with that.
10:48:03 <dankna> gah!  Happy depends on itself!  I thought we fixed this :(
10:48:13 <Jesin> roconnor: not really
10:48:17 <monochrom> hahaha just when we discuss recursion
10:48:22 <dankna> where by we I mean I did some code in cabal-install to that end, but I guess it never got rolled in
10:48:22 <Jesin> you just have to shove laziness in every layer of execution
10:48:23 <dmwit> sshc: Usually, needing UI is a sign that you should really rethink what you're doing.
10:48:36 <Jesin> that's the only real difference, I think
10:48:38 <Jesin> :p
10:48:52 <roconnor> You don't construct cpos?
10:49:04 <Jesin> also
10:49:05 <Jesin> [14:14:52]	<monochrom>	executing programs by pen and paper is a wee bit better, but still misses the forest for the trees
10:49:08 <sshc> dmwit: Usually.
10:49:15 <Jesin> *while you're doing it* it does
10:49:25 <monochrom> also http://article.gmane.org/gmane.comp.lang.haskell.cafe/81075/ :)
10:49:29 <Philippa> dolio: I'd probably also suggest another variety of 'execution' for pure programs as part of understanding
10:49:31 <Jesin> but once you've mapped out the trees
10:49:40 <ddarius> dolio: Tail call optimization "just happens" when you "execute" (functional) programs by rewriting.  There is nothing to explain.
10:49:42 <Jesin> you can step back, look at the whole page, and see the forest
10:49:55 <monochrom> sometimes people don't step back
10:50:12 <micahjohnston> tg_: were you the one who was in ##tempus a while ago?
10:50:36 <Jesin> [14:17:42]	<monochrom>	sometimes people don't step back
10:50:38 <Jesin> umm
10:50:47 <Jesin> what time scale are we considering here?
10:50:49 <Jesin> =/
10:50:59 <ski> > unsafeInterleaveST
10:51:00 <lambdabot>   Not in scope: `unsafeInterleaveST'
10:51:02 <ski> bah
10:51:03 <monochrom> all time scales
10:51:04 <roconnor> ddarius: when executing a program by rewriting is there even a stack for TCO to apply to?
10:51:14 <Philippa> ddarius: yeah, the problem is that some people still want to understand what that has to do with the hardware. At which point I feel the answer is to bust out ANF myself, but hey
10:51:18 <Jesin> :(
10:51:24 <monochrom> I even know people who don't step back for life.
10:51:28 <Philippa> (CPS for an encore rather than first)
10:51:34 <Jesin> umm
10:51:35 <ski> @type let cons :: a -> Mu (WriterT a (STRef s)) -> ST s (Mu (WriterT a (STRef s))); cons a as = do {ref <- newSTRef (as,a); return (In (WriterT ref))} in cons
10:51:36 <lambdabot> forall a s. a -> Mu (WriterT a (STRef s)) -> ST s (Mu (WriterT a (STRef s)))
10:51:41 <Jesin> don't step back from what
10:51:49 <ski> @type let freeze :: Mu (WriterT a (STRef s)) -> ST s [a]; freeze (In (WriterT ref)) = Control.Monad.ST.unsafeInterleaveST $ do {(node,a) <- readSTRef ref; as <- freeze node; return (a:as)} in freeze
10:51:50 <lambdabot> forall a s. Mu (WriterT a (STRef s)) -> ST s [a]
10:51:59 <Jesin> I mean, how bad is it
10:52:00 <Jesin> :p
10:52:03 <monochrom> from executing programs
10:52:08 <Jesin> like, you could argue that full-blown category theory
10:52:13 <ski> oh, augur left
10:52:20 <ddarius> roconnor: Yes and no, but mostly no.  The point is, though, tail recursive programs execute in constant space (assuming the result is fixed sized).
10:52:20 <Jesin> is stepping back too far
10:52:24 <Jesin> but
10:52:25 <monochrom> I am not arguing anything about full-blown category theory
10:52:39 <Jesin> I know *you're* not
10:52:39 * ski was wanting to demonstrate  runST . freeze . liftM fst . mfix $ \ ~(xs2,ys1) -> do {xs1 <- cons 'a' xs2; ys0 <- cons 'b' ys1; xs0 <- cons 'a' xs1; return (ys0,xs1)}  but lambdabot isn't cooperating
10:52:46 <monochrom> but you seem to be arguing for the sake of arguing
10:52:49 <Jesin> I'm just wondering what sort of concrete effects
10:52:57 <Jesin> this failure to step back causes
10:52:58 <Jesin> =/
10:53:00 <ddarius> monochrom: That's what most people do.
10:53:21 <ddarius> I blame Socrates.
10:53:22 <Jesin> I haven't looked very closely at bad programming much
10:53:29 <Jesin> ...though
10:53:37 <dolio> roconnor: There's not a stack as such, but in a non-tail recursive situation you might find yourself rewriting inside a very deeply nested expression, which is the same thing.
10:53:39 <sshc> dmwit: 'Bar', which requires the type to also be an instance of 'Foo', already has default implementations for every function.	Thus I *can* do this by manually writing "instance Bar Type" for every type that is an instance of "Foo".  But I want to make this more convenient by providing a default instance by writing "instance Foo a => Bar a" by itself, and enable other types to make more specific
10:53:40 <Jesin> a friend of mine did have a professor
10:53:45 <sshc> instances with OverlappingInstances.  But GHC is complaining that "Constraint is no smaller than the instance head in the constraint"
10:53:45 <Jesin> who deducted points for using recursion
10:53:50 <sshc> dmwit: Is UndecidableInstances safe to use in this case?
10:54:36 <ray> the solution is for all programmers to have at least 2 phds
10:54:38 <monochrom> it causes shortsightedness, cognitive dissonance (euphemism for hypocrisy), losing perspective
10:54:41 <dmwit> Can you prove by yourself that finding an instance terminates?
10:54:44 <dmwit> If so, it's safe.
10:55:01 <Jesin> eh
10:55:09 <Jesin> I guess I was just hoping for some anecdotes
10:55:11 <Jesin> :p
10:55:30 <Jesin> if you don't wanna provide any I guess I don't really need that though  :p
10:55:38 <ddarius> ray: Preferably not in computer science.
10:55:40 <monochrom> my article http://groups.google.com/group/comp.lang.functional/msg/51df24fbf33b7059 tells you one large class of anecdotes.
10:55:57 <ray> in math and sociology
10:56:01 <rwbarton> the worst thing UndecidableInstances can cause is for the compiler to loop
10:56:08 <monochrom> (and I already gave that url 10 minutes ago)
10:56:41 <sshc> no'i If I use OverlappingInstances in the module which defines the more general instances, do I need to use OverlappingInstances elsewhere?
10:56:57 <monochrom> if it's tl;dr for you, summary: people think the only way to build a program is trial-and-error
10:57:58 <Jesin> rather than writing a specification, and then rigorously rewriting that into a program
10:58:00 <Jesin> =/
10:58:14 <Jesin> right
10:58:19 <Jesin> ...
10:58:25 <Jesin> yeah
10:58:37 <Jesin> I had an internship a while back that involved legacy fortran code, that was not fun
10:58:51 <Jesin> a lot of it, from different sources
10:59:43 <Jesin> eh.
11:00:04 <Jesin> umm
11:00:06 <Jesin> "Most programming courses spend all their time on how to execute if-then-else, how to execute a while loop, and how to execute recursive calls."
11:00:49 <Jesin> blah.
11:01:36 <Jesin> if-then-else should take no time
11:02:08 <monochrom> (program counter and stack) is an optimization over (look for things to rewrite)
11:03:15 <Jesin> hmm
11:03:57 <Jesin> they should teach "if x: goto label"
11:04:06 <Jesin> as primitive
11:04:07 <Jesin> then
11:04:33 <Tomsik> I think they should start with finite automata
11:05:04 <dankna> I did start with finite automata!  For middle-schoolers.
11:05:11 <dankna> Mind, I didn't go much past that.
11:05:26 <Jesin> transforming while into that, is simple
11:05:29 <dankna> I was just trying to give them the flavor.
11:05:33 <Jesin> and explains how while loops work
11:05:51 <Jesin> this should take less than two weeks
11:05:54 <ddarius> Finite automata are all we have.
11:06:33 <monochrom> I started with flow charts. does that count? :)
11:06:36 <Jesin> then, function calls, with a stack of pointers
11:06:37 <hpc> Jesin: while loops should really take less than a day
11:06:44 <Jesin> yes, they should
11:06:49 <Jesin> but they don't
11:06:52 <Jesin> somehow
11:07:01 <Jesin> give it 5 days, maybe
11:07:17 <Jesin> function calls with a pointer stack, and tail call optimizations
11:07:20 <Jesin> should be taught next
11:07:30 <Jesin> and a greater bulk of time should be spent on that
11:07:40 <Jesin> if they're teaching how to execute programs efficiently
11:07:43 <Jesin> :p
11:08:07 <Jesin> scheme does strike me as a good choice for a teaching language
11:08:14 <Jesin> because loops are implemented with tail recursion
11:09:35 <Jesin> tail calls basically let you replace a "gosub" followed by a "return", with a "goto"
11:09:42 <Jesin> it just removes an indirection
11:09:46 <Jesin> (loljoin!)
11:09:50 <Jesin> :p
11:10:57 <Jesin> hm, I think I need more blood sugar
11:11:00 * Jesin goes for food
11:11:06 <Jesin> brb
11:11:53 <ray> i think scheme is a good vehicle for introducing a lot of the interesting things about programming
11:12:04 <ray> i mean if all you want to teach are for loops then anything is fine
11:12:39 <djahandarie> My uni is teaching it as the intro language experimentally, and the teacher is actually incredibly smart and really tough, so I've heard that the dropout rate is pretty astronomical
11:13:13 <cizra> Must all case variants be of the same value?
11:13:33 <cizra> What if there's only one real case value and its alternative is error?
11:13:52 <lispy> roconnor: interesting article
11:14:15 <Jesin> hm, good point about "Solving a problem by divide-and-conquer or reduction"
11:14:23 <Jesin> I thought that was obvious...
11:14:30 <Jesin> do people actually not teach that?
11:14:39 <Jesin> err, I mean *teach that way
11:14:40 <dankna> high dropout rate is a GOOD sign for an intro CS course
11:14:45 <roconnor> lispy: :D
11:14:46 <lispy> roconnor: I may till need to pair that with something a bit more formal and absract about mdo, but it's a great service to have such a clean concrete exmaple of usage that also address common pitfalls
11:14:51 <dankna> most prospective CS majors are doing it for the wrong reasons
11:14:58 <roconnor> lispy: also you should play ICFP 2006
11:15:07 <Jesin> "Unfortunately as an artifact of teaching programming by execution and
11:15:09 <Jesin> not problem solving, students do not think of divide-and-conquer"
11:15:10 <Jesin> O.o
11:15:12 <Jesin> but
11:15:13 <dankna> you want to scare them off early so the serious ones don't have to be taught at the lower level of ability for the remaining three years
11:15:24 <Jesin> but, *execution* is easiest by divide and conquer!
11:15:25 <Jesin> :(
11:15:42 <Jesin> umm
11:15:47 <Jesin> what sort of wrong reasons
11:15:54 <Tomsik> Here it's mostly half people dropping off each semester
11:15:56 <dankna> well, like, the glory of it, the shine of high-tech
11:16:07 <dankna> rather than the desire to build something creative and new
11:16:11 <Tomsik> though some of them "respawn" on first year :p
11:16:14 <dankna> hah
11:16:31 <monochrom> execution distracts from problem-solving
11:16:37 <Tomsik> some people want to study CS for money, mistaking it for cheap-ass IT
11:16:44 <dankna> yeah, that also
11:16:45 <Jesin> "the glory of it" *comes from* building something creative and new
11:16:53 <dankna> in general students who think it's going to be easy are ones we don't want
11:17:06 <lispy> roconnor: after reading it I don't understand the mechanism that mdo uses to allow forward references.  I guess it's something like what fix does, but the translation from mdo to mfix is something I need to think about more
11:17:12 <dankna> or at least, if they keep thinking that after being exposed to the truth
11:17:30 <Jesin> it is easy, though
11:17:44 <dankna> it's easy for you and me because we've been doing it since forever (I presume)
11:17:58 <dankna> in objective terms, it's not
11:18:15 <aristid> how can a measure of "easy" ever be objective?
11:18:23 <Jesin> "objective" meaning averaged over people in general?
11:18:25 <Jesin> or what?
11:18:26 <aristid> ease is by definition a relative, subjective measure
11:18:26 <dankna> yes
11:18:45 <dankna> if it were objectively easy, we would not have bugs in our programs
11:18:47 <lispy> aristid: relative to the "norm" in this case
11:18:50 <Jesin> umm
11:18:52 <Tomsik> No way, we all know that P is easy and 2-EXPSPACE is hard!
11:19:02 <Jesin> lol!
11:19:16 <Jesin> I'll be right back
11:19:34 * Tomsik daydreams of halting problem oracle
11:19:53 * lispy needs to go study some isabelle
11:19:59 <Tomsik> isabelle
11:20:00 <Tomsik> ?
11:20:09 <lispy> Tomsik: interactive theorem prover
11:20:25 <lispy> Tomsik: I need to write a translation from one language to a subset of isabelle
11:20:39 <lispy> I need to go study the subset that I'm targetting
11:20:53 <lispy> So I can figure out how much I need to learn to be able to write the translation and estimate the time to do so :)
11:21:33 <BMeph> Has anyone tried to make a torics system in Haskell?
11:22:03 <jfischoff> darcs newb question, how do I make a patch file, but not send it?
11:22:18 <dankna> darcs send --output=foo
11:22:26 <dankna> or something like that ^^'
11:22:40 <dankna> emoticon denotes giant sweatdrop hovering in the air next to my face
11:22:54 <jfischoff> dankna: when it asks to send the patch should I say yes?
11:23:01 <dankna> I suspect not
11:23:14 <dankna> or rather, hm
11:23:19 <jfischoff> that's what I thought initially
11:23:20 <dankna> check the syntax with darcs send --help
11:23:36 <jfischoff> but no I think it is just a bad prompt
11:23:39 <dankna> if you're sure it's --output=foo then go ahead and say yes to send, because it's not actually sending, just incorporating into the sendfile
11:23:51 <lispy> jfischoff: darcs send -O
11:23:55 <jfischoff> yeah, that's what I think now too thanks
11:24:00 <dankna> np
11:24:04 <lispy> jfischoff: the capital O tells dars to create foo.dpatch
11:24:10 <jfischoff> ah
11:24:18 <lispy> jfischoff: and it names it for you
11:24:24 <lispy> jfischoff: with -o you have to provide a name
11:24:52 <jfischoff> cool
11:24:53 <lispy> jfischoff: lots of darcs users here, but if you don't get good answers there is also #darcs
11:25:02 <jfischoff> ah good to know
11:25:14 <jfischoff> helpful as always :)
11:25:40 <lispy> heh, #haskell is the rockband of freenode.
11:25:47 <jfischoff> totally
11:25:55 <dankna> @ask dcoutts I'm running cabal-install from your darcs repo updated a moment ago, with the boostrap.sh patched to use the latest versions of all the dependencies, including mtl2, and when I try to install one of my packages with the resulting binary I get "configure install plan should have exactly one local
11:25:56 <lambdabot> Consider it noted.
11:25:56 <dankna> ready package.", how can I debug this? :) :) :)
11:26:10 <dankna> @ask dcoutts "configure install plan should have exactly one local ready package.", how can I debug this? :) :) :)
11:26:10 <lambdabot> Consider it noted.
11:26:41 <dankna> (sigh)
11:26:56 <dankna> (the trials of being on the cutting edge, heh)
11:28:34 * Jesin returns with a burrito
11:28:51 <Jesin> (it's really a monad :D)
11:29:18 * Jesin noms on his monad
11:30:17 <roconnor> lispy: there are some papers that document how mdo is translated to mfix
11:30:22 * BMeph whips out his high=performance monad transformer library and starts playing some "Heavy MTL"!
11:30:47 <Jesin> lol
11:31:06 <ray> play some iron maiden
11:31:24 <Jesin> hmm
11:31:26 <Jesin> [14:45:32]	<dankna>	it's easy for you and me because we've been doing it since forever (I presume)
11:31:28 <Jesin> kinda yeah
11:31:31 <aristid> BMeph: why did you use = instead of -?
11:31:34 * dankna nods
11:31:35 <roconnor> lispy: losely speaking it turns mdo { x <- e1; y <- e2 } into mdo (x, y) <- (e1, e2) and then
11:31:50 <Jesin> I was playing around with Python in 9th grade
11:31:54 <roconnor> this is turned into mfix \(x,y) -> (e1,e2)
11:31:56 <roconnor> IIRC
11:31:59 <Jesin> and wrote an algorithm that used generators recursively
11:32:01 <Jesin> :D
11:32:03 <dankna> nifty
11:32:07 <BMeph> aristid: Because...the '=' key is right next to the '-' key. :)
11:32:16 <Jesin> I came back to it two years later
11:32:21 <Jesin> and was like, wtf how did I do that
11:32:24 <dankna> haha
11:32:32 <Jesin> and spent like two hours figuring it out
11:32:33 <Jesin> :p
11:32:37 <lispy> BMeph: and that's why you should switch to dvorak :)
11:32:38 <dankna> good fun
11:32:40 <Jesin> (and explaining it to someone else)
11:32:59 <ddarius> lispy: = is still pretty close to -
11:33:31 <aristid> not on german QWERTZ!
11:33:38 <lispy> ddarius: But - is a really natural reach on dvorak so I don't accidentally hit = when reaching for - (but the opposite could happen I guess)
11:34:12 <ddarius> lispy: I agree that it would be odd to typo - as =.
11:34:21 <jfischoff> you're using dvorak?
11:34:32 <Jesin> hmm
11:34:34 <Jesin> [14:45:32]	<dankna>	it's easy for you and me because we've been doing it since forever (I presume)
11:34:35 <Jesin> [14:45:46]	<dankna>	in objective terms, it's not
11:34:37 <Jesin> well
11:34:38 <jfischoff> did you change your shortcuts around?
11:34:45 <Jesin> I guess there are people who find, for example, english class
11:34:47 <Jesin> easy.
11:35:44 <BMeph> Jesin: I'm pretty sure no one finds english classes easy. Just the teachers... ;
11:36:10 <Jesin> ?
11:36:12 <Jesin> umm
11:36:25 <lispy> jfischoff: No, but some setups (OSX I know for sure) treat modifier key + key as qwerty but you are in dvorak other wise.  So Ctrl+C is still the same keystroke
11:36:35 <Jesin> well, this is a high school english class, and not such a high volume of work...
11:36:42 <ddarius> What is difficult about English class and why would it be easy for teachers?
11:36:59 <Jesin> well, at least the other students don't seem to have a problem with it
11:37:02 <Jesin> =/
11:37:38 <lispy> jfischoff: the default dvorak mode in OSX doesn't have that property though.  It's definitely opt-in/configurable
11:37:47 <ray> please
11:37:52 <ray> can YOU remember the kings of england?
11:38:01 <Jesin> umm
11:38:13 <Jesin> what does that have to do with english class
11:38:27 * BMeph always Alfred the Great, and Ethelred the Unready.
11:38:50 <Jesin> I guess the content of "english class" varies  :p
11:38:52 <Jesin> hmm
11:39:00 <ray> i can remember the lancastrians because of those shakespeare plays
11:39:05 <jfischoff> lispy: I tried using dvorak way back when and found all my programs shortcuts were difficult
11:39:19 <geheimdienst> i can remember lambastians. not sure if those are related.
11:39:37 <monochrom> james, charles, edward, richard. that ought to cover most of them. :)
11:40:07 <Jesin> lol
11:40:19 <Jesin> you forgot Henry
11:40:20 <Jesin> :p
11:40:24 <monochrom> yeah!
11:41:11 <Jesin> ...eh
11:41:38 <Jesin> actually, general consensus seems to be that my problems with english class have to do with, umm
11:42:02 <christo_m> Can someone help me with writing a LUA parser using parsec in Haskell?
11:42:24 <Jesin> instinctual perfectionism, reluctance to write a paper endorsing a position I'm unsure of
11:42:30 <Jesin> that kind of thing
11:42:53 <christo_m> http://pastebin.com/bScKHkCS   <- i know this is pretty incorrect, but its what i have thus far
11:43:09 <Jesin> bleh
11:43:11 <Jesin> anyway
11:43:15 <Jesin> offtopic, sorry
11:43:19 <saiko-chriskun> anyone seen this before while trying to build haskell-crypto? http://paste.pocoo.org/show/341187
11:43:19 <Jesin> hm.
11:44:16 <lispy> saiko-chriskun: never tried to build that package, but if I had to hazzard a guess I would say you're using a different version of quickcheck than what they tested with
11:44:33 <saiko-chriskun> hm.. ok
11:44:49 <ray> did you guess that without even looking
11:44:51 <ray> :)
11:45:19 <lispy> ray: almost
11:45:32 <saiko-chriskun> how would I find out what version I need to downgrade to? :P
11:45:55 <rajeshsr> how can I have global constnats?
11:45:57 <lispy> saiko-chriskun: what version is cabal trying to use and what does the .cabal file say?
11:45:59 <Jesin> I should probably take the rest of whatever discussion I wanna do about this to #haskell-blah
11:46:00 <rajeshsr> MAX_SIZE = 1000
11:46:06 <rajeshsr> seems to give parse error
11:46:06 * Jesin goes there
11:46:15 <rajeshsr> i troed let MAX_SIZE = 1000
11:46:18 <rajeshsr> still..
11:46:25 <rajeshsr> sorry for being so stupid!!
11:46:28 <lispy> rajeshsr: just do, mAX_SIZE = 1000
11:46:29 <saiko-chriskun> lispy: tryin' to install 4.2.2
11:46:59 <rajeshsr> lispy: yes, that doesn't seem to work! Reports out of scope!!
11:47:05 <lispy> rajeshsr: everything in haskell is a constant and so you can just put it at the top level
11:48:03 <lispy> rajeshsr: well, you can't call it MAX_SIZE
11:48:16 <rajeshsr> lispy: yes, but it is reporting  Not in scope: data constructor `MAX_SEGMENT_SIZE'
11:48:17 <lispy> rajeshsr: it can't start with a capital letter
11:48:21 <saiko-chriskun> I also had an issue while trying to build some things with cabal it would just stall and use up all my memory
11:48:24 <rajeshsr> lispy: ha!!!
11:48:26 <rajeshsr> right!!
11:48:30 <rajeshsr> forgot! thanks!
11:49:10 <lispy> saiko-chriskun: the only time I've seen that is during linking.  Sometimes GNU LD wants all the ram on your system and more
11:49:37 <saiko-chriskun> is there a fix?
11:50:32 <lispy> saiko-chriskun: there is a fix for the linker problem I had, but that may not be your issue.  You could try running cabal with -v3 to find out where it stalls
11:50:45 <saiko-chriskun> ok
11:52:50 <christo_m> xplat: you here??
12:08:38 <periodic> Hmmm... why would cabal say it can't find a module that is a member of a hidden package when the package is a dependency in the cabal file?
12:09:10 <periodic> In this case it's Network.Wai.Handler.Warp and the package is 'warp-0.3.2' which I'm requiring through 'warp' as a dependency.
12:10:50 <dankna> @tell dcoutts I solved it - but I don't know how :/
12:10:50 <lambdabot> Consider it noted.
12:19:27 <harlekin> When using System.Plugins and loading fn.hs which contains the module Config, two files fn.o and Config.hi are created. However, then load is looking for fn.hi. How can I fix that?
12:22:03 <alpounet> harlekin, give your file the same name as your module
12:22:07 <alpounet> that is, Config.hs
12:23:24 <dcolish> is there a way to tell cabal to use g++ when compiling external sources?
12:23:29 <harlekin> alpounet, okay. Thanks.
12:26:03 <alpounet> dcolish, why ?
12:26:17 <alpounet> i'm not sure the name mangling etc will be compatible depending on what you're compiling
12:26:22 <alpounet> better do it with gcc
12:26:26 <dcolish> i cant
12:26:34 <dcolish> the lib i am building against is written in c++
12:26:58 <dcolish> i am externing the C++ to C and then linking, which works
12:27:03 <dcolish> i just want to automate it 
12:27:06 <alpounet> oh ok
12:27:36 <dcolish> i am looking at Distribution.Make, but i was hoping for a shortcut
12:27:45 <alpounet> i'm looking at http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/builders.html but i don't see anything about what you want
12:28:09 <harlekin> alpounet, now my file is named config.hs and contains module Config and make generated Config.hi, but load looks for config.hi. Is there a way around that? Having upper case files seems strange and lowercase module names, too.
12:28:36 <alpounet> harlekin, name it Config.hs and it'll be fine
12:29:26 <harlekin> alpounet, and is there a way around if I don't want to do that?
12:30:16 <alpounet> harlekin, http://www.haskell.org/ghc/docs/latest/html/users_guide/loading-source-files.html#ghci-modules-filenames
12:30:28 <alpounet> that's the section of GHC's documentation explaining how it works
12:47:51 <Guest24913> does anyone know what's happening with the Yi text editor?
12:48:00 <Guest24913> do they have an irc channel?
12:48:23 <Guest24913> i'm interested in developping a text editor in haskell but i don't know if the project is still alive
12:49:15 <monochrom> occasionally alive. you should certainly base on it.
12:49:43 <monochrom> as in "don't reinvent its basics"
12:53:31 <robryk> is there somewhere i could read a description of implementation of IO in GHC?
12:54:00 <c_wraith> robryk: what level of detail are you looking for?
12:54:39 <robryk> i want to understand what happens when i provide an action with a list from a good producer and what happens when i evaluate a good consumer on a list produced by an action
12:55:18 <Cale> robryk: Usually you don't have to know anything about the real implementation.
12:55:42 <ski> roconnor : if you traverse an expression with a zipper, to mark a current redex, then the zipper path is basically a stack  (see "felleisen contexts")
12:55:58 <robryk> i don't want to understand the semantics, but in which cases the list gets produced in its entirety
12:56:01 <c_wraith> robryk: good producers/consumers as in list fusion?
12:56:08 <robryk> yes
12:56:17 <Cale> list fusion doesn't mix with IO actions at all
12:56:18 <c_wraith> robryk: list fusion is almost entire unrelated to IO
12:56:28 <c_wraith> *entirely
12:56:55 <robryk> Cale: but if i do return goodProducer >>= someIOAction then sometimes list doesn't get created
12:57:00 <Cale> Except to the extent that maybe you do things like generate an IO action using a list of actions and a fold
12:57:13 <alpounet> robryk, then it'd be more about laziness
12:57:15 <Cale> What do you mean by "created"?
12:57:22 <robryk> c_wraith: yes, i know; i want to see how it behaves then
12:57:32 <robryk> sorry, allocated in its entirety at one point in time
12:57:48 <Cale> okay
12:57:53 <robryk> yes, it is about some sort of laziness
12:58:09 <c_wraith> robryk: even if it doesn't fuse, laziness can keep it from being allocated all at once
12:58:14 <Cale> Well, sure, goodProducer might return an expression which simply evaluates to a list
12:58:19 <robryk> sorry, confused terms
12:58:42 <robryk> i am talking about things that are a result of laziness, not any opt. rules
12:58:52 <Cale> and only as much of that list as someIOAction (whose type is confusingly not that of an IO action) pattern matches on will be constructed
12:59:01 <robryk> yes
12:59:03 <robryk> exactly
12:59:05 <Cale> It's the same situation as with any function.
12:59:25 <robryk> but when i do var <- someIOAction >>= return goodListConsumer
12:59:32 <robryk> and then use the var in another action
12:59:42 <Cale> That doesn't typecheck.
12:59:42 <robryk> the whole list gets produced (at least i believe so)
12:59:53 <Cale> No.
13:00:27 <Cale> (do v <- x; f v) is identical to (x >>= f)
13:00:27 <robryk> why doesn't it? i don't see..
13:00:38 <robryk> yes
13:00:42 <c_wraith> the main way IO interacts with laziness and lists is that things that build a list by performing an IO action for each element can't be lazy.  They won't return until the whole list is built.
13:01:09 <robryk> yes
13:01:16 <robryk> and i want to see why
13:01:20 <alex404> Can anyone tell me why hmatrix is giving me an error on installation saying that I must run 'cabal clean'?
13:01:28 <robryk> not as in why is can't be otherwise, because this is somewhat obvious
13:01:30 <robryk> but how it work
13:01:32 <Cale> An executing IO action written as a do-block will execute each of its steps in order, and the result of the last IO action in the block is the result of the block as a whole.
13:01:33 <robryk> *works
13:01:57 <Cale> This has nothing to do with evaluation (the reduction of expressions to values)
13:02:14 <roconnor> still, IO actiosn only force enough of their arguments as required to do whatever action they need to do.
13:02:26 <Cale> Functions which construct IO actions, even :)
13:02:26 <robryk> i am more concerned about return values
13:02:29 <roconnor> (when executed)
13:02:39 <tolkad> Are polymorphic functions outside a class specialized for each type they are used with?
13:02:48 <Cale> tolkad: no
13:03:13 <Cale> tolkad: There's only one version of any given polymorphic function in general, and it works identically for all types
13:03:21 <alpounet> robryk, IMO you actually wanna read a paper or two about how laziness works
13:03:26 <robryk> ok, so is it possible having an action returning a list, a good consumer (a function) to combine them so that the list doesn't get allocated whole?
13:03:29 <Cale> (you couldn't even do anything to specialise it because there's nothing to do)
13:03:52 <Cale> robryk: uh, sure?
13:03:57 <robryk> ok; how?
13:04:01 <Cale> return [1..] and print?
13:04:11 <robryk> other way round
13:04:15 <robryk> action produces
13:04:19 <robryk> and i have a function consumer
13:04:24 <Cale> return [1..] is an action
13:04:26 <tolkad> Cale: well what if I'm using sizeOf with scoped type variables?
13:04:27 <Cale> print is a function
13:04:27 <robryk> sorry
13:04:31 <robryk> meant for general action
13:04:43 * ski waves an `unsafeInterleaveIO' in front of c_wraith
13:04:50 <christo_m> is it possible to have multiple definitions for something in haskell
13:04:55 <Cale> robryk: What are you actually trying to do
13:04:56 <Cale> ?
13:05:02 * c_wraith pretends he can't see ski.  unsafeInterleaveIO ruins everything
13:05:05 <Cale> christo_m: Using typeclasses, yes
13:05:13 <robryk> i am trying to get a list, process it into another list, and output it
13:05:16 <christo_m> data Field = `[ Exp `] `= Exp | Name `= Exp | Exp
13:05:23 <ski> c_wraith : .. and concurrency ?
13:05:25 <Cale> robryk: and what I/O is involved?
13:05:29 <christo_m> see a Field can be three different things
13:05:31 <christo_m> Cale: is that what you mean?
13:05:32 <robryk> getting and outputing is IO
13:05:35 <Cale> robryk: Could you be more specific about the nature of the list?
13:05:44 <robryk> let us say, a video
13:05:55 <robryk> i know that i want something impossible
13:05:58 <robryk> at this moment
13:05:59 <c_wraith> ski: concurrency is fine.  unsafeInterleaveIO is actually fine, too...  It just ruins the clean semantic model. :)
13:06:29 <robryk> but if i wanted to get a list, consume it with a function, and output the small return value of a function
13:06:48 <robryk> how would i go about combining this so that the list isn't necessarily allocated?
13:06:54 <christo_m> Cale: ?
13:07:09 <christo_m> trying to write a parser for LUA in using haskell/parsec, new to both haskell and parsec though lol
13:07:09 <Cale> christo_m: It's not what I meant, but you'd probably represent that as a datatype with three data constructors
13:07:13 <tolkad> c_wraith: standard prelude has to use something like unsafeInterleaveIO for some of the functions in System.IO
13:07:46 <c_wraith> tolkad: Well, it doesn't need to be in the Prelude, but it does need to be somewhere.
13:08:13 <tolkad> c_wraith: yeah my mistake
13:08:29 <alex404> Can anyone tell me why hmatrix is giving me an error on installation saying that I must run 'cabal clean'?
13:08:37 <Cale> robryk: So how do you expect the steps of input and output to occur?
13:08:37 <robryk> let us say that i want to read a list of integers, sum it and output the sum
13:08:40 <ski> <http://hackage.haskell.org/packages/archive/ivar-simple/0.1.0.1/doc/html/Data-IVar-Simple.html>,<http://hackage.haskell.org/cgi-bin/hackage-scripts/package/procrastinating-variable-1.0.2>
13:08:49 <tolkad> if I use sizeOf like:  sizeOf' :: forall a. a -> Int; sizeOf' _ = sizeOf (undefined :: a) 
13:08:50 <robryk> ski: is that for me?
13:08:56 <tolkad> I don't understand how that can be compiled
13:09:03 <tolkad> without being specialized
13:09:05 <robryk> Cale: i don't quite understand what you mean
13:09:20 <tolkad> if I use sizeOf like:  sizeOf' :: forall a. Storable a => a -> Int; sizeOf' _ = sizeOf (undefined :: a) 
13:09:22 <tolkad> whoops
13:09:29 <tolkad> forgot the storable constraint
13:09:30 <Cale> robryk: If you do all the input steps first, then memory will obviously be needed to hold on to the first one until they're all read.
13:09:39 <robryk> yes
13:09:50 <ski> robryk : if you like, i suppose .. though it was more like intended for c_wraith
13:10:13 <ski> (though i think i actually wanted something not exactly like that .. though they are close)
13:10:16 <Cale> robryk: If you want to do part of the output after consuming part of the input, then you can't write a program which just reads all the input at once.
13:10:29 <robryk> i want it to happen thus: the input steps are interleaved with the function, which is a good consumer, and then the output happens
13:10:45 <Cale> (unless you use something like unsafeInterleaveIO or getContents to interleave input with other stuff lazily)
13:11:10 <tolkad> someone in here told me that expressions without free variables are only evaluated once during runtime. According to this rule, sizeOf (undefined :: a) would only be evaluated once
13:11:30 <tolkad> but that doesn't seem possible as it is polymorphic. I am a bit confused
13:11:46 <robryk> i understand that ; what i want doesn't interleave input actions with output actions
13:11:46 <tolkad> I had previously assumed it was specialized
13:11:47 <c1de0x> surely without free variables, they should be evaluated at compile time.
13:12:00 <Jesin> I think free type variables
13:12:02 <Jesin> count as free variables
13:12:11 <Philonous> Cale: Delimited Continuations!
13:12:32 <tolkad> c1de0x: no. the compiler can't know whether those expressions halt
13:12:44 <tolkad> c1de0x: also they may result in huge amounts of code
13:12:53 <c1de0x> ok
13:13:13 <tolkad> c1de0x: just because I want to memoize the fibonacci sequence doesn't mean I want my code to contain the first 10,000 numbers
13:13:38 <ski> @tell roconnor (if you traverse an expression with a zipper, to mark a current redex, then the zipper path is basically a stack  (see "felleisen contexts"))
13:13:38 <lambdabot> Consider it noted.
13:13:59 <Twey> Neat
13:16:11 <tolkad> Jesin: wait. how does it know which instance of Storable to use at runtime though?
13:16:18 <robryk> ski: i think that might solve my problem. thanks.
13:16:35 <c_wraith> tolkad: values with kind * have uniform runtime representation.  Because of that, if there's no typeclass involved, there's nothing to specialize
13:17:27 <tolkad> but there is a typeclass involved. Storable
13:17:57 <robryk> does do { v <- return goodProducer ; return $ goodConsumer v } always construct the whole v in memory?
13:17:59 <tolkad> I forgot that in my first type signature and corrected myself
13:18:06 <tolkad>  sizeOf' :: forall a. Storable a => a -> Int; sizeOf' _ = sizeOf (undefined :: a) 
13:19:44 <robryk> oh. it doesn't
13:20:28 <divip> hi, i have a memory leak problem with the hint runtime haskell interpreter
13:20:51 <divip> i can not find any bugreport
13:20:55 <divip> how to proceed?
13:20:59 <tolkad> robryk: to my knowledge, memory is only allocated when you call a constructor or function
13:22:04 <tolkad> robryk: haskell values are immutable so they don't need to be copied.
13:22:31 <tolkad> robryk: if you wanted to copy them you would need to completely recursively reconstruct them
13:22:32 <divip> i can reproduce the problem 
13:22:33 <robryk> well, it also gets allocated when you evaluate something that is a closure now
13:24:55 <tolkad> robryk: yeah I shouldn't have said it like that. What I meant was that just referring to variables doesn't copy them
13:25:01 <xplat> divip: if there's no applicable bug report, you could/should submit one
13:25:05 <kevinburke> i'm trying to run happy in debug mode
13:25:08 <kevinburke> by typing:
13:25:21 <kevinburke> happy -i -a -d Parser.y
13:25:25 <xplat> divip: preferably include a small piece of code that triggers the bug
13:25:39 <kevinburke> however when I try to make Parser.hs by calling ghc --make Parser.hs
13:25:53 <kevinburke> i get an error saying templates/GenericTemplate.hs:62:25: Not in scope: `unsafePerformIO'
13:25:58 <kevinburke> templates/GenericTemplate.hs:63:4: Not in scope: `hPutStr'
13:26:13 <kevinburke> i tried running find / -name GenericTemplate.hs 2>/dev/null
13:26:23 <kevinburke> but i can't find the location of the generictemplate.hs file
13:26:35 <kevinburke> any chance you could help me figure out the problem?
13:27:05 <christo_m> xplat: whatsup dudeee
13:27:07 <divip> xplat: i have found only the email of the maintainer
13:27:11 <christo_m> need your assistance
13:27:40 <divip> xplat: i think i will write an email then
13:28:07 <robryk> would having a function IO () -> a -> a which upon evaluation executes the action and returns its second argument break referential integrity?
13:28:28 <tolkad> kevinburke: enable CPP
13:28:39 <robryk> assuming the action couldn't throw any exception or anything of that kind?
13:28:44 <kevinburke> tolkad: how do you do that?
13:28:44 <tolkad> kevinburke: GenericTemplate.hs uses the CPP extension. enable it
13:29:08 <tolkad> kevinburke: just compile it with cabal instead of manyally
13:29:13 <tolkad> manually*
13:29:46 <tolkad> hmm, maybe that's not it
13:29:47 <divip> robryk: you can not construct a meaningful function with type IO a -> b  (for any b not containing IO)
13:29:52 <BMeph> robryk: Not only does it break RI, it lies its ass off!
13:29:58 <robryk> why?
13:30:05 <tolkad> kevinburke: are you using happy as a library? or are you trying to compile happy?
13:30:10 <divip> just try...
13:30:16 <hpc> robryk: what value do you return?
13:30:18 <robryk> it returns the same value in every evaluation
13:30:25 <robryk> the argument
13:30:29 <kevinburke> i'm trying to use happy to compile a parser i wrote - not trying to compile happy
13:30:29 <hpc> you can't
13:30:37 <hpc> because it's IO a -> *b*
13:30:42 <robryk> i know that i can't do this without unsafe stuff
13:30:56 <robryk> i want to know it it truly breaks RI if i do it unsafely
13:31:04 <hpc> robryk: one possibility is unsafeCoerce
13:31:09 <djahandarie> robryk, look into ST if you feel like you can guarentee nothing weird will happen in the IO
13:31:12 <hpc> another is unsafeCoerce . unsafePerformIO
13:31:13 <robryk> i don't want any coercing
13:31:13 <divip> robryk: maybe you mean  IO () -> IO (a -> a)   which is possible
13:31:37 <robryk> i am not talking about something that can be done without unsafeness
13:31:44 <hpc> divip: (>> return id)?
13:31:57 <divip> if you get an action, and you don't return an action that means that you did not use the action you got
13:32:00 <kevinburke> tolkad: i tried running ghc --make -cpp Parser.hs and got the same error - i'm not sure how to compile with cabal
13:32:02 <robryk> djahandarie: i don't quite understand; could you explain
13:32:04 <tolkad> kevinburke: I don't understand why ghc is trying to compile GenericTemplate.hs then. GenericTemplate.hs is part of the source code of the happy package
13:32:16 <BMeph> robryk: It cannot execute the action if it's 'IO b -> c', unless you're lying somewhere.
13:32:21 <robryk> i am Not talking about something than can be done without unsafeness
13:32:35 <robryk> and i Am aware of that
13:32:46 <divip> phc: yes
13:32:51 <robryk> i want to lie and see whether i can get away with that
13:32:52 <byorgey> robryk: yes, it would break RT. suppose it is called  foo :: IO () -> a -> a
13:32:55 <divip> hpc: yes
13:33:01 <tolkad> kevinburke: 0_o happy doesn't even have an associated library
13:33:06 <byorgey> robryk: then consider  let x = foo y in x + x   and  foo y + foo y
13:33:15 <djahandarie> robryk, ST is for IO-like stuff that isn't damaging to the outside world. For example, a mutating quicksort can be done in ST, and have the type signature [a] -> [a]
13:33:17 <byorgey> robryk: it lets you tell the difference between those two expressions, but you should not be able to
13:33:18 <kevinburke> tolkad: I'm not sure either
13:33:32 <robryk> byorgey: only by side-effects, yes?
13:33:38 <robryk> because they return the same value
13:33:46 <byorgey> robryk: yes, by side effects.
13:34:07 <djahandarie> robryk, http://www.haskell.org/haskellwiki/Monad/ST
13:34:09 <alex404> Can anyone tell me why hmatrix is giving me an error on installation saying that I must run 'cabal clean'?
13:34:23 <robryk> no, i am not looking for state monads
13:34:24 <tolkad> kevinburke: uh check the source code of Parser.hs and see if you are importing anything from the happy package
13:34:33 <robryk> i want that to be a world-changing IO action
13:34:38 <djahandarie> robryk, who said that was a state monad?
13:34:58 <djahandarie> Look at the examples
13:35:21 <robryk> i Want to damage outside world inside there
13:36:03 <divip> robryk: any function which typecheks and has type IO () -> a -> a, is safe, because it did not use the IO () value
13:36:15 <djahandarie> And you want to have a pure type signature that damages the outside world without using unsafe functions?
13:36:22 <djahandarie> That's impossible, and it's why the type system exists in the first place.
13:36:24 <robryk> byorgey: that is probably a stupid question, but why do we care in RT what happens to the outside world?
13:36:33 <xplat> robryk: the function you suggest breaks RT, but depending on what the action does you might be able to get away with not caring
13:36:33 <robryk> i Want to use unsafe functions!
13:36:46 <djahandarie> :t unsafePerformIO
13:36:47 <lambdabot> Not in scope: `unsafePerformIO'
13:36:52 <robryk> i know that
13:36:53 <byorgey> robryk: because ultimately, the only reason we care about programs is what they do to the outside world.
13:36:59 <xplat> for example, if you write to a file your program does not examine, or something like that
13:37:13 <BMeph> djahandarie: He wants to use unsafe functions. He does not not want to use them. :)
13:37:19 <kevinburke> tolkad: no, just from system, data.array and debug.trace - two imports of other .hs files, but neither of them imports from happy either
13:37:19 <robryk> byorgey: so it would be ok if that action is idempotent?
13:37:21 * djahandarie is sorely confused
13:37:37 <robryk> i am not asking how to implement that
13:37:46 <robryk> i am asking how much i am breaking by implementing that
13:37:51 <xplat> robryk: not completely ok if the action is idempotent, because it also might not run at all
13:37:51 <byorgey> robryk: I think in that case it would be OK, yes.
13:37:54 <BMeph> robryk: Itried to explain what you've already said...some folks get confused easily. ;)
13:38:11 <xplat> but it's closer to ok in some sense
13:38:19 <kevinburke> tolkad: there is this though http://hpaste.org/44144/happyerror
13:38:24 <byorgey> robryk: oh, xplat has a good point though
13:38:45 <Eduard_Munteanu> Doesn't idempotence there allude to uniqueness typing there?
13:38:57 <xplat> Eduard_Munteanu: no
13:38:58 <Eduard_Munteanu> s/there //
13:39:57 <xplat> if you write your function as, like, unsafePerformIO . seq, then you should not be able to observe the value without the idempotent action running at least once, so you're probably mostly safe there
13:40:11 <BMeph> Eduard_Munteanu: Idempotence is almost like, if not exactly like, a dual to uniqueness.
13:40:14 <robryk> xplat: not necessarily, i think
13:40:16 <xplat> er, sorry, seq . unsafePerformIO
13:40:53 <robryk> hm.. i guess this depends on what RT specifies exactly; the call might get optimized out
13:40:56 <Eduard_Munteanu> I'm taking idempotence in the mathematical sense here, i.e. it displays side-effects *just* once.
13:41:09 <xplat> you can still hand the value to a function, but if you pattern-match it or anything you will observe the action to have been performed
13:41:51 <robryk> but it might or might not get evaluated if the result doesn't depend on it in some cases, depending on optimizations performed, right?
13:42:31 <xplat> robryk: you're taking advantage of the fact that the compiler promises not to optimize out the left side of seq even if it has every reason to
13:42:46 <robryk> but it can optimize out the whole call to my function
13:42:56 <xplat> yes, that it can do.  even at runtime.
13:43:20 <robryk> so the action can run or not run depending on optimizations applied, right?
13:44:19 <xplat> but if you do case robryksFunction of Blah blah -> do { wiggle; waggle } 
13:44:45 <xplat> then your idempotent action will run before wiggle, if wiggle runs at all
13:44:53 <robryk> and that's my point
13:44:56 <robryk> if it runs at all
13:45:11 <robryk> wai
13:45:12 <robryk> sorry
13:45:15 <robryk> misread
13:45:15 <dankna> oh good, we're already talking about unsafePerformIO!
13:45:21 <dankna> I'm interested in unsafeLocalState
13:45:50 <Kaidelong> xplat: "seq . unsafePerformIO" will allow you to do a side effect and then return a pure value
13:46:00 <dankna> in particular, I have a class of operations, those which allocate memory and return a ForeignPtr to it (that's the type that wraps it in garbage-collection), which don't obey the rules for unsafeLocalState, forcing me to use unsafePerformIO instead
13:46:05 <dankna> I'm curious what people think about this
13:46:10 <dankna> should I move everything to IO, perhaps?
13:46:26 <dankna> but it seems wrong when basically all I'm doing is constructing a value.  it's not so different from what ByteString does.
13:46:28 <Saizan> there's a unsafeLocalState?:O
13:46:29 <Kaidelong> I know you guys are just working with an example here but you probably should not actually use something like that
13:46:34 <dankna> yes, it's in Foreign.Marshal
13:46:50 <dankna> the documentation makes it fairly clear that it's a placeholder for a future version which will actually enforce semantics
13:47:14 <dankna> maybe an unsafeEnduringState?
13:47:17 <xplat> this is the first i've heard of unsafeLocalState :I
13:47:21 <Eduard_Munteanu> So why are we discussing methods to turn Haskell non-pure?
13:47:21 <dankna> to provide the behavior I want?
13:47:39 <dankna> xplat: yeah, heh, it might be new in HEAD, I'm not sure
13:48:05 <rwbarton> yeah, what is this function?
13:48:12 <robryk> because i want to interleave IO with less breaking stuff than by using unsafeInterleaveIO
13:48:14 * BMeph patiently waits for djahandarie to find the function 'unsafePerformNoseDemonSummoningRitual'...
13:48:22 <dankna> http://www.google.com/search?q=unsafeLocalState&btnI=z
13:48:30 <Eduard_Munteanu> I don't actually understand the point of unsafeInterleaveIO :/
13:48:33 <dankna> "Sometimes an external entity is a pure function, except that it passes arguments and/or results via pointers. The function unsafeLocalState permits the packaging of such entities as pure functions."
13:48:38 <djahandarie> BMeph, I'll leave that to dankna :)
13:48:43 <dankna> haha
13:48:52 <xplat> robryk: hm, in that case it doesn't seem like a function of type IO () -> a -> a will work for you
13:48:56 <Eduard_Munteanu> Shouldn't it be the job of the execution engine to provide lazy IO semantics?
13:49:07 <BMeph> djahandarie: Oops, name-completion fails again. :)
13:49:18 <robryk> Eduard: i want to read a stream and output a stream ; conversion i want to happen through a function [a]->[b] and i don't care about interleaving order
13:49:39 <dankna> as c_wraith noted yesterday, everyone whose nick starts with d is secretly one person.
13:49:41 <xplat> BMeph: isn't that 'fix unsafeCoerce'?
13:49:52 <hpc> :t fix unsafeCoerce
13:49:53 <lambdabot> Not in scope: `unsafeCoerce'
13:50:01 <hpc> @let unsafeCoerce = fix ($)
13:50:02 <lambdabot>  Defined.
13:50:04 <hpc> :t fix unsafeCoerce
13:50:05 <lambdabot> forall a. a
13:50:08 <hpc> ooh, fun
13:50:09 <Eduard_Munteanu> robryk: doesn't that already happen with Bytestrings and that kinda stuff if you take care to make them fuse?
13:50:23 <BMeph> xplat: I thought it was 'cfix unsafePerformIO' ;)
13:50:26 <robryk> so i want to do this with little breakage -- if i put reading in one thread and writing in second, it don't see a reason why it should be impossible to do it then without breaking RT
13:50:30 <djahandarie> Daniel Peebles, Don Stewart, Dan Doel, Derek Elkins... Hmm, I'd like being grouped with this people :D
13:50:33 <robryk> i don't know what happens with ByteStrings
13:50:49 <ray> the "D" company
13:51:13 <Kaidelong> hpc: "fix unsafeCoerce" should be exactly bottom if you think about it
13:51:20 <BMeph> djahandarie: You forgot Dan Piponi. :)
13:51:31 <dankna> http://hackage.haskell.org/trac/haskell-prime/wiki/ForeignFunctionInterface scroll to "considerations for the future"
13:51:39 <djahandarie> Ah hah, yeah, him too :D
13:51:42 <dankna> this seems to be the motivation - it's an early-warning kind of thing
13:51:46 <Eduard_Munteanu> Didn't he use to hang in here?
13:51:54 <djahandarie> @seen sigfpe
13:51:54 <lambdabot> Unknown command, try @list
13:51:54 <Eduard_Munteanu> I haven't seen him in a while.
13:51:54 <preflex>  Sorry, I haven't seen sigfpe
13:51:56 <Kaidelong> since it is idempotent (hopefully) and "id" is a strict function
13:51:57 <hpc> Kaidelong: yeah, didn't have to think about it though :D
13:52:37 <xplat> robryk: if you want to break LESS stuff than unsafeInterleaveIO, you probably want iteratees
13:53:12 <robryk> i don't think so. i want to convert a stream into a stream, roughly one element for one element
13:53:26 <ray> isn't his name samuel igfpe
13:53:46 <Eduard_Munteanu> What? I always thought it stood for SIGFPE
13:53:49 <robryk> my converter doesn't halt of its own accord
13:54:04 <dankna> I thought it stood for signal floating-point exception, yeah
13:54:11 <Eduard_Munteanu> robryk: something like interact?
13:54:11 <alpounet> it does
13:54:22 <robryk> interact?
13:54:32 <alpounet> :t interact
13:54:33 <lambdabot> (String -> String) -> IO ()
13:54:43 <robryk> no
13:54:49 <robryk> mine isn't stateless
13:55:25 <alpounet> http://hackage.haskell.org/package/streams
13:55:39 <Eduard_Munteanu> I've also been using a mapM idiom for Bytestrings.
13:55:41 <alpounet> edwardk has put quite some love in this
13:55:50 <xplat> robryk: i don't think you can use a function of that type and structure for this except by using lazy IO (unsafeInterleaveIO)
13:56:09 <xplat> robryk: i mean, you can try something else, but it will break more, not less
13:56:21 <hpc> :t unsafeInterleaveIO
13:56:22 <lambdabot> Not in scope: `unsafeInterleaveIO'
13:56:27 <robryk> xplat: if i have that function, i can do this without more breakage
13:56:34 <robryk> that == IO () -> a -> a
13:56:41 <kevinburke> hmmm it works on my linux machine
13:56:43 <xplat> robryk: no, you really, really can't
13:56:48 <Eduard_Munteanu> bsMapM_ :: (Monad m) => (Word8 -> m a) -> B.ByteString -> m ()
13:56:49 <Eduard_Munteanu> bsMapM_ f xs = B.foldr (\x acc -> f x >> acc) (return ()) xs >> return ()
13:56:49 <robryk> if i have it i can
13:56:58 <robryk> oh, and IVars
13:56:58 <Eduard_Munteanu> That can keep state just fine.
13:57:15 <xplat> robryk: try it, the function is seq . unsafePerformIO
13:57:44 <Eduard_Munteanu> I wonder why that doesn't already exist in the Bytestrings package.
13:58:04 <hpc> @hoogle unsafeInterleaveIO
13:58:04 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
13:58:10 <hpc> ooh, fun
13:58:52 <alpounet> robryk, why do you wanna stick to that type signature ?
13:59:01 <robryk> i not necessarily want
13:59:11 <xplat> robryk: how will you get any information from the IVars into the pure space if your IO actions aren't returning any value?
13:59:14 <alpounet> there probably is a better way to design this part of your program without actually throwing away safety
13:59:28 <robryk> IVars can be read by a pure action
13:59:47 <robryk> alpounet: reading about streams now
14:00:31 <alpounet> robryk, i'm pretty sure laziness and haskell's I/O model handles what you wanna do just fine
14:00:38 <alpounet> IIUC
14:01:11 <robryk> i'm pretty sure that without using unsafe-ish stuff i cannot do the exact thing i stated
14:01:23 <kmc> when i upload a library to hackage which requires a c library using Extra-Libraries, and the hackage server doesn't have that lib, it fails to build documentation
14:01:41 <kmc> except i find other people's libraries that apparently build the docs despite requiring C libraries which are probably not installed
14:01:46 <kmc> so what am i doing wrong?
14:02:12 <ddarius> 13.5 * 5 / 12
14:02:13 <robryk> that was: have a function Stream a -> Stream b , have an action IO a and b -> IO() and want to combine them without loading everything into memory
14:02:13 <ddarius> > 13.5 * 5 / 12
14:02:14 <xplat> robryk: data-ivar or ivar-simple?
14:02:14 <lambdabot>   5.625
14:02:40 <robryk> ivar-simple
14:03:54 <alpounet> robryk, can you give the type signature for the function you would like to write ?
14:04:40 <robryk> alpounet: in the end i want (Stream a -> Stream b) -> IO a -> (b -> IO ()) -> IO ()
14:05:08 <robryk> and i want it not to try to load the input into memory
14:05:41 <robryk> i mean, at once
14:06:18 <alpounet> the fact that you need such a function looks very odd to me
14:06:26 <robryk> why?
14:06:38 <jmcarthur> there's always just lazy IO and something like mapM_
14:06:39 <robryk> i read a stream from input, process it, and write it out
14:06:53 <alpounet> no
14:06:59 <alpounet> you have a function from a stream to another
14:07:04 <robryk> yes, i know
14:07:08 <robryk> it won't terminate
14:07:12 <alpounet> well
14:07:12 <robryk> i do not care about that
14:07:23 <alpounet> you just don't have a 'Stream a' to feed your function with
14:07:25 <robryk> oh, that should've been probably -> IO x
14:07:28 <ddarius> > exp (-1) / sqrt (2 * pi)
14:07:29 <lambdabot>   0.14676266317373993
14:09:07 <ddarius> > 34 - 15/12
14:09:08 <lambdabot>   32.75
14:09:31 <xplat> IVars are using unsafePerformIO too, i guess
14:09:37 <ddarius> > 15 / 2
14:09:37 <lambdabot>   7.5
14:09:48 <robryk> yes, but they preserve RT, right?
14:10:05 <alpounet> robryk, could you give me a bit more context about what you're doing?
14:10:13 <xplat> robryk: what breakage caused by unsafeInterleaveIO do you plan to eliminate?
14:10:29 <christo_m> xplat: TableConstructor = between ('{' '}' [FieldlList])
14:10:37 <ddarius> > exp 1 / sqrt (2 * pi)
14:10:38 <lambdabot>   1.0844375514192277
14:10:53 <robryk> xplat: i am trying to write a small selfcontainted part which will do unsafe stuff and will be RT
14:11:03 <robryk> alpounet: i have a video stream and produce one
14:11:16 <christo_m> tableconstructor ::= `{ [fieldlist] `}  is that a good translation of this grammar
14:11:20 <christo_m> or production rather
14:11:39 <xplat> christo_m: looks like it
14:11:53 <christo_m> xplat: whew
14:11:55 <alpounet> robryk, so it's like 'Stream Image -> Stream Image' ?
14:11:56 <xplat> christo_m: wait, no
14:11:59 <robryk> yes
14:12:03 <christo_m> xplat: :|
14:12:25 <alpounet> robryk, and how you get the new Stream ? Apply a transformation to each image ?
14:12:31 <xplat> christo_m: you want tableConstructor = between '{' '}' fieldList
14:12:35 <robryk> no
14:12:59 <robryk> i apply a transformation to image and some data extracted from previous images
14:13:00 <christo_m> xplat: what does the [] mean, in grammar productions
14:13:01 <harlekin> What would be the Haskell equivalent of uint64? CULong?
14:13:03 <christo_m> is it just more paranthesis?
14:13:09 <kmc> harlekin, Word64
14:13:12 <kmc> from Data.Word
14:13:25 <kmc> or if you're using hsc2hs, you can write (#type uint64_t)
14:13:40 <christo_m> xplat: ive also defined FieldList = [Field] ie. a list of fields
14:13:50 * hackagebot LinearSplit 0.2 - Partition the sequence of items to the subsequences in the order given  http://hackage.haskell.org/package/LinearSplit-0.2 (VitaliyRukavishnikov)
14:13:50 <harlekin> kmc, I didn't know that. Thank you.
14:13:50 <christo_m> i know thats right because of what you said yesterday, i think.
14:13:52 <alpounet> robryk, ok so, what does IO have to do with your stuffs ?
14:14:00 <kmc> there are many platforms where a c unsigned long is not 64 bits
14:14:08 <robryk> my input stream is read from input and output stream is written to the output
14:14:30 <xplat> christo_m: hm, actually the [] in the original means optional
14:14:45 <xplat> christo_m: so you want between '{' '}' $ opt fieldList
14:14:56 <christo_m> xplat: dollar sign being?
14:15:07 <harlekin> Mh, what exactly must the alignment function in Foreign.Storable implement?
14:15:17 <alpounet> robryk, so what ?
14:15:24 <xplat> christo_m: implicit parentheses, same as between '{' '}' (opt fieldList)
14:15:30 <robryk> well, they are long
14:15:31 <alpounet> that just means you'll have to do your stuffs in the IO monad
14:15:38 <robryk> i am unable to read my whole input to memory
14:16:00 <christo_m> xplat: now what if i have a production with a bunch of definitions, like this
14:16:03 <christo_m> field ::= `[ exp `] `= exp | Name `= exp | exp
14:16:08 <alpounet> that doesn't mean everything you'll use there 1/ will be strictly read entirely into memory 2/ has to get everything and return everything from/to IO
14:16:19 <christo_m> do i use <|> or something to choose which?
14:16:23 <robryk> yes
14:16:29 <ddarius> > 15*5 /12
14:16:30 <lambdabot>   6.25
14:16:38 <robryk> and i want to do it so that both 1 and 2 will not hold
14:16:49 <alpounet> basically, as long as you do not force the evaluation of stuffs, you'll have your producer/consumer thingy
14:16:56 <robryk> no i don't
14:17:08 <robryk> if my `producer' is an IO action
14:17:10 <robryk> it cannot be so
14:17:20 <robryk> because that will cause input and output actions to overlap
14:17:31 <alpounet> http://book.realworldhaskell.org/read/io.html#io.lazy
14:17:49 <xplat> robryk: your stuff is not actually RT, and i'm not at all convinced it will do a better job of faking RT than the builtin lazy IO does
14:18:16 <christo_m> xplat: ?? sorry , i know your busy
14:18:24 <christo_m> its just i literally have no other resources right now besides what you tell me
14:18:58 <robryk> i think that i might make it RT if inputting and outputting happens in two different threads
14:19:01 <xplat> christo_m: don't you actually have the entire internet?  and the documentation for parsec, and tutorials for parsec ...
14:19:16 <christo_m> xplat: right, but, your right hereeeee
14:19:30 <xplat> christo_m: nonetheless i'll tell you, you do use <|>
14:19:50 <christo_m> perfect,
14:19:54 <christo_m> thank you sir
14:20:53 <xplat> christo_m: but please, if you have any more questions, ask someone else, because i'm pretty sure i already told you every bit of info that you will need to complete your parser
14:21:53 <azaq23> updating your internet search & evaluate skills > asking who is here right now in the long term
14:22:06 <xplat> robryk: it doesn't matter to RT if things are happening in the same or different threads
14:23:59 <xplat> threads are not even part of the evaluation model of pure values in haskell, so if you can distinguish same thread from different thread your RT is already gone ...
14:24:21 <robryk> a moment, i will write what i mean
14:24:55 <robryk> oh, ok, i was saying stupid things
14:25:31 <ddarius> > exp (-0.5) / sqrt (2 * pi)
14:25:32 <lambdabot>   0.24197072451914337
14:25:52 <robryk> generally i want a function of type (Stream a -> Stream b) -> IO a -> (b -> IO ()) -> IO x
14:26:00 <ddarius> > 5*exp (-0.5) / sqrt (2 * pi) / 12
14:26:01 <lambdabot>   0.10082113521630974
14:26:01 <kmc> so any ideas about the hackage / extra-libraries problem?
14:26:17 <robryk> and this function won't break anything.
14:26:25 <robryk> ok, thanks for all help.
14:30:54 <xplat> lazyRepeatIO :: IO a -> IO a ; lazyRepeatIO act = liftM (<:) act unsafeInterleaveIO lazyRepeatIO act -- am I using unsafeInterleaveIO right?
14:31:25 <xplat> er
14:31:33 <xplat> lazyRepeatIO :: IO a -> IO a ; lazyRepeatIO act = liftM (<:) act $ unsafeInterleaveIO lazyRepeatIO act -- am I using unsafeInterleaveIO right?
14:32:39 <robryk> i think not
14:32:59 <freedrull> good vim plugins for haskell, anyone?
14:33:08 <robryk> i think in this statement, forcing evaluation of a stream element doesn't force evaluation of its value
14:33:57 <robryk> so i can evaluate it to closure :< closure, then to closure :< closure :< closure and then to closure :< value :< closure
14:34:11 <robryk> and then the second element of the stream would get first element from input
14:35:27 <xplat> no, i think i am right.  the unsafeInterleaveIO is at the tail of the stream, not the head
14:35:39 <xplat> if it were at the head, it would break like you say
14:35:52 <robryk> oh, right, sorry
14:36:21 <sgronblo> What's the point of using let bindings in a do block? Looking at this example with reading a first and last name in learn you a haskell's IO chapter? Is it just for declaring a temporary variable?
14:36:27 <xplat> lazyRepeatIO act = unsafePerformIO $ liftM (<:) act $ lazyRepeatIO act would also work fine, maybe even better
14:36:57 <ezyang> sgronblo: Yes. 
14:37:29 <sgronblo> ezyang: Ah thanks, so it's not strictly necessary to use them then I guess.
14:37:36 <harlekin> I'm trying to write a FFI to statfs. I have a C and a Haskell program which should do the same thing. However, I seem to have an offset problem (last annotation). Could someone take a look and give me a hint what could go wrong? http://hpaste.org/paste/44147/statfs_ffi_annotation#p44150
14:37:56 <ezyang> sgronblo: If you do a pure computation wedged between monadic ones, a let binding can make a great deal of sense. 
14:38:04 <ezyang> But you can do a lot with fmap and <$> :-) 
14:38:17 <azaq23> sgronblo: Every let binding inside a do is converted into something of the form let ... in do ... (without let bindings in the do block), so it was likely introduced to support let bindings in the "statement order" of a do block, but it isn't really relevant.
14:38:53 <ezyang> harlekin: Write out the numbers in hexadecimal and see how far off your offset is. 
14:39:28 <ezyang> Things Edward dislikes, partial list: non-statically typed pointer tagging 
14:39:57 <harlekin> ezyang, I checked with the generated .hs file. I think the offsets are right, at least if int32 is 4 bytes and uint64 is 8 bytes long. I'll try that, though.
14:40:20 <aristid> ezyang: you refer to yourself as "Edward"? or did you mean edwardk?
14:40:54 <ezyang> My first anme is Edward. 
14:41:46 <ddarius> ezyang: Clearly you need to choose another name.
14:42:05 <ezyang> :-) 
14:42:15 <Olathe> Error: name is in use.
14:42:19 <Twey> Error: insufficiently unique identifier
14:42:20 <ezyang> Some commenters on my blog have taken to calling me Eric. 
14:42:22 <kmc> are you using hsc2hs harlekin?
14:42:33 <aristid> ezyang: um, you could refer to yourself as "I"
14:42:38 <ezyang> But I don't have the heart to correct them... 
14:42:44 <aristid> ezyang: unless you cloned yourself, that is completely unambiguous
14:42:47 <kmc> sgronblo, the point is the same as outside of "do"
14:43:05 <ezyang> "but Edward likes third person!" 
14:43:26 <dankna> that's hilarious, re commenters getting your name wrong
14:52:07 <Adamant> ezyang: Radical Edward Z. Yang?
14:52:34 <ddarius> Especially seeing as it says his name on the very same page that they just (allegedly) read and on the page they enter comments.
14:53:50 <shachaf> ddarius: What is the origin of "ddarius"?
14:55:04 <harlekin> kmc, I am. I found out, if I use Int32 for every field in the struct it is working. I don't know why hsc2hs makes a wrong guess.
14:55:18 <harlekin> kmc, or maybe I was reading the C header wrong.
14:55:35 <ddarius> I like the name Darius so that was my nick, but then Darius Bacon would occasionally show up and I figured he had a better claim on the nick than I, so I prepended a 'd' from "Derek."
14:56:17 <kmc> harlekin, what's the C header say?
14:56:34 <ddarius> I would've switched to Derek but that's definitely taken.
14:56:41 <harlekin> kmc, I thought it said that some field were of type uint64.
14:56:43 <kmc> harlekin, are you using #offset?
14:57:00 <kmc> harlekin, i mean could you hpaste the headeR?
14:59:35 <harlekin> kmc, http://hpaste.org/44152/bitsstatfsh
15:00:48 <harlekin> kmc, maybe I have __USE_FILE_OFFSET64 enabled and __fsblkcnt_t is the same as __SWORD_TYPE? That'd make sense. However, can I tell hsc2hs to figure that out?
15:01:01 <harlekin> Making things more portable.
15:01:59 <kmc> itym "__USE_FILE_OFFSET64 disabled"
15:02:20 <kmc> and you can use the hsc2hs #sizeof directive
15:02:27 <kmc> but i don't know how to set the type directly from that
15:03:01 <harlekin> kmc, okay. Thanks so far. (:
15:03:04 <kmc> perhaps just
15:04:07 <kmc> http://hpaste.org/44153/kmc
15:04:10 * kmc fails at author /title
15:04:42 <kmc> harlekin, if i'm reading hsc2hs docs right, those preprocessor directives will appear in the C file that prints out your .hs file
15:04:48 <kmc> so only one of the two lines will get printed
15:05:01 <kmc> (that is to say, they aren't passed through to the .hs file, and you don't need to turn on -XCPP as a result)
15:05:46 <harlekin> Thank you very much. (:
15:06:09 <Twey> kmc: I always do that
15:06:51 <Twey> @tell chrisdone Please swap the title/author fields :<
15:06:51 <lambdabot> Consider it noted.
15:06:57 <kmc> oh no
15:10:59 <TTimo> ok are there any subtle pitfalls when getting ghc 7 installed that I should be aware of? (Debian x86_64 - I'd like to keep the official 6.x packages as well)
15:12:17 <mreh> can I manually fix category-extras to not conflict with transformers?
15:12:19 <Zao> TTimo: Considering installing it in some off place like /opt or something, so you don't clobber the usual ghc symlinks.
15:12:32 <TTimo> zao: k
15:12:34 <mreh> without resorting to installing ghc7 as i've see
15:12:35 <mreh> n
15:13:10 <TTimo> the stuff I'm more worried about is the platforms / cabal stuff ?
15:17:32 <burp> there are no problems
15:17:58 <TTimo> ah :)
15:17:58 <burp> ghc 7 installs into /usr/local by default
15:18:32 <monochrom> don't use the default if you ever intend to have several ghc's at the same time
15:18:55 <burp> well, debian has 6.12 in it's repository
15:19:01 <sgronblo> Why can't i do import qualified System.Random in ghci?
15:19:06 <burp> and when you install 7 in /usr/local there is no problem
15:19:35 <monochrom> and when you add 7.0.2 to /usr/local there is a little problem
15:19:36 <TTimo> oh there's even binaries
15:19:43 <mreh> sgronblo: the command is :m + System.Random
15:19:51 <mreh> is that what you're looking for?
15:19:53 <hpc> mreh: but it doesn't qualify
15:20:01 <hpc> import becomes :m+
15:20:09 <burp> if you wanted to have 7 _and_ 7.0.2? yes
15:20:36 <sgronblo> So what is :add for then?
15:20:54 <mreh> oh, yeah, you're probably stuck with explicitly naming each function that clashes with another
15:21:01 <dankna> wait, is 7.0.2 out?
15:21:36 <monochrom> or you already have debian's 6.12.1 but you want to add 6.12.3 and 7.0.1 to /usr/local
15:22:39 <monochrom> there are a combinatorical explosion of combinations of "several ghc's" people will want to install more than merely "one from debian, one from myself"
15:22:40 <burp> doesn't ghc use version dependent paths anyway? for me it does
15:22:44 <alpounet> dibblego, haha for the disease (cf twitter)
15:22:46 <mreh> do we got Functor Applicative and Monad instances in ghc7 then?
15:22:54 <burp> I have /usr/local/lib/ghc-7.0.1 and /usr/local/bin/ghc-7.0.1 etc.
15:23:12 <mreh> @instances Functor
15:23:13 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
15:24:03 <monochrom> not for haddock, hp2ps, hpc, hsc2hs, runghc, runhaskell
15:24:56 <burp> seems they're migrating more stuff to this scheme, I have haddock which symlinks to haddock-7.0.1
15:25:00 <monochrom> it is a little problem and I carefully said "a little problem" but it is definitely not a clean absolute "no problem"
15:25:26 <burp> but for older versions it's surely wise to manually choose custom paths
15:25:55 <burp> I understood his question just like one custom + one debian
15:26:49 <monochrom> everything who eventually installs 5 ghc's, all of them thought at the beginning "I just want one".
15:27:53 <burp> well, I know that I just want to follow the latest 7, and still keep debians
15:28:01 <mreh> sounds like a serious addiction
15:28:09 <sgronblo> How do I check what type : has?
15:28:20 <burp> sgronblo: brackets (:)
15:28:23 <mreh> you sound like my boss, he's obsessed with the latest version of everything
15:28:26 <azaq23> :t (:)
15:28:27 <lambdabot> forall a. a -> [a] -> [a]
15:28:33 <mreh> software related atleast
15:28:53 <burp> mreh: um, ghc 7 has cool new features
15:28:54 <sgronblo> ah thanks
15:29:30 <hpc> mreh: my boss is running a debian version that's a decade old, on state-of-the-art hardware
15:29:34 <hpc> just because it's more stable
15:29:43 <mreh> high five
15:29:48 <hpc> indeed
15:29:50 <mreh> it's the way it should be
15:29:51 <aristid> hpc: a _decade_ old?
15:30:03 <hpc> aristid: more or less
15:30:11 <Adamant> hpc: fully patched?
15:30:15 <mreh> they had haskell in the past?!
15:30:27 <hpc> definitely patched
15:30:40 <hpc> it's a hella secure server
15:30:55 <Adamant> mreh: Haskell is about as old as Python, aktually. it got a reinvigoration with monads in ~2000
15:30:58 <hpc> it even has minimal php presence
15:31:29 <burp> I'm not sure patching old stuff with backported security patches is more secure than using new software in first place
15:31:40 <Adamant> burp is right, that's questionable.
15:31:42 <robryk> are there even patches backported so far back?
15:32:09 <robryk> i doubt kernel patches get backported significantly back
15:32:18 <hpc> not sure if it's a decade old, but it's definitely not the latest
15:32:21 <Adamant> 2.4 is still being maintained
15:32:23 <Adamant> IIRC
15:32:27 <Adamant> yah
15:32:47 <hpc> i vaguely recall it being that old though
15:34:09 <mreh> what's a php presence?
15:34:22 <Adamant> letting php run on your system, I assume
15:34:26 <mreh> heh
15:34:42 <Adamant> protip: do not want
15:35:19 <mreh> i just spent an extra half hour making backuppc users on each of my machines with sudo access to rsync, because it's more secure than root access, he sounds like my kind of guy
15:35:59 <mreh> i also read rsa keys without passphrases are useless
15:36:15 <Adamant> they're useless if someone has access to your accout
15:36:23 <hpc> @src Int
15:36:23 <lambdabot> data Int = I# Int#
15:36:29 <Adamant> of course if someone has access to your account, they just steal your passphrase.
15:36:43 <mreh> well quite
15:36:53 <mreh> you need my private key to do any damage
15:38:07 <kmc> if someone has access to your account, they can trojan your shell and steal your passphrase
15:38:13 <Adamant> right
15:38:20 <sgronblo> Any idea why my use of : would expect a [m Int]?
15:38:23 <mreh> still no word on this category-extras conflict with transformers, it's orphan instances of Either
15:38:33 <mreh> sgronblo: depends on the context
15:38:37 <Adamant> and they're probably scheming some method of privilege elevation anyway.
15:38:41 <dobblego> mreh: I've hit that many times and complained to edwardk
15:39:03 <mreh> dobblego: apparently the instancs are in base-4
15:39:03 <sgronblo> mreh: Is it determined by the type of the first parameter to : ?
15:39:28 <dobblego> mreh: yes, and I once tried to fix it with a 10 minute time limit, and failed
15:39:32 <burp> :t (return (1::Int) :) -- sgronblo 
15:39:33 <lambdabot> forall (m :: * -> *). (Monad m) => [m Int] -> [m Int]
15:39:39 <mreh> sgronblo: it really depends on the context
15:40:12 <mreh> try putting in some explicit type annotations to track down the type error
15:40:35 <sgronblo> oh so m is some kind of monad stuff?
15:40:46 <mreh> sgronblo: quite often
15:40:53 <burp> yeah, most probably
15:40:58 <mreh> infact, exclisively in my experience
15:41:30 <mreh> that's not a made up word
15:42:06 <mreh> dobblego: bum, fix it how exactly? change the sources having d/l ghc7
15:42:15 <sgronblo> http://pastebin.com/LbPjCCUz this is what I'm trying to do
15:42:26 <dobblego> mreh: yeah I twiddled in the source of category-extras
15:42:57 <mreh> did you change the dependencies accordingly?
15:43:12 <burp> sgronblo: brackets
15:43:21 <burp> :t return 1 : [2]
15:43:22 <lambdabot> forall t (m :: * -> *). (Num t, Monad m, Num (m t)) => [m t]
15:43:25 <burp> :t return (1: [2])
15:43:26 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m [t]
15:43:35 <mreh> :t return $ 1 : [2]
15:43:36 <lambdabot> forall (m :: * -> *) t. (Monad m, Num t) => m [t]
15:43:42 <burp> or that, sure
15:44:01 <mreh> function application has higher precendence than operators
15:44:13 <sgronblo> burp: argh :)
15:44:14 <mreh> burp: fewer characters :)
15:44:35 <Saizan> mreh: don't you just have to comment out half of category-extras' Control.Monad.Either ?
15:45:05 <mreh> Saizan: i'm guessing just the instances, but I haven't tried it yet
15:45:23 <mreh> why can't I just hide transformers and not use it?
15:45:24 <Saizan> that's what i meant
15:45:28 <sgronblo> Was ghc interpreting it as (return Int) : [Int]?
15:45:35 <mreh> despite being an insanely useful package
15:45:44 <Saizan> mreh: those instances are not in transformers, they are in the base package
15:45:55 <mreh> Saizan: i'm ghc6
15:46:13 <mreh> time to upgrade?
15:46:13 <Saizan> ah
15:46:19 <BMeph> sgronblo: Of course it was. Why, how would you do it? ;)
15:46:45 <Saizan> no idea
15:47:26 <sgronblo> I guess I'm starting to see the appeal of Lisp :)
15:48:01 <BMeph> sgronblo: ?
15:48:20 <sgronblo> No chance for me to mess up with the precedence
15:51:26 <tg_> usually, if you want to learn something, you have to seek it out
15:51:30 <tg_> err, wrong channel
15:51:50 <dino-> tg_: I don't know. May be appropriate here as well.
15:51:52 <sgronblo> well that sounds like a comment appropriate for any channel
15:51:58 <tg_> hehe. ;)
15:52:20 <tg_> i came to an incorrect conclusion about a quantum observable of the LHC
15:52:35 <tg_> and I was corrected by a younger, less knowledgable student :O
15:52:59 <dankna> How fortuitous!  Usually I must leave my lair in order to feed.
15:52:59 <tg_> I was relishing in the fact that when someone points out your wrongness so completely, that it is refreshing because it presents an immediate opportunity for learning
15:53:15 <tg_> instead of you having to go follow some trail on your own
15:54:33 <tg_> dankna: you said it better than me
15:54:39 <dankna> why thank you
15:54:43 <dankna> I was quoting World of Warcraft :)
15:54:50 <dankna> but it seemed appropriate!
15:56:37 <dankna> okay, #haskell, it's pop quiz time!
15:56:46 <tg_> POP QUIZ HOT SHOT
15:57:09 <dankna> I am writing two small modules, one for quaternions and one for 2- and 3-vectors, in both cases parameterized on floating-point types.
15:57:17 <dankna> I wish to place them next to each other in the namespace.
15:57:30 <dankna> should they go in a) Data, b) Numeric, c) Fill in the blank?
15:57:38 <mreh> this namespace ain't big enough for the two of us
15:57:42 <dankna> gasp
15:57:45 <dankna> you wouldn't!
15:58:14 <mreh> are they data, or are they numbers?
15:58:24 <dankna> well, they're /kind of/ numbers
15:58:36 <dankna> in the same sense that complex numbers are numbers
15:59:02 <dankna> a quaternion is a four-dimensional analogue to a complex number, in fact
15:59:15 <dankna> (there's also something called an octernion, but nobody uses them.  but quaternions are quite useful.)
15:59:20 <dobblego> do any of you run hakyll for a blog?
15:59:27 <tg_> dankna: there are already several packages for quaternions
15:59:31 <dankna> I couldn't find any
15:59:31 <rwbarton> and yet complex is in Data.Complex
15:59:34 <tg_> and people do use octonions
15:59:35 <mreh> danka homogeneous co-ordinates?
15:59:46 <dobblego> (or know of one, such that I may examine its source)
15:59:53 <dankna> not me, dobblego
16:00:07 <dankna> @hoogle quaternion
16:00:07 <lambdabot> No results found
16:00:09 <dankna> @hoogle quat
16:00:09 <lambdabot> No results found
16:00:11 <dankna> @hoogle Quat
16:00:11 <lambdabot> No results found
16:00:23 <tg_> http://hackage.haskell.org/packages/archive/numeric-prelude/0.1.3.4/doc/html/Number-Quaternion.html
16:00:30 <dankna> oh hey
16:00:32 <dankna> lookit that
16:00:52 <dankna> cool, it even has a slerp function
16:00:53 <tg_> dankna: did you see the links earlier to n-Category Cafe?
16:01:02 <dankna> I did not!
16:01:06 <tg_> http://golem.ph.utexas.edu/category/
16:01:12 <burp> dobblego: mm_freak runs one
16:01:30 <ddarius> dankna: There is little point in making quaternions and not having a slerp function.  Admittedly, there is little point in making quaternions.
16:01:30 <tg_> http://math.ucr.edu/~huerta/
16:01:36 <dobblego> burp: cheers
16:01:40 <tg_> ddarius: shame!
16:01:42 <dankna> ddarius: bah!  humbug :)
16:01:51 <dankna> ddarius: I hope you mean, there's little point in it because it's already been done!
16:02:03 <tg_> ddarius: as Huerta and Baez discuss
16:02:14 <tg_> quaternions are good for a natural representation of the Weyl spinors of electrons
16:02:19 <ddarius> dankna: No.  There is little point because there are better things than quaternions that do everything quaternions do and then some.
16:02:23 <dobblego> burp: any idea where he keeps his source?
16:02:33 <dankna> well, I use them to represent orientations in 3-space for graphics and games.
16:02:38 <dankna> they are more numerically stable than matrices.
16:02:41 <ddarius> dankna: Look up geometric algebra.
16:02:51 <dankna> meaning less loss of stuff through floating-point precision.
16:02:53 <dankna> looking.
16:03:02 <ddarius> dankna: Quaternions are the even sub-algebra of the three-dimensional geometric algebra.
16:03:05 <tg_> ddarius: you are forgetting the case of strongly Integral quaternions
16:03:11 <burp> dobblego: no, but after we highlighted him, he might answer soon (it's ertes.de)
16:03:25 <tg_> and the complex conjugate forms
16:03:26 <ddarius> tg_: Quaternions are still interesting from an algebraic perspective.
16:03:27 <dobblego> burp: cheers
16:03:35 <dankna> greh http://en.wikipedia.org/wiki/Geometric_algebra is unreadable to me :(
16:03:36 <tg_> ddarius: ok, in what sense are you saying they are not interesting?
16:03:45 <ddarius> dankna: You shouldn't read that anyway.
16:03:50 <tg_> dankna: http://golem.ph.utexas.edu/category/2009/02/new_structures_for_physics_iii.html
16:04:01 <ddarius> dankna: You'd probably find Leo Dorst's page most approachable.
16:04:26 <ddarius> dankna: Though, if you are interested in physics, I highly recommend David Hestenes' page and the Cavendish page.
16:04:30 <tg_> dankna: http://golem.ph.utexas.edu/category/2010/12/division_algebras_and_quantum.html
16:04:39 <tg_> ddarius: where were you when I was discussing such things earlier? I must have missed you
16:04:57 <dankna> tg: you are linking me things faster than I can glance over them, think "that looks interesting", and minimize the tab to read later
16:05:04 <dankna> tg: this is causing a buffer overrun in my brain.  please stop.
16:05:13 <dankna> ddarius, http://staff.science.uva.nl/~leo/clifford/ ?
16:05:15 <tg_> dankna: yeah, I expect you to bookmark and look later
16:05:19 <dankna> okay, haha
16:05:55 <tg_> he probably means http://geocalc.clas.asu.edu/
16:05:58 <tg_> "gemoetric calculus"
16:06:07 <tg_> that's David Hestenes's page
16:06:17 <ddarius> tg_: That's David Hestenes' page, dankna linked Leo Dorst's page which I also recommended.
16:06:25 <ddarius> Leo Dorst's page is much more CS oriented.
16:06:29 <tg_> ddarius: it seems to have more implementation than theory
16:06:38 <djahandarie> @tell edwardk Have you considered adding foldr/build fusion to all Foldables? It should be possible: http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/
16:06:38 <lambdabot> Consider it noted.
16:06:39 <tg_> which I suppose to a person wanting to implement in Haskell would be a good thing
16:06:52 <dankna> yeah, I am at home with algorithms.  Not at home with having to keep ten new operator symbols straight in my head for thirty pages to get to the punchline.
16:07:10 <dankna> give me the algorithms and I'll know whether the theory is sound anyway
16:07:10 <tg_> dankna: I assume the point of all this is that Clifford algebras are the superset of all of tese things
16:07:21 <dankna> tg: that seems to be the point, yes
16:07:30 <dankna> I am reading http://staff.science.uva.nl/~leo/clifford/talknew.pdf now
16:07:35 <ddarius> dankna: You'll want http://www.science.uva.nl/ga/ which is linked on that Dorst page.  It has more or less the same information.
16:07:42 <dankna> oh, good
16:08:03 <tg_> basically, with clifford algebras
16:08:08 <tg_> the special cases are D=2, 4, 8, and 16
16:08:19 <tg_> with 3 being special for different reasons
16:08:19 <ddarius> djahandarie: Foldable is basically toList, so everything should follow.
16:08:53 <tg_> but they are Complexes, Quaternions [lose commutativity], Octonions [lose associativity], whatever 16 dimensional ones are...
16:09:06 <dobblego> newtype Foldable f = forall a. Foldable (f a -> [a]) ?
16:09:06 <djahandarie> ddarius, I meant his Foldable, not Data.Foldable
16:09:07 <tg_> I found John Baez's page on octonions to be very helpful for learning about quaternions too
16:09:17 <ddarius> djahandarie: What is his Foldable?
16:09:22 <djahandarie> ddarius, https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs
16:09:57 <tg_> dankna: last link: http://math.ucr.edu/home/baez/octonions/octonions.html
16:10:08 <tg_> that's very concise, straightforward, with nice layout
16:10:11 <djahandarie> i.e., generalize foldr/build fusion to any recursion structure
16:10:16 <ddarius> djahandarie: Yes, foldr/build fusionn will apply to that.
16:10:19 <tg_> if you understand octonions, you undestand quaternions
16:10:25 <djahandarie> recursive*
16:10:38 <djahandarie> ddarius, right, but it isn't there yet ;)
16:10:39 <dankna> mm.  I understand quaternions already.  do I need to understand octonions as well? :)
16:10:49 <tg_> dankna: to understand clifford algebgras in general, yes
16:10:58 <dankna> that's weird spelling.  it makes me think of an octohedral onion.
16:11:04 <rwbarton> octonions aren't a clifford algebra
16:11:10 <ddarius> tg_: Clifford algebras are associative.
16:11:33 <tg_> ddarius: yes, which makes them the first special case
16:11:39 <tg_> where clifford algebras don't fit
16:11:41 <tg_> yes?
16:11:58 <ddarius> tg_: Clifford algebras generalize in a different direction than that hierarchy.
16:12:15 <ddarius> They just happen to include quaternions as well.
16:12:50 <tg_> ddarius: when I studied them last year, I remember writing down that it was important to understand octonions to understand the features that clifford algebras don't have
16:13:21 <dankna> hm.  what do we think of http://www.amazon.com/Geometric-Algebra-Computer-Science-Revised/dp/0123749425/ref=ed_oe_h ?
16:13:39 <ddarius> Well I guess that makes sense, but there are plenty of things which aren't geometric algebras.
16:13:41 <dankna> for all values of "we" equal to ddarius?
16:14:02 <tg_> I presume he highly recommends it
16:14:05 <ddarius> dankna: I haven't read it, but I don't think it would be terribly useful.
16:14:11 <tg_> but I also presume much of the same info is available on his website
16:14:14 <dankna> tg_: see, that's why I asked :)
16:14:22 * tg_ shoots himself in the recommend-a-face
16:14:23 <ddarius> I have a website?
16:14:44 * djahandarie has secretly been compiling everything ddarius has ever said into a website
16:14:45 <tg_> dankna: on Leo Dorst's website
16:14:55 <tg_> [he] is the author of that book
16:15:12 <tg_> dankna: is this for games, again?
16:15:18 <tg_> you are represnting spatial rotations in games?
16:15:19 * dankna hmms and downloads GAViewer
16:15:42 <dankna> tg_: well, you've distracted me so much that I've wholly forgotten WHY I got onto the subject of "I think I'll port my quaternion and vector code to Haskell"
16:15:50 <dankna> tg_: but that would be one major application, yes
16:16:15 * ddarius usually implements bivectors, spinors, and vectors (and points!) directly for simple-ish 3D code.
16:16:29 <tg_> dankna: yeah, there are books about that very subject (using quaternions for rendering in games
16:16:30 <dankna> I was mostly looking for a short relaxing bit of coding I could do in an hour or two without solving any deep problems
16:16:48 <tg_> re-implement Number.Quaternion as a Data
16:16:56 <dankna> tg_: yes, I am familiar with the applications of quaternions to games.  ddarius is telling me this "geometric algebra" is better.
16:17:05 <tg_> dankna: it's more general
16:17:07 <dankna> and that I should spend my evening learning how to use it, instead
16:17:21 <ddarius> dankna: Go through these: http://www.science.uva.nl/ga/publications/CGnA.html
16:17:42 <dankna> well, I understood the assertion to be something along the lines of "for all problems you are attempting to solve small portions of with quaternions, you can solve larger portions of them with geometric algebra"
16:17:44 <hpc> @quote oasis
16:17:44 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
16:17:49 <dankna> yes, I'm doing that now
16:18:06 <ddarius> It's not just that it's "more general," so is tensor analysis.  It's that it's more general while actually being simpler, more enlightening, and useful in many, many other areas.
16:18:13 <dankna> right
16:18:17 <dankna> I appreciate that
16:18:34 <dankna> I would not buy into it even to the extent of entertaining your link-flurry if I didn't hear that part
16:18:38 <tg_> dankna: I was objecting because there are a few cases (specifically in physics) where quaternions (or other verisons of them, bi- or split- or complex-conjugated) have unusual properties that probably aren't captured by a more general subject
16:18:44 <tg_> but I'm gonna have to read this geometric algebra thing anyway
16:18:47 <dankna> tg_: okay.  but yeah.
16:19:04 <tg_> and those few cases, are the cases where I'm interested in them :)
16:19:12 <dankna> hm
16:19:18 <dankna> what is GAViewer written in I wonder
16:19:21 <dankna> gui library
16:20:03 <ddarius> The thing about geometric algebra is that it's not (just) for some crazy esoteric branch of physics that no one cares about (though there is such a thing built about Clifford algebras), but it significantly simplifies basic Newtonian mechanics and classical electrodynamics, and SR/GR/QM.
16:20:14 <dankna> well, neat
16:21:16 <tg_> ddarius: it is a relatively recent unification of concepts, though, yes?
16:21:39 <ddarius> tg_: It's not so much a unification of concepts, as a better, more unified language.
16:22:08 <tg_> I didn't know it goes all the way back to Grassman
16:22:16 <dankna> so.  ddarius.  are you aware of a GA library in Haskell?
16:22:41 <tg_> dankna: http://blog.sigfpe.com/2006/08/geometric-algebra-for-free_30.html
16:22:54 <ddarius> dankna: I think there have been a couple made.  I know I've made small ones a few times, but I don't think there is anything signifcant/compelling.
16:23:06 <dankna> okay
16:23:19 <ddarius> dankna: The thing is, ideally you want to use the language generally, and for performance you'll want to domain specific specializations like crazy.
16:23:32 <tg_> dankna: it will be more than 2 hours, but if you want to write a GA library for haskell, I'd help
16:23:33 <ddarius> Jaap Suter's C++ Clifford library gives an idea of how it should be approached.
16:23:43 <dankna> tg_: I think I do want to, but let me work through these tutorials first!
16:23:52 <tg_> dankna: ok
16:24:06 <dankna> are you going to be around in about half an hour when I emerge from the stack of reading material?
16:24:11 <ddarius> You could also embed GA into linear algebra, but that's wildly less efficient.
16:24:21 <dankna> yes, the whole point seems to be to get away from linear algebra
16:24:21 <tg_> dankna: I'll be here most of the night. PM me anytime
16:24:25 <dankna> great, will do
16:24:55 <ddarius> dankna: Not exactly.  The way I describe it is that it provides a lot more structure than tensor algebra typically does.
16:24:56 <tg_> ddarius: I'll read some of this literature and see what I think
16:25:10 <dankna> well, okay
16:25:15 <tg_> ddarius: the tensor algebra thing totally breaks down with QM / SM / QFT, yes?
16:25:42 <ddarius> Instead of having some T and asserting that T(a,b) = -T(b,a), we just say T(x,y) = x/\y and anticommutativity is obvious.
16:26:01 <ddarius> What's SM?
16:26:06 <tg_> standard model
16:26:07 <dankna> @wtf anticommutativity
16:26:08 <lambdabot> Maybe you meant: bf ft wn
16:26:27 <tg_> which is a group product structure
16:26:47 <tg_> it doesn't include spin(2) things, so it doesn't include tensors
16:26:50 <tg_> is my understanding
16:27:26 <ddarius> tg_: I wouldn't thing so.  Tensor algebra is just multivariable linear algebra.  It's a pretty general.
16:27:33 <ddarius> s/thing/think
16:27:51 <ddarius> s/multivariable linear algebra/multilinear algbra/
16:28:21 <tg_> ddarius: from my understanding, the first place that Grassman algebras come into play is SUSY
16:28:46 <tg_> but my foundational math is rustier than my physics
16:28:49 <tg_> i'll read and get back to you
16:29:10 <ddarius> Well, if you have a structure that can support the exterior product but not the inner product, then Grassman algebras are very relevant.
16:29:53 <tg_> yeah, but you need inner products in QM..?
16:29:57 <tg_> like I said, let me get back to you :)
16:30:07 <tg_> surely I don't want to compound the list of incorrect things I've said this evening
16:30:48 <ddarius> Grassman algebra + inner product = Clifford algebra.  And Clifford algebras are embeddable into linear algebra (at the cost of using (2^n)x(2^n) matrices.)
16:35:43 <ddarius> tg_: As a note, the Real->Complex->Quaternion->Octonion hierarchy is what you get when you try to generalize as much as possible while still being a division algebra.  Geometric algebra discards division at the door.  Only in the 2D geometric algebra (or below) is division possible in general.
16:37:05 <tg_> that's a much better statement than what I said, I agree
16:37:28 <tg_> and physics (qm and onward) couldn't care about being a division algebra
16:37:48 <tg_> and when I said grassman algebra, I only meant to imply grassman numbers (are used in SUSY)
16:38:02 <tg_> and are not used anywhere else in physics
16:38:15 <tg_> to my knowledge
16:39:45 <ddarius> (or I should say, GA discards being able to divide in general at the door.  It ends up providing a lot more chances for division that vector algebra, e.g. you can divide by any vector.)
16:40:00 <tg_> ddarius: weird
16:40:34 <tg_> ddarius: any idea about the compatibility with fractal groups and GA?
16:40:49 <tg_> and/or fractal groups that generate complex representations from Integers
16:41:04 <tg_> or something like Z/nZ -> C
16:42:38 <ddarius> I don't know anything about fractal groups.
16:43:06 <tg_> ok. I need to take my puppy for a run, I'll be back in an hour or so
16:43:11 <ddarius> dankna: http://www.science.uva.nl/ga/publications/inner_chapter.pdf is an innocuous sounding paper, but turns out to be extremely useful for developing computational techniques.
16:43:13 <tg_> thanks for the chat ddarius and dankna
16:43:24 * ddarius really, really needs to get a dog.
16:44:20 <dankna> looking
16:44:30 <dankna> why do you need to get a dog?
16:44:53 <companion_cube> to eat it
16:45:24 <aristid> to get to walk out regularly? :D
16:45:31 <tg_> i got me one of these: http://i.imgur.com/8P9au.jpg
16:45:40 <tg_> a Lincoln :O
16:45:46 <dankna> aww
16:45:49 <tg_> aka a Wheaton Terrier
16:45:54 <tg_> he's a joy :)
16:46:34 <ddarius> dankna: Because I've spent most of my life with multiple dogs around and dogs are way, way better than people.
16:47:04 <companion_cube> they do not talk about haskell, though
16:47:07 <dankna> fair enough
16:47:15 <tg_> companion_cube: speak for yourself
16:47:17 <tg_> mine does
16:47:23 <companion_cube> :o
16:47:31 <tg_> I lost my translator, though
16:47:32 <companion_cube> i'd like to see it :)
16:47:50 <tg_> i am pretty sure 'woof' means functor
16:47:56 <ddarius> companion_cube: That's okay.  I don't talk about Haskell either.
16:48:25 <monochrom> get a computer. better than dogs.
16:48:34 <ion> The concept of higher-order functions is quite easy to teach to dogs. They seem to struggle with stuff like monads, though.
16:48:58 <geheimdienst> a computer can show lolcats. ergo a computer is better than a dog. qed.
16:49:23 <dankna> cats, in contrast, already understand higher-order functions.  they just can't explain what they know.
16:49:49 <ddarius> dankna: Are you sure the cats just are deigning to explain it to you?
16:50:00 <geheimdienst> no they don't care. they know monads and know that you'd like a tutorial, but they just can't be assed to explain it to you.
16:50:20 <ddarius> +not
16:51:41 <dankna> ddarius: also possible.
16:51:42 <ion> Cats like feeling superior to you. Teaching concepts such as monads to people wouldnt be in their best interests.
16:52:27 <ion> Thats pretty much the reason nobody has learned monads from a cat.
16:52:34 <ben> http://i.imgur.com/Iq8wT.gif someone spin a metaphor for monads around this cat, tia
16:52:59 <dankna> hahaha
16:52:59 <dankna> nice
16:53:04 <hpc> > unsafeLaserPoint
16:53:04 <lambdabot>   Not in scope: `unsafeLaserPoint'
16:53:17 <hpc> *unsafePointLaser
16:53:21 <dankna> looks more like unsafeSteppedOnTowel
16:53:30 <TTimo> side effects
16:53:36 <geheimdienst> yes, it's all the rage now. check youtube, there's quite some videos for "kitty bowling"
16:53:43 <ben> oh dear
16:54:58 <ion> The physics of a cat following a laser pointer can be represented by a pure function, but side-effects such as a tower of cups collapsing obviously requires IO.
16:55:02 * geheimdienst thinks this could plausibly be developed into the new sport of kitty darts: http://www.youtube.com/watch?v=kYSoy71ib7A
16:55:22 <geheimdienst> ion, how about the towel sliding across the floor?
16:55:32 * ddarius is sure this is exactly what Charles Hard Townes was intending when he invented the laser.
16:55:46 <dankna> bwahhaha it's like "fetch" but with less effort on the cat's part
16:56:53 <ion> ddarius: But the laser was invented by John Laser.
16:57:26 <dankna> nonsense.  LASER is an acronym.  it stands for the name of its creator, Lester Albert Susan Ellington Roberts.
16:57:46 <dankna> (his third cousin was the boy named Sue, hence the middle name)
16:57:57 <geheimdienst> what is the gender of little albert susan?
16:58:03 <Adamant> ddarius: I think we wanted to make the world safe for digital music.
16:58:07 <Adamant> *he
16:58:59 <dankna> hey, RADAR is both an acronym and a palindrome.  cool.
16:59:06 <dankna> bah, I'm supposed to be reading these papers
16:59:18 <hpc> "palindronym"?
16:59:37 <aristid> dankna: TOYOTA is a palindrome too
16:59:57 <geheimdienst> atoyot?
17:00:01 <Bynbo7> well A TOYOYA is
17:00:02 <dankna> er.... do you mean in hiragana?
17:00:18 <aristid> even in english letters, when written vertically :)
17:00:20 <dankna> oh right, it's toyoda isn't it
17:00:23 <dankna> vertically haha
17:00:32 <sajith> Malayalam is palindrome!
17:00:43 <geheimdienst> atoyot sounds vaguely russian. "the atoyot-63 main battle tank ..."
17:00:53 <sajith> that is my "mother" tongue \o/
17:00:58 <dmwit> ATOYOTA. Race fast. Safe car. A TOYOTA.
17:01:17 <dankna> (I remember some article recently where the US Congress was interviewing Mr. Toyoda, and they thought there must be some confusion because they had asked to speak to the founder of the company, but his name wasn't Toyota.  The answer of course was that their American marketers had changed the name to make it sound better!)
17:01:31 <sajith> ... or native language.
17:01:42 <aristid> dmwit: good job :)
17:01:46 <dankna> dmwint: haha nice
17:01:55 <dankna> er
17:02:00 <dankna> where did that n come from
17:02:09 <aristid> @remember dmwit ATOYOTA. Race fast. Safe car. A TOYOTA.
17:02:09 <lambdabot> Nice!
17:02:23 <aristid> lambdabot likes it too
17:02:45 <ion> Its also a recursive acronym. RADAR stands for RADAR Aint Designed Against Raccoons.
17:03:02 <dankna> and C stands for C
17:03:23 <ion> But what does the inner C stand for?
17:03:25 <ddarius> C is also a palindrome.
17:03:34 <dankna> it's recursive.  the inner C also stands for C.
17:03:39 <ion> ooh
17:03:51 <geheimdienst> > let isPalin x = x == reverse x in isPalin ""
17:03:51 <lambdabot>   True
17:03:56 <geheimdienst> :-o
17:04:12 <dankna> geheimdienst, for one shining moment I thought you had written a palindrome tester the code for which was itself a palindrome
17:04:32 <geheimdienst> ... a so-called quinindrome
17:04:38 <dankna> (did I just destroy your productivity for the rest of the evening?  so sorry!)
17:04:39 <ion> :-D
17:04:40 <dankna> indeed
17:05:47 <geheimdienst> i have a beautiful proof why a quinindrome is impossible, but this irc window is too narrow ... ah screw it. i got nuthin.
17:06:13 <dankna> that claim would work better were your text not wrapped
17:06:29 <ddarius> geheimdienst: Make sure you write such comments in the margins of all your notebooks.
17:06:39 <dankna> in case you ever become famous, yes
17:07:00 <hpc> geheimdienst: "remarkable" or it didn't happen :D
17:07:01 <ion> One could cheat by having a reverse portion as a code comment in the quine.
17:07:21 <diracdelta> 200
17:07:25 <geheimdienst> so that history books will note me as a pompous troll. yeah, i like that.
17:07:37 <aristid> geheimdienst: everybody likes pompous trolls
17:07:44 <ddarius> geheimdienst: Actually, they probably won't note you at all unless you do something else.
17:08:15 <companion_cube> maybe irc history files...
17:08:22 <dankna> Ion: in that case you would have to have it be exactly half, because you can't include -- without starting a comment
17:08:45 <ddarius> dankna: That's not hard to arrange.
17:08:51 <diracdelta> If I've made a type error when writing code, and I'm trying to 'debug' the error, is there some form of 'debugger' that will help me step through the process? The compiler's warnings weren't enough to figure out which substitution was invalid.
17:09:06 <geheimdienst> }- reverse me and i become a comment -{
17:09:11 <dankna> oh hey, yeah
17:09:33 <hpc> geheimdienst: good luck getting that to be valid haskell :D
17:09:54 <dankna> diracdelta: yes, the interactive program for debugging that is called IRC.  could you hpaste the full text of the warning?
17:09:56 <geheimdienst> > let }- = 42 in 42
17:09:57 <lambdabot>   <no location info>: parse error on input `}'
17:10:02 <geheimdienst> bah
17:10:34 <ddarius> > do { 3 }- 4
17:10:34 <lambdabot>   -1
17:10:46 <diracdelta> sure, I'll post the original code (without the fix)
17:11:01 <dankna> please post the error message as well.  some of us find ghc's error outputs immensely valuable.
17:11:18 <hpc> ddarius: and you have to do the same thing on the other side of the comment
17:11:27 <ddarius> hpc: You can't.
17:11:28 <hpc> but when you reverse it, you have }{
17:11:40 * ddarius offers to sell dankna some GHC error messages.
17:12:03 <dankna> I have enough of my own, thanks
17:12:07 <aristid> need money for a dog?
17:12:10 <hpc> (it's amazing how many ways GHC can catch failed typechecks)
17:12:29 <ddarius> aristid: I have more than enough money.
17:12:44 <ddarius> Speaking of which, I probably need to transfer money out of my checkings account.
17:13:11 <diracdelta> http://hpaste.org/44154/bug
17:13:29 <kulakowski> ddarius: I have room in mine
17:13:49 <diracdelta> and yes, I know there is a much simpler way to do this with list comprehensions. :)
17:14:35 <hpc> diracdelta: first, a stylistic tip
17:14:40 <hpc> replace concatMap with join
17:14:42 <rwbarton> diracdelta: are you really missing a ] on that line 2?
17:14:56 <geheimdienst> ddarius, let me guess, your the nigerian attorney representing MR. NGABO UNGUBUBABWE has contacted you to transfer $20 (TWENTY) MILLION through your account, you're just waiting for the money to come through
17:14:57 <diracdelta> no, that was a typo during transcription
17:15:00 <diracdelta> :(
17:15:19 <Philippa> diracdelta: you're not the first person to want a typing dump by a long way, believe me! Really could've used one on thursday, wasted an hour on something that was buried under just enough recursion to make a mess of the typechecking process
17:15:26 <dankna> diracdelta: okay, so first off, do you understand the occurs-check error message on the literal level?
17:16:10 <hpc> haha, step 1 of reading compiler errors:
17:16:12 <dankna> it's telling you that it discovered in the course of its investigations that two types which have to be equal can only be so by being infinite in size, ie recursive
17:16:15 <hpc> "do the words mean things"
17:16:19 <dankna> hpc: yes haha
17:18:06 <Philippa> dankna: couple that one with some recursion and you end up having to add lots and lots of annotations to get the compiler to tell you where you screwed up though :-(
17:18:07 <aristid> is there an elegant way to define rose trees with Mu?
17:18:11 <dankna> true
17:18:26 <Philippa> and, well, of /course/ it involves recursion
17:18:42 <geheimdienst> guys, could you keep the condescension down a little ...
17:19:02 <dankna> diracdelta, this usually happens when you have confused an item with a list of items
17:19:22 <rwbarton> to be honest this type error is really bad
17:19:28 <dobblego> @type sortBy
17:19:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
17:19:33 * Philippa wonders how much well-typed would want to implement a (maintainable) GHC typing browser and whether it'd be achievable by a 'community bounty' approach
17:19:42 <elliott> How well does the IO subsystem recover from invalid UTF-8?
17:19:46 <elliott> Can I discard UTF-8 on a line-by-line basis?
17:19:49 <elliott> *invalid UTF-8
17:19:55 <diracdelta> dankna: I somewhat understand it. In this case, the problem was the concatMap in combiner. Combinations just needed to be applied to the list, I didn't want to map to each element in the list.
17:20:42 <rwbarton> I think there is a ghc trac entry about how this kind of error message could be made more helpful
17:20:42 <aristid> elliott: you could read as octets, and rely on the fact that line endings are ALWAYS 0xA.
17:20:57 <aristid> elliott: then convert every single line to utf-8
17:21:08 <elliott> aristid: I wouldn't want to convert to UTF-8.
17:21:11 <elliott> I would just want to convert to a String.
17:21:19 <aristid> um i meant that
17:21:21 <hpc> Char is utf8 isn't it?
17:21:23 <elliott> I don't know if there's a function to turn a UTF-8 string into a String.
17:21:24 <rwbarton> from utf-8
17:21:25 <elliott> hpc: no, UTF-32.
17:21:26 <aristid> hpc: no
17:21:27 <elliott> == codepoint
17:21:30 <ddarius> hpc: That doesn't make sense.
17:21:51 <hpc> ddarius: how?
17:21:51 <aristid> elliott: you know what i meant now? or should i try to phrase it more correctly? :)
17:22:16 <dankna> diracdelta, ah, I see.  yes.  so the clue to look at that is the "a = [a]" part of the message - it says you're returning a list when you meant an element
17:22:22 <elliott> aristid: Well. I don't know if there is a function from (UTF-8) ByteString -> String.
17:22:29 <elliott> There is ByteString -> String but it just keeps the octets as-is.
17:22:42 <dankna> diracdelta, I understand that what you want is mostly a suggestion for strategies to debug this faster next time?  I hope that helps
17:22:48 <rwbarton> Technically if your input is supposed to be UTF-8 but is invalid, it doesn't totally make sense to talk about lines at all
17:22:48 <monochrom> I think buffering makes it a bit hard to discard utf8 errors on a line-by-line basis
17:22:51 <aristid> elliott: there is. it's in Data.ByteString.UTF8
17:22:56 <aristid> elliott: i forgot the package name now
17:22:56 <diracdelta> dankna: Yeah, unfortunately, it didn't help too much, since I had multiple maps in that code
17:22:59 <ddarius> hpc: Your statement is kind of like asking if 3 is little endian.
17:23:05 <elliott> utf8-string seemingly
17:23:08 <elliott> monochrom: indeed
17:23:12 <dankna> yeah I see.  well, there's always reducing the problem to the smallest program that manifests the error...
17:23:24 <elliott> I'd just use ByteStrings throughout, technically there's no need for me to assume that everything is valid UTF-8 -- but this way is a lot more convenient
17:23:28 <diracdelta> dankna: yeah, pretty much :) A more systematic (or automatic) method of what I did (do manual substitutions of the code and see where it broke down)
17:23:30 <hpc> ddarius: oh, because utf-8 and utf-32 have the same symbols?
17:23:31 <aristid> elliott: package is utf8-string
17:23:31 <dankna> yes
17:23:32 <elliott> (they're IRC messages, so the chance of them being valid UTF-8 is 99.9%)
17:23:53 <aristid> well, actually many people use iso-8859-1 on irc
17:23:57 <dankna> in my exp-- yeah
17:23:59 <elliott> aristid: Only bad people.
17:24:01 <aristid> or iso-8859-15
17:24:02 <dankna> or other codepages
17:24:08 <dankna> euc-jp was also popular at one point
17:24:12 <elliott> At least in the channels I'm in, anyone not using UTF-8 is beaten to death with a cluebat :P
17:24:19 <aristid> elliott: \o/
17:24:23 <elliott> ofc non-freenode/oftc tend to be a bit more ... liberal.
17:24:30 <elliott> But that doesn't concern me.
17:24:40 <ddarius> hpc: I'm not exactly sure what you mean by that, but maybe.  A Char is a character.  The representation isn't specified nor (semantically) relevant.
17:24:45 <geheimdienst> ... be liberal in what you accept
17:24:49 <aristid> i set up my irc client to accept both utf-8 and latin-1
17:24:55 <rwbarton> diracdelta: a good first step here would be to try replacing one of the functions by undefined, to figure out which function the error is in
17:25:02 <hpc> ddarius: it can be relevant, if you want say, the snowman
17:25:07 <rwbarton> I don't know why ghc can't tell you that already, since you specified type signatures
17:25:11 <hpc> you can't get that if Char is latin1
17:25:17 <dankna> ?
17:25:17 <monochrom> IRC messages: keep as bytestring or byte-whatever, chop by lines or chop by messages, decode each message independently, then you can contain utf8 errors in a single message.
17:25:33 <aristid> hpc: Char has no encoding
17:25:39 <aristid> hpc: it supports all unicode characters.
17:25:54 <hpc> aristid: okay
17:26:04 <hpc> so it's "magic"
17:26:13 <ddarius> hpc: Char is defined to be able to handle all Unicode codepoints.  It's not defined to be UTF-8 or UCS-32.
17:26:24 <aristid> maybe a special type for ascii characters might be convenient
17:26:41 <hpc> aristid: Char8?
17:26:42 <geheimdienst> like Word8?
17:26:43 <dankna> newtype ASCII = Word8
17:26:45 <elliott> <monochrom> IRC messages: keep as bytestring or byte-whatever, chop by lines or chop by messages, decode each message independently, then you can contain utf8 errors in a single message.
17:26:45 <ddarius> In practice, it is effectively UCS-32.
17:26:45 <monochrom> although I said buffering may make things a bit hard, perhaps hGetLine does enough magic to make it look easy to you, I don't know, give it a try.
17:26:52 <elliott> monochrom: My plan is to just read lines as bytestrings, convert to utf-8, and that's it.
17:26:55 <aristid> geheimdienst: well, that's more than 7 bits :)
17:27:02 <monochrom> yeah
17:27:03 <elliott> Looks like utf8-string just replaces invalid UTF-8 with the replacement character.
17:27:07 <elliott> Which is even nicer than dropping lines.
17:27:12 <hpc> it would be interesting if strings were typeclassed by encoding, the way numerics are typed
17:27:32 <hpc> "123" :: Char8 a => [a]
17:27:33 <ddarius> "Numerics" aren't "typeclassed" by encoding.
17:27:36 <elliott> hpc: hmm, I'd prefer "String enc"
17:27:40 <elliott> where enc is (Encoding enc)
17:27:43 <hpc> elliott: or that
17:27:43 <elliott> or something
17:27:59 <hpc> ddarius: shush, i doesn't my english remember how
17:28:03 <elliott> convert :: String enc -> Maybe (String enc2) or the like
17:28:14 <kulakowski> elliott: I had hoped it would do that. That was one of the perks of UTF-8, I thought, being able to recover from just about anything in the space of one character.
17:28:26 <elliott> kulakowski: Indeed that's one of the main advantages.
17:28:44 <geheimdienst> aristid: consider the spare bit a present. use it to store a lolcat or something
17:28:50 <diracdelta> dankna: Thanks. I'll keep that in mind next time :)
17:29:01 <dankna> diracdelta, sure
17:29:02 <ddarius> hpc: It's not just that.  "Encoding" for numeric types would be something like big endian versus little endian, not Int16 versus Int32 (though, actually, endianness does come up with a Bits instance.)
17:29:04 <elliott> Unicode is 21-bit IIRC
17:29:04 <pikhq_> kulakowski: Aside from the obvious "being a superset of ASCII" bit. :P
17:29:04 <aristid> geheimdienst: the temptation to use it for, say, latin-1 is too big!
17:29:07 <elliott> or actually, 20.something bits
17:29:13 <ddarius> > maxBound :: Char
17:29:14 <lambdabot>   '\1114111'
17:29:27 <hpc> ddarius: i meant "encoding" for strings, and "implementation" for num
17:29:39 <aristid> geheimdienst: did you know that the first 8 bits of unicode codepoints are equivalent to latin-1?
17:29:41 <hpc> like how 5 can be 5%1, Int, Integer, Double...
17:29:45 <elliott> > logBase 2 (ord (maxBound :: Char))
17:29:46 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
17:29:46 <lambdabot>    arising from a use of...
17:29:51 <elliott> > logBase 2 (fromIntegral (ord (maxBound :: Char)))
17:29:52 <lambdabot>   20.087461546321563
17:29:55 <dankna> but only the codepoints - not the encodings
17:29:56 <hpc> and '5' could be latin1, ascii, utf
17:30:01 <hpc> ah
17:30:02 <elliott> Unicode: 20.08746 bits.
17:30:02 <aristid> dankna: yes.
17:30:21 * hpc lrns2string-terminology
17:30:21 <ddarius> elliott: You didn't need the ':: Char' there.
17:30:25 <kulakowski> pikhq_: Of course. Though without the other, I don't think it's such a huge win.
17:30:29 <elliott> ddarius: Oh, right.
17:30:31 <kmc> Char is no more specified to be UTF-8 or UCS-32 than Int is specified to be big-endian or little-endian
17:30:42 <kmc> the language is supposed to hide the representational details from you
17:30:49 <monochrom> "the first 8 bits"? you disgusting little endians. they are the last 8 bits!
17:31:24 <aristid> kmc: ord on Char gives codepoints :)
17:31:50 <hpc> @instances Bits
17:31:50 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
17:32:09 <kulakowski> monochrom: Blefescuian scum.
17:32:13 <aristid> monochrom: i think decimal numbers are the wrong way round
17:32:22 <aristid> monochrom: 100 should be 001 instead :)
17:32:28 <ddarius> aristid: Just learn Hebrew.
17:32:29 <hpc> aristid: there's also bits
17:32:34 <kulakowski> aristid: Semitic languages do it that way.
17:32:36 <monochrom> james bond 700
17:32:40 <hpc> which gives endian-ness
17:32:41 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bits.html#t:Bits
17:32:48 <aristid> kulakowski: ddarius was faster than you :)
17:32:54 <hpc> *exposes endin-ness
17:32:57 <hpc> *endian
17:33:04 <aristid> monochrom: lol i guess that's his title in israel
17:33:13 * hpc quits while not catastrophically behind
17:33:27 <kulakowski> aristid: But my answer was polymorphic!
17:33:31 * ddarius actually thinks Hebrewis the wrong way round and not just from ethnocentrism.
17:33:32 <kmc> which "bits" instance exposes endianness?
17:33:36 <kmc> err which method
17:33:50 <hpc> kmc: testBit
17:33:51 <kulakowski> Anyway, the solution to endianness disputes is unary.
17:33:57 <aristid> ddarius: why?
17:33:57 <hpc> rotate
17:33:58 <hpc> shift
17:34:00 <kmc> "Bits are numbered from 0 with bit 0 being the least significant bit." hpc
17:34:09 <kmc> sounds like it's specified in an implementation-independent way
17:34:49 <ddarius> aristid: Most people are right-handed and so left-to-right, top-to-bottom strokes are easiest.  This is less relevant/true for some means of writing than others, though.
17:35:12 <kmc> Word32 is a 32-bit value with bits numbered from 0 to 31
17:35:13 <aristid> ddarius: how does this apply to the order of digits?
17:35:14 <rwbarton> are the strokes in hebrew letters written right to left?
17:35:25 <ddarius> aristid: It doesn't.
17:35:26 <kmc> you don't get to see where those bits are stored in memory
17:35:30 <rwbarton> (not that the point wouldn't apply, just curious)
17:35:35 <ddarius> rwbarton: If they aren't then that would be even worse.
17:35:47 <aristid> ddarius: oh, you just mean because hebrew is right-to-left in general?
17:36:20 <aristid> somehow i was thinking that hebrew was left-to-right with reversed digit order. of course that's wrong
17:36:33 <aristid> but i didn't realise it :(
17:37:53 <ddarius> Of course, those sinister folk will disagree with me, but of course they're shady.
17:38:41 <Adamant> they can punch more gooder, though
17:39:58 <aristid> ddarius: so actually hebrew has the same digit order problem if the right-most digit is the most significant one
17:40:54 <aristid> if numbers were written in the opposite order, parsing them would be much easier, even for humans
17:40:55 * ddarius thinks most-significant digit first makes a reasonable amount of sense for written human language.
17:41:13 <aristid> well i need to read each number twice
17:41:21 <aristid> first to see the number of digits, then to read the digits
17:41:22 <kulakowski> ddarius: I'd rather get the order of magnitude up front.
17:41:25 <ddarius> The reason why I think so is secretly hidden in the term "most-significant digit."
17:41:48 <pikhq> ddarius: Well, it certainly isn't such in the language for which Arabic numerals were *invented*.
17:42:17 <Adamant> pikhq: Sankskrit?
17:42:33 <Adamant> Arabic numerals aren't
17:42:57 <pikhq> Adamant: I know, I know, they're actually out of India.
17:43:01 <Adamant> :P
17:43:11 <pikhq> Adamant: Still for an RTL script.
17:43:17 <Adamant> good point.
17:43:39 <Adamant> there are questions about Chinese influence too
17:43:43 <aristid> pikhq: so in sanskrit, it was least-significant digit first?
17:44:02 <pikhq> aristid: Yup.
17:44:08 <Adamant> although tracing Indian vs. Chinese influence on a lot of things is really hard.
17:44:14 <pikhq> aristid: We simply didn't change the ordering when adopting them.
17:44:25 <aristid> pikhq: but didn't arabs change the ordering?
17:44:32 <pikhq> aristid: No.
17:44:39 <Adamant> Arabic is Semetic and RTL
17:44:41 <Adamant> IIRC
17:44:46 <pikhq> Correct.
17:45:22 <aristid> so in arabic it's least-significant digit first, too?
17:45:31 <aristid> but in hebrew, most-significant digit first?
17:45:34 <aristid> *confused*
17:45:40 <pikhq> ... Hebrew is *also* RTL.
17:45:49 <aristid> i abstract from that
17:46:03 <aristid> first means rightmost in RTL languages and leftmost in LTR languages
17:46:23 <pikhq> And it's least-significant digit first in Hebrew script.
17:46:26 <Adamant> European languages derive huge influence from Latin and Greek, both of which were LTR
17:46:33 <pikhq> Because *nobody bloody changed the ordering of the digits*.
17:47:13 <Adamant> and there's always Chinese, which was originally up and down :P
17:47:23 <aristid> so really all LTR languages have digits in the "wrong" order?
17:47:31 <Adamant> sorta
17:47:33 <aristid> (all LTR languages that use arabic numerals)
17:47:46 <pikhq> Yeah.
17:47:50 <Adamant> they maintained the RTL from RTL languages
17:48:14 <eb4890> Yesod question: Is it possible to serve a user customised JS file on its own (for a bookmarklet say)?
17:48:33 <aristid> now the question is whether the original indians made the right decision
17:48:48 <Adamant> aristid: no, their decision was perfectly reasonable for them
17:48:59 <aristid> ddarius seems to think that most-significant digit first is better
17:49:05 <Adamant> if compatibility is an issue, then the Western decision is also perfectly reasonable
17:49:10 <pikhq> Incidentally, LTR is essentially just Greek, its derivatives, and scripts that changed their traditional writing direction because of LTR influence.
17:49:34 <Adamant> pikhq: I thought Latin and Etruscan were always LTR
17:49:38 <aristid> pikhq: i'm not really talking about LTR. just about numbers
17:49:45 <Adamant> obviously they had huge influence from Greek
17:49:46 <pikhq> Adamant: Latin and Etruscan are Greek-derived scripts.
17:50:01 <Adamant> pikhq: I thought they were Phonecian
17:50:04 <aristid> they're not straight from phoenician?
17:50:33 <pikhq> No, Latin is from Etruscan, which is from Greek.
17:50:37 <Adamant> alright
17:50:52 <Adamant> makes sense, the Etruscans were more influenced early on by the Greeks
17:51:01 <aristid> anyways, there are two separate questions here: 1. is RTL better, or LTR?
17:51:01 <pikhq> The Greek alphabet got around a lot.
17:51:14 <aristid> 2. is most-significant digit first better, or least-significant digit first
17:51:20 <Adamant> aristid: depends on a bunch of stuff
17:51:32 <pikhq> aiko_: Arguably, the question of which digit ordering is better is really a matter of which digit ordering your language evolved to use.
17:51:41 * eb4890 checks he has the right channel :p
17:51:56 <pikhq> eb4890: Yes, it's #haskell, we're just gleefully off-topic ATM.
17:52:12 <Adamant> math lingustics -> math and linguistics -> Haskell :P
17:52:16 <pikhq> Erm. aristid:
17:53:33 <augur> i /really/ dont understand agda x.x
17:53:41 <augur> Adamant: whats math linguistics
17:54:03 <aristid> augur: whitespace as sum operator?
17:54:05 <ddarius> Interestingly, cuneiform evolved from a vertical script to a ltr horizontal script because it was easier to write, even with it's impression-oriented style.
17:54:37 <augur> aristid: what
17:54:51 <Adamant> augur: math is a formal language. you can apply linguistics to it
17:55:01 <aristid> ddarius: i wonder if ease of writing played a factor in language dominance. after all, languages are under evolutionary pressures just like everything else.
17:55:04 <Adamant> particularly post-Chomsky linguistics
17:55:25 <Adamant> (due to Chomsky)
17:55:26 <aristid> Adamant: math is a language?
17:55:33 <ddarius> aristid: Definitely.
17:55:36 <Adamant> aristid: yup.
17:55:55 <pikhq> aristid: Doesn't seem like ease of writing played *too* much of a factor into language dominance.
17:56:01 <aristid> math itself, and not mathematical notation?
17:56:08 <augur> Adamant: no, you can't. linguistics is the study of natural languages, and as such is inapplicable to math because natural languages are subject to the constraints imposed by humans' cognitive capacities regarding language, which are demonstrably distinct from conscious mathematical reasoning.
17:56:09 <aristid> pikhq: yes, that may be possible as well.
17:56:29 <Adamant> augur: linguistics is the study of language, period.
17:56:35 <augur> Adamant: im a linguist. no, it's not.
17:56:48 <augur> its the study of human language.
17:56:56 <Adamant> math is a human language
17:57:01 <augur> no its not.
17:57:01 <pikhq> aristid: After all, the Sinitic languages ended up rather far-spread, and Chinese script even more-so, even though it does take quite a lot of effort to gain competence at it.
17:57:07 <Adamant> being formal doesn't matter.
17:57:13 <augur> no no you're not following, Adamant
17:57:15 <aristid> Adamant: mathematical notation is a language, but maths itself?!
17:57:25 <pikhq> (the amount of effort is highly, highly overstated, but it is still most definitely harder than, say, Hangul.)
17:57:32 <aristid> mathematics is about concepts, not representation
17:57:42 <augur> human language, the subject matter that linguists study, is the class of languages that humans can learn simply by exposure, rather than by explicit instruction.
17:57:46 <Philippa> obQ: could you create a mathematical notation (for something useful) that's designed to exploit cognitive capabilities about language?
17:57:52 <Philippa> (that doesn't become perl)
17:58:04 <Adamant> augur: no, I follow that you believe linguistics is limited to natural language
17:58:06 <Adamant> I don't
17:58:07 <augur> humans cannot learn mathematics simply by being exposed to mathematics, they have to be instructed.
17:58:10 <augur> well you're wrong.
17:58:20 <rwbarton> surely mathematical notation is already such a thing, e.g., we don't write expressions in RPN
17:58:27 <rwbarton> Philippa: ^^
17:58:34 <dankna> linguistics is limited to natural language, because it is a field of human study and the people engaging in it get to decide what they are studying.  next?
17:58:37 <pikhq> Adamant: Even in a very formal sense of language, math is not a language.
17:58:44 <aristid> pikhq: maybe there was more competition between languages in non-chinese-dominated regions
17:59:02 <Adamant> pikhq: why?
17:59:10 <pikhq> Adamant: Mathematics notation would qualify in a formal sense, sure, but not math itself.
17:59:22 <augur> Adamant: the word linguistics means something very particular. it's a technical word, and as such you must accept the technical definition. if you dont like it, tough shit. invent a new term.
17:59:35 <Adamant> that's getting into philosophical territory.
17:59:39 <augur> no, its not
17:59:49 <Adamant> that was to pikhq 
17:59:52 <augur> ok.
18:00:22 <Adamant> augur: and, no I don't have to care. you are similarly free to ignore my definition.
18:00:23 <aristid> Adamant: no, it's not very philosophical. mathematics is independent from notation. influenced, maybe, but you could always invent a new notation
18:00:31 <aristid> and that new notation would be a different language
18:00:36 <augur> Adamant: the problem is that you're the only person who uses that definition
18:00:45 <augur> the entire FIELD of linguistics uses a completely different definition.
18:00:48 <Adamant> augur: I don't think so.
18:00:56 <augur> uh, no, you are.
18:01:00 <pikhq> Adamant: It's the same distinction as between any idea and an expression thereof.
18:01:01 <Philippa> he's not
18:01:02 <Philippa> but
18:01:07 <augur> maybe non-linguists also might think this
18:01:10 <Philippa> the entire field of linguistics is still enough people to have a say in it
18:01:15 <augur> but no linguist thinks that mathematics is linguistics.
18:01:54 <pikhq> augur: Linguistics and mathematics, however, *are* related fields, courtesy of Chomsky. :P
18:02:02 * geheimdienst thinks mathematics is biology, on the grounds that biology studies living systems and living systems do math
18:02:05 <augur> they're intimately related, but they're not the samr thing.
18:02:07 <augur> same**
18:02:19 <augur> and mathematics is not a branch of linguistics
18:02:25 <aristid> which field is NOT linked to mathematics these days?
18:02:31 <augur> you might get away with saying the converse, depending on the kind of linguistics you do
18:02:36 <tg_> not all living systems 'do mathematics'
18:02:41 <hpc> geheimdienst: brains can do arithmetic! biological computers!
18:02:43 <hpc> skynet!
18:02:48 <Adamant> augur: I know linguists have applied lingustic principles to the study of math.
18:02:52 <aristid> skynet 9000!
18:02:52 <augur> hpc: brains solve differential equations.
18:02:55 <Guest24913> what's skynet?
18:03:01 <augur> Adamant: link.
18:03:11 <tg_> Guest24913: something from the movie Terminator
18:03:14 <pikhq_> augur: Solve? Doubtful.
18:03:15 <augur> name a linguist that has applied linguistic principles to mathematics
18:03:17 <Adamant> augur: and who says intellectual endevours are a tree?
18:03:25 <geheimdienst> tg_: yeah, not all living systems have wings or ears or tails. biology still studies them.
18:03:25 <Adamant> augur: looking now
18:03:26 <pikhq_> augur: Approximate solutions, sure.
18:03:37 <augur> pikhq_: well yes, you know what i mean
18:04:02 <augur> tho i wouldnt be terribly surprised if there was some actual equation solving going on
18:04:19 <aristid> pikhq: "numerical solvers" never find precise solutions anyways. i think most people accept approximate solutions as solutions, if they're good enough.
18:04:22 <tg_> [21:29] * geheimdienst thinks mathematics is biology, on the grounds that biology studies living systems and *living systems do math*?
18:04:40 <Guest24913> what's the debate about?
18:04:56 <aristid> Guest24913: whether maths is a language and other important questions
18:04:58 <pikhq_> aristid: Well, in that sense brains certainly do solutions to differential equations all the time.
18:05:16 <tg_> s/important//
18:05:20 <aristid> pikhq: lol my brain is smarter than i am!
18:05:21 <augur> pikhq_: in the sense that there is some differential equation it's solving? :p
18:05:26 <Philippa> augur: has anyone in linguistics started playing with category theory yet?
18:05:27 <augur> thats probably true of anything
18:05:30 <tg_> bbiaf
18:05:41 <augur> Philippa: lambek
18:05:43 <tg_> Philippa: ask Nim Chimsky
18:05:48 <augur> to the extent that he's "in linguistics"
18:05:55 <Philippa> augur: I should've known that, come to think of it
18:05:56 <aristid> tg_: is that Noam Chomsky's evil twin?
18:05:57 <augur> other lambekians
18:06:08 <Philippa> is there a good summary of what lambek's done for non-linguists?
18:06:10 <elliott> Why is *> fixity 4 while >> is fixity 1?
18:06:11 <augur> aristid: its a chimp that someone taught a small amount of sign language.
18:06:15 <elliott> Is it because everybody hates me?
18:06:21 <geheimdienst> @google nim chimpsky
18:06:21 <lambdabot> http://en.wikipedia.org/wiki/Nim_Chimpsky
18:06:21 <lambdabot> Title: Nim Chimpsky - Wikipedia, the free encyclopedia
18:06:27 <elliott> best name ver
18:06:28 <elliott> *ever
18:06:32 <aristid> augur: close enough.
18:06:39 <Adamant> augur: https://secure.wikimedia.org/wikipedia/en/wiki/George_Lakoff
18:06:46 <Guest24913> "This sentence is false" is like : x = x == false
18:06:47 <pikhq_> augur: Bleck, I really do dislike those claims of animal language.
18:06:55 <Guest24913> which is a paradox
18:07:02 <augur> Philippa: directional function types as a tool to model syntactic well formedness
18:07:02 <dobblego> #haskell-blah please guys
18:07:03 <Guest24913> paradox means our language and logic is broken
18:07:05 <Adamant> Lakoff is a linguist who's used linguistic tools in the study of math
18:07:25 <augur> Adamant: no, george lakoff uses cognitive tools in the study of mathematical cognition
18:07:26 <elliott> pikhq_: there was that one with the parrot that seemed plausible enough :p
18:07:27 <Guest24913> a paradox is an human infinite loop
18:07:29 <elliott> at least more than the chimps
18:07:32 <elliott> anyway yes this is -blah
18:07:43 <augur> that his cognitive tools came out as a result of his research into language back in the day is irrelevant.
18:07:56 <Guest24913> the fact that we interpret sentences that are broken means that language is broken
18:08:06 <Guest24913> we should fix it, and math, and programming
18:08:13 <augur> the cognition of mathematics and mathematics itself are two different things and thus makes lakoff irrelevant to your proposition.
18:08:16 <elliott> Guest24913: what.
18:08:25 <Adamant> augur: a cognitive linguist is still a linguist.
18:08:34 <Guest24913> it should not be possible to be able to fail to divide by 0
18:08:43 <augur> Adamant: irrelevant to the point
18:08:45 <dobblego> pretty pretty please
18:08:46 <augur> please read what i said again.
18:08:53 <Adamant> dobblego has a point
18:08:57 <elliott> Guest24913: a language where all statements are true? here's one: {1 = 1}
18:08:59 <Adamant> I'm going to -blah
18:09:07 <Adamant> I'll continue there if you want
18:10:01 <Philippa> Guest24913: google "paraconsistent logic" and have fun
18:10:57 <Guest24913> sounds fun
18:11:10 <elliott> Philippa: heh
18:11:21 <Philippa> also consider that humans have to be capable of it to cope with social situations
18:11:31 <elliott> Philippa: I always wanted to figure out what the computational analogue of dual-intuitionistic logic was
18:11:39 <elliott> intuitionistic logic -- dependently-typed lambda calculus
18:11:43 <elliott> dual-intuitionistic logic -- ??
18:11:53 <Philippa> what's dual-intuitionistic logic?
18:12:02 <elliott> Philippa: intuitionistic logic's evil, goatee-sporting twin
18:12:03 <Philippa> (and does it have any connection to Wadler's Dual Calculus?)
18:12:11 <elliott> Philippa: instead of ->, there's # -- which is apparently similar to "but not"
18:12:20 <elliott> -> maps to functions, no clue whatsoever what # would map to.
18:12:44 <Philippa> "but not" isn't intuitionistic NAND?
18:13:00 <elliott> Philippa: I don't think so
18:13:16 <dolio> Subtraction? http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.8231
18:13:25 <elliott> Philippa: http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&id=pdfview_1&handle=euclid.ndjfl/1039886520
18:13:27 <elliott> This might have been what I read.
18:13:30 <elliott> Dunno.
18:13:54 <elliott> dolio: heh what
18:14:33 <dolio> That paper adds a connective to intuitionistic logic that it calls subtraction.
18:15:18 <dolio> And it might be somehow dual to ->, I forget the specifics.
18:15:49 <dolio> Your link says 'pseudo-difference' which sounds similar.
18:18:07 <dolio> I don't know what the Curry-Howard connection is, though.
18:19:02 <elliott> probably is none :)
18:24:33 <dolio> That paper uses multiple propositions on the right of a sequent like classical sequent calculus too.
18:25:10 <dolio> I think that tends to be connected with parallel reduction, so it's possible subtraction has a connection there.
18:25:23 <elliott> obviously it's the solution to all concurrency problems then.
18:25:29 <elliott> I arrived at this conclusion... with logic! Questionable logic!
18:27:20 <kafee> is there any haskell framework with a "asp feeling"? no need to use get and post to determine user input etc...
18:28:00 <hpc> kafee: i have some code that will collect get and post into an associative list
18:28:27 <ddarius> Usually such classical things get associated with control effects (which are related to concurrency.)
18:29:01 <ddarius> elliott: You may find LolliMon interestinng.
18:29:37 <elliott> heh, why does everyone take my jokes seriously! before i even say them!
18:30:06 <elliott> :)
18:30:18 <elliott> maybe that's the secret to innovation, taking jokes seriously
18:30:41 <ddarius> dolio: If you have continuations, you can interpret a left adjoint to Either a which produces a connective that should be A and Not B.
18:32:15 <kafee> hpc, so the answer is no... seems a little cumbersome to me because i use asp at work(but i'm not complaining)
18:32:17 <dolio> I can believe that. Although the paper in question was adding it to intuitionistic logic, which probably explains why A and not B wasn't good enough.
18:33:16 <hpc> kafee: asp will be doing the same thing
18:33:28 <hpc> just as a convenience of the language
18:33:49 <hpc> in haskell, you can abstract the whole thing out (i made a cgi monad, frex)
18:34:35 <hpc> actually, now that i think about it, the mains of all my cgi scripts end up being
18:34:42 <hpc> "main = autoCGI $ do ..."
18:35:10 <hpc> where autoCGI pulls in data, connects to db, logs in user...
18:35:11 <kafee> i'm saying the lack of something like onclick
18:35:30 <Bynbo7> isn't that a javascript thing?
18:35:31 <ddarius> Norman Wildberger has a lecture on algebraic topology?  This should be interesting.
18:36:08 <ddarius> ASP or ASP.NET?
18:36:08 <kafee> bynbo7, no
18:36:41 <kafee> asp.net actually with c#, which is disguting
18:36:54 * hpc is too tired to help further
18:36:58 <ddarius> C# is probably the nicest mainstream language currently available.
18:37:21 <ddarius> And, incidentally, there's definitely a javascript onclick "thing."
18:37:21 <kafee> yes, but still disguting
18:37:50 <accel> whT?
18:37:50 <kafee> yes too, but i'm saying about asp.net one
18:37:54 <accel> haskell is not mainstream?
18:38:07 <Bynbo7> not really
18:38:09 <ddarius> kafee: The only really disgusting thing I note about it is the stupid array covariance thing.  Otherwise, it lacks some stuff that I want but is reasonable.
18:38:40 <kafee> lol
18:38:40 <kafee> ddarius , the problem is I dislike OOP
18:39:08 <ddarius> kafee: So don't use it.
18:39:39 <kafee> say that to my employer
18:39:58 <ddarius> I'm not saying "don't use C#," I'm saying don't use OOP in C#.
18:40:57 <ddarius> I'm also surprised that you find C# "disgusting" but want to import a C# framework into Haskell.
18:44:48 <kafee> i'm a junior programmer so i must follow the way of conding of other... do not want to import it, only seems more straighforward(or the way is that saidi n english)
18:45:26 <kafee> but i'll stick with yesod
18:47:06 <kafee> or do you guys have another suggestion?
18:49:04 * ddarius wonders if any of these Haskell web frameworks take a highly concurrent approach.
18:51:26 * gienah thinks the web frameworks will be more concurrent after the event manager is altered to allow one event manager per cpu core
18:52:00 <ddarius> If they are event based now, I'm pretty sure they'll still be event based then.
18:53:37 <accel> anyone here familiar with haskore / functional music?
18:54:02 <dankna> only to the extent of knowing that somebody released some packages for it last night, heh
18:54:44 <accel> fuck; haskore is GPL
18:54:49 <accel> does this mean anything that I build based on haskore
18:54:53 <accel> will also be GPL-ed?
18:54:57 <aristid> yes
18:54:59 <kmc> oh god, now we will talk about licenses for 2 hours
18:55:03 <dankna> not exactly
18:55:04 <accel> is there anyway to browse haskell packages ... 
18:55:06 <kmc> and no haskell
18:55:10 <accel> that is only BSD and LGPL ?
18:55:17 <dankna> no
18:55:21 * accel is too pragmatic to argue licenses
18:55:30 <dankna> there was a long discussion on some mailing list or other about this
18:55:36 <dankna> just this week
18:55:37 <kmc> accel, you can make a BSD library that depends on a GPL library
18:55:41 <dankna> let's not reiterate it
18:55:45 <kmc> but it's not so useful
18:55:54 <dankna> what you can't do is distribute binaries
18:55:57 <kmc> because any executable using your library will need to be GPL
18:56:14 <kmc> but in theory someone can take your BSD-depending-on-GPL lib and rework it to not depend on that GPL and proceed
18:56:53 <dankna> of course, if you don't plan to distribute executables, it might be a nonissue
18:56:59 <dankna> in the Haskell world we often do just distribute source
18:57:04 <kmc> gienah, or they'll give in to the "event-based programming" craze... in general people are totally willing to contort their programs to a weak language / runtime, rather than demanding a better language / runtime
18:57:06 <dankna> but you should definitely caution your users
18:57:14 <accel> err; I'm planning to do this for commercial purposes
18:57:18 <dankna> oh
18:57:24 <dankna> then you're screwn, you can't use haskore
18:57:35 <kmc> err, "commercial" is not at all exclusive of GPL
18:57:55 <dankna> well, it depends on your business model
18:57:57 <kmc> i know loads of people who make money from GPL software
18:58:00 <kmc> in various ways
18:58:03 <dankna> if you don't mind releasing your source, that's fine
18:58:09 <kmc> (i am one of them)
18:58:09 <accel> well; I plan to do this commerically; and not release my source
18:58:14 <dancor> haskore is pretty beta-tastic anyway
18:58:21 <gienah> kmc: haskell is really neat as the ghc event manager handles the async io stuff underneath, while as higher level code can just use blocking io
18:58:36 <djahandarie> inb4 s/haskell/ghc
18:58:39 <kmc> gienah, exactly
18:58:49 <djahandarie> Oh, he mentioned it :P
18:58:58 * hackagebot twisty 0.1.0 - Simulator of twisty puzzles  la Rubik's Cube  http://hackage.haskell.org/package/twisty-0.1.0 (LukeBlanshard)
18:59:29 <dancor> tho idk more stable functional music libs
18:59:49 <dankna> I'd be impressed if twisty supported the Square One, but it doesn't appear to
19:00:01 <accel> dankna: so basically, haskore is the best you know of too?
19:00:13 <kmc> gienah, i much prefer that model to the node.js / twisted model of explicitly turning your program inside out
19:00:14 <dankna> accel: I don't even understand what computational music IS! :)
19:00:24 <kmc> but the latter is more popular overall
19:00:27 <dankna> @hackage haskore
19:00:27 <lambdabot> http://hackage.haskell.org/package/haskore
19:00:30 <kmc> because people have low standards for languages
19:00:36 <gienah> kmc: yes, so do I
19:10:02 <accel> "ghc --make Music.lhs" <-- builds .hi and .o ... but I want an executable. How do I get an executable?
19:11:20 <Bynbo7> does it have a main function?
19:11:34 <accel> Bynbo7: it does
19:11:51 <ddarius> s it the Main module?
19:11:56 <accel> it is not
19:11:58 <Bynbo7> tried ghc --make Music.lhs -o Music?
19:12:13 <dmwit> tried --main-is Music?
19:12:25 <accel> ghc --make Music.lhs -o Music
19:12:25 <accel> Warning: output was redirected with -o, but no output will be generated
19:12:25 <accel> because there is no Main module.
19:13:17 <accel> Linking Music ...
19:13:17 <accel> /usr/lib/ghc-6.12.1/libHSrtsmain.a(Main.o): In function `main':
19:13:17 <accel> (.text+0x1): undefined reference to `ZCMain_main_closure'
19:13:33 <dmwit> gotta keep --make or add linker flags yourself
19:13:45 <accel> ghc --make Music.lhs -main-is Music
19:13:46 <accel> Linking Music ...
19:13:46 <accel> /usr/lib/ghc-6.12.1/libHSrtsmain.a(Main.o): In function `main':
19:13:46 <accel> (.text+0x1): undefined reference to `ZCMain_main_closure'
19:14:13 <kmc> preflex, zdec ZCMain_main_closure
19:14:13 <preflex>  :Main_main_closure
19:14:22 <accel> code is from here:
19:14:23 <accel> http://plucky.cs.yale.edu/soe/software1.htm
19:14:33 <accel> kmc: what's zdec ?
19:14:36 <dmwit> Oops, -main-is just changes the function name, not the module name.
19:14:40 <xplat> > case Nothing of Just { }-> reverse "me"
19:14:41 <lambdabot>   "*Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
19:14:42 <kmc> accel, decodes GHC's name-mangling scheme
19:14:59 <azaq23> man ghc says "       -main-is
19:14:59 <azaq23>               Set main module and function"
19:17:31 <azaq23> Maybe try "full module notation"? ghc --make -main-is Music.main Music.lhs
19:17:36 <dmwit> accel: From the docs, "However, if all the modules are otherwise up to date, you may need to force recompilation both of the module where the new "main" is, and of the module where the "main" function used to be; ghc is not clever enough to figure out that they both need recompiling. You can force recompilation by removing the object file, or by using the -fforce-recomp flag."
19:17:59 <dmwit> Anyway, -main-is Music and -main-is Music.main should be equivalent, if I'm reading this right.
19:18:11 <dmwit> What version of GHC are you using?
19:18:16 <accel> 6.12
19:18:24 <accel> I just created a separte Main.hs 
19:18:30 <accel> problem is elsewhere no
19:29:19 <accel> dumb qustion ... how do I play mid file in ubuntu?
19:29:25 <accel> dumb qustion ... how do I play mid file in ubuntu? (just got output from Haskore)
19:30:17 <mkscrg> Say I have a record recA with 5 members (attributes? not sure of the terminology here), and I use the "update" syntax: recA {memb1=someNewValue}. Are all five members copied into the new record, or do the four unmodified members simply reference the values from the old record?
19:30:39 <dmwit> accel: Grab timidity from Synaptic.
19:30:48 <accel> dmwit: apt-getting timidity
19:30:55 <dmwit> or apt-get, of course
19:31:02 <Bynbo7> mkscrg: bacause haskell is pure, those two things are exactly the same really
19:31:27 <dmwit> mkscrg: The pointers are copied.
19:31:29 <rwbarton> I imagine the references in the old record are copied into the new record
19:31:29 <mkscrg> I know, I mean in the under-the-hood sense.
19:31:32 <dmwit> So it's a cheap operation.
19:31:37 <Bynbo7> mkscrg: but the inplementation in ghc will mean that the new recA will point to the old values, and the one new value
19:31:38 <dmwit> mkscrg: (Speaking about GHC here.)
19:31:43 <accel> dmwit: oh shit; I have sound; it works
19:31:46 <accel> dmwit: nice; thanks!
19:31:47 <Bynbo7> im*
19:32:01 <accel> hmm, this sounds like a wedding march of some sort
19:32:12 <mkscrg> Ah, good. That's what I was assuming, but it seemed prudent to make sure.
19:32:28 <accel> hmm; if I have a piece of software, it's GPL-ed, but it runs on _my_ server, raver than on the client side,
19:32:32 <accel> then it's not distributin the binary right?
19:33:02 <dmwit> accel: Generally right, though GPL3 may have something to say about web-apps.
19:33:04 <dmwit> not too sure
19:33:11 <dmwit> You should read the license itself if you're concerned.
19:35:02 <kmc> i think GPL3 doesn't but AGPL does
19:35:33 <xplat> augur: truly humans cannot learn to read and write math notation merely by exposure, but could they if they already knew the underlying ideas?  unfortunately the obvious experimental test won't work because of the age at which people learn significant amounts of math ...
19:36:20 <accel> xplat: why; read a biography on terrence tao
19:36:28 <accel> xplat: wasn't he raised on math?
19:39:29 <dmwit> Raise your children on Lojban. For science.
19:40:13 <accel> I wonder, if you raise your chidlren on Haskell, if he/she would be vulnerable to lisp.
19:40:37 <kmc> ;P
19:40:58 <pikhq> dmwit: Probably go over as well as that kid that was raised on Klingon.
19:42:36 <mwc> dmwit: I don't think the GPL3 is concerned with web-apps, but the Affero license does.
19:42:57 <accel> so is the Affero license basically
19:43:02 <accel> if you give anyone any output
19:43:10 <accel> that in any way used our code to compute the output
19:43:15 <accel> then you have to give them the source code?
19:43:18 <mwc> essentially, if you provide a web app using affero GPL code, you need to provide source, otherwise if you're using GPL${N}, then you don't
19:43:27 <kmc> accel, i think you should ask somewhere else about that
19:43:29 <dmwit> Yes, this seems like a good exercise. Reduce a 20-page document to three sentences, and ask if that's accurate.
19:43:39 <kmc> asking about GPL in #haskell is not likely to result in anything except a tedious flamewar
19:43:45 <mwc> heh
19:43:45 * accel apologies
19:43:59 <accel> so, what do you likes more, Vim or Emacs?
19:44:02 <kmc> ;P
19:44:12 <mwc> well, everyone in #haskell thinks they're an expert abot everything
19:44:14 <kmc> i've never once met someone who actually engages in editor wars
19:44:20 <accel> haskore is pretty amazing
19:44:23 <accel> I'm a big fan of it
19:44:29 <kmc> i've used both vim and emacs for extended periods of time
19:44:31 <accel> if only for dmos, intead of wedding songs with organs
19:44:36 <accel> they had RAP ... taht wuld be cool
19:44:37 <kmc> they are both quire powerful tools
19:44:48 <Guest5903> emacs sucks
19:44:54 <Guest5903> vim is meh
19:45:02 <accel> Guest5903++ # for emacs sucks
19:45:04 <Guest5903> modality is better
19:45:06 <accel> Guest5903-- # for vim is meh
19:45:14 <Bynbo7> vim is meh though
19:45:22 <accel> Bynbo7-- # hope he doesn't have ops
19:45:22 <Guest5903> vim is hardcoded for qwerty
19:45:32 <Guest5903> and it's not ergonomic
19:45:36 <accel> true; I didn't learn dvorak becasue of vim
19:45:38 <Guest5903> why use mnemonic?
19:45:39 <mwc> Guest5903: remap
19:45:52 <Guest5903> i learned dvorak, and now i must learn vim
19:46:10 <Guest5903> that's why i'm thinking about either remaping every key or creating a new text editor
19:46:18 * dmwit vims in dvorak
19:46:24 * kmc too
19:46:26 <dmwit> It's really not a big deal.
19:46:27 <Guest5903> vim's not in dvorak
19:46:32 <ddarius> The vim defaults are vaguely QWERTY-centric, but they are far from "hard-coded."
19:46:37 <accel> dvorak is pointless
19:46:40 <kmc> hjkl with dvorak isn't *that* bad; also you can use the arrow keys, and good keyboards will even place them conveniently
19:46:42 <accel> waht do dyou type more, code or english?
19:46:43 <dmwit> accel: Yes. Sadly.
19:46:59 <ddarius> I have six lines related to Dvorak in my .vimrc.
19:47:04 <Guest5903> well, code is full of english
19:47:10 <Guest5903> and i write english often
19:47:12 <dmwit> I have zero lines related to Dvorak in my .vimrc.
19:47:13 <kmc> accel, if you don't write a) comments and b) long identifier names, then you're Doing It Wrong
19:47:14 <Guest5903> and french too
19:47:27 <pikhq> accel: There's Programmer Dvorak.
19:47:40 <mwc> GHC needs a blood alcohol content test.
19:47:44 <kmc> i used programmer dvorak for a while but honestly it wasn't different enough
19:47:50 <kmc> to justify being totally non-standard
19:47:54 <mwc> -ferror-drunken-good-idea
19:47:55 <accel> kmc: I like to name my vars a b c d e f g h i j k l m n o p q r s t u v w x y z; when I run out, I start using unicode latin letters
19:48:03 <kmc> every OS ships with dvorak, even windows
19:48:35 <Guest5903> Why don't we develop a new text editor, better and more modern than vim and emacs, extensible in haskell?
19:48:36 <kmc> and i think dvorak is a bit faster, but the main reason i use it is comfort
19:48:40 <Guest5903> yi seems dead
19:48:44 <ddarius> kmc: Same here.
19:48:55 <Guest5903> dvorak is very confortable
19:49:26 <kmc> Guest5903, yi was supposed to be exactly that
19:49:34 <kmc> so you should ask why yi is dead
19:49:37 <Guest5903> what about the "was" part?
19:49:43 <Guest5903> why is yi dead?
19:49:47 <dmwit> Well, why aren't *you* using yi?
19:49:55 <mwc> the reason yi is dead is that it got good enough and people went back to real work
19:49:56 <kmc> why aren't you developing yi
19:49:57 <Guest5903> i'm very interested in yi and revis
19:49:59 <mwc> that happens with all tools
19:50:03 <dmwit> And, if you're ready to put in the effort to build a more modern editor, why not start from yi?
19:50:05 <Guest5903> because i'm too bad in haskell
19:50:17 <Guest5903> but once i'll learn haskell, i'll either develop yi or create something new
19:50:24 <kmc> cool :)
19:50:29 <mgsloan> everytime I tried to start using yi I couldn't get the dependencies straight
19:50:31 <djahandarie> I stopped using yi because it kept on crashing due to some MVar problem
19:50:32 <Guest5903> something needs to be done
19:50:32 <kmc> i for one would love to see more work on yi
19:50:40 <mgsloan> (then again it's been a while since I tried)
19:50:43 <kmc> but yeah i usually can't get it to build let alone run
19:50:54 <Guest5903> same here
19:51:29 <Guest5903> we need an ergonomic, non hardcoded, modern, powerful, easy to learn (logical) and extensible in haskell
19:51:34 <Guest5903> text editor
19:51:34 <accel> i got yi to build
19:51:41 <Olathe> @hoogle (a -> Bool) -> (a -> Bool) -> a -> Bool
19:51:41 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
19:51:41 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
19:51:41 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
19:51:42 <accel> in exchange for ops; I will write docs on how to build yi on ubuntu 10.10
19:52:08 <xplat> sure, i'll give you ops on ##xplat
19:52:32 <accel> you don't even have ops on ##xplat
19:52:51 <Guest5903> so yi will win the emacs vs vi war?
19:53:03 <djahandarie> This is #haskell after all.
19:53:14 <xplat> accel: my not having them was the easiest way to give them to you :)
19:53:21 <accel> nah; yi is too easy to google for
19:53:27 <accel> an editor in haskell can not succeed
19:53:30 <accel> unless it's named hi
19:53:36 <dmwit> "This car I'm designing is going to be FAST, and RED, and FUEL-EFFICIENT, and it's going to be COMFORTABLE, and ROOMY, and, oh yeah, CHEAP!"
19:53:38 <Guest5903> haskell is by far teh best programming language out there (i read about it, coded nothing in it)
19:53:49 <gienah> yi builds with ghc 6.12.3 and 7.0.1 on gentoo: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/app-editors/yi
19:53:56 <xplat> no, we need to write hmacs so we can have an hmacs vs yi war
19:54:07 <Guest5903> ok
19:54:13 <Guest5903> you guys are working on hmacs
19:54:16 <Olathe> Is sortBy a stable sort?
19:54:17 <Guest5903> we will work on yi
19:54:24 <Guest5903> gl hf
19:54:24 <gienah> and there is a yi use flag for leksah (also with both ghc 6.12.3 and 7.0.1): https://github.com/gentoo-haskell/gentoo-haskell/tree/master/app-editors/leksah
19:54:54 <Guest5903> let's not forget that yi is JUST a text editor, not a programming tool
19:55:10 <dolio> Olathe: I think so.
19:55:15 <Guest5903> which means that people will use it to edit config files, write novels, blog, and code
19:55:31 <Guest5903> then we can add something to it to make it easier to code
19:56:20 <mig_> let's all use leksah, yi, xmonad, darcs and code in haskell
19:56:23 <xplat> how about something that makes it easier to write novels?
19:56:30 <djahandarie> Olathe, pretty sure also
19:56:36 <Olathe> Alright, thanks :)
19:56:48 <mig_> let's develop an Haskell web browser
19:56:55 <Bynbo7> xplat: there's a piece of software for OS X called scrivner that is great for that
19:56:55 <xplat> should we be running all this on NixOS?
19:56:58 <kmc> http://www.jerkcity.com/jerkcity1751.html
19:57:14 <mig_> and also an IM client
19:57:21 <mig_> hIM?
19:57:22 <Bynbo7> scrivener*
19:57:29 <xplat> there's already a 'haskell web browser', but only for a very low value of 'haskell'
19:57:37 <mig_> thalk?
19:57:40 <mig_> halk?
19:57:48 <kmc> unfortunately "written in haskell" is not a sufficient condition for software to be good / usable
19:57:49 <kmc> shocking, i know
19:57:55 <mig_> chaskell?
19:58:06 <djahandarie> Olathe, the old qsort used to be stable, so I imagine they made sort the mergesort was stable too when they replaced it.
19:58:12 <xplat> i.e. wraps some C or C++ web toolkit, but at least it's wrapped in haskell!  :-/
19:58:38 <mig_> let's forget about the web browser part
19:58:51 <xplat> kmc: nonsense, my first fibs function is the best in the world!@!
19:59:04 <mig_> who here uses xmonad?
19:59:13 <djahandarie> I do.
19:59:16 * gienah uses xmonad
19:59:18 * kmc .
19:59:19 <TTimo> yar
19:59:25 <geheimdienst> yo
19:59:37 <mig_> xmonad is the best
19:59:39 <djahandarie> You can join #xmonad and take the intersection of the users, that'll probably get a decent amount
19:59:39 <dobblego> yes
19:59:39 <dmwit> Can't you just /users in #xmonad?
19:59:56 <kmc> i kind of hate xmonad's window management philosophy but it's a good implementation of that philosophy
20:00:07 <mig_> what do you hate about it's philosophy?
20:00:12 <xplat> what is xmonad's window management philosophy?
20:00:16 <mig_> i love philosophy in programs
20:00:22 <kmc> i want static tiling layout
20:00:27 <TTimo> more difficult .. does someone here use arbtt ?
20:00:33 <mig_> what i don't like about xmonad is that it's not modal
20:00:34 <ddarius> xmonad has too many features
20:00:34 <kmc> i want to say "split the screen here and here and here", and assign windows to each pane
20:01:02 <djahandarie> ddarius, it has too many features and none of the ones I want
20:01:18 * geheimdienst has to use a mac at work now. it's just a lot more awkward, the window manageitude there
20:01:29 <xplat> better features >> more features
20:01:33 <kmc> i've written a nontrivial part of a static tiling wm in haskell
20:01:37 <kmc> but may never finish
20:01:45 <kmc> the ICCCM is kind of terrifying
20:01:51 <kmc> easier to read the xmonad source tbh
20:02:06 <accel> what's so bad about th xmoand soure?
20:02:07 <accel> i find it surprislngly readable
20:02:14 <mig_> let's build a haskell linux distribution
20:02:20 <accel> there's one already
20:02:24 <accel> it starts with a 
20:02:25 <accel> L
20:02:28 <accel> I can't remember the name
20:02:49 <xplat> lambdux?
20:02:53 <kmc> would anyone say "let's build a python linux distribution"
20:02:58 <xplat> yes
20:03:08 <dobblego> linspire
20:03:10 <accel> pinspire
20:03:13 <mig_> we need a document reader, a communication program, a text editor, a multimedia system, etc
20:03:13 <xplat> yes, they certainly would
20:03:16 <accel> err, linspire
20:03:25 <djahandarie> Would anyone say "Let's build a C linux distribution"?
20:03:34 <kmc> i don't have this need for my entire computing experience to eat and breathe and shit haskell
20:03:46 <accel> i want a CPU that supports laziness
20:03:47 <mig_> yes you need it
20:03:51 <djahandarie> I prefer my computing experience to do none of those things
20:03:54 <accel> i want my GPU to be lazy
20:03:56 <xplat> and ruby even more so!
20:03:57 <mig_> let's build a CPU
20:03:57 <kmc> accel, http://www.cs.york.ac.uk/fp/reduceron/
20:03:59 <accel> it doesn't get computed unti the pixel needs to be displayed
20:04:15 <mig_> let's reinvent computing
20:04:24 <mig_> let's reimaagine boolean
20:04:25 <kmc> didn't apple already do that?
20:04:27 <mig_> in haskell
20:04:32 <mig_> 0 1 and lambda
20:04:50 <kmc> guys let's all smoke a lot of weed and then program in haskell
20:04:58 <xplat> let's invent a computer than renders 3d graphics lazily ... in the type system!
20:05:18 <mig_> haskell is the only language with no compromise
20:05:19 <djahandarie> It sounds like that's what half of the channel is doing right now. Except they aren't programming.
20:05:24 <mig_> scale is just full of compromises
20:05:27 <mig_> scala*
20:05:40 <kmc> haha, no compromise
20:05:49 <xplat> haskell has plenty of compromises
20:05:58 <mig_> *let's talk and read about haskell all day long and not program anything in it*
20:06:03 <xplat> it doesn't compromise much on paradigm, though
20:06:16 <mig_> what are haskell's compromises?
20:06:16 <kmc> xplat, allowing IO at all is a compromise
20:06:18 <dobblego> scala is full of misguided attempts at compromise
20:06:19 <Philippa> yeah? What's it doing with a logic language bolted on to the type system then? :-)
20:06:40 <kmc> mig_, for one, the type system is much weaker than it could be, in order to have type inference and such
20:06:41 <mig_> i still don't know what a monad is
20:06:55 <xplat> Philippa: that wasn't a compromise, it was an accidental feature :)
20:06:57 <mig_> don't talk to me like i'm twelve
20:07:08 <dobblego> trait Monad[M[_]] extends Functor[M] { def join[A](a: M[M[A]]): M[A] }
20:07:22 <mig_> haskell is now full of compromises
20:07:26 <mig_> is clean less bad?
20:07:32 <mig_> or is it only betterV
20:07:34 <mig_> ?*
20:07:34 <lambdabot> Maybe you meant: . ? @ v
20:07:36 <kmc> haha
20:07:54 <mig_> no one talk about Clean?
20:07:57 <Philippa> Haskell's approximately as good as it'll get for a language in its class
20:08:08 <Philippa> Clean's got some cute stuff, but it just doesn't get the same amount of work done on it
20:08:09 <djahandarie> The lower class!
20:08:11 <mig_> let's imagine a new paradigm?
20:08:23 <kmc> mig_, how about troll-oriented programming
20:08:26 <Philippa> well, if you want The Future, play with Agda
20:08:36 <Philippa> I remember haskell being The Future, it was painful
20:08:50 <mig_> for me, the amount of library and people and work and compatibility and blablabla done on something (or not done in this case) is not a w eakness to me
20:09:05 <mig_> so, what is the best language, ever, in theory, not in practice
20:09:09 <xplat> well, the fundamental principle of programming languages is that they are a compromise between a computer's need for precise direction and the limits of human cognition, so honestly a language without compromise is disqualified from the getgo
20:09:12 <mig_> then let's make it the best in practice
20:09:14 <mig_> that's it.
20:09:35 <mig_> so binary is the ultimate language?
20:09:50 <mig_> or is trinary better?
20:09:54 <mig_> on unary?
20:09:59 <mig_> or*
20:10:16 <mig_> how many people here are christians?
20:10:26 <mig_> do you believe in jesus and the talking snake?
20:10:43 <xplat> i believe in the talking troll
20:10:43 <mig_> is this real life?
20:11:06 <mig_> is Jesus the ultimate troll?
20:11:25 <djahandarie> mig_, can you move to #haskell-blah for off-topic trolling?
20:11:26 <mig_> the bible is just full of troll science
20:11:42 <mig_> sorry, i'll shut up
20:20:18 <accel> quit
20:45:49 <strangeprogram> I'm trying to implement hashing in my program, I have cryptohash and crypto-api, where to from here?
20:46:53 <xplat> bytestrings i should think
20:48:04 <Bynbo7> there is a hashable package for hashing things
20:49:21 <strangeprogram> I've imported Crypto.Classes but I don't know how to implement it
20:50:44 <copumpkin> Bynbo7: he seems to want cryptographic hashing?
20:50:48 <copumpkin> which hashable is not
20:50:54 <Olathe> Is there an efficient way to, say, add 5 to all keys in an IntMap?
20:51:03 <Bynbo7> well, it wasn't clear from the question
20:52:50 <kmc> Olathe, doubtful -- that would totally change the bits in those keys
20:52:56 <kmc> resulting in a different tree shape
20:53:17 <kmc> you could remember a separate offset and translate
20:54:05 <Olathe> Alright, thanks.
20:54:26 <kmc> maybe using toList and fromList is fast enough for your purpose?
20:54:55 <gaze__> hey, what's the preferred GUI library to use at the moment? I can't seem to tell if people are still working on wxhaskell
20:55:14 <gaze__> and where's qthaskell?
20:55:17 <kmc> i think gtk2hs is the most developed
20:55:36 <gaze__> seems to look that way...
20:55:46 <kmc> or make a web-based UI
20:56:02 <gaze__> what's the preferred way to do that?
20:57:49 <gaze__> also, should I be able to work with gtk2hs through ghci? I'm on a mac and I just end up with a window that never seems to get painted.
20:58:00 <gaze__> though compiled apps work just fine
20:58:57 <bparker1000> howdy, I was wondering if it is possible to use nested if-then-else statements when defining a function, or if there is a better way to define these statments
20:59:28 <Bynbo7> you can nest them, or you can use guards
21:00:01 <strangeprogram> gaze__: ghci doesn't seem to like GUI libraries in general, it's part of the dynamic linking I think, correct me if I'm wrong
21:00:46 <gaze__> rraaargh. I can't imagine doing haskell development without ghci
21:02:23 <bparker1000> Bynbo7: thanks, will look into guards, may help with my problem
21:04:08 <copumpkin> bparker1000: keep in mind that for many things you'd use if-then-else for in other languages, pattern matching works nicely in haskell
21:04:10 <Twey> bparker1000: Guards, cases, pattern-matching, some sort of type-class (Functor, Monad, Applicative)
21:04:25 <cole> When I attempt to set any font properties in wxwidgets I get a runtime exception. What could be wrong
21:04:27 <Twey> It depends on the structure of your code and your data, but there's usually a better way to do it
21:04:36 <accel> anyone here doing procedural modeling in haskell?
21:05:08 <copumpkin> cole: I don't know the answer, but someone who does might be able to give you more help if you gave us a) the runtime exception b) what you tried to do to get the exception
21:05:24 <Twey> accel: Something like http://gregheartsfield.com/fractal-hs/ maybe?
21:05:59 <accel> eh; I was thinking things like catherdral
21:06:01 <accel> and castles
21:06:05 <accel> less fractals
21:08:15 <cole> When I attempt to set any font properties in wxwidgets I get a runtime exception. What could be wrong? Here's the runtime exception  http://pastie.org/1584654 What I did in order to get the runtime exception was to attempt to set the size of the font on a textCtrl, but attempting to set any property on fonts causes this exception.
21:10:24 <ddarius> copumpkin: So Norman Wildberger has a lecture series on Algebraic Topology.
21:11:12 <copumpkin> is it good?
21:13:14 <dolio> Oh, that guy.
21:14:33 <cole> What is the most frequently used gui library in haskell?
21:14:50 <ddarius> Gtk2hs
21:15:06 <ddarius> copumpkin: There will definitely be some interesting parts.
21:15:16 <ddarius> copumpkin: Also, it seems to be reasonably decent so far.
21:15:39 <dolio> I guess someone has to be passionate about trigonometry.
21:18:39 <ddarius> It's not that he's passionate about trigonometry, it's what he views trigonometry as being.
21:18:44 <ddarius> And why.
21:33:50 <mig_> omg
21:33:52 <copumpkin> ddarius: cool, I'll check it out
21:33:55 <mig_> google changed their interface
21:37:30 <accel> what's a good setup for netbook + haskell? or if I go that route, the best is just the 13" mbp
21:38:10 <Makoryu> I don't think that qualifies as a netbook
21:38:22 <accel> it's small/portable enough
21:39:02 <copumpkin> I use the 13" MBA and it's great, but once you're at 13" you have lots more choices :)
21:39:09 <accel> what else?
21:40:30 <ddarius> copumpkin: It's more of a novelty than something that I feel strongly about.
21:40:55 <ddarius> But it is pretty good.
21:43:06 <christo_m> http://codepad.org/23sD3di5  <- writing a LUA parser in haskell/parsec
21:43:13 <christo_m> am i on the right track here
21:43:20 <copumpkin> cool
21:43:21 <christo_m> (first time doing functional programming, not sure about the "do" and monads in general)
21:43:53 <christo_m> http://www.lua.org/manual/5.1/manual.html#8  Trying to implement this grammar
21:43:57 <christo_m> not sure if im doing it right
21:51:55 <christo_m> accel: help?
21:54:12 <accel> ?
21:54:19 <christo_m> accel: you wrote a parser recently didnt you
21:54:22 <christo_m> do you mind if i look at your code
21:54:34 <accel> it's an embrassing mess
21:54:42 <christo_m> var ::=  Name | prefixexp `[ exp `] | prefixexp `. Name 
21:54:49 <christo_m> nobody has an example grammar like that
21:55:02 <christo_m> they do childish examples that i think i understand, but im not sure how to convert that to something parsec/haskellish
21:55:05 <accel> is taht supposed to be parsec?
21:55:12 <christo_m> no, its supposed to be EBNF grammar
21:55:39 <accel> I learned parsec by working through the RWH examples
21:55:40 <christo_m> im trying to put that into parsec
21:55:45 <christo_m> link?
21:55:50 <accel> google.com
21:55:50 <christo_m> oh, nvm, i think i know
21:56:03 <christo_m> lol ya, just didnt know what RWH stood for but it clicked
21:56:16 <accel> http://book.realworldhaskell.org/read/using-parsec.html
21:58:05 <christo_m> accel: how would you implement the stuff with [ ], xplat said it meant optional
21:58:11 <christo_m> so he used the keyword opt, but i dont think that exists
21:58:16 <christo_m> i get errors about it
21:59:08 <accel> why is the rest of the channel silent?
21:59:18 <accel> is this some type of "do we give accel ops" test?
21:59:49 <accel> christo_m: write your haskell code
21:59:52 <accel> christo_m: get the error from ghc
21:59:54 <copumpkin> accel: because people are asleep and/or not in the mood to talk
21:59:55 <accel> christo_m: paste it to hpaste.org
22:00:11 <copumpkin> accel: seriously, going on about getting ops is just going to piss people off, so please stop doing it
22:00:28 <christo_m> what about opts?
22:00:48 * accel volunters copumpkin to explain
22:01:03 <copumpkin> no, I have no idea why he keeps bringing it up
22:01:10 <accel> going back to reading siggraph course notes, sorry
22:01:13 <christo_m> okay no seriously, if someone can just show me one line, converting the above grammar to haskell/parsec, ill stfu
22:01:16 <christo_m> i can just learn from the example
22:01:24 <christo_m> var ::=  Name | prefixexp `[ exp `] | prefixexp `. Name 
22:01:46 <rwbarton> those []s don't mean optional
22:01:53 <christo_m> those dont i know
22:01:54 <rwbarton> they're just [] characters
22:01:57 <rwbarton> oh
22:02:01 <christo_m> yes and i used the between function
22:02:03 <christo_m> to parse 
22:02:19 <christo_m> fieldlist ::= field {fieldsep field} [fieldsep]  < theres an example
22:02:21 <christo_m> of what im talking about
22:06:34 <christo_m> fieldlist = do field; many (do fieldsep; field) opt (fieldsep) is all i can think of
22:07:40 * hackagebot twine 0.1.2 - very simple template language  http://hackage.haskell.org/package/twine-0.1.2 (JamesSanders)
22:08:40 * hackagebot yesod-form 0.0.0.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.0.0.2 (MichaelSnoyman)
22:09:14 <pai> is PutStrLn same as print
22:09:21 <c_wraith> no.
22:09:34 <c_wraith> print = putStrLn . show
22:17:23 <accel> http://hackage.haskell.org/packages/archive/pkg-list.html <-- is there no GLSL DSL within haskell ?
22:18:59 <accel> http://hackage.haskell.org/package/vacuum-cairo <-- reporting to the powers that be, that there are broken links here
22:20:30 <superglue> The wikipedia entry for Value (computer science) says: In CS, a value is an interpretation of a sequence of bits according to some data type.  It is possible for the same squence of bits to ahve different values, depending on the type used to interpret its meaning.  For instance, the value could be an integer or floating point, or a string.  So, my question is: when reading about haskell, should 'type' be taken as a near-s
22:20:45 <copumpkin> @tell accel you didn't report it to the powers that be. Reporting it to the powers that be would be to read the maintainer field and see "Maintainer	: Don Stewart <dons@galois.com>"
22:20:45 <lambdabot> Consider it noted.
22:21:13 <copumpkin> I guess seeing should be followed by acting
22:22:35 <superglue> or, is a value a particular instance OF a type?
22:23:02 <copumpkin> superglue: you were truncated at "as a near-s"
22:23:26 <superglue> oh.... haha
22:23:29 <superglue> rear ree?
22:24:01 <superglue> the rest of it is 'taken as a near synonym for 'value'
22:24:35 <superglue> I am completely new to programming in general I should add.
22:24:50 <copumpkin> not really sure how you mean
22:24:58 <superglue> So, please forgive if it is a really stupid question to ask.
22:25:02 <copumpkin> but type should be seen sort of like a set, and value should be a member of one such set
22:26:27 <Philippa> in fact, use naive set theory and then /exactly/ like...
22:28:12 <drbean> There's a type/token distinction in corpus linguistics, the difference between a word and an example of the word. But I was never very sure which was which.
22:29:21 <drbean> In the above sentence, the type 'word' has 2 tokens.
22:33:06 <pai> http://tinypaste.com/4415e7
22:33:38 <pai> Isn't that inefficient. The stack keeps growing 
22:34:10 <quuuux> pai: that'll be tail-recursive
22:38:28 <tolkad> GHC is failing with the informative error message "could not execute: opt". it works if I turn off -fllvm
22:39:30 <tolkad> oh. maybe I need to download llvm. I thought it might come with all the XCode stuff
23:17:10 <dark> I'm having a problem with let inside do
23:17:19 <dark> actually let inside case inside do
23:17:52 <dark> i want to write it 'low level', get it working, and then rewrite using combinators
23:18:00 <dark> but haskell layout rules are in the way
23:18:57 <dark> i tried layouting this a number of ways http://paste.pocoo.org/show/341594/
23:19:18 <Makoryu> dark: You have to start a new do block
23:19:29 <Makoryu> dark: Same thing if you use if/then/else
23:19:38 <Olathe> @pl \f (a, b) -> (f a, f b)
23:19:38 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
23:20:00 <Makoryu> dark: That is, you need the keyword "do" after the =
23:20:03 <dark> oh thanks
23:20:08 <dark> after the = ?
23:20:21 <dark> but runState is part of the do?
23:20:24 <Makoryu> dark: Before "runState"
23:20:28 <Makoryu> dark: It isn't though
23:20:28 <dark> .o
23:20:33 <dark> ?? o.o
23:20:33 <lambdabot>  o.o
23:20:42 <dark> even the bot is confused
23:20:46 <dark> but will try
23:20:57 <Makoryu> dark: OK, "do" doesn't work that way. The sugar only applies to the outermost "layer"
23:21:23 <dark> http://paste.pocoo.org/show/341595/ doesn't work either
23:21:51 <Makoryu> Wait oh d'oh
23:22:13 <Makoryu> dark: Are you using (a, s) in a line below that?
23:22:19 <dark> yes
23:22:33 <dark> well that is the entire loop
23:22:48 <dark> i print a, and loop s
23:22:59 <Makoryu> dark: http://paste.pocoo.org/show/341597/
23:22:59 <dark> http://paste.pocoo.org/show/341596/ doesn't work either
23:23:00 <Makoryu> Oh
23:23:17 <Makoryu> See I'm not totally clear on what you're doing here
23:23:23 <rwbarton> put the let inside the do
23:23:24 <dark> oh, do before let? hm
23:23:54 <dark> ok compiled thank you both :)
23:24:24 <dark> (do { let { ... } = ..; putStrLn ..; loop .. }
23:26:55 <dark> I need a way for lifting that case on Either outside this do. I saw some monad things to do that but I'm unsure on how to abstract it
23:28:26 <Makoryu> dark: Transformers, presumably... I'm not comfortable with those myself :/
23:28:39 <dobblego> dark: I suspect you need a monad transformer of some sort
23:28:48 <dark> exactly what I feared
23:28:49 <dobblego> StateT Either at first glance
23:28:54 <dobblego> they are easy, trust me
23:28:55 <dark> would it be EitherT?
23:29:01 <dark> StateT?..
23:29:18 <dobblego> how about you try to write your structure without transformers
23:29:21 <Makoryu> dobblego: He's using IO as well....
23:29:27 <dobblego> ok
23:29:35 <dark> is this related to the state i'm already using?
23:30:19 <dobblego> s -> IO (Either a s, t) -- perhaps
23:30:23 <Makoryu> dark: The State type is an abstraction over the "s -> a -> (b, s)" metaphor
23:30:32 <dobblego> s -> (s, a)
23:30:37 <dark> I read a string; parse it, returning Either <someerror> Command; match it, if error i print it, if not, I do runState <run command> previous state, print the result (string) and loop with the new state
23:31:03 <dobblego> by parse it, do you mean IO?
23:31:05 <dark> so this new state would be unrelated to my existing state
23:31:09 <dark> I mean parsec
23:31:25 <dark> parser :: String -> Either ParseError Command it is my parser command
23:31:32 <dark> function*
23:31:53 <dobblego> where did State come into it?
23:32:30 <dark> I have a command :: Command -> State Mode String
23:32:40 <dobblego> aaah
23:33:02 <dobblego> so that means Mode -> (Mode, String)
23:33:09 <dobblego> do you want Mode -> IO (Mode, String) ?
23:33:18 <dark> uhm.. .o
23:33:24 <dark> I'm thinking. i have no idea
23:33:28 <dark> after I parse, if it was successful, it returns Right c. then i do let (a, s) = runState (command $ c) state
23:33:38 <dark> where state is the previous state and s is the new state
23:33:50 <dobblego> ok, then I don't see the need for a transformer at this point
23:33:52 <dark> i print a, and do it again using s as state
23:33:57 <dobblego> do you have an existing code?
23:34:03 <dark> yes
23:34:15 <dark> but i want to remove a "case" from my do code
23:34:25 <dobblego> oh, which case is that?
23:34:29 <dark> I successfully did this before a number of times, but each time using a different trick
23:34:53 <dobblego> the Either case?
23:34:55 <dark> http://paste.pocoo.org/show/341606/
23:35:03 <dark> no, the "case .. of"
23:35:04 <dobblego> @type either -- you can always use this *always*
23:35:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:35:15 <dark> I don't want to use explicit pattern matching there
23:35:26 <dobblego> just use either then
23:35:33 <dark> oh
23:35:36 <dark> uhm
23:35:42 <dark> even if i'm inside a do { } block?
23:35:45 <dobblego> sure!
23:35:46 <dark> uhm o.o
23:36:05 <dobblego> either ((>> loop state) . print) (\c -> do let (a, s) = ...
23:36:22 <Guest40585> what does "type ()" mean?
23:36:30 <dark> what I want is: eventually get rid of this do { } block and use some 'applicative' style. [ but: the more 'clean' the code, the less I will understand it, so I may live with that do block for more time.. ]
23:36:50 <Makoryu> Guest40585: Sorry?
23:36:53 <dobblego> you won't get much advantage here with applicative style
23:36:53 <dark> oh. hm. o.o
23:37:46 <dobblego> as a rough rule, if you have a do block pulling values off and you don't use *any* of those values until the end in a return, then applicative is likely to help
23:39:08 <dobblego> it's possible to write any case/of for Either using either. Sometimes it's better to use a more specific function. I cannot see a use for a more specific function in your case
23:39:22 <dobblego> the same goes for Maybe and the maybe function
23:39:32 <dark> how to read a line in a way that it would return Maybe String, so that I know there is no more lines? or something equivalent. right now,  l <- getLine gives some kind of error when I type Ctrl+d for EOF
23:39:40 <dobblego> and, a few practical considerations aside, for [] and foldr
23:40:07 <dark> @hoogle IO (Maybe String)
23:40:08 <lambdabot> System.Console.Editline elGets :: EditLine -> IO (Maybe String)
23:40:08 <lambdabot> System.Console.Editline.Readline readline :: String -> IO (Maybe String)
23:40:08 <lambdabot> System.Directory findExecutable :: String -> IO (Maybe FilePath)
23:40:09 <dobblego> hrm, I'd fiddle around in System.IO to figure that one out
23:40:44 <dark> System.Console.Editline.Readline seems interesting, since I'm running my app with rlwrap..
23:45:36 <dark> I'm beginning to think that I want Mode -> IO (Mode, String). so this maybe would mean I want StateT? but I wouldn't know how to tie the looping
23:45:54 <dobblego> yes that is StateT IO, but I don't know if that is true
23:46:02 <dobblego> StateT IO Mode String
23:46:17 <dobblego> (ordering aside, I often get type params around the wrong way)
23:46:45 <Makoryu> dark: I will confess to getting sick of trying to understand transformers in the past, and just using IO with some IORef state variables
23:47:00 <dobblego> wow, that's quite a confession :)
23:47:07 <dark> I have a "recursive" do { } .. (I saw some combinator at Control.Monad said to be used at the implementation of recursive do. so maybe, if I'm to use State
23:47:12 <Makoryu> dobblego: 
23:47:17 <dobblego> dark: forever perhaps?
23:47:17 <dark> .. StateT, I would need to use such combinators
23:47:41 <dobblego> the idea of StateT is not that it is necessary for you to use it, but by using it makes managing things a little easier
23:47:44 <dark> :t forever
23:47:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
23:48:02 <dobblego> go right ahead and use s -> IO (s, a) if you're comfortable, but StateT just happens to make it easier
23:48:15 <dobblego> that's true for all transformers
23:48:17 <Makoryu> dark: Is there a deadline of some kind on this program? You might take the time to understand what do-blocks desugar to, and then make sense of the functions involved
23:48:18 <dark> m a -> m b means it is not supposed to "end"?
23:48:30 <dobblego> I've never heard of anyone giving and using IORef because of this though
23:48:33 <dark> @src forever
23:48:33 <lambdabot> Source not found. Are you on drugs?
23:48:43 <dobblego> dark: correct, it never ends and the 'a' values are always ignored
23:48:50 <dobblego> forever k = k >> forever k
23:49:19 <dark> Makoryu, no, i just wanted to learn haskell.. (i tried many times in past)
23:50:15 <Makoryu> dark: All right. The two basic rules are: "do { a; b } == a >> b" and "do { x <- a; b x } == a >>= b"
23:50:17 * dobblego gone, good luck
23:50:41 <dark> so forever x is do { x; x; x.. } ?
23:50:50 <Makoryu> dark: The important thing to note here is that (>>=) and (>>) are ordinary functions
23:50:51 <dark> dobblego, bye, thanks for the tips =)
23:50:58 <Makoryu> dark: Well yes, effectively
23:53:37 <Makoryu> dark: By the way, there's a lambdabot feature for desugaring do-blocks
23:53:54 <dark> @undo?
23:53:54 <lambdabot> ()
23:54:00 <dark> @undo do { x; x }
23:54:00 <lambdabot> x >> x
23:54:16 <Makoryu> Yeah
23:55:25 <dark> http://paste.pocoo.org/show/341615/ right now i'm on this, i'm thinking on how make forever work with this
23:55:56 <dark> i think what i need is do { x' <- s x; x'' <- s x'; .. } , because i need to keep passing state 
23:57:15 <dark> i mean, i would need something akin to forever, but without ignoring things
23:57:38 <dark> like.. forever' m s = m >>= \s' -> forever' m s'
23:57:54 <rwbarton> that's also forever, but in a StateT-transformed monad
23:58:11 <dark> ?? @.@
23:58:11 <lambdabot> Plugin `compose' failed with: Unknown command: ".@"
23:58:16 <Makoryu> dark: Passing an extra parameter is basically the entire point of monads
23:58:35 <Makoryu> dark: Rather, passing it along between every function call
23:58:53 <dark> yeah, I was going to haskell in order specifically to avoid passing an extra parameter when doing functional stuff. and look at my handler, receiving a state as parameter
23:59:34 <Makoryu> So go ahead and use StateT
23:59:53 <Makoryu> http://www.haskell.org/haskellwiki/Simple_StateT_use
