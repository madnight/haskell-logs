00:34:48 <Maxdamantus> What is Foreign.Storable.alignment used for?
00:38:09 <luite> Maxdamantus: it's used to make sure that alloca allocates aligned memory blocks for your data type
00:38:29 <Maxdamantus> Ah.
00:39:51 <luite> check the code in Foreign.Marshal.Alloc for more info (although there may be other places where alignmet is used)
00:40:07 <luite> alignment
00:40:30 <Maxdamantus> Hm. hsc2hs doesn't give alignment information afaics :(
00:41:11 <luite> I think I usually got alignment info by using some gcc extension
00:42:50 <luite>     alignment _ = #{const __alignof__(LpStrategy)} // for example
00:42:50 <luite> not very pretty, but it worked
00:42:50 <Maxdamantus> Mmm .. well atm I'm also using #{type typeof(((struct foo *)0)->bar)} so, meh.
00:49:14 <chiho> Hi. I'm new to Haskell and I'm trying to write a function that computes the mean of an Int list. I wrote 2 implementations:
00:49:22 <chiho> mean a =  let (total, size) =  foldl' acc (0, 0) a  in total / size where acc (subtotal, subsize) i = (subtotal + i, subsize + 1)
00:49:32 <chiho> mean' a = (fromIntegral (sum a)) / (fromIntegral (length a))
00:50:16 <Heffalump> and one takes linear space and the other takes constant space
00:50:17 <Heffalump> ?
00:50:17 <chiho> Can someone explain why mean' [1..1000000] runs faster than mean [1..100000] even though it's traversing the list twice?
00:50:32 <Heffalump> err, that's odd.
00:50:56 <Heffalump> unless [1..] got inlined
00:51:15 <Heffalump> can you try with a more complicated list that would only be generated once
00:51:26 <hskltyp> "hackage.haskell.org" is probably the wrong answer since I don't know what type of library I need. -- I want a library, in haskell, taht can play PCM files -- i.e. something lower level than Haskore -- I want something where it's my job to output a PCM data block, and the library can play it in real time. I also need it to work on Mac OSX? Anyone knows what I need? [This falls under "what hskltyp needs for 800"]
00:51:48 <chiho> Heffalum: what do you mean by complicated list?
00:51:55 <jonkri> how can i convert from String to [Word8]? the string is a "regular" haskell string (which i assume is utf-encoded (?))
00:52:20 <Heffalump> something that the compiler wouldn't think of inlining. I think anything defined by a recursive function would do.
00:52:27 <Jafet> chiho: compile with -O2?
00:52:43 <Heffalump> oh yes, that too
00:52:47 <Heffalump> it's not the default
00:53:24 <chiho> Jafet: ran by loading code into ghci 6.12.1, let me try compiling
00:53:54 <Jafet> -O is often enough.
00:53:56 <Heffalump> if you try a long enough list, you'll find mean' runs out of space
00:54:11 <Heffalump> certainly in ghci
00:54:37 <Heffalump> I guess until you get to the point where memory becomes a problem, the overhad of tuple construction and destruction competes with the overhead of doing two traversals
00:55:00 <Heffalump> with -O/-O2 the tuples would probably get unboxed though
00:55:11 <chiho> hm... so tuple construction is expensive?
00:55:28 <Heffalump> well, it's an allocation
00:55:33 <c_wraith> well, compared to not constructing them it's expensive
00:55:35 <Heffalump> if it doesn't get optimised away
00:55:46 <Heffalump> allocation is pretty cheap in GHC but it's not free
00:55:57 <Heffalump> and there's not much else going on in that code
00:56:08 <Eduard_Munteanu> -funbox-strict-fields isn't enabled even with -O2, IIRC
00:56:21 <arcatan> what should this return? toEnum (5 * 10^12) :: NominalDiffTime
00:56:47 <arcatan> (import Data.Time.Clock)
00:57:57 <arcatan> because I have a feeling that 0.000658067456s is not a correct result...
01:08:29 <jonkri> should i go through Text if i want to convert a string to [Word8]?
01:11:17 <chiho> ok, looks like the two-traversal mean' function is still faster after compiling with -O2
01:14:10 <jonkri> @hoogle Char -> Word8
01:14:10 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
01:14:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
01:14:10 <lambdabot> Prelude error :: [Char] -> a
01:14:17 <jonkri> @hoogle Char -> [Word8]
01:14:17 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
01:14:17 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
01:14:17 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
01:15:04 <Jafet> Why not go to ByteString
01:15:32 <Jafet> @hoogle String -> ByteString
01:15:33 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
01:15:33 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
01:15:33 <lambdabot> Prelude read :: Read a => String -> a
01:16:31 <jonkri> aha, thanks Jafet 
01:16:52 <Jafet> Use ByteString.Lazy and skip [Word8]
01:16:52 <bicilotti> I have a compile problem: http://pastebin.com/Rn3sAHsX
01:17:00 <bicilotti> am I wrongly using |make| ?
01:19:15 <Jafet> bicilotti: does ghc compile SimpleJSON before Prettify?
01:19:49 <bicilotti> it was already compiled, so no. should I delete the .o and try again?
01:20:15 <Jafet> Hum, it should work then
01:20:41 <Lanjiao> Hi, sb knows how to resolve this issue? 
01:20:46 <Lanjiao> Resolving dependencies...
01:20:47 <Lanjiao> cabal: dependencies conflict: ghc-6.12.1 requires array ==0.3.0.2 however
01:20:49 <Lanjiao> array-0.3.0.2 was excluded because ghc-6.12.1 requires array ==0.3.0.0
01:21:24 <Lanjiao> I want to install Yesod 0.7 by "cabal install yesod"
01:23:05 <bicilotti> Jafet: even deleting the .o and .hi does not make it work
01:23:25 <bicilotti> should I upload the files somewere?
01:23:27 <Jafet> That shouldn't be necessary -- ghc automatically recompiles outdated dependencies
01:24:54 <bicilotti> Jafet: even with C++ I had always a rollercoaster relationship with compilers, but this one boggles me :P
01:25:34 <pozic> Jafet: except it does so in a buggy way.
01:25:35 <bicilotti> btw haskell platform version : 2010.2.0.0
01:26:19 <pozic> Jafet: e.g. if you first compile some objects with ghc version X, and then with X+1, it will assume all kinds of things about the environment and fail.
01:26:38 <bicilotti> maybe the compiling options " ghc -c PrettyJSON.hs --make " are wrong?
01:26:47 <pozic> Compiling a bunch of modules is not referentially transparant in GHC. 
01:26:50 <Jafet> Oh, right
01:26:59 <Jafet> pozic: pft, details
01:27:16 <Jafet> bicilotti: you didn't export JValue(..) from Prettify
01:27:23 <pozic> Jafet: I don't have the bug number.
01:28:20 <Jafet> A bigger bug to me is that ghc still does not take compilation options into account when recompiling.
01:28:29 <bicilotti> oh, you mean that when I import A in file B and B from file C i must export A in B if C needs to "see it" ?
01:29:00 <Jafet> bicilotti: yes. This is not like the anarchy you have in C++
01:29:20 <pozic> Jafet: that is an example of it not being referentially transparant, right? 
01:29:22 <bicilotti> It's not anarchy, it's... devo (sorry for bad pun)
01:30:22 <Jafet> pozic: perhaps, although I only care about when it mangles optimization.
01:31:19 <pozic> If you stick to Haskell2010 features, your compiler will generally work.
01:31:36 <jonkri> @hoogle Data.ByteString.Internal.ByteString -> Data.ByteString.ByteString
01:31:36 <lambdabot> Parse error:
01:31:36 <lambdabot>   --count=20 "Data.ByteString.Internal.ByteString -> Data.ByteString.ByteString"
01:31:36 <lambdabot>                  ^
01:31:51 <pozic> I haven't had it compile the wrong code, which I have had with C++ compilers.
01:32:33 <jonkri> @hoogle Data.ByteString.Lazy.Internal.ByteString -> Data.ByteString.Internal.ByteString
01:32:33 <lambdabot> Parse error:
01:32:33 <lambdabot>   --count=20 "Data.ByteString.Lazy.Internal.ByteString -> Data.ByteString.Internal.ByteString"
01:32:33 <lambdabot>                  ^
01:34:25 <bicilotti> Jafet: sorry if I bother you again, but can I ask for the sintax? I lost myself lreading the haskell report98 on exports
01:39:06 <bicilotti> omg disco won in ireland
01:39:31 <bicilotti> (sorry wrong chat)
01:39:35 <hskltyp> wait
01:39:37 <hskltyp> you have to tell us now
01:39:41 <hskltyp> disco won what in ireland?
01:39:46 <bicilotti> :D
01:43:52 <bicilotti> I'm a bit at loss Jafet : http://en.wikibooks.org/wiki/Haskell/Modules <-- I don't know exactly what to do to export a module A from B (which has it imported) to C
01:45:38 <Heffalump> module B (module A, ...) where ...
01:48:52 <bicilotti> oh, explicit? so ... doesn't export it all?
01:49:16 <bicilotti> (sorry for naive questions, but I'm way n00b)
01:50:58 <bicilotti> wait, now I have a : " module Prettify where " line, which, iinm, exports all from the module
01:51:27 <Eduard_Munteanu> @hoogle " --help
01:51:27 <lambdabot> Parse error:
01:51:27 <lambdabot>   --count=20 "" --help"
01:51:27 <lambdabot>              ^
01:51:33 <Jafet> That exports the entire module as B.A. If you want to export JValue, import SimpleJSON and export JValue(..) or import qualified SimpleJSON and export SimpleJSON.JValue(..).
01:51:55 <Eduard_Munteanu> @hoogle " --help;\
01:51:56 <lambdabot> Parse error:
01:51:56 <lambdabot>   --count=20 "" --help;\"
01:51:56 <lambdabot>              ^
01:52:04 <Eduard_Munteanu> Can't blame me for trying.
01:52:14 <Jafet> bicilotti: I believe that exports nothing at all (except instances)
01:56:11 * hackagebot Thrift 0.5.0.2 - Thrift library package  http://hackage.haskell.org/package/Thrift-0.5.0.2 (KirkPeterson)
01:56:27 <bicilotti> Jafet, Heffalump : but, iirc, if I write something like this "module Prettify (JValue(..)) where" it will /not/ exports defs in Prettify, right? (in other words, is ther a way to say "export all in this module and all of module kkk"?)
01:57:11 * hackagebot cassandra-thrift 0.7.2.1 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.7.2.1 (KirkPeterson)
02:02:09 <drg> Hi, Im getting a "parse error on input '2' " its coming from this line 
02:02:43 <drg> "layoutScreens 2 (TwoPane 0.5 0.5)" anyone have any suggestions?
02:06:21 <jonkri> "getFeatures f ((EventBeginElement (Name {nameLocalName = Empty}) a):es) =" works, but
02:06:46 <jonkri> "getFeatures f ((EventBeginElement (Name {nameLocalName = (DTL.pack "starttls")}) a):es) =" fails with a parse error in pattern. is it not allowed to pattern match like this?
02:08:11 <Jafet> DTL.pack "starttls" isn't a constructor or binding
02:08:29 <Jafet> Those are the only two things allowed in ordinary patterns
02:10:18 <bicilotti> I've solved with "module Prettify (JValue(..), Doc(..)) where" but it still looks incredibly clumsy :S
02:10:23 <jonkri> so an arbitrary string is a constructor?
02:10:50 <Jafet> Yes. "foo" is ('f':'o':'o':[]).
02:12:26 <jonkri> that doesn't look like a constructor to me :P
02:12:50 <Jafet> (:), [] and character literals are all constructors
02:13:48 <jonkri> ok, i accept it :)
02:14:57 <c_wraith> that's not actually how the spec definese it, in the presence of the OverloadedStrings extension.  But..  Close enough
02:15:09 <c_wraith> *defines
02:18:18 <Jafet> bicilotti: selective export and qualified import is recommended anyway
02:18:55 <bicilotti> Jafet: I can see why, I am just a bit puzzled coming from C++ =)
02:19:47 <bicilotti> I am a bit wary though, let's say I have a "wrapper module", it would be quite time consuming to type everything. And error prone.
02:20:18 <bicilotti> still, if that is that, there's no way to excape it.
02:20:28 <bd_> bicilotti: what do you mean by a wrapper module?
02:20:35 <Jafet> *more* error prone? Are you sure?
02:21:38 <bd_> bicilotti: If you want to re-export from module B everything that's in module A, you can do module B (module A, ...) where ...
02:21:58 <bicilotti> bd_: sorry if my words are unclear (italian with c++ background here, you can't get worse than that). I mean, let's say I have a module A B C. I want to make a module D which imports everything from said modules and exports the- oh
02:22:43 <bd_> If you want to re-export only certain specific identifiers, of course, just export those normally (they may have to be imported without qualification in that case)
02:22:44 <bicilotti> bd_: thanks, one more thing, let's say I have stuff in B (which I would normally export with module B where --no (), exports all)
02:23:22 <c_wraith> bicilotti: a module can export itself:  module B (module A, module B) where import A ...
02:23:22 <bicilotti> is there a way to obtain it (like module Pippo (module A, and_everything_that_is_in_B) where)
02:23:45 <bicilotti> c_wraith, bd_ , thanks!
02:23:55 <bicilotti> and Jafet : yes, that was a typo XD
02:24:24 <bd_> c_wraith: ... huh, never knew that. :)
02:24:46 <bd_> bicilotti: personally I'd recommend explicit exports, though - your module statement then gives a quick overview of your API
02:24:50 <bicilotti> indeed! And now it compiles and it is compact! Thanks folks!
02:25:08 <bicilotti> bd_: duly noted!
02:25:24 <bicilotti> (also, quite OT: 706 users????? this channel is huge)
02:27:46 <Jafet> Help us to shrink it
02:28:09 <bicilotti> :( Jafet 
02:28:13 <c_wraith> I've seen it at 780 recently..
02:28:17 <c_wraith> this qualifies as shrunk :)
02:37:50 <robertosucks> I am looking or learning a Second language, i only know python and i want to expand my knolodge, haskell would be a good language to learn? why? it has nice opensource projects to i be a part of?
02:38:26 <dv-> yes
02:39:30 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/Applications_and_libraries
02:39:31 <robertosucks> dv-, and why?
02:39:54 <devsundar> robertosucks: http://www.haskell.org/haskellwiki/Why_Haskell_matters
02:39:57 <Jafet> Because this is like asking a politician who you should vote for
02:41:09 <devsundar> robertosucks: As you might know haskell is a purely functional language. It is a different style of programming. 
02:41:31 <Eduard_Munteanu> Also it's nice if you want to get deeper into theoretical CS. Not much of a reason for many people, but still.
02:42:13 <Eduard_Munteanu> It's also nice for fast prototyping.
02:42:56 <devsundar> robertosucks: You have to try out yourself and judge whether it is good for you or you want to learn Haskell.
02:43:27 <robertosucks> devsundar, haskell has a web intrepreter to try on?
02:43:52 <devsundar> robertosucks: http://tryhaskell.org/
02:44:12 <c_wraith> doesn't mtnviewmark have a new site up, too?
02:44:35 <devsundar> robertosucks: I would recommend GHCI if you decide to learn Haskell.
02:45:25 <c_wraith> Hmm. Yes, it's called Barley.  I don't see if there's a standalone server for it
02:45:37 <robertosucks> the online intrepreter is too too slow
02:46:10 <Eduard_Munteanu> robertosucks: you can ask lambdabot here, or on private for longer sessions.
02:46:18 <Eduard_Munteanu> > putStrLn "Hello World!"
02:46:19 <lambdabot>   <IO ()>
02:46:29 <Eduard_Munteanu> > print "Hello World!"
02:46:30 <lambdabot>   <IO ()>
02:46:35 <Eduard_Munteanu> WTH?!
02:46:42 <Jafet> > text "Hello, world!"
02:46:43 <lambdabot>   Hello, world!
02:46:51 <Eduard_Munteanu> That used to work.
02:47:43 <Eduard_Munteanu> > sort [3,2,1,4]  -- works too
02:47:44 <lambdabot>   [1,2,3,4]
02:47:55 <devsundar> robertosucks: http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
02:48:06 <devsundar> Hope it is useful.
02:49:36 <Jafet> Eduard_Munteanu: I don't recall it ever working
02:58:12 <devsundar>  Jafet: lambdabot does not seem to be working.
02:59:33 <Jafet> @vixen where do you work?
02:59:35 <lambdabot> maybe. do you?
03:04:01 <c_wraith> > 1 + 1
03:04:02 <lambdabot>   2
03:05:08 <bicilotti> > [1..10]
03:05:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:05:13 <bicilotti> cool
03:06:08 <alvivi> Has anyone here installed Haskell-Plataform (2010.2.0.0 / ghc 6.12.3) on Snow Leopard?
03:13:43 <hskltyp> http://hpaste.org/44321/asdf <-- anyone else run into this problem while trying to build hcsound on OSX?
03:24:45 <amiddelk> hi. I'm trying to register to trac.haskell.org, but I'm not receiving any verification email
03:25:49 <amiddelk> also, a colleague of mine also has this problem
03:37:02 <Saizan> @tell cocon it's pretty well known in the dependently typed world
03:37:03 <lambdabot> Consider it noted.
03:38:11 <cads> can someone recommend a good tutorial for making little parsers for data? I'd like to parse things like logical syntax, or sequences of chess moves, and probably other things
03:38:55 <c_wraith> cads, have you looked at parsec tutorials?
03:38:56 <cads> and also how would you guys recommend storing those parsed in persistent database or serializing them
03:39:13 <c_wraith> I mean, parsec's not my favorite lib, but there are a lot of tutorials available for it
03:39:37 <nzero> cads: http://book.realworldhaskell.org/read/using-parsec.html isn't bad.  csv-parsing tutorial with parsec.
03:39:39 <dibblego> parsec would be fine for PGN chess data
03:40:57 <cads> want to make something that takes a sequence of moves and checks them for validity
03:41:04 <cads> maybe it can output pgn, too
03:41:14 <dibblego> I do that in my haskell course but for tic-tac-toe
03:41:19 <dibblego> enforced in the type system
03:41:30 <cads> heh, what language is that?
03:41:36 <dibblego> haskell
03:41:59 <dibblego> http://hackage.haskell.org/package/TicTacToe
03:43:25 <c_wraith> I'm really curious to see how the grammar combinator libraries work out
03:49:17 <cads> dibblego: I'll study that when I'm thinking of ways to represent the chess game in haskell
03:49:27 <dibblego> cads: I keep meaning to write chess myself
03:49:48 <dibblego> but I'll just wait for copumpkin to write it in Agda for me
03:51:46 <cads> oh nice http://hackage.haskell.org/package/game-tree
04:14:29 <Maxdamantus> What's the purpose of the separate GHC.Ptr?
04:14:43 <accel> what is GHC.Ptr ?
04:14:59 <Maxdamantus> A package, apparently.
04:15:21 <accel> it's also "GHC"" ++ "." ++ "Ptr"
04:15:27 <accel> is it a C Ptr?
04:15:33 <accel> for the FFI, or part the implementation of GHC ?
04:15:41 <Maxdamantus> Which includes GHC.Ptr.Ptr, which seems to be a separate type to uhh.. Foreign.ForeignPtr.Ptr or something.
04:16:24 <Maxdamantus> Well, this will be GHC-specific .. I'm trying to read into a normal Ptr from the FFI using GHC's fdReadBuf
04:19:41 <Eduard_Munteanu> Maxdamantus: maybe it's moving FFI out of GHC internals since it got adopted into Haskell'?
04:20:38 <Maxdamantus> But how long has the FFI been in GHC?
04:20:52 <Maxdamantus> When I Google fdReadBuf, I get suggestions of it being added last year.
04:21:15 <Maxdamantus> Wait, 2009 was the one before last.
04:23:35 <tombee> with dropWhile, is it possible to put more than one function in the comparison bit
04:23:54 <Maxdamantus> What for?
04:23:58 <tombee> so I want to dropWhile (==' ' || =='\n')
04:24:32 <tombee> if you curry the functions then you get problems with the ordering of course
04:24:44 <mauke> curry? what
04:24:55 <tombee> but with my list, I can't be certain whether the ' ' or the '\n' is first
04:24:58 <mauke> that's not "two functions", and currying only applies to multi-arg functions
04:25:24 <tombee> no i meant dropWhile (==' ') . dropWhile (=='\n')
04:25:44 <mauke> tombee: how about naming the function parameter?
04:26:10 <Maxdamantus> :t `elem` " \n"
04:26:12 <lambdabot> parse error on input ``'
04:26:16 <Maxdamantus> :t (`elem` " \n")
04:26:17 <lambdabot> Char -> Bool
04:26:31 <tombee> ah :)
04:27:35 <tombee> That's great Maxdamantus thank you.
04:27:55 <tombee> My next question is, what's the normal way of catching exceptions when using readFile
04:28:14 <tombee> so that I can provide useful output that there's a problem reading the file, rather than just crasing :)
04:28:17 <tombee> crashing*
04:28:37 <dv-> bracket
04:29:19 <mauke> the normal way is not to use readFile
04:30:20 <tombee> ok mauke 
04:31:30 <Silex> :b1
04:31:38 <Silex> oops, sorry
04:33:00 <tombee> mauke, what do you recommend?
04:33:39 <mauke> opening the file manually and no lazy I/O
04:34:09 <tombee> hm ok
04:42:48 <Maxdamantus> Eh, how do I figure out the size of what's pointer to by a Ptr a?
04:43:27 <mauke> compute the size of a
04:43:39 <mauke> what's the context here?
04:43:59 <Maxdamantus> Hm, I guess that can't really be got without a value of type a.
04:44:17 <mauke> :t sizeOf
04:44:18 <lambdabot> Not in scope: `sizeOf'
04:44:23 <luite> use sizeOf of your Storable a
04:44:33 <mauke> :t Storable.sizeOf
04:44:35 <lambdabot> forall a. (Foreign.Storable.Storable a) => a -> Int
04:44:49 <mauke> :t Storable.sizeOf (undefined :: CInt)
04:44:51 <lambdabot> Not in scope: type constructor or class `CInt'
04:45:17 <mauke> :t Storable.sizeOf (undefined :: Foreign.C.Types.CInt)
04:45:18 <lambdabot> Int
04:45:24 <mauke> > Storable.sizeOf (undefined :: Foreign.C.Types.CInt)
04:45:25 <Maxdamantus> (sizeOf :: Storable foo => foo -> Int) something
04:45:26 <lambdabot>   Not in scope: `Storable.sizeOf'Not in scope: type constructor or class `For...
04:45:34 <mauke> aww
04:45:41 <Maxdamantus> This seems funny.
04:47:48 * Maxdamantus wonders how pointer incerementation is implemented then.
04:48:14 <mauke> plusPtr
04:48:31 <Maxdamantus> Indeed, but .. how does that *figure out* how many bytes to increment by?
04:48:36 <mauke> it's an argument
04:48:42 <Maxdamantus> Without a value of type a to pass to sizeOf
04:48:51 <mauke> well, real pointer arithmetic would be peekElemOff
04:48:57 <jonkri> anyone knows how i can go from a string/bytestring (where all characters are part of iso-8859-1/latin1) to a iso-8859-1/latin1 bytestring?
04:49:06 <jonkri> i'm using utf8-string but i'm not sure it can do that
04:49:22 <luite> plusPtr advances by a byte offset, advancePtr (Foreign.Marshal.Array) advances by some number of elements, but requires that a is Storable
04:50:05 <mauke> jonkri: Data.ByteString.Char8.pack
04:50:07 <Maxdamantus> :t plusAddr
04:50:09 <lambdabot> Not in scope: `plusAddr'
04:50:27 <mauke> Maxdamantus: undefined is a value
04:50:36 <Maxdamantus> Oh, right.
04:50:43 <luite> plusAddr would be silly, you can't add addresses :p
04:51:04 <Maxdamantus> plusPtr uses some plusAddr in GHC.
04:51:13 <luite> oh ok, still silly ;p
04:51:36 <jonkri> mauke: thanks
04:52:20 <Maxdamantus> fdReadBuf fd (castPtr buf) (fromIntegral $ sizeOf (undefined :: InputEvent))
04:52:21 <Maxdamantus> O_o
04:52:30 <luite> oh looks like it's a primop
04:55:51 <Ke>  /rmreconns
05:08:49 <jonkri> @hoogle Char -> Word8
05:08:50 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
05:08:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:08:50 <lambdabot> Prelude error :: [Char] -> a
05:08:58 <jonkri> how do i go from a [Char] where all the characters are in iso-5589-1 to a [Word8]?
05:16:04 <jonkri> oh, i guess c2w will work :)
05:19:26 <Xilon> concat and toChunks may be of interest
05:19:52 <dankna> @hoogle [Char] -> ByteString
05:19:53 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
05:19:53 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
05:19:53 <lambdabot> Prelude error :: [Char] -> a
05:20:02 <dankna> that's the one - Data.ByteString.Char8 pack
05:20:23 <dankna> note that you could also do
05:20:44 <dankna> > Data.ByteString.pack $ map ord "abc"
05:20:45 <lambdabot>   Not in scope: `Data.ByteString.pack'
05:21:03 <dankna> > pack $ map (fromIntegral . ord) "abc"
05:21:04 <lambdabot>   Not in scope: `pack'
05:21:23 <dankna> and personally, I would do it the way I just gave, because it's a lot clearer
05:21:51 <dankna> the conversion is "unsafe" in the sense that it's not what many people are expecting, so it SHOULD be written out longhand rather than with an abbreviatin
05:21:54 <dankna> *abbreviation
05:22:00 <tombee> how can I turn [1,2,3,4,5] to "1 2 3 4 5" without using intercalate ?
05:22:36 <sipa> why don't you want to use intercalate?
05:22:37 <Ke> what's wrong with intercalate?
05:22:38 <Xilon> unwords
05:22:53 <dankna> tombee: fold on the list, with the state being a result string.  in each iteration, append a space and the formatted numeral.  then drop the leading space at the end.
05:23:05 <Xilon> > unwords . map show $ [1..5]
05:23:07 <lambdabot>   "1 2 3 4 5"
05:23:20 <tombee> intercalate doesn't work in hugs
05:23:25 <tombee> I don't think?
05:23:29 <dankna> I took the question to be, how does intercalate work?  if your goal is to understand it, then my suggestion makes sense.  if your goal is to avoid it for some other reason, I would argue as others have that you should just use it.
05:23:35 <burp> hugs? O_O
05:23:35 <dankna> hm, I would think it would, it's part of the standard?
05:23:46 <sipa> > foldr (\s q -> s ++ " " ++ show q) "" [1,2,3,4,5]
05:23:47 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
05:23:47 <lambdabot>    arising from the literal ...
05:23:51 <burp> hugs is still maintained?
05:23:57 <sipa> > foldr (\q s -> s ++ " " ++ show q) "" [1,2,3,4,5]
05:24:00 <lambdabot>   " 5 4 3 2 1"
05:24:04 <sipa> right!
05:24:12 <dankna> you need to fold from the left
05:24:14 <sipa> > foldl (\s q -> s ++ " " ++ show q) "" [1,2,3,4,5]
05:24:15 <Xilon> @src unwords
05:24:15 <lambdabot> unwords [] = ""
05:24:16 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
05:24:16 <lambdabot>   " 1 2 3 4 5"
05:24:30 <tombee> unwords is perfect, thanks :)
05:24:31 <sipa> > tail $ foldl (\s q -> s ++ " " ++ show q) "" [1,2,3,4,5]
05:24:33 <lambdabot>   "1 2 3 4 5"
05:24:53 <dankna> oh, rather, you can fold from the right but you need to construct the string carefully.  should do it from the right actually, for efficiency's sake.
05:25:15 <xplat> foldr1 (\a -> (show a ++) . (" " ++)) show [1..5]
05:25:23 <xplat> > foldr1 (\a -> (show a ++) . (" " ++)) show [1..5]
05:25:24 <lambdabot>   Couldn't match expected type `[GHC.Base.String]'
05:25:24 <lambdabot>         against inferred t...
05:26:09 <ddarius> dankna: intercalate is not part of Haskell 98.
05:26:13 <dankna> oh!
05:26:13 <tombee> > intercalate " " . map show $ [1..5]
05:26:15 <dankna> okay
05:26:15 <lambdabot>   "1 2 3 4 5"
05:26:18 <dankna> is it part of Haskell 2010?
05:26:31 <tombee> 'ERROR - Undefined variable "intercalate"'
05:26:34 <tombee> I get in hugs :(
05:26:53 <tombee> I've been using GHC, but this stuff needs to work in hugs too :)
05:26:54 <xplat> > foldr1 (\a -> (a ++) . (" " ++)) . map show $ [1..5]
05:26:56 <lambdabot>   "1 2 3 4 5"
05:26:56 <Xilon> Are you importing Data.List?
05:27:01 <tombee> yes Xilon :)
05:27:10 <dankna> why exactly do you need it to work in Hugs?  we might be able to suggest alternatives
05:27:16 <Xilon> Had to ask ;)
05:27:25 <ddarius> dankna: Yes.
05:27:25 <tombee> dankna, for the institution I attend
05:27:32 <dankna> you can always define intercalate yourself, it's a relatively easy thing to do
05:27:39 <dankna> oh, it's for a professor.  okay.
05:27:44 <tombee> the unwords method works fine :)
05:27:47 <dankna> okay :)
05:27:56 <Eduard_Munteanu> tombee: why do you need it to work in Hugs? It's not even maintained anymore, AFAIK.
05:27:58 <tombee> thank you for your help guys
05:28:00 <dankna> he just answered that :)
05:28:08 <dankna> np
05:28:12 <Xilon> tombee: Intercalate would pretty much be 'unwords', just with a user-specified delimiter
05:28:22 <Eduard_Munteanu> Ah.
05:28:28 <tombee> I have only *JUST* tried hugs, as I thought well I may as well make sure it works on that too.
05:28:30 <Eduard_Munteanu> Sorry, I was slow :(
05:28:39 <tombee> Have been using the GHC platform up until now
05:28:52 <dankna> GHC is the preferred way to do things, but yes, if the grader is going to use Hugs you do need to check in it
05:29:00 <Eduard_Munteanu> @src intercalate
05:29:00 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
05:29:05 <dankna> @src intersperse
05:29:06 <lambdabot> intersperse _   []     = []
05:29:06 <lambdabot> intersperse _   [x]    = [x]
05:29:06 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
05:29:13 <Eduard_Munteanu> There ya go.
05:29:44 <tombee> thanks :)
05:29:48 <Eduard_Munteanu> Uh, and sorry if was a spoiler :)
05:30:01 <xplat> there ought to be a foldr10 which is foldr1 with an empty case
05:30:02 <tombee> It's no spoiler, I've just switched it to unwords now
05:30:17 <dankna> xplat: uh, ...!
05:30:37 <Xilon> Hmm doesn't seem to be part of the standard... oO
05:30:42 <xplat> dankna: foldr is hard to use when the empty case is unrelated to the singleton case
05:31:27 <dankna> hmm.... yes, but is it really even a function in the fold family when you're doing that?
05:31:43 <dankna> what I would do is wrap the fold state in a Maybe
05:31:52 <dankna> but I suppose that's more work, yes
05:32:22 <dankna> I'd ask about your usage scenario, but I need to head off now
05:32:54 <xplat> intercalate, intersperse, and unwords are all foldr10s
05:33:48 <dankna> hmmm, I guess they are, actually.
05:33:50 <dankna> okay.
05:40:12 <Mathnerd314> would foldr10 be a fold for a binary tree? (data X a b = Empty | One a | Tree X b X)
05:42:34 <xplat> Mathnerd314: something seems wrong with your tree type
05:43:01 <Mathnerd314> oh, yeah. take out the b. data X a = Empty | One a | Tree X X
05:43:12 <Boxo> still wrong :)
05:43:31 <Mathnerd314> data X a = Empty | One a | Tree (X a) (X a)
05:43:40 <Boxo> yeah
05:43:48 <Mathnerd314> but that could easily be inferred :-)
05:44:37 <xplat> well, now at least i can see what was intended.  and yeah, for associative combiners at least, you could see a foldr10 as a fold on that tree type pushed forward through its toList
05:45:43 <xplat> although the list type List a = Empty | NonEmpty (NEList a) works just as well
05:46:28 <xplat> (and for nonassociative operators too)
05:48:12 <Boxo> you sure about that list type?
05:49:00 <xplat> Boxo: it goes with data NEList a = Cons a (NEList a) | Singleton a
05:49:16 <Boxo> oh :o
05:49:26 <xplat> (which is what foldr1 is really a fold over)
05:49:32 <Boxo> yes
05:51:09 <Mathnerd314> :t foldr1
05:51:10 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
05:52:08 <ddarius> NEList = (a, [a])
05:52:16 <Mathnerd314> foldr1 isn't a fold at all, AFAICT
05:52:21 <xplat> foldr1's type is a little wrong for a fold too, but it's convenient for some uses
05:53:00 <xplat> since it doesn't require trivial injectors for those uses
05:53:13 <Mathnerd314> :t foldr
05:53:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:53:42 <xplat> but really it should be forall a b. (a -> b -> b) -> (a -> b) -> [a] -> b
05:53:59 <ddarius> It can be built from foldr, by, for example, having (undefined, False) be the base case and doing an if on the boolean and setting it to True in the inductive case.
05:54:09 <xplat> and i even forgot it wasn't the first time i tried to write something with it today
05:55:49 <Mathnerd314> xplat: maybe the (a -> b) should come first? then foldr1 = better_foldr1 id ?
05:57:21 <xplat> hm, normally i'd say the binary should come first.  maybe you're right is this case, though ...
05:57:28 <xplat> *in
05:59:05 <xplat> library design is hard, let's go application programming!
05:59:20 <Mathnerd314> @src []
05:59:21 <lambdabot> data [] a = [] | a : [a]
06:00:31 <Mathnerd314> hmm, either that definition or foldr should be changed
06:01:33 <xplat> you want foldr to be derived automatically from the declaration of []?
06:02:22 <Mathnerd314> of course :-)
06:02:57 <xplat> maybe the deriver should work from the last constructor to the first :)
06:02:59 <ddarius> @hoogle gfold
06:03:00 <lambdabot> Data.Graph.Inductive.Basic gfold :: Graph gr => (Context a b -> [Node]) -> (Context a b -> c -> d) -> (Maybe d -> c -> c, c) -> [Node] -> gr a b -> c
06:03:00 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
06:03:00 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
06:06:15 <xplat> i wonder if syb is powerful enough to sensibly write cata and zygo and prepro and friends
06:06:16 <Mathnerd314> I'd look at some common folds and see which version of foldr makes them easier to write. But that's just me.
06:07:33 <xplat> i think probably not, for the same reason that most parser combinator libraries don't enable left recursion elimination
06:08:09 <xplat> namely, sharing isn't visible
06:09:54 <xplat> maybe with an auxiliary typeclass that lets you expose recursion ...
06:10:00 <Mathnerd314> a flaw in those libraries, clearly.
06:11:01 <Mathnerd314> maybe you'd end up with something like multirec?
06:11:08 <xplat> Mathnerd314: the present argument order of foldr is much better for writing things.  like, (++) = foldr (:) ...
06:11:09 <copumpkin> any real parser lets you parse anything
06:11:19 <xplat> Mathnerd314: maybe
06:11:55 <hpc> :t foldr (:)
06:11:56 <lambdabot> forall a. [a] -> [a] -> [a]
06:12:15 <hpc> > foldr (:) "foo" "bar"
06:12:16 <lambdabot>   "barfoo"
06:12:17 <xplat> > foldr (:) "hello " "world!"
06:12:18 <lambdabot>   "world!hello "
06:12:22 <hpc> lol
06:12:25 <Mathnerd314> copumpkin: are there any real parsers around?
06:12:40 <xplat> er, i meant flip foldr (:) :)
06:12:40 <Saizan> xplat: you can sort of tell where the recursive occurrences are by checking typeOf
06:12:46 <copumpkin> Mathnerd314: yeah, somewhere
06:12:55 <hpc> :t typeOf
06:12:56 <lambdabot> forall a. (Typeable a) => a -> TypeRep
06:13:05 <copumpkin> Mathnerd314: http://en.wikipedia.org/wiki/Earley_parser
06:14:12 <Mathnerd314> copumpkin: that doesn't parse context-sensitive grammars. any *real* parser should handle a^n b^n c^n d^n e^n easily.
06:14:22 <copumpkin> Mathnerd314: oh, true
06:14:30 <xplat> https://github.com/djspiewak/gll-combinators
06:15:17 <xplat> doesn't handle CSGs, though
06:15:59 <xplat> there are some tools that go as high as boolean grammars
06:16:34 <xplat> and of course any basic parser combinator can handle recursive grammars if you use it carefully
06:17:26 <xplat> but there's nothing that combines carefree grammar specification with the power of recursive grammars afaik
06:17:45 <kramble> hi, i remember there is a short syntax for creating an object wich is equal to another, with only a few properties changed. Could someone remember me the syntax pleas ?
06:17:57 <xplat> unless maybe you manage to turn a powerful CFG parser in on itself with two-level grammars
06:18:18 <augustss> kramble: do you mean record update?
06:18:19 <xplat> kramble: myRecord { field = newValue, field2 = another }
06:18:52 <kramble> augustss: yes exaclty
06:19:12 <kramble> xplat: myRecord is the old one ? and it change properties field and field2 ?
06:19:14 <augustss> kramble: well, looks at xplat's answer then :)
06:20:19 <xplat> kramble: yes
06:20:24 <kramble> thx guys
06:21:16 <Mathnerd314> there were those "weird" parser combinators... which claimed to handle everything in O(n) time or whatever
06:21:42 <xplat> packrat parsers are the only ones i know of that are O(n)
06:21:55 <xplat> or rather O(kn) where k is the size of the grammar
06:22:07 <xplat> (in number of nonterminals)
06:22:19 <xplat> but it doesn't parse CFGs or anything
06:22:31 <roconnor> w00t!
06:22:52 <roconnor> ((.).) . (.) === (.(.)) . (.) . (.) !
06:22:55 <roconnor> awesome
06:23:07 <augustss> if you say so
06:23:18 <roconnor> lambdabot says so
06:23:23 <xplat> instead it's a formalism that is kind of similar to CFGs, but easier to write parsers for
06:23:26 <roconnor> @unpl ((.).) . (.)
06:23:26 <augustss> :t (.).) . (.)
06:23:27 <lambdabot> (\ j m b c -> j (m (b c)))
06:23:27 <lambdabot> parse error on input `)'
06:23:30 <xplat> writing generators for it is hard though!
06:23:40 <roconnor> @unpl (.(.)) . (.) . (.) 
06:23:40 <lambdabot> (\ m s g j -> m (s (g j)))
06:23:47 <augustss> :t ((.).) . (.)
06:23:48 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
06:24:00 <augustss> I hate . being fmap
06:24:00 <rtharper> that makes me sad
06:24:02 <roconnor> beware of  caleskel
06:24:17 <hpc> :t (.(.)) . (.) . (.)
06:24:17 <roconnor> @unpl (Prelude..(Prelude..)) Prelude.. (Prelude..) Prelude.. (Prelude..) 
06:24:17 <lambdabot> ((Prelude..) ((Prelude..) (\ a -> (Prelude..) a (Prelude..)) (Prelude..)) (Prelude..))
06:24:18 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
06:24:25 <roconnor> er
06:24:28 <roconnor> @type (Prelude..(Prelude..)) Prelude.. (Prelude..) Prelude.. (Prelude..) 
06:24:30 <lambdabot> forall b b1 c a. (b1 -> c) -> (b -> b1) -> (a -> b) -> a -> c
06:24:39 <augustss> I think it's really bad for beginners that lambdabot isn't Haskell
06:24:55 <kramble> :t .
06:24:55 <xplat> i guess using a CFG toolkit with two-level grammars won't work
06:24:56 <lambdabot> parse error on input `.'
06:24:57 <roconnor> I agree
06:25:00 <hpc> augustss: i think it's fine; they have ghci and us to tell them which to use
06:25:02 <kramble> :t (.)
06:25:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:25:07 <kramble> WTF
06:25:16 <xplat> since two-level grammars can generate semidecidable languages
06:25:21 <augustss> hpc: not good enough
06:25:23 <roconnor> kramble: Cale likes messing with people's heads
06:25:32 <kramble> saw that
06:25:51 <kramble> :t (o)
06:25:53 <lambdabot> Expr
06:26:04 <kramble> :t (°)
06:26:06 <lambdabot> parse error (possibly incorrect indentation)
06:27:06 <xplat> i've heard that lambdabot isn't handling utf-8 correctly
06:27:33 <Eduard_Munteanu> :t fmap fmap fmap fmap fmap fmap
06:27:34 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
06:27:45 <Mathnerd314> ah, it was that paper "Yacc is dead"
06:28:05 <Eduard_Munteanu> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
06:28:07 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
06:28:13 <augustss> :t flip flip flip flip flip flip flip flip
06:28:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
06:28:16 <Eduard_Munteanu> Something like that used to be buggy.
06:28:33 <augustss> :t flip
06:28:34 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:28:47 <augustss> What?  flip is ruined too?
06:28:53 <hpc> flip is awesomeified
06:29:01 <augustss> ruined
06:29:14 <roconnor> :T (∘)
06:29:39 <roconnor> augustss: flip seems to hit a fixed point after about 3 steps
06:29:48 <augustss> yes, it does
06:29:55 <hpc> :t fix flip
06:29:55 <lambdabot> forall a b. a -> a -> b
06:30:04 <hpc> haha
06:30:11 <kramble> :t fix
06:30:12 <lambdabot> forall a. (a -> a) -> a
06:30:23 <Eduard_Munteanu> Ok, my previous :t still goes nuts on GHC 6.12.3
06:30:43 <hpc> oh, that makes sense now
06:30:50 <hpc> it normalizes f to (->) a
06:31:31 <Eduard_Munteanu> :t fix (flip flip)
06:31:35 <lambdabot>     Occurs check: cannot construct the infinite type:
06:31:36 <augustss> :t ($)
06:31:37 <lambdabot>       a = f (a -> b) -> f b
06:31:39 <lambdabot> forall a b. (a -> b) -> a -> b
06:31:41 <lambdabot>     Probable cause: `flip' is applied to too few arguments
06:33:00 <Eduard_Munteanu> > (fix flip $ id) 0 
06:33:04 <lambdabot>   mueval-core: Time limit exceeded
06:33:49 <augustss> Eduard_Munteanu: it's not a normal fixpoint, it's this sequence: flip, flip flip, flip flip flip, flip flip flip flip, ...
06:34:19 <Eduard_Munteanu> But that can't possibly converge type-wise.
06:34:31 <augustss> it does
06:35:12 <Eduard_Munteanu> flip :: (a -> b -> c) -> (b -> a -> c)
06:35:29 <Mathnerd314> :t flip
06:35:29 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:35:35 <augustss> @let fl = Preluse.flip
06:35:35 <lambdabot>  <local>:10:5: Not in scope: `Preluse.flip'
06:35:53 <augustss> @let fl = Prelude.flip
06:35:54 <lambdabot>  <local>:10:5: Not in scope: `Prelude.flip'
06:36:15 <dreixel> xplat: no, syb can't really do that because it doesn't have a fixed-point view on data
06:36:17 <augustss> @let fl f x y = f y x
06:36:18 <Saizan> @let fl = P.flip
06:36:18 <lambdabot>  Defined.
06:36:19 <lambdabot>  <local>:11:5: Not in scope: `P.flip'
06:36:29 <augustss> :t fl fl fl fl fl fl 
06:36:30 <lambdabot> forall t1 t t2 t11 t21. (t11 -> ((t1 -> t -> t2) -> t -> t1 -> t2) -> t21) -> t11 -> t21
06:36:39 <augustss> :t fl fl fl fl
06:36:40 <lambdabot> forall t1 t t2 t11 t21. (t11 -> ((t1 -> t -> t2) -> t -> t1 -> t2) -> t21) -> t11 -> t21
06:36:48 <augustss> :t fl fl fl
06:36:49 <lambdabot> forall t1 t2 t11 t t21. (t1 -> ((t11 -> t -> t21) -> t -> t11 -> t21) -> t2) -> t1 -> t2
06:37:02 <Eduard_Munteanu> :t fl
06:37:03 <lambdabot> forall t1 t t2. (t1 -> t -> t2) -> t -> t1 -> t2
06:37:12 <Eduard_Munteanu> :t fix fl
06:37:12 <lambdabot> forall t t2. t -> t -> t2
06:37:20 <Eduard_Munteanu> Hrm.
06:37:48 <kuznero> Hello All!
06:38:10 <xplat> dreixel: as i thought ...
06:38:13 <Eduard_Munteanu> Oh, I get it!
06:38:16 <Eduard_Munteanu> :t fix
06:38:17 <lambdabot> forall a. (a -> a) -> a
06:38:39 <Eduard_Munteanu> (a -> a) forces types in 'fl' / 'flip' to be equal.
06:39:04 <Eduard_Munteanu> So it acts on flip :: (a -> a -> c) -> (a -> a -> c)
06:43:11 <Mathnerd314> :t fl fl fl `asTypeOf` fl fl fl fl
06:43:11 <lambdabot> forall t1 t t2 t11 t21. (t11 -> ((t1 -> t -> t2) -> t -> t1 -> t2) -> t21) -> t11 -> t21
06:47:23 <Mathnerd314> is there some way to quickcheck if those are the same?
06:51:07 <copumpkin> Mathnerd314 they kind of have to be assuming they terminate
06:51:48 <ddarius> The space of Haskell functions is neither discrete nor Hausdorff.
06:52:27 <ddarius> (With the possible exception of functions from Void -> Void.)
06:56:46 <byorgey> hi kuznero 
06:57:06 <kuznero> Hello byordey
06:57:40 <ddarius> byorgey: If you do end up with a reasonably efficient, elegant way to enumerate linear lambda terms, I'd be interested.
06:58:20 <byorgey> ddarius: pairs are turning out to be slightly harder than I thought.  But I'll keep you posted.
06:59:11 <byorgey> ddarius: out of curiosity, why would you be interested?
06:59:54 <copumpkin> I am interested in why you would be interested
07:00:03 <copumpkin> byorgey, that is
07:00:32 <ddarius> byorgey: Because you are implementing a linear logic theorem prover which is similar to linear logic languages and I haven't seen a good system for handling resource usage.
07:00:57 <byorgey> ok, right.
07:01:18 <copumpkin> ddarius: I met one of the lollimon guys by the way :)
07:01:34 <ddarius> If you continue, you'll find that _|_ is a nasty connective to add.
07:02:12 <ddarius> copumpkin: Which?
07:02:25 <copumpkin> Polakow
07:05:38 <ddarius> Apparently Alt-n does something in Youtube's video player.
07:12:52 <fram> hi, how can I maintain some state in a gtk application? signal handlers have type IO () ....
07:14:51 <siracusa> fram: Create an IORef containing your state and read/set the ref in your signal handlers.
07:14:53 <ddarius> fram: Use IORefs.
07:15:14 <fram> thanks!
07:19:30 <ddarius> fram: One thing you can do is make wrappers for the signal handlers that hide all the IORef munging.
07:45:32 <copumpkin> yay, I can get a monad from an adjunction in my library :)
07:52:08 <ddarius> How easily can you get the Cont monad?
07:52:52 <copumpkin> I haven't made any real concrete categories yet
07:53:13 <copumpkin> I'll give it a go in a bit
07:57:14 <confound> http://hpaste.org/44323/what_am_i_missing
07:57:31 <copumpkin> probably --make
07:57:42 <confound> yep, thanks
07:58:09 * copumpkin ponders --mauke
07:59:51 <pozic> Is there a 'get type' function in Coq? 
08:00:01 * confound tickles mauke
08:00:24 <roconnor> pozic: check
08:00:36 <andrewu> I am new to arrows; try to perform IO (eg. putStr) inside an arrow. how?
08:00:42 <roconnor> pozic: print will also print the type (and the term)
08:00:49 <copumpkin> andrewu: wrap your monadic action in Kleisli
08:00:56 <copumpkin> if it doesn't take a parameter, make it take ()
08:01:03 * copumpkin shudders
08:01:07 <pozic> roconnor: I want to say that certain types in a Section are the same.
08:01:09 <hpc> eek
08:01:14 <pozic> roconnor: #coq.
08:02:07 <copumpkin> the power of coq compels you!
08:02:57 <hpc> i should probably learn how to use coq
08:03:48 <ddarius> copumpkin: If you define product categories you can define products and exponents via adjunction.
08:04:26 <ddarius> Then you can define a "Cont" monad in any cartesian closed category (or indeed any symmetrically monoidally closed category.)
08:04:42 <copumpkin> ddarius: I already have product categories, but one of my goals has been to keep the definitions as simple as possible (i.e., not much indirection between concepts) and then to show equivalence with the more interesting definitions
08:05:15 <copumpkin> that sounds neat though
08:05:27 <copumpkin> I haven't written cartesian closed yet
08:07:10 * hackagebot snap-core 0.4.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.4.1 (GregoryCollins)
08:09:00 <andrewu> copumpkin: i tried, but did not succeed. I would like to have an arrow of type "application :: (Arrow a) => a (IO Val) (IO Val)" . how can i just print the Val?
08:09:11 * hackagebot snap-server 0.4.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.4.1 (GregoryCollins)
08:09:20 <copumpkin> andrewu: that seems like an odd type to have
08:09:40 <copumpkin> :t Kleisli print
08:09:41 <lambdabot> forall a. (Show a) => Kleisli IO a ()
08:10:25 <copumpkin> your application arrow is just id for the underlying Category
08:11:01 <copumpkin> I guess you could make it do something slightly more interesting, but not if you're polymorphic in the Arrow
08:11:08 <ddarius> copumpkin: It could be arr f for any f :: IO Val -> IO Val as well as many other possibilities.
08:11:39 <ddarius> Well, maybe not many other possibilities.
08:11:41 <copumpkin> sure, but none of them will do anything interesting 
08:11:57 <mauke> who dares tickle me?
08:11:58 <copumpkin> well, none of them will do what he wants
08:12:01 <ddarius> They wouldn't use the structure of the arrow, no.
08:12:27 <confound> mauke: :D
08:12:41 <ddarius> mauke: Your older sister.
08:13:19 <mauke> ddarius: that's exactly ... rrect?
08:13:33 <mauke> because my sister is younger, and it's me who does the tickling
08:13:43 <copumpkin> :O
08:14:24 <ddarius> mauke: So your older sister no longer exists, which is clearly what happens to those who dare to tickle mauke.
08:15:47 <copumpkin> does cartesian category mean cartesian monoidal category?
08:16:13 <copumpkin> "The term cartesian category usually means a category with finite products but can also mean a finitely complete category, so we avoid that term."
08:16:23 <copumpkin> I guess that's my answer
08:19:07 <copumpkin> ddarius: going to work on building up to CCCs and Cont now, but need to build some of the underlying machinery first
08:19:41 <ddarius> It probably wouldn't be a bad idea to define the terminal category if you haven't already.
08:20:23 <ddarius> Do you have Cat yet?
08:20:28 <copumpkin> nope
08:20:43 <copumpkin> I have terminal objects, but have been putting off an annoying proof that I need for Cat
08:21:16 <andrewu> compupkin: thank you for the help. still not working  -- error "expression .. was found where an arrow command expected". i have code 
08:21:19 <andrewu> application :: (Arrow a) => a (IO Val) (IO Val)
08:21:20 <andrewu> application  = proc v -> do
08:21:20 <andrewu>                     Kleisly print 
08:21:20 <andrewu>                     returnA -< v 
08:21:33 <copumpkin> I think you're confused :)
08:21:42 <copumpkin> you don't want that type
08:22:14 * hackagebot snap 0.4.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.4.1 (GregoryCollins)
08:22:15 <copumpkin> and it's Kleisli, not Kleisly
08:22:45 * hpc suggests sticking to explicit arrow syntax
08:22:50 <hpc> arrow-do is confusing
08:23:37 <roconnor> w00t!
08:23:45 <copumpkin> roconnor: u haz succezz?
08:24:15 <roconnor> (($a).) . (. flip) . (.) . (.) = (((($a) .) .) . (.)) . (.)
08:24:30 <copumpkin> roconnor: I weep at the beauty
08:24:39 <roconnor> I need to generalize my inductive hypthesis a little
08:24:57 <roconnor> but if that goes through, my proof that a cartesian store is applicative works.
08:25:13 <copumpkin> cool
08:25:35 <copumpkin> so much typechecked category theory going on these days!
08:25:43 <andrewu> compupkin: i am confused. the error message is the same. -- i eventually want to do something else in this arrow which uses file IO - this is just testing.
08:25:56 <copumpkin> you just write Kleisli print
08:26:00 <copumpkin> that _is_ the arrow
08:26:14 <copumpkin> if you want something that prints the value but passes it through unchanged
08:26:38 <hpc> :t Kleisli
08:26:39 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
08:26:40 <copumpkin> @ty Kleisli (\x -> do print x; return x)
08:26:42 <lambdabot> forall a. (Show a) => Kleisli IO a a
08:27:01 <hpc> :t Kleisli print
08:27:01 <lambdabot> forall a. (Show a) => Kleisli IO a ()
08:27:03 <copumpkin> @ty Kleisli (liftA2 (>>) print return)
08:27:04 <lambdabot> forall b. (Show b) => Kleisli IO b b
08:27:28 <roconnor> copumpkin: my proof isn't typechecked :(  It is on paper
08:27:32 <copumpkin> roconnor: OH NO!
08:27:40 <copumpkin> I'M SURE IT'S ALL WRONG THEN
08:27:47 <roconnor> but I think I ought to formalize this in Coq ... or maybe try out matita
08:27:59 <roconnor> copumpkin: I wouldn't be surprised if it is all wrong
08:28:11 <roconnor> copumpkin: though I would be surprised if my theorem is false or unprovable.
08:28:59 <copumpkin> yeah
08:29:32 <DevHC> is there anything provably unprovable, other than the "this statement is unprovable" statement?
08:29:51 <copumpkin> ddarius: anyway, if I get this annoying proof out of the way, not only can I make the category of categories, but I can make the 2-category of categories
08:30:01 <copumpkin> I already have all the natural transformation machinery and proofs lying around 
08:30:35 <mauke> continuum
08:30:53 <roconnor> DevHC: there are several, but most use the same trick
08:31:05 <roconnor> DevHC: intrestingly the statement "this statement is provable" is actually provable.
08:31:12 <monochrom> the continuum hypothesis is provably unprovable
08:31:17 <mauke> henkin
08:31:30 <monochrom> a false statement is also provably unprovable
08:31:50 <copumpkin> monochrom: omg ergo continuum is provably false!
08:31:57 * copumpkin is good at logic
08:32:01 <mauke> cologic
08:32:07 <copumpkin> that's the one
08:32:40 <joska> hi! I would like to use the union function in ghci, but it says its not in scope. So how do I load it?
08:32:52 <mauke> @index union
08:32:53 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
08:32:59 <mauke> joska: import Data.List
08:33:03 <copumpkin> andrewu: does that make sense?
08:33:15 <roconnor> DevHC: monochrom brings up a good point.  The statement "this statement is unprovable" is only unprovable under the assumption that the system in question is consistent.
08:33:21 <copumpkin> if you want to do IO in an arrow, you want the Kleisli IO arrow
08:33:29 <copumpkin> or something equivalent to it
08:36:57 <DevHC> uhm, well i knew that. i mean to ask: is there any provably unprovable statement, which is true (or false), other than "this statement is unprovable"?
08:38:49 <DevHC> monochrom: how is a false statement provably unprovable?
08:38:54 <ddarius> DevHC: It's provable that, if Goldbach's conjecture is true, it's not provable in Peano arithmetic.
08:39:15 <joska> @index (\\)
08:39:15 <lambdabot> bzzt
08:39:22 <joska> @index \\
08:39:22 <lambdabot> bzzt
08:39:26 <joska> @index union
08:39:26 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
08:39:41 <doserj> if ZFC is consistent, its consistency is unprovable
08:40:16 <joska> so how can I use this one? http://haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Data-List.html#v:-92--92-
08:40:32 <ddarius> DevHC: Peano arithmetic is consistent, and 1 /= 2 in Peano arithmetic, therefore 1 = 2 is provable not provable.
08:40:40 <ddarius> s/provable/provably/
08:40:45 <mauke> joska: how can't you?
08:41:03 <joska> it says its not in scope
08:41:09 <mauke> import Data.List
08:41:38 <ddarius> DevHC: As an interesting note, the Goldbach conjecture is -equivalent- to it being provable in Peano arithmetic.
08:41:39 <andrewu> copumpkin: not working. how do i put a function "Val -> IO Val" into the arrow (i.e. what do i write after the "do" and before the "returnA"? i am new to arrows...
08:41:49 <paulh_> :m + Data.List in ghci
08:41:54 <copumpkin> andrewu: don't use do and returnA
08:41:57 <joska> thx
08:42:07 <copumpkin> andrewu: just write Kleisli followed by your function Val -> IO Val
08:42:12 <copumpkin> you'll get a Kleisli IO Val Val
08:42:25 <mauke> paulh_: why not 'import'?
08:42:32 <mdwright_laptop> how can I determine when I've hit an EOF with the IO monad?
08:42:36 <paulh_> mauke: he asked about ghci
08:42:43 <mauke> paulh_: so why not 'import'?
08:43:04 <paulh_> whatever
08:43:06 <DevHC> doserj: ok, a rather good example
08:43:20 <mauke> :-(
08:43:45 <xarch> mdwright_laptop: hm
08:43:45 <DevHC> ddarius: i'll have to know what exactly peano arithmetic is, but how is 1 = 2 provably not provable?
08:43:52 <xarch> for a Handle or for stdin?
08:43:56 <mauke> DevHC: how would you prove it?
08:43:59 <mdwright_laptop> xarch: stdin
08:44:04 <mauke> (stdin is a Handle)
08:44:09 <xarch> isEOF then
08:44:18 <xarch> mauke: yeah
08:44:28 <xarch> but there's predefined things for stdin
08:44:28 <mauke> mdwright_laptop: read from it, catch the exception
08:44:46 <doserj> DevHC: because peano arithmetic is consistent, you cannot prove both 1=2 and 1!=2. but you can prove 1!=2. so you cannot prove 1=2.
08:45:02 <mdwright_laptop> mauke: xarch: Thanks! I'll give it a shot
08:45:16 <n00p> How many false values does Haskell have?
08:45:31 <hpc> n00p: one, False
08:45:42 <hpc> as it should be
08:45:50 <n00p> hpc: So 0, when used in a condition, doesn't evaluate to false?
08:46:00 <mauke> you can't use 0 in a condition
08:46:01 <hpc> 0 isn't a Bool, so it won't typecheck
08:46:03 <mmaurer> n00p: 0 is not of appropriate type to be a condition
08:46:07 <xarch> no, Haskell has strong typing
08:46:11 <n00p> For example, in C: if (0) { printf("this will never execute\n"); }
08:46:17 <DevHC> why could i not prove both?
08:46:18 <n00p> Ok. Cool :)
08:46:28 <andrewu> compumkin: but i need:  a (IO Val) (IO Val)
08:46:29 <DevHC> i cannot prove both "in the peano arithmetic"?
08:46:33 <mauke> DevHC: is this going anywhere?
08:46:41 <roconnor> copumpkin: there, I *think* my paper proof is correct
08:46:42 <DevHC> (but i can prove both with rational thinking)
08:46:51 <mauke> xarch: that's unrelated; you could make an 'if' that allows it
08:47:03 <copumpkin> roconnor: I disagree! line 5, near the end, has a mistake
08:47:08 <mauke> DevHC: ok, prove 1=2 with rational thinking
08:47:19 <xarch> mauke: well
08:47:22 <monochrom> look for "consistent" or "consistency" in logic
08:47:29 <xarch> he didn't talk about if at the beginning
08:47:35 <DevHC> wait what
08:47:36 <xarch> 18:18 < n00p> hpc: So 0, when used in a condition, doesn't evaluate to false?
08:47:50 <mauke> true
08:48:21 <roconnor> copumpkin: crap
08:48:28 <ddarius> instance Num Bool where ...
08:48:45 <mmaurer> ddarius: We really shouldn't have one of those though...
08:48:49 <mmaurer> The enum instance is enough.
08:49:03 <ddarius> mmaurer: Bool (ignoring bottom) forms a field.
08:49:04 <hpc> ddarius: that could actually be fun to have, for modular arithmetic
08:49:22 <mauke> 0 is false in lambda calculus
08:49:31 <hpc> instance Num a => Num [a] where ...
08:49:39 * hpc is a bad person
08:49:44 <ddarius> mauke: In the Church/Scott encoding.
08:49:47 <mmaurer> ddarius: I agree, but why is that semantically boolean?
08:49:51 <mauke> hpc: that generalizes to all Applicative instances
08:50:09 <ddarius> And even then which of the encodings is "false" and which "true" is conventionaly.
08:50:11 <ddarius> -y
08:50:35 <xarch> and we're using Haskell
08:50:51 <ddarius> mmaurer: Define what "semantically boolean" means.
08:51:14 <hpc> mauke: seriously? :D
08:51:23 <DevHC> mauke, monochrom: ok, i thought that "provable" could also mean "can be shown to be false"
08:51:27 <hpc> how?
08:51:52 <ddarius> preflex: seen esap
08:51:52 <preflex>  esap was last seen on #haskell 220 days, 23 hours, 31 minutes and 8 seconds ago, saying: ski: ok I do have Zero :-)
08:51:55 <mmaurer> ddarius: This is a little more SE than I normally like to get, but while you can define a num instance over a 2 element type by using a field, that doesn't mean you should, as the concept of adding True and False together doesn't make much sense.
08:51:56 <mauke> hpc: http://mauke.dyndns.org/stuff/haskell/fun.hs
08:52:11 <DevHC> <ddarius> DevHC: As an interesting note, the Goldbach conjecture is -equivalent- to it being provable in Peano arithmetic.
08:52:15 <ddarius> mmaurer: Sure it does.  It's xor.
08:52:15 <DevHC> ^ provable or not provable?
08:52:25 <mmaurer> ddarius: Agreed, but we already have xor.
08:52:35 <mmaurer> Why overload plus to point at that?
08:52:40 * esap wrote some code that encodes basic logic: http://www.kotiposti.net/epulkkin/CoFunctor.txt http://www.kotiposti.net/epulkkin/Prop.txt
08:52:46 <hpc> mauke: that's cool
08:52:50 <mauke> actually, we don't have xor. we have to use (/=) instead
08:52:52 <ddarius> mmaurer: Actually we don't have xor, we have (/=).
08:53:06 <mauke> GET OUT OF MY HEAD CHARLES
08:53:13 * Twey chuckles.
08:53:19 <mmaurer> OK. If we wanted xor separately we could just name it that way though. I don't see the benefit in actually turning it into a field.
08:53:24 <ddarius> esap: Haven't seen you for a while.
08:53:46 <esap> I've not been here for long time
08:53:54 <hpc> @let xor = (/=)
08:53:55 <lambdabot>  Defined.
08:54:04 <hpc> > True `xor` False
08:54:05 <lambdabot>   Ambiguous occurrence `xor'
08:54:05 <lambdabot>  It could refer to either `L.xor', defined at <l...
08:54:08 <mauke> @undefine
08:54:13 <hpc> > True `xor` False
08:54:14 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
08:54:14 <lambdabot>    arising from a use of `Da...
08:54:21 <hpc> wow, that's annoying
08:54:45 <n00p> lol
08:54:59 <n00p> Haskell programmers annoyed at Haskell programming. I'm in!
08:55:35 <n00p> Is this book any good? http://book.realworldhaskell.org/read/
08:55:40 <xarch> yeah
08:55:44 <hpc> very good
08:55:50 <hpc> i personally prefer lyah
08:55:56 <xarch> I prefer, though, lyah on some points
08:55:58 <n00p> I read it. It makes a few aweful assumptions about C... but in terms of Haskell?
08:56:01 <hpc> but that's neither here nor there
08:56:04 <xarch> like monads and applicative functors
08:56:08 <n00p> Well, read parts of it.
08:56:24 <hpc> lyah has top notch coverage of typeclasses
08:56:43 * hpc is curious what BONUS will do for Category and Arrow
08:56:45 <DevHC> someone port the documentation to rwh
08:57:06 <DevHC> (for people having seizures from childish pictures)
08:57:11 <xarch> hpc: he's going to talk about that?
08:57:17 <mauke> but the pictures are the best part!
08:57:20 <xarch> yes!
08:58:32 <n00p> hpc, xarch: Is lyah a free online book, too?
08:58:38 <xarch> yes
08:58:39 <mauke> preflex: ? lyah
08:58:39 <preflex>  http://learnyouahaskell.com/
08:58:45 <n00p> Sweet.
08:58:58 <n00p> Thanks. I'll have many good wet dreams learning to program in Haskell.
09:03:44 <hpc> well, on that note...
09:16:18 <kniu> @djinn
09:16:18 <lambdabot> Cannot parse command
09:17:55 <siracusa> @djinn (a -> b) -> (a,c)  -> b
09:17:56 <lambdabot> f a (b, _) = a b
09:18:48 <Ke> @help djinn
09:18:49 <lambdabot> djinn <type>.
09:18:49 <lambdabot> Generates Haskell code from a type.
09:18:49 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
09:19:48 <kniu> @djinn [(a, b)] -> ([a], [b])
09:19:48 <lambdabot> Error: Undefined type []
09:23:04 <deech> Hi all, I am doing a Gtk2hs for the first time and I keep running into situation where I have to use IORef to hold state. I'm doing my best to keep things as purely functional as possible but callbacks (onClicked ..) are making this hard. Any advice?
09:23:40 <deech> s/doing a Gtk2hs/ writing a Gtk2hs application/
09:24:00 <kniu> btw
09:24:12 <kniu> why isn't main :: [String] -> IO Int
09:24:13 <kniu> ?
09:24:34 <deech> kniu: As in C++?
09:24:46 <kniu> as in C, C++ and Java
09:25:25 <hygge> kniu: good question
09:25:32 <kniu> and as expected by POSIX execvp()
09:25:33 <deech> kniu : In Java the return type is void. But why does returning an integer make sense? 
09:25:33 <esap> I think Java main doesn't return Int...
09:25:45 <kniu> well, still
09:25:59 <kniu> why not main :: [String] -> IO () then?
09:26:15 <ceii_> accessing command-line arguments gives somewhat more flexibility
09:26:26 <ceii_> + with getArgs
09:26:43 <kniu> ceii_, how so?
09:26:52 <ceii_> this allows all your IO code to read cmdargs without them being passed explicitly
09:27:07 <kniu> oh
09:27:11 <ceii_> though the common use case is to parse them at the top-level of the program
09:27:12 <kniu> yeah, that's a good reason.
09:27:22 <ceii_> I can imagine somtimes you'd want to do something else
09:27:23 <deech> kniu : I've wondered about that. My best guess is that Haskell expects that command line args should be lazily evaluated and passing in a list of them violates that somehow.
09:27:59 <Saizan> it doesn't make much sense to talk about lazyness of command line args
09:28:03 <ceii_> as for the exit code, "exithWith code" allows you to terminate execution from anywhere in your program
09:28:05 <kniu> main :: [String] -> [(String, String)] -> IO Int
09:28:08 <Saizan> when you start a process those are already there
09:28:08 <ddarius> main = getArgs >>= main'
09:28:15 <kniu> might as well include environments too.
09:28:37 <deech> Saizan: I was thinking that if some are not used, they not read.
09:30:39 <deech> Ok, I just looked at ThreadScope's GTK2HS code and its silly with IORefs. If it's good enough for them it's good enough for me.
09:31:07 <Saizan> there isn't much else you can do
09:31:13 <ceii_> deech: since GTK has an imperative callback model there's no way around it
09:31:37 <Saizan> at best you can wrap them in something like StateVar
09:31:51 <deech> Saizan, ceii_ : Makes my code look fugly. 
09:32:14 <ceii_> at the extreme you can use a wrapper library such as grapefruit
09:32:47 <ceii_> never tried it, but since nobody does that I guess it's not close to feature complete
09:32:51 <deech> ceii_: I looked at grapefruit, I'm a little concerned about it immaturity. 
09:34:51 <kniu> @google foldl'
09:34:57 <lambdabot> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
09:34:58 <lambdabot> Title: Fold (higher-order function) - Wikipedia, the free encyclopedia
09:34:58 <kniu> @hoogle foldl'
09:34:59 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
09:34:59 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
09:34:59 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
09:35:33 <deech> Another style question, since GTK is OO the GTK2HS bindings have a lot of (treeViewGetSelection ...) style functions. In the OO world this is much more elegantly expressed as treeView.getSelection(...). Since I'm also working an FFI to some OO'ish C code, it this the best way of binding functions?
09:36:26 <monochrom> yes
09:36:33 <monadic_kid> "much more" is a bit an exaggeration
09:38:51 <geheimdienst> uh, couldn't you call it getSelection? you could then "import qualified TreeView as TV" and do TV.getSelection ...
09:38:54 <monochrom> also I am not sure whether you find fault in the name "treeViewGetSelection" or you find fault in the general translation from "o.f(x)" to "f o x"
09:40:02 <geheimdienst> monochrom: i thought he meant that the haskell name is much longer than the gtk name
09:40:17 <monochrom> following popular convention of "meaningful identifiers" (which I scorn), you can't possibly complain about a longer, more meaningful name.
09:40:51 <confound> crazy like an f o x
09:41:20 <geheimdienst> long /= meaningful ...
09:41:28 <monochrom> I know.
09:42:02 <Eduard_Munteanu> Why not think of them as capabilities and have various typeclasses such as Selectable? getSelection :: (Selectable t) => ...
09:42:16 <monochrom> gtk2hs sets up such typeclasses
09:42:27 <deech> monochrom: I'm not so much concerned about the long name, but that if another widget, say a table came along there would be a (tableGetSelection ...). It would be nice if there was a (getSelection someWidget ...) that worked for compatible widgets. Currently typeclasses in Gtk2Hs are largely only used to cast objects.
09:42:45 <Eduard_Munteanu> AFAICT, gtk2hs already feels functional, yeah
09:43:26 <monochrom> treeViewGetSelection :: TreeViewClass self => self -> IO TreeSelection  there is your typeclass
09:44:02 <Eduard_Munteanu> Admittedly the typeclass there is TreeView-specific, so the name of the method has to be as well ;)
09:44:57 <monochrom> that is equivalent to saying "the Selectable typeclass is Selectable-specific"
09:45:14 <deech> monochrom: The TreeViewClass only support casting objects to TreeView.
09:45:43 <Eduard_Munteanu> Selectable, in my view, would work on multiple kinds of objects. treeViewGetSelection seems to work on treeView's only.
09:45:53 <DevHC> @djinn ()
09:45:54 <lambdabot> f = ()
09:45:59 <DevHC> @djinn IO ()
09:45:59 <lambdabot> Error: Undefined type IO
09:46:25 <Eduard_Munteanu> It's more like a straight translation from C/C++.
09:46:36 <Eduard_Munteanu> (actually C given the context of Gtk)
09:47:07 <geheimdienst> deech: i don't know gtk2hs, but your point seems valid. a HasSelection typeclass for tables, treeviews, etc. would feel more haskellish. a TreeViewClass typeclass feels more like boilerplate
09:47:16 <b0fh_ua> Hi there! I ghci when doing ByteString.writeFile nothing really happens, how to force it to actually write a file?
09:47:32 <b0fh_ua> with bang?
09:47:37 <Eduard_Munteanu> b0fh_ua: you have to close the file ;)
09:47:38 <mauke> this surprises me
09:47:44 <hpc> :t BS.writeFile
09:47:45 <lambdabot> FilePath -> BSC.ByteString -> IO ()
09:47:53 <mauke> Eduard_Munteanu: what
09:47:57 <raeez> What is the current recommended route to graphing tree structures in Haskell? I'd preferably like to generate .png's, but will settle for other fortmats.
09:48:06 <monochrom> firstly, since you folks have explicitly given up on complaining about names, I don't see why calling it "TreeViewClass" is different from calling it "Selectable".
09:48:10 <hpc> raeez: graphvis?
09:48:11 <Eduard_Munteanu> Well if your program ends prematurely you may end up with an empty file.
09:48:24 <mauke> Eduard_Munteanu: what
09:48:40 <Eduard_Munteanu> And yeah you kinda need to close the handle.
09:48:44 <mauke> Eduard_Munteanu: what
09:48:47 <Eduard_Munteanu> :)
09:48:48 <raeez> I'm taking a look at graphviz right now; mostly curious if there was anything else
09:49:01 <Eduard_Munteanu> mauke: this has happened to me before
09:49:07 <mauke> Eduard_Munteanu: unlikely
09:49:34 <monochrom> secondly, gtk2hs has chosen to not let you add more instances to "TreeViewClass". this is a bit unfortunate, but considering that allowing you to add instances is actually pretty hard currently, I think we have to bear with it. However, when you design your lib, you can certainly choose to open up your typeclasses.
09:50:57 <Eduard_Munteanu> Oh, and yeah, ghci.
09:51:25 <Eduard_Munteanu> Just try closing the handle and quit ghci.
09:51:51 <monochrom> look at WidgetClass to see that single-instance classes is the exception, not the norm, in gtk2hs
09:52:04 --- mode: ChanServ set +o mauke
09:52:04 --- mode: mauke set +q $a:Eduard_Munteanu
09:52:18 <copumpkin> o.O
09:52:31 <geheimdienst> mauke: what are you doing?
09:52:41 <monochrom> widgetGrabFocus :: WidgetClass self => self -> IO ()
09:52:45 <Guest31020> exit
09:52:45 <b0fh_ua> Eduard_Munteanu: sorry?
09:52:46 <Guest31020> quit
09:52:54 --- mode: mauke set -o mauke
09:53:03 <mauke> making Eduard_Munteanu stop talking
09:53:03 <b0fh_ua> how to close file it I don't have reference to descriptor?
09:53:14 <mauke> b0fh_ua: you can safely ignore that
09:53:30 <mauke> b0fh_ua: I just tried it in ghci and it worked
09:53:34 <monochrom> there are almost a hundred instances of WidgetClass. they all can use widgetGrabFocus.
09:53:38 <b0fh_ua> weird
09:53:40 <mauke> b0fh_ua: what's the exact line you used?
09:54:09 <monochrom> writeFile closes itself. I have a program that relies on it twice a day. actually I use appendFile.
09:54:45 <monochrom> they don't do lazy or delayed I/O.
09:55:03 <geheimdienst> mauke: i don't see what Eduard_Munteanu did to justify muting
09:55:11 * djahandarie agrees
09:55:14 <copumpkin> someone was wrong on the internet
09:55:30 <b0fh_ua> well, probably I have something missing here
09:55:35 <deech> monochrom: I see that now. I guess the goal was to give a complete binding and let us write our DSL's on top. On the upside it makes it very easy to map GTK documentation to functions in Gtk2Hs
09:55:35 <mauke> he ignored me and kept giving nonsensical advice
09:56:13 <b0fh_ua> mauke: ( S.writeFile "dump" . printRemainder . parse (many parsecLogParser) ) `fmap` S.readFile "chat512.dbb"
09:56:24 <DevHC> @djinn (forall a. a) -> b
09:56:24 <lambdabot> -- f cannot be realized.
09:56:25 <b0fh_ua> printRemainder :: Result [SkypeEntry] -> S.ByteString
09:56:30 <DevHC> lambdabot: lies
09:56:31 <b0fh_ua> should work still
09:56:34 <mauke> b0fh_ua: what's the type of that?
09:56:53 <b0fh_ua> :: IO (IO ())
09:56:55 <b0fh_ua> hmmm
09:57:03 <mauke> the problem is fmap
09:57:05 * copumpkin hands b0fh_ua join
09:57:08 <mauke> you want =<<
09:57:13 <djahandarie> mauke, and he's also a channel regular who gives good advice regularly. I'm sure he wasn't trying to troll or anything, so he may have just been misinformed or actually have hit a weird bug before. Certainly not worth a mute.
09:57:30 <b0fh_ua> yup
09:57:32 <b0fh_ua> thanks )
09:57:40 <geheimdienst> mauke, you weren't very specific in your questions. you just said "what" and "what", to which he replied, and the you only said "unlikely" to him
09:57:53 <geheimdienst> i think you're out of line. please undo the muting.
09:58:08 <mauke> djahandarie: dude, "you need to close the handle" makes zero sense if THERE IS NO HANDLE
09:58:31 <mauke> I said "what" to get any kind of reaction or explanation
09:58:40 <geheimdienst> which you did get.
09:59:08 <mauke> not really
09:59:09 <deech> copumpkin: I've been meaning to ask. I understand how "join" works but not it's spirit. What is the use case for a function that removes one monadic layer? 
09:59:40 <djahandarie> > join [[1,2,3],[4,5,6]]
09:59:40 <lambdabot>   [1,2,3,4,5,6]
09:59:41 <mauke> <lambdabot> FilePath -> BSC.ByteString -> IO ()  <Eduard_Munteanu> And yeah you kinda need to close the handle.
09:59:44 <DevHC> mauke: i don't see how u see him as a troll
09:59:48 <mauke> DevHC: I don't
09:59:58 <geheimdienst> djahandarie: i agree, if someone has a misunderstanding about what the question is, then point that out to him ("no, we're not using handles"). don't just mute him
10:00:14 <geheimdienst> mauke: ^^
10:00:19 --- mode: ChanServ set +o mauke
10:00:20 --- mode: mauke set -q $a:Eduard_Munteanu
10:00:30 <geheimdienst> thanks mauke
10:00:34 <deech> djahandarie: Hah, thanks!
10:00:35 <mauke> ok, maybe I overreacted
10:00:44 <monochrom> my join use case is: join (atomically ((readTChan c1 >> return (putStrLn "x")) `orElse` (readTChan c2 >> return (writeFile "f" "y")))))
10:01:09 --- mode: mauke set -o mauke
10:01:17 <monochrom> although, I must say, that is about the only use case I have used :)
10:01:19 <mauke> (it was temporary anyway and the problem has been solved)
10:01:52 <DevHC> we can have "() => a" in a type signature. (1) what do u expect it to mean, and (2) what does it mean?
10:02:32 <mauke> we can?
10:02:36 <mauke> > 42 :: () => Int
10:02:38 <lambdabot>   42
10:02:47 <mauke> DevHC: it means the same as 'a'
10:02:54 <mauke> () is an empty list of class constraints
10:03:10 <DevHC> i actually expected it to work like forall a.
10:03:28 <DevHC> and ghci does give me an error about requiring RankNTypes
10:03:39 <Eduard_Munteanu> There is a 'forall a' implied.
10:03:49 <mauke> no errors in my ghci
10:03:55 <monochrom> ghci doesn't give me or lambdabot an error
10:04:05 <DevHC> i'm talking about a case where u use () => in an inner scope
10:04:23 <monochrom> you need to say that earlier
10:04:33 <monochrom> paste fully, paste early, paste often
10:04:34 <DevHC> i did
10:05:34 <DevHC> > let { f :: (() => a) -> b ; f = const (error "bla") } in f 1
10:05:34 <lambdabot>   *Exception: bla
10:06:03 <monochrom> > "inner" `isInfixOf` "we can have \"() => a\" in a type signature. (1) what do u expect it to mean, and (2) what does it mean?"
10:06:04 <lambdabot>   False
10:06:36 <DevHC> > (take 2 "inner") `isInfixOf` "we can have \"() => a\" in a type signature. (1) what do u expect it to mean, and (2) what does it mean?"
10:06:37 <lambdabot>   True
10:08:21 <monochrom> so every time you just say "in" it means "inner scope"?
10:09:11 <DevHC> not necessarily, but it also includes that case
10:10:08 <DevHC> had i meant only "() => a" as opposed to also others like "(() => a) -> b", i would have said: we can have "() => a" *as* a type signature...
10:10:30 <monochrom> you can verify that "my'undefined :: () => a" at the top level works. and by my book it still counts as "I have ()=>a in a type signature", namely in the type signature of my'undefined.
10:12:06 <DevHC> ok, so that would also be a valid interpretation
10:12:39 <azaq23> IIRC every type statement of the t :: T (forall t. (Contraints of t) => t) means that you have a universally quantified variable in T, which is polymorph until you get it out of the type and declare it to be something special. Sort of like the opposite of an existential type, where you declare a type to be something distinct and *then* put it into the type
10:12:47 <azaq23> > let t :: [forall t. Num t => t]; t = [10, 2] in ((t !! 0) :: Double, (t !! 1) :: Int)
10:12:48 <lambdabot>   (10.0,2)
10:14:24 <DevHC> HAX
10:14:32 <Eduard_Munteanu> Yes, his ended up rank-2 though.
10:15:05 <Eduard_Munteanu> Since it was equivalent to   forall b. (forall a. a) -> b
10:16:32 <copumpkin> :t (***)
10:16:33 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:17:58 <ezyang> Are Wadler's free theorems and list deforestation related? 
10:18:38 <Eduard_Munteanu> @free map
10:18:38 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:18:42 <djahandarie> Has lambdabot always put that kind signature there? I've never noticed, lol
10:19:02 <Eduard_Munteanu> Grr.
10:19:24 <djahandarie> ezyang, I'm not sure, but Mu-recursive types and list deforestation are
10:19:26 <monochrom> yes, she has always done so
10:19:33 <Eduard_Munteanu> I thought about that, but I don't remember if I've been mixing them up in my mind or not.
10:20:25 <ezyang> Hmm. The reason why I ask is that I was rereading Wadler's paper and he made an interesting statement that the free theorems usually only hold in general when the functions are stict. Whereas strictness is considered annoying in the case of deforestation. 
10:20:43 <Eduard_Munteanu> For map, the deforestation law should look like  map f . map g = map (f . g)
10:20:56 <djahandarie> edwardk said something like if you build your type with Mu, you will get free foldr/build fusion without any rewrite rules. If you build it with Nu you get destroy/unfoldr fusion
10:21:09 <azaq23> Eduard_Munteanu: So nesting of forall statements in type signatures == number of nestings defined the rank of the type?
10:21:32 <ezyang> Hmm. I wonder if I believe that. 
10:21:53 <monochrom> "(() => a) -> b" is invalid type in haskell 98 and haskell 2010. but somehow ghc allows it and calls it "a->b"
10:22:09 <DevHC> ind33d
10:22:10 <monochrom> hugs doesn't allow it
10:22:17 <Eduard_Munteanu> azaq23: more or less.
10:23:19 <djahandarie> Stream fusion on the other hand seems pretty impossible to me due to the Skip constructor
10:23:58 <Eduard_Munteanu> azaq23: some expressions defining types can be reduced to a lower rank, even if they look nested as you say
10:24:15 <Eduard_Munteanu> There was some "contravariant position" something blabber I don't remember right now :)
10:24:57 <djahandarie> Also, I think augment only works on structures that don't branch, because if they do it would be impossible to fuse tail concatenation.
10:26:04 <monochrom> > putStrLn `fmap` []
10:26:05 <lambdabot>   []
10:26:09 * djahandarie is unsure if he's just talking to himself here or not
10:26:14 <monochrom> @type putStrLn `fmap` []
10:26:15 <lambdabot> [IO ()]
10:26:22 <monochrom> @type putStrLn `fmap` getLine
10:26:23 <lambdabot> IO (IO ())
10:26:49 <DevHC> lol
10:45:29 <wagle> @hoogle append
10:45:29 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
10:45:29 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
10:45:29 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
10:45:45 <wagle> @hoogle concat
10:45:46 <lambdabot> Prelude concat :: [[a]] -> [a]
10:45:46 <lambdabot> Data.ByteString concat :: [ByteString] -> ByteString
10:45:46 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
10:46:51 <DevHC> monochrom: if u report that "() =>" thing (generating a ticket or whatever), can u give me a link?
10:50:04 <mauke> please use 'you' instead of 'u'
10:50:46 <Zao> gently caress u :D
10:51:26 <mauke> Zao: you're not even here
10:51:29 <adnap> how is the time lib supposed to work?  it doesn't seem like it's very simple to get things like: second, minute, hour, day, month, year
10:52:02 --- mode: ChanServ set +o mauke
10:52:02 --- mode: mauke set -q $a:Eduard_Munteanu
10:52:30 <mauke> ... I should probably fix that script
10:52:52 --- mode: mauke set -o mauke
10:53:02 <DevHC> mauke: you is not 1337 :)
10:53:34 <adnap> i tried looking on the wiki, and found this page, where it says that the maintainers hope to collect examples of how to use the time lib in the future: http://www.haskell.org/haskellwiki/Libraries_and_tools/Time_library
10:53:41 <azaq23> adnap: getClockTime >>= toCalendarTime gives you a record of type CalendarTime, which has all the common accessors
10:53:41 <geheimdienst> mauke: butt hao wuld dat jive wif ma plan to talk liek lolcats?
10:54:26 <mauke> "lolcats" are a terrible concept anyway
10:54:52 <DevHC> mauke: please use capitalized and punctuated sentences
10:55:03 <Zao> I prefer cats without captions.
10:55:27 <mauke> DevHC: why?
10:55:31 <chrisdone> Caturday without the funny.
10:55:54 <adnap> azaq23: i think that's deprecated
10:57:27 <DevHC> mauke: it was a rethorical statement, i thought u would have realized that if u dislike "incorrect" (or should i say, nonstandard) forms of english like "u", u should also dislike non-capitalized or non-punctuated sentences
10:57:41 <mauke> how does that follow?
10:57:44 <DevHC> and "u" has nothing to do with lolcats
10:57:49 <mauke> also, you misspelled "rhetorical"
10:57:59 <Zao> DevHC: It's not a "form" of english. It's brain damage.
10:58:05 <DevHC> lolcattery is "i can haz eats cheeez"
10:58:18 <mauke> capitalization and punctuation serve to separate a chunk of text into sentences
10:58:33 <mauke> irc does this "framing" for me
10:58:53 <Zao> mauke: Except for intersentence punctuation like commas and questionmarks.
10:58:54 <monochrom> the only problem with "u" is that you could also have a variable or function called "u"
10:59:00 <mauke> Zao: right
10:59:13 <Zao> monochrom: You're missing how it makes the talker look uneducated and generally not giving a hoot.
10:59:21 <systemfault> Oh noes, grammar nazis on #Haskell
10:59:28 <Zao> I'm much more likely to offer aid to someone that takes care in expressing themselves.
10:59:31 <chrisdone> In MY #haskell?
10:59:44 <mauke> how is 'u' a grammar thing?
10:59:47 <DevHC> unambiguous extensions to the english standard r acceptable if irc framing is
11:00:13 <monochrom> and "r" too
11:00:14 <Zao> At least 'y' doesn't have widespread adoption.
11:00:27 <Zao> Hint, it means both 'yes' and 'why'.
11:00:28 <mauke> DevHC: not to me
11:00:39 <monochrom> u r a function call?
11:00:49 <DevHC> lol
11:00:52 <monochrom> ("u r" a function call?)
11:01:02 <mauke> ru/18 qt π?
11:01:06 <chrisdone> Zao: It's a shame because it's not used otherwise.
11:01:07 <Zao> I don't mind people who use 'u' unknowingly, but people who insist of using it are proper trolls.
11:01:11 <monochrom> > let { u=id; r=5 } in u r
11:01:12 <lambdabot>   5
11:01:14 <Zao> chrisdone: Unless you're spanish.
11:01:27 * DevHC trolls Zao
11:01:44 <chrisdone> Zao: Uh, uh huh.
11:02:02 <geheimdienst> zao, calm down, saying "u" is no more trolling than leaving than typing all-lowercase, imho
11:02:05 <chrisdone> Or French, or Italian, etc..
11:02:37 <mauke> did I mention that I don't like people telling others to "calm down"?
11:02:48 <Zao> geheimdienst: I'd continue to argue if I didn't have a pipe with horrible latency and if this wasn't non-blah.
11:03:02 <Zao> And yes, I dislike that too.
11:03:46 <monochrom> I do not mind "u" "r" when they are unambiguous. however I do not trust any writer's self-deceiving judgement of disambiguity. of course you believe your own writing is clear.
11:04:52 <DevHC> >let { are = id ; you = Nothing } in are you
11:04:56 <DevHC> > let { are = id ; you = Nothing } in are you
11:04:56 <lambdabot>   Nothing
11:05:33 <copumpkin> o.O
11:05:59 <chrisdone> Deep.
11:06:14 <Maxdamantus> monochrom: you mean unambiguity?
11:06:19 <chrisdone> copumpkin: \o\
11:06:23 <copumpkin> :)
11:06:56 <monochrom> actually, "u" doesn't make me feel the writer is uneducated. it makes me feel the writer hasn't learned typing or is typing on a cell phone
11:07:30 <DevHC> what about non-capitalized sentences?
11:07:58 <chrisdone> Honestly, does it matter to you?
11:08:01 <DevHC> lemme guess, it makes u feel that the writer may have a broken shift key?
11:08:06 <copumpkin> okay
11:08:10 <copumpkin> enough of this
11:08:13 <copumpkin> :P
11:09:15 <DevHC> chrisdone: it does, we want to accept "u" as an official abbreviation of "you" into the new english standard, just how "i" was made an official abbreviation of "eye" centuries ago :)
11:10:26 <DevHC> [ok i pulled that "i = eye" thing out of my ass, but don't u wonder why don't we have a longer form in place of "i"?]
11:10:42 <kniu> is there some sort of maybeHead function?
11:10:54 <monochrom> yes, it's short for "our royal person"
11:10:56 <chrisdone> Meh, English evolves without regard to consistency, logic or standards. End.
11:10:59 <chrisdone> kniu: listToMaybe
11:11:11 <chrisdone> > listToMaybe []
11:11:12 <lambdabot>   Nothing
11:11:13 <chrisdone> > listToMaybe ['a']
11:11:14 <lambdabot>   Just 'a'
11:11:25 <azaq23> > let maybeHead = fmap head in fmap $ Just [10, 20] -- kniu as in this?
11:11:26 <lambdabot>   Couldn't match expected type `a -> b'
11:11:27 <lambdabot>         against inferred type `Data.M...
11:11:50 <geheimdienst> > listToMaybe [42, 37]
11:11:50 <lambdabot>   Just 42
11:12:01 <geheimdienst> nice, thanks chrisdone
11:12:07 <azaq23> > let maybeHead = fmap head in maybeHead $ Just [10, 20]
11:12:09 <lambdabot>   Just 10
11:12:31 <azaq23> but use listToMaybe.
11:12:45 <Zenon1> Can someone tell me how to close the program/process when I close a window in HOpenGL/GLUT, please? all examples I find only support close on keypress and don't implement the "closeCallback" event (when using X to close the window, I presume) and they use Control.OldException.
11:13:02 <monochrom> eww
11:14:19 <Zenon1> so it's basically 2 questions: 1. What is the correct way to close a window and handle closeCallback with Control.Exception and 2. If I have to use Control.OldException (and just live with the warnings), how do you implement closeCallback correctly? 
11:14:38 <azaq23> * or maybeToList, according to what you want. maybeHead can mean both in my view, though maybeToList seems more likely.
11:19:40 <chrisdone> :t maybe mempty
11:19:41 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> Maybe a1 -> a
11:19:57 <chrisdone> :t maybe mempty (mappend mempty)
11:19:58 <lambdabot> forall a. (Monoid a) => Maybe a -> a
11:20:18 <chrisdone> > maybe mempty (mappend mempty) $ Just 'a' :: [Char]
11:20:20 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:20:20 <lambdabot>         against inferred ty...
11:20:20 <monochrom> Zenon1: it seems you should use leaveMainLoop
11:20:34 <chrisdone> Ah, no.
11:21:02 <monochrom> there is also actionOnWindowClose for convenience. look into Graphics.UI.GLUT.Begin
11:25:13 <Zenon1> freeglut only :(
11:26:06 <Zenon1> should I use freeglut? the tutorials I'm using are for regular glut
11:26:57 <sm> a nice post seen off-planet: http://codeflow.wordpress.com/2011/02/20/the-reasons-i-dont-write-all-my-code-in-haskell/
11:27:08 <augustss> :t fromMaybe mempty
11:27:10 <lambdabot> forall a. (Monoid a) => Maybe a -> a
11:27:33 <monochrom> "freeglut" is the C lib behind the haskell binding. if you are on linux, you are likely on freeglut.
11:27:42 <Zenon1> windows
11:27:48 <monochrom> ah, problem
11:28:37 <Zenon1> :)
11:28:51 <monochrom> well, if Graphics.UI.GLUT.Begin doesn't offer anything else, I feel that there is none.
11:30:05 <monochrom> but even if you throw an exception, you can do so in a window-close callback so it is not just "press q to quit"
11:32:28 <araz> hi
11:32:54 <araz> can someone give me a comparison between Haskell Parametric types and C++ templates
11:33:19 <araz> are there things that can be done in C++ but not in Haskell?
11:33:39 <hpc> araz: segfaults, for one :P
11:33:49 <araz> ?
11:33:52 <araz> what do you mean?
11:34:01 <hpc> there's nothing C++ can do that haskell can't
11:34:10 <araz> template meta programming?
11:34:19 <hpc> for one, you can make a C binding to C++ code, then make a haskell binding for that
11:34:19 <araz> can Haskell do that?
11:34:26 <Zenon1> uhm when I just add the exit function to the closeCallback ( 'closeCallback $= Just exitLoop')  the program just exits right away without creating a window...
11:34:27 <wagle> if I have a finite type X, can i get a list of the values of X?  
11:34:29 <hpc> there's Template Haskell
11:34:38 <Zenon1> i guess I'll switch to freegluts :) 
11:34:44 <hpc> wagle: [minBound..maxBound]
11:34:44 <mauke> wagle: [minBound .. maxBound], maybe
11:34:55 <hpc> needs to derive Enum though
11:34:56 <wagle> woo
11:35:18 <Zenon1> thanks for the help :)
11:35:23 <araz> is template haskell's expressiveness with those of C++?
11:35:27 <wagle> i thought so, but my brain wasnt making the leap
11:35:30 <wagle> thanks
11:35:31 <araz> can you do meta-programming with it?
11:35:39 <araz> does it allow for generic programming?
11:36:06 <hpc> araz: are you asking if you can do similar things or if you can do exactly what C++ does?
11:36:10 <araz> I get a feeling that most C++ programmers don't realize how powerful C++ templates are
11:36:12 <hpc> one of those is desirable
11:36:47 <monochrom> most math students don't realize the power of math either
11:36:47 <araz> template meta-programming is the ability to perform compile time computation 
11:36:48 <mauke> Template Haskell is more like lisp macros
11:36:51 <araz> can Haskell do that?
11:37:09 <mauke> araz: Template Haskell lets you run Haskell at compile time
11:37:15 <mauke> (and generate code)
11:37:31 <araz> okay
11:37:34 <sipa> @faq can haskell do that?
11:37:35 <lambdabot> The answer is: Yes! Haskell can do that.
11:37:39 <hpc> hahaha
11:38:05 <araz> how about type level reasoning?
11:38:22 <araz> you can create typelists in C++ 
11:38:27 <mauke> hah
11:38:34 <araz> and do various things with them at compile time
11:38:54 <mauke> C++ templates are a functional programming language with severe limitations and a terrible syntax
11:39:04 <monochrom> may I ask why are you asking so many survey-type questions?
11:39:10 <araz> syntax is irrelevant 
11:39:14 <mauke> syntax matters
11:39:15 <sm> Zenon1: I just looked at some things using GLUT, on mac, and closeCallback seems to be set up for you. They all seem to exit cleanly on command-Q
11:39:20 <Philippa> araz: we know C++ well enough. We factor out the capabilities differently
11:39:21 <jmcarthur> syntax matters... a little
11:39:24 <mauke> otherwise I'd be using lisp
11:39:27 <araz> haskell syntax is not that good either 
11:39:30 <monochrom> in fact reporter-type questions, like you're handing in a 100-word news article tomorrow
11:39:31 <araz> syntax is subjective
11:39:38 <mauke> syntax is objective
11:39:39 <Philippa> we have Template Haskell for doing compile-time computation and code generation, but we don't use it for parametric polymorphism because that'd be /stupid/ for example
11:39:56 <hpc> monochrom: it seems more like he is trying to insult haskell, judging from his preference for "can haskell do that?"
11:40:01 <hpc> reminds me of bill o'reilly
11:40:02 <Philippa> (we get all these free theorems that C++ can't have, for example)
11:40:07 <jmcarthur> lol
11:40:08 <araz> hpc: nice shot 
11:40:25 <araz> why is there so much propaganda around Haskell?
11:40:33 <monochrom> well I certainly have my suspicion too
11:40:34 <Philippa> because we're better than you, duh
11:40:40 <araz> no you are not
11:40:41 <mauke> why is there so much propaganda around Lisp?
11:40:49 <jmcarthur> actually, it looks like "there's nothing C++ can do that haskell can't" probably got araz asking these questions
11:40:49 <monochrom> much propaganda where?
11:40:56 <Philippa> really, haskell has a lot of properties that languages in the C or Lisp families /can't/ have
11:40:57 <hpc> who is spain? why is hitler? ho ho berry berry!
11:40:58 * wagle wants enumerate = [minBound .. maxBound] and curses monomorphism..  8)
11:41:01 <araz> there are tonz
11:41:09 <mauke> wagle: add a type signature
11:41:10 <Philippa> and haskell's the most prominent language in its ballpark of the design space
11:41:14 <araz> high performance computing while providing high abstraction is one of them 
11:41:19 <pozic> There are only a few people spreading partial truths about Haskell. 
11:41:19 <Philippa> so it gets to benefit from the network effects
11:41:22 <DevHC> lol @ high performance
11:41:29 <jmcarthur> lol?
11:41:32 <araz> Philippa: rubbish
11:41:36 <Zenon1> sm: does closing the window using the windowbar buttons work?
11:41:52 <pozic> Most people are fairly reasonable for some reasonable value of reasonable. 
11:41:52 <Philippa> araz: okay, clearly you don't know the first thing about programming language semantics or you'd have some idea what these properties might be
11:41:52 <jmcarthur> haskell with ghc seems pretty high performance to me
11:42:06 <wagle> wanted to do "(enumerate :: [Foo], enumerate :: [ Baz])"
11:42:15 <jmcarthur> to some extent you do have to think about operational semantics to achieve that, though
11:42:20 <sm> I knew you'd ask that - no, the close button is always greyed out here
11:42:28 <Philippa> for example, C derivatives can't have referential transparency without fundamentally compromising many other things about themselves - and so they don't
11:42:45 <pozic> jmcarthur: the functional programming aspect of Haskell is _slow_. 
11:42:45 <Philippa> C++'s parametric types are neither parametric nor actually types
11:42:53 <pozic> jmcarthur: there is nothing high performance about that.
11:42:58 <jmcarthur> pozic: what do you mean?
11:43:07 <Philippa> lisp can't do anything static types can do other than by greenspunning in static types
11:43:07 <araz> Philippa: like what do I need to know? I know quite a bit about formal semantics, have read a few books
11:43:11 <pozic> jmcarthur: idiomatic simplistic benchmarks are 300 times faster than obvious C++ code. 
11:43:12 <jmcarthur> "the functional programming aspect of haskell"
11:43:18 <pozic> jmcarthur: er slower
11:43:22 <jmcarthur> pozic: i wouldn't say that
11:43:24 <araz> jmcarthur: your standards should be pretty low
11:43:27 <Philippa> araz: then you should know haskell does indeed have properties that C++ doesn't
11:43:31 <jmcarthur> pozic: unless you are saying that choosing stupid data structures is idiomatic
11:43:33 <Veinor> partial truths, like truths that aren't always defined :)
11:43:37 <araz> Philippa: such as?
11:43:40 <DevHC> oh the empty loop benchmark is epicly in favour of haskell :)
11:43:49 <Philippa> araz: I just listed some
11:43:53 <pozic> jmcarthur: I discussed this with someone from Galois. 
11:44:12 <pozic> jmcarthur: you are free to have your own opinion, but we actually wrote all the programs.
11:44:30 <araz> Philippa: okay, saw it now. Why is referential transparency desirable? why does it matter?
11:44:48 <araz> Philipa: it certainly isn't a virtue in itself, is it?
11:44:56 <n00p> What makes Haskell "high performance"?
11:45:02 <burp> @pl \(a,b) -> b-a
11:45:03 <lambdabot> uncurry subtract
11:45:04 <n00p> araz...
11:45:04 <mauke> who said anything about "desirable"?
11:45:05 <jmcarthur> pozic: i find that a lot of what people call idiomatic is using data structures and libraries that make no sense for the problem at hand
11:45:06 <monochrom> a good compiler
11:45:15 <Philippa> araz: it greatly simplifies reasoning about code because you don't have side-conditions on various code transformations. Which means that refactoring in haskell is basically /just/ doing algebra with no need to pay attention to underlying semantics at all
11:45:16 <jmcarthur> pozic: aside perhaps from a few characters shorter code
11:45:19 <n00p> monochrom: Thanks, but I really meant to ask araz...
11:45:21 <araz> Philipa
11:45:21 <pozic> jmcarthur: there was nothing wrong with the datastructures.
11:45:34 <Philippa> that both aids compiler optimisation and aids development whether you have tools to hand or not
11:45:35 <pozic> jmcarthur: asymptotically at least not.
11:45:35 <Zenon1> sm: ah well, I'll try out the actionOnWindowClose function and see if that helps :) but thanks for the tip
11:45:49 <jmcarthur> arguably, asymptotically is not enough
11:45:50 <hpc> araz: http://forums.xkcd.com/viewtopic.php?f=11&t=14661&start=2600#p2511645
11:45:52 <araz> Philippa: pure propaganda. What kind of reasoning has the haskell community been doing about their code?
11:45:53 <pozic> jmcarthur: in the end we were manipulating raw ptr buffers and it was still slowe.r
11:45:55 <monochrom> not sure araz means "c++ is high performance" or "haskell is high performance". be careful of sentences quoted out of context.
11:46:01 <pozic> jmcarthur: by about 1.5 times.
11:46:03 <jmcarthur> pozic: this is why i qualified that you do have to pay some attention to operational semantics
11:46:12 <jmcarthur> 1.5 times slower is not much slower
11:46:14 <jmcarthur> IMO
11:46:20 <pozic> jmcarthur: that means that if you are in a domain where every millisecond counts, it simply is slow.
11:46:23 <jmcarthur> but yes, manipulating raw Ptr buffers sucks
11:46:23 <Philippa> araz: "reasoning" is a fancy term for "thinking about". It's present - or rather, the checks it eliminates are absent - in /everything we do with our code/
11:46:25 <napping> araz: heard of "refactoring"?
11:46:58 <jmcarthur> pozic: sure, and i wouldn't advocate haskell is such an environment, but i wouldn't say that's the only case that "high performance" is an applicable term
11:47:03 <pozic> jmcarthur: it means you are going to lose in the financial world to all your competitors if you depend on x86 hardware. 
11:47:23 <pozic> jmcarthur: using Haskell to write e.g. Atom and then compile that to custom hardware designs is a good idea, though.
11:47:30 <Philippa> araz: do you know what aliasing is and why it can cause subtle problems? We know we don't have to worry about that (unless we embed a setting where we do, of course)
11:47:35 <jmcarthur> pozic: that is of course until you toss in some par annotations and throw some hardware at it (i'm half joking)
11:47:36 <araz> Philippa: okay, so what you are saying means, that the motivation for Haskell is more psychological, because it makes reasoning easier. 
11:47:45 <pozic> jmcarthur: that is also completely false.
11:47:49 <jmcarthur> pozic: yeah, haskell at the least makes decent code gen dsls
11:47:56 <pozic> jmcarthur: OpenMP is faster than the stuff in GHC.
11:48:02 <Philippa> araz: "psychological" is the wrong word. It's a fact of the logic at heart, how our wetware exploits it's irrelevant so long as it can
11:48:10 <augustss> pozic: a lot of the computing in the financial world is not performance critical
11:48:18 <araz> Philippa: can you point me to a study that shows that is the case? i.e., referntially transparent functional code in a large enough project is easier to reason about for programmers?
11:48:20 <Philippa> araz: the logic involved requires fewer steps and thus fewer opportunities to fuck up
11:48:23 <pozic> jmcarthur: but you are free to come up with examples where you blast C++ out of the water. 
11:48:37 <mauke> araz: why "a large enough project"? this applies to every line of code
11:48:38 <jmcarthur> pozic: i think you are exaggerating my claims
11:48:53 <araz> Philippa: yes, stop being condescending by saying, do you know this or that, I know all of it 
11:48:56 <DevHC> has anyone mentioned rapid code development as a pro?
11:48:56 <Philippa> araz: I've not seen someone do the psychological study. But as I keep saying, it's not about the psychology - it's a fundamental fact of the logic, there are less details involved
11:48:57 <napping> pozic: I think one of the things that avoids Haskell having more unreasonable people is nearby languages like Agda and ML and so on, which are obviously better in various individual dimensions
11:48:58 <chrisdone> araz: You can do it yourself it you like. Just try some non trivial function, then imagine it ten times bigger.
11:49:02 <jmcarthur> araz: "all of it?"
11:49:18 <araz> Philippa: but your arguments are not valid. it's like saying that, do you know what car accidents are? we avoid them by not driving 
11:49:25 <Philippa> araz: sorry, you're in no position to make demands like that. I'm not condescending, I'm checking your background because /nobody/ knows everything and I need to know how you're going to understand
11:49:57 <Philippa> araz: well yes, I /do/ avoid them by not driving. And I /am/ safer on the bus or train in the UK.
11:50:24 <Philippa> (and you're the one being asked because you're the one asking to understand things)
11:50:51 <araz> Philippa: assume that I know them, I will ask if I don't understand
11:51:09 <Philippa> araz: sorry, but given your behaviour I don't trust you to. You keep accusing people of propaganda unfoundedly, for example
11:51:15 <napping> araz: I mean, do you find refactoring a useful thing to do?
11:51:34 <napping> also, what languages do you think are usefully designed?
11:52:03 <araz> Philippa: it's not accusation. 
11:52:12 <Philippa> araz: then it's statement, which is even more arrogant
11:52:56 <pozic> jmcarthur: High-performance code is code of which one can say that it is is really pushing the machine to its limits (after inspection). It is the kind of code which should run on grid computing systems, etc. The kind of code which has been tweaked over 30 years. 
11:53:07 <araz> Philippa: propaganda means strident advocacy without evidence. Show me evidence that functional programming is superior for producing better, safer or faster code, whichever you want 
11:53:18 <jmcarthur> pozic: okay, then we were simply operating under different definitions
11:53:23 <napping> araz: what things do you want from code?
11:53:30 <Philippa> and seeing as /you're/ claiming that there's no way these things are an advantage, I'm going to shift the burden of proof to you if you want to continue in that manner. Please show that code written in a referentially transparent manner can't be easier to reason about than code without RT
11:53:32 <jmcarthur> pozic: and given how you just defined it, i agree with your statements
11:53:42 <pozic> jmcarthur: if you are going to say Haskell is generally faster than Python, then I agree with you. 
11:54:02 <araz> Philipa: I want it to perform what I do without wasting my cpu cycles, yet be generic and maintainable. 
11:54:05 <pozic> araz: Haskell obviously brings some safety improvements. 
11:54:05 <Philippa> hint: that's equivalent to saying "please show that either the complexity in the language with effects is irreducible or that RT forces you to adopt a worse approach". The latter is demonstrably false: RT languages can encode languages with side-effects
11:54:08 <napping> pozic: Few things meet that definition of "high performance"
11:54:18 <jmcarthur> pozic: that is the only sense that i meant it. taking it a bit further, i meant it in the sense of "in the same order of magnitude as C when not written stupidly"
11:54:25 <araz> C++ has proven capable of this. Evidence is Chrome, is firefox, is zilioons of working software
11:54:32 <araz> where is evidence for haskell ?
11:54:35 <araz> GHC?
11:54:35 <chrisdone> araz: let z = f x + g x in (z,i x) -- you don't need to check what f, g or i do, the value of x never changes, guaranteed. You can also swap the order.
11:54:40 <ddarius> Philippa: In a worse manner (arguably.)
11:54:45 <pozic> araz: all those crash all the time.
11:54:46 <napping> pozic: I think jmcarthur is claiming Haskell is fast enough for anything that doesn't have to push the machine to the absolute limit
11:54:53 <chrisdone> Oh, okay. You're not interested in technical arguments. Nevermind.
11:54:56 <pozic> araz: I don't think those applications show how good C++ is. 
11:55:09 <Philippa> GHC's probably our biggest publically-visible project, but if your only accepted form of evidence is big enough projects then nobody who thinks like you will ever undertake them
11:55:19 <Philippa> and I agree with those criticising the quality of those projects
11:55:31 <augustss> araz: there might be evidence that I can't show you
11:55:31 <jmcarthur> those applications show that patient people can create things under any circumstances ;)
11:55:37 <Philippa> C++ is better than many languages predating it and got networks, sure
11:55:42 <napping> pozic: and the sort of careful-machine level thing you are thinking of involves enough goveling of assembly and such even in C, that I think you could spot the Haskell programmers a few Ptrs
11:55:50 <araz> well, why doesn't the haskell community use the wonderful language they have to write something competitive, say a web framework?
11:55:56 <araz> that surely put Ruby on the map
11:55:59 <jmcarthur> araz: there are several of those
11:56:13 <burp> snap, happstack, yesod,…
11:56:15 <pozic> araz: how do migrations work in Ruby? 
11:56:16 <araz> if Haskell wants adoption the road is not through writing factorial functions in 200 ways
11:56:19 <hpc> blaze-html
11:56:25 <jmcarthur> araz: hackage.haskell.org
11:56:25 <araz> yeah, they all suck
11:56:27 <araz> badly
11:56:28 <pozic> araz: pick your poison on the Ruby side. 
11:56:32 <Philippa> araz: okay, you're now telling us how to run our community rather than asking for explanation. Skip it
11:56:33 <araz> I have tried Yesod and Happstack
11:56:36 <napping> araz: So, "if it's good, why isn't it popular"?
11:56:38 <jmcarthur> araz: can you even give a reason why?
11:56:39 <burp> um, it's not true they all suck
11:56:45 <confound> why is the troll being fed?
11:56:45 <araz> I may as well code in assembly than those cryptic framework 
11:56:47 <Philippa> we're not /actually/ trying to sell to you, but we'll help you understand if that's what you want
11:56:51 <pozic> araz: I am asking about Ruby. Do they solve this problem in a satisfying way?
11:56:57 <jmcarthur> araz: nothing about them is cryptic
11:57:09 <pozic> araz: here is your chance to show your superior knowledge in Ruby.
11:57:11 <araz> in a realtively satisfactory way, 
11:57:19 <Philippa> jmcarthur: plenty about plenty of haskell code is cryptic /if you don't know haskell and its ecosystem well enough/. But hey, that's life
11:57:27 <jmcarthur> Philippa: right
11:57:34 <araz> so is C++
11:57:35 <burp> araz: how much haskell experience do you have?
11:57:39 <pozic> araz: yes?
11:57:43 <copumpkin> [03:29:12 PM] <araz> if Haskell wants adoption the road is not through writing factorial functions in 200 ways
11:57:43 <pozic> araz: we are waiting. 
11:57:45 <augustss> araz: you've come with the mind-set that you don't want to be convinced.  trying to do so is pointless.
11:57:49 <araz> so then don't brag about Haskell's supriority of syntax over C++ 
11:57:50 <jmcarthur> which is more a demonstration of araz's ignorance than of any intrinsic property of haskell or haskell projects
11:57:55 <araz> haskell can look a lot uglier 
11:57:55 --- mode: ChanServ set +o augustss
11:57:57 <ion> pozic: Database migrations?
11:58:04 <Philippa> araz: you're not crashing into haskell's syntax, you're crashing into semantics
11:58:10 <jmcarthur> araz: you mean syntax is automatically worse if you don't understand it just by looking at it?
11:58:11 <pozic> ion: in-memory webapp migrations. 
11:58:11 <chrisdone> augustss: Thanks in advance.
11:58:16 <wagle> how grotesque is this:
11:58:16 <araz> I am not ignorant
11:58:22 <araz> I know haskell pretty well 
11:58:29 <araz> I have spent a year on it 
11:58:30 <Philippa> how well do you think "pretty well" is?
11:58:30 <pozic> ion: that is systems which have zero down time. 
11:58:35 <wagle> nm
11:58:35 <araz> written some relatively big programs
11:58:40 <araz> and know the advanced concepts
11:58:41 <copumpkin> araz: I wouldn't have said I knew haskell pretty well after a year
11:58:42 <araz> monads, 
11:58:46 <araz> arrows
11:58:46 <mauke> haha
11:58:49 <hpc> lol
11:58:49 <araz> yada yada 
11:58:49 <copumpkin> I guess I'm just dumb
11:58:49 <Philippa> moands aren't an advanced concept
11:58:51 <pozic> araz: you obviously do not know Ruby. 
11:58:52 <araz> so I am not ignorant 
11:58:53 <hpc> "i know monads!"
11:58:53 <augustss> araz: just a year?
11:58:54 <Philippa> *monads
11:58:57 <Philippa> not in this language
11:59:00 <araz> however
11:59:06 <Philippa> monads are about one level above foundational around here
11:59:07 <geheimdienst> araz: what specifically are your frustrations?
11:59:10 <mauke> araz: please don't use the enter key as punctuation
11:59:10 <jmcarthur> araz: then prove you're not. so far you seem to be making the kinds of subjective arguments that somebody in the first week of a programming languages course having haskell shoved down their throat would say
11:59:16 <araz> I dont feel I get anything back for the time invested in learning 
11:59:18 <araz> haskell
11:59:27 <Philippa> that's about on the level of "I know what a virtual base class is!" in C++
11:59:40 <pozic> araz: if you cannot show that you can talk intelligently about what is great about Ruby frameworks, then you have no place talking about Haskell, something about which you know even less. 
11:59:46 <araz> Philippa: which says a lot about the copious amount of useless abstractions that you have accumulated 
11:59:46 <copumpkin> araz: it completely changed my outlook on computer science and math, if you want to go with subjective anecdotes
11:59:50 <burp> araz: that's ok, everyone has different opinions
11:59:52 <napping> pozic: that sort of high performance is not attainable
11:59:57 <Philippa> araz: they accumulate because we have uses for them
12:00:03 <Philippa> whether /you/ do isn't our problem
12:00:11 <pozic> napping: where? In Haskell? 
12:00:15 <napping> pozic: Do you think it's fast enough in the sense that you could rewrite just about any consumer application and have it fast enough without too much trouble?
12:00:18 <araz> compumpkin: well, what if had a pretty solid outlook before learning haskell?
12:00:23 <ion> pozic: Ah. Not in a very pretty way. Start the new version, tell the processes of the old version to die whenever idle. Something like Unicorn makes new requests go to the new version. Nothing as pretty as in Erlang. (Haskell doesn’t really have the Erlangy goodness either, which is a shame.)
12:00:28 <pozic> napping: yes.
12:00:32 <burp> I feel dirty whenever I have to read or write c/c++/fortran
12:00:35 <napping> pozic: yeah, you won't get great numeric performance out of Haskell
12:00:38 <copumpkin> araz: self-judged?
12:00:39 <araz> Philippa: what kind of uses?
12:00:42 <pozic> napping: or perhaps not for Photoshop.
12:00:44 <napping> pozic: well, not to disparage the dph work and stuff
12:00:45 <araz> Philippa: give me an example
12:00:56 <djahandarie> ion, people have made Erlang-type stuff for Haskell
12:01:03 <jmcarthur> araz: i find it hard to believe that somebody who knows so much wouldn't understand the benefits of purity and reasoning about code
12:01:06 <copumpkin> oh, the "give me your abstraction and I'll show you how to do the same thing without the abstraction" approach to argument
12:01:11 <pozic> napping: unless you write everything against Ptr buffers. 
12:01:15 <ion> djahandarie: Yes, but it’s not quite there yet.
12:01:15 <copumpkin> Philippa: brace yourself
12:01:17 <djahandarie> ion, depends on what part of the 'Erlangy goodness' you are looking for. :)
12:01:19 <djahandarie> Yeah
12:01:20 <copumpkin> Philippa: he's gonna show you how to not use it
12:01:25 <Philippa> araz: the parsing library I'm working on's an applicative for example and it being applicative is a major aid to figuring out how to do the transformations involved in it
12:01:25 <araz> copumpkin: judged by employers, and at school exams
12:01:29 <napping> pozic: well, writing core image processing stuff with buffers like that might not be too bad
12:01:36 <wagle> enumerate :: (Enum a, Bounded a) => [a]
12:01:36 <wagle> enumerate = [minBound .. maxBound]
12:01:47 <Philippa> obviously you could ignore the applicativeness - but I know things about applicatives as a group already, and thus it saves me thinking time
12:01:52 <napping> pozic: these days you might want to farm it out to a GPU anyway
12:02:00 <pozic> napping: yeah, the higher level transformations could probably be written in a more "pure" way.
12:02:01 <araz> Philippa: what kind of parsing algorithm does it enable, that you couldn't do without using applicative functors?
12:02:08 <Philippa> in turn, a critical part of the structure is that the applicative part is /finite/ and I've implemented many separately
12:02:19 <copumpkin> araz: of course it doesn't do that, and by asking that question you're showing that you're missing the point
12:02:21 <Philippa> araz: go jump into the nearest turing tarpit
12:02:23 <scree> wow, copumpkin is psychic
12:02:34 <araz> Philippa: and you redecule me for saying monad? FYI applicative is a simple abstraction than monad (categorically speaking)
12:02:39 <Philippa> of course it doesn't enable a new algorithm. It makes it easier for me to know I've got it right
12:02:41 <copumpkin> scree: it was pretty obvious :)
12:02:43 <araz> *simper*
12:02:53 <Philippa> it is, but it's one that was spotted recently - I'd been coding haskell for years before then
12:03:10 <napping> pozic: Ok, seems like you are not claiming anything too diferent from what I believe about performance
12:03:10 <Philippa> (it's also not particularly 'simpler', they're of a similar level of complexity with different tradeoffs)
12:03:12 <copumpkin> araz: maybe you're just too arrogant about your level of knowledge then :)
12:03:13 <monochrom> it was not obvious to me
12:03:34 <FUZxxl> Small question: ghci reports some error when I do ":m +Control.Monad.State.Strict" What to do?
12:03:35 <jmcarthur> "I do not understand X, therefore X is useless."
12:03:37 <copumpkin> araz: for what it's worth, I was already in grad school with a decent undergrad degree in CS when I started haskell, and was still blown away
12:03:41 <napping> pozic: but what kind of code loses 300x? Is that against highly-tuned linear algebra? You can easily get 30x loss even with fairly decent C against good vectoized code
12:03:53 <mauke> FUZxxl: what error?
12:03:56 <monochrom> FUZxxl: what error?
12:04:09 <monochrom> paste fully, paste early, paste often
12:04:12 <araz> Philippa: hence my comment about the value of haskell being of pure psychology, nothing related to computer science.
12:04:34 <napping> araz: you don't consider proving properties of programming languages computer science?
12:04:38 <FUZxxl> I get a  Ambiguous module name `Control.Monad.State.Strict':
12:04:38 <FUZxxl>       it was found in multiple packages: mtl-2.0.1.0 monads-fd-0.1.0.4
12:04:39 <Philippa> however, I'm also exploiting deep embedding to make reasoning simpler while I get started even though I'll refactor later for performance. I'm keeping careful track of where structures are finite and where they're not because /fundamental algebraic properties/ of my library rest on it...
12:04:44 <araz> copumpkin: yeah maybe, but I can be arrogant and right. my arrogance is irrelevant 
12:04:55 <Philippa> oh, and I'm also implementing a batch of stuff on a grammar class from a 2005 paper, but that's the easy bit
12:05:00 <jmcarthur> araz: your arrogance makes you a troll
12:05:03 <napping> araz: is that not the canonical thing that is computer science rather than applied programming?
12:05:03 <FUZxxl> \privmsg lamdabot foo
12:05:03 <copumpkin> araz: not when it hinders you from seeing productive new viewpoints on existing concepts
12:05:06 <copumpkin> okay
12:05:14 <copumpkin> how about we stop feeding this troll?
12:05:15 <confound> can we be done with this now?
12:05:24 <Philippa> araz: so the process of reasoning about code is irrelevant to computer science? You have some strange ideas
12:05:25 <pozic> napping: you can try the experiment yourself. Read a 5GB file, and create a non-sorted histogram of bytes. 
12:05:36 <ddarius> copumpkin: That could have been done a while ago.
12:05:42 <Zenon1> allright, closing windows works like a charm in freeglut
12:05:46 * ddarius will need to continue hitting copumpkin with the apathy stick.
12:05:48 <djahandarie> ddarius, we don't want to starve the troll either though
12:05:54 --- mode: ChanServ set +o ddarius
12:05:54 <ddarius> djahandarie: Why not?
12:05:57 <pozic> napping: You can first write it in C++ to get rid of the "second program is easier"-argument.
12:06:09 <araz> napping: you can prove properties on other programming languages too, and in fact they are not necessarily harder than pure functional languages, any decent book on formal semantics (e.g., Winskel) does that
12:06:15 <pozic> napping: then you can write the Haskell version using whatever idioms you want. 
12:06:24 <djahandarie> ddarius, because starving people is bad!
12:06:32 <ddarius> djahandarie: I disagree.
12:06:38 <pozic> napping: If you get it under 50 times slower the first time, you must have done something special.
12:06:42 --- mode: ddarius set -o ddarius
12:07:00 <araz> Philippa: process of reasoning about code is not irrelevant to CS. the claim that FP in general, and haskell in particular, has a better grip on that is unsubstantiated. 
12:07:03 <Philippa> araz: what notion of "hardness" are you using here? We're not claiming it's impossible to reason about effectful languages, after all
12:07:05 <monochrom> FUZxxl: I think mtl-2.0.1.0 replaces monads-fd-0.1.0.4. you may like to "ghc-pkg hide monads-fd-0.1.0.4" or even get rid of it.
12:07:15 <ddarius> copumpkin: I've never been op of a channel and have zero desire to start, and I don't have all the fancy macros.
12:07:30 <copumpkin> boo
12:07:31 <napping> pozic: Hmm, interesting case
12:07:36 <araz> Philippa: I was going to ask what notion of easiness you are using when you say you can reason easier about your applicative parser?
12:07:54 <Eduard_Munteanu> Grr, a lot of +o lightsabers turning on tonight (yes, that's what I picture when I see +o/-o)
12:07:54 <pozic> napping: you should record all your versions. 
12:07:57 <napping> pozic: Does 5GB mean "larger than ram" or just "noticeably big"?
12:08:06 <napping> my laptop doesn't have so much space free
12:08:10 <pozic> napping: larger than RAM.
12:08:34 <napping> wait, that makes the Haskell relatively slower?
12:08:39 <wagle> if I want a var to range from 0..7, can I have a type, or do i have to range from P0 to P7 in an enum?
12:08:44 <pozic> napping: no.
12:08:48 <chrisdone> Eduard_Munteanu: I see it like Gandalf when he gets bigger and imposing to shout at Bilbo.
12:08:50 <FUZxxl> monochrom: Is there a temporary solution? I don't want to mess with ghc-pkg and maybe break my environment.
12:08:50 <napping> I'd think time waiting for disk would cover other performance difference
12:08:57 <Philippa> araz: while I'm not doing it fully formally? I end up with the equivalent of shorter proofs and I don't need to invent as many constructs because normally I only need a few abstract properties of the types I'm working with
12:09:00 <Eduard_Munteanu> Heh.
12:09:07 <Philippa> (for a particularly fun example, see "free theorems")
12:09:13 <pozic> napping: I am counting CPU time. 
12:09:16 <napping> araz: what approaches to proving things about assembly programs do you like?
12:09:20 <Philippa> (have fun extracting something equivalent to those in C++!)
12:09:38 <araz> Philippa: you don't need to invent as many constructs? didn't you just contradict your assertion about the need for all those fancy abstractions?
12:09:45 <ddarius> Philippa: They don't exist in C++ (or rather they cease being "free.")
12:10:07 <copumpkin> proving things is usually possible, but it's already damn hard for functional languages
12:10:07 <mauke> araz, Philippa: want to continue this in #haskell-overflow?
12:10:07 * wagle wonders if someone has started a Free Theorem Foundation yet
12:10:34 <araz> Philippa: I have read Wadler's paper, it's not particularly interesting, the type of theorems he derives for free are either useless or obvious for all practical purposes 
12:10:36 <ddarius> wagle: The legal landscape is such that that hasn't yet been necessary.
12:10:39 <Philippa> ddarius: no shit
12:10:49 <pozic> napping: you need at most 1MB of memory for this task. 
12:10:55 <Philippa> -> -overflow
12:10:55 <wagle> ddarius: heh
12:11:13 <araz> napping: proving things about assembly is not as hard as you think, model checking people have been doing this for confined processeros for years
12:11:22 <napping> so, you like the model checking
12:11:30 <napping> It's not impossible
12:11:34 <napping> Hardly
12:11:35 <Eduard_Munteanu> We could complete GPL... free as in either beer, speech or theorems.
12:11:47 <copumpkin> free monoids are where it's at
12:11:48 <Philippa> araz: take this to #haskell-overflow
12:11:54 * copumpkin 's code is free as in monoids
12:12:00 <pozic> araz: Which higher-order imperative proof assistants do you know?
12:12:03 <Philippa> same to everyone else, but araz is the critical individual on that front
12:12:09 <napping> Rather, I've been quite impressed on recent progress at connecting things about threads and stuff down to the machine level
12:12:12 <Eduard_Munteanu> copumpkin: meaning, trivial? :)
12:12:12 <monochrom> FUZxxl: "hide" is pretty mild. oh, actually, if you what an even more temporary solution, :set -hide-package monads-fd
12:12:15 <napping> but yes, let's away
12:12:21 <copumpkin> Eduard_Munteanu: yes, but also elegant :)
12:12:30 <Philippa> pozic, napping et al: you guys to
12:12:32 <Philippa> *too
12:12:58 <ddarius> copumpkin: Your code is an element of a free monoid, that's true.
12:13:02 <copumpkin> #haskell-trollcanteen 
12:13:13 * hackagebot data-type 0.0.1 - Basic type wrangling types and classes  http://hackage.haskell.org/package/data-type-0.0.1 (IainAlexander)
12:13:15 * hackagebot function-combine 0.0.1 - Combining functions  http://hackage.haskell.org/package/function-combine-0.0.1 (IainAlexander)
12:13:33 <augustss> araz: i think you might be one of those people who don't understand the necessity of abstraction.  I've such people before, they are usually very clever.
12:13:57 <araz> dear, haskellers, either change your attitude, or stay irrelevant. Just take note that your attempts at getting attention in the industry have largely ignored. For good reasons
12:13:59 <Philippa> augustss: you too, 'mafraid :-)
12:14:05 --- mode: ChanServ set +o mauke
12:14:05 --- mode: mauke set +q *!*@gateway/web/freenode/ip.76.66.124.86
12:14:14 * hackagebot flexiwrap 0.0.1 - Flexible wrappers  http://hackage.haskell.org/package/flexiwrap-0.0.1 (IainAlexander)
12:14:15 <Philippa> araz: 'sokay, you're irrelevant to us too
12:14:22 <wagle> can i define a numeric type that ranges from 0..7?
12:14:23 <jmcarthur> that was definitely worth a +q
12:14:33 <augustss> araz: who says we want haskell to be relevant?
12:14:41 <Philippa> (industry'll start looking at us and our successors more seriously in a decade or so after F#'s percolated nicely)
12:14:49 <ddarius> Johnny von Neumann should be one of those people, but he created quite a few abstractions.
12:14:51 <pozic> I thought it was quite interesting. 
12:14:55 --- mode: mauke set -o mauke
12:15:21 <pozic> Then again, I do not agree with the policies for banning people here and my opinion has no value here. 
12:15:47 <ddarius> pozic: You can continue in #haskell-overflow.
12:15:57 <augustss> wagle: no, not in any sensible way.
12:16:06 <ddarius> pozic: Also, he wasn't banned.
12:16:15 <pozic> ddarius: I was already there before all the others and in case you didn't notice augustss continued. 
12:16:31 <wagle> augustss: i need iavor and mark then..  8)
12:16:44 <jmcarthur> our policies for banning people here are for the purpose of keeping this a high quality channel. disagreeing with somebody is fine, but arrogance and veiled insults are toxic and only invites more of the same
12:17:03 <Eduard_Munteanu> mauke is on a q-ing spree :P
12:17:17 <Eduard_Munteanu> (not saying it wasn't reasonable)
12:17:55 <augustss> wagle: you can make a newtype on top of Int and define all the arithmetic operations.
12:18:17 <napping> wagle: do you want a thing with eight elements?
12:18:41 <copumpkin> wagle: you can write Fin in "plain old" haskell, but it won't be particularly efficient or pleasant to work with
12:18:58 <copumpkin> Fin 8 is what you want
12:19:05 <napping> or indeed, data Bounded = Zero | One | Two | Three | ... | Eight
12:19:10 <napping> possibly palatable with TG
12:19:12 <napping> er, TH
12:19:18 <wagle> napping: in this case 8, but in others, its different
12:19:22 <Eduard_Munteanu> data EightSomething = One | Two | Three | Four | Five | Six | Seven | Eight deriving Enum   -- should do
12:19:30 <copumpkin> wagle: you can make Fin work that way
12:19:44 <wagle> right now i have data TPrio = P0 | P1 | ...
12:20:12 <wagle> but if i wanted 15000 values, I'd be up the creek
12:20:13 <copumpkin> data Z = Z; newtype S n = S n; data Fin n where Zero :: Fin (S n); Suc :: Fin n -> Fin (S n)
12:20:22 <augustss> wagle: what operations do you want on the type?
12:20:39 <wagle> copumpkin: haha
12:20:39 * ddarius should make an article on optimizing type level programs.
12:20:42 <aristid> ghc might get type-level naturals \o/
12:20:48 <ddarius> :k 1
12:20:50 <copumpkin> wagle: nothing wrong with that :)
12:20:51 <lambdabot> *
12:20:57 <aristid> ddarius: not that ;)
12:21:01 <Eduard_Munteanu> aristid: I'd really like some support for Peanos
12:21:11 <Eduard_Munteanu> Vec looks silly with all those definitions.
12:21:26 <aristid> Eduard_Munteanu: i think the proposed change uses Integer
12:21:27 <copumpkin> with an automatic solver for arbitrary peano arithmetic statements!
12:21:35 <copumpkin> yes!
12:21:42 <DevHC> mauke: u r a troll
12:21:43 <augustss> and the halting problem!
12:21:55 <wagle> augustss: Enum and Bounded right now..  wondered about more general Pascal enum like stuff
12:21:56 <djahandarie> It'd be nice to just have the same sort of thing Agda has, where you just use a pragma to tell the compiler to optimize your Nat type to something faster.
12:22:18 <copumpkin> wagle: you can write Enum and Bounded for Fin n, given n as any type-level natural
12:22:31 <pokoko222> any of you proofs guys :) has ever thought how cool would it be if you could draw proofs in UML or something? I mean sometimes you deduce and it gets messy you know, would be nice if you could draw it
12:22:38 <djahandarie> I don't think that's what Iavor was planning on, right?
12:22:40 <Eduard_Munteanu> Wait hold on, what do you mean by optimize?
12:22:45 <Eduard_Munteanu> This goes away at runtime.
12:22:48 <augustss> wagle: newtype TPrio = TPrio Int, and the make instance declarations
12:23:14 <ddarius> Eduard_Munteanu: The compiler still needs to be able to compile your program.
12:23:16 <augustss> wagle: and make TPrio abstract for the clients
12:23:35 <wagle> i was mostly wanting concise notation (0 vs P0)
12:23:52 <augustss> wagle: make it an instance of Num
12:24:01 <Eduard_Munteanu> pokoko222: I was kinda considering having something related: a way of viewing a graph of existing theorems, where edges are implications
12:24:03 <augustss> wagle: and then you can write 0
12:24:08 <Eduard_Munteanu> I wonder if something like that exists.
12:24:13 <monochrom> someone at the McGill University uses category theory to formalize (give semantics to) UML.
12:24:19 <wagle> augustss: ohhh..
12:24:26 * wagle has lightbulb moment
12:24:32 <monochrom> But UML is not designed as a proof language.
12:24:34 <djahandarie> monochrom, that sounds evil
12:24:39 <Eduard_Munteanu> i.e. a huge database of (semi-)formal proofs so you can visualize theorems in context.
12:24:55 <ddarius> Eduard_Munteanu: There are a few databases of formalized proofs.
12:25:23 <monochrom> It is not like you would like "wouldn't it be nice if x86 machine code could express proofs". wrong language.
12:25:42 <ddarius> monochrom: You just need the right logic.
12:25:58 <Eduard_Munteanu> ddarius: anything that gets you a graph like Foo's lemma -> Bar's theorem -> ... ?
12:26:02 <Eduard_Munteanu> That would be really interesting.
12:26:32 <pokoko222> heh yeah and so that you can move through the graph, expand, collapse blocks etc.
12:26:36 <Eduard_Munteanu> A picture of mathematics.
12:26:50 <pokoko222> in a way
12:26:55 <ddarius> Eduard_Munteanu: There is probably something like that, though those implications would need to be added, at best, semi-automatically, unless you also want to wade through a combinatorially large collection of other theorems.
12:27:20 <pokoko222> i mean people say use ada or coq for proofs, but even that is still worse then pencil and paper, or maybe i am worse at it
12:28:06 <Eduard_Munteanu> pokoko222: well it's bound to be more verbose.
12:28:10 <ddarius> pokoko222: Most pencil and paper proofs have (usually easily filled in) gaps.
12:28:28 <Eduard_Munteanu> That, and catering to the underlying theory of the proving system.
12:28:56 <FUZxxl> monochrom: thx
12:30:22 <pokoko222> ddarius by database of proofs you mean?
12:30:34 <pokoko222> i mean what can that thing do? :)
12:31:20 <Eduard_Munteanu> pokoko222: a collection of theorems and associated proofs.
12:32:13 <pokoko222> ah well isnt that same as wikipedia?
12:32:16 <ddarius> Mizar is an example of a system that's been around for a long time and has such a collection of proofsl.
12:32:30 <Eduard_Munteanu> Such that initial objects represent axioms, and the diagrams commute :P
12:33:53 <Eduard_Munteanu> \bf{Math} category
12:34:00 <roconnor> @free (:[])
12:34:01 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:35:20 <Eduard_Munteanu> BTW, is there anything like that?
12:35:41 <Eduard_Munteanu> I suppose it could be useful for formalizing some stuff in model theory.
12:37:48 <ddarius> Eduard_Munteanu: Implication is an ordering so you can have it be a preorder category.  The initial object will be false.  The axioms won't be initial.
12:37:54 <alex404> What's the easiest way to figure out the context in which an exception was thrown, e.g. vector index out of bounds?
12:39:39 <dschoepe> Whom do I have to contact to get my account on code.haskell.org reactivated (my ssh-key is no longer accepted since it went back up again)?
12:39:53 <Eduard_Munteanu> Hm, yeah.
12:41:41 <Heffalump> dschoepe: http://www.haskell.org/pipermail/haskell-cafe/2011-February/089352.html
12:42:23 <dschoepe> Heffalump: thanks
12:43:04 <Heffalump> np
12:44:01 <napping> pokoko222: proof assiants are nicer when you expect to change definitions a lot
12:44:30 <napping> If you can just rerun it to see if all the old bits still go through after you add an extra construct to the language or whatever
12:46:39 <pokoko222> i realized computer science is math, and what they teach us here is software engineering and not compute science ... so i enrolled now in a course on algebraic structures, in april i will probably take another, i am thinking between topology and category theory
12:47:24 <pokoko222> dunno which one, but category theory sounds nicer since that way i will get closer to type theory and haskell
12:51:24 <gienah> pokoko222: this is a book on type theory: http://www.cis.upenn.edu/~bcpierce/sf/
12:51:56 <mm_freak_> pokoko222: i think, CT is mostly applied to topology, so it's probably good to learn both
12:53:03 <gienah> pokoko222: the way that book on type theory works is you open the .v files in coq and do proofs, which is like having your own tutor in your computer
12:53:20 <ddarius> mm_freak_: Originally.  Now it has many, many different areas of application.
12:54:25 <mm_freak_> yeah, and my favorite application is haskell =)
12:54:28 <Eduard_Munteanu> How's bcpierce's book on CT? I've heard people say it doesn't live up to TAPL's renoun.
12:54:44 <mm_freak_> it's the first language i like, which has a real theoretical foundation
12:56:42 <pokoko222> gienah sweet thanks a lot will play with it tomorow :)
12:56:51 <ddarius> Eduard_Munteanu: I briefly skimmed it once, and my impression was that it wasn't particularly notable.
12:57:58 <Eduard_Munteanu> Awodey seems to require some serious effort though.
12:58:06 * Eduard_Munteanu should stop treating it as bedside reading :)
12:58:19 <Eduard_Munteanu> s/Awodey/Awodey's/
12:58:21 <gienah> Eduard_Munteanu: that is what I have heard, this book on CT looks great: http://crm.umontreal.ca/pub/Ventes/desc/PM023.html
12:59:06 <Eduard_Munteanu> Ah, IIRC you or someone else have been looking for that.
13:00:11 <gienah> its difficult to order, after 4 pretty please emails they offered to send it to me via international courier, after I sent a fax, its a soft cover book :-)
13:00:32 <ddarius> Eduard_Munteanu: Learning any mathematical subject is, eventually, going to require serious effort.
13:01:18 <Eduard_Munteanu> Yes, I know it's my fault, though I wish Awodey layed it out a bit differently.
13:02:06 * Eduard_Munteanu was hoping to go through it once, then start doing work based on it.
13:02:37 <Eduard_Munteanu> Like, something in connection with category-extras.
13:03:18 * Eduard_Munteanu goes watch a movie.
13:06:26 * hackagebot data-accessor 0.2.1.6 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.1.6 (HenningThielemann)
13:14:03 --- mode: ChanServ set +o mauke
13:14:03 --- mode: mauke set -q *!*@gateway/web/freenode/ip.76.66.124.86
13:14:34 <DevHC> now let's discuss why haskell sux?
13:14:53 --- mode: mauke set -o mauke
13:19:39 <wagle> in the interest of DontRepeatYourself, can you abstract an instance declaration to apply to more than one base type?
13:19:59 <Heffalump> not easily
13:21:14 <aavogt> use the template-haskell
13:21:29 <wagle> eg, instance Num TPrio, and instance Num TWhen, are the same except for occurrances of the typecast ::TPrio and ::TWhen
13:22:19 <Saizan> you could make TWhen a newtype of TPrio and derive Num,
13:22:32 <Saizan> having turned on GeneralisedNewtypeDeriving
13:22:41 <wagle> aavogt: i need an excuse to dive into  TH, but that seems overkill here
13:23:08 <TTimo> is there some easy way I can have putStrLn actions from concurrent actions (forkIO) be marshalled line by line? right now all the output is superposed at character level
13:23:15 <ddarius> You could write a function that captures the similarity and define your instances in terms of that.
13:23:45 <ddarius> TTimo: Instead of putStrLn'ing, write to a channel to a "print server."
13:23:45 <Saizan> TTimo: i've seen it work just by turning on LineBuffering
13:24:41 <aavogt> wagle: do you actually need the type signatures :: TPrio and  :: TWhen?
13:24:41 <Saizan> TTimo: but the more robust approach is to send all those String to a single thread that has the sole role of writing them 
13:24:50 <TTimo> ok
13:25:05 <Saizan> see Control.Concurrent.Chan for that
13:25:20 <TTimo> yup
13:25:33 <wagle> i have 4 ranged enum's that i'm casting to from Integer by making them instances of Num..  trying to be pedantic and define +, -, * using mod arithmetic
13:26:14 <b0fh_ua> Hello! I need some help with attoparsec - how can I "return" some consumed data back to the input?
13:26:14 <wagle> so, things like: 
13:26:20 <wagle>   x * y = toEnum $ (fromEnum x * fromEnum y) `mod` (fromEnum (maxBound::TPrio) + 1)
13:26:47 <b0fh_ua> For instance I created simple function which skips the input until some sequence of bytes is found, but after that I have to return this sequence back
13:27:13 <aavogt> @type let x * y = toEnum $  (fromEnum x * fromEnum y) `mod` (fromEnum (maxBound`asTypeOf`x) + 1) in (*)
13:27:16 <lambdabot> Int -> Int -> Int
13:27:30 <napping> wagle: actually, that sounds like a good way to get into TH
13:28:08 <napping> the code you are trying to generate is very simple, so you can focus on getting the TH stuff to work
13:28:21 <aavogt> @type let x * y = \m -> toEnum $  (fromEnum x * fromEnum y) `mod` (fromEnum (maxBound`asTypeOf`m) + 1) in (*)
13:28:22 <lambdabot>     Couldn't match expected type `a -> t' against inferred type `Int'
13:28:22 <lambdabot>     In the second argument of `mod', namely
13:28:22 <lambdabot>         `(fromEnum (maxBound `asTypeOf` m) + 1)'
13:28:58 <wagle> little did /me know this morning, when he started on this tiny project, that he was going to end up using TH
13:29:51 <hpc> wagle: time to start over! :P
13:30:10 <aavogt> @type let f x y = \m -> toEnum $  (fromEnum x * fromEnum y) `mod` (fromEnum (maxBound`asTypeOf`m) + 1) in (*)
13:30:10 <Heffalump> wagle: you can of course just write utility functions and call those
13:30:11 <lambdabot> forall a. (Num a) => a -> a -> a
13:30:16 <aavogt> @type let f x y = \m -> toEnum $  (fromEnum x * fromEnum y) `mod` (fromEnum (maxBound`asTypeOf`m) + 1) in f
13:30:17 <lambdabot> forall a a1 a2 a3. (Enum a2, Bounded a2, Enum a1, Enum a, Enum a3) => a -> a1 -> a2 -> a3
13:30:28 <Heffalump> so the instance declarations become member1 = member1Helper ; member2 = member2Helper, etc
13:31:09 <aavogt> > sin^2 + cos^3 $ 2
13:31:11 <lambdabot>   0.7547542546840407
13:31:34 <DevHC> WAT?
13:31:59 <DevHC> > (1+) + (*4) $ 5
13:32:00 <lambdabot>   26
13:32:17 <wagle> supposing I do manage to give all four textually identical instance bodies, is TH the only way to state the body once?
13:32:22 <DevHC> > 2 (sin + cos)
13:32:23 <lambdabot>   2
13:32:51 <napping> wagle: If they are close enough, you might have a generic version of the function you can use for each body
13:32:56 <aristid> :t 2 (sin + cos)
13:32:56 <lambdabot> forall t a. (Num ((a -> a) -> t), Floating a) => t
13:33:10 <DevHC> > 2 4
13:33:11 <lambdabot>   2
13:33:12 <wagle> hmm..  maybe i want to write my own deriving Num
13:33:19 <DevHC> > 2 4 3
13:33:23 <lambdabot>   mueval-core: Time limit exceeded
13:33:46 <wagle> can i write my own deriver?
13:33:48 <DevHC> > 1 2 3 4 5
13:33:49 <lambdabot>   1
13:33:49 <hpc> > (do {1; 2; 3; 4}) 5
13:33:50 <lambdabot>   4
13:33:51 <wagle> heh
13:34:09 <sshc> ...Why would lambdabot define functions as an instance of Num?
13:34:18 <hpc> sshc: it's from a vector package
13:34:21 <hpc> and it's fun
13:34:29 <DevHC> > 1 2 3
13:34:30 <lambdabot>   1
13:34:33 <DevHC> > 2 2 3
13:34:34 <lambdabot>   2
13:34:36 <hpc> being able to say sin^2 x is neat
13:34:38 <DevHC> > 2 4 3
13:34:39 <lambdabot>   2
13:34:50 <DevHC> ok why didn't that work in the first time?
13:34:52 <wagle> napping I have to write +,-,*, abs,signnum, negate, etc for each
13:35:10 <aavogt> wagle: you can also write the instance once in a TH quote, then write some function (using some generics library like syb ex.) which replaces the Waggle [d| instance Num Waggle where  .... (:: Waggle) ... |]
13:35:34 <wagle> s/gg/g/g
13:35:51 <wagle> 8)
13:36:24 <aavogt> but I think you need some library from hackage to provide the Data instances
13:36:36 <DevHC> [1,2,3]+[1,2,3]
13:36:38 <DevHC> > [1,2,3]+[1,2,3]
13:36:39 <lambdabot>   No instance for (GHC.Num.Num [t])
13:36:39 <lambdabot>    arising from a use of `e_1123123' at <...
13:36:56 <wagle> > 1 1
13:36:57 <lambdabot>   1
13:37:08 <wagle> > 2 2
13:37:08 <lambdabot>   2
13:37:12 <wagle> huh
13:37:19 <DevHC> > 1 undefined
13:37:20 <lambdabot>   1
13:37:36 <wagle> @type 1
13:37:37 <lambdabot> forall t. (Num t) => t
13:37:40 <sshc> > 2^2 + 4
13:37:41 <lambdabot>   8
13:37:43 <sshc> > 2^2 4
13:37:44 <lambdabot>   4
13:37:50 <burp> lol
13:38:29 <McManiaC> btw, is the ghc team still working on the new haskell platform? why does it take them so long?
13:38:33 <sshc> hpc: But interpreting a number as a constant function doesn't make sense
13:38:51 <burp> is this caleskell?
13:38:51 <McManiaC> website says jan 2011
13:38:57 <napping> McManiaC: the core GHC team doesn't make the haskell platform
13:39:07 <burp> @undefine
13:39:11 <burp> > 1 1
13:39:12 <lambdabot>   1
13:39:20 <McManiaC> whoever does it :)
13:39:42 <aavogt> > sin^2 + cos^2 $ x
13:39:44 <lambdabot>   sin x * sin x + cos x * cos x
13:39:57 <DevHC> > 3 * (putStrLn "a")
13:39:58 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.IO ()))
13:39:58 <lambdabot>    arising from the literal...
13:40:00 <DevHC> lol
13:40:04 <monochrom> lambdabot is full of dubious extensions. normally not equivalent to your ghci.
13:40:17 <hpc> > sin^2 + cos^2 <$> [1..10]
13:40:18 <lambdabot>   [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.999...
13:40:18 <burp> aavogt: this is cool
13:40:26 <hpc> > sin^2 + cos^2 <$> [1..10] :: [CReal]
13:40:27 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
13:40:30 <hpc> :D
13:40:42 <aavogt> > foldr f z [1..]
13:40:43 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
13:40:56 <hpc> > foldl f z [1..]
13:41:00 <lambdabot>   mueval-core: Time limit exceeded
13:41:18 <aavogt> > scanl f z [1..]
13:41:20 <lambdabot>   [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3,f (f (f (f z 1) 2) 3) 4,f (f (f (f (...
13:41:22 <augur> byorgey: :D
13:41:27 <augur> you have an enumerator! :D
13:41:52 <DevHC> > f 1
13:41:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:41:53 <lambdabot>    `SimpleReflect.FromExpr ...
13:42:05 <hpc> > f 1 :: Expr
13:42:05 <lambdabot>   f 1
13:42:18 <hpc> > text "oh hey, look at me!"
13:42:19 <lambdabot>   oh hey, look at me!
13:42:45 <hpc> :t text
13:42:46 <lambdabot> String -> Doc
13:43:45 <DevHC> > sin (0 :+ 1 :: CReal)
13:43:46 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
13:43:46 <lambdabot>         against infe...
13:44:01 <aristid> :t (:+)
13:44:01 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
13:44:20 <aristid> > sin (0 :+ 1 :: Complex CReal)
13:44:21 <lambdabot>   0.0 :+ 1.1752011936438014568823818505956008151557
13:45:10 <DevHC> > sin (0 :+ 3.141592653589 :: Complex Double)
13:45:11 <lambdabot>   0.0 :+ 11.548739357248552
13:45:26 <DevHC> > sin (0 :+ 2.718 :: Complex Double)
13:45:28 <lambdabot>   0.0 :+ 7.541992652552762
13:45:43 <aristid> > let (r:+i) = sin (0 :+ 1) in map (showCReal 100) [r,i]
13:45:44 <lambdabot>   ["0.0","1.17520119364380145688238185059560081515571798133409587022956541301...
13:45:53 <DevHC> anyone know a cute complex value which produces a cute complex value?
13:46:02 <burp> > sinh pi
13:46:04 <lambdabot>   11.548739357257748
13:46:24 <aristid> > sinh pi :: Complex CReal
13:46:25 <lambdabot>   11.5487393572577483779773343153884096844952 :+ 0.0
13:46:46 <DevHC> why CReal? isn't CReal from Foreign?
13:46:53 <DevHC> .C
13:46:56 <aristid> CReal has INFINITE PRECISION
13:47:00 <aristid> and no, it's pure haskell
13:47:01 <DevHC> :o
13:47:04 <ddarius> What type would "Real" be in C?
13:47:11 <DevHC> nvm :P
13:47:17 <aristid> i guess DevHC assumed it was double
13:47:46 <DevHC> sqrt 2 :: CReal
13:47:49 <DevHC> > sqrt 2 :: CReal
13:47:50 <lambdabot>   1.4142135623730950488016887242096980785697
13:48:04 <aristid> > showCReal 100 (sqrt 2)
13:48:05 <lambdabot>   "1.414213562373095048801688724209698078569671875376948073176679737990732478...
13:48:18 <kulakowski> McManiaC: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable says March 1. I don't know why the front page isn't updated.
13:48:33 <McManiaC> oh ty
13:48:39 <aristid> DevHC: i can make it have arbitrary precision, but lambdabot will cut it off anyways
13:48:54 <DevHC> > sum $ map (2^) [0..]
13:48:58 <lambdabot>   mueval-core: Time limit exceeded
13:49:08 <DevHC> ^ that value is -1 btw :P
13:49:33 <ddarius> copumpkin: This should look vaguely familiar to you: http://www.youtube.com/user/njwildberger#p/c/A9424409A8255A99/101/X5oSGy9w4EQ
13:50:30 <DevHC> > genericLength [1..1000] :: CReal
13:50:32 <lambdabot>   1000.0
13:50:35 <DevHC> > genericLength [1..1000000] :: CReal
13:50:36 <lambdabot>   *Exception: stack overflow
13:51:45 <DevHC> to me it appears that haskell sux at calculating the length of an infinite list using low memory
13:52:14 <DevHC> ie., garbage collecting the first few, no-longer-to-be-used elements of the list
13:52:49 <Twey> It never gets the elements of the list
13:52:56 <Twey> They are irrelevant
13:52:58 <DevHC> it does
13:53:05 <DevHC> it just doesn't evaluate them
13:53:24 <Twey> Nope
13:53:27 <ddarius> DevHC: Garbage collection is irrelevant.  It isn't the heap that is being exhausted.
13:53:36 <DevHC> orly
13:53:46 <Twey> It only evaluates to the (:) constructor
13:53:48 <DevHC> > length [1..1000000]
13:53:49 <lambdabot>   1000000
13:53:53 <DevHC> > length [1..1000000000]
13:53:57 <lambdabot>   mueval-core: Time limit exceeded
13:54:18 <ddarius> genericLength is defined as a foldl rather than a foldl'.
13:54:24 <DevHC> D:
13:54:51 <ddarius> Assuming it isn't a foldr (which is even worse for strict numeric types.)
13:54:58 <ddarius> @where report
13:54:59 <lambdabot> http://www.haskell.org/onlinereport/
13:55:20 <DevHC> @where chakravarty
13:55:20 <lambdabot> I know nothing about chakravarty.
13:55:24 <DevHC> shame on u
13:55:42 <ddarius> Actually, it's defined equivalently to a foldr in the Report.
13:55:42 <DevHC> > foldr (+1) 0 [1..1000000] :: CReal
13:55:44 <lambdabot>   No instance for (GHC.Enum.Enum
13:55:44 <lambdabot>                     (Data.Number.CReal.CReal...
13:55:46 <Heffalump> http://www.cse.unsw.edu.au/~chak/
13:55:56 <Heffalump> how do we tell lambdabot that?
13:56:07 <ddarius> @help @where+
13:56:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:56:20 <ddarius> @help where+
13:56:21 <lambdabot> where+ <key> <elem>. Define an association
13:56:36 <Heffalump> @where+ chakravarty http://www.cse.unsw.edu.au/~chak/
13:56:36 <lambdabot> It is forever etched in my memory.
13:56:44 * DevHC resists the urge to add a rickroll link
13:57:05 <DevHC> @help where-
13:57:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:57:30 <DevHC> @where ffi
13:57:30 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
13:57:35 <augur> DevHC: your fold doesnt work because the folding function isnt binary.
13:57:48 <DevHC> ?
13:58:01 <Saizan> also because CReal is not an instance of Enum
13:58:03 <augur> foldr expects a binary function but (+1) is unary
13:58:08 <augur> Saizan: that too :p
13:58:16 <DevHC> o
13:58:29 <augur> remember, folds are basically a way to insert a binary operation between the list elements
13:58:30 <DevHC> > foldr (+) 0 [1..1000000] :: CReal
13:58:34 <lambdabot>   mueval-core: Time limit exceeded
13:58:39 * hackagebot data-accessor 0.2.1.7 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.1.7 (HenningThielemann)
13:58:39 <DevHC> > foldr (+) 0 [1..10000] :: CReal
13:58:43 <lambdabot>   mueval-core: Time limit exceeded
13:58:47 <DevHC> > foldr (+) 0 [1..100] :: CReal
13:58:48 <lambdabot>   5050.0
13:58:49 <augur> [x,y,z,...] ==> x <+> (y <+> (z <+> ...))
13:58:53 <augur> for some <+>
13:59:21 <DevHC> > foldr (+) 0 (replicate 1000000 1) :: CReal
13:59:23 <lambdabot>   *Exception: stack overflow
13:59:34 <augur> seriously tho DevHC, what are you trying to do
13:59:41 * hackagebot data-accessor-transformers 0.2.1.3 - Use Accessor to access state in transformers State monad  http://hackage.haskell.org/package/data-accessor-transformers-0.2.1.3 (HenningThielemann)
13:59:43 * hackagebot data-accessor-monads-fd 0.2.0.3 - Use Accessor to access state in monads-fd State monad class  http://hackage.haskell.org/package/data-accessor-monads-fd-0.2.0.3 (HenningThielemann)
13:59:45 * hackagebot data-accessor-monads-tf 0.2.1.3 - Use Accessor to access state in monads-tf State monad type family  http://hackage.haskell.org/package/data-accessor-monads-tf-0.2.1.3 (HenningThielemann)
13:59:54 <DevHC> searching for taht stack overflow which shouldn't have been a stack overflow?
13:59:59 <napping> I don't think that will work for CReal even with foldl'
14:00:08 <napping> well, at least if you swapped in pi for 1
14:00:22 <DevHC> > foldr (+) 0 (replicate 1000000 0) :: CReal
14:00:24 <lambdabot>   *Exception: stack overflow
14:00:34 <DevHC> ok, why is that a stack overflow?
14:00:39 * hackagebot data-accessor-mtl 0.2.0.2 - Use Accessor to access state in mtl State monad class  http://hackage.haskell.org/package/data-accessor-mtl-0.2.0.2 (HenningThielemann)
14:00:41 * hackagebot data-accessor-template 0.2.1.7 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-template-0.2.1.7 (HenningThielemann)
14:00:46 <ddarius> copumpkin: I meant http://www.youtube.com/watch?v=iid9wiHo07I actually.
14:00:54 <augur> probably because you're right folding, DevHC
14:01:01 <DevHC> and?
14:01:06 <augur> > foldl (+) 0 (replicate 1000000 0) :: CReal
14:01:07 <lambdabot>   *Exception: stack overflow
14:01:11 <augur> guess not
14:01:15 <blackdog> foldl', dammit
14:01:17 <ddarius> DevHC: CReal is strict (enough).  foldr isn't tail recursive.
14:01:18 <DevHC> > foldl' (+) 0 (replicate 1000000 0) :: CReal
14:01:21 <napping> > foldl' (+) 0 (replicate 1000000 0) :: CReal
14:01:22 <lambdabot>   mueval-core: Time limit exceeded
14:01:24 <lambdabot>   mueval-core: Time limit exceeded
14:01:28 <augur> ddarius: yeah but foldl failed too
14:01:32 <ddarius> > foldr (+) 0 (replicate 1000000 0) :: Int
14:01:34 <lambdabot>   *Exception: stack overflow
14:01:37 <augur> so its not that the call stack from the fold is the problem
14:01:39 <ddarius> augur: foldl is a pile of crap
14:01:44 <blackdog> augur: you'd expect foldl to fail
14:01:45 <napping> augur: foldl'
14:01:46 <augur> > replicate 1000000 0
14:01:48 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:01:49 <napping> you never want foldl
14:01:52 <ddarius> augur: As blackdog said (and I said earlier) use foldl'.
14:01:54 <augur> well thats that
14:01:56 <blackdog> it's building up thunks in the result that it doesn't really need to
14:02:05 <DevHC> i don't expect foldr to fail, i feel
14:02:06 <augur> yeah but foldl' failed too, ddarius
14:02:14 <chrisdone> augur: Not a stack overflow.
14:02:15 <napping> no, foldl' took too long
14:02:15 <wagle> copumpkin: now i'm wanting the type system to count..  heh
14:02:28 <napping> because it 1000000 was too big
14:02:32 <augur> oh true, it was mueval-core's time limit
14:02:32 <augur> ok
14:02:36 <ddarius> augur: Because it took too long.
14:03:05 <augur> back to reading about algebras!
14:03:10 <DevHC> > foldr (++) "tro" $ repeat "ol"
14:03:15 <lambdabot>   mueval-core: Time limit exceeded
14:05:27 <TTimo> ah .. even with a print server it manages to put the output in a blender
14:06:40 <ddarius> TTimo: I'm not sure how you managed that.
14:07:23 <wagle> in logic programming, when you take a term and replace all the instances of variables with values, what's that called?
14:07:40 <Heffalump> substitution? resolution?
14:07:57 <TTimo> ddarius: my print server is the following action: forever $ readChan ch >>= print
14:07:58 <uber_mor2> Hi, I am working through the Purely Functional Data Structures book by Okasaki and am getting an error with my Queue module. http://hpaste.org/44327/queue
14:08:30 <uber_mor2> The error is: Ambiguous type variable `q' in the constraint: `Queue q' arising from a use of `empty' at <interactive>:1:8-12
14:08:39 <wagle> some hersbrand thing
14:08:43 <wagle> herbrand
14:08:49 <TTimo> how do I add a flushing of stdout in between ..
14:09:05 <TTimo> I know hFlush, but I dunno how to point it to stdout
14:09:19 <hpaste> untwisted pasted "Queue"  http://hpaste.org/44327
14:09:50 <ddarius> TTimo: Flushing will change when things get output, but it won't change the order.
14:10:06 <ddarius> Are you using putStrLn (or something similar) elsewhere?
14:10:07 <napping> wagle: replacing variables with terms in all possible ways?
14:10:08 <wagle> ah, there I go: herbrand universe
14:10:13 <napping> or just instantiating?
14:11:07 <ddarius> The "Herbrand universe" is basically just the type of rose trees.
14:11:56 <wagle> i have a type that consists of a wild card value (variable), and a list of constants (value)
14:12:37 <wagle> i want two types, one with just the constants, and one with the wild cards in each of 5 fields
14:13:27 <sshc> :t hFlush stdout
14:13:28 <lambdabot> Not in scope: `hFlush'
14:13:28 <lambdabot> Not in scope: `stdout'
14:13:47 <alex404> So I've got a design question: I've got some general data structure, which in particular cases will have a set of accompanying parameters. Should I define a typeclass over the data structure, which requires definitions of the relevant accessors for the general class? Or should I define a parametric data type of the form Foo prms = Foo Bar prms? The type class option seems more elegent, but I'm always wary of using typeclasses unless I'm sur
14:13:47 <alex404> e I need them...
14:14:06 <sshc> TTimo: hFlush stdout :: IO ()
14:14:17 <TTimo> sshc: I do import IO but I still get 'not in scope: IO'
14:14:31 <TTimo> not in scope stdout even
14:14:49 <wagle> @hoogle stdout
14:14:49 <lambdabot> System.IO stdout :: Handle
14:14:53 <alex404> Essentially if I use typeclasses, all of my accessors can operate on the single data structure. With data types, the parameters are annoyingly nested when params is another record.
14:14:57 <sshc> (stdin, stdout, stderr) :: (Handle, Handle, Handle)
14:15:04 <sshc> TTimo: System.IO exports it
14:15:17 <sshc> @hoogle stdout
14:15:18 <lambdabot> System.IO stdout :: Handle
14:15:22 <sshc> http://www.haskell.org/hoogle/?hoogle=stdout
14:15:56 <TTimo> yeah it's obviously something really dumb that I'm doing wrong
14:16:01 <TTimo> kid needs me .. bbl8r
14:16:58 <wagle> try IO.stdout
14:17:22 <FUZxxl> If I installed the haskell platform from the package manager, how can I integrate the documentation for a package installed by cabal into the documentation tree? (Located at file://localhost/usr/share/doc/ghc6-doc/html/libraries/)
14:17:54 <wagle> TTimo: try IO.stdout..  then find incantation to make it unqualified
14:18:57 <ddarius> wagle: Everything is imported unqualified unless you explicitly say not to.
14:18:59 <napping> pozic: what did you try for histograms?
14:19:14 <ddarius> Further more, the qualified name would be System.IO.stdout, not IO.stdout.
14:19:32 <napping> accumArray on UArray Word8 Int was surprisingly slow
14:20:00 <wagle> i typed stdout in ghci, it said "no such variable"..  then IO.stdout, it worked
14:20:33 <wagle> ddarius: ^^^
14:20:44 <ddarius> What you get depends on what you import, though GHCi is more forgiving.
14:20:49 * wagle is playing the pure experimentalist
14:20:50 <ddarius> @where report
14:20:50 <lambdabot> http://www.haskell.org/onlinereport/
14:20:52 <uber_mort> Hi, I am working through the Purely Functional Data Structures book by Okasaki and am getting an error with my Queue module. http://hpaste.org/44327/queue
14:20:54 <fryguybob> uber_mort: You need to specify the type or use empty where the type can be inferred.
14:20:55 <uber_mort> The error is: Ambiguous type variable `q' in the constraint: `Queue q' arising from a use of `empty' at <interactive>:1:8-12
14:21:12 <uber_mort> fryguybob: so something like empty :: FifoQueue?
14:21:25 <uber_mort> fryguybob: and thanks for the response :)
14:21:26 <fryguybob> empty :: FifoQueue Int
14:21:36 <ddarius> http://www.haskell.org/onlinereport/io.html has stdout, so you can import IO and should get stdout, and IO.stdout.  (Modules are always imported fully qualified.)
14:21:39 <uber_mort> fryguybob: Ooohhhh!! Damn.  Thanks
14:21:49 <aristid> the haskelldb paper from 1999 is cute
14:21:53 <ddarius> However, System.IO should probably be preferred nowadays.
14:21:59 <aristid> ASP (!) haskell
14:22:04 <aristid> TREX
14:22:15 <aristid> it's like a glimpse into the past :D
14:23:33 <ddarius> wagle: Typing, foo = IO.stdout into a file and compiling it will fail if the IO module isn't imported.
14:24:08 <wagle> ddarius: ok, but he said he imported it
14:24:50 <wagle> ddarius: must be typo or something..  have to wsit for him to get back
14:25:09 <ddarius> Then, unless he explicitly asked for it to be qualified, stdout or IO.stdout should work, and if it doesn't then something else is the problem.\
14:25:53 <wagle> i bet he named the things to import from IO
14:26:27 <jonkri> anyone knows if there is a library which can convert a list of Events (as in http://hackage.haskell.org/packages/archive/xml-types/0.1.2/doc/html/Data-XML-Types.html) into like a Maybe Element or something
14:32:46 * hackagebot xml-basic 0.1.1.2 - Basics for XML/HTML representation and processing  http://hackage.haskell.org/package/xml-basic-0.1.1.2 (HenningThielemann)
14:33:59 <ddarius> copumpkin: Okay, last try.  This is the video I meant: http://www.youtube.com/watch?v=mnUWA8ImOyY
14:34:57 <wagle> MOMMMMM!  haskell wont let me have subtypes again!
14:36:32 <wagle> oh wait, maybe this is a job for HLists, just maybe
14:37:05 <ddarius> wagle: Use nuprl
14:38:06 <copumpkin> hm
14:38:16 <wagle> want a sorted list of Queries and Places, and Queries and Places are both subtypes of Tuple, which is Ord
14:40:40 <wagle> for example, suppose that Place = Integer, Query = Maybe Integer, and Tuple = Integer..
14:41:02 <wagle> for example, suppose that Place = Integer, Query = Maybe Integer, and Tuple = a
14:41:12 <wagle> no, thats not right either
14:41:55 * wagle thinks
14:42:49 <wagle> ddarius: this is a mad haskell skillz building expedition
14:43:22 <ddarius> wagle: Um. Okay.
14:43:26 <wagle> heh
14:43:29 * ddarius doesn't know what wagle is talking about.
14:43:45 <wagle> <ddarius> wagle: Use nuprl
14:43:54 <ddarius> copumpkin: Also, did you watch Robert Constable's talks at the Oregon Programming Languages Summer School?
14:44:05 <copumpkin> ddarius: nope, not yet
14:45:45 <azaq23> wagle: That might be too easy (and I don't understand what tuples and subtypes got to do with this), but: data Thing = Place Stuff | Query Stuff MoreStuff; instance Eq Thing; instance Ord Thing?
14:46:48 <wagle> azaq23: thats what i just started doing, intending to explicitly define Ord
14:48:03 <wagle> oh darn, its supposed to be a set, no multiple occurances..  thanks for mentioning Eq
14:48:25 <azaq23> Ord has Eq as a class constraint, you need it anyway
14:49:09 <wagle> yeah, i know, but i have to delete Queries that are equal to Places
14:50:24 <wagle> or maybe not..  sorry for thinking out loud
15:03:35 <copumpkin> ddarius: looks like a functor
15:04:07 <Philippa> on the list of blog posts I'll probably never get round to writing is a piece on using monadic form to spot which monads/monad transformers might improve a piece of code...
15:04:15 <Philippa> anyone know if someone's done that already yet, btw?
15:04:36 <Philippa> (I figure the normalisation should up the parameter/result flows that're your tip-offs that little bit more obviously)
15:05:05 <hpc> Philippa: i think it's something that most people will know how to do, once they grok monads
15:05:17 <hpc> or rather, grok monads, plus the standard monads
15:05:19 <Philippa> hpc: FCVO "grok monads" I agree
15:05:21 <hpc> reader/writer/etc
15:05:44 <Philippa> but I think it's a nice way of highlighting what the patterns are slightly more neatly
15:05:50 <hpc> i personally prefer State to reader/writer
15:06:00 <copumpkin> hpc: they do different things
15:06:04 <augur> byorgey: do you know of any discussion of enumeration of F-algebra operations, or what not?
15:06:04 <Philippa> I actively prefer to avoid state unless I explicitly need that level of power
15:06:26 <Philippa> it's throwing away knowledge that can be exploited
15:06:41 <hpc> copumpkin: i thought you could get Reader from State by just not changing the initial state
15:07:02 <hpc> and Writer in a similar way
15:07:04 <byorgey> augur: no
15:07:11 <augur> :\
15:07:18 <Philippa> hpc: approximately, but additional constraints = additional reasoning capability
15:07:27 <augur> bee-tee-dubs, for the signature of an algebra's operation, i've seen two notations
15:07:29 <copumpkin> hpc: well, sure, but you get fewer guarantees. If you just use the more powerful thing unconditionally, just use IO :P
15:07:35 <Philippa> for example, Writer is RT modulo permutation of log entries
15:07:36 <augur> for instance
15:07:37 <hpc> lol
15:07:47 <Saizan> for Writer you get different strictness properties, and tell w = modify (`mappend` w), not just put
15:07:47 <augur> mu X. 1 + A*X
15:07:50 * ddarius doesn't know what "enumerration of F-algebra operations" would mean.
15:07:51 <augur> and another was like
15:08:06 <hpc> i suppose i have just never needed the guarantees of writer/reader
15:08:11 <augur> 1 +^ A *^ id
15:08:20 <augur> or maybe it was const A
15:08:24 <augur> what is this second one??
15:08:33 <copumpkin> hpc: like any type thing, it just prevents you from using things in ways that you don't intend to use them
15:08:44 <copumpkin> if you know your state isn't going to change and you're only reading it, don't let yourself accidentally write to it
15:08:55 <Philippa> hpc: writer is also really nice for turning an algorithm into one you can 'feed time to' or equivalently keep track of the time it's eating while it computes
15:09:17 <byorgey> augur: in the second notation everything is basically lifted into the Reader monad
15:09:22 <Philippa> you just have it log 'ticks'. Which is what you want for the classic "progress bar" dialog
15:09:36 <augur> byorgey: ahhh thats what i was thinking but i wasnt sure if i was right, since the paper didnt explain it
15:10:22 <ddarius> augur: If I understand what you are meaning to ask, the "operations" aren't on F-algebras but on functors.
15:10:54 <augur> ddarius: the operations _of_ algebras
15:11:25 <augur> tho in this case i suppose it was actually the functor notation
15:13:57 <augur> hmm
15:13:59 <wagle> where's the ambiguity in deriving Enum for Maybe a if Enum a?
15:14:15 <DrSyzygy> wagle: How does Nothing compare with anything else?
15:14:21 <ddarius> Typically if you are going to talk about "operations" at all, you explicitly have a signature that explicitly enumerates them.  The concept of an F-algebra is meaningful for -any- endofunctor F, so the notion of "operations" will not necessarily be clear at all.
15:14:24 <mauke> unfavorably
15:14:39 <mauke> > Nothing < Just ""
15:14:40 <lambdabot>   True
15:14:45 <DrSyzygy> wagle: Specifically, where in the sequence spelled out by your enum should it come?
15:14:50 <DrSyzygy> mauke: :-)
15:14:54 <augur> ddarius: so, for T(X) = 1 + A*X, and nil : 1 -> X and cons : A*X -> X, [nil,cons] : 1 + A*X -> X
15:15:19 <wagle> > [Nothing..] :: [Maybe Bool]
15:15:20 <lambdabot>   <no location info>: parse error on input `]'
15:15:40 <wagle> > [Nothing..Just True]
15:15:41 <lambdabot>   A section must be enclosed in parentheses
15:15:41 <lambdabot>    thus: (`Nothing..` Just True)N...
15:15:53 <DrSyzygy> > [1..3]
15:15:55 <lambdabot>   [1,2,3]
15:15:56 <wagle> > [Nothing..(Just True)]
15:15:56 <lambdabot>   A section must be enclosed in parentheses
15:15:57 <lambdabot>    thus: (`Nothing..` (Just True)...
15:16:09 <mauke> SPACES AROUND OPERATORS
15:16:10 <wagle> meh
15:16:13 <DrSyzygy> > enumFromTo Nothing (Just True)
15:16:14 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Bool.Bool))
15:16:14 <lambdabot>    arising...
15:16:15 <mauke> the prime directive
15:16:21 <augur> but that means that [nil,cons] (1, nil ()) = ??
15:16:24 <augur> erm..
15:16:48 <DrSyzygy> wagle: And the point here is, at least, that it's not clear whether it's better to make it [Nothing, Just False, Just True] or [Just False, Just True, Nothing]
15:17:06 <mauke> DrSyzygy: just do what Ord does
15:17:07 <augur> [nil,cons] (1, nil()) = Right (1, nil ()) ??
15:17:19 <ddarius> The [f,g] notation corresponds to the either function.  It's reasonably common notation for that in any category with coproducts.
15:17:40 <ddarius> So that's either nil cons
15:17:41 <DrSyzygy> mauke: You could. I'm just trying to give arguments why it hasn't been done.
15:17:51 <augur> ddarius: yeah i guess
15:18:18 <augur> its just, nil () :: X according to nil :: 1 -> X
15:18:29 <augur> but [nil,cons] () = Left (nil ()) :: X
15:18:30 <augur> ?
15:18:35 <wagle> well, i mirror the defn of Maybe , and derive Ord just fine
15:18:41 <mauke> fromEnum (Just (maxBound :: Int))
15:18:54 <wagle> i just am not allowed to then derive Enum
15:19:18 <ddarius> augur: No, as you stated yourself [nil,cons] : (1 + A*X) -> X.
15:19:21 <byorgey> [nil,cons] ()  is a type error
15:19:28 <augur> oh right yes
15:19:34 <ddarius> :t either (const []) (:)
15:19:36 <lambdabot>     Couldn't match expected type `[a]'
15:19:36 <lambdabot>            against inferred type `[b] -> [b]'
15:19:36 <lambdabot>     In the second argument of `either', namely `(:)'
15:19:45 <ddarius> :t either (const []) (uncurry (:))
15:19:45 <augur> brilliant!
15:19:46 <lambdabot> forall a a1. Either a (a1, [a1]) -> [a1]
15:20:12 <augur> so [nil,cons] (Left ()) = nil ()
15:20:21 <ddarius> Yes.
15:20:35 * wagle resists urge to steal zomgbie's nick
15:21:02 <wagle> too cool
15:22:10 <augur> [nil,cons] $ Right (1, [nil,cons] $ Left ())  =  [nil,cons] $ Right (1, nil ())  =  [nil,cons] $ Right (1, nil ())  =  cons (1, nil ())
15:22:14 <augur> oooh brilliant
15:22:20 <wagle> DrSyzygy: so i guess the question is "i derived Ord, howcome i cant derive Enum?")
15:22:49 <DrSyzygy> I dunno
15:23:03 <wagle> 8)
15:23:19 <DrSyzygy> Actually, if you google it...
15:23:42 <DrSyzygy> ...the Haskell 9 report has conditions for when Enum can be derived.
15:23:56 <DrSyzygy> And it turns out that you can only derive Enum if you have only null-ary constructors.
15:24:02 <augur> i suppose the question is then how you get around having these Left/Right constructors explicitly? i mean, the carrier of the algebra doesnt have Left/Right but the functor requires them
15:24:10 <DrSyzygy> So data Foo = A | B | C deriving Enum works.
15:24:21 <DrSyzygy> But data Foo = A | B | C Bool deriving Enum doesn't.
15:24:29 <DrSyzygy> Because C is not nullary, so Foo is not an enumeration.
15:24:37 <DrSyzygy> No, WHY they chose that in the Standard I don't know.
15:24:38 <augur> well, the operation, not the functor
15:24:51 <augur> the operation is T(U) -> U, not U -> U
15:26:08 <xpika> > parse (do {a <- char '['; b <- many anyChar ; c<- char ']'; return (a,b,c)}) "" "[123]4]"
15:26:10 <lambdabot>   Not in scope: `parse'Not in scope: `anyChar'
15:26:37 <ddarius> The algebra is T(U) -> U (with U).
15:26:50 <xpika> result expecting "]" 
15:27:05 <ddarius> Or rather -a- T-algebra is any morphism of that form (with a given carrier.)
15:27:23 <augur> right
15:27:50 <augur> but dont we want to say that the algebra's operation operations on elements of U? or am i missing something deeper here
15:28:04 <xpika> is there any way to get parsec to behave  like how a regexp would use [.*]
15:28:35 <xpika> with the star in the middle greedy but respectful of what comes after it
15:28:53 <rwbarton> oh
15:29:02 <mauke> xpika: when would you ever need that behavior?
15:29:02 <rwbarton> you know [] are special characters in regexps right :)
15:29:12 <ddarius> In Haskell notation, T(X) = 1 + A*X is type T x = Either () (A,x), so the algebra will take in something of that type.
15:29:23 <xpika> rwbarton: yes imagine escaping is applied
15:29:37 <xpika> mauke: to parse invalid json
15:29:43 <mauke> ouch
15:29:46 <ivant> is Bryan O'Sullivan around (or what is his nick?)
15:30:03 <wagle> DrSyzygy: the original question was "how is this ambiguous?", but [Nothing, Just (-2)..] would be weird
15:30:04 <ddarius> ivant: His nick is bos.
15:30:04 <mauke> preflex: ? who:bos
15:30:05 <preflex>  factoid not found
15:30:07 <mauke> aww
15:30:20 <notallama> xpika: json is not a regular language.
15:30:33 <napping> zomgbie: any relation to zmobie?
15:30:44 <KingdomForm> rand(200,99)
15:30:46 <xpika> notallama: its markup
15:30:48 <wagle> so if Bounded, you should be able to derive Enum, maybe
15:30:50 <KingdomForm> yay!!
15:30:53 <augur> ddarius: no, i know, but
15:31:02 <DrSyzygy> wagle: And the weirdness of that is EXACTLY the “where do you put Nothing” I pointed out first.
15:31:05 <augur> then that means the operation of the algebra doesnt operate on the carrier of the algebra
15:31:05 <Philippa> xpika: is what you need manyTill?
15:31:19 <notallama> xpika: i mean it's not regular as in it can't be parsed by regular expressions.
15:31:23 <DrSyzygy> wagle: Even for Bounded, any placement you pick is going to feel artificial.
15:31:55 <KingdomForm> http://webchat.freenode.net/?channels=haskell&uio=Mz1mYWxzZSYxMD10cnVlJjExPTI0Nge9#
15:32:20 <ddarius> augur: It doesn't.  It operates on a more structured thing.
15:32:57 <wagle> i thought you used bool, not integer..  i used integer, which has no minBound, hence no obvious distance from Nothing, which would be first
15:33:02 <Maxdamantus> Just checking .. with forkIO threads, if one thread just finishes a read of some sort (hGetLine, System.Posix.fdReadBuf, whatever), no other thread can take control until that thread goes into another read, right?
15:33:11 <wagle> Bool is bounded
15:33:13 <ddarius> (The (given) algebra does, that is.  I still don't know what an "operation of the algebra" is.)
15:33:29 <napping> is there a half-open version fo enumFromTo?
15:33:36 <augur> ddarius: an algebra is a pair, (U,f) U the carrier, f the operation of the algebra
15:34:13 <ddarius> augur: Okay.  Usually simply f is called the "algebra" with the carrier understood.
15:34:14 <mauke> Maxdamantus: why do you think that?
15:34:17 <xpika> Philippa:  manyTill it is not greedy enough
15:34:29 <Maxdamantus> mauke: because it seems logical .. hm :\
15:34:44 <Maxdamantus> So that isn't the case?
15:34:44 <mauke> Maxdamantus: multiple threads can be running at the same time
15:34:46 <wagle> DrSyzygy: everything pretty much takes dictionary/lexical order as the default
15:34:47 <ddarius> Maxdamantus: GHC uses non-blocking IO for all the (GHC-defined) IO operations.
15:35:04 <monochrom> ghc can switch threads at "allocation points" e.g. when a thread creates a cons cell
15:35:14 <Philippa> xpika: what does "respecting the outside" mean, then?
15:35:15 <ddarius> Also, GHC uses (pseudo) pre-emptive concurrency.
15:35:16 <mauke> Maxdamantus: even within the same OS thread, context switching can happen in the memory allocator
15:35:22 <Maxdamantus> ddarius: but to the thread, it appears to block.
15:35:29 <KingdomForm> (>^,^)>
15:35:29 <Philippa> ..oh, I think I see
15:35:43 <ddarius> Maxdamantus: To the one thread, not to the others whether they be in the same OS thread or not.
15:35:44 <Philippa> you want the equivalent of manyTill with the /entire outside/ as the till?
15:36:05 <ddarius> (Or what I mean is that lightweight threads using the same OS thread will still run.)
15:36:37 <Maxdamantus> Yeah, sort of like an OS .. to an application/thread, reads will block, but the kernel sees it differently (as it's the one providing that illusion)
15:36:51 <ddarius> But now I'm thinking that maybe you just thought that (lightweight) threads only switched when they block, but that isn't the case and also there may be multiple OS threads.
15:36:58 <chrisdone> Maxdamantus: I had a problem with reading from handles from multiple threads due to using buffering on the handles. The other threads blocked and received no data until data was receives on another thread.
15:37:19 <wagle> DrSyzygy: i'll stop now..  8)
15:37:24 <Maxdamantus> Hmm .. okay.
15:37:42 <Maxdamantus> So you do have to consider thread safety when using forkIO?
15:37:47 <chrisdone> Maxdamantus: (Handles as wrappers around sockets, though, which probably factors in to the behaviour.)
15:37:49 <Maxdamantus> Using MVars, etc
15:38:27 <ddarius> Maxdamantus: Yes.
15:38:45 <ddarius> Maxdamantus: Just think of them as completely normal threads that are very cheap.
15:39:07 <Maxdamantus> forkIO (nonblockingthing >> nonblockingthing) >> anothernonblockingthing >> anothernonblockingthing
15:40:25 * wagle trips and falls into "nothing typechecks any more!" hell
15:41:33 <ddarius> wagle: Think more clearly.
15:41:42 <dark> wagle, I wonder if when one cease to be newbie, a screen full of type errors would be less painful
15:42:11 <roconnor> wagle: if it makes you feel better, it only doesn't typecheck because the code is wrong
15:42:25 <roconnor> (I presume)
15:42:36 <Maxdamantus> What about without -threaded? "If you don't use the -threaded option, then the runtime does not make use of multiple OS threads."
15:42:45 <ddarius> dark: What happens is that you cease to childishly view it as the "compiler getting in my way" and you start to see it as "the compiler pointing out where I'm unclear/wrong," up to a point, then you return to "the compiler is getting in my way."
15:42:46 <wagle> roconnor: the code is right, haskell is wrong!  bwahahaha
15:42:46 <chrisdone> wagle: Just put `undefined' in where the problem is, then work out the types that should go there.
15:42:46 <Maxdamantus> (GHC)
15:42:54 <xpika> using regexps in javascript "[123]4]".match(/(\[)(.*)(\])/) => ["[123]4]", "[", "123]4", "]"]
15:43:02 <ddarius> Maxdamantus: That's mostly irrelevant from your perspective.
15:43:17 <xpika> im basically trying to do the same in parsec
15:43:19 * wagle is running the squeegee
15:43:31 <monochrom> most type errors are mind errors
15:43:58 <dark> Maxdamantus, I think haskell has co-routines (or at least I saw some continuation thing that advertised itself as something like that)
15:44:04 <monochrom> but nevermind, you already know. <hide>
15:44:10 <ddarius> dark: No, it doesn't.
15:44:11 <dark> maybe it is what you want?
15:44:30 <ddarius> You can model them.  You can even model cooperative concurrency if you want, but neither is built-in.
15:45:10 <wagle> monochrom: i'm trying to get haskell to do something it dont wanna, and i got a cascade of errors causing errors
15:45:12 <ddarius> (Well, Hugs implements the threading system cooperatively.)
15:45:15 <dark> I meant, some lib at hackage
15:45:50 <Philippa> xpika: yeah. I don't actually read regexps, unfortunately
15:45:59 <dark> I saw something with callCC. I'm impressed to find it in Haskell, I heard it is not typeable in OCaml
15:46:03 <Maxdamantus> So it's basically like, in a browser environment using setTimeout(.., 0) in JS (an example of an event-based system) to set a continuation of every action.
15:46:06 <Philippa> never used them enough to get the toothpickery burned into my head
15:46:44 <ddarius> Maxdamantus: What is "it"?
15:46:46 <Maxdamantus> do { foo; bar; baz } .. setTimeout(function(){ foo(); setTimeout(function(){ bar(); setTimeout(function(){ baz(); }, 0); }, 0); }, 0);
15:47:06 <dark> +-
15:47:13 <dark> ops
15:47:19 <dark> @hoogle callCC
15:47:19 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
15:47:40 <Maxdamantus> (for "apparently" non-blocking actions anyway)
15:48:02 <napping> dark: you can type most things in O'Caml too
15:48:10 <napping> especially now that they've added higher rank polymorphism
15:48:21 <ddarius> Maxdamantus: It's like that as much as any other pre-emptive concurrency mechanism is (except that isn't true, hence the "pseudo" above.)
15:48:26 <napping> I guess you specifically said callCC
15:48:35 <rwbarton> Maxdamantus: There's basically no such thing in GHC as a blocking action in the sense that it prevents other threads from computation or doing IO.
15:49:05 <Philippa> xpika: ah, you want it to find the last possible bracket that gives you a matching bracket setup, essentially?
15:49:07 <Maxdamantus> rwbarton: but in the sense that it blocks *the* thread.
15:49:12 <napping> I think oleg's delimited continutaion stuff worked out a bit more neatly in O'Caml
15:49:32 <xpika> Philippa: correct
15:49:35 <Maxdamantus> rwbarton: just as in an OS, a blocking call (like POSIX's read) will block the application (not the OS)
15:49:36 * wagle shouts feexed!  then looks embarrassed at his outburst
15:49:36 <rwbarton> Everything blocks the thread it's in
15:49:47 <rwbarton> unless you're using some exotic asynchronous IO library
15:49:49 <Maxdamantus> I'll still call it a blocking call though.
15:49:54 <Maxdamantus> Because I'm not writing an OS.
15:49:55 <Philippa> xpika: do you need to do the recursive version of that?
15:50:02 <rwbarton> If you want asynchronous IO, use forkIO
15:50:26 <Maxdamantus> Hell, they'll probably even call it a blocking call from the OS' perspective.
15:50:27 <napping> Maxdamantus: if you just call library functions, you can pretty much think of all IO as blocking, and forkIO as giving you very cheap threads
15:50:39 <napping> very cheap fully preemptive threads
15:50:40 <Philippa> I can figure out how to do it if there's no relevant recursion (that is, if any recursion's bracketed)
15:50:56 <xpika> Philippa: of course , but this is a predicate
15:51:25 <Maxdamantus> "is it blocking me? no. therefore it's non-blocking"
15:51:33 <rwbarton> xpika: you should be able to write something along the lines of manyGreedy x = try (x >> manyGreedy x) <|> empty
15:51:52 <chrisdone> Maxdamantus: That kind of chaining in JavaScript is evil.
15:51:57 <Philippa> yeah, I was thinking of manyTillGreedy
15:52:34 <Maxdamantus> chrisdone: that sort, yeah, probably, usually.
15:52:42 <rwbarton> Actually, I don't even need that try, usually
15:52:57 <Maxdamantus> If that must be done, it'd probably be nicer with a reduceRight
15:53:20 <hpc> :t let manyGreedy x = try (x >> manyGreedy x) <|> empty in manyGreedy
15:53:21 <lambdabot> Not in scope: `try'
15:53:21 <lambdabot>     Ambiguous occurrence `empty'
15:53:21 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
15:53:30 <chrisdone> Maxdamantus: JS would've been good with do-notation imho. You can't get anything done without CPS. Wrapping everything in a closure messes with code structure too much. When you want to move it around you have to re-wrap everything and your commit messages are full of indentation changes because you needed an extra asynchronous call.
15:54:03 <ddarius> chrisdone: Don't change the indentation level.
15:54:15 <Maxdamantus> [foo, bar, baz].reduceRight(function(a, b){ a(); b && setTimout(b, 0); });
15:54:19 <hpc> yes, keep everything at column 0!
15:54:23 <hpc> :D
15:54:28 <ddarius> @where hpaste
15:54:28 <lambdabot> http://hpaste.org/
15:54:42 <Maxdamantus> Eh, that doesn't even make sense.
15:54:58 <Maxdamantus> [foo, bar, baz].reduceRight(function(a, b){ return function(){ a(); b && setTimout(b, 0); }; });
15:55:01 <ddarius> hpc: That's roughly what do-notation does and if we didn't have do-notation using (>>=) explicitly in that style produces essentially the same result.
15:55:01 <Maxdamantus> That might.
15:55:05 <Maxdamantus> Irrelevant here anyway.
15:56:58 <hpaste> TTimo pasted "forever"  http://hpaste.org/44328
15:57:19 <ddarius> http://hpaste.org/44331/stylized_code
15:58:06 <Philippa> xpika: is that enough to run with?
15:58:26 <xpika> Philippa: just trying it out now
15:58:55 <TTimo> http://hpaste.org/44330/forever_annotation_annotati <- how do I fix that? my understanding is that it wants a type in the Show typeclass in return, and having forever in there is somehow screwing it up ?
15:59:48 <ddarius> TTimo: Adding the rest of your code will probably fix it.
15:59:57 <ddarius> Currently it doesn't know what type you want 'print' to print.
16:00:42 <TTimo> aaaaah
16:01:20 <TTimo> ok :)
16:02:07 <hpaste> ddarius pasted "stylized code"  http://hpaste.org/44331
16:02:46 <ddarius> Hmm
16:03:19 <chrisdone> hm. I think I'll increase the 'check' time on that
16:07:07 <chrisdone> ddarius: Yeah, but I need to sort out my editor to indent like that. I don't manually indent anything.
16:07:42 <ddarius> Slave to a machine.  You'd do well when the robots take over if only the robots needed pets.
16:07:54 <hpc> ddarius: unfortunately you still have to close all the braces
16:08:24 <ddarius> hpc: Yeah, but that's changing one line, not many, and yeah, javascript sucks.
16:09:08 <djahandarie> chrisdone, oh wow, nice
16:09:17 * hpc has thankfully been able to keep js to a minimum on his website
16:09:22 <chrisdone> If you wrote as much JS as me you'd avoid manual indentation too.
16:10:05 <djahandarie> chrisdone, why isn't it just push so it happens instantly?
16:10:09 <ddarius> chrisdone: What's special about javascript as compared to Scheme/Lisp/C#/C/C++ etc.?
16:10:35 <aristid> javascript is special in that it runs in a browser
16:10:59 * hpc sorta wants to get in on that ghc-js project
16:11:09 * Maxdamantus only likes "copy" indenting.
16:11:21 <chrisdone> ddarius: I don't write UI interfaces in Scheme/Lisp/C#/C/C++ etc.
16:11:30 <n00p> What's "special" about Javascript by comparison of those? prototype-based object orientation?
16:11:32 <Maxdamantus> It works pretty much globally, and you it's easy to predict.
16:11:36 <chrisdone> djahandarie: It's based on the feed http://hpaste.org/atom
16:11:45 <ddarius> aristid: So does C#.
16:11:51 <djahandarie> Ah, so it isn't actually integrated
16:11:58 <n00p> C# runs in a browser?
16:12:01 <n00p> Are you sure?
16:12:02 <aristid> ddarius: in _my_ browser, C# does not run
16:12:13 <chrisdone> Silver.. thingie, allows that.
16:12:22 <ddarius> Silverlight
16:12:23 <chrisdone> Quicksilver? I dunno.
16:12:24 <aristid> and i will never install silverlight or moonlight!
16:12:25 <chrisdone> Oh.
16:13:07 * Maxdamantus doesn't even have Java in his main browser.
16:13:23 * djahandarie doesn't either
16:13:38 <Maxdamantus> Flash is still too common though :\
16:14:00 <hpc> i don't have java installed at all
16:14:02 <chrisdone> ddarius: I made a simple DSL for JS anyway so that I can avoid writing it directly... I just need to finish macro support in Lisk so that I can make it comfortable.
16:14:17 <hpc> i have flash, but i also use noscript
16:14:42 <Maxdamantus> I guess all I use Flash for really is Youtube.
16:15:00 * Maxdamantus wonders if they support everything using <video> yet.
16:15:24 <n00p> I'd love to see an example of C# running in a browser.
16:15:29 <chrisdone> Maxdamantus: You can opt in for the "html5" beta.
16:15:36 <ddarius> @google silverlight
16:15:38 <lambdabot> http://silverlight.net/
16:15:38 <lambdabot> Title: Home : The Official Microsoft Silverlight Site
16:15:38 <chrisdone> n00p: Just try to watch a video on a Microsoft site.
16:15:45 <Maxdamantus> chrisdone: but doesn't it only work for some videos?
16:16:01 <chrisdone> Maxdamantus: Last I tried, correct.
16:16:02 <Maxdamantus> or maybe that's because they were half-way through converting all of them at the time.
16:16:05 <Maxdamantus> (to WebM)
16:16:33 <Maxdamantus> Last time I tried, I also found it rather laggy for some reason.
16:17:07 <chrisdone> djahandarie: I would make it integrated but the host it runs on blocks connecting to port 6667. I will move it to a different host somewhen.
16:17:16 <Maxdamantus> Maybe it runs the video in the main browser (Gecko) thread (I think Flash runs in another)
16:17:27 <djahandarie> Ah, I see.
16:17:43 <djahandarie> chrisdone, Freenode has alternate ports that might not be blocked
16:18:08 <chrisdone> The database is large… so I'll move it when my connection isn't being crap.
16:18:12 <chrisdone> djahandarie: Such as?
16:18:46 <djahandarie> "All freenode servers listen on ports 6665, 6666, 6667, 6697 (SSL only), 7000 (SSL only), 7070 (SSL only), 8000, 8001 and 8002."
16:19:56 * chrisdone tries
16:22:29 <chrisdone> Seems to work.
16:22:43 <djahandarie> Nice. :o
16:23:26 <chrisdone> HugoDaniel: :)
16:24:12 <HugoDaniel> chris! :D
16:24:19 <chrisdone> djahandarie: Mmkay. Let's try this IRC library out on Hackage...
16:24:21 <HugoDaniel> whats up ?
16:24:23 <chrisdone> Hugglesworth: What's up? 
16:24:46 <chrisdone> Still getting paid to hack Haskell. Can't complain. ;-)
16:24:50 <HugoDaniel> still the same, working a the univ., coding haskell for the win and thats about all :)
16:25:04 <HugoDaniel> eheh
16:25:06 <chrisdone> Did you make it to belhac?
16:25:13 <HugoDaniel> no :(
16:25:38 <HugoDaniel> i miss talking in person with some haskell heads
16:25:39 <chrisdone> Me neither but I'm planning on making it to the next (European) one.
16:26:32 <copumpkin> chrisdone: get them to send you to hac phi ;)
16:26:34 <HugoDaniel> yeah
16:26:38 <HugoDaniel> :)
16:26:46 <chrisdone> @google hac phi
16:26:48 <lambdabot> http://www.haskell.org/haskellwiki/Hac_%CF%86
16:26:48 <lambdabot> Title: Hac φ - HaskellWiki
16:26:55 <copumpkin> july 29-31 iirc
16:27:06 <HugoDaniel> im planing on going to ccc camp in august and then to the utrech summerschool course, if i get to be approved this year
16:27:33 <Hugglesworth> chrisdone: not much, cooking dinner
16:29:21 <Hugglesworth> chrisdone: where do I know you from? xu do jbopre
16:29:51 <chrisdone> copumpkin: In north Italia, working and paid, on the IRC is where I spent most of my days, chilliin' out, relaxing, typin' all cool and eval'ing some fixpoints at type level (Mu), when a couple of guys, they were up to no good, started chatting in my IRC channel, I mentioned one little hackathon and the guys got excited and said you're coming to Philadelphia in Pennsylvania, USA.
16:30:02 <chrisdone> Hugglesworth: Yes.
16:30:16 <chrisdone> copumpkin: Are you going?
16:30:18 <HugoDaniel> :D
16:30:24 <copumpkin> chrisdone: hah nice
16:30:27 <copumpkin> yeah, I'll probablyh go
16:31:04 <chrisdone> Aright. Isn't it like 1000EUR to get a return ticket to the US? :u
16:31:15 <copumpkin> I'm in the US now :)
16:31:21 <ddarius> copumpkin: Needs more rhyme.
16:31:25 <ddarius> Er chrisdone 
16:31:31 <copumpkin> but nah, it's not usually that much in my experience
16:31:34 <ddarius> But not a bad start.
16:31:43 <ddarius> chrisdone: What?
16:31:45 <ddarius> !
16:32:02 * ddarius paid far less than 1000EUR for a round-trip ticket to Japan.
16:32:09 <aristid> chrisdone: it took me 50% of that thing to get the reference to fresh prince of bel air :P
16:32:16 <chrisdone> Needs more interrobang ‽, but not a bad start. :-P
16:32:37 <copumpkin> only time I've paid that much was a fairly last-minute flight during an expensive period
16:32:44 <chrisdone> Let me check prices again.
16:33:00 <ddarius> If you are going at a bad time, or doing it short-notice it can get expensive.
16:33:24 <ddarius> Tickets to Hawaii from Mississippi were about $2000-2500 dollars around Christmas.
16:34:37 <chrisdone> British Airways insists on giving me Italian-localised booking options. ;_;
16:35:15 <HugoDaniel> :)
16:35:18 <chrisdone> copumpkin: What's a good Italian airline? I tried lufthansa last and ended up stuck for three days during the snow "crisis". *Shakes from the trauma*
16:35:53 <copumpkin> chrisdone: hah, oxymoron :P
16:36:26 <chrisdone> copumpkin: True. :P
16:36:29 <HugoDaniel> i like tap :)
16:36:35 <HugoDaniel> the portuguese airline
16:36:47 <HugoDaniel> thats all i ever fly
16:36:59 <copumpkin> chrisdone: I usually do alitalia these days but not because they're good. Just because they have a direct route from rome to boston
16:37:26 <chrisdone> Ah.
16:37:37 <wagle> whats the paste service du jour?
16:37:42 <Twey> hpaste.org
16:37:49 <ddarius> There is no du jour one.
16:37:57 <wagle> i see that now, thanks
16:38:06 <aristid> @where hpaste
16:38:06 <lambdabot> http://hpaste.org/
16:38:16 * hackagebot bitset 1.1 - A functional data structure for efficient membership testing.  http://hackage.haskell.org/package/bitset-1.1 (DenisBueno)
16:38:19 <Twey> De la année
16:38:22 <aristid> ^ clickable
16:38:47 <chrisdone> Twey: Hehe.
16:39:11 <hpaste> waglemaccom pasted "odd error message"  http://hpaste.org/44332
16:39:18 <wagle> whats wrong with this: ^^^
16:40:34 <aristid> hpaste bot is back?!
16:40:42 <aristid> thanks, chrisdone (i assume it's your bot?)
16:41:31 <aristid> wagle: what's the error message?
16:41:52 <chrisdone> aristid: Yesh.
16:41:58 <HugoDaniel> buy
16:42:09 <chrisdone> Oh my giddy grandmother.
16:42:15 <chrisdone> 1799.74EUR
16:42:17 <aristid> chrisdone: is "Yesh" some weird dialect version of "yes"?
16:42:21 <chrisdone> Got to be having a laugh. From Verona to Phily.
16:42:44 <chrisdone> aristid: Yesh.
16:42:54 <aristid> chrisdone: it might also mean "no"
16:43:08 <aristid> no way to deduce this logically *panics*
16:43:13 <chrisdone> :P
16:43:38 <chrisdone> copumpkin: How can this price be so high?
16:44:01 <copumpkin> lol
16:44:07 <copumpkin> I dunno, you're looking in the wrong places probably
16:44:09 * ddarius priced one flight to Japan at $100,000-200,000
16:44:21 <ddarius> The variance can be significant.
16:44:35 <aristid> $100,000? in zimbabwe dollar, surely?
16:44:49 <chrisdone> copumpkin: I put it a week apart and got it down to 939.
16:45:16 <copumpkin> chrisdone: that seems more like it
16:45:18 <chrisdone> Seems the longer apart the cheaper it is.
16:45:25 <copumpkin> in $
16:45:28 <copumpkin> not euros
16:45:33 <copumpkin> http://www.kayak.com/flights/MIL-PHL/2011-07-28-flexible/2011-08-01-flexible
16:45:35 <chrisdone> 700 for a week.
16:45:45 <copumpkin> there!
16:46:09 <napping> STUArray MArray instances are a bit funny
16:46:17 <napping> the s gets in the way
16:46:32 <aristid> chrisdone: so you'll just extend your stay for a bit longer, to save money?
16:46:47 <napping> Maybe there could be an STArray class, and instance STArray arr val => MArray (arr s) val (ST s)
16:46:54 <djahandarie> Won't hotel costs etc. just make it more expensive again?
16:46:55 <wagle> aristid: i pasted the error message, but bot didnt report that
16:46:58 <chrisdone> aristid: I daresay staying in an hotel or hostel would cost much.
16:47:54 <aristid> wagle: generate-all-places.hs:29 which line is that?
16:48:03 <wagle> last line
16:48:40 <napping> I'd like to write fillSTUArray bounds val fill = runSTUArray (do arr <- newArray bounds val; fill arr; return arr)
16:49:06 <chrisdone> I'll see about living arrangement costs over time and balance out the ticket price.
16:49:17 <chrisdone> copumpkin: Can I stay in your kitchen cupboard?
16:49:21 <wagle> aristid: the fragment is "runnable"
16:49:35 <aristid> wagle: fromEnum (Any maxBound `asTypeOf` b)
16:49:41 <djahandarie> chrisdone, you could try couch surfing!
16:49:56 <aristid> wagle: to tell the compiler which type you need there
16:50:06 <copumpkin> chrisdone: if you want to come to Boston, sure
16:50:08 <djahandarie> copumpkin doesn't live in philadelphia anyways :P
16:50:21 <wagle> b is of type a
16:50:23 <copumpkin> but I'll probably have a hotel/hostel in philly too
16:50:41 <aristid> wagle: as, and the compiler knows the type of b
16:50:50 <djahandarie> Could split the cost for a double room
16:50:52 <aristid> wagle: but it does not know the precise type of Any maxBound
16:51:07 <aristid> wagle: with asTypeOf, you can force it into the same type as b
16:51:12 <aristid> :t asTypeOf
16:51:13 <lambdabot> forall a. a -> a -> a
16:51:36 <copumpkin> djahandarie: a bunch of us should split the cost of the Haskell Imperial Suite
16:51:38 <aristid> :t 4 `asTypeOf` x
16:51:39 <lambdabot> Expr
16:51:45 <chrisdone> My parents want to visit in maggio… the perfect time to get out of the country. ;-)
16:51:54 <copumpkin> lol
16:52:04 <aristid> wagle: but you could also let the compiler automatically derive Enum and Bounded
16:52:14 <aristid> or wait, it might not like that due to the Any
16:52:25 <copumpkin> chrisdone: any plans on your IRC search website btw?
16:52:35 <wagle> aristid: it wont derive them
16:52:42 <wagle> right
16:52:55 <aristid> data (Eq a, Ord a, Enum a, Bounded a) => Wild a = All | Any a  deriving (Show, Eq, Ord)
16:53:00 <aristid> remove the constraints in that line
16:53:13 <aristid> that won't help you here, but constraints on data are discouraged
16:53:38 <aristid> wagle: and seeing them there just drives me nuts, so i had to mention it
16:53:40 <wagle> oh yeah, artifact from previous version, thanks
16:55:23 <aristid> wagle: so, does it work now?
16:55:27 <aristid> @index asTypeOf
16:55:28 <lambdabot> Prelude
16:55:39 <aristid> wagle: i proposed a fix, after all!
16:55:57 <wagle> currently broken, figuring out why
16:55:59 <chrisdone> copumpkin: Erm, I could do it tomorrow. I'd need to have it connect to the channel directly to be up to date and allow 'context in irc' in hpaste, and also for it to pull from tunes.org in case it gets disconnected and misses some messages. Then writing a web interface is cake.
16:56:11 <copumpkin> yeah
16:56:34 <ddarius> copumpkin has a reasonably nice kitchen cupboard.
16:57:01 * chrisdone ponders an unreasonably nice kitchen cupboard
16:57:16 <ddarius> chrisdone: One that you could actually spend the night in.
16:57:23 <copumpkin> :D
16:57:31 <copumpkin> I think it might be a little small
16:57:33 <wagle> aristid: seems to work now, thanks
16:57:37 <copumpkin> well, unless chrisdone is very small
16:57:51 <aristid> wagle: asTypeOf to the rescue :)
16:57:53 <ddarius> copumpkin: Good job not making assumptions.
16:57:58 <wagle> @hoogle asTypeOf
16:57:58 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:58:07 <wagle> ahahaha
16:58:20 <aristid> wagle: asTypeOf = const
16:58:41 <wagle> yeah, hence my laughter
16:58:42 <chrisdone> copumpkin: Well, I'm not picky, as cupboards go. I'm not a connoisseur of sleeping cupboards. I won't be making rude remarks about the interiors. Or would I.
16:59:02 * ddarius wonders if he did actually finally finish Claudio Hermida's thesis or if he's just moved the pause point later on.
16:59:11 <chrisdone> copumpkin: Will you have some use for an IRC searching thing?
16:59:16 <djahandarie> Don't do it copumpkin, chrisdone'll trash your cupboard!
16:59:25 * ddarius has only seen the exteriors of copumpkin's cupboards.
17:00:33 <ddarius> Bah, no, I haven't finished Hermida's thesis.
17:00:59 <confound> when I find myself wondering what something ungoogleable like '$=' is, what's a good way to find out?
17:01:08 <chrisdone> djahandarie: I'll be bringing all the American women in there and someone will cry "TOGA PARTY" and we'll use his kitchen towels
17:01:27 <djahandarie> Haha
17:01:33 <djahandarie> @hoogle ($=)
17:01:33 <lambdabot> No results found
17:01:33 <chrisdone> confound: FWIW Google Code Search lets you search stuff like that.
17:01:37 <napping> chrisdone: in code?
17:01:52 <napping> that is, in a particular module that compiles?
17:01:55 <copumpkin> :)
17:02:02 <djahandarie> All these 'c's in here sure get confusing
17:02:05 <napping> if so, :info in ghci will tell you where it's from
17:02:17 <confound> napping: did you mean to address me?
17:02:28 <napping> confound: yeah, that's right
17:02:34 <Kaidelong> @src asTypeOF
17:02:34 <lambdabot> Source not found. I feel much better now.
17:02:34 <ddarius> djahandarie: Just set up a TCP level proxy between you and the Internet that filters out all 'c's.
17:02:36 <Kaidelong> @src asTypeOf
17:02:37 <lambdabot> asTypeOf = const
17:02:44 <Kaidelong> excellent
17:02:46 * chrisdone thought napping was continuing the toga party joke
17:02:48 <Kaidelong> so it's just specialized const
17:02:48 <confound> chrisdone: yes, which will direct me to other uses in code, not tlel me what it is
17:03:10 <Kaidelong> what would asTypeOf do that you can't do with a type signature?
17:03:13 <chrisdone> confound: I did qualify with FWIW! ;-)
17:03:19 <napping> confound: ghci's :info will direct you to the defining module
17:03:30 <napping> which probably has a searchable name (and a package)
17:03:33 <ddarius> Kaidelong: Nothing with lexically scoped type variables.
17:03:56 <Kaidelong> oh I guess if you don't know exactly what type something is
17:03:56 <Kaidelong> other than that it is the same as another type
17:04:04 <confound> it's not defined by the module that runs, it's just used by it.
17:04:04 <ddarius> Kaidelong: Otherwise it's a way to say two things have the same type when the variables are rigid but not instantiated.
17:04:07 <napping> Kaidelong: well, it lets you force two things to have the same type without writing out the whole type
17:04:17 <napping> not that it's often used like that
17:04:31 <ddarius> asTypeOf is not often used period.
17:04:51 <ddarius> It's not even that great at what it is intended.
17:05:06 <Kaidelong> hmm, seems like most of the time, asTypeOf would be made unneccessary
17:05:14 <Kaidelong> by the context
17:05:22 * hackagebot funsat 0.6.2 - A modern DPLL-style SAT solver  http://hackage.haskell.org/package/funsat-0.6.2 (DenisBueno)
17:05:33 <Kaidelong> although perhaps some extensions to haskell make it more useful
17:06:14 <confound> so what is $= ?
17:07:28 <ddarius> It's writeIORef (or something like that, writeStateVar or whatever.)
17:07:40 <confound> ah
17:08:42 <confound> thanks
17:09:31 <aristid> @hoogle ($=)
17:09:31 <lambdabot> No results found
17:09:36 <aristid> @hoogle $=
17:09:37 <lambdabot> No results found
17:16:38 <monochrom> $= is in the haskell OpenGL library
17:19:56 <confound> was there a good way for me to find that?
17:20:31 <drynish_> hello
17:20:37 <drynish_> I'm learning Haskell
17:20:38 <confound> monochrom: where do you see it defined?
17:22:31 <geheimdienst> confound: hayoo finds more things than hoogle
17:22:35 <geheimdienst> @where hayoo
17:22:36 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:23:03 <confound> geheimdienst: it doesn't find $=
17:23:12 <geheimdienst> yeah, i just noticed :-/
17:23:17 <monochrom> I just read the docs of haskell opengl
17:24:22 <monochrom> Graphics.Rendering.OpenGL.GL.StateVar
17:25:16 <Hugglesworth> chrisdone: they're talking about you in #jbopre; much confusion is ensuing
17:25:26 <confound> am I going crazy? my OpenGL-2.4.0.1 has no StateVar.hs
17:26:11 <confound> and no definition for $=
17:26:43 <confound> note that I've been writing haskell for like 3 days so I may be overlooking something obvious.
17:27:59 <monochrom> oh ha, 2.4.0.1 outsources that to http://hackage.haskell.org/package/StateVar-1.0.0.0
17:28:55 <confound> aha, thanks
17:29:01 <monochrom> I just use Haskell Platform and it is still at OpenGL-2.2.3.0
17:39:13 <wagle> Kaidelong: in my example, asTypeOf was need because only the return type of fromEnum was constrained
17:39:22 <wagle> needed
17:40:11 <wagle> hmm..  now i'm confused
17:41:59 <napping> why did you need asTypeOf to contstrain the return type?
17:43:36 <aristid> napping: he needed to constrain a parameter to fromEnum
17:43:40 <aristid> :t fromEnum
17:43:41 <lambdabot> forall a. (Enum a) => a -> Int
17:43:50 <aristid> note how the a is lost after fromEnum
17:44:05 <thatBlueThing> I'm experiencing some strange behaviour with Cabal: my package's .cabal file is at https://gist.github.com/845842
17:44:23 <thatBlueThing> and yet, Setup.hs configure yields: Setup.lhs: At least the following dependencies are missing:
17:44:23 <thatBlueThing> graphviz -any, hunit -any
17:44:28 <wagle> napping: the Bounded instance for the maxBound hasnt happened yet
17:44:43 <wagle> i think that's what's going on
17:45:00 <thatBlueThing> graphviz + hunit are both installed; and ghci, runhaskell etc. recognize them, though cabal does not; am I missing anything obvious?
17:45:16 <thatBlueThing> I'm on OSX with the latest haskell platform installed
17:45:26 <thatBlueThing> same results with ubuntu 10.10
17:45:44 <wagle> thatBlueThing: are you installing or upgrading?
17:46:00 <Saizan> thatBlueThing: --user
17:46:11 <byorgey> thatBlueThing: are graphviz + hunit installed globally or locally?
17:46:27 <Saizan> also, case-sensitivity
17:46:34 <thatBlueThing> Saizan byorgey: thanks it was the local vs global issue
17:46:55 <byorgey> thatBlueThing: also, don't call Setup.hs explicitly, do 'cabal configure' or 'cabal install' or whatever
17:47:14 <thatBlueThing> byorgey: thanks; is there documentation of the difference anywhere?
17:48:08 <byorgey> I'm not sure, maybe look in the Cabal documentation
17:48:10 <hskltyp> Library X is LGPL. If I distrubte the _source_ code of X along with my app, then my app, at run time, parses the source of X to extract certain data (and builds internal data structuers) -- is this legal?
17:48:16 * wagle is confused again
17:48:36 <byorgey> but the idea is that cabal will run Setup.hs for you, but also do other smart things like resolve dependencies etc.
17:48:45 <wagle> if casting to :: a doesnt work, how can asTypeOf work?
17:49:31 <byorgey> wagle: using a type annotation like  :: a will only work if 'a' is in scope
17:49:48 <byorgey> wagle: and it probably isn't unless you turn on ScopedTypeVariables and add 'forall a.' to the type signature
17:49:49 <wagle> its on the instance line
17:49:59 <dibblego> using a value like 'a' usually won't work due to type variable scope
17:50:15 <wagle> wacky
17:51:24 <hpc> also, asTypeOf doesn't use the scope of the type
17:51:29 <hpc> it uses the scope of a value of that type
17:52:47 <hpaste> wagle pasted "current example"  http://hpaste.org/44335
17:53:50 <wagle> i still think it couldnt see the definition of maxBound from the instance for Bounded (WIld a)
17:53:54 <byorgey> ooh, the hpaste bot is back!
17:54:14 <wagle> takes it about 30-45 seconds to announce, though
17:54:58 <wagle> maybe using asTypeOf delays the unification to the last moment
17:55:21 <Saizan> no
17:55:26 <wagle> whereas instance declarations are more eager
17:55:29 <Saizan> it's as we explained
17:56:11 <Saizan> and instance declarations are all in scope when checking the others
17:56:16 <wagle> thats not what the error was saying
17:56:47 <wagle> but it was hard to understand, so...  sigh
17:56:48 <Saizan> the error was referring to a different 'a'
17:57:36 <Saizan> or better, the a in your :: Wild a annotation wasn't understood to be the same a as the one in the instance head, but rather a fresh one
17:58:01 <wagle> the asTypeOf kludge allowed me to make a dynamic type error..  whats the way to do it with scopedtype variables and forall?
17:58:29 <hpc> asTypeOf is completely static
17:58:33 <wagle> Saizan: ahhh  a fresh one, that makes sense
17:58:38 <Saizan> dynamic type error?
17:59:29 <wagle> it compiled with Any (maxBound `asTypeOf` b)
17:59:57 <hpc> dynamic type errors require dynamic types
18:00:03 <hpc> which... can't happen in haskell
18:00:09 <hpc> without some serious effort
18:00:09 <wagle> but that led to it running off the end of the maxBound
18:00:21 <koninkje> wagle: where's this code?
18:00:45 <Saizan> http://hpaste.org/paste/44335/current_example_annotation#p44336 <- anyhow, this should work
18:01:11 <wagle> the bounds for enum type HAPPEN AT RUN-TIME
18:01:43 <Saizan> yeah, "dynamic error" would make sense there, dynamic type error not so much
18:01:51 <ddarius> Robert Harper repeats himself a lot.
18:02:08 <Saizan> oh, ops, change the `asTypeOf` b to the type annotation, of course
18:03:27 <dankna> so!
18:03:47 <dankna> I am writing a package to be, essentially, utf8-strings but for all common variants of Unicode instead of just UTF8
18:04:11 <Saizan> for String?
18:04:15 <dankna> for ByteString, no
18:04:43 <Saizan> seen text/text-icu?
18:04:44 <dankna> in my initial design, I had packages Data.ByteString.* and same-named ones Data.ByteString.Lazy.*, for * an element of { UTF8, UTF16.BOM, UTF16.BE, UTF16.LE, UTF32.BOM, UTF32.BE, UTF32.LE }
18:05:08 <dankna> yes.  Michael Snoyman benchmarked text as being about 1.5 times slower than bytestring for high-performance stuff.
18:05:17 <dankna> I have no idea why that is but I don't desire to use text for the moment
18:05:53 <copumpkin> cause processing text is harder than just treating things as arrays of characters
18:06:24 <ddarius> s/characters/bytes
18:06:33 <dankna> well, yes, it is, but with the utf8-strings approach, which is also my approach, you only incur that penalty for operations that treat it as character-like
18:06:37 <copumpkin> even arrays of characters
18:06:49 <chrisdone> ddarius: Even array of characters doesn't map well to all languages?
18:06:59 <dankna> I should note that Snoyman's test was simply concatenating and blasting them over the network
18:07:19 <dankna> (it was an http performance test)
18:07:43 <copumpkin> well, considering that network performance is probably eating a huge chunk of the time there
18:07:54 <dankna> well, no, let me point you to the benchmark if you're curious
18:08:09 <dankna> http://docs.yesodweb.com/blog/bigtable-benchmarks
18:08:31 <dankna> I had misremembered the numbers, it's actually dramatically worse than that
18:09:30 <dankna> so now that I've justified my package's existence, on to discussing its design :)
18:10:10 <wagle> example of dynamic type error here: http://hpaste.org/paste/44335/current_example_annotation#p44337
18:10:35 <dankna> I had initially included UTF{16,32}.{BOM,LE,BE} in the list of modules to be written, on the theory that the BOM variants would behave like the BE and LE variants but require a byte-order-mark at the start of the string
18:10:39 <dankna> this turns out not to be practical
18:10:51 <dankna> as I hadn't thought of what happens when you take a substring
18:11:06 <dankna> bytestring doesn't copy when you do that, but this would have to, for a big performance penalty
18:11:10 <Saizan> you may want to ask bos, iirc there has been a recent release of text that got quite faster, but go on
18:11:21 <dankna> Saizan: I'll look into it, yes.
18:11:50 <dankna> so instead I just want to provide a function detectBOM :: ByteString -> Endianness or something of the sort
18:12:23 <dankna> but now I'm into the world of explicitly passing the encoding, rather than implicitly choosing it by your choice of package to import
18:12:35 <dankna> so it makes sense to design an interface that lets you explicitly pass it
18:12:56 <dankna> maybe just Data.ByteString[.Lazy].Unicode for the module name for that interface?
18:13:21 <dankna> I think it still has some value to have the implicit interfaces too though
18:13:54 <dankna> but I'll rename UTF{16,32}.BOM to just UTF{16,32} I guess
18:14:05 <dankna> hmm
18:14:07 <dankna> now, let's see
18:14:14 <dankna> I think I want a few different variants
18:14:21 <napping> wagle: I think that's the wrong enumFrom
18:14:33 <napping> or, not enough of them
18:14:39 <dankna> data Encoding = UTF8 | UTF16 Endianness | UTF32 Endianness ; data Endianness = BigEndian | LittleEndian
18:15:11 <wagle> http://hpaste.org/paste/44335/current_example_annotation#p44338
18:15:11 <Twey> Doesn't UTF-8 have endianness?  :þ
18:15:15 <dankna> Twey: no
18:15:21 <dankna> Twey: cf. Wikipedia for explanation
18:15:47 <wagle> napping; right, the Any shouldnt be there on the last line, but it compiles and barfs if you put it there
18:15:51 <dankna> and then I want sets of functions like
18:15:56 <dankna> :: Encoding -> *
18:16:18 <dankna> those ones will be in Data.ByteString[.Lazy].Unicode
18:16:34 <dankna> and then in each of the pacakges Data.ByteString[.Lazy].UTF{16,32} I will put functions like
18:16:37 <dankna> :: Endianness -> *
18:16:49 <Saizan> wagle: why do you think the type system is in any position to prevent that?
18:17:08 <dankna> and then, too, in each of the packages Data.ByteString[.Lazy].{UTF8,UTF{16,32}.{BE,LE}}, I will have functions with types that are just
18:17:09 <dankna> :: *
18:17:12 <napping> wagle: which code had the error?
18:17:16 <dankna> where * stands in for all the other parameters the function has
18:17:24 <dankna> I guess I solved my design problem in the course of asking my question
18:17:28 <napping> oh, it's in the paste
18:17:29 <wagle> Saizan: i cant break it with the scoped typed vars
18:17:30 <dankna> but does this seem like a sane design to people?
18:17:38 <Saizan> wagle: sure you can
18:17:54 <Twey> dankna: It's not very informative
18:18:00 <dankna> how do you mean?
18:18:15 <wagle> Saizan: not with my thinko, you cant
18:18:26 <Twey> It just says ‘UTF-8 avoids the confusion of endianness’ without really explaining why.
18:18:36 <Saizan> enumFromThen b c = map toEnum [fromEnum b, fromEnum c .. fromEnum (Any (maxBound :: Wild a))]
18:18:38 <wagle> napping, its in the middle of my last paste
18:18:40 <napping> wagle: you should provide enumFrom as well
18:18:44 <dankna> oh.  sorry, you meant the Wikipedia page.  yeah.  well it's like this.
18:19:00 <dankna> in UTF32, the encoding is one codepoint maps to four bytes, so you have to know what order to take those bytes in
18:19:08 <Twey> Right
18:19:11 <napping> wagle: [Any P1 ..] will certainly run over
18:19:22 <dankna> in UTF16, the encoding is one codepoint maps to /either/ two bytes or four bytes (so-called surrogate pairs), depending on the codepoint.
18:19:42 <wagle> napping, thats what i get for not exhaustively testing..  
18:19:43 <dankna> they have worked out the subtleties such that you can always tell by looking at any two consecutive aligned bytes, whether it's part of a 2-byte sequence or a 4-byte sequence
18:19:55 <dankna> so again, endianness applies
18:20:03 <Twey> Right
18:20:45 <dankna> in UTF8, the encoding is that one codepoint maps to anywhere from one to (I think) five bytes.  when decoding, you start by examining the high bits of each byte.  if they match the pattern 10xxxxxx, you have a byte which is a "continuation", and can never be the first byte of a character.
18:20:46 <napping> wagle: it's not so clear in the docs, but none of the enumFrom* methods are defined in terms of any of the rest
18:20:51 <dankna> otherwise, the high bits tell you how many more bytes follow.
18:21:07 <napping> well, at least not in GHC's version
18:21:19 <napping> you could try rather providing enumFrom x = enumFromTo x maxBound
18:21:20 <wagle> napping: i chose the one without the implicit defn
18:21:36 <dankna> so endianness doesn't really apply because you're viewing it as a stream of byte-sized units
18:21:54 <napping> and enumFromThen x y = enumFromThenTo x y maxBound as suggested by the docs
18:22:07 <dankna> it's effectively always big-endian
18:22:27 <dankna> you could define a little-endian version but it would be convoluted and would not meet a real need because you can't read aligned chunks of bytes anyway, because of the variable-length nature of it
18:22:38 <dankna> does that help, twey?
18:22:59 <Twey> Yep
18:23:01 <dankna> great
18:23:09 <Twey> Basically, endianness is standardised
18:23:14 <dankna> yes, that's true
18:23:16 <napping> wagle: where did you read that some don't have defaults?
18:23:55 <napping> wagle: enumFromThen needs to be defined a bit better than I wrote, in case the second point is less than the first
18:24:20 <wagle> http://zvon.org/other/haskell/Outputprelude/Enum_c.html
18:24:41 * wagle is staring at the code again
18:24:52 <napping> that's just wrong
18:24:58 <napping> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Prelude.html#t:Enum
18:25:20 <napping> it's enumFrom and enumFromThen that need to be given if you have a bounded type
18:25:55 <napping> actually, you should also give them if you have a type with more members than Int
18:26:38 <wagle> napping: ah thanks
18:28:44 <wagle> Saizan: i'm defensive because so many people around portland insist dogmatically that haskell has no dynamic type errors, when its got plenty..  (it just has a LOT of things avoided with the static type thing)
18:28:55 <napping> hmm?
18:29:16 <wagle> it calls error plenty
18:29:27 <napping> A haskell type isn't the sort of thing that can appear at runtime
18:29:39 <napping> errors, sure
18:30:00 <wagle> scheme dynamic type errors arent type errors then
18:30:05 <napping> nope
18:30:12 <napping> not Haskell type errors anyway
18:30:22 <rwbarton> the word "type" means something entirely different in scheme and haskell
18:30:27 <dolio> All dynamic type errors aren't type errors. :)
18:30:27 <wagle> butbut scheme is dynamically typed!
18:30:27 <napping> (well, you can break the type system with unsafeCoerce# if you like)
18:30:34 <dolio> Because dynamic 'types' aren't types. :)
18:30:56 <napping> There's not actually any standard definition of "dynamic type"
18:31:19 <wagle> yeah, i know the types are wholy different, but being from indiana, i am continuously made fun of for scheme's "dynamic typing"
18:31:48 <dibblego> what does it mean to be made fun of because of scheme's dynamic typing?
18:32:46 <wagle> "scheme has dynamic type errors, haskell doesn't becausee its statically typed"
18:33:02 <dibblego> haskell is a non-total language, this is not a secret
18:33:13 <napping> scheme can have runtime errors involving the things it calls type
18:33:20 <dibblego> neither scheme nor haskell has dynamic type errors
18:34:07 <wagle> if scheme has dynamic type errors, then so does haskell (plenty still, but much less)
18:34:14 <dibblego> which it doesn't
18:34:24 <wagle> well, ....  duhg
18:34:29 <dibblego> you are simply saying that haskell is non-total
18:34:33 <wagle> my point
18:34:44 <dolio> You can have dynamic errors in Haskell like, "expected Left, but got Right". But we don't say that 'Left' is a type.
18:34:50 <dibblego> perhaps stop saying dynamic type errors? no such thing
18:34:53 * wagle ponders "non-total"
18:34:56 <dolio> Scheme uses the same dynamic checks to catch errors that Haskell prevents with types.
18:35:25 <pikhq> wagle: All Turing-complete languages are non-total, BTW. It's, uh, kinda inherent in being TC.
18:35:26 <wagle> haskell prevent SOME of them (a LOT of them?) with types
18:35:31 <dibblego> agda has no runtime errors
18:35:35 <napping> wagle: conversely
18:35:58 <napping> There is a class of imaginable errors that Haskell prevents from ever occuring at runtime
18:36:07 <napping> and some of these are called type errors
18:36:11 <wagle> dibblego: neat
18:36:15 <napping> (others are called syntax errors, etc)
18:36:36 <dibblego> wagle: also see what pikhq said, this means that agda is not TC
18:37:14 <wagle> dibblego: yeah, i figured its recursion was crippled in the usual way
18:37:16 <dolio> I didn't say that Haskell's types prevent all type errors. I said that Scheme uses dynamic checks to catch the errors that Haskell prevents with types.
18:37:18 <napping> When the things that you call types have this useful property, you should really avoid losing the usefulness of the definition by trying to include other things
18:37:26 <dolio> Or, prevent all errors.
18:37:34 <Philippa> does agda do corecursion?
18:37:41 <napping> wagle: Agda's recursion isn't particularly crippled
18:37:48 <dolio> They prevent all type errors for a correctly defined class of type errors.
18:37:59 <dolio> (Barring unsafeCoerce.)
18:38:02 <napping> Philippa: they've got some sort of coinduction. It's slightly experimental
18:38:45 <wagle> napping: ok..  i've been meaning to look at agda sometime..  maybe now sooner
18:39:18 <napping> wagle: the usual story with Coq and Agda and friends is that you can write any recursive function that is provably total
18:39:38 <napping> where "provable" is approximately "provable in normal mathematics"
18:40:06 <wagle> can you do streams?
18:40:10 <napping> Oh, Agda also lets you run programs that fail the automatic termination checker, if you like
18:40:27 <napping> It has coinductive types, yes
18:41:08 <napping> I don't think there are any programs other than interpreters that people usually write other than interpreters that are not total in the sense of productive corecursion
18:41:37 <wagle> i look at the isabelle (tutorial), and it briefly mentions coinduction and greatest fixpoints in passing..  not encouraging for me
18:41:57 <napping> I've never heard the Isabelle is actually useful for running programs
18:42:13 <napping> I don't think it's a type-theory based system - there's no way to "run" an isabelle proof
18:42:27 <wagle> people around here seem to proof programs "correct" with isabelle
18:42:32 <napping> yeah, that's different
18:42:37 <napping> you can write a proof that a program is correct
18:42:42 <copumpkin> wagle: around here being pdx?
18:42:56 <napping> but a "proof" in Coq or Agda is a function
18:43:03 <copumpkin> or just a value
18:43:12 <wagle> copumpkin: yeah, but dont take my word for it, i'm not well connected any more
18:43:23 <napping> I think a "proof" in Isabelle is like a proof tree or something
18:43:27 <copumpkin> oh, I know people are proving stuff in isabelle over in those there parts
18:47:13 <wagle> acl2 says it takes months to master acl2..  i figure the others are similar..  i'm trying to figure out which prover to learn/master first on my own time by myself so that I can see how to easily prove programs correct, prove category theory, and other mathematics, or maybe something else I havent thought of
18:48:47 <napping> wagle: (Any (Any P7)
18:48:48 <wagle> i did a denotational semantics for 3-Lisp long ago, but i used non-well-founded sets and greatest-fixpoints without knowing what they were (this is before even azcel's book)
18:48:54 <napping> That's the problem
18:49:05 <napping> right..
18:49:21 <napping> You wrote (fromEnum (Any (maxBound `asTypeOf` b))
18:49:26 <napping> but b already has type Wild a
18:49:41 <napping> the extra any makes it type Wild (Wild a)
18:49:51 <napping> then you get an extra succ in the fromEnum
18:49:54 <wagle> napping: yeah, i know..  i wanted to be prevented from writing that
18:50:06 <napping> ah
18:51:01 <napping> it seems like something that might be nice, yes
18:51:04 <wagle> asTypeOf seems kinda indirect/hackish, so I was blaming it, maybe erroneously
18:51:36 <wagle> wanted to say what I meant, which was maxBound :: a
18:51:36 <ddarius> wagle: Did you make a theory of non-wellfounded sets or did you just blithely say "well these should exist?"
18:52:11 <napping> unfortunately, using fromEnum to covert to Int forgets the original types
18:52:14 <wagle> ddarius: it was a class project, i didnt want to write a dissertation about it
18:52:42 <ddarius> wagle: I think writing a denotational semantics for 3-Lisp even today would be dissertation material.
18:52:43 <napping> going through Int, you obviously can't be warned about [fromEnum b, fromEnum c .. 1 + fromEnum (maxBound `asTypeOf` b)]
18:52:52 <wagle> so, "these should exist"..  no?  well let me do something different..  no?  aieeee
18:54:05 <wagle> ddarius: olivier pretended to do it, but avoided some heavy lifting..  several others havee written dissertations on reflection which I havent read
18:55:07 <napping> Well, one way you might tie it together is defining your enumFromThen in terms of your enumFromToo
18:55:20 <wagle> ddarius: I'm hoping to do it as part of a greater project where I REALLY UNDERSTAND WHAT I"M DOING NOW
18:55:35 <ddarius> Most of the ones I've seen fail to be compositional.
18:55:45 <napping> if you'd written enumFromThen a b = enumFromThen a b (Any (maxBound `asTypeOf` b)) would have seen a helpful error
18:56:32 <napping> I don't see how you could remember that ints were numbers for values from some Enum
18:58:06 <wagle> ddarius: nothing in my original semantics was non-compositional..  i just cant find it anywhere..  *laughs at /me*
18:58:40 <wagle> napping: any moment now i'll get back to staring at my code
18:59:24 <napping> well, maybe something like newtype EnumCode e = EnumCode Int deriving (Num,...)
18:59:47 <napping> but maybe too much machinery to work with
19:00:19 <napping> toEC :: (Enum e) => e -> EnumCode e, fromEC :: (Enum e) => EnumCode e -> e
19:01:10 <wagle> ddarius: whose semantics have you looked at?
19:03:08 <dolio> Good luck on the modeling category theory thing. :)
19:06:03 <napping> Is there any good reason GeneralizedNewtypeDeriving won't derive Enum?
19:06:20 <napping> I believe all newtypes have a constructor with argument, so the usual deriving can never apply
19:07:04 <Saizan> is it fair to say that smooth infinitesimal analysis replaces limits with infinitesimals?
19:07:28 <ddarius> wagle: The ones for Brown, Blonde, Black, Refci, and 3-LISP, though I don't think I read all of the 3-LISP thesis.
19:10:32 <napping> wagle: I attached some code
19:11:28 <napping> I don't know why the defaults are not more recursive
19:11:42 <napping> if the defaults were enumFrom x = enumFromThen x (succ x0
19:12:48 <napping> hmm, enumFromTo is still a bit tricky
19:13:20 <napping> enumFromTo x y = if fromEnum x < fromEnum y then enumFromThenTo x (succ x) y else enumFromThenTo y (succ y) x
19:14:11 <napping> with defaults like that, you could get by with just enumFromTo
19:14:19 <napping> enumFromThen, rather
19:14:33 <napping> well, it's really just the enumFrom instance that's unfortuante
19:14:46 <adamvh> If I'm getting a local compiler error trying to pull in a cabal package, is there any way that I can modify either the .cabal files or the source locally to get it going?
19:16:30 <dolio> > enumFrom maxBound :: [Int]
19:16:30 <lambdabot>   [9223372036854775807]
19:16:42 <dolio> > enumFromThen maxBound (succ maxBound) :: [Int]
19:16:43 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
19:19:55 <adamvh> Also, where does cabal stash cabal files?
19:21:32 <azaq23> ~/.cabal, don't know for windows.
19:22:55 <ddarius> Robert Harper is entertaining when he curses.
19:23:20 <adamvh> yeah, I just figured out that they live in the tarballs with the package sources
19:23:22 <adamvh> derp
19:24:09 <adamvh> Does cabal look at the local repository first?  So if I make some local changes to a library, it won't overwrite it with a copy from hackage?
19:25:16 <napping> If you give it a version number different from anything on hackage it will be treated as a different versin
19:25:28 <napping> I'm not sure what would happen if you left it with the same version number
19:25:53 <wagle> napping: this is going to take me a bit? 30-45 minutes?
19:26:45 <napping> wagle: what?
19:27:10 <wagle> napping: before i am able to respond to your work
19:27:17 <napping> oh
19:27:20 <napping> I might not be around
19:27:45 <napping> it's a pretty simple thing and excessive here
19:28:35 <adamvh> hmmm
19:28:43 <adamvh> maybe I should just report a bug...
19:31:18 <wagle> oic what i'm doing wrong
19:31:19 <napping> adamvh: if it has anything to do with editing the local version of a package it might not be a bug
19:32:01 <adamvh> No, I haven't edited anything at all - I was just considering do so that I could submit a patch if I got it working
19:32:30 <napping> I've kept a local version before, but I don't remember how I did it
19:32:46 <napping> Actually, I think I just unpacked the source elswhere, and built and installed it
19:32:56 <napping> so nothing to do with the cabal-install package downloading
19:33:55 <adamvh> No, I'm trying to cabal install Yesod, and it depends in some convoluted way on JSONb, which has a compiler error with GHC 6.12.3 (which is what's in the latest OS X Haskell Platform)
19:36:14 <adamvh> Something about a possible type ambiguity with Attoparsec - I figured it would be pretty easy to just write out the full type of whatever it doesn't like locally, and bug the JSONb guy(s)/gal(s) about it later
19:38:06 <CarpeUniversum> Greetings, internets.
19:45:59 <wagle> napping: wow, its NOT calling my enum functions
19:48:14 <CarpeUniversum> This tutorial is like a foreign language to a non programmer.
19:48:28 <djahandarie> CarpeUniversum, which one are you following?
19:48:42 <CarpeUniversum> Try Haskell
19:48:55 <augur> djahandarie: theres only one tutorial ever, its just written by lots of different people on lots of different topics!
19:49:05 <CarpeUniversum> I've recently become interested in trying out programming.
19:49:10 <djahandarie> CarpeUniversum, ah, that isn't really a full-fledged tutorial.
19:49:15 <CarpeUniversum> A friend linked this.
19:49:22 <augur> CarpeUniversum: try lyah
19:49:26 <augur> @faq lyah
19:49:26 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:29 <augur> whoops
19:49:30 <dibblego> @where lyah
19:49:32 <lambdabot> http://www.learnyouahaskell.com/
19:49:32 <CarpeUniversum> Yea, I understand, but it's kinda a sense.
19:49:41 <CarpeUniversum> lyah
19:49:43 <djahandarie> It's mainly targeted at people who want to pick up more languages.
19:49:57 <wagle> i had to define enumFrom
19:50:06 <djahandarie> LYAH is more fleshed-out, but it's still targeted at people who know at least one other programming language.
19:50:19 <CarpeUniversum> That's cool.
19:50:20 <augur> sicp!
19:50:23 <augur> @where sicp
19:50:24 <CarpeUniversum> I'm actually enjoying it anyway
19:50:24 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
19:50:24 <lambdabot> classes/6.001/abelson-sussman-lectures/>
19:50:25 <djahandarie> There is not really a good "learn programming using Haskell" tutorial yet.
19:50:30 <augur> watch the videos!
19:50:32 <CarpeUniversum> I just bought a full book on C++.
19:50:35 <CarpeUniversum> I'll get reading.
19:50:36 <augur> oh god
19:50:37 <augur> horrible
19:50:39 <augur> dont learn C++
19:50:44 <augur> avoid at all costs
19:50:53 <CarpeUniversum> oh my.
19:50:54 <augur> at least if you dont know at least 10 other better languages first
19:51:03 <CarpeUniversum> haha
19:51:06 <CarpeUniversum> how passionate a reply.
19:51:12 <roconnor> @pl (\g -> g id) . (.)
19:51:13 <pikhq> I doubt there is any single person who knows all of C++.
19:51:13 <lambdabot> id
19:51:17 <augur> C++ is what you get when you take a mediocre programming language and pee all over it.
19:51:30 <djahandarie> CarpeUniversum, the stuff augur just linked (SICP) is good for learning, though it is Scheme and perhaps not that useful in itself.
19:51:30 <CarpeUniversum> what should I start with, then
19:51:41 <augur> djahandarie: scheme is awesomely useful, you shut up
19:51:41 <djahandarie> Scheme is good for learning.
19:51:53 <djahandarie> Just realize that what you will learn from it is concepts.
19:51:55 <CarpeUniversum> I appologize, which should i start with
19:52:01 <CarpeUniversum> and is scheme a language?
19:52:05 <djahandarie> Yep.
19:52:11 <djahandarie> A dialect of LISP, if you've heard of that
19:52:11 <CarpeUniversum> copy all that then.
19:52:15 <CarpeUniversum> nope
19:52:28 <CarpeUniversum> Think of me as csomeone who knows computers can do anything.
19:52:37 <djahandarie> :P
19:52:38 <CarpeUniversum> and can get them to do anythign that someone else has already told them to do.
19:52:50 <djahandarie> Well the fact that you've found this channel means you're a step ahead of the game ;)
19:52:52 <DevHC> CarpeUniversum: C++ is THE BEST(TM) language to learn (even first)
19:52:52 <CarpeUniversum> but that's the end of my knowledge.
19:53:07 <CarpeUniversum> Bam.
19:53:14 <CarpeUniversum> knew i bought this book for a reason.
19:53:18 <CarpeUniversum> ( it was 5 cents)
19:53:19 <Bynbo7> DevHC: lol?
19:53:25 * ddarius would recommend HtDP and then CTM and then SICP.
19:53:35 <djahandarie> Nearly 95% of the people in this channel would disagree with that statement.
19:53:47 <djahandarie> And nearly 95% of statistics are made up but I'm pretty sure that one is accurate.
19:53:53 * ddarius would put at above 95%.
19:53:55 <DevHC> 99.99%
19:53:59 * Bynbo7 recommends WULA
19:54:01 <DevHC> including that^
19:54:02 <ddarius> I like C++, but I wouldn't recommend it as a first language.
19:54:09 <Bynbo7> (We Use Less Acronyms)
19:54:26 <DevHC> u didn't let me finish
19:54:37 <CarpeUniversum> Goodness me.
19:54:41 <napping> wagle: what? why is it not calling your functions?
19:54:41 <CarpeUniversum> Information overload.
19:54:54 <djahandarie> @quote glorious.stero
19:54:54 <lambdabot> No quotes match. My mind is going. I can feel it.
19:54:57 <ddarius> CarpeUniversum: The real question is what you want to get out of learning programming.
19:54:57 <djahandarie> @quote glorious.stereo
19:54:57 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
19:55:00 <napping> wagle: I used trace a bit, your example with the bug does call enumFrom like you should
19:55:04 <CarpeUniversum> Gonna read my C++ book, and cry softly for a little while. 
19:55:07 <DevHC> CarpeUniversum: but be sure to check out haskell after learning some C++... u'll get addicted to haskell
19:55:18 <DevHC> CarpeUniversum: which book?
19:55:21 <CarpeUniversum> I like it already, and I have no idea what it's doing :P
19:55:28 <wagle> napping its somehow deriving enumFrom
19:55:34 <CarpeUniversum> The book is called...
19:55:35 <CarpeUniversum> uhhh
19:55:36 <djahandarie> DevHC, I'm not sure masochism is the best way to get motivated.
19:55:37 <napping> what code are you looking at?
19:55:38 <CarpeUniversum> one sec, im looking for it.
19:55:46 <napping> wagle: there is a default definition of enumFrom, and you didn't provide your own
19:55:57 <napping> enumFrom is not defined in terms of enumFromThen
19:56:20 <napping> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/GHC-Enum.html#Enum
19:56:25 <CarpeUniversum> DevHC: The C++ Programming Language: Special Edition - Written by the guy who wrote C++
19:56:32 <napping> the default is enumFrom x             = map toEnum [fromEnum x ..]
19:56:33 <CarpeUniversum> or who engineered c++
19:56:34 <DevHC> ohshit
19:56:41 <wagle> napping: its not calling anything i'm defining unless i define enumFrom
19:56:43 <CarpeUniversum> or whatever it is you do to create a langiage.
19:56:48 <DevHC> that's going to be tough reading for a first language, IMO
19:56:57 <CarpeUniversum> Yea, I figured it might.
19:56:59 <pikhq> CarpeUniversum: I have my doubts that Stroustrup knows all of C++.
19:57:05 <CarpeUniversum> haha
19:57:12 <DevHC> pikhq: he doesn't
19:57:20 <pikhq> Seriously, the language is freaking impossible.
19:57:22 <DevHC> and he didn't write the book all himself, obviously
19:57:32 <CarpeUniversum> So, perhaps you'd like to link me to an equally (nearly free) book?
19:57:40 <DevHC> sure
19:57:46 <CarpeUniversum> that would work better, anyway
19:57:50 <DevHC> lemme send u a warezed book i've read :D
19:57:53 <CarpeUniversum> or even just name one, haha
19:57:55 * DevHC ducks
19:57:56 <pikhq> CarpeUniversum: You should tots learn Haskell.
19:57:59 * djahandarie still thinks that learning C++ first is a bad idea.
19:58:00 <CarpeUniversum> Sounds perfectly cheap!
19:58:10 <djahandarie> pikhq, there really is no good tutorial for learning Haskell as a first language
19:58:33 <djahandarie> As a first functional language, LYAH is good.
19:58:45 <pikhq> djahandarie: Oh, it's absolute first language?
19:58:53 <pikhq> CarpeUniversum: SICP. SICP. SICP.
19:58:55 <djahandarie> But when you aren't familiar with any computing or programming concepts at all, it isn't.
19:59:02 <djahandarie> pikhq, yeah, that's what has been recommended.
19:59:12 * ddarius thinks HtDP is more appropriate for a first language.
19:59:17 <pikhq> Or if you *insist* on a more "conventional" language, The C Programming Language, I guess?
19:59:28 * djahandarie hasn't read HtDP so cannot comment on that
19:59:31 <CarpeUniversum> I don't know if that's a language, or an acronym for something offensive, but I'm hearing it lots.
19:59:39 <pikhq> Though that doesn't teach you many concepts beyond what C consists of.
19:59:45 <djahandarie> CarpeUniversum, SICP is a tutorial for learning Scheme.
19:59:46 --- mode: ChanServ set +o copumpkin
19:59:50 <ddarius> djahandarie: Anyone who has a decent amount of experience in programming would find HtDP super slow and boring.
19:59:57 <CarpeUniversum> Gotcha
19:59:59 <pikhq> The Structure and Interpretation of Computer Programs.
20:00:26 <djahandarie> CarpeUniversum, and like I mentioned, it's mainly useful for learning concepts
20:00:33 --- mode: copumpkin set +b chocolaate-maan!*@*
20:00:37 <djahandarie> And they definition transfer to other languages
20:00:37 --- mode: copumpkin set -o copumpkin
20:00:42 <CarpeUniversum> So it IS an offensive acronym!
20:00:50 <CarpeUniversum> hah. 
20:01:04 <djahandarie> definitely*
20:01:14 <CarpeUniversum> where does one find.. SICP?
20:01:18 <napping> wagle: if you write [a,b ..] it will call your enumFromThen
20:01:19 <ddarius> djahandarie: There's nothing wrong with Scheme.  I can't see why you'd recommend Haskell over it with regards to "usefulness."
20:01:20 <djahandarie> @where sicp
20:01:21 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
20:01:21 <lambdabot> classes/6.001/abelson-sussman-lectures/>
20:01:37 <CarpeUniversum> @where sicp
20:01:37 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
20:01:37 <lambdabot> classes/6.001/abelson-sussman-lectures/>
20:01:47 <CarpeUniversum> AH neat!
20:01:57 <napping> wagle: but the default method you get if you don't provide your own, each of the enum* methids is defined seperates
20:02:08 <ddarius> @where htdp
20:02:08 <lambdabot> http://www.htdp.org/
20:02:12 <napping> in terms of fromEnum, toEnum, and then working with lists of integers
20:02:16 <djahandarie> ddarius, there is nothing wrong with scheme, but I feel like it doesn't have the same force or ecosystem behind it as Haskell does. CL seems to be miles ahead of Scheme in that area but CL kind of sucks.
20:02:28 <wagle> napping: yes..  i undefined ALL of them
20:02:28 <CarpeUniversum> TO be honest? I'm interested in programming with eventual goals in artificial intelligence.
20:02:36 <napping> wagle: undefined?
20:02:46 <wagle> commented them out
20:02:56 <djahandarie> CarpeUniversum, then stick with Scheme/Lisp, that's where a lot of AI stuff is.
20:03:00 <wagle> essentially
20:03:05 <djahandarie> Haskell is still figuring AI out. :)
20:03:06 <napping> oh, then it just has the defaults from the link
20:03:11 <CarpeUniversum> perfect
20:03:19 <CarpeUniversum> scheme/lisp
20:03:23 <CarpeUniversum> got it
20:03:32 <wagle> ok, i thought it defined some in terms of the others
20:03:32 <ddarius> CarpeUniversum: Regardless, if you are actually interested in programming seriously, you'll want to (and will, to some extent, whether you want to or not) learn multiple languages.
20:03:40 <napping> wagle: check that source.
20:04:00 <wagle> I did, its kinda underspecified, I thought
20:04:28 <napping> what?
20:04:34 <napping> that's the code GHC uses for Enum
20:04:43 <wagle> oh, there's something i missed
20:05:01 <wagle> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Prelude.html#t:Enum
20:05:07 <wagle> ?
20:06:09 <napping> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/GHC-Enum.html#Enum
20:06:13 <napping> is the source versin
20:06:31 <republican_devil> why does common lisp suck?
20:06:58 <napping> the zvon thing was quite wrong about what's a minimal implementation
20:07:26 <wagle> napping: hahaha..  luke is now using the source, and his mind is greatly clarified
20:07:37 <Bynbo7> because; it's too commmon and not elitist enough
20:07:37 <Bynbo7> filthy commoners
20:07:37 <ddarius> republican_devil: It's a grotty language, which the CL people will readily agree.
20:10:54 <augur> ddarius: question for you
20:12:22 <augur> if we say we have a function [0,succ] : 1 + N -> N, and a function [1,halve] : 1 + Q -> Q, and we say that id + f : 1 + N -> 1 + Q, and f : N -> Q
20:12:39 <augur> and we say that the diagram for that commutes, and that there is a unique f that makes this so
20:12:42 <wagle> napping :  http://hpaste.org/paste/44335/current_example_annotation#p44342
20:13:03 <augur> how is it that we determine that f(n) = 2^-n is the unique defition of f?
20:13:46 <augur> i mean, i know how we can show that that function is the unique definition
20:13:51 <augur> but how do we discover it?
20:14:29 <dankna> intuition, I think.
20:14:32 <dankna> but I don't know this problem area.
20:14:57 <dankna> if there were a technique in general for finding such things, it would be incredibly powerful, effectively a generic prover.
20:15:01 <ddarius> augur: The unique function given is foldNat 1 (/2) (which is 2^-n.
20:16:07 <dankna> I mean, there are recursive functions with no known closed form.  Plenty of them.
20:16:09 <augur> ddarius: but how do we discover this just from the laws? i mean, i guess its easy given [1,halve] : 1 + Q -> Q
20:16:56 <augur> but are there ways to figure out the structure of the function if we dont know the content, if we dont know that its [1,halve]?
20:16:58 <napping> wagle: why did you change to codes?
20:17:00 <ddarius> The initial algebra, which I'm assuming is what [0,succ] is here, is initial -because- the exists a unique algebra homomorphism from it to any other algebra.  Once you know that, then you can make up some notation for that function (I used foldNat.)  So the only question is showing [0,succ] is initial.
20:17:19 <wagle> to codes?
20:17:26 <napping> it's numbered from -1 now
20:17:40 <ddarius> augur: No.  [1,halve] is what is specifying the meaning at all.  Otherwise you don't have any reason to pick any function.
20:17:44 <wagle> i was changing stuff
20:17:49 <napping> also, you shouldn't need Ord, Eq, Show on a
20:18:02 <napping> at least not on the Enum instance
20:18:12 <napping> (Bounded a) => Bounded (Wild a)
20:18:16 <wagle> to see if i could find the problem..  the encoding of All WASNT the problem, but i left it
20:18:20 <augur> ddarius: ok. so then i guess i dont see how this is doing anything to elucidate induction at all
20:18:30 <napping> and (Bounded a, Enum a) => Enum (Wild a)
20:18:42 <augur> since the function [1,halve] : 1 + Q -> Q, and is therefore inductive to begin with
20:18:49 <wagle> I needed Show for error messages
20:18:56 <ddarius> augur: No it isn't.
20:18:59 <ddarius> It is
20:19:02 <napping> do you?
20:19:07 <wagle> Eq was just completeness
20:19:11 <ddarius> :t either (const 1) (/2)
20:19:12 <lambdabot> forall a a1. (Fractional a1) => Either a a1 -> a1
20:19:16 <ddarius> No recursion there.
20:19:18 <napping> the only error in the Enum instance is getting an out-of-bounds int
20:19:29 <napping> and then you don't have an 'a' to call show on
20:19:38 <wagle> error ("enumFrom " ++ (show x))
20:19:49 <augur> ddarius: what
20:19:50 <napping> what was that for?
20:20:07 <napping> I added a Show constraint temporarily so I could use Debug.
20:20:14 <napping> trace inside the instance
20:20:23 <augur> i mean, ddarius, it's as inductive as [0,S] is
20:20:34 <wagle> napping you are getting an error now?
20:20:45 <napping> but I don't think there are any useful errors for a final version that need a Show a constraint
20:21:01 <augur> the only difference is in what the base case and the non-base case is
20:21:03 <wagle> napping i agree
20:21:03 <ddarius> augur: That's true, [0,S] isn't "recursive."  The unique mediating algebra homomorphism given by initiality, i.e. foldNat, is what is "recursive."
20:21:16 <wagle> i agree about show
20:21:31 <augur> then im not seeing how this is explaining anything about induction
20:21:58 <augur> is it because we have foldNat for N, and we have this homomorphism, that together gives us foldQ?
20:22:10 <ddarius> augur: No.
20:22:21 <augur> :(
20:22:26 <augur> i dont understand this at all then
20:22:43 <ddarius> foldNat is all we have.  We can instantiate it to whatever algebra to get a recursive function, over naturals, with values in whatever the carrier of the algebra is.
20:23:18 <augur> ok but
20:23:19 <ddarius> By using F(X) = 1+X, we are only characterizing induction/structural recursion over the naturals.
20:23:28 <augur> then what is the point of this then
20:23:48 <augur> whats the point of having this arrow diagram
20:23:53 <augur> what does it tell me
20:24:00 <ddarius> Which arrow diagram?
20:24:33 <wagle> napping: http://hpaste.org/paste/44335/current_example_annotation#p44344
20:24:50 <augur> id + f : 1 + N -> 1 + Q      f : N -> Q      [0,S] : 1 + N -> N      [1,(/2)] : 1 + Q -> Q
20:26:01 <napping> that looks good
20:26:19 <augur> i mean, its a pretty diagram, and i guess its pretty true, but why the hell should i care about it. what does it tell me about f that i didnt already know
20:26:26 <wagle> thanks for help!
20:26:35 <ddarius> augur: A commutative diagram is a set of equations.  You've just listed some arrows.  The diagram is f . [0,S] = [1,(/2)] . (id + f) 
20:26:36 <napping> the bounded instance doesn't actually use Enum, but it might be good to still include it
20:26:50 <augur> also it commutes, ddarius, yes.
20:27:02 <napping> I don't think you will get much use out of the Bounded (Wild a) without Enum (Wild a)
20:27:17 <ddarius> augur: It characterizes f, (i.e. it -defines- f).  f is what you are being given.
20:27:24 <wagle> i think it wanted that..  will check
20:27:40 <napping> and this way just mentioning maxBound if your a is not Enum will give an error mentioning Enum
20:27:51 <augur> ddarius: but it doesnt _define_ it, since i already knew before hand what f was
20:27:57 <augur> i had to know f in order to get diagram!
20:28:08 <augur> thats the exact _opposite_ of a definition!
20:28:15 <napping> augur: you are reading it backwards
20:28:24 <ddarius> augur: No you didn't.  Initiality is what says that f exists and what it is.
20:28:33 <napping> augur: the diagram is saying for any functions you pick, you get an f
20:28:42 <augur> ddarius: actually i did. this paper gives f first, and then says look heres the diagram we can construct
20:28:46 <ddarius> You can also find an f and show it is equivalent, i.e. you can show that 2^-n is equivalent to foldNat 1 (/2) n
20:29:06 <augur> i can sort of guess how to go backwards from the diagram, but
20:29:20 <dankna> @pl \x -> not $ predicate x
20:29:20 <lambdabot> not . predicate
20:29:23 <dankna> oh, duh
20:29:24 <napping> wagle: I'm not sure how to make an instance that will work properly whether or not a is Bounded
20:29:59 <ddarius> augur: If you look at the equation I wrote, you can see (probably if you add points it will be easier) that it gives the normal recursive definition of foldNat (evaluated, here, at 1 and (/2)).
20:30:35 <augur> ddarius: the equation being f . [0,S] = [1,(/2)] . (id + f) ?
20:30:39 <napping> though, things made by mapping Any over lists build with a's Enum will work almost right, except for the exact choice of elements in enumFromThen All (Any x)
20:30:50 <wagle> a needs to be bounded to give a next value the enum of All
20:31:21 <napping> wait -- you don't know that fromEnum (minBound :: a) is zero
20:31:26 <napping> but assume it all over the place
20:31:43 <wagle> i do?
20:31:46 * wagle looks
20:31:58 <napping> how do you know you can't get (-1) from (fromEnum a)?
20:32:17 <napping> (you certainly could if a is Wild of something)
20:33:06 <wagle> yeah, i see this..  i was just trying to get Wild TPrio to work
20:33:34 <napping> maybe fromEnum All = fromEnum (minBound ::a) - 1
20:33:50 <wagle> maybe thats why my intuition left the -1 in
20:33:58 <augur> ddarius: ?
20:35:25 <ddarius> By Lambek's lemma, which is a simple property of initial (or terminal) algebras, we can invert the initial algebra [0,S] and get something which takes an n in N and splits it into either 0 or S(n'), i.e. a case on naturals.
20:36:10 <ddarius> So, f . [0,S] = [1,(/2)] . (id + f) <=> f = [1,(/2)] . (id + f) . [0, S]^-1
20:36:41 <augur> what is [0,S]^-1?
20:37:15 <ddarius> [0,S]^-1 is basically the function, \n -> case n of 0 -> Left (); (S n) -> Right n
20:37:21 <wagle> *Main> [All ..] :: [Wild (Wild (Wild TPrio))]
20:37:21 <wagle> [All,Any (Any (Any P0)),Any (Any (Any P1)),Any (Any (Any P2)),Any (Any (Any P3)),Any (Any (Any P4)),Any (Any (Any P5)),Any (Any (Any P6)),Any (Any (Any P7))]
20:38:03 <augur> so.. [0,S]^-1 = [0^-1, S^-1]?
20:38:05 <ddarius> [0,S] is \s -> case s of (Left ()) -> 0; (Right n) -> S n
20:38:13 <wagle> i didnt expect that to work, but i think i can still break it
20:38:32 <ddarius> augur: No, because N isn't explicitly a sum type.
20:38:51 <ddarius> And anyway, 0^-1 doesn't exist.
20:38:59 <augur> oh right ok
20:39:28 <augur> is there always an inverse like this?
20:39:44 <ddarius> Yes.  That's Lambek's lemma.  It's an interesting, but pretty simple exercise.
20:40:22 <augur> and how do we find them??
20:40:28 <ddarius> It's usually stated that the initial algebra, often written in, i.e. in :: F (mu F) -> mu F is an isomorphism.
20:40:53 <augur> also, i take it then that if this is a way of defining f, then the crucial bit is figuring out what the commutative diagram is, and what the relevant initial algebra is
20:41:07 <ddarius> The commutative diagram is always the same.
20:41:33 <augur> T(U) --T(f)--> T(V) ... etc
20:41:47 <augur> with f . a = b . T(f)
20:41:52 <augur> ya?
20:41:53 <ddarius> The crucial thing is showing whether the initial algebra exists or not, though for many categories relevant for programming, these initial algebras always exist.
20:42:07 <augur> ok.
20:42:11 <ddarius> augur: Yes, where a = in, is the (operation of) the initial algebra.
20:42:58 <ddarius> The fact that these initial algebras always exist for categories used for computing is why, the 'data' keyword has no side conditions.
20:43:25 <ddarius> But, to spell out the example, id + f is, in Haskell-land, id +++ f.
20:43:28 <ddarius> :t (+++)
20:43:29 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
20:43:34 <augur> so how do we find the inverse of these arrows, and are there interesting non-trivial examples?
20:43:35 <ddarius> We only need it at the function type.
20:44:27 <augur> im basically trying to learn the mathematics thats relevant to understanding the nature of inductive definability as a whole
20:44:42 <ddarius> augur: The inverse of in is easily calculated.  Proving that in is an isomorphism is a simple exercise that I recommend you do.  But the inverses will, for Haskell-like situations, always be a single layer of case-analysis.
20:44:55 <augur> to see how to approach questions like "are the monoids inductively definable", etc.
20:45:12 <copumpkin> might braided monoidal category also be called commutative monoidal category (i.e., the "monoid" is actually a commutative monoid)?
20:45:25 <ddarius> augur: Then initial algebras are what you want to look at.
20:45:56 <augur> im reading jacobs and rutten's A Tutorial on (Co)Algebras and (Co)Induction
20:46:13 <augur> at someones suggestion. i think copumpkin. lets blame copumpkin.
20:47:18 <copumpkin> :(
20:47:31 <augur> ddarius: really just, whats the book that will get me from nothing to understanding?
20:47:41 <dolio> Symmetric monoidal category is commutative.
20:48:31 <dolio> A (x) B ~ B (x) A
20:48:40 <copumpkin> oh, a symmetric monoidal category is a restricted braided monoidal category?
20:49:03 <copumpkin> looks like it
20:49:07 <dolio> Every symmetric monoidal category is braided, if that's what you mean.
20:49:12 <copumpkin> yeah
20:49:16 <copumpkin> it's braided with an additional requirement
20:49:22 <ddarius> augur: I doubt there's any one book.  There is a lot written about initial algebras, but mostly not in book form and rarely focused solely on initial algebras coming from nothing.
20:49:25 <copumpkin> I see, that makes sense
20:49:28 <dolio> Braided only lets you rearrange tensors of 3 objects as I recall.
20:50:44 <ddarius> augur: I would recommend Awodey for general category theory coverage, as at least the basics will be necessary.  There's a chapter by Jeremy Gibbons that's connects well with FP experience, but isn't intended to be general.  From there, for what you want, it would be papers.
20:51:52 <augur> ddarius: as a trivial example, do you think that this sort of math would be capable of providing a way to talk about the language defined by the function s(*) = [], s(x) = [a] ++ x ++ [b]
20:52:04 <ddarius> Yeah, symmetric is braided when the braiding is self-inverse.
20:52:19 <augur> its the simplest clean inductively definable language i can think of that also has a non-inductive definition
20:53:31 <ddarius> augur: That notation suggests that x is a list, but then what is *.  My first reaction would be it's, essentially, [].
20:53:43 <augur> oh man i dont know, you get the point tho :P
20:53:53 <augur> its suppose to generate the language a^n b^n
20:54:04 <augur> instead of the language 2^-n
20:54:49 <augur> {[], [a,b], [a,a,b,b], ...} instead of {1, 1/2, 1/4, ...}
20:54:51 <ddarius> You could definitely do that immediately, if you are taking a number with the framework above.  It would be foldNat [] (\x -> [a] ++ x ++ [b])
20:56:25 <augur> and the arrows for it would be    [0,S] : 1 + N -> N,   id + f : 1 + N -> 1 + S,   f : N -> S,   [[], [a]++_++[b]] : 1 + S -> S
20:56:29 <augur> commuting
20:56:30 <augur> ?
20:57:51 <augur> do you know of any ways of discovering what the algebras would have to be, given laws that we expect the algebra to satisfy?
20:58:01 <augur> this relates back to the are-monoids-inductive question
20:58:45 <Maxdamantus> :t void
20:58:47 <lambdabot> Not in scope: `void'
20:58:52 <Maxdamantus> @hoogle void
20:58:52 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:59:21 <augur> for instance, in this particular case, we could also describe the language as those s's that satisfy the laws   s = as ++ bs, length(as) == length(bs), listof(as,a), listof(bs,b)
21:02:01 <ddarius> augur: You'll want to look at T-algebras (monad algebras), Lawvere theories, and limits and colimits.
21:02:43 <augur> can i coax from you a brief description of each and explanation of why they're relevant? :x
21:03:13 <augur> ive been chasing topics for the last two weeks and i havent gotten any closer to understanding anything
21:04:29 <ddarius> augur: All of this is going to take longer than a "couple of weeks."  Some of this, like how initial algebras are commonly used in programming, aren't too bad, but even in the realm of just initial algebras you can go very deep.
21:04:54 <ddarius> And certainly little of the category theory stuff is going to make much sense without first understanding category theory.
21:05:17 <augur> im sure. i just want to know where to start (and why) on the question of what is inductively definable, and how to determine the inductive definitions from non-inductive ones
21:05:36 <ddarius> Lawvere theories allow you to describe algebraic theories by essentially say "I want these equations to hold."  And then it generates the actual things in a rather pretty way.
21:05:51 <augur> ok, that sounds spot on
21:05:56 <ddarius> T-algebras are closely related to F-algebras, they just have a bit more structure and they are used in a somewhat different way.
21:06:06 <ddarius> Limits and colimits are basic tools of category theory.  You can't avoid them.
21:06:37 <augur> right
21:06:45 <augur> ok. so i should be building up to lawvere theories
21:07:51 <adamvh> Man, Yesod projects take *forever* to compile...
21:08:46 <ddarius> Definitely initiality is the categorical way of doing induction, and it is quite flexible.  So it can probably do what you want, and if it can't, then what you want isn't really inductive or probably can't be done.  But knowing exactly how to instantiate the initial algebra framework can be mildly tricky for more subtle concepts.
21:09:20 <augur> ddarius: im sure.
21:10:18 <ddarius> Specifically, initial algebras give a notion of -structural- recursion, but the notion of structure can be rather rich.  Colimits can also lead to some "inductive" looking things (and in fact, a typical way to show initial algebras exists is to show that they are colimits of omega-chains.)
21:11:40 <ddarius> There's also the method of generators and relators in which you build up an algebraic structure syntactically and then impose the laws on it after the fact by quotienting.  This can be cast in a categorical light as well.
21:12:19 <ddarius> (Basically, as a coequalizer of a freely constructed algebraic structure.  A coequalizer being a particular kind of colimit.)
21:13:17 <augur> ok so these are techniques for constructing inductive definitions from non-inductive laws, then
21:13:44 <augur> and lawvere theories are one way of achieving this?
21:14:14 <copumpkin> augur: sounds like just what you want! pity it's hidden behind months/years of mathematical study :)
21:14:40 <augur> copumpkin: ive got caffeine and no social life. ill finish in a week!
21:14:46 <copumpkin> excellent!
21:15:09 <augur> also no boyfriend, so thats a plus!
21:15:13 <copumpkin> :)
21:15:50 <copumpkin> if your non-boyfriend were also a hardcore categorist, it might be a minus
21:16:09 <augur> my primary problem is not knowing _where_ to look. theres never any concise introduction to what seem to be well defined topics :\
21:16:21 <ddarius> A Lawvere theory is something like saying, "I want a type M.  And I'll add operations m : MxM -> M and e : 1 -> M.  And I want m(e,x) = x = m(x,e) for all x, and m(m(x,y),z) = m(x,m(y,z)) for all x, y, z."  And then you turn a crank and you get the category of algebras with that structure (in this case monoids) plus a decent chunk of metatheory.
21:16:23 <augur> hmm.. if my non-boyfriend were an X, would that mean my boyfriend would be a non-X?
21:16:58 <augur> ddarius: and i take it it can be operations of arbitrary complexity?
21:18:19 <ddarius> augur: They have to be of a particular form, for example, the laws defining the notion of "field" don't fit it, but there is plenty of generalization, called the theory of sketches, which allows much more complexity (including, along the way, fields which are a cocone theory.)
21:18:35 <augur> ok
21:18:40 <augur> so lawvere theories and sketches
21:18:41 <ddarius> (Actually, it's only one law that is problematic, namely 0 /= 1.)
21:19:06 <ddarius> Lawvere theories are special cases of sketches, but I doubt there's anything particularly introductory on sketches.
21:19:17 <args0> Why when I evaluate [0, 0.1 .. 1] on ghci, it gives some accurate and inaccurate values? thanks
21:19:18 <ddarius> If you want, you can smash your head against TTT again and again.
21:19:30 <augur> ddarius: TTT?
21:19:37 <ddarius> @google toposes, triples, and theories
21:19:38 <lambdabot> http://www.cwru.edu/artsci/math/wells/pub/ttt.html
21:19:38 <lambdabot> Title: Toposes, Triples and Theories
21:19:40 <augur> oh that
21:19:49 <augur> someone added ttt!
21:19:51 <augur> @where ttt
21:19:52 <lambdabot> Toposes, Triples and Theories: http://www.cwru.edu/artsci/math/wells/pub/ttt.html
21:20:01 <copumpkin> args0: that's an IEEE fundamental design issue
21:20:04 <ddarius> It's a good book, but it's not easy at all.
21:20:11 <copumpkin> args0: ghci just implements IEEE 754 floating-point arithmetic
21:20:14 <augur> after awodey's CT book, where should i head
21:20:17 <copumpkin> and floats can't represent 0.1 exactly
21:20:18 <ddarius> I've probably read through most of it at least five times.
21:20:38 <copumpkin> args0: as to why it shows the rounding error more than other languages might, it's just more honest than they are
21:20:51 <copumpkin> augur: did he already recommend the barr and wells lecture notes?
21:20:59 <augur> dunno!
21:21:25 <ddarius> Those are nice if you are aiming/wanting a CS/FP perspective.  Not as compelling from a linguistic perspective.
21:22:10 <ddarius> The calcfp notes by Jeremy Gibbons are even more CS-y but pretty easy to connect with Haskell and only cover initial(terminal) (co)algebras.
21:22:11 <augur> well, i dont know how compelling anything will be from a linguistic perspective, since the only "linguist" who does CT is lambek and then its just some boring stuff about morphisms from syntax to semantics
21:22:15 <copumpkin> augur appreciates CS
21:22:28 <copumpkin> don't you augur
21:22:33 <augur> very much so!
21:22:35 <args0> thank you copumpkin 
21:22:42 <ddarius> Lambek did some somewhat interesting stuff with an ordered linear logic.
21:22:43 <augur> i'd be a CS major if it werent for syntax
21:22:59 <augur> ill take anything that will get me towards lawvere theories and the like
21:23:05 <ddarius> @google Barr Wells ESSLLI
21:23:10 <augur> esslli!
21:23:15 <lambdabot> http://www.let.uu.nl/esslli/Courses/barr-wells.html
21:23:16 <lambdabot> Title: Courses: Barr / Wells
21:23:18 <augur> i want to go to esslli :(
21:23:32 <ddarius> @google Jeremy Gibbons calcfp
21:23:33 <lambdabot> http://code.google.com/p/cdbms/downloads/detail?name=acmmpc-calcfp.pdf&can=2&q=
21:23:33 <lambdabot> Title: acmmpc-calcfp.pdf - cdbms - Jeremy Gibbons chapter on algebreic data types in Ha ...
21:23:45 <ddarius> Odd link, but that should be it.
21:24:04 <augur> ahh yes. i was reading this the other day
21:24:41 <augur> a lot of it didnt make sense
21:25:07 <ddarius> Other than the relatively uncommon syntax for some things, it should all be reasonably straightforward.
21:25:15 <augur> i mean, some of it did, but at some point it just sort of fell off into huhhh
21:26:35 <ddarius> copumpkin: Going back to your earlier question, I'd probably consider symmetric monoidal category more appropriately called "commutative" than a merely braided one.
21:26:55 <augur> a lot of it didnt seem to be explanatory either tho. more descriptive. :\
21:26:59 <ddarius> Though the possible confusion is probably why they didn't use such terminology.
21:27:26 <copumpkin> ddarius: yeah, I see now
21:28:26 <augur> the universal properties seem to just materialize out of nowhere, and while they're trivial to show to hold, it seems kind of .. stipulative
21:31:31 <ddarius> It's taking a fairly "concrete" view.  Other than some sidebars, there's really only one (or two) universal property talked about.  Namely initiality (and terminality).  In fact, you could say initiality is the -only- universal property period (but that way leads to needing to define clever categories, if you want to see that view in action, read Fokkinga's work.)
21:32:58 <augur> ddarius: no no, i know that its pretty trivial, but the issue is that you have statements like fork (g,h) is the unique solution to exl . h = f, exr . h = g, etc.
21:33:16 <augur> and while its not hard to show this, its always nice to see how to _discover_
21:33:41 <ddarius> Yes, that is one of those sidebars.  And indeed that is a universal property (namely a limit.)
21:33:46 <augur> since the whole point of this isnt to sit around and feel good about the things we know, but instead to discover what we dont know
21:34:01 <augur> i suppose this chapter isnt supposed to be about how we discover new things in this framework, but
21:34:11 <ddarius> augur: That's not so much a thing to "discover" but a thing to "specify." 
21:34:36 <augur> well sure, but i mean, you _could_ discover it, presumably
21:34:44 <ddarius> And in fact, those equations (plus another) -gives- you fork.
21:35:23 <augur> i mean, defining fork by laws is nice, but you cant put laws into haskell, for instance
21:35:56 <augur> and for some laws, there are multiple solutions, so it's nice to know how to get from laws to solutions
21:36:21 <ddarius> In this case discovery would be, "Hey, I have this cool widget that I think is a product.  Let me check."  But you could also assert (or know from other things) that you have products and then you say "I'm asserting that fork is that thing which satisfies these laws."
21:36:46 <ddarius> augur: For universal properties, the laws characterize a solution uniquely up to unique isomorphism.
21:36:57 <augur> eh. but thats not quite giving you a case expression, is it?
21:37:13 <augur> well not a case expression in this situation, but
21:37:35 <augur> what you'd want is to get the definition for fork. fork = \(f,g) x -> (f x, g x)
21:37:46 <augur> or whatever. thats what you want to get out of this
21:38:01 <augur> here are some equations, crank the gears, and that falls out
21:40:26 <augur> i mean in the end i suppose thats just the question that led to lawvere theories earlier
21:40:30 <Polarina> Are there any complete OpenGL 4.1 bindings for Haskell?
21:40:47 <augur> but presumably for this its easier to do and doesnt require the lawvere theory idiom
21:42:09 <augur> and i feel like that secton of the chapter didnt really address that
21:42:11 <augur> not clearly, anyway
21:42:53 <ddarius> What "asserting to exist" would mean in a Haskell context for that would be defining: data Fork x a b = Fork (x -> a) (x -> b), then we can directly implement those equations exl (Fork f g) x = f x; exr (Fork f g) x = g x, and this does effectively produce something equivalent to fork (f,g) x = (f x, g x)
21:44:48 <augur> mm.. im not sure i see how
21:45:57 <ddarius> exl . Fork f g is the same as fst . fork (f, g)
21:46:50 <augur> true
21:47:23 <augur> but you have exl (Fork f g) x, defining exl as something that takes a fork and an x
21:47:28 <ddarius> Actually, it's not true, it's a type error, but essentially they encode the same information in different ways.
21:47:30 <augur> when in the paper, exl == fst
21:52:37 <ddarius> However, what I'm driving at is one way to look at these things is to take a syntactic view point.  When you see something like "there exists a unique f given such and such such that h . Ff = f . h" then 1) Skolemize, i.e. make a function that takes the "such and such" and produces the "f" and give it a name (I used "foldNat" above), and then 2) just treat it completely syntactically; the equations that characterize it
21:52:37 <ddarius>  are just reduction rules.
21:53:06 <augur> i guess this chapter addresses the issue later, since it says "assuming we can justify the universal property", and says before that something about doing so later in the chapter
21:53:52 <augur> ddarius: ok, i get the words, i just dont get the actions that they describe :P
21:54:27 <augur> ill continue with this gibbons chapter, and with the awodey book, and ill bug you some more along the way
21:54:52 <ddarius> Well there are two ways to use a universal property.  You can use it to generate operations by asserting they exist and then you can manipulate them essentially syntactically.  This is usually what you do when you don't have any particular category in mind.  Or, if you are working in a particular category, you can use them to help find or verify or show impossible these constructs.
21:55:46 <ddarius> For example, Haskell products aren't quite products because they fail the universal law that (fst p, snd p) = p.
21:56:37 <ddarius> (This would be fork f g = id in Gibbons chapter.)
21:56:49 <ddarius> Er fork exl exr = id.
21:57:03 <ddarius> (plus a different function application notation.)
21:57:58 <augur> whys it not true there?
21:58:47 <ddarius> > (() `seq` (fst undefined, snd undefined), () `seq` undefined)
21:58:48 <lambdabot>   ((*Exception: Prelude.undefined
21:58:58 <ddarius> Flipped my seq.
21:59:18 <ddarius> > ((fst undefined, snd undefined) `seq` (), undefined `seq` ())
21:59:19 <lambdabot>   ((),*Exception: Prelude.undefined
21:59:39 <augur> i dont follow
21:59:41 <ddarius> And.  Freakin' heck it's snowing again.
22:00:05 <ddarius> augur: The left component of that example is (), the right is undefined.  () /= undefined.
22:00:39 <ddarius> Therefore, (fst undefined, snd undefined) /= undefined
22:00:56 <augur> oh sure, but in this case obviously it doesnt matter
22:01:17 <augur> because for fork (fst, snd) == id to type check, it must be id :: (a,b) -> (a,b)
22:01:38 <augur> gibbons' id is id-for-pairs, obviously
22:01:47 <ddarius> undefined is a pair.
22:02:08 <augur> ok, id for pairs that arent undefined :P
22:03:14 <augur> if we include the possibility that you dont have termination then yeah, i guess we have problems, but i dont think thats an acceptable assumption given what gibbons is doing
22:03:15 <ddarius> augur: Well, the language Gibbons is using doesn't have _|_ (until later).  But Haskell has _|_ and the way (,) is defined leads to it failing the laws.
22:03:25 <augur> sure
22:03:33 <augur> but i dont think thats playing fair
22:03:44 <augur> since gibbons' laws are explicitly not about bottom
22:04:12 <augur> its like saying you're going to play chess and then chewing on your opponents queen as one of your moves
22:04:51 <augur> sure you could do it, but you're not playing chess anymore once you do
22:08:33 <augur> ddarius: brb
22:13:08 <ddarius> @tell augur I wasn't talking about Gibbons' language, however, Gibbons' laws are the -general- laws for categorical products in any category, including (as he does later) categories that model _|_.  Cast into a hypothetical category of Haskell types and functions, bottom has to be recognized and handled.
22:13:08 <lambdabot> Consider it noted.
22:18:17 <dolio> I picked that up when you said "Haskell products".
22:26:47 <mmaruseacph2> @pl f b x = map (g b) x
22:26:47 <lambdabot> f = map . g
23:00:43 <sinisa> Hi. I'm toying around and creating a ternary if operator. Part of this is "converting" various types (say, Strings and Nums) to Bools. I've declared a "Truthy t" class, which defines a "bool :: t -> Bool" function. I've made String and (Num a) instances of this class. But, I run into problems when trying the same with (Maybe a). GHC makes me pick whether I mean (Num a) => Maybe a, or perhaps Maybe String.
23:01:18 <sinisa> I'm trying to define one (Truthy (Maybe a)) instance and have it work for (Maybe String), (Num a => Maybe a) and others automatically.
23:01:20 <augur> ddarius: is it true to say that another way of defining monomorphism as saying that the arrows into its domain constitute a uni-graph?
23:01:20 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
23:01:41 <augur> where the domain only gets at most one arrow from other objects in the category?
23:02:28 <augur> f is a monomorphism if its domain gets at most one arrow from any other object in the category
23:02:41 <lpsmith> sinisa,  why not an   "instance (Truthy t) => Truthy (Maybe t) where ..."?
23:02:44 <augur> and f is an epimorphism if its codomain sets at most one arrow to any other object in the category?
23:04:36 <sinisa> lpsmith, thank you. I have no idea why I didn't think of that one. :)
23:04:54 <lpsmith> sinisa, if you want to define separate   instance Truthy (Maybe String) where... and instance (Num a) => Truthy (Maybe a)  instances,  you'll need some GHC extensions
23:06:12 <sinisa> lpsmith, yes, I didn't want them to be separate. (Maybe a)'s instance just does "bool (Just a) = bool a; bool Nothing = False". Again, thanks.
23:07:04 <lpsmith> sinisa, you are welcome
23:21:13 <hpaste> ivant pasted "sfh"  http://hpaste.org/44346
23:27:00 <mmaruseacph2> @pl f x y = [g x, h . j $ y]
23:27:00 <lambdabot> f = (. (return . h . j)) . (:) . g
23:41:09 <solrize> is there a way to rename an imported symbol like python's "from foo import bar as baz"?
23:41:53 <solrize> e.g. import Data.ByteString.Char8.pack as asciiToBin  doesn't work
23:42:14 <Veinor> I don't think you can do that, no
23:42:19 <solrize> oh well
23:45:21 <arcatan> I've sometimes done something like import qualified Data.ByteString.Char8 as DBSC; asciiToBin = DBSC.pack
23:52:36 <solrize> yeah, i've done that too
23:52:49 <solrize> there's also no way to put multiple modules in the same source file, right?
23:53:50 <arcatan> no, but you can re-export symbols from other modules if that helps
23:54:53 <arcatan> (or complete modules)
23:55:36 <solrize> yeah, i just want to encapsulate the internal fields of some data types w/o spewing separate files for every type like in java
23:56:22 <solrize> i guess i can put them in one module so they can mess with each other inside that module but not outside
