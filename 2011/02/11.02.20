00:00:58 <Makoryu> dark: In the example here, [Integer] is their state type
00:02:30 <dark> so actually I write a StateT the same way I write an State? Are all State A B automatically StateT A x B for all x?
00:02:47 <Makoryu> I don't quite get what you're asking
00:03:15 <dark> pop :: StateT [Integer] IO Integer
00:03:34 <dark> it could as well be typed: pop :: State [Integer] Integer
00:04:04 <Makoryu> dark: The State type, IIRC, is StateT Identity
00:04:36 <Makoryu> Where Identity is a "dummy" monad that doesn't actually wrap a type
00:04:40 <dark> but isn't the first parameter of StateT the state?
00:04:44 <dark> @src StateT
00:04:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:04:46 <rwbarton> "Are all State A B automatically StateT A x B for all x?" Yes, or rather you can transform them into one
00:05:04 <Makoryu> dark: Er, whoops, yes
00:05:26 <Makoryu> dark: It looks more like: "type State foo bar = StateT foo Identity bar"
00:05:48 <bradleyayers> what's the best web framework :) ?
00:05:58 <bradleyayers> yesod?
00:06:24 <dark> Makoryu, it seems they are completely distinct class, and both implement MonadStat
00:06:26 <dark> e
00:06:43 <Makoryu> dark: They're not classes
00:06:55 <dark> i mean, types
00:06:58 <dark> newtype State s a = State { runState :: s -> (a, s) }  , newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
00:07:22 <dark> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html
00:07:46 <dark> and http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Class.html for MonadState
00:07:49 <Makoryu> Guess I was mistaken!
00:11:33 <Makoryu> dark: Seems the functions I was thinking of are implemented using the MonadState typeclass... The effect is the same either way. Your code should wind up generic across both varieties of state monad
00:36:56 <dark> @hoogle ([a] -> Maybe a)
00:36:57 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
00:36:57 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
00:36:57 <lambdabot> Prelude head :: [a] -> a
00:37:29 <dark> @src Data.Maybe.listToMaybe
00:37:29 <lambdabot> Source not found. I am sorry.
00:37:57 <dobblego> \x -> case x of [] -> Nothing; (h:_) -> Just h
00:39:55 <dark> yes, was looking to see if some random combinator would be used for this
00:40:01 <dark> but no, http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Maybe.html#listToMaybe
00:58:26 <dobblego> heh my kids just discovered infinite lists
00:59:11 * hackagebot asn1-data 0.4.6 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.4.6 (VincentHanquez)
00:59:27 <dobblego> totally fascinated by mapM_ print [1..]
01:25:07 <AmunRa> Hello! I've been googleing around (probably bad searching) for some way to write functions that work for String and the various ByteString flavours
01:25:56 <AmunRa> something where I can split and join, replace, search, substring, repeat and perform all the usual string operations
01:27:01 <luite> there is the ListLike package on hackage
01:30:47 <AmunRa> Can't find anything called 'LikeList'
01:31:08 <gienah> dyslexia :-)
01:31:18 * hackagebot xml-enumerator 0.1.2.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.1.2.1 (MichaelSnoyman)
01:31:45 <gienah> its List then Like
01:33:12 <AmunRa> ohh dear.. that's happens when you try and switch your brain on without coffee in the mornin' :-)
01:34:19 * alpounet hands AmunRa some coffee
01:34:57 <alpounet> just made myself some to tackle a blog post from sigfpe
01:38:18 <AmunRa> thanks! that's better -- incidentally -- ListLike is quite a neat package, thanks for the pointer
01:40:37 <accel> having gone from idiot to expert; how do I go from expert to master of haskell ?
01:40:37 <lambdabot> accel: You have 1 new message. '/msg lambdabot @messages' to read it.
02:03:09 <jkramer> Ahoy
02:03:28 <accel> has anyone written an editor
02:03:30 <accel> that uses opengl
02:03:32 <accel> rather than curses?
02:04:49 <koninkje> djahandarie: Not generally, though you can see it at http://community.haskell.org/~wren/hetero-unification/src/Control/Functor/Fusable.hs
02:05:06 <koninkje> djahandarie: I haven't looked at it in a couple years
02:07:01 <Dae_> accel, a 3D text editor? That seems very futuristic
02:07:38 <Dae_> accel, on a more serious note, I'm not sure how well suited openGL is for the job? 
02:07:49 <opqdonut> opengl is very suited for 2d
02:08:03 <opqdonut> and font rendering
02:08:17 <accel> opqdonut++
02:09:04 <opqdonut> and using opengl will probably be a lot less painful than any of the ui toolkits
02:09:21 <alpounet> i wouldn't go that far
02:09:24 <opqdonut> maybe I should try it. my editor project stalled on curses+unicode
02:09:25 <alpounet> but it will certainly be efficient
02:09:41 <accel> do you guys now how tex fonts are stored?
02:09:43 <jkramer> I'm trying to install Cabal and cabal-installer using ghc-7.0.1 and I'm running in some dependency problems
02:09:50 <accel> i want to be able to render tex math equations
02:09:53 <accel> in my editor
02:10:00 <Dae_> Didn't mean to imply that OpenGL wasn't well suited for 2d, it's used in 2d games all the time after all. Just not sure  how suited it is for a text editor
02:10:04 <alpounet> jkramer, that's why you should wait for the next Haskell Platform version to be released :P
02:10:18 <jkramer> Oh
02:10:24 <Dae_> accel, hah, really? I've been working on doing something like that using the Cairo library
02:10:25 <jkramer> Which one should I use until then? :)
02:10:32 <accel> Dae_: screenshots / code ?
02:10:46 <alpounet> jkramer, well, let's say the Haskell "ecosystem" hasn't moved to the ghc 7 era yet
02:10:52 <jkramer> I installed 7.0.1 from my distributions ports, so I thought it was an official release
02:10:57 <alpounet> it is
02:11:27 <jkramer> Ok, going for the latest version from 6.* then
02:11:45 <Dae_> accel, it's very basic right now. Just calls latex with a system call, transforms the dvi to an svg and reads that in. You're welcome to get the code ofcourse, but it really is very basic
02:12:02 <accel> hmm; how do you do dvi -> svg ?
02:12:15 <accel> do you still ahve all the font info of base / height / ... in the svg ?
02:12:27 <accel> svg is an interesting way to "store" the font
02:12:57 <Dae_> I use dvisvgm. Again with a system call. It's not exactly a pretty solution
02:13:38 <Dae_> I think svg can do the font info, but it's not very robust
02:14:31 <accel> any idea how tex fonts are initially stored?
02:14:37 <accel> i.e. what format does Tex read the font in as
02:15:02 <Dae_> Metafont I think
02:20:22 <Dae_> accel, another way would be to follow the path of the python mathtex module, where the use a lot of different truetype fonts to render equations. It is however quite a lot of work
02:23:29 * hackagebot ghc-pkg-autofix 0.1 - Simple utility to fix BROKEN package dependencies  http://hackage.haskell.org/package/ghc-pkg-autofix-0.1 (HiromiIshii)
02:28:31 * hackagebot ghc-pkg-autofix 0.1.1 - Simple utility to fix BROKEN package dependencies.  http://hackage.haskell.org/package/ghc-pkg-autofix-0.1.1 (HiromiIshii)
02:30:46 <dark> all data representable in a computer is countable. so for every data type populated, one can "choose" a value from it. right?
02:31:04 <opqdonut> sure
02:31:31 * hackagebot ghc-pkg-autofix 0.1.2 - Simple utility to fix BROKEN package dependencies.  http://hackage.haskell.org/package/ghc-pkg-autofix-0.1.2 (HiromiIshii)
02:32:52 <dark> all data representable in a computer is countable. so for every data type populated, one can "choose" a value from it. right?
02:32:56 <dark> ops
02:32:59 <dark> suppose I have a function a -> (b, c) and I know a is populated. I want to get b by passing "any" a. if a is part of Enum I can just do (toEnum 0) and I choose whatever value
02:33:58 <dark> but String isn't o.o (and not because of fitting concerns. Double is likely to be larger than Int, and its description has some 'may overflow'..)
02:35:25 <HugoDaniel> i want to generate a haskell module file with haskell, what is the best way to do that ?
02:36:11 <c_wraith> Heh.  Any data type that's populated is countable, sure.  But that doesn't mean there's a distinguished element.  Just because it's countable doesn't mean anyone's actually created the mapping.
02:36:25 <paper_cc> dark: an Enum instance means that you assign some actual meaning to the fact that the type is countable
02:36:49 <opqdonut> c_wraith: well one can enumerate all the bit representations and take the first one
02:36:58 <dark> right i'm selecting ""
02:36:59 <c_wraith> like, you know how much of a pain it is to create the mapping for a type Integer -> Integer -> Integer?
02:37:02 <opqdonut> c_wraith: but sure, it's not feasible
02:37:20 <c_wraith> You can do it, sure...  It's painful, though.
02:37:36 <paper_cc> dark: (and an Enum instance for Double is arguably a good thing)
02:37:40 <paper_cc> > [1.2..4]
02:37:41 <lambdabot>   [1.2,2.2,3.2,4.2]
02:38:22 <dark> but I will use more complicated types. isn't there a "choice" function on haskell, provided by ghc itself - since it, all-powerful, has this information easily?
02:38:31 <dark> @hoogle choice
02:38:31 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
02:38:31 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
02:38:31 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
02:38:43 <c_wraith> dark: no, it doesn't have that information for function types.
02:39:17 <c_wraith> dark: you can't enumerate bit patterns and test each one to see if it's a total function with a valid type.  That runs into the halting problem.
02:39:19 <dark> oh I am sadisfied with types like strings, ints and ADTs...
02:39:37 <dark> c_wraith, there is a program here to find a function of a given type
02:39:45 <dark> but I suppose it doesn't always find one
02:39:58 <c_wraith> It does not.
02:40:08 <c_wraith> It only works for a limited subset of types
02:40:17 <dark> and, no such necessity for having a total function; any func.. hey, i know, i will pass undefined
02:40:21 <dark> hhaha
02:40:23 <HugoDaniel> how do i generate haskell from haskell ?
02:40:56 <c_wraith> HugoDaniel: depends...  you can use TH for some use cases.
02:41:11 <dark> HugoDaniel, http://www.haskell.org/haskellwiki/GHC/As_a_library ?
02:41:15 <HugoDaniel> c_wraith, i want to generate a haskell module
02:41:15 <c_wraith> HugoDaniel: for other use cases, you have other options...
02:41:22 <c_wraith> How structured is it?
02:41:31 <c_wraith> Can you just use something like stringtemplate?
02:41:38 <HugoDaniel> not
02:41:39 <HugoDaniel> no
02:41:59 <quuuux> haskell-src-exts?
02:42:05 <HugoDaniel> i want to generate functions with different input arguments
02:42:28 <c_wraith> @hoogle Language.Haskell
02:42:28 <lambdabot> package haskell-src
02:42:28 <lambdabot> package template-haskell
02:42:44 <harlekin> kmc, ping
02:43:09 <paper_cc> HugoDaniel: really, can manipulate ASTs with haskell-src[-exts] and pretty-print them to valid Haskell source files
02:43:12 <c_wraith> yeah, if you can do what you want with  AST creation, haskell-src-exts is probably good
02:44:55 <HugoDaniel> ok, ill check that
02:47:45 <dark> what I'm doing: In my app every command has a help string. I do this: a ~~ b = (a, b), and then command Mycommand arg = "documentation for Mycommand" ~~ do { .. }, Mycommand has a type part of enum and show, so I can build a list of all (show x, fst $ command x undefined) such as x is a command
02:48:31 <dark> I haven't suspected haskell was powerful enough for doing that. (I used to think that this kind of construct is exclusive of dynamically typed languages, like lisp)
02:49:28 <c_wraith> as long as you're not creating new command types at runtime, you can probably get it with some compile-time magic
02:49:56 <c_wraith> You can do a lot of crazy stuff with template haskell
02:50:36 <c_wraith> like, you can get at the entire list of constructors for an ADT, if you know the type.
02:50:37 <dark> if it weren't working, I would try putting they at haddock and extracting from there at compile time
02:51:08 <c_wraith> That's how the TH helper libs for the better records packages work
02:51:19 <dark> can't Data.Data do that?
02:51:54 <c_wraith> Maybe.  I tend to ignore Data.Data
02:54:12 <dark> there is a Data.Dynamic o.o
02:54:27 <c_wraith> Sure, but it's just the obvious combination of Data.Typeable and unsafeCoerce
02:54:57 <c_wraith> It throws out all the typechecker's ability to prove things
02:55:32 <dark> fromDynamic :: Typeable a => Dynamic -> Maybe a
02:55:34 <dark> returns: Just a, if the dynamically-typed object has the correct type (and a is its value), or Nothing otherwise.
02:55:56 <c_wraith> Right.  It uses Typeable to move the typecheck to runtime.
02:56:13 <dark> oh. o.o
02:56:40 <dark> I thought that it resolved exactly what was going to return what at compile time
02:56:56 <dark> but one could have a list of dynamics from different origins..
02:56:57 <c_wraith> Well, the type yes, the value no.
02:57:56 <c_wraith> :t typeof (undefined :: Int)
02:57:56 <lambdabot> Not in scope: `typeof'
02:58:10 <dark> @hoogle typeof
02:58:10 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
02:58:10 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
02:58:10 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
02:58:17 <c_wraith> :t typeof (undefined :: Int) == typeOf (undefined :: String)
02:58:18 <lambdabot> Not in scope: `typeof'
02:58:23 <c_wraith> I suck at this
02:58:27 <c_wraith> :t typeOf (undefined :: Int) == typeOf (undefined :: String)
02:58:28 <lambdabot> Bool
02:58:32 <c_wraith> > typeOf (undefined :: Int) == typeOf (undefined :: String)
02:58:32 <lambdabot>   False
02:58:46 <c_wraith> :t typeOf (undefined :: Int)
02:58:47 <lambdabot> TypeRep
02:59:07 <c_wraith> Data.Dynamic is just a pair of TypeRep, Any internally.
02:59:34 <c_wraith> Where Any is a special type, that guarantees unsafeCoerce from a -> Any -> a doesn't corrupt the value
02:59:45 <darkangel> Hi there! I'am trying get into Haskell and hit the wall with Monads. Data.Enumerator.List has function head :: Monad m => Iteratee a m (Maybe a). If I undestand correctly it doesn't get ANY parameters. So HOW it works with Iteratee?
03:00:27 <rribeiro> :t ST
03:00:28 <lambdabot> Not in scope: data constructor `ST'
03:00:41 <Veinor> darkangel: if you're just learning Haskell you shouldn't bother with Iteratees right now :)
03:00:43 <rribeiro> @hoogle ST
03:00:43 <lambdabot> module Control.Monad.ST
03:00:43 <lambdabot> module Data.Array.ST
03:00:43 <lambdabot> Control.Monad.ST data ST s a
03:00:54 <rribeiro> @hoogle runST
03:00:54 <lambdabot> Control.Monad.ST runST :: ST s a -> a
03:00:54 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
03:00:54 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
03:00:56 <c_wraith> @src ST
03:00:56 <lambdabot> newtype ST s a = ST (STRep s a)
03:01:03 <c_wraith> @src STRep
03:01:03 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
03:01:10 <rribeiro> @hoogle runSTRep
03:01:11 <lambdabot> No results found
03:01:25 <c_wraith> rribeiro: you probably want runST
03:01:39 <rribeiro> Hi c_wraith!
03:02:02 <rribeiro> I'm with a little doubt with a type that I found in Control.Monad.ST code
03:02:07 <c_wraith> rribeiro: runST can give crazy error messages.  If you're running into those, feel free to ask
03:02:12 <c_wraith> err, type errors, I mean
03:02:19 <darkangel> Veinor: my problem not in Iteratee. I can't get how this works. I looked in many places for real world Haskell code and founded ton of such things
03:02:35 <rribeiro> the type is (forall s. STRep s a) -> a
03:03:08 <rribeiro> Why the type (forall s. STRep s a) -> a is different from STRep s a -> a
03:03:16 <c_wraith> not ST?
03:03:33 <rribeiro> since the "s" dont appers in the right hand side of ->
03:03:36 <dark> darkangel, every monad works its own way. monads are just an interface to bring together different things on the same code
03:03:42 <c_wraith> rribeiro: It's different in that it forces the input value to be polymorphic
03:04:00 <darkangel> dark: I understand that already
03:04:14 <c_wraith> rribeiro: If you have a function ST s a -> a, it means that the caller gets to pick any value of s and a they want, to make the code typecheck
03:04:30 <rribeiro> so, this function can only be typed with rank n support
03:04:33 <rribeiro> ?
03:04:38 <darkangel> I have 15 years C++ background and Haskell already blow up my mind :)
03:04:52 <c_wraith> rribeiro: the function (forall s. ST s a) -> a, though, requires that the value passed in be polymorphic in s.  It has to work for *any* choice of s
03:05:09 <c_wraith> rribeiro: and yes, it requires at least the Rank2Types extension
03:05:11 <dark> darkangel, I was going to say that if you are looking for something like C++ iterators, you should probably look at foldl first
03:05:28 <dark> or foldr, map, and their monadic cousins
03:05:33 <rribeiro> c_wraith: ohh... I see... 
03:05:51 <rribeiro> c_wraith, thanks for the help! :)
03:06:07 <darkangel> dark: no. That not interesting :) Iteratee was just example on what concept I've stuck
03:06:12 <c_wraith> rribeiro: The advantage of making it require polymorphism is that it prevents the value of s from escaping...  In particular, you can't make the type of a depend on the type of s, because you don't know the type.
03:06:43 <c_wraith> rribeiro: And the way ST is set up, that is what guarantees that whatever operations it does will be pure, externally, even though they're implemented with mutation internally
03:06:45 <dark> newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }. In other words, newtype is conceptually like a typedef: Iteratee a m b is a type compatible with m (Step a m b)
03:06:57 <darkangel> dark: I can't undestand from where head get its context
03:07:49 <dark> darkangel, I have no idea because I never used Iteratee. But I had a similar problem with State
03:08:06 <darkangel> dark: :( 
03:08:08 <stephan> hi.
03:08:27 <stephan> can someone direct me to programming on multicore processors with haskell?
03:09:30 <dark> State monad is brilliant: your code reads data from state, and write data to state, but it doesn't receive the state as parameter, and has no place to write. It turns out that you build things with state, and just in the very little end, you "run" it.. passing your state, of course
03:09:38 <c_wraith> darkangel: well, State is similar to Iteratee, in this way, but *much* simpler to understand
03:09:44 <c_wraith> :t get
03:09:46 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
03:10:30 <c_wraith> I wish I could partially refine that type usefully.
03:10:53 <darkangel> c_wraith: Sorry for my bad expresivnest, but Iteratee is NOT a problem. I undestand HOW it works in general
03:10:54 <dark> your code is like: add_five = do { x <- get; return (x + 5) } , see, you do not receive x as parameter. but in order to make add_five to work you need to send it a parameter anyway. (it is actually a function o.o'')
03:11:05 <dark> oh? o.o
03:11:20 <c_wraith> darkangel: I'm pretty sure I understand your problem.  And I'm pretty sure State is an appropriate instructional vector
03:11:39 <dark> you understand how to write an iteratee, but not how to run it by hand?
03:11:54 <c_wraith> darkangel: Your question is where a monadic expression gets its value from, when it's not passed in as an argument?
03:12:06 <darkangel> dark: No. I just want to undestand how head works
03:12:18 <darkangel> dark: where it gets its context
03:12:23 <dark> oh, how that specific monad works.
03:12:34 * dark doesn't know
03:12:35 <c_wraith> darkangel: how is "get :: State s" different?
03:13:06 <darkangel> dark: you show good example but you function type will acept one param. Head does'nt acceording to type declaration
03:13:11 <c_wraith> oh, wait, that's not quite right
03:13:19 <c_wraith> get :: State s s
03:14:02 <monadic_kid> stephan: you have a number of options, what is you want to do just learn how to do it concurrent or parallel programming?
03:14:15 <dark> and, hah, i understood the thing. you can do something = do { x <- head; y <- head; return (x, y) }. see, head is a monad
03:14:31 <dark> õ.o
03:14:32 <darkangel> dark: yes
03:14:41 <dark> I don't know how get is defined =(
03:14:53 <dark> @src Control.Monad.State.get
03:14:53 <lambdabot> Source not found. Sorry.
03:14:56 <c_wraith> :t runState (do {x <- get ; put (x + 1) ; y <- get ; return (y - 2) } 5
03:14:57 <lambdabot> parse error on input `5'
03:15:01 <c_wraith> :t runState (do {x <- get ; put (x + 1) ; y <- get ; return (y - 2) }) 5
03:15:02 <lambdabot> forall s. (Num s) => (s, s)
03:15:07 <c_wraith> > runState (do {x <- get ; put (x + 1) ; y <- get ; return (y - 2) }) 5
03:15:08 <lambdabot>   (4,6)
03:15:23 <c_wraith> darkangel: does that use of get look like the same thing you're asking about?
03:16:01 <dark> do { x; y } is x >> y. and do { x <- y; z } ? y >>= \x -> z, right?
03:16:15 <c_wraith> dark: yes, that's correct
03:16:31 <darkangel> I think i really should go and read next chaper about monads from Learn you haskell...
03:16:43 <c_wraith> darkangel: This has nothing to do with monads, though.
03:16:49 <dark> so actually do { x <- head; return x } is just head >>= \x -> return x.. so in order to understand head, you need not only to see how it is defined, but how >>= is defined for that monad
03:16:53 <c_wraith> darkangel: this is entirely about wrapping functions with newtypes
03:17:27 <dark> I think that understanding a bit about monadic a <- b may help
03:18:41 <darkangel> c_wright: may be you are right. I don't know... I'am trying te get all thing new things and my mind is really blasted... I even follow asleep and wakeup with that... ghhh
03:19:24 <c_wraith> darkangel: I think the key point is that values in haskell are sometimes functions...  Sometimes, the fact that they're functions is hidden, too.
03:19:50 <c_wraith> darkangel: And so, the thing you're wondering about often *does* have an argument passed in...  It's just hidden.
03:19:52 <darkangel> dark: I've allready tryed deconstruct 'head' do statement to >>= and failed... Need to get another try
03:19:59 <monadic_kid> i believe people find concepts of monads hard to grasp because they've never come across an abstraction of computations, they've only come across data abstractions until that point
03:20:54 <dark> darkangel, but you saw how Iteratee was defined? an Iteratee a m b is an m (Step a m b). so head uses the >>= from the underlying monad (how strange it may be)
03:23:36 <dark> head :: Monad m => Iteratee a m (Maybe a); head internally has type m (Step a m (Maybe a))
03:24:07 <darkangel> dark: yes
03:24:15 <darkangel> dark: i undestand that
03:24:57 <darkangel> dark: but I think I don't really undestand WHAT that meens to... :(
03:25:29 <dark> http://hackage.haskell.org/packages/archive/enumerator/0.4.6/doc/html/src/Data-Enumerator-List.html#head you saw its code?
03:25:37 <darkangel> dark: as i undestand 'head' is a function that return all that stuffs
03:25:46 <darkangel> dark:yes
03:25:48 <dark> it is not
03:26:03 <darkangel> dark: I'am looking on it all morning
03:26:11 <dark> defined like that, head is just monad, it is not a function
03:26:12 <darkangel> dark: :)
03:26:22 <dark> or if it is a function it is well disguised
03:26:23 <darkangel> dark: oO
03:27:19 <darkangel> dark: now i'am completly lost... head is a monad... how that can be posible...
03:28:34 <dark> continue :: Monad m => (Stream a -> Iteratee a m b) -> Iteratee a m b
03:28:45 <dark> head is continue loop and it defined loop
03:29:04 <darkangel> dark: continue is a function?
03:29:08 <dark> so head is an Iteratee, but an interatee is just m .. for some monad m
03:29:09 <dark> yes
03:29:20 <darkangel> dark: why head is not?
03:29:35 <dark> http://hackage.haskell.org/packages/archive/enumerator/0.4.6/doc/html/Data-Enumerator.html#v:continue
03:29:59 <darkangel> dark: they looks very similar
03:30:39 <darkangel> dark: I read 'head' declaration as 'head is a function that returns bla-bla-bla'
03:30:52 <dark> darkangel, whenever you see a code like a b in haskell, then a is a function. whenever you see do { a <- b; .. } then b is a monad (some monads are internally functions, but not all)
03:31:01 <darkangel> dark: continue i read as 'function that get function and return bla'
03:32:11 <dark> darkangel, i haven't read that way. it isn't the obvious reading, because you see no formal parameter (it is head = continue loop, not head parameter = ..)
03:32:58 <stephan> i heard that "clojure" has tree like "list structures" and can evaluate these in parallel on multi core cpus. i just wanted wo know if haskell can do that too. :)
03:33:03 <darkangel> dark: i read in that way because i saw type declaration 
03:33:51 <darkangel> dark: head :: Monad m => Iteratee a m (Maybe a) - a read that as head is function that get nothing and produce Iteratee a m (Maybe a)
03:35:55 <dark> there are no functions that get nothing in haskell
03:36:10 <dark> if you have no useful input the function would receive ()
03:36:33 <dark> darkangel, I mean. head :: Int is head a function? then head = 42
03:37:14 <darkangel> dark: I think yes, its function
03:37:22 <dark> oh
03:37:23 <darkangel> dark: from my gues :)
03:37:37 <dark> so everything is a function
03:37:53 <darkangel> yea
03:37:59 <dark> darkangel, is 42 alone a function?
03:38:03 <robryk> stephan: could you explain what do you mean by tree-like `list structures'?
03:38:24 <dark> anyway
03:38:59 <darkangel> dark: noope
03:39:32 <darkangel> head = 42 is a null arg function that produce 42
03:40:06 <robryk> stephan: if i guess correctly, you could do something similar with sparking (function par &friends) in haskell
03:40:07 <dark> darkangel, you could say that, but it is just one of the possible interpretations
03:40:45 <darkangel> dark: maybe - i just learning...
03:40:51 <Feuerbach> darkangel: see http://conal.net/blog/posts/everything-is-a-function-in-haskell/
03:40:52 <stephan> robryk: interesting. so i will stay with haskell :)
03:41:15 <robryk> stepah: i don't know what these structures are in clojure, so i'm just guessing
03:42:48 <dark> darkangel, not all top level bindings in haskell is meant to be a function. I once read a book that beginning with an equational model for haskell. a = 10 just means you can substitute a for 10 (and you technically can substitute 10 for a, but the compiler has no desire for doing that)
03:43:05 <dark> not sure if equational is a word
03:43:16 <HugoDaniel> how does haskell-src relates to TH ?
03:44:30 <c_wraith> HugoDaniel: it doesn't really.  Except sometimes one will use haskell-src[-exts] to parse a file, in order to generate content for a TH splice based on the content of the file
03:44:36 <dankna> my understanding is that it doesn't, they have completely separate ASTs.
03:44:52 <dankna> nor is there an adaptor between them.
03:45:01 <HugoDaniel> oh :/
03:45:04 <dankna> yeah :/
03:45:11 <c_wraith> HugoDaniel: and in particular, the most common way to do that is "get a list of functions defined in this file, and then do blah with them"
03:45:47 <c_wraith> or, well.  top-level definitions, functions or otherwise
03:45:48 <HugoDaniel> what kind of scenarios is one better to use than the other ?
03:46:16 <dankna> well, TH is for when you need splicing, basically
03:46:38 <dankna> I haven't looked at the differences between their ASTs in detail; they're probably pretty similar.
03:46:41 <zenzike> in the Real World Haskell example of parallel sorting, they use the length function to make sure that the benchmark list gets sorted. I've tried replacing this with `force` instead, but for some reason it seems that the list isn't getting sorted, does anyone know why?
03:47:06 <c_wraith> zenzike: what force function do you mean?
03:47:11 <zenzike> forceList
03:47:22 <zenzike> forceList (x:xs) = x `pseq` forceList xs
03:47:29 <c_wraith> zenzike: that lacks information...  like where it's defined, and by what package
03:47:33 <zenzike> forceList [] = ()
03:47:39 <zenzike> (that's the definition I'm using)
03:48:01 <c_wraith> pseq is odd there, but not really wrong
03:48:02 <darkangel> dark: thanx for you time I will read further to try to track his down
03:48:12 <zenzike> I'm using the following to evaluate:
03:48:21 <zenzike> (forceList rands) `pseq` (forceList (sort rands)) `pseq` (return ())
03:48:26 <c_wraith> it'd be more common to use seq, since you don't actually care about order of evaluation
03:48:31 <zenzike> where rands is a list of random numbers and sort is my sorting function
03:48:36 <dankna> c_wraith: looks to me like constant folding is maybe the issue in zenzike's example?  the optimizer detects that the result is going to be () and skips to the end?  or does our optimizer not do that?
03:48:41 <zenzike> c_wraith: thanks
03:49:09 <c_wraith> zenzike: is this in IO?
03:49:12 <zenzike> c_wraith: I thought that using pseq was what I wanted to ensure that teh first argument gets evaluated first
03:49:20 <zenzike> c_wraith: yep, it's in the body of my main function
03:49:29 <c_wraith> zenzike: why do you care what argument gets evaluated first?
03:49:42 <c_wraith> zenzike: isn't the only thing you care about that it all gets evaluated?
03:49:43 <zenzike> c_wraith: I guess I don't in forceList :-)
03:50:09 <c_wraith> dankna: the optimizer shouldn't be the problem..
03:50:19 <zenzike> c_wraith: good point. so seq ensures that its first argument gets evaluated, but doesn't necessarily do it in order
03:50:20 <dark> I liked the “everything is a pair”, and 7 is really (7,⊥)
03:50:47 <dankna> c_wraith, hm okay
03:51:25 <c_wraith> zenzike: yes.  It *usually* does it in order, though.  It only doesn't if the optimizer decides that it doesn't make sense to do it in order, like if you had something like:  let x = 5 + 3; y = x + 7 in y `seq` x
03:51:56 <c_wraith> zenzike: In that case it'll go out of order because evaluating x is part of evaluating y, anyway
03:52:04 <zenzike> c_wraith: thanks, that makes sense. I've just tested again and it doesn't seem to make much of a difference here ... 
03:52:09 <c_wraith> zenzike: or at least, the compiler is free to choose to do so
03:53:22 <c_wraith> zenzike: well, I don't see the problem offhand.  But since it appears you're benchmarking, I'll point you at the criterion library, and say you should be using it anyway.
03:53:24 <zenzike> I'll paste my code to see if there's soemthing else I've missed
03:53:33 <c_wraith> @hackage criterion
03:53:33 <lambdabot> http://hackage.haskell.org/package/criterion
03:54:00 <c_wraith> since criterion gives you statistical analysis of your results, as well
03:54:22 <zenzike> c_wraith: yeah, I've used it before, but here i suspect I'm doing something silly
03:54:28 <zenzike> http://hpaste.org/44169/parallel_sort
03:54:46 <c_wraith> yikes, birdtracks! :)
03:55:02 <c_wraith> interesting that hpaste's html-colorizer doesn't handle literate haskell fully properly
03:55:08 <zenzike> heh. I'm just writing it up so I remember what I'm doing
03:55:19 <robryk> what does NOINLINE CONLIKE mean? i though CONLIKE only caused inlining in some cases where it wouldn't ordinarily happen..
03:55:27 <zenzike> yeah that is strange. it ought to use the shjs script I use on my website :-)
03:55:35 <c_wraith> oh, it does handle it properly
03:55:42 <c_wraith> you just have to set the file type as literate haskell
03:55:47 <c_wraith> and hpaste defaults to haskell
03:55:49 <zenzike> lol. i just noticed that myself
03:56:57 <zenzike> the trouble with that code is that if I replace the "forceList (sort rands)" to "sum (sort rands)", the single threaded version takes about twice as long as the parallel, which is god
03:56:59 <zenzike> *good
03:57:21 <zenzike> but if I leave it as it is, the single threaded version is only about 10% slower
03:57:49 <c_wraith> are you just benchmarking runtime?
03:57:59 <c_wraith> of the whole program, I mean?
03:58:00 <zenzike> yeah, I'm using "time"
03:58:08 <c_wraith> ok
03:58:12 <sgronblo> does ghci have something similar to the time command?
03:58:25 <dankna> you should set the program to do this operation many times in a tight loop to factor out startup overhead, but I'll let c_wraith be the diagnostician here.
03:58:31 <dankna> sgronblo, not that I'm aware of
03:58:47 <c_wraith> it has something kind of like it, but I don't remember what the argument is.
03:59:01 <c_wraith> It turns on time/memory displays for each evaluation
03:59:15 <zenzike> dankna: agreed, but here I would have thought that the expensive part would be the sorting
03:59:22 <zenzike> especially with 200000 values
03:59:29 <dankna> well, what's your total time?
03:59:50 <zenzike> time ./parallel-tutorial -p -d10 +RTS -N3 -s -H500M -K100M -qg0 -qb
03:59:59 <zenzike> real	0m5.094s
03:59:59 <zenzike> user	0m13.330s
03:59:59 <zenzike> sys	0m0.470s
04:00:07 <zenzike> time ./parallel-tutorial +RTS -N3 -s -H500M -K100M -qg0 -qb
04:00:12 <zenzike> real	0m6.252s
04:00:12 <zenzike> user	0m7.280s
04:00:12 <zenzike> sys	0m0.200s
04:00:19 <dankna> okay.  certainly 13 seconds is long enough that I'd expect it to be an accurate measurement.
04:00:21 <c_wraith> that's amusing...  it's clearly using all three cores
04:00:30 <c_wraith> it's only 5 seconds.  13 user :)
04:00:32 <zenzike> c_wraith: yeah it is strange
04:00:39 <dankna> I wonder what it's doing with the other 7 seconds that aren't spent computing anything.
04:00:49 <c_wraith> dankna, you're reading those backwards
04:00:55 <dankna> oh, right
04:01:14 <zenzike> it looks like it's doing parallel stuff fine, the only strange thing is if I use "sum" instead of "forceList", then the singlethreaded takes about 15 seconds real time
04:01:32 <zenzike> (whereas the parallel one takes about 7 secs)
04:03:24 <c_wraith> I...  Suspect it's not actually wrong.
04:03:38 <c_wraith> time just adding a list of 20000 numbers
04:03:59 <c_wraith> I have this sneaking suspicion it will be significant
04:04:27 <dankna> oh, yeah, good call.
04:04:31 <zenzike> I agree. that's why I suspected my use of pseq was incorrect in the final evaluation
04:04:49 <zenzike> but I can't think of why it would be bad
04:04:53 <c_wraith> I don't think it is
04:05:05 <zenzike> *I mean use of forceList (sort rands)
04:05:25 <c_wraith> change it to just "sum rands" there
04:05:36 <c_wraith> and compare the runtime in a few various modes
04:07:02 <zenzike> oh strange. it's working in about the same time as using forceList instead of sum now ...
04:07:18 <zenzike> I wonder why I had it being twice as slow earlier on .. hum ho ...
04:07:27 <c_wraith> hmm.  are you compiling this just with ghc --make?
04:07:39 <zenzike> ghc --make -O2 -threaded parallel-tutorial.lhs
04:08:10 <c_wraith> just because I don't trust anything, try adding -fforce-recompile, or whatever that option is.
04:08:19 <mux> -fforce-recomp
04:08:25 <c_wraith> mux: thanks
04:08:40 <mux> I'm so paranoid I use it constantly
04:09:04 <zenzike> which parts of the code might not get recompiled?
04:09:22 <c_wraith> I don't know.  It's just paranoia :)
04:09:34 <c_wraith> I have no good reason to suggest any of wouldn't get recompiled
04:09:35 <mux> those object files for which the source file's modification time didn't change, I guess
04:09:44 <c_wraith> since it's all one file
04:09:52 <mux> I guess it should be okay then :-)
04:09:53 <zenzike> time ./parallel-tutorial +RTS -N3 -H500M -K100M -qg0 -qb
04:09:53 <zenzike> real	0m6.213s
04:09:53 <zenzike> user	0m7.270s
04:09:53 <zenzike> sys	0m0.200s
04:10:00 <zenzike> time ./parallel-tutorial -p -d10 +RTS -N3 -H500M -K100M -qg0 -qb
04:10:00 <zenzike> real	0m5.170s
04:10:00 <robryk> by the way, why doesn't haskell put compile flags in some comment field in object files?
04:10:00 <zenzike> user	0m13.800s
04:10:00 <zenzike> sys	0m0.800s
04:10:01 <c_wraith> But...  When making changes sometimes results in different values, and sometimes doesn't, I get paranoid. :)
04:10:09 <zenzike> (that's using the sum version, rather than forceList)
04:10:21 <zenzike> it seems I was going crazy in my initial analysis
04:10:23 <dankna> robryk: not a bad idea.  "the default status of features is nonexistent".  if you want to see it, implement it.
04:10:41 <robryk> oh, ok. thought there was some other reason :)
04:10:45 <dankna> nope :)
04:14:39 <zenzike> c_wraith: thanks for your help (and sorry for wasting your time!) it's nice to know i was on the right page all along
04:14:56 <c_wraith> zenzike: no problem.  I'd just have been bored, or sleeping, otherwise :)
04:15:17 <c_wraith> holy crap, it's almost 5 am.  Why amn't I sleeping?  (And why isn't amn't an accepted abbreviation?)
04:15:47 <zenzike> c_wraith: whoa. that's early. trying going to bed and closing your eyes for a while, ftw
04:15:55 <Xilon> Having some trouble workig with ByteStrings. The tar library uses ByteString.Lazy (apparently), while I'm using ByteString.Char8, any way to convert between the two? http://hpaste.org/44170/bytestring_conversion
04:16:29 <mux> Xilon: try using Data.ByteString.Lazy.Char8
04:16:42 <dankna> because it's aren't
04:17:07 <mux> converting between strict and lazy bytestrings should be avoided
04:17:26 <mux> but you can use S.concat . L.toChunks
04:18:06 <Xilon> hmm that's annoying
04:18:37 <mux> Xilon: maybe you could tell us a bit more about why some ports of your code require strict bytestrings?
04:19:42 <Xilon> Not sure if they actually require them. I started writing a parser using strict bytestrings and now I've starting playing with reading files from tarballs, which uses lazy bytestrings. Guess I could provide a lazy version of the parser
04:19:48 <ulfdoz> Jo, und beim ROC im Januar hat sie das Original aufs Dach gelegt.
04:20:10 <ulfdoz> ewin
04:20:30 <Xilon> Still not familiar with the cons and pros of lazy vs strict
04:21:14 <mux> Xilon: I see; the wide number of interfaces for parsers is a bit annoying; lazy bytestring/strict bytestring/Text and possibly with enumerators, erc
04:21:18 <mux> *etc
04:22:31 <Xilon> Yeah I wanted to learn iteratees with this toy project as well :P
04:24:31 <Clex> Is there something like "replaceAt" to replace a list element at an offset?
04:26:32 <blueonyx> hi, i struggle learning iteratees too, can some one shed some light on http://hpaste.org/44171/?
04:26:34 <ClaudiusMaximus> @hoogle Int -> a -> [a] -> [a]
04:26:35 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
04:26:35 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
04:26:35 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
04:27:52 <ClaudiusMaximus> Clex: probably not, if you need random access replacement, better to use a different data structure (Map Int a, Seq a, Array Int a, ...)
04:28:13 <ksf> It's sunday.
04:28:23 <ksf> http://stackoverflow.com/questions/5057136/real-world-applications-of-zygohistomorphic-prepromorphisms . go for it.
04:28:32 <Clex> 'k ClaudiusMaximus, too bad. Thanks anyway.
04:28:34 <blueonyx> i tried to adjust skip from http://docs.yesodweb.com/blog/enumerators-tutorial-part-3 but where is the lift used there defined?
04:29:05 <ClaudiusMaximus> Clex: shouldn't be too hard to write if you absolutely need it, given splitAt :: Int -> [a] -> ([a], [a])
04:33:40 <Clex> ClaudiusMaximus: yeah but if it does not exist it's likely there's a good reason to it.
04:33:49 <Clex> I'm gonna use an array instead.
05:07:11 <rkrzr> Hi Haskell, is there an easy way to see the source for a particular instance declaration?
05:07:49 <mux> @src [] (>>=)
05:07:49 <lambdabot> xs >>= f     = concatMap f xs
05:07:59 <mux> you can usel ambdabot this way, it sometimes works
05:08:30 <mux> @src Maybe (>>=)
05:08:30 <lambdabot> (Just x) >>= k      = k x
05:08:30 <lambdabot> Nothing  >>= _      = Nothing
05:08:47 <rkrzr> @src Either (<*>)
05:08:47 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:09:28 <mux> @src (Either e) (<*>)
05:09:28 <lambdabot> Source not found. My mind is going. I can feel it.
05:09:47 <mux> I guess you'll have to dig in the sources; haddock makes this not so hard
05:11:48 <rkrzr> I think it would be nice if there were links on Haddock to show the source of particular instances
05:13:10 <rkrzr> e.g it's not really clear to me where I would have to look for the instance of Functor (Either l)
05:13:50 <Saizan> yeah, that's always a bit problematic
05:18:39 <rkrzr> Somebody already added a feature request for this: http://trac.haskell.org/haddock/ticket/145, would certainly be nice
05:20:10 <Saizan> http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/src/Control-Monad-Instances.html <- btw
05:20:22 <rkrzr> Ah thx
05:29:11 <mpiechotka> "%GC time     -6972.9%  (0.0% elapsed)" - how should I understand this?
05:30:00 <Igloo> Probably an overflow bug
05:30:50 <mpiechotka> Igloo: I thought so
05:31:27 <mpiechotka> Igloo: But rather underflow
05:33:29 <Igloo> No, overflow: http://en.wikipedia.org/wiki/Integer_overflow
05:36:06 <mpiechotka> Igloo: I know little about GC but why with short times - hence small numbers - you would get small numbers (where's place for overflow)?
05:38:43 <Igloo> Oh, it was a short run-time? That's a little more surprising, then
05:39:48 <robryk> was this a short execution or was it a long execution with short GC times?
05:40:46 <robryk> and can you reproduce it?
05:46:04 <gronliz> damn why do I have to compile ghc7 myself to get it
05:46:42 <Saizan> do you?
05:46:49 <dankna> what platform are you on, gronliz?
05:47:16 <gronliz> I did on ubuntu. I am too lazy to use those trolling release distros
05:47:31 <dankna> then it sounds like you know the answer to your question
05:47:48 <dankna> there should be a tag <rhetoric> to mark questions that aren't expecting responses
05:47:56 <dankna> (and one <sarcasm> to be never used for anything, ever)
05:48:27 <gronliz> I could use arch. I notice it is on there, but arch sucks
05:48:29 <Saizan> there is in fact no reason to compile ghc yourself if you're on linux on one of the supported archs.
05:48:34 <gronliz> for technical reasons
05:48:47 <Saizan> and no reason to mock distros here
05:48:47 <gronliz> no signed packages
05:48:57 <gronliz> that is not mocking
05:49:03 <gronliz> that is a serous security flaw
05:50:32 <Saizan> http://haskell.org/ghc/download_ghc_7_0_1#binaries <- btw
05:51:00 <dark> there was someone here, darkangel, that had problems understanding monad. I wrote up this http://hpaste.org/44174/tryingtoexplainmonads but he or she left :P
05:51:28 <dark> if someone with patience can read and tell if what I wrote makes sense, I would appreciate
05:52:27 <gronliz> lol the monads are great for trolling.
05:52:42 <gronliz> Write "A monad is just ....." and everyone goes nuts
05:52:55 <dark> =DDD
05:53:29 <aristid> A monad is just an instance of the Monad typeclass that follows the monad laws.
05:53:32 <Saizan> @quote dolio 2-
05:53:32 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
05:53:50 <dark> btw I use "myself" two times in the first paragraph, I think it is somehow bad practice (but my english as a whole is bad)
05:54:00 <aristid> Saizan: your @quote skills are excellent, master
05:54:01 <dankna> dark: for informal writing, "myself" is fine
05:54:28 * Saizan bows
05:54:28 <dark> no I meant, repetitive, redundant
05:55:09 <dankna> well, maybe slightly but not a big deal.  but actually now that I look at it, the second usage should be "me"
05:55:35 <dankna> I'm not sure that I can explain the distinction between "me" and "myself" - it's one of those numerous subtle rules which we native speakers know but can't elucidate
05:55:38 <dark> I think I read somewhere that you become a Haskell newbie when you write a monad tutorial. (if yes I might qualify as a newbie)
05:56:05 <dark> dankna, exactly, I actually rewrote and changed the second usage to me
05:56:11 <dankna> gotcha
05:56:22 <dankna> well, anyway, if you learned something from writing it up, it served its purpose
05:56:30 <dankna> although I do feel sorry that you wrote it for someone who then left :(
05:56:32 <dankna> not surprising though
05:57:02 <gronliz> how would you emulate switch with fall through in haskell? 
05:57:13 <dark> gronliz, maybe? either?
05:57:29 <dark> I will send a memo =)
05:57:35 * dankna nods
05:57:51 <dankna> gronliz: there's no direct way to do that, you should examine your reasons for wanting it
05:58:08 <dankna> gronliz: for the same reason as we don't allow you to omit the "else" in "if-then-else".
05:58:20 <dankna> gronliz: most of the time, the types would work out wrong.
05:58:25 <kaol> Just put some functions in a Data.Map.
05:58:42 <dark> what would be 'switch with a fail'?
05:59:26 <dankna> dark: hm?  gronliz is talking about a C construct where you do, ie, switch(0) { case 0: printf("foo"); case 1: printf("bar"); }
05:59:36 <dankna> the result of the expression is that "foobar" is printed, because there is no break; statement.
05:59:38 <dark> I understand like case .. of .. -> Just a | .. | _ -> Nothing
05:59:47 <dark> oh
05:59:53 <gronliz> I will provide a good example for where it is needed
05:59:55 <dankna> he's asking how we would do that in Haskell, and I'm telling him not to
06:00:11 <dankna> gronliz: that's fine, feel free, but expect me to suggest an alternate way to frame the code entirely
06:01:15 <dark> gronliz, you could have a list, and for the first option you exec the whole list; for the second, you drop the first element and exec the list; etc
06:01:38 <gronliz> http://pastebin.com/sfVQdmNq
06:02:15 <gronliz> that is from the murmurhash implementation
06:02:20 <dankna> gronliz: what is it you like about this implementation?  its brevity?  the fact that it doesn't repeat code?
06:02:36 <gronliz> the removal of repeated code
06:02:50 <gronliz> if you wrote that in a haskell case
06:02:56 <dankna> okay.  well, I can see how that's a virtue (although when the amount of code is so small, it hardly matters)
06:02:56 <gronliz> you would have to repeat a lot
06:03:05 <dankna> what I would do is something like
06:03:09 <dankna> well, I'll hpaste
06:04:28 <dark> gronliz, but you can write something like type Len = One | Two | Three , fun One = do { .. } , fun Two = do { ..; fun One }, fun Three = do { ..; fun Two }
06:04:53 <dark> or actually you could use function composition
06:05:10 <dankna> no, I've got a more elegant solution
06:05:12 <dankna> I'm writing it up
06:05:47 <gronliz> maybe continuations
06:06:10 <mpiechotka> Sorry for asking - generation 1 is older then generation 0 or vice versa?
06:06:19 <dankna> http://hpaste.org/44177/like_this
06:06:22 <dankna> mpiechotka, not sure
06:06:28 <dankna> I believe generation 0 is newer
06:06:31 <dankna> but it's just a guess
06:07:44 <gronliz> good idea
06:07:55 <gronliz> well I think that solves it
06:08:02 <dankna> cool
06:08:15 <gronliz> I wonder what that compiles down to compated to a switch
06:08:23 <gronliz> *compared*
06:08:32 <gronliz> for some imperative language
06:08:54 <dankna> you could even do http://hpaste.org/paste/44177/like_this_annotation#p44178
06:10:04 <dankna> I've no idea what it compiles to, and I shouldn't need to care unless it's a tight inner loop.  which it's not, because it's just the last few bytes.  unless you're doing the whole algorithm many times in a tight loop.
06:10:16 <dark> http://hpaste.org/paste/44177/like_this_annotation#p44179
06:10:32 <dankna> ah - yes, that's even terser
06:11:23 <dankna> although I don't believe you can do h ^ $ ... like that
06:11:40 <dark> @src (^)
06:11:40 <lambdabot> x ^ 0            =  1
06:11:41 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
06:11:41 <lambdabot>   where f _ 0 y = y
06:11:41 <lambdabot>         f x n y = g x n
06:11:41 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
06:11:42 <lambdabot>                       | otherwise = f x (n-1) (x*y)
06:11:44 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
06:11:58 <dankna> also, ^ is exponent on Haskell, not xor :)
06:12:08 <dankna> but I didn't know what xor was so I left that as an exercise to the reader
06:12:17 <dankna> it'll be in Data.Bits somewhere
06:14:07 <sbahra> (h ^) $
06:14:40 <dark> uhm o.o but the thing is, it begun with a feature that would make C code smaller
06:15:23 <dankna> that's why I asked what his concern was
06:15:28 <dankna> the execution or the presentation
06:15:31 <dankna> he answered the latter
06:16:02 <dankna> (properly.  if he had said the execution, I probably wouldn't have felt like helping.)
06:16:37 <dankna> (at some point you've got to just trust the compiler, or else go to the other extreme and profile everything very carefully, but in neither case is asking for help with tuning appropriate.)
06:21:49 <dark> and ah, the quote is "A ‘newbie’, in Haskell, is someone who hasn’t yet implemented a compiler. They’ve only written a monad tutorial."
06:22:31 <dankna> haha
06:23:19 <kuznero> Hello all, have a small question - hope somebody could help me with that... I've just installed mongodb (with "cabal install mongodb" as a user), but I cannot see it when doing "ghc-pkg describe mongodb". And it is not recognized as installed module when specified as a dependency in *.cabal file. Does anybody know how to deal with this?
06:23:52 <kuznero> Same applies to couchdb...
06:25:33 <dark> btw why import Text.Parsec isn't enough for exposing the type Parser, if http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec.html says module Text.Parsec.String ?
06:25:59 <dark> also http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec.html , the version I have installed
06:26:29 <kuznero> dark, should be exposed as Parsec(..) ?
06:27:13 <dark> kuznero, hmm?
06:27:31 <dark> I'm confused, in the end I just imported Text.Parsec.String
06:27:48 <kuznero> Ah... sorry - misunderstood
06:28:04 <kuznero> Gents, who can help me with mongodb issue?
06:28:22 <dankna> dark: the type synonym Parser is exposed, the underlying type Parsec is not
06:28:46 <dankna> except that it is, hm.
06:28:59 <dark> but,
06:29:02 <dankna> kuznero: sorry, I don't know what could be the problem; cabal always works for me
06:29:33 <kuznero> I even tried to install it globally, but it didn't help :(
06:29:52 <dark> kuznero, maybe cabal isn't seeing ghc, or ghc isn't seeing cabal
06:29:56 <Saizan> kuznero: ghc-pkg list mongoDB ?
06:30:07 <kuznero> sec
06:30:26 <kuznero> /var/lib/ghc-6.12.1/package.conf.d
06:30:26 <kuznero> /home/kuznero/.ghc/x86_64-linux-6.12.1/package.conf.d
06:30:26 <kuznero>    mongoDB-0.9.2
06:30:35 <Saizan> so it is installed
06:30:38 <kuznero> Yes
06:30:42 <Saizan> ghc-pkg is case sensitive
06:30:49 <gronliz> has  anyone attempted to make something like redis in haskell?
06:31:04 <kuznero> But when defined as dependency in cabal ghc is complaining that cannot be found
06:31:16 <Saizan> kuznero: you should be able to e.g. "import Database.MongoDB"
06:31:38 <Saizan> kuznero: what do you mean by "defined as dependency in cabal"?
06:31:44 <kuznero> In ghci - yes, when working with cabal configure project/solution wise - not
06:32:22 <Saizan> do you have mongoDB in the build-depends: field in your .cabal file?
06:32:23 <kuznero> build-depends:
06:32:23 <kuznero>   base -any,
06:32:23 <kuznero>   datetime -any,
06:32:23 <kuznero>   mongodb -any
06:32:28 <kuznero> yes
06:32:29 <dankna> case-sensitive
06:32:34 <dankna> s/mongodb/mongoDB/
06:32:40 <kuznero> Ah... do you think this is the problem?
06:32:43 <dankna> yes I do
06:32:44 <kuznero> Sec, will try
06:34:03 <kuznero> Works great!
06:34:06 <kuznero> Thanks!
06:34:20 <kuznero> Was struggling with this for an hour :)
06:34:37 <ezyang> Nop programming language! You get unconditional branches and nops. Have fun! 
06:34:48 <dankna> haha
06:35:16 <dark> I was thinking in how one can manage to do something at all with this language ezyang
06:35:36 <dankna> the Nop language is actually designed for music synthesis
06:35:41 <ezyang> I'm writing some Hoopl example code, so it's not want the language does, it's what we do to the language :-) 
06:35:46 <dankna> it can play the popular song "Four minutes, thirty-three seconds."
06:35:47 <ezyang> dankna: Like John Cage! 
06:35:50 <dankna> bah!
06:35:54 <dankna> you stole my punchline!
06:36:01 <ezyang> heehee 
06:36:03 <dankna> :D
06:36:19 <dankna> well, cool
06:36:42 <Saizan> isn't it a bit too easy to write an optimizing compiler for that? const Nop
06:36:56 <ezyang> "We're going to do it the hard way" :-) 
06:37:51 <ezyang> Also, it can get stuck if you jump to a non-existent label. 
06:38:08 <ezyang> So not too trivial :-) 
06:46:36 <ezyang> Hmm, I guess I need an exit instruction too :-) 
06:47:14 <ddarius> You could just talk about productiveness.
06:48:19 <ezyang> I could! 
06:52:41 <monadic_kid> feeling sleepy + coding == not good
06:55:20 <dark> monadic_kid, if under pressure of a deadline, surely but i enjoy programming barely wake
06:55:53 <dark> awake
06:57:18 <dark> but when i wake up i see that i just paid attention to little details and did nothing meaningful
07:04:46 <edwardk> preflex: xseen djahandarie
07:04:47 <preflex>  djahandarie was last seen on freenode/#haskell 10 hours, 53 minutes and 42 seconds ago, saying: mig_, can you move to #haskell-blah for off-topic trolling?
07:06:42 <peorOvO> is there any function that splits a string in several strings when it founds a given character? I tried to look for `a -> [a] -> [[a]]' on hoogle, but couldn't find anything
07:07:05 <dschoepe> periodic: There are various split functions in Data.List.Split (in the split-package)
07:07:29 <peorOvO> dschoepe, thanks!
07:07:57 <edwardk> @tell djahandarie i actually hacked up a little bit of it in category extras, where i have build morphisms. if you look at it Mu in recursion-schemes _is_ build, and working with Mu is implicitly working with fold/build fusion, Nu is working with unfold/destroy fusion.
07:07:58 <lambdabot> Consider it noted.
07:09:42 <mreh> edwardk: category-extras clashes with trasnformers
07:10:00 <edwardk> mreh: category-extras is deprecated. what is left in it that you need?
07:10:01 <mreh> can you fix it?
07:10:15 <mreh> edwardk, maybe I need to let conal know then
07:10:24 <mreh> i'm still using ghc6 mind
07:10:29 <edwardk> mreh: i've been splintering it into a lot of little packages
07:10:33 <edwardk> so am i
07:10:53 <edwardk> do you know what bits of it conal is using? i've probably factored them out
07:11:19 <mreh> no, but hopefully he's listening
07:11:21 <mreh> ...
07:11:36 <edwardk> conal! conal! conal! I invoke thee!
07:11:56 <Botje> huh, i read that as 'what bits of conal is it using'
07:12:08 <edwardk> hrmm, it usually works with kowey. ;)
07:13:25 <mreh> I don't feel like maintaining two build environments, but I might just have to, the most annoying part is not being able to use transformers in the same package as reactive
07:13:43 <edwardk> mreh: i'll go pull down a copy of reactive and mine through it
07:13:52 <mreh> thank you
07:13:57 <edwardk> compatibility with everything is _why_ i started splitting things out
07:14:03 <edwardk> that way i could have a large haskell 98 core
07:14:14 <edwardk> and so folks wouldn't have to pull in the kitchen sink
07:14:21 <edwardk> if they just wanted something like Pointed
07:14:29 <mreh> the clash with transformers is only the Either instances
07:14:49 <mreh> what's pointed again? pure?
07:14:53 <edwardk> yeah
07:15:05 <edwardk> and it used to subclass Functor needlessly
07:15:31 <edwardk> (the only law at that level is already a free theorem, so any type that happened to be both a functor and offer pure would have complied)
07:15:31 <mreh> because not all pointeds are functors?
07:16:01 <edwardk> because any pointed that is a functor would automatically satisfy the only law you could state relating fmap and pure
07:16:19 <edwardk> pure . f = fmap f . pure
07:16:30 <edwardk> follows from parametricity
07:16:38 <mreh> right
07:16:55 <mreh> is there a class for join?
07:17:05 <edwardk> in emigroupoids
07:17:08 <edwardk> er semigroupoids
07:17:25 <edwardk> Data.Functor.Bind states that kleisli composition is a semigroupoid. (associative, but not necessarily having a unit)
07:17:50 * ddarius doesn't think Conal would appreciate having bits of himself cut off, but you'd probably have a hard time telling.
07:18:21 <mreh> i understand why you want to cuts bits of me off, lets talk about those reasons
07:18:27 <edwardk> i can't seem to install reactive. checkers complains quite loudly
07:18:48 <mreh> ^ my conal impression
07:18:57 <edwardk> =)
07:19:09 <mreh> what checker?
07:19:19 <edwardk> something upstream of reactive
07:19:38 <edwardk> i haven't been able to install reactive for some time
07:19:46 <edwardk> some headache with quickcheck
07:21:29 <mreh> I have a headache
07:21:55 <mreh> the best solution seems to be to get conal to update to your latest category extras bits
07:22:14 <edwardk> i'm going through and hand updating every package in my local cabal
07:22:31 <mreh> or even better, update transformers to use the right bit
07:22:47 <mreh> or I could just go to ghc 7, would that enable me to install category extras?
07:23:04 <mreh> I read somewhere it would, not sure how true that might be
07:23:17 <Saizan> not as it is
07:23:23 <edwardk> i have a patch outstanding from someone, but category-extras will very shortly become a much much smaller package as all it is no longer the canonical source for anything interesting
07:24:31 <edwardk> iirc he was (ab)using it to get Comonad
07:24:57 <edwardk> and Copointed
07:25:10 <mreh> is this for reactive?
07:25:15 <edwardk> yeah
07:25:33 <edwardk> as soon as i can get it to install i can start the semigroupoids patch =/
07:25:46 <mreh> i'm going to go and read the ghc 7 change list
07:26:01 <christo_m> xplat: where did you get the "opt" keyword from when i asked you yesterday?
07:26:05 <christo_m> i cant find it documented anywhere
07:26:06 <edwardk> well, the category-extras Either instances are out-of-date
07:26:28 <aristid> edwardk: will you change category-extras to depend on your new other packages?
07:26:32 <edwardk> I've factored the either transformer out into an 'either' package which provides the transformer only
07:26:43 <aristid> edwardk: or leave it as is and keep it for historical purposes only?
07:26:58 <edwardk> aristid: if there is anything left that doesn't get factored out, yes. if nothing else a category-extras with all of the dependencies would point to where all the bits _went_
07:27:00 <mreh> category extras implies many different things
07:27:20 <mreh> i say leave it behind, as good as it was
07:27:37 <edwardk> mreh: i'd rather not have to deal with a fork of my own code ;)
07:28:11 <edwardk> the community of my users is small enough that the usual fork effect of cutting it in half and causing it to shrink would be depressing
07:28:33 <ddarius> edwardk: We'd have to cut someone in half.
07:28:42 <ddarius> Back in the day, this would be great entertainment.
07:29:10 <aristid> in some places, it still is.
07:29:25 <mreh> can't we just do a david copperfield
07:29:41 <mreh> make ourselves think we cut it in half
07:29:55 <ddarius> I guess that person was an illusion anyway.
07:30:05 <hpc> mreh: first we assume a spherical person
07:30:10 <hpc> then we cut it and cut it
07:30:13 <hpc> until we get two people
07:31:19 <edwardk> note to self, avoid being alone with hpc.
07:31:44 <mreh> i'm seeing double
07:31:46 <edwardk> hpc: the Banach-Tarski killer
07:31:47 <mreh> four people!
07:31:52 <astroboy> I have a function that throws an exception with "error". I'm trying to catch it with "catch" in a monad, and it doesn't work: http://hpaste.org/44180/catching_error
07:32:27 <hpc> :D
07:32:28 <aristid> astroboy: error is not really the best way to throw exceptions, i think
07:32:42 <astroboy> aristid: sadly that doesn't depend on me, I'm using a library that uses it
07:32:52 <aristid> astroboy: catch only works in IO
07:33:01 <aristid> you can in fact catch error, but only in IO
07:33:04 <aristid> but it is evil
07:33:15 <hpc> there's another catch in Control.Exception
07:33:19 <hpc> or similar module
07:33:21 <astroboy> aristid: ok, thanks
07:33:26 <aristid> :t catch
07:33:26 <astroboy> hpc: I get the same error
07:33:27 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
07:33:29 <hpc> and it will catch pure errors, if you are really luck
07:33:32 <hpc> lucky
07:33:37 <mreh> edwardk, why did someone send you the patch for reactive?
07:33:40 <aristid> hpc: but only in IO, too
07:33:42 <edwardk> cabal: dependencies conflict: ghc-6.12.3 requires array ==0.3.0.2 however array-0.3.0.2 was excluded because ghc-6.12.3 requires array ==0.3.0.1 — blows up on me whenever i try to install quickcheck
07:33:50 <edwardk> mreh: no a patch for category-extras
07:33:52 <astroboy> I'll just replace the error throwing function with something else myself
07:33:53 * hpc had to use that to catch sql errors, even though they were in IO >:(
07:34:01 <edwardk> mreh: to make it compile on ghc 7
07:34:06 <edwardk> with mtl 2
07:34:28 <mreh> oh..
07:34:30 <mreh> i see
07:35:04 <wires> Hi, I want to distribute data across multiple machines, what options do I have?
07:35:13 <edwardk> i really wish reactive didn't directly depend on QuickCheck. it really keeps me from using it because of all the old QuickCheck dependencies floating around
07:35:25 <hpc> wires: distributing data, not computation?
07:35:27 <edwardk> wires: scp, ftp, … ;)
07:35:31 <outsid3r> hi
07:35:48 <hpc> wires: sql, assuming specific structure of data
07:35:53 <aristid> edwardk: does reactive actually need a QuickCheck dependency?
07:35:54 <hpc> http
07:36:03 <outsid3r> i want to do something like, take (fromIntegral(length list) / 2) list
07:36:08 <outsid3r> but it gives me an error
07:36:11 <wires> hehe :) I mean like a in memory distributed data structure
07:36:27 <ddarius> outsid3r: How do you take 3.5 elements?
07:36:27 <aristid> outsid3r: the second list is wrong. take it away
07:36:28 <wires> like a clustered database, k/v store, etc... but with haskell values
07:36:31 <aristid> oh
07:36:37 <edwardk> aristid: conal packages his quickcheck properties up in the modules that define everything iirc
07:36:39 <aristid> sorry i read it wrong
07:36:42 <outsid3r> i started haskell yesterday at my computer science course
07:36:51 <outsid3r> aristid: the ideia is to convert that 3.5 to 3
07:36:53 <aristid> edwardk: he should use a flag and #if
07:37:03 <aristid> outsid3r: use `div`, not /
07:37:15 <aristid> take (length list `div` 2) list
07:37:20 <hpc> wires: the ugly way would be to make an sql cluster and store your haskell values with show/read
07:37:29 <outsid3r> aristid: ok, but if i choose to use / ?
07:37:34 <hpc> "ugly" in this case meaning i thought about it for all of 10 seconds
07:37:38 <wires> hpc: ha, no that won't work.. i need performance
07:37:38 <aristid> outsid3r: no. use `div`.
07:37:41 <hpc> :D
07:37:42 <edwardk> aristid: thats awkward, because the flag doesn't work nicely for stuff that escapes your package.
07:37:46 <aristid> outsid3r: don't insist on using the wrong function
07:37:59 <aristid> edwardk: or of course package it in another package
07:38:11 <aristid> edwardk: depending on QuickCheck is always wrong(tm)
07:38:17 <edwardk> aristid: flags should be purely internal details, if they expose an API change there is no way for another package to depend upon reactive-with-QuickCheck-support
07:38:26 <outsid3r> aristid: ok i will use div, but i want to know how to handle the problem if i have used /
07:38:41 <aristid> :t floor
07:38:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:38:50 <wires> for instance, for Java you have this package called "hazelcast" which, I quote, provides "an open source clustering and highly scalable data distribution platform for Java"
07:38:58 <wires> I'm looking for something similar for haskell...
07:39:07 <aristid> take (floor (fromIntegral (length list) / 2)) list
07:39:29 <aristid> outsid3r: but that solution is really stupid :P
07:39:52 <hpc> wires: http://www.haskell.org/pipermail/haskell-cafe/2010-February/073208.html
07:39:52 <hpc> ?
07:39:54 <outsid3r> i see
07:40:08 <hpc> there are probably clustering libs in C too
07:40:13 <hpc> which you could wrap around
07:41:42 <wires> hpc: Ah I did not think of wrapping some C lib... or maybe I should use something like redis
07:42:18 <wires> hpc: as for BERT that looks nice, at the moment i'm using zero mq with protocol buffers for communication
07:42:45 <hpc> the wiki page for redis makes it look a lot like sql
07:42:57 <hpc> albeit fancier
07:43:30 <rwbarton> astroboy: catch (return $ blah) (\_ -> ...) will never do what you want
07:43:32 <dankna> it's key-value
07:43:37 <outsid3r> what `  ` is ?
07:43:39 <dankna> ie a hierarchical database, not a relational one
07:44:06 <hpc> outsid3r: infix notation
07:44:15 <outsid3r> what is infix notation?
07:44:16 <hpc> x `something` y == something x y
07:44:20 <outsid3r> ah k
07:44:29 <outsid3r> using the function as an operator
07:44:34 <rwbarton> astroboy: because catch only catches exceptions during the execution of its first argument, and return is lazy
07:44:45 <hpc> it's the opposite of (<symbol>)
07:44:51 <wires> hpc: yes it's a key value store, think of a distributed Map with JSON documents as values
07:44:51 <hpc> (note parens)
07:44:59 <hpc> wires: ah k
07:45:13 <kmc> wires, if you don't need compatibility with other languages, then Data.Binary is probably a better choice than protobuf
07:45:48 <kmc> wrapping C libs is not so hard, RWH has a good chapter about this
07:46:58 <ezyang> Doing it well is hard :-) 
07:47:26 <outsid3r> i've done it :P  the exercice was: let half l = (take ((length l) `div` 2) l, drop ((length l) `div` 2) l)
07:47:35 <outsid3r> returning a tuple with the list splited in 2
07:47:46 <wires> kmc: why is it better? speed? usability?
07:47:55 <wires> less work
07:48:01 <kmc> all of the above
07:48:11 <kmc> i've used protobuf a bit and was not impressed
07:48:15 <astroboy> rwbarton: yeah I get the issue now, too bad that they're using error
07:48:17 <kmc> the Python bindings were terribly dog slow
07:48:30 <kmc> you might also look at Thrift
07:48:35 <kmc> which is similar to protobuf
07:48:38 <kmc> used extensively at Facebook
07:48:43 <kmc> and has Haskell bindings
07:48:55 <kmc> but anyway for just serializing data to/from Haskell, Binary is a good choice
07:48:57 <Maxdamantus> > let half l = splitAt (length l `div` 2) l
07:48:57 <lambdabot>   not an expression: `let half l = splitAt (length l `div` 2) l'
07:49:07 <Maxdamantus> > let half l = splitAt (length l `div` 2) l in half "foobarbaz"
07:49:07 <lambdabot>   ("foob","arbaz")
07:49:09 <wires> kmc: k, thanks
07:50:48 <Maxdamantus> > let half = join $ splitAt ((`div` 2) . length) in half "foobarbaz"
07:50:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:50:49 <lambdabot>         against inferred type ...
07:51:22 <Maxdamantus> > let half = join $ splitAt . ((`div` 2) . length) in half "foobarbaz"
07:51:23 <lambdabot>   ("foob","arbaz")
08:02:20 <wires> kmc: hpc: ah, so yes. I was thinking, why am I not using, say, redis for storing data. The problem is that I need to store immutable values and full their change history. So for instance, in Clojure such data structures are implemented using very wide "tries"...
08:02:51 <wires> But I cannot store a full document for every revision (that would grow to large), nor can I store all the operations, because then I need to query all of them to reconstruct some revision..
08:03:56 <wires> So I really want to use fully persistent (in the sense of history preserving) immutable datastructures and store them in a clustered way...
08:04:15 <kmc> so you want some way of serializing those trie structures while preserving sharing
08:04:18 <kmc> that should be doable
08:04:27 <wires> yes
08:04:44 <kmc> read "Type-Safe Observable Sharing in Haskell"
08:04:51 <hpc> on the "store full doc" vs "store revisions":
08:04:58 <kmc> and also take a look at the "vacuum" library
08:05:03 <hpc> video files store keyframes every few seconds, which are full images
08:05:10 <hpc> then diff for each frame in that period
08:05:16 <hpc> so you could do something similar
08:05:27 <hpc> keyframe every 20 revisions or so
08:05:37 <hpc> for each file
08:05:51 <wires> kmc: k, let me check thanks
08:06:02 <whald_> does anyone here have experience with haskell on gentoo? would I install hlint using "cabal install" or pick the one from the overlay?
08:06:30 <wires> hpc: that won't work, for a nr of reasons. mainly you w
08:06:41 <wires> hpc: oops i was still typing :)
08:07:21 <dankna> wires: how many gigabytes/terabytes is the dataset?
08:08:40 <wires> hpc: point is when you add something to a immutable persistent list, all old revisions should remain accessible and at the same time you want similar performance as a "regular" list. say O(1) for adding...
08:08:42 <vlprans> whald_: I personally prefer installing Haskell packages using ebuilds from gentoo-haskell overlay. If I can't find something that I need there, it is trivial to create ebuild for it.
08:09:42 <wires> dankna: Very big, but with many sharding possibilies
08:10:20 <whald_> vlprans: thanks, compiling using cabal gives strange errors anyway
08:10:40 <wires> dankna: you would have I think at most 1G of related data...
08:12:07 <dankna> well, that doesn't strike me as "very big", honestly, but it's at least big enough that we're talking about serious database engines here
08:12:34 <dankna> one data structure you might try -
08:13:02 <dankna> store your "list" as a tree.  to do an insert, construct a new tree which reuses nodes of the old one except where they differ.
08:13:08 <wires> dankna: you would have millions of such items, so total set would be very big
08:13:12 <dankna> oh, okay
08:13:36 <dankna> so each data item is <= 1G, and there are millions of such items, so we're talking thousands of terabytes, whatever that unit is called :)
08:13:52 <kulakowski> dankna: peta-
08:13:52 <dankna> well, that is indeed a serious app
08:13:55 <dankna> thank you
08:14:10 <wires> dankna: ah ok, so i think want you mention is like the trie based approach to persistent DS like clojure
08:14:17 <kulakowski> or pebi, if you are into that
08:14:40 <dankna> I'm not familiar with clojure's specifics, but yes, a structure like that.  you can certainly find backends that will already implement it for you, or you can roll your own.
08:14:58 <dankna> given that reliability is probably a concern I think you want to be using an off-the-shelf backend.
08:15:50 <dankna> I know Oracle is expensive, but at least there's no way it'll lose your data
08:16:12 <kmc> it's easy to implement hash-mapped tries like clojure's in Haskell
08:16:19 <kmc> in fact there are several libraries that do just that
08:16:40 <kmc> although Clojure uses high-arity tries that are probably superior to the binary tries in Data.HashMap and such
08:16:42 <ski> robryk : ok .. though in truth, i hadn't even read what you were talking about (list fusion) at the time .. (so i wonder how those concurrency abstractions i linked could be useful for that)
08:16:51 <kmc> the hard part here is serialization with sharing, imo
08:16:55 <aristid> dankna: do you think oracle is that much more reliable than, say, postgresql?
08:16:57 <dankna> kmc: I'm making a case that he should avoid roll-your-own solutions and go for big-name database engines here.
08:16:58 <wires> kmc: totally, that makes them efficient
08:17:21 <dankna> aristid: I think Postgresql hasn't been as heavily tested with petabytes of data, yes.
08:17:33 <kmc> anyway you could implement a 32-ary trie in Haskell, and with more effort you could even make it use packed representations
08:17:51 <aristid> dankna: i do think postgresql stores vast amounts, probably petabytes of data.
08:18:06 <wires> regarding the size, imagine a giant graph, but it permits a partition into subgraphs, so these subgraphs dont "reference" any data outside them
08:18:17 <dankna> I'm sure it has no implementation limits, yes.  I'm just saying you'll be on the frontier of what's been done with it if you do that.
08:18:26 <wires> the subgraphs can be very small 1K or quite big say max 1G
08:18:59 <dankna> and encountering "fun" situations that haven't arisen for anybody else because you're the first one doing what you're doing
08:19:03 <aristid> for graphs, oracle is probably not the best fit
08:19:12 <dankna> oh, I missed that it was a graph
08:19:19 <dankna> sorry, I did come in late
08:19:31 <wires> dankna: I don't think I mentioned it before
08:19:33 <aristid> dankna: i did come in late too, but wires keeps saying stuff like "subgraphs"
08:19:36 <dankna> wires: what on Earth is your problem domain.
08:19:49 <wires> haha
08:20:06 <dankna> wires: that level of variance is astonishing.  Knuth:  "I would never walk from LA to NYC, but flying there is ONLY 150 times faster."
08:20:21 <wires> hahaha
08:20:36 <wires> i'm rewriting a process engine from java to haskell
08:20:42 <edwardk> kmc: tibbe is actually in the process of building said 32-ary trie
08:20:56 * ddarius would walk from LA to NYC if he ever wanted to go from one to the other.
08:20:56 <wires> the process model is a graph, and the stuff I need to store is runs of the processes
08:21:21 <dankna> sorry, I'm not familiar with the term.  you mean like an OS that runs on the JVM and manages subprocesses?
08:21:27 <wires> runs can be short, say 10 transitions, with little data, or long and big, they can be short running or long running etc...
08:21:43 <wires> dankna: no think about a finite state machine
08:21:47 <aristid> wires: and you want to store the process model in a data base?
08:21:48 <dankna> oh, like an experimental process?
08:22:09 <mreh> conal: hello, have you been asked before about removing category extras from reactive, it's been depracated
08:22:29 <wires> aristid: I want to store, doesn't matter where :)
08:22:37 <conal> mreh: no. what's category extras?
08:22:41 <aristid> conal: plus, edwardk complained about reactive's QuickCheck dependency.
08:22:56 <aristid> wires: do you need to change the graph often?
08:23:24 <edwardk> aristid: i was mostly griping because for some reason i couldn't build it ;)
08:23:30 <wires> aristid: it's immutable, but I do operations on it yes, so I get a new revision, not to often
08:23:31 <dankna> okay, so the process graph itself is small; the data from process runs is the voluminous stuff.
08:23:44 <aristid> edwardk: that's a valid reason for complaining, i think :)
08:23:54 <mreh> conal: it's got thinks like comonads, and copointed in it
08:23:56 <conal> aristid: i haven't heard edwardk's QC complaint yet.
08:24:00 <mreh> things*
08:24:01 <wires> edwardk: kmc: thanks I'll look into these tries by tibbe, prob. on github?
08:24:01 <edwardk> conal: i started hacking together a patch to replace the dependency on category-extras in reactive with dependencies on the smaller splintered package
08:24:23 <aristid> conal: that's why i parroted it.
08:24:23 <edwardk> wires: not sure, copumpkin knows
08:24:27 <tibbe> wires: http://github.com/tibbe/unordered-containers
08:24:30 <wires> dankna: yes
08:24:38 <copumpkin> tibbe also knows! :)
08:24:39 <conal> mreh: oh! i parsed "category extras" as a cabal category. :)
08:24:48 <dankna> I'm imagining that your problem domain is something like, you have a fusion reactor; usually the fusion lasts mere nanoseconds and there's not much data, but occasionally it lasts several seconds instead; and both types of run are significant experimentally because you want to analyze the difference between them.
08:24:52 <edwardk> conal: =)
08:24:56 <dankna> I'm making this example up obviously
08:24:56 <mreh> conal: just woken up? ;)
08:25:01 <dankna> but it's something roughly like that?
08:25:05 * hackagebot semigroups 0.3.4.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.3.4.1 (EdwardKmett)
08:25:05 <wires> tibbe: funny I was looking at that a few days ago trying to figure out what it was :) looked interesting
08:25:09 <conal> mreh: hah. more or less.
08:25:31 * conal checked the cabal categories for reactive and didn't find "extras".
08:25:52 <dankna> I think what you are going to want to do, wires, is treat the "large" runs specially
08:25:55 <wires> dankna: haha sure; but think more of processes like a callcenter or getting your phone subscribed etc..
08:26:01 <dankna> gotcha.
08:26:04 <mreh> conal: category-extras
08:26:11 <conal> now i get it.
08:26:15 <mreh> the package
08:26:18 <conal> so category-extras is deprecated?
08:26:30 <mreh> edwardk: ^^
08:26:32 <edwardk> conal: the pieces of category-extras that you use have been factored out into smaller packages to make them more palatable
08:26:47 <Dae> dankna, I honestly can't tell if you're talking about stream-fusion in ghc or physics :p
08:26:54 <edwardk> conal: Pointed/Copointed is in 'pointed', Comonad is in 'comonad', etc.
08:26:54 <dankna> Dae: lol, physics
08:27:04 <conal> edwardk: ah. thanks. :)
08:27:07 <mreh> certain orphan instances in category-extras are clashing with other packages 
08:27:18 <dankna> Dae: remember, don't cross the streams!  except at the climax of the movie.
08:27:41 <edwardk> conal: a better stream package is built on top, etc. hence why i started taking it up to see what would be involved in updating reactive. mostly so i could use it again ;)
08:27:55 <edwardk> that and its probably the biggest consumer of the existing category-extras
08:28:10 <dankna> wires: do a size check on each data item.  for a large run, store it as a sequence of changes and pray that you'll never have to reconstruct a past state.
08:28:21 <conal> edwardk: cool.
08:28:29 <dankna> wires: for a small run, store it in full; you could store ALL your small runs in full in the space that you would use for just ONE of the large runs.
08:28:32 <mreh> i wish I could help, but I have no idea what a comonad is
08:28:40 <dankna> a comonad is like a coburrito
08:28:42 <mreh> i enjoyed the paper though
08:28:53 <Jesin> @hoogle CReal
08:28:53 <conal> dankna: the other way around.
08:28:53 <lambdabot> No results found
08:28:57 <Dae> dankna, I had a subroutine called "GHOSTBUSTERS" in a piece of russian fortran. I was laughing for the next 5 minutes
08:28:58 <wires> dankna: haha no praying :) .. I can (and do) store very large documents outside of the graph.. but for most past I can keep it in memory actually
08:29:00 <dankna> conal: "is like" is typically commutative
08:29:03 <dankna> Dae: haha awesome
08:29:06 <Jesin> what was that thing for infinite precision real computation
08:29:09 <Jesin> was there something like that
08:29:11 <dankna> wires: okay, good
08:29:30 * roconnor thinks there should be an extra category-extras category in cabal.
08:29:30 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
08:29:31 <conal> dankna: except for intent -- describe unfamiliar via familiar
08:29:35 <dankna> wires: the other thing to do is pay attention to how the data is actually being used - that is, how do you need to QUERY it
08:29:41 <dankna> conal: fair enough
08:29:43 <edwardk> danka: that "is like" totally not true ;)
08:29:51 <dankna> edwardk: lol
08:29:58 <dankna> totally not true "is like" that!
08:30:06 * hackagebot streams 0.6.1.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.6.1.1 (EdwardKmett)
08:30:15 <edwardk> roconnor: hrmm, just so you can find the bits and pieces?
08:30:22 <kulakowski> Jesin: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Real_and_rational_numbers has several such somethings
08:30:40 <edwardk> roconnor: i had planned to capstone this project by uploading a category-extras package that depended on all its fragments
08:30:49 <roconnor> edwardk: Ya, but I mostly said that cause it sounded nice to write
08:31:05 <roconnor> that's good
08:31:07 <wires> dankna: I walk up and down the revisions and read the whole documents, at the same time i'm persisting asynchronously to a search index for search queries and hadoop for offline calculations
08:31:14 <roconnor> no one even uses the categories in hackage anyways
08:31:40 <mreh> that's why it's been updated
08:31:42 <aristid> roconnor: well, that's an exaggeration
08:31:53 <roconnor> yes
08:31:54 <mreh> being*
08:32:33 <dankna> wires:  okay.  what I would do then is, for each large dataset, store *the latest* revision in full, and also store a list of changes.  with each change, store both "forward" and "backward" information.
08:32:52 <Jesin> huh
08:32:54 <Jesin> http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
08:32:57 <mreh> anyway, can't wait to start using reactive after reading your paper conal
08:32:59 <Jesin> "data CReal = CR_ (Int -> Integer)"
08:33:11 <Jesin> so that means there is a limit on the precision of this thing
08:33:20 <Jesin> proportional to maxBound :: Int
08:33:28 <dankna> wires:  this will take roughly three times as much storage as is strictly necessary in an information-theoretic sense, but three is a "small constant factor"; if that's an issue, buy more hardware
08:34:02 <conal> mreh: i'm glad to hear the paper inspired you. the implementation is still broken, afaik. subtle space/time leaks and/or nontermination (?).
08:34:04 <kulakowski> Jesin: Is it any worse of a bound than your memory?
08:34:12 <Jesin> I guess not  :p
08:34:15 <dankna> wires:  now you can have one revision (on disk) which is updated mutably and also the log (probably on a separate spindle).  together they are sufficient to reconstruct any past state.
08:34:24 <Jesin> I wonder if Word -> Integer
08:34:24 <dankna> wires: and you can efficiently go from any past state to any "adjacent" past state
08:34:26 <Jesin> would be better
08:34:29 <Jesin> or if that would break something
08:34:41 <mreh> conal: it's still fundamentally sound though
08:34:43 <dankna> wires: that's what I get out of your description of it as "walking" - that you proceed from one state to an adjacent one
08:35:36 <kmc> the more serious limit on the precision of CReal is that the function may take a very long time to produce even a small number of digits
08:36:13 <conal> mreh: i think so. though i've never been confident in the "legacy adapter" aspect (wrapping externally generated events). haven't seen how to structure that aspect in an elegant & compelling way.
08:36:54 <conal> mreh: oh, and the whole Event part deviates from the TCM principle. 
08:37:09 <dankna> wires: (also put your search index on another spindle, but that's obvious)
08:37:13 <ddarius> conal: Without a model of the "legacy" parts, you'd have to treat them through their external behavior only.
08:37:17 <conal> mreh: and correspondingly has some troubling symptoms
08:37:38 <conal> ddarius: yeah.
08:38:00 <mreh> TCM principle?
08:38:21 <conal> ddarius: which seems simple enough when i think about it, but always got complicated in my code. tells me something in my thinking is fuzzy.
08:38:25 <conal> mreh: type class morphism
08:38:28 <mreh> oh
08:38:29 <dankna> wires: also, storing the changes explicitly will in theory make your search-indexing faster because it can inspect only the region of the change.
08:38:52 <mreh> i think i saw the trac page for that
08:39:04 <conal> @where TCM
08:39:04 <lambdabot> http://conal.net/papers/type-class-morphisms/
08:39:07 <dankna> wires: making sense?  anything I can clarify?
08:40:01 <wires> danka: thanks, it makes sense
08:40:29 <dankna> good :)
08:41:51 <wires> dankna: I will read a bit about what kmc mentioned and i'll check out tibbe's code and think for a bit...
08:41:54 <wires> thanks all for your input
08:42:14 <dankna> good luck!
08:51:10 <edwardk> conal: btw- there are some comments in src/FRP/Reactive/Behavior.hs seeking a comonad for arbitrary compositions, said comonad does not exist, so you can rest easy that you weren't able to figure it out ;)
08:51:38 <conal> edwardk: thx.
08:52:29 <FcoJavier> Hello there
08:53:31 <djahandarie> edwardk, cool. But I don't think you actually have the rewrite rule in there, do you?
08:54:08 <djahandarie> Or is it somehow no longer necessary?
08:54:11 <edwardk> djahandarie: well, folding a Mu does evaluate to what you'd expect from fusion, i don't have the rewrite rule to automatically lift into Mu though
08:54:52 <edwardk> its kind of like how Yoneda reiies map/map fusion into code. Mu is enforced foldr/build fusion as a type
08:55:02 <edwardk> re reifies
08:58:50 <edwardk> conal: i have a hacked up reactive that i could get to build with the new plumbing, but i haven't added all the instances that i could yet
08:59:41 <conal> edwardk: how hacked up? 
09:00:17 <byorgey> hi hi FcoJavier 
09:00:42 <byorgey> don't ask me why I just wrote 'hi' twice
09:00:52 <edwardk> well, i can't get your checkers stuff to install, so i added a cabal flag to manage all the test machinery. otherwise, the main shifts are a few Semigroup dependencies here and there, and a couple of extra instances added to support stuff like Apply, Bind, Extract with the more general signatures
09:01:04 <edwardk> https://github.com/ekmett/reactive
09:01:08 <conal> edwardk: i'm guessing you didn't start with the cabal repo, since my code.haskell.org account hasn't be reactivated yet.
09:01:20 <edwardk> i started with the one on code.haskell.org
09:01:36 <conal> (i've asked the c.h.o folks)
09:01:44 <copumpkin> byorgey: why'd you write 'hi' twice?
09:01:46 <copumpkin> oh shit
09:02:48 <edwardk> conal: here is the diff of what i did. perhaps it explains better than i can: https://github.com/ekmett/reactive/commit/ebe5414e4f04ed9b072ebe870136b84778fa3745
09:03:13 <Dae> Seems like a lot of code.haskell.org pages are still down. Hmatrix for instance :(
09:03:25 <jmcarthur> edwardk: http://stackoverflow.com/questions/5057136/real-world-applications-of-zygohistomorphic-prepromorphisms
09:03:26 <conal> edwardk: ah. the reactive isn't in my user account so didn't get munched.
09:03:55 <conal> edwardk: thx for the commit ptr
09:04:02 <byorgey> hi hi copumpkin 
09:04:45 <edwardk> jmcarthur: i'll at least post the comment that the signature has changed
09:04:55 <djahandarie> Aw, I was going to do that :(
09:05:06 <jmcarthur> heh
09:05:16 * hackagebot certificate 0.7.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.7.0 (VincentHanquez)
09:05:18 * hackagebot Agda 2.2.10 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.2.10 (NilsAndersDanielsson)
09:05:24 <copumpkin> ooh
09:05:30 <jmcarthur> yay!
09:05:47 <copumpkin> not that I go by the cabal releases
09:05:58 * jmcarthur awaits the accouncement
09:06:17 * hackagebot Agda-executable 2.2.10 - Command-line program for type-checking and compiling Agda programs  http://hackage.haskell.org/package/Agda-executable-2.2.10 (NilsAndersDanielsson)
09:06:24 <jmcarthur> i go by the cabal released because i don't use it enough to justify tracking the head
09:06:29 <jmcarthur> *releases
09:08:40 <edwardk> conal: i can understand why you might not want to factor out the test stuff like that, but the rest should be rather faithful to your existing model
09:09:17 <conal> edwardk: i'm torn about the test aspect. i like how you did it.
09:10:42 <jmcarthur> i always do test code with a cabal flag, personally
09:10:54 <jmcarthur> to reduce dependencies and unnecessary exports
09:11:51 <MichealH> babuch, I see you found it :D
09:12:05 <babuch> thanks MichealH
09:12:17 <jmcarthur> :D
09:12:52 <edwardk> conal: ideally i'd like to just have a reactive-quickcheck package that provides the test suite, but the you might have to expose a couple of extra internal modules
09:13:16 <babuch> hello all
09:13:23 <babuch> i am new to #haskell 
09:13:30 <edwardk> jmcathur: yeah
09:13:32 <conal> edwardk: yeah. that's the dilemma i wrestled with.
09:13:48 <edwardk> jmcarthur: the problem there is it compromises the ability of folks to build on your tests
09:13:53 <babuch> i would like to learn and contribute to Haskell
09:14:06 <edwardk> jmcarthur: i don't find that to be a problem in practice, but YMMV.
09:14:11 <conal> edwardk: i like how you split the Monoid instances for Min & Max into Semigroup & Monoid, since the monoid part is less solid (depending on half of Bounded).
09:14:21 <outsid3r> why in haskell i see 'xs' name as a parameter lots of times?
09:14:26 <jmcarthur> edwardk: i just use some #ifdefs to control what's exported based on the config flags
09:14:37 <geheimdienst> babuch: welcome and thanks for any contributions. have you checked out the "learn you a haskell" tutorial?
09:14:40 <geheimdienst> @where lyah
09:14:40 <lambdabot> http://www.learnyouahaskell.com/
09:14:41 <jmcarthur> edwardk: so you can still get to the tests externally if built with the test flag
09:14:49 <edwardk> conal: came along naturally from the fact that i already had the semigroup for Min/Max in the semigroup package
09:15:03 <edwardk> jmcarthur: the problem is you can't depend on a package that is built with a particular flag.
09:15:08 <jmcarthur> i wish you could specify in a cabal project that you want dependencies build with a flag though
09:15:12 <jmcarthur> yeah that ^^
09:15:20 <ceii_> outsid3r: that's the plural of x, it usually refers to a list
09:15:24 <jmcarthur> but that's a cabal issue, not really a package issue
09:15:24 <edwardk> so everyone downstream becomes brittle
09:15:35 <jmcarthur> to fix it is like one extra command
09:15:38 <outsid3r> ceii_: k
09:15:43 <edwardk> well, our packages live on cabal, so its our issue ;)
09:15:51 <jmcarthur> yeah it's brittle and it sucks and i want it fixed, but i don't think it's the end of the world
09:15:54 <edwardk> yeah but it brakes autoinstalling
09:16:33 <edwardk> it is totally the end of the word. the seventh seal is broken, end times are nigh.
09:16:54 <mwc> instance Exception SeventhSeal where ...
09:17:05 <mwc> I'm totally slipping that in someplace this week
09:17:19 * hackagebot tls 0.3.3 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.3.3 (VincentHanquez)
09:17:23 <edwardk> mwc: somehow i knew that starting the apocalypse would require IO
09:18:00 <edwardk> mwc: actually you can start the apocalypse purely with throw. its _stopping_ the apocalypse that requires IO. =/
09:18:07 <mwc> I was going to say
09:18:12 <mwc> somehow that seems backwards
09:18:34 <mwc> as the apocalypse is the mother of all destructive updates
09:18:44 <jix> but the apocalypse shouldn't matter to you as long as you stay with pure code I'd say
09:19:07 <edwardk> jix: pure _total_ code ;)
09:19:18 <DataStorm> to have a pure apocalypse?
09:20:00 <mwc> So then my immortal soul is pure, and my body is merely an IO husk?
09:20:03 <edwardk> great now i'm seeing morality plays as a choice between the good continuation and the bad continuation
09:20:38 <DataStorm> ehm is there such?
09:20:45 <RichardO> We are all monads?
09:20:51 <mwc> edwardk: clearly a good morality play is merely one in wich the good continuation and bad continuation are apparently indistinguishable
09:21:06 <DataStorm> cos morality stems from theisms
09:21:34 <mwc> DataStorm: my ethical naturalism would beg to differ
09:21:46 * mwc directs DataStorm to a Sam Harris book
09:21:53 <DataStorm> there is no "good" or "bad"
09:22:40 <mwc> Not intrinsically, but of course the fact that you have identity leads to a reflection of good and bad on the world that is consistent with your own identity
09:22:50 <mwc> and now off to #-blah
09:24:12 <DataStorm> thats false, another personal interpretation of such.
09:25:28 <conal> edwardk: are you getting some kind of usefulness out of reactive?
09:26:31 <jix> btw is there any reason that in TTFP stability of typing under evaluation (or whatever it was called) is just stated as a rule, while in TAPL it is always proved from the evaluation/typing rules.. or did I miss something somewhere (I haven't finished both of them yet)
09:27:22 <ddarius> copumpkin: What's new in Agda 2.2.10?
09:27:27 <edwardk> conal: not at present. i've kind of gone in exactly the opposite direction, and been exploring a very imperative model in the style of .net's reactive framework
09:28:37 <edwardk> datastorm: personally i'm basically a secular humanist, but I find that dogma provides for better in-jokes ;)
09:28:44 <conal> edwardk: ah. okay. i keep wondering when to give reactive another go. to rethink/redesign the legacy adapter stuff cleanly and retackle the subtle termination issues.
09:29:44 <copumpkin> ddarius: not sure, I usually work off the darcs version so don't remember what has changed since 2.2.8
09:29:49 <copumpkin> probably all the irrelevance stuff is new
09:30:28 <edwardk> conal: i've done a fair bit of work on this since, but https://github.com/ekmett/reactor/blob/master/Reactor/Observable.hs is the basic monad i've been using
09:31:43 <edwardk> conal: it gives me a monad for merging and manipulating event streams and futures, which is internally quite imperative but exposes a pure interface
09:31:55 <conal> edwardk: do you have any plan of somehow pulling back from IO into something with semantics that supports rigorous reasoning.
09:32:15 <edwardk> the end goal is that end users won't code in terms of the 'Task' monad, they'll work in Observable, etc. which does just that.
09:32:29 <conal> edwardk: oh -- a pure interface.
09:32:44 <edwardk> so you can reason about the code written in terms of Observable, and then wire up your evil imperative Observers.
09:32:58 <conal> edwardk: people use "pure" in various ways. will your "pure" type have a tractably simple denotation?
09:33:21 <conal> (meaning the type you described as pure, not one called "pure")
09:33:27 <edwardk> conal: well, i stole the denotation from the ball diagrams used by the microsoft folks
09:33:36 <edwardk> which is rather nice to use in practice
09:33:52 <conal> edwardk: do you have a pointer? i'd assumed they were going without denotation.
09:34:04 <ddarius> "Ball diagrams"?
09:34:37 <edwardk> ddarius: lemme find you an example
09:35:04 <Fatalnix> Good morning :)
09:35:10 <micahjohnston> is anyone interested in designing a good frp system?
09:35:16 <edwardk> http://channel9.msdn.com/blogs/j.van.gogh/reactive-extensions-api-in-depth-selectmany sorry, 'marble diagrams'
09:35:17 <Fatalnix> Nevermind it is actually 1 PM
09:36:00 <conal> edwardk: thx. i'll check it out when i'm in civilization.
09:36:02 <edwardk> http://channel9.msdn.com/Blogs/J.Van.Gogh/Reactive-Extensions-API-in-depth-Until-and-WaitUntil is a more minimal one
09:36:13 <ddarius> Yay above freezing temperatures!
09:36:25 <Fatalnix> So I think I'd like to learn Haskell, I'm browsing the site now, reading about it :). Is Haskell strong with network programming?
09:36:41 <micahjohnston> conal: I'm really interested in designing a good FRP system
09:36:54 <micahjohnston> conal: do you care about that stuff right now?
09:37:00 <conal> micahjohnston: glad to hear! 
09:37:19 <edwardk> conal: i went down this road mainly because it let me work without the notion of globally consistent time, which as you know, i abhor. ;)
09:37:20 <roconnor> wow, the anti-formalizism in the mathematics comunity is striking!
09:37:26 <conal> micahjohnston: yeah, i still care. have been pursuing that goal for a long time.
09:37:30 <micahjohnston> :D
09:37:35 <edwardk> roconnor: ?
09:37:45 <conal> edwardk: i didn't know, but i'd expect you to.
09:37:54 <ddarius> roconnor: Computer scientists were always the real formalists.
09:38:00 <roconnor> edwardk: I'm reading the comments to is mathoverflow question: http://mathoverflow.net/questions/55458/writing-semi-formal-proofs
09:38:05 <roconnor> ddarius: indeed :D
09:38:40 <roconnor> ddarius: the amount of anti-formailism in the programming comunity is also striking!
09:38:58 * roconnor subtly switched computer scientist with programmer
09:38:59 <conal> micahjohnston: what kinds of "good" are you going for in a "good FRP system"?
09:39:11 <Philippa> roconnor: "But I don't like calling my formalism a formalism!"
09:39:16 <ddarius> edwardk: I like how he uses the bind formulation of SelectMany instead of the primitive one that is used.
09:39:17 <edwardk> roconnor: ultimately a proof is a vehicle used to convince someone of an argument, some "people" happen to be computers, and require a higher bar for proof. ;)
09:39:45 <micahjohnston> conal: well, I read your post "garbage collecting the semantics of FRP", and I've been trying to think of a good model with integration, or some sort of possibly continuous scan, or something like that
09:40:02 <ddarius> edwardk: Yeah, torturing my computer didn't work at all.
09:40:10 <roconnor> edwardk: but it is strange they want such a low bar.  It's like they want to make mistakes or spend enormous man power to prevent mistakes
09:40:11 <edwardk> =)
09:40:22 <edwardk> i was going to say, for many people, a lead pipe is a convincing proof.
09:40:23 <kmc> there's no such thing as "the programming community"
09:40:40 <roconnor> ddarius: the amount of anti-formailism in a programming comunity is also striking!
09:40:48 <conal> micahjohnston: super. this topic drifted through my mind this morning in the shower. about FRP based entirely in "the now" in space & time.
09:41:09 <edwardk> roconnor: its a matter of pace. you can prove everything in incredibly formal language, but you'll probably retire before you reach the moving forefront of knowledge =/
09:41:15 <micahjohnston> conal: yeah, based in "the now" is sort of what I'm thinking of
09:41:49 <roconnor> edwardk: I don't know. I think programmers use that argument too in support of testing over proofs, but I still don't quite buy it.
09:43:01 <conal> micahjohnston: for me frp has always been centrally about two things: (a) precise & simple denotation and (b) continuous time. for reasoning/rigor and modularity, respectively.
09:43:42 <ddarius> roconnor: The trick is to change the goal.
09:43:56 <conal> also i really dislike the name "FRP" as it eliminated the part of the previous names that were most important to me. about time/behavior/animation.
09:43:57 * roconnor moves goal posts
09:43:58 <edwardk> personally my problem with frp is that it doesn;t have a good way to indicate in the type, the difference between induction and deduction, you can loop references as long as they look backwards in a well-founded fashion, or within a timestep as long as they don't transitively depend upon themselves. this is what drives me to bloom/daedalus/datalog-style models
09:44:06 <ddarius> See, programmers using testing aren't trying to produce correct programs whereas you with your proofs are.
09:44:14 <edwardk> roconnor: of course you don't. thats why you code in coq. ;)
09:44:26 <Philippa> roconnor: formalising stuff is definitely the last stage in knowing it fully for me, which means there's a need for ways of discussing things before that point?
09:44:42 <roconnor> ddarius: You really think programmers are not trying to produce correct programs?!  That would certain explain a lot.
09:44:45 <micahjohnston> conal: yeah, I like the name temporal functional programming better, but people don't know what it's referring to as much
09:45:07 <Philippa> roconnor: fundamentally, yeah. They're trying for Good Enough (For Now)
09:45:19 <roconnor> Philippa: I agree. but these people seem to think that that last stage is a waste.
09:45:20 <conal> micahjohnston: maybe that's a good thing. as people often know what "frp" is but they know incorrectly.
09:45:24 <edwardk> at least there i can know that for a given timestep the accumulation of knowledge will terminate
09:45:41 <micahjohnston> conal: hm, yeah
09:46:07 <Philippa> roconnor: it depends what you want the formalisation for. It's less of a waste for us because we can feed the formalism into a computer and let it do the work from there on out
09:46:31 <ddarius> roconnor: The point is you are not done until the program is correct.  They are done sooner.
09:46:36 <Philippa> (the average programmer isn't interested because they don't already have a big library of pre-proven stuff)
09:46:56 <Philippa> (which is to say: because they'd have to write /hard/ proofs for a bunch of stuff they basically know, and that's lots of work)
09:46:59 <roconnor> Philippa: some people argue that mathematicians waste their entire carear :D
09:47:17 <edwardk> roconnor: and then the next generation builds upon what they have done
09:47:18 <roconnor> ddarius: interesting
09:47:22 <Philippa> roconnor: but what about their cafront? :p
09:47:26 * hackagebot Thrift 0.5.0.1 - Thrift library package  http://hackage.haskell.org/package/Thrift-0.5.0.1 (KirkPeterson)
09:47:49 <roconnor> :D
09:47:52 <roconnor> *career
09:48:06 <conal> micahjohnston: "It ain't what you don't know that gets you into trouble. It's what you know for sure that just ain't so." - Mark Twain
09:48:16 <Philippa> roconnor: I don't believe that's the case for the most part. But then, around here I mostly trade in good informal intuition and signposting stuff for people
09:48:35 <micahjohnston> conal: so I was thinking, it's possible to make a model where temporal values are basically an initial value, and an iteration function that gets the previous value and dt, but it doesn't seem very elegant to me
09:48:36 <roconnor> :D
09:48:45 <Philippa> As the line goes, you can't go from the informal to the formal by formal means
09:49:06 <micahjohnston> conal: I want to keep dt hidden in the implementation
09:49:10 <ddarius> How are jets not elegant?
09:49:25 <roconnor> Philippa: no kidding
09:49:26 * hackagebot cassandra-thrift 0.7.2 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.7.2 (KirkPeterson)
09:49:39 <conal> micahjohnston: so the dt would be in the implementation or the model? by "model", do you mean denotational model?
09:49:57 <Jesin> > digits
09:49:58 <lambdabot>   Not in scope: `digits'
09:50:05 <Jesin> > CReal.digits
09:50:05 <Philippa> roconnor: I *do* think we'll see some improvements come out of wider uptake of CT, though
09:50:05 <lambdabot>   Not in scope: `CReal.digits'
09:50:12 <Jesin> > ICReal.digits
09:50:13 <lambdabot>   Not in scope: `ICReal.digits'
09:50:14 <micahjohnston> conal: my goal would be to have something with dt outside the semantic/denotational model, and only in the implementation
09:50:16 <Jesin> hm.
09:50:21 <roconnor> Philippa: category theory?
09:50:24 <Philippa> yeah
09:50:33 <roconnor> Philippa: uptake in CS or in mathematics?
09:50:37 <Philippa> yes :-)
09:50:51 <roconnor> I thought CT was fairly well absorbed into mathematics
09:51:14 <monochrom> there is much confusion or disagreement between "formal = use a precise language" and "formal = very detailed"
09:51:16 <Philippa> maybe, it's not exactly reached the pop sci front yet AIUI
09:51:28 <conal> micahjohnston: super. i wouldn't worry much about the implementation at the beginning. all to easy to let implementation issues cloud the semantic design.
09:51:29 <roconnor> Philippa: true
09:51:33 <Philippa> monochrom: yeah. I mean the former, the latter you avoid as much as you can :-)
09:51:59 <roconnor> and there is a lot of room for CT uptake in CS.
09:52:21 <Philippa> (I've not been reading the latest, but I believe pop sci's still at the level of differential equations and pretty rendering of topology?)
09:52:37 * ddarius wants to make a pretty rendering of topology.
09:52:41 <ddarius> Thanks for reminding me.
09:53:03 <roconnor> If I was the first to notice that lenses are the coalgebras of the costate comonad in November, then that feels really sad.
09:53:21 <roconnor> I feel like it was a very shallow observation.
09:53:36 <ddarius> roconnor: Coalgebras in general are under-utilized particularly in mathematics, but significantly in computer science as well.
09:53:43 <roconnor> or fruit so low it kinda knocks you in the head
09:53:45 <ddarius> roconnor: Aren't all CT observations shallow?
09:53:51 <micahjohnston> conal: the problem is, if you hide dt from the semantic model, then what axioms/primitives do you have in the semantic model that let you define what you want
09:53:53 <roconnor> ddarius: heh, maybe
09:54:07 <ddarius> roconnor: You probably already have, but look at J.J.M.M. Rutten's work.
09:54:18 <roconnor> ddarius: but people have had at least 15 years, if not much more, to make this observation.
09:54:34 <conal> micahjohnston: exactly! you're getting toward the central questions.
09:55:09 <roconnor> ddarius: anything in particular?
09:55:11 <Cale> roconnor: Have lenses as a concept really been around that long?
09:55:23 <ddarius> roconnor: The behavioral differential equations stuff is the stuff I like.
09:55:49 <ddarius> Though, if I recall correctly, he has some view-analysis-as-coalgebra stuff too that you'd find interesting.
09:55:51 <Cale> roconnor: I mean, obviously the technique is old, but actually naming it and recognising what it is abstractly and how they compose and all that.
09:58:38 <roconnor> Cale: I have a reference by Kagawa 1997 that talks about lenses (he calls it mutator), and he references even older works.
10:00:04 <micahjohnston> conal: integrals and derivatives are definitely quite useful in this kind of thing, so basically providing them as primitives like in Yampa is useful, but it seems like they're both examples of something deeper, integration using + and *, and derivation using - and /, and I'm wondering if it's possible to extend it to other functions
10:00:04 <ddarius> roconnor: Ah, it was Pavlović and Pratt's, "The continuum as a final coalgebra" that I was thinking of (for the view-analysis-as-coalgebra stuff.)
10:00:35 <ddarius> (And I always write "Borel" rather than "Baire" when looking for this.  Baire should be more notable.)
10:00:47 <dmwit> (asymmetric) lenses are just fibrations over categories of edits ;-)
10:00:53 <dmwit> Hardly anything to understand.
10:01:44 <conal> micahjohnston: yep. there's some fun stuff to be done there. in 1992 or so i did continuous-time virtual trackball expressed as an integral.
10:02:44 <christo_m> i have type Name = String defined at the top of my file
10:02:52 <christo_m> then make referenec to it later, and i get out of scope errors, any reason?
10:02:59 * ddarius wonders if atoms and right adjoints to exponentials would lead to anything for this aspect of FRP.
10:03:03 <mauke> christo_m: yes, you're doing something wrong
10:03:07 <dmwit> christo_m: Paste some code, e.g. to hpaste.
10:03:11 <dmwit> ?hpaste
10:03:11 <lambdabot> Haskell pastebin: http://hpaste.org/
10:03:18 <roconnor> ddarius: this is seems like an unlikely paper to make this observation about lenses
10:03:29 <c_wraith> christo_m: is "Name" in correct capitalization?
10:03:39 <c_wraith> > let True = False in 5
10:03:40 <lambdabot>   5
10:03:46 <c_wraith> > let True = False in True
10:03:47 <lambdabot>   True
10:03:51 <ddarius> roconnor: It wasn't suggesting it because it talked about lenses.
10:04:07 <roconnor> oh
10:04:09 <c_wraith> > let Name = 5 in Name
10:04:10 <lambdabot>   Not in scope: data constructor `Name'Not in scope: data constructor `Name'
10:04:13 <dmwit> > let !True = False in True
10:04:14 <lambdabot>   *Exception: <interactive>:3:4-16: Non-exhaustive patterns in pattern binding
10:04:15 <christo_m> http://hpaste.org/44181/lol  <there
10:04:17 <monochrom> what is "later"? in the same file? at the ghci prompt?
10:04:35 <monochrom> > "type" == "let"  {- for c_wraith -}
10:04:35 <lambdabot>   False
10:05:25 <christo_m> i jus know im going about this whole parser wrong
10:05:31 <christo_m> and ive pestered this channel enough the past few days
10:05:33 <mauke> christo_m: Name is a type, not a value
10:05:43 <mauke> christo_m: what is 'do Name' supposed to do?
10:06:00 <ddarius> mauke: Clearly Name.
10:06:12 <christo_m> funcname ::= Name {`.´ Name} [`:´ Name]
10:06:14 <monochrom> yeah, not sure what "do Name" is supposed to mean
10:06:16 <christo_m> so how am i supposed to do something like this
10:06:27 <christo_m> well, im trying to translate a grammar into parsec
10:06:47 <mauke> christo_m: then you need to translate Name first
10:07:11 <monochrom> "do Name" makes as much sense as "do String" and "do Int". you wouldn't write "do Int", would you?
10:07:20 <christo_m> right..
10:07:35 <christo_m> i kinda went into robot mode there and just kept doing it, i didnt think
10:07:43 <christo_m> im still not sure how to code it correctly though
10:07:48 <ddarius> The root of all problems.
10:07:51 <monochrom> that insults we robots!
10:08:29 <ddarius> monochrom: I don't see how it does.
10:08:55 <JuanDaugherty> insults intelligence
10:08:59 <mauke> isn't it "us robots"?
10:09:02 <monochrom> instead of "do Int" you would write or find a parser for numbers, call it "haha", then you would write "do haha". same for names.
10:09:31 <JuanDaugherty> automated intelligence = lack of attention to/awareness-knowledge of it the equation
10:09:38 <JuanDaugherty> *is
10:09:41 <monochrom> ddarius: Merriam-Webster entry for "intelligence" #5: the ability to perform computer functions. we robots actually think.
10:09:43 <christo_m> CharParser () String?
10:09:57 <micahjohnston> ddarius: what are atoms and right adjoints to exponentials?
10:09:58 <monochrom> unlink humans who just fire neurons
10:10:05 <ddarius> monochrom: Who said anything about "intelligence"?
10:10:28 <monochrom> I'm just equating thinking with intelligence.
10:10:34 <ddarius> That's silly.
10:10:47 <monochrom> alright then we'll just agree to disagree.
10:10:55 <ddarius> micahjohnston: The most compact way to answer that is T is an atom if (T ->) has a right adjoint.
10:11:04 <geheimdienst> yes, don't be silly, monochrom. thinking clearly has as much to do with intelligence as cats have with lols
10:11:16 <gigabytes> hello
10:11:30 <christo_m> i have a feeling this would have been easier with pyparsing
10:11:36 <micahjohnston> ddarius: what's a right adjoint? :P
10:11:38 <gigabytes> is there any way to make an infix operator with an higher precedence that the application operator?
10:11:46 <dmwit> No.
10:12:08 <gigabytes> dmwit: if the No was for me, thanks
10:12:13 <dmwit> Only record update is higher than function application.
10:12:13 <ddarius> micahjohnston: A functor U such that there's a natural isomorphism Hom(F-,=) ~ Hom(-,U=).
10:12:50 <micahjohnston> ddarius: ugh, sorry, I'm not familiar enough with this stuff
10:13:34 <dmwit> micahjohnston: Some people assume that the person asking a question knows everything except the answer to the question. Some people assume that the person asking a question knows nothing, and wants a tutorial from the bare metal up to the answer to the question.
10:13:38 <dmwit> Both are annoying in their own way.
10:13:54 <christo_m> monochrom: should i leave type Name = String as it is or do something different?
10:13:55 <dmwit> Anyway, ddarius takes the former approach. So ask the right questions, and he'll help you. But it might take a while. =)
10:14:08 <monochrom> does not matter.
10:14:19 <micahjohnston> dmwit: ok :P
10:14:34 <micahjohnston> ddarius: I know what an isomorphism is but I don't understand the Hom() ~ Hom() part
10:15:25 <ddarius> The second two papers here give a very incoherent formulation of the idea: http://www.acsu.buffalo.edu/~wlawvere/downloadlist.html  They are transcripts from a video is my understanding and presumably a large part of the incoherence.
10:16:23 <micahjohnston> conal: I have to go soon; it was nice talking with you about this
10:16:53 <conal> micahjohnston: :). let's talk more.
10:17:07 <conal> micahjohnston: as you progress.
10:17:26 <conal> micahjohnston: in your thinking about frp. or if you have questions about denotational design, etc.
10:17:46 <micahjohnston> conal: definitely :) thanks
10:18:48 <whald_> can someone here please help me clean up my gentoo ghc installation? i'm tumbling from one broken dependency to the next and don't seem to be able to make "ghc-pkg check" calm down...
10:21:30 <whald_> ghc-pkg seem to think there are lots of packages installed, but they are all missing a bunch of files
10:21:43 <wires> whald_: what about moving ~/.cabal/ and reinstalling? or global install?
10:22:35 <whald_> wires: i removed my ~/.cabal already, the errors remain
10:22:55 <parcs> whald_: how about ~/.ghc/?
10:23:01 <jmcarthur> micahjohnston, conal: denotative continuous-time programing!
10:23:03 <wires> whald_: oops..
10:23:09 <whald_> i also emerge -C 'd from dev/haskell/* 
10:23:10 <christo_m> monochrom: aside from that, what do you think of the code?
10:23:20 <christo_m> monochrom: am i on the right track.. kinda have to hand something in by tmw morning
10:23:45 <whald_> wires: wow, there's a ~/.ghc
10:23:50 <whald_> didn't know that
10:23:55 <whald_> :-)
10:24:25 <wires> me neither ;)
10:24:29 <whald_> wires: ghc-pkg is cool now, i'l see how far it takes me now, thanks! :-=
10:24:40 <wires> thank parcs :)
10:24:41 <jmcarthur> dang, i wanted to tell micohjohnston that i wanted to keep up with him too
10:25:07 <whald_> parcs: wires: thank you both :-)
10:34:11 <conal> jmcarthur: yes, denotative continuous-time programing.
10:36:17 <conal> (programming*)
10:36:24 <jmcarthur> :)
10:42:43 <brad_larsen> I'm having issues with FFI finalizers:  are foreign (i.e., non-Haskell) finalizers guaranteed to be run sequentially?
10:43:50 <brad_larsen> I have some finalization code written in C, but it is not thread-safe, so if Haskell runs that finalization code from several threads concurrently, things will blow up.
10:44:56 <brad_larsen> A brief look through the H98 FFI documentation seems to not say much about how finalizers are handled
10:45:50 <brad_larsen> just that how foreign finalizers that call into Haskell are handled is system-dependent
10:47:42 <jmcarthur> brad_larsen: no. finalizers have no guarantee on relative ordering. they don't even have guarantees that they will run at all
10:48:02 <mauke> this isn't about relative ordering
10:48:12 <Saizan> GHC has a kind of finalizers that are guaranteed to run iirc
10:48:26 <brad_larsen> jmcarthur: the h98 FFI docs say that finalizers are guaranteed to run before program termination
10:48:33 <brad_larsen> jmcarthur: and that is all
10:48:36 <jmcarthur> actually i was missing the qualification of "foreign" finalizers. i'm not sure what that means
10:48:51 <mauke> <brad_larsen> I have some finalization code written in C, but it is not thread-safe, so if Haskell runs that finalization code from several threads concurrently, things will blow up.
10:49:00 <brad_larsen> foreign finalizer == finalizer code written in a foreign language, e.g., C
10:49:09 <dmwit> brad_larsen: Can you wrap a Haskell lock around them and avoid the whole mess?
10:49:22 <dmwit> (They're IO actions, right?)
10:49:48 <robryk1> be careful
10:49:56 <robryk1> in ghc they cannot call back into haskell
10:50:07 <brad_larsen> dmwit: the finalizer is a c function, takes a pointer to a Foo and returns void (on the C side)
10:50:49 <brad_larsen> (ghc has a different module for foreign pointers that allows finalizers that can be regular Haskell code)
10:51:40 <brad_larsen> Foreign.Concurrent allows finalizers that are arbitrary IO actions
10:52:13 <brad_larsen> but I'd like to avoid ghc particulars as much as is reasonable
10:53:09 <dmwit> I see. Although the type says IO (), in fact it's restricted to C function pointers.
10:53:15 <dmwit> Sorry for the mixup.
10:53:51 <brad_larsen> dmwit: yes---using a regular Haskell IO action is system-dependent
10:54:23 <jmcarthur> ah i didn't even know that
10:54:31 <jmcarthur> shows how dependent on ghc i am, i guess
10:54:45 <brad_larsen> hehe
10:54:49 <robryk> even if now ghc executes them serially, it probably won't be true in some time
10:55:14 <robryk> when minor gcs will be able to run independently
10:55:37 <jmcarthur> robryk: and we have a parallel gc already. i'm not sure what it does with finalizers
10:55:51 <christo_m> anyone able to help me finish this damn LUA parser
10:55:53 <christo_m> im about to go insane
10:57:30 <robryk> yes, but i've seen some statements to the effect that minor g will run with no sycnhronization between threads sometime
10:57:51 <robryk> *minor gcs
10:58:37 <brad_larsen> ::sigh::, so I probably need to use a mutex in the C finalizer code
10:59:15 <jmcarthur> brad_larsen: yeah, looks like
11:04:17 <kafee> hi peoplo
11:05:56 <robryk> christo_m: don't know much about parsec, but am curious: how does `reserved "do"' work -- reserved is declared to be [String] sometime earlier
11:07:43 <christo_m> robryk: reserved is part of parsec
11:07:47 <christo_m> i think it just parses it as a single token
11:08:31 <christo_m> im feeling the noose around my neck, 3 days and i feel ive made little progress
11:08:49 <lispy> christo_m: what is going wrong
11:08:58 <lispy> christo_m: problems with parsec or what?
11:09:07 <christo_m> robryk: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
11:09:12 <christo_m> lispy: just problems in general
11:09:24 <christo_m> my lack of understanding of haskell, and parsec , i thought this could be a lovely learning experience
11:09:27 <christo_m> but it turned out to be hell instead
11:09:32 <lispy> hmmm
11:09:49 <lispy> christo_m: the most common pitfall with parsec is that people don't understand when they need to use 'try'
11:10:04 <lispy> (or they understand incorrectly :)
11:10:30 <christo_m> lispy: i know what try is for, its if i want the parser to pretend it hasnt recieved input, and continue 
11:10:34 <lispy> christo_m: can we help in some way?
11:10:41 <christo_m> usually because when using <|> it evaluates from left to right ,right?
11:10:48 <christo_m> it tries the first case , then the next, etc, but no backtracking
11:11:02 <lispy> christo_m: try is there to make it so that overlapping parsers do not overlap
11:11:39 <robryk> christo_m: i think you are missing some bindings for reserved to work: in lexical analysis chapter they rebing something.reserved as reserve toplevel
11:12:30 <christo_m> robryk, ive been using this guys work as reference http://tuomov.iki.fi/software/lua-xgettext/  
11:12:38 <lispy> christo_m: where is your code?  Can we take a look at it?  Any error messages?  (I may have to go in a few minutes)
11:12:54 <christo_m> lispy: a bunch of Name is out of scope errors, which i understand now, just not sure how to solve it
11:13:06 <christo_m> lispy: http://www.lua.org/manual/5.1/manual.html#8   theres the grammar i want to solve
11:13:09 <christo_m> err, implement
11:13:33 <lispy> christo_m: I see.  Well, the Parsec documentation you linked above is unlikely to match your version of parsec (it's very old documentation for the original release)
11:13:39 <christo_m> http://hpaste.org/44185/parser
11:14:03 <christo_m> i know statements arent defined correctly right now
11:14:11 <christo_m> im just trying to iron everything out before i make it too obfuscated
11:14:15 <robryk> christo_m: he defined reserved as a list of words in one file
11:14:27 <robryk> and defines it as a parser for parsing reserved words in another
11:14:28 <christo_m> robryk: thats what i have at the top of mine
11:14:34 <christo_m> hmm
11:14:40 <robryk> these aren't supposed to be in scope together
11:14:57 <robryk> and now you try to apply the list of words as a function to a word and get a parser
11:15:24 <lispy> craptex: this line looks suspicious to me: namelist = Name ; many (do char ','; Name)
11:15:27 <lispy> oops
11:15:30 <lispy> christo_m: ^^
11:15:31 <jimi_hendrix> is haskell well suited for making servers?
11:15:43 <c_wraith> jimi_hendrix: if it's not, I'm doing something wrong :)
11:15:45 <lispy> jimi_hendrix: take a look at snap it's a web server framework
11:15:55 <christo_m> lispy: i know
11:16:08 <jimi_hendrix> c_wraith, maybe you are xD
11:16:12 <c_wraith> jimi_hendrix: Though, if you're using ghc < 7, disable the parallel garbage collector in long-running processes!
11:16:14 <jimi_hendrix> lispy, alright
11:16:19 <christo_m> namelist ::= Name {`,´ Name}  I want to translate that line
11:16:20 <christo_m> how do i do it
11:16:22 <aristid> i think the most popular haskell web frameworks are snap, yesod and happstack
11:16:33 <christo_m> if i just saw some examples of the above grammar i pasted, id probably be able to hack it together myself
11:16:48 <christo_m> im not trying to have others do my homework for me, but at this point my heads exploding with anxiety
11:16:58 <mauke> christo_m: namelist = sepBy1 name (token ",")  -- or something like that, I'm not that familiar with parsec
11:17:13 <christo_m> mauke: that looks to simple, how does it account for no separation
11:17:14 <christo_m> ie, just a name
11:17:28 <lispy> christo_m: You may actually find Happy to be more natural here given that Happy takes something in BNF and gives you a parser.
11:17:33 <mauke> I dunno how; look at the source for sepBy1?
11:17:48 <lispy> ?src sepBy1
11:17:48 <lambdabot> Source not found. My brain just exploded
11:17:52 <mauke> can't be hard, though
11:18:00 <mauke> @hoogle sepBy1
11:18:00 <lambdabot> Text.Parsec.Combinator sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
11:18:00 <lambdabot> Text.ParserCombinators.ReadP sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
11:18:00 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
11:18:15 <christo_m> lispy: should i just switch to happy?
11:18:31 <mauke> sepBy1 x d = liftM2 (:) x (many (d >> x))
11:18:33 <lispy> christo_m: you'll start all over on the learning curve :(
11:18:40 <christo_m> i know
11:18:47 <mauke> ^ not the real source but something I made up
11:18:50 <christo_m> i decided on parsec because it does lexing too
11:18:59 <lispy> christo_m: I had a go at making a go-language parser in happy and I found that happy was easy but alex was hard. FWIW.
11:19:26 <lispy> christo_m: and the monad parsing in both is underdocumented
11:19:43 <christo_m> mauke: when you put the token keyword there, does it rely on any definition prehand?
11:19:50 <christo_m> is it more accurate to use token than char there
11:19:57 <christo_m> lispy: i see :(
11:20:09 <mauke> christo_m: yes, and it's not a keyword
11:20:22 <christo_m> mauke: say there is a keyword
11:20:26 <christo_m> like Lua's end
11:20:29 <mauke> you probably want something that parses a string, then skips any following whitespace
11:20:31 <christo_m> should i use reserved?
11:20:36 <mauke> dunno
11:21:28 <lispy> christo_m: I'd stay away from reserved for now.  You can implement what you need and people here seem to be unfamiliar with it
11:21:29 <robryk> christo_m: you want first to break it up into tokens on any whitespace, nonletters-nonumbers-not'_' and recognize reserved words, special chars, and words; right?
11:21:40 <christo_m> yes thats right
11:21:56 <christo_m> it would be enough for me to just give a file as input
11:22:00 <robryk> so first you probably want to use parsec's lexer for that
11:22:03 <christo_m> and have it output the parse, i dont need the AST or anything yet
11:22:31 <lispy> christo_m: You might try parser something simpler (say csv?) and then work up to Lua
11:22:34 <lispy> parsing*
11:22:55 <christo_m> lispy: i looked at the tutorial for it, its easy to understand
11:23:10 <christo_m> theres no easy transition to this, and ive been assigned this as my source language to compile to C
11:23:29 <christo_m> my biggest issue is translating the grammar directly
11:23:45 <hgolden> hi. has the wxhaskell darcs repo moved from code.haskell.org? if so, where is it now? thanks.
11:24:04 <lispy> hgolden: code.haskell.org is down at the moment
11:24:15 <robryk> christo_m: do you have a parser which lexes input right now?
11:24:23 <christo_m> robryk: no, i have what i pasted above
11:24:25 <christo_m> thats the code
11:24:26 <robryk> ok
11:24:49 <tprow> can I interface a HAskell-based IRC lib with a C-based IRC Client?
11:24:49 <lispy> christo_m: Okay.  I was thinking you might benefit from getting a bit more practice in with haskell and parsec before doing a full language parser.  Not because the language is hard to understand but because you mentioned being new to haskell and parsec.
11:24:53 <robryk> so first get the example from `Lexical analysis' in that tutorial/handbook
11:25:02 <hgolden> lispy: it's up for me, but wxhaskell isn't there.
11:25:08 <lispy> tprow: yes, there is a good FFI.
11:25:29 <lispy> hgolden: the server may be running apache again, but it's not been fully restored :(
11:25:56 <christo_m> robryk: sorry where?
11:26:09 <lispy> christo_m: if you felt more comfortable with parsec (and haskell) I bet you could knock this out in a few hours :)
11:26:18 * lispy has to go
11:26:22 <lispy> christo_m: good luck!
11:26:23 <robryk> chater lexical analysis of http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
11:26:29 <robryk> *chapter
11:26:41 <christo_m> lispy: thanks :(
11:27:03 <lispy> christo_m: It's hard to learn haskell, but you're at the right place and you'll get this sorted.  I'm sure of it :)
11:27:45 <christo_m> http://www.cas.mcmaster.ca/~carette/CS4TB3/2011/assignments.html
11:27:52 <christo_m> robryk: doesnt mention lexing
11:27:54 <christo_m> though i see why its important
11:27:56 <Olathe> > userError "zomg"
11:27:56 <christo_m> for assignment 1
11:27:57 <lambdabot>   user error (zomg)
11:28:08 <christo_m> lispy: thanks man, i appreciate it
11:28:15 <christo_m> thought i was getting hated on by elitists in here lol
11:28:43 <robryk> yes
11:28:54 <robryk> but you want to read a stream of characters as input
11:29:14 <robryk> and need to break it up into some sensible tokens -- words, special chars
11:30:01 <robryk> so you need a parser which will read possibly some whitespace, and read some letters; right?
11:30:59 <christo_m> robryk: okay ye
11:31:00 <christo_m> yes*
11:31:43 <christo_m> robryk: should this be at the top of the file, separate module or ??
11:31:43 <robryk> you can write these two-three parsers yourself or use TokenParser
11:32:30 <robryk> i don't think having it in the same place is anyhow harmful
11:33:15 <robryk> hm.. as you've already written the parser proper for use with TokenParser, i would wager it would be easier to use it
11:34:10 <robryk> look here: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#LanguageDefMembers
11:34:11 <christo_m> you mean just setting reservedWords etc
11:34:17 <christo_m> sorry, reservedNames
11:34:20 <christo_m> then the reserved keyword will work
11:34:28 <robryk> this is the structure that you should give as argument to makeTokenParser
11:34:59 <robryk> then and when you actually define it to ParsecToken.reserver lexer
11:36:59 <robryk> and yes, you should set there reservedNames
11:38:29 <robryk> i don't know if only that, the example uses the structure for parsing haskell and modifies it ; you might do that, but it might be simpler to write it all then to think what should get modified
11:38:58 <robryk> oh, in case that wasn't clear: haskellDef { field = value } means haskellDef modified so that field has value value
11:39:17 <christo_m> ya i was wondering why im getting errors about the brace
11:39:28 <christo_m> im not sure how to exactly pass the arguments, im assuming, as a constructor for the record?
11:39:32 <christo_m> sorry if my lingos all wrong here
11:40:04 <robryk> yes
11:40:09 <robryk> you should construct the record
11:40:46 <robryk> or you can modify emptyDef
11:40:55 <robryk> which is provided and seems to be a sensible default
11:41:36 <robryk> you construct a new record by doing LanguageDef { field1 = value1, field2 = value2, ... }
11:41:42 <robryk> with all fields enumerated
11:42:06 <christo_m> so if i use emptydef its like
11:42:21 <christo_m> luaDef = emptyDef{ ...} etc
11:42:26 <robryk> yes
11:42:28 <christo_m> okay
11:42:31 <robryk> you do not need to give it a name
11:42:49 <christo_m> i see, so once i give emptyDef record values names
11:42:54 <robryk> you can just put it in as argument to makeTokenParser
11:42:56 <christo_m> (im assuming because its defined in the top level)
11:42:59 <christo_m> then i can just pass it 
11:43:07 <robryk> yes
11:43:13 <christo_m> ok, yes, this makes sense
11:43:15 <christo_m> thank you
11:43:32 <robryk> oh, you might want to import ParsecToken
11:43:38 <robryk> and do it qualifiedly
11:43:52 <robryk> because it has functions such as reserved in it
11:44:09 <pedro3005> what is wrong with http://paste.pocoo.org/show/341922/ ?
11:44:42 <mauke> pedro3005: why do you think something is wrong?
11:44:45 <christo_m> robryk: what do you mean qualifiedly?
11:44:48 <christo_m> like whats the line 
11:44:49 <ozataman> hey all - anyone aware of any Haskell bindings for R?
11:45:04 <pedro3005> mauke, because when I try to load it into ghci it errors
11:45:18 <pedro3005> `read' is not a (visible) method of class `Read'
11:45:25 <mauke> pedro3005: oh, right
11:45:30 <robryk> import qualified package as P
11:45:42 <hpc> wait, what?
11:45:48 <mauke> pedro3005: you need to define readsPrec
11:45:57 <robryk> causes the package to be imported, but you need to refer to its elements by P.name instead of name
11:46:21 <Leo> ahem. can i ask about a way to print out a function definition (from source .hs file) in haskell?
11:46:42 <christo_m> so
11:46:47 <christo_m> import qualified ParsecToken as P?
11:47:01 <hpc> Leo: :info perhaps
11:47:02 <pedro3005> mauke, how? what is that?
11:47:13 <robryk> yes
11:47:25 <robryk> and then refer to all functions from there with prefix P.
11:47:35 <mauke> pedro3005: readsPrec is the method in class Read
11:47:44 <Leo> hps: not in ghci, but in a compiled program. like show (f)
11:47:52 <hpc> Leo: impossible
11:48:07 <kevinburke> Yacc keeps reducing when it should shift
11:48:13 <kevinburke> Excuse me happy
11:48:14 <robryk> the point is that you probably want reserver to be your reserved keyword parser and not the function which creates reserver keyword parsers from TokenParsers
11:48:17 <hpc> source can be destroyed during compilation, like if a function is only ever inlined
11:48:22 <Leo> so i can't use some library that inserts function definition from source during compile time?
11:48:24 <azaq23> @src read
11:48:24 <lambdabot> read s = either error id (readEither s)
11:48:31 <christo_m> Failed to load interface for `ParsecToken'
11:48:33 <christo_m> Any reason for this?
11:48:53 <hpc> Leo: you could, but it wouldn't be inserting haskell source
11:48:56 <hpc> check out mueval
11:49:08 <Leo> hpc: thanks, i will
11:49:18 <mauke> christo_m: wrong module name?
11:49:36 <robryk> oh, because that's nor ParsecToken
11:49:45 <robryk> it's something like Text.Parsec.ParsecToken
11:50:35 <christo_m> import Text.ParserCombinators.Parsec   Well thats f or parsec
11:50:42 <christo_m> id imagine .ParsecToken at the end would be it
11:50:45 <christo_m> but that doesnt work either
11:50:59 <robryk> nope, probably Text.ParserCombinators.ParsecTokens
11:51:01 <robryk> *Token
11:51:38 <christo_m> no.
11:51:57 <christo_m> Failed to load interface for `Text.ParserCombinators.ParsecToken':
11:51:58 <christo_m> gcc
11:52:00 <christo_m> grr*
11:52:40 <robryk> hmm. a moment.
11:53:44 <meth[phone]> can i tell cabal that headers for a package are in /usr/local instead of /usr ? or should that just work ?
11:54:00 <robryk> Text.ParserCombinators.Parsec.Token
11:54:10 <mauke> if all fails, read the documentation
11:54:16 <pedro3005> mauke, http://paste.pocoo.org/show/341927/ and this?
11:54:24 <Leo> hpc: mueval has unix dependency. won't work on windows. so i guess i can't use some haskell extension to generate a string with source code for each function defined in a source file? hm
11:54:38 <ClaudiusMaximus> dankna (or anyone else who might know direct-sqlite): what's the best technique to avoid program abort at "user error (SQLite3 returned ErrorBusy while attempting to perform step.)" ?
11:54:44 <mauke> pedro3005: what is 'Cell a' supposed to be?
11:55:04 <pedro3005> mauke, well... a cell?
11:55:20 <christo_m> ouch, emptyDef not in scope
11:55:24 <christo_m> even P.emptyDef is not in scope
11:55:29 <mauke> pedro3005: looks like a kind error to me
11:55:50 <pedro3005> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:readsPrec I looked at the code here and tried to convert it to my situation
11:56:34 <robryk> because it is now in ....Parsec.Language
11:56:56 <christo_m> ... i hate life
11:57:14 <robryk> hoogle is useful for such problems
11:57:32 <christo_m> okay, noted
11:57:32 <pedro3005> mauke, any idea of how to accomplish what I want?
11:57:40 <christo_m> now back to the oldschool "name out of scope" errors
11:57:43 <christo_m> because im trying to monad a value
11:57:49 <christo_m> or a type, rather
11:58:10 <robryk> hm?
11:58:14 <robryk> where are these errors?
11:58:23 <christo_m> lua_compiler.hs:82:11: Not in scope: data constructor `Name'
11:58:25 <robryk> oh
11:58:46 <robryk> there _is_ no constructor Name
11:58:50 <christo_m> no i know
11:58:54 <christo_m> its an algebraic type i believe
11:58:55 <robryk> in your code a Name is the _same_ thing as a String
11:58:59 <christo_m> right
11:59:08 <robryk> that is quite all right
11:59:20 <robryk> but you do not need to apply anything to a String to make it a Name
11:59:30 <christo_m> but if i want to parse it
11:59:42 <christo_m> field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
11:59:44 <christo_m> see there
11:59:46 <christo_m> for example
11:59:48 <robryk> you want to parse an identifier name ; something that lexer would consider an indentifier name
11:59:59 <christo_m> ah, so i can add Name to reservedNames?
12:00:06 <christo_m> should i refer to it as reserved "Name"?
12:00:22 <christo_m> actually, wait, its not a keyword in the language though
12:00:37 <christo_m> i should set identifier record
12:00:42 <robryk> no, this has nothing to do with keywords
12:00:50 <christo_m> right?
12:00:55 <robryk> i don't undestand your last
12:00:56 <christo_m> identifier record for the lexer
12:01:15 <robryk> ident{Start,Letter} has sane defaults
12:01:19 <robryk> in emptyDef
12:01:26 <christo_m> hm
12:02:12 <ddarius> mauke: I like how reading the documentation is a method of last resort.
12:02:48 <robryk> you now want to use probably symbol from TokenParser
12:04:14 <robryk> you might want to read http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#LanguageDefMembers to see what the lexer can parse
12:04:22 <robryk> sorry
12:04:37 <robryk> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#TokenParserMembers
12:05:01 <christo_m> robryk: see i dont see anything there that can help me
12:05:13 <christo_m> Name looks like the base identifier in LUA
12:05:54 <robryk> oh: these are current docs: http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Token.html
12:07:08 <christo_m> lol, still doesnt help
12:07:26 <robryk> you've got `identifier' in TOkenParser record
12:07:43 <robryk> which seems to do what you want -- it parses a valid identifier which is not a keyword
12:08:02 <christo_m> oh i thought you meant in LanguageDef still
12:08:41 <christo_m> okay i see what you mean
12:09:07 <robryk> so to get that parser you need to evaluate P.indentifier youTokenParser
12:09:26 <christo_m> ill put P.identifier instead of name you mean
12:09:30 <christo_m> wait
12:10:04 <robryk> no
12:10:28 <robryk> P.identifier is a funtion of type TokenParser -> <type of a parsec parser which returns a String>
12:10:39 <robryk> you need to apply it to your TokenParser
12:11:14 <christo_m> still a bit confused
12:11:21 <christo_m> how do i let it know that i want to deal with Name
12:11:29 <robryk> you don't
12:11:29 <christo_m> i get that its a function applied to a TokenParser
12:11:40 <robryk> it doesn't need to know anything about Name-s
12:11:45 <christo_m> lexer :: P.TokenParser()
12:11:45 <christo_m> lexer = P.makeTokenParser(emptyDef)
12:12:03 <robryk> hm, you might want to add reserved words there later
12:12:17 <christo_m> identifier= P.identifier lexer
12:12:20 <robryk> yes
12:12:20 <christo_m> oh no i know
12:12:24 <christo_m> this is just for compiling
12:12:26 <christo_m> right
12:12:34 <christo_m> but i want to use Name
12:12:40 <robryk> and now identifier is a parser which parses a String which is a valid identifier
12:12:41 <christo_m> so when i refer to it in my rules 
12:12:52 <robryk> there is no difference between a Name and a String
12:12:59 <christo_m> im saying identifier instead of Name?
12:13:01 <christo_m> or what?
12:13:15 <robryk> yes, you say identifier in places in which you used to have Name
12:13:32 <christo_m> then i dont really need type Name = String anymore.. lol
12:13:50 <christo_m> in fact i should let Name = identifier
12:13:53 <robryk> nonono
12:13:57 <christo_m> :(
12:13:59 * hackagebot hackport 0.2.13 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.13 (SergeiTrofimovich)
12:14:03 <robryk> i mean places where Name caused a syntax error
12:14:09 <robryk> identifier is not a type
12:14:55 <bparker1000> is there a way to add elements to the end of a list, as oppose to using ++ [x]?
12:15:07 <companion_cube> x :
12:15:11 <monochrom> no
12:15:14 <tromp_> maintain list as a difflist
12:15:16 <robryk> bparker1000: everything would be equivalent to ++[x]
12:15:27 <companion_cube> oops, you should append and then reverse, perhaps
12:15:47 <bparker1000> ok, thats what I thought, thanks
12:16:35 <christo_m> robryk: http://hpaste.org/44186/luaparser
12:16:37 <christo_m> bunch of errors
12:17:21 <christo_m> i think its because i didnt define my reserved words
12:17:22 <christo_m> first off
12:17:46 <robryk> no, rather not
12:18:30 <robryk> i don't know what token does ; there is a comma parser in your lexer, which might be safer to use
12:19:00 <robryk> look at funcname
12:19:17 <robryk> now you try to use identifier as a function and pass it some argument
12:19:39 <robryk> i think you rather want to combine it with the next parser by putting it in a do-block
12:25:53 <accel> so i'm looking thorugh the hackage, and is this http://hackage.haskell.org/package/SVGFonts the closest there is to rendering Math Fonts in haskell?
12:26:05 <accel> I want something at the level of TeXMacs, but in Haskell
12:26:17 <phrackSipsing> anybody know how i could set up a regex assignment, such as '=~ "foo"::Bool' to use with a filter
12:27:09 <c_wraith> I hate that regex library so much
12:27:29 <dmwit> (=~ "foo") :: String -> Bool -- ?
12:27:37 <dmwit> :t (=~ "foo")
12:27:37 <lambdabot> forall source1 target. (RegexContext Regex source1 target) => source1 -> target
12:27:45 <dmwit> :t (=~ "foo") :: String -> Bool
12:27:45 <lambdabot> String -> Bool
12:27:50 <c_wraith> but, really, when used in the context of the first argument to filter, (=~ "foo") should suffice
12:27:57 <dmwit> yep
12:27:58 <c_wraith> :t filter (=~ "foo")
12:27:59 <lambdabot> forall source1. (RegexLike Regex source1) => [source1] -> [source1]
12:28:37 <phrackSipsing> ah, because it can infer the type
12:28:39 <phrackSipsing> thanks
12:32:53 <christo_m> robryk: sorry can you explain?
12:33:44 <dino-> I end up using the functions in Text.Regex a lot more often, including subRegex
12:33:46 <robryk> what do you want to parse in funcname?
12:34:03 <christo_m> well, Name
12:34:07 <dino-> :t \p s -> Text.Regex.matchRegex (Text.Regex.mkRegex p) s
12:34:08 <lambdabot> String -> String -> Maybe [String]
12:34:55 <robryk> i mean, what kind of expression
12:35:10 <robryk> a single name and nothing more?
12:35:28 <christo_m> funcname ::= Name {`.´ Name} [`:´ Name]
12:35:48 <christo_m> maybe im reading the grammar wrong
12:36:07 <christo_m> but Name.Name or Name.Name:Name
12:37:13 <robryk> and what do you want it to return?
12:37:27 <robryk> the first name? or some structure which contains all three?
12:37:59 <christo_m> i have no idea actually..
12:38:12 <christo_m> wait, do all these have to return something?
12:38:14 <christo_m> is that what the issue is?
12:38:37 <robryk> that isn't exactly the issue, but you do want them to return something
12:38:44 <dixie> georgi << 1
12:38:55 <robryk> what they return is all the information which you'll get about what they've parsed
12:39:03 <jmcarthur> accel: you asked in #haskell-game earlier about glsl edsls. gpipe is one
12:39:09 <robryk> apart from the fact that they suceeded to parse something
12:39:27 <jmcarthur> accel: conal is also working on one, and i'm working on something like that, too
12:40:29 <christo_m> okay
12:40:42 <jmcarthur> i guess overall mine is not really very different from conal's, except that i'm not also providing arbitrary 3d surfaces and stuff
12:41:10 <jmcarthur> i haven't thought a ton about whether mine is difference enough to even justify being a separate project
12:41:13 <jmcarthur> *different
12:41:49 <robryk> oh. you never use funcname is any other parser, that's probably why you don't have (yet) a type for its return value
12:42:26 <conal> i build all the domain-specific stuff (procedural images, surfaces, lighting models, etc) in a very simple denotational style. the compiler knows none of that stuff.
12:42:50 <christo_m> robryk: right
12:42:52 <christo_m> i also dont have exp defined
12:42:55 <christo_m> nor a proper stat
12:43:28 <robryk> ok; so comment out those parsers which don't get used by block now
12:43:34 <deech> Hi all, I have function that parses a CSV file and returns IO (Either ParseError CSV). I'm trying to catch an IOError and return something but I don't know how to make it match IO (Either ParseError CSV).
12:43:35 <robryk> and see what errors out then
12:43:35 <conal> i'm hoping the brokenness of guis & interactive 3d for haskell+mac will get sorted out soon, and then i'll have something fun to release.
12:43:53 <jmcarthur> conal: yeah, i think mine would end up working in basically the same way
12:44:05 <christo_m> robryk: sorry?
12:44:13 <christo_m> robryk: every one of them uses block im sure
12:44:16 <christo_m> a block is a section of code
12:44:25 <jmcarthur> conal: is the compiler in a separate package from the domain-specific stuff, or are there plans for that?
12:44:41 <robryk> other way round
12:44:43 * conal looks
12:44:47 <robryk> funcname is nowhere referenced
12:44:53 <christo_m> so comment it out?
12:45:15 <robryk> so that you start with something smaller, that will hopefully be able to parse a block
12:45:21 <Peaker> I think that it is bad we have packages depend on a specific version of template-haskell and thus them and all their indirect deps are tied to a particular compiler :-(
12:45:28 <Peaker> (compiler version)
12:45:31 <robryk> and then do stuff which isn't required for that, but for parsing a whole program
12:45:43 <conal> jmcarthur: they're not in separate modules. good idea, though.
12:45:46 <jmcarthur> conal: because if so then i might just consider eventually using and enhancing your compiler with my own domain specific stuff
12:46:23 <accel> http://hackage.haskell.org/package/cairo why is the homepage broken?
12:46:28 <conal> jmcarthur: oh, that'd be nifty. should be easy to break apart. i already have four packages. don't know why i didn't do it already.
12:46:38 <jmcarthur> would save me a lot of work and might mean we end up with one great compiler instead of a good one (yours) and a cheap spinoff ;)
12:46:50 <conal> jmcarthur: i'd like that.
12:47:07 <jmcarthur> awesome
12:47:11 <conal> :)
12:47:43 <conal> jmcarthur: i'll divide, push, and send you a note.
12:47:48 <jmcarthur> thanks!
12:48:57 <mreh> did the discussion about making reactive work with mtl >= 2 ever reach a conclusion?
12:49:35 <robryk> how do foreign function executions count when profiling?
12:50:00 <conal> mreh: i don't remember that discussion. maybe i missed it.
12:50:38 <mreh> conal: mtl depends on transformers which clashes with category extras
12:50:47 <conal> oh, oops.
12:50:54 <Peaker> is the new mtl an API adapter for transformers?
12:50:59 <mreh> category-extras pardon
12:51:00 <jmcarthur> i think category extras is dying anyway
12:51:04 <mreh> yeah it is
12:51:18 <mreh> edwardk is splitting it into little pieces
12:51:28 <jmcarthur> so the bigger deal is to remove the dependency on that, which i think edwardk has done a little of
12:52:01 <mreh> yeah, maybe I'll get the source, remove the dependency and try to fix it
12:52:10 <mreh> see if I get anywhere
12:53:09 <mreh> i thought he said he had a patch
12:53:34 <mreh> Peaker: yes as far as I'm aware
12:54:09 <conal> mreh: edwardk showed me his changes to wean reactive off of category-extras. probably best for me to apply them to reactive.
12:54:25 <mreh> conal: I agree!
12:54:31 <conal> :)
12:54:43 <Leo> ahem. Is there a way to use something like System.Timeout.timeout for IO like System.Process.system "ping google.com"?..
12:55:38 <mreh> i'll bug you until then
13:02:42 <Leo> .
13:06:28 <robryk> @src sequence_
13:06:28 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:07:15 <accel> cabal install gtk <-- most painful shit ever
13:07:20 <accel> cabal dependency is screwed up
13:07:29 <accel> cabal--
13:07:34 <accel> @karma cabal
13:07:34 <lambdabot> cabal has a karma of 3
13:07:38 <accel> cabal++
13:10:47 <burp> yeah it's painful
13:10:55 <burp> best to use distribution packages for it :>
13:11:43 <deech> How do I catch an IO error for Parsec's parseFromFile function? It's sig is : Parser a -> String -> IO (Either ParseError a).
13:12:28 <ezyang> deech: I assume Control.Exception will do the trick? 
13:14:12 <deech> ezyang: Yes there is a 'catch' method, but it requires me to return IO (Either ParseError a). That's the part I'm having trouble with. If there is an IO error reading the file, catching it and returning a parser doesn't make sense.
13:14:57 <deech> s/returning a parser/returning a parser error
13:15:05 <jmcarthur> conal: of the domain-specific things you meantioned (procedural images, surfaces, lighting models, etc), surfaces is the only thing i'm not planning to include in mine...
13:15:05 <monochrom> what do you plan to do when the exception happens? perhaps I can help.
13:15:09 <jmcarthur> *mentioned
13:15:18 <ezyang> Sure. Your handler needs to be high up enough so that the surrounding code is the appropriate place to deal. 
13:15:38 <jmcarthur> and i guess we are probably going with the same models for images and lighting and stuff
13:16:04 <ezyang> So in fact a function that returns IO (Either ParseError a) is not appropriate 
13:16:09 <ezyang> Something like IO () more so. 
13:16:32 <conal> jmcarthur: i imagine we would, or we'd have interesting conversations about alternative models
13:16:46 <monochrom> without that information, I still have a last resort: don't use "catch", use "try", so you get IO (Either IOException (Either ParseError a)) and then you can case and dispatch as you wish.
13:17:09 <ezyang> clunk clunk :_) 
13:17:17 <deech> monochrom: neat, I'll try that!
13:17:51 <conal> jmcarthur: i'm happy to share those models and/or help explore alternatives.
13:17:55 <deech> ezyang: Unfortunately Parsec gives me parseFromFile. I don't have control over that.
13:18:31 <monochrom> but with probability 99% you should do what ezyang says: move your "catch" to outer levels.
13:19:12 <deech> hmmm .... I'll try that too. Thanks!
13:20:37 <mm_freak> deech: tried to use parsec together with an iteratee?  that would make more sense
13:20:54 <mm_freak> apparently there is a parsec-to-enumerator converter
13:23:33 <mm_freak> ah, no, there isn't
13:23:47 <mm_freak> but attoparsec would be the more natural choice in this case anyway
13:30:12 <pedro3005> Hello
13:30:17 <pedro3005> can anyone help me with http://paste.pocoo.org/show/341927/ ?
13:33:09 <sepp2k> pedro3005: In your Read instance you're treating Cell as if it had one type parameter, but it has none.
13:35:02 <peoro> would it be possible to have a wrapping-around enum, so that `succ (maxBond :: MyType)' returns `minBound :: MyType' ?
13:35:45 <pedro3005> sepp2k, oh, so like http://paste.pocoo.org/show/341962/ ? still errors though
13:37:03 <ski> peoro : i suppose i'd find that strange ..
13:37:27 * ski isn't sure what semantics is expected of `succ' and `pred', though
13:37:41 <peoro> hmmm, don't know, maybe I'm misusing data types..
13:37:46 <Eduard_Munteanu> I suspect he wants C-like semantics.
13:38:00 <Eduard_Munteanu> so it wraps around.
13:38:19 <ski> (how is that C-like semantics ?)
13:38:34 <peoro> Eduard_Munteanu, uhm, if you're referring to integer overflows, I'm not thinking about it...
13:38:40 * cizra experienced a real WTF moment right now
13:38:47 <cizra> > return [1] ++ return [2]
13:38:48 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
13:38:48 <lambdabot>    arising from a use of `M26255441...
13:39:13 <ski> > return [1] ++ return [2] :: [[Integer]]
13:39:14 <lambdabot>   [[1],[2]]
13:39:14 <peoro> I wanted to have a Day datatype (witn constructors Monday, Tuesday etc etc), and would like to have that `succ Sunday' is Monday...
13:39:19 <elliott> Does hGetLine not handle \r\n line endings or is that just Data.ByteString.hGetLine?
13:39:24 <ski> > return [1] ++ return [2] :: Maybe [Integer]
13:39:25 <lambdabot>   Just [1,2]
13:39:30 <cizra> Why on earth am I getting that?
13:39:40 <ski> getting what ?
13:39:49 <cizra> [[1],[2]]
13:40:04 <ski> well, in the list monad, `return x = [x]'
13:40:14 <monochrom> list monad. return x = [x]. return [1] = [[1]].
13:40:15 <cizra> ah, it's list monad...
13:40:31 <ski> `return' is a `Monad' method
13:40:36 <cizra> Okay, but I think I want to concatenate two IO [String]s
13:40:46 <mreh> :t (++)
13:40:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:40:49 <mreh> ah
13:40:53 <ski> maybe you want `liftM2 (++) foo bar' ?
13:40:58 <mreh> @instance Monoid
13:40:58 <lambdabot> Maybe you meant: instances instances-importing
13:41:02 <Eduard_Munteanu> peoro: ah I think you can write such an Enum instance
13:41:18 <mreh> @instances Monoid
13:41:18 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:41:20 <ski>   liftM2 (++) :: IO [a] -> IO [a] -> IO [a]  -- in this case
13:41:26 <cizra> Guess it must be liftM2. I'm not so comforable around different monads yet.
13:41:32 <monochrom> lambdabot is weirder and weirder
13:41:41 <ski> hm ?
13:42:03 <mreh> what if a is a monoid in [a]?
13:42:16 <elliott> @info Product
13:42:16 <lambdabot> Product
13:42:19 <elliott> @info Sum
13:42:19 <lambdabot> Sum
13:42:21 <elliott> helpful
13:42:25 <monochrom> you're just doing IO and you can just think IO and nothing else. still ++ is a string function not an IO function. there is no "getLine ++ getLine".
13:42:34 <hpc> elliott: newtype Product a = P [a]
13:42:36 <ski> cizra : if you want to "access the `String' inside `IO'", then you usually want `liftM' or `liftM2' or something similar
13:42:40 <elliott> hpc: oh right
13:42:41 <hpc> newtype Sum a = S [a]
13:42:45 <hpc> and instance magic
13:42:48 <sepp2k> pedro3005: readsPrec does not have type String -> a. It has type  Int -> ReadS a
13:43:04 <elliott> hpc: obvs it should be newtype Product a b = P (a -> b)
13:43:10 <monochrom> it's another case of "don't pull your string out of IO, put your processing function into IO"
13:43:14 <elliott> and data Sum a b = S a b
13:43:21 <cizra> ski: Thank you very much.
13:43:25 <peoro> `succ = toEnum . (`plusInt` oneInt)  . fromEnum'. if I try to call `toEnum' with an integer greater than enum's elements it fails...
13:43:33 <elliott> monochrom: surely it should be the other way around.
13:43:36 <Eduard_Munteanu> elliott: I don't think it refers to product/sum types
13:43:42 <elliott> peoro: well what is it meant to do?
13:43:45 <elliott> Eduard_Munteanu: But it should!
13:43:57 <monochrom> I disagree.
13:43:59 <ski> cizra : of course, you could do `do s0 <- foo; s1 <- bar; ..(s0 ++ s1)..' as well
13:44:08 <peoro> but, hum, toEnum, fromEnum etc etc are in class Enum, so I guess I can overload them (I feel like my terminology is wrong...)
13:44:18 <cizra> ski: yes, I know
13:44:39 <elliott> monochrom: so you think (IO String -> IO String) is more preferable than (String -> String) or something?!
13:44:48 <monochrom> no
13:44:52 <elliott> obviously pure code should be pure and IO should just handle IO...
13:45:00 <Eduard_Munteanu> peoro: what about   succ Sunday = Monday
13:45:19 <peoro> elliott: I defined a `Day' datatype with constructor `Monday', `Twuesday' etc, and want that `succ' wraps around
13:45:26 <hpc> > pure 5 :: IO Int -- pure IO lol
13:45:27 <lambdabot>   <IO Int>
13:45:35 <Eduard_Munteanu> It's as simple as pattern-matching for that case in particular
13:45:36 <elliott> peoro: then what Eduard_Munteanu said would work
13:45:37 <peoro> Eduard_Munteanu: yes, that will do the trick. didn't know `succ' could be overloaded
13:45:41 <monochrom> I think (IO ()) is preferable to (IO String -> String)
13:46:14 <peoro> ok, good
13:46:20 <Eduard_Munteanu> Since it's a typeclass member, it can.
13:46:39 <sepp2k> pedro3005: You probably want to do something like  readsPrec _ ('_':s) = [(Dead, s)] . Or actually, you probably just want to derive Read automatically.
13:47:50 <cizra> Is writeFile not entirely synchronous?
13:48:27 <mauke> depends on your definition of "synchronous"
13:48:36 <monochrom> writeFile is entirely synchronous as far as the haskell level is concerned. not sure how many more buffers your OS adds.
13:48:37 <pedro3005> ok thanks sepp2k 
13:48:40 <Eduard_Munteanu> Probably not as in O_SYNC
13:49:00 <Eduard_Munteanu> or O_DIRECT
13:49:43 <pozic> I'd expect writeFile to completely write it to disk. 
13:49:54 <cizra> I'm having a problem where a file is reported not to exist after it should have been written.
13:49:56 <monochrom> however you can be sure "writeFile "x" ... >> readFile "x" >>= ..." works as expected
13:50:08 <cizra> Maybe some weird laziness issue?
13:50:08 <mauke> what is a disk?
13:50:25 <pozic> mauke: ok, file system. 
13:50:25 <cizra> A short cylinder!
13:50:30 <mauke> a miserable little pile of secrets
13:51:05 <monochrom> 99% probability it is your own bug
13:51:13 <cizra> okay
13:52:27 <monochrom> eh? I should vow to never say "bug" again. it should be "error".
13:53:56 <monochrom> come back!
13:54:06 <Jafet> Defective wrong error bug
13:54:18 <monochrom> defective human error
13:54:21 <Philippa> yeah, but then you lose wonderful terms like "rebugging"
13:54:22 <Jafet> (Add punctuation)
13:55:04 <monochrom> but I gain wonderful terms like "cognitive dissonance"
13:55:04 <aristid> what
13:55:08 <aristid> why add punctuation
13:55:22 <aristid> monochrom you always have that term
13:58:01 <pozic> Suppose one builds something on top of HAppstack. You get a binary and you run it. Now, you want to add a feature. AFAIK, you loose your whole RAM database then, completely invalidating the design of HAppstack. Please point to a flaw in my logic.
13:58:14 <pozic> lose*
13:58:35 <peoro> can I define an instance of `New' overloading `(+)' so that I can sum my type with integrals?
13:58:55 <pozic> peoro: yes, you can.
13:59:14 <peoro> something like: `instance Num Day where; a + b = toEnum $ fromEnum a + b' where a::Day and b and integrals
13:59:16 <peoro> pozic, how?
13:59:55 <pozic> peoro: instance Num MyIntegral where (+) integral1 integral2 = undefined 
14:00:35 <mauke> peoro: that looks like it would work
14:00:39 <mauke> except for the ; after where
14:00:50 <mauke> wait, no
14:00:57 <mauke> peoro: no, you can't
14:01:03 <peoro> it doesn't work, because it wants `b' of being a Day
14:01:09 <mauke> right
14:01:18 <peoro> I'd like to have `(+) :: (Integral a) => Day -> a -> Day'
14:01:33 <pozic> peoro: plus_day could do that. 
14:01:39 <pozic> peoro: you can hide (+) too.
14:01:44 <mauke> peoro: that would have to be a different function
14:02:12 <pozic> peoro: so, you can write it, but your (+) would have nothing to do with the (Prelude.+)
14:02:29 <peoro> oh, I see, `Num' defines + as `(+) :: a -> a -> a', while I'd need it to be `(+) :: a -> b -> c'
14:02:30 <peoro> ok, got it...
14:02:48 <pozic> peoro: You can write it using multi-parameter type-classes.
14:03:10 <pozic> peoro: then you can use the 'old Num' and your super-overloaded version at the same time.
14:03:19 <peoro> hum... I'll read about it on haskell wiki
14:03:36 <mauke> I don't see how that lets you use the old Num
14:03:38 <pozic> peoro: still, all these overloadings are not that useful.
14:03:50 <pozic> mauke: by writing the correct instance. 
14:04:01 <mauke> more like instances. all of them
14:04:21 <pozic> Num a => SuperNum a a where myplus = (Prelude.+)
14:04:25 <pozic> Why wouldn't that work?
14:04:31 <mauke> it's a sideways call
14:04:37 <peoro> alright... I give up and will define a function with another name, instead of instantiating Num...
14:04:41 <mauke> I don't think the termination checker would accept that
14:04:56 <pozic> mauke: you can turn that off.
14:05:20 <pozic> It has nothing to do with Haskell98, and I don't know the details of 2010, but I don't think a lot changed.
14:07:33 <pozic> Nobody who knows anything about HAppstack?
14:09:23 <peoro> if I instantiate Enum, how can I define `toEnum' ? I'd like to do something like: `toEnum a = toEnum . ( `mod` 7)', but using the default toEnum, instead of recurring indefinitely
14:12:41 <azaq23> peoro: Try adding an explicit type annotation for the toEnum in your definition
14:13:27 <quetzal> what should i use to manipulate large mutable arrays of bytes in haskell?
14:13:36 <peoro> azaq23, what do you mean? the problem is not that the type is ambiguous... I'd just like to call the default toEnum when overloading it
14:13:53 <Saizan> peoro: no way
14:14:32 <peoro> hmmm... how is the default `toEnum' implemented?
14:18:18 <BMeph> pozic: Do you want to add a feature to your built thing, or to HAppstack (sic)? ;)
14:18:20 <azaq23> peoro: http://hpaste.org/44188/explicit_type_annotation I meant that
14:18:39 <azaq23> peoro: Isn't this sort of what you want or did I get that wrong?
14:18:40 <pozic> BMeph: to my built thing. 
14:19:00 <azaq23> peoro: Int is an example here, any instance of enum would do
14:19:10 <pozic> HAppstack*
14:20:09 <BMeph> pozic: Okay. I don't know anything about HAppstack, but I figured that anyone who did would want that point made clear. :)
14:20:47 <peoro> azaq23, well, in your example it's possible to do that because it's using the `toEnum' as overloaded by another type (Int, in that case). In my case I'd like to use the default `toEnum' for the type I'm instantiating
14:21:21 <pozic> BMeph: the point is that once you destroy the process, the RAM is gone. 
14:21:54 <peoro> but I think I found out that if you instantiate a calss, instead of deriving it, default functions are not generated, so there's no way to do that
14:22:01 <pozic> BMeph: so, if you then have to read 10 GB from disk into RAM that might take more than a few seconds. 
14:22:28 <pozic> BMeph: essentially you then need to have twice the hardware.  
14:22:49 <pozic> I wonder how they exactly solved this stuff in Erlang. 
14:22:55 <ocharles> I have a list of IO [String], and a function from String -> b. How can I compose this to get from IO [String] -> IO [b] ?
14:23:03 <ocharles> I turned to fmap, but I'm not sure that's what I want
14:23:05 <pozic> At some point you need to define conversion code. 
14:23:15 <parcs> ocharles: fmap
14:23:23 <azaq23> peoro: Oh, the default definition - yep no idea how to do that, my example hasn't anything to do with that, correct
14:23:40 <azaq23> peoro: I trust Saizan's comment though
14:23:41 <parcs> actually, fmap . fmap
14:23:42 <ocharles> hrm, that's expecting an IO Char somewhere, but inferring IO String
14:24:09 <chris__> hi
14:24:21 <monochrom> two fmaps, one for IO, one for []. fmap (fmap your'String'to'b) (your'IO'to'[String])
14:24:33 <aristid> or use map for the []
14:24:33 <monochrom> the inner fmap is map if you like
14:24:41 <ocharles> ah, interesting
14:24:55 <monochrom> composability rules
14:25:09 <ocharles> it does when you can match the types :)
14:25:16 <ocharles> hoogle failed me this time :)
14:25:35 <monochrom> hoogle cannot suggest composed functions
14:25:46 <ocharles> of course
14:26:01 <ocharles> I just though there might be something that does what I wanted
14:26:03 <monochrom> but it's in the works. hoogle is expected to eliminate human programmers by 2020
14:26:03 <parcs> @hoogle (.:)
14:26:03 <lambdabot> No results found
14:26:16 <ocharles> but I had to generalize up a level
14:26:20 <ocharles> lol
14:27:16 <parcs> you'll find yourself using fmap . fmap a lot; i suggest installing the functors package for the useful (.:) operator (or define one yourself)
14:29:36 <ocharles> I'll look into that, thanks
14:29:43 <ocharles> sounds useful
14:30:15 <chris__> i ma neww
14:30:24 <chris__> what is it
14:30:36 <chris__> ??
14:30:54 <chris__> como salgo del chat
14:31:01 <ocharles> yes.
14:31:06 <chris__> i from colombia 
14:31:21 <chris__> hellp
14:31:32 <chris__> help
14:31:32 <chris__> jeje
14:31:57 <chris__> this is free software
14:31:59 <chris__> __
14:32:08 <azaq23> no this is sparta
14:32:15 <chris__> pfff
14:32:23 <azaq23> what do you need help with?
14:33:06 <chris__> i am making the tutorial 
14:33:16 <chris__> but i can close the chat
14:33:26 <chris__> y solo se espanol
14:33:39 <chris__> i only know spanich
14:33:43 <chris__> spanish
14:34:15 <chris__> but i can understant english 
14:34:22 <chris__> but is no good
14:34:26 <chris__> sorry
14:34:54 <chris__> i am in the step 3 of the tutorial
14:35:07 <chris__> how i can close the chat
14:35:20 <parcs> heh
14:35:27 <hpc> heh
14:35:29 <pozic> There is no escape.
14:35:34 <pozic> You have to complete all steps.
14:37:17 <heatsink> Is there a way to use UserHooks to customize the way configure arguments are handled?  It seems like arguments are already parsed before preConf is invoked.
14:37:26 <heatsink> ...in a Cabal setup program
14:43:18 <adnap> is there already something on hackage that will walk a file system?
14:43:54 <adnap> i need file paths for every file starting from some root directory
14:44:40 <c_wraith> look at the directory-tree package
14:45:17 <adnap> nice, thanks
14:45:29 <xplat> the 'Day' type mentioned earlier is an integer torsor
14:45:40 <adnap> also, is it possible to get information about files like last accessed time?
14:45:44 <xplat> well, aside from perhaps limited range
14:45:50 <c_wraith> @hoogle getModificationTime
14:45:50 <lambdabot> System.Directory getModificationTime :: FilePath -> IO ClockTime
14:45:50 <lambdabot> Trace.Hpc.Mix getModificationTime :: FilePath -> IO Integer
14:46:02 <adnap> woo
14:46:05 <adnap> thank you again
14:46:08 <c_wraith> the first result there is in the directory package
14:46:24 <adnap> yeah, i'm not looking hard enough.  i had that page open
14:46:29 <c_wraith> If you're monitoring a directory tree for updates, take a look at my code for doing the same thing in snap...
14:46:35 <xplat> the standard library really should define torsors/actions for groups, semigroups etc
14:46:51 <adnap> c_wraith: i'm not
14:46:56 <adnap> here's what i am going to write
14:46:58 <c_wraith> adnap: ah, ok
14:47:03 <adnap> given a path and a number of bytes
14:47:15 <adnap> scan all files below that path and sort them by last accessed time
14:47:25 <adnap> delete files until "number of bytes" have been deleted
14:47:39 <adnap> essentially like a lru deletion thingy
14:47:58 <xplat> oh, so like 'free 100MB from my webcache'
14:48:02 <adnap> yeah
14:48:11 <adnap> only, i sitll have one concern
14:48:17 <adnap> in linux, files can be associated with groups
14:48:30 <adnap> i want to prevent some files associated with a certain group from being deleted
14:48:41 <adnap> however, in windows, there is nothing like a group
14:48:46 <adnap> and i need this thing to work on windows
14:48:54 <adnap> so i need some way to protect certain files from being deleted
14:49:14 <xplat> permissions work completely differently on windows, yeah
14:49:34 <xplat> you could set them system or readonly maybe
14:49:43 <xplat> if that'll work for your purposes
14:49:59 <adnap> you can still delete a read only file, right?
14:50:08 <adnap> are you saying use that as a flag?
14:50:36 <xplat> can't remember if that is enforced at the API level, but if not you can use it as a flag
14:51:27 <xplat> unfortunately using those flags can be inconvenient depending how you use the files normally
14:52:32 <adnap> yeah, i think it's kind of a hacky solution
14:52:53 <c_wraith> Oh, hey.  I didn't realize GHC 7.0.2 was in release candidates.  That makes me happy
14:53:02 <adnap> i think it would be better to write another program that builds a database of protected files where you can specify paths
14:53:12 <xplat> well, the group thing sounds pretty hacky too, but i don know as much about the surrounding system so ...
14:53:12 <adnap> and files
14:53:20 <adnap> yeah
14:53:24 <adnap> i need something more portable
14:53:31 <adnap> i think the database thingy is best
14:53:42 <hpc> since this is going to be a utility
14:53:49 <hpc> i think, if you have permission to delete, delete
14:53:57 <hpc> if it doesn't delete, don't count it as towards the size limit
14:54:15 <hpc> then leave it to users to work out what needs to be not deleted
14:55:06 <xplat> it's hard to make useful suggestions having only a vague idea of what this is for and why some files would need to be protected
14:55:49 * hpc is imagining it as kind of like gnu utils
14:56:00 <hpc> useful stuff that you can combine easily
14:56:12 <xplat> like presumably there's some reason the protected files can't just be in a different directory to start with
14:56:24 <adnap> i can explain that
14:56:58 <adnap> all of the files are in the same class.  that is, they are related and belong in the same directory.  but certain files have higher priority over being deleted
14:57:00 <xplat> or why it would have been more convenient in the unix-only version to mark them with a special group tag rather than perms ...
14:57:25 <adnap> xplat: the group thing could have just been a dumb idea i had
14:59:19 <xplat> the only thing i can think of that would work like this is a media box a la tivo that runs as an app (but maybe for audio, or with different kind of sources, or something)
15:00:57 <xplat> and you'd want the ability to free space from things that were not marked 'keep' or 'keep until watched'
15:01:35 <adnap> xplat: yeah, exactly like that
15:01:55 <xplat> i don't imagine it being very useful as a general file utility
15:04:10 <xplat> but in that case it also seems like keeps could be a different directory.  i mean even windows can move a file without copying these days ...
15:05:28 <xplat> the other alternative is, as you suggested, an index file
15:05:47 <xplat> unfortunately xattrs/streams are not a portable solution either
15:06:32 <xplat> still way too easy to lose them in transit, especially over the network
15:06:50 <geheimdienst> so, would your use be covered by two directories (keep/don't) and sorting by modification date?
15:08:06 <xplat> of course, losing in transit with regular file tools might not be a problem here either ... especially if the temp ones get the mark instead of the perms
15:09:47 <xplat> then your only problem is if you're on unix and someone didn't enable xattrs on the filesystem
15:13:32 <adnap> if you mapM putStrLn [DirTree String], you get IO (DirTree String)
15:14:03 <xplat> :t mapM
15:14:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:14:12 <xplat> ... no you don't
15:14:43 <adnap> this is Traversable.mapM
15:14:44 <adnap> sorry
15:15:05 <hpc> @djinn Monad m, Functor f => (a -> m b) -> f a -> m (f b)
15:15:05 <lambdabot> Cannot parse command
15:15:11 <hpc> :(
15:15:40 <azaq23> @djinn (Monad m, Functor f) => (a -> m b) -> f a -> m (f b)
15:15:40 <lambdabot> Error: Class not found: Functor
15:16:14 <hpc> @djinn (Monad m, Monad f) => (a -> m b) -> f a -> m (f b)
15:16:14 <lambdabot> -- f cannot be realized.
15:16:25 <hpc> @djinn (Monad m) => (a -> m b) -> m a -> m (m b)
15:16:25 <lambdabot> -- f cannot be realized.
15:16:34 <djahandarie> djinn breaks with typeclasses sometimes
15:16:45 <hpc> shame
15:16:55 <hpc> @src mapM
15:16:55 <lambdabot> mapM f as = sequence (map f as)
15:17:02 <xplat> isn't it actually right?
15:17:09 <hpc> :t \f as -> sequence (fmap f as)
15:17:09 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
15:17:19 <hpc> humbug
15:17:23 <hpc> :t sequence
15:17:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:17:30 <xplat> that function requires an associative law, and that needs to be provided specially
15:17:34 <hpc> :t \f as -> flip (fmap f as)
15:17:34 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a -> a1 -> b) -> f a -> a1 -> f b
15:17:40 <djahandarie> :t \f as -> sequenceA (fmap f as)
15:17:41 <lambdabot> Not in scope: `sequenceA'
15:17:49 <djahandarie> :t \f as -> Data.Traversable.sequenceA (fmap f as)
15:17:50 <lambdabot> forall a (f :: * -> *) a1 (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f a1) -> t a -> f (t a1)
15:18:05 <hpc> nerd snipe successful
15:18:12 * hpc slinks away
15:18:12 <hpc> :D
15:18:17 <ddarius> Djinn breaks with constructor classes except in freak cases.
15:18:19 <Twey> Nerd-sniping in #haskell isn't even sporting
15:18:31 <hpc> yeah, it's too easy
15:18:41 <lispy> Nerd-sniping?
15:18:50 <hpc> http://xkcd.com/356/
15:18:51 <Twey> fmap sequenceA . fmap
15:19:04 <djahandarie> :t fmap Data.Traversable.sequenceA . fmap
15:19:04 <lambdabot> forall (t :: * -> *) (f :: * -> *) a a1. (Data.Traversable.Traversable t, Applicative f) => (a1 -> f a) -> t a1 -> f (t a)
15:19:26 <djahandarie> Oops, didn't notice that was just an eta reduction. :P
15:19:32 <hpc> djahandarie: lol
15:20:03 <lispy> hpc: nice
15:20:26 <Twey> Heh
15:20:39 <xplat> *distributive law
15:20:48 <hpc> i was genuinely curious at first, but after seeing the type of sequence, i gave up
15:20:54 <hpc> and then the wheels started turning in my head :D
15:21:08 <hpc> so an accident-snipe
15:21:08 <xplat> :t Data.Traversable.mapM
15:21:09 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:21:24 <hpc> xplat: awesome!
15:21:50 <hpc> though the fact that it can be done with Applicative is funny
15:23:01 <xplat> i wouldn't be too surprised if it could be done with Functor or Pointed or something, as long as you had Traversable ...
15:23:36 <xplat> slightly surprised, but not too surprised ...
15:25:54 <xplat> :t traverse
15:25:55 <lambdabot> Not in scope: `traverse'
15:26:03 <xplat> :t Data.Traversable.traverse
15:26:03 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:27:18 <xplat> i guess you can't with Functor or Pointed, because traverse is a complete definition for Traversable and it requires Applicative
15:29:46 <xplat> ah, traverse is basically like fmap except with the constructors liftA'd
15:29:58 <xplat> (at the appropriate arity)
15:30:51 <xplat> unlike Functor you don't get a unique instance, though, since flipping the constructors before lifting them can make a difference
15:30:52 <ddarius> xplat: See Conor McBride's Oregon Programming Language Summer School talk.
15:32:08 <xplat> (or you could do even crazier things ... are there laws for Traversables?)
15:33:34 <monochrom> ghc 7.0.2 rc2 is 100M?!
15:35:14 <ddarius> This proof by contradiction can be made constructive.
15:35:39 <ddarius> xplat: Traversable is basically having a distributive law and there are laws in category theory relating to distributive laws.
15:36:02 <ddarius> There's also an older paper about various ways of combining monads (and other stuff) that talks about distributive laws.
15:37:45 <xplat> yeah, i remember that paper
15:39:16 <xplat> :t fmap
15:39:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:39:29 <xplat> :t Data.Traversable.SequenceA
15:39:30 <lambdabot>     Not in scope: data constructor `Data.Traversable.SequenceA'
15:39:34 <xplat> :t Data.Traversable.sequenceA
15:39:35 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
15:41:43 <xplat> :t flip
15:41:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:42:33 <xplat> aha, caleflip is the a universal distributive law from the OTHER side, which is why Reader is not Traversable
15:43:05 <hpc> @src flip
15:43:05 <lambdabot> flip f x y = f y x
15:43:21 <hpc> @djinn (Functor f) => f (a -> b) -> a -> f b
15:43:21 <lambdabot> Error: Class not found: Functor
15:43:31 <hpc> @djinn (Monad f) => f (a -> b) -> a -> f b
15:43:31 <lambdabot> -- f cannot be realized.
15:43:34 <hpc> le fuuuuu
15:44:16 <xplat> unfortunately i took the piece of paper with source to caleflip off my desk, or at least i buried it :/
15:45:32 <ddarius> xplat: It's what you get by following the types.
15:45:34 <ddarius> @src flip
15:45:34 <lambdabot> flip f x y = f y x
15:46:02 <dmwit> :t ap -- hpc ?
15:46:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:46:14 <ddarius> :t fmap . Prelude.flip id
15:46:15 <lambdabot> forall b (f :: * -> *) b1. (Functor f) => b1 -> f (b1 -> b) -> f b
15:46:49 <hpc> dmwit: im trying to get caleflip
15:47:09 <dmwit> :t \f x -> ap f (return x)
15:47:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
15:47:11 <hpc> ddarius got it though
15:47:49 <dmwit> :t (. return) . ap
15:47:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
15:50:02 <xplat> :t Prelude.flip $ fmap . Prelude.flip id
15:50:03 <lambdabot> forall a (f :: * -> *) c. (Functor f) => f (a -> c) -> a -> f c
15:50:07 * BMeph is amused that he just finished that distributive law paper Friday night...
15:53:22 <ddarius> BMeph: You're only like 15 years behind then.
15:55:17 <Olathe> Are there any libraries that make dependency graphs easy?
15:55:57 <joe6> anyone with experience of both parrot vm vs llvm?
15:56:21 <BMeph> ddarius: Thank you! I would've said 20. You're feeling generous today... ;)
15:56:28 <joe6> llvm backend seems badly documented, but just curious of how parrotvm would compare..
15:58:55 <ddarius> BMeph: Even 20 would be better than most.
16:00:41 <azaq23> > (Prelude.flip (,)) 12 2
16:00:41 <lambdabot>   Not in scope: `Prelude.flip'
16:01:56 <xplat> last time i looked at parrotvm it suffered from 'changing faster than people can document' syndrome
16:02:21 <xplat> so there were a bunch of docs, but most of them were misleading
16:03:02 <Twey> > P.flip (,) 12 2
16:03:03 <lambdabot>   (2,12)
16:03:10 <xplat> okay, i give up, how the heck to van Laarhoven lenses work?
16:03:15 <xplat> *do
16:03:34 <joe6> xplat, ok, thanks. i am trying to do something with llvm and the docs are not of much help.
16:03:49 <joe6> xplat, so just wondering if i made the wrong choice.
16:04:19 <joe6> xplat, the software seems awesome but the docs are pretty inadequate.
16:08:29 <accel> is the following the correct way to understand haskell; when I ahve "blah = f a" I'm really saying: "blah = (lambda () (eval f) (eval a))" ; so basically in haskell, values are _not_ passed, around; closures are passed around, and they get executed on demand; and the point of seq/! is just that it removes one layer of closures
16:08:36 <xplat> llvm is a lot more mature than parrotvm afaict
16:08:58 <accel> saying llvm is more mature than parrotvm is like saying the ocean contains more water than this cup
16:09:09 <Twey> accel: Not dreadful, at least the first bit, but misses some nuance
16:09:18 <accel> Twey: where is this documented
16:09:25 <accel> Twey: I would like to dig deeply into when what gets evaluted
16:09:32 <Twey> Values, once executed, tend to be shared
16:09:38 <Twey> Er, evaluated
16:09:38 <xplat> accel: i was being conservative in case the parrot people made some series of breakthroughs since i last checked ...
16:09:47 <Twey> And seq doesn't really work like that at all
16:10:02 <aristid> parrot is worked on for a _long_ time now
16:10:04 <monochrom> I am writing a tutorial on lazy evaluation, if you can wait for two weeks.
16:10:13 <aristid> if it isn't reasonably mature, that's pretty sad
16:10:15 <sipa> one improvement may be that it's not closures that are passed around, but references to the closures; and when they are evaluated, the closure is replaced with its resulting value
16:10:18 <accel> monochrom: I demand the first page, maybe you can evaluate the first page now
16:10:22 <Twey> accel: http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation looks like it might be what you want
16:10:24 <accel> monochrom: and when I demand the second page, you can provide the second page
16:10:29 <monochrom> on the upside, it will have pictures like http://www.vex.net/~trebla/ieg.xhtml
16:10:31 <accel> monochrom: I don't ask for the entire doc at once
16:10:42 <Twey> Ooh, pictures
16:10:44 <Twey> Eep, XHTML
16:10:52 <monochrom> IE8 not supported!
16:10:57 <accel> huh there are no pngs? those are done in html?
16:11:10 <djahandarie> monochrom, it lacks a doctype though :P
16:11:21 <dankna> oh - it's inlined svg!  sweet trick
16:11:26 <Twey> Oh, embedded SVG
16:11:28 <dankna> I take it it doesn't work if you put the doctype on?
16:11:32 <monochrom> because it is html5, which says "drop the doctype"
16:11:46 <dankna> wait, how do browsers know how to go into html5 mode then :(
16:11:49 <Twey> Ah, XHTML5
16:11:50 <Twey> Neat.
16:12:02 <xplat> aristid: a significant difference between llvm and parrot is that llvm is trying mainly to package mature and well-understood compiler technology while parrot is trying to support something more like the CLOS MOP on a VM level
16:12:05 <steveklabnik> you should still have a doctype with html5
16:12:07 <Twey> Err, I don't think it says ‘drop the doctype’
16:12:10 <steveklabnik> or else you're going to get quirks mode
16:12:11 <Twey> You can have a *minimal* doctype
16:12:15 <steveklabnik> the doctype is <!doctype html>
16:12:15 <Twey> <!DOCTYPE html>
16:12:21 <monochrom> but actually browsers don't really care about the doctype for text/xhtml+xml
16:12:23 <aristid> xplat: and that's too hard of a problem?
16:12:35 * hpc longs for the day when the doctype can be removed entirely
16:12:36 <steveklabnik> oh, you're actual serving it with the real mime type too?
16:12:46 <monochrom> it says "use <!doctyle html> if text/html"
16:12:46 <Twey> hpc: Why would we do that?
16:12:49 <accel> can a function require that it's argument be evaluted?
16:12:52 <Twey> steveklabnik: It doesn't work otherwise ☺
16:12:53 <xplat> aristid: it kind of is with the constraints they've set themselves
16:13:09 <dankna> oh, you're saying the MIME type accomplishes it
16:13:11 <dankna> okay, I'll buy that
16:13:12 <Twey> hpc: I guess we could encode that information in the MIME type
16:13:14 <Twey> Yeah
16:13:15 <Twey> Heh
16:13:17 <steveklabnik> Twey: true, just nobody actually does that. everyone wants people on IE to actually be able to view their stuff ;)
16:13:20 <monochrom> my mime type is not text/html
16:13:27 <dankna> it kinda sucks that we have text/xhtml and text/xhtml+xml, but what can you do
16:13:33 <Twey> steveklabnik: I do it, when I generate XHTML
16:13:41 <hpc> Twey: i was thinking, you start from the latest version of html and work your way back
16:13:41 <xplat> i'm not saying llvm was easy, but at least if you were building llvm you could have some idea what needed to be done next
16:13:43 <Twey> dankna: We do?  I've never seen that
16:13:49 <monochrom> I haven't tried IE9
16:13:52 <dankna> Twey: xhtml vs html5, no?
16:13:58 <Twey> steveklabnik: But you can't do stuff like mixed namespaces unless you're serving real XHTML
16:14:00 <hpc> old versions can shortcut it with a doctype, and sites that are html5 can magically work
16:14:04 <Twey> So IE's going to have to take a hike ☺
16:14:05 <hpc> without a doctype on every page
16:14:09 <dankna> of course if you need to work on IE7 you need to conditionalize the MIME type on the user agent :(
16:14:22 <monochrom> "xhtml vs html5" false dichotomy. html5 permits two syntaxes, text/html and text/xhtml+xml
16:14:23 <steveklabnik> Twey: i fully support that. but you can understand why i'd assume otherwise, since you're in the minority. ;)
16:14:25 <adnap> is it common to reverse a list in order to use foldr?
16:14:26 <xplat> also, i think the llvm core developers were much more experienced with relevant tech than the parrot founders
16:14:34 <djahandarie> I really liked XHTML2.
16:14:35 <dankna> monochrom: xhtml does NOT permit text/html
16:14:40 <ddarius> adnap: Not really.
16:14:42 <djahandarie> It fixed all the stupid stuff about HTML. :P
16:14:45 <monochrom> I am not talking about xhtml
16:14:46 <hpc> adnap: why?
16:14:47 <dankna> monochrom: it's not a false dichotomy; they are two different standardization efforts
16:14:58 <hpc> reversing an infinite list doesn't work
16:15:09 <hpc> oh, so you can start at the end, derp
16:15:20 <ddarius> foldl f z = foldr (flip f) z . reverse
16:15:20 <monochrom> well have you read the html5 draft lately? cover to cover?
16:15:22 <dankna> I know you're talking about html5.  but you said "xhtml vs html5 false dichotomy".  it's a real dichotomy.  it just isn't what one might think it is.
16:15:23 <adnap> foldl can build up a huge list of unevaluated things
16:15:35 <hpc> adnap: foldl'
16:15:40 <adnap> and you can't evaluate the first thing without evaluating the whole list
16:15:40 <dankna> I really need to read up on html5, it's getting interesting
16:15:43 <xplat> djahandarie: how could they possibly fix all the stupid stuff about HTML?  that list is unending ...
16:15:45 <ddarius> @src reverse
16:15:45 <lambdabot> reverse = foldl (flip (:)) []
16:15:45 <steveklabnik> they were two different standards bodies...
16:15:51 <hpc> flipping a list that depends on the first term is iffy
16:15:57 <dankna> yeah - html5 basically deprecates xhtml, as I understand it
16:15:57 <djahandarie> xplat, well, a lot of the stupid stuff. :-)
16:15:59 <hpc> you have to evaluate the whole list to get that last term
16:16:04 <hpc> and get the same problem as foldl
16:16:09 * hackagebot digestive-functors-happstack 0.0.2.1 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.0.2.1 (JasperVanDerJeugt)
16:16:10 <adnap> once i was told not to use foldl
16:16:14 <djahandarie> xplat, but it's dead now.
16:16:14 <monochrom> ok I made a mistake. "xhtml vs html5" true dichotomy.
16:16:23 <dankna> thanks :)
16:16:29 <hpc> adnap: the two good folds are foldr and foldl'
16:16:36 <adnap> okay
16:16:42 <xplat> djahandarie: apparently the stupid stuff is what people really want from html, witness <canvas>
16:16:45 <hpc> foldl' doesn't overflow because it evaluates strictly
16:16:45 <dankna> wasn't trying to nail you to the wall or anything there, monochrom, just felt I should point that out
16:16:59 <dankna> inline svg goes way further than canvas ever did anyhow :)
16:17:11 <hpc> inline svg is pretty awesome
16:17:11 <steveklabnik> they're good for two different things.
16:17:11 <Twey> Err, doesn't HTML5 encompass XHTML?
16:17:17 <dankna> Twey: no.
16:17:17 <Twey> Using XHTML5
16:17:18 <steveklabnik> Twey: no.
16:17:21 <xplat> dankna: but people won't use it because 'it's slow'
16:17:30 <Twey> Not XHTML2, but it has an XHTML representation
16:17:44 <dankna> xplat: if they'd use it, it would get faster because browser developers would spend their optimization efforts on it :(
16:18:05 <dankna> Twey: XHTML is the name of a specific standardization effort for xml-based html.
16:18:07 <steveklabnik> Twey: think of it more as a bridge from xhtml than something that's truly around forever and ever.
16:18:14 <steveklabnik> a concession.
16:18:16 <Twey> Alright.
16:18:24 <monochrom> I don't think "xhtml5" exists.
16:18:28 <steveklabnik> monochrom: it does.
16:18:39 <steveklabnik> http://en.wikipedia.org/wiki/XHTML5#XHTML5
16:18:39 <monochrom> if anything it is really called "html5 using xml syntax"
16:18:39 <dankna> Twey: html5 is focused primarily on semantics rather than on syntax, but it does incorporate a way of putting html on top of xml, distinct from how xhtml did it.
16:18:50 <pedro3005> what is a good way of representing an n*m board in haskell?
16:19:12 <Twey> pedro3005: hmatrix
16:19:48 <monochrom> Well you could also cite http://en.wikipedia.org/wiki/God to atheists FWIW
16:20:05 <dankna> bwahahah
16:20:08 <dankna> I have to remember that line
16:20:23 <steveklabnik> monochrom: fine, http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#writing-xhtml-documents
16:20:31 <monochrom> like an encyclopedic entry settles existence questions
16:20:40 <dankna> but yeah, that's a truly unfortunate bit of naming there
16:20:53 <dankna> makes it sound like html5 is an outgrowth of the xhtml efforts
16:20:56 <dankna> when it's nothing of the sort
16:21:35 <Twey> steveklabnik: Surely that's like quoting the Bible instead, to extend the analogy ;)
16:21:49 <steveklabnik> Twey: ahahahaha
16:21:53 <Twey> I agree, it's a somewhat daft name
16:21:56 <monochrom> quote from w3.org if you want to be certain
16:22:00 * dankna once sat in an ISO meeting where a few minutes at the end of the meeting had been duly scheduled as time to spend commisserating with each other about how W3C wouldn't cooperate with them.
16:22:06 <pedro3005> Twey, how do I install it?
16:22:11 <Twey> dankna: Haha!
16:22:13 * dankna didn't get the point back then, being young, but has come to agree.
16:22:13 <steveklabnik> monochrom: whatwg are the people who make the html5 spec.
16:22:16 <Twey> pedro3005: cabal install hmatrix
16:22:16 <dankna> Twey :D
16:22:26 <steveklabnik> so whatwg.org is more canonical than w3.org
16:22:49 <dankna> yeah - that's the whole to-do about html5, that it happened behind the w3c's back
16:23:14 * hpc considers w3c to just be "that one site with good html docs"
16:23:20 <dankna> haha
16:23:23 <steveklabnik> and the w3c will be posting a frozen version of the whatwg's spec as html5, then the whatwg will be maintaining the unversioned html spec from here on out.
16:23:40 * dankna wishes they would ISO it
16:23:45 <xplat> dankna: it's probably less 'an unfortunate bit of naming' and more 'a deliberate political attempt to pee on the XHTML group's trees'
16:23:50 <dankna> xplat: true.
16:23:55 <hpc> i wish they would keep it versioned
16:24:00 <dankna> none of the stupidities that the history of HTML is riddled with would ever make it through the ISO process
16:24:11 <dankna> of course it would take longer to arrive at a standard
16:24:13 <hpc> unversioning has its merits, but eventually you get locked into a dumb decision you can't escape
16:24:17 <dankna> which is the whole disagreement betweeen the two groups
16:24:23 <xplat> enh, SGML had enough stupidities in its own way
16:24:24 <pedro3005> it failed
16:24:27 <pedro3005> "Please make sure that the appropriate -dev packages are installed."
16:24:38 <dankna> wellllll.... SGML was serving a very different need.  or failing to serve, really, I admit it was stupid :)
16:24:55 <dankna> note that SGML was meant to be a /template/ for markup languages, not a specific markup language itself
16:25:15 <dankna> so all the syntactic ambiguities in it are because of that
16:25:43 <dmwit> <!-- valid --> <!-- oh--did you think this was valid? -->
16:25:46 * BMeph will wait for "XHTML5 2.0" to come out. Because it will. :(
16:26:18 <hpc> BMeph: service pack 2!
16:26:54 <xplat> the CSS people made a pretty good case for unversioning, but i don't think it necessarily applies to HTML
16:27:09 <dankna> I'm agnostic on unversioning
16:27:28 <accel> has anyone taken the lexical structure part of the Haskell report, and directly trnsalted it into parsec?
16:27:29 <xplat> anyway it seems like the only way to make HTML sane involves a time machine
16:27:30 <dankna> really, Haskell's approach is very nice - there IS a standard but you can use features before they're standard, you just have to identify them in advance
16:27:33 <steveklabnik> i like it, but i afraid microsoft is going to ruin it just like everything else.
16:27:41 <dankna> I don't think a time machine would be sufficient
16:27:48 <dankna> maybe a time machine and a scope-sighted rifle
16:28:20 <dankna> accel: I don't believe it's an LL grammar, is it?
16:28:28 <dankna> accel: most things aren't :(
16:28:37 <Philippa> dankna: parsec isn't limited to LL grammars
16:28:45 <dankna> so it can do left recursion then?
16:28:54 <dankna> because I'm pretty sure Haskell expression syntax is left-recursive
16:28:57 <xplat> nah, you perfect the sane browser on this side, don't open source it, and by the time anyone catches up with what you've already got it's all over
16:28:58 <Pseudonym> Parsec is Turing-complete, because it has Haskell underneath it.
16:29:07 <Pseudonym> But at the very least, you can do recursive ascent.
16:29:12 <Philippa> but: it's capable of handling the lexical structure of haskell, with a little transformation
16:29:19 <dankna> My cat is Turing-complete, because he has my keyboard underneath him.
16:29:29 <Philippa> I don't recall it being hugely difficult, but my code wasn't intended for haskell itself
16:29:31 <dankna> yeah, you can do it with backtracking, it's true
16:29:43 <xplat> heh, i never heard anyone suggest recursive ascent with parsec before
16:29:43 <Philippa> oh, you don't even need to backtrack
16:29:51 <dankna> hm
16:29:54 <Philippa> you can /feed the tokens into your own parser/ if you want
16:29:58 <dmwit> :t Text.Parsec.Language.haskell
16:29:58 <lambdabot> Couldn't find qualified module.
16:30:01 <Pseudonym> xplat: Really?  Maybe people just don't use that term commonly.
16:30:10 <dankna> oh.  well that's true.  using Parsec as just a lexer.
16:30:33 <xplat> Pseudonym: people don't even use the technique commonly afaict
16:30:33 <dankna> but the original question was about directly translating the standard's BNF
16:30:36 <dmwit> Anyway, there's a lexer and a parser in Text.Parsec.Language with "haskell" in their name. No idea if they're h98-conformant or not.
16:30:36 <Philippa> and accel asked about lexical structure
16:30:46 <Pseudonym> xplat: They do, they just don't call it that.
16:30:53 <Pseudonym> Take, for example, a simple operator grammar:
16:30:54 <xplat> Pseudonym: examples?
16:30:59 <Pseudonym> E -> T
16:31:04 <dankna> is recursive ascent like operator-precedence?  where you walk the tree to figure out where to attach the next node?
16:31:09 <Pseudonym> T -> T + B | B
16:31:13 <Pseudonym> B -> n | ( E )
16:31:16 <Philippa> dankna: not how I interpret "directly" - it's still translation and not transliteration that's being asked for
16:31:17 <Pseudonym> Clearly left-recursive.
16:31:21 <xplat> dankna: see wikipedia
16:31:26 <dankna> Philippa: okay.  we took it differently then.
16:31:30 <Pseudonym> When writing a hand parser, it's usually parsed as:
16:31:39 <Pseudonym> T -> B { + B }*
16:31:47 <dankna> oh!  "Recursive ascent parsing is a technique for implementing an LALR parser which uses mutually-recursive functions rather than tables."
16:31:50 <dankna> that's a cute trick
16:31:50 <Pseudonym> If you implement that loop as recursion, it's recursive ascent.
16:31:58 <Pseudonym> More or less.
16:32:02 <pedro3005> Twey, okay, and if I have a matrix, how do I get the nth element of the mth row? Sorry, I'm looking at the docs but can't see it
16:32:29 <Pseudonym> LALR?  Oh, FSM.
16:32:51 <dankna> ya, LALR and related acronyms really describe the table-generation algorithm, not the parsing algorithm
16:32:54 <Pseudonym> FSM = Flying Spaghetti Monster, not Finite State Machine
16:32:55 <Pseudonym> Yeah.
16:33:02 <dankna> and it's unfortunate that they are in common use to mean the latter
16:33:11 <xplat> Pseudonym: ah.  i guess they use the technique unconsciously, yes.  it doesn't seem like people use it as a conscious design methodology very often that i've heard of, even under different names.
16:33:15 <dankna> I would call it a push-down automaton, but whatever works :)
16:33:22 <Philippa> I should find an excuse to define LOLR
16:33:25 <dankna> hah.
16:33:32 <dankna> what would it be though?  the LA is lookahead
16:33:41 <Pseudonym> Look over?
16:33:44 <dankna> hmm
16:33:46 <xplat> Look out!
16:33:47 <dankna> sounds like INTERCAL
16:33:57 <dankna> with its COME FROM construct for structured programming
16:34:20 <dankna> (yes - really.  implementations of this exist.)
16:34:40 <Pseudonym> You shouldn't be able to tell the difference between an LALR(1) table and an LR(1) table; the parsing algorithm is the same, given the table.
16:34:52 <dankna> Pseudonym: correct.
16:34:58 <Pseudonym> The only thing is that the unoptimised LR(1) table will be bigger.
16:35:07 <dmwit> comefrom is pretty much the same thing as goto, so it shouldn't be surprising that there are implementations of it.
16:35:15 <dankna> and LALR(1) may fail to produce an unambiguous table
16:35:24 <Pseudonym> Lambda: The Ultimate Comefrom!
16:35:39 <dankna> well, yeah, but it's a version of goto designed to be confusing to humans
16:36:09 <xplat> as opposed to one that was merely not designed not to be confusing to humans
16:36:26 <dankna> hahaha
16:36:27 <dankna> well said
16:37:28 <hpc> what about a GOAROUND?
16:37:32 <dankna> hah
16:37:37 <hpc> you put it in the exact middle of the goto and comefrom
16:37:42 <hpc> and pass it the width of the gap
16:37:43 <dankna> no, see
16:37:50 <hpc> :D
16:37:58 <dankna> a GOAROUND is an arbitrary line that says "skip this other line when conditions match"
16:38:02 <BMeph> hpc: That isn't a GOBETWEEN? ;þ
16:38:06 <dankna> it can exist at any point
16:38:11 <hpc> BMeph: yes, that
16:38:58 <xplat> 10 GET LOST 20-3000
16:39:19 <dankna> hm.  discussion on infinite types on haskell-cafe.
16:39:40 <dankna> I don't see the use-case.
16:39:55 <hpc> dankna: for writing Y without let, ofc
16:40:03 <dankna> oh, hmm
16:40:11 <hpc> (fix f = f (fix f) -- :D )
16:40:22 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105 have they referenced this excellent previous discussion yet?
16:40:23 <dankna> :t fix
16:40:24 <lambdabot> forall a. (a -> a) -> a
16:40:51 <dankna> yes, they have, dmwit
16:41:01 <adnap> @hoogle a -> Bool -> (Maybe a)
16:41:01 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:41:01 <lambdabot> Control.OldException assert :: Bool -> a -> a
16:41:01 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
16:41:10 <copumpkin> hardcore CT in progress!
16:41:20 <adnap> whaaa
16:41:29 <dankna> it's a copumpkin!
16:41:34 * copumpkin hides
16:41:36 <dmwit> :t guard
16:41:37 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:41:44 <dmwit> adnap: ?
16:41:52 <dmwit> adnap: I have in Dmwit.hs:
16:42:05 <dmwit> ensure p x = guard (p x) >> return x
16:42:08 <adnap> let foo f a = if f a then Just a else Nothing
16:42:25 <dmwit> But I guess you'd want otherGuard b x = guard b >> return x
16:42:35 <dmwit> :t \b x -> guard b >> return x
16:42:36 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
16:42:50 <dmwit> :t \p x -> guard (p x) >> return x
16:42:51 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
16:43:02 <xplat> someone did a paper on an infinite type H a b = H b a -> a
16:43:13 <dankna> hunh.
16:43:17 <xplat> launchbury and krsti
16:43:21 <dankna> oh yeah, so by the way, I have a type challenge
16:43:46 <dankna> I am attempting, on ddarius's urging, to write a Haskell implementation of "geometric algebra"
16:43:51 <adnap> @hoogle (a -> b) -> (a -> Bool) -> (Maybe b)
16:43:51 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
16:43:52 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
16:43:53 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
16:44:01 <dankna> (seriously, I mentioned I was using quaternions and he actually scoffed :) )
16:45:07 <parcs> @type \f p x -> f <$> (guard (p x) >> return x)
16:45:08 <lambdabot> forall a b (f :: * -> *). (MonadPlus f, Functor f) => (a -> b) -> (a -> Bool) -> a -> f b
16:45:38 <adnap> yeah
16:45:43 <dankna> a primitive object in three-dimensional geometric algebra is stored as a vector in the basis { 1, e1, e2, e3, e1^e2, e2^e3, e3^e1, e1^e2^e3 }, where ^ is the outer-product function they define
16:45:45 <adnap> but that is so ugly
16:46:42 <adnap> oh wait
16:46:50 <dankna> if the object has only components in { 1 }, it is a scalar; only components in { e1, e2, e3 }, it is a vector; only components in { e1^e2, e2^e3, e3^e1 }, it is a bivector; only components in { e1^e2^e3 } it is a trivector
16:47:11 <adnap> @hoogle (a -> b) -> (a -> Bool) -> a -> (Maybe b)
16:47:11 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
16:47:11 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
16:47:11 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
16:47:14 <dmwit> adnap: If (^) is commutative, it's easier to say that they're vectors in the basis consisting of subsets of { e1, e2, e3 } joined by (^).
16:47:19 <dmwit> adnap: That wouldn't be so ugly.
16:47:27 <dankna> dmwit: you meant dankna
16:47:29 <adnap> dmwit: i wasn't talking about what you were saying
16:47:39 <adnap> dmwit: sorry
16:47:49 <dmwit> oops, sorry for the misnick
16:47:52 <dankna> dmwit: yes, it would be easier to SAY that, but not easier for me to understand :)
16:48:07 <dankna> dmwit: feel free to think of it that way if you like.  it is commutative, I believe.
16:48:19 <dankna> actually let me look up whether it is
16:48:23 <dankna> as that's an important point
16:49:47 <dankna> okay.  it's commutative "or something".  I hate mathematical formalisms :(
16:49:54 <dankna> it's commutative in this way, at least
16:50:28 <dankna> anyway, so I'd love to be able to define "data Object = ..." for the actual implementation of how it's stored,
16:50:52 <dankna> and then define type synonyms Scalar, Vector, Bivector, Trivector which will match any Object that satisfies the properties to be one
16:51:14 <dankna> the type of most interesting functions is simply Object -> Object, mind you
16:51:26 <dankna> or Object -> Object -> Object
16:51:29 <dmwit> Probably easier to define data Scalar, data Vector, etc. and data Object = Scalar Scalar | Vector Vector | ...
16:51:44 <dankna> dmwit: there are also Objects which are none of these
16:51:53 <dankna> for example, 1 + e1 is none of these
16:51:55 <dmwit> Yes. Yes, of course there are.
16:51:57 <dmwit> bah
16:52:20 <dankna> thanks by the way for listening
16:52:57 <dankna> (also, I truly need a better name for it than Object.  but I can come up with something.  mathematicians just don't understand the importance of a good name in the way that programmers do! :D)
16:52:59 <dmwit> Well, Haskell doesn't really have subtyping.
16:53:04 <dankna> yeah I see that
16:53:35 <dankna> I thought maybe about a GADT with like... a type parameter for each element of the basis, indicating whether it's zero or not
16:53:36 <dmwit> Maybe the best you can do is write "type Scalar = Object" as a documented promise, rather than as something the type system can actually help you with.
16:53:40 <dankna> but that was as far as I got
16:53:59 <dankna> hmmm
16:54:00 <dankna> right
16:54:02 <dmwit> Yyyyyeeeeeessss... but then you need to encode numbers at the type level.
16:54:06 <dmwit> Do you really want to do that?
16:54:07 <dankna> wellllllllllll
16:54:11 <dankna> nooooooooooo I don't
16:54:39 <pedro3005> http://paste.pocoo.org/show/342034/ hi, can someone help me with this?
16:54:42 <dankna> especially since I want to be able to actually have Floating float => Object float (is that the right typeclass?)
16:54:57 <dankna> if these were integers, okay, I could see myself doing that work
16:55:12 <dankna> type-level floating points of some fixed but arbitrary precision?  yeah, no.
16:56:06 <dankna> let me get on to the other annoying thing about this
16:56:11 <dmwit> hm
16:56:13 <dankna> we also have like
16:56:22 <dmwit> I wonder if you really do need to encode numbers at the type level for this.
16:56:47 <dankna> (outerProduct :: Vector -> Vector -> Bivector) e1 e2 = e1^e2
16:56:55 <dmwit> Yeah, I bet you can do better!
16:57:23 <dankna> but yet, (outerProduct :: Vector -> Vector -> Scalar) e1 e1 = 0
16:57:38 <dankna> or something.  it might be e1 instead of 0, I'm not sure.
16:58:07 <dankna> I don't care about the details of this formalism, only about the fact that it forms (purportedly!  I haven't yet verified this claim!) a nice basis for representing common 3D objects and transformations
16:58:34 <dmwit> Now I'm trying to remember the relationship between phantom types and GADTs.
16:58:42 <dmwit> You may be right that GADTs are the cleanest way.
16:58:49 <dmwit> Anyway. Phantom types might work.
16:58:52 <dankna> as I understand it a phantom type is simply a type that appears on the left hand of the = but not on the right?
16:58:59 <monochrom> use 4x4 matrix for 3D transformation. objects are harder or more free.
16:59:11 <copumpkin> GADTs are give you phantom types with refinement for each constructor, among other things
16:59:24 <zenzike> is it me, or does mergesort run *much* faster than quicksort?
16:59:32 <monochrom> oh, nevermind, you want to do data Transform = Translate | Rotate | ...
16:59:42 <zenzike> (where mergesort and quicksort are the relatively naive implementations in haskell)
16:59:43 <dankna> monochrom: not getting into that discussion, but will briefly note that 4x4 matrix lacks numerical stability - much loss of information due to floating-point imprecision.  quaternions definitely better in that respect, geometric algebra supposedly better still.
16:59:45 <Philippa> zenzike: on an immutable structure? Yes, much
16:59:59 <dmwit> e.g. data Mix; data Scalar; data Vector; etc.; then, data Object a = {- whatever you want here -}; add :: Object a -> Object b -> Object (Join a b), where Join is a type function like Join Scalar Scalar = Scalar, Join Scalar Vector = Other
17:00:01 <zenzike> Philippa: thanks, I thought I must've done something mad
17:00:14 <monochrom> I am 20 years behind this :)
17:00:31 <dmwit> er, Join Scalar Vector = Mix, I mean
17:00:41 <dankna> hm
17:01:03 <dmwit> pedro3005: People might be more inclined to help if they had an idea about what >< was supposed to do. Some context code, in other words.
17:01:20 <dankna> dmwit: that's a fascinating approach, which almost works,
17:01:51 <pedro3005> dmwit, oh, it's the (><) from http://hackage.haskell.org/packages/archive/hmatrix/0.11.0.1/doc/html/Data-Packed-Matrix.html
17:02:01 <Philippa> zenzike: the immutable version of quicksort requires a pile of extra spine space (and thus allocation) amongst other things
17:02:05 <pedro3005> and I have data Cell = Dead | Alive
17:02:10 <dankna> dmwit: except that you can't write the Join type function because the result type depends not just on the input types but on their /values/
17:02:24 <xplat> the stratification can be important
17:02:32 <Twey> pedro3005: http://hackage.haskell.org/packages/archive/hmatrix/0.11.0.1/doc/html/Data-Packed-Matrix.html#v:-64--64--62-
17:02:32 <xplat> for geometric algebra
17:02:59 <dankna> the outerProduct of two parallel Vectors is a Scalar with magnitude 0; the outerProduct of two nonparallel Vectors is a Bivector
17:03:06 <dmwit> pedro3005: Okay, try adding "deriving Storable" to the end of your data declaration. If that doesn't work, you'll have to write your own Storable instance. Crib the one from Bool, likely.
17:03:07 <pedro3005> Twey, oh, yes, I found that, thank you.
17:03:08 <zenzike> Philippa: I had assumed that the partitions would be gc'd once they've been sorted
17:03:22 <xplat> the problem is, the result of an operation on objects in a single stratum can already be in two (?) strata
17:03:28 <pedro3005> dmwit, exactly, it doesn't work. How do I crib an instance?
17:03:30 <dmwit> dankna: Yeah, you have to be conservative and return Mix sometimes when you might actually have more specific information.
17:03:33 <dankna> xplat: yes - I think what you're saying is what I just said
17:03:36 <dankna> dmwit: hmmmmmm okay
17:03:38 <dmwit> dankna: Not much you can do about that without switching to dependent types.
17:03:52 <dankna> which "aren't" supported in Haskell
17:03:53 <dmwit> dankna: Types that depend on runtime information *are* dependent. =)
17:03:59 <dankna> fair enough!  haha
17:04:11 <dankna> now I understand the term, heh
17:04:15 <dmwit> pedro3005: Find the instance declaration for Bool and copy it...?
17:04:30 <pedro3005> oh
17:04:32 <xplat> you could just define injections and projections
17:04:34 <dankna> I'm actually almost leaning towards just doing everything as Object
17:04:41 <dankna> I think in the end, it may be the cleanest design
17:04:54 <dankna> the problem is that then we lose type-safety!
17:05:04 <dmwit> pedro3005: Also possible: newtype Cell = Cell Bool deriving Storable
17:05:13 <dmwit> pedro3005: (Assuming Bool has a Storable instance.)
17:05:23 <xplat> and then provide a couple of useful functions for common inject-operate-project sequences that aren't identically zero
17:05:24 <dankna> just as a floating-point value can actually be a NaN, so your not-actually-the-right-type Objects can propagate through your calculations
17:05:37 <dmwit> Yes.
17:05:39 <dmwit> That's a shame.
17:05:44 <dankna> xplat: oh, hm, I see what you mean
17:06:20 <dankna> you know, this is almost enough to un-sell me on geometric algebra, to be honest
17:06:39 <dmwit> Twey: (That has essentially the same type, so will run into the same problem.)
17:06:43 <dankna> I told tg_ I'd work on this framework with him, and he got very excited, so I feel bad backing out now
17:06:50 <xplat> i'm not sure i was ever sold in the first place, on a personal level
17:06:55 <Twey> dmwit: What's that?
17:07:12 <dmwit> Twey: The Storable constraint in the context is what was biting pedro to begin with.
17:07:12 <dankna> also I saw some numbers on the site
17:07:15 <xplat> the only reason i take geometric algebra seriously is that serious physicists seem to find it useful
17:07:24 <dankna> they went ahead and implemented some algorithms and did /measurements/ of those algorithms
17:07:38 <Twey> dmwit: Last I saw, he was just asking me how to get a particular element of a matrix.
17:07:44 <dmwit> oh
17:07:50 <xplat> spinors were first understood in terms of early forms of geometric algebra
17:07:55 <dmwit> Twey: He since discovered >< and is having type troubles with it.
17:08:02 <Twey> Oh
17:08:06 <xplat> (i'm *still* not sure i understand spinors myself)
17:08:20 <dankna> instead of like... saying... "this operation requires N flops with quaternions versus M | M < N flops with geometric algebra"
17:08:27 <dankna> and their performance numbers made it clear that actually M > N
17:08:39 <dankna> but they didn't even think like computer scientists and compute M and N
17:08:46 <pedro3005> Twey, yeah, I moved on from that, to making a matrix with a new type. but I'm about to give up and use bool
17:08:57 <dankna> I also didn't see them saying anything about the floating-point stability issue
17:09:06 <dankna> in contrast I /have/ seen both these things for comparisons of quaternions to matrices
17:09:09 <pedro3005> Can't I make it so "Dead" is a synonym of False and "Alive" is a synonym of True?
17:09:10 <Twey> pedro3005: Don't do that
17:09:18 <dankna> if physics people like it that's great
17:09:23 <Twey> pedro3005: The nice way to do it is to have a Storable instance that converts to/from
17:09:26 <dankna> if it models the physical world that's beautiful
17:09:38 <xplat> well, 3d geometric algebra is 'basically' quaternions, so the stability arguments still go through
17:09:42 <dankna> I think what I'm going to do is go ahead and implement this, it shouldn't take too long, so as to make tg_ happy :)
17:09:50 <accel> Pseudonym: what's recursive ascent?
17:09:52 <copumpkin> pedro3005: do new data type cost money or something? :)
17:10:03 <accel> Pseudonym: what's recursive ascent? (in relation to Parsec / hskell's garmmar)
17:10:04 <dankna> and then go ahead and implement my nice package using quaternions and vectors, and actually use that latter one myself :)
17:10:10 <pedro3005> copumpkin, they cost time and headaches
17:10:15 <copumpkin> really?
17:10:18 * copumpkin shrugs
17:10:23 <dmwit> pedro3005: The instance of Storable for Bool is like four lines long!
17:10:28 <xplat> and geometric algebra is easier to interpret geometrically than quaternions are
17:10:35 <dankna> I don't quite buy that
17:10:37 <dmwit> pedro3005: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Foreign-Storable.html#Storable (grep for "instance Storable Bool")
17:10:38 <pedro3005> dmwit, yeah, I saw it
17:10:49 <copumpkin> ddarius is a big proponent of geometric algebra, too
17:10:50 <dankna> a quaternion is an orientation in 3-space with a magnitude and a sign that doesn't mean anything
17:11:11 <dankna> a geometric-algebra object is an orientation or a projection or a rejection or an orthogonalization or ....
17:11:32 <pedro3005> dmwit, but it said "out of scope" to a bunch of things, do I have to import everything that that file imports?
17:11:35 <dankna> yes, ddarius is the one who got me sold on geometric algebra, copumpkin.  but now I'm coming unsold. :)
17:11:45 <dmwit> dunno
17:11:48 <Twey> Oh yeah, you could also do that
17:11:54 <Twey> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/Foreign-Storable.html#line-176
17:11:55 <copumpkin> quick, summon ddarius again to become sold once again
17:12:03 <xplat> okay, i should say it's easier to relate a clifford-thingy to OTHER elements of typical geometric practice, like vectors
17:12:04 * dankna whispers the dark incantation!
17:12:15 <dankna> xplat: fair enough.  that would be a true statement.
17:12:35 <dankna> @tell ddarius I am suffering doubts about geometric algebra!  I am coming un-sold.  Perhaps you can re-sell me. :)
17:12:36 <lambdabot> Consider it noted.
17:12:50 <dankna> it's not, like, rude to use the lambdabot messages in that way, is it?
17:13:18 <xplat> dankna: i hope not!
17:13:20 <Twey> Yes, you will be strung up by your heels at the break of dawn tomorrow
17:13:21 <dankna> good
17:13:28 <dankna> Twey: eep!
17:13:33 <accel> @tell lambdabot hehe
17:13:33 <lambdabot> Nice try ;)
17:13:39 <dankna> lol
17:13:40 <accel> preflex: help
17:13:40 <preflex>  try 'help help' or see 'list' for available commands
17:13:47 <accel> preflex: list
17:13:48 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
17:13:49 <preflex>  ZCode: [zdec, zenc]
17:13:56 <dankna> preflex: help!  fire!
17:13:57 <pedro3005> where do I find HTYPE_INT? I tried hoogle, no results
17:14:07 <accel> @tell preflex Botsnack
17:14:07 <lambdabot> Consider it noted.
17:14:15 <accel> preflex: version
17:14:15 <preflex>  0.483
17:14:15 <lambdabot> preflex: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:14:26 <dankna> xplat: I think though that I'll do what you said, when I implement this (which, as I say, I'm going to regardless) and make a newtype for each geometric entity I want.
17:14:47 <accel> do lambdabot messages expire? if not, this is a potential DOS attack
17:14:55 <dankna> let's find out!
17:15:06 <dankna> @tell accell message 0x00000001
17:15:06 <lambdabot> Consider it noted.
17:15:08 <dankna> @tell accell message 0x00000002
17:15:08 <lambdabot> Consider it noted.
17:15:10 <dankna> ... :)
17:15:16 <accel> see, this is why I need ops, to kick troublemakers trying to break lambdabot
17:15:21 <dankna> haha
17:15:24 <dankna> it was your idea
17:15:40 <adnap> does "something" exist? http://hpaste.org/44189/something
17:15:48 <dankna> adnap: cogito ergo sum
17:15:53 <accel> I merely said "gee, I wonder if it's possible to rank this bank"; you're the one implementing it :-)
17:15:58 <dankna> haha
17:16:03 <accel> s/rank/rob
17:16:03 <adnap> dankna: what?
17:16:08 <dankna> will nobody rid me of this meddlesome priest
17:16:36 <Philippa> accel: see the thing about being an op is you have to have the sense to know when to go ahead and break the bot
17:16:47 <adnap> if that means "it does because you wrote it", my question really is: "is something in a lib already?"
17:16:47 <dankna> adnap: you asked if anything existed.  I replied with the classic (though subtly not quite to-the-point) statement from philosophy that yes, clearly something exists, because you yourself exist, and you are something.
17:16:55 <adnap> yeah, i knew it
17:16:59 <pedro3005> Twey, do you know where to find HTYPE_INT?
17:17:17 <dmwit> :t scanl
17:17:18 <accel> Philippa: this soudns like a plan to get me to break lambdab ... and then get kick banned
17:17:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:17:24 <dankna> I actually didn't even click through before answering, adnap :/
17:17:32 <Twey> pedro3005: It's a CPP macro for the int type
17:17:39 <Twey> I think Int in GHC's case
17:17:44 <dankna> my attempt at humor was predicated on ignoring your quotation marks, however
17:17:48 <Philippa> accel: nah, if I wanted to k/b you I'd k/b you
17:17:51 <dankna> which is not a mistake that a programmer should make
17:17:53 <Twey> I suspect it's in HsBaseConfig.h
17:17:55 <accel> Philippa: you have ops?
17:18:00 <dmwit> :t let something f p i xs = partition snd (zip xs (scanl f i xs)) in something
17:18:01 <lambdabot> forall a t. (Bool -> a -> Bool) -> t -> Bool -> [a] -> ([(a, Bool)], [(a, Bool)])
17:18:08 <dankna> we have enough ops here, we don't need more
17:18:13 <dmwit> adnap: Something like that?
17:18:15 <dankna> they're just low-key
17:18:20 <Philippa> accel: why not ask lambdabot?
17:18:33 <accel> lambdabot: is Philippa an op?
17:18:34 <Philippa> oh, except it might piss off all the other ops if you do it in chan
17:18:35 <adnap> uhhh
17:18:50 <pedro3005> Twey, simply copying the code didn't work
17:18:54 <Philippa> heh, see, you don't even know how to cast "summon ops" :-)
17:18:57 <pedro3005> Couldn't match expected type `Cell' against inferred type `Bool'
17:19:04 <accel> Philippa: yeah; how do I cast summon ops?
17:19:06 <dmwit> whoops, no
17:19:13 <Philippa> accel: lurk moar
17:19:13 <dankna> what's the material component for that spell?
17:19:15 <dmwit> :t let something f p i xs = partition (p . snd) (zip xs (scanl f i xs)) in something
17:19:16 <lambdabot> forall b a. (b -> a -> b) -> (b -> Bool) -> b -> [a] -> ([(a, b)], [(a, b)])
17:19:19 <adnap> i wrote the type of something in my paste
17:19:27 <accel> How do I cast summon ops?
17:19:31 <dankna> @hoogle (acc -> a -> acc) -> (acc -> Bool) -> acc -> [a] -> ([a], [a])
17:19:31 <Twey> pedro3005: Yeah; we meant for you to use that as a model, not copy it wholesale :þ
17:19:31 <lambdabot> No results found
17:19:32 <dmwit> adnap: There, that's better. Gotta use 'p'. =)
17:19:37 <accel> lambdabot: help
17:19:42 <aristid> @pl something f p i xs = partition (p . snd) (zip xs (scanl f i xs)) 
17:19:42 <lambdabot> something = flip ((.) . (.) . partition . (. snd)) . (ap zip .) . scanl
17:19:46 <pedro3005> Twey, well I have no idea how to change it
17:19:46 <accel> @help
17:19:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:19:50 <accel> @list
17:19:50 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:19:58 <Philippa> accel: take your lambdabot requests to PM
17:20:25 <accel> how else can I inform others of all the things I've already tried in trying to figure out "summon ops"?
17:20:26 <Twey> pedro3005: You probably just need to change ‘if x’ to ‘if x == Alive’
17:20:45 <Philippa> accel: you could repeatedly send "BAN ME!" to the chan?
17:20:52 <Twey> And add a conditional into peekElemOff to make it return a Cell
17:20:55 <accel> http://code.haskell.org/lambdabot/COMMANDS <-- does not contain word "op" or "admin"; how do I get lamdbabot to list out all ops of the channel?
17:20:58 <dmwit> Somebody did that last night. It worked.
17:21:07 <dankna> hah
17:21:14 <dankna> yeah
17:21:14 <Twey> accel: @where ops
17:21:19 <accel> @where ops
17:21:19 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
17:21:23 <accel> Twey: ah; nice; thanks 
17:21:23 <dmwit> argh
17:21:23 <Twey> But don't do it
17:21:27 --- mode: ChanServ set +o mauke
17:21:27 --- kick: accel was kicked by mauke (stop)
17:21:30 <dankna> I was talking with some Jabber developers the other year about how Jabber MUC doesn't support ban-by-IP-address
17:21:33 <copumpkin> mauke++
17:21:35 <Twey> Heh
17:21:39 <Twey> mauke: Is that a trigger?  :þ
17:21:49 <jmcarthur> lol
17:21:54 <accel> whoa, how did you even do that, I don't se you name in teh @where ops list
17:21:59 <dmwit> accel: Philippa warned you it would piss off the ops. =P
17:22:12 <accel> is that a complete list?
17:22:15 <accel> or is that only the visible ops
17:22:16 <copumpkin> no it isn't
17:22:17 --- mode: mauke set -o mauke
17:22:21 <dankna> they eventually came around to my view that it's a necessary feature
17:22:28 <dankna> but they were kinda slow to understand it
17:22:35 <dankna> I guess because none of them have ever run IRC channels :)
17:22:36 <alpounet> hey jmcarthur 
17:22:39 <copumpkin> also, I just have a highlight on the actual text, so whether lambdabot is here or not, I'll get highlighted
17:22:41 <pedro3005> Twey, how do I do that last part? just add it in (/=) ?
17:22:42 <copumpkin> so don't do it
17:22:48 <alpounet> anything new re. your WIP library ?
17:22:51 <dibblego> accel: lambdabot accepts privmsg, you may like to use it
17:23:08 <copumpkin> accel: also, can you _please_ stop going on about getting ops. Moderation is not the topic in here, so please don't talk about it. If you have moderation questions, join #haskell-ops
17:23:11 <adnap> dmwit: dude!
17:23:13 <ozataman> is the emgm generics package abandoned? the last update was in 2009...
17:23:15 <jmcarthur> alpounet: hey what's up?
17:23:21 <adnap> dmwit: how did you cook that up so fast?!
17:23:30 <copumpkin> alpounet: I put up the category theory code on my github https://github.com/pumpkin/categories
17:23:47 <alpounet> copumpkin, oh, great! thanks for the link
17:23:52 <dmwit> adnap: Do I get to brag now? I didn't even look at your implementation. =P
17:23:57 <alpounet> will give it a whirl right away
17:23:58 <Twey> pedro3005: (\x -> if x == 0 then Dead else Alive)
17:24:30 <alpounet> jmcarthur, a lot of math :P doing a bunch of interesting stuffs i'll probably blog about some day
17:24:39 <alpounet> and you ?
17:24:41 <Twey> Or (toEnum . fromEnum . (== 0)) if your type is an Enum
17:24:46 <adnap> dmwit: yeah, you're badass
17:25:03 <jmcarthur> musing about my graphics library
17:25:07 <adnap> dmwit: i feel like that was on the tip of my brain too
17:25:11 <dmwit> yeah
17:25:30 <jmcarthur> alpounet: i made the mistake of talking to conal about it and now i have more work to do :P
17:25:31 <dmwit> Hanging out in here and watching other people cook these things up (and then trying to do it yourself) is great practice.
17:25:34 <Twey> Or ((Dead ?? Alive) . (== 0)) if you've got ?? defined :þ
17:25:41 <dmwit> I've done that for a while.
17:25:47 <conal> :)
17:25:50 <alpounet> jmcarthur, haha
17:26:03 <alpounet> yeah, sure, that's conal's fault
17:26:24 <alpounet> what did he do this time?
17:26:39 <jmcarthur> alpounet: but on the plus side we might share some work, so maybe i can avoid reinventing the wheel too much
17:27:02 <alpounet> beware, last time i talked to him that made me spend a whole night on many interesting stuffs
17:27:34 <jmcarthur> alpounet: he made me dislike my previous idea to rasterize intermediate images for sharing
17:27:46 <jmcarthur> so evil ;)
17:27:49 <alpounet> but the day after that, i had to drink like 5 or 6 coffees to be productive at my uni
17:27:55 <jmcarthur> lol
17:28:01 <jmcarthur> he tends to do that :P
17:28:30 <alpounet> jmcarthur, so what's the "plan" now for your library ?
17:28:37 <jmcarthur> edwardk makes my head explode. conal makes my projects explode.
17:28:41 <dankna> jmcarthur is working on a graphics library?
17:29:04 <alpounet> jmcarthur, same here don't worry
17:29:06 <jmcarthur> alpounet: well, the model is still the same
17:29:12 <adnap> dmwit: what's a good name for "something"?
17:29:22 <jmcarthur> adnap: something
17:29:27 <adnap> dmwit: splitUntil?
17:29:29 <adnap> no
17:29:40 <adnap> splitWith?
17:29:43 <ion> “@. slap where ops”
17:30:00 <adnap> splitAccumWith?
17:30:12 <jmcarthur> alpounet: conal is splitting off his glsl compiler from shady, so i might just use it instead of rolling my own. it doesn't include the domain-specific stuff
17:30:16 <Twey> Hm, would that parse right?  :þ
17:30:32 <dankna> it probably wouldn't work, but let's not find out
17:30:39 <Twey> Feels like it needs brackets, but I'm loath to try
17:30:42 <Twey> Heh
17:30:52 <jmcarthur> alpounet: however, it occurred to me that everything else i'm doing is also subsumed by shady, so i might just see about working with conal on that instead of doing my own
17:31:08 * conal smiles
17:31:10 <Twey> @where+ bogus_people ion Twey
17:31:10 <lambdabot> Done.
17:31:16 <adnap> partitionAccum
17:31:16 <jmcarthur> alpounet: but maybe i could focus on the subset of it that my current library is meant to tackle
17:31:17 <Twey> @. slap where bogus_people
17:31:17 <lambdabot> I won't; I want to go get some cookies instead.
17:31:28 <Twey> Ha!
17:31:33 <dankna> @where dankna
17:31:33 <lambdabot> I know nothing about dankna.
17:31:42 <aristid> @. elite where bogus_people
17:31:42 <lambdabot> I0N 7WeY
17:31:59 <alpounet> jmcarthur, so you'd focus more on the API for the library itself and conal's work would be more of a backend to your library, right?
17:32:01 <aristid> @. elite where opsNOIMTOOSCARED
17:32:01 <lambdabot> I xnOW noThIng a80uT Op$noIMT00SCAreD.
17:32:15 <jmcarthur> alpounet: i wouldn't say there is a concrete division there
17:32:19 <Twey> Wouldn't highlight anyway; should be safe
17:32:25 <ion> Some of them might.
17:32:38 <aristid> Twey: try it :)
17:32:39 <Twey> I think there's a very small chance
17:32:52 <ion> I think there’s a very great chance.
17:32:52 <Twey> Rather not :þ  Poor ops
17:33:02 <jmcarthur> alpounet: if anything the API was already created by both conal and i independently, but since we're using the same model anyway they are the same :P
17:33:10 <aristid> Twey: so you're also scared
17:33:10 <Twey> ion: Really?  It would have to leave it completely unmodified
17:33:22 <Twey> aristid: Quakin' in my boots
17:33:33 <Twey> jmcarthur: (conal and me >.>)
17:33:39 <ion> No, it might only modify letter case.
17:33:49 <Twey> Ah, point
17:33:50 * jmcarthur punchifies himself in the face
17:34:09 <accel> bare fist or with brass knuckles?
17:34:24 <Twey> Twelve times punchification!
17:34:30 <jmcarthur> Twey: for the record, i'm grateful, not annoyed. i hate it when other people mess that up like i did
17:35:02 <alpounet> jmcarthur, to sum up, that means we'll have something to test soon, right? :P
17:35:12 <jmcarthur> alpounet: ... maybe :)
17:35:27 <alpounet> c'mon
17:35:33 <alpounet> it's my birthday soon
17:35:41 <jmcarthur> shady at least works in some capacity already
17:35:42 <alpounet> make it happen heh :P
17:35:46 <jmcarthur> but not on my laptop :(
17:35:48 <Twey> jmcarthur: I usually try not to correct, but hypercorrections I can't pass up.
17:36:33 <jmcarthur> alej: hey! you were the one i was talking with about game architecture, right?
17:36:38 <alej> yeah
17:36:47 <alej> i finally got to work on it some more, if you want to see what i've come up with
17:36:50 <jmcarthur> alej: we have a channel you might like now. #haskell-game
17:36:54 <alej> oh cool
17:37:06 <aristid> damn, the #haskell-* explosion
17:37:21 <alej> irc needs to support channel directories or something
17:37:24 <Twey> Hehe
17:37:24 <aristid> right now i'm in 7 haskell related channels
17:37:27 <jmcarthur> ha
17:37:31 <aristid> alej: huh, it does?
17:37:33 <alej> "/ls #haskell"
17:37:36 <aristid> /list
17:37:37 <alej> no not really
17:37:43 <jmcarthur> if only
17:37:58 <aristid> well, /list barely works
17:38:00 <aristid> but it exists
17:38:02 <alej> well 1) i was being facetious, and 2) that doesn't really do the right thing, does it, i.e. "/list #haskell"
17:38:46 <pedro3005> Twey, gahhh http://paste.pocoo.org/show/342051/
17:38:57 <Twey> http://irc.netsplit.de/channels/?net=freenode&chat=haskell
17:40:05 <Twey> @hoogle Element
17:40:05 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
17:40:05 <lambdabot> Text.Html getHtmlElements :: Html -> [HtmlElement]
17:40:05 <lambdabot> Text.Html data HtmlElement
17:40:12 <Twey> Hmph
17:40:20 <aristid> pedro3005: what's the type of a?
17:40:25 <blbrown_win3> aristid, freenode channels?  which ones?
17:40:26 <pedro3005> Matrix Bool
17:40:48 <alpounet> copumpkin, the design looks nice
17:40:51 <pedro3005> I tried making a show instance for Element Bool and got "Element out of scope" or something
17:40:53 <aristid> blbrown_win3: #happs #haskell #haskell-blah #haskell-overflow #haskell-web #haskell.de #snapframework
17:41:12 <copumpkin> alpounet: thanks :) the naming and module structure is still a bit of a mess, but my main goal was to parametrize by equality
17:41:20 <copumpkin> and that seems to be working quite nicely
17:41:57 <Twey> Oh, there it is
17:42:05 <Twey> pedro3005: Just add an ‘instance Element Bool’
17:42:10 <Twey> All the methods have defaults
17:42:13 <pedro3005> where?
17:42:16 <Twey> http://hackage.haskell.org/packages/archive/hmatrix/0.10.0.0/doc/html/Data-Packed-Matrix.html#t:Element
17:42:19 <Twey> In your file somewhere
17:42:26 <Twey> Top-level
17:42:58 <aristid> Twey: meh, encouraging orphan instances even in the docs
17:43:14 <pedro3005> oh, thank you
17:43:16 <alpounet> copumpkin, can't wait for Yoneda.agda :P
17:43:39 <Twey> aristid: Mmm
17:43:46 <Twey> They should have more default instances in there
17:43:50 <aristid> yes
17:44:13 <copumpkin> one nice thing about agda
17:44:22 <copumpkin> is that I can talk about Hom[_,_]
17:44:24 <copumpkin> :P
17:44:44 <copumpkin> but it's easier to just do Hom A B
17:45:13 <aristid> Twey: the Element class seems to exist only to allow for optimised operaitons
17:45:45 <adnap> @hoogle (a -> b) -> (a, a) -> (b, b)
17:45:45 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:45:46 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
17:45:46 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
17:45:49 <Twey> aristid: Yeah
17:46:05 <Twey> join (***)
17:58:27 <pedro3005> is there a function that counts how many elements a there is in a list [a]?
17:58:52 <Twey> pedro3005: length?
17:59:04 <pedro3005> no, specific element
17:59:11 <pedro3005> like count 1 [1, 2, 1, 3] = 2
17:59:15 <dmwit> length . filter (==1)
17:59:24 <pedro3005> yeah that's what I used
17:59:28 <edwardk> copumpkin: =)
17:59:34 <copumpkin> edwardk: yo!
17:59:46 <aristid> :t length . filter . (==)
17:59:47 <lambdabot>     Couldn't match expected type `[a]'
17:59:47 <lambdabot>            against inferred type `[a1] -> [a1]'
17:59:47 <lambdabot>     In the first argument of `(.)', namely `filter'
17:59:59 <aristid> :t length .: filter . (==)
18:00:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
18:00:07 <Twey> Yeah, that's the best way to do it, I think
18:00:10 <Twey> There's findIndices as well
18:00:13 <copumpkin> edwardk: don't worry, semigroupoids are on the horizon
18:00:34 <edwardk> sweet!
18:00:35 <copumpkin> but I don't want to make them the most basic type because most people don't care about them :P
18:02:51 <revenantphx> One quick question.
18:03:14 <copumpkin> revenantphx: damn, I was hoping for more than one slow question
18:03:21 <revenantphx> Oh, well in that case...
18:03:23 <revenantphx> Has someone written a TH BNF quasi-quoter to generate some sort of parser/lexer/compiler?
18:03:48 <revenantphx> I'm not planning on it, but that sounds like something that'd be neat to see.
18:03:48 <copumpkin> revenantphx: parser combinators are almost BNF-looking, and allow you to interleave your semantics with the grammar
18:03:55 <copumpkin> rather than some meaningless AST that you have to postprocess
18:03:55 <revenantphx> copumpkin: this is true.
18:04:00 <revenantphx> Touché.
18:04:13 <copumpkin> it'd still be neat I think
18:04:24 <revenantphx> I'm currently really amused by parsers.
18:04:30 <revenantphx> Reading through some papers.
18:04:33 <edwardk> revenantphx: i have the better part of a lexer done in that style that i need to polish up and put on hackage
18:04:42 <Pseudonym> Parsers are cool.
18:04:58 <revenantphx> the whole left recursion thing bit me in the ass, so I've had to start some research.
18:04:59 <copumpkin> edwardk: we need your layout combinator in haskell too :)
18:05:30 <edwardk> copumpkin: it should be easy enough to port into frisbee or something
18:05:39 <copumpkin> yeah, but nobody uses frisbee :/
18:06:01 <edwardk> then clearly you need to write a new style of packrat parser for haskell ;)
18:06:05 <copumpkin> lol
18:06:20 <copumpkin> well, even a layout combinator for non-packrat parsers
18:08:02 <edwardk> well, i have that. i ported it from code i had lying around in haskell, but it works better with something packrat'ish to handle the preceeding whitespace
18:08:17 <edwardk> otherwise it spends a lot of time reparsing the same whitespace
18:08:48 <copumpkin> yeah
18:09:19 * dankna needs to finish Joy already
18:09:43 <dankna> Joy is essentially Happy and Alex in one program but incorporating some lessons I've learned the hard way through using such tools over a long period of time.  Also, with Unicode support.
18:10:08 <dankna> (Alex doesn't support UTF8, because it uses a decision table with the columns indexed by a single byte)
18:10:17 <copumpkin> yeah
18:10:20 <dankna> (or rather, s/UTF8/any Unicode thing/)
18:10:26 <copumpkin> what's amusing is that agda uses alex and hapy
18:10:32 <dankna> Joy instead generates a list of range comparisons
18:10:36 <edwardk> dankna: it was unicode lexing that actually is what derailed me from finishing luthor.
18:10:38 <dankna> it does?  hah I see
18:10:49 <copumpkin> it just preprocesses the (usually copious) unicode out of the file
18:10:49 <edwardk> dankna: i wanted to have a nice space efficient coding
18:11:00 <dankna> edwardk: oh?  I didn't know of luthor's existence or I would have proposed a collaboration.
18:11:04 <dankna> that part is actually implemented in Joy
18:11:19 <dankna> all that's needed is some front-end work and it would be ready for a 1.0 release, really
18:11:33 <edwardk> dankna: basically the idea is to do the lexer generation in a TH quasiquoter
18:11:42 <dankna> oh, yeah, I decided against that
18:11:45 <edwardk> dankna: that way you don't need any hideous external tool
18:12:01 <dankna> I had, years ago, written the predecessor to Joy in Common Lisp
18:12:04 <edwardk> and it can work in nicely with antiquotations, and doesn't break up your build process
18:12:13 <drhodes> It appears that .cabal (or symlink) must be in /home/user/, can someone confirm this?
18:12:17 <dankna> even in CL with CL's dynamicism, doing it in the equivalent of a quasiqouter turned out to be the wrong approach
18:12:32 <edwardk> how so?
18:12:41 <dankna> there are several reasons it's the wrong approach, but the biggest one is that it prevents the system from ever being self-hosting.
18:12:43 <edwardk> it worked out quite nicely for me ;)
18:13:07 <aristid> edwardk: antiquotations is edwardk-speak for quasiquotations?
18:13:08 <dankna> well, then I'm impressed, and of course I wish you luck, but I won't be adopting that myself
18:13:23 <edwardk> self-hosting wasn't a big requirement, the grammar for a lexer is simple enough that i can impelement it twice without a huge amount of overhead. parsec exists after all
18:13:24 <dankna> if it runs as a file-level preprocessor, you can ship the preprocessed copy of its own source code and people can compile it without already having it
18:13:28 <dankna> note that Happy depends on Happy to build
18:13:31 <dankna> and Alex depends on Alex
18:13:38 <dankna> (weirdly, Happy does not depend on Alex)
18:13:44 <edwardk> aristid: no, an antiquotation is an 'escape' from a quasiquotation to inject haskell inside
18:14:01 <aristid> edwardk: oh, didn't know that that exists
18:14:03 <dankna> well
18:14:08 <dankna> one of the lessons I've learned, see
18:14:18 <dankna> is that you really do want at least strong lexical understanding of the client language
18:14:34 <dankna> so you can at least get a proper stream of lexemes for the embedded snippets of codes and types
18:14:40 <dankna> otherwise how can you do good error-reporting?
18:14:47 <edwardk> dankna: my main concern is that i can use it to generate an efficient lexer, the efficiency of lexing the lexer is not that high on my priority list
18:15:00 <dankna> edwardk: oh I'm not saying efficiency at all
18:15:09 <dankna> I'm saying I can make it more featureful as a reasult of it being self-hosting
18:15:12 <dankna> *result
18:15:24 <dankna> I agree that efficiency would be a bad reason
18:15:48 <dankna> as it's a compilation process, really it could be lexed by bogolex and it would still be fine
18:16:02 <dankna> (that's the algorithm where you generate a random stream of lexemes, check if it's the correct one, and iterate if not)
18:16:06 <edwardk> my design target was "utf-8 alex sans external tools". the grammar is simple, etc. and embedding it as a quasiquoter admits a number of other user extensions as an EDSL
18:16:20 <dankna> yeah, okay.  so my design taret is more ambitious.
18:16:24 <edwardk> i mostly needed it as a side-effect
18:16:37 <edwardk> brb
18:16:57 <dankna> I agree that it's conceptually nice and tidy to not need a preprocessing phase
18:17:04 <dankna> but really you DO want that phase
18:17:08 <dankna> for the reason I gave above
18:17:18 <dankna> also
18:17:29 <dankna> if you want to redistribute the generated system
18:17:37 <dankna> without requiring your users to depend on your system
18:17:48 <dankna> and ESPECIALLY, you need it if you want to support multiple client languages
18:18:02 <dankna> I have ambitions for targeting Haskell, C, and Java from Joy
18:18:41 <dankna> (because I think that combination of languages covers all serious use-cases.  some people use Haskell because they're smart; some people use C because they have to; some people use Java because their boss told them to.)
18:19:10 <dankna> I wouldn't be adverse to Javascript as the client, either, except I'd rather subsume that with Haskell-to-Javascript compilation :)
18:19:48 <dankna> anyway, you're afk so I'll pause in my rant to let you catch up
18:33:53 <ddarius> dankna: 0 is special.  There's just one 0.  It's not a 0 scalar and a 0 vector.  Furthermore, what you are calling "Object" is called a multivector.  It's just a linear combination of k-vectors for every k.
18:33:54 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
18:34:11 <dankna> ddarius: oh!  hi thanks
18:34:21 <dankna> no - multivector is a more general thing
18:34:40 <dankna> blade is product of "Object", multivector is sum of blades.  yes?
18:34:52 <dankna> that was the understanding I took from it
18:35:08 <dankna> I did realize that 0 was special, yes
18:35:19 <dankna> I wasn't quite sure how to refer to it, but I knew it was just one of it
18:35:30 <ddarius> A k-blade is any k-vector that can be represented as a wedge product of k vectors.
18:35:57 <dankna> so you're saying it's a subtype
18:36:47 <ddarius> dankna: You could say that, if you are also willing to say things like a rotation matrix is a subtype of arbitrary 3D matrices (or really nD for n >= 2.)
18:37:12 <ddarius> Also, spinors aren't k-vectors for any k, so you don't really want to have that stratification.
18:37:16 <adnap> so, readDirection gives FilePath :/ DirTree String, but when do a mapM putStrLn . toList $ dirTree on the DirTree, I get a bunch of blank lines
18:37:22 <adnap> *readDirectory
18:37:41 <ddarius> I believe what Jaap Suter did was essentially store what grades were occupied in the type (or an approximation thereof.)
18:37:42 <adnap> doesn't the String denote file paths?
18:37:58 <dankna> ddarius: I am willing to say a rotation matrix is a subtype of arbitrary 3D matrices :)
18:38:35 <dankna> ddarius: yeah, but how can that be modelled in Haskell?
18:38:57 <dankna> ddarius: and... did you see my concerns above about this not necessarily being computationally better?
18:39:53 <ddarius> dankna: The quaternions -are- the even subalgebra of the 3D geometric algebra and you can specialized the code (manually or automatically) into -exactly- the same calculations.
18:40:09 <dankna> ddarius: then why is their code slower?
18:40:16 <ddarius> Whose?
18:40:24 <dankna> they did an empirical benchmark
18:40:24 <dankna> one sec
18:40:57 <dankna> http://staff.science.uva.nl/~fontijne/raytracer/rayperf.html
18:41:14 <dankna> it 3D linear algebra being faster by a factor of 2.5
18:41:36 <dankna> now, as a computer scientist (disclaimer: I am not actually a computer scientist)
18:41:46 <dankna> I have questions like "how many floating-point operations is it using then"
18:41:53 <dankna> and "is the algorithm the same O()?"
18:42:16 <dankna> this study, at least, does not show any awareness that we have tools besides the empirical for describing how algorithms perform
18:42:21 <ddarius> dankna: I'm fairly certain they didn't any of the specialization that I'm talking about.
18:42:25 <dankna> and I am therefore dubious of their claims to be on the verge of revolution
18:42:42 <ddarius> +do
18:42:48 <dankna> yes, clearly they didn't do any of the specialization, in fact, because then they would have gotten better performance :)
18:42:58 <dankna> also I know they didn't, because they used autogenerated code for these figures
18:43:10 <dankna> they wrote an engine that generated the code for N dimensions
18:43:28 <adnap> ah, whatever.  this works: mapM (putStrLn . fst) $ toList . zipPaths $ dirTree
18:44:13 <sshc> Is there a way to specify the default type for 'RealFloat', as 'Integer' is for the 'Integral' class?
18:44:55 <ezyang> it would be pretty neat if we had 200L notation, and friends</speculah> 
18:45:40 <rcl> Has anyone used the Haskell Objective-C FFI via GHC, I am trying to figure out if it spits out objective-c or if theres some kind of interpreter or interface that occurs at runtime?  
18:45:43 <dankna> sshc: look at the Haskell report's "default" declaration.
18:45:55 <dankna> rcl: hoc is broken :( I'm writing a replacement this week
18:46:06 <dankna> but it's supposed to be a runtime interface
18:46:13 <aristid> adnap: couldn't the first $ be a .?
18:47:11 <rcl> dankna: Broken doesn't sound good!  Ok so it's a runtime interface.. that becomes problematic for me b/c I'm looking at it for iOS use so it could be rejected.  Is there any solution out there that does spit out objective-c from haskell?  Or from any functional language (heresy)
18:47:15 <ddarius> dankna: At any rate, I wasn't recommending GA because it will make your code blaze.  I said right at the get go that it takes a fairly sophisticated implementation to let you write what you do on paper and have it perform well.
18:47:36 <dankna> rcl: I believe Apple relaxed the restriction you're thinking of, check the up-to-date wording.
18:47:41 <dankna> rcl: and no.
18:47:50 <dankna> rcl: well, rather, not easily and I'm distracted
18:47:59 <dankna> ddarius: you did say that at the outset, yes.
18:48:08 <dankna> ddarius: I just didn't properly absorb it in time
18:48:17 <dankna> ddarius: okay, so sell me on it again for the right reasons this time :)
18:48:35 <ddarius> dankna: What are Maxwell's equations?
18:48:36 <rcl> that's NP thank you, 2 more Q's are is HOC in some state of flux where it's broken/unbroken a lot (is it mature I mean?), and are there apps shipping using it? 
18:50:01 <dankna> ddarius: the equations that describe the behavior of light, aren't they?
18:50:26 <tg_> dankna: yes, they describe everything about electromagnetism
18:50:32 <ddarius> dankna: There the equations that describe electromagnetism in general, but I was asking you to write them down.
18:50:37 <dankna> rcl: no shipping apps that I'm aware of use HOC.  HOC is essentially dead; there has been no traffic on its mailing list in over a year.  the name of my clean replacement package will be direct-cocoa.
18:50:59 <dankna> rcl: note that compiling to run on ARM is not officially supported by GHC, although it may be possible!
18:51:10 <tg_> dankna: good evening
18:51:18 <dankna> ddarius: I would have to go to wikipedia to do that.  would you like me to?
18:51:29 <ddarius> dankna: Sure.
18:51:36 <rcl> interesting, ok thank you very much and good luck on direct-cocoa
18:51:38 <dankna> tg_: good evening.  I still intend to write this project with you because you were just SO excited about it, but I'm not convinced that it actually meets my needs :)
18:51:41 <dankna> rcl: thanks!
18:51:48 <ddarius> dankna: While you work on that, let B be a bivector, i.e. a "plane element".  Then a rotor in that plane is e^(θ/2 B) = cos(θ/2) + sin(θ/2)B.  Alternatively, given a unit vector u and another v, if you want to rotate v into u, just do uv^-1 and that's the rotor from v to u.
18:51:58 <dankna> ddarius: while I work on that whaaaaa
18:52:14 <tg_> dankna: re: performance, I think the point of GA is to understand the subject better, not to write it most efficiently
18:52:39 <dankna> tg_: that may be.  ddarius is making that case to me.
18:52:56 <ddarius> dankna: Anyway, you can just tell me when you've looked at the section with the actual (differential form) of Maxwell's equations.
18:53:10 <tg_> ddarius: thinking about this, GA must be able to represent gauge invariance in a slightly different way than usual
18:53:23 <dankna> okay so like..... I have looked at http://en.wikipedia.org/wiki/Maxwell%27s_equations#Maxwell.27s_.27microscopic.27_equations
18:53:30 <ddarius> dankna: Yep.
18:53:31 <dankna> it uses notation I don't even understand :)
18:53:44 <dankna> wtf double integral with circle through it
18:53:47 <dankna> anyway.
18:53:50 <drhodes> path integral
18:53:53 <tg_> dankna: path
18:53:54 <tg_> ...
18:53:55 <ddarius> dankna: Here's Maxwell's equation in the spacetime algebra (a 4D Minkowskian geometric algebra).  ∇F = J.
18:54:06 <dankna> okay, yeah, formal education and me don't get along, so I never learned past intro calculus :(
18:54:51 <dankna> Edison said "If I want a mathematician, I can hire one" - but he was wrong.  So I am sad that I don't understand advanced Calculus. :/
18:54:59 <ddarius> (You can get close to that with exterior algebra and the Hodge operator, but that's exploiting the 'no magnetic monopoles' fact.)
18:55:06 <dankna> ddarius: that's impressive!
18:55:28 <tg_> ddarius: can you write that equation somewhere else so I can read it? my irc client isn't displaying it properly
18:55:42 <dankna> tg_: the equation he wrote was F = J.
18:55:49 <ddarius> tg_: The unicode was just a del operator (upside down triangle).
18:55:53 <tg_> oh ok
18:55:55 <dankna> oh, I didn't see the unicode
18:55:58 <ddarius> Looks like the Nabla character.
18:56:09 <tg_> ddarius: that can't be all of it
18:56:14 <tg_> you need at least 1 other equation?
18:56:20 <ddarius> tg_: No.  
18:56:40 <tg_> how do you differentiate magnetic charge from electric charge?
18:56:49 <tg_> oh, no monopoles breaks that explicitly
18:56:56 <ddarius> tg_: F = E + Bi where i is the pseudoscalar.
18:58:03 <tg_> ddarius: ok, in that case, though, you need at least dJ = 0
18:58:06 <tg_> right?
18:58:31 <ddarius> tg_: That's a consequence of J being a bivector.
18:58:42 <ddarius> (And Maxwell's equation.)
18:58:51 <tg_> I don't see that yet
19:00:31 <tg_> http://en.wikipedia.org/wiki/Bivector#Maxwell's_equations
19:01:26 <tg_> ddarius: ah, that is dual in three dimensions to the curl. 
19:01:51 <dankna> okay okay, so I'm sure this is nice and fascinating from a physics standpoint.  but my original use-case was to represent and apply affine transformations in 3-space.
19:02:27 <dankna> now
19:02:32 <dankna> GA does have some attraction
19:02:32 <tg_> ddarius: I'm surprised I haven't seen this notation before for Maxwell's
19:02:36 <ddarius> dankna: And I showed you how quaternions (rotors) come straight from some simple calculation and a direct generalization of Euler's formula.
19:02:51 <dankna> I could represent volumes (axis-aligned and even non-axis-aligned bounding boxes, for example) in it
19:02:54 <ddarius> And also, how to generate these given two vectors.
19:03:01 <dankna> which would be a broadening in scope from what I originally intended, but certainly it's something I could use
19:03:04 <tg_> ddarius: it looks like it would actually survive quantization and will still have real gauge invariance
19:03:07 <ddarius> There's also a formulation for screw transformations.
19:03:51 <dankna> ddarius: wait, you showed me that?
19:04:00 <dankna> ddarius: are you sure you didn't show someone else that?
19:04:08 <ddarius> dankna: Also, if you are aware of Pluecker coordinates, these are straightforward to understand in a GA context.
19:04:15 <ddarius> I didn't show the screw transformation stuff.
19:04:16 <tg_> ddarius: why did you learn this stuff originally? physics? just geometry?
19:04:40 <dankna> I'm not actually aware of them, but okay
19:05:47 <kulakowski> dankna: You might have seen them before but not by name, if you've ever done anything with projective geometry.
19:06:07 <dankna> that is possible, but I really doubt that I have.  I very seldom go beyond three-dimensional coordinates :)
19:06:28 <ddarius> tg_: Someone mentioned it on comp.lang.lisp and I started looking at Leo Dorst's stuff originally and also at David Hestenes' stuff and it was just way better than everything else.  It massively amplifies understanding and clarifies, so that high schoolers could do today what are typically late undergraduate classes.
19:06:31 <dankna> I even live in Euclidean space most of the time, except when I live in two-dimensional hyperbolic space of course, because that's also an important one. :)
19:06:43 <ddarius> dankna: Projective = homogeneous coordinates.
19:06:57 <ddarius> If you've used 4D matrices, you've use homogeneous coordinates.
19:07:04 <dankna> okay.
19:07:53 <ddarius> tg_: I just find it enlightening everywhere it touches, particularly physics and geometry, but also things like the fundamental theorem of calculus.
19:08:02 <dankna> so you've made a good case that this would be an important library to have for any sort of investigation into physics or geometry
19:08:24 <ddarius> dankna: I never did actually recommend you make a library.
19:08:30 <dankna> I'm still unconvinced that it really meets my original problem description all that well.  I mean, bottom line, it's slower.  yes, by a small constant factor, but these operations are in an inner loop.
19:08:31 <dankna> true :)
19:09:19 <ddarius> dankna: If you already have good quaternion code, this isn't going to change anything.  The good GA code would be the same.  The goal is to understand it from a better perspective and be better able to generalize.
19:09:31 <tg_> dankna: at the very least, just like using haskell will help you understand computation, using GA should help you understand geometry
19:09:42 <dankna> yes, I think it's worth at least taking the time and writing it
19:09:48 <ddarius> dankna: For example, quaternions are 3D rotations.  e^(theta/2 B) works in any dimension (> 2) whatsoever.
19:09:55 <dankna> I'm just not sure it's worth using it once I have written it :) but hey, it could be useful to other people.
19:10:13 <dankna> hmmm, true
19:10:16 <Eduard_Munteanu> Raytracers?
19:10:25 <Eduard_Munteanu> I think somebody was working on that.
19:10:27 <dankna> Eduard_Munteanu, actually no, games, but.
19:10:35 <dankna> there is a raytrace in Haskell, HRay, but it's not mine
19:11:03 <Eduard_Munteanu> I'm not sure how much use is this in games since you'd be using the hw stuff anyway.
19:11:18 <dankna> that's not exactly true, but join #haskell-games if you have opinions on that :)
19:11:25 <ddarius> dankna: Also, for things like uv^-1, you don't have to implement a geometric algebra system to use that to work out a calculation to get a rotor (quaternion) from two (unit) vectors.
19:11:37 <Eduard_Munteanu> Heh.
19:12:02 <dankna> hm
19:12:07 <jmcarthur> Eduard_Munteanu: parallax mapping is not an uncommon feature for real time graphics engines, and it's essentially ray tracing
19:12:38 <jmcarthur> on the gpu, of course
19:13:05 <dankna> anyway, tg_, I still want to write this, it seems likely that I'll learn at least something from it
19:13:05 <jmcarthur> Eduard_Munteanu: or were you just talking about haskell implementations of ray tracers?
19:13:06 <ddarius> (Incidentally, for unit vectors, v^-1 = v.)
19:13:06 <Eduard_Munteanu> Well you probably mean realtime raytracing, done on GPGPUs.
19:13:19 <dankna> also it seems a shame to waste the design work that I've done so far, with help from dmwit
19:13:28 <jmcarthur> Eduard_Munteanu: well no, i actually mean in glsl shaders
19:13:42 <Eduard_Munteanu> jmcarthur: ah no, I commented on what dankna said, he was unsure who could use a Haskell quaternions lib
19:13:46 <jmcarthur> ah
19:13:53 <dankna> Eduard_Munteanu, no, I believe you misunderstood what I said
19:14:08 <jmcarthur> quaternions are great for physics
19:14:22 <dankna> Eduard_Munteanu, /I/ could use a Haskell quaternions lib.  I'm unsure who could use a Haskell geometric-algebra lib.  but I'm convinced that the audience would be nonzero.
19:14:32 <Eduard_Munteanu> Oh.
19:14:38 <ddarius> As for how to do what others have done (usually in C++), you do the same template metaprogramming stuff they do using the Haskell analogue, or just use TH (or something else.)  Admittedly, the Haskell analogue of C++ template metaprogramming doesn't produce nearly as nice output code as the C++ original.
19:14:49 <dankna> I'm a big fan of quaternions, they're one of the more abstract mathematical concepts that I actually have a grasp on.
19:15:11 <dankna> ddarius, yes, I found their paper on how they implemented it
19:15:16 <jmcarthur> i once thought i had a grasp on quaternions, but then i didn't use them for years and now i have forgotten everything
19:15:24 <ddarius> dankna: Whose?
19:15:35 <dankna> ddarius: uhhh lemme check!  I saved it to my papers database for later reading
19:15:39 <ddarius> jmcarthur:  Do you remember Euler's formula?
19:15:40 <Eduard_Munteanu> Abstract? They always seemed to me like complex numbers on steroids :P
19:16:22 <accel> What's a good tutorial on the advanced features of Haskell? I.e. monad transformers, arrow, ... and pretty much anything not covered in RWH/SoE?
19:16:42 <ddarius> Those aren't features, they are just interfaces/libraries.
19:16:59 <accel> What's a good tutorial on the advanced interfaces/libraries of Haskell? I.e. monad transformers, arrow, ... and pretty much anything not covered in RWH/SoE?
19:17:01 <Philippa> often the original papers're decent if you're coming from the right perspective
19:17:19 <accel> if not, I may just start reading the soruce of Control.Monad
19:17:33 <Eduard_Munteanu> I think monad transformers are covered in RWH, IIRC.
19:17:34 <ddarius> accel: Go ahead and read it.  It won't take you five minutes.
19:17:40 <Philippa> monad transformers're pretty easy, they're just "functions" that take a monad and give you another one
19:17:44 <dankna> "The Making of GABLE, a Geometric Algebra Learning Environment in Matlab" on http://www.science.uva.nl/ga/publications/index.html
19:17:59 <accel> ddarius: I never claimed it would take me five minutes
19:18:00 <dankna> Stephen Mann, Leo Dorst, and Tim Bouma.
19:18:04 <Eduard_Munteanu> accel: you should really look those up on the haskell wiki, and/or google
19:18:05 <ddarius> dankna: That's not geared towards writing programs let alone performance.
19:18:07 <alpounet> accel, there are some nice explanations in the Haskell wikibook
19:18:07 <Philippa> it'll take you a moment to get used to which order the syntax goes in, but after that? Piece of cake
19:18:08 <accel> I'm just trying to find a good way to learn this stuff
19:18:23 <Eduard_Munteanu> Also Wikibooks has some advanced stuff.
19:18:24 <ddarius> dankna: Look at some of the C++ implementations.
19:18:48 <Philippa> you'll find the source is less helpful than you'd like, accel
19:18:49 <ddarius> dankna: That said, those papers probably do have useful information.
19:18:56 <dankna> ddarius: okay
19:19:03 <Philippa> (though it's worth peeking at sometimes, still)
19:19:06 <accel> Philippa: hmm, waht is most useful then?
19:19:18 <accel> actually, now that I think about it
19:19:25 <Eduard_Munteanu> accel: http://en.wikibooks.org/wiki/Haskell
19:19:30 <accel> what I want to learn ... is about all the cool monads
19:19:38 <Philippa> honestly? I wouldn't know, I learned that stuff years back and I expect new resources exist since then. But Eduard_Munteanu keeps pointing you at something
19:19:41 <ddarius> @google all about monads
19:19:42 <accel> i.e. having seen how maybe/state moands are learned
19:19:44 <lambdabot> http://horna.org.ua/books/All_About_Monads.pdf
19:19:44 <lambdabot> Title: All About Monads Contents
19:20:16 <accel> man that's an ugly pdf
19:20:56 <Eduard_Munteanu> I particularly liked the more theoretical approach to zippers, well apart from the long Ariadne story...
19:20:59 <ddarius> accel: It's generated from a web page.
19:21:08 <accel> ddarius: I noticed
19:21:33 <Eduard_Munteanu> Also don't forget LYAH...
19:21:35 <Eduard_Munteanu> @where lyah
19:21:35 <lambdabot> http://www.learnyouahaskell.com/
19:21:42 <Eduard_Munteanu> (you didn't mention it)
19:23:05 <Eduard_Munteanu> Though arguably, there ain't much beyond zippers there that could go into "advanced"
19:43:23 <ivanm> I'm wanting to implement functionality to mimick "tred" into graphviz; can anyone suggest a way of dealing with duplicate edges without explicitly "iterating" through them?
19:44:18 <ivanm> I was originally planning on doing it by extracting out all the structural info from a graph and then defining a function to create a new one from the edited structural info, but that could change the way its defined (so it would be visualised the same but not have the same layout)
20:05:59 <adnap> dead dead dead
20:17:21 <tg_> ddarius: you know what GA's weaknesses are?
20:17:37 <tg_> i mean, without having had time to analyze all of it
20:18:46 <adnap> http://hpaste.org/44192/all_files_must_go
20:23:55 <tg_> dankna: here?
20:27:15 <adnap> i think this is the worst program ever
20:27:46 <adnap> i never had so little fun
20:27:48 <tg_> adnap: minecraft?
20:27:51 <adnap> lol
20:28:03 <adnap> no, my file removing thingy
20:28:26 <adnap> it probably wont even get used.  someone wanted me to write it.  i haven't finished it either.
20:28:49 <adnap> i hate io
20:29:21 <siracusa> adnap: What does it do, rm -rf?
20:29:28 <adnap> no
20:30:02 <adnap> it deletes files from directory X according to their access time until Y bytes have been deleted
20:30:24 <adnap> i would have just written a bash script, but it has to run on windows
20:32:04 <adnap> also, isn't minecraft cool?  i thought it was cool.
20:32:19 <adnap> i don't really play it, but my friends all love it.
20:32:39 <Twey> It has retro graphics, which makes gamers feel like real geeks ;)
20:32:49 <adnap> siracusa: lol, it would be funny if it took me 40 lines to write rm -f
20:33:23 <adnap> retrooooo
20:33:34 <adnap> like, awwwwww dude
20:34:50 <tg_> never played it. just a quip
20:36:17 <adnap> my friend said it sends your password to the server in the clear
20:40:29 <deech> A style question, I have a large number of statements in IO a couple of which might throw (Either) errors. I can pack all the code into an ErrorT monad, but that means littering my code with liftIO. The only alternative I can see is to manually check the erroring functions. Is there something else I can do?
20:42:22 <aavogt> use functions that already have the liftIO applied?
20:42:28 <aavogt> @ty liftIO . putStr
20:42:29 <lambdabot>     Ambiguous occurrence `liftIO'
20:42:29 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
20:42:29 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
20:43:15 <deech> aavogt: Unfortunately I don't think I have access to variables bound in a liftIO statement, correct?
20:43:17 <aavogt> @vizen how many mtl do you have?
20:43:17 <lambdabot> let's just say a few
20:43:33 <deech> Outside the liftIO I mean.
20:44:02 <dino-> re: minecraft .. Didn't they get $20M in sales so far? Wish I thought of it.
20:45:13 <aavogt> deech: like the 'a' here:        liftIO $ let a = ... in ...  ?
20:45:59 <aavogt> if you need to get things out, you can use IORefs if for some reason you can't make the scoping comply
20:46:14 <dino-> deech: This may not really be helpful, but one thing I do is make do blocks inside my ErrorT actions to I can apply liftIO at least once per group of related things, if possible/sensible.
20:46:29 <dino-> s/to/so/
20:46:47 <deech> aavogt: Something more like: do { x <- liftIO $ do { a <- ...; b <- ...}; func b}
20:47:36 <deech> I want the 'b' in func b to refer to the 'b' in the liftIO statement
20:48:21 <deech> dino-: And what if different liftIO blocks need access each others variables?
20:48:23 <aavogt> and it's annoying to put    (x,a,b) <- liftIO $ do { ... ; return (x,a,b) }
20:49:03 <dino-> deech: You can <- from each of those, draw the 'final' value out of a give IO block
20:49:07 <dino-> To be used elsewhere.
20:49:13 <dino-> s/give/given/
20:49:20 <ddarius> tg_: The main weaknesses of GA is that it is a non-commutative algebra which most people only have a vague familiarity with if any, it's definitely less wide-spread so there are less books/software/papers/courses/etc., it's more structured than tensor algebra so it's more difficult to represent unstructured things, it's more difficult to implement than just matrices, say.
20:49:48 <tg_> ddarius: I've been reading about the answer to that question
20:49:51 <tg_> and I stumbled on: http://www.garretstar.com/gsobczyk.pdf
20:50:19 <dino-> deech: Maybe we should work on an actual example.
20:50:52 <deech> dino-: Sure, this is certainly an alternative. I guess I was just looking for a way to do something like : (runErrorT $ do { some-io;some-io;some-erroring-func;some-io;...}) `catchError` ...
20:50:54 <dino-> Because I'm suspecting I don't know what you're up against exactly.
20:51:04 <drhodes> I've got a prototype for a 'jailed' haskell environment that should allow for more than one (ghc/cabal) install without interference.  It's sleezy.  Through a wrapper script it calls cabal like  $ HOME=/path/to/fakehome/.cabal cabal cmd; ...  Before I sink more time into this, does anyone see anything that will break by temporarily shadowing $HOME while cabal runs?
20:51:20 <deech> dino-: Sure I'll post something in a second
20:51:52 <dino-> This is all because IO can't be escaped from. My take on it is it's a wart on using transformers because of the one-way-ness of IO
20:52:29 <tg_> ddarius: I got the link from here http://www.physicsforums.com/showthread.php?t=93454
20:53:01 <ddarius> David Hestenes and Garret Sobczyk's book "Geometric Calculus" is fantastic and has material that isn't available anywhere else as far as I know.
20:54:02 <deech> dino-: Here it is: http://hpaste.org/44194/io_and_error
20:56:39 <dino-> deech: So, there's liftIO going on down in, say, runReadCSV?
20:57:18 <duckinator> in something like `foo [x] = x`, [x] matches only a single-item list, right?
20:57:35 <dino-> (Guessing that's your ErrorT thing where you'd like to not have so much liftIO happening)
20:57:42 <ddarius> tg_: I tend to lean toward Hestenes' views by and far.  So I'm not particularly interested in geometric algebra over complex fields.
20:57:47 <deech> dino-: Yes, runReadCSV is a wrapper around a runErrorT $ ...
20:58:34 <deech> So at this point the code is ugly because it staggers each time I have an error I want to handle. 
20:59:26 <deech> But since there are vastly more IO operations than ones that can error it is significantly less ugly than appending liftIO to all my IO ops.
20:59:40 <deech> I'm wondering if there's a better way.
21:02:25 <ivanm> OK, for some reason ghci can't find other modules from my library when using :m :s
21:06:02 <dino-> deech: In that (runErrorT $ liftIO do { some-io; some-io; some-erroring; some-io;... }) I wonder if you can throwError "up" to the ErrorT
21:06:33 <quuuux> question: why is there no combinator `list :: b -> (a -> [a] -> b) -> [a] -> b' analogous to maybe?
21:06:48 <dino-> I'd have to write something quick. I'm fuzzy on if this would check.
21:08:34 <dino-> deech: But, bleh, I guess one would have to catch in that do { } too for IO first and then kind of rethrow.
21:09:29 <deech> dino-: Yeah, I just get this feeling I'm missing something. 
21:11:19 <quuuux> dino-: you could write an instance for MonadIO HypotheticalErrorT that does that
21:11:59 <quuuux> actually, I think MonadCatchIO might do that already
21:16:53 <deech> I just found a Stack Overflow question (http://stackoverflow.com/questions/2216164/haskells-liftios-litter-functions-of-type-errort-string-io) that asks pretty much the same thing. The answer was that I have to live with one of the two alternatives.
21:16:58 <dino-> quuuux: You know, I only really have any experience so far with mtl. I need to read about transformers. And also grok fd and tf better.
21:19:01 <quuuux> deech: yeah, unfortunately, IO is a bit annoying with monad transformers. If you're not using much library code with IO in the signature, with a few strategic uses of liftIO all your code can work with MonadIO instead
21:25:15 <deech> quuuux: I haven't run into this problem before I can usually corral in my use of IO, but GTK2HS code seems to demand this style of coding. 
21:26:24 <kfr> What's the proper way to check if a path leads to a directory, a file or neither?
21:26:44 <kfr> doesFileExist combined with doesDirectoryExist sounds like a lame way to do this honestly
21:30:10 <dino-> kfr: If you're going to be in a POSIX env, maybe something along the lines of System.Posix.Files.getFileStatus and friends?
21:30:29 <kfr> Nah, it's Windows in this case
21:32:07 <dino-> kfr: Then I'm not sure, you're already looking at what looks to obviously work right in Windows: System.Directory
21:32:12 <deech> kfr: How about isDirectory and isRegularFile? (http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Files.html#v:isDirectory)
21:32:23 <kfr> deech: It's not Posix
21:32:27 <dino-> I would love for this to be not true. Why the hell isn't Windows compatible with this stuff?
21:32:50 <ManateeLazyCat> dino-: Even Linux, doesDirectoryExist and doesFileExist, can't work.
21:33:13 <ManateeLazyCat> dino-: doesDirectoryExist and doesFileExist can't handle utf-8, such as Chinese.
21:33:14 <dino-> ManateeLazyCat: You have to use the System.Posix file status stuff there?
21:33:18 <quuuux> kfr: use the Windows POSIX subsystem?
21:33:29 <ManateeLazyCat> dino-: I have, but can't work,
21:33:40 <ManateeLazyCat> dino-: Because those two function use withCString
21:33:42 <dino-> I see. What a fun disaster.
21:33:53 * quuuux has no idea if that's useful advice or not, but that phrase seems to be relevant
21:33:56 <ManateeLazyCat> dino-: withCString is wrong way to handle encoding
21:33:58 <kfr> quuuux hahaha
21:35:12 <kfr> quuuux doesn't that require a special compiler which can generate the POSIX subsystem entry for the binary with special linking etc and basically a port of ghc to a new architecture which is currently not possible because the bootstrapping has been broken for two years now which is why there is not even an AMD64 version of ghc for Windows yet? :p
21:35:13 <ManateeLazyCat> dino-: But GIO (sub-project of gtk2hs) works fine.
21:35:59 <accel> is there a haskell command
21:36:00 <kfr> ManateeLazyCat urgh that is terribel :|
21:36:05 <kfr> accel: No
21:36:06 <accel> to say "execute this command in a shell" ?
21:36:19 <kfr> Haskell has no commands :'(
21:36:42 <kfr> :t system
21:36:42 <lambdabot> Not in scope: `system'
21:36:49 <deech> accel: sure System.Process
21:36:51 <ManateeLazyCat> kfr: Why? 
21:36:54 <kfr> :t System.Process.system
21:36:55 <lambdabot> String -> IO GHC.IO.Exception.ExitCode
21:36:55 <quuuux> System.system too
21:37:19 <kfr> ManateeLazyCat: I was saying that it's terrible that it doesn't work with Unicode
21:37:31 <ManateeLazyCat> kfr: GIO API can 
21:37:42 <kfr> Yeah but the default packages should be able to do that
21:38:08 <ManateeLazyCat> kfr: Yeap, default package use withCString to test filepath, but that's wrong way.
21:38:23 <kfr> Why doesn't anybody do anything about that?
21:38:29 <accel> nice; thanks
21:39:25 <ManateeLazyCat> kfr: Right way should be use ByeString to test filepath, and don't care encoding information.
21:39:49 <ManateeLazyCat> kfr: Then filepath exist detect will success.
21:40:28 * hackagebot yesod-sitemap 0.0.0.1 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-0.0.0.1 (MichaelSnoyman)
21:41:07 <quuuux> ManateeLazyCat: won't that fail in interesting ways for locale-dependent casing conventions and case-(in)?sensitive filesystems?
21:41:07 <ManateeLazyCat> kfr: My suggestion, drop default package.
21:43:35 <accel> how do I tell --make to rebuild everything; i.e. some modules Main.hs depends on has changed
21:43:55 <quuuux> accel: -fforce-recomp
21:44:02 <deech> accel: --fforce-recomp
21:44:12 <deech> accel: What quuuux said.
22:03:21 <BrianHV> am I missing a way to pattern match on a list with exactly one element?
22:04:28 <adu> f [x]
22:04:30 <copumpkin> moo [a] = blah
22:04:53 <BrianHV> huh. thought I tried that, but I guess not. thanks!
22:05:02 <adu> or f (x:[])
22:05:58 <aleator> Base
22:06:01 <aleator> base* was excluded because of the top level dependency base -any
22:06:08 <aleator> What is that about?
22:06:40 <ivanm> aleator: from cabal-install ?
22:07:02 <ivanm> which package?
22:07:25 <aleator> Yeah. My own. currently doesn't export anything nor depend on anything but base.
22:09:31 <dreixel> ozataman: regarding the emgm package, I don't think it's abandoned, but it doesn't compile with GHC 7, at least (due to some TH issues)
22:10:16 <dibblego> would an Applicative for (Writer w) require Monoid w => ?
22:14:03 <copumpkin> dibblego: what would pure be?
22:14:14 <ivanm> aleator: you need an upper bound on base
22:14:17 <ivanm> base < 5
22:14:24 <dibblego> (\a -> (mempty, a)
22:14:25 <copumpkin> edwardk's Apply class for Writer w wouldn't require a Monoid w
22:14:30 <ivanm> dreixel: ping the maintainer then?
22:15:05 <dibblego> why not?
22:15:11 <dibblego> it should require Semigroup
22:15:33 <dreixel> ivanm: well, sure, if someone is interested I'm sure Sean will update it
22:15:42 <dreixel> just email the generics mailing list
22:16:04 <copumpkin> dibblego: it does
22:16:12 <copumpkin> but not Monoid :P
22:16:13 <aleator> ivanm: I tried. It works if there isn't any constraint on base, but atleast using == it still fails. 
22:16:27 <ivanm> huh?
22:16:28 <dibblego> yes but Applicative would require Monoid, since pure needs mempty
22:16:35 <copumpkin> yep
22:16:42 <copumpkin> my question was rhetorical
22:17:14 <ivanm> what's the term for when f . f = f ?
22:17:21 <copumpkin> idempotent
22:17:25 <dibblego> idempotence
22:17:44 <ivanm> that's the one, ta
22:17:51 <copumpkin> idimpotence :(
22:17:54 <aleator> ivanm: Oh. I was using too low constraint..
22:21:37 * hackagebot Interpolation 0.2.5.1 - Multiline strings, interpolation and templating.  http://hackage.haskell.org/package/Interpolation-0.2.5.1 (VilleTirronen)
22:45:01 <jacobgood1> Hello?
22:46:28 <Jonno_FTW> is there any body out there
22:46:30 <copumpkin> hello!
22:46:44 <DisembodiedVoice> oooooo
22:46:52 <digitteqnohippie> a few at least
22:46:55 * ivanm calls the ghostbusters
22:47:01 <DisembodiedVoice> ooooo.... I am your conscience.... oooo
22:47:07 <jacobgood1> good I was just wondering if this was working
22:47:29 <ivanm> <crickets>
22:47:29 <Jonno_FTW> hardly working
22:47:38 * digitteqnohippie leans forward, eager to hear what his conscience has to say
22:48:01 <jacobgood1> I know I will need help with Haskell so this was a test, hello all I am a total noob!
22:48:05 <ivanm> dammit, my tests indicate that I _can't_ put off doing something I thought would just be an extension to something :(
22:48:23 * digitteqnohippie is barely a shade past total noob still.
22:48:28 <Jonno_FTW> jacobgood1: what do you need to know?
22:48:58 <ivanm> if I have [[a]], what's the best way of getting the common elements of all the sub-lists?
22:49:14 <ivanm> Jonno_FTW: he needs to know if we're going to be around for when he actually needs something
22:49:15 <ivanm> :p
22:49:21 <Jonno_FTW> oh right
22:49:25 <Jonno_FTW> I'll be on standby
22:49:29 <jacobgood1> hehe that is about right
22:49:51 <Jonno_FTW> ivanm: isn't that O(n^n)?
22:49:51 <jacobgood1> I just really want to switch over to functional languages
22:49:56 <quuuux> ivanm: foldr union (concat xs) xs?
22:50:10 <Jonno_FTW> or not
22:50:19 <ivanm> quuuux: hmmmm... or just use foldr1
22:50:28 <ivanm> Jonno_FTW: quite possibly
22:50:32 <ivanm> but I still need to do it :/
22:50:52 <ivanm> @hoogle intersect
22:50:53 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
22:50:53 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:50:53 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
22:50:54 <quuuux> ivanm: if you can guarantee non-null-ness, sure
22:51:02 <ivanm> quuuux: *nod*
22:51:09 <Jonno_FTW>  the naive method seems to be to check each element against all the elements of every other list
22:51:40 <quuuux> if there are big numbers involved and you have Ord, use Data.Set operations instead
22:52:01 <ivanm> yeah, that's what I was figuring
22:52:04 <jacobgood1> Hey I do have a quick question.... a tutorial I was looking at used the word Ordering, yet it did not say what the heck it means... (a -> a -> Ordering)
22:52:18 <ivanm> wasn't sure if there was a better way of doing it than just repeated intersection applications
22:52:43 <quuuux> ivanm: I'd be surprised if there was in general
22:52:51 <ivanm> yeah
22:52:57 <ivanm> *grumbles*
22:53:57 <quuuux> jacobgood1: Ordering is a type with 3 members: LT, EQ and GT.
22:54:03 <quuuux> jacobgood1: an example should clarify
22:54:08 <quuuux> > compare 2 3
22:54:09 <lambdabot>   LT
22:54:17 <quuuux> > compare 3 2
22:54:17 <lambdabot>   GT
22:56:05 <jacobgood1> If I had a type signature like this... iFail :: (a -> a -> Ordering) -> [a] -> [a]... What would the first arguement be?
22:57:49 <Jonno_FTW> a function?
22:58:00 <jacobgood1> really?
22:58:20 <Jonno_FTW> that takes 2 type a's and returns an Ordering
22:58:36 <Jonno_FTW> :t sortBy
22:58:37 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
22:58:44 <Jonno_FTW> is this your function?
22:59:27 <jacobgood1> yes it is sortBy... but the thing is I do not understand why the first arguement would be something like compare
23:00:06 <Jonno_FTW> @src sortBy
23:00:06 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
23:00:14 <Jonno_FTW> @src insertBy
23:00:14 <lambdabot> insertBy _   x [] = [x]
23:00:14 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
23:00:14 <lambdabot>                                  GT -> y : insertBy cmp x ys'
23:00:14 <lambdabot>                                  _  -> x : ys
23:00:21 <Jonno_FTW> ^
23:00:44 <Jonno_FTW> jacobgood1: it's usually a good idea to check the source of the functions you want learn more about
23:01:10 <jacobgood1> where can I do this?
23:01:22 <quuuux> worth noting, though, that that's not the actual source for sortBy, which should be mergesort iirc
23:01:43 <Jonno_FTW> in the docs, click on the [source] link next to the function name, or search it here
23:01:52 <quuuux> though it's a very pretty insertion sort
23:02:49 * vegai giggles inanely at lyah's "Let's go over this line by line." 
23:03:12 <jacobgood1> ok goodnight guys that is all for now, watch out this nub will be back
23:03:14 <dankna> is that a reference to the play/movie "Proof"?
23:29:14 <accel> what's a good netbook to run haskell on?
23:30:18 <Cale> accel: That's an odd question. Anything running Windows, Mac OS, or Linux should do quite nicely.
23:30:34 <accel> in terms of bare minimum hardware requirements
23:30:40 <accel> I heard ghc needs > 1GB
23:30:46 <accel> so probably atleast 2GB RAM to be safe?
23:31:05 <ceii> accel: no way, GHC has worked fine on all the crappy netbooks I've had
23:31:10 <Cale> hmm... I don't think I've ever seen GHC use that much memory.
23:31:46 <ceii> you may want to avoid ARM netbooks though, since there's no official GHC port
23:31:53 <accel> oh shit
23:31:56 <Cale> Wouldn't rule it out completely, but I think that would usually count as a bug.
23:31:56 <accel> didn't even think about that
23:32:08 <accel> wait, doesn't ubuntu run on arm?
23:32:08 <ivanm> how well does ghc perform on the atom?
23:32:16 <ceii> accel: yes
23:32:23 <ivanm> accel: yeah, but ghc needs to be ported to each architecture
23:32:36 <accel> so on arm, ubuntu's ghc package is broken?
23:32:40 <ivanm> though IIRC LLVM should help with that in future (just have to wait until _it_ is ported :p)
23:32:41 <accel> I thoguht ghc compiled down to C
23:32:44 <accel> and gcc is ported everywhere
23:32:45 <ivanm> accel: I would say more "nonexistent"
23:32:52 <copumpkin> accel: it doesn't usually compile to c, no
23:32:58 <ivanm> accel: you can get a C-only ghc (6.2 IIRC) and bootstrap your way up
23:32:59 <copumpkin> it does when it has no other option
23:33:06 <ivanm> and then you have to registerise it to make it performant
23:33:09 <Cale> accel: It can be compiled via C, but it's not the default, and uses additional mangling of the assembler output.
23:33:09 <accel> so ghc enerates it's own assembly; then links against a runtime written in C?
23:33:22 <copumpkin> 6.2 is ancient, it's supposed to be possible to bootstrap on a way newer version now
23:33:29 <copumpkin> accel: the runtime is mostly in cmm
23:33:29 <Cale> By default, GHC compiles directly to native code.
23:33:30 <copumpkin> not c
23:33:38 <ceii> also, after compiling through C it post-processes the assembler generated by gcc
23:33:45 <ivanm> copumpkin: is there a C-only release since then though?
23:33:50 <ceii> or at least it tries too
23:34:14 <copumpkin> ivanm: oh, don't think so, but you can generate one for cross-compilation
23:34:17 <copumpkin> it's a bit of a nightmare
23:34:21 <ivanm> yeah
23:34:23 <ceii> you can make it compile through C and without post-processing, but IIRC that's like a 2x hit in performance
23:34:41 <ivanm> Cale: what did you guys at iPwn do for the port?
23:34:48 <ivanm> bootstrap your way up or cross-compilation?
23:35:02 <ivanm> ceii: I think you need the mangling
23:35:07 <ivanm> and not just for performance
23:35:29 <Cale> We have a cross compiler -- running GHC on an iPhone, or even in the iPhone simulator would be pretty crazy :)
23:35:46 <ceii> invanm: no you don't
23:35:59 <ceii> found the blog post I was searching for: http://tommd.wordpress.com/2010/01/19/ghc-on-arm/
23:41:59 <accel> Intel Atom <-- is that x86 or ARM?
23:42:12 <dark> x86
23:42:15 <pacak> accel: x86, but very bad.
23:42:23 <opqdonut> not bad
23:42:25 <dark> i'm using one, and i run gentoo on it
23:42:34 <dark> compiling chromium takes ages
23:42:36 <accel> Mini 1018 Intel Atom N455 Processor , Athlon MV40(1.6GHz) ,  Intel Atom N455 1.66GHz , ntel® Atom™ Processor N455  <-- are any of these good for running GHC ? (procs pulled from 4 different netbooks)
23:42:58 <companion_cube> yeah, ghc will work fine
23:43:42 <pacak> opqdonut: It is much (~3x) slower that core2 and takes x3 more energy to perform same operations.
23:43:56 <dark> accel, i like my atom-powered netbook, and it is the sole computer i have (for now)
23:44:21 <accel> dark: what's your battery life like?
23:44:27 <accel> dark: are you running ubuntu? hibernate works well?
23:44:38 <dark> i'm running gentoo
23:44:49 <dark> i used ubuntu for a while
23:45:43 <opqdonut> pacak: i'm under the impression that its idle power usage is much lower
23:45:51 <dark> my netbook is http://www.google.com/search?q=acer+532h and the battery is like 2h30m, 3h or more if rationing
23:47:10 <companion_cube> +1 opqdonut, atom is designed to consume less energy
23:47:59 <pacak> companion_cube: it is designed to be cheap.
23:48:12 <companion_cube> cheap and power efficient :)
23:48:34 <pacak> companion_cube: Yes, but they got only cheap part done.
23:48:53 <dark> wow at US it is $286, converting to R$ it is 1/2 to 1/3 of the price at brazil
23:49:40 <dark> pacak, but there is another thing: they got a GPU there
23:51:32 <pacak> dark: as well as newer core i3 processors.
23:51:40 <pacak> And all other iX
23:53:10 <dark> i don't think i3 would be more economical
23:53:37 <dark> but yes i would prefer an arm netbook
