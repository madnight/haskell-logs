00:00:43 <othiym23> is there a difference between Christian Maeder's and Gregory Wright's MacOS x86_64 distributions?
00:01:44 <NihilistDandy> I think I used whatever the second one in the post was
00:01:57 <NihilistDandy> Not sure if there's an appreciable difference
00:02:19 <NihilistDandy> Probably nothing serious, but might be worth looking into if you're worried
00:03:33 <othiym23> NihilistDandy: not worried per se, just curious
00:03:38 <othiym23> NihilistDandy: so thanks
00:04:31 <NihilistDandy> No problem. I was pretty happy when I found it.
00:05:31 <othiym23> slightly less newb question: is Takusen meant to be used on its own, or in combination with one of the other DB abstraction layers?
00:05:46 <othiym23> the documentation on it is not overabundant
00:07:02 <NihilistDandy> othiym23: http://blog.codersbase.com/2010/08/takusen-tutorial-part-1-hello-takusen.html
00:07:23 <othiym23> NihilistDandy: I've read that a couple times, but it doesn't go into much detail
00:07:27 <NihilistDandy> Ah
00:07:39 <NihilistDandy> What about the articles it links? No joy?
00:08:39 <othiym23> I like the idea of a foldl-based way of dealing with stuff, but I think what I really want is something like CJ Date's Tutorial D running on top of a relational store
00:09:39 <othiym23> NihilistDandy: I think a good chunk of my problem is that every time I visit that page, Firefox complains at me for a good minute about random jsMath crud
00:10:01 <NihilistDandy> Heh. Safari!
00:10:29 <othiym23> or Chrome, but all my goodies are in FF
00:10:50 <NihilistDandy> But, anyway... it looks like it can be used largely on its own, as long as you have a backend to work with.
00:10:52 <shapr> Isn't takusen all about iteratees on databases?
00:11:14 <othiym23> I guess what it is that article's great for talking about the iteration over the result-set, but I'm looking for something that's a little more directly mapped to the relational algebra / calculus
00:11:29 <shapr> HaskellDB?
00:11:46 <othiym23> shapr: I guess? There's an interesting article about the relational algebra on the Haskell wiki, but it doesn't point anywhere in particular
00:11:58 <othiym23> Is that in decent shape?
00:12:08 <othiym23> It's hard to keep track of which of the DB abstraction layers are being maintained
00:12:32 <shapr> Yah, HaskellDB has recent activity.
00:12:59 <blueonyx> jonkri: you mean a .cabal file? as a starting point i put dependency == x.y.* in, where x.y.z is the version i have installed
00:13:32 <othiym23> shapr: k, thanks
00:13:56 <othiym23> shapr: am I best off just pulling from darcs?
00:14:11 <shapr> othiym23: I haven't used HaskellDB recently, I don't know.
00:14:21 <othiym23> shapr: fair enough, thanks for the pointer
00:14:26 <shapr> Though I've had years of enjoyment from it earlier.
00:15:00 <othiym23> yeah
00:15:03 <jonkri> blueonyx: why is that better than not putting anything? people might think you had a specific reason for requiring that version?
00:15:43 <shapr> After I had a job where SQL queries could be many pages long without \n, parameterizable queries were sexy.
00:15:53 <othiym23> my first big project in Haskell some years ago was trying to get a version of Date's D up and running on top of Haskell, but my brain sort of exploded when I started trying to model its type system within Haskell's
00:16:13 <othiym23> I'm hoping I'll have a little more luck this time, having actually figured out monads and functors and combinators a little better
00:16:24 <shapr> othiym23: already seen http://trac.haskell.org/haskelldb/  ?
00:16:32 <othiym23> shapr: y, thanks
00:17:49 <othiym23> also, trying to do that with _Real World Haskell_ as my reference didn't help
00:18:00 <othiym23> is there something like _The Definition of Standard ML_ for Haskell?
00:18:31 <ddarius> othiym23: There's the Report, but there is no formal semantics.
00:19:07 <othiym23> ddarius: kk
00:21:40 <othiym23> one last noob question: do people here routinely use leksah, or am I better off just sticking with vim / emacs / TextMate?
00:22:28 <luite_> most people use regular editors
00:23:20 <othiym23> OK, thanks
00:23:35 <othiym23> the built-in reference bits seem nice, but leksah's so heavyweight otherwise
00:24:06 <luite_> I use emacs, which is ok with haskell-mode. but any editor should do, as long as it indents with spaces instead of tabs
00:25:01 <othiym23> the first thing I do in every text editor I use is turn off hard tabs, so I foresee few problems
00:25:26 * ddarius uses vim with no special Haskell support.
00:25:38 <ddarius> Though there was a very featureful vim mode somewhere.
00:26:22 <shachaf> ddarius: Not even syntax highlighting?
00:26:38 <othiym23> yeah! how could you live without ANGRY FRUIT SALAD
00:26:45 * othiym23 loves angry fruit salad
00:26:53 <ddarius> shachaf: I use the syntax highlighting that comes with the default vim installation.
00:27:05 <shachaf> Ah.
00:27:18 <othiym23> all right, sweet, I have 7.0.1, it came with cabal, no more segmentation faults
00:27:20 <othiym23> life is good!
00:27:27 <othiym23> thanks for the help!
00:28:35 * ddarius wants to play violin but probably shouldn't since it's four in the morning.
00:29:44 <shachaf> That's never stopped me before.
00:29:59 <shachaf> The fact that I don't play violin has, however.
00:30:00 <int-e> nor Sherlock Holmes ;)
00:30:50 <NihilistDandy> By that logic, 4 am is also an ideal time for cocaine :P
00:31:53 <mjrosenb> 4 am is an ideal time for many things.
00:35:04 <Jafet> Some people use it to sleep. The bastards
00:36:11 <jonkri> shouldn't "3.1.3. Executables" in http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html mention the "Executable" configuration item
00:44:09 <aleator> Gah. How do I make criterion install without gtk but with chart?
00:44:33 <aleator> I can install chart without gtk, but when installing criterion it reinstalls chart with gtk
00:46:07 * hackagebot check-email 0.1 - Confirm whether an email is valid and probably existant.  http://hackage.haskell.org/package/check-email-0.1 (ChrisDone)
00:52:57 <othiym23> sweet, HaskellDB / GHC 7 is connecting to my postgres instance and producing sensible output
00:52:59 <othiym23> I love it
00:53:10 <NihilistDandy> Nice :D
00:53:12 <Guest98021> Hello: I understand that "_" all by itself is a reserved identifier, and I've googled 'reserved identifier' "used as wild card in patterns" but I'm still unclear on why it is used in length' xs = sum [1 | _ <- xs]   (this is an example from the online resource 'learn you a haskell..."
00:53:40 <shachaf> Guest98021: It's used when you want to pattern-match anything and then ignore its value.
00:54:35 <shachaf> Guest98021: You can also use regular identifier, but _ works and makes it clearer that you don't intend to use it..
00:55:18 <shachaf> In "monad syntax", the "_ <-" is implied, but in list comprehensions it's treated as a boolean guard.
00:55:53 <Guest98021> ok, bear with me for a moment here, I am new to this, but it seems like in length' xs = sum [1 | _ <- xs]   I use it to indicate the presence of an element
00:56:14 <Cale> That code means the same thing as  length' xs = sum [1 | x <- xs]
00:56:31 <Guest98021> yes, correct, i have also run it with "x" instead of "_"
00:56:59 <shachaf> Guest98021: Do you see why [x | x <- xs] == xs?
00:57:00 <Cale> The only difference is that _ is a pattern which matches anything but doesn't bind a variable to the value matched
00:57:44 <Guest98021> ok, thanks cale, you have answered my question.
01:01:19 <Guest98021> yes shachaf, i saw why [x | x <- xs] == xs.  That is because xs gets bound to the variable "x" then output by the "output function" with no processing on it.
01:01:36 <Cale> Each element of xs is bound to x in turn
01:01:45 <Cale> it's similar to a loop, in a funny way
01:02:00 <shachaf> Except better. :-)
01:02:29 <Cale> If xs :: [a], then x :: a
01:03:22 <Guest98021> if "_" isn't having a variable bound to it, how is what is happening described?
01:03:38 <Cale> Well, it takes the place of the variable
01:03:51 <shachaf> It's like a variable, except you can't use it.
01:03:52 <Guest98021> is that called 'variable assignment'?
01:04:00 <Cale> pattern matching
01:04:03 <shachaf> Assignment doesn't exist. :-)
01:04:04 <Cale> It's just like x here, and matches each of the values in the list
01:04:16 <Cale> but it doesn't give a name to refer to those values
01:04:26 <Cale> Perhaps some more examples would help...
01:04:36 <Cale> > let (x:xs) = [1,2,3,4,5] in (x, xs)
01:04:37 <lambdabot>   (1,[2,3,4,5])
01:04:44 <Cale> > let (x:_) = [1,2,3,4,5] in x
01:04:45 <lambdabot>   1
01:04:54 <Cale> > let (_:xs) = [1,2,3,4,5] in xs
01:04:55 <lambdabot>   [2,3,4,5]
01:05:06 <blueonyx> jonkri: if you dont put anything there cabal complains? mostly the only versions which matter are major ones like parsec 2 vs 3, for the executables section, your link mentions it: "as well as build information fields (see Section 3.1.4, Build information)."
01:05:16 <Cale> > let (x:y:xs) = [1,2,3,4,5] in (x,y,xs)
01:05:17 <lambdabot>   (1,2,[3,4,5])
01:05:22 <Cale> > let (x:_:xs) = [1,2,3,4,5] in (x,xs)
01:05:23 <lambdabot>   (1,[3,4,5])
01:05:35 <Cale> > let (_:y:_) = [1,2,3,4,5] in y
01:05:35 <lambdabot>   2
01:06:01 <Cale> It's just a blank, it matches anything in a pattern, and doesn't bind a variable
01:06:42 <jonkri> blueonyx: there are two instances of "executable:" in that document, and both are in the same example
01:07:01 <mux> also, it allows you to write code that resembles an ascii art ass
01:07:26 <Cale> lol
01:07:58 <Guest98021> Cale do you also teach Yoga in Fremantle?
01:08:11 <Cale> nope
01:08:19 <Guest98021> ok, different Cale then
01:08:22 <Cale> I don't even know where Fremantle is :)
01:08:56 <Guest98021> it's a place where yoga is taught
01:09:29 <Guest98021> i mean... it's that kind of place
01:09:50 <Guest98021> ok, thanks everyone, i have to go now
01:09:54 <Guest98021> bye
01:10:38 <shachaf> Cale: Are you in .ca?
01:10:38 <Cale> see you
01:10:43 <Cale> I'm in Canada, yeah
01:10:45 <shachaf> Strange.
01:10:56 <Cale> why?
01:11:52 <shachaf> I thought you were in Texas for some reason.
01:12:05 <Cale> odd
01:12:25 <shachaf> Might've been someone else.
01:13:25 <blueonyx> jonkri: of course one package can have more than one executable or i dont understand your question
01:17:37 <Maxdamantus> @pl \a b -> maybe (b a)
01:17:37 <lambdabot> (maybe .) . flip id
01:17:52 <Maxdamantus> @pl \a b -> maybe (b a) b
01:17:52 <lambdabot> join . (maybe .) . flip id
01:18:37 <jonkri> blueonyx: my question is about the "executable" setting not being mentioned along with all the other settings, only in one example
01:19:55 <mjrosenb> @pl \ x y -> x (y x)
01:19:55 <lambdabot> ap (.) (flip id)
01:21:04 <blueonyx> jonkri: i'm sorry, what do you mean by "executable" setting? i just can find stuff about the "executable" _section_
01:21:35 <shachaf> That's usually called the "text" section. :-)
01:23:20 <jonkri> blueonyx: search the document for "Executable:"
01:25:26 <blueonyx> jonkri: pattern not found, are we both talking about http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html?
01:27:19 <blueonyx> jonkri: whats the value of the setting? program1 program2? that would be the name of the executable name created by ghc -o program1
01:29:30 <jonkri> blueonyx: sorry, it was a section...
01:30:46 <blueonyx> so "that specifies the name of your executable binary file" answers your question then? :)
01:33:34 <Ptival> q: I have a program that recurses infinitely, is there a way for me to know what recursive expressions are being evaluated resulting to this infinite loop?
01:34:28 <Cale> Ptival: One way to pin it down is to compile with -prof -auto-all and then run the program with +RTS -p
01:35:30 <Cale> Ptival: that will output a .prof file which you can look at which says how many times the code for each "cost centre" (in this case, each function definition) was entered.
01:35:47 <Cale> Look for the big numbers :)
01:36:20 <Cale> It won't tell you the precise expression, but it will at least give you an idea of which function is causing the problem.
01:42:10 <Ptival> Cale > thanks, but right now I'm using ghci, is there an equivalent? :)
01:42:40 <Ptival> otherwise it's not a big deal anyway, thanks
01:45:58 <haskellnoob> I have a big list, and I want to get its sublist which consists of every 3rd element starting from a specified element (which I will find). How do I go about doing this?
01:47:49 <luite> Ptival: you may be able to narrow down the location with the ghci debugger, but I don't think you can break a running program without setting breakpoints in advance
01:49:02 <vegai> looking for nice ways to reach a standard messaging queue in haskell...
01:49:04 <aleator> haskellnoob: pattern match with (_:_:x:xs) and take care of corner cases?
01:49:23 <vegai> the only thing I'm seeing is stomp-hs that was last modified in 2007
01:49:53 <vegai> nothing in hackage
01:50:41 <Ptival> luite > ok, thanks, I can set breakpoint, I know about where it fails, I just don't know how exactly it does
01:50:53 <haskellnoob> aleator: that seems like a good idea. thank you. i also have the small problem that 3 is just an example: i would want to find a list of all rth elements for different r, some of them possibly largish (like 2 digits)
01:51:12 <othiym23> vegai: is it important that it be Stomp?
01:51:36 <othiym23> vegai: what's the queuing service you're going to be connecting to?
01:51:54 <aleator> haskellnoob: Then I'd look at drop N and put some recursice scheme over that
01:52:36 <haskellnoob> aleator: thank you, let me try that out
01:53:00 <othiym23> vegai: there's Network.AMQP, which may or may not work for you
01:53:27 <aleator> haskellnoob: Or, come to think of it. A recursion with a counter might actually be easier.
01:56:09 <luite> Ptival: you can paste the code at http://hpaste.org/ , so that we can have a look at it here
01:56:49 <jaj> hi, I was wondering if anybody was aware of a dbus example / tutorial?
01:57:31 <Younder> I am about to write a wikipedia page on 'theorema ergrium' (Gaussian curvature). Would one of you proof read it for me?
01:58:11 <tab> jaj: in general, or with a specific library ?
01:59:07 <jaj> tab: well I think the easiest would be dbus-client
01:59:18 <jaj> tab: but anything else would be ok, too
01:59:33 <Younder> This is my favourite proof and one of the most inspirational an beautiful  works I know. See Spivak Vol. 2.
02:00:00 <jaj> tab: it's just that I never used dbus before so I don't know how the message sending/receiving etc. works
02:00:29 <tab> jaj: you should probably look at a quick tutorial in any language first then
02:00:43 <tab> jaj: unforunately, dbus-client expect you to understand how things work with dbus
02:01:15 <jaj> tab: ok I'll look at some python or so tutorial then, thanks
02:01:28 <tab> jaj: and i don't think there's any example/tutorial available for dbus-client
02:01:41 <tab> jaj: maybe you could look at the source tarball, and check if there's any
02:02:02 <jaj> tab: oh that's a good idea, I already got lucky with webkit this way :)
02:03:48 <jaj> tab: indeed, there are examples in the tarball, thanks :)
02:03:49 <Younder> I feel the world deserves the whole proof, not just the result.
02:04:06 <tab> jaj: cool, no problem.
02:05:33 <Younder> Guess I am off to AMS.
02:06:42 <Younder> (American Mathematical Society)
02:28:42 <vegai> othiym23: that could work. Thanks.
02:29:12 <vegai> othiym23: although the description states that it works only for rabbitmq
02:29:20 <blueonyx> little ot, but does someone know how to install mtl 2 with bauerbill?
02:29:33 <othiym23> vegai: what server are you using?
02:31:47 <vegai> othiym23: probably activemq
02:32:02 <vegai> blueonyx: I recommend using cabal-install
02:33:01 <othiym23> vegai: you're screwed, then -- ActiveMQ has said they're not worrying about AMQP until it hits some sort of finalized spec
02:33:29 <vegai> I think I'll take a look at stomp-hs also
02:33:46 <vegai> the protocol is simple enough that if it's not perfect, I should be able to fix it myself..
02:34:39 <othiym23> you might as well take a look at RabbitMQ if you have the option
02:34:40 * hackagebot graph-rewriting-trs 0.1.2 - Evaluate a first-order term rewrite system interactively using graph reduction  http://hackage.haskell.org/package/graph-rewriting-trs-0.1.2 (JanRochel)
02:34:59 <othiym23> it'd give you a chance to play with Erlang!
02:37:12 <vegai> othiym23: not gonna happen. Tough enough to try to upkeep one weird platform at work..
02:38:24 <othiym23> vegai: understood, good luck
02:43:40 <ceii_> blueonyx: sort of a hack, but changing the mtl version by hand in /tmp/bauerbill/hackage/hackage_db should work
02:44:07 <ceii_> blueonyx: the problem is that mtl-1.1.1.1 was uploaded after mtl-2.0.1.0
02:44:24 <ceii_> blueonyx: so bauerbill takes it as the latest version
02:44:52 <haskellnoob> aleator: I have written a "dropEvery" function following your hints, thank you.
02:45:46 <lewis1711> nitty gritty implementation question... when one defineds a function with a signature like, say... (Num a) => a -> a ... does the compiler go ahead and quietly make a version of the function for every type that implements the Num typeclass, or how does it work? :/
02:47:43 <ceii_> lewis1711: normally, the compiler will generate a function that expects a method dictionary as an additional argument
02:47:59 <ceii_> lewis1711: but it may also choose to generate specialized versions
02:48:21 <ceii_> lewis1711: you can request it yourself with a SPECIALIZE pragma, see the GHC manual
02:48:37 <lewis1711> method dictionary? as in an associative array of methods?
02:49:25 <quicksilver> just a tuple of method implementations.
02:49:49 <lewis1711> I see
02:51:17 <quicksilver> that is just the way GHC happens to do it, it's not the only way you can imagine doing it.
02:51:21 <othiym23> does anybody have any snippets showing how to use HaskellDB's "describe" command?
02:52:38 <othiym23> I've got "withDB :: MonadIO m => (Database -> m a) -> m a"
02:54:43 <othiym23> which allows me to use "withDB tables" just fine, but I'm blocking a little on figuring out how to bind the database within MonadIO to pass it to describe, which is "describe :: Database -> Tablename -> IO [(Attribute),(FieldDesc)]"
02:55:58 <ceii_> othiym23: if a single call to describe is really what you want to do, then "withDB (flip describe tablename)"
02:56:32 <ceii_> but the idea is to use wothDB to "bracket" a whole do block, as in withDB $ \db -> do ...
02:58:06 <othiym23> ceii_: ahhh, I get it
02:58:36 <Saizan> in general: withDB (\db -> ....here db is the Database..)
02:59:08 <othiym23> I'm coming at all this back-asswards -- I know what monads are theoretically, but I'm still figuring out how to use them
02:59:42 <iago> othiym23, maybe stop to thinking in them theoretically help
02:59:45 <Saizan> this is basic higher order functional programming, actually
02:59:57 <othiym23> iago: yeah, probably
03:00:10 <iago> just analyze the simpler ones Reader / State
03:00:20 <Saizan> in fact, people that struggle with monads, are actually struggling with higher order functions and/or type classes
03:00:21 <iago> and I think you will get the idea
03:00:27 <blueonyx> ceii_: but why doesnt bauerbill -S "haskell-mtl>=2" work?
03:00:43 <Saizan> s/people/most people/
03:01:07 <othiym23> Saizan: sure, but my problem right now is syntactic, not semantic
03:01:10 <gpbar> ddtc
03:01:19 <gpbar> hi guys
03:11:32 <ceii_> blueonyx: bauerbill is an "extension" of pacman, not cabal-install, and since arch is a rolling release distro pacman obviously doesn't have a syntax for selecting versions
03:13:40 <ceii_> blueonyx: bauerbill simply installs what it finds to be the latest version of packages, in accordance to the arch spirit
03:14:05 <ceii_> blueonyx: that makes it hard to use except for very mature packages
03:47:12 <mm_freak> ceii_: that's wrong
03:47:27 <mm_freak> pacman -S "PACKAGE < VERSION"
03:47:34 <mm_freak> or == or > or >= …
03:54:27 <xarch> hi, do you think we have to make a difference between interpreted languages and compiled languages?
03:54:54 <xarch> I thought there wasn't any difference, but wikipedia says there is
03:55:00 <Twey> That's an implementation property, not a language property
03:55:13 <Twey> Most languages are both interpreted and compiled
03:55:19 <Twey> (at least the popular ones)
03:55:23 <xarch> yes, that's what I thought
03:55:38 <quicksilver> it's a continuum rather than a black and white issue, too.
03:55:44 <xarch> so some people on wikipedia are wrong, no?
03:56:14 <Twey> Yeah, we've got all sorts of clever stuff like bytecode compilation and JIT nowadays
03:56:19 <Twey> xarch: Possibly
03:56:23 <Twey> Or you might have misinterpreted it
03:56:42 <quicksilver> well, I think "some people on wikipedia are wrong" is a definite YES :)
03:56:49 <xarch> okay :)
03:56:51 <Twey> quicksilver: Surely not
03:56:54 <xarch> thanks!
03:57:00 <quicksilver> but as for xarch's specific article in question, well, who knows...
03:57:08 <Twey> Everybody who edits Wikipedia is a paragon of infallibility
03:57:13 <Twey> Everyone knows that
03:57:14 <Zao> Good joke.
03:57:29 <quicksilver> there are some black and white distinguishing features, though
03:57:47 <Twey> I guess it's possible for a language standard to dictate that the language must be compiled
03:57:50 <quicksilver> existence of string eval requires your whole parse/run subsystem to accompany the final running programming.
03:58:01 <Twey> Mm
03:58:04 <quicksilver> for example, java doesn't have string eval
03:58:15 <quicksilver> and the only way to get it in haskell involves, essentially, bundling the compiler with the app
03:58:41 <Twey> Yeah
03:58:49 <quicksilver> whereas perl/python/javascript do have string eval.
03:59:14 <quicksilver> but then again, perl and python both have something which is typically described as 'compilation'
03:59:23 <Twey> Shh.  No they don't.  Don't tell people that.
03:59:47 <quicksilver> but it's traditionally run at program startup rather than before deployment, and the machinery remains in place so you can use it later for string eval.
04:00:13 <Twey> But Python at least ‘compiles’ to something that involves using the interpreter, and the interpreter also contains the compiler
04:00:21 <quicksilver> right.
04:00:27 <Twey> So you're effectively bundling the compiler, again
04:00:30 <quicksilver> right.
04:00:50 <quicksilver> I don't think any mainstream language is literally interpreted as source code
04:01:01 <quicksilver> they all tokenise/compile to bytecode or something along those general lines.
04:01:03 <mauke> .oO( brainfuck )
04:01:18 <quicksilver> mauke: falls outside my choice of definition for 'mainstream' ;)
04:01:20 <Twey> mauke: Br**nfuck is mainstream now?
04:01:23 <Twey> We're all screwed
04:01:50 <mauke> quicksilver: sh, maybe
04:02:18 <mauke> hah, cmd.exe of course
04:02:27 <mauke> doesn't even read the whole file first
04:02:42 <mauke> you can update a script while it's running and it'll see the changes
04:03:06 <quicksilver> TeX lets you change the definition of the language while the script is running
04:03:15 <mauke> that's normal
04:11:33 <Maxdamantus> @pl \a b -> a >>= \c -> when c b
04:11:33 <lambdabot> (. flip when) . (>>=)
04:12:18 * Maxdamantus wonders if something like that exists .. or if lambdabot know about `when`
04:13:17 <Maxdamantus> @pl \a b -> a >>= \c -> if' c b (return ())
04:13:18 <lambdabot> (. flip (flip . flip if') (return ())) . (>>=)
04:16:03 <quicksilver> Maxdamantus: people have called it 'whenM' but there is more than one possible meaning of whenM so it's not standard
04:16:23 <aristid> :t when
04:16:24 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:16:37 <aristid> :t \a b -> a >>= \c -> when c b
04:16:37 <Maxdamantus> I see.
04:16:38 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
04:16:56 <aristid> :t \a b -> a >>= flip when b
04:16:57 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
04:17:21 <aristid> :t \a b -> a >>= \c -> if' c b (return ())
04:17:22 <lambdabot> Not in scope: `if''
04:17:36 <aristid> :t let if' a b c = if a then b else c in \a b -> a >>= \c -> if' c b (return ())
04:17:37 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
04:38:59 <tswett> @pl \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
04:39:00 <lambdabot> (1 :) . (1 :) . ap (zipWith (+)) tail
04:39:03 <kiki_> hey! I need a bit help. it is a homework. I need to write a fucntion that will give from a list of floats those numbers that are equel or bigger then the arithemetic middle. that is my function http://codepad.org/4RowQzHS but IN greater [3.1,0.1,1.0,3.0,1.1,0.0] OUT:[3.1,3.0,1.1]
04:41:41 <tswett> kiki_: well, your function is looking for those numbers greater than... well, I'm not quite sure what (fromIntegral(length (x:xs)))/ 2 is.
04:42:27 <tswett> kiki_: but I'm guessing you want to compare the numbers with the entire original input list.
04:43:39 <tswett> If you define 'greater' recursively like this, then it has no way of knowing what the mean of the entire original input list is, since you're not just calling it on [3.1,0.1,1.0,3.0,1.1,0.0]; it's also calling itself on [0.1,1.0,3.0,1.1,0.0], and [1.0,3.0,1.1,0.0], and so on.
04:43:44 <kiki_> tswett: this line counts arithemitic middle
04:44:08 <tswett> kiki_: do you mean the mean or the median?
04:44:38 * hackagebot monoid-statistics 0.3 - Monoids for calculation of statistics of sample  http://hackage.haskell.org/package/monoid-statistics-0.3 (AlexeyKhudyakov)
04:45:38 <kiki_> tswett: hm. I dont know if I need a median. it is written just the arithemetic middle. arithemetic middle in a list [1,2,22,4,5,6] is 3 I guees
04:47:05 <tswett> > let x = [1,2,22,4,5,6] in sum x / genericLength x
04:47:06 <lambdabot>   6.666666666666667
04:47:39 <tswett> kiki_: are you sure it's not 4.5?  In ascending order, that list is [1,2,4,5,6,22].
04:47:41 <Twey> > uncurry (/) . foldr ((*** succ) . (+)) (0, 0) $ [1, 2, 22, 4, 5, 6]
04:47:43 <lambdabot>   6.666666666666667
04:47:56 <Twey> No way it's 3
04:48:23 <Twey> 20/3 for mean, 4.5 for median
04:49:26 <kiki_> tswett: it is the median. yeah. I think arithemtic middle is the half of the length of the list
04:49:56 <Dae_> Twey, that was needlessly complicated, wasn't it? :p
04:50:15 <tswett> kiki_: oh.  I don't know why that would be, but you're more familiar with the term than I am.
04:50:34 <kiki_> tswett: ok. if it is the arithmetic middle is the half of the length of the list, how can I modifz mz function that it works?
04:50:55 <tswett> kiki_: well, can you see why it's going wrong?
04:51:07 <Twey> Dae_: Saves a pass on the list :þ
04:51:28 <kiki_> tswett: I do can. the length of the list changes with everz step. it becomes smaller
04:51:37 <tswett> Right.
04:51:50 <Dae_> Twey, heh, that it does. Is it faster though? :p
04:51:53 <tswett> So first, calculate the arithmetic middle of the list; then, pass that to a second function that calculates what you want.
04:52:02 <Twey> Dae_: Sure
04:52:11 <tswett> Dae_: of course.  O(n/2).  :)
04:52:21 <Twey> Dae_: Besides, it's not that complicated
04:52:52 <tswett> @type ((*** succ) . (+))
04:52:52 <lambdabot> forall c b'. (Enum b', Num c) => c -> (c, b') -> (c, b')
04:53:27 <Dae_> tswett, both ways are O(n) ;) 
04:53:53 <Twey> Dae_: But the fold has smaller constants
04:54:13 <tswett> Twey: shouldn't you use foldl' or something?
04:54:14 <Dae_> Twey, complicated enough that that I couldn't immediatly tell you what it actually does
04:54:15 <Twey> (and they're multiplicative constants, too)
04:54:59 <Twey> tswett: Does it make a difference?  You have to force it anyway
04:55:06 <Twey> Oh, I guess the strictness might improve performance
04:55:13 * tswett nods.
04:55:58 <Twey> > uncurry (/) . foldl' (flip $ (*** succ) . (+)) (0, 0) $ [1, 2, 22, 4, 5, 6]
04:56:00 <lambdabot>   6.666666666666667
04:56:17 <ocharles> > :t uncurry
04:56:18 <lambdabot>   <no location info>: parse error on input `:'
04:56:18 <kiki_> tswett:http://codepad.org/JU1GFHcq I made it. but still it is becomming smaller
04:56:27 <Twey> Dae_: It's pretty clear if you just walk it through
04:57:14 <Dae_> Twey, sure. I just found the other method more intuitive
04:57:30 * Dae_ has a hard time with the fact that "length" is not O(1)
04:57:35 <Twey> Dae_: Sure, naïve algorithms are usually nicer
04:57:45 <Twey> Maybe when we have supercompilation ☺
04:57:47 <Dae_> Not always, but I see your point
04:57:58 <Dae_> I thought we had supercompilation? :p
04:58:00 * Twey points out that that's actually what ‘usually’ means
04:58:17 <Twey> We do?  Nobody told me
04:58:20 * Dae_ hangs his head in shame
04:59:29 * Dae_ was setting up a joke about ghc being a supercompiler, but decides that it was not a very good one
04:59:37 <Twey> Ah :þ
04:59:58 <StefanM> hey I need some help if possible with the following function...http://hpaste.org/44032/propragateunits
05:00:03 <StefanM> thank you
05:02:43 <Jafet> @hackage optimusprime
05:02:43 <lambdabot> http://hackage.haskell.org/package/optimusprime
05:03:05 <jix_> Dae_: if you need O(1) length use Data.Sequence
05:03:32 <Dae_> jix_, or Data.Vector?
05:04:05 <jix_> Dae_: you lose O(1) head/tail/cons if you use Data.Vector
05:04:27 <Jafet> type LengthList a = (Integer, a)
05:04:32 <Jafet> etc etc etc
05:04:39 <Jafet> (Integer, [a])
05:05:43 <Dae_> jix_, cons sure. head and tail are O(1) for vector
05:06:01 <jix_> Dae_: oh, but you keep around the complete list then
05:06:40 <McManiaC> http://npaste.de/xp/ :D
05:06:49 <McManiaC> (types of return are still incorrect though)
05:07:27 <Dae_> jix_, sure. But for most things that's not really a problem though, is it?
05:08:00 <koala_man> is something like let (f, _) = (42, error "zomg") guaranteed to work, or is that a compiler thing?
05:08:33 <Jafet> Or even let (f, _) (error "omg", error "bbq")
05:08:45 <koala_man> assuming f is subsequently used
05:08:46 <Dae_> Jafet, point taken. Not sure if it's a very good list though :p
05:08:49 <Jafet> Only let (f, _) = error "wtf" won't
05:08:56 <R777> haiii
05:08:57 <koala_man> neat, thanks
05:08:57 <tswett> kiki_: indeed, you haven't fixed the problem.  Remember, the way greater is written, it calls itself with ever smaller lists, like [3.0,1.1,0.0].  How is it supposed to know that the arithmetic middle is still 3?
05:09:09 <tswett> You have to tell it that, by passing a parameter.
05:09:19 <R777> wow, irrsi is the irc client of my dreams
05:09:41 <jix_> Dae_: I guess for most things where you'd use a Vector it isn't
05:09:44 <tswett> Hi R777.
05:09:49 <R777> hi tswett
05:10:00 <StefanM> can anyone provide some help?
05:11:23 <kiki_> could somebody help me please. i need to find numbers in a list that are greater or equel then the half of the list http://codepad.org/JU1GFHcq . I know the problem why it doesnt wotk properly. the length of the list becomes smaller all the time, but I dont know who to do it constant
05:12:14 <Lemmih> StefanM: Is that homework?
05:13:09 <StefanM> it is a project
05:13:24 <StefanM> the last function from a project
05:13:35 <StefanM> which I can't....do
05:13:48 <Lemmih> kiki_: How about: greater lst = filter (>= (length lst `div` 2)) lst?
05:14:22 <tswett> kiki_: something like this ought to do the trick: http://codepad.org/WTFYfO5n
05:14:23 <Lemmih> StefanM: So that's a yes, then?
05:14:37 <StefanM> yes....why?
05:15:06 <tswett> StefanM: we'd like to know whether to give you the answer or just a lot of hints.  :)
05:15:17 <Lemmih> StefanM: Asking people to solve your homework is kinda frowned upon. You'll have much better luck if you ask a specific question.
05:15:22 <zygoloid> is this a horn-sat solver? :)
05:15:29 <tswett> What Lemmih said.
05:16:07 <kiki_> Lemmih: damn. filter. yeah. you are right
05:16:14 <StefanM> I'm looking for help that will lead me to a solution not the solution itself directly
05:17:02 <StefanM> tswett...whait a minute,you already solved it?:-?
05:17:15 <tswett> StefanM: no, I didn't.
05:17:37 <kiki_> Lemmih: thank you
05:17:47 <kiki_> tsweet: thatn you too=)
05:17:47 <StefanM> good...I got scared...it thought I was an idiot
05:17:54 <StefanM> I*
05:18:42 <zygoloid> StefanM: ok, so we need to start by reformulating the problem in functional programming terms. we can't 'remove' or 'delete' as the problem description says.
05:18:48 <Lemmih> StefanM: Try defining 'propagateUnits' for some example input. Then looks for patterns.
05:18:55 <zygoloid> what we can do is build new Formulae and Clauses which do not contain the bits we don't want.
05:19:48 <tswett> StefanM: congratulations, you have two people trying to answer your question simultaneously.  :)
05:19:49 <zygoloid> StefanM: you're going to need to find the unit clauses within the provided formula, so that would be a good place to start.
05:20:09 <StefanM> ok
05:20:40 <KitB_> StefanM: irc.weegie.net #inf2d
05:21:54 <StefanM> I was thinking like 1)collect the atomic clauses, and filter those out of the non-atomic clauses 2)collect the atomics and remove their negations
05:22:03 <StefanM> 3 test for unsatisfiability
05:22:23 <zygoloid> that sounds like a good approach. which parts of this have you attempted?
05:22:43 <StefanM> all
05:22:44 <StefanM> whait
05:22:58 <StefanM> not_atomic = filter (\not_atomic -> (length not_atomic /= 1) 
05:23:05 <StefanM> that is the 1's part
05:23:41 <StefanM> atomic = filter (\atomic -> length atomic == 1)
05:24:04 <StefanM> well the last one 3 no ideea
05:24:21 <zygoloid> ok, those look approximately right. you'll need to provide 'filter' with the formula to filter too.
05:25:12 <zygoloid> do you know about 'map'?
05:26:06 <StefanM> yes
05:26:50 <deggis> suggestions on "cabal: cannot configure QuickCheck-2.4.0.1. It requires ghc -any" ? using ghc 6.12.3 with cabal 1.8.0.6 & cabal-install 0.8.2
05:27:04 <McManiaC> @pl \(ret,stmt,bndrs) -> dsFoo (stmt,bndrs) return
05:27:04 <lambdabot> (line 1, column 11):
05:27:04 <lambdabot> unexpected ","
05:27:05 <lambdabot> expecting letter or digit, operator or ")"
05:27:05 <lambdabot> ambiguous use of a non associative operator
05:27:17 <McManiaC> huh
05:27:23 <McManiaC> @pl \ (ret,stmt,bndrs) -> dsFoo (stmt,bndrs) return
05:27:23 <lambdabot> (line 1, column 12):
05:27:23 <lambdabot> unexpected ","
05:27:23 <lambdabot> expecting letter or digit, operator or ")"
05:27:23 <lambdabot> ambiguous use of a non associative operator
05:27:33 <McManiaC> @pl \ (ret,stmt,bndrs) -> dsFoo (stmt,bndrs) ret
05:27:33 <lambdabot> (line 1, column 12):
05:27:33 <lambdabot> unexpected ","
05:27:33 <lambdabot> expecting letter or digit, operator or ")"
05:27:33 <lambdabot> ambiguous use of a non associative operator
05:27:37 <McManiaC> ??
05:28:08 <dcoutts> deggis: see ghc-pkg check
05:28:10 <zygoloid> StefanM: ok, so you're missing a few pieces from the specification: 4) removing the clauses which contain literals you've found, 5) removing negated literals from clauses you're keeping
05:28:25 <StefanM> ok
05:28:27 <McManiaC> doesn't lambdabot know 3-tuples?
05:28:49 <zygoloid> McManiaC: @pl doesn't; there are no helper functions to allow it to unpack them.
05:29:05 <McManiaC> hm ok
05:30:04 <deggis> dcoutts: uh, there sure is broken pkgs. though, i think i got the error originally with clean table, mut i'll try cleaning those first
05:34:22 <pastorn> hello #haskell!
05:38:09 <Silex> :b ssi
05:38:14 <Silex> oops, sorry
05:38:20 <deggis> hm, getting same error now with clean ghc-pkg check
05:40:57 <deggis> ghc-pkg list shows only ghc-binary and ghc-prim, maybe my package repo just delivered ghc without needed srcs or something
05:45:32 <R777> f
05:45:35 <jix_> with enumerator... shouldn't there be a simple way to put an enumeratee in front of an iteratee getting a new iteratee, because I don't see how
05:46:32 <deggis> cabal info QuickCheck lists "ghc -any" as it's dependency, any idea where that points (what package is that)?
05:47:44 <dcoutts> deggis: it's the ghc package, also known as the ghc api. it's the library interface to ghc
05:50:06 <kiki_> I need a bit more help. http://codepad.org/YA7S4Q0Z I dont understand the problem. Rectangle((Float,Float),(Float,Float))  first (Float,Float) is the cordinates of right down vertex< and second (Float,Float) are the length of the sides of rectangle
05:50:50 <zygoloid> @type (^)
05:50:51 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
05:50:53 <deggis> dcoutts: ok, thanks
05:50:54 <jix_> kiki_: I think you want a^2 not a^a
05:51:06 <zygoloid> or a*a
05:51:53 <kiki_> jix_: yep
05:52:15 <kiki_> jix_: oh
05:52:21 <kiki_> that was the problem. hah,. thanks
05:52:50 <jix_> kiki_: ^ is exponentiation with an integral exponent, since you put a Float as exponent you got that type error
05:53:35 <zygoloid> haskell: catching your logic errors as type errors ;)
05:57:16 * jix_ doesn't like Data.Enumerator
06:12:37 <mdmkolbe> What is the relationship (if any) between Applicative Functors and Arrows?  (e.g. like how all Monads also define an arrow.)
06:14:04 <romand> hi. using alex+happy, how could I parse "hi <arbitrary_string> again"? If I make lexer tokens [ "hi ", " again", arbitrary_char ], then I can't say my arbitrary_string is sequence of arbitrary_char's because it may contain "hi " or " again" tokens, too
06:14:41 <mdmkolbe> nvm, I just found the WrappedArrow instance
06:20:01 <roconnor> mdmkolbe: http://4.bp.blogspot.com/_gNlz8IC_a0M/S8BOOlSbq6I/AAAAAAAAADk/qaAWYt5ODeg/s1600/effects.png
06:20:14 <roconnor> from http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
06:21:39 <mdmkolbe> roconnor: awsome! thanks. (Though from the looks of that diagram I'll have more questions in a moment when I finish reading the blog entry.)
06:26:24 <Maxdamantus> Hm. Can the argv[0] in C not be got in Haskell?
06:27:02 <Twey> Maxdamantus: It's just a different action (being as it's not actually an argument)
06:27:07 <Twey> getProgName
06:27:20 <Maxdamantus> getProgName seems to take the basename of it :\
06:27:42 <Maxdamantus> Which goes against the convention for unix-oriented utilities, ime
06:28:09 <roconnor> Maxdamantus: IIRC it does go for the convention of portability.  Does windows give you anything more than the base name?
06:28:23 <Maxdamantus> $ ../../../../../../../bin/./././bash foobar
06:28:24 <Maxdamantus> ../../../../../../../bin/./././bash: foobar: No such file or directory
06:28:57 <Maxdamantus> (that way, you can describe usage or errors by how the program seems to have been called from the shell)
06:28:59 <roconnor> hmm
06:29:03 <Maxdamantus> roconnor: I'm not sure. I'd guess so.
06:29:04 <Jafet> Where does System.Environment get its values from?
06:29:04 <roconnor> looks like I'm wrong
06:29:05 <zygoloid> Maxdamantus: no, there is no standard way to get argv[0]. if you look at the implementation of getProgName, there is a way
06:29:10 <shachaf> Maxdamantus: http://hackage.haskell.org/trac/ghc/ticket/3199 -- seems correct.
06:29:14 <Maxdamantus> eg, especially for things like ./a.out
06:29:15 <shachaf> That's pretty silly.
06:29:37 <romand> hi. using alex+happy, how could I parse "hi <arbitrary_string> again"? If I make lexer tokens [ "hi ", " again", arbitrary_char ], then I can't say my arbitrary_string is sequence of arbitrary_char's because it may contain "hi " or " again" tokens, too
06:29:39 <Jafet> roconnor: Windows does not really have that concept of argv, it just passes the program the entire command line. A C runtime might then make argv from that.
06:30:39 * roconnor fair
06:30:49 * roconnor sometimes wants to punch the CRT in the face
06:31:48 <shachaf> roconnor: Chinese Remainder Theorem?
06:31:56 * zygoloid reflects that these programs which want to re-exec themselves using argv[0] aren't doing the right thing anyway
06:32:11 <roconnor> c runtime library
06:32:13 <shachaf> zygoloid: What is the right thing?
06:32:16 <zygoloid> argv[0] need not be a name by which your program can be executed
06:32:16 <roconnor> ... not quite sure how that spells CRT
06:32:32 <Maxdamantus> zygoloid: no, it's an indication of how the program was called by the user.
06:32:42 <zygoloid> shachaf: i'm not sure what the right thing is. but /proc/self/exe would avoid that particular pitfall
06:32:43 <mdmkolbe> Jafet: I'm astonished at the brokeness of that design.  Is there a link I can find out more?
06:32:48 <Jafet> Hmm, System.Environment gets it from the C runtime. Then dutifully and methodically proceeds to mangle it.
06:32:48 <byorgey> Cathode Ray Tube
06:32:55 <byorgey> remember those?
06:33:03 <shachaf> byorgey: Those don't exist anymore, silly.
06:33:03 <roconnor> Connecticut Repertory Theatre
06:33:13 <Jafet> mdmkolbe: actually, it has its uses, for example with "rename".
06:33:21 <shachaf> zygoloid: What about e.g. a program that calls `git pull` and the reexecs itself if anything has changed?
06:33:22 <mdmkolbe> shachaf: nonsense, I use one at home
06:33:34 <Jafet> Er, for example with "copy"
06:33:50 <zygoloid> shachaf: i don't follow. how is that a special case?
06:34:29 <shachaf> zygoloid: Well, it's a justification for using exec argv[0], presumably, because /proc/self/exe would still point to the old program (I think).
06:35:10 <mdmkolbe> Jafet: if you mean what I think you mean then "rename '*.c' '*.h'" should do just the same as what windows can do.  I'm just objecting to not being able to pre-tokenize the command line.  Whether the shell does expansion is another question.
06:35:59 <mdmkolbe> Jafet: (assuming you write a rename program that works like that.  most unix programs don't.)
06:36:03 <zygoloid> shachaf: i'm confused by what situation you're talking about. generally, /proc/self/exe and argv[0] 'change' at the same time
06:36:29 <Jafet> You're objecting as a C programmer, where you expect the pre-tokenization to exist (and so it is provided by a C runtime).
06:37:10 <shachaf> zygoloid: Which pitfall were you talking about?
06:37:19 <shachaf> zygoloid: Oh, the basename thing?
06:37:49 <shachaf> Hmm, /proc/self/exe is a symlink. Never mind everything I said.
06:37:51 <zygoloid> shachaf: no, argv[0] not being your program
06:37:55 <Jafet> Actually, I'm not sure what you're objecting to
06:38:29 <mdmkolbe> Jafet: well I'm objecting from a process API and security perspective.  Not being able to pre-tokenize command arguments when spawning a process means I have to worry about escaping arguments with characters that would mess up the tokenization.
06:39:15 <mdmkolbe> Jafet: suppose I want to pass an argument with "\" or " " or (shudder) control characters in it
06:40:00 <Jesin> hmm
06:40:15 <zygoloid> shachaf: execl("/usr/sbin/setuid-binary-that-execs-argv0", "/bin/sh", 0); // instant root exploit
06:40:32 <shachaf> zygoloid: Yes, I agree.
06:40:43 <shachaf> Ignore everything I've ever said except for the previous line.
06:41:44 <Jafet> Who makes git setuid
06:42:02 <Jesin> just to make sure I understand this right
06:42:17 <Jesin> the associativity required for monads
06:42:38 <Jesin> means that foldl (>=>) is equivalent to foldr (>=>) for finite lists?
06:42:43 <mdmkolbe> Jafet: If I've already got the arguments split out separately (as I often do when spawning a process), encoding them into a single string and hoping that the process I'm launching happens to decode them the right way seems like the long way around the barn.  (For that matter I don't know of *any* language that doesn't provide argv as some sort of pre-tokenize list.)
06:43:23 <Jesin> err, well
06:43:25 <mdmkolbe> Jesin: the zero element will be on oposite sides
06:43:35 <R777> in the fucnction: rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2] how are the variables c and b posing as upper limits?
06:43:42 <Jesin> yes, but the zero element does nothing in both cases, doesn't it?
06:43:57 <Jafet> Well, Windows runs programs with command lines, not lists of arguments.
06:44:03 <Jesin> return x >>= f  = f x
06:44:08 <Jesin> x >>= return = x
06:44:22 <Jesin> oh, right
06:44:31 <Jesin> so, that means those functions are not equivalent, but
06:44:48 <mdmkolbe> Jesin: If you are using "return" for the second argument to foldl/r then yes, but you could choose others that aren't identities
06:44:48 <Jesin> foldl (>=>) return == foldr (>=>) return
06:44:52 <Jesin> right
06:45:48 <mdmkolbe> Jesin: there may also be difference in laziness and space/thunk leaks
06:46:02 <Jesin> hmm
06:46:07 <Jesin> disregarding space leaks
06:46:18 <Jesin> you mean it might have different semantics if _|_ gets involved?
06:46:22 <mdmkolbe> Jafet: Windows does, but I said "language" not "O/S"
06:46:28 <mdmkolbe> Jesin: yes
06:46:32 <Jesin> besides the whole infinite list thing
06:46:58 <mdmkolbe> @type (>=>)
06:46:59 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:47:51 <mdmkolbe> Jesin: your list elements might return bottom, might be bottom, might have bottom hidden inside the monad, etc.
06:48:29 <Jafet> mdmkolbe: but the different ways of doing things come from the operating systems, and just happen to be adopted by languages
06:49:16 <ocharles> byorgey: I'm guessing you're Brent?
06:49:22 <Jesin> hmm, k
06:49:26 <Jesin> I have to go now
06:49:28 <Jesin> bye
06:53:00 <mdmkolbe> Jafet: langauges can build compatability layers.  Of all the languages I know all of them exclusively use the pre-tokenized form.  Even C# does the pre-tokenized form.  That says something about which way is "better".  Given the write pumbing both ways can simulate the other, but simulating argument string from argument list is trivial, the other way is not.
06:54:02 <Twey> *Pre*-tokenised?
06:54:06 <Jafet> Not true. List to string isn't surjective
06:54:38 <Twey> I'm pretty sure C# passes tokenised arguments to the function…
06:54:41 <Jafet> Er, injective
06:54:58 <Jafet> Er, whatever, you know what I mean
06:55:27 <mdmkolbe> Jafet: Actually no I don't, since there is an isomorphism between lists of strings and strings.  Otherwise network protocols wouldn't work
06:56:22 <Jafet> Not if the tokenization converts escape sequences and compresses whitespace.
06:59:07 <mdmkolbe> Jafet: I think you misunderstand.  Compressing white space is completely orthoganal to how arguments are passed to a process.  Compressing white space is part of the shell and how it interprets it's REPL.
07:24:30 <dcolish> Does documentation exist for controlling C dependencies in a cabal file?
07:30:19 <alpounet> dcolish, iirc you have to use the "extra-libraries:" option
07:47:44 <ManateeLazyCat> Hi all, good night! :)
07:48:14 <mm_freak> in emacs' haskell-indentation-mode, is there a convenient way to insert the variable name of a variable you've just given a type signature for?
07:48:28 <mm_freak> in haskell-indent-mode you just write the type signature and on the next line you press tab two times
07:48:59 <mm_freak> this is very convenient, and i'm missing this feature in haskell-indentation-mode
07:49:05 <quicksilver> mm_freak: no, I believe that feature was omitted
07:49:16 <quicksilver> mm_freak: probably kuribas didn't use it or wasn't aware of it.
07:49:25 <mm_freak> hmm, ok
07:49:32 <quicksilver> (it also worked on subsequent lines of a multi-line definition)
07:49:45 <quicksilver> mm_freak: I have become used to typing the first 1 or 2 chars of the name then M-/
07:49:59 <quicksilver> mm_freak: (although I don't disagree; it was a cool feature)
07:50:14 <mm_freak> oh, i didn't know that
07:50:15 <mm_freak> thanks
07:50:22 <quicksilver> context-sensitive completion
07:50:27 <quicksilver> favours words near the point
07:50:33 <quicksilver> and since you've just typed it in the line before...
07:50:45 <quicksilver> very handy for long identifier names in general.
07:51:03 <quicksilver> it will search in other buffers too, if it doesn't find candidate words in current buffer.
07:51:17 <mm_freak> great
07:51:28 <ocharles> What's the difference between indent-mode and indentation-mode?
07:51:33 <mm_freak> ah, dabbrev…  i read about that before, but never considered it a useful feature
07:51:52 <mm_freak> ocharles: indentation-mode chooses the indentation points more strictly and correctly
07:52:03 <sproingie> i have dabbrev bound to M-space in most of my emacen
07:52:07 <ocharles> i see. how come it was a fork, instead of patching indent mode?
07:52:32 <mm_freak> it's a bit more intelligent and thus saves a few tabs…  also with indent-mode i often had the issue that the correct indentation point wasn't found for a nested 'do'
07:52:52 <quicksilver> ocharles: indent-mode was a hack; indentation mode is based on actually parsing haskell
07:53:05 <ocharles> cool, maybe I should switch then :)
07:53:18 <quicksilver> indent-mode looked at things on the previous line which looked like they *might* be indentation points; indentation-mode understands enough haskell syntax to know.
07:53:43 <mm_freak> yes, but it needs some getting used to…  also what annoys me about indentation-mode:  enter indents
07:53:46 <mm_freak> i don't like that
07:54:01 <ocharles> oh, I like that. I have enter bound to the same function as C-j
07:54:03 <mm_freak> but there is probably an easy solution to that
07:54:20 <quicksilver> de-facto standard is ^M for plain newline, ^J for newline-and-indent
07:54:31 <quicksilver> your enter key may seem like ^J to emacs?
07:54:40 <quicksilver> but you can rebind of course.
07:55:21 <cec24> hi, trying to install QuickCheck with cabal and i get the message: "cannot configure QuickCheck-2.4.0.1. It requires ghc -any. There is no available version of ghc that satisfies -any". I'm on redhat and have ghc 6.12.1. What does this -any error mean?
07:56:02 <dcoutts> cec24: it's referring to a Haskell package called ghc
07:56:06 <dcoutts> the ghc api package
07:56:18 <dcoutts> cec24: it comes with ghc
07:56:27 <dcoutts> cec24: use ghc-pkg list ghc
07:56:31 <cec24> dcoutts: oh, huh it looks like i'm missing that
07:56:57 <dcoutts> cec24: hmm, I think I've heard people on fedora report that before
07:57:05 <interferon> are there any approaches to GUI's in haskell other than FRP and typical IO-based implementations (a la gtk2hs)?
07:57:11 <cec24> dcoutts: nope, it's coming up as there. i wonder what i need to do to let cabal know
07:57:37 <dcoutts> cec24: if re-installing the rpm does not work, and if there is no separate fedora package for the ghc library then file a bug with the fedora packaging people.
07:58:06 <mm_freak> quicksilver: i didn't configure enter to act like C-j, and it only happens in indentation-mode
07:58:18 <cec24> dcoutts: thanks i'll look into that
08:00:11 <djahandarie> interferon, have you seen TV / GuiTV by conal?
08:00:23 <djahandarie> GtkTV*
08:00:26 <interferon> djahandarie: hmm, heard about it but haven't really looked at it. thanks - will take a look
08:01:33 <djahandarie> interferon, I don't know how practical it is though, but it's fairly elegant
08:01:58 <interferon> GUI's are the one place where i find it really difficult to think outside of the imperative paradigm
08:02:41 <roconnor> free theorems are useful!
08:03:03 <roconnor> types++
08:03:46 <copumpkin> free as in beer
08:03:47 <Maxdamantus> How do you think imperatively with GUIs?
08:03:58 <conal> interferon: check out tangible functional programming. paper & video. http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
08:04:04 <roconnor> copumpkin: yes!
08:04:10 <interferon> conal: great, thanks!
08:04:14 <conal> @wiki TV -- for interferon 
08:04:14 <lambdabot> http://www.haskell.org/haskellwiki/TV_--_for_interferon_
08:04:24 <conal> oops
08:04:24 <copumpkin> preflex: seen sclv
08:04:24 <preflex>  sclv was last seen on #haskell-blah 131 days, 1 hour, 35 minutes and 7 seconds ago, saying: i think its a bit more straightforward still
08:04:24 <conal> @wiki TV
08:04:24 <lambdabot> http://www.haskell.org/haskellwiki/TV
08:04:24 <interferon> yeah, looking at the Haskell wiki entry now
08:04:41 <interferon> conal: it's arrows underneath?
08:04:48 <djahandarie> @free (a -> Bool) -> [a] -> [a]
08:04:49 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
08:05:02 <conal> from my thinking, imperative programming is an insanely bad mismatch with GUIs
08:05:42 <conal> interferon: TV & TFP use and extend Arrow for structuring the interface.
08:06:02 <quicksilver> s/extend/subvert/ :P
08:06:12 <conal> more accurately, for compositional construction of GUIs.
08:06:27 <interferon> conal: it's a relief to hear that. most of my day job is Cocoa and unlike, say web programming, i just can't figure out how i'd do the same things in haskell other than just putting everything in the IO monad
08:06:56 <conal> interferon: which is just more imperative programming.
08:07:01 <interferon> conal: yep
08:07:27 <interferon> conal: so i'm really interested in better ways of doing it
08:07:29 * roconnor only uses GuiTV for GUI programming
08:07:48 <conal> interferon: glad to hear it!
08:10:37 <interferon> conal: was it you who wrote that post a few months ago about how resorting to the IO monad prevents us from finding better, more functional ways of doing things?
08:11:03 <conal> interferon: probably. it's one of my recurrent themes.
08:11:39 <conal> having IO in haskell has made it easy for us not to figure out how to think functionally/denotatively.
08:12:18 <Cale> interferon: While I don't want to take away from this exploration of other ways of handling GUIs in Haskell, there is at least one big difference between standard imperative stuff and programming GUIs using the IO monad, which is the extent to which the separation between the model and the view/controller are separated in the code, which is kinda cool.
08:12:46 <Twey> OTOH it makes it easier for us to actually use the language before clever functional ways have been devised of doing what we want to do
08:12:47 <interferon> Cale: true
08:12:52 <Cale> My sentence structure sucks, I'm probably tired. :)
08:13:07 <interferon> Cale: kind of the same with web development - there is still some IO in your response handlers, but a lot of stuff can be pushed out to pure code
08:13:18 <interferon> Twey: also true
08:17:42 <conal> Twey: indeed. i like that aspect.
08:18:07 <Twey> I kind of see IO as a sort of theoretical FFI
08:18:27 <Twey> It may be ugly, but there's lots of cool stuff that's already been worked out for imperative code, so being able to fall back on it is neat
08:18:47 <roconnor> ddarius: you were right about coalgebra composition looking like horizotal composition.  I just wrote the definition of horizonal composition of natural transformations, and the body of the two functions are identical!
08:18:57 <quicksilver> a minor but substantial advantage of haskell for imperative IO is that inversion of control / callbacks are much easier to use
08:19:21 <quicksilver> IO actions as first class values is an abstraction out of reach of most common imperative langauages
08:19:43 <roconnor> ddarius: What I don't get is how coalgebra coposition and horizontal natural transformation composition are related categorically?  They have totally different types, even though they have identical implementations.
08:20:22 <interferon> Twey: by no means am i saying it should go away, just agreed with whoever wrote that post that it shouldn't prevent us from looking for new paradigms
08:20:29 <Twey> *nod*
08:21:54 * hackagebot invertible-syntax 0.2 - Invertible syntax descriptions for both parsing and pretty printing.  http://hackage.haskell.org/package/invertible-syntax-0.2 (TillmannRendel)
08:22:55 * hackagebot crypto-api 0.5.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.5.2 (ThomasDuBuisson)
08:25:49 <dolio> roconnor: They're both function composition?
08:26:01 <dolio> They don't have identical implementations, though.
08:26:18 <cec24> \part
08:26:19 <dolio> GHC is just lying to you.
08:28:35 <roconnor> dolio: well, it is true that the haskell code doesn't show the type parameters being passed around
08:29:04 <roconnor> dolio: but both implementions are f * g = fmap g . f
08:29:17 * roconnor hasn't actually tried this in ghc
08:33:14 <smoge> hey there
08:33:44 <smoge> I'm trying out haskell 
08:34:09 <smoge> is there nice projects related to Audio and Music in Haskell ????
08:35:28 <phrackSipsin> smoge, there are bindings for supercollider, HSC3
08:35:37 <smoge> interesting
08:35:40 <roconnor> dolio: http://hpaste.org/44035/two_different_stars  -- this is the code
08:35:41 <smoge> Im a SC user
08:35:59 <smoge> can you creat synthdefs from haskell??
08:36:08 <phrackSipsin> smoge, Also check out http://plucky.cs.yale.edu/cs431/reading.htm
08:36:13 <phrackSipsin> yes 
08:36:26 <smoge> thankls a lot
08:36:27 <phrackSipsin> you can do anything you can in supercollider but with haskell
08:36:29 <roconnor> dolio: star1 is horizontal natural transformation composition
08:36:30 <ocharles> someone had some project for a modular programming environment for music too
08:36:40 <roconnor> dolio: star2 is what I'm calling coalgebra composition
08:36:44 <phrackSipsin> yaxu?
08:36:45 <ocharles> that's on youtube, but i have no idea what it was called
08:37:00 <djahandarie> smoge, http://vimeo.com/19273744
08:37:01 <ocharles> phrackSipsin: yep, thanks
08:37:30 <dolio> roconnor: The second one can be recast to look like (I a -> f a) -> (I a -> g a) -> (I (I a) -> f (g a))
08:37:44 * djahandarie just found out that Julian Assange is an OCaml programmer
08:38:32 <roconnor> dolio: yes, but the foralls in the first one are kinda important.  At least the first forall is.
08:39:19 <smoge> nice Ill take a look
08:39:58 <aristid> djahandarie: oh, cool
08:40:32 <smoge> this video uses scsynth for synthesis??
08:40:57 <phrackSipsin> smoge, yeah it uses the supercollider HSC3 bindings
08:41:20 <roconnor> dolio: because the forall a in the f parameter in star1 will be instantiated at (x a)
08:41:28 <phrackSipsin> you can pull most of the code from yaxu.org
08:42:05 <roconnor> dolio: granted if x = Id then morally the forall a in the f parameter would be instantiated at a and hence all the parameters would be the same.
08:43:34 <smoge> is that this one: http://aur.archlinux.org/packages.php?ID=17601
08:43:38 <smoge> ??
08:44:15 <dolio> Your single implementation works for (f (x a) -> g (x a)) -> (x a -> y a) -> f (x a) -> g (y a).
08:44:24 <phrackSipsin> yeah that's the haskell supercollider bindings
08:44:31 <roconnor> dolio: ya
08:44:40 <dolio> For the natural transformation, you use that implementation component-wise, but GHC hides that from you.
08:44:54 <roconnor> what do you mean component-wise?
08:44:57 <dolio> For the algebra composition, you have x = f = I.
08:45:14 <dolio> I mean there's a hidden type abstraction.
08:45:15 <aristid> @dinn (f (x a) -> g (x a)) -> (x a -> y a) -> f (x a) -> g (y a)
08:45:15 <lambdabot> -- f cannot be realized.
08:45:30 <dolio> Or, in category theory, you specify what happens at each component of the natural transformation.
08:45:33 <aristid> djinn could really have better error messages
08:45:39 <dolio> (f * g)_A = ...
08:46:04 <roconnor> aristid: you need to know that g is a functor
08:46:22 <dolio> Or, those are bad names at that point.
08:46:27 <phrackSipsin> Lamdabot sounds very zen
08:46:43 <aristid> :t \f g -> fmap f . g
08:46:44 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
08:46:54 <dolio> (t1 * t2)_A = Gt2 . t1
08:47:05 <aristid> :t \f g -> fmap g . f
08:47:06 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f a) -> (a -> b) -> f1 (f b)
08:47:14 <dolio> Er, (t1 * t2)_A = G(t2_A) . t1_A
08:47:33 <roconnor> aristid: caleskell is messing with your result
08:47:55 <dolio> Of course, composition of natural transformations and functors can be overloaded to give the same looking definition.
08:48:07 <roconnor> dolio: (t1 * t2)_A = G(t2_A) . t1_XA
08:48:32 <aristid> roconnor: oh, that confused me a little, yes :)
08:48:38 <aristid> but i'm confused anyways
08:48:46 <aristid> :t \f g -> fmap g Prelude.. f
08:48:47 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> (a -> b) -> a1 -> f b
08:48:57 <dolio> Ah, yeah.
08:49:30 <aristid> :t (\f g -> fmap g Prelude.. f) :: (Functor g) => (f (x a) -> g (x a)) -> (x a -> y a) -> f (x a) -> g (y a)
08:49:31 <lambdabot> forall (f :: * -> *) (x :: * -> *) a (g :: * -> *) (y :: * -> *). (Functor g) => (f (x a) -> g (x a)) -> (x a -> y a) -> f (x a) -> g (y a)
08:49:34 <aristid> \o/
08:49:38 <aristid> roconnor: thanks
08:55:25 <jsgf> bos: ping
08:55:31 <bos> yup
08:55:48 <jsgf> in the riak bindings, is there an ordering for the mappend args?
08:56:01 <bos> no
08:56:12 <bos> you shouldn't rely on that
08:56:35 <jsgf> is there some other way of getting the timestamps/vclocks info?
08:57:25 <bos> jsgf: yep. use one of the other APIs.
08:57:30 <bos> the vclocks are opaque.
08:57:59 <bos> but e.g. the Content type is an instance of IsContent
08:58:11 <bos> so you can get the last_mod timestamp that way
09:00:24 <jsgf> hm.  would it be hard to define an ordering for mappend?
09:01:21 <jsgf> oh, btw, do you need to do a push on attoparsec?  current aeson head isn't compiling
09:03:06 <mm_freak> oh yes…  i love those moments, when it makes click:  i finally understood the type signature of enumeratees
09:03:09 <bos> jsgf: i think they're both up to date
09:03:42 <bos> jsgf: well, given that the vclocks are opaque and the conflicting siblings don't have a defined ordering, i don't know how to do that
09:04:18 <aristid> mm_freak: lucky you, i still don't understand them, and i always forget whether enumerator or iteratee or enumeratee is for input or output
09:04:29 <jsgf> jsgf: timestamp?
09:04:35 <aristid> but then, i haven't really used them in-depth
09:04:59 <bos> jsgf: i don't know how trustworthy those timestamps are
09:05:00 <jsgf> bos: ok, i see all your changes now
09:05:07 * hackagebot bindings-libzip 0.1.0.2 - Low level bindings to libzip.  http://hackage.haskell.org/package/bindings-libzip-0.1.0.2 (SergeyAstanin)
09:05:21 <bos> jsgf: i made int parsing accurate
09:05:37 <jsgf> bos: yes, but if that's a concern, you can use a more complex Monoid definition or another API
09:05:42 <bos> if there's a floating point component, you still get a Double
09:05:50 <jsgf> bos: but timestamp ordering on mappend is a reasonable "best effort"
09:06:03 <jsgf> cool
09:06:11 <bos> jsgf: why would you care, though?
09:06:38 <mm_freak> aristid: well, enumerator enumerates, hence it's a producer; iteratee gets enumerated to, hence it's a consumer; enumeratee does both
09:06:56 <mm_freak> aristid: just like employer gives work and employee receives work
09:08:08 * hackagebot sbv 0.9.11 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.11 (LeventErkok)
09:08:28 <jsgf> jsgf: for which?  ordering?
09:08:31 <jsgf> er, 
09:08:38 <jsgf> bos: for which, ordering?
09:09:27 <bos> jsgf: yeah. it's kind of the job of mappend to get the answer right by itself, and it shouldn't depend on which value is first or second
09:10:48 <jsgf> jsgf: i'm thinking of very simple cases where conflicts are really not expected, but need to be dealt with somehow.  I guess if you have two changes that are close enough that they're racing then it doesn't matter which one you get
09:11:07 * jsgf still talking to jsgf
09:11:30 <jsgf> bos: likewise with list ordering on a list Monoid
09:12:23 <bos> jsgf: in that case, define a Monoid instance for a newtype wrapper that does the right thing
09:12:35 <bos> newtype Newest a = Newest a
09:12:49 <jsgf> bos: btw, why does riak depend on network >= 2.3?  it conflicts badly with network-2.2.1.7
09:12:56 <bos> instance Monoid Newest where mappend a b = if timestamp a > timestamp b then a else b
09:13:04 <bos> jsgf: bytestring support
09:13:31 <jsgf> bos: adding network-bytestring with older network works - or at least seems ot
09:14:07 <bos> jsgf: i'm just using network-2.3
09:14:49 <bos> jsgf: do you have some stuff compiled against 2.2?
09:15:31 <bos> jsgf: i know it's a pain, though :-
09:15:32 <bos> :-(
09:18:49 <jsgf> bos: i'm using the fedora packages, and they're all against 2.2
09:19:20 <bos> jsgf: yeah, i stopped using them
09:32:14 <monochrom> haskell platform is still at network-2.2
09:37:57 <saml> hey is there category theory? so that if i want to convert Foo to Bar, i get chain of functions to apply to Foo
09:40:03 <saml> let's say I have Resource,   but I want NodeTypeManager.  then i have to do   (getNodeTypeManager . getWorkspace . getSession) (adaptTo Node node)
09:40:29 <saml> doesn't API form a category?
09:46:42 <Peaker> Saml: of course you can compose functions...
09:47:12 <saml> Peaker, but is there a way to verify an API (set of functions..)  is "closed"  for some algebra?
09:47:30 <saml> like,  this API is a ring, a cateogry, a monad, an arrow
09:47:41 <saml> so that i can sound like smart (in Java)
09:47:59 <Peaker> Oh, don't know. Maybe you mean having a Category instance? 
09:49:43 <jonkri> @type parseBytes
09:49:44 <lambdabot> Not in scope: `parseBytes'
09:49:57 <ski> @hoogle parseBytes
09:49:58 <lambdabot> No results found
09:50:23 <aristid> saml: what do you mean by "API"?
09:51:00 <ski> maybe an algebra specification (as in universal algebra) ?
09:51:31 <pedro3005> is there some function that subtracts two lists? as in a - b = [x | x <- a, x `elem` b == False]
09:51:43 <duckinator> hi
09:51:51 <ski> > "abcde" \\ "defg"
09:51:52 <lambdabot>   "abc"
09:52:01 <pedro3005> thank you
09:52:10 <pedro3005> I wonder how...
09:52:12 <pedro3005> @src (\\)
09:52:13 <lambdabot> (\\) = foldl (flip delete)
09:52:21 <ski> (also, better to use `not' than `== False')
09:52:25 <Peaker> Impossible to type Haskell snippets on a mobile keyboard...
09:52:43 <ski> or .. `notElem'
09:52:47 <ski> @type notElem
09:52:48 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:53:00 <duckinator> Peaker: lies! i've typed them on my phone which uses T9 ;D of course, that's not saying i was particularly happy or efficient with it...
09:53:04 <pedro3005> what does flip do?
09:53:12 <ski> @src flip
09:53:12 <lambdabot> flip f x y = f y x
09:53:24 <ski> > (-) 5 3
09:53:25 <lambdabot>   2
09:53:26 <ski> > flip (-) 5 3
09:53:28 <lambdabot>   -2
09:53:58 <ski> > flip f a b :: Expr
09:53:59 <lambdabot>   f b a
09:54:14 <Peaker> Duck: well, I use Swype, which is awesome for text, but makes symbol entry button by button unbearable..
09:54:41 <duckinator> Peaker: ah... symbol entry with T9 is bearable, but it murders productivity, to say the least...
09:54:46 <pedro3005> @src delete
09:54:46 <lambdabot> delete = deleteBy (==)
09:55:28 <ski> > delete 'a' "abacabad"
09:55:29 <lambdabot>   "bacabad"
09:56:01 <pedro3005> deletes the first occurrence?
09:56:11 <ski> @src delete
09:56:12 <lambdabot> delete = deleteBy (==)
09:56:15 <ski> @src deleteBy
09:56:15 <lambdabot> deleteBy eq x []        = []
09:56:15 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
09:56:22 <ski> yes
09:56:23 <pedro3005> > delete 'b' "ac"
09:56:24 <lambdabot>   "ac"
09:56:29 <jonkri> can anyone give me a hint on how to connect http://hackage.haskell.org/packages/archive/xml-enumerator/0.1.1/doc/html/Text-XML-Enumerator-Parse.html to a handle? i want to use parseBytes but i don't know how to get (?) the enumeratee
09:57:51 <saml> aristid, i think i'm just confused
09:58:45 <duckinator> Peaker: "a" ++ "b" on my phone requires 31 key presses... :P
09:59:09 <byorgey> ocharles: yes, I'm Brent
09:59:13 <accel> duckinator: which 31/
09:59:26 <ocharles> byorgey: great, just wanted to say thanks for the typeclassopedia article - it's fantastic!
09:59:38 <byorgey> ocharles: great, glad you've found it useful!
09:59:46 <edwardk> heya byorgey
10:00:01 <byorgey> ocharles: There's a second edition in the works, should be out sometime this spring
10:00:05 <byorgey> hi edwardk 
10:00:05 <ocharles> ooo
10:00:06 <ocharles> yummy
10:00:13 <ocharles> byorgey: for monad.reader as well?
10:00:17 <edwardk> the second edition should be sexy =)
10:00:18 <duckinator> accel: most of them are opening the symbol list, selecting a symbol on it, and then pressing "Insert"...there's only 4 key presses besides those >.> (space, a, b)
10:00:24 <byorgey> ocharles: no, just as a stand-alone document this time
10:00:34 <ocharles> ok, what should I watch to make sure I don't miss it?
10:00:38 <ocharles> a blog anywhere?
10:01:00 <byorgey> byorgey.wordpress.com is my blog, I will definitely post something about it there
10:01:21 <ocharles> cool
10:01:30 <djahandarie> byorgey, do it in HTML this time ;)
10:01:54 * djahandarie burns all his pdfs
10:02:35 * byorgey definitely prefers PDFs but if I can generate both from the same source I'll see what I can do
10:02:35 <accel> how does parsec deal with unicode?
10:02:39 <accel> does it treat it as one character?
10:03:02 <stepkut> accel: if you are using Parsec on [Char], then a Char is already a unicode character
10:03:04 <Twey> accel: Bad question
10:03:08 <djahandarie> byorgey, I do too... if I'm printing it. Which I'm not. :P
10:03:19 <accel> stepkut , Twey : so Haskell "Char" is unicode, not just 0-255 ?
10:03:23 <Twey> accel: Parsec works on elements of the underlying sequence
10:03:31 <accel> stepkut ++
10:03:32 <Twey> Yes, Char is Unicode
10:03:35 <accel> Twey++
10:03:36 <byorgey> djahandarie: ok, noted.  I will do my best to make it available in several formats.
10:03:37 <accel> accel--
10:03:41 <accel> noted; thanks
10:03:42 <stepkut> accel: right. a Haskell "Char" is a unicode character.
10:03:56 <djahandarie> byorgey, thanks :)
10:04:14 <ocharles> Ok... I've used the ffi stuff to import my foo_delete function, and then create a foreignPtr using that FunPtr. but how can I actually test it to make sure it works?
10:04:32 <Twey> The sequence underneath may be divided into bytes, Unicode characters, or something else entirely; that's not up to Parsec, but to the data type being used and the functions used to generate it
10:04:32 <roconnor> Let D = D * [D -> D] + D + D + O + O + D + [D -> D] * D * [D -> [D -> D]] * D + D + O + N + N * N + N * [D -> D] * D^omega * D
10:04:36 <ocharles> is there a way to force the GC to collect a value?
10:05:23 <ski> roconnor : .. could you label that ?
10:05:45 <ski> @hoogle performGC
10:05:45 <lambdabot> System.Mem performGC :: IO ()
10:06:12 <accel> stepkut , Twey : man, these Haskell guys really got "orthogonal" components right
10:06:16 <accel> it's kinda brilliant
10:06:18 <accel> haskell++
10:06:35 <byorgey> roconnor, what's that?  looks fun =)
10:06:55 <djahandarie> Twey, unfortunately Parsec's design makes it perform like poo on ByteString
10:07:05 <Peaker> Duck: "a" ++ "b" is about 10 here... Switching keyboards and all. It's not that bad, but the ordinary text entry is so awesome it's hard to go back to touch typing..
10:07:27 <ski> roconnor : also, definition of `O' is missing ..
10:07:36 <roconnor> byorgey: it is from Abel Coquand and Pagano's NbE paper
10:07:51 <duckinator> Peaker: haha, i wouldn't know. my phone's little '08 model Nokia :< looking into getting a Samsung Galaxy 5 (not S, 5 as in five..people seem to mix them up a lot) to fix that :)
10:07:52 <ski> Normalization-by-Evaluation
10:08:06 <Peaker> @hoogle ApplicativeFix
10:08:07 <lambdabot> No results found
10:08:14 <duckinator> Peaker: actually, ignore that last bit. looking at a video of it now, the res is horrible lol
10:08:29 <ocharles> ski: well openDatabase "foo.db" >> performGC didn't blow up, so I guess it worked :)
10:08:31 <Twey> The Galaxy S is pretty neat.  My friend has one.
10:08:31 <Peaker> What's Galaxy 5? 
10:08:47 <Peaker> Yeah I'm on the Galaxy s
10:08:48 <jonkri> haskell-mode question: can i have haskell comments automatically wrap, or automatically formatted?
10:08:59 <roconnor> ski: I'm trying to figure out what O is
10:09:01 <duckinator> Peaker: a phone that looks very nice, until you see the horribly low screen resolution :D
10:09:49 <dcoutts> anyone here know how to ban haskell wiki users?
10:09:50 <lispy> ocharles: Not really.   You can force the GC to run and you can write your code so that there are no references to the value
10:09:51 <dcoutts> spammer
10:10:05 <lispy> dcoutts: the captcha is not working?
10:10:06 <ski> roconnor : i mean, something like `D = [fun : D -> D | sum : D + D | ...]'
10:10:16 <dcoutts> lispy: perhaps it's a human
10:10:48 <lispy> dcoutts: sorry, I shouldn't be so snarky :)  I don't think captchas are very effective and I was making a point.
10:10:58 <lispy> dcoutts: Too bad about the spam though :(
10:11:16 * ski makes a line
10:11:30 <dcoutts> lispy: mm, suspect it is human, or it'd have done more
10:11:32 <aristid> lispy: there are services to solve captchas for very little money
10:11:45 <merijn> Amazon Mechanical Turk? :p
10:11:56 <aristid> something like that
10:11:58 <lispy> ocharles: what database library is that?
10:12:12 <ocharles> lispy: Xapian
10:12:19 <roconnor> ski: I think these O's are typos.  I think they should be 1's.
10:12:24 <lispy> ocharles: Hmm...Is that on hackage/
10:12:29 <ocharles> no, I'm writing it
10:12:37 <ocharles> https://github.com/ocharles/Xapian-Haskell contributors much wanted :)
10:12:43 <dcoutts> gwern: ping
10:12:49 <ski> roconnor : oh ..  so `1 + 1' is probably `Bool', them
10:13:02 <gwern> dcoutts: yes?
10:13:09 <lispy> ocharles: you might look at the takusen paper/source to get ideas on preventing space leaks in your db layer
10:13:20 <roconnor> ski: actually it is for the constant terms "zero" and "Nat"
10:13:23 <dcoutts> gwern: what is the procedure I should follow for fellows like this http://www.haskell.org/haskellwiki/Special:Contributions/ZacBlakman
10:13:30 <dcoutts> gwern: I've already reverted the changes
10:13:49 <lispy> ocharles: Needing an explicit performGC is highly suspect :)
10:13:52 <ski> roconnor : it's dependently typed ?
10:14:01 <dcoutts> gwern: but I'm wondering what you do with account/ip blocking and how I do that (for future reference)
10:14:07 <ocharles> lispy: you don't have to
10:14:09 <gwern> dcoutts: are you logged in as an admin?
10:14:09 <ocharles> I'm trying to test my finalizer
10:14:10 <roconnor> ski: yes
10:14:17 <dcoutts> gwern: I suspect I'm not an admin
10:14:32 <gwern> dcoutts: if you looked at his diff, you'd see a 'block this user' link which points to http://www.haskell.org/haskellwiki/Special:Blockip/ZacBlakman
10:15:10 <dcoutts> gwern: right, I don't get that option, just undo
10:15:26 <lispy> ocharles: ah.  Finalizers are finky lot.
10:15:40 <gwern> dcoutts: you can also go to your own user contributions, click on contribs, click on your logs and see whether your userrights have been changed to admin ever
10:15:52 <lispy> ocharles: they work much better than they used to now that they run more frequently though
10:16:56 <accel> is there a haskell function that strips off the extension? i.e. "blah.exe" -> "blah" ?
10:17:04 <dcoutts> yes
10:17:13 <dcoutts> gwern: looks like not
10:17:15 <accel> dcoutts: what?
10:17:18 <lispy> accel: look at filepath library
10:17:32 <lispy> accel: http://hackage.haskell.org/package/filepath-1.2.0.0
10:17:34 <dcoutts> @hoogle extension
10:17:35 <lambdabot> System.FilePath.Posix addExtension :: FilePath -> String -> FilePath
10:17:35 <lambdabot> System.FilePath.Windows addExtension :: FilePath -> String -> FilePath
10:17:35 <lambdabot> System.FilePath.Posix dropExtension :: FilePath -> FilePath
10:17:48 <accel> splitExtension
10:17:55 <accel> lispy++
10:17:58 <accel> dcoutts++
10:18:22 <accel> @t FilePath
10:18:23 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:18:26 <accel> @src FilePath
10:18:26 <lambdabot> type FilePath = String
10:18:31 <dcoutts> gwern: ok, if I can't do it myself, is there a way to notify the people who look after these things?
10:18:37 <gwern> dcoutts: so, you'd have to ask one of the bureaucrats for the admin bit
10:18:58 <accel> > dropExtension "blah.exe"
10:18:59 <lambdabot>   Not in scope: `dropExtension'
10:19:01 <gwern> dcoutts: as you can see from RC, I usually take care of these penny ante guys but I was busy yesterday and the day before with traveling to san francisco
10:19:09 <accel> > System.FilePath.Posix.dropExtension "blah.exe"
10:19:10 <lambdabot>   Not in scope: `System.FilePath.Posix.dropExtension'
10:19:13 <gwern> accel: filepath isn't one of the modules mueval improts by deafault. too specialized
10:19:54 <accel> Prelude> +m System.FilePath.Posix.dropExtension
10:19:55 <accel> <interactive>:1:0: parse error on input `+'
10:19:58 <accel> how do I load it in ghci?
10:20:00 <dcoutts> gwern: ok, can I leave it with you then?
10:20:19 <ski> :m + System.FilePath.Posix.dropExtension
10:20:21 <gwern> dcoutts: well, I blocked that one. but I view the recent changes through RSS and I'm way behind on my feeds
10:20:24 <dcoutts> accel: :m + is for module names
10:20:30 <dcoutts> gwern: oh ok
10:20:30 <gwern> accel: all ghci commands start with ':'
10:20:47 <accel> dcoutts , gwern : notedl thanks
10:20:57 <gwern> dcoutts: to see the current list of bucreaucts you go to Special:SpecialPages or whatever and look for list of bureaucrts / admins, IIRC
10:21:09 <dcoutts> ta
10:21:13 <ski> (well s/.dropExtension// i suppose)
10:22:08 <gwern> dcoutts: might take a while to get a response. none of them are really active
10:22:13 <accel> are there builtins for "read entire file as string / write string as entire file?"
10:22:53 <accel> @src hGetContents
10:22:53 <lambdabot> Source not found. Where did you learn to type?
10:22:54 <dcoutts> accel: I suggest you look into hoogle, it'll help you answer these questions
10:23:06 <ski> @type readFile
10:23:07 <lambdabot> FilePath -> IO String
10:23:11 <ski> @type writeFile
10:23:12 <lambdabot> FilePath -> String -> IO ()
10:23:18 <accel> dcoutts: what should I have searched on Hoogle?
10:23:33 <dcoutts> accel: read file
10:23:46 <accel> ski++ dcoutts++
10:23:50 <ski> @type getContents
10:23:51 <lambdabot> IO String
10:23:53 <ski> @type hGetContents
10:23:54 <lambdabot> Not in scope: `hGetContents'
10:24:02 <ski> @hoogle hGetContents
10:24:03 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
10:24:03 <lambdabot> System.IO hGetContents :: Handle -> IO String
10:24:03 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
10:24:27 <ski> @type interact
10:24:28 <lambdabot> (String -> String) -> IO ()
10:26:44 <accel> in Parsec, why can I say: many (noneOf "\"")
10:26:47 <accel> but I can't say: many " " ?
10:27:09 <accel> ah, lacked oneOf
10:27:14 <zygoloid> because " " isnt a parser :)
10:27:49 <zygoloid> -XOverloadedStrings; instance StringLike (ParsecT ...
10:27:58 <monochrom> hahaha
10:30:12 <accel> I'm writing a function, it looks like this: (which probably manes I should be using interact)
10:30:15 <accel>           contents <- readFile inf
10:30:17 <accel>           writeFile outf transform contents
10:30:21 <accel> question is ... how do I rebind inf/outf to stdin/stdout ?
10:30:25 <accel> since interact uses stdin/stdout
10:31:03 <ski> @src interact
10:31:03 <lambdabot> interact f = do s <- getContents; putStr (f s)
10:31:46 <ski>   hInteract o i f = hPutStr o . f =<< hGetContents i
10:31:49 <ski> i suppose
10:32:22 <ski> or possibly better working directly with the file paths
10:32:50 <accel> got it; thanks ski
10:32:51 <ski>   transformFile o i f = writeFile o . f =<< readFile i
10:34:17 <ski> (so `transformFile outf inf transform' in your case)
10:35:36 <accel> http://hpaste.org/44037/idiomatic <-- is there a way to make that more idiomatic?
10:35:40 <merijn> #haskell academics, what is an appropriately academical way of saying "screwed up" (as in "whether someone screwed up")
10:35:40 <accel> i.e. kill the let
10:36:09 <accel> merijn: "quit the phd program"
10:36:13 <jnj> "dun goofed"
10:36:14 <monochrom> perhaps "makes mistakes"
10:36:19 <accel> jnj: lol
10:36:26 <zygoloid> accel: [names] <- getArgs
10:36:28 <merijn> accel: As HLint says, why use "args !! 0" instead of "head args"
10:36:32 <accel> consequences will never be the same again
10:36:37 <accel> merijn: i'm looking to get rid of the let
10:36:38 <mauke> pattern matching > head
10:36:46 <mauke> accel: the let is fine IMHO
10:36:51 <mm_freak> merijn: someone :: a
10:37:11 <zygoloid> uncurry transformFile (getFileNames names) transform ?
10:37:11 <merijn> accel: I prefer where to let, but why do you want to be rid of it so badly?
10:37:20 <accel> eh, i'm in vim
10:37:23 <accel> vim identation for ahskell sucks
10:37:31 <accel> default screws up idnetation for next line
10:37:32 <merijn> mauke: I prefer head to pattern matching... (See what I did there? :D)
10:37:36 <accel> i.e. let's don't make much sense unless there's multiples lines
10:37:53 <gwern> dcoutts: I think I've gotten all the recent spam
10:38:08 <dcoutts> gwern: great
10:38:33 <merijn> monochrom: Yeah, I guess "made mistakes" is suitably formal in this case
10:38:45 <monochrom> single-line lets are just fine
10:40:31 <zygoloid> [getFileNames -> (inf, outf)] <- getArgs
10:40:33 * zygoloid ducks
10:40:49 <monochrom> hahaha
10:41:06 <mariano|godot> what's the format of the EDITOR envvar to allow ghci to jump to specific lines?
10:41:15 <merijn> @remember ConorMcBride "Sometimes it's easier to search for good programs in the space of well typed programs, rather than in the space of ascii turds."
10:41:16 <lambdabot> Okay.
10:41:28 <mariano|godot> heh
10:41:47 <mariano|godot> well, the space of unicode turds is even worse...
10:42:02 <merijn> That one is so going in my thesis and presentation on dependent typing :>
10:43:23 <zygoloid> do [getFileNames -> ((readFile -> r), (flip (flip writeFile . transform) -> w))] <- getArgs; w =<< r
10:44:01 <mauke> merijn: why the quotes?
10:45:17 <MasseR> How come on my other computer (older ghc) AES package cache is iso-8859-1 (thus failing ghc-pkg recache) and on my other computer utf-8 as supposed
10:45:55 <monochrom> older ghc used ios-8859-1, newer ghc use utf-8
10:46:11 <merijn> mauke: Because I just copied it from my editor and didn't really think about them being there
10:52:12 <scan> oh my god, I found it! the Truth!
10:52:30 <scan> time is actually an endless recursive function of type Universe -> Universe
10:52:47 <scan> there is no state in the world
10:53:24 <merijn> scan: Don't you just mean the universe is a fixpoint?
10:53:41 <kulakowski> scan: time from what reference point?
10:53:52 <merijn> Also, my dirty socks would beg to differ on the no state idea...
10:53:52 <scan> it is re-created every possible quantum moment
10:54:02 <scan> and garbage collected once in a while
10:54:26 <monochrom> #physics? ##physics? ##physics-outcasts?
10:54:29 <lowasser> http://www.haskell.org/haskellwiki/GHC/Type_families#Type_class_instances_of_family_instances So sure, you can derive Show, but I'm having problems deriving e.g. Functor, which shouldn't be a partial application,  but it is?
10:55:10 <monochrom> also http://groups.google.com/group/comp.lang.functional/msg/4c1cb17ded810ea0
10:55:55 <scan> newtype Universe = BigBang
10:55:55 <scan> time :: Universe -> Universe
10:56:51 <scan> I must start a religion on this
10:57:40 <c_wraith> @quote category.of.religion
10:57:40 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
10:57:40 <lambdabot> object in the category of religions and theomorphisms.
10:57:49 <merijn> scan: I think every person who encounters quantum mechanics and the usual Gödel/Turing/Halting/Cantor's diagonalization stuff goes through a phase like this :p
10:58:04 <accel> http://hpaste.org/44038/parsesec <-- how do I say that a TeXLine is a bunch of parseSpace / parseWords separating each other, ending with either parseSpace or parseWord ?
10:58:09 <accel> http://hpaste.org/44038/parsesec <-- how do I say that a TeXLine is a bunch of parseSpace / parseWords separating each other, ending with either parseSpace or parseWord ? (this is in the context of parsec)
10:58:52 <scan> merijn: Aw, everytime I have an epiphany I find out someone nicked the idea from me before I had it.
10:59:27 <merijn> c_wraith: I especially like the "theomorphisms" part :>
10:59:45 <monochrom> I did not go through a phase like that.
10:59:57 <merijn> scan: That's because mathematicians and functional programmers are a bit weird like that and some (most?) of them are far to clever for their own good.
11:00:22 <byorgey> accel: maybe use parseWord `sepBy` parseSpace, followed by an optional occurrence of parseSpace?
11:00:35 <monochrom> but yes, too-clever people philosophize and ideologize too much.
11:00:59 <scan> I am so clever I approach dumb from the other side
11:01:06 <silver> lol
11:01:17 <accel> byorgey: hmm; good call; tahnks
11:01:50 <merijn> I got over it when I started to read Less Wrong and decided that personal philosophies with no real world impact are not rational philosophies since there's no gain to be had from them
11:01:53 <monochrom> parseSpace accepts the empty string. not sure you want it.
11:03:12 <scan> monochrom: then "an optional parseSpace" is surely equal to parseSpace, right?
11:03:46 <monochrom> sepEndBy says "separated and optionally ended by sep, ie. haskell style statements."
11:03:57 <litb> hmm
11:04:51 <eb4890> Where can I find the possible Rep types (RepHtml. RepPlain etc) in Yesod?
11:05:10 <byorgey> oh, thanks, forgot about sepEndBy =)
11:06:28 <scan> eb4890: http://hackage.haskell.org/packages/archive/yesod-core/0.7.0.1/doc/html/Yesod-Content.html
11:06:42 <shamster> what's the term (mathematical) for taking a discrete data set (x1,y1), and then finding a point y_a that corresponds to x_a that would 'fit' that dataset (x1,y1)?
11:06:54 <scan> eb4890: http://hackage.haskell.org/packages/archive/yesod-core/0.7.0.1/doc/html/Yesod-Content.html#g:6 to be exact
11:07:17 <monochrom> oh ha, yesod haddocks are not built on hackage, no wonder
11:07:49 <scan> yesod was recently split up to several sub-packages
11:08:27 <eb4890> scan: Thanks.
11:08:47 <scan> eb4890: yer welcome, nice to meet another yesod-er
11:09:12 <monochrom> regression analysis guesses y_a
11:09:18 <eb4890> scan: Just starting out. Not sure if it can do what I want yet.
11:10:21 <scan> eb4890: I must relearn it, kinda, since snoyberg overthrew the hamlet syntax without documenting anything
11:11:52 <scan> didn't lambdabot used to have a feature for obscuring simple haskell expressions? to remove do's and lambdas?
11:12:05 <monochrom> @undo do { x; y }
11:12:06 <lambdabot> x >> y
11:12:15 <merijn> scan: @pl?
11:12:15 <monochrom> @pl \x -> y
11:12:15 <lambdabot> const y
11:12:27 <scan> thanks
11:12:42 <udoprog> trying to figure if it's possible to get the process id of a child process through the ProcessHandle, couldn't help myself through hoogle, any insight?
11:13:18 <monochrom> @unpl const y
11:13:18 <lambdabot> (\ _ -> y)
11:13:31 <djahandarie> Heh 'obscuring haskell expressions'
11:13:33 <monochrom> @unpl f . g . h
11:13:33 <lambdabot> (\ c -> f (g (h c)))
11:13:35 <djahandarie> I guess that is what it usually does
11:14:13 <monochrom> "obscure" is subjective to educational background
11:14:35 <scan> i want my code effective, not readable
11:14:43 <monochrom> a tribe who only knows the number system "one, two, many" thinks that zero is obscure
11:14:53 <scan> cos the other guy next to me will steal it for his homework
11:15:12 <monochrom> ancient Greeks also probably thought zero was obscure
11:15:27 <scan> naw, they only thought nothing of it
11:15:36 <jmcarthur> well i haven't seen zero of anything. seems obscure to me!
11:15:39 <monochrom> same difference
11:16:09 <scan> they also clubbed the guy to death that found irrational numbers
11:16:41 <scan> personally, I could do without pi and sqrt(2), but no...
11:16:43 <monochrom> most possibly (I think nothing of >>=) = (I am uneducated about >>=) = (>>= is obscure)
11:17:17 <jmcarthur> i thought it was a rational decision
11:17:18 <scan> there's only one thing better than >>=... that is =<<
11:17:25 <silbo__> hey, how well I have to know Haskell to participate on GSOC ?
11:17:26 <alpounet> scan, depends on what you mean by "i could do without"
11:17:29 <jmcarthur> scan: <=< is pretty nice too :)
11:17:32 <djahandarie> No, =>> is better
11:17:32 <alpounet> i mean, it's just there
11:17:44 <alpounet> you can avoid using them, but it's there
11:17:54 <monochrom> where?
11:18:01 <mjrosenb> are there any reasonably fast priority queue implementations for haskell?
11:18:05 <jmcarthur> alpounet: i personally don't buy into the "math is reality" theory ;)
11:18:06 <monochrom> platonic plane?
11:18:12 <kulakowski> jmcarthur: that was terrible.
11:18:18 <scan> I would just set pi = 3 and find workarounds where it does not fit
11:18:30 <jmcarthur> kulakowski: too square?
11:18:35 <alpounet> jmcarthur, depends
11:19:18 <eb4890> scan: Busy designing at the moment. I'll come back and have a chat once I've used it in anger a bit.
11:19:30 <alpounet> jmcarthur, are lengths of real objects part of "reality" for you ?
11:19:30 <jonkri> can anyone give me a hint on how to connect http://hackage.haskell.org/packages/archive/xml-enumerator/0.1.1/doc/html/Text-XML-Enumerator-Parse.html to a handle? i want to use parseBytes but i don't know how to get the enumeratee...
11:19:32 <jmcarthur> alpounet: math is designed for human comprehension. it would be quite a coincidence if math was also somehow natural to our universe
11:19:34 <scan> eb4890: O'course
11:20:16 <scan> http://imgs.xkcd.com/comics/purity.png
11:21:20 <adnap> so, is the reason a function like size(int* xs) { return sizeof(xs) / sizeof(xs[0]); } doesn't work because sizeof(xs) gives the size of the pointer or something?
11:21:38 <jmcarthur> alpounet: i do indeed highly doubt that length is an intrinsic property
11:21:42 <merijn> I see a bunch of people who should read http://lesswrong.com/lw/jl/what_is_evidence/ to cure themselves of (most of) "math is reality" disease :p
11:21:42 <adnap> whoops
11:21:46 <Zao> adnap: The sizeof operator gives the size of the static type of the provided expression/type.
11:21:47 <adnap> i thought this was haskell-blah
11:22:06 <adnap> Zao: so it gave the size of an int*?
11:22:14 <merijn> adnap: Yes
11:22:18 * Zao eyes -blah.
11:22:37 <adnap> yeah, moving to blah
11:23:03 <jmcarthur> alpounet: i see things like "length" more like abstractions that we created so we don't have to explain every molecule of an object just to explain why it won't fit in a particular box :)
11:23:15 <monochrom> @src length
11:23:15 <lambdabot> Source not found. Wrong!  You cheating scum!
11:23:26 <monochrom> oh, it is abstract!
11:23:58 <scan> I wish the Universe was open source
11:24:16 <merijn> Or more generally then the "What's evidence" one just the entirety of http://wiki.lesswrong.com/wiki/Map_and_Territory_(sequence) (or just all of Less Wrong, my estimate is that most people in here would appreciate the essays)
11:24:35 <scan> we should re-do it as a community project
11:24:49 <alpounet> jmcarthur, yeah, i see, since it doesn't designate something we can actually touch/feel, it isn't part of reality
11:25:03 <monochrom> I don't exactly appreciate lengthy essays and lengthy videos. especially if the same point could be made in a 100 words.
11:25:20 <monochrom> or 1 formula.
11:27:12 <monochrom> statistically, very few people have enough points to make to warrant a lengthy exposition.
11:27:19 <jmcarthur> alpounet: math serves as a denotational model for reality :)
11:27:37 <jmcarthur> for various views of reality, i should say
11:28:03 <alpounet> yeah 
11:28:18 <monochrom> even the same view could use several denotational models, not just one.
11:28:27 <jmcarthur> yes
11:29:15 <jmcarthur> well, arguably, if there are several denotational models for the same view, either you are actually talking about many related views or the models are actually equivalent in some way
11:29:39 <scan> I always found weird how people can write several books about some topic you can completely summarize in one sentence
11:31:04 <jmcarthur> scan: there are often many conclusions you can derive from a single new axiom
11:31:12 <aristid> monochrom: so, what's your twitter handle?
11:31:38 <jmcarthur> s/conclusions/<something else>/
11:31:49 <monochrom> I don't have a twitter account.
11:32:23 <monochrom> you could also say theorems.
11:32:43 <scan> jmcarthur: yes, true
11:32:49 <aristid> monochrom: few people have enough to say to need more than 140 characters, to spin your argument further :)
11:34:02 <monochrom> my argument is statistical. perhaps the distribution says there are significantly more people with worthwhile things to say in 140 bytes.
11:34:31 <monochrom> but in any case I don't even have enough to say on twitter, so I don't open an account.
11:50:43 <mjrosenb> @pl (\x->x)
11:50:44 <lambdabot> id
11:51:11 <mjrosenb> @pl (\x y ->f (g x) (g y))
11:51:12 <lambdabot> (. g) . f . g
11:51:25 <mjrosenb> @pl (\f x y -> f (g x) (g y))
11:51:25 <lambdabot> flip flip g . ((.) .) . (. g)
11:53:20 <burp> yay for @pl spam
12:04:35 <blueonyx> hey, is there some JSON typeclass for JSONb? or dont you parse your json to your specific types? or can JSONb's schemas assist there?
12:14:45 <jedai> @type on
12:14:46 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:16:07 <jedai> mjrosenb: If you're searching for a function in Haskell that does what you put in your @pl, you should look at Data.Function.on
12:16:39 <jedai> mjrosenb: pretty useful to "compare `on` stuff"
12:17:48 <xplat> where do i register my vote to retain the old qualified operator syntax and dump the new one into the deepest reaches of the sea, preferably after blowing it up with atom bombs in a volcano?
12:20:32 <fryguybob> http://hackage.haskell.org/trac/haskell-prime/wiki/QualifiedOperators ?
12:21:11 <accel> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:many <-- why is many1 not documented? I'm looking for somethign like many, but matches atleast 1
12:22:21 <dark> wikipedia says: "In functional programming, a monad is a kind of abstract data type constructor used to represent computations (instead of data in the domain model).", but isn't monad just an interface?
12:22:34 <accel> Chapter 14 of RWH
12:22:39 <accel> the Logger Monad expalined everything to me
12:22:58 <accel> (this is where you follow up with "accel++" and I get karma)
12:23:23 <ClaudiusMaximus> accel: http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Combinator.html#v:many1
12:23:31 <dark> i mean. there is also Functor and Applicative and Arrow.. what monad has that is so special?
12:23:44 <copumpkin> it isn't so special
12:23:55 <copumpkin> everyone makes a big deal about them so everyone makes a big deal about them
12:24:32 <accel> ClaudiusMaximus: thanks
12:24:55 <dark> if one creates a random data type and manages to define return and >>=, it is a monad (what contradicts this 'used to represent computations, instead of data in the domain model')
12:25:35 <dark> I saw some description like: maybe is a computation that may fail; list is a non-deterministic computation..
12:25:44 <jedai> dark: it's not really special though it's a good interface to mimic imperative code and some others computational "environment"
12:25:48 <dark> but quite frankly, you can describe any data type in that way
12:25:56 <zmyrgel`> hi, how can I define new function in ghci?
12:25:59 <jedai> dark: not really... 
12:26:06 <fryguybob> dark: manages to define fmap, return, and >>= so that they follow the monad laws.
12:26:18 <byorgey> dark: well, that's not quite true.  There are lots of data types for which you will not be able to define sensible return and >>= methods.
12:26:50 <zmyrgel`> real world haskell just says that ghci uses different syntax for defining functions in ghci
12:26:55 <jedai> dark: The monad laws are quite important too
12:27:12 <ray> omg monads
12:27:33 <jedai> zmyrgel`: you need to put let before the definition as if you were in a do-block of a monad
12:27:33 <systemfault> I am the lawwww
12:28:02 <jedai> zmyrgel`: for instance "let f x y = x + y * y"
12:28:22 <zmyrgel`> jedai: can I use pattern matching that way?
12:28:55 <zmyrgel`> fact 0 = 0 \n fact n = n * fact (n-1) ?
12:28:57 <jedai> zmyrgel`: yes but you can't use multiline syntax (except in the most recent ghci from what I heard)
12:29:26 <jedai> zmyrgel`: let fact 0 = 0; fact n = n * fact (n-1)
12:30:49 <jedai> zmyrgel`: use {} to create a block where you would have indented your code more and use ; where you would put a new line in normal code
12:31:07 <jedai> zmyrgel`: it's the desugared version of Haskell syntax
12:31:38 <zmyrgel`> ok, thanks 
12:32:08 <jedai> if you have a really recent version of ghci you may be able to use multiline with :{ consult the help for more information
12:32:20 <zmyrgel`> nah, I'm on debian :)
12:32:46 <accel> Parsec is the best invention ever.
12:33:00 <accel> whoever invented Parsec deserves the Nobel prize
12:33:02 <dark> so "a monad is a kind of abstract data type constructor used to represent computations" is accurate and adequate as a first sentence on http://en.wikipedia.org/wiki/Monad_(functional_programming) ?
12:33:11 <accel> genome sequences squirm in fear at the thoght of Parsec
12:33:20 <jedai> dark: not really I think
12:34:13 <ceii_> accel: you mean one of its massively optimized offspring
12:34:19 <ceii_> parsec is _slow_
12:34:25 <dark> "A physical analogy for monads, explains monads as assembly lines." http://haskell.org/all_about_monads/html/analogy.html but you can think about function composition as an assembly line too
12:34:28 <accel> ceii_: parsec is parsing my 1000 line file with no problem
12:34:38 <ceii_> oh, cool
12:34:41 <accel> ctually, it's only 100 lines
12:34:44 <accel> but 1000 soudns more impressive
12:34:47 <ceii_> :)
12:35:29 <jedai> dark: it would be more accurate that a monad is a combination of a type constructor and some functions that allows to combine the data type you get when you apply this type constructor, all of that respecting some equational laws
12:36:33 <jedai> ceii_: it all depends on what you want to parse.... Parsec is appropriate in many simple case (and it's pretty easy to switch to an "optimized offspring" if you need to later)
12:36:49 <accel> is Happy an "optimized offspring" ?
12:36:58 <jedai> dark: but longer I guess
12:37:23 <jedai> accel: no, Happy was there before and is more in the yacc line of tools
12:38:20 <jedai> accel: that is a compiler generator that takes a specific format of grammar interspersed with code and generate a parser code from it
12:41:39 <jedai> accel: Parsec allows you to write your grammar directly in Haskell which is quite cool and open interesting possibilities for abstraction but Parsec itself can't be as fast as Happy or others since it has less opportuniy for optimisation
12:45:18 <accel> Parsec makes parsing fun.
12:45:31 <accel> jedai: hmm, what if someone implementned Parsec as template haskell?
12:45:51 <revenantphx> I'm having an issue with Parsec right now :\
12:45:55 <revenantphx> It's getting stuck in a loop.
12:46:10 <c_wraith> I find other combinator libs more fun than Parsec.  I'm not a fan of try
12:46:33 <revenantphx> if anyone has suggestiomns as to how to solve this do tell
12:46:34 <revenantphx> https://gist.github.com/830220
12:46:37 <accel> ceii_: name a few
12:46:42 <accel> ceii_: wrong auto completion, sorry
12:46:44 <accel> c_wraith: name a few
12:46:46 <revenantphx> the issue is that parseExpr I marked on line 26 loops
12:46:56 <c_wraith> accel: polyparse, uu-parsinglib
12:47:08 <ksf> "What a Monad is not deals with common misconceptions and oversimplifications in a humorous way."
12:47:15 <ksf> woot I'm quoted by wikipedia
12:47:35 <ksf> though byorgey outranks me.
12:47:39 * hackagebot pointed 0.1.0 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-0.1.0 (EdwardKmett)
12:47:51 <ksf> not to mention wadler.
12:48:34 <zmyrgel`> suggestions, what would make good example for a closure?
12:48:43 <edwardk> const 12
12:48:47 <byorgey> edwardk: what's this!?
12:48:51 * monochrom goes read "What a Monad is not"
12:48:54 <edwardk> byorgey:  hahhahahahaha
12:49:21 <edwardk> byorgey: enough people have asked for it that i factored it out, but made it its own isolated package and removed the Functor superclass constraint
12:49:31 <byorgey> ahh, I see =)
12:49:38 <monochrom> hahaha "...just accept that they're burritos, and wait until later."
12:49:55 <edwardk> because there is no point in making Pointed a subclass of Functor as the only relationship between point and fmap is a free theorem
12:50:31 <edwardk> and this opened up the ability to use point on Set, etc.
12:50:48 <edwardk> and Endo
12:51:53 <copumpkin> omg an edwardk 
12:52:07 <copumpkin> zomg, I mean
12:52:07 <edwardk> zomg its a copumpkin
12:52:11 <copumpkin> :P
12:52:22 <edwardk> i could have sworn i just saw him in a board room somewhere
12:52:41 * hackagebot comonad-transformers 1.5.2.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.2.1 (EdwardKmett)
12:54:20 <saml> > ke$ha
12:54:22 <lambdabot>   "ke$ha"
12:55:24 * monochrom feels still hurt about the colloquial use of "strict" vs "lazy" as antonyms.
12:55:36 <monadic_kid> get some votes for better FFI generator tools: http://www.reddit.com/r/haskell_proposals/comments/fmqbx/betterupdate_ffi_generator_tools/
12:55:41 <ksf> monochrom, fix it.
12:55:45 * edwardk consoles monochrom, then proceeds to continue to use them that way ;)
12:55:47 <monadic_kid> GSOC coming
12:56:11 <djahandarie> Yeay, pointed
12:56:17 <edwardk> djahandarie: =)
12:56:21 <djahandarie> I feel like I wanted this at one point but I don't remember now!
12:56:22 <edwardk> djahandarie: even if its simpler now
12:56:43 <edwardk> djahandarie: muahahaha it is working! delay long enough and folks eventually forget why they even wanted it! ;)
12:57:22 <djahandarie> edwardk, oh by the way, I think I convinced Tillmann to depend on categories :)
12:57:48 <djahandarie> I also mentioned the semifunctor to him but didn't do a very good job at motivating it since I still don't fully grasp its usefulness :P
13:00:39 <blueonyx> what's the difference between the iteratee and enumerator packages? does enumerator not support I/O?
13:01:21 <monochrom> fixed in teh HEAD
13:01:28 <c_wraith> blueonyx: just different APIs
13:01:34 <c_wraith> blueonyx: conceptually similar
13:02:30 <aristid> edwardk: how would the optimal hierarchy look? class Functor f; class Pointed f; class (Functor f, Pointed f) => Applicative f; class (Applicative f) => Monad f?
13:02:31 <edwardk> djahandarie: =)
13:02:48 <edwardk> aristid: i wouldn't use Pointed honestly. i don't believe in it
13:03:12 <blueonyx> c_wraith: thanks
13:03:16 <aristid> edwardk: didn't you say a bit earlier that you like having Pointed instances for Set?
13:03:26 <Younder> I use Jean Michelle Jare Equinox 4  as a pure mathematician song, but it isn't quite working far me any suggestions?
13:04:15 <edwardk> aristid: class Functor f; class Functor f => Apply f; class Apply f => Applicative f; class Apply f => Bind f; — then Monad is an alias class (Bind f, Applicative f) => Monad f; instance (Bind f, Applicative f) => Monad f or some crap like that
13:04:36 <NihilistDandy> Younder: Einstürzende Neubauten
13:04:43 <NihilistDandy> Any of it
13:04:47 <NihilistDandy> Makes math fun for me
13:04:49 <Younder> But it isn't quite working for me so far.  Any any suggestions?
13:04:57 <edwardk> aristid: it was a target of opportunity when browbeat to actually provide a pointed class, but i don't actually care for it
13:05:17 <edwardk> aristid: the problem is the lack of laws for Pointed/Copointed
13:05:27 <aristid> edwardk: haskell 98/2010 is not really suited for such deep class hierarchies, i think
13:05:56 <edwardk> aristid: Functor, Apply, Applicative, Bind, Monad isn't so bad. each one (except Monad) adds one operation
13:06:14 * djahandarie checks if edwardk has fail in his Monad
13:06:29 <edwardk> i don't actually define Monad anywhere ;)
13:06:43 <djahandarie> Ah, then you've avoided the fail entirely, I see
13:06:43 <aristid> edwardk: well typically you would need to define about two operations and all the rest could be derived. but haskell does not do that
13:06:44 <edwardk> but i don't believe in fail beng part of Monad ;)
13:07:02 <edwardk> aristid: correct, that is something we're able to do better in scalaz
13:07:11 <aristid> scalaz or scala?
13:07:15 <xplat> fryguybob++
13:07:22 <edwardk> aristid: scalaz, the fp library we have in scala
13:07:32 <aristid> edwardk: is it open source?
13:07:38 <byorgey> I read a paper the other day which was otherwise a really fantastic paper, but kept saying things like "such-and-such function returns its result in a monad since it may fail"
13:07:40 <edwardk> aristid: that hierarchy is being revamped into more or less the one above
13:07:41 <edwardk> yes
13:07:43 <byorgey> it was really painful
13:07:47 <edwardk> github.com/scalaz/scalaz
13:08:04 * ksf thinks we should hold back on releasing iteratees to the general public.
13:08:07 <edwardk> the 7.0 release should follow the semigroupoids hierarchy
13:08:15 <ksf> I see another swoosh of incoherent tutorials.
13:08:35 <aristid> edwardk: is odersky's scala book any good, btw?
13:08:37 <ksf> quick, all dress up in your conspiracy cabal robes!
13:08:42 <edwardk> aristid:  no idea.
13:08:55 <xplat> you know, all these first-sentence-of-Monad_(FP)-bashers are kind of ignoring the fact that monads got into the FP vocabulary via Moggi's computational lambda calculus and the use of monads therein to (wait for it)
13:08:57 <aristid> edwardk: well, how did you start learning scala?
13:09:05 <edwardk> aristid: i learned scala by reading the reference manual and by then trying to actually use the language as specified ;)
13:09:17 <xplat> ... model computations as distinct from the values in the semantic domains of datatypes
13:09:33 <aristid> edwardk: that was after you already had learned haskell?
13:09:41 <Younder> NihilistDandy: thank you
13:09:45 <edwardk> yes
13:09:56 <edwardk> i learned scala 3-4 months ago
13:10:19 <edwardk> thats why i haven't been writing as much haskell lately ;)
13:10:20 <djahandarie> And he has already reported numerous compiler bugs ;)
13:10:44 <aristid> edwardk: i'm contemplating learning scala so i can write functional programs for my android phone :D
13:10:52 <edwardk> not a terrible motivation
13:10:56 <xplat> heh, i reported a few compiler bugs once i learned scala too
13:11:13 <Younder> learn ML instead
13:11:15 <edwardk> xplat: seems to be something of a right of passage ;)
13:11:30 <xplat> yeah
13:11:31 <gwern> > 365 / 2
13:11:32 <lambdabot>   182.5
13:11:36 <aristid> Younder: is there an ML that runs on the JVM?
13:11:39 <edwardk> younder: no thanks. i rather like the language features i'd have to give up to use an ml derivative
13:11:42 <aristid> (or on Dalvik for that matter)
13:11:48 <Younder> a vastly superior language.
13:12:00 <xplat> one thing i really miss whenever i go from scala to haskell is the module system
13:12:15 <Younder> aristid, I hope not
13:12:20 <gwern> > 182 * 38.69
13:12:21 <lambdabot>   7041.58
13:12:39 <saml> is that your final answer lambdabot ?
13:12:42 <aristid> i haven't actually learned scala yet, but i have a certain fear of the huge number of features. haskell is a pretty small and simple language, actually.
13:12:55 <aristid> saml: or should we say watson?
13:13:03 <djahandarie> Second thing you do when you learn Haskell is learn about monads. Second thing you do when you learn Scala is report all the compiler bugs you found in the process.
13:13:13 <Younder> well, I have a deep love for ML
13:13:23 <aristid> Younder: do you also love haskell? :)
13:13:24 <saml> so is there best practice haskell book or webpage?
13:13:40 <saml> most of the time, you write monad and monad transformer right?
13:13:42 <edwardk> Scala is basically every language feature Odersky has ever wanted to play with dumped in a pot and stirred. It has congealed remarkably well, but there are still lumps.
13:13:44 <monochrom> best practice haskell is "go with your heart"
13:13:44 <aristid> saml: well, there's Real World Haskell, but i'm not sure if that's precisely what you're asking for
13:13:50 <Younder> and I  also love Haskel yes
13:14:05 <xplat> aristid: when i use scala i don't feel that much like there are an immense number of features
13:14:20 <aristid> xplat: maybe i listen to edwardk too much
13:14:21 <xplat> at least, not usually.  even when reading other people's code
13:14:23 <edwardk> saml: as in separate State and StateT?
13:14:28 <gwern> > 3400 / 7041
13:14:29 <lambdabot>   0.48288595369975856
13:14:30 <Younder> Haskell
13:14:34 <saml> edwardk, yah something like that
13:14:52 <saml> does leksah help you reduce boiler plate?  runYourMonad ...etc
13:15:03 <edwardk> saml: that was the original practice, but the community evolved away from it. note current transformers defines just the transformer version and defines the other in terms of it
13:15:26 <saml> edwardk, ah !
13:15:32 <ksf> @remember monochrom best practice haskell is "go with your heart"
13:15:32 <lambdabot> It is stored.
13:16:07 <edwardk> i preferred the original, but was willing to bow to what others wanted on that. it results in less code, but the early philosophy was not to define simple things as special cases of more complicated ones as a tool for pedagogy. this is the thought pattern that led to use having an explicit map as opposed to fmap, etc. so it was taken a bit too far the other way
13:17:02 <ksf> edwardk, I'd advocate having both versions. and explitcit links from fmap to map and vica versa.
13:17:04 <saml> edwardk, what code is relevant to read? to learn the "new cool stuff"?
13:17:15 <ksf> ...ind the haddock, that is.
13:17:19 <saml> I can't find StateT anymore here: http://www.haskell.org/ghc/docs/latest/html/libraries/
13:17:21 <aristid> edwardk: was that also the thought pattern for removing the Functor constraint on Monad? (afaik it was there once in the past, unless i misunderstood something)
13:17:35 <ksf> aristid, there never was one
13:17:45 <ksf> applicative, too.
13:17:46 <aristid> saml: http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html#v:StateT
13:17:55 <aristid> ksf: hmm
13:17:59 <ksf> personally, I'd slate it for inclusion in base 6
13:18:03 <c_wraith> I thought applicative wasn't a recognized pattern until after haskell 98
13:18:16 <aristid> ksf: well, and Apply ;)
13:18:17 <Younder> And imagine my comment was shut up!
13:18:24 <saml> aristid, that is mtl
13:18:27 <Younder> rotfl
13:18:28 <aristid> saml: yes.
13:18:38 <aristid> saml: that's where it resides.
13:18:38 <monadic_kid> mtl2 == transformers + monads-fd
13:18:49 <aristid> well, ok, it's actually in transformers
13:18:51 <saml> so that's legacy stuff
13:18:59 <ksf> while there's many arguments to be had about a sane num hierarchy, (Functor, Pointed) -> Applicative -> Monad is quite clear.
13:19:01 <aristid> mtl just re-exports it
13:19:06 <edwardk> aristid: there was a thought that everyone was defining their own monads, and that the functor constraint was somehow a hardship on monad authors. personally i think they seriously went the wrong way, but then from reading through the mailing list posts on haskell 98 i find that i back the minority on a LOT of issues that were discussed at that time
13:19:22 <aristid> ksf: edwardk does not want Pointed. :)
13:19:24 <ksf> and then let's add Empty -> MonadZero
13:19:35 <Younder> Finally someone with some  originality.
13:19:37 <edwardk> saml: my new cool stuff?
13:19:59 <ksf> Empty would have empty :: f a and null :: f a -> Bool
13:20:03 <saml> edwardk, no.. i didn't quite follow the new way (that replacing State, StateT)
13:20:10 <Younder> I usually go to my artist friends for inspiration.
13:20:15 <saml> i wanted to know where the new way is implemented
13:20:16 <aristid> edwardk: well it's true that a functor constraint would be slightly annoying
13:20:28 <edwardk> ksf: i'd want Apply over Applicative, and Bind over Monad because they make working with comonads much nicer
13:20:37 <aristid> edwardk: but that's also indicative that there's a missing feature :)
13:20:42 <ksf> aristid, edwardk, the reason for pointed/empty is not that applicative isn't a place for it, but that's its a base data structure classes can be built upon.
13:20:51 <ksf> edwardk, go for it.
13:21:03 <aristid> ksf: how about having a separate Singleton class for data structures?
13:21:12 <ksf> why?
13:21:17 <aristid> ksf: that seems much clearer to me.
13:21:17 <edwardk> aristid: well, you wouldn't have any more burden at use sites, you'd only have to deal with it when defining new monads. as it si, they put the burden on anyone who wants to write code that works with functors, because now they have to provide two versions of EVERYTHING
13:21:40 <ksf> why should return be different from \a -> [a] ?
13:21:55 <ksf> that's both "singleton" aka "return" aka "point"
13:21:55 <aristid> ksf: ZipList would obviously have no Singleton instance, for example. or at least it would not be the repeat one
13:22:13 <edwardk> ksf: the other way is more useful in practice. it is more useful to build up from a semigroup than from a family of distinguished coalgebras with no laws
13:22:39 <aristid> edwardk: ok, true. it results in a higher burden overall.
13:22:48 <ksf> you're not supposed to build up from them, you're supposed to instance them en bloc.
13:22:59 <monochrom> data structures could base on Pointed already. actually containers are most likely Functors
13:23:04 <ksf> ...the point is that it's nice to only require what's needed in generic code.
13:23:08 <edwardk> yes
13:23:15 <ksf> no reason to demand applicative if all you use is pure.
13:23:37 <monochrom> presumably one could write two articles "Pointed as computation" and "Pointed as container"
13:23:50 <ksf> code == data
13:23:55 <ksf> I thought we established that
13:23:59 <c_wraith> I'm really getting sick of writing (Functor m, Monad m) => constriants.  When's that gonna get fixed?
13:24:02 <edwardk> hence why i could accept the existence of Pointed, but you find that if you sort of flip your perspective around to where you work with semigroups and semigroupoids, you find you never need a default element without an operation tied to it
13:24:20 <djahandarie> c_wraith, when you start using liftM instead of fmap ;)
13:24:25 <accel> a :: [A] ; why do I need A to support Eq if I want to do "a == []" ?
13:24:27 <aristid> edwardk: was join vs (>>=) also discussed at the time? (i would never find that in mailing list archives)
13:24:30 <c_wraith> djahandarie: I'm not going to do that to myself :)
13:24:33 <Dae_> Is there a way to prevent haskell strings from reading "\" as the escape char?
13:24:35 <monochrom> "class alias Singleton = Pointed" done :)
13:24:41 <edwardk> you only need Default to define Pointed instances, etc. but there are no useful laws for Default or Pointed, etc.
13:24:50 <mauke> accel: because == is in Eq, and the [a] instance depends on Eq a
13:24:51 <edwardk> their only properties are free theorems anyways
13:25:05 <mauke> accel: solution: don't use ==
13:25:06 <ksf> "Default"?
13:25:11 <accel> mauke: so instead, if I don't have Eq, to use length ... == 0 ?
13:25:13 <monochrom> strings don't read.
13:25:21 <mauke> accel: that's terribly inefficient
13:25:24 <mauke> accel: use null
13:25:31 <edwardk> data-default, provides class Default a where def :: a — which you need when you start providing Pointed instances for crap like Writer.
13:25:32 <mauke> (or pattern matching)
13:25:41 <Younder> don't point that singleton thing at me again!
13:25:48 <monochrom> haha
13:26:02 <Younder> I's a abomination
13:26:06 <ksf> but Pointed would be point :: a -> f a
13:26:12 <edwardk> but the problem is the class annoying to build on because you have no laws relating it to a monoid or semigroup on the same structure
13:26:12 <ksf> that's a difference.
13:26:40 <accel> mauke: nice; thanks
13:26:43 <edwardk> instance (Pointed m, Default w( => Pointed (Lazy.WriterT w m) where ...
13:26:48 <edwardk> er Default w)
13:27:00 <accel> btw, what is naskell's not equal to? I've tried != =/=, ~= ... but none of them is the opposite of ==
13:27:08 <accel> *haskell's*
13:27:14 <edwardk> you need the Default to make that Pointed instance or you run into the self-same problem of needing a Monoid when all you want is a distinguished element
13:27:15 <monochrom> > 1 /= 2
13:27:16 <lambdabot>   True
13:27:53 <monochrom> note that "0!=1" is a theorem in both math and C
13:27:58 <edwardk> but in general the community gets annoyed when you make classes that only provide laws and don't provide operations. making Pointed a separate class and making Apply a separate class means that Applicative becomes a class that only provides laws
13:28:06 <accel> monochrom: nice; thanks
13:28:15 * Kaidelong thinks that we need something better than monad transformers
13:28:30 <xplat> edwardk: this would probably be less of a problem in the Agda community, i imagine
13:28:32 <ksf> edwardk, for my iteratee code I used Nullable, which provides "empty" and "null"
13:28:34 <edwardk> so in practice i choose to elide Pointed entirely, and flip over to Functor => Apply => Applicative
13:28:34 <Trystan> How do I get a Hackage password? Apparently I have a username, but I don't know what my password is.
13:28:34 <accel> > 5 % 2
13:28:35 <lambdabot>   5 % 2
13:28:42 <accel> > 5 `mod` 2
13:28:43 <lambdabot>   1
13:28:48 <ksf> that is, a "monoid without mappend"
13:29:03 <edwardk> ksf: but it also requires a certain level of decidability
13:29:03 <aristid> accel: % constructs a rational number
13:29:06 <monochrom> 5%2 is the rational number 5/2
13:29:07 <aristid> :t 5 % 2
13:29:07 <edwardk> ksf: so its not just that
13:29:08 <lambdabot> forall t. (Integral t) => Ratio t
13:29:13 <aristid> :t (%)
13:29:14 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
13:29:22 <Peaker> ksf, What's the difference between "empty" and "null"?
13:29:31 <accel> > empty == null
13:29:32 <lambdabot>   Ambiguous occurrence `empty'
13:29:32 <lambdabot>  It could refer to either `Control.Applicative...
13:29:34 <monochrom> you should probably not assume haskell is C
13:29:36 <edwardk> ksf: Monoid m => Monoid (a -> m), but I can't do that with your Nullable
13:29:37 <ksf> empty is the empty element, null tests for it.
13:29:38 <Younder> your getting kinda queer with that lambda bot.
13:29:46 <xplat> edwardk: Apply is what again?  a functor with applicative's <*> but no pure?
13:30:03 <edwardk> xplat: yes, turns out lots of comonads admit an Apply instance
13:30:15 <accel> monochrom: old habits die hard
13:30:16 <edwardk> xplat: so you wind up with <*> and extract, but not pure.
13:30:30 <accel> monochrom: seeing parsec work is fricking magic
13:30:31 <bradleyayers> is it possible to type in a function that uses guards into ghci?
13:30:31 <ksf> empty is definitely way too high up the hierarchy in Alternative
13:30:40 <accel> monochrom: it's almost like I'm describing what the file format is; rather than describing how to parse it
13:30:46 <edwardk> xplat: similarly extend provides you with the (m a -> b) -> m a -> m b — but not the m a -> b operation
13:30:48 <bradleyayers> and if so, how :)
13:30:50 <Younder> empty is good
13:30:57 <ksf> edwardk, oh.
13:31:10 <edwardk> xplat: that is useful because it gives you comonad-like machinery for things straight out of the prelude like []
13:31:13 <ksf> well, then keep pointed but don't make it a requirement for Apply?
13:31:24 <Peaker> ksf, ah, interesting...
13:31:43 <Peaker> ksf, but surely we need to have mzero alone in a class, and then separately have "null"?
13:31:45 <ksf> some instances might need it, but I bet not all.
13:31:51 <Peaker> s/mzero/mempty
13:31:53 <Younder> Never declare something until you have use of it.
13:31:55 <aristid> edwardk: you only defined lifts for Apply up to liftF3.. *just found out*
13:31:57 <edwardk> ksf: thats why i packaged 'pointed' as off to the side and unrelated to any of the code i'm using for my more generic typeclass hierarchy
13:32:10 <Peaker> Younder, Yagni
13:32:12 <monochrom> that is a sign of a good haskell lib. lets you write almost declaratively.
13:32:23 <edwardk> aristid: mainly coz i don't need any more and nobody asked for me ;)
13:32:27 <Younder> on point at point.
13:32:28 <edwardk> er for me to add them
13:32:30 <monochrom> even then, we perfectionists still think parsec is not declarative enough :)
13:32:35 <ksf> Peaker, I was unable to come up with a reason where one couldn't say that an element is empty when it's provided in the same instance...
13:32:37 <aristid> edwardk: add them! :P
13:32:42 <aristid> up to infinity
13:32:49 <edwardk> aristid: submit a patch ;)
13:32:53 <Peaker> bradleyayers, ghci supports values like you'd have them in a file.. defining types/classes/instances, not so much
13:33:03 <aristid> edwardk: an infinitely sized patch? :D
13:33:14 <edwardk> aristid: sure. i'll apply it after it arrives
13:33:17 <blueonyx_> why does compiling Text.XmlHtml.HTML.Meta take like forever? 
13:33:17 <Peaker> ksf, The (a -> b) Monoid?
13:33:23 <aristid> edwardk: hah
13:33:26 <Kaidelong> http://en.wikibooks.org/wiki/Haskell/do_Notation
13:33:28 <bradleyayers> Peaker: so,  i can't enter a function that uses guards?
13:33:35 <bradleyayers> (into ghci prompt)
13:33:36 <Peaker> bradleyayers, You can
13:33:42 <Kaidelong> The "desugared" thing with the bunch of wheres
13:33:44 <Kaidelong> makes me sad
13:33:55 <xplat> this hierarchy is already reaching the point where without laws you'd get the same result from free overloading
13:33:58 <ksf> Peaker, I hold the firm belief that (->) is evil.
13:33:58 <Peaker> bradleyayers, You have to use "let" for bindings though, even of functions
13:34:03 <mjrosenb> :hoogle [a] -> [(a,[a])]
13:34:03 <Peaker> bradleyayers, let f x | x == 1 = 5
13:34:03 <edwardk> aristid: if you're sneaky you might be able to encode it with a droste effect or something ;)
13:34:08 <Peaker> ksf, hehe
13:34:10 <mjrosenb> @hoogle [a] -> [(a,[a])]
13:34:10 <lambdabot> Data.Char readLitChar :: ReadS Char
13:34:11 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
13:34:11 <lambdabot> Prelude reads :: Read a => ReadS a
13:34:17 <edwardk> xplat: not quite, i get useful laws at each point
13:34:27 <edwardk> xplat: this is why i wanted the semigroupoid machinery
13:34:30 <Peaker> ksf, I think every time people put more than one fundamental thing in a class, they eventually regret it :)
13:34:30 <bradleyayers> Peaker: ah okay, i was trying to put a new line before the first guard
13:34:44 <Peaker> bradleyayers, In GHC 7, you can use :{ to start a multi-line thing in ghci
13:34:53 <ksf> well, yes.
13:35:03 <edwardk> xplat: Bind is the constraint that kleisli composition forms a semigroupoid. Apply is that static arrow composition is a semigroupoid, Extend is that cokleisli composition is a semigroupoid
13:35:11 <bradleyayers> Peaker: i'll upgrade :) thanks
13:35:14 <edwardk> that associativity condition is strong enough to write combinators
13:35:25 <edwardk> arbitrary overloading does not provide you enough
13:35:28 <mightybyte> blueonyx_: text.xmlhtml.html.meta takes awhile because it has a big list of constants that seems to interact in a slow manner with GHC
13:35:50 <mightybyte> blueonyx_: You should have seen it before...it took like 5 minutes
13:35:56 <mauke> Peaker, bradleyayers: that also works in 6.10.2
13:36:06 <Peaker> mauke, oh I thought that was new
13:36:33 <blueonyx_> mightybyte: i even run it on a ramdisk, but ghc didnt disksleep, neither consume cpu time, but it's finished :)
13:36:39 <bradleyayers> mauke: great
13:37:07 <mjrosenb> let parts x = zipWith (\h (f:t) -> (f,h++t)) (inits x) (tails x) in parts [1..3]
13:37:12 <edwardk> xplat: that argument is why i sought to kill or at least reduce the importance of pointed
13:37:12 <mjrosenb> > let parts x = zipWith (\h (f:t) -> (f,h++t)) (inits x) (tails x) in parts [1..3]
13:37:12 <Younder> Peaker, Never heard of Yagni
13:37:14 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2]),*Exception: <interactive>:3:23-42: Non-exhau...
13:37:15 <ksf> so what we should take from this is that we need a separate typeclass for every axiomatic function, not just concept, and just use them as a mix+combine pool?
13:37:25 <xplat> edwardk: hence why i added the qualification 'without laws'.  with laws it's still kind of useful, without it'd just be an irregular system of abbreviations ...
13:37:28 <Peaker> Younder, YAGNI = You ain't gonna need it. It's what you said
13:37:36 <edwardk> xplat: yeah
13:37:37 <mjrosenb> is there any simple way to do that, but without attempting to process the last element?
13:37:37 <Peaker> Younder, Write stuff when you need them, not before
13:37:53 <Younder> ahh
13:38:00 <mightybyte> blueonyx_: Yeah, we don't know exactly what's going on there.
13:38:05 * ksf thinks it's the type that should define what laws hold, not so much the typeclass.
13:38:07 <edwardk> YAGNI and I don't get along very well ;)
13:38:14 <bradleyayers> Peaker: how do i exit :{ mode
13:38:24 <Peaker> bradleyayers, :}
13:38:26 <ksf> if you really want a thing that guarantees laws, do another class on top of the primitive ones.
13:38:33 <Peaker> bradleyayers, sad face needs to be ended with a happy face :)
13:38:38 <bradleyayers> ah cool
13:38:58 <ksf> where you just say return = point , and mean "I vow that this is an identity"
13:39:20 <ksf> </softwaredesignrant>
13:39:29 <edwardk> ksf: not a fan of that approach, it really explodes the number of classes you need to implement. they go from linear in the number of operations to 2^n.
13:39:31 <Peaker> ksf, I think it's better to have "Empty classes" that are just evidence of laws holding
13:39:39 <Younder> Peaker, I don't remember saying that. But I totally concur.
13:39:52 <Peaker> <Younder> Never declare something until you have use of it.
13:39:52 <edwardk> ksf: in practice when n ~ 20 or so even in my existing code, i'm not willing to do that
13:39:53 <ksf> Peaker, yes, or that.
13:40:02 <dino-> hm, not sure why I'm getting error from haddock now that it's not the same ver as ghc.
13:40:17 <ksf> it'd be nice not to require undecidable instances in the standard library, though.
13:40:20 <Peaker> ksf, if we had higher-ranked class constraints, we could have:  class (forall a. Monoid (m a), Monad m) => MonadPlus m where {}
13:40:20 <dino-> Far as I know, ghc didn't move from 6.12.3 during my upgrades yesterday/today.
13:40:25 <edwardk> peaker: i used to, but i've switched away from that style
13:40:26 <dino-> Doesn't haddock come with ghc?
13:40:32 <Peaker> ksf, the instance would be evidence of the laws linking return and mzero/etc
13:40:38 <Peaker> ksf, (in this case mempty)
13:40:47 <ksf> edwardk, and if there would be more concise syntax for them?
13:40:55 <ksf> also, you wouldn't implement all 20 for all types.
13:41:03 <Peaker> edwardk, because of combinatorial explosion?
13:41:33 <Peaker> edwardk, but if you have some laws linking methods of A to B, you'd have AB as evidence of that.  Same for BC, CD,  it should be linear, not cartesian?
13:42:15 <Peaker> ksf, in the above case, we would have a mountain of libraries for Monoids available for MonadPlus too
13:42:25 <Peaker> (instead of duplicating them for mplus)
13:44:02 <dino-> Oh weird, I have two haddock binaries. /usr/bin/haddock and /user/local/bin/haddock
13:44:09 <ksf> edwardk, your code might just be an extreme example because it's, no offense meant, bloody general.
13:44:24 <monochrom> XQuery comments are enclosed in smileys (: and :)
13:44:30 <edwardk> peaker: the combinatorial explosion. in haskell its cartesian. i have to name every point in the lattice
13:44:33 <xplat> hm, do higher-order class constraints like that fall into the decidable class of hereditary harrop theories?
13:44:59 <edwardk> in scala or what have you i can reduce that but i find i wind up having to name the points in the lattice as well to deal iyt things like products of things from the lattice, etc.
13:45:41 * ksf wonders whether we stumbled across another expression problem
13:45:51 <edwardk> ksf: well, its a symptom. i don't like adopting a practice that means i can't finish writing boring boilerplate, and i figure i have a higher tolerance for writing boring boilerplate than most anyone ;)
13:46:02 <xplat> it does kind of sound like the expression problem
13:46:06 <Peaker> edwardk, do you have laws linking everything to everything?
13:46:20 <Younder> Peaker: you like my langyage. Gormula
13:46:27 <edwardk> peaker: 'almost'. i fib in 2 places
13:46:40 <xplat> edwardk: if you had a higher tolerance for writing boring boilerplate than anyone you'd be writing xml schema validators in java
13:46:52 <Younder> Peaker: you like my language. Formula
13:47:14 <edwardk> peaker: i used to have Apply and Comonad together have a subclass ComonadApply that provided the property that you have a symmetric semimonoidal comonad, but i gave up on that class because it was boilerplate
13:47:16 <monochrom> no, in cobol
13:47:33 <edwardk> xplat: in this particular community ;)
13:47:47 <xplat> oh, maybe
13:48:04 <Peaker> Younder, is it like Haskell?
13:48:12 <Younder> Peaker: Wanna join my team?
13:48:24 <Peaker> Younder, I'm overcommitted to too many projects already, sorry
13:48:54 <Peaker> edwardk, It's nice to be able to say you need the laws adhered
13:48:58 <edwardk> peaker: the other case of missing laws is when it comes to Alt and Apply. I used to have Alt require Apply as a superclass, which gave me the semineariring-like relationship between them, but i weakened it to allow Alt to work on arbitrary Functors lest i wind up with 3 more names for crap
13:49:03 <Peaker> edwardk, I don't know if it's "boilerplate" really
13:49:03 <copumpkin> edwardk: pm :)
13:50:01 <Peaker> monochrom, do you know cobol?
13:50:43 <monochrom> no, except "multiply x by y to z" for mocking cobol
13:50:51 <edwardk> peaker: i understand your point, i follow that practice in my own language, but here in haskell, the design of the language unfortunately favors a few well chosen abstractions over accuracy as much as it pains me
13:51:19 <Younder> Peaker: Well it is just another functional language panellized  and brought to justice through objectification. Nothing of interest to YOU.
13:51:45 <Younder> rotfl
13:51:47 <edwardk> and as for Alt/Plus and how they relate to Apply/Bind/Applicative/Monad there is a more glaring problem, and that is that in reality it isn't 3 classes you need. 
13:52:16 <edwardk> its that you need 'Or' vs. 'Plus', so you wind up with something like 12-24 depending on how you count
13:52:21 <Peaker> Younder, Are you young or just angry? :)
13:52:30 <Peaker> Younder, What do you mean "objectification"?
13:52:31 <edwardk> i'm not defining 24 instances just to say that i have a monadplus. 
13:52:38 <edwardk> 'fuck that'  ;)
13:52:46 <edwardk> fix the language and i'll consider it
13:52:46 <monochrom> haha
13:53:09 <Younder> neither. I am 43 and still laughing
13:54:18 <ksf> 24?
13:54:23 <edwardk> in the meantime i'm willing to fib a little bit by requiring the extralogical constraint that if you have both an instance Foo for x and an instance Bar for x that they are defined consistently such that certain laws hold between them. i'm willing to state those laws, but in general we already require that for instance the Applicative is consistent with the monad
13:54:55 <ksf> well, I wouldn't mind having a compiler that can infer <*> (as opposed to ap) from bind.
13:55:14 <ksf> put djinn into the language.
13:55:32 <edwardk> ksf: is your <|> operation left distributive or does it catch, so you really have two completely different operations that look kinda the same, this is why we can't have nice things when it comes to Applicative instances for MaybeT and EitherT.
13:55:48 <Peaker> ksf, I want djinn in my IDE, instead :)
13:55:57 <Peaker> ksf, and hoogle-based completions, of course
13:56:30 <edwardk> ksf: then there are other interactions between that and Apply/Bind, etc. that by the time you get done you then need to sit down and prove which ones are implied by other properties to whack some points in the lattice, but the number of interactions is very large
13:57:01 <Younder> Peaker, So yo never heard of sarcasm?
13:57:16 <Peaker> Younder, not a big fan, most of the time :)
13:57:18 <ksf> well, my answer to that is a snotty and plain "premature generalisation is the root of all evil"
13:57:31 <Peaker> ksf, Haskell is all about premature generalization :)
13:57:56 <edwardk> ksf: and my answer is that its just silly. so i provide a simple mechanism by which i pay proportional to the number of operations that i care about
13:57:57 <ksf> yes, she's so beautiful it's easy to be premature.
13:58:12 <Younder> Peaker, Anyhow Formula is real.
13:58:19 <edwardk> modulo the cost of interoperating with the existing class hierarchy
13:58:30 <Peaker> edwardk, If you look at Ord, for example, you might have instances for using with Map, that don't really work mathematically and may break some laws
13:59:10 <Peaker> edwardk, but that seems to point that maybe your approach is a good one, and we just need a different class for arbitrary Ordinal and mathematical Ordinal
13:59:15 * ksf is strongly opposing the idea of mathematicians taking over haskell
13:59:46 <Peaker> Younder, what's "objectification"? 
13:59:58 <edwardk> ksf: i'm strongly opposed to so called pragmatists messing up haskell as well
14:00:10 <ksf> well, then we agree. that's nice.
14:00:12 <edwardk> ksf: we can all live in delightfully creative tension
14:00:17 <dino-> Oh boy am I ever in ghc-pkg hell
14:00:17 <ksf> because I don't want me to mess it up.
14:00:54 <edwardk> ksf: the stuff i've been writing is more to 'be the change i want to see in the language', by simply acting as if the class hierarchy i prefer exists
14:01:27 <Younder> Peaker, It's the creation of a OO system.
14:01:29 <monochrom> @quote monochrom premature
14:01:30 <lambdabot> monochrom says: premature generality is the root of OOP
14:01:31 <edwardk> ksf: and i've gone out of my way to deliberately scaffold things in tiers so that the easy parts remain haskell 98, and i build to the progressively more interesting stuff on top
14:02:06 <edwardk> and insufficient generality is the root of 'design patterns' ;)
14:02:08 <ksf> ...and in the year 3000, students will be lectured about how, finally, in the year 2900 the divide between Whackywank.Prelude and AbstractNonsensical.Prelude has finally been overcome.
14:03:29 <edwardk> ksf: you don't have to use any of the code i write
14:03:38 <Younder> Peaker, No thats absolutely not true since I hate OO.
14:04:17 <ksf> edwardk, I probably appreciate it more than any other coder in a 20 mile radius.
14:04:34 <djahandarie> Depends on where you live :)
14:04:41 <ksf> well, except uwe schmidt himself, possibly.
14:05:10 * hackagebot cryptocipher 0.2.5 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.5 (VincentHanquez)
14:05:16 <gwern> > (1000000000) / (60 * 60 * 24)
14:05:17 <lambdabot>   11574.074074074075
14:05:27 <ksf> never heard him lecture haskell.
14:05:49 <Younder> Peaker, But part of the rules have ben dictateted for me
14:06:29 <xplat> @src ap
14:06:29 <lambdabot> ap = liftM2 id
14:06:40 <ksf> 20 miles easily includes all of hamburg
14:06:42 <xplat> @src liftM2
14:06:42 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:07:03 <xplat> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:07:03 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
14:07:25 <ksf> ...but none of the european haskell hubs, I would'nt really call the FH Wedel one.
14:07:40 <Younder> Peaker, But part of the rules have been dictated for me.
14:07:48 <copumpkin> edwardk: should we get going?
14:07:53 <edwardk> so you're saying you wouldn't get much attendance at a hamburg haskell user group
14:07:56 <edwardk> ya
14:07:59 <xplat> the relation that could appear between some comonads and apply seems obscure to me
14:08:09 <edwardk> anyways, off to kidnap sclv for food
14:08:16 * frerich would appreciated a HH Haskell UG
14:08:29 <Younder> hamburgers are4 cool ;)
14:08:44 <Younder> rotfl
14:09:04 <ksf> dunno, I'm born in Hamburg, but other than that it's a foreign country which starts 1km from here.
14:10:39 <ksf> as far as the IT industry goes, most of it is either consulting non-it companies, a network carrier and a decently-sized heap of game companies.
14:11:12 <ksf> berlin seems to be all the rage nowadays, which I just don't get, their beer sucks.
14:12:39 <ksf> ...utrecht is some 400km away.
14:13:43 <Younder> ksf: You need to come to Norway. The beer is god And the IT industry ROCKS!
14:14:02 <ksf> ha!
14:14:11 <aristid> Younder: the beer is extremely expensive tho. so it better be good ;)
14:14:23 <blackdog> i've never thought to look for divinity in a frothy glass
14:14:27 <ksf> the moment I'd get a job there they'd ask me to *bring* beer because it's like 10 times more expensive there.
14:14:31 <xplat> it's not good at all, it's just god
14:14:49 <Younder> so it is at 500 000 a year you can afford it
14:14:57 <frerich> As far as the IT industry goes, pretty much any major european city (and presumably every major city around the world) has its share of interesting small-medium sized companies with good work conditions and interesting problems.
14:15:07 <xplat> 500 000 of what?
14:15:15 <monochrom> of beers
14:15:30 <frerich> Heck, even denmark has interesting companies.
14:15:41 <monochrom> In ancient Rome they paid you salt. In modern Germany they pay you beer.
14:15:46 <ksf> > 500000/7.7
14:15:47 <lambdabot>   64935.06493506493
14:15:48 <xplat> Norway
14:15:52 <ksf> > 500000/7.7/12
14:15:53 <lambdabot>   5411.255411255411
14:16:02 <ksf> that's before taxes, isn't it?
14:16:20 <Younder> 500 000 kroners is about 50 000 pounds
14:16:20 <aristid> the german government needs a LOT of beer.
14:16:21 <dino-> Sounds like somebody needs to open a brew pub in Norway.
14:16:29 <xplat> 500000/365.25/24/60
14:16:33 <dark> aristid, o.o
14:16:38 <xplat> > 500000/365.25/24/60
14:16:39 <lambdabot>   0.9506426344208685
14:16:42 <ksf> 7.78 kroner buy you an euro
14:16:42 <aristid> Younder: why do you convert to pounds when explaining to germans? :P
14:16:46 <blackdog> dino-: massive taxes, i think
14:16:56 <frerich> the total cost of living in most of Norway is much higher than in e.g. Germany; in particular Oslo is a helluva lot more expensive. Which explains the seemingly high salaries.
14:16:58 <xplat> so to drink up all your pay, you'd have to do a beer a minute even while asleep :)
14:17:11 <monochrom> haha
14:17:16 <phrackSipsin> does anyone know what kind of string inet_addr expects?
14:17:19 <dino-> ksf: Also, still on floor from Whackywank.Prelude comment.
14:17:30 <aristid> phrackSipsin: doesn't the manpage explain?
14:17:43 <phrackSipsin> hmmm, i'm on hackage docs
14:17:59 <Younder> aristid, yes, rotfl
14:18:12 <phrackSipsin> where would I find the manpage
14:18:30 <ksf> http://www.manpagez.com/man/3/inet_addr/
14:18:36 <ksf> in case you don't have a terminal
14:18:45 <monochrom> inet_addr expects "192.168.1.1"
14:18:45 <phrackSipsin> ah thanks
14:19:02 <phrackSipsin> oh, so it won't take "localhost" i assume?
14:19:03 <monochrom> there is xman if you don't have a terminal
14:19:16 <phrackSipsin> thanks
14:19:18 <ksf> phrackSipsin, nope, that's a hostname.
14:19:18 <Younder> A dollar i 7 kr a euro is about 11 kr.
14:19:19 <aristid> phrackSipsin: you seem to use ubuntu. man inet_addr in a terminal.
14:19:42 <phrackSipsin> okay, I didn't realise that worked for language libraries
14:19:49 <dark> The inet_addr() function converts the Internet  host  address  cp  from IPv4  numbers-and-dots notation into binary data in network byte order.
14:19:56 <dark> you need something like gethostbyname
14:20:20 <ksf> ...or just use 127.0.0.1 or ::1
14:20:31 <Younder> loopback
14:20:38 <ksf> yes.
14:20:41 <phrackSipsin> I'm just trying to work out how to use some supercollider bindings that require as input inet_addr 
14:20:52 <phrackSipsin> but thanks for the suggestions
14:20:57 <ksf> I've got an elegant proof that loopback is equivalent to localhost after half a bottle of wine.
14:21:25 <monochrom> not beer?
14:21:26 <ksf> ...but scandinavian beer is too expensive to contain it.
14:21:49 <ksf> monochrom, usually, yes, but not always.
14:23:22 <ksf> the danes are going to build the lolland <-> fehmarn tunnel soon, though, so you can buy even more alcohol to the litre fuel in the future.
14:24:33 <dahankzter> I have been on Scala seminars all day today and i cant believe that they just didnt contribute to Haskell on the JVM instead. Loads of similar stuff although i am somewhat new to both :D
14:25:00 <ksf> haskell on the jvm would be an adomination.
14:25:07 <ksf> ...not because of haskell, but the jvm.
14:25:08 <Twey> IIRC Haskell isn't possible to implement nicely on the JVM
14:25:27 <Younder> ksf: true norwegians puke it all the time ;)
14:25:27 <ksf> yep, you'd need to trampoline.
14:25:30 <dahankzter> maybe but still, so many syntatic similarities
14:26:06 <dark> dahankzter, is it lazy?
14:26:13 <ksf> the one basic difference between java and the jvm is that the latter has function-local goto. which has to obey stack discipline.
14:26:16 <othiym23-2> dark: it can be lazy, but it's strict by default
14:26:38 <dahankzter> @dark ish, there are constructs to make it so but not out of the box
14:26:39 <lambdabot> Maybe you meant: arr ask part yarr
14:26:47 <ksf> ...which you can easily emulate with labeled loops and next etc.
14:27:01 <dark> i suspect it is like ml, then. some functional programming, but with impure functions
14:27:18 <dark> also, are functions curried?
14:27:28 <othiym23-2> dark: it has both imperative and purely functional semantics
14:27:37 <ksf> so, in the end, it dosent' matter whether you target java or the jvm as a backend. the only advantage is that instead of a total of 3 million known bugs, getting rid of javac means you only have to deal with 1 million.
14:27:44 <dino-> dark: They can be, but it's a little annoying in that you have to know you want that ahead of time, write the function 'special'
14:28:16 <othiym23-2> dark: it's basically like OCaml but with a more Java-like syntax and more of an emphasis on integrating OO concepts into a functional environment
14:28:23 <dark> also, does it has data definitions with automatic pattern matching?
14:29:10 <othiym23-2> dark: yes to pattern matching, but its type system is based on a purified version of Java's generics
14:29:14 <dino-> dark: It does have this thing they call 'case classes' which lets you write a far sparer notation that gets hammered into a small class hier for the ADT ..
14:29:23 <othiym23-2> it's not a bad design, but it's not as flexible as Haskell's, by any means
14:29:26 <dino-> And then that is deconstructable by their pattern matching.
14:29:33 <Younder> +ksf: You bastard!
14:29:42 <Younder> rotfl
14:29:58 <dark> I think that pattern matching, curried functions, and ml-style polymorphism dominates most code on haskell and ml (both sml and ocaml) i see
14:30:08 <anderbubble_> IBM used a stock photo of me standing next to Intrepid (Argonne's Blue Gene/P) on Jeopardy: http://www.youtube.com/watch?v=4nt-abT8gKw
14:30:14 <anderbubble_> Woo.
14:30:15 <othiym23-2> I personally think that Clojure is a much more interesting JVM target
14:30:24 <othiym23-2> but Clojure's emphasis on STM is less interesting to me
14:31:19 <Younder> Well if you don't want to spend time debugging code. Try Haskell.
14:31:29 <dahankzter> As a functional noob i find haskell instinctively attractive but scala feels like a hack to bend java which i know very well into something useable
14:31:48 <othiym23-2> dahankzter: eeeeeenh, yeah and no
14:31:58 <dark> Younder, i have little ability to debug code i don't understand, but, i promise to improve it
14:32:27 <dahankzter> well, maybe its just now that im kind of sick of java and the jvm as a whole
14:32:34 <othiym23-2> the things they've done to make the Java class library useful in Scala is impressive, but the criticism I see leveled at it most frequently (and which I mostly agree with) is that the design is rife with non-orthogonal design choices
14:32:44 <dino-> Still, if you absolutely have to use the JVM, it's nice to have all the things Scala offers. ADTs, closures..
14:33:08 <dahankzter> i agree, its really nice compared to Java etc
14:33:10 <Twey> Well, it's better than writing Java
14:33:13 <Twey> Heh
14:33:16 <dahankzter> :)
14:33:17 <othiym23-2> like, if you look at Scala's implementation of the Actor model, it can be EITHER reactive OR thread-based, and that kind of having it both ways everywhere pervades the language
14:33:19 <dino-> othiym23-2: yes
14:33:35 <dino-> I was able to use Scala to make an Android app.
14:34:24 <othiym23-2> dino-: that's why I see people using stuff like F# and Scala now -- they can build a whole platform, including mobile, on one language / environment
14:34:29 <xplat> othiym23-2: to be fair your example mostly relates to limitations of the existing Java libraries that make it impossible to abstract over threaded/async
14:34:31 <othiym23-2> if I end up using Scala, that will be why
14:34:34 <dino-> https://market.android.com/details?id=spectrahex.demo.ui
14:34:59 <othiym23-2> xplat: if you read the papers on Scala's Actor implementation, you'll see that it goes deeper than that
14:35:23 <xplat> othiym23-2: i've read the papers and i still don't see what you mean
14:36:05 <othiym23-2> it's a fine design and gets you most of the useful bits of Erlang running on the JVM (minus, of course, the OTP, which is where the real power of Erlang kicks in), but it doesn't feel that crisp
14:36:40 <othiym23-2> xplat: the reactive model is single-threaded, like Node.js, so it's not so much about the JVM but about the underlying model
14:39:35 <xplat> othiym23-2: the reason that exists is that JVM threads are heavyweight both semantically (limits your choice of libraries to use in your actor) and operationally but the 'reactor' model is limited by no true concurrency by itself and by the need for semi-explicit trampolining
14:39:42 <ksf> Younder, just out of interest, how expensive is more pricey stuff, like decent (say 12yo) to good whisky?
14:40:00 <ksf> is the tax based on actual alcohol content or price?
14:40:53 <xplat> othiym23-2: 'reactor' could be simpler and threads could be a special case of it, if only JVM would collect dead frames on the stack, or at least have proper TCE
14:41:20 <othiym23-2> xplat: that's true, but that doesn't exactly explain why the Actor library contains both "receive" and "react"
14:41:44 <othiym23-2> the latter is an explicit design nod to traditional single-threaded event loops, a la Node.js
14:42:08 <xplat> othiym23-2: try to write something that functions as both "receive" and "react" and it will become obvious
14:43:02 <xplat> and no fair if it crashes after running an hour
14:43:34 <othiym23-2> xplat: I know that it tries to works around weaknesses in the JVM, but a lot of Scala is Odersky thinking hard and making lemonade out of the JDK's lemons
14:44:04 <othiym23-2> a lot of thought has gone into how best to deal with that -- I know this because he lets everyone know in every paper he writes about Scala ;)
14:44:32 <Younder> Haskell is pretty much the pidestal of functional programming.. And if you can't handle that... Well you aint worth nothing-
14:44:59 <dark> othiym23-2, JDK?
14:45:43 <othiym23-2> dark: yeah, Scala's more than just a language, it's an attempt to create a functional programming environment that grapples with all the crazy baggage of Java *and* its class library
14:45:49 <periodic> Bah, I just found out jQuery's map function is actually concatMap...
14:46:03 <dark> so one can use java libraries in scala?
14:46:08 <othiym23-2> dark: and yeah, there's the .Net port, but it's clear most of the design energy was around the JDK
14:46:14 <xplat> periodic: just like perl's!
14:46:25 <periodic> xplat: I didn't know Perl had a map function.
14:46:28 <othiym23-2> dark: yes, and Scala's class library is somewhat isomorphic to Java's
14:46:47 <othiym23-2> class hierarchy, I mean
14:46:48 <Arnar> evenin' (or whatever fits you)!
14:46:59 <sipa> it has a filter function as well, called grep
14:47:02 <xplat> it's easier to map with only concatmap than to concatmap with only map, though ... just make singletons
14:47:32 <accel> I had a hash table; should I use Data.Map, or something else I should read up on?
14:47:35 <accel> window 3
14:47:52 <Arnar> I looking to pick a web framework for a small webapp.. but haven't kept up with the developments
14:47:54 <Younder> ksf: a chivas regal is about 120 euro
14:48:14 <Arnar> snap and yesod look nice.. but is there any single one emerging as "standard"?
14:48:17 <xplat> periodic: unfortunately for perl although it has map and filter it doesn't have a true reduce/fold, only foreach :(
14:48:23 <Younder> ksf: a 1200 kr
14:48:34 <parcs> Arnar: no
14:48:36 <ozataman> Arnar: both are under heavy development
14:48:37 <periodic> xplat: Now that I know haskell I'm lost without good map and fold functions.
14:48:51 <xplat> and yes, it calls filter grep, despite that a regex is only one of many things you can filter on
14:49:09 <Arnar> ozataman, parcs: thanks.. any suggestions for other things I should evaluate?
14:49:24 <othiym23-2> and Ruby's map and select / filter are based on Perl's
14:49:43 <ksf> 23/100/200 for 12/21/25 here
14:50:11 <ksf> 50 for 18
14:50:17 <ozataman> Arnar: there is also happstack, which has been around for a long time. my personal, and probably biased, suggestion is go for Snap :-)
14:50:28 <parcs> Arnar: i suggest using the fastcgi or direct-fastcgi package for small webapps
14:50:32 <dark> xplat, but one can write one nonetheless right?
14:50:35 <Arnar> ozataman: yes.. happstack, while it seems stable, also seems a bit oldfasioned
14:50:49 <Arnar> parcs: I'm looking for a framework, with routing and templates etc
14:50:56 <xplat> i think the reason perl doesn't have fold built in is it's too awkward in perl to construct tiny lambdas
14:51:14 <dark> with high order functions and car / cdr or pattern matching on lists, every language has fold
14:51:35 <Arnar> ozataman: but I agree that snap looks very nice (I have a lot of bg in python webstuff)
14:51:35 <Younder> ksf: But mostly  alcohol and cigarettes are expensive.
14:51:37 <dark> hm o.o
14:51:57 <xplat> grep and map cheat by using $_ to hold the arg, and sort uses $a and $b for its two args but i can completely see why even lwall wouldn't want to duplicate that decision
14:51:59 <ksf> .5 l moskovskaya? 8 euros here
14:52:06 <dark> xplat, so it's more like, fold wouldn't be usable, if it were there?
14:52:18 <dark> maybe perl 6 fixes that?
14:52:27 <Younder> ksf: Electronics are CHEAP!
14:52:59 <xplat> yes, perl6 fixes that with the $^foo and 'pointy' notations for small lambdas
14:53:01 <ksf> ...there not really expensive here, either.
14:53:11 <ksf> they're, even.
14:53:20 <Dae_> Younder, well... fruit and vegetables are quite expensive in Norway too
14:53:43 <dark> Dae_, are them imported?
14:53:45 <ksf> that far north you're supposed to eat more meat, anyway.
14:53:56 <dark> hm o.o
14:53:57 <ozataman> Arnar: we're also working quite actively on various snap extensions like authentication, db backends, simple i18n, etc if these are things you'll need
14:54:05 <Younder> When you live on 500 000 kr a year who cares
14:54:29 <xplat> and not only is the proposed perl6 lib full of HOFs, they even have something called 'metaoperators' to create maps and folds and zipwiths over any binary operator
14:54:36 <Younder> It can be expensive and you can still afford it
14:54:37 <dark> Younder, and a kr is worth how much US$?
14:54:41 <Arnar> ozataman: great.. I have a feeling though that if I go with Snap, I'm going to end up contributing (if that is a thing you need :)
14:54:44 <Dae_> Younder, good point
14:54:52 <accel> http://hpaste.org/44039/documentclass <-- haskell jsut asys parse error in pattern; but doesn't tell me wy ... what is the parse error?
14:54:54 <xplat> by adding just 1 or 2 characters
14:54:58 <Younder> dark, a dollarais abot 6 kr
14:55:17 <othiym23-2> xplat: and Perl6 is only 10 years old, with 0 robust implementations!
14:55:17 <Younder> dark, a dollar  is about 6 kr
14:55:19 <accel> n/m, fixed
14:55:30 <ozataman> Arnar: absolutely! that is how it started for many of us. the extensions concept (which we plan on evolving, so the API will likely change over time) is meant to stir this kind of contribution from the community
14:55:41 <Arnar> ozataman: out of curiosity.. what is the gap you are filling with snap? i.e. what do you think others are lacking?
14:56:07 <Younder> othiym23-2, The only robust one written in Haskell :)
14:56:19 <monochrom> hehe accel :)
14:56:33 <dark> Younder, so 500k kr / year seems like really a lot for brazilian standards õ.o
14:56:35 <accel> monochrom: i was stuck on this error for like 10 seconds; not funny :-)
14:57:13 <ksf> Younder, you still didn't say whether that's before or after taxes
14:57:14 <monochrom> to some extent I dislike needing parentheses in "f (x:xs) =" too
14:57:15 <xplat> othiym23: perl6 isn't a practical solution for anybody, and may never be, but at least it shows perl partisans can see the deficiencies of perl5
14:57:42 <ozataman> Arnar: Well, that's a tough one to answer publicly :-) I guess in short, we didn't agree with the approach/design of other existing frameworks and wanted a high quality, fast, clean, well-tested, well-documented framework
14:57:43 <mar77i_> how can I define data :: types -> in -> ghci ?
14:57:49 <Younder> dark, 500 000 is a normal
14:57:57 <othiym23> xplat: for sure, and it's nice to see it getting more expressive and closer to its functional core, even if it does bring along a barge of new line noise in the process
14:58:10 <dark> Younder, like "middle class"?
14:58:14 <Younder> about 36 % tax
14:58:15 <Dae_> ksf, that would be before taxes
14:59:08 <ksf> I wouldn't say that's higher that a typical german IT income
14:59:14 <Arnar> ozataman: I see. Are you seeking inspiration from some non-haskell framework in particular? And by that I mean the overall philosophy rather than technical details.
14:59:38 <Younder> not worse than other counties in Europe
14:59:45 * ksf .oO( I need to drink more, so I don't realise anymore my spelling deterioated )
15:00:02 <mar77i> wait, that may have been a dumb question, do I have to, and if so, when?
15:00:05 <xplat> from my casual inspection it feels like snap is as much about getting away from the inspiration of non-haskell frameworks as following them (using iteratees, fr.ex)
15:00:24 <mightybyte> Arnar: Snap took some inspartion from Lift, some from Happstack...
15:00:25 <ozataman> Arnar: Hmm, I wouldn't claim that one that has overriding inspiration to be honest.. not sure what the other team members would say
15:00:32 <Younder> Is my spelling that bad?
15:00:37 <ksf> nope, mine.
15:00:50 <dark> mar77i, i think ones does that way: define in a file, then :load file.hs
15:01:08 <ksf> I wouldn't mind norway, btw, but if I was given the choice between any scandinavian country, I'd take iceland.
15:01:20 <Dae_> Younder, you only pay 36% tax?? Really? I thought it was around 50%
15:01:21 <xplat> i mean, uri routing is there, but that doesn't come from anywhere in particular.  i didn't get as far as facilities for data storage though
15:01:21 <Arnar> ksf: *like*
15:01:25 <mightybyte> xplat: To some extent you're right.  But there are also plenty of things that non-haskell frameworks did right that don't need to be changed in the context of Haskell.
15:01:31 <Younder> Dae_, nop
15:01:33 <ozataman> xplat: yeah,  "in haskell, we often do.." seems to be a common enough expression in our conversations
15:01:52 <mar77i> lol
15:01:58 <Arnar> I guess I mean more what kind of framework Snap is trying to be..
15:02:27 <mightybyte> Arnar: The defacto Haskell web framework
15:02:33 <ozataman> Arnar: I think the About section of the website sums it up pretty nicely
15:02:45 <mar77i> dark: I'm rather interested in when the :: operator is used :)
15:02:50 <Arnar> like Django e.g... or something more light weight like paste, or very configurable like pylons
15:02:54 <mar77i> and how
15:02:55 <Peaker> Man! Agda's hello world needs a lot of imports
15:02:57 <ksf> .oO( there I am, in the southernmost scandinavian country, and most of germany still thinks it's a great idea to occupy us )
15:03:16 <Arnar> mightybyte: nice.. basically I'm looking for the one to bet on in those terms
15:03:35 <Arnar> mightybyte: since I'm about to write something that will need to be taken over by someone else in 2-3 years
15:03:37 <dark> mar77i, ah. but it isn't an operator. a :: b (sometimes you need to write as (a :: b) though) is just a of type b. like a :: String
15:04:08 <monochrom> I wouldn't try to "understand" :: out of context.
15:04:10 <dark> mar77i, it is needed when the type inference gets confused
15:04:33 <monochrom> There are about 3 unrelated contexts for ::
15:04:33 <xplat> mar77i: the (::) unlike other operators doesn't actually 'do' anything per se, it more just provides a hint to the compiler
15:05:27 <Peaker> What are Agda's costrings?
15:05:33 <kakeman> do you know what version of opengl is supported by opengl wrapper? ubuntu package information says 1.6 :/
15:05:52 <xplat> costrings sounds like it would be (potentially?) infinitely long strings
15:06:55 <xplat> total languages exclude data (must be finite) and codata (may, or in some cases must, be infinite) and restrict how you may recurse on each
15:06:59 <mar77i> [it] is just a of type << well, that's not even a "just"... I'll try not to ask twice, ok? :)
15:07:28 <xplat> *exclude=distinguish
15:07:50 <ksf> kakeman, try ' glxinfo | grep "OpenGL version" '
15:07:57 <ksf> that's the maximum you're going to get.
15:08:10 <Peaker> xplat, ah, thanks
15:08:19 <dark> mar77i, i'm confused o.o
15:08:52 <kakeman> ksf: even via wrapper?
15:08:54 <xplat> if you can use foldr on an infinite string like "aaaaaaa..." you can use that to write fix and all its friends like loopForever :: a
15:09:02 <Younder> I got my PhD from Yale myself how about you?
15:09:21 <mar77i> that's so easy? cool :D
15:09:23 <ksf> in theory, it might be less, but I think the wrapper itself can do at least 2.0
15:09:36 <Younder> mathematics
15:09:50 <ksf> ...it of course can't provide that if your gfx driver only supports 1.6
15:10:12 <kakeman> OpenGL version string: 3.3.0 NVIDIA 260.19.06
15:10:13 <kakeman> nice
15:10:38 <Younder> I LOVE NVIDEA
15:10:58 <ksf> well, then I officially pass the question to someone who knows more about hopengl
15:11:11 <Younder> particularly Tesla 2
15:11:36 <Rebelz> Hi
15:11:42 <Dae_> kakeman, 3.2
15:11:58 <kakeman> Dae_: nice
15:12:29 <Dae_> kakeman, according to the OpenGL hackage page anyway
15:13:04 <kakeman> is hackege and ubuntu repo doing same thing?
15:13:18 <kakeman> *hackage
15:13:59 <Rebelz> I'm new to haskell, I know higher-order functions of list, but i can't seem to do what i want to...
15:14:05 <Younder> I hav 96 processors and 48 tesla 2's happily processig to geter on my Cray. CX1000
15:14:16 <sipa> Rebelz: well what do you want to do?
15:15:04 <kakeman> time to sleep, job interview tomorow>
15:15:21 <Dae_> good luck
15:15:28 <revenantphx> So er, Parsec's kind of failed me trying to parse something in the form
15:15:33 <revenantphx> (Expr) + (Expr)
15:15:37 <revenantphx> (which is itself an expression)
15:15:50 <revenantphx> since it ends up stuck in an infinite loop calling parseExpr trying to get the first part
15:15:58 <revenantphx> any better recommendations for C style syntax?
15:16:01 <revenantphx> or vaguely similar
15:16:05 <ddarius> Looking at this audio visualization off-angle on my laptop screen makes it look much cooler.
15:16:23 <Rebelz> So i have two Lists, similar to [(string, int), (string, int)] and [(int, float), (int, float). The ints are the same, i want to use the ints to match up the floats and strings.
15:17:11 <Younder> I do about 500 terra flops enough to make among the 500 most powerful computers in the world.
15:17:34 <Younder> make it
15:17:49 <accel> I'm tired of building up strings with "++" ; so I look up printf ... which amkes me wonder ... how does printf work? since: printf "%s" and printf "%s %s" end up in different types. How does this PrintfType encapsulate this magic?
15:18:04 <revenantphx> accel: I wish I knew that XD
15:18:18 <parcs> accel: look at its source
15:18:19 <dankna> there's a paper on it
15:18:19 <accel> revenantphx++ # for honesty
15:18:21 <Younder> printf is the old C printf
15:18:30 <accel> Younder: is there a more haskell-ish way to do this?
15:18:36 <kfr> I hate printf >:O
15:18:41 <accel> Younder: I'd prefer something that lets me do string substitution perl/python style
15:18:45 <kfr> I would never use it in Haskell
15:18:56 <accel> kfr: oh great sage of ahskell; what does thee use?
15:19:01 <kfr> ++
15:19:01 <accel> s/does/doth
15:19:11 <accel> ++ is ugly
15:19:28 <accel> "\\" ++ name ++ "{" ++ s ++ "}" <-- not nearlya s cool as, say "\\$name{$s}" <-- is this possible in haskell?
15:19:29 <kfr> Aren't there some extensions for Ruby like strign interpolation?
15:19:55 <dankna> http://okmij.org/ftp/typed-formatting/ -- printf paper, I think
15:20:09 <accel> dankna++ # for increaging my Intelligence
15:20:14 <dankna> hehe
15:20:25 <dark> accel, string interpolation? lots of people find it ugly (plus, it would be hard to do typing, unless you use some untyped macro language)
15:20:34 <dark> but i would like it anyway :t
15:20:43 <accel> dark: I think you can do it with typing ... via template haskell
15:21:02 <dark> oh, template haskell is typed? hmm. õ.o''
15:21:10 <Younder> I'm a Lisper myself
15:21:19 <mar77i> oh this is just great, my tutorial is for hugs and I'm using ghc :(
15:21:32 * ddarius doesn't see how anyone would think typing string interpolation would be difficult.
15:21:33 <accel> dark: iirc, template haskell compiles to haskell ... so it's got to be typed
15:21:44 <accel> Younder: what do you think of Lisk? I like lisp syntax more myself
15:21:48 <Younder> Lisp has a great function format. 
15:21:54 <dark> ddarius, typing _in haskell_?
15:22:14 <Younder> Lisp has a great function 'format'. 
15:22:22 <dark> but hmm if printf could be typed.. o.o
15:22:36 <revenantphx> So, once again. What do people recommend for recursive descent parsers?
15:22:43 <accel> I love parsec
15:22:46 <revenantphx> Parsec fails, as I said before
15:22:46 <accel> it amkes parsing fun again
15:22:49 <accel> oh
15:22:53 <accel> where does it fail
15:22:53 <ddarius> dark: I don't see why you would think it would be difficult -at all- in any language.
15:22:55 <revenantphx> Quick summary of issue:
15:22:56 <accel> i wasnt aying attention clearly
15:22:58 <revenantphx> say I have an expression
15:22:58 <Dae_> accel, I always preferred lightyears
15:22:59 <Younder> revenantphx, pascal
15:23:03 <revenantphx> a + b
15:23:05 <revenantphx> right?
15:23:05 <ddarius> revenantphx: No recursive descent parser handles left recursion.
15:23:15 <revenantphx> ddarius: okay... then what would I want to use :|
15:23:24 <othiym23> revenantphx: the cheesy way to solve the problem is to have some kind of Expression -> Statement -> Term hierarchy that matches your operator precedence hierarchy
15:23:27 <accel> i'm pretty certain parsec is a superset of recursive descent
15:23:40 <mar77i> revenantphx: (+) a b http://xkcd.com/645/
15:23:41 <ddarius> revenantphx: You need to learn how to express your grammar in a way amenable to LL(infinity) parsing.
15:23:43 <revenantphx> accel: the gist of the issue is it looks for "a+b" as an expression, then tries to parse "a" as an expression, but since it hasnt consumed anything it just sees "a+b" ahain...
15:24:01 <revenantphx> ddarius: any good resources?
15:24:01 <accel> revenantphx: can you post something to hpaste.org?
15:24:10 <ddarius> revenantphx: You could use others but then you're are looking more at parsing tools rather than libraries (though there are some exceptions.)
15:24:11 <revenantphx> ddarius: I'm looking at a kind of C'ish syntax
15:24:13 <accel> revenantphx: i.e the string to be aprsed; the desired AST, the current AST you get ?
15:24:17 <revenantphx> lemme post my parser/evaluator as it stands.
15:24:17 <ddarius> revenantphx: Any book/introduction to parsing at all.
15:24:24 <revenantphx> ddarius: recomemndations?
15:24:27 <accel> the dragon book
15:24:40 <revenantphx> https://gist.github.com/830585
15:24:46 <revenantphx> this has other issues aside...
15:24:50 <accel> http://dragonbook.stanford.edu/
15:24:50 <revenantphx> but you can see the issue.
15:25:11 <accel> whoa
15:25:17 <accel> is that the simplest test case taht brings out the problem?
15:25:32 <accel> parseBinaryOpExpr = do e1 <- parseExpr -- problem is this
15:25:36 <accel> what exactly is th eproblem on line 25?
15:25:50 <Younder> But there isn't a tool for writing a recursive decent parser.
15:25:51 * accel feels a need to repay all the time he's asked questions in #haskell
15:26:42 <revenantphx> accel: think about how it would parse "1.0 + 2.0"
15:26:57 <othiym23> wow, I a. had no idea they'd brought out a second edition of the Dragon Book and b. didn't realize it was possible to design a cover for the second edition that's uglier than the first
15:27:00 <Younder> By it's nature you have to write it yourself..
15:27:20 <revenantphx> so it goes to parseExpr, first thing it tries is ParseBinaryOpExpr accel
15:27:28 <revenantphx> and then, before it consumes any inut, it calls parseExpr
15:27:34 <revenantphx> which of course... causes the same thing.
15:27:36 <accel> othiym23: I think he second edition is ray traced though
15:27:37 <phyrex1an> can't you use the ParsecExpr extension to parsec to resolve that?
15:27:39 <dark> ddarius, well, if string interpolation is built in in the language, then it would be easily typeable
15:27:41 <ddarius> Younder: There are plenty of tools that could (and some do) output recursive descent parsers.
15:27:43 <accel> othiym23: so atleast they're using the state of art in comptuer graphics
15:27:49 <othiym23> accel: oh, OK, that makes it all better :D
15:28:11 <ddarius> dark: And if it's not, then it is a simple syntactic transformation to something that would be easy to type check as well.
15:28:17 <Younder> I'ts a beautiful technique go for it. 
15:28:22 <dark> but if you have this interpolated string "hah $a $b" then a and b would be of Show class
15:28:38 <accel> OMG: http://www.mail-archive.com/haskell-cafe@haskell.org/msg12216.html <-- does string interpolation l... how does this magic work?
15:28:44 <blackdog> dark: it's not hard to do
15:29:05 <blackdog> dark: i blogged it at http://www.shimweasel.com/2009/10/30/string-interpolation-in-haskell-or-doing-easy-things-the-hard-way a while back
15:29:09 <Younder> ddarius, no there aren't
15:29:14 <accel> revenantphx: so you want to parse "varaible", "symbol", "varaible"
15:29:17 <accel> revenantphx: what is the problem?
15:29:19 <ddarius> Younder: ANTLR does.
15:29:20 <dark> ddarius, oh, that's why i mentioned an untyped macro expansion: expand this to ("hah " ++ (show a) ++ " " ++ (show b)) without looking into the types
15:29:29 <dark> blackdog, hm o.o
15:29:37 <othiym23> revenantphx: you probably don't want "1.0" to be an expression -- you want it to reduce to something like a Term or a Literal
15:29:43 <revenantphx> accel: think about it a bit.
15:29:46 <Younder> ddarius, yes
15:29:49 <revenantphx> what happens for "1.0 + 1.0"
15:29:59 <ddarius> Younder: I see you are covering all bases.
15:30:07 <accel> revenantphx: I don't get why you can't design something to parse it
15:30:11 <accel> revenantphx: ti's vairly standard to parse
15:30:14 <revenantphx> parseExpr chooses parseBinaryOpExpr which calls parseExpr which calls parseBinaryOpExpr...
15:30:25 <accel> revenantphx: okay, so redesign it
15:30:28 <revenantphx> The point is this kind of parsing engine isn't amenable to this apparently.
15:30:33 <revenantphx> looking for something more expressive.
15:30:36 <accel> revenantphx: how about parseExpr `sepby` parseBinaryOpExpr ?
15:30:49 <revenantphx> ???
15:30:56 <revenantphx> how would that help at all.
15:30:56 <accel> s/sepby/SepBy/
15:31:01 <c_wraith> Your problem is that you're using a left-recursive grammar definition with an LL parser...
15:31:04 <revenantphx> or even do what I want.
15:31:07 <revenantphx> c_wraith: ^^^
15:31:24 <revenantphx> c_wraith: so what do you recommend?
15:31:25 <accel> revenantphx: hmm; I think i lack the ability to understand your problem; sorry, maybe c_wraith can explain
15:31:40 <Younder> ddarius, There is only one and you are claiming there are plenty. And actually you are better off implemeting recursive decent by yourself
15:31:57 <accel> ghci -fth VariableExpansion.hs
15:32:03 <accel> ghci -fth VariableExpansion.hs <-- what does the fth doe?
15:32:08 <accel> i don't see it in my manpage
15:32:11 <c_wraith> enables template haskell
15:32:13 <ddarius> Younder: No, I claimed there are plenty that -could- and some that do.  Just because I listed one certainly doesn't mean it's the only one.
15:32:19 <accel> c_wraith++
15:32:26 <ksf> aka -XTemplateHaskell
15:32:29 <c_wraith> the normal way to do it is put {-# LANGUAGE TemplateHaskell #-} at the top of the file
15:32:30 <revenantphx> ???????????????????
15:32:36 <revenantphx> c_wraith: help please D:?
15:32:38 <ksf> ...which you shouldn't use, either, but the language pragma.
15:32:41 * hackagebot hspec 0.2.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.2.0 (TrystanSpangler)
15:32:43 <othiym23> revenantphx: what you want is to use something like a new parser, like parseTerm
15:32:46 <ddarius> I'm pretty confident Happy (and Frown) can also generate recursive descent parsers.  Probably also Coco/R.
15:32:56 <accel> why is specifying langauge extensions in source file better than in the commandline?
15:32:58 <revenantphx> othiym23: explain.
15:33:11 <revenantphx> ddarius: I don't want a generator though :P, I wanted to write one on my own :
15:33:14 <c_wraith> revenantphx: too busy now, sorry. :(
15:33:23 <ksf> accel, because it's independent of the build system. and acts as documentation.
15:33:26 <ddarius> revenantphx: I never suggested that you did.
15:33:43 <accel> ksf: I buy your argument; thanks.
15:33:44 <revenantphx> ddarius: in any case, what's the suggestion?
15:33:49 <revenantphx> othiym23: can you explain a bit more?
15:33:52 <othiym23> revenantphx: that's how you break the left recursion, by saying you have a hierarchy of Statements that can be broken down into Expressions which contain Terms that contain either Factors or Literals
15:34:03 <revenantphx> Ah... I see.
15:34:05 <ksf> accel, also, because you don't have to retype it.
15:34:12 <othiym23> so a Statement is an Assigment or an Expression
15:34:18 <Younder> ddarius, Actually you are better off implemeting recursive decent by yourself. The thing you missed..
15:34:21 <othiym23> an Expression has one or more Terms
15:34:21 <ddarius> revenantphx: Learn some parsing theory.  Just stick that into Google.  While some books/resources are better than others, you'd be hard-pressed to find one that isn't adequate for this.
15:34:23 <othiym23> etc
15:34:30 <Younder> rotfl
15:34:31 <revenantphx> ddarius: alright.
15:35:04 <othiym23> is there something like SICP (Abelson) or CTM (Haridi / Van Roy) for Haskell?
15:35:11 <accel> http://www.mail-archive.com/haskell-cafe@haskell.org/msg12216.html <-- how does Template Haskell end up calling the "expand" function in VariableExpansion.hs ? and how do I do the same in my Haq.hs file?
15:35:20 <othiym23> the only Haskell book I have is Real World Haskell and it kind of frustrates me a lot of the time
15:35:22 <accel> othiym23: Haskell school of Expression is good so is Real World Haskell
15:35:34 <othiym23> accel: K, thanks
15:35:34 <revenantphx> othiym23: thanks btw.
15:35:36 <ksf> there's an awesome intro into (N)DFAs in an ars digita lecture
15:35:36 <accel> othiym23: you can also use the technique I used
15:35:46 <alpounet> othiym23, you can give a whirl to LYAH too
15:35:48 <accel> othiym23: which is to ask lots of annoying questions in #haskell; then wait for people to point me at chatpers in RWH
15:35:53 <othiym23> haha
15:35:53 <alpounet> @where lyah
15:35:54 <lambdabot> http://www.learnyouahaskell.com/
15:36:04 <othiym23> alpounet: I'm working through it right now
15:36:07 <Younder> ddarius, You are obviously a excellent programmer. why do you need such tools?
15:36:24 <ksf> http://www.youtube.com/watch?v=HyUK5RAJg1c
15:36:26 <othiym23> actually, I'm working through these: http://www.amazon.com/review/R5SSPCA6ZGNC7/ref=cm_cr_pr_perm?ie=UTF8&ASIN=0596514980&nodeID=&tag=&linkCode=
15:36:34 <othiym23> that guy pretty much sums up my beefs with RWH
15:37:25 <accel> othiym23: I skipped the JSON chapter too
15:37:29 <ksf> "understand how JSON works"
15:37:36 <ksf> what's so non-trivial about that?
15:37:42 <ddarius> Younder: I'm going to cease responding to you now.
15:38:03 <accel> othiym23: I feel like the book is the union of (1) using Haskell in a practical mamnner and (2) a bunch of shitty library bindings (Json, SQL stuff); and the former is what I wanted, whereas I couldn't care less about the latter
15:38:38 <accel> othiym23: the chapters on monads + optimization are really good though
15:39:15 <accel> where is "{-# Langauge" defined?
15:39:17 <blackdog> accel: i thought the json chapter wasn't terrible - if you hadn't seen ADT-based development before, it might have been informative
15:39:26 <othiym23> accel: I actually found the original SPJ paper on monads to be waaaayyy more useful to me, although it left me clueless when it came to using do syntax
15:39:28 <accel> where is "{-# Langauge" defined? (in particular; I want to know more about how to specify compiler options)
15:39:34 <othiym23> I deal better with formalisms at this point in my life
15:39:38 <blackdog> but i'd agree that the optimisation & profiling chapter was golden
15:39:40 <accel> othiym23: SPJ paper = ?
15:39:56 <accel> blackdog: yeah, but a cooler/more useful example would have been, say a calculator or smoething
15:40:07 <romanandreg> guys do you know any easy way to get a UNIX Timestamp?
15:40:10 <accel> blackdog: I saw JSON, and thought why the fuck do I care about how javascript encodes stuff
15:40:19 <sipa> romanandreg: date "+%s" ;)
15:40:20 <romanandreg> can't find a function that would get a ClockTime and returns just that
15:40:28 <ksf> accel, http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma
15:40:34 <romanandreg> sipa: using Haskell functions
15:40:49 <accel> ksf: even though you don't have vowels in your nick; I still appreciate your help :-)
15:41:27 <othiym23> sorry, it wasn't Simon Peyton-Jones, it was the Phil Wadler paper: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
15:41:42 <othiym23> first link on the Monad tutorials timeline on the wiki
15:42:00 <accel> othiym23: thanks
15:42:18 <Younder> ddarius, you are a fucking idiot if you don't realize the recursive decent is a programming paradigm.
15:42:27 * ksf found writing "what monads are not" very helpful. stopped me from listening to people trying to explain them.
15:42:46 <accel> ksf: http://www.haskell.org/haskellwiki/What_a_Monad_is_not ?
15:42:51 <ksf> yep
15:42:52 <othiym23> accel: I liked the JSON parser, but I think I would have been better off with a toy interpreter of some expression language with infix syntax, just because that's analogous to how I've learned to write parsers with other languages
15:43:22 <accel>  2 Monads are not a good choice as topic for your first Haskell blog entry
15:43:23 <accel> ...just accept that they're burritos, and wait until later. 
15:43:23 <Younder> ddarius, beyond that I have nothing to say to you. 
15:43:27 <accel> monads are burritos?
15:43:34 <ksf> indeed, they are.
15:43:56 <ksf> and assembly lines, and spacesuits (with some involvment of nuclear waste)
15:44:06 <monochrom> eh? recursive descent is so trivial I wouldn't call it a paradigm. would you also speak like "the while-loop technology"? http://www.vex.net/~trebla/humour/book_for_sale.html
15:44:12 <Younder> sorry for the harsh language
15:44:27 <accel> how the fuck do I use template haskell with http://www.mail-archive.com/haskell-cafe@haskell.org/msg12216.html ? do I need a PhD in fucking template haskell ?
15:44:36 <ksf> gah. recursive descent is what breaks closedness under virtually everything if you don't pay *very* close attention.
15:44:49 <ksf> i.e. go pushdown instead of nested-word.
15:45:01 <ksf> it's the introduction of more power to a language.
15:45:02 <romanandreg> does anyone now how to get a Unix Timestamp out of a ClockTime, is that even possible?
15:45:13 <accel> whoa, are {- -} multiline haskell comments?
15:45:18 <Zao> Yup.
15:45:19 <Peaker> Younder, I think people are finding your delivery objectionable, not the content
15:45:23 <accel> I never realized that
15:45:25 <ksf> it's a step in the hierachy of computational power, and got nothing to do with programming, per se.
15:46:14 <othiym23> accel: have you played around with Literate Haskell yet?
15:46:23 <accel> othiym23: no
15:46:36 <othiym23> it's both awesome and mildly disturbing, as most literate programming systems are
15:46:38 <accel> othiym23: I find haskell code documentation free
15:46:47 <accel> othiym23: i.e. it's haskell code is either trivial to read
15:46:55 <accel> othiym23: or I need to get paper = draw fucking boxes + arrows
15:46:57 <othiym23> LYAH is actually literate Haskell
15:46:58 <romanandreg> ok done...
15:47:30 <Peaker> I think "Literate Programming" is too fancy a name for the reversal of comments and code
15:47:41 <sbahra> haha
15:48:33 <monochrom> but consider the fact that most programmers are illiterate, they can't even write external docs.
15:48:57 <ksf> Peaker, it's like those buzzword team-managment practices where people can't discern the idea from the implementation and thus go on and fund cargo cults.
15:49:47 <ksf> literate programming, in the knuth sense, means writing+prooving your code on paper, and then injecting it into a book.
15:49:55 <othiym23> Peaker: How dare you impugn the name of KNUTH?!??!
15:50:13 <Younder> Peaker, probably
15:50:31 <ksf> "The main idea is to treat a program as a piece of literature, addressed to human beings rather than to a computer."
15:50:36 <ksf> http://www-cs-faculty.stanford.edu/~uno/lp.html
15:51:01 <othiym23> yeah, and when it works, it's great, but it's not like it's something you're going to want to use to implement all your code
15:51:03 <Peaker> ksf, that idea has been accepted by virtually everyone anyway, I believe.. Everyone talks of "readability" and that's basically it
15:51:22 <ksf> the inversion of comments and code is just so that you can send the source file verbatim via email and still have it be literate.
15:51:31 <Younder> Peaker, I am offended when people don't accept my word
15:52:11 <Younder> Peaker, I have written 5 recursive decent compilers in the past.
15:52:24 <ksf> personally I think the way to go in haskell isn't literate programming as such, but arranging the order of functions such that the haddock comments, read from top to bottom, tell you the whole story.
15:52:51 <othiym23> using variables with names more than 1 character long often helps a lot, too
15:53:02 <ksf> nope.
15:53:12 <accel> is there a separate template haskell channel?
15:53:17 <ddarius> Peaker: For me, it has nothing to do with his "content" but rather the lack of content, the lack of coherence, and the fact that I'm not aware of him having said anything Haskell related.
15:53:28 <accel> is there a separate template haskell channel? ( I fear I am descending into black magic not good for innoncenent eyes to view)
15:53:29 <Peaker> Younder, Would you consider Parsec-based parsers that call other Parsec-based parsers to be "recursive descent"?
15:53:35 <ksf> there's just no reason whatsoever why one would want to use more than one character for a variable in a function like map.
15:53:43 <ksf> ...and a lot of other haskell functions are as abstract.
15:53:45 <accel> is there a separate template haskell channel? ( I fear I am descending into black magic not good for innoncenent eyes to view) -- like, can I say "I want to see the template-haskell output of this file, before it gets sent to ghc" ?
15:54:00 <accel> ksf: what if I havem ore than 26 varaibles in my map function?
15:54:06 <ddarius> ksf: map f (x:xs)
15:54:11 <ksf> then you need to split it up.
15:54:22 <dankna> accel: -ddump-splices
15:54:26 <accel> ddarius: I think ksf was mentioning as in map (\ ... ) 
15:54:37 <Pseudonym> accel: Generally speaking, you should ask here unless it's too serious.
15:54:43 <ksf> there's a place for long names, but principle ain't one of them.
15:54:44 <Pseudonym> This isn't too serious.  Yet.
15:54:51 <Younder> Peaker, I have no clue what a Parsec based parser is.
15:55:06 <othiym23> ksf: I agree for abstractions, but when you're wading through a new and unfamiliar module containing many functions, things get pretty gnomic if everything is too terse
15:55:11 <ddarius> Peaker: See?
15:55:13 <accel> Pseudonym: damn, I was hoping to feel special
15:55:17 <Peaker> Younder, then it seems you are shouting at people out of a position of ignorance
15:55:24 * ksf would call parsec calling parsec a hack
15:55:35 <ksf> not that I haven't done it already, in the context of layout parsing.
15:55:38 <Peaker> ddarius, 1/10 on the PoppaVic scale :) 
15:55:52 <accel> dankna: is there a way to pass that to cabal ?
15:55:58 <Pseudonym> accel: You are special, but you haven't yet crossed over into the arcanum.
15:55:58 <ksf> othiym23, well, add comments.
15:56:14 <othiym23> ksf: that would also help
15:56:30 <ksf> it's surely an art to know where to put the necessary information
15:56:31 <dankna> accel: --ghc-options
15:56:35 <dankna> at configure-time
15:56:38 <ksf> ...without uglifying the code.
15:56:39 <Younder> Peaker, No, I know recursive decent. Not Parsec. (a game i loved on the TI 99)
15:57:58 <accel> how do I tell ghc: search in "dist/build/haq/haq-tmp/" for the module "VariableExpansion.hi" ?
15:58:11 <ksf> -i
15:58:14 <ksf> or was it -I
15:58:16 <dankna> not sure.
15:58:20 <ksf> I always confuse those.
15:58:27 * accel bravely tries both
15:58:32 <ksf> anyway, cabal should do that for you.
15:59:09 <accel> yeah; but I can't put -ddump-sllices into calabal
15:59:15 <accel> since VaraibleExpansion.hs needs to be compiled normally
15:59:21 <accel> and Haq.hs needs to be compiled with -ddump-splices
15:59:27 <accel> TH is making mylife misrable already
15:59:52 <ksf> -ddump-splices doesn't hurt.
16:00:00 <ksf> it's just barfing stuff to stderr/out
16:00:11 <accel> ah; 
16:00:12 <accel> I'm an idiot
16:00:13 <dankna> why don't you try cabal build --verbose to figure out exactly what cabal is doing, then copy-paste those commands with your changes
16:00:19 <accel> dankna , ksf : thanks
16:00:24 <dankna> np
16:02:07 <Younder> well wonderful idiot why do you use cabal at all and not make?
16:02:39 <ksf> you surely mean ghc --make
16:02:52 <ksf> ...and the reason, if nothing else, is hackage and dependency analysis.
16:02:52 <accel> i'm a haskell newb
16:02:54 <Younder> no make
16:03:04 <accel> i like hwo cabal sets up the project
16:03:11 <accel> i'm not smart enough to set it up myself
16:03:23 * othiym23 oO( IRC is so IRC )
16:03:28 <Younder> as there exist a a Makefile
16:03:33 <ksf> accel, I'm to lazy, which bogs down to the same.
16:03:42 <accel> ksf: nah; you have potential
16:03:45 <accel> ksf: I'm just screwed
16:03:56 <Younder> rotfl
16:04:05 <ksf> great. I'm going to tell that the next girl I meet.
16:04:45 <accel> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/ <-- what's the comment character in cabal?
16:04:48 <accel> it's clearly not #
16:04:52 <ksf> --
16:05:06 <accel> is cabal some crazy haskell DSL, or is it a separate file foramt?
16:05:10 <ksf> ...just use cabal init and go from there
16:05:10 <accel> ksf: worked; thanks
16:05:18 <accel> oh shit; there's cabal init
16:05:21 <accel> which create a cabal file for you?
16:05:25 <accel> i created mine by hand
16:05:25 <ksf> yep
16:05:42 <Younder> accel, yes cabal sucks
16:05:52 <ksf> you still have to do things manually, but you won't have to look up the most used fields.
16:06:25 <Younder> accel,now darcs rocks
16:06:30 <accel> no
16:06:31 <accel> i use git
16:06:39 <accel> darcs is like git, except exponentially slower
16:06:56 <ksf> well, not really.
16:07:02 <ksf> it's got potential, so we're screwed.
16:07:06 <Younder> accel, Yes, but how HUGE is your project
16:07:11 <sipa> ;;bc,stats
16:07:12 <othiym23> darcs has its own special magic goin' on
16:07:15 <ocharles> it's like git in the fact that it versions files
16:07:16 <sipa> ow
16:07:18 <ocharles> and it's distributed
16:07:24 <ocharles> that's about as far as that goes
16:07:24 <accel> my project is already 189 lines of code, spread over 2 files!
16:07:31 <Younder> so is darcs
16:07:52 <accel> i like git for one simple reason
16:08:12 <accel> if I trust a guy to write the codeo f my kernel; I trust him to write software to keep my code safe
16:08:17 <Younder> now this i'd like to hear
16:08:21 <ksf> for me it's speed and the fact that I use vcs only as emergency backup.
16:08:34 <ocharles> accel: that's a fairly dumb reason, tbh. but whatever works for you
16:08:43 <accel> ocharles: why?
16:08:46 <Younder> ahh you basically trust linus
16:08:48 <dons> usability should be an issue
16:09:04 <accel> dons: that didn't seem a factor in xmonad
16:09:10 <ocharles> accel: why do you trust him with the kernel? it sounds like you'll just use it because it's linus approved
16:09:16 <ocharles> which seems extremely arbitrary, and limiting
16:09:21 <Younder> well GIT will scale
16:09:32 <accel> ocharles: no, i trust it because the rest of the world trusts it, and I'm too lazy to verify it myself
16:09:40 <accel> ocharles: where it = linux kernel
16:09:42 <Peaker> #haskell-blah ?
16:09:42 <ksf> I don't really need a vcs, my mode of programming makes it quite unimportant. but it's nice to have integrity in your backups.
16:09:55 <Younder> yes pretty lazy myself
16:09:55 <ocharles> accel: <insert jump off cliff analogy here>
16:10:02 <aristid> ksf: sounds like you should change your mode of programming
16:10:08 <ksf> nope.
16:10:11 <parcs> vim's persistent undo feature eliminates most of my needs for a vcxs
16:10:14 <accel> ksf codes via "cat > Main.hs"
16:10:17 <Peaker> ksf, branches are awesome
16:10:31 <accel> parcs: how many GB's if your ~/.viminfo file ?
16:10:35 <Peaker> much more willing to experiment with branches
16:10:37 <Younder> Ah. another VIM user?
16:10:47 <ksf> why should I abandon the technique of keeping my code configurable enough that I can switch branches in my code with a couple of keystrokes?
16:10:51 <parcs> accel: 19K
16:11:05 <accel> Peaker: I like branches too; these days, whenever i have a nfew feature; I create a new branch; screw around, and if it's good, merge it back; else, just ditch it
16:11:06 <othiym23> so I'm reading http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_about_strictness and trying to figure out in which environment I should be trying to run that example
16:11:29 <othiym23> GHCi 7 seems to be unhappy with it with both Control.Monad.State and Control.Monad.State.Lazy
16:11:49 <othiym23> any pointers?
16:11:55 <aristid> othiym23: you probably just need to give ghci some flags
16:12:04 <aristid> what is the error message?
16:12:13 <ksf> see, I just start off another function or module paralelly, and don't make the former one unuseable before the next one is ready.
16:12:33 <othiym23> Not in scope: data constructor `State'
16:12:48 <aristid> othiym23: ok, that one is easy. just load the module...
16:13:04 <parcs> accel: however my undo directory is 23M
16:13:05 <othiym23> :m +Control.Monad.State is already loaded
16:13:10 <doserj> change "State" to "state"
16:13:28 <Younder> Don't ask for pointers. I'll revert to my C programming days and point you to > dev/null
16:13:44 <Younder> rotfl
16:13:48 <othiym23> doserj: bingo, thanks
16:14:00 <othiym23> doserj: did something change at some point, or is that a typo on the page?
16:14:19 <doserj> State used to be a data constructor. now it is just a function
16:14:32 <ksf> othiym23, oh, that one broke with mtl-2.
16:14:36 <othiym23> ah, that makes sense
16:15:28 <accel> how can I install hoogle locally?
16:16:01 <Peaker> cabal install hoogle -- and then hoogle libs you want into db files that you can then merge and search on
16:16:28 <accel> Peaker: can you expalnd on the things I need to do after 'cabal install hoogle' ?
16:16:35 <accel> Peaker: what are hoogle libs?
16:16:42 <accel> Peaker: and where is dbfiles located?
16:16:49 <Younder> accel, Well on ubuntu I 'just ask'
16:16:49 <accel> Peaker: and how many lambds do I need to slaughter?
16:16:55 <mkscrg> So I have an algebraic datatype, and I have a specific definition of show for one of its constructors. I want to use the derived definition of show for the other constructors. Possible?
16:17:20 <Peaker> accel, I don't recall exactly.  the hoogle package gives you a "hoogle" executable that IIRC can build db files, merge db files, or do searches on db files
16:17:26 <Peaker> accel, I think the paths are given by you
16:17:27 <accel> Peaker++
16:17:36 <accel> Peaker++ # prepayment for future help
16:17:48 <Younder> accel, seriosly sudo apt-get install hoogle
16:18:02 <accel> Younder: apt-cache search hoogle brings nothing; but cabal almost succeeded
16:18:08 <ksf> mkscrg, not really.
16:18:17 <accel> haskell-src-exts-1.10.1 failed during the configure step. The exception was:
16:18:17 <accel> ExitFailure 1
16:18:38 <othiym23> what does the build log say?
16:18:44 <accel> it wants happy
16:18:52 <accel> sudo apt-get install happy
16:19:02 <ksf> mkscrg, if it's a really bad case, though, you might want to wrap a newtype around your adt, derive for the adt, and write a show instance for the newtype manually, partially in terms of the derived instance
16:19:29 <accel> happy installed; reinstalling haskell-src-exts
16:19:49 <accel> compiling Language.Haskell.Exts.Annotated.Syntax # hammering the CPU
16:19:59 <mkscrg> ksf: Good call. I'll keep that in mind if I can't find a happier workaround.
16:20:01 <ksf> mkscrg, alternatively, you might want to hack up something in template haskell
16:20:13 <Younder> accel, No you are perfectly correct UBUNTU reconises neither cabal r hoogle
16:20:29 <Younder> I tried
16:20:33 * mkscrg runs off to google "template haskell"
16:20:44 <accel> mkscrg: if you have problems, let me know
16:20:46 <accel> mkscrg: i'm in the same boat
16:20:57 <accel> mkscrg: so I can pretend to help you; whle you learn how TH works, so you can one day help me
16:21:25 <accel> operationa cabal install haskell-src-exts-1.10.1 success; resuming cabal install hoogle
16:21:52 <mkscrg> accel: Deal.
16:22:04 <accel> operation cabal install hoogle success
16:22:23 <accel> hoogle map
16:22:23 <accel> Could not find some databases: default
16:22:28 <Younder> accel, you got yourself a deal
16:22:28 <accel> There are no available databases, generate them with: hoogle data
16:22:38 <accel> dispatching team to extract hoogle data
16:22:41 <accel> wgetting .....
16:23:56 <accel> hoogle map | wc -l  
16:23:56 <accel> 305
16:23:58 <accel> victory
16:24:03 <accel> Peaker: thanks for insights :-)
16:24:04 <Younder> How slow is your connection anyhow..
16:24:43 <accel> it's only 100Mbps
16:24:50 <accel> don't ahve gigabit yet
16:25:52 <accel> how do I tell hoogle to run not on 80 but on 8080 ?
16:25:59 <accel> or how do I tell hoogle to run on 1337
16:26:15 <parcs> "only" eh?
16:26:31 <Younder> duh! Practically no-one has 1 Gbit
16:26:32 <accel> yeah; it takes me a full minute to download a iso from mirrors.kernel.org
16:26:43 <accel> gigabit would be 7 seconds, I think
16:27:03 <Younder> I havea meesly 10 Mega bi
16:27:09 <Younder> bit
16:27:20 <accel> 100 Megabit ~ 10 Megabyte
16:27:28 <Younder> and it works fine for me
16:27:54 <accel> damn it; does hoogle only run on port 80?
16:27:58 <accel> gogoel searches on hoogle
16:28:03 <accel> keeps on gi ing me results about some google 
16:28:18 <ksf> ...whatever that is.
16:28:27 <parcs> did you try hoogle --help?
16:28:30 <accel> yeah
16:28:32 <mun> hi
16:28:34 <accel> it doesn't give options
16:28:35 <Younder> rotfl
16:28:36 <accel> to the server option
16:28:40 <accel> even tried hoogle --help server
16:28:40 <ksf> if in doubt, look at the source
16:28:54 <Younder> hogle to the rescue
16:28:54 <parcs> try using the -p switch
16:28:54 <accel> hoogle server 8080
16:28:54 <accel> Unhandled argument, none expected: 8080
16:28:58 <monochrom> (how about "hoogle server --help"?)
16:29:03 <ksf> cabal unpack hoogle; cd hoogle-<version>
16:29:03 <parcs> if not, then -P
16:29:10 <accel> parcs: nice; thanks
16:29:12 <accel> parcs++
16:29:29 <mun> is \forall x. \exists v1 v2. f(x) = v1 & g(x) = v2 <--> v1 = v2 same as \forall x. \exists v1 v2. f(x) = v1 & g(x) = v2 & v1 = v2?
16:29:40 <monochrom> god, raw TeX code
16:30:17 <Younder> 'hoogle haskel' worked for me
16:30:17 <ksf> can I see that properly layout, on top of each other?
16:30:46 <accel> can I see taht rendered in TeX, converted to a ps, rendereted to a png, and psoted to imgur?
16:30:47 <Younder> 'hoogle haskell' worked for me
16:31:17 <monochrom> (∀x.∃v1 v2. f(x)=v1 ∧ g(x)=v2 ↔ v1=v2) (∀x.∃v1 v2. f(x)=v1 ∧ g(x)=v2 ∧ v1=v2)
16:31:40 <monochrom> and I guess ∧ binds tighter than ↔
16:31:51 <Younder> I's 2 in the morning forget it
16:32:15 <mun> monochrom, hmm but should the truth tables be the same?
16:32:25 <monochrom> processing
16:32:47 <Younder> Dump that data shit
16:33:34 <monochrom> (∀x.∃v1 v2. f(x)=v1 ∧ g(x)=v2 ∧ v1=v2) = (∀x. f(x)=g(x)) = (f=g)
16:33:53 <accel> monochrom: are you a bot, or are you just great at unicoding logic expressions & evaluating them?
16:34:01 <mun> monochrom, yep
16:34:06 <Younder> Yes 'and' binds closer than 'equivalence'
16:34:09 <accel> monochrom: i don't get how you unicode taht with no typos
16:34:10 <monochrom> accel: same difference :)
16:34:20 <accel> i even misspelled that
16:34:22 <mun> Younder, but what do you mean by "closer"?
16:34:28 <monochrom> bot = just great at unicoding logic expressions & evaluating them :)
16:35:00 <Younder> mum the parenthesises I suppose
16:35:52 <mun> monochrom, for the equivalence case, it's also equivalent to (f = g), right?
16:36:06 <Younder> yup
16:36:20 <Younder> for all x
16:36:23 <mun> then how is one "closer" than the other?
16:37:12 <Rotsor> Greetings everyone! Could anyone help a newbie haskeller to start with FRP? What library could I use to design GUIs? I have tried FRP.Reactive, but have some problems with it.
16:37:27 <accel> look into either Haskell SOE or Conal Elliot's tutorials
16:37:52 <Younder> Actually this is al logic trick question 
16:38:12 <monochrom> (∀x.∃v1 v2. f(x)=v1 ∧ g(x)=v2 ↔ v1=v2) = true /= (f=g)
16:38:41 <Younder> always true
16:39:16 <mun> why is it always true?
16:40:17 <monochrom> proof of (∀x.∃v1 v2. f(x)=v1 ∧ g(x)=v2 ↔ v1=v2) if the domain has enough elements: given x, pick v1 different from f(x), pick v2 different from g(x) and different from v1. (f(x)=v1 ∧ g(x)=v2 ↔ v1=v2) evaluates to (false ↔ false)
16:40:50 <mun> ohoh
16:41:29 <mun> thanks a lot
16:49:02 <dark> monochrom, i struggled to understand, but in the end it's very simple
16:49:09 <dark> logic is tricky
16:49:26 <NihilistDandy> My database professor refers to postgres as "dying"
16:49:34 <NihilistDandy> Just... \Psi
16:49:35 <dark> NihilistDandy, explain
16:49:58 <NihilistDandy> He can't explain it. He had some vague argument about clients not wanting to buy it
16:50:11 <dark> can it be bought?
16:50:17 <shachaf> NetCraft confirms is: Postgres is dying.
16:50:24 <NihilistDandy> Well, not wanting to buy things built on it, I guess
16:50:33 <dark> shachaf, what about postgresql?
16:50:52 <dark> i think postgresql is awesome. i also know about one big deployment: at caixa econômica federal (a state bank here at brazil)
16:51:02 <NihilistDandy> Yahoo and Reddit use it, as well
16:51:06 <ksf> it's neither buzzword nor hype-compliant.
16:51:28 <dark> but i have never used oracle. and i used mysql only for php things, where i hadn't know a dime about sql
16:51:38 <ksf> most importantly, it's not pronouncable.
16:51:40 <NihilistDandy> ksf: I think that's why he's not aware of it's widespread use. He's an Oracle user :/
16:51:47 <NihilistDandy> *its
16:52:00 <dark> also, i can write triggers & functions in lua @.@
16:52:46 <dark> (third party, but easy to install. it comes with python, perl bindings as well, those things)
16:52:49 <othiym23> Oracle's awesome, if you have a 64-way PowerPC machine with a terabyte of RAM, a fiber channel SAN, and a dedicated team of on-call data janitors to keep it running well
16:53:07 <NihilistDandy> lol
16:53:14 <NihilistDandy> I wish I had #haskell in my class.
16:53:24 <NihilistDandy> He wouldn't survive the night O.o
16:53:31 <othiym23> PostgreSQL is awesome when you want a nice cheap simple implementation of the relational model
16:53:35 <jtootf> hi haskellers! does anyone knows, if there a tool (or a library) already implemented for desugarizing haskell code to what is called "haskell kernel" in the Report? Language.Haskell offers a very simple parser without desugarizing, and GHC output (even with -ddump-simpl or -ddump-ds) is very noisy and really is a GHC Core language, but not the "haskell kernel" I want to have
16:54:14 <dark> NihilistDandy, i have professors like that, and i just ignore. it won't change my day, plus i now go there with a netbook, so i will not even be terribly bored
16:54:15 <ksf> I thought that's what sqlite is for
16:54:20 <othiym23> I was under the impression that there was no standardized representation of "kernel Haskell"
16:54:29 <NihilistDandy> dark: Yup. I'm in class, right now.
16:54:44 <othiym23> ksf: SQLite has a shaky grasp of types
16:55:00 <othiym23> PostgreSQL is strongly typed, which is nice
16:55:01 <dark> NihilistDandy, oh lol. what time is it in your locale? 22:18 here
16:55:29 <NihilistDandy> 20:21, if my clock is to believed
16:55:30 * ksf wouldn't trust typing that's not mirrored in haskell, anyway.
16:55:43 <ksf> and if it's mirrored in haskell, sqlite can't get it wrong.
16:56:20 <monochrom> the computing world is large enough to have sufficient user base for almost every fringe product/technology. postgresql won't die so easily, neither will windows 3.1.
16:57:04 <monochrom> as another example there are still enough os/2 bank terminals
16:57:07 <jtootf> othiym23: it is stated in Report that kernel is not formally specified, but all the syntactic constructions presented in Report with proper translation to it
16:57:27 <dark> but postgresql isn't just a commercial product (or, embedded in some products). it won't die as code & community even if it dies as a "product"
16:57:56 <monochrom> my final example is there are still enough windows 95 users you haven't heard of, and they do it just because they are still clinging on a past fax software that only has a windows 95 version.
16:58:02 <othiym23> ksf: I generally take the attitude that my database is more valuable than any single application running on top of it
16:58:08 <dark> btw at caixa, a postgresql + debian offering won against both an ibm offer and an oracle one o.o'
16:58:31 <othiym23> ksf: so support for things like integrity constraints, strong typing, and strong normalization are important to me
16:58:35 <NihilistDandy> dark: I should bring that up :D
16:59:05 <NihilistDandy> The man's not a developer, that much is clear. He sounds like a glorified IT guy. :/
16:59:16 <NihilistDandy> Refers to Lisp as "dead", too :/
16:59:21 <dark> NihilistDandy, btw i heard about it at #postgresql
16:59:31 <NihilistDandy> I should join up :D
16:59:45 <monochrom> @quote monochrom vested
16:59:45 <lambdabot> monochrom says: most people tend to deny the usefulness of useful alternative perspectives --- their entrenched vested interests demand it. as they grow older they also have more influence and power
16:59:45 <lambdabot> over "the state of the art" to preserve their self-fulfilling prophecy that "the alternative is useless" --- by controlling what practice looks like, they can control what looks useless.
16:59:55 <monochrom> This applies to glorified IT people too.
17:00:27 * NihilistDandy nods
17:00:41 <monochrom> An MCSE has invested so much in getting his/her MCSE (like, thousands of dollars) that there is incentive to pretend alternatives don't exist.
17:01:06 <dark> NihilistDandy, google mostly talks in portuguese for this issue, but there are things like http://www.pgcon.org/2010/schedule/events/204.en.html
17:01:07 <revenantphx> MSCE?
17:01:09 <ksf> monochrom, that's adherence to powerful position by expanding one's own ignorance to subordinates.
17:01:35 <ksf> ironically, some part of them has to plan on doing that.
17:01:38 <monochrom> MCSE contains no typo.
17:02:34 <Rotsor> accel, thank you! However, quick browsing through the Graphics.SOE docs did not reveal any of usual FRP notions (behaviours/signals, event streams). I've read some of Conal Elliott works and it seems that the package 'reactive' is the most recent development in this area. However, it seems to be currently broken, and I don't think trying to fix bugs in a code I do not fully understand is a good idea. So, I'm kind of stuck.
17:02:36 <Rotsor>  On one hand, some of the older FRP libraries say "deprecated, use reactive", while on the other hand reactive does not work. :)
17:02:40 <dark> NihilistDandy, http://fosslc.org/drupal/content/postgresql-mission-critical-financial-systems has it in video, but i can't find a pdf / presentation file for it
17:02:53 <ksf> it's a common patters, applies to policitans, parents, primary school kids, you name it.
17:03:05 <Rotsor> Does anyone know if 'Grapefruit' FRP framework is usable?
17:03:23 <ksf> last time I tried, it was.
17:03:42 <jtootf> Rotsor: quite usable
17:03:49 <ksf> like yampa, it's mode of frp, while less elegant and nice, is less problematic.
17:04:12 <NihilistDandy> dark: I'll probably watch it after class. Thanks for the links.
17:04:31 <NihilistDandy> I've never known someone with such attitudes toward alternatives :/
17:05:13 <othiym23> NihilistDandy: professors get like that sometimes
17:05:36 <NihilistDandy> As if to make it more offensive, we're learning SQL through Access -_-
17:05:40 <othiym23> NihilistDandy: and learning Oracle is a huge sunk cost, people who've spent a long time working with it tend to drink the Kool-Aid pretty hard
17:05:52 <NihilistDandy> othiym23: Yeah, that's the feeling I've been getting
17:06:03 <monochrom> Access is the dying one, AFAIK but IANAL YMMV etc :)
17:06:04 <Rotsor> Access is okay :)
17:06:36 * othiym23 spent 4.5 years tending to a badly denormalized, huge Oracle instance with lots and lots of PL/SQL procedures to support
17:06:37 <NihilistDandy> lol
17:06:57 <othiym23> Access is cute and friendly and dumb
17:06:57 <Rotsor> It does have foreign keys, what else do you need to learn databases?
17:07:54 <NihilistDandy> Maybe I'd like it more if we weren't still talking about basic INSERTs in week 5
17:07:56 * NihilistDandy shrugs
17:08:03 <monochrom> haha
17:08:09 <Rotsor> lol
17:08:22 <monochrom> well a teacher has to take care of other students
17:08:54 <NihilistDandy> Yeah. I've been trying to get excited about it with some recreational set theory, but the class is such a chore
17:09:53 <NihilistDandy> Meh. I'll get through and get an A, so I suppose I have nothing to whinge about, in the end
17:10:14 <othiym23> NihilistDandy: http://www.amazon.com/dp/0123820227
17:10:37 <NihilistDandy> I'd better get extra credit for translating the Access DB into usable form on my Mac, though :D
17:10:37 <othiym23> start bringing some stuff from that into class and you'll explode your professor's brain, I guarantee it
17:11:35 <Rotaerk_> SQL for Smarties isn't good enough for me
17:11:36 <NihilistDandy> I've been reading "Applied Mathematics for Database Professionals" from Apress, so far. I'll have to look into that one, though
17:11:37 <monochrom> quotients tend to explode most students and teachers of databases
17:11:37 <othiym23> NihilistDandy: also check out http://www.amazon.com/dp/0596100124, which is likely to be a muuuch better introduction to the relational model if you're into Haskell
17:11:41 <interferon> does anybody use Clean? it has a lot in common with Haskell but i'm not aware of anyone using it
17:11:43 <Rotaerk_> I need a "for Gods" series of books
17:11:59 <interferon> monochrom: quotients?
17:12:01 <NihilistDandy> othiym23: Definitely going to check that out. I love a good O'Reilly book :D
17:12:28 <othiym23> Rotaerk_: Joe Celko is smart half the time, and a colossal dumbass (in an overly opinionated with little justification kind of way) the other half the time, but there's a lot of useful stuff, especially about range queries and quota queries, in that book
17:13:36 <othiym23> also, it's fun to ask database nerds questions about the difference between the relational algebra and the relational calculus
17:13:50 <monochrom> quotient is the maximal inverse of join. if you know Galois connections, quotient and join are galois connected. if you know adjunctions, quotient and join are adjoints of each other.
17:13:53 * othiym23 had to interview a lot of database developers for a while and is still sort of unhappy about it
17:14:04 <interferon> monochrom: *whoosh*
17:14:30 <Rotaerk_> I'm not fond of SQL; seems like databases could be nicer if they had a richer type system and query mechanisms closer to a functional language
17:14:44 <NihilistDandy> And then of course MongoDB is web scale...
17:14:51 <Rotaerk_> for instance the list of results you get back from a query, in SQL, is a flat tuple...
17:15:05 <Rotaerk_> would be nicer if the items could have more structure to them
17:15:13 <monochrom> well, suppose you have tables X,Y,Z and they satisfy X join Y = Z. suppose you say, actually Y,Z are given, you want to compute X. that's quotient.
17:15:19 <Rotaerk_> or to have sub-lists
17:15:48 <othiym23> Rotaerk_: SQL sucks, but it's pretty much what we have, since nobody's actually going to build a production-scale implementation of Industrial D anytime soon
17:16:13 <Rotsor> lol, grapefruit requires gtk<0.11, but the earliest available version on hackage is exactly 0.11
17:16:17 <Rotaerk_> Industrial D, hadn't heard of that
17:16:23 <Rotaerk_> that's not that C-like language is it
17:16:36 <NihilistDandy> Rotaerk_: http://en.wikipedia.org/wiki/D_(data_language_specification)
17:16:49 <Rotaerk_> ah..
17:16:50 <othiym23> Rotaerk_: not at all, it's CJ Date's proposed system for an RDBMS implementing a pure relational model
17:16:56 <Rotaerk_> yea different from that other D language
17:16:57 <othiym23> what NihilistDandy said
17:17:11 <NihilistDandy> Might have to grab that book, too
17:17:40 <othiym23> NihilistDandy: The Third Manifesto?
17:17:45 <NihilistDandy> Yeah
17:17:51 <Rotaerk_> it's scary how  heavy-duty database software is
17:17:59 <Rotaerk_> considering how rich the Oracle corporation is
17:18:27 <Rotaerk_> I don't see why a "production-scale implementation" of this D should be so hard
17:18:36 <NihilistDandy> Available in PostScript online. Awesome
17:18:49 <othiym23> NihilistDandy: get either Databases in Depth *or* The Third Manifesto, cuz the latter is a proper superset of the former (although the former has more veiled bitching about SQL)
17:19:15 <othiym23> Rotaerk_: trust me, when you have a lot of data and a lot of competing users of that data, this stuff gets very hard
17:19:32 <Rotaerk_> hmm yea I suppose
17:19:46 <othiym23> I used to think Oracle was a waste of money
17:19:48 <othiym23> I don't anymore
17:20:29 <NihilistDandy> Hard decision. I'll have to read the first section of each one and see which one feels nicer, I guess
17:21:11 <NihilistDandy> I'll get around to both, eventually, I'm sure
17:24:09 <othiym23> Databases in Depth is a better introduction
17:24:33 <othiym23> either way, both make it clear that in its own way, the relational model is as powerful an abstraction as the lambda calculus
17:25:37 <NihilistDandy> Good, then. Shouldn't be too bad, either way. I did awfully well in set theory :D
17:28:36 <othiym23> has anyone ever wired CoddFish into a persistency store?
17:45:16 <scooty-puff> i have c function void dbinit(void) and void dbexit(void)
17:45:28 <dark> cannot mix `$' [infixr 0] and `<?>' [infix 0] in the same infix expression
17:45:29 <scooty-puff> i was either going to add them to a custom main and call hsinit, etc.
17:45:35 <scooty-puff> or is there an easy ffi way?
17:45:41 <scooty-puff> mvars i imagine?
17:45:52 <minn> If P is a formula and x a variable not occurring in P, then P is equisatisfiable with (forall x)(P). Is there a /name/ for this statement?
17:45:54 <dark> why doesn't it make it left from right then? like 2 + 3 - 5
17:46:10 <dark> btw: can one see the operator precedence at ghci?
17:47:18 <c_wraith> dark: the :info command should show you that.  you can abbreviate that command to :i
17:47:45 <dark> nice!
17:48:46 <dark> my expression is name = lexeme $ many1 letter <?> "command name". it was name = many1 letter <?> "command name" and i used lexeme name at places (like w <- lexeme name, instead of w <- name)
17:51:40 <scooty-puff> so, any advice on how to handle ffi required init/exit calls?
17:51:51 <scooty-puff> its for a library
17:51:59 <scooty-puff> so would prefer not to put off onto client
17:54:11 <accel> I'm familiar with Monads. I don't know Moand Transformers. I'm familiar with Parsec. I'm looking for a term to Google. So with Parsec, it's trivial to write: "parseWord = do x <- many1 (noneOf "\" \n\t") >> return $ String x" ... however; suppose I want to return a TaggedString Int String; i.e. I also want to keep track of a counter along the way, how can I do this? (Reading out all the words + zipping with [1..] is not an option ; -- I need to thread a c
17:54:48 <accel> I'm familiar with Monads. I don't know Moand Transformers. I'm familiar with Parsec. I'm looking for a term to Google. So with Parsec, it's trivial to write: "parseWord = do x <- many1 (noneOf "\" \n\t") >> return $ String x" ... however; suppose I want to return a TaggedString Int String; i.e. I also want to keep track of a counter along the way, how can I do this? (Reading out all the words + zipping with [1..] is not an option ; -- I need to thread a c
17:55:32 <ksf> first off, parsec supports custom state which you can use for that
17:55:52 <ksf> but then, using parsec state is evil. I never managed to use it without getting into trouble.
17:55:55 <accel> is there a more general solution?
17:56:08 <accel> I feel this is a problem that turns up in lots of places
17:56:10 <dark> ksf, really? õ.o
17:56:12 <ksf> yes, you could parse and then add the int in a second pass.
17:56:13 <accel> and I would like to learn the most general solution.
17:56:20 <accel> I don't want to add in a second pass
17:56:23 <accel> I want to thread it through
17:56:55 <dark> second pass is costly if your input is unbounded
17:57:47 <ksf> well, at least influencing the parse with the state is evil.
17:58:07 <accel> it's not influencing the parse; it's influencing what the parse returns
17:58:24 <accel> there's some tutorial
17:58:32 <accel> on threading a coutner through a binary tree with a monad
17:58:34 <accel> but I can't find it
17:58:37 <accel> anyone know what I'm talking about?
17:59:17 <ksf> as long as you only need to keep track of a constant amount of data using parsec's state should be quite straight forward.
17:59:33 <accel> lol; there's a more general solution
17:59:40 <accel> I want to understand _that_
17:59:48 <accel> i.e. I'm saying " I want to learn how to fish "
18:00:00 <accel> and you're politely telling me " as long as you want Salmon, you can get it canned from Amazon "
18:00:22 <ksf> so you want to learn transformers?
18:00:29 <accel> fuck; time to read chapter 18
18:01:15 <monochrom> do you mean you want to re-implement all of parsec yourself?
18:01:53 <ksf> all of parsec might be a bit much, but a simple parser is quite doable and educative.
18:02:10 <minn> You can always use StateT to parse (cf. every paper on parsing), and then adding a counter is trivial.
18:02:12 <accel> no
18:02:25 <accel> I don't want to rewrite parsec
18:02:27 <scooty-puff> is there any way to register a function to be called on program exit?
18:02:31 <accel> I think learning how SateT works is what I wnat to do
18:02:41 <scooty-puff> not necessarily by exception
18:02:51 <monochrom> I do not see how "I am using parsec" and "I want to learn how to fish" are compatible to begin with.
18:02:55 <accel> scooty-puff: look into CFFI, use c's atexit
18:03:17 <accel> monochrom: I want how to thread state into parsec; not use parsec's state
18:03:23 <scooty-puff> k
18:03:50 <scooty-puff> on program exit, what can be said about a multithreaded program?
18:03:57 <accel> scooty-puff: no no, I was kidding
18:03:59 <scooty-puff> nm, i'll check the atexit doc
18:04:01 <scooty-puff> o
18:04:02 <scooty-puff> ?
18:04:22 <accel> scooty-puff: hooking into the CFFi, using it's atexit is probaly the wrong thign to do
18:04:24 <monochrom> you're entitled to want that. I have no further comment.
18:04:29 <accel> scooty-puff: it's likely the Haskell runtime has been taken down by then
18:04:36 <scooty-puff> o
18:04:40 <scooty-puff> well thats fine
18:04:42 <accel> scooty-puff: i apologize for my bad joke
18:04:56 <scooty-puff> i'm just slow..
18:05:09 <scooty-puff> the call to be made is a c call anyways
18:06:17 <scooty-puff> can it be guaranteed that the haskell system has been shut down by the atexit calls?
18:06:25 <scooty-puff> or for ghc anyways
18:06:40 <accel> I don't know
18:07:21 <scooty-puff> ok
18:07:31 <ksf> hmm
18:07:45 <ksf> darcs has a custom atexit
18:07:53 <ksf> http://hackage.haskell.org/packages/archive/darcs/2.4.1/doc/html/Darcs-Global.html
18:07:54 <scooty-puff> do many (or any) libraries required a custom main?
18:07:59 <scooty-puff> (that anyone knows of)
18:08:04 <scooty-puff> *require
18:09:55 <dark> Just actions <- swapMVar atexit_actions Nothing what means this at a do block? (that Nothing would yield a pattern failure, thus hijacking the atexit?)
18:10:06 <dark> http://hackage.haskell.org/packages/archive/darcs/2.4.1/doc/html/src/Darcs-Global.html#atexit
18:12:56 <mun> in logic, is f a "term" in the expression f(a) = 0?
18:13:46 <monochrom> really depends on whose logic.
18:14:10 <mun> monochrom, hmm like whose?
18:14:52 <dark> is 0 a truth value?
18:15:11 <dark> if yes then f is a predicate
18:15:25 <dark> and =, another predicate
18:15:42 <mun> yes it is
18:15:42 <dcolish> I'm getting pretty confused by the ByteString docs. it's not very clear how I'd create a bytestring from lets say a [Char] or Char?
18:16:04 <ksf> pack
18:16:10 <dark> if not, then f(a) = 0 would be an 'atomic' proposition (at least in the little logic i was taught)
18:16:10 <ksf> :t pack
18:16:11 <lambdabot> Not in scope: `pack'
18:16:15 <ksf> :t BS.pack
18:16:16 <mun> i'm thinking in HOL
18:16:16 <lambdabot> [Word8] -> BSC.ByteString
18:16:26 <monochrom> in HOL f is a term
18:16:30 <dcolish> pack's not quite right
18:16:31 <mun> so it's fine to call 'f' a term of the expression 'f(a) = 0'
18:16:34 <ksf> > BSC.pack "hello, #haskell"
18:16:35 <lambdabot>   "hello, #haskell"
18:16:44 <mun> i see. thanks.
18:16:50 <dcolish> hmm
18:17:31 <ksf> doing that will truncate everything that doesn't fit into 8 bits, though.
18:17:44 <ksf> if you want proper unicode there's e.g. Data.Text
18:18:03 <monochrom> presumably you use Data.ByteString.hGetContents to get your initial bytestring. as opposed to System.IO.hGetContents to get a String and then pack.
18:18:17 <ksf> ...and you can also use {-# LANGUAGE OverloadedStrings #-}
18:18:28 <dcolish> well i'm reading in compressed content
18:18:42 <dcolish> but I'm trying to pack a bytestring to use for comparisons
18:18:56 <monochrom> then presumably the decompressor deals with bytestrings too and never goes through String
18:19:00 <dcolish> there is
18:19:06 <dcolish> err yes it does
18:19:36 <dcolish> but I am introducing a new string to look for in that bytestring
18:19:57 <monochrom> then pack. good for hardcoded string literals
18:20:30 <dcolish> thats what i expected to work, but this is what I get http://hpaste.org/44045/bs_pack
18:21:05 <monochrom> :m Data.ByteString.Char8
18:21:33 <dcolish> ah, hmm
18:21:38 <monochrom> I hope you are aware that there are altogether 4 packs.
18:23:11 <dcolish> not in the slightest bit aware
18:23:37 <monochrom> buy 1 get 3 free
18:23:50 <dcolish> haha
18:23:52 <dcolish> is there any overview documentation on bytestrings?
18:24:13 <dcolish> i looked around but havent seen anything aside from the hoogle docs
18:25:23 <xplat> 19:17 < Younder> Peaker, I have written 5 recursive decent compilers in the  past.
18:25:26 <ksf> there's the paper, which is mostly about the fusion scheme, and then there's the source.
18:25:47 <monochrom> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html probably counts
18:25:50 <xplat> i think that pretty much sums it up
18:26:56 <monochrom> why don't you leave Younder alone? I don't want another parser pissing war
18:27:05 <dcolish> ok cool thanks!
18:28:18 <cads> hi, I'd like to make some code that takes a set of propositional logic literals and a spits out a texified semantic tableaux proving whether the set is consistent, and I was wondering where to start
18:29:01 <cads> it seems like the part that parses the input, the part that constructs the truth tree, and the part that generates text from the truth tree, are all significant chunks
18:29:42 <cads> and there I'd start with the parser
18:31:29 <cads> but I think first I must work on representing expressions so that I have a target for my parser
18:31:45 <cads> any recommendations here?
18:31:48 <ksf> depends.
18:32:01 <ksf> you can just do an ADT, and not a proper internal representation.
18:32:10 <ksf> if you do an ADT, it falls out of the parser.
18:32:50 <ksf> er I mean AST
18:33:04 <ksf> I'd expect you to use a G(ADT)...
18:33:11 <djahandarie> All these damn acronyms!
18:33:11 <ksf> (G)ADT, even.
18:33:29 <ksf> nah, it's just a tla.
18:35:03 <minn> A little late: f would not be an atomic proposition with the usual naming conventions, but a function. That is, it just picks out members of your domain. So an instance of f would be a constant. In general, at omic propositions are prediates, not functions or constants.
18:35:27 <cads> ksf, would that be something like type Expr = Neg Expr | And Expr | Or Exp | Imp Expr | Equi Expr | Atom Char?
18:36:18 <cads> minn, I don't quite understand what you mean - are you talking about representing expressions as truth functions?
18:37:56 <dark> there is at System.IO a BufferMode type with constructor NoBuffering. I want to do a restricted import, for importing just this constructor, or just this type (plus hSetBuffering and stdout identifiers). how to do it?
18:38:06 <cads> I could have a  Expr -> TruthFunctional function which generates a n-parameter truth function from an n-variable expression
18:38:25 <cads> I'll play around with it
18:38:34 <xplat> Oracle's awesome, if dump trucks back up to your house and unload huge piles of money on your lawn every morning and you need to find some way to get rid of it so it doesn't kill the grass
18:38:35 <ksf> cads, looks fine from here.
18:38:40 <monochrom> import System.IO(hSetBuffering, stdout, BufferMode(NoBuffering))
18:38:57 <dark> oh, thanks
18:39:02 <minn> I saw the question: "is f a term in the expression f(a) = 0". The usual conventions are that small letters denote functions and large letters denote relations (predicates), and that terms are either constants or functions and atomic propositiosn are relations (predicateS). So 'f(a) = 0' is an atomic proposition containing terms f and 0 and the variable a.
18:39:32 <minn> or constant a, depending on your domain.
18:40:05 <ksf> cads, no, it doesn't, I bilieve most of those are binary ops.
18:41:09 <ksf> cads, what I'm talking about is having a 1:1 correspondance between input syntax and your first ADT in the pipeline.
18:41:27 <dark> how to load multifile programs into ghci?
18:41:49 <ksf> then figure out what you need to feed the solver, and transform the adt accordingly. separation of concerns.
18:41:50 <monochrom> :load X.hs Y.hs Z.hs
18:42:08 <monochrom> note that "loading" is different from "scoping".
18:42:10 <dark> yes, but.. can't ghci figure out on its own?
18:42:19 <dark> scoping?
18:42:28 <ksf> ...the middle parts of the pipeline are always the hardest ones.
18:42:38 <cads> ksf, what would that entail if my language just had the symbol '&' and variables 'a' .. 'z' ?
18:42:43 <aavogt> it does figure out which files to load if they are named correctly, and in the right paths
18:42:43 <monochrom> scoping refers to which identifiers are visible at the prompt
18:42:51 <dark> btw it opened X.hs, but not Y.hs
18:43:03 <monochrom> yes, "scoping" is "opening"
18:43:07 <dark> yes, i think it didn't bring Y.hs to scope
18:43:07 <monochrom> :m X Y Z
18:43:19 <ksf> data Expr = Expr `And` Expr | Var Char
18:43:27 <cads> ksf, did you say that my ADT specification looked ok? I'm actually not sure if what I did was an ADT or some more mundane type :D
18:43:34 <ksf> ...provided you want to nest them.
18:43:40 <monochrom> see http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope
18:43:44 <dark> hm. but Y isn't a module
18:43:44 <ksf> 'cos otherwise the whole thing gets boring.
18:43:59 <cads> ah, that looks rather nice
18:44:01 <monochrom> :m X Main Z
18:44:30 <monochrom> actually, :module + X Main Z
18:44:35 <dark> wow
18:44:39 <cads> in fact, more than nice - I really like how the `And` can be used as infix even in the type declaration - that's panache :)
18:44:52 <monochrom> "Y isn't a module" = "Y is a module called Main"
18:45:33 * ksf spent too much time with HList etc. not to know such tricks...
18:45:36 <dark> in the end :m Main then typing main works like ghci --make .. ; ./interpreter. i just don't know how to exit o.o (at my interpreter i exit with EOF, like, ctrl+d)
18:46:00 <monochrom> EOF or :quit
18:46:00 <ksf> formatting types properly is an underappreciated task.
18:46:59 <monochrom> if your Y.hs is your Main and it imports enough, you can just :load Y.hs
18:47:02 <ksf> ghci uses ex syntax, which is the only right thing to do.
18:47:04 <dark> anything i type, is just consumed by my main (I'm running a repl loop there) and C-d doesn't work
18:47:44 <ksf> dark, try C-c and then add a quit command to your repl
18:47:45 <dark> maybe it's because i'm on C-c C-b from emacs mode? (but i don't think emacs itself is kidnapping that keybinding)
18:48:03 <monochrom> C-c C-d
18:48:06 <dark> adding a quit command, hmm, that would work
18:48:17 * ksf heard bad things about the emacs terminal emulation
18:48:35 <monochrom> not terminal emulation to begin with
18:48:44 <dark> C-c C-c works as interrupt
18:49:00 <monochrom> which means "emacs terminal emulation bad" is a kind of strawman attack
18:49:36 <ksf> how can the means be bad, when the cause is just?
18:49:47 <dark> (this is ctrl+c, not ctrl+d though). and hm i had issues with keybindings (like emacs kidnapping ESC..) but i'm using now a terminal mode with sane bindings (multi-term). and C-d works there
18:50:23 <monochrom> again, C-c C-d is your EOF
18:51:31 <xplat> is there something like Data.Text that uses UTF8 instead of UTF16 as internal form?
18:51:53 <ksf> utf8-string?
18:52:09 <dark> ooh. the problem is, if i run my app at ghci, I can't exit it and go back to ghci with EOF at all. I have to exit with C-c
18:52:28 <ksf> utf8 has its deficiencies, though.
18:52:33 <monochrom> arguably bytestring already uses utf8, except that the functions don't do utf8
18:52:33 <dark> (C-d was working, but when running it compiled, standalone)
18:53:07 <ksf> what you gain in memory footprint you may very well lose in time because you don't know where the ith character is, anymore.
18:53:13 <dark> xplat, is any default haskell library tied to utf16 in any way?
18:53:34 <ksf> Char is defined to be "a unicode code point"
18:55:05 <dark> isn't an utf-16 char a bit less than that?
18:55:20 <ksf> iirc, yes.
18:55:35 <dark> there are unicode chars that need to be defined by two utf-16 chars
18:55:39 <Draconx|Laptop> utf-16 can encode the full range of unicode code points.
18:56:09 <ksf> is it leaving out combinated things?
18:56:14 <dark> but some code points will have to be represented by two utf-16 chars, right?
18:56:33 <Draconx|Laptop> dark, some code points are represented as four octets in utf-16, yes.
18:56:34 <othiym23> some Unicode characters have multiple representations utilizing composing forms
18:56:50 <xplat> ksf: that is true of UTF-16 as well, and for latin languages you use twice the space
18:57:16 <Draconx|Laptop> dark, everything in the basic multilingual plane (BMP) takes two octets in utf-16, and everything outside of the BMP takes 4.
18:57:25 <xplat> dark: default haskell libraries aren't, but Data.Text is
18:57:30 <dark> i think a Char would be isomorphic to a utf-32 char (right now)
18:58:03 <Pseudonym> Text is hard.
18:58:05 <Draconx|Laptop> dark, contrast with utf-8, where the majority of the BMP takes 3 octets to encode.
18:58:11 <xplat> there's only one kind of unicode character
18:58:34 <xplat> but mostly you deal in code points at this level
18:58:35 <dark> I meant, I think a Char can represent a char outside the BMP
18:59:31 <monochrom> this is why when you do "average case complexity" you should almost never assume the uniform distribution.
19:00:21 <Pseudonym> monochrom: Yeah, that bit me a couple of months ago.
19:01:08 <xplat> UTF8 is a big gain for most languages written with a latin alphabet, is pretty much a wash vs UTF-16 for greek and cyrillic, and is rather poor for most other common scripts, especially CJK.  but it's as good or better as UTF16 for scripts and other repertoires that are totally outside the BMP
19:01:33 <dark> can someone help me to pick one of the 3 options of auto-indentation on the emacs mode?
19:01:44 <Draconx|Laptop> xplat, outside the BMP, both utf-8 and utf-16 take exactly 4 octets per code point.
19:01:47 <dark> haskell-indentation, haskell-indent, haskell-simple-indent
19:02:14 <monochrom> haskell-indentation.
19:02:39 <xplat> Draconx|Laptop: ah, my memory wasn't sure exactly how high 3 bytes went.  but, it's still better in that you never have to deal with endian issues.
19:02:50 <othiym23> haskell-indentation++
19:03:41 <monochrom> endian is why I am skeptic of utf-16 in communication
19:04:01 <Draconx|Laptop> xplat, you only need to deal with endian issues at the moment the data is read or written to a storage or communication medium.
19:04:34 <Draconx|Laptop> which is kind of irrelevant in a discussion about internal representations.
19:04:39 <ksf> or when dealing with americans.
19:04:46 <dark> (how to make it default?) everytime i do some haskell, i figure out that indentation is messed up, go to C-h m, see the options and pick one at random
19:04:48 <ksf> they can't even decide between big and little endian.
19:04:57 <monochrom> also I write most web pages in english, of course.
19:05:47 <shachaf> Why would you use UTF-16? UTF-32.
19:05:50 * ksf wouldn't be surprised to see them using 05/2011/21
19:06:02 <dark> hm (add-hook haskell-mode-hook 'turn-on-haskell-indentation)
19:06:06 <Draconx|Laptop> shachaf, UTF-32 doubles the size of most text over UTF-16 for very little gain.
19:06:44 <monochrom> (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
19:06:45 <shachaf> Draconx|Laptop: Fixed-width characters is a gain. :-)
19:07:00 <shachaf> Otherwise just use UTF-8.
19:07:01 <xplat> UTF-32 is the worst of all worlds.  makes it easy to randomly index by codepoints but that's not a terribly useful operation on unicode text to begin with
19:07:24 <Draconx|Laptop> shachaf, except it isn't, as far as unicode is concerned.
19:08:07 <shachaf> Why not?
19:08:08 <Draconx|Laptop> shachaf, you still need to deal with combining chars, nonprinting chars, fullwidth chars, non-canonical representations of characters, etc.
19:08:10 <ksf> variable-length encodings are a bugger to chunk up into pieces.
19:08:28 <xplat> code point boundaries in themselves don't have very much semantic significance in unicode
19:09:15 <shachaf> Eh. Combining chars.
19:09:33 <shachaf> What if you want to e.g. compute Levenshtein distance?
19:09:36 <shachaf> Or some operation like that.
19:09:51 <ksf> you normalise
19:10:02 <xplat> levenshtein distance is computed with dynamic programming in a separate array
19:11:32 <monochrom> frankenstein distance is computed with preserved human brains
19:11:48 <pyrony> what about dubya distance?
19:12:13 <xplat> adapting it for multibyte codings as simple as UTF is easier than writing a case-insensitive compare on unicode strings (and that's assuming you know what language you'll be comparing up front)
19:14:11 <xplat> my experience with writing algorithms on unicode strings is that the advantages of a fixed-width-per-code-point encoding range from negligible to nil
19:15:46 * ksf wonders where that sht in levenshtein comes from.
19:15:59 <ksf> it's definitely a german name, and the proper spelling would be levenstein
19:16:54 <Draconx|Laptop> ksf, it's Russian.
19:16:54 <ray> got mangled somewhere in between cyrillic and here
19:17:09 <ksf> Левенште́йн
19:17:39 <ray> the guy is russian, the name is german
19:17:48 <ray> kinda like i'm american but my name is cornish
19:17:56 <ksf> well, considering that at some time, st was transliterated to шт, and that's cromulent as that's how cyrillic works, the fubar is in the round-trip.
19:18:24 <ray> cyrillic is hard ok don't blame me :(
19:18:40 <ksf> no it isn't, absolutely not.
19:18:55 <ksf> ш is the sound sh and т is the sound t
19:19:13 <ksf> cyrillic doesn't work with combinations.
19:20:45 <ksf> the only gotcha are 'o's which are pronounced 'a' due to a sound shift (unless you're from a backwater village) and the yo/ye distinction which isn't commonly indicated
19:21:00 <ksf> ...but can be inferred if you grok russian phonology.
19:24:50 <ksf> hmm. must have been quite early immigration (pre-last german sound shift) or his ancestors came from low german regions, leven -> leben = life, that is, he's called "lifestone".
19:25:12 <ksf> -stone names are usually jewish
19:25:29 <ksf> and now I'm going to stop as I wanted to go to bed some 2 hours ago.
19:28:41 <dark> can't deriving Read derive a case-insensitive version?
19:29:46 <dark> it is just data X = A | B | C .. and i want a function String -> X, but case-insensitive. (I can write myself, but it is not as cool as deriving)
19:30:11 <aavogt> use the derived instance, but make a function which properly capitalizes
19:30:35 <dark> that's a great idea, thanks
19:30:36 <aavogt> something like:       \(x:xs) -> read (toUpper x : map toLower xs)
19:31:19 <aavogt> I don't think it's going to work if you need the function to be called read
19:31:29 <dark> but since deriving will create a Read instance, how can I overwrite it with my own?
19:31:34 <dark> yes
19:31:56 <aavogt> I think you'd have to make a newtype
19:32:09 <dark> what do you mean?
19:32:31 <dark> like newtype AnotherX = X and then make an instance for AnotherX?
19:32:57 <monochrom> sorry, "deriving Read" gives you case-sensitive code, there is no cure.
19:33:18 <Jafet> An interesting ailment
19:33:49 <ray> WHAT IF YOU HAVE THINGS THAT CAPITALIZE WEIRD LIKE ß -> SS
19:33:56 <mm_freak> one thing confuses me about Data.Enumerator.Binary:  take, takeWhile, drop and dropWhile return /lazy/ ByteStrings…  don't you face the same problem as with lazy IO then?
19:34:07 <dark> lol
19:34:11 <aavogt> or maybe if you have        data Dummy; data X a = A | B | C; deriving instance Read (X Dummy); instance Read (X a) where read (x:xs) = read $ toDummy $ (toUpper x : map toLower xs) 
19:34:14 <Jafet> Or the three greek sigmas
19:34:25 <aavogt> and the toDummy :: X a -> X Dummy
19:34:42 <ray> i wonder how haskell fudges that one
19:34:45 <aavogt> and you probably have to implement reads instead of read
19:34:52 <ray> > toUpper 'ß'
19:34:53 <lambdabot>   '\223'
19:35:11 <monochrom> > char (toUpper '\223')
19:35:12 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
19:35:19 <monochrom> onoes
19:35:36 <Jafet> Mmm, fudge
19:35:44 <monochrom> > text "\223"
19:35:44 <ray> um ok i guess
19:35:45 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
19:35:45 * aavogt wonders if the suggested overlapping instance actually works
19:35:50 <monochrom> I fail
19:36:01 <ray> i know Data.Text does ß to SS correctly because it gives that specific example in the documentation
19:36:14 <dark> ... i was also thinking in having them ordered (with deriving Ord) and make partial matching using the ordering as precedence (like data Command = West | Who | Whois) and then I would have w, we, wes, west mapped to west, wh and who mapped to who, whoi and whois mapped to whois, with mixed case
19:36:28 <ksf> ray, fsvo "correctly".
19:36:44 <aavogt> ray: try them all
19:36:44 <Draconx|Laptop> ray, the language-dependent conversions are fun, too.
19:36:56 <monochrom> > 'ß' == '\223'
19:36:57 <lambdabot>   True
19:37:03 <rwbarton> is utf8-string a viable alternative to Text? (as performant, well supported, etc.)
19:37:05 <ksf> at least as common is just keeping it lower case, and recently there's been talk about just doing an uppercase one.
19:37:11 <dark> i can write a general code for that, but managing two lists for the same set of strings isn't fun
19:37:16 <rwbarton> I've been wondering about the "UTF-8 version of Text" question also.
19:37:19 <monochrom> > text "∀"
19:37:20 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
19:37:27 <ray> there's a capital ß in unicode now i think
19:37:38 <Jafet> dark: suppose you could use a preprocessor
19:38:00 <monochrom> someone broke lambdabot utf8 support
19:38:20 <dark> Jafet, yes. I think haskell should have simple, built-in functions for returning the list of constructors of a type, etc. (maybe ghc libraries offer that?)
19:38:27 <ksf> I'd even go so far and capitalise it as ſs
19:38:49 <Jafet> dark: they're just names, they don't exist
19:38:49 <ray> ẞ
19:38:49 <ksf> it's a bleeding ligature, after all. all german special characters are ligatures.
19:39:02 <accel> I just realized, instead of if ...
19:39:05 <Jafet> But you can probably get them with TH or cpp
19:39:13 <accel> I could write "myif True = ...; myif False = ..." mind = blown
19:39:21 <accel> TH = awesomeness
19:39:23 <dark> Jafet, but the compiler could offer that (by creating the binding himself)
19:39:27 <ray> unicode is a bit schizophrenic about whether to encode ligatures
19:39:28 <accel> is there a template-haskell channel?
19:39:35 <rwbarton> I think the Data typeclass may also give you the constructor names
19:39:45 <Jafet> dark: except the compiler doesn't
19:39:49 <aavogt> accel: this channel?
19:40:38 <ray> if people know template haskell they are probably in #haskell
19:40:45 <rwbarton> (or for your Command example you could derive Enum, Bounded and Show)
19:41:34 <Jafet> rwbarton: I approve of your disgusting ideas
19:41:56 <dark> .. hm, but it could, plus my understanding of haskell is very poor
19:42:11 <aavogt> @hoogle constr
19:42:11 <lambdabot> Data.Data data Constr
19:42:11 <lambdabot> Data.Data constrFields :: Constr -> [String]
19:42:12 <lambdabot> Data.Data constrFixity :: Constr -> Fixity
19:42:26 <dark> rwbarton, yes I can derive enum, bounded, and show, and.. hm..
19:42:31 <dark> constr?
19:42:36 <dark> tell me more
19:42:44 <dark> also is Typeable related to that?
19:42:53 <aavogt> > toConstr (Just 5)
19:42:54 <lambdabot>   Just
19:42:57 <dark> what's a Constr?
19:43:15 <rwbarton> constructors = [(show x, x) | x <- [minBound .. maxBound]]
19:43:31 <aavogt> > toConstr (M.singleton 2 True)
19:43:32 <lambdabot>   *Exception: toConstr
19:43:33 <rwbarton> > [(show x, x) | x <- [minBound .. maxBound]] :: [(String, Bool)]
19:43:33 <dark> rwbarton, @_@
19:43:33 <lambdabot>   [("False",False),("True",True)]
19:43:39 <dark> awesome!
19:43:51 <dark> now about this constr..
19:44:05 <Jafet> > map toConstr [minBound..maxBound :: Ordering]
19:44:06 <lambdabot>   [LT,EQ,GT]
19:44:07 <rwbarton> As long as you just have constructors with no arguments that will work
19:44:18 <dark> yes, that's my intention!
19:44:56 <rwbarton> Right, then you don't need anything more than deriving (Enum, Bounded, Show) -- and whatever else you want like Eq, Ord
19:45:14 <dark> and then I define Read my way
19:45:22 <aavogt> there is also template haskell for trying to write instances (as opposed to using the Data instance which ghc can derive)
19:45:27 <dark> why Bounded?
19:45:40 <rwbarton> for minBound and maxBound
19:45:58 <lapsu> is there a good way to run a list of quickCheck properties instead of calling quickCheck over and over for each property?
19:46:04 <rwbarton> perhaps you don't need it
19:46:17 <rwbarton> > [(show x, x) | x <- [toEnum 0 .. ]] :: [(String, Bool)]
19:46:18 <lambdabot>   [("False",False),("True",True)]
19:46:22 <rwbarton> > [(show x, x) | x <- [toEnum 0 .. ]] :: [(String, Ordering)]
19:46:23 <lambdabot>   [("LT",LT),("EQ",EQ),("GT",GT)]
19:46:37 <rwbarton> :t [(show x, x) | x <- [toEnum 0 .. ]]
19:46:38 <lambdabot> forall a. (Enum a, Show a) => [(String, a)]
19:46:52 <dark> so you saying I won't need http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Data-Data.html#7 ?
19:46:54 <rwbarton> that's better I suppose
19:46:57 <rwbarton> Right
19:47:32 <rwbarton> If you wanted to do something with constructors with arguments, then you couldn't derive Enum and would have to do something more complicated involving Data
19:47:46 <dark> oh right right =)
19:47:54 <rwbarton> (Also, you'd have other issues if your constructors weren't all of the same type)
19:49:59 <dark> .. why does read throws an exception? (so code that uses read.. what should it do if there is no way for guaranteeing reading will work?)
19:50:10 <rwbarton> use reads
19:50:30 <Jafet> Make sure your parsing table is a caf
19:50:36 <dark> caf?
19:50:47 <dark> i would expect read to be of type Read a => String -> Maybe a
19:51:02 <rwbarton> Also, it's frowned upon by some to define a read instance that isn't equivalent to the derived one
19:51:19 <aavogt> who cares about performance
19:51:20 <dark> reads is whitespace-separated, many reads?
19:51:22 <Jafet> reads has the type Read a => String -> [(a, String)], which is even better
19:51:58 <dark> but i want to do just one read, not many. (but maybe it doesn't matter, i get the first and then ignore the rest..)
19:52:31 <rwbarton> Although in this instance yours will be an extension of the derived one, so perhaps it's more acceptable
19:52:49 <Jafet> The list is ostensibly for ambiguous parses. Usually reads will return a one-element list.
19:53:01 <dark> rwbarton, read is supposed to be like lisp's read, like, it reads exactly what would be accepted by the interpreter/compiler of the language, right?
19:53:12 <dark> but haskell has no eval, so it isn't much useful..
19:53:14 <rwbarton> That's what many people say.
19:53:32 <aavogt> maybe you need a hint
19:53:35 <rwbarton> Personally, I would say, especially if you're writing an application and not a library, do whatever makes sense to you
19:53:47 <Jafet> read is much stricter than that. The Report gives the precise semantics.
19:53:53 <Jafet> Derived read, that is.
19:55:04 <dark> Jafet, but, if reads is derived from Read, how can it be ambiguous?
19:55:44 <Jafet> It doesn't have to be. In your case, you could have reads "w" = [(Wut,""), (Wtf, "")]
19:55:59 <Jafet> That's what my grandma told me, at least
19:56:14 <aavogt> derived reads ones seem to be unambiguous
19:56:33 <monochrom> you are free to write your ambiguous Read instance
19:56:40 <dark> > reads "0 1" :: [(Int, String)]
19:56:41 <lambdabot>   [(0," 1")]
19:56:56 <dark> monochrom, how? =)
19:57:24 <Jafet> instance Read T where
19:57:27 <Jafet> Now your turn!
19:57:47 <monochrom> I'm too lazy to do it. But perhaps reads "11" = [(1, "1"), (11, "")]
19:58:42 <dark> so while defining Read, I could define reads, instead of read?
20:00:11 <monochrom> in fact you're supposed to define readsPrec
20:00:35 <dark> but i can get away defining just read?
20:00:40 <monochrom> no
20:00:47 <dark> oh
20:01:24 <monochrom> read and reads are not even class methods of Read
20:01:49 <dark> readsPrec receives an.. int? oO
20:02:00 <Jafet> That's the Prec.
20:02:05 <monochrom> operator precedence
20:04:09 <dark> ok, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
20:05:06 <dark> .. so actually, read is "slow"?
20:05:20 <dark> type ReadS a = String -> [(a, String)] Note that this kind of backtracking parser is very inefficient; reading a large structure may be quite slow (cf ReadP).
20:05:46 <Jafet> Buy a faster computer
20:06:01 <dark> no, just asking
20:06:23 <Jafet> Well, if it's too slow for you, do something else.
20:06:25 <dark> also, discovered that even if one has lots of partial reads, "read" will return only if there is one that consumes all the input
20:06:49 <monochrom> it means if you actually use ambiguity, slow.
20:07:06 <dark> oh fine
20:07:13 <Jafet> http://hackage.haskell.org/trac/ghc/ticket/1544
20:07:21 <Jafet> It's usually not that slow.
20:07:43 <monochrom> also you have only discovered that ghc's Read instances return only if there is one that consumes all the input.
20:08:07 <monochrom> or perhaps the standard haskell Read instances
20:08:52 <aavogt> > reads "123     " :: [(Int,String)]
20:08:53 <lambdabot>   [(123,"     ")]
20:09:16 <dark> > read "123   " :: Int
20:09:17 <lambdabot>   123
20:09:22 <monochrom> you haven't discovered that my evil instance for my evil data type uses ambiguity and does not only return the answer that consumes all the input
20:09:27 <dark> oh, ..
20:10:20 <dark> the docs says "The read function reads input from a string, which must be completely consumed by the input process."
20:10:56 <monochrom> I personally think reads "123" = [(123,"")] is a arbitrary pragmatic choice, not the only valid choice in principle
20:11:51 <dark> but "123   " leaves those whitespace unconsumed (as the reads output shows)
20:12:04 <monochrom> > read "123 " :: Int
20:12:05 <lambdabot>   123
20:12:11 <monochrom> > read "123 a" :: Int
20:12:12 <lambdabot>   *Exception: Prelude.read: no parse
20:12:22 <monochrom> that is what you are reading from the doc
20:12:30 <monochrom> > read "123a" :: Int
20:12:31 <lambdabot>   *Exception: Prelude.read: no parse
20:12:35 <monochrom> but note:
20:12:53 <monochrom> > reads "123a" :: [(Int,String)]
20:12:54 <lambdabot>   [(123,"a")]
20:13:11 <monochrom> > reads "123   a" :: [(Int,String)]
20:13:12 <lambdabot>   [(123,"   a")]
20:13:30 <monochrom> there is something in read that also skips spaces. this is not part of reads.
20:13:37 <dark> > reads "123 a", reads "123 " :: ([(Int,String)], [(Int,String)])
20:13:38 <monochrom> > "read" == "reads"
20:13:38 <lambdabot>   <no location info>: parse error on input `,'
20:13:39 <lambdabot>   False
20:13:49 <dark> erm
20:13:55 <dark> > (reads "123 a", reads "123 ") :: ([(Int,String)], [(Int,String)])
20:13:55 <lambdabot>   ([(123," a")],[(123," ")])
20:14:04 <dark> oh. o.o
20:14:34 <dark> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Read.html#read
20:14:56 <dark> do x <- readPrec lift P.skipSpaces return x
20:18:54 <dark> now I have to figure out how this readPrec works. the examples I see are very threatening (one at the ghc page involves infix constructors, and I want to parse enums..)
20:19:27 <monochrom> if you have no infix constructors, clearly you have no operator precedence, and you just ignore that parameter
20:19:34 <dark> maybe I should just ignore the precedence? (it seems that the haskell uses it to differentiate between read vs reading with parens, etc)
20:19:40 <dark> oh.
20:19:46 <dark> lol, =)
20:20:42 <monochrom> and so it does take an example full of infix constructors to illustrate the point of precedence
20:22:25 <rwbarton> You can, of course, just write your own parser function which isn't part of the Read class
20:24:30 <dark> @hoogle toUpper
20:24:31 <lambdabot> Data.Char toUpper :: Char -> Char
20:25:45 <dark> so actually a, b isn't an expression, and i need parens like (a, b) ?
20:26:01 <dark> thinking about it, it makes sense, when , is also used for lists..
20:26:05 <adu> dark: yes
20:26:15 <adu> dark: "," means nothing in Haskell
20:26:46 <adu> dark: (,) is a tuple constructor and [,] is a list constructor
20:27:03 <dark> i feel good when i can omit the () from tuples
20:27:07 <dark> for some reason
20:27:12 <adu> dark: what? why?
20:27:21 <dark> i don't know
20:27:26 <adu> dark: in that case, use Python, or Go
20:27:39 * adu <3 Go
20:27:44 <dark> no, in ocaml. maybe it's because people from #ocaml says that omitting () is bad practice
20:27:56 <dark> (and it doesn't work everywhere anyway)
20:28:36 <adu> anyways, Go only requires () for return types
20:29:02 <adu> i.e. func DivMod(int, int) (int, int);
20:29:08 <blackdog> dark: it's a ruby thing too.
20:29:14 <Jafet> > (,,) ((,) 1 2) ((,) 3 4) ((,,,) 5 6 7 8)
20:29:15 <lambdabot>   ((1,2),(3,4),(5,6,7,8))
20:29:21 <dark> in ruby one can omit the () from function application, but not the ,. so the syntax for application is a(b, c) or a b, c. if there is only one parameter i can write it as functional programming: a b. i feel good also, but it is short lived, since functions aren't curried and i always get confused in the a b c vs. a b, c thing
20:29:54 <blackdog> dark: ruby makes a lot of dubious compromises for syntactic flexibility :)
20:29:59 <monochrom> watch I, Robot
20:30:03 <adu> wow, brain, explode
20:30:06 <dark> yes, that's what i feel
20:30:14 <monochrom> you mean: wow brain, explode
20:30:16 * blackdog quickly checks to make sure none of his ruby peeps have followed him in here
20:30:21 <adu> no wow, brain explode
20:30:23 <dark> monochrom, I, robot?
20:30:29 <dark> i think i watched but not sure
20:30:43 <monochrom> I'm just playing with Ruby syntax
20:30:50 <adu> monochrom: lol
20:30:52 <Jafet> @vixen do you want to watch I, Robot?
20:30:53 <lambdabot> sure, i want to plenty
20:30:58 <monochrom> hard to find a movie name with a comma
20:31:07 <blackdog> paris, texas
20:31:22 <monochrom> burn paris, texas
20:31:26 <stepcut> back, to the future
20:31:51 <adu> > (,) 1 2
20:31:52 <lambdabot>   (1,2)
20:31:53 <dark> oh slowness on my part
20:31:58 <adu> > ((,),) 1 2 3
20:31:59 <dark> > (, 2) 3
20:31:59 <lambdabot>   Illegal tuple section: use -XTupleSections
20:32:00 <lambdabot>   Illegal tuple section: use -XTupleSections
20:32:14 <monochrom> you are illegal!
20:32:21 <djahandarie> Everyone wants that on but I think there is some reason it can't be turned on
20:32:25 <adu> > (,(,)) 1 2 3
20:32:26 <lambdabot>   Illegal tuple section: use -XTupleSections
20:32:35 <djahandarie> Where is Cale these days anyways? I feel like I haven't seen him around
20:32:37 <blackdog> i've always loved those messages
20:32:38 <djahandarie> @seen Cale
20:32:38 <lambdabot> Unknown command, try @list
20:32:38 <preflex>  Cale was last seen on #haskell 12 hours, 20 minutes and 8 seconds ago, saying: My sentence structure sucks, I'm probably tired. :)
20:32:51 <blackdog> "you're a bad boy, you shouldn't do that. here's how to trick me and do it anyway"
20:32:55 <dark> i think that lambdabot should just ignore unknown commands
20:33:13 <dark> at least on public channels
20:33:40 <adu> aha
20:33:54 <monochrom> no, it should spam the offender, using "notice" no less
20:34:02 <adu> > (,) 1 $ (,) 2 3
20:34:03 <lambdabot>   (1,(2,3))
20:34:23 <Jafet> seen is a real command, but disabled
20:34:36 <monochrom> some people know that "notice" becomes an annoying dialog box for some clients. I exactly want that.
20:34:45 <adu> @pl \ x y z -> (,) x $ (,) y z
20:34:45 <lambdabot> (. (,)) . (.) . (,)
20:34:51 <dark> I had a lot of ruby functions defined with def a b but no more. I'm sticking to def a(b) for mental health concerns
20:35:18 <adu> @pl \ x y z -> (,) ((,) x y) z
20:35:19 <lambdabot> ((,) .) . (,)
20:35:38 <dark> or due to (unsure)
20:36:14 <adu> @pl \ w x y z -> (,) ((,) ((,) w x) y) z
20:36:15 <lambdabot> ((((,) .) . (,)) .) . (,)
20:36:45 <monochrom> <twitter_junkie> @Cale thanks for everything  <dialog box> Unknown command. [OK]  <dialog box> Unknown command. [OK]  <dialog box> Unknown command. [OK]  <dialog box> Unknown command. [OK]  
20:40:14 <dark> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html has lots of instances for tuples. can't someone generalize tuple instances? (is there some progress for quatifying over varied tuples?) because, those tuples are basically Read instances for type (Read a, Read b, ..) => (a, b, ..)
20:40:48 <dark> one can inductively define infinite instances following this pattern (I know, my questions are mostly useless, random and usually i can't understand the answer)
20:41:05 <aavogt> you can probably substitute nested tuples instead
20:42:20 <dark> but lots of type classes define those instances, and it feels like both overdoing it (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m, Read n, Read o) => Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o), and missing something
20:42:27 <monochrom> there is progress but people prefer to direct that progress to arbitrary user-defined data type because beyond a certain point those tuples are not used
20:45:25 * hackagebot warp 0.3.2.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.3.2.2 (MichaelSnoyman)
20:46:08 <rwbarton> in the case of Read, those instances are part of the language definition, and you're just looking at how GHC decided to implement that
20:47:14 <dark> so the haskell definition consider tuples up to (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
20:47:47 <dark> (for Read)
20:48:23 <accel> http://hpaste.org/44048/reinvent <-- what did I just reinvent here with "myMap ?
20:48:24 <rwbarton> from the Report: "Every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show."
20:48:36 <accel> http://hpaste.org/44048/reinvent <-- what did I just reinvent here with "myMap :: [State Val] -> State [Val]" ?
20:48:55 <dark> so a tuple of size 16 isn't even guaranteed to work at all?
20:49:15 <accel> dark: nest the tuples?
20:49:22 <rwbarton> accel: sequence
20:49:37 <dark> accel, this is somewhat ugly
20:49:47 <accel> @src sequence
20:49:48 <lambdabot> sequence []     = return []
20:49:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:49:48 <lambdabot> --OR
20:49:48 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:49:50 <rwbarton> "There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples"
20:50:03 <accel> dark: what is a prettier version?
20:50:14 <accel> rwbarton: thanks
20:51:10 <ray> all you need is set theory anyway what's the big deal
20:51:15 <dark> unlimited tuple size (but it isn't pretty to actually have this huge tuple)
20:51:39 <ray> the implementation will probably give up somewhere
20:51:53 <ray> it's a while after actual haskellers give up though so everything's ok
20:52:11 <accel> rwbarton: actually, to make it a sequence, I need to make State a Monad right? then defien the >>= and return oeprators
20:52:16 <rwbarton> right
20:52:18 <accel> rwbarton: otherwise the sequence source using do, <= won't work
20:52:20 <accel> rwbarton: got it; tahnks
20:52:32 <rwbarton> in particular it can't be a type synonym
20:52:40 <Jafet> There is HList
20:52:48 <Jafet> The H stands for headache
20:52:54 <rwbarton> also, that monad is already defined in Control.Monad.State (State Int)
20:53:45 <accel> rwbarton: what do you mean by "it can't be a type synonym" ?
20:53:59 <accel> rwbarton: as I have to make it a "data State = ... " in order to do "instance Monad State" ?
20:54:06 <rwbarton> newtype would be better, but yeah
20:54:36 <rwbarton> Partially type synonyms can't be used as class instances (or anything else for that matter)
20:55:34 <accel> rwbarton: cool; thanks
20:55:52 <dainanaki> Does anyone know what this build error means? "cannot satisfy -package-id random-1.0.0.3-9db20a71d9f20fea589bba3670736bda: 
20:55:53 <dainanaki>     random-1.0.0.3-9db20a71d9f20fea589bba3670736bda is shadowed by package random-1.0.0.3-e73ca4e6797f67d6994ecb5329f5b9fc"
21:06:08 <dainanaki> nobody?
21:10:51 <siracusa> dainanaki: Something's wrong with the installation of your random package. What does `ghc-pkg check'  output?
21:12:04 <dainanaki> Lots of broken packages
21:13:10 <dainanaki> Ah, figured it out.
21:13:25 <dainanaki> Had to force unregister random
21:13:27 <accel> myLift :: State s a -> (a->b) -> State s b
21:13:28 <accel> myLift m f =
21:13:28 <accel>   \s -> let (s', a) = m s
21:13:28 <accel>          in (s', f a)
21:13:32 <accel> did I just re-invent lift?
21:13:35 <accel> @sc lift
21:13:35 <lambdabot> Maybe you meant: rc src
21:13:37 <accel> @src lift
21:13:37 <lambdabot> Source not found. :(
21:13:41 <accel> @src liftM
21:13:41 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:13:59 <accel> except mine is working "without" a monad right?
21:14:06 <accel> :t liftM
21:14:07 <rwbarton> fmap
21:14:07 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:14:18 <rwbarton> or liftM yeah
21:14:32 <accel> hmm, and I have the function / monad in the wrong order
21:14:52 <siracusa> accel: Yours is specialiced to State and with flipped arguments.
21:15:03 <accel> siracusa: yeah; just flipped args back
21:16:26 <accel> man; how did people ever come up with all this insanity
21:16:53 <dainanaki> lots of higher order drugs
21:16:56 <accel> I bet they had 4 digit IQs
21:17:05 <accel> measured in decimal, not binary, too
21:17:55 <dainanaki> it definitely feels like standing on the shoulders of giants to me.
21:20:02 <lispy_> dainanaki: that build error means you should use cabal-dev or capri :)
21:20:09 <accel> feels like standing on the shoulders of ents
21:20:29 <lispy_> dainanaki: http://www.reddit.com/r/haskell/comments/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
21:20:44 <dark> > case [] of [] -> True | _ -> False
21:20:45 <lambdabot>   <no location info>: parse error on input `|'
21:21:10 <dark> > case [] of { [] -> True | _ -> False }
21:21:11 <lambdabot>   <no location info>: parse error on input `|'
21:21:25 <dark> is the name for this issue an.. alignment problem?
21:21:28 <dark> whitespace problem?
21:21:30 <lispy_> > case [] of [] -> True; _ -> False
21:21:31 <lambdabot>   True
21:21:38 <lispy_> > case [] of [] -> True _ -> False
21:21:39 <lambdabot>   <no location info>: parse error on input `->'
21:21:54 <dainanaki> lispy_, thanks for the info. I managed to resolve it though. Somehow cabal installed an identical package to one that was in my ghc installation already. I think it was just a glitch
21:22:08 <lispy_> dark: end of line works as a line terminator (when used correctly with layout) in the same way that semicolon does
21:22:11 <dark> there is a name for it: _ rule
21:22:15 <dark> oh, layout rule
21:22:30 <lispy_> dainanaki: it's not a glitch.  It's cabal-install being naughty.
21:23:12 <lispy_> dainanaki: cabal-dev is a wrapper around cabal-install that gives you isolated package dbs which makes it possible to avoid that problem
21:23:32 <dark> ok nice :) also found out that this function already exists, null
21:23:37 <dainanaki> lispy_: hmm, guess I'll give that a go and see how it works.
21:24:03 <lispy_> dainanaki: I've been using it and I haven't looked back :)
21:25:11 <dark> if a s = b $ c $ d s, then a = b . c . d?
21:26:27 <dark> (yes)
21:27:23 <lispy_> dark: I'm afraid to say yes because I feel like there may be corner cases that it's not true on :)
21:28:10 <lispy_> dark: I guess it has to be true if you're already assmuing that b $ c $ d s is equal to a s
21:28:29 <lispy_> $ doesn't always behave the way you want is the caveat I was thinking of
21:28:35 <lispy_> it has the wrong fixity
21:31:11 <dark> I had a function that in the end became is_zero s = not $ null $ (reads s :: [(Command0, String)])
21:31:27 <dark> (btw it seems that $ binds stronger than ::)
21:31:47 <dark> but it is is_zero = not . null . (reads :: ReadS Command0)
21:32:53 <dark> it's like haskell idioms arise on their own, if one has a language like haskell
21:33:19 <dark> (i see a lot of those $ and . lores here, but from the languages i come, i don't write code that way)
21:34:31 <mkscrg> http://hpaste.org/44049/lensum <- Space leak resulting from (I think) record updating within foldl'. Help?
21:34:58 <lispy_> dark: yeah, but each language has it's own idioms so I think that's to be expected
21:35:39 <dark> mkscrg, i heard something about hGetContents supposed to be evil
21:36:27 <lispy_> mkscrg: readFile would be a simplier way to do what you want there
21:36:44 <lispy_> mkscrg: readFile is like doing an openFile followed by hGetContents
21:36:59 <lispy_> mkscrg: BTW, the comment mentions a seq, but I don't see the seq in your code
21:36:59 <dark> @hoogle reverse
21:36:59 <lambdabot> Prelude reverse :: [a] -> [a]
21:37:00 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
21:37:00 <lambdabot> Data.List reverse :: [a] -> [a]
21:37:15 <mkscrg> foldl' calls seq, no?
21:37:17 <lispy_> mkscrg: your code is likely stack overflowing because you use the Accum type that is lazy
21:37:22 <mkscrg> or calls $!
21:37:23 <rwbarton> mkscrg: the i field isn't strict
21:37:41 <mkscrg> Aha!
21:37:48 <rwbarton> so you are forcing the Accum record but not the Int within it
21:38:06 <monochrom> > seq (Just undefined) 0
21:38:07 <lambdabot>   0
21:38:17 <monochrom> seq doesn't do anything to most fields
21:38:30 <dainanaki> lisp_: holy crap cabal-dev works like a charm
21:38:30 <accel> have any Turing awards been awarded in relation to Haskell ?
21:39:34 <mkscrg> Ah, I remember now that seq is only outermost strict
21:39:44 <mkscrg> Thanks, all
21:39:57 <lispy_> accel: I don't know much about the Turing award.  Isn't that mostly for theoretical CS?
21:40:05 <monochrom> I would modify collect to force i.
21:40:06 <accel> no; Kerigan & Ritchie won it
21:40:10 <accel> the TCP/IP guys won it
21:40:20 <accel> the APL guy won it
21:40:41 <accel> the Knuth guy won it
21:40:49 <dainanaki> "the Knuth guy"
21:41:03 <lispy_> Or, Don as I call him
21:41:07 <blbrown_win3___> IBM's watson passed the Turing test
21:41:10 <lispy_> We go by first names...
21:41:15 <luite> hehe "the Knuth guy" is also mostly about theoretical cs :p
21:41:24 <accel> and LaTeX
21:41:31 <monochrom> stretch: John Backus won it, gave speech on functional programming, that's related to haskell
21:41:38 <lispy_> Knuth does such a wierd cross section of CS
21:41:38 <luite> yeah that too, did he win it for LaTeX?
21:41:45 <accel> probably not
21:41:51 <accel> he won it for TAOCP I believe
21:41:52 <dainanaki> he doesn't need a particular reason to win.
21:42:06 <lispy_> He's into type setting, hates email, and codes in assembly and C
21:42:06 <luite> I hope not ;) (having struggled with LaTeX for the past few hours)
21:42:13 <monochrom> he won it for the weird cross section IMO
21:42:14 <accel> when people talk about Knuth in CS,
21:42:27 <accel> they enumerate the things he didn't do rather than all the things he did do
21:42:43 <monochrom> he didn't do formal methods
21:42:44 <accel> when algorithms are named in CS, they're named for the third guy to discover it -- afte Gauss & Knuth
21:42:44 <lispy_> has yet to do?
21:43:20 <dainanaki> I just hope Knuth does a better job finishing books than Robert Jordan...
21:43:41 <lispy_> dainanaki: Knuth is a bit of a perfectionist...
21:43:46 <monochrom> Knuth writes WEB applications. :)
21:44:10 <accel> monochrom: Knuth wrote WEB applications before the web existed
21:44:16 <dainanaki> lispy_: Indeed. I'm not hoping too forcefully in any case.
21:44:28 <monochrom> Knuth couldn't possibly win the Turing award for LaTeX.
21:44:54 <dainanaki> Didn't Knuth technically write TeX, not LaTeX?
21:44:59 <monochrom> precisely
21:45:05 <accel> oh right; leslie lamport?
21:45:10 <accel> or was it butler lampson?
21:45:14 <monochrom> TeX is a WEB application
21:45:26 <mgsloan> dainanaki: I think Sanderson has done a good job :D
21:46:10 * monochrom saves that up for the next web app question
21:46:31 <dainanaki> mgsloan: I haven't gotten around to the newest one yet. I'd want to reread the whole series first since I've more or less forgotten 80% of the storyline.
21:47:16 <monochrom> <Guest16384> does haskell have web apps? <monochrom> WEB apps? like TeX?
21:48:10 <ray> tex isn't in haskell
21:48:14 <accel> one day, it was raining
21:48:16 <accel> I was walking home
21:48:25 <accel> I saw Knuth biking home, wearing a helmet, in the rain
21:48:29 <accel> and I freaked out
21:48:32 <blackdog> monochrom: hey, it's a reasonable question.
21:48:37 <blbrown_win3___> accel, is knuth in texas?
21:48:51 <monochrom> haha "knuth sighting in texas!"
21:48:51 <accel> rain was hitting him like any other mortal ... it wasn't bounching off his aura of awesomeness
21:48:53 <blbrown_win3___> stanford
21:49:00 <NihilistDandy> On the one hand, I want to learn to use LH, but on the other hand it seems like a very specific use case
21:49:11 <ray> no tex is in knuthsas
21:49:11 <dainanaki> there's not much to learn
21:49:21 <dark> why haskell-indent want to indent "else" one level deep than "if"?
21:49:35 <accel> dark: are you using vim?
21:49:47 <dark> no, emacs. and actually. haskell-indentation
21:49:49 <monochrom> because do notation doesn't like if and else aligned
21:49:58 <blbrown_win3___> ray I think it was Bjarne stroustrup that teaches at A&M
21:50:03 <dark> oh, yes, inside do notation. and.. really? õ.o
21:50:04 <NihilistDandy> Do notation considered harmful :D
21:50:20 <dark> so maybe i should define my if thing outside the do block?
21:50:28 <accel> blbrown_win3___: do you get paid by the number of "_"'s in your nick? are you advertising for the national association of underscores?
21:50:38 <NihilistDandy> dainanaki: I know, but is there a large gain over just commenting? Clearly the math typesetting is a big thing, but I don't know if it's enough of a gain for me.
21:50:42 * NihilistDandy shrugs
21:50:45 <ray> no he's just making a statement about ##c
21:50:56 <monochrom> layout rule says "same column means new expression"
21:51:00 <blbrown_win3___> accel, got disconnected, irc channel relogged in with this nick
21:51:04 <blbrown_win3___> irc client
21:51:12 <accel> blbrown_win3___: oh; not as excigin :-/
21:51:18 <dark> apart from the weird indenting issue, it will.. work? o.o
21:51:20 <accel> so I reinvented the State monad. Where's my Turnig award?
21:51:21 <dark> (if inside do)
21:52:20 <NihilistDandy> Oh, shit, Borders just went into Chapter 11 O.o
21:52:26 <dark> now it wants to indent, after a <- b, the next line aligned at b, not a..
21:52:46 <dainanaki> NihilistDandy, in casual-land I think it's just handy for blog posts. You can post some code and an article to go with it. Then if someone wants to save it for later they can copy & paste the whole thing into an lhs file. That's the only use case I see for it generally speaking. I mean, I guess if you're working for NASA where things have to be vigorously proven, then things might be different.
21:52:53 <dark> i suppose i need to put  new do there
21:53:31 <accel> :t >>=
21:53:32 <lambdabot> parse error on input `>>='
21:53:36 <accel> @src >>=
21:53:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:53:44 <dainanaki> accel, parenthesis
21:53:45 <accel> wtf, why can't I :t >>= ?
21:53:48 <accel> :t (>>=)
21:53:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:53:59 <accel> dainanaki++
21:54:09 <NihilistDandy> dainanaki: Yeah, that's a reasonable view, I think. I suppose I'll practice with it a bit to be sure that I'm getting everything properly, but I can't see it becoming a normal thing unless I get into some interesting research field
21:54:34 <ray> proven VIGOROUSLY
21:55:01 <dainanaki> ray, does it really matter?
21:55:01 <monochrom> vigorous waving of arms
21:55:06 <lispy> what are guys talking about proving?
21:55:29 <dainanaki> nothing specific
21:55:32 <ray> i think you need weierstrassagra or cauchialis for that
21:56:02 <lispy> I started learning Isabelle (an interactive theorem prover language) and I found it to be a bit addictive.  My gf says I ignore her when I use it :)
21:56:20 <lispy> It's so much fun to prove things
21:56:25 <NihilistDandy> I love playing with provers
21:56:34 <dark> http://en.wikibooks.org/wiki/Haskell/Indentation#if_within_do
21:56:35 <lispy> But, 2 theorems later the weekend is gone :(
21:56:55 <NihilistDandy> I was using Vampire, last I did anything in that vein
21:57:14 <dark> incidentally i already use the style for putting then and else in another level, in ocaml (but tuareg-mode doesn't like it .-.)
21:57:27 <ray> usually tex is used to prove theorems, but these are not machine verifiable
21:57:33 <dark> added benefit is that then and else has the same width
21:57:40 <monochrom> "not tonight dear, I'm playing with isabelle"
21:58:07 <dark> ray, so maybe one would rather prove in something else, and convert to tex using some tool?
21:58:11 <lispy> monochrom: I can see you're following me on twitter :)
21:58:23 <monochrom> I just follow you on irc.
21:58:24 <accel> @src return :: State
21:58:24 <lambdabot> Source not found.
21:58:38 <lispy> dark: now that you mention it, isabelle (and probably others) do convert to latex for you
21:59:10 <accel> dumb question; how is "return" defined the State monad?
21:59:16 <accel> :t return
21:59:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:59:41 <monochrom> return x = State (\s -> (s,x)).  I may have s,x swapped
21:59:58 <mgsloan> dainanaki: oops.. distracted.  yeah, I didn't have time to re-read, so I wasn't exactly ingrained in the plotline either.  Such a massive series.  I will get around to it sometime, though.  I found the new books approachable despite forgetting a good deal of it
22:00:37 <dainanaki> mgsloan, since I last read them... reddit was invented...
22:00:42 <dainanaki> :(
22:00:57 <mgsloan> haha, same.
22:01:09 <monochrom> if you want StateT, here is one: return x = StateT (\s -> return (s,x)).  Again I may have s,x swapped.
22:01:15 <lispy> accel: For most monads return is defined in terms of applying the data constructor for the monad and very little else
22:02:14 <accel> lispy: noted; thanks
22:02:22 <accel> lispy: btw, did you ever look into lisk?
22:02:25 <monochrom> @unmtl State Int Bool
22:02:26 <lambdabot> Int -> (Bool, Int)
22:02:37 <monochrom> ha I have s,x swapped
22:02:46 <lispy> accel: lisk?
22:02:51 <shachaf> monochrom: Your order is better.
22:03:11 <accel> @src sequence
22:03:11 <lambdabot> sequence []     = return []
22:03:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:03:12 <lambdabot> --OR
22:03:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:03:17 <lispy> The order that is there is just to make the instance of Monad writeable
22:03:53 <lispy> instance Monad (State s) where ...
22:04:51 <accel> lispy: http://bit.ly/gIJUBC <-- lisk
22:05:12 <accel> :-)
22:06:11 <accel> @src liftM
22:06:11 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:06:18 <lispy> accel: that's already been done http://www.liskell.org/
22:06:57 <accel> lispy: nah, liskell hacks ghc
22:07:01 <accel> lispy: lisk works directly on ghc
22:07:07 <accel> lispy: i believe it's a preprocessor path
22:07:09 <accel> s/path/pass
22:07:36 <accel> this is fucking depressing ... C -- I write 500 LOC an hour; Haskell -- I've been hacking 2 days, still 105 lines of code; and half of them are either blank lines or "::" declarations
22:08:19 <accel> this is haskell: I write some code; then I realize oh shit, I can abstract that; I write the abstraction; and my LOC count goes back down
22:08:25 <dainanaki> accel, it gets better with time.
22:08:36 <lispy> accel: you can get nice line count stats with this http://cloc.sourceforge.net/
22:09:27 <NihilistDandy> accel: Factor in debug time
22:09:29 <monochrom> you need to read some Dijkstra article. there is a long one scorning at LOC as measure of work done.
22:09:35 <accel> yeah
22:09:39 <accel> LOC should be measured as LOC spent
22:09:41 <accel> not LOC produced
22:09:47 <monochrom> ok nice
22:10:12 <accel> what did Dijkstrac ever do for CS besides winning the Turing award, inventing structured programming + a shit load of graph algorithms, ?
22:10:18 <ray> 105 lines of haskell? that's a month's output for me
22:10:21 <ray> more really
22:10:24 <monochrom> concurrency
22:10:39 <ray> grumpiness about goto
22:10:44 <ray> memes about considering things harmful
22:11:02 <dainanaki> harmfulness considered harmful
22:11:04 <monochrom> actually only one graph algorithm but shitload of concurrency. mutex was only an appetizer. he did concurrent garbage collection too.
22:11:11 <accel> goto considred hamrful considered harmful
22:11:19 <accel> what? concurrent GC?
22:11:21 <accel> holy shit
22:11:23 <NihilistDandy> "'Considered harmful' considered harmful" considered harmful
22:11:25 <ray> the real question is what did knuth ever do for cs besides write a measly unfinished book
22:11:43 <dainanaki> buffalo buffalo buffalo buffalo buffalo buffalo buffalo
22:11:55 <NihilistDandy> Buffalo considered harmful
22:12:21 <dainanaki> I agree with that statement
22:12:31 <accel> as for Knuth
22:12:39 <accel> Knuth's pinky wrote more code that's used in the world
22:12:44 <accel> than all of our output in thsi channel combined
22:12:58 <dainanaki> i wrote facebook
22:13:25 <NihilistDandy> Also, a long paper about lowercase delta
22:13:40 <NihilistDandy> Knuth, that is
22:14:10 <dark> http://www-cs-faculty.stanford.edu/~uno/cm.html like this?
22:14:27 <accel> http://hpaste.org/44050/simplify <-- I have an awful lot of "State (\n -> (n, ... something involving n ...)) " ... is ther a way to ssimplify this?
22:14:28 <NihilistDandy> That'd be the one. I suppose long was the wrong word
22:14:45 <stepkut> knuth knuth knuth knuth knuth knuth knuth
22:14:51 <accel> http://hpaste.org/44050/simplify <-- I have an awful lot of "State (\n -> (n, ... something involving n ...)) " ... is ther a way to ssimplify this? (i.e. it seems like what I want to do is to read some state from the monad)
22:14:58 <NihilistDandy> It seemed a littler wordy for "please update your TeX so I don't have to see your ugly deltas, anymore"
22:15:07 <accel> alright ladies, let's get back to focus ... i.e. help me simplify my code
22:15:15 <dark> i'm getting crazy by having do inside else if inside do
22:15:29 <dark> i'm considering using { } and ;
22:15:31 <dainanaki> accel, you seem to be missing the point of state being a monad...
22:15:41 <accel> dainanaki: enlighten me
22:15:50 <monochrom> get = State (\n -> (n,n))  I am sure I am swapping nothing here :)
22:15:51 <NihilistDandy> dark: Why all the do?
22:16:05 <accel> monochrom: can you put that into a complete piece of code?
22:16:16 <monochrom> that is a complete piece of code
22:16:24 <accel> monochrom: can you annotated my code with get?
22:16:34 <accel> State (\n -> (n, String n x)) <-- how do I replace taht with get?
22:17:00 <monochrom> put x = State (\n -> (x, ()))
22:17:19 <monochrom> modify f = State (\n -> (f n, ()))
22:17:37 <monochrom> you could do everything by a combination of put, get, modify, return, >>=.
22:17:52 <shachaf> Everything.
22:17:59 <NihilistDandy> All of it
22:18:02 <accel> can I do two monads at the same time?
22:18:09 <dainanaki> monad transformers
22:18:15 <monochrom> you are already doing two monads at the same time
22:18:21 <NihilistDandy> Wouldn't that be a dyad? O.o
22:18:33 <monochrom> or a threesome
22:18:40 <dainanaki> my thoughts exactly
22:18:42 <NihilistDandy> More like a party, am I right?
22:18:52 <dainanaki> no, three's a crowd
22:18:58 <NihilistDandy> Fair point
22:19:06 <monochrom> crowd computing
22:19:15 <NihilistDandy> lol
22:19:18 <dainanaki> when asians join the web 2.0 trend?
22:19:22 <NihilistDandy> And that lol is not hyperbole
22:19:49 <accel> monochrom: how would that make my code shorter?
22:20:04 <dainanaki> accel, it's more about making useful abstractions
22:20:11 <accel> dainanaki: can you annotate my code?
22:20:14 <monochrom> not sure about shorter. it does eliminate a lot of manual State (\n -> ...
22:20:16 <accel> dainanaki: I know I'm misisng someting
22:20:18 <NihilistDandy> Elegance, not shortness
22:20:21 <accel> dainanaki: but I cna't see it until I see it
22:20:42 <accel> just one example
22:20:42 <dainanaki> accel, monochrom basically said what I was going to say
22:20:43 <dark> actually the issue was a type error, i missed a return
22:20:44 <accel> how should
22:20:46 <accel> parseWord = do x <- many1 (noneOf "\" \n\t") return $ State (\n -> (n, String n x))
22:20:49 <accel> be rewritten ?
22:21:03 <monochrom> example. s/State (\n -> (n,()))/return ()
22:21:15 <dark> anyway http://hpaste.org/44051/ugly
22:21:30 <dark> it is getting uglier over time
22:21:33 <accel> monochrom: yeah, but I have State (\n -> (n, String n ""))
22:22:04 <dark> (line' is the current version)
22:22:15 <monochrom> perhaps that one is as short as it gets
22:23:02 <gwern> :t log
22:23:03 <lambdabot> forall a. (Floating a) => a -> a
22:23:07 <monochrom> getwith f = State (\n -> (n, f n))
22:23:13 <gwern> @src log
22:23:13 <lambdabot> Source not found. Are you on drugs?
22:23:24 <gwern> what base is that log?
22:23:27 <dark> @src (log :: Real -> Real)
22:23:27 <lambdabot> Source not found.
22:23:32 <monochrom> then you can s/State (\n -> (n, String n x))/getwith (\n -> String n x)
22:23:40 <dark> > log 10
22:23:41 <lambdabot>   2.302585092994046
22:23:52 <gwern> > logBase 10 10
22:23:53 <lambdabot>   1.0
22:23:56 <monochrom> it is up to you which one you like. I don't have a strong recommendation
22:23:57 <ray> reals can't be a haskell type, almost all of them are uncomputable and collapse to _|_
22:24:11 <gwern> ray: so use CReal
22:24:21 <accel> monochrom: getwith I like
22:24:27 <monochrom> "Real" is just a name.
22:24:36 <gwern> > 42 / 1 - (-(1/6 * logBase 2 (1/6) + (1 - 1/6) * logBase 2 (1 - 1/6)))
22:24:38 <lambdabot>   41.34997757835165
22:24:45 <monochrom> no one really believes that "complex" is all that complex.
22:25:03 <ray> > log 2.718281828
22:25:04 <lambdabot>   0.9999999998311266
22:25:53 <monochrom> damn. getwith f = f `liftM` get
22:26:45 <dainanaki> accel, I guess my point is that monads are often an interface to keep people from mucking around with the insides of datatypes. Building an interface like monochrom has been helping you with for useful functions and then preventing the type constructor from being exported from the module gives you a black-box in a way. This is good. Once you have things working how you want, keeping developers from using your code in ways that it shouldn't be used really he
22:26:45 <dainanaki> abstraction.
22:27:32 <accel> dainanaki: yeah; i think the thing that screws over this particular case
22:27:43 <accel> dainanaki: is that for each constructor, I percisely want to read the value out of the moand for the constructor
22:27:50 <accel> dainanaki: i.e. the monad contains the "line number" as a state
22:27:57 <accel> dainanaki: and each constructor wants to know "what line do I come from"
22:28:11 <accel> dainanaki: thus the ugly State(\n -> (n, ... somethign involving n ...))
22:28:15 <monochrom> did you know that parsec already counts line and column?
22:28:22 <accel> monochrom: no
22:28:25 * accel facepalms
22:28:25 <NihilistDandy> Existentialist monads
22:28:39 <monochrom> good education to learn State anyway
22:29:10 <accel> yeah, I learned state monad, lift, sequence, and how to get two monads to place nice
22:29:22 <ray> i've really come around recently to thinking that monads really are hard
22:29:22 <accel> on top of that, far more valuble, I made new friends on #haskell
22:29:31 <accel> nah; i'm just stupid
22:29:53 <NihilistDandy> #haskell really is one of the friendlier channels
22:29:54 <ray> unlike a lot of concepts i can't think of a good way to teach them
22:30:13 <Kaidelong> @djinn (a -> m a) -> b -> m b
22:30:13 <lambdabot> -- f cannot be realized.
22:30:14 <monochrom> have you taught numbers?
22:30:15 <Kaidelong> why?
22:30:15 <NihilistDandy> ray: Monads are burritos?
22:30:19 <ray> i can explain algebraic topology to my sister
22:30:19 <dainanaki> I had a lot of fun a while ago teaching my girlfriend about monads
22:30:35 <Kaidelong> or rather
22:30:37 <Kaidelong> how do I fix
22:30:38 <dainanaki> i like the space suit-space station analogy
22:30:45 <Kaidelong> @djinn (forall a. a -> m a) -> b -> m b
22:30:45 <lambdabot> -- f cannot be realized.
22:32:01 <monochrom> people will ask you "what is a monad" and it is the same as a kindergarten kid ask you "what is a number"
22:32:06 <paolino> :t const return
22:32:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => b -> a -> m a
22:32:07 <ray> the problem is that monads aren't really burritos, whereas homotopy groups really are groups
22:32:31 <accel> "what is a number" is easy
22:32:39 <accel> what's hard is "how is sqrt(2)" defined?
22:32:51 <ray> no you just draw an isoceles right triangle
22:32:52 <NihilistDandy> ray: http://blog.plover.com/prog/burritos.html
22:32:54 <accel> then you start defining rational numers, cuts, and least upper boudns
22:32:55 <NihilistDandy> :D
22:33:22 <ray> mjd is a pretty cool guy, i read his blog once
22:33:50 <ray> the reals are hard, i would wait until age 10 to introduce them
22:34:40 <c_wraith> I'd wait until you can motivate them.  So far, no one's given me a compelling reason to care about the reals.
22:34:49 <monochrom> also try "what is a negative number"
22:36:03 <ray> the reason you care is because you need them to do calculus
22:36:09 <dark> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD09xx/EWD993.html
22:36:19 <monochrom> perhaps he doesn't do calculus or anything needing calculus
22:36:23 <ray> computer and programming nerds tend to shun the calculus
22:36:33 <ray> i think largely because it's not nice and discrete
22:36:47 <monochrom> I wouldn't say discrete is nice.
22:36:47 <NihilistDandy> I enjoy it
22:36:58 <NihilistDandy> Both calc and discrete
22:37:15 <lispy> c_wraith: reals are quit bizzare.  They are great for bending your mind.
22:37:28 <monochrom> unlimited smooth and entire is nice. to me anyway.
22:37:40 <lispy> c_wraith: quite, even I mean
22:37:45 <ray> it's really a toss-up between the reals and the complexes
22:38:02 <paolino> An off topic question. Programming a web server, does session state (where session is picked by cookie) needs to be concurrent, or is it correct to sequence the requests for one session ?
22:38:08 <c_wraith> See, the funny thing there is, you don't need reals to *do* calculus.  Only to prove it.
22:38:20 <c_wraith> That just suggests to me that there are other proofs out there.
22:38:21 <NihilistDandy> c_wraith: And what's wrong with proof?
22:38:33 <NihilistDandy> :D
22:38:40 <ray> you don't need anything to do calculus, you just apply standard rules
22:39:04 <ray> if those don't work you ask a black box called a mathematician
22:39:31 <Jafet> Like Alfred Tarski?
22:39:45 <c_wraith> As a matter of fact, it's really easy to demonstrate that the result of solving any calculus problem will never lie outside the computable reals.
22:39:50 <monochrom> let's clone Tarski. he knows how.
22:40:02 <NihilistDandy> ray: When I get to grad level or so, I may just have to start referring to myself as a black box :D
22:40:17 <c_wraith> monochrom, I don't think anyone's invented a sufficiently sharp scalpel for the cuts you need for that.
22:40:19 <ray> only when talking down to physicists etc
22:40:21 <Jafet> c_wraith: except the uncomputable problems
22:40:27 <NihilistDandy> ray: Naturally.
22:40:36 <lispy> Cale: I'm doing a pretty substantial software update/upgrade on the linode.  Then I'll likely reboot it.  So, you may need to restart lambdabot :)  Sorry for any inconveninence
22:40:39 <monochrom> you need all of the reals for the sharp scalpel :)
22:41:08 <c_wraith> I'd much rather call the non-computable reals imaginary than multiples of the square root of -1.
22:41:22 <ray> i think he means you start with a computable function and take its derivative and get another computable  function and you need to compute your inputs before you can give them to the function so they're computable therefore qed
22:42:34 <ray> i don't think anyone likes the name imaginary really
22:42:44 <Jafet> [  1 of 207]
22:42:52 <Jafet> Why does lambdahack even need gtk?
22:43:28 <monochrom> ?  what is lambdahack?
22:43:49 <ray> oh there's calculus with infinitesimals too but that's the reals plus EVEN MORE stuff
22:43:50 <monochrom> oh LambdaHack
22:44:05 <ray> numbers that even mathematicians find a bit dubious
22:44:22 <monochrom> "a small roguelike game"
22:44:41 <monochrom> perhaps it wants a GUI for the game
22:44:47 <ray> i really prefer japanese roguelikes, they aren't exercises in masochism
22:45:10 <Jafet> I believe Chocobo Dungeon was.
22:45:17 <NihilistDandy> Which is surprising, considering the nature of some of their other games.
22:46:27 <blbrown_win3___> ...
22:47:03 <gwern> if anyone is feeling bored, I wrote this silly thing about information theory: http://www.gwern.net/Notes.html#efficient-natural-language
22:47:26 <Jafet> Hm, so it draws its own terminal with gtk.
22:47:48 <Jafet> I hope that does not imply that hscurses is horrible.
22:47:51 <gwern> c_wraith: wait, if you solve a calculus problem, then haven't you just demonstrated a constructive/computable method of generating the result, so any result is by definition inside the computable reals?
22:48:01 <ray> i mean you might get riceballed and eaten in furai no shiren but you won't ever have to find a goddamn candelabra of invocation and set it up on the right square with 3 mystical candles or whatever it is you have to do in nethack
22:48:01 <gwern> Jafet: I hear that it is, incidentally
22:48:53 <ray> i'm not 100% sure that the derivative of a computable function is computable but i suspect there's a simple proof somewhere
22:49:32 <ray> half of mathematics is suspecting someone proved your baseless assertion and forging on
22:49:36 <Jafet> The derivative might not exist at a point
22:49:59 <Jafet> > 1/0 :: CReal
22:50:03 <lambdabot>   mueval-core: Time limit exceeded
22:50:07 <ray> sure it does because we're making all the standard niceness assumptions implicitly
22:50:44 <Jafet> If you think nethack is masochism, you've never played a sierra or infocom game
22:51:40 <NihilistDandy> Jafet: Adventure game logic, (C) Sierra
22:56:38 <accel> why can't I do:
22:56:46 <accel> newtype Command = [Val] -> [Val] ?
22:58:11 <accel> http://hpaste.org/44052/typerecursion <-- how do I define this recursive type?
22:58:19 <c_wraith> accel: newtypes need a constructor.
22:58:36 <c_wraith> accel: newtype Command = Command ([Val] -> [Val])
22:58:46 <accel> c_wraith: thanks
22:59:13 <mauke> | Command LineNumber String ([Val] -> [Val])
23:01:36 <accel> mauke: http://hpaste.org/44053/show <-- end up with that ; otherwise, I can't get show to work
23:04:25 <lostman> epollControl: permission denied
23:04:32 <lostman> now, that's a curious error...
23:05:23 <lostman> anyone knows what it means?
23:05:58 <accel> probably means sudo epollControl
23:06:14 <luite> lostman: I had similar errors that turned out to be bugs in the 7.0.1 rts
23:07:09 <lostman> luite: I'm running ghc head
23:07:34 <lostman> accel: what do you mean?
23:11:05 <accel> is therre a more efficient way to say:
23:11:11 <accel> > take 6 $ repeat " " 
23:11:15 <lambdabot>   mueval-core: Time limit exceeded
23:11:22 <luite> accel: replicate 6
23:11:31 <accel> :t replicate
23:11:34 <lambdabot> forall a. Int -> a -> [a]
23:11:37 <accel> > replicate 6 " "
23:11:41 <lambdabot>   [" "," "," "," "," "," "]
23:11:57 <Maxdamantus> @src replicate
23:11:57 <lambdabot> replicate n x = take n (repeat x)
23:12:39 <luite> accel: if you want a single string with 6 spaces, you should use ' ' instead of " "
23:12:48 * Maxdamantus predicts they'll both be unwrapped the same.
23:15:39 <accel> luite: yeah; I just realized that
23:15:44 <accel> luite: thanks
23:16:24 <ray> it's more efficient reading, which is all that matters
23:31:43 <accel> is there a short hand for \x -> \y -> \z -> ... ?
23:32:28 <Maxdamantus> \x y z -> ... ?
23:32:29 <luite> > (\x y -> x+y) 2 3
23:32:30 <lambdabot>   5
23:33:57 <dark> is there a shortand for \x -> case x of .. ?
23:34:37 <accel> Maxdamantus: whoa, mind blown
23:34:40 <accel> Maxdamantus: thanks!
23:41:14 <gwern> hm. I wonder how much a megawatt costs
23:41:20 <gwern> megawatt-hour I should say
23:42:07 <dark> @src maybe
23:42:08 <lambdabot> maybe n _ Nothing  = n
23:42:08 <lambdabot> maybe _ f (Just x) = f x
23:42:29 <dark> oh
23:42:44 <dark> this will save me from writing case .. of
23:43:48 <Jafet> Well, a megawatt costs a lot more than a megawatt-hour
23:44:10 <Jafet> Unless the megawatt-hour must also be provided at one megawatt
23:45:01 <dark> huh? the cost of one megawatt would be like $N / hour
23:45:53 <gwern> > 1000 * 0.0962
23:45:54 <lambdabot>   96.19999999999999
23:46:12 <gwern> huh. I would have guessed a megawatt-hour to cost more than 96$
23:46:57 <gwern> > 15 * 96.2
23:46:57 <lambdabot>   1443.0
23:47:28 <gwern> hm. Floating@home is eating up $1443/hr of electricity
23:48:09 <gwern> > 1443 * 24 * 365.25
23:48:09 <lambdabot>   1.2649338e7
23:48:40 <gwern> 1.27 million a year. I guess that's good for a supercomputer, but I didn't realize it cost the volunteers so much
23:48:58 <Maxdamantus> 365.25?
23:49:11 <Maxdamantus> > 1443 * 24 * (365 + 1/4 - 1/400)
23:49:12 <lambdabot>   1.264925142e7
23:49:24 <Jafet> Well, subtract the cost of leaving them idle.
23:49:58 <Jafet> Add the opportunity cost of possibly not being able to meet aliens in your lifetime due to cycles taken from SETI
23:50:04 <gwern> Jafet: and then add on the cost of the CPUs which are vainly trying to keep up with the ps3s and gpus
23:50:17 <blackdog> gwern: not 12.7 million?
23:50:21 <gwern> wait, e7? million is e6 isn't it?
23:50:25 <dark> > let f a b c = a + b + c in 1 `f 2` 3
23:50:26 <lambdabot>   <no location info>: parse error on input `2'
23:50:33 <dark> .-.
23:50:37 <gwern> ah, yeah, as blackdog says, 12.7 million. even worse :)
23:50:57 <blackdog> gwern: what's an order of magnitude among friends? :)
23:51:18 <gwern> blackdog: pretty important given all the errors involved in such guessing
23:51:26 <Jafet> What's Floating@home, anyway?
23:51:56 <gwern> Jafet: SETI for folding proteins
23:52:46 <dark> what's better, finding aliens of curing cancer
23:52:54 <dark> or*
23:53:10 <Maxdamantus> Testing their buoyancy.
23:54:01 <gwern> dark: curing cancer wouldn't give a huge increase in net human longevity, but aliens offer almost unlimited tech upside. (and of course downsides...)
23:54:02 <c_wraith> I thought it was like antigravity@home
23:55:34 <silver> gwern, we can't be sure
23:55:44 <gwern> silver: huh? sure of what?
23:55:50 <Jafet> I would give my cycles to that
23:56:00 <silver> that aliens offer us something
23:56:32 <Maxdamantus> Then we take it from them.
23:56:37 <silver> ha-ha
23:56:52 <dark> Maxdamantus, supposing they are in our galaxy
23:57:18 <gwern> silver: how would they not have something to offer if we can communicate with them?
23:57:26 <silver> but if we can't?
23:57:36 <dark> SETI is about _receiving_ messages, not sending
23:57:56 <dark> also it supposes messages aren't encrypted / compressed or otherwise looks random
23:58:05 <dark> i... think
23:58:10 <silver> what if they have no self-conscious, what if they're brainless (but very intellectual) robots?
23:58:25 <gwern> silver: the universe is billions of years old. even if we are offset from ech other by only a few thousand years, well, look at where we've gotten in a few thousand years. it's be mindboggling extraordinary if we were exactly equally competence. it'd be like a knife balancing on another knife balanced on a few more knives
23:59:52 <gwern> aliens will be angels or apes, as the old expression goes
