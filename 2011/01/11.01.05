00:00:00 <j-invariant> applicative: it's just a very simple algorithm - and we have proved lots of algorithms terminate (or don't)
00:00:01 <copumpkin> CocontT? 
00:00:27 <edwardk> the ContextT (w (s -> a)) s  â€” one
00:00:44 <copumpkin> oh yeah, that's what I've been working on all evening :)
00:00:50 <edwardk> the duplicate?
00:00:52 <edwardk> or the proof?
00:01:10 <copumpkin> dup (contextTâ€² f s) = contextTâ€² (map (Î» x â†’ contextTâ€² f) f) s
00:01:14 <copumpkin> that one?
00:01:20 <edwardk> yeah
00:01:22 <edwardk> thx
00:01:39 <copumpkin> np
00:01:40 <edwardk> odd thats syntactically identical to mine
00:02:26 <edwardk> which was my problem
00:02:30 <edwardk> (map  vs. fmap) =)
00:02:34 <MrWish> 01Oo what does this have to do with my original question??
00:02:41 <edwardk> mrwish: nothing
00:02:49 <copumpkin> MrWish: people can talk about things unrelated to you in here :)
00:02:52 <copumpkin> there are over 600 of us :)
00:03:00 <MrWish> 01I mean it seems fascinating but...
00:03:11 <povman> yo
00:03:54 <aefjt> @pl \x -> [x+1,x/(x+1)]
00:03:54 <lambdabot> liftM2 (:) (1 +) (return . ap (/) (1 +))
00:03:59 <aefjt> Yuk
00:04:22 <aefjt> > fix (((1%1) :) . ((\x->[x+1,x/(x+1)]) =<<))
00:04:24 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,2 % 3,3 % 2,1 % 3,4 % 1,3 % 4,5 % 3,2 % 5,5 % 2,3 ...
00:06:13 <copumpkin> > fix ((1%1:)>=>(\x->[x+1,x/(x+1)]))
00:06:14 <lambdabot>   [2 % 1,1 % 2,3 % 1,2 % 3,3 % 2,1 % 3,4 % 1,3 % 4,5 % 3,2 % 5,5 % 2,3 % 5,4 ...
00:06:29 <copumpkin> not quite, I guess
00:06:45 <aefjt> > fix ((0%1:)>=>(\x->[x+1,x/(x+1)]))
00:06:46 <lambdabot>   [1 % 1,0 % 1,2 % 1,1 % 2,1 % 1,0 % 1,3 % 1,2 % 3,3 % 2,1 % 3,2 % 1,1 % 2,1 ...
00:06:48 <povman> i heart >=>, since i found out what it does
00:07:02 <edwardk> povman It makes monad laws easy to read, thats what it does =)
00:07:20 <copumpkin> you can also use it for poor-man's symlinks
00:07:25 <copumpkin> readFile <=< readFile
00:07:50 <copumpkin> :P
00:08:04 <povman> ha
00:08:42 <MrWish> I think I was just disconnected for a while... I need a decent irc client
00:08:49 <aefjt> That's not recursive, surely
00:08:59 <aefjt> Being poor has its problems I guess
00:09:15 <povman> aefjt: files containing file names
00:09:31 <MrWish> anyways, I have no clue whatsoever what the examples you gave have to do with my problem, but the general lesson to be learned seems to be: study maths hard.
00:09:51 <edwardk> mrwish: its a good starting point
00:10:05 <povman> is there a nice library with qw and ` and the other lovely perl quotes?
00:10:11 <edwardk> copumpkin: did we ever show whether or not an ExpT comonad transformer existed? i forgot
00:10:13 <copumpkin> MrWish: if you take one thing away from it, let it be that functions are hard to compare for equality without having things behave unpredictably
00:10:39 <copumpkin> ExpT being the monoid reader one?
00:10:45 <edwardk> yeah
00:11:14 <copumpkin> we both were reasonably confident (through experiementation) that one couldn't be written meaningfully
00:11:23 <copumpkin> but I never proved it :P
00:11:24 <MrWish> I wasnt ever a good maths student tho. anyways. I started out finding out about lambda calculus before I started tryign to learn haskell.
00:11:33 <edwardk> got it. feel up to a proof? =)
00:12:04 <copumpkin> lol
00:12:13 <copumpkin> not now, really exhausted and still feeling kinda sick
00:12:31 <edwardk> bad pizza place.
00:12:41 <copumpkin> indeed
00:12:48 <copumpkin> it's a sign that I should not be lazy and should cook
00:12:54 <MrWish> I always ended up feeling frustrated when trying to learn programming, I kept having this naggign feeling I didnt have a "real" understanding of what I was doing. when I learned about lambda calculus I felt  like that was maybe what I had been looking for
00:13:05 <j-invariant> MrWish: yeah I get that too
00:13:21 <copumpkin> MrWish: it's an infinitely deep rabbit hole
00:13:54 <MrWish> anyways, thanks for the effort lol
00:14:08 <aefjt> @quote generalisation.is
00:14:08 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
00:21:15 <ski> > fix (\ns -> 1 : [n | n <- ns , n <- [n + 1,n / (n + 1)]]) :: [Rational]
00:21:16 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,2 % 3,3 % 2,1 % 3,4 % 1,3 % 4,5 % 3,2 % 5,5 % 2,3 ...
00:24:31 <dolio> ski: So, here's one issue with writing zipWithN that's specific to Agda.
00:26:16 <dolio> Actually, never mind.
00:26:24 <copumpkin> :O
00:26:37 <dolio> I think I've had trouble in the past because for some n, you need to produce a Set, and for others a Set1.
00:26:46 <dolio> And there's no good way to do that.
00:27:15 <dolio> Like, if you have 0 quantifiers, your type is in Set, and if you have n > 0 quantifiers, it's in Set1.
00:27:25 <copumpkin> yeah
00:27:41 <copumpkin> any news on the cumulative universes?
00:27:41 <dolio> But even if you try to write Nat -> Set? you have a problem.
00:28:07 <dolio> Because then you have, for 0, Set is a Set1, and for n > 0, Set1 is a Set2.
00:28:36 <qfr> Btw what is the x xs thing derived from? What does "xs" stand for?
00:28:36 <dolio> So yeah, we need cumulativity.
00:28:43 <qfr> Is it supposed to be the plural of x?
00:28:46 <dolio> Yes.
00:28:46 <ski> yes
00:28:50 <qfr> Ah, I see
00:31:07 <dolio> ski: Anyhow, it just occurred to me that zipWithN 0 should have type {R : Set} -> R -> List R, so maybe that isn't an issue.
00:31:45 <j-invariant> dolio:
00:31:56 <j-invariant> (List R)^n -> List (R^n)
00:32:26 <dolio> That type is too restrictive.
00:32:29 <copumpkin> that makes it trivial
00:32:34 <copumpkin> but not as polymorphic as you'd like
00:32:45 <copumpkin> you could use a heterogeneous vector though
00:33:07 <copumpkin> and always take the Set parameter
00:33:18 <copumpkin> so you're always in Set1, even for 0
00:34:47 <copumpkin> or yeah, have zipWithN 0 be repeat
00:34:58 <copumpkin> Colist ? :P
00:35:04 <edwardk> torn. i have an f-branching stream comonad, with all the bells and whistles, (Show, Eq, Ord, Data, Typeable, etc) but to get those, i need to admit FlexibleContexts and UndecidableInstances, but since it isn't a transformer i'd like it in the base comonads package
00:36:08 <edwardk> personally i don't care about those language features, but they seem to make some folks squeamish
00:36:23 <ski> j-invariant : `(Vector (F i) m)^(i : n) -> Vector (F i)^(i : n) m'
00:36:44 <j-invariant> ski: what does (i : n) mean?
00:37:16 <j-invariant> is that like a backwards lambda
00:37:58 <ski> j-invariant : `(..i..)^(i : n)' was here just another syntax for `(i : n) -> ..i..', i.e. a function mapping elements `i' of `n' to elements of `..i..'
00:38:00 <copumpkin> a -> b ~ b^a
00:38:25 <j-invariant> aha
00:38:29 <copumpkin> edwardk: I don't care about the extensions either (although I do try to avoid undecidableinstances) but if your goal is acceptance, I'd just avoid putting it in
00:38:39 <ski> so `(i : n) -> (Vector (F i) m) -> Vector ((i : n) -> F i) m', if you prefer
00:38:46 <ski> er, more brackets
00:38:56 <ski>   ((i : n) -> Vector (F i) m) -> Vector ((i : n) -> F i) m
00:39:20 <edwardk> i'm leaning towards putting it in a separate module. after all there is a ton of stuff in base that has those features, data.data, typeable, etc. are there, so its kind of an annoying double standard
00:39:29 <copumpkin> yeah
00:43:42 <edwardk> i did at least remove standalone newtype deriving
00:43:45 <edwardk> that seemed a bit much ;)
00:54:06 <edwardk> interesting, i didn't expect that transformers would ignore Show, etc. for all of its monads
01:10:56 <o^_^o> how do I find out what <=> this does in haskell ?
01:11:10 <Veinor> <=>?
01:11:28 <Veinor> are you sure you don't mean <> ?
01:11:28 <o^_^o> http://patternsinfp.wordpress.com/2010/12/31/stream-monad/
01:11:52 <Veinor> oh
01:11:55 <Veinor> that's a logical symbol
01:12:03 <silver> @hoogle (<=>)
01:12:03 <lambdabot> No results found
01:12:03 <Veinor> it means the left hand side implies the right, and vice versa
01:12:05 <o^_^o> h = unfold f <=> out . h = prod (id . h) . f
01:12:12 <o^_^o> ah...ok
01:12:16 <silver> heh
01:12:20 <Veinor> so h = unfold f is the same thing as out . h = prod (id . h) . f
01:12:40 <Veinor> :)
01:13:13 <o^_^o> heh...one problem with not being in touch with what I studied in school, is that obvious things like this seem like big things
01:15:16 <gienah> if you are intersted in studying some maths, this is a really good book, that does have some haskell: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.137.9312&rep=rep1&type=pdf
01:16:07 <o^_^o> One thing about learning haskell, is that it makes the gears in my brain turn. I hardly do any programming in my job and I don't know if learning haskell will do me any good. Because I probably won't get to use it in my day job. Heck the only heavy thing I do is write scripts.
01:16:37 <o^_^o> gienah, thanks, citeseer is overloaded I think, as it is always
01:16:45 <o^_^o> citeseer should merge with wikipedia
01:16:55 <gienah> it will certainly help with passing interview programming questions, even in other programming languages
01:17:12 <o^_^o> gienah, hmm...probably
01:17:52 <o^_^o> But haskell seems to be the only thing that is making me think...
01:18:39 <o^_^o> I mean actually 'think' as opposed to just 'recall' or 'integrate current memory bits in a different ways'
01:19:10 <o^_^o> gienah, what is the title of the book ?
01:19:27 <o^_^o> gienah, I want to try searching in google
01:20:09 <o^_^o> ah..haskell road to logic, math and programming
01:20:13 <gienah> I'm trying to learn haskell, it is challenging :-) Its called the Haskell Road to Logic, Maths and Programming, its only about 25 on amazon
01:20:19 <o^_^o> I already have it downloaded somewhere
01:21:00 <gienah> its a maths book, which has some haskell which helps to reinforce the maths, its a great intro book on the maths topics it covers
01:21:18 <JuanDaugherty> does it have any maths?
01:22:04 <gienah> logic, sets, relations, domains for relations, I guess its probably pretty simple stuff if you are already very familar with maths
01:22:19 <gienah> but as an intro if you are rusty, its very good
01:24:11 <o^_^o> gienah, thanks
01:30:22 <silver> gienah, it's some kind of internal server? connection times out for me :<
01:30:49 <tolkad> Is it ok if I test some unicode characters in here?
01:43:57 <Phyx-> oh, i'm still in here
01:48:05 <younder> I fail to see why. Haskell does support unicode. But it is probably the font you should worry about.
01:50:45 <gienah> silver: no, it times out for me at the moment too, I guess try again later
01:53:38 <Phyx-> that citeseer link is dead 
01:56:28 <Phyx-> anyone else notice that anytime you start coding something meaningful, time just flies by and you have to go to bed?
01:56:35 <Phyx-> seriously, who's idea of a cruel joke is that
01:57:15 <aristid> your brain
01:57:36 <edwardk> phyx: give up sleep. problem solved
02:00:53 <Phyx-> edwardk: i've tried
02:01:02 <Phyx-> but when the laptop starts slipping from my hand
02:01:06 <Phyx-> it's time to give it up :/
02:01:15 <quicksilver> nail laptop to hand.
02:02:22 <edwardk> i should probably get a nap before work myself
02:03:00 <Phyx-> quicksilver: sounds painful
02:03:15 <Phyx-> i'm heading off to uni myself
02:03:23 <Phyx-> to show everyone that i'm still alive
02:04:18 <aristid> edwardk: nah, you can sleep when you're dead
02:04:28 <edwardk> aristid: fair nuff =)
02:04:59 <edwardk> one nice thing about splitting discont and context is now it becomes apparent how to implement a PointerT comonad
02:05:22 <edwardk> and what laws it should satisfy
02:35:16 * hackagebot grammar-combinators 0.2 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2 (DominiqueDevriese)
02:47:19 * hackagebot she 0.2 - A Haskell preprocessor adding miscellaneous features  http://hackage.haskell.org/package/she-0.2 (ConorMcBride)
02:49:32 <lars9> in parsec, how to match a pattern for certain times? for example: do{char '('; matchSomeTimes 3 5 (oneOf "abc") ; char ')'}, it's to match (oneOf "abc") 3 to 5 times, how to implement matchSomeTimes ?
03:16:31 * hackagebot grammar-combinators 0.2.1 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2.1 (DominiqueDevriese)
03:19:12 <koala_man> lars9: this is how I did it http://pastebin.com/ZPF5YZtZ
03:23:42 <lars9> koala_man: let me read it, thanks
03:26:34 <lars9> koala_man: looks good, thanks
03:28:30 <lars9> I'm using parsec for the 1st time, could anyone critize my usage of parsec in a simple regex lib? http://hpaste.org/42759/regex  thanks very much
03:29:21 <lars9> *criticize
03:37:35 <lars9> how to match abc.*xyz using parsec? .* means any number of any char
03:40:16 <ziman> lars9, you can use try + lookAhead
03:41:02 <ziman> but you might as well rethink the grammar to avoid such rules
03:42:37 <ddarius> string "abc" >> many (noneOf "x") >> string "xyz"
03:43:10 <lars9> ddarius: but this is not correct.
03:43:26 <quicksilver> ziman: lars9 is writing a parsec parses which parses regexps and outputs a parsec parser.
03:43:40 <quicksilver> (which parses whatever the regexp parsed)
03:43:47 <lars9> ziman: so i can not use 'many' in this case?
03:45:01 <lars9> quicksilver: exactly. so it seems i can not use parsec's many directly for regex's abc(efg)*hi 
03:45:32 <lars9> what else works?
03:45:44 <Jafet> Text.Regex works
03:46:28 <quicksilver> Jafet: it doesn't, actually, because that does not solve the problem "writing a parsec parses which parses regexps and outputs a parsec parser which parses whatever the regexp parsed.
03:46:37 <lars9> abc(egf)*hi is not a good example, abc(de)*dX is better.
03:46:51 <Jafet> Sure, but Text.Regex still works!
03:47:16 <lars9> no, a.*b is better.
03:47:26 <Jafet> Parsec doesn't compile grammars, I think
03:47:47 <quicksilver> right
03:47:54 <quicksilver> you can't do much compilation and still have a monadic interface
03:47:58 <quicksilver> >>= is too general a type.
03:48:45 <Jafet> Can parsec do context-sensitive parsing?
03:49:16 <opqdonut_> parsec can do anything
03:49:25 <lars9> i need to convert a.*b to a.b <|> a..b <|> a...b ...
03:49:37 <Jafet> Except be really fast
03:49:41 <opqdonut_> indeed
03:49:59 <opqdonut_> lars9: for a.*b you can use string "a" >> many (noneOf "b") >> string "b"
03:50:18 <lars9> opqdonut_: yeah, how to parse abc.*xyz ?
03:50:20 <opqdonut_> lars9: you run into complications when you have a complex string x instead of "b"
03:50:22 <Jafet> Why not make a finite automaton and then wrap it in parsec
03:50:44 <opqdonut_> lars9: but it's certainly doable with try
03:51:14 <quicksilver> opqdonut_: string "a" >> many (noneOf "b") >> string "b" gives the least greedy match, but regexps are greedy, aren't they?
03:51:29 <quicksilver> a.*b should match all of "abbbbbb" not just the first two chars?
03:51:40 <opqdonut_> ah, you are correct of course
03:51:46 <lars9> try (f "abc.xyz") <|> try (f "abc..xyz") ... ?
03:52:07 <quicksilver> lars9: again, that favours the shortest match but regexps are supposed to favour the longest match
03:52:31 <opqdonut_> lars9: string "abc" >> (try "xyz" <|> char)
03:52:38 <opqdonut_> but yeah, that's again the shortest match
03:53:01 <opqdonut_> and I can't remember what the name of the parser that consumes a single char is, so I used "char"
03:53:11 <lars9> quicksilver: that's an option, match shortest/longest.
03:53:40 <lars9> opqdonut_: anyChar
03:53:55 <quicksilver> lars9: but the default interpretation of regexp is longes.
03:54:53 <lars9> if we can match shortest, we can repeat it to match the longest.
03:55:16 <ddarius> I don't believe regular expressions specify greediness, they are supposed to match -all- strings.  Perhaps POSIX gives a definition.
03:55:53 <ddarius> People have made greedy manys before.
03:56:20 <quicksilver> ddarius: mathematically they simply specific a language so they obviously 'accept' lazy + greedy.
03:56:40 <quicksilver> ddarius: but operationally (by long tradition) the sed/grep/perl implementation will match greedy.
03:56:57 <quicksilver> perl has an ugly syntax for non-greedy
03:57:00 <quicksilver> (?:) IIRC
03:57:22 <lars9> quicksilver: by greedy you mean shortest or longest?
03:57:31 <quicksilver> longest.
03:57:44 <lars9> i just tested vim, it's longest.
03:58:34 <koala_man> isn't it fo*?bar for shortest in perl?
03:58:40 <theorbtwo> quicksilver: (?:) is non-capturing.  koala_man has it.
03:58:54 * quicksilver nods
03:59:02 <koala_man> reluctant or modest quantifiers
03:59:04 <lars9> hmmm, so back to the question, how to match abc.*xyz with parsec?
03:59:09 <quicksilver> my motto is 'if you're trying to do something like that, don't use a regexp ;P'
03:59:47 <Jafet> "Greedy" doesn't mean longest or shortest, but first
04:00:29 <lars9> we can replace . with x, xy etc.
04:00:53 <koala_man> lars9: how about http://pastebin.com/8m8UzQaK
04:01:38 <Bynbo7> sn't there a not followed by thing in parsec?
04:02:04 <Bynbo7> lars9: so, you want to match between two strings?
04:02:25 <opqdonut_> lars9: what's wrong with the try solution I gave?
04:04:38 <lars9> opqdonut_: this one? string "abc" >> (try string "xyz" <|> anyChar)
04:05:07 <opqdonut_> ah, yeah, it needs a repeat
04:05:19 <opqdonut_> sorry :)
04:05:27 <lars9> hmm, could you please add repeat to it?
04:06:58 <opqdonut_> something like: let p = (try string "xyz" <|> (anyChar >> p)) in string "abc" >> p
04:07:13 <opqdonut_> sorry I don't have ghci on this machine to check that
04:07:25 <opqdonut_> hmm, try (string "xyz") obviosly...
04:07:51 * hackagebot she 0.3 - A Haskell preprocessor adding miscellaneous features  http://hackage.haskell.org/package/she-0.3 (ConorMcBride)
04:07:58 <lars9> koala_man: thanks, but return [] does not make much sense here? Nothing -> return []
04:08:10 <koala_man> why not? 
04:09:08 <lars9> oh, we need two patterns here: (p1)*p2, means many p1, then p2. which one your p is?
04:09:33 <j-invariant> http://sneezy.cs.nott.ac.uk/fplunch/weblog/wp-content/uploads/2006/10/Kan_Extensions_For.png
04:09:42 <koala_man> p1
04:10:15 <lars9> koala_man: it seems we can not do this without involving p2
04:10:28 <koala_man> yourExample = string "abc" >> greedy (string "de") >> string "dX"
04:10:44 <lars9> for example, in abc.*xyz, how can we know when to stop without using 'xyz'?
04:11:02 <koala_man> that would be abc(de)*dX
04:11:07 <lars9> sorry that's a bad example.
04:11:38 <lars9> abc.*xyz is better.
04:12:20 <lars9> opqdonut_: that one seems make sense, let me test later.
04:12:44 <koala_man> hmm
04:15:28 <lars9> opqdonut_ koala_man: yeah, it works, look: http://hpaste.org/42760/abcxyz
04:17:06 <koala_man> lars9: no it doesn't: parse (ps >> eof) "" "abcxyzxyz" 
04:19:13 <lars9> koala_man: it only returns last match now, we need to add do and some <- ?
04:22:20 <koala_man> lars9: if you want to get the matched values out, yes. but note that it still doesn't work
04:22:30 <opqdonut_> lars9: how about "between"?
04:23:02 <lars9> koala_man: could you explain a little bit? thanks
04:23:26 <opqdonut_> oh, between doesn't try
04:23:34 <opqdonut_> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Combinator.html#between
04:24:14 <koala_man> lars9: abc.*xyz should match "abcxyzxyz" 
04:24:18 <povman> can i use arrows to clean up this code: main = join $ withFile <$> (head <$> getArgs) <*> pure ReadMode <*> (pure $ mapM_ print . enumFromTo 1 . read <=< hGetContents)
04:24:24 <koala_man> all of it
04:24:46 <Bynbo7> povman: that is horribly ugly code
04:25:09 <Bynbo7> the IO monad has a place, you should consider using it :\
04:25:11 <povman> Bynbo7: yes, it used to be really nice until i decided to try to use applicative :)
04:25:25 <lars9> koala_man: you mean longest match vs shortest match?
04:25:45 <koala_man> lars9: either way
04:25:55 <lars9> yeah, it is shortest match now.
04:26:03 <koala_man> no
04:26:28 <quicksilver> Bynbo7: that is "the IO monad". Presumably you mean "do notation" ?
04:26:45 <lars9> twisted a little bit to output all match: let ps = let p = do (try (string "xyz") <|> do{c <- anyChar; cs <- p; return $c:cs;}) in string "abc" >> p
04:27:11 <povman> just wondering if there's a nicer way, so I could do something like: withFile `op1` (head <$> getArgs) `op2` ReadMode (pure blah......hGetContents)
04:27:27 <Boxo> that's not the IO monad. Not a >>= or return in sight.
04:27:41 <povman> :t withFile
04:27:42 <lambdabot> Not in scope: `withFile'
04:27:42 <koala_man> lars9: if it was shortest match, ^abc.*xyz$ would match all of "abcxyzxyz". in this case, it just matches abcxyz and then fails
04:27:44 <quicksilver> Boxo: there is a <=< though.
04:27:46 <merijn> Boxo: Who says you need those for using monads?
04:27:48 <quicksilver> Boxo: and a join.
04:28:00 <quicksilver> both monadic combinators.
04:28:03 <povman> Boxo withFile returns IO
04:28:04 <Boxo> oh yeah¨
04:28:11 <merijn> :t join
04:28:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:28:16 <merijn> :t <=<
04:28:17 <lambdabot> parse error on input `<=<'
04:28:23 <merijn> :t (<=<)
04:28:24 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
04:28:27 <Boxo> so nevermind, those are very monadic
04:29:24 <povman> sooo... is there a way I can slip that (head <$> getArgs) in as the first argument without it being totally ugly, or do I need to use >>= ?
04:29:31 <lars9> koala_man: yeah, you are right, try (string "xyz" >> eof) will work though
04:29:46 <merijn> What's wrong with do notation?
04:30:07 <povman> merijn:  nothing, just seems as though it should be doable
04:30:23 <merijn> Just because you *can* do something doesn't mean you should >.>
04:30:32 <povman> the <*> operator almost lets me get away with it
04:30:42 <povman> and <$>
04:33:50 <Jafet> Well, it is do-able
04:36:29 <povman> all i need is op1 :: Monad m => (a -> b) -> (m a -> b)
04:37:38 <povman> almost liftM
04:39:17 <lars9> hah, that's exactly manyTill
04:39:26 <lars9> shortest match.
04:43:05 <qfr> Do any of you use the latest Haskell Qt bindings btw? Are they pretty mature?
05:02:57 <Baughn_> So, to poke a suppurating wound..
05:03:21 <Baughn_> Non-unicode filenames. readFile. Any nice happy libraries that redefine filepaths are bytestrings?
05:10:02 <ivanm> Baughn_: not that I know of
05:10:15 <ivanm> IIRC, part of the problem is dealing with cross-platform issues
05:10:47 <ivanm> and how they define/deal with directory names
05:12:11 <Jafet> Part of the problem is that FilePath is a type synonym of a type synonym
05:13:44 <pastorn> If i use malloc from within forkOS and the thread dies, does that memore get freed? And what about forkIO?
05:14:03 <Baughn_> pastorn: Which malloc?
05:14:38 <Baughn_> ivanm: When I think about it, it probably wouldn't help open this file anyway. The filename contains several NULs.
05:14:59 <ivanm> :s
05:15:01 <Baughn_> ivanm: had fun constructing that. ^+^
05:15:04 <ivanm> Jafet: heh
05:16:26 <Jafet> pastorn: malloc memory is usually not thread-local
05:16:35 <Jafet> I'd look into attaching a finalizer
05:16:44 <shepheb> if I want to pull out and summarize some bits of a decently formed HTML page, what library would be best?
05:17:23 <ivanm> shepheb: *shrug* tagsoup? html? pandoc?
05:17:41 <beastaugh> anyone know what this cabal-install error message means?
05:17:43 <beastaugh> "Package regex-pcre-builtin-0.94.2.1.7.7 is in the pre-existing state but it depends on package regex-base-0.93.2 which is in the configured state"
05:17:47 <sipa> how could a memory area, defined by a pointer to its first position in memory, be thread-local, if threads by definitions live in the same address space?
05:17:47 <pastorn> Baughn_: i'm just curious :)
05:17:54 <pastorn> i don't have any use case yet
05:18:09 <Baughn_> pastorn: Again, it depends on which malloc you use.
05:18:18 <pastorn> Baughn_: which are there?
05:18:32 <pastorn> Foreign.Array.malloc, that's the only one i've used
05:19:03 <pastorn> sorry, Foreign.Marshall.Array.malloc
05:19:06 <Jafet> sipa: you don't need the concept of address space to define threads in haskell
05:19:11 <Baughn_> pastorn: There's alloca (stack allocation), which is always deallocated, there's malloc from a C program which never is - so be careful to block interrupts - then there are a couple variants of malloc-from-haskell
05:19:43 <Baughn_> pastorn: Some of which are GC-enabled and some of which aren't. Just read the documentation carefullty.
05:19:47 <aavogt> shepheb: I suggest tagsoup or hxt
05:20:56 <pastorn> cool, thanks :)
05:21:09 <sipa> Jafet: a value of type Ptr a dereferences to the same value in each thread, no?
05:23:04 <pastorn> hmm... how does ForeignPtr and Ptr differ?
05:26:42 <merijn> pastorn: I believe ForeignPtr is for stuff which needs to do some garbage collection activity related to the language it came from
05:27:00 <merijn> pastorn: (i.e. something which needs to be freed after use for example)
05:28:16 <pastorn> OpenGL uses Ptr but Data.ByteString.Internal deals with ForeingPtr
05:29:25 <Baughn_> pastorn: ForeignPtr is GC'd, Ptr isn't.. basically..
05:29:32 <j-invariant> Does anyone know uAgda?
05:29:36 <Baughn_> pastorn: ...
05:29:37 <pastorn> ok
05:29:40 <pastorn> Baughn_: yes?
05:29:43 <Baughn_> pastorn: No, don't believe that one. I'm uncertain.
05:29:48 <pastorn> hehe
05:30:18 <Baughn_> pastorn: But here's one issue I *am* certain of. You can't really *use* a foreignptr for anything - you have to convert it to a ptr first. If you then drop the foreignptr, the memory may get GCd. So don't.
05:30:23 <felix___> Snapframework, I can't see top find a small example project
05:30:32 <Baughn_> pastorn: Fortunately there are withForeignPtr style functions in the library to avoid that.
05:31:50 <pastorn> Baughn_: that's what i'm using now...
05:32:07 <pastorn> had a nice graphics bug steming from -On, n > 0
05:32:29 <pastorn> where -O0 didn't GC the pointer directly, but the others did
05:32:35 <sipa> a nice graphics bug, that's a bug that causes nice graphics? ;)
05:32:54 <pastorn> http://users.mkeyd.net/~alexander/gl-sdl-O0.png
05:32:56 <pastorn> http://users.mkeyd.net/~alexander/gl-sdl-O1.png
05:33:12 <humasect> =)
05:33:13 <pastorn> you can see where the GC kicks in
05:33:49 <Baughn_> yeah..
05:34:08 <Baughn_> pastorn: By the way, want a better catalog packing function?
05:34:23 <Baughn_> pastorn: Mine's in C++, unfortunately, but it should be fairly readable
05:35:01 <pastorn> Baughn_: ehm... sure...
05:35:09 <pastorn> i didn't write any rendering code, a friend did
05:35:16 <pastorn> i've been messing with setting up SDL properly
05:35:16 <Baughn_> pastorn: https://github.com/Baughn/Dwarf-Fortress--libgraphics-/blob/master/g_src/renderer_opengl.hpp <- Here, the catalog_fitter class
05:35:18 <Phyx-> anyone have a nice graphic of the timeline of type system development?
05:35:56 <pastorn> Baughn_: damn the single-treadedness of sdl!
05:35:59 <pastorn> (and gl)
05:36:02 <Baughn_> pastorn: ...yeah.
05:36:15 <Baughn_> pastorn: Anyway. It's a greedy algorithm, but I typically get efficiencies of >95%.
05:36:23 <Baughn_> Runs really fast, too. :)
05:36:38 <sipa> @pl \x -> g (f x + a)
05:36:39 <lambdabot> g . (a +) . f
05:36:52 <pastorn> Baughn_: what's needed to try this? and which lines are of interest?
05:37:08 <Baughn_> pastorn: Basically the entire class
05:37:22 <Baughn_> pastorn: And the class is stand-alone; you can cut and paste it to try it.
05:37:26 <sipa> @pl \x -> g (f x - a)
05:37:27 <lambdabot> g . subtract a . f
05:37:32 <sipa> @pl \x -> g (f x `op` a)
05:37:33 <lambdabot> g . (`op` a) . f
05:37:41 <pastorn> Baughn_: so what does it do?
05:37:46 <pastorn> i can't really read c++ :(
05:37:55 <Jafet> Phyx-: in the beginning, there was only Void...
05:38:10 <humasect> =)
05:39:11 <Jafet> sipa: http://appleseedhq.net/galleries/glitch-pictures-ompforg
05:39:15 <Baughn_> pastorn: Instantiate a catalog_fitter, call fit with the size of a texture, and it returns a position to put it at in a texture catalog
05:39:39 <Jafet> (one of those bugs actually turned into a conference paper on artistic rendering afaik)
05:39:43 <Phyx-> Jafet: rofl, good start :)
05:39:44 <Baughn_> pastorn: ..it does not seem to have a function to return the size of the entire catalog, as currently seen, which would be handy. I wrote it, then I realized I don't actually need it.
05:39:54 <sipa> Jafet: haha
05:40:18 <Baughn_> pastorn: As for the algorithm, umh, ping me in about six hours and I'll have time to explain it.
05:43:10 <pastorn> Baughn_: ok... i dont' really know if this will be nessecary... this was just a sprite loading test shot you saw, not some way to try to catalogue stuff
05:45:54 <sipa> Jafet: http://sipa.be/static/cg/table1.png <- that was one of the strangest bugs i encountered when i wrote a raytracer once (the "things" on the table weren't supposed to be there)
05:46:02 <Baughn_> pastorn: If you've got a texture per sprite, your performance will /suck/.
05:46:05 <Baughn_> pastorn: Trust me on this.
05:46:42 <Jafet> Wait, rendering is performance-critical for DF2?
05:46:48 <pastorn> Baughn_: probably, but i'll see about that when i get there :)
05:47:24 <Philippa> Baughn_: is your sprite some people's sprite-frame here?
05:47:45 <Baughn_> Philippa: Yes
05:47:51 <Baughn_> Jafet: Spending 10% of cpu time on rendering means 10% less to spend on simulation
05:47:54 <Philippa> or even some people's entity? (apparently not, thankfully)
05:48:00 <Baughn_> Jafet: Though I've seen it a lot higher than that..
05:48:41 <Jafet> Or you can offload simulation to the GPU
05:48:57 <Baughn_> Not usually
05:49:07 <Philippa> Baughn_: 'k. I agree on that one then, I'm less sure about bundling up several sprites as in sets-of-frames into one texture if you don't have to (but I guess if I were doing AAA work I probably would)
05:49:30 <Baughn_> Philippa: The main point is to minimize the number of texture transitions.
05:49:44 <Baughn_> Philippa: If you can assume opengl 3.0, you have texture arrays that make this pretty much a non-issue
05:51:00 <pastorn> Baughn_: is switching active texture objects that expensive?
05:51:13 <pastorn> i mean, it's already all in VRAM
05:51:17 <Philippa> Baughn_: yeah. The stuff I understand well's really DX7 era and earlier, but I get that much - was just commenting on a boundary between "you should have your toolchain spit out a spritesheet per sprite and your renderer work with that" and "shove everything into one"
05:51:25 <Baughn_> pastorn: It's an opengl call.. basically, /yes/.
05:51:45 <pastorn> well, just switching a GLuint for another can't be that expensive, can it?
05:51:49 <Baughn_> pastorn: At least, you don't want to do it 80*25*2 times a frame, like DF did
05:51:58 <Philippa> Baughn_: I'd be more worried about the pipelining on the other side these days, as I gather that most OGL drivers're threaded and buffer stuff now, but yeah
05:52:03 <Baughn_> pastorn: No, it's a lot more work than that. A full GPU pipeline stall.
05:52:15 <Philippa> and yeah, the pipeline stall's the big deal
05:52:27 <Philippa> API calls aren't the issue so much these days
05:52:28 <quicksilver> I doubt 80*25*2 active texture object switches matters.
05:52:33 <quicksilver> 8000*25*2 would.
05:52:37 <Baughn_> quicksilver: It does, for some people
05:52:38 <pastorn> Baughn_: DF?
05:52:41 <Baughn_> Yeah
05:52:56 <Baughn_> quicksilver: I've seem CPU usage from that at everything from 2% to 50%
05:53:06 <pastorn> quicksilver: we've said that we want to have this running on an eee 700
05:54:35 <Philippa> quicksilver: that's per frame, or per second?
05:55:44 <Baughn_> pastorn: Then you can't expect GL 3, and you don't have the raw horsepower for lots of transitions. You'll have to deal with texture catalogs.
05:56:43 <quicksilver> Philippa: per frame
05:57:08 <quicksilver> Philippa: obviously it depends on your target graphics card and OS and system and etc etc etc
05:57:30 <quicksilver> Philippa: but a few hundred of anything per frame is not normally a problem.
05:57:53 <Philippa> quicksilver: 4000 swaps a frame's actually quite a lot on sufficiently old hardware. That said, I suspect the intel stuff's not as deeply pipelined
05:58:19 <pastorn> Baughn_: i was thinking about this: http://hackage.haskell.org/package/OpenGLRaw21
05:59:56 <pastorn> JaffaCake: yay! it works now that i don't let my Ptr be used outside of the function i give to withForeignPtr
06:00:09 <JaffaCake> pastorn: great :)
06:02:04 <Philippa> quicksilver: anyway, when in doubt - benchmark. My guess is it'll be doable on a 945
06:02:14 <Philippa> ...oh, wait, the eee 701's actually got something slower than that, hasn't it?
06:02:24 <Philippa> (and I ought to know, I've got one lying around in the other room!)
06:02:33 <pastorn> a friend of mine has one of those (it's his fastest computer)
06:02:42 <pastorn> so it'd be nice if he could play what we make
06:03:45 <pastorn> Philippa: Intel GMA 900
06:03:49 <pastorn> http://www.umpcportal.com/products/ASUS/eee%20pc%20701/701
06:04:31 <Baughn_> pastorn: Yeah. GL 2.1 is highly compatible, but it does require a lot of extra fiddling.
06:05:01 <pastorn> Baughn_: like what?
06:05:14 <pastorn> do you mean mashalling all the foreign types etc?
06:05:41 <Baughn_> pastorn: No, I mean compared to GL 3. Like making explicit texture catalogs instead of having the drivers do that with texture arrays, etc.
06:05:58 <Baughn_> pastorn: Integer-indexed texture arrays in shaders are brilliant. :)
06:06:05 <pastorn> ah
06:06:19 <Philippa> Baughn_: all the old 8-bit palette techniques are back, huh?
06:06:28 <Philippa> (yay, we can do Doom's spectre effect again!)
06:06:45 <Baughn_> Philippa: No, this is in fact considerably worse. :P
06:06:52 <pastorn> Baughn_: true, you only need to send the index as a uniform, and not set a new active texture
06:07:07 <Baughn_> pastorn: Or *compute* the index, which is handy in DF
06:07:20 <Philippa> "worse"? I mean, bearing in mind that I was already a pretty filthy thinker when it came to such things?
06:07:32 <Philippa> oh, I guess with DX10 you really can go one nastier
06:07:53 <Philippa> can geometry shaders or whatever they're called do texture access too?
06:08:06 <Baughn_> Yep
06:08:20 <Philippa> fun :-)
06:08:35 <Baughn_> So can vertex shaders, for that matter
06:08:38 <Philippa> (...so all the old flipCode terrain engines running entirely in hardware, then)
06:08:51 <Baughn_> ..I wouldn't call it hardware
06:09:24 <Philippa> sure. But running on a vector-specialised substrate rather than a traditional CPU, anyway
06:09:30 <Baughn_> Philippa: In DF, we're imagining stuff like.. uploading the map (per-tile sprite indexes) as a texture, and having shaders look at /adjacent/ tiles to decide which sprite to actually use
06:09:59 <Philippa> mmm, so the sort of stuff that the Starcraft editor does, done on the fly? Nice
06:10:10 <Baughn_> Essentially, yeah
06:10:48 <Philippa> no CA-based animations running entirely in hardware yet, though? :p
06:10:59 <Philippa> (Cellular Automaton, that is)
06:11:07 <Baughn_> Heh, no
06:11:14 <Baughn_> Not.. yet.
06:11:17 <Baughn_> Hmm
06:11:19 <Baughn_> Ants...
06:11:22 * Baughn_ grins maniacally
06:12:10 <Philippa> how much data is it possible to slurp back into main memory per frame realistically these days, anyway?
06:12:27 <Baughn_> Per-frame? Depends on frame length. :P
06:12:31 <Baughn_> Per-second? Couple gigabytes.
06:12:57 <Philippa> mmm, I'm of the "aim for 60Hz" mindset, but then I play a lot of fighting games
06:12:59 <Baughn_> Well, ideally.
06:13:06 <Philippa> (if you think FPSers get picky about frames...)
06:13:09 <Baughn_> Right. DF aims at 20Hz.
06:13:48 <Philippa> most of the time I'd prefer at least 30Hz for animation purposes, but then I'm one of those people who see the individual frames at the cinema when their brain's been nudged in the right way
06:14:02 <romildo> Hi.
06:14:29 <Philippa> hi
06:15:59 <romildo> Using the module Network.HTTP, how to create a request corresponding to the following post submission done with curl:
06:15:59 <romildo>   curl --data "search=Bourne" http://www.interfilmes.com/busca.html
06:17:16 <pastorn> anyone has any clue as to what this does? GL.textureLevelRange :: GL.TextureTarget -> StateVar (GL.Level, GL.Level)
06:20:28 <ivanm> pastorn: takes in a TextureTarget and returns two levels in a stateful tuple? :p
06:20:44 <pastorn> U SO FANNI
06:20:52 <pastorn> I LAFF
06:21:37 <Philippa> is that about mip-mapping?
06:21:40 <arcatan> romildo: something like this: http://hpaste.org/42761/http_post
06:21:50 <pastorn> Philippa: i have no clue :/
06:21:55 <arcatan> romildo: beware though, that doesn't set the Content-Length header correctly
06:22:34 <Philippa> pastorn: got a non-haskell OGL reference to hand? If not, you should find one. Assuming it's not something newer than I know about, it looks like it's about mip-mapping and the range of levels the renderer can work with
06:23:08 <Baughn_> pastorn: opengl.org works
06:23:32 <Philippa> Baughn_: you're more up-to-date than me, so obviously feel free to let everyone know when I've got it completely wrong!
06:23:39 <Philippa> pastorn: do you know what mip-mapping is?
06:24:06 <pastorn> no, can't say that i fully understand it
06:24:20 <arcatan> romildo: my experience is that Network.HTTP is rather complicated. curl and http-enumerator libraries are easier.
06:24:21 <pastorn> it' something about what to do when scaling a texture?
06:24:34 <Phyx-> "Several 1985-7 deaths of cancer patients were due to overdoses of radiation resulting from a race condition between concurrent tasks in the Therac-25 software" <-- that's one way to go
06:27:12 <pastorn> holy shit... i did something bad
06:27:31 <pastorn> now my code won't run in in ghci/with runhaskell, but compilation works instead
06:27:41 <Baughn_> pastorn: Are you using GLUT?
06:27:46 <pastorn> Baughn_: SDL
06:27:56 <pastorn> i'm starting off by doing forkIO
06:28:05 <pastorn> the waiting on a TVar Bool to quit
06:28:19 <Baughn_> Either way.. ah, I think it's actually opengl-specific, not glut or sdl
06:28:24 <Philippa> pastorn: yup, mip-mapping effectively caches downsamples of a texture
06:28:50 <pastorn> Baughn_: we had this before, when we were messing with multiple threads and openGL
06:29:02 <pastorn> the whole preservingMatrix-business doesn't work properly
06:29:25 <Baughn_> pastorn: * There is a new -fno-ghci-sandbox flag, which stops GHCi running computations in a separate thread. In particular, this is useful for GLUT on OS X, which only works if being run on the main thread.
06:29:31 <pastorn> at least i think it is... as the program gets SDLEvents it zooms in the image
06:29:31 <Baughn_> pastorn: From the GHC 7.0.1 release notes
06:29:46 <humasect> seven..
06:30:03 <pastorn> Baughn_: how do i put that in Main?
06:30:08 <pastorn> what's the pragma?
06:30:12 <Baughn_> pastorn: You don't. There is no pragma.
06:30:33 <Baughn_> pastorn: In general, GL and threading don't go well together. In the absence of explicit context-switching calls, you need to only do GL calls from a single OS thread, which must be the one you created the GL window in.
06:30:38 <pastorn> ghci Main.hs -fno-ghci-sandbox ?
06:30:40 <Baughn_> pastorn: Use forkOS to ensure this.
06:30:51 <humasect> yeah. i had to make a custom GHC shell for GL/GLUT
06:30:52 <Baughn_> pastorn: Yes, but I don't think that related. See above.
06:31:17 <pastorn> humasect: that sounds painful
06:31:31 <humasect> eh it was a great learning experience. but probably does not work if GHC API changes!
06:31:50 <Baughn_> humasect: -fno-ghci-sandbox, now. ;)
06:32:01 <humasect> https://github.com/humasect/Nova/blob/master/Source/Shell.hs
06:32:03 <humasect> ah, excellent =)
06:32:35 <pastorn> Baughn_: i can put that in ./.ghci and it works like normal?
06:33:23 <Baughn_> pastorn: Again, unless you're on OS X that's not your problem.
06:33:32 <Baughn_> pastorn: Just make sure all graphical operations are done from a single OS thread.
06:33:38 * mux just did his first self-post on r/haskell: http://redd.it/ewl7o
06:33:51 <pastorn> they are :(
06:34:14 <Baughn_> pastorn: Well, you could always try the option and see if it helps
06:34:23 * pastorn holds 'u' for a while to find out what's wrong
06:38:38 <pastorn> hahahahhaaha, this is awesome
06:39:05 <pastorn> i can choose between either having -O1 or higher OR being able to do my SDLEvent polling on a separate thread
06:40:50 <Jafet> Move everything critical to another file!
06:40:56 <pastorn> haha
06:41:04 <pastorn> it's a cool bug
06:41:13 <Jafet> Main.hs SoLikeRealMain.hs
06:41:15 <pastorn> maybe i should introduce a semaphore for SDL
06:41:30 <pastorn> since the other thread is forked with forkIO it *should* work
06:41:34 <Philippa> pastorn: do you know what optimisation's borking your event polling?
06:42:25 <pastorn> Philippa: http://codepad.org/ypmWU3SN
06:43:03 <pastorn> Philippa: and i don't think it's the optimizations that breaking it...
06:43:09 <pastorn> hang on, i'll do some testing
06:43:31 <pastorn> Philippa: that sleep time is (1/60), should probably be a little shorter, i dunno
06:44:00 <Philippa> eh, if you've got nothing better to do you want a blocking call on the next event if one exists?
06:44:34 <pastorn> i want to gather all events in one "frame" each time the thread wakes up
06:44:46 <Philippa> sure, but what decides frame?
06:45:03 <pastorn> i dunno, this stuff is hard
06:45:12 <pastorn> what if there's a delay somwhere...
06:45:17 <Philippa> (also, is it really a big deal if the thread gathers a few events, decides it's not a new frame yet and sleeps a while?)
06:45:20 <pastorn> then my timing may get all out of whack
06:45:31 <Philippa> ah, you're trying to use fixed-frequency code?
06:46:00 <Philippa> (and if so, what's currently tied to the clock?)
06:46:04 <pastorn> Philippa: i had some cool ideas about how to do this, but threading is messing with me
06:46:31 <pastorn> i wanted a TVar (IO ()) which holds the latest completed rendering
06:46:53 <pastorn> then i can have a constant screen refreshing with that
06:47:14 <Philippa> ah, you're trying to implement triple buffering behind the scenes?
06:47:23 <pastorn> i dunno
06:47:32 <pastorn> i'm just trying to be clever
06:47:34 <pastorn> i think
06:47:47 <Philippa> (the screen buffer, the most-recently-completed buffer and the working buffer)
06:48:00 <pastorn> yeah, that's probably true
06:48:09 <Philippa> if that's what you're trying for, it's OGL's job, or at least GLUT's
06:48:12 <pastorn> and then have a third thread for iterating over the logics
06:48:27 <Philippa> get it rendered to a backbuffer and let the driver sort out which buffer hits the RAMDACs when
06:48:31 <pastorn> Philippa: but they don't do it in STM!
06:48:41 <Philippa> how do you know? :p
06:49:05 <Philippa> congrats on reinventing an actual real-world technique, anyway
06:49:05 <pastorn> haha
06:49:35 <Philippa> I mean, it's always a bit of an ambivalent experience, but the sooner you find out you've done it the better :-)
06:49:51 <romildo> arcatan, I have written this: http://hpaste.org/paste/42761/http_post_annotation#p42762
06:50:05 <romildo> arcatan, does it look good?
06:50:19 <pastorn> one thing i've been thinking about with this stuff is how "deep" an evaluation of something can be, especially in io
06:50:41 <pastorn> so i have (render1 >> render2 >> render3 somthingCalculationIntense)
06:51:09 <pastorn> will that go quicker on my 2nd call to it, or will render3 be a holdup the 2nd time as well?
06:51:42 <Philippa> depends: do you pass outside somethingCalculationIntense's scope in the meantime?
06:52:00 <pastorn> that expression is pure
06:52:14 <pastorn> or what do you mean?
06:52:58 <arcatan> romildo: looks reasonable
06:53:28 <Philippa> I mean scope, exactly that
06:54:04 <Philippa> is it the 'same' somethingCalculationIntense, or is it a fresh one that happens to be equal?
06:54:15 <pastorn> it's the same
06:54:17 <Philippa> (obviously the value of "same" here isn't denotational!)
06:54:30 <Philippa> then laziness'll do what you want it to, yeah
06:54:35 <pastorn> ok
06:54:45 <pastorn> could you give me an example of when it wouldn't?
06:55:22 <pastorn> even if that expression in a Ref somewhere it would still be "locked" once i put it in the TVar, wouldn't it?
06:55:52 <Philippa> foo = let somethingCalculationIntense = ...; in (render1 >> ...); twoPasses = foo >> foo
06:55:57 <Philippa> twoPasses doesn't do what you want
06:56:21 <Philippa> (this is why CSE isn't always an optimisation in Haskell)
06:56:57 <pastorn> wait, will that do the intense part twice?
06:57:07 <Philippa> that will, yes
06:57:16 <Philippa> because it runs the entire let block twice
06:57:18 <pastorn> won't the values of the intense stuff be bount in render3:s closure?
06:57:28 <Philippa> "render3's closure"?
06:58:00 <Philippa> (heh, the above line is a great example of how funky Haskell's layout algorithm can be at times)
06:58:00 <pastorn> doesn't it just save all the render calls?
06:58:18 <Philippa> render1 and render2 are fine, they're values
06:58:22 <Philippa> render3 is a function
06:58:26 <pastorn> Philippa: could you please make a paste for this?
06:58:33 <pastorn> showing how to avoid it
06:58:40 <pastorn> (if possible)
06:58:56 <Philippa> stick the render calls inside the let block
06:59:02 <Philippa> it's all about lexical scope
06:59:22 <Philippa> let allocates a (fresh) thunk each time you pass through it
06:59:47 <Philippa> (similarly, you can consider global scope to be a huge let with "in main" at the end)
06:59:53 <pastorn> so do { render1; render2; let r3 = render3 heavy; r3 }
07:00:13 <Philippa> r3ing a second time in that do is fine, yeah
07:00:49 <Philippa> (and you can use mutable cells to provide you with a way to "attach" things to the scope of the cell's references, yes)
07:01:06 <Philippa> similarly, if you return r3...
07:01:45 <pastorn> Philippa: hmm... you mean like creting a TMVar for heavy each rendering thead, then if it's ever recycled i can just read it?
07:01:59 <Philippa> something like that, I guess
07:02:04 <pastorn> -thread
07:02:10 <Philippa> that said, "heavy rendering" - how much calculation is going on in them compared to everything else?
07:02:18 <Philippa> you won't get to cache the effect of the OGL calls or anything
07:02:26 <pastorn> Philippa: ok, but could you (pretty, pretty, pretty) please make a paste with this?
07:02:40 <Philippa> (so it may be better to cache the data structures that get fed to render rather than the applications of render to those structures)
07:02:54 <quicksilver> Philippa: well, only if the let-binding doesn't get lifted. GHC very rarely does CSE but it will (AFAIK) sometimes lift let-bindings.
07:03:00 <Philippa> um. I realise this is a bit arsey, but that's above my attention threshold
07:03:12 <Philippa> quicksilver: sure, I'm talking modulo transformations
07:03:46 <Philippa> pastorn: all I'd do is paste the chatlog in and maybe if you're really lucky snip out the junk. You okay doing that yourself?
07:04:04 <pastorn> haha, fine :p
07:04:25 <pastorn> it's just that i don't want to get confused on the terminology
07:05:00 <Philippa> yeah. If you remember "let allocates thunks" you can probably work the rest out yourself on paper though
07:05:01 <pastorn> i get the gist of it, but i don't think i'll be capale to re-tell this to anyone anytime soon
07:05:11 <pastorn> true :)
07:05:49 <pastorn> but why is the code wit r3 quicker then?
07:05:56 <lars9> is there a @instanceOf command?
07:06:11 <pastorn> lars9: :i?
07:06:24 <pastorn> @instances Num
07:06:24 <lambdabot> Double, Float, Int, Integer
07:06:42 <lars9> :i Double
07:06:56 <lars9> pastorn: yeah it works in ghci
07:07:42 <Philippa> pastorn: it's only quicker if you call r3 /twice/ at the end
07:07:43 <pastorn> Philippa: i mean, it uses let too, "let r3 = render heavy; r3", won't that allocate a new thunk for r3 on the 2nd pass, forcing reevaluation?
07:08:02 <Philippa> so no, it's not quicker if you just call that the same way
07:08:15 <pastorn> Philippa: oh, ok, but this was to be put in a Var then grabbed twice and executed
07:08:27 <pastorn> *grabbed and executed twice
07:08:37 <Philippa> pastorn: yeah, you need to let-allocate on the outside and put the do block inside the let block
07:09:07 <Philippa> (let somethingCalculationIntense = ...; in do r1 >> r2 >> r3 somethingCalculationIntense) <- shove this in your Var
07:09:41 <Philippa> (it works because it's a value not a function)
07:10:03 <pastorn> Philippa: you're not a GHC hacker by any chance?
07:10:09 <Philippa> (every function call allocates a fresh activation record)
07:10:35 <Philippa> heh. I'm not, though I've read the papers on the STG machine's evolution and the Core language
07:10:43 <pastorn> oh, the STG
07:10:51 <pastorn> i've heard that it's a good read
07:10:55 <Philippa> (and a fair chunk of other work on intermediate reps for functional languages - I think everyone should know ANF)
07:11:35 <Philippa> (and not /just/ because of ANF's relationship with monads on progamming languages!)
07:12:36 <quicksilver> Philippa was going to invent and implement the world's greatest functional programming language, but she decided to play computer games instead. Happens.
07:12:44 <pastorn> Philippa: ANF?
07:13:20 <Philippa> pastorn: Administative Normal Form. It's what you get if you do a CPS transform, remove the administrative redexes and then translate back into lambda-calculus-with-let, roughly speaking
07:13:49 <pastorn> Philippa: what games did you play?
07:13:51 <Philippa> Function applications can only use values for parameters, where a value is roughly a function, a constructor or a bound variable
07:14:09 <Philippa> you get things done by using a succession of let statements
07:14:25 <Philippa> er, do you really need my entire list for the last decade? :-)
07:14:41 <Philippa> ("decided" is a little unfair in my personal circumstances, mind, but I'd rather not go into that atm)
07:15:03 <quicksilver> Philippa: well, I was simplifying in the interest of increased flippancy, I hope you're not too hurt ;)
07:16:03 <pastorn> ==> #haskell-blah
07:16:07 <Philippa> quicksilver: yeah, no harm done :-) There was a phase where I was still looking to contribute on a research level without necessarily providing a whole new major language, mind, and new circumstances might lead to me writing up a little bit of parsing stuff (a blend of some of edwardk's work with the neat language class I ran across)
07:17:47 <edwardk> a very useful language class indeed
07:19:36 <Philippa> *nod*. I'll probably do a writeup about layout first because I think I can neatly tackle all the "tasteful" cases with an additional token class (a subset of the non-stack-modifying ones that's "tied" to a stack frame - in other words, separators)
07:20:16 <Philippa> (hmm, I guess /really/ I need them to be tied to the corresponding class of stack frame without having to parse fully if we're going for complete parser independence, but same difference?)
07:22:57 <Philippa> anyway, I think doing the layout writeup first is probably a good idea because I'm sorta trying to pin down formal aspects of a pseudo-aesthetic as well and it might help me figure that out a bit further
07:23:45 <Philippa> (I *think* Haskell's free of even "local" ambiguities - that is, the need for backtracking - /if/ you're willing to do a bit of rewriting and do the operators in a separate pass?)
07:24:10 <Philippa> (though granted that's partly due to a convenient-but-mildly-deep relationship between constraints and type constructors!)
07:24:25 <quicksilver> Philippa: that sounds like it should be true for all remotely sensible languages, depending how generous you are on "a bit of rewriting"
07:25:23 <Philippa> quicksilver: eh, lookahead's the same thing in this context. The "a bit of rewriting" here is realising that the parse structures up until you resolve the ambiguity have /the same shape/
07:26:03 <Philippa> that is, you can recognise a constraint-or-type, run into a , => or the end of the type as appropriate and then decide whether it was a constraint or a type
07:26:23 <Philippa> if you like, it's semantic lookahead rather than syntactic
07:30:15 <quicksilver> Philippa: *nod*
07:30:16 <quicksilver> neat.
07:31:39 <Philippa> FWIW, I think speccing the class of language I have in mind /and/ making a pleasant parsing lib for it's probably a little bit tricky, but settling for a parsec-style solution is probably good enough
07:33:48 <roconnor> if people don't put join in the Monad class in the new monad proposal I'm going to punch someone in the face.
07:33:53 * hackagebot hackport 0.2.10 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.10 (LennartKolmodin)
07:43:01 <catface> can anyone tell me what the type of a function f g = (g "hello", g 7) is?
07:43:16 <Botje> that's a type error
07:43:44 <sipa> unless you have that extension with the IsString class
07:43:53 <sipa> and have a type that's both Num and IsString
07:44:01 <catface> but id could work as the parameter g...?
07:44:38 <quicksilver> normal haskell doesn't have higher-ranked types though
07:44:49 <dmhouse> catface: it's possible to put a type signature on that function, but by default it will get rejected because of the higher-order polymorphism necessary
07:44:55 <quicksilver> higher-ranked type inference isn't unique
07:45:12 <Philippa> roconnor: agreed. Amongst other things, it actually makes sense if you're writing in applicative terms
07:45:32 <quicksilver> one possible type is (forall a . a -> a) -> (String,Int)
07:45:55 <catface> i see. thanks
07:45:56 <quicksilver> another is (forall a . a -> Bool) -> (Bool,Bool)
07:46:43 <quicksilver> your original type isn't actually an error in standard haskell, it's Num String => (String -> b) -> (b,b)
07:46:46 <quicksilver> isn't it?
07:47:26 <quicksilver> :t \g -> (g "hello", g 7)
07:47:27 <lambdabot>     No instance for (Num [Char])
07:47:27 <lambdabot>       arising from the literal `7' at <interactive>:1:20
07:47:28 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
07:47:35 <catface> oh yes, you're right, i originally tried f g = (g "hello", g 'h')
07:47:40 <quicksilver> hmm. But it searches for the instance at type-checking time.
07:47:41 <sipa> (Num a, IsString a) => (a -> b) -> (b,b)
07:51:10 <Botje> it could also be :: (forall a . a -> b) -> (b,b)
07:51:44 <Botje> but _|_ is not cool enough to play with
07:51:59 <sipa> or (forall a . a -> m a) -> (m String,m Int)
07:52:38 <Philippa> roconnor: actually, can you see a case for factoring join out? Perhaps, join + fmap but no return?
07:53:33 <roconnor> possibly.  It is kinda like a semigroup in the same way that a Monad is like a Monoid.
07:53:51 <roconnor> but it is a tough sell
07:54:00 <quicksilver> Philippa: I can see a tentative case, but the cost/benefit ratio appears poor.
07:54:08 <roconnor> monoids are way more compeling then semigroups
07:54:23 <roconnor> monois being the algebras of the list monad.
07:54:28 <roconnor> *monoids
07:57:18 <catface> it seems if m a represented a type function m applied to a it would work for all cases
07:57:50 <Philippa> quicksilver: it gives you a "good enough" solution to the "monad on a subcategory of Hask" problem?
07:57:58 <Botje> sipa: heh. right :)
07:58:09 <Philippa> (you just use a different name for return, or have a more flexible 'pointed' class)
07:59:41 <Philippa> quicksilver: in particular, it's good enough in that you don't need to touch uses of Monad and it still works with do notation
08:00:47 <quicksilver> Philippa: hmm, right. Interesting.
08:01:09 <quicksilver> Philippa: that's a using it for a workaround instead of appealing to what it might mean mathematically
08:01:12 <quicksilver> but it's a good point.
08:04:25 <Philippa> quicksilver: hmm, actually that's broken - you can use fmap and any acceptable constant to break the invariant
08:10:42 <copumpkin> map (const (extract k)) k == k
08:10:45 <roconnor> Philippa: what is this monad on as subcategory problem?
08:10:48 <copumpkin> that *feels* true
08:10:54 <mightybyte> @pl foldl (\acc next -> next >>= (\a -> fmap (a:) acc))
08:10:54 <lambdabot> foldl (flip liftM2 (:))
08:10:56 * roconnor has a monad on a subcategory of Hask
08:11:29 <Philippa> roconnor: the classic example's a Set monad that requires an Eq constraint on Set members
08:11:32 <quicksilver> roconnor: making Ord a => Set a into a Monad, e.g.
08:11:39 <roconnor> ah
08:11:49 <copumpkin> anyone? :)
08:12:31 <Philippa> most people don't use the "subcategory" description - I keep it around as a way of telling the "haskell monads aren't real monads" crowd to STFU by letting them know exactly how we're (not, in this case) bending things
08:15:27 <Saizan> copumpkin: data Pair a = Pair a a; k = Pair 1 2
08:15:48 <copumpkin> hmm
08:16:03 <copumpkin> well, would it satisfy the copointed law the other way around?
08:16:05 <roconnor> how are haskell monads not real monads?
08:17:19 <Philippa> roconnor: I didn't say said crowd are justified :-) Just that I consider it worth... exerting a degree of cultural pressure against the idea that view might even be particularly well-founded?
08:17:20 <Saizan> which other way? (also, which are the copointed laws?)
08:17:28 <j-invariant> Haskell monads are a specific case of general monad
08:17:43 <roconnor> Philippa: I mean what does the crowd claim?  Also isn't it just that one symbolics guy?
08:17:50 <copumpkin> Saizan: the only one I can think of is extract (fmap f x) == f (extract x)
08:18:02 <j-invariant> it is Functor which is not a real functor
08:18:07 <j-invariant> Function in haskell is ENDOfunctor
08:18:11 <Philippa> roconnor: nah, there've been a lot of people who've said something to that tune over the years
08:18:20 <Philippa> j-invariant: which is also a specialisation of functors in general
08:18:21 <copumpkin> j-invariant: an endofunctor is still a functor :)
08:18:31 <roconnor> copumpkin: I was going to say the same thing
08:18:36 <j-invariant> it should be called Endofunctor
08:18:44 <roconnor> pfft
08:18:46 <vamsi> hi
08:18:50 <vamsi> what is this?
08:18:51 <copumpkin> in haskell we're in a universe with one category
08:18:54 <Saizan> copumpkin: that holds by parametricity though
08:19:00 <djahandarie> Subcategory definition?
08:19:01 <copumpkin> when you only have one category, all functors are endofunctors :P
08:19:01 <Philippa> copumpkin: not true. Many subcategories
08:19:06 <azaq23> vamsi: the chanell for the haskell programming language
08:19:09 <vamsi> oh god can anyone tell me what this is?
08:19:10 <j-invariant> I think the Moggi paper is nontrivial
08:19:12 <roconnor> copumpkin: Acutally I use functors from the category of functors to Hask in my code.
08:19:13 <azaq23> *channel
08:19:14 <vamsi> oh
08:19:22 <vamsi> thank you
08:19:28 <vamsi> azaq23
08:19:29 <copumpkin> Saizan: yeah
08:19:32 <j-invariant> the idea of monads as computations actually take a lot of specialation from the basic definition
08:19:47 <j-invariant> that is why monads in haskell are more of a specialized case than just "being in Hask"
08:20:05 * djahandarie wonders what the subcategory definition of a monad is
08:20:07 <EvanCarroll> the Hask.
08:20:08 <roconnor> who said monads in Haskell were computations?
08:20:17 <dmhouse> j-invariant: how do you need to specialise?
08:20:19 <Berengal> Does ghci have the ability to retain the old module when you try to reload a modified version but compilation fails?
08:20:24 <j-invariant> roconnor: I mean the same thing as moggi
08:20:24 <copumpkin> Saizan: hm
08:20:38 <copumpkin> Saizan: so what would extract on Pair return?
08:20:45 <j-invariant> dmhouse: I don't know what you mean
08:20:45 <copumpkin> one of them, I guess
08:20:49 <djahandarie> Berengal, someone asked something similar earlier... and I don't think it is
08:20:50 <mightybyte> @pl foldr (liftM2 (:)) (return [])
08:20:50 <lambdabot> foldr (liftM2 (:)) (return [])
08:20:51 <roconnor> j-invariant: how do you need to specialise?
08:20:51 <Philippa> roconnor: an idiot trying to shorten a more justified description :-)
08:20:52 <Saizan> copumpkin: yeah
08:20:58 <djahandarie> At least no one said anything then :P
08:20:59 <copumpkin> dammit, I guess my property isn't true
08:21:12 <Philippa> roconnor: it's what happened /after/ "computation" got adopted as a general term for values of type Monad m => m a
08:21:16 <roconnor> <j-invariant> that is why monads in haskell are more of a specialized case than just "being in Hask"
08:21:18 <j-invariant> roconnor: you asked the same question. I don't undersatnd it
08:21:24 <copumpkin> Saizan: actually, mine is for a specific comonad
08:21:27 <copumpkin> or copointed
08:21:31 <Berengal> djahandarie: A bit sad, really. When you need :type and :info the most, you've just lost your context
08:21:42 <dmhouse> j-invariant: you said to get monads-as-computations you need to specialise from the basic definition. How?
08:21:46 <djahandarie> Berengal, :-(
08:21:48 <roconnor> j-invariant: how are Monads in haskell more specialed that monads on the Hask category?
08:21:48 <Philippa> roconnor: "monads as computations" is pretty close to the view I adopted when teaching monads in chan however many years back it was, but it's got subtle-but-fundamental flaws
08:21:52 <Saizan> copumpkin: then we need more info :)
08:21:57 <copumpkin> Saizan: actually, it's general
08:21:58 <Philippa> roconnor: fail :-)
08:21:58 <copumpkin> dammit
08:22:16 <Saizan> copumpkin: not sure if Pair would be a comonad though
08:22:20 <mightybyte> Does lambdabot have the ability to figure out that "foldr (liftM2 (:)) (return [])" is sequence?
08:22:23 <j-invariant> The specialization I am talking about is the subject of: Notions of computation and monads
08:22:27 <j-invariant> Eugenio Moggiâˆ—
08:22:35 <copumpkin> Saizan: well, I'm only using its copointed properties here
08:22:46 <j-invariant> He takes the idea of a monad, and applies it to the theory of lambda calculus
08:22:52 <roconnor> j-invariant: but how does the class definition force monads to be computations?
08:22:56 <j-invariant> that's what we're working with in haskell
08:23:09 <Saizan> copumpkin: ah, so no comonad laws to exploit anyway?
08:23:22 <j-invariant> roconnor: I don't mean "computations" like some blog-post tutorial thing - I mean it in the same way as in Moggis paper
08:23:23 <azaq23> @help
08:23:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:23:23 <copumpkin> Saizan: I do have comonad laws, so maybe
08:23:24 <copumpkin> hmm
08:23:36 <Philippa> roconnor: by isomorphism, at least, they're programs in a language defined in terms of haskell and with an ANF-like structure
08:23:40 <copumpkin> Saizan: so you're thinking it may be true of comonads but not an arbitrary copointed?
08:24:03 <Philippa> roconnor: "computation" is just an alternative term for such programs
08:24:15 <roconnor> j-invariant, Philippa: so the restriction is that the functions have to be implemented as lambda expressions as opposed to uncomputable nonsense?
08:24:29 <Philippa> also, I've just committed the conflation I complained about above through parse error, but yeah
08:24:37 <Saizan> copumpkin: not anymore, because it's not true for e.g. the Pointer comonad
08:24:41 <Philippa> roconnor: well, it's that the underlying category's computational in nature
08:24:49 <copumpkin> Saizan: bummer :)
08:25:08 <roconnor> Philippa:  oh right
08:25:19 <roconnor> so I still don't get what the specialization beyond being in Hask is.
08:25:30 <Philippa> roconnor: I agree, modulo fail
08:25:34 <roconnor> <j-invariant> that is why monads in haskell are more of a specialized case than just "being in Hask"
08:25:40 <roconnor> oh right
08:25:47 <Philippa> roconnor: incidentally it sounds like I really need to write up /my/ version of what's currently called monads-as-computations sometime :-(
08:25:56 <Philippa> ( :-( because I needed to do that five sodding years ago too)
08:26:12 <roconnor> what does fail have to dow with monads as computations?
08:26:14 <copumpkin> here's a general question I have about proofs: if I have something to prove, and use a definitely true lemma to prove it, but the lemma requires something that is obviously false in that context, does that make the overall proof false, or does it just mean "I'm barking up the wrong tree"?
08:26:27 <Philippa> roconnor: jack shit, but everything to do with being more specialised than just being a monad :-)
08:26:58 <roconnor> [11:19] <j-invariant> the idea of monads as computations actually take a lot of specialation from the basic definition
08:27:00 <roconnor> [11:19] <j-invariant> that is why monads in haskell are more of a specialized case than just "being in Hask"
08:27:01 <Philippa> copumpkin: it means you need a paraconsistent logic to tell you to fuck off and reformulate? :-)
08:27:13 <roconnor> j-invariant: what is the more specialization that you refer to?
08:27:23 <roconnor> copumpkin: you are barking up the wrong tree
08:27:38 <Philippa> roconnor: yeah. That's j-invariant projecting slightly, because really he's talking about something that's a viewpoint whether he realises it or not
08:27:59 <Saizan> copumpkin: A -> B, Not A |/- Not B
08:28:08 <copumpkin> Saizan: fair enough :)
08:28:08 <Philippa> (it's just a viewpoint I tend to defend rather strongly because it's /true up to isomorphism/)
08:28:17 <roconnor> what is the viewpoint?
08:28:23 <Philippa> "m-as-c"
08:28:35 * copumpkin goes to find a better tree to bark up
08:28:52 <Philippa> (now if you really want to pick a fight, talk about the idea of monads as architectural components!)
08:29:33 <roconnor> I never want to pick a fight
08:29:35 <quicksilver> ButtressT
08:29:48 <roconnor> ... well except when I asked in #python why I should use python over smalltalk.
08:29:53 <djahandarie> lol
08:29:54 <Philippa> heh
08:30:16 <Philippa> AFAICT, the two good answers are "libraries" and "because it's not image-based and you may have grounds to prefer that"
08:31:17 <dmhouse> Off-topic, but are there any logicians/set theorists in here who happen to know much about interpretability?
08:31:47 <roconnor> dmhouse: Have you tried #logic?
08:32:09 <roconnor> Philippa: libraries is the only answer I've heard
08:32:31 <roconnor> Philippa: It is only a compelling for pragmatic people
08:32:45 <Philippa> yeah, image vs source files likewise
08:33:09 <roconnor> I don't like arguing about the syntax of a language :D
08:33:24 <roconnor> though admitedly making syntax an image is kinda a leap :D
08:33:30 <dmhouse> roconnor: I shall, but it doesn't look like the largest channel ever...
08:33:44 <roconnor> dmhouse: good point
08:34:06 <Philippa> roconnor: heh, the point is that an image isn't just the syntax of the /source/ program
08:34:31 <Philippa> (and indeed that the favoured notion of "program" may be rather different)
08:35:38 <pastorn> Philippa: back again... i'm thinking about my mainloop
08:36:20 <j-invariant> in category theory the monad can be used to set up an algebraic theory (and the algebra of the monad sets up its model)
08:36:41 <pastorn> so i'm thinking i'll have something like updateLogic :: Double -> STM ()
08:37:08 <j-invariant> in Moggi we use a particular theory (simple metalanguage which has functions 'let', etc..) and then a monad instance in haskell is actually the algebraic theory (aka. model) part
08:37:23 <j-invariant> so in haskell we have already had half the work done for us
08:37:46 <j-invariant> The "monad laws" in haskell, are actually the laws for the algebraic theory of a monad
08:37:49 <pastorn> wait... gameLogicUpdateList :: [ Double -> STM () ], which i will do mapM ($ time) over every now and again
08:37:56 <j-invariant> roconnor: that is why I made that statement
08:38:17 <Philippa> j-invariant: that algebraic theory is getting on for the internal language of monads across lambda calculi
08:38:25 <Philippa> that is to say, it doesn't actually specialise any
08:40:14 <Philippa> ("getting on for" because I may be committing a terminological abuse there, amongst other things - I don't think we're talking about a topos for example)
08:41:08 <roconnor> j-invariant: so this has something to do with internal vs external arrows?
08:41:19 <zmbmartin> Is there a better syntax file for vim then this --> http://www.vim.org/scripts/script.php?script_id=2062
08:41:43 <j-invariant> roconnor: I don't think so
08:42:06 <yrlnry> I don't understand why GADTs are interesting.  I've read a bunch of papers, but I don't get the point.  What do GADTs enable that wasn't there before?
08:42:38 <j-invariant> Philippa: tdhe whole point of introducing monads was because lambda calculus is too weak to prove equivalence of computations -- that's why Moggi introduces the simple metalanguage
08:42:54 * roconnor doesn't understand j-invariant
08:43:16 <djahandarie> yrlnry, I'm pretty sure you can encode all GADTs into type classes
08:43:31 <djahandarie> Hmm
08:43:32 <djahandarie> No
08:43:41 <Philippa> j-invariant: which happens to look suspiciously like ANF, which is another specialised lambda calculus with a clear transformation from it
08:43:53 <roconnor> yrlnry: GADTs allow you to have case statments where the types in each branch are different.
08:43:56 <Philippa> (admittedly I forget which was actually defined first)
08:44:22 <Philippa> you can normalise from lambda calculus in general to moggi's form
08:44:28 <djahandarie> yrlnry, think of a GADT representing typed S, K combinators w/ application
08:44:35 <Saizan> djahandarie: you can, but you've to work visitor-pattern-style then, it's oleg's "finally tagless" construction
08:44:38 <yrlnry> djahandarie:  OK
08:44:47 <mightybyte> Is there a way to catch an exception thrown by read without being in the IO monad (or using unsafePerformIO)?
08:45:03 <roconnor> mightybyte: yes, use reads
08:45:10 <Philippa> (you're also /still/ not showing how this is a specialisation of /monads on Hask/ rather than of Hask)
08:45:11 <roconnor> @src read
08:45:12 <lambdabot> read s = either error id (readEither s)
08:45:12 <djahandarie> yrlnry, I think you can avoid GADTs with rank-2 polymorphism though
08:45:25 <roconnor> mightybyte: even better is to steal the GHC source code for readEither
08:45:26 <mightybyte> roconnor: Well, I'm working with an external library that uses read.
08:45:29 <djahandarie> I know Oleg has done something or another regarding this
08:45:33 <j-invariant> Thats what I just explained
08:45:36 <yrlnry> djahandarie:  I thought your remark about SK was going to introduce something further.
08:45:48 <roconnor> mightybyte: ideally you should rewrite the external library
08:45:55 <mightybyte> roconnor: Ok
08:46:02 <roconnor> mightybyte: I hesitate to mention this, but you can use the spoon library.
08:46:06 <Philippa> granted, realising that the metalanguage is already (readily embeddable in) the object language was Wadler's thing rather than Moggi's
08:46:06 <j-invariant> in theory you  can look at monads in Hask over other theories
08:46:12 <mightybyte> roconnor: /me looks
08:46:39 <Philippa> and this changes what about the monad laws, which - expressed in terms of fmap and join - are just the consequences of being a monad?
08:47:14 <yrlnry> djahandarie:  Oh, the idea is that with GADS you can compile-time check the SK expressions for well-formedness?
08:47:19 <tibbe> anyone know if there's a difference in performance between binary and cereal?
08:47:20 <Philippa> >>= is an always-available convenience, it isn't a /change/
08:47:35 <Philippa> yeah, binary's no good for breakfast
08:47:44 <Philippa> and unstable when you pour milk over it
08:48:07 <mightybyte> roconnor: Ahh, yes.  That's exactly what I was looking for...too bad it has to use unsafePerformIO.
08:48:24 <roconnor> mightybyte: spoon is evil. Please don't use it
08:48:28 <djahandarie> yrlnry, oh. :P Well, data Term x where K :: Term (a -> b -> a), S :: Term ((a -> b -> c) -> (a -> b) -> a -> c). Translating this into a type class would not be simple since there is a type paraemter inside the GADT term and not outside of it. I think that is the general case when you can't do it
08:48:28 <mightybyte> roconnor: I think I'll rewrite the external library.
08:48:34 <roconnor> whew
08:48:38 <mightybyte> lol
08:48:54 <Philippa> (what do you call it when you've got a category which has a number of objects which /would/ be initial except they're all isomorphic?)
08:48:57 <djahandarie> Err, s/not be simple/would be impossible without rank-2 polymorphism/
08:49:36 <Philippa> (rather, what label do you put on those objects? Initial up to isomorphism?)
08:50:20 <roconnor> Philippa: isn't initality only defined upto isomorphism?
08:50:27 <mightybyte> roconnor: Is spoon unsafe?  By "safe" I mean that it is possible to write "safe" libraries that use unsafePerformIO if can make enough guarantees about the context.
08:50:35 <j-invariant> See TheCatsters Monads 1 for definition of a Monad, Monads 3 for definition of algebraic theory of a monad.
08:50:47 <j-invariant> If you know Haskell you will not recognize anything in video 1 but you will recognize everything in video 3
08:50:47 <Philippa> j-invariant: something in text, please
08:51:04 <yrlnry> djahandarie:  Sorry, I don't understand what the types here are supposed to be tracking.
08:51:08 <Saizan> djahandarie: i guess you also want application App :: Term (a -> b) -> Term a -> Term b
08:51:11 <yrlnry> djahandarie:  and what is the benefit?
08:51:25 <j-invariant> A monad is like an algebraic theory, and an algebra for a monad is like a model: In haskell we implement models of the monad using 'instance'
08:51:28 <Saizan> yrlnry: that only well-typed SK expressions are expressible as Term
08:51:28 <yrlnry> I think I'm missing a big piece of context.
08:51:40 <djahandarie> Yeah, oops, sorry, App too like Saizan wrote
08:51:54 <j-invariant> the monads theory*
08:51:57 <Saizan> yrlnry: so you can e.g. write an eval function like eval :: Term a -> a, which is guaranteed to not error out
08:52:06 <yrlnry> Aha.
08:52:15 <yrlnry> Why do GADTs enable this>
08:52:16 <yrlnry> ?
08:52:42 * djahandarie is not sure how to answer that in one sentence
08:53:02 <Philippa> j-invariant: without forcing me to watch a video, you're still not succeeding in explaining what's going on here that's more than notational
08:53:03 <roconnor> j-invariant: I know what an algebra of a monad is.  It is a function of type (m a -> a) satifying two laws. ... at least that is how I'd define it in haskell
08:53:42 <roconnor> j-invariant: but I *think* you are saying that a Monad class in Haskell is an algebra of a Monad, which doesn't make much sense to me.
08:54:22 <Saizan> yrlnry: well, you can write only well-typed expressions because the indexes have to match when you use the App constructor, essentially
08:54:34 <j-invariant> roconnor: oh you're right, I had these mixed
08:54:37 <jmcarthur> the reason spoon exists is not to do dangerous things but to work around design flaws in other libraries
08:54:39 <roconnor> gah!
08:54:40 <roconnor> :D
08:54:50 <Philippa> roconnor: it does sound an awful lot like there's been a confusion about notation, yeah
08:54:55 <jmcarthur> it's ugly, but i don't know about evil
08:55:05 <Philippa> obviously you don't draw diagrams in haskell!
08:55:20 <Philippa> but /if I translate those diagrams into an algebraic notation/...
08:55:26 <roconnor> Philippa: true, but we do write laws, which are the same as diagrams, right?
08:55:29 <Philippa> then raw CT looks familiar enough
08:55:34 <Philippa> roconnor: exactly
08:55:41 <Philippa> well, sets of laws are
08:55:56 * roconnor as been studing coalgebras of comonads recently so now knows a little bit of this sort of stuff.
08:57:47 <roconnor> heh, mathematicals calls List the "monad for monoids"
08:57:49 <roconnor> cute
09:13:35 <Fred1812> Is there a more concise way to write the following function?
09:13:35 <Fred1812> cube list = [(x, y, z) | x <- list, y <- list, z <- list]
09:13:49 <Fred1812> > let cube list = [(x, y, z) | x <- list, y <- list, z <- list] in cube [1..2]
09:13:50 <lambdabot>   [(1,1,1),(1,1,2),(1,2,1),(1,2,2),(2,1,1),(2,1,2),(2,2,1),(2,2,2)]
09:13:54 <qfr> It would be nice to have a generalised version of that
09:13:58 <qfr> For n dimensions
09:14:08 <Fred1812> qfr: yes, my sentiments exactly
09:15:50 <quicksilver> > replicateM 3 [1..2]
09:15:51 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
09:15:58 <quicksilver> ^^ Fred1812, qfr 
09:16:02 <quicksilver> (not quite the same type, of course)
09:16:03 <qfr> Amazing :/
09:16:33 <quicksilver> > [1..] >>= (flip replicateM) "ab"
09:16:36 <lambdabot>   ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb...
09:16:55 <qfr> @src replicateM
09:16:56 <lambdabot> replicateM n x = sequence (replicate n x)
09:17:02 <qfr> @src sequence
09:17:03 <lambdabot> sequence []     = return []
09:17:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:17:03 <lambdabot> --OR
09:17:03 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:21:07 <Cale> qfr: In the list monad, "running" a list means to select an element from it in all possible ways
09:21:43 <Cale> So when sequence does v <- x it, just like a list comprehension, picks an element v from the list x in all possible ways
09:21:48 <qfr> http://stackoverflow.com/questions/2921345/how-do-i-convert-a-list-to-a-tuple-in-haskell
09:22:23 <Cale> Mostly by pattern matching, but large tuples are not common.
09:22:33 <qfr> Template Haskell hmm sounds tough
09:22:44 <Cale> Stick to pairs, and define a proper datatype when the tuples get any larger than that, usually.
09:22:56 <monochrom> http://stackoverflow.com/questions/2921346/why-on-earth-do-i-convert-a-list-to-a-tuple-in-haskell
09:23:12 <qfr> Heh
09:23:14 <quuuux> qfr: Template Haskell is actually quite cuddly
09:23:20 <Cale> Heh, that's actually a valid link!
09:23:23 <qfr> Yeah in this case a list sounds better actually
09:23:26 <Fred1812> quicksilver: Want to earn some rep? ;-) http://stackoverflow.com/questions/4607011/can-i-compute-the-cube-list-in-a-neat-way
09:23:48 <qfr> It'll take me ages to learn the right Haskell function for the right job
09:24:12 <qfr> I was already losing my mind over the problem Fred1812 posted lol
09:24:12 <Fred1812> qfr: well, you can always use hoogle to search for it, given the type signature
09:24:15 <qfr> I suck at recursion
09:24:19 <Cale> qfr: Focus on learning the list library in the early stages, and then how the Monad library relates to lists.
09:24:29 <Cale> Try not to write anything recursively
09:24:50 <Cale> (Of course, there will be cases where you're backed into a corner and need to use explicit recursion)
09:25:21 <Fred1812> Cale: "Backed into a corner"? So can I use recursion to defend myself against armed robbery? ;-)
09:25:27 <Cale> Using higher order functions is what you should be trying to do though :)
09:26:09 <Cale> Yeah, using recursion is like hitting the problem with a blunt instrument.
09:26:10 * djahandarie uses zygohistoprepromorphisms to defend himself against armed robbery. Pointy.
09:26:12 <j-invariant> how do you make haskell types HELP you instead of work against
09:26:38 <djahandarie> j-invariant, context. Help you do what?
09:26:45 <yrlnry> > :t (\a -> ([1, 1, -1] !! (a mod 3)))
09:26:46 <lambdabot>   <no location info>: parse error on input `:'
09:26:55 <yrlnry> :t (\a -> ([1, 1, -1] !! (a mod 3)))
09:26:56 <lambdabot> forall t a t1. (Num t, Integral a, Num t1) => ((a -> a -> a) -> t1 -> Int) -> t
09:27:07 <Cale> j-invariant: They reduce your options to the ones which make sense. They eliminate wide classes of runtime bugs which tend to be extremely confusing to try to debug. They provide a basis for polymorphism of a sort which dynamic typing can't get you.
09:27:10 <yrlnry> I don't understand that at all.  What did I get wrong?
09:27:29 <yrlnry> I thought it would look something like Num t, Integral a => a -> t
09:27:31 <Cale> yrlnry: a `mod` 3
09:27:34 <Cale> or  mod a 3
09:27:35 <yrlnry> Oh, duh.  Thanks!
09:28:13 <Cale> j-invariant: I can expand on any of those :)
09:29:30 <Cale> Types are like the nubs on lego bricks which simultaneously provide structural integrity while strongly suggesting a decent way to fit things together.
09:30:31 <Cale> Often when I'm faced with a new library, the first thing I'll do is just look at the types of things. Often from the function names and types alone, it becomes obvious how to use the library.
09:30:41 <Cale> (Without reading any other documentation!)
09:31:02 <aristid> Cale: which is pretty important given that most haskell libraries have no documentation
09:31:08 <Cale> aristid: ;)
09:31:16 <Cale> And this is part of the reason why.
09:31:20 <Cale> (I think)
09:31:55 <quicksilver> j-invariant: bribery. threats. if absolutely necessary, hard work.
09:32:08 <j-invariant> haha
09:33:28 <Cale> Let's look at the polymorphism aspect of how we can get types to help us. We have typeclass polymorphism which lets us write functions which are polymorphic in their result type.
09:33:54 <Cale> You'll see this in Num in the form of fromInteger :: (Num a) => Integer -> a
09:34:07 <Cale> and in Monad in the form of  return :: (Monad m) => a -> m a
09:34:36 <Cale> It can be used to do insane perlish things if you abuse it, but it's pretty nice to have that sort of freedom.
09:35:45 <Cale> (This is part of the reason why almost every attempt to bring the monad abstraction to work in a dynamically typed language is either outright wrong, or really awkward to use.)
09:37:19 <qfr> Do you think that strictly typed languages are inherently superior to dynamically typed languages for larger projects because they discover more problems at compile time?
09:37:44 <qfr> wtf
09:37:51 <qfr> I meant statically* obviously
09:37:53 <qfr> Not strict typing
09:37:57 <Cale> yeah
09:38:55 <qfr> Statically typed languages generally suffer from a greater typing overhead though, no?
09:38:55 <Cale> At least, starting from a position of statically typing everything and introducing runtime variations on data incrementally is almost certainly the right way to go. It's *so* hard to bolt a type system onto a language which wasn't designed for it.
09:39:01 <Cale> Hm?
09:39:11 <Cale> You mean keyboard typing?
09:39:11 <c_wraith> Having done really large ruby on rails projects, I'm convinced that dynamic typing is purely bad past a certain project size.
09:39:22 <qfr> Cale yes, programmer typing effort
09:39:33 <qfr> c_wraith yeah I have had the same problem with Ruby
09:39:41 <qfr> I have written some larger networked services in Ruby
09:39:41 <Obvious> qfr, type inference lowers that quite a bit
09:39:42 <Cale> Most of the popular statically typed languages are just bad examples of statically typed languages.
09:39:49 <qfr> Obvious yeah I was about to mention that
09:40:32 <Cale> You basically have to look at functional programming languages if you want a good example of a statically typed language. I'm not 100% certain why that is, but it's probably mostly cultural.
09:40:55 <qfr> c_wraith: Frequently I would have really stupid mistakes like misspelled method names and such which I wouldn't discover until it was way too late, the code became really fragile in the end and writing unit tests became increasingly more time consuming
09:41:04 <qfr> I was very unhappy about that
09:41:20 <Cale> In Java and C++, the overhead of writing type signatures is just terrible.
09:41:23 <qfr> It works well now but it took a lot of patching
09:41:45 <Cale> Especially since in a lot of cases they can be inferred and the compiler is still going to force you to key them in anyway.
09:42:06 <qfr> What are the biggest statically typed functional languages?
09:42:13 <qfr> I only know like uh F# and Haskell
09:42:21 <qfr> F# isn't even on langpop.com, I have no idea how big it is
09:42:25 <Cale> there's also the whole ML family of languages
09:42:33 <qfr> Clean?
09:42:36 <Cale> O'Caml and SML in particular
09:42:39 <Cale> yes, and Clean
09:48:52 <Cale> I suppose a big part of the reason why static typing doesn't work out so great in OO languages in particular is that subtyping and type inference don't mix very nicely.
09:49:24 <c_wraith> Hasn't it been proven that inference is undecidable in the presence of subtyping?
09:49:30 <Cale> Also, that in an imperative setting, the type doesn't tell you as much about what something is. If you're allowed arbitrary effects anywhere, then the types aren't as important as they could be.
09:49:31 <roconnor> > (\x -> (,,) <$> x <*> x <*> x ) [1,2]
09:49:32 <lambdabot>   [(1,1,1),(1,1,2),(1,2,1),(1,2,2),(2,1,1),(2,1,2),(2,2,1),(2,2,2)]
09:49:44 <Cale> c_wraith: Yeah, but it's also undecidable in the presence of typeclasses.
09:50:02 <Cale> So it's more a matter of to what degree can we infer the types in an average program
09:50:02 <Philippa> I didn't think that's the case in a parametrically-monomorphic language?
09:50:05 <Philippa> it's just not so useful then
09:50:16 <Philippa> (I want my free generalisation, dammit!)
09:50:48 <qfr> Cale I see a major problem with type inference and Java and C# and such
09:50:50 <roconnor> @type \f x -> f <$> x <*> x
09:50:51 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> a -> b) -> f a -> f b
09:50:55 <qfr> How would you provide auto completion without it?"
09:51:07 <Cale> qfr: hm?
09:51:26 <qfr> When arguments are untyped, it's problematic, you would have to compile the entire program all the time to determine stuff like that, no?
09:51:44 <Cale> Oh, well, you have to determine the types of things, sure.
09:51:47 <qfr> Yeah
09:52:08 <c_wraith> There's probably a lot you can do with online compilation in an IDE...  much like many IDEs already do
09:52:38 <Cale> You can do fun things like trying to parse as much of the file as you can and typecheck what you find.
09:53:15 <Cale> and of course, for things in other modules, you're mostly fine
09:53:40 <Cale> Somehow we get by entirely without autocompletion in Haskell though.
09:54:07 <c_wraith> Some people would complain that they don't :)
09:54:57 <Cale> I think in part the usefulness of autocompletion is where you have a culture of names which are really cumbersome to type, and inexpressivity of code (so you have to type a lot more code to get the same thing to happen)
09:55:34 <zygohistomorphic> #haskell irc now 10x easier to use!
09:55:35 <Cale> If you spend about 90% of your time thinking about your program and 10% typing it into the computer, then optimising that 10% seems less important.
09:55:37 <monochrom> "meaningful" identifiers are cumbersome to type
09:55:50 <zygohistomorphic> Just zy-tab for all your zygohistomorphic needs!
09:55:56 <roconnor> kate gives me autocompletion
09:56:15 <c_wraith> yeah.  It's also true that many editors give non-type-directed autocompletion
09:56:17 <roconnor> it's doesn't know anything about types, but it does know what words are.
09:56:23 <c_wraith> Which works pretty well, many times
09:56:42 <Cale> We can afford to waste lots of time on indenting things just the right number of spaces, and lining them up all pretty since we don't have to type so much code :)
09:56:58 * roconnor wishes his editor would indent nicely for him
09:57:04 <augur> copumpkin: tho if you can PROVE that (p -> p) -> p, it would probably be interesting
09:57:27 <zygohistomorphic> Damn, just realized zygoloid is totally in the way of zy-tab... foiled.
09:57:27 <Cale> But yes, it would be nice to have editor support for this, it's just not as crucial as it would be if our language weren't as expressive.
09:58:05 <pumpkin> augur: I'd have to confiscate your axioms' axiom certificates in that case
09:58:06 <Cale> augur: in which system? :)
09:58:42 <roconnor> Prelude Integration> showCReal 1 (diag (integral01 (\x -> x^2)))
09:58:43 <roconnor> Loading package infinite-search-0.12 ... linking ... done.
09:58:44 <roconnor> "0.3"
09:58:46 <roconnor> (4.34 secs, 1492076972 bytes)
09:58:52 <roconnor> Prelude Integration> showCReal 1 (diag (integral01 (\x -> (1*x)^2)))
09:58:54 <roconnor> "0.3"
09:58:55 <roconnor> (594.98 secs, 106664891216 bytes)
09:58:57 <roconnor> Prelude Integration> 
09:58:58 <roconnor> damn you multiplication by 1!!
09:59:05 <roconnor> making my code 100 times slower
09:59:16 <djahandarie> lol...
09:59:41 <monochrom> you could invent a djahandarism
09:59:56 <Cale> roconnor: ahaha
10:00:41 * hackagebot TrieMap 0.6.0 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-0.6.0 (LouisWasserman)
10:00:46 <monochrom> I suppose CReal (1 *) is not entirely trivial
10:01:19 <Cale> I wonder what exactly is necessary to make CReal practical performance-wise.
10:01:29 <roconnor> Cale: hardware support
10:01:55 <Cale> I don't think it's just hardware support...
10:01:56 <augur> pumpkin: ;)
10:02:33 <roconnor> Cale: for one problem in probablity theroy I was trying to solve I used Rational instead of Double, and it took 3 minutes to run instead of 0.3 seconds.  But I didn't mind waiting.
10:02:34 <Cale> There are some aspects of what it's doing where things just seem asymptotically far away from expected performance.
10:02:43 <edwardk> roconnor: i'll make you a deal. =)
10:02:56 <roconnor> edwardk: does it involve the Store name?
10:03:02 <edwardk> roconnor: yes =)
10:03:07 <roconnor> edwardk: I'll do it!
10:03:36 * roconnor was working on a long email to edwardk to sell him on the Store name.
10:03:50 <edwardk> what i need is a proof that newtype StoreT s w a = StoreT (w (s -> a)) s forms a comonad
10:03:55 <edwardk> we data StoreT
10:03:58 <edwardk> er data StoreT
10:04:07 <edwardk> prove that, and the name is yours ;)
10:04:26 * roconnor loads up coq.
10:04:27 <monochrom> I already have names
10:04:29 <edwardk> (or alternately provide me with a different definition that satisfies the 3 store laws and is a transformer)
10:05:18 <edwardk> i could also use a better name than cowriter, but i'm less attached there ;)
10:05:30 <edwardk> especially since i have a tell, etc.
10:06:32 <monochrom> coauthor :)
10:06:45 <pumpkin> roconnor: or disprove it if not
10:06:54 <djahandarie> conspirer
10:07:32 <Philippa> edwardk: I just had an eeeevil thought
10:07:46 <Philippa> one which's no doubt occurred to you in related form already, but nevertheless
10:07:53 <edwardk> Philippa: ?
10:08:21 <Philippa> whether it's possible to form the class of 'visibly pushdown monadic languages'
10:08:34 <edwardk> in what sense?
10:08:40 <Philippa> (particularly interesting when you constraint the host category so you're not talking visibly pushdown turing machine)
10:08:58 <Philippa> retain the kind of context sensitivity that a monad has, but also the visibly pushdown property
10:09:05 <Cale> hehe, I have a comment with not a single alphabetic character in it on reddit, and it has 77 points
10:09:10 <edwardk> my current combinators for dealing with pushdown in pegs are something along those lines, but i don't have a nice formal derivation
10:09:14 <Cale> http://www.reddit.com/r/math/comments/evfrl/interesting_fact_2011_is_also_the_sum_of_11/c1barpm
10:09:16 <edwardk> hahaha
10:10:19 <augur> Cale: oh?
10:10:30 <augur> holy moley, cale
10:11:49 * hackagebot TrieMap 0.6.1 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-0.6.1 (LouisWasserman)
10:14:42 <augur> cale, your little function for the scanl part is almost exactly the function i had for my factors tree :o
10:15:28 <pumpkin> roconnor: are you done yet! We don't have all daY!
10:15:31 <merijn> Is there an easy way to update all out of date libraries? Just did a fresh install of Haskell Platform and cabal complains a lot of stuff is missing
10:15:45 <pumpkin> :P
10:17:17 <Cale> augur: :)
10:17:27 <augur> only mine had the arguments the other way
10:17:39 <augur> \m (n,xs) -> (m*n, m:xs)
10:17:49 <dcoutts> merijn: presumably you replaced your ghc, so existing packages are broken. you can just cabal install them again
10:18:01 <dcoutts> merijn: ghc-pkg check will list broken packages
10:18:13 <Philippa> edwardk: sorry 'bout distraction on my part, and cool. I'm still trying to decide if I want to see your work in detail or work separately :-)
10:18:32 <merijn> dcoutts: I nuked everything that was installed (in fact I nuked entire .cabal)
10:18:35 <edwardk> very little of my code is vpl specific
10:18:41 <edwardk> i just rely on it for the asymptotic guarantee
10:18:45 <pumpkin> koninkje_away: are you on twitter?
10:18:46 <roconnor> edwardk: duplicate (StoreT f s) = StoreT (extend StoreT f) s is what you had in mind?
10:18:54 <dcoutts> merijn: did you nuke ~/.ghc ?
10:19:18 <edwardk> i don't have a good answer fr what duplicate or extend are yet =)
10:19:37 <roconnor> ok
10:19:40 * roconnor continues to work
10:19:41 <sw_lasse> Hi, I am trying to solve a school exercise regarding an inference system - we just got a introduction to functional programming and Haskell, so I thought this would be a good place to ask. In the exercise, the following inference system is given: http://pastebin.com/zsiUpixL  and the exercise asks which mathematical relation "|-" describe. I'm not quite sure - but to me it look like some sort of division - anyone who could give me a hint? :)
10:19:43 <merijn> dcoutts: And the problems magically went away :>
10:19:46 <edwardk> i was just coding it up
10:20:34 <dcoutts> merijn: if you nuke ~/.ghc it deletes all package registrations, if you nuke ~/.cabal it deletes all package files. Deleting package files but leaving them registered will lead to all sorts of badness.
10:20:39 <merijn> sw_lasse: In general "x |- y" usually means "y is derivable from x"
10:20:51 <edwardk> looks clean
10:21:42 <c_wraith> sw_lasse, for additional information |- generally is pronounced "entails"
10:21:51 <Cale> sw_lasse: Okay, so 0 is a theorem, and whenever n is a theorem and n' = n+3, then n' is a theorem as well
10:22:02 <Cale> So which numbers are theorems of this system?
10:22:10 <Cale> Well, multiples of three :)
10:22:39 <merijn> sw_lasse: My usual trick for deciphering math symbols is: 1) drawing math symbols in detexify.kirelabs.org/classify.html 2) entering latex code in wolframalpha 3) hope I find an explanation or a name to look up at wikipedia :p
10:23:11 <Cale> So the (apparently unary) relation |- is the relation "is a multiple of three"
10:23:46 <sw_lasse> merijn, thanks for the tip! :D
10:23:54 <sw_lasse> Cale, great, thank you very much :)
10:24:12 <sw_lasse> c_wraith, nice, thanks :)
10:25:01 <roconnor> edwardk: well it typechecks
10:25:03 <roconnor> now for the laws
10:25:04 <edwardk> yeah
10:25:13 <edwardk> it typechecks even if you do it wrong though ;)
10:25:17 <edwardk> the laws are the hard part
10:33:09 <Mason156> Hello can anyone explain what a monad is in functional programming. Im struggaling to understand it 
10:33:30 <roconnor> edwardk: for comonads, fmap f (extend g x) = extend (f . g) x, right?
10:33:37 <edwardk> Mason156: its a burrito in a spacesuit. â€” it is very hard to reason about them by analogy ;)
10:33:41 <c_wraith> Mason156, first I have to ask, Why do you want to understand it?  If you think you have to, you're wrong. :)
10:34:09 <edwardk> roconnor: that should be provable. decompose fmap into extend and extract, then associate
10:34:10 <merijn> I agree with c_wraith
10:34:19 <jmcarthur> i'm glad to see that monads are being downplayed nowadays
10:34:22 <merijn> If you think you need to understand monads for IO, people are lying to you
10:34:33 <roconnor> edwardk: assuming that conjecture holds, law 1 holds for StoreT
10:34:41 <roconnor> now doing law 2
10:34:56 <edwardk> yeah, dan made it through the first 2, but we had a less elegant duplicate/extend
10:34:58 <aristid> iteratees are the new monads :P
10:35:09 * hackagebot symbol 0.1.1 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.1.1 (GeoffreyMainland)
10:35:17 <edwardk> aristid: heh
10:35:38 <Philippa> jmcarthur: I think we're losing something, but I'd have to do a lot of careful writing to articulate what. There's definitely a valid engineering style that makes heavy use of structures like monads and applicatives
10:35:52 <edwardk> for what its worth, your duplicate looks right to me
10:35:56 <Mason156> I want to learn about functional languages and in my research monads are described as a key feature and im struggaling to understand them
10:36:09 <mightybyte> Mason156: Check out Brent Yorgey's Typeclassopedia.  http://www.haskell.org/haskellwiki/Typeclassopedia
10:36:23 <roconnor> edwardk: oh I'm doing it on paper right now.  Will you require a formal proof.  I can write one later, but I prefer to start with paper.
10:36:35 <merijn> Mason156: The best way to learn is to check out how Haskell works (Learn You a Haskell for example) and examine the Maybe and List monads
10:36:39 <Philippa> Mason156: they're not really a key feature of functional languages at all - in fact, so much so that they're only library-level constructs
10:36:58 <merijn> Mason156: If you grok haskell and Maybe a bit then the monad paper by Wadler is good
10:37:09 <edwardk> formal is better, he ran into a wall doing it in agda, but i think it was because of us using the wrong duplicate
10:37:28 <merijn> It's called Monads for Functional Programming
10:38:04 <roconnor> edwardk: ya, it took me a couple wrong looking definitions of duplicate before I settled on this one.
10:38:06 <merijn> jmcarthur: Well, they used to be a bit to overstated :p
10:38:07 <Mason156> thanks i have downloaded the pdf 
10:38:18 <merijn> @quote gehiemdienst monad
10:38:18 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
10:38:25 <merijn> @quote geheimdienst monad
10:38:25 <lambdabot> geheimdienst says: #haskell has the type a -> m b. you feed in some problem, and out comes a solution invariably involving monads
10:38:26 <Mason156> all the explinations on the internet seem to be different
10:38:34 <merijn> Mason156: They're all bad
10:38:42 <Mason156> ye
10:38:43 <merijn> Except maybe the LYAH chapter
10:38:52 <merijn> @where lyah
10:38:52 <lambdabot> http://www.learnyouahaskell.com/
10:39:05 <Philippa> merijn: I think the problem wasn't so much the 'core' culture as the layer of relative newbies at any given time
10:39:12 * hackagebot srcloc 0.1.1 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.1.1 (GeoffreyMainland)
10:39:22 <pumpkin> Foldable should have a null :: f a -> Bool
10:39:43 <Cale> Hey, I don't think my explanations are all that bad :)
10:40:03 <Cale> http://haskell.org/haskellwiki/Monads_as_Computation
10:40:19 <Cale> ^^ that gives the general philosophy that most people take
10:40:20 <merijn> I also like the one called "Monads are trees with grafting"
10:40:29 <pumpkin> burritos ftw
10:41:13 <djahandarie> @quote internet.rule
10:41:13 <lambdabot> djahandarie says: I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
10:41:14 <Mason156> thanks ill read the resources you have provided
10:41:14 * hackagebot mainland-pretty 0.1.0.2 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1.0.2 (GeoffreyMainland)
10:41:22 <Cale> Though it would be better stated as "trees with grafting are monads"
10:42:00 <roconnor> edwardk: assuming my fmap-extract conjecture, law 2 holds
10:42:04 <roconnor> on paper
10:42:42 <roconnor> associativity is going to be more confusing
10:43:02 <Saizan> Cale: it kind of works both ways, if you allow for an eval
10:44:13 <edwardk> roconnor: proved your conjecture
10:44:26 <roconnor> good
10:44:27 <edwardk> fmap f . extend g = fmap f . fmap g . duplicate = fmap (f . g) . duplicate = extend (f . g)
10:44:51 <roconnor> edwardk: um, do you know what the associatively law for comonads is?
10:45:09 <pumpkin> duplicate . duplicate == map duplicate . duplicate ?
10:45:19 <roconnor> pumpkin: use extend plz
10:45:26 <pumpkin> ick
10:45:30 <edwardk> extend f . extend g = extend (f . extend g)
10:45:39 <roconnor> pumpkin: well there are only 3 laws this way
10:45:45 <pumpkin> roconnor: hrrmpf
10:45:46 <roconnor> instead of 7
10:45:50 <merijn> Cale: Still makes it a better explanation then monads are like a burrito :p
10:45:56 <pumpkin> hrrmpf I say
10:45:59 <Cale> absolutely
10:46:05 <edwardk> https://github.com/ekmett/comonad/blob/master/Control/Comonad.hs has the laws
10:46:11 <Cale> Though I never thought the "monads are a burrito" thing was serious.
10:47:09 <byorgey> Completely. Serious.
10:47:45 <byorgey> ;)
10:47:46 <Cale> Burritos are serious business. Just ask Taco Bell.
10:47:49 <alvivi> Question: I know arrows, but I have no idea about Category Theory. Can someone explain, or give me a hint about this comment: we can relatively easily express Arrows in terms of Category + Applicative?
10:48:09 <Cale> alvivi: I find that statement questionable.
10:48:59 <pumpkin> I vaguely remember it being almost true
10:48:59 <Cale> (Watch, it'll turn out to be something I said :)
10:49:14 <byorgey> no, there's something to it.  If c is a Category and (c a) is Applicative for all a, then c is an Arrow
10:49:21 <byorgey> see http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
10:49:48 <roconnor> edwardk: I assume you know that fmap f (StoreT v b) = StoreT (fmap (f .) v) b  and   extract (StoreT v b) = extract v b 
10:50:03 <edwardk> yeah got those
10:50:18 <edwardk> its looking pretty solid. i'll post up as soon as the rest of the package compiles
10:50:18 <Philippa> hmm, the graph sorta elides the 'inversion' between the ArrowChoice formulation and the Monad one
10:51:00 <byorgey> Philippa: can you elaborate?
10:52:22 * hackagebot Sysmon 0.1 - Sybase 15 sysmon reports processor  http://hackage.haskell.org/package/Sysmon-0.1 (VitaliyRukavishnikov)
10:54:19 <Philippa> byorgey: Arrows describe functions, Applicatives and Monads describe what Pascal'd call a procedure - no parameters, just a value-building-thing
10:55:02 <byorgey> sure
10:55:30 <byorgey> but what's the 'inversion' you mentioned?
10:56:27 <byorgey> oops, back in a bit
10:56:38 <Philippa> once you have enough power, those two things are dual
10:56:39 <edwardk> roconnor: quick quiz: i need a duplicate for newtype CowriterT m w a = CowriterT { runCowriterT :: w (m -> a) } ;)
10:57:02 <Philippa> () -> Result <=> Result
10:57:10 <Philippa> (modulo _|_)
10:57:29 <byorgey> Philippa: oh, indeed.  Did you mean ArrowApply / Monad  instead of ArrowChoice / Monad?
10:57:34 <byorgey> ArrowApply isn't on that graph
10:57:43 <Philippa> oops, yeah
10:57:48 <roconnor> edwardk: duplicate (CowriterT v) = CowriterT (extend CowriterT v)  I presume.
10:58:01 <Philippa> obv. ArrowChoice is also useful and interesting
10:58:06 <roconnor> edwardk: by analogy with StoreT
10:58:09 <byorgey> Philippa: but I agree ArrowApply ought to go on that graph too
10:58:25 <Philippa> though I tend to stick with the applicative/monad view unless I've got a good reason not to
10:58:37 <Philippa> yeah. Only then you have to figure out how to visualise the relationship I'm talking about across the classes
10:58:53 <edwardk> not quite so easy, you need to use the mappend, and there isn't the final s  argument to make that as nice =)
10:59:43 <roconnor> edwardk: oh right
10:59:49 <roconnor> heh
11:02:13 <roconnor> edwardk: duplicate (CowriterT v) = CowriterT (extend (\v0 m0 -> CowriterT (fmap (\f m1 -> f (m0 <> m1)) v)))
11:02:17 <roconnor> something like that
11:02:27 <edwardk> yeah that looks pretty close to what i converged to
11:02:28 <roconnor> ... I bet that isn't the ideal expression for it
11:02:42 <roconnor> and I'm not sure the best order to the mappend
11:02:43 <edwardk> i avoided an fmap or two but i went for extend
11:03:19 <roconnor> gee, duplicate for StoreT looks so beautiful in comparision
11:03:27 <edwardk> hah
11:03:37 <edwardk> yeah your duplicate for store was much prettier than mine
11:08:35 * hackagebot TrieMap 0.6.2 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-0.6.2 (LouisWasserman)
11:09:26 <roconnor> edwardk: okay I think I have law3 done on paper.
11:09:36 <pumpkin> nice!
11:09:36 <roconnor> I guess I should do it in Coq.
11:09:48 <edwardk> you can one-up pumpkin that way ;)
11:10:18 <pumpkin> hey, I had the duplicate laws, and for a different comonad :P
11:10:22 <pumpkin> :(
11:11:28 <edwardk> it all helps =)
11:11:41 * pumpkin goes and sulks in the corner
11:17:21 <edwardk> extend f (CowriterT wf) = CowriterT (extend f' wf) where f' wf' m = f (CowriterT (fmap (. mappend m) wf')) â€” is the best i can do so far
11:18:40 <poucet_> Is there a way to have multiple build targets in a single cabal file?
11:18:56 <edwardk> platforms or artifacts?
11:19:09 <edwardk> e.g. a library and executable or multiple OSs?
11:19:14 <poucet> edwardk: multiple executables
11:19:23 <dcoutts> poucet: yes, multiple exes is fine
11:19:34 <poucet> Aa, 'Executable foo'
11:19:39 <poucet> how do you specify which one you are building?
11:19:55 <edwardk> library foo; executable bar; , etc. each one opens a layout section
11:20:02 <edwardk> one sec lemme get you an example
11:20:26 <poucet> edwardk: ah makes sense :)
11:20:32 <edwardk> https://github.com/ekmett/speculation/blob/master/speculation.cabal
11:20:44 <edwardk> look down towards the bottom, the library and executable sections
11:21:12 <dcoutts> poucet: currently there's no way to specify. They all get (re)built.
11:21:18 * poucet nods
11:21:22 <poucet> Ok thanks for the help :)
11:21:32 <edwardk> you can make flags to target them if you want
11:22:40 <poucet> I might put my code up later tonight since for some reason it is REALLY slow 
11:22:56 <poucet> (simplex perlin noise generator)
11:23:52 <dcoutts> edwardk: that's not the intended use of flags of course (and makes them somewhat less useful for their intended purpose if they do get used like that)
11:24:11 <edwardk> dcoutts: fair nuff
11:24:25 <dcoutts> as lots of packages will end up with "junk" flags with no real end-user meaning
11:24:28 <edwardk> i mostly abuse them that way to get benchmarks, etc. =/
11:24:39 <dcoutts> though we already have that problem with e.g. if base4 stuff
11:24:50 <dcoutts> that also needs a different solution
11:25:03 <poucet> dcoutts: What is 'CAF" again?
11:25:15 <dcoutts> constant applicative form
11:25:26 <edwardk> straw poll: better name for cowriter?
11:25:32 <poucet> So I could get rid of those by making my code stricter
11:25:33 <dcoutts> poucet: a top level value, rather than top level function
11:25:35 <poucet> edwardk: reader :)
11:25:40 <dcoutts> poucet: no
11:25:42 <edwardk> poucet: =P
11:25:48 <edwardk> it still has tell, etc. its just a comonad
11:25:48 <pumpkin> retirw
11:26:12 <pumpkin> RetirW
11:26:19 <dcoutts> poucet: a CAF is a syntactic thing, like x = 3, not an issue of strictness
11:26:19 <pumpkin> see, the W suffix is like the M suffix
11:26:21 <edwardk> newtype CowriterT m w a = CowriterT { runCowriterT :: w (m -> a) } is a comonad if w is a comonad and m is a monoid
11:26:23 <pumpkin> suggesting it's comonadic ;)
11:26:29 <edwardk> hahaha
11:26:39 <jmcarthur> i like "cowriter" personally
11:26:43 <poucet> dcoutts: aha, the reason I ask is because half my memory allocations are from GHC.Float.CAF
11:27:04 <edwardk> jmcarthur: i'm growing on the 'co' prefixes as i work, because i've ben able to provide direct analogues to the monadic actions for each one
11:27:20 <jmcarthur> edwardk: doesn't category-extras already have cowriter?
11:27:23 <edwardk> e.g. costate has 'get' 'modify', etc.
11:27:49 <jmcarthur> edwardk: well it makes a ton of sense when you think of it as a kleisli arrow, too
11:28:03 <edwardk> jmcarthur: i'm building standalone Haskell 98 packages for 'comonad', 'comonad-transformers'  and fundep/typefamily based comonads-fd and comonads-tf
11:28:08 <jmcarthur> ah cool
11:28:37 <joe6> can I have a type synonym for more than one type such as: type Description = Lineno Line deriving Show
11:28:53 <edwardk> the comonad package is simple enough it could go in base (if Data.Functor.Identity moved into base), and the comonad-transformers package is directly analogous to transformers.
11:28:53 <joe6> where type Lineno = Int
11:28:54 <joe6> type Line = String
11:29:02 <monochrom> no, you can't
11:29:06 <joe6> ok, thanks.
11:29:08 <xplat> >fix $ (\x -> "yo dawg, i heard you like " ++ x ++ " so we put a " ++ x ++ " in your " ++ x ++ " so you can meme while you meme") . show
11:29:46 <xplat> > fix $ (\x -> "yo dawg, i heard you like " ++ x ++ " so we put a " ++ x ++ " in your " ++ x ++ " so you can meme while you meme") . show
11:29:48 <lambdabot>   "yo dawg, i heard you like \"yo dawg, i heard you like \\\"yo dawg, i heard...
11:30:05 <mauke> > fix show
11:30:07 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:30:13 <poucet> ghttp://hpaste.org/42766/simplex_perlin_noise
11:30:14 <sproingie> > fix error
11:30:15 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:30:26 <mauke> > map length . group $ fix show
11:30:33 <lambdabot>   [1
11:31:00 <dcoutts> poucet: interesting, I wonder what they are
11:31:59 <poucet> I am not sure how to further investigate performance costs
11:32:03 <poucet> :|
11:32:41 <poucet> Unfortunately to generate a 512x512 grid of (3d, where z=0) perlin noise takes like 6 seconds, including output, which seems excessive
11:32:57 <pumpkin> wow
11:33:15 <jmcarthur> of course now i would have trouble coming up with a way to show how writer and cowriter are dual
11:33:29 <jmcarthur> i had done this exercise before i'm sure
11:34:35 <poucet> dcoutts: I take it that the easiest way to track down cost is to generate core?
11:34:36 <pastorn> damn, i can't get the first facebook puzzle accepted :(
11:34:37 <jmcarthur> i think that monoid constraint is what's throwing me
11:34:50 <edwardk> look at the hom-prod adjunction instead
11:36:01 <dcoutts> poucet: I was just looking at ghc --show-iface GHC/Float.hi but it's not terribly enlightening. There are a bunch of generated CAFs of type Int, but it's not clear which ones you'd be retaining, nor how expensive each is
11:36:22 <jmcarthur> ah!
11:36:52 <poucet> I have annotated the paste with the prof output
11:37:27 <poucet> And the summary
11:39:20 <poucet> alright, be back in 20 minutes, walking over to my gf's house.
11:39:29 <poucet> dcoutts: so would the best idea be to annotate my code with SCCs?
11:40:00 <dcoutts> poucet: that will not help in breaking down what is retained by the Float module CAFs
11:40:24 <dcoutts> poucet: you'd need to recompile Float (ie base) with a different prof flag
11:40:26 <poucet> dcoutts: on second inspection, if I look at the .summary and .prof, allocation is not using that much of total time, or am I misreading those?
11:40:27 <dcoutts> I think
11:40:47 <poucet> http://http://hpaste.org/paste/42766/simplex_perlin_noise_annotati#p42768 [information at bottom]
11:40:52 * dcoutts looks
11:42:24 <dcoutts> poucet: so that shows GHC.Float CAF taking 0% of everything
11:42:34 <poucet> dcoutts: right
11:42:41 <poucet> dcoutts: the number I got was from the ps graph from the .hp
11:43:37 <dcoutts> poucet: that's odd, perhaps worth asking about the apparent discrepancy on the ghc users list
11:43:58 <burp> f :: String -> IO (Maybe String); g :: String -> IO (Maybe [String]), how do I chain them within IO, within Maybe monad?
11:44:16 <burp> without IO it would simply be f "123" >>= g
11:44:18 <poucet> My guess is that my code doesn't use a lot of memory but it cycles through it very fast, so the sampler doesn't really see it
11:45:58 <burp> I don't come to a beautiful solution
11:46:26 <c_wraith> burp: use MaybeT IO ?  That's the cleanest solution I can think of.
11:47:53 <c_wraith> burp:  MaybeT m a = m (Maybe a), but with with a monad instance that does what you'd expect.
11:48:14 <burp> hm yes
11:48:21 <burp> guess I need to use that
11:48:32 <c_wraith> You don't need to.  But it's one way to go about it.
11:49:00 <jatin> hi everybody i am interesting participatng in gsoc through your organization. I have a experience of working in open source. Could anyone please provide with some pointers on how to proceede?
11:49:01 <burp> right now I'm using some if/else Nothing/Just stack, but that's ugly :/
11:49:07 * hackagebot asn1-data 0.4.0 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.4.0 (VincentHanquez)
11:49:17 <medfly`> haskell is a language, jatin
11:50:04 <pumpkin> jatin: for next year?
11:50:17 <pumpkin> or rather
11:50:25 <pumpkin> nevermind :)
11:50:26 <Philippa> pumpkin: codepocalypse!
11:50:33 <jatin> medfly`: i know that
11:51:15 <jatin> pumpkin: i am looking to participate this year only
11:51:31 <Philippa> jatin: do you know it well enough to compete for a place in a group containing postgrad GHC hackers and long-standing community regulars?
11:51:53 <pumpkin> jatin: you'd usually make a proposal of what you'd want to do, and maybe hang around and try to convince people here you know haskell well enough to be worth the effort :)
11:52:11 <Philippa> right. Proposals should be stuff widely useful to the community
11:52:32 <Philippa> carefully targetted GHC improvements are good, work on cabal is really good, sorting out important libraries is good...
11:53:19 <maltem> oy, a Haskell gsoc is *usually* worth the effort
11:53:24 <merijn> Philippa: Pfft, as if being a postgrad makes you a good coder :p
11:53:42 <jatin> i have been working on sugar and ut doesnt contain only post grade hackers but pdh hackers
11:53:44 <merijn> Philippa: Some of the code the postgrads here produce is horrifying :>
11:54:45 <jatin> *phd
11:56:39 <xplat> haskell comonads make me sad because of the terms 'extend' and 'duplicate'
11:57:53 <Philippa> merijn: well no, but the theory behind the horrifying code... :-)
11:57:56 <ClaudiusMaximus> http://hpaste.org/42770/refactor_my_reducer i tried to fix this yesterday but ended up breaking it, any ideas?
11:58:22 <xplat> they should have other names.  i mean, 'extend' kind of makes sense if you think about it a really, really long time, but.
11:58:44 <Philippa> (anyway, the competent haskell hacking postgrad is often borderline scary for entirely different reasons)
11:59:14 <xplat> yeah, crystal meth in your coffee will do that
11:59:41 <Philippa> heh, I'm bad enough on caffeine
12:03:52 <roconnor> edwardk: http://hpaste.org/42771/storet_comonad
12:03:59 <roconnor> (* StoreTComonad
12:04:00 <roconnor>      : forall (s : Type) (w : Type -> Type),
12:04:01 <roconnor>        Comonad w -> Comonad (StoreT s w) *)
12:04:15 * djahandarie doesn't even drink caffeine
12:05:33 <roconnor> edwardk: yay, I win the name!
12:06:32 <djahandarie> Wow I totally do not understand whatever language that is. Coq?
12:06:51 <roconnor> djahandarie: yes it is Coq.
12:09:47 <edwardk> roconnor:  =)
12:10:20 <edwardk> https://github.com/ekmett/comonads-fd/blob/master/Control/Comonad/Store.hs
12:10:22 <edwardk> =)
12:10:40 <roconnor> yay it is called Store!
12:10:53 <roconnor> I hope I don't change my mind again on the name >:)
12:11:02 <edwardk> hah
12:11:11 <roconnor> I don't think I will; I'm very statified with the name.
12:11:30 <edwardk> well, it makes me only a little sad, because i was starting to grow on Coreader Costate and Cowriter once i got them to all have analogous operations
12:11:34 <pumpkin> OconnorT?
12:11:59 <roconnor> edwardk: I think you should give coreader and cowriter different names.
12:12:13 <edwardk> CoreaderT is currently EnvT
12:12:25 <edwardk> CowriterT hasn't yet offered up a nice name
12:12:36 <edwardk> i was tempted to call them Reader, Writer, and State actually ;)
12:12:40 <roconnor> edwardk: are the kleisli arrows for Reader and Coreader ismorphic?
12:12:41 <edwardk> drop all the scary Co's
12:12:56 <edwardk> a -> r -> m  and (a, r) -> m â€” yeah
12:13:08 <roconnor> and same with Writer and Cowriter?
12:13:14 <roconnor> but not State and Store?
12:13:24 <edwardk> writer is a bit trickier to see
12:14:10 <roconnor> (m -> a) -> b  vs a -> (m,b)
12:14:14 <roconnor> doesn't look isomorphic
12:14:24 <roconnor> I would call coreader  Reader
12:14:32 <edwardk> its not a bad call
12:14:40 <roconnor> but I would call cowriter something else (other than writer).
12:15:17 <edwardk> cowriter is more of a consumable monoidal supply, but its different than the supply comonad
12:15:45 <edwardk> tell prefixes the monoidal context
12:15:50 <roconnor> ya, writer would be a terrible name for that.  But reader isn't a bad name for coreader.
12:16:01 <edwardk> i'm being won over by reader
12:16:25 <roconnor> I haven't thought about what I'd call cowriter.
12:16:36 <roconnor> I took me like a month to come up with Store comonad.
12:17:13 <edwardk> well, lessee, a cowriter looks like w (m -> a), time to hit a thesaurus ;)
12:17:25 * roconnor did the same
12:17:40 <edwardk> https://github.com/ekmett/comonad-transformers/tree/master/Control/Comonad/Trans is what i have so far
12:17:46 <edwardk> as the base transformers
12:18:28 <edwardk> as far as i'm concerned it could be LogT or LoggedT
12:19:19 <edwardk> or traced
12:19:38 <edwardk> because you can have a value that you have accumulated a trace on how it was built that you can discard the trace of
12:20:29 <edwardk> which makes it nicer to me than the usual writer because it is disposable ;)
12:23:52 <edwardk> with TracedT â€” i could rename tell to trace and it'd be done
12:24:37 <edwardk> trace :: ComonadTrace m w => m -> w a -> a
12:24:58 <monochrom> TracerT : http://www.youtube.com/watch?v=SXmv8quf_xM (off-topic, pun on TracerT) :)
12:28:19 <roconnor> edwardk: Env is a pretty good name too
12:28:30 <edwardk> yeah but more likely to conflict
12:29:05 <edwardk> well, i guess not more likely than Reader ;)
12:29:17 <edwardk> but since my operation names already conflict i'm kinda stuck anyways
12:29:34 <poucet> edwardk: how do you specify the -main-is flag for ghc in cabal?
12:29:45 <poucet> edwardk: if your main module is not 'module Main where'
12:29:48 <roconnor> edwardk: hah, comonad transformer have lower
12:29:53 <roconnor> kinda obvious
12:30:11 <edwardk> main-is: Test.hs
12:30:20 <edwardk> roconnor: yeah, but note that category-extras had it wrong =)
12:30:28 <edwardk> so the only ones i had there were isomorphic cases
12:30:34 <poucet> edwardk: that doesn't specify -main-is
12:31:02 <gwern> any HTML experts? I recently had a curious issue with pandoc where my xhtml validation broke because I had something like '<!-- foo bar baz see also <http://www.predictionbook.com> quux foobar -->' and Pandoc rewrote the --> into soemthing with an ampersand escape. are HTML comments supposed to break if < or > are used anywhere inside the comment?
12:31:02 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
12:31:06 <edwardk> poucet: well you could ghc-options, perhaps
12:31:07 <gwern> @messages
12:31:07 <lambdabot> gh_ said 6h 19m 55s ago: about http://irclog.perlgeek.de/darcs/2011-01-04#i_3152774 , maybe look at http://wiki.darcs.net/Using/GrowingPristineProblem . also http://wiki.darcs.net/Using/GrowingInvento
12:31:07 <lambdabot> riesProblem is currently unsolved.
12:31:11 <poucet> edwardk: good idea
12:31:12 <poucet> wow...
12:31:31 <poucet> simplex perlin noise in C (driven from haskell): 0.36s, simplex perlin noise in haskell: 6.72s
12:31:39 <roconnor> edwardk: also, you need to invent a friendlier name for comonad :P
12:31:45 <romildo> Is there a class to handle bytestring and string operations? For instance, I want to find the length of a string or a bytestring. Is there an overloaded function for that?
12:31:48 <edwardk> roconnor: warmer fuzzier thing?
12:32:05 <Cale> Cold tasty thing
12:32:08 <edwardk> romildo: not really
12:32:31 <monochrom> icecream is cold tasty thing. eh? comonad is like icecream?
12:32:38 <edwardk> romildo: the problem with such classes is they are rarely the most useful thing, because of the differing asymptotics
12:32:39 <Cale> yeah
12:32:45 <edwardk> so they have limited application
12:32:57 <gwern> romildo: well, length means different things on an infinite linked list and an fixed-length sequence of arrays
12:33:19 <monochrom> "comonad is like icecream, you keep licking until only the cone is left, pun on cone"
12:33:19 <edwardk> e.g. if you know something is slow you may hold onto it, etc. if you go through such a class you get  the worst of all worlds
12:33:29 <edwardk> monochrom: *groan*
12:33:45 <monochrom> "burrito is like cocone"
12:34:02 <roconnor> comonads are like ice cream!
12:34:28 <edwardk> i think comonads are more like burritos. you can get the contents out very easily, but the trick is to keep the tortilla around it.
12:35:00 <edwardk> i think i foresee a talk in my future
12:35:04 <monochrom> this is why mathematician's monad is our comonad
12:35:28 <roconnor> monochrom: eh?
12:35:56 <monochrom> yes I read a math book that defines monad and I had to flip all the arrows to suit what I learned from haskell and wadler etc
12:36:19 <roconnor> I watched the Catsters today and didn't have any trouble following.
12:36:41 <monochrom> well bear in mind that mathematicians are divided on even whether 0 is a natural number or not
12:40:34 * hackagebot TrieMap 0.6.3 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-0.6.3 (LouisWasserman)
12:40:45 <edwardk> roconnor: now, fix up a PointerT =)
12:41:07 <edwardk> data PointerT i w a = PointerT (w (Array i a)) i
12:41:30 <edwardk> i had it until i bolted the w in, but haven't plumbed the w through the duplicate yet
12:41:39 <roconnor> edwardk: you can be serious.  It is exactly the same as StoreT
12:41:40 <edwardk> it can be made into an instance of Store, where the store manipulates the inde
12:42:04 <edwardk> well the duplicate is a little trickier because it has to tabulate
12:42:26 <roconnor> edwardk: take the definition of duplicate for StoreT, eta expand, and then turn the array into a function with (!)
12:42:29 <edwardk> my goal is to have PointerT serve as a nice array-memoized StoreT
12:42:53 <roconnor> oh hmm
12:42:57 <roconnor> I guess it isn't quite that simple
12:43:01 <edwardk> its not quite so simple, you wind up having to build the new array with listarray or some such. like i said, i have the definition for the non-transformer version
12:43:04 <roconnor> you have to turn the function back into an array
12:43:08 <edwardk> yep
12:43:25 <roconnor> well, it shouldn't be too hard to figure out
12:43:32 <roconnor> maybe pumpkin can do it :P
12:43:37 <edwardk> get corresponds to extracting your location, put correponds to changing it, and modify lets you do location relative addressing
12:43:39 <edwardk> hah
12:43:41 <pumpkin> ?
12:43:44 <pumpkin> wat
12:43:57 <aristid> roconnor: no, only copumpkin can.
12:43:59 <edwardk> he's a bit burned out, so i figured i'd turn to the master of the Store comonad to help ;)
12:45:21 <aristid> edwardk: if you make nice comonad packages, be sure to document them better than category-extras :P
12:45:51 <edwardk> aristid: =P working on that
12:47:36 * hackagebot Sysmon 0.1.1 - Sybase 15 sysmon reports processor  http://hackage.haskell.org/package/Sysmon-0.1.1 (VitaliyRukavishnikov)
12:48:17 <roconnor> I guess semigroups are the algebras of the non-empty list monad?
12:48:19 <Saizan>  /win 20
12:48:56 <roconnor> and pointed algebras are the algebras of the (Const ()) monad?
12:49:29 <roconnor> can I form a monad from any algebra?
12:49:41 <roconnor> that seems so unlikely
12:54:28 <roconnor> I'm tempted to make CoCatsters vidoes which are exactly the same as the Catsters videos except with all the arrows reversed.
12:55:17 <osfameron> catsters?
12:55:44 <roconnor> http://www.youtube.com/user/TheCatsters
12:56:13 <roconnor> oh I guess they have lots of videos
12:56:18 <osfameron> kewl
12:56:18 <roconnor> I was just looking at the monad ones.
12:56:18 <monochrom> hehehe
12:56:51 <monochrom> be careful to hold chalk backwards too
12:57:07 <monochrom> also use left hand
12:57:27 <roconnor> nah, I'll just write backwards and then flip the video
12:57:59 <monochrom> finally, if you can manage to face the board while talking to the audience and face the audience while writing on board, that will be complete, but I recognize it is pretty hard
12:59:01 <Botje> mirrors ftw
13:02:06 <espadrine> I am reading "learm haskell for...", and I stumbled across a piece of code that produced an error with me.
13:02:20 <espadrine> The code I wrote is http://hpaste.org/42774/zipwith
13:02:40 <espadrine> I get: *Main> zipWith' (+) [4,3,2,1] [1,2,3,4] *** Exception: redef.hs:(25,0)-(26,19): Non-exhaustive patterns in function zipWith' 
13:02:53 <espadrine> Does anyone know why?
13:03:12 <Botje> your last case has a lower-case w
13:03:20 <Botje> hence haskell thinks it's a different function
13:04:31 <edwardk> roconnor: any further thoughts on a better name for DiscontT?
13:04:51 <roconnor> discount
13:04:53 <roconnor> :P
13:04:55 <edwardk> =
13:04:58 <edwardk> =P
13:05:20 <espadrine> Botje: thanks
13:06:12 <roconnor> I should probably watch these videos
13:13:18 <quuuux> we need a word for the cycle where you're close to finishing your bite-sized feature and committing the code, then discovering a design flaw/horrible bug that you just -can't- leave in, and then before you know it your nice, small feature has touched 30 files and added 500 LOC
13:13:32 <cdsmithus> So did anything come of the 'cabal test' GSoC project?  Is it now easy to add QuickCheck tests to cabal and run them with 'cabal test'?  And if so, where's a good step-by-step on doing it?
13:13:50 <quuuux> it's a bit like yak shaving, but tail-recursive instead of head-recursive
13:13:56 <dcoutts> cdsmithus: yes and no
13:14:10 <dcoutts> cdsmithus: that is, the docs are a bit thin
13:14:24 <cdsmithus> Ah, okay.  Can you suggest somewhere to start reading anyway?
13:15:05 <dcoutts> http://www.galois.com/~dons/talks/hiw-2010/tuegel-cabal-test.pdf
13:15:20 <cdsmithus> Awesome.  Thanks Duncan
13:16:06 <pumpkin> dcoutts: have any more test types made it into the repo than the one that was there initially?
13:16:36 <dcoutts> pumpkin: we've got the exitcode-stdio-1.0 and detailed-0.9 currently in Cabal HEAD
13:16:48 <dcoutts> in Cabal-1.10 it's just exitcode-stdio-1.0
13:16:50 <pumpkin> oh I think it only had exitcode before
13:17:02 <pumpkin> is detailed a library-based one?
13:17:03 <dcoutts> you're using the released version
13:17:06 <dcoutts> pumpkin: yep
13:17:11 <pumpkin> oh, great
13:17:18 <pumpkin> I've been looking forward to that, thanks
13:22:22 <mtnviewmark> quuuux: yak-braiding?
13:22:28 <cdsmithus> Hmm... "Warning: xmlhtml.cabal: Ignoring unknown section type: test-suite"  So what do I need that I don't have?
13:23:07 <dcoutts> cdsmithus: what version of Cabal lib are you using?
13:23:18 <dcoutts> cdsmithus: does everything work apart from that?
13:23:40 * dcoutts is interested in which old versions of Cabal will correctly ignore the new section type
13:23:47 <cdsmithus> cdsmith@godel:~/Desktop/projects/xmlhtml$ cabal --version
13:23:49 <cdsmithus> cabal-install version 0.8.2
13:23:52 <cdsmithus> using version 1.8.0.2 of the Cabal library 
13:24:00 <dcoutts> ok, 1.8
13:24:24 <dcoutts> cdsmithus: does it still build etc?
13:24:44 <joe6> is there a better way of doing this: takeWhile (\x -> (==) '<' (head x)) $ replicate 2 "<<test"
13:24:47 <dcoutts> cdsmithus: you'll need Cabal-1.10 to actually use the new test-suite stuff
13:24:52 <joe6> > takeWhile (\x -> (==) '<' (head x)) $ replicate 2 "<<test"
13:24:53 <lambdabot>   ["<<test","<<test"]
13:25:19 <dcoutts> cdsmithus: but note that only version of cabal command line tool that builds with Cabal-1.10 is the darcs version
13:25:32 * dcoutts will be doing new releases soonish
13:26:25 <roconnor> > takeWhile (\x -> '<' == head x) $ replicate 2 "<<test"
13:26:25 <lambdabot>   ["<<test","<<test"]
13:26:46 * hackagebot language-javascript 0.2.0 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.2.0 (AlanZimmerman)
13:27:50 <roconnor> > let { p ('<':_) = true; p _ = false } in takeWhile p $ replicate 2 "<<test" -- Safer code
13:27:50 <lambdabot>   Not in scope: `true'Not in scope: `false'
13:27:57 <roconnor> > let { p ('<':_) = True; p _ = False } in takeWhile p $ replicate 2 "<<test" -- Safer code
13:27:58 <cdsmithus> dcoutts: Okay, thanks.  So I'll hold off a bit and just build an executable for now.
13:27:58 <lambdabot>   ["<<test","<<test"]
13:28:23 <roconnor> > let { p ('<':_) = True; p _ = False } in takeWhile p $ ["<<test",""] -- Safer code
13:28:23 <lambdabot>   ["<<test"]
13:28:38 <roconnor> >takeWhile (\x -> (==) '<' (head x)) $ ["<<test",""] -- UnSafer code
13:28:40 <roconnor> > takeWhile (\x -> (==) '<' (head x)) $ ["<<test",""] -- UnSafer code
13:28:41 <lambdabot>   ["<<test"*Exception: Prelude.head: empty list
13:31:49 * hackagebot hjsmin 0.0.7 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.7 (AlanZimmerman)
13:34:26 <joe6> > takeWhile (\x -> '<' == head x) $ ["<<test",""]
13:34:28 <lambdabot>   ["<<test"*Exception: Prelude.head: empty list
13:34:42 <joe6> roconnor: is there a way to make it safer?
13:35:32 <Cale> joe6: Maybe use take 1 instead?
13:36:08 <roconnor> > let { p ('<':_) = True; p _ = False } in takeWhile p $ ["<<test",""] -- Safer code
13:36:09 <lambdabot>   ["<<test"]
13:36:24 <roconnor> oh right, take 1 
13:36:32 <Cale> > takeWhile (\x -> "<" == take 1 x) $ ["<<test",""]
13:36:34 <lambdabot>   ["<<test"]
13:36:36 <roconnor> > takeWhile (\x -> ['<'] == (take 1 x)) $ ["<<test",""] -- UnSafer code
13:36:37 <lambdabot>   ["<<test"]
13:36:40 <roconnor> > takeWhile (\x -> ['<'] == (take 1 x)) $ ["<<test",""] -- safer code
13:36:41 <lambdabot>   ["<<test"]
13:36:53 <roconnor> what cale sid
13:36:55 <roconnor> *said
13:39:31 <hvr> ...is there somewhere documentation about what confuses cabal and why dependancy-wise?
13:39:51 <dcoutts> hvr: can you be more specific?
13:40:47 <hvr> dcoutts: for some reason I find it confusing, that cabal sometimes doesn't seem to be able to resolve dependancies on its own
13:41:00 <hvr> and I'd like to better understand, why it can't sometimes on its own
13:41:04 <hvr> +figure it out
13:41:29 <dcoutts> hvr: it takes a fairly simplistic approach, it collects constraints and never back tracks and does not look far ahead
13:41:58 <dcoutts> there is the --constraint= flag you can use to add extra constraint up front that will make it take different decisions
13:42:13 <dcoutts> cabal install --dry-run -v also helps to see what is going on
13:42:39 <beastaugh> on a related subject, I don't suppose you could explain what this cabal-install error message means?
13:42:41 <joe6> roconnor: sorry, I did not realise that your earlier code was directed to me.
13:42:41 <beastaugh> "Package regex-pcre-builtin-0.94.2.1.7.7 is in the pre-existing state but it depends on package regex-base-0.93.2 which is in the configured state"
13:42:47 <joe6> roconnor: thanks for your help.
13:43:09 <monochrom> I just use cabal install --dry-run. If it makes a choice, it makes a choice, I don't want to know why.
13:43:51 <hvr> oh, btw, is there a variant of 'cabal build' which installs the required build-prereqs?
13:43:59 <monochrom> no
13:44:08 <dcoutts> beastaugh: is that an internal error? can you post the full command and error somewhere
13:44:25 <dcoutts> hvr: no, that's what cabal install does, it installs deps and the one in the current dir
13:44:38 <roconnor> joe6: np. Cale's solution was better.
13:44:47 <dcoutts> hvr: we'll likely add a cabal install --dependencies-only
13:45:00 <hvr> dcoutts: thx, that would be highly appreciated :)
13:45:06 <joe6> Cale: Thanks.
13:45:57 <beastaugh> https://gist.github.com/26cbf01e69f95b81feb6
13:46:22 <beastaugh> (yes, it's an internal error)
13:46:29 <hvr> dcoutts: and thx for the --dry-run hint
13:46:51 <poucet> is there a faster function than: fromIntegral . floor
13:47:04 <monochrom> @type floor
13:47:06 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:47:12 <monochrom> yes, floor alone
13:47:20 <poucet> Double is not an integral
13:47:24 <poucet> I want Double -> Double
13:47:44 <monochrom> I see.
13:49:54 <c_wraith> :t fromIntegral . floor
13:49:56 <poucet> \o/ shaved off a second by removing higher order functions like liftA and fmap
13:49:56 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
13:51:23 <aristid> poucet: which GHC version?
13:51:31 <ClaudiusMaximus> poucet: http://www.haskell.org/hoogle/?hoogle=floor%20%2Bcmath
13:51:56 <poucet> The Glorious Glasgow Haskell Compilation System, version 6.12.3
13:52:10 <poucet> ClaudiusMaximus: Thanks!
13:52:44 <ClaudiusMaximus> it may or may not be faster
13:58:05 <poucet> Aha, another 2 seconds by changing which vertices have which types!
13:58:11 <poucet> 6.7s -> 4.14 s
14:00:43 <ClaudiusMaximus> http://hpaste.org/42770/refactor_my_reducer  i tried to rewrite  bar :: T -> Integer -> Maybe T  into   bar' :: T -> Maybe (Integer, T)  to avoid the multiple passes in   foo   but I messed it up.  is this a valid approach for me to retry?
14:03:37 <slack1256> hello haskellers
14:03:48 <slack1256> which gui toolkit do you recommend me to use
14:04:10 <slack1256> gtk haskell doesn't convence me neither Qthaskell (which seems a ugly hack to me)
14:04:22 <aristid> web? :D
14:04:43 <slack1256> *convince pardon my english
14:04:45 <slack1256> web?
14:04:45 <poucet> slack1256: I quite like gtk and for opengl, glut
14:04:58 <byorgey> ClaudiusMaximus: why do you need a maximum bound?
14:05:08 <monochrom> I recommend gtk but you're turned it down.
14:05:15 <monochrom> s/you're/you've/
14:05:27 <monadic_kid> slack1256: which gui api are you familiar with?
14:06:04 <ivanm> slack1256: http://hackage.haskell.org/package/#cat:gui
14:06:28 <aristid> slack1256: web = www.google.de
14:07:29 <ClaudiusMaximus> byorgey: to avoid nontermination when the term is irreducible
14:07:42 <poucet> slack1256: I have used gtk2hs with quite some success, t was very esy with cairo to draw stuff
14:08:22 <xplat> hm, hsc2hs 0.67.2006110722777 fails to build for me on debian ghc 6.12.1
14:08:25 <poucet> Unfortunately I am not at home where all my code resides, otherwise I'd upload some code to give you an idea
14:08:29 <ClaudiusMaximus> byorgey: still working on the refactor, think i might have figured it out now...
14:08:41 <byorgey> ClaudiusMaximus: I don't see how that is possible, since recursive calls to bar are always on subterms
14:08:45 <poucet> dons: are there plans to get gtk2hs in haskell platform?
14:08:46 <xplat> says it can't find module 'System.Process'
14:09:27 <monadic_kid> xplat: how are you building it, cabal install?
14:11:21 <xplat> yeah
14:11:39 <xplat> stupid me, just found i already had it on my system :7
14:12:03 * xplat takes early steps in trying to extend postresql via haskell
14:12:11 <poucet> slack1256: When I did do gui's, I used gtk for the framework, and cairo for the drawing
14:12:25 <poucet> Right now I'm working on a 3d game, so glut and opengl
14:12:47 <xplat> btw is there a good way to use the gtk binding only for cairo and some input-handling stuff?
14:13:39 <xplat> there's something i'm doing later on where i want UI but the whole prebuilt-widgets-and-framework stuff would just get in the way
14:15:20 <poucet> byorgey: hey
14:15:26 <byorgey> hi poucet 
14:15:27 <poucet> byorgey: do you still have our old icfp code lying around somewhere handy?
14:15:39 <byorgey> poucet: I'm not sure, I will check
14:16:44 <byorgey> poucet: yes, I do
14:17:02 <poucet> byorgey: could you upload it anywhere?
14:17:11 <byorgey> poucet: sure
14:17:15 <poucet> Thanks =)
14:17:22 <byorgey> poucet: do you need it right now or is it OK if I do it tomorrow?
14:17:37 <poucet> byorgey: either owrks
14:17:53 <byorgey> ok, if I don't get around to it today I will definitely do it tomorrow
14:17:59 <byorgey> I'll let you know
14:18:43 <ClaudiusMaximus> byorgey: http://hpaste.org/paste/42770/refactor_my_reducer_annotatio#p42775 does this approach look reasonable?  (guess i need a test suite...)
14:18:59 <poucet> byorgey: thank you
14:21:22 <byorgey> ClaudiusMaximus: I still don't see why you need the Integer.
14:22:19 <byorgey> ClaudiusMaximus: the only thing you seem to use it for is to decide which side of an application to reduce first
14:22:40 <byorgey> but why not just always try reducing the left side first?  that's what the previous version did
14:22:46 <byorgey> and I see no danger of nontermination
14:22:53 <pumpkin> ClaudiusMaximus: looks like the Maybe applicative or functor could be very useful here
14:23:22 <byorgey> and if there was danger of nontermination, this new version would certainly fall afoul of it, since <= is not lazy
14:26:42 <revenantphx> Hello~
14:26:49 <revenantphx> So, I've got a quick question.
14:27:01 <revenantphx> I have a list/array/w.e. of cells 
14:27:13 <revenantphx> each one containing some amount of ants and pheromone (ignore the pheromone for now)
14:27:27 <revenantphx> so I was thinking about how to update all of the ant positions, if their movement is random...
14:27:36 <revenantphx> While iterating by cell
14:27:47 <monochrom> oh hey revenantphx long time no see
14:27:50 <revenantphx> hey
14:27:54 <revenantphx> I've been a bit busy >_>
14:27:58 <ivanm> revenantphx: I did something like that using STM
14:27:59 <ClaudiusMaximus> byorgey: the integer counts how many lambdas i'm inside when i reduce, want to reduce the outermost one while still reducing inside lambdas if nothing else is possible
14:28:04 <revenantphx> ivanm: trying to do this purely
14:28:06 <revenantphx> And the only conclusion I came too, is to scan through the whole thing first, generating a list of "deltas"
14:28:11 <revenantphx> and then go through applying the deltas.
14:28:15 <revenantphx> changes, w/e
14:28:21 <ivanm> revenantphx: OK: get all the ants, shuffle them, then fold over the shuffled list
14:28:23 <revenantphx> I stole the terminology from VCS
14:28:28 <Botje> revenantphx: make a new array that has the modified positions
14:28:45 <revenantphx> Botje: thats the other thing I was thinking of, however that won't wor kI dont think
14:28:51 <revenantphx> Say I have an ant in cell 'n'.
14:28:54 <ivanm> revenantphx: are you allowing more than one ant per cell?
14:28:56 <revenantphx> yes.
14:29:03 <revenantphx> And its movement determines it will move to n+1
14:29:04 <ivanm> oh, that's a different story then
14:29:16 <revenantphx> then when I iterate over n+1... :O
14:29:32 <revenantphx> I'd either have to recreate that cell... or if I was iterating over the same list, it'd be messed up...
14:29:33 <ivanm> revenantphx: yeah, so iterate over the _old_ list/array, not the new one
14:29:34 <Botje> revenantphx: making a new array fixes that
14:29:47 <revenantphx> hm yeah
14:29:51 <monochrom> why don't you have an array/list of ants, each entry records position?
14:29:53 <ivanm> remember: purely functional data structures are _persistent_!
14:30:06 <revenantphx> monochrom: because I wanted to keep only ONE record 
14:30:07 <revenantphx> t
14:30:12 <revenantphx> this is more for fun :)
14:30:12 <ivanm> monochrom: that might be easier if he is allowing multiple ants/cell
14:30:23 <byorgey> ClaudiusMaximus: sure, but in order to do that you don't need to actually count anything.
14:30:28 <revenantphx> I am allowing multiple per cell
14:30:38 <ivanm> s/if/since/
14:30:41 <byorgey> ClaudiusMaximus: just try reducing the left-hand side of the application; if that doesn't work, do the right side.
14:30:51 <revenantphx> https://gist.github.com/767152
14:30:55 <monochrom> I want to keep only one record too. Only a list/array of ants. No list/array of cells.
14:31:01 <revenantphx> this should give a little insight into the data tyupes.
14:31:14 <revenantphx> i made the World more split up so its easier to map stuff onto the paths.
14:31:33 <revenantphx> (the colony and left/right foods never have pheromone changes, so nothing they never need to be mapped over)
14:32:49 <revenantphx> I should probably use arrays here instead anyhow. :\
14:33:52 <revenantphx> oh... the other question I had was about random numbers TT_TT...
14:34:08 <revenantphx> eh, I'll look it up
14:34:20 <revenantphx> I have a feeling it might not be too simple given... pure functions and all
14:35:58 <revenantphx> QuickCheck's `frequency` pretty much does what I want >_>
14:37:02 <monochrom> I wonder how RTS games do it. Some update rules modify each ant independently. Some other update rules depend on "what other ants are within 5 cells of this ant". However cells are usually sparsely occupied.
14:38:16 <Philippa> monochrom: these days? Probably the same kinds of spatial queries you'd use in other games
14:38:31 <Philippa> (and at least related structures, though probably specialised around the obvious plane)
14:39:13 <monochrom> Two lessons I learned in the past for this. 1. commercially successful RTS games do it by "minimum requirement: Core i7 4GHz, RAM 8GB". 2. Lesson learned from a class on data structures and algorithms: don't insist on "keep only one record".
14:40:13 * hackagebot texmath 0.5 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.5 (JohnMacFarlane)
14:40:23 <gds> oooh
14:43:24 <ClaudiusMaximus> byorgey: it's a bit tricky; maybe this example simplified too much - in the real version i have 3 kinds of lambda
14:43:33 <monochrom> probably some quad-tree thingy for the cells
14:44:04 <monochrom> 3 lambdas is probably standard :)
14:45:46 <ivanm> with the deepseq discussion on libraries@, it makes me wonder: why did they bother splitting base up into containers, etc. when it's still tied deeply to ghc's release cycle, you can't upgrade them, etc. ?
14:45:50 <byorgey> ClaudiusMaximus: hmm, could be.  well, if the point of the counting is to guard against nontermination, this rewrite will not work
14:46:20 <ClaudiusMaximus> byorgey: no, the counting is to avoid reducing inside lambdas unless nothing else is possible
14:47:00 <ClaudiusMaximus> byorgey: the maximum bound in the first version was to avoid nontermination, that version tried successively with different depth limits
14:47:27 <byorgey> ClaudiusMaximus: ok, so maybe this is where the example simplified too much.  In this particular example you can avoid reducing inside of lambdas unless nothing else is possible simply by pattern matching.
14:47:31 <monochrom> containers is probably not tied
14:48:09 <revenantphx> okay I'm back
14:48:12 <byorgey> ClaudiusMaximus: oh, wait a minute, I think I get it now.
14:48:21 <revenantphx> monochrom: my C implementation keeps a record of ants and cells.
14:48:51 <revenantphx> it's a bit different though, since they're pointers.
14:49:03 <revenantphx> so when I look up an ant i can do ant->current_node->next
14:49:04 <byorgey> ClaudiusMaximus: I think what you have will work then.  It's sort of an odd reduction strategy though.
14:49:11 <monochrom> use pointers in haskell too
14:49:20 <revenantphx> I wanted to try doing it purely :\...
14:49:31 <revenantphx> I guess the fact that I need random numbers might shove a wrench in that a bit.
14:50:18 <ClaudiusMaximus> byorgey: if foo' == foo, then it'll work - the other kinds of lambda do different things, not to mention the complications of references and free variable lookup....
14:51:11 <ClaudiusMaximus> will make the changes to the real code base tomorrow, getting a bit late now to start on that
14:54:10 <monochrom> you know how if I have "let x=Ant{position=5}" and two lists "let s0 = [x, y, z]; s1 = [y, x, z]" then I have two lists but still only one ant record for x, right?
14:57:21 <ddarius> ClaudiusMaximus: What is this for?
14:57:30 <tibbe> dons: there?
14:58:34 <byorgey> poucet: code.haskell.org/~byorgey/icfp08.tgz
14:58:51 <ClaudiusMaximus> ddarius: untyped lambda calculus livecoding environment; some videos here > http://claudiusmaximus.goto10.org/v/gulcii/
15:00:41 <byorgey> ClaudiusMaximus: hah, that's pretty cool =)
15:01:00 <ClaudiusMaximus> :) thanks
15:08:38 <byorgey> @tell poucet code.haskell.org/~byorgey/icfp08.tgz
15:08:38 <lambdabot> Consider it noted.
15:11:40 <poucet> byorgey: thanks
15:11:40 <lambdabot> poucet: You have 1 new message. '/msg lambdabot @messages' to read it.
15:12:00 <byorgey> poucet: you're welcome.  I hadn't thought about that code in a long time =)
15:12:10 <poucet> If you have something like data Foo = F { x::Int, y:: Int} | G
15:12:13 <poucet> can I match it with
15:12:18 <poucet> foo f@(F{})
15:12:31 <poucet> so I can do something like
15:12:45 <poucet> foo f@(F{}) = f{x = 2}
15:13:01 <Heffalump> poucet: yes
15:13:10 <poucet> thanks =)
15:13:16 <Heffalump> I don't think you need () round F{}
15:15:59 <joe6> i have a pattern guard and in the otherwise condition, I want the system to fail, is this possible?
15:16:11 <joe6> without using IO monad or any other monad?
15:16:17 <Cale> joe6: Use the error function
15:16:19 <Cale> :t error
15:16:21 <lambdabot> forall a. [Char] -> a
15:16:37 <joe6> i am getting a compilation error using error.
15:16:40 <Twey> But only if you're sure it never should reach that branch except by programmer error
15:16:46 <joe6> give me a sec and I will post the error.
15:17:00 <joe6> yes, it should never reach that place.
15:18:16 <joe6> write_control_messages.new.hs:81:18:
15:18:16 <joe6>     Couldn't match expected type `Out' with actual type `[a]'
15:18:16 <joe6>     In the expression:
15:18:16 <joe6>         error "lineno: " ++ (show lineno) ++ " ,line: " ++ line
15:18:16 <joe6>     In an equation for `getouttxn':
15:18:19 <joe6>         getouttxn ((lineno, line@('<' : _)) : xs)
15:18:21 <joe6>           | (ifData1 line)
15:18:23 <joe6>           = OutData1 (Message (getbytes line) (Description lineno line))
15:18:26 <joe6>           | otherwise
15:18:28 <joe6>           = error "lineno: " ++ (show lineno) ++ " ,line: " ++ line
15:18:58 <joe6> does the above fragment make sense?
15:20:02 <parcs> joe6: replace error with error $
15:20:30 <parcs> and you should use a paste site for large snippets of text
15:21:51 <ddarius> ClaudiusMaximus: So why do you have three kinds of lambdas?
15:21:55 <joe6> ok, thanks.
15:23:28 * hackagebot GPX 0.4.8 - Parse GPX files  http://hackage.haskell.org/package/GPX-0.4.8 (TonyMorris)
15:23:30 <pgavin> isn't there some magic ghc rts flag that tells you exactly what chunk of code is causing your stack overflow?
15:23:35 <pgavin> lol
15:26:57 <lispy> pgavin: nothing quite that magical
15:27:57 <ddarius> Compile with profiling and -auto-all then run with -xc
15:28:45 <pgavin> ddarius: I've done that, it's not helping :/
15:28:59 <pgavin> I have a feeling it's something stupid
15:29:39 <monochrom> I should open a paid clinic for this.
15:30:00 <monochrom> I want your money and you want me to find the stack overflow
15:30:14 <pgavin> lol
15:30:32 <pgavin> It's a tail recursive loop
15:30:40 <gwern> monochrom: transaction costs are a killer and things like Flattr aren't popular enough
15:30:42 <pgavin> and everything has bangs
15:30:44 <Mathnerd314> monochrom: you're too likely to be made obsolete
15:30:47 <monochrom> perhaps just big thunk
15:31:21 <monochrom> what is Flattr?
15:32:18 <byorgey> monochrom: http://flattr.com/
15:32:42 * ddarius doesn't think monochrom will be made obsolete for some time.
15:32:50 <monochrom> try to prove termination in a formal theorem prover. it may point you at the problem.
15:33:08 <poucet> What does this mean:     Unexpected strictness annotation: !Vertex3
15:33:31 <monochrom> it means the ! is not supposed to be there
15:33:32 <Cale> poucet: Is that inside a datatype declaration?
15:33:36 <mauke> "that strictness annotation was a complete surprise to me at this point in the program"
15:33:44 <poucet> http://hpaste.org/42777/octtree
15:33:46 <poucet> Cale: yes
15:34:03 <monochrom> but yeah I see I'm just translating plain english to plain english
15:34:04 <gwern> monochrom: it's yet another attempt at microtransactions
15:34:15 <mauke> did you mean: !(Vertex3 a)
15:34:24 <poucet> aha!
15:34:54 <poucet> mauke: thanks
15:44:26 <phao> Hi, I'm getting an error in this code here: http://hpaste.org/42779/exercises ghci tells me that there is an erro on line 214
15:44:46 <phao> it says "couldn't match expected type 'IO Char' with infered type 'a -> Char'"
15:44:56 <phao> "In a stmt of a 'do' expression: c <- getCh"
15:45:27 <phao> what is the problem there?
15:46:42 <monochrom> what is the type of getCh ?
15:47:11 <monochrom> alright, it's IO Char
15:47:15 <phao> IO Char
15:47:34 <ddarius> There error is elsewhere.
15:48:06 <roconnor> what's a presheef?
15:48:33 <ivanm> roconnor: something you do before a sheef? :p
15:51:39 <monochrom> "showStr str" is wrong
15:51:51 <phao> yes
15:51:56 <phao> corrected that already
15:51:58 <phao> thx
15:52:40 <pgavin> does anyone know if it's better to use foldr or foldl with shows?
15:53:49 <pgavin> > foldr (\n f -> showString "(" . shows n . showString ")" . f) id [0 .. 10] $ ""
15:53:52 <lambdabot>   "(0)(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)"
15:54:10 <pgavin> for example
15:54:31 <pastorn> Philippa: remember what we were talking about earlier, about a Var (IO ())?
15:54:44 <pgavin> > foldl (\f n -> f . showString "(" . shows n . showString ")") id [0 .. 10] $ ""
15:54:45 <lambdabot>   mueval-core: GhcException "signal: 15"
15:55:38 <pgavin> ...
15:55:46 <parcs> seems like foldr is the better choice
15:55:52 <pgavin> that's what I thought
15:56:02 <ddarius> roconnor: A contravariant functor into Set.
15:56:19 <ddarius> Well, that's what a presheaf is.
15:57:14 <ddarius> pgavin: The "rule" is if the argument function is lazy in the accumulator, use foldr, otherwise use foldl'.
15:57:32 <pgavin> sure
15:57:39 <pgavin> so foldr should be better
15:58:22 <pgavin> because the point of the whole shows exercise is to build the string lazily, right
15:58:36 <ddarius> No.
15:58:42 <ddarius> The string is built lazily regardless.
15:58:45 <pgavin> um
15:58:59 * poucet whistles: 1 
15:59:05 <poucet> 1 
15:59:08 <pgavin> the problem was with applying (++) left to right, iirc
15:59:08 * aristid whistles: 2
15:59:23 <aristid> poucet: but why are we whistling numbers?
15:59:31 <poucet> 1,151,697,232 bytes x seconds 
15:59:43 <poucet> That is what I meant to paste, but pasting from a pdf fails :|
16:01:42 <pastorn> @pl (\xs ys f -> zipWithM_ f xs ys) -- forM2_
16:01:42 <lambdabot> flip . flip zipWithM_
16:22:43 <phao> is it a problem to mix up IO with normal return value, like here http://hpaste.org/42781/555
16:22:48 <phao> for escWhich
16:23:57 <ddarius> IO isn't some kind of annotation or taint or something, it is a data type.  An IO Int isn't an Int, exactly like a [Int] isn't an Int.
16:24:07 <ddarius> There are no implicit conversions in Haskell.
16:24:35 <phao> but I'm not returning an IO in escWhich
16:24:39 <phao> I'm returning an int based on what I read
16:24:59 <mauke> escWhich :: Int claims escWhich is a constant
16:25:03 <sipa> phao: return exactly turns an Int into a IO Int
16:25:03 <mauke> an integer
16:25:08 <nostrand> phao: yeah, but you use getCh which i guess has a type of IO Char
16:25:36 <mauke> you're using 'otherwise' wrong
16:25:49 <mauke> you don't need ord
16:26:24 <phao> why am I using otherwise wrong?
16:26:41 <phao> saw it
16:26:41 <ddarius> phao: You are not using it at all.  You are binding it there.
16:26:44 <mauke> because you're not using it :-)
16:27:08 <mauke> > case 41 of otherwise -> otherwise + 1
16:27:10 <lambdabot>   42
16:27:10 <ion> In getCh >>= (\c â†’ â€¦), the type of the right-hand parameter must be a â†’ IO b
16:29:09 <nostrand> phao: maybe you should read a bit in Learn You a Haskell or Real World Haskell(freely available online). There you will get good explanations =)
16:29:23 <i> hello
16:29:23 <lambdabot> i: You have 1 new message. '/msg lambdabot @messages' to read it.
16:29:40 <blackdog> i'm trying to get a build script back together on the hudson box i accidentally blew away (oops...) - is there a better way of making sure cabal is up to date than just running "cabal update" before every build?
16:29:54 <blackdog> it seems slow even when then there's nothing to update
16:30:35 <Guest29386> i can has haskell please?
16:30:37 <ddarius> cabal update just downloads the index 
16:31:44 <Guest29386> gentlemen, may I interrupt you for a quick question please?
16:31:50 <blackdog> ddarius: so there's no way to grab a checksum or something?
16:32:01 <blackdog> I suppose it doesn't really matter.
16:32:11 <blackdog> Guest29386: never ask to ask:) just go!
16:32:30 <blackdog> (uh, as in ask your question. i'm not telling you to go away. that would be rude, and i'm only rude to Axman6)
16:32:56 <Guest29386> i know little about haskell, and would like to download it on my phone (N900) if possible do you know how i could do that?
16:32:59 <ddarius> blackdog: Why do you need to cabal update before every build?
16:33:10 <mauke> Guest29386: download what?
16:33:38 <Guest29386> install haskell on my phone (N900), running Maemo
16:33:38 <blackdog> ddarius: it's a hudson build - i won't ever actually log in to the machine otherwise, so if there isn't a hook for cabal to be occasionally updated, it won't ever be.
16:33:50 <mauke> Guest29386: what do you mean by "haskell"?
16:33:55 <monochrom> no haskell implementation for N900 I know of
16:33:57 <phao> what is '\DEL' ... when I hit delete, it doesn't trigger '\DEL'
16:34:11 <monochrom> > ord '\DEL'
16:34:11 <mauke> phao: try backspace
16:34:12 <lambdabot>   127
16:34:12 <phao> it triggers '\ESC' and two other characters
16:34:18 <blackdog> ddarius: the whole point is to get a set-and-forget sort of situation
16:34:26 <phao> well, backspace works, but I wanna delete too
16:34:34 <roconnor> @type deriv
16:34:35 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
16:34:40 <mauke> enjoy parsing terminal escape sequences
16:34:42 <monochrom> keyboard mapping is non-trivial in modern day OSes
16:34:51 <Guest29386> so, there is no way i can get a haskell (compiler?) on my N900? (it runs on ARM)
16:34:53 <phao> monochrom, I've noticed
16:34:54 <blackdog> it also acts as doco: if i can point someone at a buildscript that gets them running from ground zero, then they've got a better chance of debugging their problems
16:35:05 <roconnor> edwardk: would cosequence :: (Comonad w) => w (Stream a) -> Stream (w a) be usefull?
16:35:22 <monochrom> not just non-trivial, also varies among users, even if same OS. users really love to customize.
16:35:32 <Philippa> Guest29386: the traditional trick's a debian chroot
16:35:37 <edwardk> roconnor:  hrm. i just posted up a stream comonad transformer, one sec.
16:35:57 <Philippa> haven't done it on n900, but I've done it on a Zaurus (be glad you've got more memory than that!) and I've heard it works on Android too
16:36:11 <Guest29386> chroot?
16:36:19 <Philippa> I think at least one person around here (shapr?) has done it under older versions of maemo too
16:36:22 <roconnor> cosequence x = (extend (hd . extract) x) :> cosequence (fmap tl x)
16:36:32 <roconnor> as a guess
16:36:43 <roconnor> I'm not even sure if the type of cosequence is right
16:36:44 <edwardk> https://github.com/ekmett/comonad-transformers/blob/master/Control/Comonad/Trans/Stream.hs is my new transformer
16:36:54 <edwardk> (note that the simple stream is gone)
16:36:58 <Philippa> yeah, you mount a complete debian install under somewhere and use the chroot command to effectively run debian under maemo - and then use debian's GHC build
16:37:06 <Philippa> how current a version of GHC's available, I don't know
16:37:11 <Philippa> no GHCi
16:37:16 <edwardk> its 'CofreeT done right' ;)
16:37:21 * ddarius wonders where his pants went.
16:37:34 <c_wraith> CoffeeT?  Seems strange to mix coffee and tea.
16:37:46 <mauke> CoFeet
16:37:48 <roconnor> edwardk: I spent an hour thinking about Cowriters today.  They seem kinda cool
16:37:52 <Philippa> unless you're tight for bandwidth you'd be better off sshing into an x86 box somewhere instead though
16:37:54 <edwardk> i'm fond of them
16:38:03 <roconnor> edwardk: does tell :: m -> Cowriter m a -> Cowriter m a ?
16:38:04 <edwardk> they became TracedT
16:38:15 <edwardk> tell :: m -> TracedT m w a -> a
16:38:20 <edwardk> you extend it if you want to keep it
16:38:21 <roconnor> oh
16:38:46 <roconnor> that is flip runTrace
16:38:49 <edwardk> yep =)
16:38:50 <roconnor> for Traced
16:39:04 <edwardk> https://github.com/ekmett/comonad-transformers/blob/master/Control/Comonad/Trans/Traced.hs
16:39:09 <phao> monochrom, any easy way to see if the user typed a back arrow key, or the delete key?
16:39:10 <roconnor> I guess that isn't an unreasonable primitive
16:39:12 <Guest29386> hmm... i will investigate further what you said, mr. Philippa. Thank you gentlemen!
16:39:55 <Philippa> ...mr?
16:40:06 <Philippa> not a lot of guys out there with this name, but hey
16:40:15 <phao> '\DEL' isn't working... and I know that if I put this string "\ESC[1d", the cursor goes back 1 char... but I have no clue how to use those things to do what I want (recognize delete and back arrow)
16:40:22 <roconnor> edenc: if you want to be extra cool, instead of having get and set for StoreT, you make a lens ... which is an coalgebra for Store :D
16:40:26 <roconnor> oopw
16:40:35 <roconnor> that was for edwardk
16:40:38 <roconnor> who is gone
16:41:05 <Guest29386> my sincere apologies... Thank you again and i apologise for the mistake
16:42:10 <aristid> roconnor: @tell may help?
16:43:05 <edwardk> ?
16:43:19 <roconnor> edwardk: if you want to be extra cool, instead of having get and set for StoreT, you make a lens ... which is an coalgebra for Store :D
16:43:20 <edwardk> sorry: at a talk. internet sporadic ;)
16:43:32 <edwardk> roconnor: i wanted something that wasn't too radical for folks ;)
16:43:33 <hpc> phao: \DEL is the delete key, not backspace
16:43:39 <hpc> i think
16:43:42 <roconnor> edwardk: fair
16:43:53 <roconnor> edwardk: people can make their own lenses out of get and set.
16:43:54 <phao> hpc, I tried testing hitting del and checking if the read character is '\DEL'
16:43:56 <phao> returns false
16:43:57 <edwardk> i figure i blew my feature budget on comonad transformers
16:44:10 <roconnor> edwardk: not really.  People expect comonad transformers
16:44:13 <edwardk> =)
16:44:36 <ddarius> edwardk: Which talk?
16:44:40 <roconnor> now if you can create some sort of codo notation, that'd be great
16:45:05 <phao> do {c <- getCh; if c == '\DEL' then putStr "YES" else putStr "NO";} -- I did that after disabling echoing and buffering from stdio
16:45:10 <phao> got me "NO"
16:46:16 <astroboy> I am trying to install the package "snap" with cabal, but it fails because haskell-src fails to install. haskell-src says fails because happy is not installed. I installed happy manually (cabal install happy) but ghc-pkg list doesn't show it. any suggestions? I'm doing this on a ubuntu server, i installed ghc6 and cabal-install with apt-get
16:47:12 <blackdog> astroboy: is happy in your path?
16:47:45 <blackdog> it'll try to use happy as a build tool, not as a dependent library
16:47:52 <blackdog> you could even just apt-get install it
16:48:16 <parcs> astroboy: ghc doesn't keep track of executables
16:48:26 <astroboy> blackdog: Yes I could, but I like to use cabal to install the haskell packages
16:48:44 <blackdog> yep, that's fine, too, but what does "which happy" give you?
16:49:15 <ivanm> astroboy: "cabal install happy"
16:49:37 <astroboy> blackdog: nothing, maybe I have to add the cabal bin dir to the path? I'll try now
16:49:39 <blackdog> ivanm: he just did that:)
16:49:45 <blackdog> astroboy: that'd be your problem.
16:49:48 <ivanm> oh, I missed that
16:50:08 <ivanm> astroboy: make sure you use $HOME/.cabal/bin and not ~/.cabal/bin; the latter sometimes results in problems
16:50:32 <astroboy> ok it works now, stupid me I forgot to do that :P
16:50:47 <astroboy> I had cabal installed for such a long time on my machine that i forgot how to set it up
16:51:27 <blackdog> astroboy: it's not entirely your fault. "cabal install snap" ought to be able to build from nothing, there's just a slightly awkward build-tools setup
16:52:21 <blackdog> you don't necessarily want to require 'happy' as a dependency, because it's not needed at runtime, and it could be built by another compiler anyway.
16:52:28 <c_wraith> The real problem is that cabal-install doesn't know how to install binaries.
16:52:45 <c_wraith> as a dependency, that is.
16:52:47 <astroboy> yeah cabal install is definitely not perfect :P
16:53:08 <blackdog> c_wraith: yeah. i'm just saying it's a tricky problem
16:53:17 <blackdog> lots of error cases
16:53:18 <c_wraith> I agree.  There are lots of wrong answers. :)
16:53:47 <c_wraith> also, you can depend on binaries that aren't haskell programs!
16:53:56 <blackdog> yes, exactly.
16:54:18 <blackdog> but it'd be nice to have a '--just-do-it-i-trust-you' flag
16:54:43 <blackdog> we've already got the tip "maybe you need to install happy" in cabal install
16:58:34 <geheimdienst> suppose i have a bunch of functions like Â«f (r@SomeRecord { a, b, c }) = ...Â». is there any way to omit the SomeRecord? especially since i just declared f :: SomeRecord ...
16:58:39 <astroboy> anyway, thanks for the help
16:58:51 <astroboy> going to play with snap tomorrow I guess
17:03:11 <azaq23> m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r -- is the definition of >>= for the (Reader r) Monad for newtype Reader r t = Reader (r -> t), which is structurally equivalent to the definition of >>= for the function monad ((->) r). This structural equivalence is called "isomorphic", right?
17:07:43 <__yhvh__> I'm importing Data.Color just fine in a program, how can I jump to it's definition in emacs, it's failing atm
17:08:02 <hpc> azaq23: i believe so; it's how i have used it
17:10:01 <hpc> i vaguely remember being told i was wrong though
17:10:30 <hpc> no, in this case it is right
17:10:35 <hpc> wikipedia confirms
17:11:11 <ddarius> azaq23: All newtypes introduce isomorphisms.
17:16:19 <hpc> unless you can find multiple monad instances, of course
17:16:35 <hpc> or $typeclass instances
17:21:40 <nzero> Hi, I'm trying to define liftM more compactly using >>= but am stuck at: myLiftM f m = m >>= \s -> return (f s).  Any hints?  (It's an exercise in G.Hutton's new monad tutorial http://is.gd/kc1tP)
17:21:58 <hpc> @src liftM
17:21:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:22:49 <nzero> a bit clearer here https://gist.github.com/767348
17:22:54 <hpc> liftM = fmap
17:23:09 <hpc> assuming all your monads are functors
17:23:15 <parcs> nzero: your definition is correct
17:23:16 <hpc> (which they should be)
17:23:29 <hpc> parcs: i think he is stuck at trying to make it more compact
17:23:35 <nzero> hpc: Thanks, It's a learning exercise meant to get me used to >>=
17:24:13 <parcs> oh, i see. well, try omitting the lambda
17:24:19 <nzero> parcs: yep, I can't think of how to compact it.
17:24:25 <hpc> @src Monad fmap
17:24:26 <lambdabot> Source not found. You type like i drive.
17:24:30 <hpc> pah
17:24:47 <hpc> :t fmap
17:24:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:24:48 <hpc> :t liftM
17:24:49 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:25:04 <hpc> i forget the proof that they are the same
17:25:48 <hpc> :t return . f
17:25:49 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, SimpleReflect.FromExpr (f a), Functor f) => f (m a)
17:27:13 <pastorn> what's cheapest? STM or MVars?
17:28:28 <azaq23> hpc I was formulating a question along these lines, using Control.Applicative.ZipList as a example (for the Reader newtype, there clearly seems to be only one way to define a monad instance, though), but I'm not sure whether ddarius means the general case, since you need to expose the internal type in a newtype in some way, for the newtype would otherwise be pretty useless, but this exposement seems to automatically introduce something lik
17:28:30 <nzero> hpc: thanks.  I'll go and get my head around that.   myLiftM f m = m >>= return . f
17:28:33 <brisbin> http://hpaste.org/paste/42786/do_let_correction#p42788 -- am i running into a bug here? if i do has hlint says it won't compile.
17:28:41 <azaq23> but of course that could be bs since I just asked about the meaning of isomorphic
17:28:56 <hpc> ziplist isn't a monad though
17:29:05 <hpc> i think
17:29:58 <pgavin> ok, so I have a really strange problem... this is essentially how my program is structured: loop arg = let arg' = ... in trace "foo" $ if continue then loop arg' else result
17:30:01 <hpc> brisbin: check the indentation on your where clause
17:30:12 <azaq23> okay, correct, so s/monad/applicative/g :)
17:30:14 <pgavin> if I remove the trace "foo" $     the program stack overflows
17:30:37 <hpc> as far as i know, the popular style is to half-indent the line beginning the where clause
17:30:44 <pgavin> any ideas?
17:31:11 <hpc> right now you have the where block continuing the do, instead of being attached to the function definition
17:31:14 <hpc> if that makes sense
17:31:39 <brisbin> hpc: it does, it's what i usually do. even if i fully indent it, the error (which is targeted at line 3) remains when using let
17:31:43 <brisbin> if that makes sense...
17:31:43 <hpc> :t trace
17:31:44 <lambdabot> Not in scope: `trace'
17:32:02 <pgavin> hpc: see Debug.Trace
17:32:13 <hpc> :t Debug.Trace.trace
17:32:14 <lambdabot> forall a. String -> a -> a
17:32:24 <pgavin> > Debug.Trace.trace "a" $ 1
17:32:25 <lambdabot>   Not in scope: `Debug.Trace.trace'
17:32:29 <pgavin> ehh...
17:32:32 <pgavin> try it in ghci
17:32:39 <pgavin> basically just prints a debug message
17:33:02 <hpc> brisbin: tabs? i am grasping at straws at this point
17:33:35 <brisbin> hpc: i'm leanign against indentation since the '<- return' redundancy works ok... but i'll keep toying, thanks.
17:34:37 <mm_freak> hpc: in my functions the 'where' key word is lined up with the definitions it introduces
17:34:42 <brisbin> hpc: also, i'm under the impression as long as teh where is indendented past top level, you're ok
17:36:36 <mm_freak> pgavin: make sure you're using optimization
17:36:38 <younder>  have you heard "The Day the Routers Died"? (utube)
17:37:01 <mm_freak> brisbin: past the definition it belongs to
17:37:15 <mm_freak> same as do, let and other keywords
17:37:39 <mm_freak> and i think for the last function in the file it's even ok not to indent 'where' at all
17:37:46 <mm_freak> but i'd consider that bad style
17:37:50 <brisbin> agreed
17:38:05 <pgavin> mm_freak: I am
17:38:28 <mm_freak> pgavin: can you paste the code to hpaste.org?
17:38:30 <pgavin> mm_freak: really, all I do is comment out the trace "foo" $ part and it works
17:38:35 <pgavin> it's a lot of code
17:38:56 <brisbin> mm_freak: "the definition it belongs to" is what i actually meant by top level, though now i realize that's confusing...
17:39:12 <mm_freak> pgavin: i don't see how 'trace' can change anything
17:39:27 <pgavin> mm_freak: exactly
17:39:34 <mm_freak> brisbin: let's say parent definition
17:39:41 <mm_freak> dunno what it's called
17:39:46 <brisbin> fair enough
17:40:21 <mm_freak> brisbin: what about that "'<- return' redundancy"?
17:40:23 * azaq23 noticed that I forgot about the IRC msg length limit, so here's the rest of the cut of sentence "but this exposement seems to automatically introduce something like a isomorphism - wouldn't, for instance, newtype T t = T { runT :: [t] } make the data constructor T and the function runT automatically a isomorphism between List and T?"
17:41:33 <mm_freak> azaq23: if you're using irssi you may be interested in splitlong.pl
17:42:19 <brisbin> mm_freak: http://hpaste.org/paste/42786/do_let_correction#p42788 line 3 fails to compile, though line 4 is the redundancy
17:42:25 <brisbin> but compiles
17:43:19 <mm_freak> brisbin: indent the fields past the "sqlPost"
17:43:21 <mm_freak> then it should work
17:43:31 <brisbin> aren't they indented?
17:43:38 <mm_freak> yes, but not enough
17:43:49 <brisbin> oh, past SqlPost?
17:43:56 <mm_freak> sqlPost
17:44:05 <mm_freak> but i usually indent even past SqlPost
17:44:29 <mm_freak> i like this style:
17:44:36 <mm_freak> let x = X { abc = â€¦,
17:44:46 <mm_freak>             def = â€¦ }
17:45:04 <humasect> liftM
17:45:09 <brisbin> mm_freak: that was it, and answers why sometimes it fails and others it works. thank you.
17:45:18 <mm_freak> you're welcome
17:47:23 <mm_freak> now, completely different issueâ€¦  i'm writing a little game engine and really wonder how to approach it from a semi-functional style without using FRP
17:48:00 <hpc> FRP isn't entirely appropriate for a game engine, i think
17:48:07 <mm_freak> my current idea is that every game object is a haskell thread, but i'm afraid i'll run into unpredictable performance behaviour with this
17:48:08 <hpc> it's damned hard to model a game continuously
17:48:32 <humasect> do what comes natural
17:48:34 <hpc> i tried to model it as a buffered game state
17:48:34 <mm_freak> hpc: i could do it, but i don't like the current FRP implementations and i'm not smart enough to write my own
17:48:49 <hpc> where every individual entity based its action on the previous frame
17:48:56 <alpounet> mm_freak, couldn't you put in there some notion of object group ?
17:48:57 <hpc> and so every entity was threadsafe
17:49:27 <humasect> function game loop:  thisWorld = update thisWorld
17:49:29 <mm_freak> alpounet: yes, the most straightforward way would be to write a data type for game objects, but unfortunately that's not very composable
17:49:36 <mm_freak> uhm
17:49:39 <mm_freak> not very extensible, i mean
17:49:57 <joe6> in parsec, how do I get the SourcePos?
17:50:04 <joe6> I tried pos <- getPosition
17:50:07 <humasect> extensible? composible? is this for theory
17:50:09 <hpc> if you go the route of existentials, you are better off using a C-like language, too
17:50:30 <hpc> because they have nicer handling of such things, through their own polymorphism
17:50:32 <dobblego> @type \a b -> do t <- a; if t == mempty then b else return t -- is this in the GHC libraries
17:50:33 <joe6> sorry, ignore my question
17:50:33 <lambdabot> forall (m :: * -> *) b. (Monad m, Monoid b, Eq b) => m b -> m b -> m b
17:50:38 <mm_freak> humasect: i write a game library with some base object types, and the user should be able to add new object types without having to change the library
17:50:45 <hpc> :t guard
17:50:46 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:51:12 <hpc> :t if' . (== mempty)
17:51:14 <lambdabot> Not in scope: `if''
17:51:19 <humasect> mm_freak: ah, type classes? =) or just monads for AI ... there is no requirement for complexity yet 
17:51:30 <hpc> @let if' a b c = if a then b else c
17:51:31 <lambdabot>  Defined.
17:51:32 <hpc> :t if' . (== mempty)
17:51:33 <lambdabot> forall t a. (Monoid a, Eq a) => a -> t -> t -> t
17:51:52 <hpc> pah
17:52:23 <mm_freak> humasect: type classes alone don't enable me to have heterogenous sets
17:52:34 <aristid> :t if'
17:52:35 <lambdabot> forall t. Bool -> t -> t -> t
17:52:52 <humasect> no?
17:53:13 <mm_freak> humasect: i need at least existentials
17:53:20 <hpc> mm_freak: my approach was to go with a static-typed scenegraph
17:53:32 <mm_freak> hpc: how does that work?
17:53:33 <hpc> you don't need existentials if you know every type of every object
17:53:40 <mm_freak> i don't
17:53:46 <hpc> and you can have a root with [Player], [Prop] etc
17:53:48 <humasect> "Existentials is a fancy word for "expressions that talk about the existence of things"" ?
17:53:50 <mm_freak> it's a library, not a game
17:54:04 <humasect> but too abstract is also a limitation
17:54:09 <mm_freak> humasect: higher ranked types
17:54:15 <humasect> ahh
17:54:16 <hpc> make functions to aid with handling a scenegraph
17:54:19 <hpc> and let them build it themselves
17:54:32 <hpc> it gives them more control over the end product, but you can still take over the hard stuff
17:54:34 <humasect> what i did was provide enough types that new behaviours can be Read and Shown
17:55:00 <mm_freak> hpc: my current approach lets objects modify vertex arrays through a custom monad, but i'm adding a lot of concurrency objects and that will have bad performance behaviour
17:55:38 <hpc> i suppose it would help if i wrote a game in a C-like language first
17:55:49 <mm_freak> i wrote games in C++
17:56:00 * hpc has mostly lost the ability to think imperitively or OO
17:56:10 <mm_freak> and i really like the FRP approach, but current libraries are too slow
17:56:38 <humasect> a kind of FRP will come from your solution, custom and efficient
17:57:04 <mm_freak> humasect: the current approach isn't even close to FRP
17:57:07 <mm_freak> it's very imperative
17:57:30 <mm_freak> perhaps for now i could do RP without the F
17:57:39 <humasect> when the solution is a complete whole, its parts will be too =)
17:59:17 <humasect> ah, Core Animation is a bit of RP
18:07:41 <joelb> Is there a simple function that returns if a string can be read as an integer?
18:08:12 <monochrom> use reads
18:08:15 <monochrom> @type reads
18:08:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:08:27 <monochrom> here is what typically happens:
18:08:32 <monochrom> > reads "1234"
18:08:33 <lambdabot>   []
18:08:43 <hpc> > reads "1234" :: Int
18:08:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:08:45 <lambdabot>         against inferred type ...
18:08:50 <monochrom> > reads "1234" :: [(Int,String)]
18:08:51 <lambdabot>   [(1234,"")]
18:08:54 <hpc> > reads "1234" :: ReadS Int
18:08:56 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
18:08:56 <lambdabot>           ...
18:09:00 <hpc> :/
18:09:06 <monochrom> that's what happens when success
18:09:06 <joelb> ah got it
18:09:12 <joelb> Thanks!
18:09:14 <monochrom> > reads "abc" :: [(Int,String)]
18:09:15 <lambdabot>   []
18:09:20 <hpc> a good read will match [(x,_)]
18:09:20 <monochrom> that's one way it fails
18:09:27 <monochrom> > reads "123 " :: [(Int,String)]
18:09:28 <hpc> a failed one is []
18:09:28 <lambdabot>   [(123," ")]
18:09:36 <monochrom> that's another way it fails
18:09:38 <hpc> an ambiguous one is x:y:xs
18:10:05 <monochrom> so you should really look for [(x, "")]
18:10:47 <humasect> maybeRead s = case reads s of { [(x, rest)] | all isSpace rest -> Just x; _ -> Nothing } 
18:11:16 <joelb> It doesn't necessarily have to be an empty string, correct? As long as the list returned is not empty then it can be read?
18:11:28 <monochrom> > reads "123nononon" :: [(Int,String)]
18:11:30 <lambdabot>   [(123,"nononon")]
18:11:34 <monochrom> think about that
18:11:43 <hpc> joelb: yes, but not unambiguously
18:12:01 <hpc> depends on how important the data is, and how much you care about reading it in correctly
18:12:04 <hpc> :t reads
18:12:05 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:12:11 <hpc> @src reads
18:12:11 <lambdabot> reads = readsPrec minPrec
18:12:16 <hpc> o.O
18:12:31 * hpc reads up on reads
18:13:18 <joelb> thanks for the help!
18:13:21 <roconnor> damn, my simplified intergation function is 20x slower
18:13:26 * geheimdienst has never understood that Prec stuff
18:13:28 <monochrom> I wouldn't call " 123" or "123 " or "123nonono" or "nonono123" a string that can be read as a number
18:14:04 <roconnor> apparently calling forevery on an uncountable set is slow.
18:14:23 <roconnor> and calling it 3 times per recursive call is even slower.
18:16:15 <gwern> but infinitely slow * 3 is still infinitely slow, no?
18:16:49 <geheimdienst> gwern, only on a triple-core processor
18:17:13 <gwern> so adding another core could give us an infinite speedup?
18:17:57 <geheimdienst> yeah. my 16-core monster executes an infinite loop in about 40 seconds
18:18:30 <roconnor> geheimdienst: it's not infinitely slow
18:18:36 <roconnor> it only took 90 seconds
18:19:11 <geheimdienst> gwern, see?
18:19:34 <roconnor> I have 2 cores but I'm using sequential haskell
18:19:39 <gwern> but forevery on an uncountably infinite set? o.0
18:19:42 <roconnor> though using par is an interesting idea
18:19:57 <roconnor> gwern: the set is compact if that makes you feel better
18:20:33 <gwern> a little, not that I understood sigfpe's or whomever's blog posts on cantor sets
18:21:30 <roconnor> In this case the compact set in question is the unit interval.  All CReal numbers between 0 and 1
18:21:42 <roconnor> unitInterval :: Set CReal
18:21:43 <roconnor> unitInterval = do
18:21:44 <roconnor>   x <- unitInterval
18:21:46 <roconnor>   doubleton (left x) (right x)
18:22:08 <roconnor> where left and right are lazy functions for computing x/2 and (x+1)/2 respectively
18:22:32 <roconnor> I like this function because the recursive call is made first, then the result is returned.
18:22:45 <gwern> you speak with a forked tongue, white mathematician
18:23:15 <roconnor> mathematician's definition of the unit interval: { x : 0 <= x <= 1}
18:24:28 <roconnor> computer scientist's definition of the unit interval.  I = (I*1/2) union (I+1)*(1/2)
18:29:07 <monochrom> php programmer's definition of the unit interval: unit interval
18:30:02 <ddarius> http://lambda-the-ultimate.org/node/1297
18:30:11 <mauke> http://www.exploringbinary.com/php-hangs-on-numeric-value-2-2250738585072011e-308/
18:30:22 <roconnor> oh good
18:30:36 <roconnor> now my mostly simpler code is as fast as my original code
18:30:46 <roconnor> er
18:30:51 <roconnor> actually it is twice as slow
18:31:13 <roconnor> at least it isn't 20x as slow
18:33:42 <gwern> hm. interval arithmetic looks a lot like probability with a uniform/maxent distribution assumed
18:36:34 <roconnor> pft interval arithmetic
18:38:26 <MrWish> hello
18:39:12 <MrWish> Im trying to run a function from a source file called baby.hs in WinGHCi, but it wont work somehow?? I got the function from a tutorial, it goes:
18:39:30 <MrWish> bmiTell :: (RealFloat a) => a -> a -> String
18:39:38 <lispy> MrWish: oh noes, it doesn't work?  What do you mean it doesn't work?
18:39:39 <MrWish> uhm...
18:39:57 <MrWish> bmiTell weight height
18:40:02 * lispy wonders if work means force * distance
18:40:11 <MrWish> | bmi <= 18.5 = "You're underweight, you emo you!"
18:40:29 <MrWish> and 3 more guard statements
18:40:56 <roconnor> notices it seems to be impossible to define integration without using a limit.
18:40:56 <MrWish> baby.hs:50:0: parse error on input `|'
18:41:01 <MrWish> that is what I get
18:41:01 <roconnor> */me
18:41:26 <geheimdienst> @pl lift $ withDisplay (\d -> io $ xftTextExtents d font text)
18:41:26 <lambdabot> lift (withDisplay (io . flip (flip xftTextExtents font) text))
18:41:49 <geheimdienst> ... doesn't really simplificate ...
18:42:03 <lispy> MrWish: you might put your program on a pastebin, say http://hpaste.org and let us look at it
18:42:37 <lispy> roconnor: There are types of integration besides Riemann integration
18:42:44 <lispy> roconnor: but, they may also need limits
18:42:54 <roconnor> they are also mostly uncomputable
18:43:13 <azaq23> > let f :: Floating t => t -> String; f x | x <= 15 = "Something" in f 14
18:43:14 <lambdabot>   Could not deduce (GHC.Classes.Ord t)
18:43:14 <lambdabot>    from the context (GHC.Float.Floatin...
18:43:20 <roconnor> Steiltje's integrals are nice though.
18:43:27 <lispy> roconnor: oh, you didn't mention that :)
18:43:46 <roconnor> what good is an intergral if it isn't computable ? 
18:43:51 <azaq23> > let f :: (Ord t, Floating t) => t -> String; f x | x <= 15 = "Something" in f 14
18:43:52 <lambdabot>   "Something"
18:43:52 <ddarius> roconnor: You may like Daniell's integral.
18:44:26 <ddarius> As far as definitions not using limits, you may be interested at the stuff done in relation to synthetic differential geometry.
18:44:37 <ddarius> Things like Lawvere's "amazing" adjoint.
18:45:16 <roconnor> ddarius: that's okay.  Computable limits are computable
18:45:27 <revenantphx> I have a question about finding a specific data type  :\
18:45:35 <revenantphx> right now I'm just using an array >_>
18:45:52 <revenantphx> Say you have a finite number of nodes from which each ant can move left or right.
18:45:58 <revenantphx> Now, the important bits are:
18:46:04 <roconnor> comonad!!
18:46:10 <revenantphx> 1) needs to prioritize fast access to adjacent tiles
18:46:37 <revenantphx> 2) easy to find out which half of the nodes an ant is in, etc (this not so much since I can just have two separate branches.
18:46:40 <revenantphx> )
18:46:46 <revenantphx> The first one is most important I think.
18:47:01 <revenantphx> Doubly-linked list is what I use in C, just wondering if there's something better in haskell.
18:47:06 <revenantphx> Something more... functional.
18:47:30 <roconnor> revenantphx: a zipper for a list  will give you (1)
18:47:43 <revenantphx> I have a lot of ants btw
18:47:53 <lispy> revenantphx: it sounds like you want a space partition
18:48:07 <revenantphx> I need to iterate through all of the cells and build a new data structure with all the movements.
18:48:09 <roconnor> revenantphx: do the ants move?
18:48:13 <revenantphx> Yes, every timestep
18:48:15 <lispy> revenantphx: I don't know if kd-trees let you do quick adjacent access, but you might check on them
18:48:35 <roconnor> revenantphx: does each ant have an ID?
18:48:45 <revenantphx> No, but I could do that.
18:48:51 <revenantphx> why do you ask?
18:48:52 <roconnor> no no
18:49:09 <roconnor> you could keep a map from ant to location
18:49:18 <revenantphx> Thats what I do in the C one.
18:49:26 <revenantphx> well, all ants have a pointer to their current node.
18:49:30 <roconnor> But I think that given each ant an ID is not a great idea
18:49:31 <ddarius> The wikipedia page for the Daniell Integral has a Integrals cross-linking section at the bottom.  Of -all- the many links mentioned there, only do not include one or more people's names: improper integral and regulated integral.
18:49:52 <revenantphx> So what's the consensus on what would be a good idea?
18:49:59 * edwardk waves hello.
18:50:03 <revenantphx> hey
18:50:04 <roconnor> what does it mean to be able to find out which half of the nodes an ant belongs to if ants have no ID?
18:50:13 <revenantphx> Ok let me put it this way
18:50:31 <revenantphx> In my C implementation, the colony is at the center, and it has two pointers outward
18:50:36 <roconnor> maybe I should have asked if different ants are distinguishable
18:50:40 <revenantphx> each one goes to a node which has "next" and "prev" (going outwards)
18:50:46 <revenantphx> until a food source node at the end
18:50:51 <MrWish> hey I tried out a function from a tutorial, loading it from a source file in WinGHCi, but it doesnt work... the function goes as follows: 
18:50:57 <MrWish> bmiTell :: (RealFloat a) => a -> a -> String
18:50:57 <MrWish> bmiTell weight height
18:50:57 <MrWish> | bmi <= 18.5 = "You're underweight, you emo you!"
18:50:57 <MrWish> | bmi <=  25.0 = "You're supposedly normal. Pfffft, I bet you're ugly!"
18:50:57 <MrWish> | bmi <= 30.0 = You're fat! Lose some weight, fatty!"
18:50:57 <MrWish> | otherwise = "You're a whale, congratulations!";
18:51:00 <revenantphx> no, they're indistinguishable. All an ant does is have food or not.
18:51:03 <revenantphx> (and lay pheromone)
18:51:14 <revenantphx> @where hpaste
18:51:14 <ddarius> edwardk: I recommend dreaming up a new method/formulation of integration to have your name ossified in the annals of mathematics.
18:51:14 <lambdabot> http://hpaste.org/
18:51:15 <roconnor> that's good!
18:51:25 <MrWish> I get this: baby.hs:50:0: parse error on input `|'
18:51:38 <revenantphx> I'm looking for something along those lines, but more haskelly (learning experience :P)
18:51:48 <azaq23> MrWish: You're indenting the guards (the |'s), right? Otherwise they will not be recognized as belong to the function.
18:51:49 <revenantphx> What needs to happen each step btw is:
18:51:59 <revenantphx> 1) All nodes must have their pheromone concentrations decayed
18:52:11 <revenantphx> 2) All ants must be moved (biased stochastic movement) around
18:52:11 <edwardk> ddarius: usually that requires deigning to publish something
18:52:21 <edwardk> at this point it has almost become a running gag that i haven't bothered ;)
18:52:22 <MrWish> indenting, what I should press tab on that line first or something?
18:52:25 <revenantphx> 3) Food must be enabled/disabled on some foods.
18:52:35 <revenantphx> MrWish: try pasting
18:52:40 <ddarius> edwardk: That's true.
18:52:44 <revenantphx> none of us can tell anything about the indentation like that.
18:52:50 <roconnor> revenantphx: Myself, I'd be inclined to use http://hackage.haskell.org/packages/archive/pointedlist/0.4.0/doc/html/Data-List-PointedList.html
18:53:16 <roconnor> revenantphx: in particular the contextMap function should be quite useful (and unfamiliar to you)
18:53:18 <ddarius> edwardk: You could keep this new integral in writings that you squirrel away only to be discovered upon your death, but then you'd need to be somewhat notable by some other means.
18:53:20 <edwardk> hrmm i should add a pointed list comonad ;)
18:53:40 <roconnor> revenantphx: contextMap takes a function that says how a single cell should update, and applies that everywhere!
18:53:47 <revenantphx> aaaah 
18:53:50 <azaq23> MrWish: Haskell uses spaces / tabs to group statements together. Those |'s are guards which belong to the definition of f. You need to have spaces or tabs before them so that the compiler knows that they belong to the definition of bmiTell
18:53:51 <roconnor> revenantphx: great for cellular automota like you are describing
18:53:51 <edwardk> my previous method of squirreling had been to hide stuff in category-extras ;)
18:53:51 <MrWish> if I copy paste straight from the page its on (http://learnyouahaskell.com/syntax-in-functions) I get:
18:53:53 <revenantphx> yeah I have something like that in my current attempt T_T
18:54:13 <revenantphx> its called pathMap and it maps a Cell -> Cell function to all cells in a path (ignoring specific ones)
18:54:20 <revenantphx> but it 
18:54:26 <revenantphx> roconnor: thanks I'll take a look :D
18:54:47 <ddarius> edwardk: The ideal situation is to be like Gauss and solve all of mathematics' problems but never tell anyone.
18:54:49 <roconnor> revenantphx: I helped jeffwheeler make that library, so if you have any questions about it I can probably help
18:54:59 <revenantphx> Ugh... cabal install failure
18:55:07 <m3ga> is there a tool to demangle names like ghczmprim_GHCziTypes_ZMZN_static_info?
18:55:21 <revenantphx> for fucks sake, it broke binary again
18:55:26 <MrWish> ok I will try indentation but I pasted the thing in the paste thing lol... how do I make it so you can find my paste?
18:55:28 <ddarius> preflex: zdec ghczmprim_GHCziTypes_ZMZN_static_info
18:55:28 <preflex>  ghc-prim_GHC.Types_[]_static_info
18:55:30 <revenantphx> now I have to reinstall everything that uses binary TT_TT
18:55:39 <edwardk> ddarius: hrmm. i'll chew on it for a while, but there are so many more of them these days that i'll definitely have to automate that task ;)
18:56:05 <ddarius> edwardk: Doron Zeilberger has a head start on you there.
18:56:22 <revenantphx> https://gist.github.com/767432
18:56:23 <MrWish> how do I refer you to my hpaste.org paste?
18:56:25 <revenantphx> roconnor: https://gist.github.com/767432
18:56:30 <aristid> preflex: zenc base_Data.Functor
18:56:31 <preflex>  basezuDataziFunctor
18:56:51 <edwardk> darius: sok, i'm better at doing derivative/spinoff work anyways. i appreciate the slingshot ;)
18:57:00 <aristid> is there any logic to zenc/zdec? :D
18:57:02 <m3ga> ddarius: thanks, but wherer to i get zenc and zdec?
18:57:03 <azaq23> MrWish you paste the link to which you're redirected after pasting, of course
18:57:09 <aristid> preflex: zdec basezuDataziFunctor
18:57:10 <preflex>  base_Data.Functor
18:57:23 <revenantphx> roconnor: where is it even getting set and get from 0.o
18:57:28 <aristid> preflex: zenc basezuDataziFunctor
18:57:29 <preflex>  basezzuDatazziFunctor
18:57:40 <edwardk> ddarius: did you see the callCV combinator i was kicking around yesterday?
18:57:46 <ddarius> No
18:57:49 <roconnor> revenantphx: possibly the fclabels depencency changes in a non-backwards compatiable way
18:57:53 * roconnor invesitgates
18:57:54 <edwardk> ddarius: give me uses for this:
18:57:58 <revenantphx> roconnor: go fix it >:D
18:58:11 <revenantphx> also I'm sick of "module Prelude is deprecated"... that needs to be fixed more >_>
18:58:22 <edwardk> https://github.com/ekmett/comonad-transformers/blob/master/Control/Comonad/Trans/Discont.hs
18:58:26 <edwardk> in particular, callCV
18:58:35 <azaq23> MrWish I found it already and, assuming the line numbers are not in the source file, this looks correct
18:58:49 <ddarius> preflex: zenc Î£ 
18:58:49 <preflex>  z3a3U
18:58:57 <MrWish> azaq23: thanks. but the problem seems to have been resolved, Im not gonna bother you with that
18:59:10 <revenantphx> roconnor: how exactly is having a focus useful for me here btw?
18:59:11 <roconnor> revenantphx: oh it uses template haskell
18:59:22 <mauke> preflex: zenc aristid!~quassel@menger.breitkreuz.me
18:59:23 <preflex>  aristidznz7eUquasselz40Umengerzibreitkreuzzzime
18:59:43 <humasect> educgeduacgodeucgaoeudhal`hurc
18:59:55 <roconnor> revenantphx: it gives you convienent getter and setter functions ... I'm almost tempted to tell you to comment it out, but wait
18:59:56 <edwardk> its a left kan extension of a constant functor, as cont is the right kan extension of a constant functor
19:00:10 <revenantphx> roconnor: go fix the pkg :P
19:00:15 <aristid> mauke: that made me feel slightly uncomfortable
19:00:34 <edwardk> it came up when i was working on splitting apart CostateT and what is now DiscontT (they are the same type, except when you expand them to transformers)
19:00:37 <roconnor> revenantphx: rename get to getL and set to setL
19:00:46 <mauke> aristid: why?
19:00:51 <mauke> preflex: ? .me
19:00:52 <preflex>  Montenegro
19:00:58 <MrWish> what is kan? 
19:00:59 <revenantphx> where is it cached again?
19:01:10 <azaq23> MrWish: Maybe you copied spaces but you're using tabs for indentation (or the other way round)? This causes problems sometimes and confounds the haskell parser; simply try to indent it yourself using your editor instead of copying
19:01:11 <edwardk> MrWish: main villain star trek ii
19:01:12 <aristid> mauke: because it includes my personal server in a publicly logged channel
19:01:21 * azaq23 khaaan?
19:01:59 <edwardk> daniel kan defined a way that functors could interact in category theory, turned out to be very useful for all sorts of seemingly unrelated stuff.
19:02:00 <mauke> aristid: uh, I see this information every time you join, part, quit, or I /whois you
19:02:18 <revenantphx> roconnor: one other issue
19:02:18 <revenantphx> https://gist.github.com/767440
19:02:19 <MrWish> yes eswardk that is khan or at least kahn, not sure.
19:02:39 <ddarius> aristid: That information is already there.
19:02:45 <revenantphx> fclabels changed it seems :3
19:03:01 <roconnor> delete the signature for focus
19:03:01 <geheimdienst> mauke, aristid, everyone gets that information, it's just that some clients don't show it
19:03:35 <revenantphx> and it works, hurray
19:03:43 <aristid> maybe i should get a cloak or however freenode calls it
19:03:45 <revenantphx> but now I can't give it to anyone and expect it to work for them :D
19:03:50 <aristid> haven't bothered so far
19:04:03 * roconnor wonders if he should patch PointedList to use the new fclables or simply put an upper bound on the acceptable version of fclabels (or both)
19:04:13 <revenantphx> fix it
19:04:16 <revenantphx> its a super easy fix
19:04:26 <revenantphx> total changes == 4 characters
19:04:32 <ddarius> aristid: http://tunes.org/~nef/logs/haskell/11.01.03 04:53:11,  and why get a cloak, the information is already logged and saved on the internet.
19:04:36 <revenantphx> add two 'L's and two '-'
19:04:39 * hackagebot Command 0.0.1 - A replacement for System.Exit and System.Process  http://hackage.haskell.org/package/Command-0.0.1 (TonyMorris)
19:04:50 <ddarius> You'll have to get a cloak and change computers and, to be safe, change nicks.
19:05:00 <ddarius> Alternatively, you could just become a different person.
19:05:02 <roconnor> revenantphx: I'll probably do both
19:05:17 <revenantphx> that wouldn't make sense though.
19:05:20 <revenantphx> if you put an upper bound and fix it
19:05:23 <revenantphx> then the old version will fail
19:05:25 <aristid> ddarius: i don't really see an acute danger or anything. it just made me feel uncomfortable
19:05:31 <roconnor> revenantphx: I mean make two uploads
19:05:35 <revenantphx> add an upper bound for the current version
19:05:41 <revenantphx> and fix it.
19:05:47 <ddarius> aristid: Then you'll never see it coming.
19:05:49 <roconnor> revenantphx: first add and upper bound and bump the minor revision
19:06:02 <aristid> ddarius: see what coming?
19:06:11 <roconnor> then fix it putting in a lower bound and bumping a major revision?
19:06:19 <roconnor> hmm
19:06:22 <revenantphx> 0.o
19:06:27 <revenantphx> I'm saying just do this:
19:06:34 <revenantphx> 1) Put the upper bound on fclabels to the current version
19:06:39 <revenantphx> 2) fix the mistakes
19:06:43 <revenantphx> 3) Increment version (somehow)
19:06:44 <roconnor> maybe I don't need to bump the major revision since there is no interface nor functionality change
19:06:48 <revenantphx> Agreed.
19:06:55 <roconnor> revenantphx: more or less
19:06:57 <revenantphx> so make it 0.4.1 and do what I mentioned above.
19:07:05 <revenantphx> so anyways, how is the focus useful to me?
19:07:14 <roconnor> revenantphx: except I cannot put an upperbound into the current version.  Once things are in hackage, they are immutable
19:07:39 <revenantphx> you cant change a dependency in a minor verson update
19:07:40 <revenantphx> ?
19:07:48 <roconnor> that I can do
19:07:50 <mauke> m3ga: http://mauke.dyndns.org/stuff/perl/zenc.pl
19:07:51 <roconnor> and will do
19:07:54 <revenantphx> kk.
19:08:03 <revenantphx> So... how is focus useful to me >_>?
19:08:06 <roconnor> revenantphx: anyhow, focus lets you get, set, and modify the cell in focus.
19:08:15 <roconnor> (all in constant time)
19:08:54 <roconnor> revenantphx: get will probably be the most relevent for you.
19:09:19 <mauke> this is actually incomplete; IIRC ghc has a special encoding for ()
19:09:21 <roconnor> you probably won't need to use set.
19:09:23 <m3ga> mauke: thanks!
19:09:27 <revenantphx> ...I'm not quite getting it :\
19:09:51 <roconnor> revenantphx: say you have a PointedList Cell right?
19:09:55 <revenantphx> sure.
19:10:01 <revenantphx> (I'll have two more likely though)
19:10:24 <roconnor> revenantphx: this *represents* (not is) a list of Cells, with one location highlighted
19:10:35 <revenantphx> Ok.
19:11:01 <revenantphx> (highlighted in a similar sense to the top node of a zipper?)
19:11:10 <roconnor> yes very similar
19:11:21 <m3ga> sorry mauke, Data.Munge? where do i find that?
19:11:31 <roconnor> (pointedList is implemented as a zipper)
19:11:52 <mauke> m3ga: like all perl modules on CPAN
19:12:10 <roconnor> anyhow, lets say myAnts :: PointedList Cells
19:12:12 <roconnor> anyhow, lets say myAnts :: PointedList Cell
19:12:16 <mauke> http://search.cpan.org/~mauke/Data-Munge-0.032/lib/Data/Munge.pm
19:12:45 <mauke> m3ga: if you don't care about getting perl modules installed, just copy/paste list2re from http://cpansearch.perl.org/src/MAUKE/Data-Munge-0.032/lib/Data/Munge.pm
19:12:50 <roconnor> revenantphx: then getL (focus myAnts) :: Cell is the value of the Cell that is highlighted
19:13:05 <revenantphx> k
19:13:37 <revenantphx> i get this, I'm just not seeing how it fits my problem exactly?...
19:13:51 <roconnor> sorry I got the code a bit wrong
19:13:56 <roconnor> revenantphx: then getL focus myAnts :: Cell is the value of the Cell that is highlighted
19:14:06 <revenantphx> right right.
19:14:33 <roconnor> setL focus myAnts newCell :: PointedList Cell is a new copy of the world, but now with the Cell set to a new value
19:14:38 <roconnor> *the cell in focus
19:14:45 <roconnor> but you probably won't use this function
19:15:06 <roconnor> revenantphx: contextMap is the source of awesomeness you want to harness
19:15:56 <revenantphx> alright, and how is that different from a normal map?
19:16:17 <revenantphx> hm, PointedList a -> b :\
19:16:39 <roconnor> revenantphx: because you can "see" the neighbouring cells.  This will help you move ants across cells.
19:17:05 <revenantphx> but then...
19:17:11 <roconnor> revenantphx: you will be using contextMap with type variables a and b set to Cell.
19:17:25 <revenantphx> will it have the "ant at n, moves to n+1, iterator goes to n+1, ant gets a second move" issue?
19:17:39 <revenantphx> And if not, I'm curious how :P
19:17:47 <roconnor> revenantphx: well perhaps I should have asked this first, do the ants move simultanously or one at a time?
19:17:54 <revenantphx> simultaneously
19:17:58 <roconnor> good
19:18:10 <roconnor> okay so this is what you do
19:18:25 <roconnor> you write a function updateAnts :: PointedList Cell -> Cell
19:18:32 <roconnor> what will this function do?
19:18:34 <roconnor> it will
19:18:51 <roconnor> be given the whole world with one cell highlighed
19:19:00 <aefjt> ghci runs out of memory evaluating: cmp x = \a b -> unsafePerformIO (modifyIORef x succ) `seq` compare a b; sortBy (cmp $ newIORef 0) [1..10000000]
19:19:08 <aefjt> Is it because the modify isn't strict enough?
19:19:15 <revenantphx> roconnor: I got that.
19:19:29 <roconnor> it's job is to figureout what the value for this this highlighed cell will be for the next turn
19:19:49 <revenantphx> oh I see.. it's not updating the cells next to it with ant movements...
19:19:53 <roconnor> to do this job, it will probably need to not only consider the highlighted cell, but it's neighbours as well
19:19:56 <revenantphx> but checking the neighbors to see how it will update...
19:20:01 <roconnor> right
19:20:02 <revenantphx> however, that raises an issue...
19:20:05 <roconnor> that's the key
19:20:18 <revenantphx> say you have [1][2][3][4][5] (cells)
19:20:33 <revenantphx> and 2 and 4 are both updated by this contextMap
19:20:40 <revenantphx> then you're giving ants in 3 two chances to move.
19:20:49 <revenantphx> (this is giving me an idea for a data structure to implement...)
19:21:58 <roconnor> no no
19:22:14 <roconnor> the update will all be done simulatnously
19:22:24 <m3ga> preflex: zdec DDCziVarziModuleId_zdfOrdModuleIdzucompare_info
19:22:25 <preflex>  DDC.Var.ModuleId_$fOrdModuleId_compare_info
19:22:32 <roconnor> so what contextMap does is the following
19:23:17 <revenantphx> it just fmaps underneath it seems
19:23:42 <roconnor> once you give it that update function it takes a world as the anothe argument and creates a big list of worlds that are all the same, except with the focus different, then it maps your given function over that huge list of worlds.
19:24:10 <roconnor> so if you give it (1)(2)[3](4)(5)
19:24:13 <roconnor> then it computs
19:24:28 <revenantphx> thats exactly the issue >_<
19:24:44 <revenantphx> If each cell is looking at its neighboring cells to determine which ants will move into itself...
19:24:52 <roconnor> question
19:24:56 <roconnor> is the movement deterministic?
19:25:02 <aefjt> zipWith3 update cells (lBorder : cells) (tail cells ++ rBorder) -- la la la
19:25:02 <revenantphx> no... its random :P
19:25:06 <roconnor> ah
19:25:08 <revenantphx> biased stochastic random walk
19:25:09 <roconnor> I see the problem
19:25:12 <revenantphx> mm
19:25:18 <revenantphx> so I'm thinking of a new data structure.
19:25:29 <revenantphx> well, a new way to work with this.
19:25:39 <revenantphx> I mentioned this before...
19:25:51 <revenantphx> basically I need to run through each cell, and collect the resultant changes... but NOT apply them.
19:25:57 <roconnor> yes
19:26:02 <revenantphx> So basically, accumulate a list of deltas
19:26:04 <revenantphx> and then apply all at once.
19:26:21 <roconnor> with a map (or mapM to sequence the randomess) to decide how they will move
19:26:26 <roconnor> and then contextMap to move them
19:26:47 <revenantphx> well if I'm doing that, there's no need for contextMap anymore.
19:26:58 <roconnor> so map will take you from pointedList Cell to pointedList (CellWithDecision)
19:27:05 <revenantphx> I can just map deltas onto the list producing a new one.
19:27:27 <roconnor> and then contextMap to take you from pointedList (CellWithDecision) to pointedList Cell
19:27:34 <aefjt> (But map doesn't provide the context!)
19:27:42 <revenantphx> one moment... I think I have an interesting idea.
19:27:45 <roconnor> revenantphx: I think you will need two steps
19:27:53 <revenantphx> roconnor: agreed.
19:28:06 <roconnor> and you need contextMap to move ants across cells
19:28:19 <mauke> preflex: zenc $s =~ s/($dere)|z([[:xdigit:]]+)U/defined $2 ? chr hex $2 : $dez{$1}/eg;
19:28:19 <preflex>  zdsz20Uzez7eUz20UszsZLzddereZRzbzzZLZMZMZCxdigitZCZNZNzpZRUzsdefinedz20Uzd2z20Uz3fUz20Uchrz20Uhexz20Uzd2z20UZCz20Uzddezzz7bUzd1z7dUzsegz3bU
19:28:25 <revenantphx> well no, that's not true.
19:28:29 <revenantphx> One moment.
19:28:32 <revenantphx> Let me draw something out.
19:28:33 <roconnor> ok
19:28:39 <revenantphx> trying to think if an idea would work...
19:29:24 <roconnor> oh nice PointedList is already Traversable
19:29:46 <roconnor> just what you need to randomly assign movements to the ants
19:30:20 <monochrom> preflex: zenc Î»Î±ÂµÎ²Î´Î±
19:30:21 <preflex>  z3bbUz3b1Uz0b5Uz3b2Uz3b4Uz3b1U
19:30:23 <deech> I was reading through "Purely Functional Data Structures" and there doesn't seem to be a Haskell version of the RealTimeQueue p.88. Do anyone know why?
19:30:24 <revenantphx> Any ideas on randomization btw?
19:31:31 <roconnor> revenantphx: yes 
19:31:34 <ian__> lol
19:31:39 <ian__> giu
19:32:00 <roconnor> revenantphx: let me show you a very simple ant world okay
19:32:21 <roconnor> data Cell = NumberOfAnts Integer
19:32:32 <roconnor> in my simple ant world, all a cell contains is a number of ants.
19:32:36 <roconnor> in that cell
19:32:38 <revenantphx> sure
19:32:42 <revenantphx> but remember
19:32:45 <roconnor> now each ant can move randomly left or right.
19:32:51 <revenantphx> ants are not just "there" or "not there"
19:33:02 <revenantphx> ants can have food or not, so they are somewhat distinguishable beyond quantity
19:33:44 <roconnor> revenantphx: yep, in a complex ant world Cell = Cell {numberOfAntsWIthFood :: Integer, numberOfAntsWithoutFoo :: Integer ... }
19:33:56 <roconnor> or whatever you need to represent what is going on in a cell
19:34:17 <roconnor> but let's go back to our simple ant world so you get the idea of what to do.
19:34:22 <roconnor> data Cell = NumberOfAnts Integer
19:34:26 <roconnor> now each ant can move randomly left or right.
19:34:42 <roconnor> so I'm going to make a new type representing that decision
19:35:40 <roconnor> data CellDecided = CellDecided {numberGoingLeft :: Integer; numberGoingRight :: Integer}
19:36:03 <roconnor> now we can write a procedure that randomly decides how each ant is going to move
19:36:15 <roconnor> randomWalk :: Cell -> IO CellDecided
19:37:05 <roconnor> we can "map" this randomWalk function over our entire world
19:37:24 <revenantphx> the basic gist of it is that the modifications made simultaneously to the entire world have to be composable and not interfere with eachother.
19:37:30 <revenantphx> (they're also monoidal :\)
19:37:33 <roconnor> everyoneDecide :: PointedList Cell -> IO (PointedList CellDecided)
19:37:42 <revenantphx> (which is something I want to try playing with here...)
19:38:09 <roconnor> everyoneDecide = Traversable.mapM randomWalk
19:38:20 <revenantphx> Has to be in the IO monad I guess :\
19:38:28 <revenantphx> To get randomness...
19:38:47 <roconnor> now once everyone has decided where to go, we need to move them
19:39:14 <roconnor> moveOneCell :: PointedList CellDecided -> Cell
19:39:30 <roconnor> this function will give the value of the highlighed cell on the next turn
19:39:36 <aristid> revenantphx: it could also be in a randomness monad.
19:39:42 <aristid> of which there are many
19:39:43 <revenantphx> aristid: IO is a bit more flexible
19:40:04 <aristid> duh, first you complain about IO and now you want the flexibility
19:40:17 <revenantphx> I wasnt complaining specifically about IO >-,
19:40:19 <revenantphx> >_<*
19:40:22 <aefjt> aristid: stupid type system!
19:40:26 <revenantphx> just saying it'd be cool to do it purely, though I cant
19:40:46 <aristid> revenantphx: using a randomness monad is pretty pure
19:40:57 <revenantphx> I'll go with IO anyways.
19:41:03 <revenantphx> since I'll need to be outputting logs to files
19:41:05 <roconnor> moveOneCell world = NumberOfAnts (numberGoingLeft (getL focus (next world)) + numberGoingRight (getL focus (previous world)))
19:41:06 <revenantphx> (to then plot)
19:41:21 <aefjt> You can log with the Writer monad...
19:41:33 <roconnor> so the value of the new cell is the number of ants going Left from the cell to the right + the number of ants going Right from the cell to the Left
19:41:53 <revenantphx> Pretty much :)
19:41:57 <roconnor> now we extend this moveOneCell function to the whole world
19:42:25 <roconnor> moveEveryone :: PointedList CellDecided -> PointedList Cell
19:42:41 <roconnor> moveEveryone = contextMap moveOneCell
19:42:54 <revenantphx> yeah
19:42:57 <revenantphx> similar idea to mine
19:43:04 <roconnor> finally we combine this with everyoneDecide to get one turn
19:43:08 <roconnor> yep
19:43:22 <roconnor> turn :: PointedList Cell -> IO (PointedList Cell)
19:43:27 <revenantphx> one moment I'm gonna go try to write something
19:43:46 <roconnor> turn world = moveEveryone `fmap` everyoneDecide world
19:44:06 <roconnor> Maybe there is a better way of solving your problem.
19:44:24 <roconnor> this is simply the first solution that comes to mind.
19:46:27 <roconnor> (there is a small cavet, next and previous actually return Maybe, so you have to handle the edge case there, which is pretty easy.
19:46:43 <roconnor> There are a couple of tweeks you can make to to this
19:47:07 <roconnor> maybe define type CellDecided = Either Cell Cell
19:47:19 <roconnor> er rather
19:47:45 <roconnor> maybe define type CellDecided = CellDecided {goingLeft :: Cell; goingRight :: Cell}
19:48:14 <roconnor> then writing an addCell function to add the contributions of the ants coming from the left and coming from the right
19:48:23 <roconnor> might as well make Cell a monoid while you are at it.
19:48:42 <revenantphx> Ok ok, I got it >_<
19:48:53 <revenantphx> I'm just going to try to implement it slightly differently as an experiment.
19:49:05 <roconnor> then moveOneCell world = goingLeft (getL focus (next world)) `mappend` goingRight (getL focus (previous world)))
19:49:07 <roconnor> okay
19:52:39 <ddarius> @free ((a -> X) -> X) -> a
19:52:39 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:53:00 <aefjt> I'd just write out the zipper: moveCell `mapM` zip cells (neighbours cells), or liftM (zip moveAnts cells . neighbours) (mapM decideAnts cells)
19:53:31 <aefjt> But PointedList handles unbounded worlds elegantly
19:53:43 <revenantphx> Note: world has finite size
19:53:46 <revenantphx> and always will
19:53:51 <roconnor> aefjt: and zip will chop of the ends of the world each step
19:54:20 <roconnor> aefjt: forget that
19:54:22 <roconnor> I'm wrong
19:54:44 <roconnor> aefjt: ya, your solution is better
19:54:47 <aefjt> neighbours has to patch in some boundary markers
19:54:54 <roconnor> er
19:54:58 <roconnor> aefjt: actually
19:55:00 <aefjt> But the problem's essentially the same as for yours
19:55:03 <roconnor> aefjt: it doesn't solve the problem
19:55:13 <roconnor> of stoping the same ant from moving in two directions (or no direction)
19:55:28 <roconnor> oh wait
19:55:32 <roconnor> it odes
19:55:35 <roconnor> using decideAnts
19:55:36 <revenantphx> ?...
19:55:37 <lambdabot> Not enough arguments to @.
19:55:38 <roconnor> heh
19:55:39 <roconnor> I suck
19:55:42 <aefjt> The second one does, yeah
19:55:48 * aefjt afk
19:56:13 <roconnor> aefjt: your solution is effective the same one.
19:56:35 <roconnor> as my suggestion
19:57:40 <edwardk> hrmm, is there a ComonadFix instance for the Monoid m => Comonad ((->)m) comonad?
19:57:49 * revenantphx is trying to decifer it >_>
19:57:55 <roconnor> O_o
19:58:11 <revenantphx> hm/
19:58:13 <revenantphx> ?
19:58:30 <edwardk> roconnor: starting from class Comonad w => ComonadFix w where cofix :: w (w a -> a) -> a
19:58:45 <roconnor> @type mfix
19:58:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
19:58:54 * hackagebot pointedlist 0.4.0.1 - A zipper-like comonad which works as a list, tracking a position.  http://hackage.haskell.org/package/pointedlist-0.4.0.1 (RussellOConnor)
19:59:00 <edwardk> example: instance ComonadFix ((,)e) where cofix ~(e, f) = x where x = f (e, x)
19:59:08 <duairc> If you something like (length "hello") in a program that has OverloadedStrings enabled, it will fail because [a] is not an instance of IsString
19:59:11 <edwardk> make both kleisli arrows in that cokleisli
19:59:20 <edwardk> and you get the cofix definition i'm using
19:59:27 <edwardk> w (w a -> a) -> a
20:00:25 <revenantphx> Well I have to go, so I'll finish this later
20:00:29 <revenantphx> thanks roconnor and aefjt
20:01:53 <roconnor> see ya
20:02:47 <roconnor> why does everyone use fclabels over data-accessor?
20:03:11 <roconnor> I think data-accessor has more functionality
20:03:23 <aavogt> naming conventions
20:03:33 <roconnor> maybe
20:04:04 <aavogt> data-accessor was on hackage earlier
20:04:15 <edwardk> i don't use data-accessor because henning-effect
20:04:24 <roconnor> what effect is that?
20:04:25 <edwardk> er because of the henning effect
20:04:36 <edwardk> unreadable documentations caused by naming everything T and C
20:04:36 <roconnor> I mean what effect does henning have?
20:04:46 <roconnor> hmm
20:04:54 <edwardk> http://hackage.haskell.org/packages/archive/data-accessor/0.2.1.5/doc/html/Data-Accessor-Basic.html
20:05:04 <edwardk> i can never tell which of his Ts or Cs he means
20:05:13 <aavogt> can he?
20:05:22 <edwardk> can't tell =)
20:05:50 <edwardk> i ported fclabels over to scala and have been happily using it ever since
20:06:02 <aavogt> roconnor: also template-haskell stuff is in a different package for data-accessor
20:06:18 <edwardk> (it is even a bit nicer to use than in haskell because you can use them direction as State actions)
20:06:21 <roconnor> aavogt: which is sort of good
20:06:27 <duairc> Argh why would somebody do that :( (the T and C thing)
20:07:21 <aavogt> duairc: modula 3 maybe?
20:08:39 <aavogt> edwardk: what do you mean by   "use them direction as State actions"?
20:08:49 <edwardk> directly
20:09:15 <edwardk> for { x <- foo; _ <- foo := 12 } yield { â€¦ }
20:09:44 <edwardk> foo is a lens being used as a state monadic action that accesses its field in the state of the current monad
20:10:14 <edwardk> and some sickeningly sweet sugar lets you use them like mutable variables. foo += 12; etc
20:10:24 <aavogt> that's done with an implicit?
20:11:02 <edwardk> yeah, since scalaz has been fairly anti-subtyping prior to my arrival on the scene, so State is currently declared final.
20:11:32 <edwardk> https://github.com/ekmett/scalaz/blob/master/core/src/main/scala/scalaz/Lens.scala
20:11:33 <aavogt> I don't follow why it isn't possible in haskell (though it may not be sensible, considering the type errors and annotations sometimes needed)
20:11:38 * aavogt looks
20:12:11 <edwardk> the := is possible in haskell.
20:12:21 <edwardk> in fact i think that was where i stole the inspiration
20:12:57 <aavogt> well the colon is awkward as it must be a constructor
20:13:21 <edwardk> for the most part my scala lenses try to make a lens to an immutable structure look like a mutable one
20:14:08 <edwardk> x += (key -> value) â€” when x is a lens referencing a set, etc.
20:14:58 <edwardk> or x.contains(key) when x is a lens to a set returns a lens to a boolean that when set or unset adds or removes that member to the set
20:15:04 <roconnor> edwardk: isn't making lenses interface with the state monad exactly what data.accessor does that fclabels doesn't?
20:15:10 <ivanm> edwardk: what do you use scala for? becaues you need java interop?
20:15:31 <roconnor> damn you ghc-pkg
20:15:41 <ivanm> roconnor: what now?
20:15:43 <edwardk> ivanm: subverting and converting a much larger codebase to functional code
20:15:48 <ivanm> ahhh
20:16:06 <ivanm> edwardk: so, more a lesser of evils rather than choice?
20:16:15 <edwardk> ivanm: pays better than haskell atm ;)
20:16:30 <roconnor> ivanm: I have this problem that when I runSetup install --user I get errors like:
20:16:32 <ivanm> :(
20:16:44 * edwardk is a language slut ;)
20:17:03 <roconnor> Setup.lhs: fclabels-0.11.1.1: dependency
20:17:05 <roconnor> "mtl-1.1.0.2-336254fecf8a77054f76cb33671a5177" doesn't exist (use --force to
20:17:06 <roconnor> override)
20:17:14 <shepheb> edwardk: no, a whore. it's about the money.
20:17:15 <roconnor> even though ghc-pkg list shows that it exists
20:17:19 <ivanm> roconnor: you upgraded mtl and so now fclabels is broken
20:17:22 <edwardk> cofix w = extract w (extend cofix w) should serve as a passable default definition for comonadfix
20:17:27 <ivanm> roconnor: that exact version with that hash?
20:17:31 <ivanm> roconnor: ghc-pkg check
20:17:48 <edwardk> now, the question is is there any case that is sufficiently better than that to justify not using it universally
20:18:15 <roconnor> ivanm: it lists a bunch of broken packages, none of which are mtl
20:18:42 <roconnor> oh wait
20:18:44 <roconnor> where is the mtl?
20:18:47 <ivanm> roconnor: no, they would include packages that depended on mtl, etc.
20:18:50 <ivanm> ghc-pkg list mtl
20:18:57 <roconnor> why didn't cabal configure catch this.
20:19:25 <ivanm> roconnor: ghc-pkg field mtl id
20:19:40 <ivanm> will be a different hash than the one they're expecting
20:19:42 <roconnor> $ ghc-pkg field mtl id
20:19:43 <roconnor> id: mtl-1.1.0.2-336254fecf8a77054f76cb33671a5177
20:19:44 <roconnor> id: mtl-1.1.0.2-336254fecf8a77054f76cb33671a5177
20:19:52 <ivanm> but yeah, cabal configure normally bitches about this kind of thing :/
20:20:03 * hackagebot xss-sanitize 0.2.5 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.2.5 (GregWeber)
20:20:04 <ivanm> roconnor: :o looks the same :/
20:20:10 <ivanm> (as the one that it can't find)
20:20:15 <roconnor> ya I had this problem before
20:20:27 <roconnor> I managed to use --force by hand before but I can't figure out how I did that
20:21:52 <roconnor> not that I understand why this problem happens
20:22:41 <roconnor> wait how does cabal call ghc-pkg?
20:22:50 <roconnor> ivanm: are you a cabal developer?
20:23:50 * roconnor bet he knows what the problem is
20:25:23 <edwardk> there has to be a nice way to define: cotraverse :: (Comonad w, Traversable f) => (w a -> b) -> w (f a) -> f b
20:25:50 <edwardk> or mapW i guess it would be
20:25:53 <roconnor> using cosequence
20:26:01 <edwardk> what was cosequence again?
20:26:10 <roconnor> not general enough
20:26:13 <edwardk> you pasted it before but i got pulled away
20:26:18 <roconnor> it was only for streams
20:26:55 <edwardk> i can make a typeclass up, but i'm not sure too many folks will get around to implementing Cotraversable ;)
20:27:10 <roconnor> edwardk: cotraverse is a class method.  What implementation are you expecting?
20:27:37 <edwardk> analogous to the definition of mapW with cokleisli actions
20:29:36 <edwardk> i'd expect i can do the same for parallelW as well
20:30:33 <edwardk> which is just mapW id
20:30:39 <ivanm> roconnor: nope, I'm not
20:30:45 <ivanm> (a cabal developer)
20:30:57 <roconnor> edwardk: cotraverse f = cosequenceA . fmap f ?
20:31:39 <edwardk> so class Cotraversable f where mapW :: Comonad w => (w a -> b) -> w (f a) -> f b; parallelW :: Comonad w => w (f a) -> f (w b)
20:32:08 <edwardk> cosequenceA was what again?
20:32:57 <roconnor>  sequenceA :: CoApplicative f => f (t a) -> t (f a)  ???
20:33:00 * roconnor has no idea
20:33:00 <copumpkin> > transpose [[1,2,3], [5,6,7], [4,5,6]]
20:33:02 <lambdabot>   [[1,5,4],[2,6,5],[3,7,6]]
20:33:11 <copumpkin> > Data.Traversable.traverse id [[1,2,3], [5,6,7], [4,5,6]]
20:33:12 <lambdabot>   [[1,5,4],[1,5,5],[1,5,6],[1,6,4],[1,6,5],[1,6,6],[1,7,4],[1,7,5],[1,7,6],[2...
20:33:29 <edwardk> ah, it'd be parallelW and mapW. there is no coapplicative to speak of
20:33:35 <edwardk> (since we don't have coexponentials)
20:33:35 <copumpkin> > Data.Traversable.traverse id (map ZipList [[1,2,3], [5,6,7], [4,5,6]])
20:33:36 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList [a]))
20:33:36 <lambdabot>    arisin...
20:33:43 <copumpkin> > runZipList $ Data.Traversable.traverse id (map ZipList [[1,2,3], [5,6,7], [4,5,6]])
20:33:44 <lambdabot>   Not in scope: `runZipList'
20:33:49 <roconnor> :|
20:33:52 <copumpkin> ugh
20:34:12 <roconnor> no coexponential means no cotraversable as such right?
20:34:28 <copumpkin> > getZipList $ Data.Traversable.traverse id (map ZipList [[1,2,3], [5,6,7], [4,5,6]])
20:34:29 <lambdabot>   [[1,5,4],[2,6,5],[3,7,6]]
20:34:34 <edwardk> no cotraverse, but the comonadic analogue of the monadic ones are there
20:34:36 <copumpkin> yay
20:34:44 <edwardk> mapM, sequence, etc.
20:34:46 <roconnor> yes
20:34:51 <roconnor> so mapW and cosequence
20:34:59 <roconnor> which is mapW id
20:35:08 <roconnor> I presume
20:35:19 <edwardk> well, if we take the old old category-extras definitions there are 3
20:35:58 <roconnor> and mapW f = sequence . map f
20:35:58 <edwardk> mapW :: (w a -> b) -> w [a] -> [b]   â€” parallelW :: w [a] -> [w a] â€” sequenceW :: [w a -> b] -> w a -> [b]
20:36:04 <copumpkin> @let zomg = getZipList . Data.Traversable.traverse ZipList
20:36:05 <lambdabot>  Defined.
20:36:18 <copumpkin> > zomg [[1,2,3],[4,5,6],[7,8,9]]
20:36:20 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
20:36:27 <roconnor> parallelW = cosequence
20:36:29 <copumpkin> that is quite elegant indeed
20:36:34 <edwardk> yeah
20:36:38 <aavogt> > transpose []
20:36:39 <lambdabot>   []
20:36:52 <roconnor> that sequenceW seems surprising
20:36:56 <roconnor> where is parallelM?
20:37:39 <edwardk> [a -> m b] -> a -> m [b] ?
20:37:58 <roconnor> isn't that just sequence . sequence?
20:38:04 <roconnor> @type sequence . sequence
20:38:05 <lambdabot> forall a. [[a]] -> [[a]]
20:38:21 <roconnor> er
20:38:47 <roconnor> @type sequence
20:38:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:38:54 <edwardk> its just \xs a -> map ($a) xs isn't it?
20:39:11 <edwardk> ok, that one is boring =)
20:39:17 <edwardk> not sure why its there
20:39:20 <edwardk> killing it
20:39:20 <roconnor> @type \l a -> sequence (sequence l a)
20:39:21 <lambdabot> forall t (m :: * -> *) a. (Monad ((->) t), Monad m) => [t -> m a] -> t -> m [a]
20:39:37 <roconnor> @type ((sequence .).)
20:39:38 <lambdabot> forall (m :: * -> *) a (f :: * -> *) (f1 :: * -> *). (Monad m, Functor f, Functor f1) => f1 (f [m a]) -> f1 (f (m [a]))
20:39:42 <edwardk> sequenceW xs w = fmap ($w) xs
20:40:17 <edwardk> mapW and cosequence are the interesting ones
20:41:30 <roconnor> yes
20:41:47 * roconnor is sad there is no coapplicative
20:42:17 <edwardk> i'm not
20:42:24 <edwardk> if there was, then haskell would be a poset.
20:42:38 <edwardk> kinda boring to program in with only one function between any two types ;)
20:43:07 <aefjt> Not if that function is dwiw
20:43:53 <edwardk> now to make a class (Functor f, Foldable f) => Cotraversable f where â€¦
20:44:07 <aefjt> do x <- newIORef 0; replicateM_ (10^8) (modifyIORef x succ); runs out of memory in ghci; is it really not strict enough?
20:44:10 <edwardk> and build foldMapDefault and fmapDefault for it
20:45:42 <roconnor> @hoogle rawSystem
20:45:42 <lambdabot> No results found
20:46:31 <edwardk> hrmm i wonder if forW makes more sense with: forW :: (Cotraversable t, Comonad w) => t a -> w (a -> m b) -> t b â€” so that the result of partially applying it is a cokleisli arrow
20:46:54 <edwardk> er
20:47:02 <edwardk> t a -> w (w a -> b) -> t b
20:48:03 <roconnor> hmm, what I thought was wrong with cabal isn't a problem 
20:48:15 <roconnor> so now I don't know what is causing this error
20:51:09 <aefjt> Compiling it with -O2 doesn't work either
20:52:17 <BMeph> edwardk: Can loeb be written with cFix?
20:52:17 <ddarius> aefjt: Why do you think it is strict at all?
20:53:22 <edwardk> bmeph: hrmm
20:53:52 <aefjt> Well, using (succ $!) also fails, ddarius
20:53:58 <edwardk> well: extend cofix has the signature of loeb
20:54:02 <edwardk> not sure about the semantics
20:54:07 <aefjt> I can't see how that one isn't strict enough
20:54:12 <ddarius> aefjt: Which is completely expected as succ is already strict.
20:54:29 <ddarius> aefjt: Again, why do you think it is strict -at all-?
20:54:38 <edwardk> actually that looks like exactly the same semantics
20:54:56 <aefjt> ddarius, you mean modifyIORef, then?
20:55:01 <edwardk> extend cofix = loeb for a comonad
20:55:09 <edwardk> (its just a more limited type
20:56:46 <aefjt> I would think that it should be strict, since I can't think of any way to strictify it if it isn't
20:57:40 <ddarius> aefjt: modifyIORef isn't strict and arguably that's a mistake, but not because you can't "strictify" it, but because it's rarely what one wants.
20:58:19 <ddarius> You can easily force the IORef before or after, or, even more easily simply write out the strict version.
20:58:42 <ddarius> It's only two lines of code assuming you take the sparser route.
20:59:37 <aefjt> Okay, I see
21:00:28 <aefjt> (I don't see the usefulness of a non-strict modify, but that's another thing)
21:02:12 <ddarius> aefjt: It's more defined and it works completely fine if the function passed into it is lazy, but yes, as I said, it not usually want you want.
21:08:27 <edwardk> hrmm i'm not entirely sure the existing mapW is sound
21:09:05 <edwardk> mapW :: Comonad w => (w a -> b) -> w (t a) -> t b â€” the guts of it seem to require (unless i'm mistaken) that all of the lists be the same length
21:10:26 <edwardk> if you have a w [a] where an item that isn't at the focus has length shorter than the focus, then the mapW f w | null (extract w) = [] â€” check will succeed, but the | otherwise f (head <$> w) : â€¦ stuff will take the head of any empty list
21:11:08 <edwardk> so i'm not sure they are 'good' combinators
21:11:27 <dolio> You could just try it with such a value.
21:11:38 <dolio> I'm sure the answer will be better than the one you get here.
21:13:11 <aefjt> Hrm, writeIORef doesn't seem to be strict either. But I found a modifyIORef' on cafe
21:15:09 <edwardk> boom
21:15:12 <edwardk> it blows up
21:15:32 <edwardk> @hpaste
21:15:33 <lambdabot> Haskell pastebin: http://hpaste.org/
21:16:08 <edwardk> http://hpaste.org/paste/42790/mapwparallel_unsound_annotat#p42791
21:16:56 <edwardk> dolio: look bad to you? =)
21:17:15 <edwardk> at least i don't have to implement Cotraversable now ;)
21:17:58 <edwardk> i could however flip it around a bit and make a valid forW though
21:18:09 <edwardk> forW :: t a -> w (w a -> b) -> t b
21:18:09 <dolio> Yeah. And I'm not surprised. Just channeling monochrom.
21:18:34 <edwardk> that should be sound, since i don't need to traverse a container held in the comonad
21:18:42 <edwardk> er traverse n containers held in one
21:19:16 <dolio> What is that one going to do?
21:19:34 <edwardk> not sure, it just doesn't fail for the same reasons =)
21:19:53 <edwardk> when you extend that you should get a w (t b)
21:19:55 <dolio> I mean, it has to get the as into a w somehow.
21:20:00 <dolio> But what context?
21:20:13 <edwardk> that it can do it'll take the one outside of the w (w a -> b)
21:20:15 <dolio> The one from the function?
21:20:18 <edwardk> yeah
21:20:24 <edwardk> didn't say it was useful
21:20:27 <edwardk> =)
21:20:41 <edwardk> but i have a few of those w (w a -> b) shaped things floating around
21:20:46 <edwardk> cofix, etc.
21:21:12 <edwardk> and that callCV thing i'm trying to make heads or tails out of
21:22:36 <dolio> V stands for value?
21:22:50 <edwardk> yeah
21:23:34 <edwardk> i was going to go try and hack through some stock callcc examples and see what can survive the translation
21:23:44 <edwardk> but iv'e been buried in other parts
21:30:18 <edwardk> at least i don't have to worry about somebody wanting a comonad fail ;)
21:30:47 <c_wraith> hey, with this special comonad syntax, what are we gonna do when a pattern match fails? :P
21:31:06 <edwardk> =)
21:31:32 <edwardk> i'm going through and killing more functions than i'm writing these days
21:31:33 <dolio> cofail :: w a -> String
21:31:45 <dolio> cofail _ = "lolwat"
21:31:52 <edwardk> hrmm. <$ subsumes the .>>
21:32:11 <edwardk> which has an inefficient implementation anywyas
21:32:16 <edwardk> since it could just map
21:36:39 <edwardk> cofail is like a bizarre form of show =)
21:37:16 <edwardk> meh, forW, etc. are pointless
21:37:23 <alexbobP> go4dividee?
21:37:28 <alexbobP> whoops
21:37:32 <alexbobP> wrong window --
21:37:33 <edwardk> and with .>> gone, the world is shrinking
21:38:52 <edwardk> though <$ has the wrong fixity/precedence
21:51:20 <Berengal> http://hpaste.org/42792/stm <- This exhibits some weird performance behaviour
21:51:52 <Berengal> When compiled without -threaded it's really slow compared to with -threaded
21:52:18 <Berengal> Regardless of how many native threads I actually use
21:53:32 <Berengal> And regardless of optimization level
21:55:00 <Zeiris> Are there any Haskell bindings/libraries for HTTP load testing/traffic generation? :)
21:55:39 <lispy_> Zeiris: I think so...but I can't actually think of what it's called
21:55:45 <lispy_> Zeiris: did you check hackage?
21:56:03 <Zeiris> Nothing that struck out.
21:56:08 <Zeiris> Or stuck out.
21:56:20 <lispy_> Zeiris: http://osdir.com/ml/haskell-cafe@haskell.org/2010-11/msg00989.html
21:57:01 <lispy_> Zeiris: guess not.  Both replies to that thread recommend tools in other languages
21:57:41 <Zeiris> Most of the tools involve a command line call + regexable output.
21:58:18 <Zeiris> I can probably write that, just wanted to see if I could avoid the mess. I'm sure I'll get guilted into learning UU-parsec or something and using that instead of regexen, and I want to do this quick :p
21:59:31 <ajnsit> is hackage down?
21:59:39 <Zeiris> Just used it.
21:59:47 <lispy_> ajnsit: no
22:00:00 <ajnsit> ah it works now must have been a temp glitch
22:14:02 <jdavis> if I'm pattern matching, and one pattern ends up being a long list ORed together like "A | B | D | G | N -> ...", is there a good way to separate that out? Like give a name to the pattern?
22:14:13 <lispy_> edwardk: cofail = show, is an interesting idea
22:15:08 <lispy_> :t (||)
22:15:09 <lambdabot> Bool -> Bool -> Bool
22:15:18 <Colours> hey do all functions have a fixed point
22:15:18 <lispy_> jdavis: is that what you meant?  || instead of | ?
22:15:39 <Colours> well all integral functions
22:15:52 <jdavis> lispy_: I am refering to algebraic pattern matching, and was using OR a little loosely.
22:17:22 <jdavis> lispy_: and maybe the components aren't simple constructors, but perhaps they are more like "A (Foo x) | B (Bar (Baz x) | ... -> ..."
22:17:24 <copumpkin> Colours: no
22:17:49 <Colours> oh I see
22:19:00 <lispy_> > case 1 of 1 | 2 | 3 -> 4
22:19:01 <lambdabot>   <no location info>: parse error on input `|'
22:19:25 <lispy_> jdavis: I still don't understand the question :(
22:22:24 <jdavis> lispy_: I think I was moving back and forth between OCaml and haskell today, sorry (trying to learn them both). Is there a way to do something similar to that in haskell?
22:24:49 <jdavis> or do you always have to do something like: case 1 of 1 -> 1 ; 2 -> 1 ; 3 -> 1;
22:25:11 <Makoryu> jdavis: I think there's an extension for that
22:25:11 <joe6> which is the best tutorial or module to use prettyprinting?
22:25:12 <jdavis> lispy_: I guess I'm thinking of something like C's "fall-through" behavior for case
22:25:14 <lispy_> jdavis: we would write a predicate and then use guards
22:25:16 <Makoryu> But I don't remember what it is
22:25:33 <jdavis> lispy_: ok, I'll look into that.
22:25:51 <joe6> Text.PrettyPrint?
22:25:51 <lispy_> jdavis: if want fall through, we use the wild card _ in the pattern
22:26:44 <lispy_> > case 5 of 1 -> 1 | 2 -> 2 | x -> x
22:26:45 <lambdabot>   <no location info>: parse error on input `|'
22:27:02 <lispy_> > case 5 of 1 -> 1 ; 2 -> 2 ; x -> x
22:27:04 <lambdabot>   5
22:27:08 <lispy_> jdavis: ^^
22:29:31 <jdavis> lispy_: oh, guards work perfectly, thanks!
22:37:34 <joe6> does anyone how to use the module "pretty" . it appears that the default function of prettyPrint is contained in it.
22:43:07 <lispy_> Sorry joe6, never used it.
22:43:28 <lispy_> documentation is often a weak point in libraries
22:47:28 <ajnsit> is there a serialisation library for haskell that preserves shared data?
22:48:26 <ajnsit> and maybe can store infinite data structures like x=1:x
22:48:45 <Makoryu> That would be a fascinating project to work on
22:48:56 <Makoryu> I can't imagine such a library already exists
22:49:49 <ajnsit> well thinking about it, given referential transparency, how would a serialise function even know if something is shared?
22:49:59 <Makoryu> Exactly
22:50:21 <ajnsit> maybe a library can be told explicitly that something is shared
22:50:32 <Makoryu> The amount of runtime introspection involved would be utterly dickbees
22:50:36 <dolio> It wouldn't. It'd need to use magic.
22:51:39 <Makoryu> Alternatively you could include some kind of portable executable bytecode for pure functions in this format
22:52:03 <Makoryu> And write macros to generate bytecode from stuff that only *looks* like executable Haskell
22:52:11 <Makoryu> Templates, I mean
22:52:34 <ajnsit> Makoryu, is there some kind of work already done for serialising functions?
22:52:45 <Makoryu> ajnsit: In Haskell? I don't think so
22:53:05 <Makoryu> In Erlang you could write this overnight
22:53:15 <Makoryu> And maybe some dialects of Lisp
22:53:49 <ajnsit> Makoryu,  in lisp it would be a cakewalk
22:54:11 <dolio> Alice ML is built around serializing functions and entire modules.
22:55:16 <Makoryu> ajnsit: In Common Lisp you'd have a buttload of portability issues and weird corner cases with name resolution, so I hesitate to agree ;)
22:55:28 <Makoryu> ajnsit: But in Scheme, and Clojure... probably, yeah
22:58:00 <ajnsit> okay I found this on hackage - RefSerialize
22:58:10 <ajnsit> allows you to do this -
22:58:16 <ajnsit> Data.RefSerialize>runW $ rshowp [x,x] >>>     v9 where {v6= 5; v9= [ v6, v6]; }
22:58:56 <ajnsit> how is this library able to detect shared structures?
22:58:59 <ajnsit> http://hackage.haskell.org/packages/archive/RefSerialize/0.2.7/doc/html/Data-RefSerialize.html
22:59:06 <Makoryu> Hax
22:59:51 <ajnsit> Makoryu, Hax?
22:59:56 <Makoryu> Yes
22:59:59 <Makoryu> Major hax
23:00:11 <ajnsit> ah
23:01:30 <c_wraith> wow, that lib uses unsafeCoerce.  I wonder what it's doing
23:02:11 <Makoryu> ^ Told you. Hax.
23:02:22 <Makoryu>  â”(ã€€Â´ã€°`)â”Œ 
23:04:15 <edwardk> aha ComonadZip gives me ap-like and <* and >* like operators
23:04:23 <edwardk> er *> and <*
23:20:41 <j-invariant> So I just discovered the Implicit Configurations uses unsafePerformIO
23:21:28 <j-invariant> buut there doens't seem to be any way to write my code without it
23:22:48 <j-invariant> that's what I don't get: How do you deal with this stuff
23:27:07 <mafs> Using Text.JSON for this, how could I get the inference to work properly on this? http://codepad.org/RhzI1baD Assuming well-formed data, if kind is "point" then coordinates in the JSON will be [Double] and likewise with polygon, except [[[Double]]]
23:27:41 <mafs> It works fine if I do *just* point or *just* polygon in the case, but not both (and this example is simplified, there's more than just Point or Polygon)
23:34:59 <j-invariant> http://codepad.org/18pFG7vJ
23:35:55 <mafs> I was suspecting I'd have to do something like that, but hoping not, mainly because it would be kind of ick to repeat that 6 times
23:38:15 <mafs> (but thank you! I'll play with that at least and see if there's any simplification from there)
23:39:45 <j-invariant> mafs: something like this might work http://codepad.org/kSJyhPFq
23:46:08 <mafs> j-invariant: Aha, thank you. That works a bit more nicely. Though, geo wasn't in scope in the where close, so I had to add that as an argument
23:51:51 <lispy_> j-invariant: implicit configurations uses unsafePerformIO in a completely safe way
23:52:23 <lispy_> j-invariant: The oleg paper explains how/why.
23:56:19 <j-invariant> is there a theory for proving unsafePerformIO is safe?
23:56:53 <banisterfiend> j-invariant: what do u mean by a theory?
23:58:05 <c_wraith> j-invariant, formally?  Not that I'm aware of.  Informally, it comes down to "could what you're doing be done with only pure functions, even if possibly in a less efficient manner?"
