00:01:23 <cads> wow, that might work with one person
00:01:53 <flamingspinach> as in, you just thought of someone who that would work on? :) or, you doubt it would work on more than one person in the world? :(
00:02:13 <cads> sorry, one person that I know
00:02:22 <cads> :_)
00:02:29 <dolio> Ask them if they prefer Hilbert systems, natural deduction, or sequent calculus.
00:03:00 <flamingspinach> honestly, I'm the kind of person that would work on. I have no idea how the "by a compactness argument" hand-wave works :P
00:03:05 <flamingspinach> can anyone recommend a good book to read?
00:03:29 <dolio> Mathematical Handwaving for Dummies.
00:03:50 <cads> I was actually wondering if there was a branch of proof theory that encapsulates the patterns of proofs of various things in analysis and topology specifically, so that you could remember those things better
00:04:16 <cads> and so that a student equipped with some of those tools could use them to recognize patterns they've seen and used before
00:04:17 <colah> Another question: Is it possible to implement function classes? For example, I'd like to turn implement classes of integrable functions and then turn the into an inner product space via L2.
00:04:44 <cads> it should also work with other theories
00:05:22 <colah> I realise that I could do something like data Cont = C a -> b but then I brake compatability with everything else and every function needs to get turned into a type.
00:05:40 <cads> so that a student could see analogies between early theorems s/he learned and theorems in new topics of study
00:06:42 <cads> colah, you want integrable functions to do what with other functions?
00:07:54 <cads> compose with them properly?
00:09:15 <colah> cads: Well, I'd like to have an integral operator and then extend my InnerProductSpace class using the L2 norm. And once I figure out how I'm going to work around num I'll add addition. I'll also implement convolution with the star operator and so on.
00:09:24 <cads> you'd want to implement your own function typeclass hierarchy, I think
00:09:43 <colah> Can I do that without having to wrap every function?
00:09:53 <cads> and you might have to wrap it :P
00:10:13 * colah sighs
00:11:24 <colah> Well, that solves the problem of how to determine the integral domain for norm and convolutiion, at least.
00:11:43 <djahandarie> flamingspinach, hm, wouldn't each vertex in that tree need to have infinite incoming edges due to the generating set being infinite?
00:12:00 <flamingspinach> not at all. Not every number is divisible by all primes :)
00:12:13 <flamingspinach> every vertex does have infinite outgoing edges, though!
00:12:21 <flamingspinach> this is depicted in augur's image as "..."
00:12:44 <djahandarie> I thought given the generating set S with k elements, every vertex needs to have k incoming and k outgoing edges?
00:12:49 <cads> colah, that might be as simple as saying eval f a b, compose f g, add f g, l2 f, etc, etc.
00:13:19 <flamingspinach> djahandarie: if it's a group, yes. Monoid elements don't have inverses, so there are no "backwards" arrows.
00:13:23 <cads> colah, there might be ways of getting around it - I'm not an expert
00:14:05 <djahandarie> Hmmmm
00:14:24 <flamingspinach> well, they don't necessarily have inverses, anyway. :) In free monoids and free commutative monoids there are definitely no inverses whatsoever, though
00:14:38 <djahandarie> I have no idea how you observed all this in like one second looking at that tree though :P
00:14:40 <flamingspinach> well, other than the identity being its own inverse
00:14:50 <flamingspinach> I didn't - it's just something I know about the natural numbers
00:14:55 <flamingspinach> in particular, the fundamental theorem of arithmetic
00:14:59 <augur> wow, still talking about this tree ey
00:15:00 <djahandarie> Right, I know that
00:15:14 <djahandarie> augur, sorry, got me interested a little :P
00:15:16 <augur> :)
00:15:18 <augur> good!
00:15:30 <flamingspinach> and when I looked at the tree I saw that it was organized by prime factorization, and each edge represented multiplication by a prime number
00:15:43 <Saizan> colah: you surely can make instances like e.g. instance Num b => Num (a -> b) where ..
00:16:14 <Saizan> colah: so if what you want can be done without wrappings depends on the details
00:16:33 <djahandarie> I see how it connects now, but I don't think I would have been able to notice that lol
00:16:47 <flamingspinach> well, what I first "noticed" was actually wrong :)
00:17:00 <Saizan> colah: (->) is just a type constructor like any other here
00:17:07 <flamingspinach> it's not the cayley graph, since the graph has the path "1 -> 2 -> 2*3" but not "1 -> 3 -> 3*2"
00:17:24 <flamingspinach> the edges of those paths are "2 3" and "3 2" respectively
00:17:40 <flamingspinach> the first is monotonically increasing, the second is not - the first is in augur's tree, the second is not
00:18:49 <augur> hmm
00:19:18 <j-invariant> how do you prove that polymorphism functions in haskell are noatural transofrmations?
00:19:34 <augur> so about that idea earlier where you have definitions like    xs !! i = f (ys !! i)
00:20:00 <augur> obviously you'd want this to work regardless of how you access xs, whether through (!!) or not
00:20:28 <augur> you could ofcourse translate all such things into fmaps, but thats no fun
00:21:22 <augur> surely what you'd want is to be able to treat xs !! i as a structured pattern thing, and then to be able to translate head/tail into it
00:21:33 <augur> something like zippers i think
00:21:41 <j-invariant> why augur 
00:21:47 <augur> j-invariant: for fun, ofcourse!
00:21:54 <j-invariant> it don#t sound much fun :/
00:21:58 <augur> as an exercise in different computations
00:22:08 <augur> like
00:22:15 <j-invariant> augur: d'o you know Yoneda lemm
00:22:18 <j-invariant> a?
00:22:20 <ufopp> emacs
00:22:21 <augur> no
00:22:30 <augur> if you did    let xs !! i = f (ys !! i) in take 2 xs
00:22:39 <djahandarie> j-invariant, your sentences seem to get slowly more and more broken over time :P
00:23:23 <j-invariant> I dont "get" this stuff
00:23:23 <augur> you'd want to somehow treat xs !! i as some sort of thing which can be "peered into" so as to see 'take 2 xs' as related to it
00:23:29 <Axman6> djahandarie: whisky will do that to you
00:23:32 <Saizan> j-invariant: in System F it follows from Reynolds' abstraction theorem, and haskell isn't that far from it
00:23:44 <colah> Saizan: Good point. Thanks.
00:24:43 <augur> take 2 xs = head xs : take 1 (tail xs) = head xs : head (tail xs) : take 0 (tail (tail xs)) = head xs : head (tail xs) : []
00:24:43 * djahandarie doesn't like when the only resource to learn about something is an academic paper
00:25:13 <augur> xs !! 0 = head xs, xs !! n = (tail xs) !! (n - 1)
00:25:15 <Saizan> j-invariant: i'm not familiar with the proof, though i guess the crucial part is that types are immaterial at the value level, you can e.g. pattern match on them
00:25:23 <Saizan> s/can/can't/
00:25:36 <dolio> j-invariant: Not all parametricity corresponds well to natural transformations, exactly.
00:25:41 <dolio> Without finessing, at least.
00:25:58 <augur> so that means head xs : head (tail xs) : [] == xs !! 0 : (tail xs) !! 0 : []
00:26:21 <dolio> For instance, 'forall a. a' doesn't look like a natural transformation unless you interpret it as 'forall a. () -> a'.
00:27:01 <augur> hmm
00:27:31 <j-invariant> that makes sense
00:27:45 <j-invariant> what about a -> b -> c
00:27:55 <j-invariant> it could be either (a,b) -> c or a -> c^b
00:28:05 <j-invariant> I guess theyh give the same thing though
00:28:14 <dolio> Anyhow, for functors F and G, a natural transformation h : F -> G is a family of functions h_A such that for g : A -> B, h_B . Fg = Gg . h_A
00:28:57 <dolio> And if you look at what parametricity means, you can get that identity out of something with the type of 'forall a. F a -> G a'.
00:29:27 <dolio> The "free theorem" for a function with that type is that 'h . map_F g = map_G . h'.
00:29:36 <dolio> Er, 'map_G g'.
00:29:45 <j-invariant> is it always map
00:29:50 <dolio> @free h :: forall a. F a -> G a
00:29:50 <lambdabot> $map_G f . h = h . $map_F f
00:30:18 <dolio> Yes.
00:30:20 <j-invariant> @free x :: forall a b. (a,b) -> (b,a)
00:30:21 <lambdabot> $map_Pair g f . x = x . $map_Pair f g
00:30:41 <j-invariant> @free x :: forall a b. (a -> b) -> (b -> a)
00:30:41 <lambdabot> g . h = k . f => f . x h = x k . g
00:30:53 <j-invariant> . is "map" then
00:31:12 <j-invariant> why is there a hypothesis?
00:32:00 <j-invariant> @free x :: forall a b. (F a b) -> (G a b)
00:32:01 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
00:32:14 <djahandarie> Heh
00:32:49 <testme> hi
00:32:53 <colah> Anyone have a better idea than a long list of type declarations for  ‚Ñù, ‚Ñù¬≤, and so on?
00:32:59 <ddarius> In which we discover there's an 89 line function in FreeTheorem.hs
00:33:00 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
00:33:03 <testme> what?
00:33:23 <colah> I'd love to be able to have someway of doing an aribtrary n, if possible.
00:33:30 <djahandarie> testme, do you have a Haskell-related question?
00:33:41 <testme> bye
00:33:44 <djahandarie> Later
00:34:17 <djahandarie> lol
00:35:07 <Saizan> colah: how do those look?
00:35:30 <colah> right now, just type ‚Ñù = Float, type ‚Ñù¬≤ = (Float, Float), and so on.
00:36:38 * colah is not looking forward to making them all instances of a bunch of classes.
00:37:03 <Saizan> data Z; data S n; data R :: * -> * where Nil :: R Z; Cons :: Float -> R n -> R (S n) -- is one way
00:37:31 <Saizan> maybe with strict fields, and differently named constructors
00:37:58 <colah> That defeats the whole cool unicode thing though.
00:38:15 <colah> Does haskell have some sort of preprocessor I could use to handle these?
00:38:24 <djahandarie> If you want the cool unicode thing use Template Haskell
00:38:34 <djahandarie> But you'll be in much more pain doing that than just writing the instances
00:38:47 <c_wraith> eh.  TH isn't that hard.
00:39:17 <j-invariant> does parametricity have analogues on other categories?
00:39:43 <djahandarie> Jesus christ it's late
00:40:59 <colah> OK. Thanks again for your help, all.
00:41:15 <colah> Sleep well.
00:42:53 <systemfault> Haskell is evil.. the more I learn about it, the more I hate other languages for not having some of its features...
00:43:19 <cads> and the more I hate haskell for looking so damn ugly!
00:43:40 <cads> it's like I'm in love with an ugly woman!
00:43:56 <systemfault> You've never done java or C++, right? Or even web languages like javascript...
00:44:06 <cads> and other women can't attract me even if I see that they are attractive in certain ways
00:44:19 <systemfault> Haha
00:46:17 <cads> my first language was Ti-Basic on the Ti-82 calculator
00:47:35 <cads> and I could animate pixels on the screen without using monads :(
00:47:47 <sipa> loi
00:48:52 <cads> also, every game written in haskell will have "monad" written in the title and there will only be 2 games written in haskell.
00:48:53 <ddarius> @hackage BASIC
00:48:53 <lambdabot> http://hackage.haskell.org/package/BASIC
00:49:01 <pedro3005> how do I take the last element of a tuple of length 3?
00:49:09 <cads> and I will write the second one.
00:49:13 <cads> Monadtris.
00:49:23 <systemfault> Eww BASIC for haskell
00:49:36 <sipa> pedro3005: ( \
00:50:01 <sipa> pedro3005: ( \(_,_,x) -> x  )
00:50:24 <pedro3005> sipa, oh, right. I was really confused at the first message
00:50:28 <asflierl> cads: Haskell game programming indeed does not seem to be very popular
00:50:45 <systemfault> Well... C++ has that "field"
00:50:55 <asflierl> sadly
00:51:38 <systemfault> Mainly for performance considerations...
00:52:02 <cads> well, haskell doesn't have many game libraries
00:52:46 <augur> @tell conal push-pull FRP talk in edinburgh <3
00:52:47 <lambdabot> Consider it noted.
00:52:50 <asflierl> yeah, that's symptom and cause all in one
00:53:15 <augur> i love conal so very much
00:53:25 <systemfault> Marry him.
00:53:27 <augur> in this talk he's got a bit of an asymmetry in his facial expression,
00:53:34 <augur> and he looks like a pirate because of it
00:53:44 <augur> arr matey, we be haskellin' tonight
01:00:53 <jan247> hi, pretty new at haskell. I was wondering if i can let say, name = getName. getName does IO and reads from stdin and returns a string. now, I pass this name variable to some function. only if the name variable is evaluated will it trigger the actual IO. in other words, it should do it lazily
01:01:22 <j-invariant> no
01:01:49 <Saizan> that is not how things normally work
01:02:14 <jan247> I see. how are lazy bytestrings implemented though? isn't it the similar?
01:02:29 <Saizan> but you can pass name to a function and that function can sequence it with the rest of IO with >>= and do-notation
01:02:30 <dolio> You can do that, but not in exactly the manner that you said.
01:02:39 <dolio> And people will make angry faces at you.
01:02:52 <jan247> haha, i see. thanks for the tip
01:03:40 <Saizan> lazy bytestring's readFile does it with unsafeInterleaveIO, which is what makes people angry :)
01:04:20 <jan247> i was hoping to declare my variables, say.. let name = getNameFromDB, telNo = getTelNoFromDb in ....somecodehere...
01:04:51 <jan247> wherein only if I use the telNo variable should it actually get it from DB. am I thinking about this wrong? :)
01:06:34 <Enigmagic> jan247: short answer is that it is technically possible but should be avoided
01:06:50 <jan247> might I ask why? :)
01:07:05 <Enigmagic> technically possible = breaking the rules
01:07:41 <jan247> that pure functions shouldn't cause side effects?
01:07:41 <dolio> You wouldn't be breaking any rules the core libraries don't.
01:07:59 <Saizan> jan247: leaving external resources like file handles and database connections at the mercy of lazy evaluation can lead to nasty bugs
01:08:01 <dolio> And I think the evils of lazy IO are over-exaggerated.
01:08:04 <Enigmagic> jan247: well... what do you want to happen if the values in the database change?
01:08:25 <dolio> But database connections might be more rare than is appropriate for lazy IO.
01:08:26 <Saizan> jan247: that's the main objection, also it's hard to recover from errors
01:09:18 <jan247> I see. thanks for the tips guys
01:09:35 <token22> hi
01:09:55 <blackh> jan247: Opinions do vary a little.  I'm in the anti-lazy-IO camp, so I think you shouldn't do it.
01:10:22 <Saizan> tual IO. in other words, it should do it lazily
01:10:22 <Saizan> 10:00  j-invaria : no
01:10:23 <Saizan> 10:01     Saizan : that is not how things normally work
01:10:23 <Saizan> 10:01     jan247 : I see. how are lazy bytestrings implemented though? isn't it the similar?
01:10:26 <Saizan> 10:02     Saizan : but you can pass name to a function and that function can sequence it with the rest of IO with >>= and do-notation
01:10:29 <Saizan> 10:02      dolio : You can do that, but not in exactly the manner that you said.
01:10:32 <Saizan> 10:02      dolio : And people will make angry faces at you.
01:10:34 <Saizan> 10:02     jan247 : haha, i see. thanks for the tip
01:10:37 <Saizan> 10:03     Saizan : lazy bytestring's readFile does it with unsafeInterleaveIO, which is what makes people angry :)
01:10:40 <Saizan> 10:03     jan247 : i was hoping to declare my variables, say.. let name = getNameFromDB, telNo = getTelNoFromDb in ....somecodehere...
01:10:43 <Saizan> 10:04     jan247 : wherein only if I use the telNo variable should it actually get it from DB. am I thinking about this wrong? :)
01:10:46 <Saizan> 10:06  Enigmagic : jan247: short answer is that it is technically possible but should be avoided
01:10:49 <Saizan> 10:06     jan247 : might I ask why? :)
01:10:51 <Saizan> 10:06  Enigmagic : technically possible = breaking the rules
01:10:54 <Saizan> 10:07     jan247 : that pure functions shouldn't cause side effects?
01:10:56 <Saizan> 10:07      dolio : You wouldn't be breaking any rules the core libraries don't.
01:10:59 <Saizan> 10:07     Saizan : jan247: leaving external resources like file handles and database connections at the mercy of lazy evaluation can lead to nasty bugs
01:11:27 <token22> could you help to write a function that do from matrix transponded matrix ([[Int]]->[[Int]]) ?
01:11:30 <Saizan> sorry, again
01:11:46 <mm_freak> dolio: lazy IO is fine for simple command line utilities, but you shouldn't write networking code using lazy IO
01:11:50 <dolio> @type transpose
01:11:51 <lambdabot> forall a. [[a]] -> [[a]]
01:12:17 <dolio> mm_freak: Right.
01:12:47 <dolio> At least, relatively complex networking code.
01:12:59 <dolio> If it's the networking equivalent of a simple command like utility, it's probably fine.
01:13:02 <qfr> What is "lazy IO" in Haskell?
01:13:06 <shachaf> s/lazy/evil/
01:13:09 <mm_freak> well, it might even suffice for very simple clients
01:13:15 <cads> augur, was your comment related to the game library thing?
01:13:19 <jan247> yep, i can imagine it actually coming back to bite..
01:13:22 <blackh> jan247: It is generally very difficult to make an IO operation convincingly referentially transparent.
01:13:27 <mm_freak> but for servers lazy IO is not suitable
01:13:38 <mm_freak> especially when it comes to scaling servers with multiple clients
01:14:16 <mm_freak> qfr: reading to a lazy string, writing a lazy string
01:14:19 <qfr> Does Haskell provide an IOCP/epoll/kqueue thing?
01:14:25 <mm_freak> yes, it does
01:14:28 <qfr> Nice
01:14:35 <Bynbo7> haskell doesn't, the epoll package does
01:14:43 <shachaf> qfr: But that's not what "lazy IO" means.
01:14:46 <mm_freak> i think newer GHC runtimes have it built in, but for older versions there is also an epoll package
01:14:47 <qfr> err yeah I meant Haskell libs
01:15:04 <Bynbo7> also GHC's IO bckend is epoll/kqueue based in GHC 7
01:15:07 <Saizan> writing a lazy string is not lazy I/O (unless you consider OS level buffering to be)
01:15:10 <Bynbo7> backed*
01:15:26 <dolio> mm_freak: But people frequently come in here and say things like, "I'm writing a toy program that needs to read in a single file, and when I close the handle manually, I get no input." And people immediately say, "learn iteratees! Lazy IO is evil!!!"
01:15:34 <mm_freak> Saizan: something like:  forkIO $ hPutStr h str
01:15:40 <mm_freak> semilazy
01:16:02 <mm_freak> dolio: yes, that's a bad response to such a question
01:16:10 <qfr> I don't even know what a "lazy" string is
01:16:21 <Saizan> i would characterize lazy I/O as tying the execution of some side-effects to evaluation
01:16:30 <Bynbo7> > show [1..] -- lazy string
01:16:31 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:16:39 <Saizan> that example is explicitly concurrent instead..
01:16:45 <mm_freak> qfr: every string in haskell is lazy
01:16:50 <ddarius> dolio: People frequently come in here and say things like, "I'm writing a toy progarm that needs a global variable" and people immediately say, "learn monads! Global variables are evil!!!"
01:17:04 <mm_freak> qfr: only what's needed or explicitly demanded is evaluated
01:17:33 <mm_freak> qfr: lazy IO interleaves evaluation (an otherwise pure operation) with reading from a file (an impure operation)
01:17:54 <Saizan> dolio: i think that started happening after the flood of "i'm writing a toy program that opens a gazillion of files and it uses all my file handles)
01:18:14 <qfr> mm_freak right, what's the problem with that? That it's inefficient?
01:18:24 <mm_freak> qfr: that it's unpredictable
01:18:30 <dolio> Yeah. I wonder what those toy programs are doing.
01:18:35 <mm_freak> you don't know when the handle is closed and errors are silently ignored
01:18:39 <dolio> I've never written anything that runs out of file handles.
01:19:04 <mm_freak> qfr: String IO is inefficient, but that's not related to laziness
01:19:14 <Bynbo7> dolio: highly concurrent network servers
01:19:25 <mm_freak> it's related to the fact that String = [Char], i.e. a linked list of characters
01:19:26 <dolio> Bynbo7: That doesn't sound like a toy program to me.
01:19:50 <Saizan> mm_freak: you get an exception if there's an error now
01:19:59 <Bynbo7> heh, sounds like my toy programs do :P
01:20:03 <mm_freak> Saizan: ah, ok, at least something
01:20:24 <mm_freak> but anyway, if you know how to write iteratees you really don't miss lazy IO anymore =)
01:21:00 <mm_freak> and good thing is that you can implement iteratees in other languages, too, although you might run into trouble with that, because your colleagues don't understand your code
01:21:27 <qfr> mm_freak you mean unpredictable as in, it's not clear at which point something gets evaluated when you are using it to perform IO or something?
01:21:45 <mm_freak> qfr: yes, and also it's unpredictable when the handle is closed
01:21:51 <mm_freak> so you might run into resource usage problems
01:22:00 <qfr> Is there some code example which shows such an "unexpected behaviour" and how the person should have coded it instead?
01:22:58 <Bynbo7> main = do h <- openFile "foo" ReadMode; str <- hGetContents h; let res = f str; hClose h; print res
01:23:40 <qfr> that'll fail because evaluation occurs after the handle is closed?
01:23:41 <Bynbo7> in that code, f may get passed [], even if foo had data in it, because the handle gets closed before the result using the contents wasn't evaluated before the handle was closed
01:23:58 <mm_freak> Bynbo7: in lazy IO generally you don't close the handle
01:24:05 <Bynbo7> sure
01:24:22 * Bynbo7 does
01:24:42 * mm_freak doesn't, because mm_freak doesn't do lazy IO =)
01:24:49 <Saizan> hGetContents closes it for you at the end
01:25:05 <blackh> qfr: If you read a file lazily, then it works as long as you expect the file never to change during the lifetime of the program.  Unix does actually pretty much give you that illusion anyway, so the main practical problem is too many file handles open if you read lots of files lazily.
01:25:07 <Bynbo7> well, that makes life even more annoying :)
01:25:07 <mm_freak> Saizan: semicloses i think
01:25:08 <qfr> So what is the preferred way to ensure that you perform evaluation and store the result so you can use it after the handle is closed without causing any errors?
01:25:17 <mm_freak> Bynbo7: "that"?
01:25:30 <Bynbo7> the fact hGetContents closes the handle
01:25:45 <mm_freak> blackh: the former problem is not related to lazy IO
01:25:49 <dolio> Bynbo7: Anyhow, if "highly concurrent network server" is your toy, then scalable IO is what you're playing with, and lazy IO isn't an option.
01:26:00 <ddarius> Saizan: hGetContents closes it for you -when you consume all the input-
01:26:00 <Saizan> mm_freak: "semiclosed" is ghc speak for you shouldn't do anything else with this handle and it'll get closed at the end
01:26:10 <dolio> Often times, you're playing with something else, and IO is a minor afterthought.
01:26:11 <mm_freak> Saizan: k
01:26:14 <Bynbo7> qfr: the preferred way (imo anyway) is to use iteratees to make sure things happen when they should
01:26:23 <Saizan> ddarius: that's what i meant by "at the end"
01:26:38 <qfr> Oh boy, I've never even heard of that term before
01:26:42 <mm_freak> iteratees are not just some abstraction to enforce predictablity‚Ä¶  they are actually very convenient
01:26:48 <ddarius> And if you only use part of the input, it never gets closed.
01:26:53 <qfr> http://www.haskell.org/haskellwiki/Enumerator_and_iteratee
01:27:03 <blackh> qfr: The preferred way is any non-lazy way of reading the file, e.g. hGet
01:27:12 <blackh> I mean Data.ByteString.hGet
01:27:21 <mm_freak> i love the combination attoparsec, attoparsec-enumerator and enumerator
01:28:15 <profmakx> writing compilers for existing languages never stops being fun
01:28:32 <Bynbo7> yeah, attoparsec practically is an iteratee anyway
01:28:40 <Bynbo7> it just doesn't know it
01:28:50 <j-invariant> compiler to what language?
01:28:54 <qfr> C++
01:28:58 <qfr> His favourite
01:29:01 <Bynbo7> to or from?
01:29:06 <tab> mm_freak: very convenient, but not as simple unfortunately
01:29:15 <qfr> From C++ to ELF obj
01:29:45 <Xilon> Anyone attempting to write a C++ parser is mad
01:29:49 <mm_freak> tab: i prefer iteratee IO over lazy IO in every aspect, including convenience
01:29:49 <qfr> :D
01:30:08 <mm_freak> tab: it's certainly a bit difficult to learn, but it pays off
01:30:14 <Bynbo7> indeed
01:30:15 <ClaudiusMaximus> augur: http://claudiusmaximus.goto10.org/g/tech/label-tree-pruned.png (graphviz code generated from some haskell i wrote from your diagram)
01:30:23 <tab> mm_freak: absolutely. but i took me a while to convert a large package to it
01:30:27 <blackh> qfr: There are two main iteratee packages: enumerator and iteratee.  enumerator is newer and more popular.  There's a small learning curve involved, but the resulting code is solid and reliable.
01:30:36 <Bynbo7> it doesn't take long until you start thinking "hmm, this is a great place to use iteratees"
01:31:08 <Bynbo7> blackh: it should be noted that iteratee has quite a few features enumerator doesn
01:31:13 <Bynbo7> doesn't by defauly*
01:31:17 <Bynbo7> t*
01:31:19 <mm_freak> i used to like the 'iteratee' package, but the 'enumerator' package feels cleaner and simpler
01:31:19 <Bynbo7> -_-
01:31:44 <mm_freak> also the interface between attoparsec and enumerator works well, while the one between attoparsec and iteratee is broken
01:32:10 <mm_freak> Bynbo7: none of them are difficult to write‚Ä¶  also enumerator has some features iteratee doesn't have
01:33:28 <Bynbo7> sure, but they aren't there by default
01:33:45 <Bynbo7> does enumerator include an enumHandle function?
01:34:25 <mm_freak> sure
01:34:30 <mm_freak> Data.Enumerator.IO
01:34:44 <mm_freak> enumHandle, enumFile
01:35:07 <mm_freak> the package would be quite laughable without a handle enumerator =)
01:36:11 <mm_freak> but currently i'm writing a custom handle enumerator called enumHandleTimeout
01:36:14 <mm_freak> for networking code
01:36:21 <Bynbo7> how handeh
01:36:50 <mm_freak> also a custom enumeratee truncatedLines, also for networking code
01:37:17 <mm_freak> my current networking code is subject to DoS attacks, which is bad
01:37:26 <Bynbo7> heh, oh no
01:37:54 * blackh is working on an enumerator-based XML parser
01:37:58 <Bynbo7> i would very much like a enumHandleLines or something, that does passes bytestrings line by line
01:38:26 <mm_freak> Bynbo7: why?
01:38:51 <mm_freak> enumHandle h $$ joinI $ truncatedLines $$ iteratee
01:39:18 <qfr> Is $ like $$, just with a different precedence or something?
01:39:20 <Bynbo7> would have been useful for the implementation of tee i wrote :)
01:39:25 <qfr> @src ($$)
01:39:25 <lambdabot> Source not found. Where did you learn to type?
01:39:30 <Bynbo7> qfr: it's for iteratees
01:39:58 <mm_freak> qfr: in simple terms ($$) applies an enumerator (data source) to an iteratee (data sink)
01:40:14 <mm_freak> in iteratees you separate input from input processing
01:40:31 <mm_freak> so one iteratee can work with many types of data sources
01:41:39 <mm_freak> Bynbo7: you just need an enumeratee to convert to lines
01:42:01 <Bynbo7> that would work i guess
01:42:08 <mm_freak> in the iteratee package there is one predefined
01:42:16 <mm_freak> in the enumerator package you need to define it yourself right now
01:42:18 * Bynbo7 -> dinner
01:43:41 <tab> mm_freak: you have to be careful converting to lines though, in case of infinite line
01:43:59 <mm_freak> tab: right, that's why i'm writing the truncatedLines enumeratee =)
01:44:09 <tab> mm_freak: how do you solve the problem ?
01:44:19 <tab> mm_freak: explicit limit ?
01:44:24 <mm_freak> tab: yes
01:44:35 <pedro3005> Hello all. I'm having trouble with this code http://paste.pocoo.org/show/313606/ . It "works", compiles, connects, responds to PING and all, but the message responding to "¨alive?" doesn't seem to be sent at all. Somewhere along the road it's lost or not even called
01:45:20 <mm_freak> tab: in the protocols i'm implementing you need the end of line, before you can start processing the input, so i can't process right away‚Ä¶  i have to limit the line length
01:45:33 <mm_freak> but that's no problem, because the corresponding RFCs limit the line length anyway
01:48:32 <pedro3005> I tried to add a debug print but the compiler started complaining about types
01:48:51 <qfr> pedro3005: Debug.Trace.trace performs unsafe IO
01:49:03 <qfr> So you can use that without introducing the QIO monad to everything
01:49:05 <qfr> IO*
01:49:15 <tab> mm_freak: cool, are you going to publish the code any time soon ?
01:49:52 <qfr> hGetContents hmmm
01:49:53 <tab> mm_freak: i'll need the same kind of code for nntp actually :)
01:50:26 <mm_freak> tab: yes, in the ismtp package, but perhaps it would be better to do it separately
01:50:42 <qfr> pedro3005 I am somewhat puzzled by this code, I suck at Haskell though
01:50:53 <tab> mm_freak: maybe a text-enumerator-helper package ?
01:51:07 <pedro3005> qfr, I agree it looks kind of ugly, to say the least
01:51:07 <mm_freak> tab: rather 'enumerator-network' or something
01:51:11 <qfr> So hGetContents with that mapM_ down there will process line by line?
01:51:16 <pedro3005> yeah
01:51:25 <qfr> instead of waiting for the connection to terminate?
01:51:30 <mm_freak> tab: or 'enumerator-tools'
01:51:31 <pedro3005> indeed
01:51:54 <tab> mm_freak: i think that would be quite pratical thing to have
01:52:01 <pedro3005> qfr, I'm 90% sure that share is working, since it responds to ping, prints all the privmsgs and everything correctly
01:52:04 <blackh> hGetContents is lazy I/O
01:52:09 <mm_freak> tab: i'll work on it today in the evening
01:52:11 <j-invariant> What if haskell had parametrecity built into the language?
01:52:12 <tab> mm_freak: quite common to need to enumerate text lines in lots of protocol
01:52:17 <mm_freak> (it's 10:51 am here)
01:52:35 <qfr> pedro3005: lines doesn't remove \r btw
01:52:40 <qfr> Which is used in IRC
01:52:58 <pedro3005> hmm
01:53:03 <tab> mm_freak: i'll keep an eyes on hackage then :)
01:53:03 <pedro3005> do you think that could be causing it?
01:53:04 <qfr> I didn't see you removing that anywhere
01:53:07 <qfr> Just a wild guess
01:53:17 <qfr> Also, encoding issues?
01:53:26 <qfr> prefix = '¬¨'
01:53:55 <qfr> Does Haskell keep that as a single char?
01:53:56 <mm_freak> 'lines' doesn't work for IRC at all, because in IRC '\r' alone is also a line delimiter
01:54:06 <qfr> Unicode Char?
01:54:19 <o^_^o> hmmm
01:54:23 <o^_^o> Hello
01:54:25 <mm_freak> so "x\r\ny" actually has three lines with one empty inbetween
01:54:30 <qfr> mm_freak: Well, the RFC dictates that its' \r\n afaik?
01:54:35 <pedro3005> qfr, haha you were right
01:54:37 <Zao> mm_freak: If you follow the RFC, the only allowed is CRLF.
01:54:40 <qfr> pedro3005 really :D
01:54:42 <Zao> Of course, idiots in reality disagree.
01:54:46 <pedro3005> I changed it do cmd == "alive?\r"
01:54:54 <pedro3005> <pedro3005> ¨alive?
01:54:54 <pedro3005> <FailureBot> Yes
01:54:56 <qfr> Amazing, and I have never even written one useful Haskell program.
01:55:03 <o^_^o> unfold :: (b -> (a,b)) -> b -> Stream a
01:55:09 <Zao> s/idiots/ircd "developers"/
01:55:31 <o^_^o> unfold f b = a : unfold f b' where (a, b') =  f b
01:55:50 <qfr> pedro3005: Splitting with "\r\n" sounds better to me
01:55:53 <o^_^o> where (a, b') = f b, how do I interpret this ?
01:56:06 <o^_^o> (a, b') is f b or f b returns (a. b')
01:56:09 <mm_freak>    The protocol messages must be extracted from the contiguous stream of
01:56:09 <mm_freak>    octets.  The current solution is to designate two characters, CR and
01:56:10 <mm_freak>    LF, as message separators. 
01:56:14 <mm_freak> see section 2.3.1
01:56:18 <pedro3005> qfr, indeed this was just a test
01:56:23 <qfr> pedro3005: Btu I am still puzzled how this all works :P when the server sends "a\r\nb", wouldn't it erroneously interpret that as two lines?
01:56:26 <o^_^o> and how can a function call be equal to a tuple ?
01:56:30 <mm_freak> since i wrote fastirc i DID pay attention to the RFC ;)
01:56:46 <Zao> mm_freak: Also see the end of the BNF, that says <crlf> ::= CR LF
01:56:57 <Zao> Not CR | LF | CR LF
01:56:59 <qfr> Nice, BNF.
01:57:09 <pedro3005> qfr, yes. but why is that wrong?
01:57:13 <pedro3005> those ARE two lines
01:57:30 <mm_freak> Zao: the RFC is ambiguous about this and states explicitly that CR and LF are allowed delimiters
01:57:43 <Zao> mm_freak: I trust the BNF over prose.
01:57:54 <qfr> pedro3005: Lines can get split up over packet boundaries and it parses this on a packet basis or something, no?
01:57:56 <Zao> Of course, idiots^Wircd implementers disagree.
01:58:15 <mm_freak> i don't, because by allowing CR and LF the code is more general than yours
01:58:25 <mm_freak> networking code needs to be error tolerant
01:58:27 <pedro3005> qfr, I assume `lines` takes care of that and gives me each line (\n) individually
01:58:34 <Zao> Thankfully, in reality you can just split on CR or LF, and discard empty messages.
01:58:43 <Zao> mm_freak: I don't give a hoot about reality, I care about proper specs.
01:58:44 <mm_freak> yes, that's what i do
01:58:46 <Philippa> so long as they're strict in what they send out...
01:59:00 <mm_freak> Zao: then nobody will use your code ;)
01:59:02 <ddarius> Error tolerant doesn't mean assigning arbitrary semantics to malformed input.
01:59:03 <Zao> mm_freak: Why are there request-for-comments when these kinds of things are not caught and updated? :D
01:59:15 <Zao> mm_freak: The perils of a single implementation and a spec written from that.
01:59:21 <mm_freak> Zao: because you NEED to consider the case that your PEER doesn't follow the RFC
01:59:50 <Zao> mm_freak: I'm just saying that custody of the IRC protocol and its dialects is very poorly maintained.
02:00:18 <mm_freak> yes, but even if the RFC would dictate to allow only CRLF i would still allow CR and LF, too
02:00:26 <mm_freak> because i don't trust my peer
02:00:29 <Zao> How about a deprecating RFC? How about augmenting RFCs? Standards evolve, but all an IRC implementer has is a cruddy broken RFC from the dark ages.
02:00:41 <koala_man> I don't trust him either, he keeps resetting my connection
02:00:41 <Zao> Bloody finns :D
02:00:46 <mm_freak> we should replace all RFCs by haskell parsers =)
02:01:17 <qfr> pedro3005: Let's say the server sends two packets to you, one says "PRIVMSG #haskell :I learned Haskell", the next one says "because I wanted a misanthropic programming language\r\n" - won't lines.. nevermind, it probably works somehow anyways, I just don't know how <- works really anyways...
02:01:26 <Zao> mm_freak: Considering that I've never managed to understand any of the parsing libraries properly, that's probably a dumb idea.
02:01:45 <mm_freak> ddarius: well as soon as you get error-tolerant you /have/ to assign arbitrary semantics
02:01:51 <Zao> uu-parsinglib kicks me in the groin on a regular basis, with its affinity to conjure up tokens from thin air.
02:02:10 <pedro3005> qfr, lines will wait until it gets a \n
02:02:12 <Philippa> qfr: "packets"? we're on TCP, not UDP
02:02:16 <ddarius> mm_freak: The arbitrary semantics should be notifying about an error and/or retrying.
02:02:18 <balor> The pureMD5 docs suggest that there's a function ¬´hash'¬ª defined somewhere.  Where is this function defined?  Docs here http://hackage.haskell.org/packages/archive/pureMD5/2.1.0.3/doc/html/Data-Digest-Pure-MD5.html
02:02:58 <Philippa> ddarius: the protocol has no way to do the former, and no non-arbitrary way to do the latter
02:03:10 <tab> balor: in crypto-api IIRC
02:03:12 <mm_freak> ddarius: what does it mean to "retry", if you get only LF limited lines from an IRC server?
02:03:33 <Philippa> a server that only sends out LF is borked
02:03:49 <Philippa> completely, there's no excuse for such a basic failure
02:04:10 <ddarius> The assigning arbitrary semantics to malformed input is what got us into the HTML problems.
02:04:18 <mm_freak> yes
02:05:03 <mm_freak> the problem is that you get so much malformed input in the real world that you have to be error-tolerant and try to guess‚Ä¶  otherwise nobody will use your code
02:05:17 <qfr> Philippa: My point was that you must not depend on when recv returns. I've seen people who assumed that data returned by recv would always contain an atomic communication unit whereas you really need to continously append this to a buffer where bytes then get consumed by a parser, depending on how it works
02:05:42 <mm_freak> if you would inform the user about every malformed packet, 80% would shut their computer down and never turn it back on
02:05:45 <qfr> Since you can split up one IRC line over 50 returns of recv if you feel like it
02:05:53 <qfr> If the server is being impolite
02:06:03 <Philippa> qfr: not much of an issue if you do the 'obvious' thing in haskell, though
02:06:04 <Zao> qfr: And/or evil.
02:06:34 <Zao> Philippa: You're greatly overestimating the competence of network developers :D
02:06:42 <mm_freak> i'm not a big fan of being error-tolerant, but i write real world code
02:06:56 <mm_freak> in this case the RFC clearly states that it's allowed, so i do it
02:07:07 <Zao> mm_freak: It vaguely mumbles :)
02:07:18 <qfr> I'm going to write a patch for Firefox which uses "Referrer" instead of "Referer"
02:07:29 <qfr> Error tolerance can suck it
02:07:37 <mm_freak> hehe
02:07:47 <Zao> mm_freak: I hope you send CRLF at least.
02:07:52 <mm_freak> of course
02:07:59 <Philippa> Zao: weeell, the obvious thing in haskell is to just use lazy IO...
02:08:12 <qfr> Philippa people here were complaining about that earlier
02:08:26 <mm_freak> Zao: error-tolerance doesn't mean that you make errors yourself ;)
02:08:28 <Philippa> yes, it's problematic in many other contexts. But it works fine for this one
02:08:29 <qfr> And showed me an example where stuff would get evaluated after the handle was already closed
02:08:54 <Philippa> ...yes, but how's that a problem in this context?
02:08:55 <Zao> mm_freak: I know the old adage - be strict in what you send, be sloppy in what you accept.
02:09:18 <Philippa> (I wouldn't suggest using lazy IO for output here, mind)
02:09:28 <Zao> Philippa: Because it's awesome fun to have errors occur in unrelated parts of your code.
02:09:40 <Philippa> again, "in this context"?
02:10:01 <mm_freak> Zao: IMO if there is an obvious interpretation of what you receive, you shouldn't fail, just because the RFC dictates it‚Ä¶  only few implementations in the real world really follow the RFC
02:10:21 <mm_freak> NNTP is a particularly sad example‚Ä¶  an RFC-compliant NNTP client is completely useless in the real world
02:10:47 <qfr> mm_freak what part makes it useless?
02:10:51 <qfr> Or parts if you so wish
02:11:12 <mm_freak> qfr: listing messages‚Ä¶  most servers implement /only/ an extension for this purpose and disable the standard command
02:11:25 <mm_freak> efficiency is the reason
02:11:45 <tab> except it's standard in newer RFCs
02:12:08 <mm_freak> true
02:12:26 <mm_freak> but it's not a replacement RFC
02:12:36 <mm_freak> you actually need to read the original one together with some extension RFCs
02:12:47 <tab> yes
02:12:49 <mm_freak> that's why i call it an "extension"
02:15:33 <tibbe> Sigh, we need to do something about the libraries process.
02:15:46 <j-invariant> Warning: This package indirectly depends on multiple versions of the same
02:15:46 <j-invariant> package. This is highly likely to cause a compile failure.
02:15:46 <j-invariant> package happy-meta-0.1.1 requires mtl-1.1.0.2
02:15:46 <j-invariant> package monads-fd-0.2.0.0 requires mtl-2.0.1.0
02:15:48 <j-invariant> ^ this is bad news
02:16:13 <mm_freak> j-invariant: works most of the time, just try it out
02:16:17 <tibbe> j-invariant, happy-meta needs to be patched to work with the new mtl
02:16:18 <qfr> lol
02:16:31 <mm_freak> tibbe: what do you mean?
02:16:36 <tibbe> j-invariant, like mm_freak said, fixing the constraints mostly works
02:17:07 <tibbe> mm_freak, the error message says that  happy-meta-0.1.1 requires mtl <= mtl-1.1.0.2 while monads-fd-0.2.0.0 requires >= mtl-2.0.1.0
02:17:39 <tibbe> mm_freak, but that's probably not quite true, happy-meta could probably be made to work with mtl-2 without much hassle
02:17:52 <mm_freak> tibbe: i mean:  <tibbe> Sigh, we need to do something about the libraries process.
02:18:11 <Saizan> j-invariant: you just have to rebuild happy-meta against mtl-2, "cabal install" would do it automatically, "cabal configure" doesn't
02:18:27 <tibbe> mm_freak, oh :)
02:18:47 <Saizan> since happy-meta doesn't have an upper bound on mtl anyway
02:19:08 <j-invariant> thanks Saizan 
02:19:25 <Saizan> (though there's no guarantee it'll actually build with mtl-2, but it's likely)
02:19:32 <tibbe> mm_freak, too many people choose to not work on libraries maintained by that process due to its heavy weight nature
02:20:06 <tibbe> mm_freak, Milan (who has done the most work on containers in a long time) told me that he stopped working on it due to not wanting to spend more time on the process
02:20:27 <qfr> What process?
02:20:33 <mm_freak> what process?
02:20:40 <qfr> Are you talking about an organisation issue?
02:20:47 <tibbe> mm_freak, bryan o'sullivan almost withdrew text from the platform due to the heavy-weightness of the (HP) process
02:20:56 <tibbe> the libraries@ process
02:21:05 <tibbe> to change libraries managed by the libraries mailing list
02:21:13 <qfr> HP = ?
02:21:18 <qfr> Haskell Platform?
02:21:20 <tibbe> qfr, haskell platform
02:21:52 <tibbe> any change to a library maintained by the libraries mailing list requires proposals, GHC trac tickets, discussions, etc
02:21:55 <balor> I'm struggling trying to write a simple function that computes the md5 hash of a file. http://hpaste.org/42729/simple_md5_hashing Pointers please?
02:23:27 <tab> balor: you can always try cryptohash, it got simpler functions
02:24:09 <tab> balor: in your case though you need to annotate the hashFileStrict function with the type you want the hash from (MD5 in your context)
02:25:08 <merijn> For the Hacker News readers among us, please look over my explanation of dependent typing and help me fix/correct any mistakes/error: http://news.ycombinator.com/item?id=2062737
02:25:29 <qfr> I don't even have that module hmm
02:25:52 <balor> tab: thanks.  cryptohash makes things easier for me
02:28:41 <qfr> merijn I am puzzled, how would you want to ensure that head never gets called with an empty list? I mean, all the possible stuff you can get through side effects from IO are unknown at compile
02:28:59 <qfr> s/want /
02:29:10 <qfr> Also, why do you want this?
02:30:17 <j-invariant> http://axisofeval.blogspot.com/2011/01/why-lisp-is-big-hack-and-haskell-is.html <--- more evidence
02:30:30 <merijn> qfr: You don't need to know the length of all lists at compile time (you are right that you can't know the length of a list obtained from IO). all you need to know is that a list which is potentially length 0 can never reach head
02:30:42 <ddarius> I like academic reports of engineering projects.  Sentence from the report: "this was sufficient to cause thermal breakdown in our coils in a matter of seconds."  Probable supporting event: "Oh shit!  The robot's on fire!"
02:31:27 <merijn> qfr: For example, if earlier code checks for length of zero before calling head on a list obtained from IO then the compiler can still guarantee that list of length zero never reaches a call of "head"
02:31:38 <krainboltgreene_> "Adjustable-safety"
02:31:41 <merijn> j-invariant: My explanation was actually in the comment thread for that blog post
02:31:46 <krainboltgreene_> Sounds like Modula-3
02:32:12 <merijn> I just don't know whether my dependent typing sales pitch was solid :p
02:32:23 <j-invariant> merijn: oh I wasn't following any discussion here, funny coincidence!
02:32:28 <j-invariant> let me catch up
02:32:36 <Saizan> merijn: "turing completeness" btw
02:32:57 <merijn> Saizan: Yeah, I keep capitalizing it because its a name, my bad
02:33:37 <merijn> and completion is wrong too, I guess
02:33:44 <krainboltgreene_> Alan Turning spin around and met Haskell with a somber look, holding Haskell in his arms, "You...Complete me."
02:33:50 <krainboltgreene_> spun*
02:35:41 <Saizan> merijn: ah, capitalizing is fine
02:36:49 <slowsort> I'm confused about how to use the StateT monad with gtk
02:37:08 <qfr> Now that somebody brought the lazy IO thing to my attention, Haskell feels less robust/less resistant to writing erroneous code than I had anticipated hmm
02:38:08 <Saizan> merijn: anyhow, i'd have used gadt syntax for the last example, but the description seems correct
02:38:54 <Saizan> qfr: it's not like that's the normal way things work though
02:39:31 <merijn> I was making the syntax for dependent types up as I went. I'm mostly used to the LaTeX notation used in papers, but that seemed a bit inconvenient for an ASCII medium :p
02:40:25 <mm_freak> tibbe: i see
02:42:12 <qfr> Saizan you mean, in most scenarios you don't even use lazy IO?
02:42:33 <Saizan> qfr: right
02:42:34 <qfr> I just want to write a web framework in Haskell anyways, on top of that FastCGI server whose name I forgot
02:42:35 <opqdonut_> qfr: lazy io is discouraged by many. have you had a look at iteratees?
02:42:49 <quuuux> qfr: lazy IO is an accident waiting to happen, typically
02:42:57 <qfr> opqdonut_ I briefly saw some post about it today but I didn't really grasp it
02:43:17 <qfr> It explained stuff in terms of category theory :(
02:43:17 <opqdonut_> try again, it's simple really
02:43:25 <opqdonut_> ah you must've had the wrong link :)
02:43:34 <qfr> Catamorphisms, F-algebras and cofinal algebras!
02:43:40 <qfr> Heh
02:43:41 <opqdonut_> maybe http://www.haskell.org/haskellwiki/Enumerator_and_iteratee 
02:43:53 <qfr> That's the one I was reading :D
02:43:59 <Philippa> qfr: I only use it at present because I cba and don't generally care about the alternatives because I'm not doing "serious" IO work. But. It works well for the IRC read case still
02:44:27 <Philippa> (especially in combination with a little concurrency - have a thread that reads the input stream and spits parsed messages down a Chan)
02:44:42 <Saizan> qfr: {System.IO,Data.ByteString}.readFile/hGetContents/getContents are the main and almost only examples in the standard libs, so it's easy to avoid if you want
02:44:59 <qfr> Alright
02:45:08 <opqdonut_> http://www.haskell.org/haskellwiki/Iteratee_I/O <- that has some good links
02:45:13 <qfr> I'm not even sure if I will deal with any of those for the FastCGI thing, probably not
02:45:26 <qfr> Haha nice, it permits / :P
02:45:27 <opqdonut_> maybe just read http://hackage.haskell.org/package/iteratee , even
02:46:11 <Saizan> Philippa: given that lazy I/O is more or less implicit concurrency it seems a bit pointless if you're going to use explicit concurrency anyway
02:47:35 <Saizan> qfr: oops, s/Data.ByteString/Data.ByteString.Lazy/ and maybe you've to add .Char8 actually, but you get my point :)
02:50:19 <Saizan> (in fact, iteratees seem like they'd be more intuitive as concurrent agents too)
02:51:58 <mm_freak> http://docs.yesodweb.com/book/enumerator/ ‚áê i prefer this introduction to iteratee IO
02:52:44 <mm_freak> Philippa: an enumerator can read from anything, including a Chan
02:53:04 <qfr> Eeew, /b/
02:53:07 <mm_freak> and the iteratee doesn't care what you do with the result, so you can easily pass it down to a Chan
02:54:18 <mm_freak> if you're doing explicit concurrency anyway it seems pointless to me to use lazy IO
02:54:25 <Philippa> Saizan: eh, it saves me having to write out "do enough IO to grab me up to the next CRLF" long-hand, it's still useful
02:54:37 <Philippa> that's to say: it makes some sense with TCP reads
02:54:58 <Philippa> anyway, gtg
02:55:02 <mm_freak> huh?
02:55:14 <mm_freak> you have to say that explicitly in both lazy IO and iteratee IO
02:55:21 <qfr> Philippa you would use some looped buffer < readUpToNBytes 4096 or something like that then, right?
02:55:29 <qfr> <-, too
02:56:07 <Saizan> mm_freak: with hGetContents you can just compose it with mapM_ (writeChan c) . lines
02:56:15 <mm_freak> but in iteratee IO you wouldn't even wait for CRLF, you would write an enumeratee to split the input into lines and then write a line-based iteratee
02:56:27 <qfr> Or enumerator or whatever hm
02:56:30 <mm_freak> Saizan: right, but what's the point of doing that?
02:56:35 <Saizan> though you could also do forever $ writeChan c =<< getLine
02:56:53 <Saizan> mm_freak: get the lines into the Chan :)
02:57:24 <Saizan> without having to manage the actual chunks manually
02:57:48 <mm_freak> well‚Ä¶  run_ (enumHandle 4096 h $$ joinI $ lines $$ consume) >>= mapM_ (writeChan c)
02:58:10 <Saizan> does that push lines into the chan as they come?
02:58:14 <mm_freak> yes
02:58:17 <qfr> Hmm mapM_ has a Monad type variable
02:58:24 <qfr> Is m = IO in this case?
02:58:36 <qfr> :t mapM_
02:58:36 <mm_freak> Saizan: but in general you wouldn't do it that way
02:58:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:58:41 <mm_freak> better:
02:59:11 <Saizan> anyhow, that part of the discussion wasn't comparing it with iteratees :)
02:59:22 <mm_freak> run_ (enumHandle 4096 h $$ joinI $ lines $$ consume >>= liftIO . mapM_ (writeChan c))
02:59:45 <mm_freak> because run_ should deliver a /result/, not some intermediate data structure =)
02:59:57 <mm_freak> i.e. either use iteratees for everything or don't use iteratees
03:00:07 <qfr> Where is run_ defined?
03:00:12 <mm_freak> qfr: in that case, yes
03:00:17 <mm_freak> qfr: Data.Enumerator
03:00:21 <qfr> Ah, right
03:00:24 <Saizan> that's the part of iteratees i dislike the most
03:00:48 <mm_freak> Saizan: i really like it, because it makes your code very composable
03:00:49 <tab> you still have benefit using iteratee, if you don't use it all the way
03:01:42 <Saizan> still, i don't see how  run_ (enumHandle 4096 h $$ joinI $ lines $$ consume) >>= mapM_ (writeChan c) could push lines into the chan as they are received, there's a IO [String] in the middle there, unless you're using unsafeInterleaveIO it will only return when the list is complete
03:02:11 <mm_freak> true
03:02:34 <mm_freak> it won't push, unless you do it inside of the iteratee
03:02:36 <Saizan> mm_freak: composable within iteratees, less so with the rest
03:03:22 <mm_freak> yeah
03:03:47 <mm_freak> it's a concept you have to like to use‚Ä¶  not just some drop in tool
03:09:57 <ddarius> Saizan: The solution is to add delimited continuations to IO.
03:11:18 <dolio> I don't think that helps with IO [String].
03:11:36 <ddarius> It was a somewhat silly remark.  Ultimately, nothing will help.
03:11:43 <ddarius> From the outside that is.
03:12:51 <ddarius> unsafeInterleaveIO doesn't turn an IO [String] into something that will return the Strings one at a time from the outside.
03:13:52 <dolio> Yes, but it will allow you to build an IO [String] that explicitly interleaves the IO of building the [String] with its use.
03:14:01 <dolio> Adding delimited continuations to IO wouldn't.
03:14:57 <ddarius> Of course, not since delimited continuations are better behaved than unsafeInterleaveIO.
03:15:10 <dolio> Because the effects of the delimited continuations aren't interleaved in the [String].
03:16:05 <dolio> You could, of course, create a new data structure that is a list with interleaved effects.
03:16:15 <dolio> Which is more or less what iteratees are.
03:16:28 <dolio> Or Peaker's thing with the proper list monad.
03:16:35 <dolio> ListT, even.
03:25:34 <Jonny3> Hello
03:25:47 <Jonny3> I'm having a little problem with this function: http://pastebin.com/EQwArdVi
03:26:10 <Jonny3> It reports the error *** Term           : base3 n / 3 *** Type           : [Int] *** Does not match : [Ratio Int]
03:26:18 <mm_freak> :t (/)
03:26:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:26:21 <dolio> base3 n returns a list, and then you're dividing it by 3.
03:26:22 <mm_freak> :t div
03:26:23 <lambdabot> forall a. (Integral a) => a -> a -> a
03:26:31 <Jonny3> the thing is when I use div
03:26:40 <Jonny3> I receive an Integral error
03:26:43 <mm_freak> also % is not modulo in haskell
03:26:51 <mm_freak> :t mod
03:26:52 <lambdabot> forall a. (Integral a) => a -> a -> a
03:27:03 <dolio> base3 n / 3 = (base3 n) / 3
03:27:21 <Jonny3> oh
03:28:08 <dolio> mm_freak is also correct.
03:28:22 <mm_freak> > takeWhile (> 0) . map (`mod` 3) . iterate (`div` 3) $ 538
03:28:24 <quuuux> @pl \ (a, b) -> f b >>= g a
03:28:24 <lambdabot>   [1,2,2,1]
03:28:24 <lambdabot> uncurry (flip ((>>=) . f) . g)
03:28:45 <Jonny3> so if I change it to ( base3 n `div` 3 ) ++ [ n `mod` 3] it asks for instance of Integral [int]
03:29:11 <ddarius> Also don't use Hugs.
03:29:19 <nostrand> Jonny3: yeah it's (base3 n) `div` 3 ...
03:29:24 <mm_freak> Jonny3: listen to dolio about operator precedence
03:29:33 <mm_freak> function application has the highest priority in haskell
03:29:47 <mm_freak> higher than operator application
03:29:52 <Jonny3> ah yes sorry
03:29:55 <Jonny3> thanks very much
03:29:56 <nostrand> Jonny3: try: base3 (n `div` 3)  ++ ... =)
03:30:33 <qfr> This function is begging to be generalise
03:30:35 <qfr> This function is begging to be generalised*
03:30:43 <mm_freak> yea
03:31:06 <mm_freak> :t \n -> takeWhile (> 0) . map (`mod` n) . iterate (`div` n)
03:31:07 <lambdabot> forall a. (Integral a) => a -> a -> [a]
03:32:12 <mikeg> @src const
03:32:12 <lambdabot> const x _ = x
03:33:31 <Jonny3> I would generalise it but its part of a specification for an exercise
03:34:01 <mm_freak> Jonny3: in such cases the haskell way is to write a generalized version and derive a specialized version from it
03:34:24 <mm_freak> baseRep n = ‚Ä¶
03:34:29 <mm_freak> base3 = baseRep 3
03:34:39 <Jonny3> oh right
03:35:32 <mm_freak> but unless you want to learn haskell for actually useful stuff, you shouldn't care too much about it =)
03:36:27 <ddarius> Why would someone want to write useful code?
03:36:45 <merijn> Beats me? Useless academical code is much more fun :p
03:37:10 <mm_freak> btw, i find this "takeWhile f . map g . iterate h" pattern very recurring
03:37:33 <mm_freak> at least the "map g . iterate h" part
03:37:38 <merijn> :t iterate
03:37:38 <lambdabot> forall a. (a -> a) -> a -> [a]
03:38:10 <merijn> > iterate (+1) 1
03:38:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:38:14 <mm_freak> > let chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n) in chunksOf 3 "abcdefghijkl"
03:38:15 <lambdabot>   ["abc","def","ghi","jkl"]
03:38:26 <tab> mm_freak: btw, are you doing client side smtp or server side ?
03:38:32 <mm_freak> tab: client side
03:38:38 <mm_freak> tab: for now
03:39:05 <tab> mm_freak: ok
03:39:30 <tab> mm_freak: guess it wouldn't be too much of a stretch with enumerator interface to have a server side as well
03:40:02 <tab> really interesting anyway, need to find a way to duplicate my time :)
03:40:24 <mm_freak> tab: well, currently you have parsers for server responses and writers for client requests‚Ä¶  to implement a server you need it in the other direction, so it will roughly double the code size
03:41:17 <tab> mm_freak: yes, but the testing is much easier :)
03:41:41 <mm_freak> tab: i tested against real SMTP servers (and i'm glad i did)
03:42:15 <qfr> Will you hate me if I use regex in Haskell?
03:42:34 <tab> mm_freak: but technically you just need to test one side for real, and the other side can be tested against the tested side :)
03:42:37 <mm_freak> qfr: no, but real parsers are usually preferred
03:42:38 <merijn> qfr: Only if you're trying to do something stupid like parsing HTML
03:42:55 <merijn> Parsing isn't that hard, tbh
03:42:56 <qfr> merijn: I use regex for parsing HTML and XML all the time
03:43:14 <merijn> qfr: No you don't, because that is mathematically impossible
03:43:58 <merijn> Regular expressions can only parse regular grammars (hence the name), HTML and XML are context sensitive and hence not parse-able by regex's
03:44:11 <Twey> I don't know‚Ä¶ I've long suspected that PCREs are a Turing tarpit >.>
03:44:15 <qfr> I believe you are confusing "extracting random bits of data from tag soup" with "creating a consistent tree from markup" :P
03:44:29 <merijn> qfr: That is what "parsing" means
03:44:39 <Twey> qfr: That's not really parsing HTML
03:44:48 <qfr> Oh well
03:44:49 <Twey> That's extracting bits of a string that happens to be in HTML format
03:45:20 <mm_freak> qfr: try using a real parser
03:45:30 <mm_freak> qfr: once understood you will never use regex again
03:46:12 <merijn> Twey: Perl regexes aren't regexes, correct.
03:46:26 <Zao> merijn: Of course, what the common man calls regex tend to be a bastardised "superset" of proper regular expressions.
03:46:28 <qfr> mm_freak I've already used stuff like Nokogiri, Hpricot, REXML with XPath lookups etc
03:46:34 <Twey> Yeah.
03:46:34 <mm_freak> actually regex can be context-sensitive
03:46:37 <mm_freak> but not recursive
03:47:04 <mm_freak> qfr: i'm talking about a monadic haskell parser
03:47:13 <mm_freak> parsec or attoparsec
03:47:30 <dolio> There's a prime recognizer 'regex' out there somewhere.
03:47:35 <merijn> mm_freak: I'm talking about the Chomsky grammar hierarchy. Do explain how regexes can be context-sensitive
03:48:18 <tlonim> dolio: i dont think that holds out everywhere.. otherwise prime detection would have been trivial right
03:48:29 <mm_freak> merijn: maybe i'm talking about a superset of regular expressions
03:48:38 <qfr> mm_freak: I think I will use them more in future but back when I wrote some of these systems I didn't know about them and usually the most difficult part was just copy pasting lots of stuff and replacing some things to extract data, with XPath lookups and such it would take even longer
03:48:47 <dolio> tlonim: I mean a Perl regex. They aren't really regular expressions.
03:48:58 <qfr> mm_freak: Oh well I don't know Haskell yet really and are those even things which deal with tag soup?
03:49:00 <merijn> mm_freak: You probably are, because regular expressions are isomorphic with the set of regular grammars
03:49:00 <tlonim> dolio: ah.those ..
03:49:16 <qfr> Almost everything I deal with is not standard compliant markup and contains syntax errors, mm_freak
03:49:19 <tlonim> dolio: isnt that based on binary representation of number ?
03:49:40 <mm_freak> qfr: then write an error-tolerant parser‚Ä¶  we've had that topic earlier =)
03:49:53 <dolio> I didn't investigate it much. It might even be unary. I can't remember.
03:50:26 <qfr> mm_freak so those aren't error tolerant ones?
03:50:43 <qfr> Oh, you mean you want me to write my own parser using those?
03:50:50 <qfr> I thought they already supported HTML and such
03:51:07 <qfr> In Nokogiri and those other libraries you can perform lookups by CSS tags
03:51:25 <qfr> I used that stuff to make the LaTeX version of Learn You A Haskell btw
03:51:27 <mm_freak> no, parsers are for parsing stuff (mostly text)
03:52:58 <mm_freak> when i talk about "writing a parser" then you have to parse yourself, otherwise i would talk about "using a parser" =)
03:53:42 <j-invariant> Where do adjunctions come up in haskell?
03:54:04 <j-invariant> are they like a version of Monad but closer to the metal?
03:54:29 <isp_> There's a thought that's been nagging me, but it almost seems too good to be true -- Is Haskell a better XML than XML? Could Haskell replace XML?
03:54:39 <ddarius> isp_: No and no.
03:54:44 <isp_> why?
03:55:12 <qfr> You want to serialise data as Haskell source code?
03:55:20 * qfr is dealing with 20-30 MiB XML files atm
03:55:30 <ddarius> isp_: Is C a better XML than XML?  If the answer to that is "Yes" feel free to change my original response to "Yes and no."
03:56:01 <qfr> And then you want to parse this... how? By compiling it and using it as a module within Haskell? O_O
03:56:02 <isp_> Well it's not about the serialization, but that would be a possibility
03:56:57 <qfr> That reminds me of that stuff which embeds resources by converting icons to C and such
03:56:59 <triyo> I have a list and I need to 'take' 1 element and drop the next 'n' number of elements and then repeat the process for all remaining elements in the list... Is there an existing list function or combinator that can do this or shall I write one myself?
03:57:34 <isp_> ddarius: I couldn't see C replacing XML. But Haskell is a language for denoting things, right? So why I just represent the entire world as a system of interrelated Haskell objects?
03:57:45 <isp_> why couldn't*
03:58:33 <qfr> isp_ how do you intend to use the files? Run-time compilation of Haskell code and then using it in some sandbox?
03:59:46 <tlonim> qfr: you mean xpm ? that is nice for small images
04:00:03 <ddarius> isp_: Why couldn't you do that with C?
04:00:44 <isp_> qfr: not in any immediate practical application. I was just thinking. If Haskell is a language to construct data objects, of which a program is one type, why couldn't I interpret Haskell not as a programming language but just as a data description language? It seems natural.
04:01:24 <isp_> ddarius: well I guess you could do it in anything, but it doesn't make as much sense in C.
04:01:31 <qfr> I'd say that Haskell is much more powerful and has totally different purposes from something like XML
04:01:50 <j-invariant> isp_: it does more than construct the data objects: You can compute with them too
04:02:06 <isp_> j-invariant: precisely, so that makes them composable.
04:02:31 <tlonim> isp_: but wrt storage/persistence, two things matter - size and interoperability among other languages
04:02:59 <tlonim> wrt size, compared to json etc, it will be inefficient unless u want to store types and so like protocol buffers
04:03:26 <tlonim> and interoperability ..well. no there too if you are talking about serializing haskell code to file
04:04:02 <isp_> tlonim: what do you mean by interoperability? is it any less interoperable than XML?
04:04:34 <qfr> isp_: What do you do when you want to load and use it in C, C++, Java?
04:04:36 <tlonim> isp_: XML is a standard representation.. serialized/haskell code isnt
04:04:48 <flux> I like my data formats non-turing-complete, thank you very much :)
04:05:08 <tlonim> isp_: so yes.. but my first point of efficeint packing is more pertitnet
04:05:16 <qfr> flux haha
04:05:18 <tlonim> something like binary json is even better
04:05:27 <isp_> qfr: same as what I do in XML; I would need some sort of importer
04:05:38 <qfr> Let's replace XML with x86 binaries!
04:05:49 <qfr> You say XML? I say AMD64 ELF
04:05:52 <flux> atleast parsing would be faster
04:05:55 <qfr> Hahaha
04:06:07 <flux> (if you have the same platform)
04:06:14 <isp_> tlonim: (1) I know, I was thinking about just intrinsic merits of the notation (2) I didn't really understand your point about packing, sorry
04:06:17 <qfr> Arguably, there might be some speed concerns
04:06:27 <qfr> flux we could use LLVM assembly, I suppoe
04:06:29 <qfr> suppose*
04:07:03 <qfr> Then it would with like ARM at least
04:07:12 <isp_> is the point just that you need a lot of characters to represent some information?
04:07:25 <qfr> XML is super redundant
04:07:28 <tlonim> isp_: packing == overhead (total - minumum space used for actual data) /total * 100
04:07:50 <tlonim> lets be clear here :) ..XML is bloat 
04:08:37 <isp_> I don't understand then, explicitly what is the packing then>
04:08:46 <j-invariant> anyone know MU AGDA?
04:08:52 <tlonim> i mean with xml for say a tree of degree 3 and depth 100, imagine all wasted space in '<' '>'  other symbols ..
04:09:11 <isp_> you would need to carry GHC around?
04:09:51 <Twey> j-invariant: #agda?
04:09:51 <tlonim> isp_: no. basically i meant you should use as  minimal a representation as possible 
04:10:09 <j-invariant> not agda
04:10:19 <isp_> tlonim: haskell is not a more minimal representation than XML?
04:10:19 <tlonim> whcih xml is not..and haskell (without types etc) is also not
04:10:30 <Twey> Alright then‚Ä¶ I don't know it ‚ò∫
04:10:30 <isp_> tlonim: oh so you're saying JSON is better than both
04:10:38 <tlonim> isp_: it is ..but may not be minimal than rest
04:10:48 <tlonim> depends on requirements
04:11:04 <tlonim> basically for type info, protocal buffers are used
04:11:30 <Twey> http://inglorion.net/documents/designs/ffff/ ‚Äî FFFF is the way to go
04:12:06 <mm_freak> tlonim: so for every type you use you'll want to write a compact bijection between the natural numbers and that type
04:12:18 <mm_freak> that gives you the most minimal representation
04:13:39 <mm_freak> XML has an ugly syntax, but other than that it's fine
04:13:47 <tlonim> mm_freak: well.. it should be amenable to new types being introduced and all.. so a static bijection may not do. i am not deeply familiar with protocol buffers..should check though
04:14:01 <mm_freak> if you want to make it smaller, use compression, because size is a separate concern
04:14:19 <isp_> tlonim: okay, so let's assume that we can tweak haskell's syntax so that it uses not a lot of space to express type definitions. I'm more interested in the intrinsic merits of the language
04:14:23 <mm_freak> the highest priority is easy of use
04:14:28 <isp_> precisely
04:14:36 <mm_freak> easy ‚Üí ease
04:15:15 <mm_freak> there is a good reason why most standard formats are text formats
04:15:39 <tlonim> mm_freak: isp_  http://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking ..
04:15:44 <isp_> all other things being equal, is haskell [the system of abstractions] better than XML [the system of abstractions] as a language to represent interrelated data?
04:15:55 <Jonny3> Am I able to simplify         f x	 = map colour ( base3 x 2 )        using function composition?
04:16:11 <tlonim> they have compared there 10-20 persistence mechanisms
04:16:51 <isp_> ddarius: I'd be interested to hear your reasoning
04:17:27 <Xilon> Jonny3: maybe map colour . (flip base) 2
04:17:54 <mm_freak> isp_: i think yes
04:18:02 <Jonny3> yeah I thought that maybe
04:18:07 <Xilon> @pl f x  = map colour ( base3 x 2 )
04:18:07 <lambdabot> f = map colour . flip base3 2
04:18:11 <merijn> @pl \x -> map colour ( base3 x 2 )
04:18:11 <lambdabot> map colour . flip base3 2
04:18:12 <Xilon> well there you go :)
04:18:36 <mm_freak> haskell gives you type safety and can express more
04:18:41 <merijn> Random question: How does @pl work?
04:18:50 <mm_freak> merijn: rewrite rules
04:19:06 <Xilon> merijn: You can have a look at the source code. It's the pointfree package
04:19:32 <mm_freak> map colour . (`base3` 2)
04:19:33 <isp_> and also you only need one language; e.g. instead of XQuery just used the monad syntactic sugar
04:21:30 <tlonim> isp_: the idea of data as code can have another implication
04:21:38 <tlonim> that is of sanitizing it
04:21:50 <isp_> validation = type checking?
04:21:52 <tlonim> otherwise it can have untoward results
04:21:57 <isp_> oh
04:22:36 <tlonim> isp_: yeah..type checking should do i guess. 
04:22:55 <mm_freak> i think the question is very related to this one:  should we use relational databases or databases with a more straightforward representation of what we want?
04:23:33 <tlonim> isp_: mm_freak i would love to see any example of this being done...to see how it will fare with generic data structures and ..
04:23:47 <mm_freak> tlonim: what exactly?
04:24:29 <tlonim> mm_freak: of what isp_ is asking.. of serializing haskell data in plain and deserializing with structure and type validating it 
04:24:55 <mm_freak> tlonim: just look at the default Read and Show instances of most base datatypes
04:25:12 <tlonim> ok
04:25:22 <mm_freak> > read "((3, 4), \"haha\")" :: ((Int, Int), String)
04:25:23 <lambdabot>   ((3,4),"haha")
04:25:51 <mm_freak> > read "((3, 4), \"haha\", Left 3.4)" :: ((Int, Int), String, Either Float String)
04:25:52 <lambdabot>   ((3,4),"haha",Left 3.4)
04:26:06 <isp_> it gets interesting when you mandate that names be valid URLs also
04:26:25 <isp_> my crazy idea is to model the entire world as a haskell program
04:26:50 <isp_> no "main", just structures to evaluate in response to HTTP GET or whatever
04:27:23 <mm_freak> what are you doing anyway?
04:27:43 <isp_> me? nothing yet, just wondering
04:27:45 <tlonim> mm_freak: i meant in comparison with other types like the benchmark above..
04:28:06 <tlonim> so with IO in between
04:28:07 <mm_freak> tlonim: dunno, it's not the way i do things usually
04:28:24 <mm_freak> i use parsers, iteratees and builders
04:28:30 <tlonim> mm_freak: yeah..me neither.. isp_ seems to be the curious about it..
04:29:27 <isp_> it's been on my mind for a few months
04:35:14 <isp_> do I have this right: IO is an ordinary type that represents "programs" in Haskell, and GHC knows how to take anything of type IO and turn it into a program?
04:35:40 <sipa> yes, except it's the runtime system and nog GHC
04:35:45 <sipa> *not
04:35:57 <isp_> oh, what's the difference?
04:36:20 <sipa> the runtime is something that is linked together with your program
04:36:46 <isp_> so GHC turns the source into some more efficient representation that is interpreted by the runtime system?
04:36:55 <sipa> that's one way to see it
04:37:07 <merijn> isp_: It's not interpreted though, it's compiled to machine code
04:37:19 <isp_> the runtime system compiles to machine code?
04:37:30 <sipa> no, ghc compiles your program to machine code
04:37:46 <merijn> isp_: GHC compiles to machine code (or can compile to), the runtime system is just a dynamically linked library
04:37:47 <isp_> so... where does the runtime system come in?
04:37:56 <isp_> oh
04:37:59 <isp_> okay, thanks
04:38:28 <merijn> isp_: Sorta like how the C stdlib forms a layer between your program and the actual machine.
04:39:24 <isp_> so why: "yes, except it's the runtime system and not GHC"
04:39:28 <merijn> Your code calls the C stdlib, the stdlib calls the OS, which actually controls the machine. In the Haskell case you code calls the Haskell Prelude, which calls the runtime, which deals with the big bad outside world (i.e. OS etc)
04:39:47 <isp_> oh, got it
04:39:52 <isp_> thanks, that helps
04:40:14 <merijn> The runtime knows how to use IO, GHC does not. But since we tell GHC "Here, this library knows how to do it" GHC just links your code with the runtime
04:40:50 <sipa> isp_: ghc creates a binary which represent an efficient way in machine code for (lazily) evaluating your "main", and the runtime system "interprets" the result of this main, doing callbacks to your program as necessary
04:41:32 <isp_> so how does ghci work?
04:43:31 <merijn> AFAIK it dynamically compiles code and links it as a dynamically linked library, the same way you could exec gcc to create a .dll/.so and load the resulting file
04:53:08 <Jonny3> I miss haskell's conciseness in java
04:54:17 <edwardk> jonny3: you can get some of it back with scala, but its still a big ml'ish hack ;)
04:54:25 <ddarius> edwardk: Do you remember at least whereabouts the restaurant was?
04:55:16 <edwardk> ddarius: fraid not, the entry in my phone reverted when it accidentally sync'd and wiped you out of my contacts
04:55:44 <edwardk> its in a neighborhood of boston that begins with a b, brighton i think ;)
04:56:21 <ddarius> edwardk: That may indeed be helpful.  Thanks.
04:58:33 <copton> is there something like references in Haskell? If I have a set of objects and want to relate them with each other, in other languages I would have a set of reference-reference-tuples. What's the Haskell way for this?
04:59:28 <Xilon> Relating the values doesn't suffice?
05:01:51 <Saizan> there are references: Data.IORef, but i don't think they are what you want there
05:09:49 <monadic_kid> Xilon: that can be a problem if you're dealing with stateful computations, you can quite easily end up with reference retaining older values
05:11:01 <monadic_kid> Xilon: unless you meant something else
05:11:58 <Xilon> Nope, just meant foo = 2; bar = 5; refs = (foo, bar)
05:12:38 <copton> if I look how Data.Graph works, then for every vertex there is a list of vertices. And a vertex is an Int, thus serving as a reference. But is there no built-in support?
05:13:31 <monadic_kid> copton: you can do what Xilon said but if you're dealing with stateful computations you need to be careful
05:16:02 <monadic_kid> copton: some other things you can do is: maps, indices, guids, STRef, IORecf the last two are real mututable references ST version is restricted to only mutating values and no other side-effects where as IO you can fire misslies using them and use them for global varibles, etc.
05:17:52 <monadic_kid> copton: well they are both restricted to Monads so you're not free to use them in pure functions without escaping those monads
05:18:58 <monadic_kid> copton: there are also various types of arrays in haskell, both mutable and immutable and different levels of control of effects
05:20:47 <monadic_kid> copton: actually you've got MVar and TVar and some libraries for functional references as well
05:22:05 <turiya_> is foldl1 the same as foldl'? Some tutorials on the web ask to use foldl' in the place of foldl to avoid stack overflow but I was unable to find foldl' ..
05:22:17 <hpc> @src foldl'
05:22:18 <lambdabot> foldl' f a []     = a
05:22:18 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:22:21 <hpc> @src foldl1
05:22:21 <lambdabot> foldl1 f (x:xs) = foldl f x xs
05:22:21 <lambdabot> foldl1 _ []     = undefined
05:22:53 <turiya_> :i foldl' does not work in ghci
05:23:13 <monadic_kid> turiya_: :m + Data.List
05:23:35 <turiya_> oh.. 
05:24:21 <turiya_> ok, foldl' is now visible :)
05:25:03 <mux> yay, my code for NFAs / DFAs / Levenshtein automata seems to work fine :-)
05:35:28 <Xilon> @src foldl
05:35:29 <lambdabot> foldl f z []     = z
05:35:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:35:38 <Xilon> what's the point of fold1?
05:35:46 <j-invariant> it is used to write other functions
05:36:05 <Twey> Xilon: It's about the order of application
05:36:25 <Twey> > foldr (+) z [a, b, c] :: Expr
05:36:26 <lambdabot>   a + (b + (c + z))
05:36:31 <Twey> > foldl (+) z [a, b, c] :: Expr
05:36:32 <lambdabot>   z + a + b + c
05:36:45 <Twey> Okay, that's not terribly illustrative
05:36:59 <Twey> Think ((z + a) + b) + c
05:37:19 <azaq231> foldl1 folds with no default value, assuming the list has length >= 2. foldl' is just a strict version of foldl
05:37:38 <Twey> (+) is commutative so it doesn't matter much, but for some functions it makes a big difference
05:37:39 <azaq231> oh sorry had the window scrolled up still, though the question was new
05:37:39 <ski> > foldr (\n s -> concat ["(",show n," + ",s,")"]) "0" [2,3,5]
05:37:40 <lambdabot>   "(2 + (3 + (5 + 0)))"
05:37:51 <ski> > foldl (\s n -> concat ["(",s," + ",show n,")"]) "0" [2,3,5]
05:37:52 <lambdabot>   "(((0 + 2) + 3) + 5)"
05:38:20 <ddarius> > foldl1 (+) [1]
05:38:21 <lambdabot>   1
05:38:23 <Twey> ski: SimpleReflect was way easier :√æ
05:38:32 <Twey> I think the ‚Äò1‚Äô was a typo.
05:38:46 <ski> Twey : but it didn't add the brackets you wanted, there
05:38:52 <Twey> Xilon: It's foldl (fold-ell, for ‚Äòleft fold‚Äô) not fold1 (fold-one)
05:38:58 <Twey> ski: Ah, fair enough
05:39:07 <Twey> I should have just redefined (+)
05:39:09 <Xilon> It was a typo but it was meant to be foldl1 :P
05:39:28 <Twey> > let infix 4 +; (+) = undefined in foldl (+) z [a, b, c] :: Expr
05:39:29 <lambdabot>   *Exception: Prelude.undefined
05:39:33 <Twey> Damn
05:39:39 <Twey> > let infix 4 +; (+) = (Prelude.+) in foldl (+) z [a, b, c] :: Expr
05:39:40 <lambdabot>   z + a + b + c
05:39:50 <Twey> Surely that's not meant to happen
05:40:12 <Twey> I thought specifying ‚Äòinfix‚Äô rather than infixl or infixr made a + b + c an error
05:40:20 <ski> > foldr f z [a,b,c] :: Expr
05:40:21 <lambdabot>   f a (f b (f c z))
05:40:23 <ski> > foldl f z [a,b,c] :: Expr
05:40:24 <lambdabot>   f (f (f z a) b) c
05:40:32 <Twey> Xilon: Oh ‚Äî the -1 versions of the folds are just convenience functions for when you know you have a non-empty list
05:40:49 <Twey> Xilon: foldl1 f (z : xs) = foldl f z xs
05:42:06 <ski> Twey : the fixity for `+' is only locally associated with the lexically scoped identifier `+' -- only the function itself is passed, though, and that one uses the `Num Expr' instance
05:42:09 <Twey> foldl1 = list (error "Empty list") . foldl
05:42:13 <Xilon> Yeah. Haven't found a need for that yet, though I guess it's useful even in foldl (+) 0 xs 
05:42:20 <Twey> ski: Oh, right.  Of course.
05:42:36 <Twey> Xilon: Funny, I found it the other way around
05:43:09 <Twey> When I started, I was constantly using foldl1, and got plenty of ‚Äòempty list‚Äô errors as a result ;)  It was only later that I learnt to use the zero properly.
05:43:33 <Xilon> hah :) lucky me then
05:43:56 <Xilon> Actually I think that's what Perl's 'reduce' (it's version of foldl) does, and I found it odd
05:44:01 <Xilon> its*
05:44:13 * ski hsa sometimes wanted convenience functions (well, *function*, for `foldr') for when you know you have an infinite list
05:44:17 <Twey> What, foldl1?
05:44:19 <Xilon> I had to actually inject a value into the list to get the default :S
05:44:21 <Xilon> yeah
05:45:13 <Twey> It kind of makes sense for foldl, because you can just cons on another value
05:45:18 <Twey> Not so much for foldr
05:45:29 <ski> what makes sense for `foldl' ?
05:45:40 <Twey> ski: Having the -1 version be the default
05:45:40 <daedra> can anyone explain dependent typing to me? Wikipedia's take on the topic is quite complicated for me. According to this article, Haskell is heading towards supporting Dependant Typing.
05:45:53 <daedra> http://axisofeval.blogspot.com/2011/01/why-lisp-is-big-hack-and-haskell-is.html
05:46:06 <Twey> daedra: I think the decision has been explicitly made to not head into dependent types.
05:46:14 <ski> Twey : i'm not sure why you'd want that
05:46:25 <daedra> oh
05:46:36 <Twey> ski: Well, because then you don't need the explicit-zero version
05:46:43 <Xilon> ski: I just mentioned that in Perl the 'reduce' function is foldl1 (there's no foldl as far as I'm aware)
05:46:55 <Twey> ski: You can just write foldl f (z : xs) instead of foldl f z xs
05:47:25 <Twey> (not that I'm actually advocating this; breaking the symmetry is not so nice, but I can understand why they might do it)
05:47:39 <Xilon> Well it is Perl :)
05:48:16 <xenyl> Xilon: lol
05:48:38 <mux> this blog post is quite inaccurate
05:48:51 <Twey> Yeah, it's a load of old tosh
05:49:02 <mux> "Haskell's type-classes support what some people call "duck typing", without the dynamism and unsafety."
05:49:06 <Twey> Haskell is already ‚Äòadjustably-safe‚Äô
05:49:08 <mux> that one is particularly wrong
05:49:23 <mux> he meant "Go's structural subtyping"
05:49:30 * Twey doesn't speak Go
05:49:46 <mux> or any language tht supports structural subtyping, actually
05:49:55 <dolio> daedra: Dependent types allow types to depend on values, and let, say, the result type of a function depend on the argument value.
05:50:53 <mux> also, Haskell growing more support for type-level computations doesn't make it a dependently typed language
05:51:17 <ski> Xilon : hm, is that similar to the SRFI-1 <http://srfi.schemers.org/srfi-1/srfi-1.html#reduce> version of `reduce' ?
05:51:22 <Twey> mux: Well‚Ä¶ *indirectly* they do support duck-typing
05:51:22 <mux> hopefully, or I wouldn't even be able to use it :-)
05:51:32 <Twey> As in, you can build duck-typing on top of them
05:51:39 <mux> Twey: the whole point of duck typing is that 'direct' bit
05:51:49 <ddarius> Twey: I don't think there has an "explicit" decision, though I don't think it being explicit is necessary.  Also, the author of that blog post explicitly conflates Haskell with a bunch of other dependently typed languages.
05:51:54 <Twey> I don't know‚Ä¶ I'm cautious of questioning Peaker's assertions :√æ  You should ask him :√æ
05:52:04 <ski> Twey : you can't write `foldl f (z : xs)' if the type of `z' doesn't match the type of elements in `xs'
05:52:16 <Twey> ski: Not an issue in Perl
05:52:35 <ski> Twey : i know, that was re your Haskell suggestion
05:52:50 <Twey> Oh, no, it wasn't a suggestion and it wasn't based on Haskell
05:53:12 <Twey> I was just saying that I can understand why some dynamic languages (such as Perl) might do that
05:53:28 <ski> oh, i'm sorry, then ; "You can just write foldl f (z : xs) instead of foldl f z xs" sounded like a Haskell suggestion to me
05:53:37 <tac-tics> This blogpost is kind of weak
05:53:51 <Twey> Perhaps using Haskell syntax was confusing, but I don't know Perl syntax all that well (but then again, who does?  ;) )
05:54:14 <Twey> daedra: We Are Not Amused.
05:55:13 <daedra> Twey: I didn't suggest you be amused.
05:55:17 <tac-tics> Are there any docs on the ghc core language?
05:55:19 <daedra> what have I done now..
05:55:41 <Xilon> ski: No, it doesn't he the ridentity bit. Just reduce f xs: http://search.cpan.org/~gbarr/Scalar-List-Utils-1.23/lib/List/Util.pm
05:55:45 <Xilon> have*
05:56:53 <dolio> Does perl have inductively defined/linked lists such that (z:xs) isn't an O(n) operation?
05:57:25 <quuuux> dolio: I've no doubt it's on CPAN somewhere
05:57:51 <quuuux> IIRC, perl's (usual) 'lists' are arrays, though
05:58:15 <dolio> Well, what matters is the list for which people were discussing foldl above.
05:58:17 <Xilon> Yeah a more likely implementation
05:58:46 <Xilon> dolio: I bet that reduce uses a foreach loop under the hood
05:59:24 <Xilon> Which is likely just sugar for C-style iteration
06:00:59 <ski> hm .. "anything with a quack method will work" sounds like the object system of OCaml (and, at least partially, like Trex in Hugs) -- in short, records with row polymorphism
06:01:03 <turiya> is there was a simple way to convert a list "lis = [1..100]" into a function such that f(i,j) = lis !! (10*i + j), the function f :: (Int.Int) -> a ?
06:01:10 <balor> Given a monad such as IO, where I have an ¬´IO String¬ª, rather than lifting functions to the monad, is it possible to "get the string out of IO".  The purpose would be to store in a database.
06:01:21 <dolio> daedra: Anyhow, for a useless example, you could have a functions like:  f : (b : Bool) -> if b then Int else Char ; f True = 0 ; f False = 'z'
06:01:34 <dolio> That's a dependently typed function.
06:02:03 <Xilon> balor: In the IO monad just use bind or do notation. You need to use IO to store in a database anyway
06:02:07 <ski> Xilon : ok
06:02:56 <applicative> balor, getLine a >>= storeInDatabase 
06:03:23 <ddarius> turiya: You just wrote it.
06:04:04 <turiya> ddarius: hmm, i thought so initially but what about the values of the functions at other integer points?
06:04:09 <ddarius> balor: There isn't any "String" "inside" the IO action.
06:04:23 <dolio> daedra: A less useless, but still not really very interesting example is printf. It takes a format string and then takes arguments depending on that string.
06:04:24 <ski> turiya : `renameMe lis = f where f (i,j) = lis !! (10 * i + j)' ?
06:04:29 <ddarius> turiya: What do you want to happen then?
06:05:04 <turiya> the function has to have zero values there..
06:05:35 <ddarius> turiya: Then add a check that i and j and in bounds and if not return zero.
06:07:12 <ski> dolio : `zipWithN' ?
06:07:23 <j-invariant> what's the point of Dialectica interpretation
06:07:34 * ski 'd like to know that, as well
06:07:59 <mux> ZipList and Applicative lets you have zipListN
06:08:13 <ski> (da Paiva related it to Chu spaces, but presumably G√∂del had some original motivation)
06:08:31 <ski> mux : not directly
06:08:35 <dolio> ski: I've written it, and it doesn't end up that great.
06:08:37 <mux> yep
06:08:45 <applicative> > let turiya (i,j) = if (10 * i + j)  < 100 then  [1..100] !! (10 * i + j) else 0 in map turiya [(0,9), (2,2),(2,3),(19,1), (2, 300)]
06:08:46 <lambdabot>   [10,23,24,0,0]
06:09:05 <ski> dolio : you have to write in CPS, or what ?
06:10:04 <dolio> In my experience, it's difficult to write something that works well with just 'zipWith n l1 l2 l3 ...'.
06:10:21 <yrlnry> r.
06:10:27 <dolio> It's more like you have to provide it with a list of types you want to work with, not a natural number.
06:10:47 <ski> can't those be implicit ?
06:11:03 <dolio> Maybe my kung fu was too weak at the time, though.
06:13:01 <turiya> thanks all, i feel the power of functional programming :). Can the same be done in C? i.e. returning a function from a function which accepts an array?
06:13:19 <ddarius> turiya: Not in general.
06:13:32 <Xilon> You could use function pointers, but it's not nearly as clean
06:13:59 <turiya> ddarius: can it be done in some specific cases then?
06:14:08 <Xilon> Don't think there's any way to form a closure
06:14:19 <ski> you can simulate it
06:14:20 <ddarius> Xilon: Even using function pointers wouldn't completely work unless you used some static variables, but then you get conflicts.  You could pass in the "environment" but then you might as well just pass in the original array to begin with.
06:14:30 <ski> (but you have to keep track of resources yourself)
06:15:09 <ski> ddarius : well, in some cases you might want to conform to a pre-existing interface
06:15:36 <ddarius> ski: In those cases you are screwed in general unless you do what GHC does.
06:16:10 <ddarius> Though most such interfaces do have a "user data" argument as well.
06:16:39 <ski> ddarius : do you mean trouble with responsibility for who should reclaim the memory resources when ?
06:16:52 <ddarius> No.
06:17:21 <qfr> I just generate new x86 opcodes in C on the fly
06:17:24 <qfr> To get closures
06:17:25 <ddarius> I guess you could have a static map of some sort and that works.
06:17:32 <ddarius> qfr: That's what GHC does.
06:18:31 <ddarius> Ah, but you'd still need to pass in the "key" for each invokation.
06:19:01 <applicative> j-invariant http://plato.stanford.edu/entries/goedel/#GodWorIntLogAri 
06:19:10 <ski> ddarius : hm, then maybe you could elaborate more on the problem you had in mind ?
06:19:20 <ddarius> ski: With which?
06:19:52 <ski> simulating a closure, to conform to a pre-existing interface
06:20:27 <ddarius> If there is no "user data" argument, then you can't pass in an environment.  If there is, then this falls under the latter part of my statement to Xilon.
06:22:43 <ski> ddarius : if the pre-existing interface wants a function (pointer), then you can't pass in an array there instead .. so i don't see your point
06:23:36 <ddarius> ski: My point is if the original interface wants a function pointer solely, then you can't make a function that will take an array and produce a function that will use it that you can then pass to that interface.
06:23:51 <ski> yes, i agree with that
06:24:01 <ddarius> ski: At any rate, I wasn't trying to solve your problem when I made the first comment.
06:24:05 <ski> i didn't understand the latter part, though
06:25:18 <ski> (i.e. the "You could psas in the \"environment\" but then you might as well just pass in the original array to begin with." part)
06:28:11 <ddarius> God I hate Tcl/Tk.
06:28:31 * hackagebot applicative-extras 0.1.8 - Instances for Applicative  http://hackage.haskell.org/package/applicative-extras-0.1.8 (ChrisEidhof)
06:32:28 <ddarius> God I hate Tcl/Tk.
06:38:51 <copumpkin> God ddarius hates Tcl/Tk.
06:40:09 <sioraiocht> ddarius is a god?
06:40:28 <Jafet> That can't be, I thought Morgan Freeman is god!
06:40:42 <Jafet> Unless ddarius is Morgan Freeman...?
06:41:02 <Xilon> _a_ god :P
06:41:02 <qfr> Are you saying that ddarius is a figment of our imagination?
06:42:28 <pastorn> hahaha, haskell is doomed to succeed: http://axisofeval.blogspot.com/2011/01/why-lisp-is-big-hack-and-haskell-is.html
06:42:35 <Jafet> Well, if I was god, I'd smite tcl/tk.
06:43:14 <aristid> pastorn: i don't get the obsession with dynamic typing though. i just don't see a need for it
06:43:34 <pastorn> me neither, but maybe we've just had too much kool-aid
06:43:40 <aristid> heh
06:43:55 <opqdonut_> heh
06:44:13 <Jafet> Too much kool-aid!?
06:44:25 <pastorn> but one thing that i miss in haskell is replacing function definitions at runtime
06:44:37 <aristid> Jafet: because it tastes like shit?
06:44:40 <pastorn> i don't know how it's done in lisp, but i know what it can be done
06:44:59 <pastorn> python and erlang supports it as well, well (ruby?)
06:45:07 <pastorn> anyway, it seems optimal for prototyping stuff
06:45:21 <aristid> pastorn: i don't think it would be completely impossible, if the compiler supports it
06:45:36 <pastorn> aristid: i know it can be done with hs-plugins
06:45:48 <pastorn> but i don't get the feeling that it's as convenient
06:46:09 <Jafet> pastorn: what would be the semantics for replacing functions at runtime?
06:46:11 <Xilon> pastorn: uhh you just redefined stuff in lisp, because it's mutable
06:46:31 <Xilon> Or do you mean implementation-wise?
06:46:31 <Jafet> (If you figure it out, you could tell manatee, because he seems to be having an ad-hoc approach to it)
06:46:47 <pastorn> Jafet: i can't really say, i don't know how the syntax tree looks
06:47:10 <Jafet> The mechanism is irrelevant if you can't even figure out what semantics should be used
06:47:11 <pastorn> Jafet: but something like reloadDefinition X.Y.functionZ
06:47:26 <pastorn> as long as the type is intact it could work
06:47:36 <pastorn> (i dunno, just guessing here, really)
06:48:07 <Xilon> The type is likely to change though
06:48:28 <ddarius> If you simply store your functions in IORefs you can swap them out whenever you like.
06:48:32 <Jafet> What about existing thunks to the function? You have to address the problem of multiple functions existing and supposedly implementing the same thing... or not
06:48:34 <quuuux> oh, hey, something relevant: how bitrotted is hs-plugins at the moment? I'm working on hotswapping for my Haskell MUD server, and I need some way of dynamically reloading code (of course)
06:48:35 <pastorn> Xilon: yeah... maybe it needs a recursive call down the syntax tree
06:48:54 <aristid> pastorn: i think, semantically it would replace the program with another program where all existing parts have the same types, and preserve IO state
06:50:01 <pastorn> aristid: yeah, that being the idea...
06:50:11 <pastorn> persistent state over a reload
06:50:44 <pastorn> maybe you if it got factored into an init phase and a mainloop phase and then you could just reload the main phase definitions
06:51:11 <aristid> put all top-level definitions in unsafePerformIO . readIORef
06:51:37 <pastorn> so one part setting up variables, then mainLoop which takes all these vars in IORef or TVar or wahtever, and then a reload function which can add newly initialized variables to the call to the mainloop
06:51:52 <pastorn> aristid: hehe
06:52:59 <Xilon> Might be worth checking out how Erlang hotswaps, though it's probably built into the runtime
06:53:49 <Jafet> I think we should first work out a good monad transformer library before venturing into these things
06:54:54 <Xilon> pish posh
06:57:54 <Jafet> Erlang is imperative and only supports hot swapping entire modules
06:58:15 <Jafet> Presumably a lot of overhead is involved to support that
07:01:09 <Saizan> it'd prevent inlining at the boundaries where you want to support hot-swapping, at least, though a jit could re-inline on the fly
07:01:16 <augur> cads: what game library thing
07:01:27 <ddarius> If you can (de)serialize functions, then you can get a hotswap effect in a message passing system like Erlang by simply tail calling a passed in "new body" message.
07:02:12 <aristid> i don't think erlang uses the message passing system to do it
07:02:30 <ddarius> aristid: It doesn't but Erlang programmers do.
07:03:04 <ddarius> The original Erlang didn't have first class function and even when they were added they weren't able to be serialized for quite some time.
07:03:50 <Saizan> you don't even need to be able to serialize functions to link in some code and send it down a Chan
07:05:47 <Jafet> Surely the runtime has to do it if the code is being sent to another computer
07:07:41 <Saizan> ah, the discussion was about distributed hot-swapping?
07:08:17 <ddarius> Saizan: Not explicitly, but technically an object file is a serialized version of (multiple) functions and linking is deserialization.
07:08:37 <Jafet> Erlang was designed from the start for distributed systems.
07:08:55 <Jafet> Oh, you're talking about Chan as in Chan
07:13:45 <Saizan> ddarius: that object file is produced from source code, which is already a serialized format for me, so in the end we're only deserializing :)
07:14:45 <ddarius> Saizan: That's not true.
07:15:17 <ddarius> In languages like Smalltalk or Common Lisp (really their environments), there may not be any source code that corresponds to a method/function.-
07:20:55 <Saizan> in haskell too, but you can't dump them to disk, yet the above procedure for hot-swapping would work
07:23:38 <quuuux> @pl \ x -> f x >> g
07:23:38 <lambdabot> (>> g) . f
07:55:37 <alios> hi is there anyone who can help me to undersand this template/class method issue while using happstack? https://gist.github.com/763597 
07:59:49 <Saizan> why are you defining test as the method of a type class?
08:06:26 <SonOfLilit> Hi, All!
08:07:07 <SonOfLilit> I'm having a problem with persistent-postgresql
08:07:15 <SonOfLilit> or probably one of the libraries it builds on
08:07:32 <SonOfLilit> error messages by PostgreSQL are "mumbled"
08:07:37 <Jafet> (Who's Lilit? Lilith?)
08:07:51 <SonOfLilit> by which I mean, are printed with lots of ellipses instead of in full
08:07:54 <SonOfLilit> like
08:07:55 <SonOfLilit> SqlError {seState = "42P01", seNativeError = 7, seErrorMsg = "execute: PGRES_FATAL_ERROR: ERROR: relation \"IpMap\" does not exist\nLINE 1: ...egistry\",\"country2\",\"country3\",\"countryLong\" FROM \"IpMap\" WH...\n ^\n"}
08:09:06 <SonOfLilit> Michael says this is what postgresql gives, but I find that hard to believe - as searching the web for similar errors seen through bindings of other languages finds only full messages
08:10:23 <SonOfLilit> Jafet: My mother
08:10:30 <phao> the haskell book I'm reading has this: cls = putStr "\ESC[2J"
08:10:37 <phao> the purpose is to clear the screen
08:10:42 <phao> is this valid for all systems? termials, etc.
08:10:43 <phao> ?
08:10:49 <SonOfLilit> it's a word play, as "Son of Lilith" in hebrew is a way to translate elf
08:11:08 <alios> Saizan: yes... 
08:11:17 <Jafet> I'd just never seen it transliterated as "Lilit"
08:11:23 <quuuux> SonOfLilit: interesting. In Hebrew, are elves viewed as a type of lesser demon?
08:12:09 <SonOfLilit> quuuux: it was a translation decision by the translator who did the first Tolkien translation
08:12:24 <SonOfLilit> at least she did view them as demons of some sort :)
08:12:36 <gwern> hm. could someone with ghc 7 check whether Control.Monad.void exists for them?
08:12:39 <Saizan> alios: i asked why.., anyhow if you define test as a standalone function it works
08:12:41 <alios> Saizan: thought a class would be a nice place to define those methods which don't affect the foo (the type dependend part of the component)....
08:12:47 <Jafet> phao: that's an ANSI escape code, so it works with any terminal which uses those codes.
08:13:12 <Jafet> > ord . "\ESC"
08:13:13 <mux> gwern: it does
08:13:14 <lambdabot>   [27]
08:13:25 <Saizan> alios: you can have polymorphic functions without putting them in a typeclass
08:13:33 * Jafet needs to read about the haskell string literal syntax
08:13:35 <SonOfLilit> which makes sense with the way jewish folk tradition treats "demons" to mean "everything else", as far as I know (I have little knowledge in jewish folk trandition"
08:13:43 <alios> Saizan: ahhh thnx ... will try that ;)
08:13:45 <gwern> mux: thanks
08:13:54 <mux> Control.Monad.void :: Functor f => f a -> f ()
08:14:10 <SonOfLilit> anyway, please ignore my question
08:14:11 <Saizan> alios: it's actually the standard way, type classes are for special cases where you need different implementations for different types
08:14:27 <SonOfLilit> I kept googling and found that it IS the output of postgresql
08:14:32 <Jafet> Her mythology seems wrong then, because Tolkien's elves are not devilish (although that was indeed the norm in the standard fey mythology of the time)
08:14:48 <SonOfLilit> I always find my answers a moment after I ask the question, desperate of ifnding it on my own XD
08:14:48 <gwern> looks like http://code.google.com/p/ndmitchell/issues/detail?id=317 can be closed then
08:15:05 <gwern> SonOfLilit: like the universe is conspiring to make you look bad
08:15:09 <quuuux> SonOfLilit: I have a theory that the act of asking a question on IRC causes that
08:15:19 <SonOfLilit> quuuux: it does
08:15:23 <SonOfLilit> or anywhere else
08:15:28 <quuuux> there's a sort of strange quantum entanglement going on
08:15:34 <SonOfLilit> one day I'll pick someone that I can just tell my problems to
08:15:43 <SonOfLilit> he wouldn't even need to know to program
08:15:55 <SonOfLilit> I can pay him minimum wage, and become twice as good a programmer
08:16:04 <byorgey> I don't think it's that strange.  The act of asking a question entails different mental processes that make you think about the problem in a different way.
08:16:09 <SonOfLilit> Profit!
08:16:26 <lelf> teddy bear?
08:16:32 <Jafet> Tell your problems to a stuffed animal for free
08:16:37 <byorgey> The trick is to write your question and then stop and think about it some more BEFORE you hit "send".
08:16:40 <gwern> SonOfLilit: I believe people usually use a yellow rubber duck or teddy bear for that
08:16:41 <SonOfLilit> byorgey: it also makes you reevaluate all you did, fearing to waste people's times
08:16:48 <byorgey> SonOfLilit: indeed.
08:17:00 <SonOfLilit> or be caught an idiot
08:17:06 <SonOfLilit> usually I do that :P
08:17:20 <SonOfLilit> there were so many reuqest for help emails deleted in mid-writing
08:17:27 <SonOfLilit> most after spending hours on an issue
08:18:34 <alios> Saizan: mmm ok moved test out of the class ... but now i get:
08:18:36 <alios> test.hs:1:1:
08:18:36 <alios>     Exception when trying to run compile-time code:
08:18:36 <alios>       Method not general enough: Test.test
08:18:37 <alios>       Code: mkMethods 'TestComponent ['test]
08:19:53 <SonOfLilit> anyway, teddy bears don't work for me
08:21:11 <phao> does ghc has anything like hugs getCh?
08:22:02 <Jafet> phao: if you're looking for a systematic approach to this, there are the vty and hscurses packages.
08:22:08 <Botje> does getChar suffice?
08:22:12 <Botje> oh.
08:22:52 <phao> Botje, actually, it does if I were the one coding
08:23:00 <phao> but this is an exercise of the haskell book I'm reading
08:23:12 <phao> I use ghc here, and it uses hugs... so it's using some stuff from hugs
08:23:15 <phao> getCh is one of them
08:23:52 <Jafet> Well, you can manually set the terminal mode to cbreak or raw using stty, and do asynchronous input from stdin.
08:24:12 <Jafet> If you're tempted to do that, I suggest spending a few hours at the whim of a professional dominatrix.
08:24:18 <phao> the book mixes getChar with getCh
08:24:21 <phao> would that be a problem?
08:24:44 <quuuux> Jafet: I hear the pros can turn you to puTTY in their hands
08:25:01 <Jafet> Do you know what getCh is supposed to mean, phao?
08:25:08 <phao> the book says:
08:25:12 <phao> The action getCh that reads a character without echoing is not part of the
08:25:13 <phao> standard prelude, but is provided as an extension by Hugs and can be made
08:25:13 <phao> available in any script by including the following special line:
08:25:23 <Jafet> Ah yes, noecho mode too
08:25:25 <phao> that's all I know about it
08:25:44 <Jafet> Now lie down, you've been a bad, bad boy.
08:27:28 <Jafet> I'm not sure if using the curses getch will work, then, unless you make a getChar that wraps getch and addch
08:28:06 <Jafet> A "standard" (if there were any such thing) terminal is in echo or noecho mode at any given time
08:30:32 <phao> so... 
08:30:50 <phao> I'd have to do stuff outside the haskell source code to get that working with ghc?
08:30:56 <lelf> phao: use can just use some curses library
08:31:20 <phao> right
08:31:24 <Jafet> I just gave you two ways to define the appropriate getCh and getChar in ghc-haskell
08:31:25 <lelf> phao: like nanocurses: UI.Nanocurses.Curses.getCh
08:31:48 <phao> Jafet, I tried using curses once, couldn't.
08:31:49 <phao> I'll try again
08:32:00 <Jafet> curses does not let you mix getCh and Prelude.getChar, probably
08:32:07 <phao> right
08:32:13 <phao> I'll define the way you suggested.
08:32:13 <Jafet> So use my fake echo
08:34:03 <Jafet> The downside is that you won't see your input echoed until the program gets around to processing it
08:34:14 <Jafet> And refreshing the screen, too
08:34:39 <Jafet> ...I'm not sure what the hugs people were thinking.
08:35:36 <phao> I'm not sure what most people are thinking when they use io functions that don't wait for line
08:35:56 <phao> for most purposes that I'm aware of, using anything that doesn't get a line at a time isn't "programmer friendly"
08:36:04 <phao> in terms of interactive programs
08:36:05 <Jafet> Why do you think it's named "curses"?
08:36:10 <phao> hahahahahahhahaah
08:36:37 <monochrom> in fact it is "n curses", for very large values of n
08:38:53 <Jafet> @quote 1970s
08:38:54 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
08:39:04 <phao> Jafet, 
08:39:09 <phao> I can use System.IO stuff
08:39:14 <phao> hSetEcho and hSetBuffering
08:39:48 <phao> http://ix.io/1mD this put a character you type without waiting for return 
08:39:51 <phao> and doesn't echo
08:40:03 <phao> I compiled it with ghc just now, worked.
08:40:36 <Jafet> Ah, that's great for you then.
08:40:44 <phao> yeah
08:40:52 <Jafet> .oO(Why is that stuff even in System.IO? Why?)
08:41:01 <phao> don't ask me, but makes sense to me.
08:41:47 <phao> supposing that System.IO should handle IO stuff related to the unrelying operating system =)
08:44:32 <pastorn> how do i create a var that's a const?
08:44:48 <monochrom> by creating a const that is a var.
08:45:03 <qfr> What's a var?
08:45:08 <pastorn> qfr: TVar
08:45:09 <qfr> Is taht a type?
08:45:10 <pastorn> (using STM)
08:45:35 <pastorn> qfr: how you have shared variables in haskell... the easiest place to start is to look at Data.IORef
08:45:35 <monochrom> v = 5  -- var and const
08:45:48 <pastorn> monochrom: i get its value from a config file
08:45:54 <pastorn> monochrom: maybe i meant a "final"
08:46:18 <monochrom> do { s <- getLine; let v = length s -- var and const
08:46:18 <pastorn> qfr: once you wanna do threads then IORef won't suffice, then you look into Control.Concurrent.MVar
08:46:46 <pastorn> qfr: and when that's not enough you go to Control.Concurrent.STM, where everything has hair on its chest (and lots of it!)
08:47:13 <pastorn> monochrom: i'm thinking i'm just stupid here
08:47:31 <pastorn> but i want certain threads/functions to be able to access it and others to only read it
08:47:52 <ddarius> MVars are about 20 years old in Haskell, and STM is about 3 or 4.
08:48:20 <pastorn> ddarius: the hair is a birth defect
08:48:35 <ddarius> pastorn: So give certain threads (readMVar mvar) and others the mvar directly.
08:48:36 <pastorn> bearovitis
08:48:44 <alej> ugh #math has been invaded by 12 year olds
08:48:49 <ddarius> Though, Reppy's thesis is good here.
08:49:02 <pastorn> alej: give them some lie algebras, that'll shut'em up
08:49:29 <pastorn> ddarius: but the readers should still be able to query it if updated
08:49:35 <pastorn> but never change it
08:49:44 <monochrom> that's what ddarius said
08:49:45 <ddarius> pastorn: And they will.
08:50:23 <pastorn> how will an MVar assure me of this?
08:50:32 <monochrom> what is the type of readMVar mvar? IO Int
08:50:45 <pastorn> sort of, it's clocks and times and minutes
08:50:47 <monochrom> readers are given some mystery of type IO Int
08:50:54 <pastorn> AH!
08:50:59 <pastorn> clever!
08:51:01 <pastorn> :D
08:51:11 * pastorn feels sort of retarded for not understanding this
08:51:12 <ddarius> This was probably clever in 1960.
08:51:22 <monochrom> you just have to pay attention to "So give certain threads (readMVar mvar)"
08:51:49 <pastorn> i thought of that as "val <- readMVar mvar" and not as the expression that it is
08:52:11 <pastorn> thanks :D
08:56:10 * hackagebot Etage 0.1.5 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.5 (MitarMilutinovic)
08:58:51 <phao> in this code, http://ix.io/1mF, hGetChar isn't echoing and I don't need to wait until '\n' to regain control. However, unless I type '\n', nothing is printed.
08:59:42 <byorgey> phao: use hSetBuffering stdout NoBuffering, or call hFlush stdout after the putChar
08:59:43 <phao> how do I change that? I want the character to be output as soon as I read it
08:59:49 <phao> ahhh
08:59:52 <byorgey> phao: output buffering is set to LineBuffering by default
08:59:54 <phao> forgott about stdout
09:00:09 <phao> thx Bynbo7 
09:00:12 <phao> byorgey, 
09:00:18 <Cale> I really wish there was an hWithEcho/hWithBuffering/etc.
09:01:14 <Cale> (not that you necessarily need them for this program)
09:01:16 <byorgey> that would be nice.  It would be easy to write one if there's a way to query the current buffering/echoing modes.
09:01:23 <byorgey> I don't know if there is.
09:01:24 <Cale> there is
09:01:32 <phao> Cale, what would those do?
09:02:01 <Cale> phao: get the current buffering/echo mode, then set it, run an action and reset it to what it was before
09:02:06 <phao> works perfectly byorgey haha
09:02:10 <phao> right
09:02:29 <phao> I think scheme has some stuff of that kind
09:03:31 <Twey> Hmm.
09:05:16 <Twey> hWith get set new h a = do old <- get h; set h new; r <- a; set h old; return r
09:05:46 <Twey> Or‚Ä¶
09:05:55 <Twey> hWith (get, set) new h a = do old <- get h; set h new; r <- a; set h old; return r
09:06:09 <Twey> buffering = (hGetBuffering, hSetBuffering)
09:06:31 <Twey> hWith buffering LineBuffering h $ do ‚Ä¶
09:07:52 <quuuux> is it possible to have two separate Library/Executable sections in one .cabal and have the ability to build/install one without the other, or will I need two separate .cabal files for that?
09:09:15 <byorgey> quuuux: you can definitely do that with multiple Executable sections (use flags to let the user select which one is wanted).
09:09:24 <byorgey> but I think you are only allowed one Library section, IIRC.
09:09:25 <jmcarthur> you can do it with multiple libraries too
09:09:31 <byorgey> oh, you can? neat.
09:09:49 <jmcarthur> pretty sure, although it may be that my memory is telling me the wrong thing
09:09:56 <jmcarthur> i'm pretty sure i've done it before
09:10:19 <jmcarthur> oh, it may be that i am confusing that with building the same library in different ways
09:10:23 <quuuux> I only need one Library section and one Executable section. I'm just trying to figure out how to get the independence to work, because I don't necessarily want to install them together
09:10:40 <jmcarthur> ah, that's fine then
09:10:53 <jmcarthur> you can use flags to determine which one(s) to build
09:11:07 <jmcarthur> in recent versions of cabal you can even have the executable depend on the library :D
09:11:15 <jmcarthur> byorgey: you're right, only one executable
09:11:25 <jmcarthur> err
09:11:28 <jmcarthur> library
09:12:04 <jmcarthur> i forgot that you don't get a field for naming the library. it's just named after the package
09:16:33 <byorgey> man, github is being super slow for me.  is anyone else having problems too?
09:16:45 <byorgey> and don't point me to downforeveryoneorjustme.net, I already checked that.
09:17:34 <quuuux> how do I enable/disable the Library/Executable sections? Wrapping it using an 'if' block is ungrammatical, according to the error I'm getting
09:17:56 <quuuux> and I don't see any options in the commands to specifically enable/disable the sections
09:18:13 <byorgey> quuuux: put 'if' blocks inside them and use  buildable: False  to disable a section
09:18:22 <quuuux> byorgey: oh, duh. Thanks
09:21:17 <jmcarthur> byorgey: seems slow to me as well
09:22:42 <fryguybob> http://status.github.com/
09:31:54 <augur> byorgey! :o
10:06:59 <Veinor> @tell fliebel pong
10:06:59 <lambdabot> Consider it noted.
10:34:05 <augur> whats with all the joining and leaving
10:34:36 <Naktibalda> it means "no talking" actually
10:34:49 <augur> maybe maybe
10:35:11 * ziman ignores joins and leaves :)
10:43:25 <sleepynate> people leave #haskell?
10:43:35 <sleepynate> i thought it was like hotel california
10:44:21 <Twey> Heh
10:44:29 <Eduard_Munteanu> Hi.
10:45:02 <Eduard_Munteanu> How do I get a backtrace in ghci? I get a "No match in record selector parent" error and I don't know where it comes from.
10:45:35 <Eduard_Munteanu> Even with :set -fbreak-on-exceptions, I get nothing useful.
10:50:47 * hackagebot bindings-gobject 0.3 - Low level bindings supporting GObject and derived libraries.  http://hackage.haskell.org/package/bindings-gobject-0.3 (MauricioAntunes)
10:54:02 <tomjnixon> Eduard_Munteanu: have you tried :list ?
10:55:49 <tomjnixon> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
11:03:48 <Eduard_Munteanu> tomjnixon: thanks, but it doesn't work...
11:03:54 <Eduard_Munteanu> Unable to list source for <exception thrown>
11:04:44 <Eduard_Munteanu> Hm, it seems I have to :trace.
11:05:42 <Eduard_Munteanu> Thanks, it works now.
11:15:16 <quuuux> is it possible to unload a package from the linker using the GHC API?
11:26:09 <roconnor> @quote heroin
11:26:10 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
11:28:24 <augur> any opinions on responsiveness-based type constraints? like, in some language without type classes, having a type (RespondsTo f) for any type that has a definition for f?
11:28:44 <augur> eg instances of Bool are also instances of RespondsTo (==), etc.?
11:30:10 <roconnor> augur: homonyms
11:30:16 <augur> roconnor: ?
11:30:43 <roconnor> IMHO that doesn't work well due to the existance of homonyms
11:30:57 <augur> roconnor: what do you mean
11:31:10 <ddarius> If it's good enough for the Perl programmers, it should be good enough for you.
11:31:43 <roconnor> I guess I should say Heteronyms since how they are pronounced isn't important
11:32:05 <ddarius> augur: I'm not sure what your question is.  It seems like you are describing something that is handled fine by most typed programming languages one way or another.
11:32:09 <roconnor> er rather Homographs
11:32:49 <augur> ddarius: a friend is complaining about generics in C#, and how you cant have a type like, say, List<T> where T responds to Foo
11:33:04 <Twey> Row types?
11:33:18 <augur> ddarius: and i mentioned that haskell at least avoids the issue by forcing overloading into type classes, so you could just do (Foo a) => [a]
11:33:21 <jmcarthur> you can't do that in C#? i'm pretty sur eyou can in java
11:33:27 <jmcarthur> *sure
11:33:46 <augur> but he dislikes the idea of having to go through type classes for that sort of thing
11:33:56 <Twey> jmcarthur: No, you can say ‚ÄòWhere T implements IFoo‚Äô which is not the same thing
11:34:15 <augur> so i was wondering what people thought of a type system that, instead of having type classes, you have responsivity types
11:34:17 <jmcarthur> Twey: i know interfaces are not the same as type classes, but wouldn't that suffice here?
11:34:27 <mtnviewmark> is lambdabot's quote database available somewhere?
11:34:32 <Twey> Probably, but I don't think that's what's being sought
11:34:33 <ddarius> augur: You can say List<T> where T : Foo, which is indeed, not the same, but seems the same enough.
11:34:35 <augur> where anything over which a method f is defined is (among other things) a subtype of RespondsTo f
11:34:47 <augur> ddarius: yeah but Foo would have to be an interface
11:34:47 <roconnor> augur: the type classes are the interface where two people get together and agree they are in fact talking about the same thing.
11:34:55 <merijn> mtnviewmark: Yes, because I downloaded it once. But I forgot where :x
11:35:03 <augur> and just imeplementing the method Foo() wouldnt make something an implementor of the interface Foo
11:35:12 <jmcarthur> augur: sounds like you want duck typing, which is not what type classes *or* interfaces are about
11:35:13 <augur> roconnor: ;)
11:35:19 <ddarius> augur: It can be a class as well, but yes, that's intentional.  It sounds like you friend is just complaining about the interfaces/classes not being fine-grained enough for him.
11:35:36 <Twey> Static duck-typing
11:35:41 <augur> jmcarthur: nah, its not quite duck typing, since presumably it should behave like a type class (uniform-ish type for the Foo method)
11:35:49 <Twey> ddarius: More about the clumsiness of it, I presume
11:35:52 <ddarius> Note that type classes don't achieve this either.
11:35:56 <augur> its just i suppose sort of like if you had an infinite number of record types and subtyping
11:36:00 <Twey> Having to create a new interface for each method
11:36:05 <augur> where you could talk about any record with a field "foo"
11:36:12 <augur> regardless of what other fields it has
11:36:12 <roconnor> I like the name duck-typeing because you never know whether calling the duck() method will cause the system to hide under the table or quack.
11:36:18 <jmcarthur> augur: is "class Foo a where" too much boilerplate?
11:36:27 <ddarius> Twey: We'd have to create a new type class for each method, so the situation is no better in Haskell and as I said, this is intentional.
11:36:42 <augur> jmcarthur: well not for ME. i like the type class method. im just curious what people think of the _other_ solution :P
11:36:55 <jmcarthur> augur: i guess i mean i'm not sure i see where this idea is any better than what we have already
11:37:09 <ddarius> Note that Clean does not have type classes (or didn't) per se, and instead treats each "generic" operation as a single method class.
11:37:37 <augur> jmcarthur: its not, but im not gonna be a dick to him and be like "dude, get over it. use type classes. derp."
11:37:55 <jmcarthur> augur: fair enough
11:38:06 <augur> i mean, you COULD imagine being able to do that
11:38:10 <jmcarthur> so you're just looking for decent arguments either way
11:38:13 <augur> yeah
11:38:24 <mux> I'm sooo loving type functions: https://bitbucket.org/mumux/automata/changeset/6d8a792913ff
11:38:39 <augur> i mean, its not unimaginable to have the ability to talk about pseudo-type classes in this way, right
11:39:07 <mreh> how do you implement a typeclass morphism?
11:39:19 <roconnor> mux: type families?
11:39:23 <augur> jmcarthur: any type is an instance of the pseudo-type class RespondsTo (f :: t) any time you define f :: t for that type
11:39:26 <ddarius> mreh: It's just a function.
11:39:31 <mux> roconnor: yeah.
11:39:35 <jmcarthur> augur: is there any difference between this and a type class with only one method, semantically?
11:39:47 <augur> jmcarthur: probably not.
11:40:58 <augur> i mean, theres something appealing about the idea of doing static duck-typing, but
11:41:00 <jmcarthur> augur: i'd say it's a tradeoff then. on the one hand, you would get fine-grained "type classes" with less boilerplate, but on the other hand, your type signatures would get larger
11:41:17 <jmcarthur> because you would have a lot more constraints
11:41:25 <ddarius> jmcarthur: And you'd get the standard problems with duck typing.
11:41:27 <augur> jmcarthur: sure. i mean, if you could avoid the constraints by having them be inferable
11:41:39 <mreh> @quack
11:41:39 * lambdabot clobbers  with an untyped language
11:41:53 <mreh> wtf
11:41:54 <jmcarthur> ddarius: standard problems? i always thought the standard problems were related to the dynamic typing more than anything
11:41:58 <augur> jmcarthur: like, if you have a function f x = g x, you'd infer that f :: (RespondsTo g x) => x -> ...
11:42:07 <ddarius> Also, for this automatic instance thing, exactly what instances get created?  What is "responding to" what?
11:42:25 <augur> ddarius: a valid question! i have no idea. :p
11:43:00 <ddarius> jmcarthur: Just because some "type" "responds to" a shoot method, doesn't mean that's the thing you want.  This is orthogonal to dynamic v. static typing.
11:43:12 <jmcarthur> augur: tons of constraints with polymorphic types can make type inference harder, though. consider (read . show)
11:43:13 <ddarius> monochrom would mumble something about "meaningful names" here.
11:43:23 <augur> ddarius: im also assuming you could enforce that the method has the appropriate type
11:43:39 <jmcarthur> ddarius: i was thinking that it would be like "open functions," not string matching on the function name
11:43:51 <aristid> :t read . show
11:43:52 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:43:58 <aristid> :t show . read
11:44:00 <lambdabot> String -> String
11:44:09 <aristid> > show . read $ "a"
11:44:12 <lambdabot>   "*Exception: Prelude.read: no parse
11:44:12 <jmcarthur> aristid: oh i meant the latter
11:44:20 <jmcarthur> ... defaulting?
11:44:22 <aristid> jmcarthur: defaulting is evil in that case
11:44:23 <ddarius> Yes.
11:44:34 <jmcarthur> silly defaulting
11:44:44 <aristid> especially when it defaults to ()
11:44:58 <jmcarthur> > show . read $ "()"
11:45:00 <lambdabot>   "()"
11:45:22 <ddarius> jmcarthur: I don't see what you mean by "open functions" and again, just because something has the same name and a congruent type doesn't mean it's what you want.
11:45:43 <jmcarthur> ddarius: we have different ideas about what we're talking about then
11:46:31 <jmcarthur> ddarius: what i'm thinking of is essentially the same as type classes with one method each
11:46:52 <ddarius> If you explicitly create and name those, then that's fine.
11:47:18 <ddarius> If they are "automatically" created, though, then it has the same problems "duck-typing" has elsewhere.
11:49:05 <jmcarthur> ddarius: i meant explicitly
11:49:07 <jmcarthur> http://hpaste.org/42732/thingy
11:49:41 <jmcarthur> it has no real benefit over type classes with one method though
11:50:32 <jmcarthur> i guess it's kind of an anonymous type class, which is why you would still have to say something like    RespondsTo (+) a =>
11:53:57 <ddarius> jmcarthur: Clean supports pretty much exactly that.\
11:54:25 <jmcarthur> yeah that's what i figured you were talking about earlier
11:54:34 <ddarius> See section 6.8 of the language definition.
11:55:07 <ddarius> (Plus some other stuff that I didn't realize...)
11:55:26 <Mitar> hmm, i have problems installing fgl library, on hackage it is written that it is succesfully compiled on 7.0 but on my 7.1 version it fails with     Illegal bang-pattern (use -XBangPatterns):
11:55:35 <augur> whos a zipper freak
11:55:36 <augur> anyone?
11:55:45 <augur> who can i bug about out there zipper-like ideas
11:59:36 <ddarius> http://www.st.cs.ru.nl/papers/2008/janj08-CEFP07-InterpretationToCompilation.pdf for the kids who haven't already implemented a bunch of languages.
12:09:39 <roconnor> implementing a compilier is as easy as partially evaluating an intepreter right?
12:10:09 <roconnor> augur: I like to think I know about zippers
12:10:31 <augur> roconnor: ah yes, but are you a zipper nerd? :p
12:10:42 <mtnviewmark> roconnor: just as soon as we've got that "dump run-time state as executable the OS understands and will launch" thing worked out.... :-)
12:10:43 <roconnor> not as much as some others
12:10:50 <tibbe> mtnviewmark: hi!
12:10:54 <tibbe> mtnviewmark: just sent you an email
12:10:57 <mtnviewmark> I saw
12:11:05 <copumpkin> roconnor wears these: T
12:11:06 <augur> roconnor: so what im thinking is, is it possible to treat the relationship between defined and definition in a zipperlike way
12:11:10 <copumpkin> http://1.bp.blogspot.com/_7IcDtaK0adU/TC1L6jMdsgI/AAAAAAAABcQ/JnfoVPDB0fo/s1600/parachutepants.jpg
12:11:27 <augur> roconnor: so like, imagine we have a simple definition:   x = if y then z else w
12:11:46 <augur> is it possible to think of y, z, or w in terms of the rest?
12:12:02 <roconnor> mtnviewmark: isn't that done by CryoPID http://cryopid.berlios.de/
12:12:10 <roconnor> CryoPID allows you to capture the state of a running process in Linux and save it to a file. This file can then be used to resume the process later on, either after a reboot or even on another machine.
12:12:15 <augur> e.g. if we think of that definition as x = f y, is there an inverse, y = f' x?
12:13:05 <roconnor> augur: what you are describing seems almost entirely unrelated to zippers :D
12:13:21 <roconnor> you might need someone nerdier than me
12:13:44 <augur> roconnor: think of it this way: `x = ifThenElse y z w` is an expression, right
12:13:52 <augur> lets think of it as an expression in some logic
12:13:58 <roconnor> well, it is a declaration
12:14:03 <roconnor> oh okay
12:14:07 <roconnor> an expression then
12:14:28 <mtnviewmark> roconnor: looks nice, and I like this known issue: "Very undocumented"
12:14:41 <augur> if we did the belnappian thing, we might say then we might want to be precise and say x = ((ifThenElse $ y) $ z) $ w
12:15:57 <augur> roconnor: but we can do the display trick:   w $' x = (ifThenElse $ y) $ z   =>   (ifThenElse $ y) $' (w $' x) = z
12:16:29 <augur> but we know that display logic and zippers are intimately related: they're the same thing, almost!
12:17:30 <ski> augur(,jmcarthur) : look at O'Camls object system ?
12:17:50 <ddarius> ENOTENOUGH'
12:18:10 <roconnor> hi ski
12:18:10 <nooodl> my function blows up when i try to return a fractional number, and i don't know which type signature to add
12:18:17 <ski> hello roconnor
12:18:37 <augur> but so then what is z = (ifThenElse $ y) $' (w $' x) and how could we make sense of this generically
12:18:51 <nooodl> it works fine until i need to divide the result by 20 :|
12:19:10 <ski> nooodl : type error ?
12:19:17 <roconnor> augur: you lost me at w $' x = (ifThenElse $ y) $ z   =>   (ifThenElse $ y) $' (w $' x) = z
12:19:41 <nooodl> yeah
12:19:50 <nooodl> "Possible fix: add an instance declaration for (Fractional Int)"
12:19:54 <nooodl> but i'm not sure how i'd do that.
12:20:03 <augur> roconnor: well, so    x = f $ w   <=>   w = x $' f
12:20:05 <augur> right?
12:20:15 <invarius1> I bought the book "The Haskell School of Expression"
12:20:18 <invarius1> I like it so far
12:20:23 <Veinor> quick
12:20:28 <Veinor> give me some reasons to learn haskell
12:20:30 <augur> or    x $' f = w   to keep this side invariant
12:20:39 <invarius1> Veinor: ease
12:20:46 <ddarius> Veinor: There are no reasons to learn Haskell.
12:20:51 <Veinor> invarius1: for people who are already programmers
12:20:52 <ski> nooodl : you probably need to convert from `Int' to whatever fractional type you want, using `fromIntegral' .. or, if possible, avoid generating an `Int' in the first place
12:20:52 <ddarius> Veinor: Learn PHP instead.
12:20:55 <invarius1> ddarius: wtf are you talking about
12:20:57 <nostrand> Veinor: it's in my opinion easier to code in =)
12:20:59 <Veinor> ddarius: wat
12:21:06 <invarius1> Veinor: okay...?
12:21:10 <ski> > length "abcd" / 2
12:21:11 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
12:21:12 <lambdabot>    arising from a use o...
12:21:12 <roconnor> augur: how should I read $'
12:21:13 <merijn> Veinor: It helps you be a pretentious coding snob :>
12:21:19 <Veinor> merijn: haha
12:21:21 <nostrand> merijn: :D
12:21:23 <ski> > fromIntegral (length "abcd") / 2
12:21:24 <lambdabot>   2.0
12:21:24 <augur> roconnor: pseudo-application. i dont know. lol
12:21:31 <ski> > fromIntegral (length "abcd") / 2 :: Rational
12:21:32 <lambdabot>   2 % 1
12:21:34 <nooodl> oh :)
12:21:45 <nooodl> thanks
12:21:47 <ski> nooodl : you can paste the code if you want, of course
12:21:53 <augur> roconnor: i mean, for this:   x = f y   <=>   x $' f = y
12:22:17 <nooodl> nah, it works now. besides, it's embarrasingly messy :)
12:22:27 <merijn> Veinor: In all seriousness, assuming you already know how to code, Haskell will warp your understanding of what programming is and forever change your ideas on what coding should be
12:22:44 <augur> i think you could relate it somehow to continuations. like, y is the value for which f is the continuation in x
12:23:08 <roconnor> augur: well, if f is the constant function, what would x $' f return?
12:23:21 <augur> what, precisely, you should get from    y $' x = f, i dont know :p
12:23:31 <roconnor> :)
12:23:43 * ski idly wonders whether one could turn this "pseudo-application" thingie into an adjunction
12:23:48 <roconnor> augur: I'm afraid I have no answers for you
12:23:54 <Veinor> merijn: I like that one
12:23:59 <roconnor> ski: ya, it did look like an adjuction
12:24:05 <augur> i mean, this might all be just a syntax trick, but the idea im aiming for is to be able to evaluate expressions that aren't explicitly defined
12:24:06 <invarius1> merijn: wait, how so?
12:24:11 <merijn> Veinor: The downside of this is of course that if you've learned to program in a "traditional" language (C, python, ruby, java, etc) you will have a lot of bad habits to unlearn before Haskell starts making sense, this causes some to think Haskell is hard.
12:24:14 <invarius1> studying compilers did that, not haskell
12:24:28 <merijn> invarius1: As does learning Lisp, etc.
12:24:28 <augur> roconnor: like, if you could do   let xs !! i = f (ys !! i) in take 5 xs
12:24:32 <ski> roconnor : well, not quite .. but remniscent, yes
12:24:55 <merijn> invarius1: Haskell is not the only way, but it is one of the ways to get your understanding of programming unstuck :p
12:24:55 <roconnor> augur: sadly computation appears to be not symetric.
12:25:30 <augur> roconnor: since take isnt defined in terms of (!!) but is instead defined (approximately) in terms of head and tail, and since (!!) is defined in terms of head and tail, you could "pseudo-define" head in terms of (!!), and tail similarly
12:25:50 <merijn> Veinor: My C (and now Java for class) code has started to look a lot different since I learned Haskell, and in a good "less bugs, easier to maintain" sort of way
12:26:18 <augur> roconnor: oh this might not be a computation thing, it might end up being proof oriented instead, but thats ok, im not concerned with usability ;)
12:26:29 <merijn> Veinor: I usually recommend people learn Haskell even if they never code in it afterwards. Which is of course a trap, because once you understand it you will like coding in it :p
12:27:12 <roconnor> augur: classical logic is more symetric.
12:27:12 <alpounet> i almost do not use any other language anymore
12:27:17 <ski> augur : or `let head xs = ..; tail xs = ..; in ..xs..' :)
12:27:25 <augur> roconnor: :P
12:27:29 <augur> ski: ey?
12:27:35 <roconnor> augur: have you studied the sequent calculus?
12:27:36 <nooodl> > :t (map . map)
12:27:37 <lambdabot>   <no location info>: parse error on input `:'
12:27:42 <ski> roconnor : how about classical linear logic ?
12:27:45 <augur> roconnor: yes :P
12:27:52 <copumpkin> does (.&.) have a general identity element (given the typeclass definition)?
12:27:58 <roconnor> augur: then you already know this. :D
12:28:07 <augur> roconnor: belnap's display logic was meant to address certain issues with the sequent calculus
12:28:13 <merijn> Isn't sequent calculus really just a fairly trivial notational trick for describing derivations?
12:28:21 <roconnor> augur: sounds like you know more than me :D
12:28:26 <augur> merijn: its more that the "trick" is syntactic, not semantic
12:28:40 <augur> merijn: the sequent calculus tries to show stuff about _proofs_ not boolean algebra
12:28:46 <roconnor> merijn: cut elimination!!
12:28:50 <augur> but stuff which _corresponds_ to boolean algebra in interesting ways
12:29:44 <merijn> roconnor: Yes, but that's all fairly trivial
12:30:08 <roconnor> merijn: subformula property!!
12:30:26 <merijn> Now you're just making up words to make me look dumb...
12:30:51 <augur> he is not.
12:31:18 <merijn> Off-topic: Anyone read "Elimination with a Motive"? Specifically anyone that cares to explain to me what the hell is going on? :p
12:31:24 <ski> # let foo x = x # frob 42;;
12:31:24 <ski> val foo : < frob : int -> 'a; .. > -> 'a = <fun>
12:31:40 <roconnor> merijn: link?
12:31:44 <ski> augur : that's a trivial O'Caml object example of "responds to `frob'"
12:31:56 <augur> ski: ok
12:32:15 <roconnor> Gentzen proved the cut-elimination theorem (his Hauptsatz) in a 1934 paper. This implies that if a formula is provable, then it is provable "without detours". In particular, we have the "subformula property" that all formulae in a (cut-free) derivation are subformulae of the endsequent formulas. Other consequences include consistency of predicate calculus, decidability of intuitionistic propositional logic, and unprovability of excluded 
12:32:16 <roconnor> middle in intuitionistic propositional logic. 
12:32:24 <merijn> roconnor: http://strictlypositive.org/elim.ps.gz
12:32:30 <ski> augur : the function `foo' can be sent any object which supports a method `frob' which is a function with argument of type `int'
12:33:06 <nooodl> i can not believe the amount of lines in which i just did this
12:33:08 <nooodl> http://codepad.org/x4rdU98z
12:33:17 <augur> ski: nifty. ill let ez know
12:33:18 <nooodl> i really need to use haskell more :)
12:33:25 <merijn> nooodl: Nice
12:33:38 <copumpkin> anyone know about my identity for (.&.) question?
12:33:49 <roconnor> 0
12:33:55 <nostrand> Veinor: Why Haskell? "<nooodl> i can not believe the amount of lines in which i just did this" =)
12:33:57 <roconnor> er
12:34:07 <roconnor> -1 ?
12:34:11 <ddarius> Yes, -1.
12:34:17 <augur> copumpkin: i wish i did :(
12:34:24 <roconnor> not sure what that will do for Integer
12:34:26 <roconnor> but anyhow
12:34:26 <copumpkin> oh smart
12:34:36 <copumpkin> I was looking for a simple way to get 0xffff...
12:34:37 <ddarius> > complement 0 :: Integer
12:34:38 <copumpkin> but that's it :P
12:34:38 <lambdabot>   -1
12:34:42 <copumpkin> oh, that's even cleaner
12:34:59 <ski> augur : btw, note that the Trex record system for Hugs allows something similar (though more limited, iirc)
12:35:01 <roconnor> ddarius: I don't want to know how that works
12:35:06 <nostrand> nooodl: nice code =)
12:35:12 <Twey> plane = [x / 20 :+ y / 20 | x <- [-40 .. 20], y <- [-20 .. 20] ] ‚Ä¶ no?
12:35:15 <augur> ski: ok
12:35:19 <sleepynate> permission to pander and spam to the channel about a totally non-haskell subject?
12:35:26 <augur> ski: how about the zipper-ish stuff? :D
12:35:30 <Twey> Or vice versa with the order, perhaps
12:35:45 <Veinor> nooodl: neat :D
12:36:12 <nooodl> yup :)
12:36:16 <copumpkin> roconnor: the first parameter to J#
12:36:19 <mtnviewmark> yeah, nooodl: Haskell really sux when you're gettin' paid by the LOC
12:36:31 <mtnviewmark> :-)
12:36:34 <copumpkin> roconnor: just for the sake of not respecting your wish
12:36:36 <ddarius> -x = ~x + 1, so ~x = -1 - x
12:36:36 <merijn> mtnviewmark: Just write literate Haskell? :p
12:36:39 <ski> augur : in O'Camls object system ?
12:36:44 <augur> ski: no no, in general
12:36:46 <ddarius> > -1 - 3
12:36:47 <lambdabot>   -4
12:36:48 <roconnor> copumpkin: huh?
12:36:49 <nooodl> could've added in some type signatures here and there... ;)
12:36:58 <ddarius> > complement 3
12:36:59 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:36:59 <lambdabot>    `Data.Bits.Bits a'
12:36:59 <lambdabot>      a...
12:37:03 <ddarius> > complement 3 :: Integer
12:37:03 <copumpkin> roconnor: for GMP integers, there's a separate sign
12:37:04 <lambdabot>   -4
12:37:17 <copumpkin> but they pretend to be an infinitely large 2's complement
12:37:23 <merijn> :t complement
12:37:24 <lambdabot> forall a. (Bits a) => a -> a
12:37:39 <roconnor> copumpkin: that is kinda scary
12:38:16 <ski> nooodl : btw, note that in the specific case `fromIntegral (length ...)' you can instead say `genericLength ...'
12:38:34 <ddarius> ski: Which has different (but probably preferable) semantics.
12:38:59 <ddarius> (but it's probably also noticably slower...)
12:40:01 <c_wraith> also, genericLength requires an import, but neither fromIntegral nor length do. :)
12:40:46 <ski> ddarius : *nod*
12:41:40 <copumpkin> rightIdentity (commutative -> Yes op) = leftIdentity op
12:41:43 <copumpkin> :P
12:42:10 <copumpkin> I love view patterns
12:42:16 <nooodl> hmm, (,) is an operator, it seems
12:42:34 <mightybyte> @pl (\f k -> runMaybeT $ lift . f =<< (MaybeT k))
12:42:34 <lambdabot> (runMaybeT .) . (. MaybeT) . (=<<) . (lift .)
12:42:35 <mtnviewmark> I thought that was a GHC extension... though perhaps on be default
12:42:35 <nooodl> that's pretty neat
12:42:53 <copumpkin> nooodl: (,,,,,) is too
12:43:01 <copumpkin> also, with an extension, you can partially apply it
12:43:03 <nooodl> too bad i can't do (, x) and (x ,)
12:43:03 <luite> > (,2,3) 1
12:43:04 <lambdabot>   Illegal tuple section: use -XTupleSections
12:43:07 <copumpkin> nooodl: you can
12:43:12 <copumpkin> with the new TupleSections
12:43:20 <nooodl> hmm, could i do like
12:43:23 <nooodl> (,,x,y,z,)
12:43:24 <mightybyte> Anyone have suggestions for what that last @pl function should be named?
12:43:31 <copumpkin> and you can write (,,,3,True,,(),,,(2,5),,)
12:43:35 <ski> nooodl : `main = mapM_ (putStrLn . map (graph . mandelbrot)) plane'
12:43:36 <copumpkin> and it'll give you a suitable function
12:43:38 <copumpkin> nooodl: yep
12:43:41 <mightybyte> >:t (\f k -> runMaybeT $ lift . f =<< (MaybeT k))
12:43:53 <copumpkin> @ask Cale can you turn on TupleSections?
12:43:53 <lambdabot> Consider it noted.
12:44:01 <c_wraith> copumpkin, I'd argue that the result of that expression is never a suitable function
12:44:12 <mightybyte> :t (\f k -> runMaybeT $ lift . f =<< (MaybeT k))
12:44:13 <lambdabot> Not in scope: `runMaybeT'
12:44:13 <lambdabot>     Ambiguous occurrence `lift'
12:44:13 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
12:44:18 <copumpkin> c_wraith: argue away ;)
12:44:25 <copumpkin> hypothetically, of course
12:44:25 <mtnviewmark> @ask Cale is the lambdabot quote database available somewhere?
12:44:26 <lambdabot> Consider it noted.
12:44:53 <merijn> mtnviewmark: It is, I just forgot where, maybe you can find it in the logs from when I asked
12:45:20 <mtnviewmark> when did you ask? today?
12:45:39 <lelf> mtnviewmark: lambdabot sources
12:45:46 <ddarius> It's in the source.  The actual live version is in lispy's machine.
12:45:48 <ddarius> @version
12:45:48 <lambdabot> lambdabot 4.2.2.1
12:45:48 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:46:38 <alpounet> mtnviewmark, seems to be here: http://code.haskell.org/lambdabot/State/quote
12:46:42 <lelf> mtnviewmark: ./State/quote
12:46:50 <mtnviewmark> I see - now I just have to write a little code (figuring out the API) to get the data out of there
12:47:17 <merijn> mtnviewmark: It's just a tarred/gzipped text file
12:47:23 <mtnviewmark> oh
12:47:26 <mtnviewmark> coolio
12:47:53 <lelf> just gzipped
12:48:14 <ski> nooodl : also you could do
12:48:23 <ski>   plane = (`map` [-20 .. 20]) $ \y ->
12:48:31 <ski>             (`map` [-40 .. 20]) $ \x ->
12:48:35 <ski>               x / 20 :+ y / 20
12:48:46 <ski> (but it's arguable)
12:50:21 <mtnviewmark> thanks all
12:51:29 <lelf> runBASIC $ do { 10 FOR Y := -20 TO 20 ...  } :)
12:51:30 <lelf>  
12:53:55 <copumpkin> is there a name in algebra for x such that forall y. y `op` x = k (where k tends to be additive identity)
12:54:24 <c_wraith> zero, informally.
12:54:31 <c_wraith> I don't know if there's a formal term
12:56:09 <ski> is `op' associative ?
12:56:23 <copumpkin> let's say yes
13:00:35 <ski> then `forall a b.  k  =  op (op a b) x  =  op a (op b x)  =  op a k' .. setting `b' to e.g. `a' or `k' or `x', we get that `k' must be a right zero/annulator of `op'
13:00:51 * hackagebot Etage 0.1.6 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.6 (MitarMilutinovic)
13:02:56 <ski> (.. though i suppose that doesn't say anything about `x' itself)
13:04:52 * ski idly wonders where this property originated from ..
13:04:52 <ddarius> http://en.wikipedia.org/wiki/Annihilator_(ring_theory)
13:13:50 <Veinor> wow, since when is haskell.org pretty?
13:13:56 * ddarius really needs to get a real knife.
13:15:52 <nooodl> hey, it is
13:17:02 <merijn> Oh bah
13:17:11 <merijn> It's all Web2.0 gradients and all
13:17:15 <jmcarthur> it's been that was for a while now
13:17:18 <jmcarthur> *that way
13:17:58 <nooodl> i remember it as having an outright terrible logo
13:18:02 <pastorn> when will hackage start having that?
13:18:08 <jmcarthur> i don't care if it's trendy or not as long as it's readable and not completely ugly, and this is more readable and less ugly to me than the old one
13:18:15 <nooodl> http://www.blogonauts.com/eats-the-world/wp-content/uploads/2009/03/Haskell_Logo.jpg
13:18:19 <Veinor> jmcarthur: agreed
13:18:27 <merijn> As far as programming language sites go I think I like Clojure's design best (http://clojure.org/?responseToken=352d2903ff019f0e623cc6bccab7a001)
13:18:32 <Veinor> plus, first impressions and all that
13:19:05 <mtnviewmark> yes - that logo was pretty bad... Haskell had a logo contest in 2009 and the Thompson-Wheeler logo won
13:19:10 <mtnviewmark> it is quite nice and versitle
13:19:26 <merijn> Haskell.org should switch to a "Learn You A Haskell"-like design ;)
13:19:26 <jmcarthur> merijn: it looks good, but i have to admit the first thing i did when i saw clojure's web page was wonder where the download link was hidden
13:19:30 * ddarius sees absolutely nothing notable in Clojure's site.
13:19:31 <Veinor> mtnviewmark: the lambda-bind one?
13:19:43 <Veinor> also, clojure's website won't load for me
13:19:51 <mtnviewmark> http://www.haskell.org/haskellwiki/Thompson-Wheeler_logo
13:19:55 <jmcarthur> merijn: for that matter, it's hard to find anything at all
13:20:02 <systemfault> clojure's website looks cleaner than haskell
13:20:20 <Twey> The ?responseToken= spoilt it for me
13:20:28 <jmcarthur> systemfault: i agree that it's less cluttered and all, but the navigation hurts
13:20:40 <Twey> But yes, it's nice to have the features and reference immediately available
13:20:44 <systemfault> I think that the use of "orange" while being a complementary color, is just plain annoying for the eyes on haskell.org
13:20:44 <merijn> Twey: I agree, that is ugly
13:21:01 <Twey> The logo looks weird though
13:21:04 <Twey> >.>
13:21:07 <Dyazz> Hello all !
13:21:10 <Veinor> the thompson-wheeler logo really is good
13:21:11 <Twey> Hi
13:21:15 <Dyazz> i'm french :)
13:21:16 <merijn> Oh, hey! Dutch Functional Programming day this week
13:21:28 <nooodl> http://www.ruby-lang.org/en/ is nice IMO
13:21:33 <mtnviewmark> Is that like a national holiday>?
13:21:34 <Veinor> http://www.haskell.org/wikiupload/9/96/HaskellLogoStyPreview-8.png haha
13:21:35 <jmcarthur> systemfault: i agree, but i ripped those colors off for some slides i'm making and it's beautiful. maybe the colors just aren't completely appropriate for a web page
13:21:36 * ddarius wants the old GHC logo back.
13:21:37 <nooodl> a bit clashy, maybe
13:21:52 <Twey> The image is nice, but I don't like how they just stuck that italic j in the middle with no regards for colour or harmony
13:21:55 <Dyazz> you programming on ruby ?
13:22:01 <systemfault> jmcarthur: I love the rest :)
13:22:04 <Twey> Well, oblique, I suppose
13:22:16 <Veinor> ... clojure still isn't loading
13:22:16 <Twey> ddarius: GHC has a logo?
13:22:28 <nooodl> yeah, when scripting
13:22:41 <cgray> hi, I have a function where I want to reverse a list based on an option.  What's the most idiomatic way to do that?
13:22:47 <Dyazz> I prefer Python if i want scrypting
13:22:56 <nooodl> cgray: option being a Bool?
13:23:04 <cgray> nooodl: yeah
13:23:21 <jmcarthur> if p then reverse else id
13:23:25 <mtnviewmark> if you're looking at "the competition", slides 5 - 17 compare documentation design in my presentation on Haddock here:  http://mtnviewmark.wordpress.com/2010/10/01/haddock-revamp/
13:23:36 <Twey> fun = reverse ?? id
13:23:46 <merijn> :t (??)
13:23:47 <lambdabot> Not in scope: `??'
13:23:47 <Twey> (y ?? n) p = if p then y else n
13:23:49 <Twey> @let (y ?? n) p = if p then y else n
13:23:50 <lambdabot>  Defined.
13:23:51 * jmcarthur prefers bool to (??)
13:23:54 <Twey> :t (??)
13:23:55 <lambdabot> forall t. t -> t -> Bool -> t
13:24:12 <Twey> fun = reverse `bool` id -- if that makes you happier :√æ
13:24:20 <jmcarthur> @let bool t f p = if p then t else f
13:24:21 <nooodl> i'd probably do "fun True = reverse; fun False = id"
13:24:21 <lambdabot>  Defined.
13:24:25 <jmcarthur> :t bool reverse id
13:24:26 <lambdabot> forall a. Bool -> [a] -> [a]
13:25:12 <Twey> > let fun = bool reverse id in (fun True [1, 2, 3], fun False [1, 2, 3])
13:25:14 <lambdabot>   ([3,2,1],[1,2,3])
13:25:48 <Twey> cgray: It's your program, but I'd generally not bother making that a function, if we're talking ‚Äòidiomatic‚Äô.
13:25:49 <augur> whats the point of these functions
13:25:58 <Twey> augur: cgray asked for them
13:26:12 <ddarius> Twey: http://web.archive.org/web/20031203222338/www.haskell.org/ghc/
13:26:16 <Twey> cgray: Well, giving it a name, anyway ‚ò∫
13:26:20 <cgray> Twey: ok
13:26:22 <augur> oic
13:26:33 <jmcarthur> the point of bool is that you can write if-then-else point free and it's nice :)
13:26:53 <Twey> Yeah
13:26:58 <augur> :t ifThenElse
13:27:00 <lambdabot> Not in scope: `ifThenElse'
13:27:01 <jmcarthur> kind of like the maybe function as opposed to using case matching
13:27:12 <jmcarthur> it's just a fold
13:27:14 <Twey> ddarius: Haha, the dinosaur?
13:27:14 <augur> :t ifthenelse
13:27:15 <lambdabot> Not in scope: `ifthenelse'
13:27:17 <Dyazz> if condition then instruction else instruction
13:27:23 <ddarius> Twey: Yes, the happy dinosaur.
13:27:23 <augur> :t ifThen
13:27:24 <lambdabot> Not in scope: `ifThen'
13:27:26 <augur> :|
13:27:27 <Twey> ddarius: Nice.  :√æ
13:27:31 <augur> isnt there a predefined ifthenelse
13:27:33 <jmcarthur> augur: if is not a function
13:27:33 <augur> what is this
13:27:37 <augur> jmcarthur: yes it is
13:27:40 <jmcarthur> well, it is, but it's special
13:27:46 <augur> not really
13:27:53 <Twey> http://www.haskell.org/wikiupload/9/96/HaskellLogoStyPreview-8.png would be cool if not for the red/blue.  That clashes and makes it asymmetrical and horrible.
13:27:53 <jmcarthur> it's syntax
13:27:56 <augur> @pl if x then y else z
13:27:57 <lambdabot> if' x y z
13:28:00 <augur> there you go
13:28:02 <jmcarthur> augur: if'
13:28:03 <eZet> 22:27 <      Twey> http://www.haskell.org/wikiupload/9/96/HaskellLogoStyPreview-8.png would be
13:28:04 <jmcarthur> not if
13:28:20 <Twey> > if'
13:28:21 <lambdabot>   Not in scope: `if''
13:28:23 <jmcarthur> Twey: eh, i think that look kinda cheap and busy
13:28:34 <augur> so since if' exists, whats the point of bool
13:28:38 <jmcarthur> augur: if' is a function defined just for pointfree
13:28:43 <jmcarthur> augur: it's not in base or anything
13:28:47 <Twey> augur: if' has its arguments in a silly order because that's the way if has them
13:28:56 <Twey> And yeah, it's no more standard than bool is
13:29:02 <mtnviewmark> bool feels like the right name to me -- consistent with maybe and either
13:29:13 <jmcarthur> augur: with bool you can leave off the condition and use it in nicer point free ways
13:29:16 <augur> jmcarthur: its not really relevant. i mean, its entirely possible to define the if-then-else as sugar for if'
13:29:40 <augur> ok, so the point is more to make the argument the _last_ thing
13:29:41 <jmcarthur> not relevant to what. i'm confused about what you are trying to say
13:29:45 <Twey> augur: The predicate, yes
13:29:46 <jmcarthur> right
13:29:46 <augur> (`if'` y z)
13:29:50 <Twey> Right
13:29:51 <mtnviewmark> possible, in some personal version of Haskell perhaps -- but the spec is pretty clear about what if then else is
13:29:56 <Twey> Like that, except not horrible
13:29:57 <ddarius> mtnviewmark: You want foldr renamed to list?
13:29:57 <cgray> wow, so much info...
13:29:58 <Twey> ‚ò∫
13:30:05 <augur> Twey: its not horrible!
13:30:11 <jmcarthur> augur: that won't work
13:30:23 <mtnviewmark> ddarius - I don't think I'd find that as natural
13:30:24 <jmcarthur> augur: unless you mean for (y z) to be the true case
13:30:27 <augur> you're right, but thats not the point :D
13:30:38 <augur> no i see the idea behind bool
13:30:43 <jmcarthur> @pointfree \t f p -> if p then t else f
13:30:43 <lambdabot> Unknown command, try @list
13:30:45 <augur> tho it should better be called if2 or something
13:30:46 <jmcarthur> bleh
13:30:52 <jmcarthur> @pl \t f p -> if p then t else f
13:30:52 <lambdabot> flip . flip if'
13:30:59 <jmcarthur> if2? why?
13:31:05 <mtnviewmark> bool with the Bool at the end is very useful, and fits the scheme of maybe and either .... 
13:31:08 <augur> because its just like if only slightly different
13:31:13 <jmcarthur> bool matches up with maybe and eith... yeah that
13:31:23 <jmcarthur> but it's not supposed to be like if at all
13:31:25 <sid3k> is there anyone interested at both javascript and fp? you guys may be interested a javascript library influenced by haskell, check it out; http://github.com/azer/functools (any kind of ideas are welcome)
13:31:26 <jmcarthur> it's supposed to look like a fold
13:31:38 <augur> how does it fit the scheme of maybe and either
13:31:42 <jmcarthur> :t maybe
13:31:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:31:43 <jmcarthur> :t either
13:31:43 <Twey> augur: bool = flip . flip if'
13:31:44 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:32:06 <Twey> Oh, you @pl'd it already
13:32:08 <Twey> >.>
13:32:09 <augur> @src maybe
13:32:10 <lambdabot> maybe n _ Nothing  = n
13:32:10 <lambdabot> maybe _ f (Just x) = f x
13:32:46 <augur> @src either
13:32:47 <lambdabot> either f _ (Left x)     =  f x
13:32:47 <lambdabot> either _ g (Right y)    =  g y
13:32:54 <augur> interesting
13:33:00 <Dyazz> what is it again lambabot ?
13:33:08 <mtnviewmark> the only question is should it be  bool true-value false-value   or the other way 'round ---
13:33:21 <mtnviewmark> --- to match maybe and either, probably   bool false-value  true-value
13:33:23 <Twey> mtnviewmark: I don't think it matters that much
13:33:31 <Twey> That's only one flip/section, which is alright
13:33:35 <mtnviewmark> but that will probably feel unnatural
13:33:35 <augur> whats the point of maybe and either?
13:33:46 <mtnviewmark> though I like that it puts the generally shorter value first (the False-value)
13:33:52 <mux> avoid clunky pattern matching everywhere
13:33:52 <Twey> True
13:33:54 <nooodl> what's the point of if'? :)
13:33:57 <merijn> augur: Less typing
13:34:04 <Twey> augur: Neater functions
13:34:06 <augur> merijn: example of their usefulness?
13:34:09 <c_wraith> augur: Replacing syntax with functions
13:34:10 <mux> and lets you focus on function composition
13:34:37 <nooodl> i like regular if then else, making it a function feels too obfuscated
13:35:01 <c_wraith> I really hate if/then/else.  complicated clunky syntax for a simple function.
13:35:09 <merijn> augur: map (maybe zero f) bar -- bar :: [Maybe a]
13:35:10 <Twey> nooodl: You consider ‚Äòf = bool reverse id‚Äô to be *more* obfuscated than ‚Äòf b = if b then reverse else id‚Äô?
13:35:13 <conal> nooodl: your reaction may change as you get used to function-level programming
13:35:13 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:35:16 <mux> nooodl: but when most of your code is dealing with function composition, as is often the case, "if then else" gets very clunky
13:35:23 <Twey> c_wraith: Though sometimes it's nice to avoid brackets
13:35:35 <mux> nooodl: consider: "if b then id else f . g" for instance
13:35:41 <merijn> zero being some value of type a
13:35:49 <c_wraith> Just look at the fact that one of the haskell 2010 changes is a syntax change to slightly make if/then/else less clunky
13:35:52 <merijn> eh, type "f a"
13:35:53 <augur> merijn: hm
13:35:54 <mux> that would be a point for (.?) though :-)
13:36:04 <copumpkin> > 0 / 0 :: Rational
13:36:06 <lambdabot>   *Exception: Ratio.%: zero denominator
13:36:31 <heiz> Hi! In scheme I can write something like (define (foo)
13:36:32 <heiz>     (display "return fun")
13:36:32 <heiz>     (newline)
13:36:32 <heiz>     (lambda (x y)
13:36:32 <heiz>       (+ x y))), but I don't understand how to write it in haskell.
13:36:36 <nooodl> Twey: i actually do, but that's probably the imperative programmer in me speaking :)
13:36:52 <merijn> heiz: Next time use a pastebin
13:37:07 <mtnviewmark> > let displayName = maybe "Dr. X" ("Mr. "++) in map displayName [Just "Spock", Nothing, "Just Bond"] 
13:37:08 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe [GHC.Types.Char]'
13:37:08 <lambdabot>         ag...
13:37:27 <Twey> nooodl: *shudder*
13:37:35 <mtnviewmark> > let displayName = maybe "Dr. X" ("Mr. "++) in map displayName [Just "Spock", Nothing, Just "Bond"] 
13:37:37 <lambdabot>   ["Mr. Spock","Dr. X","Mr. Bond"]
13:37:43 <merijn> heiz: Also, what us that supposed to do?
13:37:48 <merijn> s/us/is
13:38:02 <jmcarthur> heiz: so you want it to print something to the screen and then return a function?
13:38:02 <mtnviewmark> maybe is very useful for situations like that --- so useful that often you don't even need a helper function 
13:38:10 <Twey> heiz: foo = putStrLn "return fun" >> return (+)
13:38:35 <Twey> foo = const (+) <$> putStrLn "return fun"
13:38:47 <Twey> :t ($>)
13:38:48 <lambdabot> Not in scope: `$>'
13:38:52 <jmcarthur> foo = (+) <$ putStrLn "return fun"
13:38:52 <Twey> :t (<$)
13:38:53 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:38:55 <Twey> That's the one
13:39:09 <mtnviewmark> foo = do { putStrLn "return fun"; return (\x y -> x + y); }
13:39:18 <Twey> mtnviewmark: Ewww :√æ
13:39:18 <nooodl> it's probably also the fact that "if then else" is more like english, and feels more natural for bigger expressions
13:39:20 <jmcarthur> heiz: keep the conversation in #haskell, not a private session. everybody is willing to help
13:39:27 <mtnviewmark> but I'm not sure why heiz you want to do that
13:39:34 <merijn> mtnviewmark: "\x y -> x + y" == (+)
13:39:40 <Twey> heiz: 213838 < jmcarthur> foo = (+) <$ putStrLn "return fun"
13:39:48 <Twey> heiz: ^ this is probably the nicest way to do it.
13:40:01 <heiz> The question is how to create a procedure that returns a function
13:40:09 <mtnviewmark> I know, I'm just mimicing heiz's function, since I assume in scheme the lambda wasn't needed either
13:40:10 <Twey> heiz: mtnviewmark's is a (non-idiomatically) direct translation
13:40:22 <mtnviewmark> yes
13:40:24 <jmcarthur> heiz: all functions taking more than one argument return functions when applied to fewer arguments ;)
13:40:46 <Twey> heiz: (+) is a function
13:40:47 <merijn> @check (\x y -> x + y) == (+)
13:40:47 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a -> a))
13:40:47 <lambdabot>    arising from a use of `GH...
13:41:16 <nooodl> argh, i hate how ghci can't print functions
13:41:18 <Twey> heiz: putStrLn is a ‚Äòprocedure‚Äô if you like that, when called, prints something to the console, then returns ()
13:41:33 <Twey> heiz: (<$) is a function that swaps that () out and replaces it with (+)
13:41:33 <merijn> @check \i j -> (\x y -> x + y) i j == (+) i J
13:41:34 <lambdabot>   Not in scope: data constructor `J'
13:41:38 <merijn> @check \i j -> (\x y -> x + y) i j == (+) i j
13:41:39 <lambdabot>   "OK, passed 500 tests."
13:41:39 <nooodl> can't it just substitute them with "<funcname>" or something
13:42:01 <Twey> nooodl: let f = id; g = f in f
13:42:02 <copumpkin> nooodl: unfortunately not
13:42:04 <jmcarthur> @check \x y -> (x + y :: Int) == (+) x y
13:42:05 <lambdabot>   "OK, passed 500 tests."
13:42:08 <Twey> nooodl: ‚Äî what's the name?  ‚ò∫
13:42:10 <Silvah> What if they don't have a name?
13:42:41 <ddarius> > not
13:42:42 <lambdabot>   Overlapping instances for GHC.Show.Show
13:42:42 <lambdabot>                              (GHC.B...
13:42:43 <nooodl> right. just "<func>" then?
13:42:48 <merijn> In Haskell it is harder not to return functions then it is to return functions :p
13:42:49 <ddarius> Bloody shite.
13:42:59 <ddarius> nooodl: Yes, that can be done readily.
13:43:03 <Twey> nooodl: Not very informative though :√æ
13:43:09 <ddarius> import Data.Function (I think)
13:43:11 <merijn> I think its downright impossible to write non-trivial code without returning functions (maybe its even impossible to write trivial code...)
13:43:32 <nooodl> or its type
13:43:33 <Silvah> The error message is more informative actually.
13:43:35 <heiz> Uner procedure I mean lambda that takes no arguments. In scheme it is valid to create something like (lambda () (do something)).
13:43:51 <Twey> heiz: Haskell doesn't work like that
13:43:56 <ddarius> Text.Show.Functions
13:43:59 <merijn> heiz: It's valid, but makes no sense in haskell
13:44:00 <Twey> A lambda that takes no arguments is just a value
13:44:03 <nooodl> it could print <[a] -> a>
13:44:08 <Veinor> instance Show (a->b) where show = const "<func>"
13:44:10 <jmcarthur> heiz: if you are wanting to do something then you are wanting IO actions, not functions
13:44:11 <Veinor> :)
13:44:13 <merijn> :t \ -> 5
13:44:14 <lambdabot> parse error on input `->'
13:44:39 <ddarius> nooodl: Not quite, but lambdabot could do something like that.
13:44:58 <Veinor> > :t showsType
13:44:58 <lambdabot>   <no location info>: parse error on input `:'
13:45:00 <Veinor> :t showsType
13:45:01 <lambdabot> Not in scope: `showsType'
13:45:04 <nooodl> > print map
13:45:05 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
13:45:05 <lambdabot>    arising...
13:45:21 <Silvah> > print id
13:45:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:45:22 <lambdabot>    arising from a use of `...
13:45:29 <jmcarthur> heiz: but you can still pass actions around just like any other value, so there is not problem here
13:45:37 <jmcarthur> heiz: you just can't think of it as some sort of function
13:45:42 <merijn> heiz: Haskell only allows expressions and expressions alway return something. How is a lambda that takes no arguments and returns a value different from just the actual value
13:45:51 <ddarius> > getLine
13:45:52 <lambdabot>   <IO [Char]>
13:46:19 <ddarius> merijn: I think you can actually write nullary lambdas in Clean.
13:46:21 <nooodl> heiz is thinking like a schemer while writing haskell
13:46:35 <merijn> ddarius: Yes, but Clean is not haskell, now is it? :p
13:46:50 <nooodl> scheme isn't pure so zero-argument lambdas make sense, they're just like subroutines
13:46:54 <heiz> Well, in other programming languages I can create a function with no arguments to store repeating code there. What mechanisms des haskell provide for this situation?
13:46:55 <merijn> heiz: Where are you learning Haskell from? (book/site/etc)
13:46:56 <jmcarthur> heiz: in haskell, everything is a value. not everything is a function, though
13:47:00 <Silvah> But this is Haskell, so coding as if it were Scheme is pointless.
13:47:10 <jmcarthur> heiz: you can do the same thing. it's just not a function
13:47:22 <heiz> then what is it?
13:47:25 <jmcarthur> a value
13:47:28 <jmcarthur> like i've already said
13:47:32 <Silvah> What's he trying to do?
13:47:34 <gienah> kolmodin guess I will drop the .txt, thanks
13:47:44 <gienah> sorry wrong channel
13:48:09 <merijn> Silvah: "In scheme it is valid to create something like (lambda () (do something))." which is obviously non-sensical in Haskell
13:48:10 <jmcarthur> heiz: you can say something like   foo = getLine >>= putStrLn
13:48:20 <copumpkin> gienah: :O
13:48:29 <copumpkin> secret dealings with kolmodin 
13:48:44 <heiz> what type foo will have?
13:48:49 <jmcarthur> heiz: foo as i defined it there not only takes no arguments but is not a function at all
13:48:52 <jmcarthur> heiz: IO ()
13:48:56 <merijn> :t getLine >>= putStrLn
13:48:57 <lambdabot> IO ()
13:49:08 <nooodl> IO in haskell is pretty crazy though
13:49:13 <jmcarthur> no it's not
13:49:17 <jmcarthur> it's just a value
13:49:18 <Twey> It's pretty sane
13:49:23 <merijn> nooodl: Not it's not, people should stop saying that
13:49:26 <nooodl> sure, sane, but nothing like scheme
13:49:33 <aristid> now iteratees, THOSE are sane
13:49:33 <jmcarthur> scheme is not sane
13:49:34 <Twey> You're just working at a level higher than you're used to from impure languages
13:49:37 <Silvah> It is compared to worse languages ;)
13:49:38 <aristid> argh crazy i mean
13:49:40 <copumpkin> it's so crazy we locked it up in an asylum, whence it cannot escape
13:49:50 <Twey> Heh
13:49:57 <jmcarthur> impure languages are so insane that you *can't* leave the IO monad
13:50:11 <copumpkin> in our language we keep the insanity in asylums
13:50:19 <merijn> jmcarthur: You mean your *program* can't leave the IO monad
13:50:20 <ddarius> Yep, Clean syntax for lambdas allows either of \ = ... or \ -> ...
13:50:23 <copumpkin> most languages let the crazies roam freely among the normal people
13:50:27 <jmcarthur> merijn: i mean your *code* can't
13:50:27 <copumpkin> so you have no way of telling who's who!
13:50:39 <merijn> jmcarthur: I, myself, am stuck in the IO monad by definition
13:50:53 <nooodl> i feel like i don't really understand IO because monads are involved, and I don't get those at all
13:50:54 <jmcarthur> merijn: i disagree. the IO monad is sequential, but your world is concurrent
13:51:07 <copumpkin> nooodl: they aren't involved though, unless you choose to make them involved
13:51:11 <nooodl> so do notation works, but it feels a little mysterious
13:51:15 <Silvah> Ah, monads...
13:51:15 <jmcarthur> merijn: also, the IO monad is discrete, but your world is (arguably) continuous
13:51:18 <nooodl> because i don't know what's going on under the hood
13:51:39 <Twey> Nah, nobody believes in that crazy ‚Äòcontinuous‚Äô woo-woo stuff any more ‚ò∫
13:51:40 <jmcarthur> merijn: interesting, i just defined the problem that FRP seeks to solve :)
13:51:51 <merijn> I like to pretend the IO monad is concurrent but with "sequential consistency" making everything make sense in hindsight :p
13:52:02 <Silvah> We really, REALLY should choose a less frightening name.
13:52:10 <Twey> (warm fuzzy thing)
13:52:10 <jmcarthur> merijn: it's hard to imagine IO as concurrent when its concurrency is merely interleaving
13:52:11 <nooodl> <- and >> and >>=, oh my
13:52:21 <merijn> nooodl: You have read LYAH's stuff on the Maybe monad?
13:52:28 <ddarius> Silvah: Like lax functor into Cat.
13:52:41 <ddarius> Who wouldn't like a name like "lax functor into Cat?"
13:52:59 * Silvah would not.
13:53:09 <conal> augur: i'm glad to hear you enjoyed my push-pull frp talk. :)
13:53:09 <jmcarthur> lax cat
13:53:12 <merijn> nooodl: If so, I recommend reading "Wadler - Monads for Functional Programming", its really easy to read and explains how to use monads for modeling IO
13:53:22 <augur> conal: :)
13:53:22 <ddarius> From the terminal category specifically, but one can begin to generalize...
13:53:34 <jmcarthur> and conal appears as though he were summoned by the mention of frp
13:53:45 <augur> conal: i also enjoyed your slight facial expression asymmetry that made you look like you were hiding your true pirate identity <3
13:53:49 * ddarius thinks "The Essence of Functional Programming" is a bit more entertaining read.
13:54:16 <Silvah> What the syntax for defining an instance of a class has been?
13:54:22 <conal> augur: what asymmetry do you see? raised eyebrow?
13:54:31 <augur> conal: throughout the _whole_ talk. yes. :p
13:54:35 <merijn> Will anyone here be at the Dutch FP day in Twente?
13:54:47 <Silvah> I forgot that ^^'
13:54:49 <conal> augur: wow. i've never noticed.
13:54:51 <jmcarthur> augur: i'm trying to decide whether to laugh or say you are being rude :P
13:55:08 <nooodl> merijn: i'm in the area, and it's on my birthday... but nope
13:55:12 <augur> conal: its subtle but cool.
13:55:14 <luite> hmm, when is it?
13:55:20 <merijn> luite: Friday
13:55:24 <jmcarthur> okay, i've decided to laugh
13:55:25 <nooodl> January 7th
13:55:31 <conal> jmcarthur: i'm laughing, too.
13:55:59 <augur> conal: i still have no idea how frp works, tho. lol
13:56:07 <merijn> augur: Join the club
13:56:12 <augur> :D
13:56:23 <Twey> augur: Clearly you were distracted by his piratical aura
13:56:31 <augur> i mean, i get the concept, but i dont understand the haskell implementation
13:56:31 <sleepynate> same
13:56:33 <merijn> I feel like FRP is exactly what I want/need, if only I could understand what the hell it was :p
13:56:40 <augur> Twey: probably true!
13:56:46 <merijn> "jQuery Programming with Haskell" sounds interesting, that means I can do my web front end coding in Haskell :>
13:56:56 <sleepynate> wat
13:57:02 <sleepynate> do want
13:57:16 <jmcarthur> lol i pulled up the video and i see it now
13:57:18 <Twey> jQuery is just a big State monad
13:57:19 <jmcarthur> it will never be unseen
13:57:28 <Silvah> Let's write everything in Haskell!
13:57:32 <conal> i started watching the talk to see if i could spot the asymmetry, and then i got interested. now i wonder if luqui's lazy if-then-else leads to a simpler or at least alternative solution to the problem described on slide 18.  http://conal.net/blog/posts/lazier-functional-programming-part-2/
13:57:59 <merijn> sleepynate: Its one of the topics at the FP day, Utrecht has build a Haskell to JS compiler and they're giving a talk on using Haskell for web front-end development :p
13:58:06 <conal> at 00:15:03
13:58:24 <sleepynate> nice
13:58:38 <conal> the problem was that if-then-else produces no information until the boolean resolves to true or false. lazier if-then-else does produce info before then.
13:58:55 <merijn> "lazier functional programming", that's when you no longer write code yourself but just wait for dons to solve your problems?
13:58:59 <augur> lol conal
13:58:59 <luite> hmm, haskell to js, interesting.
13:58:59 <augur> <3
13:59:06 <Silvah> ;D
13:59:09 <sleepynate> merijn: correct
13:59:17 <conal> :)
13:59:19 <arjanb> merijn: i don't see your name on the participants list...
13:59:29 <luite> merijn: is the compiler written in javascript? (or can it be compiled to javascript)?
13:59:44 <merijn> arjanb: No, I just found out about it today, just mailed them I would go
14:00:04 <sleepynate> one would think the compiler is in haskell...
14:00:23 <augur> conal: i like that your mad quest for good FRP has revealed bugs in GHC
14:00:23 <Silvah> What the syntax for defining an instance of a class has been?
14:00:39 <luite> sleepynate: but the compiler itself might require extensions or rts functions that the javascript target does not support
14:00:51 <conal> augur: my frp impls have always pushed the bleeding edge of the language & compiler.
14:00:56 <norm2782> the UHC compiler is written in Haskell and it is able to compile Haskell code to JS :)
14:01:06 <augur> i feel its this sort of nutty experimentation that makes haskell such a wonderful language. people toy with it, and that toying is also useful
14:01:22 <augur> its like a parable for science in general
14:01:31 <sleepynate> luite: there you have it
14:01:39 <conal> augur: hm, yeah.
14:01:53 <conal> and for me haskell is a thought clarifier & amplifier.
14:02:02 <augur> indeed!
14:02:21 <jmcarthur> conal: i'm wanting to generalize lazier if-then-else to pattern matching on arbitrary sum types
14:02:23 <luite> norm2782: cool, the current stable version? (1.1.0), or should I check it out from the git repository?
14:02:35 <conal> jmcarthur: definitely.
14:02:49 <augur> i feel like you're the kind of guy who would be like .. "ok, who cares if this even makes sense on first look. lets try it and see where we get"
14:02:55 <norm2782> luite: the current stable version already has support for JS, but the version in the repository has some nice enhancements
14:03:00 <norm2782> so I'd recommend that one
14:03:07 <norm2782> it's also the one I'm basing my work on :)
14:03:11 <conal> jmcarthur: do you mean like eitherL in that blog post?
14:03:16 <jmcarthur> conal: it's one of the goals i have in mind for this effort to make a lazier, specializing language
14:03:16 <luite> norm2782: waht are you working on?
14:03:17 <jmcarthur> yeah
14:03:36 <norm2782> luite: the jQuery support :) I'm giving the presentation at NL-FP 
14:03:49 <jmcarthur> conal: i'm curious how we might think about our code differently if it was this lazy by default
14:03:51 <conal> augur: you're right. i follow my nose, often tugged by what at first just seems to be aesthetics, but often turns out to be more.
14:03:58 <systemfault> Hmm
14:04:05 <luite> norm2782: oh interesting
14:04:14 <systemfault> A haskell to JS compiler? What is that compiler?
14:04:17 <zearen> If a handle connected to socket with connectTo and in hangs on hPutStrLn, what can I assume if I'm confident the server is malfunctioning?
14:04:22 <conal> jmcarthur: me too. would open up new programming techniques.
14:04:27 <norm2782> systemfault: UHC (Utrecht Haskell Compiler)
14:04:40 <luite> norm2782: what kind of support? something that looks like ffi bindings from the haskell side?
14:04:43 <systemfault> norm2782: Thanks :)
14:05:00 <norm2782> luite: yes, we use a jscript ffi
14:05:06 <invarius> I bought the book "The Haskell School of Expression"
14:05:12 <norm2782> here are two blogpost related to it: http://utrechthaskellcompiler.wordpress.com/
14:05:13 <invarius> I like it
14:05:18 <jmcarthur> conal: btw, do you want luqui and me to stop spamming you about vatican, or should we keep CCing you?
14:05:21 <augur> conal: where do you get this stuff? like, your awareness of bottom as a relevant issue for laziness, etc. how did you come across this stuff and integrate it into your view of things?
14:05:53 <conal> jmcarthur: i'm glad you're pushing on laziness. rather than settling for the status quo.
14:06:00 <conal> jmcarthur: no. please keep spamming me, even though i've not responded. i'm interested in the topic but distracted by thinking about parallelism.
14:06:03 <ddarius> augur: If there wasn't bottom, laziness would be immaterial.
14:06:17 <augur> ddarius: yes i know that, but thats not the point :P
14:06:35 <jmcarthur> conal: parallelism, eh? i'm trying to put together a talk on pure parallelism right now
14:06:40 <jmcarthur> you thinking of anything juicy?
14:06:41 <conal> augur: denotational semantics has been an enormous influence on me. or maybe gave me a language/framework that fits my thinking.
14:06:48 <ddarius> augur: Then I don't understand how someone can -not- see bottom as relevant to laziness.
14:06:48 <augur> its the sort of presence that such a thing has in someones mind when thinking of how a language works that im curious about.
14:07:12 <copumpkin> real programmers use total languages
14:07:15 <augur> hmm. conal, ill have to read more about the denotational semantics of programming languages then
14:07:23 <conal> augur: do.
14:07:29 <Philippa> copumpkin: natural programmers, surely?
14:07:40 <conal> augur: and note that it's directly applicable to designing libraries, not just languages.
14:07:54 <Philippa> conal: there's a difference?
14:07:56 <augur> i know about denotational semantics of natural languages, but those are a bit less tricky, since we model them like logics not like algorithms
14:08:06 <augur> conal: libraries, ey?
14:08:07 <ddarius> copumpkin: Total languages aren't programming languages, but then I guess real programmers program on real machines which aren't Turing machines.
14:08:58 <copumpkin> pff, depends what you mean by a programming language
14:09:05 <augur> ddarius: you could probably wrap all your functions in Maybe so that they could sort of be total
14:09:06 <conal> augur: yes. i design libraries around data types, and my fundamental question is what does the data type *mean*?
14:09:26 <ddarius> augur: I'll be sure to do that for my next Scheme interpreter.
14:09:32 <conal> augur: see my "denotational design" paper.
14:10:04 * ddarius needs to write a paper formalizing "type class morphisms" from an algebraic perspective.
14:10:05 <alpounet> conal, if only more people would ask themselves these questions, we'd live in a better world
14:10:16 <alpounet> asked*
14:10:30 <conal> alpounet: :) 
14:10:31 <invarius> ddarius: please do
14:10:39 <invarius> that should save me some time
14:11:11 <alpounet> conal, sometimes i'm just disgusted when reading a library's doc
14:11:19 <invarius> don'
14:11:25 <invarius> don't read library docs
14:11:34 <invarius> they're bad for your eyeballs
14:11:41 <norm2782> luite, systemfault : you might also be interested in this: https://github.com/norm2782/haskell-jscript-libraries/tree/master/uhc-initial-experiments
14:11:46 <jmcarthur> invarius: but sometimes they're so good!
14:12:00 <norm2782> just run make and run Test.html after cloning it
14:12:09 <systemfault> norm2782: Thank you :) I was reading the blog :)
14:12:15 <invarius> :)
14:12:37 <jmcarthur> alpounet: i love it when i see a model in the documentation. it almost instantly helps me understand it and i can usually even predict most of the rest of the functionality of the library just based on the model
14:12:39 <invarius> I want to write a virtual machine in haskell
14:12:43 <invarius> rather, compiler 
14:12:55 <alpounet> jmcarthur, the *very* same happens to me 
14:13:36 <invarius> jmcarthur: there is something like that for haskell docs, I cannot remember what it is
14:13:40 <invarius> can you? :O
14:13:51 <invarius> things of many algebras
14:14:07 <norm2782> just a disclaimer on the JS (and especially the jQuery) stuff: it's still _very_ experimental ;)
14:14:19 <conal> jmcarthur: the type class morphism (TCM) discipline accentuates this property (that the semantic domain/model largely describes the API)
14:14:19 <systemfault> :P
14:14:32 <alpounet> i gotta take a look at that TCM thing
14:14:39 <alpounet> i read a bit about it a while ago
14:14:41 <alpounet> but can't remember
14:14:45 <jmcarthur> conal: yeah, it's even nicer when you see a model in the documentation and then you see a huge list of type class instances :)
14:15:06 <gienah> invarius: I would like to be able to write a simple little bytecode interpreter virtual machine in haskell, but I don't know enough about haskell yet to know how to do it
14:15:35 <ddarius> gienah: You just do it.
14:15:38 <conal> TCM came out of what i thought was aesthetics. i was describing the semantics of frp for the push-pull paper, and i started noticing patterns. so i set about revealing them more plainly. i thought i was just making the code poetic.
14:15:42 <gienah> invarius: so trying to learn, the Write Yourself a Scheme in 48 hours tutorial is useful for learning how to write a compiler
14:16:22 <conal> now TCM is a central design principle for me. where TCM works, i have confidence that the design is good, and where TCM fails, i know to try reworking the design.
14:17:15 <conal> and now i realize that TCM failure == abstraction leak.
14:17:29 <luite> norm2782: does it already support interactive things, for example javascript event handling or time-based events? (such as animations, which would probably require setTimeout in javascript)
14:17:46 <jmcarthur> hmm... abstraction leak?
14:18:38 <norm2782> luite: not quite.. there are some msc students working on adding such things in the context of a project for the advanced functional programming course at UU atm
14:19:12 <jmcarthur> i guess TCM failure does mean abstraction leak
14:19:22 <norm2782> luite: hopefully that will result in some cool features in that area
14:19:49 <invarius> gienah: I actually don't like scheme and I have books on compilers using Ada, Pascal, and C... I guess it's just the idea I need to translate, which could be done, but I'm not confident in haskell being a gateway to the low level languages
14:19:52 <invarius> not sure at all 
14:19:58 <norm2782> next semester I will be able to spend more time on the DOM manipulation part, so I hope to support other libraries as well (Dojo, YUI, etc.)
14:20:27 <conal> norm2782: who's working on this haskell-jscript stuff? sounds like something i'd like to learn about and maybe get involved in.
14:21:34 <gienah> invarius: that tutorial is on how to write a scheme interpreter in haskell.
14:21:50 <norm2782> conal: the main author of the UHC JS backend is Atze Dijkstra. I'm working on adding DOM manipulation features and improving the general API 
14:22:02 <conal> norm2782: i have a hunch that one of my old papers could be applied nicely to map frp into jscript. http://conal.net/papers/padl99/
14:22:23 <conal> norm2782: cool. ah -- it's a UHC backend. i hadn't realized. nice!
14:22:33 <gienah> invarius: I think scheme is very interesting as the book "Essentials of Programming Languages" is written using scheme, and it describes how to use continuations, which are very useful for writing a compiler in haskell
14:23:03 <norm2782> conal: ah nice :) doing things with FRP is being looked into at the moment
14:23:12 <norm2782> I'm pretty sure your paper will be useful
14:23:32 <luite> norm2782: I wanted to do something with interactive graphics in the browser (started last summer) with haskell. I first based it on something similar to tryhaskell, where the haskell is evaluated on the server, using a web service. the graphics library generates javascript code. the problem I ran into is that it isn't really possible to make it actually interactive this way. the uhc javascript backend could be the solution :)
14:24:24 <jmcarthur> UHC has a lot of cool stuff
14:24:33 <conal> norm2782: oh, sweet. :)  
14:24:35 <jmcarthur> i love its kind polymorphism extension
14:25:01 <norm2782> luite: cool :) the nice thing about the UHC backend is that it compiles to JS, so theoretically you can do everything you would do in conventional JS proramming
14:25:07 <conal> norm2782: that paper is about bridging the gap between a purely functional animation spec and a stateful retained-mode display engine.
14:25:55 <c_wraith> To be honest, kind polymorphism still hurts my head.  I mean, I see where it'd be really useful, but it makes my head go "owie"
14:26:10 <luite> norm2782: compiling to js does have disadvantages though, I'm assuming that many hackage packages can't be compiled with it
14:26:10 <conal> norm2782: while breaking the impl into a sort of client/server structure, in which the client recomputes and redisplays at a terrifically high rate, and unaffected by garbage collection.
14:26:46 <balor> What's the most straightforward way to send an email from a haskell app?  i.e. which package?
14:27:23 <norm2782> luite: yeah, I suppose not everything will compile nicely to JS. but then again, you probably don't really need that :) especially when reusing libraries like jQuery et al
14:27:24 <jmcarthur> c_wraith: that's how you know it's good. if your mind has to expand in order to understand it then that often means you've been limited by your vocabulary
14:27:32 <augur> ddarius: what i meant was more than a function seems to be total-izable if you include a Nothing-like value
14:28:20 <augur> ddarius: like, in certain versions of categorial grammar, function application can always apply, even when it cant
14:28:48 <ddarius> augur: That's what bottom is.
14:28:50 <augur> so like, app (a -> b) a = b, and app _ _ = Fail
14:28:50 <jmcarthur> conal: oh cool, i hadn't seen that paper before, but it sounds nice
14:28:53 <norm2782> conal: sounds cool! I've added it to my to-read list :)
14:28:59 <c_wraith> augur, total doesn't just mean "never returns null or throws an exception."  It also means "always terminates".  Which gets into obvious turing-area if you're trying to just map a non-total function into a total function + nothing
14:29:05 <conal> :)
14:29:40 <conal> my group in grad school (cmu) was about program derivation. that mindset has influenced me quite a lot.
14:29:43 <augur> c_wraith: well, total more properly means that every input in the domain has an output, which i suppose has something to do with termination
14:29:49 <ddarius> c_wraith: For a Haskell-like language, kind polymorphism mostly comes up when you don't actually care what the type constructor is indexed by.  Once the kind level gets more interesting, though, it will come up more often and should be just as natural as polymorphism is at the type level.
14:29:50 <augur> maybe we're thinking of different totals
14:30:01 <augur> or maybe theyre the same and i dont realize how :p
14:30:19 <c_wraith> augur: look at denotational semantics, and realize that an infinite loop is also bottom.
14:30:49 <augur> c_wraith: i suppose. im not sure if im intending bottom, tho
14:31:07 <jmcarthur> augur: a strict function is defined as one where f _|_ = _|_, which seems to be exactly what you are trying to say here
14:31:34 <norm2782> anyway, I'm off for the night :)
14:32:07 <jmcarthur> augur: err, i mean, a function f is strict if f _|_ = _|_. stupid clumsy wording
14:32:20 <augur> :P
14:32:24 <alpounet> conal, that must have been quite interesting
14:34:00 <conal> alpounet: yeah, very. and where i learned about lazy functional programming and got to hack a lot in lisp and ml and a bit in miranda (in the pre-haskell days).
14:34:13 <hpc> :t undefined undefined
14:34:14 <lambdabot> forall t. t
14:34:19 <hpc> :t fix undefined
14:34:20 <lambdabot> forall a. a
14:34:30 <hpc> > fix undefined
14:34:32 <lambdabot>   *Exception: Prelude.undefined
14:34:34 * ddarius should probably get a not draft version of "Denotational design with type class morphisms"
14:40:43 <andy_> can anyone provide any help with http://pastebin.com/2pWndPWz
14:41:08 <andy_> a ConcatC instance fails the compiler
14:42:55 <alpounet> conal, oh! fun! any conclusive results ?
14:43:22 <hpc> andy_: any compiler output?
14:43:28 <conal> alpounet: what were we talking about?
14:44:08 * ddarius prepares to shave off his two week old beard.
14:44:08 <hpc> oh, this is GADT stuff
14:44:11 <hpc> i can't help
14:45:31 <alpounet> conal, your grad school work
14:46:27 <andy_> hpc, http://pastebin.com/pgKCQM3k
14:47:27 <andy_> (that one contains just the compiler output)
14:47:29 <hpc> yeah, i have no clue
14:47:41 <andy_> ok
14:47:42 <hpc> i don't deal with that group of extensions
14:48:28 <conal> alpounet: there's a lot of wonderful work on deriving correct & efficient programs from correct, elegant & inefficient (or non-executable) specs. i derived a higher-order unification algorithm for dependently typed lambda calculus.
14:48:41 <conal> alpounet: (a long time ago)
14:48:55 <jmcarthur> that sounds really sweet
14:49:01 <jmcarthur> i should really just get back into academia
14:49:43 <jmcarthur> heh, i say "back into" but i doubt an undergrad program even counts all that much as academia compared to what i would like
14:50:06 <kosmikus> andy_: the compiler is right. you are trying to partially apply a type synonym, which isn't allowed in Haskell.
14:50:42 <andy_> ok
14:50:46 <andy_> thanks
14:51:03 <andy_> is it possible to define a fold type-level function?
14:51:55 <conal> jmcarthur: yeah if you can swing it, and you find a department that fits you. i had a ball in grad school. undergrad also (math at college of creative studies at uc santa barbara). i was lucky with my schools.
14:52:50 <kosmikus> andy_: nearly everything is possible. but probably not exactly in the way your are trying to.
14:53:57 <conal> i'm glad i studied pure math instead of cs as an undergrad. it informed my sensibilities. i keep hearing people say "programming is not math", but to me it is. or where it isn't, it's just not mature yet.
14:54:15 <conal> minority perspective, i suspect.
14:54:29 <jmcarthur> conal: my CS department required a math minor. i have to admit i enjoyed the math classes a lot more than the CS classes
14:54:46 <conal> jmcarthur: cool!
14:55:38 <Heffalump> advanced maths is mostly really complicated though. I'd like programming to be simpler than that :-)
14:55:38 <Mitar> I would like to use map on Data.Graph.Inductive, there is a function for that, gmap, but I would like to use a function in IO monad to map
14:56:00 <djahandarie> I'd say my major problems with math is feeling like I'm never using it and forgetting it as a result
14:56:05 <jmcarthur> conal: IMO, programming *isn't* math, but it would be better if it was
14:56:05 <djahandarie> Like all my calculus
14:56:16 <Mitar> how could i transform that gmap into io monad based map?
14:56:43 <jmcarthur> conal: well, i mean "programming" in the sense that most people in the "real world" think of it
14:56:52 <jmcarthur> what those people do is not math
14:56:53 <conal> jmcarthur: no opinions needed here. my language was sloppy. by "for me it is", i mean what i aspire to when i program.
14:57:33 <jmcarthur> conal: that sounds more accurate to how i approach it as well
14:57:42 <conal> jmcarthur: :)
14:58:27 <jmcarthur> i *want* it to be math, even if it currently isn't
14:59:10 <jmcarthur> now that you brought up program derivation i really want to get some richard bird reading material
15:00:02 <conal> jmcarthur: yeah! richard bird is a hero of mine. still holding the torch for old-skool functional/denotative programming. (no IO.)
15:01:31 <jmcarthur> Heffalump: programming is really complicated too, though
15:02:03 <Heffalump> it shouldn't be :-)
15:02:14 <jmcarthur> hear hear
15:02:18 <merijn> Heffalump: Based on what evidence/reasoning? :p
15:02:53 <merijn> Humans are ill equipped for dealing with math and programming, unfortunately.
15:03:49 <merijn> I'd like programming to be more like math, but today people were calling me a static typing snob again while arguing that dependent typing will be awesome :<
15:04:04 <jmcarthur> merijn: i see math as a discipline for overcoming our weaknesses in these areas
15:04:55 <jmcarthur> the problem is that we just suck at "simple" things. we tend to conflate abstract things with concrete scenarios
15:05:17 <Heffalump> I'd like it to be like the simpler bits of maths, rather than say Wiles' proof of Fermat's last theorem
15:05:42 <jmcarthur> look at category theory, for example. it's insanely simple, and yet it's so difficult for us to wrap our heads around it sometimes
15:06:35 <conal> suppose we get tiny supercomputer brain implants soon (2020), tremendously augmenting our ability to retain & access information and carry out computational experiments, to complement our intuitive & creative abilities. what might happen to our abilities in math & programming?
15:06:35 <merijn> Heffalump: imo CS and programming are related far more to the simpler bits of maths then normal math is
15:07:08 <merijn> The basics of logic, type theory and complexity theory are not all that complicated
15:08:01 <Heffalump> merijn: yeah
15:08:16 <merijn> conal: I think we'll be there sooner if you disregard implant science fiction and take a peek at the future of smart phones
15:08:29 <conal> merijn: works for me.
15:08:49 <merijn> I wonder how long until my android phone can run Mathematica...
15:09:00 <c_wraith> conal: I doubt augmented computation abilities will help the average person much at all.
15:09:04 <jmcarthur> conal: i'm not sure that's the kind of direction i'd like to see. i kind of see that line of thought as accepting more complicated things rather than simplifying them. then again, i guess that same line of thought makes complexity less painful, so maybe my ideals would just have to change
15:09:16 <luite> merijn: it can probably already access wolfram alpha... not quite the same, but close
15:09:20 <merijn> Then again, I suppose it'd be shorter to wait for decent 3G and using WolframAlpha
15:09:28 <conal> what i'm curious about is the impact of tight interplay between bio-evolved and tech-evolved abilities.
15:09:47 <merijn> conal: The future will be awesome...
15:09:49 <luite> merijn: the latest mathematica also needs wolfram alpha for some of its functionality
15:10:48 <conal> jmcarthur: iswym about simple vs complicated. i like simple also. i suppose there's the possibility of computational searches to find hiding simplicities.
15:11:23 <merijn> At some point you run out of simple things and need to start considering more complex things based on the set of simple things
15:12:02 <merijn> Unless we turn up some simple elegant grand unifying theory of everything, which seems unlikely
15:12:27 <Mitar> gmap has such type
15:12:28 <jmcarthur> i'm curious whether building things out of simple components necessarily leads to complex things. if so, that goes against everything i thought i had learned as a programmer
15:12:35 <Mitar> gmap :: http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:DynGraph gr => (http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Context a b -> http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Context c d) -> gr a b -> gr c d
15:12:49 <Mitar> how can I make: ap :: http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:DynGraph gr => (http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Context a b -> IO (http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Context c d)) -> gr a b -> IO (gr c d)
15:12:49 <Mitar> ?
15:13:40 <merijn> I suppose the other possibility would be that the set of simple things is unbounded...
15:14:00 <opqdonut_> Mitar: ap x = liftM gmap x
15:14:04 <opqdonut_> :t liftM
15:14:05 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:14:05 <merijn> I'm sure someone with more knowledge about Kolmogorov complexity and stuff is able to say something more definite on that subject
15:14:14 <copumpkin> Heffalump: you around?
15:14:17 <opqdonut_> oh, sorry, "liftM (gmap x)"
15:14:17 <Heffalump> yes
15:14:24 <luite> merijn: or not well-defined...
15:14:37 <opqdonut_> :t elem True
15:14:38 <lambdabot> [Bool] -> Bool
15:14:39 <copumpkin> Heffalump: how come in suitable, you don't make Constraints an associated data type of Suitable?
15:14:42 <opqdonut_> :t liftM (elem True)
15:14:43 <lambdabot> forall (m :: * -> *). (Monad m) => m [Bool] -> m Bool
15:14:44 <Mitar> but also unction has to be lifted
15:14:44 <copumpkin> instead of a standalone data family
15:14:49 <Mitar> function inside
15:14:56 <Heffalump> haven't we had this conversation? :-)
15:15:03 <copumpkin> Heffalump: hmm, maybe :)
15:15:06 <Heffalump> different sets of parameters IIRC
15:15:07 <copumpkin> I didn't think so
15:15:12 <opqdonut_> Mitar: ah, sorry, I misread the type
15:15:12 <merijn> luite: Well, we have several definitions for *how* simple things are, so we just need pick a bound
15:15:39 <opqdonut_> Mitar: I don't think that's possible using just gmap...
15:16:12 <merijn> Is bugging researchers on IRC for explanations about their papers considered poor etiquette?
15:16:13 <Mitar> hmm
15:16:20 <copumpkin> Heffalump: hmm, I see!
15:16:27 <copumpkin> Heffalump: I want a Suitable2 :)
15:16:30 <copumpkin> for Category
15:16:37 <Heffalump> why?
15:16:44 <copumpkin> for restricted categories!
15:16:58 <Saizan> what's the advantage of an associated data? that you can make the instance inside the class instance?
15:17:00 <balor> Is there a cabal option to "follow all dependencies"?
15:17:01 <Heffalump> i.e. you want something for two parameter containers?
15:17:05 <copumpkin> Saizan: yep
15:17:07 <copumpkin> Heffalump: yep
15:17:31 <Saizan> balor: that's the default for "cabal install"
15:18:56 <Heffalump> copumpkin: I guess there's no reason not to add that to the suitable package, if you want
15:19:07 <copumpkin> I might send you a patch at some point
15:19:16 <copumpkin> for now it's just for tinkering
15:19:23 <copumpkin> and I don't really have a "legit" use for restricted categories
15:19:29 <Heffalump> can you give some examples of instances?
15:20:10 <copumpkin> well, I'm playing around with a partial order category, so I defined type-level naturals and a GADT representing their order
15:20:16 <copumpkin> and wanted to make that a category
15:20:29 <copumpkin> I have reflexivity and transitivity
15:20:30 <ivanm> copumpkin: I was thinking of adding something like Suitable2, but in the end I decided my restricted typeclass stuff was too much work for too little return :s
15:20:46 <banisterfiend> off for the w/e bye
15:20:57 * Heffalump wonders if he's been mixing up conversations with ivanm and copumpkin in his head
15:21:03 <ivanm> heh
15:21:40 <djahandarie> coivanm
15:22:44 <ivanm> no, there's no "co" version of me; the normal version of me is sufficient methinks :p
15:26:36 <aristid> codjahandarie disagrees
15:27:40 <c_wraith> Do the co- versions have goatees?
15:28:35 <roconnor> how do you do a goatee accent in latex?
15:28:43 <roconnor> some sort of upside down below hat
15:36:05 <aristid> c_wraith: and the non-co- versions have cogoatees
15:37:14 <copumpkin> c_wraith: I don't have a goatee, nope :)
15:41:32 <alpounet> jmcarthur, conal, you were having a great debate
15:41:40 <alpounet> and i share your PoV regarding math and programming
15:41:49 <conal> :)
15:41:58 <alpounet> but yeah, that's definitely not a popular one...
15:42:12 <alpounet> "hey, how is printing to stdout math?"
15:47:06 <copumpkin> lteIsNat (Ls s) | (IsNat, IsNat) <- lteIsNat s = (IsNat, IsNat)
15:47:12 <aristid> heck, i might agree if different wording was used, but i would never consider programming to be math
15:47:26 <conal> i view explicitly printing to stdout as explicitly implementing function call mechanics. when unix was invented, computers weren't fast enough, nor language design evolved enough to leave these low-level issues to the compiler.
15:47:41 <copumpkin> isn't that cute?
15:48:00 <copumpkin>   IsNat :: Nat a => IsNat a
15:48:02 <aristid> copumpkin: looks like invalid syntax?
15:48:09 <copumpkin> aristid: get with the times!
15:48:12 <copumpkin> it's h2010
15:48:24 <conal> and, interestingly, doug mcilroy knew that pipes and lazy evaluation were interchangeable. doug presided over the dept that invented unix, and doug himself invented pipes.
15:48:28 <aristid> which extensions do i need to load into Control.Brain?
15:48:37 <copumpkin> aristid: none at all :) just use GHC 7
15:48:46 <aristid> copumpkin: and in GHC 6.12? :P
15:48:50 <copumpkin> pff
15:48:55 <copumpkin> PatternGuards
15:49:29 <conal> (i go into more detail in my "modern marriage" google tech talk.)
15:49:30 <aristid> copumpkin: an alternative to view patterns?
15:49:40 <copumpkin> aristid: I use both
15:49:52 <conal> (http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/)
15:50:05 <aristid> copumpkin: that doesn't mean it's not
15:50:16 <copumpkin> I guess it's slightly more general than view patterns
15:50:36 <copumpkin> but yeah, you could replace all view patterns with pattern guards
15:51:32 <copumpkin> trans (Ls a) (Ls b) | (IsNat, IsNat) <- lteIsNat a, (IsNat, IsNat) <- lteIsNat b = Ls (trans a b)
15:54:22 <conal> copumpkin: you must blog!
15:54:39 <alpounet> yeah, agreed!
15:57:04 <copumpkin> okay :)
15:57:12 <copumpkin> tonight I'll work on getting it set up
15:57:17 <alpounet> seriously?
15:57:28 <copumpkin> fairly
15:57:49 <alpounet> let's get jmcarthur to do the same
15:57:51 <alpounet> and it'll be great
15:57:55 <copumpkin> :P
15:58:06 <copumpkin> anyway, time to go home from work now
15:59:05 <Mitar> is there around some implementation of bellman ford algorithm for haskell?
15:59:11 <conal> copumpkin: take care.
15:59:15 <copumpkin> thanks :)
15:59:25 <conal> jmcarthur: yeah -- what alpounet said.
16:00:02 <Veinor> whew, okay
16:00:09 <Veinor> I went through that material way faster than I expected
16:06:10 * ddarius needs an unsound "abstraction" function.
16:07:16 <roconnor> conal: any recent work on or replacement for GuiTV?
16:07:33 <conal> roconnor: i have a gtk version
16:07:37 * ddarius wonders if he can completely cheat and how inelegant that would be.
16:07:41 <roconnor> oooh
16:07:55 <roconnor> right on time since wxHaskell now complies reasonably :P
16:08:08 <conal> :)
16:08:16 <conal> @wiki GtkTV
16:08:23 <roconnor> conal: do you have a preference between wxHaskell and gtk for GuiTV?
16:08:28 * alpounet wishes qthaskell was better
16:08:54 <conal> roconnor: i like wxHaskell's API much better.
16:09:22 <roconnor> ok
16:09:43 * ddarius prefers, at least the basic structure of, Gtk and Qt more than wx.
16:10:28 <alpounet> actually
16:10:35 <conal> roconnor: i don't use wxHaskell because it kills ghci. jeremy is working on the problem.
16:11:03 <alpounet> i realize that i've never used a GUI library in any language that really made me feel like it was really, really the right way
16:11:07 <conal> kills its host process the second time a top-level window is opened
16:11:37 <roconnor> conal: ooh
16:11:42 <conal> alpounet: have you seen TV? you might like it. composable functional GUIs.
16:11:46 <conal> @wiki TV
16:11:46 <roconnor> that is a major minus
16:11:56 <conal> roconnor: yeah!
16:12:05 <alpounet> damn
16:12:10 <alpounet> that's quite hard to google
16:12:36 <djahandarie> append "haskell" or "conal" might help :P
16:12:39 <roconnor> alpounet: GuiTV is the only functional GUI system that I've ever had the pleasure to use.
16:12:53 <alpounet> yeah djahandarie 
16:12:55 <alpounet> got it now
16:13:03 <alpounet> thank to "composable"
16:13:32 <roconnor> alpounet: I sort of feel GuiTV is only good for little user interfaces, but I think a lot of the worlds problems are solved by software with little user interfaces.
16:13:41 <roconnor> little isn't quite the word I'm looking for
16:13:49 <sipa> simple?
16:13:56 <roconnor> simple is closer
16:14:12 <alpounet> yeah roconnor but well
16:14:16 <alpounet> it's still not all the problems
16:14:24 <roconnor> that being said I could be wrong.  It is unclear what would stop one from writing Photoshop with GuiTV.
16:14:31 <jmcarthur> alpounet, conal: *sigh* i know, i know
16:14:34 <sipa> time?
16:14:37 <alpounet> take a "dumb" example... an IM client
16:14:49 <aristid> :t let fork (f, g) a = (f a, g a) in fork
16:14:50 <alpounet> you just *can't* have little UIs
16:14:55 <aristid> NOOOOOOOOOOOOOOO
16:14:58 <roconnor> an simple IM client would be doable in GuiTV without trouble I think.
16:15:13 <Veinor> aristid: D:
16:15:27 <conal> roconnor: part of my master plan is to implement a photoshop competitor via tangible functional programming (which includes TVs).
16:15:35 <jmcarthur> conal: i want in
16:15:35 <alpounet> jmcarthur, yeah yeah you told me that in the past, but then nothing happened :P
16:15:47 <conal> jmcarthur: good. let's do it!
16:16:04 <alpounet> take sigfpe too
16:16:06 <augur> conal: lol
16:16:22 <conal> alpounet: i'd love to. though he has a real job.
16:16:27 <alpounet> yeah heh
16:16:45 <alpounet> i think he share our point of view about programming too
16:16:52 <alpounet> well, I *know* he does :P
16:16:53 <conal> yeah
16:16:54 <conal> other highlights: compile
16:16:55 <aristid> conal: i figure you still need to do a lot of basic research until that is feasible in a nice way?
16:17:11 <roconnor> conal: good idea.  That would really test the design.
16:17:18 <conal> other highlights: interactive rather than static media, and represented as GPU code.
16:17:36 <roconnor> I want to write a paint program.  I've written a paint engine before.
16:17:56 <aristid> how about a vector graphics editor?
16:18:02 <jmcarthur> and purely functional editing of course
16:18:09 <alpounet> roconnor, conal: TV looks nice... my main worry is, like you said, how it scales to larger examples
16:18:53 <roconnor> alpounet: what is sigfe's skills?
16:19:07 <conal> alpounet: still two big puzzles: designing a user experience for revision (editing), and visualizing polymorphic values.
16:19:12 <augur> is there a name for a system where you have a set of disjointly typed items that are all addressable as a whole?
16:19:27 <alpounet> I mean I've written (with 2 other guys) a tokamak monitoring platform for physicists... that means a *LOT* of code only for GUI
16:19:35 <alpounet> the GUI*
16:19:45 <jmcarthur> we need to improve on http://www.vips.ecs.soton.ac.uk/index.php?title=Nip2
16:19:51 <alpounet> i wonder how it would look like with TV
16:19:57 <augur> like, if you have x = {4,"abc"} you could do sqrt x = 2 and reverse x = "cba"?
16:20:00 <alpounet> roconnor, well... about everything ?
16:20:01 <alpounet> :P
16:20:05 <roconnor> :)
16:20:12 <augur> or sqrt x = {2,"abc} and reverse x = {4,"cba"}
16:20:17 <aristid> jmcarthur: start by getting a domain for the project, that would be a huge improvement over www.vips.ecs.soton.ac.uk already :P
16:20:22 <jmcarthur> ha
16:20:31 <alpounet> conal, are your more or less actively working on it still ?
16:20:32 * Eduard_Munteanu thinks WriterT is seriously useful for writing monadic equivalents of list functions.
16:20:40 <augur> i feed like thats related to the scrap-your-boiler-plate function everywhere
16:20:51 <roconnor> jmcarthur: wow, I thought nothing could be worse than the gimp
16:21:17 <djahandarie> lol.
16:21:28 <jmcarthur> roconnor: the nice thing about nip2 is that it is purely functional image editing
16:21:30 <conal> alpounet: i've been working on a functional->gpu compiler. which will be a part.
16:21:39 <jmcarthur> roconnor: it's just kind of clumsy in the interface
16:21:44 <roconnor> jmcarthur: oh, maybe it is better than the gimp :D
16:22:03 <Eduard_Munteanu> Rather, different.
16:22:08 <jmcarthur> roconnor: it even has its own lazy functional programming language
16:22:08 <systemfault> The gimp? Yeah... They made poor choices
16:22:27 <roconnor> my paint program was way better :D
16:22:50 <conal> i've lost a lot of motivation for developing functional graphics & UIs due to problems with graphics & UIs on the mac in haskell. nothing i can find works.
16:23:05 <jmcarthur> conal: virtualbox works ;)
16:23:25 <roconnor> do mac's have hardware virtualization support?
16:23:31 <jmcarthur> yeah
16:23:34 <alpounet> yeah but launching virtualbox just to developed functional graphics stuffs is quite annoying
16:23:36 <conal> jmcarthur: yeah. i might go that way.
16:23:37 <systemfault> It's not a mac thing..
16:23:43 <systemfault> It's a CPU feature.
16:23:53 <conal> alpounet: zakly.
16:23:57 <jmcarthur> systemfault: true, but all modern macs have cpus that support it
16:24:06 <systemfault> Indeed
16:24:20 <systemfault> I haven't seen a difference though...
16:24:39 <jmcarthur> conal: at my last job i did mainly kernel programming. i arranged for my computer to transparently launch virtualbox in the background on boot and then i would simply connect to it when i wanted to use it
16:24:51 <jmcarthur> that way it was always there
16:25:05 <conal> jmcarthur: ah.
16:25:22 <jmcarthur> and i could just ssh, use X forwarding, or pull up an actual display through virtualbox, without having to wait
16:25:23 <mux> has anyone else ever needed a datatype such as 'data OneOrBoth a b = First a | Second b | Both a b' ? just being curious
16:26:00 <edwardk> mux: we use it here a fair bit
16:26:02 <roconnor> systemfault: I had to upgrade my bios to get virtualization support.  It made a huge different to me on my Acer Aspire
16:26:02 <conal> i imagine the haskell+mac+graphics mess is fixable, but i don't have the right skills. i guess few people care.
16:26:22 <jmcarthur> mux: just today, actually, but i had an additional case for Neither. i ended up just going with (Maybe a, Maybe b)
16:26:54 <mux> jmcarthur: I moved from (Maybe a, Maybe b) and in my case it made things a lot better :-) I had no use for a (Nothing, Nothing) case
16:27:00 <jmcarthur> ah
16:27:24 <edwardk> mux: one of the guys here has an 'alignable functor' that he winds up using that in to avoid having to provide a case that he can't implement
16:27:59 <djahandarie> Maybe I'll use GuiTV to write my dream IRC client. :)
16:28:27 <mux> edwardk: and what would that alignable functor be?
16:28:31 <edwardk> djahandarie: it isn't looking good for you timing wise. copumpkin is gone from the 15th to the 18th
16:28:38 <roconnor> djahandarie: that's a good idea
16:28:49 <djahandarie> edwardk, :(
16:29:00 <djahandarie> edwardk, what about his dual? :P
16:29:06 <copumpkin> I wish people were more open to weekends
16:29:09 <copumpkin> cause then djahandarie could make it
16:29:18 <edwardk> mux: we have a number of them, maps, etc.
16:29:26 <copumpkin> imposing it on weekdays pretty much rules out anyone who has school/work and lives a nontrivial distance away
16:29:40 <copumpkin> djahandarie: just skip class
16:29:44 <djahandarie> -_-
16:29:45 <edwardk> copumpkin: yeah, but its also an overwhelmingly larger crowd
16:29:48 <copumpkin> yeah
16:30:28 <monadic_kid> you have one problem with using virtual machines regarding doing GPGPU or any 3d graphics, the graphics card is virtualized, VMs like virtual box have only recently (last few years) offically support hardware accelerated 3D graphics on the guest, typically via foward gl/dx calls to opengl, last time I checked virtual box support opengl 2.0. Chances of support for GPGPU programming on a vm at the moment are quite slim I'd imagine
16:30:48 <djahandarie> I have so many projects on my projects list that I shouldn't be adding stuff to it though, so I'll leave the irc client for later ;)
16:32:36 <conal> monadic_kid: hm. thx for the warning. more bleeding edge than i'd want to deal with.
16:33:41 <ddarius> conal: I have a somewhat odd question.  What kind of music do you listen to?
16:34:11 <conal> ddarius: various. mostly new age & vocal jazz these days.
16:36:36 <monadic_kid> conal: I do use virtualbox a lot and a linux vm for haskell development it's quite good but I don't know what version of gl support it uses now, I can't imagine support for GL3/4 now
16:37:13 <aristid> getting a physical linux laptop might be easier
16:38:15 <conal> yeah. i'd rather the mac+haskell problems got fixed. i can't be the only one who cares.
16:38:29 <blackdog> conal: the 64-bit stuff?
16:38:41 <alpounet> ok conal TV definitely looks awesome
16:38:44 <blackdog> i just burned a day making sure RVM works in 32 bit mode because of it:/
16:38:53 <conal> blackdog: no. availability of working interactive graphics.
16:39:12 <monadic_kid> conal: i thought on the macs I can't remember the name but you can have OS installed on a real parition for dual booting?
16:39:27 <blackdog> monadic_kid: boot camp
16:39:28 <conal> monadic_kid: maybe Parallels.
16:39:38 <conal> oh yeah. boot camp.
16:40:43 <blackdog> monadic_kid: one sneaky trick if you need a linux box - amazon ec2 micro insntances are free for a year if you're a new customer
16:40:53 <blackdog> which equates to using a credit card they haven't seen before, basically.
16:41:14 <roconnor> wow, SpecWare sounds like a tool that can legimately be used for "software engineering"
16:41:51 <cads> blackdog, you're kidding
16:42:19 <blackdog> cads: http://aws.amazon.com/free/
16:42:20 <cads> blackdog, do you need to commit for beyond that year?
16:42:39 <blackdog> no. if you keep using it, you'll get charged, obviously.
16:42:45 <cads> fantastic
16:42:58 <blackdog> i'm running ci.shimweasel.com and an irc bouncer on mine:)
16:43:00 <cads> thanks for sharing that info with people man!
16:43:30 <blackdog> np.
16:45:23 <aristid> and i did not qualify because i signed up 2 weeks too early
16:46:10 <blackdog> aristid: sign up with another credit card. i was in the same position.
16:46:30 <blackdog> if you're feeling profligate, the big instances are rather nice build machines.
16:47:10 <aristid> blackdog: i only have one credit card :P
16:47:41 <aristid> blackdog: fortunately my laptop is running linux, so i have no mac problems ;)
16:48:11 <blackdog> heh. i got mine mostly because i was sick of downtime every time i rebooted my dev machine:)
16:49:45 <aristid> huh? i don't need to reboot my dev machine that often
16:50:10 <gwern> is ec2 really that expensive?
16:50:26 <gwern> I mean, I pay like $6 a month to back up 30 gigs or so on s3
16:51:06 <gwern> the old quip 'linux is free if your time has no value' comes to mind with this offer
16:51:31 <gwern> (34G to be precise, and then whatever bandwidth charges I incur for my daily or bidaily backups)
16:51:36 <sproingie> ec2 is for cpu, not storage
16:51:42 <blackdog> gwern: it can mount up if you're using the bigger instances.
16:52:23 <blackdog> $2 an hour for the big ones, for instance
16:52:46 <cads> dude
16:52:46 <gwern> sproingie: I know, my implicit argument was something like 's3 is pretty darn cheap so maybe ec2 would be darn cheap too?'
16:52:48 <cads> this is great
16:53:14 <cads> as long as I'm not poor when the year is up
16:53:15 <blackdog> admittedly, for that $2 an hour, you get 23 gb of memory and 34 compute units
16:53:24 <cads> !
16:54:08 <gwern> blackdog: what is a compute unit? I was thinking 2$/hr could really add up
16:54:41 <sproingie> ec2 is cheaper than expanding your data center
16:55:04 <blackdog> gwern: "One EC2 Compute Unit provides the equivalent CPU capacity of a 1.0-1.2 GHz 2007 Opteron or 2007 Xeon processor"
16:55:05 <sproingie> if you already have the spare cpu in-house then perhaps it isn't, but that's not usually the case
16:55:09 <gwern> also, every time I log in I can't help but think, 'Amazon, my bookseller, is also my computing utility?'. who could have guessed this back in the mid/late 90s?
16:55:46 <sproingie> i buy damn near everything off amazon
16:55:56 <gwern> blackdog: hm. need some pretty parallel code to take advantage of that many slow serial processors, but you said that was one of the biggest instances available
16:56:05 * geheimdienst thought ec2 was best if you have spikes ... "we need a lotta power for a few days"
16:56:26 <blackdog> gwern: http://aws.amazon.com/ec2/instance-types/ has the breakdown
16:56:36 <cads> hmm
16:57:01 <gwern> geheimdienst: spikes can also just be 'I need a lot of power for a little while'; every so often I run across a dev blog post about how they used ec2 for some project they thought of. genetic programming was the last one I remember
16:57:01 <blackdog> gwern: i think the bigger ones actually have about 3 ECUs per core
16:57:13 * cads is trying to think of all the minitasks he never got around to doing because he just didn't have the reliable compute power
16:57:26 <cads> living on only a laptop is rough sometimes
16:57:28 <gwern> geheimdienst: since genetic programming is highly parallel and absorbs nigh-infinite computing power with appropriate options
16:57:46 * ddarius has only had a laptop for the past four years.  Less before that.
16:57:46 <aristid> cads: quite possible tho
16:57:47 <blackdog> if you break it down by cost per minute/hour, usually ec2 will come out behind - the whole point is to scale your costs with your success
16:57:47 <roconnor> does repa work with GHC 7?
16:58:10 <gwern> I also saw one for setting up a VPS on an ec2 instance for getting around firewalls and other such restrictions. that sounded interesting
16:58:26 <blackdog> to bring it vaguely back on track: one of my hoping-to-get-around-to goals is to get accelerate going on one of the GPU clusters they offer
16:58:36 <alpounet> roconnor, there also is accelerate now
16:58:41 <alpounet> for the same kind of tasks
16:58:42 <alpounet> iirc
16:58:46 <roconnor> what is accelerate?
16:58:52 <cads> ddarius, what do you do when you want to process large chunks of data?
16:59:09 <blackdog> a parallel programming framework designed to be useful for GPUs
16:59:21 <alpounet> oh yeah right it's mostly for GPUs
16:59:24 <ddarius> cads: I use my laptop, but I don't think it's ever come up too much.
16:59:32 <gwern> GPU clusters - the beowulf of the 2010s
16:59:38 <blackdog> i know trevor lee has been working on the CUDA stuff.
16:59:56 <blackdog> heh. yeah. i've been wracking my brains trying to think of compute-intensive stuff you could offer as a service.
17:00:39 <ddarius> cads: Most things I'd want to do that are compute-intensive wouldn't really be much benefitted by having a bigger box or even several of them.
17:01:26 <gwern> yeah. if you have need of it, you already know your need. not everyone is the NYT team that wants to convert a few million PDFs in a week or something
17:01:34 <ddarius> cads: Most of the rest can wait; if raytracing a scene or rendering a fluid animation takes a few days, so be it.
17:01:43 <roconnor> repa isn't for GPUs is it?
17:01:56 <blackdog> gwern: sometimes, though, you're so used to your limitations that more ambitious goals don't even occur to you
17:02:15 <cads> ddarius, I use my laptop for school, so it travels a lot. It must be sad for it. The life it experiences must feel like the life of a narcoleptic
17:02:22 <blackdog> ruby guys almost instinctively do just about nothing per request.
17:02:57 <nooodl> foldl (\x y -> x*10+y) 0
17:03:01 <nooodl> any cleaner way to write this?
17:03:05 <ddarius> blackdog: Which is probably the right thing to do as far as the "critical path" is concerned.
17:03:18 <ddarius> nooodl: Use foldl'.
17:03:21 <gwern> blackdog: that is true of many times, but I'm not sure it is of ec2. ec2 doesn't let you think new thoughts so much as speed up current thoughts - you can already do ec2-like things by running overnight
17:03:29 <ddarius> (Though it probably won't matter for your inputs.)
17:03:57 <gwern> @pl foo x y = x*10+y
17:04:02 <blackdog> ddarius: generally, yes. but there are probably useful possible apps that do need reasonable computation per request
17:04:05 <cads> hey, would you guys advise strongly against uploading pirated material to my free ec2 instance?
17:04:07 <nooodl> lambdabot is gone, it seems.
17:04:13 <gwern> piffle
17:04:36 <blackdog> gwern: i was doing some linguistic analysis a while ago, and the machine really was my bottleneck.
17:04:40 <gwern> think it would've rewritten it to (* 10) . (+) or something atrocious like that
17:05:04 <blackdog> cads: i would certainly recommend against discussing it on a public and archived channel.
17:05:11 <cads> ah shoot
17:05:16 <ddarius> blackdog: You mean useful targets for a DoS.
17:05:18 <sproingie> amazon won't go out of their way to police your ec2/s3 instance, but if they do catch wind of it they'll nuke your account first and ask questions later
17:05:26 <cads> thanks blackdog
17:05:51 <blackdog> ddarius: sure. so maybe it needs to be behind a login, or a paid plan. there are lots of potential objections.
17:05:54 <ddarius> (+) . (10*)
17:06:01 <blackdog> i'm just talking about the scope of the possible.
17:07:22 <cads> blackdog, I think I'm going to use it for a little personal chess engine service
17:07:53 <gwern> cads: if I were hosting pirated material on a service, I'd look into light-weight encryption
17:08:40 <gwern> hm, or maybe set up a seedbox on an ec2 instance so there's no obvious URL to send to amazon for them to inspect. bittorrent would work nicely
17:08:45 <cads> hmm, this reminds me of homomorphic encryption
17:09:11 <ddarius> gwern: To respond to your earlier remark, sometimes a quantitative difference makes a qualitative difference as the history of computing amply demonstrates, albeit with -massive- quantitative differences.
17:09:25 <ddarius> Still, two orders of magnitude is the difference between a week and a year.
17:09:44 <cads> gwern, I'd wish to host the material not to share it, but to reprocess it
17:10:01 <cads> well, not necessarily to share it
17:10:05 <cads> I'm not doing any of that
17:10:11 <cads> chess engine ;)
17:10:18 <gwern> ddarius: most of the examples in AI I can think of were well thought about before the power was available. we had public key, GC, computer vision, data mining, lazy evaluation etc developed & implemented long before we had the power to make it practical
17:10:53 <cads> I will have a chess section on my site that plays correspondence games against a limited set of users, and serves up chess database info
17:11:57 <gwern> sounds like something that's already been done. I know a go site which hosts some gnugo bots
17:11:59 <ddarius> cads: You could look into zero knowledge proofs and secure multiparty computing... if you want to be on the bleeding edge of cryptography.
17:12:30 <roconnor> cads: you should upload random data to your ec2 account.  And then have someone else upload random data to their ec2 account.  Should it happen that the xor of those two files produce an mpg movie of Ferris Buller's Day Off, you can each point the finger at the other.
17:12:43 <ddarius> (Well perhaps not the bleeding edge theoretically.)
17:14:45 <ddarius> If you encrypt your EC2 instance, be sure to use a system with plausible deniability should you be forced to decrypt it.
17:17:35 <Veinor> does haskell have a fast modular exponentiation package?
17:17:36 <roconnor> how would people know it is encrypted?
17:17:49 <cads> ddarius, I'd love to know about that kinda stuff :)
17:17:52 <blackdog> i remember looking into rubberhose a while ago, and thinking that julian assange was a cynical man...
17:18:03 <cads> ddarius, have you read about post-quantum classical cryptography?
17:18:05 * roconnor used to run a hosted server with encrypted root
17:18:16 <ddarius> cads: Nope.
17:18:43 <blackdog> on the topic, it might be instructive to consider bradley manning. perfect technical solution, which he managed to ruin by talking about afterwards.
17:19:03 <roconnor> blackdog: cads is talking about it beforehand
17:19:08 <roconnor> tooooootaly different
17:19:09 <ddarius> Why do people even bother supporting DES?
17:19:23 <roconnor> 3DES?
17:19:35 <blackdog> roconnor: rubberhose? isn't the point that you can never prove that there isn't another key?
17:19:37 <ddarius> roconnor: No, it supports 3DES as well.
17:19:41 <blackdog> surely that's plausible deniability
17:19:42 <danharaj> haracter
17:20:09 <roconnor> blackdog: do you mean rubberhose in some techinal sense that I don't know?
17:20:12 <ddarius> blackdog: It is well known that -by far- people are the weak link in computer security.
17:20:22 <ddarius> http://iq.org/~proff/marutukku.org/
17:20:29 <blackdog> roconnor: oh, sorry. it's a piece of software assange wrote a while ago
17:20:31 <Eduard_Munteanu> What's the dual to 'last', say 'f', so that 'f xs ++ [last xs] == xs'?
17:20:36 <ddarius> To protect against http://en.wikipedia.org/wiki/Rubber-hose_cryptanalysis
17:20:39 <roconnor> blackdog: what does it do?
17:20:44 <ddarius> Eduard_Munteanu: init
17:20:51 <Eduard_Munteanu> :t init
17:20:58 <blackdog> roconnor: http://iq.org/~proff/marutukku.org/current/src/doc/maruguide/t1.html
17:20:58 <Eduard_Munteanu> ddarius: thanks
17:20:59 <roconnor> [a] -> [a]
17:21:00 <ddarius> Eduard_Munteanu: Of course both last and init are slow O(length xs)
17:21:10 <Eduard_Munteanu> Yeah, I know.
17:21:31 <blackdog> the idea is that if you encrypt a chunk of data usually, the adversary knows that a key exists, and that you know it
17:21:50 <blackdog> so beating you will get it.
17:22:04 <blackdog> with rubberhose, you can have multiple levels of keys.
17:22:10 <ddarius> Admittedly, some of the human weakness is the fault of computer security theoreticians and, much more, current computer security practices.
17:22:16 <blackdog> and you can never prove to your torturers that you've told them everything
17:23:13 * geheimdienst defends against this kind of cryptanalysis http://xkcd.com/538/ by only giving out the key that decrypts his lolcat collection
17:23:37 <gwern> good ol steganographic filesystems
17:23:54 * sproingie hits geheimdienst with the wrench til he reveals the location of what he's after
17:24:09 <sproingie> you have to give them something, otherwise they just assume you have the data somewhere else
17:24:24 <roconnor> thankfully my biggest threat is a court of law.  All I need is reasonable doubt.
17:25:01 <geheimdienst> sproingie, i gave them the key to my lolcat collection! invaluable!
17:25:45 <sproingie> it did add some levity to my every day routine as a torturer, yes
17:26:06 <blackdog> geheimdienst: part of the protection rubberhose gives you is dependent on not making the torturer want to torment you _anyway_
17:26:33 <geheimdienst> lol
17:27:03 <mrkotfw> Hello everyone.
17:27:39 <blackdog> mrkotfw: what secrets are you hiding?!
17:27:56 <blackdog> mrkotfw: I mean, hi! would you like to learn about haskell?
17:28:05 <mrkotfw> Haha
17:28:08 <sproingie> thing is if they *know* you're in possession of the documents, all the crypto in the world won't help
17:28:13 <mrkotfw> I'm just starting out
17:28:26 <mrkotfw> I've been a C programmer for far too long...
17:28:27 <roconnor> on my old laptop I'd boot from usb key.  Without a USB key my laptop would just say "No OS Found" and halt.
17:28:32 <sproingie> something like rubberhose i suppose could act as misdirection in that case
17:28:39 <mrkotfw> I'm just amazed on how beautiful Haskell code is
17:28:43 <geheimdienst> anyhoo, there's the theory that torture tends to make you tell the torturer what he wants to hear. supposing someone is truly innocent and truthfully says "there's no more data in my rubberhose"
17:28:46 <mrkotfw> It's so clean
17:29:00 <roconnor> mrkotfw: \o/
17:29:01 <blackdog> mrkotfw: it is indeed. have you checked out the FFI?
17:29:02 <sproingie> mrkotfw: no, Clean is clean :)
17:29:15 <roconnor> mrkotfw: and people call it line noise ... bah
17:29:18 <mrkotfw> blackdog: I haven't
17:29:22 <geheimdienst> the torturer might just go on torturing because of that, and you can never prove that there's not some secret left ...
17:29:29 <ddarius> Actually, Clean has some warts, but then it does do some stuff better than Haskell.
17:29:30 <blackdog> even the C interface is pretty nice.
17:30:09 <mrkotfw> Actually, I'm trying to see how I can suppress the startup message in GHCi
17:31:04 <blackdog> unless you're trying to bind to preprocessor macros. *growls at ruby*
17:31:31 <ddarius> geheimdienst: If your torturers are willing to torture you to death, they are probably going to do that regardless.
17:32:29 <geheimdienst> yeah ... i just meant that rubberhose's "can't prove there isn't another layer" works both ways
17:32:58 <blackdog> geheimdienst: that's almost the point.
17:33:40 <blackdog> mrkotfw: hm, not sure if you can.
17:33:55 <blackdog> do you mean the line that comes up "GHCi, version Foo" ?
17:35:10 <alpounet> you can still modify GHCi's code and rebuild it
17:35:34 <ddarius> ghci -v0
17:36:28 * hackagebot kit 0.6.3 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.3 (NickPartridge)
17:36:35 <roconnor> where is dph-prim-par and dph-prim-seq?
17:36:50 <blackdog> ddarius: that's cute - can you set that in .ghci too?
17:37:21 <gwern> 'SDF uses DEC Alphas and AMD Opterons running NetBSD, TOPS-20 and Symbolics GENERA' <-- huh. SDF didn't have tops-20 or Genera last time I was there...
17:37:22 <alpounet> you can create an alias if not
17:37:27 <mrkotfw> ddarius: Thanks
17:37:37 <mrkotfw> blackdog: Eh, I could...
17:38:14 <geheimdienst> alphas are still around? and symbolics, aren't they the guys with the lisp machines?
17:38:43 <nooodl> f (+) [(1,2),(3,4),(5,6)] ==> [3,7,11]
17:38:51 <nooodl> which function am i looking for? :)
17:38:59 <sproingie> there's a company that bought up symbolics, but lisp machines are long gone
17:39:07 <ddarius> map . uncurry
17:39:09 <sproingie> genera is basically a software version of the lisp machine os
17:39:19 <nooodl> oh, here i was trying map . curry
17:39:34 <Bynbo7_> :t map . curry
17:39:46 <Bynbo7_> lambdabot!
17:39:48 <Bynbo7_> >__<
17:39:56 <roconnor> @seen benl
17:39:56 <preflex>  Sorry, I haven't seen benl
17:40:43 * roconnor worries repa doesn't build with GHC 7 at all
17:40:51 <geheimdienst> cale, you around? lambdabot has been kidnapped by raccoons again
17:41:25 <ddarius> Did you ever wanna take bad advice?  Did you ever wanna go and take it twice?
17:41:35 <copumpkin> preflex: seen benl23
17:41:36 <preflex>  benl23 was last seen on #ghc 48 days, 21 hours, 12 minutes and 2 seconds ago, saying: wrong channel
17:41:46 <copumpkin> preflex: seen TacticalGrace
17:41:46 <preflex>  TacticalGrace was last seen on #ghc 53 days, 1 hour, 57 minutes and 10 seconds ago, saying: ok
17:41:52 <copumpkin> preflex: seen ChilliX
17:41:53 <preflex>  ChilliX was last seen on #ghc 1 year, 22 days, 13 hours, 40 minutes and 26 seconds ago, saying: sorry, bundled with gmp
17:41:55 <copumpkin> man
17:42:11 <copumpkin> you aussies should hunt them down
17:42:26 <gwern> sproingie: genera was the symbolics OS, and it didn't die with the lisp machines but lingered on the DEC Alpha for a number of years iirc
17:42:46 <roconnor> @seen ndm
17:42:47 <preflex>  ndm was last seen on #haskell 15 days, 6 hours, 26 minutes and 31 seconds ago, saying: if you don't, then there was a parse error
17:42:50 <roconnor> woah
17:43:05 <blackdog> copumpkin: he's like, 15 km away. Way out in the boonies.
17:43:06 <sproingie> there's probably some genera installations out there even now
17:43:06 <geheimdienst> gwern, interesting, thanks
17:43:14 <copumpkin> blackdog: damn, maybe not then
17:43:26 <gwern> sproingie: sure, and emulators for them
17:43:31 <blackdog> of course, not as far out in the boonies as Bynbo7 
17:43:31 <ddarius> 15km is like a two hour walk.
17:43:51 <gwern> I ran genera in an emulator once. it was interesting
17:45:44 * ddarius considers making a (linear?) higher order pattern unification library.
17:46:40 <copumpkin> ooh
17:46:43 <copumpkin> I'd like that
17:49:31 <Cale> Kidnapped by raccoons!
17:49:49 <djahandarie> Damn raccoons.
17:50:09 <djahandarie> @botsnack
17:50:14 <lambdabot> :)
17:51:05 <Axman6> :t map . curry
17:51:12 <ivanm> copumpkin: what should we be hunting down?
17:51:12 <lambdabot> forall a b c. ((a, b) -> c) -> [a] -> [b -> c]
17:51:20 <copumpkin> TacticalGrace and/or benl23
17:51:33 <ivanm> eh, they're in NSW
17:51:46 <ivanm> that part of the country is filled up with wierdos, like blackdog :p
17:51:55 <copumpkin> and Axman
17:52:00 <ivanm> nah, he's from ACT
17:52:10 <copumpkin> I thought he'd worked with benl23 at some point
17:52:18 <Axman6> what did you say about my mother copumpkin?
17:52:19 <geheimdienst> thanks cale!
17:52:19 <ivanm> yeah, when benl23 was still at ANU in the ACT
17:52:28 <copumpkin> oh I see
17:52:41 <Cale> geheimdienst: Thanks for pointing it out
17:52:48 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:53:36 <copumpkin> did it keep my @ask ?
17:54:20 <Cale> I could turn on TupleSections
17:54:50 <copumpkin> (is there a but coming?) thank you!
17:55:11 <ddarius> but who would ever need tuple sections and why?
17:55:25 <aristid> ddarius: for convenience?
17:55:56 <Axman6> when you need to do zipWith3 (5,"hello",,Nothing,,True,) as bs cs!
17:56:15 <ivanm> ddarius: I've used them when I was writing a quick throw-away program, but doubt I would use them in production
17:56:15 <Axman6> :t (5,"hello",,Nothing,,True,)
17:56:17 <lambdabot> Illegal tuple section: use -XTupleSections
17:56:23 <ivanm> since it's easy enough to do away with that extension
17:56:46 <Cale> copumpkin: But I'm a little busy at the moment. Keep bugging me if I don't do it by the end of tonight :)
17:59:16 <sseefried> Hi guys, I was just having a look at the fclabels package on Hackage. It states that it provides first class labels that are fully composable. I was just wondering what it was about regular record labels that were found wanting.
17:59:36 <copumpkin> Cale: sure thing :)
17:59:50 <edwardk> seafood: fclabels are useful if you want to access members of members of members of members of...
18:00:12 <edwardk> seafood: they compose unlike traditional labels
18:01:04 <edwardk> ddarius: i _like_ tuple sections, they remove an irregularity in the grammar, admittedly a very odd one
18:01:06 <etpace> @hoogle concatMaybes
18:01:06 <lambdabot> No results found
18:01:15 <etpace> @hoogle [Maybe a] -> [a]
18:01:15 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
18:01:16 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
18:01:16 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
18:01:28 <etpace> > catMaybes [Just 5, Nothing, Just 7]
18:01:29 <lambdabot>   [5,7]
18:03:02 <geheimdienst> seafood, my guess is that fclabels fix problems like this: suppose you have myRecord { theFieldToUpdate = 42 } -- now what you can't do with regular records is: (\x -> myRecord { x = 42 }) theFieldToUpdate
18:03:08 <seafood> edwardk: That isn't obvious to me. If I declare data R1 = R1 { r1 :: R2 } and data R2 = R2 { r2 :: Int } then I can compose r2 and r1 with (r2 . r1) just fine. Just tried it out.
18:03:23 <geheimdienst> so you can't pass the field name into the function like that
18:03:33 <edwardk> seafood: that works to read. now update the r2 field of the r1 field of a value i give you
18:04:15 <edwardk> with a lens/fclabel that is set (r2 . r1) 12380
18:04:32 <edwardk> (using the . from Control.Category)
18:05:15 <edwardk> i wind up using fclabels to avoid writing a ton of boilerplate code
18:05:19 <ivanm> hey edwardk 
18:05:41 <pumpkin> I'd like fclabels to have a dedicated modify method
18:05:45 <pumpkin> rather than a get + set
18:06:08 <ivanm> edwardk: did you see my latest blog post on graph labels?
18:06:31 <sshc> pumpkin: What exactly do you have in mind?
18:07:20 <edwardk> e.g. i have some kind of class HasFoo a { foo :: Label a Foo } , and then i have a bunch of primitive member accessors that know how to go from Foo down to some member field, so i then compose them and make a bunch of accessors that know how to access those fields out of anything that HasFoo, one time boilerplate, and the depth of my inheritance hierarchy doesn't cost me 
18:07:22 <seafood> edwardk: Ah. Now I see.
18:07:34 <pumpkin> sshc: well, if I wanted lenses into a Map or some other associative structure that has a more efficient update method than a get + set
18:08:23 <edwardk> ivanm: yeah, though, we already went over my approach to handling labeling without duplication =P
18:08:43 <ivanm> edwardk: yeah, but I'm talking about something to use for _all_ types of graphs
18:08:47 <edwardk> personally i don't find duplication in libraries to be as abhorrent as duplication in client cod
18:08:55 <ivanm> rather than a specific type
18:09:01 <ivanm> edwardk: what do you mean?
18:09:09 <edwardk> this was the comonadic graph stuff
18:09:24 <ivanm> yeah, you were going to use different tags, etc.
18:09:25 <edwardk> tracking shape separately from annotations, phantom types, all that
18:09:32 <ivanm> but I thought most of them get the same operations, just got new ones
18:09:46 <ivanm> and by "what do you mean", I was referring to your duplication statement
18:10:31 <edwardk> i mean without duplication of code for handling different graph types, because the labeled and unlabeled graphs are just graphs with different annotations attached. they unify under my more bizarre framework
18:11:10 <ivanm> so are you saying it's OK to have duplicate functions in the library as long as the end user doesn't have to duplicate stuuff?
18:11:19 <edwardk> personally, i think so
18:11:36 <ivanm> and yes, your bizarre framework sounds cool for actual normal graph data structures, but not to cover all graph-like data structures
18:11:40 <edwardk> you've spent a year or so beating your head on how to remove duplication and tried a dozen designs to avoid a factor of 2-3 code bloat
18:11:51 <edwardk> just saying ;)
18:12:19 <sshc> pumpkin: I don't see how that would work with pure structures
18:12:23 <ivanm> edwardk: well, what I was trying to get through to the people replying to my post is that if you don't know if labels are there or not, you will end up writing duplicate code
18:12:30 <sshc> pumpkin: Can you think of an example?
18:13:16 <edwardk> sshc: the modify works fine with pure structures.
18:13:24 <edwardk> sshc: put is just a modify with a constant function
18:13:53 <ivanm> e.g. I don't think this function can be defined without duplication for anything without compulsory labels: http://hackage.haskell.org/packages/archive/graphviz/2999.11.0.0/doc/html/Data-GraphViz.html#v:preview
18:14:21 <edwardk> the usual lens is data Lens a b = Lens { get :: a -> b, set: b -> a -> a } ‚Äî you can replace it with data Lens a b = { get :: a -> b, mod:: (b -> b) -> a -> a }
18:14:39 <sshc> edwardk: I'm already quite familiar with fclabels.
18:15:33 <edwardk> sshc: then i'm not sure how pumpkin's modify is better than put comment, didn't immediately make sense =)
18:16:12 <edwardk> sshc: it can typically avoid a factor of 2 in workload, because the usual lenses have to walk down to get the value, then walk all the way back down and replace it
18:17:32 <ivanm> edwardk: so do you mean about duplication that it's OK for all libraries dealing with graphs to have duplication, or that duplication is preferable only in the classes and instances?
18:18:15 <edwardk> ivanm: well, i've already given up on the library design you are aiming for. i was making a more general purpose statement that you've spent a lot of time letting the perfect be the enemy of the good ;)
18:18:23 <ivanm> heh
18:18:36 <ivanm> what do you mean by "given up", in that you don't care about designing such a thing yourself?
18:18:47 <ivanm> and are going more for a specialised co-monadic one?
18:19:38 <edwardk> i actually moved to one that just abuses stable names to extract graph structures out of plain old haskell data types for nodes.
18:19:46 <edwardk> that works for my applications, but isn't general purpose
18:19:57 <edwardk> the comonadic one is general purpose, but i'll admit i got sick of explaining it ;)
18:20:33 <ivanm> heh
18:20:49 <ivanm> edwardk: well, if you implement+document it you won't have to explain it... :p
18:21:06 <edwardk> but what i mean was that losing the ability to map over the nodes/edges in fgl kind of put me off of it, because it destroyed the few usecases i had left for it
18:21:08 <ivanm> by "general purpose", you mean it will even work for something like Cabal's package dependency type?
18:21:40 <ivanm> what do you mean by losing the ability to map? because of it no longer being kind * -> * -> * ?
18:22:04 <edwardk> yes, because your instances are now wedded to the types In the nodes/edges
18:22:16 <edwardk> it just means i can't use the library
18:22:25 <edwardk> still i have the current fgl ;)
18:22:43 <edwardk> until you tromple on the namespace and name
18:22:49 <ivanm> yeah; I'm waiting for superclass constraints to get implemented (apparently in 7.0.2 \o/) so that mapping will work again
18:23:45 <Random75> :t Just
18:23:46 <lambdabot> forall a. a -> Maybe a
18:24:00 <edwardk> i'm not sure they'll help you
18:24:34 <edwardk> at least not in a way that'll help me
18:24:41 <ivanm> sure they will: type (Graph (g a b), NLabel (g a b) ~ a, ELabel (g a b) ~ b) => MappableGraph g a b where ...
18:24:44 <pumpkin> needmoar languidge feetyurz
18:25:04 <pumpkin> preflex: seen NEEDMOAR
18:25:04 <preflex>  NEEDMOAR was last seen on ##logic 33 days, 23 hours, 50 minutes and 23 seconds ago, saying: I would state it if b = a and a = c, then b = c (transitivity).
18:25:09 <ivanm> (actually, I can't recall if that `a' and `b' in the class definition is needed or not)
18:25:19 <edwardk> that only works if a and b are concrete types.
18:25:30 <ivanm> edwardk: without the superclass constraints, it will work but with really ugly type sigs for the mapping functions
18:25:44 <ivanm> edwardk: as opposed to?
18:26:15 <Random75> :t Maybe
18:26:17 <lambdabot> Not in scope: data constructor `Maybe'
18:26:25 <edwardk> yes, but the resulting ugly type sig doesn't get me the ability to use map in its full polymorphic glory. which is necessary for me to be able to tie knots through them with Mu/Nu, etc. 
18:26:26 <ivanm> :i Maybe
18:26:35 <Mitar> why this type constraint implicitly also constraints b to Show? forall a b. (Show a, Data a, Data b, Real b)
18:26:57 <ivanm> edwardk: well, with the constraints I think it will still work
18:27:06 <edwardk> itar: real implies Num implies Show
18:27:07 <ivanm> Mitar: Show a => Num a => Real a
18:27:19 <edwardk> ivanm: i will let you beat your head on it until you come around ;)
18:27:26 <ivanm> edwardk: heh
18:27:37 <ivanm> edwardk: well, _have_ you worked on your comonadic stuff any more?
18:27:45 <edwardk> ivanm: not in haskell =P
18:27:51 <Mitar> aha, thanks
18:27:57 <ivanm> edwardk: :(
18:28:01 <ivanm> just in your toy language?
18:28:33 <edwardk> ivanm: nah, some in scala. i also implemented the aforementioned stable-name based graph _reading_ code, just so i could build graphs up with let bindings and ADTs
18:28:40 <pumpkin> embrace the comonadz
18:28:54 <ivanm> I don't recall any stable-name stuff... :/
18:29:46 <edwardk> basically just decomposing a data structure using Data.Data and stablenames to assign unique node id's to each thunk present. and edges for every reference.
18:29:59 <ivanm> ahhhh
18:30:04 <edwardk> was sufficient for me to do the few graph algorithm's i've needed since we last talked
18:30:12 <ivanm> so, a runtime version of vacuum or something?
18:30:19 <edwardk> kinda
18:30:30 <edwardk> vacuum is a pretty close analogy
18:31:10 <jmcarthur> @seen mmorrow
18:31:10 <preflex>  mmorrow was last seen on #ghc 350 days, 23 hours, 33 minutes and 21 seconds ago, saying: * mmorrow is rtfm'ing
18:31:10 <lambdabot> Unknown command, try @list
18:31:27 <ivanm> pumpkin: did you ever try to look him up again after you moved back to the USA?
18:31:34 <pumpkin> ivanm: oh, forgot
18:31:42 <pumpkin> I'll add it to my todo list, to call during a reasonable time of day
18:31:48 <ivanm> edwardk: I've kinda forgotten most of what you said about your comonadic plans though :(
18:31:50 <edwardk> i started with Data, then i build a class that let me visit the node and its children. usually i can even fall back on data-reify
18:31:57 <ivanm> do you have anything up about it somewhere?
18:32:18 <pumpkin> ivanm: it's up on your trac
18:32:24 <ivanm> pumpkin: I don't have a trac1
18:32:28 <ivanm> s/1/!/
18:32:29 <pumpkin> although it's only barely becoming a comonad at that point
18:32:33 <edwardk> just whatever you captured, alp and tomberek. i think tom grabbed a code fragment
18:32:41 <ivanm> *nod*
18:32:52 <edwardk> yeah i dropped the comonads from it almost entirely because it was causing folks aneurisms. ;)
18:33:03 <edwardk> they are there if you know where to look though ;)
18:33:26 <pumpkin> do people have graph zippers?
18:33:37 <edwardk> ivanm: http://trac.haskell.org/HNN/wiki/CodeDraft
18:33:41 <listofoptions> hmm
18:34:19 <ivanm> pumpkin: nope
18:34:33 <pumpkin> they should!
18:34:35 <ivanm> not sure how they would work; specify a traversal and walk your way through it?
18:34:44 <ivanm> what defines a comonad again?
18:35:10 <pumpkin> functor + (f a -> a) + (w a -> w (w a))
18:35:22 <applicative> extend m a -> m m a , extract m a -> a
18:35:32 <ddarius> comonad = monad with the 2-cells swapped
18:35:49 <edwardk> well, you could do a fairly flat graph zipper by defining it in terms of an edge context or a vertex context. in many ways fgl is defined in terms of contexts that look a lot like zipper fragments
18:36:30 <ivanm> is extend the opposite of join?
18:36:36 * applicative has a sudden awareness: w an upside down m
18:36:36 <pumpkin> yep
18:36:43 <edwardk> i usually call that duplicate, and the dual of bind extend
18:36:44 <ivanm> applicative: heh, never noticed that
18:36:53 <edwardk> applicative: yeah
18:37:11 <edwardk> applicative a particular awful reason for a naming convention, but its stuck ;)
18:37:16 <edwardk> er particularly
18:37:22 <ddarius> It works for me.
18:37:38 <pumpkin> it's like mario vs. wario
18:37:40 <ddarius> c would be far worse, and g completely non-mnemonic.
18:37:42 <ivanm> so would I be correct in understanding that IO, etc. can't be a comonad because you can't define extract/extend/whatever-you-want-to-call-it ?
18:37:43 <pumpkin> monad vs. wonad
18:37:47 <applicative> anything to avoid the stress on 'f'
18:37:53 <applicative> or strain
18:38:00 <pumpkin> ivanm: yep
18:38:09 <edwardk> io can't be a comonad because every functor in haskell is strong and we don't have uniqueness/linear types
18:38:27 <ivanm> what's the significance of extend/duplicate; isn't that just return?
18:38:27 <applicative> pauow vs monad
18:38:37 <ivanm> applicative: *groan*
18:38:38 <geheimdienst> pew pew pew!
18:39:28 <edwardk> ivanm: no, the laws usually get in the way if you saying duplicate = return =)
18:39:44 <ivanm> *nod*
18:40:04 <ddarius> Not to mention the fact that there may not be a "return"
18:40:21 <ivanm> true
18:40:27 <edwardk> extract: w a -> a ‚Äî acts like head, but it must always succeed in returning a value. (like head of a non-empty list)
18:40:32 <ivanm> for some reason I was thinking a comonad had to be a monad :/
18:40:58 <ddarius> I would say comonads are usually not monads and vice versa, though there are definitely exceptions.
18:41:07 <ivanm> edwardk: so does that mean that lists can't be a comonad because of the empty case?
18:41:14 <edwardk> extend:: (w a -> b) -> w a -> w b  ‚Äî is dual to bind :: (a -> m b) -> m a -> m b ‚Äî it takes a 'cokleisli arrow' and gives you back one in the underlying category
18:41:17 <ddarius> (For example, M -> a and (M, a) are both monads and comonads when M is a monoid.)
18:41:20 <edwardk> ivanm: correct
18:41:40 <edwardk> otherwise what is the type of extract mempty?
18:41:44 <ddarius> Non-empty lists can, particularly streams (infinite lists)
18:42:07 <edwardk> (which goes to show if you are a haskell comonad and a monoid, you typically have something wrong with you ;)
18:42:07 <ddarius> Streams being a cofree comonad (on Id no less.)
18:42:16 <pumpkin> non-empty lists being one too!
18:42:21 <codolio> Also Identity.
18:42:58 <TeachmeHaskell> Hello folkz
18:43:11 * ivanm waves idly in TeachmeHaskell's general direction
18:43:31 <TeachmeHaskell> hello ivanm
18:44:57 * ivanm -> lunch
18:45:39 * geheimdienst thinks more appropriate would be "ivanm <- lunch", since the lunch is being unwrapped into ivan
18:46:08 <edwardk> perhaps he is unwrapping his lunch, or he is disgorging its contents as we speak
18:46:26 <geheimdienst> ivan barfs up lunch?!
18:46:41 <edwardk> it would explain why he had to walk away from the keyboard to eat
18:47:33 * ddarius suspects that the walking away had more to do with moving closer to the food and less to do with moving farther away from the keyboard.
18:47:59 * edwardk finds the concurrency primitives provided in the java world to be remarkably.. quaint.
18:48:47 <ddarius> I'm sure Java will move into the latter part of the seventies some day.
18:50:03 <edwardk> i was finding myself having to reimplement affinity scheduling, efficient work-stealing deques, etc. today. it made me sad
18:50:07 <applicative> ivamn, sorry I didn't see I was giving the signature for unjoin or disjoin w (w a) -> w a , rather than "extend"
18:50:32 <edwardk> you got the sig wrong again ;)
18:50:37 <applicative> ggrrrrr
18:50:42 <edwardk> duplicate/cojoin: w a -> w (w a)
18:51:01 <edwardk> duplicate (e, a) = (e, (e, a)) ‚Äî for instance
18:51:38 <applicative> i had it right the first time, I can only be right about one thing at a time. 
18:53:37 <applicative> duplicate, I see, it even comes before extend in Control.Comonad, very tasteful.
18:53:49 <edwardk> =)
18:58:31 <Nullus> hey guys any expert around that can provide some help to a newbie?
18:58:52 <Cale> lots
18:58:58 <Nullus> cool
18:59:04 <geheimdienst> (cale: newbies or experts ...?)
18:59:08 <Cale> That's upwards of 80% of what this channel is for :)
18:59:16 <Nullus> I would really appreciate any kind of help
18:59:26 <blackdog> Nullus: just ask:)
18:59:31 <Nullus> I got this semester project but I got 0 experience
18:59:37 <Nullus> with funcional languages
18:59:58 <edwardk> fortunately, being a semester project, you probably have some time to learn functional programming ;)
18:59:59 <Nullus> I guess I best say what the project is about
19:00:09 <Nullus> well its not a big project
19:00:20 <Nullus> I got to deliver it in the 8th
19:00:24 <Nullus> still got some time
19:00:33 <Nullus> but anyway
19:00:36 <Nullus> its not that big
19:00:43 <Nullus> basically I got to build a csv parser
19:00:58 <luite> hehe, read real world haskell then :p
19:01:03 <Nullus> indeed
19:01:04 <luite> @where rwh
19:01:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:01:07 <Nullus> although
19:01:16 <Nullus> I saw that already
19:01:19 <djahandarie> import Text.CSV
19:01:22 <TeachmeHaskell> what is cvs parser
19:01:28 <Nullus> but theres some stuff I dunno how to do
19:01:52 <jeffwheeler> TeachmeHaskell: parse documents that are in CSV format, i.e. lines of comma separated lists
19:01:55 <pumpkin> is there some analog to bind in category theory (instead of join)?
19:02:06 <TeachmeHaskell> jeffwheeler thank you
19:02:18 <ddarius> pumpkin: Yes.
19:02:21 <Nullus> csv file contains  inscriptions in a conference
19:02:21 <edwardk> its just a map followed by a join =)
19:02:35 <Nullus> I got to eliminate the duplicate inscriptions
19:02:49 <Nullus> got to put some hex characters to normal form
19:02:58 <Nullus> like \xca etc
19:03:14 <TeachmeHaskell> Nullus i got it, thnx
19:03:24 <Nullus> 1\xc2\xba should be 1¬∫
19:03:39 <edwardk> if you flip it around its a natural transformation from the kleisli arrow for M to the underlying category
19:03:47 <edwardk> er kleisli category
19:03:47 <pumpkin> oh yeah
19:03:55 * applicative loves to follow fmap by join
19:04:04 <edwardk> a -> m a    becomes m a -> m b
19:04:31 <pumpkin> kleisli application? :P
19:04:49 <pumpkin> does that mean there's an exponential object in the kleisli category of a monad?
19:04:53 <edwardk> sadly the haskell orientation of the function sort of messes up any intuition about comonads though, and requires the category to have exponentials, etc.
19:05:11 <edwardk> note, the definition i gave doesn't require exponentials in the category.
19:05:24 <edwardk> (a ~> m b) -> (m a ~> m b)
19:05:30 <edwardk> the haskell version does however
19:05:37 <edwardk> its just one big scary ass arrow ;)
19:07:04 <edwardk> something like m a ~> (m a)^(m b)^a
19:07:52 <edwardk> er i have one too many m a in there
19:08:26 <geheimdienst> > filter isAlpha "m a ~> (m a)^(m b)^a"
19:08:27 <lambdabot>   "mamamba"
19:08:56 * hackagebot Etage 0.1.7 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.7 (MitarMilutinovic)
19:09:02 <edwardk> m a ~> (m b)^((m b)^a) = m a -> (m b)^(a -> m b) = m a -> (a -> m b) -> m b
19:09:41 <edwardk> but the double exponential, etc. there only works because of the particular category we're in.
19:09:50 <geheimdienst> edwardk: m a ~> m b ~> o ~> n u ~> m b ~> e r ~> 5
19:10:04 <edwardk> geheimdienst:  =)
19:10:06 <ManateeLazyCat> Hi all. :)
19:10:13 <edwardk> heya manatee
19:10:18 <geheimdienst> hi manatee
19:10:47 <ManateeLazyCat> I will go home to see my grandmother, perhaps offline one month, if you have any question about Manatee, send mail to manatee-user@googlegroups.com, i will reply you as soon as possible. Thanks! :)
19:11:00 <ManateeLazyCat> Hi geheimdienst edwardk :)
19:11:14 <ManateeLazyCat> Happy new year, all! :)
19:11:38 <ManateeLazyCat> I will bring perfect terminal emulator and IDE feature when i'm back. :)
19:13:31 <zzing> Does anyone know if HP 2011.2.0.0 will have ghc 7?
19:14:27 <applicative> Isn't that the idea, a few months after a new GHC, a new Platform?  
19:14:47 <zzing> applicative: Ideas are not of interest, only what is actually being done :p
19:15:04 <jmcarthur> zzing: well, that's the plan so far
19:15:11 <jmcarthur> is for the next HP to have ghc 7
19:15:55 <applicative> zzing, oh, maybe; somehow I cleave to the opposite idea.
19:15:56 <zzing> It does say on the release time table "Release (candidate) of 2011.1.0.0: Jan 2, 2011."   Is that release candidate released?
19:16:15 <TeachmeHaskell> ManateeLazyCat 
19:16:20 <TeachmeHaskell> ops
19:16:27 <ManateeLazyCat> TeachmeHaskell: Find me? 
19:16:33 <TeachmeHaskell> Happy new year to you
19:16:35 <TeachmeHaskell> :)
19:16:44 <ManateeLazyCat> TeachmeHaskell: You too. :)
19:17:44 <ddarius> Lawvere theories, why are you so handy?
19:18:53 <applicative> zzing, http://projects.haskell.org/pipermail/haskell-platform/2010-December/001360.html
19:19:19 <applicative> ddarius, what are you finding the handy for?
19:20:17 <edwardk> i just always loved that the category of the mappings between them is 'Law' all in bold letters. subtle.
19:20:35 * applicative studied them in a class with S. Awodey; he is still in recovery.
19:20:47 <mm_freak> is there a mature opengl graphics engine/rendering library for haskell or will i have to write this myself?
19:20:47 <zzing> applicative: nice and merci
19:21:07 <jmcarthur> mm_freak: there isn't really a great one anywhere yet
19:21:11 <pumpkin> applicative: ooh, Cale would be jealous :P
19:21:24 <jmcarthur> mm_freak: there are lots of people who want one though   <--
19:21:24 <ManateeLazyCat> mm_freak: Do you want OpenGL embedded in GTK?
19:21:31 * applicative is only blaming Lawvere of course, not the teacher!
19:21:40 <mm_freak> jmcarthur: ok, then i will write one
19:21:55 <mm_freak> ManateeLazyCat: no, i will write an SDL+OpenGL rendering library, i guess
19:22:07 <ManateeLazyCat> mm_freak: Oh, i see. :)
19:22:16 <Cale> pumpkin: wat?
19:22:30 <ManateeLazyCat> mm_freak: Use for what? :)
19:22:42 <mm_freak> ManateeLazyCat: i'd like to write a game in haskell, and right now i prefer not to use FRP
19:23:03 <ManateeLazyCat> mm_freak: Of course, write your own engine is best choose. :)
19:23:17 <ManateeLazyCat> mm_freak: I guess you use for game. :)
19:23:43 <mm_freak> not necessarily‚Ä¶  there are great rendering engines for other languages like irrlicht and ogre‚Ä¶  unfortunately their haskell bindings are far from useful right now
19:24:09 <ManateeLazyCat> mm_freak: Write new one, my suggestion. :)
19:24:26 <pumpkin> Cale: applicative took a course with awodey!
19:24:39 <ManateeLazyCat> mm_freak: Haskell's graphics library is not good enough like other language, so we create it. :) 
19:24:43 <Cale> Oh, cool :)
19:25:04 <mm_freak> ManateeLazyCat: i agree‚Ä¶  but it will take some time to write a generic graphics library
19:25:46 <mm_freak> especially when you want it to be elegant /and/ fast
19:26:05 <ManateeLazyCat> mm_freak: I suggestion, you can first use OpenGL as backend, then write some high-level library focus on engine. You can rewrite everything when you found some feature missing.
19:26:30 <mm_freak> i will use opengl anyway
19:26:36 <ManateeLazyCat> mm_freak: Haskell is GC is problem on memory control, you need care. :)
19:26:45 <ManateeLazyCat> s/haskell is/haskell's
19:27:28 <zzing> Rewrite coco2d-iphone in haskell :p
19:28:00 <mm_freak> GC isn't so much of a problem
19:28:12 <jmcarthur> depends on the machine
19:28:29 <mm_freak> jmcarthur: and on the code
19:28:35 <jmcarthur> ipwn studios has had some issues with the gc on the iphone, iirc
19:28:50 * ski wonders what Nullus didn't know how to do ..
19:29:04 <jmcarthur> well yeah, certainly on the code. i just mean sometimes there just isn't much you can do about it
19:29:11 <mm_freak> if your code doesn't create many objects, for which lifetime is difficult to predict, then GC shouldn't be too bad
19:29:33 <zzing> Are there actually iphone apps written in haskell?
19:29:50 <jmcarthur> zzing: there's at least one game under development. not sure about existing stuff though
19:29:51 <Cale> zzing: We're working on one at iPwn.
19:30:02 * hackagebot haskell-src-meta 0.3 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.3 (BenMillwood)
19:30:02 <edwardk> zzing: one game kind of on its way from ipwn, but thats about it atm
19:30:12 <zzing> Cale, I would love to eventually see it :p
19:30:28 <jmcarthur> zzing: http://ipwnstudios.com/
19:30:32 <zzing> I would be interested in a compiler eventually, but that is another day...
19:30:52 <luite> what's the status of ghc for ios? still the same patch for 6.10.4?
19:30:57 <Nullus> hey ski just wondering if theres a neat way to put those hex characters in displaying in the normal form, btw after I parse the csv file and remove the non valid inscriptions I need to generate inscription badges in LaTeX form to another file
19:31:12 <jmcarthur> wow, there's even less information on the ipwn site now than there was before ;)
19:31:35 <edwardk> yeah
19:32:09 <zzing> Is the idea of FRP advanced enough to really work for a production game?
19:32:11 <Cale> But yay, I'm listed on the team page ;)
19:32:43 <edwardk> zzing: imho, its an uphill battle. monadic frp is pretty leaky to build a game on, and arrow frp is rather annoying to work with
19:32:48 <jmcarthur> zzing: depends on what kind of FRP you are talking about and what you mean by advanced
19:33:10 <jmcarthur> monadic frp would be fine if there was a discrete time one, i think
19:33:24 <zzing> jmcarthur: advanced in terms of development of the technology
19:33:33 <jmcarthur> that's still very ambiguous
19:33:45 <ddarius> edwardk: Clearly we need arrow monadic FRP.
19:33:48 <jmcarthur> yampa has a well-tested, fast implementation
19:33:54 <jmcarthur> but semantically i think it suffers
19:34:17 <jmcarthur> ddarius: you mean arronadic!
19:34:24 <Cale> I have this sense that there might be something to having an arrow FRP foundation in terms of which an applicative-style FRP is built. I've used this sort of idea locally in building the UI for our game, with reasonably nice results.
19:34:27 <zzing> I don't think I could swallow FRP on haskell because it always seemed extremely complicated.
19:34:39 <edwardk> personally i find the 'reactive framework' style of programming used in the .net world to be more compelling than the 'functional reactive' school of thought. the semantics of the latter are cleaner, but its not clear that they are performantly implementable
19:34:52 <pumpkin> oh, ipwn has a new website
19:39:34 <ManateeLazyCat> About how to write application, i have write docs at http://haskell.org/haskellwiki/Manatee#How_to_write_Manatee_extension and http://hackage.haskell.org/package/manatee-template .
19:39:40 <ManateeLazyCat> Happy hacking
19:52:15 <ManateeLazyCat> Bye all, i will miss you guys. :)
19:52:30 <blackdog> ManateeLazyCat: where are you going?
19:53:10 <ManateeLazyCat> blackdog: I will go home to see my grandmother, i haven't see her 4 years. I perhaps offline one month.
19:53:12 <msieradzki> how does rewinding simulation in time to last position acknowledged by server on error fit with FRP? has anyone build full game based on quakeworld (not quake) using FRP?
19:53:29 <blackdog> ManateeLazyCat: oh, cool. we'll miss you too:)
19:53:38 <ManateeLazyCat> blackdog: Thanks. :)
19:59:55 <mm_freak> ManateeLazyCat: have a good time =)
20:03:12 * hackagebot templatepg 0.1.0 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/templatepg-0.1.0 (ChrisForno)
20:09:23 <ddarius> :t fmap (uncurry id) . uncurry (liftA2 (,))
20:09:24 <lambdabot> forall b c (f :: * -> *). (Applicative f) => (f (b -> c), f b) -> f c
20:13:46 <pumpkin> perfect!
20:13:46 <pumpkin> almost
20:20:30 <turiya> @forall
20:20:30 <lambdabot> Unknown command, try @list
20:20:38 <turiya> @src forall
20:20:38 <lambdabot> Source not found. It can only be attributed to human error.
20:27:21 <ivanm> turiya: if you mean the forall in the type sigs, it's not a function...
20:28:15 <turiya> ivanm: oh, i was looking for something like the \forall we use in math..
20:28:29 <Axman6> o.O
20:28:30 <ivanm> in what sense?
20:28:41 <ivanm> if you want it for type sigs, there are extensions for that
20:28:50 <ivanm> otherwise, do you mean all?
20:28:52 <ivanm> @type all
20:28:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:29:48 <turiya> no..i wanted to build a list from a function
20:30:20 <turiya> something like .. func f = lis where lis !! i = f (i)
20:30:28 <turiya> but it does not seem to work
20:30:54 <turiya> i thought adding a forall would fix that..
20:31:29 <ion> What do you expect as input and what should be the output?
20:31:30 * Axman6 is very vonfused
20:31:59 <turiya> f :: Int -> Int, say
20:32:13 <turiya> lis is a list
20:32:31 <Axman6> so, you want something like func f = map f [minBound..maxBound]?
20:32:46 <Axman6> that doesn't quite give you wnat you want
20:32:59 <turiya> hmm..
20:33:18 <turiya> if f is a restriction of sin to integer arguments
20:33:39 <turiya> i want lis to be a list of all the sin values
20:34:05 <turiya> starting from sin 0
20:34:07 <Axman6> well the function i gave you does that
20:34:24 <Axman6> func f = map f [0..maxBound]
20:34:36 <phao> http://ix.io/1mQ -- What is wrong with line 91? ghc is complaining about invalid type signature...
20:35:01 <turiya> Axman6: i understand now, that a neat way to do it.. thanks
20:35:03 <Axman6> phao: please paste that on a paste site that has line numbers, and include the error
20:35:12 <pumpkin> hpaste.org
20:35:12 <Axman6> for example, hpaste
20:35:26 <wto> i suspect the error is in: buttons :: [Char ]
20:35:43 <Axman6> turiya: it's not particulatly efficient though
20:35:52 <phao> ok, http://hpaste.org/42740/calculator
20:35:53 <ion> lis = map sin [0..], or foo f = map f [0..] (or foo = flip map [0..])
20:36:07 <Axman6> the compiler may be able to make things a little more efficient, but that's not guaranteed
20:36:30 <turiya> Axman6: is there a better way?
20:36:45 <wto> phao: you cannot include the arguments to your function in the type signature
20:36:45 <phao> "test.hs:91:0: Invalid type signature" that is the error message
20:36:49 <Axman6> phao: you have arguments on the left od the ::, remove cs and c
20:36:58 <phao> ... damn
20:38:19 <ion> turiya: Instead of ‚Äò(map f [0..]) !! n‚Äô just do ‚Äòf n‚Äô perhaps.
20:39:50 <turiya> ion: can a list be built that way? lis !! n = f n does not work
20:40:09 <ion> What do you need the list for?
20:40:29 <ion> In my previous message, map f [0..] was the list.
20:40:41 <turiya> for finding minimum and maximum etc..
20:41:07 <ion> of what?
20:41:17 <turiya> of the list
20:42:21 <turiya> is there  a way to find the global minimum of a function directly?
20:43:27 <turiya> i am thinking that there is nothing direct as in C
20:44:16 <ion> For which function are you actually trying to find the global minimum? Not sin of integers, i take it.
20:45:23 <applicative> phao, I make this mistake all the time :)
20:47:30 <turiya> ion: no, sin was an example, i am actually trying to find the minimum of an image represented as a function of two variables
20:47:39 <phao> lucky I just wasted some mins on it
20:47:49 <phao> I imagine wasting like hours on mistakes like that
20:58:26 <ion> turiya: As you still aren‚Äôt telling what you‚Äôre trying to find the minimum of, i‚Äôll just tell that finding the minimum of a mathematical function consists of finding the point where its derivative is zero and the second derivative is positive. If that doesn‚Äôt apply to your secret function, and you really need to make a list of its values for all possible input values within certain bounds and with a certain step size, ‚Äòminimum‚Äô is
20:58:32 <ion> the function.
21:00:17 <mm_freak> ion: that would be /a/ minimum, not /the/ minimum
21:00:28 <ion> true
21:02:54 <turiya> ion: sorry, if what i wrote earlier was not clear..my function is an image and hence discrete..
21:03:27 <ion> :t minimum
21:03:28 <lambdabot> forall a. (Ord a) => [a] -> a
21:03:29 <turiya> much like a matrix
21:05:31 <turiya> using map i could create a list from the function and then find its minimum..
21:09:18 <Axman6> > foldl' min (1/0) (map (sin . fromIntegral) [1..1000])
21:09:20 <lambdabot>   -0.9999903395061709
21:09:33 <Axman6> > foldl' min (1/0) (map (sin . fromIntegral) [1..100000])
21:09:35 <lambdabot>   -0.9999999999848337
21:09:38 <Axman6> > foldl' min (1/0) (map (sin . fromIntegral) [1..10000000])
21:09:42 <lambdabot>   mueval-core: Time limit exceeded
21:09:45 <Axman6> > foldl' min (1/0) (map (sin . fromIntegral) [1..1000000])
21:09:48 <lambdabot>   -0.9999999999848337
21:09:54 <Axman6> > foldl' min (1/0) (map (sin . fromIntegral) [1..1000000 :: Int])
21:09:56 <lambdabot>   -0.9999999999848337
21:11:34 <ion> > minimum $ map (sin . fromIntegral) [1..100000]
21:11:37 <lambdabot>   -0.9999999999848337
21:12:22 <turiya> minimum uses foldl hence slower?
21:18:06 <ion> > foldl1' min $ map (sin . fromIntegral) [0..100000]
21:18:09 <lambdabot>   -0.9999999999848337
21:26:17 <j-invariant> I was dreaming baout my haskell programming problem
21:26:56 <dolio> I dreamed about cooking food the other day.
21:27:03 <j-invariant> :)
21:32:34 <qfr> What are the biggest three Haskell projects (other than ghc or libraries for Haskell)? Especially commercial ones
21:33:12 <pumpkin> commercial ones tend to not tell you what they're doing
21:34:56 <qfr> :o
21:35:26 <blackdog> qfr: maybe cryptol and BloodKnight would be up there? it really does depend on your definition of 'big'
21:35:38 <blackdog> most code? most influential? most contributors?
21:35:50 <Axman6> there's a few banks using haskell, we're using haskell exclusively here, galois are probably the largest haskell users
21:36:07 <Axman6> i'd say the work we have here is quite large
21:36:46 <blackdog> the difficulty is that it's used in situations where correctness is important, and in those situations, secrecy is also often important
21:38:08 <Axman6> hmm, seems we only have 30,000 lines of haskell
21:38:44 <Axman6> assuming find . -name "*.hs" | grep -v extsrc | xargs car | wc -l is accurate
21:38:48 <Axman6> cat*
21:40:37 <qfr> Heh
21:40:44 <j-invariant> I think "Implicit Configurations
21:40:55 <j-invariant> solves my problem
21:41:32 * Eduard_Munteanu finished his adaptive Huffman thingy
21:41:34 <j-invariant> they show how do to modular arithmetic
21:42:05 <Eduard_Munteanu> But I still have to tweak it a bit, particularly my sibling-finding function doesn't play too well with the stack on larger files.
21:42:22 <jonathan_> what's a good name for a property that checks if a list has all ints between its max/min range?
21:42:34 <jonathan_> isConnected? isDense?
21:43:20 <blackdog> isContinuous?
21:43:27 <Eduard_Munteanu> unionIsInt?
21:43:50 <Axman6> inBounds?
21:44:17 <jonathan_> continuous wins
21:44:25 <jonathan_> thanks blackdog :)
21:44:39 <Axman6> oh, i get it
21:44:56 <jonathan_> bounds is good too
21:45:14 <Heffalump> exhaustive?
21:45:41 <Eduard_Munteanu> That one sounds reasonable, Heffalump 
21:45:55 <jonathan_> hmm, yeah I guess continuous implies a continuum
21:46:15 <jonathan_> exhaustive is good too
21:46:29 <pumpkin> complete? full? :P
21:46:42 <Eduard_Munteanu> I'd choose a short name and write a nice comment there.
21:46:43 <jonathan_> so many good choices
21:47:00 <pumpkin> yoDoUHazAllDaNumbasBetwixt
21:47:06 <jonathan_> that's it!
21:47:09 <Eduard_Munteanu> :))
21:47:30 * Eduard_Munteanu goes figure how to rewrite his 'sibling' function without building hellish thunks.
21:59:41 <zmbmartin> What is the editor of choice for haskell?
22:00:50 <jmcarthur> zmbmartin: many of us just use vim or emacs
22:01:18 <jmcarthur> zmbmartin: there is a pretty good haskell-mode for emacs, if you like emacs
22:01:38 <zmbmartin> jmcarthur: I am more of a vim man myself.
22:01:50 <j-invariant> use vim
22:01:56 <zmbmartin> I just read about this leksah
22:02:01 <jmcarthur> i'd just stick with what you already like
22:02:31 <zmbmartin> I guess I was curious if leksah was any good.
22:02:50 <jmcarthur> it's been too long since i last tried it. it's probably much improved by now
22:02:54 <blackdog> zmbmartin: it's not yet trivial to install
22:02:57 <Eduard_Munteanu> Hm, why would profiling show a record syntax accessor as a major allocation hog, hm...
22:04:12 <j-invariant> What are your thoughts on Implicit Configurations
22:05:01 <pumpkin> awesomely evil
22:08:00 <Eduard_Munteanu> Just checking, does WriterT carry any risk of blowing the stack?
22:08:30 <pumpkin> you've been awfully worried about blowing the stack recently :)
22:09:07 <maurer_> Eduard_Munteau: Just becareful with appending to lists, and it's fine (if I remember correctly)
22:09:09 <Eduard_Munteanu> Well, that's because I've been blowing it too often recently :D
22:10:02 <Eduard_Munteanu> maurer_: well I am using WriterT w m a, where w = [something]
22:10:43 <Eduard_Munteanu> And 'tell' does seem to append to lists.
22:11:04 <Cale> But it does it in the good order
22:11:30 <Eduard_Munteanu> Ah, so I suppose it's no worse than composing with concat on the left.
22:11:37 <Cale> I don't think Writer is inherently any more prone to stack overflows than any other library.
22:13:14 <j-invariant> what perrcentage of haskell programming read "Notions of computation and monads
22:13:41 <Eduard_Munteanu> http://hpaste.org/42742/sibling
22:14:01 <Eduard_Munteanu> Profiling shows most time is spent in this, and most allocations occur in 'parent', but that's just a record field accessor.
22:15:06 <Cale> j-invariant: Moggi's paper?
22:15:10 <j-invariant> yes
22:15:17 <Cale> j-invariant: Hmm, at least I have :)
22:15:43 <Eduard_Munteanu> I wonder if strict ST/STRefs could help here.
22:16:18 <j-invariant> Are there any songs about Haskell?
22:16:30 <Cale> It's one of the original papers on the path to getting people actually using monads for programming and not just for studying the behaviours of programs.
22:16:47 <j-invariant> Cale: oh cool I thought itw as just theory
22:17:27 <Cale> Well, it's still on the more theory side of that, yeah
22:18:22 <BMeph> Just idle curiousity, but does anyone know if there's any significance to which side of the pair gets the functor in the definition of strength?
22:19:46 <tcatipax> Hey guys. Does anyone have a working link for the "Haskell for C Programmers" book?
22:28:57 <ivanm> @google haskell for c programmers
22:28:58 <lambdabot> http://lambda-the-ultimate.org/node/724
22:28:58 <lambdabot> Title: Haskell for C Programmers | Lambda the Ultimate
22:29:11 <tcatipax> Click it
22:30:15 <tolkad> ghc is saying "Illegal type synonym family application in instance: Evaluated e"
22:30:28 <ivanm> tcatipax: http://oldhaskell.cs.yale.edu/~pairwise/intro/intro.html
22:30:29 <tolkad> but I have TypeSynonymInstances enabled!
22:30:39 <tcatipax> ivanm: Thank you!
22:30:43 <ivanm> tcatipax: yeah, I was just trying to find the original
22:30:56 <ivanm> that page won't be up for much longer, so save it if you want it
22:31:01 <tolkad> Why isn't TypeSynonymInstances working?
22:31:12 <Axman6> ur doin it rong!'
22:31:47 <ivanm> Axman6: brilliant deduction!
22:32:22 <tolkad> hmm, I might actually be able to do this with superclass constraints
22:32:32 <tolkad> are they out yet?
22:33:02 <tcatipax> Saved. He has tarballs if you remove intro.html
22:33:05 <tcatipax> Thanks!
22:33:38 <ivanm> tolkad: no :(
22:33:55 <ivanm> there are rumours of 7.0.2 having it, but it's more likely to be 7.2 in september :s
22:36:11 <BMeph> Axman6: Thanks for the assist! Must have been distracted there for a bit. ;)
22:36:28 <Axman6> I do what i can
22:37:06 <horms> Hi Axman6
22:37:12 <Axman6> o/
22:37:36 <Axman6> how does the network stuff?
22:37:57 <Axman6> hmm, i guess you wouldn't be working on that when you're not here
22:43:02 <j-invariant> why isn't there a haskell song?
22:43:30 <ivanm> why should there be?
22:44:01 <colah> Is it possible to have funtions act on types?
22:44:17 <BMeph> More on the 'strength' thing: I've seen it as "a √ó f b ‚Üí f (a √ó b)", and as "f a √ó b ‚Üí f (a √ó b)" and was wondering if there's some benefit to one form over the other.
22:44:36 <j-invariant> BMeph: isn't a x b isomorphic to b x a?
22:44:43 <j-invariant> (so you could just swap them?)
22:45:16 <j-invariant> would have to rename a and b though
22:46:15 <pumpkin> view patterns and pattern guards are wonderful for working with expression trees
22:46:22 <pumpkin> especially with GADTs turned on
22:47:15 <BMeph> j-invariant: So, you se it too, then? ;√æ
22:47:33 <BMeph> *see
22:47:35 <j-invariant> BMeph: I dont really know
22:48:16 <pumpkin> BMeph: there's no particular reason to prefer one over the other, except for the functor instance giving snd a slight advantage
22:48:50 <pumpkin> (I tend to put more interesting stuff in snd than fst as I can do more with it in less code)
22:52:56 <Axman6> colah: what do you mean?
22:55:25 <BMeph> pumpkin: Fair enough.
22:56:48 <pumpkin> colah: look at type families
22:56:59 <pumpkin> or, alternately, typeclasses
22:57:10 <pumpkin> for functions from types to types and types to values, respectively
22:57:12 <colah> I know about typeclasses.
22:57:40 <j-invariant> type F a = ....
22:57:45 <colah> I'll look into type families.
22:57:50 <j-invariant> the only thing you can do with F is apply it
22:57:53 <pumpkin> what do you want specifically?
22:58:25 <j-invariant> do type families break parametricity
22:58:38 <colah> Nothing. Idle curiousity. The sort of thing I was wondering about is, say, a function that takes a type a and returns [a].
22:58:48 <j-invariant> type List a = [a]
22:58:51 <colah> It seems like that sort of thing could be usefull
22:59:07 <pumpkin> colah: yeah, type synonyms and type families both allow that
22:59:11 <colah> But that's actually creating a type.
22:59:21 <j-invariant> yes?
23:00:06 <colah> Actually, I think I see now. I'd seperated the idea of type declarations from functions. But it's actually a function acting on a type that creates it, like a consturcutor.
23:00:20 <colah> That's really obvious in retrospect.
23:00:38 <j-invariant> colah: you can't make something the same as "List" anonymously like using lambda
23:00:48 <j-invariant> e.g. (\a - [a]) is not valid
23:01:11 <j-invariant> infact you can't even use List on its own
23:01:16 <j-invariant> it must be aplplied List x
23:01:36 <Axman6> sure you can
23:01:38 <colah> That's too bad. Can one go assign the constructor to a new variable (foo = List) or pass it to another function
23:01:50 <pumpkin> for some values of list
23:01:54 <colah> Well, I guess foo would have to be uppercase.
23:01:57 <pumpkin> of use, I mean
23:02:09 <j-invariant> type Foo = List <-- not allowed either
23:02:13 <j-invariant> but you can do  type Foo a = List a
23:02:14 <pumpkin> you can pass it around, but you can't make values of a type constructor that isn't of kind *
23:03:14 <colah> ghci doesn't seem to like :t Int; is there a type for datatypes?
23:03:28 <pumpkin> :k Int
23:03:29 <colah> Or just *
23:03:29 <lambdabot> *
23:03:35 <pumpkin> types have kinds
23:03:43 <pumpkin> ghci accepts :k too
23:03:53 <Axman6> :k []
23:03:54 <lambdabot> * -> *
23:04:04 <pumpkin> :k RWST
23:04:05 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
23:04:06 <Axman6> i believe you can indeed do type Foo = List
23:04:15 <pumpkin> yeah you can
23:04:22 <colah> OK. Thank you for your help.
23:05:18 <j-invariant> "This paper identify one of such structures, i.e. monads, but probably there are
23:05:21 <j-invariant> others just waiting to be discovered.
23:06:02 <jfischoff> Has anyone every made a class that has the method isValid :: a -> Bool or something similar?
23:06:28 <jfischoff> I made one for testing and design by contract assertions and was wondering if someone else has gone this route
23:06:34 <jfischoff> ?
23:07:39 <j-invariant> I thought CCC give simpel lambda calculus: Where do you find untyped lambda calculus?
23:08:21 <j-invariant> Can proved 2^k > k, how can D^D = D
23:08:26 <pumpkin> you need S and K on top of that don't you?
23:08:27 <j-invariant> cantor
23:08:45 <pumpkin> or some similar combinators that give you more power
23:09:33 <pumpkin> not sure about untyped. the category is really just describing the typing relationships in the LC, so not sure what would happen with untyped LC
23:14:44 <j-invariant> what category is  Id_C
23:15:01 <Cale> jfischoff: It sounds like it would fit in well with QuickCheck
23:15:25 <jfischoff> Yeah, that is how I am using it. 
23:16:01 <jfischoff> Cale: I at runtime I make exceptions, or I can make tests for quickcheck
23:16:56 <j-invariant> oh it's not a category it's a functor
23:28:20 <colah> Another noob question: what's wrong with delta's signature in "class MetricSpace a where (Œ¥):: a -> a -> Float"
23:28:50 <j-invariant> the brackets
23:28:53 <j-invariant> take those off
23:30:14 <colah> Ah, thanks.
23:30:36 <Axman6> @src Num
23:30:37 <lambdabot> class  (Eq a, Show a) => Num a  where
23:30:37 <lambdabot>     (+), (-), (*)           :: a -> a -> a
23:30:37 <lambdabot>     negate, abs, signum     :: a -> a
23:30:37 <lambdabot>     fromInteger             :: Integer -> a
23:30:49 <Axman6> i believe the brackets are right
23:31:32 <colah> It fixed it. I'm guessing it's because not all unicode registers as an operator.
23:31:52 <colah> Another problem: "data L2 (‚Ñù,‚Ñù,‚Ñù) = L2 (‚Ñù -> ‚Ñù)"
23:32:08 <colah> I'm trying to make a paramaterized data type, but apparently I'm not doing it right 
23:32:19 <colah> type ‚Ñù = Float
23:32:26 <j-invariant> data L2 = L2 (‚Ñù -> ‚Ñù)
23:33:00 <colah> No, it needs to be a, I beleive the term is, phantom type.
23:33:20 <colah> The tuple is very important.
23:33:24 <etpace> hmmm.. does data typeable not work for large tuples, such as 9-tuples?
23:33:31 <colah> For every typle, there's a different type.
23:33:50 <etpace> it seem No instance for (Typeable7 ((,,,,,,,,) Purpose OrderPlace))
23:33:54 <etpace> any idea? :)
23:34:07 <colah> later on I want to do: instance InnerProductSpace L2 (a,b,d) where f‚ãÖg = (a,b,d) ‚à´ (\x -> f(x)*g(x))
23:34:21 <j-invariant> colah: oh you need a function F that compuse ‚Ñù -> ‚Ñù from ‚Ñù,‚Ñù,‚Ñù
23:34:28 <j-invariant> then you can do  data L2 a = L2 (F a)
23:34:45 <nilshero> hello, im a linux newbie. i installed Leksah (http://rizwanbulbul.blogspot.com/2010/06/installing-leksah-gtk-gtk2hs-and-glade.html). opened leksah. first time dialog opened (search for packages). i see that ubuntu does not connect right to the internet. i abort leksah window, restart computer, connection now works, i restart Leksah - no first start dialog any more. Am i right that deleting...
23:34:46 <nilshero> ...the .leksah-0.8 folder in my home directory resets this?
23:35:40 <colah> j-invariant: could you expand?
23:35:42 <nilshero> or how do i do what this dialog does?
23:36:13 <j-invariant> colah: so that L2 (‚Ñù,‚Ñù,‚Ñù) has constructor L2 (F (‚Ñù,‚Ñù,‚Ñù)) = L2 (‚Ñù -> ‚Ñù)
23:36:15 <colah> nilshero: That sounds like a problem that would be more appropriate to ask about on #ubuntu.
23:37:08 <colah> j-invariant: you mean like type ‚Ñù3 = (‚Ñù,‚Ñù,‚Ñù) and then use that?
23:37:10 <nilshero> sorry im not as stupid as it sounds, it just makes me nervous if i dont do new things exactly as described in manual
23:37:12 <j-invariant> no
23:37:49 <j-invariant> nilshero: just a guess but check if you have ~/.cabal
23:38:55 <nilshero> yes i have a .cabal directory in userfolder
23:39:11 <j-invariant> if there is leksah stuff inthere you can try using cabal to reset it
23:41:16 <j-invariant> I need http://www.scss.tcd.ie/Edsko.de.Vries/ct/catsters/linear.php
23:41:28 <j-invariant> why did it go :(
23:43:26 <nilshero> do i understand this issue if i read through the cabal manual?
23:44:14 <nilshero> a shit. thx anyway
23:44:55 <j-invariant> i don't get "computation and monads
23:44:57 <j-invariant> at all
23:45:00 <colah> nilshero: what happens if you echo ~/.leksah*
23:47:46 <colah> OK. So how do I get a function that maps (‚Ñù,‚Ñù,‚Ñù) to ‚Ñù -> ‚Ñù?
23:47:53 <j-invariant> type families
23:48:09 <pumpkin> colah: sounds like you want a type family
23:48:26 <pumpkin> type family Moo a :: *
23:48:35 <pumpkin> type instance Moo (Float, Float, Float) = Float -> Float
23:49:17 <colah> pumpkin: thanks!
23:49:49 <pumpkin> in general, you probably want to pair it up with a typeclass, if you want to have different behavior based on the type
23:51:31 <colah> and then how do I pull off: instance InnerProductSpace L2 (a,b,d) where f‚ãÖg = (a,b,d) ‚à´ (\x -> f(x)*g(x))
23:51:42 <j-invariant> you can't
23:51:53 <maurer_> I'm trying to use the "Allow executables to depend on the lib within the same package
23:52:07 <maurer_> " feature in Cabal 1.8
23:52:18 <colah> ... I see. That was the whole point.
23:52:44 <pumpkin> colah: I don't understand your syntax :P
23:52:53 <j-invariant> colah: what is the type of ‚à´?
23:53:01 <maurer_> However, when I try to use it, I get cannot satisfy -package-id testpackage-0.0.1
23:53:11 * hackagebot autoproc 0.1.2 - EDSL for Procmail scripts  http://hackage.haskell.org/package/autoproc-0.1.2 (JasonDagit)
23:53:25 <colah> (Float,Float,Float) -> (Float -> Float) -> Float
23:53:39 <j-invariant> then you can't have instance InnerProductSpace L2  (a,b,d) 
23:53:50 <j-invariant> since a,b,d are floats
23:53:54 <pumpkin> colah: what's the type of (‚ãÖ) ?
23:54:09 <j-invariant> (Float -> Float) -> (Float -> Float) -> Float
23:54:19 <colah> (InnerProductSpace a) => a -> a -> Float
23:54:45 <colah> In this case, what j-invariant said.
23:55:08 <pumpkin> you can sort of approximate this with a method for getting at the value
23:55:23 <colah> ?
23:55:26 <pumpkin> represent a triple of a,b,d with a data Blah = Blah (one for each triple)
23:55:34 <j-invariant> You need to use Implicit Configuations
23:56:03 <maurer_> Can anyone point me to an example of using this feature successfully?
23:56:06 <pumpkin> then add to your InnerProductSpace class a method that takes you from the parameter (Blah in this case) to the triple
23:56:14 <j-invariant> colah: instance InnerProductSpace L2  (a,b,d) .. mandates that a,b,d are types (of kind *)
23:56:25 <j-invariant> colah: but you use them like they are values (of type Float)
23:56:38 <pumpkin> then you can pass that method to ‚à´
23:56:57 <colah> OK. SO if I start from scrath, how should I be doing this.
23:57:06 <pumpkin> what's L2, anyway?
23:57:08 <j-invariant> colah: you don't have to start from scratch
23:57:13 <pumpkin> and are a,b,d uniquely determined by it?
23:57:17 <j-invariant> colah: "You need to use Implicit Configuations"
23:57:19 <j-invariant> for the next step
23:57:47 <j-invariant> pumpkin: it's a space of functions that are integrable
23:57:52 <colah> pumpkin: L2 is a way of defining an inner product on functions.
23:58:07 <pumpkin> okay
23:58:22 <colah> It can be defined for functions for intervals of the real line, or the whole thing.
23:58:53 <j-invariant> Given a monad T we have Alg_T  <-- what is Alg_T?
23:58:56 <dcoutts> maurer_: sounds like you need a later point release of the Cabal lib. There was a bug in early versions that meant it did not work with ghc-6.12
23:59:11 <maurer_> dcoutts: 1.8.0.2 too old?
23:59:28 <j-invariant> or Alg^T
23:59:34 <pumpkin> so you have class InnerProductSpace a where type Carrier a :: *; type Moo a :: *; myTriple :: a -> Moo a; (‚ãÖ) :: Moo a -> Moo a -> ...
