00:01:03 <tlonim> what is the equivalent of something like perldoc ? to view the man-like documentation of installed modules i mean
00:04:52 <Adamant> Bynbo7: I do
00:07:28 <Bynbo7> tlonim: there is no man-like docs for haskell, but we do have haddock docs
00:08:39 <tlonim> Bynbo7: but can haddock be used to view doc of already installed packages ? like haddock xyz ?
00:10:00 <Bynbo7> if you get cabal-install to build packages with docs turned on, then you can get access to an index.html page with links to all installed modules
00:10:06 <Schalken> Is there a function kleeneStar :: [a] -> [[a]] that computes a lazy list that is the Kleene Star of it's input? Eg kleeneStar [1,2] = [[],[1],[2],[1,2],[1,1],[2,1],[2,2] ... ]
00:10:32 <tlonim> Bynbo7: ok. thanks
00:10:49 <Bynbo7> > filterM (const [True,False]) [1,2]
00:10:50 <lambdabot>   [[1,2],[1],[2],[]]
00:10:54 <Bynbo7> maybeh not
00:11:20 <Bynbo7> Schalken: there sertainly is a function to do it, but you may have to write it ;)
00:12:01 <Schalken> Bynbo7: Heh, yeah, I'm sure someone has written one before, but Googling has given nothing useful. :(
00:12:58 <Schalken> Maybe it's really simple, I just need to think about it harder...
00:14:18 <mauke> > let foo xs = ys where ys = [] : map (: ys) xs in foo ""
00:14:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
00:14:33 <mauke> right, of course
00:15:32 <mauke> > let foo xs = ys where ys = [] : liftA2 (:) xs ys in foo ""
00:15:33 <lambdabot>   [""]
00:15:38 <mauke> > let foo xs = ys where ys = [] : liftA2 (:) xs ys in foo "ab"
00:15:40 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
00:17:48 <Bynbo7> :(
00:18:17 <Bynbo7> Adamant: have you seen http://www.infoq.com/presentations/Thinking-Parallel-Programming ?
00:18:55 <Adamant> yes
00:19:05 <Adamant> ?
00:19:12 <Bynbo7> I love the quote in it: "If i'd know about haskell 7 years ago, i would have started with haskell and moved it 1/10th the way towards Fortress, instead of moving Fortress 9/10ths of the way toward haskell"
00:19:18 <mauke> > let foo xs = ys where ys = [] : liftA2 (flip (:)) ys xs in foo "ab"
00:19:20 <lambdabot>   ["","a","b","aa","ba","ab","bb","aaa","baa","aba","bba","aab","bab","abb","...
00:19:28 <Adamant> oh wait
00:19:32 <Adamant> no, that's new
00:19:37 <Adamant> I'll watch
00:19:40 <Schalken> mauke: :O !
00:20:12 <Bynbo7> i think it's an old talk, but re-presented more recently. you may have seen it before (though it starts out with a very cool bit of history)
00:21:00 <Schalken> mauke: I have no idea how you did that. I was going to write a function that gave all the combinations of the given list of a specified length n, and then concat the results for 0, 1 2 etc.
00:21:28 <mauke> > replicateM 2 "abc"
00:21:29 <lambdabot>   ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
00:21:50 <Schalken> mauke: Haha. Yeah, that. :P
00:23:09 <Adamant> Bynbo7: thank you!
00:26:48 <Schalken> > let foo xs = do; i <- [0, 1..]; replicateM i xs in foo "ab"
00:26:49 <lambdabot>   ["","a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","...
00:27:29 <Schalken> mauke: I think yours would somehow be more efficient because it doesn't involve passing around an int that is the expected length of the string.
00:31:07 <Schalken> mauke: Thanks.
00:31:17 <Taejo> Schalken: I didn't see Mauke's, but you are right: yours will construct the string "ab" many times, instead of reusing it to make "bab" and "aab"
00:31:53 <ketil> Anybody using gitit?  I have some stylesheet problems...
00:39:30 <tlonim> is yi editor developed still ? I see the last posts for it being in 2009
00:42:20 <jonkri> how common is it to have the same value in the map key as in some field of the map value? i want to make a map between node names and nodes so that i can look them up, but i'm wondering if it's ugly to have the name in two places. is there some other set-like data type which can take the name field as the "primary key" or something?
00:42:45 <rubenz> I'm trying to build cabal-install 0.8.2 under ghc 7.0.1 but getting errors. Can this be done?
00:52:42 <Taejo> jonkri: that's kind of tricky because the type of the map depends on a value: the function from values to keys
00:54:01 * hackagebot turni 2011.1.15 - shifts scheduling tool  http://hackage.haskell.org/package/turni-2011.1.15 (PaoloVeronelli)
00:57:04 <jonkri> Taejo: i don't understand what you are getting at
00:58:46 <jonkri> what is tricky?
00:59:13 <Taejo> jonkri: defining such a type. Say it's called KeyMap v f
00:59:30 <Taejo> then v will be your value type (say (String, Int))
00:59:33 <Taejo> which is fine
00:59:46 <Taejo> but f should be fst, the function to extract the key
01:00:01 <Taejo> but you can't have types like that in Haskell, since fst is a value, not a type
01:00:40 <jonkri> ok. what would you advice me to do at this point?
01:04:42 <Taejo> jonkri: I would just create a wrapper around Map
01:05:05 <Taejo> if you only have one type with a single possible key, the issue above doesn't matter
01:05:17 <Taejo> that's only an issue if you want genericity
01:27:35 <jonkri> Taejo: found http://hackage.haskell.org/packages/archive/Holumbus-Distribution/0.1.1/doc/html/Holumbus-Data-KeyMap.html :)
01:28:24 <Taejo> jonkri: ah, d'oh, of course you use a typeclass for the key
01:29:01 <jonkri> could it not be argued that this should be part of the haskell distribution or something? :)
01:30:55 <ddarius> jonkri: What Haskell distribution?
01:32:00 <jonkri> ddarius: wherever Map is included... ghc perhaps?
01:33:46 <ivanm> is this a non-hashed equivalent of a hash-map or something?
01:34:17 <ivanm> or is it meant to be a Set-like type with a cheaper way of doing comparisons?
01:34:53 <zenzike> I'd like to parse some simple input, where the first line contains a number that indicates how many lines will follow, and the following lines come in pairs, where the first line defines a fixed number of space separated ints, and the second line defines a list of ints. What's the "right" way to solve this? I'm thinking of just writing a function of type String -> [(Int, Int, Int, [Int])], but wondering if there's a standard way to solve this kind of problem.
01:36:14 <dmwit> zenzike: Parsec seems like the way to go.
01:36:15 <mornfall> zenzike: You could go with lines/words and read and just discard all the counts.
01:36:30 <zenzike> dmwit: is that overkill?
01:36:35 <zenzike> mornfall: is that hacky?
01:36:42 <dmwit> No.
01:36:42 <mornfall> Yes for both. :)
01:36:43 <dmwit> Yes.
01:36:45 <zenzike> (I considered both those options, and not sure which to choose!)
01:37:04 <dmwit> It's not overkill. Parsec parsers are so easy to write.
01:37:19 <mornfall> dmwit: Come on, do you really believe that? :)
01:37:22 <jonkri> ivan: i don't know what it's meant to be, but i was thinking it's a convenient way to insert elements into maps that can generate their own keys
01:37:26 <dmwit> I would say it's probably easier to write the parser correctly than it is to write with lines/words/etc.
01:37:36 <dmwit> mornfall: Yup, I've written a few. =)
01:37:37 <jonkri> but maybe it's not worth it
01:40:04 <zenzike> thanks guys. it seems like it's a subjective issue :-)
01:42:56 <Zeiris> What's the difference between quickcheck and a fuzzer?
01:43:42 <ivanm> what's a fuzzer?
01:44:14 <Zeiris> Thing that feeds invalid/unexpected/random data into a program, according to Wikipedia.
01:45:14 <ivanm> well, quickcheck tries to narrow down the input to try and find a minimal incorrect case
01:45:30 <ivanm> but also, QC is based upon you specifying properties that must be upheld, rather than just trying to crash a program
01:45:36 <Zeiris> And can also verify that the system functions correctly, rather than just handling exceptions.
01:45:37 <Zeiris> Yeah.
01:45:50 <ivanm> so if my quick skimming of the wikipedia article on a fuzzer is correct, then QC is just an advanced/specialised fuzzer
01:50:14 <ivanm> does anyone know of any packages with existing Arbitrary instances for Text?
01:52:34 <ivanm> oh, even Text's own testsuite just uses arbitrary = fmap T.pack arbitrary :s
01:56:59 <keep_learning> hello all 
01:57:21 <keep_learning> i am trying to implement elliptic curve prime factorisation in haskell 
01:57:33 <keep_learning> i implemented it into python 
01:57:45 <keep_learning> and trying to translate it into Haskell 
01:57:52 <keep_learning> here is link http://pastebin.com/Ab0WwS7k
01:58:05 <keep_learning> which contains both python and haskell code 
01:58:11 <keep_learning> i just wanted to know 
01:58:35 <keep_learning> if my multiEC routine translated correctly 
01:59:09 <keep_learning> multiEC in haskell is translated correctly from python mulPoint 
01:59:29 <keep_learning> As soon as i get d >1 
01:59:35 <keep_learning> i am returning from 
01:59:42 <keep_learning> function in python 
01:59:46 <keep_learning> but in haskell 
01:59:51 <keep_learning> this is bit difficult 
02:00:03 <keep_learning> and i don't know how to do this 
02:02:51 <keep_learning> any one 
02:02:54 <keep_learning> ?
02:03:28 <Zeiris> I'd like to help but I have no idea what you mean.
02:06:24 <keep_learning> @Zeiris  i just wanted to 
02:06:24 <lambdabot> Unknown command, try @list
02:06:47 <ivanm> keep_learning: don't try to translate code; re-implement the algorithm from scratch
02:07:02 <keep_learning> if my python code of mulPoint and multiEC 
02:07:03 <keep_learning> are same 
02:07:05 <keep_learning> or not
02:07:14 <Zeiris> What do the test cases say?
02:07:34 <ivanm> keep_learning: you can make it easier to read by starting the first guard on the next line
02:07:48 <Zeiris> And he's right about direct translations: if your code in two languages is the same, it's usually because one of the implementations is awkward.
02:07:57 <keep_learning> actuall in python when i am getting d >1 
02:08:00 <keep_learning> i am returning 
02:08:03 <ivanm> keep_learning: also, if extended_gcd always returns 3 Integers, then return a triple, not a list
02:08:04 <keep_learning> but in haskell 
02:08:26 <ivanm> you're also mixing and matching camelCase with underscores for function names
02:08:53 <keep_learning> @ivanm  k 
02:08:54 <lambdabot> Unknown command, try @list
02:10:29 <keep_learning> @ivanm in python [mulPoint ]as soon as i get d >1 i am returing it to calling function but in[multiEC]  Haskell i am taking a 
02:10:30 <lambdabot> Unknown command, try @list
02:10:42 <keep_learning> global variable q 
02:10:50 <keep_learning> and storing the value 
02:10:57 <ivanm> keep_learning: don't start with a @, it confuses lambdabot!
02:11:00 <ivanm> @botsnack
02:11:01 <lambdabot> :)
02:12:27 <keep_learning> @ivanm  thank you 
02:12:27 <lambdabot> Unknown command, try @list
02:12:45 <keep_learning> but could you suggest me method in haskell 
02:12:59 <keep_learning> like if i have found something in middle of function 
02:13:07 <ivanm> then return the value
02:13:08 <keep_learning> and want to return to calling 
02:13:11 <keep_learning> funciton 
02:13:47 <keep_learning> return is some IO operation in haskell 
02:13:47 <ivanm> just return the value once you've reached a stopping point
02:13:52 <ivanm> no, don't use return
02:14:01 <ivanm> just state the value to be returned
02:14:01 <ivanm> @type return
02:14:02 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:14:08 <keep_learning> :) 
02:14:30 <keep_learning> k i will study monads 
02:14:35 <ivanm> no need
02:14:53 <ivanm> > let fact n | n <= 0 = 1 | otherwise = n * fact (n-1) in fact 5
02:14:55 <lambdabot>   120
02:15:10 <ivanm> keep_learning: ^^ when the stopping criterion is reached, the value is returned
02:15:17 <ivanm> in FP we use recursion a fair amount
02:15:54 <ivanm> formatting-wise, your code can definitely be improved to match more typical layout of Haskell code
02:16:28 <keep_learning> @ivanm i got it what if my function return two types of value. FIrst is type  a and second is type b 
02:16:28 <lambdabot> Unknown command, try @list
02:16:38 <ivanm> keep_learning: return a tuple
02:16:46 <keep_learning> so some times if i got a speciall value of b 
02:16:51 <keep_learning> i have to break it 
02:17:00 <ivanm> "special"?
02:17:01 <keep_learning> and return to calling function 
02:17:09 <ivanm> > 5 `divMod` 2
02:17:10 <lambdabot>   (2,1)
02:17:17 <keep_learning> yes suppose like all the time i get b =1 
02:17:26 <keep_learning> but if i got b =5 
02:17:36 <keep_learning> then return this to calling 
02:18:09 <drp> keep_learning: In your multiEC function, you are not using the variable q at all.  Perhaps what you want instead of "in fun e v (w-1)" is something like "if f==1 then fun e v (w-1) else (e,f)"
02:18:33 <ivanm> afk
02:18:34 <keep_learning> actually in multiEC 
02:18:45 <Kaidelong> keep_learning: Either if you want either one type or the other, tuple for both types at once
02:18:46 <keep_learning> p is point and q is Integer 
02:19:28 <keep_learning> @Kaidelong yes 
02:19:28 <lambdabot> Unknown command, try @list
02:20:07 <keep_learning> i am returning a list from multiEC which contains a Point and Integer 
02:20:31 <keep_learning> Now if  i got anything other then 1 from addPoint 
02:20:41 <keep_learning> it means i got a factor of number 
02:20:52 <keep_learning> and i have to report it to calling function 
02:20:54 <drp> you are only setting q, never using it
02:21:15 <keep_learning> that i will use in when i will implement the whole function 
02:23:47 <keep_learning> here i removed all other functions http://pastebin.com/SzcxFJSH
02:24:23 <keep_learning> except addPoints and multiEC in haskell 
02:24:33 <keep_learning> and rest two are in python 
02:25:37 <keep_learning> @ivanm i just wanted to know if addPoints in haskell return second value other then 1 so my q will store it 
02:25:37 <lambdabot> Unknown command, try @list
02:25:40 <keep_learning> multiEC 
02:27:22 <drp> I think you want the function 'fun' to not recurse when f==1, is that correct?
02:27:38 <Phyx-> any better way of doing: concatMap (maybe [] id . flip lookup flagstock)
02:28:09 <ivanm> Phyx-: fromMaybe rather than maybe
02:28:22 <Phyx-> @fromMaybe
02:28:23 <lambdabot> Unknown command, try @list
02:28:28 <Phyx-> @type fromMaybe
02:28:29 <lambdabot> forall a. a -> Maybe a -> a
02:28:36 <Phyx-> ah
02:28:46 <keep_learning> @drp yes 
02:28:46 <lambdabot> Maybe you meant: arr do map rc src url
02:28:50 <ketil> >fromMaybe Nothing
02:29:02 <Phyx-> catMaybe . map (flip lookup flagstock) should work too i think
02:29:12 <Phyx-> @type catMaybe
02:29:13 <lambdabot> Not in scope: `catMaybe'
02:29:15 <Phyx-> @type catMaybes
02:29:16 <lambdabot> forall a. [Maybe a] -> [a]
02:29:32 <drp> keep_learning: Then instead of 'in fun e v (w-1)' do 'in if f==1 then (e,f) else fun e v (w-1)'
02:29:53 <drp> keep_learning: (and similar for the other recursion call in 'fun')
02:30:10 <keep_learning> @drp thank you
02:30:11 <lambdabot> Maybe you meant: arr do map rc src url
02:31:45 <Phyx-> hmm i should probably use a map, though would the performance be noticeable with ~30elemens, though it might get queried alot
02:32:40 <Twey> :t mapMaybes
02:32:41 <lambdabot> Not in scope: `mapMaybes'
02:32:42 <Twey> :t mapMaybe
02:32:43 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
02:32:46 <Twey> Phyx-: ^
02:32:58 <Phyx-> ooh, it's magic!
02:33:04 <Phyx-> thanks Twey :)
02:33:14 <Twey> You're welcome ☺
02:34:40 <Twey> mapMaybe (`lookup` flagstock)
02:35:00 <jonkri> six spaces seems to be the default for indentation for things like a function where or guards when you have to break the line after the function arguments, correct?
02:35:17 <ivanm> jonkri: no
02:35:18 <mauke> no
02:35:27 <Twey> jonkri: It's about what it lines up with above
02:35:28 <ivanm> jonkri: some people use 2 spaces, others 4, etc.
02:35:35 <ivanm> (for new indentation levels)
02:35:35 <Twey> Not about how many spaces there are
02:35:42 <mauke> lining up is only relevant for layout mode
02:35:51 <mauke> i.e. doesn't matter for function bodies or guards
02:36:12 <Twey> I was talking about convention, not syntax
02:37:06 <Phyx-> Twey: ty, that's much nicer than what i first had, hehehe
02:37:27 <jonkri> oh okay. if the first line is "subscribe jid" and i press tab on the second line, it will jump to the column where "jid" starts. how can i instead jump (for example) four spaces?
02:37:30 <jonkri> using emacs!
02:38:00 <mauke> C-x C-c vim RET
02:38:10 <jonkri> oh snap
02:38:17 <mauke> that's all the emacs I know :-(
02:40:47 <jonkri> if anyone has a simple emacs method for this, please let me know
02:42:31 <jonkri> also, how do you indent the last line at http://paste.pocoo.org/show/320946/ ?
02:42:39 <ivanm> jonkri: are you using haskell mode?
02:42:46 <jonkri> ivanm: yes
02:42:56 <ivanm> then it does most of the indentation stuff for you
02:43:20 <jonkri> it seems to be jumping to the col of the next above word
02:43:37 <jonkri> which doesn't work when i want to jump two or four spaces to make a guard or something
02:44:11 <ivanm> type the |, then tab
02:45:01 <jonkri> ivanm: results in "|         "
02:45:25 <ivanm> then you haven't activated the indentation mode
02:45:38 <ivanm> see the README
02:51:34 <jonkri> aha ok
02:51:47 * hackagebot hashmap 0.2 - A purely functional and persistent hash map  http://hackage.haskell.org/package/hashmap-0.2 (KevinWuWon)
02:52:09 <ivanm> anyone know if there's any particular reason Text doesn't have elem and notElem equivalents?
02:53:14 <copumpkin> qrd
02:53:15 <copumpkin> wtf
02:53:23 <copumpkin> dcoutts: what happened there?
02:53:30 <copumpkin> I guess you aren't the hackage person :P
02:53:32 <copumpkin> sorry
02:54:36 <copumpkin> looks like someone just uploaded a completely unrelated package with the same name
02:54:53 <Phyx-> dance monkey, dance.. produce my code!
02:56:55 <Phyx-> well, guess it showed me....
03:05:56 * hackagebot fuzzytime 0.4 - Telling the time in a more humane way  http://hackage.haskell.org/package/fuzzytime-0.4 (KamilStachowski)
03:22:27 <Phyx-> @type foldl (\a b->a ++ " " ++ b) . lines
03:22:28 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
03:22:29 <lambdabot>       Expected type: String -> [Char]
03:22:29 <lambdabot>       Inferred type: String -> [String]
03:22:40 <Phyx-> @type foldl (\a b->a ++ " " ++ b) "" . lines
03:22:42 <lambdabot> String -> [Char]
03:22:54 <Phyx-> @pl  foldl (\a b->a ++ " " ++ b) "" . lines
03:22:55 <lambdabot> foldl ((. (' ' :)) . (++)) [] . lines
03:22:58 <Phyx-> eew
03:23:47 <jonkri> how can i specify that a Map i have created with Map.empty should be of type, say, String -> Num
03:25:05 <mauke> Num is not a type
03:25:16 <Phyx-> add an explicit type signature
03:25:29 <Phyx-> and mauke is right :)
03:27:32 <jonkri> say that i want to do this: newState = Map.empty String String... how can i avoid the "Not in scope: data constructor `String'" errors?
03:28:04 <mauke> newState = Map.empty
03:28:48 <Botje> jonkri: String only exists in the types namespace
03:28:52 <Botje> you're creating a value
03:29:08 <Botje> what you CAN do is newState = Map.empty :: Map.Map String String
03:31:11 <jonkri> ah
03:32:24 <jonkri> "newState = Map.empty :: Nodes" works. however, when i change the type of newState to State (data State = Nodes) and try "(Map.empty :: Nodes) :: State" it cannot match State against Nodes... guess you can't "cast" like that, huh?
03:33:07 <mreh> golfing question, splitting a list where the list sublist first satisfies some predicate
03:33:10 <mauke> data State = Nodes? what
03:33:11 <mreh> not just the element
03:33:22 <mreh> like break or span
03:33:45 <Botje> jonkri: what?
03:33:57 <Botje> jonkri: State is in the types namespace, Nodes in the values namespace.
03:34:06 <Botje> you cannot use Nodes in a type 
03:34:19 <jonkri> got it
03:34:29 <mauke> actually, you have two different Nodes
03:34:34 <mauke> one's a type, the other a value
03:34:41 <mreh> map (inits &&& tails) $ [1,2,3,4,5]
03:34:46 <mreh> > map (inits &&& tails) $ [1,2,3,4,5]
03:34:46 <lambdabot>   No instance for (GHC.Num.Num [a])
03:34:47 <lambdabot>    arising from a use of `e_112345' at <i...
03:37:43 <opqdonut> ah, stupid me
03:37:54 <opqdonut> I need to cache the measures of individual elements myself
03:38:08 <opqdonut> fingertree only caches them for inner nodes and not leaves
03:42:23 * hackagebot fuzzytime 0.4.1 - Telling the time in a more humane way  http://hackage.haskell.org/package/fuzzytime-0.4.1 (KamilStachowski)
03:43:24 <mreh> > transpose . uncurry (++) . (return . inits &&& return . tails) $ ([1,2,3] :: [Int])
03:43:25 <lambdabot>   [[[],[1,2,3]],[[1],[2,3]],[[1,2],[3]],[[1,2,3],[]]]
03:45:35 <Jafet> > uncurry zip $ inits &&& tails $ [1,2,3]
03:45:36 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
03:45:46 <mreh> ah yeah
03:46:46 <Jafet> > liftM2 zip inits tails [1,2,3]
03:46:47 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
03:48:08 <mreh> this one I don't get
03:48:42 <mreh> :t liftM2
03:48:43 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:49:01 <mreh> :t inits
03:49:02 <lambdabot> forall a. [a] -> [[a]]
03:49:54 <Jafet> The list monad strikes again
03:50:04 <mreh> the types don't parse
03:50:06 <mreh> in my head
03:50:22 <Jafet> > liftM2 zip return return [1,2,3]
03:50:23 <lambdabot>   [([1,2,3],[1,2,3])]
03:50:31 <Jafet> > liftM2 zip return (replicate 2) [1,2,3]
03:50:33 <lambdabot>   [([1,2,3],[1,2,3])]
03:50:37 <Jafet> Oh, er
03:50:47 <Jafet> > liftM2 zip (replicate 2) (replicate 3) [42]
03:50:48 <lambdabot>   [([42],[42]),([42],[42])]
03:51:09 <Jafet> Nevermind, looks like I don't get it either
03:51:27 <mreh> inits is not a monad
03:52:32 <Jafet> inits :: (Monad m = []) => [a] -> m [a]
03:52:47 <Jafet> @quote monads.are
03:52:48 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
03:52:49 <mreh> yeah
03:53:35 <Jafet> I've always wanted to order one of those klein bottles
03:54:28 <luite> I only want klein bottles once they make proper one, without curved surfaces and self-intersection ;)
03:55:40 <Jafet> You won't accept M-theory space unless it admits embeddings of non-orientable surfaces?
03:56:15 <mreh> how do you drink from one
03:58:12 <mreh> http://www.kleinbottle.com/wine_bottle_klein_bottle.html
03:59:53 <Jafet> http://www.kleinbottle.com/drinking_mug_klein_bottle.htm
04:02:35 <Kaidelong> could you argue that haskell is nicer for imperative programming because you can't possibly confuse a procedure with a function (short of malice)?
04:03:24 <Kaidelong> IE MArray -> ST () announces immediately that you've left the world of pure functions
04:05:19 <Jafet> @quote SPJ imperative
04:05:20 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
04:07:16 <Kaidelong> makes me think that a "pure" imperative language might be a worthwhile pursuit in itself
04:07:20 <Jafet> @remember SPJ Haskell is the world's best imperative language.
04:07:20 <lambdabot> Good to know.
04:07:26 <Kaidelong> I suppose that is part of the motivation behind disciple
04:08:28 <zenzike> is there a way to "unimport" a module from ghci after it's been imported?
04:08:28 <ivanm> was that actually SPJ that said that?
04:08:32 <ivanm> @quote imperative
04:08:33 <lambdabot> tnks says: I'm astounded that LYAH makes an FP language accessible, while Why's Poignant Guide makes a straight-forward imperative language look arcane.
04:08:36 <ivanm> zenzike: :m -Data.Foo
04:08:42 <ivanm> @quote imperative
04:08:43 <lambdabot> lennart says: I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
04:08:43 <lambdabot> useful for functional code
04:08:43 <zenzike> ivanm: thanks
04:09:22 <Kaidelong> let programmers write code that looks imperative, statically check that it doesn't let you observe any side effects from higher scope unless explicitly parameterized
04:09:49 <Kaidelong> that could also make memory management easier, actually
04:11:22 <Jafet> Side effects are just the ones you haven't bothered to write down in your semantics.
04:11:41 <Jafet> (Which is why IO is necessarily the sin bin.)
04:14:47 <Kaidelong> I try to avoid using IO if I can help it
04:14:55 <Kaidelong> but I find myself using ST way more than I'd like to
04:15:37 <Kaidelong> especially since I only superficially understand how ST works and would rather not think about it or write down types involving it
04:20:10 <aristid> Kaidelong: maybe you use ST a lot due to your choice of data structures?
04:21:05 <Kaidelong> aristid: for that application, it made sense. Particularly since I did a lot of in place shuffles.
04:21:29 <Kaidelong> not to mention needing random access
04:21:43 <Kaidelong> to a memory bank
04:21:54 <Kaidelong> to overwrite the worst members of the population during the search
04:22:43 <Kaidelong> well what I ended up doing was actually quite different
04:22:56 <Kaidelong> I ended up using a tree to represent the memory bank
04:23:10 <aristid> Kaidelong: whenever somebody talks about genetic algorithms, the gods of machine learning demand that somebody say that genetic algorithms are always the wrong choice.
04:23:21 <Kaidelong> aristid: harmony search
04:23:30 <Kaidelong> also genetic algorithms can be pretty good if properly tweaked
04:23:39 <Kaidelong> just not the one they teach you, with the roulette wheel
04:23:45 <nyloc> Hi, I'am totally new to haskell and currently trying to understand some example code
04:23:52 <Kaidelong> shoot
04:24:07 <nyloc> showReg Empty    = ("Empty"++)
04:24:17 <nyloc> if i type :info showReg
04:24:29 <nyloc> I get showReg :: Reg -> [Char] -> [Char]
04:24:36 <luite> there's always a better choice than genetic algorithms, but finding that choice is a difficult optimization problem :p
04:25:00 <Kaidelong> aristid: oh that's the other thing, this isn't machine learning, not really! it is optimization
04:25:03 <Maxdamantus> :t ("foo"++)
04:25:04 <lambdabot> [Char] -> [Char]
04:25:15 <aristid> Kaidelong: is there a difference? :)
04:25:17 <Maxdamantus> :t \42 -> ("foo"++)
04:25:18 <lambdabot> forall t. (Num t) => t -> [Char] -> [Char]
04:25:21 <Kaidelong> nyloc: what do you need help understanding
04:25:52 <Jafet> Genetic algorithms are actually the only real kind of machine learning
04:25:52 <nyloc> why does it result in showReg Empty "Test" to "EmptyTest"!
04:26:08 <Jafet> All other methods require you to learn at least as much as the machine does
04:26:22 <Kaidelong> Jafet: define learning here
04:26:32 <nyloc> the ++ operator is a String concatonation operation
04:26:47 <Botje> nyloc: what is your question here? Empty is of type Reg and "Test" is a [Char]
04:27:42 <nyloc> yeah but where  does the line = ("Empty"++) say that the second parameter should be added after the Empty
04:27:47 <Jafet> Kaidelong: I haven't learned the definition of that
04:27:50 <Kaidelong> I guess optimization is machine learning just as much as classification is
04:28:00 <aristid> nyloc: the second parameter is a second function call
04:28:13 <aristid> nyloc: and ("Empty"++) is a function
04:28:30 <nyloc> oh
04:28:34 <nyloc> now I understand
04:28:55 <Jafet> showReg Empty "Test" = (showReg Empty) "Test" = ("Empty"++) "Test"
04:29:00 <nyloc> so my funktion results in a function which gets called with my string
04:29:02 <nyloc> thx
04:29:59 <nyloc> so even if the type of showReg ist Reg -> [Char] -> [Char]
04:30:30 <nyloc> i can input just a Reg and haskell addes and empty string ?
04:30:48 * hackagebot snap-core 0.3.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.3.1 (GregoryCollins)
04:31:47 <Botje> nyloc: no, if you give it just a Reg you will get a function [Char] -> [Char] back
04:32:06 <nyloc> or is the type inferred becaus the function returns a function which needs a string
04:32:47 <nyloc> slowly I'm getting the idea.
04:32:48 * hackagebot snap-server 0.3.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.3.1 (GregoryCollins)
04:32:48 <Botje> ALL types are inferred :)
04:32:50 <Maxdamantus> Functions only really have one argument.
04:32:54 <Kaidelong> -> is right associative (just like the propositional logic operator that it actually is)
04:33:20 <Kaidelong> a -> b -> c and a -> (b -> c) are the same thing
04:33:49 * hackagebot snap 0.3.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.3.1 (GregoryCollins)
04:38:51 * hackagebot snap-core 0.3.1.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.3.1.1 (GregoryCollins)
04:46:29 <mreh> > liftM2 zip inits tails [1,2,3]
04:46:31 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
04:46:40 <mreh> I still don't understand that
04:46:55 <mreh> I understand what liftM2 does
04:47:22 <Jafet> @src liftM2
04:47:22 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:47:38 <mreh> but inits and tails are functions
04:47:54 * hackagebot hoogle 4.1.4 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.1.4 (NeilMitchell)
04:47:58 <Jafet> Oh, right, it's not the monad instance for lists
04:48:10 <Jafet> It's the monad instance for ((->) a)
04:48:14 <mreh> this is Caleskell
04:48:22 <Jafet> No, it's a standard monad
04:48:26 <Jafet> ...instance
04:49:09 <mreh> I've never seen the type -> a used as a monad directly
04:49:20 <mreh> (->) a
04:49:35 <alpounet> @instances Monad
04:49:36 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
04:49:42 <alpounet> :)
04:49:44 <Jafet> (a ->), but sections aren't allowed in types
04:50:23 <alpounet> yeah, (->) a is (a ->), just like (+) 1 is (1+)
04:51:39 <mreh> :t runReader
04:51:40 <lambdabot> forall r a. Reader r a -> r -> a
04:52:00 <mreh> that I *have* seen
04:52:21 <Entroacceptor> what is -> in this conntext??
04:52:26 <jonkri> how can pattern match like "myFunc (My, Pair) =" while having the "(My, Pair)" tuple in a variable?
04:52:38 <Botje> jonkri: ?
04:52:48 <Botje> jonkri: oh. you can use let or case
04:52:55 <Botje> let (My, Pair) = x in ..
04:53:02 <mreh> Entroacceptor: the same as it is elsewhere in types, a function symbol
04:53:09 <mreh> or type constructor
04:53:18 <alpounet> Entroacceptor, it's the same -> you see in, e.g, Int -> Int
04:53:24 <alpounet> it's a type level 'operator'
04:53:37 <Entroacceptor> jonkri: I think you want tupl@(My, Pair)
04:53:38 <mreh> because it's infix?
04:53:49 <jonkri> Entroacceptor: that's the one!
04:53:55 <jonkri> Botje: sorry for being unclear
04:54:30 <Entroacceptor> and that's a monad...
04:54:54 <Entroacceptor> ok, thanks, I thought I had understood something :)
04:58:30 <timopheym> Hi all, i fail today my Haskell exam...(
04:59:12 <Botje> boo
04:59:14 <Botje> what happened?
04:59:25 <medfly`> people come here like Haskell is physics or something.
04:59:47 <timopheym> )) No
05:00:13 <ulfdoz> You missed the appointment?
05:00:16 <timopheym> I wrote tasks for my friend, but hadn'y time for me(
05:00:56 <timopheym> And task wore simple
05:01:30 <timopheym> i had to write function like word
05:02:20 <Botje> so you failed the exam because you made it for someone else?
05:02:26 <timopheym> and another that test two-dimensional list for square matrix 
05:02:52 <timopheym> yes. i just hadn't time(
05:06:58 <Botje> i hope your "friend" made it worth your while
05:09:33 <timopheym> Yes, he do)
05:10:05 * hackagebot attoparsec-iteratee 0.2.0 - An adapter to convert attoparsec Parsers into blazing-fast Iteratees  http://hackage.haskell.org/package/attoparsec-iteratee-0.2.0 (GregoryCollins)
05:10:22 <timopheym> I'l try mail to my teacher with answers...
05:12:13 <Bynbo7> timopheym: wait, so you're going to fail, and get accused with academic misconduct? that's.. pretty fail
05:13:27 <Bynbo7> uh, s/with/of/
05:13:52 <timopheym> It isn't so bad in russian, here we can (usualy) try make exem for thre times...
05:14:00 <ulfdoz> Hm, if this came out at my former university, you'd definitely leave it.
05:16:32 <Jafet> In soviet russia, words fail you
05:17:00 <Phyx-> heh
05:17:10 <Entroacceptor> :)
05:17:14 <luite> hehe
05:18:23 <timopheym> Why soviet? It is now Russion Federation, no?
05:19:22 <alpounet> it was a joke
05:19:50 <timopheym> )
05:23:04 <nyloc> I have another one which isn't compleatly clear to me, parse :: Reg -> [String] -> Bool 
05:23:04 <nyloc> parse = (final .) . dstar
05:23:04 <nyloc> final :: Reg -> Bool
05:23:04 <nyloc> dstar :: Reg -> [String] -> Reg
05:23:32 <nyloc> I would understand one . to compose final and dstar
05:23:45 <nyloc> but why are there two dots?
05:23:52 <alpounet> @unpl (f .) . g
05:23:53 <lambdabot> (\ d i -> f (g d i))
05:24:09 <alpounet> so it's equivalent to : parse x y = final (dstar x y)
05:24:17 <mauke> nyloc: one . would be a type error
05:24:25 <alpounet> it's a sort of "common" pattern
05:27:22 <nyloc> mauke: I dont't understand why one dot would be a type error.
05:27:40 <nyloc> is it because there are two parameters?
05:27:51 <mauke> it is because dstar returns a function
05:27:57 <mauke> and final takes a Reg, not a function
05:28:25 <nyloc> oh, ok i thought dstar would return a Reg
05:28:42 <mauke> dstar :: Reg -> ([String] -> Reg)
05:28:54 <mauke> it takes a Reg and returns a function (from Strings to Reg)
05:29:17 <nyloc> ok, now it makes sens to me
05:29:22 <nyloc> thanks again
05:42:44 <Bynbo7> win 21
05:43:11 <Bynbo7> > replicateM 4 [0,1]
05:43:11 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1...
05:43:23 <Bynbo7> > replicateM 4 "01"
05:43:24 <lambdabot>   ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","101...
05:44:06 <Entroacceptor> it can count
05:48:47 <Kaidelong> interesting bit of overloading of monad there
05:48:54 <Kaidelong> @src replicateM
05:48:54 <lambdabot> replicateM n x = sequence (replicate n x)
05:49:04 <Kaidelong> @src sequence
05:49:04 <lambdabot> sequence []     = return []
05:49:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:49:05 <lambdabot> --OR
05:49:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:50:52 <Kaidelong> > [0,1] >>= [0,1]
05:50:53 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
05:50:59 <Kaidelong> err
05:51:03 <Kaidelong> > [0,1] >> [0,1]
05:51:04 <lambdabot>   [0,1,0,1]
05:51:37 <Kaidelong> > [0,1] >>= return . (:[[0,1]])
05:51:38 <lambdabot>   No instance for (GHC.Num.Num [t])
05:51:38 <lambdabot>    arising from a use of `e_10101' at <in...
05:51:51 <Jafet> > ((.((.((.return).(:))).(.).(:))).(.).(.).(:)) <$> [0,1] <*> [0,1] <*> [0,1] <*> [0,1]
05:51:52 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1...
05:52:08 <Kaidelong> @unpl ((.((.((.return).(:))).(.).(:))).(.).(.).(:)) <$> [0,1] <*> [0,1] <*> [0,1] <*> [0,1]
05:52:08 <lambdabot> (((((\ o ag i l -> ((:)) o (((:)) ag (((:)) i (return l)))) <$> ([0, 1])) <*> ([0, 1])) <*> ([0, 1])) <*> ([0, 1]))
05:52:28 <Jafet> \a b c d -> [a,b,c,d]
05:55:25 * hackagebot cmdargs 0.6.7 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.7 (NeilMitchell)
05:57:19 <opqdonut> it seems that -prof interacts badly with opitisations
05:57:54 <opqdonut> specifically, it seems to interfere with strictness analysis
06:05:22 <Cin> Where are the show instances in the awesome prelude?
06:06:03 <companion_cube> :i Show
06:06:11 <Cin> E.g. Lang.JavaScript -- JS has no mention of Show.
06:06:27 <Cin> λ> :t show (true::JavaScript Bool)
06:06:27 <Cin> show (true::JavaScript Bool) :: String
06:06:28 <Cin> ^ No problem. 
06:06:33 <companion_cube> this is not prelude, afaict
06:06:53 <Cin> S'there an easy way to find an instance definition in GHCi?
06:07:01 <Cin> Ah wait, :i Show.
06:07:27 <Cin> Ah, found it.
06:07:35 <Cin> instance Show (j a) -- Defined in Generic.Data.Num
06:08:41 <Cin> Not sure I follow the reasoning for't.
06:08:48 <Cin> instance Prelude.Show (j a) where show _ = "num"
06:10:09 <Cin> Ah, I need a Show for Val. :t show (undefined :: Val JS Bool) => String
06:11:50 <Cin> λ> let x = show (true :: Val JS Bool) in putStrLn x
06:11:50 <Cin> Loading package array-0.3.0.1 ... linking ... <interactive>: /home/chris/.cabal/lib/AwesomePrelude-0.1.0/ghc-6.12.3/HSAwesomePrelude-0.1.0.o: unknown symbol `AwesomePreludezm0zi1zi0_CompilerziLiftDefinitions_inline_closure'
06:11:50 <Cin> ghc: unable to load package `array-0.3.0.1'
06:11:50 <Cin> Ah, balls.
06:13:34 <Maxdamantus> @pl flip liftM
06:13:34 <lambdabot> flip fmap
06:14:45 <aristid> Maxdamantus: flip liftM is already point-free
06:14:52 <Maxdamantus> Monads are Functors or something aren't they ..? fmap would work as liftM but more generally?
06:15:12 <Maxdamantus> aristid: I know, was just seeing if there was already a common function.
06:15:24 <Maxdamantus> @pl flip (>>=)
06:15:25 <lambdabot> (=<<)
06:15:49 <keep_learning> rollDice ::Integer-> IO Integer
06:15:49 <keep_learning> rollDice n= do
06:15:49 <keep_learning>                 a<-getStdRandom (randomR (1,n))
06:15:49 <keep_learning>                 return a
06:15:59 <keep_learning> could some one please tell me 
06:16:06 <aristid> Maxdamantus: Monads are supposed to be functors, but sadly haskell98 did not specify it that way
06:16:13 <Maxdamantus> Ah.
06:16:13 <keep_learning> how to return Integer from rollDice function 
06:16:23 <keep_learning> rather than IO Integer
06:17:41 <Jafet> keep_learning: think: why does it require IO?
06:18:19 <mreh> > take 3 . liftM2 inits tails $ [1..]
06:18:20 <lambdabot>   Couldn't match expected type `a2 -> a'
06:18:20 <keep_learning> @jafet i want random number to use in a function 
06:18:20 <lambdabot>         against inferred type `[[a1]]'
06:18:20 <lambdabot> Unknown command, try @list
06:18:29 <mreh> > take 3 . liftM2 zip inits tails $ [1..]
06:18:32 <lambdabot>   [([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
06:18:41 <mreh> ah yes
06:18:53 <Jafet> keep_learning: System.Random provides pure functions to get pseudorandom numbers
06:19:07 <co_dh> greeting , does anybody successfully " cabal install xmonad" on snow leopard? 
06:19:12 <Jafet> They can't pull a number out of nothing, so you have to supply a generator
06:19:24 <alpounet> co_dh, what are the errors you're getting ?
06:19:33 <co_dh>  Missing C library: Xinerama
06:19:37 <keep_learning> @jafet Are those function return different number every time 
06:19:37 <lambdabot> Unknown command, try @list
06:19:42 <keep_learning> as they are called ?
06:19:52 <alpounet> co_dh, have you tried to install Xinerama ?
06:20:18 <co_dh> xinerama is a virtual package, it supposed come with snow leopard
06:20:29 <keep_learning> Jafet, are those functions return random number everytime they are called ?
06:20:51 <Jafet> keep_learning: they are pseudorandom generators; they take a state and return a new number and a new state
06:20:56 <co_dh> fink list xinerama
06:20:59 <alpounet> co_dh, you're probably missing the -dev files of xinerama, like headers etc
06:21:01 <Jafet> :t random
06:21:02 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
06:21:05 <co_dh> i   system-pkgconfig-  1.0.3-1        [virtual pkgconfig package representing xinerama]
06:21:05 <co_dh>  
06:21:27 <co_dh> xinerama is not in fink. 
06:21:27 <keep_learning> Jafet : thank you 
06:22:01 <keep_learning> Jafet, but is there way to isolate Int from IO Int
06:22:30 <Jafet> keep_learning: what would that mean?
06:23:37 <Jafet> An Int is an integer -- IO Int is a possibly different integer every time
06:23:38 <alpounet> co_dh, i'm not a mac os x user so i won't be of any help for this particular problem, but if you figure out a way to get the correct xinerama package, it should be fine
06:23:57 <alpounet> wasn't there something called "mac ports" or somesuch to install packages ?
06:24:04 <alpounet> you may want to give it a whirl
06:24:48 <keep_learning> Jafet,  IO Int to use in function which ask for Int
06:25:13 <keep_learning> randomCurve:: Integer->[Integer]
06:25:13 <keep_learning> randomCurve n = let
06:25:13 <keep_learning>                         a=1
06:25:14 <keep_learning>                         u=2
06:25:14 <keep_learning>                         v=3
06:25:16 <Jafet> keep_learning: no, I want you to think about what that means.
06:25:18 <co_dh> alpounet: thanks. I guess I might need mac ports. 
06:25:37 <keep_learning> Jafet, i need random value for a u v 
06:25:54 <keep_learning> Jafet, so i will call rollDice n 
06:26:07 <keep_learning> Jafet, since it returns IO Int 
06:26:19 <keep_learning> Jafet, its giving erro 
06:26:22 <Jafet> keep_learning: what kind of values does "IO Int" have?
06:26:27 <keep_learning> :error
06:26:29 <Jafet> What does that type mean?
06:27:11 <keep_learning> Jafet, i did not get u
06:29:02 <Jafet> The values of Int are some (small) integers: 0, -1, 1 ..; so what values does IO Int have?
06:30:50 <keep_learning> Jafet, IO Int also have same value 
06:30:57 <keep_learning> Jafet, i guess 
06:31:25 <Jafet> Why have the IO at all, then? What does the "IO" part mean?
06:32:00 <hpc> IT MEANS NOTHING! CATS AND DOGS LIVING TOGETHER! NUMBERS CHANGING VALUES HOWEVER THEY PLEASE!
06:32:02 <hpc> :P
06:32:09 <keep_learning> Jafet, Because its return different value every time from function if called with same argument
06:32:31 <ben> Trying to "get the Int from IO Int" is like trying to get the string from a burrito
06:33:09 <hpc> keep_learning: the popular catchphrase is "IO x is the type of computations that produce an x"
06:33:30 <hpc> as in, IO Int isn't an Int, but it computes one
06:33:35 <keep_learning> Jafet, i am kind of new to haskell 
06:33:38 <hpc> you just have to execute it (which is not evaluation)
06:33:54 <keep_learning> Jafet, specially for Random number 
06:33:58 <Bynbo7> keep_learning: we can tell ;)
06:34:07 <hpc> so you write your program, and you have one big IO () action as your main function
06:34:12 <keep_learning> Bynbo7, thank you 
06:34:24 <hpc> evaluation ~~ compilation
06:34:24 <keep_learning> Bynbo7, random generation is kind of hard for me 
06:34:29 <Jafet> keep_learning: so, IO Int is some weird thing which produces potentially different Ints every time.
06:34:29 <Zao> How do I get Bread from a Recipe Bread?
06:34:33 <vikeshraj> Hi, I get errors when i try to install lambdabot via cabal
06:34:35 <vikeshraj> http://pastebin.com/8GSF2Nx8
06:34:41 <hpc> then you execute whatever main evaluates to
06:34:50 <keep_learning> Jafet, yes thats what i mean
06:34:50 <vikeshraj> I am on ubuntu 10.10
06:34:52 <Bynbo7> keep_learning: it's not random generation that's hard, it's your misunderstanding of some vital concepts in haskell
06:34:54 <Jafet> keep_learning: that is pretty clearly not the same thing as Int.
06:35:01 <hpc> so, getLine :: IO String
06:35:04 <Zao> You feed the Recipe Bread to a baker, which interprets it and gives you a loaf of Bread.
06:35:09 <hpc> but the String it makes depends on how it executes
06:35:13 <keep_learning> Bynbo7, yes 
06:35:13 <hpc> NOT how it evaluates
06:35:21 <Zao> Possibly a differently shaped or tasting loaf every time.
06:35:45 <Jafet> (Are all the IO tutorials so bad, that we can't just direct him to one?)
06:35:46 <hpc> and it simply evaluates to some code that asks STDIN for a line of text
06:35:53 <Zao> Monads are like bakers!
06:35:54 <Zao> :D
06:36:14 <Bynbo7> @google axman6 Haskell IO tutorial
06:36:15 <lambdabot> Plugin `search' failed with: connect: does not exist (Connection refused)
06:36:22 <Bynbo7> :O
06:36:32 <hpc> Jafet: the best one would perhaps be lyah's, but it starts at chapter 6 or so
06:36:40 <hpc> and assumes you get everything that comes before
06:36:43 <Jafet> Google detected evil intent, and refused it
06:36:49 <hpc> (and even then, teaches it a bit like magic)
06:37:38 <Bynbo7> keep_learning: maybe this will help a little: http://random.axman6.com/blog/?page_id=70
06:37:49 <mauke> http://mauke.dyndns.org/stuff/haskell/how-to-io.html - is this acceptable?
06:38:27 <keep_learning> Bynbo7, thank you
06:38:48 <keep_learning> mauke, everything which explains some thing abt haskell
06:39:38 <timopheym> why a can't make division at line 3
06:39:42 <timopheym> let ml = [[1,2,3],[4,5,6],[7,8,9]]
06:39:42 <timopheym> let len = length ml
06:39:42 <timopheym> let s = sum(map (length) ml) / len
06:39:43 <timopheym> ?
06:40:05 <Bynbo7> timopheym: you're using the wrong kind of dovision, you need div
06:40:08 <Bynbo7> :t div
06:40:09 <lambdabot> forall a. (Integral a) => a -> a -> a
06:40:11 <jamii> anyone else waiting for the hacker cup?
06:40:12 <timopheym> tnx!)
06:40:12 <Bynbo7> :t (/)
06:40:13 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:40:25 <Bynbo7> timopheym: replace / with `div`
06:40:34 <Bynbo7> (with the backticks)
06:40:38 <timopheym> Yes, i'm understand) Thnks!
06:41:16 <timopheym> it still doesn't work
06:41:26 <timopheym> let s = (sum(map (length) ml)) div len
06:41:33 <timopheym> let s = (sum(map (length) ml)) div len
06:41:42 <Bynbo7> i told you to use the backticks
06:41:49 <Bynbo7> and you even said you understood!
06:41:50 <Bynbo7> :O
06:42:03 <Bynbo7> you need `div` not div
06:42:14 <timopheym> oh(
06:42:43 <Bynbo7> this is how you make functions infix in haskell
06:42:44 <Zao> Backticks makes a function infix.
06:42:59 <Zao> (div 9001 3) and (9001 `div` 3) are equivalent.
06:43:05 <Bynbo7> > 7 `elem` [1..10]
06:43:05 <lambdabot>   True
06:43:10 <Bynbo7> > 70 `elem` [1..10]
06:43:11 <lambdabot>   False
06:43:14 <Zao> Making them infix tends to make them read out better.
06:43:19 <Bynbo7> > elem 7 [1..10]
06:43:20 <lambdabot>   True
06:43:34 <Zao> "is 7 an element of [1..10]?"
06:43:42 <aristid> > flip elem [1..10] 7
06:43:44 <lambdabot>   True
06:45:16 <vikeshraj> lambdabot is cool
06:45:31 <aristid> vikeshraj: true.
06:45:38 <aristid> i mean True
06:45:52 <vikeshraj> I want to install it. cabal is giving me errors while compiling it
06:46:03 <keep_learning> :t sequence 
06:46:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:46:28 <vikeshraj> http://pastebin.com/8GSF2Nx8
06:47:09 <aristid> vikeshraj: installing lambdabot is not so easy
06:48:09 <vikeshraj> aristid, how do I play with it otherwise ?
06:48:28 <aristid> vikeshraj: you can start a private query
06:48:33 <aristid> /query lambdabot
06:50:32 * Bynbo7 sets his terminal to use Papyrus
06:50:53 <hewei> aristid: a side question, how did you put this command in literally?
06:51:09 <aristid> hewei: //
06:51:21 <aristid> hewei: not all irc clients support this, mine does
06:51:30 <hewei> let me have a try
06:51:33 <hewei> //query lambdabot
06:51:40 <Zao> Some use //, some use /say
06:51:52 <hewei> /query lambdabot
06:51:53 <Zao> Some don't at all.
06:51:55 <Zao> hewei: Hooray.
06:51:58 <mauke> some use / /
06:52:12 <WendyMackaye> chu's monad guides are pretty good
06:52:17 <hpc> mine has neither // or / /
06:53:49 <vikeshraj> aristid, thanks :)
06:55:25 <WendyMackaye> so monads are a series of tubes
06:55:49 <Bynbo7> depending on the monad, yes
06:56:20 <WendyMackaye> could they be a network of tubes?
06:56:23 <Jafet> Vacuum-insulated burrito tubes
06:56:28 <WendyMackaye> :-D
06:56:37 <WendyMackaye> mark chu-carrol <3
06:57:25 <WendyMackaye> i still don't get it, but this is awesome. http://scienceblogs.com/goodmath/2007/01/haskell_a_first_step_into_mona_1.php
06:58:16 <hpc> WendyMackaye: that looks like one of the worse tutorials, i think
06:58:46 <WendyMackaye> but it makes sense to me, somehow
06:59:00 <Jafet> "Hello dear readers, I discovered that monads perform IO!"
06:59:48 <WendyMackaye> well, for the idiot reader, that's awesome
06:59:53 <Jafet> I can prescribe something for their gonads
07:00:04 <hpc> WendyMackaye: a better tutorial of monads would be a description and some example code of Identity a, then Maybe a, etc
07:00:19 <hpc> increasing in complexity until the pattern is obvious
07:00:31 <hpc> Jafet: their gonad monad has an enormous continuation
07:00:38 <WendyMackaye> i did try those
07:01:09 <WendyMackaye> but a moment at chu's and i get the general fuzzy notion
07:01:29 <WendyMackaye> finally
07:01:38 <Jafet> The notion is not for Monad, but for IO.
07:01:44 <Jafet> So it's mislabelled, for one thing
07:01:56 <WendyMackaye> hmmm
07:01:57 <WendyMackaye> i see
07:02:01 <pastorn> WendyMackaye: i learned how monads work and how to write them by reading "all about monads", which is an excellent tutorial
07:02:34 <pastorn> WendyMackaye: the problem is that it's hard to write a general tutorial, since each monad solves a specific task
07:02:42 <Elko> Hi, there! I need some help with the basic mapping function. Anyone here to help me?
07:03:11 <pastorn> Elko: sure, give us some input/output/desired output
07:03:11 <Bynbo7> Elko: we're all here to help. though if this is homework, there's only so much we can do
07:03:22 <pastorn> Bynbo7: well, we CAN do it
07:03:37 <hpc> the big problem with monads is that it has a very abstract interface, that is slightly too much for a person to get all at once
07:03:39 <mauke> > map f [x, y, z]
07:03:40 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:03:40 <lambdabot>    `GHC.Show.Show b'
07:03:40 <lambdabot>      a...
07:03:56 <hpc> functor and applicative are easy, since you can remember them as "those things what look like function application, sort of"
07:04:27 <pastorn> WendyMackaye: to understand it you'll want to have a specific task/pattern you want to describe (stop me if i'm being too abstract)
07:04:33 <hpc> that reminds me, i should finish writing this thing about arrows
07:04:37 <Maxdamantus> > map f [x, y, z] :: Expression
07:04:38 <lambdabot>   Not in scope: type constructor or class `Expression'
07:04:53 <Maxdamantus> :t (f (x + y))
07:04:54 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
07:04:57 <Jafet> > map f [x,y,z] :: [Expr]
07:04:58 <lambdabot>   [f x,f y,f z]
07:05:03 <WendyMackaye> pastorn: hmm....
07:05:19 <Elko> I don't want it to be solved! Here I got some hpaste: http://hpaste.org/43050/greatest_common_divisor
07:05:25 <hpc> > foldr f x [y, z] :: Expr
07:05:27 <pastorn> WendyMackaye: all about monads is good because it has a very concrete example, cloned sheep
07:05:27 <lambdabot>   f y (f z x)
07:05:30 <co_dh> greeting, can anybody tell me where Xinerama.h normally located ? mine on snow leopard is not a normal place , so I can ln to it. just try locate Xinerama.h on a linux system . thanks. 
07:05:33 <WendyMackaye> pastorn: i'll try reading monad examples
07:05:40 <WendyMackaye> pastorn: ah, that's nice
07:05:48 <Elko> Don't worry about ggt, it's the german abbreviation for gcd
07:06:05 <pastorn> WendyMackaye: no, read good tutorials... another one that always gets praise is "monad parsing in haskell"
07:06:24 <mauke> /usr/include/X11/extensions/Xinerama.h
07:06:46 <pastorn> WendyMackaye: that one uses some old names (so you'll probably have to ask here about why you gett the weirdest of type errors when you copy the code)
07:07:10 <Bynbo7> Elko: what's wrong?
07:07:10 <pastorn> but it's excellent
07:07:24 <WendyMackaye> i tried the baated.pdf thing
07:07:28 <WendyMackaye> baasted.pdf
07:07:36 <Botje> on OSX it's in /usr/X11/include/X11/extensions/Xinerama.h
07:07:42 <pastorn> WendyMackaye: URLz0r?
07:07:44 <Elko> Bynb07: I want to calculate the gcd of 1024 over a list of ints
07:07:54 <Elko> Bynb07: But i get an error
07:08:01 <Bynbo7> o.O
07:08:17 <pastorn> Bynbo7: what's the emoticon for facepalm?
07:08:18 <Bynbo7> that's definitely not a good thing, and should not happen if the code compiled correctly
07:08:28 <mauke> pastorn: m(
07:08:34 <Bynbo7> pastorn: for me, generally >______<
07:08:43 <pastorn> hehe
07:08:52 <co_dh> Botje: thanks. I have it there too. but cabal install xmonad complains cannot find xinerama.
07:09:09 <WendyMackaye> pastorn: i don't remember the link
07:09:11 <WendyMackaye> url
07:09:13 <Botje> you probably have to nudge it in the right direction
07:09:28 <pastorn> WendyMackaye: have you ever written any parsing code?
07:09:34 <WendyMackaye> never
07:09:40 <Elko> Bynbo7: It says "Couldn't match expected type 'a->b' against inferred type '[a1]'
07:09:42 <pastorn> do you understand what parsing means?
07:10:16 <WendyMackaye> pastorn: never
07:10:17 <Elko> when i want to execute i.e. ggt1024map [1,2,34,4]
07:10:30 <mauke> Elko: it's e.g., not i.e.
07:10:43 <mauke> Elko: also, ggt1024map expects a function as its first argument, not a list
07:10:44 <pastorn> WendyMackaye: ok, it's about the differenc between the string "123" and the number 123
07:11:08 <pastorn> WendyMackaye: if you've ever done java this maybe makes some sense:
07:11:11 <doserj> Elko: your definition of ggt1024map doesn't do what you think it does
07:11:23 <pastorn> "123" + "4" = "1234", 123 + 4 = 127
07:11:23 <Zao> Elko: http://theoatmeal.com/comics/ie
07:11:32 <WendyMackaye> ya
07:11:37 <Bynbo7> Elko: it just happens that you've given the name of one of your arguments the same name as another function you've defined
07:11:48 <Zao> tl;dr is "i.e. means 'that is'"
07:11:49 <pastorn> WendyMackaye: ok, so parsing is about reading strings into "proper" data
07:12:24 <doserj> Elko: you want: ggt1024map zu = [ggt1024 z | z <-zu]
07:12:31 <pastorn> WendyMackaye: say that we have 'data Exp = ENum Int | EAdd Exp Exp | EMul Exp Exp', to start things of simply
07:12:39 <pastorn> so when we want this to be true
07:12:39 <WendyMackaye> i have a fuzzy notion of what parsing is. taking stored data and juggling it around
07:13:03 <pastorn> parse "1 + 3" == EAdd (ENum 1) (ENum 3)
07:13:05 <mauke> WendyMackaye: taking an unstructured string and turning it into a data structure
07:13:22 <Elko> doserj: That's right. I thougt I could just put it in the mapping function to execute right for me
07:13:58 <WendyMackaye> i see
07:14:06 <Maxdamantus> > scanl (*) 1 [1..] :: [Expr]
07:14:07 <lambdabot>   [1,1 * 1,1 * 1 * 2,1 * 1 * 2 * 3,1 * 1 * 2 * 3 * 4,1 * 1 * 2 * 3 * 4 * 5,1 ...
07:14:13 <Elko> doserj: So I can just drop my first ggt1024?
07:14:21 <doserj> Elko: yes
07:14:22 <pastorn> WendyMackaye: and you often want to be able to "fail" when parsing without having your program crashing
07:14:27 <Elko> Oh,well...
07:14:35 <WendyMackaye> like in 1/0
07:14:37 <dpratt71> I use the Haskell Platform on Windows, which I gather is typical; Is this also what is typical for using Haskell on Linux platforms?
07:14:38 <pastorn> WendyMackaye: so you'll often want some sort of error control
07:14:57 <pastorn> WendyMackaye: not exactly, that one (i think) *should* make your program crash
07:14:59 <WendyMackaye> or some other faulty string
07:15:04 <WendyMackaye> oh
07:15:25 <pastorn> so if you try to parse "1 +" that shouldn't crash your program, but give you some sort of error which you can handle
07:16:25 <WendyMackaye> so how do monads do that?
07:16:39 <pastorn> WendyMackaye: that's basically what you want from a parser... you should perhaps try to write some shitty ad-hoc parsers, just to try it out
07:16:48 <Bynbo7> > 1/0
07:16:49 <lambdabot>   Infinity
07:16:52 <pastorn> WendyMackaye: in a great way, you'll see once you read the paper
07:17:27 <pastorn> WendyMackaye: ok, try this: write a function :: String -> Integer, which reads the string "12345" to the number 12345
07:17:48 <pastorn> there are functions in Data.Char to help you, namely digitToInt
07:17:59 <WendyMackaye> okay
07:18:01 <pastorn> (maybe String -> Int will make the code simpler)
07:18:20 <merijn> Don't you mean "String -> Maybe Int"?
07:18:20 <pastorn> just to get a feeling of what might be nessecary etc.
07:18:28 <pastorn> merijn: nah, not without monads
07:18:50 <dpratt71> does anyone here use Haskell on Linux? How did you choose to install it? The Haskell Platform? Build from sources? other?
07:18:53 <merijn> What's the point of "Maybe String -> Int"?
07:19:08 <pastorn> WendyMackaye: well, merijn might be right... you could do an error correction pass in beforehand and check with Data.Char.isDigit :: Char -> Bool
07:19:10 <merijn> dpratt71: I use Haskell Platform (not on linux, though)
07:19:11 <Heffalump> dpratt71: I suspect most users do. I personally install GHC from the tarball then use hackage.
07:19:38 <pastorn> dpratt71: ghc from tarball
07:19:49 <pastorn> i've never gotten the platform to work for me
07:20:42 <aristid> > sequence . transpose $ [[1,2,3],[4,5,6]]
07:20:44 <lambdabot>   [[1,2,3],[1,2,6],[1,5,3],[1,5,6],[4,2,3],[4,2,6],[4,5,3],[4,5,6]]
07:21:05 <dpratt71> ok, thanks all
07:21:06 <cdsmithus> dpratt71: You want the Haskell Platform somehow.  If your distribution packages it, great!  Otherwise, if your distribution has the right GHC version, install that and then grab the Haskell Platform.  And if not that, then you can download *all* the pieces. :)
07:23:43 <dpratt71> cdsmithus: I'm using Ubuntu atm, so I can get the platform...
07:24:05 <cdsmithus> Then that's what I'd do.  Just sudo apt-get install haskell-platform
07:24:15 <dpratt71> ...I was figuring that someone using Linux might be more inclined to build from sources
07:24:30 <pastorn> dpratt71: i do, i like the source building more
07:24:35 <Elko> doserj: GHC is putting out errors... Nothing changed! :(
07:24:46 <pastorn> dpratt71: gives me the illusion of "control" :)
07:24:54 <dschoepe> dpratt71: You can also just install ghc and cabal-install, which includes a script that will fetch and compile its dependencies
07:24:57 <pastorn> Elko: paste new code + error in comment
07:24:59 <doserj> Elko: did you adjust the type signature for ggt1024map?
07:25:16 <pastorn> dschoepe: will the cabal stuff go in ~/.cabal/ with that?
07:25:24 <dschoepe> pastorn: yes
07:25:48 <Elko> doserj: What shall it look like?
07:26:04 <dpratt71> does anyone use ghc > 6.13?
07:26:23 <pastorn> dpratt71: i tried, but you don't want yet
07:26:46 <Elko> Updated hpaste
07:26:47 <pastorn> it's all riddled with problems, old libraries that yields errors with the new standards etc.
07:26:50 <dpratt71> pastorn: don't try that Jedi mind trick on me!
07:27:20 <pastorn> dpratt71: ok, i figure you wanna be hardcore
07:27:27 <doserj> Elko: just leave the type signature out
07:27:40 <doserj> Elko: then you can check what ghc thinks it should be
07:28:04 <pastorn> dpratt71: 64-bit?
07:28:07 <dpratt71> pastorn: I'm more "firm core"
07:28:22 <dpratt71> pastorn: 64-bit, yes
07:28:51 <WendyMackaye> pastorn: a very naive version
07:29:27 <pastorn> dpratt71: $ sudo apt-get install libgmp-dev && curl http://haskell.org/ghc/dist/6.12.3/ghc-6.12.3-x86_64-unknown-linux-n.tar.bz2 | tar -xjv && cd ghc-6.12.3 && ./configure && sudo make install
07:29:34 <pastorn> that *should get you ghc
07:29:56 <pastorn> not sure if that "cd ghc-6.12.3 && ./configure" will work
07:29:58 <dpratt71> pastorn: ah, cool; too bad you can't do such things on Windows
07:30:00 <pastorn> (not that great with bash
07:30:14 <pastorn> dpratt71: i thought you were on *nix...
07:30:25 <Elko> doserj: Thanks! It works :)
07:30:46 * Elko is happy!
07:30:58 <dpratt71> pastorn: for the purposes of my question, yes I'm on *nix
07:31:05 <pastorn> dude....
07:31:37 <dpratt71> Ubuntu via Wubi
07:31:52 <pastorn> anyway, after installing ghc (i always do that system-wide) i download "cabal-install" from hackage, extract and run $ sh bootstrap.sh after installing libz-dev
07:32:10 <pastorn> then you do $ cabal update and you're rolling
07:32:22 * Maxdamantus installs ghc and cabal and everything under ~/hsr
07:32:31 <pastorn> hsr?
07:32:44 <Maxdamantus> Haskell System Resources.
07:32:57 <pastorn> it gets it own user?
07:33:03 <pastorn> you're spoiling it!
07:33:13 <Maxdamantus> I'm only one user.
07:33:14 <pastorn> oh, ~/hsr, not ~hsr
07:34:23 <dpratt71> pastorn: taking notes, thanks
07:34:49 <pastorn> that's what i always do on ubuntu every 6 months
07:35:17 <pastorn> and ghc7 isn't ready yet, especially since you can't get cabal-install to work with it without messing with grabbing the sources from the repo
07:35:27 <pastorn> and that requires you have darcs installed on your computer
07:35:34 <gwern> that isn't so bad
07:35:41 <gwern> I would be worried about everything *else* being broken
07:35:54 <pastorn> and if you want to have darcs you should grab it through cabal (unless you're a sissy and uses your package manager)
07:36:08 <pastorn> yay! dependency hell!
07:36:11 <pastorn> (almost)
07:36:36 <pastorn> so you'd need to install ghc6 to compile darcs, then use darcs to grab cabal-update, then install ghc7 etc. etc. etc.
07:36:50 <Heffalump> dpratt71: of course, you can just install the last released Haskell platform :-)
07:36:51 <gwern> or download one of the precompiled darcs like from your package manager
07:37:11 <pastorn> Heffalump: grow some chest hair
07:37:22 <WendyMackaye> pastorn: <_< not sure about this thing. i know how to do it in imperatives
07:37:24 <dpratt71> OT: I'm using Empathy for IRC (since it came 'in the box'), but I'm not digging it; I'm familiar with X-Chat, but is there something better?
07:37:26 <Heffalump> I already said what I do (install GHC from binary tarball) :-p
07:37:41 <Heffalump> and since I'm a darcs developer, I don't have any difficulty compiling darcs for myself either :-p
07:37:45 <pastorn> WendyMackaye: you might want to reverse the string
07:37:51 <Heffalump> but for a newbie, the Haskell Platform is a perfectly sensible option
07:37:56 <WendyMackaye> i thought about that -_-
07:37:58 <pastorn> WendyMackaye: can you get a [Int] with numbers 0..9?
07:38:11 <WendyMackaye> but reversing is a list spanning thing
07:38:29 <pastorn> WendyMackaye: we're not working on infinite numbers here...
07:38:38 <pastorn> @type reverse
07:38:39 <lambdabot> forall a. [a] -> [a]
07:38:55 <pastorn> reverse ['a'..'z']
07:38:55 <dpratt71> Heffalump: I'm a Succ Newbie
07:38:58 <pastorn> > reverse ['a'..'z']
07:38:59 <lambdabot>   "zyxwvutsrqponmlkjihgfedcba"
07:39:19 <merijn> Is there a reason to invest all this invert to basically reinvent "read"? >.>
07:39:30 <merijn> s/all this/all this effort/
07:39:35 <pastorn> merijn: yes
07:39:43 <gwern> 'all this effort invert'?
07:39:58 <pastorn> merijn: yes, to see what goes into parsing
07:40:09 <merijn> oh, effort turned into invert in my head, somehow
07:40:13 <pastorn> if WendyMackaye never has written any parsing code ever before, this is a very good place to start
07:40:42 <pastorn> to at least get a grasp of what is needed etc. to get interpret strings
07:42:29 <pastorn> -get
07:45:09 <pastorn> WendyMackaye: could you show what you have? (make a paste)
07:45:30 <WendyMackaye> it's stupid.
07:45:38 <pastorn> WendyMackaye: doesn't matter
07:45:52 <pastorn> just paste it, i'll give you pointers ;)
07:46:04 <Heffalump> dpratt71: it's entirely up to you. Just so you know there are easy routes available as well as doing lots yourself :-)
07:46:09 <pastorn> One simply does not cowboy code their way into haskell
07:46:16 * hackagebot extcore 1.0.1 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-1.0.1 (TimChevalier)
07:47:05 <Heffalump> pastorn: have you ever encountered undergraduate code?
07:47:19 <merijn> I never program Haskell...I just have a genetic algorithm I whipped up in python generate random code where the number of type errors produced by GHC is the fitness and I just wait until my program is written for me :>
07:52:46 <tibbe> anyone knows Christopher Kuklewicz's handle?
07:54:23 <pastorn> Heffalump: yes, but they get constant feedback
07:55:24 <hpc> merijn: :D
07:55:42 <killown>  > scanl error
07:55:45 <killown> > scanl error
07:55:47 <lambdabot>   Overlapping instances for GHC.Show.Show
07:55:47 <lambdabot>                              ([GHC....
07:56:01 * Maxdamantus will be ready when he takes that Haskell-including course in two years time.
07:56:19 <hpc> > fix error
07:56:20 <rampion> hey, quick question.  docs say Test.QuickCheck contains disjoin, but ghc complains that Test.QuickCheck doesn't export it
07:56:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:56:32 <Maxdamantus> > fix show
07:56:32 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
07:56:36 <hpc> > fix id
07:56:40 <lambdabot>   mueval-core: Time limit exceeded
07:56:49 <merijn> > fix 5
07:56:50 <lambdabot>   5
07:56:59 <hpc> :D
07:57:18 <Jafet> pastorn: unsafeLaunchWing843
07:57:48 <Maxdamantus> > fix (2*) :: Expr
07:57:49 <lambdabot>   2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (2 * (...
07:58:13 <rampion> @type disjoin
07:58:14 <lambdabot> forall prop. (Testable prop) => [prop] -> Property
07:58:18 <pastorn> Jafet: huh?
07:59:03 <Saizan> rampion: different version?
07:59:13 <hpc> ^
07:59:25 <hpc> especially if you are using the debian repo version
07:59:35 <hpc> which is routinely about a year older than the head
08:00:00 <rampion> I'm running ghc v6.12.3
08:00:11 <Jafet> Launches the wing without an executive order, while the process is still under evaluation
08:00:40 <hpc> rampion: different version of the package, not ghc
08:00:45 <rampion> ah
08:00:48 <hpc> unless quickcheck comes with base
08:01:38 <rampion> latest is 2.4, I'm at 2.1
08:01:44 <rampion> good place to start, thanks!
08:03:06 <rampion> perfect!
08:04:31 <cole> When I do cabal install wx I get "cabal: Error: some packagines failed to install: wx-0.12.1.6 depends on wxcore-0.12.1.6 which failed to install wxcore-0.12.1.6 failed during the configure step." What' wrong?
08:04:51 <Zao> cole: Do you have wx libraries installed?
08:04:54 <vikeshraj> Hi, I am trying to use handle function to handle exceptions in IO
08:05:03 <vikeshraj> http://hpaste.org/43052/handle_ghc_error
08:05:05 <Zao> cole: You can cabal unpack wxcore, and then try building from inside the directory.
08:05:05 <cole> Don't think so.
08:05:13 <Zao> It might give you more exhaustive errors.
08:05:23 <vikeshraj> ghc throws error about types missing
08:05:38 <vikeshraj> I believe I am missing some ghc option for this
08:09:23 <Bynbo7> killown: you need to specify what type e is there, if you put let _ = e :: SomeException in return Nothing then it should work
08:09:27 <Reemo> Hey guys, I'm learning Haskell at the moment and wondered if someone could take a look at this function i wrote and tell me whether this could be done more easily (http://hpaste.org/43053/permutate)
08:10:33 <cole> What is the difference between the packages "wx" and "wxcore"?
08:10:47 <Zao> cole: The former builds on the latter, assumedly.
08:10:55 <Bynbo7> Reemo: well, for one, join lists is just concat
08:11:20 <Zao> cole: I'd expect that wxcore is a low-level binding and wx makes it more Haskellic.
08:11:22 <cole> wx is a superset of wxcore?
08:11:45 <Bynbo7> Reemo: also, all the things that have been provided by hlint are useful to read too
08:11:54 <Reemo> Bynbo7, yepp just read them
08:12:21 <Zao> cole: Or wx builds on wxcore, providing more high level abstractions or additional functionality.
08:12:34 <Bynbo7> > filterM (const [True,False]) [1,2,3]
08:12:35 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
08:12:42 <Bynbo7> hmm
08:13:44 <Reemo> Bynbo7, the thing is: this was a test assignment from 2002 for which you had about 15 minutes. I wondered if theres another way since i spent like 2 days working on it
08:13:55 <Reemo> And usually I'm quite fast in writing algorithms
08:14:04 <Berengal> How much memory-overhead does a boxed value have?
08:14:23 <Bynbo7> Berengal: something like 16 bytes i think
08:14:35 <Bynbo7> there's a pointer, and some other stuff
08:15:03 <Berengal> Bynbo7: So that would mean that the size of a string is something like 36 times the number of characters?
08:15:16 <Bynbo7> Berengal: roughly, yes
08:15:23 <Berengal> No, wait, the conses have pointers too
08:15:36 <Berengal> So 44...
08:15:46 <Berengal> (or 52)
08:16:50 <fryguybob> Is there a name for: do f <- e; x <- a; return (f x)
08:17:02 <mauke> ap
08:17:10 <fryguybob> mauke: thanks
08:18:48 <Jafet> @pl \e a -> e >>= \f -> a >>= x -> return (f x)
08:18:49 <lambdabot> (line 1, column 29):
08:18:49 <lambdabot> unexpected ">" or "-"
08:18:49 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
08:18:58 <Jafet> @pl \e a -> e >>= \f -> a >>= \x -> return (f x)
08:18:59 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
08:19:20 <Jafet> Splendid
08:20:32 <fryguybob> Jafet: Ha, I had just tried that.
08:20:49 <mauke> :t \e a -> do f <- e; x <- a; return (f x)
08:20:50 <lambdabot> forall (m :: * -> *) b t. (Monad m) => m (t -> b) -> m t -> m b
08:20:56 <mauke> @hoogle (Monad m) => m (t -> b) -> m t -> m b
08:20:57 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
08:20:58 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
08:20:58 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:21:08 <fryguybob> @. hoogle type \e a -> do f <- e; x <- a; return (f x)
08:21:09 <lambdabot> Parse error:
08:21:09 <lambdabot>   --count=20 "forall (m :: * -> *) b t. (Monad m) => m (t -> b) -> m t -> m b
08:21:09 <lambdabot> "
08:21:13 <fryguybob> :(
08:22:15 <cole> I've successfully installed "wx" unfortunately, when I try to run a simple program I get "unknown symbol '__dso_handle' unable to load package 'filepath-1.1.0.4'
08:23:13 <Reemo> Bynbo7, can you give me a hint on how to generify this method? I mean basically it should work for every type that is comparable
08:25:33 <svdberg> 
08:29:32 <developernotes> I'm trying to run the following in ghci, but I get a parse error on data: http://pastie.org/1463819, any thoughts?
08:29:57 <ben> Last I checked you cannot have Data definitions in ghci
08:30:06 <ben> err, data.
08:30:12 <Bynbo7> you can't
08:30:22 <developernotes> hmmm...gotcha, bummer
08:30:27 <developernotes> thanks
08:30:31 <ben> Basically only expresions and let foo = bar lines, and import, and ghci : commands
08:30:44 <developernotes> ben: ok, thanks
08:34:52 <alpounet> developernotes, generally, people write data definitions in some .hs file and load it (using :l yourfile.hs) from ghci
08:35:17 <developernotes> alpounet: ok, thans
08:35:23 <developernotes> alpounet: thanks
08:38:38 <McManiaC> is there *any* way to distinquish two pure functions with the same value in haskell? something like http://npaste.de/uX/
08:39:04 <Jafet> McManiaC: ...those aren't functions
08:39:19 <McManiaC> definitions
08:39:31 <alpounet> McManiaC, with pure values
08:39:32 <McManiaC> data types
08:39:33 <alpounet> no you can't
08:39:58 <Jafet> GHC lets you take stablenames, but they are governed by different semantics
08:40:12 <alpounet> or, well, maybe you can in some hacky way, but that's not recommended to try to distinguish them
08:40:15 <Jafet> Anyway, what you're asking for isn't usually sensical
08:40:19 <alpounet> they represent the exact same thing
08:40:28 <alpounet> so why treat them differently ?
08:40:58 <Jafet> He's probably expecting implementations to represent them in some fixed way, and wants to grab that representation
08:41:10 <Jafet> Of course, the point of a pure language is that they don't have to.
08:41:20 <McManiaC> they might e.g. represent a unique window in a GUI application
08:41:25 <alpounet> no
08:41:27 <alpounet> since they're pure
08:42:21 <alpounet> having GUI code outside of IO would be quite bad
08:42:22 <Jafet> If two Window values are the same, then they should be the same window.
08:42:48 <Jafet> This follows directly from considering the semantics of windows, you don't need to think about IO or anything
08:42:59 <Jafet> That is, the semantics of Windows to windows
08:43:08 <McManiaC> hmhm
08:43:13 <warrenharris> question about heap profiling... my profile is showing a huge build-up of ->>(#,#) values -- what are these?
08:44:05 <Jafet> warrenharris: unboxed pairs
08:44:26 <Jafet> I think
08:44:30 <warrenharris> is there a way to find out who's allocating them?
08:44:45 <McManiaC> other question: is there something like a "state" for template haskell? so if I would call one template haskell function twice in the same document I could have something like a counter?
08:44:56 <Jafet> The heap profiler probably lets you find out those things, read the manual
08:45:01 <aavogt> McManiaC: yes, TH is allowed IO
08:45:17 <aavogt> @hoogle runIO
08:45:18 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
08:45:18 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
08:45:18 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
08:46:08 <McManiaC> aavogt: it still would require some unsafePerformIO or sth, wouldnt it?
08:46:25 <McManiaC> to have a "global state variable"
08:46:45 <savask> Hi, can you help me with this function http://hpaste.org/43054/maxf_function ? (I'm only learning) GHCI says: "Occurs check: cannot construct the infinite type: b = Maybe b"
08:47:30 <warrenharris> Jafet: another question -- the .prof file is showing me a huge amount of information from the Parsec package, but little else. I've built everything with profiling enabled. Is there something special about parsec?
08:47:35 <Jafet> McManiac: not really, you just admit a system where Q a values are not necessarily pure
08:47:53 <Jafet> McManiac: which TH readily does for pragmatic reasons
08:48:24 <Jafet> warrenharris: well, you might be writing your parsers in an inefficient style
08:48:41 <Jafet> I don't know that much about parsec or its space usage to help you
08:48:56 <warrenharris> ok - any pointers on efficient parsec style?
08:49:15 <doserj> savask: in (f x) > (maxf f xs), the right hand side is a maybe value. you have to unpack that first before you can compare it with f x
08:49:32 <savask> Ah.
08:49:44 <savask> How?
08:49:44 <Jafet> In parsec's case, avoiding lookahead helps
08:50:05 <warrenharris> I have no lookahead
08:51:59 <doserj> savask: just use a helper function like f (Just x) = x. And think about what happens if maxf f xs is Nothing (that cannot happen in your case, but you should understand why)
08:52:33 <savask> doserj: Aha, thanks. I'll try.
08:52:45 <Jafet> Also preferring LL type to LR or LALR, I think
08:53:03 <Philippa> yeah, parsec's fundamentally LL in nature
08:54:25 <warrenharris> Jafet: thanks
08:56:01 <aavogt> McManiaC: well maybe you can get around that unsafePerformIO by putting the   runIO . newIORef in a different module. Either way it's not a big deal
09:08:01 <McManiaC> can anyone give me quick tip on how to get that `v` in there? kinda rusty with TH: ttp://npaste.de/uY/
09:08:11 <McManiaC> http://npaste.de/uY/
09:09:33 <McManiaC> hm nevermind
09:09:34 <McManiaC> :D
09:09:41 <McManiaC> TH doesn't like the "a"
09:10:10 <aavogt> @hoogle lift
09:10:11 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
09:10:11 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
09:10:11 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
09:10:45 <aavogt> McManiaC: you use the last lift there. But it's also implicit if you have     let x = 5 in [| x + x |]  -- I think
09:12:53 <McManiaC> aavogt: thx
09:17:11 <IanCal> Hi. I'm a little confused about datatypes. I'm writing a little expression parser( (a + 3) * (4 + 7) etc  ), starting with the internal representation. Code and error here: http://hpaste.org/paste/43057/datatype_confusion_in_simple_a
09:17:51 <aavogt> IanCal: the two  Value you've defined are different
09:17:52 <Odd_Bloke> Hello all.  I'm teaching myself Haskell using http://learnyouahaskell.com.  I've reach the lists part, and am puzzled by the fact that "[3,2,1] > [2,10,100]" evaluates as True.  Is this because 3>2 returns True and so the rest of the lists are not compared?
09:17:54 <IanCal> I thought that since Expr could be a Value, the types would just sort of work. I might be completely on the wrong path here though
09:18:06 <IanCal> aavogt: ah right
09:18:08 <mauke> IanCal: Value is a value of type Expr
09:18:15 <aavogt> you could write        data Expr = ....  | Values Value
09:18:38 <mauke> Odd_Bloke: yes
09:18:56 <alpounet> Odd_Bloke, yes, the > operator on lists compares the head first, and if they're equal then the second element of both lists, etc
09:19:05 <mauke> Odd_Bloke: same reason that "cab" comes after "aye" in the dictionary
09:19:11 <IanCal> I'd understood it as "Value is an Expr, so Constant is a Value and Expr"
09:19:17 <alpounet> > [1,2,3] < [4,5,6] 
09:19:18 <lambdabot>   True
09:19:37 <alpounet> > [1,4,5] < [1,2,3] -- Odd_Bloke 
09:19:38 <lambdabot>   False
09:19:40 <mauke> IanCal: values are not types
09:20:43 <IanCal> mauke: Oh ok. Seems I'm using the wrong things here! I'll go and have more of a read though LYAH.
09:20:46 <IanCal> thanks :)
09:21:04 <mauke> data A = B -- defines B
09:21:14 <mauke> this is unrelated to any type called B that may also exist
09:22:05 <IanCal> ahhhh that would certainly explain why that wasn't working
09:22:51 <IanCal> theres a haskell.org tutorial on values and types. Thanks for the terminology, I'm slowly learning the right words to be able to find help
09:27:08 <kolmodin> I've got a bunch of quickcheck tests. which test driver should I use?
09:29:33 <kolmodin> HTF, testrunner, test-framework ?
09:34:41 <warrenharris> question about STM: does it work on a multiprocessor or only a uniprocessor (concurrent, not parallel)?
09:35:36 <tibbe> warrenharris: multiprocessor I think
09:37:21 <warrenharris> just wondering because it's package name contains Concurrent 
09:37:43 <warrenharris> wasn't clear from the docs whether it was smp safe
09:38:27 <tibbe> warrenharris: it definitely is
09:38:37 <tibbe> warrenharris: it's a step up from MVars
09:38:50 <warrenharris> i.e. it used mvars under the covers?
09:38:55 <Philippa> warrenharris: that's not actually what 'concurrent' means in this context
09:38:57 <warrenharris> uses
09:39:30 <Philippa> concurrent is /allowed/ to run on one processor because it's "semantically concurrent", but it runs on a multithreaded runtime if you use -threaded
09:39:32 <warrenharris> I'm wondering about attempting to use it in conjunction with Snap
09:39:35 <tibbe> warrenharris: it doesn't it uses optimistic concurrency with a log
09:39:41 <McManiaC> aavogt: I'm trying something like this, do you think that is possible somehow? the only "state" function I see in Q is aout that Name stuff, and I feel kinda dirty to "misuse" that for my counter :)
09:39:45 <McManiaC> aavogt: http://npaste.de/uZ/
09:40:02 <tibbe> warrenharris: it will work fine on SMP, just us it and remember to compile with -threaded
09:40:12 <warrenharris> tibbe: thanks!
09:41:03 <tibbe> warrenharris: it has some performance cost. if you only need to synchronization a single datum use MVars (or better yet, IORef with atomicModify IORef)
09:41:03 <aavogt> McManiaC: well as posted it doesn't work
09:41:25 <aavogt> McManiaC: ghc won't run the StateT for you
09:41:38 <warrenharris> ok
09:42:06 <aavogt> McManiaC: you can also look at Data.Unique which hides some unsafePerformIO
09:42:18 <tibbe> warrenharris: check out #snapframework
09:43:06 <tibbe> warrenharris: one of the main authors is out for dinner at the moment but maybe someone else there could help you out
09:43:24 <warrenharris> ok, thanks
09:46:01 <McManiaC> aavogt: Segmentation fault/access violation in generated code
09:46:08 <McManiaC> when trying to use Data.Unique :O
09:48:48 <jamii> mmmm, hacker cup is full of fail
09:51:11 <McManiaC> I think I have a feature request for template haskell :>
09:53:29 <cole> is there some was using either cabal or ghci to list all the currently installed modules?
09:53:36 <aavogt> McManiaC: no, you can properly have global state in TH
09:55:56 <kuffaar> cole ghc-pkg list
09:57:13 * hackagebot word24 0.1.4 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-0.1.4 (JohnLato)
09:59:58 <McManiaC> aavogt: how??
10:00:28 <McManiaC> in the IO part, but how can I pass that around without having the user to do that by hand?
10:00:28 <kuffaar> <McManiaC> aavogt: Segmentation fault/access violation in generated code
10:00:29 <_vlad> @help
10:00:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:00:32 <kuffaar> I get that with cabal install
10:00:37 <kuffaar> Randomly
10:00:41 <_vlad> @list
10:00:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:01:08 <aavogt> McManiaC: well I dunno if Data.Unique works with TH. I guess it doesn't. But IORefs work
10:01:19 <_vlad> @djinn a ? p -> (q -> p)
10:01:19 <lambdabot> Cannot parse command
10:01:51 <McManiaC> aavogt: but I have no where to "store" that IORef
10:01:54 <McManiaC> aint I?
10:05:53 <deech> I was reading Data.Monoid and Endo is called "the monoid of endomorphisms under composition". Is an endomorphism just a function of type "a -> a"?
10:07:51 <alan_> hey! can anyone help me with haskell
10:07:59 <deech> alan_: Sure 
10:08:54 <alpounet> deech, an endomorphism is just a morphism from <somewhere> to itself, yes
10:09:07 <alan_> deech : I need to check if a list is in a Zig Zag form. like [],[3],[2,1,4],[1,5,2,6,2,8] are in ZigZag form
10:10:00 <alan_> deech: that is what I thought http://codepad.org/3NrPb5pX
10:11:10 <deech> alan_: The error message is because you haven't defined a main function. Load the file in to GHCI and to test the function. I'm looking at it now.
10:11:32 <alan_> deech: but I have a problem. for [5,3],[5,3,4,1,3] and [5,3,4,1,3,2,8,1] haskell tells that  Non-exhaustive patterns in function isZigZag
10:12:06 <alan_> deech: I have already done it. it works but I have a problem
10:12:19 <deech> alan_: Whats the problem?
10:12:34 <alan_> deech:  for [5,3],[5,3,4,1,3] and [5,3,4,1,3,2,8,1] haskell tells that  Non-exhaustive patterns in function isZigZag
10:12:38 <deech> alan_: didn't see your previous message.
10:12:47 <merijn> alan_: But the pattern match is non exhaustive as far as I can tell
10:13:14 <merijn> I see empty list, list of one element and list of four or more elements
10:13:34 <merijn> I don't see a list of 2 or 3 elements pattern
10:14:43 <deech> alan_: Which isZigZag equation would be invoked in the case [5,3],[5,3,4,1,3]?
10:16:06 <deech> alan_: Perhaps something like isZigZag [x] = error "only one element" and isZigZag (x:y:[]) = error "only two elements"
10:16:30 <deech> Of course in this case the length of your list has to be a multiple of 3.
10:16:43 <alan_> deech: no. for [x] it should say True
10:16:55 <merijn> alan_: I think the main problem is that isZigZag [_] does not do what you think?
10:17:15 <deech> alan_: ok, then isZigZag [x] = True
10:17:20 <merijn> [_] == _:[]
10:17:35 <aristid> @oeis 0,1,3,6
10:17:37 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
10:17:37 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
10:17:55 <aristid> yay for oeis
10:18:08 <alan_> merijn: yeah... it matches [3] is True
10:18:41 <alan_> deech : I just dint understand why it doesnt match [5,3],[5,3,4,1,3]
10:18:43 <merijn> alan_: Yes, but if you call "isZigZag [5,3]" which case do you expect it to match?
10:18:49 <alan_> deech : should I write one more defintion
10:19:17 <deech> alan_ : yes. Although you're better off using function guards.
10:19:36 <merijn> alan_: [] is for empty lists, [_] matches lists containing one item and [x:y:z:xs] matches lists of four or more items. [5,3] is a list of two items, you have no pattern for that
10:19:51 <aavogt> McManiaC: it segfaulted with the unsafePerformIO?
10:20:04 <Jafet> You mean (x:y:z:xs) matches lists of three or more items?
10:20:35 <Zao> [x:y:z:xs] matches a list of list of three or more items.
10:20:36 <alan_> merijn: yeah. I got that. but for 8 elemnts I dont have as well. and foe some more amount of elements. shoul I write for them all definitions&
10:20:46 <lelf> > let (x:y:z:rest) = [1,2,3] in rest
10:20:48 <lambdabot>   []
10:20:51 <merijn> Jafet: Whoops, counted the empty list as an item in the last one which is inconsistent with the rest of my explanation...
10:20:56 <Zao> (well, list of a single list of 3+ items)
10:21:03 <monochrom> consider also [[[x:y:z:rest]]] :)
10:21:13 <Zao> Note the difference between (x:y:z:xs) and [x:y:z:xs]
10:21:35 <monochrom> [[[[x:[y]]:z:rest]]]
10:21:41 <merijn> alan_: No, 8 items is matched by (x:y:z:xs), the first three will be x, y and z and the remaining 5 items will be in xs (which you then call isZigZag on again)
10:21:47 <Zao> @type [?x : ?y : ?z : ?xs]
10:21:48 <lambdabot> forall a. (?xs::[a], ?z::a, ?y::a, ?x::a) => [[a]]
10:21:51 <Zao> @type (?x : ?y : ?z : ?xs)
10:21:52 <lambdabot> forall a. (?xs::[a], ?z::a, ?y::a, ?x::a) => [a]
10:22:08 <Jafet> [[x]:(y,z):xs]
10:22:24 <merijn> alan_: List of five will match (x:y:z:xs) again, resulting in xs being a list of 2 items (and since you have no isZigZag for 2 items it will complain again)
10:22:41 <merijn> alan_: See where this is going?
10:22:54 <alan_> merijn: yeah. I got it
10:23:08 <monochrom> this is going to a program with infinitely many lines of code :)
10:23:16 <merijn> monochrom: Why?
10:23:22 <deech> alan_: Check out http://codepad.org/0UQc7rU5
10:23:26 <monochrom> write one line for each special case
10:23:28 <merijn> monochrom: It is going to a program with 2 more lines of code...
10:24:17 <monochrom> write one line for each list length
10:24:29 <Jafet> Write it in template haskell and surprise your instructor with O(1) complexity!
10:24:49 <Jafet> Plus you don't need to buy an infinitely long tape.
10:25:00 <merijn> Couldn't you just do that in the type system directly?
10:25:16 <monochrom> template your type system too
10:25:22 <merijn> Encoding list length in the type system, etc
10:25:39 <aavogt> that's what SHE does!
10:25:43 <Jafet> If your oleg number is less than four, yes
10:25:54 <merijn> How do I obtain an Oleg number? :p
10:26:07 <monochrom> by passing the oleg test
10:26:09 <alan_> deech:ok... but why donest this one work http://codepad.org/2e6PAZ6L
10:26:17 <Jafet> Unfortunately, oleg isn't that prolific a coauthor I think
10:26:21 <merijn> I was at the Dutch FP day, I think we reached at least several deci-Olegs in some of the talks...
10:26:27 <Jafet> But if he was, the threshold would be two
10:26:37 <beastaugh> publish something with someone who is in the transitive closure of publishing with Oleg
10:26:52 <beastaugh> (presumably)
10:26:56 <merijn> alan_: Because of this:
10:27:03 <merijn> > [2] == 2:[]
10:27:04 <lambdabot>   True
10:27:07 <merijn> > 2 < []
10:27:08 <lambdabot>   No instance for (GHC.Num.Num [a])
10:27:09 <lambdabot>    arising from the literal `2' at <inter...
10:27:18 <Jafet> Perhaps if you considered being in the same cafe thread as him to be coauthoring
10:27:33 <monochrom> haha
10:27:56 <alan_> merijn: oh. yeah. again the first matching. yea. now I got it really%))
10:27:57 <merijn> alan_: So [2] matches you (x:y) pattern, but comparing to the empty list is an error
10:28:11 <monochrom> writing (x:y) doesn't automatically make y a number.
10:28:21 <monochrom> so much for meaningful identifiers.
10:28:45 <merijn> alan_: If you use (x:[]) and (x:y:[]) as patterns instead of (x:y) it *should* work
10:29:00 <aavogt> > let xs:x = "hi" in xs
10:29:01 <lambdabot>   'h'
10:29:28 <monochrom> Let h be a group and G be an automorphism of h...
10:29:36 <merijn> alan_: http://codepad.org/P7totjcl
10:30:11 <merijn> On unrelated note, I dislike [_] as a pattern
10:30:15 <locholmez> im a newb.. how can i define a list comprehensions output function with pattern matching?
10:30:20 <alan_> merijn: yep. I tried it already
10:30:26 <deech> It's kinda nice of codepad to run your potentially unsafe code.
10:30:26 <alan_> thanks you all
10:30:56 <merijn> deech: They have an article about their sandboxing somewhere I think
10:31:27 <merijn> Lambdabot also executes potentially unsafe code and it doesn't get compromised that often anymore :p
10:31:46 <deech> merijn: Maybe session gets its own virtual machine? That would be cool :)
10:32:01 <monochrom> > [ case x of { Nothing -> False; Just _ -> True } | x <- [Nothing, Just (), Just ()] ]
10:32:03 <lambdabot>   [False,True,True]
10:32:10 <Jafet> codepad uses ptrace in a chroot, that's all.
10:32:13 <merijn> deech: On FreeBSD it'd be very cheap and easy to fork of all code into its own jail
10:32:18 <alpounet> merijn, it's at http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
10:32:59 <merijn> And once it is in its own jail its reasonably safe to execute untrusted code. ptrace + chroot is begging for trouble, though
10:33:34 <deech> Would be nice if there were different levels of the IO monad (ReadOnlyIO, ReadWriteIO ...). 
10:33:36 <Jafet> What kind of trouble?
10:33:56 <merijn> Jafet: Dunno, but I'm sure someone can find some :p
10:34:38 <Jafet> There's a C++ bot named geordi you can try to exploit right now, its supervisor code is the basis for codepad
10:34:50 <Jafet> It's also written in haskell
10:35:32 <deech> Jafet: You can bind Haskell and C++?
10:35:56 <lelf> ?faq You can bind Haskell and C++?
10:35:56 <lambdabot> The answer is: Yes! Haskell can do that.
10:36:03 <aristid> @hoogle m () -> Bool -> m ()
10:36:03 <Tomsik> > nil undefined
10:36:04 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
10:36:04 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
10:36:04 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
10:36:04 <lambdabot>   Not in scope: `nil'
10:36:10 <Tomsik> > null undefined
10:36:11 <lambdabot>   *Exception: Prelude.undefined
10:36:11 <Jafet> You can write a haskell program to invoke a C++ compiler and execute the resulting program.
10:36:18 <Tomsik> > null (undefined:[])
10:36:18 <lambdabot>   False
10:36:29 <deech> Oh I was thinking through the C FFI.
10:36:30 <monochrom> onoes, c++ bot written in haskell, the impossible has just happened!
10:37:13 <monochrom> this is good information for next time someone asks "where is haskell used?"
10:37:44 <Jafet> "You can execute remote code over the internet, as long as you do it with haskell"
10:38:10 <deech> This is an impossibly broad question, but as a relative Haskell newbie how hard is it to write a Haskell binding to Java? I'm not a Java newbie.
10:38:24 <kmc> not hard, just a pain in the ass
10:38:44 <beastaugh> http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages#Java
10:38:50 <kmc> you can export functions  to C with FFI and call them with JNI
10:38:52 <monochrom> haskell to c (ffi), c to java (jni)
10:38:52 <kmc> or vice versa
10:38:59 <Jafet> That sounds unsatisfying
10:39:00 <kmc> might i recommend instead some kind of RPC protocol
10:39:20 <monochrom> theoretically one day someone will do a haskell-java ffi.
10:39:58 <Jafet> Success by osmosis?
10:40:46 <Reemo> Can someone recommend assignments i can do to dive into Haskell?
10:41:10 <deech> beastaugh: The latest release from LambdaVM is in 2007. The JNI link is dead.
10:41:13 <monochrom> indeed the haskell 2010 report contains "callconv -> ccall | ... | jvm | dotnet"
10:41:38 <Jafet> Reemo: haskell has no assignments!
10:41:39 <ddarius> monochrom: Someone will write a song which, interpreted in a simple manner, can be viewed as the machine code to a Haskell to Java interface builder.  Unfortunately, the machine code will be for the PDP-10.
10:41:40 <deech> Reemo: Write a Java FFI? 
10:41:41 <beastaugh> deech: might be an idea to update the wiki then :)
10:41:59 <Reemo> Jafet, no assignment as in "practices"
10:42:10 <deech> beastaugh: Yes, good idea :).
10:42:22 <Reemo> deech, pass ;)
10:42:32 <Jafet> Haskell books have exercises.
10:43:05 <monochrom> tryhaskell.com is a set of exercises
10:43:09 <Jafet> Past that, convince yourself that haskell is general-purpose by doing whatever you want in it
10:43:21 <Jafet> RWH is a good place to start
10:43:45 <monochrom> but generally "dive in" results in head injuries only
10:43:59 <deech> Reemo: Write some shell scripts?
10:44:20 <deech> Reemo: Write some CGI scripts - if web programming is your bag?
10:44:34 <Reemo> monochrom, I usually learn some aspects better by stumbling upon them while practicing
10:44:56 <monochrom> yes I know. doesn't matter.
10:45:01 <Jafet> Not if you dive in to immersed manifolds
10:46:56 <kmc> i wouldn't count on ever getting the "jvm" calling convention supported by GHC
10:47:13 <deech> kmc: Why?
10:47:16 <kmc> *shrug*
10:47:19 <kmc> hacking on GHC is hard
10:47:19 <alpounet> haha
10:47:30 <kmc> however you could write a stand-alone wrapper generator which generates all the JNI / FFI boilerplate
10:47:37 <alpounet> supporting the LLVM one was hard enough
10:47:37 <kmc> perhaps using Java introspection to discover the APIs to wrap
10:47:51 <kmc> alpounet,  i don't mean a JVM backend
10:48:00 <kmc> if someone wrote this wrapper generator, a lot of people would use ti
10:48:01 <monochrom> you could count on the fact that both jvm and ghc have been in existence for a decade and still no ghc support of jvm, and extrapolate the future.
10:48:21 <companion_cube> haskell without tail call would be hard to implement
10:48:30 <companion_cube> (i suppose)
10:48:32 * hackagebot monad-param 0.0.4 - Parameterized monads  http://hackage.haskell.org/package/monad-param-0.0.4 (DominiqueDevriese)
10:49:35 <deech> monochrom: In Missouri IT seems to run on the JVM. It's hard to sell the awesome C FFI because people are wedded to Java.
10:50:29 <deech> kmc: That's a great idea. I'll look into it.
10:50:49 <monochrom> I wonder why that's directed at me.
10:51:37 <kmc> companion_cube, a JVM backend could do tail calls  the same way the unregisterised C backend does
10:51:49 <deech> Just echoing your last comment "you could count ..."
10:51:53 <deech> Not arguing.
10:52:08 <kmc> there are several ways described to implement tail calls on JVM; all have performance penalties though
10:52:25 <companion_cube> like trampolines ?
10:52:29 <kmc> which is why Clojure has an explicit tail-call construct and doesn't optimize the common case
10:52:35 <kmc> yeah
10:52:46 <companion_cube> mutual tail-call is the hard part
10:53:39 <ddarius> monochrom: I've been in existence for 26 years.  I extrapolate that I will never become 27.
10:54:18 <monochrom> Non-zero probability that it comes true, sadly.
10:54:49 * ddarius doesn't know why the "sadly" is there.
10:55:10 <Ke> you'll know, when you turn 27
10:55:12 <dolio> Opposite of "happily".
10:55:19 <monochrom> because if you will not become 27, I will miss you.
10:55:26 <j-invariant> ddarius: whdy do you extrapolate that/
10:55:26 <j-invariant> ?
10:55:30 <tg_> monochrom: though if you don't start with the Earth-Sun system in your estimate, it's pretty damn close to 0 that one lives 27 years.
10:57:55 <j-invariant> hello
10:59:09 <BMeph> ddarius: As in "non-zero prob. of you not becoming 27." Unless you just don't want to become 27, which is a different proposition altogether.
10:59:53 <alan_> I have one more small question
10:59:59 <alan_> =)
11:00:17 <BMeph> alan_: Are congratulations in order? ;)
11:01:27 <alan_> BMeph: sorry??
11:01:45 <monochrom> congratulations for one more small question
11:01:59 <Jesin> hmm, so, (.) is defined in GHC.Base like this:
11:02:05 <alan_> щр
11:02:07 <alan_> oh
11:02:08 <alan_> hahah
11:02:09 <Jesin> {-# INLINE (.) #-}
11:02:09 <alan_> ok
11:02:10 <Jesin> (.)    :: (b -> c) -> (a -> b) -> a -> c
11:02:12 <Jesin> (.) f g = \x -> f (g x)
11:02:32 <Jesin> and that's re-exported by Prelude
11:02:35 <Jesin> I'm wondering
11:02:37 <Zao> @src (.)
11:02:38 <lambdabot> (f . g) x = f (g x)
11:02:38 <lambdabot> NB: In lambdabot,  (.) = fmap
11:02:42 <Jesin> in Control.Category
11:02:52 <Jesin> instance Category (->) where
11:02:54 <Jesin>         (.) = (Prelude..)
11:03:08 <Jesin> does the INLINE pragma from the GHC.Base definition of (.)
11:03:39 <Jesin> have the same effects if you use the (Control.Category..) definition with (->)?
11:03:55 <alan_> so, the signature of thus function f (x,y,z) = (x,[1..y], x++[z])	  is f :: ([a],b,a) -> ([a],[b],[a])     ?
11:03:59 <Jesin> does it get inlined under the same circumstances?
11:04:35 <Tomsik> they say that ghc inlines very aggressively 
11:04:37 <Jesin> I mean, even though Control.Category contains no INLINE pragma
11:04:42 <dolio> That signature isn't enough.
11:05:08 <dolio> f :: (Num b, Enum b) => ([a],b,a) -> ([a],[b],[a]), probably.
11:05:11 <monochrom> I'm pretty sure "[1..y]" causes more constraints on the type, like Enum b, there may be more
11:05:13 <Jesin> :t \(x,y,z) -> (x,[1..y], x++[z])
11:05:14 <lambdabot> forall t t1. (Num t, Enum t) => ([t1], t, t1) -> ([t1], [t], [t1])
11:05:40 <alan_> ohh cool
11:05:48 * BMeph declares dolio the winner!
11:09:10 <alan_> but why do you have to declare as well Num b if Enum b contains already everyhting that Num has
11:09:15 <Jesin> so, in any case where a function is defined as simply
11:09:25 <Jesin> somefunction = anotherfunction
11:10:03 <Jesin> then anotherfunction gets effectively substituted in for somefunction everywhere, and all the pragmas work the same?
11:10:09 <dolio> Enum b does not contain everything that Num does.
11:10:10 <Jesin> even where somefunction is in an instance?
11:11:13 <alan_> dolio: ok.. but how did you know that Num b and Enum b should be
11:11:31 <monochrom> "1" induces the Num part. ".." induces the Enum part.
11:11:40 <mreh> how do I see what modules are in scope?
11:11:56 <joe6> guys: i asked this question yesterday night when the traffic was slow and did not get much response, hence asking again.
11:11:57 <alan_> monochrom:ok. thanks !!
11:12:23 <joe6> if you had a choice between using parsec vs read(serialization) for reading a config file. Which would your prefer?
11:12:34 <joe6> I have an input data file whose format I control
11:12:36 <kmc> parsec
11:12:41 <joe6> oh, ok.
11:12:51 <kmc> Read sucks in about ten ways
11:13:00 <kmc> if your config file is actually Haskell code then you can use "dyre" instead
11:13:10 <Jesin> hmm
11:13:18 <joe6> I could make the config file into haskell code.
11:13:21 <kmc> though, if the goal is just "get something working fast", Read is a perfectly acceptable choice
11:13:26 <kmc> joe6, it's  how xmonad works
11:13:28 <joe6> will check out dyre. Thanks a lot for the suggestion
11:13:34 <kmc> and xmonad is even used by some people who don't know haskell!
11:14:29 <monochrom> actually I use read
11:14:36 <Jesin> would something like this make sense btw?
11:14:37 <joe6> i have the parsec implementation and the data file is line based. But, in my next version, I want to make it better, hence the question.
11:14:47 <Jafet> kmc: that blissful innocent state never lasts
11:14:59 <Jafet> It's antistable
11:15:00 <kmc> hehe
11:15:10 <Jesin> (Category cat) => instance Functor (cat a) where fmap = (.)
11:15:29 <Jesin> or whatever rearranging has to be done to make that parse...
11:15:42 <monochrom> my "config" is just "data X = X UTCTime String" so I just "deriving (Read,Show)". zero insertion effort.
11:16:08 <Eelis> is there a wildcard analogue for types? i'd like to say:    x :: [_]; x = something   to make it clear that x is to be a list, but without having to spell out the element type
11:16:43 <kmc> Eelis, not in standard Haskell or GHC, unfortunately :/
11:16:49 <Eelis> kmc: ok :( thanks
11:16:51 <kmc> there are some oleg hacks to get it
11:16:56 <Eelis> oh, interesting
11:16:56 <kmc> i think UHC supports basically that
11:17:04 <kmc> x = something `asTypeOf` []
11:17:04 * Eelis googles UHC
11:17:32 <Twey> You could also just write [a]…
11:17:52 <Eelis> Twey: no, in my cast x is actually of type  [Some Really Complicated Type]
11:17:55 <kmc> Twey, but that fails if it turns out to be less general
11:17:56 <Eelis> *case
11:17:57 <kmc> right
11:18:08 <kmc> iow you want to introduce a unification variable, not a variable to be quantified over
11:18:16 <Eelis> exactly
11:18:29 <Jafet> oleg has the partial type signature trick
11:18:30 <Twey> Ah
11:18:37 <Eelis> or in still other words, an existential rather than a universal quantification
11:19:05 <Jafet> f x where f :: forall a. Whatever a -> Whatever a; f x = x
11:19:50 <joe6> kmc: the config file that I am talking about is more of a data file. I am reading up on dyre and it seems to be geared towards config files.
11:20:04 <joe6> kmc: it appears that parsec is my best bet. would you concur?
11:20:44 <kmc> what are your requirements?
11:20:58 <monochrom> I concur with everything.
11:21:15 <joe6> I am reading the data file into a list datastructure.
11:21:36 <joe6> and then doing some conversion and writing it to 5 different data files.
11:21:48 <joe6> basically, a simple read -> convert -> write
11:22:02 <kmc> monochrom, i heard that concurrency is the future
11:22:04 <aavogt> Jafet: I'm not sure it's really oleg's invention. Look at  asTypeOf in the Prelude (which has probably been there for a long time)
11:22:10 <monochrom> hehehe you win
11:22:43 <kmc> joe6, and how complicated is each record?
11:22:53 <kmc> and are you optimizing for development time or run time or space or what?
11:23:36 <Tomsik> aavogt: who knows, maybe oleg wrote it :p
11:23:46 <joe6> a record has 3 types of transactions, one a header, many or none body transactions and a footer.
11:24:17 <joe6> kmc: I am using strings to represent the data while converting and i want to use more refined bits or binary values
11:24:22 <Jafet> aavogt: Well, I reinvented it myself, then found oleg writing about it
11:24:27 <joe6> for the internal representation
11:24:30 <Jafet> It's not non-obvious, I guess
11:25:11 <Jesin> hmm
11:25:47 <Jesin> I tried to do this, with -XFlexibleInstances
11:25:50 <Jesin> import qualified Control.Category
11:25:52 <Jesin> import qualified Control.Arrow
11:25:54 <Jesin> instance (Control.Category.Category cat) => Functor (cat a) where fmap = (Control.Category..)
11:26:19 <Jesin> it told me this:
11:26:22 <Jesin>     Couldn't match expected type `(->)' against inferred type `cat'
11:26:23 <Jesin>       `cat' is a rigid type variable bound by
11:26:25 <Jesin>             the instance declaration at foo.hs:6:36
11:26:26 <Jesin>     In the expression: (Control.Category..)
11:26:27 <kmc> that's a sad instance; it will overlap anything else of the form (a b)
11:26:28 <Jesin>     In the definition of `fmap': fmap = (Control.Category..)
11:26:30 <Jesin>     In the instance declaration for `Functor (cat a)'
11:26:34 <Jesin> eh
11:26:35 <Jesin> probably
11:26:37 <Jesin> =/
11:26:39 <jmcarthur> Jesin: don't paste like that here
11:26:42 <Jesin> sorry
11:26:46 <jmcarthur> Jesin: use a paste site like hpaste.org
11:26:47 <Jesin> should use pastebin, I guess
11:26:51 <Jesin> or that
11:26:55 <joe6> kmc: was that directed towards me?
11:27:05 <kmc> no Jesin's
11:27:06 <Jesin> sorry, forgot about that
11:27:07 <jmcarthur> Jesin: no worries ^_^
11:27:16 <Jesin> k :p
11:27:44 <Jesin> hmm
11:27:50 <Jesin> [14:29:26]	<kmc>	that's a sad instance; it will overlap anything else of the form (a b)
11:28:04 <Jesin> I'm not sure I understand how
11:28:06 <Twey> Haha
11:28:19 <Jesin> the Category type restriction doesn't work, or what?
11:28:32 <kmc> it works in a different way than what you expect
11:29:02 <kmc> when I say "instance (C x) => T x" i mean "for any x, we have an instance T x.  also, if you end up using this instance and later discover  that x isn't an instance of C, choke and die"
11:29:19 <kmc> in other words, there's no backtracking based on failed class constraints
11:29:20 <Jesin> ah.  =/
11:29:52 <Jesin> If there were, would that theoretically be a valid Functor?
11:29:54 <kmc> not a problem in Haskell 98 / 2010, where the instance head can't overlap anyway
11:30:33 <joe6> kmc: any further thoughts on the record or program structure?
11:30:41 <kmc> :t (Control.Category..)
11:30:42 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
11:30:51 <kmc> joe6, not really
11:30:55 <Jesin> :t fmap
11:30:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:31:06 <Tomsik> :t fmap fmap fmap
11:31:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:31:08 <kmc> right, so it tries to unify (cat b c) with (a -> b)
11:31:24 <kmc> and concludes that cat = (->), which contradicts the more general head you gave
11:31:26 <Jesin> (->) is a Category instance already
11:31:28 <Jesin> =/
11:31:40 <kmc> you've got the quantification backwards
11:31:49 <kmc> let's say i give you a different category, like (Kleisli IO)
11:32:01 <kmc> type K = Kleisli IO
11:32:13 <Jesin> hmm, ok
11:32:14 <kmc> now (.) :: K b c -> K a b -> K a c
11:32:24 <kmc> that can't be fmap
11:32:35 <Jesin> riiight
11:32:40 <Jesin> ok, that makes sense, I think
11:32:49 <kmc> what Haskell calls "Functor" is what category theory would call "endofunctor on (->)"
11:32:54 <kmc> it's a more specific concept
11:32:56 <Jesin> yeah, ok
11:33:03 <kmc> look in category-extras if you want more general functors etc
11:33:25 <Jesin> so... is there any way to make fmap be a special case of (Control.Category..)?
11:34:51 <Nmord> k guys a quick newbie question. I got to make a function that compares the first element of a list and tells me how many elements are greater than the first, Im kind of stuck here
11:35:05 <kmc> :t \(x:xs) -> length $ filter (>x) xs
11:35:06 <lambdabot> forall a. (Ord a) => [a] -> Int
11:35:30 <kmc> Jesin, no, they are different things
11:35:39 <kmc> in category theory as well
11:35:50 <Jesin> hmm, ok
11:36:07 <Jesin> and (Prelude..) just happens to be a case where they intersect, I suppose?
11:37:07 <dolio> There's a definition of general fmap that can cover Category's (.).
11:37:23 <Jesin> huh
11:37:32 <Jesin> hmm.  how?
11:37:34 <dolio> I'm not sure how it works out in use, though. It probably starts requiring type annotations.
11:39:04 <dolio> Similar to how regular Functor's fmap covers the prelude's (.).
11:40:14 <Jesin> I would've thought that Category's (.) would be more general than fmap
11:40:16 <kmc> so for category K, there's a functor corresponding to composition in K?
11:40:20 <Jesin> hmm.
11:41:11 <dolio> I think that's right. This may also require bad overlapping instances, too, though. It's been a while since I did it.
11:41:52 <Jesin> "bad" in what sense
11:43:55 <dolio> The instance would be like (Category (~>)) => Functor (->) (->) ((~>) a)
11:43:58 <kmc> right, for every morphism f in K there's an endofunctor on K corresponding to "composition on the left with f".  maybe?
11:44:07 <dolio> The last part is of the form 'f a'. I don't like instances like that.
11:44:11 <Guest41692> where should my Pretty Print Monad lie? Text.Monad.Pretty?
11:44:36 <kmc> is it particularly important that it's a monad?
11:44:47 <Guest41692> kmc: no not really
11:45:01 <Guest41692> it's a closed interface, but you use the do syntax, so it's semi important
11:45:07 <kmc> nod
11:45:20 <monochrom> Text.PrettyPrinter.MyMonad
11:45:38 <kmc> i'd just invent a name for it
11:45:53 <aristid> mreh_: "closed interface"?
11:46:17 <mreh_> aristid: you can't create a Pretty monad, you can only combine them
11:46:31 <aristid> mreh_: no return?
11:46:50 <kmc> mreh_, you mean a value of that type?
11:47:09 <mreh_> well, I don't know of a way of hiding return, but that's not the intended usage
11:47:19 <kmc> then it sounds like this really isn't a monad
11:47:37 <mreh_> yeah, it's Monadic
11:47:45 <mreh_> like Parsec isn't a Monad
11:47:52 <kmc> parsec is a monad
11:47:59 <Jesin> oh no, http://www.haskell.org/haskellwiki/Arrow says side-effect order is significant here
11:48:03 <kmc> and you can use "return" in Parsec, and it's meaningful
11:48:06 <Jesin> I should've seen that coming
11:48:20 <kmc> they're not really side effects
11:48:39 <kmc> you build pure values representing descriptions of effects, same as with IO
11:48:57 <dolio> kmc: Anyhow, hom works as bifunctor C^op x C -> Set. Partially applying the first part gets you a functor C -> Set
11:49:17 <kmc> i see
11:49:18 <dolio> In Haskell's case, Set is replaced with Hask.
11:49:25 <aristid> mreh_: if return is not supposed to be used, then don't put it in the Monad typeclass.
11:49:34 <aristid> mreh_: don't use Monad just to get do syntax.
11:49:54 <mreh_> aristid: I'm not
11:50:02 <monochrom> mreh_ has reached the Pointed Functor of No Return? :)
11:50:33 <harlekin> Is there a version of break, in which break pred cs put the element with (pred c) being true into the left entry of the result?
11:50:50 <harlekin> Like break (==' ') "Hello World" -> ("Hello ", "World").
11:50:51 <mreh_> it keeps track of your indenting for you, it roughly corresponds to Wadlers pretty printing normal form, but puts in the required nests for you
11:51:30 <kmc> > break (==' ') "Hello World"
11:51:31 <lambdabot>   ("Hello"," World")
11:51:55 <monochrom> > span (/=' ') "Hello World"
11:51:56 <lambdabot>   ("Hello"," World")
11:51:56 <dolio> So I was slightly mistaken earlier, it should be: (Category (~>)) => Functor (~>) (->) ((~>) r)
11:52:08 <monochrom> > span (==' ') "Hello World"
11:52:09 <lambdabot>   ("","Hello World")
11:52:22 <dolio> That gets you fmap :: (a ~> b) -> (r ~> a) -> (r ~> b)
11:53:08 <paolino> hello, is there a class to be instantiated to extract the Int from a newtype on Int ?
11:53:25 <kmc> paolino, you want to do this generically over all newtypes
11:53:29 <kmc> ?
11:53:32 <paolino> class Index a where
11:53:32 <paolino> 	index :: a -> Int
11:53:38 <paolino> yes
11:53:40 <kmc> that kind of breaks the idea of newtype
11:53:45 <kmc> but ok
11:53:49 <kmc> there is the Ix class
11:53:51 <kmc> @src Ix
11:53:51 <lambdabot> class (Ord a) => Ix a where
11:53:51 <lambdabot>     range           :: (a,a) -> [a]
11:53:51 <lambdabot>     index           :: (a,a) -> a -> Int
11:53:51 <lambdabot>     inRange         :: (a,a) -> a -> Bool
11:53:51 <lambdabot>     rangeSize       :: (a,a) -> Int
11:54:25 <paolino> how it breaks the idea ?
11:55:07 <hpc> wtf is with the uncurried types?
11:55:17 <kmc> one use of newtype is to hide implementation details without losing performance
11:55:30 <kmc> i.e. abstract newtype
11:56:03 <kmc> if we had automatic newtype extraction then GHC users would be accidentally writing unsafePerformIO left and right ;)
11:56:27 <hpc> i see no problem with that :D
11:57:29 <paolino> mh, I just use the newtype here to let ghc distinguish different Ints and avoid some bugs in exchanging them
11:57:49 <paolino> but then I need the value inside the functions
11:58:03 <kmc> yeah it would be appropriate in some cases
11:58:11 <kmc> why not:  f (MyWrapperConstructor x) = ...
11:58:17 <c_wraith> Do you really need the value?   Or could you just derive Num, and get what you need?
11:58:29 <paolino> that is not polimorphic
11:58:51 <kmc> oh you want to distinguish a few different sorts of Int, but you also want to use them interchangeably elsewhere?
11:59:08 <c_wraith> Really sounds like a case for using the Num interface
11:59:17 <c_wraith> with GeneralizedNewtypeDeriving
11:59:20 <paolino> c_wraith: I need to use (!!) and such not summing them
11:59:24 <c_wraith> ah
11:59:38 <paolino> kmc yes
11:59:49 <c_wraith> You could derive Integral, and use fromInteger
11:59:50 <kmc> i see, that's harder
11:59:55 <paolino> I have instance Index Int where
11:59:55 <paolino> 	index = id
12:00:14 <c_wraith> err, toInteger is the one in Integral
12:00:23 <hpc> instance Index someNewtype where index (someNewtype x) = x
12:00:50 <paolino> well deriving Index is enough then
12:00:59 <c_wraith> Oh, I suppose it would be
12:01:10 <paolino> newtype A = A Int deriving Index
12:01:15 <c_wraith> yeah
12:01:43 <c_wraith> The other thing you could do is use a newtype with a phantom type for keeping the distinct things apart, but then you could pattern-match on the constructor
12:01:57 <c_wraith> But the typeclass probably is easier for this case
12:02:41 <paolino> ah GADTs
12:02:51 <kmc> not necessarily GADTs
12:03:07 <c_wraith> newtype Wrapper a = W Int
12:03:19 <paolino> don't they subsume phantom types ?
12:03:40 <c_wraith> yes, but they have a runtime cost, where a newtype with a phantom parameter doesn't
12:03:46 <kmc> well technically they subsume all algebraic types
12:03:46 <Tomsik> they're kind of overpowered and need some nerfing :p
12:03:55 <paolino> ok
12:03:58 <kmc> but i don't think you  gain from the GADT-ness here
12:04:09 <kmc> because you explicitly *don't* want different constructors for different result types
12:04:12 <c_wraith> anyway, I think the typeclass is probably better.
12:04:25 <c_wraith> I was just pointing out an alternative approach that might be better in other cases
12:05:36 <kmc> i think it's worth trying both on small scale
12:05:56 <kmc> maybe i have an irrational suspicion of type classes
12:07:16 <paolino> mh , then Wrapper a appears in the signatures and I fix 'a' when I want . But pattern match for every 'a' , which is like index method
12:07:44 <kmc> except that you can use it as a pattern, while the index method can't
12:07:47 <kmc> unless you use view patterns
12:07:59 <kmc> polymorphic views, eh
12:08:01 <kmc> interesting idea
12:08:15 <kmc> remember that numeric literal patterns are already overloaded
12:08:39 <KitB> Can anyone point me to a good tutorial for making instances of read? Googling has failed me :(
12:08:56 <j-invariant> KitB: instance Read X where ...
12:08:57 <Tomsik> deviring Read?
12:09:02 <Tomsik> :p
12:09:05 <kmc> it's almost never worth making a Read instance unless you can derive it
12:09:09 <KitB> Without deriving :P
12:09:14 <kmc> if you want to write a real parser, use a parser combinator library
12:09:19 <kmc> like parsec
12:09:28 <paolino> KitB: use Text.Read and Text.ParserCombinators.ReadP
12:09:33 <kmc> Read is for quick hacks and there deriving almost always does what you want
12:10:06 <kau> Hello everybody!
12:10:30 <paolino> KitB: Text.ParserCombinators.ReadPrec if you don't care precedence IIRC
12:10:36 <j-invariant> hi kau
12:10:46 <KitB> paolino: Thanks
12:10:52 <KitB> I suspect I'm in over my head
12:11:06 <KitB> But that's the funnest way to learn
12:11:24 <kau> I have a little question with happstack...
12:11:42 <McManiaC> how do I tell GHC that my module xy should be compiled as main?
12:11:50 <kau> I have a program with happstack state and a happstack web server
12:11:54 <McManiaC> Warning: output was redirected with -o, but no output will be generated
12:11:55 <McManiaC> because there is no Main module.
12:11:58 <hpc> McManiaC: --make?
12:12:04 <McManiaC> hpc: did that
12:12:18 <kau> I'd like that the web page refreshs whenever the MACID changes
12:12:27 <kmc> McManiaC, -main-is?
12:12:45 <McManiaC> kmc: merci
12:12:57 <kau> That is to say, I'd like to have a event handler on MACID that refresh my web page
12:13:00 <KitB> Is there some automated method for generating read instances from show instances?
12:13:13 <kau> Is there a way to do that?
12:13:16 <hpc> KitB: i doubt it
12:13:17 <KitB> (I'm aware it's not an easy problem)
12:13:17 <kmc> no KitB, it would be undecidable in general
12:13:32 <kmc> there are some systems for genertaing both parsers and prettyprinters from the same grammatical description
12:13:35 <kmc> but i don't know much about them
12:13:46 <kmc> someone had an arrow-based attribute grammar system that did this
12:13:47 <hpc> also the grammar for the descriptions isn't always the best
12:14:16 <hpc> actually, a thought occurs to me
12:14:28 <hpc> could one define hypothetical type classes:
12:14:33 <hpc> Foo a => Bar a
12:14:37 <hpc> and Bar a => Foo a
12:15:40 <aristid> preflex: seen ivanm
12:15:41 <preflex>  ivanm was last seen on #haskell 8 hours, 7 minutes and 12 seconds ago, saying: @quote imperative
12:15:49 <aristid> @quote imperative
12:15:49 <lambdabot> newsham says: lambdabot is imperative!  and her mom's kinda loose...
12:15:56 <aristid> @quote impredicative
12:15:57 <lambdabot> No quotes match. Wrong!  You cheating scum!
12:16:05 <aristid> NO YOU
12:17:25 <kau> So nobody has an idea?
12:27:54 <azaq23> paolino: If you want to mark integers as being mathematically differently used (as you would with floats which represent probabilities), I would suggest using type T t = t instead of newtypes, which just serves as an annotation (for example, type Count t = t; f :: Count Int is possible and fully equivalent with f :: Int).
12:28:13 <joe6> can i use a functor to map over the fields of a record?
12:28:31 <kmc> not in general; most records have fields of different types
12:28:50 <joe6> what if i make the fields to have the same type?
12:29:20 <kmc> then you can write the functor instance
12:29:26 <tswett> > sin 177.5
12:29:28 <lambdabot>   0.9999999998864147
12:29:28 <joe6> ok, cool. 
12:29:36 <kmc> but it'll also have to be a polymorphic type
12:29:50 <kmc> you could have some other fields which aren't mapped over
12:29:56 <kmc> data Foo a = { bar :: a, baz :: Int }
12:30:06 <kmc> you can write a fmap instance which only touches "bar"
12:30:18 <paolino> azaq23: thanks, I'm exercising the phantom type right now, I'll try that too
12:30:31 <kmc> @instance fmap (,)
12:30:32 <lambdabot> Maybe you meant: instances instances-importing
12:30:37 <kmc> @src (,) fmap
12:30:37 <lambdabot> fmap f (x,y) = (x, f y)
12:31:16 <joe6> kmc: that is interesting.
12:31:58 <joe6> so, I could have data Foo = Foo { a ::Int, b :: Bool, c::Word8, d ::Word8}
12:32:07 <joe6> and i could have fmap looping over only c and d?
12:34:22 <tswett> > sin 51996.5
12:34:24 <lambdabot>   9.564667889649377e-6
12:39:39 <paolino> c_wraith: the phantom type made the code shorter
12:39:53 <c_wraith> Well, in that case...  :)
12:41:20 <paolino> not only in the class and instance, also I could generalize functions
12:41:49 <kmc_> you still have a type class for it too?
12:41:55 <paolino> resolve :: MappaTP -> ReadP (Index a)
12:41:57 <paolino> no
12:42:43 <j-invariant> Question: Are the type system in haskell maybe just a hold back?
12:43:01 <j-invariant> Overall making things harder
12:43:16 <paolino> c_wraith: I couldn't have that function without the phantom type, it seems to me , at least
12:43:42 <kmc_> j-invariant, yeah, it makes it harder to write incorrect programs
12:43:51 <paolino> j-invariant: the make your code correct at compile time
12:44:01 <j-invariant> my code is not correct
12:44:01 <kmc_> writing correct programs is hard in any language
12:44:12 <kmc_> haskell makes it also hard to write incorrect programs
12:44:19 <c_wraith> j-invariant: Not when you get into long-term maintenance of production software.  The type system makes it *so* much harder to break things during maintenance.
12:47:02 <paolino> kmc_: newtype Index a = Index {index :: Int} deriving (Show, Eq, Ord) , the index function is somewhat polymorphic like in the typeclass
12:47:11 <kmc_> sure
12:48:45 <paolino> it is not obvious to me why deriving is still working with phantom types, but that is a strong reason to avoid GADTs , when it's possible :) 
12:49:06 <kmc_> you can also derive with GADTs and StandaloneDeriving, i think
12:49:29 <kmc_> deriving works with phantom types because the derived instance doesn't care what the type is
12:49:47 <paolino> that is TH 
12:50:08 <kmc_> ?
12:50:14 <c_wraith> No, the Deriving package is TH.  StandaloneDeriving is another extension
12:50:52 <paolino> isn't TH behind deriving mechanism ?
12:50:59 <kmc_> no
12:51:12 <kmc_> "deriving" is in the Haskell spec; TH isn't
12:51:21 <kmc_> any Haskell compiler is free to implement "deriving" however
12:51:28 <kmc_> each derivable class is basically a special case in  the compiler
12:51:37 <joe6> is there a better way of implementing this: data DataMode = Data0 | Data1; data X = X {mode::DataMode, someotherfields::Int}; data Y = Y {headertransaction :: X, footertransaction:: (X but with Data1 mode always)}
12:52:16 <aavogt> @hackage derive is probably a good example of how instances can be written automagically
12:52:17 <lambdabot> http://hackage.haskell.org/package/derive is probably a good example of how instances can be written automagically
12:53:18 <joe6> should I just create another data for X with mode always Data1?
12:53:39 <joe6> such as XData1 = X {someotherfields:: Int}
12:54:27 <joe6> or just do data X = X{mode::DataMode,someotherfields::Int} | XData1 {someotherfields::Int}
12:55:31 <joe6> but that would mean that "someotherfields::Int" would be repeated 
12:55:42 <joe6> any suggestions, please?
12:55:52 <ddarius> The most typeful way would be to have a separate type.
12:56:11 <joe6> ok, then data XData1 .., you mean?
12:56:27 <ddarius> This will minimize the possibility for error, convey intent, and avoid ugly "this can never happen" error cases.
12:56:28 <ddarius> Yes.
12:56:39 <joe6> ok, thanks.
12:56:46 <joe6> makes sense.
12:57:01 <joe6> i was thinking about avoiding redundancy in the types..
12:57:55 <ddarius> Well there are ways to get the type safety while still using a generic representation.
12:57:58 <joe6> but your thinking makes sense. easy to use.
13:00:08 <joe6> ddarius: thanks a lot for your suggestion.
13:07:47 <Feuerbach> Does anyone know of any compilers/interpreters except ghc which can compile Parsec 2 or Parsec 3?
13:08:14 <mauke> hugs?
13:08:22 <ddarius> The only extension Parsec 2 uses is Rank-2 types which should work in Hugs and JHC and maybe NHC.
13:08:35 <ddarius> (And probably LHC, YHC, and UHC.)
13:11:11 <Feuerbach> ddarius: here John says that jhc cannot compile Parsec 2: http://www.haskell.org/pipermail/jhc/2008-May/000270.html. It was almost 3 years ago, but I haven't found any other mentions.
13:11:51 <ion_> Did my message about the State monad get through just before i got disconnected?
13:12:44 <ddarius> Feuerbach: Three years is a long time.
13:13:57 <ion> cale: Re: the discussion about State a month or so ago, i tried to write the kind of description i’d have found useful at the point of understanding the concept of monads but still struggling with State. http://heh.fi/state-monad
13:14:21 <ion> Oh, wow. The message got through with quite a bit of a delay. :-D
13:21:26 <conal> i'm looking for a sanity check. the non-ascii chars on my TCM paper page are getting garbled. http://conal.net/papers/type-class-morphisms/ and i can't figure out how. for instance, the curly apostrophes and quote marks in the abstract. i've tried three browsers here. does anyone see differently at their end? any ideas what's happening?
13:21:26 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:22:19 <jmcarthur> conal: same thing here
13:22:43 <beastaugh> it's a mime-type problem
13:22:55 <conal> jmcarthur: thx. strangely, the html looks fine in emacs on the server. and renders fine when viewed locally.
13:23:00 <jmcarthur> conal: i'm guessing it's the web server
13:23:02 <beastaugh> your server is sending the document with this header
13:23:03 <beastaugh> Content-Type:text/html; charset=iso-8859-1
13:23:05 <conal> beastaugh: pleas say more. i don't knowwhat mime-type is about.
13:23:12 <jmcarthur> conal: if i manually change the encoding in my browser it works
13:23:27 <beastaugh> if you set it to send it as text/html; charset=utf-8 it'll probably work
13:23:32 <jmcarthur> and your html seems to specify utf-8, so that's good, but the server seems to be overriding it
13:23:37 <kmc_> egh, latin-1
13:23:56 <beastaugh> yeah, the Content-Type header takes precedence over the content type specified in the document
13:24:10 <conal> hm. i wonder why *this* page in particular.
13:24:18 <jmcarthur> other pages work?
13:24:34 <conal> e.g. http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization
13:24:51 <conal> plenty of non-ascii chars
13:25:01 <jmcarthur> yeah, the encoding seems to be utf-8 there
13:25:29 <beastaugh> well, many non-ascii characters are supported by iso-8859-1
13:26:10 <jmcarthur> my browser reports it as utf-8 though
13:26:31 <conal> any theories about how my web server could be choosing iso-8859-1 for the TCM page and utf-8 for the blog post?
13:26:36 <jmcarthur> not that i checked the http headers myself, but i doubt my browser is being very smart considering it fails for the tcm page
13:27:01 <beastaugh> jmcarthur: the HTTP headers specify iso-8859-1 in both cases
13:27:12 <jmcarthur> huh, then i guess my browser is being smart then
13:27:23 <jmcarthur> conal: there's your answer ^^
13:27:29 <jmcarthur> the server is doing the same thing
13:28:32 <conal> jmcarthur: ??
13:28:34 <mauke> I see different headers
13:28:53 <conal> how are people seeing headers?
13:28:55 <jmcarthur> conal: according to beastaugh the server is being consistent, but ... not according to mauke
13:29:23 <mauke> latin-1 for the paper, utf-8 for the blog
13:29:51 <conal> i'm looking at the default encoding per page that firefox chooses. which differs between these two pages.
13:30:02 <jmcarthur> mauke: you sure? i'm seeing "Content-Type:text/html; charset=UTF-8"
13:30:04 <beastaugh> mauke: you mean the actual PDF file?
13:30:11 <jmcarthur> oh
13:30:14 <jmcarthur> heh
13:30:17 <jmcarthur> beastaugh: are *you* sure?
13:30:23 <mauke> HEAD http://conal.net/papers/type-class-morphisms/ --> 200 OK
13:30:24 <beastaugh> yes
13:30:24 <mauke> Content-Type: text/html; charset=iso-8859-1
13:30:26 <kuffaar> "Do not use the send and recv functions defined in this module in new code, as they incorrectly represent binary data as a Unicode string. As a result, these functions are inefficient and may lead to bugs in the program. Instead use the send and recv functions defined in the Network.Socket.ByteString module. "
13:30:28 * kuffaar sighs
13:30:34 <mauke> HEAD http://conal.net/blog/ --> 200 OK
13:30:34 <mauke> Content-Type: text/html; charset=UTF-8
13:30:38 <kuffaar> I was wondering why he did that in the module
13:30:47 <kuffaar> In the EchoServer example
13:30:56 <ion> conal: A blog engine may output different headers than what the HTTP daemon uses for static files.
13:31:00 <beastaugh> yes, the blog page is being served as utf-8
13:31:08 <allbery_b> keep in mind that things may be different based on what order (and if, for HEAD) the browser's preferred encodings are in
13:31:08 <beastaugh> sorry, I didn't make it clear I agreed with that
13:31:26 <jmcarthur> i'm not even getting a content type from the server on the tcm page
13:31:36 <beastaugh> the static HTML pages seem to be being served as ISO-8859-1, which is the standard Apache content type for HTML
13:31:46 <beastaugh> I think it's what it defaults to
13:32:06 <beastaugh> not 100% on that though, I usually change mine in my httpd.conf
13:32:20 <beastaugh> ahh, the blog's wordpress
13:32:28 <beastaugh> yeah, WP serves all pages as utf-8
13:32:35 <conal> and wouldn't the content-type/charset choice in the html override the apache default?
13:32:42 <beastaugh> because that's what the database entries are stored as
13:32:42 <mauke> no
13:32:45 <mauke> headers > content
13:32:48 <beastaugh> unfortunately, no
13:33:19 <conal> hm. okay. maybe something changed recently on the server.
13:33:46 <jmcarthur> w3 detects it as iso-8859-1 as well
13:33:54 <jmcarthur> and reports the conflicting information
13:34:11 <jmcarthur> i don't know why i'm not even getting the header
13:34:20 <mauke> jmcarthur: what are you using to check?
13:34:35 <conal> i still don't understand something here. wordpress generates the html, but isn't that html delivered by the same web server that delivers my static html page?
13:34:36 <jmcarthur> chrome's developer tools
13:34:51 <conal> i don't understand where they can diverge other than in their html
13:34:52 <beastaugh> conal: yes, that's correct
13:34:54 <Saizan> conal: the script can decide which headers to use
13:35:01 <jmcarthur> it's php's doing
13:35:03 <beastaugh> however, wordpress *also* sets the HTTP header
13:35:03 <mauke> conal: uh, in the headers
13:35:44 <conal> beastaugh: what does it mean that wordpress *sets* the header? how?
13:35:46 <monochrom> this is why I don't use any of those famous blog software. they all do detrimal things behind my back. all of them. detrimal.
13:36:09 <mauke> conal: what do you mean by "how"?
13:36:13 <conal> monochrom: oddly, the blog is the thing that *is* working.
13:36:14 <conal> m
13:36:15 <conal> a
13:36:15 <Saizan> conal: the blog software gives to the server a full HTTP response, not just the content
13:36:32 <mauke> the blog software is also part of the server
13:36:35 <jmcarthur> conal: php gives you the ability to get and set http headers
13:36:37 <mauke> assuming mod_php
13:36:38 <beastaugh> WordPress is a PHP application; it's effectively being run directly by Apache
13:37:00 <conal> i guess i don't know even basics of what goes on in a web server
13:37:11 <conal> beastaugh: ah. that helps. thx.
13:37:19 <ion> conal: If you are using Apache: AddDefaultCharset UTF-8
13:37:25 <beastaugh> mauke: yeah, assuming that :)
13:37:27 <mauke> request comes in; response goes out
13:37:29 <conal> when ignorance is deep enough, it's hard to know even what questions to ask.
13:37:40 <mauke> requests and responses are http messages
13:37:42 <kuffaar> <Saizan> conal: the blog software gives to the server a full HTTP response <- PHP can't do that without extensions, can it?
13:37:47 <beastaugh> but usually if you're running php-fpm or cgi or something, you use a different server to Apache
13:37:49 <mauke> every message has headers and (optionally) a body
13:38:12 <beastaugh> kuffaar: it's done through an Apache extension, mod_php, which runs the PHP process
13:38:16 <kuffaar> Unless you use TCP sockets or something directly
13:38:48 <mauke> even CGI lets you set response headers
13:38:59 <conal> how could it make sense to have headers override the charset specified in the html?
13:39:01 <kuffaar> beastaugh: How do you return "lol" from a request without using TCP sockets with mod_php?
13:39:21 <mauke> conal: content is hostile. the server can be trusted.
13:39:32 <conal> mauke: ah.
13:39:45 <mauke> at least that's the assumption, I think
13:39:54 <ddarius> conal: You should write a web server.  It's a fun exercise for an afternoon.
13:40:09 <kuffaar> Yes, it's something you should have done at least once
13:41:02 <ddarius> Also you may want to send your HTML as, for example, binary data.
13:41:15 <kuffaar> Huh :o
13:41:33 <stulli> I have a function "fromInt::(Rounding r, Precision p) => Int -> Fixed r p". When i run fromInt 42 in ghci i shall add a type signature, but i can't figure out what it should look like. Any hints?
13:42:04 <conal> ddarius: good idea. i bet i'd learn a lot.
13:42:27 <Saizan> stulli: look at instances for Rounding ans Precision
13:42:52 <beastaugh> kuffaar: you mean as the entire response string, without even a response code? I have no idea, I've never tried
13:43:04 <Saizan> stulli: the haddock should list then under the class
13:43:11 <kuffaar> beastaugh well that is what we were talking about :p
13:43:14 <Saizan> *them
13:43:50 <conal> i'm writing to my little brother, who runs the server, asking if a setting changed recently.
13:44:13 <mauke> conal: you could just change the html
13:44:36 <conal> mauke: i can?? it already says utf-8
13:44:39 <Saizan> kuffaar: i'm pretty sure "lol" doesn't qualify as an HTTP response btw
13:44:48 <kuffaar> Saizan: Exactly
13:45:14 <Saizan> kuffaar: so how is it relevant?
13:45:16 <mauke> conal: no, turn it into latin-1 (or plain ascii)
13:45:28 <kuffaar> "<Saizan> conal: the blog software gives to the server a full HTTP response, not just the content"
13:45:33 <kuffaar> It doesn't ^
13:45:59 <kuffaar> That's just wrapping applied by mod_php I would guess?
13:46:16 <kuffaar> Apache in combination with mod_php
13:46:16 <monochrom> well you could never be sure
13:46:17 <Saizan> kuffaar: that phrase excludes "lol" already
13:46:27 <stulli> Saizan: for Precision it is something like Precision Float, but Rounding isn't linked and i can't find it by manually searching either. Alternatively you can suggest another package for arbitrary precision floats :). 
13:46:57 <conal> mauke: oh. you mean change the content. stop using non-ascii chars?
13:47:08 <monochrom> yikes
13:47:20 <beastaugh> that shouldn't be necessary
13:47:23 <mauke> conal: yeah
13:47:32 * ddarius just received a letter whose contents were another letter.
13:47:43 <monochrom> there goes all the mathy symbols for lub etc :)
13:47:46 <beastaugh> you just need to convert them from utf-8 to iso-8859-1
13:47:55 <mauke> monochrom: why?
13:48:00 <beastaugh> so if an alternative representation is available, that would be ok
13:48:01 <mauke> this is html we're talking about
13:48:10 <Saizan> kuffaar: if you found a field of a valid http response you can't control from mod_php then that'd be a counterexample
13:48:11 <beastaugh> personally I would just change the content-type header
13:48:22 <monochrom> oh oops, I see.
13:48:38 <conal> i'm going to try AddDefaultCharset UTF-8
13:50:03 <stulli> Ok, i finally got it. Haskell types still confuse me.
13:50:08 <monochrom> x ⊓ y ⊑ ⊥ becomes x &#8851; y &#8849; &#8869; :)
13:50:33 <conal> beastaugh: via apache setting AddDefaultCharset UTF-8 ?
13:50:35 * hackagebot yices-painless 0.1 - An embedded language for programming the Yices SMT solver  http://hackage.haskell.org/package/yices-painless-0.1 (DonaldStewart)
13:50:36 <j-invariant> me too
13:51:23 <stulli> People should concentrate on type tutorials instead of monad tutorials :)
13:51:27 <beastaugh> conal: if you know all your files are in UTF-8, sure
13:51:53 <conal> beastaugh: got it. thx.
13:52:37 <mauke> http://mauke.dyndns.org/tmp/tcm-index.html - after a search/replace
13:52:38 <conal> fixed!
13:53:13 <beastaugh> I would recommend checking a selection of your other static HTML pages to ensure that it hasn't broken something elsewhere
13:53:27 <beastaugh> since they've presumably been working fine all this time
13:53:40 <conal> when i looked at my http.conf file, i found that i'd added a "AddDefaultCharset On" at the root of my domain. compensated for something i've forgotten. so i just commented out that line and restarted the server.
13:53:51 <conal> the apache docs say that On means iso-8859-1.
13:54:16 <conal> i don't know why this symptom showed up only recently.
13:54:16 <conal> t
13:54:17 <conal> hank
13:54:17 <conal> s
13:54:23 <conal> thanks very much for the help!
13:54:35 <beastaugh> happy to help :)
13:54:46 <ddarius> stulli: Beginners should concentrate on types instead of monads.
13:54:49 <conal> whew!
13:55:04 <aavogt> rectangles not squares!
13:55:08 <conal> stulli: what ddarius said! 
13:57:21 <stulli> ddarius: i try, i try!
13:58:35 <stulli> But as soon as there is more than one type variable (like Fixed r p) i feel lost
13:59:00 <stulli> Although it shouldn't make much of a difference.
13:59:16 <Nullus> hey guys. I need a little help here, any idea how to make a function, checkSorted :: [Int] -> Bool , that checks if a certain list is sorted? 
14:00:48 <Philippa> Nullus: what does it mean for a list to be sorted?
14:00:53 <kuffaar> Nullus that smells like homework :)
14:01:35 <ddarius> stulli: If only all the rest did.
14:01:37 <companion_cube> Nullus, f x = x == sort x ?
14:01:51 <Nullus> kuffaar just studying for an exam, one of the exercises is that one
14:02:04 <companion_cube> or you can use some foldl
14:02:17 <Boxo> joke answer: ap (==) sort
14:02:56 <kmc_> Nullus, look at "zipWith" and "tail"
14:03:09 <mauke> why zipWith?
14:03:11 <Nullus> I was looking for a more recursive solution
14:03:20 <kmc_> explicit recursion?
14:03:27 <Nullus> yes
14:03:29 <kmc_> isSorted (x:y:xs) = ...
14:03:31 <Philippa> Nullus: again, how would you know if a list is sorted?
14:03:32 <kmc_> isSorted [x] = ...
14:03:34 <kmc_> isSorted [] = ...
14:04:00 <kmc_> (i'd call it isSorted not checkSorted because we focus on what things *mean* not on what they *do*.  haskell values are often named after adjectives or nouns, not verbs)
14:04:13 <Nullus> Philippa if x is lesser than the next element on the list or greater than the next one
14:04:14 <ivanm> preflex: seen aristid 
14:04:15 <preflex>  aristid was last seen on #haskell 1 hour, 48 minutes and 13 seconds ago, saying: NO YOU
14:04:22 <ivanm> aristid: you were looking for me?
14:05:06 <aristid> ivanm: yea, i was wondering how to get a list of subgraphs in a graph. but i have an idea now :)
14:05:20 <ivanm> aristid: what kind of subgraphs are you after?
14:05:23 <aristid> @pl \ab -> map (flip delNodes ab) $ subsequences (nodes ab)
14:05:24 <lambdabot> ap (map . flip delNodes) (subsequences . nodes)
14:05:45 <aristid> ivanm: this kind: http://en.wikipedia.org/wiki/Clique_problem
14:06:04 * ddarius would call it "isSorted" because "if isSorted xs" reads better.
14:06:56 <ivanm> aristid: I do have a clique-finding function in Graphalyze
14:07:01 <j-invariant> better than  if sorted xs  ?
14:07:05 <ivanm> no guarantees are made about correctness or performance though :/
14:07:43 <aristid> ivanm: which module?
14:07:44 <ddarius> j-invariant: sorted would be what sort is called.
14:08:10 <ivanm> ummm.... IIRC, Data.Graph.Analysis.Algorithms.Common
14:08:30 <companion_cube> let isSorted = snd . foldl (\(y, z) x -> (x, z && x >= y)) (head x, True)
14:08:36 <companion_cube> \o/ ugly one-liner
14:08:50 <kuffaar> Mine is worse
14:09:29 <companion_cube> there lacks a check for empty list, though
14:09:41 <aristid> ivanm: what's a _regular_ subgraph?
14:09:58 <comak> companion_cube, try with zipWith
14:10:02 <ivanm> aristid: a clique is a maximal regular subgraph
14:10:09 <ddarius> and . ap (zipWith (<=)) (drop 1)
14:10:16 <ivanm> aristid: you know what regular graphs are, don't you?
14:10:21 <aristid> no
14:10:26 <kuffaar> Wait, what's the equivalent of #'rest in Haskell?
14:10:33 <kuffaar> It's not rest, apparently
14:10:38 <companion_cube> comak, my solution does not allocate a second list ;)
14:10:44 <ivanm> K_n = graph with n vertices, each pair of vertices has an (undirected) edge
14:10:53 <aristid> <In computer science, the clique problem refers to any of the problems related to finding particular complete subgraphs ("cliques") in a graph, i.e., sets of elements where each pair of elements is connected.>
14:11:03 <ddarius> companion_cube: Neither does zipWith
14:11:10 <companion_cube> oh
14:11:12 <ivanm> a regular subgraph is a subgraph where every pair of vertices in that subgraph have an edge
14:11:32 <ivanm> a _clique_ is a maximal regular subgraph (i.e. can't add any more vertices to it whilst still keeping it as a regular subgraph)
14:11:36 <aristid> ivanm: regular = complete?
14:11:46 <companion_cube> ok, my solution is not that short, anyway i'm not a good haskeller :)
14:11:51 <ivanm> wait, have I been getting my terminology mixed up again? :/
14:11:53 <ddarius> companion_cube: Well it does, but it will fuse with and, however, simply because you don't explicitly create a list doesn't mean you aren't allocating.
14:12:08 <aristid> ivanm: they might be synonyms :)
14:12:13 <companion_cube> yeah, but i hope my tuples will go in registers
14:12:14 <ivanm> aristid: *sigh* yeah, I think I meant complete rather than regular
14:12:24 <aristid> ivanm: heh
14:12:44 <ivanm> nah, regular graph is where all vertices have the same degree
14:12:54 <ivanm> do a k-regular graph on k vertices is a complete graph
14:13:03 * ivanm bangs his head against a convenient flat surface
14:13:06 <ivanm> anyway, I've g2g
14:13:16 <kuffaar> companion_cube: checkSorted list = if length list <= 1 then True else let a : b : c = list in a < b && checkSorted (b : c)
14:13:21 <kuffaar> That was mine :[ much l.onger
14:13:33 <ddarius> kuffaar: And -much- less efficient.
14:13:39 <companion_cube> not tail rec
14:13:50 <ddarius> companion_cube: That's not a problem.
14:13:59 <ddarius> And it is anyway.
14:14:16 <companion_cube> even with the && thing ?
14:14:36 <companion_cube> i can't get used to how lazyness changes complexity :D
14:14:43 <aristid> bad: length list <= 1
14:14:46 <kuffaar> Why would I use Haskell if I cared about efficiency? :D
14:14:50 <kuffaar> aristid: Why?
14:14:50 <ddarius> companion_cube: Laziness isn't changing complexity really.
14:14:59 <aristid> kuffaar: haskell is pretty efficient.
14:15:05 <aristid> kuffaar: or GHC is
14:15:08 <kmc_> kuffaar, GHC is one of the best compilers I know of
14:15:14 <kmc_> i regularly rewrite Python code in Haskell for speed
14:15:18 <ddarius> companion_cube: (&&) is lazy in its second argument and if we viewed (&&) as a built-in, like in C, then the second argument would be a tail position.
14:15:21 <companion_cube> maybe i should stop saying false statements like that ...
14:15:35 <kuffaar> aristid: What is bad about it?
14:15:35 <kmc_> it takes a while to learn Haskell well enough to write fast code
14:15:49 <kmc_> and often the fast code isn't the prettiest
14:15:56 <kmc_> but usually only a tiny part of a program actually needs to be fast
14:15:57 <aristid> kuffaar: length traverses the whole list
14:16:06 <aristid> kuffaar: you only care about the first element anyways
14:16:12 <kmc_> and you can use the slow prototype as a cross-verification test
14:16:19 <kuffaar> aristid: Two, no?
14:16:20 <ddarius> One of the nice things about Haskell is that most of the optimizations are geared at making the pretty code, fast code (within reason.)
14:17:30 <kuffaar> But yeah I didn't think of length
14:17:32 <kuffaar> To me it's O(1)
14:17:45 <aristid> no, it's O(n)
14:17:48 <kuffaar> Yeah
14:18:13 <ddarius> "Not thinking."  That sums up most people's performance problems with Haskell.
14:18:56 <ddarius> "I just assumed it was like every other language, even though I started it because it was supposed to be different from every other language."
14:19:19 <kmc_> @quote ChrisOkasaki
14:19:19 <lambdabot> ChrisOkasaki says: Historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict.
14:21:17 <j-invariant> lol
14:21:53 <kuffaar> ddarius: My main reason for learning Haskell was the need for a statically typed, sandboxed and portable language, not because it's totally nuts
14:22:13 <kuffaar> Haha just kidding, the latter was much more important.
14:22:19 <kuffaar> @quote SPJ cheerful
14:22:19 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
14:22:54 <companion_cube> ddarius, even when thinking, reasonning about lazyness is hard
14:23:09 <systemfault> Hahaha
14:23:20 <ddarius> kmc_: For asymptotic analyses, that works reasonably well for a single algorithm in a pure language.  It over-estimates, but is otherwise right.  For multiple operations, it usually just breaks worst-case into amortized.
14:24:12 <ddarius> companion_cube: Not harder than garbage collection or programming itself.  Most issues with laziness can be foreseen and resolved with just a bit of straightforward thought or calculation.
14:24:23 <kuffaar> Btw my original version didn't use length but pattern matching
14:24:30 <kuffaar> It was just too long for IRC
14:24:31 <ddarius> At least for the performance problems most people are worried about.
14:24:55 <kuffaar> Data.ByteString.length/null are O(1) though, right?
14:24:57 <ddarius> I'll admit precise asymptotic analyses of lazy programs are a bit tricky, but then those are fairly tricky anyway.
14:25:04 <kmc_> kuffaar, for strict bs, yes
14:25:18 <ddarius> type Lazy.ByteString = [Strict.ByteString]
14:25:23 <kmc_> kuffaar, lists are represented by singly linked lists; strict bytestrings are represented by (pointer to byte array, length, offset)
14:25:36 <kmc_> which means also that slicing a bytestring is cheap
14:25:46 * hackagebot hCsound 0.3.1 - interface to CSound API  http://hackage.haskell.org/package/hCsound-0.3.1 (JohnLato)
14:25:52 <kuffaar> Ah, didn't know about the offset part
14:26:14 <kuffaar> So you can refer to subsets of bytestrings efficiently because no copies are made
14:26:15 <kuffaar> Interesting
14:26:21 <kmc_> length for lazy bs is O(# chunks) which is technically still O(n) but it's a much smaller constant factor
14:26:47 <kmc_> i'm not a big fan of asymptotic analysis.  "you made your program 1000 times faster? so what, it's a constant factor"
14:27:10 <kuffaar> :)
14:27:24 <kmc_> it's good for what it was originally used for (comparing abstract algorithms in isolation) and not so much as a guide for real humans programming real computers with all the messiness
14:27:30 <kuffaar> inb4 10 furious academics flame you
14:29:23 <kmc_> no, academics are usually pretty honest about the scope of their work
14:29:32 <kmc_> and if anything get pissed off when people try to apply it and miss the point
14:29:34 <ddarius> Indeed.
14:29:35 <awesomehaskell> Hi.I have finished tryhaskell and wish to learn the newest revision haskell 2010
14:29:38 <awesomehaskell> any book
14:29:40 <awesomehaskell> tutorial
14:29:45 <awesomehaskell> for the newest revision
14:29:47 <kmc_> awesomehaskell, Haskell 2010 is almost the same as Haskell 98.  don't worry about it.
14:29:54 <awesomehaskell> super
14:29:55 <olsner> some more interesting measures would be to find exact function for time/space taken, number of memory accesses or cache misses
14:29:56 <Boxo> @where lyah
14:29:56 <lambdabot> http://www.learnyouahaskell.com/
14:30:01 <kuffaar> @where rwh
14:30:01 <awesomehaskell> i love it so far
14:30:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:30:07 <cmars232> how do i convert between String, Word8 and Lazy bytestrings?
14:30:32 <kmc_> cmars232, String holds Chars, ByteString holds bytes (aka Word8)
14:30:32 <kuffaar> cmars232 "\x00" to the Word8 0, for example?
14:30:41 <kmc_> so the question of converting between them is a question of character encoding / decoding
14:30:42 <awesomehaskell> second question  does haskell offer any gpu acceleration 
14:30:45 <kmc_> which means thre's many ways you can do it
14:30:54 <kmc_> which produce different results
14:31:37 <cmars232> i see, i'm ok with treating everything as utf8
14:31:49 <kmc_> then you might enjoy http://hackage.haskell.org/package/utf8-string
14:32:17 <awesomehaskell> does haskell offer any gpu acceleration like opnecl or cuda
14:32:34 <kmc_> awesomehaskell, no Haskell compiler does such things automatically
14:32:37 <kmc_> but there are libraries for it
14:32:43 <awesomehaskell> yupi
14:32:45 <awesomehaskell> link
14:32:49 <cdsmithus> awesomehaskell: I see to recall there was a Hackage library for building such things some time ago...
14:32:50 <kmc_> look on http://hackage.haskell.org/packages/archive/pkg-list.html
14:32:51 <kuffaar> awesomehaskell: There is always the C foreign function interface
14:33:14 <kmc_> awesomehaskell, www.eecs.harvard.edu/~mainland/publications/mainland10nikola.pdf
14:33:26 <awesomehaskell> 3rd question  GUI development
14:33:33 <kmc_> awesomehaskell, read Real World Haskell
14:33:36 <kmc_> it has a GTK GUI
14:33:37 <awesomehaskell> ok
14:33:39 <kmc_> the book is free online
14:33:47 <awesomehaskell> web
14:33:53 <kmc_> web
14:34:06 <awesomehaskell> web implementation 
14:34:11 <awesomehaskell> jquery
14:34:15 <awesomehaskell> and so on
14:34:32 <kmc_> haskell web frameworks include happstack, snap, and yesod
14:34:36 <kmc_> there's a bunch of them on the page i just linked
14:34:40 <kmc_> you could try searching google
14:34:44 <kmc_> to answer some of these questions
14:34:47 <cdsmithus> jquery is a JavaScript client-side library, so nothing to do with Haskell
14:35:02 <awesomehaskell> ok.That was my last quesion.Thank you very much 
14:35:23 <awesomehaskell> Have a nice day. :)
14:36:37 <kmc_> you too :) feel free to stick around here while you're learning, it's a great resource
14:37:04 <kuffaar> How do I retrieve an escaped presentation of a String?
14:37:14 <cdsmithus> escaped how?
14:37:22 <kuffaar> Like, "\x00\"" would turn into "\\x00\\\""
14:37:35 <kuffaar> So I can see unprintable characters in their escaped sequences as a string
14:37:39 <monochrom> > show "\x00\""
14:37:40 <lambdabot>   "\"\\NUL\\\"\""
14:37:40 <cdsmithus> Oh... show does Haskell escaping
14:37:42 <kuffaar> To print them to the console for debugging
14:37:46 <mauke> 'print'
14:37:47 <kuffaar> Ah I didn't know
14:37:55 <kuffaar> mauke: Well, print is IO, no?
14:37:57 <kmc_> "show" turns a value into Haskell syntax for that value
14:37:59 <monochrom> yeah print includes show
14:38:01 <kuffaar> I wanted a pure one
14:38:03 <kmc_> print = putStrLn . show
14:38:09 <kuffaar> Ah, right
14:38:10 <cdsmithus> kuffaar: show is pure
14:38:12 <cmars232> thanks kmc, got utf8-string to build
14:38:17 <kuffaar> I forgot that show would work on a String, yeah
14:38:37 <monochrom> > show (show "\x00\"")
14:38:38 <lambdabot>   "\"\\\"\\\\NUL\\\\\\\"\\\"\""
14:38:54 <monochrom> yo dawg, we heard you like escaping...
14:38:59 <kmc> > fix show
14:39:00 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:39:04 <ion> :-)
14:39:28 <kuffaar> kmc I don't get that one 
14:39:37 <kmc> > map length . filter ((=='/').head) . group $ fix show
14:39:41 <cdsmithus> > show (undefined :: String)
14:39:42 <lambdabot>   mueval-core: Time limit exceeded
14:39:43 <lambdabot>   "\"*Exception: Prelude.undefined
14:39:49 <cdsmithus> > show (show (undefined :: String))
14:39:50 <lambdabot>   "\"\\\"*Exception: Prelude.undefined
14:39:52 <cdsmithus> and so on
14:39:58 <kmc> fix f = f (fix f)
14:40:30 <monochrom> you can understand "fix show" by considering show "x", show (show "x"), show (show (show "x"))... and take limit of the sequence.
14:40:42 <kmc> > show (show (show "x"))
14:40:43 <lambdabot>   "\"\\\"\\\\\\\"x\\\\\\\"\\\"\""
14:40:48 <kmc> > show (show (show (show "x")))
14:40:50 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"x\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
14:40:51 <kmc> > iterate show "x"
14:40:52 <lambdabot>   ["x","\"x\"","\"\\\"x\\\"\"","\"\\\"\\\\\\\"x\\\\\\\"\\\"\"","\"\\\"\\\\\\\...
14:40:58 <kmc> > iterate show "x" !! 1000
14:41:00 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:41:00 <monochrom> after a while you also see that the "x" is not very relevant anyway
14:41:04 <kmc> > fix show
14:41:05 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:41:14 <kuffaar> OH, fix
14:41:18 <kuffaar> I read "flip"
14:41:21 <monochrom> yeah, recursion
14:41:36 <kuffaar> I was wondering why flip show even had a Show instance :p
14:41:41 <cdsmithus> kuffaar: Yeah, fix calculates fixpoints of functions by iterating them infinitely many times. :)
14:41:41 <monochrom> haha
14:41:55 <kuffaar> Yeah I'm familiar with fix
14:42:07 <monochrom> cool, you're a haskell expert then
14:42:28 <kuffaar> > let {f x = x^2 - 2; f' x = 2 * x; x_0 = 1} in fix (\iterate f f' x -> let x' = x - f(x) / f'(x) in if abs (x - x') < 10^^(-6) then x' else iterate f f' x') f f' 1
14:42:29 <lambdabot>   1.4142135623730951
14:42:31 <kuffaar> <:
14:42:42 <monochrom> nice
14:42:43 <kuffaar> The first one who can explain what it does gets a cookie
14:43:00 <kmc> my browser is already full of cookies, why would i want another
14:43:04 <monochrom> newton got the cookie
14:43:42 <kuffaar> Newton indeed
14:43:44 <azaq23> uses newton raphson algorithm to calculate the sqrt?
14:43:49 <kuffaar> Yeah
14:43:52 <kmc> http://upload.wikimedia.org/wikipedia/commons/0/0b/Ybc7289-bw.jpg
14:44:02 <monochrom> he says "I steal cookies by sitting on the shoulders of giants"
14:44:02 <kuffaar> > 2^^(0.5)
14:44:04 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:44:04 <lambdabot>    `GHC.Real.Fractional t'
14:44:04 <lambdabot> ...
14:44:11 <kuffaar> :(
14:44:18 <kmc> babylonian tablet c. 1800 BCE
14:44:21 <kuffaar> > 2**0.5
14:44:22 <lambdabot>   1.4142135623730951
14:44:25 <kuffaar> Ah, there we go
14:44:30 <kuffaar> Wow, even all digits match
14:44:33 <ion> > let x₀ = 42 in x₀
14:44:34 <lambdabot>   <no location info>: lexical error at character '\8320'
14:44:52 <kuffaar> I still don't know the difference between ^, ^^ and **
14:45:03 <kmc> :t (^)
14:45:04 <kmc> :t (^^)
14:45:05 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
14:45:05 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
14:45:06 <kmc> :t (**)
14:45:07 <lambdabot> forall a. (Floating a) => a -> a -> a
14:45:20 <kuffaar> Strange stuff
14:45:51 <monochrom> x^y needs y natural and multiplication for x.
14:46:09 <monochrom> x^^y needs y integer and multiplication and division for x.
14:46:18 <kuffaar> <monochrom> cool, you're a haskell expert then <- hardly, I still consider myself to be in the hello world stage really
14:46:31 <ddarius> Indeed.  (^) :: Monoid m => m -> Natural -> m is what it should be.
14:46:40 <monochrom> x**y tries to be too general and so need exp and log.
14:46:45 <ddarius> (^^) :: Group g => g -> Integer -> g
14:47:18 <kuffaar> Are Monoid and Group actual classtypes in Haskell?
14:47:28 <kuffaar> Are there Magma and Field, too? :p
14:47:32 <kmc> kuffaar, in some library probably
14:47:35 <kuffaar> Oh, and Ring? Oh ok
14:47:42 <ddarius> Monoid is a quite common class.
14:47:54 <ddarius> Group and Ring are definitely in some library somewhere.
14:47:54 * hackagebot haskell-xmpp 1.0 - Haskell XMPP (eXtensible Message Passing Protocol, a.k.a. Jabber) library  http://hackage.haskell.org/package/haskell-xmpp-1.0 (DmitryAstapov)
14:48:00 <cdsmithus> kuffaar: Monoid is a type class.  Group is not in base, but could be a type class.  For example, I'm sure numeric prelude makes it one
14:48:11 <kuffaar> I'm not sure I'll have any of those algebraic structures in my web dev project
14:48:11 <ddarius> As well as EuclideanDomain
14:48:23 <ddarius> kuffaar: I'm quite sure you'll have free monoids.
14:48:26 <cdsmithus> Num is *approximately* ring... it's a ring with a few extra things thrown in.
14:48:28 <monochrom> you just need booleans for web
14:48:34 <ion> kuffaar: Btw, i updated http://heh.fi/state-monad
14:48:37 <kuffaar> ddarius: Implicitly :p
14:48:45 <ddarius> kuffaar: Quite explicitly.
14:50:00 <cdsmithus> Yeah, wouldn't it be more Haskellesque of us to rename Data.List to Data.FreeMonoid?  Where do I propose that? ;)
14:50:16 <kmc> yep
14:50:22 <kmc> i look forward to a rash of free monoid tutorials
14:50:25 <j-invariant> cdsmithus: LOL
14:50:29 <kmc> you see a free monoid is like a train
14:50:36 <kmc> you can "couple" "cars" onto the front or the back
14:50:40 <kmc> and also there's an empty train with zero cars
14:50:41 <cdsmithus> A train full of burritos?
14:50:44 <kmc> but hey, it's not a perfect analogy
14:50:48 <kuffaar> ion: Thanks, bookmarked
14:50:59 <kuffaar> But right now I'm just dealing with TCP basics in Haskell
14:55:28 <joe6> guys: can you please look at these type definitions and share your thoughts: http://codepad.org/tUzJHgU0
14:55:53 <joe6> the "
14:56:29 <joe6> the "Out" and "In" data definitions are pretty similar and I would like to add in a dir field and club them both together.
14:56:36 <luqui> what is the recommended way to install ghc7 on ubuntu?
14:56:49 <cdsmithus> joe6: you're using constructors as if they were types...
14:57:15 <kuffaar> luqui download the tar bz2 and read the instructions on how to compile it? :o
14:57:25 <kuffaar> You need ghc6 to compile it though
14:58:08 <ddarius> The tarball is a binary.  You don't need to compile it.
14:58:24 <cdsmithus> There are nightly snapshot builds, too... but be ready to fight with a lot of libraries.  The Haskell Platform including GHC 7 is not out yet; so while the GHC team supports the compiler, using GHC 7 with widely used libraries won't necessarily work
14:58:41 <cdsmithus> Umm, that was confusing.  The nightly snapshots aren't GHC 7
14:58:52 <cdsmithus> I meant there are compiled builds of GHC 7. :)
14:58:54 <joe6> cdsmithus: oh, sorry just noticed that 
14:58:55 <luqui> ok so no deb package or anything yet?  thx
14:58:57 <joe6> thanks.
14:59:15 <kuffaar> luqui it's probably going to take 6-18 months
14:59:18 <kuffaar> As usual
14:59:26 <luqui> k
14:59:46 <cdsmithus> Actually, once the Haskell Platform is released, Ubuntu will typically have packages far faster than 18 months.
15:00:23 <Phyx-> that's not really something to boast about
15:01:15 <hpc> Phyx-: considering the ubuntu repos are debian testing, perhaps it is :P
15:01:36 <cdsmithus> I wasn't boasting... just pointing out that 18 months is misleading.
15:01:48 <kuffaar> Debian and Ubuntu packages tend to be quite old and it takes quite a while before anything new kicks in, it's one of the reasons why I switched to Gentoo and later Arch, I'm a bleeding edge moron
15:02:41 <Phyx-> hpc: lol
15:02:52 <Tomsik_> bleeding edge mormon
15:02:59 <kuffaar> No, I'm an atheist
15:03:38 <Phyx-> is it just me, or is the internet utterly boring lately?
15:03:48 <Tomsik_> at heist?
15:03:54 <ddarius> Phyx-: It's just you.  The internet has always been boring.
15:03:59 <kuffaar> Tomsik_: No, actually I stopped using Heist
15:04:04 <Tomsik_> Phyx-: yeah, I have the same feeling lately
15:04:09 <kuffaar> Because it ruined my pretty markup :(
15:04:12 <Tomsik_> It's like all the internet went BOORING
15:04:14 <Tomsik_> Man.
15:04:26 <Tomsik_> kuffaar: :(
15:04:30 <kuffaar> Phyx-: I haven't noticed any difference, still consuming new series, IRCing and gaming etc
15:04:36 <kuffaar> Same old, same old
15:05:27 <cdsmithus> "capitalized DOCTYPE the way it's supposed to be" /= "ruined".  But oh well.
15:05:30 <Phyx-> ddarius: lol
15:05:35 <kmc> Phyx-, you could try to start another argument in #haskell-blah
15:05:42 <kmc> that's usually fun times
15:05:46 <Phyx-> Tomsik_: good to know i'm not alone
15:05:53 <Phyx-> kmc: i'm too hungry for that :P
15:06:00 <kuffaar> Tomsik_: Being the Bleeding Edge Moron I am, my templates were all HTML5 and then Heist XMLified them by upper-casing the doctype statement and adding slashes to void tags :'(
15:06:07 <Phyx-> I can't troll on an empty stomach
15:06:16 <Phyx-> kuffaar: irc itself is quite boring lately
15:06:21 <kmc> can't eat a $4000 watch?
15:06:24 <kmc> ;)
15:06:26 <Phyx-> the proof is that i'm only in #haskell and #haskell-blah
15:06:40 <Phyx-> kmc: nah, it can only do one thing at a time, so it's doing the laundry
15:06:42 <monochrom> troll #haskell-blah with haskell questions
15:06:59 <monochrom> wait, your stomach does your laundry?
15:07:00 <kuffaar> Phyx- start warezing tons of series then
15:07:08 <Tomsik_> yeah, I could even argue on religion, I find internet that boring latetly
15:07:13 <hpc> doesn't html5 allow you to omit the doctype?
15:07:22 <cdsmithus> Yes, it does.
15:07:31 <hpc> cool, i thought i was missing something
15:07:33 <Tomsik_> kuffaar: no idea, I try to keep away from html, xml, etc. :p
15:07:39 <Phyx-> it does?
15:07:39 <hpc> since that was the main draw to me using it on my website
15:07:52 <hpc> not having to google that bullshit tag
15:08:12 <kuffaar> Well, I prefer being explicit
15:08:13 <Phyx-> well, I know that IE uses the doctype to determine if it should render in "old-IE compat mode" or just html5 compliant
15:08:30 <kuffaar> hpc: It's not a good website until IE6 and IE7 can't even open it
15:08:38 <cdsmithus> It's actually recommended to leave it in because of browser compatibility behavior.  But, you're also allowed to just say <!DOCTYPE html>
15:08:51 <kuffaar> Or <!doctype html>
15:08:53 * kuffaar smirks
15:08:54 <hpc> kuffaar: well, it looks nice on my android phone
15:08:57 <hpc> does that count?
15:09:53 <hpc> hmm, why does my website have a meta tag marking it as utf-8..
15:10:30 <monochrom> I added it
15:10:56 <hpc> oh, that makes sense
15:11:17 <Phyx-> hax!
15:11:29 <kuffaar> You forgot to say "Thank you"
15:11:37 <Phyx-> hrm.. why can't i get a straight answer from nintendo's tech support
15:15:38 <kuffaar> Haha I just spent like trying to figure out why ghc was giving me "empty do statement"
15:15:45 <kuffaar> *spent like 10 minutes
15:16:00 <kuffaar> It wasn't until now that I realised that "data" is a reserved word in Haskell
15:16:20 <kuffaar> Unlucky choice for a binding name
15:16:37 <kuffaar> The highlighting in haskell-mode really should have given it away
15:16:38 <mreh> kuffaar: syntax hilighting?
15:16:41 <kuffaar> mreh yeah
15:16:43 <mreh> lol
15:16:54 <kuffaar> I am so not used to "data" being a keyword
15:17:05 <kuffaar> I use terribly generic names like that all the time
15:17:11 <mreh> yeah
15:17:13 <kuffaar> My code tends to be full of input, output and data names
15:17:29 <mreh> data is rather a generic name for a variable
15:17:32 <doserj> just use i, o, and d then :)
15:17:52 <kuffaar> doserj: No, I think that single letter names are terrible style
15:17:54 <monochrom> and the use of the name "test" for toy programs on unix
15:17:54 <kuffaar> I never do that in Haskell
15:18:17 <kmc> i think the length of a  variable name should be proportional to its scope
15:18:20 <Phyx-> which... reminds me, need to fix a syntax highlighting bug
15:18:27 <kuffaar> kmc: That sounds like a reasonable rule of thumb
15:18:30 <mreh> meh, single letter names are great, then in tuples you combine them, and lists you add an 's'
15:18:31 <ddarius> Hmm... I grew a stitch somehow.
15:18:31 <joe6> hello guys, any thoughts on these type definitions: http://codepad.org/V2Djeq5e
15:18:33 <kuffaar> Phyx- in what code?
15:18:37 <kmc> but Haskell shouldn't need one-letter vars so much, because we often have zero-letter vars
15:18:43 <joe6> please
15:18:46 <kmc> you don't need to say (\x -> x+2) if you can say (+2)
15:18:51 <Phyx-> kuffaar: visual haskell
15:18:53 <mreh> kmc: not inversely so?
15:18:57 <kuffaar> Ah right :p
15:19:04 <shachaf> monochrom: Not a.out?
15:19:07 <kuffaar> Another brave Windows user, eh?
15:19:10 <kuffaar> Phyx- do you use ghc 7?
15:19:17 <Phyx-> kuffaar: yup
15:19:25 <Phyx-> to both questions
15:19:34 <monochrom> a.out is C only. consider shell scripts.
15:20:12 <kuffaar> It took me ages to set up ghc 7 with all my dependencies on Windows, but then I stopped using Snap and Heist etc so it's not as much work anymore
15:20:22 <monochrom> "I want to write a shell script to test the behaviour of if-then-else. I'll call it test."
15:20:22 <mreh> I just discovered liftMn for ((->) a) today, man that's good shorthand
15:20:33 <Phyx-> kuffaar: why.. didn't you just double click on the installer?
15:20:52 <kmc> i'm going to start calling all my test scripts [
15:20:56 <mreh> @help
15:20:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:21:01 <kuffaar> Phyx-: A lot of my dependencies can't be installed from HackageDB
15:21:06 <kuffaar> They don't compile with ghc 7
15:21:23 <Phyx-> which dependencies are you talking about here?
15:21:35 <Phyx-> ghc pretty much comes with all it's corelibs
15:22:33 <hpc> mreh: you mean you haven't discovered applicative style yet?
15:22:51 <kuffaar> Takusen, snap, heist, openid, yesod, happstack, network
15:22:54 <hpc> liftMn f x.. = f <$> x <*> ..
15:23:04 <mreh> hpc: it's rather underappreciated, so I've never seen many examples
15:23:10 <mreh> but yes, I know Applicative
15:23:12 <kuffaar> For example, we actually had to write a patch for unix-compat which is a dependency of uh snap to make it work with ghc 7 on Windows
15:23:16 <hpc> ah
15:23:20 <kuffaar> On Linux it doesn't even require a patch
15:23:36 <kuffaar> I also had to apply an unofficial patch to hint
15:23:42 <hpc> although i can see the appeal of being able to lift the whole function at once
15:23:43 <kuffaar> Because it does not compile with ghc 7
15:23:48 <Phyx-> kuffaar: the patch would have been to remove "unix" at all from any cross platform package
15:23:58 <hpc> so you can say applyOodlesOfActions = liftM6 f
15:24:02 <hpc> or something like that
15:24:12 <Phyx-> i have always been quite against using packages like unix or unix compat. But i'm in the minority
15:24:50 <hpc> i am not against using them
15:24:51 <kuffaar> Phyx- so am I but tons of Linux developers are just as bad about portability as the Windows ones :()
15:24:55 <hpc> i am against using them /everywhere/
15:24:56 <Phyx-> kuffaar: regardless, problems with a package that uses unix is neither windows nor ghc7's fault though
15:25:13 <kuffaar> Phyx- I never said or implied it was :o it's still a lot of work
15:25:15 <Phyx-> the "easy" alternative is to use cygwin
15:25:23 <hpc> fuck cygwin
15:25:25 <kmc> the easy alternative is don't use Windows
15:25:25 <kuffaar> Nah, cygwin doesn't always work
15:25:31 <hpc> i would rather write a VM by hand, myself
15:25:35 <kuffaar> As soon as something requires fork, it will crash sooner or later
15:25:36 <Phyx-> hpc: here here
15:25:38 <BMeph> cygwin in the Devil! >:(
15:25:43 <kmc> setting up Ubuntu in a VM is probably easier than setting up Cygwin
15:25:44 <BMeph> *is
15:25:49 <Phyx-> kuffaar: yeah, i hate cygwin too
15:25:50 <monochrom> hehe
15:26:17 <kuffaar> It's just can't do what fork needs
15:26:20 <kuffaar> It's a limitation
15:26:31 <mreh> my boss wants to put me on a MSCE course, I think they're trying to bring me down to their level
15:26:33 <kuffaar> It would need a modified kernel to pull it off properly
15:26:34 <kmc> so it implements vfork and calls it fork?
15:26:44 <kuffaar> kmc: It can't implement either I think?
15:26:52 <kmc> then how does any unix software work at all
15:27:03 <kuffaar> kmc: Most stuff doesn't require fork
15:27:04 <Phyx-> lol, some of the new tokens in GHC7 i have no idea what they do..
15:27:06 <kmc> every process in unix is started through fork
15:27:13 <kmc> except the first one
15:27:15 <kmc> (more or less)
15:27:16 <kuffaar> But if it does, then it uses a terrible hack
15:27:45 <kuffaar> It involves emulating the behaviour of fork but it breaks easily due to DLL injection and such
15:27:52 <kuffaar> And possibly some ASLR stuff, too
15:27:56 <monochrom> most of the time you just need "spawn".
15:28:08 <kmc> all you need is clone *whistles*
15:28:11 <kuffaar> In general you really just want to use a Linux VM on top of Windows yeah
15:28:20 <kmc> virtualization used to be more expensive
15:28:20 <kuffaar> If you don't want it to break
15:28:29 <kuffaar> I run a Linux VM on top of Windows all the time
15:28:30 <kmc> Also sometimes you want tight integration with Windows apps
15:28:36 <kuffaar> Mostly just to run... *drumroll* whois.
15:29:07 <Phyx-> did i just inadvertedly start a windows bashing session? :/
15:29:19 <hpc> i suppose it was me that did
15:29:22 <kuffaar> Phyx-: Nobody has even bashed Windows yet have they?
15:29:25 <hpc> with the "fuck cygwin" comment
15:29:43 <Tomsik_> I remember how long time ago I got fed up with windows cmd being made of suck
15:29:43 <hpc> (i don't apologize though)
15:29:54 <Tomsik_> and added cygwin's bin/ to $PATH
15:29:54 <Phyx-> kuffaar: not true :P "00:28:22 < kmc> the easy alternative is don't use Windows"
15:30:02 <Tomsik_> and then it almost felt like a console
15:30:17 <Phyx-> Tomsik_: i use console with powershell
15:30:22 <kmc> the main advantage of not using windows is that people can't ask you to fix their windows machine
15:30:24 <Phyx-> that combo is made of win
15:30:35 <kmc> i have absolutely no idea how to fix anything on Vista or Windows 7
15:30:38 <kuffaar> Phyx-: Do you mean Konsole2 or whatever it's called?
15:30:46 <Phyx-> kmc: i don't use macs, but constantly get asked to fix macs
15:30:54 <kmc> but you have a credible way to decline
15:31:23 <monochrom> I agree.
15:31:31 <Phyx-> kuffaar: no, Console, a sourceforge project http://sourceforge.net/projects/console/
15:31:40 <kuffaar> Yep that's it
15:31:45 <kuffaar> Console2, right
15:31:56 <Phyx-> kmc: the reply i get is most often "but, it's a computer isn't it? and you study computers"
15:32:00 <kuffaar> Phyx-: The whole csrss/cmd terminal annoys me so much that I actually attempted to write a replacement but it's only a stdin/stdout/stderr redirector pretty much which will break for most stuff really - what you need is a full emulator which hooks like 30-50 calls in user32.dll
15:32:10 <kuffaar> http://siyobik.info/paracletus/
15:32:28 <kuffaar> I will attempt to write a proper one at some point
15:32:34 <kuffaar> But it will be an immense amount of work
15:32:53 <monochrom> I answer "I only do the theory"
15:33:34 <Phyx-> kuffaar: Console handles all those points mentioned i think
15:33:38 <kuffaar> console has no use for me either, it doesn't even support maximisation IIRC and it didn't support copying the first byte due to some selection issue
15:33:42 <Phyx-> monochrom: lol
15:33:50 <monochrom> "I don't use windows and I know nothing of viruses" fends off 99% of requests for volunteered tech support
15:33:54 <Tomsik_> Well, when people ask me to fix a computer I fall back to a kind of an adaptative DFS
15:34:00 <kuffaar> monochrom haha
15:34:01 <hpc> i answer with "right, so first we install gentoo.."
15:34:04 <hpc> that shuts them right up
15:34:05 <kuffaar> hpc :D
15:34:08 <Tomsik_> :D
15:34:14 <kuffaar> hpc they don't even know what Gentoo is
15:34:18 <kuffaar> It would be lost on them
15:34:26 <Tomsik_> Okay, gotta try that technique
15:34:32 <hpc> well, after i explain what gentoo is
15:34:35 <Phyx-> i really don't get what the deal is with windows and viruses. I don't understand how people get them
15:34:45 <monochrom> http://xkcd.com/627/ may also be helpful
15:34:48 <hpc> Phyx-: shitty code mostly
15:34:51 <Phyx-> i'm not kidding here, how does someone unwillingly get a virus...
15:35:05 <hpc> browser plugins, office macros
15:35:07 <Tomsik_> Phyx-: they don't know what links in google are BAD
15:35:14 <Tomsik_> when they look for porn and warez
15:35:15 <Phyx-> monochrom: lol
15:35:17 <Tomsik_> that's my guess
15:35:19 <hpc> and yeah, 90% of the world using windows helps
15:35:23 <kuffaar> Phyx- people will do anything ads say and they will willingly install any new toolbar because they believe it will help them or becaue it's necessary to use websites etc
15:35:47 <kuffaar> In the past it was even mostly just the RPC exploits etc but now it's actually less frequently remote exploits, I think
15:35:57 <Phyx-> kuffaar: that is true. I want to stab google for trying to push their crappy desktop stuff on people
15:36:07 <Phyx-> google toolbar and desktop search are the devil
15:36:14 <Phyx-> those things are worse then norton
15:36:15 <hpc> indeed
15:36:20 <kuffaar> Phyx-: I install untrusted binaries on Windows all the time
15:36:33 <kuffaar> Because sometimes I just need to quickly find a program which does job XYZ
15:36:45 <hpc> the mere existence of google toolbar and desktop legitimizes all the shitware people like to install by accident
15:37:09 <Phyx-> i find it odd the selection of sites peddling that crap
15:37:16 <Phyx-> you go to adobe to install flash
15:37:30 <Phyx-> and if you don't uncheck a checkbox, you get a google toolbar too
15:37:33 <Phyx-> bleh
15:37:42 <hpc> oh yes, that too
15:38:13 <Phyx-> or you install itunes to sync with your stupid ipod, and you get safari out of no where asking to be your default
15:38:14 <hpc> the "uncheck this box to not install some optional thing"
15:38:27 <hpc> Phyx-: also when itunes updates
15:38:36 <hpc> and you have to download 90Mb
15:38:44 <hpc> and then in a week it updates again
15:38:44 <Tomsik_> it's annoying with windows -- you want to install anything? Go to its motheraching web page, download, click, look at some damn progress bar...
15:39:07 <Phyx-> hpc: heheh
15:39:12 <Phyx-> Tomsik_: i don't get it :P
15:39:14 <hpc> windows install method isn't so bad
15:39:27 <Phyx-> windows has had unattended installs for ages
15:39:31 <hpc> i mean, on linux you have repos, but when something is not in those
15:39:36 <Phyx-> you don't want to look at a progressbar, you don't have to!
15:39:41 <hpc> it can sometimes be a pain
15:40:05 <Tomsik_> sometimes, not everytime
15:40:12 <hpc> being able to install $obscure_program with just a few clicks is nice
15:40:22 <Tomsik_> and updates, I can't imagine anyone updating all their software on windows
15:40:54 <Phyx-> kuffaar: i maintain the oppinion that windows isn't as bad as people say, there's just no cure for the lack of common sense is some people
15:41:59 <hpc> Phyx-: agreed
15:42:08 <kuffaar> Phyx- well I wish I had the choice between different WMs/DEs and a unified UNIX like filesystem and a unified package management system with nearly everything I need like pacman or apt-get etc
15:42:12 <hpc> updating software on windows goes quite smoothly
15:42:18 <kuffaar> In fact I want to code something like that for Windows
15:42:26 <kuffaar> Something like pacman/apt-get
15:42:30 <Phyx-> Tomsik_: http://coapp.org/
15:42:33 <hpc> even if each program has a separate update mechanism
15:42:34 <kuffaar> pacman -S photoshop-cs5
15:43:08 <pastorn> i'm writing me some haddock... what's "stability" and "portability"?
15:43:19 <pastorn> and how do i know what to put in my header?
15:43:24 <hpc> "stability" == "shit don't crash"
15:43:29 <kuffaar> pastorn: Stability is like stable vs. experimental
15:43:32 <hpc> "portability" == "shit run everywhere"
15:43:39 <pastorn> nice
15:43:40 <pastorn> thanks :D
15:43:42 <Phyx-> portability = will shit run on anything else
15:43:44 <kmc> i thought stability was more like "will the API change"
15:43:48 <kmc> i ignore those fields
15:43:52 <kmc> they mean almost nothing
15:43:54 <Phyx-> kmc: hmm true
15:44:01 <pastorn> i'm doing X.Types now, so this might change
15:44:13 <pastorn> then things everywhere might blow up
15:44:28 <pastorn> should i mark it as unstable or experimental?
15:44:30 <hpc> then they can just not update
15:44:35 <pastorn> and what's meant by "provisional"?
15:44:51 * hpc is of the view that an API can change at any time, but only if you change the version you are using
15:44:53 <pastorn> hpc: huh? not update?
15:45:16 <Phyx-> Tomsik_: seen the link?
15:45:27 <joe6> hello pastorn
15:45:32 <pastorn> joe6: hey :)
15:45:38 <Tomsik_> yeah
15:45:43 <pastorn> joe6: how's it been going?
15:45:44 <hpc> pastorn: yeah, as in stick to version 1.x or whatever
15:45:59 <pastorn> hpc: no, this is for writing my own shit (not to be released)
15:46:04 <hpc> oh
15:46:04 <joe6> pastorn: I am slowly working through the changes
15:46:07 <Tomsik_> might be useful if I ever have to work with windows on a prolonged basis :p
15:46:24 <hpc> then why bother with getting haddock fields all populated?
15:46:43 <pastorn> hpc: because i'm a believer in commented code
15:46:59 <pastorn> why is this controversial?
15:47:00 <joe6> pastorn: This is the structure that I have come up with when reading the txns: http://codepad.org/V2Djeq5e
15:47:19 <pastorn> joe6: dude, line lengths! please!
15:47:21 <pastorn> you're killing me
15:47:27 <joe6> oh, sorry
15:47:34 <joe6> will change it 
15:47:45 <monochrom> killing you softly with 42" screens
15:47:45 <joe6> i use a widescreen monitor, hence the long line lengths
15:47:53 <monochrom> QED
15:47:55 <kuffaar> joe6: I always split up stuff with a comma in it really
15:48:03 <hpc> joe6: use an 80x24 terminal
15:48:06 <kuffaar> {\na,\nb,...
15:48:10 <hpc> you will learn good style quickly
15:48:13 <pastorn> joe6: this is very good, i follow it: http://snapframework.com/docs/style-guide
15:48:17 <kmc> the point of having a big monitor is to fit as many 80x24 terminals as possible
15:48:18 <joe6> ok, thanks will do.
15:48:21 <kuffaar> Some use blah { a\n *, b...
15:48:22 <monochrom> this is why I want all programmers condemned to 10" netbooks. all.
15:48:30 <Phyx-> line lengths?
15:48:36 <pastorn> monochrom: actually i have 2 * 1600x1200 screens
15:48:37 <Phyx-> oh
15:48:38 <hpc> monochrom: it also will make them write fast code
15:48:40 <Phyx-> the codepad
15:48:53 <Phyx-> hah... i had a teacher that deducted points for long lines of code
15:49:07 <mreh> mice are locked up in a cupboard, only removed when you want to design a GUI
15:49:12 <mreh> also GUIs are banned
15:49:18 <pastorn> joe6: just so you know, the optimal line length for human reading (non-monospaced font) is 68 or so characters / line
15:49:36 <mreh> that's why newspapers are in short columns
15:49:42 <kmc> and LaTeX
15:49:44 <joe6> pastorn: oh, ok.
15:49:44 <pastorn> 100+ char lines are just silly
15:49:45 <merijn> I figure someone here would know: Is there like an aggregator site for CS summer schools somewhere?
15:49:57 <joe6> pastorn: the style guide that you sent is pretty good.
15:50:11 <monochrom> perhaps the next generation of kids grow up to be optimized for 200-character lines.
15:50:35 <pastorn> joe6: this looks really good, except for the missing newlines ;)
15:50:45 <Phyx-> not likely... with twitter being popular
15:50:53 <mreh> newspapers have been around for 100+ years
15:50:54 <kuffaar> joe6 you use spacing around :: inconsistently btw
15:50:59 <joe6> pastorn: ok, thanks. will ping as it gets better
15:51:02 <kuffaar> I see a :: b and a:: b and a::b
15:51:06 <monochrom> ok 140-character lines!
15:51:09 <kmc> a∷b
15:51:28 <monochrom> I find that the young ones simply have the urge to maximize all windows
15:51:34 <pastorn> joe6: maybe you'll want to tag all your record fields with datatype abbreviations, so in ControlTransaction, rename description to ctDescription
15:51:36 <kmc> what's the longest-running terminating Haskell program that fits in 140 characters
15:51:39 <kuffaar> I run everything maximised really
15:51:43 <kmc> maybe some of you busy beavers can figure this out
15:51:47 <kuffaar> My emacs and my IRC client are maximised simultaneously
15:51:50 <merijn> kmc: Oh, nice contest
15:51:58 <monochrom> QED
15:52:01 <pastorn> kmc: main = newEmptyMVar >>= takeMVar
15:52:03 <Phyx-> can it be a trivial program?
15:52:08 <pastorn> oh, terminating
15:52:08 <joe6> ok, thanks
15:52:10 <Tomsik_> kmc: you bastard
15:52:11 <pastorn> you boring person
15:52:11 <kuffaar> And I'm 24, which makes me young enough hopefully
15:52:20 <kmc> i don't care what it does.  just that it runs for a long time and then exits
15:52:26 <hpc> main = sum [1..]
15:52:33 <j-invariant> that doesn't terminate
15:52:36 <Phyx-> hpc: doesn't terminate
15:52:36 <pastorn> hpc: won't terminate
15:52:39 <hpc> main = sum [1..] `seq` return ()
15:52:43 <kmc> and exits for real, not with a stack/heap overflow
15:52:49 <hpc> it terminates
15:52:51 <pastorn> kmc: main = threadDelay maxBound
15:52:57 <Tomsik_> Well, for easy starters
15:52:59 <kmc> pastorn, no way.  that's hardly 30 minutes
15:53:07 <Tomsik_> as many nested ackermanns as you can
15:53:08 <hpc> :t threadDelay
15:53:09 <lambdabot> Not in scope: `threadDelay'
15:53:32 <pastorn> forM [1..(maxBound :: Word64)] $ (const (threadDelay maxBound))
15:53:44 <pastorn> maybe i'm pressing the 140 chars here...
15:53:50 <pastorn> (with imports etc.)
15:54:18 <monochrom> threadDelay (ackermann 56) or something
15:54:18 <Phyx-> i've always wondered one thing
15:54:19 <kmc> i bet you can do slower with some maths
15:54:37 <pastorn> kmc: perhaps if you do lots of list lookups
15:54:41 <pastorn> !! is pretty short to write
15:54:42 <kmc> i bet just computing ackermann (ackermann 100) takes far longer than all those threadDelays
15:54:47 <kmc> you're not thinking big enough
15:54:52 <pastorn> hehe
15:54:54 <Tomsik_> that's what I said
15:55:00 <monochrom> actually, replicateM_ (ackermann 56) (threadDelay 49384954) or something like that
15:55:05 <merijn> kmc: Wouldn't you run out of RAM fairly quickly?
15:55:07 <kmc> by the way i don't require that the program terminates in the lifetime of the universe or on a computer small enough to be constructed in our universe
15:55:15 <hpc> merijn: probably not quickly, but eventually
15:55:26 <Tomsik_> monochrom: threaddelay probably is nothing compared to adding one or two to the number next to ackermann
15:55:26 <Phyx-> 42
15:55:39 <hpc> kmc: that's too easy
15:55:46 <pastorn> joe6: why do you have String in your records? Shouldn't that be lazy bytestrings?
15:55:50 <merijn> hpc: Well, ackerman gets big enough fast enough that it'd be an issue I guess
15:55:52 <hpc> more fun to make it like blackjack
15:55:57 <Tomsik_> hpc: not at all, it's undecideable
15:56:03 <pastorn> joe6: or are the string fields actually ascii text?
15:56:06 <hpc> as long as possible, but on a computer with limited memory
15:56:16 <merijn> But anyway, so there is no summer school aggregation site? :p
15:56:32 <Tomsik_> on limited memory it's trivial hpc 
15:56:36 <monochrom> I haven't heard of a cs summer school aggregate site.
15:56:45 <mreh> lets make one
15:57:03 <kmc> it is not trivial to determine the longest-running program for a machine of limited memory n
15:57:10 <monochrom> but walking around the corridors of cs prof offices may reveal several cs summer school posters
15:57:15 <merijn> I've seen multiple interesting summer school announcement fly by but it is hard to keep track and I'd hate if I miss another interesting one like the category theory for programmers one...
15:57:15 <Tomsik_> you just add one to counter as long as your memory till you get all ones, starting from 0
15:57:22 <kmc> unless you have an odd idea of "trivial"
15:57:30 <kmc> Tomsik_, you can make much longer running than that
15:57:34 <Tomsik_> you can
15:57:36 <Tomsik_> 't
15:57:38 <kmc> hmm
15:57:41 <monochrom> you will need to get to know those profs for those summer schools anyway. (to get them recommend you.)
15:57:44 <mreh> merijn: that's not a productive way to operate I find
15:57:45 <Tomsik_> you'll loop if you can
15:57:45 <kmc> no you can't
15:57:48 <kmc> yeah, you're right
15:57:49 <hpc> yeah, Tomsik_'s hits every state
15:57:57 <kmc> hmm
15:58:03 <merijn> mreh: Elaborate?
15:58:07 <hpc> the fun though, comes from writing that in 140 characters of haskell
15:58:33 <mreh> merijn: sorry I misunderstood what you were saying
15:58:52 <Tomsik_> Integers are of unlimited size, aren't they
15:59:04 <monochrom> if given no memory limit
15:59:07 <mreh> Tomsik_ if you have the memory
15:59:11 <Tomsik_> yeah
15:59:16 <monochrom> and time
15:59:17 <Tomsik_> that's what we're doing right now
15:59:40 <merijn> Tomsik_: You can write longer programs then that...
15:59:54 <sshc> Is there a construct in Haskell similar to C's __LINE__ and __FILE__ macros?
16:00:11 <kmc> yes, and it's the same construct
16:00:14 <kmc> just enable the CPP extension
16:00:17 <merijn> sshc: A swift thwack on the head by the compiler, hopefully...
16:00:19 <luqui> if we lump instruction pointer and registers etc. into "memory", then I think Tomsik_'s is the longest running program
16:00:22 <pastorn> sshc: what do they do?
16:00:25 <Tomsik_> fix (\f n -> if n < 2^memory then 0 else f (n+1)) -- ?
16:00:52 <merijn> luqui: What if you add more code to make (a now slightly shorter loop) multiple times?
16:01:08 <luqui> merijn, how would you keep track of how many times to do it?
16:01:12 <Tomsik_> well, that comparision is wrong but
16:01:14 <joe6> pastorn: no, it is just the representation of the input data structures still. I am moving away from strings.
16:01:47 <mreh> I think the way that kmc worded the question was the biggest clue "what's the longest running program"
16:01:52 <joe6> pastorn: it is still early . i plan to add in the changes
16:01:59 <mreh> there had to be some theoretical reason for that
16:02:12 <luqui> although i am intuitively unconvincing myself of that... hmmm... this is tough.
16:02:14 <merijn> mreh: longest running non-abnormally terminating program, to be exact
16:02:42 <Tomsik_> merijn: well, if you run longer it means you hit the same state twice
16:02:47 <Tomsik_> it means you're in a loop
16:02:54 <Tomsik_> (longer than the number of states)
16:02:57 <luqui> yeah.  computer :: Memory -> Memory
16:03:15 <mreh> is the proof of that, if you want it to run longer, you have to add more memory?
16:03:17 <merijn> Tomsik_: So? Nothing specified you couldn't repeat states, as long as you somehow terminate normally
16:03:21 <luqui> so if it terminates, it's period has to be <= |Memory|
16:03:28 <luqui> er, not period
16:03:30 <luqui> you know what i mean
16:03:41 <Tomsik_> merijn: you _won't_ terminate if you hit the same state
16:03:46 <Tomsik_> twice
16:04:04 <aristid> hmm, not beautiful: get >>= \x -> case f x of ...
16:04:09 <merijn> Tomsik_: That's only true if you program is deterministic, which was not a requirement :>
16:04:15 <Tomsik_> because you'll do exactly the same thing the second time
16:04:19 <Tomsik_> heh
16:04:25 <luqui> aristid, there was a recent thread on haskell-cafe discussing how to design the language to clean that up.
16:04:35 <Tomsik_> well, not really
16:04:41 <aristid> luqui: what was proposed?
16:04:49 <kmc> whee \case
16:04:57 <kmc> also do case
16:04:59 <luqui> aristid, heh, don't remember.  not that interested in syntax these days. :-P
16:05:12 <Tomsik_> merijn: because if you hit the same state again it means that there were no accepting states on your path
16:05:14 <kmc> but syntax is the most important and interesting part of programming languages!
16:05:15 <kmc> [/troll]
16:05:20 <Tomsik_> (/in your tree)
16:05:48 <Tomsik_> nondeterminism always chooses the accepting path if there's any ;p
16:06:20 <luqui> have you ever done a ;p in real life.  it looks really dumb.
16:06:45 <aristid> ;p
16:06:50 <Tomsik_> It's a keyboard slip
16:06:52 <mreh> luqui: you have reterned
16:07:01 <Tomsik_> shift and ';' not pressed simultaneously
16:07:15 <merijn> Tomsik_: Theoretic nondeterminism maybe, but I fail to see how that holds for actual nondeterminism in a computer program
16:07:19 <luqui> mreh, apparently so.
16:07:19 <mreh> luqui: still into games?
16:07:31 <Tomsik_> merijn: what's "actual nondeterminism"? :p
16:07:37 <Tomsik_> You mean like, randomness?
16:07:37 <luqui> kinda.  still making our game, but also in school now so it's pretty slow going.
16:07:42 <merijn> Yes
16:07:50 <luqui> also have 2 personal projects at the same itme.
16:07:54 <luqui> i'm like that
16:07:54 <Tomsik_> That's interaction with outside world?
16:08:09 <Tomsik_> You could then have a human with a ton of paper and a pencil
16:08:12 <mreh> luqui: I should think most of us are in here
16:08:19 <merijn> I'm pretty sure the longest running program will be a Monte Carlo simulation looping on some random condition :p
16:08:23 <Tomsik_> which would extend your memory, yer cheating
16:08:36 <kmc> with what seed merijn?
16:08:43 <kmc> pick the longest one
16:09:04 <ddarius> There are multiple notions of "non-determinism."  For example, angelic, demonic, erratic.
16:09:09 <merijn> kmc: Not if you read /dev/urandom (hooked up to one of those fancy 7.9 bits of entropy per byte machines)
16:09:20 <luqui> not pseudorandom, but getting some randomness from the outside world
16:09:25 <luqui> but then you're kind of coupling the question to the world
16:09:29 <luqui> which has a lot more states than your memory
16:09:33 <merijn> True
16:10:09 <Tomsik_> It's then like
16:10:19 <mreh> luqui: have you heard of Ed Byrne?
16:10:30 <Tomsik_> read, if "quit" then exit else goto begin
16:10:44 <Tomsik_> that's not something we wanna talk about
16:10:57 <Tomsik_> also, if you get input from outside, you can't prove you'll halt 
16:11:07 <Tomsik_> maybe you'll wait for the keypress forever
16:11:16 <luqui> but if it's truly random input, then you could halt with probability 1
16:11:19 <merijn> If you're running on actual hardware you can't prove you'll halt either
16:11:37 <kuffaar> What function do I use to convert a [GHC.Word.Word8] to String?
16:11:42 <luqui> mreh, don't think so
16:11:47 <Tomsik_> P != NP with probability 1, yet nobody thinks it's proven that P != NP
16:11:49 <merijn> luqui: Hence why I said the longest running program is probably a Monte Carlo with a random chance of exiting
16:11:55 <aristid> amazingly, StateT can make code more readable
16:11:58 <mreh> luqui: was reading about your improvisation, check him out
16:12:04 <mreh> he is the best
16:12:07 <merijn> Tomsik_: Where are you pulling that probability from?
16:12:15 <luqui> kuffaar, you mean like "42", or like the character from that charcode, or what
16:12:16 <kuffaar> merijn: From Tomsik.Arse
16:12:19 <hpc> aristid: StateT is perfectly capable of making readable code :P
16:12:22 <Tomsik_> It's some proof based on oracle machines I think
16:12:26 <merijn> kuffaar: That's what I anticipated
16:12:43 <aristid> hpc: yes, but isn't the ideology that statefulness is usually bad? :)
16:12:49 <luqui> mreh, cool i shall.  haven't seen a good comedian in a while.
16:12:54 <kmc> yeah Pr_A[P^A != NP^A] = 1
16:12:58 <merijn> Tomsik_: If P != NP was proven I'm pretty sure I'd have heard. As long as it is not proven claiming that it has 100% probability is a bit optimistic
16:13:02 <mreh> luqui: Jazz improvisation
16:13:05 <kuffaar> luqui: I want to print something I received with Network recv, basically
16:13:08 <luqui> mreh, oh different guy?
16:13:09 <mreh> i hope you were joking :)
16:13:13 <joe6> pastorn: formatted code: http://codepad.org/5wyENxcG
16:13:13 <mreh> yes
16:13:16 <luqui> i wikipediad
16:13:17 <mreh> google harder
16:13:19 <kmc> P and NP are not in any way the same classes as P^A and NP^A
16:13:20 <luqui> :-P
16:13:20 <mreh> ;)
16:13:27 <kmc> where A is some language you give an oracle for
16:13:33 <joe6> kuffaar: cannot use show?
16:13:34 <kmc> it is an interesting result though
16:13:41 <kuffaar> No integer to decimal presentation string stuff
16:13:48 <kmc> there are classes C,D for which C = D but Pr_A[C^A = D^A] = 0
16:13:49 <pastorn> joe6: doisn't it feel better now?
16:13:53 <joe6> yes
16:14:00 <kuffaar> joe6: Ah, that doese not perform escaping yet?
16:14:11 <kuffaar> I mean show on a String is totally different from what I want
16:14:23 <Tomsik_> merijn: nobody said that P != NP
16:14:32 <Tomsik_> only that it's slightly improbable ;]
16:14:34 <joe6> kuffaar: putStrLn . show?
16:14:38 <pastorn> kuffaar: Data.Char.ord (or is it chr?) and fromIntegral
16:14:52 <kmc> "P != NP with probability 1" is a misleading way to put it
16:14:56 <kuffaar> pastorn: No :p
16:15:02 <kuffaar> Ok I'll just try it, sec
16:15:02 <merijn> Tomsik_: Giving odds of 1 is slightly different from merely improbable
16:15:16 <pastorn> one of those is Int -> Char
16:15:18 <pastorn> @type ord
16:15:18 <lambdabot> Char -> Int
16:15:23 <pastorn> well, chr then
16:15:25 <pastorn> @type chr
16:15:26 <lambdabot> Int -> Char
16:15:29 <ddarius> merijn: It's also not the same as logically certain.
16:15:31 <kuffaar> How do you construct a Char8?
16:15:32 <pastorn> chr 90
16:15:34 <pastorn> > chr 90
16:15:34 <lambdabot>   'Z'
16:15:59 <hpc> @hoogle Char8
16:16:00 <lambdabot> module Data.ByteString.Char8
16:16:00 <lambdabot> module Data.ByteString.Lazy.Char8
16:16:00 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
16:16:03 <pastorn> > let z = 90 :: Word8 in chr (fromIntegral z)
16:16:04 <lambdabot>   'Z'
16:16:08 <kuffaar> Sorry, Word8*
16:16:08 <Tomsik_> merijn: I'm not sure, are we saying the same thing or not?
16:16:10 <kuffaar> Not Char8
16:16:13 <pastorn> kuffaar: ^^
16:16:18 <kuffaar> @hoogle Word8
16:16:19 <lambdabot> Data.Word data Word8
16:16:19 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
16:16:24 <cdsmithus> kuffaar: Then use fromIntegral
16:16:29 <cdsmithus> > fromIntegral 5 :: Word8
16:16:30 <lambdabot>   5
16:16:41 <Philonous> How do TVars scale? Could I expect them to behave acceptably when I have thousands or even millions of them with sparse access patterns?
16:16:50 <cdsmithus> > fromIntegral (5 :: Int) :: Word8
16:16:52 <lambdabot>   5
16:16:54 <merijn> Tomsik_: I dunno? You were saying the odds of "P != NP" are 1. I'm convinced the odds of "P != NP" are high, but not 1.
16:17:10 <pastorn> Philonous: you coding for ROFLscale?
16:17:16 <glguy> Does anyone know of an example of a language that lets you specify version requirements for functions in an API. I'm imagining something where you could say that the Data instance for a type is only available if you claim to depend on version "2"
16:17:26 <cdsmithus> fromIntegral is does general type conversion from any integral type to any numeric type.
16:17:32 <Philonous> pastorn: come again?
16:17:35 <kuffaar> > let x = fromIntegral 32 :: Data.Word.Word8 in show [x]
16:17:36 <PerfM> I like this channel
16:17:37 <lambdabot>   "[32]"
16:17:38 <Tomsik_> merijn: 1 as in probability of hitting 0.5 when throwing a dart at (0, 1) interval
16:17:43 <PerfM> Jk.
16:17:44 <kuffaar> Yeah show doesn't work for that, joe6
16:17:47 <PerfM> It's eeeffffin weird
16:17:51 <pastorn> glguy: haskell can... i think it's -XPackageImports
16:17:53 <kuffaar> It's supposed to return " "
16:17:58 <ddarius> Tomsik_: Of not hitting 0.5.
16:18:15 <PerfM> I think you're all liars
16:18:15 <Tomsik_> err
16:18:17 <pastorn> glguy: from "OpenGL-bla-blu-blu" import qualified Graphics.Rendering OpenGL as GL
16:18:17 <Tomsik_> yes
16:18:25 <cdsmithus> kuffaar: to get from [Word8] to [Char], use: map (chr . fromIntegral)
16:18:28 <cdsmithus> is that what you want?
16:18:34 <glguy> pastorn: that's roughly the opposite of what I mean
16:18:44 <merijn> Tomsik_: Probability of 1 == "100%"
16:18:47 <cdsmithus> > map (chr . fromIntegral) [65, 66]
16:18:49 <pastorn> Philonous: http://www.youtube.com/watch?v=majbJoD6fzo
16:18:49 <lambdabot>   "AB"
16:18:53 <kuffaar> @hoogle chr
16:18:53 <lambdabot> Data.Char chr :: Int -> Char
16:18:54 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
16:18:54 <lambdabot> Network.Browser chRealm :: Challenge -> String
16:19:00 <merijn> In all sane versions of probability anyway :>
16:19:09 <glguy> I'm imagining that a package might only export a function if you import that package as version 2. A program that depends on version one of the library but compiled against version 2 would not see said function
16:19:22 <kuffaar> cdsmithus yeah that works but I'm surprised that this is not available as a default function? This must be an extremely common task
16:19:30 <ddarius> merijn: Yes, and probability of 1 /= logically certain, just like probability of 0 /= completely impossible.
16:19:34 <kuffaar> Since you receive network data in that format
16:19:42 <merijn> ddarius: How so?
16:19:50 <Tomsik_> merijn: you throw a dart at (0, 1) interval, what is the chance of not hitting point 0.5?
16:19:52 <ddarius> merijn: The odds of you hitting any particular point of a dart board are zero.
16:19:56 <cdsmithus> kuffaar: Actually, you're probably doing it wrong.  You most likely want Data.Text.Ecoding.decodeUtf8, or the equivalent from the utf8-string package
16:20:00 <pastorn> kuffaar: i gave you the code for converting already...
16:20:12 <ray> you throw a dart at that interval and it hits somewhere
16:20:17 <ray> an event of probability 0 just happened
16:20:20 <pastorn> oh, you want UTF stuff... sorry
16:20:21 <ray> zomg
16:20:23 <PerfM> I dont get it
16:20:24 <cdsmithus> Unless you know for sure that you've got ISO Latin 1 encoding, then the above code with chr is okay.
16:20:27 <kuffaar> No, I never said UTF-8
16:20:28 <ddarius> merijn: This is what mathematicians mean when they say "almost certain" or "almost never."  They aren't being vague.  Those are mathematical terms.
16:20:51 <cdsmithus> Well, how about this: what is the character encoding?
16:21:03 <cdsmithus> I don't think I saw you say one way or the other
16:21:03 <j-invariant> I don't undesrtand probability 1
16:21:08 <PerfM> Zoooooooooooooooooooooooooooooooemmmmmgeeee
16:21:10 <j-invariant> I thought it meant certainly
16:21:16 * dixie likes the gitit
16:21:21 <j-invariant> it sucks that they ruined that, mathematicians are worse than planets
16:21:24 <merijn> ddarius: I fail to see how a probability of 1 admits the possibility of something else?
16:21:27 <ddarius> j-invariant: Nope.  It means "almost certainly."
16:21:40 <pastorn> Philonous: found that on reddit ages ago ;)
16:21:50 <ray> certainties have probability 1 but probability 1 events are not necessarily certain
16:21:50 <j-invariant> merijn: a random number in [0,10] has 0% probability of being pi
16:21:50 <PerfM> winky winky
16:21:52 <merijn> I could see of the limit to 1 of probability being "almost certain"
16:21:57 <kuffaar> cdsmithus I guess I'll use chr then hmm
16:22:03 <j-invariant> merijn: real numbers ARE limits
16:22:08 <j-invariant> that's the secret
16:22:11 <ddarius> merijn: If you throw a dart at a board, you hit a point.  The probability of you having hit any other point is 1, and yet, you hit that point.
16:22:13 <cdsmithus> If it's ISO Latin 1, then map (fromIntegral . chr) works.  If it's UTF-8, then the ways I mentioned using text or utf8-string work.  If it's ASCII, then either will work.  If it's something else, then you need something else.
16:22:39 <merijn> ddarius: I disagree, the probability of hitting any other point are close to, but not 1.
16:22:44 <ion> > Random.mkStdGen (2^31)
16:22:45 <lambdabot>   Not in scope: `Random.mkStdGen'
16:22:52 <kuffaar> Data.ByteString.Char8	unpack :: ByteString -> [Char]
16:22:52 <ddarius> merijn: Define "close to."
16:22:52 <ion> > mkStdGen (2^31)
16:22:54 <merijn> ddarius: Since there is an obvious non-zero chance of hitting that spot
16:22:55 <kuffaar> Oh there it is
16:22:56 <lambdabot>   mueval-core: Time limit exceeded
16:22:58 <ray> the secret is lebesgue measures
16:22:59 <cdsmithus> So I guess the *real* answer is that the problem was underspecified
16:23:02 <merijn> 1 - non-zero can never be 1
16:23:04 <ion> > mkStdGen (2^31-1)
16:23:05 <lambdabot>   86 2
16:23:06 <ion> > mkStdGen (2^31+1)
16:23:07 <lambdabot>   86 2
16:23:10 <kuffaar> Not sure why it now says ByteString
16:23:11 <Philonous> pastorn: My condolences, reddit killed my productivity too. 
16:23:23 <lpsmith> merijn, the problem is that are using discrete reasoning in a continuous space
16:23:29 <ddarius> merijn: That's true, but the probability of you hitting that spot is 0, and 1 - 0 = 1.
16:23:29 <kuffaar> Oh I think I was using the wrong unpack earlier
16:23:31 <pastorn> Philonous: so y u want roflscale?
16:23:55 <merijn> ddarius: Only if you permit unreasonable rounding, in which case bollocks to you :>
16:24:12 <Tomsik_> merijn: it's not rounding
16:24:14 <Tomsik_> it's fact
16:24:22 <PerfM> not fiction
16:24:24 <Tomsik_> if you had non-zero probability of hitting a point
16:24:29 <ion> http://hackage.haskell.org/packages/archive/random/latest/doc/html/src/System-Random.html#mkStdGen
16:24:31 <ddarius> merijn: It has nothing to do with rounding.  Answer Tomsik_'s earlier question.  What is the probability of you hitting a mathematically perfect bulls-eye on a dart board.
16:24:32 <Tomsik_> and every point had that probability
16:24:33 <merijn> You are not allowed to turn non-zero into zero in my universe :<
16:24:34 <Philonous> pastorn: I don't want millions of threads but lots of TVars, as to parallelize an ant algorithm. STM seemed like a good fit as the access pattern of ants is pretty sparse
16:24:46 <PerfM> kids writing paragraphs again.......
16:24:49 <ion> mkStdGen goes into infinite loop because (-2^31 :: Int) == (2^31 :: Int) :-)
16:25:11 <cdsmithus> kuffaar: No answer on what character encoding your bytes are in?
16:25:15 <ddarius> merijn: Are you aware of the topological notion of density?
16:25:17 <pastorn> Philonous: sounds cool, it probaby shouldn't be too hard to try implementing it then...
16:25:19 <Tomsik_> I predict 0.9999... = 1 problem soon
16:25:29 <pastorn> Philonous: you have TArray, you know
16:25:51 <kuffaar> Tomsik_ that one is only fun when you are around people who have no education in actual mathematics
16:25:52 <merijn> ddarius: Obviously not
16:25:53 <ray> reals are actually pretty hard
16:26:07 <kuffaar> cdsmithus: Hmm no particular encoding really, it's just random crap dumped from a telnet test really
16:26:13 <kmc> the "real" numbers are such a ridiculously implausible concept
16:26:26 <Tomsik_> kmc: dun dun dun, surreal numbers
16:26:31 <kmc> i mean i get that it's algebraically convenient but it's crazy to think our universe works like that
16:26:35 <ddarius> merijn: Well, at any rate, saying something is true "with probability 1" is a mathematical statement with a specific meaning and is strictly weaker than saying something is logically true.
16:26:36 <cdsmithus> kuffaar: Then you're doomed to keep doing being wrong until you understand what encoding you have.  There is no such thing as "no particular encoding".
16:26:41 <Cale> ray: Yeah, the real numbers are quite a subtle structure, and they're introduced to students in an entirely inappropriate way.
16:26:42 <ion> unreal numbers
16:26:47 <cdsmithus> s/doing being/being/
16:27:02 <kuffaar> cdsmithus: It's like asking me what encoding my ghc.exe is :p
16:27:14 <Cale> kmc: You can avoid that problem by remembering that models are models :)
16:27:17 <cdsmithus> kuffaar: That one is easy: it's not text.
16:27:22 <cdsmithus> But you claim to have text
16:27:27 <merijn> Tomsik_: I know that one and I can see where you are going, but I will stick to my non-zero is not zero statement regardless of you going to claim infinitely small points and 0.000....1 being equal to 0
16:27:46 <kuffaar> But I think the default behaviour is just CP1437 or whatever it's called if I wrote this in C++, cdsmithus
16:27:51 <ddarius> merijn: No one is saying 0 /= 0.
16:27:54 <merijn> Banach-Tarski is a lie too >.<
16:27:54 <ion> cale: Did you notice my message? :-)
16:28:00 <kuffaar> But unpack probably does exactly what I wnat :p
16:28:17 <Cale> ion: Sorry, I'm not sure that I did :)
16:28:22 <Tomsik_> merijn: Probability have to sum to 1, right?
16:28:24 <PerfM> Oooo burn!
16:28:27 <kuffaar> cdsmithus: As long as 32 is interpreted as a space etc I'm basically good
16:28:32 <Cale> @bot
16:28:33 <lambdabot> :)
16:28:34 <cdsmithus> kuffaar: Okay, if it's a Windows codepage, then I recommend to either use text-icu, or else just hope it's actually all ASCII and make peace with your code being broken. :)
16:28:37 <Tomsik_> Let's assume all points have equal probability
16:28:49 <Philonous> pastorn: Well, TArray is just an array of TVars. So I still need to have a lot of those sticking around and I wondered whether this impacts performance so much as to render the benefits of parallelising nought
16:28:55 <ddarius> merijn: Just refute the axiom of choice and Banach-Tarski is a lie.
16:29:02 <Tomsik_> that is non-zero and equal to some epsilon
16:29:07 <Cale> Tomsik_: By 'equal probability' here, what do you mean?
16:29:15 <kmc> "The Axiom of Choice is obviously true, the well-ordering principle obviously false, and who can tell about Zorn's lemma?"
16:29:19 <Tomsik_> Cale: hitting every point is equally likely
16:29:20 <pastorn> Philonous: how many lines is the non-paralelized code?
16:29:26 <ddarius> Cale: Obviously something ill-defined, since the end result won't make sense.
16:29:31 <ion> cale: You were describing the State monad to cheater last month, i think. I got around to trying to write the kind of description i would have found helpful at the point of having understood the concept of monads but still struggling with State myself: http://heh.fi/state-monad
16:29:38 <Cale> Tomsik_: On the interval [0,1]?
16:29:43 <pastorn> with STM, rewriting non-paralelized code isn't too painful
16:29:47 <merijn> Tomsik_: Yes and then you are dividing by infinity and 1/infinity is going to come equal to zero. But then you still need to convince me to accept your infinitely small points axiom *stew*
16:29:50 <Cale> Tomsik_: Then every point has probability 0, since there are infinitely many of them.
16:30:00 <cdsmithus> Though having written it in C++ is no guarantee of any particular encoding.  There are text libraries for C++ using any number of encodings, in addition to the platform default.
16:30:06 <kmc> STM is about concurrency *and* parallelism
16:30:13 <kmc> which means you're going to totally change your code's structure
16:30:17 <kmc> in particular make it more imperative
16:30:21 <Cale> Tomsik_: But that's okay, because probability distributions assign probabilities to sets of points.
16:30:24 <Tomsik_> Cale: yes, I'm explaining that to merijn 
16:30:27 <kmc> or is it already imperative
16:30:36 <merijn> Cale: See, and that is why no one takes mathematicians seriously :p
16:30:39 <ddarius> merijn: Well, you can deny that infinitely small points don't physically exist, but that has little to do with the original statement or with a mathematical model.
16:30:49 <PerfM> That makes soo much sense
16:30:49 <Tomsik_> merijn: no, I want it to be finite, a number
16:31:01 <ddarius> s/don't//
16:31:33 <merijn> ddarius: I fail to see the applicability of a mathematical ideal dart board to the concept of a statement being proven, to begin with
16:31:52 <merijn> Not sure who brought that up
16:32:06 <Philonous> kmc: It's java atm, so it's plenty imperative. I considered rewriting it, but I won't bother if STM wouldn't handle it well anyway
16:32:11 <kmc> oh
16:32:25 <kmc> but you could rewrite it declaratively in haskell and use pure parallelism
16:32:27 <ddarius> merijn: It's to illustrate a case of something being probability 1 and yet not being certain.
16:33:18 <Tomsik_> merijn: now if we have that probability p, which is nonzero number
16:33:33 <Tomsik_> let's take a natural number greater than 1/p 
16:33:39 <Tomsik_> and pick so many points on the line
16:33:44 <Tomsik_> dun dun dun
16:33:52 <Cale> merijn: hm?
16:33:52 <Tomsik_> summed probability is greater than zero
16:34:00 <ddarius> one
16:34:02 <Tomsik_> reductio ad absurdum
16:34:39 <Cale> merijn: The probability of any individual point can be zero, but the probability of an uncountable disjoint union of sets needn't be the sum of the probabilities of the sets.
16:34:40 <merijn> Tomsik_: I don't follow
16:34:47 <ray> basically the probability is less than ε for any ε > 0
16:34:47 <elliott> 0.99999 = 3*0.33333... != 0.1
16:34:54 <elliott> 3*(1/3) = 1, but 1/3 != 0.333333...
16:34:55 <elliott> simple logic
16:35:08 <Philonous> elliott: I beg to differ
16:35:17 <j-invariant> LOL
16:35:19 <Cale> elliott: What?
16:35:30 <Cale> 1/3 is equal to 0.333...
16:35:31 <PerfM> So, I'm basically badass no matter what anyone says.
16:35:31 <Tomsik_> merijn: p*1/p = 1
16:35:32 <ray> because if it were some ε > 0 then you could only have ceiling(1/ε) points
16:35:38 <elliott> no it isn't
16:35:39 <ray> but there are more than that since it's a real interval
16:35:41 <Tomsik_> but p* something greater than 1/p is more than 1
16:35:42 <elliott> 1/33 is 0.infinite 3s
16:35:43 <Cale> 3 * 0.333... = 1
16:35:47 <elliott> but ... is just as many as you want, not infinite!
16:35:50 <ddarius> Well it certainly true that 0.9... and 3*0.3... /= 0.1
16:35:52 <Cale> elliott: huh?
16:35:57 <elliott> http://www.demonx.net/trollface.png
16:36:19 <Cale> Of course 1 isn't equal to 0.1
16:36:25 <ddarius> Indeed.
16:36:39 <elliott> i don't actually believe that in case it's not clear
16:36:52 <ddarius> elliott: So you believe 1 = 0.1 ?
16:36:58 <Cale> lol
16:37:14 <elliott> ddarius: absolutely
16:37:18 <elliott> mathematical fact
16:37:31 <ion> 1 = 0.1 FSVO “0.”
16:37:41 <merijn> Cale: Yes, but of course that requires a belief in the acceptance of infinitely sized sets when dealing with probability, I'm pretty sure I can some ultrafinitistic argument against those assumptions
16:38:00 <elliott> i love ultrafinitists, they're cute and cuddly, like kittens
16:38:01 <j-invariant> real numbers contain infinite information
16:38:08 <ddarius> elliott: Indeed.
16:38:16 <j-invariant> it's not reality it's just this idealistic model
16:38:18 <ddarius> j-invariant: -A- real number contains infinite information.
16:38:20 <elliott> also they run around in circles saying stupid things
16:38:21 <elliott> like kittens
16:38:24 <ddarius> (potentially)
16:38:31 <elliott> (kittens speak)
16:38:34 <merijn> elliott: You have talking kittens?
16:38:38 <elliott> YES
16:38:40 <merijn> Could get rich with that
16:38:42 <elliott> and they're ultrafinitists, too
16:39:04 <Tomsik_> what's an ultrafinist? something with ultra fins?
16:39:08 <kuffaar> I'm new to Haskell, would somebody please check out if Im doing something terrible? https://github.com/epicvrvs/Veles/blob/master/Source/Veles/Server.hs
16:39:10 <Tomsik_> Like, a shark?
16:39:13 <ddarius> The only problem with kittens is that they become cats.
16:39:25 <kuffaar> I'm especially wondering about the >> stuff in processClient
16:39:30 <Cale> merijn: I don't see any problem with it. There's a formal system, it has rules. We can apply those rules to derive theorems. Science can try building models using that formal system, and if they work, great.
16:39:30 <merijn> I'm more of an ultrapragmatist, I change my personal beliefs about mathematics to make the points I'm arguing come out :p
16:39:41 <kuffaar> You can't use the regular do semicolon within if statements, can you?
16:40:03 <kuffaar> You need to use >>= and >> and such manually?
16:40:13 <ddarius> merijn: Why don't you just add 0 = 1 to your set of axioms?  Then you'll be able to argue that any statement is true (or false) !
16:40:21 <Philonous> ddarius: Luckily, every cat has an inverse, combine both, and you end up with another kitten
16:40:31 <pastorn> kuffaar: why the >> return () ?
16:40:32 <ray> if p then do ... works
16:40:36 <pastorn> seems pretty unnesecary
16:40:39 <pastorn> (line 37)
16:40:41 <ddarius> kuffaar: A do expression is an expression.  You can use it in any expression context.
16:40:48 <merijn> ddarius: Good idea, I'm still looking for the collector's edition of "(a -> a) -> a" if you see it :>
16:40:58 <Tomsik_> ddarius: even better, add "false" to your axioms :p
16:40:59 <Cale> I don't believe in an objective universe anyway, so all I care about is models that make predictions and whether there are predictions which have been falsified or not.
16:41:11 <pastorn> kuffaar: you might benefit from Text.Printf
16:41:12 <ddarius> Tomsik_: Pssh, no one would believe that.
16:41:18 <Cale> (as far as science is concerned)
16:41:18 <pastorn> (looking at line 39
16:41:26 <kuffaar> pastorn: Formatting strings are so un FP :/
16:41:26 <merijn> Cale: Well, we mostly got into this mess with this discussion whether "probability 1" == certainty
16:41:31 <j-invariant> Cale: what does it mean? objective universe
16:41:44 <pastorn> kuffaar: yes, but Printf is nice
16:41:47 <Cale> And of course, whether or not scientific models are successful has nothing to do with whether some piece of mathematics is acceptable.
16:42:12 <elliott> Cale: define objective universe
16:42:20 <Tomsik_> I have a model-based view on the world too
16:42:43 <ddarius> Cale: As is clearly demonstrated by the completely ungrounded math used in much of modern physics.  
16:42:55 <Tomsik_> Except when some people throw too much existential philosophical ultrarelativist bullshit in
16:42:55 <ddarius> But then there was ungrounded math used in early physics.
16:42:59 <kuffaar> <pastorn> kuffaar: why the >> return () ? <- how would you do it?
16:43:12 <merijn> elliott: "The collection of experiences that influence us regardless of our own believes", if you bring up solipsism I conveniently counter that I'm just imagining you and can therefore disregard your solipsism argument
16:43:20 <pastorn> kuffaar: not at all? printing returns () already
16:43:23 <elliott> meadowlark: i was asking Cale
16:43:24 <pastorn> you can just remove it
16:43:28 <kuffaar> Oh, true
16:43:32 <pastorn> kuffaar: :p
16:43:35 <PerfM> oh true, fagtrons.
16:43:42 <PerfM> I'm out, enjoy being laaaame
16:43:46 --- mode: ChanServ set +o monochrom
16:43:48 <kuffaar> <ddarius> kuffaar: A do expression is an expression.  You can use it in any expression context.
16:43:50 <Tomsik_> ur ass is lame
16:43:54 <kuffaar> ddarius: See the else statement
16:44:12 <ddarius> kuffaar: There is no else statement.
16:44:14 <merijn> kuffaar: There is no else statement in haskell
16:44:20 <kuffaar> ddarius https://github.com/epicvrvs/Veles/blob/master/Source/Veles/Server.hs
16:44:24 <merijn> There is only an "if-then-else" expression
16:44:41 <Tomsik_> I think monochrom is giving us a hint to talk in -blah :p
16:44:59 <monochrom> no, don't worry, it's just for PerfM
16:45:04 <ddarius> Tomsik_: No, he was going to assist PerfM in leaving.
16:45:18 <merijn> I'll save you the time, I need my beauty sleep :p
16:45:26 <ray> kindly hand him his coat and show him the door
16:45:47 <pastorn> kuffaar: but switch to printf, your line width will shrink
16:46:05 <kuffaar> pastorn can do
16:46:20 <kuffaar> But I still haven't gotten any suggestions regarding the else statement down there
16:46:20 <merijn> :t printf
16:46:21 <lambdabot> forall r. (PrintfType r) => String -> r
16:46:28 <kuffaar> Sorry, s/ statement//
16:46:29 <pastorn> kuffaar: some consider it "unsafe", ut as long as you test it you'll be fine
16:46:54 <c_wraith> It's unsafe in that the compiler can't verify you've done it properly
16:47:02 <pastorn> kuffaar: do it with do-notation instead
16:47:08 <hpc> and more so in that it is runtime-variadic
16:47:25 <hpc> which is a spooky brand of runtime dependence
16:47:31 <Tomsik_> I wish TH was simpler
16:47:33 <pastorn> hpc, c_wraith: or you just test it...
16:47:35 <merijn> hpc: Agda will fix it! :>
16:47:46 <Tomsik_> then printf would be like, easier, better and more static
16:47:49 <hpc> pastorn: indeed, just explaining why it is so unsafe
16:47:59 <ddarius> Tomsik_: There is a TH printf.
16:48:00 <kuffaar> Ahhh now I realise why my code broke when I tried to use a do in there
16:48:07 <kuffaar> Because the indentation had to be updated
16:48:10 <ddarius> hpc: There is no such thing as "runtime-variadic."
16:48:18 <hpc> ddarius: i can make up words!
16:48:23 <Tomsik_> yeah, but it's more of general comment, especially about variadic functions
16:48:30 <hpc> i mean, the number of parameters is not known until runtime
16:48:37 --- mode: monochrom set +q *!*@gateway/web/freenode/ip.173.180.71.38
16:48:38 <Tomsik_> I often wish I had variadic functions
16:48:40 <ddarius> hpc: It is known at compile-time.
16:48:44 <Tomsik_> which would be easy to write and use
16:48:58 --- mode: monochrom set -q *!*@9.244.251.212.customer.cdi.no
16:49:16 --- mode: monochrom set -o monochrom
16:49:18 <ddarius> The way printf works is that the compile-time type leads to a different -format string- parser.  One that will give an error if there aren't enough parameters or they have the wrong type.
16:49:31 <ddarius> The "arity" is still completely resolved at compile-time (in most cases...)
16:50:26 <pastorn> joe6: how's it going?
16:50:35 <hpc> ah, that makes more sense; i was thinking of the string as deciding the arity of the function
16:51:01 <ddarius> Indeed.  It works almost the opposite of the way it does in C.
16:51:09 <Tomsik_> Is there any utily/wrapper/whatever library to make TH simpler? Like to cut half the constructors
16:51:11 <ddarius> And is a bit of a clever way to go about it.
16:51:15 <Tomsik_> and make it lisp-easy?
16:51:43 <Tomsik_> TH has a lot of features many people usually don't need
16:51:46 <ddarius> Tomsik_: If Lisp-easy is easier than Haskell-easy, why not just use Lisp?
16:52:29 <monochrom> lisp macro is lisp-easy only because lisp syntax is just a lot of cons cells.
16:53:05 <monochrom> haskell syntax is much more elaborate
16:53:07 <Tomsik_> ddarius: Well, it's just TH that's not that great IMO
16:53:17 <ddarius> monochrom: Not really.  Lisp-easy is only "Lisp-easier to compile."  You just end up with macro-expansion-time errors.
16:53:19 <kuffaar> TH = ?
16:53:20 <Tomsik_> monochrom: yeah, that's what I'm talking about
16:53:25 <Tomsik_> template haskell
16:54:16 <Tomsik_> haskell is has a lot more syntax and that's reflected in TH, but you usually don't need ALL of that
16:54:21 <ddarius> For something like printf, you can just use the code quoting mechanisms and you shouldn't need to directly deal with the AST at all.
16:56:10 <ddarius> Tomsik_: You could write a function that normalizes the AST to something simpler at the cost of giving up some (syntactic) information.  For example, reducing all infix applications to prefix.
16:56:42 <Tomsik_> That's what I mean
16:56:58 <Tomsik_> Is there anything like that?
16:57:17 <Tomsik_> and dropping all that strictness information :p
16:57:44 <pastorn> what? are you trying to make printf compile-time-safe?
16:58:18 <ddarius> pastorn: As I said earlier, there are already TH printfs.
16:58:28 <pastorn> Real Men(TM) crash and burn
16:59:07 <Tomsik_> pastorn: I think that crashing and burning isn't exactly the best from the evolutionary standpoint.
16:59:17 <pastorn> Tomsik_: weakling
16:59:25 <pastorn> Tomsik_: sissy
16:59:26 <pastorn> etc.
16:59:49 <BMeph> Tomsik_: Barbecue hater! ;þ
17:00:22 <cheater00> hello
17:00:33 <cheater00> is there an implementation of hyperreal number arithmetic in haskell?
17:01:45 <Tomsik_> hyperreal, is that something like complex numbers or more like surreal numbers?
17:01:52 <cole> I don't understand this function declaration: "eol :: GenParser Char st Char" What is it saying? Where are the '->'?
17:02:14 <pastorn> cheater00: are those the ones that was first introduced in a work of fiction?
17:02:26 <lpsmith> Tomsik_, as in Non-standard analysis
17:02:29 <pastorn> or was that surreal numbers
17:02:34 <Kaidelong> eol is a value of the type GenParser Char st Char. Perhfectly possible that GenParser is an alias for a function
17:02:36 <ddarius> cole: That's not a "function declaration."  It's just a type annotation.
17:02:48 <cheater00> pastorn: ?
17:03:01 <cheater00> pastorn: no, they're just hyperreal numbers, an extension of real numbers?
17:03:01 <Tomsik_> cole: hidden in constructors or it's just a value of the type
17:03:35 <pastorn> cheater00: ehm... what's their deal?
17:03:35 <cheater00> also known as nonstandard reals
17:03:39 <Kaidelong> Tomsik_: looks like it's basically a way to work with infinities like they are numbers
17:03:44 <cheater00> they are extended by infinite and infinitesimal quantities
17:03:46 <ddarius> copumpkin: Enjoy your operas?
17:04:07 <pastorn> cheater00: oh, so arbitrary precision floats?
17:04:11 <Kaidelong> it may well be possible to implement these with typeclasses
17:04:12 <ddarius> cheater00: I don't think anyone has anything like that on hackage, though I highly suspect someone has made some toy library for them at some point.
17:04:17 <copumpkin> ddarius: that's next weekend :) in tampa now
17:04:30 <ddarius> cheater00: Incidentally, you may also be interested in synthetic differential geometry.
17:04:44 <cheater00> ddarius: what does it do?
17:05:07 <cheater00> "draw this n-manifold with a compass and straight edge"?
17:06:20 <ddarius> cheater00: It gives meaning to infinitesimal quantities in a different way than non-standard analysis.  It doesn't give any meaning to "infinite" quantities.  The catch is rather than being limited to first-order real number axioms, you are limited to an intuitionistic logic (because it has x such that x^2 = 0 and x /= 0.)
17:06:47 <ddarius> cheater00: It makes differentiation "algebraic" and fits rather well with the historical, intuitive notion of "inifinitesimal quantity."
17:07:00 <j-invariant> it's not a field
17:07:02 <j-invariant> it's just a ring
17:07:04 <j-invariant> (RUBBISH!)
17:07:05 <cheater00> interesting
17:07:09 <cheater00> got a nice paper?
17:07:17 <cheater00> some sort of tutorial?
17:08:51 <ddarius> The beginning of Kock's book which is available online, "Synthetic Differential Geometry" is reasonably readable.  Then it gets highly technical later on.
17:11:20 <ddarius> There's also "Synthetic Geometry of Manifolds"
17:11:52 <Tomsik_> Manly folds
17:11:57 <Tomsik_> like fold'
17:12:09 <ddarius> (And I just saw a potentially interesting, new paper on Kock's site.)
17:12:11 <Tomsik_> foldl' damn
17:13:20 <jmcarthur> heh, in the profiling and optimization chapter of real world haskell... the example program is *much* faster with ghc 6.12 and ghc 7 than it was with the version they used in the book
17:13:38 <jmcarthur> the original version, at least
17:13:59 <Kaidelong> maybe they should update it
17:14:06 <pastorn> joe6: hello?
17:14:06 <Kaidelong> their example was a mean function, wasn't it?
17:14:48 <monochrom> that was mean. <duck>
17:14:56 <jmcarthur> as they increase the command argument it goes from 0.059 to 0.298 to 1:04.53, but with the same arguments and ghc 6.12 it goes from 0.036 to 0.200 to 1.734
17:15:19 <monochrom> you should try it in a VM :)
17:15:23 <jmcarthur> ha
17:15:35 <jmcarthur> the profiling results are also very different
17:15:42 <luite> how fast is it when you generate javascript with uhc? :p
17:15:53 <gwern> luite: does that even still work?
17:15:54 * jmcarthur tries not to think about that
17:16:02 <gwern> last time I tried yhc was kind of bitrotten
17:16:43 <luite> gwern: apparently people are still working on it, and there are some student projects to make a better ffi, or so I've heard
17:16:59 <jmcarthur> now... are we talking about uhc or yhc?
17:17:03 <luite> uhc
17:17:22 <kuffaar> 1. Write a Haskell compiler in Javscript 2. do web development with client side scripting in Haskell 3. ??? 4. profit
17:17:25 <jmcarthur> i would not say uhc is bitrotten
17:17:30 <jmcarthur> i think gwern was confusing the two?
17:17:41 <kuffaar> Haha I know somebody from #lisp who has written a Common Lisp interpreter in JavaScript, I think
17:17:44 <kuffaar> Really insane.
17:18:06 <kuffaar> Haskell would be considerably more challenging though.
17:18:09 <kmc> you don't need a haskell compiler in javascript, just a haskell compiler that targets javascript
17:18:13 <kmc> and UHC has that iirc
17:18:48 <kuffaar> kmc it's much funnier when the compiler/interpreter is written in JavaScript
17:18:55 <Tomsik_> it's not
17:18:58 <Tomsik_> it's slower
17:19:02 <kuffaar> Of course it is
17:19:02 <jmcarthur> i don't see what's so funny about that
17:19:11 <jmcarthur> a lot of things are written in javascript
17:19:16 <kuffaar> x86 emulator in JavaScript with VESA etc to render HTML would be even funnier
17:19:26 <luite> kuffaar: once enough rts support is available, you could compile the compiler itself to javascript
17:19:29 <Kaidelong> what about doing a compiler in PHP that targets Javascript
17:19:43 <kuffaar> PHP :'(
17:19:47 <kuffaar> PHP makes SPJ cry
17:19:57 <kmc> this is better: http://visual6502.org/JSSim/index.html
17:20:05 <jmcarthur> kuffaar: you realize that javascript is even used server side a lot. it's not exclusively for the browser
17:20:06 <raichoo> PHP makes everyone cry…
17:20:16 <kuffaar> jmcarthur: No, I don't
17:20:25 <Tomsik_> how about a compiler in assembler that targets python which is later compiled to javascript by a program written in perl?
17:20:25 <kuffaar> I've used node.js btw
17:20:42 <kuffaar> But I've grown really hostile to dynamic typing in general recently
17:21:12 <jmcarthur> kuffaar: http://www.mozilla.org/rhino/overview.html
17:21:19 <Kaidelong> it is useful sometimes (and you can do it in Haskell)
17:21:19 <Tomsik_> strong, static typing with inference is the shit
17:21:22 <kuffaar> I have heard of Rhino before
17:21:36 <kuffaar> Tomsik_: Yeah, I have had that feeling even before I touched Haskell
17:21:48 <kuffaar> Although Haskell really makes me nothing but miserable, I get no joy out of it at all
17:21:50 <ddarius> visual6502 is completely insane and something I'd like to do (albeit not in javascript.)
17:22:14 <kuffaar> One friend of mine is still trying to make me quit Haskell to prevent me from turning into a zombie lost in abstract discourse
17:22:25 <kuffaar> @quote SPJ cheerful
17:22:26 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
17:22:26 <jmcarthur> i have found dynamic typing useful for when i'm playing around with programming language ideas that have nothing to do with a type system and i want to play with embeddings without worrying about even remotely type safe compilation or anything like that
17:22:38 <kmc> the abstract nonsense is kind of optional
17:22:46 <kmc> you can approach Haskell as just a programming language
17:22:54 <kmc> and ignore that it's also a vocabulary for talking about abstract maths
17:23:02 <kmc> because those blog posts are about maths, not haskell, even if they use haskell syntax
17:23:26 <Kaidelong> not that it isn't interesting
17:23:31 <jmcarthur> on the other hand, your haskell code *can* improve by learning certain kinds of maths
17:23:35 <Kaidelong> that said, I have not found much use for it writing haskell
17:23:42 <kmc> of course to some programmers the idea of "correctenss" or "types" or "knowing what your code does before you run it" is abstract nonsense
17:23:43 <kuffaar> I think I'd like to make a simple general purpose language with static typing and type inferrence (possibly in a restricted way which does not allow polymorphism in the beginning though)
17:23:44 <cheater00> ddarius: let me read!
17:23:45 <ddarius> Haskell is a pretty crappy vocabulary for talking about math.
17:23:59 <kuffaar> But it would be imperative mostly, not pure FP
17:24:07 <ddarius> Inferring simple types is stupid simple.
17:24:23 <cdsmithus> kmc: My coworkers tell me that saying words like "functor" and "monoid" is abstract nonsense regardless of the application.  Somehow, this doesn't seem to apply to "functors" in their C++ code, though. :(
17:24:24 <ddarius> Hell, even HM polymorphism is far from difficult.
17:24:36 <kmc> kuffaar, why not Haskell's approach -- pure FP computations that produce imperative programs
17:24:55 <kuffaar> kmc: I don't like pure FP, I find it really clumsy and unintuitive
17:25:06 <Tomsik_> kuffaar: not yet down the rabbit hole, eh?
17:25:07 <Tomsik_> :p
17:25:10 <cheater00> ddarius: i can't find the book. where do you see it available for free?
17:25:22 <cheater00> (you wouldn't happen to have, say, a pdf of it?..)
17:25:33 <Kaidelong> kuffaar: what I find "clumsy" and "unintuitive" are things like the value restriction that start to show up after you lose purity
17:25:52 <Kaidelong> purity itself makes things a lot easier
17:26:01 <Kaidelong> it is worth looking into for an imperative language as well
17:26:02 <kuffaar> Kaidelong what do you mean by value restrictions?
17:26:11 <kuffaar> I know the term from people in here talking about SML
17:26:18 <kuffaar> And monomorphism restrictions
17:26:23 <Kaidelong> kuffaar: ML isn't pure and one of the consequences of that is the value restriction
17:26:30 <dolio> In ML, all values must be monomorphic.
17:26:40 <Kaidelong> kuffaar: Haskell's monomorphism restriction can be turned off without killing the type system
17:26:40 <kmc> "functional" and "imperative" are not in any way opposites
17:26:43 <Kaidelong> in ML that is not the case
17:26:45 <kmc> Haskell is a pure functional imperative language
17:26:54 <Philippa> cdsmithus: that's because they think "functor" means "function object" :-(
17:27:26 <cdsmithus> Philippa: Yes, I know.  I was joking
17:27:26 <kuffaar> Philippa it's just a wrapper around a function pointer with a type in C++ pretty much
17:27:37 <kuffaar> Template abuse <3
17:27:43 <kuffaar> Kaidelong what about C++ templates?
17:27:43 <dolio> Yes, in C++, "functor" is "my language is impoverished" nonsense.
17:28:05 <Kaidelong> kuffaar: you can show that getting rid of the value restriction thwarts the ML type system and allows you to write "cast :: a -> b". The idea of keeping IO inside monadic wrappers defeats that "exploit"
17:28:12 <ddarius> @google synthetic differential geometry
17:28:14 <lambdabot> http://en.wikipedia.org/wiki/Synthetic_differential_geometry
17:28:14 <lambdabot> Title: Synthetic differential geometry - Wikipedia, the free encyclopedia
17:28:19 <ddarius> Curse you wikipedia.
17:28:26 <ddarius> @google "Anders Kock"
17:28:28 <lambdabot> http://home.imf.au.dk/kock/
17:28:28 <lambdabot> Title: Homepage of Anders Kock
17:28:51 <ddarius> cheater00: Both of them are available there along with many other papers of varying technicality.
17:28:57 <cdsmithus> The point remains: some people like to whine about any simple abstraction by complaining about the "made up words" and "math babble"... but when they make up words, it's ok.
17:29:13 <Kaidelong> kuffaar: programming haskell is a lot like programming at a template level
17:29:21 <Kaidelong> but much, much nicer
17:29:28 <kmc> cdsmithus, yes, the complaining about "math babble" is usually rooted in irrational group-antagonism dynamics
17:29:30 <monochrom> be careful what you wish written in javascript. I once scorned at "theorem prover in javascript". then I learned of http://www.umsu.de/logik/trees/
17:30:06 <kmc> it really pisses me off because it's basically the same anti-intellectualism that poisons political discourse and everything else
17:30:07 <ddarius> monochrom: Is it now your theorem prover of choice?
17:30:13 <kmc> except it's coming from ostensibly educated, intelligent people
17:30:37 <monochrom> depends on task. I point logic students to it.
17:31:48 <ddarius> Kaidelong: What really happens with IORefs in Haskell that keeps that from happening is the fact that the results of an IO action are lambda bound and thus monomorphic.
17:31:49 <ion> What is the opposite of an imperative programming?
17:32:00 <ddarius> Kaidelong: If you use unsafePerformIO, you can implement unsafeCoerce via IORefs.
17:32:33 <roconnor> ion: the alternatives to imperative programming are functional programming, and logic programming, and maybe others
17:33:06 <dolio> clearly we should have: newIORef :: Useless a => a -> IO a
17:33:20 <dolio> class Useless a where ; instance Useless a where
17:33:27 <ion> kmc: What do you say?
17:33:34 <Kaidelong> ddarius: at least those are clearly labeled though and you're unlikely to implement unsafeCoerce by accident or by passing the wrong parameters
17:33:46 <monochrom> I say that the opposite of imperative is declarative. imperative: indulged in how. declarative: indulged in what.
17:33:54 <kmc> ion, not all things have opposites
17:33:55 <ddarius> Kaidelong: Actually, it's quite easy to do when doing the unsafePerformIO hack.
17:34:03 <cheater00> ddarius: ahh
17:34:06 <cheater00> ddarius: thanks!
17:34:10 <cheater00> ddarius: i overlooked it somehow.
17:34:15 <dolio> That probably wouldn't actually solve the problem, though.
17:34:19 <jmcarthur> kmc: yeah, anti-intellectualism is probably one of the things i hate the most... and i hate a lot of things
17:34:22 <monochrom> although some other people say imperative: mutable vars, and so their opposite is functional.
17:34:29 <Kaidelong> ddarius: but can you implement it without somehow invoking unsafePerformIO, unsafely?
17:34:44 <kmc> ion, i would say the opposite of "imperative" is "denotational" or "declarative".... but i think these terms are better applied to individual programs or styles than to languages
17:34:53 <kmc> since most languages support a wide spectrum of styles
17:35:01 <ion> alright
17:35:13 <jmcarthur> ion: i don't know of an opposite, but i would say that "declarative programming" stands in pretty stark contrast
17:35:31 <kmc> Haskell may have become the poster child for pure functional style, but it's very much a multi-paradigm language and not a typical functional language either
17:35:45 <Kaidelong> anyway, the other thing about purity is that it is easy to isolate sections of code as well
17:35:57 <roconnor> good point about declarative
17:35:58 <rien> what's a typical functional language?
17:36:00 <ddarius> Kaidelong: The unsafePerformIO hack is a specific trick (namely, to get global mutable variables.)
17:36:08 <Kaidelong> it prevents hidden parameters from being passed from unexpected locations by the observation of side effects
17:36:16 * roconnor wonders if ML is declaratives.
17:36:25 <Kaidelong> ddarius: If you're going for that, I'd say you've left the realm of purity
17:36:37 * roconnor wonders if scheme is declarative
17:36:53 <rien> scheme can be whatever
17:37:00 <jmcarthur> roconnor: i'd rather say that there is a continuum between imperative and declarative rather than a stark black and white dividing line
17:37:01 <Kaidelong> the global mutable parts should be left for the last minute when you apply the pure program to its environment
17:37:10 <rien> in "the reasoned schemer" they make it be like prolog
17:37:25 <jmcarthur> roconnor: and calling a language any particular style is probably overgeneralizing, IMO
17:37:40 <dolio> roconnor: Yes, Martin-Loef type theory is declarative.
17:37:43 <jmcarthur> although some languages lend themselves to certain kinds of programming
17:38:19 <Kaidelong> kuffaar: anyway, purity is nice, even outside of the functional paradigm
17:38:36 <jmcarthur> luqui: hey, sorry i haven't responded to your last email yet. i've been busy with unrelated things and have been mulling over some thoughts i want to include
17:38:43 <pastorn> Kaidelong: yes, riddle your java code with "final" :)
17:38:55 <Kaidelong> pastorn: this is exactly what I do!
17:39:00 <Kaidelong> is that bad?
17:39:04 <rien> Kaidelong: yes, purity is one the nicest things Haskell has taught me
17:39:15 <rien> and I use it in other languages because it keeps me sane
17:39:25 <Kaidelong> also impure classes with pure wrappers, is another thing I find myself doing
17:39:26 <pastorn> Kaidelong: actually it's probably good for performance
17:39:32 <ddarius> Kaidelong: Yes, because you should be using C# and readonly.
17:39:47 <pastorn> ddarius: hehe
17:39:52 <Kaidelong> ddarius: Why not const for C#?
17:40:01 <pastorn> they differ?
17:40:05 <pastorn> it has both?
17:40:05 <ddarius> Kaidelong: Because you often can't use const.
17:40:05 <Kaidelong> unless you specifically need readonly for binding at construction time
17:40:28 <Kaidelong> ddarius: you can also define a property that has only get and not set
17:40:44 <ddarius> Kaidelong: Indeed.
17:45:03 <kmc> unsafePerformIO is not the right way to extend Haskell with global mutable variables
17:45:07 <kmc> it was added for a different extension
17:45:11 <kmc> though has found many uses
17:46:16 <dolio> Careful, you might be accused of being a member of the history revisionists.
17:46:25 <Kaidelong> kmc: global mutable variables seems like the wrong approach anyway. Better to have them inside main than in true global scope.
17:47:16 <Kaidelong> and then pass them by reference
17:47:33 <Kaidelong> it is more explicit that way
17:48:06 <ddarius> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/ExtensibleVisitor/
17:49:19 <Philippa> Kaidelong: and to have to instantiate modules, where appropriate, yeah
17:52:56 <ddarius> Installing this Hangul font has jacked something up.
17:53:10 <kuffaar> Are you dealing with Korean?
17:53:34 <geheimdienst> jacked up in the sense of messed up?
17:54:25 <joe6> i have " data Dir       = In | Out " and in a parsec subroutine, can I do "_ <- string (show x::Dir)"
17:54:46 <kmc> how would "show x" have any type other than String?
17:54:56 <geheimdienst> :t show
17:54:57 <cdsmithus> the type of (show x) is String,  not Dir
17:54:58 <lambdabot> forall a. (Show a) => a -> String
17:55:15 <joe6> sorry i meant "_ <- string (show (x::Dir))"
17:55:23 <joe6> it is just to show that x is of type Dir
17:55:24 <cdsmithus> Oh, you meant: _ <- string (show (x :: Dir))?
17:55:27 <kmc> sure
17:55:32 <kmc> that should work
17:55:40 <ddarius> You need to derive or implement Show though.
17:55:49 <kmc> why do you ask?
17:55:58 <cdsmithus> joe6: That will match only one of "In" or "Out", though, depending on the value of x
17:56:58 <cdsmithus> if you want to read either one, and assign the result to x, then you'd need to do: str <- read <$> (try (string "In") <|> string "Out")
17:57:09 <cdsmithus> And Dir would need to be an instance of Read, not Show
17:57:53 <cdsmithus> Oops, I meant "x <-"
17:59:39 <ddarius> In that case try is not necessary.
18:00:07 <kmc> because 'I' /= 'O'?
18:00:22 <cdsmithus> ddarius: okay, yes... but that's a coincidence
18:01:44 <ddarius> kmc: Yes, though the try does slightly change the behavior.
18:02:06 <brisbin> is "forall a." new or more advanced? it seems to just reinforce (Whatever a) => is going on
18:02:25 <ddarius> forall is an extension, but it is hardly new.
18:02:42 <brisbin> that explains it
18:02:43 <brisbin> thanks
18:02:45 <kmc> brisbin, there are some types you can only write with explicit forall
18:03:02 * geheimdienst has found the wikibooks page on existentials helpful
18:03:03 <kmc> "S a -> T b" is the same as "forall a b. S a -> T b" which is not the same as "(forall a. S a) -> T b"
18:03:25 <kmc> forall on the left argument of (->) indicates a function which demands polymorphism from its argument
18:03:31 <geheimdienst> ... http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
18:03:35 <kmc> outside of (->) it indicates a function which promises polymorphism from its result
18:03:40 <kmc> so they are dual notions
18:03:52 <brisbin> i personally have been noticing forall's coming up more an more and i didn't know if it was because it was actually new or because i've reached some point where they're not useful to me
18:04:06 <brisbin> i'm glad it's the latter
18:04:17 <joe6> cdsmithus: that is a good observation. Thanks.
18:04:18 <kmc> why do you say they aren't useful?
18:04:24 <brisbin> sorry, s/not//
18:04:41 <kmc> Rank2Types is the only GHC extenison I think is *really* necessary for real world code
18:04:43 <kmc> because of ST
18:04:51 <brisbin> sometimes i start a sentence one way and finish it another
18:05:02 <brisbin> unfortunate where that split happend
18:05:14 <cdsmithus> kmc: Okay, you can write the Haskell Report delta for a Haskell 2012 submission, then
18:05:22 <cdsmithus> :P
18:05:23 <kmc> to get them into H2012
18:05:25 <kmc> i think not
18:06:15 <ddarius> Rank2Types is probably the most widely supported, significant extension.
18:06:40 <ddarius> That, or multiparameter type classes.
18:06:48 <kmc> i should say "only H2010 extension" because FFI is also very much necessary
18:07:43 <ddarius> The FFI is a ratified addendum to the Haskell 98 Report, though you can claim Haskell 98 conformance without FFI conformance.
18:08:37 <nalaurethsulfate> I have some questions about haddock, and literate haskell files, does anyone know about these two and have a couple of minutes to spair?
18:08:38 <kmc> existentials are quite useful too but i think their CPS-encoding with Rank2Types is probably bearable
18:08:47 * ddarius remembers the days just before the FFI addendum.
18:09:31 <cdsmithus> nalaurethsulfate: Just go ahead and ask
18:10:07 <nalaurethsulfate> I am trying to understand if there is built in seperation between comments that will be sent to haddock, or comments that are left out
18:10:07 <dolio> If you want to make much use of existentials encoded with universals, you probably need rank-n types, not rank-2.
18:10:21 <kmc> maybe so
18:10:36 <nalaurethsulfate> to me I want to keep api documentation seperate, so I was thinking that if I wanted it to show up in haddock it would have to be in a comment in a code block
18:10:37 <dolio> Like, taking any existential as a parameter.
18:10:40 <luqui> jmcarthur, it's cool. i've been busy with school.  now researching to translate extcore to thyer rep so we can run haskell :-D
18:10:53 <ddarius> Impredicativity is also useful.
18:10:56 <ddarius> (in that case)
18:11:27 <nalaurethsulfate> SO where do my haddock comments go? In code blocks or just in the literate lines?
18:12:24 <kmc> what are you doing with extcore luqui?
18:12:58 <luqui> kmc, translating to our lazy specializer project
18:13:12 <kmc> cool
18:14:44 <cdsmithus> nalaurethsulfate: I just tried, and I had to put them in special comments in the source blocks.
18:15:34 <nalaurethsulfate> cdsmithus: Do you know if that is specified somewhere? Or does it just seem to come out in the actions?, also thanks btw
18:16:17 <joe6> if i have "data DataMode  = Data1 | Data0" and "let x = Data1", is there a way to derive Data0 from the value of x, such as (not x) or something?
18:16:23 <cdsmithus> I don't see it directly stated anywhere.  But it's pretty clear from the comments at http://www.haskell.org/haddock/doc/html/invoking.html#cpp that haddock views literate haskell as a preprocessor to run.
18:16:29 <joe6> or succ x
18:16:49 <kmc> data DataMode  = Data1 | Data0 deriving (Enum)
18:16:52 <kmc> then you can use succ
18:17:02 <joe6> kmc: thanks a lot
18:17:16 <nalaurethsulfate> cdsmithus: so it runs unlit.c and then haddock you think?
18:17:24 <ddarius> joe6: You can just write your own pattern matching function.  Or you could just use Bools...
18:17:25 <cdsmithus> Yes, I think so.
18:17:40 <nalaurethsulfate> cdsmithus: thank you very much!
18:18:38 <nalaurethsulfate> cdsmithus: just wanted to say that you guys are great; #haskell is the best tech-support for any product I have ever used!
18:19:20 <ddarius> Maybe we should set up a flattr-like thing for #haskell to fund community projects.
18:19:33 <cdsmithus> flattr?
18:19:37 <cdsmithus> @google flattr
18:19:38 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
18:19:42 <kmc> hmm, is strictness analysis done before or after the stage where extcore is produced?
18:19:52 <cdsmithus> hmm... who broke lambdabot?
18:20:00 <luqui> i've always appreciated the kind, helpful haskell community.  many other languages seem to have channels full of jerks.
18:20:11 <ddarius> @google flattr
18:20:12 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
18:20:16 <ddarius> Huh.
18:20:30 <luqui> > 1+1
18:20:31 <lambdabot>   2
18:22:19 * ddarius will have to figure out what is special about googling flattr.
18:22:21 <geheimdienst> @google lolcats
18:22:27 <lambdabot> http://icanhascheezburger.com/
18:22:27 <lambdabot> Title: Lolcats 'n' Funny Pictures of Cats - I Can Has Cheezburger?
18:22:31 <cdsmithus> ddarius: Without actually knowing whether flattr specifically is trustworthy, I like the idea.  Like a sort of common man's IHG
18:22:40 <joe6> when I use Enum, I cannot do "succ Data0" is there a built-in function that can work like a Bool?
18:22:47 <joe6> for defining data
18:23:05 <ddarius> joe6: Just define your own "flip" function.
18:23:10 <joe6> i tried deriving Bool, but that does not work.
18:23:49 <ddarius> joe6: There is only one way to do anything with an algebraic data type, and that is to pattern match on it.  All functions in Haskell ultimately pattern match on algebraic data types.
18:23:50 <joe6> ddarius: ok will do, just curious if there was anythig like that already.
18:24:06 <joe6> ddarius: ok, thanks.
18:25:38 <joe6> is there an operator for this: if transactiontype == "Read" then Out else|~                                                                   In
18:25:45 <joe6> sorry, it came out wrong
18:26:13 <ddarius> Freakin' Google "Instant"
18:26:57 <ddarius> It makes it so you can't click "I'm Feeling Lucky."
18:27:13 <cdsmithus> Ah
18:27:33 <joe6> is there an operator for if then else statement: I have "if transactiontype == "Read" then Out else In"
18:27:50 <joe6> different if then else statements but in the same format.
18:28:01 <cheater00> you want guards
18:28:10 <joe6> got it: ?:
18:28:14 <joe6> sorry about that
18:28:18 <cdsmithus> joe6: Nope.  And Haskell can't do ternary operators.  The syntax requires all operators to be binary
18:28:52 <cdsmithus> ?: is not a Haskell operator
18:28:53 <lambdabot> Maybe you meant: . ? @ v
18:28:54 <cheater00> cdsmithus: a ternary operator is easily encoded as a binary operator.
18:29:14 <cheater00> test ? (then, else)
18:29:18 <cheater00> binary.
18:29:48 <cdsmithus> cheater00: sure... but then it's not ternary any more. :)
18:30:00 <joe6> cdsmithus: oh, ok. yeah, it did not work at the prompt
18:30:11 <cheater00> you're trollin', right?
18:30:12 <joe6> cheater00: how does that work?
18:30:19 <cheater00> joe6: you want guards
18:30:22 <cheater00> joe6: read up on guards
18:30:27 <joe6> oh, ok.
18:31:16 <joe6> > ?
18:31:17 <lambdabot>   <no location info>: parse error on input `?'
18:31:22 <cdsmithus> joe6: Actually, you only want guards if you're already pattern matching.  If you aren't, then the if/then/else will be the shortest way to do it.
18:31:34 <joe6> cdsmithus: ok, thanks. 
18:32:48 <kmc> case transactiontype of "Read" -> Out; _ -> In
18:33:13 <cdsmithus> Hmm... is that shorter?  Maybe
18:33:18 <kmc> i like it better anyway
18:33:27 <kmc> more extensible
18:34:13 <cdsmithus> joe6: So I guess you might want neither guards nor if/then/else. :) 
18:41:13 * ddarius should have completely divorced the Search plugin from lambdabot's craptastic "utils" library when he rewrote it.
18:50:01 <ddarius> So the problem is that flattr uses Content-type rather than Content-Type for the HTTP header.
18:50:22 <Entroacceptor> I've always used Content-type
18:50:45 <luqui> I've used content-TYPE, just to mess with people like you.
18:50:57 <ddarius> luqui: It's not my code that's the problem.
18:51:25 <ddarius> It's the two lines from the earlier Search plugin that I decided to keep.
18:51:34 <luqui> people like library authors you endorse :-P
18:51:47 <luqui> anyway i've never used content-TYPE... does that even work?
18:52:02 <ddarius> luqui: I definitely don't endorse most code in lambdabot-utils (or lambdabot.)
18:52:25 <ddarius> The RFC says Content-Type.  I don't know if there is some other section that specifies any laxness on case.
18:52:45 <dankna> it's not case-sensitive
18:52:57 <dankna> it normatively includes another rfc, the same one that defines the mail-header format
18:52:57 <kuffaar> putStrLn $ "Received " ++ (show (DB.length clientData)) ++ " byte(s) from " ++ clientAddress ++ ": " ++ (show $ unpack clientData)
18:53:02 <kuffaar> Is being printed as WaRietcienigv efdo r3 7a0  nbeywt ec(osn)n efcrtoimo n1
18:53:04 <dankna> I want to say 822?  but I could be misremebering
18:53:28 <kuffaar> Uhm is show failing to properly escape some stuff from the unpacked SCGI data?
18:53:38 <joe6> csmithus: just used the if then else. I wanted to check if  there was anything else availabel.
18:53:40 <kuffaar> But I don't get what it could be
18:53:45 <ddarius> The code is contentType here: http://hackage.haskell.org/packages/archive/lambdabot-utils/4.2.1/doc/html/src/Lambdabot-Url.html  What really gets me is that the function already returns a Maybe String, I don't know why they didn't just return Nothing.
18:54:14 <joe6> and i like the case statement above.
18:55:48 <kuffaar> Wow, in Haskell --++ is interpreted as an operator instead of a comment? :o
18:56:13 <kmc> yep
18:56:23 <kuffaar> putStrLn $ "Received " ++ (show (DB.length clientData)) ++ " byte(s) from " ++ clientAddress ++ ":  " -- ++ (show $ unpack clientData)
18:56:24 <dankna> it's the "remove postdecrements" operator in Language.Haskell.Confusing
18:56:25 <kmc> > let (--++) = (+) in 2 --++ 3
18:56:25 <ddarius> As is ---.
18:56:25 <kuffaar> Even that breaks
18:56:26 <lambdabot>   5
18:56:28 <kuffaar> This is very odd
18:56:41 <kuffaar> New connection: 127.0.0.1:4723
18:56:41 <kuffaar> WaRietcienigv efdo r3 7a0  nbeywt ec(osn)n efcrtoimo n1
18:56:45 <kmc> -- ++ breaks really?
18:56:47 * kuffaar scratches head
18:56:58 <dankna> kuffaar: I had a bug like that once.  You're inadvertently using the list monad.
18:57:01 <kmc> kuffaar, looks like two threads trying to talk over each other?
18:57:04 <dankna> kuffaar: instead of the monad you meant to use
18:57:08 <kmc> hehe
18:57:17 <kuffaar> dankna: Huh :o
18:57:45 <dankna> yeah.  add a type signature to the do-block and the resulting compiler error will help you pinpoint the actual problem.
18:58:02 <kmc> this is a problem with polymorphism
18:58:04 <dankna> note: or it might have been the Maybe monad, I forget now.  but it was one of those.  really confused me for like a whole hour.
18:58:07 <kmc> or with overloading rather
18:58:18 * ddarius had something similar to that happen with the parser to his Prolog interpreter, but the problem then was the Monoid instance for functions had changed.
18:58:51 <kmc> there's a monoid instance for functions?
18:59:00 <ddarius> @instances Monoid
18:59:00 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:59:02 <kuffaar> Like, adding a :: IO () at the end of the do block?
18:59:10 <dankna> yes, like that
18:59:15 <kuffaar> It still compiles fine
18:59:17 <dankna> oh :(
18:59:25 <dankna> hpaste some context for me then
18:59:41 <kuffaar> https://github.com/epicvrvs/Veles/blob/master/Source/Veles/Server.hs
18:59:57 <dankna> I like your comment on the file
19:00:21 <cdsmithus> kuffaar: I'd bet it's threads, not the list monad issue that dankna talked about.
19:00:23 <dankna> I have one of those too, but mine is like 10,000 lines and still doesn't work :)
19:00:40 <kuffaar> cdsmithus yeah
19:00:44 <kuffaar> It works fine when I telnet
19:00:48 <dankna> you know, it actually does look like threads
19:00:50 <kuffaar> But it fails with SCGI comm from nginx
19:00:57 <kuffaar> Waiting for a new connection
19:00:57 <kuffaar> Received 1 byte(s) from 127.0.0.1:4751:  "f"
19:00:57 <kuffaar> Received 1 byte(s) from 127.0.0.1:4751:  "w"
19:01:18 <dankna> you can disentangle the mixed messages into two separate ones, that wasn't the case when I had a bug that looked like this
19:01:19 <dankna> hm
19:01:26 <dankna> also, you're using threads, I wasn't :)
19:01:27 <cdsmithus> GHC is unusual in that when you have two threads writing to the console, it seems to do a context switch every character or two.
19:01:40 <ddarius> putStrLn is not atomic.
19:01:45 <kuffaar> cdsmithus because of the green thread stuff?
19:02:02 <dankna> putStrLnSlowly :: ConnectionInformation -> String -> IO ()
19:02:14 <kmc> if you want non-garbled messages from multiple threads
19:02:17 <ddarius> One way to deal with this is to have a process (forked IO action) that just receives messages over a Chan and prints them.
19:02:18 <dankna> putStrLnSlowly = do { takeMVar ... }
19:02:23 <cdsmithus> Right, of course it's not atomic.  It just seems to do a lot more context switches that I'd expect.  Which is cool from a pedagogical standpoint, but does make it harder to read debug messages!
19:02:40 <ddarius> This structure also has a lot of other benefits.
19:02:52 <kmc> mkLogger :: IO (String -> IO ()); mkLogger = do { c <- newChan; _ <- forkIO . forever (readChan c >>= putStrLn); return (writeChan c) }
19:03:02 <kuffaar> I hope it doesn't actually perform API calls with this granularity
19:03:08 <kuffaar> Because that would be devastating
19:03:19 <kuffaar> Calling WriteConsole 40-60 times to print 2 lines?
19:03:26 <kmc> i assume it buffers the IO
19:03:29 <kmc> you can use strace to see
19:03:32 <kuffaar> I would hope so
19:03:35 <kuffaar> kmc very funny :p
19:03:40 <kmc> what's funny?
19:03:42 <kuffaar> <kuffaar> Calling WriteConsole 40-60 times to print 2 lines?
19:03:43 <cdsmithus> kuffaar: performance of GHC is generally fine; it's just a quirk of console I/O I guess
19:03:45 <kuffaar> <kmc> you can use strace to see
19:03:50 <kmc> no strace for windows?
19:03:55 <kmc> nothing similar?
19:04:06 <dankna> there is actually, I used it once, but it was so long ago I've forgotten its name
19:04:09 <ddarius> kmc: There's something somewhere that will do something similar.
19:04:11 <kuffaar> kmc: I don't know of one but it would actually be useful hmm
19:04:29 <kmc> if not, i'm sorry you're using a platform that cripples developers
19:04:36 <kmc> i bet it does exist though
19:04:45 <kmc> probably not a simple command line utility ;P
19:05:16 * kmc overuses strace... like to find where a program's config file is
19:05:23 <kuffaar> kmc haha yes
19:05:24 <kuffaar> I do the same
19:05:26 <kmc> it's quicker than reading the manpage!
19:05:27 <cdsmithus> "StraceNT is a System Call Tracer for Windows. It provides similar functionality as of strace on Linux." http://www.intellectualheaven.com/default.asp?BH=projects&H=strace.htm
19:05:30 <kuffaar> Agreed
19:05:38 <ddarius> There's also a library somewhere that handles multiple concurrent printing statements by essentially allocating each it's own section of the screen if I remember correctly.
19:05:55 <kuffaar> kmc yesterday I was running OllyDbg on a Haskell binary to figure out why the TCP IO was broken
19:06:14 <shachaf> kmc: Isn't that the primary purpose of strace?
19:06:15 <kuffaar> As it turns out, Network.listenTo behaves differently on Windows on Linux
19:06:22 <kuffaar> On Windows it binds AF_INET6
19:06:27 <ddarius> kmc: In Gnome, only because the man pages don't actually tell you, which isn't surprising since it goes through like ten layers to decide.
19:06:27 <kuffaar> On Linux it binds AF_INET
19:06:59 <kuffaar> I figured this out by breaking on bind and looking hard at [[esp + 4] + 4]
19:07:03 <kuffaar> No, wait
19:07:13 <shachaf> ddarius: There are some GNOME programs that I *still* haven't figured out where they store their configuration. Even with strace and such.
19:07:21 <kuffaar> Not + 4 :[
19:07:30 <ddarius> shachaf: It took quite a while for me to figure out one case using strace.
19:07:42 <shachaf> It's not in ~/.config or ~/.gnome2 or in GNOME's registry thing or in most places I could think of.
19:07:58 <kuffaar> Need to redirect stderr to stdout for grep with strace, heh
19:08:20 * shachaf has no idea why they make it so complicated.
19:08:31 <kuffaar> How do you make a .ghci call a function?
19:08:41 * geheimdienst thinks it takes a lot of effort and restraint to make something simple
19:08:51 <kuffaar> I want it to run runServer 2342 whenever I launch ghci in a particular directly
19:08:54 <kuffaar> directory*
19:09:05 <shachaf> kuffaar: Just type it in?
19:09:11 <ddarius> shachaf: You thought Enterprise Java Beans were only a corporate thing?
19:09:21 <kuffaar> shachaf: Yeah, let's do work that could be done by a computer
19:09:26 <kuffaar> That's why we are programmers
19:09:31 <shachaf> kuffaar: I mean, just type it into .ghci.
19:09:33 <shachaf> kuffaar: Putting things in .ghci is the same as typing them into ghci, more or less.
19:09:36 <kuffaar> Oh
19:09:45 <kuffaar> I tried that, no luck so far
19:09:59 <shachaf> Seems to work for me.
19:10:20 <cdsmithus> Adding stuff to .ghci works, so I'm not sure why it isn't for you.
19:10:26 <kuffaar> oh I think it loads the file AFTER it executes the .ghci
19:10:38 <kuffaar> So I need to perform the loading in the ghci file, too
19:10:51 <kuffaar> Using :load or something
19:11:08 <kuffaar> <interactive>:1:1: Not in scope: `runServer'
19:11:08 <kuffaar> [1 of 1] Compiling Server           ( Server.hs, interpreted )
19:11:08 <shachaf> Makes sense.
19:11:12 <ddarius> It wouldn't be very useful otherwise...
19:11:20 * shachaf notes that if the current directory has a .ghci file with :!rm -rf /, it could lead to unfortunate results.
19:11:41 <kmc> i'm going to start distributing all my haskell projects with that file
19:12:04 <ddarius> Everyone trusts Haskell programmers.
19:12:08 <kuffaar> Hoping that one day one of them will run ghci as root?
19:12:28 <shachaf> kuffaar: It would be more interesting to make it fork a keylogger or something.
19:12:38 * shachaf wonders if that's already happened.
19:13:20 <kuffaar> 'rm' is not recognized as an internal or external command,
19:13:20 <kuffaar> operable program or batch file.
19:13:22 <kuffaar> Oh snap!
19:13:53 <shachaf> kuffaar: Well, you run Windows. Your life is bad enough as it is.
19:13:55 <cdsmithus> All you people that say "oh snap!"... etabot in #snapframework is unhappy with you.
19:14:11 <kuffaar> cdsmithus time to write filters
19:14:15 <kuffaar> Preferrably in regexp
19:14:20 <kuffaar> Haskell people love the RE
19:14:22 <kmc> now you have two problems
19:14:36 <kuffaar> I've been writing so much RE since early 2010
19:14:43 <Entroacceptor> kuffaar: haskell people like to write parsers instead :)
19:14:48 <kmc> i actually like regexes.  i wish the standard Haskell API for them wasn't so catastrophically bad
19:14:48 <kuffaar> Some of my code actually consists of up to 30% RE
19:15:03 <Entroacceptor> but it isn't a snap to parse written human conversations, I guess
19:15:03 <shachaf> kmc: Which API is the standard one?
19:15:06 <cdsmithus> Yes, it is catastrophically bad.
19:15:24 <kuffaar> Sooo what I should do now is to provide some way of providing globally atomic console IO
19:15:33 <kuffaar> I have no idea how to achieve that in Haskell
19:15:43 <kuffaar> I read that you use MVars for locking
19:15:56 <kmc> <kmc> mkLogger :: IO (String -> IO ()); mkLogger = do { c <- newChan; _ <- forkIO . forever (readChan c >>= putStrLn); return (writeChan c) }
19:16:05 <ddarius> kuffaar: I already described a good way to do what you want and kmc gave you code for it.
19:16:07 <cdsmithus> kuffaar: People just told you.  Create a Chan.  fork a thread to listen on it.
19:16:17 <kmc> don't even expose the chan; expose its write method
19:16:30 <dankna> I suggested MVars instead, but on reflection the Chan is a better approach
19:16:36 <ddarius> kmc: You should read Reppy's thesis on CML if you haven't alreoady.
19:16:43 <kmc> concurrent ML?
19:16:45 <kmc> sounds interesting
19:16:47 <ddarius> Yes.
19:16:51 <kuffaar> Why the _ <-?
19:16:57 <ddarius> I didn't think it was as interesting as it turned out to be.
19:16:59 <kmc> kuffaar, explicit locking is to be avoided when possible
19:17:06 <cdsmithus> kuffaar: because otherwise, GHC might whine.
19:17:16 <kmc> kuffaar, because ghc >= 6.12 warns when an action has a non-() result which is ignored
19:17:22 <kmc> and forkIO returns a ThreadId
19:17:23 <ddarius> I thought it was just ML + channels, but it is much more than that, or rather the abstraction described is significant.
19:17:26 <kmc> which is pretty useless
19:17:29 <kuffaar> Ohh I forgot about that
19:17:40 <kuffaar> ghc 7 doesn't whine about it
19:17:49 <kmc> you should turn on -Wall
19:17:53 <ddarius> I don't believe that warning is on by default.
19:17:57 <kuffaar> Oh
19:17:58 <ddarius> And I don't like that warning.
19:18:05 <kuffaar> How do you set -Wall globally?
19:18:11 <kmc> the catastrophically bad regex API is the one which defines an overloaded (=~) which does all kinds of different unrelated things
19:18:13 <cdsmithus> -fno-warn-unused-do-binds, I believe
19:18:15 <kmc> kuffaar, "globally"?
19:18:21 <kmc> i forgot the package name
19:18:34 <kuffaar> kmc i.e., I run ghci in /b/c/d/e which has no .ghci
19:18:41 <kuffaar> And I still want it to use -Wall
19:18:44 <kmc> you should set it per project
19:18:46 <kmc> in your cabal file
19:19:26 * ddarius should modify lambdabot-utils to include a warning: "Warning: This code uses lambdabot-utils."
19:19:26 <shachaf> kuffaar: For ghci you can set it in ~/.ghci.
19:19:50 <cdsmithus> Yeah, I was going to say, GHCi always reads the one in $HOME
19:20:01 <kuffaar> So how do you do it?
19:20:05 <kuffaar> :set -Wall or something like that?
19:20:12 <cdsmithus> Sure, that works
19:20:35 <cdsmithus> I have ":set -fprint-explicit-foralls" in mine, and it works.  I assume -Wall will be the same
19:22:10 <kuffaar> Warning: A do-notation statement discarded a result of type ThreadId.
19:22:12 <kuffaar> Haha
19:22:37 <kmc> i'll take a moment to plug my tiny thread library: http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/Control-Concurrent-Spawn.html
19:22:39 <kuffaar> cdsmithus yeah I use that now, too :p
19:23:02 <kmc> note that the type signatures don't mention Chan, MVar, etc.
19:23:09 <kmc> i advocate a style where such details are hidden inside closure
19:23:11 <cdsmithus> I agree with ddarius, that's an unhelpful warning, and fixing it just uglifies code.  You can turn it off with -fno-warn-unused-do-binds.
19:23:39 <dankna> I actually like the warning
19:23:45 <dankna> but I also like to be contrary
19:24:01 <ddarius> kmc: Looks like futures.
19:24:15 <kmc> yeah
19:24:39 <ddarius> kmc: Anyway, I think you'll find Reppy's thesis rather interesting.
19:24:50 <gwern> kuffaar: so use `void`
19:25:24 <kuffaar> gwern: What do you mean by that?
19:25:28 <kmc> :t void
19:25:30 <lambdabot> Not in scope: `void'
19:25:34 <gwern> discard the threadid with void
19:25:35 <kmc> eh lambdabot doesn't have it
19:25:35 <kuffaar> :t ()
19:25:36 <lambdabot> ()
19:25:48 <kmc> void :: (Functor f) => f a -> f ()
19:25:52 <kmc> void = fmap (const ())
19:25:52 <gwern> kmc: no surprise, lambdabot is still on 6.10 or 6.12
19:25:59 <cdsmithus> Where is void?  Not in anything I normally import.
19:26:03 <kuffaar> Never heard of it before
19:26:45 <kmc> i really like being able to do things like "  return $ bracket_ (waitQSem s) (signalQSem s)"
19:26:48 <kuffaar> But yeah, I don't want to use that all the time, seems excessive
19:26:57 <kuffaar> Doesn't help the code really now does it
19:27:22 <kuffaar> Or maybe it does increase verbosity hmm
19:27:56 <kuffaar> cdsmithus: Control.Monad
19:28:01 <kuffaar> It's Haskell 2010 though
19:28:19 <gwern> kuffaar: I believe it does help the code's memory characteristics
19:28:35 <gwern> you aren't accidentally holding onto something but can GC it immediately
19:28:43 <gwern> ndm had a blog post on that iirc
19:29:06 <WM2D> Tremendous error: updated cabal & xmonad, and now it cant find xmonad.managehook
19:29:57 <joe6> I am doing: requesttype <- try (string "Standard") <|> try (string "Class")
19:29:59 <joe6> return (read requesttype)
19:30:07 <joe6> is there a better way of doing the above ?
19:30:25 <kuffaar> I wonder if Haskell nerds would use an IRC client just because it was written in Haskell and easily lets you write extensions in Haskell
19:30:36 <joe6> data RequestType = Standard | Class | Vendor
19:30:38 <kmc> probably
19:30:53 <kuffaar> What's next, the emacs of Haskell?
19:30:56 <gwern> joe6: I suppose you could do something like >>= read, to get it onto one line
19:31:01 <kmc> ManateeLazyCat is working on that kuffaar
19:31:09 <mm_freak> joe6: requestType <- read <$> (try (string "Standard") <|> string "Class")
19:31:11 <cdsmithus> joe6: fmap helps: requesttype <- read `fmap` (try (string "Standard") <|> string "Class")
19:31:12 <kmc> http://hackage.haskell.org/package/manatee
19:31:14 <kuffaar> kmc: CLI or GUI?
19:31:19 <kmc> GTK+ GUI
19:31:19 <cdsmithus> Or <$> as a synonym for `fmap`
19:31:21 <kmc> it embeds everything
19:31:25 <kmc> kind of insane
19:31:26 <kuffaar> Hmm I wanted to use Qt
19:31:27 <gwern> kmc: well, we already had yi
19:31:35 <kuffaar> This video contains content from UMG. It is not available in your country.
19:31:35 <kmc> can yi read mail?
19:31:35 <kuffaar> Sorry about that.
19:31:48 <kuffaar> http://www.youtube.com/watch?v=A3DgKDVkyeM haha
19:31:48 <mm_freak> joe6: the second try is not recommended, because generally failing parsers /should/ consume
19:32:04 <gwern> kmc: if it's a text file, sure
19:32:09 <ddarius> WM2D: ManageHook is in contrib, I'm pretty sure.
19:32:12 <joe6> mm_freak: I actually have 3 types that 
19:32:17 <joe6> i am matching against
19:32:29 <mm_freak> joe6: then you may be better off using 'choice'
19:32:32 <WM2D> Ah-- xmonad-contrib install craps out
19:32:58 <joe6> mm_freak: will check out choice. Thanks for the suggestion.
19:33:39 <mm_freak> joe6: which parser library are you using?  because i know 'choice' from attoparsec and i'm not sure if it's in parsec
19:33:45 <WM2D> hackage mirrors wd b nice, but the list degenerated into an IT-like discussion about the need for corporate standards of server invulnerability
19:33:57 <dankna> yeah :(
19:33:58 <joe6> do I have to write out the different items, can I do that automatically?
19:34:10 <cdsmithus> gwern: I hunted down what I think it Neil's blog post you mentioned.  But it's about using mapM_ versus mapM.  I can't imagine any benefit from using void.
19:34:23 <joe6> something like "map (show RequestType)?
19:34:27 <gwern> cdsmithus: isn't mapM_ basically void $ mapM?
19:34:42 <mm_freak> joe6: you can automate that, but you should probably avoid using 'read'
19:34:44 <cdsmithus> gwern: no.  The internal plumbing is redone to release references earlier
19:34:44 <joe6> mm_freak: parsec
19:34:58 <cdsmithus> Semantically it is.  But performance wise, it'll be better
19:35:06 <joe6> mm_freak: any suggestions on how I can avoid using Read?
19:35:11 <gwern> cdsmithus: ok, so void is useful for everything but mapM_
19:35:38 <mm_freak> joe6: requestType <- choice [ Standard <$> try (string "Standard"), Class <$> try (string "Class"), … ]
19:35:48 <mm_freak> joe6: as said, the last parser doesn't need to 'try'
19:35:57 <cdsmithus> gwern: I guess what I'm saying is that using void shouldn't ever have any effect, except for making the annoying GHC warning go away
19:36:02 <mm_freak> uh, wait
19:36:05 <mm_freak> not <$>, but <$
19:36:15 <gwern> cdsmithus: denotational or operational effect?
19:36:18 <mm_freak> joe6: requestType <- choice [ Standard <$ try (string "Standard"), Class <$ try (string "Class"), … ]
19:36:20 <joe6> mm_freak: ok, thanks. i will check that out.
19:36:24 <cdsmithus> gwern: either (assuming it's inlined)
19:36:39 <joe6> mm_freak: will check out about <$
19:36:52 * ddarius eliminates the two remaining lines of the earlier Search.hs.
19:37:05 <mm_freak> (<$) is just fmap . const
19:37:16 <mm_freak> > 4 <$ Just 2
19:37:17 <lambdabot>   Just 4
19:38:03 <joe6> mm_freak: is it possibly to automate to read the different choices of the data type? instead of having to write string "Standard" and string "Class" and so on.
19:38:14 <mm_freak> if the parser (string "Standard") succeeds, then you know it's the string "Standard", so there is no point in using 'read'…  in general using 'read' in a parser is not a good idea
19:38:17 <aristid> @let repeatedly f = let repeat = f >>= \x -> if x then repeat else return () in repeat
19:38:18 <lambdabot>  Defined.
19:38:23 <aristid> :t repeatedly
19:38:24 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
19:38:28 <ddarius> joe6: Yes... ...
19:38:28 <mm_freak> joe6: yes
19:38:37 <mm_freak> > map show [False ..]
19:38:38 <lambdabot>   ["False","True"]
19:39:08 <aristid> > repeatedly [True]
19:39:12 <lambdabot>   mueval-core: Time limit exceeded
19:39:15 <joe6> > map show [Standard ..]
19:39:16 <lambdabot>   Not in scope: data constructor `Standard'
19:39:16 <aristid> > repeatedly [False]
19:39:18 <lambdabot>   [()]
19:39:27 <aristid> > repeatedly [False,False]
19:39:28 <lambdabot>   [(),()]
19:39:39 <mm_freak> :t repeatedly
19:39:40 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
19:39:40 <joe6> ok, that's brilliant. Thanks a lot, guys
19:40:58 <luqui> :t runIdentity
19:40:59 <lambdabot> forall a. Identity a -> a
19:42:21 <kuffaar> <kmc> mkLogger :: IO (String -> IO ()); mkLogger = do { c <- newChan; _ <- forkIO . forever (readChan c >>= putStrLn); return (writeChan c) }
19:42:31 <kuffaar> Wow, I think I get how that works
19:42:38 <kuffaar> Never would have occured to me :p
19:43:10 <mm_freak> although i would prefer to use an MVar
19:43:14 <mm_freak> instead of Chan
19:43:20 <WM2D> looks like i'm in business -- cabal was able to connect to hackage to install xmonad-contrib
19:43:26 <kuffaar> mm_freak they told me it's bad to use explicit locking
19:43:47 <mm_freak> kuffaar: well, MVar keeps your resources under control
19:44:04 <mm_freak> Chan might explode, if you have a slow stdout
19:44:14 <kuffaar> Hmm
19:44:21 <mm_freak> also MVar is not about explicit locking
19:44:37 <cdsmithus> The nehavior is slightly different: an MVar based version would guarantee that the message is printed (at least to a lower-level buffer) before your continue.  The Chan version prints asynchronously.  So if you care about the order of printing and other I/O operations, I guess...
19:44:59 <mm_freak> cdsmithus: no, it wouldn't, but it would guarantee that at most one string is in the printing queue
19:45:32 <cdsmithus> Oh, we were thinking of different things
19:46:05 <cdsmithus> I assume that "an MVar version" meant : printConsole msg = takeMVar v >> putStrLn msg >> putMVar v ()
19:46:23 <kmc> eew, at least use "withMVar"
19:46:25 <mm_freak> nope
19:46:34 <ddarius> An MVar is like an one-element blocking channel.
19:46:47 <mm_freak> replace newChan by newEmptyMVar and readChan by takeMVar
19:46:48 <cdsmithus> Got it.  So you could still fork the thread, and use MVar
19:46:57 <mm_freak> and writeChan by putMVar
19:47:56 <kuffaar> I have a problem though - as long as the locked console output is tied to a chan or an MVar, I need to pass this around whenever I want to use it. What can I do about that?
19:48:02 <mm_freak> in fact, i would also make the thread stoppable…  right now there is no guarantee that the last message is written to the log
19:48:10 <dankna> kuffaar: ReaderT monad
19:48:13 <cdsmithus> kmc: yeah, but the type for withMVar is trickier to remember.  It's definitely the better choice, though.
19:48:18 <kmc> kuffaar, well don't pass a Chan; pass a "writer" action
19:48:21 <kmc> but yes you have to pass it
19:48:23 <mm_freak> data LoggerCmd = PrintLog [String] | QuitLog (IO ())
19:48:28 <kmc> or a "writer" function i should say
19:49:08 <kuffaar> dankna so this would change the signature of all the functions that use it, still? Unless they already use a monad of my own and I can simply extend it?
19:49:16 <kmc> yes
19:49:20 <kmc> unless you use a global state hack
19:49:23 <dankna> kuffaar: yes, it would.
19:49:25 <kuffaar> :D
19:49:27 <mm_freak> kuffaar: most concurrent applications have some kind of state…  you may make your life easier by writing some kind of reader/state monad
19:49:37 <kuffaar> kmc that's what I would use a global lock for, in C++ and Ruby etc
19:49:46 <kuffaar> mm_freak alright
19:49:52 <mm_freak> type MyAppT m = StateT MyAppConfig m
19:50:03 <mm_freak> and your MyAppConfig could include the logger function
19:51:04 <lars9> it's so easy to cause naming confliction when defining record type: Point2D = Point2D{x::Int,y::Int}, ...Point3D{x::Int,y::Int,z::Int}, then error occurs... It will be good if compiler can recoganize syntax like Point2D.x, Point3D.y...
19:51:35 <mm_freak> this is better than a global state in any case, because it keeps your state in control and also enables you to run multiple instances of your application in the same executable
19:51:47 <kuffaar> lars9: That's one of the first things I noticed with Haskell, I consider it a flaw tbh
19:51:56 <kuffaar> It forces you to write code like a dumb C hacker
19:52:00 <kuffaar> With function prefixes
19:52:19 <kuffaar> point2Dx :: Int,
19:52:21 <kuffaar> etc
19:52:25 <j-invariant> it's not possible to create PointD (n :: Integer) in haskell
19:52:30 <mm_freak> lars9: you can use modules to help with that, but i agree that haskell needs better syntactic support for records
19:52:54 <mm_freak> j-invariant: what would that be?
19:53:00 <kuffaar> I would prefer Point2D.x or something like that
19:53:16 <mm_freak> i would prefer (x myPoint) over myPoint.x
19:53:25 <mm_freak> but the 'x' should be chosen by context
19:53:46 <kuffaar> I didn't suggest that :o
19:54:08 <kuffaar> I was suggesting Point2D.x myPoint
19:54:12 <kuffaar> Not myPoint.x
19:54:31 <mm_freak> oh, i see
19:54:37 <ddarius> If you use the module system, you can use qualification like normal.
19:54:38 <lars9> j-invariant: PointND is the most simple way to remind ppl importance of dependent type
19:54:56 <ddarius> The only problem is that most implementations tie modules to files which is massively heavy-weight.
19:55:07 <mm_freak> kuffaar: you have that already in haskell
19:55:20 <cdsmithus> class HasX r f | r -> f where x :: (f -> (f,a)) -> (r -> (r,a))
19:55:23 <luqui> I would love something so simple as nested modules with lexical scoping.
19:55:30 <mm_freak> lars9: you don't need dependent types for that
19:55:31 <cdsmithus> :)
19:55:38 <kuffaar> mm_freak you mean you want me to make a new module for every single record?
19:55:41 <ddarius> luqui: Yes, I've suggested "local modules" several time.  I think they are the right solution to this problem.
19:56:14 <mm_freak> kuffaar: i don't want you to do anything
19:56:18 <ddarius> Rather than treating conflating the record concept with a namespacing concept.
19:56:24 <ddarius> s/treating//
19:56:58 <lars9> mm_freak: how to?
19:57:11 <mm_freak> lars9: ordinary type level arithmetic can do it
19:57:19 <luqui> ddarius, I agree. TDNR makes me queasy.
19:57:28 <mm_freak> ddarius: well, i would prefer not having to spell out the record name for each and every function application
19:57:41 <mm_freak> it works in other languages, too, after all
19:57:49 <ddarius> luqui: Same here.
19:58:04 <ddarius> mm_freak: You don't.  Don't import it qualified if you don't want it qualified.
19:58:21 <mm_freak> ddarius: and if i import two modules with the same names?
19:58:29 <luqui> mm_freak, but think about the type inference in other languages.  if it doesn't suck, it's because it's not implemented at all.
19:58:48 <ddarius> mm_freak: Then you need to disambiguate, but you need to anyway.
19:58:54 <j-invariant> some untyped languages have type inference
19:59:06 <luqui> j-invariant, huh?
19:59:09 <mm_freak> luqui: we have working type inference in haskell, so we should use it for that
19:59:12 <kuffaar> Yeah I didn't get that either :p
19:59:18 <earlz> Hi, just trying to learn and play around with haskell.  I've tried doing a simple `x=10` and get "<interactive>:1:2: parse error on input `='" in ghc's interactive mode. From what it looks like this should work though? What's wrong?
19:59:42 <kuffaar> earlz ghci sucks and doesn't work like regular Haskell code
19:59:47 <ddarius> @hoogle try
19:59:48 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
19:59:48 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
19:59:48 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
19:59:48 <luqui> mm_freak, as we get more comfortable with the feature, we will start to use it more.  and complex uses of TDNR and type inference don't mix. 
19:59:48 <kuffaar> which is super irritating for beginners
20:00:01 <kuffaar> earlz: I think the ghci syntax for that was let x = 10
20:00:05 <luqui> mm_freak, then we get into (a little bit) of scala's situation where the compiler is always telling you it can't figure stuff out
20:00:05 <kuffaar> And then you can use x after that
20:00:08 <kmc> kuffaar, it works mostly like an IO monad "do" block
20:00:09 <aristid> kuffaar: ghci sucks? no, it's awesome.
20:00:10 <mm_freak> kuffaar: it doesn't "suck"…  it just has some semantics you need to understand
20:00:12 <luqui> unpredictably, like magic
20:00:15 <lars9> mm_freak: that's interesting, how to do that?
20:00:18 <kmc> yeah all things i don't understand suck
20:00:29 <earlz> kuffaar: hmm.. the tutorial I'm reading doesn't address that. What is probably recommended then? Hugs?
20:00:29 <kmc> also saying something sucks is the best way to get help with it online
20:00:35 <ddarius> mm_freak: Note that local modules would provide much more than just lightweight scoping for record fields.  You would have lightweight abstract data types as well.
20:00:38 <kmc> earlz, ghci is definitely recommended
20:00:52 <kmc> don't worry that kuffaar doesn't understand ghci
20:00:54 <kuffaar> earlz: GHC is the biggest and most mature piece of Haskell software, I think
20:00:56 <kmc> i'm sure you can read the manual
20:01:00 <kuffaar> so I'd stick with that
20:01:12 <mm_freak> lars9: for compile time guarantees you can use regular type-level naturals, for run-time guarantees (i think) you can use reification
20:01:24 <kuffaar> kmc: It is very disturbing that ghc doesn't work like the code does
20:01:33 <kmc> it works like an IO monad do block
20:01:38 <cdsmithus> earlz: The thing to remember is that in GHCi, you're basically working in an implicit IO "do" block.  Not the top level of a file.
20:01:41 <ddarius> kuffaar: I'm pretty sure it's not the biggest, but it probably is the most mature since it predates Haskell actually existing (though it is predated by HBC.)
20:01:41 <kuffaar> as you can see it confuses people ^
20:01:47 <kuffaar> kmc: That's irrelevant
20:01:52 <kmc> if it were a file top level you'd be unable to type things like "2+2"
20:01:54 <kuffaar> It should work like source code
20:01:59 <kmc> it *does* work like source code
20:02:00 <kuffaar> It should support both
20:02:07 <kmc> kuffaar, then it wouldn't work like source code
20:02:09 <kuffaar> Every other REPL can handle it
20:02:10 <ddarius> kuffaar: Then it wouldn't work like source code
20:02:12 <kmc> because source code doesn't support both
20:02:12 <mm_freak> luqui: if the compiler can't figure it out, you can still add the record name
20:02:14 <luqui> kuffaar, then you get into an opposite confusing situation
20:02:15 <earlz> heh, so basically just prefix let before everything..
20:02:15 <kuffaar> You can support both
20:02:15 <kmc> this is retarded
20:02:19 <cdsmithus> kuffaar: You seem to have a strong tendency to badmouth things you don't understand. 
20:02:23 <luqui> kuffaar, where you can say x <- readFile in ghci, but not in a source file
20:02:31 <mm_freak> luqui: that way you reduce the cases you need to get verbose
20:02:37 <kuffaar> Use fallback interpretation, what's the big deal?
20:02:40 <luqui> kuffaar, although of the two, I would prefer that one. :-)
20:03:11 <mm_freak> kuffaar: you really don't need top-level definitions in GHCi
20:03:32 <ddarius> mm_freak: There's no real reason it shouldn't support it.
20:03:38 <cdsmithus> mm_freak: I'd sure like to be able to declare new types now and then, though.
20:03:38 <luqui> mm_freak, basically i don't like compilers that try to do as much as they can and then whine when they're too stupid.  I like to be able to predict my compiler's behavior.  Means I can write code with confidence.
20:03:39 <mm_freak> in fact, you /can't/ have them in a sound way
20:03:44 <ddarius> I'm pretty sure HBCi did, and the MLs have always done this.
20:04:23 <aristid> cdsmithus: yes, declaring types would be very nice
20:04:31 <mm_freak> ddarius: well, you might run into problems with forward-references
20:04:32 <mm_freak> or reference cycles
20:04:34 <mm_freak> cdsmithus: i agree
20:04:53 <mm_freak> anyway, all that doesn't make GHCi "suck", at least compared to the command line interpreters of most other languages
20:04:55 <luqui> mm_freak, reference cycles?  like ghci> x = y  ghci> y = 1:x  ?
20:05:03 <aristid> @oeis 7,2,5,1
20:05:07 <lambdabot>  Decimal expansion of 1/(2pi).
20:05:07 <lambdabot>  [1,5,9,1,5,4,9,4,3,0,9,1,8,9,5,3,3,5,7,6,8,8,8,3,7,6,3,3,7,2,5,1,4,3,6,2,0,3...
20:05:13 <ddarius> mm_freak: You won't be able to paste a source file in it, but there's no problem with otherwise supporting those.
20:05:21 <mm_freak> luqui: when two types reference each other
20:05:27 <aristid> @oeis 7,2,5,1,7
20:05:30 <ddarius> mm_freak: GHCi is a kind of crappy REPL.
20:05:30 <lambdabot>  Limit of the power tower t(2)^(t(3)^(t(4)^(t(5)^(...) ...))) in which t(n)=n...
20:05:30 <lambdabot>  [1,5,2,3,2,3,0,3,2,4,2,0,8,5,2,9,8,3,0,7,0,4,3,0,8,1,7,2,5,1,7,7,0,6,5,5,7,6...
20:05:45 <luqui> mm_freak, wait... what does that have to do with ghci?
20:06:06 <mm_freak> luqui: i suppose you could use ; separation to define them
20:06:14 <ddarius> mm_freak: You just have a multiline input mode which GHCi already has.
20:06:40 <mm_freak> luqui: but you couldn't define them on separate input lines, because you don't have…  well…  transactions
20:06:54 <luqui> i think if we support type declarations in ghci, we should require all recursion to be encoded with Mu
20:06:55 <mm_freak> ddarius: oh?
20:07:02 <ddarius> See :{ and :}
20:07:21 <mm_freak> oh, great…  didn't know that
20:07:32 <mm_freak> that's useful :}
20:07:33 <ddarius> Admittedly, GHC doesn't support layout in them currently (I don't think), but that is far from insurmountable.
20:07:36 <luqui> mm_freak, it half-sucks though...
20:07:38 <cdsmithus> IIRC, though, you don't get layout in GHCi until GHC 7
20:07:49 <ddarius> cdsmithus: Ah, so they already fixed that.
20:07:56 * ddarius tests.
20:07:56 <cdsmithus> I thought so... don't quote me
20:08:04 <luqui> oh cool, ghci 7 has improvements, must check out
20:08:24 <mm_freak> ddarius: anyway, have you ever tried the python "REPL"?
20:08:25 <cdsmithus> luqui: Best to wait on the Haskell platform, unless you want to spend the next few days fighting library dependencies
20:08:37 <mm_freak> or the PHP "REPL"?
20:08:50 <ddarius> mm_freak: Yes to the former.
20:08:50 <earlz> so I'm a bit confused. When do you need something like `x=return 5` instead of `x=5` ?
20:08:56 <kuffaar> I've used the Python, Ruby and a CPAN Perl one
20:09:12 <kuffaar> earlz: "return" is an ill chosen name
20:09:24 <kuffaar> It has very little to do with the return statement in other languages you might be used to
20:09:38 <joe6> i am trying to understand this: can you please help?
20:09:39 <luqui> cdsmithus, i am smart enough not to install from tarballs.  i'll probably install into a local prefix.
20:09:39 <joe6> :t Class <$ try . string $ "Class" = RequestType
20:09:39 <joe6> :t (<$) (Class) (try . string $ "Class")  =  GenParser Char st RequestType
20:09:40 <lambdabot> parse error on input `='
20:09:40 <lambdabot> parse error on input `='
20:09:47 <cdsmithus> earlz: return 5 puts the value 5 into a monad.  If you don't know what a monad is, think of it like this: 5 is just the value 5, but "return 5" is an I/O action that does nothing and give 5 as its *result*
20:09:53 <kuffaar> earlz: At first you will probably only encounter it in functions which have IO in their signature
20:09:58 <joe6> i do not understand why (<$) has a different type than using <$
20:10:04 <luqui> cdsmithus, (maybe "stupid enough not to install from tarballs", because it takes a genius...)
20:10:12 <mm_freak> ddarius: GHCi is far ahead of them…  python's REPL is very poor and PHP's REPL is practically non-existent
20:10:21 <aristid> joe6: it's not the same expression
20:10:28 <ddarius> joe6: It doesn't.  That isn't how the first expression parses.
20:10:28 <earlz> kuffaar: ok thanks. so basically use return only with monads. (which, yea I haven't quite learned yet)
20:10:41 <luqui> mm_freak, have you ever used C# immediate mode?
20:10:42 <aristid> joe6: ((<$) (Class) (try . string)) "Class"
20:10:47 <mm_freak> luqui: nope
20:10:58 <joe6> aristid: oh, ok. thanks a lot.
20:11:00 <cdsmithus> earlz: Right, return is only used with monads.  Which, as you're learning, means "I/O actions"
20:11:08 <luqui> mm_freak, you wouldn't believe a REPL could be that bad until you try it.
20:11:08 <ddarius> mm_freak: As far as I remember, the Python REPL is just a Python interpreter.  You can execute arbitrary Python code in it.
20:11:24 <ddarius> luqui: I've abused C# immediate mode as a REPL.
20:11:27 <ddarius> It's frustrating.
20:11:35 <kuffaar> earlz: Yeah the actual use is unclear in the beginning, I think, until you get in touch with the Monad typeclass and the >>= (bind) and return function, which are defining for everything that is an instance of the Monad typeclass
20:11:47 <kuffaar> I don't have a good grasp of the subject myself yet
20:11:48 <ddarius> Being limited to an expression in a statement-oriented language is very limiting.
20:11:51 <luqui> ddarius, wait... abused?  what is it supposed to be for/
20:12:04 <kuffaar> ddarius haha a C# REPL? Interesting
20:12:27 <mm_freak> luqui: try the PHP one
20:12:30 <mm_freak> really, do it
20:12:42 <ddarius> mm_freak: I'm unclear what you find wrong with Python's.
20:12:49 <aristid> ddarius: python is statement-oriented too
20:13:08 <ddarius> aristid: Yes, but Python's REPL executes statements.
20:13:10 <mm_freak> ddarius: as one example, i have to spell out everything
20:13:11 <luqui> mm_freak, how?  is it just the php executable or is there something special?
20:13:23 <mm_freak> GHCi has completion, which works very well and is context-sensitive
20:13:28 <mm_freak> using type inference
20:13:41 <mm_freak> luqui: no, just the PHP executable
20:13:41 <aristid> ddarius: why does C# immediate mode disallow statements?
20:13:54 <kuffaar> I had no idea that ghci had completion - can you actually tab out stuff?
20:13:59 <cdsmithus> Yes
20:14:04 <ddarius> aristid: I don't know.  I didn't write it.
20:14:06 <aristid> kuffaar: yes, i use it all the time :)
20:14:21 <ddarius> aristid: Or were you asking "whether it does"?
20:14:31 <luqui> mm_freak, oh, that's like perl's.  it's not really trying to be a REPL at all, it's more just a RE
20:14:35 <aristid> ddarius: you already said that it does. i asked why.
20:14:57 <mm_freak> kuffaar: you can complete everything in GHCi
20:15:17 <mm_freak> it's the only REPL i know with such sophisticated completion
20:15:24 <cdsmithus> GHCi even does filename completion in the string literal after a readFile... which is *awesome*
20:15:27 <luqui> mm_freak, what do you mean it uses type inference?
20:15:51 <luqui> cdsmithus, woah....
20:15:51 <aristid> cdsmithus: it does filename completion in ALL string literals.
20:16:00 <ddarius> mm_freak: Is completion the only issue you have with Python's interpreter?
20:16:06 <mm_freak> luqui: if you are in type context, it completes types, if you are in constructor context, it completes a constructor…  and it completes only the constructors of the corresponding type at that point
20:16:45 <aristid> ddarius: for obvious reasons the python repl cannot show a lot of useful type information which is one of my favorite use cases for ghci
20:17:00 <ddarius> aristid: We aren't comparing languages.
20:17:06 <mm_freak> ddarius: well, since i mostly enter expressions and want their result, that's my main issue
20:17:22 <ddarius> aristid: My main issue with the Python interpreter is that it doesn't interpret Haskell.
20:17:26 <aristid> ddarius: i know, but this is one of my favorite features of ghc_i_
20:17:35 <mm_freak> lol
20:17:51 <ddarius> mm_freak: Well I don't use completion and would much rather have the full power of the language available without completion than have completion without the power.
20:17:53 <kuffaar> Prelude> :t put
20:17:53 <kuffaar> putChar   putStr    putStrLn
20:17:55 <kuffaar> Great stuff
20:17:56 <luqui> mm_freak, I can't verify that.  data Foo = Foo (Maybe Int).   ghci> let bar (Foo (<TAB>       Display all 474 possibilities?
20:18:00 <luqui> is that what you meant?
20:19:00 <luqui> I am working on a language that is supposed to be used from the command line.  Trying to get syntax highlighting on the command line even :-)
20:19:01 <mm_freak> luqui: uhm…  i could swear GHCi did that
20:19:40 <luqui> but i'm working on a new language every week so we'll see %-)
20:19:41 <aristid> mm_freak: which version of GHC do you use?
20:19:51 <cdsmithus> Wow... I wrote this two and a half years ago... http://cdsmith.wordpress.com/2007/07/14/my-dream-ghci-session/
20:19:57 <mm_freak> aristid: 6.12.3
20:20:26 <kuffaar> 2007 2011
20:20:29 <kuffaar> 2.5 years
20:20:31 <aristid> mm_freak: mmmh
20:20:35 <kuffaar> Does not parse
20:20:44 <cdsmithus> Oh... did I do math wrong?
20:20:48 <joe6> is there a function that can do: (a -> m b) -> [a] -> [m b]
20:20:49 <cdsmithus> 3.5
20:20:55 <joe6> choice . mapM (try . string. show) [Standard ..]
20:21:02 <joe6> I am trying to get something like the above.
20:21:16 <luqui> cdsmithus, yeah that would be pretty nice :-)
20:21:17 <aristid> cdsmithus: i think 2.5 is correct but it's pretty late :D
20:21:21 <kuffaar> @hoogle (a -> m b) -> [a] -> [m b]
20:21:22 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
20:21:22 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
20:21:22 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
20:21:24 <cdsmithus> Don't mind my arithmetic... I'm only working on a graduate math degree :) 
20:21:51 <aristid> joe6: just map
20:21:54 <kuffaar> cdsmithus who cares about trivial stuff like that
20:21:54 <cmars232> how does the 'do' know what monad its in?
20:22:01 <joe6> aristid: ok, thanks.
20:22:15 <cmars232> could i use do syntax to chain a bunch of stuff in the Maybe monad, nested in the IO monad?
20:22:15 <kuffaar> I always facepalm when people think mathematics has anything to do with being able to quickly solve simple arithmetic problems
20:22:25 <cmars232> or is that crazy talk?
20:22:27 <luqui> cmars232, type inference.   eg x <- foo,  matches type of foo against m a, and then m is the monad.
20:22:29 <kuffaar> They have no idea what mathematicians usually concern themselves with
20:22:31 <aristid> cmars232: with MaybeT, maybe? :D
20:22:46 * ddarius thinks people underestimate the power of GHCi's :def feature, which is one of the redeeming qualities of GHCi.
20:22:55 <cmars232> ok, haven't gotten to transformers yet, thanks!
20:22:57 <luqui> ddarius, i don't even know what it is
20:23:19 <kuffaar> Neither do I
20:23:29 <luqui> cmars232, it's not about transformers... unless your question was in a context to which i'm not privy
20:23:38 <ddarius> luqui: It lets you define new GHCi : commands.
20:23:41 <luqui> cmars232, oh nevermind, missed that one
20:23:56 <cmars232> oh... i thought the T in MaybeT was for transformer...
20:24:14 <luqui> cmars232, yeah it is.  missed your question about chaining in Maybe and IO
20:24:23 <cmars232> i'm doing something like this in IO: let maybeTo = readJSON msg >>= telexGet To >>= readEndpoint
20:24:30 <cmars232> lots of >>='s ...
20:24:48 <luqui> and each one is a function of type a -> IO (Maybe b)  for some a and b?
20:25:09 <cmars232> no, each one is a a -> Maybe b
20:25:15 <aristid> cmars232: >>= can always be replaced by do
20:25:25 <aristid> cmars232: if it's just Maybe, you don't need MaybeT
20:25:28 <tolkad> > let a.b = 0 in a.b
20:25:29 <lambdabot>   0
20:25:33 <joe6> mm_freak: what do you think of this: requesttype <- choice . map  (try . string. show) $ [Standard ..] ; return (read requestType) :: RequestType
20:25:37 <aristid> cmars232: Maybe is a monad already. i thought you were mixing it with IO
20:25:40 <tolkad> > let a. = 0 in a.
20:25:41 <lambdabot>   <no location info>: parse error on input `='
20:25:52 <mm_freak> cmars232: just 'do' it
20:26:01 <cmars232> hehe
20:26:04 <mm_freak> let maybeTo = do …
20:26:06 <joe6> mm_freak: it wourked from the ghci prompt
20:26:17 <joe6> but just wanted to check if you have any thoughts.
20:26:19 <mm_freak> cmars232: you can separate things by ; or use indented layout
20:26:24 <tolkad> when I tell lambdabot « let a.b = 0 in a.b » it works, but when I do the same thing in ghci it doesn't
20:26:30 <tolkad> it says a and b are undefined
20:26:39 <tolkad> which one is wrong?
20:26:41 <luqui> i wish i could mouseover a username in my irc client and it would highlight everything they have said (or about them) recently
20:26:51 <luqui> i wish lots of UI stuff :-P
20:26:54 <monochrom> lambdabot is wrong
20:27:05 <ddarius> luqui: Be like ManateeLazyCat.
20:27:07 <mm_freak> joe6: seems fine, although it will 'try' the last possibility, which is unfortunate
20:27:13 <tolkad> monochrom: why can't I use . in an identifier?
20:27:25 <luqui> ddarius, ?
20:27:38 <monochrom> because that's what the haskell standard says
20:27:47 <kuffaar> luqui: He's coding something like emacs for Lisp
20:27:48 <mm_freak> joe6: personally, if there is no extensibility concern, i just list all possibilities
20:27:51 <kuffaar> With integrated browsing etc
20:27:56 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002 compulsory reading
20:28:00 <kuffaar> Actually it's more of an OS than emacs is
20:28:01 <tolkad> monochrom: I looked through the report and I couldn't find anything about it. I read that it can be used to qualify things with module names
20:28:02 <ddarius> tolkad: let a.b = 0 in ... (re)defines (.)
20:28:07 <tolkad> oh!
20:28:10 <ddarius> Lambdabot has a and b bound.
20:28:24 <ddarius> luqui: Just rewrite all you usual applications.
20:28:28 <ddarius> @hackage manatee
20:28:28 <lambdabot> http://hackage.haskell.org/package/manatee
20:28:57 <luqui> ddarius, ah, yeah, i was doing that a while ago but took too puristic an attitude and got nothing done.
20:28:58 <joe6> mm_freak: why do you say "it will 'try' the last possibility,". I just tested it with (parseTest test "Vendor") and it worked for all the 3 types.
20:29:07 <kuffaar> ddarius wait did he actually write a markup renderer himself in Haskell or is he just using the FF engine?
20:29:08 <ddarius> luqui: Here's the page that describes :def, though it still doesn't completely illustrate the power.
20:29:10 <ddarius> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/ghci-commands.html
20:29:11 <joe6> ok, I get you.
20:29:21 <ddarius> kuffaar: He's using WebKit.
20:29:25 <kuffaar> Right
20:29:30 <tolkad> let aaaa>><>baaa = 5 in aaaa>><>baaa
20:29:31 <monochrom> your "identifier" begins with "a" so it's a varid. varid → (small {small | large | digit | ' })  your "." is not one of them.
20:29:33 <joe6> it should not try the last.
20:29:34 <tolkad> > let aaaa>><>baaa = 5 in aaaa>><>baaa
20:29:35 <lambdabot>   Not in scope: `aaaa'Not in scope: `baaa'
20:29:43 <joe6> i will see if I can get rid of the type of the last
20:29:59 <mm_freak> joe6: it's not wrong, just unfortunate
20:30:21 <mm_freak> joe6: this is what you would do usually in a parser:  try p1 <|> try p2 <|> try p3 <|> p4
20:30:22 <luqui> ddarius, ooh that's cool (:def)
20:30:32 <mm_freak> joe6: yours does:  try p1 <|> try p2 <|> try p3 <|> try p4
20:30:38 <luqui> you could construct yourself a shell with that kind of power
20:30:40 <joe6> mm_freak: yes, i noticed.
20:31:01 <ddarius> luqui: -Everything- that's in scope before the :def command is in scope for it.  So you can do stuff like: ipcChannel <- openIPC ...; :def sendToFoo \s -> writeIPC s; return ""
20:31:02 <mm_freak> that's not wrong, but in case the fourth parser fails, you waste memory
20:31:04 <joe6> why do you say "unfortunate", just takes too much power than it should?
20:31:17 <joe6> ok, I get it.
20:31:27 <joe6> mm_freak: thanks a lot
20:31:32 <mm_freak> you're welcome
20:32:13 <luqui> ddarius, nice.  although for that i would probably just write  sendToFoo = writeIPC ipcChannel
20:32:23 <luqui> *let
20:32:38 <monochrom> this is a good moment to recall the #5 definition of "intelligence" on http://www.merriam-webster.com/dictionary/intelligence : the ability to perform computer functions
20:32:47 <luqui> oh right but that would require quotes
20:34:15 <luqui> joe6, usually you should try to design your parsers to minimize the use of try.  but occassionally that can be a major pain so...
20:34:59 <luqui> parsec w/o try = LL(1) ?
20:35:22 <Philippa> approximately, yeah
20:35:31 <luqui> (modulo infinite chains which make it universal)
20:35:41 <Philippa> (you still get all the lovely context-sensitivity, which /also/ still makes it universal)
20:35:48 <monochrom> only add "try" to operands of <|>, and only when it is necessary
20:36:10 <Philippa> therefore, only to the LHS of a <|>
20:36:27 <monochrom> for example try (string "string") <|> try (string "special") is kind of necessary
20:36:33 <luqui> and only when there is a valid prefix of the lhs that is also valid for the rhs
20:36:56 <monochrom> yeah
20:36:57 <luqui> monochrom, what?
20:37:12 <monochrom> yes it may surprise you that string "string" is not quite atomic
20:37:24 <luqui> that does surprise me
20:37:31 <monochrom> you should try it. (pun!)
20:37:38 * ddarius is actually thinking about changing that.
20:37:42 <luqui> do the Parsec.Token combis abstract over that?
20:37:49 <ddarius> luqui: Yes.
20:38:04 <luqui> ok that's why it surprised me i guess
20:38:04 <ddarius> You can use most of the token parsers without such worries.
20:38:09 <monochrom> yes Parsec.Token adds try around keywords etc.
20:39:30 <ddarius> The main rule for try is not to add it around "large" (usually recursive) branches, and otherwise use it to make something "atomic."  And, for Christ's sake, left-factor your grammar.
20:39:34 <joe6> mm_freak: just noticed, do I need try when using choice?
20:39:46 <mm_freak> joe6: yes
20:41:15 <|nanothief|> I'm having a problem with the code at http://hpaste.org/43061/compile_error_no_instance . I don't understand why the typechecker can't realize that since method takes as an input anything in the class AClass, and makeSomeData returns a SomeData (instance of AClass), b can be resolved to SomeData.
20:41:19 <joe6> :t choice $ (map (try . string. show ) . init $ [Standard ..]) ++ [string . show . last [Standard ..]]
20:41:20 <lambdabot> Not in scope: `choice'
20:41:20 <lambdabot> Not in scope: `try'
20:41:20 <lambdabot> Not in scope: `string'
20:42:27 <mm_freak> joe6: a superfluous 'try' is not that bad in this case…  it will waste memory for keeping the last possible string
20:42:42 <mm_freak> joe6: it's much worse in other cases
20:43:04 <mm_freak> joe6: if you want to auto-evaluate the parser, don't care about it
20:43:05 <joe6> mm_freak: ok ,thanks. will leave it in then. shorter code.
20:43:34 <joe6> or I could abstract it to a function and use that in a few other places..
20:44:28 <mm_freak> joe6: that one could work: foldr1 (\p1 p2 -> try p1 <|> p2)
20:44:36 <ddarius> @hackage tagsoup
20:44:36 <lambdabot> http://hackage.haskell.org/package/tagsoup
20:45:24 <mm_freak> hmm, i'm
20:45:32 <mm_freak> not sure whether that would introduce another problem
20:45:52 <aristid> isn't there some kind of optimised choiceString or such
20:45:54 <aristid> ?
20:46:07 <joe6> mm_freak: that is awesome. good thinking . thanks.
20:47:34 <monochrom> nanothief: do you know what type should joined2 take on eventually?
20:48:19 <nanothief> monochrom: well I would have thought it would be the same as the type of joined
20:48:46 <nanothief> ie String -> String
20:49:23 <mm_freak> aristid: i don't know parsec very well, but in attoparsec there is none
20:49:29 <mm_freak> but it would be easy to write
20:49:41 <mm_freak> just add (. string)
20:49:44 <mm_freak> uhm
20:49:45 <aristid> mm_freak: easy to write in any optimised way?
20:49:47 <mm_freak> just add (. map string)
20:49:51 <monochrom> you can add that type signature. "joined2 :: String -> String". it will give you a better error.
20:49:53 <Bynbo7> anyone know how the bytestring parsers handle just taking a bytestring chunk from the bytestring being parsed? i'm wondering if they make a copy, or if they reference the original btyestring (depending on the situation, i'd like to be able to use one over the other, so the original bytestring isn't always kept around in memory)
20:50:17 <joe6> mm_freak: your idea helped a lot: this is what the code has come down to: foldr1 (\p1 p2 -> try p1 <|> p2) . map (string . show) $ [Standard ..]
20:50:27 <mm_freak> aristid: well, sure, you could turn a string parser into a character parser
20:51:22 <mm_freak> aristid: the PArrows parser library does that by itself using arrows
20:51:34 <mm_freak> in monadic parsers you need to encode this kind of optimization yourself
20:51:53 <Bynbo7> what sort of optimisation are you after?
20:52:21 <aristid> :t (<=<)
20:52:22 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
20:52:33 <mm_freak> Bynbo7: attoparsec has optimized bytestring parsers for taking prefixes
20:52:41 <nanothief> monochrom: It improves it a bit by setting the c in "No instance for (Joiner (String -> SomeData) (a -> String) c) ... to (String -> String). Doesn't help explain my problem though, I don't know why a isn't being resolved as a SomeData
20:52:46 <Bynbo7> mm_freak: what do you mean?
20:53:07 <mm_freak> Bynbo7: about the optimization:  if your parser parses one of "abc", "abd" and "xyz", then PArrows optimizes this to character level
20:53:55 <Bynbo7> i was just wondering if the InterleveT in the latest Monad.Reader issue would be useful here
20:54:05 <mm_freak> if the next character is 'x', then it knows it can turn off the other branches…  if it's 'a', then it turns off the "xyz" branch…  if it's anything else, it fails immediately
20:54:48 <Bynbo7> sounds good
20:55:25 <mm_freak> yes, but unfortunately PArrows is not really mature and not actively developed it seems
20:55:46 <mm_freak> i suppose monadic parsers are "good enough", since in general you don't need that optimization that much
20:57:02 <joe6> > matchlist = choice . map  (try . string. show)
20:57:03 <lambdabot>   <no location info>: parse error on input `='
20:57:08 <joe6> > choice . map  (try . string. show)
20:57:09 <lambdabot>   Not in scope: `choice'Not in scope: `try'Not in scope: `string'
20:58:34 <monochrom> nanothief: I think there is a bit difference between (makeSomeData `join` method) and (makeSomeData `join` (method :: SomeData -> String))
20:58:48 <monochrom> s/bit/big/ 
20:59:33 <kuffaar> Is GeneralizedNewtypeDeriving a common pragma to use?
20:59:58 <mm_freak> it's a fairly common extension (the pragma is LANGUAGE)
20:59:59 <monochrom> you can add NoMonomorphismRestriction to see what the type inference really gets. it is joined2 :: (AClass a, Joiner (String -> SomeData) (a -> String) c) => c
21:00:06 <kuffaar> Oh, right
21:00:10 <pastorn> kuffaar: when you declare monads it is
21:00:36 <pastorn> kuffaar: but you shouldn't use it for when doing a library with a monad
21:01:00 <kuffaar> So people use this to avoid writing standard boilerplate code for the Monad methods?
21:01:03 <kuffaar> i.e. bind and return?
21:01:07 <monochrom> The (a -> String) part, with AClass a, comes from method. Nothing says that method should be any more specialized than that.
21:01:08 <pastorn> yes
21:01:21 <pastorn> kuffaar: but as i said, don't put stuff on hackage that uses it
21:01:21 <kuffaar> pastorn: That is precisely what I am doing (library)
21:01:31 <kuffaar> What is the problem with it?
21:01:35 <pastorn> then you should declare all the stuff from scratch
21:01:38 <kuffaar> However it's just a dependency for my own projects
21:01:39 <monochrom> Without specialization, nothing would suspect that your "instance Joiner (a -> b) (b -> c) (a -> c)" should be involved at all.
21:01:41 <pastorn> kuffaar: ok, let's say we have this
21:01:48 <pedro3005> if I have "file.hs" in the same directory as "bla.hs", can I do "import file" in bla.hs? if not, how do I achieve that?
21:01:49 <ddarius> Freakin' lambdabot.
21:01:52 <mm_freak> i wish deriving would work for RankNTypes
21:02:03 <pastorn> newtype Env e a = Env { unEnv :: Reader e a }
21:02:11 <monochrom> whereas with (method . makeSomeData) the (.) does the specialization.
21:02:34 <pastorn> then the user wants to do a RederT userEnv (Env someOtherEnv) a
21:02:41 <pastorn> kuffaar: you with me?
21:02:53 <mm_freak> newtype SimpleStateT s m a = SimpleStateT (forall r. StateT r s m a)  deriving (Applicative, Functor, Monad)
21:03:17 <pastorn> then when you use 'ask' haskell won't know which of the monads you're calling ask for
21:03:37 <kuffaar> So you specify a module path?
21:03:42 <kuffaar> To eradicate ambiguity?
21:03:47 <nanothief> monochrom: I see, the type checker uses the class definition since more instances of Joiner could be written. That isn't specialized enough, resulting in the compile error (without the manual method :: SomeData -> String annotation)
21:03:57 <kuffaar> And when you specify the absolute one for the one which used the LANGUAGE pragma it will fail
21:04:00 <kuffaar> Because it doesn't exist?
21:04:08 <pastorn> kuffaar: i think you need implement whatever monad you're using from scratch
21:04:25 <dmwit> pedro3005: If you have File.hs, which has "module File where" at the top, then yes.
21:04:49 <dmwit> pedro3005: (Actually, it will look in pwd for File.hs, not in the same directory as bla.hs. Luckily these are usually the same thing.)
21:05:13 <pastorn> kuffaar: maybe if you don't derive MonadReader and use (lift ask) internally, but don't export anything relating to Reader, then maybe you can hav ReaderT Env and it would work
21:05:20 <pastorn> kuffaar: but you understand the problem?
21:05:49 <kuffaar> pastorn: Not fully, I've never written a monad befoer
21:06:02 <nanothief> monochrom: thanks for the help, makes sense now :)
21:06:09 <monochrom> glad I made sense
21:06:18 <kuffaar> But I want to implement this lock around putStr/putStrLn now and I probably want a monad for that
21:06:33 <kuffaar> But it's 0609 in CET so I'll try to do that tomorrow I guess
21:06:45 <kuffaar> So I make a new monad with some boiler plate code
21:06:47 <pastorn> kuffaar: bah, just do that with a global QSem
21:06:54 <kuffaar> :O
21:07:14 <kuffaar> pastorn: Is that what others in here previously referred to as a "global state hack"?
21:07:14 <pastorn> kuffaar: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-QSem.html
21:07:22 <pastorn> maybe
21:07:32 <pastorn> but since you're not exporting it it's fine (i think)
21:07:37 <Jonno_FTW> pastorn: what was that paper on monads you said I should read?
21:07:37 <pastorn> so you do
21:07:48 <pastorn> Jonno_FTW: Monadic Parsing?
21:07:51 <kuffaar> pastorn: But I do export it
21:08:02 <pastorn> kuffaar: well, not the semaphore
21:08:08 <Jonno_FTW> no
21:08:10 <pastorn> kuffaar: like this
21:08:20 <mm_freak> kuffaar: for simple applications, don't bother and just pass around a logging function
21:08:33 <kuffaar> mm_freak: That sounds filthy
21:08:37 <mm_freak> kuffaar: also for /applications/ (i.e. not libraries) it's fine to use 'type'
21:08:49 <mm_freak> newtype is better for libraries
21:08:49 <pastorn> ioLock :: QSem; ioLock = unsafePerformIO (newQSem 1); {-# NOINLINE ioLock #-}
21:08:52 <kuffaar> mm_freak: What if I need to add another such function? And another one? ETc
21:09:11 <Bynbo7> kuffaar: do it the fun way, fork off a logging thread :)
21:09:17 <kuffaar> mm_freak ultimately I do want a stack of monads for that, no?
21:09:20 <mm_freak> kuffaar: data MyAppConfig = MyAppConfig { loggerFunc :: …, thisFunc :: …, thatFunc :: … }
21:09:22 <Bynbo7> with a Chan to communicate with it
21:09:37 <kuffaar> Bynbo7: People already advised me not to use a Chan for this
21:09:51 <mm_freak> kuffaar: type MyAppIO = ReaderT MyAppConfig
21:09:52 <joe6> in parsec, similar to getting the position, is there a function to get the current line being matched?
21:10:00 <mm_freak> kuffaar: or MyAppT, if you're me
21:10:22 <mm_freak> kuffaar: for application configuration alone there is no need to have more than one transformer in the stack
21:10:23 <kuffaar> They said Chan IO is async and will break ultimately if the console IO is too slow and it keeps on stacking up whereas with an MVar it would just block
21:11:16 <mm_freak> joe6: parsec is not line-aware, but it supports custom state, so you can count lines yourself
21:11:25 <monochrom> alright, then MVar, as hard to use as Chan anyway
21:11:44 <mm_freak> joe6: but that's the point, where you may want to consider trying iteratee-based IO
21:11:45 <jmcarthur> luqui: you got the same idea i did when i saw the announcement for extcore 1.0 ;)
21:12:09 <kuffaar> pastorn: Hah, unsafePerformIO
21:12:22 <kuffaar> I'm at the hello world stage, and already using dirty stuff like that? :p
21:12:49 <pastorn> kuffaar: that's how you do globals (without reading up on a whole PHD thesis)
21:12:52 <mm_freak> kuffaar: if you want a buffered logger, there is a Chan with a limited queue length…  i don't know its name, but you find it on hackage
21:12:53 <monochrom> "diving in" gets dirty pretty quickly
21:12:57 <mm_freak> personally i would just use MVar
21:13:35 <ddarius> An MVar is a Chan with limited length essentially.
21:13:40 <joe6> mm_freak: what is iteratee-based IO?
21:13:56 <joe6> is there a different parsing library that you would recommend?
21:13:59 <Bynbo7> kuffaar: what reason did they have for not using a Chan for this?
21:14:06 <kuffaar> <kuffaar> They said Chan IO is async and will break ultimately if the console IO is too slow and it keeps on stacking up whereas with an MVar it would just block
21:14:08 <mm_freak> joe6: http://docs.yesodweb.com/book/enumerator/
21:14:26 <joe6> mm_freak: thanks, will check it out
21:14:26 <ddarius> Bynbo7: Chans are asynchronous, so production could outrun consumption leading to a memory leak.
21:14:47 <Bynbo7> kuffaar: sure, but using an MVar also means that you ow have a single bottleneck
21:15:01 <Bynbo7> the printing thread should easily be fast enough to do what you want
21:15:03 <kuffaar> That's intended, yeah
21:15:06 <monochrom> it is not bottleneck. it is flow control.
21:15:09 <mm_freak> joe6: i use attoparsec for most of my stuff…  it has less functionality, but is very fast, comparable to a C parser
21:15:14 <cdsmithus> Seriously, if printing to the console is your performance bottleneck, you have issues
21:15:22 <monochrom> like how we used to use CTS RTS
21:15:24 <Bynbo7> cdsmithus: my thoughts exactly
21:15:51 <mm_freak> joe6: combined with iteratees you can get really fast, elegant parsers for network protocols and such
21:16:08 <pastorn> kuffaar: a Chan is actually just a sequence of MVars
21:16:27 <pastorn> kuffaar: look on haddock and click 'Source' :)
21:16:47 <joe6> mm_freak: the iteratee stuff is above my capability at the moment.
21:16:52 <mm_freak> what makes you people sure that kuffaar is logging to a terminal?
21:16:55 <joe6> mm_freak: will check out attoparsec
21:17:03 <mm_freak> logging usually goes to a file or a network socket
21:17:07 <monochrom> "console"
21:17:15 <Bynbo7> yeah, Chans will probably give you just as much control flow as just a single MVar, but also allows for there to be a little slowness in printing
21:17:48 <mm_freak> if one thread generates a lot of log output and the logger can't keep up, then you might end up with a system crash
21:17:51 <kuffaar> I have no idea why they started using "logging" at all
21:17:55 <ddarius> Bynbo7: Ultimately it's a tradeoff between memory, not losing events, and concurrency.  You can choose two.
21:17:56 <kuffaar> I am performing console IO and that's it
21:18:00 <mm_freak> we all know what happens, when you do:  reverse [1..]
21:18:08 <kuffaar> That's unrelated to logging in my terminology :p
21:18:21 <cdsmithus> Bynbo7: It probably doesn't matter.  But on the off chance that it *does* temporarily get backed up, I think blocking threads and letting the writer catch up is better than using more memory.
21:18:34 <ddarius> From what I can tell of kuffaar's use-case.  It really doesn't matter which of the two solution he chooses.
21:18:34 <kuffaar> cdsmithus agreed
21:18:41 <joe6> mm_freak : "Attoparsec is specialised to deal only with strict ByteString  input." -- i am reading text files.
21:18:43 <mm_freak> i suggest MVar from a pratical viewpoint…  it guarantees that the logger is able to keep up
21:18:44 <kuffaar> Three* solutions
21:18:47 <Bynbo7> how much data is going to be logged?
21:18:49 <kuffaar> Or four
21:19:13 <mm_freak> joe6: sure…  you now read files into ByteString instead of String
21:19:17 <kuffaar> There is no logging >:O
21:19:26 <monochrom> hahaha
21:19:43 <kuffaar> But usually less than 1 MiB of output per minute if that's what you want to know
21:19:49 <Bynbo7> or whatever, how much data are you producing
21:19:51 <monochrom> you see the real question is "what makes you so sure that kuffaar is logging at all?" :)
21:19:54 <kuffaar> Just whatever I usually print for debug questions
21:20:37 <kuffaar> So far the suggestions have been: partially applied log function which is passed around, monadically wrapped Chan, monadically wrapped MVar, QSem global state hack
21:20:46 <mm_freak> also the scenario where two threads writing to the logger will be a bottleneck is very unlikely…  you would need at least one thread, which writes to the log a lot very fast…  then another thread might need to wait 10 ms, before it can continue
21:20:52 <kuffaar> I liked the QSem global state hack by pastorn best, I think
21:20:58 <kuffaar> It strikes me as utterly pragmatic
21:21:01 <kuffaar> :D
21:21:02 <mm_freak> in the bottom line, Chan will be slower anyway
21:21:08 <joe6> mm_freak: it seems to be a lot more straightforward.
21:21:16 <kuffaar> <pastorn> ioLock :: QSem; ioLock = unsafePerformIO (newQSem 1); {-# NOINLINE ioLock #-}
21:21:22 <kuffaar> Although I have no idea how to use it really
21:21:43 <mm_freak> kuffaar: it's about the worst solution you could choose from…  you might just as well go back to C++ ;)
21:21:52 <Bynbo7> yeah
21:21:55 <mm_freak> -from
21:22:00 <Bynbo7> we don't want your kind here
21:22:02 <Bynbo7> >_>
21:22:14 <mm_freak> kuffaar: in the first year of your haskell experience, don't use ANY function starting with 'unsafe'
21:22:26 <mm_freak> you WILL end up writing C++ code in haskell
21:22:30 <pastorn> kuffaar: each time you want to use the IO stuff you use takeQSem, when you're done you use signalQSem
21:22:44 <pastorn> sorry, 'waitQSem', not takeQSem
21:22:53 <ddarius> pastorn: Why not use an MVar () ?
21:22:58 <kuffaar> pastorn: Yeah but I can't just pass ioLock to those, that would generate a new semaphore every single time, no?
21:23:08 <Bynbo7> ddarius: extra complexity imo
21:23:08 <kuffaar> So tehre would be no actual locking
21:23:21 <Bynbo7> if you're going to use and MVar, just put the messages in the MVar
21:23:22 <pastorn> kuffaar: and they're right, this isn't very nice, but if you want your IO functions to still only be IO and not some other weird type, then this is the simple approach
21:23:42 <ddarius> Bynbo7: I agree.  You can apply the unsafePerformIO hack to all the other solutions.
21:23:43 <kuffaar> pastorn: Well I will use a monadic approach with MVar
21:23:51 <kuffaar> To learn how to write my own monads anyways
21:23:53 <ddarius> Bynbo7: My question was for pastorn though.
21:23:56 <pastorn> kuffaar: NOINLINE guarantees that the lock will only be created once
21:24:00 <kuffaar> hah!
21:24:03 <kuffaar> Nice hack
21:24:06 * kuffaar approves
21:24:09 <pastorn> ddarius: because it's a lock! not a var
21:24:10 <ddarius> pastorn: It certainly doesn't "guarantee" it.
21:24:18 <ddarius> pastorn: That's what MVar () is.
21:24:35 <pastorn> kuffaar: ok, ddarius is right, it's not a guarantee, but you can be pretty sure about it
21:24:38 <Bynbo7> pretty sure that QSems are implemented using MVaras
21:24:40 <Bynbo7> -a
21:24:40 <mm_freak> btw, you can and should pass multiple messages in a single MVar message
21:24:54 <pastorn> ddarius: it's a lock! he should use semaphores :)
21:24:55 <mm_freak> MVar [String], not MVar String
21:25:07 <mm_freak> that enables logging transactions, if you want multiple message to be logged together
21:25:12 <kuffaar> pastorn: For Dijkstra's sake?
21:25:18 <joe6> mm_freak: do you know of any good tutorials on attoparsec?
21:25:29 <kuffaar> mm_freak nah I don't want that really
21:25:30 <pastorn> joe6: why u hatin on 'binary'?
21:25:33 <kuffaar> mm_freak: I can just use \n for that
21:25:39 <mm_freak> and it also improves performance, if one thread has to write a lot of stuff to the log
21:25:48 <kuffaar> IT'S NOT A LOG :(
21:26:11 <cdsmithus> What is writing to the console, except a very simple log?
21:26:17 <mm_freak> kuffaar: it is =)
21:26:25 <monochrom> a very simple message
21:26:33 <kuffaar> Why do people keep on referring to cosole IO as logging? Is this because they all read the same Haskell tutorial where this was the first similar use case? :P
21:26:35 <monochrom> it is messaging not logging
21:26:35 <mm_freak> joe6: nope, but if you can write parsec parsers, you can also write attoparsec parsers
21:26:46 <ddarius> pastorn: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/Control-Concurrent-QSem.html
21:26:48 <mm_freak> joe6: the main difference between the two is how to actually parse stuff
21:26:59 <kuffaar> Night
21:27:15 <mm_freak> joe6: attoparsec supports chunked input, so the parsing function is slightly more complicated
21:27:25 <pastorn> ddarius: heh yeah, i figured as much
21:27:28 <Bynbo7> kuffaar: what do you actually want to do then?
21:27:34 <mm_freak> kuffaar: you were the one to call it logging =P
21:28:16 <Bynbo7> kuffaar: do you want to be able to read data too? if so, the Chan idea is by far the most useful imo
21:28:28 <monochrom> the tutorials don't use Writer to log. they use Writer to create a pure string and then throw it away.
21:28:45 <mm_freak> i never used Writer to log
21:29:10 <mm_freak> i tried once, but ran into laziness problems with that
21:29:23 <Bynbo7> make: data Console = Write String | Read (MVar String), and have a Chan Console communicating with another thread. guarantees ordering of the IO
21:30:23 <ddarius> Hmm.  Flattr throws 400 responses to lambdabot's requests.
21:30:32 <mm_freak> Bynbo7: why Chan and not MVar?
21:31:09 <mm_freak> you can guarantee ordering very easy with a single thread and an MVar
21:31:11 * ddarius will make a SynchronousChan module which will just be a wrapper around an MVar.
21:31:30 * monochrom wraps around SynchronousChan :)
21:32:01 <ddarius> mm_freak: Whether you want a Chan or MVar depends on your use-cases.  I think Bynbo7 was gearing more toward the conceptual idea.
21:32:49 <mm_freak> i don't know…  Chan appears to be an unnatural choice, because its storage requirements are very unpredictable
21:33:47 <ddarius> The storage requirements for most things done in Haskell are rather unpredictable.  It's a question of what is important to you and some understanding of the processes.
21:33:55 <mm_freak> there should be a bounded Chan in the base library
21:34:02 <ddarius> Probably.
21:34:36 <ddarius> There should probably also be a non-blocking, bounded channel that discards elements when full.
21:34:40 <joe6> pastorn: i have not gotten to the point of binary yet. I am still reading the text file.
21:34:53 <joe6> pastorn: sorry, did not see your message earlier.
21:34:54 <mm_freak> the thing is, mostly when IO is involved, you can't predict the performance of the reader side of the Chan
21:35:05 <ddarius> (And then you get into discarding policies, discard most recent or least recent or...)
21:35:14 <mm_freak> then, if the writer side doesn't have a second channel to that reader, you will run into problems
21:35:15 <pastorn> joe6: Data.Binary.Get does essentially the same stuff as attoparsec
21:35:34 <pastorn> it's just that with binary you get the Binary typeclass, with the get/put functions
21:35:40 <mm_freak> since it happened many times to me, i stopped using Chan and switched to MVar
21:35:43 <pastorn> which is very nice
21:36:08 <pastorn> joe6: decode . encode == id
21:36:09 <mm_freak> as a side note, Chan also was slower than MVar in all my benchmarks, even with many threads
21:36:21 <pastorn> mm_freak: tried TChan?
21:36:26 <ddarius> mm_freak: Of course it will be.  It's a linked list of MVars.  It can't be faster.
21:36:35 <ddarius> It can reduce contention though.
21:37:00 <mm_freak> pastorn: nope, but with STM there will be much fewer cases where you need a communication "channel" between threads
21:37:13 <pastorn> mm_freak: true
21:37:26 <pastorn> mm_freak: i usually use it for inputs
21:37:57 <pastorn> so i create a TChan where i put both stuff from stdin and from a network socket or whatever
21:38:01 <mm_freak> joe6: you can view ByteString as a faster, stricter String
21:38:12 <Bynbo7> mm_freak: 'why Chan and not MVar?' allows slightly better concurrency
21:38:14 <mm_freak> joe6: it doesn't mean you can't read text files anymore ;)
21:38:51 <ddarius> One should probably use Text if they want performance for text files rather than ByteString.
21:39:09 <mm_freak> ddarius: unfortunately attoparsec only supports ByteString
21:39:23 <pastorn> can you use Parsec with Text?
21:39:42 <Bynbo7> mm_freak: i think someone's working on attoparsec-text
21:39:44 <ddarius> pastorn: Yes, for Parsec 3.
21:39:49 <pastorn> cool :D
21:41:09 <joe6> mm_freak: oh, ok. i am used to thinking of binary as a binary string of bytes and in the past it was a pain to convert it to other formats for display, hence, wast sticking with text.
21:41:36 <joe6> mm_freak: i will stick with parsec for now. I cannot seem to find any good tutorials on attoparsec.
21:41:46 * ddarius finds it ridiculous that he's sweating his balls off in his apartment in winter in Massachusetts with the heat off and the windows open.
21:42:00 <pastorn> joe6: binary!
21:42:05 <pastorn> it's what you want! i promise
21:42:29 <monochrom> heat off, windows open, and still hot? you have cold fusion there?
21:43:06 <Bynbo7> joe6: binary is dead simple, really :)
21:43:09 <Bynbo7> it's fun too!
21:43:36 <ddarius> monochrom: Unfortunately, I can't actually turn the heat off because it's a hot-water piping system, so even if I turn it off for my apartment, the hot water still flows through the pipes to other apartments.
21:43:51 <joe6> pastorn: can you please take a look at this: http://codepad.org/hCGRprkK
21:43:51 <magicrat> ?
21:44:00 <BMeph> !
21:44:03 <Bynbo7> ¡
21:44:06 <Bynbo7> ¿
21:44:24 <Bynbo7> BMeph: how did you write that upside down i :O
21:44:50 <joe6> pastorn: i have not tested the code yet. I am still working on it.
21:44:59 <joe6> pastorn: just wanted to show you where I am headed.
21:45:05 <pastorn> joe6: dude, your haskell is starting to look awesome :)
21:45:08 * BMeph shakes his head at what passes for "Aussie humour"...
21:46:30 <joe6> pastorn: this is the data file: http://codepad.org/a24fZxzp
21:46:41 <joe6> pastorn: thanks to you. it is really beautiful.
21:47:07 <pastorn> but that's your custom thingy you wrote for testing, right?
21:47:16 <pastorn> (which that parser is for)
21:47:27 <joe6> yes
21:47:27 <Bynbo7> joe6: what's the {msgs} for? the {}'s confuse me
21:48:05 <joe6> Bynbo7: what are you talking about? which line, please?
21:48:05 <ddarius> pastorn: I'd recommend using camel case or underscores or something to separate words in identifiers.  I'd also recommend running hlint over your code.
21:48:21 <pastorn> ddarius: my code? it's joes code
21:48:22 <Bynbo7> 76
21:48:35 <pastorn> i just helped him to get his haskell-fu on
21:49:12 <pastorn> joe6: Bynbo7 is right, it should say Write { outs = msgs }
21:49:30 <Bynbo7> also, this makes no sense:
21:49:30 <Bynbo7>       _        <- status (if transactiontype == "Read"
21:49:31 <Bynbo7>                           then Out else In)
21:49:38 <ddarius> pastorn: I meant that for joe6 
21:49:47 <joe6> Bynbo7: yes, thanks. please noted that I have not tested this code. I just wanted to show it to pastorn for guidance on the direction I am headed.
21:49:57 <Bynbo7> righto
21:50:05 <mm_freak> joe6: there is nothing wrong with parsec, unless you have real high speed requirements
21:50:22 <joe6> Bynbo7: that is to make sure that there is the status transaction.
21:50:48 <ddarius> Parsec was never intended for high-speed, simple data.
21:50:50 <Bynbo7> joe6: then remove the _ <-, it's not needed
21:50:58 <joe6> bynbo7: there is nothing for us to store from the status data, it is to ensure that there is a status line in the data fiel.
21:51:19 <mm_freak> i noticed parsec to be the main bottleneck, when parsing very large files (mega-/gigabytes) or when doing network I/O, so i went to attoparsec…  it doesn't mean that parsec is bad, it just wasn't appropriate for my purposes
21:51:24 <pastorn> Bynbo7: yes it is, with -Wall it is :)
21:51:33 <mm_freak> and now i'm so used to ByteString and attoparsec, i use them for everything =)
21:51:40 <Bynbo7> that's a stupid warning, and i hate it
21:51:42 <mm_freak> less memory, faster, no real disadvantages
21:51:44 <joe6> Bynbo7: would that not fire off the warnings with -Wall?
21:52:08 <Bynbo7> yes, but -Wall should stfu about that
21:52:42 <mm_freak> and attoparsec plays very well with iteratees, which parsec doesn't, on the low level
21:53:02 <mm_freak> attoparsec parsers are iteratees, effectively
21:53:18 <joe6> pastorn: do you still think I should go back to binary here? What do you feel about attoparsec in my situation?
21:53:34 <pastorn> Bynbo7: i usually turn on the flag that fixes that
21:53:38 <joe6> atleast to this portion of code while reading the text file into a data structure
21:53:46 <pastorn> joe6: no, this looks like code for parsec
21:53:52 <joe6> pastorn: thanks.
21:53:59 <Bynbo7> looks like good code for attoparsec to me :\
21:54:11 <pastorn> joe6: but seriously, couldn't you write this stuff in haskell?
21:54:17 <pastorn> then you wouldn't need a parser :)
21:54:25 <pastorn> and you could then run functions on it etc.
21:54:28 <Bynbo7> feels like this should be fast code, and you won't get as fast code with parsec as you would with attoparsec
21:54:37 <joe6> ddarius: i am still working on the code. I will get to the hlint and identifiers in an hour. Thanks.
21:55:12 <joe6> pastorn: I was thinking about it. and i think kmc recommended dyre
21:55:16 <pastorn> i'm not user about this, but i think that (try f <|> try g <|> h) is equivalent to (f <|> g <|> h)
21:55:21 <pastorn> not sure, though
21:55:36 <mm_freak> joe6: btw, as a hint:  you can write a parser with the following type:  (Enum a, Show a) => Parser a
21:55:46 * hackagebot maccatcher 2.0.0 - Obtain the host MAC address on *NIX and Windows.  http://hackage.haskell.org/package/maccatcher-2.0.0 (JasonDusek)
21:56:00 <Bynbo7> pastorn: i think it's only equivalent if f and go don't consume any input
21:56:04 <ddarius> pastorn: It isn't.
21:56:14 <joe6> mm_freak: so I can print the output from the parser function while testing?
21:56:20 <ddarius> That said, try should not be sprinkled about willy-nilly
21:56:25 <mm_freak> joe6: nope…  look at the type
21:56:31 <pastorn> oh, so they consume, fail and then lets the right one take up the work?
21:56:59 <joe6> mm_freak: I do not understand, can you please help?
21:57:33 <joe6> i do not understand where I should be putting (Enum a, Show a).
21:58:11 <mm_freak> joe6: with that parser you can parse any simple Enum type, with "simple" meaning that all constructors have no arguments
21:58:25 <mm_freak> parseEnum :: (Enum a, Show a) => Parser a
21:59:17 <joe6> mm_freak: sorry for being thick. I do not understand what you are trying to say.
21:59:41 <mm_freak> uhm…  you'll probably need a Bounded constraint, too
21:59:59 <mm_freak> parseEnum = foldr1 (\p1 p2 -> try p1 <|> p2) . map (string . show) $ [minBound ..]
22:00:14 <joe6> oh, ok.
22:00:33 <mm_freak> or you can supply a range
22:00:47 <joe6> that is the reason I could not put show into the function.
22:00:58 <joe6> mm_freak: that is a good idea. will try it.
22:01:04 <mm_freak> parseKeyword :: Show a => [a] -> Parser a
22:01:18 <mm_freak> parseKeyword = foldr1 (\p1 p2 -> try p1 <|> p2) . map (string . show)
22:01:49 <mm_freak> (or perhaps just 'keyword')
22:02:17 <luqui> this is so silly
22:02:35 <luqui> you are saving so little time with this transformation.  it's not like p2 is a big complex parser.
22:02:44 <luqui> er i mean, the last keyword
22:03:09 <pastorn> joe6: why are you doing  >> return ()
22:03:13 <pastorn> on line 50?
22:03:19 <mm_freak> luqui: so?  it's an optimization you can easily do
22:03:21 <pastorn> it seems unnesecary
22:03:44 <joe6> I do not need any input from it. I just want to ensure that there is a separater
22:03:48 <joe6> s/er/or/
22:03:56 <pastorn> you already do
22:04:01 <pastorn> return () is a nop
22:04:02 <mm_freak> pastorn: because otherwise you get a type error
22:04:11 <pastorn> oh, ok, that explains it :)
22:04:14 <luqui> i guess it's a matter of taste.  i would prefer the 1% of added clarity over the 0.5% of added speed.
22:04:22 <luqui> %-)
22:04:46 <mm_freak> luqui: i don't think that the code is that difficult to understand ;)
22:05:03 <luqui> it's 1% harder to understand than choice . map (try . string . show)
22:05:03 <Bynbo7> looks pretty clear to me :\
22:05:07 <mm_freak> if you want clarity, don't make use of the Show instance
22:05:30 <luqui> oh wait... yeah... i was thinking it was a list of strings
22:05:42 <luqui> yeah that's weird
22:06:48 <luqui> shouldn't there be a read in there somewhere?
22:08:06 <joe6> luqui: read is in the return
22:12:12 <joe6> mm_freak:  i had to change the type signature to => parseKeyword :: Show a => [a] -> GenParser Char st String 
22:12:22 <joe6> as i was getting some error while compiling it.
22:12:32 <joe6> and it seemed to work from ghci
22:13:19 <joe6> mm_freak: this is the usage: requesttype <- parseKeyword $ [Standard ..]
22:14:29 <joe6> is there any way: I can tell it : requesttype <- parseKeyword $ [minBound ..]?
22:14:49 <joe6> or just let the function get the minBound automatically if I specify the datatype?
22:15:01 <joe6> such as: requesttype <- parseKeyword RequestType
22:17:00 <ddarius> @tell edwardk http://home.imf.au.dk/kock/CYRSC.pdf  Nice and old, before terminology settled down.  The "generalized limits" are Kan extensions.  I'll need to expand things to see what comes of it.
22:17:00 <lambdabot> Consider it noted.
22:21:03 <joe6> mm_freak: are you still there?
22:22:58 <luqui> joe6, yeah, just like that.  you need a Bounded constraint.
22:23:29 <luqui> not parseKeyword RequestType, just plain parseKeyword.  type inference will figure out the type for you.
22:23:38 <luqui> er, actually nvm
22:23:47 <luqui> you need the read to do that.
22:24:30 <luqui> parseEnum :: (Bounded a, Enum a) => GenParser Char st a;  parseEnum = read <$> parseKeyword [minBound..]
22:25:09 <luqui> otherwise a would not occur in the type signature, and type inference would have no way of knowing which type you mean
22:25:39 <luqui> (unless you took a type witness, which is ugly.  eg.  parseKeyword (undefined :: RequestType))
22:25:39 <joe6> luqui: but using read seems to lock out the ability to use it on any Enum.
22:25:46 <joe6> luqui: let me try your suggestion
22:25:51 <luqui> oh right you need a Read constraint as well
22:25:53 <mm_freak> joe6: if you want to use minBound, your type needs to be bounded
22:26:08 <mm_freak> data X = A | B | C  deriving (Bounded, Enum)
22:27:02 <pastorn> joe6: enum gives you [A .. C], but with Bounded as well you can do [minBound .. maxBound] :: [X]
22:27:05 <joe6> i can add that in and then I can use minBound. Better yet, Can i not even write minBound but just give the data type and make the system figure out that it has to work with the minBound.
22:27:47 <joe6> luqui: let me try the parseKeyword. that looks pretty cool.
22:31:03 <mm_freak> joe6: but in that case you will also need Show
22:31:12 <mm_freak> map show [minBound ..]
22:31:53 <mm_freak> that's the straightforward solution, but i recommend just mentioning the first value
22:32:05 <mm_freak> or, better and more extensible, write a little class
22:32:09 <luqui> oh man, yeah, so my parseEnum :: (Read a, Show a, Bounded a, Enum a) => Parser a
22:32:20 <mm_freak> class EnumKeywords a where enumKeywords :: a -> [String]
22:32:35 <mm_freak> then you can do:  parseKeyword $ enumKeywords (undefined :: MyType)
22:32:55 <mm_freak> no need for Read
22:32:59 <luqui> i can't imagine how you would want to get a list of keywords from a data type and not want to get back to the datatype from a keyword
22:33:14 <mm_freak> luqui: the parser does that
22:33:26 <mm_freak> that's what you're writing the parser for in the first place
22:33:59 <mm_freak> otherwise you could just as well just derive Read and Show and be finished
22:34:25 <luqui> i guess i don't see how it's all fitting together.  how is this string going to be used once he gets it?
22:34:39 <mm_freak> it's a keyword parser
22:34:51 <mm_freak> data BinOp = And | Or
22:34:59 <mm_freak> parseBinOp :: Parser BinOp
22:35:04 <mm_freak> "And" → And
22:35:08 <mm_freak> "Or" → Or
22:35:17 <joe6> mm_freak: sorry, I was trying the code in another window.
22:35:37 <mm_freak> and my suggestion was to generalize this into a general keyword parser
22:35:38 <luqui> so it looks like we need to get back from the keyword to the data type after all (?)
22:35:59 <luqui> otherwise what is parseBinOp doing, and how does it know "And" maps to And?
22:36:21 <luqui> if it is trying to be general about it, i mean
22:36:32 <mm_freak> it doesn't…  he asked for a combinator to try a set of strings
22:36:45 <mm_freak> after that you can use 'case', for example
22:36:54 <luqui> which is basically emulating a read
22:37:01 <mm_freak> right
22:37:03 <luqui> i'm trying to see the bigger picutre here
22:37:22 <luqui> and it can be very clean if you use "read" and "show" in the same function to round-trip
22:37:27 <mm_freak> that is the big picture i guess, because i don't know his application
22:39:01 <luqui> basically i'm saying for a parser, whose job is to translate syntax to semantics, it's weird to see a function which only translates from semantics to syntax... you're going to have to turn it around
22:39:03 <luqui> anyway...
22:40:23 <joe6> luqui: do you mean that I just read the next word and do read on it?
22:40:30 <pastorn> are there any good libraries for parsing configs?
22:40:34 <luqui> what I'm _really_ saying is that i liked my parseEnum function and i'm offended that it's not being used :-P
22:40:47 <pastorn> all i want is a bunch of var = val with some defaults
22:40:56 <joe6> luqui: i like it too and I am trying to get it work
22:41:10 <joe6> i am just running into ghci errors when I am trying it.
22:42:07 <joe6> http://codepad.org/hVahs7Nj
22:42:48 <pastorn> joe6: the error might be useful here :)
22:42:51 <luqui> joe6, <$ is tighter than $, i believe
22:43:12 <ddarius> luqui: It can't be less tight.
22:43:13 <luqui> joe6, and also you need <$>, not <$
22:43:26 <pastorn> joe6: use :i (<$) and :i ($) and look at the number where it says infix(l|r)
22:43:57 <luqui> pastorn, do you have something specific you want your config to look like, or can it look like anything?
22:44:21 <pastorn> luqui: well, anything that isn't haskell :)
22:44:35 <pastorn> and if any config parsing fails it should set the default
22:44:41 <pastorn> (if applicable)
22:45:00 <luqui> pastorn, i'd just write it by hand.  only a couple lines.
22:45:03 <joe6> http://codepad.org/VDqdVfB4
22:45:07 <joe6> with the error message
22:46:01 <joe6> sorry forget it, I screwed it up badly
22:46:08 <joe6> give me a sec, I will put the better code
22:46:21 <pastorn> luqui: you might be right...
22:46:51 <luqui> do we seriously not have a library function for splitting on a character?
22:47:10 <pastorn> heh
22:47:20 <pastorn> luqui: $ cabal install split
22:47:21 <joe6> sorry, this is the correct version: http://codepad.org/mOdZ5TLC
22:47:26 <pastorn> it has all the goodies and more
22:47:30 <luqui> ah nice
22:48:11 <pastorn> @src words
22:48:12 <lambdabot> words s = case dropWhile isSpace s of
22:48:12 <lambdabot>     "" -> []
22:48:12 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
22:48:21 <pastorn> bah!
22:48:35 <joe6> luqui: any thoughts?
22:48:38 <joe6> please.
22:48:40 <luqui> bah! what?
22:48:41 <pastorn> oh wait, that was all :)
22:49:00 <pastorn> i thought it broke, since the actual source is two lines longer, but it just made the last line longer
22:49:25 <luqui> joe6, again, $ is looser than <$>, so it is getting parsed as (read <$> parseKeyword) $ [minBound..]
22:49:44 <luqui> and you want read <$> (parseKeyword $ [minBound..])
22:49:52 <luqui> (which can also be written read <$> parseKeyword [minBound..]
22:50:23 <joe6> test2.hs:25:39:
22:50:23 <joe6>     Ambiguous type variable `a' in the constraints:
22:50:24 <joe6>       (Bounded a) arising from a use of `minBound' at test2.hs:25:39-46
22:50:34 <joe6> this is what it says if do that.
22:51:01 <luqui> oh, 
22:51:05 <luqui> oh yeah, that's tricky
22:51:15 <luqui> i'll reply to your paste
22:51:27 <luqui> this requires a subtle thing
22:51:52 <mm_freak> pastorn: every type deriving Read is basically a configuration file parser
22:52:17 <mm_freak> data MyConfig = MyConfig { blah :: String, blubb :: Int }  deriving (Read, Show)
22:52:27 <pastorn> mm_freak: read can't fail graciously :(
22:52:42 <mm_freak> :t reads
22:52:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:52:55 <luqui> also didn't maybeRead or something enter the stdlib recently?
22:53:04 <luqui> joe6, aw man I have to make an account?
22:53:28 <joe6> luqui: for codepad usage? 
22:53:29 <joe6> no
22:53:34 <mm_freak> maybeRead str = case reads str of (x,_):_ -> Just x; _ -> Nothing
22:53:53 <luqui> joe6, to comment apparently I do.  anyway this should work: http://hpaste.org/43062/parseenum
22:54:00 <mm_freak> @ pastorn 
22:54:56 <pastorn> mm_freak: that one still isn't in the prelude, is it?
22:55:13 <mm_freak> pastorn: dunno, just write it
22:55:14 <luqui> joe6, modulo my typing errors.  -#} should be #-}
22:55:29 <pastorn> mm_freak: heh, i have quite a bit to go before i get to that :)
22:56:02 <mm_freak> pastorn: there is also nothing wrong with using 'read' directly
22:56:05 <joe6> luqui: Cannot parse LANGUAGE pragma
22:56:11 <joe6> oh, ok.
22:56:14 <mm_freak> pastorn: exceptions are a good concept, while you're in IO =)
22:56:26 <pastorn> mm_freak: yeah, having the application crash is real good when you want to distriubet stuff
22:56:36 <pastorn> especially crashing with weird haskell error messages
22:56:42 <pastorn> that's gonna be just swell
22:56:56 <luqui> i think he's suggesting you catch the exception
22:57:05 <pastorn> catching?
22:57:08 <pastorn> i don't do that
22:57:17 <luqui> yeah same.  i'd go with maybeRead
22:57:19 <pastorn> i give, i never recieve
22:57:22 <pastorn> that's my motto
22:57:27 <Rotaerk> how manly
22:57:28 <mm_freak> pastorn: in a production executable you'll want to catch exceptions somewhere in 'main'
22:57:29 <pastorn> indeed
22:57:41 <pastorn> mm_freak: heh, true
22:57:41 <mm_freak> pastorn: that's my way of reporting fatal errors to the user
22:58:10 <mm_freak> i don't catch file open errors, when such an error is fatal anyway
22:58:11 <luqui> but he wants it to default when there is a parse error
22:58:17 <joe6> luqui: there are still errors. it is not compiling
22:58:19 <mm_freak> the exception's error message is clear enough about what happened =)
22:58:44 <luqui> joe6, what is the gist of the error message?
22:59:09 <joe6> test2.hs:26:78: Not in scope: type variable `st'
22:59:11 <mm_freak> pastorn: that also simplifies your code a lot, because one point in using a high level language is that you don't have to worry about explicit error handling
22:59:22 <mm_freak> and haskell is about as high as a practical language can get =)
22:59:22 <joe6> i think it is the type signature
22:59:32 <luqui> joe6, oh i was worried about that.  "forall st a."  instead of "forall a. "
23:00:10 <joe6> luqui: that worked, cool.
23:00:16 <luqui> this is kind of a weird corner.  quantifying variables with forall explicitly allows the function body to mention them.
23:00:40 <joe6> what does that mean " forall st a."?
23:01:00 <pastorn> joe6: that there are no restrictions on 'a'
23:01:11 <pastorn> but it can still have typeclass restrictions (yes, this is weird)
23:01:13 <joe6> what is "st"?
23:01:23 <pastorn> it's like IO, but with more magic
23:01:29 <luqui> GenParser Char st String
23:01:33 <Philippa> there, st is just another type variable
23:01:36 <pastorn> you have O(1) array writing in ST
23:01:36 <luqui> pastorn, not in this case
23:01:43 <luqui> we are not talking about ST monad
23:01:50 <dolio> st is a variable.
23:01:51 <joe6> ok, thanks a lot for your help.
23:01:53 <pastorn> luqui: oh...
23:03:50 <luqui> also I would describe ST as like IO but with *less* magic :-)
23:04:26 <dolio> ST doesn't have any magic, really.
23:04:30 <dolio> As far as you can tell.
23:04:31 <pastorn> luqui: i thought of it because he mentioned "forall" just before he mentiond "st"
23:04:43 <pastorn> dolio: yes it does, the weird (forall s. ...) thingy
23:04:51 <dolio> That isn't magic.
23:04:55 <pastorn> i have no clue as to how it works
23:04:56 <dolio> That's just a type.
23:04:59 <pastorn> must be magic
23:05:06 <pastorn> @type runST
23:05:07 <lambdabot> forall a. (forall s. ST s a) -> a
23:05:23 <pastorn> what's up with that?
23:05:38 <pastorn> what can i use as an s?
23:05:39 <Philippa> it insists on a parameter that can run with /any/ state thread
23:05:58 <pastorn> state thread? what's a state thread?
23:05:58 <mm_freak> pastorn: it means, among other things, that the 's' type variable doesn't escape the type in the parentheses
23:06:01 <Philippa> an s
23:06:09 <mm_freak> pastorn: it's the essence of what makes 'ST' safe/pure
23:06:32 <pastorn> but cant' i just do something like
23:07:05 <pastorn> magic_s <- runSt getThatSweetST_s
23:07:17 <Bynbo7> nope
23:07:18 <mm_freak> 's' is a /type/, not a value
23:07:19 <Philippa> nope, because then the s would leak out of its scope
23:07:46 <Bynbo7> the type forall s. guarantees you can't get the s back out, because if you could, things won't typecheck... i think? hmm
23:07:59 <pastorn> so only if i had an 'ST s s' could i leak?
23:08:05 <shachaf> Bynbo7: The issue is that they *would* typecheck.
23:08:08 <Philippa> nope, not even that
23:08:13 <pastorn> wat?
23:08:22 <Philippa> you're only allowed to run a (forall s. ST s s)
23:08:30 <Bynbo7> shachaf: yeah, i realised that half way through writing that :)
23:08:45 <pastorn> Philippa: then what type will i get with runST on something like that?
23:09:00 <dolio> You'll get an error.
23:09:18 <Philippa> yeah, because the s would appear outside the forall that binds it
23:09:28 <dolio> Because it would have to be something like '(forall s. ST s s) -> s' but the last s isn't in scope.
23:10:31 <pastorn> ok
23:10:51 <pastorn> so it's impossible for the state and the return value to have the same type?
23:11:02 <pastorn> And what are common types of this 's'?
23:11:09 <pastorn> same as in MonadState?
23:11:16 <Philippa> no
23:11:28 <pastorn> or do you get some fixed stuff when you use the ST monadic functions?
23:11:31 <Philippa> the only concrete one you're likely to run into is RealWorld
23:11:46 <pastorn> then why is it qualified?
23:11:51 <pastorn> why not hidden?
23:11:52 <dolio> It's just a phantom type used to enforce coherence conditions.
23:12:11 <pastorn> what's ST short for?
23:12:11 <Philippa> because the qualification wouldn't do its job if you hid it
23:12:16 <Philippa> State Thread
23:12:22 <dolio> So that you can't past refs out of the scope in which they're defined, and such.
23:12:41 <pastorn> Philippa: exactly what do you mean by "state thread"?
23:12:45 <Philippa> the whole point is that different invocations of runST are /different/. They can't interact
23:12:49 <pastorn> does it fork off a bookkeeper?
23:12:59 <Philippa> they're separate heaps, yes
23:14:10 <joe6> why does this error: Warning: orphan instance: instance Bounded RequestType
23:14:26 <joe6> it happens when I used instance to add Bounded to RequestType
23:14:28 <Rotaerk> it means you're guilty of trying to murder orphans
23:14:58 <Philippa> http://www.haskell.org/haskellwiki/Orphan_instance
23:15:08 <mm_freak> pastorn: think of a function of this type:  (forall b. a -> b) -> a -> b
23:15:14 <mm_freak> pastorn: the outer 'b' is a different b
23:15:28 <pastorn> yeah... that sort of looks impossible
23:15:31 <mm_freak> outside of the function, which is the first argument you have no access to the inner 'b'
23:15:45 <pastorn> even if you fix the (b -> b)
23:15:46 <mm_freak> in other words, this function can only return bottom
23:16:22 <mm_freak> or even easier:  (forall a. a) -> a
23:16:28 <mm_freak> again the outer 'a' is different from the inner 'a'
23:16:41 <mm_freak> you could just as well write:  (forall a. a) -> b
23:16:46 <mm_freak> it's the same statement
23:17:07 <mm_freak> and since the inner 'a' has no class constraints, a function of this type couldn't do anything with its argument
23:17:20 <pastorn> mm_freak: bah! i'll just unsafeCoerce that shit :D
23:17:53 <joe6> how do you guys avoid orphan instances?
23:18:18 <joe6> instance Bounded RequestType where  minBound = Standard 
23:18:40 <joe6> RequestType is defined by System.USB and Bounded is defined somewhere else.
23:25:51 <Philippa> joe6: I don't, it's a warning not an error unless you've told the compiler to treat all warnings as errors
23:55:04 <luqui> joe6, orphan instances can be a major modularity problem if you publish your code for others to use
23:55:34 <luqui> joe6, define instance Bounded RequestType the same place you define RequestType
23:56:02 <luqui> Bounded is defined in the prelude, so that should not be a problem
