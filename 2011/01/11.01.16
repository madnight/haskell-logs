00:02:53 <joe6> luqui: ok, thanks. just not defining instance then.
00:10:38 <lars9> anyone used hp2any to profile haskell programs?
00:25:31 <joe6> > read ("00"::[Char]) :: Word8
00:25:32 <lambdabot>   0
00:25:40 <joe6> is there a better way of doing the above?
00:25:51 <joe6> without read, maybe?
00:33:48 <Maxdamantus> > (read ("00"::[Char]) :: Word8) == 0
00:33:49 <lambdabot>   True
00:39:53 <ivanm> there's a readHex or something in the Numeric module
00:40:06 <ivanm> or if you just want to see if it's all zero:
00:40:14 <ivanm> > all (=='0') "0000000"
00:40:15 <lambdabot>   True
00:41:03 <Maxdamantus> > read "12" :: Word8
00:41:04 <lambdabot>   12
00:43:18 <Maxdamantus> > foldl (\a b -> a * 10 + b) "12345"
00:43:18 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
00:43:18 <lambdabot>    arising from the literal ...
00:43:38 <Maxdamantus> > foldl (\a b -> a * 10 + b) 0 "12345"
00:43:39 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
00:43:39 <lambdabot>    arising from the literal `1...
00:43:44 <Maxdamantus> Bleh.
00:44:09 <Maxdamantus> > foldl (\a b -> a * 10 + fromEnum b - fromEnum '0') 0 "12345"
00:44:09 <lambdabot>   12345
00:44:38 <azaq23> > foldl (\a b -> let a' = ord a - 48; b' = ord b - 48 in a' * 10 + 'b) "12345"
00:44:39 <lambdabot>   <no location info>:
00:44:39 <lambdabot>      lexical error in string/character literal at chara...
00:44:41 <Maxdamantus> @pl \a b -> a * 10 + b
00:44:41 <lambdabot> (+) . (10 *)
00:45:24 <Maxdamantus> @pl \a b -> a * 10 + fromEnum b - 48
00:45:25 <lambdabot> flip flip 48 . ((-) .) . (. fromEnum) . (+) . (10 *)
00:45:52 <Maxdamantus> @pl \a b -> fromEnum b + a * 10 - 48
00:45:52 <lambdabot> flip flip 48 . ((-) .) . (. fromEnum) . (+) . (10 *)
00:47:01 <Yrogirg> Hello! I'm looking for custom colouring schemes for HsColour (.hscolour file). Is there a collection of them? I want colouring like in gtksourceview or in kate.
00:47:25 <Maxdamantus> > fix $ (read . show .)
00:47:26 <lambdabot>   The operator `L..' [infixr 9] of a section
00:47:26 <lambdabot>      must have lower precedence ...
00:47:35 <Maxdamantus> > fix ((read . show) .)
00:47:36 <lambdabot>   No instance for (GHC.Show.Show (f a))
00:47:36 <lambdabot>    arising from a use of `M6245020548...
01:12:37 <luqui> :t fix
01:12:37 <lambdabot> forall a. (a -> a) -> a
01:14:44 <luqui> :t ((read . show) .)
01:14:44 <lambdabot> forall a a1 (f :: * -> *). (Read a, Show a1, Functor f) => f a1 -> f a
01:16:02 * hackagebot hackport 0.2.12 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.12 (LennartKolmodin)
01:29:17 <Maxdamantus> > fix (((5*) . (/5)) .) $ 20
01:29:19 <lambdabot>   *Exception: stack overflow
01:29:27 <saket> test
01:29:28 <Egbert9e9> oh wow
01:30:19 <Egbert9e9> 20 divide by 5 then multiply by 5?
01:30:45 <Maxdamantus> Something like that.
01:30:56 <Egbert9e9> > ((5*) . (/5)) $ 20
01:30:58 <lambdabot>   20.0
01:31:05 <Maxdamantus> Apply a something that infinitely divides by 5 then multiplies by 5, to 20.
01:31:08 <Egbert9e9> but it won't fix the weird expression?
01:31:12 <Egbert9e9> oh
01:31:16 <Egbert9e9> O_O
01:31:30 <Maxdamantus> 20/5*5/5*5..
01:31:34 <Egbert9e9> how does it infinitely divides by 5 then multiply by 5?
01:31:38 <Maxdamantus> > fix (((5*) . (/5)) .) 20 :: Expr
01:31:40 <lambdabot>   5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (5 * (...
01:31:44 <Egbert9e9> zomg O_O
01:31:48 <Egbert9e9> > :t fix
01:31:49 <lambdabot>   <no location info>: parse error on input `:'
01:31:51 <Egbert9e9> err
01:32:02 <Maxdamantus> > fix (1:)
01:32:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:32:13 <Egbert9e9> that's insane
01:32:18 <Bynbo7> > fix ((5*).(5/))
01:32:21 <Egbert9e9> i see!
01:32:22 <lambdabot>   mueval-core: Time limit exceeded
01:32:27 <Bynbo7> :(
01:32:37 <Bynbo7> > fix ((5*).(5/)) 5
01:32:39 <lambdabot>   *Exception: stack overflow
01:32:46 <Egbert9e9> super cool
01:32:51 <Egbert9e9> hmmm
01:33:00 <Egbert9e9> fix 1
01:33:03 <Egbert9e9> err
01:33:05 <Maxdamantus> > fix $ (1:) . zipWith (*)
01:33:05 <Egbert9e9> > fix 1
01:33:06 <lambdabot>   Couldn't match expected type `[a]'
01:33:06 <lambdabot>         against inferred type `[a] -> [a]'
01:33:07 <lambdabot>   1
01:33:09 <Maxdamantus> > fix $ (1:) . zipWith (*) [1..]
01:33:10 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
01:33:16 <Egbert9e9> > fix [1]:
01:33:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:33:20 <Maxdamantus> > fix $ (1:) . zipWith (/) [1..]
01:33:22 <lambdabot>   [1.0,1.0,2.0,1.5,2.6666666666666665,1.875,3.2,2.1875,3.657142857142857,2.46...
01:33:25 <Egbert9e9> > fix ([1]:)
01:33:26 <lambdabot>   [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1...
01:33:39 <Maxdamantus> > sum $ takeWhile (> 1e-50) $ fix $ (1:) . zipWith (/) [1..]
01:33:39 <Egbert9e9> hhhmmmmmmm
01:33:47 <lambdabot>   *E
01:33:54 <Maxdamantus> *E?
01:34:02 <Maxdamantus> > sum $ takeWhile (> 1e-20) $ fix $ (1:) . zipWith (/) [1..]
01:34:06 <lambdabot>   mueval-core: Time limit exceeded
01:34:17 <Maxdamantus> Oh, that's not right.
01:34:47 <Maxdamantus> > sum $ takeWhile (> 1e-20) $ map (1/) $ fix $ (1:) . zipWith (*) [1..]
01:34:50 <Egbert9e9> > type
01:34:50 <lambdabot>   2.7182818284590455
01:34:51 <lambdabot>   <no location info>: parse error on input `type'
01:35:02 <Egbert9e9> :t fix
01:35:05 <lambdabot> forall a. (a -> a) -> a
01:35:08 * hackagebot sbv 0.9 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9 (LeventErkok)
01:35:20 <Egbert9e9> :t forall
01:35:21 <lambdabot> Not in scope: `forall'
01:35:27 <Egbert9e9> hmmm
01:35:33 <joe6> ivanm: thanks, the readHex was a good idea
01:35:47 <joe6> pastorn: are you still around?
01:35:50 <augur> hmm
01:36:38 <Egbert9e9> > head . fix $ 1:
01:36:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:36:45 <Egbert9e9> > (head . fix) $ 1:
01:36:45 <augur> anyone know of any techniques to optimize mathematical computations based on things like identifying when multiple subcomputations are computing similar, or related, things and then factoring out the common bit?
01:36:46 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:36:53 <Maxdamantus> > sum $ take 1000 $ 1 : scanl1 (/) [1..]
01:36:54 <lambdabot>   2.7182818284590455
01:36:55 <Egbert9e9> > (head . fix) $ (1:)
01:36:57 <lambdabot>   1
01:38:16 <Maxdamantus> > fix $ (1:) . (1:) . ap (zipWith (+)) tail
01:38:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
01:40:23 <Maxdamantus> @pl fib = 1 : 1 : zipWith (+) (tail fib) fib
01:40:23 <lambdabot> fib = fix ((1 :) . (1 :) . (zipWith (+) =<< tail))
01:41:29 <Maxdamantus> @pl fib a = 1 : 1 : zipWith (+) (tail (fib a)) (fib a)
01:41:29 <lambdabot> fib = fix ((([1, 1] ++) .) . (ap =<< ((zipWith (+) . tail) .)))
01:44:16 <Maxdamantus> > fix ((([1, 1] ++) .) . (ap =<< ((zipWith (+) . tail) .))) $ 5
01:44:20 <lambdabot>   mueval-core: Time limit exceeded
01:55:41 <Bynbo7> :t (zipWith (+)) `ap` tail
01:55:42 <lambdabot> forall a. (Num a) => [a] -> [a]
01:56:12 * hackagebot PermuteEffects 0.2 - Permutations of effectful computations  http://hackage.haskell.org/package/PermuteEffects-0.2 (MartijnVanSteenbergen)
01:56:21 <Bynbo7> > fix $  (1:) . (1: ) . (zipWith (+)) `ap` tail[D
01:56:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:56:29 <Bynbo7> > fix $  (1:) . (1: ) . (zipWith (+)) `ap` tail)
01:56:30 <lambdabot>   <no location info>: parse error on input `)'
01:56:51 <Bynbo7> > fix $  (1:) . (1: ) . ((zipWith (+)) `ap` tail)
01:56:53 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
01:57:43 <shachaf> > fix$(1:).scanl(+)1
01:57:45 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
01:58:04 <companion_cube> augur, you're talking about memoization ?
01:58:13 <augur> companion_cube: no
01:58:18 <luqui> augur, or perhaps CSE (common subexpression elimination)?
01:58:29 <augur> i mean, its sort of related to memoization
01:58:36 <augur> and maybe related to CSE too
01:58:52 <companion_cube> i think memoization is easier than dynamic programming in haskell
01:58:57 <augur> but with the possibility that the thing in common isnt syntactically identical but semantically identical
01:59:25 <luqui> augur, hmm, you'd have to have a simplifier like, say, mathematica's
01:59:54 <augur> so that you might have two expressions, f and g, and you can replace them with f' h and g' h
02:00:14 <augur> where h is something common to both f and g, but not necessarily obviously so
02:00:21 <luqui> and mathematica has the good fortune of expressing complex mathematical things in mathematical notation so that it can apply rules.
02:00:48 <luqui> if all you've got is, say, lambda calculus with some numeric primitives, i would say "fat chance"
02:00:57 <luqui> assuming you are doing iteration and stuff
02:02:04 <luqui> basically, a problem that general is unlikely to have a good solution.  do you have something more specific in mind?
02:05:17 <Maxdamantus> @pl \(a, b) -> (f a, f b)
02:05:17 <lambdabot> f *** f
02:05:54 <Maxdamantus> @pl (\(a, b) -> (f a, f b)) x
02:05:54 <lambdabot> (f (fst x), f (snd x))
02:06:43 <luqui> that's weird
02:06:59 <luqui> you'd think it would say (f***f) x
02:07:34 <luqui> i guess it doesn't try to find the simplest one
02:08:00 <opqdonut> luqui: it only tries to make the function you gave it point-free, not any contained functions
02:08:03 <opqdonut> AFAIK
02:08:34 <opqdonut> @pl \y -> f (\x -> x) y
02:08:35 <lambdabot> f id
02:08:36 <luqui> sure.  i thought it had a simplifier in it.  maybe that's something else
02:08:44 <opqdonut> okay, it does do something further
02:08:56 <luqui> it eliminates all \s
02:09:39 <luqui> @pl (\x -> x x) (\x -> x x)
02:09:43 <lambdabot> ap id id (ap id id)
02:09:43 <lambdabot> optimization suspended, use @pl-resume to continue.
02:10:08 <luqui> huh, it does seem to have some sort of simplifier.  it just didn't do a good job with Maxdamantus's
02:10:14 <companion_cube> @pl \f-> (\x -> f (x x))(\x -> f (x x))
02:10:15 <lambdabot> ap (. join id) (. join id)
02:10:17 <companion_cube> nice
02:10:56 <luqui> @pl (\x -> x x) (\x -> x x x)
02:10:59 <lambdabot> ap id id (ap (ap id id) id)
02:10:59 <lambdabot> optimization suspended, use @pl-resume to continue.
02:11:12 <luqui> can't make it explode as easily as wolframalpha
02:11:14 <Bynbo7> @pl-resume
02:11:19 <Bynbo7> gogogo
02:11:20 <lambdabot> ap id id (ap (ap id id) id)
02:11:20 <lambdabot> optimization suspended, use @pl-resume to continue.
02:11:24 <Bynbo7> @pl-resume
02:11:30 <Bynbo7> :(
02:11:33 <luqui> heh, it's not gonna get any simpler
02:11:36 <lambdabot> ap id id (ap (ap id id) id)
02:11:36 <lambdabot> optimization suspended, use @pl-resume to continue.
02:11:39 <Bynbo7> yeah
02:11:55 <Bynbo7> @pl (\x -> x x x)  (\x -> x x x)
02:11:59 <lambdabot> ap (ap id id) id (ap (ap id id) id)
02:11:59 <lambdabot> optimization suspended, use @pl-resume to continue.
02:12:32 <luqui> doesn't beta unsubstitute...
02:12:44 <luqui> because that's hard as heck
02:15:17 * hackagebot crc16 0.1.1 - Calculate the crc16-ccitt.  http://hackage.haskell.org/package/crc16-0.1.1 (JorisPutcuyps)
02:16:31 <ivanm> wow, what an informative package description...
02:24:28 <ivanm> does anyone here still happen to be using 6.10? I need to test something with it but don't have access to a machine with it atm :s
02:27:06 <Phyx-> i still have 6.10.4 installed along side the newer ones
02:28:21 <ivanm> if I upload a tarball somewhere, can you please check that it builds with it?
02:28:40 <ivanm> (technically, I care more about it building with Cabal-1.6, but you can't build Cabal-1.6 with 6.12 :s)
02:30:02 <Phyx-> sure
02:31:00 <ivanm> http://code.haskell.org/~ivanm/haskell-updater-1.1.3.0.tar.gz
02:31:14 <ivanm> ta
02:32:19 <shrubbery> ta
02:33:05 <Maxdamantus> > join (***) f (x, y)
02:33:06 <lambdabot>   Ambiguous type variable `c' in the constraints:
02:33:06 <lambdabot>    `GHC.Show.Show c'
02:33:06 <lambdabot>      a...
02:33:12 <Maxdamantus> > join (***) f (x, y) :: Expr
02:33:13 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:33:13 <lambdabot>         against inferred ...
02:33:20 <Phyx-> it fails, lemme post the error
02:34:19 <Phyx-> ivanm: http://phyx.pastebin.com/wSsNsHph
02:34:21 <ivanm> *sigh* didn't think it would work
02:36:30 <ivanm> Phyx-: if it gets defined internally (i.e. just put rawSystemStdInOut = undefined in that module), does it build everything else?
02:36:51 <Phyx-> lemme check
02:37:38 <Phyx-> ivanm: yeah, then it builds
02:38:00 <ivanm> so that's the only thing stopping it from building? excellent, I might just copy that in then
02:38:03 <ivanm> thanks Phyx-
02:38:06 <ivanm> @karma+ Phyx- 
02:38:06 <lambdabot> Phyx-'s karma raised to 1.
02:38:15 <Phyx-> np :)
02:38:28 <mauke> people need to stop using @karma+ :-/
02:39:33 <Philippa> @karma- @karma+
02:39:33 <lambdabot>  @karma+'s karma lowered to -1.
02:39:42 <mauke> :-(
02:39:47 <ivanm> mauke: why?
02:40:02 <mauke> because lambdabot is the only thing that parses it
02:40:07 <ivanm> I used it because I wasn't sure how the `-' at the end of Phyx-'s nick would interact with ++
02:40:10 <mauke> everyone else uses "thing++"
02:40:12 <Philippa> could be worse. All those chans where C gets the highest karma rating of anything...
02:40:17 <ivanm> heh
02:40:20 <ivanm> @karma C
02:40:20 <lambdabot> C has a karma of 3
02:40:32 <Kaidelong> @karma chameleon
02:40:32 <lambdabot> chameleon has a karma of 4
02:40:33 <Maxdamantus> C--
02:40:35 <mauke> Philippa: I like that, actually
02:40:49 <mauke> it shows that even C++'s name is stupid
02:41:10 <Philippa> but of course: it evaluates to C
02:41:36 <shrubbery> which is why we got C# because the other efforts fell flat
02:42:48 <mauke> wat
02:42:52 <mauke> C# is Java, not C
02:46:03 <mm_freak> @karma haskell
02:46:03 <lambdabot> haskell has a karma of 60
02:48:27 <Maxdamantus> @karma coma
02:48:27 <lambdabot> coma has a karma of 0
02:48:36 <mauke> preflex: karma coma
02:48:36 <preflex>  coma: -1
02:48:45 <mauke> preflex: karma haskell
02:48:45 <preflex>  haskell: 57
02:51:03 <Maxdamantus> @karma C++
02:51:03 <lambdabot> C++ has a karma of 0
03:11:36 * hackagebot haskell-updater 1.2.0.0 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.0 (IvanMiljenovic)
03:35:54 <drp> @pl \x -> x*x*x
03:35:55 <lambdabot> (*) =<< join (*)
03:36:31 <drp> @pl \x -> x+x*x
03:36:31 <lambdabot> ap (+) (join (*))
03:38:54 <Kaidelong> s (*) (s (*) id)
03:38:58 <Kaidelong> if you have the s combinator
03:40:24 <Kaidelong> > let subst f g x = f x (g x) in subst (*) (subst (*) id) 5
03:40:26 <lambdabot>   125
03:40:53 <Kaidelong> > let subst f g x = f x (g x) in subst (+) (subst (*) id) 5
03:40:54 <lambdabot>   30
03:42:01 <mauke> > ap (+) (ap (*) id) 5
03:42:02 <lambdabot>   30
03:42:30 <Kaidelong> @src ap
03:42:31 <lambdabot> ap = liftM2 id
03:42:47 <Kaidelong> overloading trickery, mauke!
03:42:53 <mauke> why overloading?
03:43:04 <Kaidelong> monad instance for functions
03:43:14 <mauke> well, of course
03:43:19 <mauke> <3 Reader
03:43:35 <Kaidelong> I did not know you could use ap as S
03:43:43 <Kaidelong> that is quite cool
03:45:26 <Kaidelong> @ty liftM2 id
03:45:27 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
03:45:40 <Kaidelong> @ty flip id
03:45:41 <lambdabot> forall a b. a -> (a -> b) -> b
03:46:27 <mauke> > ap f g x
03:46:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
03:46:29 <lambdabot>    `GHC.Show.Show a'
03:46:29 <lambdabot>      a...
03:46:48 <mauke> > ap (f :: Expr -> Expr -> Expr) g x
03:46:49 <lambdabot>   f x (g x)
03:47:09 <mauke> > join f x :: Expr
03:47:11 <lambdabot>   f x x
03:48:01 <Kaidelong> @ty join . flip
03:48:02 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
03:48:43 <mauke> > (join . flip) f x :: Expr
03:48:46 <lambdabot>   f x x
03:49:41 <Kaidelong> > fix (const x) :: Expr
03:49:42 <lambdabot>   x
03:49:58 <mauke> > fix (const x)
03:49:59 <lambdabot>   x
03:50:11 <Kaidelong> ah you can infer Expr?
03:50:18 <mauke> :t x
03:50:18 <Kaidelong> or is that just lambdabot dark magic?
03:50:19 <lambdabot> Expr
03:50:27 <mauke> no, this is x having a known type
03:50:28 <Kaidelong> :t expedience
03:50:29 <lambdabot> Not in scope: `expedience'
03:50:35 <mauke> > fmap fix return x
03:50:36 <lambdabot>   x
03:51:32 <aristid> > (f >=> g) x
03:51:34 <lambdabot>   No instance for (GHC.Show.Show (m c))
03:51:34 <lambdabot>    arising from a use of `M7270306741...
03:51:41 <aristid> :t (f >=> g) x
03:51:43 <lambdabot> forall (m :: * -> *) b c. (SimpleReflect.FromExpr (m b), Show b, SimpleReflect.FromExpr (m c), Monad m) => m c
03:51:59 <aristid> > (f >=> g) x :: Expr -> Expr
03:52:00 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:52:00 <Kaidelong> > (*) >=> (+)
03:52:00 <lambdabot>    `GHC.Show.Show b'
03:52:00 <lambdabot>      a...
03:52:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
03:52:02 <lambdabot>    arising from a use...
03:52:07 <Kaidelong> @ty (*) >=> (+)
03:52:08 <lambdabot> forall a. (Num a) => a -> a -> a
03:52:21 <Kaidelong> > (*) >=> (+) $ 3 5
03:52:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:52:22 <lambdabot>    arising from a use of `...
03:52:35 <Kaidelong> > ((*) >=> (+)) $ 3 5
03:52:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:52:36 <lambdabot>    arising from a use of `...
03:52:41 <Kaidelong> oh
03:52:59 <Kaidelong> > ((*) >=> (+)) $ 3 5 :: Int
03:53:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:53:00 <lambdabot>         against inferred type ...
03:53:06 <Kaidelong> @more
03:53:18 <mauke> Kaidelong: dude, you're calling 3 with 5
03:53:26 <Kaidelong> ...!
03:53:26 <mauke> why would you do that :-(
03:53:33 <Kaidelong> Because I haven't slept in...
03:53:36 <Kaidelong> also
03:53:42 <Kaidelong> yay for the num instance
03:53:45 <aristid> BECAUSE HE CAN
03:53:46 <mauke> > 3 5 :: Int
03:53:47 <lambdabot>   3
03:53:49 <mauke> do ho ho
03:53:53 <Kaidelong> > ((*) >=> (+)) $ 3 $ 5
03:53:54 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
03:53:54 <lambdabot>    arising from a use of `...
03:54:02 <Kaidelong> > (((*) >=> (+)) $ 3) $ 5
03:54:03 <lambdabot>   20
03:54:10 <mauke> > ((*) >=> (+)) 3 5
03:54:11 <lambdabot>   20
03:54:13 <Kaidelong> well I wasn't expecting that
03:54:24 <mauke> > ((*) >=> (+)) x y
03:54:24 <lambdabot>   x * y + y
03:54:38 <Kaidelong> oh...
03:55:05 <mauke> > ((*) `ap` (+)) x y
03:55:06 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
03:55:13 <mauke> unary
03:55:25 <Kaidelong> > (join (*) >>= (+)) 3 5
03:55:27 <lambdabot>   12
03:55:42 <mauke> > ((*) `ap` join (+)) x y
03:55:43 <lambdabot>   Couldn't match expected type `t -> t1'
03:55:43 <lambdabot>         against inferred type `Simpl...
03:55:45 <Kaidelong> eeeeh?
03:55:48 <Kaidelong> 12?
03:55:55 <Kaidelong> > (join (*) >>= (+)) x y :: Expr
03:55:56 <lambdabot>   Couldn't match expected type `t -> SimpleReflect.Expr'
03:55:57 <lambdabot>         against infe...
03:56:04 <Kaidelong> > (join (*) >>= (+)) x y
03:56:05 <mauke> > ((*) `ap` join (+)) x
03:56:05 <lambdabot>   Couldn't match expected type `t -> t1'
03:56:06 <lambdabot>         against inferred type `Simpl...
03:56:06 <lambdabot>   x * (x + x)
03:56:15 <mauke> Kaidelong: it's 3*3 + 3
03:56:26 <mauke> > (3 * 3 + 3) 5
03:56:27 <lambdabot>   12
03:56:39 <Kaidelong> num instance, great
03:57:00 <Kaidelong> oh, that makes sense though
03:57:39 <Kaidelong> I better sleep~
04:00:23 <Egbert9e9> so IO () is a monad of IO state and nil returned value?
04:00:38 <Egbert9e9> that type signature
04:01:06 <Boxo> I don't think many people would put it like that
04:01:16 <Egbert9e9> hmmm
04:01:30 <ion> IO () represents an IO computation that results in a value of type ()
04:01:34 <Boxo> it is an I/O action that returns a value of type ()
04:01:39 <ion> action, yeah
04:01:51 <Boxo> the only such value happens to be "()"
04:02:29 <Egbert9e9> value of a type which has only one value and this value is pretty much nothingness?
04:02:33 <aristid> :t (>=>)
04:02:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:02:47 <aristid> :t (f >=> g) x y
04:02:49 <lambdabot>     Ambiguous type variable `b' in the constraints:
04:02:49 <lambdabot>       `SimpleReflect.FromExpr b'
04:02:49 <lambdabot>         arising from a use of `f' at <interactive>:1:1
04:03:05 <aristid> :t (f :: Expr -> Expr -> Expr >=> g) x y
04:03:06 <lambdabot>     Could not deduce (SimpleReflect.FromExpr ((>=>) Expr g))
04:03:06 <lambdabot>       from the context ()
04:03:06 <lambdabot>       arising from a use of `f' at <interactive>:1:1
04:03:25 <aristid> :t ((f :: Expr -> Expr -> Expr) >=> (g :: Expr -> Expr -> Expr)) x y
04:03:26 <lambdabot> Expr
04:03:30 <aristid> > ((f :: Expr -> Expr -> Expr) >=> (g :: Expr -> Expr -> Expr)) x y
04:03:30 <Egbert9e9> oh, it's the empty tuple
04:03:31 <lambdabot>   g (f x y) y
04:04:10 <Egbert9e9> the empty tuple type can hold only one value
04:04:24 <Egbert9e9> nice
04:04:54 <aristid> Egbert9e9: no, it can hold two values.
04:04:59 <Egbert9e9> really?
04:05:07 <aristid> yes. () and bottom
04:05:15 <aristid> :t  undefined :: ()
04:05:20 <lambdabot> ()
04:05:46 <ivanm> aristid: yeah, but we usually don't mention bottom...
04:06:18 <aristid> ivanm: huh? it's mentioned quite often here :)
04:06:37 <Egbert9e9> now i feel like i'm stepping into high energy physics conversation
04:06:37 <ivanm> you know what I mean...
04:06:53 <ivanm> Egbert9e9: don't be ridiculous: high energy physics can sometimes be useful! :p
04:06:59 <Egbert9e9> :-D
04:07:03 <aristid> bottom can be useful too
04:07:19 <aristid> it allows more kinds of recursion AFAIK
04:07:34 <Egbert9e9> don't be hard on cs. everything it's based on was once considered as useless math
04:07:39 <ivanm> aristid: it's for laziness IIRC
04:07:44 <Egbert9e9> useless games
04:07:50 <ivanm> Egbert9e9: hey, I _love_ useless maths!
04:07:57 <Egbert9e9> ya, games are fun
04:07:58 <ion> > mkStdGen (2^31) -- is bottom
04:08:02 <lambdabot>   mueval-core: Time limit exceeded
04:08:25 <Egbert9e9> do i really want to know what's bottom at this point in my life?
04:08:27 <aristid> :t mkStdGen
04:08:28 <lambdabot> Int -> StdGen
04:08:44 <aristid> Egbert9e9: bottom is not complicated. it's just the "error value".
04:08:50 <Egbert9e9> i see
04:09:05 <aristid> Egbert9e9: whenever you have infinite recursion or another error, you get bottom
04:09:13 <ivanm> consider it analogous to NaN and Infinity in floating point numerics
04:09:17 <Egbert9e9> so the IO () actions monad can also tell us something bad happened in its chain of commands?
04:09:22 <Egbert9e9> ah
04:09:30 <aristid> Egbert9e9: no, bottom is outside IO ()
04:09:35 <Egbert9e9> okay
04:09:50 <mauke> it's like when you call a function that never returns
04:10:00 <mauke> the function has a return type, but you never see an actual value there
04:10:03 <mauke> we call that "bottom"
04:10:09 <Egbert9e9> why bottom?
04:10:13 <mauke> math
04:10:25 <Bynbo7> > mkStdGen (2^31 - 1)
04:10:27 <lambdabot>   86 2
04:10:30 <Bynbo7> > mkStdGen (2^31)
04:10:34 <lambdabot>   mueval-core: Time limit exceeded
04:10:37 <Bynbo7> > mkStdGen (2^31+1)
04:10:38 <lambdabot>   86 2
04:10:41 <Egbert9e9> is it really high math i will never grok or something pretty trivial i can understand in this conversation?
04:10:42 <Bynbo7> o.O
04:10:48 <Bynbo7> that's not particularly random
04:10:52 <Egbert9e9> lattice theory
04:10:53 <Bynbo7> > mkStdGen (2^31+2)
04:10:55 <lambdabot>   85 2
04:10:56 <mauke> Egbert9e9: it's the least existing value or something like that
04:11:00 <Bynbo7> > mkStdGen (2^31+3)
04:11:01 <lambdabot>   84 2
04:11:03 <Egbert9e9> O_O
04:11:05 <aristid> Egbert9e9: bottom is not high math.
04:11:07 <Bynbo7> :|
04:11:20 <Egbert9e9> consider me perplexed
04:11:43 <ivanm> Egbert9e9: put it this way: quite often the design of Haskell was based upon mathematical concepts and terminology, but very rarely do you need to know the maths involved to use or talk about it
04:11:48 <aristid> Egbert9e9: once you understand laziness, it's almost trivial :)
04:11:57 <Egbert9e9> ah, there are a bunch of number fields
04:12:09 <keep_learning> hello all 
04:12:14 <keep_learning> factor::Integer->Integer->IO [Integer] factor 1 m = return ([1]) factor n m  = do                 l<-rCurve n                 let p=multiEC (Conelliptic (l!!0) (l!!1) (l!!2)) (Conpoint (l!!3) (l!!4)) m                 k <-case p of                                      Left p'->factor n m                                          Right p'-> return (p') ::factor (div n p') m                             return (k) 
04:12:37 <ion> Pastebin, *please*.
04:12:43 <Bynbo7> @where hpaste
04:12:43 <lambdabot> http://hpaste.org/
04:12:45 <Egbert9e9> ivanm, something tells me that knowing a lil bit about the math concepts will make learning haskell easier
04:12:50 <keep_learning> factor::Integer->Integer->IO [Integer] factor 1 m = return ([1]) factor n m  = do  		l<-rCurve n 		let p=multiEC (Conelliptic (l!!0) (l!!1) (l!!2)) (Conpoint (l!!3) (l!!4)) m 		k <-case p of  				Left p'->factor n m  				Right p'-> return (p') ::factor (div n p') m   		return (k)
04:13:05 <Egbert9e9> oh god, oneliners
04:14:34 <Bynbo7> keep_learning: please use hpaste
04:14:45 <ivanm> Egbert9e9: I still barely know anything about category theory, yet I still manage to use monads, etc. :p
04:14:54 <keep_learning> http://hpaste.org/43063/haskell_program
04:14:57 <Egbert9e9> hmm
04:15:11 <Bynbo7> keep_learning: why does that function need to be in IO?
04:15:23 <Egbert9e9> is there a haskell beautifier?
04:15:25 <keep_learning> Bynbo7: i am getting this error
04:15:29 <keep_learning> Elliptic.hs:73:15:     Couldn't match expected type `IO [Integer]'            against inferred type `factor (div n p') m'     In the expression: return (p') :: factor (div n p') m     In a case alternative:         Right p' -> return (p') :: factor (div n p') m     In a stmt of a 'do' expression:         k <- case p of {                Left p' -> factor n m                Right p' -> return (p') :: factor (div n p') m } 
04:15:44 <Bynbo7> keep_learning: please stop pasting so much in channel!
04:15:51 <aristid> keep_learning: paste the errors on hpaste.org, too.
04:16:14 <Egbert9e9> oh my, there's a reddit haskell page
04:16:20 <keep_learning> Bynbo7: because of  l<-rCurve n
04:16:23 <Bynbo7> boody hell that code is ugly
04:16:35 <Bynbo7> why is everything so for to the right? o.O
04:16:38 <keep_learning> rCurve returns IO [Integer] 
04:17:02 <Egbert9e9> there's a haskell sytple guide
04:17:03 <Bynbo7> keep_learning: also, make your editor produce spaces instead of tabs
04:17:05 <Egbert9e9> haskell style
04:17:42 <keep_learning> Bynbo7: k but u can have a look on factor 
04:17:46 <ivanm> Egbert9e9: there are a couple of style guides, actually; IIRC there are a few things I disagree with them
04:17:49 <Bynbo7> keep_learning: the return () isn't necessary in main
04:18:05 <keep_learning> Bynbo7: thank you
04:18:13 <keep_learning> but how to remove the error 
04:18:15 <Bynbo7> keep_learning: you've got return (p') ::factor (div n p') m, which makes no sense
04:18:25 <keep_learning> i know i can use System.random 
04:18:38 <keep_learning> which does not have side effect 
04:18:39 <Bynbo7> :: is used for types, i think you want to use : which is for lists, but you're not using that right there
04:18:47 <Egbert9e9> ivanm, did you write your criticism online?
04:18:51 <ivanm> nope
04:18:51 <Egbert9e9> i mean, published
04:19:02 <ivanm> only a few small things I did differently
04:19:07 <ivanm> not enough to bitch about ;-)
04:19:12 <Egbert9e9> i'm kinda jumping from one subject to another right now
04:19:20 <Egbert9e9> i see
04:19:25 <ivanm> my philosophy is: if you're hacking on someone else's project, follow their style
04:19:31 <Egbert9e9> i've been reading a bit of that irc bot tutorial
04:20:14 <keep_learning> but i am Bynbo7  Couldn't match expected type `[m Integer]'            against inferred type `IO [Integer]'     In the second argument of `(:)', namely `factor (div n p') m'     In the expression: return (p') : factor (div n p') m     In a case alternative:         Right p' -> return (p') : factor (div n p') m 
04:20:18 <keep_learning> still the error 
04:20:39 <aristid> :t sequence
04:20:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:21:35 <Bynbo7> keep_learning: what you want it do { ps <- factor (div n p') m; return (p:ps)]
04:21:38 <Bynbo7> } not ]
04:22:06 <keep_learning> Bynbo7: yes
04:22:24 <Bynbo7> keep_learning: can i also suggest to go and look at some other people's code? your code is... to say the least, very ugly, at least in terms of indentation
04:22:39 <keep_learning> Bynbo7: but one thing till i did not got the all factors , i will keep calling factor with random values 
04:22:58 <Bynbo7> huh? :\
04:23:55 <keep_learning> Bynbo7:  i am new Bie so experimenting with haskell
04:24:26 <keep_learning> Bynbo7:  could u suggest a good editor for fedora 
04:24:27 <Bynbo7> sure, but it's good to get into good habits early
04:24:45 <keep_learning> Bynbo7:  :) yes 
04:24:46 <Bynbo7> no, i don't use linux, and i have never found an editor i liked on linux
04:25:00 <keep_learning> Bynbo7: k 
04:25:07 <keep_learning> i will search for editor 
04:25:26 <aristid> keep_learning: many people use emacs :P
04:25:28 <Bynbo7> whatever editor you do use, make sure you can turn off using tabs
04:25:37 <keep_learning> Bynbo7: can u just find the bug in factor code
04:25:47 <Bynbo7> i did, and showed you how to fix it
04:25:57 <Bynbo7> 21:25 < Bynbo7> keep_learning: what you want it do { ps <- factor (div n p') m; return (p:ps)]
04:26:12 <Bynbo7> uh, p':ps there
04:26:13 <gienah> emacs does not know how to indent haskell code though, and neither do I
04:26:21 <gienah> maybe yi
04:26:36 <Bynbo7> also, there's no need to be using IO here at all
04:26:45 <gienah> I looked for a pretty printer for haskell code and could not find one
04:27:27 <Bynbo7> vim doesn't do a terrible job with indentation
04:27:34 <Bynbo7> but i quite dislike vim and emacs
04:27:35 <merijn> gienah: Vim is working ok for me with Haskell indentation
04:27:55 <merijn> I don't buy that there is no good Haskell mode for emacs...
04:27:56 <aristid> gienah: right, emacs' haskell-mode does not indent perfectly, but it's bearable
04:28:16 <aristid> merijn: there is. it just doesn't always indent perfectly
04:28:43 <merijn> I think perfect indentation is an AI-Hard problem :p
04:29:08 <Bynbo7> especially since there's many different ways people indent their code
04:29:30 <gienah> yi has a really cool approach to the problem: it incrementally parses Haskell :-)
04:30:19 <merijn> How is Yi's vim support?
04:31:05 <gienah> merijn: I'm not really sure, it has some vim support, but I've only tried yi with the emacs support
04:32:22 <ion> Source code should be in a parse tree kind of format with small hints about displaying (‚Äúan extra newline here‚Äù etc.) and editors and viewers should automatically format the code according to default or user-specified rules, taking advantage of things such as wide or very narrow (think mobile device) screens. :-)
04:32:39 <merijn> I fear switching from vim to something vim-like will cause me to miss out on crucial features (such as the ability to copy to OS clipboard from console editor)
04:33:18 <Bynbo7> keep_learning: ok, i'm going to try and clean up your code for you
04:33:48 <keep_learning> Bynbo7:  thank you and i am also going to remove IO 
04:34:06 <keep_learning> Bynbo7: going to try random without IO 
04:35:59 <Bynbo7> you really do love let don't you ;)
04:37:04 <Bynbo7> keep_learning: start with this: http://hpaste.org/paste/43063/haskell_program_annotation#p43064
04:38:27 <keep_learning> Bynbo7: thank you
04:39:16 <Bynbo7> keep_learning: in extend_gcd, do you just want to make sure all elements in the list are positive?
04:39:33 <keep_learning> Bynbo7: yes
04:39:36 <pozic_> > let in let in let in let in let in  1
04:39:39 <lambdabot>   1
04:39:55 <Bynbo7> keep_learning: why not use map abs?
04:40:08 <Bynbo7> > map abs [1, -7, -10, 15]
04:40:09 <lambdabot>   [1,7,10,15]
04:41:46 <keep_learning> Bynbo7: i will keep in mind these things
04:42:25 <Bynbo7> keep_learning: http://hpaste.org/paste/43063/haskell_program_annotation#p43065
04:45:02 <keep_learning> Bynbo7: your help is appreciated 
04:45:11 <keep_learning> Bynbo7: i will keep these things in mid 
04:45:14 <keep_learning> :mind
04:45:19 <Bynbo7> good :)
04:59:30 <kuffaar> Hmm so you usually use newtype to declare types for a Monad?
04:59:41 <Bynbo7> eh?
04:59:58 <sipa> if you want an encapsulated state monad or so, yes
05:00:17 <Bynbo7> :t Reader
05:00:18 <lambdabot> Not in scope: data constructor `Reader'
05:00:22 <Bynbo7> @src Reader
05:00:23 <lambdabot> Source not found. :(
05:00:25 <Bynbo7> :(
05:00:25 <kuffaar> :t ReaderT
05:00:26 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
05:00:44 <Bynbo7> @src ReaderT
05:00:44 <lambdabot> Source not found. Where did you learn to type?
05:01:32 <Bynbo7> keep_learning: ok, this is a lot better: http://hpaste.org/paste/43063/haskell_program_annotation#p43066
05:02:11 <Bynbo7> i haven't figured out how to clean up some of the let bindings, i'm sure it's possible though
05:39:11 <keep_learning> Bynbo7: thank you 
05:39:19 <Elko> Hi there!
05:39:31 <keep_learning> Bynbo7: i also implemented without IO 
05:39:44 <keep_learning> Bynbo7: thank you for your help
05:39:47 <Bynbo7> good!
05:39:50 <Bynbo7> no worries
05:39:51 <Elko> I need some help with that: http://hpaste.org/43067/dictionary
05:40:07 <mauke> hello, electrolytic capacitor
05:40:23 <Elko> Hi, mauke
05:40:36 <mauke> Elko: what is lookup supposed to return when the key is not in the dictionary?
05:40:38 <j-invariant> sorry Elko but you cannot do "type dictionary = String -> String", please change it to type Dictionary = String -> String
05:41:18 <aristid> Elko: looks like a homework?
05:41:33 <j-invariant> aristid: especially since someone came asking the exact same question yesterday X)
05:41:33 <Elko> j-invariant: Thanks! :)
05:41:54 <aristid> j-invariant: hah
05:42:11 <Elko> aristid: Yes! That's right. I don't want it to be solved. I want to do it on my own. But I'm a bit messed up with that code... :(
05:42:30 <mauke> is the homework text online?
05:43:01 <Elko> mauke: I have to do it like that "lookup "Haus" (insert "Haus" "house" empty)
05:43:10 <mauke> that doesn't answer anything
05:43:25 <mauke> what is lookup "X" empty supposed to return?
05:43:46 <Elko> The translated word
05:43:52 <mauke> ...
05:43:57 <mauke> WHAT TRANSLATED WORD
05:44:02 <mauke> THE DICTIONARY IS EMPTY
05:44:19 <Elko> Yes, I know... I have to insert the word before
05:44:36 <Elko> at the same time respectivily
05:44:39 <aristid> Elko: but what if you don't? what is supposed to happen?
05:44:46 <Gracenotes> thar is a shoutin
05:44:50 <mauke> where's the text of this assignment?
05:44:52 <aristid> MAUKE IS A SHOUTER
05:45:07 <mauke> ÔºØÔº® Ôº©Ôº≥ Ôº¥Ôº®Ôº°Ôº¥ Ôº≥ÔºØÔºü
05:45:15 <Elko> aristid: An error. Like "not found"
05:45:16 <Bynbo7> IT HURTS!
05:45:26 <mauke> Elko: "not found" is a string, not an error
05:45:44 <sipa> ¬ø«ù ç  É É…ê…•s 's…π«ù á…î…ê…π…ê…•…î «ùpo…îƒ±un p…πƒ±«ù ç ∆Éuƒ±sn  á…π…ê ás  áou s, á«ù É
05:45:45 <aristid> mauke: maybe he means that "not found" is the default string?
05:45:53 <mauke> Elko: where's the text of this assignment?
05:46:08 <mauke> sipa: ¬ø áou  é…• ç
05:46:10 <aristid> sipa: absolutely not
05:46:20 <Elko> mauke: at my desk ;) Do you want the task explanation?
05:46:40 <mauke> I'd like an exact copy
05:46:47 <Elko> if you understand german, i can send you the pdf 
05:47:06 <mauke> that would be nice
05:47:27 <Elko> via?
05:47:47 <j-invariant> via the internet
05:48:01 <mauke> random webspace maybe, or mediafire.com
05:48:05 <Elko> j-invariant: Nice hint
05:48:12 <sipa> i'd use pigeons
05:48:31 <sipa> oh well... http://en.wikipedia.org/wiki/IP_over_Avian_Carriers
05:49:09 <Elko> http://www.mediafire.com/?y4ec26zd7y37mb8
05:50:03 <mauke> http://mauke.dyndns.org/tmp/Blatt10.pdf
05:50:10 <aristid> Elko: Woerterbuch has the correct case there, why did you replace it by lower-case dictionary?
05:50:32 <mauke> heh, the pitfalls of cross language coding
05:50:33 <Elko> I changed it like j-invariant suggested
05:50:43 <aristid> so "nicht gefunden" is the default value
05:50:51 <Elko> jep
05:50:51 <mauke> "method signatures"? how about no
05:51:02 <Elko> Sry?
05:51:14 <mauke> it calls values "methods"
05:51:32 * hackagebot blaze-html 0.4.0.0 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.4.0.0 (JasperVanDerJeugt)
05:51:40 <mauke> that prof needs slapped
05:51:55 <aristid> a good old slapping can never hurt
05:51:59 <aristid> except the slappee
05:53:37 <Elko> what's wrong?
05:53:58 <mauke> "foo" is not a method, it's a string
05:54:04 <mauke> id is not a method, it's a function
05:55:20 <aristid> mauke: didn't you know that "method" is German for value?
05:55:40 <mauke> this is a fun exercise though
05:56:57 <Elko> So are you able to help me or shall I do it completly on my own?!
05:57:15 <mauke> well, what kind of help do you need?
05:57:15 <j-invariant> Elko: what do oyou want help with
05:57:45 <Elko> I like to know how to write the code for the function "insert"
05:57:59 <Elko> What values are required and so on
05:58:00 <mauke> I think a better start would be empty/lookup
05:58:10 <mauke> that's the core of the whole thing
05:58:20 <Elko> I'd start with "insert e u w ="
05:58:27 <Elko> But than... :(
05:58:30 <Elko> *then
05:58:41 <aristid> Elko: start with empty.
05:58:45 <mauke> or lookup
05:59:07 <Elko> I thought of a mapping function to store the values. Am I wrong?
05:59:19 <aristid> the type dictates that.
05:59:19 <Elko> aristid, mauke: Okay...
05:59:46 <Elko> So I have to use mapping... *grr*
06:00:00 <aristid> huh? it's pretty trivial
06:00:03 <mauke> every function is a "mapping" in some sense
06:00:17 <John___> Hi guys! Learning some Haskell here
06:00:43 <Elko> aristid: Nice that's trivial to you. To me it's not...
06:00:50 <aristid> Elko: let me help you with lookup. lookup s w = w s
06:01:02 <John___> Is it just me or does Haskell feel a lot like Ruby?
06:01:10 <Bynbo7> John___: for great good, or for fun?
06:01:24 <mauke> dunno, I don't know ruby :-)
06:01:28 <Bynbo7> John___: if by a lot like ruby you mean nothing at all like ruby, then yes :P
06:01:38 <pozic_> John___: You have function application in Ruby too, yes.
06:01:47 <John___> for fun right now.  But occasionally that turns into for great good
06:01:53 <pozic_> John___: otherwise the ideas are pretty much completely different.
06:02:23 <John___> oooh ok, Haskell is completely different from Ruby.
06:02:47 <aristid> Bynbo7: maybe he means at an emotional level ;)
06:02:58 <mauke> (=|¬∑√ó¬∑|=)
06:03:08 <pozic_> In Ruby you build a dynamic time bomb. In Haskell you build military grade control-software.
06:03:17 <comak> pozic_, 
06:03:21 <comak> sry
06:03:25 <aristid> Elko: do you understand why lookup works this way?
06:03:41 <Bynbo7> there are some ways in which ruby is like haskell, but i wouldn't say there's much where haskell is like ruby, if that makes sense
06:04:13 <Elko> aristid: Yes, got it.
06:04:20 <John___> ooh alright. I kind of said that after only doing a couple exercises, so I was in no position to say any of that
06:04:40 <aristid> Elko: now try to write the rest of the functions. :)
06:05:34 <exDM69> what would be the preferred haskell lib to do fixed size matrices, vectors and quaternions for 3d physics and graphics?
06:05:44 <j-invariant> not possible
06:05:45 <aristid> Elko: oh, and it does not need to be efficient or fast. it just has to work. in fact, there is no way to make it efficient.
06:06:11 <aristid> j-invariant: of course it's possible
06:06:24 <aristid> j-invariant: you just have to encode numbers peano style in the type system
06:07:07 <aavogt> exDM69: you're not using opengl?
06:07:28 <Elko> aristid: No there's no perfomance requirement or any like that. It just has to do it's job
06:07:52 <mauke> ... yes, that's what he said
06:08:01 <aristid> Elko: i'm just saying because i think you might be stuck thinking about hash tables or something like that.
06:08:07 <exDM69> aavogt: yes, but I still need plenty of 3d math on the CPU side
06:08:25 <exDM69> aavogt: in particular for the physics stuff
06:08:56 <exDM69> I want to prototype some neat numerical integration tricks based on the Runge-Kutta-Nystrˆm method
06:09:24 <exDM69> I've used it previously with C++ (which was a bit tricky) and Python (which was too slow to write clean code with)
06:09:54 <exDM69> the Python code would have required me to write some ugly code using numpy arrays, etc
06:11:05 <burp> exDM69: have a look at hmatrix
06:11:32 <exDM69> burp: I'll take a look. There were some other alternatives too
06:11:41 <exDM69> do you have a comment which one would suit 3d math the best?
06:12:04 <burp> well, hmatrix has fast matrix and vectors
06:12:23 <burp> based on GSL library
06:12:35 <burp> it also exports many of the GSL functions (integration, diff..)
06:12:42 <burp> http://hackage.haskell.org/package/hmatrix-0.10.0.1
06:12:45 <pozic_> exDM69: if you are prototyping you should care about making it work first.
06:12:59 <Egbert9e9> when getting an unsafe string
06:13:08 <Egbert9e9> like, from a web form
06:13:36 <Egbert9e9> ... it won't do anything, right?
06:13:41 <exDM69> pozic_: regarding the Python code? it was too slow to see the results in real time, so it was practically useless
06:14:10 <burp> python should be ok too with numpy
06:14:32 <burp> speed wise
06:14:34 <exDM69> numpy would probably have worked
06:15:01 <exDM69> but then my code would have gotten very ugly and I would have lost all the pros of doing the stuff in python
06:15:02 <pozic_> exDM69: I am talking about Haskell.
06:15:51 <exDM69> pozic_: yeah, I think haskell will be fast enough for real-time. but I'm looking for a library that would do some of the basic vector/matrix stuff easily, speed is a secondary issue
06:16:09 <Elko> aristid: Somehow if got no compilation errors :) that's nice :)
06:16:16 <pozic_> exDM69: that is soft real-time.
06:16:36 <aristid> Elko: what's your current code?
06:16:49 <exDM69> pozic_: yeah, soft real time. Not really going for real-time as in the RTOS sense.
06:17:13 <Elko> aristid: http://hpaste.org/paste/43067/dictionary_annotation#p43068
06:17:19 <pozic_> exDM69: you can pick the Vec library if you want a BSD license.
06:17:23 <exDM69> pozic_: I mean real-time in the sense that I can actually see the results of the physics simulation in real-time, ie. real world clock vs. physics sim clock
06:17:36 <pozic_> exDM69: hmatrix is GPL. 
06:17:37 <exDM69> pozic_: I don't care about licenses, as long as it's open source, it's fine
06:17:53 <pozic_> exDM69: then hmatrix is probably the fastest, but not the safest.
06:18:05 <aristid> Elko: why did you not use my lookup function?
06:18:14 <exDM69> hmatrix is more aimed at scientific stuff with big matrices, etc
06:18:32 <aristid> Elko: it's completely wrong. every single function.
06:18:35 <pozic_> exDM69: Vec contains statically sized matrices.
06:18:40 <Elko> aristid: :(
06:18:43 <exDM69> I would be fine just having 4x4 matrices, 4d vectors and quaternions, the stuff you usually use for 3d math
06:18:49 <j-invariant> you don't care about liscences as long as it's open source? LOL
06:18:54 <j-invariant> I don't care about color unless it's green
06:19:24 <pozic_> exDM69: I don't think that one has quaternions.
06:19:54 <pozic_> j-invariant: I thought it was a perfectly valid statement.
06:20:02 <exDM69> pozic_: yeah, I might have to write the whole vec/mat/quat stuff myself
06:20:07 <oklopol> well "I don't care about color unless it's green" is perfectly valid as well
06:20:08 <pozic_> Closed source only works with good contracts.
06:20:10 <oklopol> green is an exception
06:20:18 <Maxdamantus> @pl \f -> (* g . f)
06:20:19 <lambdabot> (*) . (g .)
06:20:54 <aristid> Elko: another hint: an empty Woerterbuch is a function that returns "nicht gefunden" for every single input.
06:21:10 <j-invariant> people mad in here 
06:21:23 <dankna> I tend to agree with j-invariant.
06:21:36 <dankna> open source only works with good lawyers, too.  they're just somebody else's.
06:23:15 <Elko> aristid: Ah, got it! My insertion function is crappy
06:23:21 <Elko> like u said ;)
06:23:51 <Elko> aristid: Updated: http://hpaste.org/paste/43067/dictionary_annotation#p43069
06:24:07 <killown> >test
06:24:14 <killown> @test
06:24:15 <lambdabot> Maybe you meant: let list tell
06:24:33 <aristid> Elko: good, lookup is correct and empty is almost correct now.
06:24:36 <pozic_> It is kind of a silly exercise considering that the same exercise was already in books written over 20 years ago.
06:25:06 <aristid> Elko: you don't need the error function there. it should just return the string "nicht gefunden", not an error value
06:25:26 <Elko> aristid: Okay, changed.
06:25:29 <pozic_> Elko: you just want to insert a string into a dictionary, right?
06:25:40 <mauke> also lookup and remove
06:25:51 <killown> @let list [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
06:25:51 <lambdabot>   TemplateHaskell is not enabled
06:25:52 <aristid> pozic_: the type of Woerterbuch is fixed to String -> String
06:26:15 <pozic_> aristid: so it is basically a key value pair which needs to be inserted, right?
06:26:21 <Elko> Yes
06:26:40 <pozic_> Are the types already given in the exercise?
06:26:46 <aristid> yes.
06:26:48 <Elko> Strings
06:27:00 <mauke> pozic_: http://mauke.dyndns.org/tmp/Blatt10.pdf
06:27:14 <aristid> mauke: 403
06:27:26 <mauke> the fu
06:27:32 <Elko> http://www.mediafire.com/?y4ec26zd7y37mb8
06:28:03 <mauke> aristid: try again
06:28:18 <Elko> mauke: valid
06:28:32 <aristid> mauke: i already downloaded it a while ago tho
06:29:14 <Elko> how do i put a string in this Woerterbuch?
06:29:58 <killown> @let [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
06:29:58 <lambdabot>   TemplateHaskell is not enabled
06:30:58 <aristid> Elko: insert should start like this: insert e u w s = ... or insert e u w = \s -> ...
06:31:20 <killown> >let [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
06:32:25 <Elko> aristid: what's the backslash for?
06:32:50 <aristid> Elko: a lambda function
06:33:01 <Elko> Euh...?!
06:33:15 <aristid> Elko: you can create anonymous functions this way.
06:33:30 <mauke> "lambda" and "anonymous" are fluff
06:33:37 <mauke> \ is how you write functions
06:34:10 <opqdonut> > (\x y -> x + y) 1 2
06:34:11 <lambdabot>   3
06:35:22 <Elko> Ha! Got it! :D
06:35:24 <ski> > (\n -> take n "abcdefgh") 3
06:35:25 <lambdabot>   "abc"
06:35:26 <Elko> *happy*
06:35:34 <ski> > map (\n -> take n "abcdefgh") [3,1,5,2,6]
06:35:35 <lambdabot>   ["abc","a","abcde","ab","abcdef"]
06:35:44 <aristid> Elko: yes? show it please :)
06:36:10 <Elko> http://hpaste.org/paste/43067/dictionary_annotation#p43070
06:37:13 <aristid> Elko: why does the new dictionary always return its input? :)
06:38:15 <Elko> aristid: Ah! 
06:38:41 <Elko> Because "\s -> u" is a function and a function has to "calculate" something.
06:38:53 <Elko> So Haskell is giving me the output
06:39:00 <Elko> Right?
06:39:02 <aristid> but not always the right one.
06:39:22 <aristid> it always gives you u, but you don't want that.
06:40:01 <Elko> But thast
06:40:03 <mauke> > let { empty w = "nicht gefunden"; lookup e w = w e; insert e u w = \s -> u } in lookup "Haus" (insert "Baum" "Rauch" empty)
06:40:03 <lambdabot>   "Rauch"
06:40:04 <Elko> wah...^^
06:40:05 <ski> `\s -> w' is the function (der  W√∂rterbuch) that given any word `s', ignores that word, and always gives back the word `u'
06:40:13 <mauke> das W√∂rterbuch
06:40:15 <ski> (er, `\s -> u', i mean)
06:40:32 <ski> (mauke : oh .. my mother thought it was masculinum)
06:40:46 <mauke> basically, my example should return "nicht gefunden"
06:40:57 <Elko> mauke: Yes. I see
06:41:02 <kuffaar> lol German
06:41:26 <mauke> Buch is neutrum (as is Wort)
06:42:25 <ski> Elko : are you sure you want to return the string `"nicht gefunden"' (which can easily be confused with a valid answer) in the `empty' case, instead of giving an error, or giving an "error code", which you can check for ?
06:42:38 <ski> (mauke : ty)
06:42:43 <aisamu> Hi! Why does "succ (maxBound) :: Int" gives a "tried to take succ of maxBound" and succ (maxBound) :: Char
06:42:51 <aisamu> gives a "bad argument"?
06:43:02 <ski> > succ maxBound :: Char
06:43:04 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
06:43:07 <ski> > succ maxBound :: Int
06:43:08 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:43:29 <pozic_> aisamu: probably because that is part of its specification
06:43:33 <ski> aisamu : dunno. apparently they didn't think of making the error messages in those two cases coherent
06:43:50 <mauke> ski: the interface is fixed by the exercise
06:43:58 <ski> ah, ok
06:44:11 <Elko> ski: i need a verification...
06:44:13 <pozic_> aisamu: oh, never mind; just coincidence, I suppose.
06:44:15 <ski> (only the types or the error behaviour as well ?)
06:44:51 <mauke> ski: it defines the empty dictionary as one that always returns "nicht gefunden"
06:44:56 <aisamu> pozic_, ski: oh, thanks!
06:45:15 <Elko> but how do i do that? i can't check against something which is not even there
06:45:25 <Elko> i cant check "Haus" against "house"
06:45:47 <mauke> hmmwhat?
06:45:52 <mauke> why not?
06:46:03 <Elko> I could
06:46:18 <Elko> but it would make no sense, because my function would have to translate it
06:46:27 <ski> hehe
06:46:34 <Elko> so if i'm putting "rauch" in 
06:46:43 <aristid> insert e u ...
06:46:45 <aristid> you have e
06:46:45 <Elko> my dictionary had to check against smoke
06:46:47 <aristid> you have u
06:46:48 <mauke> wait, what
06:46:53 <aristid> and you have the old dictionary
06:47:00 <aristid> what more do you need?!
06:47:03 <mauke> s
06:47:09 <ski> Elko : your `insert' is creating a new word book (a function), which *when* given any input word, will check how to translate that
06:48:19 <Elko> in my code never, ski. 
06:48:26 <Elko> i have no if-clause
06:48:34 <Elko> *wahh. brainfuck
06:48:37 <mauke> heh
06:48:38 <ski> maybe you want one ?
06:48:48 <Elko> yes, sure i need one
06:48:55 <aristid> add it, then.
06:48:57 <mauke> I don't know if you've realized it, but your "dictionary" is its own lookup function
06:49:05 <pozic_> It is something like this, right? insert key value dict = \query -> if key == query then value else dict query
06:49:16 <ski> so, if you call `insert "smoke" "rauch" wordBook', you want a word book function that when given `"smoke"' gives `"rauch"', if i understand you correctly
06:49:36 <Elko> Yes
06:49:41 <Elko> That's right
06:49:59 <ski> but the resulting word book function could be given other words as well, such as `"house"'
06:50:15 <ski> and you need to tell what german word it should translate that to, in such cases
06:50:21 <mauke> `...' looks terrible
06:50:27 * ski bows
06:50:31 <mauke> at least use ‚Äò...‚Äô
06:51:05 <mauke> or ‚Äö...‚Äô :-)
06:51:24 * ski is sitting in a virtual console without X / UTF, atm ..
06:51:45 <aristid> or ‚Ä¶
06:51:53 <Elko> "then" cant be parsed
06:52:00 <aristid> ski: huh? good consoles all have utf-8 :P
06:52:03 <mauke> „Äå‚Ä¶„Äç
06:53:58 <Bynbo7> mauke: took me a while to figure out what those were for while here in tokyo :)
06:54:24 <mauke> they're for quoting code!
06:56:05 <ski> Elko : hm ?
06:56:54 <michie1> hmm, a quick check to see if I'm understanding things correctly, the reason that Maybe is a Monad, and not merely an Applicative, is to allow early termination, right?
06:57:10 <michie1> an Applicative Maybe would be doomed to pass around Nothings unnecessarily
06:57:20 <michie1> (a solely Applicative Maybe, of course)
06:57:59 <Bynbo7> michie1: the reason it is a monad is because you can implement the Monad class on it, that's about it. you still get failure from the Applicative instance
06:58:50 <michie1> Bynbo7: hmm, okay.  So it's more a matter of 'We didn't have Applicative when we wrote the standard library'?
06:59:07 <ski> > pure (+) <*> Nothing <*> Just 3
06:59:09 <lambdabot>   Nothing
06:59:11 <Bynbo7> well, it's extremely useful to have it as a monad
06:59:18 <ski> > pure (+) <*> Just 2 <*> Nothing
06:59:19 <lambdabot>   Nothing
06:59:21 <ski> > pure (+) <*> Just 2 <*> Just 3
06:59:23 <lambdabot>   Just 5
06:59:29 <ski> > pure (+) <*> Nothing <*> undefined
06:59:30 <lambdabot>   Nothing
06:59:36 <ski> > pure (+) <*> undefined <*> Nothing
06:59:37 <Elko> Got it
06:59:37 <lambdabot>   *Exception: Prelude.undefined
06:59:38 <Elko> :)
06:59:39 <michie1> ski: ah, that makes sense
06:59:49 <ski> effectively, it's defined as
06:59:54 <michie1> ski: thanks, it really helps me to see it like that.
07:00:04 <ski>   Nothing <*> _       = Nothing
07:00:14 <ski>   Just _  <*> Nothing = Nothing
07:00:22 <ski>   Just f <*> Just x  = Just (f x)
07:00:36 <Elko> let { empty w = "nicht gefunden"; lookup e w = w e; insert e u w = \query -> if e == query then u else w query} in lookup "Haus" (insert "Baum" "Rauch" empty)
07:00:49 <Elko> :(
07:00:51 <mauke> Elko: "> "
07:00:59 <parcs> or rather, Just f <*> Just x = Just (f x); _ <*> _ = Nothing
07:00:59 <Elko> > let { empty w = "nicht gefunden"; lookup e w = w e; insert e u w = \query -> if e == query then u else w query} in lookup "Haus" (insert "Baum" "Rauch" empty)
07:01:00 <lambdabot>   "nicht gefunden"
07:01:10 <ski> michie1 : so first the left argument is checked, if it's `Nothing' you get `Nothing' immediately (even if the other hangs or is an error)
07:01:11 <Elko> > let { empty w = "nicht gefunden"; lookup e w = w e; insert e u w = \query -> if e == query then u else w query} in lookup "Haus" (insert "Haus" "house" empty)
07:01:12 <lambdabot>   "house"
07:01:20 * Elko is happy
07:02:01 <michie1> ski: yeah, it makes sense now.
07:02:51 <ski> > let { empty w = "nicht gefunden"; lookup e w = w e; insert e u 4w = \query -> if e == query then u else w query} in lookup "Rauch" (insert "Haus" "house" empty)
07:02:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:02:52 <lambdabot>         against inferred ty...
07:03:01 <ski> > let { empty w = "nicht gefunden"; lookup e w = w e; insert e u w = \query -> if e == query then u else w query} in lookup "Rauch" (insert "Haus" "house" empty)
07:03:02 <lambdabot>   "nicht gefunden"
07:03:09 * ski nods
07:03:39 <kuffaar> So I  want to write a module which I can reuse to achieve synchronised access to the console through an MVar lock or something like that. I make a new monad which derives from Reader for that, right? And it's an MVar () and then I make something like lockedPrint :: String -> ConsoleLock IO () and it retrieves the MVar () through ask from the Reader monad and locks stuff before it calls putStr or putStrLn?
07:04:06 <mauke> that would work
07:04:38 <dankna> last night they were saying to use a Chan instead of an MVar, but either will work
07:05:12 <mauke> hmm, a Chan would allow nonblocking access
07:05:43 <dankna> yeah the more I think about it the more I'm convinced it's a nicer solution.  because it lets the thread that generated the message get on with its business without waiting.
07:06:14 <mauke> I'm not sure if that's good or bad
07:06:38 <dankna> the only way I see it could be bad is if the worker threads get too far ahead and there's an impossible queue of messages to be written out
07:07:04 <dankna> anyway the basic strategy for passing it around in a monad is the same either way
07:07:34 <dankna> let me correct a misconception - what you probably want to do is not actually derive from Reader but rather do something like
07:07:44 <dankna> data ConsoleLockState = ...
07:07:45 <dankna> and then
07:07:51 <dankna> type ConsoleLock = ReaderT ConsoleLockState
07:08:08 <kuffaar> Oh
07:08:15 <dankna> the second line just defines a shorthand that lets you write "ConsoleLock IO ()" instead of "ReaderT ConsoleLock IO ()"
07:08:18 <Elko> How do i realize the remove function?
07:08:25 <dankna> was that a point of confusion for you?  good
07:08:50 <kuffaar> dankna: You mean ReaderT ConsoleLockState IO (), no?
07:08:54 <dankna> yes, I do
07:09:11 <Bynbo7> Elko: if i were you, i'd return "" for empty, it will make writing remove a lot nicer
07:09:28 <ski> Elko : if you remove a word association, do you want the resulting word book function to map the removed word to `"nicht gefunden"' ?
07:10:00 <Elko> Bynbo7: but i cant do it like that
07:10:01 <ski> or maybe to the word it was associated with before the last `insert' for that word (if any) ?
07:10:07 <Elko> ski: Yes
07:10:10 <ski> which ? :)
07:10:15 <Bynbo7> Elko: why not?
07:10:49 <ski> Bynbo7 : afiui, the excercise/laboration specifies it should say `"nicht gefunden"'
07:10:53 <Egbert9e9> is forever IO bottom?
07:10:56 <Elko> ski: Both should be removed. The original and the translated word
07:11:07 <Bynbo7> ski: good enough for me, ta
07:11:17 <Elko> Bynbo7: Because empty has to be "nicht gefunden" in its intial state
07:11:25 <ski> Egbert9e9 : sorry ?
07:11:46 <ski> Elko : ok .. then i think `remove' will not be that different from `insert'
07:11:57 <ski> @hoogle forever
07:11:58 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
07:12:51 <Egbert9e9> let forever a = do a; forever a
07:12:56 <Egbert9e9> > let forever a = do a; forever a
07:12:57 <lambdabot>   not an expression: `let forever a = do a; forever a'
07:12:59 <Egbert9e9> err
07:13:04 <Egbert9e9> forever a = do a; forever a
07:13:12 <Egbert9e9> > forever a = do a; forever a
07:13:13 <lambdabot>   <no location info>: parse error on input `='
07:13:19 <Egbert9e9> err
07:14:53 <Egbert9e9> nvm
07:15:13 <ski> @type let forever ma = do ma; forever ma in forever
07:15:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
07:16:49 <Egbert9e9> i mean, i get to see IO () in some type signatures and someone said the type () can be either a zero length tuple or bottom for endless recursion
07:17:04 <ski> > execWriter (forever (tell "a" >> return 2) :: Writer String Double)
07:17:05 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:17:26 <ski> Egbert9e9 : `()' is always the zero length tuple
07:17:38 <Egbert9e9> what about the type '()'?
07:17:51 <ski> then it's a fact that expressions of *any* type can always happen to be endless recursion
07:17:59 <ski> including the type `()', of course
07:18:05 <Egbert9e9> oh hm
07:18:09 <ski> > let foo :: (); foo = foo in foo
07:18:14 <lambdabot>   mueval-core: Time limit exceeded
07:18:15 <ski> > let foo :: Int; foo = foo in foo
07:18:18 <lambdabot>   mueval-core: Time limit exceeded
07:18:22 <Egbert9e9> i see
07:18:27 <ski> > let foo :: a; foo = foo in foo
07:18:32 <lambdabot>   mueval-core: Time limit exceeded
07:18:38 <Egbert9e9> so how do you denote bottoms?
07:18:44 <ski> if one wanted another typing for `forever' it could be
07:18:58 <ski>   forever :: Monad m => m a -> m Void
07:19:11 <ski> where `Void' is the type which has no actual/concrete values
07:19:13 <Elko> Why does "remove" do not work? http://hpaste.org/paste/43067/dictionary_annotation#p43073
07:19:41 <ski> so an expression of type `Void' *always* hangs (or errors out, which is counted the same, in these circumstances)
07:19:53 <ion> > let foo :: StdGen; foo = mkStdGen (2^31) in foo -- ;-)
07:19:57 <lambdabot>   mueval-core: Time limit exceeded
07:20:21 <ski> Egbert9e9 : e.g. `Bool' is a type which can be any of two *alternatives* .. and `Void' is a type which can be any of *zero* alternatives
07:20:43 <ski> (note how having `n' alternatives is different from having `n' components in a tuple)
07:21:44 <ski> Elko : what does "do not work" mean ?
07:21:45 <Elko> Am I wrong does my dictionary just excists when i'm executing "lookup "Haus" (insert "Haus" "house" empty="
07:21:47 <Elko> *)
07:22:05 <Elko> ski: There are parsing erros
07:22:06 <Elko> *r
07:22:47 <ski> do you mean the ones hpaste shows below the paste ?
07:23:29 <ski> i'd say ignore those .. those are really just style checks (i'm not sure why they are named "Error"s, there)
07:24:21 <kuffaar> HaskeŒªŒª
07:24:56 <pacak> What is the proper way of constructing/deconstructing of binary objects? Let's suppose i want to parse/build DHCP packets.
07:25:09 <Elko> ski: No, no... GHCi is nagging around
07:25:26 <ski> what is the error message ?
07:26:30 <Elko> ski: couldn't match type "String -> String" [Char] expected
07:26:52 <Elko> which makes absolutly no sense
07:26:59 <Elko> because there are no characters
07:28:37 <Bynbo7> pacak: there's a few different way. the simplest is using the Binary package. that may be all you need for DHCP packets. there's also parser libraries like attoparsec which are excellent for such things too (and things much more complex than that too)
07:30:05 <ski> Elko : hm
07:30:18 <ski> the type `[Char]' is the same as `String'
07:30:26 <pacak> Bynbo7: My current implementation uses attoparsec for deconstructing. What can i use to construct packets back?
07:30:46 <Egbert9e9> ski, i appreciate your help
07:30:51 <Bynbo7> Binary, cereal, blaze-builder possibly 
07:31:10 <Egbert9e9> ski, sadly, i'm not cool enough for your explanations
07:31:14 <Bynbo7> (though binary's Put monad will hopefully soon be replaced by the blaze-builder code)
07:31:59 <pacak> Bynbo7: Thank you, i'll check those packages.
07:32:07 <ski> Elko : which line in the paste is the error referring to ?
07:32:26 <Bynbo7> pacak: all three of these are basically the same when it comes to producing bytestrings. blaze-builder is the fastest at the moment. i'd recommend using Binary though, because you'll get those speedups in the future
07:32:36 <Elko> ski: 16
07:33:02 <Bynbo7> and it's not like you're going to be doing anything where you'll need to worry about this speed anyway, DHCP packets are very small right?
07:33:22 <ski> Egbert9e9 : anyway, if you'd want another type for `forever' than `Monad m => m a -> m b', it could be `Monad m => m a -> m Void' .. you can read the `Void' there roughly as "never returns (normally)" .. (though that's not the full picture)
07:34:01 <pacak> Bynbo7: less than 1500 in any case :)
07:34:05 <Egbert9e9> i see
07:34:13 <Bynbo7> yeah, use binary. it comes with ghc anyway
07:34:50 <ski> Egbert9e9 : you could compare this with `forM_ :: Monad m => [a] -> (a -> IO b) -> IO ()' .. an alternative type for that could be `Monad m => [a] -> (a -> m ()) -> m ()'
07:35:28 <ski> Egbert9e9 : so, occuring in the result type, `()', can be read as "uninteresting/trivial result"
07:35:51 <ski> (Egbert9e9 : while `Void' will be read as "there will never be a result (it doesn't return)")
07:36:02 <Elko> ski: Can you have a look at this: http://hpaste.org/paste/43067/dictionary_annotation#p43074 ??
07:36:29 <ski> Egbert9e9 : btw, note that `Void' isn't really used very much .. i'm just mentioning this because you asked about `forever', where it *could* sensibly be used
07:36:40 <ski> Elko : yes
07:37:21 <ski> hm, i don't think that's what you want, anyway
07:37:53 <Egbert9e9> hmmm so using void will make most programs not work?
07:37:54 <ski> if `e == query' is `True', then `w e' is the same as `w query', so you're returning the same thing in both branches
07:38:08 <Elko> Not good
07:38:13 <Egbert9e9> defining the IO () functions as IO Void
07:38:45 <ski> Egbert9e9 : i'm just saying that `Void' is seldom the thing you want (but imho, when it is the thing you want, it can be useful)
07:39:38 <ski> Elko : i'm still not sure why you got an error in the earlier paste, though .. (btw, you're sure you don't have any tab characters in your file, yes ?)
07:40:16 <Egbert9e9> oh my god. i've just googled for something and came across potential-lang.org
07:40:30 <ski> Egbert9e9 : as an example, i used a `kill :: SystemM Void' for an action that killed the current thread .. since the thread is killed, the action doesn't return a value, so here i thought `Void' was appropriate
07:41:06 <ski> (Egbert9e9 : in fact, i initially used `()', but i had bugs which were hard to find .. changing to `Void' helped me hunt down the bugs)
07:41:21 <Egbert9e9> how can it help?
07:41:55 <Elko> ski: I've deleted the tabulator inputs. Do they have any effect? 
07:42:02 <Egbert9e9> what happened inside your code?
07:43:28 <ski> Elko : the short story is : don't use tabs in Haskell source. the longer version is that if you use them, you need to be careful, typically you *only* indent with tabs (*and* break the line after every `let',`do',`where' and all the other layout-introducing keywords)
07:43:58 <ski> Egbert9e9 : i had mixed up things so that the code simply hang itself .. that's a bit hard to debug
07:45:31 <Elko> ski: okay thx
07:46:11 <Egbert9e9> http://www.haskellassemblyofgod.com/
07:46:31 <jonkri> what does "s <- get" do?
07:46:51 <Elko> My remove function doesnt work. I think it's because the dicitionary is just "produced" for the "insert" function. So it saved nowhere
07:46:55 <sipa> jonkri: syntactic sugar for (get >>= \s -> ...)
07:46:58 <j-invariant> If you don't beleive in caetgory theory you will be eater by sabre toothed tigers
07:47:05 <alpounet> jonkri, it's in the state monad
07:47:10 <alpounet> it gives you the current state
07:47:54 <Egbert9e9> j-invariant, but sabre tooths went extinct thousands of years ago
07:50:38 <ion> jonkri: I wrote an article about the State monad which may or may not be helpful (hopefully the former). http://heh.fi/state-monad
07:50:51 <aisamu> Hello again! When you type `336 :: GHC.Word.Word8` you get `80`. I'm trying to find where this wrapping is defined, but I could only get to narrow8Word# :: Word# -> Word# narrow8Word# = let x = x in x (in GHC.Prim) ‚Ä¶ What am I missing/where else should I search?
07:51:10 <alpounet> ion, that's a nice idea, I already gave the link to some haskell beginners I know :)
07:51:22 <alpounet> i've already given*
07:52:36 <ion> aisamu: I‚Äôd guess ‚Äòinstance Num Word8 where fromInteger = ‚Ä¶‚Äô is defined somewhere.
07:52:37 <ski> Elko : if you produce a new dictionary with `insert', then if you don't use that, it's as if you never called `insert', right
07:52:55 <jonkri> thanks
07:52:58 <Elko> ski: yes
07:53:03 <Elko> ski: but i used it
07:53:08 <Elko> ski: so it's there?
07:53:28 <Elko> ski: and "empty" isnt any longer empty?
07:53:37 <ion> aisamu: Any integer literal in Haskell code stands for ‚ÄòfromInteger x‚Äô where x is the equivalent numeric value of type Integer. ‚ÄòfromInteger‚Äô is then defined for all types integers can be converted to.
07:54:15 <Bynbo7> aisamu: not all haskell is written in haskell. there are primitives that aren't haskell
07:54:54 <Bynbo7> so narrowWord8# likely has a real implementation elsewhere
07:55:02 <ion> Yeah, things in the GHC namespace may be somewhat more likely to fall into that category.
07:56:53 <ski> Elko : i can't tell easily, if i don't see the code where you use it ..
07:57:12 <mauke> Elko: empty is still empty, but you can't "unwrap" a dictionary to see if it's empty or anything else
07:58:02 <aisamu> Bynbo7: hm, ok! Is a function that ends with '#' always implemented elsewhere?
07:58:14 <Elko> ski: I try myself. Maybe i solve it. ;)
07:58:25 <Elko> mauke: alright :) thx for the hint
07:58:38 <ski> (heh, if `wordboook undefined' terminates, then `wordbook' was empty .. otherwise it doesn't terminate)
07:58:52 <ski> (normally)
07:59:29 <mauke> the trick is that remove doesn't actually remove anything
07:59:31 <aisamu> ion: Thanks! In fact, I got to narrow8Word# through the fromInteger implementation!
08:01:07 <aisamu> ion: fromInteger i = W8# (narrow8Word# (integerToWord i)), (in GHC.Word)
08:06:56 <aristid> Elko: remove e w is equivalent to insert e "nicht gefunden" w, btw
08:07:38 <aisamu> ion: and going down integerToWord i got to int2Word# = let x = x in x also...
08:09:20 <aisamu> Bynbo7, ion: thank you!
08:29:31 <Blkt> good evening people
08:29:56 <silver> hello
08:30:25 <Phyx-> hello
08:52:55 <Elko> mauke: Why is this the case that remove does not actually remove anything?
08:53:21 <Elko> aristid: So I can just exchange this?
08:53:59 <mauke> Elko: because you can't look inside of functions
08:54:32 <Elko> so remove is sensless in any way?
09:00:04 <mauke> hmm? no
09:00:40 <mauke> the point of remove is not to actually remove anything, it's to make lookup return "nicht gefunden"
09:03:34 <Filosofem> Hello, can anyone help me with Haskell? (binary tree related)
09:03:43 <Elko> Now i understand what aristid meant
09:03:47 <Elko> thanks, mauke
09:04:22 <Bynbo7> Filosofem: not if you don't tell us what your problem is ;)
09:05:22 <Filosofem> ok, this must be basic (for you) but I just started learning haskell and im having problems with this
09:05:42 <Elko> me too, don't worry. you'll get help :)
09:06:11 <Filosofem> first, I have a new data type defined
09:06:24 <Filosofem> its a binary tree that represents a quiz
09:06:41 <Filosofem> all the answers are yes/no (True,False if we are talking about Bools)
09:07:16 <Filosofem> if the answer is Yes, we go to the left branch of the tree
09:07:28 <Filosofem> if the answer is No, we go to the right branch of the tree
09:07:59 <Filosofem> so, what I need to do is to write a funcion that calculates the number (int) of possible results
09:08:49 <Filosofem> I already have a function that given a [Bool] gives me the result
09:09:07 <Bynbo7> Filosofem: isn't it just 2^n, where n is the number of questions?
09:09:26 <Bynbo7> or do you need to calculate it from the tree?
09:09:33 <Filosofem> y, i need to calculate them
09:09:37 <Filosofem> because the results can be the same
09:09:39 <Bynbo7> ok
09:09:40 <kuffaar> http://siyobik.info/pastebin_download.php?id=567 <- trying to write the module to offer synchronised access to the console, but I'm Doing It Wrong (TM): Couldn't match expected type `ReaderT LockedConsoleState IO a'
09:09:40 <kuffaar>  with actual type `IO a1'
09:10:04 <Bynbo7> can you paste the definition of your tree structure? (data Tree ...)
09:10:07 <Filosofem> y, sure
09:10:16 <mauke> kuffaar: 'let ... in do ...' better written as 'let ...; ...'
09:10:40 <Filosofem> let me just translate somes words, to easier understanding
09:10:49 <mauke> kuffaar: lock <- asks consoleLock  -- anyway
09:11:03 <kuffaar> Oh yeah I forgot about that one
09:11:10 <mauke> kuffaar: remove 'return $'
09:11:32 <Filosofem> data Quiz a = Result a | Question String (Quiz a) (Quiz a)
09:12:08 <Bynbo7> Filosofem: so, you need to count all Result's right?
09:12:33 <kuffaar> mauke: Alright, I did: http://siyobik.info/pastebin_download.php?id=567 still Doing It Wrong though
09:12:41 <Filosofem> y, but if we have the same result twice
09:12:48 <Filosofem> it only counts +1
09:13:00 <Bynbo7> ah
09:13:01 <Bynbo7> ok
09:13:24 <mauke> kuffaar: liftIO $ do takeMVar lock; putStr string; putMVar lock ()
09:13:29 <Bynbo7> ok, the i suggest you first write a function which can return all the a's in the Results
09:13:44 <drichards> I have what I am sure is a FAQ: I am a cometent programmer; I've used many languages for many years.  If I wish to purchase only one book to become a competent Haskell programmer, which would it be?
09:13:47 <Filosofem> i have that already
09:13:48 <Filosofem> 1 sec
09:13:55 <j-invariant> drichards: that's absurd
09:14:13 <mauke> drichards: why buy anything?
09:15:08 <winxordie> drichards: You should buy http://book.realworldhaskell.org/read/ for $0
09:15:21 <Bynbo7> drichards: i wouldn't buy a book just yet, start with LYAH. it looks like it's for kids, but it is the best way to get started with haskell. if you've never used a functional language, i very strongly recommend you start there. if you feel it's below you, start out with Real World Haskell
09:15:40 <winxordie> alternatively, you could buy the actual book with the same content for actualy money on amazon or so
09:15:40 <alpounet> drichards, I'd say read RWH
09:15:46 <Filosofem> can i take a prin screen and then send you the link? (to imgshack or something) ?
09:15:48 <kuffaar> mauke: Oh, so it's two do's then?
09:16:08 <kuffaar> Cheers, it compiled!
09:16:15 <Bynbo7> Filosofem: ok, well what you next need to so is find all the unique elements in that list right?
09:16:39 <Filosofem> y
09:16:40 <Bynbo7> @where rwh
09:16:40 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:16:48 <Bynbo7> drichards: ^^^^^^^^^^^^^^
09:16:48 <Filosofem> for instance, it gives me the result 4
09:16:51 <Filosofem> and it would be 2
09:17:06 <Filosofem> for the eg. i have right now
09:17:07 <joe6> is the re a haskell source code beautifier?
09:17:08 <Bynbo7> Filosofem: is that because some results are the same?
09:17:13 <Filosofem> y
09:17:18 <joe6> s/the re/there/
09:17:25 <Filosofem> the results are "Aproved" and "Not Aproved"
09:17:39 <drichards> Ok, thanks.  Real world it is.  Amazon had commentary that worried me.
09:17:55 <Bynbo7> drichards: you can read it for free online
09:17:57 <drichards> btw, attacking a questioner isn't such good style
09:18:06 <kuffaar> Approved*
09:18:13 <Bynbo7> drichards: who attacked you? :\
09:18:39 <winxordie> style's a lazy attribute 'round these parts
09:18:42 <drichards> unlike most people, I can't easier read content online
09:18:42 <Bynbo7> i think we were a little put off by your assumpting that you needed to buy something to become good at haskell, which isn't true
09:18:49 <drichards> books are more accessible to me
09:19:00 <Bynbo7> drichards: that's fine :)
09:19:53 <Filosofem> Bynbo, here is 1 print of my situation http://img220.imageshack.us/i/etworesults.png/
09:20:02 <Filosofem> my function gives the result "4"
09:20:04 <Filosofem> and it should be 2
09:20:17 <Filosofem> my function gives the result "5" *
09:20:32 <kuffaar> :t liftIO
09:20:33 <lambdabot>     Ambiguous occurrence `liftIO'
09:20:33 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
09:20:33 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
09:20:33 <Bynbo7> well, like i said, you need to write a function to remove duplicates from a list
09:20:46 <kuffaar> :t Control.Monad.Logic.liftIO
09:20:47 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
09:20:58 <joe6> is there a haskell source code beautifier that is commonly used?
09:21:11 <Bynbo7> joe6: none that i know of
09:21:16 <Bynbo7> joe6: people
09:21:21 <joe6> it just does not make sense for the developer to be doing all the beautifications..
09:21:27 <parcs> hlint could be considered a "beautifier"
09:21:36 <kuffaar> mauke ah and m is inferred to ReaderT LockedConsoleState IO in this case?
09:21:39 <Bynbo7> people's styles vary quite a lot, it's not a piece of software that will be useful to that many people really
09:21:54 <joe6> not for formatting.
09:21:58 <Filosofem> ok, I think that if I convert the tree to a list it would be easier, thanks
09:22:24 <Elko> Bynbo7, mauke, aristid, j-invariant: Thank you for your help today! :) You really help me to understand Haskell a little more. 
09:22:47 <Elko> And ski as well, thank you! :)
09:23:16 <Bynbo7> no sorries
09:24:28 <kuffaar> So a stack of monads bascially works like A B C D a where each one of them takes the next one as its argument?
09:24:31 <Bynbo7> uh, worries even
09:24:41 <kuffaar> It's basically A (B (C (D a))))?
09:25:11 <parcs> kuffaar: no, it's ((((A B) C) D) a)
09:25:21 <parcs> just like function applicative
09:25:26 <parcs> tion*
09:25:39 <j-invariant> A B C D a is wrong
09:26:02 <j-invariant> also I don't think a monad transformer is like M (N a)
09:26:07 <j-invariant> it combines them in a different way
09:26:50 <j-invariant> perhaps N = NA NB and M = MA MB, then the transformer might produce MA (NA (NB (MB a)))
09:27:22 <ski> kuffaar : a monad transformer stack is like `t0 (t1 (t2 m)) a'
09:27:30 <kuffaar> Oh snap
09:27:40 <ski> `t0',`t1',`t2' being monad transformers, `m' being a monad, and `a' being the result type
09:28:48 <ski> e.g. `StateT [(Int,Int)] (ContT Bool (WriterT String IO)) ()'
09:28:54 <ski> @unmtl StateT [(Int,Int)] (ContT Bool (WriterT String IO)) ()
09:28:55 <lambdabot> [(Int, Int)] -> (() -> [(Int, Int)] -> IO (Bool, String)) -> IO (Bool, String)
09:29:20 <ski> `State [(Int,Int)]', `ContT Bool', `WriterT String' are monad transformers
09:29:23 <ski> `IO' is a monad
09:30:01 <ski> (so `WriterT String IO' is also a monad, as is `ContT Bool (WriterT String IO), and `StateT [(Int,Int)] (ContT Bool (WriterT String IO))')
09:30:08 <ski> and the result type is `()'
09:30:37 <kuffaar> Hm alright
09:37:02 <Elko> Thanks again and byebye, guys! :)
09:38:45 <ski> kuffaar : were you wondering about any particular monad transformer stack ?
09:39:01 <kuffaar> No, just in general
09:39:03 <ski> ok
09:39:17 <ski> note that while `Maybe' is a monad, `State' isn't
09:39:20 <kuffaar> And I am still not sure how to create the MVar now and to pass it on in the monadic stack in the code which uses this
09:39:31 <ski> otoh, *`State s'* is a monad, for any type `s'
09:39:39 <kuffaar> http://siyobik.info/pastebin_download.php?id=567
09:39:55 <ski> similarly `StateT' is not a monad transformer, but `StateT s' is one, for any type `s'
09:39:58 <kuffaar> ski * -> * -> * vs. * -> *?
09:40:06 <Bynbo7> what did rnf become in the latest Control.Concurrent.Strategies?
09:40:10 <ski> yeah, every monad must have kind `* -> *'
09:40:37 <ski> and every monad transformer must have kind `(* -> *) -> (* -> *)' (transforming any monad into a new monad)
09:40:40 <ski> @kind Maybe
09:40:42 <lambdabot> * -> *
09:40:43 <ski> @kind State
09:40:44 <lambdabot> * -> * -> *
09:40:54 <ski> @kind State Int
09:40:55 <lambdabot> * -> *
09:40:59 <ski> @kind StateT
09:41:00 <lambdabot> * -> (* -> *) -> * -> *
09:41:02 <ski> @kind StateT Int
09:41:03 <lambdabot> (* -> *) -> * -> *
09:41:34 * hackagebot sbv 0.9.1 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.1 (LeventErkok)
09:42:11 <monochrom> rnf is in Control.DeepSeq or Control.Parallel.Strategies
09:42:34 <monochrom> packages are deeseq and parallel respectively
09:42:54 <ski> ok, your
09:42:57 <ski>   lockedPrint :: String -> LockedConsole IO ()
09:43:02 <ski> is shorthand for
09:43:22 <kuffaar> ReaderT LockedConsoleState IO ()
09:43:25 <ski>   lockedPrint :: String -> ReaderT LockedConsoleState IO ()
09:43:31 <kuffaar> Right
09:43:34 <monochrom> ah, parallel's rnf is just re-exporting deepseq's rnf
09:43:35 <ski> which is (currently) isomorphic to
09:43:43 <ski>   lockedPrint :: String -> ReaderT (MVar ()) IO ()
09:43:46 <Bynbo7> thanks monochrom 
09:44:13 <Bynbo7> monochrom: in my ghc7, Control.Parallel.Strategies doesn't export rnf
09:44:25 <ski> so you have `IO' at the "bottom" of the monad transformer stack, and only one monad transformer (`ReaderT (MVar ())' i.e. `LockedConsole') over that
09:45:14 <kuffaar> ski: But when do I actually use newMVar  and how do I start passing this around?
09:46:13 <ski> you'd do `newMVar' when running any `LockedConsole IO a' from `IO'
09:46:24 <ski> e.g. you could define an
09:46:48 <ski>   runLockedConsole :: LockedConsole IO a -> IO a
09:46:58 <ski> or, maybe you want to generalize to
09:47:01 <dankna> :t runReaderT
09:47:02 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
09:47:08 <ski>   runLockedConsole :: MonadIO m => LockedConsole m a -> m a
09:47:28 <ski> `runLockedConsole' would just be a short handy wrapper
09:48:39 <ski> so i suppose maybe
09:48:40 <dankna> runLockedConsole action = do { mVar <- liftIO $ newMVar ; runReaderT mVar action }
09:48:43 <dankna> something like that
09:48:49 <ski> yeah, what dankna said
09:49:36 <ski> (if you only need `IO' rather than any `m' such that `MonadIO m', then you can replace `liftIO $ newMVar' with just `newMVar')
09:49:45 <ski> (oh, and you need `newMVar ()', of course)
09:49:48 <kuffaar> I see, and then I wrap everything in it like with withSocketsDo?
09:50:24 <ski> yeah, when you want to call a `LockedConsole' action from `IO' (or any `m' s.t. `MonadIO'), you call this
09:50:33 <ski> btw, note that each such call will create a new `MVar ()'
09:50:36 * hackagebot texmath 0.5.0.1 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.5.0.1 (JohnMacFarlane)
09:50:47 <ski> so, presumably you only want to do this once
09:51:12 <ski> or, maybe you don't want `runLockedConsole' to create a new `MVar ()', but instead use one which is passed as an argument
09:51:21 <ski> kuffaar : it all depends on what you want to do
09:52:18 <joe6> "scan" is pretty good for formatting
09:52:27 <ski> @hoogle scan
09:52:28 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
09:52:28 <lambdabot> Data.ByteString scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
09:52:28 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
09:52:28 <joe6> haskell beautifying, I mean
09:52:45 <joe6> scan module, not the function
10:07:31 <Filosofem> how can I remove duplicates from a list? I have something writen already, but it only removes the duplicates if they are together like ["a","a","b"]
10:07:44 <Filosofem> but if i have ["a","b","a"] it wont work
10:07:49 <kmc> Filosofem, convert it to Data.Set and back
10:08:02 <kmc> that will be more efficient (for large lists) than anything small hand-rolled solution
10:08:36 <Bynbo7> kmc: it would be nice for him to figure out how to implement something like this (coming up with the implementation of nub by hand)
10:10:04 <kmc> fair enough
10:11:37 <kmc> i don't have great advice about that
10:12:13 <jmcarthur> > nub ["a", "b", "a"]
10:12:14 <lambdabot>   ["a","b"]
10:12:42 * hackagebot hoogle 4.1.5 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.1.5 (NeilMitchell)
10:13:20 <Filosofem> yeah, I got nub to work
10:13:43 <Filosofem> but its like Bynbo says
10:13:49 <Filosofem> its not "my work"
10:14:27 <kuffaar> <dankna> runLockedConsole action = do { mVar <- liftIO $ newMVar ; runReaderT mVar action }
10:14:44 <kuffaar> dankna ski: That doesn't work for me :'(
10:15:02 <kuffaar> Couldn't match expected type `IO a' with actual type `a1 -> IO (MVar a1)'
10:15:23 <dankna> oh, that means something is missing a parameter, heh
10:15:35 <dankna> what line is the error on?
10:15:40 <mauke> newMVar ()
10:15:49 <kuffaar> Ahhh of course
10:15:57 <dankna> oh, of course
10:16:28 <kuffaar> Couldn't match expected type `ReaderT r m a' with actual type `MVar ()'
10:17:04 <dankna> in general the important part of a Haskell error message is the description of where in the source it is
10:17:08 <dankna> not the actual text of the error
10:17:18 <dankna> it may be useful to hpaste the full context of what the compiler is telling you
10:17:20 <kuffaar> On the runReaderT part
10:17:24 <kuffaar> Ok
10:17:49 <dankna> oh
10:17:51 <dankna> but I think I know
10:17:55 <dankna> I think the arguments are backwards?  hmm
10:17:58 <dankna> :t runReaderT
10:17:59 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
10:18:09 <dankna> yeah, it wants the action first and the thing to read second
10:18:09 <kuffaar> dankna http://siyobik.info/pastebin_download.php?id=567
10:18:10 <dankna> my mistake
10:18:13 <ski> (kuffaar : i mentioned you needed `newMVar ()' :)
10:18:15 <dankna> thanks
10:18:21 <kuffaar> ski oh snap :p
10:18:36 <Filosofem> Other problem came along. If I write the type of the funcion I get this Error "parse error on input `->' ". If I let Haskell guess the type, it works
10:18:43 <Filosofem> but I really need to write the type
10:19:06 <kmc> how were you writing the type?
10:19:09 <kmc> we can help you fix your syntax
10:19:12 <Filosofem> like this
10:19:13 <kmc> if it's a single line just paste it here
10:20:49 <Filosofem> I forgot the "::" but I get an error anyway
10:20:53 <Filosofem> but this time its longer
10:21:08 <ski> what's the type signature ? :)
10:21:10 <kuffaar> My signature for runLockedConsole was so wrong ;[
10:21:43 <Filosofem> Could not deduce (Eq a) from the context ()
10:21:43 <Filosofem>       arising from a use of `limpaLista' at PF_P2.hs:30:20-40
10:21:43 <Filosofem>     Possible fix:
10:21:43 <Filosofem>       add (Eq a) to the context of the type signature for `contaRes'
10:21:43 <Filosofem>     In the first argument of `length', namely
10:22:06 <kmc> don't paste that many lines here
10:22:08 <kmc> hpaste.org
10:22:22 <kmc> the error is that you're using (==) or otherwise need the ability to compare values of type "a"
10:22:25 <ski> kuffaar : i think you want to put the arguments to `runReaderT' in the opposite order
10:22:30 <kmc> which you only have for certain types
10:22:31 <ski> @hoogle runReaderT
10:22:32 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
10:22:38 <kmc> but you didn't write this constraint in your type  signature
10:22:40 <kuffaar> ski: Yeah I already fixed that, it compiles now
10:22:45 <ski> oh, ok
10:23:52 <ski> Filosofem : you know, if you omit the type signature, and let Haskell infer it, then you can ask for the type with `:t' in the interactor and then put that into your type signature
10:24:27 <Filosofem> ah, yeah
10:24:28 <Filosofem> gr8 tip
10:24:29 <Filosofem> thanks
10:24:42 <ski> (Filosofem : omitting any part from `forall' to `.', if any .. imho, GHCi shouldn't say those if one doesn't have that extension enabled)
10:24:57 <Filosofem> I forgot the Eq =>
10:25:00 <Filosofem> contaRes :: (Eq a) => Questionario a -> Int
10:25:03 <Filosofem> this is the type
10:25:05 <Filosofem> and I had
10:25:09 <Filosofem> contaRes :: Questionario a -> Int
10:26:36 <ski> (Filosofem : just a small point, if you like, you can write `Eq a =>' instead of `(Eq a) =>' .. it doesn't matter -- i find the former prettier, but YMMV)
10:27:03 <kmc> Filosofem, yes, the error message said you forgot the Eq
10:27:35 <kmc> i prefer (Eq a) => for uniformity.  if you have more than one constraint you have to use the parens
10:28:09 <ski> i think of `(.. , .. , ..)' as conjunction, and thus i think it prettier to omit, when there's only one constraint
10:28:23 <dixie> @src seq
10:28:23 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:28:31 <kmc> dixie, seq is a magical built-in
10:28:37 <kmc> however you can define it yourself for particular types
10:28:43 <kmc> seqBool True x = x; seqBool False x = x
10:28:44 <ski> (also i'm sortof hoping we might get other kinds of compound constrants later .. like `(forall a. Show a => Show (f a)) => ...' e.g.)
10:28:51 <kmc> seqUnit () x = x
10:29:17 <kuffaar> runLockedConsole :: MonadIO m => ReaderT (MVar ()) m a -> m a
10:29:18 <Bynbo7> hmm, how do i take the elements in a binary tree, and get them out in heap order (so index 0 is the root, index 1 and 2 are its children, 3,4,5 and 6 are its grandchildren)
10:29:26 <kuffaar> type LockedConsole = ReaderT LockedConsoleState
10:29:38 <kuffaar> Shouldn't I be able to turn that into LockedConsole m a -> m a then?
10:30:02 <ski> hm, oh
10:30:37 <ski> you need to wrap the `MVar ()' up into an `LockedConsoleState', when calling `runReaderT'
10:31:04 <ski> `MVar ()' is "morally" the same as `LockedConsoleState' (we say "is isomorphic to")
10:31:19 <kuffaar> Ah
10:31:21 <kuffaar> Right
10:31:23 <ski> but there's still a difference, which means that you have to explicitly wrap (and unwrap) to go between them
10:31:45 <ski> then if you ask `:t' it will probably infer `ReaderT LockedConsoleState' in your type
10:32:45 <ski> but since `type LockedConsole = ReaderT LockedConsoleState' says the former is *equal* to the latter (as opposed to creating a *new* type which contains the right-hand-side), you can replace that part by `LockedConsole' in your type signature, to shorten thinfs
10:40:46 <aristid> ski: isomorallyphic
10:41:41 <ski> ("lyphic" being ?)
10:46:45 <ski> (oh .. ok)
10:49:21 <yatt0> does any one is the scientific computing world use haskell?
10:49:52 <Martty> no but it's great to get chicks
10:49:55 <Ke> it's not too popular, but there's definitely interest
10:50:04 <Ke> see eg. obsidian
10:57:09 <Filosofem> Ok, one more question ... Im not making a small interactive menu to work with my binary tree. Its working very well, except for the stop case
10:57:42 <Filosofem> if i write like this
10:57:48 <Filosofem> questiona (Resultado a) = do {putStrLn "Haskell";}
10:57:51 <Filosofem> it works fine
10:57:55 <Filosofem> but I want
10:58:01 <Filosofem> questiona (Resultado a) = do {putStrLn a;}
10:58:09 <Botje> Filosofem: then use print
10:58:16 <Botje> or putStrLn (show a)
10:58:20 <ski> Filosofem> :t questiona
10:58:59 <Filosofem> I have the type right
10:59:08 <Filosofem> because the interactivity works
10:59:17 <Filosofem> i have more than 1 case
10:59:23 <Filosofem> wait, let me past the code
11:00:11 <Filosofem> http://hpaste.org/raw/43080/interactivity
11:00:47 <Filosofem> this way it works, but as I said, I dont want to print Haskell but that "a" instead
11:01:16 <lelf> ?ty putStrLn
11:01:17 <lambdabot> String -> IO ()
11:02:48 <Filosofem> lambdabot, it needs to be Questionario a -> IO (), because I have to give a Questionario a as a paramter 
11:03:37 <ski> Filosofem : how is `Quesionario' defined ?
11:03:39 <Botje> :t show
11:03:41 <lambdabot> forall a. (Show a) => a -> String
11:04:09 * ski thinks Filosofem probably needs to add `Show a => ' to the type signature of `questiona' .. but wants to make sure
11:04:48 <Filosofem> @ski data Questionario a = Resultado a | Questao String (Questionario a) (Questionario a)
11:04:48 <lambdabot> Maybe you meant: ask src wiki
11:06:08 <Filosofem> ahh
11:06:09 <Filosofem> it works now
11:06:16 <ski> s/@ski/ski :/
11:06:27 <Filosofem> (Show a =>) with print
11:06:34 <Filosofem> :D
11:06:36 <Filosofem> thanks all
11:06:43 <ski> right, you need `questiona :: Show a => Questionario a -> IO ()'
11:06:58 <Filosofem> y, thanks :)
11:07:26 <ski> this means that you can only pass values of type `Questionario a' to `questiona' such that `a' is in the type class `Show' (i.e. that values of type `a' can be `show'n)
11:08:09 <ski> the type signature you had before claimed that `questiona' would work for *any* type `a' .. but the code for it didn't work for any `a'
11:08:16 <ski> e.g. if 
11:08:39 <ski> `a' is `Integer -> Integer', then you can't show such values
11:08:54 <Filosofem> ah, I see
11:09:02 <Filosofem> Well, the machine is always right
11:09:02 <ski> so you can't pass `Questionario (Integer -> Integer)' to `questiona'
11:09:20 <ski> probably this doesn't matter for you, probably you won't need/try to do such things anyway
11:09:36 <ski> Haskell only wanted the type signature to be correct in all cases
11:10:06 <Filosofem> the problem is that in the classes at the university we always assume that the user will pass the right values
11:10:13 <Filosofem> then when we come to this situations
11:10:18 <Filosofem> we dont have the right training
11:10:38 <dankna> nobody can train you to debug, it's between you and the code
11:11:25 <Filosofem> yeah, but if you are used to deal with this type of situations
11:11:28 <Filosofem> you work them out fast
11:12:07 <dankna> I'm not sure anybody learns how to debug FROM university.  They may learn how to do it WHILE AT university, but that's almost by coincidence.
11:12:24 <Filosofem> ok, I will have to trust you on that
11:12:31 <Filosofem> because I dont have much experience in programing
11:12:33 <dankna> heh, it's just my opinion
11:12:40 <ski> anyway, if you're unsure, you can try commenting out the type signature, then ask the interactor for the type with `:t' (if there√'s no type error), and then you can put that into the type signature
11:12:42 <smerz> i learned it before uni
11:12:43 <smerz> x)
11:12:44 <smerz> lucky me
11:13:35 <Filosofem> y, the only problem is in the writen tests, no computer to check if the things are right :/
11:13:45 <Filosofem> but again, thanks for the tips
11:14:27 <Bynbo7> well, that's awesome. just manages to make a super fast version of the binary trees benchmark :)
11:14:43 <ski> Filosofem : yeah .. after a while, you develop a type checker/inferrer in your head
11:14:52 <ski> .. at least i did :)
11:15:24 <Filosofem> I'm sure I will. As I said, I don't have much practice yet :)
11:15:41 <Twey> Especially if you spend enough time working with languages that don't have a software checker/inferrer ;)
11:24:02 * hackagebot BerkeleyDB 0.8.3 - Berkeley DB binding  http://hackage.haskell.org/package/BerkeleyDB-0.8.3 (StephenBlackheath)
11:25:54 <hpc> ski: some types it cannot infer; at least, i have gotten errors for omitting the signature of class-constrained functions
11:26:26 <ski> yes
11:26:32 <ski> usually this is because of DMR
11:26:47 * hpc personally makes the type signature first, and writes the function to match
11:26:56 <ski> but there's some cases (not that common in actual code), where you *do* need explicit type signatures
11:26:58 <hpc> if i can't get what i want, i change the signature, then rewrite the function from scratch
11:27:03 <Bynbo7> heh, awesome, this new binary trees program is three times faster than dons'
11:27:33 <ski> (polymorphic recursion in H98. higher-rank-types. functions matching on GADTs .. possibly i'm forgetting some)
11:27:41 <hpc> i would say those situations can be quite common; i had that issue on my website, without extensions
11:27:41 <Bynbo7> shame they almost certainly won't allow it. i think they intend for you to use an actual tree structure, not a binary tree represented by an Array ;)
11:27:52 <hpc> i forget what i did to provoke the error though
11:28:07 <ski> hpc : i usually write the signature first as well
11:28:23 <ski> .. but i've heard e.g. John Hughes seldom writes type signatures
11:28:46 <Botje> us mere mortals have to rely on the typechecker
11:29:11 <ski> hpc : hm, was those only cases of DMR, or more serious cases like those i mentioned ?
11:29:32 <hpc> polymorphic recursion?
11:29:45 <hpc> also, what's DMR stand for?
11:29:53 <ski> the Dreaded Monomorphism Restriction
11:29:58 <hpc> oh
11:30:17 <ski> an example of polymorphic recursion is
11:30:23 <hpc> i think it might have been monomorphism
11:30:38 <ski> yeah, that's what i'd expect :)
11:30:51 <ski>   {-# LANGUAGE NoMonomorphismRestriction #-}
11:30:57 <ski> to disable it
11:31:01 <ski>   sillyLength :: Integral i => [a] -> i
11:31:07 <ski>   sillyLength [    ] = 0
11:31:31 <ski>   sillyLength (a:as) = 1 + sillyLength (map Just as)
11:31:37 <hpc> oh wow, that's exactly the monomorphism restriction
11:31:50 <j-invariant> haha
11:32:07 <hpc> yeah, what i had was Show a => a -> IO ()
11:32:09 <ski> note that if `sillyLength' is passed an `[a]', then it passes an `[Maybe a]' on in the recursion
11:32:09 <hpc> iirc
11:32:21 <ski> this is polymorphic recursion
11:32:45 <ski> a recursive definition, which in its recursive call(s) uses itself at *another* instance than the "current" one
11:33:36 <ski> hpc : this case is not DMR .. DMR applies when you have non-function-definitions where the type includes constraints `.. => ..'
11:34:42 <ski> DMR disallows those constraints in the type, in those cases, insisting on those to be removed (usually by monomorphizing the definition)
11:35:59 <ski> a very simple example would be
11:36:06 <ski>   count = 42
11:36:12 <hpc> oh, and it defaults to Int
11:36:13 <ski> normally, this would get type
11:36:18 <ski>   count :: Num n => n
11:36:35 <ski> but to avoid the `Num n' constraint, it defaults `n' to `Integer'
11:36:41 <ski> another example is
11:36:51 <ski>   foo = \x -> reverse (show x)
11:36:59 <hpc> which defaults to x :: ()
11:37:03 <ski> the general type of this would be
11:37:10 <ski>   foo :: Show a => a -> String
11:37:27 <ski> but with DMR, you get either some defaulting, or an error (if no defaulting apply)
11:37:34 <ski> but note that in
11:37:46 <ski>   foo x = reverse (show x)
11:37:50 <ski> DMR does *not* apply
11:37:56 <ski> even though the code is equivalent
11:38:10 <ski> because `foo x = ...' is syntactically a *function* definition
11:38:25 <ski> but `foo = \x -> ...' is not (even though it defines a function in this case)
11:38:50 <hpc> yeah, i read the wiki article
11:39:39 <ski> ok, then you probably know about the old rationale for having the DMR in the first place
11:39:56 <Bynbo7> anyone familliar with using Data.Parallel.Strategies?
11:40:27 <Bynbo7> i'm wondering if this is the best way to do this: depth minN maxN `using` parListN numCapabilities rdeepseq (here depth creates a list of 3-tuples)
11:41:19 <hpc> ski: yeah, because of sharing; they thought the value would be computed twice
11:43:46 <ski> well, not quite .. they though it would be *confusing*to*newbies* that the value of the definitions *wasn't* shared, in case the type for it got constraints (but the definition syntactically looks like a non-function definition)
11:44:17 <ski> if you say
11:44:37 <ski>   foo = repeat False /\/ map not foo
11:44:46 <hpc> yeah, saying "confusing to newbies" and then talking about sharing...
11:44:51 <ski> then `foo' will be shared, and only conputed once
11:44:55 <ski> if you instead say
11:45:01 <hpc> haskell sharing is doomed to be a confusing topic for newbies :P
11:45:06 <ski>   foo = repeat 0 /\/ map (+1) foo
11:45:14 <ski> then `foo' *won't* be shared
11:49:55 <tromp_> anyone here have a galaxy tab?
11:54:10 <j-invariant> so is haskell on its last legs?
11:54:29 <Bynbo7> you do say some very strange things don't you
11:54:30 <j-invariant> (read,ing about The AST Typing Problem)
11:56:35 <monochrom> just answer yes to end the non-existent "discussion"
11:57:02 <Bynbo7> yes, haskell has no future at all
11:57:18 <kmc> haskell is dying, netcraft confirms it
11:57:20 <Phyx-> i knew it.. I was misled..
11:57:46 <monochrom> (haskell is just a programming language. why do people hope it will prevent the sun from going red dwarf?)
11:58:01 <monochrom> (and cure cancer?)
11:58:31 <ddarius> We'll shoot the Haskell Report off in a canister out into space and it will outlive us all.
11:58:36 <Phyx-> because java failed to live up to it's promise!
11:58:51 <Phyx-> ddarius: or mutate and come back to kill us all :/
11:59:23 <j-invariant> "Dependent type can certainly handle some of this problem, but I'm really looking for clarification on how to do this in non-dependent type systems. "
11:59:48 <monochrom> just use machine code. it's turing-complete.
12:00:03 <j-invariant> ddarius: though the hsakell report isn't enough for an alien race t oundersatnd haskell
12:00:09 <Phyx-> what are you on about.... what is this problem you speak of?
12:00:10 <Bynbo7> no need to worry about types!
12:00:10 <j-invariant> since it's based on english and stuff
12:00:26 <monochrom> there is no aliens
12:00:35 <ddarius> j-invariant: That's irrelevant.
12:00:42 <Phyx-> monochrom: then what are those little purple things i keep seeing?
12:00:52 <dolio> Hallucinations.
12:01:03 <ddarius> Also, I'm pretty refinement types solve that problem, and they can be encoded into Haskell, although it isn't the prettiest thing.
12:01:35 <j-invariant> ddarius: better read about those, I have no idea what they are!
12:02:30 <kmc> j-invariant, do C, FORTRAN, and COBOL solve the problem in question?
12:02:34 <kmc> because all those languages are still going strong
12:03:28 <Bynbo7> i still haven't figured out if j-invariant is a very subtle troll
12:04:18 <Phyx-> <-- honestly doesn't know the "ast problem"
12:04:36 <monochrom> <-- = const "yes"
12:04:47 <kmc> let's be careful with the t-word
12:04:57 <ddarius> <-- = const "RTFM"
12:05:10 <Phyx-> <-- = const "Huh?"
12:05:11 <monochrom> wait, const "RTFM" is also me!
12:05:37 <monochrom> then again actually const "<haskell report url> compulsory reading"
12:05:58 <Phyx-> lol, was that aimed at me? :P
12:06:05 <monochrom> no!
12:06:13 <ski> > let (<--) = (^) in 2 <-- 3
12:06:14 <lambdabot>   8
12:08:24 <kuffaar> ski: http://siyobik.info/pastebin_download.php?id=567
12:08:29 <kuffaar> I am doing the wrapping wrong :(
12:09:27 <ski> oh
12:09:43 <ski>   runReaderT action (LockedConsoleState lock)
12:10:01 <ski> is what you wanted there
12:10:04 <ski> kuffaar : ^
12:10:28 <ski> (or if you really want to, you *could* change the other line to
12:10:47 <kuffaar> Wouldn't it be nicer to use $ instead of parentheses?
12:10:49 <uman> hi guys, I have a function; let's say it's called "permuteString". Could someone show me how to write a program that takes a string (possibly including newlines) from stdin, passes that string to the function, then prints the output to stdout? I'm going through an online Haskell tutorial, but I/O is pretty far along in the tutorial and I need to get this program finished today
12:11:04 <ski>   lock <- liftIO . liftM LockedConsoleState $ newMVar ()
12:11:04 <ski> )
12:11:14 <kmc> uman, http://www.haskell.org/haskellwiki/Introduction_to_IO
12:11:15 <Bynbo7> uman: look at interact
12:11:18 <Bynbo7> :t interact
12:11:19 <lambdabot> (String -> String) -> IO ()
12:11:28 <ski> kuffaar : imho, `$' only looks better in a few cases .. i usually prefer brackets
12:11:30 <uman> kmc: thanks :)
12:11:44 <kuffaar> Cheers, it works
12:11:44 <ski> also, `x $ y $ z' looks uglier than `x . y $ z'
12:11:51 <kuffaar> :t liftIO
12:11:52 <lambdabot>     Ambiguous occurrence `liftIO'
12:11:52 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
12:11:52 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
12:12:00 <ski> @hoogle liftIO
12:12:00 <kuffaar> :t Control.Monad.Logic.liftIO
12:12:00 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
12:12:02 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
12:12:03 <monochrom> yeah, money isn't everything
12:12:06 <kuffaar> Oh yeah that was wrong
12:12:06 * Bynbo7 wishes someone would fix that
12:12:13 <ski> monochrom : yeah
12:13:01 <uman> unfortunately kmc's link says how to read individual lines from stdin; is there an action that reads one entire string (until ^D) from stdin?
12:13:03 <ski> imho, it is a mistake to think `$' is somehow for replacing / using instead of brackets
12:13:10 <kmc> uman, getContents
12:13:17 <kmc> my link was for learning the concepts of how IO is done
12:13:20 <uman> kmc: thanks :)
12:13:23 <kmc> you can then look at API docs for specific functions
12:13:31 <Bynbo7> why not use interact :\
12:13:32 <kmc> e.g. http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/System-IO.html
12:13:37 <ski> (you can't do that generally, at least not without introducing temporary variables (well, or ugly things like a forth-combinators lib i saw))
12:13:39 <kmc> you should book mark this page: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
12:13:45 <Bynbo7> it wraps getContents very nicely
12:14:08 <monochrom> main = interact permuteString
12:14:16 <Bynbo7> exactly
12:14:18 <monochrom> THE END
12:15:07 * geheimdienst wonders when the credits will roll
12:15:11 <hpc> @src interact
12:15:12 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:15:32 <kmc> @pl \f -> fmap f getContents >>= putStr
12:15:33 <lambdabot> (putStr =<<) . flip fmap getContents
12:16:40 <Twey> (>>= putStr) . (<$> getContents)
12:17:50 <uman> I got what I needed done, thanks guys
12:18:17 <uman> I will learn about these concepts more thoroughly once I get to that point in my learning; for now I just needed a quick fix; thanks a million :)
12:19:45 <aristid> @pl \f -> getContents >>= return . f >>= putStr
12:19:45 <lambdabot> (putStr =<<) . (getContents >>=) . (return .)
12:20:42 <nyuszika7h> Hi!
12:20:45 <nyuszika7h> I'm a newbie.
12:20:51 <Zao> Hello.
12:20:55 <Botje> Hi, newbie!
12:21:32 <nyuszika7h> I can't seem to be able to type the left bracket [ with a Hungarian keyboard layout (AltGr+F).
12:22:09 <Bynbo7> i don't think that's so much as haskell problem as an editor/OS problem
12:22:20 <nyuszika7h> I'm at tryhaskell.org
12:22:50 <sipa1024> in that case it's a browser problem? :)
12:22:53 <geheimdienst> chrisdone, you around?
12:23:08 <nyuszika7h> Chrome 10.0.634.0 dev
12:23:09 <kuffaar> nyuszika7h that thing doesn't work so well in general
12:23:15 <kuffaar> nyuszika7h jsut get the real deal then
12:23:20 <kuffaar> ghc
12:23:41 * geheimdienst can't seem to get tryhaskell working with opera ...
12:23:55 <Twey> Yeah, modifiers and Compose don't work for me on tryhaskell.org, either
12:24:05 <Twey> Oh wait
12:24:09 * nyuszika7h can't seem to get tryhaskell working with Opera Mobile
12:24:10 <Twey> No, modifiers do, but deadkeys don't
12:24:41 <Twey> Ha, but it errors out
12:24:43 <geheimdienst> nyuszika7h: here on irc, you can send messages to lambdabot ...
12:24:44 <Twey> Encoding issues
12:24:48 <geheimdienst> > 2 + 42
12:24:49 <lambdabot>   44
12:25:29 <nyuszika7h> > [1, 2, 3]
12:25:30 <lambdabot>   [1,2,3]
12:25:37 <Bynbo7> yeah, feel free to use lambdabot instead of tryhaskell.com
12:25:40 <nyuszika7h> > reverse "hello world"
12:25:41 <lambdabot>   "dlrow olleh"
12:26:01 <nyuszika7h> reverse reverse "I'm broken"
12:26:01 <kmc> you can also private-message lambdabot
12:26:08 <kmc> in which case i think you have to say @run instead of >
12:26:14 <nyuszika7h> @run 1+2
12:26:15 <lambdabot>   3
12:26:34 <geheimdienst> kmc, > seems to work fine in a priv window
12:26:37 <kmc> oh
12:26:40 <kmc> maybe it was :t that doesn't work
12:26:45 <nyuszika7h> @run "anyone seeing this?"
12:26:46 <lambdabot>   "anyone seeing this?"
12:26:51 <kmc> yes we see it
12:26:55 <kmc> @. elite nixon
12:26:56 <lambdabot> I D0n'7 WAN+ 7o z3E 7HIS (OUnTRY T0 9o 7|-|a+ way. joo KNow whaT |-|4pp3NEd to 7h3 GReEK5. HOmOzExua|ItY dE57ROYED th3/\/\. zURE, 4RizT0t|E wAz 4 |-|o/\/\o, w3 4Ll xNow t|-|at, zo was 50cr4TEs.
12:27:01 <kmc> @quote ghc
12:27:02 <nyuszika7h> Nice!
12:27:02 <lambdabot> ghc says: At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
12:27:07 <nyuszika7h> > elite hello world
12:27:08 <lambdabot>   Not in scope: `elite'Not in scope: `hello'Not in scope: `world'
12:27:15 <nyuszika7h> oops
12:27:19 <nyuszika7h> > elite "hello world"
12:27:19 <lambdabot>   Not in scope: `elite'
12:27:30 <kmc> @. elite run ("hello world: " ++ show (2+2))
12:27:30 <Bynbo7> elite is a lambdabot command, not a function
12:27:32 <lambdabot> "heLL0 WOr1D: 4"
12:27:34 <nyuszika7h> > @. elite "hello world"
12:27:35 <lambdabot>   <no location info>: parse error on input `@.'
12:27:37 <Bynbo7> @elite hello?
12:27:38 <lambdabot> |-|3llO?
12:27:40 <geheimdienst> > cake
12:27:43 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
12:27:55 <Bynbo7> TOOT TOOT, ASCII CAT!
12:28:13 <nyuszika7h> @. elite run ("My IQ is: " ++ show(60+60))
12:28:15 <lambdabot> "my IQ iz: 120"
12:28:36 <nyuszika7h> > "I'm broken"
12:28:36 <lambdabot>   "I'm broken"
12:28:41 <kmc> @faq Can Haskell increase your IQ by over 9000 points?
12:28:41 <lambdabot> The answer is: Yes! Haskell can do that.
12:29:07 <nyuszika7h> @faq How do I set variables in Haskell?
12:29:07 <lambdabot> The answer is: Yes! Haskell can do that.
12:29:10 <nyuszika7h> LOL
12:29:16 <nyuszika7h> @faq But how?
12:29:16 <lambdabot> The answer is: Yes! Haskell can do that.
12:29:24 <kmc> @vixen How do I set variables in Haskell?
12:29:24 <lambdabot> church is my favourite computer scientist.
12:29:32 <nyuszika7h> @faq Can Haskell shit my pants?
12:29:32 <lambdabot> The answer is: Yes! Haskell can do that.
12:29:37 <nyuszika7h> ROFL
12:29:38 <aristid> kmc: it answers coded.
12:29:46 <kmc> it takes effort to shit someone else's pants
12:29:56 <aristid> nyuszika7h: you're easy to entertain? :)
12:30:02 <nyuszika7h> @faq Can Haskell get effort?
12:30:02 <lambdabot> The answer is: Yes! Haskell can do that.
12:30:17 <aristid> @faq Can Haskell avoid success at all costs?
12:30:17 <lambdabot> The answer is: Yes! Haskell can do that.
12:30:21 <aristid> LIAR
12:30:22 <nyuszika7h> > lesson1
12:30:23 <lambdabot>   Not in scope: `lesson1'
12:30:29 <aristid> @quote avoid.success
12:30:29 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
12:30:30 * Adamant suppresses urge to reference the Lonely Island
12:30:35 <nyuszika7h> > let square x = x * x in square 52
12:30:35 <Bynbo7> aristid: can and will are different things
12:30:36 <lambdabot>   2704
12:30:41 <nyuszika7h> > x
12:30:41 <lambdabot>   x
12:30:43 <aristid> Bynbo7: good point.
12:30:49 <nyuszika7h> > Oops.
12:30:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:30:54 <nyuszika7h> > "Oops"
12:30:54 <lambdabot>   "Oops"
12:31:04 <nyuszika7h> > myList: [1,2]
12:31:05 <lambdabot>   Not in scope: `myList'
12:31:15 <nyuszika7h> > myList : [1,2]
12:31:16 <lambdabot>   Not in scope: `myList'
12:31:21 <nyuszika7h> > 1 : [2,3]
12:31:22 <lambdabot>   [1,2,3]
12:31:22 <aristid> > 0 : [1,2]
12:31:24 <lambdabot>   [0,1,2]
12:31:40 <nyuszika7h> > "foo" : ["bar","baz","qux"]
12:31:41 <aristid> > cycle "nyuszika7h... "
12:31:41 <lambdabot>   ["foo","bar","baz","qux"]
12:31:41 <lambdabot>   "nyuszika7h... nyuszika7h... nyuszika7h... nyuszika7h... nyuszika7h... nyus...
12:31:55 <geheimdienst> nyuszika7h: you can also privately talk to lambdabot
12:32:03 <kmc> > fix show
12:32:04 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
12:32:05 <nyuszika7h> cycle "Read That Fucking Manual"
12:32:09 <aristid> @quote ennobunktor
12:32:10 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
12:32:13 <nyuszika7h> > cycle "Read That Fucking Manual"
12:32:14 <lambdabot>   "Read That Fucking ManualRead That Fucking ManualRead That Fucking ManualRe...
12:32:21 <aristid> @quote bunktor
12:32:21 <lambdabot> No quotes match. Do you think like you type?
12:32:24 <nyuszika7h> cycle "FUCK ME "
12:32:34 <nyuszika7h> > cycle "Fuck me "
12:32:35 <lambdabot>   "Fuck me Fuck me Fuck me Fuck me Fuck me Fuck me Fuck me Fuck me Fuck me Fu...
12:32:40 <Bynbo7> nyuszika7h: ok, you're now getting well on your way to being banned
12:32:42 <djahandarie> nyuszika7h, you should probably stop spamming
12:32:46 <nyuszika7h> okay, sorry
12:32:53 <nyuszika7h> @quote aristid
12:32:53 <lambdabot> aristid says: what's the quote-add-command-thingie?
12:33:03 <geheimdienst> nyuszika7h: you can privately talk to lambdabot as much as you want
12:33:09 <Adamant> yes, we have bots in this channel
12:33:16 <nyuszika7h> geheim...whoever: how?
12:33:27 <aristid> /query lambdabot
12:33:48 <geheimdienst> i use pidgin and it's double-clicking on someone's nickname
12:33:50 <Bynbo7> nyuszika7h: try this: type ax<tab>
12:33:59 <ski> /msg lambdabot @vixen what's your opinion on the single-particle theory ?
12:34:01 <Bynbo7> should autocomplete to Axman6
12:34:11 <geheimdienst> @quote ennobunktor
12:34:13 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
12:34:28 <aristid> geheimdienst: why doesn't it find it? :(
12:34:35 <geheimdienst> i'm wondering as well
12:34:43 <nyuszika7h> nice :)
12:34:52 <Bynbo7> @quote enno
12:34:52 <lambdabot> No quotes match.
12:35:04 <nyuszika7h> @quote ChanServ
12:35:05 <lambdabot> No quotes match. :(
12:35:14 <Bynbo7> lost it maybe, @flush needs to be run every not and then
12:35:17 <aristid> @quote geheimdienst
12:35:18 <lambdabot> geheimdienst says: #haskell has the type a -> m b. you feed in some problem, and out comes a solution invariably involving monads
12:36:19 <djahandarie> Hahaha
12:36:41 <Bynbo7> heh
12:36:53 <sipa1024> :t const fail
12:36:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> String -> m a
12:37:03 <sipa1024> almost
12:37:03 <nyuszika7h> @what myself
12:37:03 <lambdabot> I know nothing about myself.
12:37:05 * geheimdienst feels like a low-grade celebrity
12:37:14 * nyuszika7h laughs
12:37:21 <sipa1024> :t const . fail ""
12:37:22 <lambdabot> forall a b (f :: * -> *). (Monad f, Functor f) => f (b -> a)
12:37:27 <sipa1024> :t const $ fail ""
12:37:28 <lambdabot> forall b (m :: * -> *) a. (Monad m) => b -> m a
12:37:38 <aristid> @quote djahandarie
12:37:38 <ski> @ghc
12:37:38 <lambdabot> djahandarie says: I'm like a massively parallel but slow clocked processor
12:37:38 <lambdabot> ghc says: TELL SIMON: evalAbsence
12:37:44 <aristid> @quote djahanderie
12:37:44 <lambdabot> No quotes match. Where did you learn to type?
12:37:48 <sipa1024> @let haskell = const $ fail "blah"
12:37:50 <lambdabot>  Defined.
12:37:58 <aristid> :t haskell
12:38:00 <lambdabot> forall b (m :: * -> *) a. (Monad m) => b -> m a
12:38:00 <djahandarie> aristid, now you're just messing with me
12:38:09 <aristid> djahandarie: no i'm not :P
12:38:17 <JuanDaugherty> where did you learn to type?
12:38:23 <mauke> preflex: quote geheimdienst 
12:38:23 <preflex>  no quotes found for geheimdienst
12:38:38 <nyuszika7h> @quote geheimdienist
12:38:38 <lambdabot> No quotes match. You type like i drive.
12:38:39 <Bynbo7> @quote anal
12:38:39 <lambdabot> Vellos says: OLD CAP I DO BELIEVE I HAVE FOUND YOUR MARKET COMPETENCE, OR PERHAPS LACK THEREOF, TO IMPLICATE YOU AS A PARTICIPATE IN HOMOSEXUAL ANAL  INTERCOURSE.  I AWAIT YOUR RETORT.
12:38:44 <dolio> > haskell () `seq` ()
12:38:45 <lambdabot>   Ambiguous type variable `m' in the constraint:
12:38:45 <lambdabot>    `GHC.Base.Monad m'
12:38:45 <lambdabot>      a...
12:38:46 <ski> preflex: quote lambdabot
12:38:46 <preflex>  <lambdabot> @fact preflex
12:38:47 <aristid> JuanDaugherty: i think i learned it at my first computer, it was a 486.
12:38:47 <nyuszika7h> preflex: > "foo"
12:38:50 <Bynbo7> hmm, not the one i was after...
12:38:53 <Bynbo7> @quote axman6
12:38:54 <lambdabot> m3ga says: shut up Axman6
12:38:56 * dankna feels old
12:38:57 <Bynbo7> @quote axman6
12:38:58 <lambdabot> ivanm says: Axman6: the premature optimisation quote is misquothed
12:39:00 <Bynbo7> ouch
12:39:04 <Bynbo7> @quote axman6
12:39:04 <lambdabot> m3ga says: shut up Axman6
12:39:05 <aristid> dankna: because you are.
12:39:07 <nyuszika7h> @show "STOP FLOODING THE ROOM"
12:39:07 <lambdabot> "\"STOP FLOODING THE ROOM\""
12:39:08 <dankna> bah!
12:39:10 <Bynbo7> @quote Axman6
12:39:10 <lambdabot> Axman6 says: inface, ST is just plain awesome
12:39:12 <Bynbo7> @quote Axman6
12:39:12 <lambdabot> Axman6 says: -ddump-occur-anal <- another terrible name...
12:39:16 <Bynbo7> there we go
12:39:21 <JuanDaugherty> aristid, I didn mean that kinda type
12:39:25 <aristid> nyuszika7h: how ironic that it's you saying that :)
12:39:31 <aristid> JuanDaugherty: what else?
12:39:40 <mauke> preflex: forget lambdabot @fact preflex
12:39:41 <sipa1024> :t runST
12:39:42 <lambdabot> forall a. (forall s. ST s a) -> a
12:39:43 <kmc> hehehehe
12:40:16 * nyuszika7h is a bot. Type !help for a list of the available commands.
12:40:28 <geheimdienst> !help
12:40:36 <nyuszika7h> Listing...
12:40:41 <aristid> a slow bot.
12:40:48 <Zao> !botsnack
12:40:52 <Zao> Oh, @.
12:40:53 <nyuszika7h> Yummy!
12:40:53 <aristid> @botsnack
12:40:54 <lambdabot> :)
12:40:57 <ski> maybe enough bot abuse for today ?
12:41:10 <nyuszika7h> !run code: run the specified haskell code
12:41:15 <monochrom> abuse monochrom instead
12:41:25 <dankna> !run exitFailure
12:41:37 <monochrom> run Forrest run
12:41:43 <nyuszika7h> @dankna A compile-time error! It just means the expression wasn't quite right. Try again
12:41:43 <lambdabot> Unknown command, try @list
12:41:47 <dankna> lol
12:41:48 <nyuszika7h> dankna: A compile-time error! It just means the expression wasn't quite right. Try again
12:41:55 <nyuszika7h> @list
12:41:55 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:42:03 <kmc> this is getting old
12:42:07 <nyuszika7h> http://code.haskell.org/nyuszika7h/COMMANDS
12:42:11 <kmc> nyuszika7h, why don't you private message the bot?
12:42:11 <aristid> monochrom: !. types readRecursive "http://okmij.org"
12:42:27 <monochrom> my head has exploded
12:42:49 <aristid> oleg gets them all
12:43:09 <nyuszika7h> @what myself
12:43:09 <lambdabot> I know nothing about myself.
12:43:19 <monochrom> do you have a haskell question?
12:43:24 <nyuszika7h> yes
12:47:08 <geheimdienst> so, i notice there is 4 google hits for "ennobunktor"
12:47:15 <monochrom> haha
12:48:20 <geheimdienst> i notice aristid asked lambdabot for the exact same quote only on 11 jan, and she found it
12:48:22 <mreh> was that on letterman?
12:48:33 <geheimdienst> the ways of the lady lambdabot are mysterious
12:48:40 <geheimdienst> mreh, i doubt it
12:48:52 <mreh> geheimdienst: heh, I jest
12:48:54 <nyuszika7h> @slap lambdabot
12:48:55 * lambdabot smashes a lamp on lambdabot's head
12:49:15 <Bynbo7> geheimdienst: if no one ran @flush in the time between the quote being remembered and her dying, then it wouldn't have been saved i think
12:49:33 <aristid> @remember geheimdienst ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
12:49:34 <lambdabot> I will remember.
12:49:41 <aristid> geheimdienst: reinstituted :)
12:49:58 <mauke> @slush
12:49:58 <lambdabot> Not enough privileges
12:50:14 <aristid> @quote ennobunktor
12:50:15 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
12:50:34 <mauke> @slush
12:50:48 <hpc> @slush?
12:50:48 <lambdabot> Not enough privileges
12:50:54 <mreh> > reverse . drop 1 $ "haskell"
12:50:56 <lambdabot>   "lleksa"
12:51:02 <aristid> @quote ennobunktor
12:51:03 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
12:51:06 <nyuszika7h> @what haskell..
12:51:06 <lambdabot> I know nothing about haskell...
12:51:15 <mauke> hpc: flush
12:51:27 <aristid> nyuszika7h: so what was your haskell question? :)
12:51:32 <geheimdienst> why doesn't she automatically flush after every @remember ...? can't be a performance issue, @remember is only called like once per hour
12:51:47 * nyuszika7h 's Haskell question is: how can I set variables?
12:51:49 <geheimdienst> lambdabot: that's what we figured
12:51:54 <mauke> nyuszika7h: with =
12:52:00 <mreh> that's a constant
12:52:20 <mauke> not if you disable the MR
12:52:54 <hpc> variables are a subtle and complex beast, which can only be tamed by thinking of your problem in a different way
12:53:07 <mreh> some jerk said to me over my shoulder once, if you're doing functional programming, why do you have all those assignments?
12:53:08 <hpc> or through the liberal application of ST
12:53:13 <nyuszika7h> > foo = 1
12:53:14 <lambdabot>   <no location info>: parse error on input `='
12:53:16 <aristid> hpc: or even State.
12:53:38 <Filosofem> I need your help again in this new problem . New data defined as --->  data List a = List Int (Int -> a)
12:53:53 <Filosofem> and when I try to define a function to convert it to a regular list
12:53:56 <Filosofem> it gives me this error
12:53:58 <Filosofem>     Occurs check: cannot construct the infinite type: a = [a]
12:53:58 <Filosofem>     When generalising the type(s) for `fromList'
12:54:01 <aristid> Filosofem: that data structure is more of an array, not really a list :)
12:54:06 <j-invariant> nyuszika7h: haskell doesn't have varibles like that, you can make a box thing which the value can change though if you want
12:54:14 <Filosofem> im just following the text
12:54:19 <mauke> Filosofem: well, then your function definition is wrong
12:54:26 <geheimdienst> @remember mreh some jerk said to me over my shoulder once, if you're doing functional programming, why do you have all those assignments?
12:54:27 <lambdabot> Okay.
12:54:36 <mreh> maybe he found an inconsitency in the universe
12:55:00 <mreh> excellent
12:55:36 <mreh> anyone here who went to hoodlums?
12:55:57 <Saizan> Filosofem: we need to see the code for your function too
12:56:07 <nyuszika7h> @quote ChanServ
12:56:07 <lambdabot> ChanServ says: I'm stupid
12:56:15 <Filosofem> i will post the whole text, with all the info
12:56:21 <mreh> @flush
12:56:21 <lambdabot> Not enough privileges
12:56:26 <Saizan> in a pastebin, please
12:56:29 <mreh> but I really need to go
12:56:33 <nyuszika7h> @quote ChanServ
12:56:33 <lambdabot> ChanServ says: I'm stupid
12:56:36 <nyuszika7h> @quote ChanServ
12:56:36 <lambdabot> ChanServ says: No! I've just banned myself!
12:56:44 <mauke> @floss
12:56:57 <Filosofem> because the data definition comes with an example
12:58:23 <mreh> my pretty printer is a monstrosity that leeches off do notations desugaring, should I commit it to the flames?
12:58:28 * hackagebot sbv 0.9.2 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.2 (LeventErkok)
12:58:30 * hackagebot ranges 0.2.3 - Ranges and various functions on them.  http://hackage.haskell.org/package/ranges-0.2.3 (GeorgePollard)
12:59:12 <aristid> are SMT solvers the new rage?
12:59:21 <aristid> and what's the difference from SAT solvers?
13:00:07 <Saizan> you get to use something fancier than booleans, like integers, bit vectors, or whatever
13:00:36 <aristid> but it's in theory equivalent?
13:01:03 <Filosofem> ok
13:01:05 <Filosofem> here it is
13:01:06 <Filosofem> http://hpaste.org/raw/43085/list_that_turns_out_not_to_be
13:01:25 <ddarius> aristid: SMT is "Satisifiability Modulo Theories"
13:01:35 <Filosofem> i didnt post my code because i only have 1 line
13:01:40 <mreh> that's the problem definition, not the code
13:01:55 <mreh> paste that in here hten
13:01:57 <aristid> ddarius: yeah, wikipedia says so too
13:02:14 <Saizan> Filosofem: but it's your code that's giving the error!
13:02:32 <mreh> > "I am a code"
13:02:33 <lambdabot>   "I am a code"
13:02:35 <Filosofem> so, that notation isnt wrong after all
13:02:44 <Filosofem> fromList (List x y)  = y((x-1)+65)
13:03:04 <nyuszika7h> > sort [1,8,1,4,5,1,"foo","bar",82,35,19,57]
13:03:07 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
13:03:09 <lambdabot>    arising from the literal ...
13:03:23 <nyuszika7h> sort ["beta", "zeta", "alpha", "gamma"]
13:03:27 <Saizan> Filosofem: the result of 'y' will be a single 'a' not a list of 'a', hence the type error
13:03:27 <ski> `fromList (List x y)' should have type `[a]', but `y' will return a single `a'
13:03:32 <nyuszika7h> Huh?
13:03:44 <nyuszika7h> sort ["beta","zeta","alpha","gamma"]
13:03:54 <Saizan> > sort ["beta","zeta","alpha","gamma"]
13:03:55 <lambdabot>   ["alpha","beta","gamma","zeta"]
13:04:04 <mreh> > sort . words $ "do it like this"
13:04:05 <lambdabot>   ["do","it","like","this"]
13:04:10 <mreh> lol
13:04:10 <Filosofem> ok, i think i got it
13:04:13 <Filosofem> i will try something
13:04:26 <Botje> Filosofem: what would "List 3 (\x -> x) be ?
13:04:28 <nyuszika7h> > sort . words $ "never ever try to shit my pants"
13:04:30 <lambdabot>   ["ever","my","never","pants","shit","to","try"]
13:04:37 <shachaf> > sort . unwords $ ["no", "do", "it", "like", "this"]
13:04:40 <lambdabot>   "    dehiiiklnoostt"
13:04:58 <aristid> > words . sort . unwords $ ["no", "do", "it", "like", "this"]
13:05:00 <lambdabot>   ["dehiiiklnoostt"]
13:05:03 <nyuszika7h> > sort .words "try to shit"
13:05:04 <lambdabot>   ["rty","ot","hist"]
13:05:05 <FauxFaux> I don't understand why you people insist on using . when $ is so much clearer. ¬¨_¬¨
13:05:17 <nyuszika7h> > sort . words "try to shit my pants"
13:05:19 <lambdabot>   ["rty","ot","hist","my","anpst"]
13:05:22 <nyuszika7h> Huh???
13:05:28 <shachaf> FauxFaux: (.) is the clearer one!
13:05:31 <nyuszika7h> > sort . words $ "try to shit my pants"
13:05:33 <lambdabot>   ["my","pants","shit","to","try"]
13:05:40 <shachaf> nyuszika7h: Oh, this is a lambdabot oddity. (.) behaves like map.
13:05:42 <aristid> nyuszika7h: you sorted each word :)
13:05:46 <nyuszika7h> @shit
13:05:46 <lambdabot> Maybe you meant: quit show what
13:05:54 <Botje> FauxFaux: you can take part of a pipeline and give it a new name
13:05:56 <yatt0>  what domain of problems is Haskell (or functional programming) well suited for? 
13:05:58 <nyuszika7h> @show me something new
13:05:58 <lambdabot> "me something new"
13:06:07 <Botje> FauxFaux: you can't do that easily with $
13:06:10 <aristid> nyuszika7h: you know that this channel is publicly logged? :)
13:06:11 <shachaf> FauxFaux: With (.) you build up a function and then apply i.
13:06:24 <ski> FauxFaux : `f . g . h . i $ x' is nicer than `f $ g $ h $ i $ x', because all of `f . g . h . i',`f . g . h',`g . h . i',`f . g',`g . h',`h . i' are all valid subexpressions, which you can think about on their own, and factor out, if you want to
13:06:29 * hackagebot yices-painless 0.1.1 - An embedded language for programming the Yices SMT solver  http://hackage.haskell.org/package/yices-painless-0.1.1 (DonaldStewart)
13:06:38 <shachaf> FauxFaux: If you use (.), you can make the argument that $ should be infixl, and eventually save more parentheses. :-)
13:06:58 <ddarius> aristid: SMT problems are usually translated to SAT, but the power depends on the theory being used.
13:07:20 <ski> shachaf : yay !
13:07:25 <FauxFaux> Mmmmm.
13:07:26 <ddarius> aristid: Of course he knows that because everybody reads the topic always.
13:07:29 <nyuszika7h> @botsnack
13:07:29 <lambdabot> :)
13:07:30 <trinithis> > sudo aptget install computervirus
13:07:32 <lambdabot>   "Reading package lists... Done\nBuilding dependency tree\nFetched 31.4kB in...
13:07:32 <mreh> @topic
13:07:32 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join oeis todo type
13:07:44 <nyuszika7h> > sudo apt-get install haskell
13:07:44 <aristid> ddarius: true, how would i forget that everybody reads the topic.
13:07:45 <lambdabot>   Not in scope: `apt'Not in scope: `haskell'
13:07:58 <nyuszika7h> > topic-null
13:07:58 <lambdabot>   Not in scope: `topic'
13:08:05 <nyuszika7h> @topic-null
13:08:05 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
13:08:18 <nyuszika7h> @type hello
13:08:19 <lambdabot> Not in scope: `hello'
13:08:23 <nyuszika7h> @type "hello"
13:08:24 <lambdabot> [Char]
13:08:28 <nyuszika7h> @type 1235
13:08:29 <lambdabot> forall t. (Num t) => t
13:08:37 <nyuszika7h> @type [1,2]
13:08:38 <lambdabot> forall t. (Num t) => [t]
13:08:39 <ddarius> I, for one, vote for a +q for a while.
13:08:54 * ski agrees
13:08:54 * nyuszika7h is leaving
13:08:56 <nyuszika7h> good night
13:09:14 <ski> good night
13:09:16 <mreh> nazis
13:10:03 <parcs> how would one write (m a, m b) -> m (a, b)?
13:10:12 <kuffaar> https://github.com/epicvrvs/Knyaz/blob/master/Knyaz.cabal cabal: can't find source for Knyaz in ., dist\build\autogen https://github.com/epicvrvs/Knyaz what am I doing wrong?
13:10:19 <ddarius> :t uncurry (liftM2(,))
13:10:20 <ski> @type uncurry (liftM2 (,))
13:10:20 <shachaf> parcs: That would depend on what m is.
13:10:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
13:10:21 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
13:10:23 <trinithis> @faq haskell @faq haskell
13:10:23 <lambdabot> The answer is: Yes! Haskell can do that.
13:10:48 <sipa1024> @djinn (m a, m b) -> m (a, b)
13:10:48 <lambdabot> -- f cannot be realized.
13:11:09 <Twey> Djinn is not so good with typeclasses
13:11:10 <ski> @djinn Monad m => (m a,m b) -> m (a,b)
13:11:11 <lambdabot> -- f cannot be realized.
13:11:24 <Twey> @djinn (Maybe a, Maybe b) -> Maybe (a, b)
13:11:24 <lambdabot> f (a, b) =
13:11:24 <lambdabot>     case a of
13:11:24 <lambdabot>     Nothing -> Nothing
13:11:25 <lambdabot>     Just c -> case b of
13:11:25 <lambdabot>               Nothing -> Nothing
13:11:26 <lambdabot>               Just d -> Just (c, d)
13:11:32 <Twey> Gah
13:11:41 <ski> .. what did you expect ?
13:11:44 <kuffaar> The cabal file contains: hs-source-dirs:    Source
13:11:49 <mreh> lol
13:11:55 <mreh> yeah, what did you expect
13:12:06 <Twey> ski: do a' <- a; b' <- b; return (a, b)
13:12:09 <kuffaar> Is that wrong?
13:12:10 <Twey> Er
13:12:13 <Twey> ski: do a' <- a; b' <- b; return (a', b')
13:12:24 <Twey> I assumed it knew that Maybe was a monad
13:12:46 <mauke> what, djinn?
13:12:51 <Twey> Yeah
13:12:52 <mreh> it couldn't do it when we told it m was a monad
13:12:52 <ski> it finds a definition in terms of `case' and the primitive operations
13:12:54 <ski> no lemmas
13:13:02 <Twey> Ah, alright
13:14:19 <ski> @djinn Functor f => (a -> b) -> (f a -> f b)
13:14:19 <lambdabot> f = fmap
13:14:22 <ski> @djinn Functor f => (a -> c) -> (f a -> f c)
13:14:22 <lambdabot> -- f cannot be realized.
13:14:51 <mreh> :t fmap
13:14:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:14:54 <mreh> is that why?
13:15:12 <ski> djinn doesn't really understand polymorphic class methods
13:15:26 <parcs> @pl liftM2 . liftM2
13:15:27 <lambdabot> liftM2 . liftM2
13:15:32 <mreh> oh I see, it thinks b is a type
13:15:41 <ski> (which are equivalent to data definitions with polymorphic arguments, i.e. higer-rank polymorphism)
13:16:16 <ski> it thinks `b' is a type variable that's distinct from `c'
13:16:25 <mreh> yeah
13:16:27 <Bynbo7> :t liftM2 . liftM2
13:16:27 <ski>   Functor f => ..
13:16:28 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
13:16:29 <ski> is more or less
13:16:47 <ski>   (forall a b. (a -> b) -> (f a -> f b)) -> ..
13:16:52 <ski> but djinn reads it as
13:16:55 <ski>   ((a -> b) -> (f a -> f b)) -> ..
13:17:12 <mreh> @slap djinn
13:17:12 * lambdabot is overcome by a sudden desire to hurt djinn
13:17:20 <Twey> Heh
13:17:25 <mreh> i was hoping for a nipple cripple
13:17:36 <Filosofem> it works, but i got the letter in reverse other. I cant add reverse to the last line because it wont give me the right result
13:17:42 <Filosofem> http://hpaste.org/raw/43086/fromlist
13:18:23 <ski> well, you could always rename that `fromList' to something else, and define `fromList' as calling that, then reverse
13:19:55 * ski wonder why there's a `+65' in that
13:20:17 <mreh> > char 65
13:20:18 <aristid> ord 'A' == 65
13:20:18 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
13:20:18 <lambdabot>    arising from the literal `6...
13:20:23 <aristid> > chr 65
13:20:24 <lambdabot>   'A'
13:21:08 <ski> (^ yeah i know .. it still looks very strange)
13:21:24 <parcs> @check (==) `ap` (chr . ord)
13:21:25 <lambdabot>   "OK, passed 500 tests."
13:21:25 <mreh> true :)
13:21:40 <ski> Filosofem : i think the `+65' is a mistake .. that was only something that was in the example because they wanted a list of characters
13:22:00 <ski> it's nothing to do with your `List' type and the three operations on it that you're to define
13:22:18 <aristid> :t chr . ord
13:22:20 <lambdabot> Char -> Char
13:22:29 <aristid> :t ord . chr
13:22:30 <lambdabot> Int -> Int
13:22:37 * ski can never remember which is which of `ord' and `chr' :)
13:22:39 <aristid> @check (==) `ap` (ord . chr)
13:22:41 <lambdabot>   "*Exception: Prelude.chr: bad argument: (-1)
13:22:48 <aristid> ski: i learned that from visual basic :)
13:23:04 <aristid> back in the time when i was using it
13:23:53 <ski> (hm .. well maybe it was `chr$' in C64 BASIC ..)
13:24:29 <parcs> i remember it as ord = the ordinal rep. of.. and chr = the character rep. of..
13:24:45 <hatds> function names tend to refer to their result value more often than not
13:26:11 <mauke> big exception: oct/hex in perl :-(
13:28:39 <ddarius> If you went to Perl for sanity and consistency, you'll fit right in because clearly you are insane as well.
13:29:11 <ddarius> (or you're a PHP programmer)
13:29:24 <Twey> Hahaha
13:29:27 * monochrom recalls chr$ too!
13:29:32 <mauke> hey, at least I won't have problems with ord/chr
13:29:38 <Twey> Oh gods, not Chr$
13:29:41 <mauke> (those work the same in perl)
13:29:58 <Twey> I spent several of my earlier programmer days wondering who Chris was
13:29:59 <shachaf> chr$
13:29:59 <shachaf> ?
13:30:08 <mtnviewmark> I try not to use ord & char --- fromEnum and toEnum!
13:30:10 <monochrom> is a function in BASIC
13:30:25 <Twey> shachaf: It's BASIC ‚Äî the $ indicates the return type is a string
13:30:31 <shachaf> Ah, BASIC.
13:30:32 * ddarius remembers chr$ as well but never had any misunderstandings about it.
13:30:34 <mauke> mtnviewmark: chr, not char
13:30:43 <monochrom> BASIC chr$ x = haskell [chr x]
13:30:53 <mtnviewmark> fingers type by themselves, apparently
13:31:04 <ddarius> That statement is actually legal Haskell.
13:31:29 <monochrom> typically string variables are all called a$, b$, c$ ...
13:32:11 <Twey> ddarius: Not quite ‚Äî type/constructor definition without a keyword
13:32:17 <Twey> It would be but for the case :√æ
13:32:27 <mauke> we're defining $
13:32:27 <ddarius> Twey: It's defining ($).
13:32:36 <Twey> Ooh, yes.
13:32:47 <Twey> But then doesn't ‚ÄòBASIC chr‚Äô require brackets?
13:32:51 <ddarius> No.
13:32:56 <Twey> Hrm, alright.
13:33:09 <ddarius> The syntax for patterns is almost exactly the syntax for expressions.
13:33:25 <ddarius> So please stop writing (Just x) >>= k = k x
13:33:26 <ski> (which is as it should be, imho)
13:33:28 * shachaf wishes the syntax for view patterns was nicer.
13:33:28 <monochrom> > let { Just right $ x = "hello" } in (Just () $ ())
13:33:30 <lambdabot>   "hello"
13:34:22 <monochrom> (Just x) >>= (k) = (k)x
13:34:27 <ski> shachaf : yeah, i'd like a declarative semantics of it, which explains what it would mean, in an expression
13:35:07 <Twey> ddarius: Heh, okay.
13:35:22 <kuffaar> Hey, is there any difference between putStr and putStrLn with regards to buffering?
13:35:29 <Twey> kuffaar: No
13:35:33 <kuffaar> Alright
13:35:42 <ddarius> monochrom: You're a far ways away from the von Neumann onion.
13:35:42 <Twey> But putStrLn includes a linebreak, which may trigger flushing if using LineBuffering
13:36:43 <monochrom> but then putStr "haha\n" triggers the same line flushing
13:38:10 <Filosofem> is there any function that gives the inverse of other? like ord --> char or char --> ord
13:38:11 <Filosofem> ?
13:38:32 <monochrom> who is "other"?
13:38:38 <ddarius> Filosofem: What should it give for putStrLn or const 3?
13:38:57 <Filosofem> Im not talking about every function
13:39:12 <Filosofem> in this particular case is char / ord
13:39:49 <ddarius> What would it's type be?
13:40:05 <dons> what i'm working on at the moment, http://donsbot.wordpress.com/2011/01/16/painless-np-complete-problems-an-embedded-dsl-for-smt-solving/ 
13:40:31 <Filosofem> :/ good way of telling me that it doesnt exist xD
13:40:57 <ddarius> dons: Are you going to steal Ed's ideas?
13:41:13 <Bynbo7> hey dons, you interested in looking at by new program for the binary trees shootout benchmark? it's three times faster than your corrent entry :)
13:41:32 <dons> Bynbo7: simonmar worked on some GC changes that make it a /lot/ faster, fwiw
13:41:37 <dons> but sure, if it is a valid entry, submit it.
13:41:38 <Bynbo7> though, i'm pretty sure they'll reject it
13:41:44 <dons> ddarius: from his ersatz system?
13:41:50 <dons> Bynbo7: prob. unnecessary then :-)
13:42:16 <dons> simonmar's work  http://www.reddit.com/r/haskell/comments/e7ao4/new_haskell_701_shootout_numbers/c16v4g6 
13:42:24 <ddarius> dons: Yes.  The StablePtr sharing stuff.
13:42:38 <Bynbo7> well, i want to give it a try. the way i've done it isn't so far off the way the C entry does it... sort of.
13:42:47 <dons> ah yes, i'll certainly be stealing some sharing code from somewhere
13:42:56 <dons> accelerate has a similar thing, as does SBV (a galois project)
13:43:03 <aristid> Bynbo7: why do you think they will reject it?
13:43:19 <dons> as well as compiling to SMT-LIB (not yices)
13:43:19 <Bynbo7> i dislike that for C, they're allowed to use APR, but we're not even allowed to tune the GC
13:44:10 <Bynbo7> aristid: well, i'm pretty sure they want you to produce a native binary tree datatype. i'm using an array with binary heap ordering :)
13:45:03 <Bynbo7> dons: thanks for the link, i managed to miss that comment
13:45:45 <hatds> what do you mean?  more examples of such pairs or an honest 'function' that takes in functions and returns these inverses?
13:45:46 <aristid> Bynbo7: what's APR?
13:45:54 <Bynbo7> Apache Runtime Library
13:46:10 <hatds> oops disregard
13:46:25 <Bynbo7> aristid: and we're ot allowed to use anything not provided by the default install of ghc (or possibly the platform, i can't remember which)
13:47:07 <aristid> Bynbo7: weird
13:48:02 <monochrom> the shootout admin (a human) is afraid that machine-generated code by ghc surpasses human-written code.
13:48:51 <aristid> monochrom: i.e. he is political
13:49:07 <geheimdienst> monochrom: by machine-generated you mean the c code ghc emits with via-c ...?
13:49:17 <monochrom> I think it's just human self-dignity. wouldn't want to be told inferior to "mere" machine
13:50:04 <monochrom> and then there is the machine-automated memory management (gc) vs hand-written malloc and free.
13:50:06 <geheimdienst> computers/think/submarines/swim/etc.
13:50:27 <geheimdienst> "omg i can't swim as well as a submarine" ... uh, yeah. that's why we built them.
13:53:22 <ddarius> geheimdienst: I thought the reason we built them is because you can't sink ships as well as they do.
13:53:49 <monochrom> "omg i can't sink ships as well as a submarine does" :)
13:54:27 <monochrom> http://www.merriam-webster.com/dictionary/intelligence #5 is very awakening
13:55:14 <ddarius> Ugh.  Merriam-Webster has a "user-submitted" words section apparently.  I just got subjected to "nonversation."
13:55:28 <Rotaerk> monochrom, lol.
13:55:31 <geheimdienst> @slap ddarius
13:55:31 * lambdabot slaps ddarius with a slab of concrete
13:55:40 <geheimdienst> suppose a human could stay submerged for 10 hours and a submarine for 5 hours. there'd be not much point to these submarines
13:55:51 <Bynbo7> dons: is the behaviour of -H documented somewhere? +RTS --help isn't particularly helpful with what -H by itself does
13:56:15 <hatds> ghc user manual should have it
13:57:00 <geheimdienst> ... for sinking ships or whatever purpose
13:57:39 <ddarius> geheimdienst: As long as you can do that and fire torpedoes, sure.
13:58:30 <ddarius> (And you change 10 hours to, like, 10 months.)
13:58:39 <dons> reddit's a tough crowd these days.  http://www.reddit.com/r/programming/comments/f3fpc/painless_npcomplete_problems_an_embedded_dsl_for/ 
13:58:41 <hatds> huh, the documentation says default for -H is '0'
14:00:17 <ddarius> dons: I read an interesting paper about HOAS recently, but, unfortunately it's probably too hi-tech to be directly relevant to a Haskell program.
14:01:35 <geheimdienst> ddarius, tell that to dijkstra. i don't think he'd say that torpedoes are the point
14:02:36 <ddarius> "A Type-theoretic Foundation for Programming with Higher-order Abstract Syntax and First-class Substitutions" or, in fact, probably any of the papers behind Beluga: http://complogic.cs.mcgill.ca/beluga/
14:03:36 <geheimdienst> (about the length, i said "suppose". early submarines were more like ships that could for a short while retreat below the surface. technical progress then made the times longer)
14:03:39 <j-invariant> I don't get the big deal about HOAS
14:03:41 <ddarius> geheimdienst: Dijkstra should have been a good trooper like Turing.
14:04:25 <Phyx-> didn't turing kill himself?
14:04:34 <ddarius> Phyx-: Most likely.
14:04:43 * geheimdienst now has the image in his mind of a turing machine with torpedo launchers
14:05:06 <dankna> The torpedo launchers are for when you trigger undefined behavior, obviously?
14:05:12 <Phyx-> ddarius: doesn't sound like much of a trooper :/
14:05:43 <j-invariant> it could fire them iff the program doesn't halt
14:05:48 <ddarius> Phyx-: He worked on cracking the Enigma code in World War II among other such things.
14:05:53 <geheimdienst> dankna: the launchers are just to make ddarius happy
14:05:59 <dankna> heh, okay
14:06:21 <ddarius> geheimdienst: I'm an airman.  We don't use torpedoes.
14:06:22 <Phyx-> ddarius: oh, you meant it like that
14:06:51 <Adamant> ddarius: aktually.
14:06:51 <Adamant> '
14:06:53 <Adamant> ...
14:07:18 <Adamant> airdropped torps have been used for a long time and still are
14:07:24 <Adamant> only now for sub killing
14:07:53 <Bynbo7> dons: the link for the text "user-facing layer" is a little messed up in your post
14:08:07 <Bynbo7> the u isn't included in the link
14:08:41 <ddarius> Adamant: But does the Air Force use torpedoes, or do the Navy planes use torpedoes.
14:08:55 <geheimdienst> adamant, discussing technicalities which are besides the point with ddarius ... you're making the same mistake as i did
14:09:13 <ddarius> My work here is done.
14:09:52 <Adamant> ddarius: both
14:09:56 * geheimdienst hands ddarius a turing machine with torpedo launchers strapped to a rocket. do you like that now, airman?
14:09:58 <Adamant> mostly Navy though
14:10:54 <geheimdienst> if turing walks in here, he'd be very unhappy what we did with his machine
14:11:02 * ddarius just came across that Demaine paper about Tetris.
14:11:17 <ddarius> geheimdienst: We're lambda-folk anyway.
14:11:17 <geheimdienst> "ohai i upgraded ur masheen. haz torpeedos nao"
14:11:44 <destur_> hi, noob here, anyone using leksah?
14:11:57 <ddarius> geheimdienst: And higher-order functions.
14:12:17 <Adamant> when things are in question, it's time to go back to Church
14:12:23 <Adamant> thank you, tip your waitress
14:13:23 <geheimdienst> we should upgrade the ram while we're at it
14:13:47 <uman> god ghc takes forever to compile
14:13:57 <Adamant> powered exoskeleton and titanium horns?
14:14:30 <ddarius> Adamant: Combining that and a line from Othello makes for -very- strange images.
14:14:56 <Adamant> ddarius: I had the same line flash through my head, but fortunately it fell out after a second
14:23:49 <kuffaar> Writing malware in Haskell - yay/nay?
14:23:56 <jmcarthur> i'm playing with the threadring benchmark. when i make it use 10000 threads and send the token around 50000 times using 2 cores, my cpu makes a cool sound. over the run of the program it rises in pitch (fairly rapidly).
14:24:07 <jmcarthur> just thought i'd share
14:24:16 <jmcarthur> kuffaar: haskell can do no wrong
14:24:29 <ddarius> jmcarthur: You can use that to debug/profile your programs in the future.
14:24:31 <kuffaar> "wrong" lies in the eyes of the beholder
14:24:35 <ddarius> Like ticky-ticky debugging.
14:24:37 <kuffaar> Unless we are talking about a formal system
14:24:39 <kuffaar> Which we are not
14:24:41 <ddarius> @wn mal-
14:24:41 <lambdabot> No match for "mal-".
14:26:24 <jmcarthur> ddarius: there's a lot of deviation in the runtime it seems, and i have been able to predict the timing based on the sound. sometimes the sound goes straight up, but other times it kind of sounds... like a car that's having trouble starting
14:27:03 <geheimdienst> what does the cpu usage graph look like ...?
14:27:05 <jmcarthur> but higher pitched. it only hesitates; it doesn't sound like it's "trying a few times"
14:27:28 <jmcarthur> i haven't checked that. it would have to be a very fine grained monitor
14:27:58 <Bynbo7> jmcarthur: is that my thread-ring entry?
14:28:07 <Bynbo7> (Alex Mason)
14:28:15 <jmcarthur> it's only a few seconds total, and the sound only happens at the beginning (as it creates threads and then consolidates them to a single OS thread? maybe i should check threadscope)
14:28:19 <jmcarthur> Bynbo7: yeah
14:29:32 <Bynbo7> it sticks everything onto a single core to avoid the various overheads that context switching, and migrating threads from one core to another introduces
14:31:30 <jmcarthur> i assume that was not a complete thought :)
14:31:59 <Bynbo7> hmm?
14:32:13 <jmcarthur> "and migrating threads from one core to another introduces"  <-- nothing follows that
14:32:35 <mtnviewmark> anyone here deeply familiar with hs-plugins?
14:32:50 <mtnviewmark> I seem to be beating my head against it, so I must not be understanding something in it
14:33:12 <Bynbo7> jmcarthur: it's ambiguous, if you read it how i would have said it, it makes sense :P
14:33:41 <jmcarthur> i fail to form a complete sentence out of that in my head :P
14:33:50 <jmcarthur> or a complete thought even
14:33:56 <applicative> jmcarthur, comma before the last word, which should be introduce
14:33:57 <lambdabot> applicative: You have 1 new message. '/msg lambdabot @messages' to read it.
14:34:00 <Bynbo7> remove the , then
14:34:22 * ddarius understood.
14:34:32 <jmcarthur> ah!
14:35:36 <jmcarthur> to avoid the various overheads that ((context switching) and (migrating threads from one core to another)) introduces
14:35:51 * geheimdienst wonders about marrying irc and a wiki, to edit messages after they were sent ...
14:36:39 <jmcarthur> geheimdienst: i've been tempted to rig up my client to try to understand peoples' corrections, like when they say "*corrected version", and replace things they said formerly with their corrected versions
14:36:59 <jmcarthur> so liek if i said this
14:37:01 <jmcarthur> *like
14:37:12 <jmcarthur> it would replace what i said with "so like if i said this"
14:37:44 <jmcarthur> would require some intelligent matching algorithm, levenstein or something maybe
14:37:57 <jmcarthur> *Levenshtein
14:38:55 <Phyx-> what if it targeted multiple corrections?
14:39:05 <Phyx-> leik if i do liek this?
14:39:07 <Phyx-> *like
14:39:13 <ddarius> jmcarthur: Just tell everyone to use accurate ed commands.
14:39:23 <geheimdienst> you might get halfway there if you run incoming messages through a spellchecker library. if it flags a word, that's a prime candidate for any corrections ...
14:39:46 <geheimdienst> Phyx-: this very rare, isn't it ...
14:39:55 <ddarius> geheimdienst: Or perhaps one should just run all IRC through spellchecking regardless and ignore corrections entirely.
14:40:18 <geheimdienst> uh ...
14:40:31 <Phyx-> heheh
14:40:50 <geheimdienst> depending on the quality of the dictionary, conversations might rapidly become manatee-esque 
14:41:05 <jmcarthur> heh
14:43:03 <jmcarthur> i also sometimes correct with "s/leik/like/". maybe for Phyx-'s example it could just be "s/leik/like/g"
14:43:11 <ddarius> geheimdienst: I doubt that.  It would probably improve my experience, though I would no longer be able to tell which people say "u r lam"
14:45:26 <geheimdienst> suppose we make a client that allows edtiing and sends the corrections as "*allows editing and"
14:46:06 <geheimdienst> 3 words of context should make it fairly unique, and it degrades nicely. if your client doesn't support it, the asterisk correction is perfectly readable
14:46:43 <geheimdienst> if the client has any doubt, it could just not correct stuff and display the "*blah" message for you to figure out
14:46:59 <jmcarthur> i'm just thinking that since most people would not be using such a client or writing specifically for it, it would be nicer if it attempted to be smart-ish
14:47:12 <geheimdienst> that's true
14:47:18 <jmcarthur> maybe the client could show the original and speculative correction near each other
14:48:06 <geheimdienst> that's a good idea
14:48:16 <kamaji> What type should I use for a real number?
14:48:27 <jmcarthur> kamaji: how precise does it need to be?
14:48:41 <jmcarthur> kamaji: and you *really* need a real number? are you sure you can't get by with Rational, for example?
14:48:51 <jmcarthur> or even just Double or Float?
14:49:11 <kamaji> oh probably
14:49:15 <kamaji> I was just wondering, hehe
14:49:20 <jmcarthur> kamaji: there is CReal if you need precise, computable reals, but it's kind of slow
14:49:25 <Bynbo7> always use Double, unless you need to save space
14:49:28 <jmcarthur> s/kind of/very/
14:49:31 <kamaji> mainly because if there are infinite irrationals, how does haskell deal with that?
14:49:40 <jmcarthur> Bynbo7: or unless you need more accuracy than floating point can offer
14:49:49 <ddarius> data UnitInterval = Zero | One | Split (Stream UnitInterval)
14:50:02 <Bynbo7> jmcarthur: i meant when choosing between Float and Double
14:50:05 <jmcarthur> kamaji: you can't express all reals on a computer
14:50:39 <jmcarthur> > sqrt 2 :: CReal
14:50:40 <Bynbo7> you can express them, you may not be able to represent them
14:50:41 <lambdabot>   1.4142135623730950488016887242096980785697
14:50:52 <jmcarthur> > sqrt 2 * sqrt 2 :: CReal
14:50:54 <lambdabot>   2.0
14:51:00 <kamaji> so you basically just store the expression?
14:51:00 <shachaf> geheimdienst: The "*" syntax for corrections is abominable.
14:51:01 <jmcarthur> > sqrt 2 * sqrt 2 :: Double
14:51:03 <lambdabot>   2.0000000000000004
14:51:14 <jmcarthur> kamaji: it can be more involved than that
14:51:23 <kamaji> oh dear~
14:51:29 <jmcarthur> but, well, that's kind of the idea at least
14:51:31 <kamaji> i'll just throw a Num in there and hope for the best :D
14:51:42 <kamaji> or is that a heinous haskell crime
14:51:44 <jmcarthur> polymorphic code is usually the best idea if you can help it :)
14:51:45 <mreh> @src (<*>) []
14:51:45 <lambdabot> Source not found. Maybe you made a typo?
14:51:49 <Bynbo7> kamaji: Num is a class, it's not a type
14:51:54 <kamaji> oh whoops
14:52:03 <kamaji> fair point :D
14:52:23 <Bynbo7> if you just say Num, then the compiler will just choose which ever Num makes sense (usually Integer or Double)
14:52:24 <kamaji> but it covers things like CReal too?
14:52:36 <jmcarthur> kamaji: only constrain the type as high up in the program as you can, as a not-always-applicable rule of thumb
14:52:42 <jmcarthur> kamaji: CReal is indeed an instance of Num
14:52:46 <kamaji> and I guess it's always possible to force those if you need, right?
14:52:48 <kamaji> ok coooolbeans
14:52:49 <kamaji> thanks
14:54:58 <ddarius> I guess that should have been NegOne rather than Zero.
14:55:18 <revenantphx> hurray for taking school projects too seriously >:D
14:55:40 <engla> shachaf: s// is worse
14:55:53 <revenantphx> Why do people do that? I don't quite get it.
14:56:05 <revenantphx> I tend to just use an asterisk, which isn't especially clear sometimes.
14:56:25 <ivanm> revenantphx: if you want to replace more than one word, etc.
14:56:59 <shachaf> engla: How is it worse?
14:57:34 <Phyx-> because people never get s// right away, but everyone intuitively gets *<correction>
14:57:42 <engla> verbose to read/type and redundant
14:57:56 <aristid> Phyx-: huh? who does not get s///?
14:57:59 <engla> Phyx-: yeah and I wonder why the * is so universally understood
14:58:59 <Phyx-> aristid: most people don't, atleast not right away.
14:59:16 <aristid> Phyx-: on technical irc channels?
14:59:37 <Phyx-> yes, why is it so surprising?
14:59:39 <ivanm> aristid: there's nothing really intuitive about it
14:59:49 <ivanm> people just pick it up from the context
15:00:03 <aristid> ivanm: but don't most programmers use regular expressions sometimes?
15:00:05 * engla thinks it's partly an injoke
15:00:07 <jmcarthur> i'd say as long as people are able to pick it up it doesn't matter. they only have to learn it once
15:00:15 <revenantphx> I think * is too simple for people to confuse at all.
15:00:25 <aristid> sed -e 's/a/b/'
15:00:28 <ivanm> aristid: I use them very rarely...
15:00:30 <revenantphx> For instance if I see a correction with s// I understand what it is off the bat, but
15:00:35 <aristid> perl -p -e 's/a/b/'
15:00:36 <revenantphx> I'm like "well what's the s for"
15:00:47 <aristid> s for substitute
15:00:49 <jmcarthur> but you got the gist
15:00:51 <ivanm> in fact, I first saw the s/a/b/ stuff here as a correction ;-)
15:00:53 <revenantphx> aristid: I know >_>
15:01:02 <parcs> s/// is made for machines to parse. i don't know why people use it when conversing with humans
15:01:09 <Phyx-> aristid: i can count of my fingers the amount of times i've used regexp
15:01:11 <jmcarthur> because it's unambiguous
15:01:14 <shachaf> parcs: Because it's precise?
15:01:21 <sipa1024> and concise
15:01:23 <engla> parcs: exactly, wasting human communcation skill
15:01:24 <parcs> yeah, like the english language
15:01:27 <shachaf> parcs: It's certainly less of an abomination thatn asterisks.
15:01:31 <aristid> Phyx-: i use them all the time when dealing with text files on the command line :)
15:01:33 <shachaf> s/tn/n/
15:01:49 <aristid> but on irc i actually tend to ues -x+y
15:01:50 <revenantphx> Guys, great news.
15:01:53 <aristid> -ues+use
15:01:57 <revenantphx> I have a better alternative for * and s//
15:01:59 <revenantphx> are you ready for this?
15:02:08 <revenantphx> "Oh hey there, my naem is Phil"
15:02:13 <parcs> the english language is already ambiguous; using s/// doesn't make it any less so
15:02:15 <revenantphx> Oh sorry, I meant "name".
15:02:16 <revenantphx> WHOA.
15:02:16 <jmcarthur> aristid: aside from diff tools i don't think i've ever seen that
15:02:18 <geheimdienst> aristid, that is a little less to type than s//. i like it
15:02:19 <revenantphx> :P
15:02:28 <aristid> jmcarthur: -x+y is pretty obvious tho
15:02:32 <jmcarthur> yeah
15:02:38 <revenantphx> aristid: what are you, a VCS?
15:02:38 <geheimdienst> revenantphx: too much to type :)
15:02:41 <jmcarthur> somewhat
15:02:42 <revenantphx> geheimdienst: ;)
15:02:47 <ivanm> aristid: only works if x and y are in Num :p
15:02:50 <aristid> revenantphx: yes, "git" is my second name.
15:03:07 <revenantphx> From now on, all IRC messages are fully forkable/cloneable git repositories.
15:03:08 <ivanm> well, you certainly act like one sometimes :p
15:03:15 <jmcarthur> parcs: no, but s/// itself is unambiguous. it doesn't have to make anything else less ambiguous...
15:03:31 <jmcarthur> > -a+b
15:03:33 <lambdabot>   negate a + b
15:03:45 <aristid> :t \a b -> - a + b
15:03:46 <lambdabot> forall a. (Num a) => a -> a -> a
15:04:04 <geheimdienst> yeah, let's have lambdabot check all messages into some repository
15:04:23 <revenantphx> geheimdienst: no it needs to be a fully new implementation of IRC
15:04:23 <Phyx-> jmcarthur: * is also unambiguous is you maintain the rule to always correct whole words not parts of it
15:04:32 <jmcarthur> parcs: or is your point that english is already ambiguous so we shouldn't try to be unambiguous?
15:04:34 <revenantphx> all messages are send with an additional hash key to a git repository the server hosts.
15:04:46 <revenantphx> so every message can be forked.
15:04:48 <revenantphx> :)
15:04:51 <sipa1024> IRC is just multiplayer notepad
15:04:53 <aristid> i think some xmpp clients support s/a/b/
15:04:54 <jmcarthur> Phyx-: only for spelling corrections and typos though. not if you want to use an entirely different word
15:04:56 <sipa1024> s/notepad/$EDITOR/
15:05:10 <mauke> IRC is multiplayer cat
15:05:18 <kmc> emacs is multiplayer notepad
15:05:19 <revenantphx> But wait, what do you do for recursive fixing?
15:05:19 <geheimdienst> multiplayer vim
15:05:26 <revenantphx> Example:
15:05:31 <revenantphx> My naem is ...
15:05:32 <geheimdienst> mauke, what is multiplayer lolcat then?
15:05:35 <jmcarthur> Phyx-: and even then, it gets tougher for longer messages where there is more likely to be multiple choices of replacements
15:05:36 <revenantphx> ss/naem/name/
15:05:45 <revenantphx> s/ss/naem/name//s/naem/name//
15:05:48 <revenantphx> that's a bit awkward.
15:05:50 <Phyx-> jmcarthur: but that's rarely done with s/// on irc isn't it? it's mostly use to correct
15:05:59 <aristid> revenantphx: just use s/ss/s/
15:06:06 <Phyx-> jmcarthur: that's true
15:06:12 <jmcarthur> i normally use * for typo correction, but if it will lead to ambigiuity i use s///
15:06:15 <aristid> revenantphx: also you would have to escape the inner /
15:06:21 <shachaf> kmc: What's multiplayer about emacs?
15:06:22 <revenantphx> aristid: :)
15:06:25 <mauke> revenantphx: use different delimiters
15:06:28 <revenantphx> shachaf: tetris!
15:06:30 <kmc> doesn't emacs-server support multi-attach?
15:06:32 <kmc> maybe not
15:06:35 <mauke> s!foo!bar!, s{foo}{bar}
15:06:39 <kmc> i kind of assumed it does everything screen does
15:06:47 <geheimdienst> jmcarthur: but s// can be ambiguous two. suppose there's two instances of a word ...
15:06:49 <revenantphx> Let's just all use sed scripts for corrections TT_TT
15:06:50 <geheimdienst> s/two/too
15:06:54 <revenantphx> rofl.
15:06:56 <jmcarthur> geheimdienst: then capture its context
15:06:58 <revenantphx> expressions I guess.
15:07:09 <revenantphx> At least we're not using regexp.
15:07:12 <aristid> geheimdienst: include some context then
15:07:23 <aristid> geheimdienst: you can use groups to make it less tedious
15:07:28 <jmcarthur> oh god
15:07:44 <geheimdienst> but this would have to be enforced by the client ...
15:07:59 <jmcarthur> it wouldn't have to be enforced
15:08:05 <aristid> geheimdienst: well, it's your responsibility to produce correct code
15:08:20 <jmcarthur> at least... my idea is for a client that detects this stuff, not one that type checks it :P
15:08:20 * geheimdienst hacks the irc clients of the world to pop up "Are you sure?" on each message-send
15:08:42 <ski> aristid : dynamic typer ;P
15:09:04 <revenantphx> At least OS X has built in spellcheck in all Cocoa apps.
15:09:06 <revenantphx> Helps out a bit.
15:09:06 <aristid> ski: you could propose a parsec-based alternative to s/// :)
15:09:19 <revenantphx> aristid: I knew parsec would come up.
15:09:24 <jmcarthur> if your speaking from the viewpoint of the client that's sending it, you might as well just have the client allow you to edit the text directly in the chat log and the client could generate an unambiguous correction string on your behalf
15:09:29 <jmcarthur> *you're
15:09:36 <revenantphx> ...irony.
15:09:37 <Phyx-> T9 for irc :P
15:09:44 <Phyx-> should produce some fun messages :)
15:09:49 <revenantphx> jmcarthur: that's a good idea!
15:10:13 <sprinkles> this chat room is boring
15:10:17 <aristid> jmcarthur: s/your/you're/ or -your+you're would have been easier to apply for my execution model :)
15:10:35 <aristid> jmcarthur: i had to search the word to be replaced, and i searched from the back of the sentence :/
15:10:37 <ddarius> geheimdienst: Incidentally, s/two/too/ would have done the right thing in that example.
15:10:42 <jmcarthur> aristid: fortunately, *you're was pretty clear ;)
15:10:42 <Bynbo7> sprinkles: i wouldn't expect anyone who calls it a chatroom to find it interesting ;)
15:10:46 <jmcarthur> aw
15:10:48 <ddarius> s/two/too/g would have done the wrong thing.
15:10:48 <ski> we need more talk about how to use advanced type system features for this
15:11:08 <sprinkles> lol... true
15:11:09 <Phyx-> jmcarthur: yeah, but the idea was, to generate something someone with a different client could process without the help of a computer
15:11:17 <jmcarthur> yeah
15:11:25 <aristid> ski: so we should use agda instead?
15:11:37 <jmcarthur> Phyx-: i'm talking mainly about heuristics, but there's no reason not to try being precise *and* human readable
15:11:42 <jmcarthur> when possible at least
15:11:45 <ski> well, i was thinking maybe GADTs
15:11:50 <Phyx-> agreed
15:12:00 <geheimdienst> jmcarthur: good idea. you'd have some simple user interface for correcting, and what gets sent to irc is an unambiguous s// command
15:12:07 <aristid> ski: can we get concise syntax too?
15:12:16 <ddarius> All IRC statements need to be sent with a proof of correct spelling and grammar.
15:12:19 <jmcarthur> geheimdienst: or a maybe ambiguous one if the unambiguous one is too unweildly
15:12:33 <ski> aristid : maybe semi-concise with TH
15:12:35 <jmcarthur> geheimdienst: so long as the client has good heuristics for it
15:13:07 <aristid> ski: we don't need to restrict us to the confines of haskell
15:13:34 <ski> oh .. i thought we wanted to use Haskell, if it wasn't too cumbersome
15:13:44 * ddarius suggests PVS.
15:14:20 * Phyx- suggests CLIPS
15:14:21 <revenantphx> ddarius: they should be signed and verified as well.
15:14:30 <Phyx-> it's perfect for this kinda rule based stuff
15:14:49 <revenantphx> "And so #haskell split from IRC to go write it's own chat protocol, venturing away, never to be seen again"
15:14:54 <geheimdienst> revenantphx: how about peer-reviewed?
15:15:12 <revenantphx> "To this day, in the #help rooms, it is told of the mythical faraway land of Haskell relay chat with too many features"
15:15:19 <aristid> geheimdienst: that's a method not sufficiently based in category theory
15:15:27 <revenantphx> "and enough extensions to potentially implode and create a black hole"
15:15:41 <ski> (revenantphx : well, maybe we can avoid the bug that is unknowable maximum message length, at least ..)
15:15:44 <revenantphx> "of a chat protocol that also serves as a kernel for over 30 simple OS"
15:15:58 <revenantphx> "and that you can play tetris in"
15:16:06 <aristid> revenantphx: considered writing science fiction? :P
15:16:08 <revenantphx> "an almost... emacs... of irc"
15:16:14 <geheimdienst> revenantphx: could you elaborate on the role of lambdabot in that new system?
15:16:21 <revenantphx> lambdabot IS the new system.
15:16:22 <ski> revenantphx : maybe you should send that to ManateeLazyCat ?
15:16:28 <revenantphx> It will no longer be a bot...
15:16:37 <revenantphx> it will be the supreme AI arbiter in control of the HRC system.
15:16:39 <Phyx-> lambdabot is the architect...
15:16:47 <Phyx-> it runs the #Haskell system
15:16:50 <jmcarthur> now that #haskell has been turned into #haskell-blah, i'm out
15:16:57 <jmcarthur> mission accomplished
15:16:58 <sprinkles> How much math do you need to know in order to understand Haskell?  Everything I know about category theory comes from wikipedia.
15:17:02 <revenantphx> I think you're missing the point though.
15:17:08 <revenantphx> WE won't build HRC.
15:17:09 <revenantphx> No.
15:17:12 <revenantphx> We'll educate lambdabot.
15:17:13 <Bynbo7> sprinkles: none
15:17:16 <revenantphx> Until she can build it for us.
15:17:17 <j-invariant> sprinkles: you don't have to know any category theory
15:17:31 <sprinkles> It must help though, right?
15:17:32 <geheimdienst> sprinkles: i don't know any CT, and i'm happily hacking xmonad modules ...
15:17:40 <Bynbo7> sprinkles: eventually, it can
15:18:02 <Bynbo7> i've been using haskell for three years now, i know next to no CT
15:18:02 <revenantphx> You don't need category theory to understand Haskell, though you may need it to understand #haskell.
15:18:14 * geheimdienst seconds that
15:18:14 <ddarius> @hackage Barracuda
15:18:14 <lambdabot> http://hackage.haskell.org/package/Barracuda
15:18:25 <geheimdienst> @remember revenantphx You don't need category theory to understand Haskell, though you may need it to understand #haskell.
15:18:25 <lambdabot> It is stored.
15:18:31 <revenantphx> whooo!
15:18:33 <ski> Bynbo7 : but you know how to use `Functor', right ?
15:18:36 <Phyx-> lol, you need an advanced math degree to understand #haskell sometimes
15:18:40 <j-invariant> sprinkles: You have to be really clever to actually use category theory in programming, None of the category theory I learned has become useful in any programming I did. But other people have used it for breakthroughs
15:19:00 <Bynbo7> ski: yes, and i am blissfully unaware of its role in CT
15:19:02 <Bynbo7> :P
15:19:51 <j-invariant> sprinkles: also most of category deosn't seem to have any computational content, it's just organizational. So you're trying to find things in the small fractional of category theory which actally computes stuff..
15:19:53 <Phyx-> i don't know why, but everytime i start reading my CT book, i fall asleep
15:19:55 <kmc> @remember revenantphx You don't need category theory to understand Haskell, though you may need it to understand #haskell.
15:19:56 <lambdabot> It is forever etched in my memory.
15:19:57 * ski was going to ask Bynbo7 whether he/she/it knows how to use natural transformations in Haskell, but will refrain from asking now ..
15:19:58 <Phyx-> good times..
15:20:03 <kmc> that's a great way to put it revenantphx
15:20:15 <Bynbo7> ski: he:
15:20:19 <engla> I just found this nice book in category theory, reading it: http://kaizer.se/volatile/BasicCategoryTheory.djv (Ben Pierce)
15:20:21 <Bynbo7> > map pred "Bynbo7"
15:20:22 <lambdabot>   "Axman6"
15:20:23 <revenantphx> kmc: You got ninja'd ;)
15:20:26 <kmc> i see
15:20:30 <kmc> well now it's double quoted
15:20:30 <shachaf> kmc: Already @remembered once.
15:20:47 <Phyx-> engla: yes, that's the one i bought on amazon
15:20:49 <shachaf> > "double quoted?"
15:20:50 <lambdabot>   "double quoted?"
15:20:51 <geheimdienst> Bynbo7: :-o
15:20:54 <kmc> a lot of people write about maths using Haskell syntax; then other people read it and complain they can't understand Haskell
15:20:58 <ski> Bynbo7 : what did you do to `pred' !?
15:21:40 <ddarius> revenantphx: The Barracuda package link was for you above.
15:21:41 <monochrom> Bird writes about haskell using maths syntax :)
15:21:45 <Bynbo7> :t (***)
15:21:45 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:21:52 <Bynbo7> :t (&&&)
15:21:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:22:16 <revenantphx> Oh I see, thanks ddarius.
15:22:19 <Bynbo7> @let rename = unzip . map (pred &&& succ)
15:22:20 <lambdabot>  Defined.
15:22:26 <Bynbo7> > rename "Axman6
15:22:27 <lambdabot>   <no location info>:
15:22:27 <lambdabot>      lexical error in string/character literal at end o...
15:22:31 <Bynbo7> > rename "Axman6"
15:22:33 <lambdabot>   ("@wl`m5","Bynbo7")
15:22:45 <hpc> :t rename
15:22:47 <lambdabot> forall a. (Enum a) => [a] -> ([a], [a])
15:22:59 <geheimdienst> > map succ "Bynbo7"
15:23:00 <lambdabot>   "Czocp8"
15:23:09 <Phyx-> damnit, and again ghc proves it was right all along and makes me out to be a fool
15:23:15 <hpc> > rename hpc
15:23:16 <lambdabot>   Not in scope: `hpc'
15:23:21 <hpc> > rename "hpc"
15:23:23 <lambdabot>   ("gob","iqd")
15:23:27 <hpc> gob
15:23:32 <Bynbo7> heh, i like it
15:23:40 <geheimdienst> > rename "geheimdienst"
15:23:42 <lambdabot>   ("fdgdhlchdmrs","hfifjnejfotu")
15:23:54 <revenantphx> > rename "revenantphx"
15:23:55 <hpc> geheimdienst: oh hey, you are an icelandic landmark!
15:23:56 <geheimdienst> ... military-grade encryption
15:23:56 <lambdabot>   ("qdudm`msogw","sfwfobouqiy")
15:24:00 <Phyx-> > rename "Phyx-"
15:24:02 <lambdabot>   ("Ogxw,","Qizy.")
15:24:03 <ski> > mapAndUnzipM (Just . (pred &&& succ)) "Axman6"
15:24:05 <geheimdienst> hpc, lol :)
15:24:05 <revenantphx> Qizy!
15:24:05 <lambdabot>   Just ("@wl`m5","Bynbo7")
15:24:06 <revenantphx> I like it
15:24:21 <Phyx-> hahaha
15:24:33 <mauke> > rename "mauke"
15:24:35 <lambdabot>   ("l`tjd","nbvlf")
15:24:52 <shachaf> > rot13 "Shachaf"
15:24:53 <Qizy> :t pred
15:24:53 <kuffaar> https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/Console.hs <- I don't really grasp how to use my runLockedConsole :: MonadIO m => LockedConsole m a -> m a to establish a synchronised console printing environment in https://github.com/epicvrvs/Veles/blob/master/Source/Veles/Server.hs runServer. Now, the signature of the function is going to change from runServer :: Int -> IO () to runServer :: Int -> LockedConsole IO (), right? But I can't just a
15:24:53 <kuffaar> dd runLockedConsole $ in the beginning, prior to the withSocketsDo $, the monadic stack does not match :(
15:24:54 <geheimdienst> > map succ . succ "mauke"
15:24:54 <lambdabot> forall a. (Enum a) => a -> a
15:24:55 <lambdabot>   "Funpuns"
15:24:55 <lambdabot>   Couldn't match expected type `[a]'
15:24:55 <lambdabot>         against inferred type `GHC.Types...
15:25:12 <kuffaar> Does this require a lift or something like that?
15:25:22 <Qizy> :t pred
15:25:23 <lambdabot> forall a. (Enum a) => a -> a
15:25:27 <ski> Qizy : yeah, maybe more time should be spent on making GHC convince you better of why it's right and you're wrong ..
15:25:38 <geheimdienst> shachaf: was that intentional? "fun puns"?
15:25:45 <geheimdienst> ... when you chose your nick
15:25:58 <shachaf> geheimdienst: It was unintentional.
15:26:33 <Qizy> ski: I get why it's right now, just didn't agree with it before. Me and him dissagree alot
15:26:36 <aristid> > succ "mauke"
15:26:38 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
15:26:38 <lambdabot>    arising from a use of `...
15:26:53 <aristid> > (succ . succ) . "mauke"
15:26:54 <lambdabot>   "ocwmg"
15:27:00 <ski> Qizy : yeah, that's what i mean .. improve GHC's communication skills
15:27:05 <ddarius> ski: That's silly.  GHC is always right.  It should not need to convince you.
15:27:06 <aristid> > succ . succ . "mauke"
15:27:08 <lambdabot>   "ocwmg"
15:27:35 <mauke> preflex: help rot13
15:27:35 <preflex>  rot13 TEXT
15:27:42 <mauke> preflex: rot13 mauke
15:27:42 <preflex>  znhxr
15:28:02 <shachaf> > text . rot13 . succ . "mauke"
15:28:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:28:03 <lambdabot>         against inferred ty...
15:28:11 <aristid> mauke: your secret name has been uncovered, znhxr
15:28:20 <shachaf> > text . rot13 . (succ .) $ "mauke"
15:28:21 <lambdabot>   aoiys
15:28:30 <cdsmithus-mobile> That . works because of Calendar.  Lambdabot thinks . = fmap
15:28:49 <cdsmithus-mobile> Umm, Cale
15:28:55 <aristid> cdsmithus-mobile: autocorrection for the fun?
15:29:09 <Phyx-> ski: ah, i would say 90% of the time ghc generates perfectly understandable errors, but it's those left over 10%....
15:29:19 <shachaf> cdsmithus-mobile: lambdabot thinks the truth.
15:29:21 <Phyx-> ski: but this was mostly a make error
15:29:39 <cdsmithus-mobile> Yes.  No idea how you kids can stand texting. :)
15:29:47 <ski> Phyx- : it would be nice to have type error slicing
15:30:28 <Phyx-> ski: type error slicing? don't know that one
15:30:30 * ski makes error
15:30:35 <geheimdienst> ZnHxr = ZincHaxor?
15:30:36 <kmc> GHC gives pretty good error messages but very bad advice
15:30:57 <chessguy> @type unfoldTree
15:30:58 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
15:30:59 <kmc> when GHC says "Probable fix: Add an instance (Num T)", this is almost never a reasonable fix
15:31:06 <aristid> cdsmithus-mobile: i can stand texting, but i don't like it :)
15:31:10 <Phyx-> oh, silly me, i modified the .cabal file instead of the .in file
15:31:12 <ski> Phyx- : the idea is that instead of reporting the place in the code where the type error is *found* (which can far away from the actual error the user made)
15:31:13 <ddarius> ski: There's also Chameleon's type debugger which can be used with Haskell.
15:31:23 <cdsmithus-mobile> "Suggestion : add an instance for Number ..."
15:31:43 <monochrom> Suggestion: take a logic course
15:32:09 <cdsmithus-mobile> Grr... Num
15:32:20 <ski> Phyx- : the system identifies all the places in the code which contributes to the error : at least one of those must be changed to fix the error, and none of the places are irrelevant (as far as from what can possibly be inferred from the code (it can't read your mind about what you wanted))
15:32:42 <ski> ddarius : how does that present type errors ?
15:34:50 <Phyx-> ski: so a simple example would be \f -> (f 1, f 'a') it would show both applications of f that caused the error "Expected Int but got Char" ?
15:34:50 <ddarius> http://arxiv.org/abs/cs/0311023
15:35:08 <ski> Phyx- : yes
15:35:16 <ddarius> Which does do some type error slicing like stuff, but is also interactive.
15:35:47 <ddarius> And allows you to see the types of local variables.
15:35:47 <Phyx-> ski: neat, but wouldn't that easily produce information overload?
15:35:58 <ski> Phyx- : and if you pass an `Int' to a function, which passes it to another, which tries to use it as a function (e.g. missing argument somewhere), then you'll get at least those three locations listed
15:36:26 <kuffaar> I have a runLockedConsole :: MonadIO m => LockedConsole m a -> m a and the argument which is to be passed to it is of type IO (), which obviously doesn't work. Do I need some monadic transformation for this?
15:36:38 <ski> Phyx- : well, they generate an AST, where only the relevant nodes show up .. and they can generate high-lighting information for an editor as well
15:37:18 <ski> Phyx- : iirc, if you google "type error slicing" you can find a site with some info about a prototype implemented for SML
15:37:36 <Phyx-> ski: will do, the idea sounds interesting
15:38:34 <hpc> > let x = \f -> (f 1, f 'a') in x const
15:38:36 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:38:36 <lambdabot>    arising from the literal `1...
15:38:46 <ddarius> Phyx-: You may also want to look at the link I posted.
15:39:45 <Phyx-> ddarius: pdf downloaded :) will read it in the train tomorow
15:40:22 <ski> ddarius : ok,ty
15:40:58 <Phyx-> hpc: yeah, my example was from my own typechecker, which doesn't support classes (yet)
15:42:19 <Egbert9e9> can i compile using ghc a windows executable on linux?
15:42:30 <hpc> Egbert9e9: yes
15:42:36 <hpc> er
15:42:38 <hpc> no
15:42:38 <Egbert9e9> what're the flags?
15:42:40 <Egbert9e9> oh
15:42:40 * hpc misread
15:42:41 <Egbert9e9> dang
15:42:52 <hpc> i suppose you could VM windows
15:42:54 <monochrom> set up a virtual machine
15:43:02 <shachaf> Egbert9e9: You probably *could*.
15:43:06 <hpc> actually, that always bugged me
15:43:14 <Egbert9e9> maybe if i use jaskell
15:43:19 <Phyx-> ghc does cross compilation now?
15:43:21 <Egbert9e9> is jaskell still operating?
15:43:29 <cantropy> hello channel, I am looking for weblog software written in haskell, what do you recommend? So far I have found gitit, and am already installing it.
15:43:33 <Phyx-> i remember a trac request for it
15:43:52 <hpc> cantropy: i wrote one myself, but it isn't even close to ready yet
15:44:02 <hpc> currently http://faidio.visuallycreated.com:8000/blog/
15:44:45 <hpc> (it currently only supports that index, viewing a post, adding, and editing)
15:44:55 <cantropy> hpc: I wouldn't mind half baked ones too, as long it has basic functionality and is usuable readily on local machine.
15:45:22 <cantropy> hpc: how does it compare to gitit? have you tried that one?
15:45:29 <hpc> i have not
15:46:13 <hpc> eek, that is phenomenally featureful
15:46:32 <hpc> (my posts are composed in straight html)
15:46:52 <Entroacceptor> cantropy: isn't gitit more like a wiki?
15:46:53 <hpc> huh, that reminds me
15:46:58 <hpc> i should write part 2 of that series
15:47:17 <Phyx-> :)
15:47:24 <cantropy> hpc: more features are good. I also like that it is built on top of a version control.
15:47:34 <hpc> mine is built on mysql
15:47:39 <cantropy> Entroacceptor: I am a newbie and discovered gitit 5 mins ago.
15:48:23 <cantropy> hpc: ah, I don't want to install a separate database. can it use sqlite3?
15:48:25 <applicative> cantropy, it has been modified for use blogging.  Do you want there to be comments and so on? 
15:48:50 <cantropy> applicative: not at the moment. I am considering a personal note taking software, wiki format suits fine for now.
15:48:53 <hpc> cantropy: yeah, it should work
15:49:20 <hpc> oh, if it's for actually using, i don't recommend mine
15:49:25 <cantropy> applicative: personal diary rather.
15:50:01 <applicative> oh, yes, many people use it 'locally'.  gwern is knowlegable about this. 
15:50:16 <applicative> pardon spelling as usual
15:52:33 <cantropy> what about http://happs.org/ does it not have anything for weblogs?
15:52:40 <geheimdienst> applicative: may i interest you in our upcoming hypercomplicated self-aware new chat system? it will make spelling a thing of the past
15:53:30 <Entroacceptor> cantropy: happs is dead
15:53:34 <applicative> geheimdienst, actually I know how to spell okay. I just never learned how to type.  
15:53:46 <Entroacceptor> cantropy: it's Happstack now http://happstack.com/index.html
15:53:56 <geheimdienst> ... it also will make typing a thing of the past
15:53:59 <geheimdienst> ;)
15:54:05 <Entroacceptor> but there's no ready made blog on that site
15:54:07 <applicative> cantropy, the hakyll static site building system might attract it has a couple of static blog illustrations
15:54:10 <Entroacceptor> of course you can write one
15:54:45 <cantropy> Entroacceptor: okay, am taking a look now, thank you.
15:55:07 <cantropy> applicative: Yes, I noticed that haskell.org is implemented using hakyll.
15:55:09 <applicative> cantropy https://github.com/jaspervdj/hakyll/tree/master/examples has three 
15:55:22 <Bynbo7> it is? o.O
15:56:33 <cantropy> Bynbo7: at least I saw references to it in the haskell wiki on some footers.
15:56:55 <cantropy> what is the haskell wiki implemented in then?
15:57:05 <Bynbo7> mediawiki
15:57:15 <Bynbo7> like wikipedia
15:57:22 <ski> (the old wiki was moinmoin)
15:57:24 <Bynbo7> afaik anyway
15:57:38 * ski misses the old wiki
15:57:53 <applicative> what was  the advantage of the old wiki, ski 
15:58:01 <ski> i'm not sure
15:58:11 <ski> for some reason it seemed more inviting
15:58:38 <kmc> because the new one is Serious Business
15:58:44 <ski> maybe
15:58:51 <kmc> Haskell is now enterprise-ready, industrial strength, not to mention webscale
15:59:07 <kmc> who wants to launch an agile scrum Haskell consultancy
15:59:27 <ski> @quote Yoneda
15:59:28 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
15:59:28 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
15:59:49 <geheimdienst> kmc, it's enterprise-ready because it relies on a wiki engine written in php?
16:00:01 <kmc> php is always enterprise-grade
16:00:04 <kmc> that's what the 'p' stands for
16:00:17 <applicative> ha
16:00:51 <Bynbo7> the other p stands for performance
16:01:22 <cantropy> what about bamboo, anyone tried it?
16:01:22 <monochrom> did you know that enterprise means adventure. so something futuristic like haskell and agda are enterprise-ready
16:01:26 <Bynbo7> Penterprise Has Performance
16:01:41 <cantropy> http://hackage.haskell.org/package/bamboo
16:02:39 <kuffaar> cantropy haha I like the version system
16:02:47 <kuffaar> I should adapt that, too
16:02:48 <Phyx-> to boldly go, where no program has gone before
16:03:14 <cantropy> kuffaar: how do you mean: "version system"?
16:03:18 <monochrom> kirk is not enterprise-ready until he cheats on exams
16:03:23 <aristid> > succ . "aristid"
16:03:25 <lambdabot>   "bsjtuje"
16:03:25 <kuffaar> cantropy: 	2009.4.22, 2009.4.23, 2009.4.25, 2009.4.26, 2009.4.27, 2009.4.30, 2009.4.50, 2009.4.52, 2009.5.13, 2009.5.18, 2009.5.18.1, 2009.5.18.2, 2009.5.19, 2009.5.22, 2009.5.23, 2009.5.27, 2009.6.6, 2009.6.8, 2009.6.9, 2009.6.25, 2009.8.16, 2009.11.1, 2010.1.1, 2010.1.26, 2010.2.25
16:03:33 <kuffaar> He simply uses the date
16:03:55 <applicative> kuffaar, his version system is the least of it.  Note the dependence on his "mps" package.
16:04:12 <aristid> kuffaar: that (date versioning) used to be a popular practice, but is discouraged now AFAIK
16:04:18 <cantropy> kuffaar: are you talking about bamboo?
16:04:28 <kuffaar> cantropy: Aye
16:04:30 <hpc> > (succ &&& pred) . "aristid"
16:04:32 <lambdabot>   [('b','`'),('s','q'),('j','h'),('t','r'),('u','s'),('j','h'),('e','c')]
16:04:36 <hpc> oh shit
16:05:05 <Bynbo7> > rename "aristid"
16:05:07 <lambdabot>   ("`qhrshc","bsjtuje")
16:05:45 <ZnHxr> > liftA2 (&&&) ($ succ) ($ pred) map "wat"
16:05:46 <lambdabot>   ("xbu","v`s")
16:05:48 <aristid> > unzip $ (succ &&& pred) . "aristid"
16:05:50 <lambdabot>   ("bsjtuje","`qhrshc")
16:06:01 <djahandarie> lol.
16:06:14 <djahandarie> > rename "djahandarie"
16:06:14 <kuffaar> https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/Console.hs <- I don't really grasp how to use my runLockedConsole :: MonadIO m => LockedConsole m a -> m a to establish a synchronised console printing environment in https://github.com/epicvrvs/Veles/blob/master/Source/Veles/Server.hs runServer. Now, the signature of the function is going to change from runServer :: Int -> IO () to runServer :: Int -> LockedConsole IO (), right? But I can't just a
16:06:14 <kuffaar> dd runLockedConsole $ in the beginning, prior to the withSocketsDo $, the monadic stack does not match :( I have a runLockedConsole :: MonadIO m => LockedConsole m a -> m a and the argument which is to be passed to it is of type IO (), which obviously doesn't work. Do I need some monadic transformation for this? A lift or something like that?
16:06:16 <lambdabot>   ("ci`g`mc`qhd","ekbiboebsjf")
16:06:23 <djahandarie> Scary
16:06:36 <aristid> djahanderie: at least not possible to write your renamed name slightly wrong.
16:07:00 <cantropy> PRIVMSG lambdabot help
16:11:48 <ski> @hoogle withSocketsDo
16:11:48 <lambdabot> Network withSocketsDo :: IO a -> IO a
16:11:49 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
16:11:49 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
16:12:18 <ski> kuffaar : i'm not sure, but maybe you want `withSocketsDo' outside `runLockedConsole' ?
16:12:24 <kuffaar> Oh? Hm
16:12:34 <ski> i.e. `withSocketsDo . runLockedConsole $ do ...'
16:12:40 <kuffaar> Oh true, it returns m a hmm
16:12:48 <ski> and `m' there can be `IO'
16:13:11 <kuffaar> But the return type of the inner stuff is still wrong then, no?
16:13:27 <ski> i dunno what monadic return type you want
16:13:45 <hpc> kuffaar: instance MonadIO IO where liftIO = id
16:13:56 <hpc> ^ is an instance you already have
16:14:07 <hpc> oh, or what ski said
16:16:56 <kuffaar> http://siyobik.info/pastebin_download.php?id=568 hmm
16:17:07 <kuffaar> I tried withSocketsDo . runLockedConsole $ do
16:17:46 <kuffaar> Couldn't match expected type `transformers-0.2.2.0:Control.Monad.Trans.Reade
16:17:46 <kuffaar> r.ReaderT
16:17:47 <kuffaar>  Knyaz.Console.LockedConsoleState IO a'
16:17:47 <kuffaar>  with actual type `IO Socket'
16:17:49 <aristid> :t forever
16:17:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
16:17:57 <aristid> :t sequence_ . repeat
16:17:58 * Egbert9e9 hugs #haskell
16:17:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:18:12 <kuffaar> aristid hmm that sounds better
16:18:18 <kuffaar> I'd just have to use void $ then
16:18:25 <aristid> no
16:18:36 <hpc> :t repeat
16:18:37 <lambdabot> forall a. a -> [a]
16:18:51 <aristid> :t forever :: Monad m => m a -> m ()
16:18:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:19:07 <aristid> kuffaar: forever is polymorphic enough not to need void
16:19:09 <aristid> :t void
16:19:10 <lambdabot> Not in scope: `void'
16:19:25 <kuffaar> @hoogle void
16:19:26 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
16:20:11 <kuffaar> Oh I just realised I can use composition instead of $ in several places there
16:20:20 <kuffaar> void $ forkIO $ processClient $ ConnectionInformation clientSocket clientAddress
16:20:23 <kuffaar> Like there, right?
16:20:31 <aristid> you don't even need the void there
16:20:39 <aristid> because the next line has a return ()
16:20:40 <kuffaar> aristid: Without it -> warning
16:20:41 <kuffaar> Oh
16:20:49 <kuffaar> aristid: Still a warning
16:20:58 <aristid> interesting.
16:20:59 <kuffaar> #haskell recommended that I adapt void
16:21:06 <kuffaar> aristid: You only get that with -Wall
16:21:24 <kuffaar> Because forkIO is -> IO Threadid
16:21:27 <kuffaar> Or something like that
16:21:30 <kuffaar> @hoogle forkIO
16:21:31 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
16:21:33 <kuffaar> Right
16:21:57 <aristid> forkIO_ t = forkIO t >> return ()
16:22:03 <aristid> this might be convenient
16:22:16 <aristid> or
16:22:25 <aristid> forkIO_ t = void $ forkIO t
16:22:30 <aristid> or
16:22:35 <aristid> forkIO_ = void . forkIO
16:22:40 <kuffaar> Yeah I can add that to my general purpose library in future
16:22:45 <aristid> :)
16:23:01 <kuffaar> But right now I'm more concerned with me not really grasping how to use that console environment I came up with
16:23:14 <kuffaar> Because whatever I'm doing right now, it's terribly wrong
16:23:58 <kuffaar> https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/Console.hs <- I'm trying to use that runLockedConsole  thing to somehow set up synchronised console IO with an MVar in that other code
16:24:14 <kuffaar> So I can use lockedPrint instead of putStrLn
16:24:25 <kuffaar> Because putStrLn from multiple threads equals catastrophe
16:24:37 <kuffaar> Your output will loo like weuifhweruigheruig otherwise
16:24:46 <kuffaar> Since it's not atomic
16:24:50 * ddarius should read Eilenberg and Moore's original paper.
16:26:06 <ski> ddarius : on ?
16:27:00 <kuffaar> People told me that you just have to start using monads to grasp that stuff, well, I followed their advice :p
16:28:04 <kuffaar> But it's starting to feel like people on IRC are designing and writing all my code for me because I'm not managing to even get it to compile on my own
16:29:20 <ddarius> ski: Eilenberg-Moore algebras, i.e. factoring monads.
16:29:26 <ddarius> @google "Adjoint functors and triples"
16:29:27 <lambdabot> http://www.springerlink.com/index/l7864qr0894q2552.pdf
16:29:28 <lambdabot> Title: SpringerLink - Mathematische Zeitschrift, Volume 109, Number 4
16:29:36 <hpc> kuffaar: you are trying too much for a newbie
16:29:37 <ski> well, when you're new to Haskell, "even get it to compile" is often most of the hurdle
16:29:39 <hpc> i think
16:29:52 <ski> ddarius : ok
16:30:06 <hpc> write monadic code with Maybe and lists, and it will be a bit easier to get
16:30:07 <hpc> i think
16:31:29 <kuffaar> But adding the LockedConsole monadic signature to all the functions which are supposed to be part of the synchronised console IO environment made sense at least, right?
16:33:45 <kuffaar> runLockedConsole :: MonadIO m => LockedConsole m a -> m a must eat withSocketsDo :: IO a -> IO a or something like that
16:34:00 <kuffaar> I need to turn a IO a into a  LockedConsole m a?
16:34:16 <kuffaar> IO a -> LockedConsole m a
16:34:47 <kuffaar> @hoogle lift
16:34:48 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
16:34:48 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
16:34:48 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
16:34:58 <kuffaar> Doesn't that look like a candidate?
16:35:05 <kuffaar> Oh but it's a MonadTrans...
16:35:11 <kuffaar> type LockedConsole = ReaderT LockedConsoleState
16:35:19 <kuffaar> Is ReaderT an instance of that? Hm
16:36:05 <kuffaar> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader.html#3 hmm
16:36:15 <applicative> ddarius, you are answering the 'stackoverflow' question about resolving monads into adjoint functors?
16:37:19 <kuffaar> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader.html#t:ReaderT well look at that
16:37:27 <kuffaar> MonadTrans indeed
16:37:51 <kuffaar> So can't I lift the output of withSocketsDo to get the right monadic signature to match the stack of the function?
16:38:24 <humasect> sure
16:38:48 <humasect> 666 haskellers
16:40:10 <kmc> haskell is fucking metal
16:40:21 <kuffaar> Wow, I think I made some progress, it's now erroring out on a later line
16:40:22 <monochrom> that hurts
16:41:09 <kuffaar> I think now I need the opposite of what I did with the lift hmm
16:41:10 <ddarius> applicative: I don't read stackoverflow.
16:41:17 <humasect> 80 columns y/n?
16:41:47 <kmc> m
16:42:10 <geheimdienst> y, mostly
16:42:31 <geheimdienst> i make exceptions sparingly
16:42:48 <applicative> ddarius, someone asked about it the other day, "if a monad is the composition of adjoint functors" how come Haskellers don't talk about adjunction," etc.
16:42:48 <kuffaar> http://siyobik.info/pastebin_download.php?id=568 Couldn't match expected type `IO b' with actual type `transformers-0.2.2.0:Control.Monad.Trans.Reade
16:42:49 <kuffaar> r.ReaderT
16:42:49 <kuffaar>  Knyaz.Console.LockedConsoleState IO ()'
16:42:49 <kuffaar>  - that's because I added the monadic signature for the synchronised IO console environment to the other functions in that code, too, because I figured I wouldn't be able to use lockedPrint there otherwise
16:42:56 <kuffaar> Oh, curse those hidden newlines
16:42:59 <humasect> hmm i do not believe i am able to be m or y with exceptions
16:44:05 <ddarius> In my article for the Monad Reader, I don't think I made use of the fact that, given a monad T on C, and F -| U where U : C -> D, then UTF is a monad on D.
16:44:20 <kuffaar> Do you even need the $ in a . b . c $ d e or can you turn that into a . b . c . d e?
16:44:39 <humasect> c (d e)
16:45:38 <shachaf> kuffaar: Those mean different things.
16:45:42 <kuffaar> Alright
16:47:00 <ddarius> For the curry/uncurry adjunction that gives StateT.
16:48:49 * humasect learns how to make composable programs
16:51:44 <ddarius> For the flip adjunction, and given a -co-monad G, we get G (a -> R) -> R.  I'll need to expand this one.
16:52:37 <parcs> > id . id . id (id True)
16:52:38 <lambdabot>   Couldn't match expected type `f a'
16:52:38 <lambdabot>         against inferred type `GHC.Bool....
16:56:41 <gwern> preflex: seen roconoor
16:56:41 <preflex>  Sorry, I haven't seen roconoor
16:56:44 <gwern> preflex: seen roconnor
16:56:44 <preflex>  roconnor was last seen on #haskell 23 hours, 20 minutes and 49 seconds ago, saying: * roconnor wonders if scheme is declarative
16:57:25 <mm_freak> 666 users‚Ä¶
16:57:30 <mm_freak> haskell is evil
16:57:34 <gwern> @tell roconnor years ago you asked to be told how I made out on Intrade. well, I finally finished and wrote up my experience and also some stuff on the kelly criterion: http://www.gwern.net/Prediction%20markets.html
16:57:35 <lambdabot> Consider it noted.
16:57:37 * kuffaar facepalms
16:58:02 <gwern> truth be told, I wouldn't've remembered to tell him if I hadn't run across his request in a google search
16:59:25 <mm_freak> parcs: id . id . id (id True) = id . id . id True = id . id . True
16:59:35 <ddarius> People who think IRC is real-time are sorely mistaken.
16:59:58 <humasect> or real-space. =)
17:00:05 <mm_freak> or real life
17:02:17 <deech_> Has anyone used Haskell's Lua bindings to talk to LuaJIT?
17:04:32 <kuffaar> Wow, I made it compile
17:04:36 * kuffaar stares in disbelief
17:05:03 <kuffaar> Removed LockedConsole from acceptClient and processClient and now using lift . runLockedConsole . lift . withSocketsDo $ do
17:05:09 <kuffaar> Which just looks odd
17:05:27 <kuffaar> I don't really know what I am doing here anyways but I'll just pretend that this is is some form of success
17:05:43 <DataDriven> is there a fold that consumers two elements at a time?
17:06:19 <DataDriven> e.g to convert a list o fbytes to a list of uint_16s
17:06:25 <DataDriven> lazily
17:06:59 <mm_freak> DataDriven: easy version would be to split the list into chunks prior to folding it
17:07:20 <mm_freak> otherwise you need to keep some sort of state, which is easily possible in foldl, but not so easy in a foldr
17:07:26 <kmc> :t \xs -> zip xs (tail xs)
17:07:27 <lambdabot> forall a. [a] -> [(a, a)]
17:07:40 <kmc> :t \f xs -> zipWith f xs (tail xs)
17:07:41 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
17:08:10 <j-invariant> DataDriven: it would be the fold for data TwoList a = Nil | Cons a a (TwoList a)
17:08:19 <mm_freak> > let chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n) in chunksOf 2 ['a'..'z']
17:08:21 <lambdabot>   ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
17:08:38 <mm_freak> kmc's function is also useful, but it does something different
17:08:51 <DataDriven> kmc, this wont work,  because you will be usign the LSB of previous as the MSB of the current
17:09:15 <applicative> yes you want mm_freak's.  Your initial question was ambiguous
17:09:15 <ddarius> You can implement foldl with foldr.
17:09:17 <mm_freak> kuffaar: you're doing something with monad transformers, suggested by the 'lift' function
17:09:31 <kuffaar> mm_freak yeah that appears to be the case
17:10:15 <kmc> DataDriven, you can then drop every other element
17:10:45 <DataDriven> > let chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n) in  take 10 $ chunksOf 2 [ 1..]
17:10:46 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]
17:10:55 <mm_freak> kuffaar: but doing a single lifted operation in a monad transformer is usually either sign of a poorly designed library (not your fault) or conceptual misunderstanding (your fault)‚Ä¶  that doesn't /have/ to be, but it's likely
17:10:57 <applicative> j-invariant, what if there is an odd number of elements in the list we make the TwoList from?  or maybe that's the point
17:11:06 <v0|d>  /j #pswa
17:11:08 <v0|d> ops
17:11:10 <DataDriven> mm_freak, thanks!
17:11:15 <j-invariant> applicative: Indeed: The data points out problems
17:11:47 <mm_freak> DataDriven: you're welcome, but i think you don't need to reinvent the wheel‚Ä¶  there should be such a function somewhere in Data.List.Split
17:11:58 <kuffaar> mm_freak: In this case the library I am using is written by me :D
17:12:08 <mm_freak> kuffaar: hehe ok
17:12:33 <kuffaar> Not really sure where this is going, just trying to piece this together bit by bit with help from IRC
17:12:52 <DataDriven> actually i need to implement it in C#,  but im new to C# and use Haskell or Python itertools to think the idea out first, [ or get help as in this case]
17:12:59 <mm_freak> kuffaar: then let me explain:  you're transforming monads, because you want to combine the effects of two monads‚Ä¶  but if you have a single lifted operation, then the outer monad can't have any effects other than initialization, in which case you wouldn't need a monad transformer
17:13:16 <DataDriven> Linq in C# makes it relatively easy
17:13:30 <kuffaar> But my lockedPrint :: String -> LockedConsole IO () requires the LockedConsole monad to be in the mondic stack so I suppose that I want it to be part of the monadic signature of the functions which perform synchronised console IO
17:14:11 <mm_freak> DataDriven: compared to haskell C# is a real pain in the arse, but it's better than nothing
17:14:46 <mm_freak> kuffaar: ah, i see
17:14:58 <mm_freak> kuffaar: now it makes sense‚Ä¶  it's part of something bigger
17:15:32 <mm_freak> kuffaar: but why are you using explicit locking?  that's a bad concept and should not be resorted to, unless there is really no other solution
17:15:36 <kmc> C#'s LINQ is a special syntax for monadic computations, much like Haskell's "do" syntax
17:16:11 <kuffaar> mm_freak: What would you use instead? Don't say Chans, that was shut down repeatedly over the past days whenever it was brought up
17:16:21 <mm_freak> kuffaar: MVar
17:16:27 <kuffaar> Uh? I am using MVar
17:16:34 <kuffaar> Which is explicit locking, no?
17:16:38 <mm_freak> for locking or for message passing?
17:16:42 <kuffaar> mm_freak see https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/Console.hs
17:16:52 <DataDriven> mm_freak, yes, but one has to live with it.  but I am considering F# for the next releast of my product [ image processing]
17:16:59 <mm_freak> no‚Ä¶  you can (ab-) use MVar for locking, but in general you use it for message passing
17:17:03 <mm_freak> that's not locking
17:17:14 <kmc> kuffaar, shut down?
17:17:20 <mm_freak> kuffaar: but your code does indeed use MVar for locking
17:17:21 <kuffaar> Err shot down*
17:17:26 <kmc> i don't follow
17:17:29 <kmc> i proposed a Chan-based solution
17:17:30 <DataDriven> kmc, yes and it makes it easy to think functionally
17:17:31 <kmc> as did many others
17:17:36 <mm_freak> kuffaar: let me code you an example
17:17:38 <ddarius> Following changes in variance is tricky.
17:18:04 <kuffaar> kmc yeah and the problem is that the message queue can grow indefinitely
17:18:14 <kuffaar> Anyways I could still use a Chan for this anyways, it's unrelated to my problem
17:18:26 <kuffaar> I would still have to use it in the same way outside the library
17:18:33 <mm_freak> you can abstract out the type of message channel used
17:18:58 * kuffaar now tries to replace the putStrLn with lockedPrint which has a different monadic signature and will break everything
17:19:21 <kmc> why should it?
17:19:36 <kmc> my Chan-based solution gives you something with the same type signature as putStrLn
17:19:51 <kmc> and you could modify it to have a maximum channel size
17:19:54 <kmc> without too much trouble
17:20:04 <DataDriven> in my app image acquisition takes about 400 milliseconds and analysis takes about the same time, since the image is acquired in chunks, i am trying to see if i can interleave the two operations
17:20:28 <kuffaar> kmc you were telling me to pass around a print function to all functions which use it where the first argument is partially applied to the channel object or something like that but that is precisley what I am trying to avoid
17:20:34 <kmc> why
17:20:37 <kuffaar> I thought the entire point in Haskell was to avoid that
17:20:40 <kuffaar> Using monadic signatures?
17:20:54 <kmc> first of all i don't know what the term "monadic signature" means
17:20:57 <humasect> state monad..
17:20:59 <kmc> but you can put my print function into ReaderT
17:21:02 <kmc> same as any other value
17:21:07 <kuffaar> kmc right
17:21:11 <kmc> and that syntactically hides the fact that it's being passed
17:21:18 <kuffaar> kmc that is essentially the same
17:21:22 <kuffaar> As what I am trying to do
17:21:31 <kmc> so what's the trouble
17:22:14 <Cale> kuffaar: Explicit parameter passing is often nicer than reader monad transforming things anyway, so consider it, especially if you'd be reader transforming the IO monad
17:22:25 * hackagebot maccatcher 2.1.0 - Obtain the host MAC address on *NIX and Windows.  http://hackage.haskell.org/package/maccatcher-2.1.0 (JasonDusek)
17:22:49 <kmc> kuffaar, if you're under the impression that the point of Haskell is monads, then you've been sorely misinformed
17:23:01 <kmc> it's a common misconception
17:23:15 <humasect> but it is not false
17:23:21 <kuffaar> Replacing putStrLn with my lockedPrint stuff changes the signature, so now it no longer compiles because of "Expected type: IO a" vs. "Actual type: LockedConsole IO ()"
17:23:27 <ddarius> @djinn (((a -> r) -> r) -> r) -> a -> r
17:23:27 <lambdabot> f a b = a (\ c -> c b)
17:23:56 <ddarius> Cale: I don't see why you'd consider it especially in the IO case.
17:24:15 <kmc> see if you can write this function:  String -> ReaderT (String -> IO ()) IO ()
17:24:29 <kuffaar> Cale kmc: But what if I need to add another function bound to some MVar or a Chan? And then another one? And another one? I'd have to pass around either multiple things like that all the time or I could put some common ones into a new type and then use uhh record notation and composition or whatever to use the functions which are wrapped up inside it
17:24:31 <humasect> because lockedPrint needs to be done inside of LockedConsole IO monad
17:24:37 <kmc> kuffaar, yep
17:24:43 <kmc> you'd build a record probably
17:24:46 <Cale> ddarius: Because IO is already a really huge monad with lots of effects, and there are lots of special higher order functions which become awkward to use with IO once you transform it.
17:24:56 <kmc> if you look at XMonad the "X" monad is basically ReaderT SomeStuff (StateT OtherStuff IO)
17:25:04 <Cale> kuffaar: records are a good idea
17:25:05 <kmc> where the first part is "constant" configuration data and the latter part is state
17:25:14 <kmc> and each of those are big-ish records
17:25:45 <kuffaar> But wouldn't I be coding Haskell the way you do OOP in C then? :|
17:25:59 <kuffaar> Passing around a this pointer all the time
17:26:03 <kuffaar> Excplicitly
17:26:39 <ddarius> :t extract
17:26:40 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
17:26:43 <ddarius> Curses.
17:27:42 <kuffaar> Because if I code like this, I will end up never using anything other than IO
17:27:48 <kuffaar> Pretty much?
17:28:35 <Cale> kuffaar: You should try to design your program in such a way that you use the IO monad just for input and output, pretty much.
17:28:38 <kuffaar> I thought using a monad for this was elegant hmm
17:29:08 <Cale> Design a pure version of the thing you're trying to do, and then wrap an IO interface around that.
17:29:09 <joe6> pastorn: you there?
17:29:48 <kuffaar> Cale: How do you design synchronised console IO in a pure way?
17:29:50 <Cale> (I don't know anything about the details of your particular program)
17:30:03 <kuffaar> Cale: I print to the console from multiple threads
17:30:04 <Cale> kuffaar: As a pure function from input to output?
17:30:22 <Cale> Well...
17:30:29 <kuffaar> And putStrLn is not atomic
17:30:52 <Cale> Okay, you shouldn't do that. Have one thread which is responsible for writing to the console.
17:31:05 <Cale> and use a channel
17:31:22 <deech_> Hi all, I am trying to learn the GHCI debugger but when I try to set a breakpoint it says "Cannot find default module for breakpoint". 
17:32:08 <Cale> kuffaar: Of course, concurrency is by its very nature not very pure :)
17:33:36 <kuffaar> Cale so then I just specify a maximum queue length for the Chan to prevent it from overflowing?
17:33:48 <mm_freak> kuffaar: http://hpaste.org/43094/concurrent_logger_thread
17:33:53 <mm_freak> that's how i would do it
17:33:58 <Cale> kuffaar: Oh, yes, you can do that too.
17:34:19 <Cale> There's a QSemN which might be of some use in that regard
17:34:41 <Cale> Er, or even just QSem
17:35:10 <kuffaar> What do people even usually use monads other than IO for then?
17:35:12 <BMeph> deech_: Put your function in a module.
17:35:23 <kuffaar> I thought people were working with huge stacks of monads in their code all the time
17:35:25 <Cale> kuffaar: Lots of stuff. It's like asking what people use libraries for.
17:35:42 <Cale> There are parsing libraries which define monads, for instance.
17:35:44 <kuffaar> But now you're telling me not to try to use monads for this
17:35:56 <mm_freak> kuffaar: that really depends‚Ä¶  there are always many ways to do it‚Ä¶  some require monads, some don't
17:36:08 <mm_freak> kuffaar: other than IO, which is special, monads are really just a design pattern
17:36:09 <Cale> You shouldn't set out to use monads or try to force your library to be a monad needlessly.
17:36:16 <deech_> BMeph: Oh, I didn't think I had to do that. I'll try tha t and report back.
17:36:22 <mm_freak> i make heavy use of monads, others don't
17:36:29 <j-invariant> Cale: all category theory is like that?
17:36:31 <Cale> Just notice when you can define a monadic bind or when your library happens to be constructible using monad transformers.
17:36:46 <Cale> and take advantage of it then
17:36:49 <mm_freak> kuffaar: anyway, the code above shows how you can use MVar as a transmission channel rather than a locking mechanism
17:37:06 <Cale> The main advantage of defining a monad is that you can use the stuff in Control.Monad.
17:37:41 <mm_freak> Cale: monads are also good to encapsulate behaviour and perhaps even hide its implementation
17:37:42 <Cale> But if you can't, well, it's not a huge problem.
17:38:04 <Cale> Define combinator libraries, notice when they're monads when you can.
17:38:15 <kuffaar> @hoogle evalContT
17:38:15 <lambdabot> No results found
17:38:19 <kuffaar> Wat.
17:38:38 <kuffaar> http://hackage.haskell.org/packages/archive/contstuff/0.1.0/doc/html/Control-ContStuff.html
17:38:40 <Cale> @hoogle execContT
17:38:41 <lambdabot> No results found
17:38:43 <Cale> er
17:38:44 <mm_freak> kuffaar: in most transformer libraries you will do this instead:
17:38:49 <mm_freak> flip runContT return
17:38:52 <mm_freak> instead of evalContT
17:39:04 <mm_freak> :t flip runContT return
17:39:05 <lambdabot> forall r (m :: * -> *). (Monad m) => ContT r m r -> m r
17:39:39 <Cale> oh, right, runCont of course :)
17:39:49 <Cale> and runContT
17:39:49 <mm_freak> hehe
17:39:55 <kuffaar> mm_freak I am puzzled, I don't see an "in" keyword for the let statement down there
17:39:55 <kuffaar> In main
17:39:55 <applicative> mm_freak, maybe "import Control.Concurrent hiding (forkIO)" ?
17:39:56 <mm_freak> you should use ContT more often =P
17:40:26 <applicative> kuffaar, you don't need one in a do block.
17:40:26 <Kaidelong> why does GHC reject patterns like (True?) or (False?) on the left side in my trying to declare ?
17:40:27 <lambdabot> Kaidelong: You have 1 new message. '/msg lambdabot @messages' to read it.
17:40:32 <kuffaar> applicative :|
17:40:33 <mm_freak> applicative: oh right, i don't have the latest contstuff here
17:42:13 <ivanm> Kaidelong: what's the question mark for?
17:42:30 <Kaidelong> ivanm: trying to declare it as a new operator
17:42:45 <mm_freak> kuffaar: "do let y = x; c" is the same as "let y = x in do c"‚Ä¶  just think of it as a scoped variable, which is in scope for the rest of the do block
17:43:05 <Cale> Kaidelong: a unary operator?
17:43:06 <Saizan> Kaidelong: postfix operators are not so well supported, though maybe you just have to enable the extension
17:43:24 <Cale> Or just trying to take a points-free approach?
17:43:33 <Cale> You could always write (?) True = ...
17:44:58 <Kaidelong> Cale: no
17:45:03 <Kaidelong> also
17:45:06 <Kaidelong> I could do that yes
17:45:16 <Kaidelong> but it is not a unary operator no
17:45:24 <Kaidelong> I'll do that instead
17:45:27 <ivanm> or try with a space?
17:45:33 <ivanm> what's the actual error?
17:45:44 <Kaidelong> ivanm: Parse error in pattern
17:46:24 <Kaidelong> the "(?) True" pattern works just fine
17:46:40 <Kaidelong> (True?) and (True ?) do not
17:47:21 <ivanm> why are you putting parens around it?
17:48:16 <Kaidelong> ivanm: that seems to stop it from trying to parse a pattern at all
17:48:31 <Kaidelong> it just complains that it wasn't expecting the =
17:48:58 <Kaidelong> if you do True ? or True?
17:49:18 <Kaidelong> doing it prefix like cale suggested works just fine
17:49:24 <kuffaar> mm_freak anyways, thanks for the code, I saved it for future reference
17:49:43 <mm_freak> kuffaar: it's a bit‚Ä¶  well‚Ä¶  full fledged =)
17:49:52 <ivanm> Kaidelong: well, it's probably looking for the second parameter
17:49:57 <applicative> > let x ? y = x ++ y ++ "ha" in "hey " ? "ho "
17:49:57 <kuffaar> My variant will be simpler
17:49:59 <lambdabot>   "hey ho ha"
17:50:18 <mm_freak> kuffaar: you should implement the quitting function at least, because otherwise you may lose output
17:50:25 <kuffaar> @hoogle abort
17:50:26 <lambdabot> Foreign.C.Error eCONNABORTED :: Errno
17:50:26 <lambdabot> Test.QuickCheck.Batch TestAborted :: Exception -> TestResult
17:50:28 <Kaidelong> ivanm: so I'd have to eta expand to make that work
17:50:36 <Kaidelong> well the prefix solution works fine
17:50:40 <Kaidelong> so I'll just use that
17:51:03 <kuffaar> There's a lot of stuff in there I've never heard of before
17:51:38 <applicative> > let (x ? ) = (x ++) in "hey " ? "ho "
17:51:39 <lambdabot>   <no location info>: Parse error in pattern
17:51:42 <mm_freak> kuffaar: 'abort' is also in Control.ContStuff‚Ä¶  if your transformer library doesn't predefine it‚Ä¶
17:51:49 <mm_freak> :t ContT . return
17:51:50 <lambdabot> forall a (m :: * -> *) r. m r -> ContT r m a
17:52:02 <kuffaar> I'm using ghc 7, I'm sure it has all the new stuff
17:52:03 <mm_freak> hmm, no
17:52:17 <mm_freak> :t ContT . const return
17:52:18 <lambdabot>     Occurs check: cannot construct the infinite type: r = a -> m r
17:52:18 <lambdabot>     Probable cause: `return' is applied to too many arguments
17:52:18 <lambdabot>     In the first argument of `const', namely `return'
17:52:20 <mm_freak> :t ContT . const
17:52:22 <lambdabot> forall a (m :: * -> *) r. m r -> ContT r m a
17:52:42 <mm_freak> i'm stupid today
17:52:47 <kuffaar> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#t:TVar hmm
17:53:16 <mm_freak> ah
17:53:22 <mm_freak> :t ContT . const . return
17:53:23 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => a1 -> ContT a1 m a
17:53:27 <mm_freak> there we go
17:53:33 <mm_freak> that's the 'abort' function
17:54:10 <kuffaar> Ah, people use pred and succ to avoid - 1 and + 1 for Int?
17:54:31 <mm_freak> to avoid parentheses mostly
17:54:39 <applicative> pred is more general
17:54:40 <mm_freak> and the 'subtract' function
17:54:44 <kuffaar> mm_freak can't you use ($) instead of fmap to make that even shorter down there?
17:54:50 <applicative> @type (pred,succ)
17:54:51 <kuffaar> applicative sure, since it operates on Enum
17:54:51 <lambdabot> forall a a1. (Enum a, Enum a1) => (a -> a, a1 -> a1)
17:54:57 <mm_freak> kuffaar: you mean (<$>)?
17:55:03 <kuffaar> Woops, yeah that one
17:55:06 <kuffaar> <$>
17:55:17 <kuffaar> pred <$> readTVar waitVar, right?
17:55:18 <mm_freak> well, i choose from the two quite intuitively
17:55:25 <mm_freak> i think that 'fmap' looks nicer in that context
17:55:32 <kuffaar> I've never used fmap nor (<$>) before
17:56:11 <kuffaar> Wait, why are you using the bind operator in a do block?
17:56:26 <kuffaar> Excplicitly, I mean
17:56:39 <kuffaar> Explicitly*
17:56:40 <hpc> kuffaar: what?!? and you are trying to do TVars?
17:56:54 <Philippa> usually the answer's "because it looks better"/"because it's more readable"
17:57:05 <kuffaar> hpc: I am primarily trying to grasp mm_freak's code, right now
17:57:10 <hpc> ah
17:57:10 * applicative admires kuffaar's topsy-turvy-ness
17:57:22 <kuffaar> applicative: What does that mean?
17:57:23 <hpc> bind in a do block helps keep conceptual actions on one line
17:57:24 <mm_freak> kuffaar: to avoid explicit names
17:57:29 <hpc> without necessarily giving them all names
17:57:34 <kuffaar> Oh, right
17:57:38 <mm_freak> kuffaar: also it's not in a do block
17:57:42 <kuffaar> Otherwise you'd have to use <- yeah
17:57:47 <hpc> kuffaar: you are learning the concepts almost exactly backwards :P
17:58:35 * applicative has always felt that the monad transformer concept should precede those of composition, application and fmap
17:58:40 <mm_freak> kuffaar: 'atomically' expects an STM action as its argument, and i didn't introduce it by 'do'
17:58:40 <kuffaar> hpc: I'm not sure what you mean. Are you saying that I'm trying to do way too advanced stuff all the time and then I spent days on trying to fill the gaps between what I aimed for and what I actually know?
17:59:00 <hpc> kuffaar: not so much "advanced" as that certain things are conceptually dependent on others
17:59:38 <hpc> like learning the derivative before learning the slope formula
17:59:50 <mm_freak> hpc: honestly i wouldn't care‚Ä¶  the understanding comes intuitively
17:59:53 <kuffaar> Hah, STM - I actually had to take an exam on TM stuff :[ mostly hardware implementations though
17:59:55 <Kaidelong> > flip ap (+) f x :: Expr
17:59:56 <lambdabot>   Overlapping instances for GHC.Show.Show
17:59:56 <lambdabot>                              (Simpl...
18:00:04 <Kaidelong> > flip ap (+) y x :: Expr
18:00:05 <lambdabot>   Couldn't match expected type `a -> (a -> a) -> SimpleReflect.Expr'
18:00:05 <lambdabot>         ...
18:00:18 <hpc> mm_freak: im not saying its bad, just funny :P
18:00:21 <j-invariant> what more is there to haskell?
18:00:26 <mm_freak> for example, he doesn't need to know what ContT is and what you can do with it‚Ä¶  all he needs is this enlightenment:  "aha, i can abort computations with ContT"
18:00:37 <mm_freak> "i can break out of 'forever'"
18:01:07 <kuffaar> mm_freak hmm that sounds a bit obfuscated
18:01:22 <kuffaar> Wouldn't it be better to loop conditionally?
18:01:26 <kuffaar> Instead of using forever?
18:01:26 <mm_freak> kuffaar: i'm not doing overexciting stuff with STM‚Ä¶  could have done the same with MVars, but STM is more elegant =)
18:01:32 <hpc> to me, ContT always looked like an exercise in obfuscation
18:01:44 <kuffaar> Doesn't it make the termination condition more clear?
18:01:53 <kuffaar> And that it actually _can_ be terminated?
18:02:00 <mm_freak> kuffaar: i'm using 'forever' and 'abort'‚Ä¶  an explicit loop/recursion would be worse i guess
18:02:17 <mm_freak> the only thing, which suggests that i've even used ContT is that 'evalContT'
18:02:35 <hpc> it's the functional equivalent of while (true) {stuff; break;}
18:02:39 <hpc> i suppose
18:02:43 <mm_freak> exactly
18:03:09 <mm_freak> when LogQuit is read, the thread aborts
18:03:22 <mm_freak> i hate killThread and explicit recursion, too
18:03:38 <mm_freak> and if i were to write a 'while' action, i'd probably write it in terms of ContT =)
18:04:06 <hpc> my transformer of choice seems to be StateT
18:04:32 * BMeph resolves to write his Io interpretes using ContT!
18:04:37 <hpc> (ITC: monad transformers as personality test?)
18:04:48 <BMeph> s/interpretes/interpreter/
18:05:28 <jmcarthur> BMeph: Io interpreter eh?
18:05:37 <mm_freak> my favorite is StateT in contstuff, which is basically ContT r (StateT s m) =)
18:06:45 * hpc needs to suck at haskell again, so he is required to learn ContT to solve a problem
18:08:07 <j-invariant> ConT?
18:08:21 <kuffaar> Continunation transformer or something like that I suppose
18:08:30 <kuffaar> I've only encountered continuations in Ruby before
18:08:45 <kuffaar> I abused them to implement dirty error handling crap in terribly large function sometimes
18:08:52 <kuffaar> But in general I found exceptions far cleaner for that
18:09:07 <j-invariant> does Ruby not have exceptions?
18:09:13 <kuffaar> ^
18:09:14 <c_wraith> it does
18:09:24 <mm_freak> kuffaar: i implemented custom exception handling, abortion, resuming and even goto using ContT =)
18:09:31 <kmc> two different kinds
18:09:31 <kuffaar> :[
18:09:50 <kuffaar> mm_freak I guess that makes you like one of the 60 people in here who actually know Haskell
18:10:01 <mm_freak> i think i should implement CL style resumable exceptions, too
18:10:15 <hpc> kuffaar: the general rule is that anyone who talks in here knows haskell :P
18:10:17 <mm_freak> kuffaar: i don't know haskell, but i know monads
18:10:23 <kmc> sigh
18:10:25 <BMeph> jmcarthur: Yep. I find it especially frustrating that 1) Martin Sandin said that he did it in Haskell first, then did it in OCaml; and 2) He's been exceedingly scarce online since finishing his Master's paper in 2005.
18:10:46 <kuffaar> hpc well I don't know Haskell, yet I am one of the most active spammers in here at times
18:12:01 <BMeph> Continuations are easy! And fun, especially from a functional perspective.
18:12:02 <mm_freak> kmc: just view me as an android =)
18:12:47 * BMeph is not a Haskell expert, but he plays one on the Internet... ;)
18:13:02 <mm_freak> kuffaar: actually i don't even know monads‚Ä¶  i just know CPS =P
18:13:27 <BMeph> mm_freak: Awesome! I'm picking your brains for my Io interpreter! ;)
18:14:26 <mm_freak> no, then i'm dead
18:14:41 <kuffaar> CPS = clicks per second?
18:14:42 <mm_freak> you don't want me to stop spamming, do you?
18:14:50 <mm_freak> kuffaar: continuation passing style
18:14:55 <kuffaar> Ah, right
18:15:06 <mm_freak> kuffaar: http://haskell.org/haskellwiki/Cps
18:19:35 * BMeph is torn between his desire to get an Io interpreter running, and his love for spam...
18:19:53 <j-invariant> spam spam spam spam spam bacon eggs and spam
18:20:42 <nate_> @type map
18:20:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:24:33 <ddarius> @tell edwardk For every comonad w, type Cont w r a = w (a -> r) -> r is a monad.
18:24:33 <lambdabot> Consider it noted.
18:26:55 <tolkad> is there any way to tell ghc to remove the restrictions on the INLINE pragma?
18:28:34 <ddarius> @tell edwardk This is a special case of the fact that given a monad T on C, and an adjunction F -| U : C -> D, then UTF is a monad on D.
18:28:34 <lambdabot> Consider it noted.
18:29:22 <BMeph> ddarius: s/given a monad/given a comonad/ ?
18:29:27 <j-invariant> 3What is UTF?
18:29:37 <j-invariant> oh right U T and F
18:29:52 <BMeph> j-invariant: Uhat is WTF? ;√æ
18:30:00 <ddarius> BMeph: No. I meant what I said.
18:30:43 <BMeph> ddarius: Okay. I was just trying to figure out where the comonad you mentioned prior came in.
18:37:01 <dolio> BMeph: A monad on C^op is a comonad on C, and the adjunction that gets you (a -> r) -> r goes between C and C^op.
18:40:02 <dolio> At least, the (- -> r) one.
18:44:41 <Saizan> i guess any functor C -> C^op also works as a functor C^op -> C
18:45:55 <dolio> For any functor C -> D there's a functor C^op -> D^op with the same components.
18:48:54 <Saizan> op‚ÇÅ : ‚àÄ {o}{‚Ñì}{A B : Category {o}{‚Ñì}} ‚Üí Functor A B ‚Üí Functor (op‚ÇÄ A) (op‚ÇÄ B) <- heh, i had even written the Agda code for that
18:53:32 <edwardk> ddarius: hrmm
18:53:33 <lambdabot> edwardk: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:53:48 <edwardk> @messages
18:53:49 <lambdabot> alpounet said 2d 14m 47s ago: i just saw your contravariant package, I actually had written most of it myself for some fun stuffs I was trying to figure out! But thanks for uploading it :p
18:53:49 <lambdabot> ddarius said 20h 37m 26s ago: http://home.imf.au.dk/kock/CYRSC.pdf Nice and old, before terminology settled down. The "generalized limits" are Kan extensions. I'll need to expand things to see what
18:53:49 <lambdabot> comes of it.
18:53:49 <lambdabot> ddarius said 29m 16s ago: For every comonad w, type Cont w r a = w (a -> r) -> r is a monad.
18:53:49 <lambdabot> ddarius said 25m 16s ago: This is a special case of the fact that given a monad T on C, and an adjunction F -| U : C -> D, then UTF is a monad on D.
18:54:02 <mm_freak> could you say that haskell monads are a reification of CT monads?
18:54:45 <edwardk> ddarius: now i'm curious what other monads exist given any comonad
18:54:50 <edwardk> and vice versa
18:58:22 <edwardk> tolkad" restrictions i the sense that it can't be a recursive function etc?
19:06:30 <pastorn> joe6: oi
19:16:49 <ddarius> @paset
19:16:50 <lambdabot> Maybe you meant: part paste
19:16:52 <ddarius> @paste
19:16:52 <lambdabot> Haskell pastebin: http://hpaste.org/
19:18:48 <joe6> hello pastorn: i have the parser ready. Would you mind taking a quick look? It looks pretty beautiful. I think you might consider me a good student.
19:18:54 <ddarius> Here's the code if anyone was interested: http://hpaste.org/43095/continuation_comonad_to_monad
19:19:36 <ddarius> The "general" case for adjunctions from Hask -> Hask would be a fairly straightforward exercise (though wouldn't cover this case.)
19:19:39 <edwardk> ddarius: yeah i just hacked up basically the same thing
19:20:13 <edwardk> then i tried to figure out where in the module hierarchy it would live
19:20:15 <pastorn> joe6: hehe, linky?
19:20:22 <edwardk> and came to no satisfactory answer ;)
19:20:32 <joe6> pastorn: http://codepad.org/VnqUrWT5
19:20:46 <edwardk> i guess it is a monad transformer, so its Control.Monad.Trans.Cont.Something
19:22:21 <joe6> pastorn: this is the next step: http://codepad.org/4fPRYVem
19:23:10 <joe6> i have a module with a record datatype. I imported the module and am wondering how I can import all the constructors for the record datatype.
19:23:18 <joe6> any thoughts, please?
19:24:53 <ivanm> joe6: did you export all of them?
19:25:37 <ddarius> edwardk: One thing that is suggested is if w is a cofree comonad, then w (a -> r) -> r should be isomorphic to m ((a -> r) -> r) where m is a free monad.
19:25:55 <edwardk> ddarius: hrmm, with universal quantification over r, this looks like a comonad at a glance too
19:26:25 <pastorn> joe6: it comes automatically
19:26:27 <joe6> ivanm: should I just put a module where instead of listing some functions and record datatypes.
19:26:38 <ivanm> huh?
19:27:10 <kuffaar> Is evalContT outdated or something like that?
19:27:20 <kuffaar> Somebody made it sound so, a few hours ago
19:27:43 <pastorn> joe6: say that you have "data D = A | B", then if you only have "module X where" all gets exported. you also get them all with "module X ( D(..) ) where", but you won't get B with "module X ( D(A) ) where"
19:27:48 <joe6> i just have this on the top of the module file: "module ControlTransactions where"
19:28:02 <joe6> pastorn: thanks a lot.
19:29:06 <pastorn> joe6: oh, just a thing on your imports... the convention is to have them in three sections; Stuff from GHC, stuff from other libraries, same project imports
19:29:16 <pastorn> separated by newlines
19:29:50 <pastorn> so parsec would fall under library imports
19:30:04 <joe6> pastorn: ok, thanks
19:30:28 <pastorn> oh, readtransactions... you do (>>=) f (return . g)
19:30:39 <pastorn> instead do fmap g (f)
19:33:09 <kuffaar> mm_freak: Why is it that your quit type includes that (IO ()) part?
19:33:17 <joe6> > fmap
19:33:17 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> f a -> f b)
19:33:17 <lambdabot>    arising...
19:33:50 <pastorn> joe6: and you have a lot of parentheses... try removing some and see if it loads... you don't need them on any of your "return Constructor {...}" lines
19:34:25 <joe6> pastorn: that was a good idea about the fmap
19:34:52 <joe6> pastorn: just saw the hlint code and it says the same too. will make those changes. 
19:35:07 <pastorn> also i'm bretty sure you don't need paretheseses around your ifs
19:35:07 <joe6> pastorn: i should have done that before asking for your comments. It slipped my mind.
19:35:17 <pastorn> it's fine :)
19:36:13 <edwardk> @pl \x a -> runCont (f a) x
19:36:14 <lambdabot> flip (runCont . f)
19:37:28 <pastorn> joe6: and the module with datatypes looks nice...
19:37:29 <kuffaar> http://hpaste.org/43094/concurrent_logger_thread <- I am currently trying to understand mm_freak's code, is that (IO ()) part for LogQuit really necessary?
19:37:41 <kuffaar> Is that just a convenient way to link the TVar stuff to it?
19:38:09 <mm_freak> kuffaar: the caller sends a LogQuit signal with a response action‚Ä¶  upon exiting the logger executes that action, so that the caller can know, when the logger has written all pending data
19:38:15 <kuffaar> Oh he's still around
19:38:25 <pastorn> joe6: for parsing a 'Buffer' type you could do (pure Buffer) <*> getWord8 <*> getWord8 <*> getWord8 ...
19:38:27 <mm_freak> kuffaar: this is important, because when the main thread exits, all other threads are killed
19:38:44 <pastorn> joe6: (<*>) is from Control.Applicative
19:38:54 <kuffaar> liftIO c >> abort () <- oh I think I get it now
19:38:59 <mm_freak> that means, if you write something to the log just before your main action returns, the logger may not have enough time to write it
19:39:14 <kuffaar> Wait no, I expected c to be a function
19:39:21 <kuffaar> But it's just IO () hm
19:39:23 <mm_freak> no, it's just an IO action
19:39:29 <kuffaar> How is that an action?
19:39:44 <kuffaar> To me that's like calling 0 an action
19:39:45 <mm_freak> look at the logQuit function‚Ä¶  it creates a TVar, which is initialized to False
19:39:54 <mm_freak> an action is not a function
19:39:54 <joe6> pastorn: thanks, i am making the suggested changes. thanks, will think about the buffer as bytestring.
19:40:04 <mm_freak> putStrLn is a function, which results in an action
19:40:08 <pastorn> joe6: yeah, that seems more reasonable
19:40:15 <mm_freak> it takes a String and results in an action of type IO ()
19:40:39 <pastorn> joe6: maybe with a constructor; newtype Buffer = Buffer ByteString
19:40:56 <mm_freak> in the same way (atomically $ writeTVar quitVar True) is an action of type IO ()
19:41:11 <mm_freak> that action is passed to the logger thread, which runs it right before exiting
19:41:14 <joe6> i still do not understand the newtype. will ping you on that once I get my things in order. hope that's ok.
19:41:18 <kuffaar> Never heard of an "action" before hm
19:41:35 <mm_freak> kuffaar: "action", "monadic value", "computation", ‚Ä¶
19:41:46 <mm_freak> there are many terms for them, but not "function"
19:42:06 <mm_freak> a function is a mapping in the mathematical sense, while an IO action is sort of like a recipe
19:42:23 <mm_freak> it's an abstract notion of what will happen, when the program is run
19:42:35 <mm_freak> (or the action, for that matter)
19:43:12 <kuffaar> mm_freak what happens when I call logQuit twice in your code?
19:44:04 <kuffaar> Ohhh I think I finally get what confused me
19:44:11 <kuffaar> This exploits laziness, doesn't it?
19:44:39 <kuffaar> log $ LogQuit (atomically $ writeTVar quitVar True) <- I expected this writeTVar to be executed right at the same time as the log within the logQuit caller
19:44:47 <kuffaar> But that is not the case, because of laziness?
19:44:56 <kuffaar> the laziness actually crosses thread boundaries in this case?
19:45:14 <kuffaar> And it's not evaluated until the LogQuit c -> patr in logger in another thread?
19:46:21 <mm_freak> kuffaar: it has nothing to do with laziness‚Ä¶  just follow the program execution
19:46:33 <mm_freak> logger runs in parallel and expects messages
19:46:57 <mm_freak> caller creates a TVar with the value False and sense a LogQuit with an action to set the TVar to True
19:47:03 <kuffaar> mm_freak to me it looks like the logQuit thread calls newTVarIO and then writeTVar right after that.
19:47:10 <mm_freak> sense ‚Üí sends
19:47:28 <kuffaar> i.e. it sets it to True itself
19:47:32 <mm_freak> the logger gets the message at some point, runs the action, thereby notifying the caller that it got the signal to quit
19:47:35 <kuffaar> Without the involvement of any other thread
19:47:46 <mm_freak> after that the logger exits
19:47:52 <kuffaar> Why does logger run the action instead of logQuit...?
19:47:53 <jmcarthur> what does JHC stand for? John's Haskell Compiler?
19:47:58 <mm_freak> at the same time the caller waits for the variable to become True
19:48:14 <mm_freak> as soon as it becomes True, the caller knows that the logger has got the signal
19:48:19 <mm_freak> and that's about it‚Ä¶  no magic
19:49:19 <kuffaar> In my understanding of this program, writeTVar quitVar True is executed by the thread which calls logQuit, mm_freak
19:49:30 <kuffaar> I don't see any reason why it would be executed by the logger instead]
19:49:36 <kuffaar> If it weren't for laziness, perhaps
19:50:27 <jmcarthur> laziness has nothing to do with execution (unless you are doing horrible things with unsafePerformIO or unsafeInterleaveIO)
19:50:36 <jmcarthur> well
19:50:45 <jmcarthur> "execution" meaning "executing IO actions"
19:51:50 <mm_freak> kuffaar: the logger needs to notify the caller that it has received the quit signal
19:52:07 <mm_freak> the caller waits for that signal
19:52:11 <kuffaar> jmcarthur http://hpaste.org/43094/concurrent_logger_thread we are talking about line 29
19:52:16 <mm_freak> that notification is done by writeTVar
19:52:31 <kuffaar> mm_freak yes I know, that has nothing to do with my problem though
19:52:52 <kuffaar> I don't know why writeTVar is executed by the logger thread instead of the logQuit thread
19:53:20 <kuffaar> I mean if I just put << writeTVar quitVar True << in there it would execute it in the logQuit thread, right?
19:53:35 <kuffaar> But << log $ LogQuit (atomically $ writeTVar quitVar True) << does not execute the writeTVar
19:53:37 <kuffaar> In the same thread
19:53:42 <kuffaar> It executes it in another thread
19:53:56 <jmcarthur> kuffaar: it looks like you're just writing an IO action to the TVar. that doesn't execute the action
19:54:19 <kuffaar> Huh :O why not
19:54:26 <kuffaar> How is it executed?
19:54:42 <jmcarthur> there is a seperation between execution and evaluation. an IO action is only executed when you use it with IO's >>= operator (or do notation) and you can trace it back to main
19:55:05 <mm_freak> kuffaar: the logger notifies the caller /by writing to the TVar/
19:55:06 <jmcarthur> kuffaar: LogQuit c     -> liftIO c >> abort ()   -- that executes it
19:55:32 <kuffaar> Interesting, so it's all about the bind hmm
19:55:49 <kuffaar> I had no idea it worked like that
19:56:01 <mm_freak> kuffaar: initially the TVar is set to False‚Ä¶  the caller sends the quit signal and then immediately jumps into an STM action waiting for it to become true
19:56:09 <mm_freak> the logger then sets it to True
19:56:26 <kuffaar> mm_freak: Yes, that has never been unclear :p jmcarthur actually addressed what I was irritated by
19:56:47 <kuffaar> You see, in the languages I am used to this would be executed immediately
19:57:06 <kuffaar> It doesn't matter if you do writeTVar(); or f(writeTVar());
19:57:11 <kuffaar> In my model there's no difference
19:57:24 <mm_freak> there is a difference‚Ä¶  you're not passing the result of the action
19:57:28 <mm_freak> you're passing the action itself
19:57:35 <mm_freak> you don't pass (), but IO ()
19:57:59 <kuffaar> Ah, if you passed liftIO blah it would be executed first?
19:58:06 <mm_freak> nope
19:58:16 <kuffaar> >:O
19:58:29 <kuffaar> But that would pass (), wouldn't it?
19:58:31 <mm_freak> if you did this:  writeTVar quitVar True >>= log . LogQuit
19:58:43 <mm_freak> then it would pass (), and LogQuit would be defined as:  LogQuit ()
19:58:46 <mm_freak> not LogQuit (IO ())
19:59:19 <mm_freak> the concept of execution is encapsulated in the IO monad's bind operator (>>=)
19:59:32 <kuffaar> Ah, so it comes down to the bind, as jmcarthur said
19:59:35 <mm_freak> there is no other way to extract the () from IO ()
20:00:07 <mm_freak> until you bind, you pass the action itself around, not its result‚Ä¶  it doesn't even have anything to do with function call semantics
20:00:32 <Zao> > [print "lol", print 9001]
20:00:32 <edwardk> ddarius: callCC f = ContT $ \wc -> runContT (f (\a -> ContT $ \_ -> extract wc a)) wc
20:00:33 <lambdabot>   [<IO ()>,<IO ()>]
20:01:06 <edwardk> ddarius: it also seems to admit the usual callCC definition, where effectively each position in the comonad is 'callCC'd in turn.
20:01:22 <jmcarthur> kuffaar: if you want it to be executed first then instead of "log $ LogQuit (atomically $ writeTVar quitVar True)" you should say "atomically $ writeTVar quitVar True; log LogQuit", and instead the LogQuit constructor just shouldn't take any parameters
20:01:37 <jmcarthur> kuffaar: unless there is actually some sort of data you need to pass along with the LogQuit constructor
20:01:44 <mm_freak> jmcarthur: thanks, i missed the atomically =)
20:01:51 <jmcarthur> kuffaar: currently the "data" you are passing along is an IO action
20:02:25 <kuffaar> Curious
20:02:49 <jmcarthur> it's actually quite useful that it works this way. it gives you much more control over things :)
20:04:35 <kuffaar> mm_freak so what happens when I call logQuit more than once? It would call putMVar on an MVar which has no taker, right?
20:04:35 <jmcarthur> i'll just ask once more. does anybody know what JHC stands for?
20:04:41 <kuffaar> So it would just be blocked indefinitely
20:04:44 <kuffaar> Doing nothing?
20:04:52 <edwardk> i thought J was just john as in john meacham
20:05:07 <jmcarthur> so, John Haskell Compiler?
20:05:11 <jmcarthur> or John's Haskell Compiler?
20:05:15 <edwardk> probably John's
20:05:23 <mm_freak> kuffaar: yes, you shouldn't send LogQuit more than once
20:05:23 <jmcarthur> thanks
20:05:36 <mm_freak> kuffaar: the proper way to deal with this is the following function:
20:05:55 <mm_freak> withLogger :: ((LogCmd -> IO ()) -> IO a) -> IO a
20:06:53 <kuffaar> mm_freak: Right, to basically make the print thread "scoped" (using C++ talk)?
20:07:08 <jmcarthur> woah, callCC
20:07:29 <edwardk> jmcarthur: re the comonadish-Cont callCC?
20:07:33 <kuffaar> I've only heard of "call/cc" in the text mm_freak pasted, on the subject of conitunations
20:07:34 <mm_freak> kuffaar: yes, and that's also valid haskell talk =)
20:07:39 <kuffaar> mm_freak oh, nice
20:08:00 <joe6> when ByteString is used, can I specify the size?
20:08:16 <mm_freak> kuffaar: if you want to do it /really/ properly, you'll need this:
20:08:41 <mm_freak> withLogger ((forall s. Logger s -> IO ()) -> IO a) -> IO a
20:08:56 <jmcarthur> edwardk: i was just looking at mm_freak's withLogger type signature. callCC has a very unique type signature and it's rare to see it occur naturally in the wild, especially in newbie code :)
20:09:05 <edwardk> ah
20:09:46 <jmcarthur> although i guess "with*" functions have it fairly often
20:09:47 <kuffaar> What does CC even stand for?
20:09:52 <mm_freak> i think, callCC is a third order function‚Ä¶  withLogger is only second order
20:09:53 <jmcarthur> Current Continuation
20:09:54 <edwardk> "current continuation"
20:09:55 <mm_freak> :t callCC
20:09:57 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:10:05 <mm_freak> yeah, third order
20:10:40 <jmcarthur> oh i see. my human brain is going on overdrive with pattern recognition i guess
20:10:52 <kuffaar> I'm only familiar with the with* stuff from withSocketsDo
20:10:53 <mm_freak> uhm, wait‚Ä¶  the first function was indeed third order
20:10:59 <kuffaar> @hoogle withSocketsDo
20:10:59 <lambdabot> Network withSocketsDo :: IO a -> IO a
20:10:59 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
20:11:00 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
20:11:04 <kuffaar> Right, IO a -> IO a
20:11:06 <jmcarthur> it's not quite unifiable though
20:11:07 <kuffaar> Much simpler
20:11:09 <edwardk> i think the concern is the rank of the type
20:11:27 <mm_freak> kuffaar: try withFile, which gets a bit closer
20:11:35 <kuffaar> @hoogle withFile
20:11:35 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
20:11:40 <edwardk> properly rank 3 you can use the continuation in very different contexts
20:11:40 <mm_freak> withFile passes the handle to a file, callCC passes a continuation
20:12:44 <mm_freak> edwardk: as an experiment with ContT and callCC i tried to transport a labelled continuation outside of the scope of runContT to another ContT computation
20:12:48 <mm_freak> couldn't do it
20:13:03 <mm_freak> i guess that's haskell's lack of first class continuations
20:13:08 <dolio> Screw the rank-3 type, anyway. Everyone knows delimited continuations are far superior.
20:13:11 <edwardk> ya
20:13:20 <edwardk> well, that lack is a good thing in some ways =)
20:13:24 <dolio> And you can't give magic, use-anywhere types to the continuation in shift.
20:13:38 <edwardk> bad in others, because it makes cozipping/devil's bargain tricks hard
20:14:30 <monochrom> this is the pros and cons of referential transparency
20:14:32 <mm_freak> well, you can always emulate delimited continuations in a CPS-based language
20:14:50 <edwardk> rather, costrong/devil's bargain sstuff
20:14:58 <edwardk> yeah
20:15:31 <edwardk> been playing a lot with CPS'd code the last couple of weeks
20:17:18 <kuffaar> mm_freak so you still have a separation of the creation of the logger object which is basically just a wrapper around an MVar and the withLogger stuff, right?
20:17:36 <kuffaar> At first you create it, and then you run withLogger on it and print within the scope of withLogger
20:18:00 <nanothief> I remember their being a program that could generate a function by giving it a type. Can anyone remember what it was called?
20:18:43 <kuffaar> The signature you gave to me didn't really tell me much hmm especially since I wanted to limit it to putStr/putStrLn anyways so it wouldn't be as generic as your idea
20:18:43 <dolio> @djinn a -> a
20:18:44 <lambdabot> f a = a
20:18:45 <Sgeo> I know I've seen it in here
20:18:57 <nanothief> dolio: thanks!
20:19:02 <Sgeo> @djinn Just Right
20:19:03 <lambdabot> Error: Undefined type Just
20:19:05 <dolio> There's a stand-alone version, too.
20:19:07 <Sgeo> oops
20:19:16 <Sgeo> @djinn Maybe ( b -> Either a b)
20:19:16 <lambdabot> f = Nothing
20:19:25 <Sgeo> Hate you too, lambdabot
20:19:42 <AxleLonghorn> I'm trying to create the following function: convertNumbers :: Num a => [Expr] -> [a]
20:20:03 <kuffaar> @hoogle Expr
20:20:04 <lambdabot> module Text.Parsec.Expr
20:20:04 <lambdabot> module Text.ParserCombinators.Parsec.Expr
20:20:04 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
20:20:10 <jmcarthur> :t a
20:20:11 <lambdabot> Expr
20:20:11 <kuffaar> Parsec, AxleLonghorn?
20:20:15 <kuffaar> Oh
20:20:23 <jmcarthur> kuffaar: i don't think AxleLonghorn is talking about that though
20:20:26 <AxleLonghorn> where Expr is an AST datatype containing a couple of number types along with other ast types
20:20:27 <jmcarthur> probably his own type?
20:20:31 <AxleLonghorn> yes
20:20:31 <monochrom> perhaps you could create convertOneNumber :: Num a => Expr -> a  first
20:20:32 <jmcarthur> yeah ^^ :)
20:20:45 <mm_freak> kuffaar: the withLogger function would be just a convenience function, which creates the logger thread, then calls the passed function and finally quits the logger
20:20:46 <AxleLonghorn> I'm having trouble with the number conversion
20:21:05 <AxleLonghorn> there's an (EInt Integer) and an (EFloat Float)
20:21:20 <kuffaar> mm_freak yeah but I mean syntactically it can't provide the logging function on its own, can it?
20:21:30 <kuffaar> You still need to have another step for that
20:21:33 <monochrom> the Float can't really be done
20:21:59 <AxleLonghorn> The type checker is complaining " Couldn't match expected type `a' against inferred type `Float', `a' is a rigid type variable bound by, the type signature for `convertNumber'"
20:22:29 <jmcarthur> the problem is that you are trying to return a Float, but the type signature says it must be *any* Num
20:22:52 <monochrom> the user gets to choose a.
20:23:12 <mm_freak> kuffaar: 'logger' creates the logging function
20:23:30 <mm_freak> withLogger k = logger >>= k >> ‚Ä¶
20:23:35 <AxleLonghorn> how do I convert properly then?
20:23:43 <AxleLonghorn> with Integer, I used fromIntegral
20:23:59 <monochrom> there is no conversion from Float to (Num a)=>a
20:25:21 <jmcarthur> the only thing i can think of is to round it to an Integer and then use fromInteger. or you can just not use Float in Expr
20:25:44 <jmcarthur> you could try parameterizing Expr on the type of the result
20:25:53 <jmcarthur> then that function would be something like Expr a -> a
20:26:10 <jmcarthur> with some sort of constraint, most likely
20:26:25 <kuffaar> mm_freak: Ohhh... that sounds much better than what I was thinking of... right, you can actually pass the function to the scope which it executes hmm I was actually going to perform some manual binding outside of that, making it much clumsier to use hm
20:26:50 <AxleLonghorn> The usage is that I have a '+' function for a dynamic language that needs to take a list of numeric expressions, sum them, and then package up the result
20:27:17 * hackagebot plot 0.1.2.4 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.2.4 (VivianMcPhail)
20:27:19 <mm_freak> kuffaar: well, to do it properly you'll also want to add some exception handling
20:27:27 <mm_freak> kuffaar: the 'bracket' function is suitable here
20:27:36 <mm_freak> kuffaar: see Control.Exception
20:28:19 * hackagebot plot-gtk 0.1.0.3 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.3 (VivianMcPhail)
20:33:03 <kuffaar> mm_freak wouldn't that just confuse me even more? :P Seems like overkill at this point
20:33:58 <mm_freak> kuffaar: no, actually using 'bracket' may even simplify your code
20:35:52 <kuffaar> Hmm block { }
20:50:48 <joe6> data Buffer = Buffer { buffer0 :: Word8, buffer1 :: Word8}; emptyBuffer = Buffer 0 0; I am trying to do: let x = (buffer0 = 1) $ emptyBuffer
20:51:21 <joe6> basically trying to ensure that whenever I create a new Buffer data, I have the fields initialized to 0
20:51:29 <joe6> is this possible?
20:52:54 <jmcarthur> joe6: let x = emptyBuffer { buffer0 = 1 }
20:54:10 <joe6> oh, cool thanks.
20:55:07 <joe6> jmcarthur: that was easy.. thanks a lot.
20:55:28 <jmcarthur> np
21:10:30 <pastorn> joe6: why not just have a bytestring of length 8?
21:11:13 <joe6> pastorn: I googled to see how I could do that. but, there was no literature on how I could specify the maximum length to a bytestring
21:11:48 <ivanm> not sure if it's possible to specify that a bytestring has a fixed length
21:11:54 <ivanm> use a vector or something instead for that
21:11:57 <pastorn> joe6: no, you can't
21:12:11 <ivanm> or wrap a newtype around a ByteString and specify which operations are possible
21:12:17 <pastorn> but you can do make sure that your functions only uses stuff of length 9
21:12:18 <pastorn> *8
21:12:51 <joe6> pastorn: this is where I got to.
21:12:53 <joe6> http://codepad.org/PaninSSW
21:13:16 <pastorn> joe6: basically you have 4 functions: emptyBuffer, getBuffer :: Get Buffer, putBuffer :: Buffer -> Put and setBufferVal :: Int -> Word8 -> Buffer -> Buffer
21:13:21 <joe6> http://codepad.org/iAqUSvXx
21:13:41 <joe6> this is the ControlTransactions module
21:14:20 <joe6> pastorn: can you please take a look at http://codepad.org/PaninSSW. It seems a lot simpler just using fields 
21:14:39 <pastorn> joe6: hang on, let me show you what i mean...
21:14:52 <joe6> please note that this code does not even compile and not even close to complete, but i think it shows the direction I am headed in.
21:15:12 <pastorn> is my browser silly or is the hoogle search CSS different?
21:15:13 <joe6> pastorn: btw, on a different note, do you think I have learnt your lessons?
21:15:30 <pastorn> heh, i think you've learned about style :)
21:15:34 <pastorn> and type safety
21:15:50 <pastorn> and modularizing your design :)
21:20:45 <joe6> what is type safety?
21:21:04 <joe6> not to use too many types?
21:21:14 <Eduard_Munteanu> No, not that :)
21:21:28 <ivanm> closer to using specialised types
21:21:39 <Eduard_Munteanu> Rather making use of the type system to avoid programming errors.
21:21:46 <ivanm> e.g. if you use Int to represent Customer ID and they're bank balance, there's a chance you accidentally mix two values up
21:22:04 <pastorn> joe6: that you actually have a datatype describing your buffer instead of having an array of uchar
21:22:15 <joe6> oh, ok.
21:22:21 <pastorn> it's one part of it
21:22:38 <pastorn> joe6: other stuff is like how you can't do ('a' + 1)
21:22:51 <pastorn> since 'a' isn't a number
21:23:17 <joe6> oh, ok. thanks.
21:23:37 <pastorn> stuff like that, you'll understand once the compiler has screamed enough at you
21:32:53 <pastorn> joe6: http://codepad.org/qAC9i0wx
21:33:17 <pastorn> joe6: didn't try running it, so you'll have to deal with any type errors, but it *should* work
21:34:05 <joe6> pastorn: thanks, will check it out.
21:35:41 <pastorn> joe6: with that, what you do on line 171 could be
21:36:05 <pastorn> tsEp0InBuffer = setBufferVal 0 1 . setBufferVal 1 2 $ emptyBuffer
21:36:23 <pastorn> and you don't have to mess with the record syntax :)
21:36:35 <stepcut> is there an ETA on GHC 7.0.2 ? I know the rc1 come out Dec 15 or so..
21:41:48 * hackagebot hmatrix-gsl-stats 0.1.2.9 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.9 (VivianMcPhail)
21:44:47 <joe6> pastorn: the code is definitely a step up from what I had. Why not just use Data.Array of Word8's?
21:46:13 <pastorn> because bytestring would be simpler for you
21:46:31 <pastorn> joe6: when you're using Data.Binary.Get there's a function :: Int -> Get ByteString
21:46:41 <pastorn> 'take' or something
21:46:42 <om-foxy> can we no longer say
21:46:44 <om-foxy>   foo 0        = Nothing
21:46:46 <om-foxy>   foo (n+1) = Just n
21:46:47 <om-foxy> The (n+1) part.  I get a parse error with ghc-7.0.1
21:46:56 <pastorn> om-foxy: zomg
21:47:03 <mtnviewmark> indeed, + patterns were removed w/Haskell 2010
21:47:10 <djahandarie> Yes, no more n+k
21:47:20 <om-foxy> pastorn: zomg?
21:47:24 <mtnviewmark> I'm sure there is a flag to GHC that brings it back -- gets you Haskell 98
21:47:28 <joe6> pastorn: ok, thanks will use what you recommended. Thanks a lot for your help.
21:47:34 <pastorn> om-foxy: i thought noone used it :)
21:47:40 <om-foxy> :)
21:48:51 <om-foxy> pastorn:  I'm recompiling my packages with ghc-7.0.1 and have used it once.
21:50:14 <pastorn> om-foxy: i bet you use monad comprehensions as well
21:51:01 <om-foxy> pastorn:  not yet, but I'm keeping an eye on the ticket ;P
21:52:44 <om-foxy> make that three times
21:53:52 * hackagebot hstatistics 0.2.2.7 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.7 (VivianMcPhail)
21:53:53 <om-foxy> pastorn:  I am pre-Applicative/Alternative/Enumerator and have some learning to do
21:55:28 <pastorn> om-foxy: have you looked at the Applicative functional pearl?
21:55:40 <om-foxy> no, do you have a link?
21:55:47 <om-foxy> @google Applicative functional pearl
21:55:50 <lambdabot> http://strictlypositive.org/IdiomLite.pdf
21:55:50 <lambdabot> Title: FUNCTIONAL PEARL Applicative programming with effects
21:55:53 * hackagebot hsignal 0.1.3.3 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.1.3.3 (VivianMcPhail)
21:56:25 <pastorn> yes, that
21:56:48 <om-foxy> pastorn, thanks :)
21:57:08 <pastorn> i only read the first 2-3 pages, but that was enough for me
22:29:53 <joe6> pastorn: i am trying to do putStrLn . unpack on the Buffer and am not able to. is there a way to display the contents of the Buffer?
22:30:09 <joe6> pastorn: any thoughts, please..
22:32:54 <pastorn> joe6: B.putStrLn :p
22:33:09 <pastorn> joe6: but if you wanna print the hex, then it's a different situation...
22:40:01 <joe6> pastorn: "displayBuffer . setBufferVal 0 1 . setBufferVal 1 2 $ emptyBuffer" does not show anything
22:40:11 <joe6> i put this in Buffer.hs: displayBuffer buf = B.putStrLn . buff $ buf 
22:40:48 <pastorn> that's weird...
22:41:05 <joe6> displayBuffer :: Buffer -> IO ()
22:41:06 <pastorn> joe6: try removing the explicit exports and derive Show for Buffer
22:41:26 <joe6> i added deriving (Eq, Show) to the Buffer data structure
22:44:17 <joe6> *Main> show . setBufferVal 0 1 . setBufferVal 1 2 $ emptyBuffer
22:44:18 <joe6> "Buffer {buff = \"\\SOH\\STX\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\"}"
22:46:50 <pastorn> joe6: better?
22:47:08 <pastorn> joe6: i think i have some code for printing it as hex... let me look
22:47:16 <joe6> thanks a lot
22:48:14 <pastorn> http://codepad.org/aYRHv2Nx
22:48:31 <pastorn> joe6: but you could cheat :)
22:50:08 <joe6> pastorn: ok, thanks.
22:50:27 <Rotaerk> http://xkcd.com/833/
22:50:35 <pastorn> you could unpack it as a [Word8] and then use Text.Printf to print hexes
22:55:54 <joe6> pastorn: that helped. thanks.
22:56:17 <joe6> converted it to Word8 with unpack: unpackBuffer = B.unpack . buff
22:56:27 <joe6> Prelude.putStrLn . show .unpackBuffer . setBufferVal 0 1 . setBufferVal 1 2 $ emptyBuffer
23:03:24 <pastorn> joe6: you want to use Text.Printf to look at it properly, you want to print it as hex, don't you?
23:04:59 <joe6> pastorn: http://codepad.org/LAuzs88N
23:06:07 <pastorn> joe6: import Text.Printf
23:07:14 <pastorn> printBuff = mapM_ (printf "%x") . unpacking-business
23:07:46 <Bynbo7> probably want %02x
23:09:00 <joe6> that is awesome. Thanks a lot.
23:09:21 <pastorn> and you also might want a space in there somewhere :)
23:12:20 <joe6> pastorn: is there a print typeclass?
23:12:58 <pastorn> a printf one, yes
23:13:03 <pastorn> but it's a big hack
23:13:15 <pastorn> printf takes a String and an arbitrary amount of arguments
23:13:32 <pastorn> so (printf "%d" 1) is valid, and so is (printf "%d" 1 2)
23:13:43 <pastorn> they both typecheck because of nifty typeclasses
23:14:42 <pastorn> sure, if you write the wrong value marker in your formatting string you're gonna have stuff blow up in your face when you run you program, but i think that's a small price to pay for the convenience you get
23:15:19 <joe6> pastorn: http://codepad.org/x4q22sDy
23:15:47 <joe6> i am trying to add the printBuffer into the Buffer.hs and it gives me an error
23:16:08 <joe6> though the code works at ghci
23:16:11 <pastorn> joe6: printf has two output types; String and IO ()
23:16:21 <pastorn> (more typclass hacks)
23:16:32 <yiliang> hi
23:16:47 <pastorn> so basically the compiler chooses your version depending on context... if you don't have any context, make one (insert a type signature)
23:16:50 <pastorn> yiliang: hello
23:16:51 <joe6> oh, that worked.
23:16:55 <joe6> good idea. thanks.
23:17:03 <joe6> printfBuffer :: Buffer -> IO ()
23:17:09 <pastorn> exactly
23:17:13 <yiliang> nice to meet you all here
23:17:16 <joe6> i just added the header definition and it worked.
23:17:31 <pastorn> header definition? it's a type signature :p
23:18:43 <joe6> sorry, i meant a type definition
23:22:19 <joe6> pastorn: that ended up being brilliant. Thanks.
23:22:29 <pastorn> joe6: heh, nice :)
23:57:00 <Phyx-> ooooooohh
23:57:06 <Phyx-> ghc finished compiling
23:57:12 <Phyx-> *golf clap*
23:57:23 <Bynbo7> as it really been a month? :o
23:57:58 <Phyx-> yeah, according to my calendar
23:58:11 <Phyx-> i went into some kinda hibernation mode
23:58:19 <kniu> Is there an IRC channel for ray/path/photon tracing and similar topics?
