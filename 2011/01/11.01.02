00:00:09 <Jesin> > :t reverse
00:00:11 <lambdabot>   <no location info>: parse error on input `:'
00:00:14 <Jesin> ...
00:00:16 <Jesin> :t reverse
00:00:17 <lambdabot> forall a. [a] -> [a]
00:00:21 <Jesin> > reverse "blargle"
00:00:23 <lambdabot>   "elgralb"
00:00:55 <Jesin> :t permute
00:00:56 <lambdabot> Not in scope: `permute'
00:00:59 <Jesin> :t permutations
00:01:01 <lambdabot> forall a. [a] -> [[a]]
00:01:17 <Jesin> > nub $ permutations "blargle"
00:01:19 <lambdabot>   ["blargle","lbargle","albrgle","labrgle","ablrgle","balrgle","ralbgle","arl...
00:01:57 <Jesin> > length $ nub $ permutations "blargle"
00:01:58 <lambdabot>   2520
00:03:12 <ksf> Enigmagic, didn't even try, won't try.
00:03:21 <ksf> it's not the first ptr-based loop I'm writing myself.
00:04:06 <Jesin> @src nub
00:04:07 <lambdabot> nub = nubBy (==)
00:04:11 <Jesin> @src nubBy
00:04:12 <lambdabot> nubBy eq []             =  []
00:04:12 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:04:22 <Jesin> :t nubBy
00:04:23 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
00:05:41 <ion> > reverse . filter isAlpha $ "Doc note: I dissent. A fast never prevents a fatness. I diet on cod."
00:05:43 <lambdabot>   "docnoteidIssentafastneverpreventsafAtnessidIetoncoD"
00:19:09 <Jesin> > fix reverse
00:19:13 <lambdabot>   mueval-core: Time limit exceeded
00:23:48 * ksf doh
00:23:58 <Jesin> ?
00:24:16 <ksf> no I shouldn't worry about that suspiciously large %alloc. the max heap size is 3k.
00:28:27 <systemfault> ksf: What is your timing so far for 25 millions? 
00:28:57 <ksf> I've got no idea, it wouldn't be comparable, in any case.
00:29:09 <ksf> my box is 6 years old
00:29:21 <Jesin> @src permutations
00:29:21 <lambdabot> Source not found.
00:29:32 <Jesin> @src length
00:29:33 <lambdabot> Source not found. Just try something else.
00:29:43 <Mitar> is it possible to have a semi-polymorphic function which, if the argument type is an instance of Data, do something, and if it is not, do something else?
00:32:53 * hackagebot EsounD 0.1 - Type-safe bindings to EsounD (ESD; Enlightened Sound Daemon)  http://hackage.haskell.org/package/EsounD-0.1 (MasatakeDaimon)
00:33:44 <ion> ESD has been dead for how many years now? :-)
00:34:40 * shachaf misses OSS.
00:34:41 <ion> The final release in 2008.
00:34:54 <jeikobu> This works, but I'm looking for feedback: http://pastebin.ca/2036503
00:36:39 <systemfault> shachaf: Just use it, no?
00:37:00 <shachaf> systemfault: It's still alive?
00:37:07 <systemfault> Yeah
00:37:20 <shachaf> Anyway, I don't miss it in a *practical* sense.
00:37:26 <systemfault> ALSA being linux-only, OSS is everywhere else.
00:37:37 <shachaf> Hmm.
00:38:10 <shachaf> Is there an easy way to get /dev/audio in Linux nowadays?
00:38:26 <systemfault> I don't know :/
00:39:47 <akamaus> shachaf, I think only by manual recompiling the kernel
00:40:19 <systemfault> shachaf: I'm actually on OSX, connected via ssh to my small server with ubuntu... :/
00:40:29 <shachaf> Is there a reasonable way to emulate it in userspace?
00:40:35 <shachaf> I guess you could use FUSE...
00:41:14 * shachaf should just switch to Plan 9.
00:42:38 <systemfault> Or just go on with what you currently have.
00:43:58 <systemfault> Or you could just watch that... http://www.youtube.com/watch?v=msviW3M3Dls :'(
00:47:42 <ksf> hmm.
00:47:55 <ksf> I think I'm loosing time marshalling bytestrings.
00:48:25 <ksf> ...I should probably switch completely to (Ptr,Int)
00:56:04 <lars9> "Perhaps you haven't installed the profiling libraries for package `MemoTrie-0.4.9'?"
00:56:14 <ksf> :t isJust
00:56:15 <lambdabot> forall a. Maybe a -> Bool
00:56:16 <lars9> how to install profiling lib for a pkg?
00:56:18 <ksf> :t isNothing
00:56:19 <lambdabot> forall a. Maybe a -> Bool
01:02:15 <lars9> :t getArgs
01:02:16 <lambdabot> Not in scope: `getArgs'
01:02:17 <qfr> What's the normal way to debug problems in Haskell? In C++, Ruby and Python I would frequently just print out stuff to see where things start going awry because some database contained something unexpected etc. In Haskell this is problematic because that would involve adding IO everywhere so when you have a nested cakll pattern a -> b -> ... -> h then you need to modify the signature of tons 
01:02:17 <qfr> of functions just so you can perform IO in one. How do you usually deal with this?
01:02:42 <shachaf> qfr: If you just want to add print statements, there's Debug.Trace.
01:03:14 <qfr> shachaf and that doesn't force you to add the IO monad everywhere?
01:03:22 <shachaf> Nope, it's unsafe.
01:03:29 <qfr> Ah, alright
01:03:33 <shachaf> @src trace
01:03:34 <lambdabot> trace string expr = unsafePerformIO $ do
01:03:34 <lambdabot>     hPutStrLn stderr string
01:03:34 <lambdabot>     return expr
01:04:18 <qfr> What does unsafe mean in the context of Haskell? That it has side effects while pretending to be pure in its type?
01:04:43 <qfr> Also, what problems does unsafePerformIO cause?
01:05:17 <shachaf> qfr: That's what unsafePerformIO means.
01:05:44 <shachaf> qfr: Well, the behavior is undefined. It mixes up evaluation with secret IO execution.
01:06:02 <lars9> shachaf: does it make eval strict?
01:06:25 <shachaf> lars9: ?
01:06:38 <qfr> shachaf: Does this have any practical implications?
01:07:08 <shachaf> qfr: ...Yes? It breaks referential transparency.
01:07:13 <ksf> ...possibly, at least.
01:07:56 <ksf> it's just like mmaping a file, happily working away on it and then having some process change the file under your fingertips.
01:08:02 <ksf> usually, breakage ensues.
01:08:30 <ion> Or IPC
01:08:38 * shachaf thinks ksf should merge with kmc.
01:09:26 <qfr> So when I use unsafePerformIO in Haskell I will experience random memory corruption and segfaults?
01:09:45 <ksf> ...why am I comparing string bytewise?
01:10:07 <Saizan> qfr: not segfaults (unless you're also messing with pointers)
01:10:19 <shachaf> qfr: Probably not, unless your IO actions cause that.
01:10:21 <qfr> shachaf why would that even bother me?
01:10:27 <qfr> 10:06:39 <shachaf> qfr: ...Yes? It breaks referential transparency.
01:10:30 <Saizan> qfr: though, for example, some side effects could be performed more than once, or never
01:10:38 <ksf> your program becomes deeply, deeply non-deterministic.
01:10:44 <shachaf> qfr: Values, since they're referentially transparent, can be evaluated any number of times.
01:11:04 <shachaf> Equational reasoning is broken.
01:11:15 <qfr> So where I might expect one debug print, I might end up with 50?
01:11:34 <shachaf> For debugging it usually works out fine.
01:11:43 <shachaf> But you don't want to use it for "real" IO.
01:12:19 <Saizan> anyhow, that's possible, if ghc happens to inline your trace rather than sharing its evaluation
01:12:46 <qfr> Can you come up with any examples where unsafePerformIO would do something unexpected, from the viewpoint of somebody who is used to C++, Ruby, Common Lisp, etc?
01:13:04 <Saizan> it usually respects the sharing implied by explicit let bindings, but to be really sure you'd have to add NOINLINE pragmas etc
01:13:47 <shachaf> qfr: That depends on how you expect. How are you meaning to use it?
01:14:12 <qfr> I would just randomly add debug prints in places where I think the error in the program is located
01:14:50 <shachaf> As I said, that usually works out fine.
01:14:56 <Enigmagic> qfr: for debugging its fine. you don't want something like fseek(h, 10, SEEK_CUR) executed with unsafePerformIO though
01:14:56 <Saizan> qfr: for example unsafePerformIO is used in an ugly hack to get global IORefs, if you forget to add a NOINLINE pragma there, each use of that IORef could end up creating a different one
01:15:21 <arcatan> qfr: btw, for randomly added debug prints you could use Debug.Trace
01:15:31 <qfr> arcatan that's what I was talking about
01:15:34 <arcatan> (which of course uses unsafePerformIO)
01:17:59 <arcatan> i've always got the expected amount of debug prints
01:18:30 <qfr> I debug almost everything with debug prints lol
01:19:04 <qfr> Except in C++ and C# perhaps
01:19:27 <arcatan> with Haskell i seldom need debug prints
01:19:46 <shachaf> http://www.agoyangyang.com/content.php?id=94
01:19:59 <shachaf> "The Wisdom Mind sometimes called Adi-budha, the Supreme Wisdom, is the field of consciousness which, overshadowing each individual, is the home of the Monad, the seat of incomparable bliss where truth abides."
01:21:21 <Jafet> Cultists
01:21:36 <ksf> deists.
01:21:50 <qfr> Filthy theists
01:21:51 <shachaf> Category theorists.
01:22:10 <ksf> that sentence is just as idiotic as saying "Love and peace, sometimes called Jesus Crist, ..."
01:23:03 <shachaf> ksf: What are you talking about? Stop getting me out of my Monad.
01:23:17 * shachaf returns to incomparable bliss where truth abides.
01:24:33 <ksf> but hurling blasphemy at armchair-monks is great fun
01:35:51 <Saizan> qfr: anyhow, a nicer way to debug haskell programs is to test in isolation the small functions they should be composed of
01:36:33 <qfr> Writing proper unit tests is time consuming
01:38:15 <ion> Not noticing newly introduced bugs because of a missing test suite is time consuming in the long run.
01:45:01 <ibt> slam
01:48:07 <qfr> ion: It's not like I write code which will run in a satellite or anything like that, just small one man projects :p
01:49:42 <Saizan> well, you don't need to write unit tests in advance
01:50:24 <Saizan> just like you don't put print statements in advance, i assume
01:54:34 <profmakx> does anybody know why a bootstrapped ghc 6.12.3 might complain like this: package.conf.d: openFile: inappropriate type (is a directory)
02:03:21 <ksf> why write unit tests before you've written quickcheck tests?
02:03:29 <ksf> and why test stuff that's guaranteed by the type system?
02:03:57 <ksf> profmakx, how did you compile ghc?
02:04:15 <ksf> I once had the exact same thing, due to mixed up headers.
02:04:45 <ksf> linux' and haiku's struct stat don't match up well.
02:04:48 <profmakx> ksf, i want to bootstrap for dragonfly
02:04:57 <profmakx> i booted on freebsd 
02:06:04 <ksf> profmakx, have a look at http://hackage.haskell.org/trac/ghc/ticket/3472
02:07:44 <profmakx> hm
02:07:45 <profmakx> crap
02:08:07 <ksf> rejoice!
02:08:32 <ksf> there have been speculations that llvm will make cross-bootstrapping much easier, and you can work on it!
02:08:49 <profmakx> well, for this i would need llvm on dragonfly right :P
02:08:54 <profmakx> which is a story all by itself
02:10:10 <ksf> hmm. do your host and donor have different bitsizes? I ask because two bsd's should with a bit of luck be sufficiantly compatible to share headers.
02:10:31 <ksf> another approach would be to try linux emulation.
02:11:59 <profmakx> dragonfly does not have linux emulation
02:12:21 <profmakx> and yes, as dragonfly is a freebsd fork i hoped that they both would be compatible enough. both 64 bits and all
02:13:03 <profmakx> oddly enough someone seems to at least have gotten it to work on i386 dfly at some point
02:14:54 <ksf> is llvm that problematic on dragonfly?
02:15:03 <profmakx> to be hones, i don't know
02:15:49 <profmakx> so let's try that
02:16:05 <ksf> ...on march 16, 2009 someone complied a working dragonfly kernel with clang.
02:16:11 <ksf> so I'd guess it works.
02:16:44 <magicMark> in Emacs, I just tried to line up declarations using the key binding C-c C-= but Emacs says it's not defined. I have Haskell mode 2.8. Can anybody help?
02:17:05 <ksf> yes.
02:17:12 <ksf> start by switching to vi.
02:18:28 <magicMark> any other suggestions?
02:18:37 <arcatan> magicMark: have you loaded haskell-indent.el
02:18:50 <magicMark> yes ... indentation works
02:20:04 <magicMark> wait ... I load haskell-site-file in .emacs ... isn't that enough?
02:21:10 <arcatan> there are three different indentation modes
02:21:31 <arcatan> haskell-indent, haskell-indentation and haskell-simple-indent
02:21:41 <magicMark> i tried the first and second
02:22:19 <arcatan> by a quick grep to the source of haskell-mode, the first one is the only that binds anything to C-= 
02:23:04 <magicMark> ok I change to it again
02:24:23 <arcatan> you could try M-x turn-on-haskell-indent and then C-c C-=.
02:24:42 <arcatan> i'm not an Emacs user myself, though, so this is where my knowledge ends
02:25:44 <romildo> Hi.
02:27:15 <romildo> Compilation of my application on Gentoo Linux is failing because the module Graphics.UI.Gtk.WebKit.WebView cannot be found, although the webkit package is installed. Any clues?
02:27:34 <magicMark> arcatan > thanks ... I'm still fighting ...
02:28:03 <ksf> romildo, I guesstimate gtk2hs has a flag you can enable to build webview.
02:29:22 <silbo__> if I have a type (Int, Double, Float) what is the best way to get the Double from a variable of that type
02:29:24 <ksf> hmmm no.
02:29:37 <romildo> ksf, webview should already be enable:
02:29:37 <romildo> # ghc-pkg describe webkit | grep View
02:29:38 <romildo>                  Graphics.UI.Gtk.WebKit.WebSettings Graphics.UI.Gtk.WebKit.WebView
02:29:46 <ksf> romildo, cabal install webkit
02:30:01 <romildo> ksf, it is already installed.
02:30:40 <ksf> oh, are you trying to compile via cabal?
02:31:02 <ksf> it hides all packages by default to make sure you list them all in build-depends:
02:31:05 <magicMark> arcatan > it's working now :-)
02:32:31 <lars9> @instances MonadPlus
02:32:32 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
02:36:39 <zingoba> could anyone tell me how to read input from console?
02:37:06 <ksf> @hoogle readLn
02:37:06 <lambdabot> Prelude readLn :: Read a => IO a
02:37:06 <lambdabot> System.IO readLn :: Read a => IO a
02:37:14 <ksf> also have a look at
02:37:20 <ksf> @hackage haskelline
02:37:21 <lambdabot> http://hackage.haskell.org/package/haskelline
02:37:37 <ksf> or was it three l?
02:37:37 <zingoba> readLn returns a string?
02:37:55 <ksf> no, anything readable.
02:38:10 <ksf> @hoogle getLine
02:38:10 <lambdabot> Prelude getLine :: IO String
02:38:10 <lambdabot> Data.ByteString getLine :: IO ByteString
02:38:11 <lambdabot> System.IO getLine :: IO String
02:38:20 <ksf> ...if you want to do your own parsing.
02:38:31 <zingoba> I need to read integers
02:38:42 <ksf> but then chances are good that you also want line-editing, that's where haskelline comes into play.
02:38:53 <ksf> use readLn
02:39:14 <zingoba> so I wont have to do any type conversions after reading?
02:39:46 <ksf> readLn will decide what to accept depending on what type you want
02:39:47 <romildo> ksf, webkit (as almost all other Haskell packages on my system) has been installed with the package management utility from the linux distribution.
02:39:54 <ksf> > read "1" :: Int
02:39:54 <lambdabot>   1
02:39:59 <ksf> > read "1" :: String
02:39:59 <lambdabot>   "*Exception: Prelude.read: no parse
02:40:05 <ksf> > read "\"1\"" :: String
02:40:05 <lambdabot>   "1"
02:40:06 <dobblego> @hackage haskeline
02:40:07 <lambdabot> http://hackage.haskell.org/package/haskeline
02:40:13 <ksf> > read "1.0" :: Int
02:40:14 <lambdabot>   *Exception: Prelude.read: no parse
02:40:16 <ksf> > read "1.0" :: Float
02:40:17 <lambdabot>   1.0
02:40:18 <quuuux> undefined is the greatest mock-testing framework in existence
02:40:31 <romildo> ksf, but my application is being compiled with the command line "ghc --make -O Gui"
02:41:04 <zingoba> yeah thanks, the previous link was broken
02:41:20 <ksf> romildo, then stuff should work...
02:42:30 <om> hey there!
02:42:55 <om> Can someone tell me what this program does?
02:43:38 <ksf> om, "this program"?
02:43:46 <ksf> > this program
02:43:47 <lambdabot>   Not in scope: `this'Not in scope: `program'
02:44:18 <zingoba> thankyou
02:44:33 <om> well, I've tried a few examples given on the try Haskell,
02:44:42 <om> but not quite sure what else it can do.
02:45:10 <ksf> about anything except IO
02:45:43 <om> Ok,
02:46:39 <om> for example, can I get say, the Fibonacci series displayed?
02:47:09 <ksf> > let fibs = 1:1: zipWith (+) fibs (tail fibs)
02:47:10 <lambdabot>   not an expression: `let fibs = 1:1: zipWith (+) fibs (tail fibs)'
02:47:10 <qfr> ksf haha
02:47:16 <ksf> > let fibs = 1:1: zipWith (+) fibs (tail fibs) in fibs
02:47:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
02:47:41 <om> hmm., lemme try this.
02:48:10 <qfr> what's the ghci equivalent of @src btw?
02:48:18 <ksf> there's none.
02:48:21 <qfr> Aww
02:48:28 <ksf> lambdabot just memorised some.
02:48:44 <ksf> ...and they're not necessarily the definitions you see in the source
02:48:51 <ksf> but there's hackage
02:50:04 <quuuux> hm. Mysterious. I seem to need -XRelaxedPolyRec to make TH play nice with my typeclass-boxing shenanigans, and not give utterly useless error messages
02:51:46 <quuuux> what's the motivation for -not- having RelaxedPolyRec enabled by default, anyway? It only seems to exist to trip me up
02:53:15 <qfr> Wasn't there some list comprehension hackery in Haskell which allowed you to go like [2, 3, 5, 7..] to get the primes?
02:54:56 <mjrosenb> qfr: that sounds hard, and un-useful
02:55:00 <ivanm> yeah
02:55:05 <ivanm> it's not possible
02:55:07 <qfr> Hehe
02:55:12 <mjrosenb> qfr: you can use [1,3..] to get the odd numbers.
02:55:15 <ivanm> since [a,b..c] ==> enumFromThenTo a b c
02:55:19 <qfr> I just remotely recalled something like that
02:55:20 <qfr> Yeah
02:56:11 <shachaf> > [1,2..1/0]
02:56:12 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
02:56:22 <qfr> Uh
02:56:38 <qfr> Haha
03:00:56 <qfr> Hmm can you have a lambda call itself somehow?
03:01:00 <qfr> Without giving it a name?
03:01:36 <qfr> Wow, that must have really scared him off
03:02:09 <quuuux> @let a `divides` b = a `rem` b == 0
03:02:10 <lambdabot>  Defined.
03:02:21 <quuuux> @let primes = filter (\n -> not . any (flip divides n) . takeWhile (< n) primes) [2..]
03:02:22 <lambdabot>  <local>:2:65:
03:02:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]...
03:02:26 <augur> the kronecker product of matrices x and y is x >>= \ex -> scale ex y
03:02:28 <augur> 0.0
03:02:40 <quuuux> @let primes = filter (\n -> not $ any (flip divides n) $ takeWhile (< n) primes) [2..]
03:02:42 <lambdabot>  Defined.
03:02:46 <quuuux> > take 10 primes
03:02:50 <lambdabot>   mueval-core: Time limit exceeded
03:02:54 <quuuux> curses :(
03:05:35 * hackagebot cpuid 0.2.1.3 - Binding for the cpuid machine instruction on x86 compatible  processors  http://hackage.haskell.org/package/cpuid-0.2.1.3 (HenningThielemann)
03:08:11 <Saizan> @undefined
03:08:47 <ddarius> quuuux: You have to prime the pump.
03:09:03 <quuuux> ddarius: very punny
03:09:26 <ddarius> quuuux: Except I wasn't making a joke.
03:09:58 <qfr> > let fibonacci n = if n `elem` [1, 2] then 1 else fibonacci (n - 1) + fibonacci (n - 2) in map fibonacci [1..10]
03:10:00 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
03:10:14 <qfr> Can you pull that off using a lambda without let somehow?
03:10:54 <ddarius> qfr: Use fix.
03:12:31 <silbo__> ddarius: if I have a type (Double, Int, Float) what would be the best way to get the Int from a variable of that type?
03:13:31 <ddarius> silbo__: I don't know why you are asking me specifically.  The only way to destructure a type is ultimately pattern matching.
03:13:33 <shachaf> silbo__: Is there a particular reason you're asking ddarius?
03:14:39 <silbo__> not really no xD
03:15:15 <silbo__> so I should make getters that use pattern matching?
03:15:52 <shachaf> silbo__: If you want to. Using your own data type rather than a tuple might make more sense.
03:16:20 <silbo__> someone told me a better way like   type myType = myType { number :: Int, decimal :: Double }
03:16:46 <shachaf> silbo__: data, not type.
03:16:51 <silbo__> and the call  variable deciaml or something
03:16:53 <shachaf> @google algebraic data types haskell
03:16:54 <lambdabot> http://en.wikipedia.org/wiki/Algebraic_data_type
03:16:54 <lambdabot> Title: Algebraic data type - Wikipedia, the free encyclopedia
03:17:06 <qfr> Is the (4342+) stuff syntactical sugar?
03:17:16 <ddarius> Yes.
03:17:18 <qfr> Does that work for all arithmetic operators?
03:17:25 <shachaf> qfr: For any infix operator.
03:17:28 <ddarius> It works for all syntactic operators.
03:17:30 <qfr> Oh, wow
03:18:57 <quuuux> @pl \ p -> p * p <= n
03:18:58 <lambdabot> (<= n) . join (*)
03:19:12 <qfr> > take 9 $ cycle $ ("LO"++) []
03:19:14 <lambdabot>   "LOLOLOLOL"
03:19:17 <qfr> Curious.
03:22:40 <qfr> fix (+) says cannot construct the infinite type: a = a -> a
03:22:45 <qfr> fix (2+) works
03:22:47 <qfr> Why is that?
03:22:49 <paolino> Hi, I'd like to have comments on http://hpaste.org/42703/typeclass_to_keep_old_states . I wonder if there is a similar approach avoiding existentials in favour of other type machinery
03:23:19 <paolino> :t fix
03:23:20 <lambdabot> forall a. (a -> a) -> a
03:23:21 <shachaf> qfr: What do you expect (fix (+)) to mean?
03:23:30 <paolino> :t (+)
03:23:30 <shachaf> fix f = let x = f x in x
03:23:30 <lambdabot> forall a. (Num a) => a -> a -> a
03:23:36 <qfr> Oh wait, I get it
03:23:38 <shachaf> fix (+) = let x = (x+) in x
03:23:56 <qfr> That made no sense, yeah
03:24:44 <qfr> > take 5 $ fix ("LO"++)
03:24:46 <lambdabot>   "LOLOL"
03:24:51 <qfr> pwetty.
03:25:26 <ddarius> tryShowF f (ToPast x) = f (show x) || maybe False (tryShowF f) (back x)
03:27:13 <paolino> ddarius: I just discovered ||, amazing :)
03:29:19 <paolino> hlint still didn't
03:29:28 <ddarius> The only thing you can do with ToPast is show the contents producing a String (roughly) and apply back to it producing a Maybe ToPast.  So it's pretty much the same as data ToPast = ToPast String (Maybe ToPast) which is roughly akin to a non-empty list of Strings.
03:29:42 <kolmodin> does anybody know if the gtk2hs homepage has moved or when it will be back?
03:31:15 <ddarius> (Admittedly, you could also do some craziness and use the forth operator, but you don't seem to be doing that in stuff related to ToPast.)
03:31:26 <mathijs> is there a way to define a class to unify runState and runStateT ?
03:31:50 <Saizan> kolmodin: i think it's a causality of the move of haskell.org to the new server, you should ask the admins
03:32:19 <paolino> ddarius: the 2 methods are unrelated, right
03:32:32 <ddarius> Similarly FromPast looks like it could be simplified by just being (String -> a)
03:33:24 <qfr> Hmm can't you use where in lambdas?
03:33:45 <ddarius> Well that might be too simplified, but something in that direction will probably work.
03:34:25 <kolmodin> Saizan: I was hoping an admin would hear me :)
03:36:03 <qfr> \x -> (y where y = 1)
03:36:05 <qfr> Not legal
03:36:14 <qfr> Why is that?
03:36:19 <Saizan> #haskell on sunday morning is not so likely
03:36:44 <kolmodin> :)
03:37:58 <ddarius> @where report 
03:37:58 <lambdabot> http://www.haskell.org/onlinereport/
03:38:07 <ddarius> Have at it qfr
03:38:23 <profmakx> ksf when will the llvm things appear in ghc?
03:38:25 <qfr> how hostile :(
03:39:01 <ivanm> profmakx: they already are
03:39:43 <qfr> let works fine though, I guess I'll just use that then
03:39:58 <ivanm> qfr: where is just syntactic sugar for let anyway
03:39:59 <pastorn> is the -O3 default LLVM now?
03:40:02 <paolino> ddarius: that would involve rewriting a function , instead of adding an instance when data a is expanded, right ?
03:40:19 <ksf> profmakx, in ghc 7.0.1
03:40:22 <ksf> ...which is out
03:40:25 <ksf> try -fllvm
03:40:30 <ivanm> pastorn: do you mean "does -O3 turn on LLVM" or "is -O3 the default optimisation level when using LLVM"?
03:40:34 <ivanm> if the former, then no
03:40:39 <ivanm> if the latter, I have no idea
03:40:48 <profmakx> ksf so llvm works fine on dfly.
03:40:55 <qfr> Can you cons on the right side somehow?
03:40:55 <ddarius> paolino: I'm not sure what you're talking about, but I'm pretty sure the answer is "no."
03:40:59 <profmakx> .oO(fonally something that works!)
03:41:08 <qfr> Using ++ [x] is not so elegant
03:41:24 <ksf> qfr, there's difference lists
03:41:56 <ivanm> and Sequences
03:41:57 <ksf> ...which do what you did above with non-abysmal performance as you don't get quadratic behaviour
03:42:18 <ksf> ...which are finger trees.
03:42:30 <ivanm> yeah
03:43:06 <ksf> qfr, you could also pretend that the head is the end.
03:43:44 <ksf> ...the question is more whether or not and how often you need to reverse. if that's a lot, you should use data.sequence, otherwise lists/difference lists.
03:44:10 <ddarius> Seeing as there is no -O3 for GHC, I think we can safely answer "no" to both of those questions.
03:44:25 <ksf> ddarius, but llvm has -O3
03:44:43 <ksf> ...which is a standard collection of optimisations useful mainly for C
03:50:26 <ddarius> Yay.  Brigitte Pientka is doing cool stuff with contextual modal type theory.
03:51:11 <quuuux> @pl \s -> fmap ((s !!) . pred) $ f (1, g s)
03:51:12 <lambdabot> ap (fmap . (. pred) . (!!)) (f . (,) 1 . g)
03:51:16 <paolino> ddarius: tryRead is :: (Read a, Transition a) => ReadS a and with a new Transition instance I can reuse it for a new 'a' based on that 'a'. Without the instance I guess I must modify tryRead definition.  I'm not sure anyway
03:51:17 <mathijs> ksf: the old via-c backend used to have an option to set options for gcc, so you could tell ghc to -O2 the haskell step, but gcc would do -O3. Probably somthing like that exists for llvm as well
03:52:16 <Jafet> gcc has a fourth level now
03:52:36 <quuuux> so, I'm finding myself using a lot of monad transformers and monad typeclasses right now, and the quadratic explosion of instances I need to write is getting annoying. What can I do about that?
03:54:18 <ddarius> paolino: All my suggestions do is do the composing with show/read and back/forth before the packing since the only you do or even (almost) can do with the existentially bound variables is those compositions.
03:54:45 <ddarius> It should not change the structure overall structure very much.
03:54:59 <ivanm> quuuux: IIRC, some of the alternate transformer libs like monadlib do away with that issue
03:55:36 <quuuux> ivanm: part of the problem is I'm using about 5 libraries, and a lot of the instances I'm writing are just to get them to play nicely
03:55:49 <ivanm> ugh
03:59:31 <Eduard_Munteanu> quuuux: maybe you can use a combined transformer, like RWST?
03:59:47 <decaf> there was an annotation format about reading source files in ghc, charset for example. am I remember correctly?
03:59:51 <Eduard_Munteanu> @hoogle RWST
03:59:51 <lambdabot> Control.Monad.RWS.Lazy newtype RWST r w s m a
03:59:52 <lambdabot> Control.Monad.RWS.Lazy RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
03:59:52 <lambdabot> Control.Monad.RWS.Strict newtype RWST r w s m a
04:01:34 <quuuux> Eduard_Munteanu: it's a bit of a band-aid fix, and only really helps if you happen to have those monad transformers in the stack anyway. There are several StateTs hidden behind newtypes, for example, but I'd have to break the abstractions to get at them
04:02:02 <quuuux> at that point, I might as well ditch monad transformers and write it all monolithically anyway, I figure
04:14:29 <palmje> anyone know how I can define my own read/show for something that has a polymorphic definition already? already tried enablinng the TypeSynonymInstances, OverlappingInstances and FlexibleInstances language extensions...
04:16:30 <Twey> palmje: Don't, and newtype it?
04:17:00 <koala_man> 12:58 <mortenmj> dårlig med billigbilletter neste helg, men etter der funker
04:19:08 <palmje> Twey: I'll try making a newtype, though I thought it was possible to override polymorphic definitions with more specif ones...
04:19:34 <Saizan> what do you mean by polrmorphic definition?
04:22:15 <Twey> Saizan: Probably trying to add a new Show instance for String…
04:23:09 <palmje> Saizan: a polymorpic definition is one that involves type variables, so that it matches multiple types
04:23:45 <Saizan> i'd s/definition/instance/
04:24:14 <Saizan> anyhow, with OverlappingInstances it should work, modulo the brokeness of OverlappingInstances itself
04:25:13 <palmje> tried that already... comes up saying that the overlap is allowed, but still complains about an overlap...
04:26:23 <banisterfiend``> palmje: explain monads to me plz
04:27:12 <ddarius> @src ReadS
04:27:12 <lambdabot> Source not found. Do you think like you type?
04:27:35 <ddarius> @hoogle (a -> b) -> ReadS a -> ReadS b
04:27:35 <lambdabot> No results found
04:29:08 <Saizan> palmje: you should paste the code and the error somewhere
04:30:17 * ksf gets a (meagre) speedup with -optlo-O3
04:32:06 <ddarius> :t reads
04:32:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:34:58 <qfr> Hmm is it possible to generate [1..1/0] using pretty much nothing but fix and a lambda? I suck at recursion
04:36:22 <Saizan> > fix $ \xs -> 1 : map (+1) xs
04:36:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:37:32 <banisterfiend``> qfr: what is fix?
04:38:13 <palmje> Saizan: http://pastebin.ca/2036647
04:38:22 <qfr> fix f = f (fix f), banisterfiend``
04:38:24 <c_wraith> qfr: fix is generalized recursion.  You can do anything with fix and lambda.
04:39:18 <banisterfiend``> c_wraith: what do u mean by generalized recursion
04:39:20 <ddarius> With types that's not exactly true and I think you meant "general recursion."
04:39:29 <c_wraith> err, yes.  I do.
04:40:08 <McManiaC> http://npaste.de/ti/ <- whats wrong with that let?
04:41:03 <qfr> @src map
04:41:03 <lambdabot> map _ []     = []
04:41:04 <lambdabot> map f (x:xs) = f x : map f xs
04:41:17 <c_wraith> banisterfiend``, fix is a way of abstracting out recursion.  It's more broad in application than things like map or folds, but it's the same sort of idea.
04:43:02 <Saizan> palmje: weird, i thought that would work with OverlappingInstances, i wonder if the type synonym is interfering ehre
04:44:28 <arcatan> McManiaC: it should be let { x = 5 };
04:44:47 <palmje> Saizan: that's what I'd have thought as well...
04:44:53 <palmje> I'll just try making it a new type like Twey suggested
04:46:27 <Saizan> palmje: ghc version?
04:46:52 <palmje> 6.10.4
04:46:57 <Saizan> (btw, i'd just define a datatype data Pair = Pair Int Int, maybe with record fields)
04:47:27 <qfr> How do you generate the Fibonacci sequence using fix and a lambda which uses no recursion?
04:47:58 <Botje> carefully
04:48:10 * Eduard_Munteanu finds Writer to be useful with ByteStrings, for side-effectful mapping over them
04:48:16 <qfr> (using map in the lambda would count as recursion)
04:48:36 <c_wraith> did someone demand that you use fix only once?
04:48:52 <c_wraith> You could easily write the map using fix, also
04:49:02 <palmje> Saizan: might be easier that way... just means I'll have to create a few more instances, which is what I was trying to avoid...
04:49:10 <qfr> Hmm I wanted to use fix outside the lambda only
04:49:11 <Jafet> @pl let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
04:49:11 <lambdabot> fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
04:49:30 <c_wraith> Jafet, zipWith is map, for the purposes of this discussion :)
04:49:56 <Twey> map, a.k.a. zipWith1
04:50:38 <Jafet> Or (<$>). Wait, that's the same as zipWith.
04:50:53 <Twey> Depends on the instance
04:51:25 <Twey> (<$>) is not the same as zipWith even for ZipLists
04:51:27 <Twey> It's map
04:51:34 <qfr> Saizan: Actually, how do you do the [1..1/0] thing from earlier using 1 fix and no further recursion actually?
04:51:52 <Twey> You map the function over the first list to get a list of functions, then use (<*>) in the ZipList applicative instance to apply that list to another list
04:53:54 * Twey can't figure out how to write map in terms of fix :-\
04:54:04 <shachaf> @src map
04:54:05 <lambdabot> map _ []     = []
04:54:05 <lambdabot> map f (x:xs) = f x : map f xs
04:54:21 <shachaf> Presumably just translate that?
04:54:26 <Twey> I'm trying :þ
04:54:33 <Twey> The base case in particular is giving me trouble
04:54:45 <Twey> fix doesn't really allow for a base case, does it?
04:54:51 <shachaf> Sure it does.
04:54:57 <shachaf> fix f = f (fix f)
04:54:59 <shachaf> That's all it does.
04:55:44 <shachaf> > let { maplike map _ [] = []; maplike map f (x:xs) = f x : map f xs } in fix maplike succ [1,2,3]
04:55:45 <lambdabot>   [2,3,4]
04:55:47 <Twey> > fix $ const []
04:55:48 <lambdabot>   []
04:55:50 <shachaf> It's exactly the same code.
04:55:52 <Twey> Hrm
04:56:35 <Saizan> > fix (\k i -> i : k (i+1)) 1
04:56:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:56:43 <Saizan> qfr ^^^
04:56:55 <qfr> AH
04:56:58 <shachaf> Twey: You should read http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps :-)
04:57:31 <ksf> great. while runtime is staying quite constant, I'm shaving off time from the profiling runs...
04:57:31 <qfr> I was thinking about using a binary lambda earlier but partial application didn't occur to me
04:57:42 <qfr> fix requires an unary function after al
04:57:45 <qfr> all*
04:57:53 <Twey> But what about combining the two into a lambda?
04:58:08 <Twey> Oh, wait
04:58:11 <Twey> I see… sort of…
04:58:15 * Twey reads the paper.
04:58:22 <Saizan> it requires a function of type a -> a, you can take a = Int -> [Int] though :)
04:58:23 <Kaidelong> @ty fix (:)
04:58:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> [a]
04:58:24 <lambdabot>     Probable cause: `:' is applied to too few arguments
04:58:24 <lambdabot>     In the first argument of `fix', namely `(:)'
04:58:35 <Kaidelong> oh right
04:59:54 <Eduard_Munteanu> :t id == id
04:59:55 <lambdabot> Bool
05:00:00 <Eduard_Munteanu> > id == id
05:00:01 <lambdabot>   *Exception: (==): No overloading for function
05:00:23 <ksf> these numbers don't make any sense.
05:00:32 <Botje> Man came home after business trip. The same day in the middle of the night naked man with a knife jumps out of the wardrobe and shouts: "I am fugitive criminal Ivanov!" and then run through the door. Few second after that another naked man jumps out of wardrobe and shouts "I am police detective Petrov, have you seen where fugitive criminal Ivanov gone?" confused husband gestured to the door. "Thank you, citizen, SWAT team, follow me!"
05:00:42 <Botje> oops
05:00:43 <Eduard_Munteanu> Meh, I thought I could use functions as identifiers.
05:01:09 <Twey> Botje: Now I want to know how it ends :þ
05:01:52 <ksf> http://hpaste.org/paste/42704/knuc_annotation#p42705
05:02:07 <ksf> can anyone explain to me how keyEq and hashGenome can take so much time?
05:03:14 <ksf> (and please excuse the code quality)
05:03:24 <Botje> Twey: where did it get cut off?
05:04:22 <Twey> Oh, or perhaps that was the whole thing
05:04:34 <Twey> … follow me!"
05:04:39 <Eduard_Munteanu> ksf: given your total runtime, I'd suggest trying with -H64m or something first.
05:04:44 <Botje> yes, that was it :P
05:05:05 <ksf> makes it slower.
05:05:15 <Botje> it's a russian version of the 'wife with man in bed' joke
05:05:52 <Eduard_Munteanu> ksf: does '-s' suggest the GC eats a large part of the time, or not?
05:06:11 <tibbe> Designing a collection API is surprisingly hard.
05:06:31 <ksf>   Generation 0:  3094 collections,     0 parallel,  0.02s,  0.02s elapsed
05:06:32 <ksf>   Generation 1:     2 collections,     0 parallel,  0.00s,  0.00s elapsed
05:06:53 <ksf>   Productivity  99.5% of total user, 97.3% of total elapsed
05:07:17 <Eduard_Munteanu> Doesn't look like much.
05:07:35 <Eduard_Munteanu> tibbe: like HList?
05:07:48 <tibbe> Eduard_Munteanu: Like a new Data.Map.
05:10:18 <Eduard_Munteanu> ksf: what else does hashGenome do, besides calling your functions?
05:10:36 <Eduard_Munteanu> (lib functions won't show there)
05:10:47 <ksf> it loops.
05:11:25 <ksf> it moves a n-character window over the bytestring and feeds the hashtable with it.
05:11:51 <ksf> that's the outermost shell of the tight loop
05:12:21 <monadic_kid> how do you add a new group in the haskellers site?
05:12:31 <monadic_kid> *interest group
05:14:09 <ksf> keyEq could have an alignment problem, but that's not going to hit seriously, not with merely two peeks.
05:16:37 <Jafet> ksf: try cachegrind?
05:22:45 <ksf> hmmm. I doubt I'm going to find anything interesting with it.
05:23:52 <ksf> > 28 * 30
05:23:53 <lambdabot>   840
05:24:11 <ksf> that's the whole hashtable.
05:24:40 <ksf> my cache is a thousand times bigger.
05:28:29 <ddarius> There are some -really- stupid people out there.
05:29:47 <Philippa> what else is new?
05:30:14 <Kaidelong> context would be nice
05:31:32 <Jafet> The grammar of the universe is context-free with respect to that sentence
05:44:20 <Erito> i've heard you're better at programming once you learn haskell. Does this mean youll be better at solving algorithmic problems or something else?
05:46:13 <Jafet> My numerical programming didn't improve much by learning Haskell
05:46:42 <ddarius> Jafet: That of course means you just haven't learned Haskell enough.
05:47:01 <Jafet> Oh, but of course
05:47:10 <sipa> @faw will haskell improve your numerical programming?
05:47:10 <Philippa> Erito: it can help there (it's a great environment to get a grip on a more abstract view of algorithms in, not to mention thinking about things like fusion), but also larger-scale design issues
05:47:11 <lambdabot> The answer is: Yes! Haskell can do that.
05:47:13 <sipa> see?
05:47:30 <c_wraith> Erito, when people say that, they generally mean "you will learn different ways to solve problems, with different tradeoffs, giving you more tools to apply as appropriate"
05:47:42 <ksf> cachegrind says 
05:47:44 <ksf> ==22649== I1  miss rate:        0.00%
05:47:44 <ksf> ==22649== L2i miss rate:        0.00%
05:47:55 <c_wraith> Erito, it's not really about algorithms, so much as design philosophies
05:48:53 <Erito> thank you for answering
05:50:24 <Jafet> ksf: er, well, now you know it's not cache effect! <insert GI Joe slogan here>
05:53:17 <ddarius> Jafet: The other half is killing.
05:57:41 <mathijs> I would like to read data from a socket. at the moment it's line based so using hGetLine and hPutStrLn works fine. however, I would like to change this to handle (semi)binary data. I've already changed to ByteString, but now I want to find a replacement for the get/put Line stuff
05:58:00 <Eduard_Munteanu> @hoogle iterate
05:58:00 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
05:58:01 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
05:58:01 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
05:58:09 <Eduard_Munteanu> :t iterateM
05:58:10 <lambdabot> Not in scope: `iterateM'
05:58:14 <Eduard_Munteanu> Gr.
05:58:56 <mathijs> I can't use hGetLine, because it's perfectly possible a client sends me a request that is not ended by \n. hGetContent is the magic/lazy stuff I want to stay away from. and hGetChar sounds too small for my purpose.
05:58:57 <Eduard_Munteanu> mathijs: I think BS has lines/unlines as well.
05:59:12 <ddarius> :t $(return 3)
05:59:13 <lambdabot> parse error on input `$'
05:59:52 <mathijs> Eduard_Munteanu: it has, but I don't have any "lines" in my incoming requests anymore. I just collect what's there and feed it through a parser
06:00:28 <mathijs> sometimes what's there is not a full (parsable) request yet, so I need to buffer it until more data arrives.
06:00:48 <mathijs> so basically I'm looking for a hGetWhatsThere function
06:00:51 <pedro3005> how do I print an IO String?
06:01:01 <merijn> mathijs: I think I recall hearing that attoparsec can already deal with partial inputs?
06:01:38 <qfr> Saizan this is embarrassing, I still haven't grasped your fix (\k i -> i : k (i+1)) 1, I suck at picturing the recursion
06:01:45 <mathijs> merijn: that's nice, I'll look at that once I start the parsing bit. For now, I just need to get the data out ;)
06:01:57 <merijn> pedro3005: You are running into the problem that putStrLn expects a String rather then IO String?
06:02:07 <pedro3005> merijn, exactly
06:02:43 <merijn> pedro3005: There are two ways, the ">>=" operator or do-notation (which is syntactic sugar for the former). I assume your new to Haskell?
06:02:52 <ksf> those numbers must be some kind of profiling artifact
06:03:03 <qfr> Oh wait, the k is actually a function
06:03:08 <pedro3005> merijn, yeah. I am using do-notation
06:03:29 <merijn> pedro3005: Can you paste your code so far at hpaste.org?
06:04:38 <pedro3005> merijn, http://hpaste.org/42708/untitled
06:05:06 <chau> wonderful
06:05:16 <chau> I remember reading it
06:06:01 <Saizan> qfr: seen this? http://www.vex.net/~trebla/haskell/fix.xhtml
06:06:11 <ksf> mathijs, there's hGetWhatsThere, in a sense.
06:06:17 <ksf> it's an ioctl.
06:06:18 <monadic_kid> :t hGetLine
06:06:19 <lambdabot> Not in scope: `hGetLine'
06:06:27 <monadic_kid> :t System.IO.hGetLine
06:06:28 <lambdabot> GHC.IO.Handle.Types.Handle -> IO String
06:06:33 <merijn> pedro3005: connectTo returns an IO Handle the same way "hGetLine" returns an IO String, the solution to get a String is also the same. Simply use "msg <- hGetLine conn; putStrLn msg"
06:06:37 <ksf> but then, you could just try to read.
06:07:05 <mathijs> ksf: I'm not sure I understand what you mean
06:07:08 <pedro3005> merijn, but then why wouldn't msg be an IO String?
06:07:10 <Eduard_Munteanu> @hoogle mappend
06:07:10 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
06:07:17 <mathijs> ksf: read char by char you mean?
06:07:42 <merijn> pedro3005: For now (as a newcomer) it is sufficient to just pretend that "<-" explicitly removes the IO part
06:07:59 <ksf> mathijs, http://haskell.org/ghc/docs/6.10.3/html/libraries/base/System-IO.html#v%3AhGetBuf
06:08:25 <monadic_kid> pedro3005: return type of hGetLine does not match the argument type of putStrLn
06:08:35 <merijn> pedro3005: To be more general you can pretend that "<-" turns any type "m a" into type "a"
06:08:36 <pedro3005> merijn, oh, alright. I still get an error though, it doesn't accept 6667 as a port number. hs:5:41:    No instance for (Num PortID)
06:08:42 <ksf> use http://haskell.org/ghc/docs/6.10.3/html/libraries/base/System-IO.html#v%3AhWaitForInput  , too.
06:08:43 <Eduard_Munteanu> @src iterate
06:08:43 <lambdabot> iterate f x =  x : iterate f (f x)
06:08:47 <monadic_kid> pedro3005: look at the types:
06:08:51 <monadic_kid> :t System.IO.hGetLine
06:08:51 <merijn> pedro3005: Try "6667::Int"
06:08:51 <lambdabot> GHC.IO.Handle.Types.Handle -> IO String
06:08:56 <monadic_kid> :t putStrLn
06:08:57 <lambdabot> String -> IO ()
06:09:15 <mathijs> ksf: ah, those look useful. I never used a Ptr though
06:09:15 <ksf> mathijs, you can just guess a buffer size, in the real-world it usually doesn't matter.
06:09:19 <merijn> monadic_kid: He got that far, he just didn't understand what to do about it
06:09:33 <ddarius> merijn: 3 seconds later, "Why do I get a syntax error on print (a <- getLine)?"
06:10:07 <pedro3005> merijn, Couldn't match expected type `Int'            against inferred type `IO Handle'
06:10:19 <merijn> pedro3005: Actually, scratch my last suggestion. That was wrong >.>
06:10:30 <pedro3005> I need to form a PortID somehow
06:10:37 <merijn> @hoogle PortID
06:10:37 <lambdabot> Network data PortID
06:10:58 <pedro3005> 6667::PortID ?
06:11:12 <ksf> mathijs, if you really, really need to know the amount of bytes available for reading you can use the FIONREAD ioctl.
06:11:16 <Saizan> PortNumber 6667
06:11:38 <ksf> but note that what you safe in memory management overhead you can easily lose by calling out to the kernel.
06:11:41 <ksf> so YMMV
06:11:46 <augur> hmm
06:12:04 <augur> ksf: divisor trees. :T
06:12:38 <Eduard_Munteanu> @hoogle mplus
06:12:39 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
06:12:43 <ksf> the nicest way to read a file is still mmap.
06:12:56 <merijn> pedro3005: It appears that "data PortID = Service String | PortNumber Int | UnixSocket String", so you need to specify the constructor to tell it whether it should expect a port number, protocol or file path. So in your case probably "PortNumber 6667" (as Saizan says) or "Service "irc""
06:12:57 <mathijs> ksf: I don't need that for now. this will do I think.  only how do I create the buffer (Ptr a) ?
06:13:05 <mm_freak> in haskell the nicest way i've found so far is to use an iteratee
06:13:17 <knobo> How do I do file upload forms in yesod?
06:13:18 <pedro3005> merijn, yeah, I tried that. getting a very weird error now
06:13:20 <augur> ksf: are there any monads for "diagonalizing" infinite trees?
06:13:23 <ksf> it's just that mmap implementations suck and just flatly refuse to give guarantees about not changing the data under your fingertips.
06:13:29 <knobo> Anyone have any pointer to any example?
06:13:33 <ksf> mathijs, Foreign.Marshal.Alloc
06:13:34 <ddarius> augur: Yes.
06:13:38 <mm_freak> knobo: get the latest version, then you have a form element for that
06:13:40 <augur> ddarius: awesome.
06:13:42 <mathijs> ksf: tnx
06:13:48 <pedro3005> http://paste.pocoo.org/show/313123/
06:13:50 <ksf> augur, how should I know?
06:13:56 <knobo> mm_freak: you mean 7 (beta)?
06:13:58 <augur> ksf: presumably the same way ddarius knows!
06:14:05 <knobo> or 0.7
06:14:19 <merijn> pedro3005: Looks like the Network library on your system is failing
06:14:33 <mm_freak> knobo: donno which version introduces it, but the functions are called fileField and maybeFileField
06:14:49 <merijn> pedro3005: That's not a bug on your code, but something going wrong somewhere else
06:14:53 <augur> ddarius: i've stumboled upon a nice little way of enumerating the infinity list of integer-divisors pairs
06:15:09 <augur> that happens to be self recursive
06:15:11 <merijn> I'm a bit at a loss how to solve that, though. Which compiler/OS are you using?
06:15:19 <augur> kind of like how fibs is self recursive
06:15:27 <pedro3005> merijn, ghc and arch linux
06:15:37 <knobo> thanx. I found it.
06:15:40 <ab9> I want to cleanly uninstall HP 2010.2.0.0 from Mac OS X Snow Leopard. I already ran the GHC uninstall script. If I delete /Library/Frameworks/HaskellPlatform.framework and the corresponding symlinks in /usr/local/bin, will that remove it completely?
06:15:41 <mm_freak> pedro3005: recompile your project
06:15:51 <merijn> Maybe some Arch user in here can chime in with suggestions
06:15:55 <mm_freak> i.e. clean first, then recompile from scratch
06:16:07 <pedro3005> mm_freak, clean?
06:16:08 <mm_freak> whenever i get linker errors, recompilation helped
06:16:26 <mm_freak> pedro3005: are you using cabal to build?
06:16:29 <pedro3005> yes
06:16:34 <mm_freak> cabal clean
06:16:41 <mm_freak> then:  cabal configure && cabal build
06:17:04 <mm_freak> 'clean' removes the 'dist' directory, so you can compile from scratch
06:17:17 <pedro3005> am I supposed to be in a specific directory?
06:17:23 <pedro3005> cabal: No cabal file found.
06:17:29 <mm_freak> in your project root
06:17:46 <mm_freak> where your .cabal file is located
06:18:09 <pedro3005> there's a .cabal directory here
06:18:18 <pedro3005> [pedro@pedro ~]$ ls .cabal
06:18:19 <pedro3005> config  lib  logs  packages  share
06:18:27 <mm_freak> i think you're not using cabal =)
06:18:42 <pedro3005> well I installed Network by doing 'cabal install network'
06:18:58 <pedro3005> I assumed that's what you meant
06:19:02 <mm_freak> you could have installed it through pacman
06:19:14 <mm_freak> pacman -S haskell-network
06:21:06 <merijn> pedro3005: On an unrelated note to this compilation problem. I can recommend reading "Learn You A Haskell" (if you weren't already) to (eventually, in the monad chapters) explain how/why "<-" works to remove the IO part.
06:21:54 <pedro3005> merijn, yeah, just haven't reached monads yet
06:21:56 <mm_freak> I/O in haskell is very easy as soon as you forget the word "monad"
06:22:31 <pedro3005> mm_freak, does pacman override the cabal 'network'? because I still have the same error
06:22:46 <mm_freak> pedro3005: have you installed anything else through cabal?
06:22:46 <merijn> mm_freak: Agreed, that's why I told him to pretend "<-" is just a magical way to turn "IO x" into "x" for now
06:22:54 <pedro3005> mm_freak, no
06:23:35 <mm_freak> pedro3005: then delete ~/.ghc and ~/.cabal
06:23:50 <mm_freak> unless you have hackage login data saved somewhere there
06:24:01 <mm_freak> but since you're a beginner, i don't think so =)
06:24:13 <mm_freak> after that install via pacman haskell-network
06:24:25 <mm_freak> it's the same package, but packaged up by arch maintainers for you
06:25:09 <pedro3005> still same error :(
06:25:19 <mm_freak> then in your project delete all *.o files
06:25:51 <pedro3005> yeah, I tried that.
06:26:37 <mm_freak> same error messages?  or different ones?
06:27:05 <chau> happy new year everyone!who wants help to me download premium the page megaupload.com
06:28:22 <chau> I'm puzzled
06:29:12 <pedro3005> the same mm_freak . at some point I got first a warning "compilation is NOT required" and then the error
06:29:25 <mm_freak> chau: if you notice 100% CPU usage while downloading, you might want to consider switching from lazy String I/O to iteratee-based ByteString I/O
06:29:37 <mm_freak> and yeah, happy new year to you, too
06:29:48 <chau> thanks
06:30:01 <mm_freak> pedro3005: huh?
06:30:12 <mm_freak> pedro3005: have you tried loading your project into GHCi?
06:30:56 <pedro3005> mm_freak, just did, and it works
06:32:41 <Olathe> Hmm, :t whatever can show something even without a Show instance :)
06:33:13 <Olathe> Ahh, never mind :)
06:33:46 <Eduard_Munteanu> Bah, this is stricter than I thought... iterateM :: (Monad m, MonadPlus t) => (a -> m a) -> a -> m (t a)
06:33:49 <Eduard_Munteanu> iterateM f x = (f x >>= iterateM f) >>= \y -> return $ (return x) `mplus` y
06:34:28 <Eduard_Munteanu> This doesn't terminate... iterateM (\x -> return $ x + 1) 1 >>= take 5
06:34:48 <Eduard_Munteanu> Any ideas?
06:35:42 <mm_freak> Eduard_Munteanu: do you want to use this for lists?
06:35:50 <Eduard_Munteanu> mm_freak: yes.
06:36:00 <Eduard_Munteanu> I thought some generality doesn't hurt.
06:36:22 <mm_freak> yes, it's quite strict
06:36:34 <Eduard_Munteanu> Hm, is it the 'bind' that's strict?
06:36:39 <mm_freak> that's in the nature of (>>=) for lists
06:36:40 <mm_freak> yeah
06:37:15 <mm_freak> pedro3005: i think there are some leftover files from an older compilation, which you need to delete
06:37:24 <mm_freak> pedro3005: try removing everything except the source files
06:37:40 <mm_freak> pedro3005: ah, and also make sure you're using --make with GHC
06:38:04 <mm_freak> pedro3005: ghc -O2 -o executable --make Main.hs
06:38:10 <Twey> > take 2 . concatMap (\x -> [x, x + 1]) $ 1 : undefined
06:38:12 <lambdabot>   [1,2]
06:38:27 <pedro3005> mm_freak, ha, the --make did it. thank you!
06:38:35 <mm_freak> pedro3005: you're welcome
06:39:00 <Twey> > take 2 $ 1 : undefined >>= \x -> [x, x + 1]
06:39:02 <lambdabot>   [1,2]
06:39:07 <Twey> Doesn't seem very strict…
06:39:16 <qfr> Saizan it's not that I find the fix operator mystical, I just suck at recursion, still trying to use what you just showed to me for another example...
06:39:42 <mm_freak> Twey: try with an infinite iteration
06:39:52 <Twey> > take 2 $ [1 ..] >>= \x -> [x, x + 1]
06:39:53 <lambdabot>   [1,2]
06:40:09 <mm_freak> no, not with an infinite input list, but with an infinite iteration
06:40:09 <Twey> Like that?
06:40:20 <Twey> Hrm
06:40:55 <Eduard_Munteanu> Maybe it's strict in the second arg?
06:41:10 <Eduard_Munteanu> > take 2 $ [1 ..] >>= \x -> [x..]
06:41:11 <lambdabot>   [1,2]
06:41:13 <mm_freak> Eduard_Munteanu: consider that (>>=) always uses the entire list, including the beginning
06:41:30 <mm_freak> Eduard_Munteanu: so each iteration iterates from the beginning of all sublists
06:41:40 <mm_freak> leading to no output, until the computation is finished
06:41:53 <Twey> But you can get a sublist without traversing the whole of the original list
06:42:25 <Twey> Oh — but the first sublist is the original list?
06:42:40 <mm_freak> > let iterateM f x = liftM2 (:) x (f x >>= iterateM f) in iterateM (\x -> [x+1]) 0
06:42:41 <lambdabot>   No instance for (GHC.Num.Num [a1])
06:42:41 <lambdabot>    arising from a use of `e_1210' at <in...
06:42:45 <mm_freak> uhm
06:43:07 <mm_freak> > let iterateM f x = liftM2 (:) [x] (f x >>= iterateM f) in iterateM (\x -> [x+1]) 0
06:43:09 <lambdabot>   *Exception: stack overflow
06:43:51 <mm_freak> it works only with the empty list
06:43:56 <mm_freak> > let iterateM f x = liftM2 (:) [x] (f x >>= iterateM f) in iterateM (const []) 0
06:43:57 <lambdabot>   []
06:44:21 <Eduard_Munteanu> :t mapM
06:44:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:44:27 <mm_freak> but…
06:44:32 <Eduard_Munteanu> @src mapM
06:44:32 <lambdabot> mapM f as = sequence (map f as)
06:44:36 <Eduard_Munteanu> @src sequence
06:44:36 <lambdabot> sequence []     = return []
06:44:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:44:37 <lambdabot> --OR
06:44:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
06:44:40 <mm_freak> > let iterateM f x = liftM2 (:) [x] (f x >>= iterateM f) in iterateM (\x -> if x < 10 then [x+1] else []) 0
06:44:41 <lambdabot>   []
06:44:58 <mm_freak> as soon as you get a [] it stops with no result…  not very useful
06:45:10 <Eduard_Munteanu> Hm, yeah.
06:45:29 <phao> Is there any function like scheme's apply in haskell? (takes 2 arguments, first the function, second a list, and then calls the function giving all the elements of the list as arguments to the function]
06:45:40 <mm_freak> phao: no
06:45:54 <phao> hmm
06:46:01 <mm_freak> phao: to know why, try to express the type of that function
06:46:19 <phao> its type?
06:46:28 <mm_freak> sure, if the function exists, it also has a type
06:46:55 <mm_freak> apply :: (somethingHere) -> [a] -> b
06:46:59 <mm_freak> what's this somethingHere?
06:46:59 <phao> no clue how to do it
06:47:05 <Jafet> Would work with a hlist
06:47:12 <Eduard_Munteanu> Heh.
06:47:13 <chau> when i restart my device my application setting launch
06:47:14 <chau> d
06:47:15 <chau> fd
06:47:15 <chau> f
06:47:25 <mm_freak> would also work with tuples, but not with lists
06:47:29 <phao> mm_freak, what about a function that takes no arguments... is there such a thing?
06:47:39 <Jafet> I don't think phao even understands the difference between scheme lists and haskell lists at this point
06:47:42 <Eduard_Munteanu> phao: yes, it's a value
06:47:47 <mm_freak> phao: there is no function that takes no arguments…  such a "function" is just a value
06:47:51 <phao> Jafet, I know some of the differences
06:47:55 <phao> but not all of them
06:48:03 <phao> mm_freak, what about getChar
06:48:10 <mm_freak> phao: that's a value
06:48:17 <mm_freak> of type IO Char
06:48:17 <phao> hmm
06:48:24 <phao> right
06:48:38 <mm_freak> interpret this value as "the computation to be done to read a Char from stdin"
06:49:35 <pedro3005> So what method should I be using to read continuously from a socket?
06:50:00 <chau> hj
06:50:04 <chau> d
06:50:08 <mm_freak> pedro3005: if you're a beginner, use lazy I/O, because it's simple
06:50:20 <mm_freak> once you're more advanced, switch to something else like iteratee-based I/O
06:50:39 <gwern> lispy: I'd just like to know what the problem with mueval is; I don't especially need or want another account somewhere :)
06:50:40 <pedro3005> mm_freak, what is lazy I/O?
06:50:46 <qfr> *** Exception: Prelude.(!!): negative index: take 10 $ fix (\f x -> x ++ f [last x + (x !! (length x - 2))]) $ [1, 1]
06:50:51 <mm_freak> pedro3005: hGetContents
06:51:01 <qfr> How could the index ever become negative? I am puzzled
06:51:29 <qfr> It starts out with [1, 1] and then it just gets longer, no?
06:51:39 <qfr> So length x - 2 should be >= 0
06:52:32 <mm_freak> qfr: look at the type of your statement
06:52:38 <mm_freak> it's not what you're expecting
06:53:00 <mm_freak> :t fix (\f x -> x ++ f [last x + (x !! (length x - 2))]) [1, 1]
06:53:00 <lambdabot> forall t. (Num t) => [t]
06:53:04 <phao> liked this getChar... it doesn't waits the line to end
06:53:05 <mm_freak> oh
06:53:13 <qfr> That is precisely what I expected :o
06:53:26 <mm_freak> ok, that's not what /i/ expected =)
06:53:30 <mm_freak> because you're using sublists
06:53:49 <Jafet> What is the length of [last x + (x !! (length x - 2))]
06:53:54 <Jafet> Hint: it's very easy
06:53:55 <qfr> 1
06:53:55 <pedro3005> mm_freak, will that block until it can no longer receive? or will it read line by line, allowing me to interpret each as it goes?
06:54:04 <qfr> Jafet oh
06:54:06 <qfr> Now I get it, haha
06:54:08 <mm_freak> Jafet: yeah, that's what i was getting at
06:54:31 <mm_freak> pedro3005: it will read the entire contents, but lazily, so it will not block
06:54:42 <mm_freak> pedro3005: you get a lazy string back, which does its I/O as needed
06:54:59 <Jafet> phao: that depends on whether your terminal, or whatever input device, uses line-oriented input.
06:56:14 <pedro3005> mm_freak, oh, that is awesome. thank you again
06:56:37 <phao> that's right Jafet ... the interpreter (ghci) that isn't line oriented, it seems.
06:56:38 <chau> any ideas
06:56:43 <phao> the compiled code does =(
06:58:04 <mm_freak> pedro3005: it sounds awesome and certainly is for test applications, but not so awesome for real world applications =)
06:58:26 <Jafet> Sock-it
07:01:54 <aristid> iteratees maybe need more knowledge, folklore and combinators on top of it
07:02:13 <hpc> i think you can hSetBuffering stdin NoBuffering
07:02:16 <hpc> or something similar
07:06:03 <romildo> I need to encode/decode a web page content whose contents is in charset windows-1252. I was going to use the encoding package, but it does compile with ghc-7.0.1. Is there any other solution?
07:06:37 <romildo> I mean that the encoding package does not build with ghc-7.0.1
07:06:48 <mm_freak> aristid: why?
07:06:48 <qfr> > take 10 $ fix (\f a b -> [a, b] ++ (f (a + b) (a + 2 * b))) 1 1
07:06:50 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
07:07:13 <qfr> Saizan: I finally figured it out! This took me like close to 3 hours...
07:07:15 <mathijs> I'm using bracket on a socket. it works as I want. Now I moved that part of my program to a background thread. As a result, when pressing ctrl-c now, the bracket close function does not get called. is there a way to fix this?
07:07:38 <qfr> It's beautiful, it doesn't use any recursion other than fix!
07:07:50 <qfr> Of course I would never write it like that, I was just trying to figure out how to do it.
07:08:09 <shachaf> qfr: (++) is defined recursively. :-)
07:08:11 <mathijs> I should probably kill/join the other thread from the main thread when ctrl-c is detected, but how do I trap that?
07:08:17 <qfr> shachaf: Oh, of course, haha
07:08:46 <shachaf> As are (+) and (*), in theory.
07:09:04 <qfr> Nah, those are fine :P
07:09:11 <Philippa> "other than fix" - you can just build 'em yourself if you're that picky
07:09:18 <merijn> mathijs: *nix I'm guessing? I imagine signal handling is handled in the posix library
07:09:38 <aristid> mm_freak: because they have a steep learning curve
07:09:58 <aristid> mm_freak: which is no wonder given that they originate from Oleg :D
07:10:02 <Saizan> mathijs: Control.Exception.catch?
07:10:23 <mm_freak> aristid: i think richer libraries (i.e. less boilerplate code) will help with that…  as long as you don't have to write Enumerators and Enumeratees, they are fairly easy to use
07:10:30 <mathijs> merijn: I'll have a look there. but isn't there some default setting thingy for this? I mean it looks as if the main thread does do the right thing regarding bracket and interrupts. 
07:10:39 <qfr> shachaf Saizan: Hmm how would you generate Fibonaccis using one fix and lambdas without any further recursion? I didn't think of the ++..
07:10:48 <qfr> @src (++)
07:10:49 <lambdabot> []     ++ ys = ys
07:10:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:10:49 <lambdabot> -- OR
07:10:49 <lambdabot> xs ++ ys = foldr (:) ys xs
07:11:02 <parcs> > fix$(0:).scanl(+)1
07:11:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:11:15 <qfr> @src scanl
07:11:15 <lambdabot> scanl f q ls = q : case ls of
07:11:16 <lambdabot>     []   -> []
07:11:16 <lambdabot>     x:xs -> scanl f (f q x) xs
07:11:24 <qfr> parcs: That's recursive
07:11:37 <qfr> The trick is not to use recursion
07:11:38 <Saizan> qfr: [a,b] ++ foo = a : b : foo
07:11:46 <mathijs> Saizan: that will probably do the trick. thanks. However, I think it's strange that this isn't needed on the main thread.
07:11:54 <qfr> Saizan: Oh, haha. I am so stupiid
07:11:56 <qfr> stupid*
07:12:02 <aristid> mm_freak: yes, richer libraries was what i meant with combinators
07:12:17 <quuuux> qfr: now do it for Church-encoded numerals using only one fix :)
07:12:17 <aristid> mm_freak: and sadly i don't think you can completely avoid enumerators ;)
07:12:23 <qfr> It didn't even occur to me that I had a constant number of arguments in that list :P
07:12:27 <merijn> mathijs: Depends, I'm unfamiliar with Haskell. Normally ctrl-c would cause a signal that kills the process. I'm not sure if haskell by default installs a handler which turns the ctrl-c signal into an exception...
07:12:32 <qfr> quuuux: I don't even know what that is :/
07:12:53 <mm_freak> aristid: i think you can, because most of the time you just enumerate lists, files or EOF
07:12:59 <qfr> > take 10 $ fix (\f a b -> a : b : (f (a + b) (a + 2 * b))) 1 1
07:13:00 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
07:13:01 <mm_freak> with "files" including also sockets
07:13:05 * qfr approves
07:13:23 <qfr> I bet you can do it even shorter using the same approach though
07:13:29 <qfr> I'm just a noob at recursion
07:13:30 <aristid> mm_freak: what if you need to parse a socket into messages first?
07:13:58 <Saizan> mathijs: bracket is a combinator built on top of catch, in case of exception it runs the closing action and rethrows the exception
07:14:39 <mm_freak> aristid: either use an enumeratee or a parser
07:14:42 <Saizan> mathijs: and Ctrl-c is translated into an exception iirc
07:14:46 <mathijs> Saizan: ok, so my problem is that no exception gets raised in that background thread on keyboard-interrupt
07:14:47 <ksf> romildo, there's the implicit assumption that if you want to try out a ghc that isn't in the platform, yet, you're agreeing to fix all broken packages you happen to need.
07:14:53 <mm_freak> aristid: or an enumeratee that is a parser
07:15:06 <Saizan> mathijs: sounds right
07:15:14 <ksf> romildo, that said, ICU might work.
07:15:35 <aristid> mm_freak: i'm still not firm at all with these things, which is perhaps the point
07:15:57 <Saizan> mathijs: ctrl-c is probably sent to the main thread, which could use killThread to propagate it to the background one
07:16:28 <mathijs> Saizan: ok cool. so all I need is a list to keep track of all background threads :)
07:17:54 <Saizan> mathijs: test if ^C is reported as an exception first, i'm not 100% sure of that :)
07:18:07 <qfr> quuuux http://en.wikipedia.org/wiki/Church_encoding#Translation_with_other_representations heh
07:18:44 <ksf> mathijs, you might want to have a look at combinatorrent.
07:19:01 <mathijs> Saizan: UserInterrupt seems to be the exception for that
07:19:06 <ksf> it's heavily threaded and uses erlang-style watchdog threads
07:19:38 <ksf> ...and is generally very, very erlangy.
07:19:47 <mathijs> ksf: sounds like a good read then :)
07:20:10 <quuuux> @pl \ a -> f a $ g a
07:20:11 <lambdabot> ap f g
07:23:00 <merijn> mathijs: Its author (jlouis) also has a blog where he discusses the design of combinatorrent and has some comparisons between it and an erlang torrent client he wrote. You can find it as the second google result for "jlouis"
07:23:23 <mathijs> ramblings?
07:24:42 <mathijs> merijn: yep, that's it, great! also a node.js/erlang comparisson.
07:24:51 <phao> The haskell book I'm reading says that IO a is the same as World -> (a, World)
07:25:01 <phao> So IO a should be a function, right...
07:25:20 <c_wraith> phao, if you think about it that way, you will go insane :)
07:25:21 <phao> but I can call getChar and give no argument to it, and it is IO Char
07:25:30 <phao> c_wraith, how should I think aboutit?
07:25:34 <hpc> phao: that's a simplistic view of it, which they just use for demonstration
07:25:51 <mathijs> phao: that way, it _is_ a function, but the runtime supplies the World input argument for you
07:26:05 <phao>  right
07:26:10 <c_wraith> phao: think of IO as opaque.  It really doesn't matter what it *is*.  Just how it works.
07:26:12 <hpc> i think of it as the monad for which an action is executable code
07:26:13 <phao> so the argument is automatically given?
07:26:26 <phao> c_wraith, then I miss all the fun 
07:26:38 <hpc> the inner details of IO are unspecified
07:26:48 <hpc> so there is no "this is IO"
07:26:48 <Saizan> if by "fun" you mean broken irrealistic model
07:26:55 <hpc> it's different for different compilers
07:27:05 <c_wraith> if you want fun, find the definition of inlinePerformIO in the bytestring library.  After reading that, you should be happy to treat IO as opaque. :)
07:27:09 <mathijs> phao, yes, and the result (a, World) is handled by the runtime as well. it applies the World changes you did (like writing to screen) and hands you back a
07:27:12 <quuuux> is there any way to disable either specific warnings or toggle -Werror/-Wwarn for only -parts- of a source file?
07:27:33 <phao> mathijs, so.. I cannot write getChar without calling it?
07:27:34 <phao> I mean
07:27:42 <phao> I can't give getChar as argument to a function
07:27:49 <phao> or can I?
07:27:54 <c_wraith> quuuux, I don't think you can have lower than per-file granularity
07:27:56 <Saizan> quuuux: you can do the former, -fno-warn-foo, check the ghc manual
07:28:10 <Saizan> quuuux: still per file though
07:28:10 <hpc> phao: IO actions are functions
07:28:16 <mathijs> phao, a function that accepts IO Char as input argument, sure
07:28:28 <c_wraith> quuuux, is it possible to move the declarations that need those into another file?
07:28:32 <hpc> for example, id
07:28:35 <hpc> > id getChar
07:28:36 <lambdabot>   <IO Char>
07:29:12 <quuuux> c_wraith: not entirely, no, unfortunately
07:29:24 <Saizan> phao: within that broken analogy, the World argument is given to getChar by >>=
07:29:45 <Saizan> phao: and ultimately given to main from the outside
07:29:50 <phao> Saizan, which broken analogy?
07:29:59 <mm_freak> hpc: IO actions are /not/ functions
07:30:01 <hpc> phao: the World -> (a, World) one
07:30:05 <Saizan> phao: the IO a = World -> (a, World) one
07:30:09 <phao> ok
07:30:12 <mm_freak> hpc: a function involves a (->)
07:30:13 <hpc> mm_freak: well, values
07:30:15 <mathijs> sure, the World is broken :P
07:30:16 <phao> btw, is there really a World type?
07:30:25 <hpc> mm_freak: but i think of values as nullary functions :P
07:30:34 <phao> mathijs, it's cold here when it should be hot! of course it's broken
07:30:40 <Saizan> phao: no and yes
07:30:48 <c_wraith> phao, sort of, in GHC.  It's called RealWorld.  But seriously, thinking about it is only going to mislead you.
07:30:50 <mm_freak> hpc: then you think wrong, because if something is a function, then you can apply values to it
07:30:55 <phao> hhehehhe
07:31:01 <phao> I'll make my own ImaginaryWorld
07:31:14 <phao> in It, characters will be all utf-8
07:31:33 <hpc> in GHC, RealWorld is also unboxed, iirc
07:31:36 <quuuux> hmm. A way to turn specific warnings into errors or back would be nice to have, then I can have -Werror except for the one or two undodgeable ones
07:31:46 <Saizan> what this analogy boils down to is "we implement IO by side-effectful functions which manage sequencing by baton-passing"
07:31:46 <phao> well.. thx people
07:32:07 <hpc> quuuux: i think there's a pragma that lets you ignore specific errors in only certain functions
07:32:17 <hpc> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/pragmas.html
07:33:53 <quuuux> hpc: I was looking at that. OPTIONS_GHC is a file-header pragma, and so is file-granular
07:34:25 <hpc> bleh
07:35:07 <qfr> Uhm what's the Haskell function to get the absolute value of a Num/Fractional?
07:35:28 <qfr> Google lead me to somebody defining it themselves
07:35:31 <sipa> :t abs
07:35:33 <lambdabot> forall a. (Num a) => a -> a
07:35:38 <qfr> Huh, I tried that hm
07:35:52 <merijn> > abs -1
07:35:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:35:53 <lambdabot>    arising from a use of `...
07:36:01 <merijn> > abs (-1)
07:36:02 <lambdabot>   1
07:36:12 <qfr> AH
07:36:25 <pedro3005> http://hpaste.org/42709/untitled returns only one "NOTICE" and stops, but if I exchange line 23 for "putStrLn msg" I get several lines... what's happening?
07:36:27 <merijn> Accidentally applying abs to - like me, I guess?
07:36:31 <qfr> > abs $ -1
07:36:32 <lambdabot>   1
07:36:33 <qfr> Yeah
07:36:42 <qfr> I'm still a noob, it didn't occur to me
07:36:52 <merijn> qfr: - is tricky
07:37:03 <hpc> where "tricky" means "broken"
07:37:09 <quuuux> ((-) :: Num a => a -> a) is my bane too, don't worry
07:37:29 <sipa> > abs -1
07:37:30 <Jafet> (-) = undefined -- there, now use subtract and negate
07:37:31 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:37:31 <lambdabot>    arising from a use of `...
07:37:45 <parcs> :t (-)
07:37:46 <lambdabot> forall a. (Num a) => a -> a -> a
07:37:56 <hpc> there's a way to make it unambiguous, but it requires an invasive language change
07:38:13 <quuuux> I'm surprised it's not a GHC option, actually
07:38:14 <hpc> (make whitespace mandatory for function calls)
07:38:16 <parcs> :t (-5)
07:38:17 <lambdabot> forall a. (Num a) => a
07:38:48 <merijn> hpc: Golfers everywhere will cry ;)
07:40:31 <Saizan> pedro3005: parseCommand returns at most one token, why would you expect that program to print more?
07:40:33 <qfr> > 10^(-1)
07:40:34 <lambdabot>   *Exception: Negative exponent
07:40:39 <qfr> Why is that..?
07:41:00 <jmcarthur> > 10 ** (-1)
07:41:01 <pedro3005> Saizan, because it should be called each time it reads a line from the socket
07:41:01 <lambdabot>   0.1
07:41:13 <jmcarthur> > 10 ^^ (-1)
07:41:14 <lambdabot>   0.1
07:41:21 <qfr> Oh, 3 operators?
07:41:34 <jmcarthur> yeah. kind of unfortunate, but each is for certain cases
07:41:41 <parcs> :t [(**), (^^)]
07:41:41 <lambdabot> forall a. (Floating a, Integral a) => [a -> a -> a]
07:41:42 <vegai> > 10^1.5
07:41:42 <lambdabot>   Ambiguous type variable `t' in the constraints:
07:41:43 <lambdabot>    `GHC.Real.Fractional t'
07:41:43 <lambdabot> ...
07:42:09 <vegai> that's not nice...
07:42:21 <jmcarthur> > 10 ** 1.5
07:42:22 <lambdabot>   31.622776601683793
07:42:24 <Cin> jaspervdj: > (getParams1 "PRIVMSG" ["a","b"] ((,) <$> prompt "x" <*> (prompt "y" `validate` Text.Digestive.Validate.check "must be number" (all isDigit))))
07:42:25 <Cin> Left (Descriptions {unDescriptions = fromList [(PRIVMSG-f0,["x"]),(PRIVMSG-f1,["y"])]})
07:42:25 <Cin> jaspervdj: getParams1 uses eitherForm. I'd expect eitherForm to return the error "must be number". What is missing?
07:42:25 * vegai mutters something about cargo cult mathematics :P
07:42:42 <Saizan> pedro3005: msg there is supposed to be the whole data you'll get from the socket, ever. if you want to do something for each line you've to split it into lines and mapM (or mapM_) over them
07:43:24 <pedro3005> Saizan, ah, I see. not as easy as I thought
07:44:27 <Saizan> mapM_ (putStrLn . parseCommand) (lines msg)
07:45:57 <pedro3005> Saizan, so if I create a function that interprets one line, I should do mapM_ function (lines msg) ?
07:46:14 <Saizan> pedro3005: yep
07:46:26 <pedro3005> why mapM_ and not a regular map or even mapM?
07:47:12 <qfr> > let {f x = x^2 - 2; f' x = 2 * x} in fix (\iterate function derivative x -> let x' = x - function(x) / derivative(x) in if abs (x - x') < 10^^(-6) then x' else iterate function derivative x') f f' 1
07:47:13 <lambdabot>   1.4142135623730951
07:47:17 * qfr smiles
07:47:29 <qfr> Slowly getting the hang of this
07:47:46 <Saizan> assuming function :: String -> IO X; then a regular map would produce a [IO X] which you need to combine into an IO Something if you want the side effect to be performed
07:48:28 <jaspervdj> Cin: could you paste the code somewhere, so I can run it?
07:48:39 <Saizan> mapM will produce a IO [X], but if you're not insterested in the [X] it's more efficient to use mapM_ which discards the results and builds a IO ()
07:49:52 <qfr> Aw, tryhaskell doesn't let you paste stuff?
07:50:55 * hackagebot control-monad-free 0.5.2 - Free monads and monad transformers  http://hackage.haskell.org/package/control-monad-free-0.5.2 (PepeIborra)
07:50:57 * hackagebot control-monad-free 0.5.3 - Free monads and monad transformers  http://hackage.haskell.org/package/control-monad-free-0.5.3 (PepeIborra)
07:57:49 <jaspervdj> Cin: I gotta go afk, feel free to mail me or file an issue on github
08:00:50 <Cin> jaspervdj: Righto, cheers.
08:04:54 <fliebel> Hey, I'm tying to install hoauth, which tries to install bytestring, which fails with a helpfull exit: ExitFailure 1. What can I do? I'm on Mac 10.6
08:07:41 <qfr> Somebody just asked me what the definition of f is, in the following statement: take 10 $ fix (\f a b -> a : b : (f (a + b) (a + 2 * b))) 1 1
08:07:55 <qfr> I wasn't sure actually - it's not defined, is it?
08:08:11 <qfr> Lazy evaluation saves the day?
08:08:34 <Jafet> f is defined recursively via fix
08:09:13 <augur> i think more accurately, f is neither defined nor undefined, its a formal parameter
08:09:22 <Jafet> take 10 $ let f a b = a : b : f (a + b) (a + 2 * b) in f 1 1
08:09:47 <Jafet> Well, it's defined in the context of the whole expression, but not in the lambda expression
08:10:08 <augur> its not even defined in the context of the whole expression
08:10:40 <augur> there is no place outside of the lambda expression where f is defined, and inside the lambda expression it gets bound to different things every time it recurses
08:11:03 <qfr> I find that term fascinating, haha
08:11:09 <augur> what term
08:11:15 <qfr> take 10 $ fix (\f a b -> a : b : (f (a + b) (a + 2 * b))) 1 1
08:11:23 <qfr> It took me hours to write and grasp it
08:11:26 <qfr> :/
08:11:41 <Jafet> You can bind f to fix (...), no?
08:11:49 <Jafet> Its definition doesn't have to change from there
08:11:52 <mreh> :t execState
08:11:53 <lambdabot> forall s a. State s a -> s -> s
08:12:02 <mreh> :t evalState
08:12:03 <lambdabot> forall s a. State s a -> s -> a
08:12:12 <augur> eh.. i dont know how fix is defined so i cant say
08:12:16 <mreh> can't think of useful mnemonic for those
08:12:37 <Jafet> @src fix
08:12:37 <lambdabot> fix f = let x = f x in x
08:12:56 <mreh> :t evalWriter
08:12:57 <lambdabot> Not in scope: `evalWriter'
08:13:00 <mreh> :t execWriter
08:13:01 <lambdabot> forall w a. Writer w a -> w
08:13:01 <augur> @.@
08:13:02 <lambdabot> Maybe you meant: . @
08:13:06 <Jafet> That one works for what I was saying, fix f = f (fix f) might not
08:13:29 <Mitar> @pl 1 : []
08:13:30 <lambdabot> [1]
08:13:47 <Mitar> @pl (id 1) : []
08:13:48 <lambdabot> [1]
08:13:51 <Mitar> great ;-)
08:14:21 <mreh> :t runWriter
08:14:22 <lambdabot> forall w a. Writer w a -> (a, w)
08:14:23 <Mitar> @pl (foo . bar 1) : []
08:14:24 <lambdabot> [foo . bar 1]
08:15:02 <Mitar> @pl (\x -> ((foo . bar x) : []))
08:15:03 <lambdabot> return . (foo .) . bar
08:15:12 <Jafet> Hah
08:15:23 <Mitar> return?
08:15:35 <mreh> return === (:[])
08:15:49 <Mitar> return is list singleton function?
08:15:56 <augur> fix (\f a b -> a:b:f (a+b) (a+2*b)) 1 1 = (let x = (\f a b -> a:b:f (a+b) (a+2*b)) x in x) 1 1 = ...
08:16:02 <mreh> > return 1 :: [Int]
08:16:03 <lambdabot>   [1]
08:16:06 <augur> > fix (\f a b -> a:b:f (a+b) (a+2*b)) 1 1
08:16:06 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:16:10 <Jafet> @src instance Monad [a]
08:16:10 <lambdabot> Source not found. My pet ferret can type better than you!
08:16:21 <Jafet> @src instance Monad []
08:16:21 <lambdabot> Source not found.
08:16:24 <qfr> :D
08:16:29 <augur> oh fibs
08:16:34 <qfr> augur yeah
08:16:39 <augur> i like you better as a list
08:16:48 <mreh> > [1,2,3] >> [a,b,c]
08:16:48 <Jonny> Hello
08:16:49 <lambdabot>   [a,b,c,a,b,c,a,b,c]
08:17:03 <augur> let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
08:17:07 <mreh> Jafet: bind is concatMap
08:17:07 <augur> so much nicer
08:17:13 <augur> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
08:17:14 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)'
08:17:16 <augur> whoops
08:17:19 <augur> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in fibs
08:17:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:17:23 <parcs> drop 1 eh?
08:17:34 <kaini> Hi. I am working through the Haskell Scheme tutorial. Why does this https://gist.github.com/762616 work for binary numbers only? (It says expecting "b" for other bases)
08:17:42 <augur> parcs: yes. obviously!
08:17:54 <parcs> @check liftM2 (==) (drop 1) tails
08:17:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:17:58 <parcs> @check liftM2 (==) (drop 1) tail
08:17:58 <lambdabot>   "*Exception: Prelude.tail: empty list
08:18:04 <augur> tails! thats it
08:18:09 <Jafet> mreh: =<< is indispensable for the seaside links
08:18:10 <augur> > let fibs = 0 : 1 : zipWith (+) fibs (tails fibs) in fibs
08:18:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:18:15 <augur> or not
08:18:15 <parcs> not tails, tail
08:18:21 <augur> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:18:21 <parcs> drop 1 is tail
08:18:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:18:26 <Jonny> Can anyone help me work out why I'm getting an error with this function: http://pastebin.com/VvX42Z5Y
08:18:37 <augur> either way, oh how i love that definition
08:18:39 <augur> this fix definition, bah
08:18:46 <parcs> look at this one:
08:18:51 <parcs> > fix$(0:).scanl(+)1
08:18:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:19:01 <augur> stop it :|
08:19:04 <marens> how do i install xmobar via cabal with the flags with_xft and with_utf8 enabled? do i really have to create a cabal file for it because cabal configure --flags="with_utf8 with_xft" is complaining about a missing cabal file. i'm using cabal for the first time and maybe i'm just missing something.
08:19:57 <augur> fix $ (0:) . scanl (+) 1 == fix $ \x -> 0 : (scanl (+) 1 x)
08:20:03 <augur> > scanl (+) 1
08:20:04 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
08:20:04 <lambdabot>    arising from a use ...
08:20:17 <augur> :t scanl
08:20:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
08:20:36 <augur> > scanl (+) 1 [1,2,3,4]
08:20:36 <lambdabot>   [1,2,4,7,11]
08:21:12 <Jafet> > let fibs = 0: map (succ . sum . (`take` fibs)) [0..] in fibs
08:21:14 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:21:20 <augur> @src scanl
08:21:22 <lambdabot> scanl f q ls = q : case ls of
08:21:26 <lambdabot>     []   -> []
08:21:30 <lambdabot>     x:xs -> scanl f (f q x) xs
08:21:49 <Jonny> Is there anything wrong with this code:
08:21:58 <Jonny> http://pastebin.com/VvX42Z5Y
08:22:07 <Jonny> I am getting a type error but I can't see why :\
08:22:51 <Jonny> actually I see
08:23:53 <mm_freak> can i force users of my library to use the threaded RTS?
08:24:04 <mm_freak> or at least issue a compile-time warning, if they don't?
08:24:13 <mm_freak> latter is probably preferred
08:24:40 <parcs> i think there's a ghc 7 pragma for default runtime options
08:24:50 <Jafet> kaini: <|> doesn't backtrack
08:25:23 <Jafet> You can refactor the parsers, or use some backtracking combinator
08:27:03 <kaini> Jafet, ah okay, thanks for the hint
08:28:19 <ddarius> Jafet: It's not that <|> doesn't backtrack, it does.  It's that Parsec parsers commit once they successfully consume input.
08:29:19 <Jafet> Yeah, once it consumes input
08:29:27 <ddarius> kaini: Probably the simplest thing you can do is replace the uses of char twice, with a use of string.
08:29:44 <ddarius> All string does is use char repeatedly, but with a try around it all.
08:30:05 <ddarius> So, you could alternatively put the two char parsers in a (single) try expression.
08:31:04 <ddarius> All (try p) means is parse p but don't commit even if p successfully consumes some input before failing.
08:32:15 <hpc> if (try p) succeeds, it does consume the input, i assume
08:32:48 <monochrom> yeah
08:32:49 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
08:32:50 <ddarius> hpc: p succeeds then try p behaves just like p except that it holds onto the input longer.
08:34:03 <kaini> hmm
08:34:25 <kaini> string "#b" ... does not work, I'll try the "try" thing now
08:36:51 <kaini> ddarius, perfect, thank you! 'try (string "#b")` works.
08:37:16 <ddarius> @hoogle choice
08:37:16 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
08:37:17 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
08:37:17 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
08:37:39 <monochrom> haskell yoda says: there is no try, there is only do or error :)
08:38:12 <Jafet> But monochrom, there is another!
08:42:01 <mreh> :t intercalate
08:42:02 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:42:12 <rjo> :t ack
08:42:14 <lambdabot> Not in scope: `ack'
08:42:21 <mreh> is there something for intercalating monadic actions?
08:44:05 <hpc> :t \filler xs -> sequence_ (intercalculate filler xs)
08:44:06 <lambdabot> Not in scope: `intercalculate'
08:44:14 <hpc> :t \filler xs -> sequence_ (intercalate filler xs)
08:44:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> [[m a]] -> m ()
08:44:42 <hpc> @pl \filler xs -> sequence_ (intercalate filler xs)
08:44:42 <lambdabot> (sequence_ .) . intercalate
08:45:02 <hpc> or sequence_ .: intercalate, i suppose
08:45:12 <ddarius> :t sequence .: intersperse
08:45:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> [m a] -> m [a]
08:45:28 <mreh> :t intersperse
08:45:29 <lambdabot> forall a. a -> [a] -> [a]
08:45:44 <ddarius> @src intercalate
08:45:45 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
08:46:35 <ddarius> I guess the strict generalization of intercalate would be
08:46:40 <ddarius> :t msum .: intersperse
08:46:41 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> [m a] -> m a
08:46:53 <mreh> mind = blown
08:47:30 <mreh> where do I learn all the advanced monad interfaces?
08:47:37 <ddarius> This last definition having the property that it reduces to intercalate when used in the list monad.
08:47:54 <ddarius> Neither sequence nor msum are advanced.
08:47:59 <monochrom> read Control.Monad
08:48:00 <ddarius> intersperse is just a list function.
08:48:12 <quuuux> :t (.:)
08:48:14 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
08:48:14 <mreh> :t msum
08:48:15 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
08:48:33 <ddarius> I'm pretty sure sequence is in the Prelude and msum is in (Control.)Monad.
08:49:01 <mreh> @instances MonadPlus
08:49:02 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
08:49:19 <quuuux> @hoogle (.:)
08:49:19 <lambdabot> No results found
08:49:39 <quuuux> @src (.:)
08:49:40 <lambdabot> Source not found. My mind is going. I can feel it.
08:49:56 <mreh> odd, it's a custom definition
08:50:06 <ddarius> (.:) is I think a lambdabot function like the alternate definitions of (.) and flip.
08:50:07 <mreh> I was here when it was defined
08:50:11 <ddarius> It is simply (.) . (.)
08:50:24 <quuuux> oh, right. That's a handy combinator
08:50:25 <hpc> :t sequence
08:50:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:50:28 <ddarius> Instead of f .: g you can write (f .) . g
08:50:54 <hpc> ddarius: (.:) = fmap fmap fmap
08:51:09 <mreh> :t (f .:) . g
08:51:10 <lambdabot> forall a b (f :: * -> *) (g :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, Functor g, SimpleReflect.FromExpr (f1 (f (g a))), Functor f1) => f1 (f (g b))
08:51:17 <hpc> or (.) (.) (.) if you feel like golfing
08:51:35 <aristid> hpc: (.) (.) (.) is longer than (.) . (.)
08:51:59 <hpc> or (.).(.) if you don't like style guidelines
08:52:10 * hackagebot manatee-template 0.0.7 - Template code to create Manatee application.  http://hackage.haskell.org/package/manatee-template-0.0.7 (AndyStewart)
08:52:12 <ManateeLazyCat> Look http://haskell.org/haskellwiki/Manatee#How_to_write_Manatee_extension , enjoy! :)
08:52:12 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
08:52:13 <mreh> maybe he meant soccer
08:52:15 <quuuux> (.) (.) (.) is the 'Blinky' combinator
08:52:27 <mreh> it's the total recall operator
08:53:09 <hpc> @let getYourAssToMars = (.) (.) (.)
08:53:10 <lambdabot>  Defined.
08:53:35 <aristid> :t (+1) `getYourAssToMars` (*)
08:53:35 <lambdabot> forall a. (Num a) => a -> a -> a
08:54:13 <ManateeLazyCat> manatee-template is template package to help you create your own manatee application.
08:54:38 <mreh> (sequence_ :. intercalate) is exploiting the fact that [] is a monad then?
08:54:40 <ManateeLazyCat> manatee-template is simplest code to explain how to write your own manatee application.
08:54:48 <ddarius> The story Total Recall is based on is like three pages long.  And the punchline is completely missing from the movie.  (Similarly for I am Legend, albeit, at least the book is 150 some pages.)
08:54:58 <ManateeLazyCat> Feel free ask me any question. :)
08:54:59 <sshc> Hi, I have a dozen or so lined program that uses a library that I'm trying to profile, but I only want to profile the library when one expression / line in the program is being evaluated.  The profiling of the library during everything else is adding too much noise to the results.  How do I only profile the library during one expression?
08:55:04 <hpc> mreh: no; it exploits that [a] can be [m a]
08:55:10 <hpc> :t sequence_
08:55:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:55:12 <hpc> :t intercalate
08:55:13 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:55:18 <aristid> :t sequence_ .: intercalate
08:55:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> [[m a]] -> m ()
08:55:33 <mreh> I must have misread the type before
08:55:34 <hpc> the result of intercalate is fed to sequence_
08:55:52 <mreh> but I understand sequence .: intersperse
08:56:20 <hpc> ddarius: what's the punch line?
08:56:43 <mreh> women don't have three breasts
08:57:03 <ddarius> mreh: There are no three breasted women in the short story.  I'm sorry.
08:57:28 <mreh> -10 points
08:58:05 <ddarius> hpc: I'd ruin it if I told you.  The short story is called "We Can Remember It For You Wholesale."
08:58:19 <hpc> ddarius: ah, cool
08:58:20 <geheimdienst1> "who cares about artsy-fartsy plots and punchlines. gimme the three-boobed babes."
08:58:54 <mreh> why dont we have some .(.*): notation for arbitarily delaying composition
08:59:10 <hpc> :t \f -> (.(.f))
08:59:10 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => f a -> (f b1 -> b) -> (a -> b1) -> b
09:00:12 <ddarius> Oh my God, they are considering remaking Total Recall.
09:00:13 <aristid> mreh: because you haven't written it yet
09:00:47 <mreh> aristid: cool, nice to know it was an original idea
09:01:03 <mreh> (somewhat maybe)
09:01:17 <aristid> mreh: i have no idea if it's an original idea :)
09:01:23 <hpc> presumably, the lack of it in any library means it is an original idea :P
09:01:36 <hpc> (assuming people contribute the junk they write)
09:01:40 <roconnor> ddarius: do you know if Jaynes has written anything about Maxwell's demon?
09:01:42 <mreh> :(
09:01:49 <ddarius> I'm pretty sure Oleg made a deep composition thing.
09:02:06 <Ke> did someone mention thermodynamic boobs?
09:02:19 <mreh> not in the same threads
09:02:25 <mreh> but it's an interesting idea
09:02:31 <ddarius> roconnor: I don't recall anything detailed about it.  It is indirectly alluded to in Clearing up mysteries.
09:03:00 <geheimdienst1> (... hehe, recall, you said recall, ...)
09:03:06 <mreh> arbitary delayed composition would bring points free to a new level
09:03:56 <aristid> mreh: i think to make it work some explicit type signatures would be needed sometimes
09:04:35 <mreh> I'll add it to the list of interesting things 
09:04:46 <mreh> I'm starting a yampa hackathon (of 2) on Monday
09:05:23 <ddarius> Carrots go from being pretty awesome to super awesome when you get rid of all that cellulose.
09:05:43 <aristid> ddarius: how can you do it?
09:05:43 <mreh> are you talking about soup?
09:06:47 <aristid> mreh: is my perception correct that yampa is one of the more popular frp libraries?
09:06:58 <mreh> aristid: yes, in relative terms
09:07:17 <aristid> i heard that the iPhone guys use it
09:08:01 <mreh> I didn't know that, Yale hasn't really blown the yampa trumpet much, so I never hear these things
09:08:05 <mreh> but there's a mailing list
09:08:24 <mreh> oh, not forgetting Henrik at Nottingham
09:08:35 <aristid> and george (according to hackage)
09:08:44 <aristid> Maintainer	George Giorgidze (GGG at CS dot NOTT dot AC dot UK)
09:09:26 <aristid> mreh: i associate nottingham mostly with videos about chemical elements and molecules and physical symbols
09:09:28 <mreh> PhD student maybe, never seen his name in literature
09:09:32 <Saizan> having a working implementation is quite a popularity boost
09:09:42 <aristid> Saizan: hahaha
09:10:02 <mreh> sshh, conal might hear
09:10:25 <aristid> mreh: not being here, i doubt it
09:10:37 <mreh> yeah, I did a whois before I said that :)
09:11:15 <mreh> has anyone read and understood "push pull frp"?
09:11:43 <augur> mreh: probably conal!
09:12:21 <mreh> hohoho
09:12:34 <augur> :P
09:13:04 <Saizan> is that the one with the typeclass morphisms?
09:13:09 <j-invariant> does anyone know SHE?
09:13:27 <aristid> know about it? sure
09:13:31 <mreh> FRP seems to induce rage in some people
09:13:35 <pedro3005> what happens if I call hPutStrLn with an empty string?
09:13:48 <copumpkin> j-invariant: some parts of it
09:13:52 <Saizan> pedro3005: you get a newline?
09:13:53 <mreh> somone on here described it as the narwhal horn before
09:14:54 <augur> mreh: narwhal horn?
09:15:43 <mreh> yeah, that didn't make much sense seeing as i've actually seen a narwhal horn, but I assume he meant unicorns horn
09:15:54 <pedro3005> Saizan, I see. I was planning on making a function that takes a message and calculates a response, but sometimes there is no response, so I thought I'd return "". but then I would put "\n" on the socket, not sure if that's good. any other way?
09:17:17 <lelf> pedro3005: Just "response here" and Nothing?
09:17:27 <Saizan> pedro3005: you can use hPutStr, and add the "\n" yourself when you want it
09:17:52 <geheimdienst1> pedro3005: for things like "a response, but sometimes there is none" you'd usually use a Maybe. in your case it'd be a Maybe String
09:17:57 <geheimdienst1> :t Just "lolcats"
09:17:59 <lambdabot> Maybe [Char]
09:18:03 <geheimdienst1> :t Nothing
09:18:04 <lambdabot> forall a. Maybe a
09:19:13 <pedro3005> I see. so if I call hPutStrLn bla, and bla is Nothing, what happens?
09:19:41 <Saizan> you can't do that
09:19:42 <merijn> pedro3005: You can't do that
09:20:15 <Saizan> but if you have bla :: Maybe String you can "case bla of Nothing -> return (); Just x -> hPutStrLn h x"
09:20:53 <Saizan> "return ()" is the typical "do nothing" action, with type IO ()
09:21:01 <aristid> i wonder if an IsString instance for IsString a => Maybe a would be evil
09:21:18 <geheimdienst1> you might want to check this for how the "case" syntax works http://learnyouahaskell.com/syntax-in-functions#case-expressions
09:21:31 <lelf> ?ty :t let handle (Just response) = putStrLn response; handle Nothing = return () in handle
09:21:32 <lambdabot> parse error on input `:'
09:21:41 <aristid> @index IsString
09:21:41 <lambdabot> bzzt
09:21:45 <lelf> ?ty let handle (Just response) = putStrLn response; handle Nothing = return () in handle
09:21:47 <lambdabot> Maybe String -> IO ()
09:22:34 <copumpkin> :t maybe (return ()) putStrLn
09:22:35 <lambdabot> Maybe String -> IO ()
09:22:59 <ddarius> aristid: instance Typeable a => IsString a where fromString = eval
09:23:11 <aristid> :t eval
09:23:12 * ddarius almost never does a case on Maybe.
09:23:12 <lambdabot> Not in scope: `eval'
09:24:30 <aristid> @hoogle eval
09:24:30 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
09:24:30 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
09:24:30 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
09:24:35 <geheimdienst1> > maybe "moar" (++ "s") $ Just "lolcat"
09:24:36 <lambdabot>   "lolcats"
09:24:46 <geheimdienst1> > maybe "moar" (++ "s") $ Nothing
09:24:48 <lambdabot>   "moar"
09:25:10 <aristid> geheimdienst1: is that part of the Lolcat guide to Haskell?
09:25:14 <pastorn> Lemmih: hello
09:25:30 <mreh> is sequence in Applicative?
09:25:39 <mreh> @src Applicative
09:25:39 <lambdabot> class Functor f => Applicative f where
09:25:39 <lambdabot>     pure  :: a -> f a
09:25:40 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
09:25:50 <ddarius> mreh: It's in the Prelude as I said earlier.
09:25:50 <mreh> no it's Traversable ain't it
09:25:51 <aristid> @hoogle sequenceA
09:25:51 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
09:25:51 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
09:25:58 <pastorn> Lemmih: is there some clever choice behind not exporting the possibility to set icons with Graphics.UI.SDL.WindowManager.setCaption ?
09:26:06 <aristid> @hoogle sequence
09:26:06 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:26:06 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
09:26:07 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:26:12 <pedro3005> Saizan, "hPutStrLn h x" what does the h stand for?
09:26:27 <aristid> mreh: do you trust hoogle more than ddarius? :)
09:26:30 <pastorn> Lemmih: maybe this if fixed IN TEH HEDD
09:26:42 * geheimdienst1 can think of no better medium than lolcats for explaining anything to anyone
09:26:47 <McManiaC> can anyone familiar with happy tell me why I get an infinit loop on "*foo*" here? http://npaste.de/tj/
09:26:50 <pedro3005> ohhh
09:26:52 <pedro3005> handle
09:26:53 <pedro3005> sorry
09:26:57 <Saizan> yeah
09:27:29 <aristid> geheimdienst1: you could compete with BONUS in the space of haskell guides ;)
09:27:48 <McManiaC> the main parser here is "Markups"
09:28:03 <geheimdienst1> learn me moar haskell for great better!
09:28:53 <lelf> I CAN HAZ IO ()?
09:28:58 <aristid> geheimdienst1: i would simply call it "Teh Lolcat guido to Haskell"
09:30:04 <pedro3005> Saizan, so, if you recall, it's using mapM_ . if the function mapM_ calls returns something, can I do (bla = mapM_ f (lines msg); case bla of Nothing .....) ?
09:30:11 <pedro3005> I mean
09:30:17 <pedro3005> bla <-
09:30:27 <geheimdienst1> obviously lyah covers the basics, while the lolguide would cover the more advanced topics, as is appropriate for lolcats
09:30:49 <Saizan> pedro3005: you want mapM then
09:31:24 <pedro3005> Saizan, being the syntax exactly as I said?
09:31:44 <Saizan> pedro3005: but considering what msg is, mapM f (lines msg) would return only after you close the connection
09:32:20 <Saizan> pedro3005: so, you should rather change your f
09:32:35 <fliebel> Veinor: ping
09:32:42 * ddarius wonders if he can embed Brigitte's work into Haskell.
09:33:02 <Saizan> pedro3005: i.e. mapM_ (\line -> do bla <- f line; case bla of Nothing ...) (lines msg)
09:33:40 <Saizan> Brigitte?
09:34:30 <pedro3005> Saizan, that lambda would need access to the handle though
09:34:50 <pastorn> Lemmih: sorry, not SDL_WM_SetCaption, i meant SDL_WM_SetIcon
09:35:24 <Saizan> pedro3005: if the handle was going to be in scope after the mapM then it's in scope in that lambda too
09:36:06 <pedro3005> Saizan, that lambda could end up sort of long.. could I make it a function which receives the handler as parameter?
09:36:24 <Saizan> pedro3005: sure
09:36:33 <hpc> you can always turn a lambda into a function
09:37:16 <merijn> A lambda *IS* a function, just one without a name so you don't have to turn anything into anything. All you need to do is come up with a name for it.
09:38:45 <roconnor> @go anonymous function
09:38:46 <lambdabot> Maybe you meant: google googleit do
09:41:05 <pedro3005> Saizan, do I need ; on case if I'm dividing it in lines?
09:42:14 <parcs> no
09:42:30 <turiya> i am getting a stack overflow message, how do i fix it?
09:42:39 <copumpkin> turiya: depends what's causing it
09:42:41 <mauke> don't overflow the stack :/
09:43:25 * ddarius should get to where he can do era by memory.
09:43:25 <turiya> copumpkin: i am not sure whats the cause
09:43:45 <hpc> era?
09:43:46 <copumpkin> turiya: that's why error reports usually include more of a description of the failing code than "it fails" :)
09:43:47 <turiya> mauke: dont know how :(
09:43:57 <mauke> turiya: me neither!
09:44:08 <mauke> LET'S ALL MOURN TOGETHER
09:44:20 <copumpkin> turiya: you might consider using hpaste.org to tell us what it is :)
09:44:27 <ddarius> copumpkin: You may find "A Type Theoretic Foundation for Programming with Higher Order Abstract Syntax and First-class Substitutions" interesting.
09:44:47 <copumpkin> ddarius: ooh, it definitely sounds like something I'll find interesting! thanks
09:44:47 <ddarius> hpc: DDR 4th mix.
09:45:02 <hpc> oh lol
09:46:00 * ddarius should also get back to where he can trounce Healing Vision (angelic mix).
09:47:30 <turiya> copumpkin: the error message is small, http://hpaste.org/42710/stack_overflow
09:47:56 <copumpkin> turiya: I mean the code that causes it :) the error message really tells us very little more than what you already told us
09:47:56 <mauke> oh noes
09:48:24 <copumpkin> turiya: put yourself in our shoes for a moment and consider what we might need to know to fix it (and how many bits of information you've divulged)
09:49:12 <j-invariant> Why does haskell base on the strange "Num" rather than something simple like .. Ring?
09:49:26 <copumpkin> j-invariant: nobody knows!
09:49:38 <j-invariant> I fix it
09:49:39 <copumpkin> j-invariant: some questionable design decisions early on, that almost everybody hates now
09:49:47 <turiya> copumpkin: oops, did not understand what you meant
09:49:52 <ddarius> Because there would be more people who would be asking "Why is Haskell based on the strange Ring rather than Num?" than the other way.
09:50:06 <j-invariant> ddarius: but there would be an explanation for those guys.
09:50:21 <ddarius> j-invariant: We see how well such explanations work.
09:50:28 <j-invariant> hm?
09:50:29 <ddarius> Also, there's Double.
09:50:43 <copumpkin> then instead of "you need to know ridiculous category theory to do basic IO" the trolls would be saying "you need to know algebra to do basic math"
09:50:59 <mauke> I'd like that
09:50:59 <copumpkin> :P
09:51:01 <j-invariant> :/
09:51:16 <Saizan> ..papers using ML tend to be ugly even in the theoretical parts
09:51:24 <j-invariant> I think, even with Num instead, These folks have a different reason to not use haskell
09:51:26 <ddarius> ML is ugly.
09:51:57 <Eduard_Munteanu> Uh, this is killing me...
09:52:11 <copumpkin> j-invariant: yeah, it's a pretty ugly class, but haskell sort of indirectly encourages you to not break classes up into a finer hierarchy, because defining a dozen instances before you hit Field is a pain
09:52:19 <Eduard_Munteanu> What's a (good) way to get the nodes of a tree by level, especially in monadic code?
09:53:05 <copumpkin> Eduard_Munteanu: Data.Tree?
09:53:05 <Eduard_Munteanu> I'm looking for something like    levels :: STTree s a -> ST s [[STTree s a]], where STTree is my binary tree type living in ST.
09:53:07 <ddarius> Eduard_Munteanu: Do a breadth-first traversal using a queue.
09:53:13 <turiya> copumpkin: here it is, http://hpaste.org/42711/stack_overflow
09:53:13 <Eduard_Munteanu> copumpkin: no.
09:53:19 <ddarius> @google Okasaki breadth-first
09:53:20 <lambdabot> http://debasishg.blogspot.com/2008/09/breadth-first-numbering-okasakis.html
09:53:20 <lambdabot> Title: Ruminations of a Programmer: Breadth-F
09:53:23 <j-invariant> copumpkin: can aynone design a better system that makes it easy to subdivide?
09:53:25 <Eduard_Munteanu> ddarius: thanks.
09:54:16 <copumpkin> levels?
09:54:16 <copumpkin> j-invariant: there are some proposals to amend the class system to allow "default" methods (say Monad were a subclass of Applicative, then it could provide default implementations of pure and <*> in terms of its own methods to save you from having to write the Functor and Applicative instances if you wrote Monad directly)
09:54:31 <copumpkin> but I don't know of any concrete implementations of these ideas
09:54:38 <aristid> :t 1
09:54:39 <lambdabot> forall t. (Num t) => t
09:54:43 <aristid> :t 1.0
09:54:43 <lambdabot> forall t. (Fractional t) => t
09:54:48 <ddarius> :k 1
09:54:49 <lambdabot> *
09:55:23 <aristid> ddarius: i wonder why GHC enables that by default. shouldn't it rather be in an extension?
09:55:48 <Eduard_Munteanu> copumpkin: yeah, but even the 'iterate' stuff in Data.Tree's levels is kinda tough to get working in monadic code.
09:57:46 * Eduard_Munteanu goes code some more Painskell :)
09:58:04 <zachk> Eduard_Munteanu whats painskell? 
09:58:39 <Eduard_Munteanu> zachk: writing non-functional algorithms and C-like code in Haskell.
09:58:56 <zachk> ahhh. for ffi stuff? 
09:58:59 <copumpkin> Eduard_Munteanu: why not implement your tree in terms of an explicit fixed point of a functor
09:59:24 <copumpkin> where you write an additional type to wrap the underlying functor in STRef s if necessary
09:59:36 <copumpkin> it might be cleaner to work with
09:59:56 <Eduard_Munteanu> copumpkin: I can't. I have a tree with STRef links (to parent and downwards).
10:00:06 <copumpkin> ah
10:00:46 <Eduard_Munteanu> It must be structurally mutable, and I must be able to hold refs to leaves, otherwise I would've used zippers :)
10:00:47 <qfr> What's the Haskell equivalent of puts "blah #{someInteger}"
10:01:09 <copumpkin> qfr: you can use Text.Printf I guess
10:01:11 <qfr> sequential putStr and print?
10:01:16 <copumpkin> otherwise, we don't have interpolation
10:01:27 <copumpkin> there have been template haskell versions of it I think
10:01:27 <qfr> Hmm format strings is not elegant though :()
10:01:32 <qfr> s/is/are/
10:01:53 <copumpkin> some would say named variables like someInteger aren't elegant either :P
10:01:55 <zachk> qfr: putStrLn $ "blah " ++ (show someInt) 
10:01:57 <Eduard_Munteanu> I think I've seen some HList implementation.
10:02:16 <qfr> Ah, show, right
10:02:26 <qfr> I guess I'll use that
10:02:37 <sipa> zachk: no need for the brackets
10:02:41 <qfr> Yeah
10:02:45 <qfr> Just USD it up
10:02:59 <sipa> ?
10:03:09 <zachk> oh the parentheneses, oh guess not, i just put alot of parents in my code to make sure 
10:03:19 <qfr> Oh, no need, right
10:03:25 <ddarius> Eduard_Munteanu: Did you get the paste I sent the other day?
10:04:23 <ddarius> > 2 + ((((((negate 5)))))) -- just to be sure
10:04:24 <lambdabot>   -3
10:05:00 <paolino> visually sure
10:05:02 <Eduard_Munteanu> ddarius: hm, I don't think so.
10:05:11 * mauke ponders
10:06:13 <aristid> paolino: function application is visually quite different from operator application, and always has the HIGHEST precedence
10:06:16 <pedro3005> Saizan, can you see what's wrong with http://hpaste.org/42712/bla ?
10:06:20 <aristid> paolino: no need to enclose it in parens
10:06:28 <mauke> ploki has the \V escape sequence in strings that lets you interpolate an expression, as in "x is \Vx and y is \Vy\n"
10:06:31 <pedro3005> I'm getting erros in line 31 and 37
10:06:35 <pedro3005> errors*
10:06:37 <mauke> could something like this be done using TH/QQ?
10:07:27 <Eduard_Munteanu> Here's a paste of my tree code, in case somebody's wondering: http://paste.pocoo.org/show/313234/
10:07:46 <Eduard_Munteanu> (ignore the WriterT and friends imports, those are for some tests and actual code)
10:08:00 <paolino> aristid: I was commenting  2 + ((((((negate 5)))))), nothing more
10:08:29 <aristid> paolino: and i was commenting on your comment
10:09:32 <Saizan> pedro3005: you want "let response = getResponse line" on line 35
10:10:12 <Saizan> pedro3005: in a do-block for the IO monad the things on the right side of <- should all be of type IO Something
10:10:47 <pedro3005> Saizan, so how about take away the do and make it  "respond handler line = case ........ where response = getResponse line" ?
10:11:07 <j-invariant> how do you fix this SHE error?
10:11:08 <j-invariant> Polynomial.hs:29:19: Not in scope: data constructor `SheWitZ'
10:11:08 <j-invariant> Polynomial.hs:30:19: Not in scope: data constructor `SheWitS'
10:11:55 <Saizan> pedro3005: that's fine too
10:12:25 <ddarius> Eduard_Munteanu: http://paste.pocoo.org/show/312549/  Though replace should not overwrite Nothings so the /= should be an equal and the branches switched.
10:12:53 <Saizan> pedro3005: or even "responds handler line = case getResponse line of ..."
10:13:00 <Eduard_Munteanu> Thanks, /me looks
10:13:44 <pedro3005> Saizan, one question. what is the type of 'respond'?
10:14:57 <Saizan> pedro3005: Handle -> String -> IO ()
10:17:50 <Eduard_Munteanu> ddarius: this <- newSTRef =<< Node v <$> newSTRef p <*> newSTRef l <*> newSTRef r
10:18:02 <Eduard_Munteanu> Why do you think these will ever compare equal to anything else?
10:18:41 <Eduard_Munteanu> I see you're tying it up by doing writeSTRef.
10:19:17 <Eduard_Munteanu> Aren't the refs all different, even if they hold the same data?
10:20:09 <Eduard_Munteanu> Oh you're not comparing refs, but nodes. :/
10:20:33 <Eduard_Munteanu> (Sorry, line 8 really applies here :) )
10:21:11 <ddarius> No, I'm only ever comparing references in that code.
10:21:21 <ddarius> References are all different except from themselves.
10:22:03 <ddarius> The only place I compare references is in replace where I'm simply seeing which child of the parent of t t is.
10:22:39 <ddarius> I didn't compile the code, so there are probably errors, and I guess that is one.
10:23:33 <Eduard_Munteanu> Yeah, it's actually comparing "references" as in nodes. Should work with 'deriving Eq'
10:25:55 <Eduard_Munteanu> ddarius: folding over my tree (building a list etc.) looks hella tough considering ST, any advice?
10:26:12 <Eduard_Munteanu> I'm currently using accumulator parameters, kinda ugly.
10:26:30 <Eduard_Munteanu> Like 'path' in here... http://paste.pocoo.org/show/313234/
10:26:50 <j-invariant> use procedural programming Eduard_Munteanu 
10:26:50 <ddarius> It shouldn't be any harder than normal.  A bit more tedious, but logically the same.
10:27:30 <ddarius> Also you're "TreeRef" is not the most pleasant thing to work with.
10:28:15 <Random75> :t Num
10:28:16 <lambdabot> Not in scope: data constructor `Num'
10:28:26 <Eduard_Munteanu> Yeah, it isn't, but I'm not sure I can do any better considering it's emulating a pointer (which could be NULL or something valid)
10:29:53 <ddarius> Eduard_Munteanu: You don't have to copy every minutiae of the imperative solution.  Do you actually need "NULL" pointers for anything other than initialization and representing leafs?
10:30:54 <Eduard_Munteanu> ddarius: yes, I'm travelling upwards and downwards into the tree.
10:31:04 <ddarius> Eduard_Munteanu: How does that require NULL pointers?
10:31:34 <Eduard_Munteanu> ddarius: well, I have to know that a node is the root, i.e. has no parent, for instance.
10:31:46 <Eduard_Munteanu> What would the parent ref be then?
10:31:56 <ddarius> There are ways of doing that without having to have every parent ref be potentially null.
10:32:03 <ddarius> Eduard_Munteanu: You could represent the root specially.
10:32:15 <mathijs> now that we can compile stuff using the llvm backend... is it possible to recompile all base libs (and stuff bundled with ghc) using it?
10:32:32 <merijn> mathijs: In theory it should be, yes
10:32:41 <Eduard_Munteanu> ddarius: yeah, I tried imposing an ADT-like structure before, but it doesn't mix well with refs. It looked like a lot of code duplication.
10:33:29 <merijn> :k Num
10:33:30 <lambdabot>     Class `Num' used as a type
10:33:30 <lambdabot>     In the type `Num'
10:33:53 <merijn> :k Num a
10:33:54 <lambdabot> Not in scope: type variable `a'
10:33:56 <merijn> hmm
10:34:09 <merijn> Oh, duh
10:34:35 <ddarius> data STTree s a = Empty | Root { left :: STRef s (STTree a), right :: STRef s (STTree a) } | Node { left :: STRef s (STTree a), right :: STRef s (STTree a), value :: a, parent :: STRef s (STTree a) }
10:36:35 <pedro3005> Saizan, if x has type [String], can I do 'map (handler `hPutStrLn`) x' ?
10:37:02 <mauke> yes
10:37:13 <mauke> but why is your handle called "handler"?
10:37:26 <pedro3005> well why not?
10:38:17 <ddarius> foldSTTree (a -> b -> b -> ST s b) -> b -> STTree s a -> ST s b; foldSTTree node leaf (Node { value = a, left = l, right = r }) = do bl <- maybe leaf (foldSTTree node leaf) =<< readSTRef l; br <- maybe leaf (foldSTTree node leaf) =<< readSTRef r; return (node a bl br)
10:38:47 <mauke> pedro3005: because I'd reserve that name for ... like, handlers
10:38:54 <ddarius> foldSTTree (\a l r -> return $ a:(l++r)) [] tree
10:39:28 <Eduard_Munteanu> ddarius: thanks, it doesn't look so bad. My main concern was I'd have to pattern match too many times on the constructor.
10:39:54 <ddarius> You have to pattern match on Maybe.
10:39:56 <pedro3005> mauke, anyway, something else is broken then: http://hpaste.org/42713/bla
10:40:20 <mauke> pedro3005: do you get an error?
10:41:07 <pedro3005> mauke, ah, yes. I saw what's wrong
10:41:35 <pedro3005> but there's still one I can't fix
10:41:46 <pedro3005> http://paste.pocoo.org/show/313257/
10:41:50 <Eduard_Munteanu> ddarius: still, won't using a 'go parent' function still result in Maybes? I kinda use that.
10:42:01 <pedro3005> new code http://paste.pocoo.org/show/313258/
10:42:34 <Eduard_Munteanu> ddarius: though I'll try it, but lemme get this breadth-first traversal going first :)
10:42:50 <mauke> pedro3005: use mapM_
10:43:13 <mauke> pedro3005: the resulf of map (hPutStrLn conn) [...] is a list of actions, not an action that prints a list
10:43:55 <ddarius> Eduard_Munteanu: If you make a "generic" parent function, yes, but that doesn't seem necessary or desirable.
10:44:35 <pedro3005> mauke, which map? the one in main or the one in respond?
10:45:12 <mauke> all of them
10:46:08 <pedro3005> mauke, compiled :) let's see if it works
10:46:11 <pedro3005> thank you anyway
10:46:15 <Eduard_Munteanu> ddarius: I see. Maybe it's because I really have no clue how to express this algorithm functionally. For example, at some point it starts at a node, then goes leftwise until no more siblings are left, restarts on the next upper level etc.
10:46:51 <Eduard_Munteanu> (Though I think it's just as pissy to code this stuff in C, too)
10:49:40 <ddarius> It goes left by going up to the first parent it's the right descendent of and then going back down the other side?
10:49:52 <Eduard_Munteanu> ddarius: yes.
10:50:02 <ddarius> Could you just put left sibling pointers?
10:50:28 <Eduard_Munteanu> ddarius: hm, I wonder about that. I'm not sure if it's easier though.
10:50:44 <ddarius> It will be easier to use but harder to build.
10:52:10 <Eduard_Munteanu> ddarius: it still doesn't make the 'levels' stuff go. If I start at a random node 'x', it's okay to go left. But when I get to the next upper level, I have to start at the rightmost node, not at x's parent. :/
10:52:26 <ManateeLazyCat> dcoutts: What's wrong with haskell.org/gtk2hs ?
10:52:41 <dcoutts> ManateeLazyCat: it's not been moved to the new server
10:52:41 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
10:53:05 <Eduard_Munteanu> I suppose I could hack up a 'levels' by using those pointers though, but it's rather hacky.
10:53:33 <ddarius> Yeah, if you wanted to be insane (but efficient, at least for traversal) you could have the "left" pointers wrap around.
10:53:51 <ddarius> You'd still need to know when you were at a new level though.
10:54:13 <copumpkin> dcoutts: I'd also asked the administrator of haskell.org (the old one) to make haskell.org/platform redirect to hackage.haskell.org/platform (since having nice URLs is good for various reasons)
10:54:20 <copumpkin> dcoutts: it seems to have been lost in the move too
10:54:33 <Eduard_Munteanu> I think I'll do it terms of sibling traversal, just to get it done for the moment.
10:54:37 <Eduard_Munteanu> *in terms of
10:54:47 <pedro3005> http://paste.pocoo.org/show/313267/ seems to receive three lines and then time out
10:54:55 <dcoutts> copumpkin: oh, we used to have that redirect did we? ok, that's easy
10:55:16 <copumpkin> dcoutts: yeah, I had just emailed whoever it was who ran the server before and they added it
10:55:36 <copumpkin> I was trying to encourage people to link to that URL instead of the longer one
10:55:36 <copumpkin> @where platform
10:55:36 <lambdabot> http://hackage.haskell.org/platform/
10:55:42 <copumpkin> guess it didn't always work :P
11:01:36 <pedro3005> mauke, hey, if you have time, I'm having some problems with the code above
11:08:41 <ManateeLazyCat> Saizan: Do you interested help me udpate gtk2hs? dcoutts said it's need upgrade WordPress
11:12:54 <Saizan> ManateeLazyCat: i'm not familiar with wordpress, i asked mostly because more than one person came to #haskell wondering where it went
11:13:06 <ManateeLazyCat> If anyone have WordPress knowledge and so kind, please help us move haskell.org/gtk2hs move to new community server, than you very much! :)
11:13:46 <ManateeLazyCat> Saizan: yeap, i suppose it's just temporary download like before, but this time looks not.
11:16:43 <akamaus> ManateeLazyCat, do you need to tweak Wordpress or only move it?
11:17:14 <Eduard_Munteanu> ddarius: this seems to compile, I hope it works... http://hpaste.org/42714/breadthfirst_siblings_up_to_g
11:17:44 <ManateeLazyCat> akamaus: Use new version WordPress
11:17:57 <ManateeLazyCat> akamaus: I'm not familiar WP too. 
11:18:08 <Eduard_Munteanu> Comments wrt style are appreciated too :)
11:20:10 <ManateeLazyCat> akamaus: We really need WP expert help, otherwise gtk2hs always down for user.
11:20:53 <ManateeLazyCat> akamaus: If you want to help, you can send mail to Axel.Simon@in.tum.de to contact Axel (the author of gtk2hs), thank you very much! :)
11:21:45 <tommd> Is the format of Happy info files documented anywhere?  I want to be sure I understand what they're saying correctly.
11:23:33 <akamaus> ManateeLazyCat, ok I will
11:23:45 <ManateeLazyCat> akamaus: Ok, thank you very much! :)
11:24:18 <pedro3005> well
11:24:24 <pedro3005> hPutStrLn doesn't seem to be sending anything
11:24:45 <pedro3005> I started listening on a local port with nc, connected with firefox and it listens fine. connected with the haskell program and nothing is sent
11:25:31 <ddarius> Eduard_Munteanu: Unfortunately, when you start writing imperative code in Haskell you inherit most of the problems of imperative code and so "If it compiles, it works." holds much less often.
11:25:33 <pedro3005> the code is http://paste.pocoo.org/show/313288/
11:26:08 <ManateeLazyCat> @time
11:26:08 <lambdabot> Local time for ManateeLazyCat is Mon Jan  3 03:25:26 2011
11:26:17 <ManateeLazyCat> Bye all, need to sleep. :)
11:28:05 <Saizan> pedro3005: try adding calls to hFlush
11:29:08 <Eduard_Munteanu> I see.
11:29:34 <pedro3005> Saizan, oh, thank you! It works now
11:30:00 <mathijs> Does anyone know of a DSL for asynchronous communication? I want to describe parts of my program as "the result of this db query and that http request" without having to write all stuff in IO. executing my example should just perform the IO and when data arrives, continue
11:31:10 <Philippa> mathijs: I don't off-hand, but a simple wrapper around Chans ought to get you most of that?
11:31:27 <Philippa> (Chans or MVars or...)
11:31:40 <mathijs> that's all IO right?
11:31:42 <jmcarthur> mathijs: there are some cool DSL for that kind of concurrent programming. i can only think of chp and orc right now
11:32:07 <jmcarthur> *DSLs
11:32:38 <mathijs> Philippa: to read/write chans and stuff, all functions will be IO and read like a imperative program. that's what I want to avoid.
11:32:48 <mathijs> jmcarthur: I'll have a look at those
11:32:55 <Philippa> mathijs: so wrap it and call via an Applicative
11:33:58 <mathijs> Philippa: hmm.. that sounds not too hard indeed
11:34:18 <mathijs> Philippa: do you know of any examples doing something like that?
11:34:53 <Philippa> none that I could cite. I'm pretty sure more than one person around here's built libraries in that vein for personal use, don't know of anything that got release
11:34:55 <Philippa> *released
11:36:04 <mathijs> well it's a nice exercise :)
11:37:39 <jmcarthur> mathijs: i've used neither chp nor orc, but i think in orc your code could look something like:   liftA2 f (liftIO dbQuery) (liftIO httpRequest)  -- the dbQuery and httpRequest would be executed concurrently
11:38:31 <mathijs> jmcarthur: that looks promising. I've had a look at chp once, but orc is new to me, I'll have a look
11:39:14 <jmcarthur> mathijs: http://code.galois.com/paper/2010/Hask-Orc-DRAFT.pdf
11:42:55 * hackagebot highlighting-kate 0.2.8.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.8.1 (JohnMacFarlane)
11:47:11 <mauke> @hoogle Maybe a -> Either b a
11:47:12 <lambdabot> Prelude Right :: b -> Either a b
11:47:12 <lambdabot> Data.Either Right :: b -> Either a b
11:47:12 <lambdabot> Prelude Left :: a -> Either a b
11:49:49 <aristid> :t maybe (Left noMsg) Right
11:49:50 <lambdabot> forall a b. (Error a) => Maybe b -> Either a b
11:49:56 <aristid> ^ mauke :)
11:50:41 <mauke> yeah, I'm using 'maybe' now
11:51:27 <aristid> with a different default value from mine?
11:51:41 <mauke> yes, I have a more specific error message
12:00:37 <j-invariant> what are opinions on CATEGORICAL PROGRAMMING
12:00:37 <j-invariant> WITH
12:00:37 <j-invariant> INDUCTIVE AND COINDUCTIVE
12:00:37 <j-invariant> TYPES
12:00:50 <j-invariant> relevant to haskell or not?
12:00:51 <mauke> ALSO, CAPS LOCK
12:00:57 <Phyx-> INDEED
12:01:13 <Twey> shachaf: That's a very peculiar thing you linked me ( http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps ).  It uses some very peculiar phrasing: ‘How much attention should we pay to the first argument? / At least twice as much.’  How exactly does one measure the amount of attention one pays to an argument?  :þ
12:01:22 <j-invariant> oh it even gives haskell implementations
12:03:01 <Cin> What's the straight-forward way to catch all usual exceptions like file not found, pattern match fail, etc. and not important ones that shouldn't be caught like user-interrupt and out of memory?
12:08:36 <akosch> is there a shortcut to modulo == 0?
12:08:48 <mauke> only for 2
12:09:00 <akosch> I don't like to write something `mod` something == 0
12:09:04 <byorgey> akosch: make one yourself
12:09:16 <jmcarthur> @pl \a b -> a `mod` b == 0
12:09:16 <lambdabot> flip flip 0 . ((==) .) . mod
12:09:19 <jmcarthur> not that
12:09:28 <mauke> a `divByP` b = a `mod` b == 0
12:10:10 <parcs> @type (==0) .: mod
12:10:11 <lambdabot> forall a. (Integral a) => a -> a -> Bool
12:10:22 <akosch> thanks
12:10:31 <Phyx-> wtf
12:10:37 <Phyx-> @type .:
12:10:38 <lambdabot> parse error on input `.:'
12:10:52 <Phyx-> what a I missing...
12:11:38 <ion> How about…
12:11:39 <ion> @type (.:)
12:11:40 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:12:15 <Phyx-> *facepalm*
12:12:40 <ion> or simply
12:12:59 <ion> @type (`(`(`(`(.:)`)`)`)`)
12:13:00 <lambdabot> parse error on input `('
12:13:09 <ion> ok, not then. :-P
12:14:18 <Phyx-> @src (.:)
12:14:18 <lambdabot> Source not found. I feel much better now.
12:14:23 <Phyx-> i have never seen that before
12:14:39 <opqdonut_> folklore for second degree composition
12:14:44 <opqdonut_> or whatever you want to call it
12:14:57 <ion> In hindsight, it’s obvious `(+)` or (`foo`) can’t be expected to work.
12:15:31 <parcs> @type fmap fmap fmap
12:15:32 <ion> Hm. Perhaps (`foo`) could work, though.
12:15:32 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:15:41 <opqdonut_> parcs: indeed
12:15:44 <jmcarthur> :t (`mod`)
12:15:45 <lambdabot> parse error on input `)'
12:15:47 <jmcarthur> nope
12:15:57 <jmcarthur> @let fap = fmap
12:15:58 <lambdabot>  Defined.
12:16:06 <parcs> >_>
12:16:12 <j-invariant> ion: obvious how?
12:16:15 <j-invariant> it makes no sense to me
12:16:25 <j-invariant> I think both should work
12:16:48 <Phyx-> parcs: ah, i was missing an fmap
12:17:41 <ion> I mean, `(+)` couldn’t even work in theory as `foo` makes an infix operator out of the name foo, but (`foo`) *could* work in theory akin to how (`elem` [42]) works. Of course, `foo` could be changed to make *any* code within that returns a function an infix operator, though.
12:18:30 <jmcarthur> but then you can end up with ambiguous things like  a`b`c`d`e
12:18:48 <ion> yeah
12:21:13 <aristid> it would have to be two different characters on each side
12:21:22 <aristid> let's say ` and '
12:21:38 <aristid> a`b`c'd'e
12:21:38 <jmcarthur> yeah
12:21:51 <jmcarthur> or a`b'c`d'e
12:22:07 <ion> aristid: ‘ ’
12:22:17 <aristid> ion: how to type that?
12:22:28 <ion> compose < ' and compose > '
12:22:53 <aristid> ion: too hard to type :P
12:24:14 <ion> The fi keyboard layout has altgr-, and altgr-shift-, for them, too. But as i type everything that doesn’t require ä/ö with the us layout, i use the compose shortcuts. After using them for a while, it’s very fast to type them. :-)
12:25:51 <aristid> ion: which key do you map compose to? i use right ctrl
12:26:55 <ion> The right Lose key and the right ctrl key. The Lose key tends to be more conveniently placed, but some keyboards don’t have it, that’s why both of them. :-)
12:27:41 <ion> Btw, a program any user of the compose key should know about: http://www.pixelbeat.org/scripts/ximkeys
12:27:44 <ion> % ximkeys “
12:27:44 <ion> <Multi_key> <less> <quotedbl>    	: "“"   U201c # LEFT DOUBLE QUOTATION MARK
12:32:32 <cederland> Hello, I have a vision to create a biochemistry-game. Anyone willing to discuss a strategy?
12:33:25 <mauke> ion: that's broken
12:36:38 <edwardk> cederland: a strategy for writing the game, or the strategy used within the game?
12:37:14 <cederland> Both I think
12:38:40 <edwardk> well, at the scale of the indie scene, i'll say that what seems to work best for folks is to  iterate, iterate, iterate, get something that you can control up as soon as possible, and keep playing the crap out of it until you get something fun
12:39:46 <edwardk> cederland in the 'abstract' you might find something like http://www.lostgarden.com/2010/12/steambirds-survival-goodbye-handcrafted.html useful
12:40:34 <cederland> edwardk: My idea is quite simple: You have rules, you collect molecules in "volumes", you let them interact 
12:41:03 <edwardk> pure puzzle or is there a timing/stability aspect?
12:43:00 <cederland> The aim is to learn out biochemistry, but i'm not shure about your question
12:43:24 <cederland> Are you familiar with the cell?
12:43:35 <gwern> anyone play Osmos? it's like a newtonian physics learning game
12:43:41 <copumpkin> yeah
12:43:43 <copumpkin> I quite like it
12:43:45 <copumpkin> very relaxing
12:44:08 <jmcarthur> i got bored with osmos
12:44:26 <jmcarthur> it kind of reminded me of... crap, what's the game called...
12:44:28 <edwardk> well, if you're making it as a game, typically you have levels, ad goals, and ease people into harder and harder puzzles. what you described with the volumes and rules sounds like a way to make a given level, but when you put things in a volume, do they interact stably, or would there be a timing aspect as well as a 'mix this with that' aspect.
12:44:42 <edwardk> osmos was relaxing. my wife enjoyed it
12:44:44 <cederland> I imagine having different volumes (blood, cytoplasm, nucleus, mithocondria),
12:44:51 <jmcarthur> flow
12:45:11 <edwardk> jmcarthur: i can see that
12:45:21 <gwern> jmcarthur: oh. I thought the orbital levels were quite challenging and interesting
12:46:01 <edwardk> ah, so biology moreso that biochemistry
12:46:05 <edwardk> er moreso than
12:46:35 <cederland> And a glucos comming with the blood, you capture in the cytosol with hexose ant ATP to G6P
12:46:49 <aristid> gwern: osmos is totally difficult IMO :)
12:47:08 <gwern> I did say physics and not biology
12:47:32 <edwardk> i love the later levels of osmos
12:48:06 <rjo> how do I observe execution time in ghci?
12:48:10 <jmcarthur> gwern: well i admit i didn't give it enough of a chance
12:48:27 <aristid> do you play it on computer or on ipad?
12:48:30 <mauke> rjo: :set +s
12:49:35 <rjo> *Main> primes 10
12:49:35 <rjo> [29,23,19,17,13,11,7,5,3,2]
12:49:36 <rjo> (-2103651100000.00 secs, 1004306256 bytes)
12:50:33 <mauke> haha
12:50:42 <roconnor> fast!
12:51:15 <Twey> @faq Can Haskell perform time-travel?
12:51:16 <lambdabot> The answer is: Yes! Haskell can do that.
12:51:22 <aristid> rjo: the order is reverse, too
12:51:36 <Twey> It's actually a quantum uncomputation
12:52:08 <Twey> Of a previously-computed function from ‘[29,23,19,17,13,11,7,5,3,2]’ to ‘primes 10’
12:52:12 <monochrom> haskell is so cool :)
12:52:26 <j-invariant> what's the difference between  module M where  and  module M () where ?
12:52:39 <monochrom> module M() exports nothing
12:52:51 <Eduard_Munteanu> monochrom: yes it is, do you want a guide?
12:52:52 <Eduard_Munteanu> @where lyah
12:52:53 <lambdabot> http://www.learnyouahaskell.com/
12:52:54 <Eduard_Munteanu> :P
12:52:54 <Twey> ‘module M’ exports everything
12:53:01 <monochrom> except instances
12:53:09 <gwern> aristid: I play osmos on me linux laptop
12:53:16 <Twey> (nothing except instances, not everything except instances)
12:53:18 <monochrom> I learned haskell from the gentle introduction.
12:53:38 <Twey> gwern: Humble Bundle?
12:53:41 <gwern> yup
12:54:29 <Twey> I wanted to buy it, but they stopped selling it before I could :-\
12:54:30 <rjo> that was os x impression of time, it is not speeding in linux either: *Main> primes 10
12:54:33 <rjo> [29,23,19,17,13,11,7,5,3,2]
12:54:36 <rjo> (3.02 secs, 495508316 bytes)
12:55:08 <j-invariant> it says Polynomial.hs:20:0: parse error (possibly incorrect indentation)
12:55:14 <j-invariant> any way to get beter information?
12:55:31 <monochrom> by asking in #haskell
12:55:40 <mauke> j-invariant: probably a missing )
12:55:59 <j-invariant> that't scary mauke! how did you know
12:56:23 <monochrom> he has a table of probability distribution of causes on incorrect indentations
12:56:34 <monochrom> s/ on / of /
12:56:45 <ion> timeTravel = threadDelay  -- FIXME: Still broken with negative time periods.
12:56:45 <Twey> Heh
12:56:52 <mauke> (psychic debugging)++
12:58:02 <scan> uh, hello, someone with some time to maybe discussing combinator construction? (If that's the right term)
13:00:54 <j-invariant> why doesn't import Prelude (Bool(..))
13:00:58 <j-invariant> import True?
13:01:05 <j-invariant> I need the consturctor True
13:01:17 <j-invariant> I can access it with Prelude.True but that doesn't import it
13:01:51 <mauke> I thought it did
13:02:16 <Igloo> Seems to work for me
13:02:34 <j-invariant> oh I just have to use Bool(..) in the export list
13:02:39 <j-invariant> rather than True, False
13:05:49 <knobo> in the form example from http://docs.yesodweb.com/book/forms/ there is a data type Params and a function paramsFormlet that uses it. How can I extend this to use fileField?
13:06:06 <Eduard_Munteanu> Hm, does profiling help to narrow down a stack overflow?
13:08:19 <TTimo> if an evaluation never returns, what tools do I have to investigate ?
13:08:35 <Eduard_Munteanu> Hm it seems so...
13:09:57 <knobo> I don't understand the documentation.
13:10:09 <knobo> http://hackage.haskell.org/packages/archive/yesod/0.6.7/doc/html/Yesod-Form.html
13:10:25 <rjo> TTimo, ghci debugger?
13:10:38 <TTimo> yeah I'm in ghci
13:14:10 <rjo> what if you use stepping? TTimo, http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/ghci-debugger.html
13:15:53 <lelf> ?where aam
13:15:54 <lambdabot> http://www.haskell.org/all_about_monads/
13:16:07 <lelf> where is that now?
13:16:31 <ion> @google "all about monads"
13:16:34 <lambdabot> http://horna.org.ua/books/All_About_Monads.pdf
13:16:34 <lambdabot> Title: All About Monads Contents
13:17:29 <lelf> html?
13:18:31 <jeikobu> @google "all about monads" +html
13:18:32 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg81751.html
13:18:32 <lambdabot> Title: [Haskell-cafe] example in "All about Monads"
13:18:39 <jeikobu> ha
13:19:18 <ion> @google "all about monads" filetype:html
13:19:18 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg81781.html
13:19:18 <lambdabot> Title: Re: [Haskell-cafe] example in "All about Monads"
13:19:23 <ion> meh
13:21:49 <ion> Someone should apply the bat of clue to the maintainers of a certain website for breaking links. :-)
13:22:36 <akosch> can I break a long number over multiple lines?
13:22:51 <monochrom> probably not
13:23:12 <monochrom> just use one single long line
13:23:32 <akosch> it's a very long number :)
13:23:48 <mauke> read "..."
13:24:09 <monochrom> yes I know. I am not religions about "every line must be short"
13:24:16 <monochrom> s/religions/religious/
13:24:21 <lelf> ?slap maintainers of the certain website
13:24:21 <lambdabot> Come on, let's all slap maintainers of the certain website
13:24:33 <mathijs> just round it :D
13:24:34 <monochrom> hahaha, which web site?
13:24:52 <akosch> mauke: hm, read sounds appropriate. how do multiline strings work in haskell?
13:25:15 <mauke> "foo\   \bar" or "foo" ++ "bar"
13:25:29 <monochrom> "hello I am \                  \monochrom"  could use newlines too between
13:25:52 <akosch> I see... thanks!
13:26:06 <lelf> monochrom: guess:)
13:26:15 <monochrom> haskell.org?
13:26:58 <rjo> does anyone have tried F#
13:27:06 <Saizan> assivo... tipo, aveva da ridire su tutto quello che facevamo. ma aveva avuto una vita infelice, quindi in fondo faceva bene a sfogarsi
13:27:18 <Saizan> sorry.
13:27:54 <geheimdienst1> aveva kedavra!
13:28:06 <lantti> bene, tutto beme
13:28:36 <jeikobu> http://pastebin.ca/2036503  Any constructive criticism or suggestions?
13:28:53 <lelf> monochrom: yup
13:29:16 <monochrom> any wrong with haskell.org ? I can't find a problem.
13:29:33 <TTimo> hum, unfortunately :step does not return past some point either
13:29:39 <lelf> ?where aam
13:29:39 <lambdabot> http://www.haskell.org/all_about_monads/
13:29:58 <lelf> monochrom: ^ find that:)
13:30:10 <geheimdienst1> ?help where
13:30:10 <lambdabot> where <key>. Return element associated with key
13:30:16 <monochrom> oh, yeah, that's the tip of a bigger iceberg, the server migration problem
13:31:26 <geheimdienst1> @where+ aam http://horna.org.ua/books/All_About_Monads.pdf
13:31:27 <lambdabot> Good to know.
13:31:32 <geheimdienst1> @where aam
13:31:33 <lambdabot> http://horna.org.ua/books/All_About_Monads.pdf
13:31:55 * geheimdienst1 mumbles contentedly
13:31:59 <monochrom> the idea was: those "sub sites" each has its own maintainer, so the server migration is not responsible for moving (just responsible for the wiki part), each respective maintainer is, and probably should move to community.haskell.org instead.
13:32:09 <lelf> geheimdienst1: not a solution
13:32:22 <mtnviewmark> jeikobu: what do you want to know? 
13:32:27 <monochrom> but most maintainers aren't even awake yet
13:32:42 <lelf> heh
13:32:43 <mtnviewmark> I'd write slowFilterFoldSubseq w/o out so many parenthesis, using either $ or .
13:33:15 <monochrom> there was a question raised "why didn't the migration just copy all of them" and no one could answer. in retrospect I think that's the better thing to do, to include everything in the migration, just copy them over.
13:33:25 <jeikobu> mtnviewmark: Was that a good way to go about it, did I hit any gotchas (I know there's some eta thing with 'where' to beware of), things like that
13:33:55 <monochrom> so for example the gtk2hs home site is also in the same 404 state.
13:34:45 <mtnviewmark> jeikobu: Your use of where seems fine... but your layout of multiBalls and slowFilterFoldSubseq reveal a past with List  :-)
13:35:21 <monochrom> meanwhile, the Yale CS Dept is nice enough to keep around http://haskell.cs.yale.edu/all_about_monads/html/index.html (for example) until jan 31 or something
13:35:26 <jeikobu> Heh
13:35:48 <monochrom> it costs the dept a lot of money to do keep this. they can't afford much longer.
13:36:32 <jeikobu> mtnviewmark: Well thank you, I'll go play with $ and .
13:36:40 <mtnviewmark> for example,
13:36:56 <monochrom> (why it takes so much money is another story. but generally university computing pricing is shielded from free market pricing, so it's really way off)
13:37:22 <monochrom> (easily 10x to 100x the free market price)
13:37:32 <mtnviewmark> multiBalls n = sum . map exp . filterFoldSubseq filt mp (1,0)
13:37:37 <mtnviewmark>     where
13:37:58 <mtnviewmark>        exp sign z = sign * (binomial (bandb - z) fbins
13:38:00 <mtnviewmark>       ....
13:38:25 <mtnviewmark> Haskell tends to read better (IMHO) as a chain of applications, rather than as nested function calls
13:38:36 <aristid> monochrom: hosting a niche topic website costs real money? since when?
13:38:59 <monochrom> no, it is not about niche topic. it is about doing it the university way.
13:39:00 <lelf> monochrom: well, after copying everything it will continue to function properly at least
13:39:20 <jeikobu> Yeah, that it much more straight forward
13:39:31 <mreh> :t runReader
13:39:32 <lambdabot> forall r a. Reader r a -> r -> a
13:41:09 <mreh> it's interesting how some transformers commute, and others dont
13:41:39 <monochrom> (I am not sure which part of "why it takes so much money is another story. but generally university computing pricing is shielded from free market pricing, so it's really way off" implies "niche topic")
13:44:16 <mreh> tbh, the only one I can think of that doesn't, is the List Monad
13:45:45 <monochrom> heh nomad monad
13:46:08 <j-invariant> what does it mean to commute as monads
13:46:11 <monochrom> instance Monad Nomad where return = stay; (>>=) = move
13:46:23 <ion> hah
13:46:35 <Makoryu> （　≖‿≖）
13:47:06 <mauke> http://blog.desudesudesu.org/?p=108
13:47:30 <mreh> WriterT String [] a /= ListT (WriterT String) a
13:47:30 <monochrom> haha
13:47:45 <Makoryu> mauke: Everything about this is amazing.
13:48:05 <Makoryu> mauke: You are a long-haired beautiful anime among men
13:49:28 <mreh> hadooken
13:49:39 <dcoutts> monochrom: re migration, because at the same time the decision was to move most non-core projects off haskell.org and onto e.g. community.haskell.org or another site
13:49:41 <Phyx-> shooooruuuken!
13:50:00 <mreh> asatsatvarukat!
13:50:08 <dcoutts> mornfall: doing both at once meant being able to regain control over the list of login accounts on haskell.org
13:50:58 <Phyx-> mreh: ehh... who makes that move?
13:51:23 <mreh> Phyx- ken/ryu
13:51:37 <Phyx-> heh
13:51:49 <Phyx-> the rolling throw?
13:51:56 <mreh> hurricane kick
13:52:15 <mreh> You Lose!
13:52:20 <mreh> Continue?
13:52:28 <Phyx-> hahahah
13:53:23 <Phyx-> mreh: i thought he said Tatsumaki senpuu kyaku
13:53:29 * hackagebot mysnapsession 0.3 - Sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.3 (ChrisSmith)
13:54:29 * hackagebot mysnapsession-example 0.3 - Example projects using mysnapsession  http://hackage.haskell.org/package/mysnapsession-example-0.3 (ChrisSmith)
13:54:45 <mreh> Phyx- the english version of SF2T just sounded like gibberish
13:58:13 <knobo> I'm not able to post to web-devel@haskell.org 
13:58:23 <knobo> and not able to subscribe
14:00:14 <maltem> Here we go, enumeratees for zlib (de)compression: https://github.com/maltem/zlib-enum/blob/master/Codec/Zlib/Enum.hs
14:01:54 <maltem> I found it quite exhausting to get to type-check maybe that's just the way of iteratees
14:02:50 <Heffalump> dcoutts: who should I talk to to get the bytestring on hackage fixed?
14:03:10 <dcoutts> Heffalump: either dons or I can upload a new release
14:03:26 <dcoutts> I'll have to check with him to make sure there's no other outstanding stuff
14:03:39 <mreh> knobo: googlemail?
14:04:21 <Heffalump> I'm a little confused about the source of the broken ones, since there seem to be patches in the HEAD repo that part fix the problem (but expose another one) and predate the upload.
14:05:06 <Heffalump> and it's not completely obvious how to fix the newly exposed problem, either
14:05:36 <dcoutts> Heffalump: oh, sounds like I've missed something then, I thought it just one problem that was fixed in the darcs repo
14:05:44 <dcoutts> Heffalump: perhaps you can send me an email summary
14:06:13 <dcoutts> Heffalump: I aim to make a bit of time in the next week or two do to releases of my packages for ghc 7
14:06:33 <dcoutts> Heffalump: I finished writing three days before xmas, so I can do that sort of thing now :-)
14:08:10 <Heffalump> cool :-) Is it all submitted then?
14:08:18 <Heffalump> or do you have to wait for stuff to open
14:08:36 * dcoutts will hand in in a week or so
14:09:21 <dcoutts> Heffalump: yep, got to wait for Exam Schools to open, and I should give Oege a moment to read the last bits
14:09:21 <Heffalump> in time for it still to be a Michaelmas submission?
14:09:37 <dcoutts> Heffalump: anything before the start of term I think is ok :-)
14:09:46 <Heffalump> end of 0th IIRC
14:10:03 <Heffalump> I handed in to the graduate studies office, not exam schools, though
14:10:19 <monadic_kid> sorry for the off-topic question but is it bank holiday tomorrow in the UK?
14:10:24 <Heffalump> monadic_kid: yes
14:10:26 <Twey> Yep
14:10:27 <Twey> \o/
14:10:33 <Heffalump> I had to tell two of my colleagues that, otherwise they'd be in tomorrow :-)
14:10:34 <monadic_kid> cool, thanks peeps!
14:10:44 <Twey> Haha
14:10:57 <dcoutts> Heffalump: right, end of 0th week is what I understand it to be too. They changed it to be the exam schools. Dunno why.
14:11:25 <dcoutts> perhaps just to add a bit more class
14:11:44 <knobo> mreh: yes
14:11:49 <Heffalump> the graduate studies office was kind of anti-climactic
14:12:37 <knobo> looks like I'm subscribed now.
14:12:55 <rootzlevel> does anybody know where the gtk2hs website ended up? It's not at http://www.haskell.org/gtk2hs/
14:15:06 <dcoutts> Heffalump: I can believe it. I'll have to plan a little ceremony, no doubt ending up at a pub :-)
14:21:16 <tonkman> how do I controll fps with opengl
14:21:26 <tonkman> or is it even neccessary 
14:23:52 <jrk_> hmm..
14:24:02 <Makoryu> tonkman: OpenGL just draws triangles. Deciding what those should be and when it should draw them is up to you.
14:24:12 <jrk_> i wrote a simple file search program
14:24:35 <tonkman> Makoryu: ok
14:24:40 <jrk_> which actually used to perform a bit better than system.filepath.find
14:24:46 <jrk_> and used less memory too
14:25:01 <jrk_> but it's not that rich in predicates etc..
14:25:04 <jrk_> however
14:25:21 <jrk_> i tried to parallelize it
14:25:28 <Makoryu> tonkman: But Haskell also has bindings to GLUT, which is a framework for writing OpenGL-centric apps
14:25:36 <jrk_> using a mvar
14:25:57 <Makoryu> tonkman: And when you set up GLUT, you can tell it how frequently you want it to call your update functions
14:26:02 <jrk_> but now it is about 1.5 times slower and needs twice as much ram
14:26:16 <tonkman> ok, so it is that simple
14:26:33 <jrk_> what could i do achieve a real speed up?
14:27:12 <jrk_> or are threads with ghc just for concurrency..?
14:27:45 <Makoryu> tonkman: GLUT is probably not what you want unless you're writing a test app of some kind.
14:28:30 <Heffalump> jrk_: did you use the threaded runtime?
14:28:49 <tonkman> I'll check sources of some game what is written is haskell
14:28:51 <Heffalump> you need to compile with ghc -threaded, and then also run the program with ./foo +RTS -N2 -RTS [I think]
14:28:57 <Heffalump> -N2 to use two cores
14:28:59 <jrk_> i think so: compiled with ghc -threaded
14:29:41 * hackagebot data-default 0.2.0.1 - A class for types with a default value  http://hackage.haskell.org/package/data-default-0.2.0.1 (LukasMai)
14:29:44 <jrk_> ok, didn't know about that -N knob :)
14:29:45 <Heffalump> threads should certainly also be for parallelism, but obviously you have to actually write your program in a way that'll make useful use of it. E.g. get the granularity right.
14:29:57 <Heffalump> I can't actually remember whether the default is still -N1 - it used to be.
14:30:15 <j-invariant> I have this data type:  data Quot a = Quot a a
14:30:45 <j-invariant> and we can do stuff liek   Quot 3 4 + Quot 3 5 = Quot 3 7,  it's alright when the first component are equal
14:30:58 <j-invariant> but it's an error of they are different.. so what should I do?
14:31:06 <mauke> type-level naturals!
14:31:17 <j-invariant> well my example is simplified, the truth is they are not natural
14:31:37 <mauke> type-level unnaturals!
14:31:41 <j-invariant> :D
14:32:01 <mauke> type-level abominations
14:32:02 <token22> hi, how to use ixmap to transpose matrix?
14:32:20 <jrk_> Heffalump: that's what i'm trying atm.. the problem i have is with indefinitely blocking mvars (i.e. starvation..)
14:33:44 <Heffalump> jrk_: you might want to try STM instead
14:33:54 <Heffalump> harder to get wrong and more compositional
14:34:02 <Heffalump> more overhead though, but it may not matter
14:34:34 <jrk_> ok, i'll look at it
14:34:37 <monochrom> Quad x y + Quad a b | x/=a = error "invariant broken" | otherwise = Quad x (y+b)
14:34:44 <Cale> j-invariant: You can of course just do runtime checks. It's rather hard (even if it's possible) to enforce things like that at the type level unfortunately.
14:35:24 <jrk_> Heffalump: do you mean Control.Monad.ST?
14:35:36 <jrk_> Heffalump: or is this not in base?
14:35:39 <j-invariant> oh this sucks
14:35:51 <j-invariant> I can't do  zero :: Quot a
14:36:00 <jrk_> ah ok
14:36:01 <j-invariant> because I would have to guess correctly teh value
14:36:01 <jrk_> found it
14:36:09 <jrk_> http://hackage.haskell.org/package/stm :)
14:37:17 <Eduard_Munteanu> What's a '<$>' for monadic functions?
14:37:31 <mauke> what's a monadic function?
14:37:33 <monochrom> zero :: Num a => Quot a
14:37:55 <Eduard_Munteanu> I'm interested in doing stuff like    a <- foo <$> baz <*> bar, where foo :: a -> m b
14:38:08 <mauke> =<<
14:38:13 <monochrom> that is not what <$> does
14:38:41 <copumpkin> :t (=<<)
14:39:04 <monochrom> and I don't know what is intended
14:39:16 <monochrom> analogies are so bloody clear, yeah
14:39:37 <mauke> preflex: seen lambdabot 
14:39:44 <aristid> Eduard_Munteanu: liftM as (<$>) and ap as (<*>)?
14:40:37 <Eduard_Munteanu> fork :: STTree s a -> STTree s a -> STTree s a -> ST s (),   newNode :: a -> ST s (STTree s a),     I want to do...
14:40:47 <Eduard_Munteanu> f1 <- fork =<< newNode "Root" <*> newNode "Left" <*> newNode "Right"
14:41:01 <Eduard_Munteanu> Well, something that works.
14:42:24 <Eduard_Munteanu> aristid: yeah, I mean using an applicative style, so I don't bind *everything* using '<-' and '>>='
14:42:42 <Eduard_Munteanu> But I see <$> works only for pure functions.
14:43:31 <aristid> Eduard_Munteanu: you want something like join $ f <$> a <*> b <*> c?
14:43:48 <monochrom> I think that's it.
14:44:43 <copumpkin> why not f <*> a <*> b <*> c ?
14:44:43 <Eduard_Munteanu> Hm, lemme see, I didn't see that coming...
14:44:52 <Eduard_Munteanu> copumpkin: already tried that...
14:45:03 <copumpkin> what are the types you want?
14:46:09 <Eduard_Munteanu> fork :: STTree s a -> STTree s a -> STTree s a -> ST s (),   newNode :: a -> ST s (STTree s a)
14:46:09 <jrk_> rootzlevel: http://www.haskell.org/haskellwiki/Gtk2Hs
14:46:09 <aristid> :t \f a b -> join $ f <$> a <*> b
14:46:10 <aristid> NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
14:46:10 <copumpkin> @get-Cale
14:47:09 <Eduard_Munteanu> Could not deduce (Applicative (ST s)) from the context ()
14:47:10 <copumpkin> then add it to the context :P
14:47:11 <copumpkin> or use ap and fmap
14:47:11 <copumpkin> or ap and liftM, I should say
14:47:48 <rjo> would anyone be willing to check one paste, if it contains some obvious speedups without affecting the algorihtm?
14:47:56 <Eduard_Munteanu> No instance for (Applicative (ST s))   -- even if I give it -XFlexibleContexts
14:48:03 <Eduard_Munteanu> Looks fishy.
14:48:08 <Twey> rjo: Sure, but if it doesn't then I'm suing for false advertising.
14:48:09 <shachaf> rjo: They'd be much more likely to if you actually @paste it. :-)
14:48:27 <Eduard_Munteanu> My function is test'' :: (Applicative (ST s)) => ST s ()
14:49:03 <Eduard_Munteanu> :t liftM
14:49:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:49:07 <rjo> http://pastebin.com/PCATBAjT
14:49:09 <Eduard_Munteanu> :t <$>
14:49:09 <lambdabot> parse error on input `<$>'
14:49:12 <Eduard_Munteanu> :t (<$>)
14:49:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:49:22 <rjo> it is naiive factorial
14:49:37 <Eduard_Munteanu> :t pure
14:49:38 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:50:22 <Eduard_Munteanu> :t <*>
14:50:23 <lambdabot> parse error on input `<*>'
14:50:26 <Eduard_Munteanu> :t (<*>)
14:50:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:50:53 <danlei> where can I find Bulat's TH tutorials? the links on haskellwiki are broken
14:51:14 <aristid> Eduard_Munteanu: does my "join" solution work?
14:51:41 <Eduard_Munteanu> aristid: nope.
14:51:53 <Eduard_Munteanu> The previous error was for your solution.
14:51:57 <rjo> @paste http://pastebin.com/PCATBAjT
14:51:58 <lambdabot> Haskell pastebin: http://hpaste.org/
14:53:11 <Eduard_Munteanu> :t ap
14:53:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:53:59 <rjo> @paste http://hpaste.org/42717/perf_tets
14:54:00 <lambdabot> Haskell pastebin: http://hpaste.org/
14:54:46 <Eduard_Munteanu> f1 <- fork `ap` (newNode "Root") `ap` (newNode "Left") `ap` (newNode "Right")
14:55:00 <Twey> No need for those brackets
14:55:35 <Twey> Also, try <*> for a less restrictive type
14:55:36 <Eduard_Munteanu> Couldn't match expected type `a -> b'    against inferred type `ST s ()'   Probable cause: `fork' is applied to too many arguments     In the first argument of `ap', namely `fork'
14:55:36 <Eduard_Munteanu> Twey: same thing with <*>
14:55:37 <Twey> What's the type of fork/
14:55:37 <Twey> ?**
14:55:37 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
14:55:37 <Twey> @hoogle fork
14:55:37 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
14:55:37 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
14:55:49 <aristid> Eduard_Munteanu: oh, missing Applicative instance? well, then how about this?
14:55:49 <Eduard_Munteanu> fork :: STTree s a -> STTree s a -> STTree s a -> ST s ()
14:56:02 <aristid> Eduard_Munteanu: join $ f `liftM` a `ap` b `ap` c
14:56:09 <Twey> Hmm
14:56:18 <Twey> I think the precedence might be wrong
14:56:28 <Twey> Oh, yeah, that too
14:56:29 <Eduard_Munteanu> Lemme see... but I thought (ST s) should've had such an instance.
14:56:30 * Twey feels stupid
14:56:53 <Twey> ‘fork’ isn't a value wrapped in ST, so you can't ap it or <*> it to a value that is
14:57:15 <Eduard_Munteanu> aristid: that seems to work. Thanks. But why?
14:58:04 <Twey> Idiomatically, we'd write: fork <$> newNode "Root" <*> newNode "Left" <*> newNode "Right", I guess
14:58:04 <aristid> Eduard_Munteanu: because it's the same as my previous version, but now without Applicative constraint
14:58:04 <Twey> Eduard_Munteanu: 225637 < Twey> ‘fork’ isn't a value wrapped in ST, so you can't ap it or <*> it to a value that is
14:58:04 <Twey> aristid: But with a Monad constraint instead, which is more restrictive >.>
14:58:19 <Eduard_Munteanu> Twey: yes, I know. In fact I asked for a '<$>' that worked with already lifted functions... erm actually a -> m b functions
14:58:25 <Eduard_Munteanu> Partially lifted ? :D
14:58:30 <aristid> Twey: no. because the join already introduces the Monad constraint
14:58:38 <Twey> Eduard_Munteanu: You need to fmap (or liftM, or <$>) the function onto the first ST, since it's not wrapped
14:58:45 <Twey> That gives you a wrapped function-in-an-ST
14:58:53 <aristid> Twey: so in theory, both constraints are equally restrictive, in practice the Monad-only constraint is less restrictive
14:58:54 <Twey> Which you can then ap or <*>
14:59:07 <aristid> and typing with an arm in restraints is tiring
14:59:09 <Twey> aristid: There was no join in the one Eduard_Munteanu posted
14:59:19 <aristid> Twey: but in both of mine.
14:59:20 <Twey> Dvorak-{LR}
14:59:37 <Eduard_Munteanu> Ok, so this works because <$> makes a -> m b into m a -> m (m b), and join makes that latter back into m b? :)
14:59:53 <Twey> Eduard_Munteanu: Yes
15:00:07 <Twey> Eduard_Munteanu: Which is like using ap or <*>, but clumsier ;)
15:00:11 <Eduard_Munteanu> Doesn't look very idiomatic, I wonder why I havent seen this before...
15:00:24 <aristid> :t \a b c -> a <*> b <*> c
15:00:25 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
15:00:30 <Eduard_Munteanu> Twey: I'd very much like to use 'ap' or '<*>' :/
15:00:38 <Twey> Eduard_Munteanu: Probably because it's usually an indication that you should be using Applicative instead
15:01:07 <Eduard_Munteanu> It doesn't seem to be my fault, though... Looks like ST, or MPTCs, don't get Applicatives so easily?
15:01:31 <copumpkin> MPTC?
15:01:38 <Eduard_Munteanu> copumpkin: multi param typeclasses
15:01:40 <copumpkin> ST s can be an Applicative but isn't one right now
15:01:47 <copumpkin> I know
15:01:48 <Twey> Urrrgh
15:01:49 <Twey> http://hackage.haskell.org/trac/ghc/ticket/4455
15:01:52 <copumpkin> but there are no MPTCs here
15:01:54 <Eduard_Munteanu> copumpkin: ah, thanks, that settles it.
15:02:02 <copumpkin> Twey: yep, that was me
15:02:07 <Twey> That's what I get for assuming that all Monads have Applicatives.
15:02:19 <Twey> Eduard_Munteanu: You can still use fmap/liftM and ap, though
15:02:19 <banisterfiend> Eduard_Munteanu: what do u think of ruby
15:02:20 <Eduard_Munteanu> Oh, right.
15:02:22 <copumpkin> Twey: at least it'll get fixed soon
15:02:23 <ceezer> hi, i'm doing euler problem 6 using haskell. Is there a nicer way to write my solution "problem6 = subtract (sum [x*x | x <- [1..100]]) $ (^2) $ sum [x | x <- [1..100]]"
15:02:28 <Twey> copumpkin: Alright… thanks ☺
15:02:35 <copumpkin> banisterfiend: do you have any interest in haskell whatsoever?
15:02:47 <copumpkin> I've seen people grep for your "contributions" to this channel and there's nothing whatsoever
15:02:53 <banisterfiend> copumpkin: no i just join this channel for status reasons
15:02:57 <copumpkin> oh okay
15:02:59 <banisterfiend> so that #haskell shows up in my /whois
15:03:07 --- mode: ChanServ set +o mauke
15:03:07 --- mode: mauke set +q *!*@118.82.186.189
15:03:15 <aristid> :t \a b c -> a <*> (b <*> c)
15:03:16 <lambdabot> forall (f :: * -> *) a b a1. (Applicative f) => f (a -> b) -> f (a1 -> a) -> f a1 -> f b
15:03:22 <mauke> ceezer: [x | x <- [1..100]] better written as [1..100]
15:03:24 <copumpkin> there, mauke made it so we can all be happy now
15:03:34 <Twey> Eduard_Munteanu: fork <$> newNode "Root" <*> newNode "Left" <*> newNode "Right" = fmap fork (newNode "Root") `ap` newNode "Left" `ap` newNode "Right"
15:03:36 <aristid> Eduard_Munteanu: i don't see a way to write my code with only (<*>)
15:03:57 <Eduard_Munteanu> Yeah, I suppose the 'join' trick is okay.
15:03:57 <mauke> ceezer: sum [1..100] better written as 100 * (100 + 1) `div` 2
15:03:58 <aristid> Twey: it binds left-to-right
15:04:18 <Twey> aristid: Right
15:04:18 <copumpkin> Eduard_Munteanu: (=<<) would handle the join more elegantly, I think
15:04:18 <Eduard_Munteanu> Or I could write my own (ST s) instance for Applicative.
15:04:22 <Twey> That's what we want…
15:04:22 <Twey> Eduard_Munteanu: You could do that, yeah
15:04:42 <ceezer> mauke: Is there a way to get rid of my first set of brackets for subtract?
15:04:59 <Eduard_Munteanu> copumpkin: I tried various permutation of (=<<) with no success.
15:05:06 <Eduard_Munteanu> *permutations
15:05:06 <Twey> Eduard_Munteanu: ff <*> fa = do f <- ff; a <- fa; return $ f a
15:05:07 --- mode: mauke set -o mauke
15:05:08 <aristid> Eduard_Munteanu: would be an orphan instance
15:05:09 <Twey> For all monads
15:05:35 <mauke> ceezer: (100 * (100 + 1) `div` 2) ^ 2 - sum (map (^ 2) [1 .. 100]) ?
15:05:44 <mauke> also, that's 5050
15:05:45 <copumpkin> \f x y -> do a <- x; b <- y; f a b
15:05:52 <copumpkin> Eduard_Munteanu: that's what you want
15:06:03 <Twey> ff <*> fa = ff >>= flip liftM fa
15:06:04 <Twey> I guess
15:06:20 <zygoloid> @tell kcm Hades is still under development in the sense that it's not releasable yet, but i'm not intending to spend any cycles on it for the next month or so. and there's no ghc7 support yet.
15:06:20 <lambdabot> Consider it noted.
15:06:23 <aristid> copumpkin: the problem with using (=<<) or (<*>) all the way is that it joins too early, the "f" needs to have all parameters applied before being joined
15:06:44 <copumpkin> @undo \f x y -> do a <- x; b <- y; f a b
15:06:44 <lambdabot> \ f x y -> x >>= \ a -> y >>= \ b -> f a b
15:06:51 <copumpkin> aristid: ?
15:07:01 <aristid> :t \f a b c -> (f =<< a) `ap` b `ap` c
15:07:01 <lambdabot> forall a (m :: * -> *) a1 a2 b. (Monad m) => (a -> m (a1 -> a2 -> b)) -> m a -> m a1 -> m a2 -> m b
15:07:09 <copumpkin> @pl \ f x y -> x >>= \ a -> y >>= \ b -> f a b
15:07:10 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
15:07:12 <copumpkin> :P
15:07:23 <aristid> copumpkin: not elegant :P
15:07:35 <Eduard_Munteanu> copumpkin: yeah
15:07:52 <mtnviewmark> why are we trying so hard to re-write liftM2?
15:07:58 <mtnviewmark> @src liftM2
15:07:58 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:08:03 <copumpkin> it isn't liftM2
15:08:14 <mtnviewmark> ah, no final return
15:08:14 <copumpkin> it's join after liftM2
15:08:19 <Twey> It's ap ;)
15:08:37 <mtnviewmark> @src liftA2
15:08:37 <lambdabot> liftA2 f a b = f <$> a <*> b
15:08:57 <mtnviewmark> right - not that either
15:08:58 <copumpkin> it's not ap either, directly
15:09:01 <copumpkin> it needs all of Monad
15:09:18 <j-invariant> Why can't we use haskell modules as functions?
15:09:22 <mtnviewmark> just    (join .) . liftM2
15:09:34 <copumpkin> ((join .) .) . liftM2
15:09:37 <copumpkin> isn't it?
15:09:37 <aristid> :t join .: liftM2
15:09:38 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
15:09:38 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
15:09:38 <lambdabot>     In the second argument of `(.:)', namely `liftM2'
15:09:44 * Twey scratches his head.
15:09:46 <aristid> :t join .: liftM
15:09:47 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> m a1 -> m a
15:10:00 <Twey> 230629 < copumpkin> @undo \f x y -> do a <- x; b <- y; f a b
15:10:03 <Twey> This is ap
15:10:17 <copumpkin> doesn't look like it to me
15:10:18 <Twey> Oh, wait
15:10:19 <Twey> No return
15:10:20 <copumpkin> :t ap
15:10:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:10:32 <Twey> Okay, silly me
15:10:39 <aristid> so far you haven't beat my solution :P
15:12:22 <danlei> still searching for Bulat's TH tutorials. is there maybe some kind of mirror I don't know about?
15:19:09 <ceezer> mauke: Thank, I think you're right "(100*101 `div` 2)^2 - (sum $ map (^2) [1..100])" seem like a good solution (maybe not the most readbale though)
15:20:07 <Eduard_Munteanu> I find it readable.
15:21:11 <shachaf> ceezer: Why use sum in one part and a closed-form formula in the other?
15:21:37 <TTimo> ^
15:21:42 <mauke> is there a closed formula for sum of squares?
15:22:14 <ceezer> shachaf: in the other one we're summing square values ... i thought the closed form only worked for consecutive values?
15:22:35 <ceezer> successive squares summation
15:22:43 <ceezer> maybe.
15:22:55 <c_wraith> there's another closed form for that: n * (n + 1) * (n + 2) / 6
15:23:10 <ceezer> wow, never knew that.
15:23:34 <c_wraith> successive cubes is n * (n + 1) * (n + 2) * (n + 3) / 24
15:23:39 <c_wraith> I think you can find the pattern :)
15:24:35 <ceezer> fantastic.
15:26:19 <shachaf> Somewhat more generally, this is neat: http://www.stanford.edu/~dgleich/publications/finite-calculus.pdf
15:27:10 <ceezer> in haskell, is using `div` equivalent to \  for division?
15:27:42 <mauke> no, \ is lambda
15:27:47 <c_wraith> ...  \ in basic?
15:27:58 <c_wraith> \ *is* integer division in basic.
15:27:59 <ceezer> not \ ... doh! /
15:28:53 <ceezer> not \ ... doh! /
15:28:54 <c_wraith> No, div and (/) are not the same
15:28:54 <aristid> :t div
15:28:54 <aristid> :t (/)
15:28:55 <aristid> NOOOOOOOOOOOOOOOOOOOOOOOOO
15:28:55 <c_wraith> lambdabot got lost in the split!
15:29:09 <ceezer> Ahh.
15:29:10 <ceezer> okay.
15:29:29 <Eduard_Munteanu> shachaf: thanks, looks interesting
15:29:40 <c_wraith> They are defined in different type classes.  I don't think there are numbers that are instances of both typeclasses at once
15:37:38 <ceezer> Why are so many people joining/leaving at once?
15:37:58 <aristid> ceezer: netsplit, i guess
15:38:10 <aristid> :t div
15:38:11 <lambdabot> forall a. (Integral a) => a -> a -> a
15:38:12 <aristid> :t (/)
15:38:13 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:38:26 <aristid> @instances Integral
15:38:27 <lambdabot> Int, Integer
15:38:32 <aristid> @instances Integral, Fractional
15:38:32 <lambdabot> Couldn't find class `Integral, Fractional'. Try @instances-importing
15:38:49 <aristid> @instances Fractional
15:38:49 <lambdabot> Double, Float
15:39:01 <ceezer> ohh
15:39:31 <Eduard_Munteanu> Hah, this is really interesting... \delta(2^x) = 2^x
15:40:39 <bsmntbombdood> why are there no real graph-reduction machines?
15:40:46 <bsmntbombdood> that would be fun
15:41:12 <bsmntbombdood> seems like there's lots of opportunity for hardware-level parallelism
15:44:52 <roconnor> there were
15:50:22 <j-invariant> are there any times when you can't use haskell types to save the program?
15:50:56 <j-invariant> Eduard_Munteanu: 2^(x-1) no?
15:51:20 <roconnor> j-invariant: you are asking if there are type safe untyped terms that cannot be typed in Haskell?
15:51:52 <j-invariant> sort of, I didn't mean it like a technical question like that but pragmatic
15:52:09 <roconnor> oh pragmatically.
15:52:36 <roconnor> In that case I'd say no, but I don't know how I would convince you.
15:52:41 <djahandarie> GADTs and type families or fundeps get you a long way
15:52:59 <j-invariant> I have an example
15:53:06 <Eduard_Munteanu> j-invariant: < shachaf> Somewhat more generally, this is neat: http://www.stanford.edu/~dgleich/publications/finite-calculus.pdf
15:53:10 <j-invariant> maybe you can tell me how to fix it
15:53:56 <j-invariant> I have a polynomial data type and want to maek a new oen for R[x]/(p). So I define data Quotient = Q Poly Poly -- the first poly is the element of R[x] and the second is p
15:54:09 <j-invariant> so e.g.  you can do Q a p + Q b p = Q (a+b) p
15:54:15 <djahandarie> This is not what comes to mind when someone says pragmatic
15:54:23 <j-invariant> but Q a b + Q c d typechecks (which shouldn't)
15:55:06 <Eduard_Munteanu> Heh.
15:55:40 <Eduard_Munteanu> j-invariant: why shouldn't it, apart from the loose connection to math?
15:55:57 <Eduard_Munteanu> *why should it
15:57:17 <Eduard_Munteanu> That gives very little info to the type system.
16:00:24 <j-invariant> I could do it like runST
16:00:54 <Bynbo7> :\
16:01:06 <Bynbo7> i don't see how your problem at all relates to ST
16:01:20 <djahandarie> He means rank-2 types
16:01:33 <Bynbo7> all you need to do is to specify the composition of p in Q's type
16:01:36 <Bynbo7> right?
16:02:15 <rjo> if I've: (find (0==) $ map (x`mod`) $ primes (n-1))
16:02:29 <rjo> is latter map completely evaluated?
16:02:38 <c_wraith> not necessarily.
16:02:45 <rjo> ok thx
16:02:45 <Eduard_Munteanu> :t find
16:02:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:02:52 <c_wraith> find only consumes as much of the list as necessary to return a result, if one is found
16:03:00 <j-invariant> rjo: it will only do as many as it needs to find the first 0
16:03:05 <Bynbo7> rjo: it is when you cann 0== on the results :P
16:03:15 <c_wraith> I guess if "primes" is well-named, none of the results are equal to zero :)
16:03:17 <Bynbo7> call*
16:03:37 <c_wraith> oh, that's not true with the mod in there.  nevermind. :)
16:04:05 <rjo> I started with 0.295 and I managed to simplify it 0.121s
16:04:18 <rjo> trivial Turner's Sieve is 0.059s
16:06:36 <rjo> maybe I can write find map with single func
16:07:01 <j-invariant> So haskell can't do this
16:07:01 <j-invariant> ?
16:07:19 <Bynbo7> haskell can do this, you need to tell it how to do so
16:08:14 * hackagebot epub-metadata 2.0.0 - Library and utility for parsing and manipulating ePub OPF package data  http://hackage.haskell.org/package/epub-metadata-2.0.0 (DinoMorelli)
16:08:35 <c_wraith> for one, mod is significantly slower than rem.
16:08:49 <c_wraith> mod is specified to be more useful, but rem is what hardware provides.
16:09:00 <c_wraith> (in general)
16:09:14 <c_wraith> > 7 `rem` 4
16:09:15 <lambdabot>   3
16:09:19 <roconnor> anyone know how I could (psuedo-)randomly generate a Wiener process of type CReal -> CReal?
16:09:21 <c_wraith> > (-7) `rem` 4
16:09:23 <lambdabot>   -3
16:09:27 <c_wraith> > (-7) `mod` 4
16:09:28 <lambdabot>   1
16:10:15 <rjo> wow, 0.082 now!
16:10:41 <c_wraith> What change was that, rjo?
16:10:55 <rjo> find (\y -> (0 == (x`rem`y))) $ primes (n-1)
16:11:06 <rjo> I removed map and used rem
16:11:20 <roconnor> [18:53] <j-invariant> but Q a b + Q c d typechecks (which shouldn't)
16:11:29 <roconnor> this is a different question than I thought you were asking
16:11:33 <aristid> rjo: `rem` binds tighter than ==
16:11:41 <aristid> infix 4 ==
16:11:46 <aristid> infixl 7 rem
16:11:47 <roconnor> I thought you wanted to know if there were correct programs that you can't typecheck
16:12:00 <roconnor> instead you have an incorrect program that you want to not type check
16:12:08 <j-invariant> yeah
16:12:14 <mtnviewmark> mod should be no more than 2x rem.... is it?
16:12:15 <roconnor> there are lots of those in Haskell
16:12:45 <roconnor> j-invariant: Agda/Coq/Epigram/Matita will solve almost every such problem for you.
16:12:57 <j-invariant> I think those guys generate more problems :D
16:13:04 <roconnor> because you can encode arbitrary mathematical properites in the types
16:13:39 <dobblego> what more problems are generated?
16:14:26 <roconnor> A third characterization is that the Wiener process has a spectral representation as a sine series whose coefficients are independent N(0,1) random variables.
16:14:33 <roconnor> this sounds promising
16:14:51 <roconnor> what's a spectral representation?
16:15:23 <c_wraith> I think it's a representation of what frequencies are present at what intensities
16:15:37 <c_wraith> that is, the coefficients of various terms in the fourier transform
16:16:41 <c_wraith> spectral representations are often a form of visualizing audio data in audio editing software
16:17:08 <roconnor> :/ I don't think it is a fourier series, otherwise I think they would have said so
16:17:13 <roconnor> but I don't really know
16:17:33 * roconnor investigates the Karhunen-Loève theorem
16:21:19 <rjo> still got 0.2s off, now I approached the Erastothenes Sieve
16:21:35 <copumpkin> @pl \x y -> x `shiftL` fromIntegral y
16:21:35 <lambdabot> (. fromIntegral) . shiftL
16:22:23 <aristid> :t \a b -> (.a).b
16:22:24 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f a -> f1 (a -> b) -> f1 (f b)
16:22:34 <j-invariant> dobblego: having to prove a lot of equations in a long difficult way even though they are all trivial
16:22:35 <aristid> :t \a b -> (Prelude..a)Prelude..b
16:22:36 <lambdabot> forall b c a a1. (a -> b) -> (a1 -> b -> c) -> a1 -> a -> c
16:24:38 <parcs> @pl \a b -> (.a).b
16:24:39 <lambdabot> (.) . flip (.)
16:25:16 <dobblego> @type fmap fmap fmap
16:25:17 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:25:41 <rjo> if I convert anonymous function to real one, is there some performance thingies?
16:25:49 <aristid> if (.) is result, what is the name of flip (.)?
16:25:58 <aristid> :t flip (Prelude..)
16:25:59 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
16:26:08 <flippo> rjo, English is also a useful language.
16:26:14 <aristid> @hoogle (a -> b) -> (b -> c) -> a -> c
16:26:15 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
16:26:15 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
16:26:15 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
16:26:22 <parcs> rjo: all "real" functions are syntactic sugar for anonymous ones
16:26:34 <dobblego> aristid, there is (>>>) in Control.Category if you like
16:27:01 <aristid> dobblego: i mean just the SEC name :)
16:28:22 <latros> hi
16:28:29 <latros> anyone use yi at all?
16:28:35 <adnap> is there a corresponding darcs repo for most packages on hackage, or do i have to get the sources and start a new one?
16:30:28 <aristid> adnap: hackage packages are not required to use a specific version control system
16:30:29 <lispy> adnap: it really varies from package to package, but a fair number of them have links to their reps
16:31:02 <lispy> adnap: github and darcs being the two most common repo formats on hackage, AFAICT
16:31:34 <adnap> oh, you know what, i think the package i'm trying to get is hosted on github
16:31:46 <adnap> damn
16:32:45 <lispy> hacking on darcs and using github makes me feel a bit dirty, but github's hosting is just so nice.
16:33:02 <adnap> i've never used github
16:33:05 <lispy> Unlike some other servers I know that are always down :(
16:33:14 <adnap> i'd rather just use my own server
16:34:22 <lispy> There are two things that github does well: a) social aspects of coding/ui, b) being fast/reliable
16:34:29 <adnap> is it a waste of time to try and convert the git repo to darcs>
16:34:40 <adnap> should i just start a new repo?
16:34:42 <Enigmagic> adnap: just use git :P
16:34:44 <lispy> The fact that it uses git just seems to be incidental (and I wish they support things besides git)
16:34:51 <adnap> noooo
16:35:14 <lispy> adnap: have you looked at the darcs packages on hackage?
16:35:17 <aristid> adnap: crybaby :P
16:35:30 <lispy> adnap: http://hackage.haskell.org/package/darcs-fastconvert
16:35:42 <adnap> lispy: thanks, i was googling for something like that
16:37:36 <adnap> http://blog.moertel.com/articles/2007/12/10/how-i-stopped-missing-darcs-and-started-loving-git
16:39:30 <lispy> adnap: If you're coming from a darcs background, expect to need to read a book (or two) on git before it makes sense.  I found the visual git guide and pro-git to be especially helpful.
16:41:36 <ClaudiusMaximus> i implemented Data.List.transpose in my lambda calculus interpreter, but it has a horrible space leak: "drop infinity (transpose [repeat a, repeat b])" doesn't run in constant space - is there any easy fix?
16:42:11 <parcs> aristid: regarding your previous question, flip (.) is (>>>) i think
16:42:26 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#transpose  which i translated into  transpose = \l . l (\xs xss . xs (\y ys . cons (cons y (concatmap (take 1) xss)) (transpose (cons ys (map (drop 1) xss)))) (transpose xss)) nil
16:42:37 <aristid> parcs: i meant in the context of SECs
16:43:38 <aristid> @ask conal Is there a SEC-name for flip (.)?
16:43:38 <lambdabot> Consider it noted.
16:44:23 <conal> aristid: yes: "argument". watch out, though: unlike first, second, and result, argument is contravariant
16:44:23 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
16:45:41 <geheimdienst1> conal has the chuck-norrisesque ability to answer before lambdabot told him the question :-o
16:46:01 <conal> geheimdienst1: :)
16:46:03 <ClaudiusMaximus> my interpreter seems to build up a massive chain of "map (drop 1)" thunks...
16:46:04 <aristid> conal: what does "contravariant" mean? i found a category theory explanation on wikipedia
16:46:10 <conal> aristid: you'll see 'argument' in TypeCompose but commented out in DeepArrow. i had 'argument' for a while in Eros (tangible functional programming).
16:46:28 <conal> @type first
16:46:30 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:46:39 <roconnor> There is a sequence {Z_i} of independent Gaussian random variables with mean zero and variance 1 such that W(t) = sqrt(2)*sum[Z_k * sin((k - 0.5)*pi*t)/((k - 0.5)*pi)|k<-[0..]]
16:47:21 <roconnor> I wonder if the reverse is true. Every sequence of independen Gaussian random variables produces a wiener process using that formula?
16:47:26 <aristid> :t (.)
16:47:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:47:37 <aristid> :t (Prelude..)
16:47:38 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:47:43 <roconnor> (note that t is between 0 and 1)
16:48:15 <dobblego> aristid, see f in that signature and replace it with (a ->)
16:48:17 <aristid> result :: ((b -> c) ~> (a -> b) -> (a ~> c)
16:48:32 <aristid> :t flip (Prelude..)
16:48:32 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
16:48:46 <aristid> dobblego: translating it to Arrow-style is already hard enough for me :)
16:49:05 <conal> aristid: first :: (a -> a') -> ((a,b) -> (a',b)), second :: (b -> b') -> ((a,b) -> (a,b')), and result :: (b -> b') -> ((a->b) -> (a->b')). but argument :: (a' -> a) -> ((a->b) -> (a',b)).
16:49:46 <c_wraith> yes.  the arrow goes the other way. :)
16:49:55 <c_wraith> If you know which arrow "the" refers to! :)
16:50:03 <aristid> :/
16:50:12 <aristid> confusing, it is :P
16:50:26 <conal> aristid: and generalizing to Arrow and DeepArrow, first :: (a ~> a') -> ((a,b) ~> (a',b)), second :: (b ~> b') -> ((a,b) ~> (a,b')), and result :: (b ~> b') -> ((a->b) ~> (a->b')). but argument :: (a' ~> a) -> ((a->b) ~> (a',b)).
16:50:51 <mikeg> Do any of the regex libraries support a "join"-like operation to speed up checking many regexes against a single string. `any (=~ "sample string")` is somewhat slow
16:50:56 <conal> aristid: the contravariant part is that the a' & a switch sides of the arrow.
16:50:56 <aristid> conal: the , in argument should be ->?
16:51:07 <conal> aristid: yes, thanks.
16:51:18 <aristid> conal: well, isn't the POINT of argument being that a' and a switch sides?
16:52:47 <mikeg> the package "regexpr-symbolic" looks interesting for this
16:53:12 <roconnor> hmm, a Wiener process appear to not always be continuous :(
16:53:25 <c_wraith> mikeg: couldn't you just do that with a combination of quoting and alternation?
16:53:35 <roconnor> it is only continous with probability 1
16:53:58 <roconnor> which means that it is probably hard to estimate it's modulus of continuity
16:54:03 <roconnor> *its
16:54:30 <c_wraith> mikeg: actually, you don't even need quoting.  You just need grouping and alternation:  (a)|(b)|(c)
16:55:09 <conal> aristid: puzzling over your "well, ..." question. are you asking out of confusion about my contravariance warning?
16:55:18 <aristid> conal: maybe :)
16:55:21 <mikeg> Well, I also need to figure out which one matches. But I'm doing this inside a tight loop, so I'm considering the situation where finding if ANY matches is much quicker than finding which one specificaly
16:55:56 <c_wraith> ah, that does make it a bit trickier...  Probably depends on the number of possible matches vs the number of inputs being checked.
16:56:57 <c_wraith> though something that gives perl-style group capturing actually works just fine there...  You just find out what group is non-empty
16:57:05 <aristid> conal: what's the danger from the contravariance?
16:58:06 <mikeg> Mhmm that's a very good idea. I would have to use non-capturing parens inside each group
16:58:31 <c_wraith> Or else manually count them.  But yeah, it's tractable
16:58:41 <conal> aristid: i've forgotten what bumps i ran into. if you use argument in SEC composition chains, you might encounter them yourself. or maybe specific to TFP.
16:58:48 <conal> (tangible functional programming)
16:59:12 <aristid> conal: i mostly only use SECs to make nice-looking function composition chains :)
16:59:56 <conal> aristid: cool. i mostly do as well. there's wonderful magic ahead though. have you read the TFP paper?
16:59:59 <conal> @where Eros
16:59:59 <lambdabot> http://conal.net/papers/Eros
17:00:27 <aristid> conal: i have, can't say i really understood it.
17:01:08 <yip> > foldl (+) 0 [1,2,3]
17:01:09 <lambdabot>   6
17:01:10 <conal> SECs can also build editors (transformers) of not only denotations but also GUIs, types, code, and pairings of the same. powerful stuff!
17:01:24 <yip> what is the (+) operation called in the context of this fold? what is it's name?
17:02:09 <aristid> conal: right, i understand that much, but not really the way it fits together. and this is probably outside the scope of an IRC conversation, i fear
17:02:24 <TTimo> yip: not sure I understand you right, but I believe that's called a section
17:02:26 <copumpkin> yip: the binary operation?
17:03:04 <conal> aristid: probably so. though i'd like to be able to explain it simply & succinctly enough for an IRC chat.
17:03:44 <yip> hm... don't think section is what i'm looking for
17:04:15 <conal> the key idea of TFP is to turn gestures into SEC chains and then apply those chains to synthesize "tangible values", which are functional programs (denotations really) and user interfaces for them.
17:04:19 <yip> the parameter of the binary function is often called "f". but what is a better name for it? what is it called, an operation that combines two elements?
17:04:38 <dobblego> yip, a binary function
17:04:40 <mauke> it's a function
17:04:46 <TTimo> operator maybe
17:05:01 <conal> yip: no standard name that i know of. sometimes i like "combiner"
17:05:07 <TTimo> or an infix
17:05:12 <conal> or Binop
17:05:57 <conal> i hear "infix" as a syntactic notion and "function" as a semantic notion.
17:06:25 <conal> though i notice that a lot of programmers say "function" where i'd say "definition". don't know where that use of "function" originates.
17:06:30 <TTimo> conal: yes, infix operators are just a kind of function
17:06:47 <ClaudiusMaximus> aha - fixed the space leak with more strictness...     sdrop = \n l . n (\p . l (\x xs . seq x (sdrop p xs)) nil) l  ;  sdrop infinity (transpose [repeat a, repeat b])    now happily running in constant space
17:07:15 <conal> TTimo: except that the infixness is about the *name*, not the function
17:07:19 <yip> ok, so there is no standard name for a function that is used to fold through a list, each time combining two elements? binop sounds good i guess
17:07:33 <j-invariant> yip: call it cons
17:08:09 <yip> hm...
17:08:10 <djahandarie> Not like that'd be extremely generic
17:08:45 <TTimo> yip: http://ww2.cs.mu.oz.au/172/Haskell/tourofprelude.html#foldl
17:08:55 <TTimo> called a binary operator there fwiw
17:09:37 <mikeg> c_wraith: another idea is, since I'm actually checking many regexes vs. many strings, I could combine the strings in some deliminited fashion, using your grouping solution too..
17:09:48 <conal> many of my modules use these defs: type Unop a = a -> a; type Binop a = a -> Unop a
17:10:03 <conal> Sometimes eliminates a *lot* of boilerplate.
17:10:10 <yip> TTimo: thanks! looks like conal was right on the money :)
17:10:29 <djahandarie> yip, note that not all functions passed to a fold would neccessarily be best though of as a "combiner". Think of map... map f xs = foldr (f . (:)) [] xs.
17:10:44 <djahandarie> thought*
17:11:16 <djahandarie> It's technically combining stuff into a single list value but you normally want to get rid of that notation when you start using map
17:11:35 <djahandarie> notion*
17:11:41 <djahandarie> Man, not a good day for me, lol
17:11:45 <conal> djahandarie: good point. folds are more general than Binop (in the sense i defined it). though monoids and associative folds are about Binops
17:12:26 <conal> i have monoids & associative folds on my mind, since i'm noodling about automatically deriving fast parallel programs from functional specifications.
17:12:59 <djahandarie> Cool
17:15:11 <conal> i worked a bunch with GLSL for functional graphics. now learning CUDA, which is much more flexible. and more challenging for me to bridge the gap from functional.
17:16:47 <djahandarie> I've found that whenever I want to use CUDA, it rarely ever helps at all because the tasks I want to parallelize often are not identical, which is required for better speed than what a CPU can give you usually. 
17:18:19 <conal> djahandarie: do you mean you haven't known how to avoid thread divergence within thread blocks?
17:19:35 <conal> djahandarie: do you have a few different tasks with tons of data?
17:21:13 <djahandarie> I'm particularly thinking of a motion vector search algorithm
17:22:25 <djahandarie> It's required me to rework my problem entirely, but I'm still not sure if it'd do any better (haven't had time to try it)
17:23:22 <djahandarie> Where I'm at now is a blind search on all blocks, then over and over until some stabilization threshold is hit
17:23:58 * djahandarie thinks this is probably off-topic
17:24:43 <TTimo> conal: anything you're making available in the field of graphics + functional programming ?
17:25:34 <conal> TTimo: it's coming together, and i'll probably announce something. still fussing with common sub-expression in the functional -> glsl compiler.
17:25:55 <conal> CSE is the hard part of every embedded compiler i've written.
17:27:03 <TTimo> k
17:27:06 <conal> i currently have two CSE solutions. one is fast and the other is thorough. i want fast & thorough.
17:28:08 <conal> i've lost some motivation, given the terrible state of libs for GUIs & interactive 3D for haskell+mac
17:28:38 <conal> i haven't found any lib that works on mac and doesn't kill ghci.
17:28:49 <TTimo> mh .. ever heard of NUI?
17:28:59 <TTimo> friend of mine is a pretty active developer
17:31:10 * TTimo afk dinner
17:54:20 <alpounet> which curl do i need to install to get the binding to build ?
17:54:34 <ClaudiusMaximus> http://hpaste.org/42723/transpose_vs_laziness -- so, ghci suffers the same space leak as my interpreter, and the same fix (more strictness) works: does this mean Data.List.transpose is flawed, or is this likely not to be an issue in real code?
17:54:37 <alpounet> (i mean which c library)
17:54:50 <alpounet> it fails with libcurl-gnutls
17:55:45 <ClaudiusMaximus> probably you need the -dev package?
17:55:53 <roconnor> the kinda strange bit is that I can compute the values of a wiener process at all the dyadic rationals (or something like that) but without a modulus of continuity I cannot compute intermediate values.
17:55:56 <monochrom> will take a while for me to boot up linux and tell you what I did
17:56:12 * roconnor ponders if that is true
17:56:22 <ClaudiusMaximus> i've not tried though, alpounet 
17:57:10 <alpounet> ClaudiusMaximus, i managed to build the binding now
17:57:19 <alpounet> but hoauth isn't happy with the package-id of the curl binding i have
17:57:22 <alpounet> damn it
17:58:38 <roconnor> ah, right it isn't true. I can't even compute values on the dyadic rationals
17:59:17 <roconnor> somewhere deep in they sine series expession some coefficent might randomly just happen to be very huge.
17:59:23 <yip> what are the operands of a sum called?
17:59:58 <latros> summands
18:00:30 <monochrom> ubuntu name is libcurl4-gnutls-dev or libcurl-openssl-dev (different packages, choose your politics)
18:01:07 <yip> latros: thanks :)
18:01:09 <parcs> yip: addends?
18:01:31 <latros> I think addends is also correct
18:01:44 <yip> hm... which is better?
18:01:48 <parcs> summands
18:02:04 <yip> what about the operands of a product?
18:02:10 <parcs> multiplicands
18:02:24 <mauke> factors
18:02:25 <roconnor> maybe there is some other way to compute a wiener process
18:02:33 <copumpkin> haha you said wiener
18:02:41 <Twey> I think it's an ‘addendum’ if you're going to go that route…
18:02:51 <ClaudiusMaximus> call them somethings
18:02:57 <parcs> call them terms
18:03:06 --- mode: ChanServ set +o mauke
18:03:06 <roconnor> if I figure it out I can implement the wiener process in Coq
18:03:07 --- mode: mauke set -q *!*@118.82.186.189
18:03:32 <copumpkin> haha you said wiener and coq in one sentence
18:03:46 <Veinor> haha
18:04:03 <Eduard_Munteanu> Is there anything in particular to watch out for in case I get a stack overflow with my STRef based tree?
18:04:20 <monochrom> don't let big thunks build up
18:04:33 <copumpkin> Eduard_Munteanu: don't blow the stack
18:04:39 <roconnor> Eduard_Munteanu: you only have two days left!!!
18:04:44 <Twey> Eduard_Munteanu: Fix it
18:04:48 <Eduard_Munteanu> :)
18:04:59 <copumpkin> Eduard_Munteanu: what are you going to do with this infamous STRef-based tree?
18:05:07 --- mode: mauke set -o mauke
18:05:07 <Twey> Come on, now someone has to chime in with ‘do something’
18:05:17 <Twey> I'm not sure we can get much vaguer than that, though
18:05:17 <monochrom> do something!
18:05:18 <Eduard_Munteanu> copumpkin: it's already part-done... adaptive Huffman compression.
18:05:30 <copumpkin> damn, that's so concrete
18:05:38 <monochrom> actually, don't do anything!
18:05:39 <Eduard_Munteanu> Well, part-done, but not working :)
18:05:42 <Twey> Heh
18:05:57 <Twey> Two days until what?
18:06:05 <Eduard_Munteanu> Until I have to turn it in.
18:06:08 <Twey> Is this some sort of competition?
18:06:15 <Twey> Ah, right.  Academic deadline.  So yes.  ;)
18:06:16 <Eduard_Munteanu> Twey: no, school.
18:06:20 <monochrom> perhaps. wanna bet?
18:06:27 <Twey> Heh.
18:06:41 <Eduard_Munteanu> Uh, everybody else does it in Matlab, with one or two exceptions C.
18:06:45 <roconnor> Eduard_Munteanu: so you've gone with STRef.  Interesting choice.
18:08:16 <Eduard_Munteanu> roconnor: well, IDK, but I wanted some assurance. Plus I can rewrite it in C any time :)
18:08:30 <Eduard_Munteanu> (assurance wrt performance)
18:08:55 <roconnor> Eduard_Munteanu: It's a fine choice.  After all, Haskell is the best impertive language out there.
18:09:18 <roconnor> At least that is what the Akward Squad says
18:09:23 <roconnor> I tend to agree
18:09:38 <roconnor> other imperative langauges don't have first class commands
18:10:17 <copumpkin> but we do have to jump through hoops to get early return
18:10:20 <copumpkin> or goto
18:10:26 <copumpkin> and everyone knows goto is a good thing
18:10:52 <roconnor> oh boy, I totaly misunderstood the definition of what a Matringale is.
18:11:43 <roconnor> copumpkin: I'm pretty sure that augustus implemented GOTO in the BASIC monad.
18:12:03 <copumpkin> yeah
18:12:10 <copumpkin> but you have to jump through hoops
18:12:28 <copumpkin> it's not quite as simple as "IO is your average imperative language"
18:12:59 <mreh> is there a Parsec mode that ignores all whitespace?
18:13:18 <copumpkin> tokenize?
18:13:20 <mauke> parse . filter (not . isSpace)
18:13:55 * hackagebot logict 0.4.2 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.4.2 (DanDoel)
18:13:58 <mreh> it is effective
18:14:10 <mreh> good call
18:15:57 <copumpkin> wait, you're actually going to filter out all whitespace?
18:16:13 <copumpkin> the usual situation is where you don't want to deal with it, but it's still meaningful in your language
18:18:29 <mreh> copumpkin: yes, that had crossed my mind, what if a small portion of my parser didn't require whitespace to be meaningful
18:19:04 <mreh> but in this instance it doesn't matter, I'm interested in the more general case though
18:24:59 <monochrom> haskell has goto. it's called function application.
18:26:30 * JuanDaugherty takes note.
18:26:33 <roconnor> monochrom: isn't that gosub?
18:26:33 <ion> Function applications tend to return.
18:26:47 <Axman6> since when?
18:26:49 <mauke> but they don't have to
18:26:54 <mauke> just keep calling more stuff
18:27:59 <c_wraith> This is making me realize we need a linenumbers monad
18:28:30 <mauke> I thought we did
18:28:34 <mauke> BASIC
18:28:39 * JuanDaugherty .oO( monochrom is someone who thinks goto and function application are equivalents )
18:28:54 <ion> Perhaps a labels monad.
18:29:19 <ion> do foo <- here; goto foo
18:29:53 <roconnor> ion: you need mdo so you can goto the future
18:30:04 <mauke> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
18:30:27 <copumpkin> augustss should start blogging again!
18:30:29 * geheimdienst1 thought it's mostly about global state. say "goto foo" in 10 places, and at the "foo" label you need to correctly handle the 10 states the program can be in. it gets combinatorially worse if a little earlier you have a "bar" label jumped-to 10 times which falls through to the foo label
18:30:50 <aristid> preflex: seen augustss
18:30:50 <zachk> how do i find the source code to modules i cabal installed? 
18:30:51 <preflex>  augustss was last seen on #haskell 1 day, 5 hours, 42 minutes and 35 seconds ago, saying: True
18:31:22 <geheimdienst1> maybe goto wouldn't be that bad in a language where global state is tightly controlled? (hint hint)
18:31:50 <Veinor> @src reverse
18:31:51 <lambdabot> reverse = foldl (flip (:)) []
18:32:21 <roconnor> Veinor: I thought I was so awesome when I derived a definition of reverse using foldl.
18:32:27 <roconnor> then @src crushed me
18:32:40 <copumpkin> aww
18:32:50 <dobblego> roconnor, I gave that in a job interview once, "reverse a list in any language"
18:32:58 <dobblego> I didn't get that job
18:33:19 <roconnor> you gave that definition of reverse?
18:33:27 <dobblego> yes
18:33:29 <roconnor> aww
18:33:29 <copumpkin> I did too
18:33:30 <j-invariant> haha
18:33:38 <roconnor> I'd hire you if I had a job for you
18:33:56 <dobblego> I was asked to explain it but I think I bamboozled him
18:34:05 <dobblego> it was for C# programming
18:34:17 <j-invariant> I would have done the code in C# :/
18:34:35 <dobblego> it's not so easy for IEnumerator :)
18:38:51 <Axman6> dobblego: you didn't say "tsil a", and say you used english?
18:39:34 <Veinor> "atsil anu"
18:39:43 <Veinor> sounds like a magic spell
18:39:46 <aristid> which is better, reverse = foldl (flip (:)) [] or reverse = foldl' (flip (:)) []?
18:39:52 <parcs> > let reverse (x:xs) = reverse xs ++ [x]; reverse x = x in reverse [1..10]
18:39:54 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:40:13 <Axman6> aristid: they should be basically the same
18:40:31 <aristid> Axman6: the strictness should bring no improvement?
18:40:43 <Axman6> i don't think so
18:40:56 <aristid> why not? :)
18:40:56 <parcs> is there a linear version of reverse that doesn use a folding function?
18:41:18 <aristid> parcs: yours does seem to be linear, no?
18:41:29 <djahandarie> parcs, a fold just abstracts the recursion out of the function
18:41:37 <djahandarie> Just plugin stuff in and you'll get one 'without the fold'
18:41:42 <djahandarie> plug*
18:42:07 <Eduard_Munteanu> Ok, narrowed it down.
18:42:28 <Eduard_Munteanu> I know I should've used STRefs on all records.
18:42:29 <Axman6> aristid: the seq in foldl' just evaluates to head normal form, so you know that each list is made up of something : something else, rather than just knowing each list is a list
18:42:30 <parcs> aristid: hmm, you’re right. at first i thought it was O(n1)
18:42:33 <parcs> n!*
18:42:45 <Axman6> aristid: as with all things performance related though, it is worth testing to find out
18:43:01 <Eduard_Munteanu> Right now I have to worry whether the 'value' or 'ctx' is updated or not :/
18:43:32 <aristid> Axman6: except you actually have to compile to get good numbers, so my usual ghci method is too sloppy for that :)
18:43:43 <aristid> i _love_ ghci
18:44:47 <zachk>  > let reverse list = helper list [] ; where helper (x:xs) ax = helper xs (x:ax) ; helper [] ax = ax in reverse [1..10] 
18:45:08 <zachk> :(
18:45:23 <parcs> leading space
18:45:41 <zachk> > let reverse list = helper list [] ; where helper (x:xs) ax = helper xs (x:ax) ; helper [] ax = ax in reverse [1..10] 
18:45:43 <lambdabot>   <no location info>: parse error on input `where'
18:45:48 * zachk sighs 
18:45:59 <djahandarie> It needs to be an expression
18:46:07 <zachk> what does 
18:46:15 <djahandarie> Whatever you enter
18:46:29 <mauke> it is
18:46:38 <zachk> it doesnt like my where 
18:46:48 <Axman6> delete the where, it's not needed
18:46:52 <djahandarie> > let reverse list = helper list []; helper (x:xs) ax = helper xs (x:ax); helper [] ax = ax in reverse [1..10]
18:46:53 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:46:55 <mauke> > let reverse list = helper list [] where helper (x:xs) ax = helper xs (x:ax) ; helper [] ax = ax in reverse [1..10]
18:46:56 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:47:02 <copumpkin> why are all the usual trig functions in Floating, but atan2 is in RealFloat?
18:47:06 <djahandarie> Or that :)
18:48:04 <zachk> > let reverse list = helper list []  where helper (x:xs) ax = helper xs (x:ax) ; helper [] ax = ax in reverse [1..10] 
18:48:05 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:48:08 <Twey> What is atan2?
18:48:09 <zachk> oh ok 
18:48:14 <zachk> atan^2? 
18:48:36 <djahandarie> It's a variation of arctan
18:48:53 <copumpkin> not ^2
18:49:01 <copumpkin> it's a user-friendly arctan
18:49:09 <Twey> > map ((atan &&& atan2) . (* pi))
18:49:10 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [(a, a -> a)])
18:49:10 <lambdabot>    arising f...
18:49:11 <Twey> Er
18:49:18 <mafs> @type atan
18:49:18 <Twey> > map ((atan &&& atan2) . (* pi)) [-4 .. 4]
18:49:19 <lambdabot> forall a. (Floating a) => a -> a
18:49:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:49:20 <lambdabot>    arising from a use of `...
18:49:20 <mafs> @type atan2
18:49:21 <lambdabot> forall a. (RealFloat a) => a -> a -> a
18:49:25 <Veinor> "For real floating x and y, atan2 y x computes the angle (from the positive x-axis) of the vector from the origin to the point (x,y)."
18:49:43 <Twey> Oh, huh.
18:49:44 <Axman6> :t atan
18:49:45 <lambdabot> forall a. (Floating a) => a -> a
18:49:47 <Axman6> :t atan2
18:49:47 <copumpkin> :t atan2
18:49:48 <copumpkin> :t atan
18:49:48 <lambdabot> forall a. (RealFloat a) => a -> a -> a
18:49:48 <lambdabot> forall a. (RealFloat a) => a -> a -> a
18:49:49 <lambdabot> forall a. (Floating a) => a -> a
18:49:50 <mafs> Axman6: thanks
18:49:57 <djahandarie> -_-
18:49:59 <copumpkin> :P
18:50:06 <mafs> haskellwiki lied!
18:50:12 <mauke> I'm going to kick all of you
18:50:31 * Twey looks scared
18:50:48 * mafs *is* scared
18:51:20 <mauke> mafs: not you, you did it first
18:51:21 <Twey> Why don't they give it a more descriptive name, like angleFromX?
18:51:51 <Twey> I didn't do it at all
18:51:57 <Twey> :<
18:52:20 <djahandarie> or argumentFunctionPrincipalValue
18:52:36 <Twey> That's maybe a bit verbose :þ
18:52:57 <djahandarie> FloatPointPartialArcTangent???
18:53:06 <Twey> Heh
18:53:32 <listofoptions> craaaap
18:53:45 <listofoptions> stupid parse error
18:53:54 <listofoptions> http://hpaste.org/42724/some_lambda_nonsense
18:54:41 <listofoptions> borrowed from a paper on de bruijn notation in haskell
18:55:14 <djahandarie> What's the error?
18:55:34 <Axman6> why do you have Incr i when i isn't mentioned as a type argument to Term?
18:55:50 <listofoptions> parse error (possible incorret indentation) on kfoldT
18:56:20 <listofoptions> it's for de bruijn notation
18:56:22 <copumpkin> class Real a where toRational :: a -> Rational has got to be one of the best jokes in haskell-land
18:56:49 <djahandarie> listofoptions, I think the problem is that you're using tabs
18:56:54 <listofoptions> oh
18:56:59 <listofoptions> wtf
18:57:07 <Axman6> don't use tabs
18:57:08 <alpounet> copumpkin, haha 
18:57:11 <Axman6> ever
18:57:11 <alpounet> yeah...
18:57:52 <shachaf> copumpkin: Maybe they know something we don't.
19:00:23 <listofoptions> nope
19:00:29 <listofoptions> still nothing
19:00:41 <listofoptions> same error
19:02:14 <listofoptions> http://hpaste.org/paste/42724/some_lambda_nonsense_annotati#p42726
19:02:53 <Axman6> it would help a lot if you pasted the error message...
19:04:24 <djahandarie> listofoptions, you forgot a )
19:04:31 <djahandarie> On the line before the error
19:04:55 * listofoptions uber face-palms
19:05:06 <listofoptions> *NIET!*
19:13:58 <listofoptions> ....and a few syntax errors later...
19:14:48 <roconnor> oh good. Given values of a Wiener process at 0 and 1, one can interpolate the intermediate values using a Brownian bridge.
19:14:51 <roconnor> yay
19:15:00 <listofoptions> http://hpaste.org/paste/42724/some_lambda_nonsense_annotati#p42728
19:18:28 <Axman6> RTEDUNDANT BRACKETS!
19:18:31 <Axman6> -T
19:20:51 <listofoptions> fixed
19:21:02 <listofoptions> thx Axman6 
19:24:28 <Jonno_FTW> @src succ
19:24:29 <lambdabot> Source not found. Take a stress pill and think things over.
19:24:52 <Jonno_FTW> is it possible to redefine succ for a specific datatype?
19:25:00 <copumpkin> @src Enum
19:25:00 <lambdabot> class  Enum a   where
19:25:01 <lambdabot>     succ                     :: a -> a
19:25:01 <lambdabot>     pred                     :: a -> a
19:25:01 <lambdabot>     toEnum                   :: Int -> a
19:25:01 <lambdabot>     fromEnum                 :: a -> Int
19:25:02 <lambdabot> [3 @more lines]
19:25:11 <copumpkin> it would appear to be so :)
19:26:08 <Jonno_FTW> @more
19:26:08 <lambdabot>     enumFrom                 :: a -> [a]
19:26:08 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
19:26:08 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
19:26:18 <Jonno_FTW> what do I have to do?
19:26:26 <copumpkin> instance Enum MyType where succ = blah
19:26:37 <Jonno_FTW> ahk
19:27:25 <djahandarie> It's nice having the Enum instance defined for stuff
19:29:13 <ClaudiusMaximus> have some lambdas (they're pink!) : http://claudiusmaximus.goto10.org/v/gulcii/gulcii-session-3-an-infinite-deal-of-nothing.ogv (haskell + gtk + cairo for gfx, networked to pure-data for sfx)
19:30:02 <Jonno_FTW> but I only want it to work for a specific value
19:30:15 <Jonno_FTW> instance Enum Value where succ Ace = Two
19:30:26 <Jonno_FTW> and then just have it work normally for any other value
19:38:43 <Axman6> Jonno_FTW: you either define the whole function or have it all de3rived, you can't do both
19:39:29 <j-invariant> In haskell are there good examples of Yoneda lemma?
19:39:48 <copumpkin> http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization/
19:39:49 <djahandarie> You can make a newtype wrapper around it, then just call the succ on the wrapped type in the cases you don't want the special behavior
19:41:14 <Jonno_FTW> :(
19:48:21 * hackagebot mysnapsession 0.3.1 - Sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.3.1 (ChrisSmith)
19:48:23 * hackagebot mysnapsession-example 0.3.1 - Example projects using mysnapsession  http://hackage.haskell.org/package/mysnapsession-example-0.3.1 (ChrisSmith)
19:50:47 <ickabob> good evening everyone; an issue with types here... could somone explain why this function's inferred type is restricted to an integer? http://codepad.org/F0DcNiRi
19:51:37 <mauke> ickabob: it's not Integer, it's (a -> Integer)
19:51:48 <mauke> ickabob: because you're trying to call . on a number ... or something
19:52:07 <horsewhisper> hi
19:53:06 <Axman6> ickabob: it should work if you make the . a $
19:53:14 <Axman6> but, that code is really ugly :\
19:53:32 <Axman6> what's wrong with add_and_double x y = 2 * (x + y)?
19:53:45 <ickabob> Axman6: nothing at all
19:54:37 <ickabob> I wanted to demonstrate to myself that I knew lambdas application and composition. which clearly was a tossed effort :*(
19:54:48 <ickabob> hah anyways mauke thank for your help
19:55:07 <mauke> you can only compose two functions, not a function and a number
19:55:10 <Axman6> actually, just remove the . completely
19:56:53 <Axman6> . is used to combine two functions, but you have a function and a value (which it is inferring is a function because of the type of .)
20:05:22 <applicative> > (even . 4) 1
20:05:24 <lambdabot>   True
20:07:47 <blbrown_win3> what is a good resource for haskell code reviews.  Mailing list, reddit?, or pastebin/irc on this channel, or RTFM? 
20:08:02 <blackdog> blbrown_win3: here's probably best
20:08:19 <applicative> you paste them on hpaste.org  
20:08:24 <blbrown_win3> cool
20:08:29 <applicative> the first critique is from the great HLint
20:08:30 <blackdog> although i've often thought it'd be nice to have a more in-depth code-review service. i'd love to have people look through my apps and tell me all the things i could be doing better.
20:08:50 <blackdog> (less charitably: how badly they suck:)
20:08:53 <blbrown_win3> google code sort of has code review system.
20:09:16 <blbrown_win3> I haven't used it but they git is good for merging/making changes.
20:10:04 * applicative thinks, funny, I thought he said "git is good for merging and making changes"
20:10:24 <blbrown_win3> shrug
20:11:42 <applicative> well, where's this allegedly imperfect code, blbrown.  Of course, if it compiles, its good, in truth; it says something
20:13:19 <blackdog> blbrown_win3: if you're hacking on someone else's code, then of course they'll do code review on it before they accept the change - i thought you were talking more about getting feedback on your own code.
20:14:31 <blbrown_win3> blackdog, that is what I mean.
20:15:38 <applicative> "Code golf in any language is generally a recipe for obfuscation" -- b_allbery.  Is this true of Haskell, where everything is 'compositional'?  
20:16:02 <mauke> yes
20:16:20 <shapr> blackdog: I bet well typed would critique for money :-)
20:16:20 <applicative> I always feel like I learn something from swank 'golfed' things.  Take "  zip `ap` tail "  .... please
20:16:32 <shapr> applicative: What does that do?
20:16:40 <blackdog> applicative: they feel a bit less accidental than the equivalent tricks in perl
20:16:59 <applicative> blackdog, I was thinking there was a structural difference, yeah
20:17:29 <applicative> @quote aztec
20:17:30 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
20:17:50 <j-invariant> "Haskell has this weird property that polymorphic functions, with minor restrictions, are natural transformations" <-- weird?
20:18:02 <j-invariant> "I think this is the deepest mathematical fact about Haskell I've come across"
20:18:03 <copumpkin> where's that from?
20:18:19 <blackdog> applicative: ya. you wouldn't use tricks you learned in golfing perl in real code, ever.
20:18:24 <applicative> j-invariant, are you still quoting in hte second line?
20:18:43 <j-invariant> yes http://blog.sigfpe.com/2006/11/yoneda-lemma.html
20:19:18 <applicative> note that this is very early sigfpe
20:19:56 * applicative thinks the people who don't like sigfpe just don't know about his early stuff...
20:20:04 <j-invariant> I hate that guy
20:20:07 <j-invariant> :P
20:20:18 <blackdog> applicative: yeah, he was better on vinyl.
20:20:25 <j-invariant> with this stupid clear description of yoneda lemma
20:20:46 <applicative> i saw sigfpe at the Whiskey in '77
20:21:23 <applicative> is that the post where he says it is the deepest triviality in mathematics or something?
20:22:12 <ickabob> does haskell provide an analog to assert? The intention is to not allow for sqrt of a negative number.
20:22:34 <applicative> @type sqrt
20:22:35 <lambdabot> forall a. (Floating a) => a -> a
20:22:43 <djahandarie> > sqrt (-1)
20:22:43 <lambdabot>   NaN
20:23:05 <monochrom> see Control.Exception.assert
20:23:58 <djahandarie> > sqrt (-1) :: Complex Double -- fwiw
20:23:59 <lambdabot>   (-0.0) :+ 1.0
20:26:50 <ion> > sqrt (-1) :: Complex Rational
20:26:52 <lambdabot>   No instance for (GHC.Float.RealFloat
20:26:52 <lambdabot>                     (GHC.Real.Ratio GH...
20:27:25 <ion> (Didn’t expect there to be one.)
20:27:42 <Draconx|Laptop> djahandarie, heh, that answer is wrong; the real component should be positive zero.
20:27:44 <ion> Ah, missed the @type above.
20:28:55 <djahandarie> ion, the problem there is (RealFloat a) => Complex a
20:29:36 <djahandarie> > 0 :+ 1 :: Complex Rational
20:29:37 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
20:29:38 <lambdabot>    arising from a u...
20:30:37 <djahandarie> Draconx|Laptop, does it make a difference? I thought signed zero was just an indication of which way rounding went in IEEE 754
20:30:43 <mauke> I'm looking for a copy of "How to replace failure by a list of successes"
20:30:51 <Draconx|Laptop> djahandarie, yes, it makes a big difference.
20:30:56 <mauke> does anyone here have it?
20:31:06 <Draconx|Laptop> djahandarie, convention places the slit for complex square root on the negative real axis.
20:31:27 <Draconx|Laptop> djahandarie, the sign of zero indicates which side of the slit you are on.
20:32:38 <Draconx|Laptop> er, I have my axes confused.   In this case, it's simply that squaring the result does not give you the original.
20:33:04 <applicative> mauke, it's not on Wadler's site?
20:33:46 <mauke> I grepped for "successes" and didn't find anything
20:39:00 <applicative> mauke i have a copy where should i put it?
20:39:33 <applicative> "Jim Morris first introduced me to the idea of pattern matching in functional languages."
20:39:51 <mauke> where I can download it :-)
20:40:21 <applicative> Concluding line: "Whereas the power of Lisp is that it is relatively easy to define new language features, the power of lazy functional languages is that one does not need to."
20:43:47 <mauke> hello?
20:44:17 <applicative> mauke, here http://tinyurl.com/2a4jr4d
20:45:14 <mauke> applicative++  # :-D
20:46:37 <applicative> i need a real server.  the authorities give me only a few MB.  
20:46:47 <djahandarie> @karma djahandarie
20:46:47 <lambdabot> You have a karma of 1
20:46:48 <djahandarie> :(
20:47:15 * applicative can't remember how to elevate djahandarie's karma
20:47:36 <ion> @karma- ion
20:47:36 <lambdabot> You can't change your own karma, silly.
20:47:44 <djahandarie> @karma lambdabot
20:47:44 <lambdabot> lambdabot has a karma of 1
20:47:58 <djahandarie> It's okay, me and lambdabot will just be cool with one karma together.
20:48:07 <mauke> applicative: by saying "djahandarie++"
20:48:07 <applicative> @karma+ djahandarie
20:48:07 <lambdabot> djahandarie's karma raised to 2.
20:48:17 <duairc> I just realised that zipWith is a special case of liftM2
20:48:21 <mauke> "@karma+" is non-standard and only works in lambdabot
20:48:38 <duairc> Oh wait, not quite
20:48:47 <duairc> I knew that couldn't be right
20:48:53 <dolio> It's a special case of liftA2.
20:49:00 <applicative> @type zipWith
20:49:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:49:45 <duairc> dolio: I don't think so
20:49:56 <dolio> For the right applicative it is.
20:50:01 <dolio> The zip list one.
20:50:34 <duairc> Oh right, yeah
20:50:41 <duairc> But not for the default instance for lists
20:50:48 * applicative dimly remembers a module by Hinze (?) in which Applicative is called Zip or something, pressing the analogies
20:50:50 <dolio> Right.
20:51:46 <applicative> http://hackage.haskell.org/packages/archive/hinze-streams/1.0/doc/html/src/Data-Stream-Hinze-Idiom.html not quite like i remembered
20:52:18 <duairc> This came to me by the way when I wanted a cartesian product function... I was surprised that hoogle didn't find one, but I was content when I figured out that I could use liftM2 (,)
20:52:20 <applicative> dolio, yes, he give 'zip' as a method of Idiom; it's liftA2
20:52:52 <listofoptions> anybody know of a ghetto way to graph functions in haskell/
20:53:26 <listofoptions> ie something like "graph x*x"
20:53:34 * applicative only knows the shtetl way
20:54:09 * listofoptions is interested now
20:54:54 <Jafet> (system "gnuplot")
20:55:13 <dolio> There's even gnuplot bindings, no?
20:56:05 <Jafet> Perhaps he can't touch that.
20:58:29 <latros> anyone here use yi, btw?
20:59:04 <latros> I have managed to get it to compile, but I can't seem to find decent documentation on its builtin functions and such
21:05:24 <applicative> it seems we are too slow for listofoptions
21:42:54 <isaacd> dons: Why can't I e-mail the Haskell Platform committee or list? My mail keeps getting rejected. (E-mailing libraries@ is working fine.)
22:12:50 <Mr_Miaggi> hi
22:13:43 <Mr_Miaggi> anybody know any microsoft dev channels?
22:15:52 <Enigmagic> Mr_Miaggi: for any language or technology in particular?
22:16:47 <Mr_Miaggi> not sure my brother posted the question...he's 3 years old and wants to learn
22:17:15 <Mr_Miaggi> he said "goo..goo..gagaa"....is that even a technology?
22:17:58 <Axman6> well, you win my medel for most retardedly bizzare troll of the day
22:18:07 <Veinor> haha
22:18:41 <Mr_Miaggi> lol nice one
22:18:59 <Axman6> medel? bah -_-
22:20:03 <Enigmagic> :P
22:21:09 * Mr_Miaggi slaps Axman6 around a bit with a large trout
22:24:12 <augur> http://wellnowwhat.net/transfers/RoseFactorizations.png
22:24:17 <augur> just for anyone whos interested
22:24:47 <Axman6> ?
22:27:11 <Jafet> mspaint!
22:27:20 <augur> Axman6: a rose tree that contains the unique occurances of pairs (n,fs) where n is a positive integer and fs is the list of prime factors of that integer
22:27:31 <augur> Axman6: where all positive integers are present
22:27:34 <augur> Jafet: photoshop :P
22:28:17 <augur> but theres a funny little relationship between the smaller and larger circled trees in each case
22:28:28 <augur> demonstrating a cool property of this tree
22:28:38 <flamingspinach> yeah, the lines have that special warm fuzzy glow that only $800 software can impart
22:28:39 <Gopi> I've a newbie question regarding associativity of -> (for function types)
22:28:43 <flamingspinach> shame on you, Jafet, for not noticing the difference
22:29:03 <j-invariant> Gopi: what is it?
22:29:03 <Gopi> I'm unable to understand that it's right associative given that the function application is left associative
22:29:11 <Jafet> Bah, it's too subtle for me
22:29:18 <adu> Gopi: right-associative
22:29:19 <j-invariant> Gopi: funciton application is backwards
22:29:28 <Jafet> Even mspaint is like $200
22:29:36 <flamingspinach> rofl
22:29:40 <flamingspinach> good point
22:29:48 <flamingspinach> at least it comes with an operating system and other goodies though
22:29:49 <j-invariant> Gopi: f : a -> b, x : a |- f x : b
22:30:02 <Enigmagic> Jafet: but it also comes with Solitaire
22:30:05 <Enigmagic> i doubt photoshop does
22:30:11 <j-invariant> Gopi: which is downright crazy, anyone sensible would use  x : a, f : a -> b |- x f : b
22:30:11 <adu> Gopi: let's use an example
22:30:16 <flamingspinach> Enigmagic: who knows, maybe there's an easter egg in the about menu
22:30:18 <flamingspinach> *dialog
22:30:24 <j-invariant> Gopi: anyway that's why the function application matches with the types
22:30:36 <j-invariant> oens backwards, so you have to flip them around
22:30:45 <augur> flamingspinach: my copy of photoshop came free with my copy of The Pirate Bay
22:30:47 <augur> :P
22:30:49 <adu> Gopi: how about f x y z
22:31:06 <flamingspinach> augur: sounds like a mislabeled torrent happened to you somewhere along the line :)
22:31:14 <augur> :P
22:31:25 <augur> different kinds of copies!
22:31:30 <adu> Gopi: f :: X -> (Y -> (Z -> R))
22:32:01 <adu> Gopi: and (f x) :: (Y -> (Z -> R)), (f x y) :: (Z -> R), (f x y z) :: R
22:32:32 <adu> Gopi: so f x y z == (((f x) y) z)
22:35:38 <Gopi> j-invariant: I don't know what |- means. Thanks adu, that clarifies.
22:36:06 <flamingspinach> in other words this arises from the fact that, even in mathematics, f(x) = y means x --f--> y
22:36:21 <flamingspinach> (f coming first in the first notation, and x coming first in the second)
22:36:28 <flamingspinach> is that about right?
22:39:26 <Axman6> Gopi: not many people do,. especially haskell newbs (i've been using haskell for 3 years and have only a small understanding of what j-invariant is saying)
22:39:41 <mm_freak> Gopi: remember that in haskell a function always has a single argument
22:40:13 <mm_freak> to implement multi-argument "functions" you implement functions that return functions
22:40:17 <mm_freak> a -> (b -> c)
22:40:33 <mm_freak> it takes an 'a' and returns a 'b -> c', which you can apply in turn to a value of type 'b'
22:40:38 <mm_freak> f x y = (f x) y
22:40:43 <djahandarie> x |- y just means that y is derivable from x 
22:41:07 <djahandarie> A -> B  |-  !B -> !A   for example
22:41:14 <mm_freak> that's why function type construction is right-associative, while function application is left-associative
22:41:15 <Gopi> Meaning, there exists a function f with type x -> y?
22:41:30 <mm_freak> no, x and y are /value/ variables
22:41:38 <mm_freak> 'a', 'b' and 'c' are type variables
22:41:48 <latros> actually, those are Chars
22:41:51 <latros> *nitpick*
22:42:02 <shapr> djahandarie: What's up with A -> B  |-  !B -> !A   ?
22:42:16 <latros> that's equivalence of a statement and its contrapositive
22:42:16 <flamingspinach> that's logic, not haskell
22:42:21 <latros> but yeah, that's logic
22:42:25 <copumpkin> @djinn (a -> b) -> (Not b -> Not a)
22:42:26 <lambdabot> f a b c = b (a c)
22:42:44 <djahandarie> f : a ->b, x : a |- f x : b   translates to: given a function with type a->b and a variable x with type a, f x has the type of b
22:42:47 <shapr> @src Not
22:42:48 <lambdabot> Source not found. Sorry.
22:42:56 <copumpkin> type Not a = a -> Void
22:42:57 <flamingspinach> @src not
22:42:58 <lambdabot> not True   =  False
22:42:58 <lambdabot> not False  =  True
22:43:07 <copumpkin> data Void
22:43:11 <djahandarie> flamingspinach, that's a different not
22:43:14 <flamingspinach> oh
22:43:23 <flamingspinach> sorry, I know nothing as yet :)
22:43:25 <djahandarie> copumpkin, that isn't H98!
22:43:34 <edwardk> newtype Void = Void Void
22:43:37 <edwardk> there ;)
22:43:42 <shapr> djahandarie: Oh, that's easy enough.
22:43:45 <shapr> o hai edwardk
22:43:57 <copumpkin> edwardk: that's less guiltily inhabited though
22:44:00 <edwardk> heya shapr
22:44:04 <djahandarie> shapr, what is? :P
22:44:13 <shapr> djahandarie: your translation... makes perfect sense
22:44:16 <copumpkin> as in, it has the same size as data Void, but you feel less guilty providing its one inhabitant
22:44:23 <edwardk> heh
22:44:49 <djahandarie> edwardk, so when is the next Boston Haskell? :)
22:44:57 <mm_freak> Gopi: take as an example the (+) function for integers…  it has the type Integer -> Integer -> Integer, which (because (->) is right-assoc) is equivalent to Integer -> (Integer -> Integer)
22:45:07 <dolio> copumpkin: Using fix doesn't make you feel guilty?
22:45:10 <edwardk> copumpkin: but you don't have to export the constructor (though the compiler while whine)
22:45:15 <mm_freak> Gopi: when you apply this function to one argument, you get a function back, which expects another argument
22:45:25 <mm_freak> so '(+) 3' is a function
22:45:27 <shapr> djahandarie: You could organize the next Boston Haskell :-P
22:45:29 <edwardk> djahandarie: good question. probably late january
22:45:44 <copumpkin> dolio: it does, but not quite as guilty as something that obviously doesn't terminate
22:45:47 <mm_freak> and ((+) 3) 4 applies a value to that intermediate function
22:45:50 <copumpkin> I can pattern match on newtype Void
22:45:58 <edwardk> djahandarie: my wife picked up a camera for me for christmas
22:45:59 <Gopi> mm_freak: Thanks mm_freak. I got it.
22:46:06 <edwardk> copumpkin: only if i export the constructor ;)
22:46:21 <mm_freak> Gopi: and because application is left-assoc you can leave the parentheses away:  (+) 3 4
22:46:29 <djahandarie> shapr, no, I think I'll continue to let edwardk handle it even though he didn't sign up for the job ;)
22:47:02 <dolio> copumpkin: fix Void doesn't terminate. :)
22:47:04 <edwardk> djahandarie: there were some questions about how to get david spivak's schedule to line up with mine, since i wasn't sure when in january/february i was going to be in new york and he had some travel
22:47:12 <mm_freak> i think haskell is one of the very few languages, in which you care about these things =)
22:47:25 <dolio> It's only inhabited because of bottom.
22:47:35 <dolio> data Void = Void Void is empty in Agda.
22:47:41 <edwardk> dolio: i believe that is the one inhabitant he is referring to
22:47:42 <djahandarie> edwardk, :( I might not be able to come if it's after the 18th
22:47:45 <copumpkin> dolio: but I can peel off Void constructors at will (assuming they're in scope, which they apparently aren't)
22:47:46 <copumpkin> :P
22:48:15 <dolio> You can only peel off the constructors because GHC makes sure you don't actually peel off constructors. :)
22:48:18 <edwardk> djahandarie: i'll try to factor that in
22:48:28 <copumpkin> yeah :P
22:48:35 <copumpkin> but that's more constructors than I can peel off with data Void
22:48:35 <djahandarie> Hah, I'm not that important. :P
22:49:08 <copumpkin> how is newtype Void = Void Void represented in memory anyway?
22:49:17 <dolio> No idea.
22:49:17 <copumpkin> as a pointer to itself?
22:49:27 <copumpkin> void *moo = &moo :P
22:49:34 <Axman6> :P
22:49:41 <edwardk> not even that
22:49:49 <shachaf> copumpkin: Well, the only value of that type is _|_.
22:49:50 <djahandarie> With pixie dust that a black magician called GHC manipulates
22:50:06 <dolio> The idea of a newtype is that it's represented the same as the one thing in the constructor.
22:50:14 <dolio> With Void, it's represented identically to Void.
22:50:15 <copumpkin> yeah
22:50:25 <copumpkin> yeah, but there's no base case there :P
22:50:26 <edwardk> when you try to inhabit it with a bottom, you have the same representation as any bottom. just a thunk that evaluates to kaboom. the newtype doesn't offer any other implementation
22:50:36 <Axman6> which is represented identically to Void...
22:51:00 <Axman6> well, not kaboom, foo = Void foo works fine
22:51:01 <edwardk> if you say foo = Void foo — it'll spin forever. evaluating it will never give you back a Void
22:51:17 <edwardk> well, it'll give you a bottom
22:51:27 <edwardk> when you go to look at it
22:51:29 <dolio> Conceivably, if GHC were smart enough, it could probably avoid representing Voids at all.
22:51:37 <dolio> Possibly, at least.
22:51:43 <copumpkin> so case fix Void of Void x -> ...
22:51:47 <Axman6> and you can do foo = Void foo; mapVoid (Void x) = mapVoid x
22:51:49 <dolio> I suppose it might depend on the program.
22:51:50 <isaacd> Nah, they can hold different _|_ values.
22:52:07 <isaacd> like 'error "hi"' vs 'undefined' vs 'throw (something)'
22:52:19 <j-invariant> "roughly, a monad is an algebraic theory"?
22:52:41 <copumpkin> http://www.cwru.edu/artsci/math/wells/pub/ttt.html
22:52:49 <dolio> Roughly because it's actually a generalized algebraic theory.
22:52:58 <isaacd> All newtypes are kind *; all unevaluated or bottom values of kind * are represented the same way in memory by GHC.
22:53:44 <j-invariant> class GeneralizedAlgebraicTheory m where ...
22:55:11 <qfr> Aww the Y combinator is not legal in Haskell? (\f -> (\x -> f (x x)) (\x -> f (x x)))
22:55:23 <copumpkin> qfr: it can be
22:55:29 <copumpkin> but you need to use a funky type :)
22:55:33 <qfr> Oh?
22:55:40 <copumpkin> and even then, you need to do some wrapping and unwrapping
22:55:54 <edwardk> or unsafeCoerce!
22:56:02 <djahandarie> \o/
22:56:07 <dolio> @type Roll
22:56:09 <lambdabot> Not in scope: data constructor `Roll'
22:56:21 <edwardk> @type Rick
22:56:23 <lambdabot> Not in scope: data constructor `Rick'
22:56:52 <djahandarie> newtype Rick a = Roll { unroll :: Rick a -> a }; y f = (\x -> f ((unroll x) x)) (Roll (\x -> f ((unroll x) x)))
22:56:59 <shapr> argh!
22:57:00 <dolio> jdh claims that OCaml's ability to type that Y combinator using equirecursive types is a major advantage.
22:57:06 <qfr> http://r6.ca/blog/20060919T084800Z.html
22:57:10 <copumpkin> dolio: damn right!
22:57:10 <qfr> dolio: Haha
22:57:24 <isaacd> This is one thing that happens when you don't care which _|_ is which: http://hackage.haskell.org/trac/ghc/ticket/1171
22:57:40 <ion> (Y), (_|_) and other anatomical values
22:57:56 <djahandarie> lol
22:58:02 <j-invariant> 1p;4;4;
22:58:16 <j-invariant> polynomial functions in haskell are natural transofrms:
22:58:24 <j-invariant> is that a trivial theorem or very difficult?
22:58:25 <dolio> GHC's optimizer will actually go into loops if you write that sort of Y combinator, too.
22:58:30 <edwardk> dolio: jdh claims many things. only rarely are they valid concerns ;)
22:58:46 <dolio> It's designed under the premise that you can't write that (or won't jump though the typing hoops to do so).
22:59:11 <edwardk> j-invariant: the connection between polymorphism and (di)natural transformations is fairly well explored.
22:59:36 <edwardk> er parametric polymorphism
22:59:53 <dolio> I don't think it's trivial, though.
23:00:05 <dolio> It involves learning a bunch of technical definitions about what parametricity means.
23:00:06 <j-invariant> are there any other categories with something like that?
23:00:07 <edwardk> definitely not trivial
23:01:25 <edwardk> hey copumpkin: tarmo finally posted his msfp paper, so i don't have to bring in a hard copy! http://www.ioc.ee/~tarmo/papers/msfp08.pdf
23:01:35 <dolio> edwardk: The amusing thing is that he alternately claims that Haskell programmers put all kinds of top-level annotations in their programs due to defects in the type system.
23:02:01 <dolio> Yet, if you infer equirecursive types, you can easily write lots of trivial bugs unless you litter your program with top-level annotations.
23:02:06 <edwardk> dolio: i've largely tuned him out and stopped listening to him
23:02:33 <dolio> I haven't read anything by him in a while. I got tired of it.
23:02:40 <edwardk> i tune in long enough to debunk something and then shut him out
23:02:40 <copumpkin> I haven't even noticed him posting on reddit in a while
23:02:51 <copumpkin> maybe he got banned or tired of pissing people off (the latter is unlikely)
23:03:09 <edwardk> he trolls indirectly. gets shot down too fast if he posts straight to reddit, so when something gets posted to reddit, he replies ON the target blog
23:03:09 <dolio> He still posts occasionally in c.l.functional.
23:03:10 <copumpkin> edwardk: cool, will check it out tomorrow
23:03:15 <copumpkin> might sleep now
23:03:26 <djahandarie> I answered a question of his on stackoverflow the other day
23:03:38 <edwardk> i think i saw that one
23:03:42 <edwardk> he was downright courteous
23:03:48 <djahandarie> Yeah
23:04:09 <djahandarie> I looked at his other stackoverflow posts and they all seem to be fairly tame
23:04:42 <edwardk> broader community, more compartmentalized, he has his views challenged a lot less there
23:05:43 <djahandarie> It's weird that all the EST people talk at like 2am
23:05:53 <edwardk> some of us just don't sleep
23:06:09 <copumpkin> :P
23:06:17 <djahandarie> My sleep schedule over the weekend seems to be the opposite of what it is during the week
23:06:23 <cncl> question: often i have ghci open with a file i'm working on. i'll use :r to reload the file and type check it occasionally. sometimes it will fail, and the file won't be loaded. once that has happened, i can't use :t to check the type of things loaded by that module
23:06:26 <edwardk> though i may get a few z's and actually come in to work early
23:06:28 <djahandarie> Making the transition a little rough
23:06:28 <cncl> is there some way around that
23:06:41 <dolio> Remarkably, he seems to not have participated at all in the, " to improve the readability of (any) LISP or any highlevel functional language to the level of FORTH ?" thread.
23:06:47 <copumpkin> edwardk: very radical!
23:06:53 <dolio> Er, that should be "How to ..."
23:06:59 <Jafet> cncl: revert your code to the previous version and reload
23:07:29 <shachaf> edwardk: Where do you work?
23:07:29 <jamy23> anybody use HOUSE?
23:07:44 <cncl> Jafet: that means i will either have to do undo a lot, or make many git commits that i wouldn't otherwise make
23:07:56 <edwardk> shachaf: i work at CapitalIQ/ClariFi
23:08:03 <dolio> jamy23: I doubt it.
23:08:19 <djahandarie> cncl, I don't think ghci actually "loads" anything until it has fully type-checked everything
23:08:28 <djahandarie> jamy23, I'm pretty sure even its creators don't use it
23:08:33 <Jafet> Well, you can merge the commits later
23:08:49 <edwardk> shachaf: basically copumpkin and i get paid to hack on functional code and do PL stuff ;)
23:08:51 <Jafet> Ideally your new code should come out of ghci typechecked, but ghci is a terrible editor
23:09:03 <copumpkin> I must say, it's pretty awesome
23:09:19 <cncl> djahandarie: right, that's why i can't use :t, because i will reload the file and it will fail
23:09:23 <cncl> and stuff won't be imported
23:09:23 <Jafet> djahandarie: sure, but it always meticulously unloads the previous version first
23:09:25 <shachaf> edwardk: Neat. :-) For some reason I thought you were at a university.
23:09:38 <edwardk> as long as i occasionally make corporate-speak noises folks leave me alone ;)
23:09:38 <shachaf> But I must be thinking of one of the other Boston people.
23:09:41 <jamy23> ghc has self bytecode?
23:09:43 <djahandarie> People should get paid to provide support in this channel
23:10:01 <copumpkin> djahandarie: it works fine with no money :P
23:10:07 <copumpkin> money makes things icky :)
23:10:21 <djahandarie> But with money they can be here all day!
23:10:36 <edwardk> shachaf: nah, i've greatly enjoyed my status as a card-carrying pseudo-academic for the last few years
23:10:43 <Xilon> I'd love to work at an FP company :(
23:11:03 * Xilon is stuck writing Perl with the only alternative being C# *sigh*
23:12:15 <edwardk> shachaf: trying to think which boston #haskellers are actual academics. there aren't many
23:12:38 <j-invariant> how is a suitable function {words in G such as x^-2 y^3 x z^-1 y^4} --> G a monad? (for some set G)
23:12:56 <shachaf> edwardk: Hmm. Well, perhaps I was thinking of one of the non-Boston people. :-)
23:13:01 <shachaf> Close enough.
23:13:13 <djahandarie> I go to a university! But I do nothing related to Haskell, functional languages, and I barely even do CS. lol
23:13:28 * djahandarie is taking a total of 1 CS course next semester
23:13:54 <edwardk> yeah, i guess its much easier to suppose that there exists a person in some city X such that they are a haskeller and at a university where X is in the set of cities excluding boston. i'd be willing to grant that hypothesis
23:14:12 <djahandarie> I fixed my grades though, yeay
23:14:18 <j-invariant> "fixed"?
23:14:26 <djahandarie> > fix grades
23:14:27 <lambdabot>   Not in scope: `grades'
23:14:44 <edwardk> you know bottoming out your grades is generally not a good idea ;)
23:14:45 <djahandarie> lambdabot is a dropout
23:15:17 <shachaf> @vixen Is that true, lambdabot?
23:15:18 <lambdabot> first you tell me.
23:15:20 <Axman6> > fix 80
23:15:21 <lambdabot>   80
23:15:24 <Axman6> heh
23:15:38 <djahandarie> j-invariant, just retook some courses that I got bad grades in
23:15:45 <edwardk> > fix error
23:15:47 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
23:15:51 <j-invariant> oh ok
23:16:29 <djahandarie> Alright I'm going to bed or I'll be dead tommorrow for work. Night
23:18:12 <shapr> shachaf: I'm a #haskell person, and I'm working on my undergrad CS degree, do I count? :-)
23:18:20 <copumpkin> j-invariant: not sure specifically there, but if you have a functor giving a set some structure, and another forgetting it, they are adjoint, and composition of adjoint functors (in one direction) gives you a monad
23:18:36 <copumpkin> giving a set some structure = free, anyway
23:18:37 <Veinor> shapr: high five!
23:18:46 <shachaf> shapr: You're not in Boston, though.
23:18:50 <shachaf> Oh, Veinor is in Boston, right?
23:18:51 <shapr> shachaf: I was previously?
23:18:53 <Veinor> yeah, i am
23:18:54 <edwardk> shachaf: but he was
23:19:04 <shapr> I don't think I ever got to meet Veinor though.
23:19:11 <Veinor> (well, I'm in cambridge, technically)
23:19:21 <shapr> and I was in Somerville, technically
23:19:43 <edwardk> veinor: you make it down to any of the boston haskell meetups?
23:19:54 * edwardk sucks at tying faces to names to nicks
23:19:54 <shapr> I think I organized the first meeting of BostonHaskell too.
23:19:56 * shapr tries to remember
23:20:09 <edwardk> shapr: yeah you did, and convinced me to talk about comonads
23:20:12 <Veinor> edwardk: one a while ago
23:20:18 <shapr> oh right, I remember that!
23:20:31 <edwardk> but nirav and ravi wound up getting us space out at bluespec
23:20:33 <Veinor> the most recent one, i believe. i was the really young-looking guy :)
23:20:45 <shachaf> You people should move BostonHaskell over here.
23:20:51 <edwardk> where is here?
23:20:55 <shachaf> CA.
23:20:58 <shapr> I haven't yet organized the first meeting of AlabamaHaskell, but soon.
23:21:03 <edwardk> don't you have BAHUG?
23:21:21 <shachaf> edwardk: True, there's bahaskell.
23:21:54 * shachaf works with the organizer, in fact.
23:22:09 <shapr> I keep trying to get jmcarthur to do all the AlabamaHaskell organizing, but it hasn't happened yet.
23:22:15 <shachaf> But I've only been to one meeting.
23:22:57 <djahandarie> shachaf, you work at Engine Yard?
23:23:07 <djahandarie> Hmm, I'm as bad as copumpkin at going to bed
23:23:13 <copumpkin> :P
23:23:48 <djahandarie> Hmm, actually I don't think that guy organizes it, I think he just 'hosts' it
23:23:56 <shachaf> djahandarie: No, that's just where they run their meetings.
23:23:59 <shachaf> Yep.
23:24:09 <shachaf> I meant Ivan Tarasov.
23:24:15 <djahandarie> Yeah
23:24:22 <djahandarie> He seems more interested in Agda than Haskell though
23:24:28 <j-invariant> culd you use category theory to make a better module system than haskell?
23:24:31 <djahandarie> Err
23:24:40 <j-invariant> instead of "Hask" everywhere, have "MyModule" etc.
23:24:41 <djahandarie> The Engine yard guy
23:24:42 <djahandarie> I mean
23:24:44 * djahandarie sighs
23:24:49 <shachaf> djahandarie: Who's that?
23:24:54 <copumpkin> larrytheliquid
23:24:57 <djahandarie> Yeah
23:25:02 <copumpkin> larry diehl I think
23:25:06 <djahandarie> Yep that's his name
23:25:41 <augur> copumpkin: agreed.
23:25:43 <shachaf> I don't think I've met him.
23:25:56 * shachaf also lives about an hour from SF.
23:25:59 <djahandarie> shachaf, I was at one of those, you should have gone :P
23:26:03 <djahandarie> I live on the other side of the country!
23:26:04 <shachaf> But then so does Ivan, so it's no excuse. :-)
23:26:09 <shachaf> djahandarie: Which one?
23:26:21 <djahandarie> Good question. It was near the of summer
23:26:33 <shachaf> When?
23:26:37 <copumpkin> augur: :(
23:26:43 <djahandarie> Hmmm
23:26:52 <augur> copumpkin: you can turn it off in search prefs tho
23:27:23 <copumpkin> augur: I was looking for that
23:27:27 <copumpkin> but couldn't find such an option
23:28:03 <augur> turn off instant search
23:28:24 <copumpkin> that's different though
23:28:33 <djahandarie> shachaf, August 11th
23:28:34 <augur> it worked for me, for the most part
23:28:40 <augur> i mean, maybe not, im not that attentive, but
23:28:41 <augur> :P
23:28:44 <copumpkin> I mean the "showing results for <unrelated misspelling of query>. Search instead for <what you actually typed in>"
23:28:57 <augur> yeah i know
23:28:59 <augur> im probably wrong
23:29:01 <augur> who knows!
23:29:03 <shachaf> djahandarie: Ah. I was only at Erik Meijer's talk in November.
23:29:16 <augur> copumpking: wellnowwhat.net/transfers/RoseFactorizations.png
23:29:17 <copumpkin> hmm, maybe you're right
23:29:20 <shachaf> djahandarie: You should come again! :-)
23:29:26 <djahandarie> shachaf, it's a little hard ;)
23:29:36 <djahandarie> Buy me a plane ticket :P
23:29:44 <shachaf> @localtime djahandarie
23:29:45 <lambdabot> Local time for djahandarie is Mon Jan  3 03:13:43 2011
23:29:48 <copumpkin> nah, still broken: http://snapplr.com/efqw
23:29:52 <copumpkin> augur: what's that?
23:30:04 <shachaf> Huh, what time zone is that?
23:30:18 * djahandarie lives somewhere in the atlantic ocean
23:30:24 <augur> a rose tree that contains unique pairs (n,fs) where n is a positive integer and fs are its prime factors
23:30:32 <shachaf> djahandarie: FSVO "in".
23:30:34 <augur> copumpkin: that is, each (n,fs) shows up only once.
23:30:35 <shachaf> Presumably.
23:30:49 <augur> copumpkin: notice the fun relationship between the darker circled subtrees to the larger circled subtrees
23:30:51 <augur> :)
23:30:56 <djahandarie> shachaf, my server clock is off, that's all. :P I'm EST here, Connecticut
23:31:37 <shachaf> Aw.
23:33:46 <copumpkin> augur: interesting. How did you generate that?
23:33:53 <augur> by hand XD
23:34:01 <augur> i just observed it
23:34:13 <augur> tho you can write a short little definition for it
23:37:23 <augur> copumpkin: http://www.pasteit4me.com/1970002
23:37:41 <copumpkin> yeah
23:38:13 <augur> im sure you could eliminate the RoseL (1,[1]) from it if you had something like rosetails
23:38:28 <augur> where rosetails (RoseL l x:xs) = RoseL l xs
23:39:44 <j-invariant> augur: why did you start to think about rose tree?
23:40:05 <augur> j-invariant: what?
23:40:35 <flamingspinach> augur: isn't that just a cayley graph of the multiplicative monoid of natural numbers?
23:40:48 <augur> flamingspinach: i have no idea
23:41:13 <augur> copumpkin: i also came up with a visual proof that its possible to enumerate all the nodes of a labeled rose tree :D
23:41:30 <flamingspinach> what is a rose tree in general?
23:42:01 <augur> a tree with any number of daughters
23:42:16 <flamingspinach> how does a tree have daughters
23:42:24 <augur> its nodes have daughters
23:42:26 <flamingspinach> or do you mean generally a tree in which the number of leaves on a node is not restricted?
23:42:31 <augur> yes
23:42:36 <flamingspinach> I see
23:42:53 <Axman6> @src Tree
23:42:54 <lambdabot> Source not found. I feel much better now.
23:42:57 <Axman6> bah
23:43:02 <Axman6> @src Data.Tree.Tree
23:43:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:43:05 <djahandarie> flamingspinach, I'm pretty sure it isn't the cayley graph of the multiplicative monoid of natural numbers...
23:43:09 <flamingspinach> btw I'm wrong, it's not the Cayley graph exactly
23:43:11 <Axman6> maybe you should shut up lambdabot!
23:43:16 <flamingspinach> lol djahandarie
23:43:18 <flamingspinach> yeah, it's not
23:43:25 <augur> @src Data.Tree
23:43:25 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:43:29 <augur> well ok then
23:43:49 <Axman6> :t Node
23:43:50 <lambdabot> forall a. a -> Forest a -> Tree a
23:44:53 <flamingspinach> the cayley graph of anything abelian and with more than one generator can't really be a tree, I think
23:45:58 <colah> Noob question: is there a way I can make Num extend a class? I want to implement algebraic structures and it's stolen some of my operators :)
23:47:21 <djahandarie> Took me a second to even think of what a cayley graph of a monoid would be
23:47:31 <Axman6> why can't you just make your datatype an instance of Num?
23:49:24 <djahandarie> I guess m = <c>, where m is a monoid and c is a generating set, the vertices of the graph would be m and the edges would be x -y> xy, x \in m, y \in c
23:49:41 <flamingspinach> yup, exactly
23:50:02 <colah> Axman6: Num is far stronger than what I want.
23:50:02 <cads> god, what should I do the next time I ask a student if they've studied formal logic and they answer "yeah, I've taken critical thinking" or "yeah, I've taken discrete math"?
23:50:06 <flamingspinach> basically the same as the cayley graph of a group, except with half as many generators :)
23:50:34 <cads> well, I should say schoolmate
23:50:47 <j-invariant> cads: ask them to prove loebs theorem
23:50:55 <colah> And I'm not implementing a single data type either. I'm building up Magma -> Group -> Albelian Group -> Feild etc and then Vector Space and such.
23:51:00 <Axman6> colah: what do you want?
23:51:04 <djahandarie> flamingspinach, how does this connect to a tree like augur's? Specifically the part regarding prime factors
23:51:17 <djahandarie> colah, the numerical stack in the base library is awful
23:51:23 <flamingspinach> once I asked a professor (a model theorist) if I could study formal logic with him and he said "nah that's boring, let's do computability instead" :/
23:51:30 <Axman6> colah: make new functions then, like +., *. etc
23:51:34 <j-invariant> colah: do you have aa github or blog or something? i want to follow the progress of your program
23:51:39 <flamingspinach> djahandarie: the nonzero naturals are a free commutative monoid over the primes
23:51:44 <ClaudiusMaximus> wow, fixed a really stupid bug in my garbage collector... i was traversing each node as many times as there were paths to it - no wonder it got slow...
23:51:46 <colah> http://christopherolah.wordpress.com
23:51:52 <j-invariant> thanks
23:51:57 <djahandarie> colah, numeric-prelude provides some better stuff if you're interested
23:52:14 <colah> I'll look into that.
23:52:17 <Saizan> cads: my first course on mathematical logic was a spinoff of discrete math :)
23:52:56 <colah> I'm really just playing around with implementing math stuff in haskell and using unicode to make syntax nicer.
23:53:12 <colah> I'm new to haskell and I'm trying to figure out if its right for me.
23:53:34 <j-invariant> colah: you picked an extremely difficult problem
23:53:42 <flamingspinach> djahandarie: augur's tree is the cayley graph of that monoid, with all but the monotonically increasing path from the root node to any given node deleted (leaving shared edges, of course)
23:53:44 <djahandarie> colah, use Agda instead, Haskell isn't that good at expressing this stuff
23:53:48 <Saizan> colah: you can import Prelude without Num
23:53:50 <colah> I was playing around with approximating integral transforms, and that worked out well.
23:53:54 <flamingspinach> monotonically increasing in edge color I mean
23:54:08 <colah> So I'd need to rewrite Prelude?
23:54:16 <augur> well im glad my little observation has caused such intrigue <3
23:54:34 <flamingspinach> what was your observation?
23:54:38 <Saizan> colah: you'd need to avoid the Num class
23:54:56 <cads> Saizan, I meant how should I act the next time someone I'm talking to assumes they already know all there is to know about logic because they know the connectives and a couple rules.
23:55:00 <colah> Couldn't I just inject a higher level class above it?
23:55:03 <augur> flamingspinach: the tree! :|
23:55:17 <Saizan> colah: not without hacking the source code
23:55:34 <flamingspinach> what did you observe about it?
23:55:38 <colah> I see. OK. Thank your for your help.
23:56:08 <augur> flamingspinach: that it exists >|
23:57:00 <flamingspinach> I notice you circled some subtrees - self-similarity in that tree comes from the fact that the monoid is free commutative :)
23:57:17 <augur> flamingspinach: ok
23:58:40 <Saizan> cads: expose them to other logics maybe, e.g. higher order and/or intuitionistic
23:59:11 <j-invariant> cads: wqhat more is there?
23:59:20 <cads> Saizan, I think that might be a good idea, since I'm not even sure why it'd be important to me that people get that they don't really know logic in general
23:59:50 <cads> if I show them examples of things that it helps
23:59:58 <flamingspinach> cads: ask them whether they haven't ever wondered how the "by a compactness argument" hand-wave works, and whether they haven't ever wished they could master its power :)
