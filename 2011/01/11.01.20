00:00:03 <Arney> capitalize  cs = (toUpper (head cs)) : [toLower c | c <- (tail cs)]
00:00:54 <Axman6> may i suggest you go and read LYAH before going any further? it won't take you long at all find the answer you're after
00:00:54 <Cale> Arney: If a string is empty, the capitalisation of it is also empty. If it is not empty, then the capitalisation consists of the uppercase version of the first character followed by the capitalisation of the remainder of the string.
00:01:18 <Kaidelong> Arney: what do you know at this point?
00:01:45 <Cale> (Or is that not what we're looking for)
00:01:58 <kfish> Cale, looks like just the first letter
00:02:11 <edwardk> > let capitalize  cs = (toUpper (head cs)) : [toLower c | c <- (tail cs)] in capitalize ""
00:02:12 <lambdabot>   "*Exception: Prelude.head: empty list
00:02:21 <edwardk> ^— looks dangerous to me ;)
00:02:47 <Arney> Cale: you just translated my code into english... I am instructed to use a recursive method... I am not sure if tis possible.
00:02:50 <kfish> Arney, how would you write a recursive function that just did the lowercasing part?
00:03:04 <quuuux> > fix (\ k f xs -> case xs of {[] -> []; (first:rest) -> (f first):(k f rest)}) toUpper "foobar"
00:03:04 <lambdabot>   "FOOBAR"
00:03:08 <quuuux> look, ma, no loops!
00:03:28 <Cale> Arney: Actually, the function I translated into English isn't the one you wrote.
00:03:29 <edwardk> arney: note that cale's definition was different, it included a base case for the empty string which your code did not, and his definition of capitalization capitalized all letters, where yours capitalizes the first and lowercases the rest.
00:04:02 <edwardk> which definition is the one your instructor is looking for is between you and your instructor ;)
00:04:27 <edwardk> but i suspect it is closer to what cale mentioned
00:05:50 <Arney> edwardk: its capitalize the first letter, lower case the wrest
00:05:58 <Arney> here is the assigned problem http://pastebin.com/Taacihvj
00:06:14 <cubi> Joe Hacker?
00:06:18 <cubi> rly? awesome :>
00:06:31 <quuuux> @pl \ a b -> (f a):(k a b)
00:06:31 <lambdabot> ap ((.) . (:) . f) k
00:06:36 <Arney> I solved "capitalize", now I need to solve " capitalize' "
00:06:38 <cubi> ah i see what you did there Arney 
00:06:38 <edwardk> arney: you still probably want to handle the base case of the empty string gracefully
00:06:51 <fabjan> cubi: **FIX** probably means the students are supposed to fill in their names :)
00:06:59 <cubi> yeah
00:07:06 <edwardk> cubi: given the coauthor is sally segfault, i think its a pseudonym ;)
00:07:10 <cubi> yy
00:07:12 <Arney> cubi: I thought that was his name too, then I realised it says "fix" so I can put my name there.
00:07:12 <quuuux> @hoogle (t -> [t] -> [a]) -> [t] -> [a]
00:07:13 <lambdabot> No results found
00:07:18 <Axman6> Arney: imagine you didn't know C, or any language at all like it. would it be a good idea to jump in and try and write these sorts of functions without learning a little C first?
00:08:19 <edwardk> cubic: I used to know a guy named John Public, who kept getting asked if his middle initial was Q.
00:08:34 <cubi> lol
00:09:12 <quuuux> there's no library combinator `\ a xs -> case xs of {[] -> []; (first:rest) -> a first rest}' ?
00:09:17 <cubi> I know someone called "bauklo", let google or so translate it four you in english ;>
00:09:30 <cubi> s/in/to/
00:09:32 <fabjan> Arney: Just read a little on recursion over lists. You have it easy, I had to do my first programming excercises in ML where recursing over strings is not as easy :P
00:10:35 <Kaidelong> > (++) <$> (map toLower) <*> (map toUpper . take 1) $ "intimidate"
00:10:35 <Kaidelong> err no
00:10:35 <Kaidelong> (map toLower . drop 1)
00:10:35 <Kaidelong> but I see lambdabot is down for the count
00:10:37 <lambdabot>   "intimidateI"
00:10:37 <Kaidelong> or maybe it is just me, the network likes to do that
00:11:36 <edwardk> > (++) <$> (map toLower . drop 1) <*> (map toUpper . take 1) $ "intimidate"
00:11:38 <lambdabot>   "ntimidateI"
00:11:50 <edwardk> =)
00:12:11 <edwardk> she's just slow
00:12:46 <dobblego> liftA2 (++) in libraries FTW
00:12:54 <Arney> Kaidelong is that a solution to my problem? im sorry I cant tell.
00:13:06 <dobblego> it almost is
00:13:20 <edwardk> arney: its a bit tongue in cheek, and not at all what your instructor is looking for
00:13:35 <edwardk> its one of those examples where if you turn it in you'd better be able to explain it, or you'll be called out =P
00:13:44 <fabjan> You instructor probably wants you to write the recursion explicitly as well
00:14:21 <Axman6> Arney: why are you refusing to go and learn haskell? :(
00:14:47 <Axman6> just read LYAH, it'll take maybe an hour for you to get the answer you need, as well as all the understanding you need for your course hopefully
00:15:01 <Kaidelong> edwardk: Actually, I did disconnect
00:15:04 <Arney> Im not at all... I read the entire functions and recursion section of learn you a haskell... the functions section 3 times over... I frankly think that what im being asked t odo is impossible
00:15:24 <Kaidelong> edwardk: Linux reloaded my network adapter firmware and everything
00:15:27 <dobblego> Arney, it definitely is not impossible; it is trivial for everyone in this channel
00:15:41 <dobblego> Arney, that's why we are pushing you a little to try it out
00:15:48 <Arney> Ive been in a solaris lab since 10+ hours ago... went to eat for an hour
00:16:13 <exDM69> I feel sorry for you
00:16:21 <fabjan> Can you write a function tha lower cases a whole string?
00:16:27 <Arney> 100%
00:16:55 <dobblego> how does it look?
00:17:13 <Arney> http://pastebin.com/aqD5dynP
00:17:18 <Axman6> Arney: obviously it's not, since we all think it's trivial
00:17:33 <dobblego> Arney, that doesn't handle the empty case
00:17:46 <Arney> right.. thats on the upper line
00:18:14 <Kaidelong> > map toLower "SHOUTING"
00:18:15 <lambdabot>   "shouting"
00:18:24 <Arney> http://pastebin.com/cYAvg3WX
00:18:45 <Axman6> Arney: do you understand that lists in haskell are just linked lists?
00:18:50 <dobblego> Arney, ok, why did you check if the first isUpper and if so toLower it? seems redundant?
00:18:51 <Arney> dobblego, my problem is that I cannot tell the beginning of the recursion from the middle
00:18:53 * hackagebot json2 0.2 - This library provides support for JSON.  http://hackage.haskell.org/package/json2-0.2 (YuriyIskra)
00:18:59 <fabjan> Arney: all will be rebound every call
00:19:21 <fabjan> so c will always be head all
00:19:28 <quuuux> @pf (\ k f -> list (\ h t -> (f h):(k f t)))
00:19:28 <lambdabot> Maybe you meant: bf pl
00:19:32 <quuuux> @pl (\ k f -> list (\ h t -> (f h):(k f t)))
00:19:32 <lambdabot> (list .) . liftM2 flip (((.) . (:)) .)
00:20:25 <Arney> dobblego: yes, it is. In fact that makes everything upper case. I cant find a way to polarize the head from the tail with recursion
00:20:26 <fabjan> Arney: right, there is no difference between the beginning ang the middle of the recursion
00:20:48 <dobblego> Arney, (c:cs) <-- c is head and cs is tail
00:20:50 <fabjan> if you had access to a for loop, would you check each element in the loop to see if it is the first element?
00:21:13 <Arney> fabjan: exactly what I had in mind....
00:21:19 <fabjan> you know you will only see the first element once and then never again
00:23:06 <fabjan> note that in your template, you have two functions
00:23:10 <fabjan> capitalize and capitalize'
00:23:50 <Kaidelong> @src map
00:23:50 <lambdabot> map _ []     = []
00:23:51 <lambdabot> map f (x:xs) = f x : map f xs
00:23:58 <fabjan> your instructor is hinting to you that you will need to have a function called capitalize' that will help you write capitalize
00:24:17 <Arney> fabjan: yes the first is with comprehension, which I was able to do
00:24:29 <Arney> the second must be accomplished with recursion
00:24:48 <exDM69> Arney: to make it tail recursive, hold the accumulator string reversed and correct it in the end
00:24:48 <fabjan> oh, there are instructions outside of that file
00:25:01 <Arney> OMG!
00:25:32 <Arney> exDM69: genious, your first part of the sentence tipped me to the end.
00:25:46 <Arney> exDM69: thanks a bunch.
00:25:50 <Arney> Thank you all!
00:25:55 <exDM69> that gives linear complexity instead of quadratic which comes when you append to the end on each recursion
00:26:17 <exDM69> Arney: prolog made me learn tail recursion the hard way
00:26:49 <Arney> the answer was that in recursion you cant distinguish the head from the tail, but you can distinguish the last from the init
00:27:04 <Randroid> Prolog is one of the few languages I haven't yet investigated.
00:27:48 <exDM69> Randroid: actually I learned logic programming from SICP's lisp based logic programming language
00:28:03 <fabjan> exDM69: capitalize can still be linear even if it's not tail recursive, it'll just use more memory
00:28:21 <fabjan> you have to refrain from appending though :)
00:28:27 <dobblego> it won't use more memory
00:28:31 <exDM69> prolog is pretty neat too, more practical than the lisp based
00:28:58 <fabjan> dobblego: due to laziness?
00:29:02 <dobblego> yes
00:29:06 <exDM69> fabjan: exactly, the idea of tail recursion is to use less space
00:29:17 <Randroid> exDM69: The whole logic programming is an area I haven't investigated. I'm pretty good with Haskell, Oz, J, Dylan, REBOL, and a host of other exotics of various paradigms, but haven't done a logic programming language. I'd say I'm due. :)
00:29:30 <Kaidelong> tail recursion can be weird in haskell
00:29:35 <dobblego> exDM69, tail recursion is inappropriate here
00:29:56 <Kaidelong> @src map
00:29:57 <lambdabot> map _ []     = []
00:29:57 <lambdabot> map f (x:xs) = f x : map f xs
00:30:03 <Kaidelong> no tail recursion
00:30:09 <Kaidelong> yet this runs in constant space
00:30:17 <Kaidelong> (well maybe)
00:30:56 <fabjan> will it not have to keep a lot of cons and f thunks while evaulating?
00:30:58 * hackagebot json2 0.2.1 - This library provides support for JSON.  http://hackage.haskell.org/package/json2-0.2.1 (YuriyIskra)
00:31:06 <fabjan> laziness always has me fooled :(
00:31:10 <levifikri> Hi, I'm newbie in IRC. I'm trying to running nested data parallelism in Haskell. Could someone help me, which version of GHC supports NDP?
00:31:24 <dobblego> > head $ map (+1) [1..] 
00:31:25 <lambdabot>   2
00:31:48 <Kaidelong> levifikri: try Glasgow Parallel Haskell if you don't mind something more experimental
00:31:55 <fabjan> > sum $ map (+1) [1..]
00:31:58 <Kaidelong> NDP is somewhat of a new thing still
00:31:59 <lambdabot>   mueval-core: Time limit exceeded
00:32:16 <Kaidelong> if you're fine with task parallelism, that works too
00:32:21 <Kaidelong> fabjan: what were you expecting
00:32:26 <fabjan> Kaidelong: that :P
00:32:32 <Kaidelong> sum [2..] == _|_
00:32:37 <dobblego> sum is "tail recursive"
00:33:00 <Kaidelong> > sum $ map (+1) [1..11111]
00:33:03 <lambdabot>   61743827
00:33:23 <dobblego> > sum . take 10 $ map (1+) [1..]
00:33:27 <lambdabot>   mueval-core: Time limit exceeded
00:33:44 <Kaidelong> fascinating
00:33:47 <dobblego> lambdabot is broke
00:33:56 <levifikri> Kaidelong a school project requires me to try NDP in Haskell. I tried http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell, but it failed when compiling
00:34:13 <levifikri> error message: Unsupported extension: ParallelArrays
00:34:17 <quuuux> dobblego: you scared me for a minute there
00:34:27 <levifikri> I'm using GHC 6.12.3
00:34:31 <Kaidelong> levifikri: I'm questioning the wisdom of that assignment
00:34:35 <Kaidelong> oh
00:34:43 <Kaidelong> I don't think DPH works with 6.12 yet
00:34:47 <Kaidelong> Let me look
00:35:15 <Kaidelong> oh
00:36:23 <Kaidelong> levifikri: you'll need GHC 7 for that it seems.
00:36:32 <Kaidelong> Did your professor get it working?
00:37:00 <levifikri> no, he asked me to figure it out :s
00:37:10 <levifikri> hmm ok let me try GHC 7 first
00:37:16 <levifikri> thx! :)
00:37:53 <Kaidelong> AFAIK NDP is not quite ready yet
00:38:05 <Kaidelong> but advanced enough to use
00:38:20 <Kaidelong> I've only worked with task parallelism
00:39:13 <levifikri> Kaidelong task parallelism? I haven't heard about that before. Could you send me a link about that?
00:39:42 <Kaidelong> http://en.wikipedia.org/wiki/Task_parallelism
00:40:21 <Kaidelong> in haskell, with par and pseq
00:40:39 <levifikri> oh that one
00:55:39 <Axman6> levifikri: i believe that the NDP stuff does 'work' with 6.12 fine, i believe i've used it in the past to play with
00:55:59 <Axman6> levifikri: try ghc -XPArr
00:56:23 <Axman6> that turns on parallel arrays (it may have been renamed to ParallelArrays in GHC7)
01:02:18 <levifikri> I used ghc -c -Odph MatrixDotProductNDP.hs  to compile on 6.12.3
01:02:45 <Axman6> maybe -Odph implies -XPArr
01:06:11 <levifikri> oh, it does compile with ghc -c -XPArr -XParallelListComp MatrixDotProductNDP.hs 
01:06:44 <Axman6> you shouldn't need the parallel list comprehensions should you?
01:07:03 <levifikri> hmm, I used it in the code: sumP [:x * y | x <- xs | y <- ys:]
01:07:20 <Axman6> isn't that part of the PArr syntax?
01:08:01 <levifikri> when I compile with XPArr only, the compiler complained: "Illegal parallel list comprehension: use -XParallelListComp"
01:08:35 <Axman6> huh, odd
01:08:42 <Axman6> i thought that was part of its syntax
01:30:34 <glehel> quick question: if writing a paper/thesis/similar and you're the only author, do you say "we" or "I"?
01:30:52 <glehel> I don't recall reading a paper which said "I", but then maybe I've never read any single-author papers
01:31:26 <ion> I can only speak for ourself, but we don’t know.
01:31:28 <quicksilver> glehel: it's traditional to say 'we'
01:31:42 <quicksilver> I've always taken it to include the reader, personally
01:31:51 <quicksilver> "We combine the two lemmas to show that..."
01:31:58 <quicksilver> includes the reader in the proof process, very cosy.
01:31:59 <glehel> quicksilver: yeah, that's what I suspected, just wasn't sure... thanks :)
01:33:36 <Jafet> Daniel Bernstein uses "I" throughout. But he's sort of a maverick.
01:33:48 <Axman6> as in DJB?
01:33:57 <Jafet> Is there another?
01:34:25 <Axman6> there's properly hundreds, but i only really know the guy as djb
01:43:19 <edwardk> djb is a little crazy
01:44:50 <edwardk> glehel: one justification for using 'we' is to include the reader. this works best if you are walking through the material and referring to 'we' consistently in a fashion where you can say things like 'we'll defer  considering blah blah blah'
01:45:12 <edwardk> hah just saw quicksilver's reply
01:45:58 <Jafet> You can always write a paper entirely in the passive voice
01:46:12 <glehel> edwardk: yeah, makes sense :)
01:46:39 <ion> How about entirely in third person? :-)
01:46:52 <edwardk> jafet: i prefer not to tie my hands.  the result of using the passive voice throughout is that the paper reads terribly. plus you can get dinged for using a passive voice by some thesis guidelines
01:47:06 <mux> I think I've seen papers where the author does that; saying stuff like "The author thinks that..."
01:47:06 <edwardk> it just feels like you are afraid to commit to anything
01:48:03 <Jafet> mux: that is actually common in papers that use "we", because that pronoun is so vague
01:48:13 <Jafet> (or as quicksilver would say, too cosy)
01:48:19 <edwardk> heh
01:49:51 <quicksilver> edwardk: if your thesis doesn't read terribly, then it will probably be rejected for style reasons.
01:50:04 <quicksilver> edwardk: terrible reading is inseperable from academic core values.
01:50:08 <edwardk> quicksilver: =)
01:50:30 <Jafet> "If it was hard to write..."
01:50:31 <edwardk> quicksilver: the thesis guidelines i was stuck using actually required you _not_ to use passive voice.
01:51:14 <quicksilver> edwardk: certainly overuse of it can be horrible.
01:51:37 <quicksilver> but, it has it's place.
01:51:42 <quicksilver> its place.
01:51:47 <quicksilver> damn apostrophe's.
01:51:56 <digitteknohippie> oh cooooool! vacuum visualise haskell data structures. http://www.youtube.com/watch?v=X4-212uMgy8 http://www.youtube.com/watch?v=nQkhELdAYB8 
01:52:28 <edwardk> digitteknohippie: vacuum is really fun
01:52:47 <katja> could someine help we with haskell?
01:52:50 <quicksilver> although I have concerns that becoming too involved in vacuum may cause you to disappear.
01:52:58 <digitteknohippie> flux looks fun too.  http://www.youtube.com/watch?v=4vo0yK7P8-s&NR=1
01:53:05 <quicksilver> katja: certainly, but not until you ask a question :)
01:53:21 <digitteknohippie> i knew i shoulda just stuck to trying to learn haskell from youtube videos.  lol.   (jk.)
01:53:34 <flux> I recent that statement.
01:53:39 <Maxdamantus> !8ball Could someone be helped about Haskell on a Haskell channel?
01:53:43 <katja> quicksilver: I dont get why it diesnt work http://codepad.org/ebLwuRFr
01:54:18 <ivanm> katja: what's the error?
01:54:30 <quicksilver> katja: is there an error? or does it just not do what you expected?
01:54:35 <ivanm> katja: you should remove the Ord constraint from your definition of BinTree
01:55:08 <ivanm> also, isSearchTree = flip element ?
01:55:46 <katja> ivanm: sorry?
01:56:08 <ivanm> katja: what's your error in that code that you say it doesn't work?
01:56:19 <mux> katja: small nit: instead of comparing for equality with (==) and then comparing with (<), I'd just use compare
01:56:38 <mux> this way you avoid one unnecessary comparison
01:56:46 <katja> ivanm: rror occurred ERROR - Undefined variable "main"
01:56:53 <ivanm> katja: that's just codepad
01:57:02 <ivanm> your code isn't a program
01:57:05 <ivanm> so it can't run it
01:57:15 <ivanm> (which is one reason why I don't like codepad)
01:57:40 <katja> ivanm: oh. so in haskell it should work, yeah?
01:57:54 <ivanm> yeah
02:01:41 <katja> ivanm: and I have one more question. I need to make BinTree class an instance for Eq class, when subTrees were mixed, after flipoperation
02:01:55 <katja> ivanm: http://codepad.org/e4zPUrOi is that right?
02:02:19 <ivanm> katja: that will _only_ make them equal if they are flipped
02:02:23 <ivanm> katja: is this homework?
02:02:24 <edwardk> yo ivanm: decided to actually proceed with that graph lib
02:02:31 <ivanm> edwardk: \o/
02:02:34 <ivanm> what convinced you?
02:02:45 <ivanm> katja: also, don't indent more like you have
02:02:55 <ivanm> all top-level declarations need to have the same indentation level
02:02:56 <edwardk> ivanm: when i realized i could shuffle some things around and switch from a comonad to a monad
02:03:02 <ivanm> edwardk: :o
02:03:10 <ivanm> how?
02:03:37 <edwardk> ivanm: a cokleisli arrow for the environment comonad is the same as a kleisli arrow for the reader monad
02:03:38 <katja> ivanm: yeah. is should make them equal, i guess. yeah. it is a homework
02:04:00 <edwardk> once i flip that around the api looks a lot like the boost graph library
02:04:02 <ivanm> katja: it's polite to say up-front that problems are homework; that way we know not to give you answers, etc. but just to help you
02:04:14 <ivanm> edwardk: what's kleisli and cokleisli again?
02:04:17 <edwardk> and it leads to immediate generalization that allows things like huge graphs that require io to fetch portions, etc.
02:04:26 <edwardk> kleisli = a -> m b, cokleisli = w a -> b
02:04:52 <edwardk> a -> e -> b   and (e, a) -> b   are isomorphic
02:05:23 <edwardk> so i translated everything from explicit comonads, to explicit reader monads, then factored out the monad and made the monad into the graph
02:05:23 <katja> ivanm: m. ok. but still I didnt ask for answers. I aksed if all my writings are true, so I suggested my answers already and I dont know if they are right
02:05:30 <ivanm> how do those type sigs work?
02:05:31 <quuuux> katja: for just testing that your program compiles, you can load it in ghci. Then you can play around with it interactively
02:05:39 <ivanm> katja: right, I'm just saying that in future
02:05:51 <ivanm> *that in future you should state so
02:05:56 <quuuux> katja: that way you don't need any `main' function
02:06:08 <ivanm> I believe it's the policy here, if I can remember where the policy is written down...
02:06:20 <edwardk> ivanm: i recommend looking and Control.Arrow which provides Kleisli and Control.Comonad in the comonad package which provides Cokleisli
02:06:32 <ivanm> edwardk: *nod*
02:06:53 <edwardk> but the short answer is my graphs now look like
02:07:16 <Axman6> katja: letting people know it is homework is still a good thing to do
02:07:18 <edwardk> class (Monad g, Eq (Vertex g)) => Graph g where type Vertex g; type Edge g; vertexMap :: … 
02:07:24 <dobblego> cokleisli and kleisli are words that you use to scare java/scala guys
02:07:37 <katja> ivanm: pk. thanks. I will do that. so, did I make BinTree an instance to class Eq after flipoperation , so that those two trees are the same
02:07:54 <ivanm> edwardk: if you read the fun with type families paper, you'll realise that you can't use type families for Edge ;-)
02:07:59 <edwardk> and then, class Graph g => AdjacencyGraph g where adjacentVertices :: Vertex g -> g [Vertex g] — lets you extract the adjacent vertices from a vertex
02:08:03 <katja> Axman6: I git it already, thanks
02:08:10 <ivanm> katja: unless you changed your definition, it will _only_ work for flipped ones
02:08:23 <edwardk> ivanm: i can here because of the way i plumb all my actions wth 'g'
02:08:35 <katja> ivanm: yeah. it should wotk only for them.
02:08:39 <edwardk> type families are _exactly_ what i want for this version
02:08:46 <edwardk> it doesn't work for something fgl style
02:08:47 <ivanm> edwardk: hmmmmm.... you sure?
02:08:51 <edwardk> it works for this 'mgl
02:08:53 <edwardk>  style
02:08:56 <edwardk> yes
02:09:06 <ivanm> because the paper didn't use FGL graphs
02:09:10 <ivanm> it used rather generic graphs
02:09:16 <edwardk> keep in mind unlike you my vertices and edges contain no data
02:09:21 <ivanm> :o
02:09:32 <ivanm> edwardk: do you actually have any code anywhere?
02:09:37 <edwardk> i build external vertex maps, etc. just like my comonadic graph lib
02:09:41 <edwardk> it'll come soon enough =)
02:09:44 <Arney> http://pastebin.com/4sP400yz couldnt match char against string?
02:09:57 <edwardk> i was working on it when i saw you come online
02:10:21 <ivanm> ahhh, k
02:10:30 <ion> arney: In a:b, b must be a list.
02:10:53 <Arney> that sounds a little un intuitive
02:10:58 <ivanm> Arney: "length cs == 1" is _bad_
02:11:02 <ivanm> @type (:)
02:11:05 <Arney> but ok, I can work with that
02:11:05 <lambdabot> forall a. a -> [a] -> [a]
02:11:07 <ivanm> Arney: ^^
02:11:12 <ivanm> how is it unintuitive?
02:11:16 <ivanm> (:) = cons
02:11:19 <ivanm> not snoc
02:11:40 <Arney> cons actually stands for something?
02:11:48 <ion> Think of x:xs as “prepend x to xs”.
02:12:27 <Arney> ivanm: is there an operator symble for snoc?
02:12:33 <ivanm> Arney: ++ [c]
02:12:42 <ion> http://en.wikipedia.org/wiki/Cons
02:13:00 <Arney> Couldn't match expected type `[Char]' against inferred type `Char'
02:13:45 <Arney> ivanm: switching it out for ++ gives that error, which truelly bafles me
02:13:50 <katja> ivanm: http://codepad.org/9DMcIe9P and this one as well. is it right? when two trees t1 and t2 are quel when they are after flipoperation should be identic
02:14:02 <ivanm> Arney: did you put [c] or just c ?
02:14:23 <ivanm> katja: you still shouldn't indent the instance line ;-)
02:14:29 <Arney> dont scream at me alright... im just a newb. :)
02:14:40 <ivanm> and no, that isn't right: you can't do == on BinTree, since it's a type
02:14:45 <ivanm> Arney: who's screaming?
02:14:46 <katja> ivanm: why then&
02:14:47 <ion> Who is screaming at you?
02:15:04 <ivanm> katja: why what?
02:15:14 <Arney> id think the smilie would have denoted the sarcasm.
02:15:31 <katja> ivanm: why should not I ident then instance line
02:15:47 <ivanm> katja: all top-level statements should be indented the same amount
02:15:56 <ivanm> Arney: ":)" is for humour, not sarcasm
02:15:58 <ivanm> ;-)
02:16:32 <katja> ivanm: my god. I dont understand you
02:17:13 <ivanm> katja: what don't you understand?
02:17:25 <ivanm> you need to have the "data" and the "instance" at the same indentation level
02:17:39 <ivanm> indenting something further denotes that it is a sub-part of the previous statement
02:17:56 <ivanm> since the instance is separate from the data definition, it shouldn't be indented any futher
02:18:31 <ivanm> kapish?
02:19:03 <katja> ivanm: http://codepad.org/85in3szZ do you mean like this?
02:19:11 <cubi> katja: haskell is not like C/java/.. proper indentation is required
02:19:23 <ivanm> katja: no
02:19:38 <ivanm> and you can't have "BinTree t1 == BinTree t2" either; saying that doesn't make sense
02:19:51 <ivanm> katja: you need to start a new line for the instance
02:20:47 <hannes__> whats the site called again where you can upload your code for others to see?
02:20:48 <katja> ivanm: http://codepad.org/KDtjjV3L this way?
02:20:51 <hannes__> nvm
02:20:57 <cubi> hpaste.org?
02:21:03 <cubi> k
02:21:04 <ivanm> katja: http://codepad.org/PBBejSpw
02:21:35 <edwardk> ivanm: https://github.com/ekmett/graphs/tree/master/Data/Graph should get you started
02:21:41 <edwardk> thats the gist of what i'm working on
02:21:53 <edwardk> note Data.Graph.Class.Adjacency and Data.Graph.Algorithm.Dfs
02:22:02 <katja> ivanm: hm.. I had almost the same. is it so important to wrote it that way>?
02:22:10 <hannes__> Hello guys, im having trouble with my code as the site indicates and cant figure out why theres a syntax error. could someone please help me out? http://codepad.org/DWHz6oHp
02:22:11 <ivanm> yes
02:22:31 <ivanm> hannes__: indentation
02:22:38 <Arney> Im getting my reverse recursion result backwards :(
02:22:42 <ivanm> don't indent the _ == _ line further than the previous line
02:23:03 <hannes__> ill try that, thanks
02:23:04 <ion> arney: You’re probably using snoc where you should be using cons.
02:23:26 <ion> arney: That is, you might have xs++[x] where you’ll want x:xs.
02:23:36 <Arney> ion: I dont know how to use snoc
02:23:45 <cubi> katja: 11:25 < cubi> katja: haskell is not like C/java/.. proper indentation is required
02:23:48 <cubi> ;)
02:24:07 <katja> cubi: ok. thanks
02:24:08 <ivanm> edwardk: where do the "Vertex" and "Edge" definitions come from?
02:24:31 <Arney> aaah apparently I do know how
02:24:38 <cubi> @where lyah
02:24:39 <lambdabot> http://www.learnyouahaskell.com/
02:24:44 <cubi> should explain it
02:24:56 <Arney> cubi it never calls it snoc
02:25:03 <edwardk> ivanm: particular graph instances.
02:25:07 <Arney> which is the source of the confusion
02:25:14 <cubi> Arney: pardon me?
02:25:33 <edwardk> ivanm: you pushed for code, so i put up code ;)
02:25:39 <Arney> it does say that : is cons, but it never says what snoc is called
02:25:52 <ion> snoc is just the reverse of cons.
02:25:56 <Arney> even though it clearly describes it
02:25:59 <ion> > reverse "cons"
02:25:59 <lambdabot>   "snoc"
02:26:00 <Axman6> Arney: it's a fairly common name, it's just cons backwards
02:26:19 <edwardk> ivanm: an example might be building a Graph instance for ((->) Array Int [Int]) — though that'd be a special case of a more complicated signature
02:26:24 <ivanm> edwardk: huh? I thought associated types couldn't create new constructors, types, etc.
02:26:30 <edwardk> they aren't
02:26:48 * Axman6 - home
02:26:56 <ivanm> so for the Strict.StateT isntance, it has "type Vertex g = Vertex g"; where is that RHS Vertex coming from?
02:27:01 <ivanm> Axman6: oh, back from tokyo?
02:27:19 <edwardk> ivanm: is type Vertex (StateT s g) = Vertex g
02:27:23 <edwardk> its taking it from the underlying monad
02:27:36 <edwardk> its saying that if you state transform a graph monad you don't change its vertex type
02:27:50 <Axman6> ivanm: no, i'm going back to my apartment ;)
02:27:55 <ivanm> edwardk: gah, missed that
02:27:59 * ivanm facepalms
02:28:01 <edwardk> ivanm: consider the following straw man
02:28:51 <edwardk> instance Ix i => Graph ((->) (Array i [i])) where type Vertex ((->) (Array i [i])) = i; type Edge (…) = (i, i)
02:28:52 <hannes__> hm, i fixed the indentation error but got a new one. http://codepad.org/I7rOaWPh
02:29:11 <Arney> capitalize' (c:cs) is there any way to alter that patern to give me the last first and so on?
02:29:21 <edwardk> (er instance (Ix i, Ord i) => … so that vertexMap = propertyMap can be used
02:29:38 <edwardk> the adjacencyGraph instance is easy to define, then dfs can search on it
02:29:45 <edwardk> i haven't build all the instances yet
02:30:23 <ivanm> yeah, I just mis-read those lines, that's all
02:31:23 <ivanm> edwardk: so is vertexMap just an example so far to show how to specify to get all vertices, etc.?
02:31:24 <edwardk> note that unlike fgl most of this library doesn't care about manipulating the shape of the graph (in fact none of the combinators i offer so far allow you to add an edge, etc. but this provides me the invariant than for any graph g. a 'Vertex g' that was created through my methods, _is_ a member of the graph.
02:31:45 <edwardk> ivanm: no, a vertexmap is a way of associating a value with every member of a graph. i use it in dfs
02:32:01 <edwardk> i need a VertexMap g Color to track visited nodes
02:32:17 <ivanm> so will this technique eventually allow you to query or manipulate the graph?
02:32:25 <ivanm> or is it just goign to be useful for doing DFS? :p
02:32:42 <edwardk> query is done through AdjacencyGraph or IncidenceGraph or BidirectionalGraph or AdjacencyMatrix, etc.
02:32:48 <edwardk> those add more structure
02:32:52 <edwardk> Graph is pretty minimalist
02:33:14 <edwardk> then tagged variations will allow you to write algorithms that are polymorphic in the graph structure and which optimize based on available features
02:33:17 <edwardk> but thats later
02:33:40 <edwardk> note that for instance dfs requires an AdjacencyGraph
02:33:52 <edwardk> Edge will probably move out to IncidenceGraph
02:34:13 <edwardk> or to a common superclass of AdjacencyMatrix and IncidenceGraph
02:34:22 <edwardk> (AdjacencyMatrix isn't in that repo)
02:34:29 <hannes__> could someone help me with my code please? http://codepad.org/I7rOaWPh i dont understand why theres an ambiguous variable
02:35:03 <ivanm> edwardk: so you're splitting the structures up much more finely than I'm planning on doing
02:35:09 <edwardk> yes
02:35:16 <ivanm> but I take it your approach will _only_ work with graphs that are monads?
02:35:34 <ivanm> hannes__: there's an ambiguous occurrence of ==, not an ambiguous variable
02:35:45 <ivanm> you've now unindented the last line too much ;-)
02:35:51 <hannes__> fasdfadf
02:35:59 <edwardk> the 'graph is a monad' is a simplification. the 'Graph' as the environment for some reader monad lets you use it for any of your kind of monads
02:36:03 * ivanm wonders how these newbies are learning Haskell that they're not learning layout rules properly
02:36:09 <edwardk> thats how this transitioned from a comonad to a monad
02:36:14 <ivanm> edwardk: *nod*
02:36:20 <edwardk> the graph was the environment in my comonad
02:36:31 <ivanm> so will your approach ever work/be useful for a more "normal" Map-based graph, etc.?
02:36:37 <edwardk> i just generalized this so i can have actual monadic side effects
02:36:41 <edwardk> yes
02:36:56 <edwardk> those will just be instances provided by Data.Graph.Adjacency, etc.
02:37:10 <edwardk> just need to change perspective and it'll make sense =P
02:37:12 <Arney> I cant believe there is no way to reverse a pattern match... capitalize' (c:cs) to capitalize' (c:reverse cs)
02:37:16 <ivanm> but how will they be instances of Graph itself since they don't have a monadic component?
02:37:25 <ivanm> Arney: huh?
02:37:30 <edwardk> i'm going back to implementing because that seems to serve as a much better explanation than irc ;)
02:37:51 <ivanm> Arney: you can't apply a function within a pattern match (especially now that n+k patterns have been removed)
02:37:54 <edwardk> (->) WhatYouAreThinkingOfAsAGraph will be my Graph instance
02:38:03 <ivanm> edwardk: ooohhhh.....
02:38:06 * ivanm waits
02:38:10 <hannes__> ivanm: how much do i have to indent it?
02:38:21 <ivanm> edwardk: or how about you let me know when you've got it in a reasonable state instead of teasing me? :p
02:38:28 <ivanm> hannes__: the same as the one before
02:38:50 <edwardk> all of the pieces are there, you just need to figure out how it gets put together ;)
02:38:57 <hannes__> http://codepad.org/GHe4hNgl and a new error..
02:39:19 <ivanm> hannes__: very simplistically: more indent == this is a sub-part of the previous line; same indent == this is in parallel/same level as the previous line; less indent == this is a higher/more important statement than the previous line
02:39:22 <Arney> ivanm: http://pastebin.com/aNbqNGub all I need is to reverse the input
02:39:41 <hannes__> ivanm: thx
02:39:48 <ivanm> hannes__: you need: "instance (Eq a) => (GenBinTree a) where ..."
02:40:03 <ivanm> hannes__: is this the same homework that katja is doing?
02:40:35 <hannes__> ivanm: http://codepad.org/DOpX58JB
02:40:45 <ivanm> Arney: http://pastebin.com/DBm1q1CC
02:40:56 <hannes__> wait
02:41:00 <ivanm> Arney: however, your first guard is better off done with an explicit singleton pattern-match
02:41:14 <Arney> why didnt I think of that
02:41:16 <ivanm> you should never use length if you have a fixed, finite length that you're comparing it to
02:42:02 <ivanm> Arney: I don't know, why didn't you? :p
02:42:02 <hannes__> ivanm: hmm possible since im working on a task for the university, yet i dont know katja
02:42:36 <ivanm> your IPs are both at fu-berlin.de
02:42:41 <ivanm> so it's likely ;-)
02:42:48 <hannes__> ah, must be a collegue then
02:42:52 <ivanm> hannes__: next time, you should state up-front that you're working on homework
02:43:01 <ivanm> (as opposed to trying to work something out yourself)
02:43:02 <Arney> how do I esplicitly patern match a singleton? I know how to do it in a case statement
02:43:17 <hannes__> why?
02:44:08 <hannes__> still got an error, hm
02:44:27 <ivanm> Arney: foo [x] = ...
02:44:48 <ivanm> hannes__: because if it's homework, we shouldn't give you answers up-front but instead help you work out what's wrong
02:45:18 <Arney> oooh, i get what your saying.
02:45:51 <hannes__> ah there shes gone
02:46:55 <hannes__> ivanm: http://codepad.org/fzP8dsdv is still reporting an error. it seems like he doesnt like my (   ) 
02:47:20 <ivanm> hannes__: 1) remove the (Ord a) from the data declaration
02:47:33 <ivanm> if it's your professor telling you to do that (since katja was doing it as well), they should be shot
02:47:42 <Bynbo7> ivanm: i propose we add this to the topic: "We'll solve your homework! Just let us know!"
02:47:49 <ivanm> 2) you're not saying which class you're making an instance of now ;-)
02:47:53 <ivanm> Bynbo7: heh
02:48:06 <hannes__> heh why should our professor be shot?
02:48:16 <ivanm> Bynbo7: looking forward to telling people off from COMP1100 for asking homework questions here :p
02:48:32 <ivanm> hannes__: because putting constraints in data definitions doesn't do what you want, just makes it more annoying to use
02:48:43 <Bynbo7> hannes__: adding class constraints is not a good thing to do, ebcause it infects all functions that use those type
02:48:51 <hannes__> ok, thanks
02:49:44 <Bynbo7> you'll notice that Data.Set has no Ord constraint, though it might make sense to do so. the Ord constraint is enforced by the functions you use on Sets that need Ord, and by hading the definition of Set
02:49:59 <Bynbo7> ivanm: have you spoken to Clem yet?
02:50:08 <hannes__> im still having the same error or should i remove even more? http://codepad.org/xbhVdTUI
02:50:13 <ivanm> Bynbo7: nah, I'll send him an email next week
02:50:20 <Bynbo7> ok.
02:50:28 <Bynbo7> can you remember to mention me too? =)
02:50:35 <HugoDaniel> what function can i use to replace this: foldr (++) "" s  ?
02:50:38 <ivanm> hannes__: more specifically: note that despite having the Ord in your data definition, you still need the Ord constraint in all functions that use that data type
02:50:41 <ivanm> hence it's useless
02:50:47 <ivanm> Bynbo7: I'll consider it :p
02:50:53 <Bynbo7> :P
02:50:55 <ivanm> HugoDaniel: concatMap or something?
02:50:57 <Bynbo7> thanks :P
02:50:58 <lunaris> HugoDaniel: concat?
02:50:58 <ivanm> @type foldr (++) ""
02:51:00 <lambdabot> [[Char]] -> [Char]
02:51:04 <ivanm> oh, right, just concat
02:51:17 <hannes__> ivanm: ah i see
02:51:18 <HugoDaniel> ah cool yes
02:51:19 <lunaris> concat = foldr (++) [], right?
02:51:28 <ivanm> @src concat
02:51:28 <HugoDaniel> @type concat
02:51:28 <lambdabot> concat = foldr (++) []
02:51:29 <lambdabot> forall a. [[a]] -> [a]
02:51:40 <lunaris> Indeed.
02:57:34 * hackagebot antlrc 0.0.2 - Haskell binding to the ANTLR parser generator C runtime library.  http://hackage.haskell.org/package/antlrc-0.0.2 (MarkWright)
02:58:06 <hannes__> when i remove '(' and ')' in line 3, he tells me that GenBinTree is an undeclared class. why then do i get syntax errors leaving the brackets as is? http://codepad.org/4bFdoP1s
02:59:09 <quicksilver> because it is illegal to have a ( there?
02:59:16 <quicksilver> not quite sure what answer you're expecting...
03:01:02 <ivanm> quicksilver: he's missing the Eq
03:01:15 <quicksilver> I know.
03:01:25 <quicksilver> but that wasn't what he asked :)
03:01:25 <hannes__> what do you mean, im missing the Eq?
03:01:34 <quicksilver> you want to say that GenBinTree is an instance of Eq
03:01:37 <quicksilver> the syntax for that is 
03:01:42 <quicksilver> Eq a => Eq (GenBinTree a)
03:02:35 <hannes__> undefined variable "main"
03:02:42 <Arney> ivanm: Your trick doesnt work with recursion, since it flips the order on every try. thus "Yu-Gi-Oh!" to "I-go-hu!y"
03:02:53 <ivanm> hannes__: *sigh* yes, codepad is assuming your code is a program, but it isn't
03:03:04 <ivanm> Arney: huh?
03:03:13 <ivanm> Arney: in that case, fix your code up! ;-)
03:03:27 <Arney> lol
03:03:57 <Arney> were back to where we started then... how do you reverse pattern match
03:04:13 <ivanm> what do you mean by "reverse pattern match"?
03:04:26 <Zao> hannes__: Are you referring to whatever gibberish that codepad might emit, or genuine errors on your local platform?
03:04:49 <hannes__> zao: i meant codepads response, seems like ivan already answered it
03:04:53 <Arney> Im having a ureka moment with case statements
03:05:10 <Bynbo7> :\
03:05:22 <Bynbo7> case statements are just pattern matching
03:05:32 <ivanm> Zao: former
03:05:40 <ivanm> Bynbo7: other way round! ;-)
03:05:49 <Bynbo7> shhh
03:05:51 <ivanm> don't pattern matchings get desugared to case statements?
03:06:04 <Bynbo7> well, it gets compiled into case statements anyway
03:07:32 <quicksilver> it sounds like we're being pedantic.
03:07:41 <quicksilver> If we're being pedantic, then core case != haskell case
03:07:44 <quicksilver> different semantics.
03:07:45 <ivanm> quicksilver: *It
03:07:46 <ivanm> :p
03:07:54 <Bynbo7> hmm, i should write a program like axel in haskell using iteratees
03:08:34 <hannes__> thank you guys, its working
03:09:27 <nomemory> hello, what's the haskell approach when we need a matrix data-structure to resolve a given problem ?
03:09:40 <Bynbo7> possibly hmatrix?
03:09:49 <nomemory> hmatrix ?
03:09:57 <Bynbo7> nomemory: depends how big the matrix is too
03:10:05 <Bynbo7> @hackage hmatrix
03:10:06 <lambdabot> http://hackage.haskell.org/package/hmatrix
03:10:09 <nomemory> 5 x 5
03:10:10 <Arney> my ureka moment didnt work with recursion
03:10:24 <Bynbo7> you could easily use arrays then
03:10:38 <ivanm> or lists of lists
03:10:38 <ivanm> :p
03:10:59 <ivanm> or Map (Int,Int) a
03:11:00 <Bynbo7> yeah, if it's only 5x5, then lists would be fine most likely
03:11:10 <Bynbo7> that's a bit gross imo :P
03:11:19 <ivanm> Bynbo7: yeah, it is...
03:11:41 * ivanm really abused the list-of-lists sudoku solver that bird wrote when he started learning Haskell
03:12:01 * Botje stole that sudoku solver for a project euler program
03:12:09 <Botje> couldn't be arsed to write one
03:12:16 <ivanm> I used it to generate partial latin squares, beat that!
03:12:32 <ivanm> (ended up having too many "optimisations", but oh well...)
03:12:44 <Botje> oh yeah?! mine caused global peace but got stuck in an infinite loop!
03:12:50 <ivanm> heh
03:12:56 <ivanm> afk
03:14:48 <nomemory> Could not find module `Data.Packed.Matrix':
03:14:57 <nomemory> Should I install something additionally ?
03:15:35 <ion> @hoogle Data.Packed.Matrix
03:15:36 <lambdabot> No results found
03:25:39 <Arney> I love you all and thanks for all the fish
03:26:07 <Arney> I was using pattern matching without any need for it
03:27:53 <Arney> ivanm: http://pastebin.com/77Bhw9g7 thanks for the tips
03:31:03 <Bynbo7> that code is horrible :|
03:31:14 <Arney> elaborate?
03:31:19 <dobblego> be nice
03:31:37 <Arney> its my first script, ill take the critizism
03:31:47 <Arney> whats wrong with it?
03:31:48 <Bynbo7> ok, you've played long enough. i would write it as capitalise (x:xs) = toUpper x : map toLower xs; capitalise [] = []
03:32:04 <mauke> Arney: looks pretty inefficient
03:32:47 <Arney> Bynbo7: I was instructed to use recursion
03:33:12 <mauke> so write your own map
03:33:14 <dobblego> Arney, map is recursive
03:33:30 <osfameron> not explicitly
03:33:38 <Arney> your right... perhaps I did more then I had to
03:33:52 <Arney> not sure... ill ask my prof if map couts as recursion
03:33:55 <Bynbo7> anyway, you should be looking at how to write map
03:34:07 <Arney> map is easy
03:34:34 <Arney> capitalize  cs = (toUpper (head cs)) : [toLower c | c <- (tail cs)]
03:34:46 <Arney> thats the code of my non recursive version
03:35:18 <Bynbo7> don't use head and tail when you can pattern match
03:35:21 <mauke> that fails on empty strings
03:35:39 <mauke> [f x | x <- xs] is equivalent to map f xs
03:35:39 <Arney> one line paste geez
03:36:25 <ion> Yeah, map is easy.
03:36:26 <ion> > let map _ [] = []; map f xs = map f (init xs) ++ [f (last xs)] in map (+1) [42..50]
03:36:29 <lambdabot>   [43,44,45,46,47,48,49,50,51]
03:36:31 <ion> ;-)
03:36:46 <mauke> haha
03:36:54 <mauke> THAT'S NOT HOW TAIL RECURSION
03:36:55 <dobblego> I believe his capitalize' function is supposed to do the "map"
03:37:46 <ion> mauke: You accidentally the verb.
03:37:57 <Bynbo7> it's supposed to capitalise the first letter, and make the rest lowercase
03:41:26 <dobblego> chr <$> [108,101,116,32,99,97,112,105,116,97,108,105,122,101,32,91,93,32,61,32,91,93,59,32,99,97,112,105,116,97,108,105,122,101,32,40,104,58,116,41,32,61,32,116,111,85,112,112,101,114,32,104,32,58,32,99,97,112,105,116,97,108,105,122,101,39,32,116,59,32,99,97,112,105,116,97,108,105,122,101,39,32,91,93,32,61,32,91,93,59,32,99,97,112,105,116,97,108,105,122,101,39,32,40,105,58,117,41,32,61,32,116,111,76,111,119,101,114,32,105,32,58,32,99,
03:41:26 <dobblego> 97,112,105,116,97,108,105,122,101,39,32,117]
03:41:29 <dobblego> I believe he wants that
03:41:47 <ion> :-D
03:42:08 * dobblego counts on <$> being an encryption key
03:47:59 <Arney> I cant get quick check to work here (error included) http://pastebin.com/MUmVJVpy
03:48:33 <dobblego> woah, how did QuickCheck come into this?
03:49:06 <Arney> the teacher is in love with it, he wants everyone to use it... the entire assignment is based on it
03:49:56 <Arney> the error output is on line 23, after running quickCheck prop_captalize
03:50:15 <Bynbo7> well, he has a right to be in love with it, it's a great way to test things
03:50:26 <Arney> i dont get what it does
03:50:57 <mauke> autogenerates tests for your functions
03:51:11 <Bynbo7> it produces the tests for you. you specify what the code should do, and it runs hundreds of tests and tells you when the code doesn't do what you said it should
03:51:44 <Arney> sounds vague
03:51:55 <mauke> heh
03:52:00 <Veinor> https://github.com/veinor/nimber/blob/master/Data/Tests.hs
03:52:08 <Veinor> this is quickcheck 2, but the principle is the same
03:52:27 <Veinor> i have a test commutes x y = x * y == y * x
03:52:40 <mauke> <kakazza> Oh, about Haskell. The Austrian Federal Railways want a new ticketing system and an institute of a UNIVERSITY is doing it. So it is written in Haskell, Python and Javascript/BoxHTML on the terminals/web, using git.
03:52:42 <Veinor> and a way of generating random elements of the Num instance that i defined
03:53:14 <Veinor> so quickcheck says 'is commutes 8257 30295 true? okay, what about commutes 3827 27 ?'
03:54:01 <ivanm> Arney: consider this: you state some property of your code; QC will then try to generate tests based upon the types of the inputs
03:54:05 <Arney> why havent I heard about this is other languages like C Java JS PHP Pascal
03:54:17 <ivanm> but the best bit about it is, if it finds an error, it tries to refine the inputs to get a minimal case
03:54:26 <mauke> because it's extremely hard to do in other languages
03:54:26 <ivanm> Arney: there are some for other languages, but they don't work as well
03:54:34 <ivanm> since haskell's purity is a major part of why QC works
03:54:39 <mauke> especially JS/PHP/Pascal
03:54:45 <mauke> er
03:54:58 <mauke> I didn't mean Pascal
03:55:02 <ivanm> heh
03:55:03 <Arney> Ill read the intro parts of learn you a haskell later
03:55:36 <Arney> It is by far the weirdest language ive ever usede
03:59:15 <Arney>     No instance for (Arbitrary Char) -- thats the output of quickcheck, how is that helpful
03:59:44 <ivanm> what? I could have sworn there as an instance for Char
03:59:49 <ivanm> which version of QC are you using?
03:59:50 <mauke> that means it doesn't know how to generate random Chars
03:59:59 <Arney> 1. something
04:00:32 <Arney> that could be it
04:00:43 <Arney> let me try a simpler example on it
04:00:58 <ivanm> why aren't you using version 2?
04:01:11 * ivanm guesses Arney did "cabal install" and got bitten by the preferred_versions problem
04:01:34 * dcoutts_ needs to redefine it so it's not a problem
04:01:37 <Arney> we are in a solaris lab... aparently its hard to update and no one has admin privs exept the guys who dont know solaris... so were screwed
04:02:18 <Arney> mauke: if your hypothesis is correct, the code should run fine on someone elses comp
04:02:28 <dcoutts_> ivan: oh, no, the default QC version is 2, so there should be no expectation/reality mismatch
04:03:00 <ivanm> dcoutts_: huh, I thought someone said something on -cafe recently about this...
04:03:07 <ivanm> unless you've updated it since then :s
04:03:17 <dcoutts_> ivan: yes, I did update it
04:03:30 <dcoutts_> I thought it had been done already, but apparently it had not
04:03:35 <ivanm> huh
04:03:42 <ivanm> anyway, sounds like that's not Arney's problem
04:04:44 <Arney> http://pastebin.com/kxaX8SZZ could anyone run that with quickcheck 2
04:07:05 <gienah> haskell stuff builds on solaris 10 and presumably solaris express, I used to maintain the pkgs when I used to have a solaris machine, they are in: http://pkgbuild.svn.sourceforge.net/viewvc/pkgbuild/spec-files-extra/trunk/  called SFEghc-*.spec
04:07:25 <ivanm> Arney: loads
04:07:38 * ivanm tries to remember how to manually test a QC property
04:07:55 <ivanm> duh, quickCheck <property>
04:08:05 <ivanm> Arney: fails with an empty list... ;-)
04:10:41 <Arney> came error with capitalize "" = "" and capitalize' "" = "" added
04:10:51 <Arney> s/came/same
04:22:29 <Arney> I was checking the class website for support and I found News {- the ``no instance of (Arbitrary Char)'' error If you get this error, then add " -}
04:23:35 <edwardk> ivanm: i added pure adjacency lists and matrices to give you something concrete to hold on to
04:23:36 <Arney> apparently I must tell the possible chars to quickCheck with instance Arbitrary Char where; arbitrary = elements (['A'..'Z'] ++ ['a' .. 'z'] ++ " ~!@#$%^&*()")
04:25:23 <jacobian> Is there a "fair" version of sequence
04:25:42 <jacobian> sequence :: Monad  m => [m a] -> m [a] 
04:26:23 <jacobian> take 8 (sequence [[1,2,3],[1..]])
04:26:36 <edwardk> jacobian: there are variations on the theme in Omega and in LogicT iirc
04:26:40 <jacobian> That never gets to the next answer in the finite sequence.  It's not a space filling curve. 
04:26:41 <sipa> > take 8 (sequence [[1,2,3],[1..]])
04:26:42 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8]]
04:26:59 <sipa> > take 8 (sequence [[1..],[1,2,3]])
04:27:00 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2]]
04:27:04 <sipa> that one does :)
04:27:09 <jacobian> hehe, yup
04:27:23 <jacobian> doesn't help me unfortunately
04:27:25 <sipa> and if both are infinite, you'd have to use diagonalization
04:27:37 <jacobian> That's what I want
04:27:42 <edwardk> jacobian: the problem is the Omega isn't technically a monad
04:27:55 <sipa> > [[a,a-b] | a <- [0..], b <- [0..a]]
04:27:57 <lambdabot>   [[0,0],[1,1],[1,0],[2,2],[2,1],[2,0],[3,3],[3,2],[3,1],[3,0],[4,4],[4,3],[4...
04:28:03 <edwardk> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
04:29:00 <edwardk> (it fails associativity slightly)
04:30:10 <edwardk> but it works fine in practice
04:30:57 <jacobian> Thanks all - very helpful
04:44:02 <ivanm> edwardk: ta
04:44:13 * hackagebot monad-st 0.2 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2 (EdwardKmett)
04:45:52 <edwardk> i may ditch the .Pure hierarchy but its a decent starting point
04:46:36 <lpsmith> Out of curiousity,  what will Data.ByteString.hGet :: Handle -> Int -> IO ByteString
04:46:53 <lpsmith> do on a network socket when there is less than Int bytes available?
04:49:13 <quicksilver> block, I believe.
04:51:58 <hiptobecubic> Sounds desirable.
04:52:41 <lpsmith> ahh, it looks like network-bytestring has functions that will guarantee to do what I want
04:53:07 <quicksilver> the documentation of hGetNonBlocking certainly implies that hGet blocks.
04:53:09 <ivanm> lpsmith: FYI, that's been merged into network proper
04:53:13 <mdwright> I was wondering if anyone could explain why Haskell 2010 removed the n+k patterns?
04:53:24 <ivanm> mdwright: they were bad
04:53:25 <ivanm> :p
04:53:36 * ivanm tries to find the wiki page
04:54:18 <mdwright> ivanm: Ah, found a page on it. http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
04:54:23 <mdwright> Thanks for looking though :-)
04:54:33 <ivanm> that'd be the one
04:54:41 <lpsmith> ivanm, so it has.  Thanks!
04:55:33 <lpsmith> mdwright, I kinda liked n+k patterns myself
04:55:40 <lpsmith> oh well
04:55:52 <lpsmith> I'm not going to miss them that much either
04:56:23 <lpsmith> I'm finding myself using view patterns more and more though
04:57:20 <mdwright> lpsmith: I think they were interesting, but I can certainly see how they deviated from the norm, and didn't really add -that- much to the language.
04:59:02 <lpsmith> mdwright, oh once in a while I think they made code a great deal more aesthetically pleasing.
04:59:17 <lpsmith> well, a fair bit more anyway
05:00:12 <ivanm> probably my favourite "new" extension is PatternGuards
05:00:46 <ivanm> and since it's part of Haskell2010, I don't feel that guilty about using it :p
05:01:06 <mdwright> lpsmith: I should preface my opinion with that I haven't been using haskell for all that long (on the order of 4-6 weeks), and have generally avoided them because of their removal in Haskell 2010.
05:02:46 <lpsmith> Yeah,  I really like pattern guards, but at the same time I don't use them that often either
05:04:32 <mjrosenb> ivanm: is "f g [] x | y <- g x = x + y" a pattern guard, or am i thinking of something else?
05:04:44 <lpsmith> mdwright, that's ok.   One of the examples of n+k patterns that I think is the "prettiest" versus the (rather simple alternative) is the top example on page 42 of the Monad Reader issue 14
05:04:53 <lpsmith> http://themonadreader.files.wordpress.com/2009/07/issue142.pdf
05:05:12 <lpsmith> using n+k preserves the symmetry of the invariant being used
05:05:42 <mdwright> lpsmith: I'd not seen The Monad Reader before. I'll have to go take a look at some other issues of it.
05:06:51 <edwardk> ivanm:  i removed the .Pure hierarchy and just flipped the constructors over a lambda, yielding the simpler Data.Graph.Adjacency.List and Data.Graph.Adjacency.Matrix definitions 
05:06:59 <lpsmith> but basically,  that code uses the integer as a "parallel" data structure to know how much of a self-referential lazy list can safely be examined
05:07:12 <edwardk> ivanm: a.) it shrunk the size of the package by a factor of 2, and b.) it drives the programming model i want
05:07:28 <lpsmith> and n+k patterns emphasize that symmetry, which can be lost somewhat without them
05:08:51 <edwardk> lpsmith: bah, old timer, n+k patterns are long dead ;)
05:09:48 <edwardk> re pattern guards i've talken to using them in lieu of where and let bindings in a lot of code
05:10:05 <edwardk> er taken even
05:12:51 <silver> @where
05:12:51 <lambdabot>  @where <key>, return element associated with key
05:13:00 <silver> can I get list of keys?
05:13:51 <silver> looking for the wiki, where one of the #haskell citizens posted some cool stuff
05:13:51 <jacobian> How do you ascribe a type to a lambda
05:14:11 <lpsmith> I could see that, actually
05:14:11 <lpsmith> it is basically a let with slightly lower syntatic overhead
05:14:30 <parcs> > ((\x -> x) :: Int -> Int) 5
05:14:32 <lambdabot>   5
05:15:38 <jacobian> thanks parcs
05:15:38 <lpsmith> Uhm,  given \x -> exp,   assume x has type a and then use that to prove exp has type b?
05:17:50 <lpsmith> heh,  you can't even write ((-1) -> x) using view patters as a sort-of subsitute for (x+1).  bah
05:18:18 <lpsmith> we should have gone with ~ for unary negation or something
05:18:36 <mjrosenb> lpsmith: it is what sml uses!
05:18:44 <lpsmith> indeed :)
05:19:05 <edwardk> subtract 1 -> x ? =)
05:20:09 <mjrosenb> subtract = (0-)
05:20:25 <edwardk> > subtract 1 3
05:20:26 <lambdabot>   2
05:20:51 <edwardk> you're thinking negate
05:20:53 <lpsmith> how long has subtract been part of the prelude?
05:21:02 <edwardk> since pre 98
05:21:05 <lpsmith> heh
05:21:15 <lpsmith> I learn something every day :-D
05:21:26 <edwardk> its used when you want to section (-) =)
05:21:32 <lpsmith> right :)
05:22:10 <lpsmith> That is actually useful,  and I know I've read the prelude in it's entirety,  but it must not have sunk in
05:29:28 * hackagebot lispparser 0.3 - Simple parser for LISP S-expressions  http://hackage.haskell.org/package/lispparser-0.3 (EricKow)
05:32:29 * hackagebot lispparser 0.3.1 - Simple parser for LISP S-expressions  http://hackage.haskell.org/package/lispparser-0.3.1 (EricKow)
05:33:47 <mjrosenb> but it is only useful for right sections
05:33:48 <aleator> Hi, could anyone give simple example of iteratee program that reads two files and prints out concatenations of all lines
05:34:02 <mjrosenb> and that is equivalent to (+ (-foo))
05:34:30 <lpsmith> which is less characters than,  but also less readable (IMO) than (subtract foo)
05:34:51 <edwardk> then you use flip subtract ;)
05:34:56 <quuuux> takeFrom = flip subtract?
05:35:10 <lpsmith> > (3 -) 4
05:35:11 <lambdabot>   -1
05:35:12 <edwardk> i usually call the other minus
05:35:19 <Aristid-andro> :t (-)
05:35:20 <lambdabot> forall a. (Num a) => a -> a -> a
05:35:24 <edwardk> its in monoids somewhere
05:35:29 <lpsmith> :t (-3)
05:35:31 <lambdabot> forall a. (Num a) => a
05:35:45 <edwardk> or i suppose you can just (-) 3
05:35:48 <Aristid-andro> why flip subtract if there is -
05:35:52 <exDM69> I'm wondering how should I implement a physics simulation loop. I want to have it in another thread and it must be pauseable and stoppable from the UI thread
05:35:53 <edwardk> yeah
05:36:05 <Eelis> edwardk: do you already have a separate package containing Bifunctor? it's another thing i'd like to use in category-extras, but if i recall correctly you were planning to deprecate category-extras, right?
05:36:12 <Aristid-andro> :t (3 -)
05:36:14 <lambdabot> forall t. (Num t) => t -> t
05:36:16 <Eelis> s/use in/use from/
05:36:20 <exDM69> I know how to implement it with mutexes and conditions but that's not generally preferred with Haskell concurrency
05:36:24 <Aristid-andro> or sections
05:36:35 <quuuux> quuuux's third law of Haskell development: every useful function is defined in a library related to monads somehow
05:36:47 <Veinor> s/monads/monads or arrows/
05:37:08 <hpc> Veinor: if it's defined for arrows it can be used on all monads :P
05:37:18 <hpc> so the latter reduces to the first
05:37:29 <Veinor> :D
05:38:23 <quicksilver> exDM69: have a thread which runs a 'single step' and then checks an MVar to see if it is allowed to keep running.
05:38:36 <Maxdamantus> @pl \f a b -> foo (f a) (f b)
05:38:36 <lambdabot> flip =<< (((.) . foo) .)
05:38:37 <hpc> argh, i hate vim's handling of tabs
05:38:56 <Maxdamantus> hpc: copyindent is nice.
05:38:56 <exDM69> quicksilver: how to do the delay? I initially thaught that I'd do a condition variable wait with a timeout
05:39:24 <Maxdamantus> hpc: it copies the spaces/tabs from the previous line, as you create a new one.
05:39:32 <exDM69> quicksilver: adjustable frame rate would be nice too, so if I increase the frame rate, the condition should be notified
05:39:43 <hpc> Maxdamantus: not that; i cannot scroll to column zero in a line that begins with a tab
05:39:45 <Maxdamantus> (rather than doing any automatic indent insertion or conversion from spaces to tabs)
05:40:00 <hpc> but only for the first tab
05:40:22 <hpc> so i am scrolling through this file, with my cursor jumping from column 0 to column 8
05:40:28 <Maxdamantus> You can .. it just puts the cursor at the end of the tab ratehr than the start.
05:40:51 <hpc> yeah, that's what i hate :P
05:41:07 <hpc> visually, it is not the first column
05:41:17 <quicksilver> exDM69: well, if you want fixed framerate then you do the normal {check clock time; calculate one frame; sleep until (1/fps) seconds afer check}
05:41:31 <quicksilver> exDM69: threadDelay takes a microsecond delay.
05:42:07 <quicksilver> exDM69: my interpretation of your first question was 'sleep until I'm instructed to wake up', in which case you might as well block on a takeMVar
05:42:17 <exDM69> quicksilver: I suppose using a normal delay would be close enough
05:42:57 <exDM69> quicksilver: there's no function to block on an mvar with a timeout
05:43:29 <hpc> it's possible to write your own though
05:43:54 <hpc> using non-blocking take, and a sleep
05:43:59 <quicksilver> exDM69: that's correct; you can build one by forking, delaying, and either (a) sending an async exception to the blocking thread or (b) just waking it up
05:44:01 <hpc> and maybe loop as well
05:44:18 <quuuux> hpc: that might be race condition prone. I -think- System.Timeout will be safer
05:45:04 <exDM69> quicksilver: I'll try to get something written, let's see how it turns out
05:45:05 <quuuux> hpc: I don't quite recall how MVars react in the presence of exceptions, but I presume it's sane!
05:45:35 <hpc> quuuux: non-blocking take uses Maybe, so no exceptions are thrown :P
05:45:51 <hpc> (if your own code uses exceptions, i have no idea what will happen)
05:45:51 <quuuux> hpc: I mean that exceptions are used in System.Timeout
05:45:56 <hpc> oh
05:48:48 <jacobian> I wonder if most people try to write total code, or if they use exceptions/error
05:49:03 <jacobian> I generally only use error myself if I think something is truly impossible. 
05:49:29 <hpc> i don't use error
05:49:32 <hpc> i like my line numbers
05:49:59 <hpc> i also don't write exceptional code, so there's that too
05:50:16 <quicksilver> exceptions as suggested above don't imply non-total code
05:50:34 <quicksilver> they're just a non-local "jump" facility which happens to be part of the IO monad
05:50:55 <quuuux> on my most recent project, it's -theoretically- almost all total, but that's because it's written using an exception-handling monadic style
05:50:56 <quicksilver> and asynchronous ones are our only kind of asynchronous thread message.
05:51:33 <jacobian> ok - I rather naively wrote my own exception monad
05:52:06 <jacobian> Didn't know there was one rolled in that was part of the IO monad. 
05:58:40 <Saulzar> Hi
06:11:59 <keep_learning> :t iter
06:11:59 <lambdabot> Not in scope: `iter'
06:12:05 <keep_learning> iter
06:12:17 <keep_learning> lcm
06:12:30 <keep_learning> :t lcm
06:12:31 <lambdabot> forall a. (Integral a) => a -> a -> a
06:30:18 <saml> hey is 咒 special operator in haskell?
06:30:46 <Maxdamantus> > :t (咒)
06:30:47 <lambdabot>   <no location info>: parse error on input `:'
06:30:52 <Maxdamantus> :t (咒)
06:30:53 <lambdabot> parse error (possibly incorrect indentation)
06:30:55 <Saulzar> Seems unlikely - japanese character??
06:31:03 <zygoloid> > let (咒) = id in negate 咒 42
06:31:05 <lambdabot>   -42
06:31:07 <azaq23> fix could, purely theorically, solve something like fix $ \x -> x^2 - x - 120 (so putting out one of the two possible solutions, whichever is found first), correct?
06:31:19 <zygoloid> saml: looks like it's an operator character
06:31:57 <Maxdamantus> What determines an operator from a .. not operator?
06:32:02 <zygoloid> azaq23: that really depends on which Num instance you're using. fix provides a /least/ fixed point (information-wise)
06:32:08 <Maxdamantus> Operators are all non-letters?
06:32:28 <Maxdamantus> > let þ = id in þ 42
06:32:28 <lambdabot>   42
06:32:29 <saml> 咒  is f word in chinese
06:32:46 <Maxdamantus> Mm, looks something like that.
06:32:48 <zygoloid> azaq23: if there are two distinct fully-defined fixed points for a function, fix cannot return either of them, since neither is least-defined.
06:33:06 <Maxdamantus> > let þ = id in negate `þ` 42
06:33:07 <lambdabot>   -42
06:33:47 <Saulzar> > let ^ = 4 in ^
06:33:49 <lambdabot>   <no location info>: parse error on input `^'
06:34:03 <Maxdamantus> ^'s not a letter.
06:34:10 <Maxdamantus> (according to unicode)
06:34:44 <Maxdamantus> > let Þ = id in Þ 42
06:34:46 <lambdabot>   Not in scope: data constructor `
06:34:49 <Maxdamantus> Fun.
06:35:20 <lpsmith> azaq23, different kind of fixed point :)
06:37:02 <quicksilver> well, I think there's only one kind of fixed point.
06:37:03 <tac-tics> @let 天 = ［1,2,.. ］
06:37:03 <lambdabot>   Illegal character ''\22825''
06:37:04 <quicksilver> f x = x
06:37:13 <tac-tics> @let 天 = 0 
06:37:14 <lambdabot>   Illegal character ''\22825''
06:37:20 <quicksilver> the point is that there may be many, and fix always finds the least-defined such.
06:37:20 <tac-tics> Aww ;( 
06:37:29 <quicksilver> (there always is a least-defined one, as well)
06:39:06 <kuffaar> Will Haskell Prime have proper Unicode support?
06:39:12 <kuffaar> I want my Unicode names
06:39:22 <kuffaar> Can you currently even put UTF-8 into a string?
06:39:39 <copumpkin> o.O
06:39:43 <copumpkin> kuffaar: yes, it already does
06:39:48 <copumpkin> UTF-8 doesn't belong in a string
06:39:54 <copumpkin> characters/code points  do
06:40:11 <kuffaar> I'm not sure what you mean
06:40:26 <copumpkin> the encoding used in the string is irrelevant from the programmer's point of view (or should be)
06:40:29 <copumpkin> UTF-8 is an encoding
06:40:43 <kuffaar> let string = "此编程语言吮吸"
06:40:47 <kuffaar> Is that currently legal?
06:40:56 <copumpkin> well, if you write a full expression it is
06:41:04 <kuffaar> Because many programming languages currently fail at that.
06:41:05 <copumpkin> let x = 5 isn't legal except in a do block
06:41:11 <copumpkin> but yeah, otherwise it's fine
06:41:12 <Zao> kuffaar: Are you asking whether you can have source files encoded with UTF-8?
06:41:13 <kuffaar> Right
06:41:18 <kuffaar> Zao yes
06:41:22 <copumpkin> we also don't have an issue with non-BMP characters
06:41:29 <kuffaar> And what about
06:41:32 <kuffaar> 此编程语言吮吸 = 345345
06:41:38 <copumpkin> kuffaar: same haskell name restrictions
06:41:40 <copumpkin> as usual
06:41:42 <quuuux> copumpkin: even with ByteString?
06:41:47 <Zao> kuffaar: The string itself never has any "encoding". It's just a sequence of codepoints.
06:41:53 <copumpkin> quuuux: that's a string of bytes, not characters
06:42:06 <Zao> As for interpreting string literals, that's most probably up to the implementation.
06:42:23 <quicksilver> GHC supports UTF-8 source files
06:42:26 <quicksilver> has done for many years.
06:42:28 <copumpkin> kuffaar: haskell asks the unicode standard about what's a letter and what's punctuation to decide what to allow as names and what to allow as operators and such
06:42:38 <quuuux> copumpkin: right, but it's pushed as a drop-in high-performance replacement for [Char] (at least, I've seen it pushed as such)
06:42:43 <quicksilver> I forget if it also supports other formats like windows UTF16 or not.
06:42:45 <copumpkin> quuuux: it shouldn't be
06:43:00 <kuffaar> quicksilver I thought what Windows used wasn't even UTF-16
06:43:05 <kuffaar> But some homebrew mix
06:43:11 * quuuux thinks we should all just move to UTF-32 and be done with it
06:43:18 <kuffaar> ...? That's wasteful
06:43:22 <quicksilver> that's why I called it "windows utf16"
06:43:23 <kuffaar> UTF-8 is awesome
06:43:26 <kuffaar> Oh, right
06:43:47 <Jafet> Windows used UCS-2 -- it probably uses UTF-16 properly now.
06:43:52 <quicksilver> GHC allows you to name variables in anything unicode things is a letter
06:43:58 <quicksilver> (in a UTF8 source file)
06:44:01 <Maxdamantus> Hmm.. How are strings stored in GHC? I'm guessing it groups Chars and uses some sort of encoding (rather than an array of 32-bit-wide integers)
06:44:08 <ketil> I think Java is still using UCS-2.
06:44:13 <copumpkin> Maxdamantus: no, a singly linked list of 4-byte characters
06:44:14 <quicksilver> as well as put any unicode code point at all in a String
06:44:17 <Jafet> Maxdamantus: String is [Char] -- take a guess.
06:44:17 <Zao> Maxdamantus: String is [Char].
06:44:33 <Zao> Maxdamantus: It's no different from any other list, and subject to the same kind of optimizations.
06:44:37 <Maxdamantus> Yeah, but it could be optimised quite easily to not simply be stored as a normal list.
06:44:46 <Maxdamantus> Ah.
06:44:47 <quicksilver> Maxdamantus: quite easily? Go do it then.
06:44:48 <Zao> Maxdamantus: Except you do do normal list operations on it.
06:44:53 <Jafet> That would preclude other optimizations.
06:45:01 <copumpkin> nothing comes for free
06:45:10 <Jafet> Use ByteString instead.
06:45:10 <quicksilver> when you've "quite easily" solved this problem, I will be pleased to learn from your solution.
06:45:13 <ketil> Maxdamantus, so it's a 64bit pointer to a cons cell, with a 64bit pointer to a Char, and a 64bit pointer to the next cons cell.  UCS-4 is wasteful, you say? :-)
06:45:15 <Zao> Jafet: Use Text intead.
06:45:16 <quicksilver> Jafet: no, use Text.
06:45:17 <copumpkin> kuffaar: anyway, if you try a utf-8 haskell source file it should work fine with GHC
06:45:26 <hape01> Hi, how Do I putStrLn a ["123","456"] value easily?
06:45:26 <Jafet> Okay, use Text instead.
06:45:29 <copumpkin> kuffaar: lambdabot may have some odd encoding issues on IRC
06:45:32 <Zao> Jafet: Working with baked octet piles is not text processing.
06:45:36 <ketil> hape01, "print"?
06:45:40 <kuffaar> copumpkin so you need to mark it explicitly as UTF-8? :C
06:45:45 <Zao> hape01: You can 'show' it.
06:45:45 <hape01> print won't work with [[Char]]
06:45:47 <copumpkin> kuffaar: no?
06:45:49 <malosh> Hi. Is it possible to declare the "tuple" type an instance of some class ?
06:45:54 <Zao> hape01: print works with anything showable.
06:45:57 <kuffaar> copumpkin: Alright
06:46:03 <Zao> @instances Show
06:46:04 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
06:46:09 <ketil> hape01, no?  Why not?
06:46:10 <Zao> Which includes lists.
06:46:11 <kuffaar> > show ["123","456"]
06:46:12 <copumpkin> kuffaar: but if you write unicode in a text editor that doesn't save in a unicode encoding by default, you're just going to discard information when saving :P
06:46:13 <lambdabot>   "[\"123\",\"456\"]"
06:46:21 <copumpkin> kuffaar: it also can't magically detect the encoding so it'll assume utf-8
06:46:22 <kuffaar> copumpkin pff I use emacs
06:46:24 <malosh> Like instance Class ( , ) where ...
06:46:56 <quicksilver> malosh: if the Class is expecting a 2-ary type constructor, then instance Class (,) will work
06:47:08 <Zao> Contrary to popular belief among its users, you DO need to think when using Emacs.
06:47:12 <Jafet> @instances Functor
06:47:12 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
06:47:23 <Jafet> (kuffaar)
06:47:30 <kuffaar> Zao I already use utf-8-unix
06:47:47 <Bynbo7> malosh: what's the class (/its definition)
06:47:50 <malosh> quicksilver : no, I want to define a class with instances for all tuples up to 4-uples
06:47:53 <kuffaar> Jafet what about them? I didn't ask about anything pertaining to functors
06:48:13 <quicksilver> malosh: well, it depends what kind of class you what
06:48:20 <quicksilver> malosh: instance Class (a,b) where ... is also correct
06:48:30 <Bynbo7> possibly
06:48:30 <malosh> Bynbo7 : I do not know, I'm just trying to figure out if it is possible
06:48:35 <Jafet> kuffaar: Er, you didn't, malosh did
06:48:36 <quicksilver> malosh: but that suggests a class of kind *, instead of a class of kind * -> * -> *
06:48:39 <malosh> quicksilver : it's not what I mean
06:48:47 <Jafet> (malosh), then
06:48:50 <Bynbo7> malosh: well, types are instances of quite a few classes
06:48:55 <Bynbo7> tuples even
06:49:24 <Bynbo7> malosh: can you show us what you mean?
06:49:34 <malosh> I want to define a class with some function f that I would be then able to call on couples, 3-uples, ..., n-ulpes,..
06:49:44 <malosh> like f (1,2)
06:49:48 <malosh> f (2,3,4)
06:49:56 <Zao> malosh: Very unfeasible, I'd say.
06:50:06 <Maxdamantus> > (1, 2, 3, 4, 5)
06:50:07 <malosh> It's only a matter of syntax
06:50:08 <lambdabot>   (1,2,3,4,5)
06:50:17 <Zao> Unless you go and make it  f :: forall a. T a => a -> b
06:50:18 <Maxdamantus> > show (1, 2, 3, 4, 5)
06:50:19 <lambdabot>   "(1,2,3,4,5)"
06:50:25 <Bynbo7> Zao: eh?
06:50:26 <malosh> If I'd defined my own tuple types
06:50:30 <malosh> It would be possible
06:50:34 <Jafet> @hackage nthable
06:50:34 <lambdabot> http://hackage.haskell.org/package/nthable
06:50:35 <Zao> That is, define some type class you can use.
06:50:53 <quicksilver> malosh: well you have to make an instance for each size of tuple
06:51:01 <quicksilver> or find someone else who has done so )
06:51:02 <malosh> Sure
06:51:05 <Bynbo7> malosh: you can restrict the types inside the tuples, say: instance Num a => Foo (a,a,a) where...
06:51:14 <malosh> quicksilver : But what is the syntax for declaring the class
06:51:24 <hape01> ketil and others: Thanks for helping.   do -> putStrLn $ show [["1","2","3"]]    works fine.
06:51:29 <quicksilver> instance Class (a,b) where....
06:51:31 <quicksilver> as I said?
06:51:39 <quicksilver> I dont' even know what your class is!
06:51:46 <malosh> That is not what I want
06:51:49 <katja> can someone halp with with my homework in haskell?
06:51:57 <quicksilver> malosh: then you have to tell me what you do want.
06:52:25 <Bynbo7> malosh: explain what you want more clearly
06:52:35 <hape01> ketil and others: putStrLn $ show abc   is okay or is there a shortifcation?
06:52:46 <malosh> For instance if I had declared my own tuple types, say data Couple a b=Couple a b, then data Triple a b c=Triple a b c
06:52:57 <Bynbo7> so, if you have a class Foo with a function f that takes tuples of different sizes, what will be the result of f?
06:52:59 <malosh> I'd be able to say instance MyClass Couple where ...
06:53:06 <malosh> instance MyClass Triple where ...
06:53:12 <malosh> With the same "MyClass" class
06:53:15 <malosh> of course
06:53:18 <quicksilver> malosh: no, you would not.
06:53:21 <Bynbo7> malosh: you can't do that
06:53:26 <Bynbo7> they have different kinds
06:53:29 <Bynbo7> :k (,)
06:53:30 <lambdabot> * -> * -> *
06:53:31 <Bynbo7> :k (,,)
06:53:32 <lambdabot> * -> * -> * -> *
06:53:32 <quicksilver> malosh: you wolud have to say "instance MyClass (Couple a b)"
06:53:32 <Bynbo7> :k (,,,)
06:53:34 <lambdabot> * -> * -> * -> * -> *
06:53:38 <malosh> Ah, right
06:53:40 <malosh> ok
06:53:41 <quicksilver> malosh: instance MyClass (Triple a b c)
06:53:42 <malosh> Thanks
06:53:50 <quicksilver> malosh: and, you can say "instance MyClass (a,b)"
06:53:50 <malosh> Neither template haskell allows for that ?
06:53:57 <Bynbo7> huh?
06:53:59 <quuuux> :t print
06:54:00 <lambdabot> forall a. (Show a) => a -> IO ()
06:54:05 <quicksilver> malosh: as I have also said - three times now - you can also say "instance MyClass (,)"
06:54:06 <quuuux> :t putStrLn . show
06:54:07 <lambdabot> forall a. (Show a) => a -> IO ()
06:54:15 <quicksilver> malosh: which would be the equivalent of "instance MyClass Couple"
06:54:29 <malosh> Yeah, but that would work for triples, as you said !
06:54:32 <quicksilver> but that would obviously be a different class, of the kind Bynbo7 showed.
06:54:39 <malosh> Which is what I want
06:54:56 <katja> can someone help with my homework in haskell? I dont need the solution for it.  just to say it is right
06:55:12 <quicksilver> malosh: I don't understand why you don't think "instance MyClass (a,b)" is what you want.
06:55:17 <quicksilver> malosh: it seems right to me.
06:55:24 <Bynbo7> katja: we need to know what your problem is to be able to help you
06:55:54 <malosh> quicksilver, Bynbo7 : Well, I'll think more about it, thanks !
06:56:04 <Bynbo7> -_-
06:56:13 <Bynbo7> we could help you a lot if you told us more
06:56:34 <Bynbo7> you're only hurting yourself (and slightly annoying us ;)) by not giving us more details
06:56:40 <edwardk> ivanm: still awake?
06:57:39 <katja> Bynbo7:http://codepad.org/9BwrxRGZ I have to write typ Ternary Tree but it should not be a real ternary tree
06:58:08 <Bynbo7> what do you mean by not real?
06:58:19 <lunaris> katja: It's fine apart from the fact that you can't have spaces in type names
06:58:34 <lunaris> katja: i.e. data TernaryTree a = ... would be better
06:58:44 <katja> Bynbp7: it is like the first Node can have only 2 children but not three
06:58:58 <Bynbo7> katja: also, as a rule, you should not put type constraints on your data type definitions, but i'm guessing your lecturer has said you need it?
06:59:23 <Bynbo7> katja: so do you mean a binary tree? i don't follow
06:59:47 <lunaris> If this turns into a discussion on 2-3 finger trees then I'll have to step aside.
06:59:53 <lunaris> ;)
06:59:55 <edwardk> katja: the Ord constraint on the data structure is useless. it should be on any instances that use the structure
07:00:23 <edwardk> (they are even being removed from the language!)
07:00:26 <Bynbo7> edwardk: i believe their lecturer has given them this code, with the constraint sadly
07:00:31 <edwardk> =/
07:00:37 <edwardk> suck
07:00:38 <katja> Bynbo7: no, I mean to define TerneryTree as like binaryTree is defined by data BinTree a = Nill    | Node (BinTree a) a (BinTree a)     deriving (Show)
07:01:12 <Bynbo7> katja: i still don't understand what your problem is
07:01:35 <Bynbo7> the code you've given there is exactly a ternary tree
07:01:40 <lunaris> katja: Why not just data TernaryTree a = Nil | Node a (TernaryTree a) (TernaryTree a) (TernaryTree a)?
07:01:53 <lunaris> The additional Leaf constructor seems extraneous in this case.
07:01:58 <Bynbo7> except the Leaf is weird
07:02:23 <Bynbo7> katja: i'm guessing you're supposed to store Strings in this ternary tree?
07:02:50 <katja> Bynbo7: I have to define Typ TernaryTree
07:02:54 <hape01> quuuux: thanks a lot
07:02:56 <katja> Bynbo7: yeah
07:02:59 <Bynbo7> katja: you already have
07:03:15 <Bynbo7> but if it is only going to store Strings, i would change it like so:
07:03:50 <katja> Bynbo7: it should store as well numbers
07:04:22 <Bynbo7> data TernaryTree a = Nil Int | Node a (TernaryTree a) (TernaryTree a) (TernaryTree a)
07:04:33 <Bynbo7> since you changed your mind while i was typing that :P
07:04:42 <Bynbo7> hmm, maybe that's not right
07:04:44 <lunaris> Your concept of Nil intrigues me :)
07:04:49 <katja> Bynbo7: and Strings as well
07:05:01 <Bynbo7> katja: this will store Strings
07:05:18 <Bynbo7> you just make a = Char
07:05:27 <lunaris> kaini: To specify: are you saying that each leaf (and only the leaves) should contain an Int and String?
07:05:37 <lunaris> Damnit
07:05:43 <lunaris> s/kaini/katja/
07:05:48 <Bynbo7> and a string?
07:06:16 <katja> Bynbo7: so like data TernaryTree a =  Leaf Char Int |Node a (Tree a)(Tree a)(Tree a)
07:06:39 <Bynbo7> katja: i think you want to make that Char an a
07:07:02 <Bynbo7> also, if i were you, i'd go and learn about ternary trees... say from an article like this: http://igoro.com/archive/efficient-auto-complete-with-a-ternary-search-tree/ =)
07:07:24 <Bynbo7> (i happen to be the author of the TernaryTrees package in hackage ;)
07:07:38 <Bynbo7> and that article is where i learnt about them
07:07:59 <katja> Bynbo7: so like data TernaryTree Char =  Leaf Char Int |Node Char (Tree Char)(Tree Char)(Tree Char)
07:08:05 <Bynbo7> no
07:08:17 <Bynbo7> the other way around :P make all those Chars into a's
07:08:24 <Bynbo7> Leaf a Int ...
07:08:25 <katja> Bynbo7: but I need as well to store numbers there
07:10:12 <Bynbo7> yes, so make it data TernaryTree a = Leaf a Int | Node a (TernaryTree a) ...
07:11:28 <katja> Bynbo7: i mean like can it be something like that data TernaryTree = Leaf Char Int | BNode Int TernaryTree TernaryTree |TNode Int TernaryTree TernaryTree TernaryTree
07:12:00 <Bynbo7> it could be, but you also want to be anle to stre Chars at the nodes right?
07:12:04 <Bynbo7> store*
07:12:47 <katja> Bynbo7: yeah. but I mean what is the difference between them
07:13:06 <Bynbo7> the second one can only store Ints
07:13:51 <katja> Bynbo7: besides that
07:14:11 <Bynbo7> why do you need the BNode?
07:14:27 <Bynbo7> and that does the Char in the Leaf represent?
07:15:53 <katja> Bynbo7: i need to define typ Ternary tree with stored int and string, but this ternary tree should not be a real one exactly. like node can have two children Mary and Katy and then Mary can have three children
07:16:19 <Bynbo7> hmm, ok
07:16:35 <Bynbo7> ok, this is a different sort of ternary tree from what i'm used to then
07:16:53 <Bynbo7> i'll have to leave you in the capable hands of others while i sleep
07:17:45 * Bynbo7 tag teams to lunaris and goes to sleep!
07:20:04 <katja> can someone help me? i need to define typ Ternary tree with stored int and string, but this ternary tree should not be a real one exactly. like node can have two children Mary and Katy and then Mary can have three children . what is right? http://codepad.org/PHvUnkg9
07:20:19 <dschoepe> katja: what about the above data TernaryTree a = Nil | Node a (TernaryTree a) (TernaryTree a) (TernaryTree a) and later using (Int,String) for a?
07:20:52 <dschoepe> If you want a node to have only two children you can set the third TernaryTree a to Nil
07:21:23 <lunaris> katja: It depends where you want the Int and String
07:21:51 <lunaris> katja: If you *always* want an Int and String to appear together, dschoepe's suggestion is fine.
07:21:59 <katja> lunaris: in leaves
07:22:04 <lunaris> katja: Ok
07:22:14 <lunaris> katja: And they always appear together?
07:22:27 <lunaris> katja: So every leaf (and only the leaves) has an Int and a String?
07:22:39 <katja> lunaris: yes
07:22:42 <lunaris> katja: Ok.
07:23:00 <dschoepe> data TernaryTree a = Leaf a | Node (TernaryTree a) (TernaryTree a) (TernaryTree a) should do it then
07:23:19 <dschoepe> hm, and a Nil constructor for nodes with less children
07:23:26 <lunaris> katja: Something like data Tree23 a = Leaf a | Node2 (Tree23 a) (Tree23 a) | Node3 (Tree23 a) (Tree23 a) (Tree23 a) will be fine
07:23:34 <lunaris> katja: If you set a to be (Int, String)
07:23:41 <lunaris> katja: Alternatively, hardcode in the (Int, String)
07:24:10 <katja> lunaris: but can I set those String and Int direct in data TernaryTree
07:24:15 <lunaris> katja: Giving: data Tree23 = Leaf Int String | Node2 Tree23 Tree23 | Node3 Tree23 Tree23 Tree23
07:24:20 <lunaris> katja: It's up to you.
07:24:35 <lunaris> The latter example will fix the values in the tree to be Ints and Strings
07:24:46 <dschoepe> in general I'd leave it more general though, so you can reuse that code later for different data types
07:25:29 <dschoepe> s/in general//
07:25:45 * lunaris is going to grab a cup of tea; back to work in a bit.
07:25:57 <Bynbo7> dschoepe: it's an assignment :\
07:26:09 <dschoepe> okay, nevermind then :)
07:26:34 <katja> lunaris: TernaryTree a = Leaf a  Int |Node a (Tree a)(Tree a)(Tree a) so that will not work because one Node has always 3 children
07:27:16 <dschoepe> katja: with that definition you also have data in the nodes
07:28:21 <katja> dschoepe: so, like I also have string and int in the nodes?
07:28:38 <dschoepe> in your example you have an a in the Node, but not an Int
07:28:59 <katja> dschoepe: data TernaryTree a = Leaf Char Int | BNode Char Int TernaryTree TernaryTree |TNode Char Int TernaryTree TernaryTree TernaryTree and this one with not work 
07:29:30 <katja> dschoepe: will not work because every node has string and int
07:30:04 <dschoepe> my/lunaris' definition should be fine then
07:30:14 <dschoepe> as you can see, there's no lone 
07:30:20 <dschoepe> 'a' in the Node constructors
07:31:06 <nednil> Hi everyone
07:31:08 <katja> dschoepe: TernaryTree String Int = Leaf String  Int |Node String Int (Tree String Int)(Tree String Int)(Tree String Int)  so that is not right because every node has an int and a
07:31:26 <nednil> Is Haskell a functional programming language?
07:31:43 <Bynbo7> it's THE functional programming language :)
07:32:02 <Jafet> (Haskell is unrelated to the THE.)
07:32:13 <nednil> Is it anything like scheme?
07:32:39 <dschoepe> katja: "data Tree23 = Leaf Int String | Node2 Tree23 Tree23 | Node3 Tree23 Tree23 Tree23" <- this should be what you want
07:32:51 <Bynbo7> i believe there's many similarities nednil 
07:32:59 <Bynbo7> but they're also very different
07:33:00 <dschoepe> there every node has either 2 or 3 children and every leaf has an Int and a String
07:33:08 <katja> dschoepe: dataTernaryTree String Int = Leaf String  Int |Node String Int (Tree String Int)(Tree String Int)(Tree String Int) and that is not right as well because every node has int and string but I need only leaves to have them
07:33:34 <byorgey> nednil: It has some similarities to scheme (e.g. first-class functions) but also some major differences (lazy evaluation, strong static typing, algebraic data types)
07:33:37 <Bynbo7> nednil: haskell is a pure language, so you can't do mutation or IO everywhere, only in certain places
07:33:49 <katja> dschoepe: yeah. I got it. but I dont understand why those two can not be the right, so I aks and suggest my answers
07:34:38 <Jafet> Haskell is also a language for which there does not exist two dozen mutually incompatible implementations
07:35:22 <dschoepe> katja: Yes, your statement above is correct, ... | Node String Int ... would mean that there is also data at the nodes.
07:35:23 <osfameron> there's merely half a dozen or so, aren't there?
07:35:50 <katja> dschoepe: ok. thank you
07:36:23 <hpc> osfameron: at least most of those are academic exercises
07:36:23 <nednil> Okay sounds cool. What type of language is Haskell, compiled, interpreted, hybrid?
07:36:37 <Jafet> nednil: yes.
07:36:38 <Bynbo7> compiled
07:36:40 <hpc> nednil: it can be both; ghc compiles to binary
07:36:47 <hpc> ghci compiles to bytecode and interprets
07:36:54 <Bynbo7> well, i think of haskell as compiled
07:37:05 <osfameron> that's not a property of the language
07:37:10 <hpc> or rather, it compiles to the intermediate language between .hs files and binary
07:37:14 <Bynbo7> yeah, i was about to mention that
07:37:15 <nednil> So is it as fast as a language like c?
07:37:28 <hpc> nednil: faster, occasionally
07:37:47 <Bynbo7> often slower, but it's very hard to beat C, and we do manage it sometimes
07:37:49 <osfameron> the only language that is exactly as fast as c is c.  or at least that particular implementation of c.
07:37:55 <Jafet> C programs are like drag racers on rocket fuel.
07:38:04 <Jafet> They are faaast.
07:38:12 <hpc> Jafet: damned hard to drive?
07:38:31 <byorgey> hpc: that too.
07:38:58 <valium97582> And when they crash, it's fun to watch :P
07:39:02 <hpc> one thing that bugs me about haskell, speed-wise, is compile times
07:39:03 <Bynbo7> nednil: http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php 
07:39:41 <Jafet> Probably more useful for nednil to read http://shootout.alioth.debian.org/dont-jump-to-conclusions.php
07:39:58 <Bynbo7> that too, but it's less favourable :P
07:41:19 <nednil> Thanks for all the help!
07:41:23 <Jafet> Trying to increase Haskell's success is a vain task, anyway
07:41:34 <katja> dschoepe: and I have one more question. Shouldnot I write data TernaryTree Int String = ...
07:41:38 <Bynbo7> nednil: if you're interested in learning more about haskell, head on over to...
07:41:42 <Bynbo7> @where lyah
07:41:42 <lambdabot> http://www.learnyouahaskell.com/
07:41:46 <Bynbo7> nednil: ^^^^^^^^^^^^^^^^^^^^^^^^^^^
07:42:22 <nednil> Haha thats a nice page, i might check it out some
07:43:01 <hpc> lyah is the top banana
07:43:18 <nednil> I've decided to learn a new language and i'm trying to deciding between Go and Hackell
07:43:39 <hpc> Go isn't that awesome
07:44:08 <nednil> I looked into it a little and Go seems to have very little community support
07:44:44 <aristid> Go is a very boring language :)
07:45:30 <byorgey> Go also doesn't have an awesome IRC channel where people answer your questions and make jokes about zygohistomorphic prepromorphisms
07:45:39 <byorgey> at least I assume it doesn't
07:45:49 <Bynbo7> the things that are "awesome" in Go have all be in Haskell for a long time
07:46:02 <Jafet> Go is named after the board game, where the objective is to hem components in so that they lose breathing room and die. It's also based on ancient principles.
07:46:27 <hpc> also go code isn't very pretty
07:46:29 <Bynbo7> Jafet: the game or the language? =)
07:46:35 <hpc> it looks too much like java for my tastes
07:46:58 <dschoepe> katja: the arguments to TernaryTree on the left hand side have to be type variables and since String and Int are not variable they do not belong there.
07:48:21 <nednil> Thanks for all the help guys, i'm going to try myself some Haskell now!!!
07:48:39 <Bynbo7> go forth and learn for great good!
07:49:36 <keep_learning> http://hpaste.org/control
07:49:36 <keep_learning> could some one please tell me 
07:49:50 <keep_learning> why this code is going into infinite loop 
07:50:04 <keep_learning> i http://programmingpraxis.com/2010/04/23/modern-elliptic-curve-factorization-part-1/
07:50:13 <keep_learning> http://programmingpraxis.com/2010/04/27/modern-elliptic-curve-factorization-part-2/
07:50:26 <hpc> keep_learning: your link has no content
07:50:28 <keep_learning> i am trying to implement this algorithm 
07:50:59 <keep_learning> http://programmingpraxis.com/2010/04/23/modern-elliptic-curve-factorization-part-1/
07:51:03 <keep_learning> check now 
07:51:09 <Bynbo7> no, your first link
07:51:11 <keep_learning> i think its working 
07:51:16 <Bynbo7> the hpaste one
07:51:21 <keep_learning> ohhhhh
07:52:02 <keep_learning> http://hpaste.org/43165/elliptic_curve_montgomery
07:52:09 <keep_learning> Bynbo7: kindly have a look now
07:52:18 <keep_learning> i think now its working 
07:52:23 <Bynbo7> no, i'm going to sleep ;)
07:52:32 <copumpkin> Bynbo7: not allowed!
07:52:50 <hpc> oh god, the indentation
07:53:01 <hpc> main = do
07:53:06 <Jafet> (Go?! Forth?!)
07:53:06 <hpc>         foo <- bar
07:54:01 * fryguybob would pick forth over go, but sticks with haskell.
07:54:32 <exDM69> when doing a soft realtime physics sim loop with haskell, is it feasible to stop the update loop thread every time the sim is paused? or is it better to let the worker thread wait for a condition variable until the sim is unpaused?
07:54:33 <keep_learning> hpc:  i think 
07:54:43 <keep_learning> its tab character of 
07:54:45 <keep_learning> vim 
07:55:04 <keep_learning> i don't have any other editor for linux 
07:55:05 <hpc> might i suggest using spaces :P
07:55:16 <keep_learning> hpc: i will keep in mind 
07:55:22 <hpc> it looks like it is indented 16 columns
07:55:30 <keep_learning> hpc: buts its my c programming 
07:55:47 <hpc> keep_learning: bust that habit!
07:55:49 <keep_learning> which making things worst 
07:55:49 <hpc> :D
07:57:30 <keep_learning> hpc: i think some good haskell editor for linux will work fine 
07:57:54 <keep_learning> i am trying to install eclipsefp on eclipse 
07:58:05 <keep_learning> but i am not able to install scion 
07:58:08 <hpc> i tried using that; it wasn't so great
07:58:23 <keep_learning> hpc: k
07:58:28 <keep_learning> so what do you use 
07:58:32 * hpc is at the stage where he can't even use notepad on windows without using vim everywhere
07:58:36 <hpc> (vim)
07:58:42 <hpc> *vim keys
07:58:47 <keep_learning> hpc: great 
07:58:55 <keep_learning> hpc: i also use this 
07:59:01 <keep_learning> hpc: but with tabs 
07:59:19 <keep_learning> what do you mean by vim keys 
07:59:41 <keep_learning> is it some thing special in vim for haskell
07:59:45 <aristid> hpc: it's fun when your files contain :w in random locations, eh?
07:59:46 <hpc> 'i' 'a' ^U etc
07:59:50 <hpc> aristid: indeed
07:59:57 <pastorn> hpc: <C-v>
08:00:27 <pastorn> once you start  with visual block every other editor seems like shit
08:00:57 <valium97582> ^[
08:00:58 <hpc> i love visual block
08:01:00 <pastorn> i know know emacs can do it, but every emacs user i've asked don't have  aclue about how to do it
08:01:03 <hape01> hpc: I got emacs ghc running with fly-make, that is nearly the same as EclipseFP   ;-)
08:01:06 <hpc> but i like visual line better
08:01:18 <pastorn> hpc: nah, not paired with case-of
08:01:47 <hpc> pastorn: oh nice
08:01:50 <hpc> i see
08:02:06 <pastorn> hpc: especially when you have an enum-like ADT
08:02:39 <quicksilver> visual-block = rectangle editing?
08:02:44 <hpc> indeed
08:02:48 <pastorn> i always declare my datatypes as "data X;    = A;    | B;    C;"
08:02:56 <valium97582> emacs is for tea drinkers :P
08:03:23 <pastorn> then just copying that block and pasting it, with some minor visual block hacking gives you a proper case-of expression
08:03:24 <hpc> valium97582: there is three times as much tea in the world as coffee :P
08:03:25 <quicksilver> ok, emacs is fine for rectangle editing although you need to use your imagine insofar as the rectangle isn't actually displayed
08:04:03 <valium97582> hpc: damn!
08:04:29 <pastorn> quicksilver: http://www.youtube.com/watch?v=3XYsV4cZCqI
08:04:41 <hpc> (assuming price per unit volume is equal between the two; i only recall the monetary figure)
08:05:14 <quicksilver> pastorn: yup. I do that all the time.
08:05:20 <quicksilver> (in emacs)
08:05:21 <sold> can I import GHC.Prim into ghci?
08:05:25 <sold> and mess around
08:05:32 <pastorn> sold: yes
08:05:58 <pastorn> @faq Are you allowed to import GHC.Prim and mess around?
08:05:59 <lambdabot> The answer is: Yes! Haskell can do that.
08:06:25 <sold> why does 2::Int# give me a parse error
08:06:32 <sold> I need to enable something
08:06:34 <sold> somehere
08:06:35 <quicksilver> you need MagicHash
08:06:36 <sold> rite
08:06:46 <quicksilver> ghci -XMagicHash
08:06:48 <kuffaar> What does the # part do?
08:06:51 <hpc> some whitespace would be nice too
08:06:56 <hpc> 2 :: Int#
08:06:56 <copumpkin> kuffaar: it's just a marker
08:07:00 <quicksilver> or load a file with the language extension
08:07:01 <pastorn> or {-# LANGUAGE MagicHash #-}
08:07:11 <quicksilver> or use :set, probably
08:07:12 <keep_learning> any one 
08:07:14 <hpc> it marks unboxed types
08:07:15 <keep_learning> could tell me 
08:07:22 <copumpkin> kuffaar: it's to make it inconvenient to use primitive operations unintentionally, and to make them stand out :)
08:07:24 <quicksilver> hpc: well, it marks GHC primitives.
08:07:29 <hpc> or that
08:07:32 <quicksilver> including, but not only, unboxed types.
08:07:34 <keep_learning> why my code is going for infinite loop 
08:07:34 <copumpkin> kuffaar: you can name anything you want with # in it if you have MagicHash turned on
08:07:49 <quicksilver> keep_learning: nobody, until you show us the code.
08:07:57 <copumpkin> http://hpaste.org/43165/elliptic_curve_montgomery
08:08:02 <keep_learning> http://hpaste.org/43165/elliptic_curve_montgomery
08:08:03 <hpc> quicksilver: he did, up above; then i picked a tabular nit
08:08:10 <keep_learning> sorry for indentation 
08:08:22 <keep_learning> but my tabs are 4 spaced apart 
08:08:25 <copumpkin> keep_learning: I'm going to guess it's the factor function
08:08:29 <copumpkin> factor n cnt | cnt>=10 = return [n]
08:08:31 <keep_learning> yes 
08:08:38 <copumpkin> your base case is not stopping
08:08:55 <keep_learning> copumpkin: why ?
08:08:56 <copumpkin> or rather, what if it goes to 0 or below?
08:09:05 <copumpkin> I have no clue how the algorithm is working
08:09:15 <copumpkin> I'm just guessing and looking for obvious red flags
08:09:17 <keep_learning> i think its increasing in every case 
08:09:34 <copumpkin> n is decreasing isn't it?
08:09:37 <keep_learning> copumpkin: http://programmingpraxis.com/2010/04/23/modern-elliptic-curve-factorization-part-1/
08:09:40 <copumpkin> you have a base case of 1
08:09:47 <keep_learning> http://programmingpraxis.com/2010/04/27/modern-elliptic-curve-factorization-part-2/
08:10:30 <copumpkin> it's a lot of code, and I don't have the time right now to read all the articles and match them up to your code
08:10:36 <keep_learning> copumpkin: that is for n 
08:10:36 <keep_learning> if my cnt is more than 10 then 
08:10:38 <keep_learning> return 
08:10:39 <quicksilver> hmm. That's a lot of code to follow. Did you test the subfunctions independently?
08:10:45 <keep_learning> this is my base case
08:10:56 <copumpkin> keep_learning: I'm saying, are you positive n is never 0?
08:11:03 <copumpkin> and why not put a case in for that
08:11:37 <copumpkin> (and [1<p,p<n]) ==> 1 < p && p < n
08:11:46 <copumpkin> why put it in a big case block instead of an if
08:12:01 <napping> Hi, does anyone here know about powerdomains?
08:12:06 <keep_learning> copumpkin: i think yes because no factor will make it zero but not certain
08:12:28 <copumpkin> keep_learning: I'd take each function separately and try running it and see which one hangs :)
08:12:29 <keep_learning> copumpkin: let me remove the statement
08:12:47 <keep_learning> copumpkin: i think this idea is great 
08:13:06 <keep_learning> i never thought abt it
08:13:06 <keep_learning> :) 
08:13:06 <keep_learning> thank you
08:13:10 <keep_learning> i am going to do this 
08:13:18 <copumpkin> :)
08:13:24 * copumpkin gives all credit for the inspiration to quicksilver 
08:13:29 <kuffaar> What happens when you have case statements or guards which do not cover all possible cases?
08:13:40 <Entroacceptor> valium97582: I drink tea!
08:13:50 <copumpkin> kuffaar: you get a runtime crash or possible a compile-time warning if you have the warning turned on
08:13:58 <napping> kuffaar: an exception at rutnime!
08:14:01 <kuffaar> I'm a -Waller
08:14:10 <copumpkin> kuffaar: then it will warn you
08:14:19 <napping> (that's not a crash as in segfault crash)
08:14:20 <fryguybob> > case 1 of 0 -> []
08:14:21 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
08:14:24 <sold> nice
08:14:35 <sold> I will have fun with this for a while
08:14:39 <keep_learning> * thanks to quicksilver also :)
08:14:52 <kuffaar> Although in general it can't warn you, can it? Since that would ultimately depend on solving the halting problem at compile time?
08:14:58 <napping> kuffaar: I tried that network stuff in windows, and also saw that listenOn seemed to only listen on the IPv6 address
08:15:04 <copumpkin> kuffaar: no, it can
08:15:05 <kuffaar> napping yep :)
08:15:17 <napping> No, it warns you if you leave you any constructor for the type
08:15:34 <kuffaar> I was more thinking of stuff like rankes for Int's, for example
08:15:35 <napping> it doesn't try to be especially clever about deciding that a constructor can't actually occur
08:15:40 <kuffaar> Right
08:15:44 <napping> Neil Mitchell's "catch" can do some things like that
08:15:45 <kuffaar> That wouldn't be possible
08:15:55 <kuffaar> ERr, ranges*
08:15:59 <napping> GHC *might* if you are working with GADTs, and your signature makes some constructors impossible
08:16:07 <napping> oh, and guards are almost entirely ignored
08:16:15 <kuffaar> napping I ended up using Network.Socket directlry for this stuff to get IPv4 for it
08:16:30 <copumpkin> napping: it won't even let you write impossible constructor combinations as of 7, which makes me happy
08:16:48 <copumpkin> pre-7 it just warned you about impossible combinations
08:16:48 * kuffaar uses ghc 7
08:16:51 <napping> copumpkin: really?
08:17:12 <napping> it might be easier with just GADTs, I guess
08:17:12 <copumpkin> if I write data Zomg a where IsBool :: Zomg Bool; IsInt :: Zomg Int
08:17:34 <copumpkin> and f :: Zomg a -> Zomg a -> a; f IsBool IsBool = True; f IsInt IsInt = 5
08:17:53 <copumpkin> it won't warn about incomplete patterns, and if I try to write f IsBool IsInt = undefined
08:17:57 <copumpkin> it'll give me an error
08:18:24 <copumpkin> I had a bit of a discussion on whether it should be an error or not with SPJ and he was arguing that it shouldn't be
08:18:28 <napping> I guess I was thinking Agda, where it's not always immediately obvious a pattern is impossible
08:18:37 <copumpkin> but then GHC 7 magically made it an error anyway, so he let it go for the moment
08:19:25 <copumpkin> napping: well things like Fin 0 are not really doable in haskell just because we don't have an empty function/absurd pattern
08:19:32 <kuffaar> @quote SPJ cheerful
08:19:33 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
08:19:37 <Egbert9e9> http://www.haskellforjustice.com/
08:19:44 <napping> all the examples that come to mind invovle dependent types
08:20:01 <Egbert9e9> http://www.insiderpages.com/b/15245428471/haskell-justice-of-peace-haskell
08:20:04 <mkscrg> Haskell beginner: Is there a standard datatype that's better than a list (efficiency-wise) for frequent access to both ends but not to the middle?
08:20:06 <napping> like, needing a further match on a purported element of Lt a Zero to decide it's absurd
08:20:19 <quicksilver> mkscrg: Data.Sequence - Seq
08:20:32 <mkscrg> quicksilver: Thanks!
08:20:35 <quicksilver> mkscrg: very efficient at each end, and actually fairly efficient in the middle.
08:20:38 <Egbert9e9> oh, it's not for justice but for great good
08:20:45 <dafis> keep_learning: in rabinMiller: b0 = mod (a^m) n
08:20:50 <quicksilver> mkscrg: O(1) at the ends, O(log n) in the middle
08:21:00 <dafis> keep_learning: imagine n = 2^137-1
08:21:10 <napping> kuffaar: I think Network is usually a little too basic for what you actually want
08:21:17 <jmcarthur> copumpkin: wait, so the "GADT pattern matching issue" is fixed in 7? i hadn't even noticed!
08:21:20 <mkscrg> quicksilver: Awesome. That exactly fits the bill!
08:21:23 <napping> did you ever figure out why you seemed to be able to bind the same pattern multiple times?
08:21:46 <copumpkin> jmcarthur: yeah, but it's not definitely going to keep the current behavior for giving an error on impossible patterns
08:21:55 <kuffaar> napping no, and I haven't checked out if it works properly with the one I use now
08:22:00 <keep_learning> dafis: prime = 2:filter rabinMiller  [3,5..]
08:22:07 <jmcarthur> copumpkin: at least a warning though?
08:22:16 <napping> copumpkin: isn't the current behavior kind of forced if you try to unify the signature with the types derived from the patterns?
08:22:31 <jmcarthur> as long as it doesn't give me warnings when i leave off a pattern i know to be impossible, i'm happy
08:22:33 <keep_learning> dafis: that n is different from number to factorise 
08:22:45 <keep_learning> dafis: sorry for same notation 
08:23:26 <keep_learning> dafis: i implemented this long ago so i did not change the parameter 
08:23:28 <copumpkin> napping: that's what I was arguing
08:23:39 <copumpkin> napping: but he seemed to favor just giving a warning
08:23:54 <napping> I don't understand how it would be possible to continue
08:24:07 <napping> well, I gues you could realize the case is absurd and skip it entirely or something
08:24:23 <copumpkin> yeah, it'll warn you about it being unreachable
08:24:25 <copumpkin> but let you write it
08:24:30 <keep_learning> [an,ad,u,v]=  montgomeryCurve 234  [182,140,170,118] 
08:24:36 <napping> but that would be a bit strange - it's not like you can write if False then head True else "blah"
08:24:57 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3927
08:24:57 <keep_learning> dafis: ellipticFac 10 100 (Cone 182 140 234) (Conp 170 118)  
08:25:03 <napping> and I don't see how you could get a sane context for typechecking that branch
08:25:09 <napping> oh well
08:25:16 <keep_learning> this is also going to infinite loop
08:25:20 <copumpkin> that's the ticket where we discussed it
08:25:20 <jmcarthur> i agree, it doesn't make sense
08:25:27 <napping> So, does anyone know how to build a denotational semantics with laziness and nondeterminism?
08:25:35 <copumpkin> but if you have an opinion on the matter, please feel free to chime in on that ticket
08:25:51 <copumpkin> I am very pleased with the current state of affairs regarding GADT pattern matching
08:26:12 <quicksilver> copumpkin: unsatisfiable constraints are a similar issue, aren't they? ([a] ~ Maybe b) => ...
08:26:31 <copumpkin> quicksilver: yeah, I guess. does GHC reject those?
08:26:31 <quicksilver> copumpkin: I don't think they short-circuit immediately, they just turn out to be useless
08:26:47 <j-invariant> CAn I aske a math question here
08:26:56 <j-invariant> you guys are smarter than the other channel :)
08:27:18 <copumpkin> quicksilver: nope, error
08:27:51 <quicksilver> copumpkin: interesting, but I didn't mean one that you typed literally
08:28:04 <quicksilver> copumpkin: I meant one that came about in the process of unification
08:28:24 <napping> I guess you can't write empty cases.
08:28:43 <napping> data T a where C :: T Int; test :: T Bool -> Bool; test v = case v of {}
08:29:23 <copumpkin> yeah
08:29:38 <copumpkin> it's kind of nice though:
08:29:39 <copumpkin> <interactive>:1:44:
08:29:39 <copumpkin>     Couldn't match type `[]' with `Maybe'
08:29:39 <copumpkin>     Inaccessible code in the type signature for `f'
08:30:03 <quicksilver> copumpkin: hmm, that is quite nice.
08:30:03 <copumpkin> j-invariant: sure :P
08:30:21 <quicksilver> copumpkin: my guess is that the direction SPJ wanted to take the type checker anyway lead to you winning the argument ;)
08:30:29 <j-invariant> there is this news report that says Ken Ono found a formula for the partition function
08:30:31 <quicksilver> copumpkin: he was defeated by his own code!
08:30:44 <j-invariant> is that so? I wonder what is happening with it
08:31:09 <quicksilver> napping: there was a feature request for empty cases. Might have been a haskell-prime ticket?
08:31:36 <copumpkin> data Empty where
08:31:37 <copumpkin>   No :: (Maybe a ~ [a]) => a -> Empty
08:31:39 <copumpkin> :P
08:32:03 <napping> undefined :: Emtpy
08:32:04 <dafis> keep_learning: found a loop: g =mod (g*z') n in ellipticFac
08:32:04 <quicksilver> napping: http://hackage.haskell.org/trac/ghc/ticket/2431
08:32:08 <copumpkin> napping: yeah, obviously
08:32:13 <j-invariant> "Our work brings completely new ideas to the problems," says Ono, who will explain the findings in a public lecture at 8 p.m. Friday on the Emory campus. "We prove that partition numbers are 'fractal' for every prime. These numbers, in a way we make precise, are self-similar in a shocking way. Our 'zooming' procedure resolves several open conjectures, and it will change how mathematicians study partitions."
08:32:19 <copumpkin> it's just a cute way to make a pseudoempty type
08:32:21 <napping> do, maybe you need to catch something?
08:32:44 <napping> j-invariant: sorry, that's not the sort of math we would be expected to know anything about
08:32:49 <keep_learning> dafis: i did not get u 
08:33:11 <j-invariant> napping: number theory
08:33:27 <j-invariant> napping: partitions a one of the fundamentals
08:33:41 <dafis> keep_learning: let g = mod (g*z') n; g is defined in terms of itself => loop
08:33:50 <j-invariant> anyway i dont want to b e off topic so I beter not  go on about it
08:34:01 <j-invariant> I wish I culd find more information
08:34:10 <keep_learning> dafis: ok, it means it is loop 
08:34:24 <keep_learning> dafis: can this be used as self updating variable 
08:34:56 <keep_learning> where seed is updated every time
08:34:56 <keep_learning> rather than using foldl fun seed list 
08:35:26 <dafis> keep_learning: Sorry, I don't understand
08:36:07 <keep_learning> g = gcd g n 
08:36:09 <keep_learning> dafis: is loop 
08:36:27 <keep_learning> so does it mean that 
08:36:34 <keep_learning> it updates everytime 
08:36:49 <hpc> keep_learning: no; g never changes value
08:36:58 <keep_learning> hpc: so its in loop 
08:37:28 <hpc> don't think of it as a loop though; think of it as the value of g not being realizable
08:37:43 <dafis> keep_learning: loop as in bottom = bottom
08:37:46 <hpc> since it can't compute it, it does something dumb
08:37:53 <hpc> in this case, nontermination
08:37:57 <hpc> in other cases, it could crash
08:38:00 <dafis> keep_learning: nontermination
08:38:14 <keep_learning> dafis: thank you 
08:38:22 <keep_learning> dafis: lesson learned 
08:38:37 <hpc> so when we say x = x + 1, we don't increment x
08:38:49 <hpc> we are instead saying that x and x + 1 must be the same value
08:39:06 <kuffaar> Right, in order to increment x you have to use x += 1; in Haskell
08:39:11 <kuffaar> Or simply x++;
08:39:29 <hpc> no; once you say x = 1, it is 1
08:39:40 <hpc> to change the value later would make you a liar :P
08:39:45 <keep_learning> *thank you all for help 
08:40:08 <keep_learning> long way to go for Haskell 
08:40:26 <kuffaar> Yes, at least 2-4 years until you get out of the hello world stage
08:40:33 <hpc> so if you wanted to write "for (x = 0; x < 4; x++) {print "foo";}"
08:40:53 <hpc> in haskell that would be loop = loopx 0
08:41:11 <hpc> loopx n = print "foo" >> loopx (n+1)
08:41:16 <hpc> loopx 4 = return ();
08:41:23 <hpc> er, minus the semicolon
08:41:33 <kuffaar> Explicit recursion, urgh :(
08:41:39 * quicksilver would write forM_ [0..3] (print "foo")
08:41:40 <hpc> there's other ways to do it
08:41:46 <kuffaar> quicksilver yeah
08:41:50 <hpc> but that's just to prove a point
08:41:55 <quicksilver> if I wanted to give the translation closest to the C code.
08:41:58 <kuffaar> Why () over $ though?
08:42:04 <kuffaar> :t forM_
08:42:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
08:42:11 <quicksilver> kuffaar: one less thing to confuse the explanation with.
08:42:14 <kuffaar> Ah it's already ()
08:42:41 <kuffaar> forM_ [1..4] $ print "hay"
08:42:41 <quicksilver> for (x=0;x < 4;x++) {print x;} is probably more interesting though.
08:42:47 <aristid> :t forM_ [0..3] (print "foo")
08:42:48 <dafis> :t replicateM
08:42:49 <lambdabot>     Couldn't match expected type `t -> m b'
08:42:49 <lambdabot>            against inferred type `IO ()'
08:42:49 <lambdabot>     In the second argument of `forM_', namely `(print "foo")'
08:42:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:42:55 <aristid> :t forM_ [0..3] (const $ print "foo")
08:42:56 <lambdabot> IO ()
08:43:06 <aristid> quicksilver: :P
08:43:08 <dafis> :t replicateM_
08:43:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
08:43:10 <kuffaar> Oh?
08:43:56 <mercury^> > mapM_ print $ replicate 4 "foo"
08:43:57 <lambdabot>   <IO ()>
08:44:25 <quicksilver> aristid: good point.
08:44:40 <kuffaar> I have no idea what const does
08:44:54 <copumpkin> > const 5 7
08:44:55 <aristid> kuffaar: const x = \_ -> x
08:44:55 <lambdabot>   5
08:45:00 <copumpkin> > const 5 undefined
08:45:01 <lambdabot>   5
08:45:08 <kuffaar> Oh
08:45:27 <mercury^> I think replicate should have a shorter name.
08:45:37 <copumpkin> copumpkin's identity (because I'm good at stating the obvious) = const id = flip const
08:46:04 <mercury^> copumpkin: they are not isotypic.
08:46:09 <hpc> i vaguely recall const id having lower overhead
08:46:12 <quicksilver> mercury^: we could call it repRap
08:46:17 <hpc> :t const id
08:46:18 <lambdabot> forall a b. b -> a -> a
08:46:20 <hpc> :t flip const
08:46:20 <lambdabot> forall b a. a -> b -> b
08:46:22 <kuffaar> replicate is alright
08:46:41 <kuffaar> I'm generally a friend of long and verbose names over pStrMinLn2_''
08:46:54 <kuffaar> Or ParseT u s m a
08:47:00 <hpc> kuffaar: oh god, the C++ memories
08:47:02 <copumpkin> kuffaar: names get in the way of getting a feel for the "Shape" of the code
08:47:11 <copumpkin> we often try to avoid naming things altogether when possible
08:47:12 <hpc> :t (=~) -- or this, kuffaar
08:47:14 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
08:47:20 * quicksilver hands kuffaar an AbstractEnterpriseFactoryBuilderFactory.
08:47:32 <kuffaar> quicksilver that's how I write Haskell
08:47:36 <copumpkin> mercury^?
08:47:44 <aristid> (cadddadadr 'AbstractEnterpriseFactoryBuilderFactory)
08:47:44 <napping> copumpkin: Would you like a fine DeBruijn notation?
08:47:57 <kuffaar> aristid lol
08:48:00 <copumpkin> napping: indeed!
08:48:15 <kuffaar> aristid that would probably cause an error, no?
08:48:25 <aristid> kuffaar: only at runtime.
08:48:29 <kuffaar> Hahaha.
08:48:36 <jmcarthur> AbstractStrategyFactory!  http://it.slashdot.org/comments.pl?sid=194161&cid=15916702
08:48:41 <kuffaar> Yeah, filthy dynamically typed languages :[
08:48:46 <napping> copumpkin: http://www.e-pig.org/epilogue/?p=773
08:49:04 <mercury^> copumpkin: they types that ghc prints fail a string comparison at least.
08:49:10 <mercury^> the*
08:49:23 <copumpkin> mercury^: well, I was just talking about how names deceive!
08:49:43 <copumpkin> napping: oh yeah, I like that :)
08:49:44 <kuffaar> Rasterised images of code. Really. With edgy cursive fonts.
08:50:11 <napping> copumpkin: so, can humans be upgraded?
08:50:40 <copumpkin> definitely
08:50:47 <copumpkin> I got upgraded when I came across haskell
08:51:20 <napping> I don't think I've seen DeBruijn indices in haskell
08:51:32 <napping> I guess you could hack the pretty-printer if you like
08:51:42 <copumpkin> I've written them
08:51:46 <copumpkin> even the strongly typed ones
08:52:20 <copumpkin> data Var g t where
08:52:20 <copumpkin>   Zero :: Var (t, g) t
08:52:20 <copumpkin>   Suc  :: Var g t -> Var (b, g) t
08:52:29 <napping> sure, but that's not the default output
08:52:33 <copumpkin> oh, fine
08:52:35 <copumpkin> :P
08:52:46 <napping> I think it was some of the early epigram prototypes that counted the number of binders
08:52:53 <napping> and being dependently types, -> counted
08:53:04 <copumpkin> ah, I see
08:54:28 <napping> nice types like \all \all (1 -> 1) -> (2 -> 2) 
08:55:03 <napping> being more conventionally written (a -> b) -> (a -> b)
09:08:06 <napping> with a finite directed set, the lub is just one of the members, right?
09:08:42 <tac-tics> Sounds about right
09:09:04 <tac-tics> Prove it. Shouldn't be hard.
09:15:01 <tac-tics> actually, take the finite directed set "", "a", "b", where <= is the substring relation
09:15:47 <napping> that's not directed
09:15:47 <tac-tics> I think
09:15:58 <napping> what's the upper bound on "a","b"
09:16:17 <gwern> @quote Amador
09:16:17 <lambdabot> gwern says: there are no beginnings or ends to the circular list; but a cons cell thunked in Amador...
09:16:28 <gwern> hah. so someone did @remember it
09:16:41 <tac-tics> I'm not familiar with the concept, I'm just working with the definitions
09:16:48 <napping> wasn't that quoted in HWN?
09:17:31 <quicksilver> napping: I'm pretty sure the lub of the set is what you get by folding lub over the members (doesn't matter what order) but I can't prove that off the top of my head.
09:18:26 <napping> quicksilver: that's what I tried first, but not every pair of elements has a join
09:18:40 <napping> though, I guess if they have an upper bound they happen to
09:19:06 <napping> well, I'm just finding the maximum by my ordering
09:19:37 <napping> I'm writing some code to explicitly calculate some domain constructions on lists of at most 2 elements
09:19:42 <ksf> ...in case any tunesians are around: While I'm all glad for the revolution and all and I _really_ like your new minister for youth+sport, YOU ARE GOING TO LOSE THIS HANDBALL GAME.
09:20:19 <copumpkin> ksf: o.O
09:21:13 <quicksilver> napping: well, I should have said 'upper bound' not 'lub'
09:21:23 <quicksilver> napping: they all have an upper bound because that's what directed means.
09:21:39 <napping> yeah, I think it's pretty simple if I'm working with finite lists
09:22:09 <quicksilver> and yes, in fact, I can see the proof. That constructs something which is definitely >= every element, and it is an elemtn
09:22:39 <quicksilver> hmm
09:22:48 <quicksilver> that doesn't give you a unique lub.
09:22:56 <quicksilver> it might be only up to equivalence.
09:23:09 <monochrom> up to equality
09:23:28 <napping> as long as the order is antisymmetric, yes
09:23:41 <napping> which mine is, whether or not that's requried
09:24:27 <monochrom> and of course, up to equality = unique
09:24:50 <quicksilver> monochrom: in a preorder a <= b and b <= a does not mean they are equal, does it?
09:25:07 <monochrom> partial order
09:25:15 <quicksilver> directed sets are merely preorders though
09:25:25 <quicksilver> unless I've lost a step somewhere.
09:25:49 <quicksilver> it sounds like napping's one happesn to be a partial order so that's fine.
09:26:10 <napping> yeah, I'm actually looking for directed subsets of a domain
09:32:43 <napping> If I start with a finite subset of a partial order, then being closed under lubs of directed subsets of that set is trivial
09:53:42 <kuffaar> What's the equivalent of argv[0] in Haskell?
09:53:43 <aristid> @hoogle getArgs
09:53:43 <lambdabot> System.Environment getArgs :: IO [String]
09:53:43 <aristid> kuffaar: ^
09:53:44 <kuffaar> getArgs starts at argv[1]
09:53:45 <aristid> oh.
09:53:53 <aristid> sorry, then, don't know that
09:54:01 <kuffaar> :(
09:54:53 <zygoloid> getProgName
09:55:06 <zygoloid> @hoogle getProgName
09:55:07 <lambdabot> System.Environment getProgName :: IO String
09:55:11 <kuffaar> Ah, thanks
09:55:18 <zygoloid> kuffaar: but be warned that it strips off the path (iirc)
09:55:30 <kuffaar> Oh well
09:55:53 <aristid> argv[0] sometimes contains the path and sometimes not, anyways
09:58:33 <kuffaar> How is a . b c parsed?
09:58:38 <kuffaar> Is it a . (b c)?
09:58:42 <kuffaar> Or (a . b) c?
09:58:48 <sipa> a . (b c)
09:58:57 <sipa> function application binds tighter than anything else
09:59:02 <kuffaar> Oh, right
09:59:07 <sipa> except :: maybe
10:01:23 <aristid> i think :: binds pretty losely
10:06:03 <c_wraith> :: scopes over the entire preceeding expression
10:09:15 <gwern> "In the Haskell wiki [11], we have found allusions to a library SerTH that allegedly supports cyclic data structures and uses template haskell. The provided links are however not accessible any more. This library seems to have perished (including all substantial information about its implementation techniques)."
10:09:22 <gwern> hah! you all laughed at me for my packrat days
10:09:28 <gwern> but now - now I have a copy of SerTH
10:09:30 <gwern> and you don't
10:09:50 <gwern> BWA HA HA THE WORLD IS MINE
10:11:01 <kuffaar> gwern: Haskell 0day warez?
10:11:29 * gwern pwns 411 ur 53p05
10:11:45 <kuffaar> sepos?
10:11:49 <kuffaar> Repositories?
10:12:16 <gwern> 5 can also be an R
10:13:21 <azaq23> System.Environment.getProgName
10:13:48 <kuffaar> Yep, already got it working, thanks
10:14:57 * azaq23 is sometimes scrolled up in pidgin and doesn't notice that the conversation went on already
10:15:16 <gwern> anyone else want a copy of serth while I'm at it?
10:16:33 <gwern> no?
10:16:39 <gwern> speak now or do be holding your peace
10:20:32 <kuffaar> Can you make \x y -> length x < length y any shorter?
10:20:39 <kuffaar> I don't really like mentioning length twice
10:20:46 <kuffaar> This is for a sortBy, by the way
10:20:57 <copumpkin> (<) `on` length
10:21:03 <medfly> aww
10:21:13 <kuffaar> :t (<) `on` length
10:21:14 <lambdabot> forall a. [a] -> [a] -> Bool
10:21:25 <kuffaar> It takes two lists, huh
10:21:33 <kuffaar> Oh, the Strings
10:21:35 <kuffaar> Of course
10:21:45 <kuffaar> Thanks, that's cute
10:22:02 <kuffaar> Although I don't know why I would want to use infix there
10:22:02 <djahandarie> @type length
10:22:04 <lambdabot> forall a. [a] -> Int
10:22:09 <kuffaar> Of course, yeah
10:22:23 <kuffaar> I just forgot about type String = [Char] -- :p
10:23:16 <djahandarie> @type on
10:23:18 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:29:45 <j-invariant> ex. prove that e_X : X^S x S -> X defiend by e(h,s) = h(s) is a natural transformation
10:30:02 <artagnon> How do I unwrap several monadic layers to apply a function? I use (>>=) for one layer.
10:30:04 <j-invariant> so in haskell how do you define the functor
10:30:19 <j-invariant> type Eval x = (x -> s,s) -> x
10:30:32 <j-invariant> is it a covariant
10:30:48 <j-invariant> artagnon: join :: m (m a) -> m a
10:31:07 <kuffaar> Configuring AfraidParser-0.1...
10:31:07 <kuffaar> Segmentation fault/access violation in generated code
10:31:08 <Baughn> P == NP, possibly..
10:31:12 <kuffaar> Two times in a row already :(
10:31:22 <kuffaar> Yay, it worked the third time
10:31:31 <copumpkin> Baughn: unlikely
10:31:34 <j-invariant> Baughn: I hate how people always comment "I don't undersatnd the first god damn thing about any of this but it's probalby wrong! because .. I am so skeptical"
10:31:35 <artagnon> j-invariant: Thanks :) And what if they're different monads?
10:31:51 <Baughn> copumpkin: We'll see.
10:32:01 <j-invariant> data Ev s x = Ev (x -> s,s)
10:32:15 <Baughn> copumpkin: It's certainly an interesting algorithm. I'm trying to go over it. :)
10:32:30 <artagnon> ie. I need :: m (m1 a) -> (a -> b) -> m (m1 b)
10:32:46 <j-invariant> instance Functor (Ev s) where fmap (f :: a -> b) (Ev (g,x) :: Ev s a) = Ev (g,f x):: Ev s b
10:32:51 <j-invariant> am I on the right lines here 
10:33:13 <j-invariant> maybe it should be Ev (f . g,x)
10:33:18 <copumpkin> artagnon: fmap . fmap (flipped)
10:33:20 <j-invariant> but how could it be a natural transofrmati[n
10:33:32 <j-invariant> because it's  FX -> X  rather than  X -> FX
10:33:35 <napping> j-invariant: that's not going to be a functor
10:33:36 <lunaris> artagnon: Is it not just liftM . liftM?
10:33:39 <lunaris> :t liftM . liftM
10:33:40 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
10:33:52 <napping> the "x" is left of the arrow
10:34:01 <j-invariant> so it is a covaraint functor
10:34:04 <napping> you can't make a function y -> s from a function x -> s and a function x -> y
10:34:10 <j-invariant> i.e. a functor in ^op
10:34:13 <lunaris> artagnon: (Flipped)
10:34:18 <zygoloid> Baughn: published somewhere?
10:34:23 <artagnon> copumpkin, lunaris: Got it. Thanks :D
10:34:32 <lunaris> artagnon: Np
10:34:43 <Baughn> zygoloid: http://science.slashdot.org/story/11/01/20/1546206/Polynomial-Time-Code-For-3-SAT-Released-PNP?from=rss
10:35:00 <j-invariant> here is my code
10:35:00 <j-invariant> data Ev s x = Ev (s -> x,s)
10:35:00 <j-invariant> instance Functor (Ev s) where fmap f (Ev (g,x)) = Ev (f . g,x)
10:35:08 <mafs> How would I go about mapping an argument to a list of functions?
10:35:12 <j-invariant> fmap id = id
10:35:19 <lunaris> mafs: As in the swing function?
10:35:23 <j-invariant> fmap f . fmap g = fmap (f . g)
10:35:36 <j-invariant> napping: I think I fixed it now 
10:35:38 <j-invariant> is that okay?
10:35:46 <lunaris> > let swing = flip . (. flip id)
10:35:47 <lambdabot>   not an expression: `let swing = flip . (. flip id)'
10:35:53 <lunaris> let swing = flip . (. flip id)
10:35:55 <deech> Hi all, where does c2hs look for C header files found on Windows? I am trying to install glade and it complains that it can't find glade/glade.h. I have added the library path to C_INCLUDE_PATH and INCLUDE at the DOS prompt. Is there something else I should be doing?
10:35:55 <lunaris> :t swing
10:35:56 <lambdabot> Not in scope: `swing'
10:36:06 <tswett> @index on
10:36:07 <lambdabot> bzzt
10:36:08 <lunaris> :t let swing = flip . (. flip id) in swing map
10:36:09 <lambdabot> forall a b. [a -> b] -> a -> [b]
10:36:12 <lunaris> That's better
10:36:18 <tswett> Where's the "on" function go?  :(
10:36:38 <lunaris> Data.Function?
10:37:00 <j-invariant> ev :: forall s. forall x. Ev s x -> x
10:37:00 <j-invariant> ev (Ev (g,x)) = g x
10:37:02 <napping> Baughn: new rule - any paper claing an algorithm for P = NP needs to be digitally signed by e.g. the Veritrust root certificate
10:37:08 <j-invariant> does that prove the functor  Ev s  is a natural transformation?
10:37:11 <sipa> napping: lol
10:37:24 <j-invariant> napping: why not just have a computer checkabel proof
10:37:50 <napping> not as showy
10:38:04 <tswett> Any paper claiming an algorithm for P = NP needs to be digitally signed by the Coq kernel.  :P
10:38:45 <j-invariant> so I guess map f . ev = ev . f
10:38:52 <j-invariant> i.e. my function ev is natural
10:38:56 <j-invariant> because of free theorem
10:39:03 <_mpu> :t flip id
10:39:06 <lambdabot> forall a b. a -> (a -> b) -> b
10:40:11 <_mpu> :t flip . (. flip id)
10:40:11 <lambdabot> forall a b a1 b1. (((a1 -> b1) -> b1) -> a -> b) -> a -> a1 -> b
10:40:18 <lunaris> _mpu: It's a corker isn't it :)
10:40:44 <_mpu> lunaris: I just can't understand without the lambdabot 
10:40:53 <lunaris> _mpu: There's some elaboration on http://www.haskell.org/haskellwiki/Pointfree
10:41:01 <lunaris> _mpu: I can't take credit :)
10:41:11 <_mpu> :)
10:41:19 <lunaris> The owl combinator is also good
10:41:24 <lunaris> :t (($).($))
10:41:25 <lambdabot> forall a b. (a -> b) -> a -> b
10:41:33 <lunaris> Sorry
10:41:34 <lunaris> I mean
10:41:38 <lunaris> :t ((.)$(.))
10:41:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
10:41:50 <lunaris> Which is:
10:42:06 <lunaris> :t let f a b c d = a b (c d) in f
10:42:07 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2) -> t -> (t3 -> t1) -> t3 -> t2
10:42:19 <djahandarie> That combinator is my warning of when I'm hitting the strip club too often
10:42:30 <lunaris> Ah
10:42:33 <lunaris> I've messed it up.
10:42:36 <lunaris> Regardless.
10:42:39 <djahandarie> > ((.)$(.)) (pure id)
10:42:41 <lambdabot>   No instance for (GHC.Show.Show (f (f1 a -> f1 a)))
10:42:41 <lambdabot>    arising from a use of...
10:43:08 <artagnon> Network.Browser.browse $ request $ getRequest :: IO (Network.URI.URI, Response String) and getResponseBody :: Result (Response ty) -> IO ty
10:43:27 <artagnon> I'm stuck- I don't know how to get the response body.
10:43:45 <artagnon> I did a liftM snd to get the Response String, but what after that?
10:44:00 <artagnon> It needs to be wrapped in Result for getResponseBody to act on it
10:44:16 <lunaris> You have an IO (a, Response b) and a Result (Response b) -> IO b.
10:44:18 <lunaris> So...
10:44:22 <lunaris> *Lag*
10:44:31 <lunaris> You're in the IO monad
10:44:41 <artagnon> Ok, so what should I do?
10:45:09 <lunaris> artagnon: I wish I was that fast -- I'm a Celeron of the man I used to be.
10:45:22 <artagnon> np :)
10:45:29 <artagnon> I essentially have to get out of the IO monad and wrap the rest in a Result monad.
10:46:08 <djahandarie> > join $ ((.)$(.)) (return id) <*> (return "x")
10:46:12 <lambdabot>   "x"
10:46:31 <lunaris> Is it (perhaps...): (>>= getResponseBody) . liftM snd?
10:47:14 <lunaris> Which might be neater if you use an alternative to (>>=) -- (>=>, <=<; I must confess I'm not good enough to do this out of my head)
10:47:19 * lunaris fires up GHCI
10:47:23 <artagnon> lunaris: That won't work because liftM snd ... :: IO (Response String)
10:47:33 <lunaris> I see.
10:47:35 <mafs> lunaris: oops, sorry about that--had a phone call to take. Wasn't aware of the swing function (though map ($ a) [function] seems to work)
10:47:46 <artagnon> I need to unwrap it from the IO and THEN lift it to Response.
10:48:05 <lunaris> (>>= getResponseBody . return) . liftM snd?
10:48:07 <lunaris> Hacking here.
10:48:12 * artagnon tries that
10:48:15 <lunaris> *Code explosion*
10:48:48 <artagnon> Nope, doesn't work either.
10:49:01 <artagnon> Oh wait
10:49:10 <artagnon> Nice! It works :D
10:49:16 <lunaris> Ok.
10:49:19 <artagnon> Thanks lunaris!
10:49:29 <lunaris> There may be functions in Control.Monad that make it neater.
10:49:35 <lunaris> I'm not sure.
10:49:37 <kuffaar> Question about Haskell style: Do you separate top level type/data/function statements from each other? Like, for example, all data statements first, then the type homonyms, then the top level functions? (within a Haskell source code file)
10:49:48 <napping> kuffaar: no
10:49:55 <lunaris> kuffaar: I lay them out as they are related to each other.
10:50:03 <artagnon> lunaris: I didn't understand how it works though -- doesn't `return` wrap (as opposed to unwraping)?
10:50:04 <lunaris> kuffaar: As in, if the module exports a type, define it.
10:50:15 <lunaris> kuffaar: Then the functions that operate on it, etc.
10:50:18 <napping> generaly some related data definitions and type synonyms and classes are mixed together
10:50:23 <lunaris> artagnon: return puts something into the monad.
10:50:28 <lunaris> artagnon: Here, it's the Response monad
10:50:38 <lunaris> artagnon: So, you have (>>= getResponseBody . return) . liftM snd
10:50:51 <artagnon> lunaris: Ah, but don't we need to unwrap IO first?
10:50:58 <artagnon> Before putting it in Reponse ie.
10:51:09 <lunaris> artagnon: liftM snd takes an IO (a, Response b)  and gives you IO (Response b)
10:51:19 <lunaris> artagnon: That goes into (>>= getResponseBody . return)
10:51:20 * artagnon nods
10:51:26 <artagnon> Ok, then?
10:51:27 <lunaris> artagnon: >>= unwraps the IO bit
10:51:36 <lunaris> artagnon: So you have Response b going into getResponseBody . return
10:51:41 <Egbert9e9> is cabal capable of automatic installation of dependencies?
10:51:42 <lunaris> artagnon: return lifts that into the Result monad
10:51:52 <artagnon> Ah, so the (>>=) acts first, eh?
10:51:52 <lunaris> artagnon: Finally, getResponseBody does its thing
10:51:57 <artagnon> I thought return would act first.
10:51:58 <lunaris> artagnon: Yes, it's a section
10:52:24 <lunaris> artagnon: It's this: \x -> x >>= \y -> getResponseBody (return y)
10:52:32 <lunaris> artagnon: x :: IO (Response b)
10:52:36 <lunaris> artagnon: So y :: Response b
10:52:49 <ksf> kuffaar, I write them as they come and then, when cleaning up, try to make sense.
10:52:54 <artagnon> lunaris: Got it. >>= is a special case then.
10:52:56 <lunaris> artagnon: getResponseBody expects Result (Response b), so that tells return it's putting something in the Result monad.
10:52:59 <kuffaar> Very well
10:53:12 <lunaris> artagnon: It's just a partial application, kind of like (== 3)
10:53:13 <ksf> premature code cleanup is the root of all procrastination.
10:53:17 <artagnon> In a general moo . foo $ string, foo acts first and then moo acts, right?
10:53:20 <dcoutts_> Egbert9e9: yes, try: cabal install blah [--dry-run]
10:53:32 <Egbert9e9> dcoutts, cool! thanks
10:53:36 <lunaris> artagnon: Yes. It's like a pipeline: in (f . g . h) x
10:53:36 <mafs> kuffaar: I tend to put data definitions before the first place where they are used, then any important functions go at the top and related utility functions group together lower in the file (so that stuff I care about closest to the top)
10:53:48 <lunaris> artagnon: x goes in on the right (i.e. the bit nearest it) and flows right-to-left
10:53:54 * ksf would like to have function-local data definitions.
10:53:57 <kuffaar> mafs: Right, I was considering something like that
10:54:01 <artagnon> lunaris: Got it.
10:54:04 <ksf> or, possibly better, multi-module files.
10:54:11 <artagnon> lunaris: Thanks again :)
10:54:24 <lunaris> artagnon: In general, just remember the definition of composition: (g . f) x = g (f x)
10:54:28 <lunaris> artagnon: No worries
10:54:31 <mafs> ksf: multi-module files might be nice in some edge cases, but I think would lead to bad form or perhaps clutter overall
10:55:07 <Egbert9e9> sometimes it tells me a package isn't installed and i have to install it manually
10:55:12 <ksf> I just want to have more namespaces without making files shorter than 200 lines or such.
10:55:37 <Egbert9e9> i tried installing hgeometric and i had to install c2hs too
10:55:38 <ksf> it's not like I'm working on an 80x25 screen, after all.
10:56:14 <mafs> ksf: Ah yeah, that's understandable. I ran into that recently with a data definition and utility functions that a particular module uses. It would be better form to toss them into their own module, but I didn't want the file clutter and such for such short code
10:56:18 <ksf> oh, and tunisia _did_ lose the game.
10:56:40 <asmund> I'm really, really new to haskell, and I'm exploring ByteStrings. http://goo.gl/YFl2P gives me strange error messages. but what's wrong with it?
10:57:07 <Egbert9e9> dcoutts_, so why did it fail installing it?
10:57:18 <kuffaar> asmund you should make the error messages part of the paste, too
10:57:18 <ksf> asmund, care to post the error, too?
10:57:32 <kuffaar> :t Data.ByteString.Lazy.interact
10:57:33 <lambdabot> (BSLC.ByteString -> BSLC.ByteString) -> IO ()
10:57:40 <kuffaar> :t Data.ByteString.Lazy.map
10:57:41 <lambdabot> (Word8 -> Word8) -> BSLC.ByteString -> BSLC.ByteString
10:58:20 <dcoutts_> Egbert9e9: currently it automatically installs library dependencies, it does not yet do build tools such as c2hs
10:58:46 <asmund> kuffaar: http://goo.gl/kuD4b
10:59:01 <kuffaar> asmund wow that sounds messed up
10:59:03 <ksf> asmund, use ghc --make instead of plain ghc
10:59:06 <Egbert9e9> oh, so it is not directly dependent on c2hs?
10:59:17 <kuffaar> Oh right, you used plain ghc, haha
10:59:23 <monochrom> ghc --make baby.hs
10:59:27 <ksf> that's going to be the default in ghc 7
10:59:30 <kuffaar> Usually you just ghci small stuff like this and you use cabal for more elaborate projects, asmund
10:59:36 <dcoutts_> Egbert9e9: there are different kinds of dependencies, C libs, Haskell packages, build tools, etc etc
10:59:37 <asmund> so, what dows plain ghc do?
10:59:39 <kuffaar> asmund just do ghci baby.hs for now
10:59:41 <Egbert9e9> not dependent from within the haskell code but is dependent on the build tools
10:59:59 <napping> with plain ghc, you have to manually list packages to link against
11:00:04 <asmund> aha
11:00:06 <napping> and all the dependencies and so on
11:00:23 <dcoutts_> Egbert9e9: and currently the cabal install command only automatically handles the most important kind of dependency which is Haskell library packages. Doing build tools as well (and perhaps others) is on the TODO list
11:00:34 <monochrom> @faq can haskell make baby.hs?
11:00:35 <lambdabot> The answer is: Yes! Haskell can do that.
11:00:39 <ksf> asmund, it's compiling just fine, but failing the linking phase.
11:00:45 <monochrom> @faq can ghc make baby too?
11:00:46 <Egbert9e9> dcoutts_, okay, no problem. thanks!
11:00:46 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:21 <Egbert9e9> monochrom, read about bob the monadic lover
11:01:30 <dcoutts_> asmund: it is a bit confusing, as of ghc-7 the --make flag is the default
11:02:28 <asmund> awesome! thank you guys
11:02:36 * kuffaar uses ghc 7
11:04:55 <artagnon> When using Network.Browser.browse, I get all sorts of progress information on IO -- How do I omit printing all this?
11:05:17 <_mpu> :t let f g x y = g (\f -> f x) y in f
11:05:18 <lambdabot> forall t t1 t2 t3. (((t -> t1) -> t1) -> t2 -> t3) -> t -> t2 -> t3
11:05:24 <_mpu> :t flip . (. flip id)
11:05:25 <lambdabot> forall a b a1 b1. (((a1 -> b1) -> b1) -> a -> b) -> a -> a1 -> b
11:05:29 <monochrom> setOutHandler (const (return ()))
11:05:35 <_mpu> yes !
11:06:17 <lunaris> :D
11:06:40 <_mpu> well it took me a while ...
11:07:54 <_mpu> I think it is machine generated ...
11:08:07 <artagnon> monochrom: Thanks :)
11:08:08 * hackagebot IOSpec 0.2.2 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.2.2 (WouterSwierstra)
11:13:11 * hackagebot unix-compat 0.2.1 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.2.1 (JacobStanley)
11:15:45 <kuffaar> Hmm how do I translate /\.[a-z]+$/m to Parsec? + is many1, [a-z] is lower, $ is eof - but what about the rest?
11:16:00 <gwern> hm, good to see wouter working on the isntallation problems for IOSpec
11:16:03 <kuffaar> char '.', of course.
11:16:11 <kuffaar> But I still don't know what to wrap this in.
11:16:46 <kmc> well you need nothing special for [m]ultiline
11:17:31 <kmc> char '.' >> many1 letter >> eof
11:17:32 <kuffaar> I need to repeatedly apply try somehow, right?
11:17:39 <kmc> why?
11:17:49 <kuffaar> Uh what you just posted would fail to match "a.b"
11:17:57 <kuffaar> Whereas with RE it would match
11:18:00 <kmc> oh you're matching in the middle
11:18:16 <kuffaar> There's no ^ there, yeah
11:18:22 <kmc> "with RE" it may or may not match; for example python's regex module has both "match" and "search"
11:19:22 <katja> hey! could you please help me. it is an assigment. I need to write a fuction that defines if one tree is a searchTree http://codepad.org/nHaJqwvi  is that right?
11:20:23 <j-invariant> katja: what is?
11:20:45 <kuffaar> kmc: Oh, not familiar with that distinction, I am only familiar with the way Ruby does it
11:21:18 <kuffaar> Which is like the Python search one I suppose
11:21:27 <katja> j-invariant: if it is a search tree
11:21:39 <j-invariant> katja: what is meant by search tree?
11:21:50 <lunaris> katja: It's correct
11:21:57 <lunaris> katja: But what happened to ternary trees?
11:22:05 <lunaris> katja: Also, a better name might be "inSearchTree"
11:22:39 <lunaris> katja: Additionally, Nill is typically spelt Nil, but I understand that this may be a caveat of the assignment.
11:22:51 <kuffaar> irb(main):001:0> puts "a.b".match(/\.([a-z]+)$/m)[1]
11:22:51 <kuffaar> b
11:23:03 <lunaris> j-invariant: She's searching for a value in an ordered binary tree.
11:23:11 <lunaris> j-invariant: Or rather, that's what the function does.
11:23:36 <katja> lunaris: it is ok with ternary . but isSearch Tree is the same like when I look for a specofoc element that can be in one tree
11:23:38 <j-invariant> I wonder what katja means by "is a search tree"
11:23:49 <koala_man> how do I statically compile a haskell program? I tried ghc -static, but the resulting executable was still dynamically linked
11:24:13 <kuffaar> j-invariant what the function actually appears to do is a binary search in a tree which is supposed to be sorted
11:24:18 <katja> j-invariant: I just gor a definiotion what search tree is
11:24:29 <lunaris> katja: Your isSearchTree function will correctly tell me whether or not an item exists in a sorted binary tree.
11:24:30 <j-invariant> katja: good - what is the definition?
11:24:41 <mzero> katja  only concern: the name seems wrong "isSearchTree" would say to me - "this function checks if a Tree is a search tree"....
11:24:46 <lunaris> katja: You should however consider a better name.
11:24:58 <lunaris> katja: As mzero notes, the current name is misleading.
11:25:18 <Egbert9e9> guys, i wasn't aware of it before. everyone should be aware of it. ghci has a step by step evaluation!
11:25:23 <lunaris> Additionally, mzero is an awesome nick ;)
11:25:31 <kuffaar> searchInTree sounds better to me
11:25:48 <koala_man> hmm, nm
11:25:53 <lunaris> isInTree, inSearchTree, anything that starts with/contains ``in'' would be a good alternative (IMHO)
11:26:29 <katja> lunaris: but I have to name it as isSearchTree. I need to write two functions. isSearchTree that checks if a Tree is a searchTree and a function elemtnt that checks if an exact element is in the tree
11:26:54 <kuffaar> Oh yeah that sounds better actually
11:27:44 <katja> lunaris: A Binary Search Tree  is a tree, where each node has two children, and the children are related in a manner which allows them to be compared. The generic example is that all items to the left of a given node are less than that node, and all items to the right are greater. How equality is treated is ambiguous, and depends on the specific application of the tree. . that is the definition of searchtree
11:28:36 <kuffaar> katja uhm I believe you mixed up the isSearchTree and that other function then...
11:28:53 <lunaris> katja: Indeed, the function you have written is ``element''
11:28:58 <mzero> lunaris: it's my e-mail too!
11:29:07 <lunaris> mzero: I am so jealous of you right now.
11:29:09 <kuffaar> isSearchTree :: Ord a => BinTree a
11:29:13 <kuffaar> Sounds more like it, to me
11:29:25 <lunaris> isSearchTree :: Ord a => BinTree a -> Bool, surely.
11:29:35 <lunaris> But I know you meant that ;)
11:29:55 <kuffaar> Woops
11:29:58 <kuffaar> Yeah
11:30:22 <dmead> oh ho ho
11:30:47 <dmead> @hoogle clojure
11:30:48 <lambdabot> No results found
11:30:51 <dmead> @hoogle jvm
11:30:51 <lambdabot> No results found
11:32:21 * kuffaar waits for #haskell to start the usual "write the best isSearchTree" contest
11:33:01 <zygoloid> isSearchTree _ = True -- by construction
11:33:26 <lunaris> zygoloid: Not necessarily; you've got the ordering constraint
11:33:41 <lunaris> zygoloid: Though I won't post the solution, since it's better if katja works it out herself.
11:33:46 <zygoloid> lunaris: i don't expose any functions which violate that invariant from my module
11:33:46 <katja> lunaris: http://codepad.org/GGeJAzcE and this one? I guess it should be as well rekursively made on a left child as well as on the right
11:34:00 <lunaris> zygoloid: God bless you.
11:34:20 <lunaris> katja: Not quite.
11:34:36 <lunaris> Firstly, note that your ``Nill'' case pattern matches two parameters; you only have one now.
11:35:17 <lunaris> katja: After that, note that you are trying to compare a BinTree a with an a on line 8 (twice in fact).
11:35:21 <lunaris> katja: Which isn't allowed.
11:36:25 <lunaris> katja: Not with (<) and (>), anyway.
11:36:37 <lunaris> katja: There are a few ways to approach this.
11:36:57 <katja> lunaris: i tried to compare Node with its children. not with those operations? how then?
11:37:13 <lunaris> Well, there are a couple of ways.
11:37:56 <lunaris> You might write a helper function, allSmallerThan :: BinTree a -> a -> Bool, which returns True if and only if its second argument is greater than all the elements in its first element.
11:37:59 <katja> lunaris: give me a hint
11:38:10 <lunaris> You could then use that to do the greater than test.
11:38:25 <lunaris> But, you'd then need a similar function for the less than test.
11:38:34 <zygoloid> isSearchTree = join((==).sort).Data.Foldable.toList
11:38:41 <lunaris> zygoloid: Thanks for that.
11:38:46 <lunaris> katja: Here's a hint.
11:38:56 <lunaris> katja: There are various methods of looking at a tree.
11:39:15 <katja> lunaris: oh no. please. is there the easiest one/ like with > < operations
11:40:14 <lunaris> katja: Are you familiar with tree traversals?
11:40:24 <lunaris> I'm trying to guage the level of the exercise.
11:40:27 <lunaris> :/
11:42:04 <lunaris> katja: Ok.
11:42:06 <lunaris> Here's a tip.
11:42:20 <lunaris> You're looking at the (Node left x right) case.
11:42:50 <katja> lunaris: yeah. i know about inorder. it will give me a the numbers in a rising order
11:42:56 <lunaris> Oh.
11:42:57 <lunaris> Excellent.
11:42:59 <lunaris> Ok.
11:43:22 <lunaris> Well, why not perform an inorder traversal and produce a list?
11:43:29 <spetrea> katja: in your piece of code on codepad I don't see recursive calls if isSearchTree, any reason for that ?
11:43:39 <lunaris> If that list is sorted (which is easier to check), then you've got a sorted tree.
11:43:48 <lunaris> katja: There are many ways of doing this...
11:43:54 <lunaris> katja: So pick the one that makes most sense.
11:44:25 <spetrea> katja: what lunaris is saying is that you can actually make a tree sort http://en.wikipedia.org/wiki/Tree_sort
11:45:08 <spetrea> katja: oh look, on the page on wikipedia you actually have a haskell implementation :)
11:45:09 <lunaris> spetrea: Is it? :/
11:45:16 <spetrea> lunaris: is it not ?
11:45:36 <lunaris> spetrea: I don't think so -- katja merely wishes to check if a tree is sorted in that sense.
11:45:49 <spetrea> lunaris: a tree sort is precisely that, from what I gather
11:45:58 <lunaris> spetrea: Additionally, it's a homework assignment, so it'd be perhaps better for her to realise an implementation herself.
11:46:00 <spetrea> lunaris: take a look on the "Tree Sort" page on wikipedia
11:46:11 <lunaris> spetrea: But you're not performing a sort.
11:46:21 <lunaris> spetrea: You're just checking well-formedness, as it were.
11:46:31 <lunaris> spetrea: Perhaps I'm misunderstanding grossly.
11:46:36 <spetrea> lunaris: that is correct, but it's good to know that there is a similar thing called Tree sort
11:46:49 <spetrea> lunaris: which is what you describe above
11:47:04 <lunaris> spetrea: But we're not building any trees or sorting any data :)
11:47:19 * spetrea goes for a cig
11:47:25 <lunaris> spetrea: It's almost like we're just checking the post condition of a tree sort.
11:47:32 <lunaris> Oh well :P
11:48:20 <katja> lunaris: ok. inorder function will make from the leaves of the tree a list
11:48:33 <lunaris> katja: Correct.
11:48:53 <lunaris> katja: Once you've got that, check the sortedness of the list.
11:49:16 <lunaris> katja: It will be sorted if and only if the tree was well formed (i.e. in order sorted) in the first place.
11:49:40 <lunaris> katja: For now, just write the inorder functio
11:49:41 <lunaris> n
11:49:48 <lunaris> katja: inorder :: BinTree a -> [a]
11:51:54 <katja> inorder Nil = [] inorder (Node l x r) = (inorder l) ++ [x] ++ (inorder r)
11:52:42 <katja> lunaris: so, i got a sirted list and now I have to look if t issorted in a rising way. I mean like 1,2,3,4 but not 1,3,2,4 yeah&
11:53:44 <lunaris> katja: Precisely.
11:53:45 <katja> lunaris: so, i got a sorted list and now I have to look if it is sorted in a rising way. I mean like 1,2,3,4 but not 1,3,2,4 yeah&
11:53:57 <lunaris> katja: So you want a function isSorted :: Ord a => [a] -> Bool
11:54:06 <lunaris> katja: Which isn't too bad.
11:54:26 <katja> lunaris: yeah. that I got. I guess I am capable of doing that%)
11:55:55 <aristid> :t zipWith (<=) <*> tail
11:55:56 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
11:56:09 <aristid> :t all . (zipWith (<=) <*> tail)
11:56:10 <lambdabot>     Couldn't match expected type `a -> Bool'
11:56:10 <lambdabot>            against inferred type `[Bool]'
11:56:11 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
11:56:12 * lunaris sighs
11:56:49 <lunaris> :t (all .) . (zipWith (<=) <*> tail)
11:56:49 <lambdabot>     Couldn't match expected type `a -> Bool'
11:56:50 <lambdabot>            against inferred type `Bool'
11:56:50 <lambdabot>     In the first argument of `zipWith', namely `(<=)'
11:57:26 <aristid> :t zipWith (<=) <*> tail $ [1,2,3,4]
11:57:27 <lambdabot> [Bool]
11:57:35 <lunaris> My bad
11:57:37 <aristid> :t all $ zipWith (<=) <*> tail $ [1,2,3,4]
11:57:38 <lambdabot>     Couldn't match expected type `a -> Bool'
11:57:38 <lambdabot>            against inferred type `[Bool]'
11:57:38 <lambdabot>     In the second argument of `($)', namely
11:57:39 <lunaris> :t (and .) . (zipWith (<=) <*> tail)
11:57:40 <lambdabot>     Couldn't match expected type `[Bool]' against inferred type `Bool'
11:57:40 <lambdabot>     In the first argument of `zipWith', namely `(<=)'
11:57:40 <lambdabot>     In the first argument of `(<*>)', namely `zipWith (<=)'
11:57:45 <aristid> :t all
11:57:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:57:50 <aristid> lol :D
11:57:50 <lunaris> Oh ffs.
11:58:04 <aristid> :t and . (zipWith (<=) <*> taiL)
11:58:05 <lambdabot> Not in scope: `taiL'
11:58:06 <aristid> :t and . (zipWith (<=) <*> tail)
11:58:07 <lambdabot> forall a. (Ord a) => [a] -> Bool
11:58:09 <joe6> isn't the type signature of the cast operator weird?
11:58:15 <joe6> > cast 'a'
11:58:16 <aristid> > and . (zipWith (<=) <*> tail) $ [1,2,3,4]
11:58:16 <lambdabot>   Nothing
11:58:18 <lambdabot>   True
11:58:22 <aristid> > and . (zipWith (<=) <*> tail) $ [1,2,4,3]
11:58:25 <lambdabot>   False
11:58:29 <sipa> :t cast
11:58:30 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
11:58:31 <joe6> > (cast 'a') :: Maybe Char
11:58:32 <locks> :t "me wants"
11:58:33 <lambdabot>   Just 'a'
11:58:33 <lambdabot> [Char]
11:58:43 <j-invariant> joe6: why is it weird
11:58:49 <lunaris> joe6: It's intuitive, isn't it?
11:59:16 <lunaris> joe6: If you cast from type a to b, you might get a value of type b (if a and b are the same in that sense) or Nothing (if a and b aren't interchangeable)
11:59:18 <joe6> for any function, we must list out all the arguments. But for cast, it seem to behave differently
11:59:27 <joe6> > cast 'a'
11:59:27 <lambdabot>   Nothing
11:59:40 <joe6> > (cast 'a') :: Maybe Char
11:59:40 <lunaris> > cast 'a' :: Maybe Char
11:59:41 <lambdabot>   Just 'a'
11:59:41 <lambdabot>   Just 'a'
11:59:49 <lunaris> > cast 'a' :: Maybe Int
11:59:50 <lambdabot>   Nothing
11:59:55 <sipa> joe6: cast only has one argument
12:00:20 <sipa> types are always passed implicitly
12:00:35 <joe6> its' behaviour is defined by the parameter which is optional?
12:00:54 <sipa> there are no optional arguments
12:01:12 <joe6> oh, ok. if the outer parameter is not given, it is implicitly assumed to be something else?
12:01:29 <sipa> there is no outer parameter
12:01:44 <kmc> :t cast
12:01:45 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
12:01:46 <_mpu> :t flip . flip
12:01:47 <kmc> there's one ->
12:01:48 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
12:01:48 <sipa> the return type is inferred from the context
12:02:09 <sipa> its a -> Maybe b
12:02:34 <kmc> types are inferred, but if there's ambiguity then you have to give a signature (but you can give it anywhere which is sufficient to resolve the ambiguity)
12:02:56 <_mpu> > (cast 3) ++ "hi"
12:02:58 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
12:02:58 <lambdabot>         against inferred ...
12:03:24 <_mpu> :t maybe
12:03:25 <monochrom> against inferred type [Char]
12:03:26 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:03:42 <kmc> > (fromMaybe 'x' $ cast 'y') : "abc"
12:03:44 <lambdabot>   "yabc"
12:04:05 <kmc> joe6, also you called it the "cast operator" but it's an ordinary function
12:04:09 <joe6> kmc: i do not understand what you mean by ->?
12:04:14 <kmc> "operator" vs "function" is entirely a syntactic thing in Haskell
12:04:16 <_mpu> maybe "" (++ "hi") (cast 3)
12:04:20 <kmc> there's only one "->" in the type of "cast"
12:04:20 <kmc> :t cast
12:04:22 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
12:04:23 <_mpu> > maybe "" (++ "hi") (cast 3)
12:04:25 <lambdabot>   ""
12:04:30 <kmc> hence it has one argument only
12:04:51 <kmc> (technically, we should also convince ourselves that "Maybe b" isn't a type synonym expanding to something with "->" in it, which it clearly isn't)
12:04:57 <joe6> kmc: there is only one argument but its' behaviour is determined by the result type?
12:05:09 <jonkri> how can i pattern match against record fields?
12:05:11 <joe6> which implies that the result type is also a parameter
12:05:11 <kmc> joe6, correct.  functions in Haskell can be overloaded on the result type as well as argument types
12:05:19 <kmc> jonkri, f (Foo { x = p })
12:05:24 <monochrom> "(Typeable a, Typeable b) => a -> Maybe b" seems to say both a and b determine behaviour
12:05:24 <kmc> for p a pattern
12:05:38 <joe6> oh, ok. so, every function has an implicit parameter of the return type.
12:05:41 <kmc> no
12:05:55 <kmc> joe6, type information flows at compile time and is bidirectional with respect to the run-time flow of data
12:06:03 <monochrom> fromIntegral behaviour is also determined by two types, not just one
12:06:18 <kuffaar> Ohh, monochrom the Parsec overlord is here
12:06:22 <kmc> so the fact that "cast x" is later used as Maybe Char can determine how "cast x" behaves
12:06:29 <j-invariant> Q. Seriously, this is a dumb idea.
12:06:29 <j-invariant> A. Please try to phrase your question in the form of a question.
12:06:29 <j-invariant> Q. Seriously, is this a dumb idea?
12:06:29 <joe6> yes, that is true. fromIntegral behaves in the same manner
12:06:30 <j-invariant> A. No, I’m pretty sure it is awesome.
12:06:33 <j-invariant> LOL
12:07:01 <kmc> the situation with numeric types is muddled by the existence of the (ugly, ad-hoc) "defaulting" rules, which means there's fewer ambiguous cases than you'd expect
12:07:14 <kuffaar> monochrom: How do I translate /\.([a-z]+)$/m to Parsec? + is many1, [a-z] is lower, $ is eof - but what about the rest? It needs to match "b" in "a.b", for example. Need some combination of try and some other parser, I suppose.
12:07:37 <joe6> isn't that many1 anyChar newline
12:07:37 <monochrom> what is the m doing there?
12:07:54 <kmc> if you write in a file:  default (); main = print $ fromIntegral (3 :: Int)
12:07:57 <kmc> then you will see the same ambiguity
12:08:21 <kuffaar> monochrom hmm I think it basically turns $ into eof instead of just eol in this case? It's the Multiline flag
12:08:35 <lunaris> :t show . read
12:08:36 <lambdabot> String -> String
12:08:40 <lunaris> :t read . show
12:08:41 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
12:08:52 <monochrom> anyChar >> many1 (oneOf ['a'..'z']) >> eof
12:09:00 <_mpu> interesting compositions .....
12:09:01 <lunaris> Oh lambdabot.
12:09:17 <lunaris> _mpu: GHCi won't like the first one.
12:09:19 <kuffaar> monochrom: It's /\./, not /./
12:09:37 <kuffaar> And you can use many1 lower
12:09:38 <_mpu> oneOf ['.']
12:09:45 <monochrom> I keep forgetting to escape and unescape.
12:09:49 <kuffaar> Nah, letter '.', _mpu
12:09:50 <lunaris> I mean the second
12:09:55 <monochrom> char '.' >> many1 (oneOf ['a'..'z']) >> eof
12:10:05 <_mpu> I don't know parsec :)
12:10:06 <katja> lunaris: i wrote it but it gives me a mistake http://codepad.org/XoFWnJWW , the mistake is  Couldn't match expected type `a -> BinTree a -> BinTree a1'            against inferred type `BinTree a'     In the first argument of `inorder', namely `(left x right)'     In the first argument of `isSorted', namely         `(inorder (left x right))'     In the expression: isSorted (inorder (left x right))    
12:10:08 <monochrom> all escape codes must die
12:10:10 <kuffaar> _mpu: Also, "." is shorter than ['.'] :p
12:10:21 <monochrom> and screw plain text file
12:10:21 <kuffaar> Woops, char*, not letter, sorry :p
12:10:31 <kuffaar> monochrom: that still doesn't match "a.b"
12:10:34 <kuffaar> Whereas the RE does
12:10:51 <lunaris> katja: That looks great; it's nearly there.
12:11:10 <lunaris> katja: First, you don't need the two cases at the end of isSorted
12:11:17 <lunaris> katja: You've got a case for [], [x]
12:11:20 <lunaris> katja: Which is right
12:11:38 <lunaris> katja: The last case is for ``at least two elements'', i.e. (x : y : rest)
12:12:05 <monochrom> because "/blabblah/" is a substring searcher but parsec isn't
12:12:12 <kuffaar> Yep
12:12:21 <kuffaar> And I need a substring searcher in Parsec
12:12:28 <lunaris> katja: The type error is before you need a ``Node`` before the ``left x right'' inside the brackets on line 7
12:12:31 <lunaris> However
12:12:40 <lunaris> Consider the fact that isSearchTree can be simplified quite a bit.
12:12:42 <kuffaar> Parsec can do it, I just don't know what to combine in this case
12:13:53 <monochrom> the best way is to specify what may come before \.([a-z]+)$, and recognize and skip it.
12:14:13 <kuffaar> It can be anything
12:14:21 <katja> lunaris: do you mean this isSearchTree Node (left x right)
12:14:26 <kuffaar> $*(TR48rj4\x00\x01......ds.gf.sdgf.gfd.
12:14:46 <lunaris> katja: You don't need two cases for isSearchTree. It's much simpler.
12:16:08 <monochrom> I would go back to regex if you literally mean "anything" and not "I'm just too lazy to specify precisely"
12:16:12 <katja> lunaris: do you mean the lines 19,20,21. I dont need them? why then?
12:16:43 <_mpu> let { string c:t = char c >> string t ; string "" = return ?? }
12:16:56 <monochrom> parsec becomes slow and hard to use when it is really "anything" and requires backtracking.
12:16:58 <kuffaar> monochrom: Awww
12:17:00 <lunaris> katja: You don't need 16,17,18
12:17:11 <lunaris> katja: Additionally, lines 6 and 7 can become one line
12:17:20 <lunaris> katja: Also, lines 20 and 21 can be one line
12:17:40 <lunaris> katja: (Without any cheeky hacks or helper functions)
12:17:40 <katja> lunaris: if without 16,17 18, then i get this thing isSorted [1,3,4,5,6,7] *** Exception: new  10.hs:(13,0)-(17,33): Non-exhaustive patterns in function isSorted
12:19:05 <kuffaar> Pff I'll just do it with a basic string operation then
12:19:13 <kuffaar> How do you perform a reverse search in a list?
12:19:24 <lunaris> katja: Works fine for me.
12:19:27 <sioraiocht> kuffaar "reverse search"?
12:19:51 <gwern> reverse the list and do a regulra search?
12:19:52 <_mpu> kuffaar: perform a search on (reverse l)
12:19:55 <kuffaar> sioraiocht: Find the last occurence of an element in an array/string
12:19:59 <kuffaar> Ok
12:20:12 <monochrom> x = try (do { char '.' ; a <- many1 ['a'..'z'] ; eof ; return a }) <|> (anyChar >> x)  may work
12:20:20 <_mpu> search . reverse
12:20:25 <sioraiocht> kuffaar: you coul dalso loop through and store the most recent element, and return tha when you get to the empty list
12:20:33 <katja> lunaris: why then? without lines 16,17,18 it gives a mistake that there is no such patter
12:20:33 <gwern> sioraiocht: that would be a little faster, yeah
12:20:36 <kuffaar> sioraiocht yes that is faster
12:20:40 <kuffaar> I bet
12:20:42 <sioraiocht> and phraseable as a foldl, I bet
12:20:44 <gwern> sioraiocht: after all, iwth reverse you could wind up doing 2n operations
12:20:48 <gwern> rather than just n
12:20:55 <sioraiocht> aye
12:20:57 <kuffaar> gwern yeah but CS people don't care about that
12:21:03 <kuffaar> Because O(2 n) = O(n)
12:21:03 <gwern> we care about constant factors1
12:21:08 * sioraiocht cares about that.
12:21:19 <monochrom> not all CS people
12:21:22 <sioraiocht> also, causes copying.
12:21:29 <deech> Hi all, I am trying to install glade on Windows 7 and getting the "Missing C libraries" error.  When using the --extra-lib-dirs flag do I point it to the directory containing dll's or dll.a's? 
12:21:39 <jamwt> cabal-dev question.. I'm getting errors about "xxxx-0.1.1-<md5>" does not exist (use --force to override)
12:21:47 <jamwt> and I've done the "configure" and "install-deps" dance
12:22:05 <jamwt> so I'm not sure what else I need to do to satisfy cabal-dev and get those in the sandbox
12:22:16 <jamwt> (they're in the .cabal file)
12:22:18 <monochrom> humanity is a lost cause
12:22:43 <kuffaar> monochrom ahh I get your parser now
12:22:51 <lunaris> katja: See http://codepad.org/0gPjZcsa
12:22:55 <lunaris> katja: It works for me.
12:25:09 <kuffaar> monochrom yay it works, cheers
12:26:22 <monochrom> nice
12:28:56 <katja> lunaris:  ok. then I have one more questio. why did I have to define 4,5,6 Lines. is that not the the same problem like we had with isSorted? I eman that without that line [1,2,5,6,] last element 6 would be compared with []
12:29:42 <lpsmith> so why is Network.Socket the same type as Network.Socket.Socket?
12:30:00 <lpsmith> that almost seems an interface "bug" to me...
12:30:27 <hpc> lpsmith: because Network reexports Network.Socket
12:30:39 <hpc> the naming looks odd, but only if you use qualified names
12:31:52 <mkscrg> Is there a way to verify that GHC is doing tail call optimization on a given [supposedly] tail-recursive function?
12:32:50 <kmc> mkscrg, i think that's basically the wrong question, due to laziness
12:33:10 <kmc> maybe i'll figure out how to explain precisely
12:33:10 <dafis> mkscrg: read the Core
12:33:37 <lunaris> katja: I'm not sure what you're asking, but lines 6 and 7 can be shortened -- you don't need to consider both cases.
12:33:40 <dafis> but of course, kmc is right, that's not always what you want
12:33:43 <c_wraith> mkscrg: due to how ghc is implemented, it's pretty much impossible for it not to do tail recursion.  But laziness can re-create issues that look the same, even when the function call is tail-recursive
12:33:52 <lunaris> katja: Additionally, your isSorted's final case can be shorted to one line.
12:34:02 <lunaris> Remember, if p then p else not p is the same as p.
12:34:20 <lunaris> Unfortunately, I have to leave shortly, so I can't provide any more help at present.
12:34:23 <c_wraith> lunaris: actually, that's the same as True
12:34:56 <lpsmith> hpc,  I mean that the usage of Network.Socket.Socket is rather different than the usage of Network.Socket in actual programs
12:35:07 * dafis suspects lunaris meant to write if p then True else False
12:35:14 <lunaris> dafis: Thank you
12:35:17 <lunaris> :)
12:35:20 <lunaris> Apologies
12:35:23 * lunaris is a n00b really
12:35:42 <lunaris> katja: You're nearly there, hope you get it solved.
12:35:48 * lunaris must sneak off to play metal.
12:35:55 <kmc> mkscrg, note that the stack in GHC haskell is not a stack of function calls but a stack of thunk-forcings
12:36:16 <kmc> "if p then True else False"
12:36:17 <kmc> ...
12:36:39 <dafis> kmc: that's a classic
12:36:41 <kmc> yep
12:36:44 <lunaris> kmc: A common programming error -- some students don't realise that booleans are first class.
12:36:49 <kmc> a /lot/ of beginners do that
12:36:50 <aristid> just write "p"
12:36:50 <lunaris> kmc: They see them only as tools for writing conditionals.
12:36:56 <lunaris> Anyway.
12:36:58 <kmc> in most languages, too
12:37:01 <lunaris> I must away.
12:37:09 * lunaris waves goodbye.
12:37:16 <dafis> good whatever, lunaris
12:37:33 <lunaris> (I'm off to steal mzero's email address)
12:38:31 <mkscrg> Ah gotcha. I'm still carrying imperative baggage when I try to reason through Haskell code.
12:39:03 <aristid> @let isSorted xs = and (zipWith (<=) xs (tail xs))
12:39:05 <lambdabot>  Defined.
12:39:08 <mkscrg> Or non-lazy baggage, perhaps.
12:39:28 <aristid> (i thought that might be easier to understand than the point-free version leveraging <*>)
12:39:46 <dafis> > isSorted []
12:39:48 <lambdabot>   True
12:41:59 <aristid> > isSorted [1,2,3]
12:42:02 <lambdabot>   True
12:42:04 <aristid> > isSorted [1,2,3,2]
12:42:06 <lambdabot>   False
12:43:10 <EnglishGent> what happens if you do isSorted [1..] ?
12:43:18 * EnglishGent not wanting to crash lambdabot
12:43:22 <j-invariant> it never returns
12:43:25 <hpc> > isSorted [1..]
12:43:28 <lambdabot>   mueval-core: Time limit exceeded
12:43:38 <EnglishGent> ah! 
12:43:42 <Cale> mkscrg: Yeah, when you evaluate everything outermost first, you don't actually end up needing a stack for evaluation. GHC has a stack, but uses it for something different than it's used for in strict evaluators. In particular, the stack carries all the case expressions (and other pattern matches) which are waiting for their scrutinee to be sufficiently evaluated to be able to pattern match.
12:43:56 * EnglishGent glad at least the bot doesnt die in a "calculate Pi to the last digit" kind of way :)
12:44:23 <Cale> mkscrg: Thus, tail call optimisation doesn't really make much sense in this context.
12:44:34 <edwardk> added bfs to my shiny little monadic graph library
12:44:45 <EnglishGent> hi edwardk :)
12:44:45 <edwardk> onward to dijkstra, etc.
12:44:47 <sproingie> EnglishGent: actually it just finished that a couple hours ago.  it was going to be a surprise.
12:44:52 <edwardk> heya EnglishGent
12:44:57 <companion_cube> edwardk, what data structure do you use to perform the bfs ?
12:45:12 <mkscrg> Right. I'm worried about space leaks with a particular function, so forcing evaluation somewhere is probably the answer, rather than something about TCO.
12:45:15 <edwardk> I used Data.Sequence for the queue for now
12:45:21 <Cale> mkscrg: Yeah
12:45:21 <companion_cube> ok
12:45:39 <Cale> mkscrg: Let's look at how foldl (+) 0 [1,2,3] evaluates, and I think it gives a good idea of the difference.
12:45:44 <kuffaar> What container do I want to use when I need 1. fast appending at the end 2. O(1) length?
12:46:00 <companion_cube> i think Data.Dequeue is a good fifo, too
12:46:03 <Cale> @src foldl
12:46:03 <lambdabot> foldl f z []     = z
12:46:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:46:14 <Cale> foldl (+) 0 (1:2:3:[])
12:46:28 <Cale> -> foldl (+) (0 + 1) (2:3:[])
12:46:34 <kmc> kuffaar, perhaps Data.Sequence
12:46:37 <Cale> -> foldl (+) ((0 + 1) + 2) (3:[])
12:46:45 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
12:46:46 <kuffaar> At first I thought about doing something data Blah = { count :: Int, elements :: [String] }
12:46:49 <edwardk1> copumpkin: https://github.com/ekmett/graphs/tree/master/Data/Graph/Algorithm
12:46:50 <Cale> -> (((0 + 1) + 2) + 3)
12:46:54 <kuffaar> But I figured Haskell already has something for that
12:46:54 <jmcarthur> kuffaar: Data.Sequence is what you want
12:46:59 <Cale> no stack has been needed up to this point
12:47:01 <kmc> kuffaar, btw is asymptotic analysis really appropriate? do you really care if length is O(log n) rather than O(1)
12:47:01 <kuffaar> Alright, thanks
12:47:01 <jmcarthur> fingertree ftw!
12:47:17 <kmc> asymptotic analysis is a tool for comparing abstract algorithms; it's not a tool for programming computers
12:47:20 <kuffaar> kmc: Well otherwise I'd probably double my work load
12:47:26 <mkscrg> Ah I see. I've been misunderstanding Haskell's use of the stack.
12:47:29 <Cale> But now GHC will start using its stack, because the outermost (+) essentially needs to "pattern match" on both of its parameters
12:47:41 <kmc> mkscrg, this is really GHC's use of the stack, Haskell-the-language has no concept of an execution stack
12:47:43 <copumpkin> edwardk1: very neat :)
12:47:46 <edwardk1> copumpkin: terribly imperative, but nicely will handle things like huge offline graphs, etc. once i'm done
12:47:46 <Cale> and its first parameter, ((0 + 1) + 2), isn't evaluated enough
12:47:53 <EnglishGent> hi copumpkin :)
12:47:57 <copumpkin> hi EnglishGent :)
12:48:00 <kmc> kuffaar, what if O(1) is 900000 and O(log n) is 0.000001*log(n)
12:48:00 <copumpkin> kmc: you coming later?
12:48:05 <kmc> copumpkin, not sure
12:48:16 <kuffaar> kmc: Because I pretty much just keep on adding stuff to a container and then I dump its length and its contents to a file at the end
12:48:23 <edwardk1> i probably also need to add some kind of short circuiting to let you escape in case you are in a particularly strict monad like IO
12:48:29 <kuffaar> So with a [String] it would be slower
12:48:30 <jmcarthur> kmc: do you know something about what kuffaar is trying to do that i don't?
12:48:34 <mkscrg> The buildup of thunks, like you just demonstrated, is the reason for foldl', no?
12:48:39 <kuffaar> jmcarthur: Nope
12:48:39 <Cale> mkscrg: yeah
12:48:46 <kmc> nope jmcarthur
12:49:05 <kmc> kuffaar, right, i asked about a hypothetical case of O(log n) length, not O(n)
12:49:07 <Cale> mkscrg: So foldl' is like foldl, but it forces the accumulating parameter to be evaluated (into weak head-normal form) on each step
12:49:07 <mkscrg> Cool. Thanks for hammering that out for me.
12:49:25 <Sgeo> ?so Can I make lambdabot speak?
12:49:26 <lambdabot> Can I make lambdabot speak? not available
12:49:31 <Sgeo> What is ?so
12:49:39 <kuffaar> "An amortized running time is given for each operation, with n referring to the length of the sequence and i being the integral index used by some operations. These bounds hold even in a persistent (shared) setting. "
12:49:55 <kuffaar> length: O(1). The number of elements in the sequence. 
12:49:57 * kuffaar cheers
12:50:09 <j-invariant> anyone know caetgory theory?
12:50:15 <kuffaar> (|>): O(1). Add an element to the right end of a sequence. Mnemonic: a triangle with the single element at the pointy end. 
12:50:17 <Cale> A term is in weak head-normal form or WHNF when it is either an unapplied lambda, or it is a data constructor applied to arbitrary arguments (ready for pattern matching)
12:50:26 <j-invariant> I try to write my proof in haskell: http://hpaste.org/43168/tittle but I am not sure.. is it correct?
12:50:28 <edwardk1> kuffar: data.sequence is pretty awesome
12:50:35 <kuffaar> Yeah it looks useful
12:50:36 <jmcarthur> kuffaar: the data structure that Seq is based on is called a finger tree. i highly recommend reading up on it, because it rocks
12:50:41 <j-invariant> (natural transformation)
12:50:48 <jmcarthur> kuffaar: finger trees are useful for more things than just Seq :)
12:50:48 <kmc> kuffaar, again, i think the question is "does it have fast length" and not "does it have length conforming to this theoretical notion that has nothing to do with how real computers operate"
12:50:55 <kmc> kuffaar, recall that log(n) < 64.
12:52:00 <jmcarthur> kmc: it sounds from kuffaar's description of what he's doing that this is perfectly appropriate though. are you just complaining that he asked for O(1) appending to the end instead of simply for "fast" append?
12:52:00 <edwardk1> j-invariant you probably want an existential on s.
12:52:12 <j-invariant> hm
12:52:16 <kmc> jmcarthur, yes, that's what i'm complaining about
12:52:26 <Sgeo> lambdabot is in the process of spamming a channel I'm in
12:52:31 <jmcarthur> okay, then i'm with you, from a precision standpoint
12:52:35 <j-invariant> Sgeo: that's not lambdabot
12:52:44 <edwardk1> j-invariant then you'll have http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Yoneda.html#t:CoYoneda id
12:52:50 <Sgeo> It's lambdabot and another bot
12:52:56 <jmcarthur> *accuracy
12:53:03 <edwardk1> er CoYoneda Identity
12:53:06 <kmc> i'm not just being pedantic about this case, i think the overuse of asymptotic analysis by programmers wastes a lot of time and produces a lot of bad outcomes
12:53:07 <elliott> Sgeo: Hey, no telling them about what I discovered. :p
12:53:09 <elliott> Bug report: lambdaot's ?so is buggy.
12:53:11 <elliott> It does not prefix its output with a space.
12:53:13 <elliott> *lambdabot's
12:53:15 <elliott> This allows the following bot-loop:
12:53:16 <j-invariant> Yoneda huh!
12:53:17 <elliott> ?so !c char *s="?so !c char *s=%c%s%c; printf(s,34,s,34);//"; printf(s,34,s,34);//
12:53:18 <lambdabot> !c char *s="?so !c char *s=%c%s%c; printf(s,34,s,34);//"; printf(s,34,s,34);// not available
12:53:27 <elliott> Cale: ^
12:53:34 <kmc> for starters, we should be willing to trade hundreds of instructions for better cache locality
12:53:44 <copumpkin> elliott: what's ?so ?
12:53:44 <j-invariant> edwardk1: I see!
12:53:55 <elliott> copumpkin: I have no idea what it corrects to. But observe:
12:53:56 <elliott> ?so amazing
12:53:56 <lambdabot> amazing not available
12:53:59 <companion_cube> +1 kmc 
12:54:02 <elliott> ?so putStrLn
12:54:02 <lambdabot> putStrLn not available
12:54:03 <kmc> (neither String nor Seq will have good cache locality, afaik)
12:54:05 <copumpkin> edwardk1: you going to make it to the meetup?
12:54:08 <elliott> copumpkin: Whatever it is, it's buggy :P
12:54:10 <j-invariant> ?do PUTSTRYLIN
12:54:11 <lambdabot> PUTSTRYLIN
12:54:19 <edwardk1> j-invariant: as it is you have http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Context.html
12:54:27 <Sgeo> ?to asdf
12:54:27 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell do
12:54:36 <companion_cube> no functional data structure has good cache locality, am i wrong ?
12:54:41 <elliott> oh ?do has the same issue
12:54:46 <Cale> @do !c char *s="?so !c char *s=%c%s%c; printf(s,34,s,34);//"; printf(s,34,s,34);//
12:54:47 <elliott> in fact a lot of them have such issues!
12:54:47 <lambdabot>  Parse error at "="?so" (column 11)
12:54:58 <elliott> yeah that would be a lot tricker
12:55:00 <elliott> *trickier
12:55:01 <copumpkin> Cale: what command is ?so calling?
12:55:02 <elliott> since you'd have to polyglot it
12:55:04 <djahandarie> copumpkin, source
12:55:06 <Cale> copumpkin: I have no idea
12:55:08 <copumpkin> oh
12:55:09 <elliott> ah
12:55:10 <Cale> oh, source?
12:55:13 <copumpkin> ?source moo
12:55:13 <lambdabot> moo not available
12:55:13 <edwardk1> copumpkin: yeah i should be able to make it. Amy'll give me a ride down to cambridge a bit early and i'll grab a bite to eat then head in. coud you and runar pick up some diet coke/coke on the way in? i'll bring cupcakes or something
12:55:18 <djahandarie> @source moo
12:55:18 <lambdabot> moo not available
12:55:20 <elliott> i'm proud of that botloop, first one #esoteric's had in ages >:D
12:55:27 <copumpkin> edwardk1: sure, bottles or cans?
12:56:02 <jmcarthur> companion_cube: i don't think i would go that far
12:56:03 <edwardk1> cans tend to work best. i usually bring a 12 back of diet coke and an 8-pack of coke and wind up with half the diet cokes left over at the end
12:56:30 <Sgeo> elliott, you wouldn't have discovered it if the conversation, and something I said, didn't make you ask ?so
12:56:36 <Sgeo> =P
12:56:45 <elliott> Pah.
12:56:46 <companion_cube> jmcarthur, i mean that keeping a data structure in the same portion of the memory and still be able to alter it is hard
12:56:48 <elliott> That is mere synchronicity.
12:56:53 <elliott> The Gods willed me to discover it.
12:56:57 <companion_cube> because you allocate at different times
12:58:25 <jmcarthur> companion_cube: but, say, the gc and allocator could be really smart, or maybe it's a persistent structure with some cache-friendly, unobservable mutation under the hood
12:58:56 <jmcarthur> companion_cube: even without those, i'm not sure i'd say they are *always* cache unfriendly (but usually, yes)
12:59:12 <kmc> yeah, if i had to tune Haskell code for cache locality today, I would rewrite critical parts using unboxed ST stuff
13:00:15 <companion_cube> maybe using ST behind the scene ?
13:00:22 <jmcarthur> that could be a way
13:00:40 <companion_cube> ok, it's possible, but really non-trivial :D
13:00:43 <jmcarthur> lazy ST especially can do some weird/cool things
13:00:59 <copumpkin> like what?
13:01:47 <jmcarthur> copumpkin: i mean interleaved ST, not Control.Monad.ST.Lazy
13:02:09 <kmc> unsafeInterleaveST?
13:02:12 <jmcarthur> yeah
13:02:12 <kmc> sounds... unsafe
13:02:19 <jmcarthur> it is
13:02:44 <copumpkin> oh
13:02:47 <kmc> actually another approach to cache locality is DPH
13:02:54 <jmcarthur> vectorization?
13:02:55 <kmc> you describe big data transforms in a declarative way
13:03:01 <kmc> and count on the compiler to be cache-aware
13:03:02 <kmc> yes
13:03:18 <kmc> or even without vectorization, intelligent loop ordering
13:03:22 <copumpkin> GHC: the sufficiently smart compiler
13:03:24 <kmc> easier when the programmer doesn't write loops at all
13:03:26 <kmc> yep :)
13:03:45 <kmc> dunno if DPH is really working yet but that's the idea anyway
13:04:01 <jmcarthur> it's not really working well yet :(
13:04:10 <companion_cube> or you can use C behind the scene, i presume
13:05:50 <hpc> copumpkin: that would make a nice catchphrase if GHC ever decided it needed one
13:06:34 <kmc> yeah companion_cube
13:08:20 <kuffaar> What is the equivalent of std::map<std::string, std::vector<std::string> > blah; blah["abc"].push_back("def"); in Haskell? I was just wondering about "default constructed insertion" where it would start with an empty container when you access a key for the first time. What is the normal way to achieve this in combination with Data.Map.Map?
13:08:48 <vaflis> why whenever I try to define a function in GHCi it gives me an error 'Not in scope 'funcName' ' ?
13:09:10 <vaflis> by saying GHCi I mean interactive shell
13:09:10 <kuffaar> vaflis ghci doesn't work like Haskell source code
13:09:18 <kuffaar> For top level definitions you need to use let, basically
13:09:21 <kuffaar> let function = 1
13:09:30 <vaflis> oh, ok
13:09:44 <kuffaar> vaflis: ghci is like a do block, I think
13:09:57 <hpc> ghci is a magic do blogk
13:10:00 <hpc> block, even
13:10:17 <vaflis> and I was hoping for an interactive shell... 
13:10:33 <mzero> ghci is a magic do burrito!
13:10:44 <vaflis> so maybe you could offer me a shell which works with Haskell source code?
13:10:47 <mzero> okay - that didn't work as well as I expected
13:11:10 <mzero> vaflis - just put your source code in a file and :load it into ghci
13:11:14 <vaflis> because now I am reading Haskell tutorial on functions and it doesn't work ;)
13:11:22 <kuffaar> vaflis heh, we talked about that a few days ago
13:11:27 <mzero> if you edit your source (in yer favorite text editor) you then just save and back in ghci :reload
13:11:33 <kuffaar> :r is shorter
13:11:45 <mzero> indeed    :l foo.hs    then later    :r 
13:11:55 <mzero> and there is file name completion on the :load command which rocks
13:12:08 <mzero> and :r will correctly remove all the older defs, then load in the new ones ---
13:12:28 <vaflis> so Haskell source file is called module? is that right?
13:12:28 <mzero> best REPL code management I've ever used (Python, for example, sucks in this regard!)
13:12:45 <mzero> yes, but for this purpose, you don't need to even put a module header on it
13:12:52 <revenantphx> What would you guys recommend for plotting.
13:12:59 <revenantphx> In this case, two dimensional scatter plots.
13:13:04 <revenantphx> (in terms of moduleS)
13:13:18 <kuffaar> mzero: The Python REPL allows you to write top level functions in the REPL at least :)
13:13:39 <mzero> sure - but try reimporting a lib when you fix a bug in it!
13:13:49 <revenantphx> (:r)?
13:14:05 <kuffaar> It's not a function, it's a ghci command, revenantphx
13:14:12 <revenantphx> yeah I know
13:14:24 <revenantphx> I don't know why I put it in parens anyways 
13:14:28 <zzing> Does anyone know what sorts of changes have to be made to an opengl app from 2008 to compile on 6.12? The specific errors are 3, http://hpaste.org/43169/shuthing  It looks like things that are inferred as Double, but expecting some complex type
13:14:43 <kuffaar> Axman6: You know C++ well, right? Maybe you can answer my question about the std::map equivalent in Haskell I just posted ^
13:15:17 <kmc> you can write functions in ghci too, with "let"
13:15:46 <vaflis> ok, thanks. Editing source and loading it into GHCi is good enough
13:15:49 <tromp_> ghci is like an IO monad
13:16:19 <kmc> like an IO monad "do" block
13:16:23 <dafis> zzing: just replace Double with Gldouble where it complains
13:16:40 <kmc> (there's only one IO monad, it's a type and its name is Prelude.IO)
13:17:01 <dafis> zzing: Gldouble etc used to be type synonyms for Double etc, now they are newtype wrappers
13:17:07 <kuffaar> kmc haha that sounded like the shahada of Haskell
13:17:11 <kmc> yep
13:17:23 <kmc> kuffaar, how about Map.insertWith (++) k [v]
13:17:36 <zzing> Not in scope: type constructor or class `Gldouble'
13:17:40 <kmc> (course you'd want to not use lists but we talked about that already)
13:18:04 <dafis> zzing: typo, GLdouble
13:18:21 <revenantphx> kmc: One interesting thing I was thinking about today actually... imperative line-by-line programs can actually be evaluated functionally really elegantly.
13:18:41 <zzing> It doesn't like GLdouble or GLDouble either
13:18:42 <revenantphx> It kind of struck me as funny that something imperative is so elegant to interpret functionally I guess.
13:18:45 <dafis> zzing: or just leave the type signatures away and see whether it complains
13:19:50 <kmc> revenantphx, interesting, how do you mean?
13:19:58 <dafis> zzing: those types should be exported from some module, OpenGL.Raw.Core31 or something, you'd need to import that
13:19:59 <revenantphx> Since you're going line by line... 
13:20:03 <revenantphx> think of it as folding over the code!
13:20:05 <revenantphx> :D
13:20:11 <kmc> hehe
13:20:14 <kmc> yes
13:20:15 <zzing> dafis: It seems like getting rid of the declarations is working
13:20:20 <kmc> i've written interpreters like that
13:20:22 <revenantphx> You could literally fold an evaluation function over the code, with your "accumulator" being a dictionary of local variables.
13:20:26 <kmc> folding with a "machine state" value
13:20:27 <kmc> yeah
13:20:28 <dafis> zzing: fine
13:20:33 <revenantphx> I think the Haskell mindset is really starting to grow on me :3
13:20:48 <locks> uuu, opengl with haskell
13:20:50 <revenantphx> (FP in general I guess)
13:21:02 <revenantphx> locks: ($=)
13:21:07 <revenantphx> Enough said. D:
13:21:20 <monochrom> this is why we think haskell can rule the world
13:21:28 <dafis> revenantphx: what's ($=) ?
13:21:39 <kmc> ($=) is an assignment operator used by the OpenGL bindings
13:21:43 <kmc> it also works on IORefs and some other stuff
13:21:44 <revenantphx> It's the evil infix function used to set OpenGL state machine variables.
13:21:49 <kmc> it's not evil
13:21:53 <revenantphx> It is EVIL :|
13:22:10 <kmc> you're evil ;P
13:22:15 <monochrom> I'm eva
13:22:26 <copumpkin> ayanami?
13:23:10 <dafis> imamayamami
13:23:26 <zzing> dafis: It looks like things are getting complicated here rather quickly, for example: No instance for (MatrixComponent Double) 
13:24:18 <zzing> Is there any 2d library that does vector drawing on top of opengl or something like that? It might be easier.
13:24:21 <revenantphx> kmc: So I could design a simple language evaluator as a fold over lines with accumulator (machineState, parserState)
13:24:32 <revenantphx> or something along those lines >_>
13:24:55 <dafis> zzing: yes, it wants GLdouble, it's a pain. You can of course use OpenGL-2.1.*, I think that's still with synonyms
13:25:32 <jmcarthur> zzing: graphics-drawingcombinators is a pretty nice library
13:25:32 <kmc> zzing, yes, severaly
13:25:51 <jmcarthur> zzing: depends what you're wanting to use opengl for
13:25:56 <kmc> the OpenGL library doesn't claim to be anything other than a slightly cleaned up binding to the imperative OpenGL state machine
13:26:06 <copumpkin> jmcarthur: it's a pretty terrible package name though
13:26:06 <kmc> and Haskell is a fine imperative language, but we often prefer other solutions
13:26:22 <jmcarthur> copumpkin: yeah... silly luqui
13:26:52 <revenantphx> so guys again
13:26:57 <revenantphx> plotting library suggestion?
13:27:02 <zzing> jmcarthur: I am going to make a simulation of particles hitting each other, so all I need are circles :-)
13:27:07 <jmcarthur> zzing: if you are already familiar with the opengl C library you could try openglraw. it's basically just like writing C in haskell, for better or for worse
13:27:25 <zzing> I haven't actively used opengl in 5 to 10 years
13:27:29 <kmc> i've done a fair bit of OpenGL in C and C++, and i still prefer OpenGL over OpenGLRaw
13:27:30 <jmcarthur> zzing: graphics-drawingcombinators would probably work fine, but unfortunately it uses immediate mode, so if you need to do a *lot* of circles you might have problems
13:27:34 <kmc> but ymmv
13:27:41 <zzing> hmm
13:27:41 <kmc> Raw does get you *everything* though
13:27:42 <zzing> So it is best to use something more abstract
13:27:57 <zzing> How many is a lot?
13:28:00 <jmcarthur> i don't mind Raw vs. the slightly higher level one, overall
13:28:04 <jmcarthur> zzing: depends on your GPU
13:28:09 <kmc> if you need to use double scaled floating point pixbuf mapped texture buffer fragment object shader buffers, you probably need OpenGLRaw
13:28:42 <zzing> nvidia Geforce GT 330M (macbook pro)
13:28:43 * hackagebot void 0.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.1 (EdwardKmett)
13:29:33 <Twey> In H98?
13:29:42 <c_wraith> You can do it with an infinite newtype.
13:29:52 <Twey> Oh
13:29:54 <c_wraith> newtype Void = Void Void
13:29:58 <Twey> *nod*
13:30:07 <edwardk> yeah
13:30:10 <jmcarthur> zzing: heh, unfortunately i can't just say. if you really need great performance then you may need to use non-deprecated opengl stuff, otherwise opengl's immediate mode (and therefore g-dc) might be fine, but i have no idea what you need or whether your GPU can handle it :\
13:30:18 <edwardk> the one i had was locked up in either categories or category-extras
13:30:22 <edwardk> so i factored it out
13:30:22 <revenantphx> I'm sitting here listening to old math professors bullshit with each other.
13:30:23 <Twey> Is that a valid newtype?
13:30:25 <revenantphx> It's pretty funny.
13:30:27 <edwardk> yeah
13:30:31 <jmcarthur> Twey: it's valid, yeah
13:30:33 <Twey> Interesting
13:30:35 <edwardk> the void (Void a) = void a
13:30:38 <zzing> jmcarthur: It is probably enough to start out 
13:30:39 <zzing> I can always look at modifying the library if i really need to
13:30:50 <revenantphx> "...Is X a real number? How the fuck am I supposed to know? Do I need to fucking read your mind!? THERE'S NO SUCH THING AS THE ABSOLUTE VALUE OF Z - 9"
13:30:54 <edwardk> provides the witness of ex falso quod libet Void -> a
13:31:11 <jmcarthur> zzing: good approach :)
13:31:24 <j-invariant> that's horrible :P
13:31:27 <Twey> *nod*
13:32:02 <zzing> jmcarthur: If I wanted maximum performance I would be using cocos2d with objective C. But most of what I am going to be attempting involves math over display, so the choice is clear.
13:32:19 <copumpkin> objective C for maximum performance? o.O
13:32:30 <elliott> $ cabal install parsec>=3
13:32:31 <elliott> $ 
13:32:34 <elliott> What does _that_ mean?
13:32:38 <edwardk> i needed it for the empty graph
13:32:38 <revenantphx> cocos2d is not especially maximum performance.
13:32:43 <revenantphx> It's okay, but not maximum by any means.
13:32:51 <revenantphx> Use a CVDisplayLink with raw OpenGL >_>
13:32:56 <revenantphx> there's your speed.
13:33:04 <locks> it's RAW
13:33:06 <locks> \m/
13:33:12 <revenantphx> HARDCORE MAN.
13:33:13 <monochrom> "cabal install parsec>=3" probably means stdout is redirected to file "=3"
13:33:15 <zzing> revenantphx: good for speed of coding and generally good speed
13:33:18 <elliott> monochrom: oh duh :)
13:33:31 <elliott> edwardk: your void library needs more functions!
13:33:31 <revenantphx> zzing: Well yeah, if you can get 80% of the speed for 20% of the code, it's usually worth it imo :P
13:33:35 <aristid> yesod allows pretty rapid development. yay.
13:33:44 <elliott> edwardk: I suggest a functor instance
13:34:05 <monochrom> Void has the wrong kind to be a functor
13:34:09 <elliott> data Voidy a = Voidy (Voidy a)
13:34:13 <edwardk> elliott: data Void — it isn't the version with the type arugment
13:34:17 <revenantphx> Mathematicians...
13:34:19 <revenantphx> are so immature.
13:34:19 <elliott> instance Functor Voidy where fmap f (Voidy x) = fmap f x
13:34:21 <monochrom> but I don't suppose Eq and Ord will hurt
13:34:21 <revenantphx> Seriously.
13:34:26 <elliott> edwardk: so add Voidy!
13:34:29 <edwardk> er newtype Void = Void Void — has no argument a
13:34:32 <elliott> you might also call it VoidT, just to confuse people
13:34:37 <edwardk> elliott: =P
13:34:40 <c_wraith> the void transformer
13:34:50 <edwardk> thats already around in the form of Const or some such somewhere
13:34:54 <elliott> for when you want your programs to be _really_ lazy
13:35:05 <revenantphx> You can also use "don't"
13:35:07 <aristid> VoidT is no comonad, sadly
13:35:09 <elliott> I think you should define the ord instance like this
13:35:16 <zzing> Is there a good sample for use of drawing combinators and user input and such?
13:35:17 <elliott> instance Ord Void where compare _ _ = GT
13:35:21 <revenantphx> @hackage acme-dont
13:35:22 <lambdabot> http://hackage.haskell.org/package/acme-dont
13:35:23 <elliott> incidentally
13:35:25 <elliott> > x+1 > x
13:35:26 <lambdabot>   True
13:35:27 <elliott> > 1+x > x
13:35:28 <lambdabot>   False
13:35:32 <edwardk> Eq, Ord etc is kinda funny though
13:35:33 <elliott> someone used "deriving (Ord)"
13:35:35 <elliott> and they're naughty!
13:35:37 <elliott> > x > 19843573489573457345
13:35:38 <lambdabot>   True
13:35:50 <elliott> > x+1+1 > x+2
13:35:51 <lambdabot>   False
13:35:55 <elliott> > x+1+1 == x+2
13:35:56 <lambdabot>   False
13:36:04 <elliott> > x+(1+1) == x+2
13:36:05 <lambdabot>   False
13:36:18 <edwardk> hahaha i _need_ the eq instance anyways
13:36:23 <revenantphx> > 2x > x
13:36:25 <lambdabot>   False
13:36:30 <revenantphx> faillll
13:36:36 <c_wraith> Is the void reflexive?
13:36:41 <revenantphx> Well, I guess it can't be determined one way or another.
13:36:44 <elliott> edwardk: X-D
13:36:45 <revenantphx> > 2*9 > 9
13:36:46 <lambdabot>   True
13:36:52 <elliott> edwardk: _ == _ = False
13:36:55 <elliott> you know you want to
13:36:56 <revenantphx> As they say, False implies anything.
13:36:58 <elliott> you can even prove that's correct
13:37:03 <c_wraith> I know that when you gaze into the void, the void gazes into you.  But that implies the void is symmetric.  Doesn't tell me anything about reflexivity!
13:37:05 <elliott> since you have a Void as an assumption
13:37:14 <monochrom> Ord for Expr is probably just syntactic.
13:37:20 <azaq23> @djinn t -> t
13:37:20 <lambdabot> f a = a
13:37:24 <elliott> monochrom: I have a feeling it's just "deriving (Ord)" :)
13:37:34 <elliott> Probably just for Map usage or whatever.
13:37:43 <azaq23> @djinn ((Bool -> Bool) -> Bool) -> Bool
13:37:47 <monochrom> yeah, and deriving Ord is mostly syntactic
13:37:49 <elliott> edwardk: Can we have a Num Void?
13:37:59 <lambdabot> No output from Djinn; installed?
13:38:00 <elliott> The cold, Num-bing void.
13:38:16 <copumpkin> @djinn a -> b
13:38:17 <lambdabot> -- f cannot be realized.
13:38:22 <c_wraith> elliott: that'd be hard to make well-founded, since fromInteger is part of Num
13:38:22 <copumpkin> azaq23: you killed her :(
13:38:29 <elliott> lambdabot lives in the happy world of Caleskell, free of unsafeCoerce
13:38:40 <elliott> c_wraith: fromInteger n = Void (fromInteger n)
13:38:44 <elliott> c_wraith: duh!
13:38:51 <copumpkin> elliott: that doesn't work
13:38:57 <elliott> why not
13:38:59 <copumpkin> Void is empty!
13:39:03 <elliott> https://github.com/ekmett/void/blob/master/Data/Void.hs
13:39:04 <c_wraith> It's bottom
13:39:04 <kmc> > M.fromList [(x,3),(y,4)]
13:39:04 <elliott> no it isn't
13:39:05 <lambdabot>   fromList [(x,3),(y,4)]
13:39:07 <elliott> this is haskell-98 void
13:39:09 <copumpkin> elliott: oh
13:39:12 <copumpkin> ick
13:39:12 <kmc> > (M.fromList [(x,3),(y,4)]) M.! x
13:39:14 <lambdabot>   3
13:39:15 <elliott> newtype Void = Void Void
13:39:15 <elliott> void :: Void -> a
13:39:15 <elliott> void (Void a) = void a
13:39:18 <kmc> cute
13:39:19 <elliott> so fromInteger is _obvious_
13:39:22 <elliott> it's even maximally lazy!
13:39:43 <copumpkin> it isn't void enough for me
13:39:50 <copumpkin> it must be devoid of inhabitants
13:39:55 * hackagebot void 0.2 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.2 (EdwardKmett)
13:40:02 <edwardk> copumpkin: sorry, work in agda ;)
13:40:03 <c_wraith> bottom is too many inhabitants for you?
13:40:15 <copumpkin> c_wraith: even one is one too many!
13:40:27 <c_wraith> I mean, even an EmptyDataDecls type has bottom, in Haskell
13:40:28 <Entroacceptor> don't update so quickly
13:40:28 <monochrom> yes, bottom is always counted as an inhabitant
13:40:30 <elliott> edwardk: wait, isn't your Void just those screwy Zero-less ints?
13:40:31 <elliott> yes, it is
13:40:42 <elliott> edwardk: so you CAN define Num
13:40:43 <azaq23> @djinn ((a -> b) -> a) -> a
13:40:44 <elliott> well
13:40:46 <elliott> for naturals
13:40:56 <elliott> fromInteger 0 = fromInteger 0; fromInteger n = Void (fromInteger (n-1))
13:40:58 <lambdabot> No output from Djinn; installed?
13:41:10 <copumpkin> azaq23: quit abusing poor @djinn :(
13:41:19 <edwardk> elliot: nah, because i don't want you injecting inhabitants that way
13:41:20 <elliott> azaq23: it hurts when you do that!
13:41:30 <elliott> edwardk: pfft, wimp :)
13:41:31 <azaq23> why does it fail, not outputing "f cannot be realized?"
13:41:39 <elliott> edwardk: why do you even expose the constructor?
13:41:41 <azaq23> or something in case it can
13:41:41 <copumpkin> azaq23: it's trying very hard
13:41:46 <edwardk> elliot: accident
13:41:48 <elliott> edwardk: make it "module Data.Void (Void, void) where"
13:41:50 <elliott> ah :)
13:41:51 <c_wraith> azaq23: I think the load is probably high on the machine it's running on.
13:41:57 * copumpkin soothes @djinn
13:42:01 <copumpkin> @djinn a -> ((a -> b) -> a) 
13:42:02 <lambdabot> f a _ = a
13:42:04 <edwardk> elliott: i just needed it, i didn't spend any time polishing it ;)
13:42:05 <copumpkin> yay
13:42:13 <elliott> edwardk: in fact, even "newtype Void = Void ()" would work, if you hid the constructor...
13:42:40 <azaq23> the error message's a bit misleading, in that case I would expect the same time limit exceeded message as normal @run outputs
13:42:41 <monochrom> supposedly lambdabot has the new process killer
13:42:50 <edwardk> elliott: i prefer the Void Void pattern because then void :: Void -> a works nicer
13:42:58 <elliott> edwardk: "works" :D
13:43:32 <Entroacceptor> void warranty
13:44:29 <j-invariant> I prefer
13:44:31 <j-invariant> data Void
13:44:38 <j-invariant> void :: Void -> a
13:44:42 <j-invariant> but that's not valid
13:44:44 <edwardk> j-invariant: that has its charm too, but i wanted haskell 98
13:45:00 * hackagebot void 0.3 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.3 (EdwardKmett)
13:45:32 <Entroacceptor> so, how do you use it?
13:45:39 <Entroacceptor> or, anyone care to explain it to me?
13:46:04 <edwardk> Entroacceptor: sure one sec. uploading example
13:46:07 <c_wraith> void :: Warranty -> ()
13:47:02 <zzing> Can anyone recommend a solution to this cabal install sdl problem? http://hpaste.org/43170/sdl_error
13:47:03 <edwardk> https://github.com/ekmett/graphs/blob/master/Data/Graph/Empty.hs is what i needed it for
13:47:17 <elliott> Entroacceptor: the point is that you DON'T us eit :D
13:47:19 <elliott> *use it
13:47:26 <olsner> spoon :: Void -- there is no spoon
13:47:42 <elliott> edwardk: huh since when is <$ part of Functor...
13:47:52 <edwardk> elliott: its in data.Functor but not exported by the prelude
13:47:55 <elliott> {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, FlexibleContexts, FlexibleInstances, UndecidableInstances #-}
13:48:00 <edwardk> Applicative exposes it
13:48:01 <monochrom> zzing: I need to see your "ghc-pkg -v list" and "ghc -v". In short you probably installed too much.
13:48:04 <Twey> edwardk: Icky, why?
13:48:05 <elliott> edwardk: wait, you have that at the top of your file and it still *works*?
13:48:16 <elliott> edwardk: Whenever I get to UndecidableInstances, I give up :-)
13:48:24 <edwardk> twey: those are there because i chose MPTCs rather than fundeps
13:48:39 <elliott> edwardk: And ended up requiring fundeps anyway? :p
13:48:39 <Twey> I meant about (<$)
13:48:44 <j-invariant> I give up on a different one, can't remember which
13:48:46 <edwardk> elliott: those are there because a lot of my instances are undecidable because they don't decrease in size on all arguments
13:48:51 <j-invariant> OverlappingInstances I think
13:48:54 <Twey> I'm not going to question your extension choices ;)
13:48:55 <edwardk> er MPTCs rather than type families
13:49:37 <edwardk> actually i only need MPTCs and Fundeps for that module, 's what i get for copying and pasting fast to show entroacceptor ;)
13:50:23 <zzing> monochrom: http://hpaste.org/43171/modules
13:50:47 <edwardk> overlapping instances is usually a sign of pure evil
13:51:59 <edwardk> i chose MPTCs in this case because saying Graph g v e — is pretty obvious given the common nomenclature
13:52:12 <zzing> monochrom: http://hpaste.org/43172/ghc_v
13:52:13 <dafis> zzing: you have process-1.0.1.3 in both, global and user db
13:52:23 <dafis> zzing: that spells trouble
13:52:35 <zzing> Interesting
13:52:36 <zzing> I was thinking on downloading ghc 7 and starting over :-)
13:52:46 <dafis> zzing: ghc-pkg unregister --user process-1.0.1.3
13:53:13 <zzing> ghc-pkg: unregistering process-1.0.1.3 would break the following packages: dyre-0.8.5 (use --force to override) 
13:53:13 <dafis> zzing: that will probably complain that it'd break something else
13:53:44 <dafis> zzing: I'd unregister dyre-0.8.5 and then process (user)
13:54:11 <monochrom> be merciless in unregistering all user packages affected
13:54:12 <joe6> i am trying to use extQ with geq and am not able to get them to hang together. Can anyone please help? 
13:54:15 <joe6> (geq p q) `extQ` (\x y -> geq (show $ B.unpack x) (show $ B.unpack y)
13:54:19 <zzing> It appears SDL is now going
13:54:26 <zzing> Obviously my package list is a mess
13:54:36 <dafis> zzing: and then $ cabal install --dry-run -v dyre to see whether it'd reinstall process, if no, install
13:54:41 <joe6> another parenthesis at the end.
13:54:42 <Entroacceptor> edwardk: that's over my head
13:54:55 <monochrom> "WARNING: there are broken packages.  Run 'ghc-pkg check' for more details." is a good warning.
13:55:11 <copumpkin> preflex: seen tomberek
13:55:11 <preflex>  tomberek was last seen on #haskell 52 days, 15 hours, 54 minutes and 46 seconds ago, saying: ddarius: hey, sorry my internet crashed
13:55:33 <joe6> > extQ (geq p q) (\x y -> geq (show $ B.unpack x) (show $ B.unpack y)
13:55:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:55:40 <joe6> > extQ (geq p q) (\x y -> geq (show $ B.unpack x) (show $ B.unpack y))
13:55:41 <lambdabot>   Not in scope: `B.unpack'Not in scope: `B.unpack'
13:55:45 <edwardk> Entroacceptor: the gist is the voidMap needs to provide a 'get' member that takes a Void and returns an a. and the ony way anyone can get such a void (beyond cheating) is through one of the combinators below, which steadfastly refuse to provide one
13:56:14 <edwardk> Entroacceptor: so a voidMap is a map from Void to a, where you can give it Void, and get an a, and given it a Void and an a and get back a new voidMap
13:56:48 <edwardk> entropacceptor: this is patently absurd but a vacuous way to satisfy the requirements of all the surrounding classes. an Empty graph has no edges and vertices,
13:57:08 <bla123> is there a way of sending udp broadcasts only using the network package?
13:57:30 <monochrom> yes, look into Network.Socket
13:57:40 <zzing> What is the easiest way to remove the haskell platform and pretty much anything haskell? I want to start over so to speak.
13:57:57 <mzero> which OS are you on?
13:58:00 <Entroacceptor> edwardk: ok
13:58:08 <j-invariant> are parsing and printing adjoint?
13:58:08 <zzing> Sorry, mac
13:58:27 <bla123> inet_addr seems to be the only function in Network.Socket that can create a SockAddr -- but it won't work with the broadcast address
13:58:42 <dolio> Are parsing and printing functors?
13:58:42 <edwardk> gotta run. copumpkin: i'll make sure to bring the camera, etc.
13:58:43 <monochrom> erase all of /Users/jdrake/.ghc/i386-darwin-6.12.3 , uninstall haskell platform.
13:58:50 <mzero> zzing: /Library/Frameworks/GHC.framework/Tools/Uninstaller
13:58:53 <copumpkin> edwardk: cool
13:58:53 <mzero> it's a script
13:59:43 <mzero> you will also need to remove /Library/Frameworks/HaskellPlatform.framework/
14:00:07 <mzero> and ~/.cabal and ~/.ghc
14:00:42 <mzero> lastly -- if you installed any packages globally.... then you could (but don't have to) remove those... but where they are depends on how you had cabal set up
14:00:49 <aristid> can you golf this? http://hpaste.org/43173/golfable :)
14:00:59 <mzero> by default (sigh) they ended up splatted all over /usr/local
14:01:15 <mzero> hope that helps, zzing
14:01:45 <elliott> foo.hs: Just test = Nothing
14:01:45 <elliott> Ok, modules loaded: Main.
14:01:45 <elliott> *Main> :t test
14:01:45 <elliott> test :: GHC.Prim.Any
14:01:48 <elliott> is that, uh...
14:01:51 <elliott> meant to be exposed like that?
14:01:53 <monochrom> if you don't mind "disk space leak" you don't have to delete libs. only metadata matters, and you're erasing that already.
14:02:09 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#ident
14:02:21 <zzing> mzero: That will work nicely
14:02:27 <zzing> Thank you
14:02:55 <Trollinator> Is there a way to parse "bad" HTML with HaXml? 
14:03:10 <Trollinator> Text.XML.HaXml.Html.Parse is too picky for my use case. 
14:03:20 <zzing> Now I must go to circuits lab :-)
14:04:46 <kmc> Trollinator, i think tagsoup is designed for that
14:04:59 <gwern> yeah, tagsoup is meant for broken html
14:05:12 <Trollinator> tagsoup doesn't return a tree structure though. 
14:05:47 <dankna> you could run Tidy in a pipe and parse its output.  or it might have a library version, I'm not sure.
14:05:48 <gwern> how could you? you just said your html is incorrect or lying
14:05:54 <gwern> any tree would be a guess
14:06:48 <dibblego> gwern, is it possible to get lambdabot to connect to a server that has a password?
14:06:48 <Trollinator> yes, that's what i want some library to do: make some intelligent guesses. 
14:07:00 <monochrom> pretty sure Text.Html.TagSoup.Tree is some kind of tree, whatever that means
14:07:06 <j-invariant> :t (=?)
14:07:08 <lambdabot> Not in scope: `=?'
14:07:09 <j-invariant> :t (?=)
14:07:10 <lambdabot> Not in scope: `?='
14:07:38 <j-invariant> does anyone know about reducibility
14:07:47 <j-invariant> I don't understand this remark
14:07:56 <monochrom> I don't either.
14:08:06 <copumpkin> lol
14:08:28 <Trollinator> oh... Somebody told me tagsoup just gives me a list of tags. He seems to be wrong. 
14:09:18 <monochrom> he is 99% correct because list of tags is 99% of how people use it
14:09:48 <Trollinator> :o)
14:09:57 <kmc> so the statement "HTTP is a protocol for transferring porn" is 99% correct?
14:10:16 <dented42> I'm trying to set up an instance of lambdabot on one of my machines, is this the right place to ask for help?
14:10:41 <monochrom> indeed it is Hyper Tube for Transfer of Porn
14:11:33 <gwern> dibblego: I have no idea
14:11:48 <dibblego> gwern, it seems not possible looking at the commands list
14:11:59 <Trollinator> speaking of porn... do you know this? http://didyouwatchporn.com/
14:12:07 <gwern> dibblego: then it probably isn't
14:12:17 <j-invariant> why not put indentation in the type system?
14:12:24 <gwern> Trollinator: is that one of the history-sniffing sites?
14:12:27 <j-invariant> like if you indent different the thing has different types
14:12:31 <Trollinator> yes. 
14:12:45 <gwern> j-invariant: uh. how would that work?
14:12:51 <dafis> dented42: one of several right places
14:13:32 <monochrom> just fork ghc and add indentation to type system yourself
14:13:40 <gwern> what's with everyone interested in lambdabot all of a sudden? just let it peacefully bitrot
14:14:02 <monochrom> or jhc or lhc or uhc whichever looks easiest to fork to you
14:14:04 <dented42> ok. I have it compiled and running, but it won't evaluate epxressions. it just says 'mueval-core: Time limit exceeded' every time
14:14:07 <dafis> good luck, gwern
14:14:25 <edwardk> kmc: clearly it was the original acronym: HyperText Transfer of Porn
14:14:28 <kmc> yes
14:14:38 <gwern> dented42: so use mueval standalone and see whether increasing the timelimit helps
14:15:41 <edwardk> goh missed the other comment to that effect. gotta run
14:15:42 <monochrom> lambdabot won't peacefully bitrot. recent enhancement to process killer in fact.
14:15:58 <dented42> gwern: mueval by itself seems to be working fine
14:16:35 <dented42> gwern: it perhaps seems a bit sluggish, but I don't know how snappy it is supposed to be.
14:17:04 <gwern> run the test script then
14:17:24 <aavogt> is starts up a ghci, no?
14:17:32 <aavogt> *it
14:18:16 <dented42> gwern: I'm somewhat embarrased to say that I don't know where it is.
14:18:25 <gwern> in the root of the folder
14:18:38 <gwern> aavogt: uses the ghc api, but not ghci
14:18:48 <aavogt> gwern: ghci uses the ghc api
14:19:01 <gwern> yes, so? ghc api isn't ghci
14:19:19 <monochrom> you can use the ghc api and not entirely mimick ghci
14:19:23 * hackagebot wumpus-core 0.42.1 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.42.1 (StephenTetley)
14:19:44 <kuffaar> <kmc> kuffaar, how about Map.insertWith (++) k [v]
14:19:45 <aavogt> gwern: it's a reason why it might be slow
14:19:53 <kuffaar> Hmm in this case it's a Seq though
14:20:00 <gwern> aavogt: maybe his machine is just slower than mine
14:20:07 <kuffaar> Map String (Seq String)
14:20:14 <gwern> my laptop isn't very impressive but if he had a 5 year old machine or something
14:20:22 <kuffaar> "Insert with a function, combining new value and old value. insertWith f key value mp will insert the pair (key, value) into mp if key does not exist in the map. If the key does exist, the function will insert the pair (key, f new_value old_value). "
14:20:23 <kmc> kuffaar, sure, you can do something by analogy
14:20:39 <kuffaar> I think I need to use flip with (|>)?
14:20:59 <kuffaar> (flip . (|>))
14:21:06 <kmc> no you need something analogous to (++)
14:21:08 <dented42> gwern: I'm not sure where cabal install is putting it...
14:21:16 <gwern> dented42: use cabal unpack
14:21:32 <kuffaar> kmc: (flip . (|>)) newValue someSequence
14:21:35 <kuffaar> Is what it would do then
14:21:49 <kuffaar> Usually you would do: someSequence |> newValue
14:21:57 <kmc> no
14:22:02 <kuffaar> Oh? :o
14:22:07 <kmc> that's not what you need with insertWith
14:22:09 <kmc> do you understand why i used (++) and not (:)
14:22:20 <kmc> and why i used [v] instead of v
14:22:24 <gwern> mappend?
14:22:29 <kuffaar> kmc: <kuffaar> Map String (Seq String)
14:22:32 <kuffaar> It's a sequence
14:22:39 <gwern> (Seq has Monoid)
14:22:55 <kuffaar> ++ is not even defined for that is it?
14:22:56 <kmc> i know kuffaar 
14:22:58 <kmc> you're not paying attention
14:23:05 <kmc> i told you how to solve the problem for Map String [String]
14:23:09 <kmc> and now you can translate it
14:23:15 <kmc> but (|>) is not the translation of (++)
14:23:18 <kmc> <kmc> do you understand why i used (++) and not (:)
14:23:19 <kmc> <kmc> and why i used [v] instead of v
14:23:28 <kmc> for [String]
14:24:38 <kuffaar> Well, what I want to do is someSequence |> newValue
14:24:49 <kuffaar> And you can use that with insertWithKey as far as I can see
14:25:12 <kmc> ok, do that then
14:25:29 <gwern> looks like you rather annoyed him
14:25:53 <kuffaar> :/
14:26:37 <gwern> if we were haskell monks, I'd thwap you with my stick. bad kuffaar, don't annoy the regulars!
14:26:39 <kuffaar> gwern: What does the Monoid instance of Seq do?
14:26:55 <gwern> kuffaar: well, do you know what a monoid is?
14:26:55 <kuffaar> Err the mappend one
14:26:56 <kuffaar> Yes
14:27:02 <kuffaar> Magma, monoid, group, blah
14:27:09 <aavogt> kuffaar: look at what the instance looks like
14:27:12 <kuffaar> I have some basic knowledge of algebraic structures
14:27:14 <gwern> then my assumption is it's exactly like mappend on list
14:27:23 <aavogt> it might be    Monoid m => Monoid (Seq m)
14:27:34 <aavogt> or   instance Monoid (Seq a)
14:27:50 <kuffaar> Anyways, kmc already pointed me to the right function I think
14:28:10 <kuffaar> The original question was: What is the equivalent of std::map<std::string, std::vector<std::string> > blah; blah["abc"].push_back("def"); in Haskell? I was just wondering about "default constructed insertion" where it would start with an empty container when you access a key for the first time. What is the normal way to achieve this in combination with Data.Map.Map?
14:28:21 <gwern> that is, Seq a -> Seq a -> Seq a, implemented as mappend = (|>)
14:28:56 <kuffaar> But (|>) :: Seq a -> a -> Seq a
14:28:57 <djahandarie> Thank god for type inference
14:29:06 <sproingie> the equivalent of that in haskell is a completely different code idiom
14:29:08 <kuffaar> No, thank SPJ
14:29:27 <kuffaar> sproingie: Well, kmc was right about insertWithKey, no?
14:29:40 <kuffaar> You can do precisely that efficiently with that function
14:29:52 <sproingie> probably .. i havent touched Data.Map except to play with it
14:30:00 <revenantphx> whoever says a development cycle is Analyze, Design, Build, Test, Deploy...
14:30:12 <revenantphx> No.
14:30:18 <sproingie> since my haskell stuff had fixed keys so i just ended up using tuples
14:30:24 <copumpkin> Analyze, Design, Buildprove, Deploy
14:30:25 <revenantphx> It's actually Analyze, Design, Build, [Test | _ <- [0..]], Deploy...
14:30:35 <sproingie> copumpkin: ... Profit?
14:30:37 <gwern> a |> b, after all, one would expect.
14:30:53 <copumpkin> Buildprove is the interleaved write code and proofs of code
14:31:00 <copumpkin> since they are very tightly related
14:31:02 <monochrom> generally it is better to specify your problem and ask for a haskell solution, rather than a code snippet out of context and ask for a haskell translation.
14:31:03 <kuffaar> Analyse, outsource, dinner
14:31:07 <revenantphx> copumpkin: unit tests + type checker?
14:31:08 <gwern> er, I mean, it'd be odd if it were something like mappend a b = fromList (toList a `mappend` toList b)
14:31:13 <revenantphx> + static analyzer stuff
14:31:20 <copumpkin> revenantphx: nah, just proofs
14:31:23 <copumpkin> unit tests are for wusses
14:31:30 <revenantphx> well this is fecking python
14:31:34 <revenantphx> so you can see the issue already.
14:31:37 <copumpkin> prove it correct anyway
14:31:40 <gwern> copumpkin: I'd be in trouble with mueval without tests
14:31:51 <copumpkin> gwern: with proofs you wouldn't be
14:32:07 <gwern> yes, but how the deuce would I get proofs of mueval?
14:32:09 <djahandarie> ETA on Haskell compiler in Agda
14:32:19 <copumpkin> djahandarie: tomorrow
14:32:23 <copumpkin> let me finish picking my nose
14:32:31 <djahandarie> Wow you're going to be productive at Boston Haskell aren't you?
14:32:47 <copumpkin> djahandarie: don't you wish you had your priorities straight, now
14:32:48 <djahandarie> ... that is tonight isn't it?
14:32:53 <copumpkin> indeed
14:33:12 <djahandarie> It would be cool if you guys just did some elite hackathon
14:33:24 <djahandarie> Invite SPJ and Simon Marlow too
14:33:28 <gwern> hackathons are small enough as they ;are
14:33:28 <j-invariant> a haskell compiler in Agda?
14:33:57 <copumpkin> mmm, an elite hackathon
14:34:01 <aristid> j-invariant: pretty recursive
14:34:03 <copumpkin> I'd like a regular hackathon in boston though
14:34:21 <monochrom> as opposed to a context-free hackathon? <duck>
14:34:32 <djahandarie> Whatever it is regex will work for it
14:34:57 <gwern> but now you have 2 problems
14:35:09 * copumpkin pumps monochrom 
14:35:20 <monochrom> the pumpkin lemma!
14:35:31 <monochrom> actually, two lemmas
14:35:36 <djahandarie> the pumpkinhole principle
14:35:36 <mreh> :t reads
14:35:37 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:36:02 <mreh> reads "1"
14:36:06 <mreh> > reads "1"
14:36:07 <lambdabot>   []
14:36:23 <Twey> > reads "1" :: [(Int, String)]
14:36:24 <lambdabot>   [(1,"")]
14:36:27 <Twey> Defaults to ()
14:36:32 <Twey> > reads "()"
14:36:33 <lambdabot>   [((),"")]
14:36:48 <kuffaar> What is snd?
14:36:52 <kuffaar> The remaining string?
14:36:52 <djahandarie> :t snd
14:36:53 <lambdabot> forall a b. (a, b) -> b
14:37:00 <djahandarie> Oh
14:37:01 <kuffaar> I am talking about the reads ^
14:37:01 <Twey> kuffaar: Yes, in the case of an incomplete parse
14:37:02 <mreh> second
14:37:05 <Twey> > reads "()foo"
14:37:05 <lambdabot>   [((),"foo")]
14:37:07 <kuffaar> Ah, ok
14:37:24 <mreh> > reads "123" :: [(Int, String)]
14:37:25 <lambdabot>   [(123,"")]
14:37:34 <mreh> drat
14:37:48 <aristid> mreh: ?
14:38:05 <mreh> i was expecting all possible incomplete parses
14:38:15 <mreh> I don't know why I said "drat"
14:39:02 <mreh> anyway, reason I came here was to ask why there's an arrow in this pattern guard!
14:39:19 <mreh> readM s | [x] <- parse = return x
14:39:19 <mreh>             | otherwise    = throwError $ "Failed parse: " ++ show s
14:39:19 <mreh>         where
14:39:19 <mreh>             parse = [x | (x,t) <- reads s]
14:39:39 <aristid> mreh: because pattern guards use arrows?
14:39:53 <monochrom> looks like the grammar requires it
14:40:12 <mreh> I thought they were just boolean expressions
14:40:19 <monochrom> not any more
14:40:31 <aristid> mreh: they're like view patterns now
14:40:48 <mreh> that sounds suspiciously like software engineering
14:41:18 <monochrom> no relation with design patterns
14:41:45 <ddarius> Pattern guards have been along for a long time, and it's likely view patterns are interpreted in terms of pattern guards.
14:41:47 <mreh> so that's saying, in the case that parse is a singleton list do return x, otherwise...
14:41:59 <kuffaar> "Same as insertWith, but the combining function is applied strictly. This is often the most desirable behavior. " http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
14:42:07 <kuffaar> What does the strict application part mean?
14:42:38 <question-mark> hey @ all
14:42:47 <mreh> o/
14:42:52 <question-mark> i got a question, can anybody help me?
14:42:56 <kuffaar> Haha
14:43:00 <mreh> ask, don't ask to ask
14:43:15 <kuffaar> mreh: He's making fun of us
14:43:21 <mreh> I get it
14:43:21 <question-mark> so i got a list [1,2,3], is there any way to pick up a number i want? like the 2?
14:43:26 <kuffaar> It's a prelude to recursive questions
14:43:26 <monochrom> insertWith forms the thunk x+y (or whatever your combining function does) and stores it. could become huge for no benefit. insertWith' seqs x+y.
14:43:30 <mreh> :t (!!)
14:43:30 <kuffaar> In the spirit of Haskell
14:43:31 <lambdabot> forall a. [a] -> Int -> a
14:44:00 <mreh> when he blows the stack he'll fuck off
14:44:02 <question-mark> i know its possible with tuples, but how about lists?
14:44:14 <kuffaar> > [1, 2, 3] !! 1
14:44:15 <lambdabot>   2
14:44:18 <kuffaar> question-mark ^
14:44:38 <question-mark> i gonna try it, thanks kuffaar
14:44:51 <kuffaar> question-mark: People who come from imperative programming languages frequently misuse it to simulate C like for loops though, which is definitely not what you want in Haskell
14:45:04 <monochrom> http://www.vex.net/~trebla/lazy-question-stream.html
14:45:42 <kuffaar> [] is a linked list so !! is actually an inefficient O(n) operation as opposed to indexing an array in a C for loop
14:46:03 <kuffaar> The requested URL /~trebla/lazy-question-stream.html was not found on this server.
14:46:15 <monochrom> oops sorry
14:46:15 <kuffaar> monochrom: What does "seqs" mean?
14:46:30 <monochrom> http://www.vex.net/~trebla/humour/lazy-question-stream.html
14:46:50 <monochrom> seqs is seq present tense for third person
14:46:55 <question-mark> woho it worked! damnit i was searching this for hours. next time i gonna just ask here :D
14:47:29 <kuffaar> question-mark what are you using it for though? It's a frequently misused operation when you are new to Haskell
14:47:39 <kuffaar> Care to pastebin the code you are working on?
14:47:47 <monochrom> if the list length is O(1) anyway it's fine
14:47:54 <kuffaar> :p
14:47:57 * ddarius recommends that question-mark search for hours (or less, if he finds the answer before then) next time too.
14:48:40 <question-mark> its kinda hard to explain
14:50:03 <question-mark> i got a list with vertex's and i have to calc the distanst between them
14:50:05 <kuffaar> Is sequence >< $ Seq.singleton x the same speed as sequence |> x?
14:50:16 <kuffaar> Because this would ease the job with insertWith', I think
14:50:34 <kuffaar> The plural of vertex is vertices
14:51:05 <question-mark> sorry, im not english and never learnt it realy
14:51:22 <question-mark> learned*
14:52:07 <sipa> ~its latin actually :)
14:52:39 <question-mark> i never learned latin aswell, but hey, thats not the topic
14:53:00 <stepcut> I studied latin for 5 years.. but I forgot it all.. kind of like C
14:53:17 <adimit> I don't think 'vertices' is a latin form. I might be wrong though.
14:53:25 <kuffaar> adimit: I think it's correct
14:53:26 <tac-tics> C is more useful
14:53:40 <kuffaar> the Latin plural of INDEX is INDICES
14:53:47 <aristid> stepcut: i think latin is for passionate adults, not unwilling children.
14:53:47 <kuffaar> So I suppose the one for VERTEX is VERTICES
14:53:55 <monochrom> latin is more typesafe than c
14:54:05 <aristid> well, or passionate children, of course.
14:54:14 <ion> The plural for CAPSLOX is CAPSLOCES
14:54:14 <adimit> kuffaar: my Latin classes were incredibly long ago… so you might be right.
14:54:15 <mreh> it's a hell of a lot more baroque
14:54:24 <kuffaar> Although they are pronounced differently
14:54:40 <kuffaar> ion: Classical Latin had no miniscules
14:54:50 <adimit> well obviously, Latin pronounciation differs a great deal from English.
14:54:56 <kuffaar> pronunciation*
14:56:26 <monochrom> a person new to english would not know when to use english rules and when to use latin rules, naturally
14:56:40 <tac-tics> Evaluator question. Is an "environment" just another way of doing term substitution?
14:56:52 <mreh> cacti? cactuses?
14:57:28 <Trollinator> there are pronunsiation rules in english? 
14:57:29 <aristid> CLASSICAL LATIN HAD NO MINISCVLES
14:57:34 <kuffaar> pronunciation*
14:57:43 <Trollinator> oops
14:57:48 <kuffaar> aristid: It had no spaces either
14:57:58 <aristid> CLASSICALLATINHADNOMINISCVLES
14:58:01 <kuffaar> They used a dot in the middle basically
14:58:05 <kuffaar> To separate words
14:58:07 <Saizan> tac-tics: it's a way to not have to do it
14:58:12 <mreh> that's nonsense
14:58:13 <quuuux> kuffaar: word composition
14:58:15 <aristid> kuffaar: but i guess the dot was optional
14:58:18 <mreh> they use to write in lowercase
14:58:19 <monochrom> an environment stores information you need for substitution. sometimes it's also there to help postpone substitution.
14:58:19 <kuffaar> aristid yeah
14:58:31 <mreh> you think they sent tablets to their sweethearts and their mothers
14:58:48 <aristid> mreh: of course. 50 kilograms of love.
14:58:52 <kuffaar> http://upload.wikimedia.org/wikipedia/commons/4/46/Appiuscaecusstele01.jpg
14:59:00 <kuffaar> But in more formal inscriptions it was used later
14:59:13 <kuffaar> But in graffiti they would not always do that I suppose
15:00:02 <tac-tics> monochrom: cool. Am I right in thinking of an environment as a "value-level" version of gamma?
15:00:02 <mreh> I've read that gravestone before
15:00:07 <mreh> I think it was in a text book
15:00:12 <monochrom> I don't know gamma
15:00:15 <mreh> definitely -blah
15:00:43 <tac-tics> Γ 
15:01:05 <monochrom> yes
15:01:14 <tac-tics> Sweet
15:01:19 <tac-tics> Thanks
15:01:25 <kuffaar> <Trollinator> there are pronunsiation rules in english? <- well for some languages there are self proclaimed authorities many people look up to. Whether you do that, is up to you. For English it's not as centralised as it is with French, for example, I think.
15:01:46 <kuffaar> And there is a vast amount of different dialects of English being spoken natively all over the world
15:01:53 <monochrom> but I was referring to plural rules, not pronounciation rules.
15:02:00 <kuffaar> pronunciation*
15:02:25 <sproingie> pronunciation
15:02:31 <sproingie> wait that was right
15:03:22 <monochrom> screw english
15:03:31 <kuffaar> :)
15:05:07 <quuuux> English's orthography actually gives most dialects a real fighting chance at pronouncing an unknown word correctly (or correct modulo stress or modulo s-voicing)
15:05:49 <kuffaar> English orthography is a nightmare
15:06:16 <quuuux> and, depending on register, the pluralisation system can be very regular. I can say vertexes and gooses and be understood perfectly :)
15:07:06 <quuuux> kuffaar: it actually strikes a pretty good balance between ease of transcription for various dialects, and corresponding ease of reading
15:07:20 <lispy> gooses would be the plural of types of geese
15:07:30 <kuffaar> lispy: Hahaha
15:07:56 <quuuux> lispy: in the acrolect, sure :)
15:08:03 <monochrom> mary of scots was the daughter of mary of geese
15:10:21 <joe6> (tf v) :: B.ByteString; geq (tf v) (tf w)  *** Exception: toConstr
15:10:47 <joe6> I am trying to use geq to compare byteString and this is the error. Can anyone please help?
15:11:11 <ikeg> where does the function geq come from?
15:11:28 <joe6> syb
15:11:43 <joe6> geq :: Data a => a -> a -> Bool         -- Defined in Data.Generics.Twins
15:11:53 <kuffaar> quuuux: English uses the derivative of the Italic alphabet which originally evolved for a language which is phonetically quite difference so they had to cheat around quite a lot to even represent many sounds in it because the original language did not have it. Additionally it has a lexicon which borrows from numerous languages and it to make it all worse, radical pronunciation shifts occured over the course of centuries whereas the orthography frequently s
15:11:53 <kuffaar> tayed the same.
15:11:56 <joe6> dreixel: are you around?
15:12:08 <kuffaar> ikeg: Use Hoogle
15:12:12 <kuffaar> http://www.haskell.org/hoogle/
15:12:16 <kuffaar> @hoogle geq
15:12:17 <lambdabot> Data.Generics.Twins geq :: Data a => a -> a -> Bool
15:12:17 <lambdabot> Language.Haskell.TH type RangeQ = Q Range
15:12:17 <lambdabot> Language.Haskell.TH.Lib type RangeQ = Q Range
15:12:31 <kuffaar> Template Haskell :O
15:12:46 <ikeg> kuffaar: thanks, i learnt
15:13:02 <joe6> no, actually part of the Scrap Your Boilerplate modules
15:13:07 <joe6> not Template Haskell
15:13:59 <dafis> hoogle needs an option to "search for exactly this name"
15:14:12 <ikeg> joe6: hoogle answers ambiguously, for users
15:16:35 <sm> dafis: and one to "search just package names"
15:16:39 <joe6> guys: anyone know generics?
15:16:39 <mreh> I need a new boiler
15:17:18 <mreh> any suggestions for a shell scripting library, dons wrote a nice blog post describing one
15:18:27 <quuuux> kuffar: a lot of the innovations in modern dialects occurred (or became widespread) after spellings in Late Middle to Early Modern English began to be formalised (~1400 or so and onwards, coincident with the printing press). That's one reason why the various dialects can have such a good stab with orthography: the words are written as they -were-, so it's just a matter of applying sound changes. As for the variously-sourced words, that's just a mat
15:18:27 <quuuux> ter of learning to recognise Germanic/Latinate/whatever roots and apply the correct reading (a heuristic process, but so is most of language)
15:18:38 <aavogt> joe6: the Data instance for Bytestring is bad. This is common. Take Data.Map.Map as another example of it
15:19:16 <aavogt> joe6: what you can do is rewrite geq adding a case that does the normal (==) instead of geq when encountering a Bytestring
15:19:19 <joe6> aavogt: is it fixed in the latest version?
15:19:37 <kuffaar> quuuux: Why don't you tab nicks? :'(
15:19:41 <joe6> aavogt: ok, thanks. I was not sure if I was doing something wrong.
15:19:42 <aavogt> joe6: it's probably not a "problem" to the authors
15:19:57 <joe6> aavogt: thanks a lot for answering the questions.
15:20:06 <quuuux> kuffaar: sorry! It's a habit I weaned myself off after it kept picking the wrong ones
15:20:17 <aavogt> joe6: they are probably not concerned with writing data instances that expose the proper interface without exposing implementation details
15:20:31 <kuffaar> I wouldn't dream of typing anybody's full nick!
15:20:41 <kuffaar> 1-2 letters should suffice for most of them
15:20:42 <monochrom> the only way to win is to omit nicks
15:20:53 <aavogt> joe6: if you complain it might get changed :)
15:20:59 <kuffaar> mo<tab>
15:21:06 <joe6> aavogt: i could write a module on top of bytestring that can change the behaviour, correct?
15:21:25 <kuffaar> showTreeWith hahaha
15:21:25 <joe6> aavogt: will send them an email
15:22:06 <dafis_> mo<tab> -> Modius: 
15:22:37 <aavogt> joe6: you can't override instances. You could use a newtype to write a new one
15:22:49 <kuffaar> dafis_: Looks like my client is more advanced than yours <:
15:23:00 * aavogt means      newtype ByteString2 = ByteString2 ByteString
15:23:03 <kuffaar> (I am using alt_completion.pl with X-Chat)
15:23:14 <aavogt> instance Data ByteString2 where ... 
15:23:37 <dafis_> kuffaar: X-Chat too, with whatever comes as a default
15:23:44 <joe6> aavogt: ok, thanks.
15:24:05 <kuffaar> Grab alt_completion.pl, it was coded by somebody from #xchat, it's delicious
15:24:38 <monochrom> I just chose "tab completion sorting order: last-spoken"
15:25:22 <ikeg> i wonder 'deriving Eq' maybe needed after that newtype declaration... : newtype B2 = B2 ByteString deriving Eq --???
15:25:51 <monochrom> however, following british parliament convention, the only correct completion is: Mr. Speaker
15:26:17 <ikeg> does generic equality 'geq' need 'eq'?
15:26:26 <ikeg> well mean '=='
15:27:42 <aavogt> ikeg: no
15:28:48 <aavogt> ikeg: geq a b   makes sure that a and b have the same constructor, and that the value in the constructors are also equal (recursively using geq)
15:28:50 <astroboy> I was unsure wheter to ask this in #haskell or #emacs, but how can I get the type of a function that's not in the standard library in haskell-mode?
15:29:37 <monochrom> not in the standard library, and in some other library? I don't think it's easy.
15:29:45 <astroboy> I can get the types with inferior-haskell-type but not for all functions
15:29:50 <dibblego> is it possible to have a Library and Executable in the one cabal package?
15:30:00 <monochrom> yes possible
15:30:02 <astroboy> it would really speed up development with libraries
15:30:07 * hackagebot show 0.4.1.1 - 'Show' instances for Lambdabot  http://hackage.haskell.org/package/show-0.4.1.1 (GwernBranwen)
15:30:21 <ikeg> aavogt: thanks, i grasp (and i have to read original papers about syb right now
15:30:35 <djahandarie> > id
15:30:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
15:30:37 <lambdabot>    arising from a use of `...
15:30:45 <djahandarie> Can this please be resolved
15:30:54 <monochrom> > id :: ()->()
15:30:57 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> ())
15:30:59 <lambdabot>    arising from a use of...
15:31:04 <monochrom> oh, interesting
15:31:40 <djahandarie> I don't even understand the error
15:31:55 <djahandarie> 19:24 <lambdabot>    arising from a use of `M6084224785513977070.show_M6084224785513977070'
15:31:58 <djahandarie> 19:24 <lambdabot>                 at <interactive>:(2,0)-(4,30)
15:32:39 <monochrom> the two instance come from Test.SmallCheck and Data.NumInstances
15:33:40 <monochrom> smallcheck-0.4:Test.SmallCheck and vector-space-0.7.2:Data.NumInstances
15:34:13 <djahandarie> Uh
15:34:18 <djahandarie> What in the world is the point of SmallCheck
15:34:27 <djahandarie> Anything useful you can do with it involves IO ()
15:34:32 <Philonous> astroboy: When the library is loaded in emacs' ghc process you should get types for all the exported functions
15:34:41 <monochrom> to strive for small counterexamples as opposed to randomly chosen large counterexamples
15:34:55 <djahandarie> monochrom, I mean in lambdabot
15:34:58 <djahandarie> Not in general, lol
15:36:09 <monochrom> perhaps someone really loves the Property type
15:36:29 <monochrom> well tons of lambdabot imports are pointless
15:36:30 <gwern> well, this is an odd error. 'cabal: unlambda.cabal:20: Construct not supported at this position: F 20
15:36:33 <gwern> "tested-with" "GHC==6.8.2"'
15:37:00 <aavogt> djahandarie: the Show instance from SmallCheck is nice
15:37:03 <dcoutts_> mm, less than ideal error message
15:37:07 <monochrom> they are imported due to personal friendship between the requester and the admin
15:37:13 <dcoutts_> gwern: what does that line look like?
15:37:25 <gwern> dcoutts_: I dunno, before it was Cabal-version:
15:37:30 <gwern> so I think it's something before it
15:37:41 <gwern> it seems to hate anything at line 20
15:37:48 <dcoutts_> heh
15:38:38 <gwern> dcoutts_: are we not allowed to put the repository info before the build-type/cabal-version/tested-with data/
15:39:04 <dcoutts_> gwern: that's right, yes.
15:39:09 <gwern> bah humbug
15:39:13 <dcoutts_> gwern: the global stuff is one "section"
15:39:14 <gwern> you can't tell me what to do!
15:39:18 <dcoutts_> hah
15:40:37 <monochrom> but he can write a program to abort on what you do
15:41:06 <sm> fiendish!
15:41:56 <djahandarie> aavogt, I'm actually failing to see where there is a Show (a -> b) instance in SmallCheck
15:42:24 <question-mark> so i finally made my task. i had to define the perimeter of a polygon with optional many vertICES. i tried it with the "!!" even thou kuffaar said they are kind of unusual. this is my code: " calc x z = if (z+1)<(length x) then (distance (x!!z) (x!!(z+1)) + (calc x (z+1))) else distance (x!!z) (x!!0)  "   this is the type "  calc :: [Vertex] -> Int -> Float  ". but how could i code this without "!!" ?
15:43:19 <kuffaar> question-mark you might not want to use [Vertex] for that
15:43:27 <kuffaar> Since !! is very slow there
15:43:36 <question-mark> i have to. got no choice
15:43:41 <kuffaar> Oh, ok :|
15:43:44 <mzero> sure you do --- you want to explore this pattern:     zipWith f  someList (tail someList)
15:43:55 <monochrom> [Vertex] is fine. you just need to write like calc (x:y:xs) = ...
15:44:00 <question-mark> :( i know. the hole taks is stupid, as always...
15:44:15 <kuffaar> Oh yeah, you are right :p
15:44:39 <kuffaar> I didn't even look at the code, I just saw !! with variable index
15:45:02 <kuffaar> question-mark by the way, I think you can do if z + 1 < length x
15:45:08 <kuffaar> No need for () there
15:45:17 <mzero> there's nothing wrong with the task at all -- infact it is a good one for exploring how to do things in the "functional style"
15:45:18 <kuffaar> No need for () around the body of then either
15:45:22 <question-mark> ok
15:45:47 <mzero> so - here's the challenge, question-mark: You don't need length or !! to do this task at all!
15:46:00 <question-mark> i tried it with (x:y:xs) monochrom but i failed... it was too complex
15:46:07 <sm> is there a good way to find a commit on github from the hash ?
15:46:09 <dafis> question-mark: do you know zipWith?
15:46:35 <question-mark> its 1 oclock at my place... and i still got like 6 task to do :/
15:46:41 <question-mark> no defis
15:46:54 <kuffaar> sm: Hmm can't you just use git for that?
15:47:00 <dafis> @type zipWith
15:47:00 <kuffaar> And then git checkout <hash>?
15:47:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:47:07 <sm> lord.. I'm hoping not to :)
15:47:15 <kuffaar> sm why not?
15:47:19 <monochrom> http://hpaste.org/43174/perimeter
15:47:39 <kuffaar> monochrom what is that more@ thing?
15:47:39 <astroboy> monochrom: so do you think it is possible to get the type for any function?
15:47:46 <sm> oh let's not go there.. just trying to browse a bugfix from another project. Point noted
15:47:47 <astroboy> kuffar: it's an alias
15:47:55 <kuffaar> astroboy: Why don't you tab nicks?
15:48:18 <monochrom> if you match [a,b,c,d] against (x:more@(y:_)), x=a, y=b, more=[b,c,d]. handy, no?
15:48:29 <astroboy> kuffaar: I don't know what "tabbing nicks" means :P
15:48:45 <question-mark> may be monochrom, i gonna check this
15:48:58 <kuffaar> astroboy: Type "ku" and hit your tab key
15:49:02 <kuffaar> In irssi
15:49:24 <monochrom> type "kuffaar" then hit your tab key to get ": "
15:49:26 <astroboy> kuffaar: oh, neat :P
15:49:33 <kuffaar> monochrom: Ahh, I get it
15:49:36 <kuffaar> astroboy: :P
15:49:45 <astroboy> kuffaar: with the @ you assign two names to the same thing
15:50:06 <astroboy> so you can pattern match in a data type while having a name for the whole thing
15:50:27 <ion> Typing the nick is an O(n) operation that doesn’t require any extra brain cycles. Tab completion requires a context switch to stop typing and check whether it got the nick right, or whether you need to hit tab again.
15:51:35 <astroboy> Philonous: sorry for the late reply, but how do I load the library into emacs ghc process? actually how do I handle emacs ghc process at all?
15:52:05 <monochrom> oh bother, my calc is wrong. but I know how to fix it.
15:52:28 <Philonous> astroboy: Easiest way I can think of is add an include to some haskell file and C-c C-l 
15:52:59 <question-mark> monochrom u forgott to calc the distance between the first and the last vertex, i guess
15:53:07 <question-mark> or am i wrong?
15:53:17 <monochrom> that is what I forgot.
15:53:23 <question-mark> ok :)
15:54:38 <Philonous> astroboy: import, not include, but you catch my drift
15:56:05 <question-mark> monochrom, so how to fix this? do i need "if" for that?
15:57:20 <monochrom> http://hpaste.org/paste/43174/perimeter_annotation#p43175
15:57:45 <question-mark> omg
15:58:01 <astroboy> Philonous: so I would have to look for that file anyway
15:58:20 <astroboy> Philonous: which is what I would like to avoid :P
15:59:05 <dafis> sum $ zipWith distance vertices (tail vertices ++ [head vertices])
15:59:30 <Philonous> astroboy: No, you just create a new file, import the libraries you are interested in, shove it into ghci (C-c C-f) and start inquiring. 
16:00:26 <Philonous> Pardon, I meant C-C C-l
16:00:31 <Philonous> C-c even
16:01:44 <monochrom> C-c C-p was the secret command for sending a report to the kgb
16:02:22 <parcs> does there exist monadic version of until?
16:02:43 <mreh> @remember monochrom C-c C-p was the secret command for sending a report to the kgb
16:02:44 <lambdabot> Nice!
16:05:08 <dafis> @hoogle (a -> m Bool) -> (a -> m a) -> a -> m a
16:05:08 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
16:05:09 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:05:09 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:06:06 <dafis> parcs: hoogle doesn't seem to know about one
16:06:12 <kuffaar> I have a Map String (Seq String) and I need to calculate a Container (String, Seq String) which is sorted according to the length of the sequence. Should I just use assocs and sortBy for that or is that inefficient?
16:06:21 <astroboy> Philonous: ok I'll try now
16:06:53 <kuffaar> Hmm assocs returns a list so I guess the sorting on that is efficient since swaps are cheap on linked lists?
16:07:00 <dafis> kuffaar: should be okay
16:07:03 <kuffaar> Alright
16:07:39 <dafis> kuffaar: but it doesn't really swap, it creates a new list
16:07:39 <dcoutts_> kuffaar: I think Seq caches its length, so sorting by length should be ok
16:07:50 <astroboy> Philonous: Wait a second, I'm not sure how this work. I am editing a file that imports various stuff
16:08:03 <kuffaar> Yeah, lenght on Seq is fast - it's why I picked it originally
16:08:19 <kuffaar> dafis well, ghc can optimise that internally, no?
16:08:39 <kuffaar> I mean when you create a list and you sort it without ever reusing the original value again it can use swaps, no?
16:08:43 <joe6> #if defined(__GLASGOW_HASKELL__) deriving (Data, Typeable)
16:08:43 <joe6> #endif
16:08:50 <astroboy> Philonous: it says that C-c C-f is undefined
16:09:04 <joe6> does anyone know when __GLASGOW_HASKELL__ is defined.
16:09:23 <kuffaar> joe6 I would guess when you run it through ghc? :o
16:09:33 <joe6> aavogt: could this definition be the cause of why geq is not working with bytestring?
16:09:51 <dafis> kuffaar: no, it creates new cons-cells, but that's cheap, it re-uses the original data, which might be expensive to copy
16:10:27 <dafis> joe6: could be
16:10:30 <kuffaar> I was wondering if it's cheaper to sort, say, a Data.Vector than a []
16:10:45 <mreh> I am so weak, I tried to learn bash, I've concluded that it's much easier to do it in haskell
16:11:06 <adimit> don't worry, mreh, i script in Haskell too.
16:11:12 <adimit> most of the time it's shorte.
16:11:15 <adimit> +r
16:11:19 <hpc> i use perl
16:11:24 <dafis> kuffaar: probably not if you have to construct a Data.Vector first but already have the list
16:11:25 <hpc> it's not only short, but also impenetrable
16:11:30 <kuffaar> Going from Haskell to shell scripting in bash is like going from the age of quantum mechanics to the stone age
16:11:45 <dafis> kuffaar: iron age
16:11:48 <hpc> kuffaar: or from your sweet-ass lab to the bathroom down the hall
16:11:53 <kuffaar> :o
16:13:39 <question-mark> monochrom, i checked your new code but i still didnt get the right perimeter. if i enter [(1,0),(1,1),(0,1),(0,0)] ill get 3.0 but not 4.0 ...
16:13:42 <joe6> aavogt: let chkbs :: Data a => a -> a -> Bool; chkbs x y = (show $ B.unpack x) == (show $ B.unpack y)
16:14:14 <joe6> t e f = if ((show $ typeOf e) == "Data.ByteString.Internal.ByteString") then chkbs e f else (geq e f)
16:14:33 <joe6> i cannot get the chkbs to compile. Can someone please help with this?
16:14:49 <joe6> the generics stuff is really frustrating to work with.
16:15:29 <kuffaar> joe6 why do you wrap your if statement in ()?
16:15:29 <dafis> joe6: a Typeable constraint and cast?
16:15:59 <kuffaar> Or the else one for that matter hm
16:16:25 <joe6> kuffaar: just want it to work. I can sort out the parenthesis later.
16:16:31 <joe6> dafis: what do you mean?
16:17:02 <dafis> chkbs :: Typeable a => a -> a -> Bool; chkbs x y = case cast x of { Just x' -> B.unpack x' == B.unpack y ; Nothing -> False }
16:17:52 <dafis> or something else in the Nothing-branch
16:20:07 <joe6> dafis: tried that. this is the error: Could not deduce (a ~ B.ByteString) from the context (Typeable a)
16:20:28 <Saizan> you need to cast y too
16:21:18 <joe6> oh, yeah. that is the issue. cast y
16:21:22 <joe6> will fix it.
16:21:26 <joe6> thanks guys.
16:22:21 <Philonous> astroboy: Yeah, I meant C-c C-l 
16:22:27 <sm> how would you ensure that you always read and write UTF-8 ?
16:22:30 <Saizan> (why are you unpacking them for (==)?)
16:22:45 <sm> independent of current locale
16:22:56 <Saizan> hSetEncoding on stdout and stdin
16:23:24 <sm> Saizan: thanks, that sounds good. I wonder why pandoc used https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/UTF8.hs
16:24:00 <sm> to support GHC 6.10 perhaps 
16:24:03 <kuffaar> Hmm what do I use when I want to map the elements of a Seq to strings?
16:24:04 <Saizan> yeah
16:24:04 <dcoutts_> sm: probably
16:24:11 <joe6> dafis: tfrm x = case cast x of { Just a -> (B.unpack a); Nothing -> []}
16:24:14 <kuffaar> Prelude.map works for lists only
16:24:22 <joe6> dafis: the above helped with the error.
16:24:28 <kuffaar> And Data.Sequence doesn't provide any map like that it seems
16:24:39 <kuffaar> Only to transform one sequence into another one
16:24:44 <kuffaar> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
16:24:49 <kuffaar> Urgh wrong one
16:24:49 <astroboy> Philonous: oh ok thanks
16:25:04 <kuffaar> I meant http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html
16:25:07 <Saizan> kuffaar: it's probably an instance of Functor, so fmap
16:25:08 <dafis> kuffaar: doesn't Seq have a toList?
16:25:19 <kuffaar> dafis yeah but isn't that expensive?
16:25:27 <dafis> dunno
16:25:35 <kuffaar> Yeah it's an instance of Functor
16:25:40 <joe6> dafis: did you say something. I briefly got disconnected.
16:25:45 <dafis> but you wouldn't do that often, would you?
16:26:03 <dafis> joe6: not recently
16:26:14 <Saizan> a lot of Seq's API comes through the classes it is an instance of
16:26:23 <Philonous> kuffaar: It's an instance of Foldable, so you can use toList if you want to make a Sequence of Chars into a String
16:26:23 <kuffaar> I should probably just use a fold for this
16:26:42 <Saizan> joe6: i was wondering why the unpack just to compare for equality, though maybe that was just an example?
16:26:46 <astroboy> Philonous: it can't compile, I think it's running from the wrong directory, how can I change that? (basically it's issuing ghci src/File.hs while it should execute it in src, so it can't find the modules in src)
16:27:10 <kuffaar> Although actually toList might be the easiest for this, heh
16:27:11 <Saizan> astroboy: :cd src at the ghci prompt
16:27:27 <Philonous> astroboy: Ah, the inferior haskell mode is pretty stupid. So in the ghci process you could say :cd src and :l File.hs
16:27:53 <Saizan> even C-c C-l should work after you :cd to the right dir
16:28:12 <astroboy> Philonous: Actually, it still doesn't work because I have a lot of flags in my .cabal file... is it possible to make it work with a cabal file :P?
16:28:35 <Philonous> Saizan: Unfortunately inferior haskell mode insist on changing it back to you cabal directory
16:29:07 <astroboy> Philonous: also, how can I close the ghci? C-c k does not work... sorry for the emacs noobness
16:29:13 <joe6> Saizan: it does not work without the unpack. I do not know what it is about ByteStrings
16:29:33 <Philonous> astroboy: C-x k
16:29:43 <joe6> dafis: chkbs x y = (tfrm x) == (tfrm y) ; tfrm x = case cast x of { Just a -> (B.unpack a); Nothing -> []}
16:29:45 <Philonous> Just kill the whole bloody buffer
16:29:59 <joe6> "ckbs v w" works but not "chkbs v v"
16:30:07 <joe6> dafis: does that make sense?
16:30:27 <astroboy> Philonous: yeah I just didn't know how to do that, new to emacs... so can I make it work with a .cabal file?
16:30:34 <dafis> joe6: not to me
16:31:20 <Philonous> astroboy: Doubtful, but I've never tried it. If it's a library, just install the thing?
16:31:48 <int80_h> how do I set the editor for the :edit command in winghci?
16:31:59 <dafis> joe6: try trfm x = case cast x of { Just a -> a; Nothing -> B.empty }
16:32:49 <astroboy> Philonous: the library is installed
16:33:10 <astroboy> in my .cabal folder
16:34:12 <dafis> joe6: or shorter, fromMaybe B.empty (cast x)
16:34:15 <Philonous> astroboy: Ah, well, but then you shouldn't need any cabal flags, should you? 
16:35:12 <astroboy> Philonous: no wait. I compile like 10 libs manually from the repos. I want to be able to get the type of the functions provided by those library. Now I am working on an app who has a .cabal file as well
16:35:21 <astroboy> and I was trying to compile a file of this application
16:36:12 <question-mark> is there any "null" in haskell? can i define a type "null" so i can put there anything later?
16:36:30 <astroboy> question-mark: in haskell functions are immutable
16:36:42 <astroboy> so there is no putting stuff in things later :P
16:36:46 <aavogt> undefined has any type
16:37:00 <question-mark> hm .. ok
16:37:06 <theorbtwo> Yes.  Almost everything is immutable in haskell.
16:37:06 <hpc> but you can't change it later
16:37:11 <hpc> it's always undefined
16:37:15 <theorbtwo> :t undefined
16:37:16 <lambdabot> forall a. a
16:37:22 <astroboy> if you are looking for a type that permits either no value or some value, go for Maybe
16:37:35 <hpc> data Maybe a = Nothing | Just a
16:37:49 <question-mark> thanks
16:37:54 <astroboy> but still, once you assign a value to a function, it's oooover eheh
16:38:04 <joe6> dafis: the B.empty is a good idea.
16:38:06 <joe6> Thanks.
16:38:20 <sm> that's odd. ghc just started complaining about having module Main in the top-level app.hs script
16:38:52 <hpc> module Main where?
16:39:14 <astroboy> sm: what do you mean "it complains"?
16:39:45 <question-mark> next question: can a tuple be "()" like a list can be "[]" ?  
16:39:47 <sm> it says "File name does not match module name:".. but only when a certain import is present
16:40:09 <sm> hmm
16:40:25 <astroboy> well I've always named my Main modules files Main.hs :P
16:40:30 <dafis> sm: what import?
16:40:43 <theorbtwo> question-mark: Why would you want it to be?  You type for a specific length of tupple.
16:41:00 <sm> https://gist.github.com/789043
16:41:16 * hackagebot pointfree 1.0.4.1 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.0.4.1 (BenMillwood)
16:41:39 <monochrom> question-mark: http://hpaste.org/paste/43174/perimeter_annotation#p43176
16:41:48 <hpc> question-mark: there is (), but it isn't a tuple
16:41:55 <question-mark> ok
16:41:58 <sm> it has been working fine until just now
16:41:59 <hpc> or rather, it is, if you count every other type as a unary tuple
16:42:13 <monochrom> in short, "distance x y + calc more" -> "distance x y + go more"
16:42:33 <astroboy> sm: just out of curiosity, does it work if you rename the file to Main.hs?
16:42:41 <Philonous> astroboy: I'm afraid I don't know how to make emacs/ghci observe your cabal file. But you could still import the library into a plain haskell file, load it in ghci and use it to inquire types. the inferior haskell mode doesn't care which buffer you are in when asking it to check for a type
16:42:55 <question-mark> ok thanks monochrom
16:43:19 <astroboy> Philonous: that's what I was thinking as well, but it's quite an ugly method. Uhm.
16:43:29 <Saizan> Philonous: afaict newer versions don't change the working directory anymore
16:43:54 <Philonous> Saizan: Ah, I shall update it then. Thanks
16:44:05 <sm> astroboy: it then says "Hledger/Cli/Stats.hs:15:7: Could not find module `Hledger'".. and in that file there is "import Hledger>Data.UTF8". Good one!
16:44:11 <joe6> dafis: can you please take a look at: http://codepad.org/ORm1ZUHw
16:44:20 <joe6> i am not getting the "t" function to compile.
16:44:35 <astroboy> Saizan: well I'm in the src directory and it still complains about not finding my modules. If I :cd and then :l into ghci it works. I mean it doesn't compile anyway, but it finds the modules
16:45:07 <sm> hmm, not quite out of the woods yet
16:45:18 <monochrom> I am old enough to need a function renamer to help me.
16:45:19 <joe6> the error http://codepad.org/sYkG7Crt
16:45:29 <joe6> dafis: ghci error http://codepad.org/sYkG7Crt
16:45:35 <astroboy> sm: could you rename the file to Main.hs and post the full ghc output?
16:48:04 <Saizan> ?type gzipWithQ
16:48:05 <lambdabot> forall r a a1. (Data a, Data a1) => GenericQ (GenericQ r) -> a -> a1 -> [r]
16:48:10 <sm> astroboy: sure, if you're willing, though it's morphing as we speak
16:48:17 <Philonous> astroboy: Btw. if your file doesn't type check ghci discards it altogether, i.e. the imports, too. So you have to have a version that compiles before you can have it print types from imported stuff
16:48:45 <sm> I fixed all my > typos, now getting https://gist.github.com/789059
16:48:54 <joe6> Saizan: thanks for trying to help me out. i seem to be missing something about the generics.
16:49:27 <sm> Hledger/Cli/Main.hs is below the current dir as always
16:49:46 <Saizan> joe6: they use fairly complicated parts of the type system
16:50:24 <astroboy> sm: ok assuming that that dir contains that library
16:50:33 <astroboy> why don't you just install it with cabal?
16:50:42 <astroboy> also, you don't need the -i .
16:51:06 <sm> astroboy: thanks, I think my regular build process is working again.. don't waste your time on it
16:51:35 <sm> I'm using make here for speed and auto-recompile
16:51:41 <Saizan> joe6: if you expand GenericQ, you see that gzipWithQ wants a function of type equivalent to (forall a b. (Data a, Data b) => a -> b -> r), so t's type doesn't match, because it requires a = b
16:51:46 <astroboy> Philonous: my app compiles correctly, I am running it now
16:52:21 <kuffaar> http://siyobik.info/pastebin_download.php?id=571 Main.hs:16:35:
16:52:21 <kuffaar>  parse error in constructor in data/newtype declaration: {algorithmFunction ...
16:52:27 <kuffaar> What am I doing wrong?
16:52:29 <astroboy> sm: make is always better eheh
16:52:58 <monochrom> you miss a data constructor.
16:53:03 <juhp> tried and failed to resubscribe to haskell mailing-lists last night...
16:53:29 <monochrom> valid data declaration is "data X = Ctor ..." you have "data X = ..."
16:54:08 <kuffaar> Oh, fail
16:54:33 <juhp> presumably anyone can join haskell list without approval?
16:55:00 <dafis> juhp: yes, you just have to subscribe
16:55:18 <monochrom> how do you know that you have failed to subscribe?
16:55:47 <astroboy> sm: anyway apart from that specific problem, cabal install hledger or get the repo and then cabal install inside it would be a much better choice
16:56:59 <sm> astroboy: not really.. I have a lot of funny development tasks to do
16:57:30 <astroboy> sm: if you are modifying the library just get the repo, do your modifications and install it
16:57:41 <kuffaar> DS.(><) is wrong
16:57:54 <dafis> kuffaar: in how far?
16:57:55 <kuffaar> What's the proper syntax? (DS.><) or something like that?
16:58:07 <dafis> kuffaar: yes
16:58:08 <kuffaar> DS is Data.Sequence in this case
16:58:09 <dibblego> !seen edwardk
16:58:10 <kuffaar> Ahh
16:58:32 <Saizan> joe6: this compiles here http://codepad.org/Cp0Gl7DP , i've also fixed other things
16:58:36 <dibblego> @seen edwardk
16:58:36 <preflex>  edwardk was last seen on #haskell 2 hours, 42 minutes and 59 seconds ago, saying: goh missed the other comment to that effect. gotta run
16:58:36 <lambdabot> Unknown command, try @list
16:58:38 <astroboy> sm: or just override what you need in your current directory
16:58:46 <dafis> kuffaar: but iirc, there's an extension to accept DS.(><)
16:59:25 <dafis> NewQualifiedOperators
16:59:34 <dafis> I think
16:59:40 <dibblego> category-extras will not install due to instance Monad (Either e) clash :(
17:00:38 <jmcarthur> i'm just glad that problem even exists now
17:01:30 <kuffaar> dafis cheers, that worked
17:01:54 <joe6> Saizan: Thanks a lot
17:03:19 <joe6> Saizan: that is pretty good. Thanks a lot
17:03:56 <Saizan> *Main> t ([] :: [Int]) (Nothing :: Maybe Bool)
17:03:56 <Saizan> True
17:04:07 <Saizan> funny thing about this version of t :)
17:04:19 <Saizan> joe6: np
17:05:37 <juhp> rather it seems one can subscribe to haskell.org lists with community a/c
17:05:40 <juhp> cannot!
17:07:30 <monochrom> interesting. perhaps to forbid recursion and turing-completeness of email
17:07:56 <revenantphx> Haskell WOULD have a turing complete mailing list.
17:07:59 <monochrom> yeah, wouldn't it be nice if the global email system were turing-complete
17:08:30 <revenantphx> >_>
17:30:02 <joe6> Saizan: can you please take a look at the s function that I added 
17:30:16 <joe6> Saizan: it has similar functionality to what you added.
17:30:30 <joe6> Saizan: just wanted to check your thoughts on what I added.
17:31:37 <Saizan> joe6: link-?
17:33:54 <joe6> Saizan: http://codepad.org/A4U43xgP
17:33:59 <joe6> Saizan: sorry about that.
17:34:20 <joe6> i used extQ 
17:36:12 <Saizan> joe6: maybe you want Data.ByteString.Char8.unpack instead of show . B.unpack ?
17:36:38 <joe6> Saizan: that is for a different datatype
17:36:51 <joe6> one for bytestring and another for just String.
17:37:09 <joe6> and I notice that toConstr for String just gives (:)
17:37:25 <joe6> whereas extQ seems to give out the string value
17:37:54 <Saizan> i meant use bs = Data.ByteString.Char8.unpack
17:38:09 <Saizan> anyhow, it's not so clear what you're trying to do here
17:38:17 <joe6> Saizan: that's ok.
17:38:20 <kuffaar> Sometimes I have a hard time pinning down type inference problems when I'm compiling my Haskell code. Is there some way to figure out the type of every single function/name somehow while compiling?
17:38:28 <joe6> saizan: Thanks for your help.
17:39:04 <kuffaar> Because I totally don't get why some name is the wrong type and it traces back through 3-5 functions until the problem is located
17:39:14 <kuffaar> And it can be very difficult to figure out where it went wrong
17:39:23 <kuffaar> When a lot of types are infered
17:39:32 <Saizan> you can try adding some type signatures
17:39:55 <kuffaar> Right :/
17:45:50 <heatsink> > [[[]]>[]||[]<[[]]|[[]]>[]||[]<[[]]]
17:45:51 <lambdabot>   [True]
17:46:04 <dolio> Of course!
17:47:22 <roconnor> heatsink: ah, list comprehension
17:48:25 <dolio> > [True | True]
17:48:26 <lambdabot>   [True]
17:48:42 <heatsink> I was a bit surprised that list comprehensions don't need <- 
17:49:06 <dolio> The base case.
17:49:30 <FauxFaux> > True|True
17:49:31 <lambdabot>   <no location info>: parse error on input `|'
17:49:33 <roconnor> > do { guard True ; return True }
17:49:33 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
17:49:34 <lambdabot>    arising from a use of ...
17:49:45 <dolio> [ x | True ] = [x], [ x | False ] = []
17:51:17 <ski> > [ () | ]
17:51:19 <lambdabot>   <no location info>: parse error on input `]'
17:51:39 <ski> (that ought to result in `[()]' ..)
17:52:24 <kuffaar>     Warning: -XNewQualifiedOperators is deprecated: The new qualified operator syntax was rejected by Haskell'
17:53:31 <ski> kuffaar : `(Foo.+)' or what ?
17:53:43 <kuffaar> ski: I wanted to use DS.><
17:53:51 <kuffaar> And it doesn't work without NewQualifiedOperators
17:53:55 <ski> infix or not ?
17:54:02 <kuffaar> No infix
17:54:13 <ski> tried `(DS.><)' ?
17:54:24 <kuffaar> Sorry
17:54:31 <kuffaar> I meant DS.(><)
17:54:38 <kuffaar> I thought that was the more modern syntax
17:54:43 <kuffaar> But apparently it's deprecated now?
17:54:49 <ski> yeah ..
17:54:54 <Saizan> it was proposed and rejected
17:55:00 <ski> i always preferred `(DS.><)', anyway
17:55:05 <kuffaar> I see
18:23:30 <int80_h> http://hpaste.org/43179/troubles_with_windows_network
18:23:36 <int80_h> hey-ooo
18:26:23 <Cale> int80_h: your port numbers don't match
18:28:33 <int80_h> Cale: Thanks for catching that. That came from me tinkering with the code. I have changed things back to the way they were. Problem still stands.
18:34:35 <int80_h> Cale: any ideas?
18:35:20 <fryguybob> int80_h: It failed for me, but I have a change that makes it work.
18:36:01 <int80_h> fryguybob: I'd like to see the change, and talk about what needed to be changed and why
18:37:50 <fryguybob> http://hpaste.org/paste/43179/troubles_with_windows_network#p43181
18:40:30 <int80_h> withSocketsDo? Hmm, serves me right for listening to the internets. It tols me that wasn't needed to windows 7
18:40:47 <int80_h> s/to/for
18:41:32 <fryguybob> int80_h: That was in the previous code and is required on windows.  It seems (on windows at least) that listenOn must happen before connectTo.
18:41:51 <int80_h> heh
18:45:35 <int80_h> fryguybob thanks. It works for me now as well. Off I go!
18:48:12 <brweber2> does anyone use haskellmode-vim?
18:51:19 <dibblego> TIL http://twitter.com/#!/dafyddrees/status/28273296751468545
18:51:24 <question-mark> anyone nows about somthing called "divide and conquer" -scheme ?
18:51:44 <question-mark> and can explain this to me :)
18:57:49 <Mathnerd314> is http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable out of date? It's past Jan 2, and I can't find an RC...
18:58:10 <zzing> I just downloaded a 64 bit mac version of ghc 7 and I notice it doesn't have any pkg file, and seems to install to /usr/local. Is there any way to get a pkg installer for this?
19:21:32 * hackagebot data-inttrie 0.0.4 - A lazy, infinite trie of integers.  http://hackage.haskell.org/package/data-inttrie-0.0.4 (LukePalmer)
19:24:33 * hackagebot data-memocombinators 0.4.1 - Combinators for building memo tables.  http://hackage.haskell.org/package/data-memocombinators-0.4.1 (LukePalmer)
19:28:22 <monochrom> question-mark: To sum up a group of 10 numbers, I split them into two groups of 5 numbers, sum each group, then I just have two numbers to add, and I know how to do that with x+y. (To sum up a group of 5 numbers, split again...)
19:29:51 <monochrom> Sometimes I prefer to split the 10 numbers into one group of 9 number and one group of 1 number, then sum the first group, (the second group doesn't need further work), then I can do x+y again to end.
19:31:05 <gwern> @hoogle '[Int] -> Int'
19:31:06 <lambdabot> Parse error:
19:31:06 <lambdabot>   --count=20 "'[Int] -> Int'"
19:31:06 <lambdabot>              ^
19:31:10 <gwern> @hoogle [Int] -> Int
19:31:11 <lambdabot> Prelude maximum :: Ord a => [a] -> a
19:31:11 <lambdabot> Prelude minimum :: Ord a => [a] -> a
19:31:11 <lambdabot> Data.List maximum :: Ord a => [a] -> a
19:32:27 <joe6> > case (typeOf 1) of { (typeOf 1) -> "1" ; _ -> "string"}
19:32:28 <lambdabot>   <no location info>: Parse error in pattern
19:32:43 <joe6> so case matches cannot have patterns?
19:32:47 <monochrom> To find your phone number in the phone directory, if I have your name: I tear the directory into two halves, find you in the first half, find you in the second half. Fortunately, it is harmless to ignore one of them. To know which one to ignore, I compare your name to the tear boundary.
19:32:48 <joe6> i mean functions?
19:33:06 <Axman6> yes
19:33:32 <Axman6> though, there is an extension that might work
19:33:38 <Axman6> i always forget its name
19:33:50 <Axman6> view patterns i think
19:34:29 <Axman6> > let foo (show -> "1") = True; foo _ = False in foo 1
19:34:30 <lambdabot>   True
19:34:32 <Axman6> > let foo (show -> "1") = True; foo _ = False in foo 2
19:34:33 <monochrom> To make a baby, marry one person to make half a baby, marry another person to make half a baby, then sew them together. This also cuts down time to 4.5 months.
19:34:34 <lambdabot>   False
19:34:39 <Axman6> :t let foo (show -> "1") = True; foo _ = False in foo 
19:34:40 <lambdabot>     Illegal view pattern:  (show -> "1")
19:34:40 <lambdabot>     Use -XViewPatterns to enable view patterns
19:34:44 <Axman6> heh
19:37:02 * shachaf wishes view pattern syntax was nicer.
19:37:38 <Axman6> what's wrong with it?
19:37:41 <joe6> what is the alternative? multiple if statements?
19:38:06 <Axman6> you can use guards
19:38:43 <monochrom> foo x | show x -> "1" = ...   like this?
19:39:11 <Axman6> eh?
19:39:17 <thescouser_89> eh?
19:39:20 * monochrom introduces view pattern guard, pattern view guard, and pattern guard view
19:39:53 <monochrom> eh? be? see? dee?
19:40:08 <Axman6> IEEEEEEEEEEEEEEEEEEEEEEE
19:40:25 <monochrom> haskell is easy as eh
19:40:32 <thescouser_89> 754
19:42:44 <monochrom> chmod 754 ieee
19:48:56 <centrinia> > let f x ys = (x ++ ) . concat $ intersperse ", " $ map (concat . intersperse " ") $ permutations ys
19:48:57 <lambdabot>   not an expression: `let f x ys = (x ++ ) . concat $ intersperse ", " $ map ...
19:49:04 <centrinia> > f x ys = (x ++ ) . concat $ intersperse ", " $ map (concat . intersperse " ") $ permutations ys
19:49:05 <lambdabot>   <no location info>: parse error on input `='
20:00:04 <joe6> > maybe
20:00:05 <lambdabot>   Overlapping instances for GHC.Show.Show
20:00:05 <lambdabot>                              (b -> ...
20:00:12 <joe6> what does maybe do?
20:00:16 <ivanm> @type maybe
20:00:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:00:27 <ivanm> > maybe 0 (*2) $ Just 3
20:00:28 <lambdabot>   6
20:00:30 <ivanm> > maybe 0 (*2) $ Nothing
20:00:31 <lambdabot>   0
20:00:46 <Axman6> :t either
20:00:47 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:01:40 <joe6> oh, gotcha. Thanks guys.
20:10:04 <dibblego> what are some typical type-classes that work on type constructors :: (* -> *) -> * ?
20:19:39 <keep_learning> http://hpaste.org/43184/montgomery_elliptic
20:19:45 <keep_learning> could some one please tell me 
20:20:08 <keep_learning> why montLadder function is giving me error 
20:20:16 <keep_learning> http://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
20:20:39 <keep_learning> i am trying to implement montgomery  ladder function given on wiki
20:22:25 <tg_> http://blogs.plos.org/badphysics/2011/01/20/ono/
20:22:33 <tg_> that story may be of interest to #haskell
20:23:59 <joe6> > ext2Q
20:23:59 <lambdabot>   Not in scope: `ext2Q'
20:25:27 <joe6> > :t ext2Q
20:25:27 <lambdabot>   <no location info>: parse error on input `:'
20:28:38 <keep_learning> no one
20:28:48 <keep_learning> its just type error
20:30:21 <BMeph> Traversible?
20:30:44 <dibblego> Traversable
20:31:24 <robertmassaioli> In the Haskeline module can I ask for input and put something in the input spot by default?
20:31:48 * hackagebot web-mongrel2 0.0.2 - Bindings for the Mongrel2 web server.  http://hackage.haskell.org/package/web-mongrel2-0.0.2 (ClintMoore)
20:34:55 <keep_learning> http://hpaste.org/43185/montgomery_elliptic_annotatio?pid=43185&lang_43185=Haskell
20:35:00 <keep_learning> changed bit 
20:35:07 <keep_learning> but stil the same error
20:36:04 <keep_learning> montMul::Integer->Elliptic->Point->Integer->Point montMul _ _ _ 0 = Conp 0 0 montMul _ _ pOint 1 = pOint montMul _ eCurve pOint 2 = doublePoint pOint eCurve montMul n eCurve pOint k = montLadder (Conp 0 0) pOint k 			    where  			       montLadder r0 r1 0= r0 			       montLadder r0 r1 1= r1 			       montLadder r0 r1 2 = doublePoint r1 eCurve 			       montLadder r0 r1 r |odd r = montLadder (doublePoint r0 eCurve) (addPoints 
20:36:16 <Axman6> please don't paste code that large in here
20:37:28 <keep_learning> Axman6: kindly have a look at my code 
20:37:34 <keep_learning> in given link 
20:37:38 <keep_learning> its type error 
20:37:42 <deech`> Hi all, how do I go about getting write access the Haskell Wiki?
20:37:50 <keep_learning> and i am not able to debug it
20:38:14 <Axman6> keep_learning: we'd need to see the type error as well...
20:38:51 <keep_learning> Axman6: Expected type: Point -> (Integer -> Point) -> t -> Point       Inferred type: Point -> Point -> t -> Point 
20:39:15 <keep_learning> Axman6: In the expression:         montLadder           (doublePoint r0 eCurve) (addPoints r0 r1 pOint) (div r 2) 
20:39:26 <Axman6> paste it on hpaste, not here >_<
20:39:36 <joe6> what is a binary type constructor?
20:39:48 <dibblego> one that takes two arguments
20:40:05 <joe6> ok, thanks.
20:40:08 <Axman6> like Map
20:40:18 <BMeph> Or State
20:40:20 <keep_learning> Axman6: http://hpaste.org/43185/montgomery_elliptic_annotatio?pid=43185&lang_43185=Haskell
20:41:20 <drhodes> Anyone know if there's been an attempt to build a system that can discover a grammar given a large collection of code samples?
20:41:50 * hackagebot web-mongrel2 0.0.2.1 - Bindings for the Mongrel2 web server.  http://hackage.haskell.org/package/web-mongrel2-0.0.2.1 (ClintMoore)
20:41:54 <Axman6> keep_learning: i don't see the error there
20:41:59 <hydo> ;)
20:42:06 <BMeph> drhodes. Yes. Next question? ;)
20:42:11 <Axman6> keep_learning: if tyou weant help with errors, you need to paste the code and the error together
20:42:26 <Rotaerk_> hmm what would you call a function of this signature:  a -> (a -> b) -> (a, b)
20:42:34 <drhodes> BMeph: does it work? and is it free?
20:42:44 <Rotaerk_> it transforms a, but it couples the result with a
20:42:45 <keep_learning> Axman6: k
20:44:17 <BMeph> keep_learning: Your program has: "addPoints::Point->Point->Point->Integer->Point", but you never give it an Integer when you use it. That's why the compiler says it's expecting "Integer->Point". :)
20:44:19 <hydo> What's the usual time for the docs to get generated on a newly uploaded package?
20:44:46 <keep_learning> BMeph: ohhhhhh
20:44:54 <keep_learning> BMeph: thank you
20:45:01 <hydo> I love ghc... when it croaks, it tells you why.  Pretty clearly, even.
20:45:04 <dibblego> Rotaerk_, stateEval
20:45:13 <djahandarie> hydo, I think it's midnight
20:45:16 <BMeph> Rotaerk_: I would call it "fred". ;þ
20:45:24 <robertmassaioli> Bump: In the Haskeline module can I ask for input and put something in the input spot by default?
20:45:27 <hydo> djahandarie: ah, cool.  Thanks!
20:45:36 <dibblego> @hoogle (s -> a) -> State s a
20:45:36 <lambdabot> Control.Arrow arr :: Arrow a => (b -> c) -> a b c
20:45:36 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
20:45:36 <lambdabot> Control.Monad.State.Strict withState :: (s -> s) -> State s a -> State s a
20:45:38 <Rotaerk_> BMeph, okay! I'll go with that!
20:45:39 <Rotaerk_> *cough*
20:47:02 <Rotaerk_> dibblego, that doesn't really match my signature
20:47:19 <dibblego> Rotaerk_, does too
20:51:57 <dibblego> @type \k -> first k . join (,)
20:51:57 <lambdabot> forall c d. (d -> c) -> d -> (c, d)
20:54:59 <zzing> On Mac, I had a copy of ghc7 installed under /usr/local that I removed after installing the 32 bit pkg for same. Right now it seems some tools are still trying load from that location: /usr/local/bin/hsc2hs: line 30: /usr/local/lib/ghc-7.0.1/hsc2hs: No such file or directory   Any ideas to fix this?
20:55:55 <djahandarie> @type (&&& id)
20:55:56 <lambdabot> forall b c. (b -> c) -> b -> (c, b)
20:56:01 <djahandarie> :-)
20:56:41 <dibblego> indeed
20:56:52 <djahandarie> Oh wait, it was the other way around originally
20:57:01 <Axman6> Hey horms 
20:57:30 <djahandarie> @type (id &&&)
20:57:31 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
20:57:37 <Axman6> kuffaar: you asked about some C++ stuff earlier... i know next to no C++ :)
20:57:49 <Axman6> i'm considering learning though
20:57:51 <kuffaar> Oh? Really? I thought you were defending C++ the other day
20:58:01 <kuffaar> Maybe I mixed you up with somebody else in here
20:58:09 <Axman6> aye
20:59:50 <Rotaerk_> think I'll go with "relationOf"
21:00:00 <Rotaerk_> relationOf 5 ((+) 1) -> (5, 6)
21:00:14 <djahandarie> Rotaerk_, should the name really be longer than its definition? :)
21:00:23 <Rotaerk_> sure
21:00:39 <Axman6> djahandarie: that's just a side effect of haskell being so concise
21:00:45 <Rotaerk_> readability isn't all about character-count brevity
21:01:01 <ddarius> dibblego: That twitter response was pretty good, except it reduces at least one problem: motivation.
21:01:27 <dibblego> ddarius, you think it was good?
21:03:07 <djahandarie> Rotaerk_, (id &&&) is in fact more abstract than just for just functions (works on any Arrow... useful). If you name it relationOf you should probably constrain its type signature too
21:03:11 <zzing> Would it be true to say that cabal-install 0.8.2 cannot use Cabal 1.10
21:03:47 <Axman6> kuffaar: i don;t know enough about C++ to defend it.
21:03:49 <Rotaerk_> djahandarie, what do you mean? why restrict it?
21:03:52 <Rotaerk_> and to what
21:04:08 <djahandarie> Oh whoops, not paying attention
21:04:14 <Axman6> kuffaar: I was watching some LLVM dev meeting videos last night though, and they've made me want ot look at C++ more
21:04:15 <djahandarie> Sticking in a -> a constraints it already :P
21:04:17 <ddarius> dibblego: I think it is an entertaining response with a hint of truth.
21:04:55 <djahandarie> Is there a more general id?
21:05:05 <dibblego> djahandarie, Control.Category
21:05:20 <kuffaar> Axman6 heh
21:05:32 <dibblego> ddarius, I'm glad my lament was your entertainment
21:05:40 <djahandarie> Oh right
21:05:44 <ddarius> dibblego: I have no idea what the context is.
21:06:15 <dibblego> ddarius, P: "statically-enforced effect-tracking is useful" Q: "Not if you do TDD."
21:06:38 <djahandarie> @type ((arr id) &&&)
21:06:40 <lambdabot> forall b (a :: * -> * -> *) c'. (Arrow a) => a b c' -> a b (b, c')
21:07:00 <djahandarie> ddarius, oh, did you go to Boston Haskell?
21:07:45 <djahandarie> Thought-driven deletion? :)
21:07:51 <ddarius> djahandarie: Yes.
21:08:02 <djahandarie> Good times? How was Spivak's talk
21:08:16 <ddarius> djahandarie: -Way- better than the Galois one.
21:08:26 <djahandarie> Damnit :(
21:08:42 <djahandarie> Did edwardk have a camera set up?
21:08:48 <ddarius> Yes.
21:08:52 <djahandarie> Woot
21:09:53 * djahandarie goes to bed
21:15:38 <zzing> How does cabal choose between something multiple dependency options with the 'or', for example, for cabal-install there are multiple options one has base >= 3  & <5 and another has base >= 2 & <2.0 and it is picking the wrong one to tell me about.
21:17:45 <joe6> sb :: String -> String; (cast sb)  :: Maybe (String -> String)
21:17:58 <joe6> i am trying to do something like the above. is that possible?
21:18:11 <Axman6> that's fmap
21:18:15 <Axman6> :t fmap
21:18:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:18:39 <Axman6> :t fmap ("hello"++)
21:18:40 <lambdabot> forall (f :: * -> *). (Functor f) => f [Char] -> f [Char]
21:18:45 <Axman6> :t fmap ("hello"++) Nothing
21:18:46 <lambdabot> Maybe [Char]
21:19:03 <Axman6> :t fmap ("hello"++) (Just "hello")
21:19:05 <lambdabot> Maybe [Char]
21:19:12 <Axman6> > fmap ("hello"++) (Just "hello")
21:19:12 <joe6> Axman6: i am trying to learn the behaviour of cast.
21:19:13 <lambdabot>   Just "hellohello"
21:19:25 <Axman6> where'd you get cast form?
21:19:28 <Axman6> from*
21:19:37 <joe6> i found the above definition used as part of extT in peytonjones slides on generics
21:19:46 <joe6> it is Data.Generics
21:19:51 <Axman6> righto
21:20:39 <joe6> extT gen spec x = case (cast spec) of { Just spec' -> spec' x ; Nothing -> gen x}
21:20:52 <ivanm> zzing: which package is that?
21:20:57 <ivanm> Cabal normally gets them right...
21:21:42 <joe6> it does not seem to work, though.
21:22:29 <zzing> ivanm: cabal-install
21:22:40 <zzing> I am trying to build it on ghc 7 without much success
21:22:46 <ivanm> zzing: it won't
21:22:49 <ivanm> so don't bother
21:23:00 <zzing> :-(
21:23:12 <ivanm> latest version of cabal-install is 0.8.2, which uses Cabal-1.8
21:23:22 <ivanm> however, ghc-7 ships with Cabal-1.10
21:23:28 <zzing> yes I noticed that
21:23:31 <ivanm> as such, there's no released version of cabal-install for it
21:24:04 <zzing> I guess I will just have to reinstall the regular platform release. I think I kept it on my harddrive upstairs...
21:24:57 <ivanm> zzing: which OS?
21:25:12 <zzing> mac
21:25:36 <ivanm> if you still have cabal-instal hanging around, then it should still work with ghc-7
21:25:52 <zzing> I bumped it all off
21:26:00 <ivanm> or else try getting the darcs version of cabal-isntall
21:26:02 <zzing> The package database was a little rotten
21:30:00 <zzing> Is it just me or is darcs slower to download something than git?
21:30:13 <ivanm> they work differently
21:30:23 <ivanm> using --lazy is usually quite fast
21:30:41 <ivanm> (as it doesn't download the entire history)
21:30:48 <zzing> It is about 50% done now
21:30:53 <ivanm> I believe the darcs team is working on making darcs get faster
21:30:58 <ivanm> zzing: with --lazy?
21:31:09 <zzing> ivanm: no, it was already 50% through so no point to stop it
21:31:21 <ivanm> oh, right
21:31:29 <zzing> Apparently the thing talks about the repository on the other end not being hashed
21:31:38 <ivanm> zzing: you're downloading the entire history; does git do that?
21:31:41 <ivanm> oh, and there's that
21:31:46 <ivanm> @slap c.h.o for using darcs-1
21:31:47 * lambdabot karate-chops c.h.o for using darcs-1 into two equally sized halves
21:32:31 <zzing> ivanm: I don't know what git does tbh, and it doesn't really matter. As the user I only care it downloads it as reasonably fast as it can.
21:32:53 <zzing> But it is done now
21:32:53 <ivanm> @ask edwardk why switch to MPTCs + FunDeps? :o
21:32:54 <lambdabot> Consider it noted.
21:33:24 <ivanm> zzing: the fault here is outdated repo formats
21:33:58 <zzing> Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
21:34:11 <zzing> It is talking about two different versions of bytestring
21:34:16 <zzing> 0.9.1.8 and 0.9.1.9
21:34:41 <zzing> I also have both installed apparently
21:36:13 <zzing> I am not sure how the older version was installed
21:39:33 <ivanm> zzing: ummm... if you have both versions installed, you have problems...
21:39:35 <zzing> ivanm: Thank you I now have a cabal binary :-0
21:39:38 <ivanm> did you do "cabal upgrade" at all?
21:40:17 <zzing> ivanm: I recall installing the newer bytestring manually, I just deregistered it without problems and the cabal compiled.
21:40:23 <ivanm> don't
21:40:41 <ivanm> out of all the libraries that come with ghc, Cabal is the only upgradeable one
21:40:45 <Axman6> i don't suppose anyone knows some nice, commonly used database relationship/schema diagramming software?
21:40:53 <ivanm> Axman6: dia? :/
21:41:02 <ivanm> zzing: you should not upgrade bytestring, filepath, containers, etc.
21:42:08 <zzing> Now if I have a package X that another package Y depends on, and I upgrade package X won't that likely break Y?
21:42:54 <ivanm> yes
21:42:59 <ivanm> so you need to rebuild Y
21:43:08 <zzing> I must be careful :-)
21:43:17 <ivanm> note: this is not true if Y is an executable built the default way (i.e. statically)
21:43:25 <zzing> ok
21:43:27 <ivanm> "ghc-pkg check" will tell you what's broken
21:44:08 <zzing> This is the output: https://gist.github.com/e3fa5daa78075f83b458
21:45:34 <ivanm> ummmm.... something is really broken :/
21:46:21 <mtnviewmark> why would it break Y? If you upgrade X with cabal, you will have *both* versions of X installed
21:46:30 <mtnviewmark> Y won't break, it'll just keep using the old X
21:46:35 <zzing> I wonder if this might be the result of me trying to manually install some of the dependencies for cabal 1.8 with ghc 7 before.
21:46:44 <mtnviewmark> BUT - if you now need to include both X and Y in the same project.... well, 
21:46:47 <Axman6> mtnviewmark: there's been a lot of talk about this lately
21:47:06 <mtnviewmark> indeed - but it isn't like the situation has changed in the last year or so....
21:47:14 <zzing> ivanm: Should I try removing ghc again and try this beast again?
21:47:36 <ivanm> possibly
21:47:38 <Axman6> mtnviewmark: i mean a lot of talk in the last two weeks or so
21:47:47 <ivanm> zzing: any particular reason you aren't using the platform?
21:47:57 <mtnviewmark> it looks like your pkg database is corrupted.... or you deleted the .o files for the base libs
21:48:10 <ivanm> mtnviewmark: well, I usually don't use cabal-install, so I forget it installs multiple copies *shrug*
21:48:26 <mtnviewmark> zzing - are  you on Mac OS X?
21:48:27 <zzing> ivanm: I had issues earlier today with my old package db and decided to try something new :-)
21:48:31 <zzing> mtnviewmark: si
21:48:47 <ivanm> zzing: your global or local one?
21:48:50 <mtnviewmark> so - we should first find out what the issue is before deciding how to fix it
21:49:00 <zzing> ivanm: That wasn't clear
21:49:18 <zzing> It is water under the bridge now though...
21:49:22 <zzing> The old one is gone
21:49:29 <ivanm> it should say so when stuff is broken
21:49:32 <mtnviewmark> zzing - ghc-pkg list | grep -v '^ '
21:49:43 <mtnviewmark> that will show you where your pkg databases are
21:49:54 <joe6> > :t fromJust
21:49:54 <lambdabot>   <no location info>: parse error on input `:'
21:49:58 <zzing> yes
21:50:04 <joe6> > fromJust
21:50:05 <lambdabot>   Overlapping instances for GHC.Show.Show (Data.Maybe.Maybe a -> a)
21:50:05 <lambdabot>    arisin...
21:50:08 <zzing> Want to see it?
21:50:33 <zzing> https://gist.github.com/7a7867c1455a4a615519
21:50:47 <ivanm> @type fromJust
21:50:48 <lambdabot> forall a. Maybe a -> a
21:50:51 <ivanm> joe6: ^^
21:50:52 <Axman6> joe6: you don't use > with :t
21:51:03 <mtnviewmark> okay - that looks good
21:51:06 <zzing> mtnviewmark: How about I reinstall ghc 7 and see if I still have this issue on the plain install?
21:51:13 <mtnviewmark> now do:  ghc-pkg describe containers
21:51:25 <mtnviewmark> well - sure, you could
21:51:36 <zzing> https://gist.github.com/ea4ebddacae0f4beb55e
21:52:38 <mtnviewmark> finally:  ls /Library/Frameworks/GHC.framework/Versions/7.0.1-i386/usr/lib/ghc-7.0.1/containers-0.4.0.0
21:53:16 <zzing>  https://gist.github.com/60c7511eac079fffab43
21:53:49 <mtnviewmark> that's disturbing -- where'd the .o files go?
21:54:04 <zzing> mtnviewmark: good question
21:54:13 <zzing> I haven't touched them manually
21:54:34 <zzing> I will reinstall and see if I have this problem if you think it is best
21:54:59 <mtnviewmark> no - wait
21:55:02 <zzing> ok
21:55:10 <mtnviewmark> I just looked at my pristine install of 7.0.1
21:55:14 <mtnviewmark> they aren't there either!
21:55:17 <joe6> @hoogle fromJust
21:55:17 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
21:55:18 <zzing> haha
21:55:22 <joe6> ivanm: thanks
21:55:28 <joe6> Axman6: thanks
21:55:29 <mtnviewmark> WTF
21:55:30 <zzing> mtnviewmark: So does this mean the official pkg is broken?
21:55:36 <believa> Are the current Yesod devel- and simple-servers multi-threaded?
21:55:37 <mtnviewmark> well..... 
21:55:47 <mtnviewmark> perhaps.....
21:55:59 <mtnviewmark> perhaps not
21:56:00 <zzing> Will this actually break ghci if I try to use one?
21:56:02 <mtnviewmark> the .a files are there
21:56:10 <mtnviewmark> and really, that is all one should need when building 
21:56:17 <mtnviewmark> so... where does the problem hit?
21:56:23 <mtnviewmark> when using GHCI?
21:57:13 <zzing> I import Data.Set and Graph fine
21:57:21 <zzing> I don't know about using them though
21:58:19 * zzing goes to sink teeth into a blood orange
21:58:30 <mtnviewmark> try it!     :m + Data.Map      let a = fromList [("ans", 42)]
21:59:04 <mtnviewmark> It is quite possible that in 7.0.1, those objects are statically linked into ghci so that it no longer needs to dynamically load 'em
21:59:08 <zzing> works fine
21:59:21 <zzing> guten 
21:59:22 <mtnviewmark> okay - so ignore those ghc-pkg check warnings!
21:59:42 <zzing> I am curious - is the new -platform nearing ready?
22:00:16 <mtnviewmark> well...... I'm awaitin' news from the HP team --- waiting for them to tell me "go forth and build offical installers"
22:00:29 <mtnviewmark> but - I've heard nothing.... (dons are you listening?)
22:00:46 <joe6> i am having a really hard time with the types and coming up with function composition.
22:00:54 <joe6> is there something that can help me?
22:01:07 <mtnviewmark> mint tea
22:01:15 <joe6> i keep trying the different combinations for so long.
22:01:36 <mtnviewmark> yeah - so there's this phase every new Haskeller goes through where you just can't seem 
22:01:39 <joe6> for something like this: I bet I cannot figure it .. (\x -> (cast x) :: Maybe B.ByteString)
22:01:51 <mtnviewmark> to figure out where you need . vs $ vs parenthesis etc...
22:01:59 <joe6> without checking some other code that uses this..
22:02:58 <mtnviewmark> ? why is that any different than      cast :: (a -> Maybe B.ByteString)     ?
22:03:26 <zzing> Now the reason why I wanted to use haskell again... I am making something that is essentially a particle simulator. Starting with a single particle that has a velocity vector and bounces off the walls of the container and then adding a few more and then hopefully implementing some kind of elastic collision. I am wondering what the best approach might be.
22:03:32 <mtnviewmark> or rather - where are you running into difficulty?
22:04:08 <joe6> i do not understand the type definitions
22:04:34 <joe6> i think that is the reason and I keep trying different combinations to cover up for that deficiency.
22:04:38 <mtnviewmark> okay - (let me know if I'm starting too elementary)
22:05:13 <mtnviewmark> So - first off, joe6, are you in the habit of writing type signatures for every top level function you write?
22:05:55 <joe6> yes, I do.
22:05:58 <mtnviewmark> good
22:06:15 <mtnviewmark> so, here, is there a type signature in front of you that you don't get?
22:06:23 <joe6> except, that I get lost  (Typeable a, Typeable b) => a -> b -> String 
22:06:36 <mtnviewmark> good - let's break that down
22:06:37 <mm_freak_> joe6: the most idiomatic way to express physics simulations is to use FRP, in which case you don't have a changing velocity vector anymore
22:06:51 <mtnviewmark> first let's look at the part after the =>
22:06:57 <mtnviewmark> so     a -> b -> String
22:07:03 <mm_freak_> i admit that FRP is not easy to get into, but once you're into it it's a great paradigm
22:07:04 <joe6> for example: this function that I wrote does not compile: bs2s x y = (show . B.unpack $ x) ++ (show . B.unpack $ y)
22:07:24 <mtnviewmark> first tell me it's signature!
22:07:34 <zzing> mm_freak_: I was actually thinking about FRP
22:07:39 <mtnviewmark> ah
22:07:46 <joe6> i am hoping that it is B.ByteString -> B.ByteString -> String
22:07:49 <zzing> mm_freak_: However, I am not sure where to start with it :-)
22:07:55 <mm_freak_> oh, zzing, yes i meant you of course =)
22:07:57 <mm_freak_> joe6: sorry
22:08:24 <mm_freak_> zzing: i started with yampa, then moved to elerea
22:08:25 <zzing> I saw a PID loop done with FRP once, but I never quite understood it (and I do understand PID)
22:08:25 <mtnviewmark> that's what it looks like to me... though I'm not sure why the show calls are there --- did you want extra quotes around your strings?
22:08:46 <zzing> mm_freak_: Are you advocating I look at yampa first?
22:08:53 <joe6> B.unpack gives out [Word8] and I am using show to convert to String
22:09:36 <mm_freak_> zzing: at least yampa gives a very simple notion of signal transformation, once you're comfortable with arrows
22:09:40 <mtnviewmark> ah - *that* B.ByteString
22:09:50 <mm_freak_> zzing: elerea is less straightforward, but it appeared to be faster
22:09:59 <joe6> import qualified Data.ByteString as B
22:10:03 <mtnviewmark> but is that the conversion you were after
22:10:08 <mm_freak_> while yampa takes the arrow approach, elerea takes the monadic approach
22:10:40 <zzing> What does this mean? "Elerea (Eventless reactivity) is a tiny discrete time FRP implementation without the notion of event-based switching and sampling, with first-class signals (time-varying values). Reactivity is provided through various higher-order constructs that also allow the user to work with arbitrary time-varying structures containing live signals."
22:10:45 <mm_freak_> in elerea you deal with time-dependent signals, in yampa you deal with signal transformers
22:11:15 <mtnviewmark> so, your function *has* the type you expect
22:11:23 <mtnviewmark> but... I'm guessing that it doesn't do what you want?
22:11:57 <mtnviewmark> > show ([65,66,67]::[Word8])
22:11:58 <lambdabot>   "[65,66,67]"
22:12:10 <mtnviewmark> and, I bet you were after "ABC"
22:12:16 <mm_freak_> zzing: since i don't know the other FRP libraries i can't really tell what "event-based switching and sampling" is…  i can only tell that elerea is monadic and works with time-varying values directly
22:12:57 <mtnviewmark> but, joe6: perhaps we should get back to the type    (Typable a, Typeable b) => a -> b -> String     --
22:13:05 <joe6> mtnviewmark: can you please take a look at http://codepad.org/LsI636jh
22:13:14 <mtnviewmark> looking
22:13:25 <joe6> at the end are the compile errors that I receive when I try to compile them.
22:13:32 <joe6> and I have no clue what they mean
22:13:51 <zzing> mm_freak_: Well my stuff would be time based I believe
22:14:17 <mm_freak_> zzing: in yampa you deal with signal transformers…  that gives you some very elegant ways to express things…  for example you can say "x' <- integral -< x"
22:14:21 <joe6> mtnviewmark: I can do the simple stuff but with the compile errors i just get lost
22:14:30 <zzing> I should really look again at my haskell editor 'Hcode' :-)
22:14:40 <joe6> mtnviewmark: should I pm you?
22:14:43 <mtnviewmark> well, GHC's errors are rendered a crazy moon poetry
22:14:45 <zzing> elerea's examples don't seem to compile...
22:14:52 <mtnviewmark> sure, if you wish
22:16:06 <zzing> mm_freak_: What would be a good example to use for yampa?
22:16:26 <mm_freak_> (does it happen to other people, too, that when you read some IRC messages you see haskell syntax everywhere?  "<- is away")
22:16:57 <mm_freak_> zzing: i'm not sure…  i started with a tutorial
22:19:27 <zzing> I have never used arrows before - what precisely are they?
22:23:38 <mm_freak_> zzing: my interpretation is that an arrow is to a function what a monad is to a value
22:23:59 <zzing> mm_freak_: My intuition for these things is rusty... :p
22:24:10 <zzing> But the first few slides: http://www.cs.nott.ac.uk/%7Enhn/FoPAD2007/Talks/nhn-FoPAD2007.pdf  make some sense so far
22:24:19 <zzing> It actually helps that I just took linear algebra
22:24:22 <mm_freak_> as such an arrow is a type constructor with two parameters, input and output, while a monad is a type constructor with only one parameter, output
22:25:12 <mm_freak_> and where monads have 'return', which takes a value, arrows have 'arr', which takes a function
22:26:03 <zzing> Is there anything from imperative languages that might help my intuition along?
22:26:12 <mm_freak_> as usual, no =)
22:27:06 <mm_freak_> arrows are like generalized functions…  there is an identity called simply 'id' (but not the one from Prelude, but the one from Control.Category)
22:27:27 <mm_freak_> there is arrow composition, which is called (.), again from Control.Category
22:27:37 <lars9> how to permutate this: pick k elements (with different indecies) from a list
22:27:52 <mm_freak_> (>>>) is the same as (.), but with arguments flipped…  there is also (<<<), which is an alias for (.)
22:27:53 <zzing> Out of curiosity does miranda do any of this FRP stuff? Miranda seems to be a favourite language at my university (thankfully I am in engineering)
22:28:22 <mm_freak_> lars9: randomly?
22:29:05 <conal> zzing: about arrows - do you know an arrow is just a member of the Arrow type class?
22:29:16 <lars9> mm_freak_: find all
22:29:42 <conal> i never know what people want to know when they ask what's a monad or arrow.  or monoid, applicative functor, etc.
22:30:09 <zzing> conal: Wouldn't know :p
22:30:16 <zzing> :t (>>>)
22:30:17 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:31:18 <zzing> okay, so if I have f a b, g b c, and h = f >>> g then h becomes h a c
22:31:43 <mm_freak_> conal: btw, i've written an n-ary 'apply' function, but i've yet to find out how i can reify
22:31:48 <conal> zzing: to understand Arrow or Monad, i recommend first understand simpler classes. start with Monoid & Functor.
22:31:56 <zzing> :t first
22:31:57 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
22:32:35 <zzing> conal: I used to have an understanding of monads once upon a time
22:32:41 <mm_freak_> then i got distracted by comonads…  i think i'm starting to understand them
22:32:56 <zzing> :t (&&&)
22:32:57 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:33:04 <zzing> @src (&&&)
22:33:04 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
22:33:22 <conal> zzing: there's an infinite number of monads. no one understands them all.
22:33:54 <zzing> conal: Consider my words in the narrowest of interpretations and that is what I mean :P
22:33:59 <conal> i'm not trying to be difficult or critical. i really am confused about what people could mean by "undersanding monads".
22:34:02 <dibblego> is there an example of a cabal file out there that has both a Library and Executable?
22:34:11 <conal> (or other classes)
22:34:24 <mm_freak_> dibblego: look at the dnscache package
22:34:25 <zzing> conal: Understand really should be know how to use
22:34:33 <zzing> It was a few of the basic ones I used
22:34:38 <conal> zzing: know how to use which ones?
22:34:57 <lars9> > msum [[1..2],[3..4]]
22:34:59 <lambdabot>   [1,2,3,4]
22:34:59 <mm_freak_> dibblego: it's a DNS resolver library together with a command line utility "massdns"
22:35:02 <zzing> conal: Too long ago to remember unfortunately
22:35:03 <dibblego> mm_freak_, I should add, the Executable depends on the Library
22:35:08 <mm_freak_> dibblego: yes
22:35:22 <sproingie> for functions, >>> is basically flip (.)
22:35:25 <conal> ah. a few of the basic ones. maybe function & pair. State.
22:35:31 <sproingie> composing left to right, like a pipe
22:35:35 <zzing> @src arr
22:35:36 <lambdabot> Source not found. My brain just exploded
22:35:38 <dibblego> mm_freak_, I get an error about the Library being hidden when I try to build
22:35:43 <zzing> :t arr
22:35:44 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
22:35:49 <mm_freak_> dibblego: huh?
22:35:55 <mm_freak_> just a sec
22:36:06 <dibblego> mm_freak_, my Main.hs imports a module from the library which causes a build error
22:36:11 <conal> The choice of "a b c" is so unfortunate.
22:36:18 <sproingie> > (- 10) . (* 20) $ 3
22:36:19 <zzing> I am trying to understand some of these arrow diagrams in this: http://www.cs.nott.ac.uk/%7Enhn/FoPAD2007/Talks/nhn-FoPAD2007.pdf  (about half way down)
22:36:20 <lambdabot>   -10
22:36:23 <sproingie> > (- 10) >>> (* 20) $ 3
22:36:24 <lambdabot>   -200
22:36:43 <mm_freak_> dibblego: oh, indeed, wait, i'll fix the error
22:36:47 <zzing> They make the diagrams look like data flow diagrams
22:36:49 <dibblego> mm_freak_, cheers
22:37:24 <sproingie> darg - was not the best choice
22:37:49 <zzing> Would it be true to say that you could make a looping control system with arrows?
22:38:17 <conal> zzing: ah. i think it's safe to view these diagrams as just a visualization of the types of some methods, plus a purely informal hint about what they might mean for various instances.
22:39:21 <dibblego> mm_freak_, is it even fixable?
22:39:42 <zzing> conal: hard to understand what they are really trying to say
22:39:56 <zzing> I wonder if there is a simple way to use arrows to understand this a little more
22:40:07 <conal> zzing: for instance the diagram for (>>>) says that f >>> g has the same input type as f and the same output type of g; also that f's output type & g's input type are the same, and that this common type (f's out & g's in) are not part of the type of f >>> g.
22:40:08 <mm_freak_> dibblego: sure
22:40:18 * hackagebot dnscache 1.0.2 - Caching DNS resolver library and mass DNS resolver utility  http://hackage.haskell.org/package/dnscache-1.0.2 (ErtugrulSoeylemez)
22:40:37 <mm_freak_> dibblego: contstuff 1.2 has some changes, which make it incompatible to contstuff 1.0, which use Control.Concurrent
22:40:44 <zzing> conal: yes that sounds very much like a monad afaik
22:40:46 <mm_freak_> dibblego: fixed
22:41:18 <dibblego> cheers, I'll take a look
22:41:23 <conal> zzing i bet it does. Arrow & Monad are fairly similar.
22:42:03 <conal> zzing: note i don't say "arrows & monads are fairly similar". since mostly monads are not even much like each other. and similarly for arrows.
22:43:02 <dibblego> mm_freak_, should I expect the solution in the diff between the cabal files of 1.0.1 and 1.0.2?
22:43:34 <mm_freak_> dibblego: nope, the significant change is in the diff of Network/DnsCache.hs
22:44:52 <mm_freak_> dibblego: darcs get http://code.haskell.org/dnscache/
22:45:12 <dibblego> mm_freak_, you .cabal file looks no different to mine
22:45:24 <Axman6> google code supports darcs?
22:45:34 <mm_freak_> Axman6: code.haskell.org
22:45:43 <Axman6> uh, right, brainfart -_-
22:50:31 <mm_freak_> dibblego: are you using Hs-source-dirs?
22:50:43 <dibblego> mm_freak_, yes
22:50:48 <dibblego> bugger, does this matter?
22:51:23 <mm_freak_> i think you need to specify the root directory somewhere in that list
22:51:30 <BMeph> I'm starting to think we're missing out by not distracting the whiny programmer crowd with comonads. Or maybe I just like playing with them... :)
22:51:34 <mm_freak_> like:  Hs-source-dirs:  /myprog .
22:51:48 <dibblego> mm_freak_, you mean under the Executable
22:51:49 <dibblego> ?
22:51:53 <mm_freak_> dibblego: yeah
22:52:11 <ddarius> BMeph: I wrote a little thing the other day to turn all your comonads into monads.
22:52:23 <dibblego> mm_freak_, got there, thanks!
22:52:27 <mm_freak_> dibblego: the program doesn't really use the /library/ itself…  it just has modules in common with the library
22:52:46 <dibblego> righto, I see, thanks again
22:53:00 <BMeph> ddarius: ...and? I wait with bated breath!
23:02:16 <juhp> is mail @community.haskell.org working for anyone?
23:02:54 <juhp> not me anyway
23:03:09 <juhp> I hope support@c.h.o works ;)
23:03:35 <juhp> maybe I'm just "lucky"
23:12:05 <rixx> Hello
23:12:23 <kfish> allo rixx
23:12:48 <dibblego> @hoogle (a -> z) -> (b -> z) -> a -> b -> z
23:12:49 <lambdabot> No results found
23:13:07 <rixx> its very quite in here. I'm on tryhaskell.org playing with the lessons
23:13:29 <shachaf> dibblego: What do you expect that function to do?
23:13:57 <dibblego> shachaf, tell me that I don't want that!
23:14:12 <rixx> I was looking for tutorials on parsing you see...I want to attempt to write an interpreter for a small subset of lisp
23:14:42 <shachaf> rixx: There's a Haskell tutorial that goes through doing that.
23:14:48 <rixx> obviously having no experience what so ever with parsing i'm having difficulty
23:14:55 <rixx> yeah thats what I found
23:14:57 <rixx> =)
23:15:05 <shachaf> But I seem to remember that it was somewhat confusing. You're probably better going through it yourself. :-)
23:15:55 <dibblego> @hoogle (z -> z -> Bool) -> (a -> z) -> (b -> z) -> a -> b -> Bool
23:15:55 <lambdabot> No results found
23:16:17 <rixx> I know there are librarys available for python that would simplify this but I figure I might as well learn about compiler/interpreter design myself.
23:16:33 <shachaf> rixx: A good introduction to monads through parser combinators is in _Programming in Haskell_, by Graham Hutton.
23:16:44 <shachaf> rixx: If you have that available you should read it. :-)
23:17:11 <shachaf> @pl \zzBool az bz a b -> zzBool (az a) (bz b) -- This is a strange function.
23:17:11 <lambdabot> ((flip . ((.) .)) .) . (.)
23:17:52 <rixx> thanks shachaf, I'm sure I can get my hands on a copy
23:18:48 <rixx> I dont even really 'know' lisp heh, I just thought it might be easier to parse since its very...
23:18:52 <rixx> pragmatic?
23:20:26 <BMeph> @ty on
23:20:27 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:20:34 <rixx> But haskell looks interesting. I was trying to find a download for PTL Scheme but the website isn't responding. I'm sure having some knowledge of a functional language like haskell would be good for my university course.
23:21:15 <gienah> rixx: PLT scheme is renamed to racket
23:21:43 <rixx> yeah, I noticed that. Either way the website isn't responding =(
23:22:02 <shachaf> gienah: The PLT Scheme website works but the Racket one doesn't.
23:23:26 <BMeph> shachaf: I recall mmorrow using it; he called it "coprod" I think.
23:24:01 <gienah> rixx: yes racket-lang.org seems down at the moment
23:24:48 <shachaf> gienah: I tried to download it a couple of days ago and didn't manage to.
23:24:48 <rixx> Well until it comes back up Haskell is something to do
23:26:12 <BMeph> @ty flip on ($)
23:26:13 <lambdabot> forall c a b. ((a -> b) -> (a -> b) -> c) -> (a -> b) -> (a -> b) -> c
23:26:33 <BMeph> That's...underwhelming. :\
23:27:00 <shachaf> rixx: Haskell is more fun anyway. :-)
23:27:16 <rixx> forall c a b. ((a -> b) -> (a -> b) -> c) -> (a -> b) -> (a -> b) -> c
23:27:22 <rixx> is -> implies
23:27:29 <rixx> like in math
23:27:39 <shachaf> rixx: Yes.
23:27:53 <rixx> i.e is that declaring some sort of transitive function ?
23:27:58 <shachaf> rixx: But the more standard meaning here is "a function from a to b".
23:28:10 <rixx> sweet
23:28:40 <shachaf> @google curry howard
23:28:41 <lambdabot> http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
23:28:42 <lambdabot> Title: Curry–Howard correspondence - Wikipedia, the free encyclopedia
23:28:49 <shachaf> rixx: If you want to read more about the other meaning. :-)
23:29:49 <kenjin2201> I'm new to Haskell... I can't figure out why the following can't be compiled.
23:29:51 <kenjin2201> isPrime n = n > 1 && all (\ x -> (mod n x) /= 0) [2..(floor (sqrt n))]
23:29:56 <rixx> Thanks, I'll read that asap...i'm sure i've heard the word currying before from one of my professors
23:29:59 <shachaf> rixx: In general it just specifies the domain and codomain, as in <http://en.wikipedia.org/wiki/Function_notation#Notation>
23:30:29 <shachaf> rixx: Well, "Curry" (Haskell Curry) has a bunch of different things named after him.
23:31:03 <rixx> let x = 4 in x * x
23:31:06 <rixx> opps
23:31:09 <rixx> wrong window
23:31:36 <shachaf> kenjin2201: You're taking the sqrt of n, so it's being treated as a floating-point number.
23:31:46 <joe6> hello, I am wondering how to extract the fieldname of a record while using SYB - data.generics module.
23:32:12 <shachaf> kenjin2201: You probably want sqrt (fromIntegral n).
23:32:23 <kenjin2201> shachaf : Oh... I see, thank you
23:32:50 <gienah> rixx: found racket on a mirror: http://mirror.leaseweb.com/FreeBSD/distfiles/racket/5.0.2/racket-5.0.2-src-unix.tgz
23:32:55 <dreixel> joe6: constrFields and constrIndex ?
23:33:16 <rixx> Thank you gienah =D
23:33:43 <shachaf> > nubBy(((>1).).gcd)[2..]
23:33:45 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:34:30 <joe6> dreixel: ok, thanks. so, we ave to get a list of the fields of the parent and when in the child query that list with the index, Correct?
23:34:39 <joe6> s/ave/have/
23:34:50 <dreixel> joe6: yes
23:34:52 <joe6> dreixel: it is so much easy to work on generics when you are around.
23:35:45 <dibblego> how can I add a { to a cabal description?
23:35:47 <joe6> dreixel: are you planning on being around for some time?
23:36:04 <dreixel> joe6: I'm generally always on the channel, but not always behind the computer
23:36:14 <joe6> dreixel: where are you based? europe, us or somewhere else?
23:36:26 <dreixel> joe6: The Netherlands
23:36:40 <joe6> cool..
23:38:44 <mm_freak_> kenjin2201: you should always specify the type of top-level defintions
23:39:33 <mm_freak_> that makes sure you know what you want, so you can catch your conceptual errors early, and it also improves error messages
23:41:00 <kenjin2201> mm_freak : I'm getting used to it. Thank you
23:43:37 <mm_freak_> :t chunks
23:43:38 <lambdabot> Not in scope: `chunks'
23:43:42 <mm_freak_> :t chunksOf
23:43:43 <lambdabot> Not in scope: `chunksOf'
23:55:36 <mm_freak_> > take 100 . map fst . filter snd . zip [2..] $ fix (\r i (x:xs) -> x : r (i+1) (if x then take (i-1) xs ++ (concatMap (\(_:xs) -> False:xs) . takeWhile (not . null) . map (take i) . iterate (drop i) . drop (i-1)) xs else xs)) 2 (repeat True)
23:55:38 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:55:55 <mm_freak_> > drop 5000 . map fst . filter snd . zip [2..] $ fix (\r i (x:xs) -> x : r (i+1) (if x then take (i-1) xs ++ (concatMap (\(_:xs) -> False:xs) . takeWhile (not . null) . map (take i) . iterate (drop i) . drop (i-1)) xs else xs)) 2 (repeat True)
23:55:59 <lambdabot>   mueval-core: Time limit exceeded
23:57:14 <mm_freak_> @let primesSOE = map fst . filter snd . zip [2..] $ fix (\r i (x:xs) -> x : r (i+1) (if x then take (i-1) xs ++ (concatMap (\(_:xs) -> False:xs) . takeWhile (not . null) . map (take i) . iterate (drop i) . drop (i-1)) xs else xs)) 2 (repeat True)
23:57:16 <lambdabot>  Defined.
23:57:29 <mm_freak_> > drop 1000 primesSOE
23:57:33 <lambdabot>   mueval-core: Time limit exceeded
23:57:53 <mm_freak_> ok, infinite SOE is a bad idea with lists
