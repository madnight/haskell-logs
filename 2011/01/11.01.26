00:00:29 <kuffaar> Well I don't use Iteratees, I just use the raw Network API
00:00:40 <kuffaar> accept -> forkIO -> recv etc
00:01:05 <Axman6> you can still use iteratees there
00:01:32 <n0den1te> mauke: looks like I need to read your article a couple of times over. I'll have it bookmarked, thanks. 
00:01:33 <kuffaar> It's just that it doesn't do stuff like call sClose regardless of the values returned by Network
00:01:53 <kuffaar> So I guess that I unknowingly cheated my way out of the problems associated with lazy IO
00:02:06 <kuffaar> Without addressing the problem in general
00:02:14 <kuffaar> Perhaps I should learn how to use Iteratees
00:03:31 <Axman6> check out micheal snoyman's blog for a good introduction to the enumerator package
00:03:41 <Axman6> also, the monad.reader had a good article on them
00:04:33 <mm_freak_> Axman6: if you think about what an enumeratee is (Iteratee a' m b -> Iteratee a m b) and factor out all useless parts, then again the type alias makes sense
00:04:41 <kuffaar> But first I need to fix the logic because I realised that I misunderstood the format lol
00:04:46 <mm_freak_> Axman6: on a first glance, i agree that Enumeratee is quite a weird type
00:05:15 <mm_freak_> but i found that when you want to use iteratees properly you really should learn the concept
00:06:06 <mm_freak_> kuffaar: iteratees really make your life easier, because you get a nice list-like interface, but including support for parser-style monadic notation
00:06:26 <mm_freak_> in fact you can easily convert, for example, an Attoparsec parser into an iteratee
00:06:30 <Axman6> iteratees are great, when they work
00:06:39 <Axman6> we're having some serious problems with them though
00:06:50 <mm_freak_> Axman6: like what?
00:07:03 <Axman6> huge space leaks in the iteratee library itself
00:07:11 <Axman6> like... >>= seems to leak space
00:07:34 <kuffaar> Urgh :(
00:07:36 * kuffaar turned off
00:08:17 <kuffaar> SPJ's talk on the GC of ghc sounded questionable anyways, made it sound like an unpredictable memory hungry beast like the Oracle JVM
00:08:48 <mm_freak_> Axman6: (>>=) doesn't leak space…  maybe you're using a faulty enumerator
00:09:38 <kuffaar> Somebody in here once said something like "most GCs never give memory back to the system really" - that sounded pretty terrible to me
00:09:43 <Axman6> mm_freak_: the guy sitting next to me has been looking into this for the past two weeks, and it seems that >>= is where the space leak is coming from
00:09:44 <kuffaar> Does GHC actually work like that?
00:10:01 <Axman6> though, we've just a breakthrough, compiling with ghc 7 without optimisations doesn't leak
00:10:14 <Axman6> kuffaar: ghc's used to, now it doesn
00:10:19 <Axman6> now it does*
00:10:35 <kuffaar> Cheers :[
00:10:54 <mm_freak_> Axman6: use profiling to find out
00:11:09 <mm_freak_> i'm using iteratees a lot and i've never noticed any space leak
00:11:18 <mm_freak_> my programs run in constant space mostly
00:11:26 <kuffaar> It would be pretty embarrassing if you had to restart services written in Haskell on a regular basis because they accumulate gigabytes of process memory over time :/
00:11:37 <Axman6> mm_freak_: uh yeah, we've been doing a hell of a lot of profiling
00:11:51 <Axman6> well, i shouldn't say we, the guy next to me
00:12:12 <Axman6> mm_freak_: are you using it for say parsing large files?
00:12:24 <Axman6> we didn't have these problems with the older iteratee library
00:12:26 <mm_freak_> does the GC now give memory back?  last time i checked the GC never freed memory
00:12:37 <Axman6> i believe it does in ghc 7
00:12:38 <kuffaar> mm_freak_ do you use ghc 7?
00:12:39 <mm_freak_> Axman6: yes, parsing large files as well as lengthy network sessions
00:12:58 <kuffaar> Axman6 you believe? :/
00:12:58 <mm_freak_> Axman6: for parsing i mostly convert Attoparsec parsers to iteratees using attoparsec-enumerator
00:13:05 <mm_freak_> kuffaar: GHC 6.12
00:13:22 <kuffaar> That sounds like a massive fault to me
00:13:30 <kuffaar> If it didn't give back memory
00:13:31 <Axman6> mm_freak_: yes, i'm pretty sure we're using attoparsec for our parsing
00:13:44 * hackagebot SimpleEA 0.1.1 - Simple evolutionary algorithm framework.  http://hackage.haskell.org/package/SimpleEA-0.1.1 (ErlendHamberg)
00:13:51 <mm_freak_> Axman6: of course you should avoid writing parsers as iteratees directly, but nobody would do that anyway
00:18:01 <kfish> Axman6, i believe this particular (iteratee) bit of code doesn't use attoparsec
00:18:37 <kfish> it used to just use data binary at the lowest level, now native iteratee afaiu
00:18:46 <joe6> hello, anyone with ghc on debian
00:19:08 <mm_freak_> Axman6: actually i don't see any way for (>>=) to leak memory without a faulty enumerator
00:35:42 <CindyLinz> Is there a package for parsing HTTP request body in Hackage?
00:36:20 <CindyLinz> I've found a package named redHandlers. But its Maintainer is NONE, and the Stability is Experimental..
00:36:27 <kevinburke> hey, can you help me figure out why this program isn't compiling? i'm trying to get better at haskell
00:36:28 <kevinburke> http://pastebin.com/ESJb4B2E
00:36:41 <kevinburke> compile output is cowqueue.hs:19:4: parse error (possibly incorrect indentation)
00:37:09 <Axman6> kevinburke: please also paste the error
00:37:18 <Axman6> with the code next time*
00:37:34 <kevinburke> http://pastebin.com/CNznVF6s
00:37:40 <Axman6> ah, you're missing a do on line 17
00:38:09 <kevinburke> could you explain why?
00:38:54 <Axman6> oh actually, that line doesn't make any sense. you can't do IO just anywhere in a haskell program
00:39:25 <Axman6> you need to remove the everything after the = on line 17
00:40:30 <kevinburke> hmmm, could i try a helper method? 
00:40:44 <Axman6> i don't understand
00:42:59 <Axman6> actually, if you don't delete that line, and just replace "" with return (), and add a do after the = then i should work
00:44:12 <frerich> Hm, when thinking about a functional implementation of e.g. a chess game - does it make sense to consider a 'turn' as a function 'performTurn :: Game -> Game'? And running a game would mean repeatedly calling performTurn until some sort of end condition is met?
00:44:57 <kevinburke> i tried with both () and [], i'll paste the errors
00:45:09 * frerich is amazed and disappointed at the same time about how hard it is to think of a functional description of a game. :-}
00:45:11 <Axman6> no, return (), not ()
00:46:12 <kevinburke> http://pastebin.com/aZSq1MNj
00:46:23 <kevinburke> oh
00:46:24 <Jafet> frerich: that's so abstract that it's valid
00:46:36 <frerich> I'm never quite sure whether I should model something like a 'turn' in a game as a data structure or as a function.
00:46:48 <frerich> I still lack the gut feeling with functional programming :)
00:46:54 <Axman6> kevinburke: processLines [] = return ()
00:47:04 <frerich> Jafet: Would it be idiomatic?
00:47:15 <frerich> Or is there no idiomatic approach, really?
00:47:43 <Jafet> Well, the chess community has well-defined serializations for the effects of turns.
00:47:48 <kevinburke> sorry - i just tried that and received this error - http://pastebin.com/MDm8sXak
00:48:14 <kevinburke> wait that's not an error with the do i don't think
00:48:28 <kevinburke> hey it worked!
00:48:29 <kevinburke> haha
00:48:31 <Axman6> there's also a problem with the putStr line, it's easy to fid, use putStrLn and remove the ++ "\n"
00:48:32 <Jafet> So they can be data structures, and a chess player would be an algorithm to compute those effects.
00:48:33 <kevinburke> thanks
00:48:48 <mm_freak_> frerich: generally you model verbs as functions and nouns as data structures
00:49:41 <frerich> Jafet: Oh, I just chose chess as a random game which most people are familiar with. I'm just trying to view this problem from different angles.
00:50:43 <frerich> mm_freak_: Hm, so you could have a 'Turn' data structure which contains information about where (assuming we're still talking about a chess game) something was moved, and this 'Turn' would be applied to a 'Game' using some function (which would return a new 'Game')?
00:50:50 <Jafet> Many widely played board games have well-defined stages of play, which can be translated directly. Free models.
00:51:10 <frerich> I'm trying to find out how more experienced Haskell programmers (or functional programmmers in general) would model things to get a feeling of how to compose problems.
00:51:34 * frerich wishes he had some Haskell guru in the next office so I could watch over his shoulder :)
00:51:39 <kevinburke> Axman6: I understand why there's a do statement in main because you need to unwrap the standard input
00:51:56 <kevinburke> but why do I need the second do statement?
00:51:57 <Jafet> A nice exercise might be to try and model a game-playing algorithm functionally.
00:52:02 <kevinburke> because of putStrLn?
00:52:11 <Jafet> Eg. a Monte Carlo evaluator for Go
00:52:21 <Axman6> because you're using two IO actions one after each other
00:52:35 <Axman6> kevinburke: http://random.axman6.com/blog/?page_id=70
00:52:46 <krey_> when do you use STRefs? I'm currently failing and doing a cartesian product on (finite) graphs and I'm thinking of moving to ST
00:53:13 <Axman6> i find STRefs aren't all that useful
00:53:41 <krey_> Axman6;
00:53:43 <krey_> oops
00:53:50 <krey_> Axman6: so, you'd avoid them?
00:54:06 <Axman6> well, if they make sense for what you're doing, then no
00:54:10 <mm_freak_> frerich: the "turn" itself may be a data structure, but function arguments are often a good manifestation of that
00:54:36 <krey_> Axman6: well, what do you think: cartesian product on finite graphs
00:54:54 <mm_freak_> frerich: but the act of moving a piece is a verb, so it's a function
00:55:06 <tlonim> the equivalent of something like a python generator/yield is abstracted into a state monad right ?
00:55:37 <krey_> tlonim: just use lists?
00:55:51 <olsner> tlonim: usually not - lazy lists replace most of what you use generators for
00:55:57 <kevinburke> axman6: just a heads up, in google chrome your site is showing up as about 2700pixels wide
00:56:00 <kevinburke> in firefox it's okay
00:56:07 <kevinburke> i'm using dev 10.0
00:57:08 <Axman6> yeah, i've been meaning to add a maximum size to its width
00:57:09 <tlonim> olsner: krey_ yeah,, i was just looking at a imperative perspective.. http://stackoverflow.com/questions/4459789/generating-sequential-members-of-an-infinite-list ... the equivalent problem in functional prgramming would be structured differently i guess
00:57:28 <Twey> frerich: chrisdone did a project where he recorded his emacs session whilst developing a project
00:57:34 <olsner> (but the continuation/coroutine part of python's yield is a lot different in haskell, especially if the generator has side-effects)
00:57:34 <Twey> frerich: Maybe that would suit you?
00:57:35 <Axman6> kevinburke: if you have a normal sized chrome window, it works fine
00:57:50 <Axman6> or not
00:57:52 <Axman6> hmmmmmmmm
00:57:57 <frerich> Twey: Oh, that sounds interesting! I'm a vim user but I'll neglect this difference in this case ;-)
00:58:02 <Axman6> it didn't used to do that
00:58:30 <kevinburke> here's what i'm looking at: https://skitch.com/kburke/rmee3/dock
00:58:43 <Axman6> yeah i'm getting it too
00:59:09 <tlonim> olsner: in haskell the coroutine thing is done using something like channels ?
00:59:22 <Axman6> other pages work fine, i wonder what's up with that one
00:59:32 <Twey> frerich: Oh, well, in that case you're beyond help ;)
00:59:33 <tlonim> like haskell procs communicating over a channel
00:59:43 <frerich> Twey: Hah!
01:00:07 <frerich> Twey: You're referring to http://chrisdone.com right? Do you happen to know where that recording (a screencast?) is available? I can't seem to find it on what looks like his homepage.
01:00:29 <olsner> tlonim: that'd be one way, or you could use ContT or Cont
01:01:03 <Twey> frerich: https://github.com/chrisdone/amelie-emacs-cast
01:01:06 <tlonim> olsner: ok.
01:02:34 <kevinburke> what language does haskell compile to? assembler?
01:02:38 <krey_> tlonim, olsner: omg, you don't want to use Cont!
01:02:46 <Twey> kevinburke: Many things
01:03:00 <Twey> I think the native backend uses C--?
01:03:15 <Jafet> It can also compile to operational-semantics
01:03:22 <tlonim> krey_: oh.. i have seen ContT being used for callCC but not coroutine stuff 
01:03:28 <Twey> There's also an LLVM backend, an interpreter, and a Javascript backend
01:03:30 <kevinburke> wikipedia says C and C--
01:03:33 <kevinburke> for ghc anyway
01:03:34 <Axman6> kevinburke: ghc compiles to machine code, using various backends
01:03:39 <kevinburke> ok
01:03:44 <Twey> Yeah, it can do via C, but that's mostly deprecated now
01:03:44 <olsner> krey_: hehe, ok :) why?
01:03:53 <Axman6> i believe the C-- in ghc is known as Cmm, it's not quite C--
01:04:08 <Axman6> kevinburke: the latest ghc also has a LLVM backend
01:05:20 <krey_> olsner: in my experience, 100% (rounded up) of the time, you can get away without it
01:06:04 <kevinburke> axman6: tomorrow i need to try to make it tail recursive, i think the stack is getting way too big in the current program, but i'm gonna go to bed. thanks for the help again
01:06:29 <Axman6> it looked fairly tail recursive to me, could be wrong'
01:07:15 <kevinburke> this input is taking about 10 mins:
01:07:15 <olsner> krey_: well, sure, you can do everything without using Cont
01:07:15 <kevinburke> THEIRCOUNTWANTSSATACOTODAYCOOKEDALLTTHROUGHNIGHTIMEANDSOON
01:07:16 <kevinburke> INTHEACCORDSTHECOWARDSATTACKEDANINNOCENTCHILDANDALOON
01:07:28 <kevinburke> anyway its 1am, take care
01:07:33 <Axman6> ... 10 mins? o.O
01:19:38 <quuuux> @hoogle (a -> Bool) -> [a] -> (Maybe a, [a])
01:19:38 <lambdabot> No results found
01:19:59 <sipa> what is the Maybe a?
01:20:08 <quicksilver> the element, if found, Nothing if not.
01:20:21 <quuuux> @hoogle (a -> Bool) -> [a] -> (Maybe [a], [a])
01:20:21 <lambdabot> No results found
01:20:24 <quicksilver> Maybe (a,[a]) would make more sense to me.
01:20:28 <Axman6> @src Maybe
01:20:28 <lambdabot> data Maybe a = Nothing | Just a
01:20:48 <quicksilver> anyhow, I don't think it's there.
01:20:59 <ski> @hoogle find
01:21:00 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
01:21:00 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
01:21:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
01:21:12 <quuuux> no, I'm after a slightly different version of break
01:21:30 <ski> ah
01:21:46 <quicksilver> a variation of the zipper version of 'find'
01:21:46 <JaffaCake> do we have a problem with community.haskell.org?
01:21:56 <ski> > break isSpace "abc def"
01:21:57 <lambdabot>   ("abc"," def")
01:22:00 <ski> > break isSpace "def"
01:22:01 <lambdabot>   ("def","")
01:22:02 <quicksilver> JaffaCake: what kind of problem?
01:22:19 <JaffaCake> I can't log in - the host key has changed, and it isn't accepting my SSH key
01:22:21 <quuuux> right. I want `(Just "abc", "def")' and `(Nothing, "def")' respectively
01:22:25 <ski> quuuux : you want a `Nothing' somewhere in that latter example ?
01:22:27 <JaffaCake> this is quite worrying
01:22:46 <nejucomo> What's the syntax for splitting long type specifications over lines?
01:22:57 <quicksilver> JaffaCake: nobody's mentioned anything that I've heard, and web pages on it are still working
01:23:25 <quuuux> ivanm said it was being weird earlier
01:23:27 <quicksilver> JaffaCake: "community.haskell.org has address 72.249.126.23"
01:23:35 <quuuux> asking for a password or something
01:23:47 <JaffaCake> can anyone log in?
01:24:01 <ski> @let quuuux p as = case break p as of (front,[]) -> (Nothing,front); (front,_:back) -> (Just front,back)
01:24:02 <lambdabot>  Defined.
01:24:08 <ski> > quuuux isSpace "abc def"
01:24:10 <lambdabot>   (Just "abc","def")
01:24:10 <ski> > quuuux isSpace "def"
01:24:12 <lambdabot>   (Nothing,"def")
01:24:16 <JaffaCake> quicksilver: has its IP address changed?
01:24:35 <quicksilver> JaffaCake: I don't know; I was pasting that so you could compare to your IP in case the DNS was going od
01:25:05 <quuuux> > quuuux isSpace "foo "
01:25:07 <lambdabot>   (Just "foo","")
01:25:14 <ski> quuuux : though, i might think it more natural to have the `Maybe' in the second component of the pair ..
01:26:15 <ski> (that way, the part of the list which has been traversed, and for which the given predicate definitely fails, will always be in the left part of the output)
01:26:16 <quuuux> ski: possibly. I was thinking out loud and hoped hoogle knew of my plight
01:27:46 <ski> anyway, i don't know of any library function which does what you want
01:29:19 <quuuux> yeah. I think it's cleanest to have the case expression explicitly in there
01:30:20 <quicksilver> quuuux: I think (a -> Bool) -> [a] -> Maybe ([a],a,[a]) is the best type.
01:30:38 <bvck> Hi folks, I thing I understand what it means to do "instance Eq Foobar ....", but could someone please explain which type is being made an instance of MonadState in "instance MonadState s (State s) where ...."
01:30:45 <quicksilver> quuuux: it's most natural (and asymptotically efficient) to keep the two halves of the list separate.
01:31:05 <sipa> bvck: State s is being made an instance
01:31:05 <Axman6> bvck: State is
01:31:07 <quicksilver> bvck: MonadState is a two-parameter class, so there are two types being made a 'joint instance'
01:31:13 <Axman6> well, yeah, State s
01:31:21 <quuuux> quicksilver: oh, I see what you mean. That makes the hidden zipper explicit too
01:31:36 <quicksilver> quuuux: with [] you probably keep the left list reversed, as well.
01:31:51 <quicksilver> so that you can have O(1) 'left' and 'right' operations.
01:32:48 <ski> bvck : think of `Eq Foobar' as stating a property of the type `Foobar'
01:33:19 <ski> bvck : and then `MonadState s (State s)' is expressing a relation between the two types `s' and `State s' (for any type `s', since `s' is a type variable)
01:33:40 <ski> @type put
01:33:42 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
01:33:46 <ski> @type get
01:33:47 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
01:34:26 <ski> bvck : `put' says that if `s' is a state type associated with the monad `m', then `put' takes a value of type `s' and gives back a `m ()' action
01:35:16 <ski> bvck : e.g. if you say `instance MonadState GameState GameMonad', then you associate the type `GameState' with the monad `GameMonad', saying that the former is a valid state type for the latter
01:35:46 <phaer> @type zipWith
01:35:47 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
01:35:52 <ski> so then `put' can take a value of type `GameState' and give back an `GameState ()' action, which sets the state in the monad to the specified one
01:36:10 <ski> bvck : does that help ?
01:36:56 <bvck> ski, it does. One more, is there a link where I can read on multiparameter classes? My understanding on classes seem quite wrong.
01:38:15 <ski> btw, you may note i said `MonadState s m' means that `s' is *an* appropriate state type for `m'
01:38:25 <ski> in actually, the class `MonadState' is defined like
01:38:34 <ski>   class Monad m => MonadState s m | m -> s
01:38:51 <bvck> (yup, had to read on functional dependencies to grok that)
01:39:03 <ski> the `m -> s' part saying that `m' must determine `s' .. or, iow, that there can't be two different types `s' associated with the same `m'
01:39:20 <ski> so, in this case, we can talk of *the* state type associated with the monad `m'
01:39:40 <ski> (for monads that are instances of `MonadState' at all, of course .. some aren't)
01:40:16 <ski> now, one could argue that this is a bad specification of `MonadState' .. but that's what the functional dependency `m -> s' means, anyway
01:41:00 <ski> (in some cases, it would be handy to be able to associate several different state types with a monad)
01:41:33 <ski> bvck : as for links .. there's the GHC manual, but possibly that's a bit sparse
01:41:44 <bvck> ski, that is very sparse.
01:41:51 <ski> i think there are papers that have more examples and rationale .. but i can't remember which
01:41:59 <ski> maybe they are listed on the wiki, somewhere
01:46:15 <bvck> ski, does 'currying' apply to type constructors? For example, you talk about type 'State a', but in the definition it is 'newtype State s a...'
01:46:44 <quicksilver> this is called partial application, not currying.
01:46:56 <quicksilver> and yes, it is a useful concept for type construtors too.
01:47:17 <quicksilver> "Maybe Int" is a concrete type, but "Maybe" is a type constructor; we also say it is a type of kind * -> *
01:47:22 <mux> unfortunately many new languages that incorporate some form of partial function application tend to call that currying
01:47:47 <quicksilver> the class Monad refers to types of kind * -> *.
01:47:57 <quicksilver> mux: round up all the people responsible and have them shot.
01:48:03 <quicksilver> mux: there is no excuse for this abuse of terminology.
01:48:37 <mux> I would, if they'd listen to me :-)
01:49:08 <mux> quicksilver: one offender: http://search.cpan.org/~dconway/Perl6-Currying-0.05/lib/Perl6/Currying.pm
01:51:12 <ion> ew
01:52:42 <kuffaar> <mux> unfortunately many new languages that incorporate some form of partial function application tend to call that currying
01:52:48 <kuffaar> I thought they were inherently related concepts?
01:53:08 <quicksilver> they are related concepts
01:53:18 <quicksilver> much like "car" and "wheel" are related concepts
01:53:33 <quicksilver> but if you confuse the two terms whilst talking to a mechanic, he will not understand what you mean.
01:54:11 <mux> what quicksilver said :)
01:55:00 <quuuux> haskell programmers == function mechanics?
01:55:12 <opqdonut> type system mechanics?
01:55:32 <silver> I like that
01:56:12 <mux> we fix problems with functions tht you didn't know you had, and we charge you extra for it
01:56:35 <sioraiocht> mux: I like the sound of *that*
01:59:27 <leeteng> the time is 18:10
02:03:16 <merijn> Hmm, I think I have a new paper heuristic: Just read anything by Wadler...
02:05:55 <ski> bvck : but yes, the type constructor `State' is curried
02:05:59 <ski> @kind State
02:06:00 <lambdabot> * -> * -> *
02:06:09 <ski> an uncurried version would be something like
02:06:15 <ski>   State :: (*,*) -> *
02:06:33 <ski> but haskell doesn't have product kinds, so this can't be expressed
02:07:03 <ski> bvck : also note that `State' itself is not a monad. instead `State s' is a monad, for every type `s'
02:07:18 <kuffaar> quicksilver: What's the difference then? Currying is the mathematical definition whereas partial application is basically currying within the context of a programming language?
02:07:51 <ski> kuffaar : if `f :: A -> B -> C', then `f' is a curried function. a partial application of it is `f a'
02:08:05 <ski> a partial application is an application
02:08:31 <ski> similarly, because `State :: * -> * -> *', `State Int' is a partial application of `State'
02:08:38 <kuffaar> Oh, I thought "currying" implied application, too, hmm
02:08:55 <ski> the "partial" in "partial application" refers to that it is applied, but not to all of its arguments
02:09:20 <ski> there is no application in the curried function `\x y -> 42'
02:09:31 <bvck> kuffaar, read this http://en.wikipedia.org/wiki/Currying :)
02:09:49 <bvck> (sorry, I was reading that to get the difference myself)
02:09:50 <ski> (btw, note that "all arguments" is a somewhat fuzzy concept)
02:10:00 <kuffaar> I already had that open actually
02:10:45 <bvck> ski, you cannot imagine how much confusion  I had all day before it dawned on me late in the evening that State s was the monad...:(
02:11:10 <ski> sometimes, if you have `f :: (A,B) -> C', you still call `\b -> f (a,b)' a partial application of `f' (since the `A' argument is provided, but the `B' one isn't)
02:11:42 <ski> bvck : yeah .. often we're lazy/sloppy, and talk about "the `State' monad"
02:11:50 <ski> (and similarly for other monad)
02:12:08 <ski> otoh, talking about a "state monad" (with lower case "state") is just fine, imo
02:13:50 <ski> e.g. if you define `newtype GameMonad a = GS (GameState -> Either GameError (GameState,a))', then `GameMonad' could be said to be *a* state monad
02:14:49 <ski> but `State s' (and `StateT s m') are so to speak the standard examples of state monads
02:16:29 <bvck> ah, I see what you did there. GameMonad encompasses a computation that leads to either an error or another state. Correct?
02:16:36 <ski> yes
02:17:00 <ski> the "leads to either an error or" is another aspect of `GameMonad' .. but that doesn't stop it from being a state monad
02:17:35 <bvck> True, but you would have to make it an instance of Monad though. right?
02:18:24 <boegel> is there a way to check which Haskell Platform is currently installed on a system (Linux)
02:18:49 <bvck> boegel, ghc -v?
02:19:02 <boegel> bvck: gives 6.12.3
02:19:14 <boegel> bvck: is that the latest Haskell Platform?
02:19:19 <dmhouse> -V you mean
02:19:25 <ski> bvck : yes, the `Monad m' in `class Monad m => MonadState s m' means that one must declare `m' to have the `Monad' property (i.e. make `m' an instance of `Monad'), before being able to relate `s' and `m' by the `MonadState' relation
02:19:25 <bvck> rpm -qa | gep haskell
02:20:13 <bvck> (that would be grep not gep)
02:20:27 <ski> (though i think it possibly would have been better to have the syntax be `class Monad m <= MonadState s m' .. i.e. logically, if `MonadState s m' is to hold, then `Monad m' must already hold)
02:20:56 * ski . o O ( `alias gerp grep' )
02:25:22 <bvck> boegel, sorry. What linux are you using? I have Fedora and on it the rpm has haskell-platform as part of the name. So dumping the list of rpms installed and doing a grep on haskell gives me the version of the platform installed. ghc -V will give you the version just of the ghc compiler.
02:26:29 <boegel> bvck: noticed that too now :)
02:26:41 <boegel> bvck: thx for the help
02:42:06 <yitz> preflex: seen igloo
02:42:06 <preflex>  igloo was last seen on #ghc 13 hours, 57 minutes and 52 seconds ago, saying: Why would not GCing mean freezing threads?
03:10:36 * hackagebot hoogle 4.2.1 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.1 (NeilMitchell)
03:20:33 <jonkri> quicksilver: i've been writing a small 3d engine myself in java so i know a little bit about opengl... considering using hopengl and yampa :)
03:22:17 <merijn> Is Yampa the best haskell FRP library atm?
03:23:58 <jonkri> merijn: is the first one i've taken a look at so far. let me know if you know of any others :)
03:26:19 <jonkri> this is in fact the first time i ever hear the term frp
03:29:31 <merijn> Well, there's Reactive, Elerea and a few others I think
03:29:46 <merijn> But Reactive had some performance issues last I checked
03:31:06 <quicksilver> yampa appears to be the most mature / usable.
03:31:33 <quicksilver> moio is another entrant from the elerea author in a similar-ish domain
03:31:47 <quicksilver> I still think reactive has the best API design, if only we could work out how to implement it.
03:32:39 <merijn> jonkri: The idea of FRP is introduced by http://conal.net/fran/, http://conal.net/papers/simply-reactive/ and http://conal.net/papers/push-pull-frp/
03:33:17 <quicksilver> however, even if/when we *do* work out how to implement reactive
03:33:27 <quicksilver> I think we will then need to work out how to profile/debug it.
03:33:41 <merijn> quicksilver: I believe that FRP is exactly what I need, if only I could figure out what the hell it was ;) I should probably actually read the push-pull FRP paper/watch the presentation, but no time atm
03:34:25 <quicksilver> well I think fran is simple enough to make it clear what it *is*
03:34:39 <quicksilver> it's simple declarative specifications of animations
03:34:46 <quicksilver> (more generally - time varying systems)
03:35:00 <quicksilver> the hard part is making it usable/useful.
03:35:03 <merijn> Yeah, I just have no picture of how you'd program with it :p
03:35:42 <merijn> Making it usable/useful is the same problem dependent typing has, the future will be a fascinating place :)
03:35:50 <quicksilver> yeah.
03:36:00 <quicksilver> reactive programming, dependent types, and flying cars
03:36:05 <quicksilver> what could possibly go wrong?
03:36:19 <merijn> Flying cars? Now that's just wishful thinking
03:48:22 <jonkri> interesting
03:54:07 <edwardk> i like the idea of frp, i just worry that its sort of slightly off from being implementable as intended.
03:54:22 <merijn> edwardk: That's what we call a research challenge :)
03:54:30 <merijn> If you don't try you'll never succeed
03:54:56 <edwardk> merijn: i've been trying ;)
03:55:03 <edwardk> this is how i came to this conclusion ;)
03:55:28 <ivanm> hey edwardk 
03:55:33 <edwardk> yo
03:55:47 <merijn> Good, as long as no one solves I might have a shot of finding a research position in that direction ;p
03:56:01 <ivanm> I was going to try and start implementing my crazy idea, but I figured I should finish off the Text port of graphviz first
03:56:19 <merijn> I asked before (with little success) but is anyone aware of universities which are doing research into FRP-like directions?
03:56:25 <ivanm> but I did check and it seems I can safely add/use JIT-specific attributes in Dot without dot, neato, etc. caring! \o/
03:57:50 <merijn> Utrecht and Nijmegen seem like good places to go for Haskell (and programming language stuff in general), but that's not entirely the direction I wanna go
04:02:04 <quicksilver> edwardk: A related challenge is that, as we develop more abstract/declarative paradigms, it becomes ever harder to do meaningful space and time profiling
04:02:36 <quicksilver> edwardk: I have a partial reactive implementation - better than conal's in a couple of parts, worse in others - but I have no idea how a user of it would be expected to locate + solve space issues.
04:02:43 <merijn> quicksilver: Which is why I am convinced there will always be a niche for low level imperative hacking
04:03:23 <ivanm> quicksilver: what, profiling doesn't work anymore with it?
04:03:37 <merijn> Unless there is a massive paradigm shift in computational power (quantum computers maybe?) I don't see declarative languages displacing systems languages soon
04:04:08 <merijn> ivanm: Not in a user friendly way. An FRP library probably isn't much good if I need intricate knowledge of its internals to be able to fix/optimize my code
04:05:26 <quicksilver> ivanm: profiling works fine.
04:05:42 <quicksilver> ivanm: but the symbols in profiling refer to things which are below the abstraction layer the library has introduced.
04:05:48 <quicksilver> right, what merijn said.
04:07:13 <ivanm> *nod*
04:08:48 <quicksilver> I don't think it's an insoluble challenge
04:09:03 <quicksilver> you can document the symbols, recommend profiling otptoions and explain the results
04:09:13 <quicksilver> I just think it's a challenge, and one you have to address.
04:09:31 <quicksilver> A library isn't much use if you can't understand how to fix/optimize your code, again as merijn said.
04:15:52 * hackagebot parsec1 1.0.0.2 - Portable monadic parser combinators  http://hackage.haskell.org/package/parsec1-1.0.0.2 (ChristianMaeder)
04:20:53 * hackagebot parsec1 1.0.0.3 - Portable monadic parser combinators  http://hackage.haskell.org/package/parsec1-1.0.0.3 (ChristianMaeder)
04:33:12 <ivanm> OK, wtf is parsec1 as opposed to parsec-2 and -3 ?
04:33:26 <ivanm> oh, the haskell98 part of parsec2
04:34:56 * hackagebot parsec3 1.0.0.1 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.1 (ChristianMaeder)
04:38:57 * hackagebot blaze-builder-enumerator 0.2.0.1 - Enumeratees for the incremental conversion of builders to  bytestrings.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.2.0.1 (SimonMeier)
05:01:55 <kuffaar> "Hello, how do I run Haskell programs on my Atmel 8-bit uC?"
05:02:55 <Jafet> With bananas, envelopes, lenses and barbed wire
05:03:02 <wferi> Hello, how do I open a file with O_EXCL|O_CREAT?
05:03:26 <hpc> hello, how do i from webbpage
05:06:33 <burp> hm, this is strange, my network package surely has ipv6 support, but listenOn doesn't bind to an ipv6 address
05:07:54 <kuffaar> burp: Don't use listenOn, you can't even control what address it binds to
05:08:03 <kuffaar> On Windows it binds IPv6 only by default
05:08:09 <burp> ew, I see
05:08:11 <kuffaar> On Linux IPv4 127.0.0.1 by default
05:08:27 <burp> I thought it would do "dual-stack"
05:08:32 <kuffaar> Not on Windows
05:08:37 <kuffaar> Possibly on Linux, I didn't checki
05:08:39 <burp> I'm on linux
05:08:51 <kuffaar> burp use ltrace/strace to check for sure
05:09:29 <rribeiro> :t everywhere
05:09:32 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
05:15:18 <burp> http://hackage.haskell.org/packages/archive/network/2.3/doc/html/src/Network.html#listenOn at least following the src this thing should be dual stack
05:22:13 <rribeiro> :t everywhereM
05:22:14 <lambdabot> forall (m :: * -> *) a. (Data a, Monad m) => GenericM m -> a -> m a
05:22:27 <rribeiro> @src GenericM
05:22:27 <lambdabot> Source not found. Maybe you made a typo?
05:23:17 <zygoloid> @type undefined :: GenericM a
05:23:19 <lambdabot> forall a (a1 :: * -> *). (Data a) => a -> a1 a
05:23:53 <burp> well I will follow your "don't use listenOn" ;)
05:23:59 <zygoloid> @type undefined :: GenericM Maybe
05:24:00 <lambdabot> forall a. (Data a) => a -> Maybe a
05:27:16 <hpc> zygoloid: holy crap, neat trick
05:29:05 <kuffaar> burp cheers
06:08:25 <rribeiro> @src Category
06:08:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:08:45 <kuffaar> Do you want to have the source code of SPJ with that?
06:21:59 <rribeiro> @src Control.Category.Category
06:22:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:22:06 <rribeiro> :t (<<<)
06:22:07 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
06:23:01 <peoro> compared to the other languages I know of, it looks like haskell provides a way bigger number of little standard functions... how can you remember all of them?
06:23:32 <merijn> peoro: Hoogle
06:23:41 <merijn> peoro: You can search by type signature :D
06:23:56 <merijn> I just think of what I want looks like and search for the type signature to go with that
06:24:35 <merijn> Can't remember "map"? Simple...
06:24:49 <merijn> @hoogle (a -> b) -> [a] -> [b]
06:24:49 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:24:50 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
06:24:50 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
06:25:20 <merijn> (Which you can also find at: http://haskell.org/hoogle/)
06:25:29 <sipa> :t Strategy
06:25:30 <lambdabot> Not in scope: data constructor `Strategy'
06:25:34 <sipa> @src Strategy
06:25:34 <lambdabot> Source not found.
06:25:56 <merijn> @src Control.Parallel.Strategies.Strategy
06:25:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:29:04 <Cin> Has anyone made a function for Emacs to go through top-level defitions in a file and add some kind of overlay directly above that definition showing the type?
06:29:40 <Cin> I've for a while stopped writing out explicit and enable -fno-warn-missing-signatures, only writing them when necessary. It's often nice to be able to see the type though. It just so happens that GHCi can tell you trivially.
06:32:16 <Rmx> Hi everybody
06:34:05 <Rmx> I had a question, I'm quite new in the haskell world. I just installed 10.10 Ubuntu, and Haskel platform / leksah / various others librauries
06:34:32 <Rmx> But I can't fint out how to execute some examples that I downloaded from cabal
06:34:49 <Rmx> ig: I did a cabal install elerea-examples
06:35:15 <Rmx> according from hackage, there should be 3 executables such as 'elerea-bounce'
06:35:26 <Rmx> how could I launch them
06:35:31 <merijn> Rmx: They are likely installed somewhere under ~/.cabal
06:35:37 <merijn> ~/.cabal/bin maybe?
06:35:44 <merijn> So you'd want to add that to your path
06:36:05 <Rmx> thx, will  try tat
06:36:10 <Rmx> that*
06:36:15 <Cin> On Windows it would be C:\Documents and Settings\Rmx\, IIRC.
06:36:53 <merijn> Cin: Well, he said Ubuntu, so :p
06:37:00 <Rmx> :)
06:37:40 <Cin> Just putting the information out there, Gary.
06:37:41 <Rmx> perfectly
06:37:47 <Rmx> everything's ok
06:37:57 <Rmx> thanks again
06:37:59 <Rmx> see you
06:38:31 * hackagebot alpino-tools 0.0.4 - Alpino data manipulation tools  http://hackage.haskell.org/package/alpino-tools-0.0.4 (DanielDeKok)
06:43:49 <dankna> hm.  ghc 7.1 changes the layout rule so that you have to actually add indentation, not just "nondecreasing"?
06:44:01 <dankna> I ask because I'm seeing compile errors trying to install network with it
06:45:41 <jmcarthur> you mean ghc 7.0.1?
06:46:03 <dankna> no, I mean the HEAD, which calls itself 7.1
06:46:14 <jmcarthur> okay
06:46:15 * jmcarthur tries it
06:46:49 <jmcarthur> well, i got an error, but it says it need flexible instances, so i doubt it's the same error as you
06:46:59 <dankna> no, I got that one too
06:47:06 <jmcarthur> ah
06:47:27 <dankna> I added FlexibleInstances to the declaration and then I got errors about empty do blocks which inspection of the source revealed were because the code didn't increase the indentation
06:47:33 <jmcarthur> well, i'm not sure if i feel like fiddling with the package right now
06:47:38 <dankna> that's fine
06:47:42 <dankna> are you the maintainer of network?
06:47:49 <jmcarthur> nope
06:47:52 <dankna> oh, okay
06:48:01 <jmcarthur> i was only thinking of verifying your issue for you
06:48:07 <dankna> gotcha, well I appreciate that
06:48:11 <dankna> it's always nice to have a sanity check
06:48:33 <dankna> I can certainly get this working, it's trivial changes as long as I don't misindent anything
06:48:45 <jmcarthur> there may be an extension you can enable/disable
06:48:55 <dankna> yeah hm
06:48:57 <dankna> that's a thought
06:48:59 <jmcarthur> i seem to recall there being one related to this...
06:49:26 <dankna> this is why I'm glad I built the user guide, haha.
06:49:31 <jmcarthur> RelaxedLayout?
06:49:37 <jmcarthur> NoNondecreasingIndentation?
06:50:13 <jmcarthur> i just ran ghc --supported-extensions
06:50:33 <dankna> oh, haha
06:50:41 <dankna> yeah, it's not in the docs yet, but good, thanks
06:51:02 <sipa> ghc: unrecognised flags: --supported-extensions
06:51:02 <jmcarthur> there's also something called [No]AlternativeLayoutRule
06:51:08 <dankna> hrm
06:51:11 <jmcarthur> sipa: this is ghc head
06:51:14 <sipa> ok
06:51:29 <jmcarthur> ghc 7 also supports it
06:51:43 <jmcarthur> ghc 6 does not
06:51:49 <jmcarthur> (i just tried all these)
06:53:37 <dankna> NondecreasingIndentation did the trick
06:53:46 <jmcarthur> good to know
06:53:59 <dankna> yeah
06:55:31 <jmcarthur> edwardk: it occurs to me that speculation could be generalized to n guesses rather than just one guess. might be interesting for large numbers of cores
06:57:39 <jonkri> i'm thinking about putting together a quick small web app to arrange product and sprint/milestone backlogs, backed by a sql database. should i consider haskelldb instead of using sql directly?
06:57:59 <jmcarthur> is haskelldb still maintained?
06:58:14 <jmcarthur> i was under the impression that it was vapor
06:58:25 <jonkri> oh :(
06:58:31 <jmcarthur> ah, nope
06:58:37 <dankna> I don't like object-relational mappings anyway
06:58:37 <jmcarthur> seems there are recent updates to the package
06:58:41 <jmcarthur> jonkri: ignore me
06:58:41 <dankna> hence why I wrote direct-sqlite
06:58:44 <jmcarthur> dankna: it's not OR
06:58:47 <dankna> oh
06:58:48 <sm> jonkri: I think it's worth a look
06:58:53 <dankna> well okay, serves me right for assuming I guess
06:58:56 <jmcarthur> dankna: it's more like LINQ
06:59:05 <dankna> hmm all right
06:59:13 <dankna> that's fine then
06:59:25 <jmcarthur> jonkri: yeah given that it's maintained, it *is* pretty nice
07:00:11 <jmcarthur> object-anything mappings normally suck, but haskell-anything mappings are more flexible and thus often fit better :)
07:01:40 <dankna> this is true
07:01:40 * hackagebot bio 0.5 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.5 (KetilMalde)
07:02:05 <sm> haskelldb can derive haskell types/marshalling code from your db, which I'm not sure other libs can
07:03:01 <jonkri> i really liked mnesia when i was doing erlang
07:30:41 <j-invariant> does anyone have a bf interp in  haskell
07:31:58 <quicksilver> there's one in lambdabot isn't there?
07:32:08 <quuuux> @bf +++.
07:32:08 <lambdabot>  Done.
07:32:16 <quicksilver> http://hackage.haskell.org/package/brainfuck
07:32:20 <quuuux> my brainfuck-fu is weak
07:32:50 * hackagebot Takusen 0.8.7 - Database library with left-fold interface, for PostgreSQL, Oracle, SQLite, ODBC.  http://hackage.haskell.org/package/Takusen-0.8.7 (JasonDagit)
07:33:06 <quicksilver> I wonder what logic means the brainfuck cabal file censors the description but not the package name.
07:33:48 <kuffaar> Takusen :o I still want to write some crazy typesafe SQL bindings for Haskell, but it's probably far above my current skill level
07:33:53 <quicksilver> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
07:33:54 <lambdabot>   Hello World!
07:35:29 <lispy> quicksilver: what do you mean?
07:35:32 <lispy> oh
07:35:35 <kuffaar> :t runReaderT
07:35:36 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
07:35:50 <lispy> quicksilver: nevermind, I get what you mean.  I thought you were referring to the @bf command
07:36:19 <lispy> quicksilver: FWIW, I didn't cabalize it
07:36:52 <lispy> quicksilver: I submitted it as a nekid module to lambdabot way back when.  I wonder if gwern cabalized it.
07:37:25 * lispy finds the status of c.h.o sad/frustrating
07:37:39 <lispy> I really regret putting packages up there
07:37:48 <djahandarie> http://hpaste.org/43326/a Is what I did here "correct"? Also how do I make this proof easier to look at?
07:37:57 <dcoutts> quicksilver: simple, * is not allowed in package names
07:38:09 <lispy> I wish darcs had something equivalent to github.  Their hosting is nice but I don't really want to convert these repos out of darcs.
07:38:13 <quicksilver> lispy: I'm sure gwen cabalized it
07:38:27 <quicksilver> dcoutts: right, but having acknowledged that you might as well not censor the description eitehr.
07:38:40 <dcoutts> quicksilver: true :-)
07:39:08 <quicksilver> lispy: you mean just because it's broken at this moment? there's no current reason to fear data loss, the stuff on it will be recovered.
07:39:13 <dcoutts> lispy: I thought there was darcsden
07:39:15 <quicksilver> not that I don't agree github is clever.
07:39:26 <quicksilver> making it easy for everyone to fork is *very* clever
07:39:33 <quicksilver> obvious, too
07:39:36 <gwern> I cabalized brainfuck
07:39:42 <quicksilver> most clever ideas seem obvious in retrospect ;)
07:39:53 <dcoutts> quicksilver: I don't really get it, it's always been easy to fork, every 'get' is a fork.
07:39:58 <gwern> also, for darcs hosting see patch-tag.com
07:40:09 <dcoutts> gwern: oh yes, that's what I was thinking of
07:40:12 <lispy> quicksilver: I've been having issues with c.h.o before this most recent outage and have already decided that not being able to access code when I have time to hack makes it hard to work on things :)
07:40:21 <quicksilver> dcoutts: ah, but a github fork is publically accessible fork
07:40:31 <quicksilver> dcoutts: if you darcs get you need to then find hosting for it.
07:40:38 <alexsuraci> quicksilver: darcsden has that (one-click forking)
07:40:45 <quicksilver> dcoutts: that's the point - it just reduces the barrier to entry so low that you can fork "just like that"
07:40:47 <dcoutts> lispy: oh agreed, c.h.o is hosted on a woefully underpowered server, hence all the plan to move it to a VM on the new haskell.org machine.
07:40:48 <quicksilver> alexsuraci: excellent.
07:41:23 <dcoutts> quicksilver: but if you want to get the fork, then you still need to get it
07:41:24 <alexsuraci> also has issues and fork queue (confusingly called "patches"), lately
07:41:36 <gwern> quicksilver: I didn't censor the brainfuck package name because I had no idea what consequences there would be if I put in a * or ?
07:42:07 <quicksilver> gwern: I understand why the package name isn't censored. I was just remarking that there is, therefore, not much point censoring the description.
07:42:21 * gwern shrugs. if c.h.o were up I'd uncensor it
07:42:24 <quicksilver> gwern: it was not an important point, and was not worthy of the CRT-inches it has already generated ;)
07:43:41 <gwern> 'Finally… it is somewhat painful to admit, but patch-tag really doesn’t need transactions. I probably could have just used text files and read/show serialization for state. What the heck was I thinking? I can’t even remember anymore.' <-- I do! premature optimization!
07:45:15 <gwern> I wonder if thomas hartman is in SF. we really ought to deal with his gitit fork
07:47:18 <lispy> dcoutts: I feel so very "once bitten, twice shy" about c.h.o.  I may come back to it eventually if it has a good track record after the move.  Either way, I need to do something as a stop gap.
07:47:53 * hackagebot ls-usb 0.1.0.8 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.8 (RoelVanDijk)
07:49:54 * hackagebot usb-id-database 0.4.0.5 - A database of USB identifiers  http://hackage.haskell.org/package/usb-id-database-0.4.0.5 (RoelVanDijk)
07:54:48 <djahandarie> Maybe writing this in LaTeX would make it easier to look at
08:04:58 <sm> lispy: so, tried darcsden ?
08:07:14 <lispy> sm: No.  I tried patch-tag but it's not clear to me if p-t is still actively maintained.  I'm starting to get more and more conservative about my decision due to making bad choices historically.
08:07:45 <lispy> sm: In other words, I'm very hesitant to try darcsden
08:07:49 <sm> I hear you.. there's no substitute for keeping a fairly fresh local copy in case of outage
08:08:23 <sm> but I do like darcsden and its hacker is quite available
08:09:00 <aisamu> Hello! 
08:09:35 <aisamu> (no questions today for a change, heh)
08:13:45 <lispy> sm: good to know.
08:23:12 <EdH> Hi :)
08:24:36 <byorgey> hi EdH 
08:24:55 <EdH> Hey byorgey
08:25:22 <EdH> Sorry to bother you all, but I'm a newbie with an error. And it's not going away :P
08:26:50 <fryguybob> EdH: No bother, just describe your problem.
08:27:06 <Cin> @hoogle (Applicative f) => f a -> f a1 -> f (a, a1)
08:27:06 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
08:27:07 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
08:27:07 <lambdabot> Language.Haskell.TH strictType :: Q Strict -> TypeQ -> StrictTypeQ
08:27:15 <Cin> @pl \x y -> (,) <$> x <*> y
08:27:15 <lambdabot> (((,) <$>) .) . (<*>)
08:27:24 <Cin> @pl \f x y -> f <$> x <*> y
08:27:24 <lambdabot> (. (<*>)) . (.) . (<$>)
08:27:29 <Cin> @_@
08:27:34 <quicksilver> liftA2 (,)
08:27:37 <quicksilver> if you prefer that form.
08:27:49 <Cin> Oh, duh.
08:28:06 <Cin> Thanks. Brainfart. :-)
08:28:09 <quicksilver> :)
08:28:37 <mun_> if i have a FOL axiom like forall x y. foo x < foo y --> bar (foo x) = bar (foo y). is it consistent? the antecedent doesn't seem quite right though, because if x is equal to y, then foo x has to be foo y?
08:30:05 <EdH> building a sudoku solver for my uni course. I'm generating three lists of available numbers for a given cell (horizontally, vertically and in the local box), then using intersect to get the allowable values. those methods are tested and seem to work fine, but when I try to use them in a function to check a cell, I get an error *goes to copy-paste*
08:30:06 * hackagebot filestore 0.4.0.2 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.4.0.2 (JohnMacFarlane)
08:30:35 <EdH> \scripts.hs:21 - Type error in application *** Expression     : combineLists hList vList bList *** Term           : bList *** Type           : Int *** Does not match : [a]
08:30:45 <mightybyte> Does parsec have any machinery for unifying "hierarchical" parsing patters?
08:31:45 <mightybyte> By that I mean things like run one parser, get the result, run another parser on that result, get more results, run another parser on those, etc...
08:32:35 <byorgey> EdH: can you paste the entire scripts.hs on hpaste.org?
08:32:47 <byorgey> EdH: for some reason bList is an Int, but it is supposed to be a list
08:33:24 <EdH> that's what I thought, but running it individually returns a list. I've got it on mediafire, will upload to hpaste
08:34:13 <EdH> http://hpaste.org/43327/sudoku_solver_type_error
08:36:36 <quicksilver> EdH: you do not want to do "bList <- makeBList grid index"
08:36:48 <quicksilver> you simply want to do "let bList = makeBList grid index"
08:36:54 <EdH> oh righto
08:37:00 <quicksilver> same correction for all for uses of <-
08:37:07 <quicksilver> those are all simple functions
08:37:07 <EdH> I had that before but I think I changed it before that error came up
08:37:09 <EdH> cheers :)
08:37:17 <quicksilver> they do not use IO, they don't need the special <- notation
08:38:07 <EdH> okay, altered that.
08:38:24 <quicksilver> EdH: similarly, 'remove' and 'replaceAt' really shouldn't be using do, let and return.
08:39:26 <EdH> what would be a better way?
08:40:27 <quicksilver> EdH: well, for "remove" this would be better : let newListTuples = splitAt index list in ((fst newListTuples) ++ tail (snd newListTuples))
08:40:42 <Palmik> Hi guys, what do you use for integer square root computation? I have used floor . sqrt . fromIntegral before, but it seems to be highly inaccurate... consider it used on  12345678901234567890123456789012345678901234567890, the result will be 3513641828820144053288960 but 3513641828820144253111222 is much more accurate
08:41:21 <quicksilver> EdH: ...and even that would be more concisely written as "let (before,after) = splitAt index list in before ++ tail after
08:41:40 <quicksilver> Palmik: that's using floating point maths so it's limited to the precision of Double
08:41:55 <Palmik> ah, you are right :)
08:42:00 <quicksilver> Palmik: better would be to write a real integer square root; there isn't one in the standard lib
08:42:05 <quicksilver> although there must be several on hackage.
08:43:03 <quicksilver> it's easy to write a bad one (e.g. binary chop); I'm sure googling will come up with a better algorithm.
08:43:14 <Palmik> I have written one in c++ for my "integer of arbitrary length" type and I just wanted to compare the results with haskell :)
08:43:45 <byorgey> writing one based on Newton's method is fairly easy
08:43:57 <EdH> what exactly does the "list in" bit do? I'm having a bit of trouble wrapping my head around it :(
08:44:31 <byorgey> 'in' is syntax, it's part of the  let ... in ...
08:44:47 <byorgey> let  (newListTuples = splitAt index list)  in  ((fst ... ) ... )
08:45:28 <EdH> oh right, I kinda get it now
08:45:29 <byorgey> it creates a local definition for newListTuples which can be used in the expression after the 'in'
08:45:32 <EdH> ...ish :P
08:45:34 <EdH> gotcha :)
08:45:37 <byorgey> > let x = 3 in x + x
08:45:38 <lambdabot>   6
08:45:47 <quicksilver> > let x = 3 in "x is " ++ show x
08:45:50 <lambdabot>   "x is 3"
08:46:07 <EdH> well, that's a handy one :P
08:46:39 <roconnor> does system F have fix?
08:46:58 <byorgey> roconnor: no
08:47:06 <roconnor> good
08:47:32 <dafis> did that win you a bet?
08:48:02 <roconnor> fix is evil
08:48:08 <dafis> why?
08:48:31 <dafis> (no dissent, just curious)
08:48:34 <roconnor> because it can be used to make inhabitants of any  type
08:48:46 <j-invariant> System F is strongly normalization
08:49:13 <lunaris> fix is tame.
08:49:13 <dafis> roconnor:  isn't bottom already an inhabitant of all types?
08:49:17 <lunaris> :t fix . fix
08:49:18 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
08:49:21 <lunaris> That's evil.
08:49:25 <jacobian> > fmap (1+) (2,3) 
08:49:26 <lambdabot>   (2,4)
08:49:32 <jacobian> That surprises me
08:49:38 <roconnor> dafis: my question about fix was a question about bottom in disguse
08:49:49 <lunaris> jacobian: It's the way it has to be right?
08:49:59 <byorgey> dafis: bottom exists in Haskell because Haskell has fix.
08:50:07 <lunaris> jacobian: (,) on its own is a bifunctor though (I hope)
08:50:09 <lunaris> :t bimap
08:50:09 <quicksilver> > fmap (1+) ('a',3)
08:50:11 <lambdabot> Not in scope: `bimap'
08:50:11 <lambdabot>   ('a',4)
08:50:16 <dafis> byorgey:  not the other way round?
08:50:23 <quicksilver> jacobian: haskell only lets you partiall apply type constructors one way
08:50:25 <EdH> okay, remove and replaceAt are more elegant now. however, I'm still getting the "Instance of RealFrac Int required for definition of checkCell"
08:50:30 <byorgey> dafis: no, you could have bottom without fix
08:50:33 <quicksilver> jacobian: so we don't have any choice about which way to make (,) a functor.
08:50:42 <byorgey> dafis: but once you have bottom you might as well add fix =)
08:51:01 <dafis> byorgey:  but bottom is a necessary condition for fix, isn't it?
08:51:13 <quicksilver> EdH: check out the types of your make*List functions
08:51:18 <quicksilver> EdH: (and tell us what it says)
08:51:42 <quicksilver> on the other hand, unrestricted recursion is pretty handy.
08:51:51 <byorgey> dafis: well, not really.
08:52:10 <jacobian> Without unrestricted recursion, you'd slow things down development time a lot. 
08:52:25 <EdH> makeHList :: (RealFrac a, Ord b, Num b, Enum b) => [b] -> a -> [b]
08:52:34 <roconnor> jacobian: isn't that what other people say about types?
08:52:34 <byorgey> dafis: for example, Coq and Agda have fixpoints but only allow taking fixpoints of certain functions, to ensure termination and hence rule out bottom
08:52:40 <EdH> makeVList :: (Ord a, Num a, Enum a) => [a] -> Int -> [a]
08:52:55 <EdH> makeBList :: (RealFrac a, Ord b, Num b, Enum b) => [b] -> a -> [b]
08:53:03 <jacobian> roconnor: maybe it's not a necessary condition for all time, but you probably wouldn't disagree that it's true presently. 
08:53:05 <quicksilver> EdH: so, the point is, that makeHList forces 'Cell' (its second parameter) to be RealFrac.
08:53:11 <quicksilver> EdH: (and makeBList does the same)
08:53:24 <quicksilver> EdH: this is because you do "cell/9"
08:53:33 <EdH> oh, okay
08:53:35 <jacobian> Types don't cost me much extra in devel time.  Trying to prove everything I write is total does. 
08:53:35 <quicksilver> EdH: and '/' is an operator on RealFrac types
08:53:42 <lunaris> Isn't (/) a member of Fractional?
08:53:44 <EdH> change to div?
08:53:51 <quicksilver> change to div sounds good
08:53:54 <roconnor> jacobian: Depends on how much type you spend chasing down non-termination bugs I guess.
08:53:58 <quicksilver> as long as you're happy with integer division.
08:54:06 <quicksilver> :t (/)
08:54:07 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:54:08 <jacobian> A lot... 
08:54:15 <j-invariant> roconnor: In this case its actaully true :P
08:54:17 <j-invariant> 17:03 < jacobian> Without unrestricted recursion, you'd slow things down  development time a lot. 
08:54:20 <j-invariant> 17:03 < EdH> makeHList :: (RealFrac a, Ord b, Num b, Enum b) => [b] -> a -> [b]
08:54:23 <j-invariant> 17:03 < roconnor> jacobian: isn't that what other people say about types?
08:54:36 <EdH> well, it's all getting floored back to integer again anyway, so I'm just peachy with integer division
08:54:38 <lunaris> RealFrac has things like floor, truncate, etc.
08:54:43 <j-invariant> It's because the existing systems are babies
08:54:53 <j-invariant> they don't have features for programming yet
08:54:56 <quicksilver> lunaris: right. yes. It's floor that forces it to RealFrac instead of Fractional.
08:54:58 <roconnor> if you spend a lot of time chasing down non-termination bugs, then you might save time by proving termination upfront
08:55:21 <quicksilver> anyhow, if EdH replaces floor(cell/9) with (cell `div` 9) this particular problem goes away.
08:55:26 <jacobian> I've tried my current project both ways. 
08:55:40 <jacobian> I intend to do it in Coq after the haskell version is complete, which is soon. 
08:55:55 <jacobian> However, I previously attempted it in Coq, and it took quite a lot longer. 
08:56:08 <jacobian> perhaps a factor of 3-5 times longer to get the same amount of work done. 
08:56:34 <warrenharris> hi all - is there any sort of wait or takeMVar with timeout in haskell (like java's wait/notify)?
08:56:36 <jacobian> Could just be that I'm thick :) 
08:56:59 <quicksilver> warrenharris: no, but you can wait yourself in another thread and use an async exception
08:57:07 <quuuux> warrenharris: look at System.Timeout
08:57:08 <quicksilver> warrenharris: (or use the timeout package on hackage which does the same thing)
08:57:18 <roconnor> jacobian: is that 3-5x figure just to write your functions in Coq, or to also prove properties about your functions?
08:57:20 <quicksilver> oh.
08:57:23 <quicksilver> timeout is in base ;)
08:57:24 <EdH> I'm still getting the error
08:57:28 <quicksilver> ignore the bit about hackage.
08:57:33 <jacobian> roconnor: Good point :) 
08:57:36 <quicksilver> EdH: can you paste your lasted code version, I've got a bit lost
08:57:44 <EdH> sure :)
08:57:44 <warrenharris> quicksilver: I'll take a look - thanks
08:57:46 <jacobian> Usually those things are closely related though, since I need properties to prove termination. 
08:57:49 <tibbe_> warrenharris: if you want to get hardcore you can use System.Event in GHC 7, but that's really hardcore
08:58:01 <roconnor> jacobian: I typically estimate 10x factor to prove correctness :)
08:58:02 <tibbe_> warrenharris: I'm working on supporting timeouts in the next version of network
08:58:10 <lunaris> The legend of the timeout is way hardcore.
08:58:18 <warrenharris> tibbe_: cool
08:58:25 <roconnor> jacobian: I'm not sure how often properties are needed to prove terminations.
08:58:38 <tibbe_> warrenharris: that's the semipublic (GHC only) API of the new I/O manager
08:59:13 <jacobian> Maybe it's a peculiarity of the problem space.  I'm writing a supercompiler. 
08:59:14 <tibbe_> warrenharris: System.Timeout does use that underneath by raising a thread that sleeps for n microseconds and then kills the current computation and returns Nothing.
08:59:37 <EdH> annotated it onto the hpaste file http://hpaste.org/paste/43327/sudoku_solver_type_error_late#p43329
08:59:50 <tac-tics> Who proves the proof of correctness is correct?
08:59:57 <dixie> hmmm, does this work for anybody ? I'm beginer and can not figure out what is wrong with "flip" here
09:00:00 <dixie> http://tutorial.happstack.com/src/StateTExample.hs
09:00:08 <warrenharris> tibbe_: I'm trying to run something on a timer, but I want the ability to shut it down promptly (hence the need for notify)
09:00:11 <dixie> ops, no flip... but lift 
09:01:09 <tibbe_> warrenharris: CPU or I/O?
09:01:29 <warrenharris> IO - trying to flush bdb transactions
09:01:54 <quicksilver> EdH: you must have missed my further comments, you need to drop the "floor" as well
09:02:04 <quicksilver> EdH: (it's not logically necessary with all the divs anyway)
09:02:08 <quicksilver> :t floor
09:02:09 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:02:14 <EdH> I literally just noticed that and started - sorry about that
09:02:18 <quicksilver> it's fine ;)
09:02:34 <roconnor> tac-tics: we are working on that.  However when errors are found we can fix them and recheck all proofs with little effort.
09:03:09 <eden> Hi. I'm looking for a list of all legal operator characters. I've found a few lists already, but they are all different. I;ve also found the isSymbol function, but don't know if that would do the trick. Any clues?  
09:03:16 * hackagebot TrieMap 2.0.0 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-2.0.0 (LouisWasserman)
09:03:31 <EdH> VICTORY
09:03:36 <j-invariant> type theory doesn't support equational reasoning unless you use the idiot type
09:03:41 <jdavis> I see that the GHC.IOBase module is deprecated in favor of IO. But IO doesn't appear to have a "bindIO" function, what's the equivalent function in IO?
09:03:51 <j-invariant> which is almost never useful in real programs
09:04:11 <quicksilver> EdH: yay :)
09:04:22 <quicksilver> eden: tried the haskell report?
09:04:29 <djahandarie> It'd be nice if we had an HTML DSL that encoded some of the HTML rules in the types
09:04:34 <EdH> I give it maybe five minutes until I break something else and come back moaning again :P
09:04:44 <j-invariant> so you have to make your own equational reasoning system to do proofs, but that's just the start. Expect to take 20 to 30 years writing a tools just to write you program
09:05:55 * quuuux doesn't know whether to love or hate the epiphany when you realise the complicated data structure manipulation you've been wrangling with for the past hour is just a list with concatMap
09:06:31 <j-invariant> love
09:06:41 <eden> quicksilver: Yeah, it says that ascSymbol and uniSymbol are permitted, but doesn't say what how you test for a uniSymbol. Which isn't very helpful.
09:07:01 <quicksilver> eden: ah, well that's a secret :)
09:07:12 <quicksilver> it's based on some unicode property but I don't remember what
09:07:18 <quicksilver> last time I wanted to know, I checked the GHC source
09:08:16 <eden> yikes
09:09:44 <quicksilver> eden: I think it's probably "isSymbol", plus exceptions.
09:09:52 <quicksilver> or, rather, minus exceptions.
09:09:58 <quicksilver> and all the exceptions are in the ASCII region.
09:10:08 <quicksilver> (e.g. [], |, comma, semicolon, etc)
09:11:21 <tibbe_> warrenharris: and if they don't flush in time you want to kill out some socket opertation?
09:12:05 <eden> Like I say, I found isSymbol, and thought that might get most of the way. I guess finding a list of exceptions is the next thing to try.
09:12:35 <warrenharris> tibbe_: no... I just want to call something every 15 sec or so on an os thread, but when it's time to shut down, I don't want to wait 15 sec for the timer thread to wake up
09:12:44 <EdH> PC broke
09:12:45 <EdH> :P
09:13:10 <quicksilver> eden: I think the exceptions can be derived from the report
09:13:15 <tibbe_> warrenharris: I see
09:13:28 <tibbe_> warrenharris: System.Timeout seems about right then
09:13:57 <quicksilver> eden: isSymbol if ord is over 127, for ords under 127 use the ascSylmbol definition from the report
09:14:04 <djahandarie> nlab is so cool
09:14:13 <warrenharris> tibbe_: ok... btw what's so hardcore about System.Event?
09:14:26 <eden> I'm writing a comment remover for an auto-indent function in Yi, so I need to be careful about operators that start with "--"
09:16:04 <tibbe_> warrenharris: it's new and not fully publically supported
09:16:11 <warrenharris> I see
09:16:13 <tibbe_> warrenharris: but it should be easy to use
09:16:22 <eden> what about exactly 127? I seem to remember that being delete, so this probably doens't matter.
09:16:37 <warrenharris> I'm still on 6.12.3 actually
09:17:15 <quicksilver> eden: yes it doesn't matter, but technically it's ASCII, so it would be in ascSymbol if it was a symbol which it isn't...
09:18:03 <bgamari> How would one use both Data.Binary.Get and Put in the same monad?
09:18:10 <bgamari> Does this require monad transformers?
09:19:35 <eden> Either way, thanks. It'll do for testing purposes, and I don't recall ever seeing an operator that uses unicode. You know, just trying to be complete...
09:20:07 <copumpkin> bgamari: yeah, but unfortunately I don't think anyone's written the transformers you need
09:20:17 <bgamari> hmm
09:20:18 <bgamari> ouch
09:20:22 * hackagebot TrieMap 2.0.1 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-2.0.1 (LouisWasserman)
09:20:24 <bgamari> that's a bit of a dealbreaker
09:20:44 <bgamari> copumpkin: Considering I'm just starting to wrap my head around monads, I suspect it's well above my abilities
09:21:55 <Silvah> > (fix . fix) (\a b c -> c)
09:21:56 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
09:21:56 <lambdabot>    arising from a use of `...
09:22:18 <Silvah> @hoogle fix
09:22:18 <lambdabot> Data.Function fix :: (a -> a) -> a
09:22:18 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
09:22:18 <lambdabot> module Control.Monad.Fix
09:22:20 <roconnor> can I quantify over type constructors in system F?
09:22:22 <bgamari> copumpkin: Any suggestions in this case?
09:23:12 <Saizan> roconnor: in F_omega
09:23:19 <roconnor> damn
09:23:43 <roconnor> you are right
09:24:30 <roconnor> Atkey's fromalization of system F in Coq isn't strong enough for me.
09:25:01 <roconnor> I don't suppose anyone knows of a formalization of F_omega that allows one to reason about parametricity?
09:25:03 <Silvah> > fix . fix $ ($)
09:25:18 <lambdabot>   thread killed
09:25:18 <aristid> :t fix . fix
09:25:19 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
09:25:36 <Silvah> Poor thread :(
09:25:51 <aristid> Silvah: holy shit, i don't know what could be put into fix . fix
09:26:48 <c_wraith> I don't think functions have a non-bottom least fixed point
09:26:58 <c_wraith> though that's just intuition
09:27:01 <mun_> if i have a FOL axiom like "forall x y. foo x < foo y --> bar (foo x) > bar (foo y)". is it consistent? the antecedent doesn't seem quite right though, because if x is equal to y, then foo x has to be equal to foo y, but bar (foo x) > bar (foo x) would be false?
09:27:01 <jmcarthur> not in haskell anyway
09:27:19 <djahandarie> > fix . fix $ (const 5)
09:27:21 <lambdabot>   5
09:27:27 <jmcarthur> a more lax evaluation order could probably find one for some functions
09:27:28 <jmcarthur> okay
09:27:32 <jmcarthur> for some *more* functions then :)
09:27:48 <c_wraith> ok.  const can take anything crazy as input. :)
09:28:41 <djahandarie> NB: only works in lambdabot ;)
09:28:44 * djahandarie goes to class
09:31:14 <Saizan> > fix . fix $ \ f x -> 1 : f x
09:31:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:31:31 <c_wraith> interesting
09:39:35 <j-invariant> http://arxiv.org/abs/1101.3764 CHeck this OUT
09:39:43 <j-invariant> The model is expressed using a monadic metalanguage built on top of a universal reversible language for finite computations, and hence is directly implementable in a language like Haskell
09:40:47 <jmcarthur> what is it? i can't check the link yet because i'm running some benchmarks and don't want to launch a browser
09:41:00 <roconnor> jmcarthur: Quantum Computing over Finite Fields
09:41:25 <jmcarthur> wasn't there already a "quantum monad" in haskell out there somewhere?
09:41:50 <roconnor> now there are finite fields
09:42:01 <bgamari> Are there any haskell.org admins around?
09:42:09 <bgamari> It seems that All About Monads is down
09:52:09 <HaudRex> What's an easy way to get the occurs check to trigger?
09:53:36 <fryguybob> @type \a -> a : a
09:53:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
09:53:38 <lambdabot>       Expected type: [a]
09:53:38 <lambdabot>       Inferred type: a
09:54:34 * hackagebot partial-isomorphisms 0.1 - Partial isomorphisms.  http://hackage.haskell.org/package/partial-isomorphisms-0.1 (TillmannRendel)
09:55:55 <HaudRex> fryguybob: wait, what is the type "a" there?
09:56:02 <HaudRex> forall a. a? 
09:56:56 <jmcarthur> HaudRex: as written it's an infinitely deep nested list, which is why it's a type error
09:57:15 <jmcarthur> haskell doesn't allow infinite types
09:57:44 <HaudRex> @type a
09:57:45 <lambdabot> Expr
09:57:49 <HaudRex> I see
09:58:01 <jmcarthur> well, the thing named "a" in lambdabot is not the same thing
09:58:07 <engla> that type is useless anyway (infinitely nested list)
09:58:14 <HaudRex> @type a : a
09:58:14 <jmcarthur> engla: not necessarily
09:58:15 <lambdabot>     Couldn't match expected type `[Expr]' against inferred type `Expr'
09:58:15 <lambdabot>     In the second argument of `(:)', namely `a'
09:58:15 <lambdabot>     In the expression: a : a
09:58:23 <jmcarthur> engla: it's essentially the unwrapped type of a rose tree
09:58:37 <HaudRex> Oh hang on. Never mind, I was reading the : as ::
09:58:44 <jmcarthur> well, except this is with the values at the leaves i guess
09:58:48 <engla> jmcarthur: I don't see what that is but the infinitely nested list is a singleton
09:58:50 <fryguybob> HaudRex: ah that would be confusing.
09:58:56 <jmcarthur> if it's a lazy tree then it could still be useful structurally
09:59:05 <zygoloid> engla: what about [[[],[],[]],[]] ?
09:59:06 <jmcarthur> engla: huh?
09:59:11 <engla> jmcarthur: it's just [[[[[...
09:59:14 <jmcarthur> engla: no it's not
09:59:19 <jmcarthur> engla: [] is a valid value, for example
09:59:26 <jmcarthur> engla: or lists of empty lists, etc.
09:59:34 <zygoloid> it's a pretty interesting structure
09:59:54 <engla> hm now I see what you mean
10:00:01 <mikeg> I'm using the stm package to share one list with one writer and many readers, but all I need is readTVarIO and writeTVar... is there a better concurrency choice? MVar's?
10:00:02 <engla> it's akin to a set construction of the natural numbers
10:00:14 <zygoloid> it's a richer structure than that, but yeah
10:00:16 <engla> (that I once saw)
10:00:26 <jmcarthur> that would be [()]
10:00:31 <jmcarthur> this does even more
10:00:59 <zygoloid> it's the type of arbitrary treelike shapes
10:00:59 <jmcarthur> oh, [()] isn't the set construction i think you mean, actually
10:01:10 <jmcarthur> but still, what zygoloid said
10:02:14 <HaudRex> @type \a -> maybe Just a (Just a)
10:02:14 <lambdabot>     Occurs check: cannot construct the infinite type:
10:02:15 <lambdabot>       a = a -> a1 -> Maybe a1
10:02:15 <lambdabot>     Probable cause: `a' is applied to too few arguments
10:02:34 <engla> heh I wasn't completely convinced when I said it was useless. but it's a good strategy to find out (if you're wrong the channel will yell at you ;-)
10:03:02 <fryguybob> @type fix Just -- HaudRex 
10:03:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
10:03:03 <lambdabot>       Expected type: a
10:03:03 <lambdabot>       Inferred type: Maybe a
10:03:14 <zygoloid> data RoseList a e = Nil e | Cons a (RoseList a e); data RoseTree e = RoseTree (RoseList (RoseTree e) e)
10:03:32 <HaudRex> Yeah, just looking for a term I can actually express in my term language at this point :)
10:03:37 <lcfrs> can anyone recommend some good async-io haskell projects? (more for learning than production.)
10:04:54 <HaudRex> data RoseTree e = RoseTree (Cofree [] e)
10:04:57 <fryguybob> @type \f -> f f
10:04:58 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:04:58 <lambdabot>     Probable cause: `f' is applied to too many arguments
10:04:59 <lambdabot>     In the expression: f f
10:05:11 <HaudRex> oh of course
10:06:00 <lowasser> With Cabal, what's up with package-depends with respect to haskell2010 and base?
10:06:22 <dcoutts> lowasser: hmm? what do you mean?
10:06:56 <lowasser> oh, I think I figured it out, separate issue
10:07:32 <lowasser> it was vaguely complaining about base and haskell2010 in build-depends, but apparently I needed to move that whole field to the Library{...} section of the .cabal anyway
10:07:37 * hackagebot invertible-syntax 0.1 - Invertible syntax descriptions for both parsing and pretty printing.  http://hackage.haskell.org/package/invertible-syntax-0.1 (TillmannRendel)
10:08:03 <lowasser> and it was just that it complained about the Prelude first
10:08:22 <dcoutts> lowasser: ah ok, yes, the build-depends field lives in the library/executable sections
10:08:58 <lowasser> and I vaguely remembered some discussion of haskell2010 versus base so I assumed that was the cause ::sigh::
10:10:39 * hackagebot TrieMap 2.0.2 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-2.0.2 (LouisWasserman)
10:10:41 * hackagebot functor-apply 0.9.1 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.9.1 (EdwardKmett)
10:10:58 <rribeiro> :t everywhereM
10:11:00 <lambdabot> forall (m :: * -> *) a. (Data a, Monad m) => GenericM m -> a -> m a
10:12:21 <lowasser> oooh, functor-apply looks *interesting*
10:12:57 <lowasser> I am intrigued
10:13:11 <colinhect> Is there a way to define an instance of a class for a class rather than a type?
10:13:17 <lowasser> colinhect: no.
10:14:01 <colinhect> okay
10:34:32 <alpounet> colinhect, however, you can write : instance C a => Foo a where [...]
10:34:49 <alpounet> so that any type being an instance of C will be an instance of Foo
10:34:52 <colinhect> I thought I tried that
10:34:59 <colinhect> let me try
10:35:47 <zygoloid> be warned, that actually means that every type is an instance ofoo
10:35:50 * hackagebot gitit 0.7.3.10 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.10 (JohnMacFarlane)
10:36:08 <colinhect> Does that required extension XFlexableInstaces?
10:36:17 <colinhect> require*
10:36:31 <zygoloid> yes, and probably others
10:36:56 <colinhect> ok.. that explains it
10:37:15 <colinhect> thanks.. this will get rid of duplicate code
10:37:55 <alpounet> colinhect, see http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-class-extensions.html for more details
10:38:42 <colinhect> Perfect thanks
10:39:07 <colinhect> That type classes was partial authored by one of my CS professors (Jones)
10:39:18 <colinhect> partially*
10:40:41 <zygoloid> colinhect: that instance almost certainly doesn't do what you want
10:41:23 <colinhect> in that case I almost certainly don't want to do it
10:41:28 <zygoloid> :) do you want any other instances of Foo?
10:41:40 <colinhect> Foo is Num
10:41:56 <zygoloid> oh. then you'll get overlap issues with that instance
10:42:09 <colinhect> Maybe there is a better approach...
10:42:16 <alpounet> colinhect, what would 'C' be here in your case ?
10:42:32 <colinhect> I have a Vector class that has functions like vzip, vmap, vfold, etc.... 
10:42:41 <colinhect> The instances of Vector are Vector2, Vector3, etc
10:43:20 <colinhect> Since the arithmetic operators are defined in terms of vzip/vmap then my instances of Num are identical for each Vector instance
10:43:31 <zygoloid> i don't know any way to express that conciesly without using TH or CPP
10:45:48 <colinhect> hmm
10:45:57 <Arney> wtf is the data type of (floor ((x/y^2)*10^6)/10^6)
10:46:13 <Arney> this is popping my sensitive nurons
10:46:17 <alpounet> :t (floor (x/y^2)*10^6)/10^6
10:46:19 <lambdabot>     No instance for (RealFrac Expr)
10:46:19 <lambdabot>       arising from a use of `floor' at <interactive>:1:1-13
10:46:19 <lambdabot>     Possible fix: add an instance declaration for (RealFrac Expr)
10:46:37 <Arney> what in the world does that mean?
10:46:54 <Arney> I just want to get a decimal in a non scientific notation
10:47:00 <Arney> is that too much to ask.
10:47:15 <alpounet> oh, x and y are doubles i guess
10:47:20 <Arney> yes.
10:47:30 <ion> That message’s just a side-effect of lambdabot having special definitions of single-letter bindings.
10:47:33 <Arney> inverse square finder
10:47:34 <ion> :t x
10:47:35 <lambdabot> Expr
10:47:48 <alpounet> :t let { x = 1 ; y = 2 } in (floor (x/y^2)*10^6)/10^6
10:47:49 <lambdabot> forall b. (Integral b, Fractional b) => b
10:48:17 <Arney> what does => mean?
10:48:49 <alpounet> it basically says that it can has any type being an instance of Integral and Fractional
10:48:55 <zygoloid> @type \x y -> (floor ((x/y^2)*10^6)/10^6)
10:48:57 <lambdabot> forall a b. (RealFrac a, Integral b, Fractional b) => a -> a -> b
10:49:05 <alpounet> @instances Integral
10:49:06 <lambdabot> Int, Integer
10:49:14 <aavogt> > fromIntegral (floor $ pi*10^6) / 10^6
10:49:15 <lambdabot>   3.141592
10:49:15 <Zao> Arney: Delimits the class quantifications of the forall from the normal signature, or so.
10:49:45 <Arney> cool I guess.
10:49:53 <Arney> Ill play with that.
10:49:57 <Arney> Thank you.
10:50:37 <alpounet> Arney, you probably want to read this: http://www.haskell.org/haskellwiki/Converting_numbers
10:51:37 <zygoloid> Arney: floor produces some type of integer. haskell doesn't let you divide integers by 10^6. so that code is rejected.
10:52:23 <zygoloid> (specifically, floor produces a type in class Integral, and (/) requires a type in class Fractional, and there are no built-in types which are both)
10:52:44 <aavogt> you can make some types that are both
10:53:14 <zygoloid> is there a good reason that floor produces Integral rather than Num?
10:53:36 * zygoloid usually wants a floating-point result
10:54:20 <aavogt> @type fromIntegral . floor
10:54:21 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
10:54:48 <ion> The definition of floor might as well be fromIntegral whatever-it’s-now.
10:57:23 <ion> The type seems to be a side effect of returning fst . properFraction (for positive numbers).
10:58:23 <aavogt> well Integral does more than Num
10:58:31 <aavogt> @src Integral
10:58:31 <lambdabot> class  (Real a, Enum a) => Integral a  where
10:58:31 <lambdabot>     quot, rem, div, mod :: a -> a -> a
10:58:32 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:01:51 <zygoloid> aavogt: if floor could produce any Num, it could still produce any Integral.
11:05:16 <SirFrancisDrake> hello there.
11:05:28 <mauke> greetings, SirFrancisDrake
11:07:00 * hackagebot TrieMap 2.0.3 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-2.0.3 (LouisWasserman)
11:07:09 <EdH> and here we go! a new problem arises :P
11:08:03 <brooksbp> http://www.intel.com
11:08:37 <EdH> Type error in conditional *** Expression     : if length results == 1 then do {...} else return (checkAll grid cell) *** Term           : return (checkAll grid cell) *** Type           : a Bool *** Does not match : [Int -> Bool]
11:09:45 <Botje> what's the type of checkAll?
11:09:47 <mauke> cool story, bro
11:10:11 <EdH> should be Bool
11:10:19 * mauke bets it's something like checkAll :: _a -> _b -> Bool
11:10:28 <EdH> one sec
11:10:40 <mauke> EdH: if it was Bool, 「checkAll grid」 wouldn't typecheck
11:11:36 <SirFrancisDrake> is there a smart way to count occurence of each of the symbols in a string? I tried a blunt way, but insidious type conversions Int -> Integer -> Float and such puzzle me and don't seem to work.
11:12:02 <mauke> I don't see how you could get Float in there
11:12:07 <Botje> map (head &&& length) . group . sort
11:12:24 <mauke> or a foldl with a map
11:12:47 <byorgey> > foldl (M.insertWith (+)
11:12:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:12:49 <SirFrancisDrake> how do I represent fractional occurences, if not with Float?
11:13:06 <byorgey> > foldl' (M.insertWith (+)) M.empty "hello there"
11:13:07 <lambdabot>   Occurs check: cannot construct the infinite type:
11:13:08 <lambdabot>    a = Data.Map.Map a b -...
11:13:29 <mauke> SirFrancisDrake: what's a fractional occurrence?
11:13:35 <byorgey> > foldl' (flip $ M.insertWith (+)) M.empty "hello there"
11:13:36 <lambdabot>   Occurs check: cannot construct the infinite type:
11:13:36 <lambdabot>    a = Data.Map.Map k a -...
11:13:37 <mauke> :t M.insertWith
11:13:38 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
11:14:02 <byorgey> oh, duh
11:14:05 <mauke> :t foldl' (\z x -> M.insertWith (+) x 0 z) M.empty
11:14:05 <lambdabot> forall b a. (Num a, Ord b) => [b] -> M.Map b a
11:14:17 <mauke> actually, 1
11:14:23 <byorgey> yes, 1 would help ;)
11:14:26 <Diavol> hi
11:14:29 <byorgey> yours is still better than mine
11:14:36 <byorgey> hi Diavol 
11:15:01 <SirFrancisDrake> >let xs = "aabcdde" in map (\x -> (head x, (length x) / length xs)) $ group . sort xs
11:15:04 <Diavol> i need a bit help, but i must to say that i am newby to haskel
11:15:07 <Diavol> diavol@DiavolPC:~/Dropbox/hbot$ ghc --make main.hs -o bot
11:15:07 <Diavol> main.hs:1:7:
11:15:07 <Diavol>     Could not find module `Network':
11:15:07 <Diavol>       Use -v to see a list of the files searched for.
11:15:09 <SirFrancisDrake> > let xs = "aabcdde" in map (\x -> (head x, (length x) / length xs)) $ group . sort xs
11:15:10 <lambdabot>   Couldn't match expected type `[a]'
11:15:10 <lambdabot>         against inferred type `GHC.Types...
11:15:12 <Diavol> what can i do?
11:15:25 <byorgey> Diavol: install the Haskell Platform
11:15:38 <byorgey> @where platform
11:15:38 <lambdabot> http://hackage.haskell.org/platform/
11:15:52 <byorgey> it comes with lots of standard libraries (like network) and tools
11:15:59 <mauke> SirFrancisDrake: why do you want to divide by length xs?
11:16:36 <lowasser1> > let xs = "aabcdde" in map (\x -> (head x, (length x) % length xs)) $ group $ sort xs
11:16:38 <lambdabot>   [('a',2 % 7),('b',1 % 7),('c',1 % 7),('d',2 % 7),('e',1 % 7)]
11:16:42 <Diavol> how do i do that om ubuntu? i didn find some package for that, thould i compile it from sourse
11:16:45 <Botje> SirFrancisDrake: the magic word is fromIntegral and genericLength
11:16:59 <Diavol> should*
11:17:06 <Botje> Diavol: haskell-platform is in my package repository
11:17:07 <lowasser1> or just use Data.Ratio ;)
11:17:39 <byorgey> Diavol: what version of ubuntu?
11:17:46 <mauke> > let xs = "aabcdde" in map (\x -> (head x, fromIntegral (length x) / length xs)) . group . sort $ xs :: [(Char, Rational)]
11:17:47 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio
11:17:47 <lambdabot>                               ...
11:17:52 <SirFrancisDrake> mauke: I want fractional answers. With total sum of 1. Not sure I really need them, but still.
11:17:56 <Diavol> hmm
11:17:59 <Diavol> thanks
11:18:00 <SirFrancisDrake> Botje: thanks.
11:18:04 <byorgey> mauke: needs moar fromIntegral
11:18:08 <mauke> > let xs = "aabcdde" in map (\x -> (head x, fromIntegral (length x) / fromIntegral (length xs))) . group . sort $ xs :: [(Char, Rational)]
11:18:09 <lambdabot>   [('a',2 % 7),('b',1 % 7),('c',1 % 7),('d',2 % 7),('e',1 % 7)]
11:18:10 <Diavol> probably i mist that befor
11:18:26 <EdH> http://hpaste.org/paste/43327/sudoku_solver_type_error_next#p43341 'cause I'm really rather clueless
11:18:30 <mauke> SirFrancisDrake: in what type? floating point numbers, exact rationals, something else?
11:19:00 <SirFrancisDrake> mauke: preferably floating point numbers.
11:19:10 <aristid> > let xs = "aabcdde" in map (\x -> (head x, genericLength x % genericLength xs)) . group . sort $ xs
11:19:12 <lambdabot>   [('a',2 % 7),('b',1 % 7),('c',1 % 7),('d',2 % 7),('e',1 % 7)]
11:19:13 <Botje> EdH: uh, could you annotate it with the error you get?
11:19:14 <mauke> > let xs = "aabcdde" in map (\x -> (head x, fromIntegral (length x) / fromIntegral (length xs))) . group . sort $ xs 
11:19:16 <lambdabot>   [('a',0.2857142857142857),('b',0.14285714285714285),('c',0.1428571428571428...
11:19:22 <Botje> EdH: also, List and IO have been superceded
11:19:23 <mauke> well then
11:19:25 <EdH> oh yes, sorry
11:19:31 <lowasser1> > let xs = "aabcdde" in map (second fromRational) $ map (\x -> (head x, (length x) % length xs)) $ group $ sort xs
11:19:32 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
11:19:32 <lambdabot>         against inf...
11:19:32 <mauke> EdH: I think you're misusing 'return'
11:19:42 <lowasser1> > let xs = "aabcdde" in map (second realToFrac) $ map (\x -> (head x, (length x) % length xs)) $ group $ sort xs
11:19:42 <EdH> also quite possibly
11:19:42 <lambdabot>   [('a',0.2857142857142857),('b',0.14285714285714285),('c',0.1428571428571428...
11:19:45 <SirFrancisDrake> mauke: hmm. Thanks. That explains a lot
11:19:58 <mauke> EdH: why are there any 'return's in checkAll?
11:20:07 <byorgey> EdH: yes, Bool is not a monadic type, so using a do-block is not going to work
11:20:17 <aristid> :t (%)
11:20:18 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
11:20:21 <SirFrancisDrake> aristid, lowasser1, thanks.
11:20:37 <aristid> > let xs = "aabcdde" in map (\x -> (head x, length x % length xs)) . group . sort $ xs
11:20:39 <lambdabot>   [('a',2 % 7),('b',1 % 7),('c',1 % 7),('d',2 % 7),('e',1 % 7)]
11:20:57 <aristid> :t let xs = "aabcdde" in map (\x -> (head x, length x % length xs)) . group . sort $ xs
11:20:58 <lambdabot> [(Char, Ratio Int)]
11:21:14 <byorgey> EdH: delete every occurrence of 'do', change every 'let ...' to 'let ... in ...', and delete every occurrence of 'return'
11:21:23 <Arney> Indentation error: brighty' (x,y) = fromIntegral (floor (x/(4*pi*y^2)*10^6) / 10 ^ 6
11:21:35 <byorgey> EdH: also, replaceAt does not actually modify grid, it just returns a new one
11:22:05 <Arney> aaah, its missing a paren
11:23:01 <jmcarthur> wow, remember the "holy shmoly" blog posts that dons did in 2007? i'm doing a similar benchmark with ghc 7, and my dual core laptop is getting the same speedup that his quad core was with ghc 6.8
11:25:08 * hackagebot mongoDB 0.9.2 - MongoDB driver  http://hackage.haskell.org/package/mongoDB-0.9.2 (TonyHannan)
11:25:10 <mikeg> @src ($!)
11:25:11 <lambdabot> f $! x = x `seq` f x
11:25:55 <djahandarie> jmcarthur, nice
11:26:21 <djahandarie> I've found that I've needed to remove like all of my INLINE/NOINLINE pragmas now that I'm on 7 to make it go faster
11:28:01 <EdH> what should I import instead of List and IO to get the same functionality?
11:28:59 <jmcarthur> djahandarie: yeah, i've found the same. my INLINE pragmas are now hurting more than helping. this can only be a good thing
11:29:34 <byorgey> EdH: what do you mean?
11:29:34 <jmcarthur> EdH: Data.List and System.IO? not sure what you are asking
11:30:01 <EdH> [19:30] <Botje> EdH: also, List and IO have been superceded
11:30:11 <EdH> was wondering what by
11:30:12 <jmcarthur> EdH: ah, yeah, then what i said
11:30:17 <EdH> cool
11:30:32 <djahandarie> Why do those old imports even work?
11:30:39 <jmcarthur> they are in the h98 library
11:33:27 <mikeg> anyone know how I could point-free this: parseFormat format date = ErrorT . tryJust f $ return $! readTime defaultTimeLocale format date
11:33:45 <EdH> okay, made the changes as best as I could and annotated the new error message + code: http://hpaste.org/paste/43327/sudoku_solver_type_error__rem#p43342
11:33:47 <parcs> lambdabot does
11:33:57 <mikeg> no it doesn't
11:34:00 <mikeg> @pl parseFormat format date = ErrorT . tryJust f $ return $! readTime defaultTimeLocale format date
11:34:01 <lambdabot> parseFormat = ((ErrorT . tryJust f . (return $!)) .) . readTime defaultTimeLocale
11:34:11 <mikeg> mhmm.. different that the "pointfree" program gave me
11:34:57 <mikeg> Well, thanks, it works :)
11:36:05 <byorgey> EdH: I think you need parentheses around the -1  in checkAll newGrid -1
11:36:46 <EdH> ^ VICTORY
11:36:53 <byorgey> =D
11:37:40 <EdH> now let's see if it actually does what it's meant to :P
11:43:05 <jacobian> @pl foldl (\ f i  -> f:(Just i)) 
11:43:06 <lambdabot> foldl ((. Just) . (:))
11:43:31 <mauke> lol wut
11:46:04 <jacobian> oops
11:46:15 <jacobian> @pl foldl (\ f i -> (Just i):f)
11:46:16 <lambdabot> foldl (flip ((:) . Just))
11:47:19 <mauke> ok, that makes more sense
11:48:06 <jacobian> Kind of awesome that it just charges along despite being nonsense :)
11:48:46 <Saizan> untypedness
11:48:59 <ion> Well, that’s syntactically perfectly valid. You could implement an alternative (:) that even works for those types. :-P
11:50:26 <mauke> @pl \f -> [f x | x <- fuckYourSyntax]
11:50:26 <lambdabot> return . (<- fuckYourSyntax) . (| x) . ($ x)
11:50:30 <jacobian> ion: I was just trying to substitute library constructors for ones that would work at the prompt
11:50:41 <jacobian> ion: so in a sense that's exactly what I was doing. 
11:51:33 <ion> > \x -> x :: Foo -- mauke: Something that should *actually* work. ;-)
11:51:34 <lambdabot>   Not in scope: type constructor or class `Foo'
11:51:43 <ion> @pl \x -> x :: Foo
11:51:43 <lambdabot> (:: Foo)
11:51:47 <ion> that
11:54:45 <ion> fromIntegral . flip shiftR 1 . (:: Word32) . fromIntegral
11:55:50 <solistic> say is there an idiomatic way to define the function Map `k a -> Map a [k]' ?
11:57:02 <copumpkin> sort of
11:57:04 <mauke> huh?
11:57:16 <mauke> oh
11:57:17 <copumpkin> I'd probably write it as
11:58:21 <copumpkin> fromListWith (++) . fmap pure . (snd &&& fst) . assocs
11:58:33 <copumpkin> (off the top of my head, probably won't work)
11:58:50 <solistic> copumpkin: I'll try
11:59:06 <solistic> copumpkin: it is much shorter than what I have
11:59:11 <solistic> copumpkin: thk
11:59:11 <copumpkin> :t M.fromListWith (++) . fmap pure . (snd &&& fst) . M.assocs
11:59:12 <lambdabot>     Couldn't match expected type `[a]' against inferred type `(b, a1)'
11:59:12 <lambdabot>     In the first argument of `(.)', namely `(snd &&& fst)'
11:59:12 <lambdabot>     In the second argument of `(.)', namely `(snd &&& fst) . M.assocs'
11:59:15 <copumpkin> I fail
11:59:34 <copumpkin> :t M.fromListWith (++) . map (snd &&& pure . fst) . M.assocs
11:59:35 <lambdabot> forall a b (f :: * -> *). (Monoid (f a), Ord b, Applicative f) => M.Map a b -> M.Map b (f a)
11:59:39 <copumpkin> there we go
11:59:41 <mauke> :t M.foldWithKey (\k v m -> M.insertWith (++) k [v] m) M.empty
11:59:42 <lambdabot> forall k a. (Ord k) => M.Map k a -> M.Map k [a]
12:00:32 <parcs> mauke: that doesn't do much :P
12:00:41 <mauke> my emperor
12:00:45 <mauke> I've failed you
12:00:52 * copumpkin castigates mauke 
12:00:55 <mauke> :t M.foldWithKey (\k v m -> M.insertWith (++) v [k] m) M.empty
12:00:56 <lambdabot> forall k a. (Ord a) => M.Map k a -> M.Map a [k]
12:01:10 <mauke> @pl M.foldWithKey (\k v m -> M.insertWith (++) v [k] m) M.empty
12:01:10 <lambdabot> M.foldWithKey (flip (M.insertWith (++)) . return) M.empty
12:01:23 <copumpkin> shorter than mine :(
12:01:30 * copumpkin feels inadequate
12:01:46 <mauke> :t M.foldWithKey (\k v m -> M.insertWith mappend v (pure k) m) M.empty
12:01:47 <lambdabot> forall k a (f :: * -> *). (Monoid (f k), Applicative f, Ord a) => M.Map k a -> M.Map a (f k)
12:02:04 <jacobian> @pl map (\ (a,b) -> (f a,f b)) 
12:02:04 <lambdabot> map (f *** f)
12:02:44 <copumpkin> @pl M.foldWithKey (\k v m -> M.insertWith (++) v (pure k) m) M.empty
12:02:45 <lambdabot> M.foldWithKey (flip (M.insertWith (++)) . pure) M.empty
12:02:56 <copumpkin> that's very simple
12:02:57 <mauke> > (join (***) f) a b :: (Expr,Expr)
12:02:58 <lambdabot>   Couldn't match expected type `t
12:02:58 <lambdabot>                                -> (SimpleRe...
12:03:18 <mauke> > (join (***) f) (a, b) :: (Expr,Expr)
12:03:19 <lambdabot>   (f a,f b)
12:04:08 <copumpkin> jlouis: did your torrent thing for haskell fail?
12:04:33 <jlouis> copumpkin: fail?
12:04:39 <jlouis> I don't think it failed
12:04:41 <copumpkin> jlouis: oh good
12:04:44 <copumpkin> comex: ^
12:05:01 <copumpkin> thanks :)
12:05:13 <jlouis> That I am not working on it does not mean that the project as such failed
12:05:33 <copumpkin> yeah, I didn't think so
12:05:34 <jlouis> In fact, it deeply impacted etorrent written in Erlang
12:06:00 <jlouis> That can't be fail, by any measure
12:06:20 * hackagebot crypto-api 0.4 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.4 (ThomasDuBuisson)
12:06:31 <jlouis> also, I am waiting a bit for a new haskell-platform to arrive so I can play with the new IO manager
12:06:39 <copumpkin> jlouis: yay
12:07:29 <jlouis> Honestly though, for the *way I built* etorrent and combinatorrent, Erlang is probably a better fit
12:08:29 <copumpkin> ah
12:09:15 <jlouis> on the other hand, having a type system like the one in Haskell is *almost* godlike
12:09:29 <jlouis> for *godlike*, come to #agda, please :P
12:09:36 <copumpkin> I'm already there :)
12:11:33 <jlouis> feel free to ask further questions if you like :)
12:11:48 <j-invariant> can you do practical programming in agda
12:12:01 <copumpkin> j-invariant: no
12:13:33 <kuffaar> COQ
12:20:23 <kuffaar> Fact: using monads during pregnancy can lead to serious birth defects.
12:36:34 <ronwalf> hmm... It seems like there should be an elegant solution for mapzip :: [a] -> [[b]] -> [[(a,b)]]
12:37:10 <mauke> what does it do?
12:37:55 <kuffaar> map and zipWith?
12:38:12 <test423432> Hello guys, I'm compiling something in Windows
12:38:18 <test423432> ghc --make Test.hs
12:38:25 <test423432> but I only get .o and .hi files :(
12:38:26 <test423432> or something
12:38:51 <test423432> how can I compile properly in Windows 7?
12:38:55 <ClaudiusMaximus> > [ (a, b) | a <- "abc" , bs <- ["def", "ghi"], b <- bs ] -- is my guess
12:38:56 <lambdabot>   [('a','d'),('a','e'),('a','f'),('a','g'),('a','h'),('a','i'),('b','d'),('b'...
12:38:58 <kuffaar> test423432 hmm usually you either just use ghci to test stuff or a proper cabal file which you use with "cabal install" for composite executables/libraries
12:39:11 <ClaudiusMaximus> or maybe not, that's more a product...
12:39:29 <test423432> I need an exe :(
12:39:44 <test423432> but in the old days I could make an exe just by doing ghc --make Test.hs
12:39:48 <kuffaar> cabal install with an application cabal file would give you just that
12:39:51 <kuffaar> Hmm I've never used that
12:40:01 <test423432> How do I do it? :(
12:40:10 <alpounet> test423432, doesn't it tell you "Linking Test..." at some point ?
12:40:24 <test423432> uh no?
12:40:27 <test423432> it just gives me
12:40:28 <dcoutts> test423432: your Test.hs is not a Main module
12:40:33 <test423432> yes it is!
12:40:37 <test423432> that IS my main module XD
12:40:40 <test423432> I just called it test
12:40:46 <alpounet> do you have a main function inside ?
12:40:49 <test423432> yes
12:40:54 <test423432> main :: IO
12:41:04 <test423432> and it works properly within GHCi
12:41:28 <dcoutts> does it say module Main where at the top?
12:41:37 <test423432> no...
12:41:45 <dcoutts> does it have any module decl?
12:41:49 <test423432> yes
12:41:53 <test423432> module Test where
12:41:57 <test423432> and the file is called test.hs
12:41:58 <dcoutts> there you go
12:42:04 <dcoutts> test423432: your Test.hs is not a Main module :-)
12:42:18 <test423432> do I really need to name that module that way?
12:42:55 <test423432> OMG it works!
12:43:00 <kuffaar> test423432 no, you can use any name essentially, but you have to specify the main module in some commandline argument otherwise
12:43:09 <test423432> oh icic
12:43:09 <dcoutts> test423432: otherwise it's just any old module, not one that can be made into a standalone program
12:43:26 <dcoutts> Main.main is the standard entry point for standalone programs
12:43:32 <dcoutts> ghci can run any function
12:43:33 <alpounet> test423432, note that if you don't specify any module name at the top
12:43:36 <alpounet> it will compile
12:43:41 <alpounet> that's cleaner though to provide one
12:43:52 <dcoutts> because if you don't specify any module name then it defaults to Main
12:43:59 <test423432> okay thanks! =)
12:45:09 <test423432> so anyone any idea why the .o and .hi files are for?
12:45:24 <kuffaar> those are ghc object files I guess
12:45:35 <kuffaar> Not sure why 2 per module though
12:45:44 <dcoutts> .hi is an interface file
12:45:56 <test423432> are they required to run my .exe?
12:45:58 <dcoutts> no
12:46:07 <kuffaar> Ah, so that is where the Java interfaces in Haskell go
12:46:29 <test423432> @ kuffaar remember yesterday my problem? about the letters and sums?
12:46:36 <kuffaar> I do
12:46:40 <test423432> Well I couldn't solve it
12:47:00 <test423432> now I am writing a bruteforcer for a friend of mine who has a i7 processor
12:47:08 <test423432> much faster than my cerelon :P
12:47:17 <test423432> so hopefully it can crack it =D
12:48:08 <kuffaar> test423432 I don't get it, I thought it was a linear algebra problem?
12:48:29 <test423432> I couldn't solve it using linear algebra
12:48:38 <kuffaar> Why not?
12:48:54 <test423432> kuffaar are you dutch?
12:49:01 <kuffaar> No
12:49:08 <test423432> okay I will show you my calculations
12:49:17 <test423432> hold on
12:49:26 <kuffaar> But I do speak German and English, both of which are west Germanic languages like Dutch
12:49:37 <kuffaar> So I understand a fair amount when written
12:49:41 <test423432> that's cool =)
12:50:00 <test423432> First I will explain what I did
12:50:27 <test423432> a) I made from every word the following like advocaat = 3*a + d + v + o + c + t = 108
12:50:38 <test423432> which is the corresponding function
12:50:46 <kuffaar> That's an equation
12:50:49 <test423432> I did that for every funtion: http://www.wetenschapsforum.nl/index.php?showtopic=135623
12:50:51 <test423432> yes true
12:51:02 <test423432> I putted it in a Mathematica solver, to solve it
12:51:25 <test423432> as Mathematica solves these things faster than I could do with Haskell
12:51:32 <kuffaar> Yeah
12:51:33 <test423432> shown http://www.wetenschapsforum.nl/index.php?showtopic=135623 (3rd post)
12:51:51 <test423432> as you can see my only missing variables are a b and c
12:52:33 <test423432> so I used the code edwardk gave me
12:52:41 <test423432> I rewrote it a bit
12:52:49 <test423432> and tried to bruteforce crack the a b and c
12:52:51 <test423432> it failed
12:52:54 <kuffaar> I would just translate it to a matrix
12:53:01 <kuffaar> You don't need to bruteforce anything
12:53:06 <kuffaar> All you need is linear algebra
12:53:12 <test423432> yeah I thought that too!
12:53:22 <test423432> kuffaar are you familiar with Mathematica?
12:53:25 <kuffaar> You just perform Gaussian elimination and that will give you the vectors
12:53:26 <kuffaar> I am
12:53:44 <test423432> so you argue that I used the wrong Mathematica command?
12:53:50 <kuffaar> test423432 do you know what the kernel of a vector space is?
12:53:52 <test423432> (sorry for my english)
12:54:02 <test423432> no :p
12:54:29 <test423432> how can you solve for 26 variables if I have only 22 equations? :(?
12:54:38 <test423432> It's almost impossible right?
12:54:40 <j-invariant> you can still solve
12:54:43 <j-invariant> it might have multiple solutions
12:54:47 <test423432> :| WHAT? :|
12:54:54 <j-invariant> for example x + y = 3
12:54:59 <kuffaar> test423432: That gives you more vectors whose linear combinations form the solution space
12:55:00 <test423432> yes true
12:55:05 <j-invariant> we have the solutions {x=1,y=2; x=2,y=1}
12:55:24 <test423432> how do I translate that to Mathematica?
12:55:36 <j-invariant> why don't you implement gaussian elimination in haskell?
12:55:45 <test423432> because it's slower than Mathematica
12:55:47 <ivanm> test423432: why are you asking about mathematica in #haskell?
12:55:49 <kuffaar> I've implemented it in C++ once
12:55:56 <kuffaar> test423432 this is a very small example
12:55:59 * ivanm calls BS on haskell being slower than mathematica
12:56:03 <j-invariant> the algoirthm is O(n^2)
12:56:04 <kuffaar> It would be solved in less than like 100 ms
12:56:09 <lispy> Is it just me or is the threading on this page very broken towards the bottom? http://www.haskell.org/pipermail/haskell-cafe/2011-January/thread.html
12:56:15 <kuffaar> On a 10 MHz CPU
12:56:22 <lispy> It seems like very unrelated messages are getting threaded
12:56:31 <test423432> I ask it because the problem was for Haskell
12:56:34 <test423432> but I failed to do that in Haskell
12:56:35 <j-invariant> so "mathematica is faster" is nonsense
12:56:39 <ivanm> lispy: could be
12:56:43 <j-invariant> you failed to implement gaussian elimination?
12:56:52 <test423432> no I failed to solve it in Haskell :(...
12:56:54 <ivanm> lispy: or it could be that someone was lazy, replied-to a previous email and just changed all the content
12:56:59 <j-invariant> test423432: did you try gaussian elimination?
12:57:04 <ivanm> (admittedly, gmail hasn't said that that happened...)
12:57:33 <test423432> I tried to read the article edwardk gave me, but I was progressing really slow =
12:57:55 <test423432> as my Haskell skills aren't good enough :(
12:58:07 <kuffaar> test423432 how old are you? What type of school is this a problem for?
12:58:16 <test423432> This is not a school problem XD
12:58:18 <j-invariant> test423432: this is how you learn
12:58:33 <test423432> j-invariant, that's true..
12:58:38 <kuffaar> test423432 what is it then...?
12:58:44 <test423432> it's from a magazine
12:58:47 <j-invariant> test423432: I also recommend it because the algorithm is a very very important one
12:58:58 <test423432> normally I solve these with Haskell to improve my skills
12:59:21 <test423432> but this one was way too hard for me to do in Haskell
12:59:40 <monochrom> Death to the hacker who brought down the community server!
13:00:03 <test423432> but I can only agree that it is a bit off topic
13:00:41 <test423432> plus if you add the numbers in my name it would reveal my age XD :P
13:00:43 <kuffaar> Math is never off topic in Haskell
13:01:12 <dafis> lispy:  not just you ivanm: I checked the message code of yitzgale's post, at least that one doesn't contain a In-Reply-To field
13:01:15 <kuffaar> > 2 * sum [4, 2, 3]
13:01:16 <lambdabot>   18
13:01:18 <kuffaar> I see
13:01:28 <test423432> but I am not even studying Math XD or computer science
13:01:29 <kuffaar> I didn't know about this stuff until I was 19
13:01:36 <j-invariant> what stuff?
13:01:43 <test423432> I'm studying a totally unrelated field from all this
13:01:48 <test423432> Economics...
13:01:50 <Philonous> c2hs seems to choke on _Bool. is that a known problem? 
13:01:52 <kuffaar> j-invariant vector spaces, Gaussian elimination, kernels, blah blah
13:01:58 <sm> maybe we need a community server built from the ground up in a secure language ?
13:02:02 <j-invariant> kuffaar: um he doesn't know that stuff
13:02:09 <test423432> I know gaussian elimination
13:02:17 <kuffaar> j-invariant I know, why are you telling me?
13:02:25 <monochrom> gaussian elimination works on rows. you could use [[Integer]] for your matrix, where the inner list is for rows. row operations are easy to code up over that data structure.
13:02:26 <j-invariant> kuffaar: k. bye
13:02:38 <test423432> I know what a vector is too =)
13:02:42 <test423432> XD
13:03:23 <test423432> kuffaar: so according to you my problem should be solveable with a matrix?
13:03:26 <gienah> Philonous: maybe it needs a pre-processor define
13:03:54 <kuffaar> test423432: Yes, it will give you a set of vectors which are the base of the null space
13:04:02 <kuffaar> Sorry, *basis
13:04:05 <monochrom> if you don't like matrices, each row represents one equation, "row operation" is simply one of those "add this equation to this other equation" things, which is still easy to see and code up
13:04:21 <deech> Hi all, what is the best of editing literate (bird track) haskell code in emacs? I thought haskell-mode was supposed to add the ">" for you but I don't see where.
13:04:24 <test423432> no it's not I do not like matrices
13:04:51 <test423432> kuffaar: but I would have a matrix of 26 long..
13:04:58 <ivanm> monochrom: agreed (about the hacker)!
13:05:06 <Philonous> gienah: Uh, but what should I define it to be? _Bool is the ANSI C(99) bool type, and that's what it should be
13:05:15 <kuffaar> You basically perform Gaussian elimination, then you invert the sign of the rightmost column and you replace all zeroes on the diagonal with a -1
13:05:25 <monochrom> you have a 4GHz 4GB computer. 26x26 matrix is nothing.
13:05:42 <pumpkin> does it harvest human life energy?
13:05:45 <pumpkin> :(
13:06:02 <test423432> I was talking about doing it on paper :P
13:06:10 <test423432> actually XD
13:06:12 <monochrom> oh oops haha
13:06:12 <kuffaar> test423432 you can forget about that
13:06:31 <test423432> okay I'm going to try gaussian elimination
13:06:36 <test423432> with a haskell package
13:06:38 <monochrom> probably not 26x26 most of the time, more like 7x3.
13:06:45 <kuffaar> And then the rightmost columns which do not have the 1 on the digonal from the elimination are the vectors which form the null space
13:06:58 <gienah> Philonous: I'm just guessing, but you could try searching the system header files to see if _Bool is defined when some other pre-processor define is defined
13:07:13 <test423432> okay uhm... is there a math package in Haskell :(?
13:07:17 <test423432> which can do these things?
13:07:33 <test423432> yesterday someone told me, but I forgot
13:07:48 <kuffaar> test423432 there probably is
13:07:53 <test423432> hmatrix
13:07:55 <test423432> Found it!
13:08:41 <kuffaar> http://luckytoilet.wordpress.com/2010/02/21/solving-systems-of-linear-equations-in-haskell/ lol
13:09:10 <kuffaar> test423432 you don't really want to solve this numerically though, it's nicer to use a CAS with symbolic computation for that
13:09:18 <kuffaar> I mean in this case the stuff is all rational
13:11:00 <kuffaar> Mathematical symbolic computation is no trivial subject
13:11:17 <gienah> Philonous: Or if _Bool is not a #define, then another idea is to write a little C program that prints sizeof(_Bool), then typedef it to a data type of the same size when compiling with c2hs
13:11:41 <test423432> oh I see...
13:11:43 <Philonous> gienah: I've just #defined it to be unsigned int
13:11:56 <kuffaar> test423432 although in this case it would probably work fine
13:12:12 <kuffaar> Unless it has results like 1/17 + 1/13 :p
13:12:14 <test423432> kuffaar could you look at my matrix (http://pastebin.com/X0hv1ifH)?
13:12:17 <gienah> Philonous: which would only be ok if the little C program agrees on the sizeof
13:12:24 <test423432> do you expect something like this?
13:12:38 <kuffaar> test423432 yes, that's precisely what you should be using
13:12:53 <test423432> omg
13:12:56 <test423432> it looks really big XD
13:14:35 <kuffaar> test423432 the resulting vectors are pretty ugly
13:14:37 <kuffaar> In Derive
13:15:17 <kuffaar> Multiplying all vectors of the basis by 24 gives you integers though
13:15:51 <mreh> how do you generalised failing code?
13:16:02 <kuffaar> How is bebby formed?
13:16:07 <mreh> oh Monad m => m a
13:16:30 <mreh> I was thinking of trying to catch a MonadError
13:16:34 <pumpkin> :t mempty
13:16:35 <lambdabot> forall a. (Monoid a) => a
13:16:39 <pumpkin> :t mzero
13:16:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
13:16:49 <kuffaar> :t mconcat
13:16:50 <lambdabot> forall a. (Monoid a) => [a] -> a
13:17:00 <mreh> have you taken in a free pumpkin?
13:17:27 <kuffaar> pumpkin is a monad over the co-category of copumpkin
13:19:15 <test423432> kuffaar I'm reading through some theory what is a echelon form?
13:19:24 <test423432> anyone know that =(?
13:19:36 <kuffaar> The row echelon form is what you get from Gaussian elimination
13:19:41 <test423432> oh icic
13:19:46 <test423432> so that's what I need right?
13:19:49 <kuffaar> http://en.wikipedia.org/wiki/Row_echelon_form
13:19:50 <kuffaar> Yes
13:20:48 <ronwalf> mauke: I was thinking > mapzip [0..] ["abc", "de"] == [[(0,'a'),(1,'b'),(2,'c')],[(3,'d'),(4,'e')]]
13:21:09 <test423432> kuffaar I don't know I got big problems :(
13:21:23 <ronwalf> So a zip with one list of lists that preserves the lists structure
13:21:24 <test423432> somehow every one of them is -1/3 or soemthing
13:21:44 <kuffaar> test423432: The null space vectors I got out of that in Derive are pretty ugly, I told you
13:21:45 <ronwalf> It's not hard to hack out with length take and drop, but it feels so dirty
13:21:48 <mreh> > [ zip [0..] xs | xs <- ["abc", "de"]]
13:21:49 <lambdabot>   [[(0,'a'),(1,'b'),(2,'c')],[(0,'d'),(1,'e')]]
13:22:15 <kuffaar> You can multiple them with the greatest common denominator (after they have been simplified) to get an integer-only solution for the vectors
13:22:28 <kuffaar> Which is more comfortable for generating integer solutions
13:22:30 <ronwalf> mreh: if only!
13:22:31 <mreh> > zip [0..] `liftM` ["abc", "de"]
13:22:32 <test423432> which is 24 if I'm guessing it correctly
13:22:33 <lambdabot>   [[(0,'a'),(1,'b'),(2,'c')],[(0,'d'),(1,'e')]]
13:22:37 <mreh> doh
13:22:39 <test423432> (you said that haha :P)
13:23:07 <test423432> how on earth can something like 1.08333 be correct XD?
13:23:27 <kuffaar> It isn't
13:23:33 <test423432> and I get negative numbers.. =( which aren't correct as they should be in the range of 1 till 26
13:23:35 <kuffaar> That's a numerical approximation of a rational number
13:23:58 <kuffaar> Oh?
13:24:08 <test423432> ok that's it, my ahskell skills suck that bad probably
13:24:08 <kuffaar> test423432 this sounds like an ILP problem then I think?
13:24:12 <test423432> I'm gonna run 
13:24:15 <test423432> Mathematica on this
13:24:15 <kuffaar> It has integer constraints? Hm
13:24:30 <kuffaar> http://en.wikipedia.org/wiki/Linear_programming
13:24:33 <test423432> Haskell gives negative number weird XD and I can't find the code
13:24:34 <test423432> so
13:24:38 <kuffaar> No wait, that's different
13:24:56 <mreh> ronwalf: it's a traversal
13:25:01 <test423432> okay
13:25:11 <Saizan> > let next = do (x:xs) <- get; put xs; return x in flip runState [0..] $ mapM (mapM (\x -> liftM2 (,) next (return x)))  ["abc", "de"]
13:25:12 <test423432> Mathematica says that there are negative numbers :D :P
13:25:13 <lambdabot>   ([[(0,'a'),(1,'b'),(2,'c')],[(3,'d'),(4,'e')]],[5,6,7,8,9,10,11,12,13,14,15...
13:25:16 <test423432> I did it correctly :D!
13:25:28 <Saizan> > let next = do (x:xs) <- get; put xs; return x in flip evalState [0..] $ mapM (mapM (\x -> liftM2 (,) next (return x)))  ["abc", "de"]
13:25:29 <lambdabot>   [[(0,'a'),(1,'b'),(2,'c')],[(3,'d'),(4,'e')]]
13:25:39 <mreh> we have a winrar
13:25:41 <j-invariant> test423432: just curious but do you have the actual problem written somewhere? I am curiouswhat it is
13:25:53 <test423432> j-invariant do you speak dutch?
13:26:05 <j-invariant> no sorry
13:26:08 <sipa> i do
13:26:09 <ronwalf> Saizan: scaaaary
13:26:18 <test423432> okay then I'm gonna translate it
13:26:23 <test423432> go to this website: http://www.wetenschapsforum.nl/index.php?showtopic=135623
13:26:30 <test423432> You will see advocaat 108 till o 1
13:26:52 <dpratt71> easy question: I know how to create a decreasing range like this: [999, 998..100] but what if the starting point is a variable?
13:26:53 <j-invariant> test423432: so it's just find a function 'f' such that
13:27:06 <mauke> dpratt71: same thing
13:27:08 <sipa> test423432: that's an alpha puzzle
13:27:10 <test423432> that's the list of equations I have, the meaning is a+d+v+o+c+a+a+t = 108 and you should find the numbers corresponding with the letters
13:27:13 <j-invariant> f 'a' + f 'd' + f 'v' + f 'o' + f 'c' + f 'a' + f  'a' + f 't' == 108
13:27:16 <j-invariant> test423432: and so  on?
13:27:17 <sipa> trivial to solve using constraint programming :)
13:27:22 <mreh> can't we make it nicer with an instances of Traversable []?
13:27:26 <test423432> no you don't find the function
13:27:29 <mreh> instance
13:27:33 <test423432> every letter correspond with a number
13:27:37 <test423432> like o = 1,
13:27:38 <j-invariant> test423432: A function f :: Char -> Integer
13:27:49 <test423432> uh yes, you need to find the mapping function
13:27:56 <j-invariant> okay I am going to have a go
13:27:59 <test423432> But the constraints are
13:28:01 <Saizan> mreh: that'd give you mapM
13:28:03 <test423432> as follows
13:28:09 <mreh> Traversable a => [a]?
13:28:11 <j-invariant> test423432: o 1 <-- we know that f 'o' == 1 right away?
13:28:12 <test423432> a till z can only have numbers 1 till 26
13:28:18 <dpratt71> mauke: ok; by starting point, I mean the greatest value; does that make a difference?
13:28:19 <test423432> yes
13:28:20 <kuffaar> j-invariant: It's basically just a linear algebra problem which involves reducing that matrix, but you need to take care of the constraints after that
13:28:22 <test423432> you know that right away
13:28:32 <j-invariant> test423432: okay this sounds fun
13:28:34 <test423432> now plus every
13:28:35 <mauke> dpratt71: no
13:28:35 <j-invariant> thanks
13:28:39 <mauke> dpratt71: what's the problem?
13:28:46 <test423432> number should have different letters
13:28:55 <test423432> every letter has a unique number between 1 till 26
13:29:01 <kuffaar> Simplex algorithm combined branch && bound reminds me of this stuff for some reason
13:29:08 <test423432> so none of a till z can have 1 except o
13:29:10 <djso1987> need to learn haskell any video tutorials??
13:29:16 <kuffaar> Because of determining integer solutions within simplex constraints
13:29:20 <dpratt71> > let a = 999 in [a..100]
13:29:20 <lambdabot>   []
13:29:33 <test423432> that would be a very nasty job implementing Simplex method based on my haskell skills
13:29:38 <kuffaar> djso1987: Video tutorials for anything other than perhaps mechanical instructions are pretty much a joke
13:29:38 <mauke> > let a = 999 in [a, a-1 .. 100]
13:29:39 <lambdabot>   [999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,982,98...
13:29:59 <test423432> @ j-invariant you should try a one liner solution, if you can pull that off XD that's sick :P
13:30:13 <djso1987> how do i learn
13:30:17 <dpratt71> mauke: heh; I considered a-1, but I was certain that wouldn't work; guess I should've tried it
13:30:19 <kuffaar> djso1987: If you want to get started with Haskell check out Learn You A Haskell and Real World Haskell and such
13:30:21 <kuffaar> @lyah
13:30:21 <lambdabot> Unknown command, try @list
13:30:26 <kuffaar> Hmm what was it called
13:30:26 <dpratt71> mauke: thanks
13:30:37 <kuffaar> @where lyah
13:30:37 <lambdabot> http://www.learnyouahaskell.com/
13:30:38 <kuffaar> @where rwh
13:30:39 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:30:51 <kuffaar> There you go, djso1987
13:31:00 <kuffaar> Download the Haskell Platform for your OS and start with LYAH
13:31:01 <djso1987> ohh thanks
13:31:07 <test423432> j-invariant if you can solve it, can you please tell me what / how you did it?
13:31:17 <test423432> I'm out of simple ideas
13:31:43 <test423432> OH CRAP :|!
13:31:47 <test423432> kuffaar I know what I did wrong!
13:31:50 <kuffaar> j-invariant how are you going to solve the integer programming/constraint part?
13:31:54 <kuffaar> test423432 was the matrix wrong?
13:31:58 <test423432> yes
13:32:00 <kuffaar> Nice
13:32:04 <test423432> it did not included advocaat = 108 :P
13:32:06 <kuffaar> You should generate it programmatically
13:32:08 <test423432> it only included the letters
13:32:21 <test423432> I did, I forgot to parse the numbers :P
13:32:26 <kuffaar> Wait a second
13:32:47 <kuffaar> That is a^3 d v o c t = 108?
13:32:51 <test423432> yes
13:32:54 <kuffaar> Instead of a linear equation?
13:32:55 <test423432> summed
13:32:57 <kuffaar> ...
13:32:57 <test423432> no
13:32:58 <test423432> no
13:33:01 <kuffaar> a b means a * b
13:33:06 <test423432> 3 * a + d + v + o + c + t = 108
13:33:09 <kuffaar> Right
13:33:17 <test423432> nog a^3, that would be sick :p
13:33:34 <kuffaar> Oh yeah I see, you forgot the elements on the right.
13:33:38 <test423432> yes
13:33:48 <kuffaar> I didn't even notice that, lame
13:33:57 <test423432> can someone give me a small example, just to test my algorithm
13:33:58 <test423432> works?
13:34:15 <test423432> matrix should be no bigger than 3 x 3 XD :P
13:35:09 <kuffaar> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
13:35:25 <test423432> what is the solution of this? :P
13:35:32 <kuffaar> Should reduce to [[1, 0, -1], [0, 1, 0], [-1, 2, 0]]
13:35:59 <kuffaar> The null space is <[1, -2, 0]>
13:36:16 <kuffaar> Although in this case the negation is irrelevant I suppose
13:36:28 <kuffaar> Since the null space has a dimension of only 1
13:36:38 <test423432> uhm...
13:36:42 <kuffaar> Oh wia
13:36:44 <test423432> I got the things mixed up?
13:36:47 <kuffaar> Wait, I forgot about the -1*
13:37:03 <test423432> I got {1,0,-1} {0,1,2} {0,0,0}
13:37:44 <kuffaar> Yeah it's <[-1, 2, -1]>, sorry
13:37:54 <test423432> I got the same as here: http://www.wolframalpha.com/input/?i=RowReduce[{{1,+2,+3},+{4,+5,+6},+{7,+8,+9}}]
13:38:08 <test423432> is my solution correct?
13:38:19 <kuffaar> Oh ffs, I posted the wrong output
13:38:21 <kuffaar> Yes
13:38:33 <test423432> ok awesome
13:38:44 <kuffaar> I accidentally transposed the matrix
13:38:48 <kuffaar> Silly me
13:38:58 <test423432> You did it in your head :|???!!!
13:39:02 <kuffaar> But my base for the null space is correct
13:39:20 <kuffaar> test423432 no, I'd probably make mistakes then
13:39:30 <kuffaar> I can do it for a 2x2 matrix, but not for a 3x3 one without paper
13:39:48 <kuffaar> Unless the matrix is really simple
13:40:11 <test423432> oh ic
13:40:18 <kuffaar> Ah, look at the characteristic polynomial :)
13:40:27 <kuffaar> Its coefficients are -1, 2, -1
13:40:30 <test423432> :P
13:40:35 <kuffaar> <kuffaar> Yeah it's <[-1, 2, -1]>, sorry
13:41:00 <kuffaar> That means that Char(A) = 0
13:41:21 <kuffaar> Where Char(x) is the characteristic polynomial and A is the matrix in question
13:41:34 <test423432> hmm...
13:41:43 <test423432> I have a problem again
13:41:58 <test423432> I got something really weird
13:42:52 <test423432> the result is this: http://pastebin.com/BUTUW4W2
13:42:56 <test423432> now what do I do with this XD? :P
13:43:11 <test423432> everything on the full right side is 0 :| :(
13:43:48 <kuffaar> Hm
13:44:00 <test423432> this shouldn't come out of it :(
13:44:24 <kuffaar> It can happen, te
13:44:27 <kuffaar> test423432*
13:44:29 <test423432> it has only calculated x y and z
13:44:34 <kuffaar> No
13:44:45 <kuffaar> It has not
13:44:53 <kuffaar> It just reduces the matrix, the interpretation is up to you
13:45:05 <test423432> so what has it done? XD?
13:45:23 <test423432> is this the answer?
13:45:45 <kuffaar> No
13:46:40 <test423432> Okay I'm lost, I do not know what this is and what I can do with it XD
13:46:55 <test423432> it got the nice 1's though
13:47:01 <fotanus> hey... What is wrong with this line: 
13:47:04 <fotanus> let n_prime n start = if n == 1 then find is_prime r else n_prime (n-1) (find is_prime r) where r = [start..]
13:47:32 <fotanus> any comments about the line would be appreciated, also
13:47:37 <kuffaar> You now extend the matrix to its square form, you replace diagonal zeroes with -1, then you take all the non-unit vectors from the right and they form the null space for your linear algebra problem A x = b, test423432
13:48:04 <kuffaar> And then you use that to solve the integer constraint problem
13:48:12 <kuffaar> Honestly, I think this is way above your head right now
13:48:16 <test423432> uh...
13:48:29 <test423432> yes it is
13:48:37 <kuffaar> test423432 usually you study this stuff for 2 years at university before you get a grasp on it
13:48:44 <kuffaar> And most people don't really get it even then
13:48:53 <kuffaar> Unless they study math instead of CS
13:48:58 <dafis> @type find
13:49:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:49:04 <dafis> fotanus:  ^^
13:49:05 <test423432> haha so I kind of fail with my economics :P
13:49:30 <kuffaar> You do economics at university? I doubt this topic will be covered at all really
13:49:30 <dafis> fotanus:  you get a Maybe Integer, but you treat it as if it were an Integer
13:49:38 <test423432> yes I do economics
13:49:40 <kuffaar> Linear algebra is not that relevant for economics, I think
13:49:47 <Saizan> another option is to use a library for contraint programming, and get it solved for you :)
13:50:01 <test423432> uhm well I have made some practical implementations
13:50:07 <fotanus> dafis: oh, I see, thank you :-)
13:50:51 <fotanus> dafis: yet I'm not sure how to fix it
13:51:20 <test423432> kuffaar so you're saying this can be done with linear programming right?
13:51:25 <dafis> fotanus:  you can use a case, or maybe, fromMaybe or fromJust
13:51:36 <kuffaar> test423432: A regular ILP is different, I think
13:51:40 <dafis> case would be my choice
13:51:42 <j-invariant> test423432: I implemented the first step
13:51:54 <fotanus> dafis: thanks, I'll google for these functions
13:52:06 <test423432> j-invariant well I got stuck after getting that matrix XD
13:52:25 <j-invariant> test423432: I mean, I made somethign which recognizes "o" = 1 and uses it
13:52:39 <test423432> you can parse it? =)
13:52:47 <j-invariant> parse what?
13:52:48 <dafis> fotanus:  case find is_prime r of { Just p -> n_prime (n-1) p; Nothing -> error "last prime detected" }
13:52:56 <kuffaar> j-invariant do you have undergraduate knowledge of mathematics?
13:52:58 <test423432> parse o = 1
13:53:17 <test423432> kuffaar what are you studying?
13:53:19 <kuffaar> > let parse o = 1 in parse "o = 2"
13:53:19 <lambdabot>   1
13:53:28 <mreh> lmerge [1,2,3] [5,4,3,2,1] == [1,2,3,2,1]
13:53:29 <kuffaar> test423432: Computard science
13:53:33 <mreh> any ideas?
13:53:34 <fotanus> dafis: oh, I see, thank you very much :-)
13:53:40 <test423432> how old are you? XD
13:53:45 <kuffaar> I am 24
13:53:56 <test423432> that's a lot older than me XD
13:54:06 <mreh> D:
13:54:11 * sproingie shakes his cane at you wippersnappers
13:54:13 <kuffaar> My math skills were probably at their peak when I was 21
13:54:20 <test423432> XD darn I thought I could solve that
13:54:26 <test423432> problem
13:54:29 <kuffaar> Now it's already on the decline again since I never use it anymore except to help random people like you on IRC.
13:54:49 <dafis> mreh:  what's lmerge supposed to do?
13:54:49 <test423432> what kind of master are you doing?
13:55:06 <kuffaar> I'm doing a German diploma, it's roughly equivalent to an MSc
13:55:11 <int80_h> greetings
13:55:27 <kuffaar> You can convert it to an MSc later, within 3-6 months or something like that
13:55:28 <ion> > let lmerge [1,2,3] [5,4,3,2,1] = [1,2,3,2,1] in lmerge [1,2,3] [5,4,3,2,1]
13:55:29 <lambdabot>   [1,2,3,2,1]
13:55:33 <test423432> wow.. so what kind of Msc are you studying theoretical cs or ..?
13:55:33 <kuffaar> But I'm not even going to bother
13:56:06 <test423432> I thought there were a lot of subfields in the cs section
13:56:06 <kuffaar> No, I wanted to do stuff on compiler theory and operating systems originally
13:56:17 <djahandarie> kuffaar, hang out in the right channels and I imagine it could make your math skills better than ever :P
13:56:19 <kuffaar> But they butchered the compiler lectures so I decided not to take that subject
13:56:29 <test423432> oh I see
13:56:40 <kuffaar> So I did embedded systems/systems engineering and operating systems
13:56:56 <kuffaar> Nearly done with all of that except for the OS stuff now
13:57:06 <test423432> ah I see
13:57:09 <kuffaar> djahandarie: Yes, IRC helped me a lot with mathematics
13:57:12 <kuffaar> And physic
13:57:14 <kuffaar> physics*
13:57:20 <test423432> which IRC can help me with math?
13:57:27 <solistic> kuffaar: where do you study, erlangen?
13:57:31 <kuffaar> freenode and EFnet #math
13:57:38 <sipa> #haskell can too
13:57:40 <kuffaar> solistic: Whatever gave you that idea? No, Karlsruhe
13:58:38 <test423432> which EFNet can help me the most XD? :p
13:58:39 <kuffaar> sipa: I think it's less suited for math in general, but it might be better for category theory than regular math channels
13:58:46 <kuffaar> test423432: It's one network
13:58:47 <solistic> kuffaar: "..butchered the compiler lectures.." ;)
13:58:52 <kuffaar> solistic: Oh, heh
13:59:09 <test423432> no I got here http://www.efnet.org/?module=servers where every server has different amount of people?
13:59:32 <kuffaar> solistic: I'd be forced to take 3 lectures on useless corporate/suit talk stuff about software development
13:59:39 <kuffaar> To take one lecture on compilers
13:59:47 <djahandarie> kuffaar, definitely. No one talks about category theory in #math, if they do it's only for like a second
13:59:54 <kuffaar> In the past you used to be able to do 50% real stuff and 50% corporate/suit talk
13:59:58 <djahandarie> Usually only abstract algebra over there
14:00:28 <kuffaar> But they decided to reduce it for some reason
14:00:28 <test423432> anybody uses mIRC?
14:00:34 <dafis> kuffaar: In the past, corporate/suit talk wasn't even invented yet
14:00:37 * kuffaar uses X-Chat
14:00:39 <test423432> I am pretty an idiot with that problem
14:00:43 <test423432> oh icic X-Chat
14:02:39 <kuffaar> dafis: You learn exciting stuff like choosing the right software development model for a particular project and how to document requirements formally so you can run a metric on that and the salary of your coders to predict the development time and the cost of a particular software project etc lol
14:03:29 <dafis> kuffaar: When I was young, not even the corporate executives would have dreamed of such gibberish :)
14:05:10 <kuffaar> dafis well I mean these techniques are actually used at a very high corporate level in bigger companies, having accurate predictions for the development time of a product and how much it will cost is pretty essential at a high level. I am just not really interested in it, it's just a total niche and probably won't ever have any professional implications for me.
14:05:10 <test423432> I wonder what I'm actually doing here as a economist
14:06:17 <kuffaar> test423432 yes, you are an unusual sight
14:06:24 <kuffaar> Almost everybody here is involved with CS academically
14:08:03 <j-invariant> my prgraom is borken
14:08:31 <kuffaar> j-invariant what are you using to deal with stuff like 1/2 + 1/3?
14:09:06 <kuffaar> Did you code a new instance of Num for rationals?
14:09:48 <ClaudiusMaximus> > 1/2 + 1/3 :: Rational -- there's one already, i thought?
14:09:48 <lambdabot>   5 % 6
14:09:55 <edwardk> back
14:10:00 <test423432> hi =)
14:10:04 <edwardk> yo
14:10:10 <test423432> I have a problem maybe you can help me out :P
14:10:12 <test423432> same as yesterday
14:10:17 <edwardk> uhoh
14:10:24 <test423432> it did not work XD
14:10:31 <test423432> none of all the method worked XD
14:10:32 <kuffaar> ClaudiusMaximus ah, nice
14:10:35 <kuffaar> I didn't know that
14:10:55 <edwardk> when you solved things in terms of 'a' 'b' and 'c' did you solve them such that a b and c were the first three letters or did you solve them such that you had three unknowns to plug in?
14:10:59 <ClaudiusMaximus> my code seems to work! http://claudiusmaximus.goto10.org/g/mandelbrot/lots-of-rays.png  (but it's sloooow, 7 seconds per ray pair)
14:11:08 <edwardk> such that the first three letters were functions thereof?
14:11:17 <test423432> yes
14:11:21 <test423432> I bruteforced it
14:11:23 <test423432> and it failed
14:11:31 <edwardk> then you messed up a step =)
14:11:40 <kuffaar> You shouldn't be brute forcing any of this :/
14:11:40 <test423432> Mathematica doesn't mess up a step I think XD
14:11:55 <test423432> the equations are the ones I got from Mathematica
14:12:03 <test423432> by applying the Solve command
14:12:12 <kuffaar> test423432 I already told you how this worked, although I am not sure about the integer constraint part which might be ILP related though
14:12:18 <test423432> kuffaar I agree, but there is NO WAY with my current math skills that I can solve this
14:12:27 <edwardk> kuffaar: he has something like 21 equations and 25 unknowns. he gets 3-4 variables left over. then he has to use the exclusivity condition to resolve the last few steps. linear algebra HELPS but isn't sufficient
14:12:43 <dafis> ClaudiusMaximus: Nice pic, any idea why it's so slow?
14:12:52 <test423432> 22 equations ;)
14:12:54 <kuffaar> edwardk: The null space has a dimension of 3 I think
14:13:06 <ClaudiusMaximus> dafis: profiling right now!  my guess is something stupid, like recomputing values that should be shared...
14:13:09 <edwardk> yes, so then he has a 3 dimensional nullspace to explore using _brute force_
14:13:34 <dafis> ClaudiusMaximus: Which library are you using to render?
14:13:37 <Taejo> ClaudiusMaximus: what is that picture?
14:13:42 <test423432> I've already written a bruteforce program but this would take I guess a decade XD :P
14:13:48 <kuffaar> edwardk: You can then multiply the base vectors with their greatest common denominator to get an integer only representation, for example, but it's not an algorithmic approach to fulfill the constraints
14:13:52 <edwardk> so he specifies the nullspace in terms of the first three answers he needs, then he can loop over them because they are known to be integers from 1 .. 26
14:14:09 <test423432> PS: edwardk your code partially worked =)
14:14:12 <kuffaar> edwardk: I thought that you might be able to turn this into an ILP problem and solve it with simplex/branch and bound to get integer solutions for the constraints
14:14:19 <edwardk> then he just has to search for a solution that satifies the constraints
14:14:37 <dafis> Taejo: Mandelbrot set
14:14:38 <edwardk> ILP can enforce the caps on the parameters, but not the exclusivity
14:14:50 <kuffaar> Exclusivity? What do you mean?
14:15:05 <test423432> that every letter is unique
14:15:07 <edwardk> he knows that each letter is an integer between 1 .. 26 and that they aren't used twice
14:15:16 <Taejo> dafis: I can see that it's related to the mandelbrot set, and I can also see that it *isn't* the mandelbrot set
14:15:18 <ddarius> > 26*25*24
14:15:18 <kuffaar> Well you can encode that, no?
14:15:19 <lambdabot>   15600
14:15:21 <ddarius> Not too bad.
14:15:40 <Taejo> or at least, it's something more than the mandelbrot set
14:15:41 <kuffaar> You can encode all kinds of strange conditions in ILP matrices
14:15:46 <edwardk> the search space is like 17000 items, and its trivial to check a case.
14:16:00 <Veinor> I just came with a great compromise for hoogle's 'search everything' vs 'search the platform' thing
14:16:09 <ddarius> edwardk: It's 15,600 items.
14:16:13 <edwardk> i would never want to try to encode uniqueness of 26 items as an ILP problem
14:16:14 <Veinor> give users a way to specify what to search by default
14:16:22 <edwardk> ddarius: i guesstimated. thanks =)
14:16:35 <test423432> ddarius how do you know that XD?
14:16:35 <dafis> Taejo: Okay, so my guess it's number of iterations until escape
14:16:49 <edwardk> the cure there is far worse than the disease.
14:17:06 <edwardk> > 26 * 25 * 24
14:17:07 <lambdabot>   15600
14:17:12 <test423432> oh ic
14:17:22 <test423432> well thanks to logic
14:17:26 <test423432> I was able to deduce a few things
14:17:40 <test423432> and I reduced it, making it only depend on a
14:17:48 <edwardk> test423432: did you perhaps flip a sign 
14:17:57 <test423432> what you mean?
14:18:11 <test423432> I probably did not, but uhm i show you the screenshots
14:18:13 <edwardk> i mean when you interpreted the row reduced equations
14:18:30 <kuffaar> edwardk oh it would require 26! / 23! additional constraints to encode that? That's a fair amount alright :p
14:18:44 <pumpkin> > product [24..26]
14:18:45 <lambdabot>   15600
14:18:54 <djahandarie> Is there a guide for using Agda to uh... actually prove things?
14:18:59 <ClaudiusMaximus> dafis: outputing textfile which i subsequently loaded into gnuplot
14:19:05 <kuffaar> djahandarie: Coq tutorials?
14:19:10 <ClaudiusMaximus> Taejo: external rays of the mandelbrot set
14:19:11 <test423432> http://www.wetenschapsforum.nl/index.php?showtopic=135623&st=0&gopid=653366&#entry653366 here is the screenshot
14:19:21 <test423432> of the computation Mathematica did (3rd post)
14:19:37 <kuffaar> I don't see any screenshots
14:19:42 <djahandarie> I want to know if my proof is right or not :(
14:19:44 <kuffaar> Ohh a link
14:19:51 <ddarius> djahandarie: Does it type check?
14:19:56 <test423432> try this: http://www.wetenschapsforum.nl/index.php?act=attach&type=post&id=7330
14:20:08 <djahandarie> ddarius, it's not written in type-checkable form yet :P
14:20:09 <edwardk> i need to register for an account… in dutch to get the file ;)
14:20:12 <kuffaar> test423432 it cannot be viewed by unregistered users, upload it to imgur.com or something like that instead
14:20:15 <test423432> here you go: http://www.wetenschapsforum.nl/index.php?act=attach&type=post&id=7330
14:20:19 <test423432> no account needed?
14:20:25 <ddarius> djahandarie: So simply express the proposition you'd like to prove as a type, and then write a term of that type.
14:20:28 <edwardk> Log hieronder in of http://www.wetenschapsforum.nl/index.php?act=Reg&CODE=00.
14:20:41 <test423432> olk
14:20:44 <test423432> Ill host it somehwere else
14:20:46 <ClaudiusMaximus> Taejo: http://www.math.nagoya-u.ac.jp/~kawahira/programs/mandel-exray.pdf explains the algorithm i'm using
14:20:48 <edwardk> k
14:20:57 <Taejo> ClaudiusMaximus: thanks
14:21:00 <djahandarie> ddarius, I want to prove that Rel is a category
14:21:04 <ddarius> ClaudiusMaximus: You should look at zeta function stuff too.
14:21:07 <test423432> http://img441.imageshack.us/img441/3285/solve.png
14:21:08 <ddarius> djahandarie: That should be easy.
14:21:11 <test423432> this should be the direct link
14:21:12 <test423432> http://img441.imageshack.us/img441/3285/solve.png
14:21:18 <j-invariant> test423432: my way did not work :/
14:21:25 <djahandarie> ddarius, right, but not when I have never done this before
14:21:36 <test423432> The values are stated here in the first post: http://www.wetenschapsforum.nl/index.php?showtopic=135623&st=0&gopid=653366&#entry653366
14:21:44 <test423432> j-invariant =( I failed to do this too
14:21:48 <kuffaar> test423432 you don't want that representation.
14:21:49 <j-invariant> test423432: I should try a different approach
14:21:52 <kuffaar> You want a matrix.
14:22:03 <kuffaar> You already used one, that is a step back from the matrix
14:22:23 <sipa> test423432: http://hackage.haskell.org/package/monadiccp
14:22:29 <ddarius> djahandarie: It should relatively straightforward to state the properties you want to prove in Agda, particularly as there are a number of CT libraries, and then it is a simple matter of hacking until it compiles.
14:22:36 <sipa> test423432: there's an alpha puzzle in the examples
14:22:41 <kuffaar> sipa: Hehe
14:22:55 <djahandarie> Okay, I'll tinker around then. I always seem to have trouble finding Agda code, compared to Haskell code at least
14:22:57 <test423432> let's see
14:23:40 <test423432> FDSolver?
14:24:05 * hackagebot functor-apply 0.9.2 - Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.9.2 (EdwardKmett)
14:25:49 <sipa> test423432: yes, but where do you see that?
14:26:19 <edwardk> sipa: guessing http://hackage.haskell.org/packages/archive/monadiccp/0.6.1/doc/html/Control-CP-FD-FD.html
14:26:46 <edwardk> test423432: can you paste the row-reduced matrix?
14:27:07 <edwardk> or the equational version of the problem?
14:27:21 <test423432> uhm yeah sure
14:27:21 <edwardk> i don't have mathematica installed on my mac
14:27:26 <test423432> wait a second
14:27:48 <Philippa_> edwardk: I should probably grab functor-apply for experimenting when I'm starting to do grammar rewrites and don't want to think /too/ hard about rearranging the 'computational' aspect of a parser, shouldn't I?
14:27:51 <sipa> test423432: if you can install the library, you should be able to ghc --make Alpha.hs in the examples directory
14:27:57 <Philippa_> (read: to do experiments with)
14:28:23 <edwardk> philippa: functor-apply provides the semigroup portion of applicative, alternative, monad, and comonad
14:28:25 <test423432> http://pastebin.com/kk1duVS3
14:28:35 <test423432> this should be the matrix in Mathematica style: http://pastebin.com/kk1duVS3
14:28:39 <test423432> the reduced row would be
14:29:10 <test423432> http://pastebin.com/QYAHkkRn
14:29:21 <Philippa_> edwardk: yep - so I can use it if I want to replace the pure stuff with a more limited range of mappings while I'm getting my head around restructuring when I feed data in. Or if I want to produce an output grammar that can be used to generate code in another language, or...
14:29:30 <test423432> {{...}, {...}, ...} this is the format
14:29:44 <Philonous> gienah: Turns out the size of _Bool is platform dependent. But my code has to integrate with other code that assumes bool = unsigned int, so when this doesn't hold I'm screwed anyway. Thanks for the hint
14:29:50 <edwardk> test423432: when you solved it, did you solve it using Rational or Float?
14:29:59 <kuffaar> test423432 and if you solve this you win 10000 EUR, based on the work of others? =)
14:30:09 <kuffaar> edwardk: Float.
14:30:14 <kuffaar> (later: Mathematica)
14:30:16 <test423432> no, you get a dvd from your birth year :P
14:30:22 <test423432> worth of 10 euro's
14:30:27 <kuffaar> lol
14:30:30 <test423432> there is 1 dvd
14:30:30 <edwardk> test423432: hah. you work cheap ;)
14:30:44 <test423432> and it will be randomly given away to the winner
14:30:48 <test423432> to A winner *
14:31:10 <test423432> the only thing I am doing this, is because I thought it would be fun
14:31:16 <edwardk> test423432: ok, finally do you have the mangled version of my function where you plugged in these equations?
14:31:25 <test423432> but now it's just an obsession to get the answer XD :P
14:31:26 <kuffaar> Sounds like a total ripoff/waste of time, lol, but yeah, solving problems can be fun/educational.
14:31:36 <test423432> yes :P I am putting it online
14:31:41 <test423432> if you give me permission
14:31:47 <edwardk> go for it
14:32:00 <Gabbie> Codegolf is prtty fun, and you don't even get a dvd for that
14:32:32 <merijn> I don't remember who, but there was a pretty interesting golf suggestion in here some time ago
14:32:40 <test423432> http://pastebin.com/PgmmQp4h
14:32:43 <test423432> source code
14:32:52 <test423432> kuffaar if you want the dvd I can send it
14:32:55 <merijn> "Longest running (not abnormally) terminating program in 140 chars or less"
14:32:57 <j-invariant> test423432: Here is an idea, Instead of turning the whole system into one matrix. Try to find a 2x2 matrix in there.. if not try to find a 3x3.. etc
14:33:13 <kuffaar> Haha, I thought about writing a silly browser game where you are given simple problems and you have to come up with Haskell code to solve them as quickly as possible and you are then evaluated based on how long it took you to solve it and how efficient your algorithm is :p
14:33:13 <test423432> XD that would take more time? or not?
14:33:13 <j-invariant> noticing that o = 1 is just a special case (the 1x1 case)
14:33:21 <j-invariant> test423432: I think this might work, I will try it out
14:33:28 <j-invariant> efficiently
14:33:34 <ClaudiusMaximus> woop, significantly speeded up by not writing braindead code :)  from 7 seconds down to 2 seconds per ray pair now...  [ i had something like:  a k = a' (a (k - 1)) ; b k = b' (a (k - 1)) (b (k - 1))   then fused into one function for a win:  ab k = ab' (ab (k - 1)) ]
14:33:35 <kuffaar> test423432: I have no interest in optical media, I download all my movies/series illegally online
14:34:03 <test423432> it's not downloadable at least I don't search for dvd's from 1993 :P
14:34:14 <kuffaar> I do.
14:34:22 <test423432> it only explains what happened in my year, but I can read that on Wikipedia too...
14:34:25 <kuffaar> I watch lots of older movies
14:34:31 <test423432> it's not a movie :p.
14:34:44 <kuffaar> Oh, what DVD is it then?
14:34:46 <test423432> it's something like history channel thing of your year :P
14:34:55 <kuffaar> o_o
14:35:07 <test423432> if you were born in 1945 then they will show you the war and other interesting stuff that happened
14:35:17 <test423432> it's only 1 hour long
14:35:53 <test423432> if it could win 1000 euro's I wouldn't post it on a dutch educational forum XD :P
14:37:15 <test423432> but at the moment I've learned so much XD, I always thought computer science was the key to everything... but now I see my limitations of brute forcing things XD
14:37:48 <roconnor> > 176 * atan (1/57) + 28 * atan (1/239) - 48 * atan (1/682) + 96 * atan(1/12943) :: CReal
14:37:49 <lambdabot>   3.1415926535897932384626433832795028841972
14:38:01 <test423432> > import Data.List
14:38:02 <lambdabot>   <no location info>: parse error on input `import'
14:38:14 <test423432> > :t nub
14:38:15 <lambdabot>   <no location info>: parse error on input `:'
14:38:27 <test423432> > nub [1,2,2,2,2]
14:38:29 <lambdabot>   [1,2]
14:38:59 <sipa> test423432: where is the problem specification?
14:39:15 <test423432> uhm I have to tell you XD
14:39:18 <test423432> as it's in dutch :p
14:39:24 * sipa understands dutch
14:39:25 <test423432> or you can look somewhere above
14:39:30 <test423432> oh ICIC :D :P!
14:39:40 <test423432> sipa how did you do that?
14:39:41 <test423432> http://www.wetenschapsforum.nl/index.php?showtopic=135623&st=0&gopid=653366&#entry653366
14:39:54 <test423432> how do you type sipa understands dutch? :P
14:40:22 <edwardk> test423432: working on it
14:40:26 <Botje> test423432: put /me at the start of your line
14:41:32 <test423432> (I'm actually more interested in the process than solution ;))
14:41:42 <edwardk> test423432: hrmm, i'll say this, eyeballing it, it doesn't look like you flipped a sign
14:42:09 <test423432> yeah a friend of mine reviewed my work too
14:42:15 <test423432> he couldn't find an error either
14:42:28 <ivanm> it seems that parsing using Text doesn't affect performance; _printing_, using Text, does :/
14:42:28 <test423432> Mathematica can't be wrong (as the company is pretty big)
14:42:55 <ClaudiusMaximus> > length "let x = maxBound ; i = toInteger x ; up 1 = i ; up j = let k = up (j - 1) in k ^ k in genericReplicateM_ (up i) (threadDelay x)"
14:42:57 <lambdabot>   127
14:43:09 <int80_h> http://hpaste.org/43344/trying_to_map_over_a_string
14:43:54 <int80_h> not realy trying to map over a String, but a [String].
14:44:27 <edwardk> well if i replace your validation with all (\x -> x >= 1 && x <= 26) — i still bomb out
14:44:37 <edwardk> so even removing the uniqueness constraints isn't enough
14:44:53 <test423432> oh sorry forgot to tell you that
14:44:53 <edwardk> (and after i converted to Rational
14:45:06 <test423432> there is something more you should know
14:45:20 <test423432> you see there are two commented out sections right?
14:45:29 <edwardk> yeah i flipped to the third
14:45:31 <test423432> the lowest section was the original problem
14:45:34 <test423432> yes that's right!
14:45:48 <test423432> the first is one where I've used logic with
14:45:56 <test423432> the second is a intermediate step between them.
14:46:05 <test423432> (meaning I used partial logic XD :P)
14:46:15 <Botje> int80_h: the order of your arguments is wrong
14:46:25 <edwardk> so logic was just going through and checking to see where the constraints said it was impossible for b to be greater than some number etc?
14:46:38 <Botje> you want mapM (\url -> curlResp curl' url resourceOpts)
14:46:48 <test423432> edwardk no logic was used to solve this problem partially
14:46:49 <Botje> or mapM (flip (curlResp curl' resourceOpts)
14:46:49 <int80_h> Botje, thanks
14:47:02 <test423432> a few dutch people have deduced that g = 4, but I don't know the reason behind it
14:47:09 <Botje> int80_h: and if you're not interested in the response of the mapM, you can use mapM_
14:47:12 <int80_h> Botje, how did you arrive at that? I had difficulty thinking about this problem
14:47:30 <test423432> after collecting all the info people have worked on it, I've created the first uncommented solution
14:47:33 <Botje> int80_h: I looked at the type of curlResp, and the types of the arguments you give it
14:47:44 <int80_h> Thank you
14:47:46 <edwardk> ?
14:48:02 <edwardk> so you have the answer and now want to motivate it?
14:48:09 <test423432> no, I do not have it :p
14:48:12 <sipa> test423432: i have the solution :)
14:48:18 <test423432> YOU MUST BE KIDDIN GME?
14:48:20 <test423432> XD :P
14:48:22 <edwardk> sipa: hah
14:48:22 <sipa> no
14:48:22 <test423432> seriously XD?
14:48:25 <sipa> yes
14:48:25 <edwardk> fast =)
14:48:31 <test423432> how...
14:48:36 <test423432> did you do it by hand?
14:48:37 <edwardk> what'd i miss?
14:48:42 <sipa> no, using that library
14:48:48 <edwardk> hahahaha
14:48:48 <test423432> ...???!!!
14:48:52 <test423432> what??!?!!
14:48:55 <sipa> there was already an alpha puzzle as example
14:48:55 <test423432> XD
14:49:00 <sipa> so i changed the data
14:49:01 <test423432> I couldn't find that one
14:49:11 <test423432> :$
14:49:27 <sipa> just this: http://hackage.haskell.org/package/monadiccp
14:49:31 <sipa> it's an old version though
14:49:42 <sipa> but it already has the alpha puzzle example
14:49:58 <test423432> Control.CP.FD.Example.Example here?
14:50:05 <sipa> no, the whole library
14:50:13 <sipa> not some specific module in it
14:50:33 <test423432> Im not familiar how this works XD where can I see the example?
14:50:34 <sipa> takes 0.02s to solve it ;)
14:50:41 <sipa> test423432: download it
14:50:49 <edwardk> =)
14:50:50 <sipa> there's a link at the bottom
14:50:51 <uberfry> whaddup geeeeeeeeeks, jk ;D
14:51:12 <edwardk> ah yeah the library is pretty easy for this one
14:51:22 <uberfry> question... is there any easy way to extract bits from an input? or how do I shift and mask please?
14:51:22 <test423432> uhm...
14:51:27 <applicative> ivanm, what are you using to parse Text?
14:51:29 <test423432> do I need to install it?
14:51:32 <uberfry> I'd like to try making a disassembler
14:51:33 <Botje> uberfry: look at Data.Bits
14:51:38 <uberfry> ok thanks :)
14:51:44 <Botje> uberfry: ah. then also look at some existing disassemblers
14:51:45 <sipa> yes, and you'll also need gecode (the C++ library that does the actual solving)
14:51:51 <ivanm> applicative: polyparse
14:52:03 <test423432> uhm...
14:52:08 <test423432> does this works on Windows?
14:52:11 <uberfry> Botje: do I need to include?
14:52:12 <ivanm> I don't think malcolmw has released the version with it yet though
14:52:16 <int80_h> Botje, I'm getting another error. 
14:52:20 <sipa> test423432: never tried windows i'm afraid
14:52:24 <sipa> but there's a chance it works :)
14:52:25 <int80_h> Botje, http://hpaste.org/paste/43344/trying_to_map_over_a_string#p43345
14:52:25 <test423432> I've extracted it and I should press Setup.hs?
14:52:36 <test423432> normally I use cabal install packagename
14:52:36 <Botje> uberfry: http://hackage.haskell.org/package/disassembler looks interesting.
14:52:42 <sipa> cabal install monadiccp
14:52:42 <Botje> uberfry: and yes, you need to import Data.Bits
14:52:52 <uberfry> Botje: how do I do that please?
14:52:54 <sipa> or you can do it manually, too
14:53:11 <test423432> I did it wrong once
14:53:16 <edwardk> monadiccp is tricky to install, it requires old versions of stuff
14:53:21 <test423432> and it went badd...
14:53:32 <int80_h> when good monads go bad
14:53:43 <sipa> i might upload a new version somewhere in the future, this one is quite outdated
14:53:45 <int80_h> next time, on "The Monad Reader"
14:53:46 <Botje> uberfry: "import Data.Bits"
14:53:52 <uberfry> ok thanks
14:53:52 <test423432> one question
14:53:58 <test423432> it says solver type required?
14:54:08 <sipa> use gecode_run
14:54:17 <kuffaar> uberfry or if you want to try it in ghci first: :m +Data.Bits
14:54:45 <test423432> sorry sipa I don't know what you're saying actually XD
14:54:50 <Botje> int80_h: if i read the error correctly, the MonadError instance for IO forces you to use IOError as your exception
14:54:51 <test423432> I've installed the library using cabal
14:54:57 <kuffaar> :t runReaderT
14:54:58 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
14:55:03 <Botje> so you can't use String
14:55:07 <Botje> but now i really have to go to sleep
14:55:08 <test423432> but I don't know how to run it :( sorry for my stupid questions :(
14:55:11 <Botje> up in 6 hours 
14:55:11 <mun> with this FOL formula "forall x. x \in S --> f(x) < g(x)", does it imply that S is the universe?
14:55:12 <sipa> test423432: no problem
14:55:13 <edwardk> btw- if you tweak the monadiccp cabal file to add the constraint mtl < 2 it compiles
14:55:41 <test423432> so how do I run it XD? :P
14:55:53 <test423432> I click: Alpha.hs, type main, but it says solver type required
14:56:17 <sipa> i have no idea what happens when you "click"
14:56:29 <test423432> It suppose to start GHCi
14:56:35 <test423432> and load Alpha.hs
14:56:44 <test423432> and it does
14:56:46 <sipa> but it takes a command line argument, the solver you want to use
14:56:51 <kuffaar> test423432: I think you should just stop investing time into this, whatever is going to happen at this point, it is likely that almost all of the actual work will be done by other people and you still won't understand how it works even when it is solved, which ruins the entire purpose :p
14:57:13 <int80_h> Botje, thanks. :) I'll keep at it.
14:57:20 <test423432> kuffaar yes, but I might reverse it
14:57:20 <applicative> ivanm, I see, I was wondering if people were making progress with parsing Text.  A naive Stream instance with parsec wasn't doing me much good, but that could be me of course.
14:57:24 <test423432> from solution -> problem
14:57:34 <test423432> instead of problem -> solution
14:57:48 <sipa> test423432: anyway, there's a very simple solver (written in haskell) built in, which is very slow
14:58:04 <sipa> which doesn't seem to be able to solve it in any reasonable time
14:58:20 <sipa> but it can also use a low-level library for solving, called gecode
14:58:26 <ivanm> applicative: there's also attoparsec-text
14:58:27 <ivanm> but the polyparse text instance is quite nice
14:58:27 <ivanm> does c.h.o also contain planet.haskell ?
14:58:47 <sipa> but you'll need to have that installed first, and unfortunately i have no idea how that is done on windows
14:59:03 <test423432> I thought that should be installed
14:59:08 <test423432> after I do cabal install
14:59:14 <sipa> before
14:59:30 <int80_h> The last statement in a 'do' construct must be an expression
14:59:40 <int80_h> would not return be considered an expression?
14:59:45 <sipa> it would
14:59:50 <int80_h> huh
15:00:00 <sipa> but that error often signifies bad indenting
15:00:11 <int80_h> okay I'll look at that
15:00:18 <test423432> sipa can you give me the solution?
15:00:24 <test423432> so I can work my way back?
15:00:33 <test423432> I want to know what I did wrong
15:00:41 <ClaudiusMaximus> ... so, ~3.5x speedup by eliminating stupid code, and another 100x speedup on top by switching to Double instead of QuadDouble -> 0.02s per ray pair
15:00:43 <sipa> if you want me to, sure :)
15:00:48 <sipa> it may spoil the fun for you
15:01:00 <test423432> hmm...
15:01:06 <test423432> can you tell me if g = 4?
15:01:07 <sipa> a is 18
15:01:19 <sipa> g is 4 yes
15:01:21 <edwardk> sipa: i have the example adapted how do i select the solver?
15:01:30 <sipa> edwardk: command-line argument
15:01:33 <test423432> yes I was wondering about that too! :P
15:01:45 <edwardk> bah =) actually compiling code
15:02:02 <sipa> ?
15:02:09 <test423432> sipa could you tell me a b and c?
15:02:16 <edwardk> was running it from ghci ;)
15:02:21 <test423432> then I can deduce why Mathematica is failing
15:02:22 <sipa> 18 12 17
15:02:26 <applicative> ivanm, I see, I think the attoparsec things weren't up the last time I was thinking about it.  Must study.  
15:02:48 <applicative> of course the darcs version of polyparse is on code.haskell.org
15:02:52 <sm> http://kitenet.net/~joey/blog/entry/three_thousand_lines_of_Haskell/ has some nice experience notes
15:02:54 <ivanm> yeah :s
15:03:08 <applicative> i see, you alluded to this.
15:03:19 * hackagebot crypto-api 0.4.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.4.1 (ThomasDuBuisson)
15:03:21 <ivanm> applicative: I was about to offer to put a tarball up somewhere, then realised I was going to put it up on c.h.o :p
15:03:25 <test423432> sipa is z = 3?
15:03:29 <test423432> and u = 2?
15:04:02 <uberfry> can someone please take a look? http://hpaste.org/43346/decoder
15:04:10 <uberfry> it tells me no constructor for the types
15:04:12 <applicative> ivanm, now that I know about it, I can look into it later, thanks.
15:04:21 <ivanm> np
15:04:37 <edwardk> sipa: i have to admit this solver isn't very friendly about telling you about what arguments it wants ;)
15:04:38 <ivanm> applicative: very simplistically, it's just the bytestring instance but for lazy text values
15:05:24 <int80_h> http://hpaste.org/paste/43344/trying_to_map_over_a_string#p43347
15:05:32 <int80_h> this is a parse error now
15:05:38 <sipa> edwardk: i agree
15:05:40 <int80_h> until I fix it and see what else is going on
15:05:53 <sipa> edwardk: maybe i should look at :)
15:05:58 <int80_h> but I can't figure out where my indentation goes wrong. I've tried a few things...
15:06:33 <sipa> test423432: both correct
15:07:08 <dafis> int80_h: forgot a ')', mapM_ (flip (curlResp curl' resourceOpts))
15:07:08 <sipa> int80_h: put the do on a separate line
15:07:18 <test423432> edwardk
15:07:35 <test423432> this is the solution right: [18, 12, 17, 9, 5, 7, 4, 10, 24, 25, 16, 19, 23, 1, 20, 14, 22, 8, 21, 2, 6, 26, 11, 15, 3]
15:07:41 <test423432> ?
15:07:44 <dafis> int80_h: sorry for the typo
15:07:57 <dropdrive> Newbie question.  Suppose I define x = 1 : ...something-involving-x...  When I do something like x !! 3, where is it guaranteed that something-involving-x will actually examine the x that is in the process of being constructed?
15:08:06 <int80_h> dafis no worries
15:08:16 <test423432> sipa, is the solution correct: [18, 12, 17, 9, 5, 7, 4, 10, 24, 25, 16, 19, 23, 1, 20, 14, 22, 8, 21, 2, 6, 26, 11, 15, 3]?
15:08:21 <sipa> no
15:08:40 <Saizan> uberfry: things defined with let need to start with a lowercase letter
15:08:41 <Veinor> dropdrive: what do you mean?
15:08:45 <Veinor> could you give a more concrete example?
15:08:51 <edwardk> right now i just can't figure out how to run the problem i compiled ;)
15:08:54 <test423432> hmm weird could you pastebin the solution? I would like to know whether it is because of Haskell or Mathematica XD
15:08:56 <Saizan> uberfry: only data constructors start with an uppercase one
15:09:04 <sipa> edwardk: ./Alpha gecode_run
15:09:13 <dafis> int80_h: Oh, and with the mapM_, there's no need for the return ()
15:09:37 <edwardk> sipa: i don't have gecode installed i'm guessing so the flag didn't toggle on, i tried the others but i get unresolved lambdas, etc.
15:10:37 <kuffaar> http://siyobik.info/pastebin_download.php?id=579 <- I am trying to code a small function which allows me to use forkIO with a ReaderT such that the new thread will use the same monadic environment. My signature for the function is wrong though. This actually compiles if I don't use the signature and GHC produces transferReader :: forall r (m :: * -> *) a. MonadReader r m => ReaderT r m a -> m a for this case. I am not even entirely sure what this means. D
15:10:37 <kuffaar> oes MonadReader r m mean that both r and m must be instances of MonadReader?
15:10:37 <Saizan> dropdrive: i'm not sure about where, but that's a property that GHC and all non-toy compilers will respect (assuming x's type doesn't have a typeclass context)
15:10:43 <int80_h> dafis, thanks. I'm almost there (I think)
15:10:47 <kuffaar> :t runReaderT
15:10:48 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
15:10:48 <sipa> test423432: no 13 in your example?
15:10:52 <sipa> *solution
15:11:05 <test423432> oh ic
15:11:05 <edwardk> ah got it
15:11:06 <kuffaar> So, I got the ReaderT r m a part for the body right
15:11:13 <test423432> because that's the K
15:11:16 <Heffalump> kuffaar: MonadReader r m means that m must be some kind of reader monad with environment type r
15:11:17 <test423432> I KNOW WHAT I DID WRONG!
15:11:21 <test423432> OMG OMG!
15:11:23 <test423432> I KNOW IT :D :P
15:11:30 <Saizan> dropdrive: i.e. it's guaranteed by lazy evaluation, but the haskell standard only requires a non-strict evaluation
15:11:31 <tg_> simmer down now
15:11:32 <test423432> edwardk I forgot to state to you
15:11:35 <test423432> we did not have the k!
15:11:37 <kuffaar> I figured the m a part has to be ReaderT'ified for that, too, otherwise you can't even use ask within that context
15:11:40 <test423432> so your function to validate it failed!
15:11:40 <edwardk> sipa: actually i got test's solution
15:11:56 <edwardk> meh =P
15:11:57 <test423432> sipa is k = 13?
15:11:58 <kuffaar> Heffalump: Oh, so it's a composite type after all, I had never seen it with more than one variable before
15:12:07 <Heffalump> it's a type constraint
15:12:14 <Heffalump> called a multi-parameter type class
15:12:26 <edwardk> > sort [18,12,17,9,5,7,4,10,24,25,16,19,23,1,20,14,22,8,21,2,6,26,11,15,3]
15:12:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,17,18,19,20,21,22,23,24,25,26]
15:12:30 <edwardk> yes =)
15:12:31 <ddarius> edwardk: Always go to the sources.
15:12:33 <sipa> yup
15:12:47 <test423432> OMG OMG :P my solution is correct right?
15:12:52 <edwardk> yes
15:12:54 <test423432>                where solution = [18, 12, 17, 9, 5, 7, 4, 10, 24, 25, 16, 19, 23, 1, 20, 14, 22, 8, 21, 2, 6, 26, 11, 15, 3, 13]
15:12:54 <applicative> uberfry is this more what you meant? http://hpaste.org/paste/43346/decoder_annotation#p43348
15:12:58 <test423432> this is correct except for the k
15:13:06 <sipa> it's correct, k is just missing
15:13:11 <test423432> IT WORKED :D :P MATH ACTUALLY WORKED :P!
15:13:16 <edwardk> hah
15:13:18 <uberfry> thanks alot saiam applicative :D
15:13:20 <sipa> congrats :)
15:13:27 <test423432> thanks everyone!
15:13:30 <edwardk> of course, constraint solving would have solved it just as well ;)
15:13:35 <uberfry> yes applicative
15:13:40 <uberfry> brb
15:13:43 <kuffaar> > let x = [18,12,17,9,5,7,4,10,24,25,16,19,23,1,20,14,22,8,21,2,6,26,11,15,3] in length x `compare` (nub x)
15:13:44 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:13:44 <lambdabot>         against inferred type ...
15:13:48 <kuffaar> :(
15:13:53 <kuffaar> Woops, length*
15:14:25 <edwardk> > let x = [18,12,17,9,5,7,4,10,24,25,16,19,23,1,20,14,22,8,21,2,6,26,11,15,3] in (compare `on` length) x (nub x)
15:14:26 <lambdabot>   EQ
15:14:39 <kuffaar> Oh yeah that's prettier
15:14:49 <Saizan> kuffaar: transferReader m = do e <- ask; lift (runReaderT m e) -- this would have the type stated in your code, but it wouldn't be very useful for forkIO
15:14:56 <test423432> now I'm gonna try something else
15:15:25 <edwardk> test423432: have you put in for your dvd before the internets reads the logs here and beats you to it? =)
15:15:27 <Saizan> yours wouldn't either..
15:15:39 <kuffaar> Saizan: :(
15:15:51 <test423432> I will not send my solution in
15:16:01 <test423432> as you guys deserve it more than me
15:16:16 <ddarius> sipa already has the DVD.
15:16:23 <kuffaar> lol.
15:16:27 <test423432> but I only needed to change the code to == 25 and it worked XD
15:16:32 <uberfry> nice, my decoder works ;D
15:16:36 <edwardk> hah
15:16:43 <uberfry> with hex even
15:16:52 <kuffaar> Saizan: Oh, wait, I thought you said my original code was useless for forkIO, too
15:16:54 <tg_> :t nub
15:16:56 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:17:11 <dropdrive> Veinor: I'm just saying that, if GHC were really dumb, then "let x = 0 : 1 : zipWith (+) x (tail x)" might be exponential time.  But I think Saizan explained...
15:17:14 <sipa> test423432: van waar ben je?
15:17:19 <kuffaar> > nub "Haskell causes cancer"
15:17:20 <lambdabot>   "Haskel cunr"
15:17:23 <kuffaar> That's right
15:17:48 <tg_> > nub nub "Haskell causes cancer"
15:17:50 <lambdabot>   Couldn't match expected type `[a]'
15:17:50 <lambdabot>         against inferred type `[a1] -> [...
15:18:01 <Saizan> kuffaar: as written yes, but it works with a simple modification: transferReader m = do e <- ask; liftIO (forkIO (runReaderT m e))
15:18:10 <dropdrive> Saizan: Thanks.
15:18:13 <ddarius> tg_: nub is idempotent.
15:18:20 <tg_> ddarius: yes
15:18:34 <kuffaar> Saizan: Well it's not supposed to do the actual forkIO itself, I wanted to keep it generic hmm
15:18:35 <Saizan> dropdrive: np
15:18:45 <kuffaar> Although I don't really have any other use case for it right now other than forkIO'ing
15:18:48 <theorbtwo> > nub (nub "This is a test.  This is only a test.")
15:18:49 <lambdabot>   "This ate.only"
15:19:14 <int80_h> I've cleaned things up a bit, and the larger problem has been revealed.
15:19:18 <int80_h> http://hpaste.org/paste/43344/trying_to_map_over_a_string#p43349
15:19:45 <Saizan> kuffaar: transferReader k m = do e <- ask; k (runReaderT m e), then use it like "transferReader (liftIO . forkIO) ..."
15:20:10 <kuffaar> Oh it would take the function then hm
15:21:13 <edwardk> test423432: yeah you had the right solution, it was the == 26 you copied from me that broke you =)
15:21:25 <Saizan> int80_h: what's the type of curlResp?
15:21:50 <test423432> yesh XD
15:22:18 <test423432> thanks guys
15:22:23 <test423432> I've learned a lot =)
15:22:29 <test423432> I feel a lot smarter already ahahhahaaha :P!
15:22:52 <int80_h> Saizan : > curlResp
15:22:52 <int80_h> >   :: (MonadError String m, MonadIO m)
15:22:53 <int80_h> >   => Curl -> URLString -> [CurlOption] -> m String
15:22:53 <lambdabot>   <no location info>: parse error on input `::'
15:22:54 <lambdabot>   <no location info>: parse error on input `=>'
15:23:00 <kuffaar> Saizan: I feel so terrible for having GHC determine the type signatures for me
15:23:07 <edwardk> oh wait
15:23:09 <edwardk> there is a bug =)
15:23:24 <kuffaar> I stare in awe at the constraints it generates
15:23:27 <int80_h> Saizan that looks horrible, I will paste it
15:23:48 <int80_h> Saizan: http://hpaste.org/paste/43344/trying_to_map_over_a_string#p43350
15:23:50 <ClaudiusMaximus> i'm still stunned by how slow libqd :(  same program recompiled with [Float, Double, DoubleDouble, QuadDouble] took [3.6, 4.6, 353, 468] seconds
15:23:58 <Saizan> int80_h: that "MonadError String m" is your problem, it means m can't be IO
15:24:22 <pumpkin> ClaudiusMaximus: do you use realToFloat?
15:24:39 <Saizan> int80_h: you can use it with m = ErrorT String IO though, and use runErrorT to convert it to an IO action
15:24:48 <pumpkin> realToFrac, I mean
15:25:02 <ClaudiusMaximus> pumpkin: not explicitly, as far as I can tell
15:25:21 <int80_h> Saizan: I understood the second thing you said (used runErrorT before) but not the first thing.
15:25:39 <ClaudiusMaximus> pumpkin: but i hazard a guess that Data.Complex does voodoo decodeFloat/encodeFloat stuff, which in this case is likely to be sloooow
15:25:41 <pumpkin> ClaudiusMaximus: the issue might be that most realToFrac conversions get rewritten because the actual implementation of the function is horrendously slow
15:25:52 <edwardk> test423432: when i run the function you gave me to expand it, for (18,12,17) all the numbers checked out except v
15:25:55 <pumpkin> but the new types don't have rewrite rules?
15:26:01 <pumpkin> so conversions jump through Rational
15:26:08 <Saizan> int80_h: are you familiar with MonadError?
15:26:19 <pumpkin> ClaudiusMaximus: I'd look and see if you can find any obvious differences in the core
15:26:26 <test423432> except v?
15:26:41 <int80_h> Saizan: no, it was a someone elses suggestion. I expect I will become more familiar with it now though.
15:26:42 <test423432> you mean using the last solution or the first?
15:26:44 <edwardk> i got [18,12,17,9,5,7,4,10,24,25,16,19,23,1,20,14,22,8,21,2,210,26,11,15,3] by plugging in expand
15:26:47 <ClaudiusMaximus> pumpkin: well in earlier code i didn't bother to implement most of RealFloat - but then i couldn't use Data.Complex as it crashed with "exponent not defined" or similar
15:26:52 <edwardk> using the last solution
15:26:59 <int80_h> Saizan: it was the result of me trying to take my toy code and add error handling to it
15:27:10 <int80_h> Saizan: and this is my first attempt ever at doing that.
15:27:11 <Saizan> int80_h: it's a typeclass for monads that can deal with errors, in fact
15:27:18 <test423432> I have a typo at v probably
15:27:22 <edwardk> yeah
15:27:26 <ClaudiusMaximus> pumpkin: there'll be massive differences - libqd is C++ with a C wrapper interface with a FFI wrapper interface into haskell...
15:27:26 <edwardk> so two bugs =)
15:27:30 <test423432> whaha let me check
15:28:00 <edwardk> > 301 - (17*18)/2 - (12/2) + 17*c
15:28:00 <lambdabot>   301 - 17 * 18 / 2 - 12 / 2 + 17 * c
15:28:02 <Saizan> int80_h: an instance of MonadError T M, means that the monad M can throw and catch errors of type T
15:28:15 <edwardk> woops
15:28:23 <int80_h> Saizan: that much I know. But I don't really know how to use it. it's "Monkey see, monkey do" at this point.
15:28:30 <edwardk> > 301 - (17*18)/2 - (12/2) + 4*17
15:28:30 <lambdabot>   210.0
15:28:52 <test423432> indeed
15:28:55 <test423432>                                 301 - (17*a)/2 - (b/2) - 8*c     , -- v
15:28:58 <test423432> v should be this
15:29:02 <edwardk> ah
15:29:23 <edwardk> ok, that explains why flipping to rationals, etc. didn't help
15:29:24 <Saizan> int80_h: since MonadError e m has a functional dependency "m -> e", then each monad can only have one instance of MonadError, so each monad can only support errors of one single type
15:29:26 <ClaudiusMaximus> pumpkin: i think what i should do is write some (shudder) C++ that implements the same code; and compare it
15:29:32 <edwardk> now i can put this down ;)
15:29:39 <test423432> I need to test it first :P
15:29:52 <test423432> ok it worked
15:29:57 <test423432> now I can sleep :p
15:29:59 <test423432> thanks guys
15:30:03 <Saizan> int80_h: but IO is already MonadError IOException IO, so you can't use it when your errors are of type String, like in curlResp
15:30:06 <int80_h> Saizan: I just got slammed at work. Be back in about 15 minbutes
15:30:13 <int80_h> hold that thought
15:30:40 <test423432> one question everyone that helped me XD, do you guys have a good job XD? (just wondering because you guys are probably smarter than me XD so I can look forward to my furture XD)
15:31:11 <Saizan> int80_h: let me know if you have more questions :)
15:31:20 <tg_> test423432: this is IRC, we don't have jobs!
15:31:26 <test423432> :P lolz
15:31:40 <kuffaar> I've been unemployed for 24 years
15:31:47 <tg_> plus, everyone knows that haskell can't be used for "real world" things
15:31:47 <parcs> does there exist syntactic sugar for datum { getField = f $ getField datum } ?
15:32:14 <kuffaar> I figured putting Haskell on my CV would make me less likely to be hired, that's why I started learning it
15:32:21 <test423432> kuffaar seriously XD?
15:32:32 <Twey> parcs: Sadly no
15:32:42 <test423432> Haskell = good right XD?
15:32:49 <test423432> everything is going into the functional direction =)
15:32:52 <kuffaar> Haskell is a cancer of the mind
15:32:57 <ivanm> Twey: not even with lenses, etc, ?
15:33:00 <edwardk> @hpaste
15:33:01 <lambdabot> Haskell pastebin: http://hpaste.org/
15:33:01 <Twey> parcs: But the fc-labels package has some interesting stuff
15:33:10 <test423432> kuffaar lol :P
15:33:18 <Twey> ivanm: I don't think there's any sugar for it… there're surely some helpers
15:33:26 <ivanm> oh, right
15:33:38 <edwardk> test423432: http://hpaste.org/43351/the_dutch_drinking_problem 
15:34:03 <edwardk> just for posterity =)
15:34:30 <test423432> :P whaha
15:35:11 <kuffaar> edwardk: lol you bruteforced the null space vectors? Lame
15:35:19 <kuffaar> How unsystematic.
15:35:21 <edwardk> test423432: and the constraint version: http://hpaste.org/paste/43351/the_dutch_drinking_problem__l#p43352
15:35:36 <kuffaar> Now that's what I'm talking about :)
15:35:43 <edwardk> kuffaar: it was checking to see if the solutions matched
15:36:04 <kuffaar> Although why does it say 107? I thought it was 108
15:36:04 <edwardk> i believe i had hand substituted o in that one
15:36:12 <kuffaar> Oh
15:36:22 <edwardk> just before i started
15:36:36 <test423432> :P
15:37:48 <kuffaar> test423432 languages somewhat similar to Haskell have been around for close to 40 years now, without any major influence on the 15 most popular programming languages really?
15:38:11 <edwardk> i want to put up a new version of FDSolver using the tricks from ersatz though to clean up the grammar =)
15:39:07 <edwardk> that way it could be model = exist $ \ a b c d e f … z -> 
15:39:08 <kuffaar> When I express my interest in a language which isn't widely used commercially I usually get made fun of by professional developers
15:39:24 <edwardk> meh. herd mentality
15:39:49 <kuffaar> They said if they saw anything like Lisp or Haskell on my CV they would intentionally throw it away
15:39:55 <pumpkin> lol
15:39:59 <kuffaar> Because it means I'm an academic idiot who can't code for shit
15:40:00 <ivanm> OK, normally when I enable profiling it takes twice as long... this time it's taken about _4_ times as long :s
15:40:09 <edwardk> if someone would throw away my resume because of the words haskell or lisp i probably wouldn't want to work there
15:40:12 <pumpkin> kuffaar: I'd throw away their job ad ;)
15:40:26 <ddarius> Certainly none of the fifteen most popular languages have garbage collection, higher order functions, parametric polymorphism, or means to limit mutability.
15:40:26 <merijn> kuffaar: I don't think you re right saying haskell like languages have not had any influence on the 15 most popular languages
15:40:38 <kuffaar> merijn: I said *major*
15:40:45 <edwardk> this leads to a remarkable symmetry in the search parameters ;)
15:40:48 <kuffaar> Obviously there is LINQ in C#, for example
15:40:49 <merijn> I'm pretty sure python is top 15 and they literally copied list comprehensions from haskell
15:41:00 <kuffaar> Or stuff like that
15:41:03 <merijn> Also, generators are haskell inspired
15:41:12 <kuffaar> But other than that those languages are all pretty much the same
15:41:13 <merijn> Those things are pretty major parts of python
15:41:13 <pumpkin> except just don't iterate over two separate collections in python's comprehensions
15:41:23 <pumpkin> (http://web.mit.edu/rwbarton/www/python.html)
15:41:29 <kuffaar> OOP and a = f(b)
15:41:42 * ddarius strengthens pumpkin's statement to "except just don't use python."
15:41:52 <ivanm> pumpkin: you're interested in graph DBs, aren't you?
15:42:04 <jacobian> @pl concat $ intersperse " " $ map (\ (x,ty) -> x++":"++show_type ty tctx) xs
15:42:04 <lambdabot> join (intersperse " " (map (uncurry ((. ((':' :) . flip show_type tctx)) . (++))) xs))
15:42:18 <kuffaar> pumpkin is actually an odd exception to me, since he also hangs out in ##re, it seems
15:42:20 <merijn> ddarius: Yeah, you're much better of using Java and C#!
15:42:31 <kuffaar> pumpkin most crackers/RE people I know are huge language fascists
15:42:32 * hackagebot network 2.3.0.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.1 (JohanTibell)
15:43:12 <pumpkin> kuffaar: I'm convincing my fellow reversers to use haskell too
15:43:15 <ddarius> merijn: You are much better off using at least C#.
15:43:17 <kuffaar> ;D
15:43:22 <pumpkin> kuffaar: well, along with jix
15:43:29 <kuffaar> Oh, I don't think I know anything about him
15:43:37 <pumpkin> I don't think I've ever seen him speak in here :)
15:43:51 <ivanm> pumpkin: you might find this talk interesting (I can give you the streaming address once it's posted): http://lca2011.linux.org.au/programme/schedule/view_talk/184?day=thursday
15:43:57 <merijn> Someone just remarked that computer scientists are the opposite of mathematicians (trying to make complex things simple vs making simple things complex), wouldn't that make mathematicians mputer scientists? :D
15:44:03 <kuffaar> I know one guy who used to be heavily involved with cracking who is a huge Common Lisp nerd
15:44:14 <kuffaar> But other than that most of them only accept C and ASM
15:44:18 <ivanm> merijn: that sounds like a load of garbage to me
15:44:19 <kuffaar> Sometimes C++ if I get lucky
15:44:22 <pumpkin> kuffaar: rolfr on the reverse engineering subreddit is also an FP guy
15:44:28 <kuffaar> Yeah I know
15:44:29 <pumpkin> kuffaar: he posts the vast majority of the stores on there 
15:44:30 <kuffaar> He's into OCaml
15:44:32 <pumpkin> yep
15:44:33 <merijn> ivanm: Of course it is, but don't ruin my bad math joke :<
15:44:49 <kuffaar> pumpkin I wouldn't know him from any website btw, I just know him from ##re
15:44:52 <merijn> ddarius: Can you provide any argumentation other then "just because" for that claim?
15:44:54 <pumpkin> ah ok
15:45:24 <pumpkin> ddarius: I can agree with your strengthening
15:45:29 <pumpkin> ivanm: yep I am
15:46:28 <ivanm> that talk is going to be on in 4.5 hours from now, streamed if nothing goes wrong
15:46:43 <ddarius> merijn: Types.  More concise lambdas.  Better documentation.  More libraries.  Better performances.  Less broken semantics.  readonly.  Access modifiers.
15:46:43 <jacobian> I don't think I can imagine feeling better off from using java. 
15:46:46 <pumpkin> ivanm: cool, thanks :) can you ping me closer to the time?
15:47:09 <ddarius> merijn: Also it doesn't have Guido.
15:47:10 <ivanm> pumpkin: if I remember ;-)
15:47:18 <ivanm> pumpkin: I _think_ this is the streaming address: http://lca2011.linux.org.au/stream/N515-QUTandUrbanest%28AU%29.html
15:47:20 <pumpkin> jacobian: a lot of professional developers feel way better using it and will argue too
15:48:03 <kuffaar> I frequently can't figure out the signatures of my own functions in advance, even when  the code compiles, because I get confused by monads and picking the righ constraints etc. Then I usually end up reading the warnings by ghc and then I copy paste the signatures from those and put them into my code in those cases. I just ended up doing that again with my forkIO + ReaderT thing. Does that mean I suck? Do other people do this in the beginning, too?
15:48:03 <jacobian> I'm won't argue that they don't experience that. 
15:48:05 <ddarius> merijn: Heck, with the DLR stuff, I can even do the exact same kinds of things that one does in Python if I wanted to, which I don.t
15:50:33 <Saizan> kuffaar: it's perfectly fine in the beginning, and i still don't bother coming up with the full type myself most of the time
15:50:54 <kuffaar> Saizan but I mean you add it later, right? I started using -Wall -Werror early
15:50:55 <merijn> ddarius: The lambda, docs, libraries and performance have never been an issue for me. I disagree that types, access modifiers or its semantics make it inferior to C#, it just makes it suited for a different approach to programming (and by extension a different problem domain)
15:51:01 <kuffaar> Or rather -Wall only really
15:51:10 <kuffaar> But I usually don't rest until every warning is eradicated
15:51:18 <kuffaar> I even use Control.Monad.void in do blocks
15:51:19 <int80_h> Saizan: we're dorking around with the router on my local subnet, so I may dissapear at any moment (followed by me coming back when I run to another subnet). That said, I don't really need IO () as a return type. I don't need a return type at all, as I am using MapM
15:51:34 <Saizan> kuffaar: i add it later copy-pasting from ghci, i don't use -Wall though
15:51:38 <int80_h> Saizan: would this problem be fixed if I just changed the return type to String?
15:51:39 <kuffaar> Hehe, ok
15:51:46 * int80_h checks that now
15:52:08 <ddarius> merijn: Except that I can take the -same- approach in C# if I wanted to.
15:52:09 <Saizan> kuffaar: anyhow, learning how to do type inference manually is quite important to be able to deal efficiently with type errors when they come up
15:52:21 <kuffaar> Yeah, I can see that
15:52:30 <int80_h> mapM_ I mean
15:52:36 <merijn> ddarius: What I've seen so far from C# so far (admittedly not much) that is much more cumbersome in C#, though
15:52:39 <Saizan> ?type mapM_
15:52:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:52:47 <ddarius> merijn: The DLR stuff is rather new.
15:53:00 <ddarius> Anyway, I'm not saying that C# is the bestest language in the world.
15:53:03 <Saizan> int80_h: the function that gets mapped still needs to be in the same monad
15:53:38 <ddarius> C# did do one particularly stupid thing and copied Java on array covariance.
15:53:52 <merijn> ddarius: Also the idea that everything must be a class
15:53:59 <merijn> *rage*
15:54:26 <azaq23> I think the python object model is rather elegant in its general way of approaching things and a big + for the language in comparison, it's similar to smalltalk's - though I can't say anything about C# specifically.
15:54:26 <ddarius> Not everything is a class in C#.  Perhaps you meant "in" which is also not true, but true enough and is annoying, I agree.
15:55:09 <merijn> I like static typing as much as most people in here, but some people in here seem to belong to some secret "static typing gestapo" dedicated to the eradication of dynamic languages and hunting me down when I remotely imply using one :p
15:55:14 <kuffaar> I am currently developing a tendency to do something which feels like OOP in Haskell to me. I wrap related values into record types and then I put those into stacks of ReaderTs and pass them around in functions which operate on these environments.
15:55:53 <kuffaar> I am not sure if this is a good idea at all
15:56:00 <merijn> kuffaar: Probably not :p
15:56:12 <kuffaar> But it worked great for my synchronised console output thing at least
15:56:12 <heatsink> I have an hs file and an hs-boot file with incompatible type signatures, but GHC compiles them anyway and my program crashes.  Is this a bug?
15:56:29 <int80_h> Saizan: what would I use to keep it in the same MOnad?
15:56:29 <heatsink> in GHC i mean.  It's obviously a bug in my code.
15:56:44 <kuffaar> merijn what is the problem with that and what do I want to consider instead?
15:56:51 <ddarius> merijn: If that was directed at me, then the fact that I don't like Python doesn't imply that I want to get rid of all dynamically typed languages, though I do, indeed, dislike dynamic typing.  However, I do rather like Scheme and some other dynamically typed languages.
15:57:19 <jacobian> what about statically typed shells 
15:57:20 <kuffaar> I find composing stacks of monads really annoying btw and I generally need to define new functions for a particular stack configuration which then basically just aliases existing functions with the appropriate lifts/record functions
15:57:25 <merijn> ddarius: Not at you specifically, but its a trend in here I've noticed
15:57:28 <Saizan> int80_h: runErrorT 
15:57:39 <int80_h> Saizan: Ah you mentioned that one before
15:57:41 <Saizan> int80_h: + something to deal properly with the errors
15:58:21 <merijn> kuffaar: Ah, bollocks. Cale had a nice site showing some examples of "OO" haskell (using a theoretical game as example), but that site seems to have evaporated...
15:58:36 <kuffaar> Well, Cale is still around at least
15:58:42 <heatsink> kuffar: If you use the same functionality in lots of different monads, you could make a typeclass for monads supporting that functionality.  Similar to MonadReader etc.
15:58:56 <ddarius> merijn: Well I blame your use of dynamically typed languages leading to a tendency to brashly and unsoundly generalize, and once we solve the Dynamically Typed Language Problem you will be cured.
15:58:57 <Saizan> int80_h: since runErrorT would give you an IO (Either String WhatCurlRespProduces) and in mapM_ that could just end up ignored
15:58:58 <kuffaar> heatsink: Why don't you tab my nick :'(
15:58:58 <pumpkin> merijn: it boils down to representing your records of methods explicitly
15:59:11 <kuffaar> (you misspelled it so I don't get any highlights)
15:59:13 <heatsink> It's only seven characters long
15:59:18 <heatsink> Oh sorry
15:59:20 <heatsink> kuffaar
15:59:21 <pumpkin> kuuffffar: what's wrong?
15:59:21 <Cale> merijn: yeah :(
15:59:22 <int80_h> Saizan: okay I think I have seen that modelled before. I'm going to post my thoughts on the direction I should go in. I expect it won't be exactly right but might be close
15:59:36 <Cale> merijn: It's on my old machine whose hard drive seems to be halfway-dead
15:59:44 <merijn> Cale: Bummer
15:59:50 <kuffaar> penilepump: Nothing, I'm fine, just Haskell giving me the cancer again
15:59:59 <Cale> merijn: I need to try harder to extract files off it sometime, but I'll have to actually rip it apart, since I can't get the machine to boot
16:00:11 <pumpkin> kuffaar: that's a bit of a stretch :)
16:00:43 <merijn> ddarius: No, my tendency to brashly and unsoundly generalize comes from inconsistent personal belief system leading to delusions of grandeur :p
16:01:28 <kuffaar> merijn: What dynamically typed languages are you afflicted with? (regarding ddarius' comment)
16:01:39 <merijn> pumpkin: I couldn't really figure out what you were replying to there?
16:02:16 <merijn> Mostly python and lua, although I've been trying to get into Scheme
16:02:40 <pumpkin> merijn: Cale's OO guide, iirc
16:03:33 <Tinned_T1na> hi, I've a function that I hope will be for type [a] -> [a] -> Double
16:03:43 <pumpkin> merijn: OO in haskell is basically existentials + typeclasses, which happen to be equivalent to just dictionaries of the typeclass methods applied to the existentially quantified value
16:03:55 <Tinned_T1na> the idea is to find  f a b = (length a) / (length b)
16:04:07 <Tinned_T1na> but I'm not entirely sure how to phrase it for haskell.
16:04:16 <ddarius> pumpkin: I don't see any reason to bring in type classes.
16:04:21 <djahandarie> Does anyone know of a Windows text editor with Haskell syntax highlighting?
16:04:26 <ddarius> djahandarie: vim
16:04:29 <merijn> Tinned_T1na: I think you want zipWith
16:04:31 <Tinned_T1na> i.e. such that it doesn't throw a type-based wobbly and gets me my double :-)
16:04:32 <merijn> :t zipWith
16:04:33 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:04:43 <djahandarie> ddarius, I would, but it's not for me, and I don't want to tell this guy to learn vim and Haskell at the same time
16:04:45 <heatsink> Tinned_T1na: Use fromIntegral to cast Int to Double
16:04:47 <pumpkin> ddarius: there isn't, really, but it more closely matches the existential interface that OOers expect. But yeah, that's what I'm saying, the typeclass can be eliminated
16:04:53 <merijn> eh, no I'm wrong
16:05:04 <ddarius> djahandarie: Why not?
16:05:10 <merijn> Tinned_T1na: Disregard what I just said :>
16:05:10 <Tinned_T1na> merijn: you're surprisingly close to what I'm actually doing, but thank you all the same :-)
16:05:21 <djahandarie> Because the little motivation he has for this will probably break 
16:05:36 <Tinned_T1na> thanks, I think I'll go read some fromIntegral documentation :-)
16:05:39 * ddarius prefers hanging around people that break less easily.
16:05:43 <j-invariant> is milk bad for you?
16:05:47 <kuffaar> Currently my concern is mostly just to wrap up groups of values so I can pass them around easily between related functions. Sometimes these different groups need to be combined. I am still not sure about an elegant method of dealing with all this. Maybe I shouldn't be using ReaderT at all.
16:05:56 <j-invariant> does #haskell drink green tea?
16:05:59 <pumpkin> I do
16:06:06 <merijn> pumpkin: Yeah, I think the main advantage of Cale's site was that the examples were very easy to explain/understand while your explanation is fairly...obtuse :p
16:06:14 <ddarius> j-invariant: Well, humans are the only animals that actively choose to 1) drink milk in adulthood, and 2) drink the milk of other species.
16:06:15 <pumpkin> merijn: :'(
16:06:23 <kuffaar> merijn maybe it's still on archive.orgf
16:06:26 <kuffaar> archive.org*
16:06:28 <Cale> It's not
16:06:35 <kuffaar> Oh snap
16:06:37 <Cale> I deny all robots
16:06:41 <pumpkin> lol
16:06:45 <pumpkin> why?
16:06:46 <Cale> because the webserver is my personal machine
16:06:51 <pumpkin> ah
16:06:51 <kuffaar> pumpkin: AI-phobia
16:06:53 <roconnor> edwardk: have you ever thought about fixpoints of comonad transformers?
16:07:01 <Cale> and many random robots are very obnoxious
16:07:03 <ddarius> pumpkin: Cale only wants the disreputable indexers.
16:07:36 <j-invariant> if a robot doesn't respect robots.txt do the internet police stop it?
16:07:43 <Philippa_> ddarius: for which value of "actively choose"?
16:07:56 <pumpkin> j-invariant: tim berners-lee comes knocking 
16:07:56 <ddarius> Philippa_: They do it in the wild.
16:08:11 <Philippa_> ddarius: we're the only one that I know of that goes out of its way to farm etc for it, sure
16:08:36 <merijn> Philippa_: Wrong!
16:08:48 <Philippa_> merijn: "that I know of" :p
16:08:54 <merijn> Philippa_: They discovered a type of amoeba which raises bacteria as cattle :D
16:09:01 <j-invariant> wow
16:09:06 <j-invariant> merijn: that is cool whats it called
16:09:12 <ddarius> merijn: And then drinks the bacteria's milk?
16:09:19 <Philippa_> merijn: cool, but also figures from what I knew of already - not sure it counts as 'milk' though
16:09:21 <kuffaar> I don't think I understand how runReaderT actually "executes" stuff
16:09:24 <kuffaar> :t runReaderT
16:09:24 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
16:09:28 <merijn> ddarius: Well no, they get eaten. But he said farm, not milk :p
16:09:41 <Philippa_> she, and "farm... for [milk]"
16:09:47 <merijn> j-invariant: I forgot the name, was in the news fairly recently (within the last week) lemme see if I can find it
16:09:49 <Tinned_T1na> Sorted, thanks very much for your help :-)
16:10:13 <ddarius> Philippa_: You'll have to forgive merijn.  He uses dynamically typed languages you see.
16:10:29 <edwardk> merijn: i'd be more impressed with one that raised cattle as cattle
16:10:33 <Philippa_> ah. And I guess I quack confusingly or something
16:10:33 <djahandarie> I used untyped languages
16:10:36 <ddarius> edwardk: Me too.
16:10:47 <merijn> Philippa_: Oh yeah, I skipped the it. Although I'm pretty sure there are ant colonies which "milk" aphids
16:10:50 <Philippa_> edwardk: I'd be extremely impressed with a bacterium that does that, yes :-)
16:10:51 <kuffaar> djahandarie: Likw?
16:10:53 <kuffaar> Like*
16:11:01 <kuffaar> MIPS assembly?
16:11:06 <pumpkin> is there anything these bacteria can't do!?
16:11:08 <djahandarie> UTLC
16:11:13 <kuffaar> ...
16:11:18 <pumpkin> untyped lambda calculus?
16:11:19 <kuffaar> Very funny :[
16:11:22 <kuffaar> yes, pumpkin
16:11:29 <ddarius> pumpkin: Bacteria are pretty impressive, as are fungi.
16:12:10 <merijn> Philippa_: http://www.the-scientist.com/news/display/57924/ and http://en.wikipedia.org/wiki/Aphid#Ant_mutualism
16:12:23 <kuffaar> ddarius: How can they be impressive if they don't even show up in textbooks on category theory?
16:12:34 <jmcarthur> ah, but they do
16:12:38 <Philippa_> merijn: yeah. I was being picky about the value of milk there, as in if it didn't come from a mammal... knew about ants and aphids though
16:12:46 <merijn> kuffaar: Get a better textbook? :p
16:12:47 <jmcarthur> just lick a textbook on category theory and you may find out for yourself
16:12:48 <int80_h> Saizan: I think I'm going about this wrong and need to modify curlResp
16:13:13 <kuffaar> Oh, you mean germs on a printed textbook
16:13:13 <int80_h> Saizan: I have some thinking to do so I'll be away for a bit
16:13:25 <kuffaar> Whereas a "book" is just a virtual copy to me
16:13:44 <ddarius> Someone's replaced my giant bucket of Sprite with a giant bucket of lemon-lime flavored sugar water.
16:14:03 <Philippa_> you had a bucket of chroma-keyed bitmaps?
16:14:24 <dolio> Non-carbonated lemon-lime flavored sugar water?
16:14:38 <merijn> ddarius: You accidentally got the wrong fluid due to mistaken duck-typing? :>
16:14:58 <kuffaar> Oh, when I type a ReaderT I should probably call my type BlahT instead of Blah to stick with Haskell conventions, right?
16:15:26 <ddarius> Thankfully I never wanted the Sprite anyway.
16:15:58 <heatsink> kuffaar: I think the convention is to use T for transformers.  They have kind (* -> *) -> (* -> *)
16:16:23 <kuffaar> Let's see if that is even the case here
16:16:41 <kuffaar> type LockedConsole = ReaderT LockedConsoleState
16:17:02 <kuffaar> ReaderT r m a
16:17:11 <kuffaar> r is given, m a and a remain
16:17:16 <kuffaar> m is * -> *, right?
16:17:21 <heatsink> yes
16:17:22 <kuffaar> And a is *
16:18:15 <kuffaar> (* -> *) -> (* -> *) is the same as (* -> *) -> * -> * anyways, right?
16:18:30 <kuffaar> Just with implied common use semantics, I suppose?
16:18:33 <heatsink> yes
16:19:03 <kuffaar> So I lack one -> * for it to be a monad transformer I guess
16:19:11 <kuffaar> I won't attach a T then
16:19:49 <ddarius> :k ReaderT
16:19:49 <lambdabot> * -> (* -> *) -> * -> *
16:20:11 <heatsink> No, your parameters are (* -> *) and *, and your result is *, so it's (* -> *) -> * -> *
16:20:24 <kuffaar> Ohh
16:20:35 <kuffaar> So it is a transformer
16:20:41 <kuffaar> I totally forgot about the result, yeah
16:20:46 <kuffaar> I just looked at the arguments
16:21:02 <kuffaar> LockedConsoleT it is
16:21:27 <ion> @hoogle Ptr a -> (Ptr a -> b) -> Maybe b
16:21:27 <heatsink> Is there a way to make GHC detect whether a hs and hs-boot file have inconsistent types when compiling in single-file mode?
16:21:28 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
16:21:30 <kuffaar> I suppose LockedConsole would then be the same as LockedConsoleT Identity
16:21:35 <kuffaar> @hoogle Identity
16:21:36 <lambdabot> module Control.Monad.Identity
16:21:36 <lambdabot> Control.Monad.Identity newtype Identity a
16:21:36 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
16:21:38 <parcs> does there exist a more general bracket for MonadIO m => m?
16:22:15 * ddarius wonders about something now.
16:22:25 <ion> Does any module have a function like this? ptrMaybe :: (Ptr a -> b) -> Ptr a -> Maybe b; ptrMaybe f ptr = if ptr == nullPtr then Nothing else Just (f ptr)
16:22:29 <heatsink> scrap: There's no way to abbreviate class contexts, if that's what you're looking for.
16:22:40 <kuffaar> newtype is for * -> * only, right?
16:22:52 <parcs> :t bracket
16:22:52 <pumpkin> nope
16:22:53 <lambdabot> Not in scope: `bracket'
16:23:00 <pumpkin> it's for any type
16:23:06 <pumpkin> as long as there's only one value behind it
16:23:09 <pumpkin> (and no typeclass context)
16:23:12 <parcs> @hoogle bracket
16:23:12 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:23:12 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:23:12 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:23:15 <ddarius> @src Mu
16:23:15 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:23:19 <EdH> Major success with it all today - thanks hugely to everyone who lent a hand and looked past all my sickeningly noobish Haskell faux pas :P
16:23:22 <EdH> Night all!
16:23:25 <kuffaar> Doesn't precisely that mean * -> *, pumpkin?
16:23:36 <pumpkin> nope
16:23:41 <ddarius> :q
16:23:50 <heatsink> Oh, that kind of bracket.
16:23:53 <ddarius> Crap.  That's the first time I've done something like that I believe.
16:23:54 <kuffaar> I mean you can't have newtype Blah a b c d can you?
16:23:59 <pumpkin> I can write newtype Moo a b c d = Moo Int
16:24:03 <kuffaar> Oh
16:24:04 <pumpkin> all it cares about is the value
16:24:12 <ivanm> kuffaar: you can do newtypes on Ints, on (a -> b), etc.
16:24:20 <heatsink> ddarius: Lick your face instead of exit a room?
16:24:28 <pumpkin> newtype SpecialFunction a b = Special (a -> b)
16:24:34 <ivanm> you _can't_ do a newtype on more than one value/type (unless you combine them with a tuple or something, which in effect means it only has one type)
16:24:41 <ivanm> heatsink: heh
16:26:48 <kuffaar> I just realised that runReaderT doesn't actually take a function in its arguments, yet I always thought of it as "executing some function with the specified MonadReader environment"
16:26:55 <kuffaar> But it's just a value
16:27:41 <ion> With ptrMaybe like that one can do e.g. Data.Traversable.sequence . ptrMaybe peekCString =<< withCString str some_imported_function where some_imported_function :: CString -> IO CString and may return NULL.
16:27:48 * ddarius wonders how much he can abuse recursively importing a module into itself.
16:28:06 <ivanm> ddarius: interesting idea
16:28:16 <ion> and get an IO (Maybe String) with Nothing if the imported function returned NULL.
16:30:31 * Saizan has problems with inverse images
16:31:00 <Saizan> i mean, definitions that use them feel always so weird to me.
16:32:12 <j-invariant> Saizan: it's like kung fu
16:32:19 <j-invariant> a small movement causes a big effect
16:33:12 <kuffaar> What's a -- * comment in Haddock?
16:33:36 <ivanm> kuffaar: used in the export list
16:33:41 <kuffaar> Ah, ok
16:33:42 <ivanm> it gives you a header
16:34:03 * kuffaar reads the mtl source to get a better grasp of runReaderT
16:35:20 <c_wraith> kuffaar: runReaderT isn't going to tell you much of anything.  It's just an accessor.  it's the Monad instance for ReaderT that has all the interesting stuff.
16:35:40 <sshc> Hi, what is the convention regarding prefixing the names of the fields in an abstract data type with an underscore?
16:35:55 <kuffaar> Alright
16:36:49 <ivanm> sshc: used when aren't going to export it or something IIRC
16:36:49 * hackagebot functor-apply 0.9.3 - Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.9.3 (EdwardKmett)
16:36:55 <ivanm> there's something about it in the ghc docs
16:37:25 <ivanm> edwardk: what's the point of functor-apply?
16:38:23 <sshc> ivanm: Can you remember generally where it is in the GHC docs?
16:38:32 <kuffaar> Ah, in Haddock you're supposed to mark forkIO as @forkIO@?
16:38:55 <ivanm> sshc: lemme have a look
16:38:59 <sshc> Thanks
16:39:02 <ddarius> "It is one of only two axioms [...] that we express informally, because formalizing it is equivalent to writing a program to perform substitution."  To which I reply, "So?"
16:39:03 <ivanm> kuffaar: if you want it type-set
16:39:08 <ivanm> use 'forkIO' to get a link
16:39:11 <sshc> kuffaar: If you want a link, surrond it with 's
16:39:11 <kuffaar> Oh.
16:39:18 <kuffaar> Yeah I just want the link
16:39:41 <kuffaar> But how does Haddock find what forkIO I am referring to?
16:39:47 <kuffaar> It's exported in so many modules
16:39:50 <ivanm> sshc: somewhere around http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html IIRC
16:40:03 <ivanm> kuffaar: whichever one you imported it from
16:40:07 <kuffaar> Do I need to specify a 'Full.Path.forkIO' for that to work?
16:40:10 <kuffaar> Ah, interesting
16:40:15 <ivanm> though I don't recall it being exported that many times...
16:40:22 <ivanm> kuffaar: that's one reason why haddock is tied to ghc atm
16:40:25 <ivanm> (IIRC)
16:41:03 <kuffaar> I have a function which contains ' in its name
16:41:12 <kuffaar> Do I escape that with \?
16:41:16 <kuffaar> 'test\''
16:41:21 <edwardk> ivanm: functor-apply is the structure out of applicative that is used by comonads in uustalu and vene's essence of dataflow programming
16:41:25 <ivanm> kuffaar: yup
16:41:35 <edwardk> ivanm: they are 'Applicatives sans pure'
16:41:46 <ivanm> edwardk: hmmmm... how does removing pure change things?
16:41:53 <edwardk> ivanm: it turns out though, that there are lots of things that are 'Comonads sans extract'
16:41:55 <kuffaar> Alright, thanks
16:42:03 <edwardk> and 'Monads sans return'
16:42:05 <ivanm> isn't pure one of the main parts of applicative?
16:42:19 <edwardk> just like the unit is one of the main parts of a monoid
16:42:23 <edwardk> but semigroups are still useful
16:42:37 <ivanm> *nod*
16:42:38 <edwardk> for instance Max is a semigroup, but only a monoid if your type is bounded
16:43:24 <edwardk> Many comonads offer a symmetric semigroup-like zip operation which is a valid <*>, but i can't provide it alone without a class
16:43:25 <ivanm> edwardk: is Apply Pointed?
16:43:33 <kuffaar> pure and <*>
16:43:42 <kuffaar> Although I have no idea what I would ever use them for.
16:43:52 <edwardk> class Functor f => Apply f where (<.>) ::  f (a -> b) -> f a -> f b
16:44:05 <edwardk> Applicative is Pointed, Apply is explicitly the part that lacks the point! =)
16:44:09 <ivanm> kuffaar: pure == return for monads
16:44:29 <ivanm> edwardk: you mean applicative = apply + pointed?
16:44:30 <kuffaar> :o
16:44:32 <edwardk> Apply satisfies the constraint: (.) <$> u <*> v <*> w = u <*> (v <*> w)
16:44:33 <edwardk> yes
16:44:47 <kuffaar> Yeah that was the second law of Applicative, I think
16:44:49 <edwardk> ivanm: plus the the laws for pure.
16:44:53 <kuffaar> The first one was about pure I think?
16:44:59 <kuffaar> I just read about those in LYAH yesterday
16:45:06 <edwardk> kuffaar: yes, but without pure, the associativity law there is the only one you can prove
16:45:08 <kuffaar> But it didn't look like something I would ever find any use for
16:45:10 <ivanm> edwardk: right
16:47:00 <edwardk> kuffar: its enough to give you that if you defined (<+>) =  liftA2 mappend then (a <+> b) <+> c  = a <+> (b <+> c)
16:47:03 <edwardk> its an associativity law
16:47:43 <edwardk> like how the funny looking 3rd law on monad is really a law about the associativity of (>=>)
16:48:15 <ivanm> @type (>=>)
16:48:16 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
16:48:42 <ClaudiusMaximus> http://hpaste.org/43353/libqd_benchmarks for the curious - qd in haskell is sloooow, but it's slow from C++ too....
16:48:44 <edwardk> kuffaar: it helps you write combinators, because otherwise you have a hard time writing functions that use these because the way you decompose yoru functions would change your parenthesization, and might break your program
16:49:19 <ivanm> ClaudiusMaximus: you're doing quantum dynamics in haskell? :o
16:49:20 <kuffaar> I don't even know what a combinator is
16:49:21 <ivanm> :p
16:49:28 <kuffaar> Does that have anything to do with Curry's Y combinator?
16:49:48 <kuffaar> > fix (+0)
16:49:52 <lambdabot>   mueval-core: Time limit exceeded
16:49:57 <ivanm> kuffaar: what a combinator is is the same
16:49:57 <kuffaar> Good man
16:49:58 <edwardk> kuffar: foo x y z = … — in that foo is a combinator =)
16:50:01 <ivanm> Y is just _a_ combinator
16:50:21 <kuffaar> edwardk: Why do you still try to spell out my nick manually :'(
16:50:25 <edwardk> think of a combinator as just a function typically without capturing environment
16:50:38 <edwardk> kufer: coz i enjoy misspelling it
16:50:38 <ddarius> edwardk: foo may be recursive, in which case it isn't a combinator.
16:50:43 <ivanm> kuffaar: eh, a lot of people do that with mine, etc. *shrug*
16:50:48 <ClaudiusMaximus> ivanm: high precision floats
16:50:49 * ivanm puts it down to "people are weird"
16:50:51 <kuffaar> iv<tab> for me
16:50:57 <ivanm> ClaudiusMaximus: *nod*
16:51:06 <kuffaar> ivanm I bet they erroneously type ivan or ivam all the time
16:51:15 <kuffaar> People misspell merijn all the time, too
16:51:17 <ivanm> yup
16:51:24 <edwardk> kuffaar: typically i'll tab after the second character, there is another ku-  kuribas on channel, so i keep typing
16:51:26 <ivanm> note: ivan _is_ my name, but not my nick :p
16:51:26 <geheimdienst> tell me about it
16:51:29 <kuffaar> Because they haven't discovered the power of the tab and they actually attempt to fuloly parse it
16:51:44 <Haskell> There, happy?
16:51:44 <preflex>  Haskell: you have 1 new message. '/msg preflex messages' to read it.
16:51:51 <edwardk> hahaha
16:51:54 <djahandarie> Heh
16:51:56 <ivanm> edwardk: xchat uses order of appearance as well to try and make tabbing "smarter"
16:52:01 <djahandarie> Didn't even know preflex kept track of messages!
16:52:02 <Haskell> <preflex>  tolkad asked 148 days, 21 hours, 58 minutes and 22 seconds ago: hi
16:52:03 <Haskell> Legendary
16:52:08 <edwardk> meh, i hate the tabs ;)
16:52:10 <ivanm> wow, someone left a message for Haskell? :o
16:52:18 <edwardk> @tell Haskell You got my message!
16:52:18 <lambdabot> Consider it noted.
16:52:19 <Haskell> That would appear to be the case.
16:52:19 <lambdabot> Haskell: You have 1 new message. '/msg lambdabot @messages' to read it.
16:52:30 <Haskell> I am popular with young people
16:52:37 <edwardk> and category theorists
16:52:45 <edwardk> but not "real world programmers"
16:53:01 <geheimdienst> ... real world haskellers?
16:53:03 <ivanm> edwardk: oh, you interested in graphs in DBs at all?
16:53:06 * ddarius is pretty sure most categorists are completely unaware of Haskell.
16:53:07 <ivanm> geheimdienst: they exist? :o
16:53:13 <edwardk> for some grungy half-denigrating definition of real world programmers, who obviously can't be taught to think, and so must be protected.
16:53:14 <Haskell> ddarius probably
16:53:38 <ddarius> edwardk: Why must they be protected?
16:53:45 <edwardk> ivanm: yes, i was actually talking to david spivak about graphs and databases the other day =)
16:53:49 <ivanm> ddarius: from themselves
16:54:06 <ddarius> ivanm: That doesn't answer the question.
16:54:07 <ivanm> edwardk: there's going to be a talk on at linux.conf.au in about 3.5 hours about them if you want to watch the streaming video
16:54:09 <edwardk> ddarius: don't ask me, this just seems to be the prevailing widsom among the yegge/bracha crowd
16:54:39 <edwardk> er wisdom
16:54:58 <ddarius> edwardk: For djahandarie, have you put up your video with extra home-madedness?
16:55:11 <edwardk> ddarius: oh, i should do that
16:55:39 <djahandarie> Yes!
16:55:58 <ivanm> what video is this?
16:56:11 <Haskell> By the way, have any attempts been made to write a native DBMS in Haskell which you can query in a proper type-safe way? The current SQL bindings available for Haskell are extremely dirty because they are still based on manually typing raw queries mostly and that happstack in-memory one doesn't scale with simple systems where you have just one simple low end server with 1-2 GiB of RAM and you need to deal with large datasets. When you need to start swappi
16:56:11 <Haskell> ng with those in-memory ones they are surely outperformed by conventional DBMSes like PostgreSQL
16:56:23 <ivanm> not AFAIK
16:56:33 <ivanm> definitely nothing like erlang's mnesia that I've seen
16:56:36 <djahandarie> Someone said they wanted to try
16:56:37 <djahandarie> ddarius?
16:56:39 <edwardk> ivanm: i recorded the talks at the last boston haskell and boston scala meetups
16:56:41 <djahandarie> Not sure if he started
16:56:43 <Haskell> djahandarie: Axman6
16:56:46 <ivanm> edwardk: ahhhh
16:56:54 <ivanm> djahandarie: he did?
16:56:55 <Haskell> Although he said it's too complicated
16:57:08 <edwardk> Haskell: i have a partial datalog-in-haskell implementation designed for that purpose, using TH quasiquoters for queries
16:57:08 <djahandarie> Haskell, maybe him too, but I'm pretty sure ddarius said something about it
16:57:11 <Haskell> I want to write some type safe table/query thing for SQL in Haskell but it's probably far above my current skillset
16:57:25 <HaskellLove> I'M BACK!
16:57:33 <djahandarie> I'm sure I'd get ticked off trying to optimize everything in it far before I finished it
16:57:42 <edwardk> HaskellLove and Haskell sitting in a tree...
16:57:47 <Haskell> HaskellLove shall we order a curry?
16:57:47 <djahandarie> Would be fun up until that point though
16:57:48 <uberfry> night everybody
16:57:58 <HaskellLove> Haskell: sure
16:58:14 <geheimdienst> HaskellLove: You have 197 messages. /msg lambdabot msg to retrieve them.
16:58:23 <djahandarie> Haskell, can(I,please,have,chicken)?
16:58:29 <Philippa_> edwardk: ...I-M-P-U-RI-T-IES?
16:58:36 <HaskellLove> aaaaaaieeeeee
16:58:39 <ivanm> @slap HaskellLove 
16:58:39 <lambdabot> I won't; I want to go get some cookies instead.
16:58:45 <edwardk> Philippa_: what impurities? it was completely pure. =)
16:58:52 <ivanm> lambdabot doesn't seem to like slapping people that much nowadays...
16:58:58 <copumpkin> @slap ivanm 
16:58:59 * lambdabot is overcome by a sudden desire to hurt ivanm
16:59:05 <ivanm> grrr.....
16:59:09 * ddarius should also go get some cookies or at least food.
16:59:15 <geheimdienst> the desire did not seem to translate into action
16:59:16 <edwardk> Philippa_: build the EDB as an object, then lazily evaluate the IDB rules via stratified aggregation
16:59:25 <djahandarie> Speaking of cookies, I have one right here!
16:59:43 <Haskell> Haskell Curry eats chicken tikka masala
16:59:50 <geheimdienst> me too. synchronous worldwide cookie munching action, anyone?
17:00:19 <Haskell> Surveys have found chicken tikka masala to be the most popular dish in British restaurants and it has been called "Britain's true national dish."
17:00:25 <ivanm> OK, my tests run slower when using Text rather than String because of the pack in the Arbitrary instance :s
17:01:50 <djahandarie> http://althack.org/cookie.jpg
17:02:49 <ddarius> djahandarie: Clearly photoshopped.
17:02:53 <Haskell> I see my name on a screen
17:03:08 <copumpkin> omg I'm famous
17:03:24 <Haskell> Is that irssi?
17:03:29 <djahandarie> ddarius, I must be really damn good at Photoshoping stuff if I did it that fast
17:03:41 <heatsink> Is that a CRT?
17:03:45 <djahandarie> No lol
17:03:47 <ivanm> ddarius: yeah, that biscuit looks _totally_ fake!
17:03:49 <copumpkin> people who like irssi should use http://www.secretgeometry.com/apps/cathode/
17:03:50 <ddarius> djahandarie: That wasn't particularly fast.
17:04:00 <edwardk> copumpkin beat me to the link
17:04:09 <edwardk> best terminal evar ;)
17:04:19 <djahandarie> Haskell, http://althack.org/desk.jpg
17:04:35 <djahandarie> Heh
17:04:41 <copumpkin> you sure like black
17:04:42 <Haskell> Please don't tell me that's XGonad
17:05:04 <edwardk> djahandarie is secretly goth
17:05:10 <djahandarie> Haha
17:05:12 <ddarius> copumpkin: You have to pay $20 for it?
17:05:13 <djahandarie> Don't judge me!
17:05:15 <ivanm> Haskell: how did you mis-type M ?
17:05:20 <edwardk> see? =)
17:05:27 <copumpkin> ddarius: nope, if you don't mind the screen deteriorating even more
17:06:00 * ddarius judges djahandarie for using a floating window.
17:06:23 <edwardk> it degrades as you use it unless you register. phosphors hold light longer, screen starts to wave. we were joking that it should abuse the mac accelerometer to let you whack the monitor and fix it temporarily
17:06:38 <ivanm> edwardk: lol
17:06:49 <ddarius> copumpkin: Ah, I see I need to pay far more than $20 for it.
17:07:13 <copumpkin> I can make a movie of it in action if anyone wants to see it
17:07:58 * ivanm doesn't
17:09:00 <spetrea> sup furballz ?
17:09:15 <copumpkin> furballz?
17:09:16 <copumpkin> really?
17:09:25 <ivanm> copumpkin: did someone let a cat in here?
17:09:32 <ivanm> I mean, Manatee isn't here atm...
17:09:38 <ivanm> didn't he clean up after himself or something? :p
17:09:55 <ddarius> ivanm: Have you -ever- seen a cat clean up after themselves?
17:10:18 <Haskell> <ivanm> Haskell: how did you mis-type M ?
17:10:22 <Haskell> It was intentional
17:10:28 <ivanm> ddarius: well, they _do_ dig holes do they not?
17:10:30 <copumpkin> I would have never guessed
17:10:39 <ivanm> Haskell: so you're that juvenile?
17:10:46 <ddarius> ivanm: Last I checked digging a hole did not count as cleaning anything up..
17:10:54 <ddarius> ivanm: You hadn't realized that?
17:11:03 <ivanm> well, they pre-emptively do it so they don't have to clean up
17:11:14 <ivanm> but I don't routinely study felines
17:11:33 <ddarius> There's a cool TED talk about felines.
17:11:48 <ivanm> yeah, don't care that much about them
17:11:53 <geheimdienst> ivanm, in case you want to study them, here's a good resource i visit frequently: icanhascheezburger.com
17:12:00 <copumpkin> lolfelines
17:12:25 <ivanm> geheimdienst: that got old rather fast
17:12:40 <copumpkin> not for me
17:12:41 * copumpkin laughs
17:13:09 * geheimdienst wonders what it must be like to "not care that much about felines" on a feline-crazed global computer net
17:13:25 <ivanm> copumpkin: yeah, but you named yourself after a gourd-like squash!
17:13:33 <ivanm> geheimdienst: quite refreshing actually
17:13:45 <ddarius> geheimdienst: Probably about the same way it feels to despise humans on a human-infested rock.
17:13:56 <copumpkin> http://dl.dropbox.com/u/361503/cathode.mov
17:13:59 <copumpkin> in case anyone was wondering
17:15:47 <geheimdienst> ivanm: how do you feel about t. gondii? http://en.wikipedia.org/wiki/Toxoplasmosis
17:15:53 <Haskell> ivanm: I am./
17:16:03 <Haskell> djahandarie: http://siyobik.info/misc/e420/desk/desk.jpg
17:16:07 <Haskell> Counter desk pic
17:16:13 <geheimdienst> "omg kitties is usang a mind control virus on us!!1! awww how cute!"
17:16:35 <Haskell> Dual screen high five
17:16:41 <djahandarie> Haskell, I like your wall a lot better
17:16:54 <Haskell> You like the wall better than the desk?
17:16:55 <copumpkin> five screen high two
17:17:09 <edwardk> ddarius: i have a solution to the 'where to put your comonad->monad transformer
17:17:11 <djahandarie> copumpkin, you gave up the rest of your fingers for the extra screens?
17:17:15 * geheimdienst noticed a world map on djahandarie's wall, probably sketching his plans for wold domination
17:17:16 <copumpkin> yep
17:17:48 <edwardk> newtype ContT r w m a = ContT { runContT :: w (a -> m r) -> m r } — =)
17:18:02 <edwardk> now i can put it in Trans without compunction!
17:18:03 <edwardk> =)
17:18:13 <ddarius> Haskell: Someone let out a box of black squares in your room.  You should have someone look into that.
17:18:31 <Haskell> It happens
17:19:02 <int80_h> Haskell: Y U No Compile?
17:19:17 <Haskell> int80_h because I am not a programmer (?)
17:19:22 * int80_h has been reading reddit all day.
17:19:32 <ivanm> Haskell: methinks he's referring to your nick
17:19:44 <Haskell> I should probably stop using it now
17:19:48 <ivanm> yes, you should
17:20:48 <int80_h> oh damn, now I'll never know.
17:21:09 * ddarius recommends not reading reddit.
17:21:18 <int80_h> too late!
17:21:25 <int80_h> besides /r/haskell is nifty
17:21:49 <int80_h> but, it's like a gateway to the biggest timewaster ever
17:22:58 <andy_> is there a good point-free way to describe:
17:22:59 <andy_> http://hpaste.org/43356/pointful_put
17:23:24 <ivanm> probably not
17:23:27 <ivanm> but why would you want to?
17:23:45 <ivanm> that looks clear enough
17:23:45 <andy_> most of the module is defined in applicative style - just looks out of place
17:24:19 <andy_> also, are record wildcards too exotic of an extension?  another question might be if anyone uses anything other than ghc
17:24:55 <mikeg> you can get basically the same behaviour using the reader monad, without the extension
17:25:10 <ddarius> Hehner and Wildberger would get along.
17:25:21 <mikeg> putRGB = do { putUI8 . red; putUI . green ... 
17:25:31 <copumpkin> mikeg: it's a different monad though
17:25:49 <andy_> ReaderT then?
17:25:56 <mikeg> oh missed that part :x
17:26:45 <andy_> o - do you mean a reader monad defined such that red :: R Word8, green :: R Word8 for some reader-like monad R?
17:26:47 <edwardk> ddarius: hrmm, though its not a MonadTrans instance =( it only looks like one. it offers Trans only if the comonad is a pointed functor
17:27:02 <ddarius> edwardk: Serves you right.
17:27:13 <ddarius> Why don't you just replace the r with Void.
17:27:21 <edwardk> ddarius: =)
17:29:44 <kfr> :t liftIO . forkIO
17:29:45 <lambdabot>     Ambiguous occurrence `liftIO'
17:29:45 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
17:29:45 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
17:30:04 <andy_> but not MonadIO?
17:30:47 <mikeg> andy_: try: put = last . sequence [putUI8 . red, putUI8 . green, putUI8 . blue]
17:30:47 <kfr> Shruggedyshrug
17:30:52 <kfr> @hoogle liftIO
17:30:52 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
17:31:11 <kfr> Haskell: Now with more trans fat!
17:31:16 <andy_> mikeg, that is what i had - was considering looking at variable argument functions - though i don't recall the link..
17:31:31 <andy_> o, minus the last
17:31:42 <andy_> :t 
17:31:43 <lambdabot> <no location info>: not an expression: `'
17:31:59 <andy_> :t flip (mapM_ . flip ($))
17:32:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => [a -> m b] -> a -> m ()
17:33:12 * ddarius has a tendency to solve simple mathematical problems with heavy mathematical tools.
17:33:20 <andy_> :t sequence
17:33:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:35:05 <accel> is there a way to generate fast lienar algebra routines in haskell
17:35:07 <accel> or should one just use blas?
17:35:28 <ddarius> @google oleg fft
17:35:30 <lambdabot> http://www.freedownloadscenter.com/Best/audio-card-fft.html
17:35:30 <lambdabot> Title: Audio card fft software by Oleg Ya. Shmelyoff and others
17:35:38 <accel> ?
17:35:39 <ddarius> Not exactly what I was looking for.
17:35:40 <ivanm> accel: hmatrix, hblas, etc.
17:35:50 <ivanm> @google oleg fft haskell
17:35:51 <lambdabot> http://books.google.com/books?id=sona_r6dPyQC&pg=PA73&lpg=PA73&dq=oleg+fft+haskell&source=bl&ots=o2YKFmG_yr&sig=i92iz5NVhPAVJdL9wPku9di2Iys
17:35:51 <lambdabot> Title: Parallel Computing Technologies ... - Google Books
17:35:57 <ivanm> probably not it either
17:36:12 <accel> are you guys looking for fftw ?
17:36:35 <accel> ivanm: ++ for hmatrix
17:36:39 <accel> exactly waht I was looking for
17:36:58 <ivanm> I have no idea what ddarius was looking for ;-)
17:37:12 <accel> @google what ddarius was looking for
17:37:13 <lambdabot> http://www.flickr.com/photos/ddarius/5109845197/
17:37:13 <lambdabot> Title: dDarius.M photography | Flickr - Photo Sharing!
17:37:24 <ddarius> http://okmij.org/ftp/NumMath.html#FFT-generation
17:37:42 <accel> @google @google
17:37:43 <lambdabot> http://www.google.com/
17:37:43 <lambdabot> Title: Google
17:37:49 <accel> @google bot abuse
17:37:51 <lambdabot> http://www.d3scene.com/forum/warcraft-3-bots/3785-naaab-nagas-advanced-abuse-bot.html
17:37:55 <geheimdienst> omg google is self-aware!?
17:38:07 <accel> is @google basically google + clicking "I'm feeling lucky" ?
17:38:17 <ivanm> yup
17:38:26 <accel> @google french military victories
17:38:27 <lambdabot> http://www.albinoblacksheep.com/text/victories.html
17:38:27 <lambdabot> Title: french military victories
17:38:44 <ddarius> These photos are actually pretty good.
17:38:50 <geheimdienst> accel, yeah. including some weirdness because if you'll google yourself, you'll get different results
17:40:41 <ddarius> My nicksake on twitter doesn't even like twitter.
17:40:59 <accel> whowever wrote hmatrix
17:41:02 <accel> deserves the nobel prize
17:41:11 <gwern> why? isn't it just a binding?
17:41:18 <accel> yeah; but it's awesome
17:41:19 <accel> and done right
17:41:28 <accel> maybe all haskell bindings are like that; and other languages have just given me low expectations
17:41:40 <gwern> maybe you should thank the authors of the original software for doing the heavy lifting
17:41:40 <accel> how often do you look at a library and say
17:41:48 <accel> if I had to bind this library, this is exactly how I would hav done it?
17:41:57 <ivanm> well, I'm not sure how necessary having the glsl bindings inside hmatrix is
17:42:05 <ddarius> My livejournal nicksake also like (the Korean) My Sassy Girl.
17:42:17 <gwern> accel: I only know haskell, so I could never say that
17:42:40 <gwern> ddarius: everyone likes My Sassy Girl, if they're not anal-retentive
17:42:52 <ivanm> no idea who that is
17:43:07 <ddarius> gwern: True.
17:43:23 <gwern> ivanm: very popular korean romantic-comedy sort of movie
17:43:40 <ivanm> o...k...
17:44:05 <geheimdienst> very enormously popular!!1! why u not know it
17:44:08 <kfr> I used to watch a lot of Korean movies
17:44:12 <ivanm> because I'm not Korean?
17:44:20 <kfr> I remember reading about this but I wasn't interested
17:44:29 <kfr> Or maybe I did even watch it, I can't remember
17:44:32 * gwern notes that ivanm's soul is dead. make sure to stake him thoroughly when the zombie/vampire apocalypse comes
17:44:47 <geheimdienst> i have never heard of the movie either
17:45:02 <gwern> you have now
17:45:03 <ivanm> gwern: how did you deduce that?
17:45:24 <kfr> Chan-wook Park has directed lots of funny stuff
17:45:29 <gwern> ivanm: well, everyone with a soul likes it. so I think it follows via modus tollens
17:45:51 <ivanm> I've never watched it, so I can't tell if I like it or not!
17:46:01 <ivanm> also, I'm not sure your premise is correct...
17:46:03 <kfr> Then download it already
17:46:15 <geheimdienst> you can't tell if you like it? that's the kind of thing a zombie would say
17:46:20 <ivanm> kfr: at a conference atm... ;-)
17:46:30 <ivanm> anyway, isn't this -blah stuff?
17:46:31 <gwern> geheimdienst: on the other hand, a p-zombie would say he liked it or didn't like it
17:46:41 <gwern> geheimdienst: so hard to tell
17:47:26 <pastorn> YES!!
17:47:31 * pastorn squashed a bug
17:48:02 <geheimdienst> "braiiins, possibly ... braaaains, although i'm not entirely sure ..." <- ivanm-style indecisive zombie
17:52:32 <gwern> pastorn: for gleefully taking a life, you shall surely be reborn as a preta for 1000 lifetimes!
17:53:08 <gwern> why must sentient beings pile up mountains of evil karma for themselves? 'as surely as the cart follows the horse, so too does evil follow the evil-doer'
17:53:45 <ivanm> because some people find it fun?
17:53:57 <geheimdienst> what about a free-running horse or one that a rider sits on?
17:54:10 <geheimdienst> they don't seem to be followed by carts much
17:55:00 <gwern> geheimdienst: but if there is a cart, it's usually preceded by the horse, yes? rare to see a horse pushing a cart rather than pulling
17:56:21 <geheimdienst> yeah. this means "so does evil follow the evil-doer" = if there is evil, it's preceded by an evil-doer
17:56:35 <gwern> seems reasonable to me
17:56:37 * geheimdienst likes to discuss things besides the point
17:56:57 <ivanm> 50% of runtime is generating Text values... :s
17:57:03 <geheimdienst> i thought what they meant was: if you're an evil-doer, evil will follow you = evil will get you
17:57:27 <geheimdienst> as kind of a warning, no?
17:57:40 <gwern> well, there is some of that
17:58:23 <gwern> it's not clear to me whether one's own evil is guaranteed to catch up to one. that one will suffer eventually for some reason is guaranteed, though.
17:58:58 <gwern> maybe the admonition is to not forget that the consequences of one's evil do not go away
17:59:23 <pastorn> gwern: huh? i don't get it
17:59:58 <gwern> pastorn: that consequences of evil actions persist
18:00:03 <pastorn> gwern: what i did was to filter my input a bit so that vty doesn't try to print cool esape characters coming in over my telnet connection
18:00:26 <geheimdienst> interesting that you read it like that. i had only interpreted it as "don't be evil. if you are, it will come back to haunt you"
18:01:38 * geheimdienst will now apply his twisted confused mind to developing a 21st-century version of the saying, without the horse and cart. will be something about cats and captions, probably.
18:01:39 <gwern> geheimdienst: I personally try to interpret early buddhism in a very atheistic and materialistic way, so 'it will haunt you and if you escape in this lifetime, punish you in the next' isn't very satisfactory
18:02:09 <gwern> pastorn: ~-~ I was willfully misinterpreting your comment as of an actual bug being killed and put a buddhist reaction on it
18:02:25 <gwern> pastorn: also, why are you using telnet? isn't that a cardinal sin of insecurity these days?
18:02:25 <Philippa_> geheimdienst: truck before trailer too 20th century?
18:02:44 <pastorn> gwern: the server demands it
18:02:57 <gwern> wow.
18:02:58 <pastorn> gwern: also: KISS
18:03:06 <gwern> secure by default
18:03:14 <pastorn> well, i could probably encript my shit, but i don't feel like it
18:03:18 <mjrosenb> pastorn: hopefully, this server does not have any public facing ports.
18:03:21 <pastorn> it's for freechess.org
18:03:29 <Philippa_> from a user's POV, SSH is as KISS as telnet these days anyway
18:03:30 <pastorn> the server is 15+ years old
18:03:48 <Philippa_> ah, so it's probably cracked to hell and back if anyone gives a shit anyway
18:04:01 <pastorn> Philippa_: probably
18:04:09 <gwern> I wonder how well a headless debian runs on a 15 year old machine these days
18:04:14 <pastorn> but the timestamp system isn't
18:04:40 <kfr> gwern: I know somebody who put Gentoo/Arch on a notebook from like 1996, I think
18:04:56 <pastorn> i have some magic binary which i probably should use to encrypt all my output moves, but i haven't bothered reading the docs yet
18:04:57 <gwern> kfr: a *notebook*? that sounds unlikely
18:05:13 <gwern> I'd believe a desktop, but notebooks were really pitiful back then
18:05:22 <pastorn> basically this magic binary adds timestamps to all moves, effectively removing lost time due to lag
18:05:32 <kfr> I'm not sure about the year tbh, but it had 32 MiB RAM, gwern
18:05:38 <kfr> Is that too much for 96? I can't remember
18:05:43 <kfr> Maybe it's younger then
18:06:02 <kfr> He showed me pictures of it, maybe I still have them
18:06:33 <kfr> Toshiba Satellite 4030 CDS
18:06:47 <kfr> Oh I guess it's newer
18:06:50 <kfr> :[
18:07:03 <kfr> Celeron A 300 MHz, 13" 800 x 600 screen
18:07:24 <kfr> Celeron series started in 1998
18:08:06 <kfr> Yep, looks like a 98 Mendocino series CPU?
18:08:17 <kfr> 250 nm process, nice
18:10:49 <gwern> a 98 I would have less trouble believing. that's 1 or 2 turns of moore's law compared to 96 depending on speicifcs
18:11:36 <kfr> Anyways, it worked fine
18:11:41 <kfr> I was quite impressed
18:11:53 <kfr> You can run a Linux kernel from 2011 on it
18:12:08 <kfr> He even ran Firefox 4 on it lol
18:12:11 <kfr> Try running Windows 7 on that thing..
18:13:14 <mjrosenb> kfr: iirc, firefox4 won't run on my desktop :(
18:13:29 <kfr> Why not?
18:13:35 <kfr> Because it's an ARM?
18:13:48 <mjrosenb> ppc64
18:13:55 <kfr> I was close though :)
18:14:02 <kfr> I was aware of the x86 specific stuff in FF
18:14:22 <kfr> mjrosenb fascinating, how come your desktop is a PPC? What CPU is that?
18:14:43 <mjrosenb> kfr: it is an G5 powermac running gentoo.
18:15:10 <kfr> I am playing with the thought of getting myself all kinds of dev boards with processors from various architectures just to code stupid stuff for them
18:15:25 <kfr> ARM dev board, some MIPS stuff, maybe an old used PPC
18:15:56 <mjrosenb> arm dev boards are pretty cheap; other processors, not necessarialy.
18:15:58 <kfr> Old used SPARC servers area available on eBay, too
18:16:06 <kfr> The most expensive thing would be an Itanium
18:16:18 <Axman6> mjrosenb: if you were running OS X on there, firefox would work fine ;)
18:16:26 <mjrosenb> Axman6: not ff4.
18:16:45 <kfr> Axman6 it uses some x86 specific stuff at the moment, and it can't be turned off? lol
18:17:53 <mjrosenb> kfr: iirc, they removed the JS interpreter, and replaced it with a JS JIT compiler
18:18:14 <mjrosenb> so if you have an arcitecture that does not have a backend supported by their JIT compiler
18:18:20 <kfr> Itanium servers on eBay look 300 EURish
18:18:20 <mjrosenb> you can't really run firefox
18:18:32 <kfr> mjrosenb right
18:18:36 <Axman6> ah, you eanted FF4
18:18:37 <mjrosenb> kfr: you should get an alphabook
18:18:42 <kfr> mjrosenb how do you deal with Flash crap?
18:18:50 <mjrosenb> kfr: and a sparcbook
18:18:57 <mjrosenb> kfr: i don't, it is amazing!
18:19:28 <geheimdienst> what is an alphabook?
18:19:48 <kfr> mjrosenb those look really exppensive/flashy/new
18:20:10 <mjrosenb> geheimdienst: have you ever heard of DEC?
18:20:23 <kfr> mjrosenb ... those are $5000-$15000
18:20:33 <kfr> I'd rather play with some uC than that...
18:20:34 <geheimdienst> oh okay :) i thought it was something new
18:20:46 <mjrosenb> kfr: and sweet pieces of hardware.
18:21:10 <kfr> Actually I should focus on simple embedded stuff, it's probably the most fun to mess with
18:21:24 <kfr> I don't need no virtual memory!
18:21:52 <mjrosenb> kfr: so you're saying that it is virtually useless?
18:22:43 <kfr> :|
18:24:45 <roconnor> can LR(k) parsers handle right-recursive grammars?
18:25:05 <int80_h> if initCurl is type initCurl :: IO Curl, and I do something like " do foo <- initCurl, does foo have type IO Curl or type Curl?
18:25:28 <geheimdienst> foo has type Curl then
18:25:46 <int80_h> gotcha, okay I see where I goofed.
18:26:05 <geheimdienst> (you can only use such a "do" block inside a function declared ... -> IO Something)
18:26:34 <int80_h> :)
18:26:38 <kfr> You done goofed up
18:27:51 <dark> roconnor, doesn't it produce the rightmost derivation? i think it would enter an infinite loop parsing a right recursive grammar
18:29:00 <dark> roconnor, maybe the software itself could remove right recursion
18:29:23 <roconnor> dark: that is what I'm thinking, but I see no evidence
18:29:43 <roconnor> dark: also it is parsing from the Left, so maybe that helps
18:30:22 <ddarius> I'm pretty sure they can, but you can do a quick experiment and find out.
18:30:34 <roconnor> I can?
18:30:54 <ddarius> Just run an LR(k) parser on a right recursive grammar and see if it terminates.
18:31:20 <roconnor> that doesn't sound quick
18:31:34 <copumpkin> halts?(parse(mygrammar))
18:31:34 <ddarius> You write a few lines of happy and execute the result.
18:31:37 <copumpkin> really easy
18:31:57 <roconnor> I'd have to learn Happy. :)
18:32:07 <Philippa_> roconnor: yeah, but you can add "in a reasonable amount of time", which is approximately an eyeblink for a small grammar, a small input and a modern CPU :-)
18:32:11 <copumpkin> or maybe it should be halts?(parse, mygrammar)
18:32:13 <kfr> What does Blah(..) in the export list mean? Export all constructors?
18:32:14 <dark> the closest wikipedia says about that is "A formal grammar that contains left recursion cannot be parsed by a naive recursive descent parser unless it is converted to a weakly equivalent right-recursive form (in contrast, left recursion is preferred for LALR parsers because it results in lower stack usage than right recursion)"
18:33:39 <mjrosenb> iirc, if a grammar is not parsable by a LR(k) parser, then, you simply cannot writ a parser for it
18:33:57 <kfr> Also, do you consider using "getBlahBlah" for record functions bad style?
18:33:58 <mjrosenb> whereas the left-recursive issue will result in non-termination
18:34:10 <kfr> I saw that LYAH did that sometimes, I had been avoiding it so far
18:34:26 <teki> kfr: yes
18:34:59 <teki> kfr: if you have a data type defined using record syntax, the names of the fields are functions that you get defined for free
18:35:16 <teki> kfr: but they're local to where you define the data type unless you export the data type with (..)
18:35:26 <kfr> Ah, I see
18:35:41 <kfr> I was manually putting them into the export list, no need then
18:36:31 <dankna> all right!  it's freaking compiling!  finally
18:36:59 <dankna> had to back out to the old ghc 6.10.4 from macports to get an x86_64 version.  then used that to build 7.0.1 and using that now to build HEAD.
18:37:14 <kfr> Don't actually execute the code though, that would be against the spirit of Haskell
18:37:20 <dankna> I agree completely :)
18:38:14 <kfr> I was just comparing C++ templates and Haskell type constraints/type variables. C++ templates essentially give you type variables but no constraints, right?
18:38:23 <teki> kfr: btw, your mileage may vary when it comes to using newtype and what you have to export
18:38:26 <jmcarthur> 6.10 can't build head?
18:38:29 <dankna> that's loosely my understanding
18:38:35 <jmcarthur> huh
18:38:43 <dankna> jmc: maybe it can, but I didn't have luck with it
18:39:06 <kfr> dankna: I was interested in making an AMD64 build of ghc 7 for Windows
18:39:12 <dankna> does anybody want my GHC-7.0.1-x86_64.pkg btw?
18:39:12 <dark> mjrosenb, I think that context-sensitive grammars can't be parsed by a LR parser (but the resulting parser could have poor performance nonetheless)
18:39:21 <kfr> But as it turns out the bootstrapping process is currently broken I read
18:39:27 <kfr> And it has been for 15 months now?
18:39:29 <dankna> no, bootstrapping is supposed to be working again
18:39:43 <dankna> it was broken at one point but is fixed now.  or that's what the wiki and trac claim..
18:39:45 <kfr> dankna: The mailing list said it's currently unfixed and won't work again until 7.2.1
18:39:57 <dankna> hrm, okay
18:40:03 <kfr> Which is some future release I suppose
18:40:12 <dankna> yes.  that would be about six months from now I suspect.
18:40:14 <kfr> They specified "Milestone: 7.2.1", whatever that may mean
18:40:16 <kfr> Ouch.
18:40:26 <dankna> do you have a link to the ticket?
18:40:29 <kfr> Yes, sec
18:40:54 <dankna> dark: well, they can be - but it's a matter of definition whether the resulting parser is truly an LR parser or not
18:40:54 <kfr> http://hackage.haskell.org/trac/ghc/ticket/3472
18:41:02 <kfr> "Porting through .hc files broken"
18:41:06 <kfr> Oh this was reported by copumpkin
18:41:13 <copumpkin> ?
18:41:15 <copumpkin> oh
18:41:17 <kfr> http://hackage.haskell.org/trac/ghc/milestone/7.2.1
18:41:29 <kfr> copumpkin: I wanted to make an AMD64 build for Windows, remember?
18:41:47 <copumpkin> vaguely :)
18:42:10 <kfr> I would totally attempt to use Clang to build this >:)
18:42:39 <kfr> I originally found your ticket linked in here: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
18:42:49 <dankna> I saw this ticket earlier today, actually
18:43:01 <dankna> I think large parts of the problem are OS X specific, but it's hard to know
18:44:15 <kfr> This is probably an inhuman task anyways, I should just leave it as it is and focus on actually learning Haskell instead lol
18:44:46 <dankna> yes, haha, at some point you have to focus on the coffee and not the cup
18:46:04 <dankna> personally my favorite ticket that I hope gets done someday soon is http://hackage.haskell.org/trac/ghc/ticket/4163 -- cross-compilation
18:46:05 <kfr> And if all else fails I can try to use another Haskell compiler
18:46:13 <dankna> no, no, use ghc :)
18:46:17 <dankna> in 32-bit mode if you must
18:46:26 <kfr> :[
18:46:29 <dankna> it has more language features and probably produces more efficient code
18:46:34 <dankna> and 32 bits isn't horrible
18:46:54 <dankna> ... because when cross-compilation works I can take another stab at cleaning the bitrot off the javascript backend
18:47:01 <kfr> dankna I don't do any number crunching anyways, this is just a purely mental issue with me
18:47:01 <geheimdienst> it appears «f = putStrLn "abc"» doesn't do the same as «f = return "abc" ; putStrLn =<< f». i suspect it's a laziness issue
18:47:06 <dankna> kfr: fair
18:47:07 <geheimdienst> so could anyone point me to documentation on IO and laziness? i'm trying to find out why this doesn't work: http://hpaste.org/43358/
18:48:06 <kfr> Oh no, lazy IO with unconditional hClose after that? :'(
18:48:24 <kfr> Lazy IO with manually closing handles is generally an issue, no?
18:48:25 <geheimdienst> yeah, so what?
18:48:50 <dankna> no that should be okay, shouldn't it?  hClose will force the buffer to clear
18:49:09 <dolio> You never hClose something you're doing lazy IO with.
18:49:13 <geheimdienst> okay, i thought i have to close the program's stdin at least. some tools will only do something once they have received all of stdin
18:49:20 <kfr> dolio that's what they told mne
18:49:32 <kfr> I think I am doing some similar crime with Network IO in my SCGI server
18:49:35 <dankna> wait, yeah, I see what you're doing.  yes it's a problem.
18:50:03 <Axman6> augustss_: are you about?
18:50:10 <geheimdienst> okay, so closing the fork's stdin is necessary, but closing its stdout and stderr is evil?
18:50:20 <dankna> I believe so
18:50:36 <dankna> well
18:50:41 <dankna> really, just don't use hGetContents
18:50:46 <kfr> But in my case the sClose always depends on the contents from a previous recv so it already has to be evaluated at that point I think - I should still look at Enumeratee or whatever it was called at some piont
18:50:52 <kfr> Although Axman6 said that that stuff leaks
18:50:54 <dankna> make your own function that reads strictly
18:50:59 <kfr> When optimisations are activated
18:51:06 <kfr> Axman6 what compiler do you use at work?
18:51:08 <kfr> ghc 6 or 7?
18:51:13 <Axman6> both
18:51:27 <kfr> dankna I would, but how?
18:51:28 <Axman6> things seem to always leak with 6, and only in 7 when we use optimisation
18:51:38 <Axman6> i'm no expert on the matter though
18:51:48 <geheimdienst> dankna, could you elaborate what such a function might look like?
18:51:54 <kfr> Do you just convert it to a strict ByteString instead, for example?
18:51:55 <dankna> I can give it a shot, sure.
18:51:56 <dankna> one sec.
18:52:06 <geheimdienst> thanks a lot
18:52:12 <roconnor> $ happy Test.y
18:52:14 <roconnor> shift/reduce conflicts:  1
18:52:17 <roconnor> gee, thanks Happy
18:52:25 <kfr> Axman6: Just with Enum. or with other stuff, too?
18:52:31 <Axman6> hmmm?
18:52:32 <roconnor> very informative
18:52:33 <dankna> roconnor: you can make it spit out the full parse table with a parameter
18:52:38 <Axman6> maybe we're talking about different things...
18:52:45 <Axman6> what're you on about kfr? ::P
18:52:59 <kfr> Axman6: Is anything other than the Iterator/Enum stuff leaking? You said that was leaking, I remember you arguing about it with somebody in here
18:53:29 <kfr> <mm_freak_> Axman6: actually i don't see any way for (>>=) to leak memory without a faulty enumerator
18:54:20 <Axman6> we're still working on it. I'm hoping my colleague will write a blog post on my blog about the issue when we finally fax the problem
18:54:46 <kfr> But that was restricted to that package, right? It wasn't just ghc leaking on you in general?
18:54:53 <kfr> Because what you just said scared me
18:55:03 <roconnor> dark: 
18:55:03 <azaq23> geheimdienst: In your example, stdout is not evaluated due to laziness, you could force the evaluation using seq / $! in your function
18:55:04 <roconnor> Exp  : 'x' '+' Exp           { Plus $3 }
18:55:06 <roconnor>      | 'x'                   { X }
18:55:20 <roconnor> dark: Happy accepts this right recursive grammar.
18:55:26 <azaq23> geheimdienst: x <- shell "echo lol2" $ \_ stdout _ -> return $! stdout
18:55:35 <Axman6> kfr: it seems to be the package, but we're not sure
18:55:43 <kfr> Alright
18:55:53 <kfr> azaq23 oh I heard about seq/par in the SPJ lecture on Data Parallel Haskell
18:55:54 <Axman6> i'll let you know when we figure it out if you like
18:56:04 <kfr> Axman6 that would be great, thanks
18:56:34 <revenantphx> :D
18:56:35 <revenantphx> str = "?" + "&".join(["%(key)s=%(val)s" % {"key":key, "val":val} for (key, val) in a.items()])
18:56:40 <revenantphx> Best line of python, I have ever written.
18:56:41 <geheimdienst> azaq23: is it advisable to do that? suppose i run "cat 3GB-of-stuff" and the haskell code needs only the first line of it ...?
18:57:09 <Axman6> use iteratees!
18:57:13 <kfr> I mean I'm a total newb at Haskell but I am attempting to learn the language for perfection/kicks/insanity etc so some serious sneaky creeping faults in the GHC GC severely threaten my mental health
18:57:21 <dankna> http://hpaste.org/43359/hgetstuff
18:57:27 <dankna> I think this will work but I haven't even checked it at all
18:57:33 <Axman6> kfr: if you're looking to use iteratees, i'd advice using the enumerator package. it's much simpler
18:57:33 <geheimdienst> Axman6: who, me?
18:57:35 <dankna> treat it as a general outline of what you have to do
18:57:38 <Axman6> geheimdienst: yes
18:57:40 <kfr> Alright
18:57:53 <kfr> Yesterday somebody told me that GHC 6 never gave back memory to the system in its GC, that sounded pretty messed up
18:58:07 <revenantphx> Neither does python.
18:58:07 <Axman6> kfr: micheal snoyman's blog has a pretty good introduction to thee package
18:58:09 <kfr> But I think somebody told me that GHC 7 does that now
18:58:18 <geheimdienst> axman6: okay ... this the right place to start? http://hackage.haskell.org/package/iteratee
18:58:20 <revenantphx> Basically, python keeps this heap,
18:58:20 <Axman6> kfr: GHC 6.12 gives memory back
18:58:29 <kfr> Oh, ok, so it was a false rumour?
18:58:33 <revenantphx> and whenever it needs more memory, it gets more, but first it tries to reuse existing memory
18:58:35 <Axman6> geheimdienst: i'd recommend the enumerator package
18:58:38 <revenantphx> (it never gives back automatically though)
18:58:45 <azaq23> geheimdienst: It is something which works and is, of course, against the "point" of lazy IO. I used this for simple, little files which need to be read completely on startup
18:58:47 <Axman6> kfr: it used to not give memory back
18:58:58 <kfr> Axman6: That was pre 6.12 though?
18:59:04 <Axman6> yes
18:59:18 <azaq23> geheimdienst: The problem is that stdout is hClose'd before it can be read
18:59:28 <geheimdienst> dankna: thanks a great deal :)
18:59:35 <kfr> I've also read claims that the Oracle JVM doesn't give back memory to the system until there is more pressure, strange stuff, I guess most of it can be swapped out though (I hope)
18:59:46 <dankna> geheimdienst, no problem :)
19:00:01 <dankna> I could have sworn there used to be a way to do it without catching an exception, but I don't see a way now
19:00:21 <edwardk> preflex: xseen ivanm
19:00:22 <preflex>  ivanm was last seen on freenode/#haskell 1 hour, 3 minutes and 27 seconds ago, saying: 50% of runtime is generating Text values... :s
19:00:39 <int80_h> mkdir /quit
19:01:05 <dankna> mkdir /quit?  that's an amusing typo
19:01:12 <dankna> or an amusing joke, if it is one
19:01:24 <kfr> /shutdown -h 0
19:01:27 <dankna> ha
19:01:30 <azaq23> geheimdienst: I'm not sure how someone more knowledgeable in the intricancies of IO in haskell / GHC views this. Also, hallo deutschland.
19:02:19 <dafis> How do I debug a stack overflow? I get no stack overflow when compiling with 6.12, nor when compiling with profiling, but with 7.0.1 and a HEAD from October, it overflows. For extra weirdness, compiling the same code earlier with 7.0.1 produced a non-overflowing binary. Any ideas?
19:02:44 <dankna> that is weird
19:02:54 <dankna> if it were happening to me I might try profiling
19:03:10 <kfr> By the way, what is the rationale behind using an absolute path in the module statement instead of a relative one?
19:03:11 <dankna> but I'm not fully sure how to do that myself, so I can't explain it :)
19:03:22 <kfr> Absolute ones seem more redundant to me
19:03:24 <dafis> dankna:  profiling means no overflow, I've tried that
19:03:29 <dankna> oh, hunh.
19:03:32 <geheimdienst> azaq23: thanks so far :) i'll make a new version and see how it goes
19:03:37 <dankna> try a full clean, in case you've got a stale .o or something?
19:03:50 <dafis> dankna:  already done
19:03:53 <dankna> drat
19:04:00 <dafis> you say it
19:04:18 <dankna> kfr: I don't know the rationale, but what are you envisioning a relative one might look like?
19:04:38 <kfr> dankna: module Blah instead of module The.Full.Bloody.Path.Blah
19:04:43 <dankna> oh
19:05:00 <kfr> And whenever I move modules I need to rename tons of stuff
19:05:04 <kfr> Inside the source
19:05:09 <dankna> I dunno, it's probably a matter of preference, but note that The.Full.Bloody.Path tells ghc where to find other modules
19:05:40 <dankna> if you happen to invoke it on a single module rather than on a top-level Main, that is, ghc has no way of knowing where the top of your hierarchy lies without that full path
19:05:44 <kfr> dafis: Have you tried using the current HEAD btw?
19:06:09 <kfr> dankna oh, hm
19:06:11 <geheimdienst> kfr: not sure what exactly you want, but i usually don't rename when importing, i just prefix some modules ... import qualified Stuff.Stuff as S
19:06:11 <dankna> you're right that having to rename stuff in multiple places is a bad thing, but I'm not clear there's an easy way around it
19:06:14 <dafis> kfr:  not yet, I haven't built one
19:06:35 <geheimdienst> wait, you mean renaming modules or functions ...?
19:06:35 <kfr> geheimdienst: No, I mean I have to rename the modules themselves, not just the components which use them
19:06:39 <dankna> modules
19:06:43 <kfr> The components which use them need to be updated either way
19:06:50 <kfr> Because their path changed
19:06:54 <geheimdienst> i see
19:09:03 <copumpkin> http://www.cl.cam.ac.uk/~jrh13/slides/cmu-19mar07/slides.pdf 
19:09:44 <dankna> wow, talk about over my head
19:10:51 <edwardk> ddarius: oh, looks like the Monad transformer for ContsT is fine
19:10:57 <kfr> copumpkin: RAND! = ?
19:11:04 <kfr> Page 6
19:11:12 <copumpkin> kfr: AYN?
19:11:27 <kfr> Ayn Rand was probably mathematically illiterate
19:11:33 <kfr> I doubt she was referenced in this paper
19:11:46 <kfr> Tarski proved in the 1930s that the theory of real-closed ﬁelds is
19:11:46 <kfr> complete and decidable, and even exhibited a quantiﬁer elimination
19:11:46 <kfr> procedure for it.
19:11:46 <kfr> This was only published in 1948 (by RAND!)
19:11:49 <kfr> Fail paste
19:11:57 <kfr> That "RAND!"
19:12:03 <edwardk> RAND corporation?
19:12:20 <edwardk> yep thats it
19:12:40 <kfr> I thought that was some far right think tank from the US, what do they have to do with math?
19:13:03 <edwardk> they published various bits of tarski stuff around that timeframe
19:13:10 <kfr> Really? Curious
19:13:17 <edwardk> e.g. http://www.rand.org/pubs/authors/t/tarski_alfred.html
19:14:55 <copumpkin> so anyway, that led me to ask
19:15:19 <copumpkin> does that mean that universal-only statements over the naturals with addition _and_ multiplication are decidable?
19:15:44 <copumpkin> it seems to follow from what he says at the end
19:16:25 <copumpkin> (multiplication by quantified variables, not just constants à la presburger)
19:20:03 <Saizan> that would be quite good news
19:20:44 <copumpkin> unfortunately it doesn't cover modular arithmetic, as far as I know
19:21:08 <copumpkin> since it isn't nicely ordered, or an integral domain
19:21:09 <kfr> Wow, this is massive, this will really help me with my programs
19:21:19 <copumpkin> kfr: you being sarcastic?
19:21:25 <kfr> Yes
19:21:28 <copumpkin> :(
19:21:35 <copumpkin> I'm actually kind of excited
19:21:42 * ivanm needs to find a better way of benchmarking graphviz rather than relying on its test-suite...
19:21:44 <kfr> Sorry for being a Coq
19:21:49 <ivanm> copumpkin: what are you excited about?
19:21:57 <copumpkin> those slides I linked to above
19:22:02 <copumpkin> http://www.cl.cam.ac.uk/~jrh13/slides/cmu-19mar07/slides.pdf
19:22:27 <copumpkin> I'm 99% sure that the TypeNat stuff going into GHC is using a presburger solver
19:22:31 <copumpkin> which only handles constant multiplication
19:23:06 <copumpkin> and since we don't care about existential quantification
19:23:25 <copumpkin> this could actually let GHC automatically figure out more types for you
19:23:35 <geheimdienst> TypeNat, TypeNet, TypeNut, what's the difference
19:23:43 <copumpkin> :P
19:23:54 * copumpkin gives up
19:24:03 <copumpkin> when #haskell dismisses you as being too impractical, you know you have a problem
19:24:24 <kfr> Haha
19:24:48 <kfr> When you are in #haskell you already clearly have a problem
19:24:56 <geheimdienst> what is a TypeNat?
19:24:57 <kfr> Being afflicted with the cancer of Haskell
19:25:07 <copumpkin> geheimdienst: an extension to GHC that's being worked on quite actively
19:25:12 <copumpkin> that gives you first-class naturals at the type level
19:25:15 <copumpkin> and a kind for them
19:25:20 <copumpkin> and magic solving capabilities
19:25:42 <geheimdienst> so it's about natural numbers?
19:26:03 <copumpkin> yeah
19:26:08 <geheimdienst> i see
19:26:45 <jmcarthur> i can't wait
19:26:48 <kfr> Doesn't sound like anything I would ever care to import
19:26:48 <geheimdienst> so could you make a type ListWithALength 14 String using this thing?
19:26:50 <jmcarthur> feel better, copumpkin?
19:26:56 <copumpkin> yay
19:26:56 <copumpkin> yep
19:27:16 <jmcarthur> i mostly look forward to a decent vector-static :)
19:27:23 <jmcarthur> or repa-static
19:27:43 <copumpkin> yeah, it'll enable exactly that
19:27:51 <geheimdienst> that sounds vaguely useful. you could enforce "this list must at least have 3 things" at the type-level
19:27:53 <copumpkin> and several other fun things
19:28:04 <copumpkin> geheimdienst: you already can, but it's a real pain to do anything useful with at all
19:28:04 <geheimdienst> Prelude.head without a runtime error, etc.
19:28:09 <copumpkin> since you have to prove
19:28:19 <copumpkin> prove things that are fairly trivial, most of the time
19:28:39 <jmcarthur> data List n a where Nil :: List Z a; Cons :: a -> List n a -> List (S n) a
19:28:45 <jmcarthur> that's the easy part
19:28:50 <jmcarthur> using it, however, is tougher
19:29:08 <geheimdienst> a few minutes of explanation later, geheimdienst thinks TypeNat is a useful extension of the type system
19:30:37 <Saizan> copumpkin: does it really work for naturals? it seems to require an "ordered integral domain", so integers
19:30:51 <copumpkin> yeah, but then you can specify a >= constraint on it
19:30:58 <copumpkin> >= 0
19:30:58 <Saizan> heh, true
19:31:12 <andy_> is rdtsc particularly accurate?  are orders of magnitude differences suggestive one means may be quicker than another?
19:31:32 <copumpkin> so the result that multiplication is undecidable on naturals only arises in the presence of existential quantification? 
19:31:36 <azaq23> that seems like kind of dependent typing, just only with naturals and a specific kind for them
19:31:39 <copumpkin> I'm really hoping that's true
19:31:48 <kfr> andy_: I really wouldn't use it for any benchmarking, you need something more macroscopic than that
19:32:04 <copumpkin> azaq23: well, dependent types can express those properties, but the point of this stuff is to automatically derive proofs for them
19:32:06 <jmcarthur> azaq23: it's often seen in DT languages, sure
19:32:32 <copumpkin> unfortunately, the only implementation of real-closed field QE I can find is in some rather opaque ocaml code
19:32:40 <copumpkin> and I keep meaning to slog through it and translate it to nice haskell
19:32:46 <copumpkin> but then I look and lose steam
19:33:03 <Saizan> why god made ocaml so ugly?
19:33:16 <copumpkin> to punish us for the original sin :(
19:33:41 <copumpkin> http://hackage.haskell.org/package/presburger is nice though
19:33:41 <Saizan> must have been an horrible sin
19:33:57 <andy_> kfr, thanks
19:36:30 * copumpkin should really sit down and finish writing his primops
19:48:04 * copumpkin just asked the question on mathoverflow, for the fun of it
19:48:42 <Saizan> the TypeNat stuff is still non-public?
19:48:52 <copumpkin> I think there's a repo of it somewhere
19:48:53 <copumpkin> let me find it
19:49:03 <copumpkin> http://code.galois.com/darcs/type-naturals/
19:49:08 <copumpkin> and http://hackage.haskell.org/trac/ghc/wiki/TypeNats
19:54:55 <Saizan> nice
19:55:14 <copumpkin> also, it looks like rebindable if-then-else is now in HEAD
19:55:18 <copumpkin> and possibly even in 7
19:55:40 <ivanm> "rebindable"?
19:56:04 <copumpkin> it's equivalent to a Bool -> a -> a -> a function
19:56:19 <copumpkin> if x then t else f => cond x t f
19:56:22 <djahandarie> Was if' ever added to base?
19:56:36 <copumpkin> it lets you override cond
19:56:41 <copumpkin> with a few limitations
19:57:05 <ivanm> djahandarie: nope
19:57:15 <hydo> Is 0.8.2 the version of cabal-install that I'm supposed to use with ghc7?
19:57:30 <ivanm> hydo: you have to build cabal-install with ghc < 7
19:57:38 <ivanm> there is as yet no version of c-i that builds with 7
19:57:47 <ivanm> it works with 7 though
19:57:57 <ivanm> a 7-buildable version is coming Real Soon Now apparently :p
19:58:41 <copumpkin> no released version?
19:58:56 <ivanm> nope
19:59:11 <ivanm> I'd say to check darcs, but c.h.o is down...
19:59:42 <hydo> darcs.haskell.org is up
20:00:03 <hydo> looking at the source now.  trying to figure out how to get it with no ghc/cabal installed.
20:00:06 <ivanm> I thought everything was migrated off from there...
20:00:29 <ivanm> hydo: get ghc 6.12.3, then use the bootstrap.sh script (on *nix) inside the cabal-install tarball
20:04:19 <ivanm> copumpkin, edwardk: the graph talk is going to starting in about 15 min: http://lca2011.linux.org.au/stream/N515-QUTandUrbanest%28AU%29.html
20:04:52 <edwardk> ivanm: i'd watch but i'm rather fried ATM
20:05:03 <ivanm> well, it will be online in a week or so
20:05:10 <ivanm> copumpkin just wanted me to ping him about it
20:05:15 <hydo> ivanm: Yea, thanks.  I appreciate the help.  I guess I'm just stunned by the fact that I'd need to do that.  I'll just stay with 6.12.3 and plug my eyes when I read yet another blog post about how awesome 7 is.
20:05:16 <copumpkin> thanks :)
20:05:33 <ivanm> hydo: *shrug* maybe wait until the platform?
20:05:41 * ivanm hasn't upgraded to 7 yet, but that's mainly out of laziness
20:05:45 <hydo> yea, that's probably best.
20:05:58 <copumpkin> streaming is very slow here :/
20:06:03 <copumpkin> one frame every few seconds
20:06:04 <geheimdienst> ivanm, ghc 6 supports laziness as well
20:06:08 * ivanm heads off to that room
20:06:14 <ivanm> geheimdienst: _my_ laziness, not ghc's!
20:06:20 <hydo> haha
20:06:23 <edwardk> ivanm: wave to the camera! =)
20:06:33 * geheimdienst successfully trolled ivanm in a minor way :)
20:07:50 * hackagebot Tablify 0.8 - Tool to render CSV into tables of various formats  http://hackage.haskell.org/package/Tablify-0.8 (DanielLyons)
20:09:50 <djahandarie> Oh hey, I know Arjen Lentz
20:10:01 <djahandarie> ...a little
20:10:23 <kfr> What is the purpose of the Writer monad btw? If you can only transmit data to the monad, what's the point?
20:10:59 <shachaf> kfr: What does "transmit data to the monad" even mean?
20:11:04 <copumpkin> to the monoid
20:11:09 <copumpkin> kfr: you read it out at the end
20:11:18 <kfr> Oh, I see
20:11:28 <geheimdienst> kfr, the way i understand it, you might use it for things like print out log messages at various points, then at the end, get them all
20:11:33 <shachaf> @unmtl Writer [a] b
20:11:34 <lambdabot> (b, [a])
20:11:39 <copumpkin> or do anything monoidish
20:11:43 <copumpkin> you could add up numbers
20:11:45 <shachaf> That's all it is -- just an output stream you can append to.
20:12:08 <shachaf> That tuple is backwards, by the way. :-(
20:12:09 <copumpkin> if you want useless
20:12:13 <copumpkin> @unmtl Writer () a
20:12:13 <lambdabot> (a, ())
20:12:20 <kfr> Are Reader, Writer and State related at all? Is it basically r vs. w vs. rw?
20:12:27 <copumpkin> yes
20:12:30 <shachaf> kfr: Not exactly.
20:12:31 <kfr> Alright
20:12:34 <kfr> :[
20:12:43 <copumpkin> Writer has a monoid on it, unlike the other two
20:12:45 <shachaf> kfr: Writer doesn't have "put" like State; it only has "append".
20:13:09 <geheimdienst> shachaf, this explanation "an output stream you can append to" is damn useful. i wish these kinds of one-liners were in the haddocks in bold at the top ...
20:13:48 <shachaf> kfr: But you can use State to simulate the other two.
20:14:12 <shachaf> kfr: "tell x" is approximately "modify (++ x)".
20:14:14 <kfr> Yeah I know that the methods are different from each other
20:14:20 <copumpkin> Saizan: I guess not :( http://mathoverflow.net/questions/53445/real-closed-fields-minus-existentials-for-presburger-like-power-and-multiplicatio
20:14:30 <kfr> And that they aren't instances of a common specific typeclass or anything like that
20:14:35 <kfr> (except for Monad obviously)
20:14:50 <shachaf> kfr: Sure, but it's not quite "r/w/rw".
20:15:20 <shachaf> There's also RWS.
20:15:25 <kfr> s = ?
20:15:31 <shachaf> State.
20:15:36 <shachaf> I mean the RWS monad.
20:15:46 <kfr> Oh, not familiar with it
20:16:00 <shachaf> @unmtl RWS r [w] s a
20:16:01 <lambdabot> r -> s -> (a, s, [w])
20:16:11 <geheimdienst> Reader is kinda the mirror image of Writer. you put in stuff at the beginning, then it stays unchanging until runReader is complete. (think environment variables in unix. they're set when a program starts and the program reads from them)
20:16:11 <shachaf> Just what you'd think.
20:16:26 <geheimdienst> as for State, i dunno. haven't gotten there yet :)
20:16:47 <copumpkin> state is (->) a and (,) a stuck together!
20:16:50 <djahandarie> Whoever set up this stream has no idea how to set up a stream
20:16:51 <copumpkin> in a holy union
20:16:55 <copumpkin> djahandarie: I agree
20:17:09 <djahandarie> x264 -vbr-maxrate -crf you idiots!
20:18:52 <djahandarie> I wonder if we can see ivanm
20:18:59 <geheimdienst> oh, so it's an html5 video thingy. i was wondering, i have my browser set to not play flash by itself ...
20:19:06 <kfr> Is it alright to use a StateT for related values but some of which are basically read only? Or do you consider that bad style?
20:19:10 <geheimdienst> yeah, that was ivanm right there. the dude with the pointy rice hat
20:19:23 <djahandarie> Haha
20:19:53 <kfr> I guess it's not a big deal but it would seem tidier to control the access with greater granularity somehow then
20:20:24 <ivanm> edwardk: the camera doesn't point at _me_ for some reason...
20:20:44 <djahandarie> lol ivanm 
20:20:45 <geheimdienst> ivanm, would you walk up to the stage for us, for a moment?
20:20:54 <ivanm> ummm, NO!
20:20:55 <geheimdienst> just wave a little or something
20:21:00 <ivanm> (there's no stage for starters)
20:21:09 <djahandarie> Go punch arjen
20:21:27 <geheimdienst> "he doesn't need any introduction. he's a very famous hacker from what i hear" <- well that kinda contradicts itself
20:22:46 <djahandarie> MyISAM isn't good at anything
20:22:51 <djahandarie> He's wrong!
20:23:31 <copumpkin> lol
20:23:45 <copumpkin> it felt so good when I first moved from mysql to postgresql
20:23:53 <geheimdienst> omg he doesn't have xmonad
20:24:08 <djahandarie> Pretty sure he doesn't do any Haskell :P
20:24:19 <ivanm> geheimdienst: ... and?
20:24:22 * kfr moved from MySQL to PostgreSQL, too
20:24:51 <kfr> I recently had to deal with MySQL again, I was annoyed by how you can't even set up pg_hba style authentication without extensions for MySQL :'(
20:25:18 <kfr> I never use passworded authentication on fully local servers
20:25:36 <kfr> All user based mostly
20:25:47 <ivanm> edwardk: his implementation needs to load the entire graph in RAM: sounds like he needs monadic graph combinators! :p
20:26:22 <gwern>  no, graphs are arrows! it came to me in a dream
20:26:37 <copumpkin> maybe they are, but nobody wants to use them as such
20:26:42 <djahandarie> gwern, so they are just functions right?
20:26:44 <djahandarie> Right?
20:26:50 <geheimdienst> finally found the blog post that talk reminds me of: http://blog.directededge.com/2009/02/27/on-building-a-stupidly-fast-graph-database/
20:26:54 <gwern> djahandarie: let me sleep on it
20:27:46 * ivanm wonders what gwern's next dream will bring
20:28:31 <kfr> :t asks
20:28:32 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
20:28:34 <kfr> :t gets
20:28:35 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
20:28:37 <ivanm> geheimdienst: as soon as he started talking about geek-cred, etc. I stopped reading
20:29:32 <geheimdienst> yeah, seems like a bit of a showoff ...
20:29:39 * geheimdienst shrugs
20:31:05 <ivanm> since my test-suite is now limited (as in about 50% of the run-time is taken up by) generating Text values, what would be a better benchmark for graphviz?
20:31:10 <kfr> http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes <- haha is this supposed to be a joke
20:31:24 <Axman6> ivanm: how are you creating the text values?
20:31:26 <kfr> 9 Topics that don't fit in 10 minute limit: [everything]
20:31:32 <ivanm> pick some Dot graphs and use criterion to time how long it takes to parse it, print it and then parse it again?
20:32:09 <ivanm> Axman6: basically liftM Text.pack arbString (arbString :: Gen String)
20:32:21 <ivanm> text's test sutie does the same, but doesn't care about the format of those Strings; I do
20:32:50 <ivanm> even the String version was dominated by generating Strings; having to pack them just makes it worse/more obvious :s
20:33:12 <Axman6> so you're not using a builder library then
20:33:18 <Axman6> not sure if that'd make much difference
20:33:45 <Axman6> how does arbString work? could you not make a text bersion?
20:33:47 <Axman6> v*
20:34:14 <ivanm> arbString is basically: listOf1 $ elements validChars
20:34:40 <Axman6> could you make a arbText version?
20:35:11 <ivanm> yeah, I'm trying to use T.concat rather than T.pack
20:35:17 <ivanm> not sure if it will make it any more efficient
20:35:42 <Axman6> if possible you want to avoid using strings at all basically
20:35:45 <ivanm> but still, if the old String version was dominated by generating String values anyway, it doesn't help much with testing how fast the printer and parser is :s
20:38:22 <geheimdienst> might be missing something obvious, but do you need the generate step at every benchmark run? if you stored the generation result and then only benchmarked load-print-parse ...?
20:38:35 <ivanm> yeah, not doing that
20:38:56 <ivanm> my "benchmarking" atm is basically "time how long the test suite takes to run"
20:39:18 <Saizan> ..that's really wrong
20:39:44 <ivanm> Saizan: yeah, it was more that I abused the test suite more than anything else
20:40:01 <ivanm> especially when the run-suite of the test suite became smaller after a couple of simple optimisations
20:40:54 <ivanm> this graph talk is actually rather boring...
20:41:20 <copumpkin> lol
20:41:35 <copumpkin> yeah, it was enough to make me go back to my boring primops
20:41:38 <copumpkin> which is a bad sign
20:42:06 <ivanm> heh
20:42:11 <djahandarie> ivanm, yeah sounds like pretty standard stuff
20:42:16 <ivanm> I didn't realise it was just "omg, graphs in mysql!"
20:42:17 <ivanm> :/
20:44:15 <geheimdienst> it is slightly interesting that they found a way to query graphs from regular sql, without major uglitude. but other than that, you're right
20:44:45 <ivanm> it's interesting the kind of slow down profiling with Text values causes
20:45:04 <copumpkin> what's slow in Text?
20:45:49 <ivanm> copumpkin: I think bos put some extra profiling things in them or something
20:45:53 <ivanm> fusion is probably also disabled
20:46:06 <ivanm> normally building an executable with profiling enabled results in roughly a 2x slow-down; I'm currently experiencing a 4x slowdown :s
20:46:42 <dafis> text had -auto-all for ghc-prof-options, that kills performance pretty much completely
20:47:00 <geheimdienst> > "unikonts" == "unicorns"
20:47:01 <lambdabot>   False
20:47:06 * geheimdienst is relieved
20:48:37 <geheimdienst> so we belong to the haplorrhines, aka the dry-nosed primates ... http://en.wikipedia.org/wiki/Haplorrhini
20:48:44 <Veinor> why is Network.HTTP telling me  hGetContents: invalid argument (Invalid or incomplete multibyte or wide character
20:49:24 <geheimdienst> encoding mismatch ...?
20:49:33 <Veinor> i'm assuming so
20:50:00 <Veinor> but i"m not sure how to make it try unicode or something else
20:52:09 <aristid> preflex: seen cdsmith
20:52:10 <preflex>  Sorry, I haven't seen cdsmith
20:52:13 <aristid> preflex: seen cdsmithus
20:52:14 <preflex>  cdsmithus was last seen on #haskell 9 days, 40 minutes and 5 seconds ago, saying: Oh.  Yeah, the answer I gave doesn't do that, of course... something tells me it was just a guess because someone wanted an answer.
20:52:24 <ivanm> Veinor: with 6.12+ it will use your locale
20:53:50 <geheimdienst> otherwise, would hSetEncoding work? also, i seem to remember i once ran into trouble because things in the haddock listed under "encoding-aware" actually weren't, they were only planning to do it. might be that that's what they fixed with 6.12
20:54:06 <geheimdienst> so tread carefully in the haddock
20:54:24 <Veinor> ivanm: that's the problem
20:55:36 <Veinor> ... hm
20:56:01 <ivanm> Veinor: do you know what the encoding is?
20:56:20 <Veinor> no. :/
20:56:36 <ivanm> then even under <6.12 you'd have possible problems!
20:56:41 <Veinor> hm!
20:57:25 <aristid> know thy encoding!
20:57:41 <Veinor> odd.
20:57:50 <Veinor> when I run my script directly from the command-line, everything's happy
20:57:57 <ivanm> :o
20:58:00 * hackagebot highlighting-kate 0.2.8.2 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.8.2 (JohnMacFarlane)
20:58:14 <Veinor> but when my snap program calls it, things break
20:58:24 <monochrom> you should probably hSetEncoding utf8 to force all your users to UTF-8
20:58:29 <Veinor> sounds like a plan!
20:58:38 <Veinor> since it' slikely i'm getting utf8
20:58:41 <geheimdienst> veinor, LANG or LOCALE variable not set on a server process, but _is_ set on your bash process
20:58:52 <geheimdienst> ?
20:58:57 <Veinor> geheimdienst: I don't see how that'd be possible considering I'ms tarting them both from the same shell, but it's possible!
20:59:05 <Veinor> "I don't see how that'd be possible... but it's possible!"
20:59:22 <monochrom> you don't see, but you meta-see :)
20:59:27 <Veinor> yes :D
20:59:51 <geheimdienst> hm, okay. maybe snap sets it to null ... you can examine a process' environment variables from /proc/
21:00:48 <Veinor> hm
21:00:56 <Veinor> lang in snap and my shell are both en.US_UTF8
21:01:18 <Veinor> i'm just going to directly add a print hGetENcoding stdin
21:01:41 <Veinor> ... or maybe print <$> getEnvironment
21:01:51 <geheimdienst> oh wait, this stuff doesn't take effect unless in your haskell program calls setlocale
21:01:56 <geheimdienst> (confusingly named)
21:02:02 <Veinor> blah
21:02:35 <aristid> :t print <$> getEnvironment
21:02:36 <lambdabot> Not in scope: `getEnvironment'
21:02:46 <aristid> :t print <$> return ()
21:02:47 <lambdabot> forall (f :: * -> *). (Monad f, Functor f) => f (IO ())
21:03:00 <aristid> Veinor: print =<< getEnvironment?
21:03:13 <Veinor> yeah that's what I meant
21:03:18 <Veinor> anyway
21:03:38 <Veinor> i can't print the current encoding because textencoding isn't an instance of show, even though haddock says it is :/
21:04:11 <Veinor> :i TextEncoding
21:04:19 <Veinor> oh right, that's in IO anyway so \bot wouldn't have it
21:05:05 <kfr> :t (>>=)
21:05:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:05:12 <kfr> :t (=<<)
21:05:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:05:50 <kfr> getEnvironment >>= print -- is this this the same?
21:06:43 <kfr> Oh, Hoogle can look these up, right
21:06:48 <geheimdienst> kfr, yes
21:06:53 <kfr> Ah, thanks
21:07:05 <ivanm> and Text.tail is bitching that there's non-empty input... not sure where that is coming from :s
21:07:18 <kfr> <<= seems far more intuitive to mw
21:07:20 <kfr> me*
21:08:32 <azaq231> normal notation vs reverse polish notation
21:08:58 <Veinor> I'm really tempted to write a hoogle js-injector
21:08:58 <azaq231> > let f = (+ 2); g = (* 10) in (f . g $ 10, g >>> f $ 10)
21:09:00 <lambdabot>   (102,102)
21:09:05 <Veinor> that lets you add stuff like packages by default
21:09:13 <azaq231> @src (=<<)
21:09:14 <lambdabot> f =<< x = x >>= f
21:09:15 <Veinor> 'cause it does index every package, it just only searches the platform-ish
21:09:50 <kfr> Woops, *=<<
21:10:27 <Veinor> okay... snap is setting LC_ALL and stuff
21:10:32 <Veinor> so I'm not sure what the problem here is exactly
21:11:41 <ivanm> Veinor: neil has said he's wondering which packages to add to the default list
21:12:10 <Veinor> i'd rather he have some way to let each user choose what to add to their own default list :D
21:12:23 <ivanm> yeah, I see what you mean
21:12:37 <ivanm> hooray, I got a glibc warning from my Haskell program! \o/
21:12:44 * ivanm arbitrarily blames bos
21:12:45 <Veinor> \o/
21:12:52 <Veinor> hey, what'd boston do to you?
21:12:58 <ivanm> though it's quite possible the fault is with dot
21:13:06 <ivanm> Veinor: >_>
21:13:08 <ivanm> preflex: seen bos
21:13:08 <preflex>  bos was last seen on #haskell 1 day, 6 hours, 20 minutes and 39 seconds ago, saying: aristid: thanks, fixed
21:13:43 <Veinor> oh, shoot. textencodings are only showable in 4.3
21:13:45 <tolkad> phase control seems like a ridiculous exposition of ghc internals
21:16:16 * Veinor grumps
21:17:03 <stepkut> i wish my library didn't have to depend on other packages just so i could include class instances for types in those packages :-/
21:17:52 <tolkad> stepkut: I wonder if it is possible to detect if a package has already been imported using some combination of cabal and CPP
21:18:49 <geheimdienst> ghc tells me: No instance for (IsString (IO a)). i do have an instance of (IsString (IO String)) ... so what do i do?
21:18:54 <geheimdienst> can the answer be defaulting?
21:19:51 <stepkut> tolkad: I am not sure how that would help
21:20:17 <geheimdienst> i mean, i'd like it to try the (IsString (IO String)) instance whenever it's encountering a (IsString (IO a))
21:21:02 <monochrom> perhaps something about UndecidableInstances
21:22:47 <tolkad> stepkut: if cabal if statements were able to test what packages were included, you could set a CPP definition like TRANSFORMERS_INCLUDED, and make your import and instances conditional on that
21:23:45 <geheimdienst> monochrom: thanks for the suggestion, but that didn't work
21:24:22 <Veinor> ugh. tempted to uninstall the haskell platform, then reinstall ghc 6.12.3
21:25:11 <tolkad> stepkut: tell the cabal maintainers they should make it so :P
21:25:21 <monochrom> uninstall-reinstall does not seem to be relevant to text encoding
21:27:22 <Veinor> monochrom: 6.12.1 doesn't have a Show instance for TextEncoding, 6.12.3 dose
21:27:23 <Veinor> *does
21:28:04 <Saizan> geheimdienst: you could do instance (a ~ String) => IsString (IO a) where ...; that'd conflict with other IsString (IO Foo) instances though
21:28:34 <monochrom> no wonder. I see.
21:28:58 <geheimdienst> woah, never seen a squiggle in that place
21:29:03 <monochrom> well haskell platform 2010.2.0.0 is about ghc 6.12.3
21:29:31 <Veinor> Package: haskell-platform
21:29:32 <Saizan> geheimdienst: requires TypeFamilies
21:29:32 <geheimdienst> ah, TypeFamilies
21:29:35 <Veinor> Version: 2010.1.0.0.1
21:29:36 <geheimdienst> :) thanks
21:30:07 <monochrom> there was a 2010.1.0.0.1? that's strange.
21:30:27 <Veinor> it is.
21:31:16 <geheimdienst> so i have no clue what type families are, but they're helping me \o/
21:31:22 <geheimdienst> thanks saizan, was exactly the right idea
21:31:32 <monochrom> actually I can't see TextEncoding in 6.12.3 being a Show instance.
21:31:46 <Saizan> np
21:33:33 <copumpkin> I'm not really sure why ~ is bundled in with TypeFamilies though
21:33:36 <copumpkin> it's useful outside of them
21:34:01 <monochrom> in fact it says data TextEncoding = = forall dstate estate . TextEncoding  { mkTextDecoder :: IO (TextDecoder dstate), mkTextEncoder :: IO (TextEncoder estate) }  This is highly unshowable.
21:34:48 <monochrom> you're probably looking at ghc 7 if you see Show TextEncoding
21:35:28 * geheimdienst sees a (textEncodingName :: String) here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-IO-Encoding-Types.html#t:TextEncoder
21:35:35 <geheimdienst> that's "latest"
21:36:28 <monochrom> yeah "latest" = base-4.3.0.0 = ghc 7 today
21:39:49 <kfr> Go GHC 7!
21:40:27 <Veinor> oh, yeah, I am
21:43:54 <sproingie> is the haskell platform on track for february release?
21:44:03 <ivanm> sproingie: doubt it
21:44:07 <sproingie> bah
21:44:07 <ivanm> especially with c.h.o being down
21:44:12 * hackagebot c10k 0.4.1 - C10k server library using prefork  http://hackage.haskell.org/package/c10k-0.4.1 (KazuYamamoto)
21:44:17 <sproingie> yah the web infrastructure has been a mess
21:44:23 <Axman6> what's that got to do with anything ivanm?
21:44:38 <ivanm> Axman6: well, many of the packages are stored there, aren't they?
21:44:55 <Axman6> no idea
21:47:00 <ivanm> dons sometimes stores stuff in c.h.o/~dons
21:47:01 <monochrom> certainly hinders work if repos are hosted and hosed there
21:47:09 <ivanm> even the trac is down
21:47:17 <ivanm> so I think that's a bigger reason why not
21:47:36 <monochrom> and hinders collaboration even if repos are not hosed there.
21:48:05 <ivanm> does anyone know how to catch the error for text failing due to an encoding error?
21:48:14 <ivanm> I _think_ that's what's causing my glibc errors :s
21:48:38 <Veinor> eh, I need to integrate my program into my snap framework anyway
21:48:41 <Veinor> i'll debug errors then
21:49:01 <monochrom> probably an IOException
21:49:58 <ivanm> hmmm, I thought I was catching IOExceptions already...
21:50:15 <ivanm> yup, I am
21:50:36 <monochrom> darn
21:51:37 <monochrom> I would find out by catching SomeException and then interrogating it
21:52:25 <stepkut> is there a way to get, cabal haddock, to haddock just one specific source file (for debugging purposes)
21:53:25 <Axman6> why not just call haddock?
21:53:32 <geheimdienst> "touch yourfile.hs" and re-run cabal build? it should only rebuild what's necessary
21:53:43 <geheimdienst> (rebuild as in re-create haddock)
21:53:47 <stepkut> geheimdienst: cabal haddock re-haddocks everything
21:54:10 <stepkut> Axman6: directly, instead of via cabal haddock ?
21:54:27 <ivanm> not that I know of
21:54:34 <ivanm> calling haddock is a bit of a black art... :s
21:54:42 <ivanm> I leave it to Cabal to do it
21:54:47 <Axman6> haddock --html foo.hs? :\
21:54:50 <stepkut> ivanm: me too
21:55:03 <stepkut> Axman6: that leaves poop all over my working directories I think
21:55:50 * stepkut likes the haddock coverage report stuff in the new haddock
21:56:16 <ivanm> anyone knows where the "hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)" error comes from?
21:56:27 <ivanm> that message doesn't seem to appear in hGetContent's source... :s
21:56:37 <Veinor> you can't catch it?
21:57:25 <kfr> Interesting, I discovered a curious error message in GHC on a missing ->: setBuffer :: Monad m => DB.ByteString ClientEnvironmentT m () -- `DBC.ByteString' is applied to too many type arguments, in the type signature for `setBuffer'
21:57:38 <kfr> With: import qualified Data.ByteString as DB import qualified Data.ByteString.Char8 as DBC
21:57:38 <ivanm> Veinor: I can't work out what kind of error it _is_ :s
21:57:48 <ivanm> I'm catching IOException already, so it's not that
21:57:49 <kfr> I wonder if that is a bug
21:57:51 <stepkut> ivanm: the "invalid or incomplete multibyte or wide character" part comes from outside of GHC I think.. libc or something ?
21:58:04 <ivanm> kfr: ByteString doesn't take any type arguments...
21:58:09 <ivanm> so it's not a bug...
21:58:21 <kfr> ivanm: Notice how the error message says DBC
21:58:22 <ivanm> stepkut: yeah, glibc is the one that bitches :s
21:58:26 <stepkut> ivanm: errno EILSEQ
21:58:28 <kfr> But there's no DBC anywhere near that function
21:59:08 <kfr> ivanm why would it say DBC when my signature says DB?
21:59:09 <ivanm> kfr: the two bytestring types are the same
21:59:10 <ivanm> so it might be applying the wrong de-sugaring *shrug*
21:59:16 <kfr> Ahh
21:59:22 <kfr> I thought they were unrelated
21:59:29 <geheimdienst> ivanm, could you change the encoding so that the error doesn't occur in the first place ...?
22:00:12 <ivanm> geheimdienst: I'm trying to ignore any non-utf-8 encodings
22:00:20 <ivanm> stepkut: hmmm?
22:00:51 <stepkut> ivanm: errno EILSEQ is the error which results in that message..
22:00:59 <ivanm> ahhhh
22:01:38 <stepkut> ivanm: that is why you can not find the error message in hGetContents. 
22:01:45 <ivanm> *nod*
22:01:47 <stepkut> ivanm: the error string comes from C
22:01:57 <ivanm> so what kind of Exception would it be? :/
22:02:33 <geheimdienst> as a workaround, you could run rawSystem "isutf8 yourfile" and do hGetContents only when it came back clean
22:03:41 <ivanm> geheimdienst: nah, this isn't a one-off thing
22:04:08 <ivanm> Dot code can come use either utf-8 or latin1: I'm trying to explicitly use utf-8
22:04:48 <geheimdienst> no, i meant, have your haskell program fork off isutf8 to check if the input is valid
22:05:02 <ivanm> I don't care about it that much
22:05:06 <ivanm> especially right now ;-)
22:05:17 <geheimdienst> 'kay :)
22:05:19 <ivanm> (I was also trying to work out where the glibc memory corruption errors were coming from)
22:05:30 <ivanm> I _might_ work out some hack to parse in latin1 and then remove that attribute, but that'd be down the track
22:06:23 <Saizan> do you have the code somewhere? you might be fooled by lazyness
22:07:12 <ivanm> Saizan: how so?
22:07:25 <monochrom> hGetContents. may be an async exception.
22:07:59 <Saizan> well, rather than async, you might not be forcing it enough to throw the exception inside the catch
22:08:18 <Saizan> assuming you're using String and/or lazy BS
22:11:51 <ivanm> Saizan: hmmm...
22:11:54 * ivanm checks that out
22:12:52 <ddarius> "Our operation A − B is not on a par with our earlier operations, in the sense that it does not extend unambiguously to infinite multisets, which we do not define here, but which play an important role (so we are told) in many branches of mathematics."
22:13:13 <geheimdienst> ddarius: lol
22:13:29 <ivanm> I'm doing: try (openFile fp ReadMode >>= T.hGetContents)
22:14:06 <Saizan> assuming T.hGetContents uses lazy I/O that's not going to work
22:14:08 <ivanm> wait, lazy text has lazy hGetContents...
22:14:32 <monochrom> Saizan is right. Using hGetChar, it's an IOException
22:14:56 <Saizan> try (openFile fp ReadMode >>= T.hGetContents >>= \s -> T.length s `seq` return s) -- this will work
22:15:29 <Saizan> it will also read the whole file in memory though
22:16:09 <Hugglesworth> what does a "no instance" error mean?
22:16:37 <Hugglesworth> "No instance for (RegexMaker Regex CompOption ExecOption t) arising from a use of `=~' at mssbot.hs:17:15-65" "t =~ "<[^>]*title[^>]*>[^<]*<[^>]*/[^>]title[^>]*>" :: B.ByteString"
22:17:13 <Saizan> it means there's no instance for those particular parameters for the RegexMaker class..
22:17:16 <Hugglesworth> t is a bytestring; I've also tried making t a string and using :: String; but i get the same error
22:17:20 <Hugglesworth> hrm
22:17:26 <ivanm> gah! even after doing so it _still_ borks!
22:17:41 <ivanm> no, wait, soemthing _else_ is causing the glibc ... >_>
22:17:54 <ivanm> but I can't work out what :s
22:17:57 <Saizan> Hugglesworth: i think the problem is that it doesn't know which type to use for the last argument
22:18:13 <ivanm> *** glibc detected *** ./TestParsing: double free or corruption (top): 0x0af28f98 ***
22:18:17 <Saizan> Hugglesworth: you need to fix the 't' type variable that appears in the No instance error
22:18:29 <drbean> The gentle introduction says: matching is permitted using  the constructors of any type, user-defined or not.
22:19:28 <Saizan> ?type (=~)
22:19:29 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
22:19:57 <Saizan> Hugglesworth: do you have OverloadedString enabled?
22:20:09 <Hugglesworth> yeah, the lib I'm using seems to need it
22:20:25 <Saizan> then you need a type annotation to that string literal
22:20:40 <ivanm> Hugglesworth: no library should need it
22:20:46 <ivanm> it just saves you from doing explicit packs, etc.
22:21:03 <Hugglesworth> ah
22:21:21 <Hugglesworth> maybe I'll see if I can get rid of overloaded strings, it seems to be a pain in my ass
22:21:26 <ivanm> however, OverloadedStrings seems to be useful enough to become part of Haskell'
22:21:55 <ivanm> because you can't pattern-match on Text, etc. values without it! \o/
22:22:02 <Hugglesworth> hrm
22:22:13 <yitz> ivanm: some kinds of syntactic sugar have an effect on the whole way you think about a language.
22:22:24 <ivanm> yitz: oh?
22:22:42 <Hugglesworth> "let fullt =  t =~ ("<[^>]*title[^>]*>[^<]*<[^>]*/[^>]title[^>]*>" ::B.ByteString) :: B.ByteString" fixes it
22:22:43 <monochrom> in fact, all kinds of sugar do.
22:22:48 <Hugglesworth> thanks
22:22:51 <yitz> ivanm: famous example is do notation for monads. i think overloaded strings is a smaller example.
22:23:04 <Hugglesworth> I'll have to remember that that's what that means
22:23:24 <ivanm> yitz: how does overloaded strings change how you think?
22:23:27 <yitz> ivanm: it makes Text feel like a canonical way of doing strings in Haskell. Which is good.
22:23:38 <ivanm> ahhhh
22:23:41 <yitz> s/a/the/
22:23:55 <ivanm> well, it doesn't help with something like "if the first char is this"... :s
22:24:00 <ivanm> but patternguards help with that
22:24:29 <yitz> if T.head s == ...
22:24:43 <ivanm> yitz: and if s is empty? :p
22:24:51 <yitz> > undefined
22:24:52 <lambdabot>   *Exception: Prelude.undefined
22:24:55 <dskippy1> Why doesn't this work? I want a 4x4 matrix of 1's.      array ((0,0),(3,3)) (repeat 1)
22:25:05 <ivanm> I needed to do cases like "if the first char is '#' and the second is '0'"
22:25:13 <monochrom> arrayList
22:25:17 <ivanm> @type array
22:25:18 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
22:25:20 <ivanm> @type arrayList
22:25:21 <lambdabot> Not in scope: `arrayList'
22:25:21 <monochrom> err, listArray
22:25:32 <ivanm> @type listArray
22:25:32 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
22:25:36 <monochrom> > (listArray ((0,0),(3,3)) (repeat 1)) ! (2,2)
22:25:38 <lambdabot>   1
22:26:33 <dskippy1> Oops, sorry, guys, I made a short version of my program and dropped the indexes. That's actually not the issue I'm having. One sec.
22:26:46 <yitz> ivanm: maybe no yes . maybeResult . parse "#"
22:26:47 <monochrom> the plot thickens!
22:26:55 <dskippy1> :)
22:27:23 * hackagebot hbeanstalk 0.2 - Client for the beanstalkd workqueue service.  http://hackage.haskell.org/package/hbeanstalk-0.2 (GregHeartsfield)
22:29:19 <ivanm> yitz: http://hpaste.org/43360/text_vs_string
22:29:40 <dskippy1> array ((0,0),(2,2)) $ zip [(x,y)|x<-[0..2],y<-[0..2]] [0..3*3]
22:30:06 <monochrom> > [0..3*3]
22:30:07 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
22:30:45 <dskippy1> monochrom: Yeah that's what I expected.
22:30:52 <ivanm> isn't there some extension to list comprehensions to let you do zips as well?
22:31:09 <monochrom> > (array ((0,0),(2,2)) $ zip [(x,y)|x<-[0..2],y<-[0..2]] [0..3*3]) ! (1,2)
22:31:09 <ivanm> or would that get you a [[(a,a)]] ?
22:31:10 <lambdabot>   5
22:32:17 <yitz> ivanm: ok, not too awful. except for the use of pattern guards, which i consider awful. you can use the maybe monad directly and it will look just as simple.
22:32:58 <ivanm> what's wrong with pattern guards?
22:33:06 <ivanm> (though it'd be nicer if they nested)
22:33:18 <dskippy1> I think I need to just paste bin my program.
22:33:24 <monochrom> heh
22:33:51 <yitz> ivanm: they are an abuse of <- which means bind the monadic thing on the right to the pattern on the left, for every use of <- except pattern guards
22:33:58 <monochrom> wouldn't it be wonderful if your code corrected itself gradually as you asked more questions on irc...
22:34:07 <ivanm> yitz: I had a better example but can't remember where :/
22:34:13 <ivanm> yitz: fair enough
22:34:24 <ddarius> yitz: They can be viewed as bind for a Maybe monad where Nothing = pattern failure.
22:34:27 <yitz> where it means something different, but similar enough to be really ugly
22:34:40 <geheimdienst> monochrom: my head corrects itself gradually as i ask more questions
22:35:12 <yitz> ddarius: exactly. except that <- is being used in the wrong way.
22:35:33 <monochrom> I just watched Tron today. "my head" and "my code" may be not so distinct
22:35:42 <yitz> anyway, my that's my bugaboo about pattern guards
22:36:58 <monochrom> but I didn't know that the leave-solid-tail thing can generalize from land vehicles to airplanes!
22:37:20 <yitz> monochrom: in perl perhaps. in haskell they can be distinguished by their types.
22:38:31 <monochrom> so kevin flynn coded in perl because that's why most programs can't tell programs from users...
22:39:25 <dskippy1> http://hpaste.org/43361/error   Here is my real problem. I get "undefined array element"
22:40:06 <ivanm> OK, this glibc error with text is pissing me off: if I run it on a per-file basis, there's no problem; if I parse all the files (with just _one_ containing the wrong encoding) then the error is caught but glibc still complains about double free corruption :s
22:40:32 <ivanm> dskippy1: why don't you use the hierarchical modules?
22:40:49 <ivanm> and why are some of your test board rows shorter than the others?
22:40:55 <dskippy1> ivanm: What?
22:41:09 <ivanm> "import Char" ==> why not "import Data.Char" ?
22:41:24 <ivanm> the only non-hierarchic non-Prelude module that I know of that isn't duplicated is Numeric
22:41:25 <dskippy1> ivanm Not clue about the benefits.
22:41:44 <ivanm> dskippy1: the benefits are is that non-hierarchical ones are just there for backwards compatabiliity
22:42:07 <dskippy1> ivanm: Some rows are shorter than others because this is a hexagonal grid.
22:42:26 <ivanm> then I don't think an array will work...
22:42:38 <ivanm> maybe use a Map instead then?
22:42:52 <monochrom> dskippy1: I wonder why array ((0,0),(mx,my)) not array ((0,0),(mx-1,my-1))
22:44:02 <ivanm> monochrom: there won't be problems from having non-contiguous indices?
22:44:12 <dskippy1> Oh I think this will work if I just don't reference the bad elements.
22:44:21 <ivanm> dskippy1: what actually causes the error?
22:44:22 <dskippy1> I'm trying to show it so it blows up.
22:44:39 <monochrom> non-contiguous indices never posed a problem
22:44:51 <monochrom> bad elements were never referenced
22:47:18 <monochrom> if you do zero-based indices, you have to be aware that array (0, 2) [ (i, 'c') | i<-[0 .. 2-1] ] is one element short of what you think.
22:47:41 <kfr> How do I rewrite do { connection <- gets clientConnection; return $ connectionSocket connection } without do?
22:47:53 <ivanm> @pl mapM f =<< getArgs
22:47:54 <lambdabot> mapM f =<< getArgs
22:48:02 <monochrom> the effect is more amplified if you have more dimensions.
22:49:06 <dskippy1> That was it. If I just don't reference the bad indexes, I'm fine.
22:49:17 <yitz> kfr: fmap connectionSockt $ gets clientConnection
22:49:34 <yitz> s/ckt/cket/
22:49:43 <kfr> yitz wouldn't it be wiser to use <$> there?
22:49:58 <yitz> kfr: it's a matter of style, whatever you prefer
22:50:15 <yitz> kfr: yeah it works out good there
22:50:22 <kfr> Thanks
22:50:36 <kfr> I kept on trying to do it using >>= but I failed
22:50:59 <ddarius> @undo  do { connection <- gets clientConnection; return $ connectionSocket connection }
22:50:59 <lambdabot> gets clientConnection >>= \ connection -> return $ connectionSocket connection
22:51:01 <yitz> kfr: gets clientConnection >>= return . connectionSocket
22:51:18 <kfr> Ahh .
22:51:31 <yitz> kfr:  but whenever you see return on the right of >>= it means you meant fmap (or <$>)
22:51:44 <kfr> Right
22:52:23 <kfr> I used $ instead of composition, fail
22:52:57 <yitz> @. undo pl do { connection <- gets clientConnection; return $ connectionSocket connection }
22:52:58 <lambdabot>  Parse error at "mn" (column 14)
22:53:25 <yitz> @. pl undo do { connection <- gets clientConnection; return $ connectionSocket connection }
22:53:26 <lambdabot> connectionSocket `fmap` gets clientConnection
22:53:50 <kfr> Nice :p
22:54:08 <ivanm> OK, I just tried to make a minimal example of my glibc problem with Text... and there was no problem :s
22:54:09 <yitz> lambdabot++
22:54:27 <ddarius> @karma lambdabot
22:54:27 <lambdabot> lambdabot has a karma of 2
22:54:40 <yitz> @botsnack
22:54:41 <lambdabot> :)
22:55:48 <kfr> @. pl undo do { connection <- gets clientConnection; put $ ClientEnvironmentData connection newBuffer}
22:55:49 <lambdabot> put . flip ClientEnvironmentData newBuffer =<< gets clientConnection
22:56:03 <kfr> Hmm shorter but I'm not sure I like flips :(
22:56:34 <ddarius> :t puts
22:56:35 <lambdabot> Not in scope: `puts'
22:56:46 <ddarius> :t modify
22:56:47 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
22:56:59 <ivanm> oh, great, the memory corruption is occuring at random spots now :s
22:57:13 <ddarius> ivanm: That's how memory corruption normally works.
22:57:26 <monochrom> yuck
22:57:34 <kfr> ivanm in a GHC binary?
22:57:40 <ddarius> Wait until your physical memory starts going bad.
22:57:43 <ddarius> or your CPU.
22:57:55 <ivanm> kfr: yup; I think it's related to text reading a file in an invalid encoding
22:57:59 <monochrom> and your neurons
22:58:05 <yitz> ddarius: not always. if it's a flaw in the silicon it usually occurs at the same spot
22:58:18 <ivanm> ddarius: it used to always occur in the same spot in this computation
22:58:51 <ddarius> ivanm: Programs are deterministic (well, less so in this age of multicore.)
22:59:30 <ivanm> yet you said that memory corruption occuring at random was normal...
22:59:35 <monochrom> when you don't debug, they occur at the same address. when you debug, they move to new places, since your debugging changes code and environment
22:59:36 <ddarius> Indeed.
22:59:38 <yitz> monochrom: you were really affected by that weren't you
23:00:13 <monochrom> affected by what?
23:00:19 <yitz> monochrom: tron
23:00:38 <yitz> monochrom: when you debug, they move to new places, by murphy's law
23:01:23 <monochrom> well I don't believe in orbital monsters and murphy's law
23:02:29 <dafis> Does anybody here know -fno-strictness well? My stack overflow goes away if I compile Main with -fno-strictness. Unfortunately the resulting binary is not very fast. Any ideas to solve the problem?
23:02:43 <yitz> monochrom: someone once did a controlled study that proved the validity of murphy's law, but then his hard drive crashed.
23:02:51 <monochrom> haha
23:05:12 <kfr> ddarius: modify $ \state -> ClientEnvironmentData (clientConnection state) newBuffer -- any better?
23:06:33 <yitz> kfr: i don't mind using flip here, it's still clear. it's only when you combine multiple flips that things start getting murky.
23:07:19 <yitz> @pl \f g x y z w -> g x y z (f w)
23:07:20 <lambdabot> flip (flip . ((flip . ((flip . ((.) .)) .)) .))
23:09:38 <kfr> @. pl undo do { let environment = ClientEnvironmentData client DBC.empty; void $ runStateT state environment }
23:09:39 <lambdabot> Parse error at "}" (column 99)
23:09:45 <kfr> What did I break? Hm
23:09:47 <ion> lambdabot finally flipped.
23:09:58 <djahandarie> kfr, add the ending ;
23:10:19 <djahandarie> do { a; b; c; }
23:10:25 <yitz> kfr: not sure that pl and undo understand let
23:10:40 <kfr> djahandarie: That is not needed afaik :o
23:10:43 <kfr> It doesn't help either
23:10:48 <kfr> yitz oh, too bad
23:10:53 <djahandarie> kfr, it isn't but lambdabot can be picky sometimes
23:11:12 <yitz> @undo do { let environment = ClientEnvironmentData client DBC.empty; void $ runStateT state environment }
23:11:13 <lambdabot>  Parse error at "}" (column 99)
23:11:55 <lyndon_> Hey people. What is the cabal package that supplied a command-line quickcheck program?
23:11:57 <kfr> I am stupid though, I erroneously thought I had a bind in there
23:12:01 <kfr> Whreas there isn't one
23:12:11 <Saizan> dafis: can you paste the code?
23:12:25 <djahandarie> Yep, you could just remove the do entirely (after substituting the let)
23:12:49 <kfr> Originally the block was larger, forgot to remove it, haha
23:12:55 <dafis> Saizan:  it's a bit longish, I've reduced it to two bearable modules though, want to look?
23:13:57 <Saizan> dafis: let's try, on a pastebin or repo of course, usually it's a matter of finding a tail recursion with a lazy accumulator
23:15:25 <pastorn> lol i roxx
23:15:37 <pastorn> now i have text input fields in vty
23:15:46 <pastorn> only took 2~3 days to get that right...
23:18:06 <dafis> Saizan:  http://hpaste.org/43364/stack_overflow
23:18:58 <dafis> I'd be surprised if it was a lazy accumulator, though because there's no stack overflow with 6.12, only with 7, optimisations and no profiling
23:19:24 <dafis> s/though/though,/
23:19:32 <dankna> gr!
23:19:43 <dankna> profiling has a bad interaction with running as a daemon
23:19:54 <dankna> namely, it stops doing it when the original process exits
23:21:14 <Saizan> dafis: couldn't find one in fact
23:21:36 <kfr> Hmm is there a short way to take a T x y and return a T x $ f y?
23:24:15 <dafis> kfr:  make T an instance of Functor?
23:24:21 <kfr> I can make it one
23:24:37 <dafis> then fmap f
23:25:16 <kfr> What about T (f x) y?
23:26:30 <kfr> I believe to recall that you cannot modify the Left part of an Either due to that limitation?
23:28:43 <dafis> Saizan:  Weirder and weirder. I compiled again without -fno-strictness to look at the Core, and now that one doesn't stack overflow???
23:29:39 <dafis> kfr:  you can only fmap in T's last type argument (which would probably be y's type)
23:29:47 <kfr> Yeah
23:29:57 <kfr> So what about T (f x) y then?
23:30:01 <pastorn> @type either
23:30:02 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:30:17 <kfr> Since a Functor requires a * -> *?
23:30:17 <pastorn> kfr: that's how you escape Either ^^^
23:30:21 <dafis> kfr:  There's a class BiFunctor in some package
23:30:27 <kfr> And Either is * -> * -> *?
23:30:44 <kfr> dafis no big deal, I was just wondering
23:30:54 <dafis> kfr:  right, the kinds
23:31:24 <kfr> So you should choose the order of values in a type carefully to enable convenient fmap'ing, for example?
23:31:31 <dafis> right
23:32:10 <dafis> kfr:  and for deriving instances if you define a newtype
23:35:03 <kfr> > (+1) <$> Right 0
23:35:04 <lambdabot>   Right 1
23:35:09 <kfr> > (+1) <$> Left 0
23:35:10 <lambdabot>   Left 0
23:35:21 <kfr> No instance for (Functor (Either a))
23:35:54 <dafis> > fmap not (Right True)
23:35:55 <lambdabot>   Right False
23:36:02 <dafis> there is
23:36:31 <ion> kfr: Perhaps one of the lens packages is useful for what you want: https://gist.github.com/798215
23:36:46 <kfr>  (+1) <$> Left 0 doesn't work in ghci hmm
23:36:51 <kfr> With :m +Data.Functor
23:36:58 <kfr> I wonder what I am doing wrong
23:37:24 <kfr> ion: Why the underscores?
23:37:29 <kfr> _foo
23:37:41 <ion> kfr: fclabels defines ‘foo’ based on that.
23:38:09 <kfr> http://hackage.haskell.org/package/fclabels hmm never heard of it before
23:38:32 <sipa> @pl x >>= \y -> return (2*y)
23:38:32 <lambdabot> (2 *) `fmap` x
23:39:08 <dafis> shouldn't that be liftM
23:39:26 <dafis> Functor is no superclass of Monad yet
23:40:24 <sipa> :f fmap
23:40:34 <sipa> :t fmap
23:40:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:41:01 <sipa> :f liftM
23:41:12 <sipa> :t liftM
23:41:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:41:25 <ClaudiusMaximus> :t genericIndex
23:41:27 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
23:41:47 <ClaudiusMaximus> @hoogle (Integral a) => [b] -> a -> Maybe b
23:41:48 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
23:41:48 <lambdabot> Prelude (!!) :: [a] -> Int -> a
23:41:48 <lambdabot> Data.List (!!) :: [a] -> Int -> a
23:41:50 <kfr> ion ah I get it now, great stuff
23:42:01 <sipa> :t (<*>)
23:42:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:42:12 <kfr> Foo {_foo = 1, _bar = 44, _baz = 3}
23:42:29 <sipa> :t (<$>)
23:42:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:42:31 <ClaudiusMaximus> > genericIndex (99 :: Integer) "too big explodes :("
23:42:33 <lambdabot>   Couldn't match expected type `[b]'
23:42:33 <lambdabot>         against inferred type `GHC.Integ...
23:42:37 <ClaudiusMaximus> oops
23:42:39 <ion> kfr: It makes accessors first-class objects – the way they should have been in the first place. :-P
23:42:44 <ClaudiusMaximus> well, it does...
23:44:25 <adnap> why doesn't hpaste offer hints before you post?
23:44:56 <ion> Because you didn’t submit a patch that implements it yet. ;-)
23:45:03 <adnap> lol
23:45:13 <adnap> is it still lively in here?
23:45:15 <ClaudiusMaximus> it likes to shame you for writing "main = do forM_ [...] $ \i -> really long expression"
23:45:33 <adnap> i have a challege for #haskell
23:45:40 <dafis> ClaudiusMaximus:  and what does it suggest?
23:45:44 <adnap> but i want to know if there are enough people up for it
23:46:07 <ClaudiusMaximus> dafis: to remove the superfluous 'do', while quoting the really long expresssion twice
23:46:39 <dafis> ah, I thought there might come more after that line
23:46:45 <adnap> does anyone feel like a small programming challege in here?
23:46:49 <ion> Btw, is there a reason for the \x → … construct not having such a high precedence that one could just do foo x y \w → 42?
23:47:26 <dblhelix> ion: yes
23:47:32 <dblhelix> ios: :)
23:47:40 <ion> Also: foo x y do bar >>= baz
23:47:46 <dblhelix> ion: otherwise, you would have to write \x -> (f x)
23:47:59 <dark> adnap, seems like a brilliant way to gather people for doing your homework
23:47:59 <dolio> It's not a precedence issue. It's just not allowed.
23:48:09 <adnap> dark: i promise its not that
23:48:13 <ion> whoops
23:48:13 <adnap> i'll just come out with it
23:48:21 <ion> I mean foo x y do bar; baz of course.
23:48:37 <dark> jk ^^
23:48:38 <adnap> my friend told me to do this about an hour ago
23:48:40 <dblhelix> ion: and function application under a lambda is not that unusual ;-)
23:48:46 <adnap> but i did it in c++
23:49:02 * dafis shudders
23:49:04 <adnap> write a more elegant program that does what this c++ program does: http://hpaste.org/43365/rings
23:49:13 <ClaudiusMaximus> hm, seems there isn't a safeGenericIndex anywhere..
23:49:38 <dafis> ClaudiusMaximus:  have you looked at the safe package?
23:49:57 <adnap> just ammend them to the paste!
23:50:06 <adnap> oh wait
23:50:08 <dolio> Agda, for instance, will parse f x \y -> ....
23:50:27 <ClaudiusMaximus> dafis: yes i have
23:50:34 <ClaudiusMaximus> and safe-failure too
23:50:41 <ion> dolio: nice
23:50:50 <adnap> just private message me links or something.  i think that's going to expire in an hour or something.
23:51:17 <dafis> ClaudiusMaximus:  then you have to write it yourself :(
23:51:20 <adnap> PROGRAMMING CHALLENGE
23:51:24 <adnap> :)
23:51:35 <ddarius> adnap: It only expires in an hour if you asked it to.
23:51:43 <dark> adnap, is this supposed go be challenging? @.@
23:51:50 <adnap> not that challenging
23:52:10 <adnap> it draws concentric rings of x's and o's
23:52:14 <ion> adnap: Also, please provide me a pretty Haskell implementation of this C code. http://www.de.ioccc.org/2004/anonymous.c
23:52:29 <adnap> lol
23:53:38 <adnap> this one wont expire in an hour: http://hpaste.org/43366/rings
23:53:47 <adnap> i told the other one to, but i don't know what i was thinking
23:54:06 <adnap> so just ammend it to that one if you care to try
23:54:12 <adnap> it shouldn't take that long to do it
23:54:45 <adnap> i'm kind of wondering what other ways there are to think about this problem
23:55:24 <ddarius> Why don't you think about it directly?
23:56:02 <adnap> what do you mean by that?
23:56:03 <ion> You might as well provide its output for those among us who can’t be bothered to either compile and run the code or parse it in their heads. :-P
23:56:10 <adnap> okay
23:57:34 <kfr> adnap: I can't do it, the program is malformed
23:57:44 <kfr> stdlib.h is not a C++ header :'(
23:57:45 <ddarius> [if even (round (sqrt (x^2 + y^2))) then 'o' else 'x' | x <- [1..n], y <- [1..n]] -- plus some fromIntegral  
23:58:04 <adnap> http://hpaste.org/paste/43366/rings_annotation#p43367
23:58:13 <adnap> i just posted the output
23:58:17 <adnap> now you can see what it does
23:58:39 <ddarius> Those look more like squares to me.
23:58:43 <adnap> yeah
23:58:50 <ddarius> So replace the Euclidean distance with the Manhattan distance.
23:58:54 <adnap> right
23:59:00 <adnap> it's gotta output on the console
23:59:05 <adnap> i guess you could do some fancy stuff
23:59:08 <adnap> with more characters
23:59:21 <adnap> but this is just what my friend described to me as the problem
23:59:27 <ddarius> adnap: That list comprehension should have been a nested one, rather than a cartesian product.
