00:03:55 <john_r_watson> is there a definition for the following somewhere?  Or a
00:03:55 <john_r_watson>                 better way to do the following?  I'm reading the Monadic
00:03:55 <john_r_watson>                 Parsing Combinator paper by Hutton & Meijer who make heavy use
00:03:55 <john_r_watson>                 of this throughout their State Monad implementations:  [00:06]
00:03:58 <john_r_watson>  update :: (s -> s) -> State s s
00:04:02 <john_r_watson>  update f = do get >>= (put . f); get
00:04:06 <john_r_watson>  
00:04:11 <john_r_watson> sorry about that formatting...
00:04:14 <mm_freak_> john_r_watson: usually called 'modify'
00:04:19 <john_r_watson> mm_freak_: many thanks
00:06:24 <c_wraith> well.  Modify returns State s ()
00:06:47 <mm_freak_> oh, true
00:06:53 <john_r_watson> yeah... just saw that
00:07:42 <mm_freak_> (>> get) . modify
00:08:16 <john_r_watson> paper is here btw: http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing 
00:08:27 <mm_freak_> or write it yourself:  modifyGet f = State $ \s' -> let s = f s in (s, s)
00:08:44 <mm_freak_> or write it yourself:  modifyGet f = State $ \s' -> let s = f s' in (s, s)
00:09:02 <john_r_watson> :) right.  That prior definition was that... just in do syntax
00:10:16 <john_r_watson> (pos,x:_) <- update newstate
00:10:16 <john_r_watson> vs.
00:10:17 <john_r_watson> (pos,x:_) <- (>> get) . modify
00:10:37 <john_r_watson> it seems like this was in MonadState at some point... just odd that it's gone
00:11:00 <john_r_watson> thanks for the suggestions
00:30:19 <niket> use /nick niket
00:40:59 <mm_freak_> @undef
00:41:18 <mm_freak_> @let primesSOE = filter (/= 0) $ fix (\r (x:xs) -> x : r (if x /= 0 then uncurry (++) . second (concatMap (\(_:ys) -> 0:ys) . map (take x) . iterate (drop x)) $ splitAt (x-1) xs else xs)) [2..]
00:41:20 <lambdabot>  Defined.
00:41:30 <mm_freak_> > drop 500 primesSOE
00:41:33 <lambdabot>   [3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691...
00:41:57 <mm_freak_> that's about the fastest infinite prime sieve i could come up with using only lists
00:42:08 <mm_freak_> i think, if you want real performance, you need vectors or arrays
00:43:01 <Maxdamantus> > primesSOE !! 10000
00:43:05 <lambdabot>   mueval-core: Time limit exceeded
00:43:27 <mm_freak_> lambdabot times out already after about 1000 primes
00:43:32 <mm_freak_> > drop 1000 primesSOE
00:43:36 <lambdabot>   mueval-core: Time limit exceeded
00:45:06 <Maxdamantus> > threadDelay 1000 >> return 42
00:45:07 <lambdabot>   Not in scope: `threadDelay'
00:45:10 <joe6> dreixel: *Main> constrFields  . toConstr $ (v) = ["ta","tb","tc","td","te","tf"];  *Main> constrIndex  . toConstr $ tb v = *** Exception: constrIndex
00:45:14 <joe6> is this expected?
00:45:49 <joe6> i am under the impression that the constrIndex of the fields will be, in this instance, 2
00:47:34 <joe6> dreixel: it is conIndex not constrIndex
00:47:44 <joe6> dreixel: got it.. sorry for the bother
00:48:07 <dreixel> joe6: what is conIndex?
00:48:38 <mm_freak_> i wonder why Bool has no Num instance
00:48:56 <mm_freak_> that would be handy sometimes
00:49:31 * hackagebot json2 0.2.2 - This library provides support for JSON.  http://hackage.haskell.org/package/json2-0.2.2 (YuriyIskra)
00:51:26 <shachaf> mm_freak_: There's always fromEnum.
00:51:40 <shachaf> mm_freak_: I don't think it behaves enough like a number for the Num typeclass.
00:51:44 <dibblego> conal has a Bool type-class on hackage
00:52:52 <joe6> dreixel: something that I saw in that module.
00:53:09 <joe6> dreixel: which proved to be useless. I guess it should have been constrIndex
00:53:32 <Maxdamantus> > iterate (toEnum . (+1) . fromEnum) False :: [Bool]
00:53:34 <lambdabot>   [False,True,*Exception: Prelude.Enum.Bool.toEnum: bad argument
00:54:12 <Maxdamantus> > iterate (toEnum . (`mod` 2) . (+1) . fromEnum) False :: [Bool]
00:54:14 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
00:54:29 <mm_freak_> shachaf: Bool forms at least one finite field
00:54:50 <mm_freak_> where (+) means XOR and (*) means AND
00:55:56 <dreixel> joe6: so does it work or not?
00:56:26 <dolio> What does (/) mean?
00:56:34 <shachaf> mm_freak_: XOR has an identity?
00:57:06 <mm_freak_> shachaf: False
00:57:27 <joe6> dreixel: no, it does not work.
00:57:31 <shachaf> Er... Yes.
00:57:45 <mm_freak_> dolio: True / True = True and x / False = undefined
00:57:53 <joe6> dreixel: it gives an exception.
00:58:04 <dreixel> joe6: oh, sorry, constrIndex is not what you want.
00:58:09 <Maxdamantus> and False / True = False
00:58:18 <Maxdamantus> > 0/0
00:58:19 <lambdabot>   NaN
00:58:24 <dreixel> joe6: you'd want something like selIndex, which doesn't exist
00:58:55 <joe6> dreixel: oh, no..
00:59:16 <joe6> dreixel: is it hard to get the field name? is there any other generics library that has that?
00:59:31 <dolio> Yeah, I guess the way division works guarantees that it's not interesting.
00:59:48 <joe6> dreixel: it is impossible without the index. correct?
00:59:55 <dreixel> joe6: well, you have the field names, just at the wrong spot. So when you are at a constructor you need to "remember" the labels, and pass them down when you traverse
01:00:04 <mm_freak_> dolio: the first equation should be:  x / True = x
01:00:12 <mm_freak_> since True is its own inverse
01:00:43 <dreixel> joe6: other generic libraries treat labels different, giving you the label exactly at the spot of the argument to the constructor (like instant-generics)
01:02:23 <joe6> dreixel: instant-generics does that?
01:02:33 <dreixel> yeah.
01:03:03 <joe6> dreixel: i am using gzipWithQ to traverse the list of fields. I guess it will always start from the first list. and I can take stuff from the list?
01:03:10 <dreixel> joe6: but it's not so well integrated with other Haskell libraries. For instance, it doesn't work with ByteStrings (out of the box, you could prob make it work)
01:03:46 <dreixel> joe6: what exactly do you want to do?
01:03:51 <joe6> dreixel: even syb did not work with bytestrings.
01:04:49 <joe6> dreixel: I have a nested record structure and want to compare 2 records of that structure and show the fields which have different values.
01:05:00 <joe6> almost like a diff but on the record structure.
01:05:34 * hackagebot json2 0.2.3 - This library provides support for JSON.  http://hackage.haskell.org/package/json2-0.2.3 (YuriyIskra)
01:05:52 <dreixel> joe6: and you need generics because the structures keep changing?
01:06:26 <joe6> no, because I want to do the right thing and not put in all the boilerplate code to compare each field of the record.
01:06:58 <joe6> i had a first version where I hard-coded all the fields and the field differences using prettyprint.
01:07:18 <joe6> after the program was done, I realised that the display code was almost as much as the rest of the code.
01:07:50 <joe6> and pastorn recommended generics, and it seems to be a natural fit and haskell'ish to be using generics to avoid the boilerplate code.
01:08:11 <joe6> dreixel: does my explanation makes sense.
01:09:17 <dreixel> joe6: yes
01:10:32 <joe6> in half the amount of time i have spend mucking around with generics, I could have finished the prettyprint hardcoded code.
01:10:51 <joe6> but, it does not seem to be the correct thing to do.. programmer guilt..
01:10:54 <dreixel> joe6: but I see that syb might not be ideal for dual traversals when you want record field access
01:11:09 <dreixel> joe6: well, you're learning, and you're hoping to produce code that is more reusable and maintainable
01:12:17 <dreixel> oh, and btw, instant-generics actually doesn't do records at all
01:12:19 <dreixel> regular does, though
01:12:29 <dreixel> and I know people using it, so it works :P
01:12:35 <joe6> what do you mean by "regular"
01:13:21 <dreixel> the library
01:13:29 <dreixel> joe6: http://hackage.haskell.org/package/regular
01:13:59 <joe6> dreixel: can you please check listss of http://codepad.org/87HhVigv
01:14:24 <joe6> i have gotten it to the point where it can compare dual records and I am also using extQ and all that.
01:14:40 <joe6> dreixel: it is just the fieldnames that I cannot do with SYB.
01:15:31 <dreixel> joe6: sure, comparing records is fine
01:15:38 <dreixel> the problem is how to get the name of the field
01:16:01 <joe6> dreixel: yes, that is the issue now.
01:16:22 <joe6> dreixel: this is what the docs say (of the regular module): This library cannot be used with mutually recursive datatypes or with nested datatypes. The multirec library [1] can deal with mutually recursive datatypes. 
01:16:24 <dreixel> and actually this elem (dataTypeName . dataTypeOf ...) stuff could be replaced by an extQ, I think
01:16:52 <MasseR> How come even non-tail recursive recursions are damn fast in haskell? How come it's so much faster than the equivalent c/python recursion for example?
01:17:21 <Baughn> MasseR: Because the compiler guys have spent immense amounts of time on optimizing them.
01:17:22 <joe6> dreixel: yes that should be done.
01:17:32 <c_wraith> MasseR: you're probably encountering laziness reducing the amount of wasted work being done
01:18:10 <c_wraith> though the standard python interpreter is stupidly slow.  So beating that is no big deal.
01:18:14 <Baughn> MasseR: Also, keep in mind that recursion in haskell doesn't use a stack. Which is not likely to actually /speed things up/, but..
01:18:17 <MasseR> c_wraith: I tested with simple factorial. Compared with tail-recursive version and not tail-recursive. They were exactly the same speed, and even still it took quite a lot of digits before seeing any peformance penalty
01:18:46 <mux> it's quite possible that the two versions get compiled into the same Core, GHC is smart
01:18:48 <c_wraith> MasseR: you probably weren't *actually* using a proper tail-recursive version.  Care to post your code?
01:18:53 <dreixel> joe6: so what you want is an equality test that, when failing, tells you the name of the record where this happened?
01:19:09 <MasseR> Hold on
01:19:50 <joe6> dreixel: no, the name of the field where it is failing and print the first value and the second value of the correspoding field in the different records.
01:19:59 <dreixel> ok
01:20:11 <dreixel> joe6: I'll do that in regular in a few moments and I'll show it to you.
01:20:33 <joe6> dreixel: the docs say that regular does not work with nested datatypes.
01:20:44 <joe6> dreixel: I think multirec is the solution.
01:20:57 <MasseR> http://hpaste.org/43187/tco there
01:21:06 <dreixel> joe6: Test and Test1 are not nested
01:22:00 <joe6> Test is part of Test1?
01:22:03 <c_wraith> MasseR: that's tail-recursive, but it doesn't help because it's not strict in the accumulator.  So it still builds a stack.
01:22:15 <joe6> do you mean Test1 having Test1 within itself?
01:22:30 <joe6> no, that will not happen. But, Test1 has Test datatype.
01:22:50 <c_wraith> MasseR: well, actually, that case is probably simple enough that the strictness analyzer will catch it.
01:23:12 <MasseR> It does use 8MB of memory so something is happening
01:23:16 <c_wraith> ...  actually, neither of those is tail-recursive
01:23:20 <dreixel> joe6: that is not nested. and regular will work ok with that, as long as you don't want a fold, which so far you don't (syb can't do that)
01:23:22 <MasseR> Err, when x = 100000
01:23:27 <c_wraith> Check your definition of tail recursion. :)
01:23:41 <dreixel> joe6: nested datatypes are something else: http://www.springerlink.com/content/4nmhxj5mwdnu3btk/
01:23:47 <c_wraith> In both of those implementations, (*) is the last function called.
01:23:48 <MasseR> c_wraith: :P. Yes it's still kinda hazy concept
01:24:13 <joe6> dreixel: don't bother. I will try regular and ping you if I have any questions.
01:24:29 <joe6> dreixel: I hate it for you to spending time on something I should do.
01:24:41 <joe6> dreixel: hold on, please. let me take a crack at it.
01:27:11 <c_wraith> MasseR: http://hpaste.org/43188/x
01:27:25 <c_wraith> both of those definitions are tail-recursive
01:27:33 <c_wraith> the second one is explicitly strict in its accumulator
01:28:17 <c_wraith> heh.  actually, the strict one is not technically tail-recursive.  that it practically is tail-recursive is an artifact of how laziness works, and how seq works.
01:28:26 <dreixel> joe6: ok. do a cabal update because I just uploaded a new version to hackage (the equality function was actually missing the case for records!)
01:28:39 * hackagebot regular 0.3.2 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.3.2 (JosePedroMagalhaes)
01:29:36 <c_wraith> MasseR: So let's start with tail recursion.  Given that fac3 is the only one with a proper tail-recursive implementation, can you see why?
01:29:43 <joe6> dreixel: so, you are the maintainer of regular?
01:30:10 <joe6> or the author?
01:30:20 <MasseR> c_wraith: I can see how that version is optimized over mine, but no, can't see how it's more/less tailcall than mine
01:30:37 <MasseR> Well sort of can, but hazy
01:30:59 <c_wraith> MasseR: The definition of tail-recursive is that the the function calls itself as the last thing it does.
01:31:33 <c_wraith> MasseR: in fac1 and fac2, the outermost function applied is (*)
01:31:34 <MasseR> So it first evaluates the arguments and then calls itsel
01:31:39 <cubi> what is the best (?) method to color ghci?
01:32:14 <c_wraith> in fac4, the outermost function is seq...  But seq is a special case, and probably shouldn't be considered.
01:32:42 <c_wraith> in fac3, the outermost function is fac3' (called by fac3')
01:32:50 <dreixel> joe6: I'm the maintainer of regular, instant-generics, syb, generic-deriving, and maybe a few others
01:33:06 <c_wraith> dreixel: sounds like a topic you know something about :)
01:33:15 <dreixel> joe6: I'm doing a PhD on it :P
01:33:33 <MasseR> Hmm.. I think I can see it now
01:34:09 <c_wraith> So, anyway...  Try your test with fac3 there.
01:35:06 <MasseR> Quite a lot faster. 20s vs 6s
01:35:27 <c_wraith> Also, are you compiling with optimizations?
01:35:34 <MasseR> O2
01:36:39 <c_wraith> ok.  given -O2, fac3 and fac4 are probably identical
01:37:12 <MasseR> Speedwise at least
01:37:21 <c_wraith> in generated code, too, probably
01:37:31 <FauxFaux> Haha, I read "fac" as "flip a coin", as in, pick a random optimisation level.
01:37:58 <c_wraith> -O2 includes a strictness analizer that probably notes that with the Integer type, fac3 needs to be strict to function properly
01:38:03 <c_wraith> err, analyzer
01:38:27 <MasseR> Thanks for all, I learnt something new again :)
01:38:33 <c_wraith> with -O0, fac3 and fac4 would function very differently :)
01:40:24 <MasseR> Indeed. 6s vs 40s
01:41:24 <c_wraith> There are a lot of subtle details in haskell's evaluation model.  I'd suggest not trying to learn them all at once :)
01:41:57 <MasseR> I've just now started to look into optimization, so yes, I agree :P
01:42:41 <c_wraith> I would suggest looking at your c code again, and determining if it's actually tail-recursive
01:48:26 <joe6> dreixel:glad I ran into you. Thank you for helping me out. Ph.D? wow.. good luck. 
01:50:28 <joe6> dreixel: i doubt I can get much out of my head this night. It is pretty late here. I will start working on it in another 6-8 hours. will keep you posted on how it goes.
01:51:02 <merijn> @hoogle [a -> b] -> a -> [b]
01:51:02 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
01:51:03 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
01:53:25 <dreixel> joe6: http://codepad.org/kEQRkFQ7
01:59:35 <merijn> @pl \l1 l2 -> (map (\x y -> x `mod` y == 0) l1 <*> l2)
01:59:35 <lambdabot> (<*>) . map (flip flip 0 . ((==) .) . mod)
01:59:50 <merijn> Somehow that doesn't seem significantly more readable >.>
02:07:22 <Maxdamantus> > iterate ((*2) .) id <*> 5
02:07:23 <lambdabot>   No instance for (GHC.Num.Num [a])
02:07:23 <lambdabot>    arising from a use of `e_125' at <inte...
02:09:08 <Maxdamantus> :t (iterate ((*2) .) id, 5)
02:09:08 <lambdabot> forall a t. (Num a, Num t) => ([a -> a], t)
02:11:38 <lpsmith> dolio, do you know SML?
02:42:55 * hackagebot web-mongrel2 0.0.2.2 - Bindings for the Mongrel2 web server.  http://hackage.haskell.org/package/web-mongrel2-0.0.2.2 (ClintMoore)
03:37:27 * hackagebot haskore 0.2 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.2 (HenningThielemann)
03:47:17 <redd_> @pl \u v -> s (k `fmap` ((g u) `r` (h u)))
03:47:18 <lambdabot> const . s . (k `fmap`) . liftM2 r g h
04:06:50 <merijn> @hoogle Char -> Int
04:06:50 <lambdabot> Data.Char digitToInt :: Char -> Int
04:06:50 <lambdabot> Data.Char ord :: Char -> Int
04:19:29 <maurer_> Has anyone gotten ffipkg to work?
04:20:10 <maurer_> When I try it on simple libraries, it seems to get partway through and hang, and when I try it on unistd.h (as suggested in their wiki page) it errors out due to not acquiring some #defines
04:20:56 <marciorja> hi
04:31:54 <marciorja> hello
04:42:35 <Bynbo7> hi marciorja 
04:59:03 <maurer_> Does anyone know of a function similar to ByteString -> IO CString?
04:59:06 <maurer_> Hoogle is failing me.
05:02:45 <zygoloid> @hoogle ByteString -> (CString -> IO b) -> IO b
05:02:51 <lambdabot> Data.ByteString useAsCString :: ByteString -> (CString -> IO a) -> IO a
05:02:53 <lambdabot> Data.ByteString.Unsafe unsafeUseAsCString :: ByteString -> (CString -> IO a) -> IO a
05:02:55 <lambdabot> Data.ByteString.Char8 useAsCString :: ByteString -> (CString -> IO a) -> IO a
05:02:57 <merijn> Are there any people working on like Haskell for CUDA style things?
05:03:17 <zygoloid> maurer_: ^^
05:05:11 <caminoix> hello
05:05:42 <caminoix> I'd like to ask you to point me to some place where I can find information on how to write a pluggable app in Haskell
05:06:00 <caminoix> I tried to find something myself but with no success
05:06:13 <merijn> What do you mean by pluggable?
05:06:34 <caminoix> erm, sorry, I'm an amateur;
05:06:45 <caminoix> I meant one that has optionally loaded modules
05:06:50 <maurer_> zygoloid: thanks
05:06:54 <caminoix> conditionally, perhaps
05:06:56 <merijn> Ah, like plugins?
05:07:05 <caminoix> yes, that's what I meant
05:08:15 <merijn> caminoix: This paper might be what you're looking for? http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
05:08:51 <maurer_> zygoloid: Oh. That comes with the usual alloca caveat :(
05:09:08 <caminoix> ah, possibly – thank you!
05:10:08 <caminoix> I don't know how I come I didn't find it, I really did google for it
05:10:15 <caminoix> *how come
05:10:30 <caminoix> thanks again and laters! :)
05:13:20 <maurer_> http://hpaste.org/43190/lazy_c_binding
05:13:29 <maurer_> I'm trying to use it in a scenario which looks like that
05:13:54 <maurer_> I have a C library that can generate the next token on demand, and I'm trying to make the binding into haskell trigger token generation when that point in the list is accessed
05:14:36 <maurer_> I am looking for a way to translate the ByteString (probably requiring a copy :/) so that this can go.
05:14:59 <maurer_> (Yes, I understand there is a potential memory leak here, but the laziness is more useful than the memory issue)
05:15:18 <quicksilver> this is not laziness.
05:15:21 <quicksilver> This is interleaved IO.
05:15:41 <quicksilver> I think you'll get a clearer semantics using unsafeInterleaveIO than nested unsafePerformIOs
05:15:52 * maurer_ looks up unsafeInterleaveIO
05:15:56 <quicksilver> (you can unsafe the top level if you want although I probably wouldn't)
05:16:42 <maurer_> quicksilver: unsafeInterleaveIO looks like exactly what I want :)
05:16:49 <maurer_> It also means I can use alloca instead of malloc :)
05:18:46 <mm_freak_> maurer_: in haskell the iteratee/enumerator pattern is very idiomatic for generating/reading/receiving/whatever on demand
05:20:23 <lpsmith> I'm not sure "very idiomatic" is quite the right word.  It's a relatively new idiom,  that hasn't fully percolated through the community
05:20:50 <lpsmith> It's more a hot topic than a common idiom these days :)
05:21:22 <quicksilver> lpsmith: 7 years old.
05:21:30 <quicksilver> I suppose that's newer than lambdas, yes.
05:21:44 <quicksilver> but it's older than quite a few people I know :)
05:22:04 <lpsmith> quicksilver,  Haskell was just barely older than that when I first picked it up,  and Haskell was definitely very new at the time
05:22:15 <maurer_> mm_freak_: Why not just use a lazy list? It seems easier.
05:22:26 <lpsmith> Good ideas usually take time to pick up steam :)
05:22:44 <mm_freak_> maurer_: lazy lists are not very predictable
05:22:50 <lpsmith> maurer_, more predictable resource usage
05:22:50 <quicksilver> maurer_: here is why not : http://www.mail-archive.com/haskell-cafe@haskell.org/msg21306.html
05:23:05 <quicksilver> I'm not trying to put you off, particularly. But there is a good answer to the question 'why not'
05:23:19 <quicksilver> and oleg arranged the arguments more neatly in that email than I'm likely to in IRC.
05:27:00 <maurer_> quicksilver: It makes sense, but it seems that if you don't have an IO error semantics or random access, the benefits datawise are small, and if you know you eventually consume every stream, all resources should be freed...
05:27:03 <mm_freak_> maurer_: also iteratees are not much more difficult to writeâ€¦  plus you get a nice parser-like monadic interface
05:27:03 <maurer_> or am I missing something?
05:28:17 <quicksilver> maurer_: not particularly, no. If you understand the objections in that email and are happy they won't affect you, that's fine.
05:28:30 <maurer_> OK :) Thanks.
05:28:33 <mm_freak_> maurer_: you rely on garbage collection to handle lazy IO lists properlyâ€¦  and to pure code an error looks like end of file
05:29:07 <mm_freak_> relying on GC for impure resources is almost never a good idea
05:29:37 <Saizan> an error looks like an exception
05:31:01 <parcs> @hoogle Read a => String -> Maybe a
05:31:02 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
05:31:02 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
05:31:02 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
05:33:17 <parcs> is this defined somewhere that hoogle is not looking in?
05:33:28 <parcs> or rather, has not indexed
05:34:30 <mm_freak_> Saizan: right, it throws an exception now
05:34:52 <quicksilver> parcs: no.
05:34:59 <quicksilver> parcs: but you can build it using 'reads'
05:35:55 <quicksilver> > let readMaybe s = case reads s of [(x,"")] -> Just x; _ -> Nothing in (readMaybe "123" :: Maybe Double)
05:35:56 <lambdabot>   Just 123.0
05:39:25 <ddarius> @hackage safe
05:39:25 <lambdabot> http://hackage.haskell.org/package/safe
05:40:58 <ddarius> :t fmap fst . listToMaybe . reads
05:40:59 <lambdabot> forall a. (Read a) => String -> Maybe a
05:42:11 * hackagebot fuzzytime 0.6 - A clock and timer that tell the time in a more human way  http://hackage.haskell.org/package/fuzzytime-0.6 (KamilStachowski)
05:46:57 <syntaxfree> http://hpaste.org/43191/eq_instance_for_type_variable
05:47:05 <parcs> neat, thanks ddarius quicksilver 
05:47:27 <syntaxfree> can't deduce (Eq a), and  I think I have a grasp of why. I just don't know how to go about fixing it.
05:47:55 <j-invariant> data (Eq a) => Card a = Card a Int
05:47:56 <j-invariant> instance Eq (Card a) where
05:47:58 <j-invariant> sholud be
05:48:03 <j-invariant> data Card a = Card a Int
05:48:07 <j-invariant> instance Eq a => Eq (Card a) where
05:48:22 <syntaxfree> oh. the syntax.
05:48:24 <syntaxfree> thx
05:48:31 <Bynbo7> syntaxfree: it is almost always a bad idea to put type constraints on data types
05:48:45 <Bynbo7> because they infect all code that uses the data type
05:49:08 <syntaxfree> well, I want to have an Eq operation on this Card a datatype, and I want to keep that type variable open because there's a myriad of different types of cards.
05:49:37 <syntaxfree> which will have their own instances of Ordering and so on.
05:51:18 <syntaxfree> if I define an Ordering instance the system will know how to use functions  with Eq constraint, right?
05:52:08 <syntaxfree> as in there's a CardX type with an Ordering instance and Card CardX _ == Card CardX _ working.
06:05:11 <azaq23> syntaxf
06:05:12 <azaq23> e
06:05:26 <azaq23> syntaxfree: You have to have a Eq instance for CardX, because class  (Eq a) => Ord a
06:06:24 <Egbert9e9> i really wish there were better beautifiers for haskell
06:06:33 <Egbert9e9> my code looks like it can use one...
06:31:39 <lpsmith> If you start ghci,  and write   Data.ByteString.packCString nullPtr,  you will segfault
06:32:10 * lpsmith is wondering if packCString should be a little bit kinder on that issue
06:32:31 <lpsmith> err
06:32:42 <ion> Heh, nice
06:32:51 <lpsmith> > Data.ByteString.packCString Foreign.Ptr.nullPtr
06:32:52 <lambdabot>   Not in scope: `Data.ByteString.packCString'Not in scope: `Foreign.Ptr.nullP...
06:33:21 <lpsmith> I mean, it's arguable either way
06:33:34 <lpsmith> so I'm not sure if it should be considered a bug or not
06:35:35 <Spockz> I'm curious, who is using lhs2TeX here? I've been using it myself quite a lot for the university, but I'm wondering whether other people are using it in the wild too.
06:36:30 <lpsmith> I've used it
06:36:56 <lpsmith> Although,  it can be a little frustrating at times.   Then again,  TeX tends to be rather frustrating most of the time
06:36:57 <astroboy> Does anybody know if it's possible to use C-c C-l in haskell-mode in emacs getting the flags from a cabal file?
06:37:57 <Spockz> lpsmith: ah, I've created a tool to generate highlighting files for it. :-) So now my code is highlighted automatically :)
06:38:07 <Spockz> lpsmith: what did you find frustrating?/
06:38:17 <lpsmith> I don't quite remember
06:38:38 <lpsmith> Honestly I think most of it came when I was first trying to use lhs2TeX
06:38:45 <lpsmith> I haven't used it in about a year
06:39:03 <lpsmith> Also,  I decided the formatting mode I was using was a bit more trouble than it was worth
06:39:27 <lpsmith> I felt in the end that I would've been better off using the monospaced haskell stuff
06:39:37 <Spockz> lpsmith: ah okay. What formatting mode do you mean?
06:39:39 <lpsmith> Spockz, cool
06:39:49 <lpsmith> the new one
06:40:01 <lpsmith> the one my monad reader article uses
06:40:54 <lpsmith> Oh,  and I do remember one thing... I wanted to format function composition as \circ but that also picked up some qualified names I was using
06:40:59 <Spockz> I'm sorry, but I don't know the title?
06:41:14 <lpsmith> Issue 14,  "Lloyd Allison's Corecursive Queues"
06:42:32 <Spockz> lpsmith: are you refering to the replaced function arrows?
06:42:45 <Spockz> lpsmith: maybe that error has been fixed
06:43:02 <lpsmith> no, the one with all the columns and stuff.  I mean function composition,  replacing . with \circ
06:43:19 <lpsmith> But then if you have Qualified.name,  lhs2TeX wanted to pick that up too
06:43:36 <Spockz> hmm
06:43:36 <lpsmith> (IIRC that is)
06:43:40 <Spockz> that sounds familiar
06:43:49 <shurikas> let add x y = x + y
06:43:51 <shurikas> An application of add has the form add e1 e2, and is equivalent to (add e1) e2, since function application associates to the left. In other words, applying add to one argument yields a new function which is then applied to the second argument. This is consistent with the type of add, Integer->Integer->Integer, which is equivalent to Integer->(Integer->Integer); i.e. -> associates to the right. 
06:44:14 <shurikas> can anyone give me an example how a second function is called in here?
06:44:32 <shurikas> An application of add has the form add e1 e2, and is equivalent to (add e1) e2, since function application associates to the left. In other words, applying add to one argument yields a new function which is then applied to the second argument. This is consistent with the type of add, Integer->Integer->Integer, which is equivalent to Integer->(Integer->Integer); i.e. -> associates to the right. 
06:44:34 <lpsmith> add 1 (add 2 3) ,   or add (add 1 2) 3
06:44:36 <shurikas> sorry
06:44:57 <j-invariant> shurikas: what are you asking
06:44:58 <shurikas> oh
06:45:05 <shurikas> I am asking how does it work
06:45:08 <kenjin2201> It's hard for me to find the type error here : http://hpaste.org/43192/type_error
06:45:08 <lpsmith> shurikas, we'll forgive you...  this time ;-)
06:45:17 <shurikas> i have two arguments, it takes first one and creates another function on another argument
06:45:24 <shurikas> I dont get it
06:45:35 <j-invariant> how does what work
06:46:02 <nlogax> you have partially applied it, it still has one argument left to eat 
06:46:20 <lpsmith> shurikas,  well,  in basic set theory,  there is an isomorphism between   A x B -> C  and A -> (B -> C)
06:46:35 <lpsmith> namely,  curry and uncurry
06:46:36 <sipa> shurikas: do you want to know how that's translated to machine code?
06:46:40 <lpsmith> @src curry
06:46:40 <lambdabot> curry f x y = f (x, y)
06:46:44 <lpsmith> @src uncurry
06:46:44 <lambdabot> uncurry f p = f (fst p) (snd p)
06:46:48 <shurikas> sipa maybe not into a machine code...
06:47:12 <shurikas> I wonder when I define curried function in what way it is executed
06:47:26 <shurikas> with uncurried functions everything is simple
06:47:48 <lpsmith> well,  it might create a closure,  but GHC works hard to optimize those away if it doesn't need to
06:47:58 <lpsmith> Do you know what a closure looks like?
06:48:12 <kosmikus> lpsmith: it shouldn't ;)
06:48:20 <kosmikus> oops
06:48:21 <shurikas> -> ?
06:48:36 <kosmikus> sorry, out of context.
06:48:46 <lpsmith> oh
06:49:19 <kosmikus> lpsmith: I was commenting on your earlier statement where you said lhs2TeX would format dots in qualified names as function composition. If it does, it's a bug.
06:49:47 <shurikas> let add = \x -> \y -> x + y 
06:50:23 <Spockz> lpsmithm, kosmikus: it's not there anymore (the bug)
06:50:33 <lpsmith> kosmikus, yeah,  lhs2TeX doesn't really parse Haskell, it uses some kind of heuristic 
06:50:34 <merijn> shurikas: The important thing to realize is that the code GHC produces looks nothing whatsoever like C code does, for instance functions calls are not done in the same way as C (push arguments on the stack, jump to function, then return when the function is done popping the arguments of the stack)
06:51:31 <merijn> I believe GHC uses a "spineless tagless g-machine" to run code
06:51:55 <lpsmith> Actually,  not so much anymore
06:52:10 <lpsmith> They added tagging a long time ago for a pretty healthy performance boost
06:52:39 <lpsmith> But sadly,  I'm not up on all the gory details of the internals of GHC
06:52:46 <merijn> shurikas: Is there any specific reason why you need to know?
06:52:55 <merijn> In practice it is much easier to just assume it works by magic :p
06:53:01 <Spockz> lpsmith: https://gist.github.com/789783
06:53:09 <shurikas> merijn, I think you got my point
06:53:25 <shurikas> I dont understand how functions in FP are executed. In OOP everything is simple
06:53:37 <Spockz> kosmikus: how is your work on lhs2TeX 2.0 coming? :D
06:53:43 <shurikas> you provide arguments, those arguments are put into function block and value is returned
06:53:51 <shurikas> but in FP everything seems to be in another way
06:54:01 <merijn> shurikas: It *is* another way :p
06:54:16 <sipa> at least in lazy languages
06:54:19 <shurikas> merijn, problem is that I don't believe in magic ;) So I need to know
06:54:29 <merijn> shurikas: You know what a closure is?
06:54:32 <Spockz> shurikas: it's better than magic :)
06:55:27 <shurikas> I am not sure if I know. I know that it is a synonym for a lambda expression and that it involves arrows... but let me google for it 
06:55:32 <merijn> Currying behaves very similar to closures
06:56:53 <merijn> shurikas: Well, it is not so much a synonym for lambda expression as it is that *most* lambda expressions are closures
06:57:02 <shurikas> so to fully understand how functions work in FP I need to look deeper into closures and curried/uncurried functions?
06:59:42 <kosmikus> Spockz: slow, slow :)
06:59:56 <cloudd> Anyone familiar with Software as a service?
07:00:00 <Spockz> kosmikus: aaah, busy with work?
07:00:04 <Spockz> cloudd: sure
07:00:09 <merijn> shurikas: Lets take a detour back to imperative languages (but one which supports closures), this is python but I think it should be understandable enough: http://dpaste.com/339699/
07:00:23 <cloudd> Spockz: Practically or academic background?
07:00:45 <Spockz> cloudd: practically as user
07:00:47 <kosmikus> Spockz: also
07:00:49 <EvanR-work> shurikas: all functions have one parameter, multiparameter functions are really functions that return functions...
07:00:55 <EvanR-work> thats all there is to know
07:00:57 <EvanR-work> ;)
07:01:00 <Maxdamantus> Python also has something like (lambda(x): a + x).
07:01:16 <merijn> shurikas: As you can see in the example, a is now a function that adds "5" to its arguments. Where is this 5 stored? Obviously it can't be on the stack...
07:01:25 <Maxdamantus> tbh though, I disagree with languages calling that a lambda.
07:01:43 <EvanR-work> why
07:01:44 <Maxdamantus> (unless x does not change for the lifetime of the function .. maybe then it could be called one)
07:01:53 <Maxdamantus> er, a
07:01:59 <merijn> shurikas: The only way to do this is by somehow storing 5 outside of the stack and then look it up when "a" is called
07:02:14 <EvanR-work> yeah mutable free variables are fairly incomprehensible ;)
07:02:24 <shurikas> merijn, how to call foo AND provide x parameter?
07:02:25 <merijn> Maxdamantus: Python doesn't allow statements in lambda expressions so everything is immutable inside a lambda
07:02:27 <EvanR-work> just ignore that and hope no one gets clever in your team
07:02:36 <Maxdamantus> merijn: is it? O_o
07:02:37 <shurikas> is it foo(a, x), or foo(a) x ?
07:02:53 <merijn> shurikas: No, it is: "a(x)"
07:03:00 <Maxdamantus> foo = lambda(x): x + a
07:03:02 <merijn> shurikas: Or "foo(5)(6)"
07:03:05 <shurikas> gamn it.
07:03:09 <Maxdamantus> bar = lambda(): x = x + 1
07:03:13 * Maxdamantus doesn't know Python.
07:03:20 <Maxdamantus> Bleh, s/x/a/
07:03:21 <Maxdamantus> g
07:03:22 * laptop` doesn't either.
07:03:30 <cloudd> I need help to find some good literature about Software as a service. I am writing a master thesis proposal  with the theme:  possible values by adopting SaaS-based ERP in small and medium-sized businesses. Any suggestion for breaking the it down to a Research questionsn? The goal is to interview several companies regarding there experience and try to reveal some interesting findings that may contribute to research within our team
07:03:43 <cloudd> open for suggestion ;)
07:03:56 <deech`> Hi all, how do I make a contribution to the Haskell wiki?
07:04:17 <merijn> shurikas: foo() returns a function (which you can call again). Now currying is pretty similar to this (look at foo(5)(6), remove the parenthesis and you would have haskell like currying)
07:04:33 <aristid> cloudd: isn't this somewhat the wrong channel for this question?
07:05:02 <Mandezul> hi ... i have a question ... can I ask here?
07:05:02 <merijn> shurikas: Which language are you coming from? You have OO experience so I'm guessing Java or C#?
07:05:11 <shurikas> Java
07:05:21 <merijn> shurikas: Java has anonymous classes, right?
07:05:30 <shurikas> yes
07:05:33 <Maxdamantus> Bleh, the latter lambda doesn't work .. = is not an operator.
07:05:58 <merijn> Imagine an anonymous class having only one method "call()", see how this is similar to a function?
07:06:08 <shurikas> merijn, can you write another example like that in python with foo and bar?
07:06:41 <laptop`> Mandezul: worst that can happen is someone won't answer, so go for it.
07:06:59 <Mandezul> im defining a simple class that takes an Integer and gives a list. (Integral a) => a -> [a]. It gives me an error :         Use -XScopedTypeVariables to permit it. do you know why?
07:07:28 <laptop`> Mandezul: i'm totally new to Haskell, so i don't know, maybe someone else will?
07:07:38 <aristid> Mandezul: how about showing us the function?
07:07:41 <Mandezul> thank you a lot
07:07:56 <Mandezul>   listaDiv x = [1..(x/2)]
07:08:29 <Mandezul> i want the list from 1 to half of the value
07:08:43 <shurikas> http://kostas.pastebin.com/LUvBMFWe
07:08:53 <merijn> shurikas: http://codepad.org/jw95FUPK
07:10:14 <Maxdamantus> btw, Java's standard library has some "Runnable" interface iirc
07:10:24 <Maxdamantus> Which is intended for that.
07:10:49 <Maxdamantus> Java doesn't really have proper closures though .. you can only access local variables from the function they're declared in.
07:11:10 <shurikas> you can do that basically with any interface, because you always have to override methods in an anonymous class 
07:11:11 <Maxdamantus> The inner anonymous class can access fields from the classes it's in though.
07:11:16 <shurikas> but still it's not the same as in FP
07:12:39 <shurikas> merijn, so closure is that structure ' function -> function -> function ', yes? At least I see it like that...
07:12:49 <Maxdamantus> Runnable foo(){ int x; return new Runnable(){ void run /* I think that's what it's called */(){ /* can't see x */ } }; }
07:13:59 <merijn> shurikas: Yes, but the closure can also have values stored inside (like a class could, lemme cobble a Java example)
07:14:11 <merijn> shurikas: In the mean time: http://codepad.org/GAG9zuxE
07:14:26 <shurikas> I am trying to rewrite second example in Haskell now... ;D
07:14:49 <shurikas> hey, you already did that :|
07:15:28 <lpsmith> Spockz, nice
07:17:02 <shurikas> merijn, in this example: http://codepad.org/jw95FUPK     when you define a = add(5)... If you call a, you will get an error, because it is missing argument for a returned function, yes?
07:17:15 <shurikas> I mean if you call just 'a' with no arguments after it
07:17:26 <Mandezul> i got it
07:17:28 <Mandezul> indentation
07:17:30 <Mandezul> thanks
07:17:43 <azaq23> Maxdamantus: It can access local variables which are final, so final int x; new Runnable ... works.
07:17:44 <shurikas> please answer yes :D
07:18:22 <shurikas> azaq23, It can access private local variables too. If you access it by ClassName.this.myLocalVarbiale
07:18:24 <Maxdamantus> azaq23: hm .. that seems odd .. wonder why.
07:18:42 <shurikas> in inner anonymous class.
07:19:00 <merijn> shurikas: You mean if you do "a()"? Then yes, you get invalid number of arguments
07:19:13 <merijn> shurikas: Think of the function add like this Java class: http://dpaste.com/339749/
07:19:19 <Maxdamantus> shurikas: does that refer to some object's fields, or local method variables?
07:19:20 <shurikas> because a() returns foo which REQUIRES argument, yes?
07:19:28 <merijn> shurikas: Yes
07:19:39 <shurikas> then I think I start to understand that :)
07:20:36 <Maxdamantus> azaq23: ah, I see. It does its magic "may not have been initialised" stuff.
07:21:06 <Maxdamantus> So the compiler needs to be sure that it's set by the time you create the object so it can copy it over.
07:21:12 <merijn> shurikas: The interesting thing to see is that if you call add() twice (like in the example with a and b) then each returned foo() will remember the value that was originally given to add()
07:21:27 <Spockz> lpsmith: my tool is lhs2TeX-hl in hackage
07:22:12 <lpsmith> well, the next time I work on writing a haskell paper,  I'll keep that in mind :)
07:22:49 <pastorn> @hoogle withSockets
07:22:49 <lambdabot> Network withSocketsDo :: IO a -> IO a
07:22:50 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
07:22:50 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
07:23:06 <merijn> shurikas: This remembering of values stored within the stored function is what is meant with a "closure"
07:23:16 <shurikas> merijn, http://pastebin.com/PrZRnxJj
07:23:33 <shurikas> am I correct?
07:23:35 <merijn> shurikas: Correct
07:23:42 <shurikas> great :)
07:23:51 <shurikas> <merijn> shurikas: This remembering of values stored within the stored function is what is meant with a "closure"
07:24:07 <shurikas> you mean that inner functions remember values which are given to outer functions ?
07:24:14 <shurikas> if I am nesting one function in another...
07:24:19 <azaq23> Maxdamantus: Apparently, since anonymous inner classes are compiled separately from the class itself and then instantiated, I guess.
07:25:06 <hatds> can one search hackage by author?
07:26:47 <merijn> shurikas: Using your example of "add = \x -> \y -> x + y" then the function returned by "add 5" (i.e. the inner function) will remember the value 5, yes. Which means that if you do "add 5" after "add 4" then the function returned by "add 4" will still have x = 4 and not x =5. (In Haskell there is no such thing as "before" or "after" for pure functions, so in Haskell this explanation makes no sense, but it's correct in things like python)
07:27:43 <merijn> > let add = \x -> \y -> x + y in (add 5 4) + (add 2 1)
07:27:44 <lambdabot>   12
07:27:57 <shurikas> Which means that if you do "add 5" after "add 4" then the function returned by "add 4" will still have x = 4 and not x =5
07:28:11 <keep_learning> lambdabot, kool 
07:28:30 <sipa> shurikas: just remember one rule: variables are never overwritten
07:28:44 <shurikas> so each function is like an object in oop which has its own unique local variables, yes?
07:28:45 <sipa> and the order in which things are executed doesn't matter
07:28:48 <sipa> yes
07:28:54 <merijn> shurikas: Correct. But as I said, Haskell doesn't really have "after", since all variables in haskell are immutable the compiler can do *heavy* optimization like change the order in which functions are called
07:30:04 * sm solves an old mystery.. gmane web interface shows threads in only one of the cc'd newsgroups
07:32:48 <merijn> shurikas: For example, in Java or C if you have "some_func1(); some_func2();" the compiler might see that it would be more efficient to run them in parallel (multiple threads) or reverse the order. But what if some_func1 and some_func2 both write to a global variable? Then doing this would change the result. In Haskell the compiler *knows* the functions can't write to a global variable (immutable, etc) so the compiler can do whatever it wa
07:33:23 <shurikas> Haskell doesn't have variables at all as far as I see...
07:33:37 <j-invariant> shurikas: x is a variable
07:33:49 <shurikas> isin't it an argument? :)
07:33:53 <Maxdamantus> They're not called variables because they're mutable.
07:33:58 <Spockz> j-invariant: well, it's value can't change
07:33:59 <shurikas> oh, yeah. it is a variable inside a function.
07:34:02 <Maxdamantus> It's because their value varies.
07:34:17 <j-invariant> Spockz: that is correct
07:34:26 <Spockz> j-invariant: I know
07:34:28 <merijn> shurikas: And you can do "x = 5" as a global variables, you just can't change the value of x afterwards :p
07:34:32 <j-invariant> Spockz: ???
07:34:57 <Spockz> j-invariant: I know what I said was correct, sorry.
07:35:15 <j-invariant> iyts not clear why you said it
07:35:32 <merijn> shurikas: But in practice you almost never need global variables. And in the situations where you *really* do there are some (advanced) tricks to accomplish the same
07:35:50 <Spockz> j-invariant: I tried to help.. I should've use immutable. 
07:35:57 <Spockz> *used
07:36:03 <shurikas> thank you very much :)
07:36:16 <j-invariant> Spockz: x could be a mutable value such as  STRef
07:37:05 <Spockz> j-invariant: well aren't you changing what's behind the ref? And not the ref itself in that case
07:38:08 <shurikas> http://kostas.pastebin.com/VgVyGPaB
07:38:10 <shurikas> correct?
07:38:37 <Maxdamantus> shurikas: they're both the same.
07:38:39 <j-invariant> Spockz: that's just a point of view
07:38:44 <merijn> shurikas: No, secretly they are both the same :)
07:39:06 <merijn> :t \x y -> x + y
07:39:07 <lambdabot> forall a. (Num a) => a -> a -> a
07:39:13 <merijn> :t \x -> \y -> x + y
07:39:14 <lambdabot> forall a. (Num a) => a -> a -> a
07:39:21 <hpc> :t (+)
07:39:22 <lambdabot> forall a. (Num a) => a -> a -> a
07:39:41 <Maxdamantus> shurikas: you can do eg, (foo 4) 5 which may emphasise it.
07:40:04 <merijn> shurikas: They are identical, it's just that with "\x y -> x + y" the compiler automatically turns it into "\x -> \y -> x + y"
07:40:29 <Maxdamantus> All functions take one argument.
07:40:38 <merijn> shurikas: We functional programmers are extremely lazy and doing anything which a compiler could do for us is considered "bad" :p
07:40:56 <j-invariant> id takes one, ($) takes two
07:41:12 <Maxdamantus> j-invariant: ($) takes one.
07:41:14 <merijn> j-invariant: No, ($) also takes one
07:41:27 <Maxdamantus> :h ($) id
07:41:31 <Maxdamantus> :t ($) id
07:41:32 <lambdabot> forall a. a -> a
07:41:40 <Maxdamantus> > (($) id) 5
07:41:41 <lambdabot>   5
07:42:04 <aristid> :t id id id id id id id
07:42:05 <lambdabot> forall a. a -> a
07:42:06 <merijn> @let add = \x y -> x + y
07:42:07 <lambdabot>  Defined.
07:42:10 <Bynbo7> shurikas: the first thing you wrote is syntax sugar for the second
07:42:12 <j-invariant> I define the number of arguments to be taken as the number of right associative arrows
07:42:15 <aristid> :t const id id
07:42:16 <merijn> shurikas: Observe
07:42:17 <lambdabot> forall a. a -> a
07:42:17 * Maxdamantus doesn't really see much point in the shorthand syntax.
07:42:22 <merijn> :t add
07:42:23 <lambdabot> forall a. (Num a) => a -> a -> a
07:42:27 <merijn> :t add 1
07:42:28 <lambdabot> forall t. (Num t) => t -> t
07:42:28 <aristid> Maxdamantus: which shorthand syntax?
07:42:32 <merijn> :t add 1 1
07:42:33 <lambdabot> forall t. (Num t) => t
07:42:35 <Maxdamantus> Why not just remove the backslash from the syntax?
07:42:55 <Maxdamantus> and not have the multiple parameter things, then you don't need to bother bracketing data constructors, etc.
07:43:06 <merijn> > (\x y -> x + y) 1
07:43:06 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:43:07 <lambdabot>    arising from a use of `...
07:43:10 <Philippa> we don't /have/ multiple parameter things
07:43:16 <merijn> :t (\x y -> x + y) 1
07:43:16 <lambdabot> forall a. (Num a) => a -> a
07:43:22 <Philippa> we still need to bracket data constructors /because they can nest/
07:43:41 <Maxdamantus> Hm, true.
07:43:49 <merijn> shurikas: Do you understand or is it unclear still?
07:44:02 <shurikas> merijn, give me a minute to try it myself in GHCi
07:44:04 <aristid> Maxdamantus: were you just doubting the wisdom of curried functions?!
07:44:17 <Maxdamantus> aristid: I don't think so.
07:44:19 <Maxdamantus> aristid: only syntax.
07:44:34 <aristid> Maxdamantus: you're confusing me, madam
07:44:41 <merijn> Syntax, shmyntax. We only care about semantics!
07:44:49 <copumpkin> I'm not a fan of the backslash either, but it removes ambiguity from the grammar, I guess
07:45:05 <aristid> what's wrong with the backslash?
07:45:13 <copumpkin> it's ugly
07:45:15 <Maxdamantus> Bleh, my site's down .. could show an example of a language without the backslash.
07:45:19 <merijn> aristid: We support unicode, it should be a lambda! :p
07:45:24 <aristid> copumpkin: i think lambda is more ugly
07:45:31 <copumpkin> merijn: lambda happens to be in someone else's alphabet
07:45:39 <Maxdamantus> Actually, just DNS.
07:45:41 <Maxdamantus> Stupid uni.cc
07:46:05 <jmcarthur> i think lambda is pretty
07:46:11 <BancOMat> Ciao!
07:46:43 <merijn> I'm considering getting a shirt made with a lambda with a halo on top saying "In Church we trust." :p
07:46:46 <Maxdamantus> http://174.137.61.34/~max/ll/
07:46:56 <Maxdamantus> (Char a -> a) 'a'`
07:47:00 <Maxdamantus> s/.$//
07:47:07 <copumpkin> Maxdamantus: how about pattern matches?
07:47:31 <Maxdamantus> copumpkin: on what?
07:47:36 <copumpkin> on your input
07:47:51 <Maxdamantus> Well, there's a simple example of pattern matching there .. Char a
07:47:55 <copumpkin> oh
07:48:00 <copumpkin> I thought it was a type annotation of some sort
07:48:05 <Maxdamantus> It doesn't have any special : syntax though.
07:48:24 <Maxdamantus> It's a very simple language, and it's written really horribly so cbf fixing it.
07:48:33 <merijn> In nomine Church et Turing et Von Neumann. Amen. :>
07:48:46 <quicksilver> merijn: you can use a lambda, with the -XUnicodeSyntax extension
07:48:53 <Maxdamantus> (List (Char a, _) -> a) "a"
07:49:21 <copumpkin> quicksilver: nope
07:49:30 <copumpkin> quicksilver: that's the only thing it doesn't turn on, really :P
07:50:34 <Philippa> lambda means the parser doesn't need to backtrack, FWIW
07:50:40 <parcs> @type fmap (:)
07:50:41 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ([a] -> [a])
07:51:09 <Philippa> you'd need to use parens around anonymous functions that little bit more often, of course
07:51:21 <quicksilver> ah.
07:51:59 <shurikas> ok, thanks, I think I completely understand how it works :)
07:52:12 <merijn> shurikas: No problem :)
07:52:17 <shurikas> and with closures I can define anonymous functions
07:52:25 <merijn> shurikas: What are you reading to learn Haskell, btw?
07:52:25 <shurikas> (\x -> \y -> x - y) 5 4 
07:52:42 <shurikas> http://www.haskell.org/tutorial/functions.html 
07:52:52 <shurikas> but with no background in FP this tutorial is not clear
07:53:01 <merijn> I would recommend reading Learn You A Haskell instead
07:53:09 <merijn> It rocks if you're new to functional programming
07:53:12 <merijn> @where lyah
07:53:12 <lambdabot> http://www.learnyouahaskell.com/
07:54:37 <shurikas> I don't want a beginner's guide :) I think I just learned the essential part of FP in this channel so beginner's guide is not for me anymore ;D
07:55:09 <shurikas> anyway, thanks a lot :)
07:55:45 <merijn> shurikas: It isn't just for beginners, although the kiddie graphics and writing style don't make it look like that it is actually a quite in-depth Haskell introduction that covers almost everything you need to know
07:56:31 <hpc> the kiddie graphics are the best part
07:56:39 <hpc> just when you think it couldn't get any sillier, BAM!
07:56:44 <shurikas> :))
07:56:44 <hpc> you actually learn something
07:56:52 <merijn> hpc: Agreed, he succeeded marvelously in making Haskell look non-threatening :)
07:56:59 <merijn> Just skip to chapter 3/4 and you'll be at the very interesting stuff soon
07:57:37 <merijn> It kinda reminds me of the SPJ quote
07:57:41 <merijn> @quote very.weird
07:57:41 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
07:57:52 <hpc> :D
07:59:37 <Maxdamantus> Once you get passed the first 80 sections, you get to I/O!
07:59:49 <merijn> IO is so overrated :p
08:00:19 * Maxdamantus never really liked the concept of I/O being the first thing taught in a language.
08:00:24 <gwern> @quote daddy
08:00:24 <lambdabot> S.Behrens says: or maybe she is the Queen of Sciences and he is the Mack Daddy.
08:01:05 <hpc> Maxdamantus: i like how lyah handled it, introducing just enough at the very beginning for you to be able to run a program and see results
08:01:17 <hpc> IO is chapter 8, iirc
08:01:21 <hpc> which is quite a way in
08:01:25 <Maxdamantus> 9.
08:01:36 <Maxdamantus> I remember not liking lyah.
08:01:52 <Maxdamantus> Then I just sat here and watched people talk.
08:01:59 <Maxdamantus> Then I knew some stuff.
08:02:13 <Philippa> Maxdamantus: you need it for languages that don't have interpreters unfortunately
08:02:21 <Philippa> well, a certain amount. Enough to print your results
08:02:31 <merijn> Philippa: Languages without a REPL are a thing of the past :p
08:02:41 <Maxdamantus> Just provide a library that does the IO for you.
08:02:50 * Maxdamantus wonders if that would actually be useful :\
08:03:08 <Maxdamantus> Possibly.
08:03:10 <shurikas> and I thought it couldn't get more weird... :) http://kostas.pastebin.com/rH5t1Ra2 
08:03:11 <shurikas> anyway, it works. prints 2
08:03:21 <hpc> merijn: sadly, languages with a crappy REPL are a thing of the now
08:03:22 <Maxdamantus> For something like C, perhaps .. how does printf work?
08:03:38 <hpc> at least GHCi is sufficiently awesome to counteract the disaster that is python's
08:03:47 <merijn> Maxdamantus: You mean implementation?
08:04:15 <Maxdamantus> merijn: no. Just understanding the printf interface requires a quite wide knowledge.
08:04:35 <merijn> Really? I always thought printf was one of the simpler things in C
08:05:16 <Maxdamantus> var args aren't very simple.
08:05:34 <merijn> You don't need to understand var args to use printf, though
08:06:08 <Bynbo7> so, i just started reading a C++ tutorial... this language is messed up!
08:06:10 <Maxdamantus> You don't need to understand Haskell to use it.
08:06:15 <Maxdamantus> > 5 + 4
08:06:16 <lambdabot>   9
08:06:20 <mm_freak_> does haskell's printf use magic?  or just type level hackery?
08:06:20 <merijn> Bynbo7: Correct
08:06:29 <merijn> mm_freak_: Type level hackery
08:06:32 <systemfault> var args is just reinterpreting an array of bytes to some types... It's ugly and non-typesafe
08:06:33 <merijn> :t printf
08:06:34 <lambdabot> forall r. (PrintfType r) => String -> r
08:06:39 <systemfault> (In C)
08:06:55 <Bynbo7> :t printf "hello" 2
08:06:56 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
08:07:07 <Bynbo7> :t printf "hello" 2 "test" pi
08:07:08 <lambdabot> forall a t. (Floating a, PrintfType (a -> t)) => t
08:07:10 <Maxdamantus> systemfault: more importantly is probably how you call it.
08:07:19 <mm_freak_> ok, because i'm very sure it's possible to create printf with only RankNTypes
08:07:21 <systemfault> Bynbo7: Most people think the same of haskell :)
08:07:31 <merijn> systemfault: That's just business as usual in C, though
08:07:36 <Maxdamantus> Since in `printf("%i\n", i)`, it's not specifically looking for an integer in the second argument.
08:07:40 <systemfault> merijn: Indeed
08:07:50 <Bynbo7> mm_freak_: i don't thing printf uses much hackery at all, just interesting class instances
08:07:59 <merijn> systemfault: I mean, that's what C is for, ugly awful byte manipulation
08:08:00 <mauke> systemfault: I don't see how an array of bytes is involved
08:08:11 <merijn> mauke: Everything in C is an array of bytes >.>
08:08:14 <mm_freak_> Bynbo7: it needs to use at least /some/ hackery
08:08:31 <Bynbo7> systemfault: sure, but... http://www.4p8.com/eric.brasseur/cppcen.html#l8
08:08:37 <mm_freak_> Bynbo7: i'm thinking of reification as one possibility to implement printf
08:08:40 <mauke> merijn: no
08:08:57 <merijn> You must be doing different C from me then :D
08:08:59 <mauke> mm_freak_: printf is H98
08:09:23 <Bynbo7> biggest (k, m) = 10; double ewe tea ef mate
08:09:41 <mauke> merijn: macros, types, bitfields, functions
08:10:02 <Bynbo7> sure you can probably do this in C as well, but it feels even more wrong in C++
08:10:06 <Maxdamantus> Any object is an array (term not from the set of types) of bytes.
08:10:38 <mauke> not all things are objects
08:10:57 * merijn has been apprehended by the hyperbole police
08:11:04 <mauke> Bynbo7: well, that's just normal binding semantics
08:11:13 <mauke> (can't do it in C, actually)
08:11:50 <Maxdamantus> :t printf
08:11:51 <lambdabot> forall r. (PrintfType r) => String -> r
08:11:53 <mm_freak_> mauke: huh?  the interface is H98, but also its implementation?
08:12:04 <mauke> mm_freak_: yes
08:12:31 <hape01> how can I tell ghci to tell me about List? (it is a typeclass?)    I do  ghci:     +m List      :browse List, ok but where is it definied?
08:12:35 <Maxdamantus> Mmm .. So presumably PrintfType is an instance of Show and .. Functor or something?
08:12:46 <Bynbo7> mauke: but, they give examples of doing what i have problems with in C :P
08:12:46 <Maxdamantus> :info PrintfType
08:12:57 <aristid> Maxdamantus: PrintfType is a class.
08:13:06 <quicksilver> hape01: that's a module.
08:13:12 <Maxdamantus> Oh.
08:13:19 <hape01> ghci tells me ":info List"    not in scope
08:13:28 <quicksilver> hape01: yes, it's a module.
08:13:34 <hape01> quicksilver: ahh
08:13:36 <quicksilver> :info will give you info for types and classes
08:14:14 <quicksilver> and functions, in fact.
08:14:30 <rocksteady> where to look up source code of built in haskell functions?
08:14:33 <quicksilver> all symbols - Type, Class and Value symbols.
08:14:46 <quicksilver> rocksteady: the online docs have a 'source' link in them
08:14:54 <rocksteady> alrite thy
08:15:01 <quicksilver> rocksteady: for example http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
08:15:02 <Bynbo7> "You know the classical control structures of C: for, if, do, while, switch... C++ adds one more control structure named EXCEPTION" made me laugh
08:15:15 <rocksteady> great
08:15:21 <quicksilver> rocksteady: (top left of page there is a small soure link; also by most functions)
08:15:29 <quicksilver> top right!
08:15:32 <mauke> Bynbo7: well, it's not that new. C's equivalent would be longjmp
08:15:33 <rocksteady> yep, nice :)
08:15:38 <quicksilver> left+right so confusing.
08:16:03 <quicksilver> mauke: C++ exceptions are quite a lot more than longjmp.
08:16:08 <mm_freak_> indeed, printf is H98
08:16:11 <mm_freak_> interesting
08:16:15 <quicksilver> mauke: unrolling + destructing stackframes.
08:16:26 <mauke> quicksilver: how so? C has no destructors
08:16:49 <Philippa> sure, but longjmp doesn't do that in C++ either
08:16:54 <quicksilver> well, in C the difference is that the catcher chooses where to catch.
08:17:03 <mm_freak_> Bynbo7: what's so funny about this?
08:17:05 <quicksilver> but in C++ the destructors a big difference.
08:17:13 <mightybyte> Hmmmm, does parsec not include a case insensitive string matching function?
08:17:31 <Philippa> mightybyte: nope, nobody's bothered writing it. Shouldn't be too hard to add though
08:18:10 <zygoloid> Philippa: longjmp /could/ run the destructors in c++ ;) good ol' undefined behaviour :)
08:18:21 <mightybyte> Philippa: Yeah, maybe I'll do that.
08:18:36 <Philippa> zygoloid: yeah, but that's not much more likely than nasal demons
08:19:00 <mm_freak_> zygoloid: longjmp is a C function
08:19:12 <mauke> it's also a C++ function
08:19:20 <mm_freak_> it has no idea of the destructors from C++
08:19:31 <mauke> it could be implemented using exceptions
08:20:05 <Philippa> does its spec permit calling destructors?
08:20:12 <zygoloid> mm_freak_: [support.runtime]p4 in the c++ standard specifies its behaviour in c++
08:20:39 <mm_freak_> mauke: how?  in general there is nothing that prevents a longjmp from jumping down instead of upâ€¦  you may get a segfault, but it's possible
08:20:54 <mm_freak_> exceptions on the other hand can't be thrown down
08:21:07 <zygoloid> mm_freak_: the c++ std says: "A setjmp/longjmp call pair has undeï¬ned behavior if replacing the setjmp and longjmp by catch and throw would invoke any non-trivial destructors for any automatic objects."
08:21:17 <mauke> mm_freak_: ?
08:21:37 <mauke> you "can't" longjmp up in the sense that it has undefined behavior
08:23:25 <mm_freak_> mauke: with "up" i mean leaving a scopeâ€¦  with "down" i mean entering a scopeâ€¦  an exception is always catched by a surrounding catcher
08:23:37 <mm_freak_> so it can only be thrown "up" in this sense
08:23:43 <mm_freak_> unless you start hacking, of course
08:24:01 <mm_freak_> a longjmp can jump down without hacking
08:24:01 <zygoloid> mm_freak_: you can't longjmp or throw into an unwound stack frame. how could you? that frame is gone.
08:24:02 <mauke> oh right, you can longjmp sideways
08:24:30 <mm_freak_> zygoloid: you can, but you may get a segfault
08:24:46 <mauke> mm_freak_: that's like saying you can dereference null pointers
08:24:56 <mauke> sure, go ahead!
08:24:58 <Maxdamantus> (You can't on POSIX)
08:25:19 <mauke> Maxdamantus: I totally can
08:25:20 <mm_freak_> mauke: dereferencing NULL pointers is always an errorâ€¦  longjmping down isn't necessarily
08:25:26 <mauke> mm_freak_: wrong
08:25:51 <Maxdamantus> You should always get a segfault there when you try.
08:26:12 <zygoloid> Maxdamantus: you might not get a segfault. but you will certainly get undefined behaviour.
08:26:21 <mauke> until I mmap some pages there
08:26:22 <Maxdamantus> zygoloid: UB according to C.
08:26:27 <Maxdamantus> zygoloid: segfault according to POSIX.
08:27:56 <mm_freak_> mauke: IIRC most implementations just modify the stack pointerâ€¦  the stack may still be valid after longjmping down
08:28:10 <mm_freak_> in fact i believe it is valid as long as you don't call another function inbetween
08:28:15 <mauke> C has no stack
08:28:19 <mauke> you're in UB land
08:28:35 <mm_freak_> UB?
08:28:44 <zygoloid> Maxdamantus: that's pretty cool. how do they achieve that?
08:28:45 <mauke> undefined behavior
08:29:08 <mauke> zygoloid: by saying "dereferencing a null pointer causes a SIGSEGV"
08:29:14 <Maxdamantus> zygoloid: because segfault is required for unmapped addresses.
08:29:26 <Maxdamantus> And I think that NULL is not allowed to be mapped.
08:29:37 <zygoloid> Maxdamantus: mauke: oh. i thought we were talking about longjmp to an unwound stack frame?
08:29:43 <j-invariant> Is it practical to write bug free software in haskell?
08:29:50 <mm_freak_> mauke: right, it's undefined
08:29:59 <j-invariant> or should I just write something that roughly works and fix it each time I notice a problem
08:30:01 <Maxdamantus> j-invariant: why would you want to do that?
08:30:11 <hpc> j-invariant: extremely practical, relative to other languages
08:30:15 <mm_freak_> but one thing about setjmp/longjmp is that you can write an infinite loop using them without UBâ€¦  that's not possible with exceptions
08:30:29 <hpc> (since you can give formal proof your behavior)
08:30:31 <mm_freak_> so you can't implement setjmp/longjmp using exceptions
08:30:35 <j-invariant> hpc: how is that done?
08:30:50 <hpc> with great skill
08:30:54 <hpc> (i have no clue)
08:30:56 <mauke> mm_freak_: right, that's what I meant by longjmping sideways
08:31:01 <j-invariant> I don't beleive you
08:31:01 * hackagebot hmatrix 0.11.0.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.11.0.0 (AlbertoRuiz)
08:31:12 <zygoloid> mm_freak_: you can write an inf loop with exceptions. T::~T() { T t; throw t; } should do the trick.
08:31:24 <mm_freak_> mauke: ah, yeah
08:31:25 <mauke> mm_freak_: you'd need some compiler support and then you'd end up implementing longjmp/exceptions using the same primitives, not one in terms of the other
08:31:34 <mauke> mm_freak_: so you're right
08:31:37 <mauke> this doesn't quite work
08:31:39 <hpc> j-invariant: there's a kernel some guys wrote; they prototyped it in haskell, proved it worked, then wrote it in C to match the haskell behavior
08:31:47 <hpc> iirc it was House
08:31:47 <aristid> j-invariant: bug free software is by definition trivial, and who wants to concern himself with trivial software anyways?
08:32:17 <j-invariant> aristid: by which definition?
08:32:44 <aristid> j-invariant: i'm not good at mathematical jokes, sorry :P
08:33:09 <mm_freak_> zygoloid: it's not the exceptions, which lead to an infinite loop here
08:33:26 <mm_freak_> zygoloid: it's the very creation of the 't' itself
08:34:10 <zygoloid> mm_freak_: good point. :)
08:35:14 <EvanR-work> making bug free software would be like window makers not throwing bricks through windows, bad for business!
08:35:59 <aristid> EvanR-work: oh, so THEY always throw the bricks through my windows. and i was thinking it was the neighbor's kids
08:36:10 <Maxdamantus> Bug-free sentences similarly.
08:36:39 <mm_freak_> EvanR-work: nahâ€¦  i think it sells better to provide updates for features instead of bugfixes
08:36:40 <aristid> Maxdamantus: are you mocking my grammar? :P
08:36:59 <Maxdamantus> Get your software here! Bug free!
08:37:13 <EvanR-work> heh, you mean rename bug fixes to updates xD
08:37:38 <mm_freak_> Maxdamantus: "bug free" as in "free bugging"?
08:38:05 * hackagebot hTensor 0.7.0.1 - Multidimensional arrays and simple tensor computations.  http://hackage.haskell.org/package/hTensor-0.7.0.1 (AlbertoRuiz)
08:38:22 <Maxdamantus> mm_freak_: I was thinking about free bugs, but that might work too.
08:38:25 <Maxdamantus> Ambiguity!
08:38:27 <ddarius> hpc: It definitely wasn't House, but a seL4 implementation.
08:38:37 <mm_freak_> customer to haskell programmer: "your program has a bug";  response: "impossibleâ€¦  it compiled"
08:38:43 <EvanR-work> in some methodologies, bugs dont just increase the cost of maintenance, but initial development. implementing more complex code more likely to be buggy takes longer
08:39:04 <EvanR-work> so the customer is paying for bugs xD
08:39:52 <Maxdamantus> Bugs are $200 extra.
08:40:50 <mm_freak_> customer: "your program freezes and doesn't respond"â€¦  response: "just waitâ€¦  it's written in agda"
08:42:18 <Maxdamantus> customer: "Oh god, demons out of my nose"â€¦ response: "Oh, wow"
08:43:04 <hpc> customer: "i want this to work with Joomla"... response: *ax murder*
08:43:11 <EvanR-work> hahhaha
08:49:00 <mm_freak_> toSmartCustomer :: Customer -> a
08:49:30 <ion> toSmartCustomer :: Customer â†’ ()
08:49:56 <Maxdamantus> Is it possible to implement Unique in pure Haskell?
08:50:12 <mm_freak_> Maxdamantus: not without IO
08:50:21 <Maxdamantus> Er yeah, with IO
08:50:49 <Maxdamantus> I guess .. nvm, just is it possible to implement Unique with anything?
08:50:54 <quicksilver> you can implement it without IO, but not without making it monadic.
08:51:15 <rocksteady> how to import a .hs file so i can use the functions definied in it?
08:51:25 <mm_freak_> sure:  forkIO $ mapM_ (putMVar uniqueVar) [1..]
08:51:37 <mauke> rocksteady: you don't import files, you import modules
08:52:10 <rocksteady> okay. i know how to import modules. but i thought there is a way more simple when i dont need modules. thx
08:52:24 <mauke> not really
08:52:27 <mm_freak_> rocksteady: it doesn't make sense in haskell "not to need modules"
08:52:47 <mm_freak_> remember it's not C
08:53:00 <Maxdamantus> Oh right, newtype :\
08:53:41 <rocksteady> okay ^^
08:53:41 <parcs> you can probably implement unique with natural numbers and the writer monad
08:53:57 <Maxdamantus> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Unique.html
08:53:57 <mm_freak_> Maxdamantus: i almost always write my own unique id generator
08:54:13 <Maxdamantus> So apparently it just uses an ever-incrementing integer.
08:54:26 <mm_freak_> yes, but that's not specified
08:54:35 <Maxdamantus> Yeah, ofcourse.
08:55:02 <mm_freak_> and that is a problem, which is the reason i write my own
08:55:10 * hackagebot streams 0.2 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.2 (EdwardKmett)
08:57:38 <quicksilver> it's pretty embarassing that Data.Unique uses unsafePerformIO to allocate its global mutable variable.
09:03:09 * Maxdamantus discovered that ghci interprets code as if inside a `do` construct that main is.
09:04:01 <quicksilver> sort of, yes.
09:04:38 <quicksilver> althought not exactly, because it does also have the ability to evaluate simple expressions and show the result.
09:04:49 <quicksilver> I prefer to think of it as a pure REPL that has the added feature of being able to run IO actions.
09:05:22 <Maxdamantus> > x <- return 4
09:05:23 <lambdabot>   not an expression: `x <- return 4'
09:05:42 <monochrom> fortunately lambdabot is not ghci
09:06:04 <Maxdamantus> Mmm..
09:10:40 <keep_learning> hello all 
09:11:18 <keep_learning> could some one please tell me if http://hpaste.org/43199/montogomery_ladder implementation is correct 
09:11:37 <keep_learning> http://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
09:11:50 <keep_learning> algorithm is Montgomery ladder 
09:12:07 <j-invariant> keep_learning: good question. How does one know if an algorithm is correct or not
09:12:29 <keep_learning> j-invariant, thats not my concern 
09:12:31 <j-invariant> keep_learning: The current approach to this is to "brute force" the program with a large collection of inputs and outputs
09:12:46 <keep_learning> j-invariant, could you please tell me 
09:12:54 <keep_learning> if i correctly translated the
09:13:02 <keep_learning> the given algorithm 
09:13:13 <mm_freak_> keep_learning: use test vectors
09:14:13 <keep_learning> what is test vector 
09:14:19 <keep_learning> and second thing 
09:14:29 <keep_learning> i also used bitwise operators 
09:14:46 <mm_freak_> keep_learning: prepared test values with expected results
09:14:53 <keep_learning> so i am not confident 
09:14:56 <keep_learning> k 
09:15:00 <keep_learning> thank you 
09:15:19 <mm_freak_> keep_learning: you can use the 'quickcheck' or 'smallcheck' packages to write unit tests for your code
09:15:19 <monochrom> testing is pointless if you don't know the correct answers. you don't know the correct answers if the correct answers are supposed to come from an unimplemented algorithm.
09:15:51 <mm_freak_> monochrom: but that's not an unimplemented algorithmâ€¦  you can compare results with existing implementations
09:16:15 <mm_freak_> keep_learning: PARI/GP has elliptic curve operations, so you can compare its results with yours
09:16:33 <keep_learning> mm_freak_ thank you 
09:16:54 <keep_learning> mm_freak_, i think i just wanted to ask if some one can have a look at code 
09:16:57 <j-invariant> keep_learning: why do you want to be confident about the program being correct
09:17:07 <keep_learning> and tell if this is correct translation of wiki code
09:17:14 <j-invariant> what are you  using the program for?
09:17:15 <keep_learning> wiki algorithm
09:17:56 <quicksilver> he's trying to learn haskell; he's asking if that is a correct transcription of the other code
09:17:56 <keep_learning> j-invariant, i am trying to implement http://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication montgomery ladder 
09:18:00 <j-invariant> keep_learning: yes but why?
09:18:01 <keep_learning> in haskell 
09:18:17 <j-invariant> is it to learn?
09:18:22 <keep_learning> j-invariant, for elliptic curve prime factorisation 
09:18:25 <monochrom> because it's granted by the axiom of choice
09:18:30 <j-invariant> keep_learning: if you want to compute just use pari
09:18:39 <j-invariant> since there is a chance the haskell will give wrong answers
09:19:02 <pumpkin> j-invariant: [12:25:14 PM] <quicksilver> he's trying to learn haskell; he's asking if that is a correct transcription of the other code
09:19:32 <keep_learning> pumpkin, yes you got me 
09:19:49 <j-invariant> keep_learning: is it to post on wiki?
09:19:53 <keep_learning> pumpkin, could you if u would like to 
09:19:57 <j-invariant> or present in a talk>?
09:20:05 <mm_freak_> keep_learning: is this a probabilistic algorithm?
09:20:08 <keep_learning> j-invariant, no 
09:20:12 <j-invariant> keep_learning: what then?
09:20:39 <keep_learning> i will use it mine elliptic curve package 
09:20:40 <mm_freak_> keep_learning: or does it use increasingly better approximations or something of that sorts?
09:20:44 <keep_learning> for further use
09:20:47 <j-invariant> keep_learning: I would recommend against it
09:21:02 <j-invariant> keep_learning: If you cannot be sure it's correct, and only take someone elses word: It's a dangerous thing to use this code
09:21:11 <j-invariant> keep_learning: since it could be full of mistakes which are unanticipated
09:21:39 <keep_learning> j-invariant, thats fine but i can say looking at same python code 
09:21:48 <keep_learning> if its correct translation or not 
09:22:05 <keep_learning> j-invariant, thats why i am asking here from haskell gurus 
09:22:18 <j-invariant> yes and i am saying that approach is dangerous
09:22:21 <Bynbo7> j-invariant: he's trying to learn, he won't learn much from using someone else's code. 
09:22:23 <keep_learning> i can easily translate that code in c java python 
09:22:27 <pumpkin> j-invariant: he's trying to learn haskell...
09:22:31 <j-invariant> even if it was correct translation: How do you know the source is correct?
09:22:34 <j-invariant> maybe wikipedia has a mistake in it
09:22:38 <Bynbo7> j-invariant: seriously, what is your problem?
09:22:53 <pumpkin> sounds like a broken record
09:23:01 <keep_learning> j-invariant, :)
09:23:10 <keep_learning> Bynbo7, could u have a look 
09:23:12 <Bynbo7> j-invariant: the answer to your question is 'it's not all that relevant'
09:23:23 <j-invariant> keep_learning: I hope it doesn't sound like I am worrying about things that don't matter. In my opinion these are very important
09:23:29 <Bynbo7> keep_learning: you keep asking me at reallyt bad times, i'm just about to go to sleep again :P
09:23:39 <pumpkin> j-invariant: they are important if you want to factor numbers. If you want to learn haskell, they are not
09:23:41 <keep_learning> Bynbo7, thank you 
09:23:43 <mm_freak_> keep_learning: i don't know the algorithm, so i can only comment border aspects of your codeâ€¦  for example, writing explicit recursion is usually not good coding style, but it's fine, as long as you're a beginner
09:24:00 <Bynbo7> keep_learning: if you're around tomorrow, and I haven't gone out, i'll have a look :)
09:24:11 <keep_learning> mm_freak_, yes i am beginner 
09:24:21 <keep_learning> Bynbo7, sure 
09:24:29 <mm_freak_> keep_learning: whenever you're tempted to use recursion, consider using some data structure
09:24:30 <Bynbo7> mm_freak_: bah, i use it all the time. it's good style if it makes it more understandable
09:24:35 <keep_learning> i will be here when i will have problem in haskell 
09:25:17 <keep_learning> Bynbo7, i will ping u tomorrow 
09:25:23 <Bynbo7> ok
09:25:41 <j-invariant> keep_learning: do you not thinnk that matters?
09:26:02 <mm_freak_> keep_learning: as an example to implement the mersenne primality test you need to check an element from an infinite sequenceâ€¦  in haskell a beginner may be tempted to write a recursive algorithm to calculate that sequence, but instead you can just as well really create an infinite list and index it
09:26:04 <keep_learning> j-invariant, sure may be wiki algo is wrong 
09:26:04 <Bynbo7> j-invariant: no, it doesn't matter, shush
09:26:43 <keep_learning> j-invariant, there could be lot of things but what i am trying is to implement the algorithm irrespective of right or wrong 
09:26:56 <keep_learning> j-invariant, thank u for your concern 
09:26:57 <j-invariant> keep_learning: oh I see
09:26:58 <quicksilver> j-invariant: the primary purpose of this channel is to help people with haskell questions, so it's probably more productive if we focus on helping keep_learning with his haskell questions and not examining his motives.
09:27:07 <monochrom> correctness is important. for beginners the correctness criterion is to have an expert grade it, such as what keep_learning is asking for now. this is not dangerous. not as dangerous as what every school is doing anyway. I don't understand j-invariant's obsession.
09:27:15 <Bynbo7> j-invariant: i do no see the wisdom of basically telling someone they should learn a very complex topic so they can prove for themselves that something is completely correct. there's a reason why these things take years to learn
09:27:17 <mm_freak_> Bynbo7: it may be good for your algorithms, but in general (!) it's not so goodâ€¦  often there is a combinator or data structure, which expresses what you want
09:27:21 <j-invariant> geez I asked a question about the haskell code
09:27:31 <j-invariant> if you want to debug it for him i am not stopping you
09:28:05 <keep_learning> j-invariant, its like we learning addition with out knowledge of group theory 
09:28:12 <Bynbo7> j-invariant: that's what people come here asking for help with... why is that a bad thing?
09:28:13 <keep_learning> i am trying to learn haskell 
09:28:15 <Bynbo7> wtf?
09:28:16 <monochrom> oh it's your turn to say "geez"? finally understand what it is like to be grilled?
09:28:24 <j-invariant> keep_learning: well I thought you said you were making an elliptic curve package
09:28:38 <kuffaar> <keep_learning> i am trying to learn haskell <- why would you want to do that?
09:28:39 <keep_learning> j-invariant, yes i am 
09:28:43 <j-invariant> oay
09:28:48 <Bynbo7> i'm still under the impression that j-invariant is just a very well thought out troll
09:28:50 <keep_learning> j-invariant, buts form scratch 
09:29:00 <j-invariant> the best way
09:29:06 <monochrom> haha kuffaar
09:29:14 <kuffaar> monochrom what.
09:29:23 <kuffaar> I'm just trying to preserve that person's sanity.
09:29:27 <kuffaar> @quote SPJ cheerful
09:29:28 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
09:29:32 <monochrom> all the more haha :)
09:30:05 <keep_learning> everyone seems to be in mood teaching correctness 
09:30:10 <j-invariant> haskell is all about abstract nonnsense
09:30:16 <j-invariant> keep_learning: you asked "if it is correct"
09:30:16 <kuffaar> j-invariant yeah
09:30:35 <pumpkin> okay, it's getting sort of trolly in here
09:30:36 <j-invariant> keep_learning: I thought you meant it !
09:30:43 <mm_freak_> pumpkin: i agree
09:30:44 <keep_learning> j-invariant, yes but its implementation 
09:30:46 <pumpkin> I'm going to fix that if it keeps up
09:30:49 <Bynbo7> j-invariant: and you took the question far too literally
09:30:51 <j-invariant> keep_learning: yeah I undersatnd now
09:30:56 <keep_learning> j-invariant, i can't comment on wiki algorithm 
09:31:03 * Bynbo7 wonders whether j-invariant is autistic
09:31:04 <keep_learning> j-invariant, so i have to trust it 
09:31:13 <Philippa> j-invariant: keep_learning asked about the translation, not the original code
09:31:15 <j-invariant> keep_learning: well it is basitc group theory
09:31:23 <keep_learning> j-invariant, as i am not expert of montgomery curves
09:31:37 <Philippa> Bynbo7: oi, not on. There are people on the spectrum around here, we don't need people using it as a catchphrase for "someone being a particular kind of arsehole" thanks
09:31:38 <j-invariant> Philippa: 
09:31:41 <j-invariant> 17:18 < keep_learning> could some one please tell me if  http://hpaste.org/43199/montogomery_ladder  implementation is correct 
09:32:05 <j-invariant> Philippa: anyway I talked to him about it, now I know the real meaning ... not sure why everyone attacking me
09:32:11 <keep_learning> j-invariant, yes 
09:32:18 * hackagebot graphs 0.1 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.1 (EdwardKmett)
09:32:18 <keep_learning> j-invariant, and posted link too 
09:32:19 <j-invariant> kind of pissing me off I think the discussion ended ages ago, but everyone wants to tell me off
09:32:28 <keep_learning> j-invariant, of wiki 
09:32:35 <pumpkin> j-invariant: we can all just stop talking about it then
09:32:42 <Bynbo7> Philippa: that is not at all how i intended it to be taken, i meant it as an honest question, because his behaviour reminds me of the autistic people i've met, not least of which my girlfriend's little brother. i did not mean it as an insult
09:32:48 <keep_learning> j-invariant, so that you can check if its correctly translated 
09:33:02 <keep_learning> j-invariant, if you feel offended than i am sorry 
09:33:08 <j-invariant> keep_learning: not by you! sorry
09:33:11 <mm_freak_> hey peopleâ€¦  now we all know what keep_learning's query is aboutâ€¦  can we all stop this pointless discussion now?  i'm not used to #haskell being so trolly
09:33:26 <keep_learning> mm_freak_, me too :)
09:33:27 <Twey> Emphatic agreement
09:33:41 <edwardk> yeah
09:33:41 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:34:20 <Philippa> Bynbo7: still not on or helpful though - now you're creating the impression that only pathological people would do something like that
09:34:53 <edwardk> @tell ivanm i swapped because i liked the class Graph g v e | g -> v e notation â€” but ultimately reverted because i could define the Dfs and Bfs monads more nicely with the type families
09:34:54 <lambdabot> Consider it noted.
09:35:35 <Bynbo7> Philippa: again, that's not what i meant. but we don't need to go into this, i can see how to others it probably came out much more harshly/inappropriately than it was meant
09:35:55 <mm_freak_> keep_learning: i always find it difficult to translate wikipedia algorithms to haskell, because they usually give a very imperative specification
09:36:08 <mm_freak_> and in haskell it often boils down to a one- or two-liner
09:36:16 <j-invariant> wikipedia is the worst site to lean algorithms from
09:36:21 <keep_learning> mm_freak_, yes exactly 
09:36:24 <mm_freak_> if you use the right combinators together with the right data structures
09:36:36 <Bynbo7> mm_freak_: could be an interesting project, finding imperative algorithms, and adding non-imperative versions as well
09:36:40 <keep_learning> mm_freak_, thats why i am not very much confident about my tranlation 
09:36:53 <Saizan> is  http://hpaste.org/43199/montogomery_ladder giving a 502 error only to me?
09:36:53 <gwern> well, haskell one or two liners often have different complexities...
09:37:04 <mm_freak_> j-invariant: i don't think keep_learning insists on learning /the algorithm/â€¦  i think he's rather learning /haskell/ by implementing an algorithm =)
09:37:06 <pumpkin> Saizan: same here
09:37:11 <gwern> Saizan: same here
09:37:15 <mm_freak_> Bynbo7: true
09:37:19 <Philippa> Bynbo7: I'm telling you that what you mean doesn't actually come into it much - people casually asking that kind of thing in response to behaviour they think of as autistic is problematic in and of itself, and in the case that you're actually trying to help the person in question you shouldn't be asking it in public
09:37:55 <gwern> if I weren't so lazy, I'd blog my way through Okasaki
09:37:59 <mm_freak_> gwern: in my experience the proper implementations with the right complexities aren't necessarily much longer
09:38:10 <j-invariant> mm_freak_: yeah I tohught it was the opposite way before heh explained that to me
09:38:14 <Bynbo7> yes, i realise that now Philippa, i'm sorry (and to you too j-invariant if you were offended)
09:38:22 <keep_learning> http://hpaste.org/43199/montogomery_ladder
09:38:30 <j-invariant> mm_freak_: I fix my mistake by asking him and everyone likes to rubi it in .. whatever, its not new
09:38:37 <keep_learning> hello all should i post the code again 
09:38:37 <Philippa> (I'm also not just talking to you: it's a general point for everyone)
09:38:48 <edwardk> so what graph algorithms can folks think of that'd be nice to have?
09:39:02 <j-invariant> edwardk: connected components
09:39:08 <kuffaar> nginx Bad Gateway
09:39:14 * kuffaar uses nginx, too
09:39:16 <edwardk> i've been leaning towards porting a number of parallel algorithms out of the parallel BGL
09:39:19 <gwern> blogging through okasaki is actually a really good idea. pure structures mean easy discussion, visualisation with vacuum, benchmarking; you can benchmark your various versions against Edison's implementation; ech datastructure is a distinct and well-bounded topic for a long post/essay; and they build on each other
09:39:21 <pumpkin> edwardk: subgraph isomorphism, kthx
09:39:23 <edwardk> j-invariant: *nods*
09:39:26 <Bynbo7> kuffaar: that's my favourite graph algorithm :P
09:39:34 <edwardk> pumpkin: sounds fast
09:39:39 <kuffaar> Bynbo7: nginx is a graph algorithm?
09:40:15 <mm_freak_> j-invariant: let goâ€¦  the discussion is over and i'm glad about it =)
09:40:19 <edwardk> i'll have to bolt in yices-painless for that
09:40:19 <Bynbo7> gwern: oo, sounds fun, link?
09:40:21 <Maxdamantus> Every program is a graph algorithm.
09:40:32 <gwern> Bynbo7: I said it's a good idea i'd do if I weren't so lazy
09:40:34 <Saizan> keep_learning: hpaste.org seems to be having problems, so i guess it'd help :)
09:40:35 <gwern> :(
09:40:55 <Bynbo7> gwern: pls can has less lazy?
09:41:03 <keep_learning> http://ideone.com/FTImT
09:41:11 <keep_learning> Saizan, http://ideone.com/FTImT
09:41:17 <Bynbo7> i'd love to see that.
09:41:20 <gwern> Bynbo7: unfortunately there are no good orifices for strictness annotations in the human body
09:41:22 <j-invariant> lot of snarky sarcastic rude comments from monocrhom,
09:41:23 <keep_learning> Saizan, try ideone link 
09:41:24 <gwern> if you know what I mean
09:41:47 <monochrom> onoes, hpaste.org is 502 again
09:41:58 <Bynbo7> j-invariant: i thought i was far more rude than monochrom :\
09:42:17 <Philippa> gwern: I believe there's a GHC module whose name suggests otherwise?
09:42:32 * gwern pretends to not know what Philippa means
09:42:47 <mm_freak_> keep_learning: the reason why i told you about the primality test for mersenne numbers is that your 'tmpFun' function really looks a lot like a sequence
09:42:50 <Bynbo7> gwern: why would GHC have a -ddump-occur-anal flag if there weren't? =)
09:43:04 <gwern> Bynbo7: hush, it's funner when we're the only ones who know!
09:43:23 <mm_freak_> keep_learning: so you might want to implement it as oneâ€¦  an infinite list that isâ€¦  the 'iterate' function is helpful for that
09:43:45 <mm_freak_> > iterate (\x -> mod (x^2 + 1) 127) 1
09:43:46 <lambdabot>   [1,2,5,26,42,114,43,72,105,104,22,104,22,104,22,104,22,104,22,104,22,104,22...
09:43:50 <keep_learning> mm_freak_, k  
09:44:54 <j-invariant> I dont like this channel
09:45:18 <keep_learning> mm_freak_, ok but i have to find out the most significant digit 
09:45:20 <gwern> but seriously, I only just mustered teh willpower to finish my haskell bot tutorials, and I'm bogged down in SICP, so I won't be doing okasaki any time soon
09:45:27 <keep_learning> mm_freak_, so i used log 
09:45:34 <EvanR-work> i wonder what the current state of OOP in the 'industry' is right now
09:45:37 <Bynbo7> gwern: :(
09:45:40 <keep_learning> mm_freak_,  but your idea seems promising 
09:45:47 <EvanR-work> is it still the sacred paradigm
09:45:49 <mm_freak_> you can easily encode the base case (the stopping condition) using, for example, 'takeWhile' or 'find'
09:45:57 <Bynbo7> i need t get back to my array package work tomorrow.
09:46:05 <gwern> EvanR-work: I think it is. ruby and python are still OO as are java and c++
09:46:13 <Philippa> EvanR-work: it's getting on for it in a "how could you think any other way?" kind of way
09:46:33 <EvanR-work> i was told that you 'can' do functional programming in python
09:46:41 <EvanR-work> ruby added functions...
09:46:42 <mm_freak_> keep_learning: the most significant digit in which base?
09:46:55 <EvanR-work> java and c++ should be going down the drain any second now...
09:47:02 <Bynbo7> Question to all: Are there any mutable array functions you think are missing in the standard array package? (that are not already found here: https://github.com/axman6/array-utils/blob/master/Data/Array/Util.hs =))
09:47:10 <Philippa> Python's FP support is poor, ruby's is much better
09:47:16 <EvanR-work> really
09:47:27 <gwern> ruby is a half-acceptable lisp
09:47:35 <EvanR-work> more or less so than js?
09:47:39 <mm_freak_> > let msdMod b = last . takeWhile (> 0) . iterate (`mod` b) in msdMod 10 5278341
09:47:43 <lambdabot>   mueval-core: Time limit exceeded
09:47:45 <mauke> perl is a lisp
09:47:53 <mm_freak_> > let msdMod b = last . takeWhile (> 0) . iterate (`div` b) in msdMod 10 5278341
09:47:54 <alpounet> Bynbo7, oh, isn't this about the reddit post about haskell vs ocaml vs C performance ?
09:47:55 <kuffaar> I'm really fluent in Ruby :'(
09:47:56 <lambdabot>   5
09:47:56 <lispy> What is the criteria to be a lisp?  It seems everyone has their own twisted def :)
09:47:59 <gwern> EvanR-work: I hear it's more acceptable, but who knows
09:48:01 <Philippa> EvanR-work: it's lexically scoped for one, so more so IMO
09:48:04 <Bynbo7> alpounet: it sure is
09:48:07 <keep_learning> thank you all guys 
09:48:16 <EvanR-work> Philippa: eh? js uses lexical scope
09:48:22 <keep_learning>  i wrote my alternate function 
09:48:27 * hackagebot parsec1 1.0.0.0 - Monadic parser combinators  http://hackage.haskell.org/package/parsec1-1.0.0.0 (ChristianMaeder)
09:48:30 <Bynbo7> alpounet: i'm working on getting these what i believe are primitive array operations added to array
09:48:31 <keep_learning> hello 
09:48:36 <mm_freak_> keep_learning: look at this codeâ€¦  this is how i would write a function to calculate the most significant digit
09:48:42 <edwardk> "parsec1?"
09:48:48 <alpounet> that would be nice Bynbo7 
09:48:50 <Philippa> EvanR-work: oh, right, they fixed that?
09:48:54 <EvanR-work> lol
09:48:59 <gwern> edwardk: maybe he doesn't know how to make deps on older parsec versions
09:48:59 <Bynbo7> alpounet: can you think of any more? :)
09:49:01 <EvanR-work> in 1995 i guess
09:49:23 <mm_freak_> keep_learning: not imperatively by repeatedly dividing, but instead by creating an infinite list of such successive divisions, then cutting it to a finite portion and finally finding that list's last element
09:49:56 <edwardk> i just wish he would have put the damn thing in a different namespace, rather that proliferate the need for package qualified imports
09:50:02 <edwardk> er rather than
09:50:08 <EvanR-work> well despite functional 'support' i guess most people still opt for OOP by default. but still... do people still say 'thats not oop, refactor' ?
09:50:14 <EvanR-work> is my question
09:50:18 <alpounet> Bynbo7, can't think of any right now
09:50:24 <alpounet> but i'll think about this
09:50:50 <jmcarthur> EvanR-work: yes people do
09:51:35 <kuffaar> C++ is a great Lisp
09:52:07 <roconnor> @seen jeffheard
09:52:07 <preflex>  jeffheard was last seen on #haskell 1 year, 285 days, 3 hours, 10 minutes and 40 seconds ago, saying: is there a paper reference out there on IO and denotational semantics in concurrent (and possibly separately) non-concurrent programs?
09:52:08 <lambdabot> Unknown command, try @list
09:52:18 <Zhuangzi> What's the default infix spec for `foo` expressions?
09:52:19 <Peaker> The "datetime" package requires base 3.  Is there an alternative that works with base 4?
09:52:50 <alpounet> Peaker, the 'time' package
09:53:32 <Zhuangzi> http://hackage.haskell.org/package/time
09:53:49 <Peaker> Is the interface similar?
09:54:01 <alpounet> it's a bit more complicated to use
09:54:01 <Peaker> It's not my package, I need to go convert it, I guess
09:54:09 <Peaker> alpounet, Why?
09:54:22 <Zhuangzi> Looks the same to me.
09:54:42 <alpounet> the interface is a bit more cumbersome, just a bit
09:59:20 <bos> urgh, fundeps and type families are always confusing.
09:59:20 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
09:59:38 * Zhuangzi been battling fundeps today
10:00:14 <bos> fundeps are easier for basic stuff, but it's hard to figure out how to do some things with em.
10:01:35 * Evious has had luck using fundeps on an as-needed basis. Writing code until he realized that hey, type inference is having trouble, I need to help it.
10:01:44 <Evious> Figuring it out ahead of time = oh god how does this work
10:05:32 * hackagebot parsec3 1.0.0.0 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.0 (ChristianMaeder)
10:09:16 <bos> preflex: seen byorgey
10:09:16 <preflex>  byorgey was last seen on #haskell 1 day, 2 hours, 24 minutes and 24 seconds ago, saying: at least I assume it doesn't
10:10:00 <kuffaar> preflex: seen spj
10:10:01 <preflex>  Sorry, I haven't seen spj
10:20:14 <joe1> is there a way to implement a delta function in haskell?
10:20:58 <bos> what kind of delta function?
10:21:19 <joe1> dirac
10:22:24 <joe1> so when the delta function occurs, I'd like to treat it as an event that causes an effect.
10:22:36 <pumpkin> let f 0 = 1 / 0; f _ = 0
10:23:14 <bos> you could write that, yes.
10:24:55 <byorgey> hi bos 
10:25:06 <bos> byorgey: why hello!
10:25:10 <byorgey> looking for me?
10:25:17 <pumpkin> @ask tibbe in hashable, hashByteArray seems to use an expanded version of combine instead of calling combine, and combine isn't marked as inlined. It might improve clarity to just call combine with an inline annotation on it?
10:25:17 <lambdabot> Consider it noted.
10:25:21 <bos> byorgey: i am tying myself in knots with type families.
10:25:35 <byorgey> ah, sounds like fun
10:25:35 * pumpkin unravels bos
10:25:51 <bos> byorgey: and you are the handiest expert who understands the concerns of mere mortals i could think of :-)
10:26:06 <byorgey> hehe, well, I'm happy to try to help
10:26:34 <bos> byorgey: so i have a classic instance of a function whose return type should depend on its input.
10:26:47 <bos> pipeline :: (Request a, Response b) => [a] -> IO [b]
10:26:53 <byorgey> ok
10:26:59 <bos> but I know that for any a, there can only be one b
10:27:02 <byorgey> right.
10:27:08 <bos> now MPTCs and fundeps solve this problem tidily.
10:27:12 <pumpkin> [a] -> IO [Function a]
10:27:35 <bos> pumpkin: AAAHHHH.
10:27:49 * pumpkin runs away in fear
10:27:52 <aristid> but with fundeps, you can have the dependency go both ways.
10:27:55 <aristid> so fundeps win.
10:28:10 * Saizan wonders what bos has tried up to now
10:28:23 <pumpkin> if you only want a one-way dependency, you typically have a function, and that's clearer to write as a function than a relation
10:28:31 <pumpkin> but sometimes a relation is more meaningful
10:28:34 <bos> i only need a one-way dep.
10:28:36 <byorgey> class Request a where  type Response a :: *  ...
10:28:38 <bos> in this instance.
10:28:50 <byorgey> then what pumpkin said
10:29:01 <pumpkin> s/Function/Response/
10:29:02 <aristid> i have something very similar, but two-way: class Transaction a b | a -> b, b -> a
10:29:13 <pumpkin> (Request a) => [a] -> IO [Response a]
10:29:31 <bos> so 
10:29:33 <pumpkin> instance Request Int where type Response Int = Bool; ...
10:29:36 <byorgey> right, or I imagine pipeline might even be a method of the Request class?
10:29:43 <bos> type family Foo req resp :: * -- ???
10:30:00 <pumpkin> bos: it might make more sense to build it into the typeclass as byorgey said
10:30:06 <pumpkin> but if it isn't married to the typeclass and you need it elsewhere
10:30:07 <bos> type instance Foo PingRequest PingResponse
10:30:09 <pumpkin> then yeah, as you wrote
10:30:10 <Saizan> the response type is the result of the family
10:30:39 <Saizan> type family Foo req :: *; type instance Foo PingRequest = PingResponse
10:30:40 <byorgey> bos: you would want  type family Foo req :: *;  type instance Foo PingRequest = PingResponse
10:31:18 <Saizan> type families is for when you /don't/ want to write your functions as relations :)
10:31:22 <Bynbo7> aristid: what's the rest of the class do? 
10:31:24 <bos> byorgey: yeah
10:31:37 <bos> so now i have
10:31:39 <bos> pipe :: (Request a, Response (Foo a)) => Connection -> [a] -> IO [Foo a]
10:31:49 <bos> for which i need FlexibleContexts
10:31:53 <pumpkin> hmm, is Response a separate class?
10:31:57 <bos> yes it is
10:32:02 <pumpkin> it might pay to tie them up, if possible
10:32:02 <bos> though it doesn't have to be
10:32:09 <byorgey> oh, I see
10:32:17 <aristid> Bynbo7: well, the actual class looks like this (wait a second)
10:32:21 <pumpkin> nothing wrong with FlexibleContexts really
10:32:49 <bos> this area of haskell might be powerful, but it's tremendously confusing.
10:32:56 <aristid> Bynbo7: class (AsQuery r, ResponseIteratee a) => Transaction r a | r -> a, a -> r
10:33:03 <Bynbo7> hey.... this looks like it might be a good way for me to possibly be able to solve my database table difinitions being well types :)
10:33:07 <Bynbo7> typed*
10:33:19 <byorgey> bos: yes, that looks fine, except I would make Foo an associated type of the Request class, instead of a stand-alone type family
10:33:25 <Bynbo7> aristid: i don't suppose this is for takusen is it?
10:33:34 <aristid> Bynbo7: no, it's for my amazon aws bindings.
10:33:43 <Bynbo7> ah, rightio
10:33:44 <byorgey> bos: that way you are guaranteed that every instance of Request has a response type
10:33:59 * Bynbo7 needs moar takusen experts
10:34:04 <aristid> Bynbo7: what's takusen?
10:34:07 <bos> byorgey: hmm, need to figure out what that means :-)
10:34:19 <bos> i mean, i understand what you just said, but i don't know how to write it.
10:34:23 <Bynbo7> aristid: oleg's iteratee based database framework
10:34:30 <aristid> Bynbo7: lol!
10:34:33 <byorgey> bos: you just do this:   class Request a where  type Foo a :: *  ... (rest of the class)
10:34:53 <byorgey> bos: and then to make an instance you write    instance Request PingRequest where  type Foo PingRequest = PingResponse  ...
10:35:14 <aristid> Bynbo7: is it typical oleg? :P
10:35:41 <Bynbo7> aristid: what, brilliant and impossible to fully understand? quite possibly :P
10:36:10 <aristid> Bynbo7: yes, brilliant and impossible to understand are typical attributes of his work :)
10:39:05 <bos> byorgey: well i have that half-working, and now i've tied myself into another knot :-)
10:39:05 <aristid> but it's got excellent googleability
10:39:06 <Saizan> nice, the synopsis haddock thingie expands to something larger than my screen
10:39:15 <byorgey> bos: ok, what's that?
10:39:21 <Saizan> http://hackage.haskell.org/packages/archive/Takusen/0.8.6/doc/html/Database-Enumerator.html <- for this
10:39:42 * hackagebot graphs 0.2 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.2 (EdwardKmett)
10:39:59 <mzero> yup - I should figure out some way to handle that case.... sigh!
10:40:05 <Bynbo7> Saizan: it's a godsend in disguise, trust me :P
10:40:08 <aristid> Bynbo7: wow, takusen got relatively much documentation
10:40:15 <Bynbo7> i should read that fully this weekend
10:40:23 <bos> byorgey: http://hpaste.org/43201/type_family_fun
10:40:34 <bos> byorgey: that fails to typecheck
10:40:57 <pumpkin> bos: you don't have an a in there
10:41:07 <pumpkin> it has no way of figuring out the input to the type function
10:41:21 <Saizan> Bynbo7: i've written functions with types scarier than those :P
10:41:33 <pumpkin> recvResp :: (Req a) => Connection -> a -> IO (Bar a) maybe?
10:41:56 <bos> pumpkin: but that's what i tried with the dummy witness valude
10:42:00 <bos> oops, value
10:42:12 <pumpkin> oh, but the witness is also a Bar a
10:42:18 <byorgey> make the witness value of type a
10:42:19 <bos> ah
10:42:20 <pumpkin> it needs to be an a, and has to be constrained somewhere
10:42:34 <byorgey> you may need to enable ScopedTypeVariables for this to work
10:42:40 <edwardk> you can't get there from here you have a type family, so the type signature of recvResp is ambiguous
10:42:45 <edwardk> it doesn't know which Req to use
10:42:49 <edwardk> you need a data family
10:42:51 <Saizan> and recvResp needs to take withness too
10:43:07 <byorgey> true, a data family might be the way to go instead
10:43:11 <aristid> fundeps can go both ways
10:43:22 <pumpkin> aristid: it still couldn't determine this one
10:43:26 <bos> zomg
10:43:35 <aristid> pumpkin: even with bidi fundeps?
10:43:35 <bos> mai hed asplode
10:43:38 <edwardk> you can make it a newtype family so its easy
10:43:43 <pumpkin> with a Fundep, you'd have (Req a b) => Connection -> IO b
10:43:43 <edwardk> er i mean cheap
10:43:53 <pumpkin> aristid: yeah, you could, but he said he didn't want bidirectional
10:43:59 <aristid> pumpkin: oh, where's the a going?
10:44:10 <pumpkin> aristid: that's the point, it isn't in the type signature here
10:44:16 <pumpkin> it wouldn't be with fundeps either
10:44:26 <aristid> pumpkin: it was there a few minutes ago
10:44:33 <pumpkin> yeah, someone eated it
10:44:35 <aristid> recvResp :: (Req a) => Connection -> a -> IO (Bar a)
10:44:38 <aristid> you ated it
10:44:50 <bos> actually, i don't have a problem if it is bidirectional, i just thought i didn't need that.
10:44:54 <bos> apparently i was wrong.
10:44:56 <aristid> so it would be recvResp :: Req a b => Connection -> a -> IO b
10:44:58 <Saizan> aristid: that's what pumpkin suggested to fix the issue
10:45:13 <Saizan> aristid: at which point type families would work already
10:45:27 <aristid> Saizan: i would just use bidi fundeps :P
10:45:29 <edwardk> you could hide the dangerous witness by using Tagged
10:45:53 <Saizan> aristid: i think we've understood that by now :)
10:45:57 <edwardk> recvResp :: Req a => Connection -> Tagged a (IO (Bar a)) â€” but thats pretty hideous. hrmm, do i need a TaggedT?
10:46:14 <aristid> Saizan: i think they're cool, so i have to repeat it every 2 minutes.
10:46:16 <bos> the current code is up here https://bitbucket.org/bos/riak-haskell-client
10:46:30 <aristid> edwardk: haha, TaggedT
10:46:39 <pumpkin> TracerT
10:46:58 <byorgey> bos: which file(s)?
10:47:25 <edwardk> Control.Monad.Trans.Tagged ? =)
10:47:26 <bos> byorgey: the most obvious places to start are:
10:47:27 <bos> https://bitbucket.org/bos/riak-haskell-client/src/e1cd5c3c5376/src/Network/Riak/Pipeline.hs
10:48:00 <bos> byorgey: and ...
10:48:01 <bos> https://bitbucket.org/bos/riak-haskell-client/src/e1cd5c3c5376/src/Network/Riak/Connection/Internal.hs#cl-154
10:48:25 <bos> so that code is all type safe, but you have to be very explicit about what you want, and it's easy to get wrong.
10:48:40 * aristid feels the strong urge to say "bidi fundeps"
10:48:42 <bos> in particular, you can mismatch the request and response types for the pipeline functions
10:48:56 <byorgey> bos: right.
10:48:58 <bos> aristid: thanks, i already know how to use those.
10:49:13 <aristid> bos: cool. but for some reason you prefer type families?
10:49:24 <bos> aristid: think of it as a learning exercise.
10:49:50 <pumpkin> type families are nicer if you have a function relationship, in my opinion :)
10:49:51 <byorgey> bos: so is it possible to have two different request types with the same response type?
10:50:03 <aristid> pumpkin: which does not really apply here :P
10:50:30 <bos> byorgey: no, there's a one-to-one mapping.
10:51:03 <byorgey> bos: ok. so I think you really want to express the one-to-one mapping in the type system, because of things like the type of getResponse.
10:51:11 <aristid> i think type families simply cannot model one-to-one mappings.
10:51:14 <byorgey> it only mentions the response type.
10:51:21 <bos> byorgey: actually, i slightly misspeak. any request could have an ErrorResponse or the proper response.
10:51:35 <byorgey> and ErrorResponse is a different type?
10:51:40 <bos> yes it is.
10:51:58 <bos> now, i could handwave around that and just throw an exception and forget about it.
10:51:58 <aristid> but there is only one ErrorResponse type?
10:52:20 <lispy> cdsmith++
10:52:26 <lispy> http://cdsmith.wordpress.com/2011/01/21/a-recap-about-cabal-and-haskell-libraries/
10:52:27 <bos> so the ErrorResponse type doesn't necessarily need to be exposed. (but being a good citizen, i probably should.)
10:52:52 <aristid> bos: you could always use Either?
10:53:32 <bos> byorgey: i agree, getResponse should probably be :: Request a => Connection -> IO (Response a)
10:53:51 <bos> i've just little idea how to express that with the new type mushrooms that keep cropping up.
10:53:58 <aristid> where's the a coming from?
10:54:12 <byorgey> bos: ok, well, my point is, that doesn't really help.  the only thing the type system has to go on there when unifying that with something else is  Response a.
10:54:58 <bos> byorgey: but usually, if you're calling getResponse, it's immediately after sendRequest. i could simply not expose those publicly.
10:55:00 <byorgey> bos: type families are not injective (there could in theory be multiple Requests with the same Response) so,  knowing Response a = foo  doesn't help you figure out what a is
10:55:20 <bos> byorgey: instead have a roundtrip :: Request a => Connection -> a -> IO (Response a)
10:55:30 <bos> and pipeline :: [a] -> IO [Response a]
10:55:45 <byorgey> yes, that would work a lot better if you want to do it with type families
10:55:49 <bos> which i'm perfectyly happy to do.
10:56:24 <byorgey> otherwise you will have to go through lots of contortions with dummy parameters, scoped type variables, etc. etc...
10:56:31 <byorgey> bos: actually, there's one other thing to ask about
10:56:44 <bos> byorgey: :-)
10:57:24 <byorgey> bos: are the response types generally pre-existing types which are used elsewhere?  Or are they usually declared solely in order to be the responses corresponding to certain request types?
10:57:48 <bos> byorgey: both the request and the response types are generated by a compiler from a descriptor file
10:58:06 <bos> so they're pre-existing types.
10:58:32 <byorgey> ah, ok. then you can't really make the response types associated data families (which are injective, unlike type families)
10:59:05 <byorgey> although I guess you could make them associated newtypes, like edwardk suggested, it would just require some newtype constructor wrapping and unwrapping
10:59:28 <byorgey> sorry, I agree this is confusing.
10:59:42 <bos> yeah, i'm lost :-)
10:59:48 <aristid> sorry, i don't get the point of all this.
11:00:12 <bos> aristid: the point is to enhance my understanding.
11:00:27 <bos> which, alas, is not really happening just yet.
11:00:37 <aristid> bos: how about using an example where type families are actually appropriate, when you are trying to enhance your understanding?
11:00:56 <byorgey> bos: have you read "fun with type functions"?
11:01:02 <bos> aristid: well, i don't yet know where they are or are not appropriate.
11:01:06 <bos> byorgey: a while back.
11:01:40 <aristid> bos: i think newtype families sound like a damn hacky solution to this problem.
11:01:46 <byorgey> aristid: I agree.
11:01:48 * hackagebot tagged 0.2 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.2 (EdwardKmett)
11:02:25 <byorgey> I also agree that type families do not seem like a great fit for this, UNLESS you change the exposed function types to "round-trip" ones that take a request and give back a response
11:02:50 <aristid> edwardk: that was fast!
11:02:51 <byorgey> in which case what you had in that hpaste should work just fine.
11:03:07 <edwardk> aristid: that was just factoring Proxy and Tagged into two modules
11:03:18 <edwardk> aristid: i'm debating about how to proceed on Tagged =)
11:03:20 <aristid> edwardk: oh, i thought you introduced TaggedT already.
11:03:52 <edwardk> aristid: i almost did, but was debating about adding the transformers dependency
11:03:58 <edwardk> yeah i'll do it, brb
11:06:55 <edwardk> its kind of annoying because ideally i'd just use TaggedT s Identity as the Tagged version, but Tagged currently provides a ton of (fairly useless) instances
11:07:40 <bos> byorgey: so bidi fundeps?
11:07:41 <aristid> byorgey: not having really used data families yet... is my mental model of them as "open GADTs" somewhat accurate?
11:08:01 <edwardk> aristid: 'bidi fundep' =)
11:08:24 <aristid> edwardk: sounds cute, doesn't it? :D
11:08:25 <byorgey> bos: on one condition: we all agree that "bidi" shall never be uttered again
11:08:35 <bos> byorgey: oh?
11:08:39 <byorgey> hehe =)
11:08:44 <aristid> byorgey: what's the official name?
11:08:57 <byorgey> bidirectional?
11:09:09 <aristid> but bidi is just an abbreviation of bidirectional
11:09:21 <byorgey> don't mind me, I am just an abbreviation-hating snob
11:09:29 <byorgey> 'fundeps' makes me uncomfortable too ;)
11:09:37 <aristid> byorgey: i think i'm allowed to abbreviate, with my left hand in a cast :P
11:09:44 <byorgey> ah. I suppose so. =)
11:11:10 <aristid> byorgey: you should obviously change your nickname to brent_yorgey ;)
11:11:20 <byorgey> haha, good point!
11:12:09 <brent_abraham_yo> hmm, apparently there is a length limit on nicks =(
11:12:13 <aristid> hahaha
11:12:53 <aristid> brent_abraham_yorgey advises: say "bidirectional functional dependency", not "bidi fundep"
11:15:50 <Evious> I have an awesome idea. documented.hackage.haskell.org
11:16:04 <Evious> Automatically filtering packages that don't fulfill a certain required amount of documentation. :)
11:16:48 <Evious> Maybe another one, filtered to only contain packages whose documentation lies in papers, too.
11:19:09 <rkrzr> hello haskellers, I'm trying to install a local package via "cabal install" but it keeps bugging me about requiring root permissions, which seems wrong, is there a way around this?
11:19:23 <mm_freak_> rkrzr: --user
11:19:43 <dcoutts_> rkrzr: on a unix system or on windows?
11:19:47 <rkrzr> unix
11:19:54 <aristid> huh, isn't --user the default?
11:20:02 <dcoutts_> aristid: yes
11:20:04 <aristid> rkrzr: which version of ghc and cabal?
11:20:06 <mm_freak_> it should, but apparently on some systems it isn't
11:20:25 <rkrzr> so the exact error is c2hs: permission denied
11:20:38 <dcoutts_> ohh, ok
11:20:42 <rkrzr> cabal version 0.8.2
11:20:53 <rkrzr> ghc 6.12.1
11:20:55 <dcoutts_> so not a cabal permission problem, a c2hs problem
11:21:01 <rkrzr> ah ok
11:21:13 * dcoutts_ tries to recall the cause of that error
11:21:23 <dcoutts_> c2hs is not displaying the full error message sadly
11:21:35 * dcoutts_ notes that this is his own fault
11:22:19 <dcoutts_> rkrzr: it's something to do with one of the input files to c2hs
11:22:35 <dcoutts_> rkrzr: you can run cabal build -v to see how cabal is calling c2hs
11:22:56 <rkrzr> dcoutts_, ok I'll do that
11:22:56 <dcoutts_> check if any of the files it is passing it are suspicious, e.g. missing, or wrong location
11:29:08 <rkrzr> dcoutts_, hm the files seem to be fine, the error looks like this: http://pastebin.com/FyA7Y7BY
11:30:21 <dcoutts_> rkrzr: you can run c2hs manually with those params and the extra flag: --dump=trace
11:30:36 <rkrzr> ok, I'll try that
11:37:37 <SKK> hi
11:37:49 <SKK> Is there a way for a haskell module to take an argument?
11:38:08 <SKK> Like, what do you do if you want a datatype to be instantiated later with anything?
11:39:11 <xarch> hi, I'l having problem with bialgebras and all that stuff (http://paste.awesom.eu/utN&hl=haskell), I can't use metamorphisms from lists
11:39:15 <xarch> I'm
11:39:29 <xarch> *
11:39:45 <Bynbo7> SKK: eh? if you hate data Foo a = Bar a a | Baz a, then if you wnat a to be Int, you just use Foo Int
11:39:48 * gwern notes idly that bialgebras sound tasty. probably go well with cocktail sauce
11:40:45 <xarch> do you have an idea?
11:40:55 <xarch> of how to fix that
11:42:01 <Bynbo7> SKK: for example: x :: Foo Int; x = Bar 5 2
11:42:19 <Bynbo7> SKK: does that help at all?
11:42:19 <SKK> well, let's say I want to write a prover, then it depends on the signature.  but obviously i don't want to give it as an argument to every function.  i want it to be an argument with which the whole module could be instantiated -- like a local parameter
11:42:39 <Bynbo7> eh?
11:42:42 <gwern> SKK: sounds like the reader monad
11:42:45 <mreh> SKK reader monad
11:42:47 <mreh> dang
11:42:51 <gwern> mreh: jinx!
11:42:54 <Bynbo7> ha
11:42:56 <EvanR-work> SKK: reader monad
11:42:56 <SKK> is that the standard solution to this?
11:43:00 <EvanR-work> i win
11:43:09 <mreh> ....
11:43:13 <gwern> mreh: I would've been even faster but I was pondering whether to mention implicit variables, a global IORef, or other solutions
11:43:18 <mreh> haha, you said my name
11:43:24 <SKK> what's implicit variables?
11:43:33 <gwern> SKK: it is better not to know
11:43:35 <EvanR-work> global IORef? isnt that the goto of haskell
11:43:37 <SKK> and do I really need a monad?
11:43:53 <mreh> SKK not unless you don't want to pass it round as a parameter
11:43:58 <gwern> SKK: well, you could just pass the environment around. but that's what the reader monad wraps up
11:44:01 <Bynbo7> >  let foo = ?x + 7 in let x = 4 in foo
11:44:03 <lambdabot>   mueval-core: internal error: PAP object entered!
11:44:03 <lambdabot>      (GHC version 6.12.3 f...
11:44:10 <Bynbo7> o.O
11:44:15 <SKK> ok.  I do NOT want to pass the whole context around
11:44:21 <SKK> definitely not
11:44:21 <EvanR-work> reader == context
11:44:27 <SKK> ok
11:44:31 <SKK> why is it called reader then?
11:44:36 <EvanR-work> because its read only
11:44:39 <SKK> why not like "the context monad" or something?
11:44:39 <gwern> Bynbo7: ...ok, that's not good. that looks like someone installed mueval with profiling
11:44:40 <mreh> hysterical reasons
11:44:50 <gwern> SKK: symmetry with the writer monad
11:45:02 <mreh> is that really why?
11:45:10 <EvanR-work> hysterical raisens
11:45:13 <rkrzr> dcoutts_, c2hs seems to be able to load the file, I'm not really sure where the problem lies, maybe you have another idea what I should try? http://hpaste.org/43203/c2hs_problem
11:45:43 <mreh> drop all this monad nonsense, call it by it's real name ((->) e)
11:46:00 * hackagebot tagged-transformer 0.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.1 (EdwardKmett)
11:46:02 <EvanR-work> warm fuzzy thing
11:46:08 <SKK> ok... but what does it really do?  give me a local global variable that everyone can read?
11:46:23 <mreh> SKK, it just saves you boiler plate really
11:46:23 <EvanR-work> a value, not a variable
11:46:33 <SKK> yeah, that's good 
11:46:38 <SKK> another question
11:46:50 <mreh> if you want a variable value, you need the state monad
11:46:55 <SKK> thanks, i'll read about this monad
11:47:02 <gwern> state = reader+writer, iirc
11:47:16 <EvanR-work> you cant read back what you wrote with writer
11:47:21 <mreh> gwern: nah
11:47:39 <mreh> e /= w
11:48:07 <SKK> what's the standard way to make a signature?  if I write data Alphabet = [(String, Integer)] for the symbols and arity, how do I then make a datatype of terms over this?  it looks like a dependent type!
11:48:10 <gwern> mreh: what?
11:48:15 <mreh> and that's a watertight proof
11:48:31 <mreh> you can't read back what you wrote
11:48:39 <mreh> that's a much better explanation
11:48:49 <SKK> i mean type not data
11:49:03 <Bynbo7> you can't make types based on values
11:49:23 <SKK> surely, you jest!
11:49:51 <Bynbo7> well, in a sense all types are made from values. but you can't decide what type something is based on its value
11:49:56 <EvanR-work> SKK: string integer? maybe you just want to encode those strings as constructors for a type, and make an Enum instance to assign the numeric values
11:50:10 <monochrom> "data Alphabet = [(String, Integer)]" is a syntax error
11:50:27 <SKK> monochrom: see subsequent line
11:50:34 <EvanR-work> data Alphabet = A | B | C deriving (Enum)
11:51:17 <SKK> but I don't want to put the constructors in the source file.  rather i want to make a type of signatures, and then define the type of terms over a signature
11:51:20 <mreh> way confused now
11:51:26 <monochrom> "a datatype of terms" depends on what you want those terms to look like.
11:51:45 <EvanR-work> data Signature = 
11:51:50 <monochrom> but why don't I take liberty in liberally interpreting open questions?
11:53:07 <monochrom> "terms" means lambda terms. always. data Term = Atom Alphabet | BoundVar Int | Lambda Term | Apply Term Term.  The Int there is for de Bruijn numbering.
11:53:22 <gwern> o.0 I managed to cut an IRC corpus from 182MB to 157MB just by using grep to filter out a single bot's name
11:53:51 <SKK> well, it's inductive.  if ("c",0) is in sig:Alphabet, then ("c",[]) is in (Terms sig).  if ("f",n) is there, and t1,..,tn are in (Terms sig), then ("f",[t1..tn]) is in (Terms sig).
11:53:53 <Bynbo7> do we know this bot?
11:54:07 <SKK> by the way, it's first order, so no need for debruijn
11:54:11 <joe1> Haskell newbie ? - I'd like to add time concepts to a function, not the execution time, but a time I specify. Say x+y takes 1s. If I call it twice, I would like to see a result of 2s stored somewhere. Is this possible with Haskell? So if I change the time to 2s, the answer would be 4s. 
11:54:15 <gwern> Bynbo7: fortunately, no
11:54:43 <EvanR-work> joe1: maybe you want to use a profiler
11:55:10 <SKK> but i agree, every term is a lambda term
11:55:13 <mauke> joe1: well, you could do something like that
11:55:24 <mauke> I'm thinking of a Writer monad here
11:55:26 <mauke> or maybe State
11:55:35 <Bynbo7> joe1: it's possibly... but it is not something a newbie should be doing. your language also seems to suggest you don't quite unde3rstand what purity and immutability mean when it comes to haskell :)
11:55:41 <monochrom> you can delete "BoundVar Int | Lambda Term |" then
11:55:56 <SKK> hehe
11:56:15 <Philonous> joe1: Sounds like something you would use arrows for 
11:56:32 <joe1> well, i'm wondering if time has to be a structure. I've programmed similar ideas in OO, just looking to map.
11:56:35 <Bynbo7> joe1: do you actually want to time things?
11:56:50 <gwern> filtering "has quit" got me another 5MB -_-
11:56:57 <joe1> yep, really the app is timing paths in a circuit
11:56:58 <Bynbo7> or more record how long things take in a symbolic manner
11:57:11 <SKK> so just to be clear.  if a signature is specified during run-time, there's no way to have terms over that signature be a datatype.  correct?
11:57:15 <Bynbo7> because the latter is much easier i think
11:57:25 <EvanR-work> sounds more like counting than timing
11:57:50 <Bynbo7> SKK: do you mean a haskell signature?
11:57:55 <gwern> "faggot" reclaimed 1MBÂ o.0
11:57:59 <SKK> no, a first order one
11:58:30 <Bynbo7> SKK: so you're not trying to produce haskell type signatures at runtime. i misunderstood
11:58:59 <joe1> if i have two NAND gates connected and each takes 30ps to propagate, the total path time would be 60ns
11:58:59 <SKK> gwern: haha
11:58:59 <SKK> funny
11:59:00 <gwern> SKK: or sad, depending on perspective
11:59:01 <joe1> but it can be dependent on value. I just wanted to start with basic timing accountability.
11:59:01 <SKK> it's not just from haskell I hope?
11:59:04 <EnglishGent> hello :)
11:59:19 <EvanR-work> joe1: yeah, thats counting
11:59:21 <bos> byorgey: found a new knot to tie myself in :-)
11:59:25 <SKK> thanks anyway, i'll read about this monad
11:59:37 <gwern> SKK: don't worry, an entirely different network from freenode
11:59:51 <gwern> hm, filtering joins cut 4MB
11:59:54 <byorgey> bos: heh, what now? =)
11:59:58 <Bynbo7> joe1: i believe what you want to do is create a datatype which represents the circuit, and then traverse that to find the runtime
12:00:12 <bos> byorgey: so i now have a nice pipeline function:
12:00:19 <bos> pipeline :: (Exchange req resp) => Connection -> [req] -> IO [resp]
12:00:28 <byorgey> ok
12:00:36 <bos> so if i do a series of gets, i get back a series of GetResponse values
12:00:37 <aristid> bos: yay \o/
12:00:56 <dcoutts_> rkrzr: sorry, back later
12:01:08 <bos> byorgey:  wondering how i could do heterogeneous sends and receives there
12:01:29 <rkrzr> dcoutts_, I think I'm on the right track, there seems to be a problem with a header file, thanks again!
12:01:31 <monochrom> joe1: http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf  the running example is a simple evaluator, section 2.3 adds "count how many divisions are done"
12:01:42 <bos> i.e. have pipeline accept a mixture of GetRequest and PutRequest values, and give me back values of the correct types
12:02:03 <byorgey> yeesh
12:02:22 <aristid> it's getting more interesting :)
12:02:28 <bos> byorgey: yeah. it doesn't really matter, just would be nice to have.
12:02:35 <EvanR-work> are you sure about that ;)
12:02:39 <bos> byorgey: but i'm thinking it ain't gonna happen.
12:03:04 <EvanR-work> Either GetRequest PutRequest?
12:03:14 <byorgey> bos: it would require some sort of type-level-lists-of-types hackery, and probably also switching back to type families
12:03:19 <Bynbo7> joe1: could you repeat what you said in PM here?
12:03:23 <bos> byorgey: yeah. ugh.
12:03:47 <joe1> Sorry, not good with irc.
12:03:54 <Bynbo7> s'all good :)
12:03:57 <joe1> Yes, that is reasonable, but am I able to traverse a structure like it's an object? I thought Haskell types weren't like objects.
12:04:21 <EvanR-work> counting stuff in a tree is very easy in haskell
12:04:23 <Bynbo7> joe1: what do you mean by not like objects?
12:04:24 <mauke> "like it's an object"?
12:04:30 <aristid> bos: i have a very ... well, not entirely nice solution, but it might work
12:04:34 <EvanR-work> counting stuff in a graph.....
12:05:06 <aristid> bos: pipeline2 :: (Exchange a1 b1, Exchange a2 b2) => (a1, a2) -> IO (b1, b2)
12:05:07 <bos> aristid: oh really?
12:05:09 <monochrom> you don't need objects to traverse anything
12:05:09 <joe1> by not like objects I just mean that Haskell seems to me like a large netlist
12:05:13 <Bynbo7> data Tree = Node Tree Tree | Leaf; depth Leaf = 0; depth Node l r = a + max (depth l) (depth r)
12:05:16 <bos> aristid: ah
12:05:28 <aristid> bos: yeah, it sucks :)
12:05:33 <monochrom> traversing data has been done since 1950s
12:05:35 <bos> :-)
12:05:40 <Bynbo7> data Tree = Node Tree Tree | Leaf; depth Leaf = 0; depth (Node l r) = a + max (depth l) (depth r) -- fix'd!
12:05:52 <EvanR-work> joe1: you know, lists can be cyclic ;)
12:06:03 <Bynbo7> joe1: haskell is in many ways all about data traversal
12:06:11 <joe1> traversing the static structure correct, but the path delay may differ based on the values input
12:06:32 <byorgey> preflex: seen poucet
12:06:33 <preflex>  poucet was last seen on #haskell 9 days, 4 hours, 28 minutes and 42 seconds ago, saying: I talked to the guy who I had been forward chatting with
12:06:36 <Bynbo7> well keep a record of those values too
12:06:41 <monochrom> "the values input" are just more parameters to your functions
12:06:44 <aristid> bos: or you could make a Monad to thread that stuff
12:06:51 <EvanR-work> joe1: if you are measuring the 'time' between signal at A reaching B, then you want a graph traversal algorithm
12:06:54 <joe1> so a 0 to 1 transition may take more time than a 1 to 0
12:07:08 <EvanR-work> there are graph libs
12:07:25 <joe1> hmmm
12:07:31 <EvanR-work> 'total time' doesnt make sense
12:07:38 <aristid> somehow a voice with a very bad german accents reads everything written here (in my head). it's pretty funny
12:07:43 <EvanR-work> sequential logic circuits for instance are cyclic
12:07:44 <Bynbo7> data Circuit = And Circuit Circuit | Or Circuit Circuit | Not Circuit | Val Bool
12:07:53 <monochrom> So it seems that the biggest damage of most oop schools is brainwashing that you need objects to do anything at all.
12:07:58 <joe1> i would assume though that would just traverse the structure.
12:08:04 <EvanR-work> monochrom: or classes
12:08:11 <joe1> it's hard to get out of objects.
12:08:19 <EvanR-work> joe1: yes
12:08:30 <sproingie> i suggest that "pervasive globally-accessible state is needed" is the biggest damage
12:08:34 <EvanR-work> whats wrong with traversing stuff
12:08:37 <Bynbo7> joe1: basically, you're thinking about things all wrong :)
12:08:40 <sproingie> ironically OOP was supposed to get you away from it
12:08:43 * Bynbo7 goes to sleep
12:08:50 <joe1> yes, i'm trying to avoid state to really learn haskell.
12:08:59 <joe1> lol
12:09:14 <EvanR-work> evaluating the value of f circuit pointA pointB doesnt need state
12:09:15 <joe1> ok, let me phrase it another way
12:09:25 <EvanR-work> oh, add input in there
12:09:42 <joe1> say i have an inverter
12:09:45 <sproingie> sometimes you can't get away from it because the API you're using is so stateful and there's no alternative
12:09:53 <sproingie> OpenGL for example is ridiculously stateful
12:09:59 <EvanR-work> when in doubt use IO
12:10:00 <EvanR-work> ;)
12:10:06 <joe1> when I pass a 1 in, the time is 1ns, when i pass a 0 the time is 2ns.
12:10:08 <sproingie> shaders aren't, but the rest of GL is
12:10:18 <aristid> bos: hmm, maybe Applicative is better than Monad.
12:10:30 <joe1> do i have to create two different structures for the two options of input?
12:10:42 <EvanR-work> joe1: input is a value
12:10:47 <EvanR-work> the circuit is a value
12:11:22 <aristid> bos: the idea would be something like this: pipeline ((,) <$> getRequest <*> putRequest)
12:12:31 <joe1> EvanR-work: ok. so everything is a value?
12:12:42 <EvanR-work> no
12:13:02 <EvanR-work> the general structure of your program is basically a bunch of types
12:13:27 <joe1> EvanR-work: I'd assume I'd have a type Inv that would be applied a value of 0 or 11.
12:13:32 <joe1> sry 1
12:13:36 <EvanR-work> you are asking for a function with this type Circuit -> Node -> Node -> Input -> Time
12:13:54 <joe1> i c
12:14:28 <joe1> but as the values are applied to the types, the Time returned could be different.
12:14:36 <bos> aristid: yeah
12:14:49 <joe1> Each value applied has a causal dependence on the previous.
12:14:51 <EvanR-work> joe1: yes... Time is a function of all that stuff
12:15:11 <EvanR-work> unless you have a memory-ful circuit?
12:15:18 <EvanR-work> then you need state
12:15:29 <EvanR-work> Circuit -> Node -> Node -> Input -> State -> (Time, State)
12:15:47 <joe1> I could, but it sounds like I'm having enough trouble with basic asynchronous logic.
12:16:14 <EvanR-work> circuits with memory means you need state
12:16:20 <monochrom> @type uncurry
12:16:21 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:16:24 <joe1> yes, i agree with that.
12:16:37 <monochrom> @type (&&)
12:16:38 <lambdabot> Bool -> Bool -> Bool
12:16:45 <joe1> but for asynch circuits seems like i need state as well.
12:16:54 <EvanR-work> if you want to simulate a circuit in parallel, well youll need a quite more sophisticated model
12:17:30 <edwardk> joe1: modeling asynchronous circuits?
12:18:01 <joe1> timing of async circuits. I hope someday to grow up to understand haskell enough to do sync as well
12:18:15 <edwardk> joe1: i have a small library for that around here somewhere that i worked up a year or two back, just to play with them
12:18:33 <edwardk> i only have basic asynchronous circuits with isochronic forks
12:18:51 <edwardk> and some code for hazard detection
12:19:04 <joe1> i'm just getting started in haskell, but have imperitave programming experience
12:19:21 <EvanR-work> even imperative is hard for this purpose
12:19:40 <EvanR-work> you need to divide time into little pieces
12:19:41 <edwardk> then in that case i'd recommend beating on it for yourself for a while, my approach is likely to warp your approach to haskell ;)
12:19:57 <joe1> EvanR-work: definitely. Haskell seems more like a natural fit for circuits, which is why I started looking into it
12:20:21 <EvanR-work> each node has a voltage at a given time, and in general it depends on the last n values of all the other nodes in the circuit
12:20:28 <joe6> It appears that the complicated/tricky stuff of haskell are the ghci error messages (especially when dealing with generics), generics modules and template haskell.
12:20:30 <joe1> correct
12:20:38 <monochrom> http://hpaste.org/43204/introduction_to_gates
12:20:43 <joe6> I am wondering why was haskell not implemented in haskell?
12:20:48 <EvanR-work> is it?
12:20:51 <edwardk> joe6: it is
12:20:51 <EvanR-work> er it is
12:21:06 <EvanR-work> generics modules?
12:21:08 <monochrom> you better wonder why php is not implemented in php
12:21:09 <joe6> oh, cool..
12:21:29 <joe6> monochrom: condescending?
12:21:41 <joe6> so, is there a good place for haskell internals?
12:21:44 <dreixel> joe6: did you have a look at the haskell code I posted just after you left?
12:21:50 <monochrom> what condescending?
12:21:50 <edwardk> joe6: the rts commentary on haskell.org
12:22:08 <joe1> monochrom: perfect example
12:22:09 <joe6> dreixel: yes, it is awesome and I am still checking it out.
12:22:10 <edwardk> joe6: more condescending towards php performance than to you
12:22:25 <mauke> but I am php :-(
12:22:38 <joe6> edwardk: awesome. Thanks.
12:23:09 <edwardk> joe6: keep in mind that is only talking about the internals of ghc, but that is tantamount to the same thing ;)
12:23:34 <joe6> dreixel: while I was checking out your code, I had this idea that if haskell was implemented in haskell and as I can code in haskell I should be able to understand the internals
12:23:36 <joe1> in the code notzgate = Gate { function = not, timing = \b -> if b then 1 else 2 }
12:23:48 <dreixel> joe6: it's not that simple.
12:24:19 <dreixel> joe6: the source of GHC is a very large project and definitely not what I would recommend to a beginner.
12:24:29 <joe1> what does the \b do
12:24:29 <joe6> hence the question.
12:24:30 <mauke> \ -> is how you write functions
12:24:30 <mauke> b is the parameter
12:24:30 <mauke>  if b then 1 else 2 is the function body
12:25:02 <joe6> dreixel: i have a few questions on your code. but, I am doing my homework in trying to read up on the related stuff before spamming you with stupid questions, the answers of which I can get at.
12:25:17 <dreixel> it's ok
12:25:17 <joe1> mauke: great, thanks.
12:25:54 <joe6> dreixel: but, I guess that I have to bite the bullet at some point and atleast try to see what is in there? (I mean the ghc internals)
12:26:07 <joe1> that's really a great example. I'd eventually have to expand it to min, typ, max, but that is pretty straightforward.
12:26:29 <dreixel> joe6: looking won't harm. But I don't think it'll do you much good.
12:26:33 <EvanR-work> joe1 == joe6
12:26:34 <EvanR-work> ?
12:26:40 <joe6> does that help understanding things like template haskell and the generics internals.
12:26:44 <joe1> no
12:26:52 <joe1> joe1!=joe6
12:26:57 <joe6> no, joe1 /= joe6
12:26:59 <mauke> wait, there's two?
12:27:00 <EvanR-work> is that some clients idea of sick joke for default nicks
12:27:00 * sproingie wonders where the other four joes are
12:27:08 <joe1> i'll change my name
12:27:25 <dreixel> joe6: maybe, there are generics and template haskell there
12:27:26 <monochrom> just use a uuid.
12:27:29 <mauke> o_O
12:27:32 <dreixel> but there are certainly easier ways to understand that
12:27:41 <mauke> "i'll change my name" is harder to type than just changing your name
12:27:44 <joe6> dreixel: what are they?
12:28:05 <alpounet> reading the papers about them, for a start
12:28:27 <joe6> i was trying to read the generics paper and got lost in the first page.
12:28:31 <joe1> mauke: first time on irc, sry
12:28:35 <dreixel> joe6: which one?
12:29:03 <EvanR-work> the number after joe is the experience level
12:29:05 <joe6> the one on A Lightweight Approach to Datatype-Generic Rewriting
12:29:15 <dreixel> uhm.
12:29:21 <dreixel> not bad, but perhaps not the most up-to-date
12:29:29 <joe6> EvanR-work: I doubt it.. more like more active, maybe?
12:29:32 <dreixel> definitely good for an introduction to GP
12:29:41 <dreixel> but maybe not so practical anymore
12:30:04 <joe6> what do you recommend? i wanted to understand the theory behind the generics stuff.
12:30:12 <joe6> the syb papers were pretty good.
12:30:24 <joe6> there were very detailed and understandable. 
12:30:25 <dreixel> ohw, if you want the theory then you should read category-theoretical stuff
12:30:29 <dreixel> but I don't think you want that.
12:30:38 <dreixel> the syb papers are good at explaining syb
12:30:43 <dreixel> not so much the general concept
12:31:09 <joe6> i am not a mathematician and I was lost the few times to understand the CT stuff.
12:31:13 <monochrom> "you better wonder why php is not implemented in php" is criticism not condescending. if you set up a culture to classify criticisms as condescending, you will get a lame culture.
12:31:54 <dreixel> joe6: well, my own paper describes a library pretty similar to instant-generics, regular, and multirec. Maybe that can be helpful: http://dreixel.net/research/pdf/gdmh.pdf
12:31:57 <edwardk> if you're willing to step outside of haskell you might enjoy http://repository.upenn.edu/cis_reports/758/ which is a bit on how to support both generic programming and parametricity with a language extension
12:31:58 <dreixel> focus on the first parts
12:31:58 <fpga> Thanks everyone for the help - this should get me going
12:32:02 <joe6> monochrom: sorry, misinterpretation. it is harder to understand what the other person is trying to convey from a sentence.
12:32:08 <dreixel> bbl
12:32:28 <joe6> dreixel: ok, thanks will start working on your paper.
12:32:33 <EvanR-work> monochrom: like php culture
12:32:48 <EvanR-work> criticism is taboo
12:32:49 <joe6> edwardk: ok, thanks
12:34:58 <joe6> dreixel: what do you think about http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
12:36:03 <joe6> edwardk: that is a pretty good article that you sent. Thanks.
12:37:58 <gwern> one nice thing about haskell - we're all assholes. 'there's only *one* right way to do it, and this is it!' none of this post-mdoern hippy TIMTOWDI relativistic crap
12:38:32 <EvanR-work> TANSTAAFL
12:38:35 <joe6> dreixel: saw this sentence "many generic programming libraries of today still cannot compete
12:39:36 <joe6> with the Generic Haskell pre-processor, for instance.
12:39:38 <joe6> dreixel: and I am wondering why not just use the Generic Haskell pre-processor?
12:39:39 <gwern> I think the Generic Haskell pre-processor is limited to Haskell
12:39:56 <aavogt> joe6: -XGenerics?
12:40:23 <joe6> aavogt: sorry, what does -XGenerics do?
12:41:11 <aavogt> joe6: I'm not sure if that's the generic preprocessor you're talking about
12:41:13 <joe6> dreixel: I like your paper. I can understand it.
12:41:55 <joe6> aavogt: i do not understand. let me google -XGenerics and see what it pertains to.
12:42:44 <aavogt> joe6: it's part of ghc. A good resource for figuring out which library is useful is the review/paper "Comparing Datatype Generic Libraries in Haskell
12:42:45 <aavogt> "
12:43:19 <jmcarthur> gwern: actually, i've always seen haskell as kind of the perl of functional languages. there are a million ways to do things, and every feature under the sun is included
12:43:39 <gwern> jmcarthur: yeah, but we always have an opinion on which of the ways is best
12:43:58 <aavogt> gwern: is that we called gwern?
12:44:04 <aavogt> "we"
12:44:08 <gwern> naturally
12:44:09 <jmcarthur> i don't think that's so specific to haskell programmers ^_^
12:44:17 <gwern> as if we cared what the rest of you haskellers thought
12:45:38 <tac-tics> Haskell has such a powerful type system, the whole language loops around at infinity and ends up just above perl.
12:45:47 <ddarius> Screw generic programming.  Pattern calculus all the way.
12:46:32 <joe6> ddarius: what is that? 
12:46:40 <tswett> Is there a Haskell binding to C--?
12:46:45 <gwern> tac-tics: unfortunately for us, God defined 'language awesomeness' as a fixed-length int and that's what actually overflowed
12:48:15 <tac-tics> Indeed
12:48:58 <ddarius> @google "Delia Kesner" "First class patterns"
12:49:00 <lambdabot> http://portal.acm.org/citation.cfm?id=1520289
12:49:00 <lambdabot> Title: First-class patterns
12:49:05 <ddarius> @google bondi
12:49:06 <lambdabot> http://en.wikipedia.org/wiki/Bondi_Beach,_New_South_Wales
12:49:06 <lambdabot> Title: Bondi Beach, New South Wales - Wikipedia, the free encyclopedia
12:49:16 <ddarius> ... not exactly what I was going for.
12:49:21 <ddarius> @google Bondi Barry Jay
12:49:23 <lambdabot> http://www-staff.it.uts.edu.au/~cbj/
12:49:23 <lambdabot> Title: Barry Jay's Homepage
12:49:27 <joe6> dreixel: I really like your paper. Good job. It is very informative and I wish I had read it yesterday when you first recommended generics. Can you please add it to the hackage page of generics module?
12:49:40 <joe6> dreixel: This paper belongs in that hackage page. 
12:49:44 <tac-tics> And a language like coq is so awesome, it (ironically) never stops looping past infinity, leaving how awesome is really is completely undefined
12:50:04 <joe6> dreixel: It is a lot more easier to comprehend than the other paper.
12:50:49 <joe6> ddarius: thanks, will check it out.
12:51:24 <locks> what's C--?
12:51:51 <tswett> C-- is a programming language designed to be usable as a code generation target for compilers.
12:52:02 <tswett> I'd like to write a compiler.
12:52:17 <locks> what's stopping you? :)
12:52:51 <tswett> Not knowing whether or not there's a Haskell binding to C--.  :)
12:53:09 <tswett> Looks like there isn't, so I'm going to go and use LLVM instead.
12:53:19 <locks> oh, i see :P
12:53:59 <Saizan> is there an implementation of C--, even?
12:54:31 <tswett> I would be... somewhat surprised if there were not.
12:55:42 <joe6> ddarius: that is a very interesting topic. will read it in the next few hours. Thanks for the info.
12:58:27 <thoughtp1lice> there is QuickC--, but it is rather abandoned
12:58:57 <thoughtp1lice> GHC implements C--, but it has been tailored for GHC's usage and doesn't quite follow everything in the specs SPJ & NR published, etc
12:58:59 <keep_learning> http://hpaste.org/43208/log_binarysearch
12:59:17 <keep_learning> i am getting type error 
12:59:31 <keep_learning> how ever i thing i am returning Integer 
12:59:57 <keep_learning> but it says your are returning Int 
12:59:59 <keep_learning> any one
13:00:06 <keep_learning> kindly have a look 
13:00:09 <thoughtp1lice> tswett: so no, there's no binding to a C-- compiler of any sorts and QuickC-- isn't even written in Haskell
13:00:12 <thoughtp1lice> it's written in OCaml
13:00:42 <thoughtp1lice> and QuickC-- is probably the only other major implementation of C-- besides GHC, but QuickC-- never saw a lot of use from what I understand
13:00:46 * tswett nods.
13:00:50 <tswett> keep_learning: let me take a look.
13:01:05 <keep_learning> tswett: thank you
13:01:27 <tswett> Hm, what's that pastebin that executes your code?  Is it still alive?
13:01:42 <thoughtp1lice> tswett: it may be easier just to steal part of GHC's Cmm implementation, i.e. the datatypes and whatnot, you could also possibly steal the new LLVM backend for GHC, which already does the work of compiling the raw C-- GHC produces into LLVM bitcode
13:01:48 <shachaf> tswett: Presumably it is not alive after being executed.
13:01:58 <Saizan> keep_learning: can you annotate with the error message?
13:02:05 <thoughtp1lice> GHC also has parsers for it too, which would be easier to modify than just write your own
13:02:06 <shachaf> tswett: (You're thinking of http://codepad.org/.)
13:02:09 <thoughtp1lice> tswett: just a thought
13:02:22 <keep_learning> Saizan: yes 
13:02:26 <keep_learning> Saizan: wait a min
13:02:26 <Saizan> keep_learning: and the definition of Point
13:05:57 <keep_learning> Saizan: http://hpaste.org/43209/log_binarysearch_annotation
13:06:11 <keep_learning> Saizan: i can post the whole code 
13:06:16 <keep_learning> Saizan: but its mess 
13:06:32 <keep_learning> Saizan: if you would like to 
13:06:40 <keep_learning> Saizan: then i can post 
13:07:04 <Saizan> keep_learning: the type of ilognew should be enough
13:07:19 * hackagebot comonad 0.6.1.2 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.6.1.2 (EdwardKmett)
13:07:36 <keep_learning> Saizan: i did not get you 
13:07:57 <keep_learning> Saizan: why i am getting this error while i am returning Integer
13:08:04 <Saizan> keep_learning: what is the type of ilognew ?
13:08:15 <Saizan> oh, it's there, sorry
13:08:28 <keep_learning> ilognew::Integer->Integer->Integer
13:08:34 <tswett> keep_learning: be aware that "(ilognew 2 k  -1)" doesn't do what it looks like it does.
13:09:11 <keep_learning> should i put ilognew 2 k - 1::Integer 
13:09:16 <Saizan> ?type shiftÃ§
13:09:17 <lambdabot> forall a. (Bits a) => a -> Int -> a
13:09:19 <Saizan> ?type shiftL
13:09:20 <lambdabot> forall a. (Bits a) => a -> Int -> a
13:09:23 <tswett> If you mean to subtract 1, you should write "ilognew 2 k - 1"; if you mean to use negative one, you should write "ilognew 2 k (-1)".
13:09:25 <c_wraith> keep_learning: You should put negative numbers in parens
13:09:54 <tswett> You must put negative numbers in parentheses, in fact, if I remember correctly.
13:10:10 <tswett> I mean, not always, but often.
13:10:11 <Saizan> keep_learning: your problem is "shiftL (1::Integer) cnt", because the second argument of shiftL is supposed to be an Int
13:10:32 <tswett> > 3 + - 1
13:10:34 <lambdabot>   Precedence parsing error
13:10:34 <lambdabot>      cannot mix `GHC.Num.+' [infixl 6] and prefix ...
13:10:39 <keep_learning> but this one working until (\e -> 2 ^ e > n ) (+1) 1
13:10:41 <tswett> Maybe it is always.
13:10:42 <Saizan> keep_learning: so that makes ghc conclude that tmpFun should take an Int as the last argument
13:10:57 <keep_learning> ohhhhhhhhh
13:11:01 <keep_learning> saizan 
13:11:09 <keep_learning> so i should put it as Int
13:11:18 <Saizan> well, depends
13:11:32 <keep_learning> Saizan: great 
13:11:42 <keep_learning> you guys are seriously great 
13:11:46 <keep_learning> :)
13:11:48 <Saizan> you can do "shiftL (1::Integer) (fromIntegral cnt)" if you want to keep cnt an Integer
13:12:19 <keep_learning> :t fromIntegral 
13:12:21 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:12:54 <keep_learning> Saizan: thank you
13:13:46 <Saizan> np
13:13:59 <dreixel> joe6: too many things for me to reply, I got a bit lost
13:14:12 <dreixel> joe6: the Generic Haskell pre-processor isn't really maintained anymore
13:14:22 <dreixel> joe6: which hackage page do you mean?
13:20:22 <mreh> is there no Prelude shorthand for hputStr stderr
13:21:19 <hpc> mreh: don't think so
13:21:31 <mreh> fudge
13:21:35 <hpc> mreh: i like to write warn = hPutStrLn stderr
13:22:04 <hpc> prepended with "liftIO ." if i am using transformers
13:22:51 <tswett> @type liftIO
13:22:52 <lambdabot>     Ambiguous occurrence `liftIO'
13:22:53 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
13:22:53 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
13:23:01 <tswett> @type Control.Monad.Error.liftIO
13:23:02 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
13:23:28 <hpc> tswett: what makes it useful over lift is when you write your transformer by hand
13:23:34 <hpc> and it lacks the necessary kind for lift
13:24:08 <mreh> I need :: ErrorT String () -> IO (), I'm thinking either (hPutStr stderr) id `liftIO` runErrorT . ...
13:24:20 <mreh> (shell scripting in Haskell)
13:25:05 <hpc> ah nifty
13:25:15 <hpc> mine is for web logs
13:25:38 <hpc> :t ((hPutStr stderr) id `liftIO` runErrorT .)
13:25:39 <lambdabot> Not in scope: `hPutStr'
13:25:39 <lambdabot> Not in scope: `stderr'
13:25:39 <lambdabot>     Ambiguous occurrence `liftIO'
13:26:02 <hpc> :t (putStr id `Control.Monad.Error.liftIO` runErrorT .)
13:26:03 <lambdabot>     Couldn't match expected type `String'
13:26:03 <lambdabot>            against inferred type `a -> a'
13:26:03 <lambdabot>     In the first argument of `putStr', namely `id'
13:26:07 <hpc> aaargh
13:26:43 <mreh> either?
13:27:22 <mreh> my boss has me doing javascript, can I get smart and use haskell?
13:27:24 <hpc> oh, derp
13:27:33 <keep_learning> :t (.&.)
13:27:34 <lambdabot>     Ambiguous occurrence `.&.'
13:27:34 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
13:27:34 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
13:27:46 <hpc> :t (Data.Bits..&.)
13:27:46 <mreh> ._'
13:27:47 <lambdabot> forall a. (Bits a) => a -> a -> a
13:27:53 <keep_learning> .&.
13:28:22 <mreh> :t zipWith and
13:28:23 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
13:28:24 <lambdabot>     In the first argument of `zipWith', namely `and'
13:28:24 <lambdabot>     In the expression: zipWith and
13:28:43 <mreh> :t zipWith (&&)
13:28:44 <lambdabot> [Bool] -> [Bool] -> [Bool]
13:29:28 <tswett> So, time to write an application.  I guess I should use one of those version control thingies.  darcs is one of those, right?
13:29:47 <tswett> Anyway, what should I name my main Haskell file, and the module it defines?
13:30:28 <mreh> tswett: call it anything you like
13:30:28 <tswett> Can I name them after the application, or does one or the other have to be "main"?
13:30:43 <tswett> I remember ghc --make once getting angry because something wasn't named correctly.
13:31:05 <mreh> oh right, call it same as the module name
13:31:08 <joe6> dreixel: here http://hackage.haskell.org/package/regular or atleast in this page: http://www.cs.uu.nl/wiki/GenericProgramming/Regular
13:31:51 <dreixel> joe6: ah, problem is that this paper doesn't describe that library
13:31:51 <mreh> One special case, the file defining Control.Monad.Writer is called Writer.hs
13:32:13 <tswett> So I can call my main file punch.hs with module name Punch, and if it had a module named Foo, that would be foo.hs, and so on?
13:32:42 <mreh> tswett, I think it needs to be capitalised, I've never tried to do otherwise though
13:33:02 * tswett nods.
13:36:09 <sm> how do you preview a cabal file as hackage would render it ?
13:37:37 <tswett> What project category should a programming language interpretation go in?  Either Development or Language, I'm guessing.
13:37:53 <mm_freak_> sm: you can't, but the contents page in the haddock documentation gives a somewhat good approximation
13:38:30 <mm_freak_> tswett: "Compilers/Interpreters"
13:39:24 * tswett nods.
13:39:34 <sm> mm_freak_: oh nice, thanks. cabal haddock [--executables] and open dist/doc/html/.../index.html
13:39:47 <shurikas> hey, if I define function like this:
13:39:52 <shurikas> let a b c = b + c
13:40:06 <edwardk> ddarius: around?
13:40:07 <shurikas> does compiler rewrite it into let a = \b -> \c -> b + c 
13:40:08 <shurikas> ?
13:41:39 <edwardk> shurikas: some haskell compilers do, but the ghc compiler internally track k-ary functions as such rather than as single argument functions, then it eta reduces to remove the extra lambdas,  so in the end a = (+)
13:41:54 <edwardk> er internally tracks
13:41:55 <tswett> shurikas: you can think of it that way.
13:42:11 <tswett> Internally, as edwardk said, it might do something different.
13:42:15 <edwardk> shurikas: but as tswett said, you can think of it that way
13:42:34 <shurikas> you guys like to quote each other
13:42:41 <ddarius> edwardk: Perhaps.
13:42:46 <edwardk> as shurikas says, yes, we do
13:42:50 <shurikas> :))
13:42:51 <tswett> As ddarius said, perhaps.
13:43:00 <locks> haha
13:43:45 <edwardk> ddarius: Recalling the monad from UTF we talked about the other day, given that T is a monad on hask, you get a fairly pretty monad-transformer like thing. is there a nice way to embed from T -> UTF giving a MonadTrans instance?
13:44:04 <edwardk> i have a hack together package, but haven't figured out the MonadTrans for it yet
13:44:15 <edwardk> or a counter-example
13:45:27 <monochrom> UTF is less catchy than WTF
13:46:32 <shurikas> can I nest functions and not only lambda expressions?
13:46:40 <monochrom> yes
13:47:08 <monochrom> f x = g x where g x = h x where h x = i x where i x = x*x -- finally!
13:47:27 <shurikas> I regret asking...
13:48:05 <monochrom> you can use it judiciously :)
13:49:16 <shurikas> let f = \x -> g x where g x = x * x
13:49:31 <shurikas> let f = \x -> g x             at this point can I write something else and in the end define g x ?
13:49:54 <shurikas> I am thinking of making something like a code block
13:50:33 <shurikas> e.g. in Python or Scala at any point inside a function I can define my inner functions
13:50:37 <monochrom> like this? f x = g x + h (x+1) + 5 where {h n = n*n; g m = m-m }
13:50:48 <shurikas> oh yes.
13:51:20 <monochrom> or like this? f x = (let h n = n*n in h (x+1)) + 5
13:51:57 <edwardk> ddarius: i have a package on github.com/ekmett/adjunctions â€” which will make sense if that MonadTrans instance exists ;)
13:53:38 * monochrom nailed a weird cabal problem: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85413/focus=85507 :)
13:53:56 <hatds> is there a haskell resource for getting an overview of "all the common morphisms" (cata, ana, hylo, etc.)?
13:54:59 <monochrom> I suppose the haskell wiki (that is haskell.org) has them somewhere.
13:56:38 <edwardk1> what i have right now is g -| f, and an m a and I want g (m (f a))
13:57:47 <mreh> is IOException's implementation hidden?
13:57:58 <Saizan> aristotele had hylomorphisms too :O
13:58:06 <monochrom> not if you use ghc.
13:59:32 <KitB> Is there some standard binary tree module or otherwise faster search function than "elem"?
13:59:36 <monochrom> oops, I'm wrong. IOException is implementation-hidden.
13:59:51 <KitB> (and I've seriously tried googling, I feel stupid)
13:59:58 <dibblego> hatds, http://research.microsoft.com/en-us/um/people/emeijer/Papers/fpca91.pdf
14:00:37 <monochrom> Data.Set is a balanced binary search tree so you can elem fast
14:01:08 <monochrom> but it's called "memeber" there
14:01:13 <hatds> dibblego: thanks
14:02:03 <KitB> monochrom: Thanks. I suppose I should've noticed that already.
14:21:02 <edwardk1> ddarius: the closest i have so far is that I can provide an instance (Adjunction f g, Traversable f) => MonadTrans (AdjointT f g)
14:21:35 <edwardk1> but the Traversable module stubbornly fails to provide instance of Traversable for (,)e and transformers omits one for Identity
14:25:17 <ddarius> I believe a monad transformer is a morphism of monads, so you should be able to use the adjunction to build that morphism.
14:25:56 <ddarius> StateT is a monad transformer induced from an adjunction in this way.
14:26:53 <c_wraith> holy crap.  what does ghc-generated code do that makes the linux scheduler flip out?
14:27:10 <c_wraith> We've got a program that runs in a high-network loop, followed by a high-CPU loop
14:27:12 <aristid> c_wraith: having its own scheduler?
14:27:23 <c_wraith> and it makes the linux scheduler have a seizure.
14:27:27 <edwardk1> ddarius: yeah, the state transformer seems to rely on a distributive law of the left adjoint over any monad m
14:27:41 <ddarius> Yeah, that may be necessary.
14:27:41 <c_wraith> the kernel won't start another process until it finishes
14:27:54 <edwardk1> which is tantamount to saying the left adjoint is traversable
14:28:03 <ddarius> You go from T -> UTF, to FT -> TF via the adjunction.
14:28:34 <edwardk1> T -> UFT, then UFT -> UTF by fmap traverse yeah
14:28:45 <edwardk1> er fmap sequence
14:29:18 <ddarius> So, if you had an adjunction of the form UTF, then you'd have a distributive law over the (right adjoint and not necessarily a monad) F for any monad T.
14:29:41 <edwardk1> so now all i need to do is put in two separate libraries proposals, one to add traversable to ((,)e) and one to ross for the transformers package to add it to Identity, and IdentityT
14:29:53 <ddarius> had an adjunction and a MonadTrans instance I meant to say.
14:33:02 <edwardk1> i had hoped to be able to provide an instance of (Adjunction f g, Applicative m) => Applicative (AdjointT f g m) but as that isn't possible for state, it looks pretty much impossible for a case that subsumes that one ;)
14:42:59 * hackagebot adjunctions 0.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.1 (EdwardKmett)
14:43:55 <ddarius> :t Data.Traversable.sequence
14:43:56 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
14:46:51 <frerich_> Hi! Is anybody here aware with the DocBook stylesheets which were (apparently, judging from the HTML output) used to generate book.realworldhaskell.org ?
14:47:19 <frerich_> I think the HTML output looks pretty nice, and I adore the 'comments per paragraph' feature. I have a rough idea how to implement it myself but I'd love to have a look how it was done.
14:47:32 <frerich_> aware with -> familiar with
14:48:22 <ddarius> edwardk1: You should probably add morphisms of adjunctions and adjoint conjugates.
14:48:23 <mreh> what kind of people do they hire at Microsoft research?
14:48:36 <mreh> oh, old conversation thread
14:48:47 <mreh> that was literally hours ago
14:48:47 <ddarius> edwardk1: The code is in my Monad Reader article, albeit generalized and using a different framework.
14:49:07 <dibblego> frerich, https://bitbucket.org/bos/hgbook
14:49:08 <ddarius> edwardk1: I'd say "and make a Category instance" but we don't have kind polymorphism.
14:51:09 <frerich_> dibblego: Perfect, thanks a ton!
14:55:34 <mreh> that reminds me, I need to renew my subscription
15:02:00 <ddarius> Why didn't node.js use dual continuations?
15:02:19 * cwraith hands each continuation a dualing pistol
15:02:24 <edwardk1> ddarius: i was thinking about adding the Representable machinery from category-extras as well
15:02:26 <cwraith> ...  why am I cwraith?
15:03:00 <shachaf> ... why am I shachaf?
15:03:02 <edwardk1> this is part f my gradual attempt to peel off digestable fragments of category-extras ;)
15:03:06 * shachaf is now known as s_hachaf
15:03:34 <m_reh> hey guise, it's me!
15:04:02 <mreh> where can I spawn processes?
15:04:05 <shachaf> preflex: seen m_reh
15:04:05 <preflex>  m_reh was last seen on #haskell 31 seconds ago, saying: hey guise, it's me!
15:04:11 <shachaf> Ah, I guess he's gone.
15:04:45 <mreh> He should have said, "hey guise, it's mreh"
15:04:54 <mreh> pronounces "mree"
15:05:08 <mreh> pronounced*
15:05:44 <mreh> :t run
15:05:45 <lambdabot> Not in scope: `run'
15:06:03 <mreh> dons just used that on his blog to execute a shell command
15:06:19 <mreh> it was three/four years ago mind
15:06:20 <Twey> @index run
15:06:21 <lambdabot> Data.Graph.Inductive.NodeMap, Data.Graph.Inductive, Test.QuickCheck.Batch, Debug.QuickCheck.Batch
15:06:32 <Twey> Probably not any of those
15:06:35 <monochrom> yeah, and he has an implementation on the blog supposedly
15:06:37 <Twey> HSH or something?
15:07:14 <mreh> @hoogle String -> IO ExitCode
15:07:14 <lambdabot> Prelude readIO :: Read a => String -> IO a
15:07:14 <lambdabot> System.IO readIO :: Read a => String -> IO a
15:07:14 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
15:07:21 * Saizan points mreh to System.Process or System.Cmd
15:07:47 <mreh> noooo, base v4!
15:08:02 <mreh> oh
15:09:29 <mreh> i thought I saw that in base not long ago, I was frantically searching for it :)
15:10:37 <monochrom> runProcess you saw in base
15:16:17 <andy> does record field disambiguation incur any runtime overhead at all?
15:18:05 <Saizan> it's resolved statically
15:18:22 <andy> ok
15:18:23 <andy> thanks
15:18:27 <c_wraith> eh?  disambiguation?  As far as I know, there is no record field disambiguation in Haskell.  >_>
15:18:36 <c_wraith> They need unambiguous names.
15:18:38 <mreh> it usually incurs writing some extra chars :)
15:18:51 <aavogt> c_wraith: there's a ghc extension for that
15:18:57 <c_wraith> ah
15:18:58 <c_wraith> ok
15:19:12 <mreh> :t (:=)
15:19:13 <lambdabot> Not in scope: data constructor `:='
15:19:21 <mreh> what's that lib I'm thinking of
15:19:37 <c_wraith> fclabels?  lenses?  data-accessor?  something similar?
15:19:42 <aavogt> c_wraith: if you have    data T a = T { x :: a }, data T2 a = T2 { x :: a }, it will choose the right x for record updates when both are in scope
15:19:44 <mreh> quite possibly
15:20:28 <aavogt> or at least cases that it knows you're using a T2 vs a T
15:20:40 <c_wraith> aavogt: I'm assuming with the caveat that the compile will fail if it can't tell which type it is from context, just like any other extension that allows that failure condition?
15:21:28 <cantropy> Hello for the Record Syntax data constructor( http://learnyouahaskell.com/making-our-own-types-and-typeclasses ), is it possible to show the argument names with :t in ghci? For instance for the Person constructor show the name of the arguments along with their types?
15:21:29 <c_wraith> What does it do internally?  The equivalent of creating an ad-hoc class?  Or is it somewhat smarter than that?
15:21:49 <aavogt> c_wraith: I don't think it looks at types
15:22:26 <c_wraith> cantropy: :info on the type name should contain what you want
15:22:55 <cantropy> c_wraith: ah great, just what I needed!
15:25:03 <cantropy> c_wraith: does the compiler retain all this information somewhere, or is it ghci that does the magic of looking up the argument names and the source location etc.
15:25:29 <c_wraith> cantropy: I think ghci is actually looking at the .hi files for that info
15:25:40 <c_wraith> but I'm not 100% sure on that
15:26:12 <cantropy> c_wraith: would be super cool if we could access that info from the compiler and disassemble via a vis Python dis.dis.
15:26:29 <cantropy> c_wraith: i did see a module for disassembly for Haskell somewhere though ...
15:26:53 <cantropy> c_wraith: not sure how much symbolic information can be gleaned out of it though ...
15:26:59 <c_wraith> cantropy: well, it's not going to be in fully compiled code, in general.  .hi files are generated per-module during the compilation steps, but they aren't in the final binary.
15:27:48 <cantropy> c_wraith: makes sense, something like unstripped c code.
15:28:18 <c_wraith> similar purpose, but more information.
15:28:35 <cantropy> c_wraith: what do you use to disassemble haskell code. is there something which can show me the (equivalent) assembly code that would be compiled from .hs files?
15:28:55 <cantropy> c_wraith: or is that too much to ask for from a high level language like Haskell.
15:29:05 <c_wraith> The closest you're going to get is core, and it's...  Not really very much like assembly
15:29:17 <cantropy> c_wraith: core?
15:29:18 <c_wraith> It's still much more low-level than the source, at least
15:29:50 <ddarius> GHC will dump the assembly if you want it (and, of course, you can always disassemble.)
15:30:19 <c_wraith> Hmm.  I guess that matters in the cases where you're curious if the core is being translated to assembly well.
15:30:22 <cantropy> ddarius: can it do at a granular level only, like a function
15:30:40 <c_wraith> But I feel like core is probably more useful than the final assembly in many cases
15:30:42 <monochrom> ghci does magic, being the compiler therefore omniscient. the information is not stored in object code.
15:30:59 <ddarius> It will produce code per module, though there is plenty of cross-module inlining.
15:31:33 <cantropy> ddarius: so there is nothing equivalent to Pythons dis.dis
15:32:04 <c_wraith> No, the compilation model is just too different.
15:32:48 <cantropy> hmmm, I wonder what are the *functional* equivalent to dis assembling like dis.dis in Python for Haskell.
15:33:11 <cantropy> functional as in end user functionality ...
15:33:56 <Saizan> what do you want to use it for?
15:34:20 <monochrom> you probably heard of type erasure. it implies dissassembly is a lost cause.
15:34:30 <cantropy> for uses like introspecting the comiler to produce the most optimized code, what is available for a Haskell programmer?
15:34:47 <cantropy> compiler
15:34:58 <cantropy> monochrom: what is erasure? a concept .. ?
15:35:13 <monochrom> an action
15:37:08 <Saizan> there are various ghc flags to see what code it has produced (and ghc-core is a nice wrapper for that purpouse)
15:37:22 <c_wraith> erasure is what it sounds like... Removing the information.  GHC removes type information at runtime.
15:38:14 <cantropy> monochrom: c_wraith: ah I see what you mean, found this on Google which is more familiar to me http://www.kdgregory.com/index.php?page=java.generics.cpp
15:38:37 <c_wraith> yes, java generics are implemented via erasure
15:39:03 <cantropy> Saizan: thank you, I will start reading on ghc-core ...
15:39:38 <cantropy> Saizan: http://hackage.haskell.org/package/ghc-core Unix-only :(
15:39:40 <Saizan> @hackage ghc-core
15:39:40 <lambdabot> http://hackage.haskell.org/package/ghc-core
15:40:00 <Saizan> then see the ghc manual for the actual flags
15:40:46 <cantropy> Saizan: what about cygwin, does it work inside it?
15:40:47 <mreh> what do you want to disassemble haskell for?
15:41:06 <Saizan> cantropy: no idea
15:41:15 <cantropy> mreh: poke around generally, not gonna do it for sometime, but will need too sooner than later, I hope
15:41:55 <mreh> cantropy: read the ghc source code instead :)
15:42:14 <Philippa> cantropy: you're usually better off reading GHC Core instead
15:42:56 <cantropy> mreh: no, I meant disassembly for application programming, I am not after the compiler side of things ...
15:43:34 <cantropy> Philippa: ok
15:44:33 <Saizan> yeah, and you can use -ddump-simpl to get it
15:45:13 <mreh> dons conveniently left out the implementation of the most complicated function in his Haskell shell script
15:45:18 <pedro3005> How can I get a random int in a certain range with haskell? I tried reading the documentation but it's very dry, I didn't get much forward
15:45:31 <c_wraith> :t randomR
15:45:32 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
15:46:06 <mreh> the one that captures the IOErrors from the shell and raises them to ErrorT
15:46:07 <c_wraith> That type signature is rather opaque, actually.  But it's what you're looking for.
15:46:37 <mreh> when you get sick of passing round generators by hand see MonadRandom
15:46:53 <c_wraith> MonadRandom annoys me, because it lacks a *really* useful function.
15:46:59 <mreh> *this is not the monad you are looking for*
15:47:28 <mreh> whoops, I would make the worst jedi
15:47:50 <mreh> c_wraith: what?
15:48:26 <monochrom> for all lib L, for all person P, L lacks a really useful function for P.
15:48:59 <c_wraith> something like embed :: MonadRandom m => (forall g . RandomGen g => g -> (a, g)) -> m a
15:49:08 <ddarius> monochrom: The liveHappilyEverAfter function?
15:49:09 <mreh> seems valid
15:49:22 <augustss> howdy
15:49:35 <ddarius> augustss: Moin.
15:49:48 <c_wraith> I guess Cale may have wanted to avoid Rank2Types when he wrote it.  But that function seems really handy.
15:50:13 <djahandarie> edwardk, any idea when you'll be able to get those videos up?
15:51:23 <edwardk> djahandarie: the camcorder is at home, so i'll at least have to get there before i can download them ;)
15:51:39 <djahandarie> Hehe okay
15:51:45 * djahandarie is excited because he heard the talks were good
15:52:05 <mreh> what's wrong with random
15:52:05 <mreh> getRandom, pardon
15:52:19 <edwardk> djahandarie: the one by spivak was excellent. it went way better than the one by him at galois.
15:52:31 <djahandarie> Yeah, that's what ddarius said
15:52:57 <edwardk> djahandarie: it also helped that we'd just gone through an intro to agda, so spotting the Grothendieck construction as the use of a sigma type, etc. came up during the talk
15:53:34 <edwardk> dan's presentation went very well, too. first non-scary intro to agda i've seen
15:53:35 <djahandarie> Neato
15:54:00 <djahandarie> And, man it is still beyond confusing to call Derek ddarius, since Darius is MY name
15:54:27 <edwardk> =)
15:54:37 <edwardk> djahandarie: it'd be worse if he was still darius =)
15:55:09 <djahandarie> I think I've asked him a few times why that is his nick but he keeps on evading the question lol
15:55:19 <c_wraith> mreh: It doesn't provide sufficient tools to pull existing functions into MonadRandom.  Like, if you already have shuffle :: RandomGen g => [a] -> g -> ([a], g), pulling that into MonadRandom currently requires re-implementing the whole algorithm in MonadRandom.  embed with the signature I gave would make it a one-line wrapper
15:55:50 <mreh> c_wraith: oh right
15:56:12 <mreh> I wonder if we could do that with Yampa
15:56:34 <mreh> well, only for the random signal functions
15:56:49 <mreh> I suppose it could also take a pure function
15:57:44 <mreh> need to make a -> b into a -> g -> (b, g)
15:58:19 <pastorn> @pl (\mb f -> mb >>= \b -> when b f)
15:58:19 <lambdabot> (. flip when) . (>>=)
15:58:24 <pastorn> ehm... no
15:59:19 <mreh> Rand . f perhapse?
15:59:49 <mreh> um..
16:06:03 <djahandarie> @type curry . (*** id)
16:06:04 <lambdabot> forall b c b'. (b -> c) -> b -> b' -> (c, b')
16:06:19 <djahandarie> mreh, ^^
16:06:58 <achristi1nson> http://pastebin.com/bdhixDgV --getting error: 'The type signature for `isXText' lacks an accompanying binding' when I try to compile this. any ideas?
16:07:55 <mun> if i have a logic variable v, would i say that "find all instantiations *to* v" or "... *of" v"?
16:07:55 <Botje> that's exactly what it means
16:08:05 <Botje> you gave a type for isXText, but a definition for isXTest
16:09:09 <achristi1nson> Botje: oops! typo then... thanks
16:09:42 <achristi1nson> how would I import "XmlFilter" in to my scope from HXT? when I try "import Text.XML.HXT.DOM.XmlTreeTypes" it chokes
16:10:09 <djahandarie> I sometimes wish inspecting the types of functions would just go through the type variables and map them to something more sensible
16:10:54 <c_wraith> you don't think b, b', and c are sensible names?
16:11:06 <djahandarie> I'd prefer a b c
16:11:11 <c_wraith> You're almost as bad as me, complaining that my tax forms came with copies 2, b, and c. :)
16:11:27 <djahandarie> Because then it's easier to tell when variables were introduced
16:11:31 <djahandarie> Meaning easier to find them again
16:11:43 <djahandarie> (Where could a have come from? Near the beginning)
16:13:17 <Egbert9e9> i love the website design
16:13:47 <Egbert9e9> whoever designed it should be proud
16:15:19 <lispy> Egbert9e9: which website?
16:15:25 <lispy> Egbert9e9: haskell.org?
16:15:27 <Egbert9e9> yes
16:15:30 <lispy> cool
16:15:47 <lispy> It was a community effort with lots of people providing tweaks, input, and feedback
16:16:02 <Egbert9e9> sleak
16:16:03 <lispy> I'm not sure which people played major roles though
16:16:32 <lispy> Egbert9e9: I'm fond of the platform's website :http://hackage.haskell.org/platform/
16:16:50 <Egbert9e9> ya, the graphics are shiny
16:18:16 <achristi1nson> getting error "Not in scope: type constructor or class `XmlFilter'" but I have "import Text.XML.HXT.DOM.TypeDefs" (http://hackage.haskell.org/packages/archive/hxt/8.5.4/doc/html/Text-XML-HXT-DOM-TypeDefs.html) code is at: http://hpaste.org/43210/error_not_in_scope_type_cons
16:20:12 <aristid> :t unfoldr $ \x -> case splitAt n x of ([], _) -> Nothing; (a, b) -> Just (a, b)
16:20:13 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
16:20:13 <lambdabot>     In the first argument of `splitAt', namely `n'
16:20:13 <lambdabot>     In the expression: splitAt n x
16:25:19 <aristid> :t \n -> unfoldr $ \x -> case splitAt n x of ([], _) -> Nothing; (a, b) -> Just (a, b)
16:25:21 <lambdabot> forall a. Int -> [a] -> [[a]]
16:25:32 <aristid> @hoogle Int -> [a] -> [[a]]
16:25:32 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
16:25:32 <lambdabot> Prelude drop :: Int -> [a] -> [a]
16:25:33 <lambdabot> Prelude take :: Int -> [a] -> [a]
16:26:06 <aristid> @pl \n -> unfoldr $ \x -> case splitAt n x of ([], _) -> Nothing; (a, b) -> Just (a, b)
16:26:07 <lambdabot> (line 1, column 46):
16:26:07 <lambdabot> unexpected ","
16:26:07 <lambdabot> expecting variable, "(", operator or ")"
16:26:11 <aristid> :/
16:31:30 <Veinor> ha
16:32:01 <Veinor> i was playing with HXT and trying to figure out how I'd mesh my LA code with my IO code
16:32:05 <Veinor> then I realized that i could just run it in IOLA
16:33:55 <monochrom> it pays to read the docs thoroughly
16:34:00 <Veinor> it does!
16:35:26 <monochrom> the next best thing is to just ask me, if I am not busy proving something about the ackermann function
16:35:31 <Veinor> haha
16:35:39 <Veinor> now i just need to figure out how this recursion is going to work
16:35:51 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
16:36:14 <monochrom> recursion is easier to figure out than iteration
16:37:13 <Veinor> ohar Manna and Richard Waldinger.  Is "sometime" sometimes better 
16:37:15 <Veinor>     than "always"?  Communications of the ACM 21(2):159--172, 1978. 
16:37:21 <Veinor> David Gries.  Is sometime ever better than alway?
16:37:26 <Veinor> thesea re fantastic paper names
16:38:45 <Veinor> so... here's my quandary. I have an HTML page that might include some content from an xmlhttprequest, that itself might have an xmlhttprequest, recursing possibly forever
16:38:53 <Veinor> well, arbitrarily long
16:39:21 <Veinor> i want to get the output of all those xmlhttprequests
16:39:36 <monochrom> those xmlhttprequests are inside javascript. you have to execute some javascript.
16:40:53 <Veinor> fortunately for me, the request doesn't depend on the javascript and is easy to pull out of it
16:41:44 <Veinor> I have a function (well, arrow) that determines the URL i need to request, and there's no parameters or anything I need to pass
16:42:31 <achristi1nson> is there a way to enumerate modules that are available from installed cabal packages?
16:42:43 <achristi1nson> I am searching for a type and need to see which module it is in
16:43:28 * hackagebot contravariant 0.1.2 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.1.2 (EdwardKmett)
16:43:39 <Saizan> there's ghc-pkg find-module
16:43:55 <Saizan> or ghc-pkg field $pkg exposed-modules
16:44:21 <Saizan> though maybe it's best to look for the type in hoogle or hayoo to find the module
16:44:22 <monochrom> something about Control.Arrow.ArrowTree.processTopDown
16:44:36 <Saizan> and then use ghc-pkg find-module to see if you have it
16:45:37 <achristi1nson> OK field might be it
16:46:08 <Veinor> i wish hoogle had a bigger index
16:46:40 <Veinor> like, hxt
16:48:26 <achristi1nson> ok exposed-modules does give useful information, but only modules (of course)... i need something that exposes the types as well
16:49:13 <achristi1nson> is there a way to do runtime reflection to reveal the information?
16:49:51 <Saizan> in ghci you can :browse SomeModule to see what it exports
16:50:03 <Veinor> and use :i SomeType to see what module defines it
16:50:55 <Veinor> monochrom: I don't feel like processTopDown is what I need here but it looks like ArrowTree has what I need
16:51:04 <monochrom> yeah
16:51:53 <achristi1nson> Saizan: nifty! that will do! I can get the types from exposed-modules then iterate & pipe the modules into ghci :browse... then grep all of that for the type I am looking for
16:52:27 <Veinor> fortunately I can just insert the xmlhttprequest result anywhere in the document and my parser will find it 8)
16:54:57 <Veinor> man, someone seriously needs to put hxt in hoogle
16:55:47 <monochrom> perhaps once upon a time it was done, but hxt was too large, and hoogle boogled out.
16:56:23 <Veinor> haha
16:56:39 <aristid> i think monochrom is serious
16:56:51 <Veinor> also, I have an a b c, an a b d, and a c -> d -> e. i want an a -> b -> e. what do?
16:56:51 <monochrom> I am joking.
16:57:19 <monochrom> "a c -> d -> e"?
16:57:27 <aristid> Veinor: a can only have one kind
16:57:40 <Veinor> er, I want an a b e
16:58:01 <Veinor> by 'a c -> d -> e' I meant 'a function of type c -> d -> e' :)
16:58:10 <monochrom> darn english "a"
16:58:32 <achristi1nson> Saizan: this is the command that ended up working for me: for MODULE in $(ghc-pkg field hxt exposed-modules | sed -e 's/exposed-modules://'); do echo ":browse $MODULE" | ghci; done | grep XmlTree
16:58:36 <achristi1nson> thanks for the help!
17:00:22 <monochrom> proc b -> do { c <- abc -< b; d <- abd -< c; returnA -< f c d }
17:03:21 <monochrom> abc &&& abd >>> arr (uncurry f)
17:03:47 <Veinor> i like that uncurry solution more
17:04:05 <monochrom> @type \abc abd f -> abc &&& abd >>> arr (uncurry f)
17:04:06 <lambdabot> forall (cat :: * -> * -> *) a c c' c1. (Arrow cat) => cat a c -> cat a c' -> (c -> c' -> c1) -> cat a c1
17:05:29 <monochrom> it's my fingering exercise to write the proc notation first, then I'll figure out the data flow to see if it can be pointfreed
17:06:15 <Veinor> i'm not terribly familiar with proc notation. kind of want to rewrite my stuff to use it.
17:08:12 <roconnor> thoughts-on-nodejs makes ruby on rails look like crap.
17:08:57 <ddarius> Making Ruby on Rails look like crap does not require much effort.
17:09:31 <beastaugh> roconnor: my guess would be that a number of things are wrong with that benchmark
17:10:26 <beastaugh> for example, running Rails on WEBrick will always make it slow
17:10:54 <monochrom> proc notation is like you wish you could draw a block diagram but you can't because programs are plain text files
17:11:11 <Veinor> haha
17:11:18 <aristid> roconnor: http://excid3.com/blog/2011/01/thoughts-on-nodejs/ ?
17:11:20 <beastaugh> a fairer comparison would use a server that someone might actually use for a production Rails application, like Passenger
17:11:22 <dolio> So is lambda calculus.
17:11:24 <Veinor> you've seen that C++ area computer in the type system, right?
17:11:34 <monochrom> I haven't.
17:11:38 <Veinor> you draw a rectangle and somehow it computes the area
17:11:43 <monochrom> hahaha
17:11:52 <mauke> it's not in the type system
17:11:59 <beastaugh> not to mention that Rails is a huge web framework with vastly more features than Snap
17:12:01 <Veinor> i thoguht it was
17:12:11 <monochrom> oh wow, someone did that? awesome. whether type or value
17:12:11 <mauke> http://www.xs4all.nl/~weegen/eelis/analogliterals.xhtml
17:12:29 <beastaugh> obviously I'm not claiming that Rails is particularly fast--it isn't--but these comparisons are not particularly meaningful
17:12:30 <Veinor> yeah, comparing rails to snap seems like... comparing nano to emacs
17:12:39 <monochrom> yay someone else who uses xhtml, not just me
17:12:43 <sm> in which direction ?
17:13:08 <c_wraith> Snap is intended to eventually compete relatively near the rails level of features...  But there's a long way to go first.
17:13:14 <Veinor> sm: rails is emacs, snap is nano
17:13:30 <sm> ah, fits
17:13:32 <Eelis> monochrom: \o/
17:13:37 * dpratt71 is watching a lecture about Haskell on Channel 9 (by Dr. Ralph Lammel)
17:13:42 <Veinor> yeah, i got that second one backwards
17:13:43 <dpratt71> good stuff
17:13:52 <beastaugh> c_wraith: well, I certainly hope it gets there
17:14:12 <aristid> roconnor, beastaugh: http://excid3.com/blog/2011/01/thoughts-on-nodejs/ ?
17:14:19 <aristid> damn
17:14:19 <monochrom> snap has chosen the right programming language.
17:14:29 <aristid> http://moreindirection.blogspot.com/2011/01/thoughts-on-nodejs.html ?
17:14:29 <beastaugh> aristid: yes, but also http://snapframework.com/blog/2010/11/17/snap-0.3-benchmarks
17:14:43 <Veinor> iirc someone did analog literals in haskell
17:14:45 <aristid> beastaugh: why not just provide a link? :(
17:14:56 <monochrom> a featureful lib for assembly language is going to be troublesome no matter how featureful
17:15:00 <aristid> roconnor mentioned "thoughts-on-nodejs" without a link
17:15:12 <aristid> of course, node.js being the fad that it is, google finds many results for that
17:15:28 <beastaugh> oh, sorry
17:15:45 <beastaugh> I just assumed we were all talking about the same thing and knew what it was we were talking about :)
17:15:58 <aristid> snoyman made an HTTP server that is supposedly even faster than snap
17:16:11 <aristid> not included in that benchmark tho
17:16:25 <beastaugh> yes, so I saw
17:16:28 <aristid> but i think hello world type benchmarks are suspicious
17:16:41 <beastaugh> I would be interested to see why it's so much faster
17:16:48 <sproingie> hello world is a nice test of runtime startup overhead
17:17:02 <sproingie> or request servicing overhead in the case of web
17:18:45 <aristid> sproingie: it blows that part out of proportion tho
17:19:11 <parcs> beastaugh: warp uses a hand-written http parser rather than attoparsec, and it leverages a lot of the performance-tuning that was done on WAI (on top of which it is built)
17:19:16 <lpsmith> Judging the performance of a webserver by the pong benchmark is kind of silly
17:19:30 <aristid> lpsmith: but very popular :)
17:19:31 <Veinor> when someone says 'hand-written http parser' I always imagine someone lovingly crafting each bit
17:19:33 <lpsmith> I'm trying to come up with an apt metaphor or simile,  but I'm drawing a blank
17:19:41 <sproingie> i think as a relative comparison it can be reasonable
17:20:06 <sproingie> if you need to handle a lot of traffic you don't want one that falls over at 1000 requests
17:20:12 <parcs> the posted benchmark show warp at 150k reqs/second
17:20:13 <aristid> sproingie: no, because it emphasises parts that may not be all that relevant relative to parts that it underemphasises
17:20:15 <parcs> that is.. amazing
17:20:22 <Twey> A train-wreck is a good metaphor for apt!  *rimshot*
17:21:12 <beastaugh> parcs: yes, I thought the parser part was a bit strange to be honest
17:21:29 <beastaugh> given the claims bos made in this blog post: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
17:21:53 <beastaugh> but perhaps I'm missing something, and a 2x speedup isn't to be sniffed at
17:22:03 <lpsmith> ok,  so your server can serve up 50 or 150k pongs a second.   But what happens when you are overloaded with more requests than you could possibly handle?  What happens when you are serving up a lot of dynamic content?
17:22:21 <beastaugh> (assuming the warp one has comparable performance to Ryan Dahl's hand-rolled C)
17:23:02 <dolio> So, why do we now have parsec, parsec1, parsec2 and parsec3?
17:23:26 <parcs> preservation?
17:24:12 <Saizan> i think it's people wanting network compiled against one and other libs against another to live happily together
17:26:40 <monochrom> wait, there is parsec1?
17:27:05 <dolio> @hackage parsec1
17:27:06 <lambdabot> http://hackage.haskell.org/package/parsec1
17:27:12 <lpsmith> I mean,  Erlang's Yaws is kind of slow,  but it's awesome at dealing with more traffic than it can handle
17:27:21 <dolio> There is now.
17:27:24 <monochrom> oh god, there is parsec1.
17:27:50 * monochrom contemplates parsec2.71828182...
17:28:33 <Twey> Heheh
17:28:35 <aristid> parsec6.28318530717958647692
17:28:42 <aristid> (pi*2 > pi)
17:28:49 <Twey> Ï„ FTW
17:29:43 <lpsmith> hehe
17:30:39 * lpsmith prefers the continued fraction of e
17:31:00 <lpsmith> 2;1,2,1,1,4,1,1,6,1,1,8,1,1,10...
17:31:12 <yip> I recently upgraded GHC from 7.0.1 to 7.0.2 and it's rejecting a style of "if" that i often use
17:31:49 <monochrom> turn on or turn off "DoIfThenElse" to see if it helps
17:32:13 <monochrom> or choose between haskell98 and haskell2010
17:32:24 <dolio> What about the factorial base e?
17:32:27 <dolio> 1.11111...
17:32:34 <yip> monochrom: that's what the error message is telling me to do
17:32:43 <lpsmith> dolio, sweet,  I didn't know that :)
17:33:12 <azaq23> > let fac = product . enumFromTo 1 in sum $ map (\x -> 1 / fac x) [1 .. 10]
17:33:13 <lambdabot>   1.7182818011463847
17:34:57 <yip> monochrom: but why was this changed?
17:38:39 <dolio> > sum . map recip . scanl (*) 1 $ [1..]
17:38:43 <lambdabot>   mueval-core: Time limit exceeded
17:38:51 <dolio> > sum . take 1000 . map recip . scanl (*) 1 $ [1..]
17:38:53 <lambdabot>   2.7182818284590455
17:39:37 <djahandarie> > sum . take 1000 . map recip . scanl (*) 1 $ [1..] :: CReal
17:39:41 <lambdabot>   mueval-core: Time limit exceeded
17:39:44 * hackagebot hoauth 0.3.3 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.3.3 (DiegoSouza)
17:39:46 <djahandarie> > sum . take 100 . map recip . scanl (*) 1 $ [1..] :: CReal
17:39:50 <lambdabot>   mueval-core: Time limit exceeded
17:39:52 <djahandarie> lol
17:39:57 <djahandarie> > sum . take 5 . map recip . scanl (*) 1 $ [1..] :: CReal
17:39:59 <lambdabot>   2.7083333333333333333333333333333333333333
17:40:06 <djahandarie> lol CReal performance fail
17:45:30 <Kaidelong> the series of reciporicals of factorials?
17:45:36 <Kaidelong> does that converge on something useful?
17:46:11 <shachaf> Kaidelong: Presumably 0?
17:46:44 <Kaidelong> shachaf: that doesn't make any sense. 1 + positive values > 1
17:47:10 <Kaidelong> looks like that might be e
17:47:12 <azaq23> Kaidelong the sum does converge against e
17:47:20 <azaq23> @google taylor expansion exp
17:47:20 <lambdabot> http://en.wikipedia.org/wiki/Taylor_series
17:47:20 <lambdabot> Title: Taylor series - Wikipedia, the free encyclopedia
17:47:35 * Kaidelong realized that it was probably a taylor series
17:48:10 <shachaf> Kaidelong: Oh, I misread.
17:48:23 <ryanakca> Could someone explain or point me to references on the '&&&' operator? (Mentioned on http://www.haskell.org/haskellwiki/99_questions/Solutions/10 )
17:48:36 <djahandarie> :t (&&&)
17:48:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:48:40 <kuffaar> @hoogle &&&
17:48:41 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
17:48:49 <kuffaar> http://www.haskell.org/hoogle/?hoogle=%26%26%26
17:48:58 <kuffaar> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Arrow.html#v:&&&
17:49:01 <ryanakca> Ah, Control.Arrow, that's why :type (&&&) wan't working.
17:49:02 <djahandarie> :t (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
17:49:03 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
17:49:12 <djahandarie> For the (->) instance of Arrow ^^
17:49:16 <ryanakca> Thanks
17:49:33 <Kaidelong> > uncurry (/) . (sum &&& length) $ [1..10]
17:49:34 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
17:49:35 <lambdabot>    arising from a use o...
17:49:41 <djahandarie> ryanakca, most people just use it for golfing
17:49:45 <lpsmith> dolio,  oh wait, I did know that.  I temporarily forgot taylor series :-D
17:49:46 <Kaidelong> > uncurry (/) . (sum &&& fromInteger . length) $ [1..10]
17:49:47 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
17:49:47 <lambdabot>         against inf...
17:50:16 <Kaidelong> > uncurry (/) . (sum &&& fromIntegral . length) $ [1..10] --please work
17:50:18 <lambdabot>   5.5
17:50:34 <aristid> Kaidelong: you just have to be nice to the compiler.
17:50:58 <aristid> :t genericLength
17:50:59 <lambdabot> forall b i. (Num i) => [b] -> i
17:51:03 <aristid> oh!
17:51:20 <djahandarie> :t fromIntegral
17:51:21 <aristid> > uncurry (/) . (sum &&& genericLength) $ [1..10] --please work, dear compiler
17:51:21 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:51:23 <lambdabot>   5.5
17:51:57 <Kaidelong> @ty fromIntegral . length
17:51:58 <lambdabot> forall b a. (Num b) => [a] -> b
17:52:05 <Kaidelong> @src genericLength
17:52:05 <lambdabot> genericLength []    = 0
17:52:06 <lambdabot> genericLength (_:l) = 1 + genericLength l
17:52:08 <djahandarie> > uncurry div . (sum &&& length) $ [1..10]
17:52:11 <lambdabot>   5
17:52:11 <Kaidelong> ah
17:52:29 <djahandarie> Kaidelong, I don't think that's how it's actually implemented in GHC currently
17:53:32 <djahandarie> Oh, it is, it is just rewritten for certain types 
18:33:12 <sbahra> Hi.
18:33:13 <lambdabot> sbahra: You have 1 new message. '/msg lambdabot @messages' to read it.
18:33:23 <sbahra> haha
18:35:00 <Lisa_> hi
18:54:45 <deech> Hi all, is there some way to parse a Haskell expression/function and determine if it does any unsafe casting.
18:55:30 <gwern> deech: what is unsafe casting?
18:58:13 <deech> gwern : Use of unsafePerformIO for example.
18:58:27 <gwern> sure. 'grep unsafePerformIO'
18:59:06 <Draconx|Laptop> gwern, but that'll catch functions that say {- we don't use unsafePerformIO here! -} :P
18:59:14 <gwern> Draconx|Laptop: so?
18:59:24 <gwern> deech did not specify 'perfection' in his request
18:59:41 <shachaf> gwern: Oh, come on.
18:59:49 <djahandarie> I recall some thing like 'SafeHaskell' or something like that
19:00:05 <deech> gwern: Right, I was wondering if there was a better way. I am thinking about a Haskell refactoring tool that can detect if a function is subverting the type-system.
19:00:10 <shachaf> "Is there some way to take the factorial of a number?" "Sure, f _ = 1. You didn't specify 'perfection' in your request"
19:00:11 <gwern> djahandarie: yeah, a taint mode for unsafePerformIO and co
19:00:36 <shachaf> deech: Any library function can call unsafePerformIO (and many do, in a reasonable way).
19:01:10 <gwern> deech: and as shacaf says, you can't ask this question in general. you have to ask it with respect to a particular set of libraries
19:01:41 <gwern> deech: your analyzer may be able to blacklist an explicit import of Foreign or System.IO.Unsafe, but can it see what is imported by every module installed and accessible?
19:01:51 <augustss> deech: the answer is no, because it's not decidable
19:02:07 <gwern> deech: undeciable by Rice's theorem if you were curious
19:03:01 <Draconx|Laptop> Rice's theorem is a real bitch :(
19:03:24 <gwern> Draconx|Laptop: on the plus side, it's a permnent employment theorem for us :)
19:03:30 <deech> Oooh, Rice's Theorem. I hadn't heard of that. I'll check it out. I wanted to build a refactorer for Haskell and I was thinking that it would be tough to automatically refactor a function that breaks the type system.
19:04:03 <Draconx|Laptop> Rice's theorem: Let P be an interesting problem that you want to solve with a computer.  Haha, you're screwed!
19:04:17 <gwern> deech: rice's theorem basically describes how to turn any predicate into a will-this-program-halt problem, which you should already be familiar with...
19:04:18 <augustss> deech: so you can make an analysis that answers yes/no/dunno
19:04:31 <djahandarie> @quote Draconx|Laptop Rice's theorem: Let P be an interesting problem that you want to solve with a computer.  Haha, you're screwed
19:04:31 <lambdabot> No quotes match. I've seen penguins that can type better than that.
19:04:34 <djahandarie> Oops
19:04:37 <djahandarie> @remember Draconx|Laptop Rice's theorem: Let P be an interesting problem that you want to solve with a computer.  Haha, you're screwed
19:04:38 <lambdabot> I will never forget.
19:04:41 <gwern> @quote rice
19:04:41 <lambdabot> Draconx|Laptop says: Rice's theorem: Let P be an interesting problem that you want to solve with a computer.  Haha, you're screwed
19:04:46 <gwern> @flish
19:05:35 <kuffaar> I don't get Rice's theorem
19:05:40 <augustss> @quote
19:05:40 <lambdabot> MyCatVerbs says: Amdahl's law is mostly to be used for making people feel depressed. :)
19:05:50 <kuffaar> http://en.wikipedia.org/wiki/Rice%27s_theorem
19:05:54 <kuffaar> That looks different
19:06:12 <deech> Ok I'll concentrate on providing some simple renaming support then.
19:06:35 <deech> Even that would be useful ... to me anyway.
19:06:37 <Draconx|Laptop> kuffaar, that's the one.  The statement under "Introduction" is a more typical one.
19:06:51 <augustss> @quote
19:06:51 <lambdabot> psnively says: All your Data.Foldable are belong to base.
19:07:02 <gwern> kuffaar: skip down to http://en.wikipedia.org/wiki/Rice%27s_theorem#Formal_proof for the easy version I was describing
19:07:16 <gwern> deech: you should look at existing refactoring tools maybe?
19:07:27 <kuffaar> What does that have to do with the "Rice's theorem: Let P be an interesting problem that you want to solve with a computer.  Haha, you're screwed" part?
19:07:48 <kuffaar> also lol at the double space after the colon
19:07:52 <roconnor> Amdahl's law is why Windows Vista takes 26 hours to compile no matter how many servers are on Microsoft's server farm.
19:08:07 <gwern> kuffaar: 'any interesting property is undecidable'
19:08:12 <deech> gwern: I have the only one I can find is Hare and that doesn't support any Haskell programs that use extensions.
19:08:20 <Draconx|Laptop> kuffaar, Rice's theorem says that every non-trivial property about the language accepted by a turing machine is undecidable.
19:08:38 <kuffaar> I have no idea what the implications of that are
19:08:41 <gwern> deech: well, hlint is a refactoring program if you squint, and andy gill has hera which I think does extensions
19:09:19 <gwern> kuffaar: I just told you! any interesting property is undecidable. is this a virus? undecidable. will this erase my hard drive? undecidable. etc
19:09:26 <deech> I hadn't heard of Hera, I'll check that out too.
19:12:11 <kuffaar> gwern what do I care :|
19:12:50 <gwern> kuffaar: I dunno. why should you care about it being impossible to write perfect anti-virus programs or perfect any-programs?
19:13:16 <kuffaar> Exactly, you wouldn't
19:14:07 * roconnor uses Rice's theorem to write a program to decide if a turing machine decides the halting problem or not.
19:15:36 <augustss> if you want to be pedantic these properties are actually decidable for real computers
19:15:55 <augustss> since real computers are not Turing machines
19:15:58 <gwern> augustss: hush you you'll just confuse people
19:16:10 <dolio> They're Turing-decidable.
19:16:12 <roconnor> augustss: although you can't decide it with a real computer :P
19:16:13 <augustss> ignore me, I'm just babbling
19:16:25 <Draconx|Laptop> augustss, no, but you can simulate one by attaching a roll of tape to them.
19:16:28 <augustss> roconnor: why do you say that?
19:16:34 <deech> My head hurts.
19:16:46 * djahandarie is having a good time
19:16:48 <gwern> augustss: see?
19:16:52 <roconnor> augustss: presumably you would need a computer bigger than a real computer to simulate the real computer
19:17:09 <gwern> roconnor: yeah, by pigeonhole
19:17:26 <augustss> roconnor: only twice the memory (if i remember right) of the machine you are trying to check
19:17:38 <gwern> simulate one finite state machine inside a larger one and see whether you get loops etc
19:17:53 <gwern> augustss: really, only twice? that's really impressive
19:17:58 <augustss> No, not even twice, I think
19:18:22 <roconnor> I see.  So you just need two real computers :)
19:18:25 <dolio> Halting oracles can decide the halting problem for Turing machines. Isn't that useful?
19:19:04 <augustss> dolio: can you sell me one?
19:19:10 <djahandarie> X oracles can decide the Y problem for X. Isn't that useful?
19:19:12 <deech> How about a real human tester? 
19:19:13 <Draconx|Laptop> dolio, yup, but now you have a new halting problem -- the one for turing machines with attached oracles that decide the halting problem for turing machines :)
19:19:51 <roconnor> better than having two problems
19:19:51 <gwern> deech: humans make too many mistakes
19:20:01 <gwern> deech: that is why you are here, after all
19:20:22 <djahandarie> BECAUSE YOU MADE A MISTAKE
19:20:23 <deech> gwern: What did you say about my parents? :)
19:20:25 <djahandarie> HAHAHA
19:20:27 <dolio> augustss: No. Can you sell me a computer with twice as much memory as itself, so it can check its own halting problem?
19:20:31 <djahandarie> Oh wow that's even better
19:20:39 * gwern swears that wasn't what I had intended by that comment
19:20:51 <gwern> although now I wish it had been ;_;
19:20:54 <augustss> dolio: no but I can sell you one with twice as much memory as the one you have right now.
19:21:09 <deech> ouch :)
19:21:20 <dolio> But then you've created a new halting problem.
19:21:27 <lars9> how do haskellers think of Go Language?
19:21:56 <gwern> lars9: we think it's boring and bad in respects
19:21:57 <djahandarie> dolio, I think the point is that we only cared about the original halting problem
19:21:59 <augustss> Too little, too late
19:22:02 <roconnor> it's a trap augustss virus's checking program will really wipe your hard drive!
19:22:18 <kuffaar> lars9: I doubt most of them even know much about it
19:22:24 <augustss> roconnor: it takes quite a while to decide anything
19:23:59 <lars9> gwern: kuffaar: after reading some intro, i feel it's boring and wicked, but, when i check its authors, they are great guys, so strange
19:24:16 <augustss> roconnor: e.g., to check for termination you run two machine, one at half the speed of the other and compare the state of them in every clcck cycle.  Either the fast one will terminate, or the two machine will have the same state at some point.
19:24:18 <gwern> lars9: to grow older is to grow wickeder
19:24:27 <kuffaar> lol
19:24:48 <kuffaar> By the way, mind you that there are two programming languages called Go
19:24:48 <lars9> lol
19:24:58 <lars9> kuffaar: google's go.
19:25:01 <kuffaar> An older one and the one by Google
19:25:08 <augustss> Same trick as the list length function in Common Lisp
19:25:26 <lars9> dunno what's the point of Go
19:25:27 <kuffaar> http://en.wikipedia.org/wiki/Go!_%28programming_language%29
19:25:34 <roconnor> augustss: yep
19:26:05 <deech> lars9: If I understand the propoganda its a nicer C++.
19:26:09 <systemfault> Ahhh go... The most overhyped language of 2009
19:26:18 <lars9> just yet another java/c# with tons of newly invented grammers
19:26:36 <systemfault> We would have never even heard of that language if it wasn't of the "names" behind it.
19:26:41 <kuffaar> Grammars*
19:26:50 <gwern> systemfault: and the company
19:26:53 <deech> lars9: Yeah but I think it's got pointer support too.
19:26:53 <systemfault> It's Robert "fucking" Pike!
19:26:57 <Philippa> re earlier: an important fact about Rice's Theorem is that it's about functions, it's /not/ about things that you can project functions from. So a corrolary is that if you want to know interesting things about code, it'll need annotating
19:27:02 <kuffaar> lars9: Java/C# are quite different really
19:27:06 <augustss> Go has some cool features, but it's just another language in the C lineage.
19:27:10 <systemfault> gwern: Bah.. Not sure that google has any effect on that.
19:27:13 <kuffaar> I thought Go was system level stuff?
19:27:14 <lars9> systemfault: it's just Rob
19:27:31 <gwern> systemfault: you think it would have half as much interest if Google were entirely unvinovled?
19:27:37 <gwern> if Rob were at a university instead?
19:27:39 <systemfault> lars9: Thanks for correcting me.
19:27:45 <systemfault> gwern: Totally.
19:27:45 <gwern> no, it's all 'Google's new language'!
19:27:55 <systemfault> gwern: It's Rob Pike! The unix guyz
19:27:55 <Philippa> gwern: maybe 10% as much
19:27:56 <roconnor> Philippa: it also says that annotations will never always be sufficent?
19:28:14 <gwern> count the googles: http://en.wikipedia.org/wiki/Go_%28programming_language%29
19:28:15 <Philippa> roconnor: I think that one's more down to Goedel
19:28:40 <Philippa> (a given set of annotations may not always be sufficient for any possible property, sure)
19:29:14 <deech> Then are there methods that measure the probability that a program satisfies some property?
19:29:20 <roconnor> Philippa: I thought Rice's theorem, Turing's Theorem and Goedel's Theorem were all the same :)
19:29:50 <Draconx|Laptop> deech, what does "the probability that a program satisfies some property" even _mean_?
19:30:31 <kuffaar> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:read <- doesn't mention any exceptions... how do you catch the exception thrown by read when it fails to parse a string?
19:30:36 <kuffaar> > read "a" :: Int
19:30:37 <deech> Something like, there's a 75% chance this function is an infinite loop.
19:30:38 <lambdabot>   *Exception: Prelude.read: no parse
19:30:41 <kuffaar> That one ^
19:30:59 <Draconx|Laptop> deech, either the function is in an infinite loop, or it isn't.
19:31:00 <gwern> Draconx|Laptop: it sounds like chaitin's omega
19:31:00 <augustss> kuffaar: don't
19:31:09 <augustss> kuffaar: use reads
19:31:13 <kuffaar> Ah, ok
19:31:41 <augustss> kuffaar: reads isn't nice to use, though.  we really need a readMaybe
19:31:50 <Draconx|Laptop> deech, you can't be "75% likely to be in an infinite loop", just like I can't be 75% likely to be falling off an airplane.
19:31:50 <kuffaar> reads :: Read a => ReadS a
19:31:54 <kuffaar> That looks really odd
19:31:58 <kuffaar> I was expecting a Maybe a
19:32:10 <djahandarie> @type ReadS
19:32:10 <dolio> GHC defines a nice readEither internally, and then doesn't export it.
19:32:12 <lambdabot> Not in scope: data constructor `ReadS'
19:32:13 <djahandarie> Err
19:32:14 <augustss> kuffaar: yeah, that's the one that would be nice
19:32:23 <djahandarie> @hoogle ReadS
19:32:24 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
19:32:24 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
19:32:24 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
19:32:34 <Kaidelong> Draconx: what if your function is defined over 25% of its domain
19:32:37 <augustss> > reads "123" :: [(Int, String)]
19:32:37 <gwern> Draconx|Laptop: everything either happens or doesn't happen, is either true or false. do you mean there's no such thing as probability?
19:32:38 <lambdabot>   [(123,"")]
19:32:41 <kuffaar> type ReadS a = String -> [(a, String)]
19:32:45 <kuffaar> Oh yeah, I remember now
19:32:54 <augustss> > reads "apa" :: [(Int, String)]
19:32:55 <lambdabot>   []
19:33:15 <roconnor> Cox says that probablity is a measure of one's state of knowledge
19:33:50 <gwern> roconnor: I suspect Draconx|Laptop hasn't heard of your cox so my question was aimed at seeing whether he hewed to subjective or objective intuitions
19:33:53 <Draconx|Laptop> gwern, probability has to be defined over some distribution.  You can't just look at a function and say "yup, that function is 75% likely to be looping forever".
19:33:56 <ttmrichter> Morning, all.
19:34:29 <roconnor> http://en.wikipedia.org/wiki/Richard_Threlkeld_Cox
19:34:34 <deech> Draconx|Laptop: Right, you're either in a infinite loop or not, but since it isn't possible for an automated analyzer to tell for certain but can it throw up a red-flag that works pretty well.
19:34:38 <c_wraith> "75% of the input domain will result in an infinite loop"?
19:34:45 <ddarius> More people should be named "Threlkeld."
19:35:44 * ddarius also recommends the work around AIÎ¾
19:35:48 <Draconx|Laptop> deech, yes, you can have a program that answers "yes" or "maybe".
19:35:50 <ttmrichter> There appears to be some batteries missing from the Haskell Platform package for Windows.  Specifically when I use cabal-install it gives me the error "cabal: failed to parse output of 'ghc-pkg dump'.  When I do a ghc-pkg dump manually the output looks perfectly normal.  Anybody have any ideas what could be going wrong?  (This is a fresh install of the latest Haskell Platform on a clean system.)
19:36:26 <augustss> sounds like some version mismatch
19:36:51 <augustss> ttmrichter: do you have any old versions of haskell installed as well?
19:37:02 <gwern> ddarius: I saw an offhand reference today that AIXI and variants blow up whenever infinities are introduced (like a universe which lasts forever), which brought home how little I understand and how little popular material there is for it
19:37:17 <ttmrichter> augustss: Nope.  This is a clean machine with just Windows installed on it.  (I keep clean machine snapshots lying around for just this purpose.)
19:37:17 <deech> ttmrichter: What does ghc-pkg check say?
19:38:03 <ttmrichter> deech: the first time I run it it says that it needs a recache.  After I do the recache it says nothing.
19:38:17 <Draconx|Laptop> deech, (note that a program which answers "maybe" for every input is always right)
19:38:28 <deech> ttmrichter: And ghc-pkg list?
19:39:04 <ttmrichter> deech: It gives me a list of packages.
19:39:23 <deech> Draconx|Laptop: Yes I was talking more along the lines of heuristics. Something like Java's Findbugs.
19:39:31 <ttmrichter> The only unusual thing I can possibly see is that each package has whitespace before it and there are two blank lines at the end.
19:39:59 <deech> ttmrichter: Is there anything obviously malformed in ghc-pkg dump?
19:40:21 <deech> hmmm....
19:40:31 <gwern> deech: heuristics eh? so you should like hlint
19:40:42 <ttmrichter> It's a 2500 line dump, so I haven't looked so closely, deech, but a quick scan saw nothing standing out, no.
19:40:55 <deech> gwern: Yes I love it. I use it regularly.
19:41:04 <deech> Taught me a lot about Haskell.
19:41:05 <gwern> so why not look into expanding it?
19:41:14 * hackagebot memscript 0.0.1.1 - Command line utility for memorizing scriptures or any other text  http://hackage.haskell.org/package/memscript-0.0.1.1 (KiYungAhn)
19:41:35 <djahandarie> Interesting...
19:41:40 <Maxdamantus> @pl \a b -> f (g a) (g b)
19:41:40 <lambdabot> (. g) . f . g
19:41:53 <deech> ttmrichter: One more thing what version is your Cabal? I think the latest is 1.8.something.
19:41:55 <ttmrichter> deech: To me it looks like a bunch of key: value pairs separated by --- between packages.
19:42:40 <ttmrichter> cabal-install v0.6.2 using version 1.6.0.3 of the Cabal library
19:42:42 <deech> gwern: Yes I will look into that further. Thanks for your comments!
19:42:43 <ttmrichter> That's what it's reporting.
19:42:46 <Kaidelong> (f . g) a (g b)
19:43:15 <Kaidelong> ah
19:43:23 <Kaidelong> I see, there is both an a and a b there
19:43:24 <ttmrichter> It is, in fact, "cabal install cabal-install" that first failed for me, ironically.
19:43:24 <deech> ttmrichter: I think that's your problem.
19:43:39 <juhp> is community.haskell.org email working for anyone?
19:43:54 <ttmrichter> On doing a "cabal update" it told me I needed to "cabal install cabal-install" to get the latest version.
19:43:57 <ttmrichter> And nothing works now.
19:44:23 <augustss> ttmrichter: don't do it
19:44:37 <dolio> f `on` g
19:44:49 <deech> Try downloading cabal-install and compiling it by hand (http://hackage.haskell.org/package/cabal-install)
19:45:02 <kuffaar> What was the Haddock string pattern again?
19:45:06 <kuffaar> -- |Blah blah?
19:45:10 <deech> ttmrichter: You do have a working GHC right?
19:45:17 <djahandarie> kuffaar, --| blah
19:45:18 <augustss> kuffaar: that's one of them
19:45:36 <ttmrichter> deech: Yes.  But I rather wanted to install a few libraries....
19:45:40 <kuffaar> haskell-mode fails on  --|
19:45:43 <augustss> -- | to comment before something, -- ^ to comment after
19:45:50 <kuffaar> -- | sounds more like it
19:45:56 <kuffaar> Ah, I see, thanks
19:45:58 <djahandarie> Oh, whoops
19:46:06 <kuffaar> -- | It is then
19:46:06 <ttmrichter> Is there a later version of the Haskell Platform out there that's compatible with ... well ... what's actually out there?
19:46:20 <gwern> ttmrichter: you don't want to use ghc 7, I don't think
19:46:33 <s1xz> Hi, can you guys recommend any good books on type theory and denotational semantics for a math grad student?
19:46:33 <ddarius> gwern: Well, the impact of the universal distribution on "average-case" analysis was the relevant aspect for the conversation.
19:46:57 <augustss> ttmrichter: just don't do "cabal install cabal-install", and I think most things will work fine
19:47:01 <deech> ttmrichter: The latest Haskell platform comes with cabal 1.8.0.6
19:47:25 <deech> ttmrichter: Why can't you install cabal-install manually?
19:47:35 <ttmrichter> deech: The version I just installed a few minutes ago is 2010-2.0.0.  Is there a later version?
19:47:48 <deech> ttmrichter: nope
19:48:05 <ttmrichter> Then it comes with 1.6.whatever because that's what I've got here.
19:48:49 <ttmrichter> And as for installing cabal-install manually, I'm really not looking forward to hunting down the dependencies by hand.  It's kind of what cabal-install is supposed to be doing, no?
19:49:49 <augustss> ttmrichter: So what goes wrong if you don't install the new cabal-install?
19:50:29 <deech> ttmrichter: Yes, but not having the right version is causing the error you're getting.
19:52:10 <deech> And if you look at ghc-pkg list, if the rest of the Haskell platform install went ok, the deps should be installed.
19:52:43 <ttmrichter> deech: OK, I'll give that a shot.  Thanks for the help.
19:54:14 <s1xz> Any particularly good denotational semantics books at graduate math level?
19:55:41 <ddarius> I don't think there are too many aimed at undergraduate or lower levels, not that you need a degree to learn about denotational semantics.
19:57:07 <djahandarie> You know, it would be pretty awesome going to a uni that taught hardcore theory before anything else
19:57:16 <kuffaar> http://siyobik.info/pastebin_download.php?id=572 <- what am I doing wrong in the reads string :: [(a, String)]
19:57:17 <kuffaar>  part there?
19:57:33 <djahandarie> Actually, just drop the 'anything else' entirely, I can learn that by myself
19:59:24 <ddarius> djahandarie: You can learn hardcore theory by yourself as well.
19:59:39 <deech> kuffaar: Try ((reads string)::[(a,String)])
19:59:42 <djahandarie> Without getting bored?
19:59:51 <kuffaar> Oh.
19:59:58 <ddarius> djahandarie: Yes.
20:00:25 <djahandarie> Without neglecting all the current stuff I'm learning in Uni?
20:00:38 <kuffaar> deech: Still the same error :(
20:01:10 <s1xz> Boredom is probably the greatest obstacle to autodidacticism. djahandarie: that's what I'm doing :)
20:01:40 <deech> kuffaar: Hold on lemme try it out
20:02:46 <ddarius> djahandarie: If the stuff you're learning has no application to you and is not otherwise interesting, what exactly is the loss of neglecting it?  You're neglecting -many- other things that aren't taught at your university or aren't taught in your course path.
20:03:21 <djahandarie> ddarius, I need a degree!
20:03:28 <ddarius> djahandarie: Do you?
20:03:32 <djahandarie> Do you?
20:03:36 <ddarius> djahandarie: No.
20:03:46 <djahandarie> Then why are you taking classes? :(
20:03:55 <ddarius> djahandarie: Because I told my boss I would.
20:03:59 <ddarius> And I do what I say.
20:04:06 <djahandarie> I see...
20:04:09 <kuffaar> I frequently don't do what I say
20:04:16 <s1xz> ddarius: are you a student?
20:04:21 <ddarius> djahandarie: These classes are probably worse than useless for me.
20:04:30 <djahandarie> ddarius, that how I feel about most of mine
20:04:39 <djahandarie> At least the CS ones
20:04:42 <ddarius> djahandarie: I am literally not working on useful, interesting work so that I can count marbles and write two pages on the experience.
20:04:55 <ddarius> s1xz: Sort of.
20:05:47 <djahandarie> ddarius, I bet your teachers are usually like 'wtf' though, lol, considering that you probably know more than them in a large number of area
20:05:50 <djahandarie> s
20:06:24 <s1xz> Can I revise my question? What's a good way to study Haskell as a mathematical construction? As opposed to a language to get things done in.
20:06:38 <gwern> haskell road to mathematics? although I suppose that's more using haskell than studying haskell
20:06:41 <kuffaar> deech any progress? :p
20:06:53 <Kaidelong> s1xz: Is Haskell really that interesting in that sense?
20:06:54 <ddarius> s1xz: Haskell is a fairly ugly mathematical object (and isn't well-defined anyway.)
20:06:56 <djahandarie> s1xz, I guess by learning other languages, System F, Agda, Coq, etc, then studying the relationships
20:07:01 <djahandarie> And yeah
20:07:11 <ddarius> s1xz: You may be interested in type theory in general and Martin Löf type theory specifically.
20:07:57 <djahandarie> This reminds me of a question, are there other tools for categorizing how 'powerful' a type system is aside from the lambda cube?
20:08:10 <s1xz> ddarius: interesting, any recommended intros?
20:08:33 <ddarius> s1xz: You can probably find plenty googling.  I don't recall any I read in particular.
20:08:40 <deech> kuffaar: Yeah a little. If I change the type sig to [(Int, String)] it goes a little further.
20:08:53 <ddarius> djahandarie: You can "count" how many lambda terms can be typed.
20:09:20 <kuffaar> deech but it's not an Int >:O
20:09:53 <djahandarie> ddarius, which lambda terms?
20:10:01 <s1xz> Thanks. Kaidelong: not really, but I would like to understand it at that level.
20:10:27 <Kaidelong> s1xz: What will you gain from this exactly? Unless you want to write an optimizing compiler for it or something.
20:10:49 <deech> kuffaar: I know. Still thinking.
20:11:37 <ddarius> djahandarie: Presumably untyped ones (decorated with types as necessary.)
20:12:30 <ddarius> djahandarie: Of course, this isn't always useful.  Arbitrary-rank intersection types end up following beta reduction pretty much completely.
20:12:34 <deech> kuffaar: I can't get it. Maybe ask some other people here. 
20:12:42 <kuffaar> :/
20:14:49 <s1xz> Kaidelong: ways to improve it, for instance. It's like I wouldn't want to just understand matrices as blocks of numbers that are useful for rotating things; I'm happier with linear algebra. I think a deep understanding of the language would make me better at using it.
20:14:57 <Philippa> ddarius: I figure the only interesting thing about intersection types is that they lift intersection of constraints to type level
20:15:21 <Philippa> ddarius: which... well, seems to me to also contain the obvious solution to the principal typing problem, y'know?
20:15:27 <Kaidelong> Philippa: do intersection types even make sense in Haskell?
20:15:33 <Kaidelong> I imagine they might in OCaml
20:16:00 <Philippa> Kaidelong: depends what you mean by make sense. You could bolt them on, how often you'd want to use them is another matter
20:16:19 <djahandarie> ddarius, what does rank mean in terms of an intersection type?
20:16:22 <Kaidelong> Philippa: But what's the intersection type between Maybe and First?
20:17:00 <Philippa> Kaidelong: wrong question. Look at intersections of function types
20:17:41 <kuffaar> http://siyobik.info/pastebin_download.php?id=572 <- does anybody see what the problem with this code is? deech already tried his hand at it, but without success.
20:17:41 <deech> kuffaar: I think I just got it to compile. http://hpaste.org/paste/43211/reads_annotation#p43212
20:17:42 <mjrosenb> is there any documentation on intersection types?
20:17:46 <kuffaar> Ohh
20:17:56 <kuffaar> reads is in IO???
20:18:12 <kuffaar> deech http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:reads
20:18:14 <kuffaar> I don't get it.
20:18:29 <kuffaar> I see no IO in there.
20:18:54 <ddarius> Philippa: Intersection types are pretty useful for internal compiler type systems.
20:19:23 <djahandarie> That does have me wondering how isomorphism between two types affects intersection
20:20:21 <ddarius> edwardk: What do the laws say re strictness?
20:21:06 <Philippa> ddarius: hmm, I've not met that - got links to any good examples?
20:21:30 <deech> kuffaar: I know. I was just trying to isolate the prob with a toy example.
20:21:40 <deech> kuffaar: still loooking at your code.
20:22:35 <ddarius> Philippa: Not handy.
20:23:20 <Philippa> any use cases spring to mind? I can see it for eg cross-module stuff (where I see it as the reified constraint thing, really)
20:24:08 <s1xz> ddarius: thanks so much for the Martin LÃ¶f type theory pointer, I found a free book that's really piqued my interest.
20:24:34 <s1xz> http://www.cse.chalmers.se/research/group/logic/book/ if anyone's interested
20:25:24 <kuffaar> Could not deduce (Read a1) from the context (Read a) arising from a use of `reads'
20:25:28 <kuffaar> Hmmm
20:25:39 <kuffaar> Why a1?
20:28:24 * hackagebot husk-scheme 2.0 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-2.0 (JustinEthier)
20:28:34 <kuffaar> deech: Shouldn't 'a' anywhere within the body of the function refer to the same type as specified in the signature or am I mistaken about that?
20:28:58 <llayland> @kuffaar guessing that a in where a  is not bound to the a in Maybe a.  is there a precedence issue?
20:28:58 <lambdabot> Unknown command, try @list
20:29:08 <llayland> kuffaar guessing that a in where a  is not bound to the a in Maybe a.  is there a precedence issue?
20:29:45 <kuffaar> llayland http://siyobik.info/pastebin_download.php?id=572
20:29:46 <deech> kuffaar: So this works : readMaybe string = let result = reads s in Just $ fst $ head result
20:30:24 <deech> kuffaar: But this doesn't : readMaybe string = let result = reads s in if null result then Nothing else Just $ fst $ head result.
20:30:36 <kuffaar> That is so weird
20:34:08 <kuffaar> I don't understand this at all
20:36:17 <deech> I'm stumped. I'd love to hear how to resolve this.
20:36:24 <kuffaar> :'(
20:36:36 <kuffaar> llayland do you grasp this?
20:36:38 <llayland> hmm, the Nothing doesn't use result, so it does't know the type?
20:36:55 <llayland> not really, I've forgotten the very little haskell i know
20:37:14 <kuffaar> Wasn't ddarius an elite Haskell hacker?
20:37:22 <kuffaar> Maybe they understand this
20:37:57 <llayland> try (const Nothing result) instead of (Nothing)
20:38:28 <kuffaar> for both Nothings?
20:38:49 <ddarius> llayland: const Nothing result is exactly equivalent to Nothing.
20:38:59 <llayland> in the last one deech said that doesn't work
20:39:01 <ddarius> llayland: Perhaps you wanted to suggest asTypeOf?
20:39:02 <kuffaar> Oh wait, it's not even available in the first one
20:39:24 <kuffaar> ddarius: http://siyobik.info/pastebin_download.php?id=572 do you understand what I did wrong here?
20:39:44 <jmcarthur> kuffaar: your type signature's "a" is not the same as your type annotation's "a"
20:39:45 <joe6> do you all build ghc from darcs? and how often do you do it?
20:40:01 <kuffaar> jmcarthur: Why not? :(
20:40:06 <jmcarthur> kuffaar: ScopedTypeVariables might be able to fix it. removing your annotation may also fix it
20:40:09 <kuffaar> How do I refer to the one in the type signature?
20:40:16 <kuffaar> I tried removing it already hm
20:40:20 <jmcarthur> kuffaar: they are in different scopes unless you use that extension
20:40:32 <kuffaar> Ah
20:40:36 <jmcarthur> kuffaar: the extension will require you to put a forall a. in front of your type signature, btw
20:40:51 <jmcarthur> kuffaar: otherwise it will still not be in scope in the definition
20:41:10 <kuffaar> Wait wtf, removing it entirely actually worked
20:41:14 * kuffaar facepalm
20:41:24 <jmcarthur> heh
20:41:33 <kuffaar> I thought it had errored out on that earlier
20:41:45 <jmcarthur> it may have, then you fixed the error and this one came up instead
20:42:00 <kuffaar> Thanks anyways, heh
20:42:05 <jmcarthur> np
20:42:06 <monochrom> type variables in two separate types are not considered identical. haskell 98 rule.
20:42:14 <kuffaar> I had no idea
20:43:00 <kuffaar> Does this change in any way in Haskell Prime/Haskell 2011?
20:43:15 <deech> jmcarthur: In trying to help kuffaar I wrote this little snippet (http://hpaste.org/paste/43211/reads_annotation#p43215) that uses ScopedTypeVariables but with the same error.
20:43:34 <kuffaar> deech you didn't add the forall signature
20:43:39 <kuffaar> As jmcarthur said
20:43:42 <monochrom> if you write "a->a->Bool" they're the same "a". if you write "f :: a->Bool; .... g :: a->Bool" they're different "a"s. doesn't matter if "g is defined inside f"
20:43:56 <kuffaar> monochrom hmm right
20:44:39 <azaq23> > abs (0 :+ 0) ** 2
20:44:41 <lambdabot>   NaN :+ NaN
20:44:55 <azaq23> wat?
20:44:55 <kuffaar> :t (:+)
20:44:57 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
20:45:10 <monochrom> > 0 ** 2
20:45:11 <lambdabot>   0.0
20:45:20 <monochrom> oh oops complex number is different
20:45:47 <kuffaar> > (0 :+ 1) ** 2
20:45:48 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
20:45:50 <monochrom> to do complex number ** you take log
20:45:53 <kuffaar> :[
20:46:02 <monochrom> to take log you have to cut branches
20:46:34 <deech> kuffaar: I just did (http://hpaste.org/paste/43211/reads_annotation#p43216) same result
20:46:34 <monochrom> and then all branches omit 0, so 0**blah is undefined
20:46:44 <kuffaar> Hmm
20:47:20 <jmcarthur> > exp $ (0 :+ 1) * pi :: CReal
20:47:21 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
20:47:21 <lambdabot>         against infe...
20:47:25 <kuffaar> deech: Wait, how does that scope extend?
20:47:26 <jmcarthur> > exp $ (0 :+ 1) * pi :: Complex CReal
20:47:28 <lambdabot>   (-1.0) :+ 0.0
20:47:37 <kuffaar> deech try putting the result part into a where clause in test perhaps
20:47:52 <kuffaar> That's what I tried at first to avoid having to inline the type
20:47:56 <deech> kuffaar: That's what I had first, same thing.
20:47:58 <kuffaar> Hmm
20:49:15 <kuffaar> Prelude Knyaz.String> readMaybe "2" :: Maybe Int -> Just 2; Prelude Knyaz.String> readMaybe "a" :: Maybe Int -> Nothing
20:49:18 <kuffaar> At least it works :/
20:50:32 <monochrom> ScopedTypeVariables means you do something like this: "example :: forall a. a->a; example x = (x::a)" all "a"s refer to the same thing
20:51:15 <jmcarthur> deech: you used result in two places. only one of them is constrained by the type signature
20:51:21 <monochrom> Of course you can also do "example :: forall a. a->a; example x = y where { y :: a; y =x }"  still all "a"s same
20:52:02 <kuffaar> Man, C++ has nothing on Haskell
20:52:23 <monochrom> But once you write "f :: forall a. ...; g :: forall a. ..." they're different. Each forall creates a new one.
20:52:27 <joe6> ddarius: have you used pattern calculus?
20:52:34 <kuffaar> Is the current standard of Haskell longer than the C++ one?
20:52:39 <jmcarthur> no way
20:52:45 <jmcarthur> C++ is *way* more complicated
20:52:56 <joe6> ddarius: i am reading the pdf document and it seems to be an interesting concept.
20:52:58 <llayland> ddarius: yes (Nothing) and (const Nothing result) are functionally equivalent, but don't we have to have the same type on both sides of an if and then how does it verify Nothing :: Maybe a ?
20:53:18 <monochrom> you can probably estimate the length of http://www.haskell.org/onlinereport/haskell2010/
20:53:24 <joe6> ddarius: i just wanted to know where it stands in terms of practical usage.
20:53:46 <kuffaar> Removed: The (n + k) pattern syntax.
20:53:50 <kuffaar> What pattern was that?
20:54:19 <jmcarthur> > let foo (n+1) = n in foo 5
20:54:20 <llayland> kuffaar: decrement (x + 1) = x
20:54:21 <lambdabot>   <no location info>: Parse error in pattern
20:54:29 <jmcarthur> aw it's off in LB
20:54:32 <kuffaar> Hah
20:54:42 <jmcarthur> most useless feature ever
20:54:51 <jmcarthur> (IMO)
20:54:52 <kuffaar> I have no problem with it
20:54:52 <monochrom> oh interesting, the haskell 2010 pdf is 330 pages. http://haskell.org/definition/haskell2010.pdf
20:55:03 <jmcarthur> monochrom: wow, much longer than i expected
20:55:08 <kuffaar> I bet some math people love it :)
20:55:13 <kuffaar> 330 hmm
20:55:18 <ddarius> joe6: Barry Jay has implemented Bondi which implements all but the latest stuff (the stuff in "First class patterns" coauthored with Delia Kesner.)  I haven't used it though as it is fairly new, and it's syntax is based on ML, and I'm also much more interested in the newest work.
20:55:20 <kuffaar> C++ 2003 was 867
20:55:20 <crossedeyefreak> Hello! :D
20:55:21 <kuffaar> I think
20:55:30 <kuffaar> crossedeyefreak: Be warned, Haskell causes cancer
20:55:33 <llayland> I didn't until i realized what happened when x < 1 (or 0 I forget)
20:55:37 <monochrom> don't forget that it includes the bloody lib. System.IO and all that.
20:55:37 <kuffaar> @quote SPJ cheerful
20:55:38 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
20:55:44 <jmcarthur> @faq Can Haskell cure cancer?
20:55:44 <lambdabot> The answer is: Yes! Haskell can do that.
20:55:54 <crossedeyefreak> Where did you get that peice of Info?
20:56:15 <kuffaar> crossedeyefreak: Simon Peyton Jones told me on IRC
20:56:36 <crossedeyefreak> If anything where to induce cancer, I would think it would be COBOL or Assembly :S
20:56:51 <jmcarthur> man, kuffaar is really encouraging
20:57:23 <monochrom> eh? where has Random or System.Random gone?
20:57:25 <jmcarthur> haskell causes no cancer. i am 99% sure
20:57:27 <Bynbo7> ddarius: his students are doing some quite interesting things as well
20:57:28 <deech> kuffaar: Did you figure it out? If so what was it?
20:57:35 * azaq23 found an article pertaining the NaN stuff, http://www.mail-archive.com/haskell-cafe@haskell.org/msg63151.html monochrom thanks
20:57:50 <jmcarthur> monochrom: rightly removed i think
20:59:06 <crossedeyefreak> I'm not far into the haskell lesson
20:59:30 <joe6> ddarius: what is Bondi? another language or module?
20:59:50 <crossedeyefreak> but can you sutitute variables for "fst <variable>"
21:00:02 <ddarius> joe6: It's a language.
21:00:24 <jmcarthur> crossedeyefreak: what do you mean? use fst on variables instead of literal tuples?
21:00:30 <jmcarthur> if so then yes
21:00:39 <crossedeyefreak> Ahh
21:00:40 <jmcarthur> > let a = (5, "foo") in fst a
21:00:41 <crossedeyefreak> Thanks
21:00:42 <lambdabot>   5
21:01:04 <kuffaar> Referential transparency, pow?
21:01:09 <crossedeyefreak> what about putting a variable into memory then calling it later
21:01:11 <crossedeyefreak> like
21:01:18 <crossedeyefreak>  x = moo
21:01:25 <crossedeyefreak> fst x
21:01:27 <jmcarthur> crossedeyefreak: if you are using tryhaskell then you can't do it. if you are using ghci then, sure
21:01:32 <jmcarthur> *ghci, then sure
21:01:41 <crossedeyefreak> Ahh, Ok!
21:01:49 <jmcarthur> crossedeyefreak: it would look like:    let x = moo; fst x
21:01:56 <crossedeyefreak> Ah
21:02:23 <crossedeyefreak> see, I have little experience in programs like this, 
21:02:29 <crossedeyefreak> languages I mean
21:03:03 <crossedeyefreak> I have worked with Assembly, but I mostly deal with Basic, Java...
21:03:32 <kuffaar> Basic :o
21:03:41 <crossedeyefreak> Yeah...Why?
21:05:01 <crossedeyefreak> I'm experienced in it well
21:05:46 <monochrom> there is no why in contacting programming languages or dieseases
21:06:33 <crossedeyefreak> There is only a yes?
21:07:18 <deech> kuffaar: Did you get it? Because I got it to compile if you're still interested (http://hpaste.org/paste/43211/reads_annotation#p43217)
21:07:43 <deech> I'd just like to know why it worked and how I could have done this w/out the extension.
21:08:00 <jmcarthur> deech: i said what the problem was above
21:08:13 <jmcarthur> "deech: you used result in two places. only one of them is constrained by the type signature"
21:08:28 <deech> jmcarthur: oh , didn't see that. Sorry
21:08:47 <jmcarthur> deech: if the use of result you used in the condition of the if was the same use as the one you use as the actual result of the function then it would have been fine
21:09:30 <jmcarthur> deech: instead you are reading the input string in two locations, each possibly being used as a different type
21:09:55 <jmcarthur> i'll annotate that real quick...
21:10:11 <kuffaar> deech: What did you change? You added the :: in test?
21:10:16 <Bynbo7> crossedeyefreak: if you're interested in learning haskell, check out:...
21:10:18 <Bynbo7> @where lyah
21:10:19 <lambdabot> http://www.learnyouahaskell.com/
21:11:06 <crossedeyefreak> I can't really decide
21:11:21 <crossedeyefreak> I don't know if I would ever use it
21:11:56 <deech> kuffaar: I added the "forall a. " and the type sig on (result s)
21:11:59 <llayland> crossedeyefreak: even if you don't use it, it will change the way you think about problems (or at least it did for me)
21:12:23 <Bynbo7> crossedeyefreak: what sorts of programs do you write?
21:12:31 <jmcarthur> deech: i went overboard on the annotation :(   http://hpaste.org/paste/43211/reads_annotation#p43218
21:12:43 <jmcarthur> oh and i messed it up
21:12:52 * jmcarthur fixes
21:13:02 <crossedeyefreak> Sometimes games, sometimes real world program.
21:13:03 <kuffaar> crossedeyefreak: Learn C++/Python/Ruby well instead and come back when you want to try out new stuff after that, be sure to give at least one Lisp (Common Lisp, Scheme, Clojure) a try before that
21:13:08 <jmcarthur> http://hpaste.org/paste/43211/reads_annotation#p43219
21:13:23 <joe6> ddarius: have you tried Bondi?
21:13:34 <Bynbo7> kuffaar: haven't you only just started learning haskell?
21:13:40 <ddarius> joe6: I already answered that question.
21:13:43 <kuffaar> Bynbo7: Yeah
21:13:59 <Bynbo7> so, what makes you a good source of advice on these issues? :\
21:14:23 <jmcarthur> hmm, that type signature doesn't even line up. are you sure that was compiling? ;)
21:14:34 <ddarius> Bynbo7: The fact that crossedeyefreak doesn't have the background to tell the difference.
21:14:42 <tolkad> I just got this unintelligible error from ghc
21:14:53 <kuffaar> Bynbo7 I wouldn't recommend Haskell to anybody who doesn't have a broad knowledge of programming languages yet
21:15:01 <crossedeyefreak> Background, what would you mean?
21:15:02 <tolkad> SpecConstr Function `$j_sgfo{v} [lid]' has one call pattern, but the limit is 0
21:15:04 <joe6> ddarius: gotcha. sorry.
21:15:08 <tolkad> what is that supposed to mean?
21:15:18 <Bynbo7> tolkad: they're not errors, and can be ignored
21:15:19 <deech> jmcarthur: I think I gettit! 
21:15:22 <crossedeyefreak> I use a LOT of programming languages
21:15:32 <kuffaar> crossedeyefreak: You said "Basic and Java"
21:15:39 <tolkad> Bynbo7: it's not a warning. I'm not sure what it is
21:15:40 <Bynbo7> crossedeyefreak: then you should learn haskell, and find out what you've been missing in all the rest :)
21:15:42 <tolkad> what does it mean?
21:15:52 <crossedeyefreak> lol
21:15:53 <ddarius> crossedeyefreak: How well do you know the Haskell community.
21:15:56 <ddarius> ?
21:15:58 <kuffaar> tolkad I've seen that a lot when I was compiling some stuff
21:16:05 <crossedeyefreak> I just started here
21:16:06 <deech> jmcarthur: Yeah my version  seems to compile.
21:16:22 <Bynbo7> tolkad: it's from one of the optimisation passes. basically it's saying it did more specialisation than the limit said it should... and that's ok
21:16:30 <deech> Yours is way clearer and more elegant.
21:16:32 <ddarius> crossedeyefreak: So you don't yet know who is and isn't representative and authoritative.  This is the background I was referring to.
21:16:45 <monochrom> learn haskell at your own pace.
21:16:59 <crossedeyefreak> Oh?
21:17:10 <tolkad> Bynbo7: if it's not something I need to worry about it shouldn't tell me
21:17:14 <llayland> doesn't it make more sense to learn haskell first so you can think clearly and succinctly about your actual problem while you learn to deal with cruft in whatever other language you are learning?
21:17:15 <crossedeyefreak> I still quite don't know what is means.
21:17:25 <crossedeyefreak> Sorry, I'm kinda blurry
21:17:31 <crossedeyefreak> It's  12 am
21:17:34 <Bynbo7> tolkad: indeed, and it will probably be fixed in the next ghc release
21:18:06 <monochrom> yes I think it's better to learn haskell as a clean slate. but either way is fine. open-mindedness is the most important.
21:20:55 <horse_kicker> hello. noob, 1st timer here. i have some code "data Bla = Bla (String -> String) ", but am unable to derive Show for it. any clues?
21:21:12 <monochrom> can't do Show on functions
21:21:12 <Bynbo7> horse_kicker: how do you show a function?
21:21:37 <kuffaar> horse_kicker I think you need to instance Show Blah and then define the method yourself?
21:21:53 <kuffaar> Although I'm not sure how you want to serialise that function
21:21:56 <Bynbo7> method?
21:22:04 <Bynbo7> there are no methods here son ;)
21:22:05 <horse_kicker> tried that. didn't work : illegal view patterns.
21:22:12 <Bynbo7> eh?
21:22:35 <kuffaar> Bynbo7: I have seen texts which referred to functions of typeclasses as methods in Haskell :o
21:22:43 <Bynbo7> horse_kicker: instance Show Blah where show (Bla f) = "Bla f"
21:22:55 <monochrom> "the overloaded operationsâ€”called class methods" straight from haskell 2010
21:23:33 <Bynbo7> hmm, i don't like that word, make the fact that classes aren't OOP classes even more confusing
21:23:40 <kuffaar> Bynbo7: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
21:23:42 <kuffaar> LYAH does it
21:24:18 <monochrom> you probably also don't like to spell "type class" as "type class". and a million other things.
21:24:43 <Bynbo7> :\
21:25:07 <Bynbo7> i just think of them as class functions, that's all
21:25:41 <llayland> that would make my head hurt
21:26:05 <kuffaar> I bet they won't be back, we scared them off
21:26:16 <Bynbo7> well... they're functions... for a specific class.... how is this not logical?
21:26:29 <kuffaar> s/logical/reasonable/
21:27:10 <monochrom> you can call them class functions. I can call them class methods. how is this not logical?
21:27:20 <kuffaar> s/logical/reasonable/ >:O
21:27:31 <Bynbo7> you've been quite snarky lately monochrom, what's up?
21:27:42 <monochrom> not snarky. snarky how?
21:28:43 <monochrom> and I really mean logical. it's logical that I prefer one name (and it's straight from haskell 2010 too) and you prefer another.
21:29:02 <kuffaar> But it has nothing to do with logic/formal systems
21:29:14 <kuffaar> !(a && b) = !a || !b
21:29:21 <kuffaar> Boolean algebra pertains to logic
21:29:31 <kuffaar> "I like terminology XYZ" better has nothing to with logic
21:29:39 <monochrom> almost every formal system lets you attach different names to the same thing.
21:30:08 <monochrom> perhaps that should be meta-logical rather than logical
21:30:11 <kuffaar> Woops, "I like terminology XYZ better"* has nothing to with logic
21:32:41 <llayland> bynbo: not arguing, that would just kill my intuition which is that a type class is a grouping of types and what comes after the where are the functions that have to be implemented to belong to the group
21:33:14 <kuffaar> llayland: Why don't you tab nicks? They probably won't get a highlight without it otherwise
21:33:41 <monochrom> I don't think that intuition is killed.
21:34:13 <kuffaar> By the way, do you think that using _ instad of otherwise in cases/guards is bad style?
21:34:52 <monochrom> you probably can't use _ in guards.
21:34:53 <Bynbo7> llayland: i'm confused, you didn't even mention methods, so you seem to agree with me?
21:35:04 <kuffaar> Oh, right
21:35:30 <kuffaar> Different things
21:35:40 <monochrom> "otherwise" is specifically defined to be "True" and you need "True" or other boolean expressions in guards.
21:35:56 <kuffaar> Oh, I thought it was _
21:36:03 <kuffaar> Hmm
21:36:36 <kuffaar> I totally mixed them up then
21:36:38 <Bynbo7> sometimes people use otherwise in case statements, but then it's a name binfind, not a reference to the definition of otherwise we usually use
21:36:40 <kuffaar> Nevermind
21:36:40 <monochrom> whereas in cases any identifier (including "otherwise") is a variable for your own use
21:37:43 <kuffaar> Does it make any sense to have -- | Haddock comments for functions/types which are not exported?
21:38:20 <monochrom> yes. harmless. perhaps you'll be glad one day when you decide to export it.
21:38:28 <kuffaar> True
21:38:39 <llayland> Bynbo7:  ah, I thought your use of the term "class functions" was something akin to functions of the class not functions that need to be implemented to belong to the class. Maybe my distinction is just because of the unfortunate clash with OO terminology 
21:38:45 <monochrom> also there is a haddock command flag to expose the non-exported things too.
21:39:37 <monochrom> ah, that kind of class functions and methods.
21:39:54 <monochrom> "static methods"
21:41:09 <pastorn> @hoogle length
21:41:10 <lambdabot> Prelude length :: [a] -> Int
21:41:10 <lambdabot> Data.ByteString length :: ByteString -> Int
21:41:10 <lambdabot> Data.List length :: [a] -> Int
21:41:46 <joe6> pastorn: hello, still working on the generics portion of the program. Hence, did not ping you with the final version.
21:42:06 <llayland> yeah, something like that or a function that you would apply the class to instead a type that was a member of that class.    -- I'm gonna shut up about this now
21:42:09 <joe6> pastorn: just wanted to say a quick hello and update you on where my efforts are.
21:46:06 <pastorn> joe6: heh, how's it going?
21:46:33 <joe6> pastorn: good. still on the haskell drug that you put me on..
21:47:16 <llayland> last night I laughed when I it popped into my head that (id const) is the same as (const), but in a sense (const id) is the opposite.
21:47:43 <monochrom> haha
21:48:11 <Bynbo7> :t (id const, const, const id)
21:48:12 <lambdabot> forall a b a1 b1 a2 b2. (a -> b -> a, a1 -> b1 -> a1, b2 -> a2 -> a2)
21:48:42 <edwardk> preflex: xseen ddarius
21:48:42 <preflex>  ddarius was last seen on freenode/#haskell 32 minutes and 11 seconds ago, saying: crossedeyefreak: So you don't yet know who is and isn't representative and authoritative.  This is the background I was referring to.
21:48:57 <ddarius> edwardk: Ho.
21:49:11 <edwardk> ddarius: wrestling with a couple of adjunctions, i figured it was right up your alley ;)
21:49:29 <ddarius> Adjunctions are my favorite.
21:49:58 <edwardk> good because i suck when they start going contravariant, etc
21:50:15 <edwardk> https://github.com/ekmett/adjunctions/tree/master/Data/Functor
21:50:20 <ddarius> edwardk: I think everyone does.
21:50:25 <edwardk> in particular https://github.com/ekmett/adjunctions/blob/master/Data/Functor/Contravariant/Adjunction.hs
21:50:33 <ddarius> Humans aren't good about following the switching about.
21:50:37 <edwardk> i started building a module for adjunctions between contravariant functors
21:50:40 <ddarius> This screams for tool automation.
21:51:16 <edwardk> the first one that kind of called out to me was to see if I can make an adjunction between Op r and Op r â€”
21:51:25 <edwardk> but that doesn't appear to exist unless i'm being dumb
21:53:00 <edwardk> i freely admit i may have screwed up the definition, because i also can't seem to define the adjunction given rise to by the composition of two adjunctions between contravariant functors
21:53:11 <ddarius> edwardk: Wait, are you going to have multiple Adjunction classes?
21:53:48 <edwardk> ddarius: for right now i was sticking to very simple variations on the theme rather than going back to the old category-extras definition from hell
21:53:57 <ddarius> edwardk: Where is Op defined (or just what is it's definition?)
21:54:02 <ddarius> I assume it's flip (->) ?
21:54:05 <edwardk> it was the one you asked for in Contravariant
21:54:06 <edwardk> yeah
21:54:37 <edwardk> https://github.com/ekmett/contravariant/blob/master/Data/Functor/Contravariant.hs bottom of that file
21:54:54 <ddarius> Then there definitely is an adjunction.
21:55:21 <edwardk> the problem is the materialization of that rseems to require classical reasoning
21:55:34 <ddarius> One way will, the other way won't.
21:55:42 <edwardk> because i wind up having a counit that takes ((a -> r) -> r) -> a
21:56:11 <edwardk> i got the one a -> (a -> r) -> r â€” one that is pretty obvious to anyone who has written anything in CPS ;)
21:56:31 <ddarius> However, your class is messed up.  You want an isomorphism between Hask(f a, b) ~ Hask^op(a, g b)
21:56:44 <ddarius> But you are requiring Hask(f a, b) ~ Hask(a, g b)
21:57:03 <edwardk> so i need to flop around the a and g b
21:57:36 <tolkad> why aren't all Monads functors?
21:58:01 <edwardk> tolkad: because people back in 98 decided that that might be too hard for folks to remember to to define a functor every time they made a monad
21:58:23 <edwardk> tolkad: didn't say it was a good reason, but thats the reason
21:58:35 <ddarius> Yes, for the flip adjunction that gives rise to Cont, you have Hask(a, f b) ~ Hask(b, g a).
21:58:37 <dolio> People think that in 2011, too, judging from the shit storm on the libraries list.
21:58:49 <tolkad> yeah writing functor instances is hard
21:59:15 <edwardk> it makes me lose faith somewhat in humanity ;)
21:59:18 <horse_kicker> Bynbo7, thanks. i understand. i have \"a"->"b", how do i say : \"a"->"b" OR \"x"->"y". in other words, i need to avoid lists/tuples etc, and construct a name-value pairs using only function. Does it make sense?
21:59:29 <dolio> Including Oleg.
21:59:51 <edwardk> dolio: he was bound to have an off day sooner or later. regression to the mean and all that
21:59:55 <tolkad> horse_kicker: \x -> case x of { "a" -> "b"; "x" -> "y" }
21:59:59 <Bynbo7> horse_kicker: i dun't understnad, no
22:00:51 <tolkad> Bynbo7: he was asking about the existence of case expressions
22:00:51 <horse_kicker> tolkad, i'll try yours. thanks. 
22:00:56 <pastorn> joe6: i think i'm able to render a pretty telnet prompt now (!)
22:01:02 <monochrom> dolio: there are really people giving a reason different from "may break legacy code"?
22:01:29 <ddarius> edwardk: Join me in my quest to figure out how to eliminate most of humanity in a slightly more expedient manner than waiting.
22:01:35 <tolkad> > map (\x -> case x of { "a" -> "b"; "x" -> "y" }) ["a", "x"]
22:01:35 <lambdabot>   ["b","y"]
22:01:40 <dolio> monochrom: Oleg doesn't want to type 5 extra lines when he defines a monad.
22:01:48 <pastorn> joe6: like irssi or weechat or similar; an input field at the bottom and a list of communications above... this only took me like fiddy days to get to :/
22:02:05 <monochrom> humanity is a lost cause then. but I already said it yesterday. exterminate all humans.
22:02:09 <tolkad> monochrom: can't you just make it an extension in that case?
22:02:38 <joe6> pastorn: that was quick. I do not know how long it will take me to get to that level of productivity.
22:02:40 <tolkad> then we can all just put it in our cabal files and people will fix their legacy code if they want to use modern packages
22:02:48 <tolkad> and eventually it can be made standard
22:02:55 <monochrom> extension? like {-# LANGUAGE Doesn'tNeedFunctor #-}? too many extensions?
22:03:11 <tolkad> monochrom: a temporary extension to phase it out
22:03:20 <tolkad> or rather, phase it in
22:03:39 <dolio> There's also a bunch of rambling discussion on whether join or (>>=) is 'easier' to define in general.
22:03:44 <pastorn> joe6: i'm saying it was slow :/
22:03:45 <horse_kicker> Bynbo7 : In math, a function takes an input and returns an output. so, \x->x+1 is the same as [1,2,3,...] -> [2,3,4...]. I want the reverse. i.e emulate a list of tuples but by using only functions. 
22:03:48 <dolio> Because apparently having both in the class is unacceptable or something.
22:03:53 <tolkad> monochrom: more like {-# LANGUAGE MonadFunctorConstraint #-}
22:04:06 <joe6> pastorn: oh, ok.
22:04:25 <pastorn> joe6: well, i've been working on a lot of other things on the side... i'm hoping to release something on hackage within two weeks (if i have the energy to learn how to properly create a cabal archive)
22:04:29 * ddarius should propose getting rid of defaulting.
22:04:49 <tolkad> horse_kicker: in untyped lambda calculus that is possible however haskell uses typed lambda calculus and it is not possible
22:05:01 <tolkad> horse_kicker: you must use a case expression
22:05:09 <edwardk> ddarius: so, leftAdjunct :: (f a -> b) -> g b -> a   , which by unit = leftAdjunct id, gives unit :: g (f a) -> a
22:05:24 <joe6> pastorn: cool. good luck.
22:06:57 <ddarius> edwardk: You'll find that unit and counit end up the same.
22:07:13 <ddarius> Well, not exactly the same.
22:07:24 <edwardk> hrmm, mine wound up flipped, must have to define them in terms of the other adjunct
22:07:38 * ddarius should watch Falling Down again.  I love that movie.
22:07:41 <tolkad> horse_kicker: does that make sense?
22:08:04 <edwardk> i'm in "hask^op' so they flopped
22:08:19 <tolkad> horse_kicker: you might be confusing haskell with untyped lambda calculus, where all functions can be written in terms of functions and function application
22:08:31 <horse_kicker> tolkad : i am new. slow to digest. so, googling a little before asking rubbish. 
22:08:56 <ddarius> horse_kicker is slow to digest so you should chew him thoroughly.
22:09:04 <monochrom> hahahaha
22:09:59 <newsham> > md5 "horse_kicker"
22:10:01 <lambdabot>   Not in scope: `md5'
22:10:20 <newsham> how do you digest "horse_kicker'?
22:10:30 <ddarius> newsham: Slowly.
22:10:43 <monochrom> add hydrochloric acid and some enzymes
22:10:53 <mauke> 3ae9db08dc324801a2158c78e8f366ea
22:10:55 <newsham> > m d 5 "horse_kicker"
22:10:56 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
22:10:57 <lambdabot>                           ...
22:11:25 <tolkad> newsham: try adding more spaces
22:11:30 <djahandarie> lambdabot could import puremd5 or something
22:11:43 <monochrom> no, lambdabot imports too much already
22:11:45 <tolkad> have lambdabot import Unsafe.Coerce
22:12:02 <newsham> lambdabot's got a huge trade deficit
22:12:41 <tg_> monochrom: ok, dexter
22:13:04 <tolkad> newsham: it must not be British lol
22:13:12 <monochrom> dexter will help exterminate all humans?
22:13:32 <tolkad> (the imperial British believed in mercantalism)
22:13:40 <tolkad> haha get it? lol
22:13:50 <edwardk> ddarius: i think the difference in our worldviews was that i was looking for the this to be Hask^Op -> Hask  rather than Hask -> Hask^Op â€” that way the resulting monad was a monad in hask
22:15:01 <newsham> > readProcess "/usr/bin/openssl" ["md5"] "horse_kicker"
22:15:02 <lambdabot>   Not in scope: `readProcess'
22:16:11 <Bynbo7> " I have an iOmega 1TB external that I rip all of my files to (AIFF).  I connect the external to my Mini via a 4-6 pin Firewire that I purchase on Amazon.  I have not compared the audible difference between a file on my Mini to one from my external. "
22:17:14 <edwardk> which yields Hask^Op(f a, b) ~ Hask(a, g b) â€” or leftAdjunct :: (b -> f a) -> a -> g b â€” or am i completely whacked?
22:17:16 <Bynbo7> argh, why can't i find the site with the handmade 'audiophile grade' firewire cables
22:17:21 <Bynbo7> whoops, wrong chan
22:17:38 <newsham> want a high quality audiophile ethernet cable with ultra low jitter?
22:17:57 <monochrom> and it has to be handmade
22:18:26 <edwardk> handmade ethernet cables have such a warm sound
22:18:31 <monochrom> (frankly after seeing human programmers' work I have lost faith of everything handmade)
22:18:35 <newsham> its all the odd harmonics, edk
22:19:07 <monochrom> (handmade = goofy. you can pretty much take that as an axiom.)
22:19:19 <newsham> mono: we prefer "bespoke"
22:19:24 <Bynbo7> when i find the link, you'll all get a good laugh =)
22:21:45 <edwardk> ddarius: ah i was off on rightadjunct
22:22:35 <pastorn> joe6: PM
22:23:15 <Bynbo7> http://locus-design.com/firewire_cables.html
22:23:22 <edwardk> once i flipped it around unit and counit would up looking like a -> f (g a) and a -> g (f a) â€” respectively so the adjunction between Op r and Op r never needs to extract from Cont
22:23:36 <horse_kicker> tolkad :  bla \x -> case x of { "a" -> "b"; "x" -> "y" }.  I want a bla2 :: String -> String -> bla with those two Strings added to the case expression. 
22:23:41 <monochrom> seems to be 404
22:23:44 <ian_> I tried to install leksah, and I can't seem to get a successful install of the haddock and glib dependencies. Anyone willing to help me with this? 
22:24:50 <tolkad> horse_kicker: \x y -> case x of {"a" -> case y of { "x" -> Blah1; "y" -> Blah2 }; "b" -> Blah3}
22:25:16 <ddarius> edwardk: Indeed.
22:25:24 <edwardk> i feel a lot better now =)
22:25:44 <applicative> ian_ how are you installing it?  what platform? 
22:26:25 <ian_> ubuntu, tried using the cabal install leksah
22:26:52 <ddarius> monochrom: Goofy is sometimes the goal.
22:27:04 <ddarius> (In fact, goofy is oftentimes the goal.)
22:27:18 <monochrom> yes. but not the goal when audiophile grade cables are at stake
22:27:46 <ian_> I got cabal through synaptic
22:31:37 <applicative> ian_ your `cabal install`  is presumably fine.  i notice they have a separate haddock-leksah on hackage.  It seems they are not just using the haddock executable
22:32:47 <ian_> applicative, link me?
22:33:34 <applicative> http://hackage.haskell.org/package/haddock-leksah  but I wonder if you have the haddock executable 
22:34:48 <applicative> ian_ you find haddock if you do ` which haddock ` or `haddock -v` or whatever
22:36:58 <horse_kicker> tolkad : [ ] is an empty list. how do i make an empty function?
22:37:08 <mauke> what's an empty function?
22:37:51 <horse_kicker> well, function and data are supposed to be synonymous, no? 
22:38:00 <mauke> no
22:38:15 <mauke> unless you're talking about not-haskell
22:38:31 <ddarius> In which case the answer is probably still "no."
22:38:32 <shachaf> horse_kicker: You can represent the empty list as a function, but it wouldn't be "the empty function".
22:39:06 <applicative> > let empty _ = error "That was the empty function" in empty 4
22:39:07 <lambdabot>   *Exception: That was the empty function
22:40:00 <ian_> figured out the problem I think
22:40:41 <applicative> ian_, oh good. 
22:44:04 <ian_> ty for your help :)
22:47:12 <ddarius> @hackage void
22:47:12 <lambdabot> http://hackage.haskell.org/package/void
22:48:06 <horse_kicker> f1 :: int ->  [(int,int)] -> int. it does a simple look up. f2 :: int -> (int -> int) -> int. should do a look up too. in f1, i can pass in a an empty [ ] in which case i do something. what do i pass to f2 for the same effect? am i repeating myself, or does this help?
22:48:14 <ddarius> edwardk: What about Data and Typeable?
22:50:01 <ddarius> And heck, Monoid and probably every other type class.
22:50:10 * applicative was expecting an empty data declaration
22:50:20 <edwardk> ddarius: for which?
22:50:39 <bapuche> Hi, I'm getting an error that seems likes it's a compiler error to me. Of course, I know I'm almost certainly wrong, but if someone can explain why that would be great. The code is posted at http://hpaste.org/paste/43222/puzzling_compiler_error
22:50:59 <ddarius> edwardk: void.  Also, does Eq return True or undefined?
22:51:20 <edwardk> ddarius: it spins forever because its defined by newtype deriving ;)
22:51:41 <edwardk> ddarius: as for monoid i didn't want mempty to inject a term into it
22:51:50 <edwardk> because that would defeat my purposes =)
22:52:11 <edwardk> Data/Typeable'd probably be fine
22:52:17 * applicative is getting an awfully Full looking value for ` fix void`
22:52:33 <ddarius> mempty is just void at the Void type.
22:53:04 <edwardk> ddarius: the problem is i don't want to provide Enum or Monoid because they both provide a direct way to extract a Void in a result type.
22:54:24 <edwardk> ok, D.F.C.A now provides Adjunction and DualAdjunction so i can have the unit :: a -> g (f a) one and the unitOp :: g (f a) -> a â€” one for adjunctions targeting the dual category
22:55:01 <edwardk> i didn't bother for data.functor.adjunction because there you can just swap the two adjoint functors to dualize
22:55:25 <applicative> bapuche I think you brought hpaste down with your compiler error
22:56:06 <bapuche> Oops, I should have checked that URL... Hold on.
22:56:07 <ddarius> Yeah, I thought about mentioning that you'd need two classes for the contravariant case.
22:56:16 <dolio> Oh no, hpaste is dead.
22:57:17 <bapuche> heh, it's not my fault, I swear! (I think... :))
22:58:30 <bapuche> Where else can I post code?
22:59:14 <tolkad> There are electronic billboards everywhere now
22:59:17 <tolkad> we are living in the future
23:00:05 <tolkad> I imagine a day when advertisements can be projected in front of drivers, right in the middle of the road
23:00:23 <ddarius> I was living in the future a minute ago but not anymore.
23:02:05 <monochrom> codepad.org is another good choice for paste bin
23:02:09 <dolio> edwardk: http://code.haskell.org/~dolio/agda-share/html/ContAdj.html
23:02:46 <monochrom> hpaste needs help
23:05:45 <bapuche> monochrom: Thanks. I put my code at http://codepad.org/N5HtVd77. Why does the compiler choke on line 24?
23:06:08 * ddarius uses his own personal notes from many years ago as study material.
23:08:35 <edwardk> dolio: cute =)
23:09:23 <dolio> I forgot to note that (R <= -)^op = (- => R), and vice versa.
23:10:57 <edwardk> now to add the comonad->monad transformer
23:11:04 * hackagebot adjunctions 0.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.2 (EdwardKmett)
23:11:29 <edwardk> i have a basic adjunction monad transformer, given a Traversable for the left adjoint
23:13:27 <monochrom> bapuche: "h.i" is a typo. "h,i"
23:13:36 <ddarius> Since left adjoints are cocontinuous, that should cover quite a few adjoints.
23:13:59 <edwardk> *nods*
23:14:08 <bapuche> monochrom: Geez. I feel so dumb. Thanks!
23:14:09 <ddarius> Actually, that's not the issue (though probably still relevant.)
23:14:38 <Philippa> *sigh*. I have Stuck in the Middle with You stuck in my head. This is half edwardk's and Conor McBride's fault, and half having watched Reservoir Dogs earlier tonight
23:14:40 <edwardk> i'm actively pursuing getting the missing traversables into base and into transformers, so it should be quite applicable
23:14:43 <ddarius> monochrom, Making People Feel Dumb Seven Days a Week
23:14:51 <edwardk> philippa: hahaha
23:14:55 <monochrom> haha
23:15:52 * ddarius considers watching Reservoir Dogs again.
23:16:45 <ddarius> Speaking of Conor, what was that thing you were talking about yesterday, edwardk?
23:17:01 <monochrom> a way to fight music stuck in your head is to get another music piece stuck in your head
23:17:04 <Philippa> the worst bit is, the paper reference was all about cutting bits off (regexes) too
23:22:56 <edwardk> ddarius: oh, one sec
23:26:19 <ddarius> @tell copumpkin You've probably read this, but if you haven't, it's entertaining and short: http://strictlypositive.org/Ripley.pdf
23:26:19 <lambdabot> Consider it noted.
23:29:42 <edwardk> ddarius: found it: http://personal.cis.strath.ac.uk/~dagand/papers/levitation.pdf
23:31:26 <ddarius> Ah, yes.  I do think I read this a while back.
23:31:38 <ddarius> Or something leading to it.
23:31:52 <edwardk> for my ComonadTrans instance for the comonadic version of the adjunction i need a Cotraversable ;)
23:32:12 <edwardk> that'll let me shove a w (g a) -> g (w a) through the right adjoint
23:32:31 <edwardk> er for the comonadic version of the adjunction transformer
23:35:57 <edwardk> which basically seems to amount to it having a uniform size
