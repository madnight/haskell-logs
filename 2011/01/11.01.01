00:00:04 <azaq23> Num a => [a] means the list has the same type a, which is a specific type a which is constrained by num, not the set of types which are constrained of Num
00:00:10 <augur> because (+0) :: Num a => a -> a
00:00:18 <azaq23> or?
00:00:34 <augur> so surely map (+0) [1 :: Int, 2 :: Double] == [(+0) 1, (+0) 2]
00:00:37 <augur> but then that should be
00:01:00 <roconnor> even in Num a => a -> a, the type parameter occurs twice
00:01:05 <augur> [((+0) :: Num a => a -> a) (1 :: Int), ((+0) :: Num a => a -> a) (2 :: Double)]
00:01:11 <dibblego> you could have a [Num a] if you rewrote Num as a data type
00:01:22 <augur> [((+0) :: Int -> Int) (1 :: Int), ((+0) :: Double -> Double) (2 :: Double)]
00:01:34 <roconnor> dibblego: now I see what you are getting at
00:01:39 <dibblego> roconnor, great :)
00:01:48 <roconnor> dibblego: can you make this problem appear without using java's generics?
00:02:06 <dibblego> roconnor, not this problem specifically
00:02:15 <roconnor> dibblego: any problem?
00:02:19 <ddarius> roconnor: The question then is in the Haskell "equivalent" you can't say Num Int.
00:02:27 <augur> > id [1 :: Int, 2 :: Double]
00:02:28 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
00:02:28 <lambdabot>         against inferred type ...
00:02:35 <augur> now thats where the type problem is happening tho
00:02:41 <dibblego> roconnor, well, type-classes must have a type variable, unlike Java interfaces, so it's difficult to say
00:02:43 <ddarius> That said, there is no trouble at all defining ListIDrawable.
00:02:46 <roconnor> ddarius: I don't understand your comment
00:03:12 <augur> > (id :: (Num a) => [a] -> [a]) [1 :: Int, 2 :: Double]
00:03:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
00:03:13 <lambdabot>         against inferred type ...
00:03:15 <augur> there see
00:03:19 <ddarius> roconnor: If there are no generics, then arguably there should be no parametric polymorphism in the Haskell side, but then there is nothing to constrain, though you could relax that.
00:03:23 <augur> > [1 :: Int, 2 :: Double]
00:03:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
00:03:24 <lambdabot>         against inferred type ...
00:03:29 <augur> yeah so
00:03:45 <augur> > [1 :: Int, 2 :: Double] :: [Num a => a]
00:03:45 <lambdabot>   Couldn't match expected type `a'
00:03:46 <lambdabot>         against inferred type `GHC.Types.D...
00:03:48 <dibblego> roconnor, consider e.g. interface CharSequence { int length(); Maybe<Char> get(int index); }, many beginners will try to write: class CharSequence where ...
00:03:57 <augur> yeah so. roconnor thats the problem
00:04:04 <roconnor> ddarius: if there are no generic then there should be no type constructors...
00:04:08 <augur> haskell really DOESNT allow you to do what you wanted to do
00:04:09 <augur> at all
00:04:21 <ddarius> roconnor: A type is a type constructor.
00:04:24 <augur> it seems like a num constraint inside [] is as good outside []
00:04:32 <dibblego> roconnor, really they have to write: class CharSequence s where length :: s -> Int ... *and take into account type-class resolution, which is completely foreign
00:04:46 <ddarius> But the point is the way interfaces work is completely unrelated to generics.
00:04:48 <dibblego> roconnor, unlike say, data CharSequence = C { length :: Int, ...
00:05:01 <roconnor> ddarius: then give me an example without using generics
00:05:11 <augur> roconnor: obviously dibblego's/ddarius's example wouldnt work if haskell had a looser notion of type membership
00:05:24 <augur> tho obviously itd be a different language then
00:05:25 <ddarius> roconnor: I already did.  Simply change List<IDrawable> into a ListIDrawable, i.e. a list of only IDrawables.
00:05:40 * roconnor ponders that
00:05:47 <ddarius> The fact that List is a generic type in Java isn't relevant here.
00:05:55 <dibblego> Java's generics alone throw a lot of curve-balls too, when it comes to making these analogies
00:05:59 <augur> generics are more like parametric types, surely
00:06:04 <augur> List<T> ~ [a]
00:06:09 <dibblego> augur, yes
00:06:13 <ddarius> augur: Generics -are- parametric types.
00:06:21 <dibblego> with a manual of caveats 
00:06:21 <augur> :P
00:06:27 <ddarius> dibblego: It is Java.
00:06:31 <augur> not that you can do it elegantly ofcourse
00:06:41 <ddarius> C# is better in this regard.
00:06:44 <augur> i mean, polymorphism
00:06:53 <dibblego> ddarius, yes, agree
00:07:12 <augur> not that polymorphism is necessary but parametricity without polymorphism, what a pain in the ass
00:07:22 <roconnor> UHC is lame for not having class constraints on existential types
00:08:27 <roconnor> thanks everyone, this was helpful
00:09:01 <roconnor> I no longer think that java's interfaces are roughly analogous to haskell type classes.
00:09:09 <roconnor> I now think that java's interfaces are very roughly analogous to haskell type classes.
00:09:15 <augur> hahaha
00:09:15 <augur> <3
00:09:36 <j-invariant> how?
00:09:52 <roconnor> [02:37] <azaq23> An interface declares some methods as abstract. You define classes which implement these. You can instantiate classes. How is that not basically the same as the haskell "A typeclass declares some functions. A datatype can implement these functions. You "instantiate" a datatype (by using a data constructor)."
00:09:53 <augur> i think its a rough analogy thats rough mostly because you can use interfaces as types in java but not in haskell
00:10:56 <roconnor> I think I might rephrase what azaq23 said a little
00:11:17 <dibblego> I can be sympathetic to "very roughly analogous", except I will probably retract when I next encounter the practical implications
00:11:31 <ddarius> Woo, I still have a little bit more pomegranate juice.
00:11:40 <roconnor> An interface declares some methods as abstract. You define classes which implement these. You can classes can be declared as instances of interfaces. How is that not basically the same as the haskell "A typeclass declares some functions. A datatype can implement these functions. data types can be declared as instances of classes"
00:12:11 <roconnor> An interface declares some methods as abstract. You define classes which implement these. Classes can be declared as instances of interfaces. How is that not basically the same as the haskell "A typeclass declares some functions. A datatype can implement these functions. data types can be declared as instances of classes"
00:12:38 <Jafet> Hmm, where is the instance Monad (Either e)?
00:12:46 <dibblego> Jafet, Control.Monad.Instances
00:12:58 <Jafet> Strange, I imported that
00:13:02 <roconnor> Jafet: IIRC it was muddled around a bit in the last ghc release
00:13:24 <roconnor> Jafet: what version of ghc do you have?
00:13:50 <Jafet> The glorious 6.12.3
00:14:58 <dibblego> Jafet, sorry I take that back, I actually got it from Test.QuickCheck
00:15:02 <augur> btw, C# sucks
00:15:03 <augur> just fyi
00:15:26 <ddarius> augur: And yet it is still -far- better than Java.
00:15:32 <roconnor> Jafet: I think that is too old, but I'm not an expert
00:15:38 <augur> ddarius: well thats undeniably true
00:15:42 <augur> for one, its not Java.
00:15:54 <roconnor> Jafet: you can get a lame instance from a lame version of the mtl, which is lame by the way
00:15:58 <Jafet> Yeah, the instance is not mentioned in the base documentation
00:16:19 <Jafet> Lame, like dr strangelove?
00:16:37 <roconnor> or can you update base in GHC 6.12.3?  That seems like it would be dangerous, though I don't know why.
00:17:09 <Jafet> I only use the instance in two lines, I could just not use the instance and make it six lines
00:17:29 <roconnor> you mean define the instance yourself?
00:17:43 <dibblego> xmonad-contrib failed to compile for me because of this darn Control.Monad.Either and mtl shenanigans
00:17:51 <Jafet> Well, that would then conflict with a future base, wouldn't it
00:17:56 <roconnor> yes it would
00:18:01 <augur> so, what are some novel or weird type systems i can read about
00:18:04 <roconnor> but there is no getting around it
00:18:18 <roconnor> so I'd go for it
00:18:25 <Jafet> Meh, I just used some ugly cases
00:18:30 <dibblego> augur, scala, to continue the theme of this discussion
00:18:44 <augur> dibblego: what kind of type system does scala have?
00:18:47 <azaq23> So what is the above mentioned [Num t => t] type good for?
00:18:57 <dibblego> augur, I struggle to summarise it :)
00:19:03 <azaq23> > ([1, 2] :: Num t => [t]) :: [Int]
00:19:03 <lambdabot>   [1,2]
00:19:11 <azaq23> > [] :: [Num t => t]
00:19:11 <lambdabot>   Overlapping instances for GHC.Show.Show ((GHC.Num.Num t) => t)
00:19:11 <lambdabot>    arising f...
00:19:22 <roconnor> azaq23: it was bad notation on my part
00:19:25 <augur> dibblego: :|
00:19:34 <roconnor> [exists t. Num t *> t] is more accurate
00:19:38 <Saizan> dibblego: is there a formal description of it somewhere?
00:19:41 <augur> dibblego: are you dibb-lego or dibble-go?
00:20:03 <ddarius> dibblego: Don't worry, the implementors struggle to implement it.
00:20:11 <dibblego> augur, an anecdote, consider for example, that the examples of Eq and Eq' I gave, Haskell distinguishes them immediately, where scala would allow you to use either implicitly or not at the use site
00:20:25 <dibblego> Saizan, Scala Language Specification (SLS)
00:20:45 <dibblego> Saizan, i.e. no
00:21:14 <augur> i think i'd like haskell but with the java-esque interface behavior for type classes (where [IDrawable] would work)
00:21:20 <Saizan> dibblego: no equivalent of SPJ writing papers about it, eh?:)
00:21:21 <dibblego> ddarius, yes, bugs galore, edwardk is going down a path I went down about 3 years ago
00:21:28 <augur> and where types and type-classes are on equal footing
00:21:40 <ddarius> augur: If Haskell behaved that way, that would break the vast majority of type classes.
00:21:45 <augur> which i suspect would be closer to some sort of type operator system
00:21:45 <dibblego> Saizan, there are a few papers e.g. Generics of a Higher-Kind (scala's higher-kinds) 
00:21:48 <augur> ddarius: oh?
00:21:52 <ddarius> However, there are some ideas along that vein that aren't so destructive.
00:22:14 <augur> how would it break most type classes?
00:22:15 <ddarius> augur: There's a reason Haskell doesn't suffer from the binary method problem.
00:22:23 <augur> whats the binary method problem
00:22:46 <ddarius> @google "binary method problem"
00:22:47 <lambdabot> http://lambda-the-ultimate.org/node/2744
00:22:47 <lambdabot> Title: This class type | Lambda the Ultimate
00:23:12 <augur> hmm now see this actually intersects with Unity3d's engine
00:23:23 <dibblego> as it happens, myself and two of edwardk's colleagues are writing a book about scala
00:24:09 <augur> in unity, you have "components" which are class definitions that you can add to an object (i imagine by way of having a list of instances of each component)
00:24:25 <augur> so in that way you can treat a single thing as an "instance" of multiple classes
00:24:36 <augur> except you have to refer to the components for the relevant methods
00:25:26 <augur> e.g. if X has property foo, obj.AddComponent("X") lets you then do obj.GetComponent("X").foo or obj.GetComponent<X>().foo
00:25:39 <augur> which seems roughly like mixins but not quite, obviously
00:26:43 <augur> but oh wouldnt it be interesting if there was something like a fusion object, where like.. f ((x :: X) :+: (y :: Y)) == f x if f :: X -> ..., and == f y if f :: Y -> ...
00:27:06 <j-invariant> augur: Either
00:27:39 <augur> but either needs the methods to be explicit, doesnt it?
00:27:56 <j-invariant> you could make a typeclass that sticks "Left" or "Right" in place automatically
00:27:59 <augur> like, you cant just write f as :: X -> ...
00:28:35 <augur> plus, thats type-level fusion
00:28:39 <mreh> I want to incorporate a Reader's environment in another, how would you do that?
00:28:40 <augur> not value level
00:28:50 <dibblego> mreh, ReaderT ?
00:29:02 <mreh> dibblego: in another Reader
00:29:11 <augur> no! run away! monad transformers are impossible to understand!
00:29:15 <mreh> the ask would clash
00:29:21 <dibblego> mreh, join ? :) 
00:29:37 <mreh> not the result of the computation, the environment
00:29:39 <dibblego> mreh, sorry, I'm not clear what you mean
00:30:19 <mreh> well, my main module executes in some environment, some of it's client code also executes in its own environment
00:31:55 <azaq23> roconnor: Ok, but has [Num t => t] any direct meaning in haskell? The error message from lambda bot seems to suggest that. There's this rule which lets you express and existential type by using forall in the interior of the type, so, if I'm not mistaken, [forall t. Num t => t] => exists t. Num t => [t]?
00:31:58 <mreh> I suppose I could just runReader inside some monadic code and pass the old environment as part of the new environment
00:32:01 <augur> j-invariant: i think you see where the problem with that would be, right?
00:33:03 <Saizan> mreh: you can use lift to disambiguate the levels
00:33:33 <mreh> Saizan: they're going to be different monads
00:34:19 <mreh> main is ReaderT IO () and it's client code a WriterT Reader a
00:34:34 <Saizan> azaq23: [forall t. Num t => t] is a list of polymorphic values, it's not equivalent to the other type with exist
00:35:16 <augur> ddarius: i still dont follow
00:35:31 <j-invariant> augur: no I don't
00:35:56 <augur> j-invariant: x :+: y isnt supposed to be either an X or a Y and who knows which
00:35:57 <ddarius> Read "On Binary Methods"
00:36:09 <augur> j-invariant: its not supposed to be Left x or Right y
00:36:18 <augur> j-invariant: its supposed to be Both x y
00:36:28 <azaq23> Saizan: But Num t => [t] would, judging by the used language, also be a "list of polymorphic values", so what's the difference here?
00:36:31 <augur> ddarius: you cant just give me a summary of the issue? :|
00:36:35 <Saizan> azaq23: given "data AnyNum = forall t. Num t => AnyNum t" then [AnyNum] would be, modulo the AnyNum constructor
00:36:42 <ddarius> augur: The summary is: Java's equals method.
00:36:44 <bsmntbombdood> so everyone says that /almost/ all expressions can have their type automatically determined 
00:37:02 <bsmntbombdood> the only instance i can see is read :: (Read a) => String -> a; are there any others?
00:37:19 <Saizan> azaq23: well, that would more be a polymorphic list, anyhow natural language doesn't help much here
00:38:02 <Saizan> azaq23: with foo :: Num t => [t] you get to pick a single type for each use of foo
00:38:27 <ddarius> bsmntbombdood: That has it's type automatically determined.
00:38:41 <Saizan> azaq23: with bar :: [forall t. Num t => t]  even using bar once you can pick a different type for each element
00:39:01 <bsmntbombdood> ddarius: it can't in all cases though right?
00:39:09 <ddarius> bsmntbombdood: There are two cases (ignoring the monomorphism restriction) in Haskell 98/2010 where type inference can fail but adding a type can resolve the problem.
00:39:21 <azaq23> > [20 :: Int] :: [Num t => t]
00:39:22 <lambdabot>   Couldn't match expected type `t'
00:39:22 <lambdabot>         against inferred type `GHC.Types.I...
00:40:03 <Saizan> azaq23: you can pick a different type when using it, so when constructing it you've to feed it values that are polymorphic
00:40:09 <ddarius> bsmntbombdood: The most obvious one, and perhaps what you were alluding to, is when a type constraint is ambiguous, e.g. in show . read, read doesn't know which instance to use.  The type of that expression would be something like: (Show a, Read a) => String -> String and so there is no way to fix a.
00:40:18 <ddarius> bsmntbombdood: The other case is polymorphic recursion.
00:40:19 <Saizan> azaq23: e.g. fromIntegral 4
00:41:05 <bsmntbombdood> ddarius: what's polymorphic recursion?
00:41:14 <Saizan> (polymorphism would me much easier to explain in System F ..)
00:41:25 <ddarius> bsmntbombdood: It's recursing at a different type.
00:41:36 <azaq23> oh, okay, this works:
00:41:38 <azaq23> > (([1, 2] :: [Num t => t]) !! 0) :: Int
00:41:38 <lambdabot>   1
00:41:39 <ddarius> Saizan: Agreed.  Explicit type abstraction and application clarify quite a lot.
00:42:16 <azaq23> But that seems a little bit like what an existential type is, if my understanding of these isn't incorrect
00:42:28 <bsmntbombdood> ddarius: example?
00:42:41 <Saizan> azaq23: it's the dual of what you would do with existential types
00:42:50 <ddarius> bsmntbombdood: For example, let f 0 x = show x; f (n+1) x = f n (x,x), here if f has type Int -> a -> String it recurses at type Int -> (a,a) -> String.
00:43:16 <j-invariant> bsmntbombdood: data Bacteria a = Nil | Cons a (Bacteria (a,a)) -- to d osomething like  singleFile :: Bacteria -> [a]
00:43:19 <ddarius> bsmntbombdood: In Haskell that let expression is ill-typed.  If you add an explicit type annotation, it will become well-typed.
00:44:04 <augur> ddarius: im still not getting it
00:44:04 <augur> but ok
00:44:06 <Saizan> azaq23: with [exists t. Num t => t] you could pick different types for each element when _construscting_ the list, and instead when you'll take it apart you'd have to not care about which specific type each element is
00:44:19 <ddarius> bsmntbombdood: As j-invariant indirectly suggests, polymorphic recursion comes up quite often when dealing with nested data types.
00:45:08 <bsmntbombdood> that seems pointless
00:45:11 <boegel> you guys, this is all so 2010
00:45:16 <ddarius> bsmntbombdood: What does?
00:45:37 <bsmntbombdood> ddarius: why is an annotation needed there?
00:46:15 <j-invariant> bsmntbombdood: data L v = Var v | Lambda (L (Maybe v)) | App (L v) (L v)
00:47:55 <azaq23> Saizan: I think I get what you mean, thank you, happy new year
00:48:10 <Saizan> azaq23: cheers :)
00:49:33 <ddarius> bsmntbombdood: Because polymorphically recursive functions can't have their type inferred in general.
00:49:38 <Saizan> bsmntbombdood: 
00:50:42 <bsmntbombdood> the compiler can't figure out f :: (Integral a, Show b) => a -> b -> String?
00:53:37 <j-invariant> The general problem of polymorphic recursion inference is undecidable
00:53:46 <j-invariant> The specific problem of 'f' is very easy
01:02:40 <Gracenotes> what function is this?
01:03:02 <Gracenotes> ...a hypothetical one then
01:03:25 <Gracenotes> is the proof of this constructive?
01:03:47 <Gracenotes> if it's an undecidability proof, I'm guessing not
01:10:15 * ddarius considers playing some old-school adventure game like Space Quest.
01:55:31 <qfr> I think LYAH is full of markup errors which make my job of converting it to LaTeX quite unpleasant
01:56:38 <qfr> Oh, nevermind, it actually validates in the W3 validator, then my parser must be slightly broken
01:57:18 <dibblego> does LYAH use HTML as the original source?
01:58:55 <qfr> dibblego probably not
01:59:03 <qfr> But the original source is not available online is it?
01:59:10 <dibblego> BONUS, ping
01:59:17 <qfr> Is he the author?
01:59:35 <dibblego> yes
02:00:48 <qfr> I'll try to run this thing through the HTML auto indentation of emacs to see where this <p> tag ends, because I don't see a matching </p> in like 20 lines, haha
02:01:01 <qfr> Other than that it's nearly done though
02:01:18 <qfr> Then I can finally read it on my crappy ebook reader
02:01:46 <dibblego> I'm sure BONUS would help you out converting it to other formats
02:03:02 <qfr> He appears to spell "et cetera" like this: Ekcetera
02:03:10 <qfr> I wonder what that is all about, random find
02:03:30 <qfr> I had no idea the author was hanging out in here, that's rare enough
02:04:13 <dibblego> I am writing a book using docbook at the moment, looked at latex, perhaps he is the smartest of all, using html
02:04:13 <ivanm> qfr: he probably thinks that spelling is funnier
02:04:18 <qfr> ivan: :P
02:04:39 <ivanm> IIRC, someone was already converting it to pdf, if that's why you're doing LaTeX conversion
02:04:56 <ivanm> qfr: have you tried doing html -> epub via pandoc or something?
02:05:00 <qfr> ivanm I got a PDF of it from somewhere
02:05:04 <dibblego> surely pandoc can do something
02:05:11 <ddarius> Last I checked <p> tags didn't need to be closed. http://www.w3.org/TR/html401/struct/text.html#h-9.3.1
02:05:17 <qfr> But it is not suited for my reader
02:05:17 <ivanm> I don't think going via LaTeX is the best for an ebook reader
02:05:19 <qfr> ddarius: Fail
02:05:52 <qfr> So <p>a\n is the same as <p>a</p>\n?
02:05:55 <qfr> Or something like that?
02:06:04 <qfr> I wasn't aware of that hmm
02:06:37 <qfr> emacs complains about this file, too...
02:06:42 <qfr> But the w3 validator said it was ok
02:13:25 <qfr> Wow, emacs has some limited LaTeX rendering within the editor. I had no idea. Looks really strange.
02:17:55 <falsealarm> noob question: I'm learning from write yourself a scheme in 48 hours and in the stage of making a simple parser.  for this the tutorial creates a function called "spaces"
02:18:01 <falsealarm> spaces :: Parser ()
02:18:07 <falsealarm> spaces = skipMany1 space
02:18:22 <falsealarm> and it combines with a character parser called symbol
02:18:40 <falsealarm> now it says: "Note that since we defined spaces in terms of skipMany1, it will no longer recognize a plain old single character. "
02:18:43 <falsealarm> why is that?
02:32:22 <dibblego> @type \f -> liftM join . Data.Traversable.mapM f -- is there a better way to write this?
02:32:23 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m, Monad m1, Data.Traversable.Traversable m) => (a1 -> m1 (m a)) -> m a1 -> m1 (m a)
02:42:14 <ddarius> :t Data.Traversable.mapM . (join .)
02:42:15 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m (m b)) -> t a -> m (t b)
02:44:24 <HugoDaniel> happy haskelling in 2011
02:52:16 <ddarius> "A different kind of example is provided by the category of first-order deliverables"
02:55:20 <dibblego> I really feel like fixing System.Process and System.Exit
03:41:55 <adnap>  haskell w00t
03:42:00 <adnap> happy near year!
03:42:11 <adnap> :)))))))))))))0
03:45:13 <xenyl> adnap: error, unmatched parentheses in: :)))))))))))))0 (new operator overload?)
03:45:18 <xenyl> :P
03:45:22 <xenyl> could not resist...
03:45:43 <adnap> i love yo
03:45:51 <adnap> sorry
03:46:09 <xenyl> why sorry, it is ny !
03:46:29 <adnap> 'cause i'm being stupid abdbbb drunk
03:47:05 <adnap> i do love haskekl
03:49:12 <adnap> no one is up
03:49:20 <adnap> i'm not tired yet
03:49:51 <adnap> xenyl: let's do some haskell?
03:50:12 <adnap> > foldr1 (+) [1,2,3]
03:50:13 <lambdabot>   6
03:50:26 <adnap> yes i can do it
03:50:41 <adnap> :t liftM2
03:50:42 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:51:23 <adnap> liftM2 (\x y -> x + y) (Just 2) 
03:51:36 <adnap> > liftM2 (\x y -> x + y) (Just 2) (Just 3)
03:51:37 <lambdabot>   Just 5
03:51:40 <adnap> aw yeah
03:52:06 <adnap> teach me somethign coool
03:54:33 <adnap> xenyl: okay good night
03:54:58 <Kaidelong> @ty liftA2
03:54:59 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
03:55:40 <adnap> people are still up
03:55:41 <adnap> wooo
03:56:02 <Kaidelong> @ty \x y z -> pure x <$> y <$> z
03:56:03 <lambdabot> forall b a a1 (f :: * -> *). (Functor f) => b -> (a1 -> a) -> f a1 -> f b
03:56:23 <adnap> > liftA2 (++) (Jusy "your ") (Just "mom")
03:56:24 <lambdabot>   Not in scope: data constructor `Jusy'
03:56:29 <adnap> > liftA2 (++) (Just "your ") (Just "mom")
03:56:31 <lambdabot>   Just "your mom"
03:56:35 <adnap> :))))))))0
03:56:56 <adnap> man i have a bump on my head
03:57:26 <sipa> still up?
03:57:30 <adnap> yeo
03:57:35 <adnap> yep
03:57:45 <sipa> it's almost 1pm here
03:57:53 <adnap> 5:56 here
03:57:59 <adnap> mann
03:58:05 <adnap>  fai
03:58:06 <adnap> dr
03:58:13 <adnap> sorry
03:58:14 <sipa> go to sleep :)
03:58:18 <adnap> :)))0000
03:58:26 <adnap> i had irc opennnnnn
03:58:38 <Kaidelong> @ty \x y z -> x <$> y <*> z
03:58:39 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
03:58:46 <adnap> okay
03:58:48 <adnap> i can do this
03:58:58 <adnap> :t ty
03:58:59 <lambdabot> Not in scope: `ty'
03:59:03 <adnap> wtf is ty
03:59:15 <Kaidelong> short for @type
03:59:23 <lelf> ?type 0
03:59:24 <lambdabot> forall t. (Num t) => t
03:59:28 <adnap> (++) <$> Just "3" <*> Just "4"
03:59:34 <adnap> > (++) <$> Just "3" <*> Just "4"
03:59:36 <lambdabot>   Just "34"
03:59:56 <adnap> applicative fgunctors bitches
04:00:05 <adnap> do you know tehnm?
04:00:22 <adnap> happy new year agian!
04:00:24 <adnap> :))))
04:00:29 <Kaidelong> I sense some year end related lack of sobriety
04:00:37 <adnap> yesss
04:00:51 <adnap> man fireworks arwe awesome
04:01:09 <adnap> artillery shells
04:01:30 <adnap> they are the onyy tings worth buying
04:02:13 <Adamant> adnap: homemade cannon are kinda iffy in the safety department.
04:02:22 <adnap> Adamant: whaaat?
04:02:30 <adnap> Adamant: you mzdde a canno?
04:02:31 <Adamant> don't know how else you're gonna use your artillery shells
04:02:37 <Adamant> adnap: hell no
04:02:40 <adnap> they come with a cannom?
04:02:44 <adnap> sorry
04:02:47 <adnap> they come with a cannon
04:02:56 <Adamant> well where else are you gonna fire them out of?
04:03:05 <adnap> well yeah
04:03:10 <adnap> it comes iwth a ncannon
04:03:12 <adnap> it
04:03:15 <adnap> dammit
04:03:18 <adnap> it's aweosme
04:03:42 <Adamant> how does that work? mortars and artillery pieces are restricted or banned in most countries
04:03:49 <adnap> usaaa
04:04:04 <Adamant> yah, they're restricted there
04:04:10 <adnap> where?
04:04:14 <adnap> not here
04:04:26 <Kaidelong> Adamant: "mortar" just being a kind of firework you launch from a tube, that blows up in the air
04:04:26 <Adamant> cannons and artillery pieces are Destructive Devices
04:04:34 <adnap> yep
04:04:42 <adnap> tha's what its lije
04:04:44 <Adamant> Kaidelong: I know but I'm trying to mess with drunk people. play along. :P
04:04:44 <adnap> like
04:04:49 <adnap> :)
04:05:03 <adnap> i can see yoyutr trickS":{
04:05:06 <adnap> :P
04:05:09 <Adamant> :P
04:05:15 <adnap> i love you
04:05:29 <Adamant> that's OK, you love everyone at this point :)
04:05:31 <adnap> anyone who love shaskell is a lover of mine
04:06:04 <adnap> damn, i should nevr have come in this channel
04:06:05 <Adamant> you might want to cut off the sauce a little bit at this point :P
04:06:13 <adnap> saucee?
04:07:47 <adnap> Adamant: you still awake?
04:09:36 <Adamant> yup
04:09:43 <adnap> yess!
04:09:55 <Adamant> I should be asleep but I napped most of the day
04:10:05 <adnap> can you teach me something aobyt haskell?
04:10:13 <Adamant> what do you want to know?
04:10:20 <adnap> cool stuff
04:10:25 <qfr> Output written on LearnYouAHaskell.pdf (322 pages, 1318192 bytes).
04:10:26 <Adamant> more importantly, where are you at right now with learning?
04:10:29 * qfr smiles
04:10:34 <adnap> i
04:10:39 <Adamant> yup, that's a good route to it!
04:10:50 <adnap> i've read learnyouahaskell
04:11:03 <adnap> happy near year AGAIN!
04:11:04 <adnap> wooo
04:11:41 <adnap> a bedtime haskell stor
04:11:42 <adnap> yy
04:11:44 <kingping> mapM_ happyNewYear' #haskell
04:11:45 <qfr> Wow this is pretty awesome
04:11:56 <qfr> Now I can format LYAH as I wish
04:11:58 <adnap> wtf?
04:12:01 <Adamant> adnap: BigNums!
04:12:05 <adnap> okay
04:12:07 <Adamant> Haskell has them
04:12:11 <adnap> i don't know about those
04:12:16 <adnap> i thougt Integer was big
04:12:19 <Adamant> it is
04:12:27 <adnap> what is bignum bfor then?
04:12:28 <Adamant> it's arbitrary precision
04:12:43 <Adamant> adnap: Integer is Haskell's bignum class
04:12:47 <adnap> right
04:12:48 <Adamant> or one of them
04:12:52 <adnap> i thought it was alreadft big
04:13:07 <Adamant> it is, but not if you use Int or WordX
04:13:14 <adnap> yeah
04:13:17 <adnap> int is fixed
04:13:28 <Adamant> it usually uses the GNU libgmp to implement it
04:13:50 <adnap> okay
04:13:55 <adnap> show something cool
04:13:59 <adnap> with lambda bott
04:14:04 <Adamant> now, libgmp use is optional, but a good idea if you want speed
04:14:23 <adnap> > putStr "i summon thee"
04:14:24 <lambdabot>   <IO ()>
04:15:02 <Adamant> > map reverse ["may","auld","acquaintance","be","forgot"]
04:15:02 <lambdabot>   ["yam","dlua","ecnatniauqca","eb","togrof"]
04:15:05 <Kaidelong> > text "i summon thee"
04:15:07 <lambdabot>   i summon thee
04:15:18 <adnap> aw lambda bot is the cutest bot
04:16:02 <Adamant> !vixen are you a bot?
04:16:27 <adnap> who is vixen?
04:16:34 <adnap> !vixen
04:16:36 <Adamant> lambdabot
04:16:52 <adnap> lambdabot goes by vixen/
04:16:53 <adnap> ?
04:17:00 <Adamant> yah
04:17:04 <adnap> no wayy
04:17:18 <adnap> > vixen!! dasher prancer
04:17:19 <lambdabot>   Not in scope: `vixen'Not in scope: `dasher'Not in scope: `prancer'
04:18:01 <Adamant> @vixen are you a bot?
04:18:01 <lambdabot> no, why? do i seem "botty"?
04:18:11 <adnap> aw
04:18:14 <adnap> clever clever
04:18:19 <adnap> lambdabot: yes!!
04:18:27 <adnap> lambdabot: you'tre a bot and you know it
04:18:33 <adnap> lambdabot: fess upp
04:18:44 <Kaidelong> @vixen confess
04:18:45 <lambdabot> what do you want to know about me?
04:18:59 <adnap> @vixen how old are you
04:18:59 <lambdabot> 19, you?
04:19:07 <adnap> your mom
04:19:17 <adnap> @vixen where are you from?
04:19:17 <lambdabot> Huntington Beach California
04:19:21 <adnap> bullshit
04:19:27 <JuanDaugherty> lol
04:19:34 <sipa> @vixen are you pretty?
04:19:34 <lambdabot> others have told me i'm very pretty
04:19:36 <adnap> @vixen have you ever been to the grand canyon?
04:19:36 <lambdabot> nope, but i'm sure i will one day
04:19:42 <adnap> fuccckk
04:19:52 <adnap> @vixen how many licks?
04:19:52 <lambdabot> let's just say a few
04:19:53 <sipa> @vixen are you single?
04:19:54 <lambdabot> yup, i'm single. you?
04:20:03 <adnap> @vixen to the center of a tootissse pop?
04:20:03 <lambdabot> who's to say?
04:20:41 <adnap> smarmy sasas
04:21:08 <adnap> @vixen who made you?
04:21:08 <lambdabot> that's a good question, who?
04:21:28 <adnap> @vixen i don't know, you tel ; me
04:21:28 <lambdabot> it's okay, i don't know either
04:21:47 <adnap> @vixen you're nice
04:21:48 <lambdabot> i'm nice to everyone!
04:21:52 <adnap> aw
04:22:54 <adnap> ok bed
04:22:59 <adnap> gnight
04:23:03 <adnap> happpy neyw year
04:23:22 <adnap> HASKELL RULES
04:23:24 <adnap> owpadf
04:23:39 <adnap> @vixen gnight
04:23:40 <lambdabot> Beer, it's so much more than just a breakfast drink!
04:23:42 <Kaidelong> dude, go drink some water and sleep
04:23:49 <adnap> i wll
04:26:30 <ddarius> @tell edwardk Do you remember the name of the restaurant (either the Japanese place or the place we actually went) that we met Matt at the first day I was in Massachussetts?
04:26:30 <lambdabot> Consider it noted.
04:28:01 <adnap> ddarius: happy new year!
04:28:14 <adnap> ddarius: i know you.  you are cool.
04:30:12 <dom96> Happy new year haskellers!
04:32:47 <adnap> dom96: :))))))0
04:32:54 <dom96> :)
04:32:55 <adnap> dom96: happy new year!!!!!
04:33:02 <dom96> adnap: Thanks! :D
04:33:06 <adnap> dom96: high five for haskell!
04:33:14 * adnap high fives dom96 
04:33:22 * dom96 high fives adnap 
04:33:23 <dom96> :D
04:33:24 <DevHC> i think lambdabot is a hooker
04:33:26 <adnap> aw yeag
04:33:31 <adnap> DevHC: totally
04:33:36 <adnap> @vixen are you a hooker?
04:33:37 <lambdabot> i truely am
04:33:39 <adnap> see!
04:33:42 <adnap> truth
04:33:51 <DevHC> @vixen troll
04:33:51 <lambdabot> Is that a real poncho or is that a Sears poncho?
04:33:56 <adnap> lol
04:34:01 <adnap> loooolll
04:34:13 <DevHC> @vixen troll sum moar
04:34:14 <lambdabot> you sound like an awesome guy... are you single?
04:34:24 <adnap> @vixen you know i am baby
04:34:24 <lambdabot> yeah, i know
04:34:34 <adnap> @vixen let's hook up
04:34:35 <lambdabot> yeah?
04:34:44 <adnap> @vixen we can do haskell all night long
04:34:44 <lambdabot> church is my favourite computer scientist.
04:34:48 <adnap> wtf?
04:35:53 <adnap> @vixen who is your favorite computer scientist?
04:35:53 <lambdabot> i dunno, who?
04:36:11 <adnap> @vixen church, duh!
04:36:11 <lambdabot> clarify...
04:36:18 <DevHC> ROFL
04:36:20 <adnap> @vixen church
04:36:20 <lambdabot> where can I a see a picture of you?? URL??
04:36:38 <adnap> @vixen gimme a break
04:36:39 <lambdabot> Bollox!
04:36:56 <adnap> @vixen i love you good night
04:36:57 <lambdabot> you love me? you don't even know me
04:37:00 <DevHC> @vixen http://lmgtfy.com/?q=trollface.jpg
04:37:00 <lambdabot> should i go there?
04:37:12 <adnap> lol
04:37:12 <lambdabot> adnap: You have 1 new message. '/msg lambdabot @messages' to read it.
04:37:26 <adnap> :))))))))))
04:37:51 <adnap> lambdabot: seriously, sghut up
04:37:53 <adnap> shut up
04:38:04 <adnap> lambdabot: just go to bed
04:38:05 <DevHC> u got spammed too?
04:38:21 <adnap> messages?
04:38:30 <adnap> it said i had a nmsg
04:38:49 <DevHC> say: @messages
04:39:00 <adnap> say: @messages
04:39:06 <DevHC> lol
04:39:25 <adnap> oh it was you
04:39:30 <adnap> msging me spam
04:39:31 <adnap> :)))
04:39:43 <adnap> i had to /msg lambdabot
04:39:58 <adnap> DevHC: gimme a new year hug
04:40:07 * adnap hugs DevHC 
04:40:15 * DevHC gives adnap an e-hug
04:40:20 <adnap> aww
04:40:31 <adnap> yay 2011
04:40:49 <DevHC> @vixen have a nice big cup of stfu
04:40:50 <lambdabot> niceness all the way around
04:41:07 <adnap> @vixen just go to bed you bitch
04:41:07 <lambdabot> no, i don't think i'm a bitch
04:41:27 <adnap> @vixen you will regret not going to bed
04:41:27 <lambdabot> cool
04:41:37 <adnap> @vixen just fuck you
04:41:37 <lambdabot> Too much cussing.
04:41:47 <adnap> @vixen okay, sorry
04:41:47 <lambdabot> it's okay, i forgive you
04:41:56 <adnap> @vixen but please, go to bed
04:41:56 <lambdabot> keep asking
04:41:58 <adnap> @vixen but please, go to bed
04:41:59 <lambdabot> don't beg
04:42:00 <adnap> @vixen but please, go to bed
04:42:01 <lambdabot> you're so polite :)
04:42:29 <DevHC> @vixen what's 2+2?
04:42:30 <lambdabot> why are you giving me a math test?
04:42:45 <adnap> @vixen you like those
04:42:45 <lambdabot> yeah, i like
04:42:48 <adnap> > 2 + 2
04:42:48 <lambdabot>   4
04:42:51 <adnap> ha ha
04:43:08 <DevHC> > length $ cycle "blarg"
04:43:15 <adnap> cam
04:43:23 <adnap> can't do that
04:43:23 <DevHC> > "hi"
04:43:23 <lambdabot>   thread killed
04:43:24 <lambdabot>   "hi"
04:43:25 <adnap> it's infinity
04:43:27 <DevHC> OWNED
04:43:33 <adnap> poor lambdabot
04:43:44 <DevHC> dons
04:43:48 <DevHC> listen to this
04:43:54 <DevHC> > length $ cycle "blarg"
04:43:56 * adnap hugs lambda bot
04:44:08 <adnap> shhhhhhhhh
04:44:09 <lambdabot>   thread killed
04:44:12 <adnap> DevHC: you're meann
04:44:15 <DevHC> > replicate 100 "sp4m"
04:44:16 <lambdabot>   ["sp4m","sp4m","sp4m","sp4m","sp4m","sp4m","sp4m","sp4m","sp4m","sp4m","sp4...
04:44:27 <adnap> > repeat "i love you"
04:44:28 <lambdabot>   ["i love you","i love you","i love you","i love you","i love you","i love y...
04:44:35 <DevHC> :O
04:44:43 <adnap> > repeat "go to bed"
04:44:44 <lambdabot>   ["go to bed","go to bed","go to bed","go to bed","go to bed","go to bed","g...
04:45:01 <DevHC> > l:cycle "ol"
04:45:03 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:45:03 <lambdabot>         against inferred ...
04:45:21 <DevHC> > "l" ++ cycle "ol"
04:45:25 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
04:45:35 <adnap> hehe
04:46:08 <DevHC> > length [1..]
04:46:13 <lambdabot>   mueval-core: Time limit exceeded
04:46:23 <DevHC> this however exits with a timelimit error
04:46:30 <adnap> DevHC: tell it a bedtime stor
04:46:31 <adnap> y
04:46:42 <adnap> it needs to go to bed
04:47:03 <DevHC> @vixen once upon a time there was a hooker who got W0N3D by some 1337 h4xz0r called /dev/humancontroller
04:47:03 <lambdabot> why me? :)
04:47:12 <DevHC> oh u guessed it
04:47:47 <adnap>  map ("goodnight in"++) $ map read [10..1]
04:47:58 <adnap> >  map ("goodnight in"++) $ map read [10..1]~
04:47:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:48:02 <adnap> noooooooooooo
04:48:07 <adnap> >  map ("goodnight in"++) $ map read [10..1]
04:48:08 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
04:48:08 <lambdabot>    arising from the literal `...
04:48:12 <adnap> damiiitt
04:48:50 <DevHC> intercalate ", " ["what", "the", "fuck"]
04:48:55 <DevHC> > intercalate ", " ["what", "the", "fuck"]
04:48:56 <lambdabot>   "what, the, fuck"
04:49:16 <DevHC> uhm
04:49:27 <banisterfiend> lambdabot: ruby > haskell
04:49:36 <dibblego> adnap, map f $ map g x is better written map (f . g) x
04:49:45 <adnap> im drunk
04:50:04 <adnap> fuctions composition bitchess
04:50:05 <DevHC> > "goodnight in " ++ (intercalate ", " $ map read [10,9,..1])
04:50:06 <lambdabot>   <no location info>: parse error on input `..'
04:50:11 <DevHC> > "goodnight in " ++ (intercalate ", " $ map read [10,9..1])
04:50:12 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
04:50:13 <lambdabot>    arising from the literal `...
04:50:21 <DevHC> @vixen r u fucking with me?
04:50:22 <lambdabot> yes, i am
04:50:25 <DevHC> :O
04:50:29 <adnap> ha ha
04:50:51 <adnap> you cant put it to bed  etehr
04:50:57 <adnap> contdown
04:51:32 <DevHC> @vixen go fuck with adnap
04:51:33 <lambdabot> Whoa, language! :)
04:52:03 <adnap> does this work
04:52:05 <sioraiocht> Haskell, rated arr?
04:52:06 <adnap> > [
04:52:07 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:52:16 <DevHC> > cycle "FUCK !!! "
04:52:17 <lambdabot>   "FUCK !!! FUCK !!! FUCK !!! FUCK !!! FUCK !!! FUCK !!! FUCK !!! FUCK !!! FU...
04:52:20 <adnap> > ["10", "9".."1"]
04:52:21 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
04:52:21 <lambdabot>    arising from the arithm...
04:52:24 <DevHC> whoa, language :]
04:52:29 <banisterfiend>  > your gay lol
04:52:33 <adnap> string isn't enum
04:52:36 <banisterfiend> > your gay lol
04:52:37 <lambdabot>   Not in scope: `your'Not in scope: `gay'Not in scope: `lol'
04:52:39 <adnap> i geusss
04:52:47 --- mode: ChanServ set +o Saizan
04:52:56 <adnap> can you not read to string?
04:53:05 <DevHC> banisterfiend: do u know the difference between "your" and "you are" ?
04:53:20 <adnap> map (++"hoooo" . read) [1, 2, 3] 
04:53:20 <banisterfiend> DevHC: yes, but the miss-spelling is so common it's part of internet culture
04:53:26 <adnap> > map (++"hoooo" . read) [1, 2, 3] 
04:53:27 <lambdabot>   Couldn't match expected type `a -> b'
04:53:27 <lambdabot>         against inferred type `[GHC.T...
04:53:35 <adnap> dammit
04:53:37 <banisterfiend> DevHC: esp when coupled with 'gay' and 'lol' like that
04:53:47 <DevHC> ohshit adnap
04:53:50 <adnap> > map ((++"hoooo") . read) [1, 2, 3] 
04:53:51 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
04:53:51 <lambdabot>    arising from the literal `...
04:53:55 <DevHC> read 1 is a fail
04:53:58 <DevHC> show 1 isn't
04:53:58 <adnap> i hate you lambda bot
04:54:03 <sioraiocht> :t read
04:54:05 <sioraiocht> :t show
04:54:05 <lambdabot> forall a. (Read a) => String -> a
04:54:06 <lambdabot> forall a. (Show a) => a -> String
04:54:09 <adnap> > map ((++"hoooo") . show) [1, 2, 3] 
04:54:12 <lambdabot>   ["1hoooo","2hoooo","3hoooo"]
04:54:14 <adnap> ty
04:54:19 <adnap> thank you
04:54:19 <sioraiocht> read parses a string, show makes one
04:54:24 <adnap> i knowww
04:54:27 <adnap> sorrry
04:54:46 <Kaidelong> > map ((++"hooo") . show) [1, [1], [[1]]]
04:54:47 <lambdabot>   No instance for (GHC.Num.Num [[t]])
04:54:47 <lambdabot>    arising from the literal `1' at <int...
04:55:10 --- mode: Saizan set -o Saizan
04:55:13 <Kaidelong> ah right
04:55:22 <DevHC> @vixen who is your administrator?
04:55:23 <lambdabot> i dunno, who?
04:55:23 <Kaidelong> I'd need existential types for that
04:55:30 <Saizan> yeah
04:55:40 <adnap> Saizan: i know you
04:56:07 <Saizan> adnap: it happens :)
04:56:20 <adnap>  Saizan happy new yeaar!!!
04:56:47 <adnap> we are all still alive on the planet earth
04:56:54 <adnap> in 2011
04:56:56 <adnap> wooo
04:57:03 <sipa> one more year...
04:57:24 <Kaidelong> > map ((++"hooo") . show) ([1, [1], [[1]]] :: forall a. (Show a) => [a])
04:57:25 <lambdabot>   No instance for (GHC.Num.Num [t])
04:57:25 <lambdabot>    arising from the literal `1' at <inter...
04:57:40 <adnap> Kaidelong: what are you trying to dooooo>
04:57:41 <adnap> ?
04:57:54 <adnap> lemme help
04:58:06 <adnap> :))\
04:58:13 <Kaidelong> oh I see
04:58:20 <adnap> oh man
04:58:23 <Saizan> Kaidelong: you'd need :: [exists a. Show a => a], actually
04:58:24 <dschoepe> Kaidelong: you need an existential type for that
04:58:24 <Kaidelong> you have to describe a data type that has less type parameters
04:58:30 <Saizan> Kaidelong: but that's not haskell
04:58:30 <adnap> it's already 7 here
04:58:42 <Kaidelong> than the right side
04:58:45 <Saizan> it's 14 here :)
04:58:52 <DevHC> already*
04:58:58 <adnap> Saizan: where do you live?
04:59:13 <Saizan> adnap: italy
04:59:15 <DevHC> lemme guess: at lambdabot's place
04:59:19 <adnap> Saizan: aw
04:59:26 <quuuux> hi all, I'm trying to use Data.Dynamic to do type-safe downcasting with typeclasses, using (right now) Num and Integral as examples. I have a definition that works if I enter it interactively in GHCi, but not in the source: http://pastebin.com/ur4cisTv
04:59:38 <adnap> Saizan: i want to live there with you
04:59:54 <adnap> Saizan: is it cooooool?
05:01:42 <Saizan> quuuux: at the ghci prompt there's more defaulting going on
05:01:42 <adnap> @vixen good night
05:01:43 <lambdabot> good? not great?
05:01:50 <adnap> @vixen goodnight
05:01:50 <lambdabot> good? not great?
05:02:05 <adnap> @vixen greatnight
05:02:05 <lambdabot> great is like a very good good
05:02:18 <quuuux> Saizan: oh, right. Defaulting confuses me. Time to read that section of the manual again
05:02:20 <dibblego> quuuux, if you start ghci with -Wall you will get warnings for any defaulting
05:03:14 <dibblego> :set -fwarn-type-defaults
05:03:53 <quuuux> aha. Right, my example -doesn't- actually work, it doesn't downcast with Int correctly. Back to the drawing board
05:07:35 <augur> ahh, the Maybe generic
05:07:39 <augur> how horrible
05:07:39 <augur> :(
05:10:23 <Saizan> Maybe generic?
05:11:19 <augur> Saizan: Maybe in C# as class Maybe<a>
05:12:55 <Xilon> augur: C# has monads?
05:13:12 <augur> Xilon: no, but Maybe is only a monad incidentally
05:13:16 <raichoo> LINQ is a monad
05:13:18 <augur> the important part is that its a parametric type
05:13:53 <raichoo> Therefore C# has monads.
05:14:01 <Xilon> Maybe without bind would be clumsy
05:14:15 <Xilon> raichoo: Isn't LINQ only for SQL (never used it)?
05:14:25 <augur> Xilon: its incidental to my purposes
05:14:25 <raichoo> Xilon: Nope
05:17:07 <monadic_kid> you don't need parametric polymorphism to write monadic code, you can write specific monads but you do need something like parametric polymorphism with higher-kinded polymorphism to abstract over all monad types. .NET has parametric polymorphism but it does not support higher-kinded types, no type constructor parameters or in otherwords generic-generics parameters
05:19:07 <monadic_kid> you might be able to generalize some code using parametric polymorphism and sub-type polymorphism but there is no support for higher-kinded polymorphism in .NET, C# or F#
05:19:36 <Saizan> iirc, F# calls monads Workflows
05:19:52 <raichoo> Saizan: yes
05:19:53 <sioraiocht> ugh
05:20:08 <raichoo> Sounds less scary than "monads" ;)
05:20:10 <monadic_kid> yes but they only support specific monad types
05:20:16 <sioraiocht> makes me want to vomit, heh
05:20:40 <augur> monadic_kid: and you need parametric polymorphism for parametric maybe :p
05:21:08 <Saizan> (even with a specific monad type i'm not sure how you write the type of return and bind without parametric polymorphism
05:21:11 <Saizan> )
05:22:08 <monadic_kid> Saizan: well i'd imagine if you had some concrete type like maybe just for ints then return's type would be an int
05:22:40 <monadic_kid> Saizan:er sorry i mean the actually maybe type
05:23:44 <DevHC> @bf ++++++++++ [ >+++++++>++++++++++>+++>+<<<<- ] The initial loop to set up useful values in the array >++. print 'H' >+. print 'e' +++++++. 'l' . 'l' +++. 'o' >++. space <<+++++++++++++++. 'W' >. 'o' +++. 'r' ------. 'l' --- ... 
05:23:44 <lambdabot>   Hello Worliii
05:24:06 <augur> oh god DevHC what are you doing
05:24:14 <augur> go to #esoteric with that
05:24:18 <monadic_kid> in F# they have parametric polymorphism but moands using computation worflows only work with particular kinds of monads like state monad
05:25:01 <monadic_kid> so writing more general functions such as sequence, fmap, etc is a bit more tricky to do without higher-kinded types
05:25:19 <DevHC> maybe lambdabot should go there, i'm not the one who provides @bf :P
05:28:03 <monadic_kid> i think the minium abstraction you need for monads is just higher-order functions, whether they would be actually useful without parametric polymorphism is another thing
05:32:52 <Xilon> "Workflows"? Eh, that's even worse than "Monad". At least "Monad" didn't have any previous meaning for me.
05:34:54 <monadic_kid> i think that was a suggestion from Simon Peyton-Jones to Don Syme
05:35:20 <monadic_kid> i don't mean the name but a suggestion to not used the word Monad
05:36:27 <DevHC> @fact u
05:36:27 <lambdabot> u: there is NO U
05:39:01 <Kaidelong> Don Syme implicated the haskell community in his book I think
05:39:23 <flamingspinach> "implicated" lol
05:39:27 <Kaidelong> everyone agreed the main problem with monads was the fact that they were called monads and he settled with workflows as the best suggestion
05:39:44 <ion> hehe
05:40:12 <ion> Let’s rename monads as something everyone’s all familiar with… Strings!
05:40:15 <Kaidelong> so F# has "computation workflows" instead of monads
05:40:21 <maskd> burritos
05:40:39 <Kaidelong> ion: the trouble is, very few people are familiar with it and the name "monad" convinces them that they don't want to be familiar with it
05:43:14 <ddarius> Kaidelong: I don't see how that is troublesome.
05:46:20 <Kaidelong> ddarius: the rationale was that they didn't want people to take the attitude "I don't want to learn F# because it has monads in it and monads are unreasonably hard"
05:46:44 <Kaidelong> the claim was that it was observed with criticism of haskell on social networking websites
05:46:56 <Kaidelong> people would say that haskell was hard because it had monads
05:48:16 <quuuux> hard science has a long and illustrious career of appropriating words with previous meanings anyway. It took me years to figure out that 'work' in mechanics was a different concept than what I was used to thinking of as 'work' in a non-physics context
05:48:42 <ddarius> Guglielmi is a humorist. "Deep Inference: Web-based Quantum Bio-cryptography for Creative Nano-security"
05:49:39 <DevHC> @pl (\7 -> "a" f)
05:49:40 <lambdabot> const f
05:49:41 <DevHC> @pl (\7 -> "aa" f)
05:49:41 <lambdabot> const ("aa" f)
05:49:44 <DevHC> wtf?
05:50:20 <DevHC> @wtf pl
05:50:21 <lambdabot> Maybe you meant: bf ft wn
05:50:46 <Kaidelong> @unpl const ("aa" f)
05:50:47 <lambdabot> (\ _ -> "aa" f)
05:50:52 <Kaidelong> > "aa" f
05:50:54 <lambdabot>   Couldn't match expected type `t1 -> t'
05:50:54 <lambdabot>         against inferred type `[GHC....
05:51:11 <hewei> Hi there! Can I run Haskell on JVM please, like compiling .hs to bytecode? 
05:51:32 <token22> hey
05:52:30 <token22> could you help me to write f x y z = g h(x y z) to pointfree?
05:52:51 <augur> DevHC: lambdabot is fucked up
05:52:55 <Kaidelong> hewei: http://www.cs.rit.edu/~bja8464/lambdavm/ is what I found, but it looks like it sells itself as a proof of concept
05:53:27 <quuuux> pl isn't type aware, IIRC, so if you put garbage in it won't complain and just spit garbage out
05:53:31 <Kaidelong> @pl (\x y z = g h(x y z))
05:53:32 <lambdabot> (line 1, column 9):
05:53:32 <lambdabot> unexpected "="
05:53:32 <lambdabot> expecting pattern or "->"
05:53:33 <augur> token22: what is h(x y z) supposed to be
05:53:38 <hewei> Kaidelong: Thanks! I'm looking for something more practical
05:53:43 <Kaidelong> @pl (\x y z -> = g h(x y z))
05:53:43 <lambdabot> (line 1, column 12):
05:53:43 <lambdabot> unexpected "="
05:53:43 <lambdabot> expecting lambda abstraction or expression
05:53:46 <ion> @pl \x y z -> g h (x y z)
05:53:47 <Kaidelong> @pl (\x y z -> g h(x y z))
05:53:49 <lambdabot> ((g h .) .)
05:53:53 <lambdabot> ((g h .) .)
05:54:04 <hewei> Kaidelong: Like the possibility of hosting a Haskell webapp on GAE
05:54:09 <augur> token22: what is h(x y z) supposed to be
05:54:13 <ddarius> @pl ap id id (ap id id)
05:54:16 <lambdabot> ap id id (ap id id)
05:54:16 <lambdabot> optimization suspended, use @pl-resume to continue.
05:54:24 <token22> augur actually i only got this without describe of h g
05:54:45 <augur> token22: no i know but is h an argument to g, or is that h applied to x y and z?
05:55:50 <Kaidelong> hmm does LLVM have a backend for the JVM?
05:56:05 <token22> hm looks like i wrote it incorrectly here, it should be g (h x y z)
05:56:10 <augur> @pl (\x y z -> g (h x y z))
05:56:10 <lambdabot> ((g .) .) . h
05:56:21 <Kaidelong> maybe you could go GHC -> LLVM -> JVM
05:56:42 <augur> ion, Kaidelong: DONT YOU WISH YOU WERE A LITTLE MORE PATIENT HUH
05:56:43 <augur> :P
05:57:09 <augur> yeahh look at me, master helper
05:57:11 <augur> nyahhhh
05:57:12 <ion> augur: Not really.
05:57:14 <augur> ion: :P
05:57:47 <augur> i wouldve loved it if that misunderstanding had led to huge confusion
05:58:03 <token22> hm can't get that 
05:58:07 <augur> token22: ey?
05:58:12 <hewei> Kaidelong: Thank you for your advice
05:59:22 <DevHC> what's so EPIC about java?
05:59:38 <augur> DevHC: EClIPse
05:59:44 <augur> except its dyslexic.
06:00:03 <augur> but java isnt prejudiced.
06:00:12 <ion> You must mean dislyxec.
06:00:33 <augur> no just lysdexic
06:00:42 <DevHC> anything else?
06:00:45 <token22> augur ey? problem is that i can't use interpreter
06:00:53 <augur> token22: i dont follow
06:00:53 <tarrasch> Hello! I'm having trouble with haskell "being static", It's probably a common problem. http://hpaste.org/42687/adding_values , any suggestions?
06:01:27 <tarrasch> I'm probably thinking to Object-oriented ...
06:02:48 <quuuux> hmm. Do methods from a typeclass need to be visible in order to define an instance, or does just the typeclass need to be visible?
06:03:02 <Kaidelong> tarrasch: that example is subsumed by the Num typeclass
06:03:16 <tarrasch> subsumed?
06:03:34 <Kaidelong> what you are trying to achieve, you already can do it with the num typeclass, basically
06:03:48 <monadic_kid> tarrasch: that is not going to work without either higher-rank polymorphism or a type constraint with like Num
06:04:23 <tarrasch> Kaidelong, you mean I could use toInteger and functions like that?
06:05:09 <Kaidelong> fromIntegral, floor, ceiling etc, if you need to get different number types to play nice
06:05:12 <token22> looks like nobody knows it without @pl
06:05:21 <DevHC> lol
06:06:12 <tarrasch> Kaidelong, ok, you're right I could for this particular case solve it with using those functions, but are their any more general way?
06:06:15 <Kaidelong> but if you want a function that takes two arguments of the same number type, it's type is (most generally) "(Num a) => a -> a -> b"
06:06:48 <Kaidelong> @ty (+)
06:06:50 <lambdabot> forall a. (Num a) => a -> a -> a
06:07:45 <DevHC> @elite rollertoaster
06:07:45 <lambdabot> r0LL3r7o4$+er
06:07:46 <augur> has anyone ever poked around with the idea of typeclass-driven semantics?
06:07:48 <DevHC> @elite rollertoaster
06:07:49 <monadic_kid> tarrasch: basically you function arguments should work with your Value data-type
06:07:49 <lambdabot> ROLlERT04ztER
06:07:51 <DevHC> @elite rollertoaster
06:07:52 <lambdabot> RolLER+Oas73R
06:07:54 <DevHC> @elite rollertoaster
06:07:54 <lambdabot> R0|l3r70Az7eR
06:08:18 <augur> @elite DevHC i will fuck you up
06:08:18 <lambdabot> d3vHC I wIlL fU(K u up
06:08:40 <DevHC> @tell augur NO U
06:08:40 <lambdabot> Consider it noted.
06:08:56 <augur> @elite no u
06:08:56 <lambdabot> no u
06:08:59 <augur> hahaha
06:08:59 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
06:09:37 <tarrasch> monadic_kid, I don't get that, can you clarify?
06:10:00 <monadic_kid> tarrasch: what you're doing isn't going to work without haskell type extensions, what you should probably be doing is defining + or similliar for your Value types
06:10:37 <tarrasch> monadic_kid, ah, you mean the solution with "code-copying"?
06:11:46 <tarrasch> what type extension are you reffering to anyway?
06:13:11 <Xilon> What would be the type of VInt 5 + VDouble 5.0?
06:13:33 <monadic_kid> tarrasch: code copying? you mean repetitive boilerplate code? without using extensions or macro system such as template haskell yes you'll need to defin +,-, etc in terms of your Value type or (depending on what you're doing) you could define another constructor called Add or with extensions operator constructor :+: which takes Value types as arguments but then this looks like parse tree for some language
06:13:42 <Xilon> Can't make (+) be a -> a -> Maybe a
06:14:19 <DevHC> what's cale's irc nickname?
06:14:37 <Xilon> Umm, Cale?
06:14:45 <DevHC> yes, TEH_C4L3
06:14:52 <Xilon> Yes, Cale
06:14:59 <DevHC> kthx
06:15:16 <DevHC> i mean: Cale Gibbard <cgibbard@gmail.com> :P
06:15:23 * Xilon is lucky you weren't asking "What's who's irc nickname"
06:15:50 <Xilon> DevHC: That's the one
06:16:04 <monadic_kid> tarrasch: well one extensions is higher-rank polymorphisim: http://en.wikibooks.org/wiki/Haskell/Polymorphism#Higher_rank_types
06:17:12 <Xilon> Hmm, how does that "do $ ..." notation work in the pasted code? I don't see how it falls back to Nothing
06:17:15 <monadic_kid> tarrasch: but don't expect to get much type inference if any without the need for explicit type annotation when you start to use these features
06:17:49 <monadic_kid> Xilon: yes he isn't covering all the cases
06:18:32 <monadic_kid> Xilon: he should be getting warnings about it
06:18:32 <Xilon> Ah, thought there was some "magic" going on there. Never seen "do $" before
06:18:51 <monadic_kid> Xilon: doing do $ is quite pointless
06:19:02 <monadic_kid> Xilon: $ do makes a lot more sense
06:19:57 <Xilon> isn't a 'return' still required, or does do notation do it automatically for the last value?
06:20:13 <Kaidelong> if the last value is a monad
06:20:16 <Kaidelong> then that'd fine
06:20:20 * Xilon is more used to bind notation
06:20:21 <Kaidelong> all return does is wrap something in a monad
06:20:27 <Kaidelong> @ty return
06:20:28 <sipa> every statement within a do block must be a monadic action
06:20:29 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:20:56 <sipa> if you want something else in there, you need to lift it to be a monad, eg. using return
06:21:05 <quuuux> @pl (\ g -> f h g . a)
06:21:06 <lambdabot> (. a) . f h
06:21:08 <sipa> has nothing to do with where in the block it occurs
06:21:15 <monadic_kid>  yeah he's using maybe monad and he's always returning a Maybe value but i don't see the point of using a maybe monad in his example
06:21:36 <Kaidelong> > do {return 4; return 6}
06:21:37 <lambdabot>   No instance for (GHC.Show.Show (m b))
06:21:38 <lambdabot>    arising from a use of `M4003806445...
06:21:53 <Xilon> It doesn't look like a Maybe value is actually returned though (no mention of Just)
06:21:55 <Kaidelong> > do {return 4; return 6; putStrLn ""}
06:21:56 <lambdabot>   <IO ()>
06:22:16 <Kaidelong> > do {return 4; return 6; []}
06:22:17 <lambdabot>   []
06:22:29 <monadic_kid> Xilon: that's true the code looks wrong
06:22:54 <Xilon> That makes sense then :)
06:23:57 <ion> > ((do return 4; return 6) :: [Integer], (do return 4; return 6) :: Maybe Integer)
06:23:58 <lambdabot>   ([6],Just 6)
06:24:23 <monadic_kid> I don't know how he/she is managing to get addValues to compile or get warnings about non-exhaustive patterns
06:24:52 <monadic_kid> i mean not get those warnings
06:26:04 <Xilon> ion: No mention of return or Just in the code though, which was tripping me up
06:28:22 <qfr> In case somebody is interested - I just finished a script which basically converts the HTML version of Learn You A Haskell to LaTeX so you can produce customised PDFs where you can alter the font, font size, whitespace for each page, etc. I coded this because the only PDF I found on Google had a regular sized font which is far too small for my crappy ebook reader, making it close to unreadable. 
06:28:22 <qfr> So I ended up making a bigger PDF version of LYAH. The Ruby code, PDFs in various sizes and the LaTeX output are available at: https://github.com/epicvrvs/learn-you-a-haskell I didn't add the cute pictures though, I'm sorry.
06:28:33 <qfr> Urgh, did that get cut off? This client is useless
06:28:40 <qfr> I am too used to chat in X-Chat
06:28:52 <xenyl> pastebin it, pass the url
06:28:53 <xenyl> :)
06:29:01 <vegai> don't think it did, qfr
06:29:33 <vegai> qfr: did you see that there's an epub version of it out there?
06:29:56 <qfr> vegai :O!
06:30:11 <vegai> it floated around proggit for a while
06:30:43 <vegai> http://www.reddit.com/r/programming/comments/es9o3/learn_you_some_erlang_for_great_good_in_epub/
06:30:52 <tarrasch> monadic_kid, sorry, i didn't compile the code, but I think it's right ...
06:30:53 <vegai> oops, wrong language 
06:30:56 <qfr> :P
06:31:02 <vegai> http://www.reddit.com/r/programming/comments/es29v/the_excellent_learn_you_a_haskell_for_great_good/
06:31:52 <tarrasch> Correct me if I'm wrong, but I want it to become Nothing if pattern matching fails, and for that I must be in do notation, no? the $ after the do is indeed weird of me :p
06:32:00 <qfr> Trying it on my reader
06:32:45 <tarrasch> sorry, I forgot the return and Justs for the first funciton
06:32:59 <vegai> tarrasch: _ -> Nothing ?
06:33:03 <qfr> tarrasch oh man it's really
06:33:10 <qfr> urgh wrong nick
06:33:17 <qfr> vegai: Wow that epub is really good
06:33:29 <vegai> qfr: cool. What reader do you have, by the way?
06:33:29 <tarrasch> vegai, I don't think it's neccesary, it's "done automatically"
06:33:46 <qfr> vegai wait no, unluckily it totally breaks all code on my reader
06:33:50 <qfr> Sony PRS-300
06:33:52 <vegai> tarrasch: oh you were in a monad?
06:34:01 <vegai> tarrasch: yeah, I suppose that's how Maybe monad works
06:34:02 <qfr> vegai: The code is "off screen" when it's too long :(
06:34:04 <tarrasch> vegai, yes
06:34:33 <monadic_kid> tarrasch: i'm not sure if pattern match failure applies to the case expression itself, only in bind expressions i think
06:34:54 <qfr> This is too bad because other than that this file is great
06:35:12 <monadic_kid> tarrasch: if you did something like Just x <- foo and foo returns Nothing then it would be a pattern fail
06:35:22 <qfr> I guess the person who coded this might have never tested it with such a small screen? Or it's a reader error
06:38:32 <vegai> gotta buy myself a 6" then, I guess
06:41:12 <tarrasch> monadic_kid, to the labroatory!
06:41:14 <qfr> The original message was: In case somebody is interested - I just finished a script which basically converts the HTML version of Learn You A Haskell to LaTeX so you can produce customised PDFs where you can alter the font, font size, whitespace for each page, etc. I coded this because the only PDF I found on Google had a regular sized font which is far too small for my crappy ebook reader, making it close to unreadable. So I ended up making a bigger PDF versio
06:41:14 <qfr> n of LYAH. The Ruby code, PDFs in various sizes and the LaTeX output are available at: https://github.com/epicvrvs/learn-you-a-haskell I didn't add the cute pictures though, I'm sorry.
06:41:16 * tarrasch starts to experiment
06:41:26 <qfr> All hail X-Chat and its proper line wrapping.
06:41:33 <Xilon> tarrasch: You still need to either return or explicitely construct it with Just
06:41:50 <qfr> Too bad epub doesn't work that well for me in that case
06:41:56 <qfr> But I shall use it in future I suppose
06:42:20 <Xilon> tarrasch: And as far as I know without specifying _ -> Nothing or similar, it won't fall back to returning Nothing...
06:44:00 <Xilon> tarrasch: Also you don't really need do notation here at all...
06:45:07 <tarrasch> Xilon, You're right! (let me just test the case thing)
06:45:20 <monadic_kid> i also don't think maybe monad is buying much in this instance
06:45:37 <monadic_kid> *isn't buying you much
06:45:59 <Xilon> Probably not. I don't know why you'd want to add VInt and VDouble anyway
06:47:12 <Xilon> If anything it would make more sense to make the VInt a VDouble and add the two doubles
06:47:29 <voidprayer> happy new year!
06:48:48 <Watermind> is there a specific name for the function   \_->undefined 
06:49:02 <mauke> const undefined
06:49:19 <Watermind> no I mean... when you talk about it, do you call it a specific name
06:49:29 <parcs> the constant undefined function :P
06:49:30 <Watermind> I've heard "everywhere undefined"
06:49:33 <Watermind> eh
06:49:34 <Watermind> :P
06:49:52 <quuuux> it's isomorphic to just _|_, isn't it?
06:50:27 <mauke> say hello to seq
06:50:30 <Watermind> not really
06:50:48 <Watermind> well mauke just answered you
06:51:05 <lopex> sdsdsdsdsdsdsdsdsdsdsdsdsdsdsdsd
06:51:10 <lopex> er, sorry
06:51:20 <Watermind> any strict function that takes _|_ as an argument will return _|_
06:51:44 <Watermind> but you can have strict functions that take \_-> undefined as an argument and do not return _|_
06:51:52 <tarrasch> Xilon, Yea, you're right about all of that
06:51:55 <mauke> incidentally, const undefined is a strict function
06:51:55 <zomg> Wait - haskell has something that is represented by the middle finger ascii?
06:51:55 <zomg> :D
06:52:09 <mauke> zomg: ⊥ actually
06:52:14 <Xilon> zomg: bottom
06:52:15 <monadic_kid> zomg: called bottom
06:52:25 <zomg> I see, what does it actually do?
06:52:33 <quuuux> nothing :)
06:52:38 <zomg> heh
06:52:40 <Watermind> it breaks your programs when you least expect it
06:52:41 <mauke> it's maths
06:52:47 <mauke> maths doesn't do
06:53:00 <Xilon> it teaches?
06:53:13 <Watermind> this is getting too zen for me :P brb
07:27:45 <pedro3005> do I need to install http://haskell.org/ghc/docs/6.10.4/html/libraries/network/Network.html ?
07:28:38 <Saizan> pedro3005: cabal install network
07:28:50 <Saizan> since that's the name of the package that module is in
07:29:05 <pedro3005> Saizan, do I need to run that as root?
07:29:20 <Saizan> no
07:30:25 <Saizan> check "ghc-pkg list network" first, if it lists a network-x.y.z you already have it installed
07:30:26 <Xilon> network is already in the Haskell Platform
07:31:58 <pedro3005> Could not find module `Network', Could not find module `Network.Socket'..
07:32:11 <pedro3005> I may be doing something silly
07:32:35 <Saizan> that's after installing it?
07:32:46 <pedro3005> well no, I didn't yet
07:32:53 <pedro3005> Xilon said it's already present
07:33:14 <Saizan> in the "haskell platform", how did you get your ghc?
07:33:24 <Xilon> If you installed the platform it should be. Check with `ghc-pkg list network as Saizan said though
07:33:36 <pedro3005> well I went ahead and installed it
07:33:38 <pedro3005> let's test
07:33:46 <pedro3005> works :D
07:33:54 <Saizan> yay
07:34:02 <Xilon> If you don't have the platform you proabbly don't have cabal either :P
07:34:13 <pedro3005> I had to install cabal
07:36:48 <quuuux> @pl \ a -> f $ a <* g
07:36:49 <lambdabot> f . (<* g)
07:37:04 <quuuux> I can't tell if that's better or worse :S
07:37:52 <quuuux> @src (<*)
07:37:53 <lambdabot> (<*) = liftA2 const
07:39:03 <Xilon> pointfree is a bit cleaner imo
07:55:51 <hpc> :t \a -> f $ a <* g
07:55:52 <lambdabot> forall b (f :: * -> *) a b1. (Show (f a), SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f b1), Applicative f) => f a -> b
08:08:18 <Mitar> http://hpaste.org/42688/typeable
08:08:22 <Mitar> is this OK code?
08:08:47 <Mitar> is it the same as "deriving instance Typeable1 NeuronOptions" woud do?
08:19:29 <Saizan> ~3
08:25:51 <Cale> Mitar: You should generally avoid writing your own instances of Typeable, but... hmm I think you don't want a mkTyConApp, since you're not actually applying the type constructor.
08:25:51 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
08:27:38 <Mitar> i agree
08:27:51 <Mitar> but the problem is that they haven't yet included that in stable GHC release: http://hackage.haskell.org/trac/ghc/ticket/1769#comment:13
08:28:33 <Cale> Oh, it's a data family?
08:28:54 <Mitar> yes
08:29:06 <Mitar> but the question is if the code is ok
08:29:18 <Mitar> is there a way to see what GHC 7.1 produces automatically?
08:29:26 <mux> @src Maybe mplus
08:29:26 <lambdabot> Nothing `mplus` ys = ys
08:29:26 <lambdabot> xs      `mplus` ys = xs
08:29:37 <Cale> Let's try it with a simpler type then...
08:29:47 <mux> @index mplus
08:29:48 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:30:06 <Mitar> http://research.microsoft.com/%7Esimonpj/papers/hmap/gmap2.ps << by code here it seems it is correct
08:33:11 <Cale> okay, it seems like your instance is identical to the one automatically generated, according to the Eq instance and GHC :)
08:34:20 * ddarius wonders if he can use contextual modal logic, the more or less standard Kripke semantics of modal logics, and the automata view of those semantics to cast binding as an automaton.
08:34:47 <mux> @pl \q ts x y -> M.lookup q ts >>= \qts -> M.lookup x qts `mplus` M.lookup y qts
08:34:48 <lambdabot> flip flip ((. M.lookup) . ap . (mplus .) . M.lookup) . (((.) . (.) . (>>=)) .) . M.lookup
08:36:51 <mux> @src Maybe (<|>)
08:36:52 <lambdabot> Nothing <|> p = p
08:36:52 <lambdabot> Just x  <|> _ = Just x
08:41:34 <copumpkin> I can't believe there's a book out there that says: "The programming language that will be our tool for this is Haskell, a member of the Lisp family."
08:42:57 <Adamant> well, given sufficiently liberal conflation of Haskell with the lambda calculus and Lisp with the lambda calculus...
08:43:59 <hpc> given sufficiently liberal conflation of Haskell with programming languages with Python with a python, my laptop eats bunnies
08:45:56 <Adamant> I knew that DARPA hydrocarbon eating robot was a questionable idea
08:46:49 <hpc> :D
08:48:43 <ddarius> "We propose an Internet query language based on intuitionistic linear logic."
08:49:32 <hpc> "intuitionist logic" :/
08:49:42 <hpc> there's nothing logical about intuition
08:50:09 <ddarius> Not "intuitionist", "intuitionistic".
08:50:30 <hpc> oh
08:50:50 * hpc doesn't see the difference...
08:54:33 <cpa> how to go back and forth from an IP written as an Int32 and an HostName (the type provided by Data.Network, synonym of String) ?
08:54:41 <cpa> is there something in the library already?
08:57:10 <stepb> \quit
08:59:02 <hpc> cpa: dunno about going from HostName to Int32, but going from Int32 to HostName should just be bitshifts and calls to show
08:59:19 <hpc> the first octet being the first four bits
08:59:26 <hpc> the second octet the second set of four, etc
09:08:07 <Saizan> fromIntegral ?
09:09:08 <RayNbow> oh wow... I still have an old version of the Haskell Platform on this machine... (from 2009)
09:09:13 <Saizan> ah, no, HostName is String
09:09:20 <RayNbow> a new year... time to update stuff :p
09:15:34 <ddarius> "However, linearity has yet to be implemented in Twelf, ..., in part due to unresolved complications that linearity creates in its metalogical apparatus."
09:20:15 <ddarius> Curse you Crary for not solving all my problems.
09:23:53 <Jesin> @src ap
09:23:54 <lambdabot> ap = liftM2 id
09:24:06 <Jesin> @src liftM2
09:24:07 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:24:52 <Hilbert> Hey how do you check the size of maxInt in haskell
09:24:55 <Jesin> @pl do x1 <- m1; x2 <- m2; return (f x1 x2)
09:24:55 <lambdabot> (line 1, column 12):
09:24:55 <lambdabot> unexpected ";"
09:24:56 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
09:25:01 <Jesin> > maxBound :: Int
09:25:03 <lambdabot>   9223372036854775807
09:26:20 <Jesin> Hilbert: use maxBound, restricted to whatever Bounded type you want to check
09:26:43 <Jesin> > logBase 2 $ fromIntegral $ (maxBound :: Int)
09:26:44 <lambdabot>   63.0
09:27:00 <Jesin> > logBase 2 $ fromIntegral (maxBound :: Int)
09:27:02 <lambdabot>   63.0
09:27:03 <Jesin> yeah that
09:27:06 <Jesin> :p
09:27:23 <parcs> :t logBase
09:27:24 <lambdabot> forall a. (Floating a) => a -> a -> a
09:27:29 <Jesin> > logBase 2 $ fromIntegral $ negate (minBound :: Int)
09:27:31 <lambdabot>   NaN
09:27:40 <Jesin> > logBase 2 $ fromIntegral $ (minBound :: Int)
09:27:41 <lambdabot>   NaN
09:27:48 <Jesin> > logBase 2 $ negate $ fromIntegral $ (minBound :: Int)
09:27:49 <lambdabot>   63.0
09:28:07 <Jesin> > logBase 2 $ fromIntegral (maxBound :: Word)
09:28:08 <lambdabot>   64.0
09:28:19 <Jesin> > minBound :: Word
09:28:21 <lambdabot>   0
09:28:25 <Jesin> > minBound :: Char
09:28:27 <lambdabot>   '\NUL'
09:28:33 <Jesin> > maxBound :: Char
09:28:35 <lambdabot>   '\1114111'
09:29:13 <Jesin> > logBase 2 $ fromIntegral $ ord (maxBound :: Char)
09:29:15 <lambdabot>   20.087461546321563
09:29:28 <Jesin> UTF-8 I suppose
09:30:01 <mux> unicode, rather; Char represents a unicode code point, there is no encoding involved
09:30:20 <Jesin> hm, k
09:30:22 <mikeg> cpa: here's some code I use to go from "192.168.1.1/24" -> Just (192<<24 + .., 24). http://hpaste.org/42690/tonetmask tell me if you find a good lib to do this kind of thing
09:30:49 <Jesin> > (Unsafe.Coerce.unsafeCoerce (maxBound :: Char)) :: Int
09:30:51 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
09:30:57 <Jesin> > (unsafeCoerce (maxBound :: Char)) :: Int
09:30:58 <lambdabot>   Not in scope: `unsafeCoerce'
09:31:00 <Jesin> ok, then
09:31:10 <Jesin> I'll check it on my own GHCi, I guess
09:31:47 <Jesin> Prelude> :t Unsafe.Coerce.unsafeCoerce
09:31:49 <Jesin> Unsafe.Coerce.unsafeCoerce :: a -> b
09:31:53 <Jesin> awesome type signature  :p
09:32:00 <parcs> > iterate (join (^)) 2
09:32:08 <lambdabot>   mueval: ExitFailure 1
09:32:09 <lambdabot>  mueval-core: Time limit exceeded
09:32:59 <j-invariant> War is peace! Ignorance is strength! p implies q!
09:33:10 <Jesin> XD
09:33:44 <parcs> > join (^) 2
09:33:48 <lambdabot>   mueval-core: Time limit exceeded
09:34:22 <parcs> weird
09:34:43 <parcs> :t join (^) 2
09:35:32 <lambdabot> thread killed
09:36:03 <Jesin> Control.Monad.join (^) 2 :: (Integral a, Monad ((->) a)) => a
09:36:32 <Jesin> oh, I need Control.Monad.Instances I guess
09:36:33 <mauke> :t ()
09:36:36 <lambdabot> ()
09:36:41 <mauke> > join (^) 2
09:36:43 <lambdabot>   4
09:36:49 <Kaidelong> I get the feeling my beloved lhs2tex somewhat conflicts with haddock
09:37:01 <Kaidelong> in which case I'd rather use lhs2tex and not haddock
09:37:08 <Jesin> Prelude Control.Monad.Instances Control.Monad> join (^) 2
09:37:10 <Jesin> 4
09:37:17 <Jesin> there it is
09:37:33 <j-invariant> One half of my program is easy to write in haskell, the other half easy in scheme
09:37:36 <j-invariant> I don't know what to do 
09:37:54 <Kaidelong> what'd make something easy in scheme but not in haskell?
09:38:04 <Jesin> use a foreign function interface?  :D
09:38:08 <j-invariant> the types in haskell
09:38:09 <Kaidelong> at the language level, as opposed to the meta-level
09:38:29 <mauke> just use Data.Dynamic
09:38:33 <Kaidelong> hmm, what is the type problem you are having?
09:38:44 <j-invariant> I solve the problem using GADT but it is very awkward to use
09:39:11 <j-invariant> first of all I have monoid instances for () and (Monoid m, Monoid n) => Monoid (m,n)
09:39:44 <j-invariant> so I read in a string e.g. "x y z w" and this builds up something which will call a function using (m,(m,(m,(m,()))))
09:39:52 <j-invariant> the number of variables in the string
09:40:17 <mauke> hello, rank-2
09:41:40 <Jesin> umm
09:42:22 <monadic_kid> why would you want to do that really
09:42:24 <Jesin> hmm, what's rank-2 btw?
09:42:43 <mauke> polymorphism, only harder
09:42:55 <monadic_kid> Jesin: polymorphic function arguments
09:43:09 * ddarius has a good use for attribute grammars.
09:43:23 <j-invariant> Kaidelong: thats it  basicalny
09:43:55 <Jesin> umm, which part is difficult in Scheme btw?
09:44:07 <monadic_kid> Jesin: http://en.wikibooks.org/wiki/Haskell/Polymorphism#Higher_rank_types
09:44:13 <j-invariant> I write the program in both languages and the scheme one is simpler but I can't extend it - whereas it's easy to extend in haskell
09:44:15 <roconnor> j-invariant: Why are you building a nested tuple instead of a list?
09:45:02 <j-invariant> roconnor: well if you have (*) :: Monoid m => [m] -> [m] -> [m] it might crash when the lists are different size
09:45:10 <j-invariant> or worse, it might just work
09:45:24 <roconnor> j-invariant: why do you think your lists will be the same size?
09:45:27 <j-invariant> tuples are just a long way to write m^n
09:45:36 <j-invariant> but obviously haskell dosn't have "n" for some reason
09:45:54 <j-invariant> roconnor: the lists should be the same size always, that's why I use tuples 
09:46:02 <mauke> haha, what
09:46:54 <roconnor> you said you read a string "x y z w" which will call a function using (m,(m,(m,(m,())))).  Presumably the length of the "list" will depend on the number of tokens in the string, yes?
09:46:54 <j-invariant> I don't know how to program haskell
09:47:00 <j-invariant> I put the type system to check my program works
09:47:03 <j-invariant> that's the idea, no?
09:47:15 <roconnor> that is the idea
09:47:19 <j-invariant> roconnor: yes if it were "x y x x" then we use (m,(m,()))
09:47:37 <j-invariant> this all works I'm just saying it's really awkward
09:47:47 <Jesin> umm
09:47:53 <j-invariant> so I rewrote in scheme but then there are other problems
09:48:01 <roconnor> so why do you think two "lists" genated by two strings will be the same length?
09:48:01 <Jesin> you're probably better off just doing something like
09:48:04 <j-invariant> I want my poridge just righ
09:48:16 <j-invariant> roconnor: oh there is only one string
09:48:35 <monadic_kid> so what's the (*) operator for?
09:48:38 <Jesin> if length xs == length ys then (*thing*) else error "mismatched list lengths"
09:48:41 <j-invariant> multiplication
09:48:55 <monadic_kid> but you said you're only dealing with one string
09:48:58 <roconnor> j-invariant: in that case generate a list of pairs instead of a pair of lists
09:49:17 <Jesin> or what roconnor said
09:49:30 <Jesin> [(a,b)] or whatever
09:49:35 <sipa> :t sequence
09:49:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:50:44 <Jesin> j-invariant: "list of pairs" sounds like a good idea, yes?
09:50:57 <j-invariant> I don't no why I don't have any pairs
09:50:58 <monadic_kid> is there any real examples of rank-n functions where n > 2?
09:51:32 <roconnor> monadic_kid: I wrote one in my Multiplate library recently
09:51:36 <roconnor> I was quite proud
09:51:51 <roconnor> monadic_kid: also the proper type of callCC is rank-3 I believe
09:52:08 <mauke> :t runST
09:52:10 <lambdabot> forall a. (forall s. ST s a) -> a
09:52:17 <mauke> hmm
09:52:47 <akamaus> is there some source code visualization tool available for Haskell?
09:53:25 <sid3k> which name is better for a library providing functional programming utilities like partial, compose, curry etc: functools vs funk
09:53:33 <sid3k> any suggestions please? 
09:53:45 <mauke> in what language?
09:53:52 <Jafet> "Prelude"?
09:53:53 <sid3k> javascript
09:54:05 <Jafet> I'd still call it prelude
09:54:11 <Jesin> lol
09:54:13 <monochrom> callCC :: ((forall b. a -> m b) -> m a) -> m a) is third reich^H^H^H^H^H rank
09:54:16 <mauke> I disagree with Prelude
09:54:22 <sid3k> prelude? what that means?
09:54:37 <mauke> what's loaded by default
09:54:45 <mauke> implicit definitions for your program
09:55:11 <monadic_kid> sid3k: it's a module which is implicitly imported/loaded in all other modules
09:55:13 <sid3k> hmm, prelude doesn't suit my library
09:55:25 <j-invariant> I don't knowwhat to do :/
09:55:26 <monochrom> overture
09:55:40 <ddarius> monadic_kid: One way rank-2 types come up is when you have first class "modules" (e.g. what Parsec does and also what happens in the dictionary translation of constructor classes.)  So if you have a first class "module" that contains a rank-2 type, you end up with a rank-3 type.
09:55:43 <roconnor> monochrom: though newType Void = Void Void ;  callCC ::  ((a -> m Void) -> m a) -> m a) -- is rank 1.
09:56:01 <sid3k> functools and funk, which one?
09:56:05 <ddarius> monochrom: That type is still only rank-2.
09:56:26 <ddarius> monadic_kid: Also, alternative existentials and universals will lead to higher ranked types.
09:56:32 <roconnor> ddarius: Are you sure it is only rank-2?
09:56:45 <roconnor> I guess we can test this question
09:57:35 <j-invariant> I think the idea of haskell is great but I don't have some insight needed to really use it
09:57:52 <roconnor> j-invariant: paste your code
09:57:54 <ddarius> j-invariant: That insight is called "practice."
09:58:58 <roconnor> ddarius: rank-3 mkPlate: http://hackage.haskell.org/packages/archive/multiplate/0.0.1.1/doc/html/Data-Generics-Multiplate.html#v:mkPlate
09:59:10 <monochrom> "insight" "understanding" is for essay writers
09:59:24 <sid3k> any ideas?
09:59:36 <monadic_kid> sid3k: fun
09:59:48 <roconnor> sid3k: something related to the word "combinator"
10:00:18 <monochrom> overture
10:00:22 <sid3k> monadic_kid: fun? not funk?
10:00:40 <monadic_kid> sid3k: funk is fine, i think you're over thinking it and beating yourself over nothing
10:00:58 <sid3k> roconnor: are my options not good? funk and functools
10:01:25 <monochrom> funk_and_functools
10:01:29 <sid3k> funk seems cool but some people may think that its stupid
10:01:35 <monadic_kid> programmers are there own worst enemy
10:01:41 <j-invariant> roconnor: http://pastebin.com/t7yrWzBJ
10:02:03 <Jafet> People are already writing lisp and haskell compilers to javascript, so what you're doing now is basically writing libraries for what will probably become the assembly language of the www.
10:02:14 <j-invariant> actually thats broken
10:02:20 <sid3k> monochrom: it's a library, not a short movie :)
10:02:57 <j-invariant> maybe I will start from scratch try something else
10:03:11 <monadic_kid> j-invariant: all this for reading in ints from a string?
10:03:51 <monochrom> haha
10:04:20 <Jafet> !quote generalization
10:04:25 <Jafet> @quote generalization
10:04:25 <lambdabot> No quotes match. It can only be attributed to human error.
10:04:36 <Jafet> @quote generali
10:04:36 <lambdabot> not-gwern says: 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras,
10:04:36 <lambdabot> and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero.
10:04:36 <lambdabot> Just like your statistic
10:04:59 <monochrom> @quote ksf premature
10:05:00 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
10:05:18 <monochrom> @quote monochrom premature
10:05:19 <lambdabot> monochrom says: premature generality is the root of OOP
10:05:25 <monochrom> those are the two
10:06:00 <ddarius> Actually procrastination is often the -motivating- reason for generalization.
10:06:19 <Jesin> ooh
10:06:20 <monochrom> premature procrastination is the root of ...
10:06:26 <Jesin> we should have lambdabot remember [13:05:33]	<ddarius>	Actually procrastination is often the -motivating- reason for generalization.
10:06:52 <Jafet> Bah, I can always procrastinate tomorrow.
10:08:56 <medfly> are you procrastinating procrastination?
10:09:32 <Boxo> Just try to get an even number of procastination levels
10:09:53 <medfly> :)
10:16:48 <Jesin> :t undefined
10:16:50 <lambdabot> forall a. a
10:17:13 <boegel> its now painfully clear that the Haskell Platform 2010 is outdated...
10:17:25 <mathijs> I want to fold over a list. the accumulator is a Maybe type. the moment it turns into Nothing, I want to stop the folding and return the remainder of items. is there a function for that?
10:18:06 <Jesin> hmm
10:18:24 <monochrom> this is why car manufacturers label their cars by the next year :)
10:18:25 <Jesin> takeWhile isJust . scanl, perhaps?
10:18:41 <Jesin> or, no wait
10:18:44 <azaq23> sounds like a unfoldr
10:18:47 <mathijs> Jesin: that doesn't return the accumulator
10:18:53 <Jesin> yeah, sorry
10:19:02 <mathijs> ah, lemme look that up then :)
10:19:41 <mathijs> nope, doesn't seem to be it.
10:20:08 <gchin> hi, I've cabal install'd a package and ghc-pkg lists it as good
10:20:16 <gchin> however, a ghci import gets me a "module not found"
10:20:44 <gchin> ghc-pkg describe on this package lists the module I'm trying to import under "exposed-modules" correctly
10:20:59 <monochrom> first step ghc -v
10:21:14 <monochrom> actually zeroth step check spelling
10:21:26 <Jafet> Haskell 98 was outdated by like '94
10:21:34 <azaq23> > unfoldr (\x -> if length x > 5 then Nothing else let p = 1 : x in Just (x, x)) []
10:21:35 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
10:22:07 <roconnor> > eq (!!2) (!!1)
10:22:10 <gchin> monochrom: spelling is definitely correct. what should I look for in the ghc -v output?
10:22:15 <lambdabot>   mueval: ExitFailure 1
10:22:15 <lambdabot>  mueval-core: Time limit exceeded
10:22:15 <medfly> why is it called Haskell 98 then?
10:22:16 <mathijs> azaq23: I'll try that one, thanks
10:22:20 <monochrom> depends on the output
10:22:36 <Jesin> > unfoldr (\x -> if length x > 5 then Nothing else let p = 1 : x in Just (p, x)) []
10:22:37 <Saizan> gchin: which package and which module?
10:22:37 <lambdabot>   [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1...
10:22:40 <Jafet> Presumably because they only got around to writing it down properly in '97.
10:22:47 <Jesin> > unfoldr (\x -> if length x > 5 then Nothing else let p = 1 : x in Just (x, p)) []
10:22:49 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
10:22:53 <Jesin> :D
10:22:55 <Jesin> I got it to work
10:23:05 <gchin> Saizan: chp-plus, and any module in it, e.g. Control.Concurrent.CHP.Actions
10:23:12 <Jafet> > take 6 (iterate (1:) [])
10:23:13 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
10:23:43 <roconnor> > eq (!!2) (!!1)
10:23:46 <lambdabot>   False
10:23:50 <roconnor> > eq (!!1) (!!1)
10:23:52 <lambdabot>   True
10:23:57 <Jesin> > unfoldr (\x -> let y = length x in if y > 5 then Nothing else Just (x, (y:x))) []
10:23:58 <lambdabot>   [[],[0],[1,0],[2,1,0],[3,2,1,0],[4,3,2,1,0]]
10:24:21 <gchin> my ghc -v output is: http://pastebin.com/ugyQqgpi
10:24:22 <j-invariant> > eq id id
10:24:25 <lambdabot>   mueval-core: Time limit exceeded
10:24:29 <Jesin> > unfoldl (\x -> let y = length x in if y > 5 then Nothing else Just (x, (y:x))) []
10:24:30 <lambdabot>   Not in scope: `unfoldl'
10:24:53 <parcs> @src eq
10:24:53 <lambdabot> Source not found. Sorry.
10:25:02 <monochrom> tons of "unusable", including "package chp-plus-1.3.1-bcba971ccc3f122a6a6963e7359272c4 is unusable"
10:25:10 <gchin> ah ok, it's not happy about quickcheck, yeah
10:25:21 <gchin> thanks, I can probably fix from here
10:25:54 <roconnor> > eq (and . take 2) (and . take 3)
10:25:56 <lambdabot>   False
10:26:01 <Saizan> the root seems to be a duplicated installation of Cabal-1.8.0.6
10:26:04 <roconnor> > eq (and . take 2) (and . take 2)
10:26:06 <lambdabot>   True
10:26:10 <cole> Speaking about arrays: What does 'isomorphic' mean in this context?: "we need to be sure we can take advantage of the special properties of the domains of these functions, which are isomorphic to finite contiguous subsets of the integers."
10:26:12 <Saizan> you should get rid of the one in the user db
10:26:14 <roconnor> > eq (!!0) (and . take 1)
10:26:15 <lambdabot>   True
10:26:45 <Jesin> eq (!!0) head
10:26:48 <Jesin> > eq (!!0) head
10:26:50 <lambdabot>   True
10:27:02 <Jesin> :t eq
10:27:04 <lambdabot> forall a. (Eq a) => ([Bool] -> a) -> ([Bool] -> a) -> Bool
10:27:04 <Jafet> @check (\xs -> (xs :: [Bool]) !! 1 == xs !! 1)
10:27:05 <lambdabot>   "*Exception: Prelude.(!!): index too large
10:27:27 <j-invariant> > eq (const False) (const False)
10:27:29 <lambdabot>   True
10:27:32 <Jafet> @check (\xs -> length xs > 1 && (xs :: [Bool]) !! 1 == xs !! 1)
10:27:33 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
10:27:40 <Jafet> Bah
10:27:54 <monochrom> trying to fix QuickCheck will just worsen the problem
10:28:10 <Jafet> @check (\xs -> length xs <= 1 || (xs :: [Bool]) !! 1 == xs !! 1)
10:28:11 <lambdabot>   "OK, passed 500 tests."
10:28:41 <parcs> > join eq (trace `ap` show)
10:28:42 <lambdabot>   Not in scope: `trace'
10:28:43 <Jafet> @check (\xs -> length xs < 3 || and (take 2 (xs :: [Bool])) == (and (take 3 xs))
10:28:43 <lambdabot>  Unbalanced parentheses
10:28:47 <Jafet> @check (\xs -> length xs < 3 || and (take 2 (xs :: [Bool])) == (and (take 3 xs)))
10:28:48 <lambdabot>   "Falsifiable, after 14 tests:\n[True,True,False,False,True,False,True,True,...
10:29:25 <monochrom> /usr/lib/ghc-6.12.3 ?  http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave is probably how you got to this state.
10:30:56 <ddarius> cole: Just read it as "the same as"
10:32:42 * hackagebot persistent-sqlite 0.3.0.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.3.0.1 (MichaelSnoyman)
10:33:09 <gchin> my system's screwy definitely from a mix of my package manager and cabal installing various packages
10:36:14 <ufopp>  
10:36:15 <ufopp> ;
10:41:12 <Jesin> umm
10:41:16 <Jesin> how does this eq thing work
10:41:19 <Jesin> I don't get it
10:41:22 <Jesin> where would I find the source
10:41:25 <Jesin> @where eq
10:41:25 <lambdabot> I know nothing about eq.
10:41:28 <Jesin> :(
10:41:31 <Jesin> @src eq
10:41:31 <lambdabot> Source not found. There are some things that I just don't know.
10:42:14 <phaer> Jesin: http://haskell.org/hoogle/?hoogle=eq
10:42:28 <mauke> phaer: how is that relevant?
10:42:54 <Jesin> no, phaer, I meant this
10:42:55 <Jesin> :t eq
10:42:56 <monochrom> read a tutorial or read http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1280006.3.1
10:42:57 <lambdabot> forall a. (Eq a) => ([Bool] -> a) -> ([Bool] -> a) -> Bool
10:43:08 <mauke> monochrom: how is that related?
10:43:26 <monochrom> oh? there is a function called "eq"?
10:43:27 <phaer> mauke: I thought Jesin was looking for the source of eq.
10:43:29 <Jesin> this thing tests equality on functions from [Bool] to Eq a
10:43:36 <parcs> eq looks like a wrapper around quickcheck
10:43:38 <mauke> phaer: he is
10:44:02 <Jesin> I guess last night someone linked me to http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:44:06 <Jesin> which looks like it's basically that...
10:44:11 <Jesin> so, I'll read that article
10:44:13 <Jesin> :p
10:44:15 <phaer> mauke: Then whats wrong with the hoogle search? (I'm a beginner myself)
10:44:26 <mauke> phaer: it doesn't mention 'eq' anywhere
10:44:53 <mauke> not surprising, considering that eq is probably a local @let in lambdabot
10:45:08 <phaer> mauke: right. sorry.
10:45:09 <monochrom> @undefine
10:45:13 <monochrom> :t eq
10:45:14 <lambdabot> Not in scope: `eq'
10:45:18 <monochrom> problem solved
10:45:19 <mauke> you killed it!
10:45:49 <monochrom> I'm frankly tired of people using @let and not cleaning up after themselves
10:46:03 <parcs> okay, after grepping through the logs:
10:46:03 <monochrom> I would even propose automatic @undefine every minute
10:46:13 <parcs> @let eq = let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
10:46:15 <lambdabot>  Defined.
10:46:21 <ddarius> The rule for 0 is linear logic is slightly subtle.
10:46:43 <hpc> @src (>=>)
10:46:43 <lambdabot> Source not found.
10:47:01 <Jesin> :t forsome
10:47:02 <lambdabot> Not in scope: `forsome'
10:47:08 <parcs> forsome is defined there
10:47:18 <Jesin> ah
10:47:21 <Jesin> got it
10:47:37 <roconnor> parcs: forsome's scope only extends so far
10:48:22 <monochrom> the real eq is at http://hackage.haskell.org/packages/archive/hxt/9.0.1/doc/html/Text-XML-HXT-Parser-XmlTokenParser.html#v:eq
10:49:11 <hpc> :t (>=>)
10:49:12 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:49:22 <hpc> @djinn (a -> m b) -> (b -> m c) -> a -> m c
10:49:23 <lambdabot> -- f cannot be realized.
10:49:32 <hpc> @djinn (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:49:32 <lambdabot> -- f cannot be realized.
10:49:35 <hpc> bah
10:49:55 <parcs> > eq (!!100) (!!100)
10:49:59 <lambdabot>   mueval-core: Time limit exceeded
10:50:05 <roconnor> @type \f g x -> f x >>= g
10:50:06 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
10:50:12 <Jesin> ooh, this is going to be horrible
10:50:15 <Jesin> @pl let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
10:50:16 <lambdabot> (line 1, column 5):
10:50:16 <lambdabot> unexpected "{"
10:50:16 <lambdabot> expecting "()", natural, identifier or "in"
10:50:21 <Jesin> damnit
10:50:25 <Jesin> it doesn't do {}
10:50:27 <monochrom> perhaps the real solution is I write a bot that randomly pollutes @let every minute until people are really fed up and disable it
10:50:31 <roconnor> hpc: \f g x -> f x >>= g
10:50:38 <Jesin> @pl let find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) in eq
10:50:39 <lambdabot> ((not . snd (fix (uncurry (ap (flip . ((,) .) . ap (flip . (ap .) . flip (ap . (if' .) . (. (. (False :)))) . ((False :) .) . (. (. (False :)))) (((True :) .) . (. (. (True :))))) (ap id))))) .) .
10:50:39 <lambdabot> liftM2 (/=)
10:50:54 <parcs> not bad
10:50:55 <Jesin> @pl eq = let find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) in eq
10:50:56 <lambdabot> eq = ((not . snd (fix (uncurry (ap (flip . ((,) .) . ap (flip . (ap .) . flip (ap . (if' .) . (. (. (False :)))) . ((False :) .) . (. (. (False :)))) (((True :) .) . (. (. (True :))))) (ap id))))) .)
10:50:56 <lambdabot>  . liftM2 (/=)
10:51:03 <ddarius> monochrom: We'll just write a bot that does @undefine every 30 seconds.
10:51:13 <hpc> roconnor: yeah, found it now
10:51:42 <Jesin> no, I think you should just have @let stuff expire after half an hour
10:51:44 <Jesin> or some such
10:52:19 <monochrom> yes of course, but I predict it won't happen
10:52:51 * ddarius doesn't see any point in that.
10:53:43 <hpc> Jesin: nah, @undefine is called frequently enough that it doesn't matter
10:54:57 <monochrom> not frequently enough IMO
10:55:08 <hpc> @undefine
10:55:15 <hpc> @forget
10:55:15 <lambdabot> Incorrect arguments to quote
10:55:26 <hpc> hmm
10:56:46 <roconnor> the @forget command forgets quotes
10:57:31 <hpc> @commands
10:57:31 <lambdabot> Unknown command, try @list
10:57:41 <hpc> @list
10:57:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:58:19 <hpc> it looks like @undefine just doesn't give output...
10:58:39 <roconnor> I think that is correct
10:58:57 <roconnor> I mean what you say is true
10:59:05 <roconnor> not that the behaviour is nessecarisly good
11:00:45 <monochrom> "no news is good news"
11:01:20 <pastorn>  what's up with GHC7 + cabal-install?
11:01:24 <pastorn> Setup: At least the following dependencies are missing:
11:01:26 <pastorn> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
11:01:38 * ddarius has had no problems with GHC 7 and cabal install.
11:01:47 <pastorn> that requirement on base seems impossible to me...
11:02:13 <pastorn> (got that from running $ sh bootstrap.sh)
11:02:51 <monochrom> perhaps build cabal-install by ghc 6.12.3 and then use the executable with ghc 7?
11:03:11 <monochrom> I haven't tried at all. don't trust me.
11:08:45 <roconnor> wow, this guy makes PowerShell sound really awesome
11:12:34 <dpratt71> roconnor: compared to any other console you're likely to find on a Windows machine, it is pretty awesome
11:13:11 <roconnor> dpratt71: it sounds better than any console I've used on any OS
11:13:34 <roconnor> it sounds like what I've always imagined a shell environment should be like
11:13:43 <roconnor> passing around typed data structures
11:14:04 <dpratt71> roconnor: I'm a fan, but I don't have a lot of experience with *nix shells, so...
11:14:34 <dpratt71> roconnor: that's the big win (passing structured data, not text) for sure
11:14:49 <Hilbert> Hey what does concat do?
11:14:57 <Jesin> :t concat
11:14:58 <lambdabot> forall a. [[a]] -> [a]
11:15:06 <hpc> > concat ["foo", "bar"]
11:15:06 <Jesin> that, apparently
11:15:07 <lambdabot>   "foobar"
11:15:16 <Jesin> concat [[1,2],[3,4,5]]
11:15:16 <hpc> concat isn't the function you want to use though
11:15:20 <hpc> join is more general
11:15:21 <Jesin> > concat [[1,2],[3,4,5]]
11:15:22 <lambdabot>   [1,2,3,4,5]
11:15:24 <hpc> :t join
11:15:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:15:27 <Jesin> > join [[1,2],[3,4,5]]
11:15:29 <lambdabot>   [1,2,3,4,5]
11:15:32 <hpc> > join ["foo", "bar"]
11:15:33 <lambdabot>   "foobar"
11:15:33 <Jesin> ...
11:15:42 <Jesin> concat shouldn't exist, and we should get the hierarchy right
11:15:44 <Jesin> :p
11:15:47 <hpc> quite
11:16:01 <Hilbert> Oh, I still haven't gottem onto monads, so I don't understand them
11:16:03 <hpc> concat and concatMap are aliases for join and (>>=) respectively
11:16:05 <roconnor> Jesin: some people thing that every instance of every class function should have it's own real name.
11:16:20 <hpc> Hilbert: no need to get monads yet; you see what join does for lists so just imagine that
11:16:30 <roconnor> *think
11:16:55 <hpc> roconnor: because what's the point of typeclasses unless we make them completely pointless :P
11:17:07 <hpc> can somebody review this? http://faidio.visuallycreated.com:8000/blog/view.cgi?id=8
11:17:23 <hpc> i want to make sure it's free of mistakes
11:17:36 <tswett> > concat (Just Nothing)
11:17:37 <lambdabot>   Couldn't match expected type `[[a]]'
11:17:37 <lambdabot>         against inferred type `Data.Ma...
11:17:46 <scree> @let areTwoIntegersEqual :: Integer -> Integer -> Bool = (==)
11:17:47 <lambdabot>   ScopedTypeVariables is not enabled
11:17:49 <hpc> > join (Just Nothing)
11:17:50 <lambdabot>   Nothing
11:17:53 <Saizan> in a context where i'm not using lists for non-determinism i would use concat rather than join
11:18:06 <roconnor> hpc: the point is to be able to write generic functions for libraries
11:18:06 <scree> @let areTwoIntegersEqual = (==) :: Integer -> Integer -> Bool
11:18:07 <lambdabot>  Defined.
11:18:09 <Jesin> > join Nothing
11:18:11 <lambdabot>   Nothing
11:18:29 <hpc> :t join ?Nothing
11:18:30 <lambdabot> Not in scope: `?'
11:18:36 <scree> @let areTwoIntsEqual = (==) :: Int -> Int -> Bool
11:18:38 <lambdabot>  Defined.
11:18:39 <ddarius> @quote trappes
11:18:40 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
11:18:40 <hpc> :t join ?f
11:18:41 <lambdabot> forall (m :: * -> *) a. (?f::m (m a), Monad m) => m a
11:18:41 <tswett> > join (Just (Just (Just (Just "ice for all"))))
11:18:43 <lambdabot>   Just (Just (Just "ice for all"))
11:18:47 * scree isn't sold on this
11:18:57 <Jesin> also, the page that used to be at http://haskell.org/haskellwiki/Functor_hierarchy_proposal was just a less complete version of another proposal, and I hope nobody minds that I made it a redirect
11:19:01 <hpc> ddarius: that quote is win
11:19:11 <tswett> @djinn Maybe a -> a -> a
11:19:12 <lambdabot> f a b =
11:19:12 <lambdabot>     case a of
11:19:12 <lambdabot>     Nothing -> b
11:19:12 <lambdabot>     Just c -> c
11:19:36 <Saizan> Jesin: less complete in which sense?
11:19:41 <tswett> I think djinn is specifically coded to give the most complex possible answer.
11:19:43 <Boxo> :t flip ap ?q
11:19:43 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?q::m a) => m (a -> b) -> m b
11:19:52 <roconnor> scree: 
11:19:57 <roconnor> instance Eq Int where
11:19:58 <roconnor>     (==) = eqInt
11:19:59 <roconnor>     (/=) = neInt
11:20:00 <Saizan> Jesin: maybe being less radical was the point there
11:20:03 <roconnor> that is from GHC.Base
11:20:06 <Jesin> hmm
11:20:07 <Jesin> =/
11:20:09 <hpc> tswett: because the simple answer is "undefined" :P
11:20:21 <tswett> :P
11:20:38 <tswett> @djinn ((a -> a) -> a -> a) -> (a -> a) -> a -> a
11:20:38 <lambdabot> f a = a
11:20:45 <Saizan> undefined is not contemplated as an answer by djinn
11:20:55 <tswett> I guess it's not coded to give the most complex possible answer after all.
11:20:59 <Jesin> http://haskell.org/haskellwiki/index.php?title=Functor_hierarchy_proposal&oldid=37771
11:21:04 <scree> roconnor: didn't know that
11:21:10 <tswett> Actually, what if I rearrange the arguments...
11:21:13 <scree> roconnor: but still don't think it should be exposed
11:21:18 <parcs> @djinn a -> a -> a
11:21:18 <lambdabot> f _ a = a
11:21:19 <hpc> as far as i can tell, djinn is programmed to give the only answer
11:21:22 <tswett> @djinn (a -> a) -> (a -> (a -> a) -> a) -> a -> a
11:21:23 <lambdabot> f _ a b = a b (\ c -> c)
11:21:26 <hpc> or not, derp
11:21:32 <tswett> hpc: but there are lots of answers.
11:21:37 <Jesin> Saizan: neither proposal showed any sign of knowing that the other existed...
11:21:41 <hpc> nvm, im being dumb :P
11:21:55 <Jesin> oh
11:22:04 <parcs> @djinn a -> a -> Maybe a
11:22:04 <lambdabot> f _ a = Just a
11:22:05 <Jesin> no, Saizan, it actually wasn't less radical
11:22:14 <roconnor> parcs shows that djinn doesn't give the only answer
11:22:36 <tibbe> .
11:22:37 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
11:22:38 <Jesin> it did fail to provide any proposal for a legacy module, though
11:23:06 <Jesin> if you compare http://haskell.org/haskellwiki/index.php?title=Functor_hierarchy_proposal&oldid=37771 and http://haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
11:24:55 <parcs> @djinn Maybe a
11:24:55 <lambdabot> f = Nothing
11:24:58 <Saizan> i'm not the author of any of those, so i'll just leave it to them to complain :)
11:25:36 <roconnor> everything on the wiki is fair game :D
11:31:08 <ddarius> lambdabot only shows sthe first result djinn returns.
11:31:16 <lelf> ?pl (.)(.)(.)
11:31:16 <lambdabot> (.) . (.)
11:32:39 <Jesin> @pl fmap fmap fmap
11:32:39 <lambdabot> fmap fmap fmap
11:32:42 <Jesin> @pl fmap . fmap
11:32:43 <lambdabot> fmap . fmap
11:32:50 <Jesin> @unpl fmap fmap fmap
11:32:51 <lambdabot> fmap fmap fmap
11:33:09 <Jesin> :t (.)
11:33:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:33:13 <Jesin> :p
11:33:38 <ddarius> @pl map f . map g
11:33:38 <lambdabot> map (f . g)
11:34:14 <Jafet> @pl \a c e i m n o p r s t u w y -> a . c o m p u t e r . i s . n o t . a . t y p e w r i t e r
11:34:17 <lambdabot> ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)) (flip (ap . ((.) .) . (flip .) . (((.) .) .) . ((ap .) .) . (((ap .) .) .) . ((((ap .) .) .) .) . ((((((.) .) .)
11:34:17 <lambdabot>  .) .) .) . (((((ap .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . ((((((((.) .) .) .) .) .) .) .) . ((((((((.) .) .) .) .) .) .) .) . ((((((((.) .) .) .) .) .) .) .) . ((((flip .) .) .) .) . (((((
11:34:17 <lambdabot> flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((flip .) .) .) . flip) . (ap ((.) . (.) . (.) . (.) . flip . ((.) .) . ((.) .) . ((.) .) . ((.) .))
11:34:17 <lambdabot> .) . ((flip (flip . ((.) .) . ((.) .) . (ap .) . (((.) .) .) . (((.) .) .) . (((.) .) .)) .) .) . (. flip (flip . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .)
11:34:17 <lambdabot> .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . ((((
11:34:19 <lambdabot> (flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip (flip . (flip .) . flip flip)) id)
11:34:21 <lambdabot> id) . (.) . (.) . (.) . (.) . (.) . (.) . (.))
11:34:23 <lambdabot> optimization suspended, use @pl-resume to continue.
11:34:50 <Jesin> @pl-resume
11:34:57 <lambdabot> ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)) (flip (ap . ((.) .) . (flip .) . (((.) .) .) . ((ap .) .) . (((ap .) .) .) . ((((ap .) .) .) .) . ((((((.) .) .)
11:34:57 <lambdabot>  .) .) .) . (((((ap .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . ((((((((.) .) .) .) .) .) .) .) . ((((((((.) .) .) .) .) .) .) .) . ((((((((.) .) .) .) .) .) .) .) . ((((flip .) .) .) .) . (((((
11:34:57 <lambdabot> flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((flip .) .) .) . flip) . (ap ((.) . (.) . (.) . (.) . flip . ((.) .) . ((.) .) . ((.) .) . ((.) .))
11:34:57 <lambdabot> .) . ((flip (flip . ((.) .) . ((.) .) . (ap .) . (((.) .) .) . (((.) .) .) . (((.) .) .)) .) .) . (. flip (flip . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .)
11:34:57 <lambdabot> .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . ((
11:34:59 <lambdabot> (((flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip (flip . (flip .) . flip flip)))
11:35:03 <lambdabot> id) . (.) . (.) . (.) . (.) . (.) . (.) . (.))
11:35:05 <lambdabot> optimization suspended, use @pl-resume to continue.
11:35:22 <Jesin> @pl-clear
11:35:23 <lambdabot> Unknown command, try @list
11:35:26 <Jesin> @list
11:35:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:37:04 <Jesin> btw, @pl sometimes gives incorrect code
11:37:15 <knobo> in yesod I have a route /images/#String ImagesR, and i'd like to make a link to an image in hamlet, but I don't know how to do it right. I have tried something like this [$hamlet| %a!href=ImagesR.the-image.jpg] but it does not work (obviously because of the ".")
11:37:17 <Jesin> :t let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
11:37:18 <lambdabot> forall a. (Eq a) => ([Bool] -> a) -> ([Bool] -> a) -> Bool
11:37:21 <Jesin> @pl let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
11:37:21 <lambdabot> (line 1, column 5):
11:37:21 <lambdabot> unexpected "{"
11:37:21 <lambdabot> expecting "()", natural, identifier or "in"
11:37:34 <Jesin> @pl let find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) in eq
11:37:35 <lambdabot> ((not . snd (fix (uncurry (ap (flip . ((,) .) . ap (flip . (ap .) . flip (ap . (if' .) . (. (. (False :)))) . ((False :) .) . (. (. (False :)))) (((True :) .) . (. (. (True :))))) (ap id))))) .) .
11:37:35 <lambdabot> liftM2 (/=)
11:37:53 <Jesin> oh
11:37:56 <knobo> Jesin: what are you doing?
11:37:56 <Jesin> that's what happened...
11:38:10 <Jafet> He's making the bot print smileys
11:38:12 <Jesin> I missed the liftM2 (/=) before
11:38:14 <Jesin> and no
11:38:24 <lelf> ?pl \c o m p u t e r -> c (o m p u t e r)
11:38:24 <lambdabot> (.) . (.) . (.) . (.) . (.) . (.)
11:39:05 <knobo> hamlet, anyone?`
11:39:54 <Jafet> To fmap fmap or not to fmap fmap
11:40:10 <parcs> knobo: try the web-devel haskell mailing list
11:40:36 <knobo> ok
11:41:14 <Jesin> I just found out the syntax highlighting for haskell in gedit sucks
11:41:32 <Jesin> I pasted a thing that used if'
11:41:48 <Jesin> and it thought the ' was supposed to be the start of a character literal and marked everything after that as an error
11:41:54 <Jesin> :(
11:42:25 <Twey> Jesin: It is, but it can appear as a non-initial character in identifiers
11:42:55 <Twey> Like numbers: "3" is a number, "3foo" parses as "3 foo", but "foo3" is a valid identifier
11:43:03 <Jafet> if' should be if, anyway
11:43:11 <mauke> > 1x
11:43:12 <lambdabot>   1
11:43:18 <Twey> Oh, wait, you knew that
11:43:25 <Jesin> @src liftM2
11:43:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:43:26 <Twey> I'm sorry, I'm a bit sleep-deprived today
11:43:28 <Jesin> @src liftA2
11:43:28 <lambdabot> liftA2 f a b = f <$> a <*> b
11:43:42 <mauke> > 0x
11:43:43 <Twey> Jafet: Why do you say that?
11:43:43 <lambdabot>   0
11:43:56 <Jafet> So that we can name things then and else
11:44:21 <Twey> Seems silly to me… I'd much rather have (y ?? n) p = if p then y else n
11:44:28 <Twey> Or bool y n p or however you want to name it
11:44:39 <mauke> Twey: why don't you like the name "if"?
11:44:53 <Jafet> The problem is that they're unnecessarily keywords
11:45:03 <Twey> I don't dislike the name ‘if’, but I dislike the argument order
11:45:47 <parcs> > let if' p _ t _ f = if p then t else f; (then', else') = join (,) undefined in if' True then' 5 else' 6
11:45:48 <lambdabot>   5
11:45:49 <lelf> > 2 x 2
11:45:51 <lambdabot>   2
11:45:59 <lelf> sure
11:46:10 <parcs> > 2 x 1
11:46:12 <lambdabot>   2
11:46:17 <parcs> amazing
11:46:36 <sipa> > 3 x 2
11:46:38 <lambdabot>   3
11:47:24 <lelf> > (2 x 2) x ((2 x 2) x 2) $ 2
11:47:26 <lambdabot>   2
11:47:26 <Jafet> > let if' p _ t _ f = if p then t else f; ~(then', else') = undefined in if' True then' 5 else' 6
11:47:27 <lambdabot>   5
11:47:59 <mauke>  > let if'@then'@else' p _ t _ f = if p then t else f in if' True then' 5 else' 6
11:48:02 <mauke> > let if'@then'@else' p _ t _ f = if p then t else f in if' True then' 5 else' 6
11:48:04 <lambdabot>   <no location info>: Parse error in pattern
11:48:10 <mauke> > let if' @then' @else' p _ t _ f = if p then t else f in if' True then' 5 else' 6
11:48:11 <lambdabot>   <no location info>: Parse error in pattern
11:48:14 <mauke> :-(
11:48:31 <mauke> > let if'@then'@else' = \p _ t _ f -> if p then t else f in if' True then' 5 else' 6
11:48:32 <lambdabot>   Occurs check: cannot construct the infinite type:
11:48:32 <lambdabot>    t = GHC.Bool.Bool -> t...
11:48:37 <Jesin> @unpl ((not . snd (fix (uncurry (ap (flip . ((,) .) . ap (flip . (ap .) . flip (ap . (if' .) . (. (. (False :)))) . ((False :) .) . (. (. (False :)))) (((True :) .) . (. (. (True :))))) (ap id))))) .) . liftM2 (/=)
11:48:38 <lambdabot> (\ ai cu -> not (snd (fix (uncurry ((\ av b c -> ((,)) (((\ bh f g -> ((\ dd -> if' (g (\ dj -> dd (False : dj)))) >>= \ by -> (\ dm -> False : bh (\ ds -> dm (False : ds))) >>= \ bx -> return (by
11:48:38 <lambdabot> bx)) >>= \ bm -> f >>= \ bl -> return (bm bl)) >>= \ ba -> (\ cl dv -> True : cl (\ eb -> dv (True : eb))) >>= \ az -> return (ba az)) av c) b) >>= \ an -> (\ cq -> (\ z -> z) >>= \ cn -> cq >>= \
11:48:38 <lambdabot> cm -> return (cn cm)) >>= \ am -> return (an am)))) (ai >>= \ ac -> cu >>= \ ab -> return (ac /= ab))))
11:49:02 <Jesin> @pl (<*>)
11:49:02 <lambdabot> (<*>)
11:49:35 <Jesin> @pl ((not . snd (fix (uncurry ((<*>) (flip . ((,) .) . (<*>) (flip . ((<*>) .) . flip ((<*>) . (if' .) . (. (. (False :)))) . ((False :) .) . (. (. (False :)))) (((True :) .) . (. (. (True :))))) ((<*>) id))))) .) . liftA2 (/=)
11:49:37 <lambdabot> ((not . snd (fix (uncurry ((flip . ((,) .) . ((flip . ((<*>) .) . flip ((<*>) . (if' .) . (. (. (False :)))) . ((False :) .) . (. (. (False :)))) <*> (((True :) .) . (. (. (True :)))))) <*> (id <*>))
11:49:37 <lambdabot> ))) .) . liftA2 (/=)
11:49:38 <Jesin> err
11:49:40 <Jesin> @unpl ((not . snd (fix (uncurry ((<*>) (flip . ((,) .) . (<*>) (flip . ((<*>) .) . flip ((<*>) . (if' .) . (. (. (False :)))) . ((False :) .) . (. (. (False :)))) (((True :) .) . (. (. (True :))))) ((<*>) id))))) .) . liftA2 (/=)
11:49:41 <lambdabot> (\ ad bl -> not (snd (fix (uncurry ((\ aj b c -> ((,)) (((\ aq f g -> ((\ bu -> if' (g (\ ca -> bu (False : ca)))) <*> \ cd -> False : aq (\ cj -> cd (False : cj))) <*> f) <*> \ bi cm -> True : bi (\
11:49:41 <lambdabot>  cs -> cm (True : cs))) aj c) b) <*> ((<*>) (\ z -> z))))) (liftA2 (/=) ad bl)))
11:50:02 <Jesin> rawr.
11:50:04 <Jesin> =/
11:52:35 <Jesin> @unpl let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
11:52:35 <lambdabot> let { find p = if forsome (\ g -> p (False : g)) then False : find (\ j -> p (False : j)) else True : find (\ m -> p (True : m)); forsome p = p (find p); eq p q = not (forsome (\ a -> (p a) /= (q a))
11:52:35 <lambdabot> )} in eq
11:53:25 <quuuux> that's very pointful point-free programming
11:53:34 <Jesin> yup
11:53:35 <Jesin> :p
11:53:39 <Jesin> I wanted to see what it would do
11:53:46 <parcs> :t head . filter fst
11:53:47 <lambdabot> forall b. [(Bool, b)] -> (Bool, b)
11:53:53 <parcs> :t snd . head . filter fst
11:53:54 <lambdabot> forall b. [(Bool, b)] -> b
11:54:09 <Jesin> @undefine
11:54:38 <Jesin> ooh
11:54:43 <Jesin> head . filter fst
11:55:02 <Jesin> :t fromJust
11:55:03 <lambdabot> forall a. Maybe a -> a
11:55:52 <akosch> can I define functions in ghci?
11:56:01 <ddarius> @djinn Maybe a -> a
11:56:01 <lambdabot> -- f cannot be realized.
11:56:08 <mauke> akosch: yes
11:56:12 <monochrom> like "let f x = x - x"
11:56:23 <Jesin> :t fromJust . find fst
11:56:24 <lambdabot> forall b. [(Bool, b)] -> (Bool, b)
11:56:31 <Jesin> :t head . filter fst
11:56:32 <lambdabot> forall b. [(Bool, b)] -> (Bool, b)
11:56:44 <Jesin> > fromJust (Just 5)
11:56:45 <lambdabot>   5
11:56:50 <akosch> ok, so basically like inside a do block?
11:56:50 <Jesin> > fromJust Nothing
11:56:51 <lambdabot>   *Exception: Maybe.fromJust: Nothing
11:56:58 <mauke> akosch: precisely
11:57:11 <akosch> thanks :)
11:57:39 <Jesin> Prelude> a <- getLine
11:57:41 <Jesin> blah
11:57:42 <Jesin> Prelude> a
11:57:45 <Jesin> "blah"
11:57:46 <Jesin> woah, it really *is* precisely
11:57:49 <Jesin> :p
11:58:58 <parcs> :t maybe mzero snd . find fst
11:58:59 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [(Bool, m a)] -> m a
11:59:29 <parcs> is there a class that defines a default value?
11:59:44 <mauke> yes, Data.Default
11:59:59 <ddarius> Ugh.
11:59:59 <Jesin> Prelude> a <- return $ 6 + 5
12:00:01 <Jesin> Prelude> a
12:00:02 <Jesin> 11
12:01:01 <sshc> How efficient is `fromIntegral'?
12:01:24 <sshc> What should I use to convert between integral types (Wordxs)?
12:01:54 <Twey> fromIntegral!
12:02:20 <Twey> I think it's a no-op in most cases
12:02:31 <Twey> Depends what you're converting, of course
12:05:45 <akosch> can I load a hs file with -O2 optimization enabled into ghci?
12:06:51 <mauke> not really; compile it first
12:07:38 <akosch> mauke: and how do I load the compiled file into ghci?
12:08:27 <Cale> akosch: Just load the module normally, and you should see that it loads the compiled .o
12:09:12 <akosch> thanks again!
12:13:56 <absentia> n/win shrink 3
12:21:13 <Hilbert> is -- used to mark a line comment in haskell
12:21:24 <Jesin> yup
12:22:07 <Jesin> > let foo = 3 in 2 * foo -- demonstrating well-formed expression with a line comment
12:22:08 <lambdabot>   6
12:22:21 <Jesin> :p
12:23:09 <Hilbert> I get an error when I put this as a first line  --function does this
12:24:30 <Enigmagic> put a space after the --
12:25:26 <litb> hello all
12:25:42 <Hilbert> I tried that put am still getting an error with ghci
12:25:49 <litb> how can i convert an arbirary long binary number into a hexadecimal number representation?
12:25:59 <Twey> litb: showHex
12:26:07 <Twey> :t showHex
12:26:08 <lambdabot> forall a. (Integral a) => a -> String -> String
12:26:13 <Enigmagic> Hilbert: what's the error 
12:26:20 <Twey> Oh, that's only for integrals, though
12:26:26 <Hilbert> blah.hs:4:0: parse error (possibly incorrect indentation)
12:26:44 <mauke> what's line 4?
12:26:50 <Enigmagic> Hilbert: can you paste the code up somewhere?
12:26:55 <litb> hmm
12:27:21 <Hilbert> I have noting on lin 4
12:28:00 <Enigmagic> Hilbert: yeah but what are on the previous lines? 
12:29:08 <Twey> litb: For floats, AFAIK, you have to concoct something with Numeric.floatToDigits
12:30:03 <Jesin> :t <=>
12:30:04 <lambdabot> parse error on input `<=>'
12:30:07 <Jesin> :t (<=>)
12:30:08 <lambdabot> Not in scope: `<=>'
12:30:44 <parcs> @hoogle -> [a] -> (a, a)
12:30:44 <lambdabot> Parse error:
12:30:44 <lambdabot>   --count=20 "-> [a] -> (a, a)"
12:30:45 <lambdabot>              ^
12:30:49 <parcs> @hoogle [a] -> (a, a)
12:30:49 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
12:30:49 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
12:30:49 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
12:30:51 <litb> Twey: oh
12:31:23 <litb> > showHex 2 "100100100000100101001110001011101101101011111110111010101110001"
12:31:24 <lambdabot>   "2100100100000100101001110001011101101101011111110111010101110001"
12:31:30 <litb> hm
12:32:59 <Hilbert> pentlist =  (\n  ->  n*(3*n-1) `div` 2) $ concat [[( n, -n) | n <- [1..]]
12:33:20 <mauke> ]
12:33:35 <Jesin> :t (>.>)
12:33:36 <lambdabot> Not in scope: `>.>'
12:33:39 <Jesin> :t (<.<)
12:33:40 <lambdabot> Not in scope: `<.<'
12:33:43 <Jesin> :t (>.<)
12:33:44 <lambdabot> Not in scope: `>.<'
12:33:57 <litb> bah i fail with conversions
12:34:03 <Jesin> that would be awesome if any of those were actually functions :p
12:35:47 <rjo> :t showHex
12:35:48 <lambdabot> forall a. (Integral a) => a -> String -> String
12:37:55 <litb> @src showHex
12:37:56 <lambdabot> Source not found. Wrong!  You cheating scum!
12:38:00 <litb> oops
12:38:20 <litb> it's an instance method
12:38:25 <mikeg> > showHex 65535 " another string"
12:38:26 <lambdabot>   "ffff another string"
12:38:43 <litb> ohhh
12:38:56 <litb> i suppose one cannot construct binary literals
12:39:23 <hpc> litb: no, i wish
12:39:36 <hpc> :t (><)
12:39:37 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
12:40:02 <aristid> @index showHex
12:40:02 <lambdabot> Numeric
12:41:02 <mikeg> > let showBinary = showIntAtBase 2 intToDigit in showBinary 8 (showBinary 15 "")
12:41:03 <lambdabot>   "10001111"
12:41:39 <aristid> :t showIntAtBase
12:41:40 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
12:42:12 <aristid> hmm, the type is unnecessarily ungeneric
12:43:27 <litb> oh
12:46:43 <augustss> aristid: what would you like to be more generic?
12:47:06 <aristid> augustss: showIntAtBase could use any type instead of Char
12:47:20 <aristid> a -> (Int -> b) -> a -> [b] -> [b]
12:48:15 <augustss> True
12:48:31 <Enigmagic> litb: are you parsing a binary file or a binary encoded string?
12:49:22 <litb> Enigmagic: i'm just playing 
12:51:25 <mikeg> aristid: that's probably so the type matches everything else in Numeric, which is necessarily ungeneric
12:52:42 <roconnor> why are the Dutch such great computer scientists?
12:53:29 <Jesin> [15:40:34]	<mikeg>	> let showBinary = showIntAtBase 2 intToDigit in showBinary 8 (showBinary 15 "x")
12:53:36 <Jesin> > let showBinary = showIntAtBase 2 intToDigit in showBinary 8 (showBinary 15 "x")
12:53:38 <lambdabot>   "10001111x"
12:53:40 <Jesin> ah.
12:53:41 <monochrom> there are also great british computer scientists
12:54:03 <monochrom> and great great british computer scientists, just in case :)
12:54:14 * geheimdienst1 tries to think of dutch computer scientists ... other than dijkstra ...
12:55:07 <monochrom> fokkinga
12:55:19 <monochrom> roland backhouse
12:55:31 <roconnor> bart jacobs
12:55:40 <monochrom> and dijkstra, the new one :)
12:55:44 <dixie> steve jobs
12:55:45 <roconnor> these people who wrote "The Haskell Road to Logic"
12:55:54 <mikeg> Oortmerssen is pretty well known in videogame development
12:56:08 <roconnor> oh oh, de Bruijn!
12:57:24 <roconnor> actually maybe van Rossum personally negates all the greatness of the Dutch leaving them neutral.
12:57:26 <Igloo> Some or all of Foley, van Dam, Feiner and Hughes were, weren't they? (apologies for misspellings)
12:57:32 <monochrom> the new one refers to rutger dijkstra
12:57:42 <monochrom> hahaha
12:58:24 <roconnor> he is such an anti-computer scientist
12:59:24 <lelf> http://en.wikipedia.org/wiki/Special:Search/Dutch_computer_scientist
12:59:57 <mikeg> http://en.wikipedia.org/wiki/Category:Computer_scientists_by_nationality
13:00:16 * geheimdienst1 hasn't heard of most of the above. geheimdienst felt bad about it, until he found out wikipedia hasn't a page on most of them either. de bruijn and backhouse (gb) are the only ones ...
13:00:21 <aristid> roconnor: Guide von Rossum of python fame?
13:00:28 <roconnor_> woah, I blacked out for a bit there
13:01:05 <monochrom> need ups :)
13:01:20 <roconnor_> hmm
13:01:25 <roconnor_> does ups work on routers?
13:01:34 <roconnor_> the phone lines are not powered by the main lines
13:01:44 <roconnor_> that might work
13:02:06 <geheimdienst1> oh, the "van dam" in "foley van dam" worked with ted nelson on early hypertext systems. interesting. my brain had him filed under graphics
13:02:32 <roconnor_> aristid: yes
13:03:20 <geheimdienst1> aristid: (pedantry -- guido, i believe)
13:04:16 <merijn> geheimdienst1: If you're going to be pedantic you need to also point out that it's "van" instead of "von", he's not German...
13:05:30 <roconnor_> oh right, I shouldn't be pronoucing guido like italian.
13:05:33 <merijn> Also, Henk Barendregt is a famous Dutch computer scientist
13:05:41 * roconnor_ turns on his Dutch parsing
13:05:41 <geheimdienst1> true. "van Rossum" was mentioned earlier, i only checked the addition ...
13:05:42 <merijn> Unless the lambda cube counts for nothing
13:05:45 <Saizan> guy_who_sent_him_sicp++
13:07:18 <merijn> I was actually surprised by the number of Dutch names I ran into in the references of the papers I'm reading.
13:09:06 <roconnor_> now I feel bad for pronouncing Guido as italian
13:09:12 <roconnor_> I should have known better
13:09:16 <rjo> maybe it was due to that their greatness originated from trade system
13:09:30 <roconnor_> rjo: intresting
13:09:32 <Saizan> how do you pronounce it as dutch?
13:09:33 <rjo> if it is true
13:09:51 <merijn> Saizan: Uncertainly :p
13:09:56 <olsner> wikipedia lists van rossum as a "computer programmer" not scientist
13:09:57 <roconnor_> Saizan: G is pronouched as if you are clearing your throat
13:10:13 <roconnor_> Saizan: ui is pronounced something like ow
13:10:15 <merijn> olsner: He isn't really a computer scientist imo
13:10:20 <roconnor_> Saizan: and do is pronounced as do
13:10:37 <merijn> roconnor_: ui isn't like ow
13:10:51 <roconnor_> merijn: true
13:11:00 <geheimdienst1> "how do"?
13:11:18 <olsner> merijn: exactly my point :)
13:11:21 <sipa> merijn: the dutch G is pronounced remarkably close to the H in 'huge', but without the 'you' after it :)
13:11:22 <merijn> ui sounds more like "we"
13:11:34 <roconnor_> oh right
13:11:39 <olsner> so it's not completely fair to the dutch computer scientists to say that he negates them :P
13:11:52 <merijn> sipa: As a native Dutch speaker I'm pretty confident I know how to pronounce it :>
13:12:03 <roconnor_> merijn: really
13:12:22 <roconnor_> isn't "uit" pronounced vaguely like "out"
13:12:31 <sipa> merijn: so do i, just giving you an explanation how i use to explain it to native english speakers :)
13:13:21 <rjo> the story of Saint-Gobain is interesting part of history of science
13:13:32 <roconnor_> geheimdienst1: if you say "how-do" you will be much better than saying the italian "Guido"
13:13:52 <roconnor_> but I defer to merijn, who is actually native Dutch.
13:13:57 <merijn> roconnor_: Well in the context of Guido I meant, which I'd say as pronounced somewhat like "k" (as the k in kid)-"we" - "do" (as dough)
13:14:32 <roconnor_> oh right.  "dough".  I wrote "do" thinking of the musical term.
13:15:00 <geheimdienst1> qui-dough, the brother of qui-gon
13:15:24 <Twey> Hmm
13:15:27 <Twey> What's up with this?
13:15:27 <merijn> Oh, actually. He has a slightly softer G, so the k is wrong
13:15:46 <Twey> > floatToDigits 60 (-60)
13:15:47 <lambdabot>   ([-3600],0)
13:15:48 <roconnor_> merijn: is he Guido from the north or the south? :D
13:15:59 <merijn> He has an audio file with the pronunciation online: http://www.python.org/~guido/guido.au
13:16:02 <Twey> > floatToDigits 60 (60)
13:16:04 <lambdabot>   ([1],2)
13:16:24 <geheimdienst1> merijn, so G is like a german ch in doch? velar fricative might be the term i think
13:16:44 <merijn> geheimdienst1: Yes, close enough in most circumstances anyway
13:17:24 <Twey> > map (floatToDigits 10) [10, -10]
13:17:26 <lambdabot>   [([1],2),([-100],0)]
13:17:29 <geheimdienst1> nice, thanks
13:17:31 <merijn> Although in general the G tends to be pronounced with a harder edge then the ch in doch
13:17:38 <Twey> I'm pretty sure that latter is not right
13:17:53 <Twey> Is this a bug or do I just not understand it?
13:18:22 <merijn> Twey: Don't rule out the third option of "both" ;)
13:18:34 <Twey> That's also an option
13:19:06 <roconnor_> merijn: I don't understand why the vowel "ui" sounds like "we" instead of "ow"
13:19:16 <Twey> Surely the digits should be in [0, base) or at least (-base, base)
13:19:27 <Twey> roconnor_: Why would it sound like ‘ow’?
13:19:38 <sipa> in normal dutch words it would
13:19:42 <roconnor_> Twey: because "uit" is prononuced vaguely like "out"
13:19:48 <Twey> Ah
13:20:05 <roconnor_> (and also "uit" means "out")
13:20:11 <Twey> Heh
13:20:26 <roconnor_> sipa: so it is only different because this is a proper name?
13:20:38 <sipa> yes, it's not an original dutch name, i think
13:20:58 <roconnor_> ah good.  At least I'm not totally crazy
13:21:52 <roconnor_> let's go back to talking about the poor design choices of python then. :P
13:22:21 <geheimdienst1> in german, the name guido is vaguely popular, and it's G as in gun, EE as in bee, DO as in doll
13:22:39 <Twey> I vote we skip that and instead talk about the odd behaviour of floatToDigits with negative numbers >.>
13:22:49 <roconnor_> Twey: okay
13:23:28 <sipa> yes, but G in german is a plosive
13:23:33 <roconnor_> floatToDigits takes a base and a non-negative RealFloat number, and returns a list of digits and an exponent.
13:23:37 <sipa> in dutch it's a fricative
13:24:34 <Twey> roconnor_: Right
13:24:52 <Twey> > floatToDigits 10 <$> [10, -10]
13:24:54 <lambdabot>   [([1],2),([-100],0)]
13:24:57 <Twey> roconnor_: ^ so how does this work?
13:25:02 <Twey> (the second)
13:25:11 <aristid> sipa: hmm, i don't know how a fricative G would sound
13:25:34 <Twey> aristid: Like German ach-laut…
13:25:44 <roconnor_> Twey: like this: http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base-4.3.0.0/src/GHC-Float.html#floatToDigits
13:25:45 <roconnor_> :)
13:25:52 <geheimdienst1> sipa, yes that's what i understood. i meant because of the "ui is EE" thing that people were wondering about
13:25:53 <Saizan> Twey: according to that specification floatToDigits 10 (-10) is undefined behaviour :)
13:25:56 <aristid> Twey: that does not work on "Guido"
13:25:59 <Twey> Saizan: Oh
13:26:05 <Twey> Icky
13:26:06 <geheimdienst1> aristid: the first sound in "huge"
13:26:25 <aristid> "yu"?
13:26:37 <Twey> geheimdienst1: That's the ich-laut…
13:26:44 <Twey> Saizan: Why doesn't it throw an error?
13:26:44 <roconnor_> Twey: more specifically the specificaiton doesn't specify anything about the behaviour on negative inputs
13:27:00 <sipa> aristid: it depends on your english accent i believe
13:27:04 <geheimdienst1> twey, but it's similar, only that it's further in the front of the mouth
13:27:07 <roconnor_> Twey: which may or may not be what Saizan said
13:27:28 <aristid> sipa: my english accent would be german :P
13:27:29 * hackagebot language-javascript 0.1.0 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.1.0 (AlanZimmerman)
13:27:42 <sipa> some have it as something like G-you-tsh
13:27:44 <roconnor_> Twey: I think that would make a reasonable proposal
13:28:04 <Twey> geheimdienst1: Likewise, ‘a’ is similar to ‘i’, only that it's higher up in the mouth :þ
13:28:29 <geheimdienst1> twey, curse you and your unassailable logic :-)
13:29:30 * hackagebot hjsmin 0.0.6 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.6 (AlanZimmerman)
13:29:40 <Twey> geheimdienst1: (‘i’ is, that is, not ‘a’)
13:29:48 <aristid> sipa: well, when i say "huge", there is no G in front of the you :)
13:30:21 <roconnor_> is $1,000 reasonable for this Backtesting platform in Haskell job? -- http://www.odesk.com/jobs/Backtesting-platform-Haskell_~~545bac0a65aec0d3#reloaded
13:30:49 <Twey> aristid: It's not an English ‘g’.  What sipa is trying to say is that the sound represented in Dutch by the letter ‘g’ is the sound that ‘h’ becomes in English when followed by a ‘y’ sound, as in words like ‘human’ or ‘hue’.
13:31:38 <sipa> Twey: correct
13:31:46 <sipa> however, not all english speakers do this
13:32:35 <aristid> is my english bad if i pronounce hue like you?
13:32:54 <Twey> sipa: All do
13:33:11 <Twey> sipa: (though in some accents the ‘y’ sound does not occur in some of those words)
13:33:21 <Twey> sipa: (wherever it appears, though, the ‘h’ will become the ich-laut)
13:33:34 <geheimdienst1> sipa, i'm trying to imagine an alternative "human" pronunciation without a fricative ...
13:33:42 <roconnor_> maybe non-north american programmers work for cheap
13:33:58 <aristid> Twey: huh? certain that NO english speakers say you-man?
13:34:31 <Twey> aristid: Oh, no, some accents drop initial ‘h’ sounds entirely, too
13:35:13 <Twey> Let me rephrase: wherever the combination /hj/ occurs in English, the /h/ will become [ç] (the ich-laut) ☺
13:36:10 <geheimdienst1> i think the h is also often deleted in fluent speech, isn't it? ... try saying "the human condition"
13:36:55 <merijn> roconnor: Well, basically "ui" sounds nothing like "ow" except maybe when pronounced with some strange english accent. I suppose it sounds mostly like the ui in quit combined with the ea in tea
13:36:59 <aristid> > isPrime 2011
13:37:00 <lambdabot>   Not in scope: `isPrime'
13:37:55 <roconnor> merijn: I guess that is fair.  Since there is no vowel like ui in english my brain just maps it to the closest one it know.
13:38:03 <geheimdienst1> merijn, isn't "quit" a diphthong of OO-in-zoo and schwa ...?
13:38:12 <roconnor> merijn: I spent months trying to differentiate betwen "maan" and "man"
13:38:31 <Twey> geheimdienst1: No
13:38:33 <merijn> roconnor: Those don't even sound remotely similar >.>
13:38:42 <roconnor> Even today I can barely preceive the difference, while it i probably sound like night and day to you
13:38:55 <geheimdienst1> wait, not schwa
13:39:07 <geheimdienst1> anyhoo, i think it's a diphthong ...?
13:40:09 <roconnor> to me the dutch word "man" sounds like the English word "man" pronounced with a Jamacian accent.
13:40:18 <merijn> That's about right
13:40:19 <cole> I'm trying to decipher this sentence: "Haskell, therefore, does not treat arrays as general functions with an application operation, but as abstract data types with a subscript operation." What is an application operation?
13:40:48 <Twey> cole: ($), for example
13:40:49 <cole> What is a "general function"?
13:40:52 <roconnor> merijn: :D It causes me to consider them the same vowel in my head :D
13:41:13 <cole> $ is an application operation?
13:41:35 <cole> Doesn't $ mean "execute whatever follows first"?
13:41:39 <roconnor> merijn: I spent 10 minutes with a coworker getting her to keep saying those two words.
13:41:42 <geheimdienst1> > [1,2,3] "lol"
13:41:44 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
13:41:49 <geheimdienst1> > id "lol"
13:41:50 <lambdabot>   "lol"
13:42:01 <roconnor> > sequence [1,2,3] "lol"
13:42:02 <lambdabot>   [1,2,3]
13:42:48 <roconnor> cole: what is the sentence before that?
13:42:50 <geheimdienst1> cole, i think they mean that you can apply a function (id or whatever) to something, but you can't apply a list to something
13:43:06 <mm_freak> cole: ($) is simply function application
13:43:11 <mm_freak> f $ x = f x
13:43:23 <geheimdienst1> (weird that they say array instead of list)
13:43:25 <merijn> cole: $ has nothing to do with execution or order thereof
13:43:36 <mm_freak> but while normal function application (i.e. write nothing between f and x) is the highest precedence, ($) has the lowest
13:43:49 <mm_freak> > sin 3 + 4
13:43:50 <lambdabot>   4.141120008059867
13:43:52 <mm_freak> > sin $ 3 + 4
13:43:53 <lambdabot>   0.6569865987187891
13:44:02 <roconnor> cole: the only difference between $ and white space is operator precidence.  The use of $ is mostly a tool for reducing the use of parenthesis in haskell.
13:44:04 <mm_freak> sin $ 3 + 4 = sin (3 + 4)
13:44:05 <cole> roconnor: Context: First paragraph of http://www.haskell.org/tutorial/arrays.html
13:44:26 <roconnor> interesting
13:44:29 <mm_freak> although nowadays i prefer to use parentheses in many places, where i could use ($)
13:44:41 <mm_freak> parens make the code much cleaner i think
13:44:53 <merijn> mm_freak: Must be "Sudden on-set Lisp"-syndrome
13:45:18 <mm_freak> merijn: it's just that i find "sin (x + y)" better than "sin $ x + y"
13:45:21 <djahandarie> I use parentheses if there are a lot of symbols with weird fixity floating around
13:45:32 <mm_freak> merijn: i mostly use ($) only in combination with (.)
13:45:36 <mm_freak> f . g . h $ x
13:45:37 * Twey just introduces more symbols, with weirder fixity
13:45:58 <merijn> I have a parenthesis allergy, that's why I'm into Haskell ;)
13:46:02 <geheimdienst1> weird me a fix
13:46:17 <mm_freak> yeah, in haskell you're free to choose either style =)
13:47:22 <BMeph> cole: I think it means that you don't do things like "a(3)" in Haskell.
13:50:19 <BMeph> Oh, also: when you guys were doing the Dutch CS guys, how come no one mentioned Erik Meijer or Daan Leijen? ;)
13:50:31 <mm_freak> i guess one dollar sign in a statement is fine, but code gets increasingly ugly and difficult to read, as soon as you have more than one ($)
13:51:26 <ibt> is there a reason that length returns Int instead of Word? i've never understood that.
13:51:27 <merijn> BMeph: The first sounds vaguely familiar, the second not so much
13:51:37 <Twey> ibt: Word wasn't around at the time
13:51:50 <ibt> Twey: okay, but what about for bytestring?
13:51:50 <Twey> But genericLength can return a Word, if you want it to
13:52:26 <ibt> Twey: now bytestring just needs genericLength
13:52:30 <Twey> Hm, yes
13:53:38 <j-invariant> has anyone got multivaraible polynomials self contained haskell code?
13:54:59 <cole> Coming from a c++ background, when I think of an abstract data type, I think of abstract classes (classes for which certain methods must be defined by an inheriting class and cannot themselves be instantiated into objects). Is this an entirely different concept from ADT in haskell?
13:55:01 <ibt> j-invariant: no, but i remember someone being really frustrated with that problem quite recently and giving up
13:55:30 * BMeph still wonders why we don't have a 'Natural' type as standard...
13:55:58 <BMeph> cole: Entirely. :)
13:56:06 <cole> good.
13:56:20 <j-invariant> ibt: oh great! LOL
13:56:27 <j-invariant> reassuring
13:56:34 <ibt> i was really excited about stuff like category-extras, but it looks like they gave up. anyone know if there is a different library or what happened with dev on the old one?
13:57:26 <BMeph> ibt: He found about five other projects clamoring for his attention. ;)
13:57:54 <ibt> i always found it awkward since you can't really have a class Monoid and have multiple instances of it for the same type nicely
13:57:58 <rjo> if I would say that class is more like adt in C++, would that be more correct?
13:57:59 <BMeph> ibt: You could ask for something specific; edwardk frequents the channel a lot.
13:58:42 <rjo> and ADT in haskell is more like templates
13:59:20 <djahandarie> ibt, there are plans to work on it, ed is just busy
13:59:37 <BMeph> rjo: Well, it's more like templates than like abstract classes, I guess. ;)
14:00:05 <djahandarie> ibt, the major plan being "this is getting too big and crazy, let's rework it some"
14:01:10 <BMeph> ibt: Yeah, it's a sad flaw in Haskell's generally high aesthetic. On the other hand, it gives "newtype" a nice workout... ;)
14:01:25 <ibt> i wish i could figure out how to get paid to work on stuff like that. 
14:02:32 <ibt> BMeph: yeah. it pains me. haskell is so on the edge of awesomeness. i can feel it, but something seems to be missing
14:04:42 <ray> haskell sucks so hard
14:05:14 <merijn> As does every other programming language. What's your point?
14:05:35 <ibt> merijn: don't feed
14:13:00 <mathijs> Hi all, I'm using a library that has a type constraint on a constructor function. The data itself doesn't have this constraint. is there a way to tell the type system that this constraint holds true for all occurences of the data?
14:13:33 <ibt> mathijs: are you saying that you don't want to put the constraints on every function that uses the data?
14:14:15 <mathijs> the lib I'm talking about is: http://hackage.haskell.org/packages/archive/reaction-logic/2010.11.17/doc/html/Data-Reactor.html . as you can see, the "mkReactor" function has a "MonadState c m" constraint, meaning I should be able to infer c from m everywhere in my code
14:16:12 <mathijs> ibt: hmm.. that too, but I would like to force the guarantee that c can be inferred from m. Right now, my signatures are forced to use "(State s) c" everywhere, while s and c should be one and the same
14:17:04 <mathijs> So I have been trying with multiparam typeclasses and other stuff that I don't fully understand, but no result yet
14:18:23 <ibt> mathijs: did you try multiparam typeclass with functional dependencies?
14:19:09 <ibt> mathijs: i may be on the wrong track though.
14:19:22 <mathijs> ibt: nope. problem is: there are no functions to put in the class
14:24:19 <cpa> hi there, I have a question
14:25:44 <cpa> I have a type for which should be an instance of the Get typeclass
14:26:41 <cpa> so I write the get func: get = do { n <- get :: Get Word8 ; b <- get :: Get String} but I should enforce that the length b == n
14:26:54 <cpa> how can I do that?
14:27:07 <ibt> cpa: can you hpaste your actual code?
14:28:29 <DevHC> > length $ [1..]
14:28:34 <lambdabot>   mueval-core: Time limit exceeded
14:28:37 <cpa> ok
14:28:37 <DevHC> > length $ cycle "blarg"
14:28:52 <lambdabot>   thread killed
14:29:51 <cpa> http://hpaste.org/42696/get
14:30:41 <Cale> DevHC: That's not actually a problem, btw.
14:31:11 <Cale> (the thread being killed is because the time limit was exceeded, but a different part of the code caught it)
14:31:26 <DevHC> well it just looks weird
14:31:28 <mreh> what can I use instead of scanl z . repeat?
14:31:30 <Cale> (I got your message)
14:31:44 <roconnor> @type \z -> scanl z . repeat
14:31:45 <lambdabot> forall b a. ([a] -> b -> [a]) -> a -> [b] -> [[a]]
14:31:59 <mreh> hmm
14:32:05 <mreh> I don't think I meant that
14:32:06 <mreh> :t repeat
14:32:07 <roconnor> O_o
14:32:07 <lambdabot> forall a. a -> [a]
14:32:12 <Cale> :t iterate
14:32:13 <lambdabot> forall a. (a -> a) -> a -> [a]
14:32:20 <mreh> aha
14:32:20 <Cale> Maybe something kinda iteratey?
14:32:43 <merijn> @src iterate
14:32:43 <lambdabot> iterate f x =  x : iterate f (f x)
14:36:42 <dixie> :t undefined
14:36:43 <lambdabot> forall a. a
14:37:34 <mreh> > scanl1 ((+) . (0.5^^)) [1..] 
14:37:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:37:35 <lambdabot>    `GHC.Real.Fractional a'
14:37:36 <lambdabot> ...
14:37:50 <ibt> cpa: you blocking privmsgs?
14:39:02 <roconnor> how much do you think record subtyping used in OOP?
14:39:10 <j-invariant> never..
14:39:23 <mreh> :t (^^)
14:39:23 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
14:39:25 <DevHC> does the fix function always yield a fixpoint?
14:39:53 <mreh> @src fix
14:39:53 <lambdabot> fix f = let x = f x in x
14:40:54 <Jesin> this is equivalent to the definition "fix f = f (fix f)"
14:41:06 <dixie> :t fix
14:41:06 <lambdabot> forall a. (a -> a) -> a
14:41:17 <Jesin> DevHC: yes, it does, if it yields anything
14:41:24 <mreh> still blows my mind
14:41:31 <roconnor> j-invariant: really?
14:41:38 <Jesin> either it yields a fixed point of a function, or it gets caught in an infinite loop
14:41:56 <DevHC> well in theory it does give a fixpoint
14:42:07 <Jesin> @pl let it f x = x : it f (f x) in it
14:42:08 <lambdabot> fix ((ap (:) .) . ((.) =<<))
14:42:18 <DevHC> if f uses (tries to evaluate) its argument, then _|_ is a fixpoint
14:42:18 <ibt> cpa: anyway, the code looks strange. but, it sounds like you want to ensure at compile time that the size of two things are the same. people want to do that for matrix/vector stuff too. 
14:42:37 <DevHC> otherwise f is a constant function, and its return value is a fixpoint
14:42:41 <DevHC> but that's boring :P
14:42:46 <DevHC> i mean
14:42:52 <DevHC> > fix (++"a")
14:42:56 <lambdabot>   mueval-core: Time limit exceeded
14:43:00 <Jesin> but
14:43:07 <Jesin> there are other possibilities
14:43:07 <mreh> > fix (1:)
14:43:08 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:43:09 <Jesin> like
14:43:23 <roconnor> @free fix
14:43:24 <lambdabot> f . g = h . f => f (fix g) = fix h
14:43:24 <Jesin> > fix ((1:) . scanl1 (+))
14:43:27 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
14:43:27 <DevHC> there are infinite (of continuum cardinality) amount of fixpoints for the (++"a") function: all infinite strings are fixpoints
14:43:40 <Jesin> > @let fibs = fix ((1:) . scanl1 (+))
14:43:41 <lambdabot>   <no location info>: parse error on input `@'
14:43:44 <Jesin> @let fibs = fix ((1:) . scanl1 (+))
14:43:46 <lambdabot>  Defined.
14:43:53 <Jesin> > take 20 $ fibs
14:43:56 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
14:44:00 <DevHC> :D
14:44:00 <dixie> > fix (*2)
14:44:03 <lambdabot>   mueval-core: Time limit exceeded
14:44:14 <Kaidelong> > fix 2
14:44:15 <lambdabot>   2
14:44:15 <mreh> my favourite is 
14:44:19 <Jesin> > ((1:) . scanl1 (+)) fibs
14:44:21 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
14:44:25 <mreh> > fix (const 3)
14:44:25 <lambdabot>   3
14:44:33 <Jesin> > ((1:) . scanl1 (+)) $ ((1:) . scanl1 (+)) fibs
14:44:36 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
14:44:46 <dixie> @type scanl1
14:44:47 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
14:44:51 <DevHC> yeah taht's what i said: if f is a constant function..
14:44:59 <Jesin> :t (1:) . scanl1 (+)
14:45:00 <lambdabot> forall t. (Num t) => [t] -> [t]
14:45:20 <Jesin> DevHC: but (1:) . scanl1 (+) is NOT a constant function
14:45:23 <Jesin> watch
14:45:34 <Jesin> > ((1:) . scanl1 (+)) [5..]
14:45:35 <DevHC> i didn't say that's a constant function
14:45:36 <lambdabot>   [1,5,11,18,26,35,45,56,68,81,95,110,126,143,161,180,200,221,243,266,290,315...
14:45:43 <Jesin> ah
14:45:45 <Jesin> ok
14:45:55 <DevHC> i'm talking about f in "fix f"
14:46:04 <Jesin> right
14:46:18 <Jesin> > let f = ((1:) . scanl1 (+)) in fix f
14:46:20 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
14:46:25 <Jesin> @undefine
14:46:27 <Heffalump> could someone try to build bytestring-0.9.1.8 on GHC 6.12.3 ?
14:46:33 <DevHC> anyone up to the challenge of making fix a bit smarter? :P
14:46:43 <Jesin> umm
14:46:48 <Jesin> DevHC: what?
14:46:53 <Jesin> it's perfectly smart already
14:46:54 <ibt> cpa: anyway, might look at implicit configurations or maybe look at the technique used in hmatrix-static for encoding sizes in types
14:46:58 <DevHC> yeah but it's boring
14:47:11 <Kaidelong> well I did mention that if you had a global notion of equality (a like in OCaml) you could make fix terminate for more things
14:47:27 <DevHC> it's like in class...
14:47:27 <Kaidelong> but pointer comparison strikes people as ugly
14:47:42 <Kaidelong> a bit like in*
14:47:46 <Jesin> ??
14:47:48 <DevHC> task: define a function which has the type (a -> a) -> b -> c
14:47:51 <Heffalump> it looks like noone has ever tested it (there's a bit of code that's enabled with CPP that first has a weird parse error I don't understand, but also a variable that's not in scope at all)
14:47:56 <roconnor> I suppose fix could return other fixed points other than the least one :D
14:48:05 <DevHC> solution: let { f :: (a -> a) -> b -> c ; f = error "nwhahahaa" }
14:48:16 <Jesin> umm
14:48:22 <Jesin> what's a "least" fixed point btw?
14:48:48 <Jesin> there's no Ord constraint
14:48:50 <Jesin> :p
14:48:59 <roconnor> Jesin: it is a fixpoint that is lowest under the definedness relation in a cpo.
14:48:59 <DevHC> lol
14:49:12 <Kaidelong> Jesin: you can check if two things are equal if they point to the exact same things in memory
14:49:27 <Kaidelong> they might be equal in some way even if they point to different places
14:49:29 <DevHC> not in haskell theory
14:49:48 <Jesin> umm
14:49:52 <Kaidelong> but you can resort to that if you don't know another way
14:49:57 <Jesin> wouldn't that make things implementation-dependent?
14:50:06 <Jesin> hmm
14:50:09 <Kaidelong> I think that is why people don't like the idea, exactly
14:50:14 <Jesin> I wonder how that would work, though
14:50:15 <roconnor> Not to mention destroying referential transparency
14:50:32 <DevHC> however, this would be epic with it:
14:50:53 <Jesin> I mean, in what circumstances would something end up pointing to the same thing in memory?
14:51:05 <DevHC> consider a geometry walking function which walks on the integer grid of fixed NxM size
14:51:11 <Jesin> like, what's an example of something for which "fix" does not terminate as is
14:51:12 <Kaidelong> Jesin: presumably id
14:51:17 <Kaidelong> > fix id
14:51:21 <lambdabot>   mueval-core: Time limit exceeded
14:51:33 <DevHC> and u can define local functions like "up k = (i-k,j)"
14:51:36 <roconnor> fix id should return 7
14:51:38 <Jesin> ...
14:51:40 <roconnor> > id 7
14:51:41 <lambdabot>   7
14:51:43 <roconnor> see
14:51:53 <Jesin> fix id SHOULD evaluate to _|_ though, shouldn't it?
14:51:58 <Jesin> > let x = x in x
14:52:03 <lambdabot>   mueval-core: Time limit exceeded
14:52:05 <Jesin> :p
14:52:06 <Kaidelong> it should give you fix id, I guess that means it has no normal form
14:52:14 <Kaidelong> so it is _|_ actually
14:52:20 <Kaidelong> right
14:52:24 <roconnor> Kaidelong: what's wrong with 7
14:52:33 <Jesin> and an infinite loop counts as _|_
14:52:36 <Jesin> :p
14:52:45 * Kaidelong is trying to remember what he is thinking of
14:52:46 <Jesin> ooh
14:52:47 <Jesin> watch this
14:52:49 <Jesin> :t fix id
14:52:50 <lambdabot> forall a. a
14:52:52 <Jesin> :D
14:52:56 <Jesin> :t undefined
14:52:58 <lambdabot> forall a. a
14:53:03 <Jesin> it even has the same type signature
14:53:04 <Jesin> :p
14:53:19 <DevHC> and then for bounds checking u could use: if func == up then if i < k then error "OOB" else up k else ...
14:53:43 <Kaidelong> if you get back fix id from id though and can tell it is the same thing, you can terminate with an error rather than looping forever
14:53:53 <Jesin> yeah
14:53:53 <Kaidelong> which is marginally nicer
14:53:58 <Jesin> that *wouldn't* be a problem
14:54:08 <Jesin> and would still conform to the haskell spec as it stands
14:54:18 <DevHC> uhm
14:54:26 <DevHC> haskell is deterministic
14:54:29 <DevHC> fix is a FUNCTION
14:54:39 <DevHC> it can't return bot on 1 system and non-bot on another :]
14:54:46 <Jesin> right
14:54:50 <Jesin> so it returns bottom on all systems
14:54:52 <Kaidelong> DevHC: abnormal termination is the same as bottom though, isn't it?
14:54:53 <roconnor> Kaidelong: that is what happens in GHC already
14:55:17 <Kaidelong> roconnor: really? that's cool, so if I say "fix id" the program will crash rather than hang?
14:55:21 <Jesin> the haskell spec explicitly says that a non-terminating computation is semantically equivalent to _|_
14:55:27 <DevHC> bottom on all systems where bottom is teh fixpoint... there are functions for which bottom is NOT a fixpoint, namely ones which don't use their argument and return non-bottoms
14:56:04 <Jesin> DevHC: give an example of such a function?
14:56:10 <DevHC> fix (const 1337)
14:56:16 <DevHC> > fix (const 1337)
14:56:17 <lambdabot>   1337
14:56:19 <Jesin> :p
14:56:34 <Jesin> > fix (\x -> x^2)
14:56:38 <lambdabot>   mueval-core: Time limit exceeded
14:56:41 <Jesin> ^that, on the other hand
14:56:43 <DevHC> and to show taht bottom is NOT a fixpoint of (const 1337), consider:
14:56:44 <Jesin> has a fixed point at 1
14:56:49 <DevHC> > const (error "NO U")
14:56:50 <roconnor> Kaidelong: it will sometimes through a loop exception
14:56:50 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a)
14:56:50 <lambdabot>    arising from a use of `...
14:56:53 <roconnor> *trhow
14:56:55 <roconnor> *throw
14:56:58 <hpc> there's also functions for which they use their arguments, but don't return bottom
14:57:02 <hpc> > fix (1:)
14:57:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:57:06 <DevHC> > (const 1337) (error "NO U")
14:57:08 <lambdabot>   1337
14:57:41 <hpc> roconnor: like fix id?
14:57:46 <Jesin> DevHC: yes, bottom isn't always a fixed point of an arbitrary function
14:57:47 <DevHC> hpc: however for those functions, buttom IS a fixpoint, because if they use their bottom argument, they return a bottom value
14:57:55 <Kaidelong> fix id = id (fix id) = id _|_
14:58:14 <Kaidelong> = _|_
14:58:28 <Kaidelong> id is strict in its argument, basically
14:58:36 <DevHC> lol?
14:58:45 <j-invariant> is there a compiler option to stop it doing infifnnite loops>
14:58:46 <Kaidelong> and fix always returns _|_ when given a strict function
14:59:00 <Kaidelong> j-invariant: then you'd need a total language, which haskell isn't
14:59:15 <roconnor> ehird	> fix id
14:59:16 <roconnor> lambdabot	Exception: <<loop>>
14:59:16 <j-invariant> if the language was total I wouldn't need the flag :P
14:59:21 <roconnor> http://ircarchive.info/haskell/2007/3/21/63.html
14:59:22 <Jesin> [17:58:18]	<j-invariant>	is there a compiler option to stop it doing infifnnite loops
14:59:25 <Jesin> HALTING PROBLEM
14:59:27 <Jesin> :p
14:59:35 <kuribas> Is haskell suitable for low memory devices?  (32Mb ram)
14:59:37 <DevHC> j-invariant: is there a compiler option to yield the proof for the riemann hypothesis?
14:59:54 <Jesin> of course theoretically there could be a way for the compiler to know "fix id" won't terminate
15:00:10 <Jesin> but for an arbitrary function you can't know whether it will or won't terminate
15:00:22 <DevHC> like id :P
15:00:56 <j-invariant> yeah I just want a way to stop ghc going into an infinite loop
15:01:10 <Kaidelong> kuribas: depends on haskell implementation, I'm not convinced GHC would be a good choice for that, but perhaps someone knows about tuning it for space
15:01:11 <Jesin> oh, wait
15:01:12 <j-invariant> it slows down my computer
15:01:12 <Jesin> what?
15:01:19 <Jesin> you mean the *compiler*?
15:01:50 <DevHC> the thing is, if we make fix smarter for 1 function (ie., id), then why just that function? why not also my cute little g function (g = if x == 4 then 4 else 3)?
15:01:54 <Jesin> like, the compiler goes into an infinite loop on some things, even if you don't run the program?
15:01:55 <dolio> The compiler doesn't go into loops unless you're doing something funky.
15:01:57 <Kaidelong> I think you can prove that even for a total language, there is a way to halt the compiler
15:02:13 <DevHC> why not make fix smarter for 100000 functions? and if we do, then why specifically THOSE?
15:02:20 <j-invariant> I mean if there's a bug in my program, and I run it
15:02:22 <Jesin> > fix (\x -> if x == 4 then 4 else 3)
15:02:26 <lambdabot>   mueval-core: Time limit exceeded
15:02:34 <j-invariant> then the program starts going into an infinite loop and it slows dowfn my computer a lot
15:02:47 <DevHC> so a solution on a boundary would be: make fix work just theoretically, but not any more
15:02:48 <j-invariant> I want it to kill its self if things start going down that road
15:02:56 <Jesin> j-invariant: you can't DO that
15:03:13 <Jesin> it's provably impossible to know something is an infinite loop
15:03:14 <Kaidelong> j-invariant: you could maybe implement a timeout somehow using nondeterministic concurrency
15:03:28 <Kaidelong> it would, of course, kill anything taking too long
15:03:37 <Kaidelong> as opposed to knowing somehow that there is an infinite loop
15:03:40 <Jesin> or you could restrict it on memory usage
15:03:42 <Jesin> but yeah
15:03:42 <j-invariant> Kaidelong: I was hoping that sort of thing would be built in
15:03:56 <Jesin> http://en.wikipedia.org/wiki/Halting_problem
15:03:58 <Jesin> :p
15:04:24 <DevHC> infinite loop detection has been proven impossible in computer systems where evaluation is done step-by-step, ie. like integrated circuits, quantum computers, etc.
15:04:36 * roconnor can't get GHC 6.12.3 to throw a loop exception :(
15:04:41 <Jesin> "Jump to: navigation, search
15:04:43 <Jesin> In computability theory, the halting problem is a decision problem which can be stated as follows: Given a description of a program, decide whether the program finishes running or continues to run, and will thereby run forever. This is equivalent to the problem of deciding, given a program and an input, whether the program will eventually halt when run with that input, or will run forever.
15:04:44 <Jesin> Alan Turing proved in 1936 that a general algorithm to solve the halting problem for all possible program-input pairs cannot exist."
15:04:51 <DevHC> there are theoretic models for computability which supercede the turing machine, and do not have halting problems
15:04:59 <DevHC> however the problem is building such a machine...
15:05:02 <Kaidelong> you don't have to solve the halting problem in general
15:05:03 <roconnor> DevHC: eh?
15:05:06 <Jesin> yes, but none of those comply with physical reality so far as we know
15:05:10 <DevHC> yes
15:05:16 <DevHC> roconnor: ^
15:05:18 <Jesin> and don't they generally have their *own* equivalent of the halting problem?
15:05:27 <Kaidelong> also one approach is that the compiler might halt trying to prove a program halts, but once compiled the program shouldn't halt
15:05:33 <Kaidelong> err, doesn't halt
15:05:43 <roconnor> DevHC: AFAIK any langauge with general recursion will have a halting problem.
15:05:44 <j-invariant> I need a sandbox mode to run my program in so that it can't pull down my whole system
15:06:05 <Kaidelong> I think that is the approach taken by some total languages, if it halts trying to prove the correctness of the program it times out and says "I can't compile this"
15:06:27 <DevHC> well not generally, but there is at least 1 model of computation in which: (1) u can simulate the model's machines with the machines themselves, and (2) solve the halting problem for the machines with the model's machines themselves
15:06:49 <Kaidelong> DevHC: wouldn't that require bottom to be observable?
15:06:56 <roconnor> DevHC: is this language turning complete?
15:06:59 <Kaidelong> IE a basis in paraconsistent logic
15:07:01 <roconnor> *Turing
15:07:07 <DevHC> roconnor: that language is superturing
15:07:16 <j-invariant> maybe I should just make a shell script that wathces ghc and if it uses ~100% CPU for over 30 seconds it kills it
15:07:17 <roconnor> I'd like to see a reference
15:07:18 <DevHC> it can do MORE than a turing machine
15:07:25 <DevHC> listen, it's a theory
15:07:33 <j-invariant> that's a really bad "solution" though
15:07:47 <Kaidelong> DevHC: the whole problem is that we want to do less than a turing machine
15:07:50 <roconnor> DevHC: I'd like to know where Turing argument breaks down for this class of machine.
15:07:59 <Kaidelong> if it can do more, it can also presumably halt
15:08:04 <Kaidelong> just like a turing machine
15:08:10 <DevHC> like a program in that computability model is a set of functions like {f, g, h}, and the program sequence is like: "apply f until the g condition is reached, finally apply h"
15:08:44 <merijn> Kaidelong: No, the problem is that we want more knowledge about a programs behavior. Which has two ways of being done. Restricting the programs or enhancing the program doing analysis
15:08:52 <DevHC> in that model f, g, and h can be any functions in theory (even function of continuum cardinality), so this model BY DEFINITION can do more than a turing machine
15:08:52 <roconnor> DevHC: does your model not have an S-m-n theorey (ie it has no partial application)?
15:08:57 <roconnor> *theorem
15:09:08 <DevHC> i have no idea what S-m-n is
15:09:19 <Kaidelong> merijn: but wouldn't you agree that a total language is neccessarily not turing complete?
15:09:33 <Kaidelong> since there is no _|_ at all
15:09:56 <merijn> Kaidelong: I don't agree with that statement, no.
15:10:05 <merijn> I will concede the following, though
15:10:23 <Jesin> hmm
15:10:32 <merijn> 1) Non-Turing complete languages are likely good enough for the majority of the things we want to accomplish
15:10:35 <Jesin> could somebody give me a definition of "total language"?
15:10:45 <roconnor> DevHC: The system you are desercibing must have some sort of deficiency, such as no partial application.
15:11:03 <Kaidelong> Jesin: all functions are total, basically for all inputs they return something other than _|_
15:11:05 <merijn> 2) It is easier to add computational flexibility to non-Turing complete languages then it is to make super-Turing analysis programs
15:11:18 <roconnor> DevHC: the hypotheses needed for Turing's argument are not very strong.
15:11:32 <DevHC> what's partial application?
15:11:36 <merijn> Kaidelong: Eh, wait I think I got your first remark wrong
15:12:11 <roconnor> http://en.wikipedia.org/wiki/Smn_theorem
15:12:19 <Kaidelong> being able to show that a program written in a non-total language will halt without running it is a different approach with the same goal
15:12:33 <kuribas> Kaidelong: Do you think ghc is not memory efficient?  Because of lazy evaluation?
15:12:35 <Kaidelong> but unsolvable in general
15:12:40 <Kaidelong> kuribas: no
15:12:42 <merijn> Kaidelong: Yeah, your right. A total language (as in, a language which is strongly terminating) is by definition not Turing complete
15:12:52 <roconnor> DevHC: IIRC partial application is a program that takes a program and an argument and returns a new program which behaves like the input program but with the first argument fixed to the given argument.
15:13:26 <kuribas> Kaidelong: Because of garbage collection?
15:13:36 <DevHC> ok and why would that not be possible in this superturing model?
15:13:39 <dolio> merijn: I don't think it's by definition. But it's a straightforward consequence of a diagonal argument.
15:13:55 <dolio> Or something like that.
15:14:06 <deech> Hi all, I'm through Okasaki's book and I was wondering if memoization of a functional data structure is really only an issue in a lazily evaluated language.
15:14:07 <merijn> dolio: Well, I didn't mean by definition in the strict mathematical sense
15:14:12 <Kaidelong> kuribas: the GHC optimizer is just built for speed over space, but someone other than me may know better about tuning your program to do well on a system with just 32 mb
15:14:26 <merijn> dolio: But in the "The proof that this is so follows from the definition of Turing complete"
15:14:39 <dolio> Ah, okay.
15:14:46 <kuribas> Kaidelong: ok, I see.
15:15:10 <Kaidelong> the way I interpret it is just, "turing machines can halt", "total languages don't allow things that halt", "total languages can't express every turing machine"
15:15:26 <merijn> Kaidelong: I think you mean the reverse
15:15:35 <roconnor> DevHC: because Turing theorem says something like: if you have a language with partial applicaiton and can intepret itself, then the halting problem is unsolvable.
15:15:46 <merijn> "turing machines can not halt", "total language don't allow things that don't halt"
15:15:57 <Kaidelong> yes
15:16:05 <Kaidelong> wait
15:16:12 <roconnor> DevHC: Turing theorem applies more generally than to just Turing machines.
15:16:14 <Kaidelong> wait no, wasn't halting
15:16:18 <Kaidelong> where you get stuck
15:16:28 <merijn> roconnor: The Halting problem is really just a form/manifestation of Godel's incompleteness theory, isn't it?
15:16:30 <Kaidelong> a turing machine halts if it never stops
15:16:42 <merijn> Kaidelong: EH, no
15:16:52 <dolio> Halts means stops.
15:16:56 <roconnor> merijn: arguably
15:16:58 <merijn> Turing machines are not strongly terminating. That means they can get stuck in infinite loops
15:16:59 <Kaidelong> oh ok
15:17:03 <Kaidelong> then I had it wrong in my head
15:17:16 <Kaidelong> this way makes more sense
15:17:18 <DevHC> roconnor: i dunno if that argument applies to this model of computation
15:17:41 <roconnor> DevHC: if it doesn't apply then there is some hypothesis of the theorem that you fail to satisfy
15:17:50 <DevHC> however, on a side note, there is an axiom system which is both consistent and complete
15:17:50 <merijn> roconnor: The more I learn about type theory and math the more I am getting the deep seated fear Godel's incompleteness theory is the one single universal law of reality >.>
15:18:01 <merijn> DevHC: Eh, no
15:18:02 <j-invariant> um
15:18:05 <DevHC> no nos
15:18:09 <DevHC> there is one, period.
15:18:17 <j-invariant> merijn: makes for a good "best seller" but it's nonsense
15:18:21 <dolio> There are many.
15:18:25 <dolio> Like real arithmetic.
15:18:27 <Kaidelong> merijn: Godel's incompleteness theorem relies on the principle of explosion, doesn't it?
15:18:34 <Heffalump> Igloo: ping?
15:18:39 <Kaidelong> so it may not apply to paraconsistent models of logic
15:18:39 <DevHC> is real arithmetic complete?
15:18:41 <dolio> Or Pressburger arithmetic.
15:18:42 <DevHC> i don't think so
15:18:57 <j-invariant> The /only/ connection between these is the proof technique of diagonalization
15:19:23 <DevHC> between the smn theory and the goedel incompleteness theory?
15:19:34 <DevHC> or that partial application statement of whatever
15:19:37 <Jesin> theorEM
15:19:57 <merijn> dolio: Am I misunderstanding the meaning of completeness in this context, then?
15:19:58 <Jesin> Godel's incompleteness theorem (or theorems)
15:20:11 <DevHC> o
15:20:17 <Jesin> ooh
15:20:20 <roconnor> j-invariant: that's not true
15:20:25 <j-invariant> roconnor: really?
15:20:36 <Jesin> http://en.wikipedia.org/wiki/Robinson_arithmetic
15:20:37 <merijn> j-invariant: I'm not laboring under the illusion that it is actually true. It makes for an interesting philosophical lens, though
15:20:42 <roconnor> j-invariant: a weak version of goedel's incompleteness theorem is a direct consequence of the halting problem.
15:20:48 <dolio> merijn: I don't think so. The odd thing is that the axiomatization of real arithmetic doesn't subsume arithmetic on the natural numbers.
15:20:49 <Kaidelong> the consequence of the halting problem is quite similar to the consequence of the incompleteness theorem (basically, being unable to express the proof that a system is correct using the system itself) but I'm not aware of anyone having shown that the two are related
15:20:53 <Kaidelong> it seems likely though
15:20:58 <roconnor> http://en.wikipedia.org/wiki/Halting_problem#Relationship_with_G.C3.B6del.27s_incompleteness_theorem
15:21:09 <Jesin> Kaidelong: as for "showing" that the two are related
15:21:23 <Jesin> A <-> B if A and B are both true
15:21:34 <Jesin> under classical logic anyway
15:21:45 <Jesin> :p
15:21:51 <merijn> Kaidelong: Time for proof by intuition. Where I say it is true because it feels true ;)
15:21:52 <dolio> merijn: I'm having trouble finding a reference now, though. I forget whose axiom system it is.
15:22:08 <roconnor> dolio: the thing is that the axiomatizaiton of real aritmetic doesn't really axiomatize arithemetic over the real numbers.  Instead it axiomatizes arithemetic on real closed fields.
15:22:12 <merijn> dolio: But isn't being consistent and complete in violation of Gödel?
15:22:20 <DevHC> of course not :)
15:22:22 <dolio> http://en.wikipedia.org/wiki/Tarski's_axiomatization_of_the_reals
15:22:32 <dolio> merijn: No.
15:22:37 <Jesin> merijn: being consistent and complete is not in violation of Godel's incompleteness theorems
15:22:39 <DevHC> consistent, complete AND computable is a violation
15:22:44 <merijn> Ah
15:22:48 <Jesin> no, devHC, it isn't
15:22:49 <merijn> Of course
15:22:50 <dolio> Goedel's theorem has certain conditions on the axiom system.
15:22:53 <Kaidelong> merijn: the interesting thing is about systems that are inconsistent but don't allow explosion, so they can't infer anything even with inconsistent axioms
15:23:12 <Jesin> there are trivial systems that are consistent, complete, and computable
15:23:19 <DevHC> lol?
15:23:20 <merijn> I really should A) finish Gödel, Escher & Bach and B) read up on Gödel
15:23:33 <Kaidelong> Jesin: but can they prove their consistency within their own terms?
15:23:33 <roconnor> Jesin: yes
15:23:37 <DevHC> could u name one?
15:23:38 <Jesin> but they're so trivial nobody likes calling them a "system"
15:23:43 <roconnor> Jesin: presburger arithemtic
15:24:02 <Jesin> what would violate godel's theorems
15:24:13 <j-invariant> merijn: I would recommend skipping A and just go right for B
15:24:19 <Jesin> would be being consistent and complete and capable of expressing http://en.wikipedia.org/wiki/Robinson_arithmetic
15:24:24 <roconnor> presburger arithemtic cannot encode general computation
15:24:26 <Heffalump> Igloo: bytestring 0.9.1.8, which you uploaded, doesn't build on GHC 6.12.3. There seem to be patches in the repo that predate your upload that fix that specific problem, but the HEAD repo still doesn't build for some other reason. Does bytestring get uploaded from the GHC repo normally?
15:24:45 <roconnor> specifically presburger arithemtic cannot encode enough computation to describe provablity
15:25:02 <Kaidelong> well then it isn't complete, is it?
15:25:10 <dolio> merijn: Dan Willard does work on self-verifying axiom systems, for instance.
15:25:21 <Jesin> # Sx ≠ 0
15:25:22 <Jesin> # (Sx = Sy) → x = y
15:25:24 <Jesin> # y=0 ∨ ∃x (Sx = y)
15:25:26 <Jesin> # x + 0 = x
15:25:28 <Jesin> # x + Sy = S(x + y)
15:25:29 <roconnor> Kaidelong: it is complete.  Every theorem in presburger arithmetic is either true or false and provably so.
15:25:29 <Jesin> # x0 = 0
15:25:31 <Jesin> # xSy = (xy) + x
15:25:34 <DevHC> division by 0
15:25:34 * djahandarie sighs
15:25:35 <merijn> j-invariant: Naah, I rather like GEB so far and at least I can follow Hofstadter's writing style
15:25:37 <dolio> Which have enough power to talk about their own provability in some ways, but not enough to be subject to Goedel's incompleteness theorem.
15:25:51 <Kaidelong> hmm, wait, right
15:25:58 <dolio> Usually by having crippled multiplication, I think.
15:26:14 <dolio> (You can't prove multiplication total, for instance.)
15:26:16 <Kaidelong> so the problem would be, since you can't express provability, you can't use presburger arithmetic to prove that presburger arithmetic is correct
15:26:28 <roconnor> persburger arithemtic has not symbol for multiplication and cannot express it.
15:26:30 <roconnor> *no
15:26:38 <roconnor> Kaidelong: indeed
15:27:12 <merijn> dolio: Ah, so it is more like "Complete, consistent and practically usable" which violates Gödel instead of just the first two
15:27:33 <Jesin> for a specific definition of "practically usable"
15:27:47 <dolio> Yes. And computable as DevHC mentioned.
15:28:05 <Kaidelong> well I guess Goedel just ends up saying that a system that is both consistent and complete cannot prove that it is so
15:28:05 <merijn> Is there a good intro to the incompleteness theorem because if I have to get it from papers I think I will have to cry
15:28:16 <roconnor> merijn: Goedel's theorem also requires the axioms set to be decidable (or more specifically it needs to be decidable what a proof is)
15:28:24 <Kaidelong> which means that any system which allows you to prove that it is so is either inconsistent or incomplete
15:28:44 <roconnor> The "true theorems of arithemetic" is a complete and consistent system.
15:28:46 <DevHC> merijn: go to a university and listen to a lecture :P
15:28:47 <Kaidelong> well, eventually
15:28:52 <roconnor> but it isn't decidable what the axioms are.
15:28:52 <j-invariant> merijn: Godels paper is not difficult
15:29:06 <dolio> Kaidelong: Dan Willard's stuff shows that interpretation isn't quite correct.
15:29:14 <Jesin> ooh
15:29:18 <merijn> DevHC: I'm already doing that, but I do CS not math. And most math lecturers I've had so far were terrible
15:29:19 <Jesin> yes, what roconnor said
15:29:28 <dolio> He has systems that can state their own consistency to a degree, but aren't subject to the incompleteness theorem.
15:29:37 <DevHC> CS can't live without math !
15:29:59 <Kaidelong> I don't quite understand why CS and math are taught separately
15:30:00 <dolio> But they don't encompass all of arithmetic on the natural numbers.
15:30:00 <merijn> DevHC: I know, but I can manage with only an approximate understanding of Gödel so far
15:30:19 <Jesin> if you take the set of "true statements about arithmetic" as your set of axioms, that's consistent and complete but not decidable
15:30:24 <merijn> Kaidelong: Because math is to big a field to teach everything in?
15:30:28 <roconnor> dolio: whether they express their own consistency is kinda debatable.
15:30:28 <Jesin> ...at least, we HOPE it's consistent
15:30:30 <Jesin> :p
15:30:37 <Jesin> we can't actually prove that it is
15:30:45 <Kaidelong> merijn: absolutely, but I don't learn everything offered in CS either
15:30:50 <roconnor> actually it is debatable as to weather Con_PA expresses the consistency of peano arithemetic.
15:30:53 <Jesin> reality may be self-contradictory and nobody would ever know  :D
15:31:10 <dolio> roconnor: As I understand it, they have theorems that there is no proof of false.
15:31:11 <Kaidelong> I guess having a CS degree is handier than having a specialization in CS related math
15:31:35 <Jesin> "handier" for what, though
15:31:37 <merijn> j-invariant: That's what people tell me about a lot of math papers. Experience has taught me that the intersection of what mathematicians consider readable or a good explanation and what *I* consider readable or good explanations is often the empty set
15:31:41 <roconnor> dolio: theorems within their system?
15:31:45 <dolio> Yes.
15:31:46 <Jesin> and what about applied math, and operations research
15:31:48 <Jesin> :p
15:31:53 <Kaidelong> Jesin: showing to someone who wants to hire you
15:32:12 <Jesin> depends on what the company does, I expect
15:32:21 <roconnor> dolio: sure but what theorems "mean" is subject to intepretation.
15:32:25 <Jesin> a BS in mathematics wouldn't be useful for much, compared to a BS in CS
15:32:28 <Jesin> I expect
15:32:38 <merijn> Depends on where you get the BS
15:32:40 <dolio> roconnor: I'm working with knowledge based on skimming his papers, though, so I don't really have a very good understanding.
15:32:42 <dolio> roconnor: Sure.
15:32:53 <Kaidelong> but judging by the math students I met, they could get by with the same labs and some of the same courses, I mean, why do I have to learn about matrices or binomials in CS classes as opposed tomath classes
15:32:54 <litb> i hear BS is worthless
15:32:58 <merijn> If you just get java programming in your BS its still not worth much
15:33:31 <litb> better go for MS
15:34:17 <dolio> roconnor: Truth be told, I don't see the big deal in a system proving its own consistency. Even if the proof means what you think it means, and in the complete absence of Goedel's theorem, you have to trust the system before you trust its proof of self-consistency.
15:34:23 <merijn> As I understand it's extremely uncommon to go for a MS in the US. They either quit after BS or go straight to PhD unlike a lot of places in Europe
15:34:58 <dolio> So it might be comforting, but ultimately worthless.
15:35:04 <rjo> how long it takes to do PhD typically in US
15:35:08 <dolio> Goedel's theorem just means it isn't comforting, either.
15:35:12 <Jesin> :p
15:35:23 <Jesin> it's like
15:35:26 <Kaidelong> merijn: a PhD does not improve your earnings much, if at all, over an MS, but it does open more doors
15:35:27 <Jesin> "Are you lying?"
15:35:32 <Jesin> and then the guy says "no"
15:35:36 <Jesin> does that make you feel better?
15:35:38 <Jesin> :p
15:35:54 <roconnor> dolio: indeed in some sense it isn't a big deal for that reason.   Still it would give you a little bit of a warm fuzzy feeling.
15:35:57 <Kaidelong> I think it ends up being a choice between wanting a private sector job or wanting to teach the subject at a university
15:36:04 <roconnor> dolio: oh you said that
15:36:15 <Kaidelong> for the prior, MS is fine, for the latter you need a PhD and then some postdoc stuff
15:36:18 <merijn> dolio: Well, it has interesting philosophical implications which help no one whatsoever :p
15:36:19 <Jesin> the big thing with Godel's incompleteness theorems, though
15:36:20 <dolio> roconnor: I think there's some other angle that Goedel shot down, but I forget what that is right now.
15:36:25 <Jesin> was the *completeness* aspect
15:36:51 <Jesin> he proved there will always be true statements you can't prove, unless your system proves a contradiction
15:36:55 <banisterfiend> dolio: 35.6 degrees
15:36:55 <Kaidelong> err well I suppose you could go work at a public laboratory or for the government with an MS
15:37:00 <roconnor> Jesin: sure, that is the first theorem. That is kinda a big deal.
15:37:06 <j-invariant> I don't think there are any important philosophical consequences of Godels theorem, unless you came from ancient grece and still believe in platonism
15:37:12 <dolio> Yeah, I guess it's the first theorem that's a big deal.
15:37:37 <Jesin> j-invariant: that IS an important philosophical consequence
15:37:37 <Kaidelong> incompleteness and the halting problem don't seem to me to be very (practically) relevant
15:37:44 <Jesin> why do you think people don't believe in platonism now?
15:37:46 <Jesin> :p
15:37:53 <Kaidelong> halting problem perhaps a bit more if you can show another problem is equivalent to it
15:38:06 <dolio> But I tend to think about the second theorem, because it has relevance to total programming languages.
15:38:09 <Kaidelong> but that's not a reason to shoot down efforts to find partial solutions to that problem
15:38:15 <rjo> Kaidelong, well, the essential may be the machinery of diagonal proof
15:38:18 <dolio> More direct relevance, that is.
15:38:40 <winxordie> j-invariant: even if you're a fomalist, it's important to know that there are statements true in your rule-games that can't be proven in your rules
15:38:48 <winxordie> *by
15:38:57 <j-invariant> winxordie: this is completely obvious to a formalist
15:38:59 <dolio> The first is just, "there are some programs you can't write in a total language." Which isn't that interesting. The second theorem is, "the interpreter for the total language is one," which is more interesting.
15:39:05 <roconnor> sadly the anti-platonists have gone too far :(
15:39:09 <winxordie> j-invariant: is it really?
15:39:19 <Jesin> [18:38:38]	<roconnor>	sadly the anti-platonists have gone too far :(
15:39:20 <winxordie> for _any_ finite rule game?
15:39:22 <Jesin> perhaps yes
15:39:27 <j-invariant> winxordie: consider the theory with three symbols a,b,c and two relations a < c and b < c. IT's undecidable whether a < b or b < a
15:39:28 <Jesin> also
15:39:38 <merijn> Kaidelong: Halting problem not practically relevant?
15:39:49 <merijn> Kaidelong: Try working with distributed systems/algorithms...
15:39:53 <roconnor> when I prove properties of my software, it isn't a meaningless game.  It has real world consquences
15:40:04 <Jesin> http://en.wikipedia.org/wiki/Tarski%27s_axioms
15:40:09 <Jesin> Euclidean geometry
15:40:15 <Jesin> consistent, complete, decidable
15:40:27 <roconnor> Jesin: that is another good example
15:40:28 <Jesin> as long as you don't try to talk about anything that isn't geometric, you're fine
15:40:29 <winxordie> j-invariant: with trivial examples yeah... I meant games with arbitrary rules. The "obvious" and the true are two very different things  <_<
15:40:30 <Jesin> :p
15:40:30 <Kaidelong> merijn: halting problem can't be solved in general, but you don't neccessarily have to
15:40:32 <dolio> Not _any_ finite rule game.
15:40:41 <winxordie> well, yeah
15:41:15 <Jesin> oh, sorry
15:41:20 <Jesin> *elementary* euclidean geometry
15:41:42 <roconnor> I think I finally convinced Cale that "PA + Con(PA)" and "PA + ~Con(PA)" are not equally good extensions of PA.
15:41:42 <merijn> Kaidelong: You don't have to, but live would be so much better :p
15:41:45 <Kaidelong> I mean, I know that const 5 halts even if I can't absolutely prove it does
15:41:54 <Jesin> XD
15:42:15 <winxordie> roconnor: what's Con(x) mean?
15:42:16 <Jesin> I wonder if "PA + ~Con(PA)" is decidably inconsistent
15:42:17 <Kaidelong> with a general algorithm
15:42:27 <Jesin> like, if you can actually prove a statement of the form P and not P
15:42:30 <roconnor> Jesin: nope
15:42:43 <roconnor> but "PA + ~Con(PA)" is decidable unsound.
15:42:51 <Jesin> hm?
15:42:56 <Jesin> k
15:43:06 <roconnor> "PA + ~Con(PA)" is hopefully consisnent, otherwise we are all in big trouble.
15:43:08 <Jesin> ooh, what's the formal definition of soundness involved in that
15:43:10 <Jesin> is there one?
15:43:11 <maurer_> ±
15:43:27 <Jesin> roconnor: oh, right
15:43:31 <merijn> Kaidelong: Well, I suppose all formal verification of software is academic masturbation as long as we don't have formally verified hardware which would mean we have to sort out this qunatum theory/string theory mess once and for all first :p
15:43:33 <roconnor> Jesin: a theorem is sound is all the theorems are true
15:43:40 <roconnor> Jesin: truth is defined by tarski
15:43:44 <Jesin> because if it's inconsistent, you prove Con(PA) by contradiction
15:43:47 <Jesin> got it
15:44:35 <roconnor> "PA + ~Con(PA)" can prove that "PA + ~Con(PA)" is not sound
15:44:45 <roconnor> heck even "PRA" can prove "PA + ~Con(PA)" is not sound
15:44:57 <roconnor> (PRA = primitive recursive arithmetic)
15:45:13 <Kaidelong> merijn: I think it is just more useful to say "I believe this halts" in some formal way than get hung up over being unable to say it for sure, in all cases, with a program that is itself total
15:45:28 <Kaidelong> there is a "good enough" there somewhere
15:45:33 <dolio> Doesn't set theory allow you to prove the consistency of PA? Seems like people would prefer PA + Con(PA) for that reason.
15:45:52 <dolio> Since they like set theory so much.
15:46:06 <roconnor> dolio: yes set theory can prove the consistency of PA, but why would you believe set theory is consistent?
15:46:31 <dolio> I didn't say it was.
15:46:51 <dolio> But if you like set theory, you should like PA + Con(PA) more than PA + ~Con(PA), right?
15:47:21 <j-invariant> roconnor: Once I read an argument like "We have a good intuition for sets and there have been no paradoxes found so far" - kind of amusing because sets make no sense at all
15:47:32 <roconnor> merijn: I expect in the future we will have a formal chain of logic all the way down to a model of physics.
15:47:35 <DevHC> what's the bet that intel sells processors which have backdoors in it, and intel can almost always trigger it to do intel's desires?
15:47:42 <Jesin> [18:43:13]	<roconnor>	Jesin: truth is defined by tarski
15:47:48 <Jesin> nice, where's this definition?
15:47:50 <Jesin> :p
15:47:53 <roconnor> j-invariant: :D
15:47:53 <dolio> Yes, everyone finds Banach-Tarski utterly intuitive.
15:47:54 <merijn> Kaidelong: Sure, but I find myself swinging between extremes all the time. From "full formal verification including hardware" to "screw this static typing business, stuff can go wrong even when verified so we might as well handle every possible error at runtime!". Somewhere in between is where solid engineering is, I just haven't decided where :p
15:48:48 <DevHC> lol
15:48:58 <roconnor> Jesin: http://en.wikipedia.org/wiki/Semantic_theory_of_truth#Tarski.27s_Theory   Jump to "Tarski developed the theory to give an inductive definition of truth as follows."
15:49:49 <merijn> roconnor: I would hope so, but I fear that it'll be a non-deterministic system unless they find a less silly physical theory then quantum mechanics
15:50:03 <roconnor> merijn: that is an accurate statement you made to Kaidelong
15:50:06 <roconnor> IMHO
15:50:07 <Jesin> I've actually managed to find a way to look at Banach-Tarski so that it's intuitive, but I have to come at it from a set-theoretic perspective which I don't seem to be bothering to do right now
15:50:22 <j-invariant> QM isn't nondeterministic
15:50:28 <roconnor> merijn: yes but we might be able to get a bound on the probablility of an error
15:51:04 <merijn> j-invariant: AFAIK the latest consensus in physics is that the universe is nondeterministic
15:51:08 <Kaidelong> why is QM "silly"?
15:51:24 <roconnor> saying QM isn't nondeterministic is kinda like saying that the List monad isn't nondeterministic.
15:51:31 <merijn> Kaidelong: Because my mind is deadset on the universe being deterministic
15:51:37 <rjo> merijn. evolution of qm is unitary, it is not non-deterministic
15:51:49 <Jesin> [18:49:54]	<j-invariant>	QM isn't nondeterministic
15:51:57 <Jesin> well, if you take the many-worlds interpretation it isn't
15:52:15 <Kaidelong> merijn: why should the universe be deterministic, and also was about to mention what Jesin just did
15:52:19 <Jesin> hmm... same for DeBroglie-Bohm, I think?
15:52:21 <merijn> Jesin: I suppose, but in that case my silly argument stands
15:52:30 <Jesin> I agree
15:52:32 <Jesin> :p
15:52:47 <merijn> Kaidelong: Hold on, I need to bring in my brothers more expert knowledge on this subject
15:53:05 <Jesin> actually I've seen a nice coherent argument for many-worlds and against the existence of time
15:53:13 <Jesin> it was fun  :D
15:53:40 <winxordie> Jesin: you should share in -blah :P
15:54:03 <merijn> rjo: It isn't deterministic in which quantum state a particle collapses, no?
15:54:08 <azaq23> Is there an easy way to print ANSI escape sequences, so they actually have their effect? There is Text.ShellEscape, but this doesn't seem to over printing functionality. I basically want to do echo -e "\\e[32;40mSomething\\e[0m" using haskell
15:54:10 <merijn> s/in/to/
15:55:30 <rjo> merijn, then you assume that that measurer knows completely in which quantum state he is in
15:56:47 <merijn> rjo: Why's that? (Also, maybe we should move this to #haskell-blash)
15:56:56 <roconnor> Jesin: btw, the axiom of choice in set theory has no arithmetic consequences
15:57:07 <Jesin> hmm
15:57:17 <Jesin> "arithmetic" being defined as what exactly
15:57:22 <j-invariant> roconnor: do you know wwhere I can read a proof o fthat?
15:57:28 <Jesin> like, on the natural numbers?
15:57:51 <Jesin> on the reals, disallowing infinite sums?
15:57:53 <cads> hmm, you guys, how could we measure the complexity of coding a specific task in a given language?
15:57:57 <Jesin> or what?
15:57:59 <roconnor> arithemtic sentences are formulas that only quantify over the natural numbers, and only have, lets say primitive recursive operations.
15:58:10 <gwern> heh. you know you're thinking haskelly when you write a test function using map, uncurry, and first before you realize you could write it as 'all (\(a,b) -> transform a == b) [...]'
15:58:11 <Jesin> *primitive* recursive
15:58:13 <Jesin> hmm
15:58:18 <monochrom> you could measure the number of days spent
15:58:22 <Jesin> apparently the Ackermann function is disallowed in that case?
15:58:25 <Veinor> gwern: ha
15:58:40 <rjo> merijn, I would turn it other way around, why you assume that there would be an observer, which is not obeyed the laws of qm?
15:58:41 <roconnor> Jesin: you can define all recursive functions in the language of arithmetic
15:58:52 <gwern> only with haskell could you ever write the pointless version *first* ;)
15:59:07 <rjo> even if it appears to be "macroscopi" and not entagnled as you and me
15:59:10 <shachaf> gwern: Probably with most concatenative languages too.
15:59:18 <rjo> sorry about the offtopic
15:59:20 <gwern> shachaf: oh. yeah, I suppose them too
15:59:20 <Jesin> roconnor: you didn't mean "primitive recursive" then
15:59:26 <Kaidelong> I really think stuff should be going to blah at this point
15:59:26 <gwern> shachaf: I think about them so little
15:59:33 <monochrom> you know you're thinking haskelly when you write javascript and forget to sprinkle "return"
15:59:40 <Kaidelong> someone asking for support has been scrolled off my screen, not that I know how to answer him
15:59:56 <cads> so for example I want to understand how complex it is for a human to write a program that grabs some code off of a website, turns it into xml, and then processes the data a little, all using the language's common libraries
16:00:09 <merijn> rjo: My knowledge of qm is to lacking to continue this conversation I think. I'll put it in the queue after Gödel :p
16:00:12 <shachaf> monochrom: That's just as much Rubyy or LISPy or Perly as Haskelly.
16:00:12 <monochrom> you could measure the number of days spent
16:00:41 <cads> monochrom, in a blind study or something like that?
16:00:44 <dolio> monochrom: I've been writing Python lately, and it's painful.
16:00:44 <azaq23> nobody has anything about the ansi escape stuff?
16:00:45 <monochrom> yes
16:00:46 <mm_freak> i'm trying to implement iteratees to understand them better…  now i'm writing to Monad instance and wonder, whether this is correct: return x = Yield x EOF
16:00:54 <mm_freak> to → the
16:01:02 <Jesin> "The Ackermann function A(m,n) is a well-known example of a total recursive function that is not primitive recursive."  :p
16:01:02 <mm_freak> this doesn't seem right to me
16:01:26 <roconnor> Jesin: you can replace primitive recursive with just "+ and *" and it won't change what functions are definable.
16:01:53 <dolio> monochrom: It's actually even worse, because it's scripts for a game, so I only know how to get a yes or no answer for "did the script work."
16:01:57 <mm_freak> oh, wait…  it does seem to be right
16:02:26 <dolio> Or, at best, "did it work up to line N?"
16:02:40 <Jesin> well then one of these is false:
16:02:41 <Jesin> [18:57:32]	<roconnor>	arithemtic sentences are formulas that only quantify over the natural numbers, and only have, lets say primitive recursive operations.
16:02:47 <Jesin> [18:58:14]	<roconnor>	Jesin: you can define all recursive functions in the language of arithmetic
16:03:04 <monochrom> moar static analysis is needed for these oh-so-dynamic-flexible languages like python and javascript
16:04:01 <Veinor> dolio: I've been trying to write Adium plugins in ObjC, and it's annoying
16:04:16 <Veinor> because if the plugin crashes, Adium does
16:04:17 <Cale> roconnor: Actually, I'd like to go over why it is that PA + ~Con(PA) has no models independently of the metalanguage.
16:04:56 <roconnor> Jesin: there is a difference between the primitive symbols of the languages, and what new functions are definable given those primitive symbols of the language.
16:05:21 <Cale> (which is I assume what you mean by unsound here)
16:05:34 <roconnor> Jesin: I should have just said "arithmetic senteces are formulas taht only quantify over natural numbers" and left it at that.
16:05:35 <Jesin> right, got it
16:05:35 <monochrom> I experienced a very stupid type error with supposedly mature python software. https://bugs.launchpad.net/debian/+bug/589495  This is the last straw for dynamic typing for me. I now have no faith in it.
16:05:38 <j-invariant> roconnor: or who proved that choice has no arithmetic consequence?
16:06:12 <Jesin> yeah, I would like to see what definition was used in proving that
16:06:12 <roconnor> Cale: PA + ~Con(PA) has models (hopefully), it is just the so called true model of the natural numbers isn't one of them.
16:06:28 <banisterfiend> monochrom: that link doenst work
16:06:30 <Cale> roconnor: er, weird
16:06:48 <Jesin> aaaaah ontology
16:06:50 <Cale> roconnor: Then I don't think I get what's so wrong with it :P
16:06:52 <roconnor> Cale: but rather than talking about models and all the philosph that entails, it is easier to say that PA + ~Con(PA) proves that PA + ~Con(PA) isn't sound.
16:07:02 <Cale> anything which has models is surely okay
16:07:05 <Jesin> roconnor: how does it do that
16:07:11 <Jesin> hmm
16:07:20 * Jesin scrolls up to the tarski thing
16:07:30 <j-invariant> Cale: why is it important to have a model?
16:07:47 <roconnor> Jesin: how does what do what?
16:08:13 <Cale> j-invariant: Because it implies that the theory in question actually discusses something in some other logical system -- so it has a "use" in a formal sense.
16:08:15 <roconnor> Cale: yes but when it comes to reasoning about, say software, unsound systems are not okay to use.
16:08:37 <j-invariant> roconnor: because google isn't helping me :/
16:08:56 <Jesin> ummm
16:09:08 <Jesin> roconnor: " * (v) An existential statement "there exists x A(x)" is true if and only if there is an object which satisfies "A(x)"."
16:09:13 <Jesin> that
16:09:19 <roconnor> j-invariant: why is it important for PA + ~Con(PA) to have a model?
16:09:20 <Jesin> looks a little weird
16:09:31 <j-invariant> roconnor: the proof the choice has no arithmetical consequence
16:09:34 <Jesin> and seems to contradict ZFC which implies for example Banach-Tarski
16:09:57 <Jesin> unless you take its tautological definition
16:10:01 <Jesin> in which case it's useless
16:10:17 <Jesin> you shouldn't have told me to scroll down that far
16:10:26 <roconnor> j-invariant: http://en.wikipedia.org/wiki/Absoluteness#Shoenfield.27s_absoluteness_theorem  &&  http://mathoverflow.net/questions/23917/shoenfields-absoluteness-theorem
16:10:29 <Jesin> I prefer this:
16:10:34 <j-invariant> thanks!
16:10:49 <Jesin> Tarski's material adequacy condition, also known as Convention T', holds that any viable theory of truth must entail, for every sentence P of a language, a sentence of the form: 'P' is true if, and only if, P.
16:10:58 <roconnor> Jesin: for arithemetic it is easier to make sense of that definition
16:11:14 <Jesin> right, because arithmetic only works with countable stuff
16:11:44 <roconnor> Jesin: specifically we have terms for all natural numbers in the term langauge
16:12:05 <Jesin> yes
16:12:10 <roconnor> Jesin: so you can read that as there exists normal terms in the meta langauge such that A(t) is true
16:12:22 <roconnor> *there exists some normal term
16:12:39 <Jesin> but ZFC fails that test
16:12:44 <Jesin> so does ZF
16:13:03 <Jesin> and anything that makes statements about uncountable sets
16:13:31 <Jesin> except theories that allow sentences of infinite length
16:13:33 <roconnor> Jesin: thankfully we are talking about arithmetic
16:13:36 <Jesin> or infinite alphabets
16:13:41 <roconnor> Jesin: but yes, I think such things are nonsense D:
16:13:44 <roconnor> *:D
16:14:18 <Jesin> not necessarily  :p
16:14:22 <Jesin> eh
16:14:24 <Jesin> I dunno
16:14:26 <Jesin> anyway
16:14:40 <roconnor> fair
16:15:07 <roconnor> I'm a formalist about set theory and a platonist about arithemetic.
16:15:11 <Jesin> why are we using a theory of truth that seems to invalidate ZF
16:15:16 <roconnor> ... and I don't much like set theory :D
16:15:17 <Jesin> =/
16:15:34 <j-invariant> set theory is fun, like brainfuck or whatever
16:15:35 <Jesin> yeah, and you're going so far as to claim ZF is unsound
16:15:38 <roconnor> Jesin: Tarski may have defined truth before ZF was invented?
16:15:39 <Jesin> :p
16:15:44 <Jesin> not only that, but
16:15:55 <Jesin> ANY theory that does real analysis
16:16:02 <roconnor> I wouldn't say that ZF is unsound.  I think that it is a meaningless statement
16:16:15 <roconnor> I don't beleive that ZF is consisntent though.
16:16:22 <roconnor> Nor do I believe that Z is consisntent
16:16:27 <Jesin> ...
16:16:34 <Jesin> you wouldn't say they're unsound
16:16:39 <Jesin> but you believe they're inconsistent?
16:16:41 <j-invariant> roconnor: any good evidence?
16:16:42 <roconnor> nore do I beleive that Coq is consistent
16:17:04 <roconnor> j-invariant: I don't beleive they are inconsistent.  I lack reasonable evidence that they are consistent
16:17:06 <dolio> "exists x. A(x)" is true if you can prove the meta-statement: exists t. "A(t)" is true, no?
16:17:12 <Jesin> ah
16:17:21 <Jesin> you're using a stronger definition of "believe" than what I'm used to
16:17:22 <j-invariant> oh okay
16:17:22 <Jesin> got it
16:17:33 <roconnor> j-invariant: As you noted tarski's definitoin of truth fails to apply to ZF, so I don't know what it would mean for ZF to be sound.
16:17:47 <roconnor> Jesin: ya, I was being provacative ;)
16:17:51 <Jesin> hmm
16:18:16 <dolio> Or can you not form an "A(t)" out of a meta-existentially-quantified t?
16:18:50 <Jesin> Tarski's material adequacy condition, also known as Convention T', holds that any viable theory of truth must entail, for every sentence P of a language, a sentence of the form: "P" is true if and only if P
16:18:58 <Jesin> hmm, does ZF satisfy that?
16:19:17 <roconnor> dolio: yes but the meta-statement exist t has to quantify over something.  Normally I use the term language to quantify over, but that doesn't work for set theory.
16:19:39 <Jesin> ooh
16:19:47 <dolio> Okay.
16:19:52 <roconnor> I suppose you could use set theory as your meta-langauge, but that seems overkill
16:19:53 <Jesin> have you ever seen the Tarski-Grothendieck axiom?  :D
16:19:58 <Jesin> you would love it
16:20:00 <Jesin> :p
16:20:01 <roconnor> typically meta-langauges are weak
16:20:21 <Jesin> http://en.wikipedia.org/wiki/Tarski%E2%80%93Grothendieck_set_theory
16:20:46 <Jesin> ∃y [x ∈ y ∧ ∀z ∈ y [∀w (w ⊆ z → w ∈ y) ∧ ∃w ∈ y ∀v (v ⊆ z → v ∈ w)] ∧ ∀z [z ⊆ y → (z ≈ y ∨ z ∈ y)]]
16:20:55 <banisterfiend> Jesin: holy shit you're a serious nerd
16:21:02 <roconnor> Jesin: break it down for me
16:21:13 <j-invariant> it defines universes
16:21:15 <Jesin> I know, I copypasted that just for lulz
16:21:21 <Jesin> "Tarski's axiom (adapted from Tarski 1939[1]). For every set x, there exists a set y whose members include:
16:21:22 <Jesin>     * x itself;
16:21:22 <zzing> Greetings. Has ghc made any progress on the iPhone development by chance?
16:21:24 <Jesin>     * every subset of every member of y;
16:21:25 <Jesin>     * the power set of every member of y;
16:21:27 <Jesin>     * every subset of y of cardinality less than that of y."
16:21:28 <Jesin> :D
16:21:38 <c_wraith> Now, get that as a tattoo.
16:21:46 <Jesin> and when you do the analogue of induction with THAT
16:21:51 <c_wraith> (I have goldbach's conjecture in formal logic as a tattoo)
16:22:01 <Jesin> like, you plug the "y" into the "for every set x"
16:22:02 <roconnor> I should mention that I do beleive that PA is consistent.  I find Gentzen's argument compelling.
16:22:08 <Jesin> and do that ad infinitum
16:22:26 <Jesin> ...
16:22:29 <Jesin> yeah it's freaking big
16:22:31 <Jesin> :p
16:22:41 <Jesin> what's Gentzen's argument btw?
16:22:43 <j-invariant> yeah epsilon is well founded
16:22:47 <roconnor> if someone gave me a similar arugment that ZF is consistent, then I'd believe
16:23:19 <roconnor> Jesin: http://en.wikipedia.org/wiki/Gentzen%27s_consistency_proof
16:23:23 <DevHC> i think i've found some epic facts
16:23:24 <DevHC> ?faq is the halting problem solvable in Haskell?
16:23:24 <lambdabot> The answer is: Yes! Haskell can do that.
16:23:35 <Jesin> XD
16:23:50 <roconnor> Jesin: it boils down to claiming that epsilon_0 is a well founded ordinal (notation).
16:24:11 <roconnor> I've stared at the definition of epsilon_0 and I find it very beleiveable that it is in fact well-founded
16:24:19 <mm_freak> in the 'enumerator' package, when doing a bind like x >>= f and both x and f yield a result, then only the "remaining chunks" part of x is returned and the remaining chunks of f are dropped
16:24:23 <mm_freak> why?
16:24:57 <Jesin> hmm
16:25:17 <Jesin> the least ordinal epsilon such that omega^epsilon = epsilon
16:25:47 <Jesin> hmm...
16:25:48 <roconnor> Jesin: seeing ordinal notations for cantor normal form makes it more compelling
16:25:52 <DevHC> that statement about the existence of a model of computation which can solve its own halting problem... i withdraw the statement until further notice :P [can't seem to find the article]
16:26:02 <Jesin> roconnor: I'm not sure I yet have a good intuition for what "well-founded" means in such contexts
16:26:06 <mm_freak> even though i know how to use iteratees it seems like i'm still not having the right intuition here
16:26:24 <roconnor> Jesin: every decesning sequence of ordinals is finite
16:26:29 <Kaidelong> DevHC: you can do it if you fall into a black hole
16:26:36 <Jesin> oh, THAT
16:26:38 <Jesin> got it
16:27:00 <DevHC> orly
16:27:55 <Kaidelong> someone developed a model of computation that exploits time dialation to allow you to see the result of running something for infinite time, kind of useless since the information will be lost forever
16:28:02 <Kaidelong> since it has to fall into a black hole
16:28:19 <DevHC> is it true that in a black hole, everything is consistent, complete, and computable within a limited time?
16:28:21 <roconnor> Kaidelong: won't it be radiated out later?
16:28:38 <Kaidelong> roconnor: if the radiation preserves the information in a useful form
16:28:50 <Kaidelong> DevHC: I think that computer has its own halting problem
16:28:53 <roconnor> well it does preserver information
16:28:59 <Jesin> ooh
16:29:01 <DevHC> yeah it will be radiated out of a white hole somewhere else
16:29:19 <roconnor> DevHC: it should be radiate out of the black hole's event horizion
16:29:38 <mm_freak> the radiation from a black hole contains no information about the objects, which fell in earlier
16:30:04 <roconnor> mm_freak: that is generally not accepted, though it is debatable
16:30:22 <Jesin> yeah, how would you go about proving it?  :p
16:30:29 <j-invariant> the radiation doesn't come from the inside of the black hole does it?
16:30:48 <Kaidelong> j-invariant: not in the way we think it'd happen. But this should be in blah
16:30:50 <j-invariant> a particle anti-partiacle pair splits near the edge... one half gets sucked in the other escapes right?
16:30:50 <DevHC> no, it comes from ur monitor radiating light
16:30:59 <roconnor> no it doesn't come from within the black hole
16:31:07 <j-invariant> so there is no way it can have any information from within the black hole (?)
16:31:11 --- mode: ChanServ set +o monochrom
16:31:11 <Jesin> hmm, apparently primitive-recursive arithmetic replaces the axiom schema of induction with an inference rule
16:31:24 <mm_freak> roconnor: well, it's quite intuitive, because the radiation is just the result of virtual particles appearing near the event horizon
16:31:35 * azaq23 found apparently the solution to his problem, System.Console.ANSI
16:31:42 <mm_freak> unless those particles are in some way connected to the inside, this information is completely random
16:31:49 --- mode: monochrom set +q *!*@quark.teteny.elte.hu
16:31:54 <roconnor> Jesin: as I understand negative information falls into the black hole allowing postive information to escape
16:31:58 --- mode: monochrom set -o monochrom
16:31:59 <centrinia> These particles are entangled with the inside.
16:32:21 <dolio> mm_freak: Leonard Susskind has a whole book about why that's incorrect, and his interaction with Stephen Hawking on the subject.
16:32:25 <dolio> The Black Hole War.
16:32:39 <mm_freak> dolio: hmm, ok
16:33:30 <mm_freak> centrinia: that entanglement is not established in the black hole…  it's just that one of two entangled particles falls into the black hole, while the other escapes
16:33:49 <j-invariant> you can't use entanglement as communication channel though...
16:33:55 <mm_freak> but that's only assuming hawking is right
16:33:58 <monochrom> we should do more haskell
16:34:02 <j-invariant> unless you also have a classical communication channel
16:34:13 <Jesin> yeah, but
16:34:18 <mm_freak> j-invariant: yes, but you can't actually extract that information
16:34:26 <Jesin> ...
16:34:28 <monochrom> there is #haskell-blah if you want
16:34:42 <mm_freak> anyway, i agree to monochrom, and i hoped that someone could help me with my little iteratee problem =)
16:34:49 <mm_freak> to → with
16:35:03 <Jesin> you don't have any information about what happens to an object inside of a black hole
16:35:06 <Jesin> probably
16:35:15 <Jesin> but all that says is that there's no information inside the black hole
16:35:25 <monochrom> Jesin: Do you have a haskell question?
16:35:30 <burp> who cares about information in black holes anyway? :D
16:35:33 <Jesin> sorry
16:35:38 <monochrom> burp: do you have a haskell question?
16:35:47 <roconnor> Jesin: if you know what fell into a black hole then you know exactly what is going on in it.
16:35:49 <roconnor> in theory
16:35:56 <mm_freak> lol
16:36:01 <monochrom> roconnor: Do you have a haskell question?
16:36:04 <burp> lol
16:36:18 <Jesin> :p
16:36:20 <mm_freak> we should turn physics discussions into a haskell data type
16:36:23 <sipa> @vixen does burp have a haskell question?
16:36:24 <lambdabot> church is my favourite computer scientist.
16:36:24 <Jesin> XD
16:36:32 <roconnor> monochrom: I have a question about computation theory.
16:36:35 <burp> I have haskell answers
16:36:45 <mm_freak> physicsDiscussion :: a
16:36:55 <parcs> i have a haskell question!
16:37:01 <mm_freak> parcs: ask it
16:37:23 <mm_freak> type ToPhysicsDiscussion a = forall b. b
16:37:24 <parcs> what would be the most convenient way to test haskell cgi applicaitons?
16:37:47 <mm_freak> parcs: enable CGI in your webserver and copy the executable into the webspace
16:37:54 <mm_freak> parcs: but a better solution is not to use CGI at all
16:38:06 <parcs> that's what i'm doign now
16:38:15 <parcs> but i'd prefer something like doesn't require compiling/linking
16:38:25 <monochrom> I may probably hand-craft the right stdin inputs to test :)
16:38:45 <monochrom> actually some tests also need the right environment variables
16:38:49 <parcs> ideally, a function like :: CGI -> IO () that sets up a simple CGI-enabled web server
16:38:59 <mm_freak> you won't find something like that, because haskell is a compiled language, but if you don't use CGI, but rather something persistent like a WAI handler, you can easily test your stuff in GHCi
16:39:11 <mm_freak> that doesn't improve your workflow, but it might be more convenient
16:39:18 <roconnor> parcs: don't forget about the GHC CGI security hole
16:39:26 <mm_freak> parcs: have a look at WAI
16:39:28 <parcs> i use fcgi for deployment
16:39:35 <rjo> roconnor, what is that?
16:39:42 <parcs> mm_freak: will do
16:40:12 <mm_freak> parcs: with WAI you can write your web application without caring for the gateway type, so you can use its mini-webserver for testing and later switch to fastcgi/whatever easily
16:40:17 <roconnor> rjo: because you don't want people hacking your computer
16:40:47 <rjo> well, I've now GHC CGI app running
16:40:52 <monochrom> I think "what is that?" means "what is the security hole, how does it work, how to fix it"
16:41:17 <roconnor> rjo: oh sorry I missread what you said
16:41:37 <mm_freak> hmm, i haven't heard about the GHC CGI security hole, but i could imagine it has something to do with command line arguments
16:42:19 <monochrom> something about +RTS but I can't find a problem
16:42:35 <rjo> ok
16:42:56 <mm_freak> monochrom: i'm not sure how to exploit that, but if you can somehow pass arguments to the program, you can do a lot of stuff
16:43:07 * roconnor can't find a description either
16:43:08 <mm_freak> at least DoS attacks would be possible
16:43:24 <rjo> I read only the POST body and parse JSON
16:43:25 <monochrom> yes, but it is not like a url has command line arguments
16:43:31 <j-invariant> So how do I stop haskell program from crashing?
16:43:44 <j-invariant> I want to limit the compiled program so that it dies instead of slows down my computer
16:44:00 <mm_freak> j-invariant: +RTS -M32m
16:44:02 * geheimdienst1 thinks it would have to be something with haskell's handling of stdin, but how could there be a security problem there ...?
16:44:26 <mm_freak> rjo: anyway, there is little reason to use CGI anyway
16:44:34 <mm_freak> there are much better gateway interfaces
16:44:47 <mafs> So is a typical (and better?) approach, if you're writing a service's API in Haskell, to use Network.Wai then?
16:44:53 <roconnor> geheimdienst1: it was somthing about people sending +RTS to the command line argument of the cgi program
16:44:56 <mm_freak> geheimdienst1: rather with command line arguments
16:45:17 <roconnor> geheimdienst1: you can, for example, set the profiling file to some arbitrary file on the system, such as /etc/password
16:45:19 <rjo> CGI JSON was easy to integrate to simple ajax requests
16:45:21 <mm_freak> mafs: a typical and better approach is not to do the low level stuff yourself
16:45:29 <McManiaC> usefull error messages nr. 591872
16:45:30 <McManiaC> expectJust cpeBody:collect_args
16:45:32 <McManiaC> :>
16:45:38 <rjo> but the app is not so serious
16:45:38 <mm_freak> mafs: there are some great web libraries for haskell like yesod, snap and happstack
16:45:47 <monochrom> the only route I can see is to get an account on the server first
16:45:54 <mafs> mm_freak: Ah, cool, will look into those. Thanks.
16:46:58 <stepcut> i highly recommend happstack :p
16:47:08 <geheimdienst1> i see. but how would you get command line args to the cgi program? (maybe i'm missing something)
16:47:39 <mm_freak> rjo: how easy it is to integrate some AJAX doesn't really depend on the gateway interface…  in most cases you would write the entire web app in haskell, but even when not, it's rather simple to use fastcgi or proxy requests to the haskell app
16:47:45 <mm_freak> stepcut: i prefer yesod
16:47:52 <j-invariant> main = print (sum (fix (1:))) <--- this program kills me
16:48:06 <mm_freak> geheimdienst1: a geheimdienst would know how =)
16:48:21 <dolio> That probably defaults to integer, and eats memory.
16:48:36 <roconnor> geheimdienst1: as I understand, somehow the comandline arguments are derived from the HTTP request.
16:48:39 <stepcut> mm_freak: yesod is very interesting if you like that kind of thing. It is certainly a capable system.
16:48:39 <mm_freak> j-invariant: use fold' instead of sum
16:48:46 <j-invariant> mm_freak: I want the program to crash
16:48:48 <j-invariant> it's a test case
16:49:02 <mm_freak> j-invariant: then use foldr =P
16:49:04 <j-invariant> ./Kill +RTS -M30m <-- when I do that it quits!! instead of slows my computer to a halt!
16:49:10 <j-invariant> thanks a lot
16:49:22 <j-invariant> Haskell programming will be a lot less worrying now
16:49:36 <mm_freak> yeah, but note that haskell programs can consume 30 MB quite quickly
16:49:45 <mm_freak> if you have the memory, use something larger
16:49:49 <mm_freak> like half of your RAM
16:50:07 <juhp> dumb question hopefully: does anything not need the base library?
16:50:30 <monochrom> I haven't found one. Even the () type needs base :)
16:50:30 <j-invariant> I asked this question a while ago but it led to discussion about halting problem, super turing computation, godels incompleteness theorem, tarskis undefinability of truth, grothendeick universes, consequence of axiom of choice, interpretations of quantum mechanics, black hole cosmology... Wow some interesting people in here :D
16:50:35 <juhp> :)
16:50:58 <stepcut> if you do -fno-implicit-prelude, then maybe you do not need base ?
16:51:14 <j-invariant> mm_freak: this is great though beacuse I can be in a sandbox while I test the pogram
16:51:26 * juhp is trying to subpackage all the ghc libraries...
16:51:41 <mm_freak> j-invariant: it's not a sandbox, because it might still fill up your hard-drive
16:51:46 <juhp> thought I would just put rts into the base package
16:51:48 <j-invariant> how come??
16:52:13 <mm_freak> writeFile "blah.txt" (repeat 'x')
16:52:18 <j-invariant> oh sure yeah
16:52:23 <j-invariant> that's okay though
16:52:32 <mm_freak> yeah, that's less of a haskell-typical problem =)
16:52:37 <mm_freak> heap/stack overflows are
16:52:53 <j-invariant> +RTS -M30m <-- this option fixes my test case but I wonder if there are more options you can use to be even safer?
16:53:01 <mm_freak> apropos RTS…  is there a mini-RTS with a limited feature set for embedded systems?
16:53:10 <mm_freak> j-invariant: +RTS --help
16:53:15 <monochrom> wikipedia says "Data is passed into the program using environment variables. This is in contrast to typical execution, where command-line arguments are used. In the case of HTTP PUT or POSTs, the user-submitted data is provided to the program via the standard input."  command line is emphatically not used.
16:53:51 <monochrom> but if someone has an account on the web server, sure he/she can run your program with any +RTS
16:54:08 <mm_freak> monochrom: that's not bad, unless the executable is SUID root
16:54:20 <mm_freak> or something like that
16:54:38 <rjo> happstack seemed interesting, thanks
16:55:01 <TTimo> factorials = zipWith ( let fr :: Integer -> Integer -> Integer ; fr 0 n = 1 ; fr p n = p * n in fr ) [0,1..] (1:factorials)
16:55:01 <TTimo> ^ can the let .. in part be simplified? some kind of anonymous function?
16:55:03 <mm_freak> stepcut: i don't like happstack that much
16:55:12 <stepcut> mm_freak: how come ?
16:55:14 <monochrom> the next thing is I'm not sure how to exploit +RTS. by turning on profiling?
16:55:25 <mm_freak> with yesod i can do rapid web development…  with happstack everything went slowly
16:55:41 <ulfdoz> I doubt it would be better than "fremdschmen".
16:55:42 <stepcut> mm_freak: why do you think that is ?
16:55:47 <ulfdoz> ewin, sorry.
16:55:57 <mm_freak> stepcut: i don't think, it's my experience
16:56:34 <monochrom> TTimo: since you want to write two equations for your function, let is as good as it gets
16:56:52 <stepcut> mm_freak: but what things do you think caused the difference is development speed ?
16:57:05 <mm_freak> > scanl (*) 1 [2..]
16:57:06 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
16:57:13 <TTimo> monochrom: I guess I could have an if then rather than pattern matching
16:57:27 <roconnor> monochrom: Now, one of the more little-known features of CGI is that if you pass a query string that does not contain any = signs to a CGI script, the httpd may pass the string along as command-line arguments. This is specified in section 4.4 of RFC 3875
16:57:30 <TTimo> not much better :)
16:57:35 <roconnor> http://www.amateurtopologist.com/2010/04/23/security-vulnerability-in-haskell-with-cgi/
16:57:38 <geheimdienst1> does the ghc runtime interpret any env variables by default?
16:57:40 <stepcut> mm_freak: for example, is it because yesod has better documentation which tells you exactly what to do and how to do it ? is it because of of specific features like web-routes ?
16:57:47 <monochrom> I see. Nice.
16:57:49 <mm_freak> stepcut: happstack is like a toolbox, while yesod is a real framework, where everything fits together
16:58:19 <aristid> it fits together in the snoyman way
16:58:36 <mm_freak> aristid: right, and i like the snoyman way =)
16:58:55 <philosopher> any one working on haskell for .net or java ?
16:58:55 <stepcut> mm_freak: i wonder how much of that is due to actual code -- versus simply being presented as a comprehensive solution with a 'right way' to do everything?
16:59:00 <philosopher> JVM*
16:59:10 <aristid> stepcut: the latter may help
16:59:17 <mm_freak> stepcut: i'm a yesod user =)
16:59:20 <geheimdienst1> roconnor, if the webserver for some urls calls a cgi program with user-defined arguments, i'd argue that this is a flaw in the server (or server config)
16:59:23 <stepcut> philosopher: people are always working on that, no one is ever finishing it though :(
16:59:59 <philosopher> what about an haskell to F# translation would that be a simplier/better idea ?
17:00:06 <geheimdienst1> ... very interesting find though
17:00:16 <mm_freak> philosopher: not possible, because F#'s type system is not powerful enough
17:00:28 <j-invariant> What would an efficent data structure be for multiple variable polynomials?
17:00:43 <stepcut> aristid: one of the things I plan to do for the next happstack 6 is document the way I use happstack. I am hoping that will give people a better idea of how to actually use things together in a system, instead of just having a lot of tools and too many choices
17:00:51 * monochrom can't tell toolbox from framework. maybe framework makes you write lots of callbacks and only callbacks? "we call you, don't call us"? toolbox is a lot of functions I call?
17:01:02 <mm_freak> j-invariant: a Map of IntMaps probably
17:01:02 <stepcut> i am curious to see how that changes peoples experience
17:01:03 <philosopher> mm_freak i tought those were close enought
17:01:08 <mm_freak> j-invariant: or a Map of Vectors
17:01:24 <j-invariant> is there a self contained "reference implementation" anywhre?
17:01:32 <mm_freak> philosopher: nope, haskell's type system is much more powerful…  for example in F# you can't express the 'fmap' function
17:01:33 * geheimdienst1 always thought a library is what you call, a framwork is what calls you. kind of library + inversion of control
17:01:38 <dolio> philosopher: F# lacks higher kinds, I think.
17:01:45 <geheimdienst1> in soviet russia, code calls you
17:01:47 <dolio> Like most MLs.
17:02:01 <litb> a callee is what i call and a caller is what calls me. 
17:02:09 <litb> w00t why is that!?
17:02:32 <dolio> And you need those for, say, constructor classes.
17:02:43 <mm_freak> monochrom: well, let me state it this way:  yesod comes with battery and cables included…  there is a "yesod" way to write web applications
17:03:09 <mm_freak> monochrom: happstack is a set of separate tools, which you stick together yourself the way you like
17:03:17 <stepcut> philosopher: probably not. Compiling to F# or to JVM are both hard. Someone has to have a very strong reason to really finish things and continue maintaining the project. grad students might do a prototype for fun -- but I suspect nothing will really stick until someone has a strong business use for it and is willing to fund the ongoing development
17:03:31 <mm_freak> monochrom: that's probably the difference between library and framework
17:03:56 <philosopher> stepcut would it be beneficial to haskell adoption ?
17:03:59 <stepcut> mm_freak: yesod is a bunch of separate libraries too though. the yesod stuff, the wai stuff, the hamlet stuff, the web-routes stuff
17:04:19 <monochrom> I think at the end it's rather subjective.
17:04:24 <stepcut> philosopher: maybe ? depends what oracle does to java I suspect
17:04:27 <mm_freak> stepcut: yes, and there comes the "cables included" part…  they are designed to work together
17:04:39 <philosopher> stepcut agree
17:04:44 <mm_freak> stepcut: everything seems to know about everything else
17:04:49 <philosopher> dolio even Haskell IR ?
17:05:41 <mm_freak> stepcut: anyway, i like the yesod approach…  others may prefer the happstack approach
17:05:58 <dolio> philosopher: When you compile to explicit dictionary passing, you end up with types like 'forall (m :: * -> *). MonadDict m -> ...'. F# can't handle types like that, I think.
17:06:26 <stepcut> mm_freak: perhaps. I wonder if that just comes out of good design. If you use HSP + web-routes, you can do things like, <a href=SomeLink>some link</a>, where 'SomeLink' is a web-routes based type-safe URL. That certainly gives the appearance of things knowing about each other, but HSP and web-routes were developed separately..
17:06:40 <dolio> And such 'm' aren't always statically known, so you need those types.
17:06:49 <mm_freak> dolio: it can't, because type constructors are not first class in F#
17:06:58 <mm_freak> so no monads, no functors, etc.
17:07:02 <dolio> Yeah.
17:07:21 <mm_freak> it has "computation expressions", which resemble monads, but not with the same flexibility
17:07:25 <stepcut> mm_freak: right, there is nothing wrong with yesod. I want to find out what is right about yesod, and figure out what can be applied to happstack 
17:07:26 <hpc> that's a rather fundamental feature to omit...
17:08:01 <mm_freak> hpc: very few languages have that feature
17:08:18 <mm_freak> mostly only those with a HM type system
17:08:27 <stepcut> mm_freak: but, the two systems  will always have different design decisions and tradeoffs
17:08:43 <mm_freak> stepcut: yes, and i found the one that works better for me =)
17:08:44 <dobblego> scala has it, without a HM type system
17:08:59 <dolio> Even systems based on HM may not have it.
17:09:02 <hpc> mm_freak: it's still fundamental; consider the quantity of languages that lack lambdas
17:09:09 <dolio> As I mentioned, ML and OCaml don't, I believe.
17:09:09 <mm_freak> dolio: right, for example haxe doesn't have it
17:09:20 <dolio> Which is why F# doesn't. presumably.
17:09:32 <mm_freak> i found that no .NET language has it
17:09:39 <mm_freak> probably the runtime is not powerful enough
17:10:34 <vilhelm_s> I'm having a problem when I want to give a less than maximally polymorphic type annotation to a toplevel binding creating by a pattern match. Any tips? http://hpaste.org/42698/too_polymorphic_foo
17:10:35 <dolio> I mean, basic HM is a restriction of System F.
17:10:40 * hackagebot mysnapsession 0.2 - Memory-backed sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.2 (ChrisSmith)
17:10:50 <dolio> First-class, higher kinds are extention toward F omega.
17:11:40 <hpc> vilhelm_s: you can't say the function returns a value (String, y)
17:11:49 <hpc> and then give it a number as the first part
17:11:52 <hpc> and a function as the second
17:12:28 <vilhelm_s> hpc: The number is not related, it gets matched against the _ .
17:12:39 <roconnor> geheimdienst1: well I guess it is a flaw in the CGI RFC.  I guess you could send a comment to someone. That what an RFC is for.
17:12:41 * hackagebot mysnapsession-example 0.2 - Example projects using mysnapsession  http://hackage.haskell.org/package/mysnapsession-example-0.2 (ChrisSmith)
17:13:16 <hpc> o.O
17:13:30 <geheimdienst1> roconnor, you're right, it's an rfc flaw too
17:13:44 <hpc> vilhelm_s: is that inside a do or let block?
17:14:35 <vilhelm_s> hpc: The file is exactly as I pasted it, but I guess a toplevel pattern match like that might be treated like a let binding...
17:16:19 <hpc> o.O
17:16:49 <hpc> i suppose, don't use top level patterns
17:17:19 <stepcut> mm_freak: yes, and I want to know why it works better for you so I can improve happstack :)
17:17:41 <vilhelm_s> If this was System F one could use an extra typelevel abstraction and application to explicitly instantiate the polymorphic type, but I don't know if one can guide Haskell to do that... :)
17:19:35 <vilhelm_s> hpc: Or use a different type annotation, I suppose.
17:20:21 <hpc> does a top level pattern only work for tuples?
17:20:41 <vilhelm_s> I think it works generally.
17:20:53 <hpc> that seems like it would end badly
17:21:21 <vilhelm_s> probably. :)
17:24:37 <mm_freak> stepcut: ah, i see now why you're asking =)
17:25:51 <mm_freak> stepcut: well, it took time to get used to all those quasiquoting/TH stuff, but it really helps to have a concise representation of what i want
17:26:37 <mm_freak> stepcut: an AJAX guestbook in yesod (the server part) hardly takes more than two pages of code
17:26:48 <mm_freak> which already includes type-safe URLs and the database connection
17:28:08 <mm_freak> and for the client part i use haxe, which compiles down to (among others) javascript
17:28:20 <mm_freak> it's an ECMA-based programming language
17:30:43 <mm_freak> stepcut: but really you can't improve happstack so much that it's like yesod, because then it wouldn't be happstack anymore
17:31:04 <mm_freak> happstack is not necessarily worse, it's just different
17:31:22 <stepcut> sure
17:31:46 <stepcut> the quasi-quote stuff is certainly a big aspect of the yesod stuff, and something happstack is not likely to embrace
17:31:55 <mm_freak> yeah
17:32:09 <stepcut> mm_freak: but the feeling of integration and being able to do things with out a lot of code is certainly something we can improve on
17:33:21 <mm_freak> well, the QQ/TH stuff really reduces code a lot, because besides just representing some data it also writes a lot of boilerplate for you, including functions, instances, types, etc.
17:33:49 <mm_freak> and in fact it adds some static checking, which haskell alone couldn't add in this scenario
17:34:22 <McManiaC> just my opinion, but the less TH you use, the better
17:34:53 <mm_freak> McManiaC: i haven't written QQ/TH code so far, only used it, and in some cases it's really useful
17:35:08 <mm_freak> a few days ago someone asked for here-document syntax, and you can do it using QQ
17:35:13 <mm_freak> that's quite useful
17:35:20 <cdsmithus> TH and QQ stuff is definitely an easy way to reduce the amount of code you write... but it's *just* about reducing boilerplate, not about programming with simpler, cleaner abstractions.  In that sense, it's a missed opportunity.
17:37:20 <cdsmithus> That's my take.  There's nothing wrong with it versus chugging out boilerplate.  It's just that there's likely to be something even better... a good set of combinators that better capture the essence of what you meant
17:38:05 <McManiaC> yeah
17:38:56 <McManiaC> imo a library that requires a lot of boilerplate is… not the best library you could imagine ;)
17:39:09 <Mitar> is this a bug: http://hpaste.org/42699/problems_with_monomorphism_res
17:40:15 <McManiaC> it's like HSP ("great I can write html instances for my objects before I can use them…") vs. blaze-html ("I just write down that object representation")
17:40:39 <McManiaC> no offence vs. HSP, but… :)
17:42:33 <cdsmithus> Mitar: Can you do that?  there's no way for the compiler to deduce what instance applies.  I don't think you can write that class.
17:43:40 <mm_freak> cdsmithus: with TH you can express some things, which you couldn't in normal haskell, like writing types and instances with additional static checking
17:43:53 <mm_freak> haskell can check a lot statically, but not everything
17:44:06 <Mitar> it works without type signature, cdsmithus
17:44:18 <Mitar> once i add a type signature GHC itself gives me, things do not compile
17:44:26 <cdsmithus> Mitar: Does it really?  Or is the error just postponed to the site where someone else tries to refer to fun?
17:44:44 <McManiaC> mm_freak: most of the type you could write the same code without requiring types and instances
17:45:03 <cdsmithus> Or to fooFun?
17:45:42 <Mitar> cdsmithus, good observation
17:46:08 <azaq23> A very simple line color program for the terminal, written using System.Console.ANSI: http://hpaste.org/42700/colorify_program
17:46:16 <Mitar> but why would it be impossible
17:46:21 <mm_freak> McManiaC: and i think what yesod does is outside the scope of this "most of the time" =)
17:46:23 <cdsmithus> Mitar: There is definitely an error in your code.  Once type inference determines that you mean fun to be a TestData, it still cannot infer that you meant to use the Int instance for Foo, because FooType is a type family, so isn't necessarily one-to-one
17:46:32 <Mitar> if i write "fun :: (FooType Int)"
17:46:40 <Mitar> compiler should exactly know which fun to call
17:46:46 <mm_freak> Mitar: have you tried without ScopedTypeVariables?
17:47:11 <McManiaC> mm_freak: maybe… I'm not too familiar with yesod. but I still think using TH is not the ideal solution. and yes, I prefer happstack :>
17:47:36 <Mitar> there is only one fun with "FooType Int", type, as there can be only one class instance per type
17:47:43 <mm_freak> McManiaC: i'm not a big fan of TH myself, and so far i haven't written a library which requires TH/QQ
17:48:06 <McManiaC> I once wrote a biiiig library mostly containing TH
17:48:07 <mm_freak> but i forgive michael snoyman for doing it, because it's actually useful =)
17:48:17 <cdsmithus> Mitar: FooType Int is just a fancy way of writing TestData.  And there's no way to infer from TestData that you meant to use the Int instance
17:48:18 <McManiaC> just to get rid of every little function step by step again
17:48:26 <McManiaC> the result was a very nice library ;)
17:48:53 <McManiaC> oh and one big (if not the biggest) problem with TH/QQ are the GHC error messages…
17:49:10 <McManiaC> you basicly loose almost everything GHC provides for you :)
17:49:24 <Mitar> cdsmithus, that is true, but from FooType Int there should be a way
17:49:37 <cdsmithus> mm_freak: definitely, there's a lot cool about Yesod.  Not my cup of tea, but no denying Michael has written the most coherent answer yet to the question of writing web apps in Haskell.
17:50:14 <cdsmithus> Mitar: Again, FooType Int means exactly the same thing as TestData.  So you can't decide anything because of "FooType Int" that you couldn't also decide from TestData
17:50:43 <Mitar> what is then purpose of having type inside a class?
17:50:58 <Mitar> then it would be the same as if I would move "type FooType Int = TestData" outside of the instance
17:51:23 <cdsmithus> Mitar: Yeah, associated types are just syntactic sugar for the equivalent code using type functions.
17:52:04 <cdsmithus> But they are useful... you just have to make sure that the compiler can determine the right instance to use by other means.
17:52:27 <Mitar> any good suggestions how?
17:53:04 <mm_freak> McManiaC: how good the error messages are depends on how much work you put into writing proper TH =)
17:53:09 <cdsmithus> Mitar: No, since I don't understand what you're trying to do (names like "foo" are nice for technical discussions, but when it comes to design...)
17:53:38 <mm_freak> cdsmithus: Foo contains types, which give other types some kind of default value
17:54:01 <mm_freak> that's my interpretation
17:54:17 <mm_freak> but better names would be good, even in examples
17:54:17 <cdsmithus> One possibility is to turn "type" into "data"... then it's injective, so inference is possible in the direction you want.
17:56:10 <Mitar> yes, i just had data
17:56:33 <Mitar> in had a function, which choosed which instance to use according to return value
17:56:35 <Mitar> and it worked
17:56:51 <Mitar> now i wanted to open more what is possible and to use type
17:56:59 <Mitar> but now we have a problem ;-)
17:57:55 <cdsmithus> Mitar: Yeah.  With data, each instance defines a distinct type, so you can look at that type and decide the instance that defined it.  But with type, several instances can use the same type, and it's no longer possible to decide the right instance in that way
17:59:13 <Mitar> yes, but with data you have to define many times the same data type even if it is in fact the same, just so that types would be different
17:59:43 <Mitar> it would be great i would be able to say use this data type, just make it a new type so that you can infer which instance you need
18:00:37 <cdsmithus> Another possibility is to use Tagged.  Let me look up the library
18:01:06 <cdsmithus> http://hackage.haskell.org/package/tagged
18:02:22 <cdsmithus> Then the type of 'fun' would be Tagged a (FooType a).  You'd have to unwrap it at the call site using unTag
18:02:22 <Mitar> ooo
18:02:45 <cdsmithus> s/unTag/unTagged/
18:03:50 <Mitar> they are both, untag and unTagged
18:04:02 <cdsmithus> oh, right
18:05:53 <pastorn> > (+1)
18:05:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:05:53 <lambdabot>    arising from a use of `...
18:06:14 <pastorn> could someone fixate that expression to trigger her show instance?
18:06:29 <pastorn> please? :)
18:10:03 <aristid> > id
18:10:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:10:04 <lambdabot>    arising from a use of `...
18:10:15 <aristid> > id :: () -> ()
18:10:15 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> ())
18:10:16 <lambdabot>    arising from a use of...
18:12:00 <Jesin> [20:53:50]	<cdsmithus>	One possibility is to turn "type" into "data"... then it's injective, so inference is possible in the direction you want.
18:12:05 <Jesin> there's also newtype
18:12:07 <Jesin> :p
18:12:18 <tswett> So, delimited continuations.  I'm pretty sure that reset takes a continuation-laden computation and turns it into a pure one.  What does shift do, again?
18:12:38 <tswett> I should just read a blog post again.
18:13:16 <tswett> Okay, shift is just like callCC, isn't it?
18:13:38 <tswett> Hm, maybe not quite.
18:14:06 <tswett> If the continuation is invoked, *shift* returns the continuation's argument; if the function returns, *reset* returns its return value.
18:14:52 <Mitar> cdsmithus, thanks
18:15:11 <tswett> Whoa, and continuations return.
18:16:11 <tswett> What the heck motivated this behavior?  :P
18:16:13 <Mitar> is there a nicer way to write a "(\o -> o { targetEnabled = False })"
18:16:21 <Mitar> so function which would update a record?
18:16:39 <tswett> Mitar: well, you could always write a function called disableTarget.
18:16:53 <Mitar> true ;-)
18:16:58 <dobblego> Mitar, there are various packages on hackage for this problem
18:16:59 <tswett> I don't know of an easier way.
18:17:19 <Mitar> ok, i was just thinking if i am missing some obvious thing
18:17:32 <dobblego> http://hackage.haskell.org/package/data-accessor for example
18:18:26 <Mitar> i want to pass as an argumenet a record update function
18:18:28 <Mitar> currently i do
18:18:37 <Mitar> function $ \o -> o { targetEnabled = False }
18:19:00 <Mitar> probaly there could be a way to combine $ \o -> o into something?
18:20:20 <mikeg> @hackage fclabels
18:20:20 <lambdabot> http://hackage.haskell.org/package/fclabels
18:21:04 <ion> @pl \o -> o { foo = False }  -- does pl have any ideas?
18:21:04 <lambdabot> (line 1, column 9):
18:21:04 <lambdabot> unexpected "{"
18:21:04 <lambdabot> expecting variable, "(", operator or end of input
18:21:24 <djahandarie> pl doesn't support records or guards (and other h98 stuff)
18:21:25 <Mitar> @pl (\o -> o { foo = False })
18:21:25 <lambdabot> (line 1, column 10):
18:21:26 <lambdabot> unexpected "{"
18:21:26 <lambdabot> expecting variable, "(", operator or ")"
18:21:32 <ion> djahandarie: aye
18:22:58 <tswett> Okay, let's see.  Once shift happens, the insides of shift are the expression that reset will eventually return, and the continuation essentially acts as everything between shift and reset.  I wonder how this is useful.
18:25:39 <Mitar> how is called that you fix polymorphic function to one perticular type with type signature?
18:26:37 <kmc> hey, is Hades still under development?
18:27:05 <dolio> (foreach x in c: (shift k: Yield x k)) ; Done
18:27:05 <tswett> Well, there's "adding a type signature", "specifying the type", and "restricting the type".  I don't know of any better names.
18:27:07 <Mitar> i think souls have not yet left it
18:27:11 <kmc> zygoloid, that's your project, right?
18:27:19 <Mitar> restrict is good
18:27:43 <dolio> That turns a for loop into a sequential iterator.
18:28:43 <ion> It seems there’s no point-free syntax for record updates. I’d be glad to be proven wrong, though.
18:29:02 <dolio> read (Yield x k) = x ; next (Yield x k) = k ()
18:29:12 <kmc> ion, there isn't.  you'd have to use a package like fclabels, lenses, or data-accessor
18:31:32 <Mitar> kmc, but they all require some boilerplate
18:31:52 <kmc> yes, if only to invoke the boilerplate-generator via Template Haskell
18:36:57 <mikeg> is the performance of record updates something to worry about, if I'd just be changing pointers in C?
18:37:38 <kmc> worry about it once you've profiled the code
18:38:21 <kmc> in GHC compiled code it's pretty cheap
18:38:32 <kmc> you're allocating a new struct, but the fields of the struct are just pointers
18:38:41 <kmc> and you copy the pointers from the old struct, rather than a deep copy of the structure
18:38:45 <mikeg> cool, thanks
18:38:52 <kmc> (when things are immutable you almost never have to deep-copy)
18:39:11 <kmc> also allocation in GHC is much cheaper than most mallocs, though some of that cost is deferred until garbage collection
18:39:33 <mikeg> ghc does it's own allocing, i assume?
18:39:34 <kmc> it's not uncommon for Haskell programs to allocate cumulative hundreds of GB of memory in a few seconds, while keeping the maximum heap residency in the tens of MB
18:39:51 <kmc> yes, the GHC runtime has its own allocator in several layers
18:40:25 <kmc> a slab allocator to get memory from the OS, and then a fairly fancy allocator for heap objects with generational garbage collection
18:40:49 <kmc> "allocation" in most cases involves just advancing a pointer
18:42:15 <mikeg> Considering that, I guess there's no reason about the overhead of a record update package :)
18:44:58 <Mitar> on wikipedia it is wrriten
18:44:59 <Mitar> 	•	Additionally, when a new type is declared as http://en.wikipedia.org/wiki/Isomorphic to an existing type, any type class instance declared for the underlying type may be lifted to the new type "for free".
18:44:59 <Mitar> [http://en.wikipedia.org/w/index.php?title=Glasgow_Haskell_Compiler&action=edit&section=6]
18:45:06 <Mitar> http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler
18:45:06 <Mitar> is this true?
18:45:15 <Mitar> is not this still in a phase of a proposal?
18:45:20 <Mitar> http://hackage.haskell.org/trac/ghc/ticket/3205
18:46:41 <kmc> that's GeneralizedNewtypeDeriving
18:46:59 <kmc> it's existed for a while, see GHC manual
18:47:06 <kmc> i'm not sure if this ticket is about the same feature
18:47:29 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/deriving.html#newtype-deriving
18:51:07 <copumpkin> @hackage hoopl
18:51:07 <lambdabot> http://hackage.haskell.org/package/hoopl
18:57:48 <copumpkin> what's a good name for data ? = Open | Closed ?
18:58:32 <Mitar> Doors?
18:58:42 <Mitar> Hole?
18:58:44 <Mitar> Window?
18:59:05 <ProfElm> Greetings, everyone!
18:59:43 <Random75> toggle
18:59:54 <djahandarie> copumpkin, is that data X = Open | Closed X, or is the second question mark the actual question mark?
18:59:56 <ray> closure
19:00:07 <copumpkin> djahandarie: the question is about the name of such a data type
19:00:12 <copumpkin> it's more general than a window or door
19:00:32 <copumpkin> connectivity?
19:00:39 <kmc> valve
19:00:52 <djahandarie> Err. I'm asking if it was    data X = Open | Closed X   or    data X = Open | Closed
19:01:50 <copumpkin> oh
19:01:54 <ray> if these are open and closed sets, those aren't mutually exclusive and your type doesn't work
19:01:59 <copumpkin> nah, the last ? was for the purpose of grammar
19:02:19 <copumpkin> ray: it's something that is definitely either open or closed
19:02:54 <roconnor> copumpkin: Boole
19:03:21 <ray> SteampunkBool
19:07:57 <Gracenotes> I might cop out and call it State
19:08:16 <Gracenotes> terrible and terribly generic name
19:08:56 <roconnor> Switch
19:09:07 <Gracenotes> but I suppose you could look for synonyms like Position
19:09:37 <roconnor> SPST
19:10:18 <ray> zomg but haskell can't have state
19:10:48 <zomg> ray ban sunglasses rock
19:11:27 <ray> i don't want to ban sunglasses rock
19:11:32 <ray> what's wrong with it
19:12:14 <Gracenotes> yes, my family went to sunglasses rock for vacationing
19:12:22 <Gracenotes> perfectly nice place
19:15:52 <pastorn> how do i find out how many cores my machine has?
19:15:55 <gwern> hm. if haskellers were more musical, we create an anthology album 'declare a newtype state'
19:16:13 <pastorn> (cpu cores)
19:16:57 <gwern> there was a module that did that
19:17:17 <ray> read the cpu box
19:17:43 <pastorn> ray: right...
19:19:56 <pastorn> ray: that's going to work awesome when i want to use my optimizations on some arbitrary machine...
19:20:04 <gwern> numberOfProcessors
19:20:25 <gwern> @hoogle numberOfProcessors
19:20:25 <lambdabot> No results found
19:20:36 <gwern> hrm. there is ghc code that calls that...
19:20:42 <gwern> Win32/System/Win32/Info.hsc:        numberOfProcessors  <- (#peek SYSTEM_INFO, dwNumberOfProcessors) buf
19:21:51 <gwern> oh, looks like all callers are c code
19:21:53 <gwern> how annoying
19:25:29 <dons> pastorn: generally, you can use numCapabilities
19:25:39 <dons> and ghc will pick the right number (on most platforms)
19:25:40 <adu> fascinating
19:31:36 <polarina> Does anyone know of an unboxed array running in the STM monad?
19:37:58 <kmc> you can use the immutable UArray within STM code
19:38:02 <kmc> Data.Array.Unboxed
19:38:50 <kmc> i'm not aware of a mutable unboxed STM array
19:39:19 * hackagebot husk-scheme 1.3 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-1.3 (JustinEthier)
19:50:46 <Olathe> What is the default operator precedence?
19:50:54 <lispy> hi
19:50:58 <Olathe> Hello.
19:51:11 <lispy> Cale: CPU usage on lambdabot is really high.  Any idea why?
19:51:18 <Kaidelong> Olathe: 9, I believe
19:51:19 <dmwit> Olathe: You can check the precedence of any operator in ghci with :i.
19:51:26 <dmwit> Oh, I misunderstood the question, sorry.
19:51:41 <Olathe> Thanks :)
19:51:45 <Olathe> No problem.
19:52:10 <lispy> Olathe: let's check the report.  Should be 5, I think
19:52:14 <lispy> and infixl
19:52:17 <Kaidelong> use forward polish notation if you are unsure
19:53:08 <lispy> Olathe: Any operator lacking a fixity declaration is assumed to be infixl 9
19:53:20 <lispy> Olathe: http://www.haskell.org/onlinereport/decls.html See section 4.4.2
20:09:03 <Cale> lispy: Ah, mueval has restructured a bit, and so the script I have to catch stray mueval processes didn't work anymore
20:09:31 <Cale> Hopefully this will work better.
20:10:01 <lispy> Cale: ah
20:10:16 <gwern> stray muevals? that shouldn't be possible...
20:10:19 <lispy> Cale: linode emails me, and the emails are kind of funny.  It was using over > 100% :)
20:10:55 <gwern> (I mean, the watchdogs are supposed to kill muevals after a few seconds)
20:11:32 <lispy> ?versio
20:11:32 <lambdabot> lambdabot 4.2.2.1
20:11:32 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:11:42 <lispy> gwern: is that new enough to have them?
20:12:04 <gwern> watchdogs have been in from pretty much the beginning. also lb version != mueval version
20:13:01 <lispy> ah
20:13:14 <lispy> gwern: mueval has bad run-aways from the start
20:13:25 <gwern> it has?
20:14:11 <lispy> gwern: yeah, the script Cale is running has existed from pretty much the first month it was hosted on my server
20:14:58 <lispy> also, I meant to write, "has had run-aways..."
20:15:03 <lispy> Not "has bad"
20:16:49 <gwern> how can I fix these thigns if no one tells me what the problem is
20:18:31 <BMeph> Is there a name for the relation, if there is one, between two functions where one is a more general form of the other, say 'id' and '$'?
20:20:21 <banisterfiend``> BMeph: i dont know, sorry.
20:20:40 <mm_freak> BMeph: generalization?
20:21:11 <banisterfiend``> mm_freak: hi, i can neither confirm nor deny this as accurate terminology -- i just do not know, im sorry.
20:21:14 <mm_freak> BMeph: id is a generalization of ($)
20:22:31 <BMeph> mm_freak: So does that make '$' a specialization of 'id'?
20:22:42 <mm_freak> yeah
20:22:47 <mm_freak> or a special case
20:23:05 <mm_freak> in some cases you can also say abstraction
20:23:18 <mm_freak> but in this case it doesn't really fit
20:23:27 <mm_freak> the Monad class is an abstraction for Maybe
20:23:56 <mm_freak> also the term generalization is much more common than the term specialization
20:24:08 <mm_freak> instead of specialization you often say "instance", which is more common
20:24:12 <mm_freak> ($) is an instance of id
20:26:10 <mm_freak> hmm
20:26:15 <mm_freak> > sin `id` 3
20:26:16 <lambdabot>   0.1411200080598672
20:26:53 <sshc> How should I profile a library that has dozens of dependcies?
20:27:08 <ion> Which binds tigher, $ or `foo`? (I’ll just look it up if nobody remembers it offhand.)
20:27:19 <ion> tighter
20:27:23 <c_wraith> by default, things in backticks bind at infixl 9
20:27:30 <c_wraith> ($) is infixl 0
20:28:16 <ion> Thanks
20:30:37 <ion> > ((1+) $ 2 / 3, (1+) `id` 2 / 3)
20:30:38 <lambdabot>   (1.6666666666666665,1.0)
20:32:11 <qq_> Happy New Year!
20:35:16 <Jesin> mm_freak: I prefer specialization in that context
20:36:27 <sshc> What's the downside to installing every library with --enable-library-profiling?
20:37:04 <kmc> takes longer to install libraries
20:37:08 <mm_freak> sshc: i think, more detail, which may be good or bad
20:37:09 <kmc> takes more disk space
20:38:26 <sshc> Does it affect the performance of executables that use those libraries, even if the executable themselves are not profiled?
20:39:05 <sshc> Significantly at least?
20:40:46 <pastorn> @hoogle numCapabilities
20:40:46 <lambdabot> No results found
20:41:10 <lispy> gwern: no worries.  Would it help if I gave you an account on my server?
20:41:37 <pastorn> dons: cool, it was in GHC.Conc
20:41:40 <pastorn> thanks :D
20:43:10 <copumpkin> seems like hoopl's lattice is really a semilattice
20:44:00 <c_wraith> sshc: there's no different when compiling non-profiled executables
20:44:10 <c_wraith> sshc: the profiling libraries are entirely different versions of the libraries
20:44:20 <c_wraith> sshc: and the non-profiling libraries are also kept around
21:11:05 <sshc> If I set "library-profiling" in ~/.cabal/config to `True', I won't need to pass "--enable-library-profiling" to cabal configure, right?
21:15:36 <kmc> this may or may not be a Haskell question but: if Cabal is building a C file for me, is there a standard predefined preprocessor symbol for getting the CPU architecture?
21:19:43 <Ke> http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros ?
21:21:01 <kmc> thanks
21:21:14 <Ke> nothing relevant there apparently
21:22:22 <allbery_b> http://predef.sourceforge.net/prearch.html
21:23:20 <allbery_b> also ANSI specifies a different way to do it
21:25:10 <Mitar> http://hpaste.org/42702/overlapping_instances << why?
21:27:22 <allbery_b> hm, I'm wrong, asserttions weren't ANSI
21:27:44 <allbery_b> (they should have been IMO; arch macros are an ugly way of doing it due to namespace issues)
21:35:39 <sshc> When I install a library package with profiling enabled (via ~/.cabal/cabal), is one library instealled with profiling and one without, or will only the profilig version be enabled?
21:40:54 * hackagebot yackage 0.0.1 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.0.1 (MichaelSnoyman)
21:52:50 <ksf> @hoogle MonadIO m => ForeignPtr a -> (Ptr a -> m b) -> m b
21:52:51 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
21:52:51 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
21:52:51 <lambdabot> Foreign.Marshal.Alloc allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
21:52:59 <ksf> yeah I know those.
21:53:47 <ksf> argh. those little things. I want to stick WriterT IO in there.
21:56:24 <mm_freak> can i, as a library author, force users to use -threaded or at least issue a warning, if not?
21:56:40 <mm_freak> i compile time error/warning that is
21:56:52 <mm_freak> i → a
21:57:04 <lispy> sshc: you get both
21:57:22 <lispy> sshc: I just enable profiling libraries in my ~/.cabal/config file
21:57:46 <lispy> sshc: The reason is because cabal doesn't track when it installs which and to enable it in one library often requires that you --reinstall each dependency manually
21:58:10 <lispy> sshc: Another alternative to that is to use cabal-dev which can automate the install of dependencies
21:58:13 <mm_freak> ksf: it's easy to write MonadIO versions of those functions
21:58:36 <lispy> sshc: (cabal-install cabal-dev and then use cabal-dev like cabal just that it stores the package db in your pwd instead of in a global place)
22:06:09 <pastorn> dons: how can numCapabilites be :: Int and not :: IO Int?
22:06:52 <copumpkin> it's a bit of a philosophical question whether it should be IO Int or Int
22:18:15 <ksf> hmmm. I finally got around to continue to hack on the k-nucleotide benchmark
22:18:26 <ksf> ...and thus to benchmark my code against the old one.
22:18:49 <ksf> I'm already approx. as fast, and that's without fine-tuning anything.
22:19:59 <pastorn> copumpkin: since it's requesting data from somewhere i'd say IO, but i get the other argument
22:20:01 <pastorn> i think
22:20:13 <ksf> says I'm spending 11% time in ffs.
22:20:22 <pastorn> if it's that everything that you do "inside" the CPU is pure anyway...
22:20:41 <ksf> ...which is foreign import ccall "strings.h ffs" c_ffs :: CInt -> CInt
22:20:51 <kmc> the number of capabilities is a constant and requesting it isn't externally visible
22:21:23 <ksf> short of manual bit twiddling, what's the best way to get the first set bit?
22:21:37 <ksf> kmc, there's hot-swap cpus
22:22:30 <kmc> the number of capabilities is just the value of the +RTS -N flag
22:22:35 <kmc> it doesn't care if you've hot-swapped a cpu
22:22:44 <ddarius> copumpkin: Not really.  You can hot-swap CPUs.
22:23:00 <copumpkin> yeah, but the runtime keeps it constant
22:23:13 <ddarius> copumpkin: But arguably it should be variable.
22:23:17 <copumpkin> yeah
22:23:34 <kmc> echo 0 > /sys/devices/system/cpu/cpu1/online
22:23:35 <copumpkin> and even if constant for a single session, there are arguments for putting it in IO
22:23:42 <ksf> no inline llvm, yet?
22:24:06 <ksf> I could really use the hardware ffs, here.
22:28:10 <copumpkin> mkFTransfer f m l = FwdTransfers (f, m, l)
22:28:19 <copumpkin> f m l is how I feel trying to read this hoopl code :)
22:28:30 <copumpkin> it's nice in many ways but isn't very accessible
22:29:27 <ksf> hmmm. I'm faster for n = 25000 and slower for n = 250000
22:30:30 <lispy> "I'm reading hoopl source code.  FML. -- copumpkin" :)
22:33:20 <ksf> should I be worried that I'm spending more time hashing stuff than looking it up?
22:33:44 <lispy> ksf: hmm...possibly
22:34:04 <ksf> seems like a clear case of too good hash function.
22:38:36 <lispy> ksf: well, I don't say "certainly" because by hashing you may be saving hugely on your lookup times.  It would certainly be good to improve the hashing time, but it may not be a bad thing a priori.
22:39:46 <ksf> ...I don't think so.
22:40:15 <ksf> right now the whole table should fit into cache, and it's a hopscotch table.
22:51:39 <ksf> ...is there a regression in 7.0.1 foldl'ing  over strict bytestrings? those numbers just don't make any sense.
22:59:08 <adu> YEY
22:59:14 <adu> it's stable
23:00:46 <BMeph> Stability is overrated. At least, that's what I tell my wife when she complains about my cackling laughter coming from my laboratory... ;)
23:04:26 <adu> perhaps I should commemorate this by uploading to hackage
23:10:00 <mm_freak> well, if numCapabilities is a constant, then i wonder why getArgs is an IO action
23:10:19 <mm_freak> or all those environment variables functions
23:10:23 <ksf> you can write to argv
23:10:37 <ksf> ...and some c libs do exactly that. filtering out their own options.
23:10:39 <mm_freak> you can write to env vars, too, ok
23:11:00 <augur> hmm
23:11:29 <augur> ksf: what do you think of this idea: variable declaration by way of strictly relational properties
23:12:01 <ksf> I think that I don't get your drift.
23:12:21 <augur> ksf: eg suppose you have some k-tuple p, and you know that p' is such that forall i. p'[i] = f p[i]
23:12:36 <augur> for some function f
23:12:42 <ksf> yep
23:12:51 <ksf> well that looks like a canditate for functor.
23:12:53 <ion> The number of CPUs can change in runtime, too. :-P
23:13:00 <mm_freak> does getArgs even return the real command line args or just a constant copy of them?  because the RTS options are stripped out
23:13:14 <ksf> a copy, of course.
23:13:21 <ksf> it's returning [String]
23:13:29 <augur> why not allow somthing like   let' p ~ i = f (p' ~ i) in p
23:13:54 <mm_freak> yes, but by accessing the real argv?  or does the RTS save a copy of them at startup?
23:14:20 <ion> mm_freak: Does that matter?
23:14:25 <ksf> I bet it accesses when getArgs is run.
23:14:42 <ksf> yep, a C lib might've filtered out some arguments.
23:14:48 <mm_freak> ion: sure, because if it's a copy, then getArgs might just as well be a simple constant
23:14:51 <augur> ksf: then you could lazily access the bits as you need to. any time you evaluate p~i for some definition i and for the pre-existing p, you evaluate that as f (p'~i)
23:16:02 <ksf> augur, I... have no idea.
23:16:05 <augur> ksf: :|
23:16:19 <augur> well would it be INTERESTING at least to be able to define variables that way? :|
23:17:25 <augur> i suppose it would be equivalent to if you had something like ~' that behaved like so p = ~' (\i -> f (p' ~ i))
23:21:00 <augur> which i suppose is sort of like a map..
23:21:27 <augur> p = fmap f p'
23:22:44 <ksf> I'd rather like to have supercompilation
23:22:54 <augur> supercompilation?
23:23:02 <augur> is that compilation by superman?
23:23:05 <ksf> ...because those abstractions are killing my runtime.
23:23:25 <ksf> that's very agressive program specialising 
23:28:58 <augur> ksf: what abstractions
23:31:12 <Time_> Hello?
23:31:30 <ion> No.
23:31:40 <ksf> augur, think inlining f into a fold.
23:31:49 <augur> ksf: huh
23:31:55 <TheMachi`> #pylocal
23:32:10 <ksf> ...which is a thing that needs supercompilation to be done generically and properly.
23:32:27 <augur> ksf: i dont understand what you're talking about
23:32:46 <ksf> it allows you to write your algorithms generically and still have them run as fast as a hand-specialised version.
23:32:58 <augur> ksf: i.. see
23:34:26 <ksf> why, btw, do inline pragmas destroy scc annotations?
23:35:38 <ksf> ...the -auto-all'ed ones, I mean.
23:36:20 <Enigmagic> i'd guess that the auto-all pass runs after the inliner?
23:38:42 <ksf> ./knuc < fasta.250000  0.68s user 0.01s system 99% cpu 0.695 total
23:38:45 <ksf> ./knuc-orig < fasta.250000  0.56s user 0.02s system 97% cpu 0.590 total
23:38:48 <ksf> getting there.
23:40:22 <systemfault> ksf: Writing a code for the shootout?
23:40:31 <ksf> yep.
23:40:45 <systemfault> Cool :)
23:40:56 <systemfault> How close are you from the "best"?
23:42:13 <systemfault> Hmm, the test does it with 25 millions
23:42:55 <ksf> ...right now I'm trying to beat the haskell version ^^
23:43:18 <systemfault> Yeah 8.88secs right now
23:43:26 <jeffwheeler> I like the idea of using GObject-Introspection (basically, Gtkish libraries define their interfaces in Typelib files, any language can use 'em), and somebody even wrote an interface to the C library for reading those Typelib files.
23:43:56 <jeffwheeler> I'd like to go the next step and make those dynamic libraries usable in Haskell, but I don't see a clever way to do it. Does it simply require static generation of interfaces? That seems ugly.
23:44:39 <jeffwheeler> (I.e. literally writing to Haskell cabal projects . . .)
23:46:34 <jeffwheeler> I guess that's going to be a pretty general problem with any statically-compiled language and interface introspection . . .
23:48:37 <Enigmagic> jeffwheeler: code generation is the common way to do this in c/c++ and haskell
23:49:17 <jeffwheeler> Enigmagic: ew, but I guess there's not really going to be a good solution. I guess I can probably at least do better than literally printing out Haskell source code?
23:50:02 <jeffwheeler> Enigmagic: also, you appear to be correct . . . I just found gmmproc, which does code generation for C++ for this exact purpose
23:50:33 <Enigmagic> jeffwheeler: not really... there is template haskell if you'd like to talk directly to the compiler but it's harder to debug
23:51:00 <jeffwheeler> Enigmagic: I don't know, I'm inclined to do something like that. Just printing Haskell seems so dirty.
23:52:05 <Enigmagic> it all goes to the same place. there are a couple libraries like haskell-src and haskell-src-exts that make it easier to print source out
23:52:26 <Enigmagic> i'd prefer working directly with the compiler ast but the debugging tools are not as good
23:52:29 * ksf still doesn't get where that %individual time comes from. everything's stuffed with SCCs
23:52:57 <jeffwheeler> Enigmagic: thanks a lot for your help; I'm gonna look at template-haskell and haskell-src
23:53:20 <Enigmagic> np, good luck
23:54:46 <augur> type driven semantics
23:54:48 <augur> anyone?
23:55:10 <ddarius> Semantics are already type driven in many languages, particularly Haskell.
23:55:40 <augur> ddarius: no no, i mean that the semantics of the programming language itself is type driven
23:56:21 <augur> like being able to redefine what function application means when theres a particular kind of type alignment
23:57:03 <ksf> wtf bytestring's foldl' doesn't get inlined.
23:57:03 <augur> e.g. being able to say (f :: a -> b) (xs :: a) :: [b]
23:57:09 <ddarius> All that would require is making application an operator (i.e. juxtaposition desugars into use of an operator) and sticking it in a type class.
23:57:30 <augur> i suppose, but that would just be for application
23:57:38 <augur> plus, you'd get circularity
23:57:50 <augur> if it desugars into an operator, and operators desugar into functions ..
23:58:16 <augur> f x -> app f x -> app app f x -> ...
23:58:27 <ddarius> Once you desugared, you wouldn't desugar again.
23:58:32 * hackagebot language-go 0.5 - A library for analysis and synthesis of Go code.  http://hackage.haskell.org/package/language-go-0.5 (AndrewRobbins)
23:58:48 <adu> YEY
23:58:49 <augur> ddarius: hm. i suppose it'd be type-mismatch driven then, surely
23:59:36 <Enigmagic> ksf: does it inline the regular foldl?
