00:03:17 * edwardk waves hello.
00:03:38 * hackagebot semigroups 0.3.3 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.3.3 (EdwardKmett)
00:31:25 <edwardk> i think i'm just going to write a small higher order set of prelude classes like the various TypeableN instances for OrdN, EqN, ShowN, just so i can avoid all these undecidable instances and to make it easier to use polymorphic recursion and typeclasses together
00:32:18 <edwardk> instance (Show (f (Stream f a)), Show a) => Show (Stream f a) — becomes instance (Show1 f, Show a) => Show (Stream f a) — and becomes Haskell 98
00:32:37 <edwardk> (even instance (Show1 f) => Show1 (Stream f)
00:45:12 <edwardk> hrmm, meh, not so great actually, because many of those don't require instances for all of their members, bah
00:56:26 <triyo> I've read the article "List leads off with the Letter" in the latest Monad.Reader Issue 17 and thought it was a great read. Only thing I'm trying to determine is the definition of the 'list' function.
00:57:30 <triyo> I see figure 12, 13 but don't fully get it.
01:01:14 <ray> i don't see any "list" function
01:01:22 <ray> i'm assuming it hasn't been edited from the original blog post
01:03:00 <Botje> there's no definition needed
01:03:04 <ray> he just uses that word to indicate an arbitrary member of the functional list type he's explaining
01:03:20 <Botje> you build up a list by using <| and |> on empty
01:03:30 <triyo> ok so: .... list <| x = list . (x:) ... list here is just a list?
01:03:36 <Botje> (5 |> 6 |> 2 |> empty)
01:03:41 <Botje> would be an instance of such a beast
01:04:07 <Botje> triyo: if you look at the types, list has to be a function
01:04:08 <triyo> oh on empty. and empty = id
01:04:17 <Botje> a function [a] -> [a]
01:04:34 <triyo> sp hence empty = id? Right
01:04:37 <triyo> *so
01:04:46 <Botje> yep
01:05:08 <Botje> and you apply such a list thing to a *real* list to transform it into the list you want
01:06:05 <Botje> those things are called 'difference lists'
01:06:11 <triyo> Oh I'm chewing on that last part :)
01:06:39 <Botje> let's deconstruct that 5,6,2 list above
01:06:46 <Botje> simply by replacing |> with the definition:
01:07:08 <Botje> (5 |> 6 |> (2:) . empty)
01:07:22 <Botje> (5 |> (6:) . (2:) . empty)
01:07:31 <Botje> (5:) . (6:) . (2:) . empty
01:07:36 <Botje> what's the type of that?
01:07:53 <triyo> oh, light bulb moment. A list. 
01:08:05 <Botje> :t (5:) . (6:) . (2:) . id
01:08:06 <lambdabot> forall t. (Num t) => [t] -> [t]
01:08:13 <triyo> because (5:) is partial application
01:08:18 <triyo> so its a function
01:08:28 <Botje> remember, (.) composes functions, so the result is a function
01:08:42 <triyo> yep understand that now
01:08:46 <Botje> > (5:) . (6:) . (2:) . id $ []
01:08:48 <lambdabot>   [5,6,2]
01:09:24 <Botje> you start with the empty list, cons 2 in front of it, cons 6 in front of it, cons 5 in front of it and return it
01:09:26 <triyo> that last one is clear as daylight 
01:09:56 <triyo> So Thats appending to the front of the list
01:09:59 <Botje> yep
01:10:16 <Botje> well, we call it consing :)
01:10:39 <triyo> right like in lisp, got it :)
01:10:59 <Botje> and the trick with appending at the end is simply switching functions around
01:11:10 <ray> the other thing is like id . (1:) . (2:) . (3:)
01:11:10 <triyo> Is it still called consing if appending to back of list? ;)
01:11:23 <Botje> triyo: some people call that snoc
01:11:32 <triyo> heheh
01:11:33 <Botje> ray: yep
01:11:34 <ray> > id . (1:) . (2:) . (3:) $ []
01:11:36 <lambdabot>   [1,2,3]
01:11:54 * hackagebot haskell-src-exts 1.10.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.10.1 (NiklasBroberg)
01:12:28 <triyo> So consing to the end of the list using <| is constant time and not linear time?
01:12:44 <triyo> no need for ++ or reverse right
01:12:44 <triyo> ?
01:12:47 <Botje> triyo: yes, because it's all function composition
01:13:04 <triyo> That is so sexy
01:13:11 <ray> a list only gets built when you apply the function you built up to a seed list
01:13:13 <ray> in this case []
01:13:27 <ray> the function you build up just conses itself to the seed list there
01:13:34 <Botje> triyo: it's the same trick showS uses
01:14:09 <triyo> Oh ok, so nothing new but just very effective.
01:14:23 <Botje> it's a nice explanation
01:14:30 <ray> it's a neat trick, i bookmarked his blog post
01:17:22 <triyo> Thanks guys for helping me grok that article. I feel like I've learned something constructive today.
01:17:32 <Botje> no problem
01:17:34 <Botje> have fun!
01:31:28 <Axman6> win 23
01:32:21 <shachaf> Axman6: Fewer keystrokes: Alt-o Ctrl-N-N-N
01:32:55 <Axman6> i... don't know what's happening :O
01:33:23 <Axman6> ah right, handy, thanks
01:34:26 <ion> More convenient: the window_switcher script and ^Gpart-of-channel-name or ^Gwindow-number
01:43:45 <quicksilver> shachaf: unless you care that that marks windows 19 thru 22 as "read"
01:44:07 <shachaf> quicksilver: Fair enough.
01:44:19 <shachaf> (Or that I can't count.)
01:44:35 <shachaf> However, I care rather more about polluting my command line history.
01:44:41 <quicksilver> and /w 23 is also only 4 keystrokes.
01:45:04 <quicksilver> the fact that some operations in irssi accumulated command history and some don't is a source of occasional cognitive dissonance for me
01:45:28 <quicksilver> ditto the fact that some force you to discard your currently in-progress typing and some don't
01:47:50 <Maxdamantus> Which force you to discard your currently in-progress typing?
01:49:03 * hackagebot prelude-extras 0.1 - Haskell 98 - higher order versions of Prelude classes  http://hackage.haskell.org/package/prelude-extras-0.1 (EdwardKmett)
01:50:34 <shachaf> quicksilver: I d
01:51:05 <shachaf> quicksilver: I just use irssi -- I've avoided spending very much time configuring it.
01:51:17 * Maxdamantus too.
01:51:27 <qfr> How do you change the output directory of cabal, by the way? Do you need to customise the ghc-options section?
01:51:32 <qfr> I don't want "dist"
01:51:36 <Maxdamantus> I use it minimally enough not to have noticed those behaviours.
01:51:41 <quicksilver> Maxdamantus: ones which are typed as /commands, like /win 23
01:51:43 <shachaf> A big annoyance is that when you run a command, like /lastlog or /names, the output gets permanently embedded in the channel window. It's silly.
01:52:06 <Maxdamantus> this is a test
01:52:09 <Maxdamantus> Hm.
01:52:12 <Veinor> failure
01:52:33 <triyo> Botje: I only noticed now, but the 'put to front' example (5 |> 6 |> 2 |> empty) [1,2,4] ... gives me a 'No instance for (Num (a1 -> [t]))       arising from the literal `6''
01:52:36 <Maxdamantus> If I'm in the middle of a line and I need to do a command I press down so it just gets pushed into the history.
01:52:46 <triyo> this is in ghci session
01:52:59 <quicksilver> Maxdamantus: good idea :)
01:53:04 <Saizan> qfr: --builddir=
01:53:08 <quicksilver> Maxdamantus++
01:53:10 <qfr> Ah, tnaks
01:53:11 <Maxdamantus> How do you usually do it? O_o
01:53:12 <qfr> thanks, too*
01:53:18 <quicksilver> Maxdamantus: I usually delete the line.
01:53:25 <Maxdamantus> Ah. Hoh,
01:53:28 <Maxdamantus> s/o/e/
01:54:35 <shachaf> Maxdamantus: I've tended to do ^A ^K ... ^Y
01:54:44 <shachaf> And carefully avoid ^W etc. while typing the command.
01:55:07 <Maxdamantus> There's something I often press accidentally which deletes a line -_-
01:55:11 <Maxdamantus> Should figure out what it is.
01:55:34 <Maxdamantus> Yeah, probably ^K since it happens when I try doing bold with ^B
01:55:40 <Maxdamantus> test
01:55:47 <Maxdamantus> No.
01:56:11 <shachaf> ^K deletes to the end of the line.
01:56:33 <Zao> ^U clears line in most prompts.
01:56:38 <Maxdamantus> Ah, that's it.
01:56:58 <Zao> ^W erases a word, ^U erases from cursor to home or everything, depending on app.
01:57:30 <shachaf> Ah, ^U.
01:58:17 <qfr> Saizan ghc.exe: unrecognised flags: --builddir=binary
01:58:22 <Maxdamantus> I use A-d to erase words.
01:58:39 <Saizan> qfr: it was for cabal install/configure
01:58:50 <Maxdamantus> (requires to go to the start of it though)
01:58:51 <qfr> ghc-help
01:58:52 <qfr> <stdout>: hPutChar: resource vanished (Broken pipe)
01:58:54 <qfr> Oh, I see
01:58:58 <qfr> ghc --help*
01:59:04 <Saizan> see cabal install --help
01:59:09 <ray> triyo: sounds like it's associating in the wrong direction
02:02:16 <qfr> Yay, it works, thanks
02:02:24 <triyo> ray: hmm, if you look at the example on the blog, to me it doesn't look right. (5 |> 6 |> 2 |> empty) [1,2,4] ⇒ [5,6,2,1,2,4] .... and (empty <| 1 <| 2 <| 3) [4,5,6] ⇒ [1,2,3,4,5,6]
02:02:47 <triyo> these both seem to be consing to the front, right?
02:03:29 * ksf_ thinks it'd be a shame if ghc switched off darcs.
02:03:47 <ksf_> it can't be that impossible to enable them to switch to v2, can it?
02:04:14 <Bynbo7> i'd fall much more inclined to contribute if they used git
02:04:31 <ksf> shut up.
02:04:40 <Bynbo7> heh
02:04:43 <ksf> seriously, and usually I'm all nice in this channel.
02:05:08 <ksf> if you can't figure out darcs, which is significantly easier to use than ghc, you're in no position to hack on ghc, anyway.
02:05:42 <ksf> modulo the hoops you have to jump through in the ghc case, of course.
02:05:49 <Bynbo7> i can use darcs just fine, and have in the past, but git makes some very important things much easier than darcs
02:05:56 <ksf> that's the whole point, darcs must scale to ghc.
02:06:05 <Bynbo7> sure, but it doesn't yet
02:06:06 <ksf> and darcs others.
02:06:44 <ksf> and a switch would come with its own set of problems.
02:06:54 <Bynbo7> sure
02:07:03 <ksf> so why sink the ship, we just need some new sail.
02:07:07 <ksf> s
02:07:22 <Bynbo7> because it will take a long time to get those features
02:07:42 <ksf> also if the darcs devs reorder their roadmap?
02:07:45 <ray> nope it just conses the thing to the front of the seed list
02:11:51 <triyo> ray: so that is how it suppose to work? I though <| will put it at the back of the list.
02:12:04 <ray> yep
02:12:21 <Bynbo7> the main reason i want ghc to move to git is so that we can use github. if there was a website that does everything that github does for darcs, then i'm all for using that instead. but that's not going to happen for a long long time
02:12:36 <ray> just when you eventually apply the list to a "real" list that's what it does
02:12:42 <ksf> *groan*
02:12:45 <ksf> there's patch-tag.
02:13:44 <Bynbo7> comparing patch-tag to github is like comparing a ford focus to a supercar, they're just so completelt missmatched in terms of very useful, features
02:14:04 <ksf> also note that the switch isn't inspired by switching to github or a love of git, but certain problems in darcs that keeps ghc from switching to the v2 repo format
02:14:06 <Bynbo7> and the fact that you've tried to compare them shows how little you know about the issue
02:14:22 <ksf> which, in the end, means that the ghc devs are using a years-old version of darcs.
02:15:06 <ray> have they officially switched over yet
02:15:36 <Bynbo7> no, they're requesting comments on whether they should or not
02:15:43 <ksf> I know that tey don't have the same feature set (but don't have a patch-tag account), but we have a mob of web developers who, as you see in the haskell.org case, are willing to show off their skills.
02:16:13 <ray> are they really still on darcs 1? why is that
02:16:29 <Bynbo7> when the idea first came about, i was a bit upset that darcs wasn't really up to the job, and thought it was a shame to move away from it. but after using git, making the change makes a hell of a lot of sense
02:16:35 <ksf> hmmm. their blog says darcs 2.8 will drop legacy-repo write support.
02:16:41 <ray> i figure you need to subscribe to 300 mailing lists to get the full story on this stuff
02:17:06 <Bynbo7> ksf: have you ever actually used github?
02:17:20 <ksf> not extensively, but I do know my way around.
02:17:31 <dibblego> why does cabal install cabal-install run the installation even though I have the latest already installed?
02:17:49 <ksf> because it doesn't track executables
02:18:00 <ksf> as ghc-pkg only cares about libraries
02:18:09 <dibblego> aah
02:18:24 <dibblego> does anything track those?
02:18:45 <ksf> not on the haskell side, not that I'd know, no.
02:18:50 <dibblego> ok ta
02:19:00 <ksf> portage does do tracking for the system part of my install, though.
02:19:44 * ksf wonders whether "does do" is actually valid english
02:20:49 <shachaf> ksf: "actually valid"?
02:20:57 <shachaf> ksf: It's a common idiom, at least.
02:21:12 <ksf> as opposed to me merely thinking it's valid.
02:21:28 <Bynbo7> sure it's valid
02:21:28 <quicksilver> ksf: "Yes, it does do that"
02:21:44 <quicksilver> (it's fine)
02:21:59 <Bynbo7> though, "Yes, it does that" is equally valid and means the same
02:22:13 <shachaf> Bynbo7: "does" and "does do" aren't identical.
02:22:14 <ksf> so english does do allow that?
02:22:44 <quicksilver> ksf: no; in that version 'allow' is the subordinate verb
02:22:45 <shachaf> ksf: Do you have a similar objection to the phrase "would do"?
02:22:45 <ksf> that'd be valid nethergerman.
02:22:57 <quicksilver> ksf: 'does do' is the case where 'do' is the subordinate verb.
02:23:12 <Bynbo7> shachaf: how are they not? i can't think of an example
02:23:13 <ray> you only get one
02:23:17 <quicksilver> "It does fly" "It does permit" "It does drink" "It does do (something)"
02:23:21 <ksf> not at all, but speakers of standard german don't do the whole constructions with do stuff.
02:23:38 <Bynbo7> ah, "it does fly" is not the same as "it does do fly" :P
02:24:09 <quicksilver> Bynbo7: "it does do" emphasises that it *does* in fact, do that.
02:24:17 <ksf> ...itself, even.
02:24:25 <quicksilver> Bynbo7: compare the difference between "it flies" and "it *does* fly"
02:24:28 <ksf> enstrengthenment of agency.
02:24:35 <shachaf> Bynbo7: Yes, what quicksilver said. :_)
02:24:37 <shachaf> s/_/-/
02:24:43 <ray> portage does (do tracking), portage does (tracking), portage does (track executables)
02:24:54 <Bynbo7> quicksilver: see, that's cheating, you added emphasis asterisks!
02:24:59 <quicksilver> ;)
02:25:00 <shachaf> s/-/‾/
02:25:08 <quicksilver> my emphasis asterisks were to draw your eye to emphasis already there.
02:25:19 <Bynbo7> heh, i know :)
02:25:22 <ray> these all work and the middle one is the outlier because of stupid gerunds
02:26:41 <ray> i find gerunds the single most distinctive feature of english, but i'm not that equipped to judge because it is my native language
02:27:43 <Bynbo7> gerunds?
02:27:45 <ksf> my english teacher claimed we got them wrong every time.
02:27:54 <Veinor> Bynbo7: 'walking', 'talking'
02:27:55 <ksf> ...because german has it's own, very common nounifications.
02:28:10 <Veinor> using a verb as a noun
02:28:10 <shachaf> Veinor: In what sense?
02:28:14 <shachaf> Veinor: Ah, as a noun.
02:28:20 <shachaf> That's not really unique to English.
02:28:32 <Veinor> yeah, that's why i'm slightly confused about that statement
02:28:49 <quicksilver> I think calling them gerunds is silly terminology based on classical latin
02:29:00 * ksf thinks it'd be hard to construct a language in which such basic synthesis'd be invalid
02:29:07 <quicksilver> I would instead say "modern english permits you to use the present participle as a noun..."
02:29:36 <quicksilver> but then again, I'm no grammar expert :)
02:29:40 <ksf> using the preset participle give the whole thing its own taste
02:29:47 <ksf> ...german uses the infinitive.
02:31:46 <ray> in english you say "i am talking"
02:32:03 <ray> which differs from "i talk"
02:32:14 <ksf> "ich spreche gerade" / "ich bin am sprechen"
02:32:40 <ksf> that's "I speak currently" and / "I'm occupied with speaking"
02:32:55 <ray> yeah
02:33:36 <ksf> having a continuous present as a tense primitive isn't a usual feature of germanic langages.
02:34:11 <ksf> I think the second form is, or at least was, originally missingsch.
02:34:26 <ray> right i think that's what i'm getting at although grammar terms are not my thing
02:34:38 <ksf> considering that in nether german it's "Ik buen an't snacken"
02:35:31 <ksf> "I am at the (to talk)"
02:35:49 <ray> it's usually infinitives though
02:36:01 <ksf> to talk is the infinitive
02:38:15 * hackagebot syb-extras 0.1 - higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.1 (EdwardKmett)
02:38:45 <edwardk> because scrap your boilerplate wasn't complicated enough ;)
02:39:30 <ray> scrap your scrap your boilerplate boilerplate
02:40:34 <Twey> Haha
02:40:42 <ksf> ho, here: http://bugs.darcs.net/issue986
02:40:54 * quicksilver searches for the syb yo dawg joke
02:41:26 <edwardk> its mostly so i can do things like instance ( Typeable1 f, Typeable1 w, Data (w (a, f (StreamT f w a))), Data (a, f (StreamT f w a)), Data (f (StreamT f w a)), Data a) => Data (StreamT f w a) and turn it into instance (Data1 f, Data1 w) => Data1 (Stream f w)  and instance (Data1 f, Data1 w, Data a) => Data (Stream f w a)
02:41:40 <edwardk> letting me hide the implementation details of my data type
02:42:22 <edwardk> quicksilver: =)
02:43:15 <quicksilver> edwardk: but Data instances are twisted and evil!
02:43:53 <edwardk> meh
02:44:01 <edwardk> i happen to like providing them when they are possible
02:44:18 <edwardk> it annoys me when they are missing from common libraries, like transformers
02:44:29 <edwardk> (though in that case they are missing because those instances are hard as hell to write)
02:44:59 <edwardk> having just implemented them for my comonad transformers the other day i can attest to that!
02:49:11 <quicksilver> edwardk: well, Data is structural metaprogramming, and as such it's very useful when it's exactly what you need, but it can lead people down blind alleys and lure people into poor design.
02:49:25 <quicksilver> it breaks program rewriting and that shouldn't be done without considering the tradeoffs
02:49:57 <quicksilver> but I suspect you understood what I meant :P
02:50:08 <edwardk> sure. but you can define container-specific pseudo-constructors that permit data to work without breaking invariants
02:50:56 <edwardk> e.g. take Set and make a Data instance for it that claims to have one pseudo-constructor 'fromList' which takes a list, etc.
02:51:49 <edwardk> the biggest problem that i have with Data is that there are a lot of broken data instances out there because folks didn't spot the pseudo-constructor trick early on. i need to put in a libraries proposal to fix the ones in containers
02:54:50 <quicksilver> edwardk: I had a very frustrating conversation on a mailing list once where I tried to explain why the instance for 'Ratio' should *not* make the two Integers visible.
02:55:02 <c4v> com back
02:55:05 <quicksilver> edwardk: in the end, I gave up, as no one was taking my side.
02:55:12 <c4v> exit
02:55:17 <edwardk> *nods*
02:55:29 <edwardk> ratio should be opaque like that
02:55:43 <quicksilver> Complex too
02:55:51 <quicksilver> although that's slightly less black&white than Ratio
02:55:59 <edwardk> yeah
02:56:28 <quicksilver> it's partly I think because writing data instances is so *HARD* that only 3 people in the world know how to do it
02:56:40 <edwardk> in fairness though, letting the integer be visible isn't terrible. you really should only be using generic traversals to find types you defined anyways
02:56:47 <quicksilver> everyone else assumes that "deriving Data" is the only possibly instance and therefore the right one
02:56:51 <edwardk> hahaha
02:57:00 <qfr> http://siyobik.info/pastebin_download.php?id=560 <- hint says dependencies are missing, yet I see them all listed in ghc-pkg list and I don't see any conflicts in ghc -v - does anybody see what cabal is having problems with in this case?
02:57:18 <edwardk> yeah not many of us bother to provide them
02:58:08 <qfr> All the depencies appear to have been installed
02:58:13 <qfr> *dependencies, too
02:58:43 <Saizan> qfr: pass --user, perhaps?
02:59:06 <edwardk> right now i'm breaking my brain on defining newtype wrappers to lower Data1 instances to Data instances, so i can conceal more implementation details
02:59:22 <qfr> Saizan ohh of course
02:59:26 <qfr> I forgot about it again :[
02:59:45 <Saizan> why not "cabal install" directly?
03:00:27 <qfr> Saizan because the package is not on HackageDB
03:00:37 <qfr> It's a patch written by gienah
03:00:48 <qfr> Oh wait
03:00:53 <qfr> cabal install local right
03:01:05 <qfr> I totally forgot about that :/
03:01:26 <qfr> Somebody really needs to add happy as a dependency to haskell-src btw
03:01:33 <qfr> Should mail the maintainer when I get home
03:02:12 <Saizan> it probably already is as a build-tool
03:02:28 <Saizan> someone should fix cabal-install so that it installes build-tools automatically :)
03:03:04 <Saizan> mh, it isn't
03:04:44 <qfr> Is parallel compilation on the cabal roadmap btw?
03:07:23 <Saizan> on the wishing list at least
03:36:12 <qfr> Is there some Haskell file system function which deals with joining paths in the file system?
03:36:27 <companion_cube> :t </>
03:36:28 <lambdabot> parse error on input `</>'
03:36:32 <qfr> i.e. f "a" "b" returns either "a/b" or "a\\b"
03:36:33 <companion_cube> :t (</>)
03:36:34 <lambdabot> Not in scope: `</>'
03:36:38 <qfr> Depending on the operating system
03:37:49 <edwardk> is there a leibnizian equality package on hackage?
03:38:02 <companion_cube> maybe System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath (but since it is in Posix, windows may not work)
03:38:03 <qfr> http://haskell.org/ghc/docs/7.0.1/html/libraries/filepath-1.2.0.0/System-FilePath-Posix.html
03:38:17 <qfr> companion_cube yeah I was just wondering about that..
03:38:33 <qfr> It does mention Windows though
03:38:37 <qfr> So I think it is supported
03:39:10 <qfr> Oh wait, that particular function does not mention Windows :[
03:39:59 <quicksilver> qfr: </> is exported by System.FilePath.Windows too, AIUI
03:40:19 <quicksilver> qfr: but the modules are conditional compilation, so the copy on haskell.org only shows the Posix module, because haskell.org is a posix machine.
03:40:29 <qfr> http://haskell.org/ghc/docs/7.0.1/html/libraries/filepath-1.2.0.0/System-FilePath-Windows.html hm
03:40:41 <quicksilver> "Both System.FilePath.Posix and System.FilePath.Windows provide the same interface. See either for examples and a list of the available functions."
03:41:03 <qfr> So should I just import the Posix one then?
03:41:18 <quicksilver> no
03:41:21 <quicksilver> import System.FilePath.
03:41:28 <quicksilver> that's the point
03:41:39 <qfr> Oh, right
03:42:26 <qfr> quicksilver what does </> mean btw? Is that an infix operator?
03:42:40 <Zao> qfr: It's "glue a component onto this path".
03:42:42 <qfr> "a" </> "b" or something like that, if you perform a non qualified import?
03:43:03 <Zao> For glorious platform independence.
03:43:11 <companion_cube> it's infix, yeah, "a" </> "b" works
03:43:21 <qfr> (</>) :: FilePath -> FilePath -> FilePath ahh
03:43:26 <qfr> I forgot about adding ()
03:43:31 <qfr> When I was :t'ing in ghci
03:45:41 <quicksilver> > "a" </> "b"
03:45:43 <lambdabot>   Not in scope: `</>'
03:45:45 <quicksilver> :(
03:47:23 <qfr> > System.FilePath.(</>) "a" "b"
03:47:24 <lambdabot>   Not in scope: data constructor `System.FilePath'Not in scope: `</>'
03:47:38 <qfr> > System.FilePath.</> "a" "b"
03:47:39 <lambdabot>   <no location info>: parse error on input `System.FilePath.</>'
03:47:46 <qfr> I have no idea :/
03:48:02 <qfr> How do you even use those with qualified imports?
03:48:06 <Bynbo7> > (System.FilePath.</>) "a" "b"
03:48:07 <lambdabot>   Not in scope: `System.FilePath.</>'
03:48:13 <qfr> Ah
03:48:27 <Bynbo7> that's how, it just can't use that one
03:51:49 <aleator> How do you type the (equivalent of) \x y -> runST (x >> y) ?
03:52:20 <Bynbo7> @pl  \x y -> runST (x >> y)
03:52:20 <lambdabot> (runST .) . (>>)
03:52:52 <aleator> Bynbo7: As in what hoop do I jump through to get it past typechecker.
03:52:54 <Saizan> aleator: (forall s. ST s a) -> (forall s. ST s b) -> b
03:53:07 <aleator> Saizan: Ah. Thanks!
03:53:23 <aleator> Saizan: I never really grokked either st or forall. 
03:53:24 <Bynbo7> oh right, missed the type in the question
03:54:13 <Saizan> foo :: (forall s. (ST s a , ST s b)) -> b; foo (x, y) = runST (x >> y)  -- might be more general
03:54:34 <aleator> Where do you learn stuff like this?
03:54:51 <aleator> Saizan: I don't think that compiles (I tried something quite similar and it didn't)
03:55:20 <Saizan> aleator: with the forall s. there?
03:55:50 <aleator> Saizan: Yeah.
03:56:47 <aleator> Saizan: Although, It might have been something else, I already edited that away.
03:56:57 <Saizan> foo :: (forall s. (ST s a, ST s b)) -> b
03:56:57 <Saizan> foo p = runST (case p of (x,y) -> x >> y)
03:57:25 <Saizan> you're right, you've to pattern much inside runST like that
03:58:48 <Saizan> aleator: it helps to learn about System F, and the game semantics of higher rank quantification
04:00:00 <Saizan> aleator: in haskell it's all a bit muddled by the fact that types are passed implicitly, which is very convenient most of the time but obscures the matters
04:00:58 <quicksilver> in particular it obscure "when" the type applying is happening
04:02:28 <aleator> Saizan: Thanks.
04:03:12 <opqdonut> explicit type passing would be nice
04:03:46 <opqdonut> I find myself using quite a lot of in-place type signatures, but maybe my code is just built wrong
04:03:56 <aleator> darn haskell. Been writing it for 5 years and it still befounds me at places
04:04:02 <opqdonut> I mean stuff like (f (g (h x) :: X))
04:04:32 <aleator> .. confounds (darn english..)
04:09:13 <edwardk> i have a small package of leibnizian equality operators, 'eq' or 'leibniz'? i like the former because its easy to remember and to spell, the latter invites typos
04:11:03 <quicksilver> 'eq' seems too short for a package name and sounds too generic.
04:11:15 <quicksilver> in my entirely subjective and non-normative opinion
04:11:22 <opqdonut> i agree with quicksilver
04:11:37 <edwardk> well, i got away with 'ad' ;)
04:12:10 <ksf> edwardk, what's leibniz-equality? equality that can only check for equality against 52?
04:12:29 <edwardk> data a := b = Refl { subst :: forall c. c a -> c b }
04:12:44 <quicksilver> edwardk: only because you didn't ask me :)
04:13:06 <edwardk> you can form a groupoid out of them, lift them, etc.
04:13:31 <edwardk> its a bit more principled than the GADT version of the same thing
04:14:12 <edwardk> a . b = subst a b
04:15:04 <lpsmith> Ok,  what does  it mean that haddock depends on "ghc"?
04:19:35 <lpsmith> ok, let me put it this way,  how do I compile my own haddock,  if I've already got the binary ghc installed from haskell.org/ghc
04:19:40 <lpsmith> ?
04:20:45 <Saizan> you don't already have an haddock? anyhow, it should be cabal install haddock, assuming the version on hackage works for your ghc
04:21:30 <Saizan> depending on "ghc" means that it uses the ghc-api library, which is in a package called ghc shipped with the ghc compiler itself
04:22:05 <lpsmith> well,  I would like Haddock 2.8.1 for my installation of ghc-6.12.3
04:22:16 <lpsmith> it shipped with Haddock 2.6.1
04:22:52 * hackagebot hlint 1.8.4 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.4 (NeilMitchell)
04:23:12 <lpsmith> err
04:23:33 <ManateeLazyCat> Saizan: Oh, i forgot, Manatee can running in XMonad now.
04:23:47 <lpsmith> well, simply typing "cabal install haddock-2.8.1" worked 
04:23:58 <ManateeLazyCat> What's your most want application for Android? I'm developing Android application. :)
04:24:14 <lpsmith> but it didn't put the haddock executable where I wanted it to go
04:26:16 <lpsmith> but when I tried to pass the --global --prefix=... options,  cabal install couldn't find the ghc package
04:28:08 <lpsmith> ok,  nevermind, the path pointed to a different version of ghc when I called "sudo cabal install --global --prefix=/usr/local/ghc/6.12.3/"
04:28:44 <Saizan> using sudo cabal tends to cause problems, --root-cmd=sudo makes more sense
04:29:14 <ManateeLazyCat> lpsmith: Don't use sudo with cabal.
04:34:30 * ManateeLazyCat Maybe someday, manatee-android will release. :)
04:35:22 <Bynbo7> how does that make any sense o.O
04:39:51 <ivanm> Bynbo7: if you just use sudo, then IIRC it will keep using your user-specific variables, configs, etc. but install to /
04:39:51 <ivanm> (I've had problems with the past just from doing "sudo su" to avoid having to provide the password rather than just doing "su")
04:40:23 <Bynbo7> i meant manatee on android
04:41:05 <ManateeLazyCat> Bynbo7: Not manatee on Android, is Manatee develop IDE for Android.
04:41:37 <ManateeLazyCat> Bynbo7: Manatee design for keyboard.... 
04:42:07 <Bynbo7> ah, ok
04:42:17 <Bynbo7> that makes much more sense ;)
04:42:29 <ManateeLazyCat> Less confuse, android IDE extension for Manatee. :)
04:43:38 <ManateeLazyCat> I don't like Eclipse make me like stupid, click here, click there ....
04:44:55 <ivanm> Bynbo7: oh, right
04:45:13 <ManateeLazyCat> ivanm: Manatee can running on XMOnad, maybe you can try. :)
04:45:25 <ManateeLazyCat> I know many haskeller are xmonad fans. :)
04:45:34 <ivanm> ManateeLazyCat: tbh, I don't think I'd like Manatee...
04:45:54 <ManateeLazyCat> Ok, nevermind . :)
04:51:18 <ManateeLazyCat> "Eclipse + ADT + Android emulator" will kill your box... 
04:51:55 <Botje> eclipse by itself will already do that
04:52:43 <Bynbo7> hmm, so i've just thought of a feature hackage should have. it should email the authors of packages that depend on packages that have been updated
04:53:09 <ManateeLazyCat> Botje: Yep, drop Eclipse
04:53:21 <ManateeLazyCat> Botje: Big and slow crap.
04:53:29 <Botje> ManateeLazyCat: yep.
04:53:41 <Botje> but it's still the least sucky way to write java
04:53:47 <Bynbo7> never had any problems with eclipse
04:53:49 <Botje> with a modicum of productivity
04:53:56 <Bynbo7> yeah
04:57:36 <quicksilver> "crap" is a simplification.
04:57:43 <quicksilver> eclipse is big, slow, and complex
04:57:50 <quicksilver> withing the complexity lurks some good stuff
04:57:53 <qfr> Java goodness
04:57:54 <quicksilver> and some bad UI decisions
04:57:59 <quicksilver> and lots more besides
04:58:11 <qfr> I write my Haskell in Eclipse
05:02:30 <Entroacceptor> ManateeLazyCat: manatee-core-0.0.8 requires mtl ==1.1.0.2 however mtl-1.1.0.2 was excluded because manatee-core-0.0.8 requires mtl ==2.0.1.0
05:05:16 <ManateeLazyCat> Entroacceptor: Let me check.
05:05:16 <Entroacceptor> (it's from -darcs)
05:05:16 <spetrea> good news, I'm here
05:05:16 <Entroacceptor> yay
05:05:16 <ManateeLazyCat> Entroacceptor: Darcs same as hackage now, i just release new version today. :)
05:05:16 <ManateeLazyCat> Entroacceptor: Fix XMonad problem
05:05:16 <spetrea> is it true that ghc is switching to git instead of darcs ?
05:05:16 <FauxFaux> I do hope so.
05:05:16 <quicksilver> it's true that GHC is considering it.
05:05:16 <quicksilver> you can read the discussion on g-h-u
05:05:16 <spetrea> quicksilver: g-h-u = ?
05:05:16 <Entroacceptor> ManateeLazyCat: yes, I read that, that's why I was trying to install it again ;)
05:05:34 <quicksilver> spetrea: glasgow-haskell-users
05:05:46 <ManateeLazyCat> Entroacceptor: I use mtl >= 1.1.0.2 in manatee-core.cabal
05:06:19 <ManateeLazyCat> Entroacceptor: Maybe you can unregister mtl-1.1.0.2
05:06:54 <Entroacceptor> that would break installed packages
05:06:55 <Entroacceptor> *sigh*
05:07:19 <ManateeLazyCat> Entroacceptor: Hmm, i use mtl-1.1.0.2 in my box, haven't upgrade
05:07:47 <ville> Been awhile since I've done some Haskell development and coming back to my old project I get: "xxx: Prelude.undefined". What would be causing that?
05:08:03 * hackagebot eq 0.1.0 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.1.0 (EdwardKmett)
05:08:13 <quicksilver> ville: you used the dreaded 'undefined' somewhere in your code.
05:08:17 <ville> hah! nevermind, asking in IRC has done it again.
05:08:30 <edwardk> (sorry quicksilver, you lost) =)
05:08:39 <ville> quicksilver: yeah I just stumbled upon it my self right after I asked.
05:09:09 <quicksilver> edwardk: how dare you defy my will!?!? the price you will pay will be far beyond your imaginings.
05:09:15 <edwardk> https://github.com/ekmett/eq/blob/master/Data/Eq/Type.hs
05:09:20 <opqdonut> edwardk: tsk tsk, no haddock
05:09:21 <edwardk> in case you don't want to wait for the haddock
05:09:24 <ManateeLazyCat> Entroacceptor: Maybe some depend package of Manatee use ==
05:09:27 <edwardk> opqdonut: takes 12 hours
05:09:28 <opqdonut> ah, it's still compiling
05:09:32 <opqdonut> my bad
05:09:56 <Entroacceptor> ManateeLazyCat: I'll try changing the cabal to use mtl>=2
05:09:58 <ManateeLazyCat> Entroacceptor: I never use == in manatee's cabal file.
05:10:14 <edwardk> the injectivity code is a generalization of a trick by oleg, which requires vastly less boilerplate than his approach
05:10:19 <edwardk> i should probably blog it
05:10:27 <ManateeLazyCat> Entroacceptor: Which version your dbus-core dbus-client package?
05:10:48 <ManateeLazyCat> Entroacceptor: I got same weird depend problem that cause by older dbus-* packages.
05:11:20 <Entroacceptor> ManateeLazyCat: client-0.3 core-0.8.5.3
05:11:41 <edwardk> its weird writing a module you can lead into with import Prelude ()
05:12:07 <ManateeLazyCat> Entroacceptor: Which GHC?
05:12:18 <Entroacceptor> 6.12.3
05:12:27 <ManateeLazyCat> Entroacceptor: Weird...
05:12:40 <ManateeLazyCat> Entroacceptor: I have same environment except i use mtl-1.1.0.2
05:12:44 <Entroacceptor> my cabal always messes itself up
05:13:08 <ManateeLazyCat> Entroacceptor: Maybe you install too many packages that conflict each other? ;p
05:13:30 <Entroacceptor> well
05:13:37 <Entroacceptor> how do I stop that?
05:13:52 <Entroacceptor> wtf
05:13:56 <ManateeLazyCat> Entroacceptor: Have you do "cabal upgrade" ? I doubt
05:14:06 <Entroacceptor> cabal: dependencies conflict: manatee-core-0.0.8 requires mtl ==1.1.0.2 however mtl-1.1.0.2 was excluded because manatee-core-0.0.8 requires mtl ==2.0.1.0
05:15:00 <Entroacceptor> no, haven't done that since I last removed .ghc
05:15:11 <ManateeLazyCat> Entroacceptor: One possible, some Manatee depend package use mtl-1.* some depend use mtl-2.* , then manatee-core failed.
05:15:51 <Entroacceptor> .oO{ "cabal install" should be called "cabal messup" }
05:16:44 <ManateeLazyCat> Entroacceptor: cabal is good enough sometimes. 
05:16:50 <ManateeLazyCat> s/is/is not
05:17:47 <ManateeLazyCat> Entroacceptor: Maybe "ghc-pkg check" will give you clue.
05:18:02 <Entroacceptor> no
05:19:21 <ManateeLazyCat> Entroacceptor: My suggestion, unregistered mtl-1.* or mtl-2.* forcely, let other package break, then re-install those break packages.
05:19:32 <ManateeLazyCat> Entroacceptor: If just have *one* version mtl, problem should be fix.
05:20:19 <Entroacceptor> maybe I should uninstall ghc from the system
05:21:00 <ManateeLazyCat> Entroacceptor: That's not necessary
05:22:03 <Entroacceptor> well, nearly all of the packages get pulled in by cabal in a new version anyway
05:22:29 <rkrzr> join #django
05:22:41 <Entroacceptor> mh
05:22:58 <Entroacceptor> can't someone make sure that everything on hackage can build at the same time?
05:23:06 * hackagebot eq 0.1.1 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.1.1 (EdwardKmett)
05:23:17 <edwardk> added some haddocks
05:24:03 <ManateeLazyCat> Entroacceptor: Well, then unregistered mtl-1.*
05:24:24 <ManateeLazyCat> Entroacceptor: You can fix problem by re-install
05:24:31 <ManateeLazyCat> break package
05:25:23 <ManateeLazyCat> IMO, don't upgrade package if don't need do that.
05:25:39 <Entroacceptor> I can't unregister packages installed by pacman
05:25:52 <edwardk> now i can pop the stack of subprojects 5-6 levels and get back to the thing that i WANTED to write
05:26:03 <Entroacceptor> I only upgrade xmonad-darcs and happstack with some addons
05:26:10 <Entroacceptor> cabal does the rest
05:26:20 <ManateeLazyCat> Entroacceptor: ghc-pkg unregister mtl-1.1.0.2 
05:26:44 <Entroacceptor> ghc-pkg: /usr/lib/ghc-6.12.3/package.conf.d/mtl-1.1.0.2-336254fecf8a77054f76cb33671a5177.conf: removeLink: permission denied (Permission denied)
05:26:58 <ManateeLazyCat> Then add sudo
05:27:32 <Entroacceptor> let's see what else breaks
05:29:48 <JackieOh> http://heroesofnewerth.com/ref.php?r=887ADUL4 Best PC Skill Game out, Constant updates!
05:30:16 <ivanm> thanks idoru 
05:30:29 <ivanm> oh, it's a bot
05:41:28 <ManateeLazyCat> Daemn Android phone have 1GHz CPU and at least 512 MB, much faster than my old computer.
05:42:43 <Entroacceptor> haha
05:43:34 <ManateeLazyCat> Entroacceptor: Ok now?
05:44:44 <Entroacceptor> it's still compiling something
05:46:22 <ManateeLazyCat> Entroacceptor: I will waiting your result, then offline to hacking Android. :)
06:01:10 <ManateeLazyCat> Entroacceptor: You can copy manatee-reader/Config/Reader.hs to directory ~/.manatee/config/  , then you can customize your own news feed.
06:01:51 <ManateeLazyCat> Entroacceptor: After you finish customize, then do "cabal install manatee-reader" to build new version manatee-reader with your own configure file. :)
06:02:14 <Entroacceptor> that's a weird way to do that :)
06:02:30 <Entroacceptor> have you considered using that library xmonad and yi use?
06:02:42 <Entroacceptor> (or one that works like what they did)
06:02:56 <ManateeLazyCat> Entroacceptor: You can modified ~/.manatee/Config/Reader.hs and press C-u in reader extension to update configure file in runtime.
06:03:29 <Entroacceptor> ah
06:03:36 <ManateeLazyCat> Entroacceptor: But GHC have memory problem if use hot-swap feature (C-u), so best re-install it with configure file, save memory usage.
06:04:07 <ManateeLazyCat> If someday GHC haven't memory problem, we can use hot-swap (C-u) everywhere and don't need re-install.
06:05:09 <ManateeLazyCat> Entroacceptor: Look http://www.flickr.com/photos/48809572@N02/5304662424/lightbox/ for my hot-swap framework use in Manatee.
06:05:23 <ManateeLazyCat> You can update configue code in runtime, like elisp for Emacs.
06:06:28 <ManateeLazyCat> But you know, memory will increase every time you do dynamic-loading, so i recommend use C-u as developer mode to adjust Manatee code in runtime, after adjust finish press C-i re-build new binary file with new config. 
06:06:44 <Entroacceptor> ok
06:07:07 <ManateeLazyCat> Entroacceptor: My solution don't need restart like XMonad, so it's won't lose state when you update config.
06:07:42 <ManateeLazyCat> Entroacceptor: Enjoy F3, i use it everyday. :)
06:08:14 <ManateeLazyCat> Entroacceptor: Maybe you can try F6 after install manatee-ircclient. :)
06:08:31 <ManateeLazyCat> So Manatee can works in your XMOnad ?
06:09:11 <merijn> I don't suppose someone wrote a Haskell to Java compiler? :>
06:09:26 <j-invariant> The lazy cat jumped over the manatee http://icanhascheezburger.files.wordpress.com/2009/09/funny-pictures-lazy-cat-is-hungry.jpg
06:09:59 <Entroacceptor> ManateeLazyCat: as I haven't had any plugins yet, I'm not sure 
06:11:14 <ManateeLazyCat> Have you re-install manatee-reader after change ~/.manatee/config/Reader.hs ?
06:11:48 <Entroacceptor> as cabal install manatee didn't install the reader, I'm installing the plugins now
06:12:44 <ManateeLazyCat> Entroacceptor: manatee-core is core protocol and basic toolkit, manatee-anything is for input/search interface, manatee is daemon process and WM feature, other package is extension.
06:13:04 <ManateeLazyCat> Entroacceptor: All package depend on manatee-core, but those package don't need depend each other for framework design
06:13:29 <ManateeLazyCat> Entroacceptor: So you need install extension for some feature.
06:14:33 <ManateeLazyCat> Entroacceptor: Install all manatee need long time, (10 minutes, at least)
06:14:49 <Entroacceptor> should be done soon
06:14:55 <ManateeLazyCat> Entroacceptor: If you use gold-linker, you can install manatee in 6~7 minutes.
06:15:06 <ManateeLazyCat> Entroacceptor: gold-linker is much faster than defaul linker.
06:15:27 <Bynbo7> shame it only works for ELF
06:19:15 <Entroacceptor> ManateeLazyCat: doc comment parse failed:  Parse "irc:[//[user@][server[:port]][/]][#channel]".
06:19:24 <Entroacceptor> while making haddock for ircclient
06:19:54 <ManateeLazyCat> Entroacceptor: Don't use haddock now.
06:20:07 <ManateeLazyCat> Entroacceptor: I haven't format document for haddock.
06:22:30 <Entroacceptor> ok, it compiled :)
06:23:23 <ManateeLazyCat> Entroacceptor: gold-linker will accelerate installation, like i said at http://hackage.haskell.org/package/manatee :)
06:26:32 <ManateeLazyCat> Entroacceptor: If you interested "how to write your own application in Manatee framework", you can read source code of manatee-template (http://hackage.haskell.org/package/manatee-template) Just 200 lines, very easy to understand. :)
06:27:15 <ManateeLazyCat> Also http://haskell.org/haskellwiki/Manatee#How_to_write_Manatee_extension
06:29:42 <Entroacceptor> manateeUser: test :)
06:29:42 <ManateeLazyCat> My English is bad, any English improve http://haskell.org/haskellwiki/Manatee are welcome! :)
06:29:59 <ManateeLazyCat> Entroacceptor: Split with Alt + t
06:30:11 <ManateeLazyCat> manateeUser: Talk something. :)
06:30:27 <Bynbo7> "work efficient like Emacs" ha
06:30:31 <Entroacceptor> whoops
06:31:38 <ManateeLazyCat> Entroacceptor: When you busy on other thing, irc client will popup tooltip notice you when someone call you name. :)
06:31:52 <Entroacceptor> can't send
06:32:06 <ManateeLazyCat> Entroacceptor: Press Alt + m send
06:32:18 <Entroacceptor> nope
06:32:49 <Entroacceptor> F3 should open a new tab with the feed reader, correct?
06:32:54 <Entroacceptor> doesn't happen
06:32:54 <Bynbo7> o.O
06:32:55 <ManateeLazyCat> Yes.
06:33:13 <ManateeAuthor> Entroacceptor: Say hello from Manatee IRC clinet.
06:33:15 <Bynbo7> ... can't you just hit enter to send, like any normal irc client?
06:33:22 <poucet> ManateeAuthor: what is this manatee for?
06:33:26 <ManateeLazyCat> Bynbo7: yes, it can
06:33:50 <ManateeLazyCat> Bynbo7: Alt + m and return both can work
06:34:05 <Bynbo7> good
06:34:11 <Entroacceptor> F3 to open feed works if I click on the tab bar before
06:34:23 <Entroacceptor> but I can't privmsg from manatee
06:34:36 <ManateeLazyCat> Entroacceptor: Haven't time add privmsg feature. :)
06:34:42 <ManateeLazyCat> Entroacceptor: I need help
06:34:52 <Entroacceptor> ManateeLazyCat: talkign to a channel is PRIVMSG #haskell :stuff
06:34:55 <ManateeLazyCat> Entroacceptor: That's why i write docs and manatee-template.
06:34:57 <Entroacceptor> isn't it?
06:35:17 <ManateeLazyCat> Entroacceptor: I will build new tab for privmsg channel.
06:35:18 <Entroacceptor> anyway, Alt-m or Enter don't work
06:35:48 <Entroacceptor> ManateeLazyCat: what I mean is: the IRC command to send a message to a channel is called privmsg
06:35:51 <ManateeAuthor> Say hello again from Manatee IRC client.
06:36:22 <ManateeLazyCat> Entroacceptor: I know, privmsg feature is simple, i put there let other people hacking it.
06:36:46 <ManateeLazyCat> Entroacceptor: I will focus on core framework and IDE framework, and let other people have fun on those detail. :)
06:37:41 <ManateeLazyCat> Entroacceptor: I can not take all the fun things to do, right?
06:38:54 <ManateeLazyCat> poucet: Screenshot : http://goo.gl/MkVw
06:39:08 <Entroacceptor> ManateeLazyCat: the filemanager keys don't work,either
06:39:13 <ManateeLazyCat> poucet: Video : http://www.youtube.com/watch?v=weS6zys3U8k
06:39:29 <poucet> ManateeLazyCat: I don't quite understand it.  You seem to be reinventing xmonad, but forcing people to use your browser, your image viewer and your text-editor.  This is somewhat against the UNIX philosophy
06:39:34 <ManateeLazyCat> Entroacceptor: Weird, i test Manatee with XMonad today.
06:40:25 <ManateeLazyCat> poucet: http://haskell.org/haskellwiki/Manatee#NOTE
06:41:03 <EvanR-work> poucet: yes its definitely not the unix philosophy ;)
06:41:18 <EvanR-work> unless you take manatee to be unix
06:41:23 <merijn> poucet: He seems to be constructing his own OS which probably the UNIX philosophy can go bugger itself?
06:41:23 <ManateeLazyCat> poucet: If XMonad can do, i won't write Manatee, please understand "split unlimited window for *same* application" before say it'same as Manatee. 
06:41:24 <poucet> ManateeLazyCat: Yes, basically xmonad with viewing same window in multiple panes, but then forcing a specific browser/editor/image viewer on the user.  
06:41:27 <Entroacceptor> I think more of it as an emacs clone
06:41:38 <ManateeLazyCat> poucet: It's not forcely.
06:41:40 <poucet> So I should compare this with for instance BEOS?
06:41:46 <ManateeLazyCat> poucet: You still can you use your own browser.
06:41:50 <merijn> Entroacceptor: emacs clone/new OS, what's the difference?
06:41:59 <poucet> hmm
06:41:59 <poucet> ok
06:42:05 <ManateeLazyCat> poucet: Those extension just demo to show Manatee framework
06:42:19 <poucet> ok
06:42:27 <ManateeLazyCat> poucet: If you use manatee extension, you can get *integrated* feature with other extension.
06:42:32 <EvanR-work> can it go full screen or act without a window manger
06:42:35 <Entroacceptor> if X integration would be better, stuff like this wouldn't be neccessary
06:42:47 <ManateeLazyCat> poucet: But it's okay if you still want use other software, it's your freedom
06:43:02 <poucet> Just trying to understand how it differs, I guess oyu need to clarify that more in your wikipage
06:43:22 <ManateeLazyCat> poucet: I do, http://haskell.org/haskellwiki/Manatee#NOTE
06:44:20 <ManateeLazyCat> All those extension just demo, i believe other people can write better application than me. :)
06:44:40 <ManateeLazyCat> And all those demo is for test core framework....
06:44:46 <poucet> ManateeLazyCat: I guess the NOTE doesn't quite clarify it for me.  But maybe I am obtuse
06:45:20 <waterlaz|work> is something fundamentaly wrong with this?
06:45:27 <waterlaz|work> setArray arr v = do
06:45:27 <waterlaz|work>     bds <- getBounds arr
06:45:27 <waterlaz|work>     forM_ (range bds) $ \idx -> writeArray arr idx v
06:45:35 <ManateeLazyCat> Please post code.
06:45:36 <waterlaz|work> aside from being rather ugly?
06:45:50 <waterlaz|work> I use it with an unboxed array
06:45:53 <waterlaz|work> of doubles
06:46:12 <ManateeLazyCat> poucet: Perhaps my English is not good enough that confuse you.
06:46:20 <waterlaz|work> and the profiler asures me that it allocates lots of memory
06:47:54 <ManateeLazyCat> I'm human, not superman, so i need you guys' help.
06:50:21 <ski> waterlaz|work : i'd generalize it by replacing `writeArray arr idx v' to `writeArray arr idx (v idx)' (and probably renaming `v' to `f', then)
06:50:42 <ManateeLazyCat> poucet: I can consider Manatee like this: Manatee don't follow unix philosophy, it's a new style UNIX itself. :)
06:51:07 <ski> that way you can set each element to something depending on its index, instead of just being able to get an array with all elements initialized to the same value
06:51:50 <waterlaz|work> ski, I know, that's good
06:52:00 <ski> (i don't know whether you would have use for this extra generality for what you're doing, but i think it's sensible to have this generalization)
06:52:09 <waterlaz|work> but my problem is that it performs badly
06:54:58 <poucet> ManateeLazyCat: Alright
06:55:38 <ski> @hoogle mapArray
06:55:38 <lambdabot> Data.Array.MArray mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
06:55:43 <ski> @hoogle apArray
06:55:44 <lambdabot> Data.Array.MArray mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
06:55:46 <ski> @hoogle appArray
06:55:47 <lambdabot> No results found
06:55:50 <ski> @hoogle iterArray
06:55:50 <lambdabot> No results found
06:55:52 <ski> hm
06:56:12 <waterlaz|work> ski the profiler tells me that the function allocates lots of memory
06:56:17 <waterlaz|work> so I am confused
06:56:20 <waterlaz|work> it shouldn't
06:56:35 <ManateeLazyCat> poucet: If you consider Manatee is normal application, it's design is weird, if you consider it is self-contain system, it's natural, as i explain: I won't write Manatee if any software can do work of Manatee. :)
06:56:47 * ski was looking for `(MArray a e m,Ix i) => (e -> e) -> (a i e -> m ())'
06:57:02 <jonkri> what is the most convenient way to install a package such as http://hackage.haskell.org/package/storable-tuple?
06:57:03 <poucet> ManateeLazyCat: I guess I am having a hard time differentiating this from a WM
06:57:14 <ManateeLazyCat> poucet: Do you know Emacs?
06:57:15 <jonkri> on gnu/linux
06:57:18 <poucet> ManateeLazyCat: yep
06:57:30 <Entroacceptor> poucet: do you know emacs?
06:57:35 <ManateeLazyCat> poucet: Emacs can split *current* buffer with two window, XMonad can't, 
06:57:47 <ski> waterlaz|work : yeah .. that sounds strange to me, as well
06:57:59 <poucet> ManateeLazyCat: Ok, aside from that one minor functionality.  How is Manatee not a WM?
06:57:59 <Entroacceptor> ManateeLazyCat: but it would be possible to replace the WM part of manatee with something else, right?
06:58:07 <ManateeLazyCat> poucet: XMonad just put different application in different windows, but it can't split *one* application's different view in different windows.
06:58:22 <poucet> ManateeLazyCat: You're still talking about 'windows', so a window manager
06:58:24 <waterlaz|work> maybe I just don't understand the profiler output
06:58:35 <j-invariant> what shnuold you do once you've learned haskell?
06:58:43 <ManateeLazyCat> poucet: It's framework to provide *integrated* features.
06:58:49 <poucet> Anyways, maybe I should come talk on #manatee, since this is very OT
06:58:51 <merijn> j-invariant: Start coding? :p
06:58:55 <ManateeLazyCat> poucet: Of course, it's include WM feature, but it's not.
06:59:01 <ManateeLazyCat> poucet: ##manatee
06:59:08 <merijn> j-invariant: Or blow your brain even more with stuff like Coq/Agda/Epigram/whatnot
06:59:28 <j-invariant> I found Coq and Agda very limiting
06:59:36 <ski> j-invariant : learn logic programming (and constraint logic programming), if you haven't looked into that yet
06:59:58 <merijn> j-invariant: For actual practical things, yes
07:00:03 <j-invariant> I have some logic programming but I guess Idon't really know about constraint programming
07:00:33 * hackagebot syb-extras 0.2.0 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.0 (EdwardKmett)
07:00:49 <Jafet> j-invariant: try C
07:01:33 * hackagebot eq 0.1.2 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.1.2 (EdwardKmett)
07:02:29 <ski> hm .. it appears to me Monsquaz is some fork of lambdabot
07:02:54 <ski> i still don't know why it PRIVMSGed me, though
07:02:57 <poucet> ski: Monsquaz is pissing me off.  He is claiming I IM'd him to begin with
07:03:08 <poucet> ski: Then when I ask him why he sent me a message blocking me, he said I talked to him first
07:03:12 <ski> (try sending `?' or `@version' to Monsquaz privately)
07:03:15 <poucet> ski: and then he uses this log as proofhttp://gyazo.com/9dd93b72230923b5d2f83bf98e60e813.png
07:03:16 <j-invariant> poucet: they may not be aware that their IRC client is PMing people
07:03:31 <poucet> ski: according to him, I am talking as Monsquaz, and he is sean
07:03:46 <poucet> ski: And then he tells me I should never have im'd him with the 'ne2k' which I never did
07:04:01 <poucet> Sounds like a broken proxy
07:04:17 <ski> poucet : if you try those commands, you'll (probably) see that the responses are very like lambdabot's
07:04:42 <poucet> ski: Right, but I also got a person talking to me as Monsquaz, telling me that I should not have im'd him with that 'ne2k'
07:05:01 <j-invariant> poucet: his client may also "receive" messages that are not really sent
07:05:08 <ski> (do you mean with the `ne2k' nick ?)
07:05:11 * poucet nods
07:05:20 <poucet> ski: I never typed 'ne2k'
07:05:46 * poucet put him on /ignore
07:06:23 <waterlaz|work> it may be just some kid
07:06:36 <ski> (poucet : i just wondered about "I should never have im'd him with the 'ne2k'" .. i was thinking you missed to type "nick" after that, but i'm not sure)
07:06:38 <j-invariant> waterlaz|work: I think it's a prank
07:06:51 <poucet> waterlaz|work: the screenshot is confusing tho, as the tailend of that conversation IS me talking to him but my messages show up as Monsquaz
07:06:54 <poucet> http://gyazo.com/9dd93b72230923b5d2f83bf98e60e813.png
07:06:59 <poucet> that is the screenshot he sent me
07:07:18 <j-invariant> poucet: in that case perhaps Monsquaz is a man in the middle
07:07:25 <poucet> Could be
07:07:28 <edwardk> yeah
07:07:39 <waterlaz|work> well... he PMed me too
07:07:43 --- mode: ChanServ set +o poucet
07:07:45 <Entroacceptor> pm'd me, too
07:07:52 <poucet> kick?
07:07:59 <mm_freak> i also got PM-ed by Monsquaz (or something like it at least)
07:08:01 <j-invariant> next time he PMs someone they could write a codeword
07:08:10 <j-invariant> Perhaps he will tell the codeword to someone else
07:08:11 <edwardk> it looks like Monsquanz is just sending any messages it gets to this guy
07:08:19 --- mode: poucet set +b *!*Fse@*.bredband.comhem.se
07:08:25 --- kick: Monsquaz was kicked by poucet (Monsquaz)
07:08:30 --- mode: poucet set -o poucet
07:09:02 <ski> yeah .. and to me it appears that Monsquaz is a modified lambdabot
07:09:08 <j-invariant> ski: how?
07:09:23 <poucet> j-invariant: he accepts lambdabot commands
07:09:27 <poucet> according to ski
07:09:29 <j-invariant> no it doesn't
07:09:37 <ski> j-invariant : when i sent `?' and `@version' to it, it responded very similar to lambdabot
07:09:54 <merijn> Great
07:09:55 <poucet> edwardk, ski: Warranted kban?
07:09:58 <ski> (maybe it doesn't do this with all people PRIVMSGing it, i dunno)
07:09:58 <j-invariant> ski: I tried some things like that but it didn't work
07:09:59 <waterlaz|work> http://pastebin.com/DJaz3GcQ
07:10:01 <merijn> Now he's spamming me
07:10:08 <waterlaz|work> that's basicaly my logs
07:10:14 <edwardk> sounds like it
07:10:41 <waterlaz|work> when he replied "that's what you said" it reminded me of tha txkcd comics =)
07:10:44 <merijn> He's currently PMing me lambdabot commands >.>
07:10:47 <Entroacceptor> it told me "hello ManateeLazyCaT"
07:10:54 <poucet> Seems like a random PM redirector?
07:11:02 <quicksilver> mine from yesterday - http://pastebin.com/49wi4AXH
07:11:13 <waterlaz|work> http://xkcd.com/174/
07:11:24 <quicksilver> seemed to me like he was inadvertantly running a script which connected twice
07:11:34 <quicksilver> and he didn't realise some of his windows/tabs were from the other connection
07:11:34 <ski> merijn,j-invariant,edwardk : oh .. in that case it could have been Monsquaz relaying between me and lambdabot herself, i suppose
07:11:41 <ski> albeit ..
07:11:48 <j-invariant> ski: clever!
07:11:58 <j-invariant> merijn: http://i.imgur.com/NDSqx.png
07:11:59 <poucet> Ok,thanks for the evidence guys, seems that the kban was warranted
07:12:03 <ski> 15:54 <ski> @version
07:12:03 <ski> 15:54 <Monsquaz> Monsquaz 4.2.2.1
07:12:03 <ski> 15:54 <Monsquaz> darcs get http://code.haskell.org/Monsquaz
07:12:18 <merijn> j-invariant: I got all of those except the @localtime
07:12:19 <j-invariant> ski: that's funny, you communicated with the actual lambdabot: That must have been a rare occurence
07:12:24 <ManateeAuthor> Talk in Manatee, Emacs crash again.
07:12:25 <edwardk> yeah, if monsquaz is just some random proxy bot that perhaps sets up connections between two random people on irc
07:12:34 <quicksilver> ski: did your conversation start wiht 'hi lambdabot'
07:12:35 <ski> so, if that was the case, it must have replaced `lambdabot' everywhere with `Monsquaz' (which makes sense, now that i think of it ..)
07:12:35 <quicksilver> ?
07:12:36 <kj789> hi! is there a tool for desugaring haskell source?
07:12:57 <quicksilver> it seems it starts with two his to different nicks
07:13:02 <quicksilver> maybe that's the two nicks bridged
07:13:12 <j-invariant> I wonder which other channels this bot was in
07:13:23 <ski> quicksilver : "Yo lambdabot","Hey there ski"
07:13:31 <quicksilver> right, I'm sure that's it then.
07:13:38 <quicksilver> I was connected to someone called CodeNinja
07:13:44 <quicksilver> (if this assumption is correct)
07:14:33 <ManateeLazyCat> Entroacceptor: Still can't work?
07:14:47 <ManateeLazyCat> Entroacceptor: I have test Manatee with XMonad today, maybe your special XMonad config ?
07:14:51 <edwardk> yeah, its a rather cruel prank
07:15:09 <j-invariant> it's downright silly
07:15:16 <ManateeLazyCat> Entroacceptor: Maybe we can talk in ##manatee
07:15:23 <merijn> And rather poorly executed if it was this
07:15:30 <edwardk> it sits there and randomly dials up folks, and the guy who runs it gets a bunch of chatlogs of bemused and frustrated people to laugh at.
07:16:01 <Entroacceptor>  that's why I ignore pms of people I don'T know
07:16:32 <quicksilver> edwardk: judging by the examples pasted so far they're quite short and uninteresting actually
07:16:54 <edwardk> reminds me of a bot i had in the early 90s called 'doplgangr' on efnet which used to log conversation snippets, and drop them into a ruleset for use eliza-style when emulating a person
07:16:57 <kj789> (...i guess this isn't the time to ask...)
07:16:58 <luite> hmm, reminds me of a phone prank by some radio show
07:17:18 <quicksilver> kj789: sorry, your question was much more on-topic than the ramblings about the pm-bot
07:17:18 <edwardk> but at the time i was like 17 and thought it was cool.
07:17:39 <quicksilver> kj789: I dont' think there is any tool except GHC, which can be asked to dump various unfoldings of the input
07:17:48 <aristid> ooh, http://sebfisch.github.com/haskell-regexp/
07:18:01 <edwardk> kj789: desugaring all the way to core?
07:18:17 <merijn> edwardk: Core is just an implementation detail, no?
07:18:21 <qfr> What does <$> do? Does it even have anything to do with ($)?
07:18:21 <edwardk> yeah
07:18:22 <kj789> yeah, desugaring to kernel primitives
07:18:31 <edwardk> merijn: that was where i was going with that
07:18:36 <merijn> :t (<$>)
07:18:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:18:38 <edwardk> qfr: <$> is just fmap
07:18:47 <edwardk> its just nicer to use infix with <*>
07:18:49 <kj789> the only purpose, of course, is educational
07:18:51 <merijn> :t ($)
07:18:52 <lambdabot> forall a b. (a -> b) -> a -> b
07:19:22 <Kaidelong> aristid: really, really cool thing you found there
07:19:28 <edwardk> kj789: then you're pretty much stuck with using ghc with -fext-core
07:19:31 <merijn> qfr: Type signatures imply they are related as you can see.
07:19:43 * qfr looks up Functor
07:19:48 <edwardk> kj789: there is no 'standard' set of core primitives for haskell
07:19:50 <qfr> At least I have seen * -> * before
07:19:51 <aristid> Kaidelong: yes. in the paper, they use infinite regular expressions and such crazy stuff
07:19:57 <kj789> edwardk, thanks, i'll look into that
07:19:59 <qfr> That means f is of an unary kind?
07:20:10 <qfr> Like... Maybe?
07:20:12 <edwardk> qfr: yeah f takes an argument
07:20:12 <kj789> what about the primitives defined in the report?
07:20:15 <merijn> qfr: Yes
07:20:27 <Saizan> kj789: --dump-ds
07:20:30 <edwardk> kj789: think of those as more suggestions than hard requirements =)
07:20:40 <Saizan> kj789: actually, -ddump-ds
07:21:02 <kj789> fine, but even desugaring down to these "suggested primitives" would be of interest
07:21:13 <kj789> Saizan, thanks
07:21:15 <Saizan> kj789: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/flag-reference.html <- search for desugarer here
07:21:17 <edwardk> Saizan: ah you're right
07:21:24 <merijn> qfr: Maybe is an instance of Functor (I'm bluffing, I'm pretty sure, but not 100%) so using <$> *could* be (a -> b) -> Maybe a -> Maybe b
07:21:36 <kj789> great, thank you all
07:21:50 <edwardk> merijn: it is
07:21:57 * qfr looks up Functor
07:22:01 <edwardk> > (+1) <$> Just 12
07:22:02 <merijn> qfr: The f could of course also be stuff like lists, trees, maps, whatever
07:22:03 <lambdabot>   Just 13
07:22:10 <edwardk> > (+1) <$> [1,2,3]
07:22:11 <lambdabot>   [2,3,4]
07:22:17 <merijn> @src Functor
07:22:18 <lambdabot> class  Functor f  where
07:22:18 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
07:22:29 <edwardk> > (+1) <$> Right 12
07:22:30 <lambdabot>   Right 13
07:22:35 <edwardk> > (+1) <$> Left 12
07:22:35 <lambdabot>   Left 12
07:22:41 <edwardk> note the last one ;)
07:23:01 <edwardk> > (+1) <$> (0,0)
07:23:02 <lambdabot>   (0,1)
07:23:16 <ManateeLazyCat> manateeUser: Hello. 
07:23:22 <manateeUser> hello
07:23:24 <ManateeLazyCat> manateeUser: Can you talk something?
07:23:34 <ManateeLazyCat> manateeUser: Great! ;p
07:23:40 <qfr> Wait, how do tuples relate to * -> *?
07:23:40 <edwardk> > ((+1) <$> (\x -> 12)) ()
07:23:41 <lambdabot>   13
07:23:42 <aristid> edwardk: wouldn't this be possible? (+1) <$> Flip (Left 12) == Flip (Left 13)
07:23:47 <manateeUser> yes, this works, from xephyr without xmonad
07:24:08 <edwardk> qfr: tuples have kind * -> * - > *  — when you partially apply them to one argument the result has kind * -> *
07:24:11 <edwardk> :k (,) Int
07:24:12 <lambdabot> * -> *
07:24:16 <ManateeLazyCat> manateeUser:  What's the xephyr ?
07:24:44 <manateeUser> manateelayzcat: it's an X server running as an X client
07:24:48 <qfr> Hm I've never seen that one before
07:24:58 <ManateeLazyCat> manateeUser: Oh, i see.
07:25:01 <edwardk> aristid: you'd need a functor instance for newtype Flip f a b = Flip (f b a)  — which would probably need to be based on a Bifunctor instance for f
07:25:21 <ManateeLazyCat> manateeUser: Maybe you can try F3. ;p
07:26:16 <aristid> edwardk: i was thinking about hard-coding the instances somehow, but yeah, that sounds better
07:26:39 <merijn> qfr: You know how the type of 'a' is Char? The type of Char is *
07:26:39 <ManateeLazyCat> Unfortunately, just one manateeUser can login, if have other people want try, please try F7 with argus (irc.freenode.net 6667 #haskell YourNick)
07:26:40 <qfr> foldl (,) 1 [2, 3] heh
07:26:41 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html — note i have a Flip in there ;)
07:26:42 <qfr> Infinite type
07:26:55 <qfr> merijn: Don't you mean the kind?
07:27:04 <qfr> The type of Char is Char, the kind of Char is *, no?
07:27:05 <Jafet> foldr (:::)
07:27:13 <merijn> qfr: That depends on your type theory
07:27:17 <qfr> :O
07:27:41 <merijn> qfr: But it is common to call them kinds, yeah
07:27:49 <edwardk> merijn: technically correct, but unhelpful ;)
07:27:59 <qfr> Jafet what is (:::)
07:28:08 <merijn> :t (:::)
07:28:10 <lambdabot> Not in scope: data constructor `:::'
07:28:26 <Jafet> HList constructor
07:28:52 <Jafet> Well, foldr (:::) isn't going to be typeable in haskell, I don't think
07:29:33 <merijn> qfr: The type of Char is obviously not Char. Because I cannot do "isAlphaNum Char" while I can do "isAlphaNum 'a'"
07:30:42 <edwardk> 'terms have types, types have kinds' — you can generalize this relationship to towers of universes, etc. with a number of mechanisms, the nicest is something called a 'pure type system'
07:31:19 <merijn> I prefer the just calling everything types like in ECC :p
07:31:33 <edwardk> in that case you typically change terminology and call the layers sorts
07:31:53 <edwardk> foo has sort bar tells you with level of the hierarchy it is in
07:32:01 <qfr> ECC = ?
07:32:11 <merijn> Extended Calculus of Constructions
07:32:28 <edwardk> zhaohui luo has a book on it
07:32:47 <j-invariant> how do you prove strong normalization of calculus of constructions?
07:32:49 <merijn> It extends the CoC by adding an infinite hierarchy of types where each level embeds all types of the lower level + the types of those types.
07:33:11 <merijn> j-invariant: You wait for someone smart to proof it in a paper then reference said paper :>
07:33:35 <edwardk> j-invariant: you rummage through the coq-in-coq implementation for the proof ;)
07:33:38 <qfr> <merijn> qfr: The type of Char is obviously not Char. Because I cannot do "isAlphaNum Char" while I can do "isAlphaNum 'a'"
07:33:41 <qfr> Oh, right, good point
07:33:49 <qfr> :t Char doesn't even work anyways
07:33:51 <lambdabot> Not in scope: data constructor `Char'
07:33:51 <lambdabot> Not in scope: `doesn't'
07:33:51 <lambdabot> Not in scope: `work'
07:33:52 <qfr> Just :k Char
07:34:02 <j-invariant> I am watching a video about termination proof
07:34:15 <j-invariant> this is for simpler ones than calculus of contsructions
07:35:31 <merijn> qfr: Yeah, but I think you can see how calling one thing a type and the other a kind is a largely artificial distinction
07:35:44 <j-invariant> merijn: it's not artifical
07:36:00 <qfr> merijn well in ghci I need to treat them very differently?
07:36:21 <merijn> qfr: Oh yes, in Haskell world they are very different
07:36:59 <merijn> j-invariant: Why not?
07:37:18 <edwardk> j-invariant, you can always go back tot he source: http://hal.inria.fr/docs/00/07/60/24/PDF/RR-0530.pdf
07:37:40 <j-invariant> thanks
07:37:44 <merijn> 1 :: Int, Int :: * <- why do I call the first a "type of" and the second "kind of" except some distinction someone once made?
07:38:29 <j-invariant> merijn: oh they are both "type of"
07:38:31 <edwardk> merijn: in haskell the two notions serve as different namespaces, and provide different binding constructs, those limitations give you inference, type classes and many good things
07:38:43 <j-invariant> but 1 is a different sort of thing than Int, and 1 and Int are different than *
07:38:49 <j-invariant> but Int, String, etc.. are all the same type ofthing
07:38:53 <merijn> edwardk: Agreed, but I thought we sorta drifted from pure Haskell
07:39:36 <j-invariant> 1 -> ... is not well formed, because 1 is a value
07:40:05 <merijn> If you haven't read it, I thought the Barendregt paper on the lambda cube was pretty enlightening about CoC too
07:40:09 <j-invariant> forall (x : T), forall (y : x), ... is not well formed because T is a tyep
07:40:11 <merijn> "Introduction to Generalized Type Systems"
07:40:34 <j-invariant> the seperation of levels is a real thing
07:41:56 <merijn> j-invariant: 1 -> ... is not well formed in Haskell and CoC, yes. But it can be well formed in some systems
07:42:54 <j-invariant> I don't think that can be in a PTS, can it?
07:43:00 <edwardk> meh, skip a level and say 'has sort' and its unambiguous. ;)    1 has sort *, 2 has sort #, Int has sort superkind/box, (->) has sort box, etc.
07:43:42 <dolio> Wait, what?
07:43:47 <edwardk> er 2#
07:44:23 <poucet> FYI, monsquaz has been kbanned on #jquery too
07:44:33 <merijn> j-invariant: PTS being?
07:44:33 <poucet> I talked to the guy who I had been forward chatting with
07:44:36 <edwardk> dolio: the classic sort relationships in a pure type system are taking about the argument and results of Pi, which is a level above the terms you are working with 
07:44:43 <edwardk> merijn: pure type system
07:44:53 <edwardk> the berendregdt cube, etc.
07:45:08 <edwardk> http://igitur-archive.library.uu.nl/math/2007-0403-200555/jeuring_01_puretypesystems.pdf
07:45:12 <alpounet> edwardk, you've been quite productive these last days
07:45:17 <edwardk> alpounet: i try
07:45:27 <merijn> j-invariant: Yeah, that takes us outside the lambdacube and into dependent typing
07:45:29 <dolio> Oh. Well, still, saying (->) has sort box is a little weird.
07:45:37 <j-invariant> lambda cube has dependent types
07:45:42 <ccasin> j-invariant: my favorite proof of SN for CC is "A short and flexible proof of strong normalization for the calculus of constructions" by Geuvers
07:45:44 <ccasin> you can get it online
07:45:53 <j-invariant> thanks ccasin 
07:45:56 <edwardk> dolio: i didnt say it wasn't weird, i said it was unambiguous ;)
07:45:57 <merijn> j-invariant: Oh wait, yeah
07:46:07 <merijn> j-invariant: Sorry I'm a bit out of it
07:46:34 <edwardk> alpounet: i'm always productive, its just a matter of whether or not i'm working on something you're interested in at the time =P
07:46:40 <dolio> I guess it's true if you view (->) : * -> * -> *
07:46:53 <alpounet> haha edwardk 
07:47:00 <alpounet> but you're a scala guy now 
07:47:01 <merijn> I only read enough about PTS/lambda cube to get up to speed on the other stuff I needed which is all based on ECC
07:47:03 <aristid> :k (->)
07:47:05 <lambdabot> ?? -> ? -> *
07:47:06 <dolio> And not as a special case of pi.
07:47:10 <edwardk> yeah
07:47:30 <ccasin> merijn: I think ECC is not a PTS, though, right?
07:47:43 <j-invariant> merijn: I always that a : b means that a has type b, whatever sorts of things they are. But it's also useful to know what sorts of things things are: for example it's only values that have anything to do with computation -- so you can erase all the types from a program and still run it
07:47:50 <ccasin> you can't capture the right cumulativity relationship inside the PTS framework
07:47:50 <merijn> ccasin: I think you're right, but I'm not sure :p
07:47:58 <edwardk> ccasin: most of it can be put in those terms, a PTS doesn't imply a lambda cube structure, merely a set of sorts
07:48:09 <dolio> ccasin: You can, but it becomes undecidable.
07:48:22 <edwardk> that part is correct
07:48:35 <ccasin> dolio: that's interesting, can you elaborate?
07:48:37 <merijn> j-invariant: You can always do that, hell that's what people do when they compile the code :p
07:49:23 <edwardk> j-invariant: you can only erase types in a calculus a la curry. in a calculus a la church that would be a big problem =)
07:49:34 <merijn> j-invariant: Actually, that's not true now I think about it
07:50:05 <merijn> j-invariant: Lambda cube has terms depending on types, doesn't it?
07:50:20 <j-invariant> merijn: yes
07:50:21 <edwardk> merijn: yes, half the cube
07:50:41 <merijn> Then you can't just throw away the types, right?
07:50:44 <Saizan> haskell has terms depending on types :)
07:50:51 <merijn> Of course it does
07:51:14 <edwardk> Saizan: yeah thats where i was going with it. =) haskell is a calculus a la church, not curry, which is what is amusing about it ;)
07:51:20 <Saizan> though, except typeclasses, the dependency is parametric, so you can erase them anyway
07:51:32 <edwardk> the types affect the meaning of the program. you can rewrite it into an erasable form, which is basically what is done by compiling down to core
07:52:17 <absentia> ha... I read that as ass-monkey.
07:52:20 <dolio> Where did I leave off?
07:52:55 <edwardk> dolio: dolio 10:48 ccasin: You can, but it becomes undecidable.  ccasin: dolio: that's interesting, can you elaborate?
07:53:02 <dolio> You just have to add a rule and axiom for every cumulativity inclusion.
07:53:04 <dolio> So, (Set0, Set1) (Set0, Set2) (Set0, Set3) ...
07:53:09 <dolio> But then, if you ask "what is the type of (forall (a : Set). a -> a)?" The answer is ambiguous. It could be Set1 or above (or Set or above if you're impredicative). So you have to search for a solution.
07:53:30 <edwardk> yeah, then type checking ceases to be syntactic
07:53:36 <ccasin> dolio: right, so we lose most general types, right?
07:53:42 <dolio> Yes.
07:53:56 <edwardk> there are plenty of non-injective pts's
07:54:12 <ccasin> yeah, but none I want to program in :)
07:54:17 <edwardk> =)
07:54:17 <ezyang> Does anyone know where the 'MVar' papers might be? 
07:54:27 <ezyang> or at least some canonical authority on what an MVar is? 
07:54:39 <dolio> You can't check types in isolation. You have to check it in context to find the 'right' type for a term based on where it's used.
07:55:20 <dolio> ECC's algorithm, by contrast, computes principal types.
07:56:43 <edwardk> i think we need to extend the 'recent additions' list on hackage, it scrolls off way too fast ;)
07:56:58 <edwardk> though, thats probably my fault as much as anything
07:57:11 <merijn> ezyang: I thought the accepted explanation was "magic"? :>
07:57:28 <ezyang> :< 
07:58:01 <ddarius> ezyang: The Awkward Squad paper has a good introduction and an operational semantics if I remember correctly, but it isn't "the authority."
07:58:19 <ezyang> that may be good enough. 
07:59:43 <ToRA> > succ undefined :: ()
07:59:44 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
08:00:15 <aristid> would you consider this code to be sufficiently readable? https://github.com/aristidb/aws/blob/master/Aws/Util.hs#L28 :)
08:03:15 <mm_freak> > succ ()
08:03:15 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
08:03:32 <mm_freak> > [() ..]
08:03:33 <lambdabot>   [()]
08:03:46 <aristid> > fromEnum ()
08:03:47 <lambdabot>   0
08:03:49 <ToRA> > [ undefined .. ] :: [()]
08:03:50 <lambdabot>   *Exception: Prelude.undefined
08:03:55 <aristid> > toEnum 1 :: ()
08:03:56 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
08:04:18 <aristid> > [ () .. ] :: [()]
08:04:20 <lambdabot>   [()]
08:04:24 <aristid> > [ (),() .. ] :: [()]
08:04:26 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
08:06:07 <jonkri> i'm thinking about adding ssl support to a haskell xmpp library. should i read the rfc and implement it from scratch or use some kind of tls library?
08:07:20 <ddarius> jonkri: Why would you implement it from scratch?  Not only does that seem like a big waste of time, but people don't like using untested security code.
08:07:24 <quuuux> jonkri: conventional wisdom is that you should never implement crypto yourself because it's so easy to get wrong
08:07:49 <jonkri> i'd be happy not to implement it :)
08:08:10 <jonkri> i googled "haskell tls" and came up a bit short
08:08:19 <ddarius> @hackage TLS
08:08:19 <lambdabot> http://hackage.haskell.org/package/TLS
08:08:33 <ddarius> @hackage HOpenSSL
08:08:34 <lambdabot> http://hackage.haskell.org/package/HOpenSSL
08:08:58 <aristid> HsOpenSSL i think
08:09:09 <aristid> http://hackage.haskell.org/package/HsOpenSSL-0.9
08:09:34 <aristid> there's also hopenssl or so, but that seemed in a worse state than HsOpenSSL
08:10:10 <crem> Trying to solve https://www.spoj.pl/problems/FCTRL/, but getting stack overflow. Anyone can help? Basicly i'm trying to get sum of map'ed list. Code is here: http://hpaste.org/42974/stack_overflow
08:10:27 <MHD0> How come the source code for Graphics.Rendering.OpenGL.GL.VertexSpec exports the class VertexComponent and all it's methods, vertex# and vertex#v (where # is 2, 3 or 4) but I can't include them?
08:11:05 <MHD0> Or wait, no it doesn't... Why?
08:11:05 <jonkri> so i could basically use hopenssl to encrypt messages and send them using tcp?
08:12:00 <jonkri> i want to implement "starttls" for xmpp clients
08:14:52 <aristid> jonkri: as an extension to the xmpp package?
08:15:14 <jonkri> aristid: i'm currently looking at haskell-xmpp
08:15:51 <crem> Could anyone help me (understanding and) overcoming stack overflow here: http://hpaste.org/42974/stack_overflow ? I've just started to write me first pieces of haskell code today.
08:16:33 <aristid> jonkri: is there more than one xmpp package?
08:17:07 <jonkri> aristid: three as far as i have found: http://hackage.haskell.org/package/XMPP http://haque.nfshost.com/haskell-xmpp/ http://john-millikin.com/software/network-protocol-xmpp/
08:17:22 <jonkri> the last one is gpl (!) so i wont use that one
08:17:54 <jonkri> looking at xmpp vs haskell-xmpp, haskell-xmpp appeared to be a bit more powerful, providing some sasl and concurrency features
08:18:14 <MHD0> Say you make a function (fun :: DataT -> Something) and a corresponding argument datatype (data DataT = DataT Foo Bar Qux), and the function takes the argument datatype as the only argument and uses the data feilds as arguments. Does GHC optimize "fun . DataT" so it does not require a data construction?
08:19:30 <Elko> hello
08:21:00 <Elko> iv got some questions concerning haskell code. can anyone help me?
08:21:27 <cdsmithus> Elko: Just ask
08:21:48 <aristid> jonkri: oh, the one by millikin is GPL? too bad :/
08:22:22 <aristid> i just checked whether enumerator is also GPL, and fortunately it is not. enumerator is MIT. phew :D
08:22:26 <quuuux> crem: sum uses foldl, which is non-strict and can build up large thunks, unfortunately
08:22:53 <jonkri> aristid: :)
08:23:13 <quuuux> crem: try using foldl' (+) 0 instead of sum and see if that still overflows the stack
08:24:05 <crem> quuuux, thanks. Trying it.
08:24:08 <quuuux> crem: also, factorOf5 isn't tail-recursive, which will also overflow the stack when passed a large enough argument, but (apparently) that's not the problem you're running in to
08:24:51 <aristid> quuuux: actually, sum uses no combinators at all, in GHC
08:24:59 <aristid> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sum
08:25:55 <quuuux> aristid: oh, right. Won't that definition still run in to the large thunk problem?
08:26:19 <Elko> i'm studying information system and we got some tasks to do with haskell. but i'm barely new to programming. we did some things with java and now doing some functional programming with haskell. i've got some code here http://hpaste.org/42975/loop_and_factorial which i have to describe after i've done some cmd line inputs
08:26:30 <aristid> quuuux: no idea :D
08:26:40 <Elko> but i don't no wath the code above does/declares
08:27:00 <tg_> can anyone here give me a carte blanche recommendation to use arch over ubuntu?
08:27:10 <ddarius> quuuux: Yes.  The Report essentially requires that behavior.
08:27:34 <ddarius> GHC will sometimes be able to tell that the operation is strict and optimize it essentially to the foldl' definition.
08:27:58 <ddarius> But sometimes it won't be able to tell and other times it simply isn't strict and thus such an optimization would be unsound.
08:28:06 <aristid> @where InterleaveT
08:28:07 <lambdabot> I know nothing about interleavet.
08:28:11 <crem> quuuux, it works, thanks. Is there an easy way to convert factorOf5 into tail recursion? I don't have 'functional eye' yet, so for me the conversion is not trivial here.
08:28:13 <MHD0> Elko: Ever heard of the constant function?
08:28:18 <sleepynate> ugh, the constant battle between aptitude and cabal :/
08:28:26 <MHD0> Elko: The "five" is basically that
08:29:05 <aristid> oh, there: http://hackage.haskell.org/package/interleave
08:29:10 <Elko> MDH0: So the "five" is just a variable name?
08:29:17 <aristid> that's InterleaveT from monad.reader 17 :)
08:29:24 <quuuux> crem: I'm not sure about an 'easy way', but working through the first chapters of SICP is great practice for that sort of transformation
08:29:33 <MHD0> Elko: Try opening a graph drawing utility and make it draw "y = f(x) = 5" as a graph
08:29:50 <MHD0> Elko: No, five is a function
08:30:03 <MHD0> Elko: No matter what argument it takes it returns five.
08:30:33 <tac-tics> @let fiveFn () = 5
08:30:34 <lambdabot>  Defined.
08:30:40 <tac-tics> @type fiveFn
08:30:41 <lambdabot> forall t. (Num t) => () -> t
08:30:54 <tac-tics> > fiveFn ()
08:30:56 <lambdabot>   5
08:31:00 <aristid> > fiveFn undefined
08:31:01 <Elko> MDH0: Graph drawn
08:31:02 <lambdabot>   *Exception: Prelude.undefined
08:31:16 <tac-tics> Aristid: beat me to it
08:31:18 <tac-tics> Oh
08:31:22 <MHD0> Elko: See how it's always five?
08:31:47 <MHD0> Elko: "five x = 5" in haskell means "f(x) = 5" in math
08:31:47 <tac-tics> @let fiveFn _ = 5 :: ()->Int 
08:31:49 <lambdabot>  <local>:12:0:
08:31:49 <lambdabot>      Warning: Pattern match(es) are overlapped
08:31:49 <lambdabot>               I...
08:32:01 <tac-tics> > fiveFn ()
08:32:03 <lambdabot>   5
08:32:05 <tac-tics> > fiveFn undefined
08:32:07 <lambdabot>   *Exception: Prelude.undefined
08:32:30 <MHD0> Elko: Now loop is a different matter
08:32:38 <tac-tics> @let fiveFn2 _ = 5 :: ()->Int 
08:32:39 <lambdabot>  Defined.
08:32:41 <tac-tics> > fiveFn2 undefined
08:32:43 <MHD0> Elko: Loop doesn't do anything useful.
08:32:43 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> GHC.Types.Int)
08:32:43 <lambdabot>    arising fr...
08:32:57 <tac-tics> > fiveFn2 undefined ::Int
08:32:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:32:59 <lambdabot>         against inferred type ...
08:33:04 <tac-tics> ;/
08:33:04 <Elko> MDH0: Just doing some loop with an argument
08:33:36 <sleepynate> folks, should i even bother with the haskell platform .debs? it always seems barely a month goes by before there's some bizarre inconsistency from some package cabal had to download
08:34:37 <Elko> MDH0: When i'm typing "five (loop 1)" what does it do?
08:34:51 <MHD0> Elko: Return 5
08:35:20 <MHD0> Elko: Since five doesn't really need it's argument it doesn't care what (loop 1) returns
08:35:48 <MHD0> Elko: But if you try to evaluate loop it would take an infinite amount of time.
08:36:04 <Elko> MDH0: Got it.
08:36:34 <MHD0> Elko: Made you sone bogus java code to better explain it: http://hpaste.org/42978/loop_and_factorial_annotation
08:38:53 <Elko> MDH0: Thanks! Little better to understand now. But... I've got one more question. What's about the inner and outer reducible expressions?
08:39:58 <Elko> MDH0: Do I have to care about those things? My prof told us about some behaviours of haskell
08:41:41 <Elko> MDH0: And how do I have to read "five :: a -> Int"?
08:42:15 <aristid> Elko: that means it can take ANY parameter type.
08:42:17 <jmcarthur> heh, i came in here reading "five" as "5" and thinking somebody was spreading false information
08:43:11 <jmcarthur> then again...
08:43:14 <jmcarthur> > 5 "foo"
08:43:15 <lambdabot>   5
08:43:34 <Elko> aristid: So, what does the "a" stand for? And is the "::" to read like the "=" in Java?
08:43:47 <jmcarthur> Elko: :: means "has type"
08:43:52 <jmcarthur> Elko: the "a" means "any type"
08:44:03 <ddarius> :t const (5 :: Int)
08:44:04 <lambdabot> forall b. b -> Int
08:44:28 <Elko> Thanks, jmcarthur!
08:44:36 <aristid> Elko: a is a type variable. that means it can be used with any type.
08:44:52 <Elko> Are there other variable types?
08:44:57 <monochrom> "f :: a->Int" is approximately "int f(<T>)"
08:46:28 <monochrom> the approximate ends when you find that "f _ = 6; haha = True; f :: a -> Int" is accepted.
08:46:46 <kmc> learning Haskell by analogy to C++ is not advised
08:47:06 <monochrom> except I used java
08:48:14 <jonkri> i don't see a way to implement a starttls xmpp session using the libraries you mentioned; tls is incomplete and has no support for fundamental things like client certificates, hopenssl is a minimal library which only generates digests and hsopenssl seems to assume an ssl connection and a "dedicated" socket. do you have any other suggestions? :)
08:48:31 <aristid> jonkri: use HsOpenSSL
08:50:42 <Elko> Well, folks! Thanks. (:
08:51:08 <aristid> jonkri: oh, i didn't read the last part of your sentence correctly
08:51:23 <jonkri> oh :(
08:51:41 <aristid> jonkri: maybe you should extend HsOpenSSL?
08:51:59 <aristid> jonkri: it's probably just a few additional FFI calls?
08:52:55 <jonkri> aristid: i don't even know what that is :P
08:53:09 <aristid> jonkri: FFI = interface to C
08:53:27 <jonkri> aristid: how long would you estimate it would take for someone like you to do it, having limited knowledge about ssl and openssh?
08:53:48 <jonkri> i'm pretty new to haskell...
08:54:23 <aristid> jonkri: no idea.
08:54:32 <ddarius> Probably less time than reimplementing SSL.
08:54:58 <monochrom> but you need a tutorial on FFI
08:55:17 <jonkri> ddarius: of course, but the alternative for me is not doing it (ssl and/or haskell) at all
08:55:31 <aristid> does yesod have an irc channel?
08:55:56 <aristid> jonkri: maybe you should do something easier first?
08:57:14 <jonkri> yeah, perhaps. even openssl is new to me :P
08:57:45 <aristid> jonkri: openssl has an atrocious API, or at least the documentation of it is
08:58:48 <jonkri> gosh
08:58:54 <jonkri> well, thanks all :)
08:59:45 <aristid> jonkri: maybe gnutls would be an alternative tho :)
08:59:55 <kj789> another noob q: how does one define a function f such that f n = [n] if x is a positive integer and [] otherwise?  (if it helps, n can be restricted to a Num type)
09:00:24 <jonkri> aristid: hmm... but then i guess i would have to re-invent the rest of the stuff that hsopenssh is doing
09:00:25 <ddarius> guard . (>0)
09:00:37 <copumpkin> f x | signum x == 1 = [x] | otherwise = []
09:00:45 <tac-tics> @type guard
09:00:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:00:47 <copumpkin> that doesn't require an Ord
09:00:54 <ddarius> Freakin' guard returning ()
09:00:56 <kj789> copumpkin, thanks!
09:01:07 <ddarius> @pl \x guard (x > 0) >> return x
09:01:07 <lambdabot> (line 1, column 13):
09:01:07 <lambdabot> unexpected ">"
09:01:07 <lambdabot> expecting operator or ")"
09:01:10 <aristid> jonkri: there are two gnutls packages: http://haskell.org/hoogle/?hoogle=gnutls
09:01:19 <aristid> jonkri: check whether they do what you need :)
09:01:19 <ddarius> \x -> [x | x > 0]
09:01:46 <tac-tics> > guard false :: ([])
09:01:47 <lambdabot>   Not in scope: `false'
09:01:54 <tac-tics> > guard False :: ([])
09:01:56 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
09:02:13 <aristid> tac-tics: [()], not ([])
09:02:22 <tac-tics> > guard False :: [()]
09:02:24 <lambdabot>   []
09:02:32 <tac-tics> > guard True :: [()]
09:02:34 <lambdabot>   [()]
09:02:40 <ezyang> Oh! This is interesting reading. 
09:02:48 <kj789> uh-oh, signum (0.5) == 1 gives True, so that won't work...
09:02:48 <aristid> ezyang: what?
09:02:59 <ezyang> So originally we had I-structures, that only supported writes, and now we have M-structures, which support writes and reads. 
09:03:00 <copumpkin> kj789: is 0.5 not positive?
09:03:13 <ezyang> I chased down the prior work for MVars, thanks to the paper provided. 
09:03:20 <tac-tics> > (guard True :: [()]) >>= \x-> return x
09:03:22 <lambdabot>   [()]
09:03:35 <ezyang> I also dolefully note that this paper is only just barely older than I am. 
09:04:25 <ddarius> Instead of significantly older?
09:05:24 <ezyang> What does confluence mean in concurrent aps? 
09:06:02 <ddarius> Presumably starting from the same spot, you'll get to the same end regardless of interleaving choices.
09:06:48 <lunaris> tac-tics: Perhaps you need something like guardBy :: MonadPlus m => a -> (a -> Bool) -> m a?
09:06:56 <lunaris> tac-tics: I'm just thinking aloud
09:07:01 <kj789> i need positive *integer*
09:07:01 <jonkri> aristid: very interesting... thanks :D
09:07:12 <copumpkin> kj789: the type would restrict that...
09:07:21 <lunaris> tac-tics: But something like guardBy x p = if p x then return x else mzero?
09:07:36 <lunaris> tac-tics: (Neater with pattern matching but multi-line)
09:07:43 <kj789> so what i want to do is not possible?
09:08:02 <ezyang> This also means the M in MVar probably means Mutable. 
09:08:06 <lunaris> tac-tics: Also, perhaps having the predicate as the first argument would make it more general
09:08:19 <ddarius> ezyang: What did you think it meant?
09:08:20 <lunaris> tac-tics: Then guard could be guardBy id (I think, again out loud).
09:08:40 <aristid> :t let guardBy x p | p x = return x | otherwise = mzero in guardBy -- lunaris
09:08:41 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => a -> (a -> Bool) -> m a
09:08:44 <j-invariant> what's head expansion?
09:08:50 <aristid> lunaris: pattern matching IS possible
09:08:57 <EvilMachine> hello. trying to install Unixutils (1.35) gives me "Module `Control.Parallel.Strategies' does not export `rnf'". What does that mean? (GHC 6.12.3 here)
09:09:16 <copumpkin> kj789: no, it's very possible, and what I told you does it
09:09:18 <lunaris> aristid: Thanks, like I said just thinking out loud onto a single line :)
09:09:29 <aavogt> ezyang: the m might be Mutual
09:09:36 <gwern> EvilMachine: that is odd. maybe you should :browse Strategies and see what it does export
09:09:45 <aristid> lunaris: well, i mean it is possible on a single line...
09:09:53 <EvilMachine> gwern: I have no idea what you mean by "
09:09:58 <copumpkin> kj789: however, the type of what I gave you is more general than what you need. If you just use it on Integers, it'll work the way you expect. 
09:10:00 <aavogt> EvilMachine: there are different versions of  parallel
09:10:01 <EvilMachine> gwern: I have no idea what you mean by ":browse Strategies"
09:10:05 <ezyang> ddarius: I always thought there was some contention about the name, although I can't think of an alterate right now. I guess mutual is plausible. 
09:10:06 <gwern> EvilMachine: in ghci
09:10:27 <EvilMachine> gwern: hmm, didn't know that existed. thanks. :)
09:10:30 <aavogt> EvilMachine: make it take the older one with    --constraint="parallel < ???"   (assuming you're using parallel)
09:10:47 <aavogt> I dunno what numbers belong in ???
09:10:49 <kj789> copumpkin, i'm looking for a function that will accept any numeric type
09:10:58 <EvilMachine> aavogt: where do i use that --constraint in cabal?
09:11:23 <lunaris> aristid: Yea, I'm a total GHCi/lambdabot noob.
09:11:26 <copumpkin> kj789: then just write f x | x >= 1 && x == truncate x = [x] or something
09:11:26 <ezyang> I wonder what the I in I-structures stands for. Maybe Id. 
09:11:33 <aavogt> EvilMachine: err, I mean as a flag like     cabal install --constraint="x > 1.2.3" foo
09:11:37 <EvilMachine> aavogt: i think i'm able to find out what numbers belong in ???, thanks to gwern
09:11:38 <copumpkin> kj789: but working on "integers" in an IEEE float is a bad idea
09:11:44 <EvilMachine> aavogt: aah, ok.
09:11:51 <lunaris> ezyang: Immutable?
09:11:54 <EvilMachine> aavogt: thanks. that should help.
09:11:59 <EvilMachine> gwern: thanks to you too. :)
09:12:14 <aavogt> EvilMachine: it's a relatively simple change... so  Unixutils should probably be fixed
09:12:23 <kj789> copumpkin, thanks ++ !
09:12:31 <aavogt> @hackage NFData
09:12:31 <lambdabot> http://hackage.haskell.org/package/NFData
09:12:38 <aavogt> @hackage deepseq
09:12:38 <lambdabot> http://hackage.haskell.org/package/deepseq
09:13:01 <ezyang> oh, no, it means immutable. 
09:13:09 <aavogt> basically, it should use the rnf from that second package instead
09:13:18 <lunaris> ezyang: See the above :) M is surely mutable then.
09:13:46 <ezyang> yeah, seems so. 
09:14:08 <EvilMachine> aavogt: ok. i already have a bad feeling when using cabal install in Gentoo. because it's not emerge ;)
09:14:12 <ddarius> Kids these days know nothing about history.
09:14:16 <ezyang> :-) 
09:14:42 <copumpkin> whosestory?
09:15:01 <ezyang> Hmm, that's interesting. IVars can be referentially transparent, as long as you guarantee write-once in your code. 
09:15:08 <ezyang> "linear types to the rescue?" :^) 
09:15:20 <ddarius> ezyang: You don't need linear types.
09:15:34 <aavogt> EvilMachine: no idea what happens there. Just install it in your $HOME, which you can do with a little bootstrap.sh to run in the download of cabal-install
09:16:17 <EvilMachine> aavogt: it already installs in $HOME. which it what i meant. :)
09:16:20 <EvilMachine> aavogt: nevermind
09:16:57 <EvilMachine> there really should be a cabal-to-ebuild converter.
09:17:02 <ddarius> ezyang: Have you read CTM?
09:17:39 <ezyang> ddarius: No, I don't think so. 
09:17:46 <ddarius> Read it.
09:17:51 <ezyang> what does that acronym expand to? 
09:17:53 <aavogt> EvilMachine: there almost certainly is
09:18:06 <ddarius> Concepts, Techniques, and Models of Computer Programs 
09:18:11 <ddarius> or something like that
09:18:28 <EvilMachine> aavogt:  now if only i know where to find it. ;)
09:18:48 <aavogt> EvilMachine: there's a #gentoo-haskell I think
09:18:55 <ezyang> I need to build a library :-) 
09:21:09 * hackagebot ncurses 0.2 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2 (JohnMillikin)
09:23:03 <mtnviewmark> wow - ncurses.... ?
09:29:27 <hydo> What's the right way to provide an instance of Data for UTCTime?  I think I'm finding outdated info via google.
09:31:22 <monochrom> perhaps similar to providing an instance of Data for Int
09:33:10 <hydo> I am under the impression that I risk orphaned instance warnings if I do something like that.
09:33:44 <hydo> Well, actually, I suspect that there's some sort of flexible instance magic available to me, but I'm not quite sure how it works.
09:34:39 <qfr> @src return
09:34:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:34:58 <monochrom> return depends on type
09:41:52 <byorgey> hydo: there is already an instance of Data for UTCTime in the latest version of the time package.
09:45:19 <dolio> So, who's going to LOPSTR this year?
09:47:54 <j-invariant> soundr great
09:48:05 <dolio> Doesn't it?
09:48:21 <j-invariant> oh wait I am looking at the 2006 X)
09:48:25 <dolio> So many conferences forget that their acronyms can also be puns.
09:53:49 <hydo> byorgey: indeed there is!  Thanks for the pointer.
10:00:30 <aristid> byorgey: i wish there was an overview site for all monad.reader issues. i managed to scramble together all issues except 2-5 (which seemingly only exist in a wiki), but that was a lot of effort :)
10:01:10 <taotree> Is there a simple way to apply a patch to a package that I have installed via cabal?
10:02:18 <byorgey> taotree: sure, first 'cabal unpack foo' to get the source code, apply the patch, then run 'cabal install' from within the source directory
10:02:22 <jmcarthur> taotree: cabal unpack the package, cd into the directory, apply the patch, cabal install
10:05:40 <taotree> thank you!
10:13:47 <tolkad> is there a class that works for both mutable and immutable arrays?
10:14:29 <c_wraith> No...  the mutable operations are fundamentally tied to operation in a monad, where the immutable ones are not.
10:15:15 <tolkad> oh
10:15:19 <jmcarthur> well...
10:16:26 <c_wraith> I guess you could probably work around that with newer type system features.
10:16:38 <c_wraith> But the array apis are old
10:16:44 <jmcarthur> some of the immutable array functions use mutation under the hood. vector has a lot more of these than array does though, enough that there are fewer scenarios for which you really need mutable vectors anyway.
10:17:06 <jmcarthur> so i'd say that for many common use cases for mutable arrays, you can share the api with immutable arrays instead
10:17:27 <jmcarthur> it just requires a lot of fusion and stuff
10:18:14 <jmcarthur> but it's not exactly the same as what tolkad was asking
10:19:46 <byorgey> aristid: but there is!  http://themonadreader.wordpress.com/previous-issues/
10:20:01 <byorgey> aristid: I guess it doesn't have the last few issues, I need to add those
10:20:32 <sleepynate> so i'm getting http://hpaste.org/42981/error when trying to install the happstack tutorial
10:20:57 <sleepynate> what is a trhsx ?
10:21:06 <aristid> byorgey: yeah, that's where i got the older issues, but not the newer ones. and i first had to find this site :)
10:21:09 <taotree> so why does it seem to recompile all packages when I do a cabal install?
10:21:25 <byorgey> aristid: is there something in particular that would have made it easier to find?
10:21:57 <aristid> byorgey: i don't remember how i navigated the maze :)
10:22:38 <aristid> byorgey: you don't happen to know of PDF versions of issues 2-5? :)
10:22:50 <byorgey> no, I don't think they exist
10:22:57 <byorgey> those issues were actually published as a wiki
10:23:13 <byorgey> so there wouldn't be a PDF version unless someone has later gone to the trouble of making one
10:24:05 <j-invariant> I wanted to try out the proof of tait but syntax is evil!
10:24:32 <aristid> byorgey: yeah i see that you can read them on the wiki, but i like reading my monad.readers while sitting in the bed :D
10:26:39 <jmcarthur> every time i see an ebook reader i think it's a waste of money, but then later i have this directory full of PDFs the read through and i put it off because it sucks to read them on a computer
10:26:46 <jmcarthur> *to read through
10:27:11 <beastaugh> t
10:30:45 <aristid> jmcarthur: the problem is that the ebook readers are too small for pdfs.
10:31:02 <aristid> jmcarthur: i love my kindle, but i still print most papers.
10:31:26 <jmcarthur> not all of them are too small
10:32:18 <aristid> right, some are reasonably readable. i have done that. but still.
10:32:45 <aristid> people say that an iPad is awesome for pdfs. but i cannot yet justify spending that kind of money
10:33:04 <sleepynate> aristid: so it my kindle
10:33:08 <sleepynate> is*
10:33:27 <aristid> sleepynate: which version? do you have the dx?
10:33:37 <sleepynate> no, plain old white kindle2
10:33:57 <aristid> yesterday i thought i'd buy myself gödel escher bach for the kindle. but: not available. meh
10:34:09 <sleepynate> i know your pain :/
10:34:18 <jmcarthur> a dx would be nice
10:35:43 <sleepynate> honestly, i like that mine fits in my coat pocket
10:35:59 <sleepynate> a DX would not
10:36:12 <jmcarthur> mine wouldn't be as much for on-the-go reading
10:36:46 <monochrom> need bigger coat pocket
10:37:03 <aristid> jmcarthur: maybe you just need a really good laser printer and a stapler.
10:37:21 <jmcarthur> you just might turn me into a tree-murderer
10:37:59 <sleepynate> better yet, e-ink wall.
10:38:04 <jmcarthur> heck yes
10:38:09 <monochrom> you can go grow trees if you feel guilty
10:38:15 <luite> aristid: but you can probably get an unofficial version somewhere :p
10:38:19 <aristid> sleepynate: oh, and a microsoft surface for the haskell programming :P
10:38:25 <jmcarthur> ew no
10:38:28 <sleepynate> ewwww
10:38:45 <sleepynate> aristid: i'm that asshole who still has a blackberry because i loathe touch screens
10:39:02 <monochrom> @quote ray 1970s
10:39:02 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
10:39:19 <aristid> ray: so true.
10:39:35 <jmcarthur> i wish my code could at least have graphical documentation in it that is not merely ascii art
10:39:46 <luite> aristid: yeah I think the ipad is gread for pdf, but scanned books look a bit blurry, you have to process them to make them look good
10:39:49 <ddarius> jmcarthur: It's called HTML.
10:39:58 * sleepynate hides irssi
10:40:02 <jmcarthur> ddarius: i mean viewable in the editor
10:40:16 <jmcarthur> i suppose an editor could do that
10:40:22 <luite> aristid: unfortunately, this can only be done with adobe acrobat (the paid version, not the reader)
10:40:30 <monochrom> yeah first you have to leave behind "plain text editor"
10:40:38 <ddarius> jmcarthur: I can open HTML in Visual Studio.
10:40:57 <jmcarthur> ddarius: you can open an html *document*. i'm talking about comments *in* your code
10:41:11 <sleepynate> luite: or you can do a lot of reading and use the C toolkit :O
10:41:13 <aristid> monochrom: stop bitching and implement your vision! :P
10:41:26 <monochrom> heh
10:41:34 <luite> sleepynate: C toolkit for what?
10:41:41 <sleepynate> luite: pdfs
10:41:42 <monochrom> I think ddarius means html is rendered in visual studio
10:41:50 <jmcarthur> if that's the case, then cool
10:42:00 <ddarius> So that he can find out that noone, including himself, wants to use his vision.
10:42:21 <luite> sleepynate: oh I don't think there is one that can do this, unless it's by adobe, in which case it probably wouldn't be free either :)
10:42:27 <monochrom> eclipse renders html too
10:42:39 <aristid> jmcarthur: i want an editor that can render integrated graphviz graphs :)
10:42:40 <jmcarthur> graphical programming doesn't imply using your mouse to connect "nodes" like quartz composer or something
10:43:12 <jmcarthur> aristid: probably emacs can already do everything we've discussed
10:43:30 <aristid> jmcarthur: dunno, emacs + graphics is not a match made in heaven
10:43:39 <jmcarthur> but it at least works
10:43:58 <jmcarthur> people browse the web in emacs... they're crazy, IMO, but they manage to do it
10:43:59 <ddarius> jmcarthur: Indeed, there are plenty of ideas.  Google "source code in database" as well as intentional programming and subtext and SuperGlue and Citrus and on and on.
10:44:00 <luite> sleepynate: I'm using the ClearScan OCR feature, which converts bitmap (scanned) images into outline fonts. it really works wonders for readability and crispness on low resolution (ipad) screens
10:45:07 <sleepynate> ahh right.
10:45:12 --- mode: ChanServ set +o monochrom
10:45:41 --- mode: monochrom set +b *!*se@*.bredband.comhem.se
10:46:00 <jmcarthur> yay
10:46:15 <jmcarthur> i wasn't sure if he was being a bother to anybody but me
10:46:29 --- mode: monochrom set -bb *!*Fse@*.bredband.comhem.se *!~Zse@c83-254-66-66.bredband.comhem.se
10:46:32 <jmcarthur> i thought it was an honest mistake :P
10:46:34 <luite> he msged me a minute ago
10:46:37 --- mode: monochrom set -o monochrom
10:46:39 <sleepynate> luite: have you tried gocr or resseract?
10:46:49 <jmcarthur> he called me luite, so i wasn't sure if he just messaged the wrong person
10:47:35 <j-invariant> monochrom: your bot?
10:47:48 <j-invariant> nvm
10:47:52 <luite> oh that must've been quite an insult ;p
10:48:58 <luite> sleepynate: not recently, but as far as I know, all open source pdf ocr things keep the scanned image and just add hidden text
10:49:08 <jmcarthur> didn't look intended as insult
10:49:35 * hackagebot archlinux 0.3.6 - Support for working with Arch Linux packages.  http://hackage.haskell.org/package/archlinux-0.3.6 (MagnusTherning)
10:49:35 <sleepynate> luite: you can poop the pdfs out to images, run your ocr, then collect your text at the end.
10:49:37 * hackagebot cabal2arch 0.7.7 - Create Arch Linux packages from Cabal packages.  http://hackage.haskell.org/package/cabal2arch-0.7.7 (MagnusTherning)
10:49:48 <sleepynate> luite: i know it's not ideal, but yea
10:49:54 <sleepynate> luite: it IS free :)
10:50:54 <monochrom> an ideal in a free domain
10:51:15 <kaustuv> An experiment I recently ran comparing low level OCaml and Haskell: http://www.lix.polytechnique.fr/~kaustuv/misc/incr_uarray/ -- comments welcome, especialy on the Haskell.
10:52:41 <luite> sleepynate: yes but that's really not very useful for me. I use pdf when the document must be kept in the original layout (for me it's mostly math and programming related books and papers).  many things don't tranlate nicely (if at all) to a text only format
10:52:43 <taotree> why would cabal reinstall dependencies when they are already installed?
10:53:04 <beastaugh> it gets confused sometimes
10:53:13 <sleepynate> luite: indeed. you basically have to re-layout the book
10:53:25 <monochrom> because you upgraded something. or because you corrupted something.
10:53:43 <taotree> ok, I probably did both :)
10:53:58 <monochrom> see http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for a con scenerio
10:54:01 <sleepynate> "ghc: could not execute: trhsx
10:54:08 <sleepynate>  why do i get that? :/
10:55:33 <monochrom> who is trhsx?
10:56:10 <sleepynate> a bad man, obviously
10:56:32 <sleepynate> or perhaps he was pardoned?
10:56:38 <monochrom> the good, the bad, and the could not be executed
10:56:53 <sleepynate> nobody has any ideas?
10:57:04 <monochrom> no, never heard of trhsx
10:57:10 <sleepynate> it's stopping me from building happstack on a stock haskell-platform
10:57:44 <sleepynate> i literally blew away all  my ghc libs and reinstalled
10:59:07 <monochrom> interesting, trhsx is http://hackage.haskell.org/package/trhsx , it is a program (not lib).
10:59:36 <zelvosaur> How can I use getContents multiple times? I want to read more chunks of text from stdin, but the first call closes the handle so second getContents fails.
10:59:55 <mauke> what do you mean by "more"?
10:59:57 <sleepynate> which is funny, 'cause i started by snagging a bin of 6.12.3 from haskell.org
10:59:58 <aristid> ugh, literal xml.
10:59:59 <monochrom> it is also obsolete
11:00:00 <mauke> getContents reads EVERYTHING
11:00:12 <aristid> if you want literal xml, use scala :P
11:00:34 <sleepynate> monochrom: then downloaded haskell-platform
11:00:56 <monochrom> oh, you should use http://hackage.haskell.org/package/hsx which also creates a program called trhsx
11:01:17 <monochrom> but we're so talking across each other
11:01:44 <zelvosaur> mauke: so I have to write my own function to do that?
11:01:51 <mauke> do what?
11:02:09 <sleepynate> monochrom: i did a cabal install hsx and i still get the same error
11:02:19 <monochrom> you have some "s <- getContents" don't you? keep traversing s for more
11:02:33 <monochrom> you have a PATH problem
11:03:10 <sleepynate> monochrom: install it --global ?
11:03:17 <zelvosaur> mauke: read some text (more than one line), then end the input with control-d and later read something again
11:03:29 <mauke> zelvosaur: that sounds terrible
11:03:30 <monochrom> --global unnecessary. you have a PATH problem.
11:03:31 <aristid> sleepynate: no, add $HOME/.cabal/bin to your path
11:05:00 * monochrom is about ready to declare "cabal-install is only for people with bloody sysadmin skills"
11:05:52 <sleepynate> monochrom: cabal install should come with better directions :D
11:06:17 <monochrom> yes. meanwhile, see http://www.vex.net/~trebla/haskell/sicp.xhtml for what's really going on
11:06:59 <zelvosaur> mauke: you are probably right, thinking about it again makes it sound like a not very good idea
11:07:17 <monochrom> however you still need bloody sysadmin skills to read "you have a PATH problem"
11:07:29 <sleepynate> for example: "Cabal is about to install an executable on your system as a user. It does not appear that the directory it will be installing to is on your $PATH. Please rectify this before running the program."
11:11:57 <sleepynate> anyways, i'm off to perform the black art that is known as system administration which apparently i don't understand. catch ya'll later.
11:18:02 <qfr> http://thedailywtf.com/Articles/Confessions-The-Shopping-Cart.aspx <- does the phenomenon where coders do stuff like this have a name? The only names I could think of were "Doing the work for the computer", "Fully unrolling loops", "Anti scaling"
11:18:33 <monochrom> doesn't have a name
11:19:39 <Botje> "job security" comes close
11:21:44 <monochrom> "There are two ways of constructing a software design. One way is to make it so simple that there are obviously no deficiencies. And the other way is to make it so complicated that there are no obvious deficiencies." - C.A.R. Hoare
11:21:54 <monochrom> that is the name you are looking for.
11:22:16 <qfr> <Botje> "job security" comes close
11:22:17 <qfr> Hahahaha
11:22:45 <aristid> monochrom: cabal could always add $HOME/.cabal/bin to its path before invoking subscripts.
11:23:22 <monochrom> solves only half of the problem
11:24:08 <aristid> yes, but the other half is much harder to solve
11:24:41 <EvanR-work> how do you pronounce hoare
11:24:42 <aristid> it could also warn after installing executables that adapting the PATH is necessary
11:24:53 <aristid> EvanR-work: like whore?
11:24:58 <EvanR-work> k ;)
11:25:05 <Saizan> the latter one would be easy to implement i think
11:25:10 <aristid> EvanR-work: i'm just guessing :D
11:25:19 <Saizan> the former would need some restructuring of the code
11:25:20 <monochrom> I suspect that cabal-install should default to --global. This is mimum surprise for most people.
11:25:27 <monochrom> s/mimum/minimum/
11:25:42 <aristid> monochrom: it would also make it much easier to break stuff royally
11:26:16 <aristid> monochrom: if i fuck up, i can still just remove .ghc/ and .cabal/ and start fresh. if it's installed globally, that is harder :)
11:26:26 <aristid> (guess what i did yesterday :D)
11:27:14 <dankna> well
11:27:22 <dankna> really what it needs is three repositories instead of two
11:27:24 <dankna> global, user, and system
11:27:29 <dankna> the last one never gets modified
11:27:40 <dankna> then it can install into the global one by default without fear of breakage
11:28:02 <dankna> dcoutts expressed agreement with this idea but I wasn't able to offer the time to implement it, so.
11:28:35 <j-invariant> what's the big deal about  rec Z z s = z ; rec (S n) z s = s (rec n z s)  vs   rec' Z z s = z ; rec' (S n) z s = s n (rec' n z s) ?
11:28:55 <quuuux> another solution would be a system package manager that can reasonably do per-user or local installations (without a full chroot). Then I can just fob off all the package management to that
11:29:00 <monochrom> no big deal
11:29:12 <Saizan> j-invariant: with rec' you can implement pred in O(1)
11:29:33 <Saizan> fsvo in that actually makes sense.
11:30:18 * edwardk waves hello.
11:30:26 * sipa particles hello.
11:30:59 * monochrom plasmas hello
11:31:12 <edwardk> man i was just coming in real fast, but i might annihilate sipa if i wave goodbye
11:33:02 <j-invariant> What's the importance of Godels T in proof theory?
11:33:29 <EvanCarroll> how come lambdabot has the soruce of Maybe, but not Either?
11:33:45 <edwardk> data Either a b = Left a | Right b
11:33:53 <monochrom> because lambdabot's @src is a random collection of hand-written code
11:33:59 <edwardk> ya
11:34:59 <monochrom> it is hand-written code off the top of someone's head, didn't even look at the haskell standard or a particular compiler.
11:35:18 <EvanCarroll> =( is there a method of improving upon it?
11:35:19 <andy__> (why?)
11:35:28 <andy__> why to monochrom
11:35:35 <EvanCarroll> I really love lambdabot's @src, I wish it was in available in ghci
11:35:46 <monochrom> yes. go read the haskell standard for real. http://www.haskell.org/onlinereport/haskell2010/
11:35:54 <EvanCarroll> too complex
11:35:56 <EvanCarroll> I'm just learning
11:36:11 <Saizan> the defs in the standard are quite simple
11:36:14 <andy__> and the convenience..
11:36:27 <EvanCarroll> I acknowledge it might be implimented differently for speed -- I'd love to see both available, bút the one that most clearly exprseses function has the value to me
11:36:30 <dolio>  @src is mostly from the standard or GHC libraries.
11:36:40 <monochrom> "not True         =  False" is not my idea of "too complex"
11:36:48 <dolio> It's just selected at random and put in a file somewhere.
11:37:41 <j-invariant> does anyone know about Godel System T
11:37:51 <dolio> A little.
11:38:01 <beastaugh> why do you ask?
11:38:08 <j-invariant> why does Robert Harper say it is in a versy special place in proof theory
11:38:33 <dolio> I don't know. It corresponds to Peano arithmetic, I think.
11:38:35 <dolio> So that's nice.
11:38:57 <j-invariant> oh I see
11:39:08 <monochrom> historically pioneering work has a very special place in general
11:39:52 <j-invariant> natural numbers and recursion
11:40:04 <edwardk> j-invariant, hat are you looking to find out?
11:40:05 <aristid> @quote ray 1970s
11:40:06 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
11:40:25 <j-invariant> edwardk: just curious about this remark: It occupies a very special place in proof theory
11:40:52 <edwardk> well, you can view it kind of as an ancestor of modern type theory, http://www.lix.polytechnique.fr/~dowek/Philo/godel.pdf
11:41:46 <copumpkin> oh, I turn my back at the window for a few minutes
11:41:53 <copumpkin> and it's snowing like crazy when I turn around again
11:41:58 <edwardk> hah
11:42:07 <edwardk> well, you were the one dumb enough to go into the office ;) 
11:42:12 <copumpkin> I didn't!
11:42:16 <edwardk> oh
11:42:17 <copumpkin> I was going to
11:42:23 <edwardk> lost track of who was where
11:42:25 <copumpkin> then I saw that nobody had plowed the sidewalks around my place
11:42:31 <copumpkin> so I said fuck this and went back inside
11:43:08 <beastaugh> j-invariant: have a look at Girard's book, Proofs and Types, it discusses System T at some length
11:43:43 <beastaugh> the whole thing is available online, let me find the link for you
11:44:01 <ddarius> My HTTP handler isn't getting called.
11:44:24 <beastaugh> http://www.paultaylor.eu/stable/Proofs+Types.html
11:45:02 <j-invariant> thanks!
11:46:08 <dolio> Oh, I guess it's not Peano arithmetic. It's first-order intuitionistic arithmetic, unsurprisingly.
11:48:08 <dolio> But every statement in the former can be encoded into a statement in the latter, I guess.
11:49:23 <ddarius> @google kolmogorov embedding of classical logic into intuitionistic logic
11:49:24 <lambdabot> http://mathgate.info/cebrown/papers/kolm-twelf.ps
11:49:55 <alpounet> the darcs videos are quite nice
11:50:17 <dolio> Huh, that appears to be just the last page of a paper.
11:50:22 <dolio> Thanks @google.
11:50:43 <ddarius> dolio: That's probably just a strange .ps
11:50:52 <hvr> dcoutts: any plans for a 'cabal sdistcheck' command?
11:50:57 <ddarius> I've seen ones like that before.  You can fix them by hacking the ps directly.
11:52:17 <monochrom> postscript encoding of classical logic into ps
11:52:33 <j-invariant> Schwichtenberg: Functions definable in the simply-typed lambda calculus
11:52:38 <j-invariant> oops
11:52:54 <j-invariant> Tait showed in 1967 that β-reduction is strongly normalizing <--- Didn't Alan Turing prove it earlier?
11:53:13 <timbaum> can somebody help me ... I have code that does not compile. Must be absolutely simple, but I just don't get it: http://hpaste.org/42983/illegal_functor_declaration
11:53:52 <j-invariant> does anyone here edit wikipedia? Maybe you can improve this article regarding "important results": http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus
11:54:08 <mauke> j-invariant: g e contradicts g c
11:54:17 <j-invariant> what are those letters
11:54:21 <mauke> e :: event
11:54:28 <mauke> c :: Composition event
11:54:43 <mauke> wat
11:54:52 <mauke> s/j-invariant/timbaum/
11:54:54 <monochrom> Sequence (fmap g c) (fmap g c')
11:54:56 <timbaum> thanks!
11:54:57 <edwardk> j-invariant: only when i find an obvious typo or infelicity
11:55:07 <j-invariant> edwardk: I'm scared to edit it
11:55:20 <j-invariant> but I think Alan Turing wast the first to prove it
11:55:21 <ddarius> Why?
11:55:31 <ddarius> Find a reference. 
11:57:19 <Cale> timbaum: You basically just need to use fmap recursively in the Composition case
12:02:00 <dolio> β-reduction of what?
12:02:58 <timbaum> Cale: thx, I was blind
12:03:49 <dolio> Simple types I guess.
12:03:56 <j-invariant> yes
12:11:22 <j-invariant> why is normalization proof difficult?
12:12:19 <Tomsik> well
12:12:39 <Tomsik> I'd guess because it's on borders of computability :p
12:12:47 <j-invariant> interesting
12:13:03 <Tomsik> never wondered actually and never seen it
12:13:42 <Tomsik> but it's somehow related to halting problem probably, so proof is probably nonconstructive 
12:13:54 <j-invariant> no, it is constructive
12:14:28 <monochrom> I'm pretty sure "difficult" is subjective.
12:14:36 <ddarius> j-invariant: You could start proving it and see if you have any troubles.
12:15:19 <monochrom> but historically pioneering proofs are difficult in general
12:15:46 <edwardk> back to hacking in all the higher order data instances for the comonad-transformers
12:16:42 <Tomsik> yeah, it's like somebody makes a proof of something that is 100 pages long and goes through semigroup theory
12:16:55 <Tomsik> and then week later somebody makes it fit on one page
12:17:58 <edwardk> i did that with a progress and preservation proof for a calculus with substructural types once. the original proof was a 130 page technical report. It fit in 4 pages once it was rephrased in terms of display logic
12:17:59 <monochrom> machine-checked proofs of Gödel incompleteness are now shorter than Gödel's paper.
12:18:16 <j-invariant> edwardk: wow!!
12:18:43 <ddarius> edwardk: Using display logic is cheating.  Formal logic is all about boilerplate.
12:18:49 <edwardk> ddarius: =)
12:19:04 <edwardk> logicians hate display logic. its the closest thing to a dirty hack in logic.
12:19:07 <ddarius> edwardk: You should give some of the deep inference work a look.
12:19:15 <j-invariant> I want to ulearn display logic :P
12:19:19 <edwardk> links?
12:19:31 <ddarius> @google "deep inference"
12:19:32 <lambdabot> http://alessio.guglielmi.name/res/cos/
12:19:32 <lambdabot> Title: Deep Inference
12:19:33 <edwardk> j-invariant: why?
12:19:40 <qfr> How do I check the type of <$>?
12:19:50 <monochrom> @type <$>
12:19:52 <lambdabot> parse error on input `<$>'
12:19:55 <jmcarthur> :t (<$>)
12:19:55 <Apocalisp> @type (<$>)
12:19:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:19:56 <monochrom> oops, I see
12:19:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:20:03 <j-invariant> edwardk: if you can prove 30 pages in 4!
12:20:15 <monochrom> you can do ":type (<$>)" in ghci
12:20:19 <qfr> Oh
12:20:23 <Tomsik> <$> = fmap
12:20:26 <edwardk> j-invariant: its good to know that the difficulties in proving the admissability of cut can be factored out, and that all this crap folks write for it is so much busy work ;)
12:20:35 <qfr> :type (<$>)
12:20:37 <qfr> Didn't work
12:20:41 <edwardk> in ghci
12:20:43 <monochrom> yeah lambdabot is stupid on that.
12:20:45 <qfr> <interactive>:1:1: Not in scope: `<$>'
12:20:54 <Kaidelong> @ty (<$>)
12:20:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:20:57 <monochrom> :m + Data.Applicative
12:21:00 <qfr> Ah.
12:21:01 <monochrom> oops
12:21:02 <jmcarthur> qfr: it's found in the Control.Applicative module
12:21:04 <timbaum> write :m + Control.Applicative
12:21:06 <monochrom> :m + Control.Applicative
12:21:07 <jmcarthur> not Data :P
12:21:19 <edwardk> technically its in Data.Functor and re-exported by Control.Applicative
12:21:56 * jmcarthur sighs at the inconsistency of those modules
12:22:21 <monochrom> you see what a misguided false dichotomy of "control vs data" does to you.
12:22:33 <edwardk> the justification i believe is that functors aren't usually being written as control structures, but applicatives are or some such. its kinda silly
12:23:15 <jmcarthur> arguably, everything is just data
12:23:34 <monochrom> everything is just word-mincing
12:23:38 <jmcarthur> at least in the sense that everything is a value
12:23:39 <jmcarthur> yeah
12:23:50 <tac-tics> jmcarthur: even codata?
12:24:06 <monochrom> the biggest irony is that word-mincing people dare to say "formal proofs are symbol games".
12:24:16 <jmcarthur> tac-tics: looks like a value to me. you can pass it around and read it like one
12:24:21 <edwardk> codata is data in haskell ;)
12:24:45 <monochrom> I assure you that the word-mincing game is worse.
12:25:08 <Saizan> codata is data, slavery is freedom, etc..
12:25:12 <ezyang> What is stg_ap_v_fast? 
12:25:24 <Philippa> monochrom: yeah, informal language is a symbol game where nobody can agree on the rules
12:25:45 <ezyang> I see all sorts of jumps to it, but for the life of me I can't figure ouit where the code actually lives. 
12:26:05 <Philippa> ezyang: at a guess, one of the various 'application stubs' the RTS generates? (per the eval/apply paper)
12:26:48 <edwardk> iirc its used to invoke IO operations quickly. you load it into r1 and tailcall it
12:27:23 <monochrom> data is codata. newtype is not type. do doesn't do.
12:27:37 <edwardk> the zen of haskell
12:28:09 <edwardk> "there is no do, only bind"
12:28:14 <jmcarthur> type is not type
12:28:17 <j-invariant> Does anyone know where to find examples of Monad for algebra? Like defining a group theory or whatever?
12:28:42 <ezyang> oh, it's a automatically generated code 
12:29:11 <kmc> yep, 'v' is the STG type for "void" meaning a 0-byte value
12:29:15 <kmc> i.e., State# RealWorld
12:29:36 <kmc> so that's the fast-apply code for functions of type, say, State# RealWorld -> T
12:29:37 <qfr> What do you use fmap for really?
12:29:44 <j-invariant> qfr: a lot
12:29:44 <kmc> i.e., the guts of an IO action
12:29:57 <kmc> > fmap (+3) (Just 4)
12:29:58 <lambdabot>   Just 7
12:30:03 <kmc> > fmap (+3) Nothing
12:30:04 <edwardk> qfr: pretty much every 10th line of code i write invokes fmap for something
12:30:04 <lambdabot>   Nothing
12:30:09 <edwardk> sometimes several times in a line
12:30:34 <kmc> ezyang, i think it lives in some cmm code that's generated at GHC build-time
12:30:36 <ddarius> j-invariant: I believe the Catsters has a talk about that use of monads.
12:30:37 <tac-tics> If you wish to create the universe from scratch, you must first invent the continuation.
12:30:52 <monochrom> hehe
12:30:53 <qfr> Ah, there's an instance Functor Maybe
12:30:57 <j-invariant> ddarius: that's where I got the idea
12:31:04 <monochrom> @remember tac-tics If you wish to create the universe from scratch, you must first invent the continuation.
12:31:05 <lambdabot> Good to know.
12:31:17 <kmc> ezyang, generated by ghc-7.0/utils/genapply/GenApply.hs
12:32:32 <edwardk> pretty much any type of kind * where the type argument occurs only in non-negative position winds up a Functor if the author is paying attention
12:32:34 <jmcarthur> qfr: yeah fmap is one of my most commonly used functions :)
12:32:44 <edwardk> er * -> *
12:32:46 <edwardk> gah
12:37:41 <jmcarthur> i wish there was some sugar for do { x <- foo; case x of ... }
12:37:53 * sipa too
12:38:08 <jmcarthur> i love higher order functions for stuff like that, but sometimes it's just not worth defining them
12:38:22 <edwardk> jmcarthur: yeah
12:38:26 <aristid> jmcarthur: i think case of functions would already help nicely
12:38:32 <aristid> foo >>= case of ...
12:38:52 <jmcarthur> is that already a proposed extension?
12:39:01 <edwardk> jmcarthur: at least in scala i can foo flatMap { case Left a => …  case Right b => … }
12:39:16 <edwardk> case of was proposed at one point
12:39:37 <ddarius> Yes!  Go to Scala for the nicer syntax.
12:39:39 <pastorn> how often do you really want to do cases with function compositien?
12:39:53 <edwardk> ddarius: hah, well, every dog has its day ;)
12:39:56 <pastorn> isn't it just in monadic context that this happends?
12:39:57 <jmcarthur> well, i never want to, but sometimes it still beats the alternative
12:40:18 <edwardk> pastorn: nah, you get this in applicatives, functor maps, etc.
12:41:19 <dolio> The problem is solved by lambda case of some sort.
12:41:48 <edwardk> besides then you could be leet and write flip id x $ case of {.. } instead of case x of and this whole thing could come full circle
12:41:56 <dolio> Which someone implemented at some point, but I don't remember if it got accepted into GHC.
12:41:58 <jmcarthur> seems like case of and lambda case are basically equivalent, no?
12:42:23 <edwardk> the case of is nice in that it fills a hole in the grammar and has no other impact
12:45:50 <aristid> edwardk: was the case of proposal shot down?
12:46:57 <dons> yow
12:46:58 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
12:47:19 <edwardk> heya dons, ltns
12:47:26 <dons> been on vacation :)
12:47:34 <edwardk> good reason then =)
12:47:45 <dons> edwardk: reminds me, did you work on an SMT solver edsl at some point?
12:47:51 <edwardk> yeah
12:48:02 <dons> ah interesting. any details?
12:48:09 <edwardk> i have a couple of them i need to package one up more robustly
12:48:16 <dons> http://code.haskell.org/~dons/docs/yices-painless/Yices-Painless-Language.html 
12:48:31 <dons> my project at the moment. (needed for work stuff ultimately)
12:48:59 <dons> lots of good little design problems in this task
12:49:00 <edwardk> mine was based on lots of terrible stablename machinery to enable me to escape from the monad as much as possible.
12:49:21 <dons> to control sharing?
12:49:44 <dons> if you have a link, i'd appreciate it. i'm  giving a talk on friday about all the known work :)
12:49:48 <edwardk> forall $ \x y z -> (x && y) ==> z == (x ==> y ==> z) — would introduce the variables and use observable sharing within the expression, etc.
12:50:05 <edwardk> it was one of the repositories eaten by patch-tag
12:50:09 <dons> oh?
12:50:21 <dons> eaten??
12:50:21 <edwardk> yeah thats why i quit darcs and moved to git. let me see what i have
12:50:44 <edwardk> yeah, patch-tag forgot a dozen or so repos of mine
12:50:51 <dons> how'd you overload (==) (or did you?)
12:51:35 <dons> send me a link if you can. i'd appreciate it.
12:51:42 <edwardk> yeah it was called 'ersatz'
12:51:51 <edwardk> checking patch-tag
12:52:24 <edwardk> http://patch-tag.com/r/ekmett/ersatz/snapshot/current/content/pretty/Data/Logic/Ersatz is there, but it doesn't look like the final version
12:52:40 <edwardk> in fact it looks like a fairly early revision
12:52:54 <aristid> dons: you guys sure love writing frontends to SAT solvers?
12:53:12 <edwardk> i didn't overload ==, i stand corrected. i did overload the boolean operators though: http://patch-tag.com/r/ekmett/ersatz/snapshot/current/content/pretty/Data/Logic/Ersatz/Internal/Bit.hs
12:53:29 <edwardk> ersatz was a sat solving version. i started working on the smt solver later with nirav dave
12:53:49 <edwardk> basically exploiting the function sharing trick from nikola for SMT purposes
12:53:57 <Igloo> edwardk: While patchtag losing repos is obviously bad, didn't you have a local copy?
12:54:36 <qfr> Is there any difference between (+1) and (1+) really?
12:54:47 <edwardk> igloo: i was living off of the repo for the most part, because i work out of VMs typically, so the local repository to me is usually just a cache
12:55:01 <edwardk> qfr: for that operator, not really
12:55:02 <Igloo> qfr: Yes, although not an observable one for Num instances like Int
12:55:09 <edwardk> qfr: depends on your Num though =)
12:55:10 <aristid> qfr: yes, one is \a -> a + 1, the other is  \a -> 1 + a
12:55:33 <qfr> You need to have a special instance for that to do something different?
12:55:35 <edwardk> instance Num Foo where a + _ = a will see a pretty big difference =)
12:55:38 <aristid> edwardk: there's no law that Num must be commutative, is there?
12:55:41 <qfr> Right
12:55:58 <edwardk> aristid: laws for Num would presuppose that it has some sort of rigorous foundation
12:56:06 <aristid> true dat
12:57:02 <edwardk> igloo: a lot of the stuff i had up on patch-tag i didn't have locally — the rest i moved over to github
12:57:17 <Igloo> Fair enough
12:58:45 <qfr> > fmap (+1) (Left 0)
12:58:46 <lambdabot>   Left 0
12:59:11 <qfr> Wait what, in ghci that errors for me
12:59:23 <edwardk> import Control.Monad.Instances
12:59:39 <edwardk> the Either instance for Functor isn't in the Prelude according to Haskell 98, so they had to bury it somewhere else
12:59:58 * hvr just read on ghc-wiki: "Forthcoming planned releases: 7.0.2 (approx December 22 2010)" ... quite an ε
13:00:04 <qfr> I'd expect that to yield Left 1
13:00:09 <qfr> What am I doing wrong?
13:00:15 <edwardk> qfr: look at the kinds
13:00:22 <edwardk> Either takes two arguments
13:00:28 <qfr> Yes
13:00:32 <parcs> > fmap (+1) (Right 0)
13:00:33 <lambdabot>   Right 1
13:00:39 <edwardk> the first argument is the type of the contents of Left, the other is the type of the argument of Right.
13:00:40 <jmcarthur> qfr: fmap :: (a -> b) -> Either c a -> Either c b
13:00:53 <jmcarthur> qfr: fmap :: (a -> b) -> (Either c) a -> (Either c) b
13:01:22 <edwardk> when you substitute Either a for 'f' in the definition of fmap you only change the contents of the right hand side of it
13:01:33 <qfr> I am puzzled, why is there only an instance for Functor (Either a)
13:01:45 <jmcarthur> qfr: as opposed to what?
13:01:46 <qfr> Oh one argument is always gone
13:01:50 <jmcarthur> yup
13:01:50 <qfr> same with Maybe
13:01:55 <edwardk> yeah
13:02:08 <dons> edwardk: thanks!
13:02:10 <dons> aristid: yep.
13:02:10 <edwardk> thats why the order of arguments to haskell types matter, because you can partially apply them
13:02:12 <jmcarthur> only things with kind * -> * can be instances of Functor
13:02:26 <jmcarthur> Either a :: * -> *, but Either a b :: *
13:02:40 <monochrom> you see how much more you can understand by giving up "understand" and just doing it mechanically, i.e., "one argument gone"
13:02:45 <edwardk> dons: i'll pull that down and move it over to github.com/ekmett/ersatz
13:03:03 <edwardk> if you are looking for a canonical url to give for it
13:04:01 <edwardk> i see you are tageting yices as well
13:04:51 <monochrom> dons got involved in haskell, and look at what happened, cabal and hackage.
13:04:55 <copumpkin> kmc also has a yices binding
13:05:32 <monochrom> now dons is into SMT, and I fully expect fully automated large-scale program verification in 5 years!
13:06:14 <pikhq> *Not* a fully automated RPG playing program?
13:06:16 <companion_cube> you mean, dons is into haskell verification via SMT? 
13:06:25 <monochrom> if dons were Turing's phd student, the halting problem would be solved. :)
13:06:57 <monochrom> I don't know what dons is verifying. But SMT is useful for verification of all programs.
13:07:11 <ddarius> pikhq: Game programmers cheat wherever they can.  As such, such a program would nearly have to wait 40 hours and then display the final cut scene.
13:08:43 <Mitar> hmm: help: http://hpaste.org/42985/type_error
13:10:17 <monochrom> I am not even sure "data NeuronOptions (NodeNeuron a b) = ..." is valid.
13:10:29 <Mitar> why not?
13:10:33 <j-invariant> it's not valid
13:10:34 <Mitar> it is a data type family
13:10:39 <j-invariant> oh 
13:10:43 <j-invariant> it's parto f a whole thing then
13:10:48 <Mitar> yes
13:10:52 <qfr> Where can I see the source of the Functor instance of Either a?
13:10:53 <Mitar> of a NodeNeuron a b instance
13:11:14 <monochrom> well then I have no comments for incomplete code.
13:11:15 <qfr> Or is there just the instance and no method?
13:11:25 <Mitar> no, there is everything
13:11:57 <Mitar> http://hackage.haskell.org/packages/archive/Etage/0.1.7/doc/html/Control-Etage.html#t:Neuron
13:12:01 <copumpkin> Mitar: you mean data instance?
13:12:05 <copumpkin> cause as written, it's invalid
13:12:21 <Mitar> no, i mean instance of class Neuron
13:12:27 <copumpkin> oh
13:12:39 <Mitar> which has associated data type NeuronOptions
13:12:53 <Mitar> and for n I give (NodeNeuron a b)
13:13:01 <aristid> the syntax for associated types is cumbersome
13:13:20 <dskippy> What are associated types?
13:13:29 <qfr> Urgh I still don't get this: <edwardk> when you substitute Either a for 'f' in the definition of fmap you only change the contents of the right hand side of it
13:13:31 <alpounet> Mitar, something like fmap f (Left x) = Left x ; fmap f (Right y) = Right (f y) probably
13:13:59 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html are associated types
13:13:59 <qfr> alpounet oh did you mean me?
13:14:17 <qfr> Because that would explain everything, heh
13:14:23 <alpounet> hm
13:14:27 <alpounet> qfr* yeah sorry
13:14:44 <qfr> And Left (f x) would make no sense because...
13:14:48 <Mitar> nodeneuron is defined as
13:14:48 <Mitar> data NodeNeuron a b = NodeNeuron Node a deriving (Typeable, Data)
13:14:51 <alpounet> qfr, "Either" isn't a functor
13:14:52 <Mitar> maybe this is a problem?
13:14:54 <alpounet> "Either a" is
13:15:06 <alpounet> the 'a' here is the type held by the 'Left'
13:15:17 <qfr> Since the type of the left side cannot be changed?
13:15:21 <alpounet> yeah
13:15:23 <qfr> So it would make no sense to apply f
13:15:26 <qfr> Hence the code
13:15:27 <alpounet> because once you say "Either a" for some a
13:15:44 <alpounet> you can't change that a
13:16:34 <copumpkin> holy shit, I now have a fancy 2010-style outlook web app
13:16:51 <ddarius> copumpkin: Your mother would be proud.
13:16:57 <monochrom> but we're already at 2011
13:17:01 <copumpkin> indeed :(
13:17:08 <monochrom> even haskell is slated for "haskell 2012"
13:17:11 <ddarius> copumpkin: Meanwhile, I have a increased hatred for Visual Studio.
13:17:21 <qfr> My Haskell learning process: stumbling upon the signature of some standard function or some instance and then thinking 4-8 hours about it before I grasp it
13:17:34 <copumpkin> ddarius: surely not! I thought everything microsoft made was amazing
13:18:15 <aristid> qfr: playing with ghci always helps me dissect it :)
13:18:26 <qfr> aristid yeah I have ghci running for like 12 hours per day
13:18:35 <Philippa> yeah, ghci's a nice debugging tool if you don't have to worry too much about IO
13:18:48 <monochrom> microsoft products are neither all good nor all bad, but visual studio should be pretty good, what do you hate it for?
13:18:59 <qfr> Not even debugging in my case :|
13:19:20 <qfr> Unless you consider "not understanding Haskell" a bug
13:19:27 <monochrom> your ghci may sue you for labour exploitation
13:19:31 <aristid> qfr: you're buggy! :D
13:19:38 * monochrom unionizes qfr's ghci
13:19:40 * qfr sobs
13:19:53 <qfr> monochrom haha
13:19:56 <ddarius> monochrom: I actually like Visual Studio a reasonable amount (though definitely not as much as some.)
13:20:13 <qfr> VS2010 starts up so slowly :/ it greatly annoys me
13:20:29 <aristid> !cal let b = "Benoit " ++ b ++ "Mandelbrot" in b
13:20:30 <qfr> Lots of people bitch about that and rightly so
13:20:36 <monochrom> who cares about starting slowly if you run it 12 hours a day
13:20:37 <aristid> > let b = "Benoit " ++ b ++ "Mandelbrot" in b
13:20:40 <lambdabot>   "Benoit Benoit Benoit Benoit Benoit Benoit Benoit Benoit Benoit Benoit Beno...
13:21:03 <monochrom> moreoever you are not even supposed to quit it. you are just supposed to suspend your computer.
13:21:22 <ddarius> monochrom: But I just spent hours trying to figure out why my code wasn't working only to find out that for some reason or another the dll wasn't being rebuilt (most likely, that or it just wasn't including my class) despite explicitly rebuilding and cleaning and rebuilding.
13:21:44 <ddarius> Manually, deleting the dll at least has my code in the dll at all now.  Now to see if it will actually get run.
13:21:49 <edwardk> qfr: to be fair though, once you understand fmap most other similar types start to make perfect sense, so its useful to beat your head against this one for a while and try to really understand it
13:21:49 <qfr> <monochrom> moreoever you are not even supposed to quit it. you are just supposed to suspend your computer. <- Windows update will kill you for that
13:21:56 <monochrom> ok that's a weird behaviour and very annoying
13:22:05 <qfr> edwardk haha, I'll take your word for it :/
13:22:17 <monochrom> windows update happens weekly or monthly, not even half-weekly.
13:22:23 <ddarius> Once you understand the type system, Haskell becomes far more easy.
13:22:34 <qfr> mightybytes from #snapframework and some other people in there spent like 4-6 hours explaining monads and monad transformers to me today
13:22:50 <qfr> Woops *mightybyte
13:22:51 <edwardk> qfr: fmap is subject to two laws (technically one, since the other follows based on parametricity from the first).   fmap id = id  and fmap f . fmap g = fmap (f . g)
13:22:58 <qfr> Yeah I already saw
13:23:06 <j-invariant> wow
13:23:07 <qfr> Reminds me of linear algebra
13:23:18 <j-invariant> :t fmap id
13:23:19 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
13:23:20 <monochrom> even waiting 10 minutes for VS to start once a week is pretty insignificant
13:23:35 <j-invariant> @free f a -> f a
13:23:35 <lambdabot> Extra stuff at end of line
13:23:43 <j-invariant> @free (a -> b) -> (f a -> f b)
13:23:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:23:45 <edwardk> qfr: the first says that the only thing that fmap does is route your function through the type to change all a's in to b's, the second says you can therefore exploit that to glue together functions
13:23:49 <cpa> how should I coerce a GLfloat to a Float?
13:24:03 <copumpkin> @free f : (a -> b) -> (f a -> f b)
13:24:03 <lambdabot> Extra stuff at end of line
13:24:07 <copumpkin> @free f :: (a -> b) -> (f a -> f b)
13:24:07 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
13:24:08 <monochrom> if you're really annoyed, you should schedule weekly programmer meetings to coincide with weekly VS restarts. that will be a great relief.
13:24:08 <cpa> given that GLfoat is: type GLfloat = Float
13:24:20 <copumpkin> @free f :: f a -> f a
13:24:20 <lambdabot> Extra stuff at end of line
13:24:21 <edwardk> j-invariant: between the free theorem and the fmap id = id law you can set up two definitions of fmap and prove them equivalent
13:24:23 <copumpkin> lol
13:24:42 <copumpkin> holy shit
13:24:49 <copumpkin> #haskell has 699 users
13:24:57 <copumpkin> come on, one more
13:25:04 <edwardk> we've peaked over 700 before
13:25:08 <copumpkin> oh
13:25:09 <ddarius> If you read . as a dot product (and id as 1) then you have an outermorphism that's also an orthogonal transformation.
13:25:15 <copumpkin> I'd only ever seen it hit just under 700
13:25:16 <qfr> copumpkin: Stop obsessing over decimal numerology
13:25:21 <ddarius> We were just at over 700.
13:25:29 <copumpkin> qfr: I'll obsess over whatever I want
13:25:31 <qfr> You can pick a base where 699_10 is already >= 700_n
13:25:45 <ddarius> I've seen,  I think, 714, though I'm pretty sure there have been more on at one time.
13:25:57 <qfr> For example, n in {9, 8}
13:25:58 <edwardk> @users
13:25:58 <lambdabot> Unknown command, try @list
13:26:16 <qfr> Excuse me, n `elem` [8, 9]
13:26:18 <quuuux> hey, we've almost got 10 users in #haskell! (in base 10)
13:26:20 <ddarius> edwardk: I believe that was part of the seen module.
13:26:24 <copumpkin> qfr: then you wouldn't have the digit 9 in the number
13:26:27 <edwardk> ah
13:26:31 <edwardk> preflex: users
13:26:37 <copumpkin> oh you mean that way around
13:26:38 <edwardk> no love there either
13:26:41 <copumpkin> whatever :P
13:26:49 <copumpkin> I like my 700
13:27:08 <edwardk> clearly you just need to work in an irrational base > 9 ;)
13:27:10 <dolio> > showIntAtBase 9 intToDigit 699 ""
13:27:11 <qfr> copumpkin just pick n = 1 to be even more impressed
13:27:12 <lambdabot>   "856"
13:27:14 <dolio> > showIntAtBase 8 intToDigit 699 ""
13:27:15 <lambdabot>   "1273"
13:27:26 <qfr> There you go ^
13:27:33 <monochrom> if you want more users, I can clean up the ban list, you know...
13:27:39 <qfr> > showIntAtBase 1 intToDigit 699 ""
13:27:41 <lambdabot>   "*Exception: Numeric.showIntAtBase: applied to unsupported base 1
13:27:47 <qfr> :(
13:27:59 <monochrom> you have 700 now
13:28:04 <copumpkin> yay
13:28:47 <monochrom> you are really like those people on the stock trading floor...
13:28:58 <qfr> take 702 $ repeat '0'
13:29:01 <qfr> > take 702 $ repeat '0'
13:29:02 <lambdabot>   "00000000000000000000000000000000000000000000000000000000000000000000000000...
13:29:09 <qfr> How do you make that shorter again?
13:29:19 <monochrom> by using a smaller number than 702
13:29:23 <copumpkin> lol
13:29:26 <alpounet> > replicate 702 '0'
13:29:27 <lambdabot>   "00000000000000000000000000000000000000000000000000000000000000000000000000...
13:29:28 <qfr> I am talking about the generating term
13:29:32 <qfr> Ahh replicate, I was looking for that
13:29:41 <copumpkin> > ['0', '0'..]
13:29:42 <lambdabot>   "00000000000000000000000000000000000000000000000000000000000000000000000000...
13:29:43 <qfr> I couldn't remember it, I was looking at cycle and repeat etc
13:30:03 <edwardk> > take 12 $ replicate 702 '0'
13:30:04 <lambdabot>   "000000000000"
13:30:07 <edwardk> like that?
13:30:08 <dskippy> qfr: Hoogle let's you search by type, which is *really* useful.
13:30:15 <alpounet> i used it quite a lot for my continued fractions code
13:30:18 <edwardk> > length $ replicate 702 'o'
13:30:18 <alpounet> thus my remembering of it
13:30:19 <lambdabot>   702
13:30:20 <qfr> dskippy oh, very interestign :o
13:31:03 <qfr> http://www.haskell.org/hoogle/?hoogle=a+-%3E+b+-%3E+[a]
13:31:05 <qfr> Fascinating.
13:31:33 <qfr> Oh yeah I should have used Int, obviously
13:31:35 <qfr> Stupid me
13:31:52 <qfr> http://www.haskell.org/hoogle/?hoogle=Int+-%3E+a+-%3E+[a]
13:32:00 * sm hugs hoogle
13:32:04 <qfr> Wrong argument order, too :p
13:32:29 <monochrom> always try all orders
13:32:43 <c_wraith> be the combinatorial explosion!
13:32:53 <edwardk> or you can just stare at all the library functions trying to figure them all out so you have more tools in the toolchest ;)
13:33:33 <qfr> For n arguments {a, b, c, ...} and one output type you get n! combinations, then, no?
13:33:46 <qfr> This type of Hoogling is `elem` O(n!)
13:34:13 <monochrom> I skimmed the stand lib docs briefly when I learned haskell. I thought everyone did.
13:35:40 <edwardk> i just sat here thinking up functions and then hunting for how the standard library guys came up with something smarter than i did ;)
13:36:21 <ddarius> edwardk: Yeah, but few people can see that sequence is that clever cross product function they just wrote.
13:36:47 <edwardk> yeah. cale was a great help in that regard =)
13:37:11 <qfr> what did @pl do again?
13:37:16 <copumpkin> use traversable for your matrix multiplication needs!
13:37:19 <edwardk> @pl \x -> x
13:37:19 <lambdabot> id
13:37:29 <monochrom> convert to pointfree form
13:37:34 <edwardk> it tries to take a lambda and use primitive functions to simplify it into pointfree style
13:37:37 <ddarius> @help pl
13:37:37 <lambdabot> pointless <expr>. Play with pointfree code.
13:37:55 <edwardk> @pl \f x y z -> f (x y) z
13:37:55 <lambdabot> (.)
13:38:37 <qfr> Can it even produce composite functions?
13:38:49 <hpc> @pl \a b c d e f g h -> a c d b g h b f e
13:38:50 <lambdabot> ((((flip . ((flip . (flip .)) .) . flip . (flip .)) .) .) .) . join . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . (flip .)
13:38:51 <qfr> Or does it just support simplifying to simple functions?
13:38:53 <qfr> :o
13:38:54 <hpc> oops :P
13:38:56 <qfr> Ok that would answer that
13:39:00 <edwardk> hahahaha
13:39:05 <sproingie> lambdabot flipped out
13:39:09 <edwardk> i was starting with small examples
13:39:15 <edwardk> =)
13:39:18 <qfr> In this case it was not much of a success though :P
13:39:24 <qfr> Although it IS point free.
13:39:27 <hpc> @pl f g = g (f g)
13:39:27 <lambdabot> f = fix (ap id)
13:39:37 <ddarius> @quote flip.stream
13:39:37 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
13:39:39 <hpc> @pl ap id
13:39:39 <lambdabot> ap id
13:39:49 <ddarius> @pl ap id id (ap id id)
13:39:52 <lambdabot> ap id id (ap id id)
13:39:52 <lambdabot> optimization suspended, use @pl-resume to continue.
13:39:54 <sproingie> @pointy ap id
13:39:54 <lambdabot> (\ f -> (\ a -> a) >>= \ c -> f >>= \ b -> return (c b))
13:39:56 <edwardk> pointfree style is rarely a win when you are plumbing more than one argument, especially if one has to go deep 'into' the body of the function
13:40:00 <qfr> @pl f a b = take a $ repeat b
13:40:01 <lambdabot> f = (. repeat) . take
13:40:06 <qfr> :(
13:40:12 <qfr> I expected that to spit out replicate
13:40:19 <monochrom>  @pl uses just heuristics. no promise of "simplest" or "shortest".
13:40:25 <sproingie> it doesnt know about replicate
13:40:26 <hpc> :t (<*> id)
13:40:27 <lambdabot> forall a b. (a -> a -> b) -> a -> b
13:40:38 <hpc> :t join
13:40:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:40:56 <monochrom> and what edwardk says about complex plumbing
13:41:02 <ddarius> We should have it produce the program with the minimum Kolmogorov complexity that is equivalent to the input.
13:41:07 <hpc> ap id could rewrite to join, i think
13:41:33 <hpc> (for purposes of @pl)
13:41:41 <sproingie> ddarius: pull that off and i suspect there's a turing award in it for you
13:41:44 <copumpkin> `ap` id
13:41:47 <monochrom> giving names to parameters and intermediate thingies is great when you have complex, nonlinear data-flow.
13:41:49 <edwardk> qfr: @pl doesn't take into consideration all of the laws about how functions are equivalent, it just looks at each argument in turn, and goes through the very mechanical operations of removing them, it does a few ad-hoc rewrites of other things on the way
13:41:50 <hpc> monochrom: or even "correct"
13:41:57 <copumpkin> > ((+) <*> id) 5
13:41:58 <lambdabot>   10
13:41:59 <edwardk> but they aren't the 'essence' of pl
13:41:59 <hpc> (RE: no promises)
13:42:00 <copumpkin> (only for functions)
13:42:06 <copumpkin> not in general
13:42:17 <qfr> :t <*>
13:42:19 <lambdabot> parse error on input `<*>'
13:42:25 <qfr> :t (<*>)
13:42:26 <hpc> :t (<*>)
13:42:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:42:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:42:32 <edwardk> it even cheats, because occasional @pl will assume things like the commutativity of (+) which aren't true
13:42:34 <ddarius> The concatenative programmers are laughing at you weaklings.
13:42:44 <monochrom> the only approach greater than giving names is graphical display
13:42:46 <qfr> Nooo, more stuff I've never heard of before
13:42:50 <qfr> Is this ever going to end :(
13:42:53 <copumpkin> qfr: no
13:42:58 <hpc> qfr: fortunately not
13:43:00 <qfr> C++ seemed trivial in comparison to this
13:43:01 <j-invariant> yes it will
13:43:03 <edwardk> qf: if it does, you're dead
13:43:06 <hpc> if it ever stopped, it would be boring
13:43:08 <qfr> Point taken
13:43:13 <j-invariant> I haven't heard of anything new in years
13:43:16 <copumpkin> lol
13:43:22 <copumpkin> j-invariant stands for jaded invariant
13:43:23 <hpc> you are not looking hard enough
13:43:24 <j-invariant> why do people pretend like human knowledge is infinite
13:43:41 <hpc> j-invariant: well, it's as finite as our light-cone
13:43:50 <ddarius> It doesn't need to be infinite, it just needs to be more than one person can learn.
13:44:01 <ddarius> j-invariant: I doubt you know how to shuttle tat.
13:44:03 <j-invariant> anyway you can learn all of haskell
13:44:10 <monochrom> not pretend. there are infinitely many theorems. human knowledge is infinite.
13:44:20 <jmcarthur> potentially infinite
13:44:26 <hpc> you can learn all of the syntax and libraries, perhaps
13:44:28 <silver> j-invariant, how 'bout knot theory in quantum mechanics?
13:44:29 <j-invariant> ddarius: i don't knot that... true
13:44:30 <jmcarthur> "boundless" would be more precise i think
13:44:38 <hpc> there's always more extensions and wonky applications and typeclasses
13:44:40 <j-invariant> silver: I have a book on it but I haven't studied it
13:44:47 <hpc> oh god, the typeclasses
13:45:15 <j-invariant> Every programming language I learned on the past lead to something new
13:45:25 <j-invariant> Haskell does not lead me to anything new: I don't know what to do now
13:45:27 <monochrom> anyway if you have to ask "why do people pretend like human knowledge is infinite" you should ask that to the mathematicians you so love first.
13:45:36 <hpc> j-invariant: look harder
13:45:43 <ddarius> j-invariant: Do you know lambdaProlog?
13:45:49 <j-invariant> monochrom: There are only finitely many mathematical theorems which are not families of thoerems.
13:45:58 <j-invariant> ddarius: yes
13:46:00 <ddarius> That's not true.
13:46:07 <edwardk> jaded-invariant indeed
13:46:11 <hpc> j-invariant: define "family of theorems"
13:46:27 <hpc> or admit defeat; whichever is easier :P
13:46:32 <monochrom> mathematicians manage to even invent new branches periodically.
13:46:38 <j-invariant> hpc: well I can say that I have infinitely many theorems:  1 + 1 = 2, 1 + 2 = 3, ...  but i am cheating: This is obviously generated by a schema
13:46:47 <dskippy> Is this actually a conversation about finding things for j-invariant to learn because there's nothing left for him to learn?
13:46:57 <j-invariant> dskippy: yes
13:46:57 <copumpkin> dskippy: yep
13:47:06 <copumpkin> j-invariant: oh I know what you can learn
13:47:09 <edwardk> dskippy: yes. he has apparently become the sum total of human knowledge
13:47:13 <copumpkin> j-invariant: you can set out to learn the bounds of your knowledge!
13:47:17 <hpc> copumpkin: humility? :P
13:47:19 <dskippy> j-invariant: There are plenty of things out there for you to learn. Get more curious.
13:47:28 <edwardk> it can be quite a burden
13:47:33 <jmcarthur> read some Plato
13:47:39 <ddarius> Plato was crazy.
13:47:41 * ksf_ wonders whether there are infinite many smart alecs.
13:47:43 <j-invariant> I wasn't sure if I could read Plato
13:47:50 <dskippy> copumpkin: j-invariant definitely hasn't learned all there is to learn.
13:47:53 <j-invariant> I thought I might not appreciate it properly
13:47:59 <copumpkin> dskippy: you can't say that for sure!
13:47:59 <hpc> ksf_: probably, but there are only finitely many witty jabs
13:48:00 <j-invariant> dskippy: yes i was not claiming that -
13:48:00 <jmcarthur> ddarius: but he had something to say about knowledge at least
13:48:07 <monochrom> You could start working on proving haskell programs correct. The halting problem implies that you will not end.
13:48:09 <copumpkin> dskippy: maybe he has infinite capacity for knowledge and has lived forever
13:48:14 <ddarius> jmcarthur: Crazy people have stuff to say about everything.
13:48:19 <dskippy> copumpkin: Yeah, you got me there.
13:48:29 <copumpkin> I'm good like that
13:48:36 <jmcarthur> craziness /= worthless
13:48:43 <jmcarthur> *worthlessness
13:48:55 <ddarius> jmcarthur: Indeed.  I didn't say that at all.
13:49:10 <monochrom> crazy evaluation has stuff to evaluate about every thunk
13:49:14 <jmcarthur> then what was the relevance?
13:49:27 <j-invariant> jmcarthur: full disclosure
13:49:30 <hpc> monochrom: i smell a GHC extension!
13:49:48 <hpc> {-# LANGUAGE CrazyEvaluation #-}
13:49:51 <copumpkin> hpc: don't mind that, it's just implicit parameters
13:49:53 <Mitar> so any ideas about http://hpaste.org/42985/type_error?
13:50:14 <monochrom> no ideas
13:50:30 <qfr> ghc should automatically warn you about using stuff like take a $ repeat b by default because there's already a standard function which does just that :'(
13:50:56 <hpc> Mitar: that's a rather wrongly kinded type
13:50:59 <j-invariant> Mitar: you must write the data instance manually
13:51:14 <jmcarthur> qfr: check out hlint
13:51:22 <edwardk> you can actually implement a language with pessimistic/antagonistic evaluation that tries to find the worst possible evaluation order, but then when you cps transform it doesn't matter
13:51:26 <ksf_> qfr, program equivalence is undecidable
13:51:28 <hpc> oh, extensions
13:51:33 <hpc> ignore my advice
13:51:40 <qfr> ksf_: I don't mind
13:51:49 <Mitar> why should i manually?
13:52:03 <silver> lol
13:52:06 <hpc> qfr: if you can wait for it to finish compiling...
13:52:18 <monochrom> qfr: http://community.haskell.org/~ndm/hlint/
13:52:24 <qfr> hpc are you going halting problem yadda yadda on me? :/
13:52:43 <copumpkin> :t let branchy :: Bool -> ((?q :: Int) => r) -> ((?q :: Float) => r) -> r; f x t f = if x then let ?q =  5 in t else let ?q = 5.6 in f in branchy
13:52:44 <hpc> no, just that searching haskell libraries would take for-fucking-ever
13:52:44 <lambdabot>     The type signature for `branchy' lacks an accompanying binding
13:52:44 <lambdabot> Not in scope: `branchy'
13:52:46 <Mitar> so why it cannot do data instance automatically
13:52:47 <Mitar> ?
13:52:52 <copumpkin> :t let branchy :: Bool -> ((?q :: Int) => r) -> ((?q :: Float) => r) -> r; branchy x t f = if x then let ?q =  5 in t else let ?q = 5.6 in f in branchy
13:52:53 <lambdabot> forall r. Bool -> ((?q::Int) => r) -> ((?q::Float) => r) -> r
13:52:57 <hpc> it's a full-text search of oodles of information
13:53:04 <monochrom> halting problem yada yada is counterproductive. unless you use it to say "therefore permanent employment"
13:53:18 <edwardk> what does your 'data' type mean, disregarding the 'Data' instance that is trying to be generated
13:53:19 <copumpkin> hm, interesting
13:53:28 <ddarius> hpc: The Haskell libraries are quite a bit smaller than the internet and Google doesn't take that long.
13:53:33 <edwardk> data Foo (Bar a b) = !?
13:53:36 <copumpkin> > let branchy :: Bool -> ((?q :: Int) => r) -> ((?q :: Float) => r) -> r; branchy x t f = if x then let ?q =  5 in t else let ?q = 5.6 in f in branchy True ?q ?q
13:53:37 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
13:53:38 <lambdabot>         against inferred typ...
13:53:48 <copumpkin> > let branchy :: Bool -> ((?q :: Int) => r) -> ((?q :: Float) => r) -> r; branchy x t f = if x then let ?q =  5 in t else let ?q = 5.6 in f in branchy True ?q (round ?q)
13:53:49 <lambdabot>   5
13:54:00 <copumpkin> > let branchy :: Bool -> ((?q :: Int) => r) -> ((?q :: Float) => r) -> r; branchy x t f = if x then let ?q =  5 in t else let ?q = 5.6 in f in branchy False ?q (round ?q)
13:54:01 <lambdabot>   6
13:54:03 <copumpkin> magic!
13:54:14 <monochrom> hpc may like to see http://community.haskell.org/~ndm/hlint/ too :)
13:54:51 <ddarius> copumpkin: What's supposed to be magic about this?
13:55:00 <edwardk> mitar: plus, Data doesn't make sense without Typeable, so i'm guessing you did that by accident
13:55:01 <hpc> monochrom: that's not magic enough :P
13:55:06 <copumpkin> ddarius: I just didn't think that would work
13:55:19 <monochrom> submit patches to add more magic!
13:55:31 <ddarius> copumpkin: It's just like branchy b maxBound (round maxBound) or similar.
13:55:54 <monochrom> anyway the only thing I hate about hlint is its religious obsession with camel_case
13:56:00 <Mitar> edwardk: typeable is defined on a type class of which this is an instance of
13:56:15 <copumpkin> camel_case is easy to troll with
13:56:23 <j-invariant> People misunderstood me. Let me explain: I am not at the research front of programming languages - but I don't know what's between that, and where I am now
13:56:25 <copumpkin> it's a bit like how trolling is a art, I guess
13:56:28 <hpc> wait
13:56:30 <edwardk> mitar: forgive me, but my mental haskell compiler fails to parse data Foo (Bar a b) =
13:56:33 <hpc> camel case is camelCase
13:56:40 <silver> copumpkin, haha
13:56:42 <hpc> this_is_c_style_underscore_nonsense
13:56:49 * hpc is foncused
13:57:11 <silver> successful troll is successful
13:57:34 <copumpkin> monochrom: you're an excellent troll
13:57:36 <qfr> Oh, (<$>) has the same signature as fmap
13:57:36 <hpc> haha
13:57:42 <copumpkin> I've passed the trolling on to my twitter followers
13:57:46 <hpc> qfr: and the same definition too!
13:57:54 <qfr> Then what's the point
13:57:55 <edwardk> qfr: yeah in the code it just says (<$>) = fmap
13:57:56 <jmcarthur> (<$>) = fmap
13:58:12 <j-invariant> i wish I knew :[
13:58:17 <monochrom> <$> fits more nicely with <*>
13:58:18 <edwardk> qfr: it can be written infix and in a more visually pleasing manner than `fmap`
13:58:19 <qfr> Why do people even use it then? It's massively more annoying to type than fmap
13:58:20 <hpc> qfr: infix function where it looks best, and aesthetics
13:58:21 <jmcarthur> > succ . (*2) <$> Just 5
13:58:23 <lambdabot>   Just 11
13:58:25 <qfr> Ah `fmap`
13:58:26 <j-invariant> maybe thats why people take CS classes
13:58:27 <copumpkin> qfr: really?
13:58:33 <jmcarthur> > fmap (succ . (*2)) (Just 5)
13:58:34 <lambdabot>   Just 11
13:58:36 <edwardk> > (,) <$> Just 12 <*> Just 12
13:58:37 <lambdabot>   Just (12,12)
13:58:42 <hpc> for another example of this in action...
13:58:47 <jmcarthur> qfr: which of those two things i just typed do you prefer?
13:58:54 <ddarius> copumpkin: Now all those l33t h4x0r kids can be incensed if they weren't confused.
13:59:00 <Mitar> http://hpaste.org/42986/type_error_take_2
13:59:04 <Mitar> this is more of the context
13:59:15 <qfr> jmcarthur: The former
13:59:18 <hpc> (Prelude..) can be written as (.), fmap, (<$>), (Category..), (<<<), (<=<), etc
13:59:19 <Mitar> edwardk
13:59:30 <copumpkin> hpc: not <=<
13:59:32 <jmcarthur> qfr: alright, then you see the point :)
13:59:33 <hpc> oh right
13:59:39 <copumpkin> although it's closely related
13:59:52 <edwardk> ok, now your data statement makes more sense given the context of the surrounding class
13:59:57 <hpc> copumpkin: indeed; i was thinking about it from http://faidio.visuallycreated.com:8000/blog/view.cgi?id=8
14:00:06 <hpc> which i wrote just a few days ago
14:00:13 <qfr> jmcarthur oh I thought what edwardk wrote was your line, sorry
14:00:22 <jmcarthur> ah
14:00:23 <qfr> But yeah the first one was shorter obviously
14:00:24 <edwardk> it wasn't clear that it was a class associated data family from the original past
14:00:24 <copumpkin> hpc: ah, cool
14:00:26 <jmcarthur> i kind of wondered
14:00:36 <jmcarthur> of course, shorter isn't necessarily better
14:00:39 <qfr> Just line a $ b c vs. a (b c)
14:00:43 <hpc> i thought the metaphor of Identity to (->) was very neat
14:00:44 <jmcarthur> but *i* prefer the former
14:00:48 <qfr> Same considerations, right?
14:00:51 <jmcarthur> sort of
14:01:01 <qfr> like*
14:01:01 <edwardk> deriving Data can't handle that one i think
14:01:04 <jmcarthur> ($) isn't actually shorter than using parens though
14:01:07 <Mitar> why not?
14:01:20 <jmcarthur> if you use whitespace sensibly at least
14:01:25 <hpc> Mitar: the paren you save is a space added
14:01:28 <j-invariant> I don't know much at all; To be honest
14:01:30 <edwardk> jmcarthur: but it is visually less taxing because you don't have to search for the pairing
14:01:52 <hpc> a . b $ c is least taxing
14:02:23 <edwardk> i'm kinda neutral on the leading .'s i know cale has a bug up his ass about how it leads to pipelining, etc. but i tend not to use it all the time ;)
14:03:08 <edwardk> implementationally it bothers me because its introducing an unnecessary eta-expansion that you're forcing the compiler to spot to handle it efficiently
14:03:18 <hpc> my only problem with (.) is that newbies take it to mean "deference and access"
14:03:28 <hpc> a la foo.getBar()
14:03:36 <edwardk> meh, they get over that fast if they want to write more than 2-3 lines of haskell ;)
14:03:47 <qfr> hpc wtf :/
14:04:00 <hpc> saw that sort of shit /thrice/ on stack overflow
14:04:03 <qfr> hpc oh but it is used to access sub modules
14:04:26 <qfr> Wait, is the . in Data.Vector actually the same (.)?
14:04:27 * hpc rarely gets to use "thrice" seriously, and enjoyed that opportunity
14:04:39 <hpc> :t (Data.Vector..)
14:04:40 <lambdabot> Couldn't find qualified module.
14:04:48 <ddarius> edwardk: I'm pretty sure the compiler always "spots" that case.  If you are using a compiler that fails to, then you don't care about performance anyway.
14:05:18 <hpc> i do not see (.) in vector
14:05:26 <edwardk> ddarius: well. its just another reduction to count against me when the compiler is deciding whether ot not to inline my function ;)
14:05:32 <djahandarie> hpc, he means in the module name
14:05:36 <qfr> hpc I am talking about the dot in Data.Vector
14:05:37 <djahandarie> And no of course, it's different
14:05:42 <qfr> It's not an operator is it? Right
14:05:44 <qfr> I thought as much
14:05:45 <hpc> i know, i don't see it in that module
14:05:59 <djahandarie> hpc, lol.
14:06:06 <hpc> http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html
14:06:06 <qfr> :/
14:06:09 <qfr> ...
14:06:10 <djahandarie> Reread what I said
14:06:12 <qfr> Seriously?
14:06:20 <hpc> oh fuck me
14:06:23 <edwardk> qfr: (.) is syntactically overloaded in haskell. there are two meanings. one is function composition, the other is used in hierarchical namespacing
14:06:23 <qfr> :D
14:06:23 <monochrom> > "." isInfixOf "Data.Vector"
14:06:24 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
14:06:24 <lambdabot>         against inferred type ...
14:06:30 <qfr> edwardk I see
14:06:31 <monochrom> > "." `isInfixOf` "Data.Vector"
14:06:32 <lambdabot>   True
14:06:48 <parcs> > '.' `elem` "Data.Vector"
14:06:49 <lambdabot>   True
14:07:02 <qfr> lol
14:08:32 <monochrom> haskell syntax and libs not conforming to other languages is good news to me. people need to see more diversity and presume less.
14:08:36 <qfr> I was just thinking about (.) Data Vector haha
14:08:49 <hpc> haskell syntax is lovely
14:08:59 <hpc> my only qualm is that spaces are not mandatory
14:09:04 <monochrom> the urban legend of "if you know one language, picking up another is easy" must be destroyed.
14:09:06 <qfr> But I thought that would ultimately come down to something like symbolic computation or something
14:09:12 <hpc> so you can do f$x
14:09:14 <qfr> A symbol type like in Lisp/Ruby
14:09:25 <aristid> hpc: why do you hate that?
14:09:48 <hpc> aristid: it is the root cause of the unary minus bug
14:09:51 <hpc> > (- 2)
14:09:52 <lambdabot>   -2
14:09:54 <ddarius> > f$x
14:09:55 <hpc> > -2
14:09:55 <lambdabot>   Ambiguous type variable `b' in the constraints:
14:09:55 <lambdabot>    `SimpleReflect.FromExpr ...
14:09:56 <lambdabot>   -2
14:10:06 <hpc> > (-2) 5
14:10:07 <lambdabot>   -2
14:10:10 <aristid> > subtract 2
14:10:12 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
14:10:12 <lambdabot>    arising from a use of `...
14:10:18 <aristid> :t subtract 2
14:10:20 <lambdabot> forall t. (Num t) => t -> t
14:10:52 <hpc> also, anyone who writes f$x should be cast out anyway
14:11:03 <monochrom> upcast or downcast? XD
14:11:15 <ddarius> reinterpret_cast
14:12:37 <hpc> ^^
14:12:50 <hpc> ddarius: people who use that can be cast out too :P
14:13:11 <j-invariant> :(
14:13:38 <olsner> just unsafeCoerce
14:14:18 <qfr> > let {micro x = True; oft x = True; rule = True} in micro$oft rule
14:14:19 <lambdabot>   True
14:14:26 <qfr> lambdabot agrees
14:14:47 <qfr> You can see, I am already an experienced Haskell hacker far beyond the hello world stage
14:14:55 <monochrom> > let {micro x = False; oft x = True; rules = True} in micro$oft rules
14:14:56 <kmc> monochrom, the legend is true because most people know Java and most languages are a slight rehash of Java concepts
14:14:56 <lambdabot>   False
14:15:06 <qfr> :[
14:15:38 <monochrom> actually the legend began in the days of fortran and c and pascal etc. and especially advocated by famous people back then.
14:15:48 <sleepynate> qfr: micro in mircosoft is definitely False
14:15:58 <ddarius> monochrom: Which of course are all slight rehashes of Java.
14:15:58 <qfr> Can you sneak in an ! there? somehow?
14:16:17 <qfr> ! is used by Data.Vector like !! is used for lists, right?
14:16:18 <hpc> micro$oft rules(!)
14:16:22 <hpc> > micro$oft rules(!)
14:16:23 <lambdabot>   Not in scope: `micro'Not in scope: `oft'Not in scope: `rules'
14:16:27 <hpc> pah
14:16:33 <qfr> Ah you can't use ! with partial application?
14:16:35 <monochrom> almost everyone I used to respect advocated it.
14:16:53 <hpc> :t (!)
14:16:54 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
14:16:55 <sleepynate> (what? 'that 'myth 'is #'baloney)
14:16:59 <qfr> Everybody advocated Java?
14:17:15 <qfr> sleepynate can't you use || to make it funnier?
14:17:36 <sleepynate> uh
14:17:37 <quuuux> > (>.<) (<.<)
14:17:39 <lambdabot>   "foobar"
14:17:45 <kmc> @quote mountain
14:17:45 <qfr> Isn't |Microsoft rule| just a symbol or something in CL?
14:17:45 <lambdabot> PaulGraham says: What's scary about Microsoft is that a company so big can develop software at all. They're like a mountain that can walk.
14:17:47 <qfr> I already forgot
14:17:57 <qfr> Paul Graham hates CL :(
14:18:02 <sleepynate> oh hah
14:18:12 <kmc> i thought he loved CL but loved Arc more
14:18:16 <hpc> quuuux: what
14:18:21 <kmc> if you don't take paul graham too seriously then he says some interesting things
14:18:22 <qfr> He hates CLOS and loop at least
14:18:26 <qfr> Which is the same as hating CL
14:18:40 <hpc> qfr: i like this guy already
14:18:41 <monochrom> I know companies bigger than microsoft that develop software just fine. ibm. at&t.
14:19:29 <sleepynate> qfr: |foo| is the equivalent of \f\o\o
14:19:39 <sleepynate> qfr: 'foo is the symbol, foo
14:21:21 <aristid> kmc: heck, even joel spolsky sometimes says interesting things
14:21:35 <qfr> I've been more successful at writing emacs Lisp than at writing Haskell
14:21:49 <monochrom> that's fine. it will pass.
14:22:23 <sleepynate> qfr: i am definitely better at lisp than haskell :/
14:22:32 <sleepynate> qfr: and i use vim! :O
14:22:38 <qfr> :o
14:23:13 <qfr> The biggest name in IT is HP, no?
14:23:25 <qfr> http://en.wikipedia.org/wiki/List_of_companies_by_revenue#List_of_companies_by_revenue
14:23:45 <ksf_> HP, you mean that ink manufacturer?
14:23:46 <qfr> What do they even code nowadays? Drivers for printers?
14:24:12 <groovy2shoes> They code crapware that's pre-installed on their machines.
14:24:38 <groovy2shoes> And calculator OS's.
14:24:39 * hackagebot satchmo 1.8.1 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-1.8.1 (JohannesWaldmann)
14:24:41 * hackagebot satchmo-backends 1.8.1 - driver for external satchmo backends  http://hackage.haskell.org/package/satchmo-backends-1.8.1 (JohannesWaldmann)
14:24:47 <qfr> Do they sell prebuilt x86s like Dell? I had no idea
14:25:10 <groovy2shoes> qfr: like Dell, but crappier.
14:25:38 <aristid> ksf_: ink is big business.
14:25:39 * hackagebot satchmo-examples 1.8.1 - examples that show how to use satchmo  http://hackage.haskell.org/package/satchmo-examples-1.8.1 (JohannesWaldmann)
14:26:34 <edwardk> lots of sat activity this week
14:26:57 <ivanm> edwardk: some conference paper submission deadline coming up?
14:26:59 <Mitar> deadline is closing in ;-)
14:27:01 <copumpkin> they should've waited for saturday
14:27:24 <sleepynate> qfr: fwiw: http://hpaste.org/42988/lisp_pipes
14:27:28 <mreh> can I use template haskell to automatically generate instances?
14:27:30 <edwardk> i'm somewhat disconnected from the publish or perish lifecycle ;)
14:27:35 <edwardk> mreh: yes
14:27:39 <mreh> I don't want to use undecidable stuff
14:27:45 <mreh> cooooool
14:28:12 <edwardk> its a fairly common idiom to define a function for use as a splice like deriveFoo [''Bar, ''Baz]
14:28:27 <kmc> using template haskell makes termination of your compiler undecidable, trivially
14:28:34 <ivanm> I did a fair amount for restricted typeclasses, before I got sick of it
14:28:41 <kmc> i don't see why that's preferable to UndecidableInstances.  i don't see either as a problem
14:29:13 <mreh> kmc: doesn't undecidable instances have a habit of biting you in the ass later
14:29:22 <edwardk> i mostly use undecidableinstances because they are at least nominally portable, while TH weds me very closely to GHC
14:29:31 <edwardk> mreh: depends on the instance.
14:29:33 <kmc> mreh, not in my experience; where'd you see / hear / run into this?
14:29:41 <mreh> kmc: poking about on the wiki
14:29:57 <kmc> undecidableinstances by itself isn't a big deal, if your compiler dies with an instance stack overflow, then you go hunt down the bad instance
14:29:59 <mreh> I want to derive something from Show, I'm just typing up a monadic pretty print, because it's easy to do
14:30:01 <edwardk> instance (Show (f (Foo a)), Show a) => Show (Foo a) — for instance is undecidable but sound
14:30:48 <kmc> ghc's instance termination checker is a simple, conservative heuristic.  it's not like you're disabling a fundamental logically-required check
14:30:50 <qfr> sleepynate I see that it took you a stunning 24 REPL lines to figure it all out
14:31:31 <edwardk> undecidable can still be decided in many cases, it just means that the compiler doesn't know how to check it for termination, since the contents don't strictly-monotonically decrease in size
14:31:34 <mreh> ghc has a limite on it's stack
14:31:35 <qfr> I don't even know what princ does btw
14:31:36 <edwardk> er contexts
14:31:42 --- mode: ChanServ set +o copumpkin
14:31:52 --- mode: copumpkin set -b *!*@quark.teteny.elte.hu
14:32:05 <edwardk> mreh: sure, but i can spin for a long time within 20 frames ;)
14:32:32 <Ke> banning an entire host on elte seems a bit silly
14:32:40 --- mode: copumpkin set -o copumpkin
14:32:47 <mreh> okay, well I was enabling alot of language features, started to scare the willies out of me
14:32:59 <copumpkin>  /ban *!*@*.com
14:33:12 <mreh> thing is though, isn't it potentially a viral language switch
14:33:36 <edwardk> mreh: UndecidableInstances almost always brings with it FlexibleInstances/FlexibleContexts — MPTCs and Fundeps tend to drag them them the former as well
14:33:40 * hackagebot fuzzytime 0.2 - Print current time in a more casual way  http://hackage.haskell.org/package/fuzzytime-0.2 (KamilStachowski)
14:34:01 <ddarius> FlexibleInstances/Contexts aren't too bad.
14:34:19 <edwardk> yeah
14:34:25 <sleepynate> qfr: cute. actually i had break issues :/
14:34:39 <ivanm> ooohhh, fuzzytime looks cool
14:34:40 <ddarius> Maybe they'll go crazy with 2012 and add them.
14:34:46 <mreh> is deriving pretty print instances from show a nice idea?
14:35:00 <mreh> means you get a nice derived instance unless you define your own
14:35:04 <edwardk> mreh: generally not, Show is intended for source representation
14:35:05 <ivanm> wait, it's just a program, not a library? :/
14:35:23 <ivanm> yeah, use a pretty-printing library
14:35:33 <mreh> I'm writing one
14:35:33 * ivanm should polish up and publish wl-pprint-text
14:35:35 <edwardk> mreh: its usually not such a high tax to make a Pretty class with the same signature and use that you can go ahead and use the syntax or use one of the pretty printing combinator sets
14:35:46 <ivanm> mreh: why do you need yet another pretty-printing library?
14:35:47 * ddarius should go play in the snow.
14:36:01 <stepcut> found a horrible way to have global state with out using unsafePerformIO and IORef, http://hpaste.org/42990/global_counter_with_out_ioref :p
14:36:01 * ivanm should go bucket some water
14:36:07 <mreh> ivanm: I find hughespj too bloated
14:36:14 <ivanm> mreh: wl-pprint ?
14:36:16 <ivanm> boxes?
14:36:17 <ivanm> etc.
14:36:18 <edwardk> i find that current pretty printing libraries suck at dealing with layout rules and parentheses, etc.
14:36:22 <mreh> never heard of them
14:36:31 <mreh> are they good?
14:36:34 <ivanm> though how hughespj is bloated when it's the smallest/most boring of them all...
14:36:35 <monochrom> stepcut: you should also try using posix signals some day :)
14:36:41 <ivanm> edwardk: true
14:36:42 <edwardk> having something that dealt with stuff like operator precedence in the library would be pretty sweet
14:36:45 <stepcut> monochrom: ooo
14:37:03 <ivanm> for code output they're not necessarily the best
14:37:05 <monochrom> hahaha another monster is born!
14:37:07 <mreh> hughspj operators associate the wrong way
14:37:16 <ivanm> mreh: how so?
14:37:20 <edwardk> in that sense i tend to find myself implementing something like Show style pipelining on top of the HughesPJ combinators or some other combinator set when i need a pretty printer
14:37:47 <edwardk> mreh: ISTR from the original paper there was an asymptotic justification for the associativity
14:37:47 <mreh> ($$) associates in an inconvenient way
14:37:54 <mreh> okay
14:38:32 <edwardk> http://hackage.haskell.org/packages/archive/pretty/1.0.1.0/doc/html/src/Text-PrettyPrint-HughesPJ.html talks a bit about performance issues at the top
14:38:43 <rumbold> i got a word8. how do i divide it by 255, resulting in a float from between 0 and 1?
14:38:51 <mreh> I found the monadic approach really intuitive, and easy to pick up
14:39:03 <ivanm> mreh: monadic approach to what?
14:39:09 <mreh> pretty printing
14:39:09 <edwardk> > fromIntegral (8 :: Word8) / 255
14:39:10 <lambdabot>   3.137254901960784e-2
14:39:27 <ivanm> mreh: where's that? don't think I've seen a monadic pretty-printer...
14:39:28 <mreh> hughspj is more algebraic no?
14:39:44 <ivanm> edwardk: grrr... just as I was about to hit enter...
14:39:44 <ivanm> :p
14:39:47 <edwardk> mreh: you can do a nice job with an applicative combinator set.
14:40:07 <mreh> but the do syntax makes it really nice!
14:40:45 <edwardk> yes, so do foo *> bar <* baz etc.  =)
14:41:24 <edwardk> and since you are more context-oblivious you can share more computation in the portions that are done applicatively
14:41:38 <ivanm> well, I've got a monadic wrapper for pretty-printing for wl-pprint-text, but that's more so that I can use it within a state monad...
14:41:39 <rumbold> i have (fromIntegral c) / 255 (i added the parentheses later just to test ;) im getting "no instance for (fractional word8)"
14:41:53 <Pseudonym> ivanm: Considered a writer monad instead?
14:41:53 <ivanm> not quite sure what edwardk's "foo *> bar <* baz" example is supposed to print though :/
14:41:58 <edwardk> rumbold: somewhere you are using the result as a word
14:42:09 <mreh> :t (*>)
14:42:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
14:42:20 <ivanm> mreh: yeah, but how does that relate to pretty-printing?
14:42:36 <mreh> ivanm: I'm trying to figure it out :)
14:42:41 <Pseudonym> People don't use writer monads enough.
14:42:44 <ivanm> heh
14:42:54 <edwardk> ivanm: you put together combinators such that as you go left to right through the applicative grammar you are emitting text output. foo *> bar <* baz — will return the result of bar, but have the side effects of foo and baz as well, ordered such that foo happens before bar happens before baz
14:42:59 <ivanm> Pseudonym: you want to promote the gratuitous usage of writer monads, do you? :p
14:43:24 <Pseudonym> No, the _appropriate_ use of writer monads would be sufficient.
14:43:27 <edwardk> ivnam: so if you use some kind of 'showFoo combinator in foo, the *> just ignores the () answer it probably gives
14:43:31 <ivanm> edwardk: so do the pretty-print outputs of foo and baz occur as well?
14:43:39 <edwardk> yes
14:43:47 <Pseudonym> Though maybe Writer would be better as a comonad.
14:43:57 <edwardk> but they don't affect the context/shape of computation, just the output.
14:43:58 <mreh> what would the context of this Applicative pretty printer be?
14:44:36 <qfr> "He used to be a productive and cheerful member of society. Then he discovered Haskell."
14:44:48 <mreh> qfr: hello
14:45:05 <edwardk> same as your monad. all i'm saying is that ap can combine in strictly more ways than (>>=) because there are more applicatives than monads ;) so the applicative can do things like count characters, and reason about the result of sub-expressions in isolation without having to 'start over' whenever it tries a different option
14:45:15 <qfr> mreh: Hello
14:45:25 <mreh> qfr: I assume you are talking about me
14:45:48 <mreh> edwardk, I had thought about static analysis
14:45:49 <qfr> mreh: Was I? I could not say with any certainty
14:45:59 <mreh> qfr: just kidding
14:46:26 <edwardk> this gives you additional memoization opportunities, for instance, if you have only nested layout rules, you can track the nesting structure and how many have to be broken to get a nice layout, and memoize packrat-style with the context and stack
14:47:51 <edwardk> for instance i wouldn't want to do knuth style paragraph formatting with a paragraph defined word-by-word in a monad, but i might consider it in an applicative ;)
14:48:17 <mreh> hmm, I might sleep on that
14:48:23 <copumpkin> if I were galois, I'd call my VPN server connection.galois.com
14:48:34 <edwardk> copumpkin: ahahah
14:48:49 <monochrom> hahahaha
14:48:57 <ivanm> copumpkin: how could you be a company? :p
14:49:08 <copumpkin> ivanm: I'm very large
14:49:15 <mreh> edwardk: why would I define it word by work?
14:49:18 <monochrom> by being hypothetical
14:49:22 <mreh> word by word
14:49:26 <qfr> <copumpkin> if I were galois, I'd call my VPN server connection.galois.com
14:49:30 <qfr> Somebody explain please
14:49:40 <ddarius> qfr: You'll figure it out some day.
14:49:47 <monochrom> look for "galois connection" in math, specifically lattice theory
14:49:47 <edwardk> qfr:  there is a structure in mathematics called a Galois connection
14:49:52 <ivanm> @google galois connection
14:49:53 <lambdabot> http://en.wikipedia.org/wiki/Galois_connection
14:49:54 <lambdabot> Title: Galois connection - Wikipedia, the free encyclopedia
14:50:00 <qfr> Oh, don't know it
14:50:01 <Botje> damn. out-lambdabotted.
14:50:03 <edwardk> amusingly they have to do with functors, but lets just leave that bit off for a while ;)
14:50:05 <qfr> At least I know the name
14:50:22 <ddarius> edwardk: Galois didn't know (or care about) that.
14:50:29 <monochrom> galois connection is a simple special case of adjunction
14:50:31 <edwardk> ddarius: very true
14:50:50 <alpounet> it just uses an approach from Galois theory 
14:51:00 <edwardk> he was too busy getting his ass shot off in a duel to care about it ;)
14:51:07 <ddarius> Heck, most of what we call "Galois theory" was only suggested or illustrated by Galois.
14:51:12 <mreh> wasn't that cardano?
14:51:18 <mreh> he wasn't another gambler
14:51:23 <mreh> was he?
14:51:33 <alpounet> ddarius, yeah
14:51:37 <ddarius> Galois wasn't a gambler.
14:51:56 <alpounet> but his original approach (at the time) definitely is the key point of the theory
14:52:11 <edwardk> nah, galois's duel was something about a girl
14:52:17 <ddarius> and politics.
14:52:22 <Pseudonym> But it was partly motivated by politics, yeah.
14:52:28 <Pseudonym> Basically, he was a hot-headed kid.
14:52:33 <Pseudonym> Who happened to be brilliant.
14:52:48 <j-invariant> no mathematician ever cared about his work
14:52:55 <Philippa> see? Arguments on the internet do something useful
14:53:00 <monochrom> http://spikedmath.com/245.html
14:53:07 <Philippa> they stop hot-headed genius kids actually getting themselves killed
14:53:20 <ddarius> Philippa: Or being productive.
14:53:52 <mreh> how does one get a career in maths?
14:54:01 <edwardk> i usually lose my killing rage from IRC before i get a chance to meet a person in person ;)
14:54:05 <j-invariant> What is the point in mathematics?
14:54:23 <j-invariant> I didn't understand why we prove theorems (for example)_
14:54:35 <qfr> j-invariant  you use Haskell and ask that question?
14:54:45 <alpounet> are you kidding us j-invariant ?
14:54:47 <monochrom> do you mean "what is a point in mathematics"?
14:54:57 <edwardk> j-invariant is a very advanced troll ;)
14:54:57 <qfr> j-invariant it's a sophisticated form of intellectual masturbation, j-invariant
14:55:01 <j-invariant> no I wish I could really ask this question I have wondered about it for years btw I am a mathematician
14:55:10 <qfr> Urgh minus one nick*
14:55:28 <j-invariant> I don't t hink anyone knows the answer for it
14:55:30 <qfr> It's the one true science
14:55:31 <monochrom> at least a point is much simpler than a monad.
14:55:34 <j-invariant> maybe it's "because of Gauss"
14:55:43 <j-invariant> That's the most plausable answer I have come up with
14:56:24 <monochrom> a lot of your musings could go to #haskell-blah, you know
14:56:54 <ddarius> edwardk: I can hold grudges indefinitely.  There was a kid name Brian Elliott in pre-school that I have a grudge against.
14:57:08 <qfr> snap <- $(loadSnapTH 'applicationInitializer 'site) --what do the quotes do in this case? They remind me of Lisp
14:57:34 <edwardk> qfr: that is a template haskell splice
14:57:35 <mreh> > let 'hello = "hello" in 'hello
14:57:36 <lambdabot>   <no location info>:
14:57:36 <lambdabot>      lexical error in string/character literal at chara...
14:57:40 <qfr> Urgh :|
14:57:50 <Pseudonym> Give j-invariant a coin.
14:57:58 <qfr> I'm not even past the hello world stage and I'm already dealing with Template Haskell in Snap :(
14:58:00 <edwardk> qfr: what its doing is generating code at compile time, like macro expansion
14:58:01 <centrinia> ddarius, holding grudges is not healthy.
14:58:06 <qfr> Ahhh
14:58:30 <ddarius> centrinia: That's why you have to resolve them.  Then it's only unhealthy for the people you hold grudges against.
14:58:41 <edwardk> qfr: the result of loadSnapTH … is a big expression in the template haskell 'Q' monad, which then gets spliced in place of that $(…)
14:59:27 <ddarius> qfr: Haven't you ever used Lisp?  Or at least been within hearing distance of someone who has?
14:59:31 <ivanm> @quote offtopic
14:59:31 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
14:59:38 <ivanm> dammit, that's not the one I meant
14:59:41 <ivanm> @quote gwern offtopic
14:59:41 <lambdabot> gwern says: #haskell: because none of us are as offtopic as all of us
14:59:48 <edwardk> heh
14:59:49 <qfr> ddarius: I've used Common Lisp and I was about to draw a comparison to CL's compile time stuff
15:00:00 <qfr> (which I have never intentionally used btw, I know very little Lisp)
15:00:19 <edwardk> qfr: TH is just a macro expansion facility. the difference from the lisps/schemes of the world is that it is strongly typed.
15:00:36 <edwardk> which many think makes it hard to use
15:00:56 <edwardk> but it can accomplish some rather impressive feats
15:01:36 <edwardk> qfr: an example of some rather sexy TH-based code is http://hackage.haskell.org/packages/archive/jmacro/0.3.2/doc/html/Language-Javascript-JMacro.html
15:01:46 <ivanm> I just find it annoying that I have to define functions I use in splices in a different module than where I use the splice (though I understand why)
15:01:55 <edwardk> which parses and _typechecks_ javascript fragments at compile time
15:02:04 <j-invariant> Pseudonym: it was a real question :(
15:02:19 <qfr> edwardk: I doubt I have any chance of grasping that at this stage
15:03:15 <Pseudonym> j-invariant: You didn't get the reference?
15:03:18 <ivanm> edwardk: :o
15:03:21 <j-invariant> no
15:03:24 <j-invariant> yes
15:03:28 * Pseudonym thought most mathematicians would
15:03:32 <qfr> edwardk: It type checks JavaScript? Hahaha
15:03:36 <monochrom> TH is harder to use than lisp macros. But it is compensated for: you need TH less than you need lisp macros. Look at "forever m = m >> forever m". Ordinary code in haskell, macro in lisp.
15:03:38 <qfr> That is... baffling.
15:03:38 <j-invariant> Pseudonym: oh right, Euclid
15:03:41 <Pseudonym> Right.
15:03:52 <ivanm> Pseudonym: what's the actual reference?
15:04:16 <edwardk> monochrom: yeah ubiquitous laziness reduces the pressure on macro facilities greatly
15:04:29 <Pseudonym> ivanm: According to Proclus, a student came to Euclid and asked him "so how can I make money off this geometry thing?"  Euclid turned to his assistant and said "give that man a coin, for he has to make a profit off everything".
15:04:49 <edwardk> the main thing i pine for is something in the middle though, e.g. scheme's syntax-rules
15:04:55 <qfr> Pseudonym haha
15:04:56 <ddarius> edwardk: Implement it.
15:05:11 <ivanm> Pseudonym: heh
15:05:18 <monochrom> (fictional statistics) 70% of lisp macros are just for laziness.
15:05:28 <ivanm> ddarius: what, with all the other things edwardk is apparently going to implement some day? :p
15:05:37 <ddarius> ivanm: Yes.
15:05:38 <sproingie> @quote euclid
15:05:38 <lambdabot> byorgey says: "There is no royal road to Haskell." -- Euclid
15:05:44 <ivanm> monochrom: isn't the "fictional" redundant? :p
15:05:49 <edwardk> ivanm: i never wanted to implement the graph library. YOU wanted me to implement the graph library ;)
15:06:01 <ddarius> (factual statistic) 100% of factual statistics are false.
15:06:04 <sproingie> hm.  i can't remember how to use @remember
15:06:13 <sproingie> (ironic isnt it?)
15:06:14 <ivanm> edwardk: I meant more the splitting up of categories, etc.
15:06:21 <edwardk> @remember sproingie hm.  i can't remember how to use @remember
15:06:21 <lambdabot> It is stored.
15:06:29 <ivanm> and I seem to recall saying that you planned on implementing it...
15:06:30 <aristid> edwardk: damn you beat me
15:06:33 <edwardk> @quote sproingie
15:06:33 <lambdabot> sproingie says: if it makes Cale's brane asplode, i think there's no hope for me understanding it
15:06:46 <edwardk> @quote @remember
15:06:46 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
15:06:54 <aristid> oO
15:07:03 <sproingie> i broked it
15:07:04 <aristid> @quote remember
15:07:05 <lambdabot> remember says: the 5th of november
15:07:16 <aristid> @quote use.*remember
15:07:17 <lambdabot> sproingie says: hm.  i can't remember how to use @remember
15:07:22 <aristid> there we go
15:07:45 <edwardk> ah its interpreting the @ in some fashion
15:08:23 <sproingie> @. @chef @quote use.*remember
15:08:23 <lambdabot> Plugin `compose' failed with: Unknown command: "@chef"
15:08:51 <sproingie> @. @leet @quote use.*remember
15:08:52 <lambdabot> Plugin `compose' failed with: Unknown command: "@leet"
15:08:59 <sproingie> bah
15:09:04 <ddarius> edwardk: You and your faith in lambdabot's rationality.  "There's a reason(!) for this failure."
15:09:24 <edwardk> ddarius: sure there is a reason… usually in the form of a bug ;)
15:09:30 <djahandarie> @. elite nixon
15:09:30 <lambdabot> +|-|eY're no7 |Ixe U5. ThEY zm31L dIFpheREn+, T|-|ey 10oK DiFFerEnt, +|-|Ey aC+ dIfpheren+. +hE +ROu8Le I$, Y0U can't fInD on3 +|-|4T'S hONe5t.
15:09:40 <ddarius> edwardk: More likely the bubble gum came a bit loose.
15:09:46 <edwardk> @. elite quote use.*remember
15:09:46 <lambdabot> zPr0InGI3 z4y5: HM.  I can't reME/\/\BEr ho\/\/ +o U$3 @REMEMB3r
15:10:09 <kmc> @. elite ghc
15:10:10 <lambdabot> gHc SaYS: its maIn PURpO$e IS TO 3nCAp5U|4tE Th3 |-|oRri813 Sta+E |-|ACx
15:10:36 <djahandarie> Haha
15:10:53 <ddarius> @. elite src map
15:10:53 <lambdabot> Say again?
15:10:58 <sproingie> @. elite vixen
15:10:59 <lambdabot> yOu Ar3 zo0Oo iN7eRESTIN9
15:10:59 <qfr> What state hack?
15:11:14 <sproingie> @. elite elite elite vixen
15:11:14 <lambdabot> 1337 vix3n
15:11:16 * ddarius will leave that riddle for those foolish enough to explore it.
15:11:54 <ddarius> sproingie: @. is binary just like (.)
15:12:15 <edwardk> qfr: the IO monad is implemented in the form of passing around the real world as an value. so an "IO a" looks like State# RealWorld -> (a, State# RealWorld) 
15:12:25 <edwardk> its a function that takes the real world, and gives you back a value, and a new real world
15:12:26 <ddarius> @src IO
15:12:26 <lambdabot> Source not found. Maybe you made a typo?
15:12:36 <edwardk> (there is a little more unboxing going on)
15:12:40 <ddarius> I guess Cale cleaned the @src file.
15:12:51 <sproingie> @elite
15:12:51 <lambdabot> Say again?
15:12:53 <qfr> edwardk I've seen this State# business before today, what's that all about?
15:12:56 <sproingie> @. elite elite
15:12:57 <lambdabot> s4y 4g4IN?
15:13:04 <monochrom> newtype IO = IO (RWH -> (a, RWH))
15:13:10 <ddarius> qfr: It's nothing.
15:13:11 <tolkad> Since I updated to ghc 7 on Mac 10.6, the linker has been failing when I use ghc
15:13:18 <kmc> qfr, it's a very low-level detail of how GHC implements the IO type
15:13:25 <edwardk> io actions compose by plumbing the real world through to subsequent actions, and you don't see the real world because its encapsulated behind an API that keeps you from trying to copy the real world, etc.
15:13:25 <qfr> I see, so it's ghc specific anyways
15:13:30 <qfr> And should not be shown to me
15:13:31 <edwardk> qfr: yes
15:13:34 <kmc> right, it has nothing to do with what IO means to the user
15:13:37 <qfr> Otherwise I'll just get cancer
15:13:41 <edwardk> exactly
15:13:47 <tolkad> "Undefined symbols: "_kevent64","_fopen$DARWIN_EXTSN"
15:13:49 <monochrom> at least you don't go bind
15:13:52 <djahandarie> unsafePerformCancer
15:13:54 <tolkad> how do I fix that?
15:13:55 <kmc> in the Haskell Report, IO is an abstract type
15:14:10 <qfr> Distinct from regular monads?
15:14:21 <kmc> IO is a very unusual monad, yes
15:14:28 <edwardk> IO could be equally well implemented with a data type that had one constructor for every possible function, and an external evaluator that looked at the constructor did something with it, and computed the next argument to evaluate
15:14:29 <kmc> but monads don't have that much in common
15:14:32 <qfr> Today I learned that IO can only be at the bottom of a stack of monads
15:14:39 <qfr> And not in the middle like say Maybe
15:14:40 <edwardk> the realworld hack just avoids building all this misc. data
15:14:43 <kmc> it's just a generic API; the implementations of that API can be totally different
15:14:48 <monochrom> not sure what is "distinct". some monads you can write yourself, some monads you can't, like IO.
15:15:09 <kmc> in particular some monads (Maybe, []) have simple-to-used exposed constructors ("concrete type") and others don't expose constructors ("abstract type")
15:15:13 <monochrom> but that's actually just like saying you can't define Char yourself.
15:15:25 <edwardk> monochrom: i have a reimplementation of IO lying around as a right kan extension ;)
15:15:25 <kmc> for manipulating an abstract type, you can only use the functions provided to you
15:15:26 <qfr> So you can't use it in monadic transformations like Either and Maybe and such
15:15:31 <kmc> for IO that's things like putChar, (>>=), return
15:15:39 <djahandarie> It'd be nice to be able to implement the IO monad by yourself without importing GHC stuff
15:15:52 <kmc> djahandarie, you can do it -- you just have GHC's IO monad buried within your IO monad
15:15:56 <edwardk> its just Codensity ((->) State# RealWorld)
15:16:16 <djahandarie> edwardk, how does that perform?
15:16:43 <edwardk> forall r. (a -> State# RealWorld -> r) -> State# RealWorld -> r
15:16:51 <edwardk> comparably
15:17:06 <tolkad> qfr: In haskell a Monad is just a type of kind * -> * with a Monad instance that obeys the monad laws. all monads can be used with the do-notation syntatic sugar that transforms do {x <- a; y <- b; c; d…} to (a >>= (\x -> b >>= (\y -> ((c >> d) >> …))))
15:17:13 <edwardk> it loses a ittle bit because it doesn't have that stg_ap_v_fast hack in place for its type
15:17:28 <qfr> tolkad yeah I've already seen that stuff today
15:17:46 <tolkad> err wait got that wrong
15:17:48 <qfr> mightybyte from #snapframework had me convert do notation to binds and that >> thing which I don't even know the name for
15:18:08 <qfr> Took me quite a while heh
15:18:12 <edwardk> @undo do x <- foo; y <- bar; z <- baz; return (quux quaffle x y z)
15:18:13 <lambdabot> foo >>= \ x -> bar >>= \ y -> baz >>= \ z -> return (quux quaffle x y z)
15:18:23 <ddarius> (>>) is usually read "then"
15:18:25 <monochrom> the name of >> is >>
15:18:29 <qfr> >>= is the bind operator, right?
15:18:33 <monochrom> @quote monochrom modem
15:18:34 <lambdabot> No quotes match.
15:18:37 <edwardk> qfr: yeha
15:18:37 <qfr> Very well then >> is then
15:18:40 <monochrom> @quote <monochrom> modem
15:18:41 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
15:18:45 <kmc> Haskell users are sparsely distributed => Haskell users mostly talk on IRC => pronounceable names are unnecessary
15:18:54 <kmc> i hear at Galois they call (<$>) "money" and (<*>) "splat"
15:19:01 <djahandarie> lol
15:19:02 <qfr> kmc haha
15:19:11 <qfr> What do they call (!!)?
15:19:14 <qfr> "DUDE"
15:19:19 <mauke> double-bang, I hope
15:19:21 <edwardk> i just read then as 'map' and 'ap'
15:19:21 <ddarius> They probably don't use (!!)
15:19:27 <tolkad> by default, « x >> y = x >>= (\_ -> y)
15:19:32 <edwardk> nicely alliterative
15:19:45 <ion> qfr: Just shout out (!!)’s second argument very loudly, the (!!) is silent.
15:19:52 <qfr> Hahahahaha
15:19:54 <qfr> Nice one
15:19:55 <edwardk> hahhahaa
15:20:00 <Rotaerk> I prefer "bang! bang!"
15:20:03 <qfr> Wait, shouldn't it be the first one?
15:20:03 <EvanR-work> @src sum
15:20:04 <lambdabot> sum = foldl (+) 0
15:20:14 <tolkad> so anyway, why is ld failing when I try to compile anything?
15:20:17 <tolkad> "Undefined symbols: "_kevent64","_fopen$DARWIN_EXTSN"
15:20:44 <tolkad> it also says ld: warning: -read_only_relocs cannot be used with x86_64
15:20:46 <aristid> tolkad: probably because the symbols are undefined
15:21:03 <aristid> tolkad: doesn't GHC on OSX only support x86?
15:21:26 <qfr> Ouch.
15:21:29 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/34653/focus=34692
15:21:31 <tolkad> I don't know, I'm not giving it any special options
15:21:45 <tolkad> it should compile with whatever it can automatically
15:21:51 <benmachine> are there convenient ways to use QuickCheck to generate, say, a uniform distribution of integers between 1 and n that aren't either p or q
15:22:01 <benmachine> oh wait, there is choose for this
15:22:02 * benmachine silly
15:22:28 <ddarius> benmachine: You can just guard against those.
15:22:49 <ddarius> (n /= p && n /= q) ==> ...
15:22:53 <tolkad> monochrom: Why would you need to say it as a word within your mind? when you are saying a sentence within your head it's fine to use concepts in place of words
15:23:07 <benmachine> ddarius: right, but I want an arbitrary that doesn't produce them in the first place
15:23:19 <monochrom> exactly what I said
15:23:36 <benmachine> it's fine I can just guard inside the thingy
15:25:25 <aristid> @hoogle choose
15:25:26 <lambdabot> Test.QuickCheck choose :: Random a => (a, a) -> Gen a
15:27:00 <tolkad> I don't know what to do about ghc failing when linking : (
15:27:17 <Zao> tolkad: Throw more make or package flags at it?
15:28:02 <monochrom> Undefined symbols: "_kevent64" etc. Seems to be 32 vs 64 problems. mac-specific.
15:28:36 <monadic_kid> do you guys think this is a good use of continuations? http://hpaste.org/42991/good_use_of_continuations
15:28:39 <Zao> OH joy.
15:29:05 <monadic_kid> I didn't fancy writing a findM/A and this code seems quite elegant and readable to me
15:30:30 <monochrom> I think it's fine.
15:31:11 <jmcarthur> :t \f g -> fmap . (,) . f <*> g   -- This seems to be a somewhat common pattern for me. Has anybody else seen it defined anywhere, or something similar to it?
15:31:12 <lambdabot> forall a (f :: * -> *) a1 (f1 :: * -> *). (Functor f, Applicative f1) => f1 a1 -> f1 (f a) -> f1 (f (a1, a))
15:31:22 <jmcarthur> stupid caleskell
15:31:32 <monochrom> on hackage there is some "AbortT" if you're interested. but nothing really new, you can almost guess how it is implemented.
15:31:38 <jmcarthur> (Functor f) => (a -> b) -> (a -> f b1) -> a -> f (b, b1)
15:32:45 <ddarius> monadic_kid: Why didn't you just have runCont' be flip runCont return ?
15:32:52 <ddarius> +Ts
15:32:57 <monochrom> oh heh
15:33:03 <monadic_kid> good point
15:34:30 <benmachine> monadic_kid: I think it is because it says so in the URL and I'm gullible
15:34:45 <monadic_kid> benmachine: ?
15:34:58 <benmachine> oh there's a question mark, never mind
15:38:14 <tolkad> ok why is cabal using -fPIC and how do I turn it off?
15:38:48 <Zao> tolkad: Have you've skimmed the cvs-ghc and glasgow-haskell-users lists, and the GHC trac?
15:38:53 <Zao> It might be a known problem.
15:40:03 <monochrom> I don't suppose -fPIC is harmful
15:40:09 <tolkad> Zao: I googled various parts of the error message and couldn't find anything
15:40:20 <aristid> :t \f g -> fmap Prelude.. (,) Prelude.. f <*> g
15:40:22 <lambdabot> forall (f :: * -> *) b b1 a. (Functor f) => (a -> b) -> (a -> f b1) -> a -> f (b, b1)
15:40:30 <tolkad> monochrom: yeah but it wont let me use any other compilation option instead
15:40:40 <tolkad> monochrom: like -fvia-c
15:41:09 <EvanR-work> > cake
15:41:11 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
15:41:18 <EvanR-work> > length cake
15:41:20 <lambdabot>   42
15:41:48 <tolkad> > "a\nb"
15:41:49 <lambdabot>   "a\nb"
15:41:54 <EvanR-work> > last cake
15:41:56 <lambdabot>   "That will deodorize and preserve putrid tissue."
15:42:09 <Bynbo7> > drop 32 . map head $ cake
15:42:10 <lambdabot>   "OTASCIICAT"
15:42:19 <Bynbo7> > drop 36 . map head $ cake
15:42:21 <lambdabot>   "CIICAT"
15:42:23 <Bynbo7> > drop 26 . map head $ cake
15:42:25 <lambdabot>   "TTOOTOOTASCIICAT"
15:42:47 <Bynbo7> >  map head $ cake
15:42:49 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
15:43:13 <tolkad> :t transpose
15:43:14 <lambdabot> forall a. [[a]] -> [[a]]
15:43:20 <tolkad> > transpose cake
15:43:22 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
15:44:02 <tolkad> > (transpose cake) !! 1
15:44:04 <lambdabot>   "nnhonhnwoiiiiiuianlniniwnnwwnnhnnwdlonnrnh"
15:44:07 <tolkad> > (transpose cake) !! 2
15:44:09 <lambdabot>   "eeruereonssssslsnepsbdnee ooeereeojarjjada"
15:44:14 <tolkad> > last (transpose cake)
15:44:16 <lambdabot>   "."
15:44:29 <luite> ooh there must be hidden messages
15:44:31 <tolkad> > transpose (transpose cake)
15:44:34 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.shaped sediment.ts, and gas an...
15:44:55 <Bynbo7> lambdabot: there is, it's TOOT TOOT ASCII CAT!
15:45:00 <aristid_> > map length cake
15:45:02 <lambdabot>   [43,40,35,16,35,42,40,27,31,21,20,24,17,25,23,59,52,20,13,28,26,38,21,37,25...
15:45:11 <aristid_> > sort $ map length cake
15:45:13 <lambdabot>   [13,13,16,17,18,20,20,20,21,21,23,23,24,25,25,25,26,27,28,30,31,34,35,35,35...
15:45:26 <_mpu> > cake
15:45:28 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
15:45:31 <aristid_> > map head . group . sort $ map length cake
15:45:33 <lambdabot>   [13,16,17,18,20,21,23,24,25,26,27,28,30,31,34,35,36,37,38,40,42,43,47,52,59...
15:45:36 <waterlaz> > drop 10 cake
15:45:38 <lambdabot>   ["Fish shaped candies.","Fish shaped solid waste.","Fish shaped dirt.","Fis...
15:45:44 <waterlaz> > drop 100 cake
15:45:46 <lambdabot>   []
15:45:50 <waterlaz> > drop 40 cake
15:45:52 <lambdabot>   ["And it contains proven preservatives, deep penetration agents, and gas an...
15:45:53 <tolkad> > toString (empty :: ByteString)
15:45:54 <lambdabot>   Not in scope: `toString'Not in scope: type constructor or class `ByteString...
15:46:00 <waterlaz> > drop 60 cake
15:46:02 <lambdabot>   []
15:46:05 <waterlaz> > drop 50 cake
15:46:06 <lambdabot>   []
15:46:10 <_mpu> > length cake
15:46:10 <waterlaz> > drop 45 cake
15:46:12 <Bynbo7> waterlaz: it's 42 lines long
15:46:12 <lambdabot>   42
15:46:12 <lambdabot>   []
15:46:16 <waterlaz> oh
15:46:25 <tolkad> > Data.ByteString.empty
15:46:26 <lambdabot>   Not in scope: `Data.ByteString.empty'
15:46:31 <waterlaz> anyway
15:46:37 <monochrom> you would think "length cake" is faster than binary search over "drop n cake"
15:47:03 <waterlaz> yeah, better go to sleep I guess
15:47:06 <tolkad> > map words cake
15:47:08 <lambdabot>   [["One","18.25","ounce","package","chocolate","cake","mix."],["One","can","...
15:47:09 <hpc> monochrom: that wasn't even binary
15:47:14 <djahandarie> No, length is linear, binary search is log n
15:47:19 <EvanR-work> lol
15:47:20 <tolkad> > transpose (map words cake)
15:47:22 <lambdabot>   [["One","One","Three","Four","One","Three","One","Two","Don't","Fish","Fish...
15:47:31 <monochrom> binary search over "drop n cake" is n log n.
15:47:33 <hpc> djahandarie++
15:47:48 <Bynbo7> another hidden message!
15:48:02 <hpc> @oeis 1 1 3 4 1 3 1 2
15:48:05 <lambdabot>  A026741(n)/A051712(n+1).
15:48:05 <lambdabot>  [1,1,3,2,1,3,1,4,3,1,1,6,1,1,3,4,1,3,1,2,3,1,1,12,1,1,3,2,1,3,1,4,3,1,1,6,1,...
15:48:10 <Bynbo7> > map (transpose . words) cake
15:48:12 <lambdabot>   [["O1opccm","n8uahai","e.ncokx","2ckce.","5eao","gl","ea","t","e"],["Ocpcpf...
15:48:26 <hpc> @oeis Don't Fish Fish
15:48:27 <lambdabot>  Sequence not found.
15:48:37 * ddarius is reminded of the theory of one-time pads.
15:48:50 <hpc> > map nub cake
15:48:52 <lambdabot>   ["One 18.25oucpakghltmix","One caprdoutfsig.","Thre slafoucpvgtbi.","Four l...
15:49:06 <monochrom> oh well, people get ++ed for assuming "drop" is O(1).
15:49:07 <mtnviewmark> > last . sort . map (\n->(length n, head n)) . words . map toLower . concat $ cake
15:49:10 <lambdabot>   (20,'p')
15:49:10 <waterlaz> weird. There is this piece of code
15:49:16 <c_wraith> ddarius: when the key length approaches the length of the message, it becomes impossible to know if you've successfully cracked the code?
15:49:17 <waterlaz>     bnds <- getBounds arr  
15:49:17 <waterlaz>     forM_ (range bnds) $ \i -> writeArray arr i v
15:49:18 <tolkad> > concat . map (map (:' ')) . transpose . map words $ cake
15:49:19 <lambdabot>   Couldn't match expected type `[a]'
15:49:19 <lambdabot>         against inferred type `GHC.Types...
15:49:26 <mtnviewmark> > reverse . sort . map (\n->(length n, head n)) . words . map toLower . concat $ cake
15:49:28 <lambdabot>   [(20,'p'),(18,'r'),(17,'i'),(17,'i'),(17,'i'),(17,'e'),(16,'r'),(16,'j'),(1...
15:49:42 <waterlaz> in a big program the list (range bnds) gets created and eats lots of RAM
15:49:49 <tolkad> > concat . map (map (++ " ")) . transpose . map words $ cake
15:49:51 <waterlaz> in a small test example it does not
15:49:51 <lambdabot>   ["One ","One ","Three ","Four ","One ","Three ","One ","Two ","Don't ","Fis...
15:49:53 <mtnviewmark> > reverse . sort . map (\n->(length n, head n)) . group . sort . words . map toLower . concat $ cake
15:49:55 <lambdabot>   [(8,"shaped"),(6,"and"),(5,"cups"),(4,"needle"),(4,"cup"),(3,"slash"),(3,"r...
15:50:05 <tolkad> > map concat . map (map (++ " ")) . transpose . map words $ cake
15:50:07 <lambdabot>   ["One One Three Four One Three One Two Don't Fish Fish Fish Fish Fish Pull ...
15:50:07 <Tomsik> :type foldr
15:50:13 <Tomsik> @t foldr
15:50:13 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:50:16 <tolkad> > drop 1 . map concat . map (map (++ " ")) . transpose . map words $ cake
15:50:18 <alpounet> @type foldr
15:50:18 <lambdabot>   ["18.25 can slash large cup slash and cups forget shaped shaped shaped shap...
15:50:19 <alpounet> or
15:50:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:50:20 <alpounet> :t foldr
15:50:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:50:25 <tolkad> > drop 2 . map concat . map (map (++ " ")) . transpose . map words $ cake
15:50:27 <lambdabot>   ["ounce prepared four eggs. semi-sweet four two all-purpose garnishes crack...
15:50:35 <tolkad> > drop 3 . map concat . map (map (++ " ")) . transpose . map words $ cake
15:50:36 <hpc> tolkad: awesome!
15:50:37 <lambdabot>   ["package coconut cup chocolate cups third flour. such waste. licorice. com...
15:50:53 <hpc> such waste. licorice.
15:51:07 <mtnviewmark> > sort . words . concat $ cake
15:51:10 <lambdabot>   ["'how","18.25","One","Shaped","agents,","all-purpose","all-purpose","alumi...
15:51:26 <hpc> > nub . sort . words . join $ cake
15:51:28 <lambdabot>   ["'how","18.25","One","Shaped","agents,","all-purpose","aluminum","and","as...
15:51:28 <Bynbo7> 18.25 can slash large cup slash and cups forget shaped shaped shaped shap... sounds like crazy rambling, i like it
15:52:03 <luite> maybe you guys should start a new #haskell-cake channel for these investigations :p
15:52:13 <tolkad> > drop 2 . map concat . map (intersperse " ") . transpose . map words $ cake
15:52:15 <lambdabot>   ["ounce prepared four eggs. semi-sweet four two all-purpose garnishes crack...
15:52:29 <Saizan> yeah, it's getting quite spammy
15:55:05 <waterlaz> but seriously, how can this thing backfire?
15:55:11 <waterlaz>     bnds <- getBounds arr  
15:55:11 <waterlaz>     forM_ (range bnds) $ \i -> writeArray arr i v
15:55:57 <Tomsik> If you're bored, go find kolgomorov complexity of cake
15:56:01 * hackagebot ad 0.46.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.46.2 (EdwardKmett)
15:56:37 <monochrom> it doesn't "backfire", whatever that means, unless you just mean slow
15:57:15 <jmcarthur> > map (head &&& length) . group . sort $ cake
15:57:17 <lambdabot>   [("Adjustable aluminum head positioner.",1),("Alpha resins.",1),("An entry ...
15:57:22 <jmcarthur> oh it's lines
15:57:35 <jmcarthur> > map (head &&& length) . group . sort . words . unlines $ cake
15:57:37 <lambdabot>   [("'how",1),("18.25",1),("Adjustable",1),("Alpha",1),("An",1),("And",2),("C...
15:57:45 <waterlaz> monochrom, yes, I mean slow
15:57:50 <jmcarthur> > map (head &&& length) . sortBy (comparing length) . group . sort . words . unlines $ cake
15:57:51 <lambdabot>   [("'how",1),("18.25",1),("Adjustable",1),("Alpha",1),("An",1),("Candy",1),(...
15:57:55 <jmcarthur> doh. okay no more, sorry
15:58:17 <monochrom> normal arrays in ghc are a bit slow.
15:58:57 <waterlaz> oh, I am using UArrays
15:59:09 <qfr> Warning: Top-level binding with no type signature: staticPath = "static"
15:59:10 <waterlaz> of Doubles
15:59:13 <qfr> What is the problem with that?
15:59:16 <monochrom> then I don't know why. should be fast.
15:59:23 <qfr> Why does this deserve a warning
15:59:56 <waterlaz> monochrom, well, the profiler tells me that it tries to alocate lots of space
15:59:57 <Bynbo7> qfr: it's good practice, that should probably be enforced
15:59:59 <qfr> I just wanted to define some static paths globally so I don't have redundant occurences
16:00:04 <qfr> Hmm
16:00:46 <hpc> sometimes it is an error, if it is given a type with class constraints that it somehow cannot infer
16:01:24 <hpc> i haven't ever gotten that warning before, tbh
16:02:10 <Bynbo7> waterlaz: what sort of array is it?
16:02:40 <waterlaz> IOUArray (Int, Int) Double
16:02:53 <Bynbo7> hmm
16:03:11 <waterlaz> the funny thing is I can't reproduce this at home with a small example
16:03:19 <copumpkin> so say I have a shitty API that expects a vararg printf-like callback, and I want to create a haskell binding that takes what the printf thing would have printed and returns a String of it. How would you go about that? I can't even export a vararg function so I'd need to wrap it, and probably sprintf to a buffer, and then maybe make an IOReffy linked list to put that buffer into, then flatten it? is there a nicer way?
16:03:28 <Bynbo7> not that i think it'll change much, but can you try: (!a,!b) <- bounds arr; forM_ [a..b]...?
16:03:56 <tolkad> > (!!3) . iterate (\l -> (\(a, b) -> intersect a b) $ splitAt (length l `quot` 2) l) . filter ((> 5) . length) . map concat . intersperse " " . map concat . map (intersperse " ") . transpose . map words $ cake
16:03:57 <lambdabot>   Couldn't match expected type `[a]'
16:03:57 <lambdabot>         against inferred type `GHC.Types...
16:04:14 <waterlaz> unfortunatley [a..b] won't work for a and b being tuples
16:04:21 <tolkad> what did I do wrong?
16:04:22 <Bynbo7> ah right
16:04:40 <waterlaz> and according to this:
16:04:46 <waterlaz>     range ((l1,l2),(u1,u2)) =
16:04:46 <waterlaz>       [ (i1,i2) | i1 <- range (l1,u1), i2 <- range (l2,u2) ]
16:05:00 <waterlaz> it should not be a problem
16:05:08 <Bynbo7> yeah
16:05:28 <Bynbo7> can you stick some SCC's in there, and see where the allocation is actually happening?
16:06:02 <waterlaz> SCC?
16:06:17 <Bynbo7> cost centers
16:06:26 <waterlaz> ok, /me off googling
16:06:37 <waterlaz> also, reading haskell core for now
16:06:46 <Bynbo7> {-# SCC "writeArray" #-} writeArray i v for example
16:09:51 <tolkad> the GHC docs are lying to you
16:09:55 <tolkad> http://haskell.org/ghc/docs/7.0.1/html/libraries/base-4.3.0.0/Data-List.html#v:subsequences
16:10:09 <tolkad> "ac" isn't a subsequence of "abc", is it?
16:10:25 <tolkad> > subsequences "abc"
16:10:26 <Bynbo7> yes
16:10:27 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
16:10:31 <tolkad> oh
16:10:45 <tolkad> I misunderstood then, nevermind, the ghc docs aren't lying to you
16:10:48 <Bynbo7> > filterM (const [True,False]) "abc"
16:10:49 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
16:10:51 <tolkad> false alarm
16:10:58 <Bynbo7> > filterM (const [False,True]) "abc"
16:10:59 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
16:11:55 * ddarius thinks he'll walk around randomly and maybe stop somewhere for food.
16:12:00 <tolkad> be ever vigilant
16:12:05 <tolkad> though
16:12:08 <tolkad> you never know
16:12:10 <jmcarthur> copumpkin: sounds freaking sucky
16:12:24 <copumpkin> jmcarthur: yep, any ideas? or should I just go with that?
16:13:20 <jmcarthur> copumpkin: yeah, i think i would just write a C wrapper around it and bind to my wrapper
16:13:35 <copumpkin> just with a linked list behind the scenes?
16:14:09 * jmcarthur thinks
16:14:42 <ddarius> copumpkin: Why do you need an "IOReffy linked list" ?
16:14:56 <jmcarthur> yeah i was trying to figure that out, but asking works :)
16:15:07 <copumpkin> ddarius: the callback could be called multiple times and it's assuming stream-like behavior (stdout)
16:15:32 <copumpkin> so if it calls callback("blah %d", 5) and callback("moo %s", "zomg"), I should eventually be able to pull out "blah 5moo zomg"
16:16:05 <jmcarthur> eek
16:16:10 <ddarius> copumpkin: I would have your C callback just call a Haskell callback each time.
16:16:23 <ddarius> Then how you bind things together can be decided in Haskell.
16:16:25 <jmcarthur> where the haskell callback accepts a String
16:16:38 <copumpkin> ddarius: yeah, but I still need to decide what to do in haskell (that was going to be the ioreffy linked list)
16:16:58 <jmcarthur> what ddarius suggests is probably what i would do
16:17:04 <jmcarthur> and then do the rest in haskell
16:17:17 <jmcarthur> this is the bare minimum to get past the ugly varargs thing :)
16:17:26 <copumpkin> yeah, that's what I was planning to do :)
16:17:42 <copumpkin> on that note, is there a way of doing a "test run" on sprintf to ask it how much memory it's going to need?
16:17:53 <ddarius> copumpkin: Why not have just a single IORef with a bytestring Builder or some such?
16:17:55 <jmcarthur> copumpkin: how about writing to a Chan in the haskell callback?
16:18:09 <copumpkin> oh a builder sounds smarter
16:18:12 <jmcarthur> ooh
16:18:13 <copumpkin> or a chan
16:18:17 <copumpkin> but a builder seems clean
16:18:22 <copumpkin> maybe I'll do that
16:18:26 <ddarius> (And a Chan is a linked list of MVars ...)
16:18:27 <copumpkin> well, first to get the callback working
16:18:31 <jmcarthur> i don't know if this is for a concurrent type thing or not
16:18:32 <copumpkin> (this is libopcodes I'm binding to, btw)
16:18:47 <ddarius> jmcarthur: That hardly matters.
16:19:15 <jmcarthur> ddarius: i mean where the data is accessed in a different thread anyway all the time
16:19:23 <jmcarthur> callbacks are weird in haskell anyway, IMO
16:19:48 <jmcarthur> the presence of a callback in a haskell API ruins a lot of my normal assumptions about the code
16:20:03 <jmcarthur> it gets especially bad when things are bound to OS threads :(
16:20:06 <ddarius> copumpkin: It doesn't allow you store some "user data" does it?
16:20:14 <copumpkin> it does let me store user data
16:20:20 <copumpkin> and passes that to the streamish function I believe
16:20:28 <copumpkin> http://sourceware.org/cgi-bin/cvsweb.cgi/src/include/dis-asm.h?rev=1.80&content-type=text/x-cvsweb-markup&cvsroot=src
16:20:29 <waterlaz> Bynbo7, it looks like using SCC's for IO is useless
16:20:32 <copumpkin> that's _all_ of libopcodes :P
16:20:35 <copumpkin> "lib"
16:20:49 <copumpkin>   typedef int (*fprintf_ftype) (void *, const char*, ...) /*ATTRIBUTE_FPTR_PRINTF_2*/;
16:20:53 <copumpkin> that's its callbacky thing
16:21:00 <copumpkin> and the void * is whatever
16:21:05 <jmcarthur> this looks familiar...
16:21:12 <ddarius> copumpkin: Then things are easier.
16:21:33 <jmcarthur> oh i remember where i saw this before, now
16:21:43 <copumpkin> jmcarthur: pikewerks? :P
16:21:46 <jmcarthur> i'm not allowed to say how it was used though :(
16:22:01 <copumpkin> it's a horrendous API, but I don't need it for anything fancy
16:22:11 <ddarius> copumpkin: You can write your Haskell as a pure state transducer and have the C mutate the user data field to load and store the state between calls.
16:23:47 <qfr> How do you squeeze the signature definition of a function and the function itself into a line in ghci?
16:23:56 <qfr> Do you have to use the post definition :: thing/
16:24:05 <jmcarthur> copumpkin: i assume you are using this to do some reverse engineering stuff. when i saw it, it was used to make reverse engineering more difficult :P
16:24:08 <Bynbo7> foo :: bar; foo = baz
16:24:18 <qfr> Alright, thanks
16:24:22 <monochrom> let {f :: Int; f = 0}
16:24:46 <ddarius> qfr: You may also want to look at :{ and :}
16:24:54 <qfr> :}
16:24:55 <monochrom> the order is not important
16:25:20 <qfr> Prior to Haskell I was like :} and now I'm more like :{
16:25:44 <jmcarthur> lovely! i wrote some code over the last few days using STArray for speed, but it was a huge mess. i just rewrote all that code in about an hour using IntMap and it's pretty and short
16:25:52 <jmcarthur> you would think i would learn this lesson by now
16:25:54 <monochrom> this is why after communism revolutions people are usually less happy
16:26:40 <jmcarthur> and it's probably not even any slower this way because i was able to remove a lot of redundant stuff
16:27:02 <jmcarthur> not that i benchmarked or plan to benchmark
16:27:12 <ddarius> Blissful ignorance.
16:27:19 <jmcarthur> exactly
16:27:26 <alpounet> byorgey, ping ?
16:28:06 <monochrom> I tried both array and list for dynamic programming. if I traverse the array or the list sequentially, the list version is faster.
16:28:28 <alpounet> oh, nevermind.
16:28:45 <jmcarthur> monochrom: what version of ghc and what array library?
16:29:05 <monochrom> I think it was ghc 6.10 and whatever came with it.
16:29:20 <monochrom> no, it was ghc 6.12
16:29:58 * ddarius pulls on his combat boots.
16:32:39 <copumpkin> ddarius: cool, I'll give it a go and let you know
16:44:32 <randomman> hello
16:44:42 <randomman> haskellers
16:45:48 <aristid> hmm, hlint tells you about every possible eta reduction. but sometimes eta reduction is "not the right thing". i wonder if this desirability of eta reduction can be formalised somehow
16:46:55 <monochrom> you mean you prefer to write (\x -> blah x) for some blah?
16:47:39 <dolio> foo x y z = blah e1 e2 z, probably.
16:48:10 <aristid_> dolio: something similar, yeah.
16:48:19 <aristid_> f a b = f' a Nothing b
16:48:24 <monochrom> yes, I would write "foo x y z = blah e1 e2 z" any day
16:48:30 <aristid_> it proposes f a = f' a Nothing
16:48:37 <aristid_> that feels untidy
16:49:12 <coaristid> yay, i have a co- nick too, now
16:49:19 <monochrom> godawful
16:49:49 <coaristid> monochrom: can you verbalise why the eta reduction there feels wrong?
16:49:50 <jmcarthur> it's going to be a fad now
16:50:04 <aristid> jmcarthur: never.
16:50:25 <coaristid> jmcarthur: it's great fun to have a co- standby.
16:50:40 <jmcarthur> i like to think of my functions as values, so i love eta reduction :)
16:51:15 <coaristid> jmcarthur: the the a was not there, or the argument order of f' was different, i would go for the eta reduction any day
16:51:22 <coaristid> it would be f = f' Nothing, then
16:51:39 <coaristid> but i don't want to change the argument order of f'
16:51:41 <jmcarthur> you mean you don't like dropping some arguments but not others?
16:51:51 <coaristid> jmcarthur: yes, maybe that's it
16:52:15 <jmcarthur> for me it depends on how conceptually related the arguments are
16:52:31 <jmcarthur> like, i wouldn't drop one of the two list arguments to zip unless i could drop both
16:53:07 <jmcarthur> but i wouldn't mind dropping the last two arguments to zipWith even if i still have to leave the first argument
16:53:11 <coaristid> this is the actual code if you care: https://github.com/aristidb/aws/blob/master/Aws/Util.hs#L68
16:53:41 <coaristid> jmcarthur: i think i would be willing to do a single eta reduction on zipWith
17:02:39 <int80_h> I just installed Network.Curl, but ghc complains it cannot find it. What environmental variable might be helpful here?
17:03:32 <monochrom> no environment variable will help. paste the outputs of "ghc -v" and "ghc-pkg -v list"
17:03:49 <Zao> int80_h: You may have installed it as an user package and try to use it from a global context.
17:03:53 <Zao> See monochrom's advice.
17:05:10 <int80_h> okay posting. I installed it as a user and am trying to use it as local user. Brb
17:10:38 <int80_h> ghc-pkg dump is quite large, this is going to be a minute
17:11:17 <monochrom> > "-v list" == "dump"
17:11:18 <lambdabot>   False
17:12:02 <int80_h> monochrom so you wanted the output from "ghc-pkg -v list"?
17:12:23 <monochrom> yes
17:14:44 <monochrom> "reading between the lines" is harmful
17:15:08 <int80_h> monochrom: http://hpaste.org/42995/ghc_and_ghcpk_output
17:16:36 <monochrom> Network.Curl is in the "curl" package isn't it? http://hackage.haskell.org/package/curl  you don't have that package in the list.
17:18:26 <int80_h> monochrom: ack, I htink you are right
17:19:24 <monochrom> if you just did "cabal install curl" it probably just aborted because some kind of "libcurl4-openssl-dev" (c lib) was not found
17:19:35 <int80_h> yup, installing that right now
17:23:35 * hackagebot xml-monad 0.5 - Monadic extensions to the xml package.  http://hackage.haskell.org/package/xml-monad-0.5 (AristidBreitkreuz)
17:23:48 <aristid> thanks, hackagebot
17:31:06 <Hugglesworth> \o
17:41:43 * edwardk waves hello.
17:48:22 <int80_h> what is the most efficient way to do a complete uninstall of a haskell environment?
17:48:37 <edwardk> sudo rm -rf /
17:48:44 <int80_h> brilliant
17:48:54 <edwardk> you may want to back things up first
17:49:02 <edwardk> as there may be other side effects
17:49:04 <int80_h> too late!
17:49:15 <int80_h> there were. it ate my sandwich
17:49:23 <int80_h> you never menbtioned anything about that!
17:49:23 <Eelis> edwardk: how's that streams package coming along? :)
17:49:25 <monochrom> including ghc?
17:49:42 <edwardk> eelis: rather well. i have a half dozen stream types so far
17:49:45 <int80_h> monochrom: yeah, I've borked ghci and it seems all I can do is re-install everything
17:49:58 <edwardk> eelis: and a couple dozen more sketched out
17:49:58 <Eelis> edwardk: great!
17:50:10 <edwardk> one sec. let me see if i can get it buildable and throw it on github
17:50:24 <Eelis> even better! :)
17:50:29 <edwardk> well, its already on github, but i want to bring it up to date, since my local version is way newer
17:50:45 <monochrom> there are $HOME/.ghc and $HOME/.cabal to delete. there are also directories mentioned in http://groups.google.com/group/comp.lang.haskell/msg/a38908521c5a6e6b
17:50:55 <nh2> Anyone knows what is that Haskell-ish programming languate that has a lot of auto-proving, in-languate constraints on types (like lists with a maximum length or "every prime number-th argument is of type bool")?
17:51:05 <edwardk> agda?
17:51:13 <int80_h> coq?
17:51:20 <nh2> edwardk: I guess it's that
17:51:20 <edwardk> the haskell-ish one =)
17:51:30 <edwardk> coq is the ml'ish one ;)
17:53:13 <nh2> I knew it sounded like "actor"
17:54:04 <nh2> but guess what, you have to read 10k Google results full of asynchronous stuff until you find out that you won't find it with that approach
17:54:31 <nh2> it's time for Google phonetic search
17:58:25 <edwardk> eelis: it compiles, cleaning up warnings now
17:58:41 <Eelis> roger
18:01:42 <coaristid> nh2: actually google has phonetic search, in a way: you can speak search queries into your  android phone
18:01:58 <kmc> agda doesn't auto-prove much (even less than coq)
18:02:11 <edwardk> yeah but it doesn't do the actual search with soundex, etc. it just finds likely words and picks those instead
18:02:16 <kmc> but it's dependently typed, which allows you to express any formal correctness property using the types
18:02:39 <nh2> coaristid: well, yes, but I'd have to be lucky that their servers understood exactly what I did not know that I meant it before they pass it into the search
18:03:55 <coaristid> nh2: it's not perfect :)
18:04:18 <coaristid> nh2: actually the biggest problem is that it picks up people around you, who are talking
18:05:20 <sugimoto> こんばんは
18:05:39 <sugimoto> 誰もいないの？
18:05:52 <sugimoto> つま~んない
18:05:59 <sugimoto> おい
18:06:03 <aristid> sugimoto: most people here probably don't understand japanese (myself included)
18:06:24 <andy__> is there anything along the lines of unfoldM?
18:06:30 <aristid> @hoogle unfoldM
18:06:31 <lambdabot> No results found
18:06:34 <sugimoto> ははあ。。。
18:06:39 <aristid> @hackage monad-loops
18:06:39 <lambdabot> http://hackage.haskell.org/package/monad-loops
18:06:42 <andy__> or maybe a better alternative?
18:06:43 <andy__> k
18:06:46 <andy__> thanks
18:07:15 <copumpkin> a japanese person from florida?
18:07:20 <copumpkin> who doesn't speak english?
18:07:33 <sugimoto> so whats people doin with haskell?
18:07:33 --- mode: ChanServ set +o copumpkin
18:07:52 <copumpkin> programming!
18:08:10 <sugimoto> why are you here?
18:08:25 <aristid> why not?
18:08:30 <copumpkin> because I like haskell and like helping people learn it
18:08:49 <nh2> I know nothing about agda yet (except from wikipedia). Can I use it as a fully-blown programming language? Could I use it for hello world, fib, backup programs, rocket control?
18:08:54 <sugimoto> you work anywhere?
18:09:08 <copumpkin> nh2: if you really want to, sure, but it's not really very developed in that way yet
18:09:11 <Eelis> nh2: as far as i can tell, it's very much at the prototype stage.
18:09:13 <copumpkin> sugimoto: do you have a haskell question
18:09:17 <copumpkin> ?
18:09:32 <sugimoto> what isnt a haskell question?
18:09:37 <andy__> does ghc do a good job of removing unused symbols in final executables?
18:09:41 <copumpkin> sugimoto: that one
18:10:00 <andy__> i.e. including a package for a single function
18:10:21 <copumpkin> andy__: symbols, no
18:10:24 <copumpkin> you could call strip
18:10:30 <sleepynate> sexy
18:11:27 <andy__> k
18:15:18 <notallama> so, i'm trying to follow the GUI examples in real world haskell. but i have no idea what gtk2hs packages i need (gtk2hs does not exist on hackage, but several other gtk2hs-* packages do). any suggestions? or suggestions for another gui library with decent haskell examples/tutorials?
18:23:42 <monochrom> first install "gtk2hs-buildtools", then install "gtk". actually in-between ensure you have some kind of "libgtk2.0-dev" and "libglade2-dev" (c libs)
18:32:40 <andy__> if i have two datatype definitions defining record types and both have a name :: String
18:32:52 <andy__> is there an easy way to allow for qualified imports to allow this?
18:33:01 <andy__> can multiple modules be defined in one source file?
18:33:13 <andy__> can qualified imports be exported as such?
18:33:18 <copumpkin> I wish
18:33:44 <andy__> does defining a type class to overload a name method
18:33:56 <andy__> cause any overhead if the type is known at the call site?
18:34:06 <copumpkin> yeah, unless you use SPECIALIZE
18:34:13 <copumpkin> you could also use lenses
18:34:20 <copumpkin> fclabels or data-accessor are packages for this
18:34:30 <andy__> ok
18:35:49 <dibblego> I still write my own type-class for each record field :(
18:37:35 <kfish> andy__, does putting the record definitions in different modules, and importing them qualified work for you?
18:38:33 <andy__> yeah, thats what i'm doing now
18:38:35 <andy__> its just a pain
18:41:16 <andy__> using SPECIALIZE seems a good enough option
18:42:02 <andy__> you mean specializing the type class method, not functions that accept any type in that type class, right?
18:42:30 <andy__> i assume the first, but never used the pragma before, and want to make sure i don't screw it up..
18:43:37 <copumpkin> if you put them in separate modules
18:43:46 <copumpkin> GHC can actually let you use the names unqualified
18:43:53 <andy__> o?
18:43:53 <copumpkin> and figure out which ones to use based on context
18:43:58 <andy__> o
18:44:00 <andy__> perfect
18:44:00 <copumpkin> it makes many shudder
18:44:13 <Axman6> andy__: are you expecting to be calling the function enough that the overhead will make any difference at all?
18:44:17 <andy__> does it require a particular extension?
18:44:21 <Axman6> the overhead of using a class*
18:44:43 <copumpkin> andy__: yeah. Trying to remember which one
18:44:44 <andy__> not really, just seems like additional noise to a user of the package
18:45:06 <copumpkin> -XDisambiguateRecordFields
18:45:12 <andy__> k, thanks
18:46:19 <Axman6> andy__: having to write Foo.name and Bar.name all the time seems far more noisy to me ;)
18:47:54 <andy__> thought you meant for the type class?  the downside to the separate modules is just that its annoying to me
18:49:48 <andy__> (would be nice to be able to define separate modules in same file, separated by a level of indent - but guess that might mean imports would have to be allowed outside of the module)
18:49:58 <andy__> (and i guess explicit exports in such a case)
18:50:02 <copumpkin> yeah
18:50:09 <copumpkin> it'd be nice to have a more sophisticated module system
18:54:54 <coaristid> second that
18:55:30 <copumpkin> coaristid: I see you came to the dark side
19:02:39 <edwardk> Eelis: https://github.com/ekmett/streams/tree/master/Data/Stream/Infinite/Functional
19:02:45 <edwardk> er https://github.com/ekmett/streams/tree/master/Data/Stream/Infinite/Functional
19:03:11 <edwardk> eelis: i'll be uploading it to hackage once i polish the haddocks, etc. but wanted you to have what you needed
19:03:43 <edwardk> https://github.com/ekmett/streams/blob/master/Data/Stream/NonEmpty.hs is the type you are probably looking for
19:05:38 <edwardk> its not dark, just colight
19:07:05 <jkr> A long-running haskell program keeps segfaulting (sometimes after hours) on my linode VPS. Can't seem to make it crash on my home computer. Before I get into making stabs at debugging, anyone know if there's any known issue with ghc on xen?
19:10:40 <Kaidelong> @pl let trialdiv t n = (t*t>n) || (n`mod`t/=0&&trialdiv(t+1)n) in (\n -> (n>1) &&  trialdiv 2 . abs)
19:10:41 <lambdabot> (&& fix (ap (ap . ((||) .) . (>) . join (*)) . ap (ap . ((&&) .) . flip flip 0 . ((/=) .) . flip mod) . (. (1 +))) 2 . abs) . (> 1)
19:11:48 <Kaidelong> @pl let trialdiv t n = (t*t>n) || (n`mod`t/=0&&trialdiv(t+1)n) in (\n -> (n>1) &&  trialdiv 2 n) . abs
19:11:49 <lambdabot> liftM2 (&&) (> 1) (fix (ap (ap . ((||) .) . (>) . join (*)) . ap (ap . ((&&) .) . flip flip 0 . ((/=) .) . flip mod) . (. (1 +))) 2) . abs
19:12:12 <Eelis> edwardk: splendid, thanks! that will do quite nicely for the time being
19:12:56 <Kaidelong> > filter $ liftM2 (&&) (> 1) (fix (ap (ap . ((||) .) . (>) . join (*)) . ap (ap . ((&&) .) . flip flip 0 . ((/=) .) . flip mod) . (. (1 +))) 2) . abs $ [1..15] --does it work?
19:12:57 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:12:57 <lambdabot>         against inferred ...
19:13:00 <Kaidelong> no
19:13:06 <Kaidelong> oh
19:14:20 <shachaf> Kaidelong: Sure it works.
19:14:26 <shachaf> Kaidelong: But ($) is infixr, not infixl.
19:14:35 <Kaidelong> oh whoops
19:14:49 <andy__> if you have data Foo = Bar { name :: String } | Baz { name :: String }
19:15:05 <andy__> ok, so there was a question there..
19:15:05 <Axman6> that'll work fine
19:15:16 <andy__> ok
19:15:35 <andy__> so you just do x@Baz _  or whatever if you really care, right?
19:15:41 <andy__> but otherwise, no problem?
19:15:58 <Axman6> eh?
19:16:05 <andy__> (still strikes me as weird for some reason..)
19:16:09 <Axman6> you can do Baz{} actually
19:16:11 <Kaidelong> it does work, my own attempt at doing that was full of curries and uncurries
19:16:33 <andy__> k
19:16:43 <andy__> i need to do that more..
19:16:50 <andy__> that syntax i mean
19:18:34 <andy__> if you have Bar { one :: String } | Baz { two :: Int }
19:18:58 <andy__> well
19:19:11 <andy__> again, no question there..
19:19:52 <andy__> just always though i had to do another data type to combine record syntax and enumeration-like syntax
19:20:24 <c0pumpkin> you can't do that
19:20:54 <andy__> ?
19:21:01 <c0pumpkin> Bar { one :: String } | Baz { two :: Int }
19:21:01 <Boxo> > flip filter [1..15] $ liftM2 (&&) (> 1) (fix (ap (ap . ((||) .) . (>) . join (*)) . ap (ap . ((&&) .) . flip flip 0 . ((/=) .) . flip mod) . (. (1 +))) 2) . abs
19:21:03 <lambdabot>   [2,3,5,7,11,13]
19:21:35 <c0pumpkin> > nubBy (\x y -> x `mod` y == 0) [2..]
19:21:36 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:22:01 <andy__> just compiled on ghc 7.1, no extension that i can tell
19:22:08 <andy__> or do you mean without data Foo = ...
19:22:13 <c0pumpkin> andy__: weird
19:22:15 <c0pumpkin> oh
19:22:21 <c0pumpkin> I thought both records were called one
19:22:25 <c0pumpkin> yeah, that's fine
19:22:29 <Kruno> Hello
19:22:30 <c0pumpkin> it'll just give you an error if you have the wrong one
19:22:36 <andy__> ok
19:22:46 <Kaidelong> hmm...
19:23:02 <Kaidelong> > nubBy ((==0) .) . mod) [2..]
19:23:03 <lambdabot>   <no location info>: parse error on input `)'
19:23:07 <c0pumpkin> gcd
19:23:11 <c0pumpkin> oh
19:23:33 <c0pumpkin> > nubBy (((>1) .) . mod) [2..]
19:23:36 <lambdabot>   mueval-core: Time limit exceeded
19:23:39 <c0pumpkin> > nubBy (((>1) .) . gcd) [2..]
19:23:40 <djahandarie> @elite copumpkin
19:23:40 <lambdabot> CopuMpkiN
19:23:42 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:23:55 <c0pumpkin> > nubBy(((>1).).gcd)[2..]
19:23:57 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:24:06 * ddarius breaks a huge chunk of nail off again.
19:24:57 <djahandarie> > nubBy ((>1).:gcd)[2..]
19:25:00 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:25:06 <djahandarie> Oops, extra space lol
19:25:12 <Kaidelong> @ty (.:)
19:25:13 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:25:19 <djahandarie> @ty (.).(.)
19:25:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:25:55 <Kaidelong> @ty (:.)
19:25:56 <lambdabot> Not in scope: data constructor `:.'
19:26:11 <Kaidelong> lambdabot doesn't have those kinds of vectors?
19:27:24 <Eelis> edwardk: i notice your <!> is more strict than strictly necessary:   NonEmpty.head (('x' :| "bla") <!> undefined)   is needlessly bottom. is this by design? if not, making <!>'s pattern for the second argument lazy should do the trick.
19:29:16 * djahandarie wonders why typecompose isn't in lambdabot
19:33:15 <Kruno> I have a really silly question. I am new to Haskell, but it isn't about Haskell itself, it is about the Haskell Platform Build System called Cabal.
19:33:40 <Axman6> it's the haskell build system btw
19:33:50 <Kruno> Ah
19:34:17 <Axman6> what's the question?
19:34:48 <Kruno> GTK will not install because, possibly because, of CULLong in pango. I don't know if this is just me or is this universal, I spent yesterday from 6pm-1am trying to get it to work with every combination.
19:35:01 <Kruno> Pango 0.12.0 + ghc 6.12.3
19:35:11 <Kruno> Haskell Platform 2010.2.0.1
19:35:18 <Kruno> 2010.2.0.0
19:35:19 <Kruno> sorry
19:35:55 <Kruno> This is done through: cabal install gtk, I did cabal update on the day
19:36:08 <Kruno> I have gtk installed and working
19:36:15 <Kruno> 2.2
19:36:33 <Kruno> I should add I am on windows
19:37:28 <Eelis> edwardk: oh, and toList is too strict as well:  null (toList undefined)  is needlessly bottom. here, too, making the pattern lazy seems to nicely fix the problem.
19:40:23 <Eelis> edwardk: and map is also too strict, i think
19:40:40 <Eelis> edwardk: should i throw these in a commit and send you a pull request on github?
19:42:49 <john_r_watson> has anyone gotten Hughe's example:  runSF (mapA (delay 0)) [[1,2,3]] to run properly?  (From his paper here: http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf)
19:42:52 <c0pumpkin> Eelis: can't hurt, even if he's afk :)
19:43:07 --- mode: c0pumpkin set -o c0pumpkin
19:43:39 <Eelis> c0pumpkin: well, maybe he made these things deliberately stricter than necessary for efficiency reasons or something
19:43:58 <Eelis> edwardk: cons is also too strict
19:45:11 * hackagebot enumerator 0.4.5 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.5 (JohnMillikin)
19:45:23 <Kruno> OMG, I think it is installing GTK. cabal install gtk-plot, fixed everything. Cabal install gtk doesn't work. :/
19:45:33 <Kruno> Build system broken?
19:45:46 <john_r_watson> @src Control.Comonad
19:45:46 <lambdabot> Source not found.
19:45:57 <john_r_watson> @src Comonad
19:45:57 <lambdabot> Source not found. There are some things that I just don't know.
19:46:08 <john_r_watson> @src (>>=)
19:46:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:46:19 <john_r_watson> so true lambdabot... so true
19:49:59 <byorgey> alpounet: pong?
19:50:33 <alpounet> byorgey, actually i was gonna ask you the name of the program you use for publishing on your blog
19:50:36 <alpounet> but i found it in the meantime
19:50:40 <alpounet> sorry for disturbing!
19:51:21 <byorgey> alpounet: ok, no worries =)
19:58:20 <Kruno> Okay, GTK2HS works. I compiled and ran it, it works fine. But damn was that difficult. Who would have thought that the build system has to be used indirectly? I could honestly not see myself using Haskell for work. This is just too much.
19:58:54 <copumpkin> λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
20:00:23 <ivanm> Kruno: huh?
20:00:33 <ivanm> cabal install gtk2hs-buildtools; cabal install gtk
20:00:39 <ivanm> (if you're using cabal-install)
20:01:32 <ddarius> copumpkin: What was with the theta?
20:01:32 <Kruno> Tried that yesterday, doesn't work.
20:01:38 <ddarius> Or 0?
20:01:41 <Kruno> cabal install plot-gtk is what did it
20:01:52 <Kruno> It could not install plot-gtk, but it did install gtk
20:02:01 <copumpkin> ddarius: the theta?
20:02:06 <pastorn> Kruno: what version of ghc are you using?
20:02:06 <ivanm> Kruno: error message?
20:02:20 <ivanm> do you have the gtk+ development libraries installed?
20:02:21 <Kruno> ghc 6.12.3
20:02:24 <ddarius> copumpkin: I think it was a zero now.
20:02:26 <Kruno> yes
20:02:27 <ivanm> Kruno: which version of Cabal?
20:02:28 <Kruno> they work fine
20:02:33 <Kruno> 0.8
20:02:40 <ivanm> no, Cabal, not cabal-install
20:02:43 <copumpkin> ddarius: oh, just being a l33t hax0r. It's a requirement to have a digit of some sort in your nick
20:02:47 <ivanm> Kruno: ghc-pkg list Cabal
20:02:55 <ivanm> copumpkin: O RLY
20:02:57 <ivanm> ?
20:03:15 * hackagebot anansi 0.3 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.3 (JohnMillikin)
20:03:19 <Kruno> THis is the only thing it brings up: Cabal-1.8.0.6
20:03:39 <Kruno> And that my cache is out of date :o
20:03:45 <ivanm> OK, it's not the problem that I was thinking of
20:03:50 <ivanm> Kruno: _that_ might be your problem
20:04:05 <copumpkin> YARLY
20:04:21 <ivanm> grrr.... why don't people put description fields in their .cabal files?
20:04:30 <Kruno> Fixed out of date cache, now runnign cabal update. Will try things again.
20:04:30 <ivanm> copumpkin: I guess I'm not a l33t hax0r then *shrug*
20:04:38 <copumpkin> ivanm: yeah :/
20:04:58 <ddarius> So capital theta and 0 look almost identical in my font.  The only difference is that the theta is a little fatter.
20:05:09 <Kruno> failed again.
20:05:48 <Kruno> Thankfully it didn;t take out GTK bindings :)
20:06:32 <Boxo> compumkin, is it really?
20:06:46 <Kruno> If anyone else comes in here wondering why gtk2hs will not install under cabal, tell them not to install gtk, but plot-gtk, plot gtk will fail, but as l;east they will have gtk2hs installed.
20:06:56 <Boxo> <copumpkin> λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)) <- I mean, forgot to scroll
20:07:12 <copumpkin> Boxo: if you apply that to itself many times, yes
20:08:22 <Kruno> Then again I was searching for bug reports that have similar issues as I would have, but there aren't any. I really hope it is just me.
20:09:45 <Boxo> Liek this? ((?x.xxxxxxxxxxxxxxxxxxxxxxxxx)(?abcdefghijklmnopqstuvwxyzr.(r(thisisafixedpointcombinator))))f
20:10:51 <ddarius> :t \r f -> r (f r)
20:10:53 <lambdabot> forall t t1. (t -> t1) -> ((t -> t1) -> t) -> t1
20:12:03 <ddarius> :t \r -> (\r f -> r (f r)) r id
20:12:03 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:12:03 <lambdabot>     Probable cause: `id' is applied to too few arguments
20:12:04 <lambdabot>     In the second argument of `(\ r f -> r (f r))', namely `id'
20:12:44 <Kruno> I really have to ask, how many Windows users use Haskell? Are there any of you around here?
20:13:00 * Boxo is
20:13:11 <copumpkin> hmm
20:13:17 <Axman6> Kruno: tghere's quite a few, but gtk is notoriously difficult to get working properly
20:13:19 * ddarius used Gtk2hs on Windows like seven or eight years ago without much problems.
20:13:20 <copumpkin> I installed c2hs and it isn't showing up in my ghc-pkg list
20:13:28 <copumpkin> and it lets me reinstall it without warning me
20:13:35 <ddarius> copumpkin: It's a tool.
20:13:47 <Kruno> So it isn't just me? /phew
20:13:50 <copumpkin> so I can't depend on it in a .cabal file?
20:13:52 <copumpkin> I can depend on SHE
20:13:56 <copumpkin> or happy
20:14:17 <ddarius> copumpkin: You should be able to depend on it, but there isn't necessarily any library for it to register with GHC.
20:14:21 <Kruno> wx is more difficult though, I have had more issues and messing about, which is why I was desperate to solve the GTK issues.
20:14:56 <copumpkin> ddarius: yeah, there isn't, but I'd expect c2hs to be a valid dependency. I cabal install c2hs and then try to configure my package that depends on it, and it tells me it's missing c2hs
20:15:21 <Kruno> I honestly wonder if there is any way to include these libraries into the Haskell Platform? What would I have to do to make something like that possible?
20:15:42 <ddarius> copumpkin: The package is probably looking for the executable and isn't finding it in the path.
20:16:04 <copumpkin> ddarius: nah, it's my package and I just added c2hs to build-depends
20:16:08 <Boxo> http://pastebin.com/5J78JETv
20:16:15 <copumpkin> it does almost nothing
20:16:19 <copumpkin> but it does depend on c2hs
20:16:24 <Boxo> first line is  ((?x.xxxxxxxxxxxxxxxxxxxxxxxxx)(?abcdefghijklmnopqstuvwxyzr.(r(thisisafixedpointcombinator))))f
20:16:44 <ddarius> copumpkin: Did you get your binding working?
20:17:08 <copumpkin> ddarius: just started working on it, trying to figure out c2hs to avoid writing the struct and enum marshalling code by hand
20:17:25 <copumpkin> but cabal's being annoying about it
20:18:42 <copumpkin> I think my cabal is just screwed up
20:18:46 <copumpkin> or something about c2hs is
20:19:13 <copumpkin> it's not normal for me to be able to keep typing cabal install X and have it rebuild X every time (without warning me or requiring a --reinstall)
20:19:13 <Kruno> copumpkin: tell me about it
20:21:59 <pastorn> why did i have a directory ~/lib/ with all my haskell stuff?
20:22:09 <Kruno> omg, I think the same trick worked again. Wx is installing. lol
20:22:21 <pastorn> (ghc is system-wide, cabal is in ~/.cabal)
20:22:37 <Kruno> cabal install wxFruit => installs wx, but cabal install wx does not install wx
20:22:52 <Kruno> oh wait, spoke too soon
20:22:57 <pastorn> Kruno: you actually managed to compile wxhaskell?
20:23:14 <Kruno> not yet by the looks of it
20:23:31 <pastorn> i'd give up on that unless it was a requirement
20:23:38 <Kruno> Really? Why is that?
20:23:42 <pastorn> i only know of two people who's ever succeeded
20:23:52 <pastorn> i know of many more who's tried
20:24:28 <pastorn> Kruno: if you're on windows it might be easier, but on *nix it's gonna be a lot of trouble
20:24:56 <Kruno> Why is it so difficult to do these things under Haskell, and so trivial under Python? Personally I love Haskell as a language, more than anything but Common Lisp, and I honestly would prefer to use it over functional Perl.
20:25:22 <Kruno> Last job, Perl was necessary, and functional thinking made things trivial
20:25:30 <Kruno> I would prefer to replace Perl with Haskell
20:26:09 <pastorn> Kruno: it's not haskell, it's just wxHaskell that depends on weird configurations of wxWidgets
20:26:47 <Kruno> Could you elaborate?
20:27:06 <pastorn> not really
20:27:13 <systemfault> Qt bindings would be nice :P (I can dream... right?)
20:27:16 <pastorn> Kruno: just stick to gtkhs, it's pretty great
20:27:32 <Kruno> I think I will.
20:27:43 <alpounet> systemfault, there is qthaskell
20:27:45 <Kruno> Are there any plans to do something about these difficulties?
20:27:51 <alpounet> (hi! :) )
20:27:57 <systemfault> alpounet: Hey :D
20:27:58 <pastorn> Kruno: for wx? i don't think there are...
20:28:13 <alpounet> @where qthaskell
20:28:13 <lambdabot> I know nothing about qthaskell.
20:28:19 <Kruno> So GTK is the pseudo GUI toolset for Haskell?
20:28:31 <alpounet> @where+ qthaskell http://qthaskell.berlios.de/
20:28:32 <lambdabot> Done.
20:28:32 <pastorn> Kruno: it's GTK but with nicer types
20:29:04 <Kruno> I see. Probably will stick to GTK then, as I haven't had any issues with it.
20:29:13 <Kruno> In terms of past UIs
20:30:08 <Kruno> I remember a very old job where I made a wx UI in Python with some data analysis software I wrote, wx looks nice but a lot of hacking needed to be done with tables at the time, this was several years ago.
20:30:36 <Kaidelong> I thought qthaskell was an early alpha thing
20:31:01 <alpounet> Kaidelong, consider it now an early beta thing
20:31:21 <Kruno> wxcore is the key problem in getting wx to work, I will see what I can do about it. I can't seem to give up until I have exhausted every thinkable option. lol
20:31:54 <Kaidelong> wx has a nice implementation too
20:32:03 <Kaidelong> too bad wxhaskell is so hard to configure and get running
20:32:27 <pastorn> Kruno: what Kaidelong said. The interface is pretty swell...
20:32:32 <pastorn> iirc it's callback-less
20:33:19 <Kruno> Basically it is an issue with types: error: conversion of `wxString::c_str() const()' from `wxCStrData' to `void *' is ambiguous
20:33:33 <ddarius> Kruno: So simply fix it.
20:33:41 <Kruno> I am trying
20:33:52 <pastorn> Kruno: teh problem is that you need the precise versions of the C/C++ libraries that the bindings where made for
20:34:15 <ddarius> Building against C++ is a bitch.
20:34:26 <pastorn> and to get it right you probably need to download *exactly* those versions and compile it all from scratch yourself
20:34:33 <pastorn> oh the joy of wx
20:34:41 <Kruno> I am so tempted to just write the front end in C++, and then FFI it with haskell.
20:34:42 <Kaidelong> wxHaskell is IMHO too much of a pain to use
20:35:02 <pastorn> Kruno: you want to write the frontend in C, not C++?
20:35:05 <pastorn> -?
20:35:12 <Kruno> I love using lambdas in C++
20:35:22 * ddarius prefers Gtk anyway.
20:35:23 <Kaidelong> He could write a haskell server with a C++ front end
20:35:42 <Kaidelong> rather than using the FFI to drive the GUI through pushing
20:36:05 <Axman6> Kruno:really? i've only heard bad things about them
20:36:15 <pastorn> Haskell h = new Haskell("ghc");
20:36:29 <Kruno> I don't know how anyone else is using them, but they make my life easier.
20:36:53 <Kaidelong> lambda abstractions do make life easier
20:36:59 <Kruno> Indeed.
20:37:00 <Kaidelong> even delegates/function pointers do
20:37:50 <ddarius> Just write in a higher order language, defunctionalize then translate to BASIC or FORTRAN.
20:37:59 <Kruno> Can I assume the wx bindings are dead for Haskell?
20:38:15 <ddarius> You can assume whatever you want.
20:38:32 <Kruno> but would my assumption be correct?
20:38:44 <ddarius> Probably not.
20:38:49 <Kaidelong> well the page was updated just over a week ago
20:38:58 <Kaidelong> so I imagine there is still some activity there
20:39:07 <pastorn> Kruno: last version was released in may
20:39:13 <Kaidelong> I think Chalmer's uses it quite a bit
20:39:19 <pastorn> Kaidelong: no, we stopped
20:39:23 <Kaidelong> ah ok
20:39:36 <pastorn> Kaidelong: gtk now, as none of the students could compile it
20:39:50 <Kaidelong> That does not surprise me in the least
20:40:11 <Kaidelong> perhaps wx would be worth forking to get a stable interface to it
20:40:43 <pastorn> preferably depending on the versions that are in ubuntu :)
20:42:03 <Kaidelong> getting ubuntu to be stable has been a progressively harder task for me
20:45:26 <Entroacceptor> how do perl and python manage to compile against wx?
20:45:53 <Kruno> That is what I want to know.
20:46:32 <Kruno> I have one trick up my sleeve left, I will try it now.
20:46:38 <pastorn> Kruno: did you look at teh build instructions here? http://haskell.org/haskellwiki/WxHaskell
20:46:49 <Kruno> Indeed.
20:46:56 <Kruno> That is where I first went,
20:47:04 <Kruno> and I do have the wx-config binary
20:49:22 <pastorn> Kruno: OS etc?
20:49:28 <Kruno> Winblows
20:49:37 <Kruno> Vista
20:50:10 <pastorn> Kruno: only the best
20:50:32 <Kruno> lol
20:55:23 <Kaidelong> maybe I should give wxHaskell another look
20:55:37 * adu looks at wxHaskell
20:55:40 <Kaidelong> especially since I no longer spend the bulk of my time on windows
20:57:39 * adu spends bulk of time in the terminal
20:58:00 <Kaidelong> well, xterm
20:58:04 <Kaidelong> actually
20:58:07 <Kaidelong> I use terminal
20:58:09 <Kruno> Why did we ever move away from terminals?
20:58:18 * adu has no idea
20:58:19 <pastorn> ehm... we didn't?
20:58:22 <Kaidelong> Kruno: done well, GUIs are really a lot nicer
20:58:26 <Kaidelong> but I still use terminals a lot
20:58:33 <Kruno> Most UIs look like arse these days.
20:58:34 <Kaidelong> or... most of the time
20:58:42 <adu> Kaidelong: not really, information gets stuck in GUIs
20:58:45 <Kruno> Curses = Simple and elegant.
20:59:05 <Kruno> Also not an arse to get working under Windows.
20:59:13 <adu> Kaidelong: information in terminals can be piped, saved, restored, joined, tee'd, redirected, etc
20:59:22 <Kaidelong> adu: GUIs can display a lot more information at once, potentially. Microsoft Project is an example of this.
20:59:38 <Kaidelong> I have no idea how you'd do what it does well on a command line
20:59:46 <Kruno> Microsoft spend bucket loads of cash to make something look good. It is not something we could do.
20:59:58 <adu> right, but given a text box in Microsoft Project, how to you sort lines alphabetically?
21:00:01 <Kaidelong> yeah, developing a good GUI is difficult
21:00:18 <systemfault> Kaidelong: It's not... the problem is that you and me are "programmers"
21:00:19 <Kruno> Look at a lot of .NET applications made by regular developers, and they do not look good.
21:00:23 <systemfault> Not "designers"
21:00:30 <pastorn> XML + CSS is a pretty good way to make guis
21:00:45 <adu> and can you grep a project for a given regex _iff_ a given lookbehind matches?
21:00:53 <Kruno> I agree there, it brings designers and programmers closer together.
21:01:11 <Kaidelong> adu: I'm certain you could put those things into the GUI without too much effort. There is a graphical grep after all.
21:01:15 <systemfault> MS tried with XAML.. looks like it failed though.
21:01:41 <systemfault> (With XAML, it's easier to split design and code)
21:01:42 <Kaidelong> systemfault: MS half-ass tried, XAML was sabotaged by infighting
21:01:55 <Kaidelong> or so I understand it
21:02:01 <systemfault> I see 
21:02:01 <Kaidelong> all of .NET was, more to the point
21:02:23 <Kaidelong> its funding got cut because the windows people told the higher ups it was a threat to them or something
21:02:34 <mightybyte> @pl (\x -> add (f x) (g x))
21:02:34 <lambdabot> liftM2 add f g
21:02:36 <adu> MSOOXML seems to have had the same problem
21:02:40 <Kaidelong> which seems ridiculous to me
21:02:54 <Kaidelong> since .NET is less platform independent than C++ at this point
21:03:10 <systemfault> C# is a nice language I must admit.
21:03:25 <adu> I think I understand how MSOOXML got standardized now... lack of bikeshedding and the "Law of Triviality"
21:03:25 <Kaidelong> C# and F# are very nice languages. Haskell is nicer.
21:03:47 <systemfault> F# is more comparable to haskell... but C# isn't even a competitor
21:03:48 <Kaidelong> But C# has excellent tool support and Haskell... doesn't... although it has improved a lot lately on that, it seems
21:04:35 <Kaidelong> what Haskell really needs now is probably a unified framework for some of its better tools. I nominate whatever that graphical debugger was.
21:04:48 <Kruno> C# is a nice language? Possibly, but the .NET libraries make any language under .NET look homogeneous.
21:04:59 <Kaidelong> Kruno: that is not a disadvantage
21:05:11 <Kaidelong> although the Haskell platform already fulfills that role to a degree
21:05:35 <Kaidelong> GHood
21:05:39 <Kaidelong> I nominate GHood
21:05:44 <robinhoode> @pl (\(x, y) -> (f x, g y))
21:05:44 <lambdabot> f *** g
21:05:52 <Kaidelong> once I ditched the documentation and just looked at its source code, I found it awesome
21:06:24 <adu> @pl (\(x, y) -> x^2 + y)
21:06:24 <lambdabot> uncurry ((+) . (^ 2))
21:06:25 <djahandarie> robinhoode, that is from Control.Arrow btw
21:06:32 <dibblego> yeah because hoogle and pl and hlint and effect tracking and laziness and practical type system are really crap tools compared to the great tool support of C#
21:07:03 <Kaidelong> dibblego: How do you propose you bundle them? lambdabot? emacs?
21:07:20 <dibblego> bundle them?
21:07:35 <lewis1711> why is the function prototype for foldl "((a -> b -> a) -> a -> [b] -> a))", and not just (a-> [b] ->a) ....ohhh as I typed it it finally dawned on me that the first bit is the function prototype of the function you are passing to foldl...thanks for your help #haskell!
21:07:51 <Kaidelong> dibblego: where is the IDE to drive all these tools
21:08:06 <ivanm> Kaidelong: who needs an IDE?
21:08:10 <dibblego> Kaidelong, who needs such a thing? (I use leksah by the way)
21:08:29 <dibblego> what's wrong with more practical ways to "drive these tools"?
21:09:12 <Kaidelong> i do not consider a command line to be more practical than right clicking a method and selecting something like "Generate pex unit tests"
21:09:45 * ivanm has no idea what a "pex unit test" is
21:09:53 <dibblego> ivanm, pex is a joke
21:10:05 <Kaidelong> http://www.pexforfun.com/
21:10:08 <dibblego> ivanm, like quickcheck but significantly less useful
21:10:15 <ivanm> ahhh
21:10:18 <dibblego> ivanm, another example of superior tool support of C# :)
21:10:34 <monochrom> Have you written enough haskell code to get a feel of what really suits haskell, rather than just copycatting other IDEs?
21:10:38 <ivanm> how does it even pretend to autogenerate useful tests?
21:10:43 <pastorn> lewis1711: consider how to write the functions 'product' and 'sum' using folds
21:10:43 <ClaudiusMaximus> is there any package for symbolic function inversion?  i will have some complex->complex functions, and want their (possibly multi-branched) inverses...
21:10:52 <dibblego> ivanm, exactly the point
21:11:01 <ivanm> dibblego: what I figured
21:11:05 <Kaidelong> monochrom: probably just a few thousands of lines at this point, mostly in scintilla
21:11:12 <Kaidelong> I did not like any of the haskell IDEs I used
21:11:15 <Kaidelong> which is
21:11:18 <Kaidelong> Leksah and Eclipse
21:11:24 <ivanm> dibblego: unless it's merely doing the equivalent of haskell's type system
21:11:24 <monochrom> We are long past "all languages are similar" and it's time we also leave behind "all languages need similar IDEs"
21:11:45 <ClaudiusMaximus> also, is there a Language.GLSL anywhere?
21:11:48 <ivanm> even when I used Java at uni I couldn't stand to use an IDE
21:11:53 <dibblego> the idea that the existence of an IDE is a good measure of tool support undermines the idea of useful tools
21:11:55 <ivanm> admittedly, I didn't write any "Enterprise" software...
21:12:06 <ivanm> ClaudiusMaximus: what's GLSL?
21:12:07 <pastorn> ClaudiusMaximus: didn't you already build a GLSL generator?
21:12:14 <pastorn> (for a specific task)
21:12:15 <Kaidelong> dibblego: just having the tools isn't really enough if you're invoking them all on the command line
21:12:17 <monochrom> or "all languages need similar tools"
21:12:25 <ClaudiusMaximus> ivanm: opengl shader language
21:12:31 <ivanm> ahhh
21:12:33 <ClaudiusMaximus> pastorn: yes, but it's horribly ugly and specific
21:12:34 <dibblego> Kaidelong, yes it is
21:12:37 <pastorn> ivanm: Graphics Library Shading Language (part of OpenGL 2.1 and higher)
21:12:48 <ivanm> Kaidelong: *shrug* I call hoogle and pl via ghci
21:13:03 <dibblego> Kaidelong, put your clicky-fancy nonsense on top sure, but the point is about the existence of tools where C# is utterly pathetic imo
21:13:26 <ClaudiusMaximus> pastorn: it's related to the same project actually, but 100-fold better
21:13:26 <dibblego> and F# for that matter
21:13:31 <ivanm> and am quite happy to switch from emacs (editing code, running ghci and most darcs repo management) to a terminal for doing overall package building, etc.
21:13:33 <pastorn> ClaudiusMaximus: hehe, nice
21:13:33 <monochrom> if you still speak like "method" you're still shoehorning alien languages into haskell
21:14:00 <pastorn> ClaudiusMaximus: it shouldn't be too hard to write a .cf file for it using bnfc
21:14:05 <Kaidelong> wouldn't it be nice to have a docking window with hood displays or a list where you can test propositions via a wizard?
21:14:05 <Kaidelong> simple things like that
21:14:08 <pastorn> then you have a parser & pretty printer
21:14:20 <dibblego> Kaidelong, no
21:14:51 <pastorn> ClaudiusMaximus: *for* bnfc
21:15:31 <Kaidelong> dibblego: I mentioned from the start that it didn't really seem like tool support was the problem anymore
21:15:49 <ivanm> does hood even build/work nowadays?
21:15:58 <ClaudiusMaximus> pastorn: hm, will check it out, got a link?
21:16:05 <Kaidelong> ivanm: GHood does at any rate
21:16:06 <dolio> People actually use pl for writing programs?
21:16:13 <Kaidelong> the documentation is awful though
21:16:17 <ivanm> dolio: I do occasionally to see if there's a nicer way of writing things
21:16:24 <dibblego> Kaidelong, I just saw a comment that haskell has poor tool support while C# does not and I am trying to find a proposition in my feeble imagination that is further from the truth
21:17:06 <Kaidelong> I said it has improved a lot lately and what it needs now is more a framework for the tools it has already
21:17:20 <ivanm> Kaidelong: in terms of something like that, AFAICT you have four main options: adding support to haskell-mode in emacs (admittedly not really a GUI solution), hacking on leksah, hacking on manatee and writing Yet Another Haskell IDE
21:17:35 <Kaidelong> I think Leksah is the most promising right now
21:17:36 <systemfault> YAHI!
21:17:39 <Kaidelong> but it is not ready yet
21:17:46 <systemfault> Not a bad name for an IDE
21:17:46 <dibblego> Kaidelong, sure, it has more tool support than probably every language I know of, but I don't see the need to put clicky buttons on what is better used by composition
21:17:50 <dolio> What Haskell needs is an Agda-like editor.
21:18:04 <dolio> Of course, that's just Emacs.
21:18:06 <Kruno> No offense, but I ran Leksah and deleted it almost immediately after looking at it.
21:18:20 <Kruno> Emacs is what I use for Haskell and Lisp.
21:18:26 <Kaidelong> Kruno: It improved a bit in the latest version
21:18:30 <Kruno> 0.8?
21:18:48 <Kaidelong> Yeah
21:18:57 <Kruno> That's what I was using.
21:18:58 <ivanm> systemfault: yeah, I did it that way specifically to get a useful acronym out ;-)
21:19:06 <monochrom> manatee is the hope of tomorrow
21:19:13 <dibblego> leksah is full of bugs and missing use cases
21:19:19 <Kaidelong> I think a better project system might be nice for it, although that might be a limitation of cabal and not leksah, I don't know
21:19:20 <ivanm> monochrom: do you use it?
21:19:24 <monochrom> no
21:19:38 <ivanm> you're just interested in it then?
21:19:45 <systemfault> :)
21:19:49 <monochrom> I don't know.
21:20:08 <Kaidelong> I have used Leksah and decided to go back to Scintilla and vim
21:20:24 <Kruno> Why Scintilla and Vim?
21:20:25 <ivanm> monochrom: then why call it the hope of tomorrow?
21:20:36 <monochrom> it is active
21:20:39 <ivanm> ahhhh
21:20:41 <Kaidelong> Kruno: I'm familiar with them, basically. And Leksah did not impress me at all
21:21:13 <systemfault> Kaidelong: Same... still using good old vim :/
21:21:46 <monochrom> I don't have to use anything myself to know trends.
21:22:15 <monochrom> facebook, reddit, stackoverflow... I don't use them and I can still tell you whether they're going up or down.
21:22:43 <Kaidelong> anyway, a nice graphical interface is good to have. A bad one can be worse than useless.
21:22:55 <Kaidelong> Personally I think Visual Studio is actually a relatively nice one
21:23:45 <systemfault> Visual Studio is the best IDE I know... (And I don't even use Windows anymore)
21:24:50 <Kaidelong> that is pretty much my situation
21:25:10 <Kaidelong> so I don't use IDEs much at all
21:25:27 <Kaidelong> but *it would be nice* if there was a good one for Haskell, which there isn't
21:27:17 <Kaidelong> unless Eclipse FP has gotten a lot better
21:30:36 * hackagebot network-enumerator 0.1.1 - Enumerators for network sockets  http://hackage.haskell.org/package/network-enumerator-0.1.1 (JohnMillikin)
21:30:45 <ksf_> there's leksah, but it lacks a good editor.
21:31:00 <ksf_> there's rumors of yi integration, but yi's vi is a joke
21:31:26 <ksf_> the whole thing's written by someone who's never seen ex mode.
21:31:41 <Kaidelong> Isn't yi quite buggy anyway?
21:31:51 <ksf_> nah
21:32:18 <ksf_> it could be faster around the corners, and possibly has a leak or two affecting long-term use, but not general buggyness.
21:32:38 <Kaidelong> oh alright, minor performance bugs then but I shouldn't have been scared of actually using it
21:33:07 <ksf_> I've never had it wreck a file or such if you were thinking of such stuff.
21:33:32 <Kaidelong> ksf_: mostly it segfaulting or something while I was working on something
21:33:37 <Kaidelong> since that would mean losing work
21:33:52 <ksf_> ...I've used the vty backend, though.
21:35:32 * Kaidelong heads to the Eclipse gentoo wikipage and gets to work on taking another look at Eclipse FP
21:35:47 <systemfault> Eclipse FP?
21:35:54 * systemfault googles
21:36:42 <systemfault> Looks dead.
21:37:04 <systemfault> Ah no, alive and still kicking
21:37:21 <systemfault> It just changed maintainer
21:39:07 <ksf_> last push to code.haskell.org/yi/src was august 2009
21:39:46 <systemfault> Looks pretty dead to me :(
21:40:19 <ksf_> last hackage release is july 2010, though.
21:41:22 <Kaidelong> well so much for that plan
21:41:37 <Kaidelong> Or maybe not, I guess I could downgrade to 6.10
21:41:51 <ivanm> I think eclipsefp has a new name now
21:41:55 <Kaidelong> then again it'd be a problem if haskell-updater breaks eclipsefp
21:41:56 <systemfault> Kaidelong: For yi?
21:42:01 <ivanm> and that you need to look for it within eclipse's plugin system
21:42:04 <Kaidelong> systemfault: for scion
21:42:15 <systemfault> Last commits for EclipseFP2 are a few days ago
21:42:16 <systemfault> Ahhh
21:42:19 <ivanm> Kaidelong: oh, apparently scion from git is more up-to-date
21:42:30 <edwardk> eelis: not by design, by quickly slapping it together and not yet writing a test suite =)
21:42:46 <ivanm> we haven't been bothered to write an ebuild for it though as it's too much effort for something that hasn't had a release in so long
21:45:39 <edwardk> eelis: going through and adding the strictness patches.
21:45:58 <Kaidelong> @where sockets
21:45:58 <lambdabot> I know nothing about sockets.
21:46:19 <ksf_> the yi core code needs separation from the problematic stuff, ui and configuration, that is.
21:46:52 <ksf_> hmm.
21:47:29 <ksf_> going full server might be nice. only start one yi per user and have a thin client display different buffers.
21:47:53 <ksf_> that way e.g. sharing the clipboard between terminals is easy.
21:48:42 <Kaidelong> does yi have a graphical front-end?
21:48:47 <Kaidelong> if it doesn't, that might help with that
21:48:52 <ksf_> yeah, but I wouldn't recommend it.
21:49:04 <Kruno> I have an off topic, and silly question. can you emphasize binary space optimisations under ghc? -O1 + -O2 afaik are the same thing
21:49:19 <Kruno> sort of like GCC's -O1
21:49:31 <ksf_> Kruno, you can compile with -fvia-C or -fllvm and have those optimise for size.
21:49:46 <Kruno> THanks! I didn't know that.
21:50:29 <ksf_> -O1 should be smaller than -O0, but -O2 might increase stuff again.
21:50:48 <ksf_> though there might be cases were -O0 is smallest.
21:50:57 <systemfault> ghc doesn't have Os?
21:51:04 <ksf_> nope.
21:51:04 <systemfault> (I never checked)
21:51:08 <systemfault> k
21:51:23 <Kaidelong> is Hugs still maintained?
21:52:05 <Kaidelong> well I suppose you'd have to host the runtime anyway which might offset any improvement on binary size
21:52:27 <ksf_> the runtime is compiled to code, too.
21:52:49 <ksf_> just like the libc
21:53:10 <ksf_> s/code/straight code
21:53:56 <Kaidelong> last release of Hugs was 5 years ago
21:54:04 <Kaidelong> so I imagine it isn't really an option
21:54:30 <ksf_> well, it's generally bug-free
21:54:50 <ksf_> and h98 was stable, back then
21:56:09 <ksf_> Kaidelong, but in reality you want to learn vim.
21:56:32 <Kaidelong> ksf_: Fortunately for me, that's what I tend to use
21:56:54 <Kaidelong> although as of this point, without any syntax highlighting for haskell let alone any integration with haskell tools
21:58:10 <adnap> could someone try to install the fieldtrip library for me?  i'm getting an error, and i would like to know if it is specific to me.
22:00:24 <ksf_> there's been maintenance yi patches up to december 2010, though.
22:00:39 <ksf_> I think a good term is "hibernation"
22:00:58 <ksf_> adnap, if you want to try fieldtrip with reactive, forget it, reactive is broken
22:01:09 <mkscrg> any current info on the 2011.2.0.0 release of the haskell platform?
22:01:10 <adnap> ksf_: it's broken?
22:01:10 <ksf_> and fieldtrip has GLdouble issues
22:01:18 <ksf_> yep.
22:01:24 <mkscrg> the timetable page seems to list milestones from december as un-met
22:01:24 <adnap> in what way?
22:01:51 <ksf_> conal knows all the details
22:01:55 <ksf_> (which I don't understand)
22:02:07 <adnap> is it fundamentally broken?
22:02:51 <ksf_> as in "doesn't work for http://www.haskell.org/haskellwiki/Reactive/Tutorial/A_FPS_display ", yes.
22:03:07 <adnap> that's awful
22:03:18 <conal> adnap: there were some subtle (difficult for me to track down) bugs. some were ghc run-time system bugs, and probably some were subtle laziness/termination issues.
22:03:20 <adnap> it hasn't been updated since july 28th
22:03:29 <adnap> conal: hey!
22:03:37 <conal> adnap: hi
22:04:01 <adnap> conal: have these bugs existed since the beginning of reactive?
22:04:22 <conal> adnap: as for fieldtrip, i kept hoping sven would fix hopengl to make some of the type classes to export their methods so i can make instances for float & double.
22:04:39 <conal> adnap: hard to tell (age of bugs)
22:04:51 <adnap> conal: yeah, when i try to install fieldtrip, i get complains about exports in opengl
22:04:57 <adnap> conal: *complaints
22:05:18 <conal> adnap: oh. maybe different from what i've seen.
22:05:36 <adnap> conal: maybe a newer version of opengl broke something?
22:06:01 <adnap> src/Graphics/FieldTrip/Vector2.hs:29:48: Module `Graphics.Rendering.OpenGL.GL.CoordTrans' does not export `Vector2(..)'
22:06:17 <ksf_> adnap, those are just moves iirc.
22:06:21 <conal> hm. i don't remember that one.
22:06:34 <ksf_> that is, you can switch to importing Graphics.Rendering.OpenGL
22:06:49 <conal> i'll take a look
22:07:15 <adnap> conal: so, you have plans to fix reactive in the future, but you are waiting on the opengl bindings to be fixed?
22:08:05 <adnap> ksf_: this happens when i "cabal install fieldtrip"
22:08:17 <adnap> ksf_: i guess i could just get an older opengl version?
22:08:21 <conal> adnap: separate issues. reactive doesn't use opengl, though reactive-glut and reactive-fieldtrip do. 
22:08:37 <ksf_> wait I should have a version.
22:09:20 <conal> adnap: i'll look again at reactive at some point. was terribly hard for me to debug. will probably have to redesign some aspects for less operational subtlety.
22:09:29 <adnap> conal: oh, my mistake.  the reactive problems are due to ghc bugs?
22:09:30 <conal> without compromising the semantic correctness.
22:09:41 <conal> adnap: at least some were
22:10:02 <adnap> conal: i don't understand.  have they been fixed?  are you still developing reactive?
22:11:25 <conal> adnap: some ghc bugs have been fixed. i don't know if there are others that affect unamb/lub and reactive. i'm not actively working on reactive. i'll probably get back to it at some point. or maybe someone else will come along and get interested and have some good insights.
22:11:38 <adnap> conal: aw
22:12:15 <conal> so far, afaik, people who've delved into reactive have spun off their own dev efforts instead. and i don't think anyone has successfully implemented the semantics correctly.
22:12:21 <conal> i do believe it can be done.
22:13:26 <adnap> man, this is so disappointing.  i hope the issues are solved.  i've had pretty bad luck trying to find a practical avenue for developing interactive graphics programs in haskell.
22:13:36 <cdsmithus> So, whilst realizing that I should be drawn and quartered for this, I'd like to write isBottom :: a -> Bool, for code testing purposes.  I only care about bottoms that are detected by GHC.  How would I do that?
22:14:02 <conal> adnap: is your goal to use haskell or to program functionally/denotatively?
22:14:05 <adnap> i've tried some other libraries for other purposes, like gpipe, only to discover that performance was absolutely terrible.
22:14:25 <conal> adnap: oh, drag. i haven't tried gpipe.
22:14:25 <conal> a
22:15:03 <adnap> conal: i wanted to use haskell to make things easier, and in the process, possibly learn new ways of programming (such as with reactive)
22:15:53 <adnap> conal: i've read a few posts on your blog, and while it didn't make sense at first, i think i'm sort of understanding one of the points you make about functional semantics
22:16:30 <Enigmagic> cdsmithus: try chasingbottoms on hackage?
22:17:26 <cdsmithus> Enigmatic: That looks exactly like what I wanted.  Thanks!
22:17:48 <conal> adnap: denotative programming about types having precise meaning. and then being able to reason precisely and tractably. rather than just hacking w/o clear meaning, as in imperative programming--including haskell IO.
22:18:04 <adnap> conal: i guess it just wasn't clear until i saw your approach to some things.  i'll try my best to paraphrase the idea.  you would like to see people develop more api's where the semantics themselves are functional and operations compose together nicely, rather than...
22:18:09 <ksf_> adnap, conal, http://ifile.it/xbf26l3/reactive-gl-stuff.tar
22:18:41 <bitstream0101> Can someone enlighten me about the meaning of these errors?  http://hpaste.org/42998/type_family_errors 
22:18:47 <ksf_> those *should* compile with recent opengl and ghc
22:19:01 <adnap> conal: well, i don't know how to describe the alternative.  i guess io is one example, but also purely functional api's without true functional semantics
22:19:07 <bitstream0101> I'm sure it's because there are different 'sym' types involved in the invocation of dr on the last line, but I don't know how to force them to be the same :()
22:19:42 <conal> adnap: "purely functional" is a pretty vacuous notion afaict.
22:20:06 <ksf_> ooooh gpipe performance.
22:20:16 <adnap> oh yeah, let me tell you about that
22:20:18 <adnap> it sucks
22:20:40 <conal> adnap: since even c programming is purely function in the same technical sense that haskell-with-IO programming is. see http://conal.net/blog/posts/the-c-language-is-purely-functional/
22:20:44 <adnap> i've e-mailed the guy who made it and proposed some ideas that he thinks might improve it, but he's no longer actively developing the project
22:20:52 <conal> purely functional*
22:20:58 <adnap> conal: yeah, i read that
22:21:05 <ksf_> even worse, the code is a mess
22:21:23 <adnap> ksf_: i really like the api though
22:21:24 <conal> adnap: on the other hand "denotative" is a substantive notion.
22:22:19 <conal> adnap: and i think denotative is the essence of what made functional programming good for reasoning before there was IO.
22:22:20 <Kaidelong> with my latest (.NET) project, "purity" seems to be an important thing to maintain, although perhaps "repeatability" is a better word
22:22:25 <adnap> conal: yeah, i'm still sort of trying to grasp the idea of denotative semantics
22:22:41 <Kaidelong> but without it we wouldn't be able to test our optimization algorithms well against each other
22:23:23 <adnap> i made a simple program to test gpipe that draws triangles zig-zagged on the screen
22:23:40 <adnap> then i made the same program using hopengl
22:23:40 <conal> adnap: denotational semantics (DS) has some difficult/deep aspects (domain theory), but you don't need much understanding of those aspects to make good use of DS.
22:24:12 <adnap> conal: yes, it seems easy enough to use some of your api's, but coming up with the ideas seems a lot harder
22:24:19 <conal> adnap: the main idea is to give a precise (and simple as possible) meaning to each of your types. and then define the meaning of each operation solely in terms of the meanings of the arguments. ie "compositional".
22:24:47 * ksf_ is hoping for nicer cuda-based stuff and gallium drivers that make my card cuda-compatible.
22:25:00 <ksf_> or a new gfx card, fwiw.
22:25:11 <conal> adnap: it's a style of thinking. and i've been thinking that way for > 25 years.
22:25:11 <adnap> i think it was with something like 10000 triangles that the hopengl program gave me ~450 fps while the gpipe program gave me ~40 fps
22:25:13 <ksf_> (which means a whole new box)
22:26:00 <Kaidelong> now might be a good time to do that
22:26:10 <adnap> conal: yeah, it really is a style of thinking.  i thought everything in haskell was automatically great, because it's functional, and has all the type checking, but there really is a whole lot more you get from good semantics
22:26:14 <conal> adnap: i always ask "what is it?" (or "what does it mean?") before "how does it work?"
22:26:58 <adnap> conal: i see the way you build things up in some of your posts, and infer the meaning of some operators solely based on types.
22:27:24 <conal> adnap: i wish more people realized that "functional" is nearly meaningless, so they'd be less satisfied and go back to denotative thinking.
22:27:31 * ksf_ starts by asking "what do I definitely need?"
22:28:06 <ksf_> ...then build a loose agglomeration of different pieces of code, squint, and hopefully they fit in a way that gives some insight.
22:28:25 <adnap> conal: actually, i think it was in the reactive paper that i saw this.  i was trying to learn about reactive and you did something like this: you were trying to write an instance of something like Monad or Applicative, and you just put some dummy operator in place, and then you inferred the meaning of the dummy operator based on other things
22:28:32 <Kruno> wx haskell is byuilding...
22:28:41 <Kruno> got further  than before
22:28:50 <conal> adnap: yeah! :)
22:28:52 * Kruno prays
22:28:59 <conal> Kruno: :)
22:29:17 <john_r_watson> @src foldl
22:29:17 <lambdabot> foldl f z []     = z
22:29:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:29:31 <adnap> conal: oh, it was the applicative instance for future values
22:29:34 <john_r_watson> @where foldl
22:29:34 <lambdabot> I know nothing about foldl.
22:29:36 <conal> adnap: more and more i find i can discover rather than invent. by tuning into some very general themes like type class morphisms.
22:29:46 <conal> adnap: yeah. that one worked out very nicely.
22:29:57 <Kruno> if this works I am going to have to edit the wiki
22:30:26 <adnap> conal: i don't really understand what type class morphisms are entirely yet.  it seems like you use this a lot when you talk about operations that distribute over basic laws in other type classes
22:30:30 <conal> often i see glimmers of patterns and then tease them out as clearly as i can. starts off as an aesthetic exercise and becomes something more.
22:30:36 <adnap> conal: *use this term
22:31:13 * conal always appreciates a noun for every "this".  thanks.
22:31:32 <adnap> conal: "this term" would be "type class morphism"
22:31:49 <Kruno> DONE!
22:32:13 <conal> adnap: yeah. i was appreciating your "this term". so many folks leave dangling "this"s. i kill them all in my writing.
22:32:16 <adnap> conal: i don't really understand what it means yet, but you were using it when talking about operations that distribute over basic laws in other type classes.  like "ap"
22:32:20 <conal> adnap: have you read the TCM paper? it's the clearest exposition i've written about my methodology.
22:32:31 <Kaidelong> Kruno: you got wxHaskell to build?
22:32:40 <Kruno> yes
22:32:54 <adnap> conal: i don't think so.
22:32:58 <Kaidelong> let me see if I can repeat that feat here
22:33:19 <conal> adnap: it was in writing the reactive paper that i discovered the TCM pattern. came purely from aesthetics. i was tweaking my semantic definitions to read more poetically.
22:33:47 <Kruno> working!
22:33:49 <conal> adnap: now TCM is a central design tool for me. when TCM works, i know i'm on a good track. when it doesn't, i know i have design bugs.
22:34:02 <conal> TCM failure always means an abstraction leak.
22:34:10 <Kruno> now i need to finish dinner and change some things in wxHaskell wiki
22:34:49 <Kruno> it is very easy to get wx working, but there is some stupid information that misleads
22:34:58 <adnap> conal: i hope i can get to where i'm thinking like this often.  i'm still quite a haskell noob.  it's been about a year since i've started learning.  i'm at the point where i understand all the basic type classes, but i haven't really put them to good use yet.
22:35:04 <conal> adnap: see http://conal.net/papers/type-class-morphisms/. and let me know if you have any questions.
22:35:12 <adnap> conal: "this", meaning, in the way that you do 
22:35:28 <conal> :)
22:36:34 <adnap> conal: have you ever used Data.Vec?  I was using that before in my haskell graphics programs, but then i came across your linear algebra package, and i think it might be better.  it seems more abstract, with affine spaces and all.
22:36:51 <Kruno> how the hell do i remove the stupid console when running wxhaskell?
22:37:01 <adnap> conal: and in one of your libraries, you already wrote instances for opengl's vector and point types
22:37:13 <Kruno> i remember there being a compiler flkag
22:37:26 <conal> adnap: also check out http://lukepalmer.wordpress.com/2008/07/18/semantic-design/ as an intro to what i now call "denotational design". (i used to call it "semantic design".)
22:37:55 <adnap> conal: thanks, i'll add these to my bookmarks
22:38:35 <conal> adnap: i've not used Data.Vec, though i use something similar for statically length-typed sequences. for my functional->gpu compiler.
22:39:25 <conal> well, similar except for the zillion class instances. Data.Vec is pretty thorough!
22:40:57 <adnap> conal: there's Data.Vec, Data.Vec.LinearAlgebra, and Data.Vec.LinearAlgebra.Transform3D i think.  i've been using all of these for linear algebra, but the other night i was looking over your api for vector spaces, and i think i might switch.  i thought i would try to port some of my other programs to using your api's to see how well they work.
22:40:59 <conal> adnap: luke's blog post will give you a flavor of denotational design. probably worth reading before my TCM paper.
22:42:26 <adnap> conal: okay, cool.
22:43:00 <bitstream0101> Anyone feel like taking a peek at some possibly-type-family errors? Might just be -- and probably is -- naivete on my part ;P http://hpaste.org/42998/type_family_errors 
22:43:27 <conal> these days i'm mainly thinking about parallel programming. noodling over how to semantically tame CUDA.
22:44:53 <conal> for a few weeks now, i've been playing with parallel prefix scan. figuring out how to derive the tricky algorithm in http://http.developer.nvidia.com/GPUGems3/gpugems3_ch39.html
22:45:35 <conal> a lot of work for one algorithm. hoping my insights will apply to other parallel imperative algorithms as well.
22:46:42 <conal> there's a beautiful, elegant, functional algorithm hiding behind that crufty imperative code.
22:47:47 <adnap> conal: do you know much about the other frp api's?
22:48:14 <conal> adnap: not nearly as much as about my own.
22:48:33 <conal> adnap: e.g., i've never programmed with yampa.
22:50:23 <adnap> conal: you said in your paper that the semantics of reactive lead to a more efficient implementation than past attempts.  since reactive is broken at the moment, i'm wondering if there is an efficient alternative to frp, or if i should just stick to io for my programs for the current time.
22:50:56 <conal> adnap: ask around about yampa.
22:51:27 <adnap> conal: okay
22:52:13 <conal> adnap: if you ask at various time of the day, you'll find a few people on this channel who've used yampa or are using it currently
22:53:09 <Kaidelong> That blog post got me thinking on an approach to alpha blending, would (Monoid m) => (a -> m) itself be a monoid?
22:53:52 <conal> adnap: and you can still play with the essential ideas behind frp. which for me are (a) precise & simple denotation and (b) continuous time.
22:54:05 <Kaidelong> because I could imagine two monoid instances for alpha blending (below and above)
22:54:13 <conal> adnap: if you like thought experiments.  (i do.)
22:54:15 <Kruno> I am really surprised that +RTS -N allows all my cores to be used, now is there a way to make this behaviour default, without me specifying command arguments?
22:54:51 <adnap> conal: yeah, i was really starting to get a grasp on your types, behavior and event, and the overall api.
22:54:56 <conal> Kaidelong: i guess all non-commutative monoids have these two variants.
22:55:04 <conal> adnap: cool :)
22:55:08 <Kruno> Kaidelong: Monoids to do alpha blending sounds good. I have been screwing around with Monads/oids and haven't really come to a conclusion where they would be effective.
22:55:47 <Kruno> I see them as a transformation, more than anything else.
22:56:06 <Kaidelong> @ty liftA2
22:56:07 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
22:56:14 <adnap> lyah, where i learned about monads, always talked about monads as "a context"
22:56:22 <Kaidelong> @instances Applicative
22:56:22 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
22:56:34 <conal> i'm off to bed now. catch you all later.
22:56:39 <Kruno> l8r
22:56:43 <conal> adnap: good luck. let me know how it goes.
22:56:45 <c_wraith> @instances-importing Control.Applicative Applicative
22:56:46 <lambdabot> ((,) a), ((->) a), Const m, ContT r m, Either e, ErrorT e m, IO, Maybe, ReaderT r m, StateT s m, WrappedArrow a b, WrappedMonad m, WriterT w m, ZipList, []
22:56:48 <Kaidelong> sleep well
22:56:50 <adnap> later and thanks for the info!
22:57:01 <Kaidelong> excellent ((->) a)
22:57:08 <Kaidelong> ok
22:57:20 <Kaidelong> @ty liftA2 mconcat
22:57:20 <lambdabot> forall b c (f :: * -> *). (Monoid c, Applicative f) => f [b -> c] -> f b -> f c
22:57:31 <Kaidelong> err
22:57:36 <Kaidelong> @ty liftA2 mappend
22:57:37 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
22:57:45 <Kaidelong> perfect
22:57:53 <adnap> oh, i was just talking about that the other day in here
22:58:04 <adnap> liftAT mappend will append the results of the functions
22:58:23 <Kaidelong> so if you make a monoid for alpha blending you can blend together shapes in a very nice way
22:58:33 <dibblego> http://hackage.haskell.org/packages/archive/Semigroup/0.0.5/doc/html/src/Data-Semigroup.html#%3C%2B%2B%3E
22:58:40 <Kaidelong> if the shapes are of the form Point -> AlphaPixel or something
22:59:13 <adnap> aren't there various ways to define mappend for alpha blending?
22:59:38 <Kaidelong> yes but you could choose one and then rely on the order in which shapes are given
22:59:47 <Kaidelong> or that's the idea I have, anyway
23:00:22 <adnap> man, i'm so bummed about reactive
23:00:47 <adnap> i think i'll still write some programs using it just to see how they would work ideally
23:01:34 <Kaidelong> adnap: couldn't you still program in a reactive style without importing reactive?
23:01:43 <Kaidelong> although I suppose that'd require some wheel reinvention
23:04:54 <Kaidelong> hmm, so "monoid" is weaker than "group" (which is too specific to be expressed in the haskell type system) and "semigroup" is weaker than "monoid"?
23:04:58 <adnap> Kaidelong: i don't fully understand how reactive is implemented, so it would be hard for me.  also, i was planning on using it with glut, which is all tied up with io.  reactive has a nice adapter for glut.  i guess i'll need to build something cleaner on top of all the nasty io.
23:05:39 <Obvious> Kaidelong, yes, semigroup doesn't have identity requirement
23:05:47 <jmcarthur> monoid is expressible in the type system no more than group is
23:06:01 <Kaidelong> I suppose that's true
23:06:08 <adnap> man, i'm going to be so prepared for my algebra class this semester
23:06:12 <Kaidelong> haskell doesn't enforce the properties of mzero
23:06:16 <Kaidelong> err
23:06:19 <Kaidelong> mempty
23:06:31 <jmcarthur> or associative property
23:06:42 <Kaidelong> in which case Semigroup has the same problem
23:06:44 <adnap> or hardly anthing else in standard classes, right?
23:06:45 <jmcarthur> right
23:06:52 <adnap> like the monad laws and such
23:07:03 <Kaidelong> so I guess it's vacuous
23:07:08 <Kaidelong> most everything is too specific
23:07:10 <jmcarthur> it's common to put the burden of proof on the programmer when creating type class instances
23:07:13 <Kaidelong> but we do it anyway
23:07:50 <Kruno> So we have to mathematically prove our own type classes?
23:08:09 <Kaidelong> Well that might be difficult to do in practice
23:08:25 <Kaidelong> you could do empirical tests?
23:08:45 <Kruno> An Excel spreadsheet. lol
23:08:51 <adnap> i think people are always working on auto checkers
23:09:17 <adnap> program verification, etc.
23:09:20 <Kruno> What is stopping you adding a Matrix as a monad?
23:09:32 <Kruno> we know that matrices are not associative
23:09:37 <Kruno> via *
23:09:42 <adnap> no monoid
23:09:47 <adnap> wait
23:10:28 <adnap> matrices are not associative?
23:10:49 <adnap> rather, matrix multiplication
23:10:53 <Kruno> a*b != b*a
23:11:07 <sipa> thats commutativity
23:11:08 <shachaf> Kruno: That's not associativity.
23:11:09 <adnap> that's commutativity
23:11:15 <adnap> lol
23:11:30 <adnap> i'm pretty sure multiplication is associative
23:11:33 <Kruno> (a*b)*c = a*(b*c)
23:11:34 <Kruno> sorry
23:11:35 <sipa> matrix multiplication is associative
23:11:39 <Kruno> Im wrong
23:11:43 <adnap> i think it is also commutative for some invertible matrices?
23:11:45 <sipa> yes
23:12:14 <sipa> but some isnt enough
23:12:21 <adnap> but monoid doesn't have a commutative operation, so you could proably define matrix to be a monoid, since all it needs is the identity and an associative operation
23:12:32 <adnap> i think a bunch of libraries have done this
23:13:52 <adnap> http://hackage.haskell.org/packages/archive/FieldTrip/0.2.4/doc/html/Graphics-FieldTrip-Transform3.html
23:13:59 <adnap> transform3 is a monoid
23:14:26 <ksf_> I'm pretty sure you want more complex type for matrixes
23:14:49 <ksf_> one that tracks their dimension, so that you can reorder them to safe insns
23:14:59 <adnap> yeah
23:15:12 <adnap> for graphics though, you can make a lot of assumtions about the matrices
23:15:23 <adnap> hmatrix defines a more general matrix type, which i think is also a monoid
23:16:24 <Kruno> Anyone who wants to get wx working under Windows, here it is:
23:16:25 <Kruno> http://haskell.org/haskellwiki/Talk:WxHaskell/Building#WxHaskell_Windows_issue.
23:16:37 <Kruno> later guys
23:17:24 <adnap> lata
23:37:15 * hackagebot AttoJson 0.5.9 - Simple lightweight JSON parser, generator & manipulator based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.9 (HiromiIshii)
23:39:16 * hackagebot streams 0.1.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.1.1 (EdwardKmett)
23:41:42 <edwardk> adnap: matrix multiplication isn't monoidal unless you have square matrices. now. you can make a category out of them though =)
23:47:14 <dolio> Ooo, now we have Stream and streams.
23:47:24 <dolio> Almost as good as Numbers and numbers.
23:47:35 <edwardk> dolio: i have a slightly different set of package goals than the 'Stream' package
23:47:41 <edwardk> so its not really a fair comparison.
23:47:58 <edwardk> besides we also have Heaps and heaps and Semigroup and semigroups, etc
23:48:35 <edwardk> it is unlikely that i could get wouter to sit down and define a couple dozen stream types and make them all comonads for me ;)
23:48:36 <dolio> Of course, there's also stream-fusion (which is about lists) and stream-monad (which is about nondeterminism).
23:48:41 <edwardk> yeah
23:49:31 <edwardk> i was actually kicking around including the monadic stream fusion stuff, but i felt it'd drag me way too far afield
