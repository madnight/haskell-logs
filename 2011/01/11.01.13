00:05:55 * hackagebot eq 0.1.3 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.1.3 (EdwardKmett)
00:16:51 <robinhoode> @pl (\(x, y, z) -> (f x, g y, h z))
00:16:51 <lambdabot> (line 1, column 8):
00:16:52 <lambdabot> unexpected ","
00:16:52 <lambdabot> expecting letter or digit, operator or ")"
00:16:52 <lambdabot> ambiguous use of a non associative operator
00:17:15 <edwardk> @pl \(x, y, z) -> (f x, g y, h z)
00:17:16 <lambdabot> (line 1, column 7):
00:17:16 <lambdabot> unexpected ","
00:17:16 <lambdabot> expecting letter or digit, operator or ")"
00:17:16 <lambdabot> ambiguous use of a non associative operator
00:17:24 <edwardk> ah because of the ternary operator
00:17:26 <triyo> Good morning. I'm back for round two with regards to the "List leads off with letter...". I now understand clearly how ... x |> list = (x:) . list ... definition works for consing to the front of the list using function composition. However, consing to the end of the list, I don't quite get it. Definition looks really simple: ... list <| x = list . (x:)
00:17:33 <edwardk> there are no combinators for taking apart triples
00:17:49 <robinhoode> Should there be?
00:17:58 <triyo> btw, I'm referring to this post: http://logicaltypes.blogspot.com/2010/09/list-leads-off-with-letter-lambda.html
00:18:07 <edwardk> robinhoode: but then you need a set for 4-ary tuples, etc.
00:19:31 <Entroacceptor> @src |>
00:19:32 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:19:38 <Axman6> triyo: the end of list function only works when you pass in an empty list
00:20:30 <triyo> Axman6: hmm would you be so kind to explain a bit.
00:20:51 <edwardk> what the post there describes is a different list
00:20:56 <edwardk> er difference
00:21:29 <Axman6> so if you write something like (5 |> 6 <| 7 |> 8) you should end with something that looks like (5:) . (6:) . (8:) . (7:) (not sure if this code actually works, but hopefully it illustrates what's going on)
00:21:38 <edwardk> the only thing you should do to the list you are given is prepend to it, that gives you cheap append, etc. but if you use that 'last' construction he gives, the only list youa re allowed to supply is the empty list
00:21:40 <Axman6> yeah that code is bung
00:22:18 <Axman6> say you have foo = 5 |> 6 |> 7 |> empty
00:22:25 <Axman6> treat foo as a 'list'
00:23:01 <Axman6> if you 'look' at what foo actually equals, we see that it is (5:) . (6:) . (7:) . id
00:23:41 <Axman6> if we write foo <| 10, then then end up with foo . (10:), or (5:) . (6:) . (7:) . id . (10:)
00:23:44 <triyo> I see auther has an example: (empty <| 1 <| 2 <| 3) [4,5,6] .... and for me that doesn't even evaluate in ghci
00:24:01 <triyo> *author
00:24:02 <Axman6> why not?
00:24:44 <triyo> oops wrong one. I mean the "consing to front" example
00:24:46 <triyo>  (5 |> 6 |> 2 |> empty) [1,2,4]
00:24:46 <edwardk> actually the definition he gives appears sound
00:25:24 <edwardk> he doesn't violate the rules of what you are allowed to do with a difference list in the post
00:25:25 <triyo> No instance for (Num (a1 -> [t]))       arising from the literal `6' 
00:25:57 <Axman6> hmm
00:26:17 <Axman6> did you add the correct infix declarations when you defined |> and <|?
00:26:35 <triyo> hmm most probably not.
00:26:39 <edwardk> <| is applied only to a difference list and not a real list
00:26:39 <edwardk> you want infixr 5 <|    and infixl 5 |>
00:26:52 <triyo> oh I see
00:26:53 <edwardk> that'll give the former the same precedence as :
00:27:06 <edwardk> and the latter the opposite fixity but same precedence
00:27:30 <edwardk> (and prevent you from accidentally saying 5 |> empty <| 7
00:28:07 <Axman6> wouldn't you want to be able to do that?
00:28:23 <edwardk> you can't, or one side or the other gets busted precedence
00:28:49 <Axman6> hmm
00:28:51 <edwardk> you either have to lower one to 5 in which case yous tart trompling equalities, or raise one to 6 in which case you start trippling up +'s
00:29:07 <Kaidelong> > map (^2) [[1],[2],[3]]
00:29:08 <lambdabot>   No instance for (GHC.Num.Num [t])
00:29:08 <lambdabot>    arising from a use of `e_12123' at <in...
00:29:15 <edwardk> or you have to make them both associate to the right or the left in which case one always requires parens on every application after the first
00:29:20 <Kaidelong> I see lambdabot does not know about type compositio
00:29:44 <Kaidelong> oh wait
00:29:47 <Kaidelong> no
00:30:00 <Kaidelong> oh
00:30:15 <Kaidelong> no you should be able to use type inference to figure that out
00:30:33 * Kaidelong goes to try this
00:31:14 <Maxdamantus> > map . map (^2) $ [[1],[2],[3]]
00:31:16 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
00:31:33 <triyo> hm, infixl 5 |> and infixr 5 <| doesn't seem to work for me, I still get the error.
00:31:47 <Maxdamantus> > map $ map (^2) $ [[1],[2],[3]]
00:31:47 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[[t]]'
00:32:02 <triyo> Now I get it on both |> and <|
00:32:06 <Eelis> edwardk: thanks :)
00:33:06 <edwardk> eelis: that should fix the immediate strictness problems you were having. i couldn't find any more off hand in NonEmpty
00:33:19 <Kaidelong> Maxdamantus: you want (map . map) $ there I believe
00:33:39 <Maxdamantus> > map (map (^2)) [[1],[2],[3]]
00:33:41 <lambdabot>   [[1],[4],[9]]
00:33:44 <edwardk> i still need to add more combinators to Future, but Future and NonEmpty have slightly different strictness profiles, so if something gets you on one you might be able to work around it with the other ;)
00:34:05 <edwardk> (though they have different applicatives, etc, since Future is basically a ZipList)
00:34:35 <Maxdamantus> > map . map $ (^2) [[1],[2],[3]]
00:34:36 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
00:35:13 <Maxdamantus> > map . map $ (^2) $ [[1],[2],[3]]
00:35:13 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[[t]]'
00:35:17 <Maxdamantus> Meh.
00:35:38 <Kaidelong> > (map . map) (^2) $ [[1],[2],[3]]
00:35:43 <lambdabot>   mueval-core: Time limit exceeded
00:35:45 <Maxdamantus> $ must be right-assosciative.
00:35:49 <Kaidelong> it is
00:35:57 <Kaidelong> also what
00:35:57 <edwardk> > map (map (^2)) $ [[1],[2],[3]]
00:35:59 <lambdabot>   [[1],[4],[9]]
00:36:22 <edwardk> the other is passing the argument to the inner map
00:37:04 <edwardk> map . map (^2) $ [[1],[2],[3]]   — was   map (map (^2) [[1],[2],[3]])  — which wasn't what you wanted
00:37:28 <Kaidelong> oh
00:37:29 <edwardk> you can make that prettier with more sugar
00:37:32 <Kaidelong> I see
00:37:42 <edwardk> > map (^2) <$> [[1],[2],[3]]
00:37:43 <lambdabot>   [[1],[4],[9]]
00:38:26 <msieradzki> why is haskell OpenGL package using GLfloat instead CFloat or Float?
00:38:37 <Kaidelong> mmm, doesn't there exist a map (f o g) a -> (f o g) b when f and g are functors, though?
00:38:44 <Kaidelong> so you shouldn't have to use applicative
00:38:49 <edwardk> msieradzki: because GLFloat is a define in GL.h, if you don't use it you could fail on some platforms
00:39:11 <edwardk> Kaidelong: the problem is its ambiguous which you mean in many cases
00:39:11 <Kaidelong> oh
00:39:14 <Kaidelong> <*> is fmap
00:39:19 <Kaidelong> err
00:39:22 <Kaidelong> <$> I mean
00:39:56 <edwardk> Kaidelong: what if you had a Num instance lying around for [a] — your program would just change meaning
00:40:54 <edwardk> kaidelong: so if you want functor composition you need to ask for it, by building a type that has the right shape as a newtype wrapper
00:41:19 <edwardk> newtype (f `O` g) a = Compose (f (g a))
00:41:25 <Kaidelong> I see, so overloading cuts both ways here
00:41:36 <edwardk> instance Functor f, Functor g => Functor (f `O` g) where ...
00:41:36 <Kaidelong> I imagine that's a more general problem than just this example
00:41:59 <edwardk> then you can map into Compose [] [] — but you'd need to use the newtype constructor Compose to indicate you want it
00:42:07 <edwardk> exactly
00:42:51 <edwardk> what is nice is that the instances you'll dispatch on can be identified uniquely and adding another instance shouldn't change the meaning of an existing program
00:43:01 <edwardk> this is important to enable library writers to keep working =)
00:43:23 <edwardk> (that statement only holdsin the absence of some scary type extensions, but is sound enough in practice)
00:43:40 <msieradzki> edwardk, like which platform has anything other than typedef float GLfloat?
00:44:10 <Kaidelong> I imagine for those people who think that nominal types are the work of the devil, this would seem like an unsatisfying solution to them
00:44:23 <edwardk> msieradzki: i didn't say it occured in practice, just what i heard the justification was ;)
00:44:26 <msieradzki> I know it should be done like that but I'm curious why would it be different on any platform
00:44:30 <Kaidelong> but you really wouldn't be able to disambiguate, on the other hand...
00:44:58 <edwardk> msieradzki: you may not have ieee floating points on your main cpu on a platform, only on some vector processing unit used by gl
00:45:16 <edwardk> (of course, then ghc probably wouldn't run there) ;)
00:45:42 <msieradzki> I can enable 32-bit float even on PIC16 last time I checked which is quite exotic
00:45:46 <edwardk> newtypes are shims to enable you to tell the compiler which instance to use
00:45:52 <Kaidelong> s/them/the problem/g
00:46:31 <msieradzki> what's annoying is that GLfloat propagates to parts of my code that don't use GL
00:46:46 <edwardk> msieradzki: i admit its a rather annoying restriction
00:47:06 <edwardk> the whole 'Real' part of the numeric hierarchy is rather frustrating because they are hard to cast away or use
00:47:48 <Kaidelong> Can't you make a Num instance for it and then program without referencing GLFloats by name?
00:48:37 <Kaidelong> Well that won't help you in cases where other functions you're calling are returning things like Double, I suppose
00:50:31 <edwardk> well, the guts of Graphics.Rendering.OpenGL.Raw.Core31.TypesInternal sets up GLFloat from CFloat
00:53:28 <triyo> Axman6: ok that foo example you gave above that conses on to the end of the list 'foo <| 7" really got me the the lightbulb moment. Only thing still I have an issue with associativity. I tried infixl 5 and infixr 5 <| with no luck.
00:56:24 <Kaidelong> so when conal uses the weird underlined square with the right side missing, for sthat's just saying they're equal save for strictness?
00:56:40 <Cale> Kaidelong: yeah
00:56:46 <Kaidelong> thank you
00:56:46 <Cale> Kaidelong: roughly :)
00:56:54 <Cale> equal save for definedness
00:56:59 <Cale> undefined <= anything
00:57:12 <Cale> (it's a square "less than or equal to" sign)
00:57:28 <Cale> and it means "is less defined than or equal to"
00:58:44 <Kaidelong> I see
00:59:00 <Kaidelong> so the left may be _|_ where the right is defined
00:59:11 <Cale> Where the ordering is that x is less defined than y if you can take some of the undefined pieces of x and define them to get to y
00:59:16 <Cale> yeah
00:59:17 <ivanm> anyone know why darcs's .cabal file specifies parsec < 3.1 ?
00:59:20 <Kaidelong> and thus if you put const _|_ on the left it is a tautology
00:59:25 <Cale> (it's a partial ordering)
00:59:42 <Cale> yeah, except that Haskell is weird and  _|_ <= const _|_
00:59:57 <Cale> But otherwise, that's true.
01:01:03 <Cale> Kaidelong: The reason for any distinction between _|_ and const _|_ is that we have seq
01:01:08 <Cale> > seq undefined 0
01:01:10 <lambdabot>   *Exception: Prelude.undefined
01:01:14 <Cale> > seq (const undefined) 0
01:01:16 <lambdabot>   0
01:01:48 <triyo> Ok, it seems that this now works 100% infixr 5 |> infixl 5 <|
01:02:22 <Cale> and seq can't tell that a lambda is constantly undefined because that requires solving the halting problem in general
01:02:35 <Cale> (and we never evaluate under lambdas anyway)
01:02:41 <triyo> |> needs to be right associative and <| left. Works perfectly now and I actually get it! The post makes sense now.
01:03:01 <Cale> g'night!
01:04:08 * hackagebot ip6addr 0.3.3 - Command-line tools to deal with IPv6 Addresses text representation  http://hackage.haskell.org/package/ip6addr-0.3.3 (MichelBoucey)
01:04:09 <Kaidelong> goodnight
01:05:57 <Kaidelong> > (\ !x -> 0) (const undefined)
01:05:59 <lambdabot>   0
01:06:14 <Kaidelong> fun
01:07:10 <Kaidelong> I suppose that's much the same as ML things where you pass unit as an argument to side effecting functions
01:07:37 <Kaidelong> > let crash = const undefined in crash()
01:07:39 <lambdabot>   *Exception: Prelude.undefined
01:08:44 <Kaidelong> you can pass it around like a value but invoking it is different from just passing it around
01:08:46 <Kruno_> Hello
01:09:30 * ivanm waves idly in Kruno_'s general direction
01:10:03 <Kruno_> Kaidelong: Managed to get wxHaskell working?
01:10:19 <Kaidelong> Kruno_: Oh right, I was supposed to do that
01:10:26 <Kruno_> lol
01:10:28 <Kaidelong> well might as well leave wxWidgets to build overnight
01:10:50 <Kruno_> It must be really late over there or you have a mighty slow PC.
01:12:32 <Kaidelong> prior
01:12:34 <ivanm> @time Kaidelong 
01:12:44 <lambdabot> Local time for Kaidelong is Thu Jan 13 01:14:03
01:13:00 <sipa> @time sipa
01:13:04 <lambdabot> Local time for sipa is Thu Jan 13 10:14:12 2011
01:13:08 <Kaidelong> I got hung up on two of Conal's papers, again...
01:14:20 <Kruno_> I had a long discussion with a friend over which is better, GTK vs WxWidgets. Can not decide which one, now that both work fine.
01:15:33 <Kaidelong> well it'd depend on the haskell bindings at that point, right?
01:15:41 <Kaidelong> except if you're not using wxGTK
01:16:12 <Kruno_> what? wxGTK? Now that is confusing.
01:16:30 <Kaidelong> wx can target GTK, basically
01:16:38 <Kaidelong> I think it is the convention on some platforms to do that
01:16:43 <Kaidelong> but not on the windows or macintosh
01:17:01 <Kruno_> Ahh
01:17:17 <Kruno_> I will have to look which one outputs nicer code.
01:18:07 <mmaruseacph2> lambdabot, help
01:18:12 <mmaruseacph2> @pl
01:18:13 <lambdabot> (line 1, column 1):
01:18:13 <lambdabot> unexpected end of input
01:18:13 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
01:18:38 <mmaruseacph2> @pl f x y = x + y - 42
01:18:38 <lambdabot> f = flip flip 42 . ((-) .) . (+)
01:19:48 <Kaidelong> I do not know how well this is supported but one of the advantages of GTK might be if it integrates well with Glade
01:19:57 <Kaidelong> in which case you could have a designer to work with
01:20:37 <Kaidelong> ah, yes, you can do that
01:21:29 <Kaidelong> I don't think there is anything like glade for wxWidgets that will also work with wxHaskell
01:21:38 <Kruno_> hmm
01:21:51 <Kruno_> I will take GTK for now. It is nice to have options.
01:24:01 <mmaruseacph2> I found the tutorials for both GUIs lacking many details
01:24:10 <mmaruseacph2> also, the logs link seems to be broken
01:24:36 <mmaruseacph2> maybe someone could start a project for a gui designer for wxHaskell
01:24:47 <mmaruseacph2> or, better, independent of library
01:24:51 <Kaidelong> @ty (flip (-) 42 .) . (+)
01:24:52 <lambdabot> forall a. (Num a) => a -> a -> a
01:24:57 <mmaruseacph2> though, I think it will be very hard
01:25:29 <Kaidelong> @unpl (flip (-) 42 .) . (+)
01:25:30 <lambdabot> (\ g j -> (g + j) - 42)
01:26:39 <mmaruseacph2> eh, that was only a test of lambdabot's capabilities
01:26:50 <mmaruseacph2> (reading the monad reader article right now)
01:27:04 <Kaidelong> in that case it looks like pl did worse than just figuring it out by hand
01:27:07 <Kaidelong> which surprised me
01:27:41 <mmaruseacph2> it seems that way
01:28:07 <mmaruseacph2> @ty flip flip 42 . ((-) .) . (+)
01:28:09 <lambdabot> forall a. (Num a) => a -> a -> a
01:28:13 <mmaruseacph2> @ty flip flip 42 . ((-) .)
01:28:15 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => f a -> f a
01:28:23 <mmaruseacph2> nothing useful
01:33:04 <Kaidelong> > (^2) == (^3)
01:33:06 <lambdabot>   *Exception: (==): No overloading for function
01:33:17 <Kaidelong> so lambdabot has a fixed Num class?
01:34:42 <Jafet> Fixed? Looks broken from here
01:35:46 <quicksilver> that's an interesting error message tho
01:35:51 <quicksilver> > 'a' + 'b'
01:35:52 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
01:35:52 <lambdabot>    arising from a use of `GHC....
01:36:21 <quicksilver> ah, it's because Expr gives functions a vacuous Eq instance, I assume.
01:37:11 <Jafet> :t (^2) == (^3)
01:37:12 <lambdabot> Bool
01:37:17 <Jafet> Er
01:37:18 <Kaidelong> oh no
01:37:20 <Jafet> :t (^2)
01:37:20 <lambdabot> forall a. (Num a) => a -> a
01:37:45 <Kaidelong> Oh now I get it
01:37:56 <Kaidelong> (==) is implemented by "throw an exception"
01:37:58 <Jafet> It's the vector-space instance Num (a->a)
01:38:05 <Kaidelong> the Num class is still broken
01:38:30 <Kaidelong> and still requires the implementation of (==)
01:39:05 <Kaidelong> that's elegant enough really
01:39:17 <Kaidelong> perhaps better than "fixing" Num even
01:40:03 <quicksilver> > let f 0 = "zero"; f _ = "non-zero" in f (^2)
01:40:05 <lambdabot>   "*Exception: (==): No overloading for function
01:40:13 <quicksilver> :)
01:42:08 <Kaidelong> funny
01:43:32 <shachaf> > let a 0 = "zero"; a _ = "non-zero" in а (^2)
01:43:34 <lambdabot>   "non-zero"
01:44:11 <shachaf> quicksilver: Magic.
01:45:42 <quicksilver> I don't believe in magic.
01:45:48 <quicksilver> that must have been some democrat trick.
01:47:40 <Jafet> > а 0
01:47:42 <lambdabot>   "non-zero"
01:49:19 <shachaf> Jafet: Close enough.
01:55:08 <jonkri> i'm a little confused about what language to use with my project, and would appreciate some insight. the application in question is an xmpp media server with encryption support (implementing the xpmn architecture). here is a list where i grade the language in some aspects: http://paste.pocoo.org/show/319919/
01:55:36 <pacak> jonkri: erlang
01:56:30 <jonkri> pacak: ... based on?
01:57:03 <pacak> xmpp library in haskell is not very good.
01:57:34 <Jafet> This may be an opportunity to write a good one, then
01:57:49 <Jafet> I'm not really sure what you expect to get from asking this channel whether to use java
01:57:56 <pacak> At least for use in my project i had to patch it in several places. And i will patch in even more places.
01:57:59 <Kaidelong> you don't have to program in Java to use Java
01:58:16 <quicksilver> haskell doesn't really deserve a 2 for 'distributed'
01:58:29 <quicksilver> but then it's not obvious that an XMPP media server needs to be distributed.
01:58:32 <pacak> jonkri: As for java - i simply dislike it. Feels like stone axe.
01:58:58 <pacak> jonkri: So erlang is your choice.
01:59:07 <Kaidelong> you could use Scala on the Java platform if you want typeclasses, at least
01:59:12 <quicksilver> I think it's true that you'll need to write more code yourself if you use haskell.
01:59:26 <quicksilver> erlang presumably has good server libraries etc.
01:59:49 <Jafet> And why is "Fun" there? Are you making an xmpp server as part of your work?
01:59:57 <jonkri> pacak: the only feature i feel that is missing to implement xpmn though is tls security
02:00:04 <quicksilver> it's not forbidden to enjoy your job, Jafet :P
02:00:31 <Jafet> Well, I wonder what "Fun" means, if those other mundane-looking things seem to outweigh it in importance
02:01:28 <jonkri> Jafet: it's an open source project, but i want it to be successful :) it's just what i want to do based on curiosity, appreciation of elegance, etc
02:01:41 <pacak> jonkri: It can be done in haskell as well as in erlang.
02:02:25 <Jafet> I would say that these projects nearly always require fun to be successful.
02:02:48 <pacak> jonkri: Just remember that xmpp library in haskell is written to be used with Text.Lazy type and you will be forced either to use it in all other places or transcode between different encoding.
02:02:53 <jonkri> Jafet: i will work on regardless though, i'm so desperate to get a business going...
02:03:29 <jonkri> pacak: are you referring to XMPP (on hackage) or haskell-xmpp (http://haque.nfshost.com/haskell-xmpp/)?
02:04:30 <pacak> jonkri: on hackage.
02:04:55 <jonkri> pacak: we're looking at the other library as it supports sasl, concurrency and some other things
02:04:58 <pacak> jonkri: But i'll check http://haque.nfshost.com/haskell-xmpp/ - looks nice.
02:05:25 <jonkri> :)
02:10:17 <jonkri> the question is perhaps whether the pros outweighs rewriting the prototyped erlang code that we already have - http://www.pontarius.org/releases/pontarius-0.0.3.0.tar.gz (basically profileserver, newjingle_fsm, objectserver) - and learning and extending the xmpp library to support starttls
02:10:57 <Entroacceptor> I'd say that depends if the fun or the business aspect drives you
02:13:28 <dschoepe> jonkri: Another point about your scoring: Java really shouldn't have the same score for type-safe as Haskell
02:16:18 <jonkri> Entroacceptor: yeah, i think you're right
02:16:23 <jonkri> thanks for all your feedback :)
02:17:11 <edwardk> hrmm, it looks like using the iso trick causes ghc 7 to blow up when generating haddocks or something. meh. going to get some sleep, THEN look at it
02:17:59 <edwardk> or maybe thats a misconfgiuration on the server
02:18:00 <edwardk> http://hackage.haskell.org/packages/archive/ad/0.46.2/logs/failure/ghc-7.0
02:18:05 <edwardk> thoughts?
02:18:34 <edwardk> yeah that looks like something outside of my purview
02:21:10 <ivanm> edwardk: "iso trick"?
02:22:27 <edwardk> class Iso a b where iso :: a -> b      instance Iso a a where iso = id;    newtype Foo x y z = Foo (x (y z)) deriving (Iso (x (y z)))
02:22:58 <edwardk> newtype deriving takes the 'a' 'a' instance and makes an 'a' (x (y z)) instance out of 
02:23:03 <edwardk> so far so good, and harmless right?
02:23:12 <edwardk> now replace the type of iso
02:23:21 <edwardk> class Iso a b where iso :: f a -> f b
02:23:26 <edwardk> and leave everything else the same
02:23:53 <edwardk> now that lets you reach into any type and strip out the newtype wrapper, its just an unsafeCoerce
02:24:00 <edwardk> from a term to a newtype on the term
02:24:22 <edwardk> but it can be done without paying for an fmap or on things you can't fmap
02:25:04 <edwardk> i use it at the bottom of http://hackage.haskell.org/packages/archive/syb-extras/0.2.0/doc/html/Data-Data-Extras.html to make it possible to write a couple of "impossible" methods, liftF and liftK
02:25:48 <edwardk> those let me write data instances for polymorphically recursive data types
02:27:19 <ivanm> where is it exploding? or is that built with 6.12?
02:28:11 <edwardk> its unrelated to the iso hack, that was me jumping to a conclusion
02:28:34 <edwardk> its blowng up trying to read an interface file for Language.Haskell.TH
02:28:43 <ivanm> ahhhh
02:28:48 <edwardk> so it looks like something just needs to be purged
02:28:52 <edwardk> i've had this happen before
02:28:59 <edwardk> well something kinda similar
02:31:10 * edwardk &
02:38:53 <tibbe> Anyone here willing to run a Hudson continuous build for the network package on their Windows machine? I already have a Linux build bot.
02:39:01 <tibbe> I can help with the setup
02:41:32 <path[l]> huh, someone told me that haskell has a nonuniform indentation scheme. Is that true?
02:43:18 <ivanm> path[l]: depends, what does that mean?
02:43:46 <path[l]> I was wondering too. he said python has one indentation level for everything
02:44:13 <quicksilver> maybe he means that after "do foo" you have to indent 3 spaces.
02:44:20 <quicksilver> but that's your fault for writing "do foo"
02:44:24 <ivanm> could be
02:44:31 <ivanm> quicksilver: rather than "do  foo" ?
02:44:32 <quicksilver> if you write "do\n  foo" then you can use a standard indent.
02:44:51 <quicksilver> if you like standardised indent, put a newline after each layout construct
02:44:52 <ivanm> how about if statements in do blocks?
02:45:19 <quicksilver> there's nothing non-standard about them. They were just misunderstood, and then have been broken in haskel2010.
02:46:26 <path[l]> hmm I just googled
02:46:32 <path[l]> the if in do is a bit wierd
02:46:49 <quicksilver> it only seems weird until you understand what it's doing.
02:46:55 <quicksilver> "if X then Y else Z" is a single expression.
02:47:04 <quicksilver> since it's a single expression, you need to either put it on one line
02:47:12 <quicksilver> or, you need to indent the continuation lines
02:47:28 <quicksilver> just like you would with the expression "X + Y + Z" if it spanned many lines.
02:47:51 <path[l]> hmm
02:48:01 <path[l]> if I just did if without do, does then line up with if?
02:48:55 <quicksilver> path[l]: you do whatever you like
02:49:01 <path[l]> hmm
02:49:04 <quicksilver> if you're not in layout, in doesn't matter where you line things up
02:49:19 <path[l]> you're in layout only when you're inside a block?
02:49:21 <quicksilver> indentation only has an actually language effect in layout blocks.
02:49:51 <quicksilver> well, there are several layout constructs: the top-level module, do, let, case, where
02:50:10 <quicksilver> but since the top-level module is normally flush to the left margin you can almost ignore that
02:50:21 <quicksilver> it just means, any line which is zero indent starts a new definiton
02:50:41 <wjt> i don't suppose anyone knows of a collection of idiomatic solutions to the RWH exercises? i lent it to a coworker, and he says he ends up writing two solutions to the exercises and not knowing which is better; I don't really trust myself as an authority on idiomatic Haskell :)
02:59:03 <exDM69> wjt: I don't think it's necessary to actually consider how idiomatic your exercise solutions are, just do them and you should learn slowly what is idiomatic and what isn't
02:59:16 <exDM69> wjt: also using HLint on the source might give good tips
02:59:55 <quicksilver> wjt: I don't think there is a list of idiomatic solutions.
03:00:15 <quicksilver> I'm not sure an idiomatic list would help, since what you really want is an expert to explain *why* the better solution is better.
03:05:49 <Blkt> good day everyone
03:06:15 * ivanm waves idly in Blkt's general direction
03:06:50 <Blkt> lol :)
03:08:17 * Entroacceptor particles in Blkt#
03:08:21 <Entroacceptor> 's direction
03:08:45 <Entroacceptor> it's such an old, lame joke, but I love it
03:09:15 <Blkt> eheheh
03:14:40 <wjt> exDM69, quicksilver: good points, all
03:15:00 <wjt> exDM69, quicksilver: of course, my coworker could ask here :)
03:17:00 <exDM69> wjt: yep, point him to this channel and using HLint. Also point out that not all HLint suggestions are good, although most of them are
03:17:16 <wjt> looking back over the exercises, i should really do some :)
03:37:24 <Phyx-> Hi all, I'm getting some weird linker errors from GHC http://phyx.pastebin.com/858rmsCq
03:44:13 <mm_freak> you know what i really hate about PHP?  $object->doPutValuesNow(34, 63, true, false, false, null, "", true, 66);
03:44:31 <Twey> Ha
03:44:36 <mm_freak> why can't everybody just use haskell?
03:44:38 <Phyx-> ok, fixed it, but now i'm wondering why it resulted in a linker error... the module wasn't exposed. so shouldn't it have just given a compile time "module xxx not found"
03:45:09 <Twey> mm_freak: doPutValuesNow :: Object -> Int -> Int -> Bool -> Bool -> Bool -> Maybe Object -> String -> Bool -> Int -> IO ()
03:45:11 <Jafet> Phyx-: package /= module interface
03:45:13 <Twey> ;)
03:45:39 <Phyx-> Jafet: huh?
03:45:42 <mm_freak> Twey: you can have nicer values in haskell
03:46:03 <Twey> mm_freak: You *can* do it better in PHP, too
03:46:04 <mm_freak> like NoClean instead of false
03:46:11 <mm_freak> yes, but it's tiring
03:46:15 <mm_freak> and nobody does it
03:46:24 <Twey> There's the real problem
03:46:44 <Jafet> Phyx-: uh, is the the usual I-didn't-use---make problem, or something else?
03:47:06 <mm_freak> Twey: that's related to the fact that in haskell you can just write:  data MyOption = OptionA Int | OptionB String
03:47:28 <Phyx-> Jafet: no it's not. The package had a module that wasn't exposed. Another package was refering to it, instead of ghc saying it can't find that module, it just accepted it and produced linker errors
03:47:30 <mm_freak> this simple definition will need three classes in PHP, and according to company standards those will need two pages of code
03:47:43 <mm_freak> that's why nobody does it
03:47:53 <quicksilver> Phyx-: it must have thought it could find it, at compile time.
03:48:00 <quicksilver> Phyx-: I'm not sure how that can happen.
03:48:15 <quicksilver> where they compiled together so they could see each other locally, but then linked into separate packages?
03:49:17 <Phyx-> quicksilver: well, i was compiling in foo\bar and the other module that wasn't exposed was in foo\package, not sure why it would look at the parent though
03:50:51 <Phyx-> could be something in the cabal files though...
03:52:15 <Saizan> Phyx-: was it in other-modules at least?
03:52:30 <Phyx-> Saizan: nope
03:53:04 <Saizan> ah, then the .o wouldn't get included in the .a, but code from other modules would still refer to those names
03:53:54 <Saizan> so, maybe you didn't refer to it at the source level so ghc didn't catch it
03:55:14 <Phyx-> Saizan: well, it's used inside the package itself. it's just not explosed since it's internal machinery. but the .o not being included because it wasn't in Other-Modules sounds logical
03:55:46 <Phyx-> would be nice if cabal could warn about this? maybe by inspecting the interface files for all exposed modules and seeing that it has all their dependencies?
03:56:09 <Phyx-> hrm, but the .a is compiled by ghc.. so it should already know them
03:56:26 <Saizan> are you sure it is?
03:56:48 <Saizan> anyhow, a warning would be nice, not sure what would be the best way to implement it
03:57:48 <Phyx-> Saizan: yeah it is, it's imported qualified
03:58:28 <Saizan> i meant, are you sure the .a is built by ghc?
03:58:41 <Saizan> i think Cabal calls ar directly
03:58:43 <Phyx-> oh, that, not sure
03:58:58 <Phyx-> i think dcoutts_ would be the best one to answer that
04:00:42 <Phyx-> It would be though to find out the dependencies though, since Cabal is supposed to be compiler independent, you can't really read the .hi files with the GHC api since that'll be ghc specific
04:02:56 <Saizan> there's a Distribution.Simple.GHC though
04:03:36 <ivanm> *groan* converting from String to Text is a PITA
04:04:15 <Saizan> weird encoding?
04:04:28 <ivanm> no, as in porting my code from using String to using Text is a PITA
04:04:44 <Phyx-> Hmm, And I do see a Distribution.Simple.Program.Ar aswell. The interactions with ghc are via the exe. So the question then becomes, if their a flag to get ghc to dump the module dependencies
04:10:13 <Phyx-> hmm, anyone here familiar with the cabal test suite? I'm getting http://phyx.pastebin.com/rTsnmXsr and not sure if i'm the one that broke it :P and if it was, how do i get more info on it to fix it?
04:11:39 <Phyx-> oh there's a test-log file in every dir :)
04:11:56 <Phyx-> seems it failed some due to ghc 7's rewording of errors
04:17:14 <edon> Hi, what does the ! do in a ADT definition (like: data T a = T !a)?
04:17:26 <quicksilver> makes the field strict
04:18:00 <ivanm> anyone here familiar with Text's toCaseFold?
04:25:09 <qfr> quicksilver what is a "strict" field?
04:26:47 <ivanm> qfr: e.g. !Int has the Int value evaluated rather than carrying around a thunk to calculate the Int
04:26:53 <ivanm> very useful for accumulators, etc.
04:28:24 <quicksilver> qfr: A field which cannot contain _|_
04:28:41 * hackagebot usb 0.6.0.8 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.8 (BasVanDijk)
04:28:46 <qfr> That was uh the bottom value?
04:28:56 <quicksilver> (although ivanm's answer is more practical)
04:28:57 <quicksilver> yes
04:29:27 <ivanm> ! evaluates it to WHNF, doesn't it?
04:29:33 <qfr> :t _|_ doesn't even work
04:29:35 <lambdabot> parse error on input `|'
04:29:36 <qfr> What is it used for?
04:29:47 <sipa> :t undefined
04:29:49 <lambdabot> forall a. a
04:30:14 <ivanm> qfr: it's usually defined/implemented as "undefined"; _|_ is just the notational symbol for it
04:30:19 <Phyx-> http://www.haskell.org/tutorial/moretypes.html section 6.3 contains a longer definition
04:30:28 <sipa> qfr: undefined, error, diverging fixpoints are all bottom values
04:30:30 <Phyx-> @hoogle run --info
04:30:31 <lambdabot> Test.QuickCheck.Batch run :: Testable a => a -> TestOptions -> IO TestResult
04:30:31 <lambdabot>  
04:30:31 <lambdabot> Run the test. Here we use the same random number each time, so we get reproducable results!
04:30:38 <Phyx-> wrong run
04:30:50 <ivanm> :o didn't know about --info
04:31:44 <Phyx-> hehehe
04:32:37 <Phyx-> that's odd.. it's failing with a FileNotFound error
04:32:41 <Phyx-> but it's there!
04:32:41 <Phyx-> :P
04:33:08 <ivanm> preflex: seen bos
04:33:09 <preflex>  bos was last seen on #haskell 1 day, 14 hours, 30 minutes and 11 seconds ago, saying: the Show instance uses utcToZonedTime
04:37:47 <ivanm> does anyone know/understand what "folded case" means wrt text and unicode?
04:40:38 <quicksilver> case folding is stuff like "map toUpper" but locale-sensitive.
04:40:39 <Phyx-> no idea, sorry
04:45:51 <Phyx-> foo { cwd     = cwd } <-- hmm how is that working
04:46:21 <Phyx-> ghc knows which variable to pick due to the types or something?
04:46:57 <quicksilver> Phyx-: it works because it's syntax.
04:47:00 <ivanm> quicksilver: how does Text's toCaseFold differ from doing toUpper then?
04:47:16 <quicksilver> the thing on the left of the equal sign is a field name
04:47:23 <quicksilver> the thing on the right is an expression
04:47:31 <Phyx-> quicksilver: but all field names are also top level functions are they not
04:47:39 <quicksilver> ivanm: it *ought* to follow locale-based rules to fold case correctly.
04:47:43 <quicksilver> ivanm: I don't know what it actually does.
04:47:48 <quicksilver> Phyx-: in expression context, yes.
04:47:51 <ivanm> *nod*
04:47:54 <quicksilver> Phyx-: oh, is that in a binding?
04:48:03 <quicksilver> Phyx-: in a binding, that means something different
04:48:08 <quicksilver> the cwd on the left is a field name
04:48:13 <quicksilver> the cwd on the right is a pattern
04:48:20 <Phyx-> oh ok
04:48:26 <quicksilver> (a pattern consisting of a single 'fresh' variable name)
04:48:31 * ivanm is trying to work out how to do case-insensitive parsing/detection of keywords whilst also leaving internal strings untouched
04:48:32 <quicksilver> so that binds a new local variable 'cwd'
04:48:38 <quicksilver> which shadows the global binding 'cwd'
04:48:55 <quicksilver> Phyx-: I personally don't like that style.
04:49:08 <quicksilver> Phyx-: for me it's a cognitive dissonance 
04:49:17 <quicksilver> because cwd "should" have the type Foo -> Cwd
04:49:18 <quicksilver> not Cwd
04:49:28 <quicksilver> I don't like shadowing at a different type.
04:49:40 <Phyx-> yeah, it's rather confusing
04:51:14 <quicksilver> ivanm: case folding is supposed to be the right way to do that, yes
04:51:52 <ivanm> well, doing something as simple as ` toCaseFold "Hi" ' seems to return it as lower case :s
04:53:09 <quicksilver> yeah, I think it's using lower case folding not upper case
04:53:15 <quicksilver> I don't know which is better
04:53:21 <quicksilver> maybe lower works better for more languages, or something
04:53:54 <ivanm> *nod*
04:55:22 <Phyx-> oh my gawd
04:55:31 <Phyx-> 923 changes to record?
04:55:39 <Phyx-> is darcs gonna ask each one? lol
04:56:13 <opqdonut> you can also reply "all"
04:56:40 <Phyx-> is soon as a i typed "a" it went
04:56:47 <Phyx-> is 'a' all?
04:56:54 <opqdonut> at least used to be
04:57:04 <Phyx-> ok :)
04:57:34 <Phyx-> i did a record, where is the patch file put?
04:57:44 <Phyx-> <--- newb
05:00:09 <parcs> Phyx-: _darcs/patches?
05:01:25 <Phyx-> wow, that;s huge :/
05:03:53 <Phyx-> darcs send -o "name" is used to record it to a file right?
05:04:04 <Phyx-> err, bundle it up
05:04:55 <qfr> readIORef gives me an IO a - how do putStrLn that a?
05:05:12 <qfr> how do I*
05:05:23 <quicksilver> x <- readIORef blah
05:05:26 <quicksilver> putStrLn x
05:05:29 <qfr> Oh right
05:05:39 <quicksilver> or, in one line, readIORef blah >>= putStrLn
05:05:54 <aristid> both are the same, just different syntax
05:06:07 <quicksilver> what he said.
05:06:16 <qfr> Although I find the first one more convenient in general, I think
05:06:30 <qfr> In case you want to do more with it
05:07:21 <aristid> qfr: readIORef blah >>= \x -> putStrLn x >> doMoreWith x
05:07:37 <qfr> Well, I don't want to squeeze everything into one line
05:08:01 <aristid> i just wanted to show you that really both are equally expressive
05:08:04 <quicksilver> you are allowed to break lines in the middle of expressions :)
05:08:15 <robinhoode> @pl Just x >>= \x -> Just (x + 1)
05:08:16 <quicksilver> but yes, do notation is a convenient shorthand
05:08:16 <lambdabot> Just . (1 +) =<< Just x
05:08:30 <quicksilver> it's just good to remember that's all it is - a shorthand
05:10:19 <Twey> Longhand, really
05:10:24 <aristid> or a longhand, depending on how it is used
05:11:07 <aristid> often a do expression can be replaced very succinctly by combinators, or a small point-free chain of >>=/fmap
05:12:39 <qfr> You can't use fmap with IORefs though, can you?
05:12:41 <Twey> robinhoode: (+ 1) <$> Just x
05:12:49 <qfr> Because it's not an instance of Functor?
05:12:55 <quicksilver> qfr: IORef isn't a Functor, no
05:12:58 <quicksilver> but IO is.
05:13:09 <Twey> qfr: The ‘update’ for IORefs isn't pure
05:13:11 <quicksilver> "fmap (+1) (readIORef blah)"
05:13:14 <Twey> :t fmap
05:13:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:13:25 <quicksilver> my example gets the value from the ref and adds 1
05:13:28 <quicksilver> but it's not changing the ref
05:13:31 <Twey> (but does not set it back)
05:13:32 <Twey> Right
05:13:37 <quicksilver> it's just returning that calculation
05:13:37 <Twey> There's a modifyIORef that does that IIRC
05:13:41 <quicksilver> right
05:14:01 <qfr> Yeah I am dealing with state stuff like that for the first time now, for the application state in Snap
05:15:16 * hackagebot xml-enumerator 0.0.1.2 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.0.1.2 (MichaelSnoyman)
05:32:01 <damex> http://projects.haskell.org/xmobar/ != http://code.haskell.org/~arossato/xmobar/ ?
05:32:07 <damex> they'r different ... right?
05:45:31 <qfr> newtype TimerState = TimerState {_startTime :: UTCTime}
05:45:43 <qfr> What is the significance of the leading underscore there?
05:45:49 <qfr> Is that some naming convention?
05:46:18 <qfr> Usually _ or __ or __x__ refer to implementation details which are supposed to remain internal/hidden/do-not-touch
05:46:24 <mm_freak> functionally nothing, but from other languages comes the convention to name private/protected fields with a leading underscore
05:46:42 <qfr> o_O
05:46:46 <mm_freak> "private" in this sense could mean non-exported
05:47:11 <qfr> Te
05:47:12 <ClaudiusMaximus> in (ghc?) haskell, also suppresses warnings about unused names
05:47:19 <qfr> The entire TimerState is exported
05:47:21 <qfr> ClaudiusMaximus ah
05:48:24 <ClaudiusMaximus> if you like being -Wall clean, you can use _foo instead of _ in patterns while adding a small amount of documentation
05:52:09 <Bynbo7> qfr: i think it's just a way of documenting what the time does. you can;t call that function, because _x is exactly the same as _, meaning a parameter you don't care about
05:52:37 <Bynbo7> i think that's right anyway
05:53:55 <Twey> Well, it's a convention that that's so
05:54:12 <Twey> I don't think it's actually ignored (unlike _)
05:54:22 <Twey> > (\ _x -> _x) 5
05:54:23 <lambdabot>   5
05:54:28 <Twey> > (\ _ -> _) 5
05:54:29 <lambdabot>   Pattern syntax in expression context: _
05:54:40 <Twey> Which means you can also do:
05:54:43 <sipa> _ is not a valid expression
05:54:46 <Twey> > (\ _ _ -> 5) 1 2
05:54:47 <lambdabot>   5
05:54:49 <Twey> But not:
05:54:54 <Twey> > (\ _x _x -> 5) 1 2
05:54:54 <lambdabot>   Conflicting definitions for `_x'
05:54:55 <lambdabot>  Bound at: <interactive>:1:3-4
05:54:55 <lambdabot>            ...
05:56:22 <mm_freak> > let _x = 3 in _x
05:56:22 <lambdabot>   3
05:56:28 <mm_freak> > let _ = 3 in _
05:56:28 <lambdabot>   Pattern syntax in expression context: _
05:56:35 <mm_freak> it's not the same
05:56:46 <mm_freak> _x is a real name, while _ is really a non-name
05:57:46 <Twey> Right
05:58:36 <aristid> mm_freak: regarding your contstuff... did you read monad.reader 16? apfelmus notes something how his operational monad is equivalent in power to Cont...
05:59:05 <mm_freak> aristid: i remember that monad, but i think it has entirely different semantics
05:59:59 <aristid> i wonder if you can simulate callCC in that monad
06:00:26 <mm_freak> i don't know, but for the contstuff CPS is just the canonical method i think
06:00:51 <mm_freak> there are also some monad transformers with multiple continuations
06:00:58 <mm_freak> which makes this a bit more complicated
06:01:17 <mm_freak> i think i should add a callCC2
06:01:23 <mm_freak> which refers to the second continuation
06:21:56 <test> Hello, is this the IRC of Haskell where I can ask questions?
06:21:56 <lambdabot> test: You have 1 new message. '/msg lambdabot @messages' to read it.
06:22:38 <zenzike> test: yes it is
06:25:06 <test> Well we have a small problem with algebra: http://hpaste.org/43000/algebra (It gives the error couldn't match expected type f against inferred type e on row 74:47 (which is foldE (PMUL a b) = e1 (foldE a) (foldF b), actually foldE is completly wrong) can someone point the error?
06:26:51 <mun_> hi
06:27:33 <mun_> can a first-order formula be polymorphic? is polymorphism essentially existentially quantifying over types?
06:28:27 <mm_freak> mun_: 1. sure, 2. yes
06:28:44 <mun_> mm_freak, but can types over quantified over in FOL?
06:28:45 <mm_freak> you can read "a -> b" as "forall a b. a -> b"
06:29:23 <djahandarie> test, can you give the full error message?
06:29:28 <mm_freak> maybe i misunderstood what you mean by "formula"
06:30:03 <djahandarie> Guess not
06:31:08 <mun_> mm_freak, well, is EX a':Type, s::a'. P(s) a FOL formula?
06:32:03 <Philippa> doesn't matter: what matters is whether you're interpreting free variables in a manner consistent with that HOL formula
06:33:15 <mm_freak> mun_: sorry, i thought it was a haskell question
06:33:33 <mun_> mm_freak, ooh. sorry.. it was a more logic question, I guess.
06:35:00 <mun_> Philippa, assume you were talking to me, but aren't types essentially sets, so quantifying over sets is a second-order feature, right?
06:39:54 <Philippa> mun_: sure, *shrug* - but that doesn't stop people interpreting free variables in a first-order formula in a manner equivalent to that
06:40:07 <Philippa> the point is that being free, they're unconstrained
06:41:03 <Philippa> you can't really use the formula in two different places with two different values for the variables without invoking second-order machinery in practice though
06:41:31 <Philippa> it's just that: who cares so long as the proof can be normalised to an entirely first-order one?
06:41:45 <ezyang> The original concurrent Haskell paper defined a "skip channel." is this anywhere in the standard libraries? 
06:42:22 <Philippa> dunno, not met it myself
06:44:26 <mm_freak> ezyang: what is it supposed to be?
06:44:42 <ezyang> it's a channel where you can repeatedly write to it without blocking, and if someone reads they only get the most recent value. 
06:44:49 <ezyang> it's for when the producer is much faster than the consumer 
06:45:39 <mun_> Philippa, thanks
06:49:12 <bitstream0101> Anyone willing to take a peek at http://hpaste.org/42998/type_family_errors and help me figure out the source of the errors?  Is it because the 'sym' type variable in 'dr' and 'drVariant' can be different?
06:52:02 <Bynbo7> bitstream0101: but... but... you're at galois! you must know everything about haskell!
06:52:38 <ezyang> mmm, type families. sounds like fun. 
06:52:46 * mux loves type families
06:53:24 <PipiKakaLangstru> hey
06:53:38 <PipiKakaLangstru> ?
06:53:39 <PipiKakaLangstru> ?
06:53:40 <PipiKakaLangstru> ?
06:53:42 <PipiKakaLangstru> ?
06:53:55 <Bynbo7> uh hi
06:54:02 <Bynbo7> you're new to haskell aren't you
06:54:07 <bitstream0101> Bynbo7: Ha ;)
06:54:15 <mm_freak> ezyang: you can use IORef for that
06:54:16 <PipiKakaLangstru> jo
06:54:16 <mux> bitstream0101: there is no guarantee that Term sym will be the same type as Node (D sym), as far as I can tell
06:54:29 <PipiKakaLangstru> maul?!
06:54:37 <mm_freak> ezyang: IORef is a "skip channel" by that definition
06:54:39 <ezyang> bitstream0101: The code seems incomplete. 
06:55:00 <bitstream0101> ezyang: it is, but i was hoping it was enough to get some insight
06:55:04 <mux> bitstream0101: pushing the type family in the class might help
06:55:21 <bitstream0101> mux: Aha, that's a good idea, I'll try that.
06:55:25 <Bynbo7> uh, by haskell, i meant irc
06:55:26 <ezyang> mm_freak: yeah, seems so. 
06:55:32 <ezyang> I wonder why they put it in the paper. 
06:56:05 <mm_freak> perhaps because you can base every other concurrency construct on it
06:56:28 <mm_freak> or at least most, but i think any
06:56:41 <mux> bitstream0101: by the way, it seems there are a fair number of extensions you advertise at the top but don't use
06:56:47 <quicksilver> mux: surely that guarantee comes from the type of drVariant?
06:56:59 <bitstream0101> mux: And no, there's no guarantee that Term sym will be the same as Node (D sym),  but I was hoping that the type equality constraint would be sufficient and type errors would show up on use of drVariant if it was the case that they were not the same.
06:57:10 <mux> quicksilver: but he uses 'dr' which is completely unrelated
06:57:16 <mux> bitstream0101: see ^
06:57:30 <bitstream0101> mux: Can you elaborate?
06:57:46 <quicksilver> mux: but he calls on (flds :: V.Vector (MonadType sym))
06:58:10 <quicksilver> mux: and we know from the type sig of drVariant that that sym satisfies Term sym ~ Node (D sym)
06:58:20 <quicksilver> ...and then 'dr' gets to use that constraint to, doesn't it?
06:58:21 <bitstream0101> That's the idea. =)
06:58:37 <mux> hmmm, I think you're right and I read that incorrectly.
06:59:10 <quicksilver> ah, but the problem is that MonadType sym doesn't determine sym
06:59:21 <quicksilver> because MonadType is a wrapper around a type family.
06:59:34 <quicksilver> so all "drVariant" has is something of the form MonadType sym
06:59:35 <ezyang> mm_freak: Oh, I left out one key detail: it blocks if no new data has arrived since the last read. 
06:59:46 <quicksilver> but it can't unwrap it to work out what actual concrete type 'sym' is.
06:59:49 <bitstream0101> quicksilver: Ahh...
06:59:54 <quicksilver> you should be able to fix this with a phantom argument of type 'sym'
07:00:06 <mux> *brainsplosion*
07:00:16 <quicksilver> or by making TypeOpDef into a data family
07:00:22 <quicksilver> if it is, in fact, your intention that it be injective
07:00:23 <mux> I love type families and all, but sometimes they are hard to read
07:00:27 <quicksilver> yes.
07:00:31 <mm_freak> ezyang: in that case you can use MVar with writeMVar instead of putMVar
07:00:40 <mm_freak> and readMVar instead of takeMVar
07:01:01 <ezyang> that raises warning bells for me. 
07:01:12 <mm_freak> i think there was also a SampleVar
07:01:34 <bitstream0101> mux: are you suggesting drVariant :: sym -> V.Vector (MonadType sym) -> sym (OpSession m ())?
07:01:51 <bitstream0101> or as an extra parameter to MonadType?
07:02:10 <mm_freak> well, MVar has the right semantics for that
07:02:25 <mm_freak> and i think that read/write is just as valid as take/put
07:02:48 <ezyang> mm_freak: I mean, read and write are just take/put pairs 
07:02:59 <ezyang> so they have some validity, but you have to be a little careful when reasoning about them. 
07:03:19 <quicksilver> in particular they're not atomic
07:03:56 <quicksilver> bitstream0101: that's what I meant. An extra paramater to both
07:05:17 <bitstream0101> quicksilver: How do I specify a phantom type parameter for MonadType that is of kind other than *?  In the case of the 'sym' phantom, it needs to be * -> *
07:07:12 <quicksilver> use KindSignatures
07:07:29 <bitstream0101> Ah, gotcha.
07:09:03 <Phyx-> grrrrrrrr
07:10:13 * Phyx- slaps ghci
07:10:33 <Phyx-> i have a package hidden, i explicitly stated which package it should use with -package
07:10:51 <Phyx-> and yet, it still says it can't load the module due to it being in multiple locations
07:10:53 <bitstream0101> quicksilver: Were you thinking something like http://hpaste.org/paste/42998/type_family_errors_annotation#p43001 ? I'm getting the same type errors there.
07:13:18 <djahandarie> bitstream0101, just curious, does switching TermOpDef to a data family fix it?
07:13:30 <mm_freak> ezyang: true
07:14:17 <mm_freak> ezyang: i think you can easily modify the "concurrent-ivar" package to act like a skip channel
07:14:23 <ezyang> Ugh. This code doesn't work, and it was published in a paper >:-( 
07:14:32 <djahandarie> lol
07:14:45 <bitstream0101> djahandarie: Hard to figure out what class it should belong to in this case for the real code that this was lifted from.
07:15:03 <ezyang> let's see if I can fix it. 
07:15:26 <Kruno> Hello again
07:15:37 <Kruno> I have another question.
07:15:52 <bitstream0101> djahandarie: if you just mean by using 'data family TermOpDef t', naw, it doesn't seem to address it.
07:15:53 <Kruno> I have now implemented a subset of PDCurses
07:15:56 <Kruno> All working
07:16:02 <Kruno> via FFI
07:16:53 <Kruno> (Why hasn't someone done this earlier instead of ncurses, nanocurses, etc...? As it is x-compilable on Linux and Windows)
07:17:05 <Kruno> And now I want a 'game loop'
07:17:08 <Kruno> previously
07:17:10 <djahandarie> bitstream0101, that should be enough to let the compiler know it's injective
07:17:13 <dankna> (because the default status of features is nonexistant)
07:17:15 <Kruno> I did a circular function call
07:17:25 <djahandarie> bitstream0101, I imagine you're testing in GHC 7?
07:17:31 <kbdvdr> hi all, a functionnal programming can be non-strict and with eager evaluation ... what is meant by non-strict then ? non-pure (assignment available)?
07:17:37 <bitstream0101> djahandarie: Negative =) 6.12.x.
07:17:50 <djahandarie> bitstream0101, ... this could be your problem
07:17:55 <bitstream0101> djahandarie: Bah!
07:17:57 <Kruno> is circular recursive function calls perfectly valid way to do a game loop in Haskell?
07:18:07 <djahandarie> Type families in 6 are extremely wonky
07:18:13 <Kruno> -recursive, just circular
07:18:26 <bitstream0101> djahandarie: I didn't know that. Thanks and I'll look into it =)
07:18:31 <Kruno> main -> loop -> main etc...
07:18:34 <Jafet> Kruno: sounds like you're describing continuation-passing style.
07:19:07 <Kruno> I am only using direct function calls, don't know when the stack will be full
07:19:24 <Kruno> memory usage kept going up in windows
07:19:36 <scree> Kruno: are these tail-calls?
07:19:46 <Kruno> yes
07:20:01 <Kruno> oh, one isn;t
07:20:03 <Kruno> sorry
07:20:28 <Kruno> game loop calls main at the end
07:20:45 <Kruno> but main clears screen, does input, calls game loop
07:22:10 <Kruno> actually what I have is an error, as endwin is never called :/
07:22:29 <Kruno> the lack of a looping construct has put me in my place
07:23:36 <scree> Kruno: it *sounds* more like there's an unrelated memory leak
07:23:54 <Kruno> Jafet: looking up continuation passing style, I hope it is what I am looking for. Thanks.
07:24:04 <Kruno> scree: Shouldn't be.
07:24:41 <scree> Kruno: only the mutually recursive calls should either cause a stack overflow, or not be a problem, unless your stack limit is huge
07:24:51 <Kruno> ahh
07:25:05 <Kruno> I thought it would eventually cause a stack overflow
07:25:13 <Kruno> So it really is not a problem?
07:25:36 <Jafet> So, is there a real space leak or not?
07:25:36 <scree> Kruno: I'd have to see some code, but stack leak by itself shouldn't cause a lot of memory usage
07:26:57 <scree> Kruno: a paste would be useful
07:27:08 <Jafet> If you're not sure, you could profile it
07:30:00 <zearen> Hello, I was wondering if there was a convenient way to use catch, catchJust and other Control.Exception funcions inside a State transformer?
07:31:04 <ezyang> zearen: No. 
07:31:13 <ezyang> well, unless you're transforming IO. 
07:31:36 <zearen> Sorry, I thought that was implied
07:32:08 <ezyang> I think someone created an alternate to Control.Exception that had all of the functions lifted to MonadIO. 
07:32:12 <ezyang> Lemme see if I can find it. 
07:32:18 <Kruno> Fixed.
07:32:24 <Kruno> No longer using memory
07:32:39 <ezyang> Oh, it just overloaded Control.Concurrent 
07:32:49 <ezyang> ah, here we go 
07:33:05 <ezyang> hm. 
07:33:19 <ezyang> this looks nontrivial, actually. 
07:33:40 <zearen> Oh?
07:33:44 <ezyang> http://hpaste.org/43002/skipchan <-- anyone want to help me verify the correctness of this code? 
07:36:33 <aristid> ezyang: what is a skip chan?
07:37:09 <ezyang> aristid: put doesn't block, take blocks if you've already seen teh value before. 
07:37:10 * digitteknohippie guesses it's not where you go to chat about rope skipping
07:39:01 <mm_freak> ezyang: so it's just like MVar, but with overwriting put and with per-thread blocking take…  i.e. emptiness becomes per-thread
07:39:04 <mm_freak> right?
07:39:30 <ezyang> yep. 
07:39:41 <ezyang> well, you manually control the per-threadedness with dup 
07:41:04 <Kruno> char can not be converted to CUChar :/
07:44:01 <ezyang> This also reminds me: does anyone know of people using mvars to manually schedule haskell threads? 
07:44:03 <Phyx-> I get two messages, "Dependency Cabal ==1.11.1: using Cabal-1.11.1" and "Using Cabal-1.9.2 compiled by ghc-6.12" I'm a little confused, is it using 1.9 or 1.11? since i'm getting an error about a function not being exported, while it is in 1.11
07:46:27 <ezyang> I wonder if the overhead from the scheduling thread oughtweighs the benefits 
07:50:40 <Phyx-> hello? anyone? lol
07:51:39 <knobo> lol
07:51:45 <dankna> it's a hard question
07:51:54 <dankna> well, I think you must be using Cabal 1.9.2
07:52:00 <dankna> but I don't understand the other message
07:52:22 <Phyx-> well, i'm building cabal-install, in which i have a dependency to Cabal of atleast 1.11
07:52:29 <Phyx-> so that explains the first one
07:52:35 <dankna> okay
07:52:44 <Phyx-> i don't get the second one, nor why it's saying that the function is not exported
07:52:45 <dankna> so there's two relevant cabal versions
07:52:50 <ezyang> Hmm. What is the fairness guarantee that we get from MVars? I thought it was FIFO, but according to the paper it's "no process can be blocked indefinitely on an MVar unless another process holds the MVar indefinitely" 
07:53:48 <quicksilver> ezyang: it's FIFO in practice but I don't know if/where that's documented or guaranteed.
07:54:06 <quicksilver> (first-blocked first-woken, FBFW?)
07:54:53 <ezyang> heh :-) 
08:00:15 <nomemory> Hello, Haskell newbie here, learning my way through list . I am at exercise 15 from 99 Haskell Problems . My solutions are: http://hpaste.org/43003/replicate_the_elements_for_a_g . I was wondering why my third solution is not working .
08:00:22 <nomemory> Any suggestions ?
08:03:45 <Phyx-> err, what's the expected result? replicate 2 [5,6] = [5,5,6,6] or [5,6,5,6] ?
08:04:20 <nomemory> repl'' 3 [1..3] = [1,1,1,2,2,2,3,3,3]
08:07:49 <CindyLinz> I think the problem is   null xs = []   in the  prependTo
08:07:56 <Phyx-> nomemory: right, when foldr runs, the you get "prependTo n 3 []" as the first call
08:07:59 <Phyx-> which returns []
08:08:05 <Phyx-> so it'll always return []
08:08:14 <nomemory> I see
08:08:27 <CindyLinz> I removed this line, then it works..
08:08:40 <nomemory> right ?
08:08:41 <nomemory> so foldr always starts with the [] ? instead with last ?
08:09:32 <Phyx-> nomemory: foldr op b [1,2,3] = 1 `op` (2 'op` (3 `op` b))
08:10:55 <nomemory> Oh..
08:11:20 <nomemory> prependTo n 3 [] is actually prepend n 3 acc
08:11:24 <nomemory> and acc is [] at first
08:11:34 <nomemory> ok, got it
08:11:35 <nomemory> thanks!
08:12:20 <Phyx-> one way you can think of it is, that if you take your list, [1,2,3] desugar it, 1 : (2 : (3 : [])) , replace the Cons (:) constructor with the operator and the Nil consructor ([]) with the starting element, b
08:13:46 <nomemory> got it Phyx- 
08:13:56 <nomemory> and from a performance point of view
08:14:07 <nomemory> isn't the third attempt more faster ?
08:14:23 <nomemory> as (:) is O(1) while ++ is O(n) ?
08:16:02 <hewei> Hi there! 
08:16:15 <hewei> How should I understand the following please? 
08:16:22 <hewei> @type pure 23
08:16:23 <lambdabot> forall t (f :: * -> *). (Num t, Applicative f) => f t
08:16:28 <hewei> > pure 23
08:16:29 <lambdabot>   No instance for (GHC.Show.Show (f t))
08:16:29 <lambdabot>    arising from a use of `M8348508008...
08:16:45 <hewei> and what GHCi gave me was: 
08:16:55 <hewei> Prelude Control.Applicative> :t pure 23
08:16:56 <hewei> pure 23 :: (Num t, Applicative f) => f t
08:16:56 <hewei> Prelude Control.Applicative> pure 23
08:16:56 <hewei> 23
08:17:00 <Phyx-> nomemory: yeah, it's also a bit more efficient. (but actually I'm not quite sure how much stream fusion is done with prelude functions)
08:17:06 <Phyx-> list fusion*
08:17:11 <scree> nomemory: well, a ++ b takes (length a) time if you evaluate it fully
08:17:36 <scree> nomemory: so all your three solutions are O(length of output list)
08:17:54 <scree> nomemory: which should be pretty optimal :)
08:17:55 <ezyang> Ok, here's the new top-level docblock for MVar that I drafted: http://hpaste.org/43004/mvar_documentation 
08:18:59 <scree> nomemory: but you have to be careful reasoning about the complexity of lazy operators like (++)
08:19:00 <ezyang> Any comments? :-) 
08:19:03 <monochrom> you know how "23" cannot be pinned down as "integer" or "rational number" or "floating point", unless the context pins it down. If the context doesn't, it remains polymorphic, and the type class for that is called Num.
08:19:37 <ToRA> hewei: (I think), ghci will default pure 23 to have type IO Int,  and ghci will run IO actions and then Show their result.
08:19:50 <ToRA> *show
08:19:53 <hewei> monochrom: Thanks! I am more interested in the diff output from lambdabot v.s. GHCi
08:20:12 <ToRA> e.g. in ghci (return 24 :: IO Int) will do the same thing
08:20:14 <quicksilver> hewei: lambdabot doesn't default it to IO.
08:20:22 <monochrom> lambdabot doesn't emulate ghci
08:20:24 <quicksilver> hewei: so it's still an unknown applicative
08:20:33 <quicksilver> and lambdabot doesn't know how to Show an unknown Applicative.
08:20:45 <quicksilver> > pure 23 :: Maybe Int
08:20:46 <lambdabot>   Just 23
08:20:53 <ToRA> also compare (in ghci)
08:20:54 <hewei> so GHCi thought it was an IO Int of pure 23? 
08:20:55 <ToRA> x <- pure 24
08:20:59 <ToRA> vs let x = pure 24
08:21:07 <monochrom> lambdabot puts code into a file, compile. totally not like ghci.
08:21:25 <companion_cube> :t pure
08:21:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:24:15 <hewei> Thanks all! A bit clearer now. 
08:26:29 <hewei> Another question would be, then, how can I ask GHCi to show me what it does to infer the type of the expression I give ? 
08:27:30 <copumpkin> http://en.wikipedia.org/wiki/Type_inference
08:27:40 <Phyx-> does anyone know a tool for windows to show a diff of all the files in a directory? I kinda forgot what my changes to GHC were... and darcs is saying nothing new
08:27:44 <copumpkin> reading up on hindley milner and unification is probably your best bet
08:27:55 <copumpkin> cause ghci has no features for telling you what it's doing
08:27:58 <lunaris> Phyx-: windiff?
08:28:15 <mux> Phyx-: personally, I'd just install cygwin
08:28:47 <Phyx-> lunaris: i'll give it a look thanks :)
08:28:59 <Phyx-> mux: i hate cygwin, it never really works
08:29:08 <Phyx-> I'm using msys to build most of my stuff
08:29:12 <monochrom> long shot: install virtualbox, install linux inside virtualbox, let it access your windows fs, diff.
08:29:15 <mux> Phyx-: it works just fine for me here at work when I'm forced to use windows
08:29:28 <mux> windows makes such a poor development platform :-(
08:29:57 <mux> to each his own, I guess
08:29:57 <monochrom> actually windows makes a great development platform, if you pay for the toolchain
08:29:59 <j-invariant> Hello
08:30:05 <j-invariant> I have this data type: data NaturalTranformation f g = Natural { eta :: forall x. x -> g (f x), epsilon :: forall x. f (g x) -> x }
08:30:17 <aristid> hahaha, case undefined of
08:30:18 <Phyx-> monochrom: lol, I don't even argue about that anymore, :/
08:30:23 <hewei> copumpkin: thanks for the link! 
08:30:31 <j-invariant> does anyoen use it?
08:30:44 <dolio> Why is it called NaturalTransformation?
08:30:51 <dolio> It looks more like an adjunction.
08:30:58 <j-invariant> dolio: you're right, my mistake
08:31:04 <j-invariant> I will rename it to Adjunction
08:31:33 <dolio> Incidentally, the old category extras had an adjunction class.
08:31:49 <copumpkin> you're still missing some stuff for it to be an adjunction aren't you?
08:31:55 <copumpkin> you have the units
08:32:09 <dolio> It's only missing coherence proofs.
08:32:28 <j-invariant> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Adjunction.html
08:32:41 <copumpkin> you want stuff like (f x -> y) -> x -> f y and the other one
08:32:45 <j-invariant> not sure what the letf and right ajunct are
08:32:53 <j-invariant> copumpkin: never seen that before
08:33:46 <j-invariant> ah
08:33:55 <j-invariant> leftAdjunct f = fmap f . unit
08:33:59 <monochrom> eh? (f x -> y) -> x -> g y ?
08:34:02 <j-invariant> rightAdjunct f = counit . fmap f
08:34:12 <j-invariant> you can define unit/counit or define leftAdjunct/rightAdjunct
08:34:46 <copumpkin> oh, fair enough
08:35:20 <j-invariant> so how could I find out if aynone uses Adjunction in haskell ?
08:35:31 <copumpkin> I'm used to thinking of it in terms of a galois connection, where the other version seems more common
08:35:35 <monochrom> hack into people's computers
08:35:46 <Phyx-> oh crap.. the ghc lexer changed....
08:35:55 <Phyx-> now i'm gonna have to regenerate this
08:36:07 <j-invariant> I could put a GHC patch which recognizes adjunctions and secretly sends me an email whenever people do it
08:36:19 <copumpkin> lol
08:36:57 <dolio> Anyhow, the class makes sense, because I don't think two functors can be adjoint in more than one way.
08:37:11 <copumpkin> j-invariant: I'd be willing to bet that nobody has used them for "real code"
08:37:21 <j-invariant> oh how come?
08:37:35 <dolio> Even for a fixed functor F, all left adjoints to F are isomorphic, and same for right adjoints.
08:39:18 <Phyx-> generating marshalling information for the ghc core datatypes is such a pain, lol
08:39:29 <j-invariant> dolio: is that because of haskell or in general?
08:39:37 <dolio> In general.
08:40:37 <quicksilver> dolio: yes. Adjoints are unique.
08:41:13 <quicksilver> copumpkin: they might not have used them explicitly, but the pattern might lurk within nonetheless.
08:41:18 <zong_sharo> hi guys, i want to tag my xmonad-messages, to restrict receiver of the message
08:41:34 <zong_sharo> http://dpaste.com/313470/
08:41:38 <zong_sharo> something like this
08:41:43 <zong_sharo> can it be done simpler?
08:52:04 <Phyx-> did DynFlag get renamed to ExtensionFlag?
08:53:41 <ddarius> type Adjunction f u = forall a b. Iso (f a -> b) (a -> u b)
08:54:30 <rumbold1> hmm, im getting programname: <<loop>> what does that mean?
08:55:04 <monochrom> no, DynFlag is still DynFlag. http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.0.1/GHC.html#t:DynFlags
08:55:05 <Zao> rumbold1: The runtime detected a blackhole.
08:55:16 <Zao> A path of evaluation which will never terminate, so it terminated for you.
08:55:54 <Zao> (something along the lines of ending up evaluating a thunk again while evaluating the thunk.
08:56:23 <Zao> > let x = x+2 in x
08:56:26 <Phyx-> @hoogle Opt_RecursiveDo
08:56:26 <lambdabot>   mueval-core: Time limit exceeded
08:56:27 <lambdabot> No results found
08:59:00 <monochrom> oh oops, DynFlag /= DynFlags
08:59:32 <j-invariant> ddarius: thanks, that's neat
08:59:41 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.0.1/DynFlags.html has DynFlag and ExtensionFlag (no mistake this time)
09:01:20 <monochrom> ah, in ghc 6.12, they are one single data type DynFlag. in ghc 7, they are divorced.
09:01:57 <Phyx-> monochrom: well, that explains why my code isn't compiling anymore
09:02:21 <monochrom> so for example Opt_RecursiveDo was a DynFlag but now an ExtensionFlag, but Opt_WarnIncompletePatterns is still a DynFlag
09:02:35 <Phyx-> yes, which is an annoying problem
09:03:01 <Phyx-> need to find which of the two lexTokenStream takes now
09:03:35 <Phyx-> it still takes DynFlags
09:03:36 <Phyx-> hmm
09:03:56 <Phyx-> so RecursiveDo no longer introduced a new keyword?
09:04:03 <Phyx-> introduces*
09:04:07 <monochrom> in retrospect, using the same type for both the {-# LANGUAGE xxx #-} guys and the -Wblahblah guys probably won't scale. They aren't even remotely related.
09:05:20 <Phyx-> monochrom: if i'm not mistaken, RecursiveDo introduced mdo or something right? before. now that it's not a DynFlag anymore, I'm guessing it no longer has it's own keyword
09:05:40 <quicksilver> I don't think that's right at all, Phyx- 
09:05:55 <monochrom> RecursiveDo adds mdo, DoRec adds rec. RecursiveDo is being deprecated but still exists.
09:05:56 <quicksilver> the change is just to distinguish language extensions for 'mere' runtime arguments.
09:06:15 <quicksilver> the ExtensionFlag type is the one most likely to introduce a new keyword
09:06:27 <quicksilver> DynFlags are more likely just to modify some aspect of compiler UI
09:06:39 <aristid> monochrom: i guess mdo will not actually be deleted anytime soon, because there probably is code relying on it
09:07:01 <monochrom> yeah. deprecated means you still have to support it.
09:07:01 <Phyx-> quicksilver: but lexTokenStream takes DynFlags, which controlled how it tokenized certain things in 6.12
09:07:45 <Phyx-> quicksilver: oh never mind, I see my mistake
09:08:17 <Phyx-> quicksilver: DynFlags contains both DynFlag and ExtensionFlag
09:08:22 <quicksilver> yup
09:08:29 <quicksilver> badly named type
09:08:32 * upb slaps Phyx- 
09:08:36 <Phyx-> lol
09:08:43 <Phyx-> yeah, I deserve that one :)
09:08:44 <monochrom> "extensions :: [OnOff ExtensionFlag]" and "extensionFlags :: [ExtensionFlag]" are fields of DynFlags. The information is still there.
09:09:12 <monochrom> if lexTokenStream takes DynFlags, it is still omniscient.
09:09:31 <Phyx-> monochrom: yeah, I just noticed that, I just need to split the function that identified language pragmas in two
09:09:46 <Phyx-> one that returns [DynFlag] and one that returns [ExtensionFlag]
09:10:10 <upb> still making your visual haskell?:P
09:10:39 <Phyx-> upb: yes, Finally got some free time, now that I finish the implementation part of my thesis, and mostly have writing to do.
09:10:39 <monochrom> visual haskell is the best thing since visual bread
09:10:50 <upb> :
09:10:51 <upb> )
09:10:51 <Phyx-> so i'm upgrading the internal GHC used from a 6.13 to 7.0.1
09:10:55 <Phyx-> and go from there
09:11:22 <Phyx-> submitted a patch to Cabal today for the build system, but GHC's not playing nice so i can't work on the changes to Cabal-Install
09:12:15 <Phyx-> monochrom: visual bread is too colorful :P
09:12:32 <monochrom> children like colourful bread
09:12:55 <aristid> clearly you need sliced visual bread to make it more accessible
09:13:17 <Phyx-> that's for version 2
09:13:27 <Phyx-> think of it as the optimization loop for bread
09:14:10 <aristid> Phyx-: the inventor of sliced bread was basically a predecessor of the GHC developers
09:15:55 <qfr-> http://stackoverflow.com/questions/2610767/visual-haskell-2008-2010
09:16:04 <ray> visual mode
09:16:43 <Zao> Phyx-: Yay, free time!
09:17:27 <Phyx-> aristid: lol
09:17:53 <Phyx-> Zao: well, stolen time :P I turned some of the procrastination time into coding time
09:18:21 <ray> you time bandit
09:18:37 <Phyx-> qfr-: yeah... i overshot my original deadline by a mile...
09:18:45 <Phyx-> I'm a real software developer now :P
09:18:46 <qfr-> Heh
09:19:23 <quicksilver> Phyx-: if you can build a machine for turning procrastination time into coding time, you will be a famous man
09:19:24 <Zao> Phyx-: I know the feeling. I'm currently channeling exam study time into coding :)
09:20:11 <ray> just make a machine for turning procrastination time into money
09:20:12 <Phyx-> quicksilver: true. would you settle for a pill? :)
09:20:13 <dankna> I'm currently channeling coding time into procrastination!  See, it balances out.
09:20:20 <ray> i think that is the real issue here
09:20:34 <quicksilver> conservation of procrastination
09:20:41 <quicksilver> it's the -1th law of thermodynamics
09:20:51 <dankna> -1st.  get it right.
09:20:57 <Phyx-> Zao: hehehe, I'm recoding some of the base code aswell. Adding process isolation, to prevent ghc panics from taking down the IDE. (don't know why I didn't think of this the first time around)
09:21:48 <Phyx-> nothing like your code going *poof* and getting a messagebox "The Impossible has happened"
09:44:39 <joe6> quickcheck vs HUnit: I am testing the usb functionality of a device. I have the list of usb messages to send to the device using System.USB and the expected results in a text file. Which is better for this kind of usage: Quickcheck or HUnit?
09:45:04 <c_wraith> if it's in IO, HUnit
09:45:10 <c_wraith> and that sounds like it's in IO
09:45:25 <joe6> basically, read the testcase from the file, send the usb message to the device and compare the result with the expected result noted in the text file.
09:46:23 <joe6> c_wraith: ok, thanks.
09:47:35 <kmc> that's also not hard to roll your own
09:47:46 <kmc> i'm not sure what benefit HUnit brings; i'm sure there is some though
09:48:26 <joe6> kmc: just do not want to roll my own if something already exists, even if the benefit is marginal.
09:53:13 <quicksilver> joe6: quickcheck vs hunit - wrong question.
09:53:24 <quicksilver> hunit can be used to drive quickcheck tests, and sometime is.
09:53:37 <quicksilver> quick is a way of doing automated random (type-directed) tests of assertions.
09:53:38 <joe6> oh, ok.
09:53:47 <quicksilver> hunit is a harness for bundling tests into units etc.
09:54:08 <joe6> is there anything better than hunit, then?
09:54:11 <quicksilver> however, it *is* true that quickcheck is not well suited for IO testing
09:54:20 <quicksilver> and USB testing is pretty IO-centric.
09:54:36 <joe6> so, I need hunit or something similar to do what I plan on doing.
09:54:39 <quicksilver> erm there was a testing thread on the cafe recently
09:54:47 <quicksilver> not sure if it mentioned antyhing else, let me dig it out
09:54:58 <joe6> quicksilver: thanks a lot.
09:55:46 <quicksilver> ah
09:55:48 <quicksilver> joe6: http://hackage.haskell.org/package/test-framework
09:55:54 <quicksilver> is the other thing that got mentioned.
09:56:05 <quicksilver> I believe test-framework is planned to be part of cabal in future
09:56:13 <quicksilver> well, 'part of' isn't the right word
09:56:15 <quicksilver> supported by
09:56:23 <quicksilver> so that testing can be done at module build time in a standard way
09:56:46 <quicksilver> http://batterseapower.github.com/test-framework/
09:56:49 <quicksilver> seems worth a look
09:56:52 <quicksilver> (I've not used it personally)
09:56:57 <joe6> that looks pretty cool.
09:57:06 <c_wraith> quicksilver: As far as I know, quickcheck has no way to check IO actions
09:57:34 <earthy> isn't there a pure spec of (parts of) io that can be used with quickcheck?
09:57:58 <joe6> it would be very helpful. I wish I had known that a few days ago. I did something a few days ago which could have used it and my job would have gone from 4 days to 2 days.. 
09:58:12 <copumpkin> @hackage iospec
09:58:13 <lambdabot> http://hackage.haskell.org/package/iospec
09:58:18 <joe6> I guess that is how we learn.. put in the hard yards so you can appreciate the finer points..
09:58:19 <earthy> http://hackage.haskell.org/package/IOSpec
09:58:27 <quicksilver> c_wraith: well, you can cheat.
09:58:28 <copumpkin> fucking case-sensitive package names
09:58:59 <quicksilver> earthy: not when that IO is USB devices methinks
09:59:02 <spvensko_> copumpkin, how do they work?
09:59:08 <copumpkin> indeed
09:59:10 <quicksilver> earthy: joe6 is trying to test *real* IO out a real port.
09:59:16 <earthy> quicksilver: well... true. :)
09:59:35 <quicksilver> althouhg a pure model of his devices would enable a certain category of testing, to be sure
09:59:35 <joe6> yes, the device is a real usb device.
09:59:40 <quicksilver> and that you could do in quickcheck
09:59:56 <quicksilver> but obviously you'd have to keep tweaking hte model to make it behave capriciously.
09:59:57 <earthy> you could also use Arbitrary
10:00:02 <earthy> to generate test vectors
10:01:25 <c_wraith> one way of using quickcheck that I found interesting was to generate a representation of a sequence of function calls, then check that their result was as expected.
10:01:50 <c_wraith> I did that in the quickcheck properties for my lrucache package
10:01:54 <ezyang> there's also monadic quickcheck, although I don't know how that works. 
10:05:08 <Philippa> The platform download page doesn't say how big it is
10:05:29 <Philippa> need to know because I'm on a PAYG mobile connection
10:05:44 <Philippa> so 1) anyone wanna fix it?
10:05:44 <Philippa> w
10:06:06 <Philippa> 2) anyone wanna tell me how big the windows DL is?
10:06:28 <copumpkin> 74MB
10:06:37 <Philippa> thanks
10:06:41 <copumpkin> I can't fix it though :/
10:06:49 <Philippa> might cough up for the extra bandwidth then
10:07:13 <djahandarie> copumpkin, diff and send it to dons, I think he can
10:07:27 <Philippa> will probably leave it for home though
10:07:35 <copumpkin> I mean, it's a <10 character change to the HTML
10:07:46 <jonkri> which editor provides more features for working with haskell, vi or emacs?
10:07:47 <copumpkin> diffing and patching is harder than just firing up an editor and putting the size in
10:07:57 <jonkri> i'm just talking about the haskell-specific features now, and i'm not flaming :)
10:08:01 <Philippa> in other news, started coding a biased-choice VPL parsing lib
10:08:36 <Philippa> copumpkin: slightly more, should do each platform
10:11:25 <kmc> jonkri, probably emacs, but i don't think it's a big deal.  use whatever editor you're generally comfortable with
10:12:11 <jonkri> thanks kmc 
10:16:43 <awesomehaskel> I finished the Tutorial, what would be the next logical step. :)
10:16:55 <sproingie> which tutorial?
10:17:01 <awesomehaskel> tryhasskel
10:17:10 <sproingie> learnyouahaskell.com
10:17:22 <monochrom> anything on http://www.vex.net/~trebla/haskell/learn-sources.xhtml
10:17:49 <awesomehaskel> i want something shot and nice for about 3 hours
10:17:52 <sproingie> i'm not big on the gentle introduction
10:18:00 <awesomehaskel> short
10:18:12 <monochrom> the gentle introduction is short and nice for about 3 hours
10:18:24 <sproingie> learnyouahaskell.com is definitely longer but worth it
10:18:25 <awesomehaskel> thank you
10:18:30 <awesomehaskel> how many pages
10:18:33 <awesomehaskel> 200
10:18:44 <spvensko_> lyah isn't short but like others have said, it's good
10:18:51 <spvensko_> i'm on the fourth chapter now and i've enjoyed it so far
10:19:05 <awesomehaskel> ok gonna try
10:19:14 <awesomehaskel> so this one  learnyouahaskell.com right
10:19:20 <sproingie> what's nice about lyah is by the time it finally gets around to monads, they're so simple that you wonder what all the fuss was about
10:19:59 <monochrom> nothing stops you from reading something short now and something long later. I don't understand why people try to be mutually exclusive.
10:20:06 <sproingie> i had to learn when the literature was rife with bad analogies
10:20:25 <sproingie> even now monad transformers sort of stick in my craw
10:20:28 <awesomehaskel> just asking dont have to take it personal
10:20:42 <awesomehaskel> well off I go.thank you
10:20:54 <monochrom> you are fine. I'm referring to all these other people.
10:20:58 <c1de0x> copumpkin has challenged me. i have accepted. i hope i don't die.
10:20:59 * sproingie
10:21:20 <copumpkin> lol
10:22:02 <c1de0x> copumpkin i'm putting you down as my emergency mental health contact, mkay
10:22:12 <copumpkin> sounds good :P
10:23:04 <monochrom> now you have to hope also that copumpkin doesn't die.
10:23:44 <c1de0x> copumpkin is a root vegetable. (or something) if he dies, i'll just replant him.
10:24:08 <copumpkin> not sure I'm a root
10:24:30 <monochrom> wait, pumpkin is a root vegetable sure. but copumpkin?
10:24:42 <copumpkin> oh, maybe
10:24:44 <copumpkin> hadn't thought of that
10:25:38 <quicksilver> pumpkins are not root vegetables
10:25:40 <quicksilver> they are fruit.
10:25:52 <quicksilver> as for copumpkins...
10:26:00 <monochrom> ok, so copumpkin is a co-fruit
10:28:40 * shachaf contemplates making a copumpkin mpote.
10:28:49 <copumpkin> :P
10:31:41 <jonkri> what are my options if i want to be able to 1) set up arbitrary darcs users that are not system users and 2) don't want to use ssh? is it possible to do darcs pushes over http, like using webdav or something?
10:33:54 <jonkri> (i want to be able to push to the repo)
10:34:55 <quicksilver> jonkri: I don't think it is.
10:35:37 <quicksilver> although, there is http://www.equational.org/darcs-server/
10:35:42 <quicksilver> I don't know if anyone uses it
10:36:54 <jonkri> ok, thanks
10:45:00 * hackagebot monoid-statistics 0.2 - Monoids for calculation of statistics of sample  http://hackage.haskell.org/package/monoid-statistics-0.2 (AlexeyKhudyakov)
10:58:13 <elliott> What's the easiest way of getting the Haskell Platform 2010.2 on Ubuntu?
10:58:15 <elliott> Is there a PPA?
10:58:43 <j-invariant> elliott: it's easy just download it
10:59:03 <elliott> i don't wanna install a bunch of files outside apt
10:59:07 <elliott> ...or use checkinstall :P
10:59:17 <monochrom> ignore checkinstall
10:59:19 <j-invariant> well there is an old GHC in apt but I don't know anything else
10:59:42 <elliott> j-invariant: 6.12.1, not exactly old
11:00:01 <elliott> well okay, december 2009
11:00:02 <elliott> but still
11:00:19 <monochrom> see http://www.vex.net/~trebla/haskell/sicp.xhtml#ghc6121 for a nasty bug you will regret
11:00:51 <elliott> monochrom: aw, dammit.
11:01:11 <elliott> anyone got a ppa of ghc and haskell platform then? https://launchpad.net/ubuntu/+ppas?name_filter=haskell-platform has a few but i don't know how active they are.
11:01:51 <monochrom> apart from 6.12.1 bug, any ppa is fine as long as it matches your ubuntu version
11:01:55 <comwarrior> I'd like to write a dealer probability routine for blackjack. In blackjack, the dealer draws until his total is 17 or more. Aces count as either 1 or 11, and in some casinos the dealer takes a card on "soft 17" e.g. A 6, and in others he stays. In any case, this is a recursive process that would seem to be well-modeled by a tree. Now, how does the probability distribution of totals change as cards are removed or if you can specif
11:02:16 <elliott> https://launchpad.net/~justinbogner/+archive/haskell-platform This looks like the thing to go with.
11:02:20 <elliott> Argh, it's on 2010.1.
11:02:47 <monochrom> there is also a web page saying "just apt-get these packages". it says to include checkinstall but that's a red herring. absolutely nothing needs it.
11:03:10 <elliott> monochrom: I'm not going to install GHC/Haskell Platform without either apt or checkinstall.
11:03:25 <elliott> Leaving non-package-managed files lying around on my system isn't my idea of fun ...
11:03:38 <monochrom> oh ok then include checkinstall. it doesn't harm.
11:04:07 <elliott> You mean I have to compile my own GHC? :-(
11:04:28 <monochrom> no. not sure how you deduced that.
11:04:50 <elliott> Then use an outdated GHC? I haven't seen an up-to-date PPA.
11:05:07 <monochrom> 6.12.1 is more or less associated with 2010.1. 6.12.3 is more or less associated with 2010.2.
11:05:19 <j-invariant> just instrll the new one
11:05:20 <elliott> Indeed, and?
11:05:30 <elliott> j-invariant: with which GHC, exactly?
11:05:50 <j-invariant> http://hackage.haskell.org/platform/linux.html
11:06:17 <elliott> j-invariant: i am aware of that page.
11:06:24 <elliott> j-invariant: with which GHC do you propose I compile the Haskell Platform?
11:06:26 <elliott> and from where?
11:06:27 <monochrom> I'm not sure that j-invariant really knows.
11:06:28 <j-invariant> this is the answer to your question
11:06:38 <elliott> I have looked over that entire page
11:06:58 <elliott> my options seem to be an outdated, GHC 6.12.1 based package from Ubuntu, or compiling it from source
11:07:04 <elliott> doing the latter requires GHC 6.12.3
11:07:12 <elliott> which it appears i would have to compile myself,  yes, j-invariant?
11:07:25 <j-invariant> I didn't have to
11:07:45 <elliott> j-invariant: so you have an old ghc with the bug monochrom mentioned?
11:07:45 <jmcarthur> aren't there binary distributions of ghc as well?
11:07:56 <j-invariant> elliott: I have 6.12.1
11:08:01 <elliott> so, yes, you do
11:08:15 <katja> how can I go to another haskell channel?
11:08:17 <elliott> jmcarthur: they come as tarballs, so i'd have to use checkinstall again :)
11:08:21 <monochrom> you should consider http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
11:08:27 <elliott> it seems strange that there isn't some updated PPA with ghc 6.12.3/hp 2010.2
11:08:50 <j-invariant> http://haskell.org/ghc/download_ghc_6_12_3#x86linux
11:08:59 <elliott> j-invariant: <elliott> jmcarthur: they come as tarballs, so i'd have to use checkinstall again :)
11:09:00 <comwarrior> If Haskell is what it's advertised to be -- expressive, succinct -- I would expect a dealer probability routine would be a handful of lines of code. You could do in it Basic in 28 lines.
11:09:08 <elliott> also i'm on x86_64
11:09:09 <j-invariant> what's checkinstal?
11:09:12 <kaini> I've got a list [1,2,3,4] how do I get all permutations with *only three* elements [1,2,3], [1,2,4], [1,3,4], ...? Is there a function for that or do I have to code it myself?
11:09:20 <j-invariant> elliott: scroll down
11:09:24 <elliott> j-invariant: i know.
11:09:26 <kmc> those aren't permutations kaini 
11:09:34 <kmc> all of the permutations of a 4-element list have 4 elements, by definition
11:09:36 <kaini> kmc, how are they called?
11:09:44 <kmc> subsequences?
11:09:45 <monochrom> no one builds ghc ever. (this is an exaggeration)
11:09:47 <kmc> i'm not sure what the best term is
11:09:48 <elliott> j-invariant: checkinstall lets you turn "make install" into a deb package but it's ugly.
11:09:59 <j-invariant> oh right, I am not suggestingp to use that
11:10:17 <elliott> j-invariant: then the only option w/ the binary package is make install
11:10:24 <elliott> which will leave a bunch of files not tracked by apt lying around.
11:10:26 <j-invariant> elliott: it worked fine for me
11:10:32 <elliott> which kinda defeats the point of using a package manager.
11:10:37 <elliott> j-invariant: try uninstalling it
11:10:37 <j-invariant> you can still install other stuff with apt
11:10:42 <j-invariant> I don't want to :|
11:10:42 <elliott> um i realise that
11:10:45 <monochrom> anyway, not deb or ppa of ghc 6.12.3 or hp 2010.2. this won't change even if you keep asking.
11:11:03 <aavogt> @hoogle selections
11:11:03 <lambdabot> No results found
11:11:11 <monochrom> if you insist on apt, go with the existing "old" ppa's
11:11:25 <elliott> but what about that extremely deadly bug :)
11:11:38 <monochrom> if you never "cabal install", you won't run into the 6.12.1 bug anyway
11:11:42 <j-invariant> not sure what bug you mean
11:11:48 <elliott> monochrom: of course i'd cabal install
11:12:14 <monochrom> ok, then make sure you don't cabal install the same packages you apt-get
11:12:33 <monochrom> or more precisely, same package-version
11:12:38 <dcoutts_> monochrom: what was wrong with 6.12.1?
11:12:40 * dcoutts_ forgets
11:12:49 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#ghc6121
11:12:52 <kmc> you can insall using make install, within a local prefix
11:13:02 <kmc> make one just for haskell platform
11:13:07 * elliott apt-gets cabal-install, then cabal installs haskell-platform
11:13:09 <elliott> kmc: ew.
11:13:29 <monochrom> yeah actually I set aside /usr/local/haskell-platform-2010.2.0.0 for this
11:14:06 <kaini> > foldl1 (++) $ map permutations $ filter (\x -> length x == 3) $ subsequences [1..4]
11:14:08 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[1,2,4],[2,1,4],[4,2,1],[2...
11:14:09 <elliott> maybe i'll write cabal2deb and manage everything like that. :)
11:14:24 <kaini> kmc, thanks for the idea with subsequences!
11:14:56 <dcoutts_> monochrom: ahh, nasty
11:15:03 <alpounet> elliott, you can look at how cabal2arch does this and modify the code to get cabal2deb :p
11:15:09 <alpounet> although there probably already is a tool for this
11:15:15 <dcoutts_> monochrom: I hope to make all that advice on that page obsolete :-)
11:15:33 <elliott> alpounet: I might just.
11:15:43 <elliott> alpounet: then create an apt-cabal so that "sudo apt-cabal install foo" works, hehe
11:16:10 <alpounet> i guess that would somehow be cabal install --global
11:16:25 <elliott> alpounet: well, presumably it'd be more like
11:16:28 <elliott> - download from hackage
11:16:29 <elliott> - unpack
11:16:34 <elliott> - run cabal2deb
11:16:36 <elliott> - dpkg --install
11:16:43 <elliott> except doing dependencies too
11:16:48 <elliott> shouldn't be "hard", cabal2deb is the tricky part
11:17:41 <monochrom> you or everyone will never make all of my advices on that page obsolete. there are fundamental contradictions and flaws.
11:18:41 <j-invariant> you can just do  cabal install
11:18:45 <sleepynate> ot
11:18:47 <monochrom> package managers requires monopoly, cabal-install requires anarchy. you will never resolve that, unless you give up one of them.
11:19:16 <elliott> j-invariant: that isn't managed be apt.
11:19:20 <sleepynate> it's good to know that haskell is becoming such a popular language due to the optimism of its more knowledgable users.
11:19:32 <elliott> To be honest, I'm pretty sick of all the language-specific package managers.
11:19:35 <j-invariant> elliott: why does apt matter? You can install software in multipli different ways without it clashing
11:19:43 <elliott> j-invariant: there is no cabal uninstall
11:19:45 <monochrom> some distros write directly to package.conf.d, completely circumventing ghc-pkg sanity checks. you will never resolve that as a developer of cabal-install or Cabal. you don't own the distros.
11:19:53 <j-invariant> oh okay
11:19:55 <elliott> apt provides the best, most stable, most featureful unified interface to package management I know of.
11:20:00 <elliott> the others are... well, inferior
11:20:13 <dcoutts_> monochrom: certainly you'll still have the situation that user packages that depend on distro packages can be broken when the distro tool unistalls things
11:20:15 <sleepynate> elliott: i assume you're running ubuntu?
11:20:15 <cdsmithus> monochrom: People in the Haskell community generally do maintain distribution packages
11:20:20 <elliott> cabal itself is great, I just don't think much of cabal-install :)
11:20:22 <elliott> sleepynate: yes
11:20:23 <j-invariant> it's probably easier to write an uninstaller
11:20:30 <sleepynate> elliott: don't use aptitude for anything that is haskell or perl related
11:20:32 <j-invariant> though the other thing would be more useful
11:20:40 <sleepynate> elliott: use cpan and cabal. that's it.
11:20:51 <aristid> elliott: and if dons would use debian, the apt packages would be in great state too
11:20:51 <aristid> alas, dons uses arch
11:21:06 <elliott> sleepynate: Yeah, and use gem for Ruby and pip for Python because every damn language thinks it's the greatest thing in the world and it needs a special corner of your system to break the normal system rules you're experienced with. Sigh.
11:21:25 <elliott> For now I've installed the haskell-platform Ubuntu package and will just use cabal-install to handle additional packages, but maybe I'll write cabal2deb sometime...
11:21:33 <sleepynate> elliott: there's a slight problem with your theory
11:21:43 <dcoutts_> elliott: your complaint about cabal-install presumably is about it not being a good package manager?
11:21:48 <sleepynate> elliott: every distribution uses it's own package manager too :P
11:22:03 <elliott> dcoutts_: No, cabal-install could be a perfectly good package manager; I think it's alright, apart from the lack of uninstallation.
11:22:07 <sleepynate> elliott: so, you like apt, i like pacman and portmaster
11:22:11 <glguy> cabal-install is a package downloader and installer. It doesn't bother with management
11:22:13 <elliott> dcoutts_: My complaint is generic: I don't like using multiple package managers.
11:22:18 <dcoutts_> elliott: ah ok
11:22:21 <elliott> sleepynate: which is why cabal2foo is the right way, IMO.
11:22:23 <aristid> elliott: well, most distributions just move too slow for the language communities
11:22:26 <elliott> cabal2arch, cabal2deb
11:22:35 <elliott> aristid: I don't propose trying to integrate Haskell packages into distributions.
11:22:44 <elliott> I just think that it should be backed by the distro package manager, in this case, dpkg.
11:22:53 <monochrom> /usr/local/haskell-platform-2010.2.0.0 is my package manager.
11:23:10 <sleepynate> monochrom: roflsauce
11:23:12 <dcoutts_> elliott: so there are two approaches you can take with the native ditro packages, one is to translate the cabal packages into native packages and use the distro tools to resolve the deps.
11:23:26 <dcoutts_> elliott: this is what the people who maintain the distro packages do
11:23:52 <dcoutts_> elliott: and the other is to get cabal-install to do the dep resolution and to just use the native package manager to manage the installed files
11:24:04 <elliott> dcoutts_: What I would do is: There is a program, for instance apt-cabal, that acts like cabal install: it looks up the Hackage dependencies of the given package, installs them all, and then installs the current package. It achieves the single install step by running cabal2deb on the package and dpkg --installing it.
11:24:07 <dcoutts_> the latter allows e.g. making up packages on the fly
11:24:07 <elliott> So, the latter solution, really.
11:24:21 <elliott> dcoutts_: It would install it prefixed with, e.g., "haskell-cabal-" or some other prefix unused by the distro to avoid conflicts.
11:24:47 <dcoutts_> elliott: or just an extension to the cabal tool itself, a customisable install step
11:24:51 <elliott> Admittedly, this means that you have to do "apt-cabal upgrade" rather than doing it via APT, but it's a much simpler solution, and works automatically for just about all packages.
11:24:56 <elliott> dcoutts_: yes, that could work.
11:25:08 <dcoutts_> e.g. can use stow, deb, gentoo thing, etc etc
11:25:09 <elliott> dcoutts_: if e.g. there was "debdist" as well as "sdist"
11:25:23 <elliott> dcoutts_: I'll look into seeing how difficult making that would be, and maybe make some patches.
11:25:47 <dcoutts_> elliott: it's on Galois's IHG list, so you can ask the IHG to do it :-)
11:25:54 <elliott> dcoutts_: One thing, though ... can cabal builds be relocatable?
11:26:03 <elliott> dcoutts_: I don't think so: you have to specify their install prefix at compile-time.
11:26:06 <dcoutts_> elliott: by default, no
11:26:10 <elliott> hmm
11:26:15 <dcoutts_> elliott: right, --prefix
11:26:25 <elliott> dcoutts_: btw, using cabal with stow is liquid pain
11:26:30 <dcoutts_> elliott: we have some support on windows and I have an idea about how to do it on unix
11:26:36 <elliott> dcoutts_: it doesn't support separate install-time and run-time directories, so you have to use destdir like:
11:26:41 <elliott> --destdir=foo
11:26:45 <dcoutts_> the user interface would be --prefix-independent or similar, to ask for relocatable
11:26:47 <elliott> cp foo/* /stow/blah
11:26:50 <elliott> (I forget the exact option.)
11:27:42 <dcoutts_> elliott: but that's the standard way of doing things, specify runtime prefix, then do cabal copy --destdir= whatever
11:27:50 <dcoutts_> it's fine as long as it's automated
11:28:10 <elliott> stow is irritating in various ways anyway
11:28:15 <elliott> dcoutts_: well sure, but with stow it's different
11:28:21 <dcoutts_> ./configure --prefix && make install DESTDIR=img works in the same way
11:28:50 <elliott> you emulate "./configure --prefix=/usr/local && make && make install prefix=/stow/packagename" with "./configure --prefix=/usr/local && make && make install DESTDIR=root && cp root/* /stow/pkgname"
11:28:52 <elliott> basically
11:28:55 <elliott> which is ugly
11:29:24 <monochrom> if stow sucks, don't use stow. not that I know who is stow.
11:29:33 <dcoutts_> elliott: I must be missing something, I don't see the distinction
11:29:58 <elliott> dcoutts_: the two snippets are exactly equivalent, but the point is that you can't do the former with cabal
11:30:03 <elliott> dcoutts_: with cabal, it isn't quite as simple as the latter
11:30:09 <elliott> since you have to copy and register separately and the like
11:30:39 <dcoutts_> elliott: so prefix= replaces the $prefix var right?
11:30:58 <elliott> dcoutts_: yes
11:30:59 <dcoutts_> elliott: which does not work in general, since not all dirs have to be relative to the prefix
11:31:14 <elliott> dcoutts_: that's bad practice :P
11:31:17 <elliott> i would say
11:31:18 <dcoutts_> where as DESTDIR is additional
11:31:29 <dcoutts_> elliott: sure, but you can't stop users doing that :-)
11:31:49 <dcoutts_> cabal used to have a --prefix at copy/install time, but we removed it for that reason
11:31:51 <elliott> dcoutts_: I would be happy if doing the equivalent of the former auto-translated into the latter.
11:32:02 <elliott> Even call it --stow-prefix if you want. :p
11:33:48 <dcoutts_> elliott: so the hard thing with installing via distro packages is limitations like only one version, or only one instance of the same version
11:33:59 <copumpkin> dcoutts_: I'm having a weird issue with cabal(-install) (unrelated to testing :P)
11:34:09 <dcoutts_> sigh
11:34:10 <elliott> dcoutts_: Only one version is something I would keep to anyway, as it's practically a prerequisite for sanity.
11:34:29 <dcoutts_> elliott: it's quite a constraint however during development
11:34:38 <kmc> elliott, not when your package manager keeps track of version dependencies
11:34:43 <dcoutts_> it's doable when you've already done a lot of QA, but not hacking
11:34:48 <elliott> kmc: It's still a pain when compiling your own stuff.
11:34:56 <kmc> no, because you use that same package manager
11:34:59 <elliott> dcoutts_: possibly. I don't really use cabal-install when developing.
11:35:04 <kmc> if you compile your own stuff with cabal then it's no problem
11:35:15 <kmc> i agree this is a *little* more work
11:35:21 <dcoutts_> elliott: no, but presumably you use it to install the deps of the thing that you are developing?
11:35:34 <kmc> but i'm happy that i can have two apps which use different versions of some library without awful explosions
11:35:38 <dcoutts_> the "standard" deps, not the things you're hacking on
11:35:55 <copumpkin> dcoutts_: basically, if I cabal install c2hs, it installs and builds fine (with a few warnings), but doesn't show up in ghc-pkg list, and typing cabal install c2hs again will rebuild it as if I'd never installed it in the first place. Putting c2hs as a dependency of another package also doesn't notice c2hs is installed :(
11:36:00 <elliott> dcoutts_: that's true
11:36:17 <dcoutts_> elliott: my plan for cabal-install is to make it more nix-like, so that one can have multiple non-interfering instances of the same package version at once
11:36:43 <dcoutts_> elliott: since project 1 might need B built against C-1 but project 2 might need B built against C-2
11:36:51 <elliott> dcoutts_: Right. I tend to avoid such anarchy. :)
11:37:23 <dcoutts_> elliott: sure it's good if you can, and distros do try to avoid that. It's harder to avoid when half way through hacking about.
11:37:34 <dcoutts_> it also guarantees you can install new stuff without breaking old stuff
11:37:40 <dcoutts_> you get a persistent package store
11:38:00 <elliott> I've never really ran into such issues, but if I did I'd probably try to resolve the conflict rather than go all Schrödinger's-package-manager.
11:38:01 <dcoutts_> copumpkin: programs do not get registered with ghc-pkg
11:38:06 <elliott> That's just me, though. :)
11:38:08 <dcoutts_> :-)
11:38:38 <dcoutts_> copumpkin: you can list programs as dependencies using the build-tools field, e.g. "build-tools: c2hs >= 0.16"
11:38:39 <copumpkin> dcoutts_: so how does one depend on happy then? I thought cabal-install wouldn't automatically resolve such dependencies but it would still keep track of them being installed (SHE shows up on my ghc-pkg list at least)
11:38:43 <copumpkin> oh
11:39:07 <dcoutts_> copumpkin: however, cabal-install does not yet track dependencies on tools, so it will not automatically install happy
11:39:17 <copumpkin> yeah, I noticed that
11:39:19 <dcoutts_> that's a hopefully short term limitation
11:39:25 <copumpkin> but I thought something could still list it as a build-depend
11:39:30 <copumpkin> maybe it was a tool
11:39:44 <monochrom> oh god, gtk2hs totally needs this build-tools field too
11:39:47 <copumpkin> oh I see
11:39:48 <c_wraith> you can list it as a build-depend, but if you do that, it will be re-installed every time
11:39:59 <waterlaz> I have these problems with ghc optimizations. I've already asked questions here but didn't resolve the trouble
11:40:02 <c_wraith> because there's no package by that name returned by ghc-pkg list
11:40:03 <copumpkin> I can depend on SHE because it also includes a library
11:40:08 <monochrom> build-depend is good for haskell libs only. it queries ghc-pkg
11:40:10 <copumpkin> the ShePrelude
11:40:19 <waterlaz> setArray arr v = do
11:40:20 <waterlaz>     bds <- getBounds arr
11:40:20 <waterlaz>     forM_ (range bds) $ \i -> writeArray arr i v
11:40:25 <copumpkin> that makes sense
11:40:26 <monochrom> looks like you also need the knowledge from http://www.vex.net/~trebla/haskell/sicp.xhtml
11:40:27 <dcoutts_> c_wraith: hmm, that should probably simply fail. Packages that do not expose a lib probably should not be listable in build-depends.
11:40:40 <waterlaz> it works fast in small tests I write
11:40:42 <copumpkin> monochrom: you're right :)
11:40:59 <waterlaz> but inside a bigger program it allocates lots of space
11:42:04 <monochrom> hrm, gtk2hs already uses the build-tools field
11:42:20 <waterlaz> I use it with IOUArray (Int, Int) Double and compile my code with -O2
11:43:08 <monochrom> what's wrong with the build-tools field: it is just "program list". it doesn't tell user about package names.
11:43:16 <waterlaz> so does anyone know what should I be looking at?
11:43:50 <dpratt71> if anyone is in the mood to be critical, please critique my code: http://hpaste.org/43007/bowling
11:44:13 <dpratt71> it works (I think), but it's ugly (I think)
11:44:20 <c_wraith> monochrom: the build-tools field isn't restricted to tools that can be installed from hackage.  So why should it assume that if a tool isn't in the path, it should try to install it from hackage?
11:44:34 <monochrom> "build-tools:    gtk2hsC2hs, gtk2hsHookGenerator, gtk2hsTypeGen" cannot possibly tell you to grab gtk2hs-buildtools
11:45:09 <dpratt71> btw, it's supposed to calculate the score for a string in 10-pin bowling
11:45:19 <ezyang> dpratt71: The pattern matching is not complete 
11:45:22 <monochrom> did I ever say there should be automatic install? or did you make that up?
11:45:42 <monochrom> I'm talking about informing users and error messages all along.
11:45:55 <monochrom> COULD YOU PEOPLE STOP READING BETWEEN THE LINES.
11:45:58 <ezyang> dpratt71: Although it might be ok if you never pass it a two element list. 
11:46:07 <dpratt71> ezyang: supposing the missing pattern(s) represent invalid scenarios, how should I handle that?
11:46:25 <ezyang> dpratt71: In this case, I think explicitly adding an error might not be a bad idea. 
11:46:48 <ezyang> usually, we try to setup our types so that our functions are not partial, but lists that must have N elements are a bit clunky to encode in the type system. 
11:46:51 <dcoutts_> c_wraith: I filed http://hackage.haskell.org/trac/hackage/ticket/789
11:46:55 <dpratt71> ezyang: ok, I'll have to think this through a bit (which is a good thing :) )
11:47:11 <ezyang> f is kind of a confusing variable name for a value, since it implies function 
11:47:13 <dpratt71> anything else? anyone? come on, I can take it!
11:47:47 <dpratt71> ezyang: yeah, I considered that; it represents the 'frame'? ought I call it frame?
11:47:48 <dcoutts_> monochrom: a tool could usually resolve automatically by checking what exes each available package provides.
11:47:52 <ezyang> Actually, the format of the list isn't very clear 
11:48:05 <ezyang> If I bowl a 2 and an 8, is that encoded as [2,8]? 
11:48:12 <ezyang> (as in, a spare) 
11:48:15 <monochrom> in fact if you really read past channel logs, you will find me actually saying that cabal-install should never automatically install dependencies, ever. it should only list.
11:48:21 <dpratt71> ezyang: yes
11:48:36 <copumpkin> monochrom: that sounds really fun to use
11:48:37 <ezyang> So it might be a good idea to write a data type Spare | Strike | WhateverTheOtherThingIsCalled Int 
11:49:03 <dpratt71> ezyang: I started there, but it got a little dicey (for me)
11:49:06 <ezyang> which will make the code a bit clearer, because then you're no longer consuming 1-2 elements of the list. 
11:49:08 <EvanCarroll> dispatch :: [(String, [String] -> IO ())]  
11:49:09 <EvanCarroll> dispatch =  [ ("add", add)   , ("view", view)   , ("remove", remove)   ]  
11:49:16 <ezyang> Now that you have working code, it's worth looking at it again :-) 
11:49:18 <EvanCarroll> How is that the right type signature
11:49:19 <comwarrior> Please don't tell me that you're forced to create a monadic cathedral for a 28-line basic program that happens to do probability calculations.
11:49:27 <ezyang> Stylistically, you can simplify 
11:49:31 <j-invariant> comwarrior: LOL
11:49:37 <comwarrior> A Basic program that uses line numbers.
11:49:42 <ezyang> for example, r1 == 10 can become f (10:r2:r3) = ... 
11:49:44 <EvanCarroll> oh wait
11:49:46 <EvanCarroll> nevermind!
11:49:48 <elliott> <monochrom> in fact if you really read past channel logs, you will find me actually saying that cabal-install should never automatically install dependencies, ever. it should only list.
11:49:49 <elliott> oh man
11:49:51 <elliott> like slackware!
11:49:57 <elliott> comwarrior: stop trolling, nobody's going to feed you
11:50:08 <comwarrior> Not trolling. Really want to do it.
11:50:11 <dpratt71> ezyang: ooh, I like that
11:50:23 <ezyang> You're also using a strange way of only processing the first elements of the list 
11:50:24 <elliott> comwarrior: then don't say crap like "monadic cathedral" and implying it can't be done
11:50:24 <comwarrior> Want the Basic program?
11:50:31 <elliott> not really
11:50:31 <copumpkin> comwarrior: the issue is with the tone of the question
11:50:33 <ezyang> use 'take' instead 
11:50:33 <comwarrior> I'm sure it CAN be done.
11:50:44 <j-invariant> comwarrior: it's okay
11:50:47 <elliott> comwarrior: you don't state it in a way that makes me think doing it would be worthwhile, i imagine i'm not the only one
11:50:57 <ezyang> well, but you need to do the data type transform first ;-) 
11:51:00 <j-invariant> comwarrior: the truth is the monads are very simple
11:51:09 <ezyang> although I feel like bowling easily generalizes to arbitrarily long games 
11:51:14 <j-invariant> comwarrior: that's why poeple are confused about what you say
11:51:20 <dpratt71> ezyang: getting back to the data type idea...
11:51:40 <dcoutts_> monochrom: hmm, perhaps you'd like to be able to add --dry-run persistently to your ~/.cabal/config.
11:51:43 <comwarrior> I'm just a newbie, and for me monads are both obvious and mystifying.
11:52:02 <dpratt71> ...there are some scenarios that I was not sure the best way to handle...
11:52:09 <copumpkin> comwarrior: anyway, you aren't forced to do a monadic cathedral, no :P
11:52:29 <monochrom> I don't understand comwarrior's question.
11:52:59 <ezyang> wouldn't it be a triadic cathedral, given the holy trinity and all? ;-) 
11:53:16 <ezyang> dpratt71: Ask away 
11:53:18 <comwarrior> In idiomatic Haskell... write a routine that generates dealer probabilities for blackjack.
11:53:26 <monochrom> Perhaps it's really just a request, "please don't tell me xxx". OK, I agree to not tell you xxx. You're welcome in advance.
11:53:39 <ezyang> comwarrior: Hm. Depending on how you do it, you may not need monads at all. 
11:53:41 <dpratt71> ezyang: trying to formulate :)
11:54:13 <dpratt71> so suppose the sequence is [Strike, Spare, Open 3...]
11:54:22 <comwarrior> Well, of course this is only a small part of a larger problem. But if I can't do this (and I'm having a hard time), I feel like there's no hope...
11:54:40 <ezyang> practice, good sir. 
11:54:58 <dpratt71> scratch that, bad example
11:55:02 <ezyang> dpratt71: You can pattern match against constructors, if that's what you're asking 
11:55:08 <ezyang> so Strike:Strike:Strike:rs is ok. 
11:55:38 <dpratt71> suppose the sequence is [Strike, Open 3, Spare, Spare, ...]
11:56:00 <katja> hey! is there any channel where I can describe my problem in haskell and someone will help me?? it sounds odd))
11:56:10 <ezyang> katja: WE can try. 
11:56:14 <monochrom> there is.
11:56:29 <katja> oh.. ok
11:56:29 <dpratt71> hmm
11:56:34 <sipa> katja: if you ask your question, we can even try!
11:56:40 <comwarrior> If you know the game, the dealer has a fixed strategy. He just draws until he has 17 or more. Aces are either 1 or 11; 1 if making it 11 puts you over a total  of 21.
11:56:56 <j-invariant> katja: what is it about?
11:57:02 <dpratt71> maybe I don't have the problem I thought I did...lemme ponder a minute
11:58:07 <katja> http://stackoverflow.com/questions/4682705/haskell-numbers-in-binary-numbers-words   that is my programm BUT i have one problem. IN should be : ['f','o'] OUT ([('f',[1,0,0]),('o',[1,1,1,1])],[1,0,0,1,1,1,1])
11:59:07 <dpratt71> ezyang: ok I got it (I think): if I get two spares in a row, the first roll of the second spare factors into the score of the first spare
11:59:25 <tolkad> How much overhead is there in using TArray?
11:59:35 <dpratt71> ezyang: i.e. I don't think I can 'forget' how I got the spare
11:59:46 <ezyang> ok, then you need to do (Spare r1 r2) 
12:00:29 <ezyang> In Haskell, we live and die by the data types we define. It's that important :-) 
12:00:30 <dpratt71> ezyang: yeah, maybe I don't have as many cases as I first thought...at first it seemed like an explosion of pattern matching
12:00:56 <ezyang> You can always do a case statement inside, if you don't want to do combinatorial pattern matching 
12:01:04 <ezyang> esp a good idea if there is shared code between cases. 
12:01:15 <ezyang> Also, note that you can use guards to grab classes of matches. 
12:01:26 <katja> ezyang: do you tell it to me?
12:01:28 <dpratt71> ezyang: thanks very much for the advices
12:01:33 <katja> oh
12:01:34 <katja> no
12:01:47 * dpratt71 steps away for a few...
12:01:53 <tolkad> like if I'm using STM should I just make all my arrays TArrays? or should I only use them if I actually want to be able to have multiple threads access different elements at the same time?
12:02:07 <kmc> tolkad, the condition is even narrower than that
12:02:26 <kmc> you only need TArrays if you want multiple threads to access *and* you need to build atomic transactions out of multiple sequential accesses
12:02:49 <kmc> i believe it's totally safe to modify IOArrays in multiple threads
12:03:01 <kmc> you just have no way to insist that a sequence of modifications (a "transaction") is atomic
12:03:05 <comwarrior> Every time I look for stuff having to do with this problem I run into monads. State monads. Probability monads. Applicative functors. Arrows. For crying out loud. If this isn't creating a cathedral, it's at least looking pew furniture.
12:03:36 <kmc> yeah lots of Haskell types implement the Monad API
12:03:43 <monochrom> katja: I get no errors.
12:03:45 <kmc> lots of Java types implement the Comparable interface
12:03:47 <kmc> what's your point
12:04:01 <kmc> (and arrows aren't monads)
12:04:11 <kmc> (and neither are applicative functors)
12:04:19 <comwarrior> My point is this is a simple program in Basic. 28 lines. Why not in Haskell?
12:04:30 <kmc> comwarrior, probably because you just started learning Haskell
12:04:33 <kmc> it's not easy to learn
12:04:34 <j-invariant> comwarrior: it's probably less in haskell
12:04:34 <tolkad> comwarrior: what's the program?
12:04:41 <katja> monochrom: there will no be errors. I have corrected everything. the problem is in IN and OUT it should be different
12:04:52 <kmc> most people are used to the idea that a new language is some new syntax for familiar concepts
12:04:56 <kmc> Haskell doesn't work that way
12:04:57 <j-invariant> comwarrior: what's the BASIC program? maybe I can suggest something
12:05:01 <tolkad> comwarrior: and Monads are simple
12:05:07 <katja> monochrom: out should be ([('f',[1,0,0]),('o',[1,1,1,1])],[1,0,0,1,1,1,1])
12:05:07 <j-invariant> comwarrior: (I mean if the source code is easy to paste somewhere)
12:05:15 <tolkad> comwarrior: once you understand them
12:05:27 <comwarrior> How do I post a program?
12:05:30 <kmc> hpaste.org
12:05:32 <katja> monochrom: but mine programm shows onle encoded words already
12:05:32 <kmc> don't try to understand monads in general
12:05:36 <kmc> not right away
12:05:59 <tolkad> The only thing special about monads is the do-syntax syntatic sugar
12:06:01 <copumpkin> comwarrior: http://savagelook.com/blog/portfolio/8-steps-for-being-asshole-effectively
12:06:10 <kmc> it's just a generic API; you can understand the types which implement that API before you understand what makes them alike
12:06:14 <qfr-> @quote learnHaskell
12:06:15 <lambdabot> learnHaskell says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
12:06:33 <katja> monochrom: i guess I have to rewrite all the programm
12:06:45 <katja> monochrom: am I right
12:07:11 * copumpkin has no patience for people whose idea of getting help is to insult the thing they want help with, in an effort to get people riled up to defend it
12:07:16 <tolkad> Other than the do-syntax syntatic sugar they are just a normal type class. there are a few rules all instances should follow but this is not directly enforced.
12:07:19 <comwarrior> Copumpkin, thanks.
12:07:31 * hackagebot hums 0.3.2 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.3.2 (BardurArantsson)
12:07:54 <tolkad> comwarrior: Can you tell us what the program is?
12:07:57 <monochrom> you can keep lett2num. you can modify num2bin - it does too much and you should delete some code, e.g., don't convert to string. you need a different blCo
12:09:06 <kmc> comwarrior, if you just want some randomness, you don't need to understand monads
12:09:12 <tolkad> Ugh, haskell is so stupid, the documentation doesn't even tell me when to use TArrays. It's probably because every single haskell user is a terrible person and is also very short in stature. Nobody in this channel is even going to be able to tell me when to use TArrays
12:09:19 <katja> monochrom: m. I cannot even imagine how to do it. 
12:09:22 <monochrom> If you have these two lists ['b','c'] and [ [1,0], [1,1] ] you can do this:
12:09:22 <kmc> you just need the IO type: http://www.haskell.org/haskellwiki/Introduction_to_IO
12:09:24 <copumpkin> tolkad: that is true :)
12:09:28 <j-invariant> shut up
12:09:34 <monochrom> > zip ['b','c'] [ [1,0], [1,1] ]
12:09:35 <kmc> it happens that IO is a monad, but that's neither necessary nor sufficient for understanding how to use IO
12:09:35 <lambdabot>   [('b',[1,0]),('c',[1,1])]
12:10:04 <monochrom> as for going from  [ [1,0], [1,1] ]  to [1,0,1,1] you already know what to do
12:10:22 <qfr-> > zip "bc" [ [1,0], [1,1] ]
12:10:24 <lambdabot>   [('b',[1,0]),('c',[1,1])]
12:10:29 <pastorn> tolkad: actually this is true...
12:10:32 <aristid> kmc: oh, random thought crossing my mind. does the new android 2.3 ndk help for the haskell stuff?
12:10:46 <pastorn> it's pretty annoying that the array documentation is where the typeclass is
12:10:59 <pastorn> especially considering things like running times :/
12:11:57 <kmc> aristid, i didn't try it
12:12:01 <kmc> i did send my code to iPwn though
12:12:16 <tolkad> comwarrior: Can you paste your code on hpaste so we can help you trim it down or tell us what you are trying to do?
12:12:39 <kmc> @seen RyanT5000
12:12:39 <j-invariant> tolkad: I asked him that before people distracted him
12:12:40 <preflex>  RyanT5000 was last seen on #haskell 93 days, 3 hours, 26 minutes and 31 seconds ago, saying: what is ghci's ":print" based on?
12:12:40 <lambdabot> Unknown command, try @list
12:12:45 <monochrom> paste your BASIC code too in case there is a better translation to haskell than yours
12:12:48 <katja> monochrom: so. I have to modify num2bin. that it doesnt convert to string 
12:12:57 <kmc> BASIC sucks because it doesn't have monads, lolololol
12:13:04 <monochrom> right. Int -> [Int].
12:13:06 <katja> monochrom: it is possible to modify so? | n>=0 = n `mod` 2 : (num2bin( n `div` 2))
12:13:16 <monochrom> BASIC is a big monad.
12:13:37 <tolkad> ooh, I wonder if haskell could have a goto monad
12:13:48 <aristid> tolkad: it's called Cont
12:14:00 <monochrom> just delete "concatMap show" and change the type signature.
12:14:03 <kmc> there was also a (more limited, more straightforward) goto monad i saw
12:14:38 <katja> monochrom: oh. yeah. ok. I got it
12:15:05 <pastorn> tolkad: getCC = callCC (\c -> let x = c x in return x)
12:15:09 <monochrom> the way to write a correct program is to do less, not more.
12:15:20 <pastorn> actually that is a "goback" function, but still :)
12:15:39 <katja> monochrom: sp, and now blCo with a zip funktion. yeah?
12:15:47 <monochrom> yes
12:16:43 <tolkad> pastorn: it would be great if we also had a unsafeGoto for pure code
12:16:51 <pastorn> tolkad: hahahaha
12:17:20 <pastorn> tolkad: why do you want these things? or are you trolling?
12:17:24 <monochrom> we have all longed for unsafeCallCC for years
12:17:30 <tolkad> pastorn: I was kidding :P
12:17:49 <aristid> tolkad: jokes about purity are NOT TOLERATED!
12:17:53 <pastorn> But you can du stuff like labels with mdo or something like that
12:18:03 <monochrom> http://hackage.haskell.org/package/vintage-basic is BASIC in a big monad.
12:18:38 <monochrom> there is good chance you can just turn your 28-line BASIC program into a 31-line haskell program by just using this.
12:19:09 <katja> monochrom: blCo xs = zip (xs (num2bin(lett2num xs))) it should be something like this yeah? dont tell the the right varian I want it to do myself
12:19:22 <monochrom> oh wait, vintage-basic is not the one I want
12:19:46 <comwarrior> Sorry it took so long; I had to type in the program by hand. http://hpaste.org/43008/blackjack_dealer_probabilities
12:19:55 <monochrom> yes, that will give you [('f',[1,0,0]),('o',[1,1,1,1])]
12:20:22 <comwarrior> Of course, a literal translation is not really what I want. This code is about as imperatively ugly as can be.
12:20:57 <burp> the horror.
12:20:59 <katja> monochrom: it gave me an error%))
12:21:39 <monochrom> oh oops, zip xs (num2bin(lett2num xs))
12:21:39 * hackagebot cmdlib 0.3 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3 (PetrRockai)
12:21:57 <j-invariant> comwarrior: you should use the BASIC monad http://hackage.haskell.org/package/BASIC
12:22:06 <monochrom> yeah, that's the package
12:22:16 <j-invariant> comwarrior: lets you pretty just write that same thing into haskell
12:23:02 <katja> monochrom: it gives me again an error. should I change blCo :: String -> String
12:23:31 <comwarrior> I'm not looking to wrap this stuff in a package and use it. I'd like to rewrite it in idiomatic Haskell. The code is ugly and hard to change.
12:24:22 <monochrom> type of [('f',[1,0,0]),('o',[1,1,1,1])] is [(Char, [Int])]. you're looking at blCo :: String -> [(Char, [Int])] at this stage.
12:24:23 <j-invariant> comwarrior: okay. I don't understand that code but if you have a simple description of the algorithm there is a simple implementation in haskell: We can help you write that for sure
12:25:14 <katja> monochrom: oh, you should not have told me the truth%)))
12:25:37 <monochrom> ghci can easily tell you the truth anyway. look for the :type command
12:25:56 <qfr-> :t
12:26:11 <katja> monochrom: it tells me that it hat an error again%))
12:26:12 <monochrom> there is also http://www.umsu.de/logik/trees/ for logical truth if you will take a logic course
12:26:22 <EvanR-work> > 2 + 2 == 4
12:26:23 <lambdabot>   True
12:26:29 <monochrom> ok I need to see the current version of code
12:26:32 <comwarrior> Ok. The dealer in blackjack shows a card. After the players act, he turns over his second card. If the total is less than 17, he takes additional cards. Aces count as either 1 or 11; 1 if 11 makes the dealer's total is greater than 21. What is the dealer probability distribution? 
12:26:33 <pastorn> EvanR-work: indeed
12:26:42 <djahandarie> > 2 2 + 2 == 4
12:26:44 <lambdabot>   True
12:26:51 <comwarrior> 10, J,Q,K all count as 10.
12:26:54 <djahandarie> > 2 2 + 2 542 == 4 7
12:26:55 <lambdabot>   True
12:26:59 <j-invariant> comwarrior: oh you just want to compute the probability?
12:27:07 <comwarrior> for now...
12:27:09 <j-invariant> comwarrior: by simulating every possible case
12:27:09 <j-invariant> ?
12:27:15 <comwarrior> no, by enumerating
12:27:20 <katja> monochrom: http://stackoverflow.com/questions/4682705/haskell-numbers-in-binary-numbers-words
12:27:30 <j-invariant> comwarrior: what's the difference?
12:27:51 <j-invariant> comwarrior: (I don't know blackjack btw)
12:27:58 <comwarrior> simulation implies inaccuracy. enumeration computes it exactly.
12:28:00 <TeachmeHaskell> hello folkz
12:28:05 <j-invariant> comwarrior: oh okay, sure
12:28:48 <j-invariant> comwarrior: is it tractable? I mean there are 52! different ways to shuffle a deck that could take forever.. maybe there's smoething clever to reduce the search space
12:28:56 <comwarrior> The dealer has 7 different possible outcomes: 17, 18,19,20,21, blackjack, and bust (over 21).
12:29:14 <comwarrior> We're just talking about probabilities of dealer totals.
12:29:44 <j-invariant> so   dealer = [Left 17, Left 18, Left 19, Left 20, Left 21, Right Blackjack, Right Bust]
12:29:49 <j-invariant> with data Foobar = Blackjack | Bust
12:30:13 <comwarrior> The deck isn't necessarily a single deck (it could be 2 or more), and in general it will be depleted of cards.
12:30:26 <j-invariant> comwarrior: oh wait, I guess the Blackjack and Bust have different probabilities than the numbers?
12:31:08 <pastorn> j-invariant: why are you wrapping Either around this?
12:31:18 <comwarrior> Not sure why you specify Left and Right... Also the ace is kind of weird. Some kind of monad again, like Maybe?
12:31:33 <j-invariant> comwarrior: ace?
12:31:41 <j-invariant> comwarrior: and what has monad to do with it?
12:31:43 <comwarrior> An Ace counts as either 1 or 11.
12:31:45 <j-invariant> I thought you didn't want to use monads
12:31:47 <monochrom> for each character in xs, you want to do num2bin (lett2num that_character).  So it is not (num2bin (lett2num xs)) overall.  It is (map (num2bin . lett2num) xs)
12:32:11 <comwarrior> I don't want to use them but I think it may be desirable / necessary.
12:32:31 <j-invariant> comwarrior: you can avoid them at first then rewrite the program with them and compare
12:32:43 <j-invariant> comwarrior: but that's a long term learning thing you can ignore it now
12:33:36 <comwarrior> The problem is definitely tractable. There are only about 4000 different hands that qualify.
12:33:40 <j-invariant> okay
12:34:19 <comwarrior> actually the number is 3082
12:34:42 <TeachmeHaskell> Comwarrior how do you know it?
12:34:57 <comwarrior> There's a book called Theory of Blackjack that says so.
12:35:06 <TeachmeHaskell> i see
12:35:09 <TeachmeHaskell> great!
12:36:18 <katja> monochrom: ok. but it it still not the right one. it should give me  [('a',[1]),('b',[1,0]),('c',[1,1]),[1,1,0,11]]
12:36:35 <katja> monochrom: now it gives me only  [('a',[1]),('b',[1,0]),('c',[1,1]),]
12:36:37 <comwarrior> So it should be possible to write a Haskell expression that enumerates every possibility, filters out the non-candidates, then (somehow) computes the probability of each total given a composition of cards from which the dealer draws.
12:36:55 <j-invariant> comwarrior: yeah that shouldn't be too hard
12:37:20 <j-invariant> comwarrior: you could use a list like [(probability,event),(probability,event),..] etc
12:38:15 <comwarrior> I would think you'd want to create a tree of possible hands, apply a function that takes that tree and the composition of cards, and get a result.
12:39:02 <j-invariant> comwarrior: I can't visualize the tree, what is it like?
12:39:02 <comwarrior> Some kind of zipper or something, I think.
12:39:08 <j-invariant> comwarrior: no clue about zippers
12:40:19 <comwarrior> [10 6 [A,2,3,4,5,6,7,8,9,T,J,Q,K]] for a dealer 10 6 and drawing all possible cards to that. 
12:40:45 <comwarrior> there may be some node description like the total
12:41:18 <j-invariant> comwarrior: should it be [[10],[6],[A,2,3,4,5,6,7,8,T,J,Q,K]] for three cards?
12:41:28 <j-invariant> comwarrior: meaning always a 10, always a 6, but any of A,2, etc
12:41:41 <katja> monochrom: so should be so blCo :: String -> [(Char, [Int]), [Int]]
12:41:50 <comwarrior> Yes, thank you. My syntax is abominable.
12:42:04 <j-invariant> just checking that I follow :)
12:42:48 <mm_freak> > map (.&. 1) . takeWhile (>0) . iterate (`shiftR` 1) $ 53
12:42:49 <lambdabot>   [1,0,1,0,1,1]
12:43:08 <monochrom> blCo :: String -> ([(Char, [Int])], [Int])
12:43:21 <comwarrior> Well, I'm not sure this is exactly right. But the idea is that you can enumerate all possibilities then start asking probability questions. 
12:43:22 <mm_freak> > replicateM 5 "01" !! 53
12:43:23 <lambdabot>   "*Exception: Prelude.(!!): index too large
12:43:33 <mm_freak> > replicateM 6 "01" !! 53
12:43:34 <lambdabot>   "110101"
12:43:59 <katja> monochrom: and I guess I have to rewrite something again yeah?
12:44:03 <j-invariant> > sequence [[Left 10],[Left 6],[Right "A",Left 2,Left 3,Left 4,Left 5,Left 6,Left 7,Left 8,Right "T",Right "J",Right "Q",Right "K2]]
12:44:04 <lambdabot>   <no location info>:
12:44:04 <lambdabot>      lexical error in string/character literal at end o...
12:44:06 <j-invariant> > sequence [[Left 10],[Left 6],[Right "A",Left 2,Left 3,Left 4,Left 5,Left 6,Left 7,Left 8,Right "T",Right "J",Right "Q",Right "K"]]
12:44:07 <lambdabot>   [[Left 10,Left 6,Right "A"],[Left 10,Left 6,Left 2],[Left 10,Left 6,Left 3]...
12:44:17 <monochrom> wrap something around zip xs (num2bin(lett2num xs))
12:44:20 <j-invariant> comwarrior: ^ the funciton "sequence" gives every possible three cards
12:44:24 <comwarrior> The simplest question is what are the probabilities of various totals given an upcard.
12:44:51 <j-invariant> comwarrior: so basically this thing about totals, it's a predicate which says True or False given three cards?
12:45:46 <j-invariant> comwarrior: then if list is every possible three cards the dealing could give, and p :: [Card,Card,Card] -> Bool is the predicate you can just do the obvious thing  length (filter p l)/length l  to get the probability
12:46:15 <comwarrior> Hmm, not sure what you mean. But the dealer could conceivably have quite a few cards. A,A,A,A,A,A,A,5,A,A,A,A,5 is I think the longest hand. 13 cards, if I'm not mistaken.
12:46:33 <j-invariant> comwarrior: so that sequence thing was wrong?
12:46:43 <katja> monochrom: wrap something?! 
12:47:01 <monochrom> blCo xs = .... zip xs (num2bin(lett2num xs)) ...
12:47:09 <comwarrior> I don't know "sequence". But like I said, the dealer could have 2 up to 13 cards in his hand.  
12:47:30 <monochrom> you have part of the right answer. you just need to combine it with something.
12:48:11 <Phyx-> :t fun
12:48:12 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
12:48:18 <Phyx-> heh, there goes my joke..
12:48:38 <comwarrior> You also might run out of a particular denomination of card. For example, if you only had 1 card of each denomination remaining, you couldn't have 2 aces in the hand.
12:49:03 <j-invariant> comwarrior: so you should have a card type that includes the suit then
12:49:33 <katja> monochrom: yeah I know whta wrap means. I meant like a funktion or those thing ()
12:49:48 <monochrom> some () and , are involved
12:50:04 <comwarrior> Suits aren't particularly relevant to this problem right now. But if carrying them around doesn't cause a problem I can think of situations where they do become relevant.
12:50:21 <j-invariant> comwarrior: oh I misunderstood, thought the suit was important
12:51:16 <comwarrior> So a simple example might be something like the following. The dealer shows a 10. What is the probability he beats a player19
12:51:23 <katja> monochrom: something like this blCo xs = (zip xs (map (num2bin . lett2num) xs), (map (num2bin . lett2num) xs))
12:51:30 <j-invariant> comwarrior: ah I see
12:51:30 <rkrzr> Hi, a little question about low-level haskell: how do you get the memory address of a CInt value?
12:51:49 <monochrom> almost. from [[1,0],[1,1]] to [1,0,1,1] you need concat
12:51:58 <j-invariant> comwarrior: so yeah you can have "shows a 10" encoded as a predicate on three cards.. and use it to filter the possibilities
12:52:09 <j-invariant> comwarrior: just generating all the possibilities remains to be done
12:52:24 <comwarrior> Right... "just".
12:53:23 <comwarrior> This list of possible hands is small enough and queried often enough that I think it would be good to keep it around. Maybe laziness would memoize it?
12:53:33 <j-invariant> comwarrior: is it difficult?
12:53:41 <katja> monochrom: blCo xs = (zip xs (map (num2bin . lett2num) xs), (map (++) (num2bin . lett2num) xs))
12:53:41 <j-invariant> comwarrior: yes it will
12:53:55 <comwarrior> For me, it is not easy. Hence, I am here.
12:54:12 <pastorn> katja: how's it going?
12:54:18 <j-invariant> comwarrior: what are all possibilities? Does the dealer start out with n full decks of cards?
12:54:19 <monochrom> no no, (zip xs (map (num2bin . lett2num) xs), concat (map (num2bin . lett2num) xs))
12:54:53 <comwarrior> You can start with any number of cards and you should get a valid answer. Even if you have no cards...
12:55:04 <katja> monochrom: can I write then something like blCo xs = (zip xs (map (num2bin . lett2num) xs), foldr (++) (map  (num2bin . lett2num) xs))
12:55:14 <j-invariant> doesn't make sense to me because i don't know this game
12:55:35 <monochrom> rkrzr: if you want an address, you should use the Ptr type and the Foreign.Marshal.Alloc modules to begin with, get a (Ptr CInt) from the beginning.
12:55:45 <comwarrior> But in general, yes, start with n decks of cards. Typical value of n are be 1,2,4,6,8. Then cards are dealt and probabilities change.
12:55:46 <katja> pastorn, it is cool thanks
12:55:54 <monochrom> foldr (++) = concat. I don't mind either way.
12:56:19 <monochrom> err, foldr (++) [] = concat
12:56:27 <pastorn> katja: you seem to have been stuck on the same problem for a while... have you looked at the function elemIndex?
12:56:47 <comwarrior> The game is of course more complicated than the dealer's hand. But seeing how a function that computes that would help me understand how to generalize it.
12:57:00 <pastorn> From what i gather from your conversation you want to convert a string to sequence of numbers representing their place in the alphabet, correct?
12:57:27 <monochrom> doesn't need elemIndex for that.
12:57:27 <j-invariant> comwarrior: so if deck is a list of cards,  replicate n deck  gives a n decks of cards
12:57:44 <j-invariant> comwarrior: where does the dealers hand come from?
12:58:23 <pastorn> monochrom: it could help :)
12:58:28 <pastorn> make the code simpler
12:58:44 <katja> pastorn, m. I have been learning haskell only one month and before I have never dealed with programming, so it it all a bit confusing for me. and I dont know what elemIndex is
12:58:52 <monochrom> ord is simpler
12:59:13 <comwarrior> The dealer draws cards from a "shoe", a box that contains n decks of cards. He repeatedly deals from this shoe until a cut card comes out. Then he shuffles and starts all over again.
12:59:17 <pastorn> ah, yes
12:59:46 <katja> monochrom, thank you very much indeed%)
12:59:49 <pastorn> > elemIndex 'c' "abc"
12:59:49 <lambdabot>   Just 2
12:59:50 <comwarrior> So as cards are removed from the shoe, the dealer probabilities change.
12:59:52 <aristid> elemIndex is a function
12:59:53 <aristid> :t elemIndex
12:59:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
12:59:54 <monochrom> elemIndex has this extra Maybe to deal with which is totally unnecessary.
12:59:56 <pastorn> > elemIndex 'c' "xyz"
12:59:57 <lambdabot>   Nothing
13:00:02 <pastorn> monochrom: true
13:00:08 <rkrzr> monochrom, I want the memory address of one particular CInt for a function call, I need it's value somewhere else
13:00:32 <katja> hah. ok. thanks%)
13:00:55 <monochrom> it wouldn't be as bad as I make it if people weren't so taboo about fromJust
13:01:17 <sproingie> @src fromJust
13:01:18 <lambdabot> fromJust Nothing  = undefined
13:01:18 <lambdabot> fromJust (Just x) = x
13:01:26 <comwarrior> Now an interesting fact is that the shuffle is not entirely random. So if you can characterize the cards coming out in some way, you may be able to predict changed probabilities even after a shuffle.
13:01:40 <sproingie> running into undefined at runtime is kinda icky
13:01:56 <monochrom> see? QED
13:01:58 <j-invariant> comwarrior: that's crazy!
13:01:59 <dolio> Clearly fromJust should return a Maybe.
13:02:07 <comwarrior> But this is really besides the point right now.
13:02:08 <copumpkin> lol
13:02:26 <rumbold1> hrm, any tips on how to find out why im getting <<loop>>? i think i reverted all the changes i made already, but i stil get it :|
13:03:52 <comwarrior> I guess one question is how to represent an Ace, since it can be either 1 or 11.
13:04:36 <jmcarthur> represent is as Ace
13:04:39 <jmcarthur> *it as
13:05:28 <katja> thanks you all. have a nice night
13:05:30 <katja> bye bye
13:05:56 <monochrom> 10pm in germany
13:06:49 <comwarrior> So how can I generate all 3082 possible hands that total to 21 or less, using [1..10]?
13:07:24 <monochrom> I should write some trolling article about "sometimes multiplication 'may' overflow so (*) should have type a->a->Maybe a" on reddit.
13:08:01 <Botje> it should be a -> a -> (a, Bool), obviously.
13:08:16 <j-invariant> > filter ((<= 21) . sum) (sequence (replicate 21 [1..10]))
13:08:20 <lambdabot>   mueval-core: Time limit exceeded
13:08:25 <Botje> with a writer monad to thread that Bool .. that's the cpu's job!
13:08:50 <monochrom> we should collaborate!
13:09:15 <comwarrior> well, you can't have more than 2 10's in a hand that totals 21 or less.
13:09:17 <Botje> :)
13:10:26 <elliott> How does one catch errors thrown by `error`?
13:10:31 <comwarrior> It seems a naive expression runs too slowly?
13:10:43 <pastorn> elliott: teaspoon package ;)
13:10:44 <kmc> elliott, that's an indication you shouldn't be using "error"
13:10:48 <monochrom> use some Control.Exception thingies
13:10:55 <kmc> but if you absolutely have to catch errors in other people's code
13:11:00 <j-invariant> :t catchIO
13:11:02 <lambdabot> Not in scope: `catchIO'
13:11:04 <kmc> you can use Control.Exception
13:11:04 <j-invariant> :t catchError
13:11:05 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
13:11:16 <kmc> just be aware you have to force evaluation within the scope of the "try" part
13:11:24 <monochrom> but yeah, not so much catching as aborting and cleaning up, i.e., bracket and finally
13:11:28 <kmc> see also "spoon" package
13:11:48 <elliott> right. in this case it's just "read"; I should probably use reads myself, but ...
13:11:54 <pastorn> copumpkin: wasn't it you who wrote the teaspoon package?
13:12:28 <aristid> :t concat .: intersperse
13:12:30 <revenantphx> This is what happens when I try to write python now >_<
13:12:30 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:12:30 <revenantphx> https://gist.github.com/778616
13:12:38 <revenantphx> Excuse me sir, could I have more pure functions?
13:12:56 <copumpkin> pastorn: it's called spoon, and I did it with mmorrow
13:12:57 <copumpkin> but yeah
13:13:06 <revenantphx> tbh since I just made Cell's able to introspect their own indices, I can remove a lot of those now.
13:13:10 <revenantphx> But it's pretty indicative.
13:13:13 <revenantphx> (damn you haskell)
13:14:04 <monochrom> I know how to solve your problem. Erase python.
13:14:14 <revenantphx> actually I can't... since they also depend on the world variable.
13:14:20 <revenantphx> monochrom: :P
13:14:32 <pastorn> copumpkin: wasn't there a teaspoon as well?
13:14:39 <tac-tics> Are there any particularly USEFUL examples of mutually recursive functions?
13:14:43 <copumpkin> pastorn: it's in the same package, yep
13:14:49 <copumpkin> tac-tics: loads
13:15:03 <j-invariant> copumpkin: examples
13:15:04 <revenantphx> wait...
13:15:05 <copumpkin> tac-tics: any time you want to simulate a state machine, mutual recursion is a pretty clean way to do it
13:15:14 <revenantphx> how the hell do those methods up there know about the world variable D:
13:15:15 <monochrom> I am wary of all-caps "useful"
13:15:19 <revenantphx> some of them I forgot to pass it as a parameter.
13:15:21 <revenantphx> What is this.
13:15:55 <tac-tics> copumpkin: what about in a language with state?
13:16:06 <copumpkin> tac-tics: same thing, really
13:16:08 <monochrom> A parser is a bunch of mutually recursive functions.
13:16:40 <copumpkin> tac-tics: sometimes you'll encode what state machine state you're in, in a mutable variable
13:16:41 <tac-tics> monochrom: yeah, they are useful for that, aren't they
13:16:44 <copumpkin> why not just encode it in the underlying machine
13:16:51 <copumpkin> ('s instruction pointer)
13:17:00 <copumpkin> less indirection, cleaner code
13:17:09 <monochrom> A server written in haskell is also a bunch of mutually recursive, well it's IO, so I'll call them actions.
13:17:37 <monochrom> At least a few toy servers I've written.
13:17:39 <revenantphx> I can't write python with methods anymore TT_TT
13:17:54 <lowasser1> How can I do a memcpy from a MutableByteArray to a Ptr?
13:17:54 <revenantphx> It always ends up being POD objects + a lot of functions (usually pure)
13:17:56 <comwarrior> j-invariant: if you replicate [1..10] 21 times and ask for a total of 21 or less, there's only one answer: 21 1's.
13:18:09 <lowasser1> (I figure it'll almost certainly involve a foreign import, but I'm not sure beyond that)
13:18:27 <j-invariant> comwarrior: damn you're right 
13:18:30 <monochrom> But in general all questions of the form "is xxx useful" are a case of "if you have to ask, you are not ready to know".
13:18:31 <pastorn> lowasser1: check out Data.ByteString.Internal
13:18:34 <j-invariant> comwarrior: so that needs fixed
13:18:38 <pastorn> lowasser1: quite a lot of goodies there
13:18:57 <lowasser1> yeah, already there, but it only uses Ptrs, no ByteArrays
13:19:10 <lowasser1> and the key issue is to get from one to the other
13:19:20 <monochrom> I bet you many c++ programmers don't find the full extent of all c++ useful. Each only finds a fragment useful. Just work with that fragment then.
13:19:21 <tac-tics> monochrom: that's debateable
13:19:27 <pastorn> lowasser1: what's a ByteArray?
13:19:37 <lowasser1> heh, this is why it's a question for advanced users
13:19:46 <pastorn> sounds an aweful lot like a ByteString
13:19:52 <tac-tics> Usefulness can also be characterized by accessability
13:19:55 <lowasser1> not exactly
13:20:03 <monochrom> I don't understand that sentence.
13:20:05 <lowasser1> ByteArrays are a GHC-internal alternative to pointers
13:20:16 <pastorn> oh, cool
13:20:19 <lowasser1> and pointery things
13:20:19 <pastorn> never heard of
13:20:25 <pastorn> which modules?
13:20:27 <lowasser1> they're behind Data.Array.Unboxed, for instance
13:20:34 <monochrom> But sounds like a cool sentence to put on some company's home page.
13:20:42 <lowasser1> but to really do anything with them you're pretty much importing GHC.Prim, which means you're doing Serious Business
13:21:02 <pastorn> lowasser1: heh, why are you messing with this stuff?
13:21:06 <lowasser1> my end goal is conversion between Data.Vector.Primitive.Vector (from the vector package) and ByteString
13:21:26 <tac-tics> But parsers are a sufficiently useful example for my needs
13:21:29 <comwarrior> You could write something like [(x,y) | x<-[1..10],y<-[1..10],x+y<21] and [(x,y,z) | x<-[1..10],y<-[1..10],z<-[1..10],x+yz<21], continuing up to 21 variables but this hardly seems elegant.
13:21:33 <napping> lowasser1: looks like you would need to read and write individually, unless you have them pinned
13:22:04 <lowasser1> that's what I'd think, too, but Data.Array.Base seems to import a C memcpy and use it without any problems on ByteArrays
13:22:34 <lowasser1> (in Data.Array.Base, look at the source for thawSTUArray)
13:22:53 <comwarrior> Small typos: [(x,y) | x<-[1..10],y<-[1..10],x+y<=21] and [(x,y,z) | x<-[1..10],y<-[1..10],z<-[1..10],x+y+z<=21]
13:22:55 <napping> as an unsafe call?
13:23:02 <lowasser1> yeah
13:23:12 <lowasser1> I'd settle for that!
13:23:24 <napping> That should be enough to prevent a GC
13:23:39 <napping> where is the MutableBytaArray# coming from?
13:23:55 * hackagebot language-javascript 0.3.0 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.3.0 (AlanZimmerman)
13:23:56 <lowasser1> although I'm trying to do essentially the same foreign import, and it's complaining that a MutableByteArray# s isn't a valid argument in a foreign imported function, and I don't know how Data.Array.Base gets away with it
13:24:23 <napping> it's not using byteArrayContents#?
13:24:43 <lowasser1> directly copied from the source of Data.Array.Base:
13:24:46 <lowasser1> foreign import ccall unsafe "memcpy"     memcpy_thaw :: MutableByteArray# s -> ByteArray# -> CSize            -> IO (Ptr a)
13:25:42 <comwarrior> Drawing order can matter when there is an ace. For example, 5 A 10 4 is a valid ordering. But 5 10 4 A (among others) is not.
13:25:45 <lowasser1> and I copy that line into my module, and it complains " Unacceptable argument type in foreign declaration: MutableByteArray# s", and I dunno enough about the FFI to fix it
13:25:57 <pastorn> lowasser1: what's your end goal here? This seems cool 'n' all, but kinda messy
13:26:12 <lowasser1> like I said, conversion from Data.Vector.Primitive.Vector to and from ByteString
13:26:23 <lowasser1> two very lovely, well-written, usable interfaces
13:26:41 <lowasser1> but I'd like to be able to convert between them with a memcpy
13:26:51 <napping> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/ffi.html#id3231340
13:26:54 <lowasser1> rather than a one-at-a-time loop
13:27:17 <lowasser1> yeah, but then why's it complaining about the MutableByteArray#?
13:27:31 <napping> did you forget MagicHash?
13:28:02 <lowasser1> nope
13:28:23 <comwarrior> Now the answer really doesn't have to be exact. 1.5 significant figures is probably enough. 3 is overkill. So truncating the computation is a valid action, as long as you can put bounds on the error.
13:28:31 <lowasser1> oooh
13:28:40 <lowasser1> -XUnliftedFFITypes
13:29:06 <lowasser1> I win!
13:29:16 <dpratt71> hmm...is hpaste having problems or is it me?
13:29:40 <pastorn> dpratt71: http://codepad.org
13:29:48 <lowasser1> that was it
13:29:50 <dpratt71> pastorn: thanks
13:29:51 <JoeyA> It is, it seems.
13:30:26 <pastorn> lowasser1: and codepad also runs your code unless you're using weird imports (anything more complicated than Data.List that is)
13:30:50 <dpratt71> ezyang: you still around, perchance?
13:31:16 <napping> how is Vector defined?
13:31:17 <comwarrior> One idea is to evaluate the most probable hands first and quit when you've gotten close enough. I believe 7 cards is enough to get you to 4 significant figures, if you aggregate all 8 or more card totals. 
13:31:37 <comwarrior> At least, that's what Epstein's Theory of Gambling and Statistical Logic claims.
13:31:53 <copumpkin> napping: from the vector package?
13:31:58 * hackagebot hjsmin 0.0.9 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.9 (AlanZimmerman)
13:32:04 <copumpkin> napping: it's a data family
13:32:14 <lowasser1> copumpkin: not exactly true ;)
13:32:25 <lowasser1> the vector package has several different definitions of Vector
13:32:28 <copumpkin> well, yeah
13:32:30 <napping> specifically, does it actually use unpinned MutableByteArray#?
13:32:42 <copumpkin> napping: depends on which vector
13:32:43 <lowasser1> Data.Vector.Primitive.Mutable does
13:32:55 <napping> oh, I guess you probably do have to copy then
13:32:58 <copumpkin> there's a boxed vector
13:33:11 <lowasser1> and that's the one I'm interested in
13:33:14 <comwarrior> This 7-card limit applies to computations on a single deck off the top. 
13:33:23 <copumpkin> what are you interested in?
13:33:25 <lowasser1> (also Data.Vector.Primitive, but it doesn't let you take that apart)
13:33:35 <lowasser1> I think napping was still thinking about my problem
13:34:04 <dpratt71> well if anyone's willing to critique my latest version of a bowling score calculator, please do: http://codepad.org/zGFJPlO7
13:35:02 <copumpkin> lowasser1: the Storable one would be a lot easier to convert to a ByteString :)
13:35:25 <lowasser1> hmmmm
13:35:31 <napping> you could probably get away with making a ForeignPtr to a pinned byte array as well
13:35:46 <lowasser1> ...I was going to say that I needed the Primitive version for other reasons, but in retrospect I'm not so sure
13:35:48 <lowasser1> let me do that then ;)
13:36:39 <pastorn> dpratt71: you don't need the _ cases for next*
13:36:50 <pastorn> actually you should get a compiler warning for that :)
13:36:55 <napping> you would need to be careful to avoid garbage collection
13:37:17 <dpratt71> pastorn: you sure?
13:37:28 <pastorn> dpratt71: try compiling with -Wall
13:37:29 <napping> manufacturing a Ptr from the Addr#, and then putting it in a ForeginPtr to make GHC guess it's off the heap anyway is not good for that
13:37:58 <pastorn> how do you turn on -Wall from inside the source file?
13:38:00 <dpratt71> pastorn: no warnings, errors
13:38:21 <djahandarie> edwardk1, aw man, the 20th :(
13:38:34 <dpratt71> next* _ covers the case of an empty list, I think; perhaps I should make that more explicit
13:38:45 <monochrom> {-# OPTIONS_GHC -Wall #-}
13:39:21 <djahandarie> I have a 9am class on the 21st :(
13:41:04 <pastorn> dpratt71: oh, right, it does
13:41:28 <dpratt71> is there a convention? i.e. what is preferred "head _ = error..." or "head [] = error..."
13:41:52 <Botje> second is more descriptive
13:42:53 <katja>  monochrom: I have one small question more
13:43:25 <dpratt71> funny that (for me) namings things is often an obstacle to writing or refactoring code
13:44:08 <dpratt71> /s/namings/naming
13:44:36 <rexantony> what is the language that is more near to haskell ?
13:44:51 <rexantony> near like syntax
13:44:55 <kmc> who cares about syntax
13:45:02 <kmc> Agda's syntax is like Haskell's but better :)
13:45:15 <rexantony> ada ?
13:45:17 <kmc> nope
13:45:18 <kmc> agda
13:45:26 <copumpkin> you lose sections though :(
13:45:31 <dpratt71> for example, I have "score' nfx fms
13:45:31 <dpratt71> " in three places; I'd combine them, but I don't know what I would call it
13:45:33 <kmc> asking which languages are conceptually like Haskell is a more interesting question
13:45:39 <copumpkin> I can't even begin to imagine what parsing sections in agda would be like
13:45:55 <dolio> They've talked about sections with the syntax redesign that still hasn't been done.
13:46:17 <copumpkin> oh?
13:46:21 <copumpkin> hadn't even heard of that
13:46:22 <kmc> can't you take each n-ary operator and introduce (n-k)-ary operators with some special "hole" character for k of the blanks
13:46:34 <kmc> it seems quite mechanical, though it results in an exponential blowup in the number of operators ;P
13:46:46 <copumpkin> yeah, and why just one hole?
13:46:52 <kmc> i meant for every k
13:46:54 <copumpkin> (,,,True,,1,(),,,)
13:46:57 <copumpkin> oh
13:46:58 <kmc> right
13:47:04 <copumpkin> so that's just all subsets
13:47:12 <kmc> yes
13:47:15 <j-invariant> thjeproblem with a hole character is ou don't know it's scope
13:47:19 <kmc> probably doing this naively for (,,,,,,,,,) is not feasible
13:47:32 <kmc> scope?
13:47:36 <j-invariant> is (@,3) the (id,3) or \x->(x,3)
13:47:59 <kmc> j-invariant, the hole is part of the name of the operator
13:48:10 <kmc> like in agda you can define an operator named if_then_else_
13:48:18 <kmc> and use it like "if 3 then 4 else 5"
13:48:32 <kmc> and i'm proposing that "if_then 4 else 5" should be sugar for "\x -> if x then 4 else 5"
13:48:42 <katja> pastorn: monochrom is not there maybe you could help. just a bit. one thing
13:48:45 <kmc> since the _ is part of the name if_then, you don't have a scope issue
13:48:54 <j-invariant> kmc: oh that doesn't seem problematic
13:49:04 <aavogt> kmc: as done in Scala?
13:49:10 <kmc> is that how it's done in Scala?
13:49:13 <kmc> clojure deals with it another way
13:49:27 <comwarrior> > So I want to write isValidDealerHand::[a]->Bool, which takes a list of cards and returns a Bool stating whether it's an allowable sequence according to the dealer's drawing rules: Once the dealer gets 17 or more he stops. Aces count as 11, unless they make the dealer go over 21, in which they are 1.
13:49:28 <kmc> which is that functions using the anonymous hole still have a lambda-ish form
13:49:28 <lambdabot>   <no location info>: parse error on input `,'
13:49:30 <kmc> #(+ % 2)
13:49:35 <dolio> The function form of operators in Agda look like _+_
13:49:49 <comwarrior> So a hand like A 8 A is invalid. But A A 8 is ok.
13:49:56 <copumpkin> not like scala
13:50:08 <dolio> So removing one of the underscores and putting a value there doesn't seem too wacky.
13:50:10 <copumpkin> in scala _ gives you an implciit lambda
13:50:17 <dolio> _+ e
13:50:19 <dolio> e +_
13:51:14 <dolio> copumpkin: Read notes/fixity-declarations
13:51:56 <dolio> Talks about partial ordering of operators and sections.
13:52:02 <katja> those people who helped me are not there. could any one help me`. it will take abiour 5 min only
13:53:33 <pastorn> katja: sure, gimme paste + problem/error
13:54:19 <katja> pastorn: so I modiefied my code again and now I have like this http://stackoverflow.com/questions/4682705/haskell-numbers-in-binary-numbers-words
13:54:47 <pastorn> katja: you should really use a real paste site instead of stackoverflow
13:55:02 <pastorn> katja: http://codepad.org is pretty good :)
13:55:24 <katja> pastorn: oh
13:55:28 <katja> ok
13:55:29 <katja> I will
13:55:38 <katja> sorry
13:56:10 <ski> @where paste
13:56:10 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
13:56:12 <pastorn> katja: stackoverflow (at least to me) seems like the place where you put one-of questions, not a place for continuous modified code
13:56:59 <katja> pastorn: yeah. sorry. I just didnt know who to show you my code in another way%)
13:57:23 <pastorn> katja: hehe, well now you do ;)
13:57:41 <katja> pastorn: http://codepad.org/LTobw9SR so that is my code for now
13:58:05 <katja> pastorn: instead of blockCode :: String -> (String,[(Char, [Int])]) i need blockCode :: String -> (String,[(Char, [String])])
13:58:32 <ski> > unfoldr (\n -> if n == 0 Nothing else Just (n `divMod` 2)) 13
13:58:34 <lambdabot>   <no location info>: parse error on input `else'
13:58:40 <ski> > unfoldr (\n -> if n == 0 then Nothing else Just (n `divMod` 2)) 13
13:58:41 <lambdabot>   [6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:58:51 <ski> hm .. oh, right
13:59:06 <ski> > unfoldr (\n -> if n == 0 then Nothing else Just ((snd &&& fst) (n `divMod` 2))) 13
13:59:08 <lambdabot>   [1,0,1,1]
13:59:18 <pastorn> katja: and the return values would represent what? can you show a simple example of input/output?
14:02:09 <katja> pastorn: input blockCode "abc"   output  ("11011",[('a','1'),('b','10'),('c','11')])
14:02:31 <katja> pastorn: but i have now output ("11011",[('a',[1]),('b',[1,0]),('c',[1,1])])
14:03:08 <pastorn> katja: look at the first thing you just wrote, '10' is not a valid Char
14:03:13 <pastorn> did you mean "10"?
14:03:35 <katja> pastorn: yep. sorry
14:03:43 <pastorn> no sweat :)
14:03:43 * ski wonders whether katja wants to use `isUpper' and `isLower'
14:04:05 <pastorn> ski: nah, the functions work as they are now, so let's keep it like it is
14:04:15 <pastorn> katja: how long did you say you've been tinkering with haskell?
14:04:58 <katja> pastorn: I started at the end of november
14:05:06 <ski> katja : in any case, you can remove the `ord's in the guards there.. you can compare characters directly with `<='
14:05:33 <ski> > 'A' <= 'B'
14:05:34 <lambdabot>   True
14:05:36 <ski> > 'C' <= 'B'
14:05:37 <lambdabot>   False
14:06:30 <ski> (also, none of the brackets in `lett2num' are needed)
14:07:19 <qfr-> What was the general sentiment regarding Learn You A Haskell vs. Real World Haskell for people who are new to pure FP again?
14:07:23 <katja> ski: ok
14:07:36 <qfr-> I think some said RWH was too hard on beginners or something
14:07:54 <kmc> i encourage everyone to look at both and pick which you prefer
14:07:59 <qfr-> Although I'm not sure why
14:08:01 <pastorn> qfr-: yes, real world haskell is more directed at people who can program but can't do functional programming
14:08:10 <ski> (katja : of course, if you prefer the brackets there, or if you're still unsure of when they're needed, you can keep them .. i'm just pointing it out)
14:08:19 <kmc> i also think "pure FP" is only a small part of the new things you have to learn for Haskell
14:08:26 <kmc> Haskell is far from a typical functional language
14:08:31 <qfr-> Right
14:09:26 <katja> ski: no, no, it is ok%))))
14:09:28 <katja> ski: thanks
14:10:18 <pastorn>  katja blockCode xs = ( concatMap show (concat (map (num2bin . lett2num) xs))
14:10:19 <pastorn>                , zip xs (map (map intToDigit . num2bin . lett2num) xs))
14:10:27 <pastorn> intToDigit is from Data.Char
14:10:45 <ski> @type intToDigit
14:10:46 <lambdabot> Int -> Char
14:10:59 <ski> > map intToDigit [2,3,5,7]
14:11:00 <lambdabot>   "2357"
14:12:28 <ski> instead of writing  n `mod` 2  and  n `div` 2  i want to write in a `where'-clause  (q,r) = n `divMod` 2  and then use `r' and `q' in place of the earlier two
14:12:32 <katja> pastorn: is there another way to do it? I mean not using intToDigit but something simplier
14:12:49 <pastorn>  katja ehm... that's as simple as it gets
14:13:28 <katja> pastorn: gem.. ok%))
14:13:37 <pastorn> i don't get what you do with the first elements of each list
14:13:52 <pastorn> it only seems to return exactly the same as the input list
14:13:53 <ski> katja : a variation of your `num2bin' is to add to the list in an accumulator parameter of `n2b' .. that way you don't need the `reverse'
14:15:27 <katja> pastorn;yeah. you are right. it is such a task. dont aks me why
14:15:34 <ski> katja : btw, `concat (map f xs)' can be simpler written as `concatMap f xs'
14:16:01 <ski> though, hm
14:16:16 <katja> ski: you are funny-)
14:16:29 <ski> maybe it's better to factor the `map (num2bin. lett2num) xs' out from the two occurances, into a `where'-clause
14:16:40 <ski> katja : heh, why you say that ?
14:17:47 <katja> ski: I also like to tell people the easiest ways to solve the problem
14:18:09 <katja> ski: i nned a bit time to correct all your remarks. dont be in a hurry
14:18:40 <ski> (in case it wasn't clear, the `f' was in your code `num2bin . lett2num')
14:18:57 <ski> katja : note that the last two remarks where mutually exclusive :)
14:19:07 <ski> s/where/were/
14:22:40 <pastorn> katja: http://codepad.org/c3XC7NIT
14:23:12 <pastorn> katja: blockCode' is maybe a bit more readable ;)
14:24:00 <katja> pastorn: yeah. it sound like a joke for me
14:24:00 * ski would write `concat (...)' instead of `concat $ ...' :)
14:24:08 <c_wraith> I'd use concatMap, myself
14:24:19 <ski> yeah .. or that
14:24:21 <mm_freak> i'd most likely use (>>=)
14:24:32 <pastorn> oh shit... circular dependency
14:24:47 <pastorn> katja: on line 26, change "xs" to "str"
14:24:57 * ski generally only uses `$' in a few circumstances
14:25:01 <katja> ski: where are you from?
14:25:56 <tolkad> When is it good practice to use mutable data structures?
14:26:00 <mm_freak> it doesn't matter, since with "$" we generally mean a haskell operator, not a currency
14:26:10 <mm_freak> but f € x would be funny, too
14:26:16 <pastorn> tolkad: threading, callbacks etc.
14:26:18 <mm_freak> haskell increases your income
14:26:28 <pastorn> tolkad: when you can't get away with not using it :)
14:26:35 <mm_freak> tolkad: also sometimes in performance
14:27:10 <katja> pastorn: yeah. thank you. I will look at it more profoundly in the weekends. I have to give my work in some hours and I still have to write a decoding code%))
14:27:27 <tolkad> So, what if I really have no reason to hold on to an old copy of a data structure, is it appropriate to make it mutable?
14:27:28 <mm_freak> katja: decoding what?
14:27:29 <Tomsik> As to $s, latex is better, I mean... $$
14:27:31 <ski> (katja : i've been a regular of this channel since the early times .. i'm not really coming here recently from some other community)
14:28:24 <mm_freak> tolkad: not always, because in most cases the GC will take care of it early
14:28:27 <katja> ski: I mean the country. or the city
14:28:45 <katja> mm_freak: binary numbers into words
14:28:48 <pastorn> tolkad: you might, if you need the performance gains
14:29:07 <tolkad> btw, there's some broken links here: http://www.haskell.org/haskellwiki/Software_transactional_memory
14:29:15 <tolkad> "Documentation for the Control.Concurrent.STM module in GHC"
14:29:18 <tolkad> http://www.haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
14:29:20 <mm_freak> tolkad: note that creating a modified copy of e.g. a Map won't take twice as much memory as before
14:29:37 <tolkad> mm_freak: I know
14:29:37 <mm_freak> on the other hand creating a modified copy of an array will
14:29:58 <mm_freak> katja: "words"?
14:30:22 <katja> mm_freak:digit
14:30:34 <ezyang> hm. I don't know where the real link is. 
14:30:53 <mm_freak> katja: turn 101 into "one oh one"?  i guess not
14:30:57 <ezyang> I guess you could always link to http://hackage.haskell.org/package/stm 
14:31:15 <mm_freak> would be too easy
14:31:37 <mm_freak> haskell solves only real problems…  it fails at simple things =P
14:31:42 <katja> mm_freak: hhah
14:32:18 <edwardk1> http://hpaste.org/43010/y_combinator
14:32:22 <edwardk1> oops
14:32:48 <tolkad> ezyang: it stops appearing in the ghc documentation at 6.12
14:33:21 <mm_freak> katja: example of such a conversion?
14:33:26 <ski> katja : `/whois ski' gives the domain ..
14:34:06 <mm_freak> what if it's an .info or .museum domain?
14:34:10 <katja> mm_freak: sorry?
14:34:18 <monochrom> eh? hpaste is back? :)
14:34:28 <katja> ski: oh. cool
14:34:30 <mm_freak> katja: binary → words
14:34:39 <tolkad> edwardk1: You can write the fixed point combinator in ghc haskell using unsafeCoerce
14:34:54 <monochrom> hahaha
14:35:02 <tolkad> seriously I did it and it worked
14:35:24 <katja> mm_freak: you are funny too
14:36:15 <monochrom> stm got splitted out from ghc 6.12
14:36:28 <pastorn> monochrom: do you know why?
14:36:36 <mm_freak> monochrom: was it part of GHC?
14:36:43 <mm_freak> i have 6.12 and had to install it explicitly
14:36:44 <monochrom> was.
14:36:47 <jmcarthur> the primitives still are, i'm sure
14:36:54 <jmcarthur> but the library component is separated
14:36:58 <ski> mm_freak : in the latter case, i suppose i live in a museum ?
14:37:06 <pastorn> mm_freak: yes, in 6.8 it was a part of GHC
14:37:29 <monochrom> downsizing
14:37:43 <mm_freak> ski: ;)
14:37:51 <mm_freak> pastorn: ah, ok
14:37:59 <mm_freak> GHC 6.6 was the one i started with
14:38:35 <mm_freak> but i was solving project euler problems back then…  my serious work with haskell started with approx. 6.10
14:39:44 <tolkad> my ghc is still broken : (
14:40:00 <digitteknohippie> nightmare. i feel for ya tolkad
14:40:07 <monochrom> does your ghci segfault? we now know why
14:40:16 <mm_freak> btw, does anyone work with some other compiler seriously?
14:40:20 <tolkad> monochrom: no, ghc fails with a linker error
14:40:29 <tolkad> mm_freak: there's that parallel one
14:40:45 <tolkad> mm_freak: GPH
14:40:51 <mm_freak> tolkad: it's quite outdated though
14:41:14 <mm_freak> and i mean something based not/less on GHC
14:42:45 <tolkad> There's no real reason to. They wouldn't be able to catch up with GHC and if they want to do better they'd probably be writing a new language
14:43:59 <c_wraith> jhc is actively developed.
14:44:01 <mm_freak> well, i think haskell makes the best tradeoff between language high-levelness and performance of code
14:44:12 <kmc> other compilers are used actively but for niche things
14:44:37 <kmc> UHC is supposed to have clean code, hackable modular design, and is more of a platform for experiments
14:44:39 <mm_freak> with "performance" including coding time and usefulness
14:45:11 <kmc> JHC produces very portable self-contained code which is also tiny, and has a variety of interesting internal design decisions
14:45:28 <tolkad> I guess I was wrong then
14:45:32 <kmc> Hugs is (in theory) a completely portable interpreter, which makes it easy to get *some* kind of Haskell system running on any platform
14:46:15 <kmc> YHC compiles to portable bytecode, which has been useful for a variety of interesting side projects
14:46:39 <mm_freak> i even prefer haskell over agda, coq and the other "insanely high level" languages
14:46:48 <kmc> anyway UHC, JHC, and Hugs all have interesting language extensions which aren't in GHC
14:47:14 <kmc> interesting and useful -- each of them would solve a particular GHC pain point
14:47:23 <opqdonut>  /wii ski
14:47:29 <mm_freak> yeah, i found hugs' extensible record types very interesting to read about…  i really miss a good record system in haskell
14:47:33 <opqdonut> now that was embarassing
14:47:39 <napping> what do UHC and JHC have?
14:47:51 <mm_freak> kmc: which one would UHC and JHC solve?
14:47:54 <jmcarthur> my favorite in uhc is kind polymorphism
14:48:25 <opqdonut> I'm kinda bothered that I couldn't write the code I write without bangpatterns, unboxing and mptcs
14:48:25 <mm_freak> jmcarthur: i wouldn't know where to use that
14:48:32 <opqdonut> oh and the various instance extensions
14:48:41 <kmc> UHC has first-class existentials
14:48:45 <kmc> JHC has top-level IO actions
14:49:04 <jmcarthur> i'm not sure i like top-level IO actions
14:49:05 <mm_freak> opqdonut: my code never uses those extensions
14:49:19 <kmc> i'm not sure i like them either, but i'm sure i like toplevel unsafePerformIO . newIORef even less
14:49:22 <jmcarthur> seems to imply that simply importing a module into main may cause IO
14:49:23 <opqdonut> mm_freak: heh
14:49:31 <opqdonut> mm_freak: I seem to mostly be implementing data structures
14:49:33 <kmc> jmcarthur, JHC's treatment is more refined than that
14:49:41 <jmcarthur> well that's good
14:49:42 <napping> I guess that's nice, but nothing like TREX then.
14:49:51 <mm_freak> opqdonut: the ones you mentioned explicitly that is…  i use FlexibleInstances, FlexibleContexts and TypeFamilies fairly often
14:49:54 <kmc> it leaves it unspecified whether top-level IO actions happen on import or lazily; and it forces you to use a modified IO monad which makes sure you can't care which
14:49:59 <kmc> the ACIO monad (affine central IO)
14:50:00 <mm_freak> and RankNTypes, of course
14:50:16 <kmc> and then there's a sound way to embed IO into ACIO
14:50:19 <opqdonut> mm_freak: okay. I almost never use those
14:50:20 <mm_freak> kmc: top level IO actions sound very useful, but what are first class existentials?
14:50:31 <jmcarthur> [exists a . Show a => a] ?
14:50:34 <opqdonut> mm_freak: i've used gadts now and then (especially when they were new)
14:50:36 <kmc> x :: exists a. (Num a) => a; x = (3 :: Int)
14:50:42 <mm_freak> opqdonut: maybe you should try…  at least type families will get rid of quite some MPTCs
14:50:45 <kmc> though UHC doesn't support class constraints on them yet
14:50:46 <opqdonut> but I haven't done anything real with type families
14:50:55 <opqdonut> yeah I can see
14:50:59 <kmc> but it means you don't need to define the wrapper type
14:51:38 <mm_freak> kmc: very interesting
14:51:56 <rexantony> haskell servlet exist ?
14:52:14 <kmc> you can kind of fake it in GHC
14:52:14 <mm_freak> rexantony: what's that?
14:52:28 <mm_freak> kmc: unsafeCoerce? =)
14:52:30 <kmc> data Exists f where { Witness :: f a -> Exists f }
14:52:32 <kmc> that too ;P
14:53:02 <rexantony> mm_freak: like java servlet
14:53:08 <mm_freak> hehe…  i see my mention of unsafeCoerce makes you jump =P
14:53:12 <kmc> yep ;P
14:53:20 <kmc> rexantony, learning Haskell by analogy to Java is not likely to produce good results
14:53:25 <napping> kmc: is that ACIO documented?
14:53:27 <mm_freak> rexantony: there are many web libraries for haskell
14:53:31 <kmc> napping, barely.  i found docs somewhere eventually
14:53:32 <ski> (jmcarthur : s/exists a . Show a => a/exists a. Show a *> a' :)
14:53:46 <kmc> if you google JHC ACIO you may find it
14:54:01 <kmc> i'm not sure if it's fully implemented but there's some code in the jhc repo anyway
14:54:10 <mm_freak> rexantony: but as kmc mentioned, don't compare them to java servlets (they are different (and better))
14:54:37 <kmc> i'd like not to start a fight about which is better
14:54:44 <copumpkin> HASKELL IS BETTER
14:54:48 <copumpkin> ALWAYS
14:54:58 <mm_freak> there is an ACIO library, which works with GHC, too, isn't it?
14:54:59 <copumpkin> forall a. Haskell >= a
14:55:01 <kmc> copumpkin's just stating facts
14:55:05 <kmc> mm_freak, how would that work?
14:55:20 <kmc> unsafePerformIO behind your back?
14:55:20 <monochrom> at least you take the care to use >=
14:55:24 <mm_freak> kmc: no idea, my memory might be playing with me
14:55:38 <mm_freak> kmc: perhaps i just remember that interesting wiki page i once read
14:55:59 <tolkad> normal parametric types are just a special case of existential types, right? data Maybe a = forall b. (b ~ a) => Just b | Nothing
14:56:13 <kmc> yeah, the set of extensions {proposed, implemented, documented} for GHC are all different
14:56:27 <lispy> tolkad: hmm
14:56:32 <copumpkin> tolkad: what's the point of that existential?
14:56:36 <taotree> Trying to install Chart package via cabal on Windows. Everything worked up until the Chart package itself.
14:56:37 <taotree> http://hpaste.org/43011/error_cabal_install_chart
14:56:40 <lispy> tolkad: If that's the case, then it's a very special case
14:56:41 <taotree> is the error
14:56:43 <copumpkin> tolkad: parametric types are universal types
14:57:05 <kmc> tolkad, your type is equivalent to Prelude.Maybe, yes, but I'm not sure what's gained by thinking of it that way
14:57:09 <mm_freak> kmc: but your usage of existentials…  how is it different from weak types?
14:57:17 <kmc> i don't know what you mean by "weak types" mm_freak
14:57:26 <copumpkin> mm_freak: you can't look inside it
14:57:34 * ivanm tries to work out why he did "case span isDigit str of (ds,[]) -> all isDigit ds" :s
14:57:35 <taotree> cairo seemed to install with no errors, so... not sure why Chart is giving an error in cairo like that...
14:57:41 <mm_freak> x :: ?a  -- syntax is made up
14:57:43 <mm_freak> x = 3
14:57:51 <mm_freak> and the compiler just infers the type
14:57:52 <tolkad> kmc: nothing really, just wanted to know if I was correct
14:58:04 <mm_freak> it's useful, when you don't want to spell out a complicated type
14:58:05 <kmc> err, you get that just by leaving off the first line, wouldn't you?
14:58:06 <ivanm> taotree: version problem methinks
14:58:11 <kmc> if i just say "x = 3"
14:58:13 <ivanm> either your version of cairo is too old or too new
14:58:14 <kmc> the type of x is inferred
14:58:19 <kmc> that's definitely not called "weak types"
14:58:19 <mm_freak> kmc: yes, but you don't get this:
14:58:31 <mm_freak> x :: (?a -> Maybe ?b) -> ?a -> ?b
14:58:58 <kmc> UHC also has an extension for partial type signatures
14:58:58 <napping> kmc: there's some documentation in Jhc.ACIO
14:59:12 <kmc> i don't think it's especially related
14:59:12 <napping> kmc: there's not actually a safe IO -> ACIO embedding
14:59:33 <taotree> ivanm: thanks... had no problem installing on Linux.
14:59:48 <mm_freak> kmc: what can you do with first class existentials?
14:59:52 <taotree> ivanm: so... must be something related to windows
15:00:18 <ivanm> taotree: is the version of gtk+ (the C library) the same?
15:00:19 <kmc> mm_freak, the same things you can do with GHC's explicitly-declared existentials
15:00:36 <kmc> if i give you a value of type "exists a. (Num a) => a", you can do math on it
15:00:40 <kmc> but nothing else
15:00:50 <kmc> (well, you can do Eq and Show, because they're superclasses of Num stupidly)
15:01:02 <ski> copumpkin : "parametric types are universal types" -- huh ?
15:01:12 <mm_freak> ok, but that sounds like 'forall'
15:01:14 <copumpkin> ski: universal quantification
15:01:20 <kmc> if i give you a value of type "exists a. (a, a -> a -> a)" then you can do monoid-ish things without inspecting the concrete type
15:01:28 <kmc> mm_freak, no
15:01:38 <dolio> Only if it's to the left of an arrow.
15:01:39 <kmc> if i give you a value of type "forall a. (Num a) => a", then you can insist that a = Int
15:01:44 <kmc> i said it works for all a, so it must work for a = Int
15:01:53 <dolio> (exists a. ...) -> T ~ forall a. ... -> T
15:01:55 <ski> copumpkin : the parametric type `Maybe' is most certainly not a universal quantification ..
15:01:59 <kmc> if i give you a value of type "exists a ..." then I have some particular 'a' in mind, and I'm not telling
15:02:06 <f1ori> how can I convert a lazy ByteString to a strict ByteString, is there a library function?
15:02:08 <kmc> they are dual notions
15:02:17 <copumpkin> ski: Maybe : forall (A : Set) -> Set
15:02:23 <napping> f1ori: concat?
15:02:33 <kmc> lazy ByteString =~ list of strict ByteString
15:02:35 <kmc> i think "chunks" gives you those
15:02:51 <napping> that sounds right - S.concat . L.chunks
15:02:53 <kmc> mm_freak, if you continuation-passing-transform existential types, you get universal types
15:03:03 <ski> copumpkin : ok, granted if you include independent function types into (possibly) dependent like that (but i thought you were talking about Haskell)
15:03:09 <f1ori> mm, I'll try...
15:03:11 <mm_freak> kmc: ok, first question:  what's the difference at the rank 1 level?
15:03:21 <kmc> i explained it above
15:03:22 <copumpkin> ski: I am, and Maybe is universally quantified over all types (of kind *)
15:03:24 <tolkad> By the way, since jhc was created to solve the halting problem, I assume it optimizes programs much better than ghc?
15:03:31 <copumpkin> ski: as opposed to what tolkad was saying about it being existential
15:03:46 <kmc> if i give you "exists a. T a" i have some particular hidden a in mind, and you have to use it in a generic way
15:03:57 <kmc> if i give you "forall a. T a" you can use it at any 'a' you like
15:03:58 <taotree> ivanm: thanks, that might be it... linux: 2.20.1, windows: 2.22.1  ok... so maybe if I reinstall 2.20.1 on windows
15:04:13 <kmc> existentials are like a pair of a type and a value
15:04:33 <kmc> data Exists f where { Witness :: f a -> Exists f }
15:04:36 <tolkad> I will quote from the jhc website: "jhc is a haskell compiler which aims to produce the most efficient programs possible via whole program analysis and other optimizations."
15:04:43 <mm_freak> kmc: what's the difference to writing out "Int" instead of "exists a. a" and assigning it an Int?
15:04:48 <copumpkin> tolkad: halting problem?
15:05:03 <kmc> you mean assigning it Int at the definition site?
15:05:04 <j-invariant> should it be  witness
15:05:12 <kmc> the difference is that i hide some details of it being Int
15:05:14 <mm_freak> kmc: yes
15:05:15 <tolkad> copumpkin: is the halting problem equivalent to perfect optimization?
15:05:17 <napping> Are there nice algorithms for type inference on regular types without subtyping?
15:05:25 <kmc> code outside that definition can't use Int-specific functions
15:05:26 <copumpkin> tolkad: it doesn't say perfect, it says as much as possible
15:05:30 <ski> copumpkin : in think tolkad was thinking about `Maybe' (vacuosly) being interpreted as an "existential data type"
15:05:41 <kmc> mm_freak, there's a longish haskell wiki article about existentials
15:05:44 <kmc> and plenty of other stuff
15:05:47 <mm_freak> kmc: ah, now the fog starts to fade away
15:05:57 <copumpkin> ski: introducing a random existential with an equality constraint on a universally quantified type variable doesn't make it an existential
15:06:08 <f1ori> napping: thx, S.concat . L.fromChunks works
15:06:09 <kmc> eg http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
15:06:09 <ivanm> dammit, pattern matching, etc. is so much easier with String than with Text :/
15:06:18 <kmc> and of course there's a chapter in TaPL about existential types
15:06:21 <mm_freak> it makes a special type more general, in some sense?
15:06:28 <ski> copumpkin : note that "existentially quantified type" is not the same as "existential data type"
15:06:29 <katja> I need help one last time%)
15:06:38 <tolkad> copumpkin: Well, that still doesn't make sense because it is always possible to create a compiler with more optimizations
15:06:46 <napping> With regular trees it seems you need to keep around all the old equalities and expand
15:06:48 <copumpkin> tolkad: whatever
15:07:22 <copumpkin> ski: you can introduce a trivial existential anywhere that's equivalent to (), but that isn't very interesting
15:07:44 <ski> yes
15:07:45 <tolkad> copumpkin: That's why python is also a terrible language. They think they can have only "one obvious" way to do things but that would require obviousness to be uncomputable
15:07:49 <katja> http://codepad.org/FaSYPCZN that is mine decoding code. it should decoded binary numbers into digits. input ("11011",[('a',"1"),('b',"10"),('c',"11")])  output "abc"
15:08:04 <monochrom> #haskell-blah is the right place for arguing English semantics such as "is it true that (aims to be the best optimizer) = (solves the halting problem)"
15:08:04 <katja> I have no idea how to define the main code%))
15:08:18 <scree> tolkad: why is optimization uncomputable?
15:09:16 <Tomsik> scree: why are we not yet with lower-bound 3-SAT solvers?
15:09:19 <monochrom> I'm pretty sure the "11011" part can be ignored :)
15:09:27 <mm_freak> :t findBy
15:09:28 <lambdabot> Not in scope: `findBy'
15:10:17 <monochrom> And naughtily in ('a',"1") the "1" part can also be ignored. :)
15:10:33 <ski> katja : btw, note that `a * 2^0 + (b * 2^1 + (c * 2^2 + (d * 2^3 + 0)))' is the same as `a + 2 * (b + 2 * (c + 2 * (d + 2 * 0)))'
15:10:39 <katja> monochrom: that would be cool then. but now.. it should not be ignored%)
15:10:56 <monochrom> deblCo (_, ys) = let (xs,_) = unzip ys in xs
15:11:01 <tolkad> scree: you can only remove a function call if it halts
15:11:02 <katja> ski: foldr?
15:11:36 <dpratt71> @seen ezyang
15:11:37 <preflex>  ezyang was last seen on #haskell 40 minutes and 41 seconds ago, saying: I guess you could always link to http://hackage.haskell.org/package/stm 
15:11:37 <lambdabot> Unknown command, try @list
15:11:55 <scree> tolkad: don't follow.  removing function calls which don't halt sounds like good optimization to me
15:12:01 <ski> katja : or a direct recursion .. i'm just suggesting an alternative way of writing `bin2digit' which doesn't require the extra `n' parameter to `f' (which should be inside a `where', no ?)
15:12:33 <mm_freak> katja: you give a set of binary digit sequences and convert another digit stream by taking shortest prefixes?
15:12:34 <tolkad> scree: that's not an optimization, that is changing program behavior
15:12:38 <ezyang> yo 
15:12:45 <kmc> not if you replace them with the most efficient infinite loop possible
15:13:07 <katja> ski: I like it
15:13:21 <tolkad> kmc: then you can check which function calls would have halted by seeing which ones were replaced with the most efficient infinite loops
15:13:27 <ski> monochrom : presumably  deblCo ("11101",[('a',"1"),('b',"10"),('c',"11")])  should evaluate to `"cba"', though
15:13:30 <tolkad> anyway, there's a proof somewhere or other
15:13:35 <ski> katja : ^ should it ?
15:13:43 <scree> tolkad: so your characterization of an optimization is: same denotational semantics, optimal operational semantics?
15:13:49 <monochrom> interesting
15:13:58 <kmc> are we arguing about what "optimal" means?
15:14:11 <kmc> or are we arguing about whether the halting problem is solvable?
15:14:12 <katja> ski: no to abc
15:14:21 <tolkad> scree: yes
15:14:22 <Phyx-> @hoogle first
15:14:23 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
15:14:23 <lambdabot> Data.Monoid newtype First a
15:14:23 <lambdabot> Data.Monoid First :: Maybe a -> First a
15:14:35 <ski> katja : note that i changed your `"11011"' to `"11101"'
15:14:40 <Phyx-> i don't know why i keep thinking it's "Control.Arrows"
15:14:48 <tolkad> scree: well, more optimal
15:14:58 <kmc> more optimal
15:15:00 * ski was thinking that katja is doing some kind of huffman coding
15:15:05 <scree> tolkad: ok, I could believe that's uncomputable
15:15:17 <joe6> i am converting "09" to hex byte of 9 using: (fst . head $ readHex "09")::Int
15:15:29 <joe6> just curious if I can do it better
15:15:37 <joe6> > (fst . head $ readHex "09")::Int
15:15:39 <lambdabot>   9
15:15:46 <monochrom> they are arguing what "aims to produce the most efficient programs possible" means. Notice that "aims to" and "possible" significantly weakens the phrase. Not sure why anyone would argue at all.
15:15:54 <katja> ski: yeah. you are right
15:15:57 <mm_freak> Phyx-: as an easy rule, haskell modules are usually written in singular
15:15:59 <kmc> > readHex "DEADBEEF"
15:16:01 <lambdabot>   [(3735928559,"")]
15:16:04 <mm_freak> Control.Monad, Data.Map, etc.
15:16:14 <tolkad> monochrom: what about python: "There should be one-- and preferably only one --obvious way to do it. "
15:16:15 <mm_freak> as opposed to Monads, Maps, …
15:16:20 <kmc> joe6, that won't handle parse failure gracefully
15:16:23 <tolkad> monochrom: that would make obviousness uncomputable
15:16:28 <ski> joe6 : `case readHex "09" of [(n,"")] -> n; _ -> error "parse error"'
15:16:36 <mm_freak> ski: i have no idea what she's doing, so i can't really help
15:16:42 <mm_freak> and she refuses to answer ;)
15:16:51 <Phyx-> mm_freak: ah, never really thought about it, thanks, that's a good tip
15:16:58 <joe6> > case readHex "09" of [(n,"")] -> n; _ -> error "parse error"
15:16:59 <monochrom> "what about python" is the right question. yeah, what about it?
15:16:59 <lambdabot>   9
15:17:04 <ski> mm_freak : katja seemed to agree with me above :)
15:17:07 <joe6> ski: thanks a lot.
15:17:27 <mm_freak> in any case it /sounds/ like a very simple problem
15:17:34 <mm_freak> (so haskell can't solve it)
15:17:34 <ski> > case readHex "09meow" of [(n,"")] -> n; _ -> error "parse error"
15:17:35 <lambdabot>   *Exception: parse error
15:17:38 <katja> mm_freak: I just dont understand your language
15:18:11 <mm_freak> katja: you don't need to understand german =P
15:18:11 <katja> mm_freak: sorry%)
15:18:29 <katja> mm_freak: sorry?
15:19:19 <katja> mm_freak: I am not a german so I dont really need to understand german%))
15:19:27 <tolkad> monochrom: I don't believe "aims to" weakens the phrase. They are stating that this is their goal. I am stating that their goal is impossible to achieve because there is no single possible compiler which produces the most efficient programs possible
15:19:59 <kmc> that's correct tolkad
15:20:04 <mm_freak> katja: anyway, you get a digit stream like "11011" and want to decode it to…  well…  something…  and i don't get what that something is
15:20:26 <mm_freak> i just see familiar patterns
15:20:55 <kmc> tolkad, it's not uncommon that useful projects have impossible goals
15:21:03 <kmc> you can get a lot done by working towards an impossible goal
15:21:25 <pastorn> look at DragonflyBSD :)
15:21:44 <kmc> it's impossible to eliminate all crime, so let's shut down the police
15:21:49 <monochrom> this is why it's arguing English semantics. "the best xxx" is ambiguous. one interpretation is "among all mathematically allowed xxx's". another interpretation is "among all implemented xxx's at an implicit point of time". At each point of time, there are only finitely many xxx's, it's easy to trump them all.
15:21:54 <Phyx-> are {-# LANGUAGE pragmas case sensitive?
15:21:59 <pastorn> They want to be able to move a process from one machine to another
15:22:01 <copumpkin> this belongs in -blah
15:22:02 <mm_freak> tolkad: impossible goals are a good concept…  my goal of writing perfect (safe, fast, etc.) libraries is also impossible to reach, but i get a lot of good feedback =)
15:22:05 <pastorn> (without virtual machines)
15:22:06 <katja> mm_freak: It should be [('a',"1"),('b',"10"),('c',"11")])        because before that I wrote i encoding code that converts chars into binary numbers
15:22:28 <pastorn> Phyx-: yes
15:22:34 <Phyx-> pastorn: ty
15:23:01 <mm_freak> katja: i don't understand the transition from "11011" to that…  i only see that "11011" = concat ["1", "10", "11"], which seems to be related
15:23:09 <tolkad> monochrom: Let's argue English syntax instead. Do you think it was ok for them to start their sentence with a lowercase letter?
15:23:29 <monochrom> of course. i do it all the time.
15:23:45 <katja> mm_freak:http://codepad.org/yZMQgUCE
15:24:23 <mm_freak> katja: does that code solve your problem?
15:24:40 <monochrom> as do everyone who use camel_case
15:24:48 <katja> mm_freak: i thought it could help you%))
15:25:25 <mm_freak> katja: it's quite complicated =)
15:25:46 <tolkad> Is jhc better at optimizing than ghc is right now?
15:26:32 <mm_freak> > let digitsToNum base = sum . map (`mod` base) . takeWhile (> 0) . iterate (`div` base) in digitsToNum 10 [1,2,3,4,5]
15:26:33 <lambdabot>   No instance for (GHC.Real.Integral [t])
15:26:33 <lambdabot>    arising from a use of `e_1010123...
15:27:01 <tolkad> > reverse cake
15:27:02 <katja> mm_freak: b is the second digit ind the alphabet. 2 is trasfered into binary number 10
15:27:04 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
15:27:27 <mm_freak> katja: so you go from "abc" to "11011"?
15:27:38 <katja> mm_freak: and now i need to write a code that will transfer a binary number 10 into normal number 2 and then into b
15:27:53 <katja> mm_freak: yeah
15:28:00 <ion> @src cake
15:28:00 <lambdabot> Source not found. :(
15:28:59 <joe6> what is the haskell "bitwise and" operator? &&?
15:29:07 * ski . o O ( "open source cake recipes" )
15:29:15 <mm_freak> ok, then how come that "11011" is translated to "abc" and not to "fc"?
15:29:20 <mm_freak> @ katja 
15:29:20 <ski> joe6 : probably you want `(.&.)'
15:29:34 <mm_freak> 110 = 6, after all
15:29:39 <ski> @type (Data.Bits..&.)
15:29:40 <lambdabot> forall a. (Bits a) => a -> a -> a
15:29:51 <ski> > 110 == 6
15:29:52 <lambdabot>   False
15:29:59 <joe6> ski: thanks.
15:30:26 <ion> > let n = 0 in 110*n == 6*n
15:30:27 <lambdabot>   True
15:30:43 <kmc> tolkad, i think not
15:30:45 <mm_freak> > let digitsToNum base = sum . zipWith (*) (iterate (*base) 1) . reverse in digitsToNum 10 [1,2,3,4,5]
15:30:47 <lambdabot>   12345
15:30:52 <ski> @check \n -> 110*n == 6*n
15:30:54 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
15:30:57 <kmc> i think GHC is far ahead of other compilers in terms of optimization
15:31:04 <kmc> though JHC's whole-program approach will help with certain things
15:31:06 <katja> mm_freak: m...  ohhh shit
15:31:17 <kmc> you should probably find or run some actual benchmarks if you want a real answer
15:31:25 <mm_freak> katja: i mean, it sounds ambiguous
15:31:29 <mm_freak> that's why i don't get it
15:31:44 <katja> mm_freak: then it seems that my codeBlock is not right. or at least due to it I cannot decode 
15:31:49 <jmcarthur> JHC has been inconsistent for me in benchmarks (when i can actually get code to build, that is). sometimes it's far slower than ghc but other time it blows away even C. these are just microbenchmarks, anyway
15:32:13 <mm_freak> katja: you can't decode "11011" back at all…  you could decode ["1", "10", "11"]
15:32:14 <jmcarthur> strange to blow away C considering that it uses C as an intermediate
15:32:35 <mm_freak> the transition from "abc" to "11011" according to your scheme is not invertible
15:32:47 <katja> mm_freak: i mean in my codeBlock I have then input blockCode "fc" and for blockCode "abc" thesame output ("11011",[('f',"110"),('c',"11")]) 
15:33:01 <lispy> jmcarthur: with GC enabled or disabled?
15:33:26 <mm_freak> can you disable GC in JHC?
15:33:27 <jmcarthur> lispy: this was before the GC even existed, so that may be part of it
15:33:32 <katja> mm_freak: how to make it invertible then? I mean how shouwl I change codeBlock then
15:33:38 <ski> katja : if you were using huffman coding of the letters, then you could decode unambiguously from the binary string
15:33:41 <jmcarthur> mm_freak: yeah you can
15:33:46 <lispy> jmcarthur: one reason why JHC appeared fast in the past, IMO, is that it lacked GC.  GC is a significant portion of GHC's execution time.  Like up to 30% in the average program?
15:33:54 <jmcarthur> ew no
15:34:03 <jmcarthur> average should be less than 10% or you have major issues
15:34:16 <lispy> Are you sure?
15:34:28 <lispy> I seem to recall it being fairly high
15:34:29 <jmcarthur> i normally consider it to be a performance bug if my GC time is that big
15:34:29 <ski> katja : e.g.  [('a',"0"),('b',"10"),('c',"11")]  is a valid huffman coding of the three first letters of the alphabet
15:34:38 <mm_freak> ski: you would need the code for that…  you would need the prefixes
15:34:44 <mm_freak> katja: as said
15:34:47 <jmcarthur> and fixing my code fixes the gc time :)
15:34:51 <kmc> you can often decrease GC time by increasing the allocation area size
15:34:53 <katja> ski: ok I got it
15:34:54 <mm_freak> katja: you could also put a separator inbetween like a space
15:35:01 <jmcarthur> yeah, or tweaking some RTS settings
15:35:01 <mm_freak> "abc" → "1 10 11"
15:35:08 <kmc> ./foo +RTS -A400M
15:35:09 <jmcarthur> but normally it's a code problem, in my experiences
15:35:17 <kmc> yeah it's often a code problem
15:35:19 <lispy> dons wrote a tool to explore the GC options
15:35:26 <lispy> For just that purpose actually
15:35:29 <kmc> but even when it is, the simple RTS fix may be good enough
15:35:36 <kmc> yep
15:35:41 <mm_freak> katja: or, as a more interesting and certainly more difficult solution, use huffman coding
15:35:51 <lispy> http://donsbot.wordpress.com/2010/07/05/ghc-gc-tune-tuning-haskell-gc-settings-for-fun-and-profit/
15:35:52 <mm_freak> katja: but then you're essentially writing half of a compression program
15:35:57 <lispy> That's the tool I was thinking of
15:36:00 <lispy> It's pretty cool
15:36:10 <jmcarthur> i don't like relying on RTS flags for it because it means the problems may just continue to escalate as i write more code and continue to ignore them
15:36:18 <monochrom> actually katja wants to write both halfs.
15:36:27 <jmcarthur> it's good to have an understanding of *why* you're having problems with GC
15:36:38 <lispy> Yes, I fully agree with that
15:36:49 <jmcarthur> *at the least
15:36:53 <jmcarthur> even if you decide not to fix it
15:36:53 <lispy> But, developing a good understanding can be hard for most programs
15:37:08 <lispy> Laziness being very unpredictable
15:37:08 * ski idly wonders which huffman codings also work if you reverse the strings ..
15:37:20 <jmcarthur> i normally take issue with that claim
15:37:25 <jmcarthur> that laziness is unpredictable
15:37:27 <katja> ok. I get now input  blockCode "abc" output ("110",[('a',""),('b',"1"),('c',"10")])
15:37:38 <kmc> laziness is entirely predictable
15:37:42 <kmc> just difficult to predict
15:37:46 <kmc> for typical humans
15:37:47 <jmcarthur> if you can't understand the laziness in your code then that just means you haven't been thinking about it as you wrote it
15:37:57 <mm_freak> the only performance problem i had with haskell in the last two years was when i tried to write a low level graphics library
15:38:05 <jmcarthur> mm_freak: hear hear
15:38:10 <ski> katja : it's probably not a good idea to map a letter to the empty string, if you want to be able to write the inverse function
15:38:13 <kmc> @quote ChrisOkasaki
15:38:13 <lambdabot> ChrisOkasaki says: Historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict.
15:38:14 <lispy> jmcarthur: there are lots of times when I work with other people's code though too
15:38:32 <mm_freak> i think after a while you get quite a good feeling for how your program will behave
15:38:34 <ski> katja : since both `"a"' and `"aa"' will be translated to `""'
15:38:36 <jmcarthur> lispy: my hope is that those other people have also written with an eye for strictness properties
15:39:01 <jmcarthur> and documented them when appropriate
15:39:52 <lispy> jmcarthur: Have you ever looked at the darcs source? :0
15:39:56 <lispy> er, :)
15:40:08 <mm_freak> (ok, last week a memory leak blew away my system) =)
15:40:15 <mm_freak> (yes, it was my fault) =P
15:40:55 <kmc> once you know Haskell very well you will see strictness problems as you code
15:40:57 <katja> ski: yeah. I got it
15:41:01 <kmc> but it takes years to get to that point, in my experience
15:41:28 <jmcarthur> i tend to try to keep my strictness-related stuff in data structures and avoid things like seq when i can help it. i find that when i do it that way it makes everything much more predictable. as soon as i use seq in a function i often have to document its use
15:41:37 <monochrom> or a vulcan education
15:41:50 <kmc> i don't know of a document which explains the precise evaluation model GHC uses without getting into implementation details
15:41:54 <mm_freak> kmc: you should see strictness problems with pretty much every other language =P
15:42:18 <lispy> I think about it this way: Laziness + Purity give us composable functions, but the evaluation itself is not easily composable
15:42:38 <monochrom> no, take for example machine code, no strictness problem, or rather strictness is straightforward
15:42:38 <kmc> like something which explains evaluation to whnf, primitive values, seq, bang patterns, all that stuff
15:42:42 <kmc> in a precise way
15:42:52 <kmc> without getting into "how do we tag pointer bitfields on the stack" or whatever
15:43:13 <jmcarthur> lispy: i'm not sure what you mean
15:43:15 <mm_freak> monochrom: strictness /is/ the problem i have in most other languages…  i use laziness to my advantage in haskell
15:43:26 <kmc> what i mean is that i learned a lot about how to write efficient Haskell code by reading the STG machine papers
15:43:35 <monochrom> oh, that strictness problem
15:43:53 <mm_freak> yeah, it was just a joke, but with a serious background
15:44:13 <katja> ski: and I dont know how to fix it
15:44:32 <jmcarthur> mm_freak: totally! something that bugs me often is that literature on many algorithms tend to explain the algorithms in terms of imperative machines, and i know there's a beautiful version taking advantage of laziness lurking in there but it's difficult to draw out :\
15:44:39 <ski> katja : i'm not sure either, since i'm not really sure what you actually want to do
15:45:01 <katja> ski: because then my num2bin makes a (that is 0) into nothing
15:45:02 <jmcarthur> dynamic programming is a common one
15:45:14 <mm_freak> and i'm also missing many other things…  since PHP (which i have to use at work for most stuff) got first class functions, most of my colleagues don't understand my code anymore =)
15:45:21 <mm_freak> some of it at least
15:45:51 <ski> mm_freak : is the lexical scoping correct ?
15:46:01 <mm_freak> jmcarthur: yeah…  wikipedia is a good example of that
15:46:04 <mm_freak> ski: yes
15:46:13 <katja> ski:i need to write a programm that will encode digits into numbers and then into binary numbers  and then another programm decodebinary numbers into numbers and then into digits
15:46:26 <mm_freak> ski: you have to specify the closure explicitly though ("function ($x) use ($yFromEnv)")
15:47:08 <ski> katja : ok. can you choose yourself which numbers and binary strings you encode each digit/letter as ?
15:47:10 <thoughtpolice> so like C++0x lambdas, they have to be totally verbose? :(
15:47:14 <sproingie> mm_freak: is that just for mutation or for read?
15:47:30 <mm_freak> > let numToBase base = map (`mod` base) . takeWhile (> 0) . iterate (`div` base) in numToBase 2 4123
15:47:32 <lambdabot>   [1,1,0,1,1,0,0,0,0,0,0,0,1]
15:47:41 <thoughtpolice> although I guess in C++0x the distinction is necessary since you must decide if you want parts of the environment captured by value/reference, but i wouldn't think this to be necessary in PHP
15:47:41 <mm_freak> sproingie: ?
15:47:54 <mm_freak> thoughtpolice: yes
15:48:10 <thoughtpolice> mm_freak: that makes me go :(, although it's better than nothing I guess
15:48:17 <ski> mm_freak : ok, that's annoying with nested functions, then .. (the same problem appears in my simulation of lambdas in Prolog ..)
15:48:20 <sproingie> mm_freak: when the "use ($yFromEnv)" part.  do you have to declare that just to read $yFromEnv or just if you want to mutate it?
15:48:21 <katja> ski:yeah
15:48:22 <mm_freak> thoughtpolice: totally, but it got no TCO
15:48:59 <ski> katja : then i think you need something like huffman coding
15:48:59 <mm_freak> sproingie: good question…  i think the variable is accessed by reference
15:49:08 <sproingie> python needs 'nonlocal' for the same reason, it has no syntax for declaring variables other than assignment, so someOuterVar = foo shadows by default
15:49:14 <mm_freak> sproingie: i ususally don't mutate much, so i don't know
15:49:35 <ski> katja : more specifically, the bit string encoding for one digit/letter should never be the prefix of the encoding of another letter
15:50:45 <ski> katja : so e.g.  [('a',"1"),('b',"10"),...]  is out, because if you get a string starting as  "10..." then you don't know (in general), whether the result should begin with `a' or `b'
15:51:02 <katja> ski: i know this. on a paper. but how to write a programm with that
15:51:07 <katja> ski:yeah I got it
15:52:17 <katja> ski:http://codepad.org/yZMQgUCE I mean I have now this thing but it encodes a as 1
15:52:30 <ski> katja : one way is to count (or know beforhand) how many (at most) letters/digits will need to be encoded, call this count `m' .. then take the least `n' such that `m =< 2^n', then it will suffice with `n'-bit strings for all letters/digits
15:53:27 <ski> e.g. if you want to encode letters `a',`b',`c',`d',`e', then that's five of them, and the least power of two which is not less is eight, i.e. `2^3', so three bits per letter is enough
15:53:40 <j-invariant> @them
15:53:40 <lambdabot> you are welcome
15:54:10 <katja> ski: ok. but how should I write this in my code
15:54:42 <ski> it could probably be written in many different wys
15:55:14 <Bynbo7> katja: what are you trying to do?
15:56:15 <katja> Bynbo7: i need ti encode a digit into binary number and then a binary number into a digit
15:56:30 <katja> ski: yep%)
15:56:41 <Bynbo7> have you looked at something like huffman encoding?
15:56:46 <ski> another way is to encode the first letter with `"0"', the next with `"10"', the next with `"110"', the next with `"1110"', &c.
15:56:58 <ski> (though that's a bit stupid of an encoding)
15:57:08 <Bynbo7> it's easy to implement, and approaches optimial efficiency i think
15:57:11 <ski> anyway, there's lots of variation possible, i think
15:58:08 <ski> Bynbo7 : yeah, i've mentioned it .. (icbwb) i suspect proper huffman might be too complex for katja atm
15:58:11 <Bynbo7> katja: anyway, i would suggest using a binary tree (on paper) to figure out your ecoding scheme. that way you can avoid any ambiguity
15:58:13 <parcs> sproingie: `use ($yFromEnv)` is pass-by-value. `use (&$yFromEnv)` is pass-by-reference
15:58:34 <Tomsik> http://en.wikipedia.org/wiki/Huffman_coding
15:58:42 <Tomsik> this is what you are trying to do, I believe
15:58:50 <kmc> it's amazing how confused most languages are about the distinction between value, identity, and state
15:59:42 <katja> yeah. but I have not idea how I should release that in haskell
16:00:32 <Bynbo7> i've implemented huffman encoding in haskell, it was really pretty simple
16:00:48 <j-invariant> katja: release what
16:01:23 <joe6> >(.&.) (0x8F::Int) (01100000::Int)
16:01:23 <Tomsik> I've implemented it in OCaml a year ago, it's really simple, yeah
16:01:33 <joe6> > (.&.) (0x8F::Int) (01100000::Int)
16:01:34 <lambdabot>   128
16:01:38 <ski> katja : my first option above is (a) count number of letters (or maybe you already know it's 26 ?); (b) using that, decide on bit strings for each letter; (c) actually translate the letters to bit strings
16:01:42 <Tomsik> you just construct a nice tree or something
16:01:46 <joe6> should it not be 0x00?
16:01:51 * hackagebot fuzzytime 0.3 - Print current time in a more casual way  http://hackage.haskell.org/package/fuzzytime-0.3 (KamilStachowski)
16:02:02 <ski> katja : i'm not saying this is the only way. but afaiu, it'd be one possible way
16:02:21 <joe6> > (.&.) (0x8F::Int) (01100000::Int) == (0x00::Int)
16:02:22 <lambdabot>   False
16:02:28 <monochrom> > 01100000::Int
16:02:30 <lambdabot>   1100000
16:02:35 <katja> ski: ok. thank you
16:02:43 <katja> have a nice night all you
16:02:46 <ski> > 0x8F .&. 01100000 == (0 :: Int)
16:02:46 <Bynbo7> joe6: there's no octal notation in haskell
16:02:47 <lambdabot>   False
16:02:48 <katja> bye bye
16:03:16 <ski> katja : bye .. and don't hesitate to come back later, if you get more problems
16:03:29 <Bynbo7> > 0x8F .&. 0x60F :: Int
16:03:30 <lambdabot>   15
16:03:40 <Bynbo7> > 0x8 .&. 0x60 :: Int
16:03:41 <lambdabot>   0
16:03:49 <Bynbo7> what's the F for...
16:03:55 <Bynbo7> oh, right
16:03:59 <Bynbo7> -_-
16:04:03 <Bynbo7> > 0x8F .&. 0x60 :: Int
16:04:04 <lambdabot>   0
16:04:44 <katja> ski: I still dont undestand how to do that in haskell. I mean lika shoul I change all my code or just half of it
16:05:19 <ski> katja : keep the parts you can, and change/replace the parts you can't ..
16:05:56 <katja> ski: bye bye %)
16:06:09 <pastorn> can i cabal remove?
16:06:10 <ski> katja : probably your `num2bin' will have to be changed/replaced, since it won't be *that* simple to generate correct codes
16:06:24 <joe6> ski: thanks.
16:06:30 <Bynbo7> pastorn: no, you can only ghc-pkg unregister
16:06:34 <katja> ski: yeah. I got it%)
16:06:41 <joe6> Bynbo7: thanks.
16:07:20 <ski> > case readOct "755" of [(n,"")] -> n
16:07:21 <lambdabot>   493
16:07:49 <mm_freak> kmc: i think i finally understood existential types…  many thanks
16:07:59 <kmc> cool mm_freak :)
16:08:26 <mm_freak> in fact i used them a lot without understanding them =)
16:08:47 <mm_freak> first class existentials would be great as in [exists a. SomeClass a => a]
16:09:03 <ski> consumers of existentials must be able to handle any type -- producers of universals must be able to handle any type
16:09:28 <ski> consumers of universals can decide which type to use -- producers of existentials can decide which type to use
16:09:46 <kmc> mm_freak, true, though a lot of the time you want a simpler solution
16:10:22 <joe6> sorry, got disconnected.
16:10:22 <mm_freak> kmc: well, most simpler solutions aren't as extensible
16:10:37 <joe6> is it ok to post 8 lines of code here? or should I use hpaste?
16:10:39 <ski> (mm_freak : i would write that as `[exists a. SomeClass a *> a]', noting a distinction between `.. => ..' and `.. *> ..', similar to the one between `.. -> ..' and `(.. , ..)')
16:10:42 <kmc> hpaste joe6
16:10:47 <kmc> right, extensibility is the key requirement
16:11:04 <ski> @where paste
16:11:05 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
16:11:53 <joe6> is there a better way of doing this? http://hpaste.org/43012/test_and
16:12:29 <mm_freak> kmc: btw, passing functions would still require the dictionary, right?
16:12:42 <kmc> what do you mean?
16:12:47 <joe6> where Byte = 2 character string
16:13:17 <mm_freak> kmc: i use dictionary passing with existential types as some kind of semi-OOP in one of my projects
16:13:32 <mm_freak> and it has a serious performance problem…  it's a graphics library
16:13:55 <kmc> you mean, you quantify over a type class and GHC implements this with a dictionary?
16:14:03 <mm_freak> yes
16:14:09 <kmc> did you try an explicit dictionary?
16:14:17 * kmc goes into his "type classes are overused" rant
16:14:22 <kmc> did you look at the Core output from GHC
16:14:41 <mm_freak> i did the latter, but core output is unintelligible to me
16:15:06 <mm_freak> now my question is really about this "explicit dictionary"
16:15:24 <mm_freak> could passing a set of functions instead of a dictionary solve my problem?
16:15:44 <kmc> you mean like a record of functions?
16:15:51 <kmc> i don't immediately see why that would be more efficient
16:15:59 <kmc> are you using the typeclassiness of typeclasses particularly?
16:16:10 <kmc> i feel like records of functions are a nicer way to implement object-like stuff anyway
16:16:12 <kmc> particularly
16:16:18 <kmc> because records are first-class values
16:16:21 <kmc> and class instances are not
16:16:23 <kmc> it's just simpler
16:17:11 <mm_freak> i mean like:  data Drawable = forall a. Drawable { obj :: a, distanceTo :: Float -> Float -> a -> Float }
16:17:22 <Bynbo7> joe6: using a case statement
16:17:27 <kmc> right
16:17:42 <mm_freak> in the same sense as your monoid example earlier
16:17:45 <kmc> i think that's better than making an IsDrawable class and an AnyDrawable existential and then new types for every drawable thing
16:17:54 <kmc> but i don't know that it'll be particularly *faster*
16:17:58 <Bynbo7> joe6: you could also use testBit
16:18:05 <mm_freak> kmc: how is it better?
16:18:09 <kmc> simpler
16:18:11 <kmc> fewer types
16:18:16 <kmc> values are first class, types and instances aren't
16:18:29 <kmc> i link this all the time so maybe you've already seen it but: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:18:49 <napping> It seems recursive types are handled nicely by union-find with pointer equality
16:19:59 <mm_freak> kmc: no, but i'll read it
16:20:41 <mm_freak> btw, a useeful optimization of this, as far as applicable, would be to use C++ style RTTI
16:20:53 * ski annotated "test and" as "`case'" at <http://hpaste.org/paste/43012/case#p43015>
16:20:56 <ski> joe6 : ^
16:21:03 <mm_freak> the same in C++ was very fast
16:21:21 <kmc> the equivalent in Haskell would be to use Typeable
16:21:38 <kmc> that is basically RTTI
16:21:38 <napping> Have you looked at how RTTI is compiled? Typeable is almost the same thing
16:21:52 <kmc> cast :: (Typeable a, Typeable b) => a -> Maybe b
16:21:58 <mm_freak> sure, but it doesn't give you the nice syntax
16:22:02 <kmc> is basically like dynamic_cast
16:22:07 <mm_freak> and probably even less the same speed
16:22:09 <kmc> what's the nice syntax for RTTI?
16:22:20 <mm_freak> i don't need the casting part, i need the function overloading part
16:22:25 <kmc> confused
16:22:49 <mm_freak> you get a set of objects and you want to draw them…  each object has a 'draw' function
16:22:54 <kmc> C++ function overloading is resolved by the dynamic type?
16:22:55 <dpratt71> what's the meaning of having a type declaration inside a class declaration? I'm guessing it relates to type families?
16:22:57 <napping> vtable just means every value contains a record of pointers to functions
16:23:02 <kmc> mm_freak, that's not RTTI.  that's virtual functions
16:23:03 <napping> dpratt71: yes
16:23:05 <kmc> usually implemented by vtables
16:23:12 <kmc> which are basically these dictionaries we were talking about
16:23:39 <kmc> dpratt71, right.  it's an "associated type" / "associated synonym", which is a special case of type families / synonym families
16:23:47 <napping> a difference being, dictionaries are passed around separately so if you get several values of the same type you only get one dictionary, rather than taking up space in each value
16:23:47 <mm_freak> in haskell you would write "draw x", in C++ you would write "x.draw" or more likely "x->draw"…  using Typeable would destroy the syntax beauty
16:24:04 <kmc> who cares
16:24:14 <kmc> also really C++ is your model of syntactic beauty?
16:24:17 <napping> why not just write "draw x"?
16:24:30 <dpratt71> napping, kmc: ok, thanks; I haven't come across the term 'synonym families' before
16:24:34 <mm_freak> guys
16:24:41 <mm_freak> i talk about the syntax from BOTH
16:24:45 <napping> even if you need to define something like draw (Drawable impl draw_fun ...) = draw_fun impl
16:24:47 <kmc> oh i see
16:24:47 <mm_freak> "draw x" is very nice
16:24:58 <mm_freak> and Typeable destroys it
16:24:59 <kmc> mm_freak, you can make wrappers around typeable to get that, no?
16:25:10 <mm_freak> hmm, yes
16:25:19 <mm_freak> but i don't think it would solve the performance problem
16:25:31 <kmc> i don't see why it would
16:25:32 <napping> why are you using typeable anyways?
16:25:42 <napping> it sounds like you just need to package a record of methods with your values
16:25:47 <kmc> neither Typeable nor C++ RTTI (being very similar) is an appropriate way to overload functions at runtime
16:25:52 <glguy> brought to you by the people that imposed RealPlayer on you
16:25:53 <mm_freak> nap	i'm not…  i use existentials
16:25:54 <kmc> what you refered to in C++ is not RTTI but virtual methods
16:26:11 <dhaivat> I had nooo idea haskell was so popular
16:26:21 <mm_freak> in C++ every class with child classes has a 32 bit word, which is an index into an efficient lookup table
16:26:22 <glguy> (wrong channel /:-)
16:26:23 <napping> in particular, try making the function members of your existential package strict
16:26:36 <kmc> dhaivat, you'll find an abnormally high percentage of people using Haskell are in #haskell
16:26:52 <kmc> mm_freak, that's in the C++ standard?
16:27:14 <mm_freak> napping: i tried everything with regard to strictness…  it's really the dictionary passing, because as soon as i remove the polymorphism, the drawing function is blazingly fast
16:27:17 <kmc> it requires that you use a 32-bit word and such?
16:27:24 <mm_freak> it feels like i wrote it in C++
16:27:39 <mm_freak> kmc: no, of course not, but GCC does it that way
16:27:46 <kmc> mm_freak, you said "in C++"
16:27:48 <mm_freak> kmc: also i'm not sure about the 32 bits, but you get the point
16:27:52 <napping> once you remove the polymorphism, it's probably optimizing out the indirect function calls
16:27:58 <kmc> and is this for RTTI or for virtual methods?
16:28:06 <napping> that's going to make a huge difference
16:28:18 <mm_freak> kmc: let's say "practically in C++", because pretty much every compiler does it that way
16:28:22 <kmc> for the vtable you don't have a lookup table index, you just have a pointer to a vtable
16:28:31 <mm_freak> kmc: that /is/ the RTTI
16:28:38 <napping> kmc: well, clang at least seems to implement RTTI with a vtable field pointing to yet another table of class info (something like GHC header words)
16:29:19 <mm_freak> kmc: that number completely specifies the class and is also a usable index into thet lookup table, the "vtable"
16:29:36 <kmc> by "lookup index" you mean something other than a pointer, yes?
16:30:02 <mm_freak> dunno, probably the latter
16:30:17 <mm_freak> i'm not quoting the actual implementation, just the concept
16:30:27 <napping> not necessarily - I suppose a clever compiler might test the value of the vtable pointer, if it wants to check exact class
16:30:52 <kmc> before you said "32-bit word" which sounds like an exact implementation detail
16:30:54 <napping> I hear JHC sometimes implements class methods by a case over the info pointer, if it has enough whole-program info
16:30:57 <mm_freak> the term "vtable" suggests that it's an index
16:31:02 * hackagebot vty 4.6.0.4 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.6.0.4 (CoreyOConnor)
16:31:14 <kmc> mm_freak, no, it's a table per class
16:31:28 <kmc> the object has a pointer to its class's vtable
16:31:38 <kmc> the indices in that class correspond to the different virtual methods
16:31:42 <napping> and inheritance makes it not easy to use the address of the vtable alone to check types
16:31:45 <kmc> indices in that table*
16:31:49 <kmc> the entries in that table are function pointers
16:32:28 <kmc> so calling a virtual function involves two pointer derefs
16:32:49 <kmc> unless the vtable gets flattened into the object, which you'd sometimes want to do
16:33:01 <napping> really?
16:33:24 <mm_freak> well, being picky about my wording doesn't really solve my problem, and it's also annoying, because i'm pretty sure a smart guy like you gets my point
16:33:47 <napping> mm_freak: my point is that the runtime layout of a C++ class with virtual methods is almost identical to a sufficiently strict existential package
16:33:47 <mm_freak> in C++ it's efficient, in haskell it's not…  that's the point…  and there is room for optimization
16:33:51 <monochrom> "index" sometimes is more like "the index at the back of the book"
16:34:04 <mm_freak> napping: i tried making everything strict
16:34:13 <kmc> i don't mean to be a dick; i've seen arguments about programming languages go on for hours because people didn't bother to check that they agree on what terms mean
16:34:25 <mm_freak> napping: also i read in the wiki that superfluous strictness can even degrade performance
16:34:39 <kmc> right, there's a penalty to forcing a value even if it's already been force
16:34:44 <ivanm> is it possible to have nested guards?
16:34:54 <kmc> though with GHC that should be very small in the common case, thanks to pointer tagging
16:35:22 <napping> so if you're writing something like data Distable = forall state . Distable { v :: !state, dist :: !(state -> Point -> Float)}
16:35:31 <napping> it should also be two pointer derefs at most to call the method
16:35:32 <c_wraith> well, there's also the possibility of forcing something where it just leads to executing code with no gain in either time taken or memory used
16:35:34 <mm_freak> kmc: i understand that, but i didn't mean to go into low level details, and i think, i made that clear early
16:35:48 <napping> have you tried writing it just like that?
16:36:04 <mm_freak> napping: i did
16:36:21 <mm_freak> napping: it didn't improve…  in fact it ran slower, just like the wiki article said
16:36:43 <napping> also, how many different types do you actually need?
16:36:51 <mm_freak> the data gets evaluated with the first iteration of the drawing function
16:37:00 <mm_freak> and there are millions of those iterations
16:37:17 <napping> how many different types?
16:37:17 <mm_freak> i don't need many, but i want the library to be extensible
16:37:18 <monochrom> eww
16:38:18 <napping> also, how are you storing these shapes?
16:38:20 <monochrom> something about not putting the !s in the data type but make sure all creators ! them?
16:38:27 <napping> [] will hurt, for example
16:38:30 <ddarius> The issue is probably not how much time the dispatch takes, but the second-order affects of confounding optimizations.
16:38:47 <ddarius> monochrom: That's ridiculous.
16:39:32 <mm_freak> napping: ordinary haskell lists, but that's not a big deal…  as said, without the polymorphism i easily got 30 FPS…  note that i'm writing to video memory, and i'm writing every pixel in every frame
16:39:44 <mm_freak> haskell lists are fast, as long as you use them properly
16:39:54 <kmc> mm_freak, i assume you built with -O?
16:40:01 <mm_freak> kmc: sure
16:40:13 <mm_freak> -O2 didn't make a difference, btw
16:40:23 <kmc> did you try +RTS -s
16:40:31 <kmc> to get some extra performance info
16:40:32 <napping> what if you fix the type once for each list?
16:40:42 <kmc> i'm guessing you also did a full profiling, to trace it down to polymorphism
16:41:21 <napping> like changing dostuff :: ... [Distable] -> ... into dostuff :: ... (shape -> Point -> Float) -> [shape] -> ...
16:41:38 <mm_freak> yes, it's definitely polymorphism…  statistics just confirmed it
16:41:45 <mm_freak> napping: that was my question earlier
16:41:59 <mm_freak> i will try that out (inside of the existential type)
16:42:01 <napping> that should lead to good prediction even if you do end up with an indirect call
16:42:20 <ddarius> What's a good movie that isn't very widely known?
16:42:34 <ivanm> ddarius: old or new?
16:42:39 <kmc> ddarius, El Topo
16:42:42 <ddarius> ivanm: Doesn't matter.
16:43:01 <ivanm> well, I can give you some non-English ones... :p
16:43:24 <believa> Is there an API that does pretty-printing of an HXT XmlTree - not like formatXmlTree, just simple nested indentations of tags?
16:43:25 <mm_freak> ddarius: where does "widely known" start?
16:43:29 <ivanm> most Australian films aren't known outside of Australia: Castle, The Dish, Bad Eggs, CrackerJack, etc.
16:43:41 <Pseudonym> Crackerjack is crap.
16:43:48 <monochrom> writeDocument has an option for indenting
16:43:49 <Pseudonym> Bad Eggs isn't very good either.
16:43:59 <ivanm> Pseudonym: I beg to differ!
16:44:17 <Pseudonym> Let me put it this way: Neither are up to the usual standard.
16:44:26 <ivanm> define "usual standard"
16:44:36 <Pseudonym> The Castle, The Dish etc.
16:44:52 <ivanm> OK, I'll admit they aren't as good as them
16:44:56 <ivanm> they're still good though
16:44:58 <monochrom> I'm pretty sure "good movie" is subjective. Just use "good movie according to you".
16:45:02 <ivanm> oh, Wog Boy is another good one
16:45:04 <mm_freak> ddarius: fahrenheit 451 is a great movie i think
16:45:05 <Pseudonym> Proof
16:45:12 <mm_freak> i also liked the old version of solaris
16:45:12 <ivanm> Pseudonym: IMHO they are
16:45:23 <Pseudonym> "Proof" is probably my favourite of the last 20 years.
16:45:34 <ddarius> mm_freak: I didn't like the book.  I might have seen it and not liked it either.  I'm not a Bradbury fan.
16:45:38 <monochrom> there is an old version of solaris? as in not George Clooney?
16:45:45 <mm_freak> and my favorite movie is "cube", but it's a bit more widely known
16:46:08 <monochrom> cube is clever. just sad.
16:46:09 <mm_freak> ddarius: you've seen the 70s movie?
16:46:13 <beastaugh> mm_freak: Stalker is great too
16:46:19 <ddarius> mm_freak: I think I might've.
16:46:27 <mm_freak> ok
16:46:30 <Pseudonym> Oh, and Jindabyne.  Very good film, not well-known outside Australia.
16:46:37 <mm_freak> i like "dark city", too
16:46:49 <ddarius> Dark City is good.
16:47:15 <mm_freak> THX 1138 is interesting, but it's difficult to watch
16:47:15 <ivanm> Pseudonym: oh? haven't heard of that one
16:47:20 <Pseudonym> BTW, this is more on-topic on -blah.
16:47:51 <mm_freak> Pseudonym: it's very on-topic, because ddarius wanted to test how easy it is to distract haskell people =)
16:48:15 <Pseudonym> Ah. :-)
16:49:05 <mm_freak> anyway, as a last tip, ddarius, if you liked dark city, you'll probably also like cube
16:49:11 <monochrom> I need a good book on calculus...
16:49:19 <Pseudonym> If you liked Cube, there's Fermat's Room.
16:49:59 <beastaugh> monochrom: how advanced? Spivak's book is good
16:50:03 <ddarius> mm_freak: I've seen it.
16:50:36 <monochrom> "Fermat's Room" sounds intriguing
16:51:32 <kmc> you could watch Zardoz
16:51:48 <kmc> that movie really is.... something
16:52:30 * monochrom contemplates inventing movie "fermat's last tango"
16:53:04 <kmc> zardoz is simultaneously good, so-bad-it's-good, and so-bad-it's-bad
16:53:09 <kmc> depending on what you pay attention to
16:53:14 <gwern> monochrom: he has a truly marvelous dance but the hall is not lrge enough?
16:53:28 <monochrom> yeah, that will be certainly included!
16:53:40 <kmc> i also recommend getting stoned first because the plot is a lot more interesting if you're easily confused
16:53:57 <ddarius> kmc: Sounds like "Brotherhood of the Wolf" minus the "good" part.
16:55:19 <ddarius> Just to reciprocate slightly.  The Korean films, "My Sassy Girl" and "Tae Guk Gi" are both very good.
16:55:49 <napping> I realized my type checker is going to work if I build everything from unification variables, and have pointer equality
16:55:54 * sm has zardoz on queue
16:56:21 <ddarius> napping: Yep.  An STLC type checker can be written in about 3 lines of Prolog.
16:56:29 <sm> ddarius: Russian Ark
16:56:29 * mlh loves xardoz
16:56:33 <mlh> eek 
16:56:39 <mlh> for sleep therapy?
16:56:42 <gwern> ddarius: I just finished downloading my sassy girl a few months ago
16:56:44 <gwern> what a coincidence
16:56:49 <napping> if t1 and t2 are already unification variables holding two distinct arrow types, they should be made to point to a single arrow instance, and new equalities introduced
16:56:58 <napping> ddarius: including regular infinite types?
16:57:43 <ddarius> napping: Technically Prolog is supposed to have an occurs-check, but if it's omitted then you will get infinite types.
16:58:08 <ddarius> Supporting equirecursive types in a language like Haskell would not be hard at all.  Equirecursive types are just a very bad idea (at least inferring them is.)
16:58:37 <napping> I'm going to require them to go through a record type
16:58:59 <allbery_b> there's a thread in haskell-cafe where someone proposed discarding the occurs check
16:59:04 <allbery_b> a couple years ago
16:59:33 <napping> apparently the result is any closed term is typeable in the simply typed lambda calculus with recursive types
16:59:45 <allbery_b> let's just say that nobody wants to deal with the hairy issues that arise, in particular the kind of error messages you get on type mismatches (if indeed you get an error message and not a nonterminating typecheck)
17:00:00 <napping> you really shouldn't get nontermination
17:00:24 <napping> I'm not sure I trust Prolog minus an occurs check to be smart enough to avoid nontermination, though
17:01:10 <ddarius> allbery_b: Well simply discarding the occurs-check wouldn't work, but it's quite possible to make it work.
17:01:13 <napping> it seems to be essential that unifying two variables which have been partially instantiated with the same head immediately adjust them to refer to pointer-equal heads
17:01:44 <ddarius> The issue with inferring equirecursive types is that all those type errors of the form "could not construct the infinite type ..." become correct, though they almost always are actual errors.
17:01:58 <mm_freak> Pseudonym: fermat's room seems to be inspired by cube
17:02:08 <napping> yeah, that's why I'm going to limit to recursion involving record types
17:02:35 <napping> the plan is to build a class system around extensible records
17:02:52 <ddarius> napping: O'Caml allows equirecursive types when declared and when you use the -rectypes flag, if you are interested in experimenting with them in an actual system.
17:03:50 <napping> I suspect something like 90% of the structural-subtyping style stuff done in Python would be typeable with that sort of thing, and more if typecase is rewritten to use extensible variants
17:04:00 <napping> O
17:04:08 <napping> O'Caml doesn't have record extension, unfortunately
17:05:09 <monochrom> where is tolkad when we need him to say "I just use unsafeCoerce" :)
17:05:58 <napping> I doubt it would help
17:06:54 <ddarius> napping: Just imagine how much of the infrastructure you use daily is based on unsafeCoerce.
17:07:23 <napping> It's more that I'd probably have to memcpy around raw object representations to wedge new fields into the middle
17:07:41 <napping> and that sounds like a little too much
17:07:47 <monochrom> I see
17:08:19 <gwern> @quote tolkad
17:08:19 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
17:08:32 <monochrom> preflex: seen tolkad
17:08:33 <preflex>  tolkad was last seen on #haskell 1 hour, 41 minutes and 34 seconds ago, saying: > reverse cake
17:08:46 <napping> the general idea is class M (method f = e; ...) ==> let M self = {self | f = e; ...}
17:08:54 <gwern> @quote tolkad
17:08:54 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
17:08:57 <gwern> @quote tolkad
17:08:57 <lambdabot> tolkad says: Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
17:09:11 <gwern> wha. he's not a troll is he?
17:09:13 <napping> then use fix to make instances
17:09:28 <monochrom> a lost soul
17:09:31 <napping> time to go
17:10:39 <monochrom> ♥ haskell
17:11:08 <mm_freak> what are equirecursive types?
17:11:24 <pastorn> ♥ unicode
17:11:49 <conal> mm_freak: in haskell, i think they'd be recursive type synonyms.
17:11:52 <monochrom> equirecursive type is when "type X = a->X" or "data X = a->X" is valid.
17:12:06 <mm_freak> ok
17:12:36 <mm_freak> then Mu Maybe would really be Maybe (Maybe (Maybe …))
17:12:44 <Cale> mm_freak: In general, where the recurrence defining a recursive type is treated as an equation, rather than an isomorphism
17:13:04 <Cale> mm_freak: yeah
17:13:12 <conal> i often wish haskell had equirecursive types! the lack destroys the elegance of many things i want to say.
17:13:32 <Philippa> I'm feeling dozy: is there any cuter way to do "assign this to a reference then return the reference every time in future" than manually newRefing once in a monad and then always using the ref?
17:13:57 <Philippa> (the reference doesn't need to be mutable: I just need to build recursive structures and see where the recursion happens)
17:14:58 <mm_freak> other than a real type level fixed point combinator, where would that be useful?
17:15:39 <monochrom> "US_Economy = Money -> US_Economy" models US economy :)
17:15:45 <Philippa> it doesn't need to be type level
17:15:48 <mm_freak> lol monochrom 
17:16:00 <Philippa> I just need to be able to explore the structure as finite rather than infinite and want to sugar it up a bit
17:16:11 <mm_freak> Philippa: sorry, i wasn't talking to you
17:16:13 <Philippa> (putting the references in completely manually is doable, just a big PITA)
17:16:15 <Philippa> oh, sorry
17:16:38 <Philippa> and: it's partly useful when you replace the fixpoint with something else :-)
17:16:49 <ddarius> conal: You could switch to O'Caml.
17:16:51 <Philippa> which you can do to eg extend the datatype
17:17:02 <conal> ddarius: no thanks!
17:17:15 <Kaidelong> Oh conal
17:17:18 <Kaidelong> in one of your papers
17:17:27 <conal> i've programmed a lot in ml and loved it at the time, but now i'm spoiled.
17:17:30 <Kaidelong> you used [[]] to show the semantic function
17:17:37 <conal> Kaidelong: yeah
17:17:45 <Kaidelong> I found that extremely counterintuitive compared to prefix notation
17:17:49 <conal> Kaidelong: both on types and values
17:17:51 <ddarius> @tell napping You probably already have, but if you haven't, you probably want to look at Luca Cardelli's (earlier) work on objects, object encodings, and the sigma-calculus.
17:17:51 <lambdabot> Consider it noted.
17:17:53 <Kaidelong> it took me a while to figure out what was going on
17:18:03 <ddarius> Kaidelong: It's pretty common notation.
17:18:08 <Saizan> Philippa: data-reify instead?
17:18:16 <Kaidelong> I wouldn't know, admittedly!
17:18:30 <Kaidelong> but it was a hurdle for me to adjust to it
17:18:31 <Philippa> Saizan: tell me more?
17:18:34 <ddarius> And yeah, occasionally having equirecursive types would be very nice.
17:18:35 <mm_freak> conal: could you name a specific example of where one would want (or at least miss) equirecursive types?
17:18:42 <Philippa> (my data does have functions buried in it, but they're all at leaves thankfully)
17:19:19 <Kaidelong> I think I understand what is going on now though, you want it so that when implementing an interface you're just applying a semantic function to the method's terms?
17:19:22 <Kaidelong> err
17:19:25 <Kaidelong> a typeclass
17:19:29 <Saizan> Philippa: http://hackage.haskell.org/package/data-reify <- it builds a graph representation of a vanilla haskell ADT, but i've never used it myself
17:19:32 <conal> mm_freak: not at hand. there might be some in my blog.
17:19:58 <conal> mm_freak: ah. one example: memo tries via higher-order types.
17:20:13 <conal> mm_freak: or plain-old types for that matter.
17:20:52 <conal> Kaidelong: you're asking about why i want a semantic function?
17:21:07 <mm_freak> what's a higher order type?  something with parentheses in the kind signature?
17:21:20 <Kaidelong> conal: more about what semantic design is and why you would do it, I suspect?
17:22:12 <Kaidelong> I poured over the paper for a couple of hours last night, not entirely sure how well I understood it
17:22:27 <conal> Kaidelong: there are a few angles to come at that question. (as with "why" questions in general.) one is that i want to know *what* i'm implementing, not just *how* to implement some fuzzy notion.
17:23:11 <conal> Kaidelong: another is that i care about correctness. and if i don't know the *what*, then i cannot even ask clearly about whether a given *how* is correct or not.
17:23:48 <jmcarthur> to me it's about having pratically a complete specification in about an inch of notation
17:24:02 <Kaidelong> I think I picked that up, it was the formal transformations using [[]] that threw me off a bit, but I think the idea is that for some method f, with some arguments x y z, you want to show f [[x]] [[y]] [[z]] is the same as [[f x y z]]?
17:24:14 <Kaidelong> and if your semantic function doesn't behave like that it is wrong
17:24:27 <Kaidelong> or rather
17:24:27 <jmcarthur> *practically
17:24:29 <Kaidelong> you could do better
17:24:35 <conal> Kaidelong: another benefit is insulating my reasoning as a library user from any implementation complexity.
17:25:19 <Kaidelong> hmm, yes, basically thatif there is some algebra for the thing you're talking about you can change how the thing works without changing what the thing is?
17:25:32 <jmcarthur> a short, simple, precise specification is amazing documentation for both the user and the developer
17:25:36 <conal> Kaidelong: close. except that the two f's are different.
17:25:41 <Kaidelong> that'd really be an idea that goes back to things as simple as procedural abstraction
17:25:58 <Kaidelong> yes, well, [[a]] is different from a so the method overload needed would be different
17:26:09 <Kaidelong> although i guess in another sense f is actually the same?
17:26:14 <Kaidelong> in a conceptual sense
17:26:40 <conal> Kaidelong: one f works on values, and the other f works on the meanings of those values.
17:26:57 <conal> Kaidelong: when used with "languages", one side is syntax and the other side semantics.
17:27:41 <Kaidelong> I thought I picked up some similarity to BNF in the notation
17:27:47 <conal> Kaidelong: figuring out the right-hand-side f is how i give precise meaning to the left-hand-side f
17:28:07 <ivanm> what would be the best way to convert this function to Text rather than String? http://hpaste.org/43016/how_to_convert_this_to_using_t
17:28:24 <ivanm> just use Text.zip, etc. and still do a list-based foldr?
17:28:26 <conal> Kaidelong: you can think of the LHS as representation and RHS as meaning.
17:28:50 <jmcarthur> Kaidelong: "the meaning of 'f x y z' is the meaning of 'f' applied to the meaning of 'x' applied to the meaning of 'y' applied to the meaning of 'z'"
17:29:41 <jmcarthur> that is, i read [[a]] as "the meaning of a"
17:30:03 <jmcarthur> and the idea is that it's compositional
17:30:11 <monochrom> "meaning" here refers to using something from math.
17:30:33 <jmcarthur> so if you have two things with meanings, then the composition of those things should mean the composition of their meanings
17:31:04 <j-invariant> [| m . n |] = [| m |] o [| n |] <--- functor
17:36:26 <Kaidelong> huh
17:36:29 <Kaidelong> oh
17:36:40 <Kaidelong> this really seems similar to something I read about before
17:36:51 <Kaidelong> about how syntax should be tied to semantics in a predictable way
17:39:22 <j-invariant> why should it
17:40:40 <ddarius> j-invariant: If it isn't "predictable" (which compositionality gives implies a form of predictability), then you have to restart your reasoning when you add other syntactic elements, ultimately requiring understanding the whole program to understand any part.
17:41:07 <j-invariant> ddarius: that is very clear & succinct
17:41:33 <Kaidelong> it is also harder to learn a language if there are a lot of exceptions or special cases to take account of
17:41:54 <Kaidelong> if the semantics can't be predicted from the syntax you'd have to keep in mind when it behaves differently
17:42:14 <Kaidelong> well, there'd have to be a distinction between different kinds of semantics
17:42:30 <Kaidelong> denotative semantics would be the word here, I think?
17:42:31 <quepe> don't understand haskell
17:42:35 <quepe> too difficult
17:42:37 <quepe> bye
17:43:08 <ddarius> quepe: I recommend PHP.
17:43:09 <ezyang> Kaidelong: denotational semantics is one type of semantics 
17:44:00 <ddarius> In fact denotational semantics is one type of algebraic semantics, though how algebraic semantics and how denotational semantics are actually used is rather different.
17:44:05 <quepe> thnks
17:44:20 <ddarius> Conal's type class morphism starts bringing them back together.
17:44:34 <Kaidelong> that was the name of the paper I read!
17:45:02 <dpratt71> ezyang: I incorporated some of your earlier suggestions: http://codepad.org/zGFJPlO7
17:45:14 <dpratt71> ezyang: am I getting closer?
17:45:50 <quepe> I'm in tryhaskell.org. I like it is dynamic, but I got lost with the dots, parenthesis and that... it's not understandable as a natural human language... 
17:46:28 <quepe> no doubt there are people that understand it, but not me
17:46:30 <ddarius> quepe: Then you want the Inform family.
17:46:49 <Philippa> or COBOL
17:46:55 <ezyang> dpratt71: That looks pretty reasonable. 
17:47:12 <Philippa> also, only Inform 7's really natural language AFAIK
17:47:20 <Philippa> (any subsequent developments?)
17:47:24 <ezyang> Inform has a lot of cool ideas stuffed in it. 
17:47:26 * hackagebot bindings-DSL 1.0.9 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.9 (MauricioAntunes)
17:47:30 <jmcarthur> quepe: haskell is not a natural human language
17:47:39 <dpratt71> ezyang: ah, good; any suggestions for making it better?
17:48:08 <jmcarthur> quepe: it's also not "dynamic" if you mean "dynamically typed"
17:48:09 <ezyang> with the organization into frames, you can now just do a take 10 on the input list. 
17:48:12 <Philippa> quepe: it's also not actually what's normally meant by a dynamic language
17:48:59 <Philippa> jmcarthur: nor "highly mutable" in the way that smalltalk is and something like an old BASIC isn't (modulo POKE abuse)
17:49:12 <dpratt71> one thing is that the repeated "score' nfx fms" catches my eye as something I could merge, but I hesited only because I didn't have a good name for it
17:49:34 <quepe> yeah dynamically typed... Anyway guys thank you... this was my very first interaction with Haskell. 
17:50:17 <quepe> Maybe a kind of philosophical introduction could help in tryhaskell.org. To understand the philosophy behind the symbolism
17:51:04 <dpratt71> ezyang: I might be misunderstanding you, but I don't think I can 'take 10'; if the last bowl is a spare or strike, there is an 'extra' frame
17:51:13 <sm> has anyone got a good "apply function N times" ? I've misplaced mine
17:51:30 <dpratt71> actually, two extra frames in the case of a strike in frame 10
17:51:33 <c_wraith> sm: iterate f x !! n
17:51:48 <sm> eh.. really ?
17:51:52 <Twey> sm: napp n f = (!! n) . iterate f
17:52:02 <Twey> Or… yeah, that
17:52:05 <sm> oh you're right.. I didn't realise that
17:52:10 <ezyang> oh, that's right, you get extra bowls at the end, if you take strikes? 
17:52:12 <sm> thanks 
17:52:20 <ezyang> Ok, that's me not knowing enough bowling :-) 
17:52:39 <ddarius> Where "enough" = "any"?
17:53:11 <gienah> newbie question: is there an easier way to conver a Char to a Word8 for ByteString other than: toEnum (FromEnum 'c'), as in something like (probably lambdabot will not compile this): 
17:53:25 <gienah> > Data.ByteString.putStrLn $ (Data.ByteString.pack [toEnum (fromEnum 'a')]) `Data.ByteString.snoc` (toEnum (fromEnum 'b'))
17:53:26 <lambdabot>   Not in scope: `Data.ByteString.putStrLn'Not in scope: `Data.ByteString.pack...
17:54:01 <dpratt71> ezyang: right; a strike in frame x means the points from the next two bowls get added to the score for frame x 
17:54:14 <c_wraith> gienah: if you're not concerned about mangling non-ascii characters anyway, you should just use the Data.Bytestring.Char8 interface
17:54:50 <gienah> c_wraith: great, thanks!
17:54:52 <dpratt71> if a strike happens at the end, you need to bowl a couple more times to figure out what to add to the score of the last frame
17:56:12 <sm> Twey: any idea why napp's type signature isn't just  Int → (a → a) → a ?
17:56:21 <dpratt71> ezyang: I wanted to add some logic for better error handling in the case of an invalid number of balls, but that is tricky, as you can see
17:56:47 <sm> is that a sensible type sig, or have I lost my haskell fu ?
17:57:10 <sm> "cannot construct the infinite type: a = a -> a"
17:58:48 <Mathnerd314> @type \n f x -> iterate f x !! n
17:58:49 <lambdabot> forall a. Int -> (a -> a) -> a -> a
17:59:16 <sm> urghhh.. thanks! :)
17:59:53 <copumpkin> that's going to stack overflow though
17:59:59 <monochrom> I know how to implement Int → (a → a) → a. g n f = fix f :)
18:00:56 <ivanm> `f` has left-associativity, doesn't it?
18:01:11 <dolio> By default.
18:01:27 <ivanm> *nod*
18:01:37 <ddarius> monochrom: I implement it with fix id.
18:01:56 * Saizan implements everything with fix id
18:02:00 <monochrom> "Any operator lacking a fixity declaration is assumed to be infixl 9"
18:02:31 <ddarius> ivanm: To amplify, you can give fixity declarations for alphabetical operators.
18:03:30 <ivanm> yeah, I meant the default
18:03:39 <monochrom> fix id is the best thing since fixed points
18:04:21 <joe6> ski: just saw your code and it is a lot better. Thanks.
18:05:27 <monochrom> SPJ rented a place and hammered some nails into the wall. They are leased fixed points.
18:06:06 <Saizan> ...
18:06:11 <ddarius> monochrom: That's what I do when I want to find a person again.
18:09:46 <Mathnerd314> monochrom: are you certain it was SPJ?
18:09:47 <joe6> what is the difference between GHC.Word vs Data.Word?
18:09:57 <monochrom> perhapd dana scott
18:10:03 <ddarius> joe6: One you should use and one you shouldn't.
18:10:22 <joe6> so, should I be using GHC.Word and not Data.Word?
18:10:27 <monochrom> use Data.Word
18:10:33 <joe6> ok, thanks.
18:10:58 <ddarius> joe6: By and far, you shouldn't be using stuff under the GHC hierarchy.
18:11:55 <joe6> ddarius: ok, thanks. did not know that.
18:26:28 <ddarius> The interrobang has the useful property that if the reader doesn't have a Unicode font, it will likely render as a question mark.
18:27:59 <Saizan> how graceful
18:28:29 <conal> Kaidelong: sorry about the disconnection. my internet access is weather-sensitive.
18:28:37 <Kaidelong> sattelite?
18:29:50 <conal> Kaidelong: yeah. i live in the woods, far from cable & dsl.
18:31:23 <joe6> what does "reads" do?
18:31:41 <Axman6> : reads
18:31:45 <Axman6> :t reads
18:31:46 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:31:54 <joe6> i am trying to understand this code, but having trouble understanding what readOne does
18:31:58 <joe6> http://hpaste.org/paste/43012/case#p43015
18:32:06 <Axman6> > reads "123abc" :: [(Int,String)]
18:32:06 <lambdabot>   [(123,"abc")]
18:32:10 <alpounet> > reads "123aaaa" :: [(Int, String)]
18:32:11 <lambdabot>   [(123,"aaaa")]
18:32:11 <alpounet> arg
18:32:15 <Axman6> > reads "abc123" :: [(Int,String)]
18:32:16 <lambdabot>   []
18:32:20 <mikeg> @type Reads
18:32:20 <lambdabot> Not in scope: data constructor `Reads'
18:32:23 <ezyang> reads reads as much of the string as possible, and then returns what's left. 
18:32:30 <alpounet> @src ReadS
18:32:30 <lambdabot> Source not found. Do you think like you type?
18:32:43 <joe6> ezyang: cool thanks.
18:36:22 <conal> joe6: and the listness of the result allows 0 or more parsings and backtracking.
18:36:53 <conal> make that "allows 0 or more parsings. also backtracking."
18:36:57 <Axman6> doesn't it only ever return one result though?
18:37:02 <joe6> conal: thanks.
18:37:02 <alpounet> > reads "123 456abc" :: [(Int, String)]
18:37:03 <lambdabot>   [(123," 456abc")]
18:37:04 <ddarius> @google how to turn failure into a list of successes
18:37:06 <lambdabot> http://www.amazon.com/How-Turn-Failure-Into-Success/dp/0134354389
18:37:17 <ddarius> Bah
18:37:18 <Axman6> > maxBound :: Int
18:37:19 <lambdabot>   9223372036854775807
18:37:28 <ddarius> @google "how to turn failure into a list of successes"
18:37:32 <lambdabot> https://www.student.chalmers.se/hp/hp/?hp_id=6548&hp_view=listOldNews&frmt_id=25854
18:37:34 <conal> i was just looking at that paper, wondering whether to recommend
18:37:44 <Axman6> > reads (show (maxBound :: Int) ++ "123") :: [(Int,String)]
18:37:46 <lambdabot>   [(-877,"")]
18:37:49 <ddarius> I don't actually know if I've ever read it.
18:38:00 <ddarius> It just has a typically great Wadler title.
18:38:07 <conal> yah
18:38:09 <conal> yeah
18:47:55 <copumpkin> fucking hell
18:48:05 <ddarius> Damn straight!
18:48:21 <copumpkin> c2hs refuses to work if there's a variadic function anywhere
18:48:24 * djahandarie doesn't question
18:48:43 <ddarius> copumpkin: Just use hsc2hs.  It's lower tech.
18:48:56 <ddarius> That said.  That limitation is odd.
18:49:35 <copumpkin> well, in the type signature
18:49:53 <copumpkin> I'm binding to a function that takes a function pointer to a variadic function
18:50:04 <copumpkin> and was just going to make a "void ptr"
18:50:42 <ddarius> Okay, that's more reasonable.
18:51:12 <ddarius> You should be able to lie to c2hs in a way that doesn't really matter, one way or another.
18:51:24 <copumpkin> that's what I was hoping to do
18:51:29 <copumpkin> but it won't let me lie
18:52:03 <ezyang> RememberL c2hs doesn't stop you from righting the import yourself. 
18:52:48 <ddarius> I tend to prefer the lower tech stuff for smaller-scale bindings.
18:53:00 <ddarius> The hi-tech stuff mostly just adds automation.
18:53:05 <ddarius> I usually just use the FFI directly.
18:53:18 <copumpkin> well, I have an enum and a huge struct
18:54:08 <copumpkin> I don't want to rely on shady sizeofs and alignments for struct accesses, and the enum elements aren't necessarily constant
18:54:29 <ddarius> 1) Do you actually need to manipulate the struct much? 2) hsc2hs would be more than adequate for that.
18:55:17 <copumpkin> I don't need to manipulate it much, but I need to be able to get sizeof it, and there are at least a couple of fields I need to change in it (and of course there's no sort of accessor function for it in the API I'm binding to)
18:55:39 <ddarius> copumpkin: Then you could just write some C stubs to do that for you, or just use hsc2hs.
18:55:50 <copumpkin> maybe I'll just write c stubs
18:55:58 <copumpkin> I'm getting annoyed :P
18:56:07 <ddarius> (or just do the shady hand calculation which I've done but don't recommend for anything you'd give to anybody else.)
18:56:24 <ezyang> bindings-DSL might be interesting 
18:56:32 <ezyang> it's basically a huge C preprocessor hack. 
18:56:48 <ddarius> ezyang: Have you looked into how hsc2hs is implemented?
18:57:08 <ezyang> no, but it gets packed fields wrong >:-( 
18:57:17 <ezyang> (or maybe that was c2hs) 
18:58:12 <ddarius> It shouldn't.  The hsc2hs approach further underscores some of the strange Perl-Haskell connection.  The approach is very much "What would a Perl programmer do?"
18:58:41 <ezyang> heh 
19:03:43 <Philippa> ddarius: a Perl coder would try "fix error", no?
19:09:59 * ddarius thinks he's actually doing all his clockwise purls on the wrong stitch.
19:17:48 * ddarius should probably start a blog...
19:18:20 <AnAdorableNick>  \la
19:18:22 <AnAdorableNick> [A -cl
19:18:37 <copumpkin> ddarius: yes!
19:20:24 <dolio> NOOOOO!
19:21:42 <monochrom> use reddit as your blog experimentally
19:21:48 <ddarius> Screw reddit.
19:22:30 <ddarius> Don't worry dolio.  Every now and then this idea seems vaguely reasonable to me, but it hasn't happened yet for the past four or five years (or the 21 before those.)
19:22:38 <djahandarie> Use twitter as your blog
19:22:48 <dolio> Well, I figured the chances weren't great.
19:23:23 <mm_freak> "fix error" lol
19:23:36 <mm_freak> the worst error possible
19:23:42 <mm_freak> > fix error
19:23:43 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:24:26 <copumpkin> dolio should blog as well
19:24:39 <dolio> I just post comments to other people's blogs.
19:24:40 <copumpkin> hmm, on second thought, if both ddarius and dolio blogged at once, the universe might end
19:24:49 <ddarius> djahandarie: Twitter is worse than reddit.
19:24:59 <MagusOTB> Is there an inverse of take? i.e. I want all BUT the first n ellements of a list?
19:25:01 <djahandarie> Use IRC as your blog
19:25:07 <copumpkin> ddarius: just think how trendy you could be
19:25:17 <Saizan> MagusOTB: drop
19:25:24 * copumpkin joins #ddarius, ddarius' personal blannel
19:25:24 <MagusOTB> Saizan: Awesome, thanks
19:25:25 <ddarius> djahandarie: I mostly use other blogs as my blog, and I guess IRC as my twitter.
19:25:58 <djahandarie> Still stuck in the 90s I see
19:26:08 <djahandarie> Go far back enough and I guess academic papers == blogs?
19:26:25 <mm_freak> copumpkin: project ddarius?
19:26:37 <copumpkin> mm_freak: yeah
19:26:52 <copumpkin> that shit's official
19:26:57 <monochrom> blannel? freudian slip?
19:27:03 <ddarius> Anyway, I was just reflecting on the parallels of the lambda cube and a somewhat side aspect Paul Taylor's abstract stone duality.
19:27:22 <copumpkin> monochrom: nah, a blogchannel!
19:27:30 <monochrom> OK!
19:28:54 <monochrom> go back far enough and http://www.cs.utexas.edu/users/EWD/ was Dijkstra's blog
19:29:16 <Axman6> MagusOTB: you'd do well to familliarise yourself with the standard prelude of haskell
19:29:29 <ddarius> Namely, that there are usually bunches of ways of forming terms from other terms and formulae from other formulae, and also bunches of ways of forming formulae from terms, but the constructs to form terms from formula are less common/formalized/studied.
19:30:09 <ddarius> One example would be set comprehension, which turns a formula into a set.  Another would be definition by description which turns a formula into the number that satisfies that formula.
19:31:26 <ddarius> (Adjunctions abound, including an intriguing relation to the continuation monad.)
19:33:27 <Saizan> does that have anything to do with kleene's realizability?
19:34:20 <MagusOTB> Axman6: I'm doing so. I just started learning it like, yesterday. I can never remember things unless I use them though, and prelude.hs doesn't have an index of functions by what they do.
19:34:30 <ddarius> Saizan: I'd probably say more "no" than "yes."
19:37:42 <Saizan> fair enough, i don't know much about it, but it was one of the obscure (to me) references in the Synthetic Domain Theory papers
19:39:44 <john_r_watson> >pl (\x -> x `mod` 5 /= 0 && x `mod` 2 /= 0)
19:40:01 <john_r_watson> @pl (\x -> x `mod` 5 /= 0 && x `mod` 2 /= 0)
19:40:01 <lambdabot> ap ((&&) . (0 /=) . (`mod` 5)) ((0 /=) . (`mod` 2))
19:40:40 <john_r_watson> > liftM2 (&&) ((0 /=) . (`mod` 5)) ((0 /=) . (`mod` 2))
19:40:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
19:40:41 <lambdabot>    arising fro...
19:40:48 <john_r_watson> > liftM2 (&&) ((0 /=) . (`mod` 5)) ((0 /=) . (`mod` 2)) 10
19:40:50 <lambdabot>   False
19:41:04 <john_r_watson> > ap ((&&) . (0 /=) . (`mod` 5)) ((0 /=) . (`mod` 2)) 10
19:41:06 <lambdabot>   False
19:41:32 <john_r_watson> anyone see a way to get the shared (0 /=) out of there?
19:41:40 <john_r_watson> I assume if lambdabot can't do it....
19:42:23 <Saizan> liftM2 ((&&) `on` (0 /=)) ... ...
19:43:52 <john_r_watson> :t on
19:43:52 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:44:06 <john_r_watson> cool... on is news to me
19:44:11 <john_r_watson> @where on
19:44:12 <lambdabot> I know nothing about on.
19:44:14 <john_r_watson> @src on
19:44:14 <lambdabot> (*) `on` f = \x y -> f x * f y
19:45:29 <john_r_watson> Saizan: what package is `on` from?
19:46:16 <Saizan> the Data.Function module i think
19:46:34 <john_r_watson> indeed
19:46:50 <john_r_watson> isn't there a function that asks lambdabot for that?
19:46:53 <john_r_watson> I thought it was where
19:46:56 <john_r_watson> :where on
19:48:07 <ddarius> @index on
19:48:07 <lambdabot> bzzt
19:48:09 <ddarius> @hoogle on
19:48:09 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:48:09 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
19:48:09 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
19:48:19 <ddarius> Hoogle usually works better.
19:50:00 <john_r_watson> ddarius: thanks
19:50:23 <john_r_watson> [x | x <- [3..1000], liftM2 ((&&) `on` (0 /=)) (`mod` 2) (`mod` 5) x] vs
19:50:23 <john_r_watson> [x | x <- [3..1000], x `mod` 5 /= 0 && x `mod` 2 /= 0]
19:50:40 <john_r_watson> ... point-free doesn't seem worth it here... so sda
19:50:41 <john_r_watson> *sda
19:50:48 <john_r_watson> sad
19:54:01 <Kaidelong> > let subst f g x = f x (g x) in flip filter [3..1000] $ (/= 0) . subst ((*) . (`mod` 2)) (`mod` 5)
19:54:03 <lambdabot>   [3,7,9,11,13,17,19,21,23,27,29,31,33,37,39,41,43,47,49,51,53,57,59,61,63,67...
19:55:09 <ion> > (do a <- (+1); return a) 42 -- What module defines a monad instance for functions to make this work?
19:55:10 <lambdabot>   43
19:55:29 <Kaidelong> @instances-importing Monad
19:55:30 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
19:55:37 <Kaidelong> that doesn't help
19:55:39 <Kaidelong> mmm
19:55:55 <Kaidelong> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-Instances.html perhaps?
19:56:01 <Kaidelong> yes indeed
19:56:07 <ion> Thanks
19:56:16 <mm_freak> ion: the prelude does that already
19:56:28 <mm_freak> as far as i've seen, at least
19:56:44 <ion> mm_freak: My ghci says “No instance for (Monad ((->) a))” until i import Control.Monad.Instances.
19:56:49 <Kaidelong> oh, well what you did there would have been the identity monad anyway
19:57:24 <mm_freak> ion: ah, i see now, why
19:57:33 <ion> Yes, that was just a simplified example of what was going on with the liftM2 in the previous discussion.
19:57:38 <mm_freak> i include Control.Applicative in virtually all modules i write
19:57:44 <mm_freak> which defines the instance
19:58:58 <Apocalisp_> What's a simple Applicative which is not a monad?
19:59:09 <mm_freak> Apocalisp_: ZipList
19:59:23 <Apocalisp_> good one
20:00:45 <mm_freak> but, well, you can also just use zipWith
20:00:58 <mm_freak> saves some wrapping around
20:01:27 <mm_freak> > zipWith (+) [1..5] [10..14]
20:01:28 <lambdabot>   [11,13,15,17,19]
20:01:45 <mm_freak> > getZipList $ liftA2 (+) (ZipList [1..5]) (ZipList [10..14])
20:01:46 <lambdabot>   [11,13,15,17,19]
20:05:28 <sunscreen> names
20:07:29 <kevincsd> Hi there! How can I create an action that does nothing?
20:07:51 <mm_freak> kevincsd: return ()
20:07:55 <Axman6> return ()?
20:08:08 <Philippa> return undefined, if you're feeling nasty
20:08:26 <Philippa> or even return (error "WTF?!")
20:08:40 <mm_freak> well, that really depends on what "action" and "nothing" mean
20:08:46 <kevincsd> I see. Thank you guys!
20:08:46 <mm_freak> 'id' could also be valid
20:08:51 <kevincsd> return() is what i want..
20:08:59 <mm_freak> kevincsd: return ()
20:09:13 <mm_freak> 'return' is a function with one argument, namely ()
20:09:17 <Philippa> mm_freak: not assuming "action" was used intentionally
20:09:50 <mm_freak> actually 'return' can take up to two arguments…
20:09:53 <mm_freak> > return 3 4
20:09:54 <lambdabot>   3
20:10:15 <cdsmithus> mm_freak: That's evil
20:10:34 <c_wraith> > return 2 3 4
20:10:35 <ddarius> > return 3 4 5 6 7 8
20:10:35 <lambdabot>   2
20:10:36 <lambdabot>   3
20:11:38 <mm_freak> > return return (return 3) 4
20:11:39 <lambdabot>   Ambiguous type variable `m' in the constraint:
20:11:39 <lambdabot>    `GHC.Base.Monad m'
20:11:39 <lambdabot>      a...
20:12:44 <mm_freak> :t return return (return 3)
20:12:45 <lambdabot>     Ambiguous type variable `m' in the constraint:
20:12:45 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:15-22
20:12:46 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
20:12:54 <mm_freak> :t return return return 3
20:12:55 <lambdabot>     Ambiguous type variable `m' in the constraint:
20:12:55 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:14-19
20:12:55 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
20:13:13 <mm_freak> > return return 3 4
20:13:14 <lambdabot>   No instance for (GHC.Show.Show (m a))
20:13:14 <lambdabot>    arising from a use of `M3027944906...
20:13:42 <cdsmithus> A use of what?!?
20:13:45 <mm_freak> ok, i have enough
20:13:51 <mm_freak> > fix return
20:13:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
20:14:12 <mm_freak> ok, now i see, where we need equirecursive types =P
20:18:04 <mm_freak> btw, do we really need that backslash in lambda expressions?  after all, the (->) abstraction could be an ordinary operator with a very low priority
20:18:59 <ddarius> C# doesn't have it, but then C#'s syntax is, otherwise, much more... delimited.
20:19:47 <mm_freak> ddarius: that's C#, but do we really need it in haskell?
20:20:02 <mm_freak> C# has C-style syntax after all
20:20:52 <mm_freak> if (->) has lower priority than ($), i don't see a problem
20:21:25 <sunscreen> It would be still somehow special
20:21:29 <Draconx|Laptop> mm_freak, what would the type of (->) be?
20:21:39 <cdsmithus> mm_freak: So what about: case foo of Just a -> b -> a^2
20:21:51 <mm_freak> sure it would be special
20:22:12 <mm_freak> cdsmithus: good point
20:22:18 <cdsmithus> Oh, I guess that only has only one syntactically valid parse, since -> can't happen in a pattern
20:22:28 <ddarius> cdsmithus: It can with view patters.
20:22:32 <cdsmithus> Oh, true
20:22:50 <Obvious> mm_freak, you'd have to explicitly curry everything then.
20:22:54 <sunscreen> but it is still not \a -> b = \b -> b
20:23:02 <mm_freak> Draconx|Laptop: it's a data constructor
20:23:03 <sunscreen> or a -> b = b -> b
20:23:40 <sunscreen> afterall the "\a" refers to the name of the variable "a"
20:23:45 <mm_freak> Obvious: to curry?  you mean to put into parentheses?
20:23:51 <cdsmithus> mm_freak: It's certainly not a data constructor... it's first argument is a pattern, not an expression!  So it wouldn't be an operator anyway; you'd just be removing a token from the syntax
20:24:02 <sunscreen> and "a" to the object it's bound to.
20:24:05 <Obvious> i mean to say x -> y -> x*y vs \x y -> x*y
20:25:11 <ddarius> I believe that's the syntax Barry Jay uses in some of his pattern calculi.
20:25:18 <mm_freak> cdsmithus: (->) :: Pattern### a -> Expr### b -> a -> b
20:25:22 <mm_freak> something like that?
20:25:39 <ddarius> lambdaProlog also has a nice, if at first extremely strange lambda syntax.
20:26:03 <cdsmithus> mm_freak: I guess.  You might (or might not) want to allow multiple patterns on the left.  Then it's even less like an operator
20:26:33 <mm_freak> Obvious: you have a pattern on the left side
20:27:42 <mm_freak> of course it's not a normal operator, but the type-level (->) isn't either
20:27:47 <cdsmithus> mm_freak: If you allow stuff like (x y -> x*y), then I think it's headed for a mess.  If you make people write (x -> y -> x*y), then I think you might be able to get a sensible alternative syntax.... but then it's not shorter in the multiple argument case.
20:28:34 <mm_freak> cdsmithus: you're right…  then my pseudo-type above wouldn't apply anymore, too
20:28:43 <mm_freak> unless you use some type system hackery
20:29:15 <cdsmithus> You're changing syntax and making up fake type notation; you've already gone beyond type system hackery. :)
20:30:10 <mm_freak> yeah
20:30:40 <ddarius> The fake type notation is completely unnecessary.
20:30:56 <mm_freak> i just thought, if type-level (->) has an ordinary kind, why can't value-level (->) have an ordinary type?
20:31:41 <ddarius> Because the type level (->) is a totally different thing than the syntax (->) which isn't a value at all.
20:32:22 <mm_freak> true
20:32:23 <cdsmithus> mm_freak: I don't necessarily hate the notation you came up with.  It does resolve the ugly inconsistency between case patterns and lambda patterns.  But yeah, as ddarius said, you can't really make -> an operator in any real sense.
20:32:53 <mm_freak> i think, 'type' is the type-level idea of a value-level lambda
20:33:28 <ddarius> cdsmithus: "operator" is as syntactic concept.  It certainly could be made into an operator.  It can't be made into a function.
20:33:47 <ddarius> mm_freak: I have no idea why you would think that.
20:33:50 <mm_freak> yeah, it can't be turned into a value constructor (easily)
20:34:12 <mm_freak> ddarius: because if haskell were less limited, you could have type-level functions with 'type'
20:34:51 <cdsmithus> mm_freak: You already can have type-level functions in GHC... they are type families.
20:34:51 <mm_freak> but it's more like an equation rather than a lambda
20:34:55 <ddarius> However, in dependently typed languages, you might write the type of \a :: A -> b, as Πt::A.T
20:35:25 <mm_freak> cdsmithus: you can with 'type', too, but they are not first class
20:35:29 <ddarius> mm_freak: Oh, you meant type synonyms.  Then yes, they are a very restricted case of type level lambdas.
20:36:39 <ddarius> If partially applied type synonyms were allowed to be used willy-nilly, you'd effectively have type level "lambdas."
20:40:17 <mm_freak> yeah…  that would be useful from time to time
20:41:16 <ddarius> It would be useful quite often.  It would also require the type checker to do higher order unification which is undecidable.
20:46:38 <ddarius> It would, however, be quite possible to restrict the lambdas so that the compiler only has to do higher order pattern unification which is decidable.
20:46:53 <mrd> @seen dcoutts 
20:46:53 <preflex>  dcoutts was last seen on #haskell 2 days, 13 hours, 47 minutes and 51 seconds ago, saying: roconnor_: which for distro script is the method I would recommend. Puts you in full control.
20:46:53 <lambdabot> Unknown command, try @list
20:58:41 * hackagebot ghc-mod 0.5.2 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.5.2 (KazuYamamoto)
21:02:24 <augur> you know
21:02:35 <augur> one of the most useful things about functional languages like haskell and scheme and the like
21:03:27 <augur> is the ability to do stuff like this: ((if t > <) a b) instead of (if t (> a b) (< a b))
21:25:43 <monochrom> heh, happy haskell programming on emacs
21:26:03 <copumpkin> the c2hs documentation is pretty bad
21:26:12 <copumpkin> there's lots of it, but it isn't very informative
21:26:30 <aristid> :t \t -> if t then (<) else (>)
21:26:31 <lambdabot> forall a. (Ord a) => Bool -> a -> a -> Bool
21:26:42 <Maxdamantus> (t? function(x, y){ return x < y; } : function(x, y){ return x > y; })(a, b)
21:26:54 <aristid> :t \t -> if t then id else flip
21:26:55 <lambdabot> forall a b. Bool -> (a -> a -> b) -> a -> a -> b
21:27:22 * Maxdamantus wishes non-assignment operators in JS were functions :\
21:27:45 <aristid> Maxdamantus: i wish if in haskell was a function!
21:28:51 <Maxdamantus> I'd imagine that'd be useful sometimes.
21:29:18 <aristid> @let if' t a b = if t then a else b
21:29:19 <lambdabot>  Defined.
21:29:22 <aristid> :t if'
21:29:23 <lambdabot> forall t. Bool -> t -> t -> t
21:29:37 <aristid> :t flip .: if'
21:29:38 <lambdabot> forall a b. Bool -> (a -> b) -> a -> (a -> b) -> b
21:29:42 <monochrom> @let if' t a b = if t then a else b
21:29:43 <lambdabot>  <local>:2:0:
21:29:43 <lambdabot>      Warning: Pattern match(es) are overlapped
21:29:43 <lambdabot>               In...
21:29:48 <monochrom> heh
21:29:49 <aristid> :t flip . if'
21:29:50 <lambdabot> forall b. Bool -> b -> b -> b
21:29:58 <qfr-> <aristid> Maxdamantus: i wish if in haskell was a function!
21:30:05 <qfr-> Are you annoyed by the syntactical sugar?
21:30:12 <qfr-> The if then else stuff?
21:30:17 <qfr-> vs. a ternary function?
21:30:30 <qfr-> You want something more like the Lisp #'if?
21:30:31 <aristid> qfr-: i can't use things like flip or foldr on it if it's not a function
21:30:38 <Maxdamantus> Is it counted as "sugar"?
21:30:50 <qfr-> Right, doesn't Haskell provide a function for that already?
21:30:59 * Maxdamantus wonders ..
21:31:00 <aristid> Maxdamantus: everything that is not pure typed lambda calculus is sugar
21:31:06 <qfr-> aristid maybe there should be an (if) hm
21:31:23 <Maxdamantus> > let a >> b = a + b in do { 5; 4 }
21:31:24 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
21:31:24 <lambdabot>    arising from a u...
21:31:35 <aristid> qfr-: no, haskell by default does not provide an if function. but you can easily define one, as monochrom and I did above (if')
21:31:39 <monochrom> not that easily
21:31:53 <Maxdamantus> O_o
21:32:06 <aristid> Maxdamantus: you need some extension i think
21:32:11 <aristid> forgot the name
21:32:17 <Maxdamantus> > let a >> b = a + b in 5 >> 4
21:32:18 <lambdabot>   9
21:32:42 <Maxdamantus> Oh, that's the normal error for using a non-monad.
21:32:57 <qfr-> >> already exists though
21:33:11 <aristid> sure. you can redefine it locally with let
21:33:17 <monochrom> haskell is not that easy to hijack
21:33:35 <qfr-> <Maxdamantus> > let a >> b = a + b in do { 5; 4 }
21:33:36 <qfr-> Haha
21:33:50 <qfr-> It would be interesting if it worked  like that
21:34:23 <copumpkin> it would, if you have NoImplicitPrelude
21:34:37 <copumpkin> I think?
21:34:46 * copumpkin hasn't tried, but assumed it was just syntactic
21:34:51 * Maxdamantus doesn't see why.
21:35:08 <qfr-> Interesting, but then again I'm just a hello worlder
21:35:09 <Maxdamantus> It overrides the >> fine, but that's limited to the scope of that expression.
21:35:34 <copumpkin> did it override it?
21:35:39 <copumpkin> > do { 5; 4 }
21:35:39 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
21:35:40 <lambdabot>    arising from a u...
21:35:46 <Maxdamantus> If you imagine the do construct was defined outside of that expression .. and imagine it followed the usual scoping rules (globally) it won't work. 
21:36:22 <ddarius> Without NoImplicitPrelude, do desugars into Prelude.>> and such.
21:36:23 <Maxdamantus> > let a >> b = a / b in let a >> b = a + b in 5 >> 4
21:36:24 <lambdabot>   9
21:36:52 <Maxdamantus> > let a >> b = a / b in let a / b = a + b in 5 >> 4
21:36:53 <lambdabot>   1.25
21:38:47 <Maxdamantus> So you could import something as Prelude and override the meaning of do?
21:39:21 <Maxdamantus> Wait, "without" .. so what does it do with NoImplicitPrelude?
21:41:26 <aristid> Maxdamantus: if in doubt, read the GHC source
21:42:21 <ddarius> Maxdamantus: It uses just (>>)
21:42:47 <Maxdamantus> Ah.
21:42:58 <c_wraith> Didn't that extension get...  flexible-ized in GHC 7?  something about RebindableSyntax?
21:43:19 <aristid> Prelude> let a >> b = a + b in do 4 ; 5
21:43:19 <aristid> 9
21:43:21 <aristid> it works!
21:43:28 <aristid> fascinating
21:43:28 * ddarius is actually more used to the commandline flag.
21:44:10 <ddarius> NoImplicitPrelude (although it wasn't called that in those days) was one of the things not enabled by -fglasgow-exts.
21:45:23 <qfr-> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Monad are the monad laws actually defined like that in the base source package and ghc actually parses them like that? Or is it an abstract notion which is enforced by other means?
21:45:40 <copumpkin> it's an abstract notion that you're expected to respect
21:45:46 <copumpkin> no mechanical enforcement in haskell
21:45:51 <qfr-> Oh, so I could even break it
21:46:11 <qfr-> copumpkin it can't be checked because code equivalency is undecidable?
21:46:16 <qfr-> And could only be checked heuristically?
21:46:49 <qfr-> Although I suppose in a heavily restricted computational system which e.g. does not have jumps it would be decidable
21:46:54 <copumpkin> haskell simply doesn't have a mechanism for specifying that stuff
21:47:00 <qfr-> However, in this context we generally assume at least a Turing machine?
21:47:03 <copumpkin> other languages might have proofs
21:47:06 <Maxdamantus> NoImplicitPrelude doesn't sound like an extension.
21:47:15 <copumpkin> it's an intension?
21:47:45 * Maxdamantus would think for something to be an extension, valid code that already works would work the same.
21:47:48 <qfr-> Also, why doesn't anybody even mention my new hostname?
21:48:01 <ddarius> I'm pretty sure let (>>) = (+) in do 4; 5 is not legal Haskell 98.
21:48:02 <copumpkin> whois qfr- 
21:48:10 <copumpkin> qfr-: excellent
21:48:10 * qfr- is like a superficial woman who expects everybody to comment on her new haircut
21:48:15 <qfr-> Thank you
21:48:30 <Maxdamantus> Hm.
21:48:59 <Maxdamantus> Doesn't Haskell 98 have that monomorphism thing?
21:49:09 <Maxdamantus> > let (>>) = (+) in 5 >> 4
21:49:10 <lambdabot>   9
21:49:15 <Maxdamantus> Oh.
21:49:15 <ddarius> Yes, as does Haskell 2010.
21:49:16 <Maxdamantus> O_o
21:49:25 * Maxdamantus must've forgotten what it was.
21:49:32 <ddarius> Probably.
21:49:52 <aristid> Maxdamantus: it only kicks in if you need the polymorphism
21:50:14 <Maxdamantus> > let (>>) = (+) in (5 >> 4, 5.0 >> 4.0)
21:50:15 <lambdabot>   (9,9.0)
21:50:20 * Maxdamantus shrugs.
21:51:29 <qfr-> Do you think that Haskell return should be renamed? Real World Haskell criticises the name because it doesn't really have anything to do with returning a value from a function (for which you do not require a return statement), it is very different from the notion of the return statement in predominantly imperative languages where it's not even a first class object
21:51:52 <qfr-> I've heard this criticism on freenode before
21:51:59 <qfr-> Possibly inspired by the same source
21:52:20 <aristid> > let (>>) = (+) in ((5 :: Integer) >> 4, 5.0 >> 4.0)
21:52:20 <ddarius> Real World Haskell isn't that old.
21:52:21 <lambdabot>   (9,9.0)
21:52:29 <c_wraith> well.  It's a very misleading name, to people coming from other languages.
21:52:39 <aristid> Maxdamantus: in my ghci, that expression breaks. seems like lambdabot has NoMonomorphismRestriction enabled
21:52:48 <qfr-> It sounds like the author would rather have it named "inject"
21:53:09 <ddarius> Clearly it should be named η.
21:53:28 <Maxdamantus> Yeah, and the previous one in my ghci gets a (Float, Float)
21:53:45 <qfr-> Haha, I wanted to make an esoteric language which heavily uses UTF-8 symbols for native constructs
21:53:46 <ddarius> It should be (Double, Double).
21:53:57 <qfr-> Something like APL united with a primitive Lisp
21:54:01 <Maxdamantus> Yeah, that.
21:54:19 <ddarius> qfr-: return isn't a native construct, and η isn't a particularly symboly symbol.
21:54:37 <ddarius> > let η = return in do x <- [1,2]; η x
21:54:38 <lambdabot>   [1,2]
21:55:08 <qfr-> I wasn't talking about return
21:57:01 <ddarius> :t let µ = join; η = return; (∘) = (.) in (µ ∘ η, µ ∘ fmap η, µ ∘ µ, µ ∘ fmap µ)
21:57:02 <lambdabot> <no location info>: not an expression: `let'
21:57:19 <qfr-> Haha
21:57:22 <qfr-> That went well
21:57:49 <aristid> qfr-: the lack of good input methods for unicode makes that a bit of an impractical option
21:58:03 <aristid> ddarius: no symbol for fmap?
21:58:10 <qfr-> aristid it isn't supposed to become a successful mainstream language
21:58:15 <ddarius> aristid: Just require your users to use specialized keyboards.
21:58:36 <aristid> @quote avoid.*success
21:58:36 <lambdabot> dougalstanton says: Haskell: It may be avoiding success, but it's certainly quite popular.
21:58:38 <ddarius> aristid: The typical "symbol" is the name of the functor, which is usually uppercase (and would also be capitalized in Haskell).
21:58:40 <qfr-> As I said, just an esoteric fun language
21:58:58 <aristid> qfr-: much like haskell :D
21:59:04 <qfr-> Haha
21:59:12 <cdsmithus> @quote avoid.*success.*costs
21:59:13 <lambdabot> Baughn says: "<dpratt71> so I read somewhere that the unofficial  motto of Haskell was \"avoid success at all costs\"...<Baughn> dpratt71: Yeah. We failed."
21:59:22 <ion> \"?
21:59:24 <qfr-> @quote SPJ
21:59:25 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
21:59:37 <ion> \p\h\p\?\ \:\-\P
21:59:51 <qfr-> |php? :-P|?
21:59:56 <qfr-> Common Lisp?
22:00:47 <aristid> ion: probably somebody thought @remember needs escaping
22:00:53 <qfr-> We should start a channel for people who obsessively develop new programming languages, as a sport
22:01:11 <ion> aristid: Yes, it becomes more secure that way, as we’ve learned from the \p\h\p\ \f\o\l\k\s.
22:01:36 <aristid> ion: i'm not that particularly familiar with php, sorry :P
22:01:39 <qfr-> aristid: Actually it's because lambdabot runs on PHP and uses magic_quotes = on in php.ini
22:01:45 <qfr-> aristid: How ignorant!
22:02:00 <qfr-> PHP was my second programming language, I think
22:02:07 <ion> aristid: You might find this hilarious: http://en.wikipedia.org/wiki/Magic_quotes
22:02:45 <ddarius> qfr-: I could paraphrase Dijkstra.
22:02:54 <aristid> ion: haha
22:02:57 <Kaidelong> the first thing I thought looking at that article was "counterproductive"
22:03:39 <qfr-> Kaidelong you didn't know about it either? :p
22:03:45 <qfr-> Just wait until you get to know about globals
22:03:54 <Veinor> Single quotes, double quotes, backslashes and null characters in all user-supplied data all have a backslash prepended to them before being passed to the script in the $_GET, $_REQUEST, $_POST and $_COOKIE global variables.
22:03:59 <Veinor> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
22:04:32 <ion> Just imagine someone proposing making Haskell do that to all user input.
22:05:02 <Kaidelong> the idea of those global variables is frightening in itself
22:05:04 <qfr-> How would that even work :/
22:05:36 <Kaidelong> it reminds me a little bit of Perl
22:05:43 <ion> qfr: One could make the low-level functions that read from file descriptors do that transparently.
22:05:47 <qfr-> PHP is like the opposite of security
22:05:55 <Kaidelong> actually, probably because Perl is the closest thing to PHP I have ever used
22:06:06 <qfr-> Kaidelong yes it borrowed a lot of stuff from Perl but Perl is actually more sane than PHP still
22:06:23 <Kaidelong> I'm not dissin' Perl, Perl is alright at what it does
22:06:33 <ion> Perl is *considerably* saner than PHP.
22:06:36 <Kaidelong> although I've noticed myself actually writing scripts in Haskell
22:06:50 <ion> It even has lambdas, which PHP only added recently AFAIU.
22:07:14 <ddarius> Veinor: The best line is: "The PHP documentation points out several pitfalls and recommends that, despite being enabled by default, they should be disabled."
22:07:27 <qfr-> The context dependent use of variables also lead to lots of unexpected results and security holes. In PHP the following statement yields true: 12345 == '12345' && "1000000000000000000000000000000000000000" == "1000000000000000000000000000000000000001" && true == 'true' && true == '7d' && true == '7 dwarves' && 7 == 'seven' && strpos('abc', 'a') == false. It also lead to non-sense like the ===/!== operator set which you are now forced to use all the time becau
22:07:27 <qfr-> se it might erroneously return true/false otherwise.
22:07:28 <ion> And syntactic sugar for adding lambdas as function parameters with less syntactic noise.
22:07:45 <qfr-> ddarius: Are magic quotes still enabled by default?
22:07:54 <qfr-> Globals are deactivated by default now though aren't they?
22:08:05 <qfr-> ion: Hahaha in PHP you add lambdas as _strings_
22:08:23 <qfr-> I bet you achieve closures by evaluating stuff inside the string...
22:08:24 <Veinor> 'before qfr-wait, what?
22:08:34 <Veinor>  function ($v) { return $v > 2; }
22:08:34 <Kaidelong> I need to find that table again
22:08:37 <Veinor> that's a php lambda
22:08:49 <Kaidelong> http://imgur.com/7unV7
22:08:51 <Kaidelong> here we go
22:08:55 <Veinor> nothing string-y about it
22:08:56 <ion> qfr: Such strings don’t carry variables from the scope with them.
22:08:56 <qfr-> Kaidelong yeah such a gem
22:09:02 <qfr-> http://i.imgur.com/7unV7.png
22:09:15 <Veinor> at least it's symmetric
22:10:36 <sunscreen> > let (>>) = zipWith (+) in do { [5]; [4] }
22:10:37 <lambdabot>   [4]
22:11:03 <kuffaar> ion: You mean the string lambdas?
22:11:03 * ion tries to remember his Perl from the old days… % perl -Mstrict -lwe 'sub foo (&) { shift->(42); }; foo { print "@_" }'
22:11:06 <ion> 42
22:11:53 <kuffaar> http://php.net/manual/en/function.create-function.php
22:11:54 <ion> kuffaar: The kind of string “lambdas” qfr mentioned, yes.
22:12:07 <kuffaar> I am qft- :/
22:12:12 <sunscreen> > let (>>) = zipWith (+) in [5] >> [4]
22:12:13 <lambdabot>   [9]
22:12:25 <kuffaar> ion yes I think you are supposed to add them manually by inserting them into the string :)
22:12:25 <ion> Hah, sorry. I missed the nick change.
22:12:29 <kuffaar> Manual closures!
22:12:54 <Kaidelong> I remember finding my Perl experience to be very "write-only"
22:13:06 <Kaidelong> I'd consult a perl book, get something done, and never touch it again
22:13:21 <Kaidelong> the perl scripts my boss back then wrote looked like they were generated in the same manner
22:13:40 <Maxdamantus> and the unpredictable syntax and operators.
22:13:47 <Maxdamantus> Eh, scrolled up.
22:14:04 <aristid> Kaidelong: you don't HAVE to use it that way.
22:14:11 <Maxdamantus> $a = "a"; $a = $a + 1;
22:14:14 <Maxdamantus> $a = "a"; $a++;
22:14:19 <Kaidelong> I am sure there is a saner way to write Perl than the way most people do it
22:14:44 <aristid> Kaidelong: i also totally love nesting data structures in perl. great fun
22:15:36 <Maxdamantus> btw, since the anonymous functions PHP has had .. almost closures.
22:15:52 <CindyLinz> since PHP 5.3
22:16:04 <Maxdamantus> You can emulate them, something like: function with (&$a) (){ .. }
22:16:08 <Maxdamantus> No, that won't be it.
22:17:19 <CindyLinz> php..    $lambda = function($a, $b, $c) use ($d, $e, $f) { ... }
22:17:27 <Maxdamantus> Ah.
22:18:35 <Maxdamantus> Don't you need &$d for it to refer to the same variable? or is this coming from my vague knowledge of C++0x's lambdas?
22:18:41 <RayNbow`TU> @pl \f -> interact (unlines.f.lines)
22:18:41 <lambdabot> interact . (unlines .) . (. lines)
22:18:47 <Maxdamantus> (though again, not really lambdas)
22:19:03 <kuffaar> The & part passes a reference, doesn't it?
22:19:04 <CindyLinz> function(&$a, &$b) use (&$d, &$e) { ... }  is also work
22:19:10 <ion> Perl has some interesting things you can do with its scoping. For instance, the $n variable in this example will only be visible within the anonymous function assigned to $counter: % perl -Mstrict -lwe 'my $counter = do { my $n = 0; sub { $n++ } }; print "@{[$counter->(), $counter->(), $counter->()]}";'
22:19:16 <ion> 0 1 2
22:19:34 <kuffaar> So it refers to the same binding outside the function?
22:19:46 <ion> Yes, being a real closure.
22:19:59 <aristid> :t let (f ~> h) g = f . g . h in interact . (unlines ~> lines)
22:20:00 <lambdabot> ([String] -> [String]) -> IO ()
22:20:06 <kuffaar> function test(&$a) { $a = 'PHP is awesome.' }; test(&$lol); print $lol;
22:20:06 <aristid> ^ RayNbow`TU
22:20:09 <kuffaar> PHP is awesome;
22:20:48 <Enigmagic> does it always convert periods to semicolons too? ;-)
22:20:55 <kuffaar> Shush :(
22:21:08 <CindyLinz> ha
22:21:18 <Enigmagic> :-)
22:21:29 <kuffaar> Hmm when a function has a certain stack of monads defined in its signature and I use return - does it use the return of the monad at the bottom of the stack?
22:21:45 <ion> It would be more plausible for PHP to convert semicolons to periods in strings because semicolons may be more useful in SQL injection attacks.
22:23:38 <Enigmagic> kuffaar: top of da stack
22:23:43 <kuffaar> Oh snap
22:24:46 <c_wraith> kuffaar: return is polymorphic.  the compiler chooses the monad it's working in based on the context.
22:25:43 <c_wraith> kuffaar: in particulary, "return 5" and "lift $ return 5" are both valid, and both result in the same value, if the context is inside a monad transformer.
22:25:51 <c_wraith> err, *particular
22:26:11 <kuffaar> I haven't even used lift yet, although I've seen it many times before
22:26:20 <kuffaar> I've used liftIO in the application initialisation in snap though
22:26:33 <kuffaar> :t lift
22:26:34 <lambdabot>     Ambiguous occurrence `lift'
22:26:34 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
22:26:34 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
22:26:38 <kuffaar> Aw
22:26:41 <Enigmagic> :t liftM
22:26:42 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:26:44 <c_wraith> :t Control.Monad.Trans.lift
22:26:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
22:26:56 <c_wraith> that's the specific lift I meant
22:27:21 <c_wraith> Odd that it's claiming that MonadTrans is declared in Control.Monad.Error, though
22:28:09 <kuffaar> Is that wrong?
22:28:28 <kuffaar> Control.Monad.Trans.MonadTrans according to Google?
22:28:29 <c_wraith> I think it's just saying that because of the import list lambdabot uses
22:28:40 <c_wraith> yes, it's Control.Monad.Trans that has that stuff in it.
22:28:47 <kuffaar> And Control.Monad.Error imports that one?
22:28:52 <c_wraith> yep
22:30:36 <ddarius> ion: Your Perl example is just completely standard lexical scoping.
22:31:14 <c_wraith> along with closures and mutable data, which is not something everyone's used to.
22:31:17 <kuffaar> The kind of a monad needs to be * -> *, right?
22:31:22 <c_wraith> yes
22:31:39 <Enigmagic> c_wraith: mix with lazy evaluation for a real fun time!
22:31:46 <ion> ddarius: Yes, but languages vary in how easily, if at all, you can create scopes in that fashion.
22:32:12 <ddarius> ion: Languages vary in how easily, if at all, they can create higher order functions.
22:32:26 <ion> For instance, in JavaScript, you must abuse lambdas for that: (function () { new scope here }) ();
22:32:40 <ddarius> ion: That's because Javascript's "scoping" is all fucked up.
22:32:55 <ddarius> ion: Again, what Perl is doing is the most standard, obvious thing.
22:33:56 <ddarius> c_wraith: This is why languages should move to explicit reference types.  Then all of this is extremely clear.  That said, it's usually pretty clear anyway unless the language goes out of it's way to "fix" it.
22:34:34 <ddarius> Though there are some things that are normally considered implementation details that can be revealed, e.g. how for loops are implemented.
22:34:34 <c_wraith> ddarius: like Java requiring that everything used within its fake closures be declared final?
22:34:48 <kuffaar> lift is only available when a Monad is an instance of the MonadTrans typeclass, though, right?
22:34:56 <ddarius> c_wraith: That's just an arbitrary restriction.  It doesn't make anything less clear except why it is there.
22:34:57 <c_wraith> correct
22:35:16 <kuffaar> Are most built in monads instances of MonadTrans?
22:35:18 <c_wraith> ddarius: it's actually an implementation detail leaking in a really ugly way.
22:35:23 <kuffaar> Or just a subset?
22:35:26 <ddarius> c_wraith: A more subtle example, not related to higher order functions, is Scheme's callCC can reveal how letrec is implemented.
22:35:29 <c_wraith> kuffaar: I would say not most
22:35:37 <kuffaar> Oh wait there's a list right there
22:35:48 <kuffaar> Yeah it's a smaller subset
22:35:50 <c_wraith> kuffaar: that list isn't complete, though. :)
22:36:02 <kuffaar> Oh? How so? Shouldn't Haddock get all of them?
22:36:22 <ddarius> c_wraith: It's not an implementation detail leaking if it is specified to be that way.  Of course, you can complain that the specification is overly driven by implementation details.
22:36:25 <c_wraith> kuffaar: haddock builds one package documentation at a time.  If something in another package is an instance, it doesn't say
22:36:35 <c_wraith> ddarius: ok, the latter then. :)
22:36:37 <kuffaar> I see, I suspected something along those lines when you objected
22:37:11 <c_wraith> eerr, *one package's documentation
22:37:28 <kuffaar> So a MonadTrans lift allows us to to inject a new monad at the bottom of a monad stack or something like that?
22:37:48 <c_wraith> No..  It allows you to move a monadic value up a level in the stack.  hence the name "lift"
22:38:41 <kuffaar> The bottom being the "left most monad" and the top being the "right most monad" of the stack"?
22:39:26 <c_wraith> well.  the way type constructors are usually written, and if I can remember the difference between left and right, I think that's backwards.
22:39:34 <c_wraith> As an example:
22:40:04 <c_wraith> :t lift :: IO Int -> ReaderT String IO Int
22:40:05 <lambdabot>     Ambiguous occurrence `lift'
22:40:05 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
22:40:05 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
22:40:14 <kuffaar> Haha, once again
22:40:15 <c_wraith> :t Control.Monad.Trans.lift :: IO Int -> ReaderT String IO Int
22:40:16 <lambdabot> IO Int -> ReaderT String IO Int
22:40:27 <kuffaar> I see, IO can only be at the bottom
22:40:28 <c_wraith> lift wraps it in more layers
22:40:32 <kuffaar> So my direction must have been wrong
22:40:34 <c_wraith> Nah, anything can be at the bottom
22:40:45 <c_wraith> :t Control.Monad.Trans.lift :: Maybe Int -> ReaderT String Maybe Int
22:40:47 <lambdabot> Maybe Int -> ReaderT String Maybe Int
22:40:50 <kuffaar> My statement doesn't contradict that :p
22:41:06 <kuffaar> I just said that IO can't be in the middle or at the top of a stack if that stack has more than one element
22:41:11 <c_wraith> Oh, I misread you.  yes, IO can only be at the bottom
22:41:12 <kuffaar> Or so I was told
22:41:16 <c_wraith> Because there's no IO transformer
22:41:21 <kuffaar> Right
22:41:45 <kuffaar> IO is special in many ways, liftIO looks strange to me, too
22:41:54 <c_wraith> It would be really hard to have an IO transformer.
22:42:04 <c_wraith> It would require having a time machine :)
22:42:09 <kuffaar> liftIO looks like it simply replaces the monadic context
22:42:29 <kuffaar> But it's limited to instances of the MonadIO typeclass hmm
22:42:36 <c_wraith> liftIO...   kind of does.  But it can only be defined for things that are, somehow, wrappers around IO
22:42:46 <kuffaar> SnapExtend used that, right?
22:42:51 <c_wraith> yes
22:43:11 <mauke> lift goes one level up
22:43:18 <mauke> liftIO goes 0 or more levels up until it hits IO
22:43:56 <c_wraith> also, liftIO isn't restricted to instances of MonadTrans
22:44:21 <kuffaar> Right, MonadTrans and MonadIO are different typeclasses
22:45:01 <c_wraith> It's quite common to implement MonadIO as liftIO = lift . liftIO
22:45:15 <c_wraith> But that's not the only thing you can do with it. :)
22:46:11 <kuffaar> So you can control how far a function can go up in the monadic stack by making or not making the monads in your stack instances of MonadTrans?
22:46:30 * kuffaar has the image of a "monadic prison" in mind for some reason
22:46:36 <c_wraith> Well.  If you don't make something an instance of MonadTrans, it's always going to be the bottom of the stack.
22:46:50 <c_wraith> ...  Ok, that's not true.
22:47:15 <c_wraith> But it's sort of morally true.  MonadTrans is designed to indicate "this is wrapping another monad".
22:47:58 <c_wraith> If you write something that works as a monad, and wraps another (abritrary) monad, MonadTrans is usually appropriate
22:48:27 <c_wraith> really, it's "If you use lift once, it moves things up one level."
22:48:36 <kuffaar> Oh, Real World Haskell actually uses a remotely similar image in chapter 14
22:48:46 <kuffaar> "The Monad typeclass doesn't provide any means for values to escape their monadic shackles. We can inject a value into a monad using return. We can extract a value from a monad using (>>=) but the function on the right, which can see an unwrapped value, has to wrap its own result back up again."
22:50:06 <c_wraith> yeah.  which is why I don't like to think of (>>=) as extracting a value, so much as "taking a function that would apply without the monad, and combining it with a monadic value"
22:50:27 <c_wraith> Because you never do escape.  You just combine things. :)
22:51:42 <kuffaar> Right, it's just wrapped execution
22:54:20 <kuffaar> I should really keep these signatures in mind: Monad m => a -> m a and m a -> (a -> m b) -> m b
22:54:53 <c_wraith> those are pretty much the two that define what a monad is, yep. :)
22:55:37 <c_wraith> (yeah, there are some pesky rules your implementation has to follow, but those basically work out to be "it works how you expect it to")
22:55:46 <kuffaar> And >> can just be defined in terms of >>=
22:55:58 <kuffaar> Did >> even have a name like bind?
22:56:10 <c_wraith> not that I've heard
22:56:22 <Axman6> can i just say, javascript is fucked
22:56:43 <winxordie> Axman6: how?
22:56:49 <Axman6> how is it not?
22:57:09 <winxordie> It seems to be thriving...
22:57:14 <kuffaar> Hate, hate against the dynamic typing
22:57:22 <kuffaar> winxordie so are Java and PHP and C :>
22:57:30 <winxordie> hmm, touche
22:57:39 <Axman6> and C++
22:58:43 <winxordie> kuffaar: hatred's a rather strong term, isn't it?
23:01:16 * hackagebot tkhs 0.2.4 - Simple Presentation Utility  http://hackage.haskell.org/package/tkhs-0.2.4 (YusakuHashimoto)
23:02:31 <ion> kuffaar: I tend to like dynamic typing more than poorly implemented strong typing, but i do hate JavaScript’s weak typing.
23:02:40 <ion> sorry
23:02:47 <ion> poorly implemented static typing
23:03:36 <ion> and that it doesn’t have integers. :-)
23:05:38 <kuffaar> ion it doesn't have integers? :o
23:05:45 <kuffaar> var x = 1;
23:05:48 <kuffaar> What's the type of x?
23:05:51 <ion> float
23:05:56 <kuffaar> Haha
23:05:58 <kuffaar> I had no idea
23:10:02 <Kaidelong> I keep running into the value restriction now
23:10:09 <Kaidelong> has Haskell damaged me for good?
23:10:16 <Kaidelong> (programming ML)
23:10:17 <kuffaar> @quote SPJ
23:10:17 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
23:11:14 <Kaidelong> and the worst part of it is that I often found myself wishing Haskell was more polymorphic when working on that data analyzer thing last year
23:11:32 <Kaidelong> and now realizing how much more it was than what I came from, already
23:18:28 <kuffaar> Do you think that it is preferrable to use newtype over data for types which have only one type constructor? What is the deal anyways? Why does newtype exist at all?
23:20:03 <copumpkin> kuffaar: it's not about one constructor, it's about having a single underlying type
23:20:11 <Starfire> newtype is guaranteed to have no runtime cost, and it supports GeneralizedNewtypeDeriving, at least.
23:20:12 <copumpkin> if you have a constructor with more than one field, you can't use newtype
23:20:39 <copumpkin> kuffaar: it's basically an opaque wrapper type for another type, guaranteed to have the same runtime representation as the other type
23:20:45 <kuffaar> Starfire: Is that a LANGUAGE pragma?
23:20:50 <Starfire> Yes.
23:20:54 <kuffaar> copumpkin and why is it not guaranteed with type?
23:21:00 <copumpkin> it is
23:21:03 <copumpkin> data does not, though
23:21:08 <kuffaar> Errr data*
23:21:36 <copumpkin> data Moo = Moo Int Bool
23:21:57 <kuffaar> That's not possible with newtype?
23:22:09 <copumpkin> that has more than one value in it
23:22:15 <copumpkin> it's not clear how they should be laid out
23:22:18 <copumpkin> it also lets them be lazy
23:22:31 <kuffaar> I've seen the type statement being explained in terms of "defining a type synonym" - shouldn't that be homonym instead of synonym?
23:22:48 <kuffaar> i.e. same meaning as opposed to "similar" meaning?
23:23:29 <copumpkin> I'd liken it to having same spelling but different meanings :P
23:23:59 <copumpkin> anyway, bedtime
23:25:40 <Kaidelong> unamb reminds me of an idea I had for not using any conditional branches
23:25:53 <Kaidelong> there are just branches, and all but one of them never terminates
23:26:04 <Kaidelong> and you use the result from the one that does
23:26:49 <Kaidelong> now I'm starting to think that that is really just a specific case of the least upper bound idea
23:28:05 <adnap> how can you leave messages for people who don't stay logged in on irc?  can lambdabot or any other bot hold messages for people?
23:28:16 <copumpkin> adnap: use @tell nick message
23:28:25 <copumpkin> but do it in public (if you do it in private, lambdabot won't give the message for some reason)
23:28:42 <adnap> oh, this is a command for lambdabot?
23:28:46 <copumpkin> yeah
23:28:48 <adnap> okay
23:29:04 <Kaidelong> I suppose lambdabot has to know where to give the message, somehow?
23:29:05 <adnap> does the message need to be in quotes?
23:29:25 <Kaidelong> @tell adnap that it doesn't
23:29:25 <lambdabot> Consider it noted.
23:29:29 <kuffaar> adnap: There is a service provided by freenode called MemoServ
23:29:53 <kuffaar> It's tied to freenode accounts to the person in question must be registered
23:30:32 <adnap> @tell conal hey, i started reading your paper.  it's very interesting!  i thought i would point out a small error on page 3 where you implement Map in terms of TMap.  "sample m k = lookup m k" should be "lookup m k = sample m k".
23:30:32 <lambdabot> Consider it noted.
23:33:34 <jmcarthur> kuffaar: type is probably best described as "type alias"
23:33:44 <kuffaar> That sounds better to me
23:34:10 <jmcarthur> kuffaar: newtype is for when you want the semantics of the new type to be the same as its representation
23:34:31 <jmcarthur> it's essentially just a more type safe version of type aliases
23:35:10 <Kaidelong> is type-safe the right word here?
23:35:23 <Kaidelong> I thought the difference was that newtype genuinely made a new nominal type
23:35:29 <Kaidelong> while a type alias was just that
23:39:59 <codemac> I was thinking I should just log into #haskell , ask if yi is done yet, and then leave. once a day
23:43:18 <ivanm> codemac: great way to get banned
23:43:38 <kuffaar> What's yi?
23:43:50 <Kaidelong> yi is an editor
23:43:52 <Veinor> Kaidelong: newtype does create a new type that happens to look exactly like the other type
23:44:01 <Veinor> (and in ghc at least, can be unsafeCoerced back and forth)
23:45:15 <Kaidelong> the whole idea is that the representation doesn't change, right?
23:45:40 <kuffaar> What do I use in Haskell to provide an interface for modules which loaded/unloaded and executed at runtime?
23:45:51 <Veinor> yeah
23:46:02 <kuffaar> I was thinking about writing a client in Haskell and providing an interface for extensions written in Haskell
23:46:17 <Veinor> the point of a newtype is so that you can't, say, mix up your usernames and your passwords
23:46:18 <kuffaar> But I have no idea how you go about implementing the interaction
23:46:50 <kuffaar> Veinor whereas with type Password = String you could
23:47:15 <mm_freak> kuffaar: look at manatee…  there is a working dynamic loading library implemented for it
23:47:23 <Kaidelong> there, Password is just an alias for string
23:47:33 <kuffaar> mm_freak alright
23:48:34 <Kaidelong> with newtype Password = Password String you are making a type that is the same type structurally but not nominally, and thus doesn't match the type it was derived from without calling the destructor
23:48:58 <Kaidelong> and extracting the string from it
23:50:05 <mm_freak> 'newtype' would be much more convenient to deal with, if it could automatically derive all instances
23:50:20 <mm_freak> that's why i usually prefer 'type' over 'newtype'
23:50:26 <mm_freak> for that purpose
23:51:13 * shachaf wishes newtype was much more lightweight somehow.
23:52:45 <Kaidelong> mm_freak: You are missing the point then to a large degree! Also try "GeneralizedNewtypesDeriving" for the instances you do want to derive
23:53:18 <Kaidelong> one of the things that makes newtype so nice is that it doesn't automatically derive instances
23:53:26 <Kaidelong> so you can put down your own
23:54:39 <mm_freak> Kaidelong: no, i'm not…  but for half of my use cases i would derive all instances, as far as possible
23:55:00 <mm_freak> newtype MyAppT m a = MyAppT (StateT AppConfig m a)
23:55:18 <mm_freak> there could be something like "derive all"
23:55:25 <mm_freak> uhn
23:55:28 <mm_freak> "deriving all"
