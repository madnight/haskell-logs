00:02:03 <JoeyA> Do you use it for more than just IO?
00:02:33 <JoeyA> > [0,1] >>= \i -> [0,1] >>= \j -> return (i,j)
00:02:34 <lambdabot>   [(0,0),(0,1),(1,0),(1,1)]
00:07:08 <kfr> :|
00:07:10 <kfr> That was insulting
00:08:26 <pastorn> kfr: what was?
00:10:21 <kfr> <JoeyA> Do you use it for more than just IO? <JoeyA> > [0,1] >>= \i -> [0,1] >>= \j -> return (i,j)
00:10:37 <kfr> He was accusing of being an irrational anti-do person
00:10:45 <kfr> Whereas I do use do all the time, too much actually
00:10:59 <kfr> It is just now that I occasionally start using =<< and such
00:11:10 <djahandarie> Write that in do notation
00:12:50 <djahandarie> @do [0,1] >>= \i -> [0,1] >>= \j -> return (i,j)
00:12:51 <lambdabot> do { i <- [0, 1]; j <- [0, 1]; return (i, j)}
00:13:01 <djahandarie> I don't know, I just don't like do notation for most things
00:13:41 <kfr> You actually use >>= and lambdas over do...?
00:14:11 <djahandarie> Depends on the monad
00:14:25 <djahandarie> If it isn't IO I usually use >>=
00:14:56 <djahandarie> I try to avoid excessive lambdas by just using point-free code on occasion
00:15:20 <kfr> Isn't >>= + lambda generally far longer than do?
00:16:29 <kfr> > map length ["[0,1] >>= \i -> [0,1] >>= \j -> return (i,j)", "do{i<-[0,1];j<-[0,1];return (i,j)}"]
00:16:29 <lambdabot>   <no location info>:
00:16:30 <lambdabot>      lexical error in string/character literal at chara...
00:16:38 * kfr cries
00:16:57 <kfr> Ohh the lambdas
00:17:05 <kfr> > map length ["[0,1] >>= \\i -> [0,1] >>= \\j -> return (i,j)", "do{i<-[0,1];j<-[0,1];return (i,j)}"]
00:17:06 <lambdabot>   [44,34]
00:17:13 <kfr> I cheated, so what.
00:17:43 <kfr> ">>= \" is obviously longer than "<-" though so whatever
00:17:53 <kfr> Asymptotically it will become longer!
00:18:09 <djahandarie> > length "(`fmap`[0, 1]).(,)=<<[0, 1]"
00:18:11 <lambdabot>   27
00:18:21 <kfr> Sure, =<< is nice
00:18:23 <koala_man> showoff
00:18:27 <kfr> I try to use it more now
00:18:28 <djahandarie> Oh forgot two spaces also
00:18:34 <kfr> :P
00:18:41 <djahandarie> kfr, how is =<< any nicer than >>= ?
00:18:50 <helgikrs> > map length ["f >>= g", "do { a <- f; g a}"]
00:18:51 <lambdabot>   [7,17]
00:18:57 <helgikrs> this isn't longer
00:19:02 <helgikrs> :P
00:19:12 <kfr> djahandarie: Well, usually I need to get stuff on the right
00:19:17 <kfr> <kfr> ">>= \" is obviously longer than "<-" though so whatever
00:19:17 <kfr> <kfr> Asymptotically it will become longer!
00:19:18 <kfr> helgikrs ^
00:19:37 <kfr> djahandarie: And using >>= there would make it cryptic
00:20:28 <helgikrs> but you cant do pointfree
00:20:30 <djahandarie> kfr, ... huh?
00:21:28 <helgikrs> i have a program, compiled with -threaded gives me  user error (Pattern match failure in do expression at libraries/base/System/Event/Thread.hs:63:3-10)
00:22:11 <helgikrs> line 63 in Thread.hs:  Just mgr <- readIORef eventManager
00:22:19 <kfr> djahandarie: I find (`fmap`[0, 1]).(,)=<<[0, 1] far easier to understand than the equivalent with >>=
00:22:58 <helgikrs> is this a bug?
00:23:17 <djahandarie> [0,1]>>=(`fmap`[0, 1]).(,) is harder to understand?
00:23:31 <kfr> djahandarie yeah
00:23:36 <helgikrs> base-4.3.0.0
00:24:38 <kfr> helgikrs does it return a Nothing by any chance?
00:24:50 <djahandarie> kfr, this is code in base
00:24:51 <kfr> I am puzzled as to why you pattern match with Just mgr in a <-
00:24:58 <kfr> Oh
00:25:02 <kfr> I missed the path
00:25:17 <helgikrs> i suppose it is returning Nothing, since this is a patternmatch failure
00:25:45 <kfr> Sounds like a bug alright :(
00:25:52 <helgikrs> just dont know why the code looks like that, unless it should *never* be nothing, in which case i'm doing something wrong
00:27:05 <djahandarie> helgikrs, it looks like one, and could very well be one since this is new code
00:27:09 <djahandarie> I'm poking around, hold on
00:27:21 <kfr> Perhaps, but even then it should deal with it more gracefully than that I would hope
00:32:31 <djahandarie> helgikrs, yeah I'd submit a bug report, this seems odd
00:33:50 <helgikrs> djahandarie: on it, thought it looked kinda odd, i only get this error on one of 3 machines i've tried (debian unstable)
00:34:25 * djahandarie -> bed
01:43:26 <pastorn> why is it so quiet here?
01:43:38 <pastorn> nothing for over an hour...
01:44:01 * pastorn wants to help some newbz in order to avoid doing real coding
01:44:06 <koala_man> we're watching the lunar eclipse
01:46:15 <pastorn> where do you live?
01:46:36 <pastorn> all i have outside is clouds, 11 AM
01:47:17 <Ferdirand> ok, noob question: is there a fast way to do large integer input/output in hexadecimal ?
01:47:34 <pastorn> Ferdirand: printf?
01:47:48 <Ferdirand> i found Numeric.readHex but surprisingly it seems slower than using decimal
01:47:53 <Ferdirand> ah, didn't try printf
01:48:01 <pastorn> Ferdirand: but that only give you output
01:48:14 <Ferdirand> is there a way to access the routines from GMP ?
01:48:34 <Ferdirand> because for large integers, i'd expect hex to be much, much faster than decimal
01:49:12 <pastorn> Ferdirand: you might find something in GHC.Integer.GMP.Internals
01:49:34 <pastorn> Ferdirand: how much text are you parsing?
01:50:16 <Ferdirand> hmm.. will have a look
01:50:23 * hackagebot data-object-yaml 0.3.3.4 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.3.4 (MichaelSnoyman)
01:50:45 <Ferdirand> well, in the end, a million of entries of crypto-sized integers
01:51:20 <Ferdirand> we are doing it in C now, with GMP. Doing the same at equivalent speeds but in haskell would be a godsend.
01:51:21 <pastorn> Ferdirand: for really fast parsing look at attoparsec
01:52:07 <Ferdirand> i'm not sure using a haskell-written parser will cut it
01:52:15 <pastorn> Ferdirand: trust me, it will
01:52:20 <pastorn> as long as you use it properly
01:52:33 <Ferdirand> but it's the integer manipulation that is problematic
01:52:37 <pastorn> you'll probably get faster code than whatever thing you're using right now
01:53:05 <pastorn> Ferdirand: can you show the manipulation code you have right now?
01:53:07 <Ferdirand> the point of using hex is to be able to fill a large integer without bothering with mult (or divides for output)
01:53:15 <Ferdirand> right now the parsing is done by GMP itself
01:53:49 <pastorn> Ferdirand: why not just store your numbers as binaries?
01:53:58 <pastorn> for really efficient parsing...
01:53:58 <Ferdirand> if I write a parser in haskell, it will entirely depend on Integer being smart when multiplying by the "block" size or whatever
01:54:42 <Ferdirand> pastorn: plenty of reasons. For now the task is absolutely not IO-bound, and parsing is insignificant wrt time spend doing the actual computation
01:54:42 <Arney> symmetric r  = [(y,x) `elem` r | (x,y) <- r] {- can anyone explain what this does when r is a relation... [(A,B),(B,A)]
01:54:59 <earthy> why would it depend on Integer?
01:55:13 <earthy> plus, Integer *is* implmented using GMP, IIRC
01:55:36 <pastorn> Arney: that returns a list of bools
01:55:39 <Ferdirand> yes, Integer is implemented using GMP, otherwise haskell would not be an option for me
01:56:10 <pastorn> Ferdirand: iirc the bignum implementation is moving away from GMP to native haskell
01:56:14 <Arney> I know that, but how is it working... I need to make an antisymmetric checker for homework.
01:56:16 <pastorn> not sure about that, though
01:56:36 <Ferdirand> well, my ghc is linked against libgmp.so.3...
01:56:44 <pastorn> Arney: do you know what "x <- xs" does?
01:56:51 <Arney> not really.
01:56:54 <earthy> pastorn: there's been talk of that, but supplanting gmp and not losing speed is hard.
01:56:55 <Ferdirand> I need the subquadratic gcd algorithm that is in gmp 5.0
01:57:03 <pastorn> Ferdirand: i'm talking obout the future, where everything is shiny and cool
01:57:19 <earthy> ferdirand: then you're up shit creek. :)
01:57:21 <Arney> that looks like the things you use to declare types
01:57:24 <Ferdirand> pastorn: that's okay, my project is very short term :)
01:57:45 <pastorn> @google haskell sieve
01:57:50 <lambdabot> http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)
01:57:51 <lambdabot> Title: Sieve of Eratosthenes (Haskell) - LiteratePrograms
01:58:06 <Ferdirand> hmm, I didn't even check if Prelude.gcd was backed by the GMP gcd
01:58:09 <Ferdirand> is it ?
01:58:11 <earthy> linking gmp with haskell programs is 'here be dragons' work
01:58:17 <pastorn> Arney: ^^^ look at that sieve implementation
01:58:20 <pastorn> the first code block
01:58:42 <pastorn> Ferdirand: yes
01:59:20 <pastorn> i think
01:59:34 <pastorn> @src gc
01:59:34 <lambdabot> Source not found. You type like i drive.
01:59:35 <pastorn> @src gcd
01:59:36 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
01:59:36 <lambdabot> gcd x y = gcd' (abs x) (abs y)
01:59:36 <lambdabot>    where gcd' a 0  =  a
01:59:38 <quicksilver> Ferdirand: no, I don't think so.
01:59:46 <accel> what is the ideal way to handle exceptions in ahskell
01:59:49 <quicksilver> almost nothing is backed by gmp operations
01:59:54 <quicksilver> it's a common complaint
01:59:55 <accel> exceptions for things like "I want to open this file, but the file alreay exists"
02:00:01 <pastorn> quicksilver: don't you think that it's done with SPECIALIZE with for Integer?
02:00:01 <Ferdirand> I was looking forward to bragging to my colleages "look I can do in 1 day and 10 lines what would take you 1 week and 200 lines"
02:00:04 * accel doesn't understand how exceptions and laziness can go together
02:00:13 <quicksilver> pastorn: no, I don't think that. However, I could be wrong.
02:00:47 <quicksilver> looks like I am wrong.
02:00:48 <Maxdamantus> > seq (error "foo") "bar"
02:00:49 <lambdabot>   "*Exception: foo
02:00:52 <quicksilver> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg03537.html
02:00:57 <pastorn> Ferdirand: import GHC.Integer
02:01:00 <earthy> quicksilver: There's a rewrite rule for gcd on Integer
02:01:15 <pastorn> you have some pretty nice functions there, and i'm guessing most of them uses the GMP implementations
02:01:31 <Ferdirand> ow yeah
02:01:35 <Ferdirand> gcdInteger
02:01:39 <Ferdirand> thanks :D
02:01:39 <pastorn> accel: what kind of exceptions? what are you trying to do?
02:02:22 <accel> pastorn: I want to understand the right way exceptions work in haskell
02:02:29 <pastorn> Ferdirand: but storing as Hex seems kind of silly if you have millions of numbers, storing the actual binary representation seems cleverer ;(
02:02:35 <pastorn> * ;)
02:02:37 <Ferdirand> yes, I know
02:02:49 <Ferdirand> actually, the storage is in binary
02:03:09 <pastorn> Ferdirand: then why are you trying to mess with hex?
02:03:18 <pastorn> accel: error handling is doable in many ways
02:03:50 <Arney> pastorn: You have atempted to access code from an article that does not exist.
02:03:58 <pastorn> accel: it all depends on which programming domain you're doing... do you want to recover from DivByZero? Parse errors? FileDoesNotExist?
02:04:18 <Ferdirand> pastorn: because it's easier to interact with existing code. I've redone the storage to be in binary, but was disappointed at how little gain that would provide
02:04:35 <Ferdirand> storing in hex doubles the storage size at most. It's only a few gigabytes of data
02:04:55 <pastorn> Arney: check your url... did you get the "(Haskell)" right?
02:05:06 <pastorn> Ferdirand: *only*
02:05:21 <jacobian> I've noticed that ghci tends to grow to eat my entire memory and then gets killed, while using the same stuff compiled does not.  Is the gc different or something? 
02:05:35 <Arney> pastorn: lol it was missing the closing parens
02:06:07 <pastorn> Arney: you know how "sieve" works? (mathematically)
02:06:41 <Arney> pastorn: I thought sieve's was a guy. Im looking through the code.
02:07:11 <pastorn> Arney: the only thing i wanted to show was something that you probably know, but it's haskell implementation (don't read through the whole thing...)
02:07:56 <pastorn> Arney: it's for generating primes... list all the numbers from 2 and upwards, whenever you encounter a number strike all multipeles of that number in the sequence
02:08:10 <pastorn> and in the end you have all the primes (never strike the actual number itself)
02:08:24 <hape01> cabal can produce documentation with "cabal haddock", with "cabal hscolour" I might produce colourized src-code htmls.  How can I do both things in one step, I mean - producing Haddoc Html with linked Sourcecodes, by means of cabal?
02:08:54 * ivanm misses planet.haskell.org being down :(
02:08:56 <ivanm> hape01: you can't
02:09:12 <ivanm> dcoutts hasn't worked out a nice way of presenting that option in the UI
02:09:23 <ivanm> you can do it with the runhaskell Setup.hs approach though
02:11:07 <hape01> ivanm: sorry for asking as early as I did - I found an option: cabal haddock --hyperlink-source   - this does the job, when I did   "cabal hscolour"  in advance.     wow
02:11:24 <ivanm> oh, they added --hyperlink-source in?
02:11:31 <hape01> yes they did
02:11:33 <ivanm> or maybe dcoutts was just looking for an all-in-one solution
02:11:35 <hape01> super :-)
02:13:03 <Ferdirand> hmm... gcdInteger and Prelude.gcd seem to be about as fast. Good for the language !
02:13:20 <mux> would you guys recommend a specific package for handling human-editable configuration files? some YAML or JSON package maybe?
02:15:13 <pastorn> mux: xml?
02:15:20 <category> mux: I tend to use JSON for that sort of thing, and www.json.org suggests http://hackage.haskell.org/cgi-bin/hackage-scripts/package/json
02:15:41 <mux> pastorn: I said humena editable; xml is bad for that
02:16:07 <mux> category: yeah, I like JSON for that kind of things too; I'm really looking for recommandations on a specific, proven, robust, efficient package
02:16:15 <category> XML does tend to favour the machine in the Great Conversation. ;o)
02:16:26 <mux> exactly
02:16:38 <mux> I'm no XML hater, but I wish it was used more thoughtfully
02:17:14 <sipa> anyone been at fosdem in 2005?
02:17:56 <category> mux: No idea about a specific proven one, as I'm a Haskell noob; I compared the two packages listed on www.json.org and suggested the one updated in 2010. ;o)
02:18:11 <pastorn> Arney: how's it going? you getting the hang of it?
02:18:26 <Arney> yeah
02:18:30 <mux> category: yeah, I've been looking at that already :)
02:18:38 <Arney> its taking every item and checking if it has an opposite
02:18:54 <Arney> pastorn: thanks.
02:18:54 <pastorn> yep
02:18:58 <pastorn> Arney: http://en.wikibooks.org/wiki/Haskell/List_processing#List_comprehensions
02:19:04 <pastorn> for some further reading
02:21:44 <ivanm> mux: there's conffile or something on hackage
02:22:13 <Ke> is someone going to resurrect code.haskell.org
02:22:22 <ivanm> mux: make that ConfigFile
02:22:27 <ivanm> Ke: they're migrating to a new server
02:22:30 <pastorn> Ke: they're working on new servers or something
02:22:38 <Ke> ok
02:22:44 <ivanm> http://www.haskell.org/pipermail/haskell-cafe/2011-January/088577.html
02:22:48 <pastorn> Ke: this was in the pipeline, and getting hacked sort of set it off :)
02:28:31 * hackagebot adjunctions 0.5.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.5.1 (EdwardKmett)
02:28:44 <frerich> pastorn: Thanks for the wikibooks link, I'm a haskell beginner myself and I didn't know those articles yet. Looks useful to me. :-)
02:34:19 <pastorn> frerich: i usually think that the wikibooks articles should be mentioned more often when people ask for haskell books
02:34:55 <frerich> pastorn: I just read the first two 'chapters' and it's very nice. It's easy on newbies!
02:35:04 <pastorn> yeah
02:35:18 <pastorn> a bit too much text in some ports, but still good
02:37:54 <pastorn> *parts
02:39:12 <accel> dons: my copy of real world haskell arrived yesterday; looking through it; I just wnated you to know, if you stapled your blog posts together and called it "real world haskell 2", I'd be interested in purchasing a copy
02:41:32 <Palmik> Hi Botje, here is the replacing of "Variables" by traversing the AST I was talking about http://codepad.org/HAmK89bY ... the problem I have now is that it does not seem to be possible to define any function other than identity :D
02:43:52 <Palmik> All I need is some +, -, *, /, if-then-else expressions, I could hardcode them into the AST, but that probably is not the cleanes solution
02:44:09 <Palmik> *are some, cleanest
02:44:21 <Botje> add a primitiveFunction then?
02:44:38 <Botje> which, instead of an Expr, has a function [Number] -> Number
02:45:20 <Palmik> hmm, that might do the trick :) nice, thanks :)
02:46:00 <pastorn> accel: you written Control.Monad.Inception yet?
02:48:40 <accel> pastorn: are you part of Dons' mental defense?
02:49:09 <pastorn> accel: well, you'll just have to wait until he wakes up to find out...
02:49:21 * pastorn chases after accel with a gun
02:57:43 <em_> hi everyone!!!
02:59:08 * ivanm waves idly in em_'s general direction
03:01:15 <pastorn> em_: hello
03:02:56 <em_> i've never coded by Haskell
03:03:00 <accel> pastorn: I actually came to deliver something to you
03:03:08 * accel hands pastron a copy of "The C Programming Language"
03:03:10 * accel vanishes
03:03:13 * pastorn dies
03:03:19 <pastorn> instantaneously
03:03:37 <accel> you know you want to use C :-)
03:03:54 <pastorn> actually i suck at c
03:03:56 <pastorn> so no
03:04:10 <accel> besides haskell, what do you use?
03:07:02 <ivanm> who needs another language? :/
03:07:10 * pastorn nods
03:07:22 <ivanm> (except for possibly some shell for quick 'n' dirty glue, runs, etc.)
03:07:28 <pastorn> accel: well, i have to use java for school every now and again
03:07:30 <dolio> Malbolge.
03:07:31 <pastorn> but that's about it
03:08:06 <pastorn> accel: i use automake, but that's only because i haven't found any "cabal 4 newbz" documents
03:08:36 <ivanm> pastorn: :o
03:08:43 <ivanm> it's not hard to use Cabal, at least for basic stuff
03:08:52 <ivanm> just edit a pre-existing .cabal file
03:08:57 <em_> i'm bored imperative programming
03:08:59 <pastorn> i'm guessing cabal can do most of the stuff i do with make, i just haven't bothered to learn it
03:09:11 <pastorn> ivanm: aren't you supposed to use cabal init?
03:09:21 <ivanm> to create a very basic config, yes, you can
03:09:21 <accel> isn't haskell make
03:09:23 <accel> just Setup.lhs ?
03:09:40 <pastorn> accel: that's if there already is a cabal config
03:09:51 <accel> I just noticed
03:09:53 <ivanm> accel: Setup.[l]hs basically runs the Cabal library over the .cabal file
03:09:57 <accel> I should be writing lhs instead of hs files
03:10:04 <ivanm> accel: why?
03:10:04 <pastorn> accel: why?
03:10:12 <ivanm> I used to use lhs
03:10:15 <pastorn> accel: i use .hs but always write haddock comments
03:10:19 <ivanm> but unless you're doing a paper, I found it's not worth it
03:10:29 <ivanm> since you can't really use haddock with lhs nicely
03:10:39 <pastorn> accel: yeah... lhs is great for use with pandoc or lhs2tex
03:11:06 * ivanm really should clean up and publish his emacs markdown+lhs mode
03:11:21 <pastorn> lol emacs lol
03:11:38 <ivanm> *sigh*
03:12:05 * pastorn does something ivanm thinks is advanced, but in 15 keypresses less
03:12:28 <ivanm> why is it that it's generally vi users that bash emacs rather than the other way round?
03:12:59 <pastorn> because our superiority requires boasting
03:22:58 <Arney> http://img510.imageshack.us/img510/385/capturecr.png does that mean that there is only one relation that meets total when the universal set is finite?
03:27:25 <dolio> Arney: I think the answer is, "no," but your question is hard to parse.
03:28:14 <Arney> I need to make code that checks for total.... but I don't know what total is and that mathematical notation is so rediculously fringe that I can't read it.
03:28:46 <jacobian> total means not partial 
03:29:04 <jacobian> a function which has some elements in the domain which are not associated with elements in the co-domain is partial. 
03:29:32 <jacobian> That notation there says that *every* (all) element of the domain, is associated with some (exists) element of the co-domain. 
03:31:39 <jacobian> An example of a partial function is "head" which does not have an element in the co-domain for the element [] in the domain. 
03:31:40 <dolio> If U = {1,2,3}, then {(1,1),(2,2),(3,3)} is a total relation, because every value of U appears at least once in the first component of a pair.
03:31:48 <dolio> {(1,1),(3,3)} is not total.
03:32:09 <dolio> Because it's missing 2.
03:32:12 <Arney> so there is only one set of relations that is total
03:32:15 <Arney> ooooooooh
03:32:23 <Arney> dolio, got it
03:32:30 <Arney> Thank you both.
03:32:37 <dolio> {(1,2), (2,2), (3,2)} is also total, but it's different than the other total one.
03:32:39 <Arney> why couldn't they just say so.
03:32:50 <jacobian> lol
03:34:19 <Arney> should I be reading thoset to right or right to left math codes lef
03:34:44 <Arney> should I be reading those math codes left to right or right to left
03:36:14 <dolio> The math notation says, R is total when for all x in U, there exists a y in U such that (x, y) is in R.
03:36:48 * hackagebot hjson 1.3 - JSON parsing library  http://hackage.haskell.org/package/hjson-1.3 (JaroslavGridin)
03:38:54 <inglorion> is there any good library to read and write config files?
03:41:18 <Bynbo7> TacticalGrace: hey
03:47:27 <Arney> dolio: and [(x:_) `elem` r | x <- univ]
03:47:58 <Arney> how do I only match for x? thats my implementation of total
03:51:23 <dolio> You're going to have to do a little better than that, I'm afraid.
03:51:59 <dolio> I suggest you look at all and any.
03:54:57 <Palmik> Botje, I think I finally got the AST with eval working :) http://codepad.org/ogk86Qjt Thanks a lot for your advice :)
03:55:40 <Bynbo7> "Generating and compiling a zillion numerical type aliases, this might take a while"
03:56:54 * hackagebot hjsmin 0.0.12 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.12 (AlanZimmerman)
03:58:09 <greap> Hi. Just checking again: How do I get the command-line quickcheck application?
03:59:33 <Botje> Palmik: nice job!
03:59:38 <Botje> Palmik: so what's your next step? :)
04:00:21 <Palmik> Botje, read something about parsing :)
04:00:36 <Botje> good choic
04:00:37 <Botje> e
04:01:18 <inetic> hi guys, I'm trying to wrap the Data.Binary.Put monad in my own but even a trivial attempts to do so result in monads that hog memory too much to be practical, would someone please have a look? http://hpaste.org/43392/wrapping_up_the_databinarypu
04:01:21 <Palmik> I have seen people using Parsec a lot for such tasks, so I might start with parsing in theory and then move to Parsec :)
04:03:33 <emdee> If anyone who uses EclipseFP could take a look at this question, I'd really appreciate it http://superuser.com/questions/238834/configuring-eclipse-with-eclipsefp-plugin
04:03:48 <Cale> inetic: Why not use newtype instead of data?
04:04:20 <inetic> Cale, because I don't yet know enough Haskell to know the difference :-)
04:04:49 <Cale> inetic: It creates a new datatype (as far as the type system is concerned) whose semantics are such that the compiler can use the runtime representation of the original type
04:05:09 <Cale> Syntax-wise, it's just like data, only that you're restricted to a single constructor having a single field.
04:05:40 <adimit> changing this won't cut down on memory-consumption significantly, though.
04:05:47 <Cale> Oh?
04:06:08 <Cale> It will make a difference in this case, I should hope.
04:06:58 <inetic> Cale, I can try and change it
04:07:31 <Cale> Take your Writer1M example, and replace 'data' with 'newtype'
04:08:15 <adimit> well, I, too, hope it helps, but space leaks are the usual suspects when Haskell programs hog too much memory.
04:08:54 <Cale> adimit: Have you looked at the code? It's apparently fine when he uses a type synonym, not okay when he wraps the type with data
04:09:33 <inetic> the memory footprint hasn't changed :-(
04:10:01 <adimit> Cale: I've looked at the code, but the differences are much larger than just the type declaration.
04:10:10 <Cale> okay, remove the Monad instance, and add  deriving Monad to the newtype declaration
04:10:23 <Cale> and add  {-# LANGUAGE NewtypeDeriving #-}  to the top of the file
04:11:20 <lunaris> GeneralizedNewtypeDeriving
04:11:25 <Cale> oh, right
04:11:38 <Cale> Couldn't pick a nice short name :P
04:11:38 <lunaris> The Americanised spelling gets me every time.
04:11:42 <lunaris> Indeed :)
04:12:10 <lunaris> I believe Conor suggested {-# LANGUAGE KitchenSink #-} in one of his SHE talks.
04:12:33 <ivanm> lunaris: is that the new name for -fglasgow-exts? :p
04:12:43 <Cale> lunaris: btw, you might want to point that spelling issue out. In most cases, GHC will accept non-US spellings.
04:12:49 <inetic> that did help, but isn't it the same as if I didnt wrap anything at all?
04:13:15 <Cale> inetic: It's a new type as far as the type system is concerned.
04:13:19 <zygoloid> lunaris: nothing american about -ize. :)
04:13:31 <Bynbo7> sure there is
04:13:35 <ivanm> definitely
04:13:36 <Bynbo7> how is that not american?
04:13:59 <Cale> It won't be identified with the original type -- you'll be forced to use the data constructor/field extractor/pattern matching to change between them.
04:14:29 <Arney_> dolio: is [(1,2),(1,1),(1,3)] total?
04:14:35 <lunaris> ize has its place
04:14:37 <inetic> yes, but the point of creating the wrapper monad was to add some more information to it (like current position,...)
04:14:38 <lunaris> Just not where ise belongs.
04:14:59 <lunaris> It's not a case of newtype American = American English.
04:15:02 <ivanm> http://en.wikipedia.org/wiki/-ize#iseize
04:15:03 <lunaris> :)
04:15:05 <Cale> The Oxford English Dictionary people seem to prefer -ize endings when there's an option, but usually list both.
04:15:13 <ivanm> apparently using -ize in English is an Oxfordian thing
04:15:15 <ivanm> @slap Oxford
04:15:16 * lambdabot pokes Oxford in the eye
04:15:38 * ivanm can't believe that searching for -ize in wikipedia worked
04:15:43 <lunaris> Clearly the semantics of the word slap aren't well defined here.
04:15:52 * lunaris wonders what he has started.
04:17:26 <Cale> That's a lie on the wikipedia article about OED's treatment of "realise"
04:17:37 <Cale> They absolutely do list it as an alternative spelling in the entry.
04:17:44 * lunaris sinks into the shadows.
04:18:21 <inetic> Cale, now that I'm not defining my own >>= operator, wrapping the Put monad doesn't seem to bring any value, I'm not sure if I've explained myself correctly (not native english speaker)
04:18:31 <Bynbo7> gogoghc7.0.1,64bitforOSX!
04:18:37 <Bynbo7> download faster damnit!
04:18:47 <Cale> inetic: What was the idea behind defining your own >>=?
04:19:17 <Cale> You defined it in such a way that it'll be equivalent to the newtype's derived instance, except possibly less efficient.
04:20:06 <inetic> for example having the signature like this: data Writer2M a = Writer2M { write :: (a, P.Put, Integer) }, would allow me to know how many bytes will the Writer write
04:20:27 <Cale> Well, that's a whole different thing
04:20:46 <Bynbo7> inetic: i think that the blaze-builder Put monad already does something similar
04:20:48 <Cale> btw, if you care about efficiency, you're probably better off making those separate fields rather than a single triple
04:21:03 <inetic> Cale: or if the signature was like this:  data Writer2M a = Writer2M { write :: Integer -> (a, P.Put, Integer) }, I could allow me to track current offset
04:21:12 <Cale> okay
04:22:19 <inetic> Cale, it's not that much about caryin about efficiency as its about carying about it not crashing when it eats up 4GB of memory :-)
04:22:25 <Arney_> http://img91.imageshack.us/img91/1673/capturecb.png can anyone decipher what that means, or better yet, turn it into a haskell check
04:22:32 <Cale> You might consider using (possibly newtyped) monad transformers for this -- this is exactly what monad transformers are for.
04:22:54 <Cale> Arney_: I know what it means
04:23:03 <Cale> Arney_: A relation is a set of pairs, right?
04:23:09 <Arney_> yes
04:23:31 <Arney_> and U is all the universal set
04:23:52 <Cale> So it's saying that the relation is antisymmetric if for any x and y (in the domain of the relation), the fact that (x,y) and (y,x) both belong to R implies that x is equal to y
04:24:16 <Cale> Another way to put that is that if x is not equal to y, then (x,y) and (y,x) are not both in the relation
04:24:27 <inetic> Cale, I think I understand the point of monad transformers, but I think that e.g. the StateT would do exactly the same think (as it's implemented in a simmilar fashion I think)
04:24:47 <adimit> inetic: I'm gonna go out on a limb here and suggest that you most likely have a huge space leak somewher. That mean you'll need to play around with strictness/lazyness issues in your implementation.
04:25:13 <Arney_> reallllly?? which mean I could implement it like this: and [x=y | (x,y) <- r]
04:25:50 <adimit> you should try to profile it, and see which data structure gobbles up all the memory. Also, a specific use-case scenario with some data and a main function would go a long way towards identifying the problem :-)
04:25:54 <inetic> adimit, would you please recommend some resources on it?
04:26:27 <Cale> Arney_: for example, <= is an antisymmetric relation on, say, the natural numbers, because if x <= y and y <= x then x = y
04:26:47 <adimit> inetic: I could, no worries. Here's a link from the GHC manual on profiling: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/profiling.html
04:27:13 <adimit> don't despair, space leaks are one of Haskell's warts, unfortunately. After a while, you'll get used to that (sadly.)
04:27:29 <Cale> Well, space leaks happen in any language.
04:27:44 <Cale> I don't consider them all that much easier to write in Haskell than anything else.
04:27:59 <adimit> true, but they tend to sneak up on you in Haskell. Especially with lazy IO.
04:28:08 <inetic> adimit, oh, I've done some memory profiling already
04:28:19 <inetic> adimit, with ghc
04:28:29 <adimit> inetic: here's a wiki article, though I have no idea how useful it is http://www.haskell.org/haskellwiki/Memory_leak
04:28:45 <adimit> inetic: can you paste the profiling output and the complete program you profiled?
04:28:48 <Cale> It's important to understand lazy evaluation very well if you want to avoid them, which makes them kind of tough to deal with if you're used to strict programming.
04:29:04 <adimit> Cale: that's exactly what I meant :-)
04:29:41 <Cale> A lot of programs written in Haskell naively use less memory than their naive translations into strict languages though :)
04:29:53 <adimit> But I think they're tough to deal with anyway. I'm actually used to lazy FP programming, and I still have problems with them. I'm also very aware of them, since I work in NLP where a small space leak will cause a crash.
04:30:36 <Cale> It would be nice if there were some better tools to visualise graph reduction of programs
04:31:01 <Cale> (so you could see the heap as a big graph, and evaluation transforming that graph)
04:31:15 <adimit> there has been some effort in that direction, I think.
04:31:20 <Cale> (space being the amount of actual space that it takes to draw that graph ;)
04:31:24 <adimit> but I can't seem to recall what exactly it was.
04:31:37 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ -- there's this
04:31:42 <Cale> but it's not released to the public
04:31:54 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html :)
04:32:19 <adimit> wow, that seems useful.
04:32:21 <Arney_> I want to make a list comprehension that test every other element for equality, how would I do that?
04:32:33 <quicksilver> Cale: and you could do somethign interesting with vacuum, although GHC heap representation graphs aren't exactly what you'd expect from term reduction semantics
04:32:49 <adimit> Though I think for anything but toy examples this will get as incredibly tedious and opaque as a Prolog stack trace.
04:33:14 <Wooga> hello, i have pairs of 2d vectors, which are should be unique (each entry for each possible pair of two vectors, like 0-1,0-2,0,3,1-2,1-3,2-3). which tuples data strcuture i am better to use?
04:33:20 <Wooga> Lists? Maps?
04:33:30 <Wooga> or something else?
04:34:17 <Cale> adimit: Maybe in some cases. I think that a lot of functional programs are written in such a way that they locally appear to be toy examples of things. (That is, if you look at any small part of the program, it will probably be meaningful and testable independently from the rest of the system.)
04:34:23 <Wooga> where 0,1,2,3 are (x0,y0),(x1,y1),(x2,y2),(x3,y3), etc
04:34:50 <Cale> Not always true, but it's often achieved to some extent :)
04:35:04 <adimit> Cale: if they are well written, yes. Truth is, sometimes they won't be :-P
04:35:12 <adimit> that's when you'll need it most.
04:36:46 <inetic> is there some paste service for pictures?
04:37:19 <adimit> inetic: imgur.com
04:37:24 <Wooga> inetic: which kind of pictures?
04:37:32 <adimit> Probably some profiling :-P
04:37:38 <Wooga> jsut there are services like *booru, danbooru and gelbooru for examole
04:37:47 <inetic> adimit, screenshot from memory profiler
04:37:50 <Wooga> where most of anime art already posted for you
04:37:51 <inetic> :-)
04:38:10 <adimit> just use imgur. It's really the best such service I've seen :-)
04:38:34 <inetic> adimit: thanks
04:40:18 <Wooga> well, i'll try to rephrase my question ans ask again. if i have 2d vectors (represented as 2-tuples for x and y coordinats); which data structure i am better to use to represent unique pairs of this vectors ?
04:40:23 <inetic> here, the yellow part isn't there if I use the Put monad directly: http://i.imgur.com/4Q2E3.png
04:42:25 <pastorn> inetic: how do you get that outputL
04:42:26 <pastorn> ?
04:43:48 <inetic> pastorn: you run your program with flags "./main +RTS -hc", it creates a main.hp text output for you and then you run "hp2ps main.hp" and it returns a ps file
04:44:11 <Silvah> http://hpaste.org/43395/x - how can I achieve the same thing without explicit recursion? funcs is [Int -> (Bool, Int)].
04:45:30 <inetic> pastor, actually this is the line I use: ghc -prof -auto-all --make main.hs && ./main +RTS -hc && hp2ps -c main.hp && okular main.ps
04:46:30 <Wooga> why use okular in gnome DE?
04:46:37 <Wooga> there is evince
04:47:58 <inetic> Wooga, I left KDE when it got unstable and sluggish, still used to some of it's programs, this one has served me well
04:51:18 <pastorn> inetic: cool, thanks
04:55:02 <jonkri> i have a process that reads xml data over a network and i want to have another process to parse the xml and update its state. would Control.Concurrent.Chan be a good way to have these processes communicate?
04:55:17 <jonkri> its state = the second process' state
04:56:00 <jonkri> or could STM be better?
04:56:06 <Bynbo7> if by process you mean threads, then a Chan would be fine
04:56:23 <jonkri> oh, right. yes, i do mean thread
04:56:24 <Botje> Silvah: foldl (\(mod, input) f -> let (mod2, output) = f input in (mod || mod2, output)) (False, input) funcs
04:56:56 <Botje> Silvah: that will give you a tuple (mod, output), and if mod is True you can invoke yourself again
05:02:22 <Silvah> Botje: thanks.
05:02:40 <Botje> i'm sure there's a more elegant way to write that lambda
05:02:47 <davesq> I'm trying a LearnYouAHaskell example which uses a YesNo typeclass to return True for non-empty values, and False otherwise. I'm trying to modify the e.g. to also return False for (Just False) but am stuck: http://hpaste.org/43396/n00b_typeclasses_question  (pls excuse any etiquette blunders; IRC n00b)
05:03:38 <joe6> a lot of the guys on this channel are n00b's..
05:03:48 <joe6> like me..
05:04:08 <sipa> i think #haskell is pretty friendly to newcomers
05:04:14 <Arney_> can anyone make me a list comprehension that gets (x,z) from (x,y),(y,z)
05:04:17 <Bynbo7> davesq: well, you've avoided the first error most make when new to irc, and that's breaking rule #1: don't ask to ask, just ask. congratulations! :)
05:04:34 <Bynbo7> Arney_: no, those aren't lists
05:04:51 <Arney_> gets (x,z) from [(x,y),(y,z)]
05:05:01 <sipa> davesq: have you tried the code in comments?
05:05:03 <Arney_> Bynbo7: that is
05:05:07 <joe6> yes, it is the best for newcomers. and it helps a lot too..
05:05:11 <Bynbo7> you can't do that in a list comprehension Arney_ 
05:05:23 <Arney_> well that explains my pain
05:05:33 <Arney_> what do I use?
05:05:56 <Bynbo7> pattern matching? there's plenty of ways. will it always be a two element list?
05:06:00 <Arney_> I don't want to make another function
05:06:21 <Bynbo7> if so, you can just use f [(x,y),(y',z)] = (x,z)
05:06:30 <Arney_> no, it will be a long list... I want to test the transistive property
05:06:38 <Botje> davesq: only if you allow overlapping instances.
05:06:42 <davesq> sipa: yes, I get "Illegal instance declaration... all instance types must be of the form (T a1 ... an) where a1 ... are type *variables*". But I'm not sure what that means.
05:06:46 <mux> Arney_: [ (x,z) | ((x,_),(_,z)) <- thelist ]
05:06:59 <Bynbo7> mux: that won't work
05:07:21 <Bynbo7> unless the list has [((x,y),(y,z))], there's an extra tuple there
05:07:24 <davesq> Botje: The error mentions I can try -XFlexibleInstances, but I wasn't sure if that meant I'm totally on the wrong track.
05:07:40 <sipa> well, yes, you need flexible instances for that
05:07:48 <mux> Bynbo7: yes it will; this list is what he asked for without knowing, the type he gave for the list was a syntax error.
05:08:03 <sipa> davesq: it's just a limitation of the haskell standard which is not really necessary
05:08:22 <Bynbo7> mux: he corrected himself, the list contains [(x,y),(y,z)]
05:08:30 <sipa> davesq: so put {-# LANGUAGE FlexibleInstances #-} at the top of your source file 
05:08:31 <mux> that's not possible
05:08:36 <Bynbo7> anyway, the question is illdefined
05:08:37 <mux> Bynbo7: that is not a valid type
05:08:48 <Bynbo7> it's not a type, it's a list
05:08:55 <mux> hence my answer which seems to match his intentions
05:09:02 <mux> a list is a type
05:09:11 <mux> oh
05:09:13 <mux> you mean that is a value
05:09:16 <Bynbo7> yeah
05:09:17 <mux> now that makes more sense;
05:09:23 <Bynbo7> well, that's what i think he means
05:09:35 <Bynbo7> Arney_: perhaps you could be more clear about what you're after?
05:09:40 <mux> list comprehensions are not well suited to extract two elements at once
05:09:48 <mux> I probably wouldn't use a list comprehension  for this.
05:09:53 <Arney_> Bynbo7: transitive r = [ (x,z) | ((x,_),(_,z)) <- r ]
05:10:13 <Arney_> The r is a list of tupples, 
05:10:16 <mux> and if he really has list with an even number of tuples only, then he should switch to a datatype that enforces it, such as the one I suggested
05:10:20 <Bynbo7> ah, yo didn't say that:)
05:11:16 <Arney_> in C that would be something like a recursion, popping one tupple everystep down. 
05:11:38 <zygoloid> Arney_: i think you want something like [ (x,z) | (x,y) <- r, (y',z) <- r, y == y' ]
05:11:55 <zygoloid> but it's not really clear what you're asking for
05:12:10 <zygoloid> are you trying to form the transitive closure of a graph?
05:12:31 <Ferdirand> or maybe [ (x,z) | ((x,y),(y',z)) <- zip r (tail r) , y == y' ] ?
05:12:40 <Arney_> Im getting no instanze errors
05:12:51 <Arney_> transitive [(1,2),(3,4)]
05:13:06 <Arney_> should return true
05:13:18 <zygoloid> True? this is a predicate then?
05:13:19 <mux> Arney_: does your list always have an even number of elements?
05:13:27 <Arney_> oh wnope
05:13:33 <Arney_> mux: nope
05:13:41 <mux> then the specification of what you asked is ill-defined
05:13:57 <davesq> sipa: Thanks! I can load the commented code now, but when evaluating "yesno (Just False)" it doesn't know which overlapping instance I mean, YesNo (Maybe Bool) or YesNo (Maybe a). Is there a way to give it a hint?
05:14:50 <sipa> davesq: you'll need to disable the (Maybe a) instance
05:15:13 <sipa> there is another extension, overlappinginstances, which allows those, but that's more "dangerous"
05:15:39 <Arney_> Bynbo7: http://img690.imageshack.us/img690/1975/capturexau.png
05:16:06 <sipa> davesq: because now both (Maybe a) and (Maybe Bool) match
05:16:08 <zygoloid> Arney_: great, that helps a lot. you can translate that pretty literally into haskell.
05:16:12 <Arney_> mux: thats what I need to check for, given a list of relations from a universal set
05:16:27 <Bynbo7> Arney_: that's quite different from what you asked for really
05:16:40 <Arney_> Really.... that language is breaking my balls...
05:16:40 <levifikri> Hi, how to compile code using Data Parallel Array on GHC 6.12.3?
05:16:56 <mux> ah, that is completely different indeed
05:17:13 <zygoloid> Arney_: so you want to find the set of pairs of pairs (x,y1), (y2,z) where y1 == y2 in r, and check that (x,z) is in r for each such pair of pairs.
05:17:42 <Arney_> a huh. sure thing.
05:18:12 <Arney_> Couldn't I just check what it implies? x=z
05:18:31 <Arney_> I guess not.
05:18:41 <crm> is code.haskell.org down?
05:18:50 <Bynbo7> yes
05:19:13 <zygoloid> Arney_: that doesn't imply x=z. if you have [(1,2),(2,3),(1,3)], that is transitive, but we don't have x=z for the pairs (1,2) and (2,3).
05:19:15 <lunaris> sipa: There's also IncoherentInstances ;)
05:19:25 <davesq> sipa: Understood. I guess I'm still thinking in terms of OO polymorphism (picks most specific overload).  I'll do some reading up on overlapping instances and try and get a better understanding of what's happening. Thanks for the help.
05:19:38 <zygoloid> Arney_: so you can split the problem into two parts: 1) finding the (x,z) pairs, and 2) checking they're all in r.
05:19:42 <sipa> lunaris: and UndecidableInstances
05:19:57 <zygoloid> Arney_: you can do part (1) with a list comprehension, but part (2) needs something else
05:20:31 <Bynbo7> lunaris: i think you need to either compile with -XPArr or add {-# LANGUAGE PArr #-} to the file using it
05:20:49 <Arney_> zygoloid: and [(x,x)`elem` r | x <- univ]
05:21:09 <Arney_> that checks if the stuff in univ is in R, I could use that.
05:21:36 <zygoloid> Arney_: something similar to that, yes.
05:22:37 <zygoloid> Arney_: except you want to use (x,z) pairs instead of (x,x) pairs, and pick the (x,z) pairs appropriately.
05:22:55 <Arney_> how would I do that in haskell...
05:23:19 <Arney_> without another function, I don't think the prof would like that
05:23:51 <zygoloid> Arney_: well, for each (x,z) pair, you're going to need to pull two elements from r, and check their 'y' values match up
05:24:20 <zygoloid> Arney_: in a list comprehension you can do that with something like this: [ ... | a <- x, b <- x, ... ]
05:25:00 <mux> > let pairs [] = []; pairs (x:xs) = map (\y -> (x,y)) xs ++ foo xs
05:25:01 <lambdabot>   not an expression: `let pairs [] = []; pairs (x:xs) = map (\y -> (x,y)) xs ...
05:25:02 <Arney_> taht means pop a and pop b?
05:25:09 <mux> @let pairs [] = []; pairs (x:xs) = map (\y -> (x,y)) xs ++ foo xs
05:25:09 <lambdabot>  <local>:4:54: Not in scope: `foo'
05:25:16 <mux> @let pairs [] = []; pairs (x:xs) = map (\y -> (x,y)) xs ++ pairs xs
05:25:17 <lambdabot>  Defined.
05:25:28 <mux> > pairs [(1,2),(3,4),(5,6)]
05:25:31 <lambdabot>   [((1,2),(3,4)),((1,2),(5,6)),((3,4),(5,6))]
05:25:34 <zygoloid> Arney_: it means, independently, take value a from list x, then (for each a) take value b from list x
05:26:00 <mux> Arney_: using this function 'pairs', it should be easy for you to deduce the rest
05:26:15 <zygoloid> > let x = [1,2,3] in [ (a,b) | a <- x, b <- x ]
05:26:17 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:26:39 <mux> (note, unordered pairs)
05:26:57 <mux> meaning (x,y) is the same as (y,x) and you don't want to handle both
05:27:25 <zygoloid> mux: that's going to make it harder to find the cases where one of the fsts is the same as the other one's snd...
05:27:27 <mux> if you need ordered pairs, it's even easier anyways
05:27:37 <mux> zygoloid: hmm?
05:28:08 <mux> Arney_: is your relation reflexive?
05:28:11 <nmkolev> can anyone point me to some HSH exmples, besides the ones at GitHub? I would like to pipe a string I have to an external command and redirect the output to a file.
05:28:19 <hape01> E.g. I have unpacked two packages, yesod and hamlet, each in one directory with an .cabal configuration file in it.
05:29:01 <hape01> When I do a cabal haddock --hyperlink-source      each documentations are generated and linked to their src-htmls
05:29:13 <Arney_> not always... What The function Is supposed to do is check if it is transitive
05:29:41 <hape01> but the yesod-html refers to hamlet-html, but the links in the html-files are wrong.
05:29:57 <hape01> how could I combine the htmlÂ´s out of multiple packages?
05:33:08 <hape01> I mean how can go the links to imported auxillary modules?
05:33:36 <hape01> e.g. module Yesod.Hamlet imports Text.Hamlet
05:35:32 <hape01> When I click on the "Source" Button in ...yesod-0.6.7\dist\doc\html\yesod\Yesod-Hamlet.html it refers to yesod-0.6.7\dist\doc\html\yesod\src\Text-Hamlet-Quasi.html   which is *not* existing *there*
05:36:49 <Entroacceptor> can I automate "cabal install" in such  a way I get automatic source code links, locally?
05:37:39 <hape01> Entroacceptor: As I know you can run "Cabal haddock --hyperlink-source"
05:37:44 <hape01> to produces src-links
05:39:46 <Entroacceptor> hape01: yes, I've seen that, but I install my packages via cabal install
05:40:13 <Entroacceptor> and I managed to automatically get haddocks from that; but as a lot of people think that the source is documentation, I'd like those links, as well
05:44:11 <hape01> Entroacceptor: How did you manage to run haddock on installed packages without unpacking them?
05:44:25 <Entroacceptor> hape01: I don't
05:44:37 <Entroacceptor> cabal builds the haddock while compiling
05:44:48 <hape01> I see
05:44:52 <Entroacceptor> and I'd like it to save the source somewhere, automatically
05:49:32 <Arney> pairs [(A,B),(B,E),(E,G)]
05:49:37 <inetic> adimit, Cale, if you were interested in what we discussed previously http://stackoverflow.com/feeds/user/273348
05:50:18 <inetic> adimit, Cale, eh, sorry: http://stackoverflow.com/questions/4828902/why-wrapping-the-data-binary-put-monad-creates-a-memory-leak
05:50:26 <Arney> [((A,B),(B,E)),((A,B),(E,G)),((B,E),(E,G))] the pair in the middle is a bad pair.
05:51:24 * hackagebot access-time 0.1 - Cross-platform support for retrieving file access times  http://hackage.haskell.org/package/access-time-0.1 (MaxBolingbroke)
05:51:59 <lunaris> Arney: are you asking for a solution to this problem?
05:52:20 <Arney> yes... Im overdue 20 hours on that homework.
05:52:50 <lunaris> Are you familiar with list comprehensions?
05:53:01 <Arney> too familiar
05:53:05 <lunaris> Lol
05:53:15 <lunaris> Well it's easily doable with a list comprehension.
05:53:22 <lunaris> pairs xs = ...
05:53:30 <lunaris> Where ... is a list comprehension
05:53:45 <lunaris> And pairs :: Eq a => [(a, a)] -> [((a, a), (a, a))]
05:54:16 <zygoloid> Arney: the two bits you have so far are: "and [ (x,z) `elem` r | ... ]", and "[ ... | a <- r, b <- r, ... ]". you could try combining those and filling in the blanks...
05:54:54 <lunaris> zygoloid: What's the question? Is the goal to produce a list of pairs or a Bool?
05:55:03 <zygoloid> lunaris: the goal is to produce a Bool.
05:55:27 <lunaris> zygoloid: When? When there are no ``bad pairs''?
05:55:31 <zygoloid> lunaris: the question is, given a finite relation expressed as a list of pairs, write a function to determine if the relation is transitive
05:55:36 <lunaris> Oh I see.
05:55:37 <lunaris> Ok.
05:57:57 <Arney> transitive r = and [ (x,z) `elem` r | a <- r, b <- r, ... ] Im off to calc..... this is breaking my balls.
05:58:18 <adimit> inetic: thanks :-)
05:58:33 <adimit> Sorry to not be able to help much further, I'm busy at work :-\
05:59:38 <inetic> adimit: no wories, thanks anyway
06:07:24 <hape01> Entroacceptor: It is not very short, but it works: when you unpack each package, then run cabal haddock --hyperlink-source  and then   cabal copy   then you got a centralized html site with sourcecodes linked
06:07:58 <hape01> someone here knowing a shorter way? to do this from the packages without unpacking?
06:14:03 <lpsmith>  #haskell-blah
06:16:19 <wferi> Hi! If I want to install a Haskell callback into a C library (which has an API function for installing C callbacks) should I look into the foreign import "wrapper" stuff?
06:16:37 <wferi> I want to export a haskell function, after all, not import something...
06:16:52 <Entroacceptor> hape01: mh, that's still too much work for my taste ;)
06:17:20 <wferi> But can I foreign export Haskell functions?
06:18:06 <Bynbo7> yes
06:21:30 <insane> As far as I know haskell uses a modification of Hindley-Milner algorithm for type inference. Let's say an inferer deduced that function foo is of type: a -> Int. Does the code generator define such function for each argument that the function is called with later on? Pretty much similar to what c++ templates does?
06:23:14 <sipa> insane: no
06:23:16 <Bynbo7> insane: it can do that if you specify the right pragmas for the function
06:23:27 <sipa> you can use the specialize pragma
06:23:47 <insane> okay, but if I don't use anything like that
06:23:54 <Bynbo7> if you inline a function, i can get specialised too
06:24:16 <Bynbo7> insane: in general no, though if the compiler knows the types it will be used for exactly, then it can
06:24:22 <sipa> but in general, if you have a function of type Num a => a -> Int, in reality two argument will be passed: 1) a dictionary for the Num instance of a, and 2) the argument itself
06:25:04 <mun> is \forall x. x = f(a) --> P(x) same as \exists x. x = f(a) & P(x)?
06:25:09 <Bynbo7> that only happens with expoerted functions i believe
06:25:17 <lunaris> mun: No
06:25:30 <lunaris> mun: The first does not imply the existence of such an x
06:25:34 <lunaris> mun: The second does
06:25:47 <lunaris> mun: I.e., the first is true even if there are no such xs such that x = f(a).
06:26:26 <mun> lunaris, right. then which one is equivalent to P(f(a))?
06:27:11 <lunaris> mun: (Hopefully) the latter, since a is known to exist.
06:27:30 <Bynbo7> Has anyone used the llvm bindings? I'm getting 'user error (Interpreter has not been linked in.)'
06:27:44 <Bynbo7> preflex: seen augustss 
06:27:44 <preflex>  augustss was last seen on #haskell 23 hours, 38 minutes and 9 seconds ago, saying: quuuux: probably
06:27:55 <Bynbo7> augustss: ping?
06:28:02 <lunaris> mun: Perhaps the difference would be illustrated by:
06:28:17 <lunaris> mun: \forall x. x = f(a) --> _|_
06:28:18 <lunaris> mun: vs
06:28:32 <lunaris> mun: \exists x. x = f(a) /\ _|_
06:28:36 <lunaris> The first could be true
06:28:38 <mun> lunaris, but then isn't "let x = f(a) in P(x)" equivalent to the first?
06:28:39 <lunaris> If there is no such x
06:28:44 <lunaris> But the second could never be true
06:29:36 <lunaris> mun: You're right; I'm wrong.
06:29:48 <lunaris> mun: I've overlooked the fact that f(a) might not be defined.
06:29:58 <lunaris> mun: I think. I'm not a logician.
06:30:18 <lunaris> The first says "if there is an x such that x equals f(a), then P(x) holds"
06:30:32 <mun> lunaris, but i'm convinced that the antecedent of the first could be false...
06:30:39 <lunaris> The second says "there *is* an x such that x equals f(a) and P(x) holds."
06:30:49 <mun> right
06:30:59 <lunaris> mun: If the antecedent is false, the whole implication is true.
06:31:09 <ClaudiusMaximus> argh, parsec is breaking my head - conceptually i want: stuff = do{ s <- foo `endBy` bar ; t <- baz ; return $ g s t }  but baz overlaps with foo so parse fails with "expected bar or some more foo"
06:31:10 <lunaris> mun: Assuming my terminology is correct.
06:31:15 <lunaris> mun: Which it may not be :/
06:32:09 <mun> lunaris, but then the second one would be true even if there exists only one such x.
06:32:27 <lunaris> mun: The second is true if there is at least one such x.
06:32:31 <mun> lunaris, so not necessarily for every single x = f(a), P(x) holds.
06:32:52 <lunaris> mun: Indeed, there may be another y such that y = f(a) but Â¬P(y)
06:32:55 <lunaris> Which is why I'm wrong.
06:33:12 <mun> then how would one logically represent let x=f(a) in P(x)?
06:33:35 <mun> universal quantification is implicit, right
06:35:07 <lunaris> mun: Is it not just P(f(a))?
06:35:19 <lunaris> mun: I'm not sure what you can say about the existence of x.
06:35:26 <lunaris> mun: But I'm not the guy to ask.
06:35:28 <lunaris> :/
06:35:29 <lunaris> Sorry
06:35:32 <mun> thanks anyway though
06:35:44 <Palmik> Hmm, I was trying to create my own instance of Exception sublass (merely using the default), for that it has to derive from Data.Typeable, so I did so and I get this complaint "(You need -XDeriveDataTypeable to derive an instance for this class)" is it normal to use this extension or is there something wrong on my side?
06:35:56 <lunaris> I'm only saying because the let doesn't introduce any constraint on the existence of x, right?
06:36:01 <lunaris> x could be undefined.
06:36:04 <lunaris> Just as f(a) could be.
06:36:08 <Botje> Palmik: perfectly okay.
06:36:16 <Palmik> ok, thanks :)
06:36:16 <lunaris> So the let is perhaps superfluous.
06:37:36 <mun> lunaris, so it sounds like it'd be ALL x. x = f(a) iff P(x)?
06:37:37 <Fabs> Hi guy's, im new totry haskell
06:37:55 <lunaris> mun: I'm not sure.
06:38:06 <lunaris> mun: Your let statement says nothing about when P(x) is true.
06:38:17 <Fabs> you okay?
06:38:25 <lunaris> mun: It doesn't say that if you can make the assignment x = f(a), then P(x).
06:39:51 <Fabs> so who can help me here???
06:40:00 <lunaris> mun: Perhaps it's worth mentioning that universal quantification is implicit at the type level.
06:40:07 <sipa> Fabs: just ask your question
06:40:09 <lunaris> mun: Which might be clouding the issue here.
06:40:10 <Botje> Fabs: if you have a question, just ask
06:40:13 <mun> lunaris, how is that?
06:40:37 <lunaris> mun: As in, in the type map :: (a -> b) -> [a] -> [b], there is an implicit \forall a b at the front.
06:41:31 <lunaris> mun: Though I suppose universal quantification may be valid at the value level too. I'm crap at this.
06:42:52 <mun> lunaris, oh yes. but then i can't quite see how implicitly quantifying over types will quantify over the values of f(a) in a let
06:43:20 <lunaris> mun: It won't; that's the point I think I'm trying to make.
06:43:28 <lunaris> mun: The let doesn't quantify anything.
06:44:47 <Botje> huh, fabs just left. ah well.
07:05:23 <chrisdone> what is one supposed to put in the passwd.rc file for lambdabot? I want to send a PASS command.
07:05:24 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:08:14 <chrisdone> don't taunt me, woman
07:10:18 <luite> hey chrisdone is back! \o/
07:10:37 <chrisdone> hi luite
07:10:57 <turiya> what is the easiest way to write a function, f i = sin i + r, where r is a random number?
07:11:12 <chrisdone> f r i = sin i + r
07:11:31 <chrisdone> a nice way is to use one of the random monads
07:12:14 <chrisdone> Control.Monad.Random for example http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
07:12:50 <turiya> chrisdone: i see..
07:13:27 <chrisdone> your function thus becomes f :: (Fractional a,RandomGen g) => a -> Rand g a
07:14:04 <chrisdone> perhaps lambdabot has it imported already to demonstrate
07:14:05 <chrisdone> :t Control.Monad.Random.evalRand
07:14:06 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
07:14:45 <turiya> i am a bit confused..
07:15:19 <Bynbo7> random numbers have to be treated a bit differently in haskell.
07:15:37 <turiya> the result of "f i" should be a Float (say)
07:15:42 <chrisdone> > Control.Monad.Random.evalRand (do a <- getRandomR (1,6); b <- getRandomR (1,6); return (a,b)) (mkStdGen 100)
07:15:43 <lambdabot>   (6,3)
07:16:01 <Bynbo7> since you can't have a (pure) function which returns a different value each time you call it, you can't write a function like f i = sin i + random()
07:16:50 <turiya> Bynbo7: the function need not return different values at different times..
07:16:58 <chrisdone> @let f i = do r <- getRandomR (1,100); return (sin i + r)
07:17:00 <lambdabot>  Defined.
07:17:06 <chrisdone> > evalRand (f 10) (mkStdGen 100)
07:17:07 <lambdabot>   Ambiguous occurrence `f'
07:17:07 <lambdabot>  It could refer to either `L.f', defined at <local...
07:17:14 <chrisdone> Buh.
07:17:15 <luite> turiya: oh, then the easiest way is: f i = sin i + 4
07:17:22 <chrisdone> @let turiya i = do r <- getRandomR (1,100); return (sin i + r)
07:17:23 <lambdabot>  Defined.
07:17:29 <luite> where 4 is a very random number
07:17:43 <chrisdone> > evalRand (do x <- turiya 10; y <- turiya 10; return (x,y)) (mkStdGen 100)
07:17:45 <lambdabot>   (18.791564451817457,95.87792742329614)
07:17:50 <chrisdone> turiya: how's that?
07:17:57 <turiya> luite: :). i have some other constraints on the "random" number
07:18:12 <lunaris> luite: It must be 3.
07:18:21 <zygoloid> chosen by fair dice roll?
07:18:30 <luite> lunaris: 4 is way more random than 3
07:18:33 <chrisdone> turiya: you provide the evalRand monad runner a random number generator, in this case I'm using mkStdGen and providing it with a seed
07:19:03 <chrisdone> turiya: but you can use ones based on time or /dev/urandom, or whatever. instances of the RandomGen class: http://hackage.haskell.org/packages/archive/random/1.0.0.2/doc/html/System-Random.html#t:RandomGen
07:19:48 <lunaris> luite: No it's not. Assume for the purposes of contradiction that 4 is more random than 3. Then we'd expect 4 to crop up in 3's place, because it is random. But it didn't. 3 did, because it's random. Therefore 3 is more random that 3 (case in point).
07:19:59 <lunaris> QED
07:20:04 <lunaris> Â¬_Â¬
07:20:09 <chrisdone> turiya: (you can't of course generate random numbers inside a pure function otherwise it wouldn't be pure)
07:21:03 <chrisdone> so using monadrandom is essentially a more convenient way to say f r i = sin i + r, where r is the random number
07:21:58 <turiya> chrisdone: i guess i am a bit slow here. I will read through the Random monad first..
07:22:07 <Bynbo7> @google what is the most random number
07:22:08 <lambdabot> http://scienceblogs.com/cognitivedaily/2007/02/is_17_the_most_random_number.php
07:22:08 <lambdabot> Title: Is 17 the "most random" number? : Cognitive Daily
07:22:25 <Bynbo7> chosen by fair academic study
07:22:42 <jonkri> http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-String-UTF8.html#v:uncons gives us a Maybe (Char, UTF8 string); is there a function that returns a tuple with all available characters and the rest (incomplete utf8 character data)
07:22:52 <turiya> i wanted a bunch of numbers with approximate "norm" of one..
07:23:38 <chrisdone> turiya: oh, alternatively you can generate a list of random numbers trivially
07:23:40 <chrisdone> :t randomRs
07:23:41 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
07:24:04 <turiya> chrisdone: can i generate Gaussian's?
07:24:11 <chrisdone> :t randomRs (1,100) (getStdGen 123)
07:24:12 <lambdabot>     Couldn't match expected type `t -> g'
07:24:12 <lambdabot>            against inferred type `IO StdGen'
07:24:12 <lambdabot>     In the second argument of `randomRs', namely `(getStdGen 123)'
07:24:16 <aristid> chrisdone: i think haskell98 fucked up the interface for random numbers.
07:24:19 <chrisdone> woops
07:24:21 <Bynbo7> jonkri: any reason you're not using Text?
07:24:22 <chrisdone> :t randomRs (1,100) (mkStdGen 123)
07:24:23 <lambdabot> forall t. (Num t, Random t) => [t]
07:24:40 <chrisdone> > randomRs (1,100) (mkStdGen 123)
07:24:41 <lambdabot>   [6,68,70,93,13,33,33,26,71,27,2,69,18,78,98,37,6,86,52,16,70,82,83,94,85,72...
07:24:46 <aristid> :t split
07:24:47 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
07:25:19 <chrisdone> turiya: I have no idea
07:25:33 <aristid> :t \g -> let (g1, g2) = split g in (randoms g1, randoms g2)
07:25:34 <lambdabot> forall t a a1. (RandomGen t, Random a, Random a1) => t -> ([a], [a1])
07:25:42 <aristid> @let dup a = a *** a
07:25:44 <lambdabot>  Defined.
07:25:48 <aristid> :t dup
07:25:50 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:25:50 <turiya> i found getGaussian in GSL.Random.Dist
07:26:06 <aristid> :t dup randoms
07:26:07 <lambdabot> forall b a. (Random a, RandomGen b) => (b, b) -> ([a], [a])
07:26:09 <turiya> but I dont fully understand how to mix pure and impure code
07:26:31 <aristid> :t dup randoms . split
07:26:32 <lambdabot> forall b a. (Random a, RandomGen b) => b -> ([a], [a])
07:26:38 <turiya> :i getGaussian
07:26:42 <turiya> oops
07:26:54 <turiya> @src getGaussian
07:26:55 <lambdabot> Source not found. Sorry.
07:27:06 <ski> @index getGaussian
07:27:07 <lambdabot> bzzt
07:27:47 <chrisdone> turiya: typically you have an outer shell of impurity and a large inner core of purity. impurity is zombies, purity is Ash Williams.
07:28:12 <chrisdone> how do I send a raw IRC command with lambdabot's internal rc command set?
07:28:53 <chrisdone> irc-connect dev myserveru 6667 lambdabot lambdabot
07:28:53 <chrisdone> # what do I put here?
07:28:54 <chrisdone> admin + freenode:me
07:28:54 <chrisdone> join dev:#mychannel
07:28:56 <chrisdone>  
07:28:57 <copumpkin> oh wow
07:28:59 <copumpkin> chrisdone is back
07:29:03 <copumpkin> yay
07:29:18 <chrisdone> not really I just can't figure this out myself
07:29:45 <chrisdone> buh I'll just patch the source
07:29:52 <jonkri> Bynbo7: not really. it was not part of a haskell utf-8 library comparison page. the thing is that i need to be able to convert partial strings (such as a couple of utf-8 characters and an incomplete character), and save the incomplete character data so that i can use that the next time data is received
07:30:43 <Bynbo7> jonkri: sounds like this might be a good case for using attoparsec.
07:31:36 <ski> mun : yeah .. total functions, not partial ones
07:32:02 <mun> ski, yep
07:32:23 <ski> (having partiality is a side-effect)
07:40:16 <jonkri> Bynbo7: will give it a shot. thanks
07:41:16 <Bynbo7> jonkri: I'm hoping there's already some well written library to do exactly what you want, because working with unicode directly would be a complete pain
07:45:24 <jonkri> yeah, i wont do that
07:46:27 <jonkri> text doesn't seem to be able to do these "partial" conversions... maybe http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-String-UTF8.html#v:uncons is my best bet after all
07:55:54 <earthy> jonkri: your main problem is determining utf-8 boundaries then, right?
07:56:44 <earthy> but you don't seem to have a need to deal with complete utf-8 encoded texts?
07:57:03 <aristid> :t randoms
07:57:04 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
07:57:07 <Bynbo7> jonkri: the point of my suggesting attoparsec is that it handles receiving partial inputs from bytestrings
07:57:10 <aristid> :t unzip . randoms
07:57:11 <lambdabot> forall a b g. (Random (a, b), RandomGen g) => g -> ([a], [b])
07:57:38 <aristid> woot, no instance for tuples? fail!
07:58:55 <Veinor> @instances Random
07:58:56 <lambdabot> Couldn't find class `Random'. Try @instances-importing
07:59:03 <Veinor> @help @instances-importing
07:59:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:59:24 <Veinor> @instances-importing System.Random Random
07:59:25 <lambdabot> Bool, Char, Double, Float, Int, Integer
07:59:32 <Veinor> really? :(
07:59:44 <Veinor> i'd almost say that's a bug
08:00:05 <copumpkin> omg a bug?
08:00:14 <cconnett> @instances-importing Functor
08:00:14 <luite> why isn't () an instance of random? :(
08:00:15 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
08:00:33 <copumpkin> preflex: seen chrisdone
08:00:34 <preflex>  chrisdone was last seen on #haskell 30 minutes and 49 seconds ago, saying: buh I'll just patch the source
08:00:38 <copumpkin> damn, he left already
08:00:55 <aristid> copumpkin: timing fail :>
08:01:25 <aristid> Veinor: it's unbelievable that () is not instance of Random either
08:01:52 <Veinor> yeah
08:04:30 <aristid> hmm, making a random package much like random-fu but with fewer dependencies, that might be useful *add to mental list of ideas*
08:05:25 <aristid> without a single class "Random", but rather supporting different distributions (uniform distribution, normal distribution...)
08:05:36 <jonkri> earthy: i just want to convert an incoming stream to utf-8 encoded haskell bytestrings so that i can xml parse it properly
08:08:17 <luite> aristid: a class for each type of distribution?
08:09:33 <aristid> luite: well, maybe.
08:10:16 <luite> hmm, would make it rather complicated
08:10:30 <ski> @help help
08:10:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:10:35 <ski> @help instances-importing
08:10:36 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
08:13:44 <MenTaLguY> what's the lambdabot command to invent a function matching the given tyep?
08:13:46 <MenTaLguY> er, type?
08:13:57 <Tomsik> @djin a->a
08:13:58 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
08:14:02 <Tomsik> @djinn a->a
08:14:03 <lambdabot> f a = a
08:14:06 <Tomsik> yeah, this
08:14:19 <ski> @djinn Bool
08:14:19 <lambdabot> f = False
08:14:28 <Veinor> how do you write dynamically loadable plugins in a compiled language?
08:14:29 <MenTaLguY> ah, thank you
08:14:40 <Veinor> in an interpreted language you'd just eval them
08:14:42 <ski> @help djinn-env
08:14:43 <lambdabot> djinn-env.
08:14:43 <lambdabot> Show the current djinn environment
08:15:16 <Bynbo7> @djinn-env
08:15:16 <lambdabot> data () = ()
08:15:16 <lambdabot> data Either a b = Left a | Right b
08:15:16 <lambdabot> data Maybe a = Nothing | Just a
08:15:20 <MenTaLguY> Veinor: broadly speaking, you have some abstract interface that the plugin implements/provides
08:15:23 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:15:26 <lambdabot> data Identity a = Identity a
08:15:30 <lambdabot> class Functor f where fmap :: (a -> b) -> f a -> f b
08:15:36 <MenTaLguY> Veinor: the existing program only knows (statically) about that interface
08:16:08 <Veinor> MenTaLguY: hm.
08:16:50 <Bynbo7> @djinn-add class Monad m where bind :: m a -> (a -> m b) -> m b; return :: a -> m a
08:16:56 <Bynbo7> @djinn-env
08:16:57 <lambdabot> data () = ()
08:16:57 <lambdabot> data Either a b = Left a | Right b
08:16:57 <lambdabot> data Maybe a = Nothing | Just a
08:17:00 <MenTaLguY> Veinor: as far as it pertains to Haskell specifically: http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
08:17:03 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:17:05 <lambdabot> data Identity a = Identity a
08:17:07 <lambdabot> class Monad m where bind :: m a -> (a -> m b) -> m b; return :: a -> m a
08:17:09 <lambdabot> class Functor f where fmap :: (a -> b) -> f a -> f b
08:17:16 <ski> @djinn Monad m => a -> m a
08:17:17 <lambdabot> f = return
08:17:19 <ski> @djinn Monad m => b -> m b
08:17:19 <lambdabot> -- f cannot be realized.
08:17:24 <Bynbo7> heh
08:17:46 <ski> @djinn Monad n => a -> n a
08:17:46 <lambdabot> f = return
08:18:03 <Veinor> of course dons wrote it
08:18:37 <ski> augustss wrote djinn
08:19:30 <Veinor> i meant 'of course dons wrote hs-plugins'
08:20:50 <ski> oh
08:22:12 <Heffalump> the plugins mechanism also has to have some knowledge of the ABI of the compiler
08:24:09 * hackagebot tagged-transformer 0.2 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.2 (EdwardKmett)
08:28:54 <Veinor> alternate option: write a DSL
08:36:15 <firefly_> ?
08:38:40 <teki> why is Infinity not a data constructor for Double?  every time i want to use an infinite value i have to do read "Infinity" :: Double
08:38:55 <teki> which is not an optimal solution
08:39:05 <mauke> no, you don't
08:39:12 <mauke> just do 'infinity = 1/0' once
08:39:51 <teki> well darn i didn't think about breaking the maths system
08:40:00 <teki> that's a pretty hindsight-obvious solution
08:41:28 <chrisdone> any lambdabot people around? I want to know how to make lambdabot pay attention to '>', ':t', '@foo' etc in a channel that it joins. because at the moment it only works if I tell it to join a channel named '#haskell'. I grepped the hell out of the sources and can find no special case for '#haskell' yet it only works for it
08:43:17 <chrisdone> this software is enraginly difficult to get into a working state
08:45:50 <Saizan> chrisdone: how did you make it join? it always worked directly after a @join #foo for me
08:46:22 <chrisdone> I'm putting: join dev:#lambdabot in my online.rc
08:46:27 <chrisdone> I will try @join
08:46:31 <Saizan> chrisdone: are you sure lambdabot is allowed to send messages to that channel?
08:47:09 <Saizan> join net:#chan in the .rc is equivalent
08:47:11 <chrisdone> Saizan: no, I'm not. other than telling it to join, how do I tell it that it's allowed?
08:47:16 <chrisdone> -_- done that
08:47:46 <Saizan> no, i meant, e.g. some channels won't allow messages from unregistered users
08:48:22 <chrisdone> no, there is nothing like that
08:48:50 <Saizan> does it work in private?
08:48:51 <chrisdone> if I change #lambdabot to #haskell, it responds
08:49:01 <chrisdone> yes, in private
08:49:40 <Saizan> mh, have you tried another channel? neither #haskell nor #lambdabot?
08:50:06 <Saizan> (maybe the special casing is on its own nickname..)
08:50:13 <chrisdone> I will try #saizanthegreat
08:50:28 <chrisdone> oh, it works
08:50:33 <chrisdone> -______________-
08:50:48 <chrisdone> Saizan: thanks :-)
08:50:54 <Saizan> np
08:51:19 <chrisdone> I'm sure someone somewhere thought it was a good idea to block its own nick and I hope they're proud of themselves for wasting hours of my time. *shakes fist*
08:51:24 <Saizan> i guess someone tried too hard to ignore messages from the bot itself
08:53:10 <Saizan> (the irc server won't resend your messages to yourself anyhow, iirc)
08:53:22 <aristid> copumpkin: did you see that chrisdone returned?
08:53:53 <chrisdone> Saizan: they do
08:54:01 <chrisdone> (try it)
08:54:11 <sipa> no
08:54:25 <sipa> the irc server doesn't echo your own messages
08:54:41 <chrisdone> sipa: he means that '/msg lambdabot hi' from lambdabot sends the message to himself
08:54:53 <chrisdone> servers do that
08:55:02 <sipa> oh, yes, that's true
08:55:20 <sipa> if you send a message to yourself specifically, yes
08:55:24 <sipa> but not in channels
08:55:58 <chrisdone> yup
08:57:19 * chrisdone wrote an ircd recently so this is fresh in his mind
09:02:19 * hackagebot attoparsec-text 0.8.2.0 - Fast combinator parsing for texts  http://hackage.haskell.org/package/attoparsec-text-0.8.2.0 (FelipeLessa)
09:11:02 <Saizan> i actually meant what sipa understood
09:11:18 <greap> Ah, I just wanted quickcheck-script
09:11:28 <Saizan> but the coder might had in mind the other implementation
09:12:27 <Saizan> *interpretation
09:17:58 <jonkri> i must be stupid or something, but i don't understand how to use join or intercalate to join two bytestrings together (append one to the other)
09:18:34 <Saizan> ?type Data.ByteString.join
09:18:35 <lambdabot> Not in scope: `Data.ByteString.join'
09:18:39 <Saizan> ?type Data.ByteString.Char8.join
09:18:40 <lambdabot> Not in scope: `Data.ByteString.Char8.join'
09:19:11 <Saizan> if it's Control.Monad.join it has nothing to do with joining bytestrings
09:19:36 <Saizan> jonkri: i think you want append.
09:22:19 <jonkri> zomg... sorry. i thought i searched the docs for append :S
09:26:26 * hackagebot FileSystem 1.0.0 - File system data structure and monad transformer.  http://hackage.haskell.org/package/FileSystem-1.0.0 (DanielDiaz)
09:35:27 <hatds> I am curious if other any haskellers feel that using "plain datatypes" (non-records) are preferable to records even when there are many fields
09:36:14 <monochrom> most add fields. but go with your heart.
09:37:00 <hatds> I do, but what about everyone else? :)
09:38:04 <mm_freak_> hatds: fields are optional extra convenience
09:38:24 <mm_freak_> date Point a = Point { pointX :: a, pointY :: a }
09:38:29 <mm_freak_> you can still write Point 3 4
09:38:40 <mm_freak_> and pattern-match against Point x y
09:38:56 <alpounet> fields just add functions that fetch the values
09:39:12 <mm_freak_> alpounet: they do a bit more
09:39:14 <alpounet> here you have two Point a -> a functions for free
09:39:22 <hatds> the question is about the view that fields (as replacements for 'struct-like datatypes' with many fields) are more of an optional inconvenience than convenience
09:39:39 <alpounet> yeah sure
09:40:04 <ClaudiusMaximus> data Point a = Point{ pointX, pointY :: a } -- i think this is also allowed, which makes life nicer
09:40:18 <ClaudiusMaximus> and if it isn't allowed, it should be!
09:40:43 <hatds> but you really want to call those values 'x' and 'y', not  "pointX p" or "P.x p"
09:40:54 <mm_freak_> hatds: how can fields be inconvenient?
09:41:05 <hatds> mm_freak: see above
09:41:17 <mm_freak_> hatds: i call them pointX and pointY to avoid name clashes
09:41:49 <jonkri> how can "PortNumber 5222" work, but not PortNumber (5222 :: Int) or PortNumber (5222 :: Integer)? checking the type of "5222" returns a Num t => t... port number has the following instances: http://cvs.haskell.org/Hugs/pages/libraries/network/Network.html#t%3APortNumber
09:41:53 <hatds> an inconvenient necessity of records imho
09:42:02 <mm_freak_> (and no, i don't view the module system as a suitable solution)
09:42:52 <hatds> variable patterns (Point x y) let you use 'x' and 'y' in a way that is rather flexible/resistant to name clashes
09:43:18 <mm_freak_> jonkri: a PortNumber takes an argument of type PortNumber, not Int
09:43:21 <mm_freak_> or Integer
09:43:47 <mm_freak_> jonkri: if you write only "5222", then haskell syntax uses fromIntegral to convert this to a PortNumber
09:43:57 <mm_freak_> because PortNumber is an instance of Num
09:44:55 <mm_freak_> hatds: my point is that you can use both
09:45:16 <mm_freak_> hatds: when pattern-matching, you can still use normal pattern variables
09:45:28 <hatds> jonkri: in other words  PortNumber (5222 :: Int) = PortNumber (fromInteger {- ::Integer ->Int -} 5222)
09:45:30 <mm_freak_> case p of Point x y -> â¦
09:45:51 <hatds> I know record-declared datatypes can always be used as normal
09:46:32 <hatds> I'm wondering how common it is to ignore record-usage all together
09:47:08 <mm_freak_> not very common (except haskell beginners perhaps)
09:47:49 <hatds> that's been my take as well
09:48:19 <mm_freak_> interestingly i found it much more important to add a record field to newtypes than to datas
09:48:27 <hatds> agreed
09:50:07 <syntaxfree> I declare a sum datatype and derive an Eq instance;
09:50:14 <jonkri> thanks mm_freak_ and hatds 
09:50:24 <syntaxfree> data X = This | That | TheOther deriving (Eq, Show)
09:50:31 <syntaxfree> then I have another datatype
09:50:44 <syntaxfree> data Y a = Y a deriving (Eq, Show)
09:51:09 <syntaxfree> how come I don't have a show instance for  Y X?
09:52:19 <ski> you should get `Show X' as well as `Show a => Show (Y a)' instances, from which `Show (Y X)' should follow
09:53:30 <Bynbo7> syntaxfree: you should be able to un show (Y This) just fine
09:53:50 <need4steed> Could anybody please tell me what do the "??" and "?" from  "(->) :: ?? -> ? -> *" mean?
09:54:26 <hatds> for the simplest level of understanding, ? and ?? are like *
09:54:28 <ski> need4steed : they are for unboxed types .. if you don't need those, you can imagine they had been `*', instead
09:54:32 <mm_freak_> need4steed: they generalize *
09:55:16 <ski> `??' is a superkind of `*' and `#'. `?' is a superkind of `??' and `(#)'
09:55:45 <ski> @kind GHC.Prim.Int#
09:55:45 <ski> @kind (# , #)
09:55:46 <lambdabot> #
09:55:47 <lambdabot> ? -> ? -> (#)
09:56:11 <syntaxfree>  I'm also struggling to find a short function that will take a list with repeated elements and return a list of pairs (Unique element, number of occurences)
09:56:29 <copumpkin> yay chrisdone returned
09:56:31 <copumpkin> oh shit he's gone again
09:56:59 <need4steed> the example out of LYAHFGG "fmap (*3) (+100) 1" doesn't work ,so i checked the kind. And got '?' which i don't understand
09:57:27 <hatds> map f . group . sort where f xs = (head xs, length xs)
09:57:35 <syntaxfree> SORT. yes.
09:57:46 <ski> @instances Functor
09:57:47 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:57:51 <syntaxfree> damn, I feel stupid.
09:58:25 <hatds> honestly I never use sort for anything *but* functions like these
09:58:34 <mm_freak_> > (head &&& length) . group . sort $ "aaabbcddddccaaee"
09:58:37 <lambdabot>   ("aaaaa",5)
09:58:45 <mm_freak_> > map (head &&& length) . group . sort $ "aaabbcddddccaaee"
09:58:48 <lambdabot>   [('a',5),('b',2),('c',3),('d',4),('e',2)]
09:58:51 <jonkri> how can i use ByteString.append (or any other non-io function) in a do block?
09:58:56 <syntaxfree> that versio has the same problem of the version I had, which used nub.
09:59:07 <syntaxfree> it runs against the monomorphism restriction.
09:59:20 <mm_freak_> jonkri: you can use everything in a do-block, as long as you use it properly
09:59:26 <syntaxfree> @type &&&
09:59:27 <lambdabot> parse error on input `&&&'
09:59:28 <joaopizani> syntaxfree: that should help you -  encode xs = [(length x, head x) | x <- group xs]
09:59:36 <mm_freak_> :t (&&&)
09:59:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:59:39 <Tomsik> What's haskell operator is mediator?
09:59:44 <joaopizani> syntaxfree: doesn't bump into the monomorphism restriction
09:59:45 <syntaxfree> :t group 
09:59:46 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
10:00:06 <Tomsik> med f g = \(a,b) -> (f a, g b)
10:00:11 <joaopizani> syntaxfree: yes, it groups consecutive elements into sublists
10:00:13 <ski> need4steed : hm, the relevant `Functor ((->) rho)' instance is hiding somewhere .. at least in `Control.Monad' .. i'm not sure if there's a better module
10:00:18 <Tomsik> I'm pretty sure there is something like that in arrows?
10:00:35 <mm_freak_> Tomsik: what's a mediator?
10:00:52 <Tomsik> like in category theory
10:01:03 <Tomsik> It's just what I wrote, basically
10:01:07 <mm_freak_> ah, okâ¦  then i'm out =)
10:01:13 <ski> @src (->) (***)
10:01:14 <syntaxfree> it always confuses me that Haskell Arrows are not cat theory arrows.
10:01:14 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
10:01:18 <mm_freak_> oh
10:01:22 <Tomsik> thanks ski
10:01:32 <mm_freak_> didn't see your function
10:01:35 <Tomsik> @type ski
10:01:36 <lambdabot> Not in scope: `ski'
10:01:37 <Tomsik> whops
10:01:40 <Tomsik> @type (**)
10:01:41 <lambdabot> forall a. (Floating a) => a -> a -> a
10:01:43 <Tomsik> @type (***)
10:01:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:01:50 <syntaxfree> Are they even used anymore? Every "real" Haskell code I see is full of Applicative and functor transformers.
10:02:10 <mm_freak_> syntaxfree: "they"?
10:02:15 <mm_freak_> ah
10:02:15 <Tomsik> applicative is kind of nice
10:02:24 <ski> mm_freak_ : you know .. *they*
10:02:25 <syntaxfree> they = Arrows.
10:02:35 <hatds> I think there are a few high profile projects that use them and it's never been much more than that
10:02:50 <mm_freak_> syntaxfree: if you like the Arrow pattern, you can use itâ¦  personally i prefer the functor/monad pattern
10:03:01 <Tomsik> AFAIK arrows are slow
10:03:08 <mm_freak_> but i've used at least two libraries, which use them
10:03:13 <Tomsik> lots of (,) construction and deconstruction
10:03:14 <mm_freak_> hakyll and yampa
10:03:29 <syntaxfree> I never understood Arrows to be honest
10:03:38 <jonkri> mm_freak_: ahh, "let" :)
10:04:09 <mm_freak_> syntaxfree: arrows are to functions what monads are to values
10:04:35 <syntaxfree> when I "left" Haskell, GHC 6.2 was the newest new thing, and  I was messing with probability monads.
10:04:53 <mm_freak_> 'arr' corresponds to 'pure'/'return' and (.) corresponds to (=<<)
10:04:54 <syntaxfree> it was a weird time in my life.
10:04:58 <joaopizani> syntaxfree: Welcome to the wonderful world of GHC 7 :P
10:05:15 <mm_freak_> and because you're dealing with functions, you get some nice extra stuff like 'first'
10:05:37 <hatds> If you understand arrows with (->) then you understand arrows in my experience.  Devoting time reading about them doesn't enrich the picture substantially, at least in my experience.
10:06:07 <azaq23> mm_freak_ don't you mean (>>>) instead of (.) (Or do you mean Control.Category.(.)? Is (>>>) = Control.Category.
10:06:14 <mm_freak_> in my experience it's like with monads:  you learn by quantity, not by quality
10:06:24 <azaq23> * (>>>) = flip Control.Category.(.)?)
10:06:26 <mm_freak_> azaq23: (>>>) = flip (.)
10:06:31 <ski> azaq23 : s/Control.Category.(.)/(Control.Category..)/
10:06:35 <mm_freak_> at least in newer base libraries
10:06:44 <ski> @type Control.Category.(.)
10:06:45 <lambdabot> Couldn't find qualified module.
10:06:47 <ski> @type (Control.Category..)
10:06:48 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
10:07:03 <syntaxfree> I understood monads after seeing that russian tutorial that build them in terms of cat theory.
10:07:12 <mikeg> I'm trying to use Data.Binary.Get.getLazyByteStringNul (http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/src/Data-Binary-Get.html#getLazyByteStringNul), and it looks like it just chops off the head of the string for no reason
10:07:23 <mikeg> Why?
10:07:34 <syntaxfree> I have a good intuition for cat theory. And no formal CS training.
10:07:43 <azaq23> ski thanks for correcting that, mm_freak_ yes but the Control.Category one, I suppose. Has to be true. Arrows suddenly make a lot more sense.
10:07:57 <syntaxfree> I even wrote a monad tutorial once. It's a rite of passage.
10:08:34 <syntaxfree> http://patryshev.com/monad/m-intro.html <-- this made me understand monads.
10:08:56 * ski supposes he's never truly passed into Haskell, then ..
10:11:38 <ski> (i suppose this might be a good time for someone to mention byorgey's complaint about those things)
10:11:42 * hackagebot hjson 1.3.1 - JSON parsing library  http://hackage.haskell.org/package/hjson-1.3.1 (JaroslavGridin)
10:11:49 <Tomsik> Everyone writes monad tutorials, why, I cannot understand
10:12:06 <hatds> syntaxfree: the difference in your experiences with studying arrows and monads (and mine was the same) boils down to 1) there are many commonly useful monads and 2) plenty of the standard datatypes define monads.  For arrows, there is only (->)
10:12:11 <mrd> Tomsik: it's how you join the community
10:12:57 <azaq23> I explained monads in irc in an attempt to get autocorrected when I first joined and I did not, does that count?
10:13:05 * ski has never been afflicted by that
10:14:07 <uart14> Tomsik, because once you understand them they are blatantly simple, but the tutorials seem unnecessarily involved.
10:14:13 <hatds> saying "writing monad tutorials is a rite of passage" is a rite of passage for people trying to jazz up the opening paragraph of their monad tutorials
10:18:48 <Tomsik> I had the pleasure to attend a "use of category theory in program construction" course this semester :p
10:19:15 <Tomsik> But really, before this, monads didn't appear to me as something complicated
10:19:34 * ski remembers looking at a book called "Categories for Software Engineering", or something like that
10:19:48 <uart14> Tomsik, and now they do?
10:20:06 <syntaxfree> hatds: I can't add another layer of meta to that joke. I think you have an eigenjoke.
10:20:35 <uart14> syntaxfree, I think you just contradicted yourself
10:20:36 <hatds> heh :)
10:20:53 <syntaxfree> uart14: have I?
10:21:08 <Tomsik> Nay
10:21:28 <uart14> syntaxfree, You made a joke about hatds joke, isn't that a metajoke?
10:21:31 <hatds> it wasn't even really intended to be that meta, but all monad jokes end up that way
10:21:49 <syntaxfree> uart14: yes, but not a metajoke about monad tutorials.
10:22:20 <uart14> uart14, Actually, you made a joke about not making a joke, that adds 2 level of meta at the same time. I'm impressed.
10:22:39 <syntaxfree> note that what you're saying is that if v is an eigenvector of A, there's no transformation B where B(v) is defined.
10:23:23 <syntaxfree> uart14: or are you impressed with your ability to fish out those layers and be impressed?
10:23:38 <uart14> syntaxfree, Ah, now you trying too hard ;)
10:23:45 <Tomsik> Geez people
10:23:46 <uart14> are*
10:23:52 <Tomsik> it's higher-order jokes, not metajokes
10:23:54 <syntaxfree> yes, but trying too hard doesn't mean I'm failing!
10:24:24 <syntaxfree> a higher-joke is still a joke. a metajoke might not be funny.
10:24:41 <Tomsik> a regular joke might not be funny either
10:24:55 <syntaxfree> some metajokes are higher-order jokes, and every higher-order joke is a metajoke.
10:25:28 <syntaxfree> a joke is funny by definition, silly. That's like invoking the frakking Russel paradox in order to demolish a building.
10:25:51 <syntaxfree> s/Russel/Russell/
10:25:59 <Tomsik> .wik joke
10:26:05 <Tomsik> damn
10:26:09 <ski> @wiki joke
10:26:09 <lambdabot> http://www.haskell.org/haskellwiki/joke
10:26:48 <Tomsik> "A joke is a question, short story, or depiction of a situation made with the intent of being humorous."
10:26:54 <Tomsik> /intent/
10:26:59 <Tomsik> http://en.wikipedia.org/wiki/Joke
10:27:04 <syntaxfree> I once wrote a short story where the main character turned out to be metafictional.
10:27:13 <uart14> syntaxfree, A joke might be funny to some people but not to others, and we don't know before we tell them. Please ad the reference to Schrödinger yourself. 
10:27:37 <Tomsik> Joke is funny and not funny, until told?
10:27:40 <syntaxfree> uart14: I hate how people equate uncertainty = quantum entanglement.
10:27:45 <syntaxfree> uncertainty = probability.
10:28:01 <Tomsik> It's superposition, not entanglement
10:28:10 <ion> A Finn and a Russian went to sauna. The Russian died.
10:28:17 <syntaxfree> tomsik: sorry. I was in the middle of hating.
10:29:10 <syntaxfree> that's an co-joke, also known as anti-joke and non-joke. I love those
10:29:49 <dpratt71> if I use a function that is defined for a certain type class (e.g. Fractional), how does Haskell decide what data type to use in practice?
10:29:58 <ion> syntaxfree: Do you mean mine?
10:30:17 <azaq23> dpratt71 defaulting
10:30:26 <syntaxfree> do you know what you call the subspace spanned by a subset of the canonical basis vectors of the co-joke space?
10:30:27 <ski> dpratt71 : it infers it from context
10:30:49 <syntaxfree> (infinite-dimensional co-joke space, I mean)
10:31:05 <duckinator> hi
10:31:07 <ski> defaulting is only used if it actually has to choose a specific type, and it can't be inferred which to choose
10:31:10 <uart14> dpratt71, It looks at how you use it. If your usage is ambiguous it will use default types, if there is no default for the class it will error out
10:31:32 <syntaxfree> someone please say something that will lead me on to answer my bizarre question with the punchline.
10:31:46 <dpratt71> ok, I guess I just need to find docs for Haskell default types then
10:31:49 <ski> uart14 : or simply add a class constraint
10:31:55 <Tomsik> syntaxfree: Huh?
10:32:20 <dpratt71> ski: to that point, what's the most convenient way to use class constraints in ghci?
10:32:36 <ski> how do you want to use them ?
10:33:25 <ski> (typically they use themselves, with you not having to do anything special)
10:33:37 <uart14> ski, dpratt71 Yes, it will only error if you force it to choose one, not if it can get away with adding a constraint to the type. "show . fromIntegral " would be problematic if there were not default types for Num
10:33:56 <uart14> singular, actually
10:34:02 <uart14> default type*
10:38:53 <syntaxfree> Tomsik: the aristocrats!
10:42:00 <dpratt71> ski: sorry, somehow I missed your question about my question; I've managed to solve my immediate problem, but I think I need to educate myself a bit on Haskell numeric type classes
11:03:58 <shamster> hi all - very new to haskell and I've got a question: what is the <- in list comprehensions? I think of it as "x <- some_list" meaning "for x in some_list". Is that about right?
11:04:20 <shamster> somewhat like the python way of reading it
11:04:36 <dafis> it's about right
11:04:59 <shamster> thanks
11:05:01 <dafis> it's more general than for lists
11:05:27 <shamster> I haven't read of other uses yet... still on the first leg of the trip ;)
11:05:54 <dafis> shamster:  you'll come across it later ;)
11:06:10 <dafis> shamster:  don't worry 'bout it yet
11:06:31 <shamster> dafis: I'm sure. I've got a decent lisp and python background, but do most of my coding in c++. I just heard a lot of clamor about haskell recently and decided to jump onboard
11:07:08 <dafis> shamster:  Good. In any case, Haskell has by far the best community
11:07:27 <digitteknohippie> ^^^^^^^^^ agreed, from my experiences.
11:07:29 <shamster> dafis: so far so good :)
11:08:02 <shamster> dafis: the c++ channel has a lot of noise and a good amount of ego
11:08:18 <shamster> dafis: anything is a welcome change!
11:08:20 <dafis> shamster:  we have noise here too, but not too much ego
11:08:40 <shamster> let haskell = succ c++
11:08:51 <shamster> okay, back to reading this tutorial
11:08:55 * digitteknohippie lubs the inteligent gentle folk of haskell, who have never scared him away for his foolishness.
11:09:01 <dafis> which one?
11:09:14 <shamster> dafis: learn you a haskell for great good
11:09:21 <dafis> ah, good
11:09:31 <uart14> shamster, btw. "<-" is just syntactic sugar. It translates back to basic list functions
11:09:43 <shamster> dafis: Although I'm thinking that for $16 on amazon I can pick up real world haskell from o'reilly
11:09:54 <dafis> @where RWH
11:09:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:10:00 <dafis> shamster:  ^^^^
11:10:02 <dafis> free
11:10:09 <dafis> buy it if you like
11:10:16 <shamster> uart14: I imagine that a lot of the core functions boil down that way. I'm familiar with it in lisp as everything stemming from cdr cons, etc.
11:10:51 <shamster> dafis: oh! thanks for the link :) My search was too shallow
11:11:11 <digitteknohippie> :)  i've gone back to that just today too.
11:13:37 <uart14> shamster, Well, list comprehensions are truly magic. Haskell doesn't have Lisps macros so you can't replicate them in haskell. It's one of the few places with lots of sugar
11:13:51 <dafis> shamster:  The online version of RWH is not quite the printed version, there've been some changes; and there have been some changes in GHC since it was written, so some things break
11:14:31 <shamster> uart14: my python experience with comprehensions is fitting in pretty seamlessly with haskell's way of doing it.
11:14:49 <shamster> dafis: probably a good start, though
11:15:02 <dafis> shamster:  python's were heavily influenced by Haskell's
11:15:18 <shamster> dafis: makes sense
11:15:46 <dafis> shamster:  I wouldn't recommend RWH for the very first steps, first get your feet wet with LYAH
11:15:53 <Heffalump> uart14: they're not that magic, they have a fairly straightforward desugaring.
11:15:54 <dafis> @where tryhaskell
11:15:55 <lambdabot> http://tryhaskell.org/
11:15:59 <dafis> and that
11:16:15 <uart14> shamster, They are indeed really nice. My point is just that you can understand them by translating them back to "real" haskell, the don't have semantics by themselves
11:16:46 <shamster> dafis: thnx
11:16:47 <uart14> Heffalump, By "magic" I meant it is built into the compiler, you can't create them from other haskell 
11:16:54 <Heffalump> I see, fair enough.
11:17:13 <HugoDaniel> hello
11:17:23 <dafis> hello too
11:17:26 <HugoDaniel> hey bos
11:18:01 <copumpkin> I'm starting to think the michael rice guy on the mailing list is an elaborate troll
11:18:26 <monochrom> you identify trolls too much :)
11:18:39 <copumpkin> I mean, he's been asking beginner-level questions for about two years now :P
11:18:42 <copumpkin> and lots of them
11:20:01 <dolio> Whatever. He's just asking straight forward, "why doesn't this work," questions.
11:20:11 <copumpkin> yeah
11:20:17 <dolio> Not, "this doesn't work so Haskell sucks."
11:20:24 <dolio> Which is how the professionals do it.
11:22:52 <dafis> Yes, I think he's just a slow learner (probably not young enough anymore). I have to admire his tenacity.
11:24:05 <monochrom> I don't know whether it is trolling. But I see that it always asks for very wrong solutions to problems. So I just don't answer.
11:24:51 <dafis> monochrom:  'it'?
11:25:05 <copumpkin> http://snapplr.com/y0zr and http://snapplr.com/hwja
11:25:07 * copumpkin shrugs
11:25:10 <monochrom> gender-neutral grammatically correct pronoun :)
11:26:16 <dolio> copumpkin: See, he is learning.
11:26:24 <dafis> monochrom:  when 'it' calls itself Michael, I think we can safely go with 'he'
11:26:30 <dolio> The first one didn't know how to load package modules.
11:26:46 <dolio> The second one knew that, but didn't know that they had to be installed first.
11:26:46 <copumpkin> I just find it hard to believe he's gone a year and a half and hasn't learned about packages yet
11:27:18 <copumpkin> anyway, he isn't exactly disruptive :)
11:27:20 <copumpkin> it's just puzzling
11:27:33 <monochrom> Cale does not give a lecture on cabal hackage etc in haskell-cafe, that's why.
11:28:11 <dafis> copumpkin:  puzzling definitely
11:28:25 <Guest51163> I'm using HDBC-postgres and I'm getting errors with a query that runs fine in psql: Are there any known problems with the HDBC driver for queries with intervals?
11:28:31 <bos> HugoDaniel: yup?
11:28:43 <telephone> In ghci, import System.Random, setStdGen (error "my unique exeception"), will cause calls to getStdGen to fail with the exception. Is this correct behavior?
11:28:50 <hatds> I probably went a year or so without touching packages when I started, but I was aware of them early on
11:29:25 <telephone> monochrom: That is the error from yesterday, I tracked down.
11:29:40 <Saizan> telephone: yeah
11:30:15 <Saizan> well, you could argue that setStdGen could be stricter, so the exception would get triggered there
11:30:57 <telephone> Saizan: yes, its seems reasonable. But yesterday I got a wierd error after running a program in ghci. I have now tracked it down to this.
11:33:29 <gwern> Cale only gives lectures here
11:33:33 <gwern> everyone knows that
11:33:39 <monochrom> yes
11:33:50 <hatds> x <- randomRIO undefined :: IO Int has similiar behavoir
11:33:50 <dcoutts> get/setStdGen should die
11:33:58 <gwern> @quote majestic
11:33:58 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
11:34:01 <dcoutts> just say no to global mutable variables
11:34:02 <copumpkin> #universityofcale
11:34:09 <hatds> *behavior
11:34:44 <dafis> *behaviour
11:35:09 <hatds> er, that was a little unclear:   if you call randomRIO undefined and don't use the result, the next caller to randomRIO who does evaluate the result will trigger the error
11:47:41 <copumpkin> dolio, monochrom: lol, wtf? http://snapplr.com/kmy5
11:48:05 <copumpkin> (I reply saying that a ListT is only a monad if the internal one is commutative, and he says that)
11:48:14 * copumpkin shrugs
11:48:38 <dolio> Cryptic.
11:48:52 <dafis> copumpkin:  I'd rather think the suspicions in the thread title
11:49:20 <dafis> "Merry monad mixup?"
11:49:28 <awesomeproblem> Hi.Where can I post a snippet of my code to post here
11:49:30 <copumpkin> ah, maybe
11:49:34 <telephone> hatds, dcoutts: the current behavior caused some wierd error when running a program in ghci. Finally I tracked down the problem to this. So for me it would be better if it where strict evaluated!
11:49:35 <dafis> @where paste
11:49:36 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
11:49:44 <dafis> awesomeproblem:  ^^^
11:49:49 <copumpkin> preflex: seen chrisdone
11:49:49 <preflex>  chrisdone was last seen on #haskell 2 hours, 52 minutes and 35 seconds ago, saying: * chrisdone wrote an ircd recently so this is fresh in his mind
11:51:10 <awesomeproblem> I have defiend the variables with let
11:51:11 <awesomeproblem> code
11:51:13 <Veinor> copumpkin: "my suspicions are confirmed, the prophecy has been fulfilled"
11:51:15 <awesomeproblem> http://paste.lisp.org/+2JXK
11:51:26 <awesomeproblem> why it returns a empty list
11:52:14 <dafis> awesomeproblem:  iter is not the step but the second element of the list
11:52:31 <dafis> > [1, 3 .. 19]
11:52:33 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
11:52:40 <copumpkin> Veinor: onoes
11:52:40 <dafis> > [1, 4 .. 19]
11:52:42 <lambdabot>   [1,4,7,10,13,16,19]
11:52:55 <dafis> awesomeproblem:  see?
11:53:04 <awesomeproblem> hmm ok.I m reading real world haskell now
11:53:06 <awesomeproblem> thank you
11:53:21 <awesomeproblem> that would be an awesome simple for loop
11:53:26 <awesomeproblem> :)
11:54:21 <awesomeproblem> for example
11:54:24 <awesomeproblem> [1.0,1.25..2.0]
11:54:31 <dafis> awesomeproblem:  since iter is smaller than start, it builds a decreasing list; since start is smaller than end, the stopping condition is met immediately
11:54:45 <dafis> > [1.0, 1.25 .. 2.0]
11:54:46 <lambdabot>   [1.0,1.25,1.5,1.75,2.0]
11:55:29 <awesomeproblem> nice one
11:55:39 <awesomeproblem> tanks
11:55:42 <awesomeproblem> thanks
11:55:42 <dafis> @src enumFromThenTo
11:55:42 <lambdabot> Source not found. Do you think like you type?
11:55:56 <dafis> lambdabot--
11:56:12 <dafis> @botsnack
11:56:12 <lambdabot> :)
11:56:50 <awesomeproblem> yep it worked
11:56:58 <awesomeproblem> if iter is bigger then start
11:57:28 <awesomeproblem> awesome I love this language, the salvation to all my programming problems
11:57:34 <awesomeproblem> :)
11:57:38 <dafis> :D
11:58:16 * hackagebot lrucache 1.1.0.1 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.1.0.1 (CarlHowells)
12:10:40 <dibblego> edwardk: where can I find bimap in category-extras?
12:13:04 <aristid> dibblego: something with Bifunctor? Functor.something?
12:13:17 <dibblego> yeah found it in Control.Functor thanks!
12:13:45 <aristid> damn, imma too slow
12:13:57 <Saizan> ?hoogle bimap
12:13:57 <lambdabot> No results found
12:14:16 <Saizan> no category-extras on hoogle? it's a scandal
12:15:02 <dafis> Saizan:  get it into the platform, I think then hoogle will include it by default ;)
12:18:49 <awesomeproblem> Whats the difference between "awe"  and 'awe'
12:18:58 <awesomeproblem> is awe a list
12:19:02 <awesomeproblem> "awe a list"
12:19:05 <awesomeproblem> fuck
12:19:10 <monochrom> 'awe' is a syntax error
12:19:10 <Eduard_Munteanu> Yes.
12:19:11 <awesomeproblem> "awe'  a list
12:19:19 <awesomeproblem> but 'awe'
12:19:23 <awesomeproblem> string
12:19:24 <Eduard_Munteanu> Like monochrom said.
12:19:27 <awesomeproblem> or
12:19:31 <Eduard_Munteanu> awesomeproblem: strings are lists.
12:19:37 <awesomeproblem> i know that
12:19:41 <Eduard_Munteanu> type String = [Char]
12:19:44 <awesomeproblem> but what is 'awe'
12:19:54 <Eduard_Munteanu> Again, like monochrom said.
12:20:08 <maurer_> 'awe' is an error, as '' can only be used to enclose a single character
12:20:09 <dafis> > 'awe'
12:20:10 <lambdabot>   <no location info>:
12:20:11 <lambdabot>      lexical error in string/character literal at chara...
12:20:23 <awesomeproblem> thank you
12:20:25 <awesomeproblem> :)
12:20:34 <aristid> > 'a'
12:20:35 <lambdabot>   'a'
12:20:39 <aristid> :t 'a'
12:20:40 <lambdabot> Char
12:20:41 <aristid> :t "a"
12:20:43 <lambdabot> [Char]
12:20:47 <dafis> > ['a','w','e']
12:20:49 <lambdabot>   "awe"
12:21:45 * monochrom cues his definition of IQ
12:22:43 * monochrom actually cues his "the 3rd answer is the best answer" law
12:23:52 <zygoloid> 'awe' is actually legal, with -XTemplateHaskell ;p
12:24:04 <monochrom> 'eww'
12:24:10 <awesomeproblem> was just an example
12:24:14 <Eduard_Munteanu> I guess the fourth answer is the most complete :P
12:24:22 <awesomeproblem> im still learning
12:24:25 <awesomeproblem> :P
12:24:37 <awesomeproblem> "okk" : ['m','m']
12:24:43 <awesomeproblem> this return a error
12:24:55 <dafis> > "okk" ++ ['m','m']
12:24:56 <awesomeproblem> how to add it top the list
12:24:58 <lambdabot>   "okkmm"
12:25:05 <awesomeproblem> ok
12:25:05 <zygoloid> yes, that's equivalent to: ["okk", 'm', 'm'], which is a type error
12:25:05 <monochrom> the same error as ['o', 'k', 'k'] : ['m', 'm']
12:26:25 * digitteknohippie envisions reverse, append, reverse, but realises that's surely a silly work around from someone who doesnt know enough yet
12:27:11 <dafis> digitteknohippie:  reverse, *append to the end* and reverse again?
12:27:15 <joeytwiddle> 'o' : 'k' : 'k' : [ 'm', 'm', 'm' ] works too
12:27:38 <digitteknohippie> dafis: thats what i was thinking, yeah
12:27:50 <dafis> digitteknohippie:  not good
12:27:57 <digitteknohippie> hehehe. i know.
12:28:06 <dafis> consing to the front is cheap, appending to the end is expensive
12:28:31 <digitteknohippie> consing!  :)
12:28:40 <monochrom> conjugation is pleasing
12:29:37 <dafis> where did 'cons' originate, again?
12:29:44 <dafis> lisp?
12:29:50 <jetkoten> hi all
12:30:12 <awesomeproblem> If I do this
12:30:15 <awesomeproblem> "okk" : ["m","m"]
12:30:18 <awesomeproblem> it works
12:30:36 <jetkoten> i'm new to Haskell, and trying to figure out the difference between cabal and cabal-install (as installed from the Haskell Platform, if that's important). can anyone let me know?
12:31:12 <dafis> jetkoten:  cabal-install is the package that provides the executable cabal
12:31:21 <dafis> confusing?
12:31:24 <dcoutts> jetkoten: there is a package called "Cabal" which is a library, there is a package called "cabal-install" which provides an command line program called "cabal"
12:32:01 <dafis> awesomeproblem:  ["m","m"] is a list of Strings, there's no problem adding another String to that list
12:32:09 <Eduard_Munteanu> Plain cabal is the analogue of autoconf and that stuff for C.
12:32:15 <jetkoten> dafis: thanks, y, confusing a little... ah ok, your second explanation gets it. i thought cabal-install was also a command, because people keep writing use cabal-install and i see no command called that, only cabal :)
12:32:34 <Eduard_Munteanu> It's a build system.
12:32:41 <Eduard_Munteanu> cabal-install is more like CPAN for perl./
12:32:44 <jetkoten> dafis: great. that answers my questions very well.
12:33:10 <jetkoten> Eduard_Munteanu: thanks, that helps too.
12:33:30 <dafis> awesomeproblem:  whereas ['m','m'] is a list of Chars (aka a String), you can put a String in that list, you can only prepend (or append) it with (++)
12:33:45 <jetkoten> ok everyone, thanks again, got to go!
12:34:51 <awesomeproblem> so list can only take the same type thats why it worked
12:35:02 <dafis> " you can put a String in that list," should've been "can't" of course
12:35:24 <dafis> awesomeproblem:  yes, lists can take elements of one type only
12:35:38 <awesomeproblem> ok
12:35:39 <dafis> no heterogeneous lists like in Python
12:35:40 <awesomeproblem> :)
12:38:42 <monochrom> "cons cell" is short for "constructor cell" from my memory
12:39:50 <dafis> monochrom:  that's what my memory thinks too, but did it come from lisp or from some other language?
12:40:00 <mrd> you can argue that python has homogenous lists as well, since there is only a single type, and it is a disjoint union of the "dynamic types" with tags
12:40:09 <tg_> scheme?
12:40:10 <mrd> dafis: lisp
12:40:16 <tg_> lisp
12:40:17 <monochrom> it came from lisp (again according to my memory)
12:40:19 <tg_> when in doubt, it's lisp
12:40:19 <dafis> mrd:  thx
12:40:23 <mrd> cons, car, cdr
12:40:52 <dafis> tg_:  Vonnegut wrote "When in doubt, castle."
12:41:08 <monochrom> > "okk" : ["m","m"]
12:41:09 <lambdabot>   ["okk","m","m"]
12:41:15 <monochrom> is a list of 3 strings
12:41:36 <tg_> dafis: chess? surey
12:41:39 <tg_> surely*
12:42:58 <monochrom> you probably should learn to learn, not just learn haskell. "it works"/"it doesn't work" is a very coarse and ineffective understanding. you have to be more refined: it works but what does it do?
12:43:27 <dafis> or : "Why does it (not) work?"
12:43:45 <tg_> conal would say: what do I mean by "works", and what does it do by "works"
12:44:15 <tg_> but I digress
12:44:21 <conal> :)
12:49:18 <monochrom> there was and still is a class of people over-enthusiastic about the curry-howard isomorphism. their understanding of programs is similarly coarse and ineffective. they view programs as "I don't know what it does but oh boy does it formally prove that it has type Int->Int". I'm sorry but usually the point of a program is what it does --- at the value level, not so much at the type level. There is really no point working so hard
12:49:19 <monochrom>  to write and verify a program if all you want to accomplish is "prove that it is possible to write an Int->Int function".
12:49:25 * digitteknohippie falls in love with list comprehensions
12:49:51 <mrd> that's dumb. Int -> Int is necessarily boring.
12:50:10 <copumpkin> it's true implies true, from the C-H isomorphism
12:50:21 <mrd> how about Int -> True if prime | False if not
12:50:24 <copumpkin> (with some extra information)
12:50:31 <monochrom> no, a lot of interesting and useful number theoretic functions of type Int->Int or Integer->Integer
12:50:44 <mrd> no they're more like what I said
12:50:48 <mrd> (dep. types :)
12:51:12 <copumpkin> (x : Nat) -> Dec (prime x)
12:52:08 <copumpkin> where dec is a more interesting boolean
12:52:26 <monochrom> given that this is #haskell we're stuck with Integer->Integer. your dependent type is more relevant in #agda or something
12:53:12 <monochrom> of course, there is no problem doing a bit of agda here. but...
12:54:26 <category> Goldurnit, here I am trying to learn Haskell and now there's *another* language to be curious about. ;o)
12:54:30 * category shakes his cane.
12:54:33 <Saizan> yeah, C-H in haskell can be interesting only with highly polymorphic types, thanks to parametricity
12:55:24 <edwardk> dibblego: Control.Functor iirc
12:55:28 <monochrom> some enthusiasists misleadingly tell #haskell beginners about curry-howard when 1. the beginner is still learning haskell, 2. the beginner is still trying to write an Int->Int function. I'm sorry but curry-howard is utterly useless for this purpose.
12:55:30 <edwardk> its getting moved out though in the next release
12:55:31 <dibblego> edwardk: got him ta
12:56:04 <edwardk> in C.E. its tied to PFunctor and QFunctor which are needed because of type inference more than anything
12:56:29 * SomeEnthusiast glares at monochrom 
12:57:04 <Veinor> monochrom: but it proves that integers exist if and only if they exist!
12:57:10 <Veinor> well, if
12:57:33 <SomeEnthusiast> dude, that is like so totally deep
12:58:05 * digitteknohippie chuckles, thinking of pythagoras
12:58:35 <dafis> digitteknohippie:  ate any beans lately?
12:58:49 <digitteknohippie> ??? no.  why?
12:59:06 <dafis> digitteknohippie:  Pythagoras didn't like them
12:59:13 <digitteknohippie> lol. oh.
12:59:27 <dafis> he forbade eating beans
12:59:29 <digitteknohippie> he didnt like zero, or irational numbers either.
12:59:35 <mrd> what if said beginner is a mathematician?
13:00:51 <dafis> then he will most likely still think C-H stands for Dayley-Hamilton
13:00:51 <digitteknohippie> mathematician + beginin' haskell > mathlessmoronlikeme + beginin' haskell
13:00:57 <dafis> *Cayley
13:02:04 <edwardk> trying to figure out the nicest way to refactor the Control.Morphism hierarchy out of category-extras since that is the largest extractable chunk left
13:02:33 <edwardk> i'm kind of leaning towards making Data.Functor.Foldable and/or Data.Functor.Unfoldable
13:03:53 <edwardk> then type Base t :: * -> *    class Functor (Base t) => Foldable t where outF :: t -> Base t t; cata :: (Base t a -> a) -> t -> a â and cata gets a default definition
13:04:08 <dfilimon> 09879
13:04:20 <dafis> ??
13:04:22 <dfilimon> oops, sorry about that
13:04:28 <edwardk> that is enough to define g_cata, and then g_zygo, etc. but to define para you need both Foldable and Unfoldable
13:04:53 <dfilimon> could anyone please help with benchmarking code using Criterion ?
13:05:06 <dafis> dfilimon:  maybe
13:05:24 <dafis> what's the problem?
13:05:30 <dfilimon> what i want to do is benchmark a specific redblack tree implementation
13:05:33 <edwardk> the definition above would let me apply cata/ana, etc. to prelude lists, etc. without being too burdensome i think
13:05:54 <dfilimon> it is defined like a normal data type with two constructors, Nil and Node deriving Show and Eq
13:06:18 <SomeEnthusiast> you'd have to write some operations on it
13:06:21 <SomeEnthusiast> that you want to benchmark
13:06:30 <SomeEnthusiast> then wrapping criterion around it is pretty easy
13:07:00 <dfilimon> well, i'll get it in a pastebin right away
13:08:13 <dfilimon> ok, so this is the rbtree
13:08:14 <dfilimon> http://hpaste.org/raw/43403/rbtree_annotation
13:08:52 <dfilimon> and this is the benchmarking code
13:08:53 <dfilimon> http://hpaste.org/43404/rbtree_annotation
13:09:41 <dafis> try bench "1" (whnf $ makeTree l)
13:09:46 <dfilimon> it says that RBTree is not an instance of Benchmarkable ...
13:10:18 <dfilimon> now it says - Couldn't match expected type `a -> b'
13:10:18 <dfilimon>            against inferred type `RBTree t
13:10:30 <Ziphilt> i am trying to compile rexex-posix as a dependency to snap, and it is giving an error about "regex.h" and how i should edit a .cabal file or add options to cabal to point to the header. i checked that i do have libc6-dev installed, which includes that. what is wrong?
13:10:39 <dafis> dfilimon:  that's what functions like whnf are for; but, whnf is not enough I'd think, you'd need rnf
13:10:53 <SomeEnthusiast> dfilimon: you can't benchmark a type
13:10:56 <SomeEnthusiast> it doesn't make any sense
13:11:02 <SomeEnthusiast> you benchmark operations on that type
13:11:02 <Ziphilt> s/rexex/regex
13:11:15 <dfilimon> well, the makeTree is the operation i'm benchmarking
13:11:23 <dfilimon> it's suppose to foldr an insert on a list
13:11:33 <SomeEnthusiast> sure, then pass that to bench
13:11:33 <dfilimon> it just evaluates to a RBTree
13:11:39 <SomeEnthusiast> but you need
13:11:45 <dafis> dfilimon:  it's nf in Criterion.Main (and you must make an NFData instance for your RBTree)
13:11:47 <SomeEnthusiast> to pass the operand separately
13:12:16 <dfilimon> how do i make the instance? i'm pretty new to haskell, i'm afraid
13:12:21 <dafis> dfilimon:  so, bench "1" (nf $ makeTree l)
13:12:50 <SomeEnthusiast> isn't there a pure somewhere there, and a separate argument?
13:12:52 <dafis> dfilimon:  first, you need the deepseq package (for the NFData class)
13:12:54 <SomeEnthusiast> I've only benchmarked IO functions
13:13:26 <dafis> dfilimon:  then you write "instance NFData Color" (the default instance is good for that one)
13:13:58 <dfilimon> i have deepseq; i'm supposed to just add the instance line?
13:14:04 <dfilimon> but why for Color though?
13:15:59 <dafis> and "instance (NFData a) => NFData (RBTree a) where { rnf Nil = (); rnf (Node a c l r) = rnf a `seq` rnf c `seq` rnf l `seq` rnf r }
13:16:11 <copumpkin> you could use bang patterns to make that way cleaner
13:16:48 <dafis> dfilimon:  actually, you don't need that, you can replace the "rnf c" in the RBTree instance with plain "c"
13:16:50 <copumpkin> there should be an "rnsf" :P
13:16:56 <copumpkin> rsnf?
13:17:00 <copumpkin> reduce spine to normal form
13:17:05 <copumpkin> force the structure without forcing the elements
13:17:27 <dfilimon> okay, i'm a little bit confused
13:17:41 <dfilimon> what does the last rnf on the Node constructor do exactly?
13:17:46 <monochrom> I support a type class for spine normal form
13:18:24 <copumpkin> snf
13:18:26 <dafis> dfilimon:  it evaluates all components to normal form
13:18:27 <copumpkin> that's simple and clean
13:18:49 <dfilimon> so, should it be rnf or snf?
13:18:54 <copumpkin> snf doesn't exist
13:19:03 <dafis> not yet
13:19:06 <monochrom> class SpinyData a where snf :: a -> a  or something
13:19:11 <dfilimon> and the r stands for what?
13:19:12 <monochrom> @type rnf
13:19:13 <lambdabot> Not in scope: `rnf'
13:19:20 <monochrom> r = reduce to
13:19:23 <dafis> dfilimon:  "reduce"
13:19:27 <dfilimon> ah, alright
13:19:55 <monochrom> oops, snf :: a -> ()
13:19:58 <dfilimon> i still don't really understand what that instance means exactly, but i'd like to get the code working first
13:20:39 <Heffalump> how do you define spine?
13:21:07 <burp> @hoogle stringlike
13:21:08 <lambdabot> No results found
13:21:18 <burp> ah never mind
13:21:20 <monochrom> rnf's type doesn't say a lot. actually it already hints that if it is of any use, the use is in "side effects". rnf's side effect is to fully evaluate its parameter.
13:21:32 <dafis> dfilimon:  evaluating to whnf means just evaluating to the outermost constructor, that is determined to be Node very fast for trees, so that's not really meaningful; hence we need to evaluate the complete structure to get informative measurements
13:21:49 <copumpkin> Heffalump: something like rnf that doesn't depend on NFData (or an imaginary typeclass for seq) on its parameter
13:21:53 <copumpkin> oh I know what
13:21:59 <copumpkin> it could be parametric!
13:22:00 <Lycurgus> maybe was thinking spline
13:22:18 <copumpkin> instance SNFData f where snf :: f a -> ()
13:22:34 <dfilimon> thanks for the help; let me try that and i'll get back to you
13:22:53 <copumpkin> (and we'd add a note on it saying "please don't use seq on your elements, kthx)
13:23:12 <dfilimon> would a list be more appropriate?
13:23:23 <dafis> dfilimon:  for what?
13:23:33 <Heffalump> copumpkin: I just mean, how do you define what the class member should do?
13:23:33 <dfilimon> instead of the infixed `seq`s ?
13:24:07 <dfilimon> actually, i think i just said something really dumb :)
13:24:19 <Ziphilt> okay, now the error is this: http://pastebin.com/RyL8gMes
13:24:24 <peim4> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! peim4 cafesofie isaacd Lycurgus zaphar_ps jeltsch Silvah joyfulgirl dfilimon edon twanvl shula revenantphx tg_ Philonous takuan kermit gienah mkscrg tac-tics bgs100 joeytwiddle Eduard_Munteanu spetrea_ perlite hoknamahn krfs_ krfs jo
13:24:24 <peim4> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! nick8325 cads flux shamster s76 Athas eb4890_ roconnor dafis pikhq thou smarmy nettok gwern carlocci smarter edwardk timepilot jutaro stephenjudkins lpsmith damex Hugglesworth msieradzki preflex cheater- c_wraith warrenharris MoALTz 
13:24:24 <peim4> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! SyntaxNinja jsgf doserj conal Jantaro kuhrt pingveno Tomsik raichoo janbanan _s1gma copumpkin joaopizani comak dimmy1 koala_man jimmyjazz14__ dolio sda1 bo0ts__ sonnym Olathe levitation[A] polymar_ Pellwurst THC4k iago ketil Muad_Dib
13:24:24 <peim4> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! sohum MrFahrenheit kaf3ii Anoq morricone dcoutts Bynbo7 pankajm jem777 adimit BMeph artefon uberfry jacobian sunfun category danr okp Palmik jimmy1980 ormaaj insomniaSalt Ferdirand kniu BigBlackDog jaspervdj siracusa dfeuer lsthemes 
13:24:27 <copumpkin> Heffalump: "the only unevaluated thunks remaining in the input value should be those of type a, where a is the parameter
13:24:29 <sdhhjw> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! sdhhjw cafesofie isaacd Lycurgus zaphar_ps jeltsch Silvah joyfulgirl dfilimon edon twanvl shula revenantphx tg_ Philonous takuan kermit gienah mkscrg tac-tics bgs100 joeytwiddle Eduard_Munteanu spetrea_ perlite hoknamahn krfs_ krfs jo
13:24:29 <sdhhjw> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! dfkjjkfd nick8325 cads flux shamster s76 Athas eb4890_ roconnor dafis pikhq thou smarmy nettok gwern carlocci smarter edwardk timepilot jutaro stephenjudkins lpsmith damex Hugglesworth msieradzki preflex cheater- c_wraith warrenharris
13:24:29 <sdhhjw> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! cubi danharaj SyntaxNinja jsgf doserj conal Jantaro kuhrt pingveno Tomsik raichoo janbanan _s1gma copumpkin joaopizani comak dimmy1 koala_man jimmyjazz14__ dolio sda1 bo0ts__ sonnym Olathe levitation[A] polymar_ Pellwurst THC4k iago k
13:24:38 <dafis> dfilimon:  you could do "rnf (Node a c l r) = rnf [rnf a, rnf c, rnf l, rnf r]"
13:24:43 * hackagebot urlencoded 0.3.0.1 - Generate or process x-www-urlencoded data  http://hackage.haskell.org/package/urlencoded-0.3.0.1 (PhilipWeaver)
13:24:48 <MoALTz> drive by spamming..
13:24:50 <dfilimon> oh, so i could?
13:24:52 <c_wraith> I see idoru's pretty much on the spot...
13:24:56 --- mode: ChanServ set +o copumpkin
13:25:02 <c_wraith> I suppose that spamming's going to be pretty common this weekend.
13:25:10 <Jantaro> ew, I'm beeped by some idiotic spamming
13:25:23 <gwern> c_wraith: why this weekend?
13:25:24 <djahandarie> Maybe a highlight on ##politics would help
13:25:36 <Ziphilt> to repeat myself after the wall of spam: http://pastebin.com/RyL8gMes
13:25:38 <c_wraith> gwern: checked the news recently?
13:25:42 <copumpkin> I need something I can script to kick stuff automatically like that
13:25:46 <copumpkin> mauke is way better at that
13:25:51 <gwern> c_wraith: what does egypt have to do with spam here?
13:25:53 <Hugglesworth> fuck spam
13:25:57 <Hugglesworth> fucking*
13:26:22 <c_wraith> it means people are at least paying attention to the topic of spam like that
13:26:22 <gwern> Hugglesworth: both versions are fine
13:26:26 <Ziphilt> it stopped complaining about regex after i installed regex-posix and regex-compat with --extra-include-dirs=/usr/include/
13:26:28 <Silvah> Spammers are so effing stupid.
13:26:28 <copumpkin> Heffalump: not exactly an elegant definition, I guess
13:26:35 <Ziphilt> i do not understand this error
13:27:21 <kuhrt> I guess i can't partake in ##politics since I'm not in USA
13:27:40 <kuhrt> , darn
13:27:47 <Lycurgus> poor u
13:28:45 <Silvah> Thank Áine I'm not from USA.
13:28:59 <cheater-> what's Aine?
13:29:03 <Saizan> Ziphilt: it seems that version of haskell98 is not really compatible with your libraries, what version of ghc are you using?
13:29:12 <copumpkin> Heffalump: welcome back!
13:29:14 <Lycurgus> dunno but praise be unto him/her
13:29:21 <copumpkin> Heffalump: "the only unevaluated thunks remaining in the input value should be those of type a, where a is the parameter"
13:29:23 <gwern> cheater-: http://en.wikipedia.org/wiki/%C3%81ine
13:30:00 <Ziphilt> Saizan: 6.12.1
13:30:35 <Heffalump> I see, so it would be functorial.
13:30:45 <Heffalump> I was about to say that when irssi locked up on me :-)
13:31:38 <Ziphilt> Saizan: what should i do about this? install a different ghc? give options to cabal?
13:31:56 <Silvah> cheater-: WHO'S Áine, not what's!
13:32:28 <Saizan> Ziphilt: maybe you'd have more luck with 6.12.3, though what "ghc-pkg list haskell98" says=
13:32:52 <dhfbwd> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! dhfbwd Apocalisp schlaftier Heffalump cafesofie isaacd Lycurgus zaphar_ps jeltsch Silvah joyfulgirl dfilimon edon twanvl shula revenantphx tg_ Philonous takuan kermit gienah mkscrg tac-tics bgs100 joeytwiddle Eduard_Munteanu spetrea
13:33:01 <gwern> Silvah: since Ãine is not a person, a what is more appropriate
13:33:05 <dafis> Saizan:  my 6.12.1 came with haskell98-1.0.1.1
13:33:19 <Silvah> gwern: that's disputable.
13:33:25 <dafis> so it should work, but it ought to be already installed
13:33:33 <gwern> Silvah: everything is
13:33:50 <kmsn> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! kmsn Apocalisp schlaftier Heffalump cafesofie isaacd Lycurgus zaphar_ps jeltsch Silvah joyfulgirl dfilimon edon twanvl shula revenantphx tg_ Philonous takuan kermit gienah mkscrg tac-tics bgs100 joeytwiddle Edu
13:33:50 <kmsn> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! Evious HugoDaniel dfkjjkfd nick8325 cads flux shamster s76 Athas eb4890_ roconnor dafis pikhq thou smarmy nettok gwern carlocci smarter edwardk timepilot jutaro stephenjudkins lpsmith damex Hugglesworth msierad
13:33:50 <kmsn> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! cubi danharaj SyntaxNinja jsgf doserj conal Jantaro kuhrt pingveno Tomsik raichoo janbanan _s1gma @copumpkin joaopizani comak dimmy1 koala_man jimmyjazz14__ dolio sda1 bo0ts__ sonnym Olathe levitation[A] polyma
13:33:50 <kmsn> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! fryguybob Yvemath sohum MrFahrenheit kaf3ii Anoq morricone dcoutts Bynbo7 pankajm jem777 adimit BMeph artefon uberfry jacobian sunfun category danr okp Palmik jimmy1980 ormaaj insomniaSalt Ferdirand kniu BigBla
13:33:50 <kmsn> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! glguy zmbmartin theorbtwo shapr Cobra Obvious Intensity regalia untwisted ido dom96 Obfuscate jix cognominal mauke `0660 helgikrs gbeshers shutdown_-h_now ernst ousado Colours EvanR-work sm sidek ahihi mortberg
13:33:59 <rokoteko> copumpkin: one would think you could easily in haskell make a type that fails if the third instance of alike is made. and use that to evaluate the repeating smap message (to which I believe you were referring to)
13:34:00 <Saizan> yeah, so it's trying to reinstall it against some different version of some other package, unless it's a minimal install
13:34:00 <damex>  /spit
13:34:01 <Silvah> Fucking fuck.
13:34:04 --- mode: ChanServ set +o glguy
13:34:07 <revenantphx> This is really annoying.
13:34:08 <companion_cube> -_-
13:34:08 <rokoteko> hmm.. well it fails if they jus tjoin and pam.
13:34:08 <Silvah> Can someone ban him?
13:34:10 <Jantaro> ^
13:34:15 <kuhrt> is haskell a recruiting center or something?
13:34:32 <copumpkin> Silvah: there's nothing to ban
13:34:39 <Yvemath> already killed > ##comment-on-spam
13:34:40 <copumpkin> different IPs each time
13:34:41 <copumpkin> it's a botnet
13:34:43 <damex> copumpkin: spam?
13:34:44 <revenantphx> I feel it would be appropriate if freenode just removed ##politics entirely.
13:34:44 <edwardk> is there a good way to export just the constructors of a data type, but _not_ the data type?
13:34:45 <rokoteko> That was confusing.
13:34:45 <copumpkin> here, let's do this
13:34:45 <kuhrt> rather, first time i see political spam in a computer language channel
13:34:47 <Saizan> we could set +r
13:34:49 <rokoteko> copumpkin: +r ?
13:34:53 <dafis> Ziphilt:  haskell98 should already be installed from the start, if cabal is trying to reinstall it, that's probably an indication of a deeper problem
13:35:01 --- mode: copumpkin set +s-nt
13:35:02 <HugoDaniel> kuhrt, viagra is not working anymore :)
13:35:05 <copumpkin> wtf
13:35:08 <djahandarie> Haha
13:35:14 <Ziphilt> dafis: in that case, how do i find the problem?
13:35:14 --- mode: copumpkin set +nt
13:35:14 <edwardk> e.g. for data Foo = Bar | Baz â i want to export Bar and Baz but _not_ Foo from the module
13:35:18 <kuhrt> haha
13:35:30 <Saizan> (maybe it's not exactly +r?:)
13:35:33 <dafis> Ziphilt:  first step: ghc-pkg check
13:35:53 <Ziphilt> dafis: i just did that; it told me i have a bunch of broken packages
13:35:56 <gwern> I almost expected HugoDaniel to be k-lined for mentioning viagra
13:36:02 <Silvah> gwern: well, I consider gods to be persons, so who is more appropriate.
13:36:22 <gwern> Silvah: that's adorable
13:36:28 <dfilimon> dafis: am i suppose to add NFData to a's typeclasses in every function definition in addition to Ord or Num, or whatever?
13:36:30 <dafis> Ziphilt:  you'd have to remove them and reinstall carefully, I believe
13:36:30 * gwern kids. I'll drop the obnoxious atheist bit now
13:36:45 <edwardk> the reason is i'd like to only expose the type through a type family
13:36:51 <dafis> dfilimon:  only where you need it
13:37:03 <Ziphilt> i was already planning to do a clean upgrade of ubuntu; should i just do that?
13:37:22 <HugoDaniel> i really love when i have to refactor my haskell code
13:37:26 <dafis> Ziphilt:  might be a good opportunity
13:37:34 <dfilimon> it says that it is ambiguous sometimes... a can either be NFData or Ord
13:37:43 <Ziphilt> dafis: okay, i'll do that next. thanks for the help
13:37:48 <Saizan> Ziphilt: remember to rm -fr ~/.ghc , and get 6.12.3 if possible
13:37:52 <dafis> dfilimon:  huh? paste the error?
13:38:05 <Ziphilt> Saizan: will that fix my problem?
13:38:12 <vbeh> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! vbeh sioraiocht Beetny glguy Apocalisp schlaftier Heffalump cafesofie isaacd Lycurgus zaphar_ps jeltsch Silvah joyfulgirl dfilimon edon twanvl shula revenantphx tg_ Philonous takuan kermit gienah mkscrg tac-tics bgs1
13:38:12 <vbeh> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! miloshadzic gniourf_gniourf Evious HugoDaniel dfkjjkfd nick8325 cads flux shamster s76 Athas eb4890_ roconnor dafis pikhq thou smarmy nettok gwern carlocci smarter edwardk timepilot jutaro stephenjudkins lpsmith dame
13:38:12 <vbeh> kunwon1 here. ##politics invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! Itkovian Sgeo _nickel muhtimin jonafan cubi danharaj SyntaxNinja jsgf doserj conal Jantaro kuhrt pingveno Tomsik raichoo janbanan _s1gma @copumpkin joaopizani comak dimmy1 koala_man jimmyjazz14__ dolio sda1 bo0ts__ s
13:38:25 <jimmyjazz14__> arrgh
13:38:26 --- mode: copumpkin set +r
13:38:27 --- mode: ChanServ set +o glguy
13:38:27 <Jantaro> I think some bans are in order. Or something
13:38:28 <dafis> Ziphilt:  that'll give you a fresh virginal ghc
13:38:30 --- mode: glguy set +b vbeh!*@*
13:38:34 <copumpkin> Jantaro: there's nothing to ban
13:38:35 <Silvah> Holy crap.
13:38:36 <dfilimon> dafis: http://hpaste.org/43405/dan
13:38:39 <Jantaro> aww.
13:38:40 <copumpkin> they're randomly generated nicks from random IPs
13:38:45 <Jantaro> I see
13:38:47 <copumpkin> they get killed by freenode quickly
13:38:50 <Heffalump> what does +r do again?
13:38:50 <copumpkin> but they can still spam
13:38:51 <stephenjudkins> have fun with that guy. 
13:38:55 <Ziphilt> bayesian filtering?
13:38:56 --- mode: glguy set -b vbeh!*@*
13:39:02 <copumpkin> Heffalump: only logged-in nicks can talk
13:39:05 <Saizan> Ziphilt: i meant that as part of your fresh install of ghc, i think you should be fine then
13:39:06 <djahandarie> glguy, you aren't very good at this :P
13:39:19 <djahandarie> copumpkin, maybe add something in the topic
13:39:23 <djahandarie> Regarding +r
13:39:26 <Cerulean> Hi. Is code.haskell.org down?
13:39:31 <Saizan> Ziphilt: i've tried "cabal install ConfigFile" here with ghc-6.12.3 and it worked out of the box
13:39:47 <copumpkin> djahandarie: it actually prevents joining the channel if you aren't identified
13:39:56 <copumpkin> so an error from freenode will explain what to do
13:40:02 <djahandarie> copumpkin, oh, right, use +q ~$a or whatever
13:40:02 <glguy> Anyone that wants to chat about spam can join #haskell-ops
13:40:08 <glguy> Let's keep this channel on topic
13:40:08 <dafis> dfilimon:  code? probably you have to list all those classes in the constraint
13:40:14 <Ziphilt> Saizan: you mean i should do that even when doing a clean reinstall of the entire operating system?
13:40:14 <copumpkin> djahandarie?
13:40:22 <sioraiocht> ooh liberals and leftists
13:40:25 <sioraiocht> I love them
13:40:40 <dfilimon> is this not a proper function definition insert :: (NFData, Ord a) => a -> RBTree a -> RBTree a
13:40:42 <Silvah> ...I mourn them.
13:41:00 <Saizan> Ziphilt: i assumed you'd restore your $HOME :) and ~/.ghc lives there, it contains the metadate about the user-installed packages
13:41:14 <Saizan> Ziphilt: anyhow, if you change version of ghc it won't matter
13:41:18 --- mode: copumpkin set -r
13:41:40 <djahandarie> kunwon1, I imagine that isn't actually you? :)
13:41:45 <kunwon1> i am kunwon1
13:41:51 <kunwon1> the bots are not
13:41:54 --- mode: ChanServ set +o monochrom
13:41:56 <kunwon1> :p
13:42:17 --- mode: monochrom set +q $~a
13:42:33 <copumpkin> @topic-cons
13:42:33 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
13:42:38 <copumpkin> boo
13:42:41 <Ziphilt> Saizan: for some reason i don't save my entire $HOME; i just copy over the config files i want and let the other . folders get lost... i probably should be doing this differently
13:42:42 <dafis> dfilimon:  for insert, you shouldn't need NFData
13:43:08 <djahandarie> copumpkin, /t [tab] usually does that
13:43:39 <copumpkin> djahandarie: I was hoping lambdabot could cons onto the topic for me :P
13:44:37 --- topic: set to '["Register to talk", "Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by copumpkin
13:44:49 <Saizan> Ziphilt: if it works for you it's good :) i just wanted to warn you about the additional data that might get in the way
13:44:58 --- topic: set to '["To talk, identify to nickserv", "Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by copumpkin
13:45:56 <Cerulean> anyone have any idea about code.haskell.org? I'm trying to checkout agda, but darcs is hanging and I wondered if it's down
13:46:04 <Ziphilt> Saizan: it usually takes longer than it would to just remove the folders i /don't/ need. a benefit to the way i do it is that i have to keep my directory structure well-organized
13:46:11 <djahandarie> Cerulean, yes it's down, being moved to a new machine
13:46:19 <Heffalump> it got cracked :-(
13:46:20 <djahandarie> Could take awhile, haven't checked on the progress of that recently
13:46:36 <djahandarie> Yeah, got hacked so they decided to use the opportunity to move to better hardware
13:47:06 <Silvah> Really?
13:47:18 <lispy> There has been no activity on the restoration front
13:47:30 <lispy> Not in the last 24-48 hour range anyway
13:48:10 <Cerulean> thanks
13:49:07 <Heffalump> do you mean there's bee no activity on haskell-infrastructure, or do you know there's been no actual work done?
13:49:24 <SyntaxNinja> Heffalump: lispy: djahandarie: Do you know if anyone is actively working this or if we should try to get something moving? I got vague answers when I asked.
13:50:04 <djahandarie> Who made the decision to move now?
13:50:20 <lispy> Heffalump: oh sorry.  I meant to say, "on the haskell-infrastructure list"
13:50:40 <lispy> Heffalump: If Yitz (or someone else) has been working on it, they haven't said much
13:50:42 <Heffalump> SyntaxNinja: I don't know. I've only seen the emails to haskell-infrastructure, some of which were copied to committee@haskell.org. There haven't been any emails of significance just to the latter list.
13:50:47 <Heffalump> lispy: yeah
13:51:09 <Heffalump> djahandarie: not sure, but there wasn't much alternative given a compromised machine; you have to start from scratch in any case
13:51:39 <djahandarie> Well whoever it was should probably be the one who knows what is going on
13:52:52 <lispy> djahandarie: I think the way we (the community) manage that server is broken.  For example, it's hard to tell who has final say in decisions and who is responsible for results.
13:53:15 <lispy> djahandarie: I think the decision to move it was just generally agreed up on though
13:53:27 <Heffalump> lispy: the haskell.org committee now has the final say in decisions.
13:53:48 <Heffalump> But without people who actually have the time to get things done, there can be no guarantee of anything happening.
13:54:08 <Heffalump> it's a rather obvious flaw, but without any obvious solution
13:54:30 <lispy> Heffalump: I think there have been offers to help
13:54:42 <SyntaxNinja> Heffalump: yeah, there are 3-4 at Galois who could help, plus Isaac D.
13:55:00 <Heffalump> ok, so we just need to identify who should coordinate them?
13:55:13 <copumpkin> SyntaxNinja: can you convince iavor to join IRC? :D
13:55:14 <lispy> Instant help, just add leadership ;)
13:55:29 <Heffalump> do we have any volunteers to lead?
13:56:01 <Heffalump> who has the knowledge of what needs to be done?
13:56:14 <lispy> Heffalump: there is a wiki page documenting the tasks needed for the move
13:56:28 <lispy> Not sure if that page was on the compromised server or not though
13:56:47 <glguy> copumpkin: You want Iavor in general or at this moment?
13:57:02 <lispy> Heffalump, djahandarie, SyntaxNinja: http://www.haskell.org/haskellwiki/CommunityMigration
13:57:06 <copumpkin> glguy: in general :P I wanna hear more about typenats and his presburger library :)
13:57:10 <aristid> template haskell isn't that bad :)
13:57:11 <copumpkin> but yeah, I don't "need" him
13:57:30 <Heffalump> SyntaxNinja: did you reach any conclusion on the subject of those backups?
13:58:44 <lispy> Heffalump: I know he hasn't call them yet
13:59:32 <Heffalump> Igloo did say he's be configuring the VM on lambda this week, so I guess he's in charge.
13:59:45 <Heffalump> s/he's/he'd/
14:00:19 <copumpkin> ddarius: dinner and yuzu tomorrow?
14:00:27 --- mode: copumpkin set -o copumpkin
14:01:50 <SyntaxNinja> Heffalump: I haven't checked with Tektonic. No one answered my email, and I wans't clear if someone had already done so.
14:02:15 <SyntaxNinja> Heffalump: I think Igloo seems to be in charge, but perhaps he's not willing to coordinate, not sure. 
14:02:30 <Heffalump> well, he implied he'd be doing it on his own, perhaps
14:02:37 <SyntaxNinja> copumpkin: I'm not physically in the same location as Iavor at the moment, but if I see him I'll mention it to him.
14:02:40 <Heffalump> which, if he has the time to do so quickly, would be most efficient
14:02:59 <copumpkin> SyntaxNinja: okay, not really important anyway :) and I don't want to pester him if he has work to do
14:03:11 <copumpkin> man, lots of galois people here these days
14:03:15 <SyntaxNinja> I can spend some time on this tonight. If we can get an old backup from before the compromise, that might be ideal, but it's not clear if those exist. If not, that's pretty disappointing because we're paying for that purpose.
14:03:25 <SyntaxNinja> s/purpose/service
14:03:25 <djahandarie> Yes, getting the typenats is more important than hearing about the typenats!
14:03:43 <Saizan> i can't darcs get typenat btw
14:03:46 <Heffalump> SyntaxNinja: yeah, it's worth chasing that down. Even if someone else has already tried (and I doubt it), not much harm done in trying again.
14:03:47 <SyntaxNinja> It seems like having the service up and patched is ideal os ew can do the migration. we'll have to get it up to get the data off anyway
14:03:54 <copumpkin> I was just talking to him on github about using his presburger solver for typenats
14:03:59 <SyntaxNinja> Heffalump: OK I'll see what I can do about that when I have a break in what I'm doing here.
14:04:01 <copumpkin> which he doesn't seem to be using
14:04:33 <SyntaxNinja> If I can, I'll just dig in tonight after work. this is probably going to take some time, but I"m worried that nothing is happening. makes the community look bad.
14:04:47 <Heffalump> yeah.
14:05:11 <Heffalump> once it's sorted, there's also an issue with ongoing sysadmin.
14:05:20 <SyntaxNinja> OK. Back to work. Thanks for the update, that's helpful. If we get things going again, we should put together an agreement at leats about how wer'e going to handle incidents.
14:05:57 <Heffalump> hopefully some of these present volunteers could also help with that.
14:06:07 <SyntaxNinja> Maybe we can each promise to be responsive and select a leader to coordinate.
14:06:55 * SyntaxNinja &
14:08:30 --- mode: monochrom set -q $~a
14:08:45 --- topic: set to '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
14:08:48 --- mode: monochrom set -o monochrom
14:10:47 <dfilimon> nighty night everyone, thanks for all the help :)
14:14:23 --- mode: glguy set -o glguy
14:30:37 * ddarius pokes edwardk.
14:32:39 * edwardk has been audibly poked. (copumpkin passed the message)
14:33:02 <edwardk> whats up?
14:33:16 <Philippa_> hell if I know, but hi anyway?
14:33:30 <dafis> ho
14:33:53 <ddarius> edwardk: I was wondering if you could send Mo the following link on my behalf: http://www.ted.com/talks/jake_shimabukuro_plays_bohemian_rhapsody.html
14:34:34 <ddarius> There are like 51 ways I could do it, but they all require me to register for something I dislike.
14:34:43 <mafs> edwardk: If you do, have copoumpkin send that to Mo. It's only proper that the chain keep up: ddarius -> copoumpkin -> edwardk -> copumpkin -> mo
14:34:44 <edwardk> ah
14:34:44 <djahandarie> Including Freenode? :P
14:34:51 <edwardk> yes
14:35:26 <copumpkin> mafs: hey, can you ask edwardk to remind me in person to pass it on to mo? I'm forgetful
14:35:30 <edwardk> passing along instructions to mo ;)
14:35:39 <edwardk> er to contact mo to copumpkin
14:35:48 <djahandarie> A forgetful copumpkin
14:35:51 <mafs> ;)
14:36:53 <edwardk> clearly he is right adjoint to a free copumpkin
14:37:02 <copumpkin> don't ask about my monads
14:37:12 <shachaf> /whois Mo
14:38:33 <edwardk> shachaf: a social media/game dev guy i've been trying to get into haskell for a while
14:42:46 <ddarius> edwardk: What's his resistance been?
14:42:56 <ddarius> Other than an unhealthy love of PHP?
14:43:31 <djahandarie> Is there a healthy dosage?
14:43:34 <edwardk> ddarius: practicality. he loves the idea of haskell
14:43:44 <edwardk> but hasn't been able to get into the practice
14:43:45 <Apocalisp> Pragmatism
14:43:52 <sproingie> mo on here would be como?  then you could ask Â¿como esta?
14:49:21 <ddarius> The world definitely needs more quasicoherent sheaves on schemes.
14:53:40 <roconnor> is there any standard mathematical notation for the composition of two coalgebras?
14:54:14 <Philippa_> composed how?
14:54:49 <roconnor> oh right I was totally unclear
14:54:50 <glguy> dcoutts: You about?
14:55:00 <aristid> @src groupBy
14:55:01 <lambdabot> groupBy _  []       =  []
14:55:01 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
14:55:01 <lambdabot>     where (ys,zs) = span (eq x) xs
14:55:12 <roconnor> so I really mean is there standard notation for this crazy function:
14:55:38 <roconnor> coalgCompose :: (a -> F a) -> (a -> G a) -> (a -> F (G a))
14:56:26 <roconnor> which now that I think about it, isn't really what "coalgebra composition" illicits
14:56:33 <copumpkin> *elicits
14:56:36 <roconnor> thanks
14:56:37 <edwardk> hrmm, i'm going to need to redefine all the distributive law transformers for Control.Recursion.* now that i've changed the way the comonad transformers work =/
14:56:40 * copumpkin looks awkward
14:56:51 <roconnor> edwardk: what has changed?
14:56:58 * sm would like a nice wiki ui for hakyll 
14:57:12 <copumpkin> sm: but the whole point of hakyll is to be static!
14:57:18 <roconnor> now I need a better name for that function, and a standard math notation for it.
14:57:27 <edwardk> roconnor: i commuted a lot of them to actually allow them to be comonad _transformers_. otherwise they didn't admit lowering t w a -> w a
14:57:33 <sm> sure, but it can still be useful to allow through-the-web maintenance
14:57:42 <edwardk> this was before the new comonad-transformers package
14:57:48 <edwardk> but they differ from category-extras
14:58:07 <edwardk> which is what the distributive law transformers in Control.Recursion.* are based on
14:58:09 <roconnor> edwardk: commuted?
14:58:20 <copumpkin> Coalgebra f a -> Coalgebra g a -> Coalgebra (f . g) a
14:58:31 <roconnor> copumpkin: yes, that is the function
14:58:40 <sm> and I guess I'd like it to do what gitit does too (rcs integration). Then it'd be equivalent to github's gollum+gollum-site
14:58:41 <copumpkin> I can see why you'd call it composition :P
14:58:58 <roconnor> copumpkin: indeed that is why I called it composition
14:59:18 <edwardk> CoreaderT e w a = w (e, a)   became EnvT e w a = EnvT e (w a)
14:59:34 <edwardk> the product moved outside
15:00:14 <roconnor> edwardk: thoses are not equivalent.
15:00:18 <edwardk> i know
15:00:20 <roconnor> :O
15:00:26 <roconnor> which one was wrong?
15:00:26 <edwardk> but the other has nicer properties
15:00:30 <edwardk> i fixed a lot of them that way
15:00:39 <roconnor> edwardk: what about StoreT?
15:00:42 <edwardk> most of the category-extras ones aren't what i'd want
15:00:48 * roconnor only cares about StoreT
15:00:54 <edwardk> when i say i fixed them i fixed them like a month ago ;)
15:01:00 <roconnor> oh
15:01:13 <edwardk> this is relative to category-extras, not comonad-transformers
15:01:29 <edwardk> i started pulling out the recursion schemes since thats the largest remaining chunk
15:01:52 <roconnor> edwardk: have you ever defined this function: Coalgebra f a -> Coalgebra g a -> Coalgebra (f . g) a
15:01:56 <edwardk> and the rest can be a couple of little knick-knack packages for fiddling with bifunctors and higher order or indexed functors, etc.
15:02:10 <edwardk> i'd just call it composition =)
15:02:16 <roconnor> :D
15:02:21 * ddarius would just call it Fk . h.
15:02:36 <edwardk> that sounds nicely pronounceable
15:03:14 <roconnor> ddarius: I think I need a shorter name for it since it is my monoidal product. 
15:03:44 <ddarius> Then call it what everyone calls their monoidal product: â 
15:04:14 <ddarius> However, now that you mention that, I'm reminded of papers with coalgebra and modal logic.
15:04:39 <roconnor> ddarius: well I have at two monoidal categories
15:04:54 <roconnor> ddarius: though one of them has a cartesian product, so maybe I can use this symbol for this one.
15:06:15 <edwardk> so i have a win win, either i get a successfully redefined distZygoT, or i wind up defining a ZygoT comonad.
15:06:41 <roconnor> edwardk: the real winners are the prepromorphisms
15:06:52 <edwardk> those will come later ;)
15:06:56 <copumpkin> what about the poor histo?
15:07:03 <edwardk> histo/futu are coming
15:07:14 <edwardk> define in terms of the streams package
15:07:42 <edwardk> er defined
15:09:07 <roconnor> oh wait, CoalgebraCompose isn't my monoidal product, it is my natural transformation for my lax monoidal functor.
15:09:14 <roconnor> ugh, so may components
15:09:22 <aristid> @src init
15:09:22 <lambdabot> init [x]    = []
15:09:23 <lambdabot> init (x:xs) = x : init xs
15:09:23 <lambdabot> init []     = undefined
15:09:29 <aristid> @src last
15:09:30 <lambdabot> last [x]    = x
15:09:30 <lambdabot> last (_:xs) = last xs
15:09:30 <lambdabot> last []     = undefined
15:10:48 <edwardk> hrmm, i wind up with a different distZygoT signature. the semimutual recursion loses access to the comonad, but this makes it simpler
15:13:06 <ddarius> Anyway, given Ï : F -> G and Ï : H -> K, Ï*Ï : F â H -> G â K, so let F and H be Id and get Ï*Ï : Id -> G â K
15:13:13 <ddarius> I.e. it's horizontal composition.
15:13:50 <aristid> @pl decapitalise xs = zipWith ($) (id : (map (const toLower) . init . tail $ xs) ++ [id]) xs
15:13:51 <lambdabot> decapitalise = zipWith id =<< (id :) . (++ [id]) . map (const toLower) . init . tail
15:13:59 <ddarius> But horizontal composition only applies to natural transformations.
15:15:10 <roconnor> ddarius: coalgebras are natural transformations.
15:15:36 <roconnor> is * standard notatation for horzionatal compositon?
15:16:11 <ddarius> No, coalgebras are specific arrows A -> F A, though A could be a functor if you are talking about coalgebras in a functor category.
15:16:14 <edwardk> ok, new distZygo defined.
15:16:21 <ddarius> roconnor: More or less, yes.
15:16:57 <roconnor> oh right
15:18:09 <aristid>  > autoCapitalisation "MalformedPOSTRequest" -- for generating Haskell identifier
15:18:09 <aristid> "MalformedPostRequest"
15:18:50 <aristid> i hate runs of capital letters :)
15:19:07 <ddarius> > autoCaptilisation "XMLHTTPRequest"
15:19:07 <lambdabot>   Not in scope: `autoCaptilisation'
15:19:09 <hpc> heh
15:19:14 <ddarius> > autoCapitilisation "XMLHTTPRequest"
15:19:15 <lambdabot>   Not in scope: `autoCapitilisation'
15:19:25 <ddarius> Too many 'i's.
15:19:31 <ddarius> > autoCapitalisation "XMLHTTPRequest"
15:19:32 <lambdabot>   Not in scope: `autoCapitalisation'
15:19:35 <hpc> @let autoCapitalisation = id
15:19:37 <lambdabot>  Defined.
15:19:38 <hpc> :D
15:20:30 <aristid> ddarius: hmm yeah, XMLHTTPRequest would not work :/
15:21:01 <ddarius> Actually, * is defined in any bicategory, so just form your coalgebras into a bicategory.
15:21:05 <Feuerbach> Hi ddarius! I have a patch for parsec 3, who should I send it to? Also, is there any public source control repository for parsec 3?
15:21:10 <aristid> it would become XmlhttpRequest :D
15:21:13 <elliottt> is arrow notation rebindable the same way that do-notation is?
15:21:27 <elliottt> (in ghc)
15:22:24 <elliottt> ah, NoImplicitPrelude
15:23:37 <ddarius> Feuerbach: The darcs repo is at code.haskell.org/parsec3 (which is currently down)
15:24:06 <ddarius> Feuerbach: I'm just about to switch maintainership to Antoine Latter actually.
15:24:12 <elliottt> still seems to complain in ways that make me think it's not using my functions...
15:25:46 <Feuerbach> ddarius: I heard about it on libraries@, hence the question. Also I'm confused by the fact that the maintainer of parsec3 package on hackage is yet another guy
15:26:09 <ddarius> Feuerbach: Me too.
15:26:34 <ivanm> I wonder if the rate of submissions to the haskell reddit has dropped because planet is down (and thus people don't know which blog posts are now available)... :p
15:26:44 <aristid> @hoogle search
15:26:45 <lambdabot> System.Directory searchable :: Permissions -> Bool
15:26:45 <lambdabot> System.FilePath.Posix searchPathSeparator :: Char
15:26:45 <lambdabot> System.FilePath.Windows searchPathSeparator :: Char
15:27:07 <ivanm> I can almost understand the need for parsec2, but why split off parsec3 as well?
15:27:36 <aristid> search :: [a] -> [a] -> ([a], Bool, [a])
15:27:53 <ddarius> There's parsec1, parsec2, and parsec3, where parsec1 is make-believe.
15:28:08 <aristid> @hoogle [a] -> [a] -> ([a], Bool, [a])
15:28:09 <lambdabot> No results found
15:28:25 <ivanm> ddarius: "make-believe"?
15:28:34 <aristid> @hoogle [a] -> [a] -> ([a], [a])
15:28:35 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
15:28:35 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
15:28:35 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
15:29:25 <ddarius> ivanm: Insofar as what is putatively "Parsec 1" was also not Haskell 98.
15:29:34 <lispy> make believe
15:29:34 <lispy> make: *** No rule to make target `believe'.  Stop.
15:30:00 <aristid> so, how to search for subsequences in lists?
15:30:11 <ivanm> ddarius: ahhh, right, yeah, I was wondering about that
15:30:22 <ivanm> aristid: what kind of searching are you after?
15:30:47 <copumpkin> :t flip filter . (init . tails <=< tail . inits)
15:30:48 <lambdabot> forall a. [a] -> ([a] -> Bool) -> [[a]]
15:30:57 <copumpkin> :t flip (flip filter . (init . tails <=< tail . inits))
15:30:58 <lambdabot> forall a. ([a] -> Bool) -> [a] -> [[a]]
15:31:05 <copumpkin> there you go
15:31:06 <aristid> ivanm: like in a normal text search
15:31:17 <aristid> Ctrl-F in firefox, for example
15:31:22 <copumpkin> nice and efficient ;)
15:31:39 <ivanm> aristid: implement a text-searching algorithm for efficiency, use what copumpkin said if you don't care
15:31:45 <copumpkin> > flip (flip filter . (init . tails <=< tail . inits)) (== "ohai2u") "omg my name is ohai2u whatsurz?"
15:31:47 <lambdabot>   ["ohai2u"]
15:31:54 <ivanm> bird's book derives BM and KMP from first principles :o
15:32:15 <aristid> ivanm: but there's nothing half-decent somewhere?
15:32:55 <ivanm> already implemented?
15:33:03 <aristid> yup
15:33:18 <ivanm> hayoo doesn't seem to think so
15:33:32 <aristid> :(
15:34:36 <ivanm> well, there's the stringsearch package
15:34:37 <ivanm> http://www.holumbus.org/hayoo/hayoo.html?query=search#0:%20package%3Astringsearch
15:34:46 <ivanm> but it seems to be on bytestrings
15:34:51 <copumpkin> aristid: use mine! it's very short
15:35:21 <copumpkin> > flip (flip filter . (init . tails <=< tail . inits)) (all isUpper) "omg my nAMe is ohai2u WHATZURZ?"
15:35:23 <lambdabot>   ["A","AM","M","W","WH","H","WHA","HA","A","WHAT","HAT","AT","T","WHATZ","HA...
15:35:26 <aristid> copumpkin: can you adapt it to a search & replace? :)
15:35:37 <copumpkin> maybe I should filter out substrings
15:36:06 <ddarius> Does text have anything?
15:36:12 <copumpkin> > flip (flip filter . (init . tails >=> tail . inits)) (all isUpper) "omg my nAMe is ohai2u WHATZURZ?"
15:36:14 <lambdabot>   ["A","AM","M","W","WH","WHA","WHAT","WHATZ","WHATZU","WHATZUR","WHATZURZ","...
15:36:35 <copumpkin> ddarius: it has an efficient search for a constant Text value
15:36:47 <copumpkin> not sure how you'd do search by an arbitrary predicate efficiently (or I don't think it's possible)
15:36:47 <aristid> ddarius: i will look, but my internet is very slow right now.
15:37:03 <copumpkin> unless your predicate returned an "unconsumed part"
15:37:20 <aristid> copumpkin: constant Text would be ok. well, if i did not use String *sigh*
15:37:34 <ivanm> aristid: haven't you heard? String is deprecated!
15:37:35 <ivanm> :p
15:37:42 <ddarius> copumpkin: http://www.springerlink.com/content/338655u418363548/
15:37:43 <aristid> ivanm: no u r
15:37:50 * djahandarie still uses String
15:37:53 <copumpkin> :t \s -> filter (== s) . tails
15:37:53 * ivanm goes back to trying to work out why his Text-based parser uses more memory than the String-based one did :s
15:37:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [[a]]
15:38:10 <copumpkin> that's actually not terrible efficiency-wise
15:38:18 <copumpkin> it's not great though
15:38:19 <aristid> i only need this in some template haskell, so efficiency is not the biggest concern
15:38:42 <aristid> copumpkin: that only searches in the tails
15:39:02 <copumpkin> oh I meant
15:39:24 <copumpkin> :t \s -> let l = length s in filter ((== s) . take l) . tails
15:39:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [[a]]
15:39:31 <Twey> ivanm: Needs more laziness?
15:39:42 <ivanm> Twey: I'm thinking too much laziness
15:39:43 <aristid> copumpkin: oh, nice
15:39:54 <Twey> ivanm: Isn't Text a strict bytestring underneath?
15:39:58 <aristid> copumpkin: but i think we can improve, syntax-wise!
15:40:01 <ivanm> specifically, it occurs in the pre-processing step: too many chunks are created and then concatted together
15:40:04 <copumpkin> aristid: I'm sure :P
15:40:09 <ivanm> Twey: I'm using lazy Text values
15:40:13 <Twey> Ah
15:40:16 <Twey> Hm
15:40:20 <ivanm> and I'm pretty sure it uses a different datatype
15:40:22 <aristid> :t \s -> filter (s `isPrefixOf`) . tails
15:40:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [[a]]
15:40:24 <copumpkin> ddarius: paywall :(
15:40:27 <ivanm> bos: does Text use Bytestrings under the hood?
15:40:32 <copumpkin> I think I still have an account at my university though
15:40:35 <copumpkin> ivanm: no
15:40:36 <aristid> copumpkin: :)
15:40:54 <bos> ivanm: no
15:41:01 <ivanm> didn't think so
15:43:14 <ddarius> copumpkin: I know.  The paper may be available elsewhere.  I've never read it.
15:43:17 <helmut> hi. can you tell me what's the name for readdir in haskell? I had a hard time finding this with google. :-/
15:43:36 <ddarius> (Or at least I don't think I've read it.  Hard to tell nowadays.)
15:44:08 <ivanm> helmut: for what?
15:44:18 <ivanm> @hackage directory
15:44:18 <lambdabot> http://hackage.haskell.org/package/directory
15:44:23 <ivanm> helmut: ^^ something like that?
15:45:14 <helmut> ivanm: *doh* I found System.Directory, but somehoe didn't see getDirectoryContents
15:46:01 <aristid> @src find
15:46:02 <lambdabot> find p          = listToMaybe . filter p
15:50:33 <ddarius> How to turn failure into a list of at most one success.
15:51:22 <helmut> hmm. can I somehow declare some data Foo a = ... but require like Ord a?
15:52:00 <Twey> helmut: Yes, with an extension, but it's usually seen as better to put the constraint on the functions that use the type
15:52:04 <helmut> I'd guess data Ord a => Foo a = ... is it really as simple as this?
15:52:31 <helmut> Twey: yeah. I was doing this, but I was annotating every single function with the same stuff. :-/
15:52:35 <Ferdirand> helmut, no, this will not do what you think
15:53:17 <Twey> helmut: data Foo a = Ord a => â¦
15:53:19 <Twey> I think
15:53:41 <Twey> Maybe not, hm
15:53:43 <helmut> ok. I'll continue annotating a few more functions (just generalized Foo)
15:54:28 <ivanm> ddarius: maybeToList ?
15:55:27 <helmut> Twey: you seem right. I actually need to add different constraints to different functions. :-)
16:00:47 <glguy> If there are any Minecraft players here, I've been toying around with a Haskell project http://www.github.com/glguy/minecraft-proxy
16:01:21 <copumpkin> preflex: seen j-invariant
16:01:21 <preflex>  j-invariant was last seen on #haskell 22 hours, 4 minutes and 9 seconds ago, saying: Cale: that is different to solipsism?
16:01:42 <elliott> glguy: that violates our patents!
16:01:42 <aristid> @src lookup
16:01:43 <lambdabot> lookup _key []          =  Nothing
16:01:43 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
16:02:00 <glguy> elliott: I need more context
16:02:09 <elliott> glguy: the minecraft proxy :)
16:02:10 <copumpkin> glguy: but what does it do!?
16:02:29 <elliott> oh, yours lets you show dirt/stone/grass as glass? nice, ours doesn't have that (yet)
16:02:38 <copumpkin> :O
16:02:59 <glguy> copumpkin: at this point it can alter your dig speed, set your compass to follow another player, you can turn all dirt/grass/stone to glass OR you can turn a 10-radius sphere of one kind of block at a time to glass
16:03:06 <glguy> and then you can revert that
16:03:11 <glguy> (client side only, not server affecting)
16:03:21 <elliott> glguy: hmm, we played with the dig speed but had troubles getting it reliable
16:03:30 <elliott> does yours work better than "hit it, wait for server lag, it's probably disappeared"?
16:03:43 <glguy> nope, but that does ok for my purposes :)
16:03:50 <glguy> I just drag my mouse across many blocks 
16:04:15 <glguy> I have a line-drawing mode
16:04:21 <elliott> ours mostly does mapping and $thing_i_won't_reveal_in_public_channel
16:04:23 <glguy> you click two end-points and it fills in the blocks
16:04:28 <elliott> might have to steal your glass logic though :p
16:04:40 <glguy> sure, take wha tyou need
16:04:48 <glguy> its BSD3
16:05:01 <copumpkin> have you broken through the bottom of the world?
16:05:06 <copumpkin> like that video with the giant bomb?
16:05:13 <elliott> i think that would make the server nullpointer
16:05:15 <glguy> I've fallen through without a bomb or hack before
16:05:17 <elliott> at least large amounts of tnt tend to
16:05:25 <elliott> glguy: there are holes in pre-halloween terrain bedrock
16:05:26 <copumpkin> (I don't play minecraft. it probably shows)
16:05:34 <glguy> elliott: that's what I fell through, then
16:05:48 <glguy> elliott: do you have a url to share with me?
16:05:50 <aristid> @src isPrefixOf
16:05:50 <lambdabot> isPrefixOf [] _          = True
16:05:50 <lambdabot> isPrefixOf _  []         = False
16:05:50 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
16:05:57 <elliott> glguy: yes, in /msg (i'll explain why)
16:06:02 <copumpkin> o.O
16:06:06 <copumpkin> omg sekritz
16:07:19 <monochrom> we should set up a game "headcraft". you shoot category-theoretic haskell code to your opponents, and they head-explode.
16:11:21 <helmut> (style question) would I write readFile filename >>= (return . transformIt) or use a do syntax?
16:12:09 <parcs> transformIt <$> readFile filename
16:12:54 <helmut> thanks
16:13:17 <beastaugh> @type (<$>)
16:13:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:13:29 <helmut> hmm. not in scope...
16:13:35 <parcs> it's in Data.Functor
16:13:54 <helmut> I better not confuse my self now and use some more explicit notation
16:13:57 * hpc generally just imports Control.Applicative
16:14:00 <parcs> would be nice if it were in the prelude, though. i use it in every one of my scripts
16:14:09 <parcs> helmut: then use fmap
16:14:18 <Saizan> helmut: transformIt `fmap` readFile filename <- won't require imports
16:15:09 <parcs> oh nice, <$> is exported in Control.Applicative
16:15:56 <helmut> ok
16:16:18 <drbean> @type fmap
16:16:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:17:28 * helmut starts to get used to hoogle.
16:19:22 <hpc> oh, i need to set up that bookmarklet again
16:29:47 <aristid> damn, i'm too stupid to write a search&replace function
16:30:09 <aristid> searchReplace :: Eq a => [([a], [a])] -> [a] -> [a]
16:31:30 <dibblego> is there any way to get to a function that is not exported by a module?
16:31:57 <hpc> dibblego: from in or out of the module? :P
16:32:07 <hpc> (one is impossible, the other quite easy)
16:32:13 <dibblego> out of course
16:32:29 <elliott> dibblego: yes, just use unsafeCoerce
16:32:35 <elliott> and pass it a sacrificed goat as the argument
16:48:13 <helmut> is there a substring test that is quicker than the dumb approach?
16:55:28 <dcoutts> glguy: pong
16:55:57 <shachaf> helmut: For linked lists?
16:56:35 <glguy> dcoutts: I was curious if Codec.Compression.Zlib.Internal was named internal because I shouldn't expect it to stay consistent between releases
16:56:51 <glguy> I'm interested in using the stream mode that doesn't hide errors in the bytestring
16:57:14 <helmut> sciolizer: I am trying to read a series of files and determine some features (do they contain a word?)
16:57:25 <helmut> sciolizer: sorry, wrong tab complete
16:57:55 <dcoutts> glguy: that's correct, not guaranteed stable
16:58:00 <helmut> shachaf: (see above) and it seems that my method of determining whether the file contents contain a word is taking most of the time
16:58:17 <dcoutts> glguy: but I'm also reasonably happy with that API and may expose it properly in the next release
16:58:23 <glguy> dcoutts: any intention for future versions that support pure error handling?
16:58:36 <dcoutts> glguy: right
16:59:14 <dcoutts> glguy: so I'd suggest just use it, but I can't promise I won't change it and then make it more public :-)
16:59:19 <helmut> I seem to be getting more problems. ghci starts eating my memory. :-(
17:00:16 <dcoutts> glguy: the other major change I want is to allow incremental push style input, probably in the ST monad
17:04:09 <helmut> ahh. ghci is finished, now I got a decision tree for classifying my spam :-)
17:06:10 <Saizan> btw, compiled code usually performs much better
17:06:29 <glguy> complicated*
17:06:47 <glguy> :-D
17:07:22 <helmut> I'm a bit amazed that it took just 150 lines to write. and half of it is comments :-)
17:07:32 <edwardk> glguy: hah i parsed it that way at first as well =)
17:07:54 <copumpkin> oh so I have a datastructure I want
17:07:58 <copumpkin> can anyone make it for me?
17:07:58 <copumpkin> kthx
17:08:04 <edwardk> sure
17:08:07 * hackagebot recursion-schemes 0.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.1 (EdwardKmett)
17:08:35 <companion_cube> this is an appealing package name
17:09:08 * hackagebot comonad-transformers 0.10.1.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.10.1.1 (EdwardKmett)
17:09:15 <byorgey> awesome, edwardk is in another one of his Productive Phases =D
17:09:22 <edwardk> i recommend cooking the bananas using the lenses, and eating the _before_ wrapping them in barbed wire
17:09:35 <edwardk> byorgey: heh
17:09:36 <copumpkin> so I have a map indexed by bitmasks and equalities on them. So MagicMap has as keys Eq a, Bits a => (a, a), and arbitrary values. You can then look up any such a value, and if the looked-up key masked with the mask is equal to the result, the associated value is returned
17:09:46 <geheimdienst> edwardk: when do you recommend the step of generalizing?
17:09:50 <companion_cube> someone knows anything about bananas in programming/math context ?
17:09:54 <edwardk> all my phases are productive, they just aren't often relevant to you ;)
17:09:58 <copumpkin> it's basically an encoding of a decision tree in terms of bitmasks
17:10:05 <byorgey> edwardk: yes, I figured =)
17:10:09 <edwardk> copumpkin: robdd?
17:10:10 <shachaf> edwardk: How do you eat something *before* wrapping it in barbed wire, exactly?
17:10:46 <copumpkin> there's an additional constraint in that I have an ordering on how I want to build it
17:10:46 <byorgey> shachaf: you just wrap the barbed wire around yourself
17:10:54 <edwardk> shachaf: clearly you'll have the peel left!
17:11:00 <shachaf> Mm, I see.
17:11:30 <edwardk> gehemdeinst: typically for me? all the time. when i want actual users? i try to force myself down to haskell 98, then see what i can generalize within that context.
17:11:34 <edwardk> i find it makes a good rule of thumb
17:11:52 <copumpkin> so I basically have [((Word32, Word32), v)] and the order is important
17:11:53 <copumpkin> :P
17:12:11 <edwardk> companion_cube: bananas in programming are a fancy way to referring to folds
17:12:23 <dankna> I didn't read the context of this discussion, but I do what edwardk just said, too.  That is, I try to write with no extensions and turn them on one by one as I need them.
17:12:27 <companion_cube> oh, ok
17:12:31 <dankna> My reasoning is that that way I'll gain familiarity with what they actually do.
17:13:43 <edwardk> i actually go the other way, i start with everything, then try to dumb it down to something that fits in 98 ;)
17:13:59 <dankna> haha okay
17:14:15 <edwardk> this helps me locate what should be 'core' packages
17:14:23 <dankna> hmm
17:14:25 <dankna> yeah, okay
17:19:33 <Saizan> looks like eden has all the code to go from an arbitrary value on the heap to the string of bits representing the graph and back, only within the same binary though
17:20:03 <Saizan> (except for mvars and similar)
17:20:31 <Saizan> i wonder why they use a global buffer for it though..
17:32:07 <accel> how big are the files yi can edit? can it handle 2GB files?
17:35:23 <gwern> @quote
17:35:23 <lambdabot> remember says: the 5th of november
17:38:46 <aristid> @quote gwern
17:38:46 <lambdabot> gwern says: Haskellers! Tonight we write in Malbolge!
17:51:39 <accel> is it supposed to be impossible to build yi from source ?
17:51:46 <gwern> no
17:51:47 <roconnor> oh I forgot I left boxcard2d.com running
17:51:56 <roconnor> heh, nice design
17:53:27 <accel> I did a "cabal install happy"
17:53:36 <accel> yet "cabal info happy" still shows installed version as [unknown]
17:54:19 <accel> do I need to include ~/.cabal/happy in my PATH ?
17:55:26 <siracusa> accel: happy will be installed as executable, try `happy --version'
17:55:47 <accel> happy --version
17:55:47 <accel> Happy Version 1.18.6 Copyright (c) 1993-1996 Andy Gill, Simon Marlow (c) 1997-2005 Simon Marlow
17:56:05 <ivanm> accel: "cabal info" and "cabal list" only talk about libraries
17:56:18 <accel> hmm, haskell-src-exts is now happy
17:56:20 <ivanm> cabal-install doesn't keep track of what it has installed; it just relies on ghc's pkg-db
17:56:35 <accel> does cabal install take a parameter to say how many threads to use?
17:56:40 <gwern> no
17:56:48 <gwern> parallelism is not in it yet.
17:56:53 <accel> so even if i have 1024 cores, it'll only have 1 ghc instance at a time?
17:57:55 <gwern> pretty much
17:59:50 <accel> err, hypothetically
17:59:55 <accel> if hackage.haskell.org ever got owned
18:00:05 <accel> would cabal just happiy install malicious code?
18:00:28 <Saizan> yes
18:00:49 <joaopizani> I've never seen something as package signing for hackage
18:00:57 <joaopizani> It is a good idea to implement
18:01:38 <joaopizani> BUT, on the other hand, java jars can be signed and nobody really cares...
18:02:17 <accel> yi-0.6.2.4 depends on derive-2.3.0.2 which failed to install
18:02:21 <accel> wtf, how do I install yi ? :-)
18:02:31 <accel> derive-2.3.0.2 failed during the building phase. The exception was:
18:02:31 <accel> ExitFailure 1
18:02:33 <ivanm> accel: which version of GHC?
18:03:00 <Saizan> accel: there should be a more informative error up in the log
18:03:04 <ivanm> maybe get a newer version of derive?
18:03:21 <Saizan> assuming yi can work with it..
18:03:26 <Saizan> @hackage yi
18:03:27 <lambdabot> http://hackage.haskell.org/package/yi
18:03:31 <accel> ghc 6.12.1
18:03:32 <ivanm> if you edit yi.cabal then it will build with derive-2.4
18:03:38 <accel> Saizan: yi wants that particular version
18:03:44 <accel> ivanm: a-ha!
18:03:53 <ivanm> it should also build with the various gtk2hs libraries at 0.12
18:04:03 <ivanm> and newer unix-compat
18:04:15 <ivanm> and time-1.2
18:04:16 <ivanm> etc.
18:04:32 <accel> why is this not fixed? is yi dead?
18:05:04 <Saizan> last release has been in july
18:06:42 <accel> does cabal not have an de-install / remove ?
18:07:03 <Saizan> there's just ghc-pkg unregister
18:07:21 <ivanm> accel: remember, cabal-install is not a package manager
18:07:28 <ivanm> it's just an automated way to download and build haskell packages
18:07:38 <accel> i'm not root
18:08:03 <ivanm> what does that have to do with anything?
18:08:12 <joaopizani> it's just very tempting to think of cabal uninstall when we are used to "cabal install" stuff
18:08:31 <accel> ghc-pkg configure <-- requires I be root
18:08:45 <ivanm> oh
18:08:46 <gwern> --user
18:08:50 <ivanm> exactly
18:09:01 <Saizan> *unregister
18:09:11 <accel> crap, I already nuked ~/.ghc and ~/.cabal
18:09:12 <accel> trying again
18:09:30 <ivanm> don't need to be root to do ghc-pkg unregister ...
18:09:43 <accel> is there anyway to tell cabal: "install all the dependencies of 'yi', while I go and get a coffee" ?
18:10:24 <ivanm> just the dependencies? don't think so
18:10:35 <ivanm> it's often asked for though
18:10:53 <Saizan> if you "cabal install yi" it'll do that anyway
18:11:03 <ivanm> Saizan: I think he wants to edit the cabal file
18:11:14 <Saizan> or just "cabal install" from the source tree
18:11:17 <accel> so "cabal install yi", wait for feailure, then cabal fetch yi + manual cabal install ?
18:11:35 <Saizan> ?
18:11:52 <Eduard_Munteanu> Saizan: he wants to do that AFTER getting some coffee ;)
18:11:55 <Saizan> cabal unpack yi; cd yi; ..edit all you want..; cabal install
18:12:08 <Eduard_Munteanu> And install the deps in the meanwhile.
18:12:16 <Saizan> they'd be the wrong deps.
18:12:33 <accel> crap, "cabal install yi" <-- getting me wrong deps?
18:13:04 <accel> okay, failure achieved
18:13:10 <accel> cabal unpack yi
18:13:26 <accel>         build-depends: derive >=2.3 && <2.4 
18:13:31 <accel> damn, why does it want <2.4 ?
18:15:07 <accel> trying w/ 2.4 anyway
18:15:42 <gwern> @quote
18:15:42 <lambdabot> bos says: it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
18:18:43 <accel> question is
18:18:47 <accel> what does "yi" not depend on
18:18:53 <accel> i'm installing gtkhs and cairo for this "yi"
18:18:56 <accel> it better be worth it
18:19:05 <gwern> it isn't
18:19:18 <accel> oh
18:19:25 <accel> why not?
18:19:32 <gwern> really, I think you might be better off looking at leksah or manatee
18:19:34 <accel> it's _the_ haskell editor
18:19:46 <gwern> those are haskell editors too
18:19:50 <Eduard_Munteanu> For me, that 'the' is vim.
18:20:02 <accel> Eduard_Munteanu: what do you use for indenting?
18:20:15 <Eduard_Munteanu> Erm, you can use softtabs?
18:20:22 <accel> as in manually?
18:20:49 <Eduard_Munteanu> accel: what do you mean?
18:21:25 <accel> gereedy: manatee is is interesting
18:21:28 <accel> Manatee is not design for WM, it's design for OS, so don't compare it with XMonad, it's really different thing with XMonad. Please watch Window split feature carefully in video to understand the difference, Manatee can split unlimited window for same application : 
18:21:35 <accel> so basically, it's claiming to be more than emacs
18:21:46 <Eduard_Munteanu> I just do something like 'set ts=4' (or 8) and 'set expandtab'
18:22:15 <Eduard_Munteanu> That's all if you want tabs to be expanded to spaces.
18:22:33 <gwern> accel: well, you can run emacs as a WM or OS
18:22:40 <gwern> so perhaps those claims aren't quite right
18:23:31 <Eduard_Munteanu> I also have a neat file so I can write \forall and have â appear.
18:24:27 <gwern> Eduard_Munteanu: bah, emacs had that first!
18:24:35 <accel> gwern: thanks for mentioning manatee, it's by far the most interesting proejct ive seen in a long time
18:24:37 <gwern> or rather it had something close
18:24:40 <Eduard_Munteanu> Heh.
18:24:48 <gwern> accel: and manatee will probably install, too
18:26:12 <accel> so basically manatee says: I need linux and gtk; but nothing else
18:26:42 <accel> gwern: just installed + run yi
18:26:42 <accel> woot
18:26:45 <accel> time to try manatee now
18:27:35 <Eduard_Munteanu> Hm, to think about it, I fooled around with coqide, it was there.
18:28:05 <Eduard_Munteanu> But I generally prefer not to have to change my tools across different languages.
18:50:11 <SyntaxNinja> any haskell-infrastructure folks around?
18:51:09 <SyntaxNinja> Igloo: alive?
18:54:18 <copumpkin> it's pretty late over there
18:57:42 <accel> why is there *.hs rather than only *.lhs ?
19:00:28 <Saizan> often you've more code than comments
19:00:38 <sshc_> Hi, could any of you suggest a good example of QuickCheck?
19:02:28 <gwern> sshc_: I like keeping around an old simple inefficient function and then testing it against its efficient replacements
19:02:48 <gwern> neat use of quickcheck. not quite proving function equivalence but often as good
19:04:16 <gwern> sshc_: see http://book.realworldhaskell.org/read/testing-and-quality-assurance.html which I think includes that
19:04:28 <accel> gwern: tell me more; can you automate "proof" ? of do you just generate random input ?
19:04:42 <gwern> accel: latter. that's why I said it's not a proof
19:04:51 <accel> real world haskell is amazing; it's like someone who's not an academic wrote a boko on how to use haskell
19:13:22 <byorgey> accel: ...that's exactly what happened.
19:13:53 <gwern> don is sort of an academic. I mean, he's a doctor now
19:13:56 <deech> Anyone here use emacs-mode with literate haskell? If so is there a way to automatically stick bird-tracks on code lines?
19:15:42 <dons> hmm ?
19:15:46 <byorgey> deech: I have been wondering that myself, let me know if you find a nice way to do it
19:16:15 <gwern> dons: didn't you have that phd thesis or what not and are a doctor now? that's pretty academic
19:16:29 <deech> byorgey: I've looked through the source and don't see a way, I thought maybe I was overlooking something.
19:16:45 <dons> oh, i have a phd, yes. but i've been working in industry for 4 years (all the authors have commercial jobs, though i have the  most academic background)
19:17:27 <gwern> dons - not the kind of doctor you want on your plane
19:17:36 <dons> depends on what's wrong with the plane
19:17:58 <dons> ;)
19:18:11 <gwern> its Java stabilizers are null-pointer exceptioning!
19:18:29 <accel> dons: what happened to yi?
19:18:45 <dons> jyp is the maintainer for the past few years. 
19:21:51 <accel> so it's still more of an academic project
19:21:57 <accel> than a full blown tool like xmonad?
19:22:28 <byorgey> it's a pretty full-blown tool.
19:22:41 <accel> but it has like 10 users world wide
19:22:53 <monochrom> there is much false dichotomy of academic vs practical
19:23:00 <byorgey> so it's not a *popular* full-blown tool, so what?
19:23:58 <monochrom> FWIW there are many more company projects abandoned than academic projects abandoned. Companies are just better at not letting you know there were projects to begin with.
19:24:34 <systemfault> Companies also rarely innovates.
19:24:42 <accel> monochrom: interesting theory
19:24:43 <systemfault> Just take a look at java.
19:24:51 <argiopeweb> I'm looking for a brain cycle efficient way to represent matrix of finite but not necessarily well known size. Can anyone recommend a direction in which to look?
19:24:58 <dons> accel: it's an open source project. not used for research. though it hasn't got the narrow focus of xmonad
19:25:03 <dons> accel: different project goals
19:25:06 <argiopeweb> s/matrix/matrices/g
19:25:08 <gwern> accel: jyp sees yi as something of a test bed for things like finger trees and lazy lexers or things like that
19:25:16 <accel> dons: yet somehow, isn't xmonad more popular than yi?
19:25:17 <gwern> accel: I havne't followed his research very carefully
19:25:32 <dons> accel: defintely. the goal of xmonad was to be very popular :)
19:25:42 <gwern> accel: xmonad does tiling very very well. the only thing yi can be said to do well is indent and highlight haskell
19:25:46 <accel> gwern: ah, so the point was not "let me write a haskell editor in haskell" but rather "i have some crazy lazy data structure ideas; let me test it out in an editor" ?
19:25:48 <systemfault> A tiling WM, popular? :P
19:26:00 <monochrom> Not theory. Practical software people like Yourdon and Brook testify it.
19:26:01 <systemfault> As much as I love you guys... It's not gonna happen.
19:26:05 <accel> dons: I recently switched from xmonad to awesome :-)
19:26:13 <dons> well, thousands of users, using it daily. works for me.
19:26:23 <dons> accel: enjoy your configuration and dependency fun
19:26:28 <systemfault> xmonad is really nice for a tiling WM :)
19:26:46 <gwern> accel: no, it's more like tuomo/dons: 'let's write a text editor in haskell!'...years pass...jpb: 'I wonder what I and my students could do with the finger trees used for buffers and the parsers for syntax highlighting'
19:26:52 <systemfault> But I must admit defeat.. I never was able to use a tiling WM :(
19:27:01 <accel> dons: you know, after going from xmonad to awesome, from haskell to lua; i sutdeently started missing types; but nevertheless, awesome has just been infinitely easier to configure
19:27:19 <accel> gwern: jpb is a professor?
19:27:40 <gwern> accel: he's some sort of academic last I looked at his pages 2 years ago or whatever
19:27:46 * dons -> boarding a plane. 
19:27:46 <dankna> don't worry about the text editor problem, I have it solved in the future :)
19:27:53 <accel> gwern: what's full name? I don't see jgp listed on the yi webpage
19:28:00 <dankna> it will take me two years as soon as I get started on it :)
19:28:13 <accel> dankna: as I need features, will you implement them?
19:28:17 <dankna> absolutely!
19:28:18 <gwern> accel: look in the distro or something - jean phillipe bernardy or something
19:28:44 <accel> dankna: if multiple need features will you impelemtn ti multiple times or memorize?
19:28:59 <dankna> oh, the latter of course
19:29:12 <gwern> memoize, I hope you meant
19:29:19 <dankna> it will contain an upload of my own brain, so as to be able to write the features for you
19:29:41 <accel> eh; research doens't look all that itneresting
19:30:12 <djahandarie> Does anyone know Marc Bender?
19:45:17 <djahandarie> These are some damn cool videos
19:46:01 <monochrom> "Marc the last Air Bender"? :)
19:46:14 <djahandarie> http://www.youtube.com/watch?v=HW8PL5A8u-4&feature=BF&list=PLB625A791362CEB2B&index=1
19:47:02 <monochrom> is there a more efficient presentation? i.e., text.
19:47:07 <djahandarie> Yes, thesis
19:47:25 <djahandarie> http://www.cas.mcmaster.ca/~bendermm/research.html
19:59:55 <shepheb> Hackage down for anyone else?
20:00:49 <monochrom> up for me
20:01:17 <monochrom> you may also find http://www.downforeveryoneorjustme.com/ useful when no one is around :)
20:04:35 <Ziphilt> Saizan: so i just finished my upgrade, and i have been reinstalling haskell stuff. cabal tells me that the package ghc is not available from the server, and that no package called that exists. looking at http://www.haskell.org/ghc/download_ghc_6_12_3 tells me that i should stick to the version i got with haskell-platform, which is still 6.12.1
20:05:51 <Ziphilt> should i still get the package manually from haskell.org as you said?
20:05:51 <Saizan> Ziphilt: you don't get ghc with cabal
20:06:18 <glguy> Ziphilt: what distribution?
20:06:30 <Ziphilt> Ubuntu 10.10
20:06:30 <glguy> some package the ghc library separately from ghc
20:06:40 <Saizan> and i think you probably should, you won't have the packages from the platform already installed
20:06:49 <Saizan> glguy: he doesn't want the ghc library
20:06:59 <glguy> Saizan: well, the ghc package
20:07:07 <glguy> Fedora does this
20:07:50 <Ziphilt> also, the haskell-platform ppa by justin bogner doesn't seem to work any more
20:08:07 <Ziphilt> did i do something wrong or is that known?
20:08:20 <glguy> Saizan: This is what I mean $ rpm -ql ghc-ghc
20:08:30 <glguy> /usr/lib64/ghc-6.12.1/ghc-6.12.1/libHSghc-6.12.1-ghc6.12.1.so
20:09:08 <monochrom> the "stop! just get haskell platform" warning is for windows and mac only.
20:09:36 <Ziphilt> oh that would have been useful to add there
20:09:47 <Ziphilt> in that case, i'll grab the latest
20:09:58 <glguy> for linux you should get ghc through your package manager
20:10:10 <nanothief> I'm getting a Coverage Condition fails error with the following code: class SomeClass a b c d e | a -> b c d e; instance SomeClass Int d c d e; but I don't understand what it means even after reading about it in the ghc docs. Can anyone explain what is wrong with the code?
20:10:32 <Ziphilt> nevermind about the ppa, it seems that ppa has only lucid (not maverick)
20:10:44 <Ziphilt> but should i be using that?
20:11:47 <monochrom> you can apt-get ghc and stuff but there are surprises waiting for you. if you know them ahead you'll survive. see http://www.vex.net/~trebla/haskell/sicp.xhtml
20:12:14 <Ziphilt> thanks for the link
20:12:19 <Saizan> don't go with ghc 7 yet though, many packages won't build with it yet
20:12:45 * kfr started out with ghc 7 when he started learning Haskell
20:12:48 <Eduard_Munteanu> Bugs? Or is that intended?
20:12:59 <Ziphilt> i was not going to, but thanks for the warning
20:13:08 <kfr> Eduard_Munteanu: Just backward incompatibility
20:13:10 <Eduard_Munteanu> Because latest spec changes aren't so drastic.
20:13:15 * stepcut started with GHC 5.04 when he started learning Haskell :p
20:13:18 <gwern> Eduard_Munteanu: GHC 7 is the compiler of the future! not for the packages of the past
20:13:49 <Saizan> Eduard_Munteanu: mostly libs
20:13:51 <monochrom> most cases of incompatibility are easily fixable
20:14:36 <Eduard_Munteanu> Hm, did non-standard extensions change or something?
20:14:46 <Eduard_Munteanu> Erm, bad wording.
20:15:03 <Eduard_Munteanu> I'm curious what I should expect.
20:15:15 <gwern> no n+k patterns?
20:15:24 <kfr> gwern hahaha.
20:15:30 <Eduard_Munteanu> I thought most stuff didn't use that anyway.
20:15:36 <monochrom> some change in subtle type things (mono let binding, impredicative polymorphism). some change in base.
20:15:36 <kfr> Eduard_Munteanu yeah
20:16:18 <Eduard_Munteanu> Oh so let bindings are monomorphic by default now? Nice.
20:16:31 <Eduard_Munteanu> I read about that some time ago, and it made sense.
20:16:51 <monochrom> actually not sure which way it's changed. I just heard it's changed.
20:17:10 <djahandarie> -_-
20:17:17 <moshee> there he is~
20:17:22 <franz_> hi djahandarie~
20:17:48 <Saizan> Eduard_Munteanu: only if you use GADTs
20:17:54 <djahandarie> Now http://tryhaskell.org
20:18:03 <djahandarie> And bug me if anything is confusing ;)
20:18:13 <monochrom> nice, more food for breakfast
20:18:22 <Eduard_Munteanu> I see. Thanks, I'll keep an eye open.
20:37:49 <kfr> Hmm how do you avoid the redundancy of having to mention class constraints over and over again?
20:39:00 <Ziphilt> monochrom: after reading that, i think i'll stick to avoiding the distro package manager entirely
20:39:22 <kfr> type' Test = (Monad m, Functor m) => (a -> m b) -> m c
20:39:28 <kfr> function :: Test
20:39:31 <monochrom> heh
20:39:31 <kfr> function' :: Test
20:39:34 <kfr> Something like that
20:40:05 <kfr> Instead of type Test m = (a -> m b) -> m c
20:40:23 <kfr> And then function :: (Monad m, Functor m) => Test m
20:40:28 <kfr> And function' :: (Monad m, Functor m) => Test m
20:44:35 <kfr> Does Haskell provide no way to do that right now?
20:44:48 <kfr> Do you need TH for that right now?
20:44:54 <Eduard_Munteanu> Maybe CPP?
20:45:00 <kfr> Yeah CPP can do it for sure
20:45:04 <kfr> But it's so filthy
20:46:32 <stepcut> I think maybe you want this unimplemented proposal? http://repetae.net/recent/out/classalias.html
20:47:42 <Eduard_Munteanu> Interesting.
20:48:12 <dolio> What was wrong with type Test = (Monad m, Functor m) => (a -> m b) -> m c?
20:48:29 <kfr> dolio: Won't compile? :o
20:48:42 <dolio> Turn on rank-n types.
20:48:59 <kfr> :O it's already supported? Wtf
20:51:44 <kuffaar> Wow it really works
20:51:49 * kuffaar cheers
20:52:02 <kuffaar> dolio: I think somebody told me not to use this in libraries
20:52:08 <kuffaar> Why would that be?
20:52:17 <dolio> I don't know.
20:52:29 <Eduard_Munteanu> Maybe because rank-2/n types aren't standard?
20:52:44 <copumpkin> nothing wrong with that
20:52:54 <kuffaar> When you use a library module which relies on RankNTypes, do you need to activate it in the code that uses it, too?
20:52:57 <Eduard_Munteanu> Then again many useful stuff is written in terms of rank-2 types at least.
20:53:17 <kuffaar> Works with Rank2Types, too
20:53:21 <Eduard_Munteanu> *much
20:53:59 <Eduard_Munteanu> Well it kinda needs Rank2Types since you could use that type synonym everywhere in your type.
20:55:14 <kuffaar> Is this supported by any Haskell compiler other than ghc?
20:55:56 <Eduard_Munteanu> I guess so, it's quite necessary for stuff like ST. 
20:56:20 <kuffaar> ST = ?
20:56:23 <Eduard_Munteanu> There's a compatibility matrix for extensions somewhere, on the Haskell prime trac IIRC.
20:56:29 <Eduard_Munteanu> :t runST
20:56:29 <lambdabot> forall a. (forall s. ST s a) -> a
20:56:33 <Eduard_Munteanu> ST monad
20:56:55 <Eduard_Munteanu> Though I didn't know type synonyms could take class constraints. :/
20:58:06 <Eduard_Munteanu> Never tried either, so I guess that's fair :)
20:58:30 <dolio> That's, I think, shorthand for 'type Test = forall m a b c. (Monad m, Functor m) => (a -> m b) -> m c'
20:58:46 <dolio> And the right hand side is a valid type with rank-2 types.
20:59:28 <kuffaar> c'? Huh
20:59:41 <Eduard_Munteanu> kuffaar: there's a starting quote too
20:59:47 <kuffaar> Oh, fail.
20:59:55 <Ziphilt> to completely avoid distro haskell packages, i am getting a ghc 6.12.3 binary and haskell platform 2010.2.0.0 source. to confirm, does this sound sane?
21:00:05 <Eduard_Munteanu> Yeah, in case of Test -> Test it would really need a true rank-2.
21:01:13 <Eduard_Munteanu> Because it'd look like (forall m a b c. (Monad m, Functor m) => (a -> m b) -> m c) -> (forall m a b c. (Monad m, Functor m) => (a -> m b) -> m c)
21:01:17 <monochrom> yes Ziphilt. see also my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml for how to build haskell platform from source
21:01:23 <kuffaar> Ziphilt I have no idea, I actually started out with GHC 7 binaries
21:01:32 <Ziphilt> monochrom: indeed, i am reading that!
21:01:37 <Ziphilt> thanks though
21:01:38 <kuffaar> And built everything from scratch after that
21:02:31 <Ziphilt> well clearly you didn't use distro packages
21:03:42 <Eduard_Munteanu> In fact that's true even for 'type Test = a' I think.
21:05:17 <kuffaar> :t void
21:05:18 <lambdabot> Not in scope: `void'
21:05:24 <kuffaar> Why not :(
21:05:38 <kuffaar> @hoogle void
21:05:39 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
21:05:40 <Eduard_Munteanu> :t ()   -- this one?
21:05:41 <lambdabot> ()
21:05:53 <kuffaar> :t Control.Monad.void
21:05:55 <lambdabot> Not in scope: `Control.Monad.void'
21:06:12 <kuffaar> Prelude> :t Control.Monad.void
21:06:14 <kuffaar> Control.Monad.void :: Functor f => f a -> f ()
21:06:15 <kuffaar> lambdabot sucks
21:06:32 <Cale> Whaaat?
21:06:38 <kuffaar> What?
21:06:40 <kuffaar> Eduard_Munteanu: No
21:06:42 <copumpkin> it made it in, I guess
21:06:45 <Cale> Since when has that been in there?
21:06:52 <Cale> Must be a GHC 7 thing
21:06:52 <kuffaar> No idea, I use it all the time
21:06:56 <kuffaar> Since my first week in Haskell
21:07:17 <kuffaar> To discard of results in m () functions
21:07:24 <kuffaar> In do blocks
21:07:26 <dolio> I think it got added for the fanatics who want (>>) :: m () -> m a -> m a and so on.
21:08:09 <kuffaar> Yes
21:08:22 <Cale> kuffaar: um, to ignore results, you can just not bind results
21:08:28 <kuffaar> Or maybe that's different from what I do
21:08:37 <Cale> oh, you mean functions which take an m () parameter?
21:08:41 <kuffaar> Cale: I -Wall it
21:08:50 <Cale> oh, -Wall sucks :P
21:09:16 <kuffaar> I use void to explicitly discard of results to get rid of the warning
21:09:19 <Cale> It reports too many stupid things which don't matter at all.
21:09:25 <kuffaar> I take care of all of those
21:09:36 <kuffaar> I find it extremely useful
21:09:48 <Eduard_Munteanu> You can turn on only part of them.
21:09:54 <kuffaar> Boring
21:09:56 <Cale> Maybe it's a bit better in GHC 7 though, I don't really know.
21:09:57 <kuffaar> I want all of them
21:10:16 <Cale> I just found that it would tend to complain about some things which were not actually problems.
21:10:27 <stepcut> boing!
21:10:35 * shapr boings
21:10:38 <shapr> hiya stepcut!
21:11:23 <stepcut> shapr: are you still doing voip stuff?
21:11:51 <shapr> Yes, I'm currently employing doing tech support for digium.com, do you have some voip Haskell code?
21:12:14 <stepcut> shapr: just the Haskell AGI library
21:12:34 <shapr> ah right, I haven't tried that yet.
21:12:37 <kuffaar> I started learning Haskell because I wanted a statically typed language which provides sandboxed execution and good portability. So, hooray for high standards of compile time correctness! -Wall is part of that to me
21:12:47 <stepcut> shapr: haskell-agi + MACID is a nice way to go ;)
21:13:09 <shapr> At the moment, I'm installing bindings-libusb and hoping to send compiled programs to this msp430x6636
21:13:46 <stepcut> cool
21:13:49 <kuffaar> (in my terminology 'sandboxed' is the opposite of permitting raw memory manipulation without extensions)
21:14:14 <kuffaar> Hah, uC hackery with Haskell? :D
21:14:30 * stepcut heads to bed
21:14:37 <shapr> kuffaar: I hope so!
21:15:27 <kuffaar> I want to do some EE project at some point but I have little to no experience in that area
21:16:32 <kuffaar> http://www.sparkfun.com/products/9034 <- I thought about getting myself a pair of something like those and then using them to build a remotely controlled vehicle with a camera which can be controlled programmatically by an x86 box via USB
21:17:07 <shapr> kuffaar: I also don't have any experience doing EE, but it's always fun to try.
21:17:29 <kuffaar> And then I could code a server and a silly Flash thing for that which enables people to control it online with a live video stream
21:19:00 <kuffaar> Although it would probably be nicer to write a standalone application for that, instead of using browser crap
21:19:16 <kuffaar> With a proper protocol of its own
21:19:25 <kuffaar> And some GUI in Qt or whatever
21:19:50 <shapr> I like to start simple, just get anything at all working.
21:20:22 <kuffaar> Yeah, even writing a driver for a wireless thing like this is probably possibly months of work haha
21:20:52 <sm> evening shapr, all
21:21:52 <shapr> howdy sm, how's code?
21:22:35 <sm> not bad, not bad
21:23:30 <Saizan> djahandarie: hah, "a pointer is the intension of a variable" is quite cool
21:23:42 <djahandarie> Yeah!
21:24:19 <djahandarie> I don't have background in everything he was mentioning but I got the gist of it and it sounded very cool
21:24:31 <monochrom> neato
21:25:00 <monochrom> I guess it's also in line with C "a var for procedure is a pointer to procedure"
21:27:21 <sm> hrm, how come pandoc can write but not read texinfo
21:36:59 <Saizan> how do you write a ByteArray# to disk?
21:40:45 <tolkad> Are there any tools for analyzing the package dependencies of a package? I.E. what files they are used in and whether they are used
21:43:04 <Saizan> ghc has a warning for useless imports
21:43:26 <tolkad> yes but not useless package dependencies
21:43:29 <tg_> unused?
21:43:33 <tolkad> yes
21:43:46 <tg_> surely it's not so smart to tell me when my (or someone else's) code is useless!
21:44:14 <Saizan> @ask copumpkin is there a way to read/write a ByteArray# to disk?
21:44:14 <lambdabot> Consider it noted.
21:44:24 <copumpkin> Saizan: not that I know of
21:44:24 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
21:44:28 <copumpkin> not directly
21:45:51 <tolkad> Saizan: you could try to get the OS to run out of RAM and start caching stuff on disk
21:46:15 <tolkad> Saizan: if it's big and unused it's likely it will get at least partially written to disk
21:49:12 <Saizan> copumpkin: i guess i could loop extracting one byte or word at a time, i could use hPutBuf instead if there was a way to convert it to a Ptr
21:49:38 <copumpkin> a ByteArray# is passed as a pointer to a foreign call
21:49:39 <copumpkin> it's magic
21:51:37 <Saizan> btw, i have [de]serialized (1+) in eden :)
21:56:18 <copumpkin> :O
21:56:21 <copumpkin> how?
21:56:25 <copumpkin> I mean, how does it work?
21:56:34 <Ziphilt> if i installed a package with cabal, and now i want it to generate haddock documentation, do i simply do >cabal install --reinstall --enable-documentation <package>, or something else?
21:57:05 <monochrom> yes
21:57:30 <monochrom> but usually I already enable doc at first install. there is a line in ~/.cabal/config for that
21:59:12 <tolkad> hPutByteArray h array = hPutBuf h (case (byteArrayContents array) of (Addr primAddr) -> castStablePtrToPtr $ StablePTr (indexStablePtrOffAddr primAddr)) (sizeofByteArray array)
21:59:28 <tolkad> Saizan: something like that maybe?
21:59:44 <tolkad> the castStablePtrToPtr might be unsafe
22:00:24 <Ziphilt> okay, thanks
22:00:27 <tolkad> also I messed up the case on StablePtr
22:01:40 <tolkad> you'll need to import tons of GHC internals though. Data.Primitive.Types, System.IO, GHC.Stable, GHC.Prim, Data.Primitive.ByteArray, Data.Primitive.Addr
22:03:17 <tolkad> copumpkin: would that work?
22:04:24 <copumpkin> no
22:04:57 <tolkad> oh because I forgot to add a 0
22:05:03 <Saizan>   serialize#   :: a -> State# s -> (# State# s, ByteArray #) 
22:05:04 <Saizan>   deserialize# :: ByteArray# -> State# s -> (# State# s, a #)
22:05:10 <Saizan> you've those two primops
22:05:13 <kuffaar> tolkad why do you put parentheses around the case argument?
22:05:23 <tolkad> hPutByteArray h array = hPutBuf h (case (byteArrayContents array) of (Addr primAddr) -> castStablePtrToPtr $ StablePtr (indexStablePtrOffAddr primAddr 0)) (sizeofByteArray array)
22:05:27 <kuffaar> Or around the part to the left of the -> for that matter?
22:05:29 <Saizan> shame that the rts that supports them needs MPI though :)
22:05:41 <tolkad> kuffaar: I like parentheses. they look nice
22:05:54 <portnov> hello.
22:05:57 <kuffaar> tolkad it makes you look like you are trying to write C in Haskell, good man :[
22:06:23 <copumpkin> Saizan: that's crazy. Do you know how it works?
22:06:25 <portnov> code.haskell.org is down again? Are there any plans when it should be up?
22:06:42 <monochrom> will take a few days. there is a plan.
22:06:51 <tolkad> kuffaar: nah, if I wasn't writing that in an IRC text input I would have written it a lot more nicely. probably broken it up into a multiline "let â¦ in â¦" expression
22:08:28 <Saizan> copumpkin: it traverses the heap, copying the closures into the bytearray by looking at the info tables, using backreferences for nodes already serialized, so it handles thunks too
22:08:44 <copumpkin> oh, but the actual code must be present on both sides?
22:08:48 <Saizan> yep
22:08:52 <copumpkin> makes sense
22:09:27 <Saizan> and barfs on MVars and other things like that
22:10:13 <copumpkin> for MVars and FDs it should just call remotely :P
22:10:19 <tolkad> hmm, it would be cool to write haskell where every type was a unit type and anything uncertain at compile time was expressed as an existential with a class constraint
22:12:03 <Saizan> i wonder if it handles IORefs
22:12:10 <tolkad> I guess if ghc does enough optimization it wouldn't be any slower
22:13:53 <Saizan> internal error: MUT_VAR packing, not imlemented yet. <- meh
22:16:13 <tolkad> Are there any packages that do this?
22:17:10 <tolkad> it would be cool because as long as you never encounter _|_ your program would do exactly as it says it does
22:17:18 <tolkad> it's type says it does*
22:20:08 <Saizan> every type was a unit type?
22:21:45 <tolkad> every type had one constructor, no arguments
22:22:45 <tolkad> in other words: do all computation at the type level, then use existentials with class constraints for types not known at compile time (I.E. input)
22:24:50 <tolkad> you would think it would completely undermine optimization but I have faith in ghc
22:26:34 <tolkad> the skeptic's mind cannot comprehend functional programming. if you wish wish to understand haskell you must first have faith
22:27:34 <Ziphilt> i now have cabal set to generate documentation for every new package, but now it complains about not having things to link to on the other packages that do not have documentation created. is there a way to make cabal go over the entire library collection and redo haddock to fix this?
22:27:55 <mzero> not easily
22:28:08 <mzero> there is no built in haddock or cabal command
22:28:30 <Ziphilt> what does cabal haddock do, by the way?
22:28:38 <Ziphilt> the command, i mean
22:28:51 <mzero> calls haddock with exactly the right command line flags!  :-)
22:29:01 <mzero> which is, alas, hard to do by hand
22:29:20 <Ziphilt> does it take a package name?
22:29:34 <Ziphilt> cabal haddock --help does not say enough
22:29:37 <kuffaar> Ziphilt I guess it would read all that from the *.cabal file?
22:30:07 <Saizan> Ziphilt: cabal haddock works only inside an unpacked cabal package
22:30:23 <Ziphilt> that make it clearer, okay
22:30:37 <Ziphilt> *makes
22:32:44 <mzero> "cabal haddock" calls haddock with a zillion command line args to set up the haddock environment of reading interface and haddock files from existing packages, and to pass enough flags so that haddock can invoke ghc with the same package environment that it is used to compile in
22:33:26 <mzero> In one trace I have haddock is called with 97 command line args --- essentially you're never going to be able to do that by hand  :-(
22:36:15 <Ziphilt> wow
22:37:24 <tolkad> couldn't you just configure it to link to hackage for packages you don't have local documentation for?
22:38:14 <Ziphilt> that sounds sane and possible, but i certainly am not familiar enough with these tools to do that
22:38:16 <mzero> nope - haddock needs to see the .haddock files it writes when generating doc so it knows where stuff is when it generates links ---- I suppose it *could* read those from the network....
22:38:27 <mzero> anyhow, it has no such facility for now
22:38:28 <Ziphilt> okay nevermind
22:39:27 <gienah> with gentoo haskell pkgs you could just add the doc use flag and emerge -auvDN world to build the stuff with haddock, then haskell-updater
22:39:55 <tolkad> mzero: that's terrible. it means cross package links are only really feasible for packages on hackage
22:40:17 <mzero> ? no - their feasible for cross all the packages on your machine
22:40:28 <tolkad> mzero: which is a silly thing to do
22:40:30 <gienah> I have cross pkg links on my gentoo box with local haddock docs
22:40:34 <mzero> GHC, for example, ships with built haddock, including .haddock files, for all the libs it contains
22:41:14 <mzero> right - I have a complete haddock index on my machine of all the libs I can use
22:41:29 <mzero> tolkad: ? why is that silly?
22:41:41 <gienah> if you can figure out how to build the pkgs with haddock, then you can write a script to generate the docs with the cross pkg links
22:41:48 <gienah> the script may need to create some symlinks
22:42:35 <Saizan> the fun thing is that you can use a locally generated .haddock and still link to the hackage docs :)
22:43:07 <Saizan> helps if you're going to put the documentation on a website for your project and don't want to also put the haddock for base and all your deps there
22:43:14 <tolkad> mzero: well why regenerate local docs for all packages you own when you could just link to the hackage version? if you link to local copies then your documentation has to be regenerated on every machine
22:44:08 <tolkad> and what if you want to put your documentation online? you would probably want to link to the hackage version of docs when you can
22:44:22 <gienah> some systems like fedora and solaris will regenerate the haddock index for you when the pkgs are installed
22:44:55 <gienah> otherwise, you need to run the script you wrote to regenerate the index after installing each pkg
22:45:02 <mzero> well..... the libs I install with GHC and/or Haskell Package *come* with docs gen'd already --- and when I cabal install any new package, the docs get built as a matter of course and my top index file gets rebuilt..... it really is no fuss
22:45:19 <mzero> and I'd rather read them locally - far faster than reading them off Hackage
22:45:36 <tolkad> that's what your browser cache is for
22:45:36 <mzero> as for a copy on every machine... we're not talking any significant amount of disk space here
22:46:06 <mzero> you time it and tell me how that works for ya
22:46:21 <monochrom> (if you plan to read docs from hackage, you don't need the help of "cabal haddock" to begin with)
22:46:28 <gienah> the hackage docs are incomplete anyway, any build error like a missing C lib or missing dependency and hackage does not build the docs
22:46:36 <tolkad> mzero: if you keybind "work offline" it shouldn't be any slower than accessing a local copy
22:46:52 <mzero> try it
22:47:02 <mzero> I'll stick to my local files, thank you
22:47:03 <monochrom> (this is a silly "discussion")
22:47:11 <mzero> agreed
22:47:27 <tolkad> ok, I enabled "work offline" it really does instantly load. if you use "work offline" it IS accessing local copies
22:49:55 <tolkad> huh, that's strange. I tried to install hlint and it's depending on deprecated stuff.
23:05:28 <aleator> Navigating up and down in the same long, wrapped line:
23:05:28 <aleator> gk
23:05:45 <aleator> Oops. wrong terminal
23:21:35 <spvensko_> i'm currently reading LYaH and just got to the portion discussing partial functions/curried functions, is this the point where my brain is supposed to hurt?
23:22:22 <shachaf> spvensko_: Your brain doesn't have any pain receptors.
23:22:43 <spvensko_> is this the point where my brain has phantom pains?
23:23:35 <shachaf> spvensko_: If you're not used to the idea, possibly. What's confusing in particular?
23:24:17 <spvensko_> i am currently stuggling with the type declaration idea
23:24:21 <Ferdirand> well, there is plenty of stuff that will make your brain hurt long after you've become accustomed to partial application
23:25:15 <spvensko_> the initial a -> a -> a and a -> a examples weren't too bad, but now i am looking at the code for zipWith` in LYaH and the (a -> b -> c) -> [a] -> [b] -> [c] and feeling a bit confused
23:28:03 <spvensko_> i'm going to sort out my confusion and make sure i get what's going on but i just wanted to make sure this was a suitable point to get confused
23:38:16 <joe6> is runQ == $(..) ?
23:38:25 <joe6> > runQ
23:38:27 <lambdabot>   Not in scope: `runQ'
23:38:31 <joe6> > t runQ
23:38:32 <lambdabot>   Not in scope: `runQ'
23:38:39 <joe6> > :t runQ
23:38:41 <lambdabot>   <no location info>: parse error on input `:'
23:39:26 <pastorn> joe6: you doin template haskell?
23:39:58 <joe6> pastorn: hello, trying to understand how I can use macros (template haskell) to make the code shorter.
23:40:07 <accel> does manatee have an built in editor?
23:40:23 <joe6> i have some code that dreixl put together that I am trying to understand.
23:40:46 <joe6> pastorn: have to get there at some point?
23:40:51 <pastorn> joe6: heh, welcome to haskell, where doing advanced mental masturbation is percieved as more important than having a working program
23:41:27 <duckinator> pastorn has summed up all conversation in this channel rather well ;D
23:42:06 <joe6> pastorn: There are 2 reasons I am doing this: (1) understand what is going on behind the screens, and, (2) the next time I come across lisp macros, I am not kicking myself for not using lisp.
23:42:17 <pastorn> 1) write code. 2) if canUnderstand code then makeMoreDifficult code >> goto 1 else done.
23:42:32 <kuffaar> pastorn: You just said what I think about all the time when somebody mentions Haskell
23:42:57 <joe6> pastorn: if we are not pushing our borders, we might as well  be dead, right?
23:43:00 <duckinator> pastorn: for using goto, i will have to set you on fire. please climb in the fire-proof box so we do not start a forest fire while torching your soul.
23:43:13 <joe6> atleast, in something that I consider my bread-winner.
23:43:49 <pastorn> duckinator: there's basic in haskell
23:43:53 <gienah> we have callcc in preference to just mere goto :-)
23:44:10 <pastorn> you can do gotos by messing with rec-do and MonadCont
23:44:16 <joe6> pastorn: it is not makeMoreDifficult code, but to not be in the same place where I was yesterday.
23:44:26 <duckinator> pastorn: as in, a BASIC-dialect implemented in haskell?...
23:44:29 <joe6> or, self-improvement?
23:44:29 <kuffaar> I started learning Haskell because I wanted a statically typed language which provides sandboxed execution (and good portability) to ensure high compile time correctness and stability.
23:45:16 <djahandarie> But the type system is inconsistent!
23:45:17 <joe6> pastorn: anyway, you would not have spent so much time helping me out, if you did not care..
23:45:24 <duckinator> kuffaar: I started learning Haskell because I was bored and like learning new languages. Then I decided I actually liked it ;P
23:45:58 <duckinator> hm. yes. i should stop telling people in random channels that i'm leaving and actually leave.
23:46:08 <kuffaar> The languages out of the top 20 which primarily provide static typing with sandboxed execution: Java, C#, Haskell?
23:46:09 * duckinator puts his computer into standby and lets everyone talk to his bouncer. night o/
23:46:45 <kuffaar> Java: Oracle JVM too memory hungry, can't really use it on these crappy servers I code services for, good portability though
23:47:45 <kuffaar> C#: I prefer this language over Java, memory usage in mono and the Microsoft VM is considerably lower, portability... well... you pretty much have to avoid most .NET stuff for that. (no Winforms, WPF, etc)
23:48:14 <kuffaar> So that just left Haskell :[
23:50:02 <Saizan> if haskell is in the top 20 it really failed avoiding success.
23:50:09 <kuffaar> It's on rank #20
23:50:11 <kuffaar> On langpop.com
23:50:22 <kuffaar> Static typing with sandboxed execution appears to be a rare combination hmm
23:50:56 <kuffaar> The usual combination is static typing with raw memory manipulation or dynamic typing with sandboxing
23:51:57 <Saizan> even above Erlang, i would have never guessed that
23:52:49 <pikhq> Saizan: It's avoiding success at avoiding success.
23:53:00 <kuffaar> Haha
23:53:22 <kuffaar> Secretly most Haskellers want the language to kick Java off its throne
23:54:08 <CrazyMug> For some reason I don't.
23:54:27 <CrazyMug> Like I enjoy having oBsCuRe PoWeRs.
23:54:52 <kuffaar> I see, so you will just go for whatever is not popular
23:55:10 <kuffaar> Why don't you code stuff in Forth?
23:55:30 <CrazyMug> Ha, well Delphi is not popular.  It is obscure, but it does not hold much power.
23:55:46 <slom> kuffaar: I dont want it to, I couldn't care less about java :)
23:55:51 <kuffaar> I wonder what kind of developments there will be within the next decades to come, programming language wise
23:55:56 <Saizan> lots of users tend to make innovation slower, so the language gets less interesting over time
23:56:19 <kuffaar> Saizan that is actually true
23:56:20 <Lycurgus> haskell has that problem?
23:56:21 <CrazyMug> Saizan: I can see how that happened with perl.
23:56:36 <Saizan> also, the community might start accumulating too much noise :)
23:56:41 <slom> kuffaar: but if it actually happens I can still switch to agda or epigram 
23:57:11 <kuffaar> Saizan: What was the original rationale behind the whole "avoid success at all costs" slogan?
23:57:25 <kuffaar> Or was he just kidding?
23:57:34 <kuffaar> Random line without much thought?
23:57:36 <Lycurgus> perhaps something above and below the lang level can quell the babel/moot it
23:58:28 <Saizan> i don't rememeber the context tbh, though it might have been about remaining a good place to do research
23:59:25 <Saizan> or maybe joking on the fact that many haskell concepts are/were perceived as highly obscure :)
23:59:34 <CrazyMug> I do not know Python, and I may be completely wrong about this, but I think that the new version of Python breaks old code, and yet it is popular.
23:59:38 <Lycurgus> haskell = java for academics 
