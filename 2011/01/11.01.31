00:00:17 <nejucomo> No, it's a class.  Damn.
00:00:49 <nejucomo> What type is a state transformation that results in an error computation for an arbitrary type t?
00:01:19 <Cale> State s (Error e t)?
00:03:07 <nejucomo> Hrm.  Error is a class also.
00:54:57 <ski> nejucomo : huh ? `MonadError' is the class
00:57:28 <nejucomo> Yeah, I figured that out after some boggling.  (It's way past my bedtime, which tends to be when I write haskell.  ;-)
00:58:09 <nejucomo> Now I'm looking for something along the lines of :: (m t) -> (m (m' t)) -if that makes sense.
00:58:15 <nejucomo> Sort of a swapping lift...
00:58:47 <c_wraith> uh.  fmap will do that.
00:59:00 <nejucomo> Oh yeah.
00:59:00 <c_wraith> when combined with a function t -> m' t
01:03:45 <shapr> I swear, I need Fermat's Last Margin just to markup log output.
01:04:25 <adu> lol
01:04:56 <geheimdienst> what margin is that? it can't contain anything but troll remarks?
01:05:41 * ski suspects nejucomo maybe wanted something like `class (Monad m,MonadTrans t) => MonadT m t | t -> m where toT :: Monad n => m a -> t n a; fromT :: (forall n. Monad n => t n a) -> m a'
01:06:18 <shapr> geheimdienst: Nah, it's a margin of infinite size, aka a way to annotate digital documents in general.
01:06:58 <geheimdienst> i see :)
01:07:35 <shapr> geheimdienst: http://www.scannedinavian.com/~shae/blog/2004-12-01.html
01:07:38 * nejucomo wishes ghci had a hoogle-like search.
01:08:05 <shapr> nejucomo: It can be integrated, have you seen Ghci On Acid where lambdabot commands are available from the ghci prompt?
01:08:20 <silver> @hoogle (m t) -> (m (m' t))
01:08:21 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
01:08:21 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
01:08:21 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
01:10:34 <nejucomo> shapr: Does Ghci On Acid use networking for the search?  I want just a local type-based or name-based search.
01:11:33 <shapr> nejucomo: It's local, using your local Hoogle cache, iirc
01:11:52 <nejucomo> Sweetness!
01:15:34 <taotree> What is the $= operator?
01:17:54 <ion> What defines it?
01:18:05 <taotree> I don't know. I see it in OpenGL examples.
01:18:09 <taotree> setting callbacks
01:18:22 <taotree> eg.   idleCallback $= Just (idle angle delta)
01:18:53 <taotree> hoogle/hayoo don't seem to work for special chars like that
01:20:04 <ion> Hoogle works for such operators, but it doesn‚Äôt seem to know about the module.
01:20:15 <ion> You‚Äôll need to look at the documentation.
01:22:50 <quicksilver> taotree: it's a kind of 'set' operation for openGL state
01:23:00 <taotree> ok
01:23:04 <quicksilver> you might read that as "setIdleCallback (idle angle delta)"
01:23:11 <taotree> ok
01:24:58 <Wooga> how function swapping arugment of other function is called?
01:25:05 <Wooga> arguments*
01:25:14 <Wooga> implimented as f x y = f y x
01:25:56 <Wooga> ah, flip
01:26:26 <quicksilver> @hoogle (a -> b -> c) -> (b -> a -> c)
01:26:27 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
01:26:27 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
01:26:27 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
01:26:32 <ski> @src flip
01:26:32 <lambdabot> flip f x y = f y x
01:26:34 <quicksilver> Wooga: ^^ hoogle could have told you ;)
01:26:34 <Axman6> @hoogle (a -> b -> a) -> b -> a -> c
01:26:35 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
01:26:36 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
01:26:36 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
01:26:45 <Axman6> weak
01:27:12 <Wooga> wow
01:39:09 <joe6> @hoogle (a -> b -> c -> d) -> a -> b -> [c] -> [d]
01:39:10 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
01:39:10 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
01:39:11 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
02:19:20 <joe6> haskell programs take a lot of brain cycles initially. Does that get lesser?
02:20:10 <Adamant> yes.
02:20:44 <Adamant> however, the more "powerful" the language, the more time you sit and think before writing
02:21:18 <Adamant> Haskell is pretty powerful so expect a fair amount of gears turning in your head
02:21:56 <joe6> i notice that i am not thinking of if's and then's or atleast recursion but more on how to structure the data or function definitions and how I can combine them together.
02:22:04 <Adamant> it's also unfamiliar to folks initially
02:22:11 <Adamant> which also doesn't help
02:22:13 <Adamant> yeah
02:22:20 <Adamant> you're on the right track
02:24:57 <edwardk> hrmm
02:26:21 <edwardk> class BoundedCategory f k | k -> f where id :: k (f a) (f a); (.) :: k (f b) (f c) -> k (f a) (f b) -> k (f a) (f b)
02:26:27 <edwardk> kinda awful
02:26:59 <shapr> joe6: The downside is that learning to write elegant Haskell programs ruins your enjoyment of most other languages. 
02:27:56 <edwardk> class BoundedCategory k where type Ob k :: * -> *; id :: k (Ob k a) (Ob k a); ... 
02:28:44 <edwardk> wondering if there is a nice way to bound those to a valid member of a GADT
02:32:13 <joe6> shapr: yes, it does. I tried lisp after seduced by the macros but just missed haskell so much, that I felt that I would rather learn TH and stick with Haskell than go with lisp.
02:33:32 <edwardk> hrmm, i can make a nice semigroupoid product at least
02:33:51 <edwardk> it fixes the problem with control.category not being able to provide product categories by eliminating the pesky id
02:34:58 <joe6> and once you get on the TH bandwagon, it is not that bad. Though, not as simple as lisp macros but still not that hard.
02:35:27 <joe6> shapr: do you have a link to your TH tutorial?
02:35:42 <mm_freak> does anything bad happen, when you install a package version, which is already installed, but has changed?  when i do local development, i often install a package without changing its version number
02:35:43 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
02:35:44 <joe6> shapr: i am reading everything I can lay my hands on concerning TH
02:37:06 <edwardk> since i can take semigroupoid products that means i can have indexed bind and indexed extend transformers
02:37:09 <mm_freak> edwardk: i don't think that i've reinvented monad-ran‚Ä¶  look at how MaybeT, EitherT and ChoiceT are implemented‚Ä¶  i only reinvented Codensity StateT and Codensity ReaderT =)
02:37:15 <edwardk> but not indexed monad transformers
02:37:31 <edwardk> mm_freak: i noticed they were all abortable after that comment
02:38:04 <mm_freak> edwardk: not only that‚Ä¶  MaybeT has two continuations instead of one Maybe continuation
02:38:20 <mm_freak> EitherT, too and ChoiceT is a CPS left fold
02:38:28 <edwardk> *nods*
02:38:53 <edwardk> monad-ran went out of its way to build one single cps'ing, EitherT of MaybeT in your model does multiple cps's
02:38:53 <mm_freak> edwardk: there is also an "abort by second continuation", which is the HasExceptions class =)
02:39:02 <edwardk> yeah
02:39:31 <mbuf> Why do I get this error? http://hpaste.org/43459/ambiguous_type_variable 
02:40:37 <mm_freak> edwardk: although i'm thinking, maybe i can simplify ChoiceT‚Ä¶  it's so complicated, even i have to scratch my head, when i need to implement something new for it
02:41:08 <edwardk> i avoided any cpsing of recursive monads because the result was a rather messy
02:41:26 <edwardk> plus i could never get a benchmark win out of it
02:42:01 <mm_freak> well, ChoiceT is twice as fast as [] in my benchmarks, but i'm not sure this is because of the CPS
02:47:00 <edwardk> probably due to the fact that it doesn't materialize constructors for everything since you tend to only use stuff once. its tricky benchmarking cps'd code coz you can pessimize it as much as you want by recomputing values
02:53:02 <shapr> joe6: My TH tutorial has not been current for several years. Have you tried dissecting existing TH code?
02:57:54 <joe6> shapr: http://web.archive.org/web/20080822110747/haskell.org/bz/th3.htm was the best. The rest was what I learnt from Saizan and this IRC
02:59:25 <taotree> Is there some trick to detecting mouse wheel events in OpenGL?
02:59:45 <quicksilver> well, openGL doesn't know anything about mice ;)
02:59:55 <quicksilver> you want a GUI/event library to do that.
03:00:09 <quicksilver> GLUT might possibly pick up mouse wheel events as button clicks but I don't think so.
03:00:24 <quicksilver> best to use GTK/WX/SDL to collect events
03:00:29 * edwardk &
03:00:46 <taotree> sorry, I mean GLUT
03:01:02 <taotree> hmm... then why does GLUT have a mousewheelevent callback?
03:01:16 <mm_freak> edwardk: i wonder why CPS increases performance anyway
03:01:18 <Entroacceptor> well... then use that?
03:01:33 <quicksilver> taotree: freeglut only, I suspect
03:01:58 <quicksilver> the problem with using freeglut is you have to make sure your users all have freeglut installed
03:03:11 <edwardk> mm_freak: actually its quite simple. cpsing removes the construction of explicit intermediate structures that you might try to reuse. so you wind up potentially constructing fewer things once the optimizer gets done, but the cost is that you may have to rerun the computation if you need it again
03:03:27 <edwardk> mm_freak: as long as the use of the cps'd value is affine, cps can help
03:03:47 <edwardk> but not always, because a continuation is a thunk too ;)
03:04:15 <edwardk> mm_freak: consider yoneda. it acts as a form of type-enforced fmap fusion
03:04:16 <mm_freak> edwardk: yes, but how does CPS optimize code, which doesn't even need data structures?  or is that wrong?
03:04:56 <edwardk> http://hackage.haskell.org/packages/archive/adjunctions/0.5.1/doc/html/Data-Functor-Yoneda.html
03:05:03 <edwardk> consider the type of YonedaT.
03:05:50 <edwardk> the Functor instance there, just adds more and more fmaps into the function, so that when runYonedaT is finally invoked, they all go at once.
03:06:06 <edwardk> this is a type level way to cause the fmap f . fmap g = fmap (f . g) law to kick in.
03:06:09 <mm_freak> let me understand this type first‚Ä¶  it's the same as Codensity, but the continuation is pure?
03:06:32 <edwardk> codensity accumulates (>>=)'s yoneda accumulates fmaps.
03:06:38 <mm_freak> i see
03:07:09 <mm_freak> can you say that ContT accumulates (>>=), too?
03:07:12 <edwardk> the only way it can give you back an f b for any choice of b is to use the function you supply it on some supply of a's.
03:07:16 <mm_freak> or is ContT too general?
03:07:37 <edwardk> you can say that Codensity accumulates (>>=). Cont/ContT can cheat because of the continuation capture
03:07:58 <edwardk> though you can view Cont/ContT as codensity of the constant functor, so in that case, yes
03:08:08 <Beast> hey guys
03:08:11 <edwardk> basically ContT right associates all the binds
03:08:11 <mm_freak> i see
03:08:15 <taotree> can anyone suggest guidance on how I might find out how to get mouse events using WX on an opengl window?
03:08:27 <edwardk> this can help, if left associated binds are expensive
03:08:38 <Beast> x() {x | x&}; x
03:08:55 <Beast> haskell sucks dick
03:08:58 <Beast> java dick
03:09:20 --- mode: ChanServ set +o edwardk
03:09:53 <Beast> a
03:09:53 <Beast> s
03:09:53 <Beast> d
03:09:56 <Beast> f
03:09:57 <Beast> g
03:09:58 <Beast> h
03:09:58 <Beast> j
03:09:59 --- mode: ChanServ set +o shapr
03:09:59 <Beast> k
03:10:01 <Beast> l
03:10:02 --- kick: Beast was kicked by shapr (Kicked by shapr)
03:10:05 <finnomenon> go shapr 
03:10:07 --- mode: edwardk set +grip
03:10:26 <shapr> :-)
03:10:48 --- mode: edwardk set -grip
03:10:51 <edwardk> woops =)
03:10:59 <shapr> edwardk: What's +grip?
03:11:14 <edwardk> its an accident caused by getting the args to the ban in the wrong order =)
03:11:20 <shapr> aha
03:11:28 <edwardk> a bit rusty
03:11:35 <mm_freak> shapr: positive graph reduction in parallel
03:12:13 <mm_freak> edwardk: btw, every modern client has a kickban command ;)
03:12:35 <edwardk> mm_freak: fair nuff. =) i'm used to having to type the modeline by hand ;)
03:13:38 <mm_freak> well, that increases response time considerably =)
03:14:15 <edwardk> mm_freak: yeah. apparently adium fixed it. it used to just ban by nick which was useless
03:14:49 <mm_freak> dunno adium
03:16:29 <edwardk> anyways, back to the topic at hand so i can sleep
03:16:58 <edwardk> the yoneda lemma acts as a sort of type-enforced application of fmap fusion, codensity provides the same thing for (>>=) which can change asymptotics
03:17:26 <edwardk> because especially in the case of tree-like things, the 'fringe' of the tree keeps getting farther out
03:17:39 <mm_freak> ah, that makes sense
03:17:45 <edwardk> so fusing the traversals into one traversal avoids retraversing the dead structure in the middle of the tree
03:18:21 <edwardk> but the constants can be affected positively because you aren't building up all the 'dead wood' in the center of the tree.
03:18:35 <edwardk> this is good and bad, because if you go to re-examine the tree, you need to rebuild it
03:18:42 <edwardk> so its great for single-shot computations
03:18:47 <edwardk> which is most of what you do in a monad
03:19:00 <mm_freak> yeah, indeed
03:19:21 <mm_freak> one last question
03:19:21 <edwardk> but be warned. if you need the result of a yoneda'd computation, at an interim state to do something non-monadic to it. its best to lower it, then relift the result.
03:19:36 <edwardk> otherwise you'll be starting the computation over from scratch
03:19:38 <edwardk> shoot
03:20:11 <edwardk> (sadly my Ord instance can't do this because of the borked Functor/Monad relationship)
03:20:14 <taotree> FYI: figured out the mouse wheel thing. You just use the keyboardMouseCallback... it handles wheel also and it works.
03:20:17 <mm_freak> what if you use ContT instead of Codensity and you actually use CPS effects like 'abort'‚Ä¶  will that destroy the asympotic advantage?
03:20:54 <edwardk> no. ContT is just a Codensity of a functor that doesn't use the quantified portion
03:21:11 <mm_freak> ok, very interesting
03:21:37 <edwardk> ContT r m ~ Codensity (Const (m r))
03:22:07 <mm_freak> i should learn some CT, but it's so damn dry =/
03:22:14 <edwardk> forall s. (a -> Const (m r) s) -> Const (m r) ~    (a -> m r) -> m r
03:22:23 <edwardk> meh, this is just type signatures =)
03:22:38 <edwardk> i didn't spot the relationship through category theory initially
03:22:44 <mm_freak> yes, but i think knowing CT really helps understanding these things =)
03:23:13 <edwardk> in my case its mostly just obsessively coding up variations on a theme ;)
03:24:01 <mm_freak> well, but you can say:  "ah, this is a right kan extension"
03:24:11 <mm_freak> and you immediately have a theoretical model for what you just coded
03:24:27 <edwardk> *now* i do =)
03:24:43 <mm_freak> hehe ok
03:25:56 <mm_freak> you may sleep now =P
03:26:09 <edwardk> good idea
03:26:31 <edwardk> i now have coproduct and product semigroupoids, but only product categories
03:26:35 <edwardk> and hackishly at that
03:26:52 <edwardk> all 3 take GADTs which doesn't surprise me
03:27:07 <edwardk> but its kinda annoying that i can't make a good coproduct category =/
03:27:21 <mm_freak> good night and thanks‚Ä¶  it's amazing how much you can learn about your own code
03:27:24 <edwardk> at least not without infecting it with indentity arrows for all of Hask as well
03:38:05 <Eelis> would it be fair to say that there is no established way to handle OOM conditions in Haskell programs?
03:39:11 <Botje> 'die violently' is not an option?
03:39:23 <Eelis> no, that doesn't count as "handle" :P
03:39:41 <Botje> that's what most languages do :P
03:39:49 <Heffalump> what languages/execution environments do provide a good way to handle it?
03:39:55 <quicksilver> what about "reduce the machine to an unusable morass of swapping until the OOM killer kicks in and kills the wrong process"?
03:40:14 <Eelis> i'm used to C++, where OOM contingencies are taken seriously and can be dealt with if one takes care
03:41:06 <ricree> a while back I ran across a table of 5 or 6 common monads with a brief description and a short summary of their behavior with the monad functions.  I'm trying to track it down again, but not having any luck with google.  Does this ring a bell, and can someone point me in the right direction?
03:41:19 <Heffalump> Eelis: how does one actually do that?
03:41:20 <silver> Eelis, how?
03:41:36 <Eelis> by realizing that allocation can fail and writing code to respond to that failure
03:41:50 <Twey> Code that uses no memory?
03:41:52 <silver> on linux?
03:42:08 <Eelis> Twey: only stack memory, for instance
03:42:10 <Heffalump> Twey: in C++ allocation is explicit, so that's perfectly possible
03:42:14 <quicksilver> Eelis: but do real OSes actually return failure codes to allocations? Or do they just allocated unlimited amounts of swap and then the kernel invokes the OOM killer?
03:42:25 <Heffalump> Eelis: how about dealing with stack overflows?
03:42:30 <Eelis> quicksilver: sure, you can set memory limits on processes with setrlimit
03:42:35 * quicksilver nods
03:42:42 <quicksilver> yes, with an rlimit in place I can see it working.
03:42:44 <gienah> I had to write a C++ program on novell netware where there was no virtual memory, yes it can be done in C++
03:42:51 <sipa> and you can allocatie memory which will not be swapped
03:42:57 <quicksilver> gienah: it's *easy* when there's no virtual memory.
03:43:02 <Eelis> Heffalump: that's really a separate problem. i'm talking about simple cases where you run out of heap
03:43:04 <quicksilver> it was no problem on 68k macintoshes either :)
03:43:07 <Twey> Isn't there a signal that tells you when the system is getting close to its memory limit?
03:43:39 <quicksilver> Eelis: the GHC team have suggested they will eventualy implement a HeapOverflow async exception, but they have not done so yet
03:43:49 <Eelis> quicksilver: ah, interesting
03:43:58 <quicksilver> Eelis: I think you'd also need to tweak the GC, otherwise you get GC thrashing when you get close to the limit
03:44:03 <quicksilver> which is a bit counter-productive.
03:44:24 <Eelis> yes, i imagine this would all get very tricky in Haskell, where allocation is so implicit and pervasive
03:45:06 <quicksilver> well, the async exception is likely - although far from guaranteed - to free up a bunch of memory
03:45:22 <quicksilver> because hopefully terminating that big painful computation kills the last reference to most of your garbage.
03:49:12 <Wooga> am i re-inveinting the wheel with this foldl3 function: http://paste.pocoo.org/show/329867/ ?
03:50:02 <Wooga> (i have to split list into groups of 3-tuples)
03:50:07 <mm_freak> can't you write a 'withMemoryLimit' function in haskell using GHC libraries?
03:50:19 <mm_freak> say, 'withHeapLimit'
03:50:22 <mm_freak> or something like that
03:50:37 <Eelis> mm_freak: what would the type be?
03:50:51 <mm_freak> Eelis: withHeapLimit :: IO a -> IO a
03:51:04 <Eelis> i don't see how that would help
03:51:19 <edwardk> wooga: no standard foldl3 exists, the semantics of what to do with lists that are not even multiples of three are a bit awkward, etc.
03:51:29 <mm_freak> it could throw an exception instead of terminating the application
03:51:46 <mm_freak> at the point, where using too much memory has been attempted
03:52:06 <edwardk> wooga: that said, your arguments are in an odd order for a foldl
03:52:16 <Eelis> mm_freak: what GHC library in particular do you think could let one implement this function?
03:52:32 <edwardk> wooga: usually it'd be (b -> a -> a -> a -> b)  to emphasize that the zero is being placed on the left
03:52:33 <mm_freak> Eelis: some interface to the RTS‚Ä¶  it's a theoretical question
03:52:46 <Wooga> edwardk: thanks
03:52:57 <mm_freak> Eelis: a runtime equivalent to specifying the -M RTS option
03:53:20 <Eelis> mm_freak: well, if we're talking hypothetical stuff anyway: quicksilver was saying that GHC could throw an exception without any need for extra functions
03:54:09 <mm_freak> sure, but when all memory is exhaustet, it may be too late, so you would need to be able to set the heap limit at run-time
03:54:15 <mm_freak> exhaustet ‚Üí exhausted
03:54:18 <rribeiro> someone knows why planet haskell is down?
03:54:48 <mm_freak> that reminds me‚Ä¶  code.haskell.org is still down‚Ä¶  what's wrong?
03:57:37 <Palmik> Hmm, would it be appropriate to use state monad for set of functions which take a "state" and epxression but do not change the state?
03:58:11 <Botje> then you want the reader monad instead
03:58:21 <Palmik> Botje, thanks :)
03:58:38 <astroboy> If I modify something with an haskell-style copyright & license on the top, how should I make notice that I did something?
03:59:20 <astroboy> and maybe relicense it?
03:59:30 <Botje> something like 'parts of this file by astroboy, changes are under the same license as the original'
03:59:58 <Botje> you can only relicense it if the author gives you explicit permission to do so
04:00:22 <astroboy> ok so if the license is BSD-style?
04:00:32 <astroboy> yes it should be fine
04:01:20 <astroboy> thanks.
04:09:49 <jonkri> i have a function that takes an argument "string". i'm using a where statement to use string to create another string, xmlVersion. is there a way i can pattern match against xmlVersion in a guard of the functions? something like: parse string | xmlVersion == [...] = ...?
04:10:26 <ski> you could use a pattern guard ..
04:10:35 <ski> (or a view pattern)
04:10:54 <ski> or just a `case' in the body .. or matching in another definition inside the `where'
04:11:04 <dafis> jonkri: values defined in where clauses are in scope in the guards, so unless I misunderstand, you can
04:11:48 <ski> dafis : well, but `xmlVersion == [...]' will not *match* on `xmlVersion' .. it will only check equality
04:12:06 <ski> jonkri : but maybe an equality check would be enough for you ?
04:12:16 <dafis> ski: that's what pattern matching on Strings does anyway
04:12:36 <jonkri> ski: actually, no. i need to use "don't care" ('_') with xmlVersion
04:12:53 <ski> maybe you meant to say "that's what pattern matching on String *literals* does anyway" ?
04:13:22 <dafis> ski: right, forgot the 'literals'
04:13:41 <ski> > case "abcd" of x0:x1:xs -> (xs,x1,x0)  -- matching on a string
04:13:43 <lambdabot>   ("cd",'b','a')
04:14:08 <ski> jonkri : ok (i suspected so), so one of the alternatives i named above should work, i think
04:14:19 <ski> maybe you'd like to show the code in question ?
04:16:49 <jonkri> thanks :) it's only three lines of test code, i'm don't think that i will use the function later, was just curious
04:17:06 <ski> anyway, using a pattern guard would look something like
04:17:21 <ski>   parse string | [...] <- xmlVersion = ...
04:17:38 <jonkri> aha :)
04:17:44 <jonkri> was googling for that
04:17:50 <ski> (and you'd need to enable an extension .. something like `{-# LANGUAGE PatternGuards #-}')
04:18:25 <ski> (probably GHCi will tell you the name of the extension, if you haven't enabled it)
04:18:55 <ski> hm
04:19:37 <ski> if you just apply a function `f' to convert from `string' to `xmlVersion' (and don't use `string' anywhere else), then you could shorten that to
04:19:50 <ski>   parse (f -> [...]) = ...
04:20:13 <ski> (well, assuming you don't use `xmlVersion' otherwise either)
04:20:15 <dafis> which is a ViewPattern
04:20:19 <ski> yes
04:20:58 <ski> (if you do need any of `string' and `xmlVersion', you can say `string @ ' or `xmlVersion @ ', in the appropriate place(s))
04:27:54 <drbean>  
04:28:25 * ski
04:28:47 <Axman6> POWPOW PEW PEW BANG BOOM!!
04:29:06 <dafis> sshh
04:44:03 * hackagebot parsec3 1.0.0.2 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.2 (ChristianMaeder)
04:59:07 * hackagebot parsec3 1.0.0.3 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.3 (ChristianMaeder)
05:14:35 <pedro3005> could variables be considered as constant functions?
05:14:45 <ski> no
05:14:52 <pedro3005> damn
05:15:05 <sipa> either you see functions as values of types a -> a, and then every function has exactly one argument
05:15:06 <ski> `variables' is a syntactic concept. `functions' is a semantic concept
05:15:17 <sipa> and are non-function variables entirely differnt
05:15:44 <ski> if you write `length xs', then `length' and `xs' both are variables, the first standing for a function value, the second for a list value
05:16:07 <pedro3005> but can't you look at both being functions?
05:16:20 <sipa> you could, but it's less formally correct
05:16:24 <shachaf> pedro3005: You can define anything to be a function if you like.
05:16:25 <ski> functions are things which have types like `Something -> SomethingElse'
05:16:41 <shachaf> pedro3005: Values are thunks, which can behave a bit like zero-argument functions in other languages.
05:16:47 <ski> iow, functions are things which accepts argument(s) (at least one)
05:16:54 <shachaf> pedro3005: But a function is something of type a -> b.
05:17:00 <sipa> see every value as a function (though not the strict sense that haskell defines functions) taking an arbitrary (including 0) argument
05:17:16 <sipa> but then you have a problem answering the question "how many argument does id take"
05:17:37 <shachaf> sipa: ...This isn't helping.
05:17:37 <sipa> > id id x
05:17:39 <lambdabot>   x
05:17:45 <ski> sipa : well, you do anyway ..
05:18:51 <shachaf> Functions in Haskell take exactly one argument, always. Talking about functions that take 0 or >=2 arguments in any semi-formal sense is not correct.
05:19:12 <ski> pedro3005 : in any case, functions are just values, and variables can stand for function values just as they can stand for list values, or any other kind of values
05:19:19 <sipa> it is not correct, but it is probably how many beginners see it
05:20:00 <shachaf> sipa: Maybe, but talking in that mindset will only cause more confusion. It's like talking about "being trapped in a monad", or something.
05:20:11 <ski> sipa : it might be less confusing to say that every value could be thought of (*operationally*) as a *procedure*, taking zero arguments
05:20:34 <ski> sipa : that way, we don't end up confusing this implementation detail with the semantic (and syntactic) concept of `function'
05:20:42 <sipa> good point
05:20:58 <shachaf> Ah, yes.
05:21:19 <shachaf> But this is indeed an implementation detail. :-)
05:21:57 <ski> pedro3005 : are you sufficiently confused, yet ?
05:22:29 <pedro3005> ski, if we could consider variables as functions, it'd be pretty :p then we can truly say everything is a function!
05:22:38 <ski> no
05:22:42 <ski> everything is not a function
05:22:50 <ski> variables *can* refer to functions
05:22:54 <shachaf> pedro3005: Why would you want to say that?
05:22:54 <flamingspinach> do you mean... not everything is a function? :3
05:23:07 <shachaf> pedro3005: If everything is a function then the word "function" is useless.
05:23:13 <ski> (but variables do not *have*to* refer to functions)
05:23:16 <shachaf> pedro3005: Everything is a value, including functions.
05:23:26 <flamingspinach> then the word "value" is useless
05:23:38 <ski> pedro3005 : when you write the definition `square x = x *'
05:23:40 <ski> er
05:23:46 <sipa> it's useful to distinguigh from types, classes, instances and kinds
05:23:50 <shachaf> flamingspinach: Well, no, because pedro3005's statement was implicitly limited to values.
05:24:11 <flamingspinach> but since everything is a value, that would mean it wasn't limited at all, wouldn't it?
05:24:15 <ski> pedro3005 : .. `square x = x * x', think of this as giving the (unnamed) (function) *value* `\x -> x * x' the name `square'
05:24:16 <shachaf> flamingspinach: And so was mine. So my particular predicate was useless, but the set I defined wasn't. :-)
05:24:31 <ski> pedro3005 : iow `square = (\x -> x * x)'
05:24:49 <flamingspinach> as far as I can see, the set you defined was "everything"... but I don't know what I'm talking about, so I can see about as far as I can throw myself
05:24:51 <flamingspinach> :)
05:25:18 <shachaf> flamingspinach: According to my set theory book, "there is no universe".
05:25:39 * shachaf likes that theorem.
05:25:43 <sipa> pedro3005: the nice thing is not "everything is a function", but "functions can be used everywhere"
05:25:56 <shachaf> sipa: That's not true either.
05:26:10 <sipa> explain?
05:26:26 <shachaf> > (\x -> x) == True
05:26:27 <lambdabot>   Couldn't match expected type `t -> t'
05:26:27 <lambdabot>         against inferred type `GHC.Bo...
05:26:35 <shachaf> Functions can be used anywhere functions can be used. They're just another type of value.
05:26:46 <flamingspinach> shachaf: what kind of universe was that?
05:26:55 <shachaf> flamingspinach: "universe" being the set of everything.
05:27:09 <flamingspinach> OK, so in the sense of a universal set
05:27:14 <flamingspinach> sure, that's clear from russel's paradox
05:27:31 <flamingspinach> there might or might not be Grothendieck universes, though, iirc
05:29:32 <shachaf> flamingspinach: The point is that there's always an implied set that you're limiting when you say "the set of all X". :-)
05:29:38 <ski> (shachaf : in some set theories there is a universe set .. iirc, in NF and positive set theory at least)
05:30:24 <flamingspinach> shachaf: yup :) set comprehension is not arbitrary, is the point, because that leads to big problems
05:31:31 <shachaf> flamingspinach: So I was just restricting the same set pedro3005 was restricting.
05:31:45 * shachaf wonders why this "everything is a function" thing comes up so often.
05:31:56 <dolio> Is NF the one that uses stratified formulas instead?
05:32:19 <flamingspinach> shachaf: it comes up because of the lambda calculus and how pretty it is, I imagine
05:32:28 <flamingspinach> people wish everything were a function
05:32:54 <ski> shachaf : .. probably people think that since OOP often talks about "everything is an object", then FP ought to talk about how "everything is a function"
05:33:27 <flamingspinach> see this I guess? http://conal.net/blog/posts/everything-is-a-function-in-haskell/
05:33:44 <ski> dolio : yes
05:35:06 <Veinor> if everything is a function, what do they evaluate to?
05:35:58 <FauxFaux> Functions.
05:36:14 <Veinor> It's functions all the way down!
05:36:16 <pedro3005> turtles all the way down
05:36:21 <pedro3005> beat you to it!
05:36:46 <dolio> ski: Doesn't that automatically rule out a set of all sets?
05:37:17 <pedro3005> A set of everything doesn't make sense
05:37:28 <pedro3005> because that would imply there can't be a set with greater cardinality
05:37:56 <flamingspinach> you're assuming that power sets exist unconditionally
05:38:01 <flamingspinach> not all theories have to obey this
05:38:09 <hpc> or that P /= id
05:38:19 <hpc> (ie, that the power set cannot be the same as the set)
05:38:58 <flamingspinach> well, even more than that - assuming that P(X) \not\subset X
05:39:08 <dolio> Or does the set of all sets exist by a non-stratified axiom?
05:39:14 <flamingspinach> or I suppose I should say \not\in
05:40:28 <pedro3005> hpc, but... what about cantor's argument?
05:41:17 <pedro3005> there can't be a bijection A -> P(A)
05:41:34 <flamingspinach> cantor's argument assumes you can use the axiom of separability with arbitrary predicates
05:41:57 <pedro3005> true
05:41:58 <ski> dolio : hm, actually i see that it uses stratifi*able* formulae .. i suppose this is a bit similar to saying that the universal set is polymorphic over which stratification level it exists at
05:42:48 <pedro3005> but the proposition makes such intuitive sense...
05:43:08 <hpc> pedro3005: perhaps, if you use an intuitive system
05:43:20 * hpc imagines the most unintuitive system possible
05:43:50 <lpsmith> So in Control.Concurrent.MVar,   takeMVar is implemented with onException:  http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/Control-Concurrent-MVar.html#withMVar
05:43:55 <shachaf> hpc: I suspect that you can't, almost by definition.
05:44:20 <lpsmith> I'm curious why that doesn't use  `finally` and avoid repeating "putMVar m a"
05:44:31 <lpsmith> is there any semantic difference?
05:45:05 <ski> (dolio : i.e., in any particular argument, it must be possible to assign stratification levels to the all the sets)
05:45:21 <dolio> ski: I guess { x | true } is trivially stratifiable.
05:46:02 <dolio> But when you assign levels, it's { x^n | true }^(n+1).
05:46:10 <ski> aye
05:46:40 <dolio> Which would mean it doesn't contain itself.
05:46:44 * ski doesn't know too much about alternative set theories
05:47:01 <ski> dolio : the question whether it contains itself isn't wellformed
05:47:07 <dolio> Right.
05:48:00 <dolio> Well, the formula that asks whether it contains itself isn't usable with comprehension.
05:48:20 <dolio> That doesn't mean you can't ask it at all.
05:49:24 <ski> if you form the formula `x \in y', then you must be able to assign different levels to `x' and `y'
05:49:56 <dolio> Wikipedia's entry on NF only states that formulae used with comprehension must obey that rule.
05:50:16 <lpsmith> Or I suppose this is also relevant:  http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Control-Exception.html#v:mask
05:50:25 <ski> (in positive set theory, the formula in the comprehension is restricted to be a positive formula (so complement is not generally possible))
05:51:00 <ski> dolio : ok. i might be misunderstanding, then
05:51:03 <lpsmith> why does the idiom use (m `onException` release) >> release   instead of (m `finally` release) ?
05:51:26 <Twey> ‚Äòfinally m release‚Äô has less brackets
05:51:44 * Twey doesn't like it when people introduce brackets for no good reason >.>
05:52:00 <dafis> ((((()))))
05:52:10 <Twey> Argh!
05:52:19 <dafis> he he
05:52:22 <hpc> :t ((((()))))
05:52:23 <lambdabot> ()
05:52:25 <hpc> :D
05:52:26 <dolio> Actually, I'm thinking in two different parts.
05:52:36 <lpsmith> well,   using brackets around finally is fairly idiomatic
05:52:43 <dolio> The type theory has { x^n | phi(x^n) }^(n+1).
05:53:04 <dolio> The set theory just has { x | phi(x) } exists as long as phi(x) is stratifiable.
05:53:08 <ski> lpsmith : i don't really know. but it might be that that code predates `finally' ? .. maybe check dates and/or the definition of `finally' ?
05:53:22 <dolio> So a universal set exists, because 'true' is stratifiable. And it contains itself, I guess.
05:53:30 <lpsmith> ski, mask is new in GHC-7.0
05:53:37 <dafis> Twey: is "I think it'smore readable with some syntactically unnecessary parentheses" generally an acceptable reason for you?
05:54:06 <Twey> dafis: Sometimes.  Depends how I'm feeling.
05:54:10 <ski> (lpsmith : "that code" referring to the one using `onException')
05:54:14 <Twey> But it would have to be *horribly* unreadable without.
05:54:27 <dafis> oy
05:54:30 <shachaf> Twey: Are you in favor of infixl $?
05:54:51 <ski> dafis : only if it actually *is* more readable with those brackets ;)
05:55:13 <dafis> ski: that's always an idiosyncratic thing
05:55:29 * ski quite often writes extra brackets in function types, to make the curried higher-order nature more explicit
05:55:41 <ski> `map :: (a -> b) -> ([a] -> [b])', &c.
05:55:46 <shachaf> ski: And then you move the argument to the other side of the =, too?
05:55:52 <aleator> How bad idea is it to start using unicode symbols in haskell source?
05:55:56 <ski> shachaf : usually not :)
05:56:16 <ski> (shachaf : if i don't match on them, i might)
05:56:16 <shachaf> aleator: Depends on which symbols.
05:56:17 <dafis> aleator: depends on who you ask
05:56:56 <dolio> ski: Apparently NF sets and functions don't form a Cartesian closed category.
05:57:15 <ski> exponential fails ?
05:57:38 <aleator> Such as stuff with UnicodeSyntax extensions would be first stage and next would be all these funny math operators
05:59:11 <dafis> aleator: http://www.haskell.org/pipermail/haskell-cafe/2011-January/088439.html unicode symbols are not without problems
05:59:21 <Twey> ski: Types are different
05:59:25 <Twey> shachaf: Yes
05:59:28 <Twey> (isn't everybody?)
05:59:48 <dolio> ski: I think there isn't always a set of functions between two given sets.
06:00:08 <dolio> That is, the collection isn't always a set.
06:00:21 <dafis> dolio: in NF?
06:00:25 <dolio> Right.
06:00:28 <ski> shachaf : .. but then i think one should be able to write
06:00:32 <ski>   (ma >>= amb) `runState` s0 = amb a `runState` s1
06:00:35 <ski>     where
06:00:35 <ski>     (a,s1) = ma `runState` s0
06:01:09 <dolio> Their solution to a paradox about P(V) being in bijection with V is that there's no set of functions between V and P(V), I think.
06:01:22 <dolio> For instance.
06:01:31 <dolio> Where V is the universal set.
06:02:22 <dolio> If I skimmed the wiki page correctly.
06:04:04 <ski> (shachaf : i.e. i should be able to move rhs lambdas into lhs arguments, even if they're within a constructor, at the top-level (by using the projection))
06:12:27 <Veinor> Twey: wait, so P(V) is in bijection with V but there's no function between them?
06:13:53 <roconnor> the wiki page discusses Cantor's paradox in some detail
06:14:11 <Veinor> huh, interesting
06:15:12 <roconnor> it says that the cardinality of P_1(V), the one element subsets of V, is less than the cardinality of P(V)
06:15:45 <Veinor> ... ah, that makes sense!
06:15:53 <roconnor> but attempting to define the bijection x |-> {x} from V to P_1(V) doesn't work because this definition is unstratified
06:16:53 <Veinor> what is Infinity in this article's context?
06:19:17 <Veinor> oh, the axiom of.
06:54:19 <jonkri> is it possible to use an xml parsing library such as haskell xml toolbox for parsing streamed xml such as xmpp sessions?
07:07:27 <dino-> jonkri: I see Text.XML.HaXml.SAX, may help.
07:12:36 <hymnusAlae> Excuse me, Is it Okay to use (.) combine two function from different modules, like A.a.B.b?
07:12:49 <hymnusAlae> I intend to have a try in ghci, but i cannot find a good example.
07:13:33 <dino-> hymnusAlae: Sure, it's ok, even expected and encourged. Are you having a problem perhaps with whitespace: A.a . B.b
07:13:39 <Veinor> A.a . B.b
07:13:49 * hackagebot timeplot 0.2.16 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.16 (EugeneKirpichov)
07:14:20 <hymnusAlae> dino-, no, i have not find a good example to try in ghci. Would you like to suggest some functions?
07:16:53 <roconnor> what are good variable names for coalgebras?
07:17:03 <Veinor> cox, coy, coz
07:17:03 <jonkri> dino-: great :)
07:17:12 <roconnor> Veinor: too long
07:17:13 <sipa> coala, coalb, coalc
07:17:22 <roconnor> sipa: too even loner
07:17:24 <roconnor> *longer
07:17:37 <Veinor> turn them upside-down
07:17:39 <roconnor> greek letters are also acceptable
07:17:52 * roconnor uses an upside down x
07:17:57 <Veinor> except that doesn't work for x and z, and would require some kind of mirrored lambda for y
07:18:23 <aristid> ·∫ã
07:18:27 <hymnusAlae> dino-, Veinor, thank you. I add a pair of () to make sure. Thanks.
07:18:38 <aristid> :t let ·∫ã = 0 in ·∫ã
07:18:40 <lambdabot> <no location info>: not an expression: `let'
07:19:05 <dino-> jonkri: May be able to do this with HXT too, not sure.
07:19:50 <jonkri> dino-: will check it out. can i use that sax parser somehow with a handle instead of a file, you think?
07:21:41 <roconnor> what letter comes after eta?
07:21:47 <alej> zeta?
07:22:03 <sipa> theta
07:22:06 <alej> no thats after epsilon
07:22:10 <alej> (correcting myself
07:22:12 <dino-> jonkri: ym say Text.XML.HaXml.SAX.saxParse, taking a String for the content of the file? .. Perhaps readFile reading lazily
07:22:14 <sipa> zeta - eta - theta
07:22:25 <quicksilver> alpha beta gamma delta epsilon zeta eta theta
07:22:27 <quicksilver> IIRC
07:22:36 <alej> yeah
07:22:42 <dino-> :t readFile
07:22:43 <lambdabot> FilePath -> IO String
07:23:24 <sipa> iota kappa lambda mu nu ksi omicron pi rho sigma tau phi chi psi omega
07:23:26 <sipa> iirc
07:23:45 <sipa> tau upsilon phi
07:23:45 <jonkri> dino-: interesting read: http://www.haskell.org/pipermail/haskell/2010-May/022045.html
07:24:41 <roconnor> thanks
07:25:36 <yitz> Œ±Œ≤Œ≥Œ¥ŒµœõŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ
07:25:52 <hymnusAlae> dino-, I finally understand your words... I see... No () needed. thank you very much...
07:26:05 <yitz> > map fromEnum "Œ±Œ≤Œ≥Œ¥ŒµœõŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ"
07:26:07 <lambdabot>   [945,946,947,948,949,987,950,951,952,953,954,955,956,957,958,959,960,961,96...
07:26:15 <yitz> hmm
07:26:36 <yitz> > drop 10 $ map fromEnum "Œ±Œ≤Œ≥Œ¥ŒµœõŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ"
07:26:37 <lambdabot>   [954,955,956,957,958,959,960,961,963,964,965,966,967,968,969]
07:27:11 * roconnor didn't know 987 comes between 949 and 950
07:27:26 <yitz> > text $ map toEnum [945..969]
07:27:27 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:27:40 <yitz> @type text
07:27:41 <lambdabot> String -> Doc
07:28:02 <yitz> no way to get \bot to output unicode?
07:28:30 <roconnor> > text "unicode"
07:28:31 <lambdabot>   unicode
07:28:38 <opqdonut> ba da bum
07:28:44 <roconnor> thank you
07:29:40 <yitz> Well, pasted from ghci, it's "Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâ"
07:31:24 <aristid> > ['Œ±'..]
07:31:26 <lambdabot>   "\945\946\947\948\949\950\951\952\953\954\955\956\957\958\959\960\961\962\9...
07:31:51 <aristid> > length ['Œ±'..'œâ']
07:31:53 <lambdabot>   25
07:32:11 <aristid> huh, i thought the greek alphabet has only 24 letters
07:32:31 <sipa> no idea what that 6th character is
07:33:20 <alej> none of those render on my client =/
07:33:39 <alej> could be a final sigma in there
07:33:48 <PhilRod_> yeah it is
07:34:13 <aristid> > length "Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâ"
07:34:15 <lambdabot>   25
07:34:44 <aristid> 'Œ∫' <- this lookes a bit out of place
07:35:25 <yitz> the sixth letter is zeta
07:35:26 <roconnor> kappa?
07:35:44 <yitz> the funny one before sigma is "stigma"
07:36:26 <roconnor> aristid: œÇœÉ <- are those both sigma?
07:36:28 <rribeiro> Hi folks, does anyone here have used generic programming for the development of simple desktop database access applications ?
07:36:35 <aristid> roconnor: no idea :)
07:37:14 <roconnor> > length ['Œë'..'Œ©']
07:37:15 <lambdabot>   25
07:37:23 <roconnor> :/
07:38:55 <roconnor> > ord 'Œ°'
07:38:56 <lambdabot>   929
07:39:10 <roconnor> > ord 'Œ£'
07:39:11 <lambdabot>   931
07:39:20 <roconnor> > chr 930
07:39:21 <lambdabot>   '\930'
07:39:56 <roconnor> aristid: they are both sigmas
07:40:03 <roconnor> and there is no greek character 930
07:40:26 <roconnor> whose code point occurs between Œ° and Œ£
07:41:53 <dafis> roconnor: œÇ is the final sigma, œÉ the normal one
07:42:13 <alej> it's hard to see if that's a stigma or a final sigma
07:43:59 <roconnor> whats a stigma?
07:44:17 <copumpkin> a mark
07:44:22 <alej> i think it's a sigma + tau
07:44:23 <roconnor> @free map
07:44:24 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:44:29 <dafis> a ligature of a lunar sigma and a tau
07:46:03 <aristid> stigma is lower-case only?
07:46:17 <dafis> alej: stigma is U+03DB, so it should be the final sigma
07:46:39 <dafis> aristid: no, uppercase stigma is U+03DA
07:47:40 <roconnor> ah, yitz wrote an upper-case stigma instead of lower case zeta before
07:47:44 <roconnor> that is why it looked funny
07:48:23 <roconnor> wait never mind
07:48:26 <roconnor> I take that back
07:48:31 <roconnor> anyhow
07:53:08 <pedro3005> how do I escape a newline character?
07:53:31 <dafis> \n
07:54:18 <pedro3005> my problem is I'm pasting a multi-line string into the source and I want it to ignore the newlines
07:54:47 <dafis> pedro3005: String gaps?
07:55:03 <pedro3005> what?
07:55:46 <dafis> "line one
07:55:50 <dafis> "line one\
07:55:54 <dafis> line two"
07:56:09 <roconnor> dafis: does that require CPP?
07:56:13 <dafis> is interpreted as "line oneline two"
07:56:22 <dafis> roconnor: I don't think
07:56:27 <roconnor> neat
07:56:30 <dafis> roconnor: I don't think so
07:56:46 <pedro3005> doesn't seem to be working here dafis 
07:56:49 <dafis> I've never used it, however, so I'm guessing
07:56:55 <pedro3005> s = "123\
07:56:55 <pedro3005> 456"
07:57:02 <pedro3005>     lexical error in string/character literal at character '4'
07:57:03 <pedro3005> Failed, modules loaded: none.
07:58:15 <doserj> is should be "123\
07:58:16 <dafis> pedro3005: oops, you have to unescape the gap
07:58:18 <doserj> \456
07:58:25 <dafis> what doserj said
07:58:38 <pedro3005> ah okay
07:58:51 <roconnor> whoa
08:00:06 <yitz> so you can indent inside the gap without it being part of the string
08:00:42 <yitz> you can play with this in ghci using :{ and :} for a multi-line command
08:01:38 <yitz> > "abc\    \def"
08:01:39 <lambdabot>   "abcdef"
08:01:51 <roconnor> whoa
08:01:53 <yitz> any whitespace works, not just newlines
08:02:12 <roconnor> what section of the haskell report is this defined in?
08:02:35 <yitz> near the beginning somewhere
08:02:45 <dafis> section 2.6
08:03:20 <dafis> A string may include a ìgapîótwo backslants enclosing white charactersówhich is ignored. This allows one to write long strings on more than one line by writing a backslant at the end of one line and at the start of the next.
08:03:40 <roconnor> I shoudl read the report
08:03:57 * dafis agrees
08:12:02 <roconnor> œ°
08:12:40 <roconnor> œ†
08:22:26 * hackagebot strptime 1.0.1 - Efficient parsing of LocalTime using a binding to C's strptime,  with some extra features (i.e. fractional seconds)  http://hackage.haskell.org/package/strptime-1.0.1 (EugeneKirpichov)
08:27:30 * hackagebot semigroupoids 1.1.0 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.1.0 (EdwardKmett)
08:28:31 <rribeiro> @src transpose
08:28:32 <lambdabot> transpose []             = []
08:28:32 <lambdabot> transpose ([]   : xss)   = transpose xss
08:28:32 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:29:03 <rribeiro> :t transpose
08:29:04 <lambdabot> forall a. [[a]] -> [[a]]
08:29:31 * hackagebot comonad-transformers 1.3.0.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.3.0.1 (EdwardKmett)
08:30:33 * hackagebot streams 0.6.0.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.6.0.1 (EdwardKmett)
08:30:54 <roconnor> @djinn (((a,v) -> v), v) -> v) -> ((a,v) -> v)
08:30:55 <lambdabot> Cannot parse command
08:31:02 <roconnor> @djinn ((((a,v) -> v), v) -> v) -> ((a,v) -> v)
08:31:02 <lambdabot> f a (_, b) = a (\ (_, c) -> c, b)
08:35:00 <roconnor> edwardk: Is it usual for comonad transformers to distribute over sums of comonads?
08:35:28 <edwardk> haven't thought about it
08:35:57 <roconnor> edwardk: I'm thinking about whether Exists n:Nat . WT^n Id  and Mu F. WT F + Id are in general isomorphic
08:36:08 <roconnor> edwardk: and if not, which one is the free monad comonad?
08:36:33 <roconnor> Be back in an hour
08:37:27 <edwardk> k
08:38:39 * hackagebot hlint 1.8.7 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.7 (NeilMitchell)
08:39:44 <pedro3005> is there a function similar to maximum but that allows me to pass it a function for comparing the values?
08:40:36 <doserj> :t maximumBy
08:40:38 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
08:40:40 * hackagebot semigroupoid-extras 0.1 - semigroupoid products and coproducts  http://hackage.haskell.org/package/semigroupoid-extras-0.1 (EdwardKmett)
08:40:45 <doserj> in Data.List
08:46:49 <Ferdirand> now to think of it.. is there a tool that can automatically check a program for possible redundancy with the installed libraries ?
08:47:58 <doserj> you mean checking if one reimplements a library function? that's not going to be easy...
08:48:16 <Ferdirand> well, checking that the types do match may be a good start
08:49:01 <Ferdirand> i'm not sure how that would actually help for real work, but it might be a fun learning help
08:49:11 <augur> conal: stop writing blog posts :|
08:49:15 <smarmy> haskell does real work?
08:49:25 <alej> does haksell really work?
08:49:33 <conal> augur: can't stop now. on a roll! 
08:49:37 <augur> :|
08:49:41 <Philippa> smarmy: does your CPU generate more heat when running a haskell program than when idle?
08:49:54 * augur feels inadequate
08:50:11 <augur> conal, you should teach a class
08:50:12 <Botje> Philippa: well, it does when it's compiling .. :)
08:50:26 * conal likes teaching
08:50:34 <augur> :D
08:50:37 <augur> teach!
08:51:16 <augur> live classes are totally more awesome than text. and given how awesome your text is, i can only imagine how awesome a live class with you teaching would be
08:53:04 <conal> :) thx. more fun for me as well.
08:54:56 <augur> conal: it seems like you're pushing types to be increasingly dependent, without being overtly dependent
08:56:02 <augur> this is interesting. how far could GADTs be pushed into the domain of dependency? can they cover all of dependent types, or are there dependent types that can't be made to be encoded in GADTs?
08:57:24 <jmcarthur> augur: GADTs + Extensible Kinds = Dependent Programming
08:57:30 <jmcarthur> augur: (that's the name of a paper, btw)
08:57:34 <augur> jmcarthur: extensible kinds?
08:57:50 <conal> augur: i don't have a feeling yet for where the line is. however jmcarthur recommended the paper "GADTs + Extensible Kinds = Dependent Programming"
08:58:15 <augur> x3
08:58:20 <augur> server lag \o/
08:58:36 <jmcarthur> GADTs can actually be distilled a bit too, but i don't remember into what simpler features
08:58:55 <jmcarthur> existential quantification + equivalence constraints, maybe?
08:59:27 <augur> a functional pearl for the 21st century? cute.
09:00:03 <jmcarthur> augur: extensible kinds would be the ability to create new kinds
09:00:08 <augur> hmm
09:00:28 <augur> i suppose i'd have to see how that works.
09:00:35 <augur> hopefully this paper will be insightful to that end!
09:00:37 <jmcarthur> augur: consider the Vec type...
09:00:39 <byorgey> jmcarthur: yes, existential quantification + equivalence constraints, or equivalently existential quantification + a single GADT  data Eq a b where  Refl :: Eq a a
09:01:00 <augur> byorgey: when are we going to hang out
09:01:16 <augur> jmcarthur: considering
09:01:22 <jmcarthur> augur: extensible kinds would allow you to constraint the Vec type constructor to take only naturals
09:01:29 <jmcarthur> *constrain
09:01:36 <jmcarthur> Vec :: Nat -> * -> *
09:01:47 <jmcarthur> type-level naturals, to be exact
09:01:50 <augur> oh i see
09:01:55 <jmcarthur> Nat there is a new kind
09:02:09 <byorgey> augur: soon I hope!
09:02:46 <augur> how would such a thing look? the definition of such a kind, i mean
09:03:43 <augur> i mean, at what point does it just become more feasible to dissolve the boundary between type-level and data-level?
09:03:49 <jmcarthur> augur: well, one way would be something like:   kind Nat = Z | S Nat
09:04:09 <jmcarthur> augur: it's not so much about dissolving the boundary. it's more like gaining equivalent power
09:04:38 <augur> no i know, i just mean why go through the trouble of bootstrapping values into types, when we've already got values
09:04:49 <jmcarthur> augur: a more powerful way would be the ability to use values at the type level (not dynamically as in a dependently typed language, though)
09:04:51 <augur> why type level/kind level naturals instead of just value level naturals
09:05:07 <jmcarthur> augur: so then you could say:   Vec :: {Nat} -> * -> *, where Nat is actually a type, but {Nat} is a kind
09:05:55 <augur> i suppose what im asking is why not just do true and proper dependent types instead of wrangling the type system into simulating them
09:06:16 <jmcarthur> augur: is equivalent power necessarily a simulation?
09:06:30 <jmcarthur> why is dependent types inherently superior to something of equivalent power?
09:06:49 <jmcarthur> augur: to answer the question more directly though... doing it this way preserved phase distinction
09:07:04 <conal> augur: one reason is that even type-checking easily becomes undecidable.
09:07:05 <jmcarthur> augur: meaning that it's very easy to tell what happens at compile time and what happens at runtime
09:07:06 <augur> jmcarthur: well, it feels like a simulation at least, since you've got value level naturals /anyway/.
09:07:15 <jmcarthur> *preserves
09:07:18 <augur> conal: but wouldnt it become undecidable either way?
09:07:47 <jmcarthur> augur: i think what conal is getting at is that you could require strong normalization at the type level but not at the value level
09:07:49 <augur> or is it that value-level dependency introduces computation, whereas type-level dependency doesnt?
09:08:00 <conal> jmcarthur: right.
09:08:03 <jmcarthur> well, no, there can be computation in either level
09:08:27 <augur> hmm. im not familiar enough with the issue either way. there should be some sort of tutorial on this
09:08:33 <conal> depends on how far one goes with simulating dependent types.
09:08:38 <dark> http://paste.pocoo.org/show/330037/ trying to compile https://gist.github.com/89786
09:08:57 <jmcarthur> i'm not 100% convinced about the utility of a decideable type system compared to an undecideable one
09:09:04 <dark> i can compile programs using parsec 2 fine. what is a 'hidden package' in ghc terms?
09:09:16 <conal> jmcarthur: me neither.
09:09:59 <dark> Latest version installed: 3.1.0 at cabal list, for  * parsec
09:10:17 <allbery_b> it means "ghc-pkg hide" was run on the package.  (cabal automatically hides any package not explicitly named in the *.cabak file as a dependency)
09:10:41 <Philippa> jmcarthur: there're good answers to phase distinction in dependent types these days, AIUI. Erasable PTSes are one
09:10:54 <dark> cabak?
09:11:00 <jmcarthur> Philippa: sure, but is there a simple intuition for the programmer about it?
09:11:05 <allbery_b> cabal
09:11:13 * allbery_b is the lord of the typo...
09:11:16 <dark> how should i proceed to unhide it as user?
09:11:23 <dark> (not as .cabal writer)
09:11:26 <Philippa> jmcarthur: I reckon there's one that can be extracted from them, yeah
09:11:37 <allbery_b> you don't
09:11:40 <jmcarthur> i guess i should read about it more
09:11:44 <allbery_b> you fix the cabal file
09:11:57 <Philippa> (but I've only been awake an hour, not eaten or consumed caffeine in a while, not read the paper in years... not going to offer you one right now!)
09:12:05 <jmcarthur> heh
09:12:33 <dcoutts> dark: are you using cabal (or runghc Setup.hs)?
09:12:40 <dark> allbery_b, but.. what you mean? i installed it with a command (and i think i installed it explictly, not as a dependency). i have never messed with cabal files
09:12:47 <Philippa> that gets you the minimum, mind. What the optimiser can remove in a dependently-typed language is a bigger deal than what can be inlined in haskell
09:12:53 <dark> i am running ghc --make program
09:13:09 <allbery_b> ah
09:13:10 <dark> and i previously installed parsec with something like cabal install ..
09:13:12 <Philippa> for example, if the type structure dictates it anyway, a dependently-typed language can remove all the tags from a value in an algebraic datatype
09:13:14 <djahandarie> conal, how does one go about making your blog highlight the Haskell code in my comment?
09:13:27 <allbery_b> ghc-pkg list to see what's there, ghc-pkg unhide to unhideapaeticular package
09:14:01 <Philippa> (dependent types are /much/ better than an emulation thereof for an optimiser!)
09:14:35 <conal> djahandarie: do you want highlighting, or just code in a box with fixed-width font, preserving line breaks & indentation?
09:14:40 <dark> ghc-pkg: command-line syntax error
09:14:43 <jmcarthur> Philippa: is that an inherent property of dependent types? or is it just that there has been more research along those lines?
09:14:58 <dark> no man page o.o
09:14:59 <djahandarie> conal, I did the latter with <pre>, but I figured highlighting would be nice if possible
09:15:13 <Philippa> jmcarthur: to the extent that an emulation can match them, it's by reconstructing a dependently-typed system from the emulation
09:15:20 <dark> (for ghc-pkg unhide parsec, and ghc-pkg unhide parsec-3.1.0
09:15:38 <Philippa> which would, amongst other things, require running an entire second type-checker
09:15:40 <jmcarthur> Philippa: i guess i'm just taking issue with the idea that all equivalently-powered type systems are mere emulations of dependent types
09:15:46 <Philippa> (because you never know when someone's decided to cheat)
09:16:26 <conal> djahandarie: yeah. i'd like that also. seems to work for me and not for others, and i don't know what's going on. the secrets are in some php code that i haven't penetrated.
09:16:26 <Philippa> jmcarthur: I'm open to alternatives, but anything in the vein of haskell-style emulation is exactly that
09:16:38 <djahandarie> conal, haha, alright
09:16:39 <jmcarthur> well yeah, in haskell we *are* only emulating it
09:17:24 <dark> ghc-pkg list parsec works, but ghc-pkg unhide parsec gives syntax error
09:17:44 <conal> in contrast, i love working with gitit.
09:17:46 <Philippa> jmcarthur: I'm skeptical about the ability of a system without multiple sorts and a similar relationship between the sorts to reach equivalent power without effectively emulating both the sorts and the relationship between them though
09:17:58 <conal> nicely designed. plugins in haskell.
09:18:45 <jmcarthur> Philippa: i'm a little less skeptical, but i'm not knowledgable enough about it to make a sensible argument
09:19:30 <doserj> dark: it is ghc-pkg expose, not unhide
09:19:59 <Philippa> jmcarthur: in a substantial sense I think what's interesting starts with the ability to know that a term was part of a type to start with. The various lambdas and sorts act as a kind of mediating mechanism
09:20:54 <djahandarie> conal, well I submitted it, hopefully it's readable enough :P
09:21:16 <dark> doserj, works, thanks
09:22:15 <djahandarie> Not like it matters too much since the code is still in the clouds
09:22:37 <conal> djahandarie: i'm not seeing it yet. which post?
09:22:44 <djahandarie> Latest
09:23:08 <djahandarie> "(Comment awaits moderation)"
09:23:30 <Philippa> jmcarthur: note that terms depending on types and terms-depending-on-terms-that'll-go-in-types is important too :-) Hence EPTSes etc etc
09:23:45 <djahandarie> And I'm not even sure it'd be infer that the n in Pure n needs to have kind Nat from the Vec n a, but hopefully it would lol
09:25:02 <augur> i think haskell needs an editor that lets you turn on type annotations
09:25:16 <conal> djahandarie: i see it now. thx.
09:25:58 <djahandarie> Yep
09:26:03 <jacobian> A good structure editor for haskell would be handy 
09:26:23 <jacobian> You could do things like ask for term normalisation 
09:26:27 <djahandarie> And I figure it would be able to infer that since the type/kind levels would be collapsed so it could do kind inference just as easily as type inference
09:26:31 <jacobian> You could perform equivalence transforms on terms
09:26:34 <djahandarie> Only byorgey would know I guess
09:26:35 <jacobian> It would be really cool 
09:28:39 * djahandarie goes to class
09:28:57 <conal> djahandarie: thx for the comment. on the post now.
09:29:32 <dark> doserj, actually it is not working. the package is installed globally. at /usr/lib/parsec-3.1.0/ghc-6.12.3. ghc-pkg expose parsec, ghc-pkg expose parsec-3.1.0, ghc-pkg --global expose parsec, ghc-pkg --global expose parsec-3.1.0, none of that works
09:30:04 * hackagebot pandoc 1.8.0.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8.0.1 (JohnMacFarlane)
09:30:08 <augur> conal: in data S n, there's no constraint on n, right?
09:30:11 <dark> actually there is a file called /usr/lib/ghc-6.12.3/gentoo/parsec-3.1.0.conf that says exposed = True, exposedModules = ["Text.Parsec","Text.Parsec.String","Text.Parsec.ByteString","Text.Parsec.ByteString.Lazy","Text.Parsec.Pos","Text.Parsec.Error","Text.Parsec.Prim","Text.Parsec.Char", ..
09:30:19 <augur> i mean, the type S String is valid?
09:30:39 <conal> augur: right.
09:30:40 <dark> (it is from a gentoo ebuild, built from a cabal package)
09:30:59 <augur> conal: ok. so the behavior of S as the successor type is due to how things use S
09:31:01 <jmcarthur> augur: yes that is one of the downsides to this kind of programming in haskell :(
09:31:11 <augur> ok. interesting.
09:31:13 <augur> afk
09:31:35 <dark> Text.Parsec.Language is included at the exposedModules list
09:33:07 <doserj> dark: you are compiling with ghc --make and it doesn't find it?
09:33:13 <dark> yes
09:34:22 <dark> hm, i think it worked.. o.o''
09:43:28 <Sly_> hi
09:43:50 <Sly_> how to define a function witout pattern? something like function = ...
09:44:29 <sipa> function = \arg1 arg2 -> ...
09:44:41 <Sly_> thx
09:44:53 <fryguybob> > let f = map (+1) in f [1,2,3,4]
09:44:54 <lambdabot>   [2,3,4,5]
09:45:07 <sepp2k> Don't arg1 and arg2 count as (trivial) patterns there?
09:45:14 <sipa> yes
09:45:30 <jmcarthur> the docs for Control.Exception list an instance of Exception for a type called Timeout, but the type is not linked. is it actually exported anywhere?
09:46:42 <augur> conal: so these types, data Z and data S n
09:46:50 <jmcarthur> oh i think i found it in System.Timeout. not exported, sadly :\
09:47:20 <sepp2k> A bit off topic, but is there a dynamically typed, lazy functional programming language with an eval function?
09:47:20 <augur> do they have inhabitants in the denotational sense, and the lack of constructors simply means we can't /access/ the inhabitants, or do they not have inhabitants at all?
09:47:34 <sipa> sepp2k: haskell, using Data.Dynamic? ;)
09:48:04 <sipa> oh, eval function as is something you pass a string, and is interpreted?
09:48:04 <augur> i feel like if you used the type ~ set notion, you'd need to have inhabitants, otherwise types would be substantive beyond their extensions
09:48:17 <Philonous> I wonder whether ContT isn't actually a delimited continuation (delimited by runCont)
09:48:22 <sepp2k> sipa: Yes.
09:49:47 <sepp2k> Hm, lazy racket looks like it might fit the bill.
09:52:00 <conal> augur: yeah. weird. you might say they're types but not of kind *, which is why they don't have inhabitants.
09:52:09 <conal> augur: same reason that [] has no inhabitants.
09:53:19 <conal> augur: i'm not entirely satisfied with that answer. 
09:53:58 <dolio> Z and S n are both of kind *, and have inhabitant bottom.
09:54:29 <dolio> Unless your Z and S are different than normal.
09:54:39 <augur> conal: and whats up with these where clauses in data definitions? what does Zero :: Nat Z do? is it just a constructor with a specific type?
09:55:03 <conal> augur: check out GADTs.
09:55:11 <augur> :(
09:55:28 <conal> augur: and yes. a ctor with specific type.
09:55:36 <augur> i get the parametricity in the type itself (data S n type parametricity) but not the where stuff
09:56:19 <dolio> The where syntax allows you to give specific types for each constructor, including the result type.
09:56:48 <dolio> Which allows constructors to target less than the entire family of types.
09:57:02 <augur> hmm ok
09:57:04 <augur> that makes sense
09:57:40 <augur> so you have GADTs that are even smaller than what you'd get by having the variables in the type itself
09:57:41 <dark> http://hackage.haskell.org/package/hssqlppp seems nice @.@
09:58:06 <dolio> I'm not sure what that means.
09:58:31 <dolio> But, Zero :: Nat Z means that Zero is only a possible constructor for Nat Z, not arbitrary Nat n.
09:58:35 <augur> dolio: we,, i mean, in conal's definition for Nat :: * -> *, can it be converted into an equivalent Nat n :: *?
09:59:12 <augur> i feel like if you defined it as Nat n :: *, you'd have a superset of inhabitants
09:59:23 <dolio> So if you have x :: Nat (S n), you know that x cannot be equal to Zero, because Zero only targets Nat Z.
09:59:34 <augur> sure sure
09:59:44 <augur> no i get that
10:00:01 <augur> im tring to see how this relates to having type variables
10:00:21 <augur> it doesnt seem like you could state this restriction at all with type variables
10:03:15 <roconnor> edwardk: okay. I'm back to think about distribution of comonad transformers over sums
10:03:47 <jmcarthur> augur: you could say something like:    (n ~ S m) => Nat n
10:03:50 <roconnor> edwardk: so maybe I should think about the free monad for a functor F.
10:03:55 <augur> jmcarthur: who what
10:04:05 <jmcarthur> augur: equivalence constraint
10:04:14 <augur> oh ok
10:04:22 <augur> hm
10:04:24 <jmcarthur> well, and i guess m would have to exist somewhere
10:04:29 <jmcarthur> existential type i guess
10:05:23 <roconnor> edwardk: you define a free monad to be Mu X. a + F (X a)
10:05:51 <roconnor> edwardk: which is different from Exists n. F^n a
10:06:09 <jmcarthur> augur: see the section "GADTs as Equality Constrained Types" in that "GADTs + Extensible Kinds = Dependent Programming" paper
10:06:17 <augur> ok
10:06:21 <augur> ill read the whole paper, so
10:06:42 <edwardk> roconnor: true nuff
10:07:00 <edwardk> mainly because the former allows for the coinductive knot to be tied
10:07:03 <roconnor> edwardk: is Exists n. F^n a anything?
10:07:10 <edwardk> well, Nu X.
10:07:30 <edwardk> well, its annoying to work with for one =)
10:07:38 <edwardk> because the definition is terribly 'non-productive'
10:07:47 <edwardk> you get something like
10:08:11 <roconnor> edwardk: well it isn't clear to me Exists n. F^n a  and Mu X. a + F (X a) are even isomorphic
10:08:19 <roconnor> (are you sure it isn't Mu?)
10:08:20 <edwardk> data Free f a = Zero a | Succ (Free f (f a))
10:08:45 <edwardk> i don't think its the same
10:09:08 <roconnor> is Exists n. F^n a  a monad?
10:09:10 <edwardk> its Mu in the sense that mu and nu unify and that you define it interms of a fold so you can only claim mu
10:09:24 <edwardk> sure
10:09:47 <edwardk> er to get that to be eists n, you need the ! on Succ's member to keep it inductive
10:10:08 <edwardk> data Free f a = Zero a | Succ (Free f (f a))
10:10:19 <edwardk> its the dual of my Tensors data type
10:10:21 <roconnor> the ! ?
10:10:24 <edwardk> er
10:10:31 <augur> i still dont understand existential types :\
10:10:33 <edwardk> data Free f a = Zero a | Succ !(Free f (f a))
10:10:48 <roconnor> edwardk: let's forget about partial values
10:10:50 <edwardk> that keeps you from having fix Succ as a member
10:11:13 <edwardk> lets look at the relationship i have between Tensors and Cofree
10:11:24 <edwardk> it should illuminate the difference between Cotensors and Free
10:11:26 <dolio> That's still probably not inductive.
10:11:29 <edwardk> (for wont of a better name)
10:11:44 <dolio> Oh, wait, I suppose that works, yes.
10:11:55 <edwardk> yeah, here it works, sice i'm not tying through f
10:12:01 <dolio> Right.
10:12:29 <edwardk> data Tensors f a = a :- Tensors f (f a) ‚Äî is used in my ad package
10:12:35 <roconnor> (btw, your deffinition of Free is different from at your blog post: http://comonad.com/reader/2008/monads-for-free/
10:12:58 <edwardk> yes. styles change ;)
10:13:10 <edwardk> usually i say Free f a = Rick a | Roll (f (Free f a)) ;)
10:13:16 <leifw> are code.haskell.org and projects.haskell.org (and probably some others) down?
10:13:40 <dschoepe> leifw: yes
10:13:40 <dolio> Yes.
10:13:44 <dolio> They have been for a few days.
10:13:44 <roconnor> edwardk: Tensors looks like the definition of cofree
10:13:45 <edwardk> you can convert from Stream f a to Tensors f a, but not back
10:13:46 <leifw> dang
10:13:53 <edwardk> roconnor: its close
10:14:05 <edwardk> you'd need to be able to zip 'f's to put it back together
10:14:12 <edwardk> so there is a morphism, not an isomorphism
10:14:12 <roconnor> what is the definition of Cofree?
10:14:25 <leifw> of all the times to reinstall...
10:14:26 <edwardk> data Stream f a = a :< f (Stream f a)
10:14:51 <roconnor> edwardk: okay, but now I'm confused as to the definition of free.
10:15:04 <roconnor> (assuming Stream is cofree)
10:15:08 <edwardk> which one? the succ based cotensors one above, or the one in my blog?
10:15:41 <roconnor> edwardk: the difference between your succ based one here and the one in your blog is the same as the difference between Tensors and Streams
10:15:54 <edwardk> newtype Cofree f a = Cofree (a, f (Cofree f a)) ‚Äî newtyoe Free f a = Free (Either a (f (Free f a))) ‚Äî if that makes it easier to spot
10:16:00 <edwardk> exactly =)
10:16:09 <edwardk> the one above was my attempt to answer your question
10:16:24 <edwardk> hence why i tried to rename it to Cotensors ;)
10:16:31 <roconnor> edwardk: which one is the correct definition of free.  I presume they can't both be correct.
10:16:45 <edwardk> Free is the newtype or the one on my blog
10:16:53 <edwardk> Tensors is related but not the same
10:16:56 <edwardk> er Cotensors
10:17:15 <roconnor> edwardk: then why did you call the succ-based one Free above?
10:17:27 <edwardk> because i was still working out the difference. =P
10:17:32 <roconnor> :D
10:17:35 <edwardk> its not free
10:17:37 <edwardk> let it go =P
10:17:49 <edwardk> you can convert it to Free though
10:17:58 <edwardk> Free admits Returns to be at different levels
10:18:07 <edwardk> Cotensors has all the 'Returns' at the same level
10:18:12 <edwardk> its a 'complete' free monad
10:18:42 <alex404> Okay, so GHC is telling I should use Impredicative types, but in the documentation it says the feature is being deprecated? What is this extension and should I avoid it?
10:18:47 <roconnor> edwardk: okay
10:18:58 <roconnor> edwardk: I'm with you know
10:19:00 <roconnor> *now
10:19:37 <edwardk> in the dual manner you can take Stream f a ‚Äî and 'unzip' each of the f's. and get a :- f a :- f (f a) :- f (f (f a)) :- ...
10:19:41 <roconnor> edwardk: what is the universal property of a free monad?
10:19:45 <benmachine> alex404: what's your use case?
10:20:00 <edwardk> brb. and i suck at that language =)
10:20:42 <alex404> benmachine: I have a list over an associated datatype (type family stuff I think...), which I want to be polymorphic
10:23:27 <augur> anyone know of a nice discussion of data structures as embodiments of computations?
10:23:53 <edwardk> http://ncatlab.org/nlab/show/free+monad says it better than i could
10:24:08 <edwardk> augur: not off hand
10:24:18 <augur> hmm
10:24:20 <roconnor> edwardk: cotensors is a monad though?
10:24:43 <edwardk> roconnor: i think it fails actually
10:25:18 <edwardk> because nothing enforces that you return the same sized tree for a each choice of 'a'
10:25:22 <edwardk> its a comonad though
10:25:36 <edwardk> or should be
10:25:44 <roconnor> edwardk: it most certainly isn't a comonad
10:25:59 <edwardk> oh yeah
10:26:10 <edwardk> was thinking i had the a out front
10:26:25 <ski> how's `Cotensors' defined ?
10:26:30 <edwardk> got confused with tensors for a sec (which is almost a comonad for the same reason)
10:26:56 <edwardk> data Cotensors f a = Zero a | Succ !(Cotensors f (f a))
10:27:15 <edwardk> exists n. f^n a
10:27:29 <ski> edwardk : that looks like the `Free' you mentioned before ?
10:27:44 <edwardk> yeah, a misnomer i'll apparently never live down
10:27:49 <ski> ah, ok
10:27:52 <edwardk> =)
10:27:55 <roconnor> I was going to say: edwardk will never live that down
10:28:16 <edwardk> 's what i get for giving you unfiltered thoughts ;)
10:28:29 <ski> no worry :)
10:29:10 <edwardk> roconnor: btw- i can define indexed _bind_ and indexed _extend_ transformers, but not indexed monad/indexed comonad transformers =/
10:29:32 <ski> edwardk : hm, couldn't you make the size part of the type, though ?
10:29:34 <roconnor> now I wonder if my cartesian store is the free monad comonad
10:29:40 <ski> a GADT, e.g. ?
10:29:45 <roconnor> or if that was a leap too far.
10:29:46 <edwardk> ski: you can, that makes it a bit more productive
10:30:00 <JR_> if, im wondering if anyone could link me to a good tutorial for begginers on for loops.
10:30:05 <edwardk> ski: you don't have to recurse over N Succ's to get to the first f
10:30:24 <conal> New blog post: http://conal.net/blog/posts/reverse-engineering-length-typed-vectors/ .  Another little one. More to come.
10:30:25 <edwardk> as roconnor begins to doubt himself
10:30:27 <roconnor> JR_: loops are generally out of favour in Haskell.
10:30:33 <ski> edwardk : .. i'm not sure what you mean by that last ?
10:31:17 <JR_> roconnor: ok, what are the differences?
10:31:50 <roconnor> JR_: typcially we use higher-order combinators such a foldr or map
10:32:03 <roconnor> JR_: on occasion we write our own recursive functions
10:32:25 <jacobian> There is a loop construct in haskell? 
10:32:38 <jacobian> I confess I didn't know
10:32:44 <sipa> forM
10:32:44 <edwardk> ski something like: data Cotensors f n a where Zero :: a -> Cotensors Zero a; Succ :: f (Cotensors n a) -> Cotensors f (Succ n) a
10:32:46 <aavogt> there are a couple
10:32:58 <edwardk> er add 'f's as needed
10:33:04 <aavogt> map, until, iterate
10:33:31 <monochrom> you can write your own loop functions using recursion
10:33:31 <edwardk> ski: then the shape is Succ (f (Succ (f (Succ (f ‚Ä¶ - rather than Succ (Succ (Succ (Zero (f (f (f a)))))))
10:33:32 <roconnor> edwardk: okay, definitely exists n. WT^n Id a is a comonad for any comonad transformer WT.
10:33:44 <roconnor> edwardk: but that doesn't appear to be a free monad construction
10:33:47 <edwardk> that i'd buy
10:33:49 <dolio> edwardk: (exists n. f^n a) means n is a bifunctor, and f^n a = forall b. n a b -> f b?
10:33:52 <roconnor> edwardk: it is a tensors construction
10:33:54 <monochrom> they are not constructs. they are just functions.
10:33:56 <edwardk> so you need to make up a new name
10:34:15 <edwardk> dolio (f (f ( f .. n times a)))))
10:34:20 <aavogt> what is a construct?
10:34:23 <dolio> Oh, okay.
10:34:26 * hackagebot grammar-combinators 0.2.2 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2.2 (DominiqueDevriese)
10:34:32 <dolio> That makes more sense.
10:34:40 <monochrom> a construct is a language builtin and cannot be user-defined.
10:34:51 <Sly_> some german people out there? need a source code explanation in german :/
10:35:00 <edwardk> the current cofree comonad in category-extras was based on some horrid bifunctor construction
10:35:21 <edwardk> i've regretted it ever since, except the one time it let me whip out a recursion scheme for someone
10:35:37 <dafis> Sly_: kannste haben, vielleicht
10:35:46 <mauke> JAWOHL
10:35:55 <roconnor> I mean cotensor
10:36:03 <mauke> /join #haskell.de
10:36:06 <dafis> mauke: das heﬂt "jau"
10:36:22 <dafis> *heiﬂt
10:36:50 <mauke> und alle so: yeah
10:37:01 <dafis> yeah
10:37:07 <roconnor> edwardk: as a complete asside. Do you have any slice category constructions in category extras?
10:37:54 <edwardk> nah, no good way to encode it as far as i can see
10:38:22 <roconnor> fair
10:38:25 <ski> edwardk : ah, i see
10:38:28 <edwardk> category-extras will soon be replaced with a tiny little stub package
10:38:31 <roconnor> I had trouble coming up with ideas myself
10:39:12 <jmcarthur> edwardk: planning to stick some sort of Cofree into the comonads package or anything?
10:39:14 <edwardk> i just need to split off the bifunctor combinators, indexed comonads, and its basically done
10:39:24 <edwardk> jmcarthur: there are several right now =)
10:39:33 <jmcarthur> oh? /me looks
10:39:45 <edwardk> jmcarthur: comonad-transformers provides a stream transformer, and streams provides a Data.Stream.Branching
10:40:24 <edwardk> plus Data.Stream.Infinite is effectively cofree identity, and data.stream.nonempty and data.stream.future are isomorphic to cofree maybe iirc
10:40:48 <jmcarthur> i see
10:41:12 <edwardk> i was looking to package up a something small with just explicit (co)free (co)monads
10:41:19 * jmcarthur has some code to update then
10:41:23 <edwardk> and possibly (co)ideal (co)monads
10:41:33 <edwardk> but for now i'm using streams Data.Stream.Branching as Cofree
10:41:48 * benmachine starts wondering if coconuts are isomorphic to nuts
10:41:51 <edwardk> later on there'll probably be a class in comonads-fd once i can make sense out of it
10:42:00 <edwardk> benmachine: even stronger. they are nuts ;)
10:42:05 <Palmik> Hmm... how would you compose function which takes Value with function which returns Reader State Value? Or is it not feasible?
10:42:15 <glguy> coconuts are even stronger than nuts?
10:42:17 <pozic> Do you have any demo where one of those fancy structures is faster than a usual data structure?
10:42:22 <edwardk> @type fmap
10:42:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:42:34 <aristid> preflex: seen geheimdienst
10:42:35 <preflex>  geheimdienst was last seen on #haskell-blah 4 hours, 55 minutes and 11 seconds ago, saying: > let python'sIdentifiersCan'tDoThis = 42 in 1
10:43:19 <edwardk> pozic: mine?
10:43:35 <pozic> edwardk: (co)ideal (co)monads
10:43:44 <Palmik> edwardk, fo fmap return over the function accepting Value?
10:44:00 <edwardk> pozic: they are interesting because they compose nicely
10:44:05 <benmachine> Palmik: use fmap on your function which takes Value
10:44:14 <edwardk> pozic: not particularly for their speed.
10:44:15 <edwardk> afk
10:44:17 <pozic> edwardk: you mean unlike monad transformers?
10:44:25 <edwardk> yes
10:44:35 <edwardk> any to ideal monads have a coproduct construction
10:44:42 <mauke> @msg #haskell 1
10:44:43 <edwardk> lots of monads are coideal (or can be made so)
10:44:43 <lambdabot> 1
10:45:00 <edwardk> e.g. list isn't, but it can be made isomorphic to something that is
10:45:09 <benmachine> Palmik: fmap can turn a function Value -> r into Reader State Value -> Reader State r, then you can compose it with the other one
10:45:11 <aristid> edwardk: to what?
10:45:17 <edwardk> ideal
10:45:23 <Palmik> benmachine, thanks :)
10:45:32 <edwardk> of the form Return a | Ideal (f a)
10:45:50 <edwardk> its just really ugly to do =)
10:48:39 <kleinucopia> is hdbc-mysql dangerous to use?
10:49:02 <burp> dangerous in what sense?
10:49:13 <pozic> kleinucopia: the h is kinda dangerous.
10:49:23 <alex404> Is there a way to have a list over an associated data type, where the list is heterogeneous/polymorphic with regards to the type arguments of the associated data type?
10:49:28 <burp> @faq can haskell be dangerous?
10:49:29 <lambdabot> The answer is: Yes! Haskell can do that.
10:49:32 <aristid> edwardk: what is f for lists?
10:49:56 <kleinucopia> pozic: should I use odbc instead? I can't find a very helpful guide for that.
10:50:26 <pozic> kleinucopia: Haskell has no guides; people are assumed to be born with all knowledge. 
10:50:55 <pozic> kleinucopia: my first response was a joke, in case you didn't notice.
10:51:03 <Palmik> :)
10:51:47 <aristid> edwardk: with [], Ideal [] a would not be isomorphic to [a]
10:51:55 <aristid> i think
10:52:15 <roconnor> edwardk: what is ideal?
10:52:16 <kleinucopia> pozic: actually, it's not the haskell guide that's lacking, it's the configuring odbc guide.
10:52:46 <pozic> kleinucopia: it worked 10 years ago for me. I think the documentation is fine. 
10:53:32 <edwardk> aristid: with lists f has to be either empty or 2 or more a's
10:53:40 <edwardk> aristid: hence why i said its possible, but ugly
10:53:52 <edwardk> roconnor: ideal monads are a generalization of free monads.
10:54:23 <edwardk> http://www.cs.nott.ac.uk/~txa/monads-more-2.pdf gives the definition
10:54:43 <edwardk> they are basically monads where the return is separated from the 'meat' of the monad.
10:54:51 <roconnor> ok
10:54:59 <edwardk> and where return is given for you, and mu is defined in terms of a more primitive operation
10:55:26 <edwardk> this lets you compose them by interleaving the 'meaty parts' =)
10:56:14 <edwardk> a + f a   and a + g a can be composed into a + (f (a + (g (a + ‚Ä¶)))) + g (a + (f a + ‚Ä¶ ))
10:56:31 <edwardk> defined as a sort of mutual recursion between f and g
10:56:38 <edwardk> with a separated base case
10:57:10 <edwardk> the monad smashes together adjacent f's or adjancent g's using their respective 'prebinding' operations
10:58:11 <edwardk> i think i called it 'idealize' in category extras
10:58:27 <edwardk> though i think i got bored before i added the definition for ideal coproducts and coideal products
11:01:57 <roconnor> edwardk: so my cartesian store is defined by CStore b = Id :+: StoreT b (CStore b). ... that certainly seems like the free monad construction.
11:02:11 <aristid> finger trees seem to be pretty complex
11:02:23 <aristid> what are they suited for?
11:03:33 <c_wraith> having trees with distinguished values other than "the middle, for some definition of middle"
11:03:51 <roconnor> aristid: quick access to left and right of a tree and quick "concatination" of trees, Also supports memozized monoid information at the nodes of the tree for fast aggrigation of tree data.
11:03:52 <untwisted> Hi all, I'm looking for suggestions for a graduate level programming languages project. I've got a good beginner to intermediate level understanding of haskell and want to use it for the project, but I have no good ideas :(
11:04:18 <opqdonut> fingertrees are pretty fast even when used only as an annotated tree structure
11:04:39 <aristid> roconnor: so essentially for sequences and statistics over sequences?
11:05:18 <roconnor> aristid: that is a common use for them.  Note that is sort of thing is great for a priority search queue.
11:05:38 <roconnor> IIRC
11:08:12 <edwardk> roconnor: yeah. thats why i was thinking that looked like a higher kinded free monad
11:08:54 <aristid> roconnor: hmm
11:09:18 <roconnor> edwardk: ah StoreT b (w :+: v) = StoreT b w :+: StoreT b v
11:09:18 <edwardk> aristid: they have great asymptotic behavior
11:09:52 <edwardk> aristid: i use them for parsing and all sorts of stuff
11:09:54 <roconnor> edwardk: so in this particular case FreeW StoreT and CotensorW StoreT are isomoprhic
11:10:02 <aristid> edwardk: for monoidal parsing? :)
11:10:09 <edwardk> aristid: yep =)
11:10:34 <edwardk> i need to build a shiny new semigroupoid fingertree of some sort ;)
11:10:46 <aristid> edwardk: you can parse efficiently even if your input arrives out of order? :)
11:11:16 <edwardk> aristid: or in my case you can parse in parallel then glue together partial parses, or you can parse and then reparse incrementally as people type
11:11:29 <edwardk> but yes the out of order case would work too
11:12:36 <edwardk> roconnor: not sure i followed that
11:13:06 <edwardk> i buy the isomorphism
11:13:09 <roconnor> edwardk: ah StoreT b (w :+: v) = StoreT b w :+: StoreT b v
11:13:19 <edwardk> that part
11:13:36 <edwardk> but i didn't see how that got you the free store is isomorphic to cotensor store
11:14:17 <edwardk> and actually i see a morphism, not an isomorphsim
11:14:29 <edwardk> StoreT b w :+: StoreT b v has two states
11:14:34 <roconnor> That means that FreeW (StoreT b) = Id :+: (StoreT b (Id :+: StoreT b (Id :+: ...) = Id :+: StoreT b Id :+: StoreT b (StoreT b Id) :+: ... = CotensorW (StoreT b)
11:15:25 <edwardk> i can go from StoreT s (w :+ v) to StoreT s w :+: StoreT s v ‚Äî by distributing the state between them, but coming back i need to glue states together
11:15:48 <edwardk> oh wait coproduct
11:15:49 <edwardk> sorry
11:15:52 <edwardk> i'm a moron
11:15:58 <roconnor> StoreT b (w :+: v) a = ((w :+: v)(b -> a), b) = (w (b -> a) + v (b -> a), b) = (w (b -> a),b) + (v (b -> a), b) = StoreT w a + StoreT v a
11:16:44 <edwardk> i was stuck on a product law, nm
11:16:53 <roconnor> edwardk: back to grade 10 for you
11:17:05 <edwardk> yeah
11:17:16 <edwardk> i'd totally rock algebra this time around
11:18:42 <uberfry> hah
11:18:43 <uberfry> same here
11:18:47 <uberfry> I wish I was back in high school
11:19:05 <uberfry> "my dog ate my homework" *search the bag* "oh wait, I was wrong"
11:19:17 <uberfry> or attend drunk
11:19:27 <edwardk> gah. the arrows package is really !@*#() annoying
11:19:27 <uberfry> or even just hung over :)
11:19:32 <edwardk> all the constructors i want aren't exported =(
11:20:25 <edwardk> i guess i need to just make a semigroupoid-transformers package instead
11:21:11 <edwardk> or arrow-transformers/arrows-fd would make more sense i guess
11:21:48 <djahandarie> edwardk, any progress on uploading that Boston Haskell video? ;)
11:21:50 <roconnor> edwardk: it seems that both FreeW and CotensorW both produce comonads?
11:21:58 <roconnor> maybe be I should double check this
11:22:11 <roconnor> it is almost certainly the case that CotensorW produces a comonad.
11:22:16 <roconnor> less sure about FreeW.
11:22:33 <edwardk> djahandarie: sitting at home on a camcorder. should have pinged me over the weekend ;)
11:22:44 <edwardk> roconnor: haven't tried
11:22:48 <djahandarie> lol :(
11:23:26 <roconnor> so maybe there isn't a free monad comonad
11:23:40 <roconnor> it seems like a pretty nice construction though
11:26:57 <roconnor> I mean it is clearly a comonad under the assumption that it is a comonad :D
11:27:12 <edwardk> hrmm. it seems that my Apply class and my ComonadApply operations want different types somehow when i go to make them indexed.
11:27:15 <edwardk> hahaha
11:28:19 <roconnor> edwardk: such is the way of induction
11:28:26 <edwardk> hrmm i need two names for static arrows
11:28:46 <edwardk> i need one for f (a -> b) ‚Äî which gets most of its properties from f, and one for f (k a b) which gets most of its properties from k.
11:29:38 <edwardk> e.g. to derive ArrowPlus, the former uses the Alternative, the latter uses the underlying ArrowPlus instance
11:29:56 <kunwon9> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! kunwon9 marcot otzi jssanders vegai rribeiro kelvie jsgf Athas Guest30054 tew88 zmbmartin pacak jonkri _nickel fhs sioraiocht nff waterlaz anRch Itkovian geekounet ketil dreixel glguy_ hiptobecubic kosmikus cafesofie __nickm__ ale
11:29:56 <kunwon9> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! path[l] Evious allbery_b carlocci dark Cthulhon Schmallon noam lampy Sly_ pheaver dahankzter mzero ablokzijl nettok SyntaxNinja nzero dimmy silver lpsmith neurogeek ulfdoz morphling ceii_ dankna ceii Runar cubi comak Jantaro lopex
11:29:56 <kunwon9> kunwon1 here. ##politics  invites you to join in the discussion. Liberals and leftists are threatening this great country. Fight with us to take it back! We need your support in ##politics NOW! Don't let the Obamaination continue! MigoMipo TML copumpkin paper_cc kleinucopia danharaj ccasin ernst augur sonnym alej jem777 janbanan ab3 PhilRod_ xinming_ kermit phyrex1an smarter roconnor Yvemath myu2 smerz cheater00 FireFly dlila Pewpewarrows Bynbo7 fryguybob d
11:30:13 <tg_> i'm just mad
11:30:15 <Itkovian> not again
11:30:19 <copumpkin> sigh
11:30:22 <tg_> that he says he's kunwon1, when he's kunwon9
11:30:22 <cubi> :/
11:30:25 <tg_> that's false advertising.
11:30:28 <Itkovian> lol
11:30:29 <tg_> BURN THE WITCH!
11:30:30 <jonkri> haha
11:30:31 <sioraiocht> does he know that open source people are all anarchist?
11:30:32 <kleinucopia> spam spam spam spam.... SPAM SPAM, WONDERFUL SPAM
11:30:43 <silver> this country yeah
11:30:45 <hiptobecubic> So... we all storm ##politics and complain about spam?
11:30:45 <pheaver> crap, now what was I do when i was interrupted....
11:30:46 * roconnor is an anarchist
11:30:49 <mzero> maybe those identifiers are referencing the same thunk...
11:30:50 <kleinucopia> SHUT UP! Bloody Vikings.
11:30:54 --- mode: ChanServ set +o monochrom
11:31:00 <tg_> i'm a noam comskyist
11:31:03 <mzero> actually, we should all storm ##politics and explain Monads
11:31:11 <lpsmith> mzero++
11:31:13 <hiptobecubic> mzero, impossible
11:31:14 --- mode: monochrom set +q $~a
11:31:19 <edwardk> after all monads were first created for political discourse! ;)
11:31:20 * lpsmith is a social democrat
11:31:23 <roconnor> edwardk: maybe I should pull out my Coq here.
11:31:51 <edwardk> just don't wave it around the channel, there are children present. exposure to theorem proving too early warps the brain.
11:32:19 <mzero> "Father, do words corrupt?"
11:32:28 <aristid> No, but algebra does.
11:32:28 <jonkri> is there like a high-level type to represent an e-mail address in haskell?
11:32:41 <edwardk> newtype Email = Email String
11:32:43 <edwardk> done ;)
11:32:49 <jonkri> bah :P
11:33:02 <lpsmith> jonkri,  what do you really need it to do?
11:33:12 <aristid> can an email address contain non-ascii characters?
11:33:14 <edwardk> typecheck it by tryig to send an email to the address, use template haskell
11:33:15 <jonkri> lpsmith: good question... i guess is should have asked myself that first :P
11:33:17 <mzero> "I don't know, son. Let's find out. Angus... Monad!"
11:33:23 <djahandarie> I need to encode regex in my types!!!
11:33:23 <djahandarie> halp
11:33:25 <mzero> er, s/ng/gn/
11:33:30 <lpsmith> In my opinion,  it's easy to get carried around with structuring data
11:33:35 <jonkri> edwardk: what's wrong with "type Email = String"?
11:33:45 <lpsmith> I know I get sucked into that trap from time to time,  and will again.
11:33:47 <jonkri> lpsmith: i see
11:33:52 <tromp_> rebol has email datatype
11:33:55 <edwardk> jonkri: it just ensures you use it correctly
11:34:11 <edwardk> jonkri: you can use the type alias, but then you can't make instances for it, etc.
11:34:18 <tromp_> not that anybody uses rebol...
11:34:28 <jonkri> interesting
11:34:53 <lpsmith> Yeah,  otherwise Email is exactly the same as a string.   Which can be useful for documenting the intention of a given parameter in a type,  but less useful for other purposes.
11:35:48 <edwardk> my rule of thumb is generally that if it escapes the module i'm in, i make it a newtype
11:35:48 <tg_> .
11:36:33 <djahandarie> newtypes around Strings do kind of piss me off
11:36:36 <edwardk> if its a purely local concern i may make a type. the only exception i tend to permit myself is the type alias for base versions of monads in the spirit of the mtl
11:36:37 <roconnor> edwardk: I'm trying to define what CotensorW would be
11:36:55 <edwardk> roconnor: when you get done with that i have a brainteaser for you to prove with coq =)
11:37:27 <jonkri> edwardk: when do you use "data"?
11:37:37 <djahandarie> newtype FilePath = FilePath String -- would be much more annoying than type FilePath = String
11:37:54 <edwardk> jonkri: when you need two constructors, an existential data type, or you really want to add a layer of laziness and overhead
11:38:33 <ski>   data Email = MkEmail { userName :: String,domain :: Domain } -- ?
11:38:53 <ski> @quote stark
11:38:54 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11:38:58 <edwardk> roconnor: i need liftCallCV :: Comonad w => (w (w (w a -> a) -> b) -> b) -> StoreT e w (StoreT e w (StoreT e w a -> a) -> b) -> b ‚Äî though feel free to weaken Comonad there to Functor ;)
11:39:03 <jonkri> great
11:39:35 <alex404> Can anyone tell me why I'm getting this: Ambiguous constraint `MultiLayerNetwork m'
11:39:46 <alex404> At least one of the forall'd type variables mentioned by the constraint
11:39:55 <alex404> must be reachable from the type after the '=>'
11:40:10 <edwardk> jonkri: a newtype has zero overhead at runtime, it exists purely at compile time (modulo dictionary construction)
11:40:44 <aristid> @hackage newtype
11:40:44 <lambdabot> http://hackage.haskell.org/package/newtype
11:41:14 <alex404> MultiLayerNetwork is a class which involves a foralled datatype...
11:41:28 <edwardk> ski: but what do i do when i timetravel and have to encode bang paths again?
11:41:36 <roconnor> edwardk: have you asked dijnn?
11:41:42 <edwardk> besides take over the world with my laptop
11:41:52 <dafis> alex404: paste
11:41:53 <edwardk> roconnor: haven't tried
11:42:01 <djahandarie> aristid, maybe not so useful here ;)
11:42:08 <roconnor> edwardk: what was your definition of Cotensor?
11:42:22 * djahandarie -> class
11:42:34 <edwardk> data Cotensor f a = Zero a | Succ (Cotensor f (f a))
11:42:44 <aristid> djahandarie: make it more useful, then :)
11:42:50 <edwardk> or the interleaved version
11:43:05 <aristid> djahandarie: i found out that using it with mconcat is a bit tedious
11:43:57 <alex404> dafis: http://hpaste.org/43475/type_madness
11:44:14 <alex404> dafis: The error is off of the <::> declaration
11:44:46 <alex404> dafis: If you get what I'm going for, I'm open to other ways of organizing the code too
11:45:02 <edwardk> data Cotensor f a = forall n. Cotensor (Nat n f a); data Nat n f a where Zero :: a -> Nat Zero f a; Succ :: f (Nat n f a) -> Nat (Succ n) f a
11:45:14 <edwardk> with data Zero; data Succ n
11:45:24 <roconnor> edwardk: is that isomorphic?
11:46:17 <edwardk> yeah, though it is more 'productive' to access.
11:46:32 <edwardk> since accessing the first layer of something with 256 layers doesn't require skipping 256 Succs and a Zero
11:46:51 <lpsmith> jonkri,   for example,  if you want to make sure a given value represents a syntactically valid email address,   you could do something like  newtype Email = Email String,    and then define  makeEmail ::  String -> Either ErrorMsg Email
11:47:03 <dafis> alex404: Can you paste the error message too? And I'm not getting what you're going for :(
11:47:33 <lpsmith> you could also define your own equality,  for example maybe you could teach it about gmail's + accounts
11:48:00 <ski> edwardk : i suppose one could make provisions for that in the datatype .. by adding more arguments, or making another constructor
11:48:12 <ski> (this ties in to the version problem, of course)
11:48:25 <alex404> dafis: Wait a moment... I might just be being a moron...
11:48:38 <edwardk> ski: i failed to put that statement into context
11:48:40 <dafis> that's what *you* said
11:48:58 <ski> edwardk : that was re your `Email' comment
11:49:04 <edwardk> ski: ah
11:49:18 <edwardk> ski: i was mostly being facetious
11:49:32 <ski> yeah, i assumed so :)
11:49:50 <alex404> dafis: Yup, moron it is. I'd renamed some polymorphic type variables inconsistently
11:50:04 <dafis> aha
11:50:09 <alex404> dafis: I didn't really need that hour of my life anyway
11:50:33 <dafis> alex404: if you have more such hours, can you send them to me?
11:50:34 <jonkri> lpsmith: great, thanks :)
11:51:02 <alex404> dafis: Will do
11:51:14 <dafis> cool
11:56:34 <edwardk> @djinn (w (w (w a -> a) -> b) -> b) -> (e, w ((e, w (e, w a) -> a) -> b)) -> b
11:56:35 <lambdabot> -- f cannot be realized.
11:57:01 <edwardk> @djinn ((e, w ((e, w (e, w a) -> a) -> b)) -> b) ->  (w (w (w a -> a) -> b) -> b) 
11:57:01 <lambdabot> -- f cannot be realized.
11:57:15 <Veinor> "hey, why did almost all of my data disappear?"
11:57:20 <edwardk> er i'm off in parenthesization
11:57:22 <Veinor> "... oh, sort is minimum to maximum"
11:57:27 <Veinor> stupid sortBy not reading my mind!
11:57:53 <edwardk> @djinn (w (w (w a -> a) -> b) -> b) -> (e, w ((e, w ((e, w a) -> a) -> b)) -> b)
11:57:54 <lambdabot> -- f cannot be realized.
11:58:09 <augustss> very optimistic
11:58:18 <edwardk> augustss; =)
11:58:40 <augustss> djinn doesn't really do higher rank
11:58:53 <edwardk> augustss: was hoping to derive 'liftCallCV' for the environment comonad transformer.
11:59:25 <edwardk> in this case it probably needs rank2 types, so i'm not surprised
11:59:53 <lpsmith> @djinn (((a -> m b) -> m a) -> m a)
11:59:54 <lambdabot> -- f cannot be realized.
12:00:19 <augustss> It'd be interesting to have an improved djinn that can handle such things.  But I don't know how to make it efficient.
12:00:29 <edwardk> @djinn (((a -> m b) -> m a) -> m a) -> ((a -> r -> m b) -> r -> m a) -> r -> m a
12:00:29 <lambdabot> f a b c = a (\ d -> b (\ e _ -> d e) c)
12:00:37 <edwardk> it handles the dual case just fine =)
12:00:55 <edwardk> however the comonadic version requires fmap
12:01:46 <augustss> edwardk: you could try having an fmap of the right as the first argument
12:01:54 <augustss> of the right type
12:02:01 --- mode: monochrom set -q $~a
12:02:13 --- mode: monochrom set -o monochrom
12:02:19 <edwardk> augustss: my efficient version is to pit copumpkin against roconnor. this usually serves as both a decent parallelization strategy and nets me the benefit of exploring different portions of the search space, given that one uses coq and the other agda.
12:02:43 <edwardk> augustss: yeah, starting by hand thats where i went
12:03:10 <augustss> edwardk: did you try that with djinn too?
12:03:28 <edwardk> not yet, i just dusted off djinn about a minute ago
12:03:56 <edwardk> i'm somewhat leery because i may need all three fmaps
12:04:31 <roconnor> I still don't know what the universal property for a free monad is.
12:04:44 <tg_> freedom?
12:05:01 <edwardk> roconnor: the nlab definition didn't help you?
12:06:19 <roconnor> for some reason, no
12:07:15 <roconnor> edwardk: I didn't even see your definition in the nLab article
12:08:05 <dolio> For a category C, there's a category of monads T : C -> C, and a category of functors F : C -> C.
12:08:29 <dolio> There's a functor U that takes a monad (T, eta, mu) in the first category to T in the second category.
12:08:49 <roconnor> makes sense
12:08:54 <edwardk> then build it back up using the free adjoint to that forgetful functor
12:08:59 <dolio> That functor has a left adjoint, Free.
12:09:14 <dolio> The free monad over F : C -> C is Free F.
12:09:32 <roconnor> dolio: you lost me at left adjoint
12:10:27 <edwardk> free -| forget
12:10:30 <edwardk> http://en.wikipedia.org/wiki/Forgetful_functor
12:10:40 <roconnor> ya but I don't know what adjoints are
12:10:50 <dolio> Then you should learn about them.
12:11:08 <edwardk> an adjunction is just handy kind of isomorphism 
12:11:56 <dolio> Anyhow, one definition is that Hom(Free F, T) ~= Hom(F, Forget T).
12:12:25 <edwardk> given F : C <- D, and G : C -> D, we say F -| G : C -> D (f is left adjoint to G) if Hom_C(F a, b) ~ Hom_D(a, G b)
12:12:31 <dolio> So, monad morphisms Free F -> T are in one-to-one correspondence with natural transformations F -> T.
12:12:59 <roconnor> what is T
12:13:16 <edwardk> in haskell (,) e is left adjoint to (->) e  because ((,)e a -> b) ~ (a -> (->) e b)
12:13:24 <dolio> F is any functor in the functor category, and T is any monad in the monad category.
12:13:38 <roconnor> forall x. free f a -> m a  ~= forall x. f a -> m a
12:13:52 <roconnor> er
12:13:58 <roconnor> forall a. free f a -> m a  ~= forall a. f a -> m a
12:14:15 <dolio> Monad morphisms probably have more structure than just a natural transformation.
12:14:22 <roconnor> oh
12:14:26 <edwardk> monad morphisms have to preserve the monad structure
12:14:55 <edwardk> you need to map unit onto unit, etc.
12:15:01 * hackagebot network-bytestring 0.1.3.4 - Fast, memory-efficient, low-level networking  http://hackage.haskell.org/package/network-bytestring-0.1.3.4 (JohanTibell)
12:15:22 <dolio> Also, I didn't mention it, but the isomorphism between Hom(Free F, T) and Hom(F, Forget T) must be natural in F and T for it to be an adjunction.
12:16:08 <edwardk> dolio: that reminds me i need to pick your brain
12:16:27 <roconnor> dolio: see, I get the feeling that this long drawn out definition of Free Monad, as nice as the construction is, can be distilled down into a simple law that you guys just don't want to say out loud for fear of been eaten by a grue.
12:17:08 <edwardk> i've been playing with indexed (co)monads, and most of them seem to be given rise to by a family of adjunctions such that f_i -| g_i 
12:17:14 * grue eyes edwardk and dolio
12:17:21 <edwardk> (in fact, probably all of them)
12:17:21 * grue looks menacing
12:17:41 <edwardk> it is dark. a grue has been eaten by a grue.
12:17:46 <dolio> edwardk: I don't think that's surprising.
12:17:56 * dafis doesn't want to be eaten by a copumpkin
12:17:57 <edwardk> dolio: its not. just pleasing
12:18:33 <dolio> ddarius' mention of fibred adjunctions is also appropriate, I think.
12:18:36 <edwardk> that way: a -> g i (f i a) , and g i (f j (g j (f k a))) -> g i (f k a) follow from the adjunctions
12:18:47 <roconnor> I mean, I could, and do, say that a lens is just a monoid natural transformation from the coalgebra functiors from haskell functors to haskell types.
12:18:49 <edwardk> not sure i quite followed his intent at the time
12:19:08 <roconnor> but it is clearer to say that a lens statifies the three get/set laws
12:19:33 <roconnor> I want to know the laws for a a free monad
12:21:08 <dolio> edwardk: If you have two indexed families of categories, and an indexed family of adjunctions between them, that should be equivalent to a fibred category, and a fibred adjunction.
12:21:30 <edwardk> ah point
12:22:06 <edwardk> so i should probably be calling indexed monads fibred monads ;)
12:22:27 <dolio> roconnor: Free monads can be understood almost exactly like free monoids, too.
12:22:38 <dolio> Only, instead of monoid, you say monad, and instead of set, you say functor.
12:23:13 <dolio> So there's an inclusion F -> Free F.
12:23:34 <dolio> A unit I -> Free F.
12:23:55 <dolio> And a multiplication Free F . Free F -> Free F.
12:24:18 <dolio> That satisfies the relevant laws, and no others.
12:25:15 <dolio> edwardk: Eh. When you're working with Haskell, 'indexed' makes way more sense.
12:25:32 <edwardk> dolio: yeah i wasn't seriously advocating for the switch =)
12:25:57 <dolio> Fibers are nicer in category theory, but they require thinking backwards compared to type theory all the time.
12:27:14 <edwardk> the inverse image machinery, etc.
12:27:29 <dolio> For instance, if you have F : J -> Set, and f : I -> J, getting F' : I -> Set is 'easy' in type theory. It's just composition.
12:27:38 <dolio> With fibers it's a pullback.
12:28:08 <dolio> However, in type theory, dependent sums are kind of a fancy operation.
12:28:20 <dolio> With fibers, it's just composition.
12:28:32 <edwardk> *nods*
12:29:49 <jonkri> i have a number of records which i want to give an "id" field. this gives me some error messages saying Main.id is already defined. what are my options?
12:30:32 <lpsmith> jonkri, well,  you could  "import Prelude hiding (id)",   but I wouldn't recommend that
12:30:34 <jonkri> i can rename it of course, like ticketID etc, but then what will happen when i need like a foreign key in records to refer to a ticketID?
12:30:46 <jonkri> oh, i thought it was from my other records
12:30:48 <dafis> jonkri: a type class maybe
12:31:04 <jonkri> no problem then
12:31:15 <lpsmith> Records are something of an embarrassment in Haskell
12:31:15 <jonkri> yeah maybe
12:31:41 <lpsmith> As they are in most functional languages
12:31:42 <jonkri> no, there _is_ a conflict between records
12:31:52 <lpsmith> ahh,  my bad :)
12:32:24 <jonkri> let me show you my code so far, maybe you can give me some insight :) http://paste.pocoo.org/show/330170/
12:32:32 <jonkri> i have a long comment in the top explaining what i'm trying to do
12:32:43 <jonkri> this is one of my first haskell apps, so i'm sorry if it's a mess
12:33:35 <lpsmith> you need either   "type UUID = String"  or "newtype UUID = UUID String",  what you have is a syntax error
12:33:58 <jonkri> yeah, i just left it as a placeholder
12:34:04 <dafis> jonkri: looks like class IDable a where id :: a -> UUID might be fine
12:34:04 <jonkri> will use the other module
12:35:40 <lpsmith> jonkri,  dafis's suggestion seems quite reasonable  :)
12:36:04 <jonkri> ah :)
12:36:28 <roconnor> CotensorW t w a = w a + CotensorW t (t w) a
12:36:44 <jonkri> that's nice
12:37:00 <roconnor> FreeW t a = a + t (FreeW t) a
12:37:48 <roconnor> edwardk: do we even know enough about comonad transformers to even talk about a free construction?
12:38:10 <edwardk> roconnor: no idea. i just made them up coz they looked pretty
12:38:22 <roconnor> grue: eat edwardk
12:38:30 * grue eats roconnor 
12:38:36 <roconnor> damn it
12:38:43 <shachaf> Let's play fire-water-grue.
12:39:36 <copumpkin> (the grue was sated)
12:39:59 <copumpkin> omg a Gracenotes 
12:41:04 <Gracenotes> where D:
12:41:22 <copumpkin> in your mirror, look out!
12:41:54 <aristid> Gracenotes: run away when you see him
12:42:01 <shachaf> copumpkin: You're the grue?
12:42:19 * copumpkin whistles innocently
12:42:33 * shachaf Frotzes copumpkin.
12:43:45 <Gracenotes> I am the grue :( or, at least, one Levenshtein distance away
12:44:02 <copumpkin> Gruecenotes?
12:44:21 <Gracenotes> that's two x.x
12:44:36 <Gracenotes> in real life though, not on the internets
12:44:45 <copumpkin> oh
12:44:49 <copumpkin> yeah, I see
12:46:12 <aristid> somebody quickly @let a levenshtein distance algorithm
12:46:48 <dafis> I think we already have one on hackage
12:47:24 <b0fh_ua> Hello! Can somebody please help me with this: http://pastebin.com/jWuWxb0t
12:47:41 <Gracenotes> I know I've golfed one before
12:48:08 <aristid> @let levenshtein s t = let distance i 0 = i; distance 0 j = j; distance i j = minimum [d!!(i-1)!!j+1, d!!i!!(j-1)+1, d!!(i-1)!!(j-1) + (if s!!(i-1)==t!!(j-1) then 0 else 1)] in [[distance m n|n<-[0..length t]]|m<-[0..length s]]!!length s!!length t
12:48:09 <lambdabot>  <local>:3:82:
12:48:09 <lambdabot>      Couldn't match expected type `[a]' against inferred type ...
12:48:10 * hackagebot arrows 0.4.3.0 - Arrow classes and transformers  http://hackage.haskell.org/package/arrows-0.4.3.0 (RossPaterson)
12:48:13 <aristid> dang.
12:48:29 <olsner> aristid: wrong answer. thank you for playing.
12:48:39 <Twey> @let levenshtein sa sb = last $ foldl transform [0..length sa] sb where transform xs@(x:xs') c = scanl compute (x+1) (zip3 sa xs xs') where compute z (c', x, y) = minimum [y+1, z+1, x + fromEnum (c' /= c)]
12:48:40 <aristid> olsner: what?
12:48:41 <lambdabot>  Defined.
12:48:55 <Twey> > levenshtein "glue" "grue"
12:48:57 <lambdabot>   1
12:48:58 * mux is overjoyed after successfully writing a function of this type: interleave :: Vec n a -> Vec n a -> Vec (n :*: Two) a
12:48:59 <aristid> > levenshtein "Gracenotes" "grue"
12:49:01 <lambdabot>   8
12:49:08 <olsner> aristid: your levenshtein didn't typecheck on the first try
12:49:39 <Gracenotes> you can save a bit on the if statement by converting Bool -> Int
12:49:39 <mux> both (n :+: n) and (Two :*: n) weren't working because they weren't "matching" the recursion scheme
12:49:39 <mauke> > "levenshtein" `levenshtein` "levenstein"
12:49:41 <lambdabot>   1
12:49:46 <aristid> > levenshtein "gracenotes" "grue"
12:49:48 <lambdabot>   7
12:50:00 <dafis> b0fh_ua: are you sure that you get the correct sizes? maybe your box is big-endian?
12:50:03 <Gracenotes> > levenshtein "grue" "gruen"
12:50:05 <lambdabot>   1
12:50:20 <edwardk> mux: nice
12:50:21 <aristid> > levenshtein "grue" "gr√ºn"
12:50:23 <lambdabot>   2
12:50:25 <b0fh_ua> dafis: I'm sure
12:50:27 <aristid> > length "gr√ºn"
12:50:29 <lambdabot>   4
12:50:34 <b0fh_ua> sizes are correct
12:50:38 <mauke> > "aabbccdd" `levenshtein` "ddccbbaa"
12:50:40 <lambdabot>   8
12:50:46 <mux> edwardk: I'll have to send this one to conal if he didn't implement it already ;-)
12:50:55 <Gracenotes> levenshtein doesn't detect block movement
12:51:14 <aristid> @check \a -> a `levenshtein` reverse a == length a
12:51:16 <lambdabot>   Not in scope: `levenshtein'
12:51:23 <aristid> :(
12:51:30 <b0fh_ua> dafis: could you please try this out?
12:51:44 <aristid> > let a = "abc" in a `levenshtein` reverse a == length a
12:51:46 <lambdabot>   False
12:51:51 <olsner> put the whole definition in a let in the @check?
12:52:06 <aristid> > "abc" `levenshtein` reverse "abc"
12:52:08 <lambdabot>   2
12:52:23 <aristid> > "aaa" `levenshtein` reverse "aaa"
12:52:25 <lambdabot>   0
12:52:26 <roconnor> edwardk: my Coq has failed me.  It won't let me define FreeW.
12:52:27 <dafis> b0fh_ua: I'll need to install attoparsec and binary first (new ghc-7 not yet populated)
12:52:35 <b0fh_ua> oh
12:52:46 <aristid> roconnor: few men would admit to this kind of defeat.
12:52:47 <olsner> <roconnor> my Coq has failed me.
12:52:47 <dafis> won't be too long :)
12:52:50 <edwardk> mux: i haven't quite grasped what started conal's efforts to reinvent the vector wheel
12:53:12 <roconnor> oh I can move my parameter to the right
12:53:17 <edwardk> roconnor: clearly you just need to play with your coq some more.
12:53:28 <mux> edwardk: I dunno, but it went at the right time for me; I had looked at it from a distance previously but didn't fully grasp it previously
12:53:55 <mux> s/previously//
12:53:58 <Apocalisp> @remember roconnor My coq has failed me
12:53:58 <lambdabot> It is stored.
12:54:15 <roconnor> oops I made a mistake
12:54:16 <roconnor> now I get
12:54:24 <roconnor>  
12:54:25 <roconnor> Error: Non strictly positive occurrence of "FreeW" in
12:54:27 <roconnor>  "t (FreeW t) a -> FreeW t a".
12:54:44 <roconnor> which is fair.
12:54:51 <davekong> Are there any Haskell frameworks that are good for doing AJAX programming?
12:54:55 <roconnor> it isn't at all clear that t is monotone
12:55:16 <Igloo> Why is it "Non strictly positive" rather than "Negative"?
12:55:45 <roconnor> because strictly positive is stricter than positive.
12:56:07 <Igloo> What invalid type would Negative not exclude?
12:56:20 <roconnor> Igloo: the postiive ones that are not strictly positive
12:56:31 <Igloo> roconnor: e.g.?
12:56:37 <roconnor> pfft
12:56:41 <copumpkin> lol
12:56:59 <roconnor> I'd have to work to drum some up
12:57:15 * mux guesses he should be able to write transpose :: Vec m (Vec n a) -> Vec n (Vec m a) as well
12:57:15 <aristid> Igloo: roconnor's coq failed him, he can't give examples now
12:57:18 <roconnor> IIRC strict postiivity is a syntatic conditions that approximates positivity which is semantically defined
12:57:44 <aristid> mux: oh, interesting function
12:58:12 <jonkri> dafis: what would that IDable class do? you provide a variable of an instanced type ("a") and it returns a UUID?
12:58:46 <mux> aristid: yeah, a transpose function that gives you some insurance on what you're gonna get via its type, :-)
12:58:47 <aristid> mux: transpose = Data.Traversable.sequenceA
12:59:03 <aristid> i think
12:59:09 <mux> mm
12:59:18 <aristid> :t Data.Traversable.sequenceA
12:59:19 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
12:59:24 <jonkri> s/returns/converts it to
13:00:44 <mux> aristid: mmm, I gave it a try but as I suspected it didn't type check this way; I'll try to write it by hand first
13:01:06 <aristid> mux: you need the instances for Applicative and Traversable first :)
13:01:13 <mux> I have those already
13:01:25 <aristid> mux: then it should type check?
13:01:27 <dafis> jonkri: you call `id a' on a value whose type is an instance of IDable and get back a UUID; instances for Account, Ticket etc. are making id an alias for accountID/ticketID/...
13:01:36 <mux> Functor Foldable Applicative Traversable Monad :-P
13:01:57 <mux> aristid: oh wait, I fubar'ed
13:02:18 * aristid points finger at mux, accidentally hitting the laptop screen
13:02:38 <mux> aristid: nice, except azdding an additional IsNat constraint (due to the Applicative constraint), it actually works
13:02:50 <aristid> yay :)
13:02:59 <mux> *Data.Vec> :t transpose 
13:02:59 <mux> transpose :: IsNat n => Vec m (Vec n a) -> Vec n (Vec m a)
13:03:28 <aristid> mux: funny how it has no IsNat on m
13:03:45 <mux> I can probably get rid of the IsNat constraint if I rewrite the recursion by hand
13:03:53 * roconnor wonders if the free theorem is stronger without the constraint
13:04:01 <mux> aristid: well, I only need IsNat for Applicative, not for Traversable
13:04:10 <mux> so it's expected
13:04:41 <andres_> hello everybody
13:04:44 <jonkri> dafis: how is that beneficial from just getting the id field of the Account record?
13:05:40 <andres_> anyone has a good bibliography for explaining types of types?
13:05:56 <dafis> jonkri: so you can call the same function on Accounts and Tickets, I thought that was what you wanted
13:06:17 <jonkri> ah ok. i'm not sure what i want, but thanks :)
13:06:34 <gwern> bleh, how do newtypes go again? 'newtype MyInteger = MyInteger Integer' ?
13:07:03 <aristid> gwern: yes?
13:07:08 <gwern> coolios
13:07:11 <dskippy> What does it mean to have "Non-exhaustive patterns in record update" ?
13:07:19 <dskippy> Are there even patterns in a record update?
13:07:21 <mauke> newtype TCON [PARAMS] = DCON TYP
13:07:40 <jonkri> can you cabal install uuid? i get an "cabal: cannot configure QuickCheck-2.4.0.1. It requires ghc -any" error
13:08:25 <jonkri> i've tried cabal update
13:10:27 <djahandarie> aristid, you aren't suppose to use it with mconcat!
13:11:15 <djahandarie> You need mconcatMap. Like ((mconcat .) . map)
13:11:27 <ski> @remember roconnor I mean, I could, and do, say that a lens is just a monoid natural transformation from the coalgebra functiors from haskell functors to haskell types.
13:11:28 <lambdabot> I will never forget.
13:12:06 <djahandarie> Move the structure constraint into the hof so it doesn't need to litter the type of ala ;)
13:12:29 <jmcarthur> lambdabot's @quote database should be called the jargon file
13:12:40 <jonkri> (and yes, i can install other programs through cabal, and i have ghc installed) (fedora)
13:12:53 <aristid> djahandarie: i want a combinator that works directly with mconcat :)
13:14:09 <djahandarie> But it's less elegant that way :(
13:14:49 <ski> @type Data.Foldable.foldMap  -- djahandarie,aristid ?
13:14:50 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
13:15:16 <djahandarie> ski, yes, that's normally how I use it but aristid wants it with mconcat for some reason :(
13:15:28 <djahandarie> mconcatMap really should be in the libraries somewhere though
13:15:31 * ski wonders what "it" is
13:15:35 <djahandarie> @hackage newtype
13:15:36 <lambdabot> http://hackage.haskell.org/package/newtype
13:15:38 <taotree> How do I do opengl in WX? I see mention of a glcanvas or something but can't find doc for it anywhere
13:15:50 <ski> @hackage potzreibe
13:15:50 <lambdabot> http://hackage.haskell.org/package/potzreibe
13:16:12 <djahandarie> ...was that suppose to link to something? :P
13:16:18 <ski> nah
13:16:50 <ski> but apparently the `newtype' one did .. how curious :)
13:16:52 <dafis> $ cabal list potzreibe
13:16:52 <dafis> No matches found.
13:17:19 <gwern> @quote
13:17:19 <dafis> methinks, @hackage is lying
13:17:19 <lambdabot> nikki93 says: After a bit more delving, I've come to see the power of haskell at last. You have to treat functions like crap, forget about the C idea that they're 'big things'. They're not.
13:17:35 <gwern> dafis: @hackage is just string concatenation
13:17:38 <augur> does anyone have anything you could point me to on things like proving that [(a,b)] ~ ([a],[b]) in certain cases?
13:17:43 <ski> (oh, and it should have been "potrzebie" .. i misspelt)
13:17:57 <augur> or other data structure equivalences, or function equivalences of that sort?
13:17:58 <dafis> gwern: I figured so much
13:18:46 <roconnor> edwardk: have any classes for comonad transformer transformers?
13:20:04 <ski> (roconnor : .. have you asked for monad comonads, and comonad monads, yet ?)
13:20:07 <Palmik> Hmm, is there some sort of lifted "if" which would take m Bool as an condition?
13:20:17 <roconnor> ski: yes
13:20:39 <roconnor> ski: well, only free monad comonads
13:20:44 <ski> augur : in `([a],[b])' the lists can have different length .. so you only get a retract situation
13:21:05 <ski> Palmik : unfortunately, no
13:21:52 <augur> ski: sure, no, i know, but i mean, is there any literature on data structure equivalence? like, length as == length bs => (as,bs) ~ [(a,b) | a <- as, b <- bs]
13:22:13 <augur> and i feel there should be some literature on data structure equivalences
13:22:44 * ski isn't sure
13:22:57 <monochrom> you can just prove isomorphism
13:23:07 <monochrom> err, just bijection between two sets
13:23:20 <augur> monochrom: sure but is there a literature that investigates this more detailedly? :P
13:25:49 <roconnor> ski: data Cotensor t w a = (w :+: Cotensor t (t w) a) a is a comonad transformer transformer
13:26:20 <roconnor> ski: Cotensor :: ((*->*)->(*->*))->(*->*)->*->*
13:26:31 <roconnor> Cotensor :: ((*->*)->*->*)->(*->*)->*->*
13:26:36 <augur> roconnor: holy frak
13:26:37 <ski> *nod*
13:26:39 <ski> makes sense
13:26:43 <monochrom> weaken your requirement so you accept some kind of implication or refinement or simulation in one direction instead of equivalence. then look for "data refinement". when you do that, do not be put off by the fact that all of it is written for "imperative programming" - the "imperative programming" used is merely state transitions, there is no I/O, so it's still functional, except that nondeterminism is allowed.
13:29:39 * ski ponders CPSed data types again ..
13:30:28 <copumpkin> (* -> *) -> *
13:30:31 <monochrom> but then Bird has been doing nondeterministic functional programming all along in the Algebra of Programming.
13:31:27 <monochrom> the best functional programming is inspired by imperative programming. the best imperative programming is inspired by functional programming.
13:31:56 <ski> copumpkin : yeah .. like `data TreeCPS a k = Leaf (k a) | Branch (TreeCPS a (\l -> TreeCPS a (\r -> k (l,r))))', e.g.
13:32:31 <edwardk> ski: just use monad-ran ;)
13:32:35 <ski> copumpkin : i remember defining functions converting from `TreeCPS a Identity' to `Tree a', and vice versa
13:32:46 <djahandarie> copumpkin, I'm trying to pick this http://hpaste.org/9433/ apart and I keep on getting type errors in my head
13:32:51 <roconnor> ski: Codensity FTW
13:33:07 <ski> edwardk : no, the *type* is in (nq-)CPS. it's not type of CPSed code
13:33:14 <ski> roconnor : ^
13:33:19 <edwardk> ski: that was mostly tongue-in-cheek
13:33:44 <peoro> I'm having a lot of trouble in understanding where to put `.' when I try to write pointfree expressions. Can anybody give me some hint about how to use `.' correctly?
13:33:57 <gwern> remember, Neo, there is no IO
13:34:02 <djahandarie> copumpkin, aha, nevermind, I figured it out :P
13:34:06 <roconnor> @quote spoon
13:34:06 <lambdabot> roconnor says: error "there is no spoon" :: not Spoon
13:34:10 <gwern> peoro: just use @pl
13:34:10 <peoro> for example, why cannot I put a `.' in this expression: `( f . filter (<=p) xs )' ?
13:34:11 <roconnor> @quote spoon
13:34:12 <lambdabot> quicksilver says: I would rather saw off my own legs with a wooden spoon soaked in salt water than use lazy IO
13:34:25 <monochrom> f . (filter (<=p) xs)
13:34:40 <monochrom> your trouble seems to be more about where to put parentheses.
13:34:45 <roconnor> @quote MonadState
13:34:45 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
13:34:47 <ski> peoro : `.' combines two *functions' into a new function. `filter (<= p) xs' is not a function
13:34:47 <glguy> tibbe: You about?
13:35:12 <monochrom> err, ski is also right, (f . (filter <=p)) xs
13:35:16 <Palmik> hmm, this dod not work out :D
13:35:19 <Palmik> mTrue :: Monad m => m Bool -> Bool
13:35:20 <monochrom> yikes
13:35:20 <Palmik> mTrue x = x == (return True)
13:35:31 <monochrom> (f . (filter (<=p))) xs
13:35:34 <ski> Palmik : that's impossible
13:35:47 <Palmik> that is why it did not work out :/
13:35:53 <christopher> you'd need an eq constraint too...
13:35:55 <peoro> hum
13:36:28 <ski> Palmik : it would only work if you had `instance (Monad m,Eq a) => Eq (m a)' .. (and that would run into other problems, as well) .. but that instance can't be defined
13:36:30 <monochrom> the question is strange because "in C where do I put ';'?" is not the right question either.
13:36:32 <peoro> hmmm... ok, I'm understanding why my expression couldn't accept a `.' there
13:36:41 <tibbe> glguy: yup
13:37:00 <Palmik> ski, this seems to compile
13:37:01 <Palmik> mTrue :: (Monad m, Eq (m Bool)) => m Bool -> Bool
13:37:03 <Palmik> mTrue x = x == (return True)
13:37:04 <glguy> You maintain "network", correct?
13:37:06 <copumpkin> djahandarie: wait, did I write that?
13:37:07 <ski> peoro : perhaps you just wanted `f (filter (<= p) xs)' here, and no `.' at all ?
13:37:07 <glguy> tibbe: ^
13:37:14 <peoro> still I'm so confused... I keep trying to put `.' and then `$', if `.' didn't work...
13:37:18 <djahandarie> copumpkin, haha, apparently
13:37:20 <tibbe> glguy: I do
13:37:30 <ski> Palmik : yes .. but you can only call that for a few monads `m' .. e.g. not for `IO'
13:37:33 <glguy> tibbe: What would you think of adding some functions like these to that library? I find myself adding them to every networking project I write https://github.com/glguy/minecraft-proxy/blob/master/Proxy.hs#L560
13:37:50 <copumpkin> djahandarie: lol, now I remember it
13:37:59 <ski> peoro : don't guess, *think* :)
13:37:59 <peoro> yes ski, you're right, `(filter (<= p) xs)' is just a `[a]', so it cannot be composed with `f' using `.'
13:38:02 <glguy> and it would help to encourage people to use the getAddrInfo version of things more often and avoid hardcoding things to be IPv4 specific
13:38:07 <monochrom> in both cases the right question is "what are the stages to be chained in sequence". if you know your stages, the rest is easy. if you don't know your stages, you are not thinking clearly, and I don't know how to fix that.
13:38:25 <djahandarie> copumpkin, I was mainly looking for neat uses of reify and I came across this
13:38:29 <peoro> hmmm, ok, I'll try to think harder :)
13:38:36 <dskippy> What is the syntax for having an field of a data type be of a particular type class? Is that allowed? I want to pass a RandomGen around along with a game state.
13:38:37 <djahandarie> Except I have no idea how this is using reify :P
13:38:37 <peoro> thanks for now! ;)
13:38:39 <Palmik> ski, skiunfortunately Reader is not one of them :/
13:38:50 <tibbe> glguy: looking...
13:38:54 <ski> peoro : generally, only use `.' when you want to write a "pipeline" of functions
13:39:07 <copumpkin> djahandarie: ask edwardk for neat uses of reify :)
13:39:16 <copumpkin> he's the one who sold it to me
13:39:19 <ski> peoro : otherwise i suggest using brackets, except in a *few* cases where `$' is obviously better
13:39:23 <djahandarie> edwardk, give me all your reifys!
13:39:46 <tibbe> glguy: we have e.g. connectTo :: Hostname -> PortID -> IO Socket, does that do what you want?
13:39:53 <tibbe> glguy: or rather, why doesn't it?
13:39:56 <ski> peoro : note that you *could* write `f $ filter (<= p) xs' instead of `f (filter (<= p) xs)' .. but imho, the latter is more readable
13:40:27 <peoro> ski, you're right... It's just that currying confuses me: I find it tough to think that `(3<)' is a function taking an argument
13:40:33 <glguy> tibbe: I think that that gives a Handle
13:40:40 <peoro> but I'm sure I'll get used to it :)
13:40:43 <monochrom> in C, you would think, "first stage is set x to 0, and it is written x=0", "second stage is increase x by 1, and it is written x=x+1". if you get that far, you know to write "x=0; x=x+1"
13:40:45 <tibbe> glguy: oh, we're adding a Socket version
13:40:52 <tibbe> glguy: it's in HEAD already
13:41:03 <tibbe> glguy: in the master branch
13:41:07 <glguy> tibbe: OK, then that works. It doesn't help in the listening case, though
13:41:12 <ski> peoro : `(3<)' is the `(<)' function, where *one* argument has been provided .. since it still misses the other argument, it is a function that waits for that argument
13:41:19 <tibbe> glguy: I'm working on some bigger changes to network: proper timeout support and ByteString only
13:41:26 <Palmik> hah, finally solved the monadic if problem :D
13:41:28 <tibbe> glguy: we have listenOn too
13:41:39 <peoro> ski, yes, I know the theory, just find it difficult to think that way
13:41:39 <glguy> tibbe: listenOn is very inflexible last I looked
13:41:44 <glguy> tibbe: did you add more arguments to it?
13:41:51 <tibbe> glguy: no
13:41:54 <monochrom> in Haskell, you would think, "first stage is pick out those people who are <=p, and it is written filter (<=p)", "second stage is pass to f, and it is written f". if you get that far, you know to write "f . filter (<=p)"
13:41:55 <tibbe> glguy: but we could
13:41:56 <ski> peoro : instead of `(3 <)' you could write `\x -> 3 < x', it's the same thing
13:42:19 <tibbe> glguy: could you please file a feature request with motivation? I'm afraid I will lose track otherwise. Have too many projects on the go.
13:42:19 <ski> peoro : `(3 <)' is just a handy shorthand
13:42:27 <glguy> tibbe: OK
13:42:33 <tibbe> glguy: thanks
13:42:37 <glguy> tibbe: My other question is about lazy bytestring support on Windows
13:42:45 <glguy> is there a reason that that module is Unix Only?
13:42:56 <peoro> ok, thanks :)
13:42:56 <Palmik> is it possible to rewrite this without the do notation? I am not sure how I would bind the result to the if... http://codepad.org/5zEenKN2
13:43:01 <glguy> it seems like an unfortunate source of non-portability
13:43:06 <ski> peoro : .. *or* you could say `greaterThan3' instead, and put `where greaterThan3 x = 3 < x' at the end .. that's also the same thing
13:44:08 <tibbe> glguy: not really, it uses writev which is Unix only but we could have a less efficient version for Windows until someone implements the Windows equivalent
13:44:08 <jaj> hi, is anybody aware of an active webbrowser / webbrowser-library project on top of the webkit bindings?
13:44:09 <JR_> Hi guys, I have made a sudoku solver, but it doesnt' work how i was expecting, is anyone able to look at my code?
13:44:36 <doserj> Palmik: (liftM gtz) (eval c) >>= \cond -> if cond then ...
13:44:50 <ski> peoro : monochrom is saying that you *could* also build a pipeline `f . filter (<= p)' .. and *then* apply this pipeline to the input `xs', like : `(f . filter (<= p)) xs'
13:44:50 <Palmik> doserj, aah, right :)
13:44:54 <Palmik> doserj, thanks :)
13:45:03 <glguy> tibbe: is the less efficient version just: \sock bs -> sendMany sock  $ L.toChunks bs  ?
13:45:07 <homekevin> So I'm totally a beginner, and the implementation or reverse here seems slow (as I would expect): http://learnyouahaskell.com/recursion
13:45:23 <monochrom> notice that "x = 0; x=x+1" in C is also pointfree programming.
13:45:27 <glguy> it seems that without tha tless efficient version to fall back on the more efficient one is useless
13:45:31 <peoro> ok guys, thanks, I got your point :)
13:45:34 <tibbe> glguy: yes, sendMany just concats and sends on Windows
13:45:38 <sholmes> the guys over at ##programming said haskell is a language where everything is a call to a function
13:45:42 <sholmes> is this true?
13:45:44 <mauke> sholmes: no
13:45:48 <tibbe> glguy: we should fix that
13:45:53 <peoro> I just find it difficult to think this way, but with time and experience I'm sure I'll get used to it!
13:45:56 <tibbe> glguy: I'll make a not for it
13:46:23 <glguy> personally I don't care about Windows :) but someone tried to use one of my programs yesterday and it wouldn't compile, so now I'm curious
13:46:29 <ski> sholmes : many things are done by calling a function (e.g. loops is done that way) .. but not *everything*, now
13:46:34 <ski> s/now/no/
13:46:54 <monochrom> Palmik: (liftM gtz) (eval c) >>= \cond -> if (cond) then (eval e1) else (eval e2)
13:47:12 <sholmes> oh, well I was saying to them I had this idea of a langauge where *everything* was a function call
13:47:17 <ski> homekevin : the one with  reverse' (x:xs) = reverse' xs ++ [x]  ?
13:47:24 <homekevin> ski: K
13:47:27 <homekevin> ski: Exactly
13:47:30 <mauke> sholmes: what, even functions?
13:47:41 <homekevin> sholmes: Sounds kind of lispy
13:47:42 <Palmik> monochrom, yep, thank you :)
13:47:51 <lispy> homekevin: hmm?
13:47:52 <ski> homekevin : yes, that's the so-called "naÔve reverse" function :) it's slow (quadratic complexity), yes
13:47:55 <sholmes> even functions are function calls? Idk what you mean.
13:47:56 <glguy> tibbe: another reason that listenOn is no good is that it is IPv4 specifc
13:48:03 <homekevin> lispy: No, not you. ;)
13:48:07 <sholmes> homekevin, well the syntax won't be close to lisp
13:48:07 <tibbe> glguy: is that fixable?
13:48:16 <glguy> on most OSs making it listen on IPv6's wildcard would work for both IPv4 and IPv6
13:48:21 <lispy> homekevin: ah
13:48:40 <glguy> tibbe: I always bind to all of the addresses returned from getAddrInfo (as it returns a list)
13:48:48 <monochrom> in "x=0; x=x+1", "x=0" is the function that takes the full state as parameter, and returns the new full state which has the "x" cell set 0 but other cells the same as the parameter state.
13:48:59 <glguy> these are why the built-in listenOn doesn't work for me
13:49:01 <tibbe> glguy: and the first address might not be IPv^?
13:49:04 <ski> homekevin : in Lisps, special forms / syntax is not function calls (nor is literals, of course)
13:49:16 <sholmes> the syntax for a function call would be like this:       function foo, bar, baz.
13:49:27 <mauke> sholmes: what is 'function' there?
13:49:27 <glguy> tibbe: listenOn specifies IPv4 in the socket creation
13:49:33 <sholmes> actually:    function foo, bar, baz;
13:49:33 <homekevin> ski, and others, is there a non-naive haskell implementation of reverse, or is it done inside the implementation with non-Haskell tricks?
13:49:37 <sholmes> function is the name of the function
13:49:41 <tibbe> glguy: I'm afraid I don't have time to give this the attention it deserves at the moment. Could you please file a ticket? :)
13:49:43 <sholmes> not a keyword or operator
13:49:48 <tibbe> glguy: I see
13:49:58 <homekevin> I may be getting ahead of myself, being very new to haskell.
13:49:59 <mauke> sholmes: where do functions come from?
13:50:11 <ddarius> @src reverse
13:50:11 <lambdabot> reverse = foldl (flip (:)) []
13:50:12 <sholmes> mauke, literal expressions of the functions
13:50:12 <edwardk> homekevin: the built in reverse builds up an accumulating parameter and returns it, but thats still pure haskell
13:50:21 <ski> homekevin : there is a non-naÔve implementation yes (and it's not *that* complicated .. three or four lines)
13:50:33 <sholmes> of course, there will be literals in my language
13:50:33 <homekevin> Hm, interesting.
13:50:33 <ddarius> ski: Or a third of a line.
13:50:34 <mauke> sholmes: huh?
13:50:41 <monochrom> if you had pointful C, "x=0; x=x+1" would be the same as state = "x=x+1" ("x=0" (state)). but you are not allowed to mention the state parameter. you have to write "x=0; x=x+1". compulsory pointfree programming.
13:50:51 <copumpkin> foldl (flip (:)) []
13:50:51 <sholmes> for example, 1, "hello", 2.3, are literals right?
13:50:52 <ski> ddarius : yeah :)
13:51:00 <mauke> sholmes: how do you distinguish between f (g h) and (f g) h?
13:51:04 <sholmes> you can just write them in your code and they're data
13:51:14 <mauke> sholmes: how do you write function literals?
13:51:15 * ski was assuming an explicit-recursion definition, for learnings sake
13:51:34 <sholmes> f g h.   is    f (g h)
13:51:45 <mauke> how do you write (f g) h?
13:51:46 <sholmes> f g; h.  is the later
13:51:48 <monochrom> in haskell, "main = putChar 'x'" is not a function.
13:51:49 <ski> sholmes : in haskell, `f g h ' is `(f g) h' :)
13:51:55 <sholmes> ; is the function terminator
13:52:17 <sholmes> it says, end the current function argument list that we are in.
13:52:33 <sholmes> make sense?
13:52:38 <mauke> how do you write (a b c) d?
13:52:48 <ski> sholmes : how to write `((f g) (h i)) ((j k) (l m)), then ?
13:52:51 <mauke> hmm, that's ambiguous
13:52:53 <sholmes> a b c;; d.
13:53:13 <sholmes> two terminators to step out of the argument lists twice
13:53:15 <monochrom> I don't understand what is sholmes proposing or what is the proposal's point.
13:53:29 <sholmes> monochrom, creative thought. ;)
13:53:41 <homekevin> I may not be able to understand it yet, but can someone show me the non-naive implementation of reverse?
13:53:57 <monochrom> I guess I'll just say I welcome alternative syntaxes but please call it a different language and give it a different name etc.
13:54:03 <homekevin> (Can GHCi print it? I thought I made it print functions once...)
13:54:17 <sholmes> monochrom, of course it would have a different name. :P
13:54:51 <sholmes> was thinking of calling it blossom
13:55:25 <sholmes> now a function in blossom would be expressed with the literal {}
13:55:46 <doserj> homekevin: reverse xs = rev x [] where rev [] ys = ys; rev (x:xs) ys = rev xs (x:ys)
13:56:44 <doserj> err: reverse xs = rev x [] where rev [] ys = ys; rev (x:xs) ys = rev xs (x:ys)
13:56:51 <doserj> err: reverse xs = rev xs [] where rev [] ys = ys; rev (x:xs) ys = rev xs (x:ys)
13:57:41 <homekevin> Do semicolons just function like newlines?
13:57:54 <mauke> the other way around
13:57:57 <mauke> in some contexts
13:58:05 <homekevin> Hm, OK.
13:58:10 <sholmes> is it alright if I invoke a conversation based on the question: "What would be the ramifications of allowing functions to become operators where instead of them accepting an argument list they accept two terms, left and right?" ? 
13:58:12 <mauke> some newlines autogenerate semicolons
13:58:40 <mauke> sholmes: in Haskell, functions don't accept an argument list
13:58:53 <sholmes> mauke, what do they accept?
13:58:57 <mauke> an argument
13:59:01 <homekevin> This should be interesting.
13:59:11 <sholmes> mauke, how is that beneificial?
13:59:20 <homekevin> I haven't gotten that far yet, but I suspected that functions essentially take one argument.
13:59:29 <edwardk> sholmes: because now partial application is trivial
13:59:32 <sholmes> s/beneficial/good
13:59:37 <mauke> sholmes: simplicity
13:59:43 <edwardk> > let x = (+) 1 in x 2
13:59:44 <lambdabot>   3
13:59:46 <sholmes> edwardk, what's partial application?
13:59:55 <mauke> parameter lists are adhockery
14:00:14 <mauke> if you want lists, you know where to get them
14:00:16 <edwardk> sholmes: in haskell you can use any function as an 'operator
14:00:26 <edwardk> > [1,2,3] `zip` "abc"
14:00:27 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
14:00:42 <sholmes> mauke, how so? With a list you have more data going into the function
14:01:10 <mauke> sholmes: more than what?
14:01:10 <sholmes> edwardk, so long as you wrap the function in back-ticks?
14:01:13 <edwardk> sholmes: yes, but if you remove the ad hoc notion of k-ary functions and replace them with combinators for expressing the ways those arguments can be combined you gain expressive power
14:01:26 <sholmes> mauke, more than one parameter.
14:01:30 <homekevin> sholmes: You still effectively use "argument lists", it just functions a a series of calls, apparently
14:01:30 <mauke> no, you don't
14:01:34 <mauke> a list is a single value
14:01:43 <sholmes> a single parameter at that too
14:02:10 <sholmes> edwardk, example?
14:02:11 <edwardk> > foldl (+) 0 [1,2,3]    and a schemey/lispy (+ 1 2 3) say the same thing, but the haskell version tells you what order the + is being applied in
14:02:13 <lambdabot>   <no location info>: parse error on input `,'
14:02:51 <edwardk> we offer sum, but it is a distinct function from (+), and takes a list explicitly, 
14:02:59 <sholmes> edwardk, I'm sure it's more flexible, but seems like it's extra language ability that I'm not sure is necessary.
14:03:02 <edwardk> (because its a common enough operation)
14:03:23 <edwardk> sholmes: trust me, when you get to monads, having the ability to partially apply a function is critical for readability
14:03:35 <edwardk> scala _doesn't_ have it, and its painful
14:03:45 <mauke> sholmes: write a function g such that f(...) is equivalent to f(h(...)) for all functions f
14:03:49 <mauke> wat
14:03:56 <mauke> equivalent to f(g(...))
14:04:01 <lispy> edwardk: wait, I thought in Haskell all functions take just 1 argument? ;)
14:04:14 <edwardk> lispy: troll =P
14:04:18 <lispy> So what does it mean to partially apply a function??
14:04:43 <tromp_> @let add5 =(+ 5)
14:04:44 <lambdabot>  Defined.
14:04:52 <sholmes> :S
14:04:56 <edwardk> instead of writing functions that take multiple arguments you write functions that take one argument‚Ä¶. and return a new function to accept the remainder.
14:05:17 <tromp_> @let add3 =(+) 3
14:05:18 <lambdabot>  Defined.
14:05:35 <edwardk> :t \ a b c -> a + b * (12 :: Int) - c
14:05:37 <lambdabot> Int -> Int -> Int -> Int
14:05:49 <edwardk> that is Int -> (Int -> (Int -> Int))
14:05:53 <aristid> edwardk: i think this is the real source of the "everything is a function" confusion, btw
14:06:03 <lispy> > let lispyAdder a = \b -> a + b in 1 `lispyAddr` 2
14:06:04 <lambdabot>   Not in scope: `lispyAddr'
14:06:14 <lispy> > let lispyAdder a = \b -> a + b in 1 `lispyAdder` 2
14:06:15 <lambdabot>   3
14:06:18 <edwardk> we have pairs, etc. but they aren't used for arguments typically
14:06:20 <sholmes> edwardk, how can you have that function return something other than the value to be added to again?
14:07:04 <sholmes> maybe haskell is just built for a very different environment then where I'm coming from. :\
14:07:07 <edwardk> sholmes: you would typically take the primitive function defined above, and then use it with some other traversal
14:07:21 <edwardk> :t foldr
14:07:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:07:28 <edwardk> :t foldr (+) 0
14:07:30 <lambdabot> forall a. (Num a) => [a] -> a
14:07:35 <andres_> anyone could tell if this is a type of types "data Shape = Circle Float Float Float | Rectangle Float Float Float Float    5:20 surface :: Shape -> Float   5:21 surface (Circle _ _ r) = pi * r ^ 2 "
14:07:53 <edwardk> :t foldr (+) 0 [a,b,c,d,e,f]
14:07:54 <lambdabot> Expr
14:07:55 <edwardk> er
14:07:55 <sholmes> but then you're always traversing after, what if you want to be able to do something with the return value of a functio while still having the ability to pass in multiple arguments?
14:08:07 <edwardk> > foldr (+) 0 [a,b,c,d,e,f]
14:08:08 <lambdabot>   a + (b + (c + (d + (e + (f + 0)))))
14:08:12 <mauke> to answer my question above: sub g { @_ }
14:08:17 <edwardk> > foldl (+) 0 [a,b,c,d,e,f]
14:08:19 <lambdabot>   0 + a + b + c + d + e + f
14:08:41 <aristid> hear hear, Expr is left-biased
14:08:41 <edwardk> you would pass those arguments as a list
14:09:10 <edwardk> you can write
14:09:11 <ddarius> lispy: I gave a proposed formal definition of partial application on LtU a bit back.
14:09:13 <edwardk> > sum [1,2]
14:09:14 <lambdabot>   3
14:09:20 <edwardk> instead of 1 + 2 if you want to
14:09:26 <edwardk> but its kinda silly
14:09:34 <sholmes> in my language idea, you wouldn't need to learn to much to understand the fundamentals, but the fundamentals will still be powerful
14:09:38 <edwardk> (and does more work)
14:09:43 <jonkri> what is this i hear that lgpl libraries basically have the same restrictions as if they were gpl licensed when working with ghc?
14:09:50 <monochrom> andres_: it is not a type of types.
14:09:59 <edwardk> i find that the combinator idea goes much farther than the lisp/scheme variadic function model in practice
14:10:01 <ddarius> Admittedly, the distinction between application and partial application is almost non-existant.
14:10:03 <aristid> conal: is your nick change an indication that you're here?
14:10:07 <lispy> jonkri: That's because ghc does cross-module inlining
14:10:29 <edwardk> higher order functions compose much more nicely when you can curry to avoid passing arguments that you are just going to pass throuhg
14:10:31 <conal> aristid: nick change?
14:10:32 <edwardk> in this model when you have
14:10:32 <lispy> jonkri: So that restriction only applies to compiled code
14:10:38 <aristid> conal: conal_ -> conal
14:10:43 <sholmes> how is passing an array/list (or whatever they are called in haskell) any more ad hockey than having argument lists built into the language?
14:10:44 <edwardk> f a b c d = g (big complicated expression) b c d
14:10:55 <edwardk> you can rewrite that down to f a = g (big complicated expression)
14:11:05 <conal> aristid: hm. maybe flakiness of my internet connection
14:11:12 <lispy> jonkri: If you distribute in source it wouldn't apply.  The safest license to use for haskell libs is BSD3, IMO
14:11:13 <edwardk> with the lisp/scheme model you are ALWAYS stuck plumbing those extra arguments
14:11:40 <mauke> sholmes: it isn't
14:11:44 <edwardk> which means that every combinator that you have that lifts functions always has to be able to handle them, so you wind up either creating a dozen ad hoc versions of every combinator or you give up and think first order thoughts
14:12:02 <sholmes> mauke, then why would ad hockey be a bad thing, or why is it considered ad hoc at all?
14:12:04 <jonkri> lispy: thanks. i just realized that the xml library i was going to use is lgpl... :(
14:12:12 <mauke> sholmes: you've lost me
14:12:15 <jonkri> haxml
14:12:32 <ddarius> mauke: Best to stay there.
14:12:40 <sholmes> mauke, why not just have argument lists built into the language?
14:12:43 <aristid> conal: anyway. i think the "real" reason why people think that "everything is a function" is that they think of all functions in an uncurried way. so that (+) is a function of two arguments instead of a function returning a function. non-functions are just at an extreme end of that series :) 
14:12:46 <dafis> @tell b0fh_ua I've found the problem. The parsecLogParser in "many1 parsecLogParser" doesn't fail, so it returns a partial result, waiting for additional input. To tell it that there won't come any more, you can run it with parseWith (return S.empty) instead of parse or you can (parse parser input `feed` S.empty). Probably there are other ways, but those two are the ones I saw.
14:12:46 <lambdabot> Consider it noted.
14:12:58 <edwardk> sholmes: the notion of an argument list comes at a cost. that cost is the ability to curry and partially apply, the latter bits of functionality are more important in a world where you compose functions
14:13:28 <edwardk> you can force them into the language, scheme has apply, etc. but its not the common idiom, and it is a high syntactic price to pay
14:13:33 <conal> aristid: makes sense to me as one reason.
14:13:36 <homekevin> doserj: Thanks for that reverse implementation. I got distracted and only just looked at it. Very interesting.
14:13:38 <sholmes> currying is definitely possible in a language with arg lists
14:13:53 <hpc> currying in perl is an entertaining endeavour
14:13:54 * ddarius has no problem calling () -> A a function.
14:14:02 <edwardk> sholmes: it is. its also a pain in the ass to use
14:14:05 <sholmes> func 1, 2, 3; 1, 2, 3.
14:14:10 <lispy> jonkri: a discussion about which xml library to use came up the other day at lunch, and someone told me to use hxt.  I see that hxt has an MIT license (should be BSD3 compatible)
14:14:11 <aristid> ddarius: that's because it is one
14:14:32 <sholmes> edwardk, which actually why I started thinking about blossom
14:14:35 <ddarius> aristid: That's the "extreme end" of that series.
14:14:36 <sholmes> ...my language idea
14:14:50 <sholmes> because (1,2,3)(1,2,3) is definitely a pain.
14:14:51 <lispy> jonkri: http://www.fh-wedel.de/~si/HXmlToolbox/index.html
14:14:55 <aristid> ddarius: i didn't mean it that way. i meant the curried series.
14:15:02 <sholmes> but 1, 2, 3; 1, 2, 3; is much easier to type
14:15:28 <aristid> ddarius: curried but mistakenly seen as if they were uncurried.
14:15:34 <jonkri> lispy: i'm not sure hxt is a good choice for me. i need something that can parse an xml stream, "event-based". i see that network-protocol-xmpp is using libxml-sax though
14:15:40 <conal> ddarius: aristid is suggesting a different series: ... c -> b -> a, b -> a, a
14:16:03 <lispy> jonkri: oh, I see.  Well, you might be able to fake it with tagsoup, but I'm not sure.
14:16:14 <lispy> jonkri: probably best to use libxml-sax though
14:16:15 <aristid> jonkri: xml-enumerator maybe?
14:16:22 <edwardk> sholmes: personally i'm more worried to keep function application minimalist from a syntactic perspective. haskell does a very good job of just letting f a b c be application, with that, f a b c $ d e f ‚Äî is (((f a) b) c) ((d e) f)
14:16:31 <sholmes> with these argument lists, we can also use them for a lot of the language's syntax, given that we have labeled arguments!
14:16:53 <edwardk> labeled arguments and currying also don't get along very nicely ;)
14:17:14 <sholmes> edwardk, how so?
14:17:31 <sholmes> func foo: 1, bar: 2; foo: 1, bar: 2.
14:17:43 <jonkri> aristid: ah, that one also uses xml-types :)
14:18:02 <sholmes> labeled arguments in blossom are cake
14:18:02 <edwardk> lets take a straw man language with optional arguments and currying. x = func foo: 1 ‚Äî could be partial application that i want to extend later with y = x bar: 2
14:18:25 <edwardk> they also have to be entirely specified at the call site
14:18:27 <conal> so maybe a fine answer to "is everything a function in haskell?" is "yes, though not really."
14:18:36 <edwardk> or they require syntac to delimit the actual call
14:18:47 <edwardk> er syntax
14:18:59 <ddarius> conal: I don't see why we'd say "yes" at all.
14:19:08 <aristid> conal: no, that's a non-answer :)
14:19:38 <edwardk> conal: thats a very er‚Ä¶ non-confrontational response =)
14:19:39 <conal> it's an answer that acknowledges two perspectives -- one precise and the other imprecise.
14:19:49 <sholmes> edwardk, not so, in blossom all there is no limit to what labels you can pass to functions. As long as the function uses the labels.
14:20:02 <sholmes> maybe I didn't understand what you meant though, edwardk.
14:20:22 <jonkri> lispy, aristid: so basically i need to evaluate hxt, libxml-sax and xml-enumerator :) thanks! any ideas on this?
14:20:32 <tolkad> whenever I want to do any type level meta-programming in haskell I have to use these horrible hacks. is there any way around this?
14:20:35 <conal> i'm finding that people who say everything is a function are often coming from imprecise thinking. the kind we use when we talk about "two argument functions".
14:20:36 <jonkri> lispy: why did you think libxml-sax was better suited than hxt?
14:20:47 <edwardk> sholmes: very likely. what i was saying is that in a language that admits currying, ideally one would be able to partially apply functions to some of its optional arguments, yielding another partial function that can accept any subset of the remainder
14:21:02 <lispy> jonkri: You said you need a sax style parser, right?  So that's why I thought libxml-sax might be best.
14:21:14 <conal> if i say "yes, though not really", then the asker can decide whether they want to think more precisely or not.
14:21:14 <aristid> jonkri: there are even more options, in fact :)
14:21:14 <ddarius> conal: Isn't there always a (distinct) imprecise perspective?
14:21:19 <sholmes> what do you mean by "partially apply functions to"?
14:21:26 <conal> ddarius: not just one.
14:21:36 <tolkad> by type level meta-programming I mean having a library automatically selecting the most useful type for some particular purpose
14:21:47 <tolkad> or most efficient, or whatever
14:22:04 <ddarius> conal: My statement didn't restrict to there being just one.
14:22:18 <sholmes> edwardk: could you give me an example of what you mean in the syntax of blossom?
14:22:30 <edwardk> sholmes: consider a function foo that takes two optional parameters x and y. you might define that  foo ‚Äîx 12 ‚Äîy "Hello" is application with named parameters
14:22:32 <conal> imprecise thinking gets on my nerves. i'd like to find ways to respond that are honest and yet don't impose my style of thinking on others. thus the thought experiment.
14:22:51 <edwardk> i have no idea what the syntax of blossom is. i'm trying to explain how it is a problem in the context of currying, which your language lacks
14:23:11 <ddarius> Currying isn't something a higher-order language can lack.
14:23:20 <jonkri> aristid: i need a permissive license, and i like the idea of a general xml data types package like xml-types, but maybe that shouldn't make that much of a difference :P
14:23:41 <edwardk> ddarius: ok, he has primitive argument lists, at the cost of cheap syntactic currying =P
14:23:43 <jonkri> anyway, thanks a lot for your guidance :)
14:23:56 <lispy> jonkri: Can you talk a bit more about your requirements for the xml library?
14:23:56 <sholmes> edwardk: if I understand correctly, currying is the ability to make a call on the function x that a function y returns immediately after you call y?
14:24:06 <monochrom> "is everything in haskell a function" is like "is everyone in #haskell a human"
14:24:19 <tolkad> sholmes: what?
14:24:21 <fryguybob> @botsnack
14:24:21 <lambdabot> :)
14:24:23 <companion_cube> which is false
14:24:33 <jmcarthur> conal: could always just concede explicitly in order to move on to more productive conversation, e.g. "let"
14:24:35 <jmcarthur> oops
14:24:40 <ddarius> conal: Then rather than being waffly and vague (and imprecise yourself.)  Why not be upfront about what you think: "I feel that you are taking an imprecise view, and that there is a more precise and elucidating view."
14:24:45 <tolkad> sholmes: currying is transforming a function which takes multiple arguments into a function returning a function, returning a function etc.
14:24:45 <edwardk> sholmes: f takes two optional named arguments, and in this fantasy language, you can pass them in the form ‚Äîargname 
14:24:57 <monochrom> most of the time you work with functions in haskell or talk to humans in #haskell, sure. most of the time. just most of the time.
14:25:04 <aristid> conal: can you personally avoid imprecise thinking?
14:25:07 <jmcarthur> conal: could always just concede explicitly in order to move on to more productive conversation, e.g. "i disagree, but let's just roll with it for now"
14:25:07 <lispy> jonkri: as I understand so far, you need a stream based parser (basically O(1) memory), and it needs to be compatible with BSD license-wise.
14:25:09 <sholmes> tolkad: y returns x which is a function. currying is being able to call x after you call y in the same statement.
14:25:11 <jonkri> lispy: i'd be happy to... :) but the truth is that i don't really know that much about haskell yet so i'm not really sure. my current goal is to implement xmpp core as defined in http://xmpp.org/rfcs/rfc3920.html
14:25:11 <edwardk> sholmes: actually let me reparse your sentence
14:25:18 <edwardk> sholmes: yes
14:25:25 <monochrom> but anyway just answer "no", give a counterexample, and move on.
14:25:37 <edwardk> @type curry
14:25:38 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:26:07 <lispy> jonkri: hmm...I see.
14:26:07 <edwardk> curry there takes a function of two arguments, and returns a function that accepts the first argument, which in turn takes the second argument 
14:26:11 <tolkad> sholmes: like ¬´¬†f (a, b, c, ..n) = ‚Ä¶ ¬ª to  ¬´ f a = \a -> \b -> \c -> ‚Ä¶ -> \n -> ‚Ä¶ ¬ª
14:26:28 <monochrom> their imprecise thinking can be treated by you taking their questions literally and answering logically.
14:26:32 <jonkri> lispy: i will either make my own library or extend/fork http://hackage.haskell.org/package/haskell-xmpp-1.0
14:26:54 <edwardk> > let f (x,y) = x + y in ( f(1,2),  curry f 1 2)
14:26:55 <lambdabot>   (3,3)
14:27:04 <tolkad> sholmes: did that make sense?
14:27:13 <jonkri> network-protocol-xmpp does pretty much exactly what i want, but unfortunately it's gpl
14:27:16 <sholmes> edwardk, tolkad: why couldn't the language have both currying and multiple arguments?
14:27:21 <tolkad> sholmes: it does
14:27:24 <conal> jmcarthur: i'm rarely satisfied with the agree/disagree paradigm. looking for something more integrative.
14:27:29 <tolkad> sholmes: haskell has function which take tuples as arguments
14:27:30 <sholmes> mutliple arguments for a single call I mean***
14:27:39 <lispy> jonkri: Ah!  So you're forced to re-implement due to license choice.  That's unfortunate.
14:27:44 <edwardk> f is a function that takes a pair as its argument, and adds the halves of the pair to gether, you can apply the function directly to a pair. and you can curry it, currying it, allows you to apply the partially applied result multiple times if you choose
14:27:51 <jmcarthur> i think the main problem isn't imprecise thinking but, instead, a common stubbornness about the true value of precision. i may personally think it's quite valuable, but i'm not going to convince anybody else of the fact by insisting on precision in a particular instance. perhaps better to address the source of the conflict head on
14:28:07 <edwardk> sholmes: because who gets the argument? the function? or the result? if the function returns a function?
14:28:11 <tolkad> sholmes: taking a tuple as an argument is effectively equivalent to having the function take multiple arguments
14:28:13 <sholmes> tolkad, but with tuples we're talking about the same syntax as C like languages
14:28:26 <edwardk> so you wind up with some kind of syntactic delimiter saying you're done with the argument list
14:28:29 <jonkri> yeah...
14:28:30 <edwardk> in scheme these are (...)'s
14:28:45 <tolkad> sholmes: so?
14:28:48 <tolkad> sholmes: it's just syntax
14:28:53 <sholmes> edwardk, if we had a function terminator such as ; we could explicitly state who gets what
14:29:02 <tolkad> sholmes: why not just use tuples?
14:29:03 <jmcarthur> the thing is that some people see it as mere pedantry
14:29:08 <sholmes> tolkad, syntax is what my language is about
14:29:33 <conal> jmcarthur: if an approach that doesn't involve opinions, i'm interested.
14:29:46 <sholmes> tolkad, tuples use paranthesis, which are kind of painful to type (hardly, but more so then ;)
14:30:06 <mrd> rebind your keys then
14:30:12 <edwardk> sholmes: the point is that f a b c d is perfectly unambiguous in the absence of such chicanery. ;)
14:30:22 <tolkad> sholmes: yeah seriously this isn't an issue
14:31:02 <edwardk> sholmes: anyways you _can_ build currying macros for scheme-like languages
14:31:03 <sholmes> Maybe not an issue, but an idea for another langauge.
14:31:05 * ddarius doesn't know why one would bother with argument lists when one could have argument directed cyclic graphs.
14:31:15 <edwardk> ddarius =P
14:31:19 <jonkri> lispy: i like the gpl, and the free software foundation, but right now i cannot afford to leave out the dual license business model for my project
14:31:32 <edwardk> argument species!
14:31:33 <sholmes> what does f a b c d mean in haskell?
14:31:45 * tolkad doesn't know why anyone would bother with argument lists when one could have a tree of combinators
14:31:46 <mauke> (((f a) b) c) d
14:31:48 <edwardk> ((((f a) b) c) d)
14:31:49 <ddarius> edwardk: I would have to say, a language that made good use of that would be interesting (and probably horrible, but interesting.)
14:31:52 <jonkri> mauke: you beat me to it :P
14:31:53 <jmcarthur> conal: well... is this a matter of opinion? that may be a good thing to get out of the way
14:32:11 <sholmes> in blossom it's as simple as f a; b; c; d.
14:32:15 <jmcarthur> the matter of precision vs. imprecision, that is
14:32:21 <edwardk> thats 3 more symbols ;)
14:32:23 <mauke> sholmes: why so much typing?
14:32:29 <lispy> jonkri: I wish we could get more Haskell folks to go with BSD3.  Using one license consistently in the community saves time.  OTOH, I can understand why some people prefer lgpl/gpl.
14:32:48 <tolkad> jonkri: you can sell GPL software
14:32:51 <sholmes> mauke, f a; b; c; d is hardly much more typing.
14:32:59 <mauke> sholmes: it totally is
14:33:05 <mauke> sholmes: does blossom have functions without arguments?
14:33:09 <c_wraith> sholmes: why is it irregular syntax?
14:33:09 <jonkri> tolkad: i'm fully aware of that :)
14:33:10 <sholmes> no show me f(a(b(c(d()))) in haskell?
14:33:18 <edwardk> sholmes: every little bit counts ;) plus the issue comes about when you start considering how you partially apply that funtion
14:33:26 <mauke> sholmes: f . a . b . c . d $ ()
14:33:30 <edwardk> say you have f that expects 4 arguments, how do i apply it to the first 2?
14:33:31 <tolkad> jonkri: Why can you not afford to use the GPL then?
14:33:33 <newsham> f $ a $ b $ c 
14:33:35 <conal> jmcarthur: e.g. in "i think it's valuable", i hear an opinion. if instead one expressed clearly what value to them, then we're more into what we know. i often find that arguments dissolve with this sort of shift. and i learn more.
14:33:36 <newsham> d
14:33:36 <sholmes> mauke, why so much typing?
14:33:53 <edwardk> f.a.b.c$d
14:33:57 <mauke> sholmes: do you have a shorter notation for function composition?
14:34:00 <sholmes> in blossom, it's:    f a b c d.
14:34:02 <edwardk> you don't even write the () because its pointless with laziness
14:34:17 <mauke> sholmes: what if you don't want to call it yet?
14:34:20 <jonkri> tolkad: because sometimes it's more profitable to go with a free gpl + commercial prioprietary license model. i'm not saying i'm going to do it, but i want it as an option
14:34:26 <mauke> sholmes: just build the composition
14:34:43 <jonkri> or commercial gpl + commercial proprietary whatever...
14:34:55 <sholmes> in haskell, you can compose a chain of funciton calls to be called later?
14:35:02 <mauke> of course
14:35:05 <Zao> sholmes: Sure.
14:35:08 <mauke> that's a very basic thing
14:35:13 <sholmes> didn't know that
14:35:15 <sholmes> useful
14:35:16 <edwardk> sholmes: in haskell we're lazy by default, so everything is something to do later
14:35:18 <mauke> @src (.)
14:35:19 <lambdabot> (f . g) x = f (g x)
14:35:19 <lambdabot> NB: In lambdabot,  (.) = fmap
14:35:23 <sholmes> but in my language you could just compose a function for that
14:35:25 <mauke> laziness is unrelated
14:35:28 <edwardk> sholmes: its only when you look at the answer that it does anything
14:35:28 <Zao> @type (*2) . (+3)
14:35:28 <lambdabot> forall a. (Num a) => a -> a
14:35:37 <edwardk> mauke: its relevant to the d () in his example
14:35:50 <edwardk> > take 3 [1..]
14:35:51 <mauke> <mauke> sholmes: does blossom have functions without arguments?
14:35:51 <lambdabot>   [1,2,3]
14:35:51 <Zao> let f = (*2) . (+3) in map f [42, 3]
14:35:54 <Zao> > let f = (*2) . (+3) in map f [42, 3]
14:35:56 <lambdabot>   [90,12]
14:36:10 <sholmes> hang on one second, phone call
14:38:21 <jmcarthur> conal: i just mean that it's tough to rely on precision in order to make a case for precision, and the conversation tends to devolve into opinion in the long run. listeners won't necessarily appreciate strong, precise arguments. it's kind of like using logic to argue for the value of logic, or using the bible to argue for the infallibility of the bible.
14:39:20 <tolkad> jonkri: you should know that RMS has mixed feelings on the selling of exceptions: http://www.gnu.org/philosophy/selling-exceptions.html
14:39:36 <conal> jmcarthur: ah
14:39:38 <lispy> jmcarthur: Maybe we should use the bible to argue for the value of logic :)
14:39:51 <conal> jmcarthur: begs the question
14:40:13 <jmcarthur> right
14:40:14 <pastorn> conal: blog-o-mania?
14:40:39 <dafis> preflex: seen bos
14:40:39 <preflex>  bos was last seen on #haskell 2 days, 23 hours, 1 minute and 54 seconds ago, saying: ivanm: no
14:40:39 <jmcarthur> lispy: eek! how many people could we stir to anger that way? ;)
14:40:41 <pastorn> conal: nice going! 4 out of the top 25 on reddit :)
14:40:45 <ddarius> Why would you use precision to make a case for precision?  I would use better understanding, more correctness, easier to check.
14:40:48 <conal> pastorn: yep. two more in the pipe. and then comes deriving imperative data-parallel algorithms.
14:40:57 <conal> pastorn: oh, wow. :)
14:40:58 <jmcarthur> pastorn: surely you mean out of the subreddits you are following
14:41:05 <monochrom> when a particular imprecision hurts, use that imprecision to derive non-sense. this forces the participants to refine.
14:41:06 <pastorn> conal: hurry! you may be able to get all six on the front page
14:41:10 <jmcarthur> or even just /r/haskell?
14:41:14 <pastorn> jmcarthur: there is only one reddit
14:41:17 <jmcarthur> lol
14:41:18 <pastorn> haskell.reddit.com
14:41:18 <ddarius> monochrom: Exactly.
14:41:33 <pastorn> jmcarthur: wait... there's more?
14:41:59 <jmcarthur> monochrom: i've had that backfire before.
14:42:03 <sholmes> back
14:42:09 <ddarius> monochrom: I was thinking earlier when jmcarthur said "'I disagree, but let's roll with it'," that if you can "roll with it" it must not really matter, if it matters then you can't "roll with it."
14:42:09 <sholmes> where were we?
14:42:15 <JMR3> I'm trying out this tryhaskell.org tutorial.. First time seeing Haskell.. Pretty cool stuff
14:42:24 <ddarius> Unless your purpose is to roll into falsum.
14:42:29 <jmcarthur> monochrom: i derived nonsense and then they found it perfectly acceptable :\
14:42:52 <sholmes> mauke: yes blossom has functions without arguments, but I'm not sure how the syntax would be for calling them.
14:42:58 <ddarius> jmcarthur: Then you should have derived nonsense that implied them giving you large sums of money.
14:43:10 <jmcarthur> ddarius: oh how i wish i was so skilled
14:43:11 <mauke> achievement unlocked: syntactic ambiguity
14:43:31 <monochrom> derive more extreme non-sense or (admit failure as in admit that "they" are not worth saving)
14:43:32 <sholmes> in blossom you can just create define a function that will call your chain of functions for later.
14:43:32 <dafis> @tell b0fh_ua I think that's also what caused the "skipWhile (== 0)" trouble
14:43:32 <edwardk> sholmes: so do we. you just tell them apart from values, because everything looks liek that
14:43:33 <lambdabot> Consider it noted.
14:43:38 <jonkri> tolkad: thanks for the link
14:43:45 <jonkri> i'm off to bed guys... good night!
14:43:54 <edwardk> f = g . h     chains functions together
14:43:59 <sholmes> edwardk, tell what apart from values?
14:44:07 <edwardk> functions with no arguments
14:44:15 <mauke> edwardk: missing "not"?
14:44:24 <revenantphx> Anyone in here a graphics card genius?
14:44:25 <mauke> achievement unlocked: semantic ambiguity
14:44:27 <edwardk> an Int in haskell is a promise to compute an Int when asked
14:44:31 <revenantphx> probably barking up the wrong tree.
14:44:32 <sholmes> define f, {g h}. does the same thing
14:44:45 <edwardk> mauke: yeah
14:44:48 <jmcarthur> revenantphx: you want a graphics card genius? not an opengl genius or something?
14:44:50 <tolkad> revenantphx: I have a graphics card
14:44:56 <revenantphx> Haskell is as much about promises as category theory is about archery...
14:44:57 <mauke> sholmes: where's the argument list?
14:45:05 <ddarius> sholmes: Why is that not g(h)?
14:45:12 <edwardk> sholmes how do you apply some of the arguments to shose functions in the process?
14:45:23 <ddarius> @google quiver "category theory"
14:45:24 <lambdabot> http://en.wikipedia.org/wiki/Quiver_(mathematics)
14:45:25 <lambdabot> Title: Quiver (mathematics) - Wikipedia, the free encyclopedia
14:45:25 <edwardk> sholmes: f = (+1) . (*2)
14:45:26 <sholmes> ddaruis, because g h is how you call functions
14:45:41 <mauke> sholmes: g h. is g(h)
14:45:44 <sholmes> mauke: the argument list for defined functions is none.
14:45:50 <mauke> huh?
14:45:52 <tolkad> is there any way to do meta-programming in haskell without horrible type-level hacks?
14:46:02 <ddarius> tolkad: Yes.
14:46:03 <jmcarthur> revenantphx: not that i am either of those, but i at least know more about the latter than the former
14:46:09 <sholmes> edwardk, all arguments are handled by an arg variable
14:46:09 <mauke> tolkad: output haskell code
14:46:25 <mauke> sholmes: how do you refer to outer arg variables?
14:46:31 <sholmes> it's sort of like an array like object, hash, thing.
14:46:32 <gwern> tolkad: template haskell?
14:46:35 <edwardk> sholmes: so to partially apply addition and multiplication there i have so muck with some list
14:46:36 <edwardk> ?
14:47:00 <revenantphx> I need a gfx card genuis, but nevermind
14:47:12 <tolkad> ddarius: thanks for the quick answer!
14:47:12 <sholmes> mauke, you can define variables to hold the args in the outside scope, then use them inside the inner scope
14:47:18 <edwardk> > let f = (+1). (*2) in f 12
14:47:20 <lambdabot>   25
14:47:26 <mauke> consider „Äå{ { X } } 42.„Äç - what do I use instead of X to get 42?
14:47:32 <monochrom> There was once an OOP fanatic here for a few minutes. I argued with him/her over syntax. I said "so you really think that a+b+c is worse than a.add(b.add(c))?" He/She said yes. At this point you have to just write it off (I did). Though this is not about imprecision, it is about how much nonsense people can fanatically insist on.
14:47:40 <mauke> sholmes: that's what perl does, and it's very lame
14:47:46 <edwardk> sholmes: but i don't care about those variables, why would i give them names? what if my function takes 15 more arguments?
14:47:51 <sholmes> args foo, bar.  { foo and bar are available here }
14:48:13 <mrd> monochrom: was she aware of smalltalk?
14:48:23 <monochrom> I don't know.
14:48:32 <mauke> sholmes: how do you define a function with a variable number of arguments?
14:48:34 <sholmes> edwardk: you bring up good points, which is why I'm here to begin with.
14:48:37 <tolkad> sholmes: why don't you use lambda calculus syntax?
14:48:40 <ddarius> mrd: Smalltalk would be a good example of a.add(b) being better syntax...
14:48:40 <edwardk> sholmes: anyways, my point is really that the design decision doesn't come down clearly in favor of having argument lists in your language and that they come at a cost.
14:48:43 <monochrom> Probably more accurately a Java fanatic rather than an OOP fanatic.
14:48:43 <mrd> yea
14:48:50 <mrd> since it is not commutative
14:49:01 <edwardk> its a perfectly reasonable stance for a language to take that they want to incur those costs.
14:49:07 <mrd> or rather, it doesnt follow operator precedence
14:49:11 <ddarius> mrd: Exactly.
14:49:15 <edwardk> i just prefer to live in a world where i don't pay it
14:49:20 <lispy> ?quote envalue
14:49:20 <lambdabot> lispy says: a := new Maybe(); a.envalue(1);
14:49:35 <mrd> monochrom: yea most OOP fanatics have worlds beginning with Java and ending with C++
14:49:42 <sholmes> Scrope is definately something knew I need to put a lot of thought into for my language, and haven't gotten around to it.
14:49:43 <mux>     Could not deduce ((n1 :+: n) ~ (n :+: n1))
14:49:55 <monochrom> well of course if + is not associative, I would not promote writing a+b+c.
14:50:02 <edwardk> mauke: i would consider that the thing they spend the most time fighting with in perl and javascript in terms of performance _is_ the argument list.
14:50:05 * mux hates to see his compiler telling him he doesn't know addition is associative :-)
14:50:18 <ddarius> monochrom: (+) isn't associative in Haskell.
14:50:20 <edwardk> it is the bane of those respective language designers with respect to how fast they can make their code run ;)
14:50:22 <sholmes> What if functions had a outer variable that references the outer scope
14:50:25 <ddarius> Semantically.
14:50:28 <mauke> edwardk: sounds unlikely
14:50:29 <mrd> fp
14:50:34 <conal> New blog post: http://conal.net/blog/posts/a-trie-for-length-typed-vectors/
14:50:45 <mux> whoa, I managed to butt in at the exact time people were talking about associativity of (+)
14:50:51 <tolkad> ddarius: you mean because there's no rule that is has to be? or because floats aren't?
14:50:53 <edwardk> mauke: the arg list? it came up in a talk by brendan eich recently
14:50:55 <mux> conal: hi there!
14:51:16 <edwardk> mauke: and wall will never admit it was a mistake but perl 6 is sure doing what it can to abolish it ;)
14:51:17 <conal> hi mux! i've been enjoying your comments & code. looks like you're having a good time.
14:51:28 <mux> conal: yeah, this stuff is really cool
14:51:31 <mauke> edwardk: yeah, but other things are so much slower in perl
14:51:36 <tolkad> conal has a beard
14:51:44 <edwardk> mauke: this is why javascript is picking up rest args, and perl 6 explicit arguments
14:51:51 <mux> conal: I think I'm hitting the walls where I need real dependent typing and that makes me understand it better
14:51:58 <edwardk> the rest args were explicitly to kill the magic argument array
14:51:59 <mauke> edwardk: method lookup alone ...
14:52:07 <sholmes> edwardk, how does haskell handle variable scope like this?
14:52:18 <edwardk> mauke: not so bad because method lookup can often be memoized away to an inch of its live
14:52:29 <conal> mux: awesome. i'd love to hear about it. do you blog?
14:52:37 <edwardk> sholmes: variables are alive in nested combinators/lambdas. done.
14:52:52 <sholmes>  here's an example of what you could do to be able to get the outer scope's arguments: http://pastie.org/1516475
14:53:00 <mux> conal: no, considering it more and more
14:53:05 <sholmes> edwardk, example?
14:53:29 <mauke> sholmes: \x -> \y -> x + y
14:53:40 <sholmes> -> defines a function?
14:53:46 <mauke> \param -> body
14:53:52 <sholmes> ah
14:53:54 <edwardk> yes
14:53:55 <conal> mux: great!
14:53:59 <sholmes> \ ?
14:54:07 <sholmes> why the back slash?
14:54:13 <tolkad> sholmes: -> is equivalent to the . in lambda calculus
14:54:14 <mauke> for compatibility with TeX
14:54:18 <edwardk> foo = \ x -> y ‚Äî is another way of writing foo x = y
14:54:19 * mux beats dons to it and submits conal's latest article to r/haskell
14:54:20 <mux> yay
14:54:26 <edwardk> its making up an explicit lambda
14:54:27 <tolkad> sholmes: \ is supposed to be the lambda symbol
14:54:30 <edwardk> an anonymous function
14:54:34 <sholmes> tolkad, not familiar with lambda calculus, much. :\
14:54:36 <conal> hah.  thanks, mux
14:54:37 <conal> !
14:54:52 <tolkad> sholmes: you're trying to design a functional language without knowing lambda calculus?
14:54:53 <sholmes> Oh I see
14:54:56 <mux> conal: I was implementing an interleave function; and could implement one provided the two vectors are of the same length. it had a cute type :
14:55:01 <mux> interleave :: Vec n a -> Vec n a -> Vec (n :*: Two) a
14:55:06 <mux> Two being S (S Z)
14:55:07 <tolkad> sholmes: it's really simple, wont take more than a couple minutes to learn: http://en.wikipedia.org/wiki/Lambda_calculus
14:55:18 <edwardk> f =  \ x y z -> x + y * z     f x y z = x + y * z; and f x = \y -> \ z -> x + y * z ‚Äî all define the same function
14:55:25 <mauke> tolkad: I sort of almost did that once and I came close to reinventing de bruijn indices
14:55:26 <sholmes> tolkad, I know a lambda is the same as saying function literal
14:55:30 <conal> mux: nice. i wonder if left-associated vectors would use Two :*: n instead
14:55:45 <mux> conal: however, trying to generalize this to vectors of arbitrary length, GHC wants me to prove addition is associative; and I don't think I can do that
14:55:48 <conal> mux: you'll know what i mean when you finish my latest post.
14:55:54 <mux> conal: nope, Two :*: n doesn't work
14:56:01 <sholmes> in JavaScript lambdas are the function literals: function() { }
14:56:03 <mux> the type functions don't match the recursion scheme of the code
14:56:06 <conal> mux: on *left-associated* Vec ?
14:56:06 <mauke> tolkad: \x.x was written { @ }
14:56:17 <mux> conal: n :+: n doesn't weird either for the same reasons
14:56:23 <edwardk> sholmes: now, you can directly reference your parent functions's arguments because they are in scope!
14:56:45 <edwardk> sholmes: foo x y z = Bar (\w -> x + y * w)
14:56:47 <mux> conal: oh, didn't see that bit on "left-associated" vectors, don't know those :-)
14:57:41 <edwardk> foo is a function that takes 3 arguments, (technically takes 1 argument, then returns a function that takes 1, then returns a function that takes 1) then calls Bar, with a function that takes one argument and evaluates using some of the earlier parent arguments
14:57:48 <tolkad> sholmes: lambda calculus is a turing-complete language that only has function literals
14:57:53 <dpratt71> oh, yay! my first out of memory error :-)
14:58:11 <sholmes> edwardk, (foo x y z) is similar to blossom (foo x, y, z), why curry here?
14:58:26 <conal> mux: might require some beefing up of the unification algorithm used in type-checking.
14:58:30 <mauke> sholmes: foo x y z = ... is foo = \x -> \y -> \z -> ...
14:58:37 <edwardk> sholmes: because then i can partially apply foo, what if i want to apply foo only to its first argument? say i know x = 0
14:58:37 <dpratt71> I've been working through the Euler problems and managed to solve #14, but it took longer than I thought it should...
14:58:42 <edwardk> baz = foo 0
14:58:44 <conal> mux: e.g. unification modulo associativity & commutativity.
14:58:49 <shamster> hey all. In ghci I always start out in Prelude> and then after loading a file I get switched to *Main>. Can someone explain what's going on?
14:59:04 <edwardk> now baz 12 23 ‚Äî will call Bar (\w -> 0 + 12 * w)
14:59:11 <dpratt71> ...I tried to create a function that would use memoization, but I ended up with an 'out of memory' error
14:59:16 <sholmes> edwardk: what is meant by partially apply?
14:59:16 <tolkad> sholmes: every function has 1 argument (a function), one return value (a function), and can contain anonymous functions and function applications, the entire progam is a single function body
14:59:20 <dpratt71> here it is: http://hpaste.org/43488/out_of_memory
14:59:24 <mux> conal: the actual symptom is that GHC won't let you define several type family instances if they conflict with one another
14:59:42 <edwardk> sholmes: meaning i gave the function fewer arguments than you'd expect given its definition, so it gave me back a function expecting the remaining arguments.
14:59:52 <mux> conal: so if you have this: type instance Z :+: n = n
15:00:13 <mux> conal: you cannot also have this: type instance n :+: Z = n
15:00:27 <tolkad> sholmes: he means to apply a function less times than would be enough to yield a non-function type
15:00:27 <edwardk> when i said partially apply i meant that f a b c ‚Äî looks like a ternary function, but i can apply it to fewer arguments and just get functions back
15:00:40 <mux> you're forced to continue doing the recursion of your type-level addition on the left parameter
15:00:44 <sepp2k> shamster: The prompt tells you which module you're in. If a file does not explicitly define a module, the module is implicitly named Main. So after you load a file, you're in the module Main defined by that file.
15:00:54 <edwardk> you can also apply functions to more arguments than it looks like they take, if they return functions =)
15:00:59 <conal> mux: ah. because GHC doesn't know the two claims are consistent.
15:01:02 <mux> eg type instance S n :+: m = S (n :+: m)
15:01:07 <mux> conal: yup
15:01:14 <sholmes> edwardk: Oh, I think I know now. In other words, partially call a function.
15:01:21 <edwardk> yes
15:01:26 <mux> it panics as soon as there's more than one possible choice
15:01:35 <sholmes> I see
15:01:37 <sholmes> first
15:01:41 <edwardk> you apply a function to arguments, when they are all there, something happens
15:01:45 <sholmes> how does the function handle that logic
15:01:51 <shamster> sepp2k: so the purpose is to keep separate namespaces (or... what are namespaces called in haskell?)
15:02:00 <edwardk> @type (&&)
15:02:01 <lambdabot> Bool -> Bool -> Bool
15:02:10 <tolkad> sholmes: like this:
15:02:11 <mux> conal: similarly you definitely and unfortunately cannot add type instance m :+: n = n :+: m :-)
15:02:13 <sholmes> if a function requires more arguments, and returns a partial function back for the remain arguments, what's the use?
15:02:16 <edwardk> (&&) is a function that takes a boolean and returns a function that will take the other
15:02:17 <tolkad> > map (+3) [1..10]
15:02:18 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
15:02:27 <tolkad> (+3) is a partially applied function
15:02:28 <edwardk> @type (&&) False
15:02:29 <lambdabot> Bool -> Bool
15:02:37 <edwardk> @type (&&) False True
15:02:38 <lambdabot> Bool
15:02:41 <tolkad> it is syntatic sugar for (\x -> (+) x 3)
15:02:47 <edwardk> > (&&) False True
15:02:48 <lambdabot>   False
15:02:57 <edwardk> which can be written infix
15:03:01 <edwardk> > False && True
15:03:01 * mux ponders type axiom m :+: n = n :+: m
15:03:02 <lambdabot>   False
15:03:33 <applicative> dpratt71, you don't have to write " print $ show p14"   ;  print x = putStrLn (show x)
15:03:41 <mux> anyways, good night all &
15:03:48 <edwardk> but you can assign the value to any step along the way
15:03:48 <conal> mux: take care.
15:03:50 <tolkad> sholmes: there is no such thing as a partial function
15:04:32 <tolkad> sholmes: when you partially apply a function to one argument, it returns a perfectly usable function with 1 less argument
15:04:38 <sepp2k> shamster: Yes, pretty much. I mean the point of the prompt is just to tell you which namespace you're currently in, but the point of modules is to give you namespaces.
15:05:01 <shamster> sepp2k: thanks! What's the quick switch to another namespace?
15:05:06 <sholmes> tolkad, by partial function I meant a the curry function returned. It would seem most of the time you'll need multiple arguments for functions, so you'll need to define your functions is such a way that you deal with calls that are partial
15:05:16 <dpratt71> applicative: thanks; if that was the only thing that doesn't make sense, I'd be very surprised :)
15:05:29 <sepp2k> shamster: :m
15:05:29 <tolkad> sholmes: haskell deals with that automatically for you
15:05:39 <sholmes> tolkad: I suppose though, that in haskell, it's fairly simple
15:05:41 <sholmes> yeah
15:05:54 <sholmes> because the syntax takes care of the returning?
15:05:56 <shamster> sepp2k: thanks for the help
15:06:00 <edwardk> > let foo a = (||) (not a) in foo <$> [True, False] <*> [True, False]
15:06:02 <lambdabot>   [True,False,True,True]
15:06:06 <sepp2k> shamster: np
15:06:08 <tolkad> sholmes: yeah
15:06:17 <sholmes> are there multiple statements allowed in function bodies?
15:06:28 <applicative> dpratt71, the question how to 'memoize' such a function came up the other day here:  http://www.reddit.com/r/haskell/comments/f4nba/question_about_memoizing_a_recursive_function/
15:06:30 <tolkad> sholmes: what would be the use?
15:06:38 <cdsmithus> sholmes: a function body is just an expression.  No statements at all.
15:06:49 <edwardk> sholmes: you can make let bindings, but due to laziness you don't have effects like you'd expect. so to get side-effects you work with monads, but thats a more advanced topic
15:06:52 <sholmes> tolkad, being able to deal with the argument data passed into the function
15:06:54 <tolkad> sholmes: you can use let statements to break up an expression for readability
15:07:00 <gwern> or where statements
15:07:11 <mun> with skolemisation, does anyone know why there needs to be a disjunctive term g(x) in http://en.wikipedia.org/wiki/Skolem_normal_form
15:07:13 <tolkad> sholmes: but the function is a single expression, the expression's value is the return value of the function
15:07:46 <sholmes> tolkad: maybe I'm thinking that functions are closures in haskell?
15:07:57 <sholmes> s/?/.
15:07:58 <cdsmithus> sholmes: *but* if (part of) that expression is a do block, then it can contain as many statements as you like.
15:08:17 <tolkad> sholmes: functions in haskell can be thought of as functions in the mathematical sense
15:08:29 <dpratt71> applicative: cool, thanks; funny that it pertains to exactly the question I'm looking at :)
15:08:37 <sholmes> tolkad: that's what I start to think
15:08:53 <sholmes> but in a mathimatical sense there is no closures
15:09:27 <cdsmithus> sholmes: Well, there are variables known from context.  Closures are an implementation technique for that.
15:09:42 <edwardk> sholmes: yes, but there are also no side-effects. a function takes input and returns output, it doesn't 'print to the screen' or 'read from disk'
15:09:45 <sholmes> how do I do comments in haskell?
15:09:56 <tolkad> sholmes: in haskell if you apply a function to the same arguments, it will return the same result
15:09:57 <edwardk> ‚Äî foo     or {- bar -}
15:10:02 <cdsmithus> {- like this -}, -- or this for one line
15:10:09 <shamster> sepp2k: followup - when defining a function in code and then loading it via ':l filename.hs' I have no trouble. I can write out something like 'add a b = a + b' in the filename.hs. However, in Prelude> I have to do a 'let add a b = a + b'. Is there a reason for the explicit 'let' usage in ghci?
15:10:18 <shamster> sepp2k: for function defs?
15:10:39 <edwardk> sholmes: this ability to know that applying a function to the same args returns the same result is exploited aggressively by both users and by the compiler
15:10:49 * hackagebot arrows 0.4.4.0 - Arrow classes and transformers  http://hackage.haskell.org/package/arrows-0.4.4.0 (RossPaterson)
15:11:01 <edwardk> thanks ross!
15:11:11 <sholmes> but, how would you write API that doesn't become spaghetti?
15:11:15 <sepp2k> shamster: Basically code in ghci gets executed as if it were in do-block, not the top-level of a file.
15:11:43 <edwardk> sholmes: its quite easy actually. typeclasses wrap up common functionality
15:12:02 <edwardk> and you build modules that expose the interface you want your code to have
15:12:17 <edwardk> but often these interfaces are quite abstract. what i like about it is you learn a lot in the process
15:12:20 <shamster> sepp2k: gotcha. I'll have to parse the manual some more. Is there a standard editor environment that's popular for working interactively (a la slime=emacs+lisp)?
15:12:23 <sholmes> \foo -> -- would like to do if statements here and read data from other objects and return approprietely from that.
15:12:42 <edwardk> sholmes then it probably looks like
15:12:50 <ddarius> Yes, IO and mutation everywhere!  That's how to avoid spaghetti.
15:12:56 <tolkad> sholmes: in haskell data is immutable
15:12:57 <sepp2k> shamster: emacs with the haskell mode seems to be what most people use.
15:13:24 <sholmes> interesting
15:13:28 <shamster> sepp2k: I'm so reliant on vim, though ;)
15:13:32 <cdsmithus> sepp2k: For some definitions of "most".  I just use gedit, and GHCi in another window.  Works great! :)
15:13:33 <edwardk> blah foo = do x <- foo; print x; ‚Ä¶ but that is a small portion of an otherwise pure program, and even that is built out of functions in the mathematical sense
15:13:33 <sholmes> it's definitely a different way of thinking
15:14:18 <edwardk> the IO actions are actually concrete values that you pass around that will do something when chained into a larger IO action
15:14:22 <sholmes> isn't it convenient to have closure within function bodies though?
15:14:26 <sholmes> or is that subjective
15:14:28 <edwardk> you have closer
15:14:32 <edwardk> its just done for you
15:14:35 <edwardk> er closure
15:14:36 <tolkad> sholmes: if you need to write procedural code in haskell you can do it with the IO monad but your function still wont have side effects. it will be returning an opaque IO type that can be put (directly or indirectly) into the "main" procedural block
15:14:51 <edwardk> every time you reference a variable from outside of your lambda there is a closure being created
15:14:57 <int80_h> I'd like to discuss the following type signature. I'm having bigger questions, but it begins with me understanding this type signature
15:14:58 <cdsmithus> sholmes: Not sure you mean the same thing by  "closure" as the rest of us... what do you mean by that word?
15:15:08 <edwardk> well, possibly, the compiler can usually optimize many of them away
15:15:16 <int80_h> do_curl_ :: (CurlHeader headerTy, CurlBuffer bodyTy) => Curl -> URLString -> [CurlOption] -> IO (CurlResponse_ headerTy bodyTy)
15:15:26 <int80_h> can we begin with the constraints?
15:15:32 <int80_h> and what hey mean?
15:15:36 <int80_h> they>?
15:15:41 <sholmes> cdsmithus: ah, my understanding of closures are blocks of code that have their own scope and can be re-used
15:15:42 <edwardk> sholmes { ‚Ä¶. } has nothing to do with when variables are captured from the environment in haskell. its more about nesting of expressions
15:15:52 <tolkad> int80_h: we were just telling sholmes you can avoid API spaghetti in haskell -_-
15:16:16 <int80_h> tolkad: oh is that what I'm dealing with?
15:16:25 <cdsmithus> int80_h: they mean that there are type classes called CurlHeader and CurlBuffer, and that the words headerTy and bodyTy, respectively, stand in for any type that's an instance of those type classes.
15:16:32 <edwardk> sholmes: technically those would be 'blocks' in most language designers' parlance. a closure is actually a captured portion of the environment
15:17:17 <sholmes> edwardk, haskell decides that functions are a way to nest expressions, but what about the idea that functions can be a way of nesting multiple expressions? This was purely my intention with blossom
15:17:22 <ddarius> mun: I presume because it's equivalent to the general case.
15:17:23 <edwardk> sholmes: i.e. in order to evaluate the (\w -> w * y + x) sub expression, it had to capture the y and x from its environment and wrap it up in some structure, so it could later pull it out and combine them with the w
15:17:28 <cdsmithus> sholmes: so Haskell expressions are always run in a context with certain variables in scope, and if you pass them around, they keep that scope.  If that's what you mean, then Haskell does that.
15:17:39 <mun> ddarius, thanks
15:18:07 <int80_h> cdsmithus: okay now the next part. Does that mean Curl ->  URLString ->
15:18:13 <edwardk> sholmes: the values x and y mean what they meant when you captured the function, so you can 'nest multiple expressions' in that sense
15:18:27 <tolkad> ddarius: nesting multiple expressions? you could certainly nest multiple expressions  byjust using a lot of parentheses
15:18:28 <sholmes> my idea was to merge the idea of a block into a function/closure by simply making { } a block of code with it's own scope and access to the outer scope
15:18:32 <uberfry> hi everybody
15:18:37 <int80_h> cdsmithus: okay now the next part. Does that mean Curl ->  URLString -> have to be an instance of CurlHeader and CurlBuffer respectively?
15:18:39 <uberfry> can someone tell me why this won't work please? http://hpaste.org/43489/lambda
15:18:56 <edwardk> sholmes: just replace  { ‚Ä¶ } in your head with (\ y z -> ‚Ä¶. ) 
15:18:57 <cdsmithus> int80_h: No.  There are two specific types called Curl and URLString, and the first two parameters have those types.
15:19:11 <ddarius> tolkad: I'm not in your conversation.
15:19:29 <int80_h> cdsmithus: okay then what are the contraints constraining?
15:19:32 <tolkad> ddarius: sorry, my mistake
15:19:37 <edwardk> sholmes: and keep in mind that a value is a promise to be able to compute something the first time you look at it, so you can just say x = 12 instead of define x { 12 } 
15:19:38 <sholmes> edwardk: syntactically, that replaces meant doesn't seem pretty
15:19:40 <edwardk> or what have you
15:19:51 <Twey> uberfry: x y z aren't defined
15:19:57 <edwardk> sholmes: rarely do you write it that way
15:20:04 <Twey> uberfry: You forgot to include them in the function definition
15:20:05 <uberfry> Twey: I may only change fa and fb
15:20:07 <uberfry> well
15:20:08 <uberfry> they can't
15:20:12 <uberfry> I can't include them in teh signature
15:20:17 <uberfry> not allowed
15:20:30 <Twey> ‚ÄòNot allowed‚Äô?
15:20:35 <uberfry> homework :)
15:20:36 <Twey> fb = fa (\(x,y,z) -> x y z) (x,y,z)
15:20:36 <sholmes> event -> isn't as preferable as {} IMO
15:20:37 <cdsmithus> int80_h: They are constraining the types that are later referred to by the names headerTy and bodyTy.  Those types are part of the return value.
15:20:37 <int80_h> tis homework perhaps
15:20:48 <sholmes> -> is two characters like {}
15:20:49 <Twey> Here (outside the lambda) you have used three parameters x, y, and z to construct your triple
15:20:49 <uberfry> ahhhhh ic
15:20:51 <uberfry> let me try that
15:20:57 <Twey> However, no such parameters are in scope
15:21:12 <edwardk> sholmes: usually you define functions at the top level using the combinator syntax rather than the lambda syntax
15:21:16 <sholmes> but they are at opposite ends of the keyboard and one requires a shift key while the other does.
15:21:38 <sholmes> and { } is a wrap
15:21:39 <edwardk> sholmes: the lambda syntax is provided because it is occasionally useful to make nested anonymous unnamed functions
15:21:53 <edwardk> sholmes if you prefer you can avoid using it entirely
15:22:00 <lispy> sholmes: that makes a lot of assumptions about the keyboard :)
15:22:03 <sholmes> there's another syntax?
15:22:09 <tolkad> sholmes: nobody cares where on the keyboard they are. most experienced haskell users probably have customized their text editors
15:22:15 <cdsmithus> int80_h: Read a "=>" in a type signature like this: "If headerTy is an instance of CurlHeader, and bodyTy is an instance of CurlBuffer, then do_curl_ has the following type..."
15:22:17 <edwardk> foo x y z = let baz w = w * x + y in Bar baz
15:22:24 <sholmes> lispy: yes, I was going to say, "At least on a standard qwerty"
15:22:33 <edwardk> would define a named function locally, and then pass it in to Bar instead
15:22:40 <lispy> hmm.../me tries to recall what qwerty is like...
15:22:40 <edwardk> or
15:22:41 * ddarius wonders if edwardk is getting paid for this.
15:22:51 <Twey> uberfry: And you never use your z parameter
15:22:52 <edwardk> foo x y z = Bar baz where baz w = w * x + y
15:22:56 <sholmes> but I wouldn't understand why a keyboard would separate { from }
15:22:58 <edwardk> which is the more common idiom
15:23:11 <uberfry> Twey: I know
15:23:14 <edwardk> ddarius: i plead the 5th on the grounds i haven't left the office yet
15:23:17 <Ferdirand> keyboard speed isn't usually the limiting factor when writing haskell
15:23:18 <uberfry> it's just for confusion/understanding
15:23:20 <int80_h> cdsmithus: okay now for the return type. I see it's wrapped in an IO monad, but I'm having difficulty thinking about the rest IO (CurlResponse_ headerTy bodyTy). What does it mean?
15:23:21 <lispy> sholmes: the kinesis puts { and } at opposite ends of the keyboard
15:23:47 <Twey> Who cares where they are?
15:23:55 <Twey> It doesn't make it slower
15:24:03 <edwardk> sholmes: anyways, i highly recommend taking a look at how the other half lives. there are some pretty good introductions to haskell out there
15:24:03 <lispy> sholmes: http://www.kinesis-ergo.com/advantage.htm  <-- just an example
15:24:04 <Twey> Faster, if anything ‚Äî you can have both hands in position at the same time
15:24:27 <edwardk> sholmes: Real World Haskell and "Learn You a Haskell for Great Good" are both very good, and both available online
15:24:37 <edwardk> (and in dead tree form)
15:24:46 <uberfry> anyone who can help me though please?
15:24:49 <edwardk> er i think LYAH shipped in dead tree form
15:24:53 <uberfry> it's stupid homework :(
15:24:54 <cdsmithus> int80_h: Okay, it means once you supply do_curl_ with a Curl value, a URLString value, and a list of CurlOption values, the result is an I/O action.  Performing that action gives you back a value of the type CurlResponse headerTy bodyTy.
15:25:03 <uberfry> they just want to take things to an extreme
15:25:09 <uberfry> been stuck on this one for 2 hours now
15:25:13 <tolkad> :t map (map (map (map (map (map (map (map (map (map (map (map (map map))))))))))))
15:25:13 <lambdabot> forall a b. [[[[[[[[[[[[[a -> b]]]]]]]]]]]]] -> [[[[[[[[[[[[[[a] -> [b]]]]]]]]]]]]]]
15:25:32 <edwardk> :t fmap fmap fmap fmap map
15:25:33 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[b1]'
15:25:33 <lambdabot>     Probable cause: `map' is applied to too many arguments
15:25:33 <lambdabot>     In the fourth argument of `fmap', namely `map'
15:25:36 <edwardk> er
15:25:44 <edwardk> :t fmap `fmap` fmap `fmap` fmap
15:25:45 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
15:25:59 <sholmes> http://mykeyboard.co.uk/kinesis/graphics/keymap.png
15:26:10 <int80_h> cdsmithus: could you tell me what "CurlResponse headerTy bodyTy" is? This is what I'm having difficulty with.
15:26:45 <edwardk> wow thats what the default kinesis key mapping looks like. with shapr around i could never tell ;)
15:26:46 <tolkad> :t let x=(.).(.).(.).(.).(.).(.); y = x.x.x.x.x.x.x.x.x.x.x.x.x.x; z = y.y.y.y.y.y.y.y.y.y; a = z.z.z.z.z.z.z.z.z.z.z.z in a.a.a.a.a.a.a.a.a.a.a.a.a.a.a
15:26:46 <lispy> sholmes: oh hmm...maybe it separates them because I'm using the dvorak layout
15:26:57 <sholmes> twey, it would seem like { and } would have some kind of symetry on a keyboard
15:27:01 <lambdabot> thread killed
15:27:12 <tolkad> :t let x=(.).(.).(.).(.).(.).(.); y = x.x.x.x.x.x.x.x.x.x.x.x.x.x; in y.y.y.y
15:27:16 <edwardk> lispy: likely
15:27:17 <lispy> sholmes: I know dvorak on a standard keyboard doesn't separate them but since it does on a kinesis I assumed it was the kinesis to blame
15:27:24 <cdsmithus> int80_h: Umm... CurlResponse_ (sorry, left out the _ before by accident) is some type in the library you're using?  My guess it that it represents an HTTP response and uses the types of its type parameters to contain the headers and body.
15:27:42 <cdsmithus> int80_h: But I'd have to find the library and look up exactly what the type looks like.
15:27:44 <parcs> \
15:28:09 <int80_h> cdsmithus: I can make that easy. Hold on I'll paste the relevant things
15:28:35 <edwardk> sholmes: anyways, i need to run. its been great chatting with you. i hope you stick around =)
15:28:54 <sholmes> besides keyboards, { } can be more readable
15:29:16 <sholmes> edwardk: I need to work too. Thanks for the interesting talk! :D
15:29:18 <cdsmithus> tolkad: lambdabot needs @ty, not :t
15:29:32 <edwardk> sholmes: \ x -> y was chosen because it meant something and used a glyph that was already bound by the language for another purpose so it didn't steal much syntax.
15:29:45 <dafis> @hackage curl
15:30:01 <edwardk> \ looks kind of like a lambda and -> is used elsewhere in the grammar and cleanly separates the patterns from the body
15:30:23 <edwardk> plus i didn't use any pattern matching, which adds another layer of things you can do over and above your model =)
15:30:30 <dafis> cdsmithus: http://hackage.haskell.org/packages/archive/curl/1.3.6/doc/html/Network-Curl.html
15:30:41 <dafis> that's what's int80_h's problem
15:30:46 <cdsmithus> dafis: thanks
15:30:51 <sholmes> another thing I wanted in my language is hardly any weird characters at all
15:30:55 <sholmes> that is, more letters
15:30:58 <sholmes> more words
15:31:01 <cdsmithus> int80_h: So the ResponseCurl_ type is described at http://hackage.haskell.org/packages/archive/curl/1.3.6/doc/html/Network-Curl.html#t:CurlResponse_
15:31:09 <sholmes> define foo:23.
15:31:21 <edwardk> foo = 23
15:31:22 <edwardk> =)
15:31:50 <sholmes> : ; . , { } / # pretty much the only symbols I've thought up for my language, the rest are words and spaces
15:31:51 <edwardk> why make someone type a big word like define for the most common operation in your language?
15:32:12 <sholmes> I can type define just as fast as +
15:32:13 <sholmes> =
15:32:19 <sholmes> without typos :P
15:32:38 <dafis> int80_h: by the way, sending a 3MB message to beginners may be considered a bit excessive
15:32:39 <edwardk> more power to ya =) but you were just griping about the number of characters in \ ‚Ä¶ -> 
15:32:41 <edwardk> =)
15:32:41 <sholmes> also, there's the ability to modify the language now, because define is a function and can be changed
15:33:13 <tolkad> :t let x=(.).(.).(.).(.).(.).(.); y = x.x.x.x.x.x; in y
15:33:28 <edwardk> define can't be safely defined as a function though because it affects variable binding. it mutates dictionaries and its argument is a variable _name_. its a binder, which is a subtly different thing
15:33:33 <tolkad> oh that killed lambdabot 0_o
15:33:47 <cdsmithus> tolkad: No, just use @ty instead of :t
15:33:54 <sholmes> edwardk: not the number, I said they are the same number of characters as {}. You didn't understand that I meant -> is wouldn't be as symetric. That's all.
15:34:04 <tolkad> @ty let x=(.).(.).(.).(.).(.).(.); y = x.x.x.x.x.x; in y
15:34:15 <int80_h> cdsmithus: I can make that easy. Hold on I'll paste the relevant things
15:34:18 <int80_h> http://hpaste.org/43490/help_me_make_sense_of_do_curl
15:34:18 <tolkad> cdsmithus: * lambdabot has quit (Ping timeout: 276 seconds)
15:34:22 <cdsmithus> Oops, lambdabot isn't here
15:34:26 <cdsmithus> You're right
15:34:36 <Ferdirand> a { b } is hardly more symmetric than \a -> b
15:34:40 <edwardk> sholmes: well the directedness is intended. case expressions and lambdas use -> because control flows to the right, and doesn't go back across the ->
15:34:41 <sholmes> edwardk: I don't mind to many characters, just so long as they aren't all paranthesis'  (e.g.  (f (f (f ()))))
15:34:48 <int80_h> dafis: hmm yeah I was trying to compartmentalize that. It's a tricky problem.
15:35:15 <int80_h> daid: I'm trying a work-around that is not a kludge. But I need to understand do_curl_ first.
15:35:22 <cdsmithus> int80_h: So I've lost track of what your question is now.
15:35:27 <dafis> int80_h: when you say 'produces a cookies file', you mean, that's written to disk?
15:35:32 <edwardk> foo x y z | empty x = ‚Ä¶ checks if x is empty before moving on to the right hand side of the =
15:35:32 <int80_h> daifis: I'm trying a work-around that is not a kludge. But I need to understand do_curl_ first.
15:35:35 <sholmes> edwardk: true, I see how that is. But { } is more of a "block", which is useful where a language has a block of multiple statements for function bodies.
15:35:50 <edwardk> sholmes: have you seen haskell's do sugar?
15:36:06 <dafis> int80_h: we'd need to identify the problem for a solution
15:36:07 <sholmes> edwardk: I'm sure the sugar isn't with letters?
15:36:07 <int80_h> dafis: yeah cookie jar, written to disk. We found an alternative that allows capture of the headers as they are being made. 
15:36:18 <edwardk> almost all of the cases where you a thinking you'd use { } you use the keyword do
15:36:22 <sholmes> in blossom, sugar can become single letter namespaces
15:36:25 <tolkad> sholmes: in haskell you could right that as ¬´¬†let a = f (); b = f a; in f b ¬ª or ¬´ f $ f $ f () ¬ª
15:36:25 <edwardk> er where you are thinking
15:36:38 <int80_h> daifis: I wasn't clear about what the problem was?
15:36:43 <dafis> int80_h: and without the kludge, the real thing doesn't write the file?
15:36:50 <tolkad> sholmes: in haskell you could right that as ¬´¬†let { a = f (); b = f a } in f b ¬ª or ¬´ f $ f $ f () ¬ª
15:37:00 <tolkad> sholmes: whoops sorry not used to one-line syntax
15:37:03 <dafis> int80_h: I meant the cause of the problem
15:37:35 <sholmes> tolkad: look at all the symbols though. Eek! Maybe there's no way of getting around it though in any language.
15:37:55 <int80_h> dafis: well, my toy program writes the file. And I tried to model my "real" program on the toy. The problem is that the production program gives no indication that it is doing anything wrong. Except it doesn't produce the cookie jar. 
15:37:57 <edwardk> sholmes: thats because nobody writes code that way in haskell, we use layout, which replaces the { }'s with indentation
15:38:20 <dafis> int80_h: yeah, and we have to find out why to solve the problem
15:38:25 <edwardk> but you can't convey that on a single line in IRC, so we use the explicit {}'s and ; 's here
15:38:28 <sholmes> edwardk: I was thinking about using indentation as an alternative to { }, too.
15:38:45 <int80_h> daifis: I suspect libcurl, and am hoping the answer is in the strace
15:38:55 <sholmes> edwardk: I see.
15:39:19 <edwardk> in haskell 'do' 'where' 'let' and 'in' each open a block where the indentation of the next lexeme determines the indentation of the block, that block runs until you outdent, inserting 'virtual ;'s every time you indent to that same level
15:39:32 <cdsmithus> ad 'of'
15:39:37 <edwardk> er
15:39:37 <cdsmithus> ^and 'of
15:39:38 <edwardk> sorry
15:39:42 <edwardk> s/in/of/
15:39:45 <sholmes> I might adopt -> in blossom in order to do indentation
15:39:52 <augur> conal: STOP TYPING
15:39:53 <augur> GOD
15:39:56 <augur> >_<
15:40:07 <edwardk> augur: ?
15:40:11 <tolkad> edwardk: yeah, the problem is when people try to mix tab and space indenting. that's why haskell programmers accepted the standard of always using tabs for indentation
15:40:28 <edwardk> tolkad: we did what? 
15:40:31 <int80_h> daifis: When we follow the headers, it all looks good. Nothing looks wrong. If something were even slightly off it would provide a clue. But that's the wierd part. It looks good, except it doesn't write that file. But the toy does. I don't know why, when the former is modelled on the later.
15:40:36 <edwardk> tolkad: we just said its worth 8 spaces is all =)
15:40:37 <augur> edwardk: he's writing soooo many posts
15:40:40 <augur> i cant keep up
15:40:43 <edwardk> augur: lol
15:40:44 <sholmes> why couldn't haskell do both?
15:40:51 <edwardk> sholmes: it does
15:41:05 <tolkad> sholmes: I was kidding
15:41:06 <jmcarthur> edwardk: tolkad is a really good troll ;)
15:41:09 <edwardk> it just sets a language specification of what the tabstops are
15:41:17 <sholmes> if the line is 1 space more than the previous or one tab more, then it's a new block
15:41:24 * edwardk is trollable.
15:41:26 <cdsmithus> sholmes: You can use either... but you're evil if you use tabs.  I support a new compiler feature that stabs you in the eye with a broken shard of glass from the nearest window if you do so.
15:41:41 <edwardk> sholmes: the problem is when the previous line was 8 spaces, and the next line is one tab
15:42:01 <edwardk> sholmes: so you need to disambiguate somehow or complain. haskell 98 reasonably choice 8 character tabstops
15:42:02 <sholmes> cdsmithus: tabs make more sense for indentation
15:42:18 <sholmes> how do you know how many indentations are in 4 spaces? one or two?
15:42:26 <cdsmithus> sholmes: Then I recommend you wear googles when you write Haskell after my new compiler feature is implemented.
15:42:30 * int80_h just got hit with work, is aft.
15:42:39 <edwardk> sholmes: hence why it makes sense to just carve it into the language and move on
15:42:46 <augur> conal: whoa whoa whoa, exponency really _is_ a valid perspective on function types? can you give me some refs on this
15:42:47 <edwardk> cdsmithus: =)
15:42:48 <sholmes> cdsmithus: maybe I just wont use your damn feature. :P
15:42:58 <tolkad> sholmes: not to mention the fact that you can adjust tab width to adjust indentation width, without having to do any language-specific parsing
15:43:11 <sholmes> tolkad: exactly
15:43:22 <sholmes> a tab is just a space that can be styled
15:43:31 <dafis> int80_h: maybe open("cookies.txt", O_RDONLY)           = -1 ENOENT (No such file or directory) indicates the problem
15:43:34 <sholmes> so why use two of something when you can use one?
15:43:58 <tolkad> sholmes: yeah, you should always throw in a few non-breaking spaces too, just for job security
15:44:29 <sholmes> tolkad: donno what you mean
15:44:32 <edwardk> sholmes: thats your editors job. you can hit tab all you want, set soft tabstops to 2 characters, etc. but in the presence of layout, you need a tool to disambiguate. the grammar just says '8 character tabstops'. most folks i see use 2 or 4 character 'soft' tab stops, and set their editor to expand spaces
15:44:38 <conal> augur: hm. don't know about refs. play with exponent laws (e.g. a^(b+c) = ...) and compare them with function type isomorphisms. also think about cardinality of sets of functions.
15:44:40 <cdsmithus> tolkad: Don't stop there.  Unicode has LOTS of space characters
15:44:45 <edwardk> er to expand tabs
15:44:50 <tolkad> the best reason for using tabs is to reduce file size
15:45:02 <edwardk> sholmes: you're being trolled ;)
15:45:04 <tolkad> a tab is a single byte, space indentation is 2-4 bytes
15:45:12 <sholmes> ah
15:45:37 <gwern> tolkad: shit! I might have wasted 0.000000000000001 cents because I didn't use tabs!
15:45:40 <augur> conal: what is + in type terms
15:45:49 <edwardk> meh, i blow that budget putting an emacs mode line at the top to make it explicit ;)
15:45:54 <edwardk> anyways, gotta run
15:45:57 <conal> augur: easier to see when function types are written "b <- a" instead of "a -> b". which is also more convenient with (.).
15:45:58 <sholmes> the only reason why people use spaces is because they lack a good editor that allows them to change the indentation width (aka notepad)
15:46:07 <conal> augur: sum. written "Either" in Haskell.
15:46:09 <sholmes> well, I have to get back to work. damn time flies
15:46:20 <augur> conal: ok, so its union, basically.
15:46:20 <edwardk> later sholmes.
15:46:35 <conal> augur: *disjoint* ("tagged") union
15:46:36 <tolkad> Is CPP run before or after comments being removed from the source code?
15:46:44 <sholmes> cya edwardk
15:47:08 <sholmes> bye 2 everyone
15:47:16 <sholmes> or should that be
15:47:16 <cdsmithus> tolkad: Should be before
15:47:18 <augur> conal: yeah. ok. lemme think about this
15:47:25 <sholmes> bye()
15:47:40 <sholmes> how do you call a function with empty arguments in haskell?
15:47:53 <tolkad> sholmes: you don't give it argument
15:47:56 <tolkad> arguments*
15:48:03 <conal> augur: yeah, do. that's how i get insights: play with stuff.
15:48:15 <cdsmithus> sholmes: strictly speaking, *all* functions in Haskell have one argument.  Functions of no arguments don't exist
15:48:28 <sholmes> cdsmithus, oh
15:48:30 <sholmes> then
15:48:33 <tolkad> sholmes: you can bind an expression to a name
15:48:38 <sholmes> bye everyone;
15:48:52 <sholmes> haha, not much different from english
15:49:04 <tolkad> please don't leave
15:49:16 <sholmes> yeah, I'ma going to go work now
15:49:23 <cdsmithus> Have fun at work. :)
15:49:31 <tolkad> you're leaving us?
15:49:49 <conal> ah. another response to the common question "is everything a function in haskell?" is "speaking strictly?"
15:50:07 <cdsmithus> conal: Hmm?
15:50:10 <sholmes> I'm at work
15:50:13 <sholmes> and yes I'm leaving
15:50:18 <tolkad> we'll be all alone
15:50:24 <sholmes> but me sitting here saying I'm leaving is not leaving
15:50:37 <sholmes> you got edwardk
15:50:39 <conal> cdsmithus: tied to a conversation earlier today.
15:50:45 <tolkad> no he left!
15:50:48 <tolkad> edwardk left
15:50:50 <tolkad> I'm all alone
15:51:11 <sholmes> you starting to sound like a twilight movie
15:51:19 <shamster> would you say that a partially applied function is akin to c++'s bind routines?
15:51:21 <sholmes> talk to jacobian
15:51:36 <sholmes> :P
15:51:41 <cdsmithus> conal: Ah.  I wasn't here earlier, I suppose.  Is there something wrong with saying that strictly speaking, all Haskell functions have one argument?  I said "strictly speaking" because we all talk about functions of multiple arguments all the time via currying.
15:51:47 <sholmes> haha
15:52:06 <sholmes> peace
15:52:42 <benmachine> I always thought that saying that all haskell functions took one argument was rather pedantic
15:52:49 <conal> cdsmithus: nothing wrong at all. i've been musing on & off about what people are trying to ask when they pose that question (and others).
15:52:49 <benmachine> all haskell functions *can* take one argument
15:53:19 <benmachine> but I tend to think that the number of arguments a function takes is the number of things you can write after it and have it typecheck (which, yes, can be limitless)
15:53:21 <conal> cdsmithus: well, one drawback of the "strictly speaking* answer is that it might be missing the intended question.
15:53:42 <cdsmithus> conal: Sure.  But any answer *might* be missing the intended question. :)
15:54:07 <conal> cdsmithus: agreed. so i'm playing with how to fish out the intended question rather than assuming.
15:54:29 <tg_> conal: that currying implies an ordering of arguments
15:54:39 <conal> cdsmithus: and i tend to assume more precision in people's questions than they intend.
15:55:01 <kfish> morning conal!
15:55:08 <tg_> whereas people using imperative languages would assume that changing the order of arguments has no effect?
15:55:17 <conal> kfish: hi! how go things in tokyo?
15:55:21 <tg_> two guesses in one.
15:55:30 <kfish> conal: awesome, it's both warming up and snowing
15:55:37 <kfish> conal, btw do you like agda? :-)
15:55:39 <cdsmithus> Well, I'm off.  Whenever I hear the word "currying", I have to go to the Thai restaurant down the road from me.  It's a rule.
15:55:51 <conal> kfish: i like dependent types and what i've seen of agda.
15:56:20 <kfish> conal: some of your recent posts are agdariffic
15:56:31 <conal> kfish: yep.
15:56:49 <ddarius> cdsmithus most eat Thai a lot.
15:58:03 <ddarius> s/most/must
15:58:05 <tg_> am I still muted?
15:58:07 <tg_> :|
15:58:55 <mun> hi
15:58:58 <benmachine> tg_: nope
15:59:04 <tg_> benmachine: ok
15:59:08 <tg_> my suggestion was just crap.
15:59:08 <mun> is "\forall p \in S. P(p)" equivalent to "\forall p. p \in S --> P(p)"?
15:59:26 <benmachine> tg_: it's a busy channel, not everyone can reply to everyone
15:59:57 <tg_> benmachine: i know. I got muted earlier becuase of quieting spammers, so I wanted to make sure I could still speak
16:00:12 <benmachine> tg_: fair enough :)
16:01:10 <ddarius> mun: Usually.
16:01:36 <mun> ddarius, thanks
16:01:38 <int80_h> ddarius: I'm free for the moment, are you free to pick up where we left off?
16:02:34 <int80_h> cdsmithus: I wasn't ignoring you. Understanding that type signature will help me with the larger problem I have.
16:02:40 <ddarius> int80_h: I'm about to go get food, and I have no idea what you are talking about.
16:02:47 <ddarius> And cdsmithus is gone.
16:03:12 <int80_h> ddarius: oops, I had you confused with dafis
16:03:19 <int80_h> ahem
16:03:35 <int80_h> dafis: I'm free for the moment, are you free to pick up where we left off?
16:03:56 <dafis> int80_h: in which part is the cookie file supposed to be written?
16:04:25 <int80_h> dafis: hold on looking at my code
16:06:48 <dafis> int80_h: obtainCookies seems likely, so we'd need to look at curlResp
16:06:55 <int80_h> daifis: in generateResourceHtml, you'll see a function called curlResp. As far as I know, the cookie jar should start to me written to as soon as a GET or POST happens. The initial conversation happens in curlResp.
16:07:04 <int80_h> *be
16:07:24 <int80_h> eep
16:07:41 <Jotta> data Tree where
16:07:42 <Jotta>  Leaf :: Int -> Tree
16:07:42 <Jotta>  Node :: Tree -> Tree -> Tree
16:07:45 <Jotta> What should that be?
16:08:05 <int80_h> daifs: wb, I'll re-send my response
16:08:15 <dafis> int80_h: sorry, connection trouble, you still there?
16:08:18 <int80_h> daifis: in generateResourceHtml, you'll see a function called curlResp. As far as I know, the cookie jar should start to be written to as soon as a GET or POST happens. The initial conversation happens in curlResp.
16:08:28 <int80_h> dafis: still here :)
16:08:38 <int80_h> and thanks for taking time out for me :)
16:09:08 <dafis> int80_h: okay, so we need to look at curlResp, first at do_curl_
16:09:49 <sepp2k> Can I print a string to stdout without using the letters e,o or r? Sadly both print and putStr contain an r.
16:10:21 <dafis> int80_h: it might be that you have to force the response
16:10:33 <int80_h> daid: okay I'm with you. This is the broken code btw. For comparison I have the toy program with successfully produces a cookie jar
16:10:54 <int80_h> daifis: okay I'm with you. This is the broken code btw. For comparison I have the toy program with successfully produces a cookie jar
16:11:16 <int80_h> daifis: the function names differ somewhat but you can see the basic model.
16:11:35 <Jotta> Whats a datatype?
16:13:11 <Jotta> data List where
16:13:11 <Jotta>  Nil :: List
16:13:11 <Jotta>  Cons :: Int -> List -> List
16:13:18 <Jotta> Why will that not compile?
16:13:26 <dafis> int80_h: can you try something like let rbody = respBody resp in curlResp and then length rbody `seq` if code /= CurlOK ... ?
16:13:59 <int80_h> dafis: sure I can try that
16:14:56 <joe6> does anyone know of any links on how to pattern-match record fields?
16:15:09 <joe6> RWH does not seem to have an illustraction on how to do it.
16:15:27 <joe6> though it does have illustractions on binding a value with a field value
16:15:47 <dafis> joe6: fun Record{ field = value }
16:16:01 <dafis> joe6: fun Record{ field = value } = something with value
16:16:10 <int80_h> dafis: this may take me a minute
16:16:18 <dafis> int80_h: sure
16:16:23 <Jotta> "data XXX where" <<< What topic should I read to know how to use this?
16:16:40 <Zao> Jotta: GADTs?
16:16:40 <dafis> Jotta: GADTs
16:16:54 * dafis celebrates being faster for once
16:17:01 <Zao> Who ate lambdabot?
16:17:05 <int80_h> I did
16:17:06 <Zao> dafis: Not on my client.
16:17:09 <int80_h> and he was delicious
16:17:14 <dafis> Zao, I think 'twas tolkad
16:17:15 <Zao> dafis: Distributed systems are awesome.
16:17:28 <joe6> dafis: thanks.
16:18:10 <dafis> Zao: anyway, I've not been much slower :D
16:18:49 <Bel_> Hi, does anyone have the time to help a haskell beginner with an assignment? http://hpaste.org/43492/social_network_simulation
16:19:20 <dafis> Bel_: what's the problem?
16:19:44 <joe6> dafis: fun DataConstructor { field = 1 } does not seem to be working. is that what you meant?
16:19:56 <gwern> @wn entrepot
16:20:02 <joe6> dafis: fun RecordConstructor { field = 1 } does not seem to be working. is that what you meant?
16:20:23 <Bel_> when i try the last function: countFriends socialNetwork Alice
16:20:34 <dafis> joe6: that was what I meant, but you need not put a literal there
16:20:34 <Bel_> i get an error
16:20:40 <Zao> What error, pray tell?
16:20:43 <dafis> Bel_: what error?
16:20:59 <Bel_> Program error: pattern match failure: countFriends socialNetwork "Alice"  
16:21:21 <joe6> dafis: but I want to pattern match to a literal and if that record matches, want to use it here.
16:21:51 <joe6> dafis: almost like pattern matching to a normal data definition.
16:21:52 <dafis> Bel_: oh, you match only for Graphs with exactly one edge
16:22:21 <dafis> joe6: you *can* match on a literal value for the field, just you need not
16:23:08 <Jotta> data List2 where
16:23:08 <Jotta> 	Nil2 :: List2
16:23:08 <Jotta> 	Cons2:: Int -> List2 ->List2
16:23:15 <Bel_> dafis: how would i go about changing that?
16:23:16 <Jotta> Error: unexpected keyword "where"
16:23:17 <joe6> dafis: thanks a lot.
16:23:42 <dafis> Bel_: the right hand side of countFriends works for all edge-lists, so you just have to change the pattern on the left
16:24:10 <dafis> Jotta: {-# LANGUAGE GADTs #-}
16:24:38 <doserj> Jotta: or just use "data List2 = Nil | Cons Int List2"
16:24:56 <dafis> doserj: I think Jotta wants to learn GADTs
16:24:57 <Jotta> Why cant I define the types in and out like in a function?
16:25:07 <dafis> ?
16:25:53 <Bel_> :dafis: but I need the label on the right side, so i have to use this definition of the type, don't i?
16:26:05 <Jotta> I already have "data List = Nil | Cons (List)", I just want to say the inputs and out puts for Nil and Cons e.g. Nil: Int and Cons: Int -> List -> List
16:26:09 <Bel_> dafis l = label
16:26:10 <Jotta> But I dont know how to do that
16:26:16 <dafis> Bel_: oops, you repeat the pattern on the RHS, replace that too
16:26:33 <dafis> Bel_: countFriends (Graph edges) ...
16:26:33 <Jotta> *Nil: List
16:26:53 <doserj> Jotta: data List = Nil | Cons Int List already defined the types for Nil and Cons
16:27:28 <Veinor> argh
16:27:35 <Veinor> i hate it when i import stuff like HTTP and i get warning spew
16:27:49 <dafis> Jotta: or with a GADT like List2, but you need the language extension
16:27:54 <Bel_> dafis: thank you very much, now it works perfectly :D
16:28:16 <dafis> Veinor: then don't
16:28:47 <dafis> int80_h: is it running?
16:28:59 <Veinor> dafis: ?
16:29:11 <dafis> Veinor: don't import HTTP
16:29:18 <Veinor> :P
16:29:23 <Jotta> dafis: What do you mean language extension?
16:29:27 <parcs> > let transpose [[]] = [[]]; transpose (xs:xss) = zipWith (:) xs (transpose xss) in transpose [[1,2,3],[4,5,6]]
16:29:31 <dafis> Jotta: {-# LANGUAGE GADTs #-}
16:29:42 <dafis> at the top of your source file
16:30:11 <dafis> Jotta: GADTs aren't in Haskell2010, so you need an extension to use them
16:30:12 <Jotta> dafis: Then put my "module ABC where" or after?
16:30:39 <dafis> Jotta: language extensions before the "module"
16:30:49 <dafis> also options pragmas
16:31:19 <astroboy> does someone has experience with the haskell DBus library? 
16:31:20 <dafis> parcs: lambdabot was killed
16:33:13 <conal> parcs: or a tidy foldr
16:33:34 <Jotta> Does winhugs support GADTs?
16:34:11 <hpc> i think GADTs are newer than the last revision of hugs
16:34:16 <glguy> astroboy: it usually works better if you just ask your question
16:35:04 <hpc> "can i ask a question?"
16:35:07 <hpc> "yes, and that was it"
16:35:14 <dafis> Jotta: I think it doesn't, GHC only afaik
16:35:20 <Jotta> Just tried GHCI and it works fine, I hate it when your doing it write and the envirnment is to blame
16:35:27 <ddarius> Can I ask "can I ask a question?"
16:35:27 <Jotta> *right
16:35:34 <hpc> ddarius: no
16:35:36 <hpc> :D
16:35:39 <glguy> ddarius: ask first, please
16:35:52 <Jotta> question a :: question (question a)
16:36:22 <Jotta> dafis: Thanks
16:36:37 <dafis> welcome
16:36:51 <parcs> conal: oh, indeed
16:36:55 <astroboy> glguy: I'm trying to see how it works, this should match all events right: http://hpaste.org/43493/dbus ?
16:37:19 <Veinor> why does cabal keep reinstalling HTTP?
16:37:41 <conal> as someone (who?) said, "general recursion is the 'goto' of functional programming"
16:37:42 <Veinor> (every time i cabal install my snap project)
16:37:42 <dcoutts> see --dry-run -v
16:37:48 <dafis> Veinor: when you try to install what?
16:38:08 <ddarius> conal: Possibly David Turner.
16:38:12 <Veinor> huh. manually installed the latest and it stopped doing it.
16:38:13 <dcoutts> Veinor: and possibly because it's getting confused when you've got the same version of the same package in both user and global dbs.
16:38:15 <glguy> astroboy: if main returns your forked thread will be killed
16:38:29 <int80_h> http://hpaste.org/43494/dafis_i_have_brain_fail
16:39:02 <int80_h> dafis: http://hpaste.org/43494/dafis_i_have_brain_fail
16:39:34 <astroboy> glguy: ok... so what should I do if I just want to have a loop inside the running thread that waits for events and processed them?
16:40:18 <glguy> astroboy: I haven't used the dbus library before. Why did you want to fork anyway? Could you run the runDbus function in the main thread?
16:40:22 <dafis> int80_h: http://hpaste.org/43495/curlresp
16:40:46 <astroboy> glguy: I tried, but "dbus: thread blocked indefinitely in an MVar operation"
16:41:04 <astroboy> glguy: The thing is that
16:41:04 <Veinor> dcoutts: that might be it, yeah
16:41:15 <astroboy> I think that by default it makes an async call
16:41:35 <Jotta> "type Types = Integer | String" What should I look to get this understood?
16:41:54 <ddarius> Jotta: A different language.
16:41:55 <dafis> Jotta: that doesn't work
16:42:15 <Jotta> But data Types = A | B etc does ?
16:42:22 <dafis> Jotta: data Types = Integer | String would work
16:42:24 <astroboy> glguy: actually that mainLoop just calls forever "receive"
16:42:30 <dcoutts> Veinor: so the root of the problem is that cabal-install does not yet understand the concept of there being multiple instances of the same version of a package, and is just picking one at random. We're currently rewriting the dep solver to make it understand.
16:42:38 <Veinor> dcoutts: ah, okay
16:43:42 <dafis> Jotta: "type" introduces a type synonym, an alias for an existing type, e.g. type String = [Char]
16:44:33 <glguy> astroboy: just for testing purposes add a "getLine" at the bottom of your main body
16:44:41 <glguy> astroboy: (and then don't type in a line)
16:44:51 <Jotta> dafis: I see. If I say type Const = (Name, [Types]), then I can do data Types = I | S. How would I then define what I and S are? I :: String ?
16:45:01 <int80_h> dafis: in the interest of me not blindly typing in things people spoonfeed me, could we talk about what this new code does?
16:45:09 <int80_h> before I try it out
16:45:15 <glguy> astroboy: other ways to keep it alive would be to have the handler talk back to the main program through a chan or mvar
16:45:38 <dafis> int80_h: it just makes sure the response body is evaluated before curlResp is left
16:45:40 <hpc> Jotta: I :: Types
16:45:42 <hpc> S :: Types
16:45:46 <int80_h> dafis: this is a new use of length, what's going on there? And I never use seq, so I'm not sure what that does.
16:45:50 <astroboy> glguy: mhm it stays there, and I'm pretty sure that I've got dbus events happening
16:46:03 <hpc> Jotta: how do you add a parameter to a data constructor?
16:46:04 <int80_h> dafis: oh okay
16:46:21 <hpc> (hint: data Maybe a = Nothing | Just a)
16:46:35 <Jotta> hpa: type variable
16:46:53 <dafis> int80_h: x `seq` y evaluates x to WHNF whenever y is demanded, to evaluate the entire response body, we evaluate its length
16:47:16 <hpc> so, Jotta, how would you make a type with a constructor that takes an Int?
16:47:34 <int80_h> dafis: ah I may soon be able to generalize trhat and have a new trick
16:47:44 <Jotta> hpcc: I :: Int -> Types ? or is it Types -> Int ?
16:47:50 <dafis> int80_h: it's an old trick :)
16:48:04 <int80_h> new for me! I'm a n00b.
16:48:54 <hpc> Jotta: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
16:48:56 <dafis> int80_h: I've no idea whether laziness is actually your problem here, so it may help nothing
16:48:57 <hpc> ^ start there
16:49:19 <astroboy> glguy: Yeah I don't know much about concurrency in haskell, but still it doesn' tseem to receive events
16:49:30 <hpc> Jotta: if you want to make a type that can hold an Int or a String, you write
16:49:41 <hpc> data Types = I Int | S String -- Jotta 
16:50:00 <hpc> the link will help you understand why, and what you do with it
16:50:15 <Jotta> hpc: I see, thanks *reads*
16:50:24 <int80_h> dafis: well, I'm out of ideas. If nothing else I'm learning something new. I decided to pick haskell for this task in order to work toward mastery of the language. So, learning new things helps. I've got two alternative approaches if I fail to figure out what is broken about this code.
16:51:00 <glguy> astroboy: it doesn't think anyone could ever send a dbus event on the channel that it is waiting on, so it quits the program
16:51:03 <dafis> int80_h: Alternative options are good, what have you in mind?
16:51:11 <glguy> perhaps you have to do something else to get events to the client
16:51:29 <glguy> and the runDbus is only for evaluating those events that you send to the client
16:51:36 <int80_h> dafis: we can grab the header right out of the response as it happens right?
16:51:54 <dafis> int80_h: I suppose so
16:52:14 <int80_h> dafis: this is ideal, I think. What we're trying to fix is my initial design. Which as my boss pointed out, relies on *side-effects* (parsing a file).
16:52:14 <saikobee> How can I express ```point x = x --> x``` in points free?
16:52:32 <hpc> @src join -- saikobee 
16:52:38 <hpc> er
16:52:42 <saikobee> what?
16:52:47 <astroboy> glguy: why is that? basically I'm trying to have a haskell equivalend of this: http://hpaste.org/43496/dbus
16:52:54 <hpc> for functions, join f x = f x x
16:52:59 <hpc> saikobee: ^
16:53:12 <hpc> point = join (-->)
16:53:20 <astroboy> glguy: I mean how hard can it be :P
16:53:25 <saikobee> hpc: i got it after you pointed me at join, thanks
16:53:26 <dafis> int80_h: yes, relying on side-effects may be fragile
16:53:31 <saikobee> hpc: i just didn't know the name of the function
16:53:32 <int80_h> dafis: even so, I still feel I must know why my old code is broken. Even if the design was wrong to begin with and I should just be capturing the headers 
16:53:38 <hpc> saikobee: yeah, join is magic
16:54:05 <saikobee> ty
16:54:13 <int80_h> dafis: not knowing drives me bonkers
16:54:27 <dafis> int80_h: I know that feeling
16:54:44 <saikobee> hpc: do i have to import join from something? ghc isn't seeing it
16:54:55 <hpc> Control.Monad
16:55:25 <int80_h> dafis: the second way is a horrible kludge. I could write a wrapper, that calls my program and redirects standard error to a file. I can then parse the file. I hate that idea, but if I can't figure out the right way I'll have to.
16:55:31 <astroboy> glguy: actually I would be happy just to catch all the dbus events right now. thanks btw
16:55:54 <dafis> int80_h: that is indeed a horible kludge
16:55:56 <glguy> astroboy: I've never used the dbus library and I don't have dbus to test it with, so I can't help you with the particulars of the library
16:56:03 <dafis> horrible*
16:56:47 <int80_h> dafis: I'm going to try what you suggested right now. Whatever happens, would you be willing to help me work out how to capture the headers?
16:56:55 <int80_h> which is the right way I think
16:57:23 <astroboy> glguy: thanks anyway!
16:57:38 <dafis> int80_h: it's a little after 2 am here, so not this night, but in general, yes, I'd be willing
16:57:53 <int80_h> dafis: oh thanks. No worries I can find you tomorrow.
16:58:30 <int80_h> there are other pieces to my puzzle I can work on in the meantime
16:58:45 <dafis> int80_h: Okay, how long will the test take, is it worth waiting for the result?
16:58:59 <astroboy> glguy: is just that that code seemed to be the equivalent. what did you mean with "it doesn't think anyone could ever send a dbus event on the channel that it is waiting on, so it quits the program"?
16:59:00 <int80_h> dafis: this is easy I just need to finish typing this
16:59:10 <int80_h> dafis: it's small and compiles very fast. in seconds
16:59:22 <dafis> and runs in?
16:59:36 <dafis> seconds, minutes, hours?
16:59:41 <glguy> astroboy: the message you got meant that the thread was listening on a channel where the write end of the channel had been garbage collected
16:59:55 <int80_h> dafis: runs in seconds as well
16:59:58 <glguy> so there must be some other process that is supposed to be running that writes to the write end
17:00:21 <glguy> or the thing on the write end died...
17:00:57 <astroboy> glguy: oh ok
17:01:30 <int80_h> dafis: no change. No cookie jar
17:01:45 <int80_h> dafis: does that mean order of evaluation is not the problem?
17:01:49 <dafis> drat
17:02:06 <dafis> int80_h: I don't know what that means
17:02:38 <dafis> int80_h: I'll get some sleep now, see ya tomorrow
17:02:52 <int80_h> dafis: okay well, I think the answer is in the strace readout. But since it's the wrong approach anyway it may make sense to let it go and move in the right direction.
17:02:58 <int80_h> dafis: see ya
17:05:31 <astroboy> import qualified Data.Text.Lazy as B
17:05:38 <astroboy> ops sorry
17:11:57 <shapr> Good Morning Haskellers! How's code?
17:12:58 <olsner> shapr: hey! do you know how many ipv6 addresses brazil has?
17:13:01 <olsner> *half of them*
17:13:06 * shapr blinks
17:13:08 <Twey> Gosh
17:13:14 <olsner> well, 45%
17:13:15 <shapr> Wait what? How the heck did they do that?
17:13:20 <Entroacceptor> olsner: whuttheeff?
17:13:22 <Twey> What are they doing with them all?
17:13:29 <shapr> olsner: Isn't that like, more addresses than humans?
17:13:39 <Entroacceptor> I know the german military has more than ipv4 addresses exist...
17:13:48 <Entroacceptor> but that is just ridiculous
17:14:01 <davean> I think olsner means assigned IPv6 addresses?
17:14:24 <olsner> davean: yeah :D but it sounds so much better if you only count assigned ones
17:14:28 <shapr> Some of the IPv4 addresses may be reallocated.. I know there's one house (four roomies, iirc) at MIT that has its own class A.
17:14:51 <ddarius> shapr: If every human had a planet full of humans, that would be a bit over 50%.
17:14:54 <shapr> olsner: Actually, you have a good point, how do I get native IPv6 in the USA?
17:15:06 <olsner> but they have allocated a staggering portion of the total available too, a whole /16 prefix
17:15:28 <davean> shapr: live in a datacenter
17:17:25 <ddarius> Er, actually I'm wrong, let those humans on the planets have their own planets with humans on them having planets of humans, then we'd run out.
17:17:31 <ddarius> But not by much.
17:21:37 <shapr> davean: Ya know, I could totally go for that... small expensive but extremely low-ping apartments...
17:22:22 <ddarius> You could setup your Cells.
17:28:59 <davean> shapr: good ping and good bandwifth, all one really needs, right?
17:30:58 <davean> shapr: my laptop is terrible for games or I'd play a lot more from NOCs
17:34:11 <Jotta> Whats the highly recommended copy and paste website nowadays?
17:34:35 <daryoush> I understand the building a list as in  [1] ++ [2] ++ [3] is slow, but I don't understand why this way its faster   (1:).(2:).(3:) $ []
17:35:11 <ion> hpaste, gist, mathbin depending on what features you need.
17:35:23 <daryoush> (1  :  ) . ( 2  : ) .  ( 3  :  )  $  []
17:36:12 <hpc> or codepad
17:36:25 <hpc> or dropbox if you have it installed
17:36:38 <Jotta> http://hpaste.org/43497/help <<<< Please can someone explain
17:37:42 <ddarius> daryoush: Build a list ass in [1]++[2]++[3] isn't slow.
17:38:04 <ddarius> Jesus that got mangled.
17:38:28 <hpc> build a list ass
17:38:32 <hpc> :D
17:38:39 <daryoush> it is slow in the sense that the list has to be traversed time
17:39:07 <ddarius> No.
17:39:39 <fryguybob> @botsnack
17:39:46 <hpc> no \bot
17:39:51 <fryguybob> :(
17:40:11 <daryoush> (++) :: [a] -> [a] -> [a]
17:40:13 <daryoush> (++) []     ys = ys
17:40:15 <daryoush> (++) (x:xs) ys = x : xs ++ ys
17:40:21 <hpc> (almost wrote that as ŒªŒ≤ŒøœÑ)
17:40:48 <daryoush> when you want to do  [1,2] ++ [3] you have to skip 1,2   
17:41:09 <ddarius> daryoush: [1]++[2]++[3] is [1]++([2]++[3])
17:43:23 <Jotta> hpc: http://hpaste.org/43497/help Am I on the right lines?
17:43:49 <hpc> Jotta: closer
17:44:08 <hpc> so rewrite your list one without GADTs
17:44:15 <hpc> since they aren't necessary in this instance
17:44:45 <Jotta> As in: data List = Nil | Cons (List) ?
17:45:12 <hpc> no, like this:
17:45:25 <hpc> data List = Nil | Cons Types List
17:45:39 <hpc> the source of built-in lists is
17:45:49 <hpc> data [a] = [] | a:[a]
17:45:56 <hpc> ie, you have a thing, which is the head
17:46:03 <hpc> and stuff going afterwards, which is a list
17:46:13 <Jotta> Ah ok
17:46:26 * ddarius has no idea what the logic is when people throw in blatantly superfluous parentheses.
17:46:30 <hpc> and you can rewrite trees in a similar way
17:46:38 <Jotta> Let me do this one
17:46:39 <hpc> ddarius: a java background?
17:48:44 <Jotta> data Tree = Types | Tree Tree ?
17:49:00 <Bynbo7> no
17:49:03 <hpc> Jotta: close, but you need constructors
17:49:21 <Jotta> data Tree = Leaf Types | Node Tree Tree ?
17:49:30 <hpc> indeed
17:49:43 <hpc> now, neat property of your tree, which might not be intended
17:49:49 <hpc> your tree cannot be empty
17:50:06 <hpc> just something to think about
17:50:13 <Jotta> data Tree = Empty | Leaf Types | Node Tree Tree <<< Also ?
17:50:19 <Jotta> Ah wait no
17:50:24 <hpc> no, that works
17:50:27 <Jotta> Types should have an Empty constructor
17:50:51 <Jotta> I suppose either way can work
17:51:38 <dino-> But if it's a situation where you're repeatedly appending something to a list, that left side has to be walked over and over.
17:51:45 <dino-> with (++)
17:52:42 <hpc> Jotta: and now you have learned yourself an abstract data types for great good!
17:52:50 <hpc> somewhat
17:53:03 <hpc> there are many miles left in the rabbit hole
17:53:09 <ddarius> hpc: It doesn't make any sense to write (x)+3 in Java either.
17:53:32 <hpc> ddarius: in any event, those people can be punished by making them use perl
17:53:38 <hpc> where () is the list syntax
17:53:40 <Jotta> hpc: :D
17:53:42 <kfr> How do you translate class constraints in Haskell to templates in C++?
17:54:07 <lispy> kfr: I thought type class constraints actually map to concepts in C++
17:54:10 <hpc> kfr: somewhat like this (in java, but i expect it to convert easily)
17:54:27 <hpc> class Constraint a => Class a where blah :: a
17:54:33 <hpc> v
17:54:33 <kfr> lispy not familiar with that, is that an 0xen thing?
17:55:05 <hpc> interface Class<T> implements Constraint<T> { public T blah(); }
17:55:20 <kfr> interface :o
17:55:27 <lispy> kfr: I guess so.  I lost track of whether they made it into the latest revision: "Concepts is a language feature planned for C++0x" http://www.devx.com/SpecialReports/Article/38864
17:55:42 <smarmy> concepts were abandoned
17:55:42 <hpc> the main point is the <T> part
17:55:46 <Jotta> hpc: Do I need "P Types Types" and "F Types Types" <<< Are they both not the same?
17:55:53 <hpc> you have to use generics ickiness
17:56:09 <hpc> Jotta: it depends on what they are; the constructors are different
17:56:21 <Jotta> hpc: How so?
17:56:30 <hpc> Jotta: consider this: data Shape = Circle Float | Square Float
17:56:30 <kfr> smarmy: Oh
17:56:38 <hpc> a circle has radius
17:56:42 <hpc> a square has side length
17:56:46 <kfr> So right now you'd have to use some hacks to really get class constraints, eh?
17:56:48 <hpc> yet both are different shapes
17:56:55 <kfr> Like, using RTTI stuff?
17:57:04 <smarmy> kfr: yeah.  which is a shame... stepanov's "elements of programming" was a beautiful work that will now never come to fruition
17:57:41 <hpc> Jotta: so i suppose the question is, what do P and F stand for?
17:58:38 <Jotta> hpc: Ah ok so just for easier reading and understanding of the code? Which in this case bad pratices me using single letters
17:58:57 <hpc> Jotta: in that case, pick one
17:59:10 <hpc> Jotta: P and F are different constructors, like Circle and Square
17:59:24 <Jotta> hpc: Im with you
17:59:27 <hpc> Jotta: so if you want them both to work, you need a pattern for both in every function that would otherwise only need one
18:00:08 <Jotta> hpc: I think I get you
18:00:18 <Jotta> hpc: No wait, I do
18:00:23 <hpc> :D
18:01:15 <Jotta> hpc: How do I represent List now as the type synonym DataType?
18:02:29 <Jotta> hpc: I know type synonym's are only for easier reading of the code, do I start at the base and go up? e.g. start with Nil and Cons (List) ?
18:02:47 <hpc> Jotta: not sure entirely what the code is going to accomplish, so can't answer that question
18:03:04 <Kaidelong> I'm starting to think that trying to make a pure system for GUIs is inherently a bad idea
18:03:38 <hpc> Kaidelong: yeah, unless you roll your own monad or some disaster like that
18:03:42 <Kaidelong> Better to have controls push their state into the pure code
18:04:17 <Jotta> hpc: I want to basically create a storage http://hpaste.org/43497/help has e.g. 's to see what im trying to do
18:04:20 <Kaidelong> rather than wiring together controls from the other end
18:04:24 <ddarius> Kaidelong: Read Rob Pike's, "A Concurrent Window System"
18:04:52 <hpc> oh, i see the comment now
18:05:09 <hpc> so you want data List = Nil | Cons DataType List
18:05:17 <hpc> which will make a list of DataTypes
18:06:05 <daryoush> so I have two version of reverse of list, one that uses the ++ and one that uses "." 
18:06:07 <daryoush> r1 [] = []
18:06:09 <daryoush> r1 (x:xs)  = r1 xs ++ [x]
18:06:12 <Jotta> hpc: Yep
18:06:15 <daryoush> r2 :: [a] -> [a] -> [a]
18:06:17 <daryoush> r2 [] = id
18:06:19 <daryoush> r2 (x:xs) = r2 xs.(x:)
18:06:20 <Jotta> hpc: So List is one DataType being stored
18:06:23 <daryoush> do you expect one to be faster than the other?
18:06:37 <augur> daryoush: the latter shouldnt work at all.
18:06:38 <hpc> Jotta: it's as many as you feel like ;)
18:06:49 <hpc> it's a list, after all
18:06:57 <Jotta> haha true
18:07:00 <augur> well, it might but its not reverse
18:08:01 <augur> itll be reverse if you give it the empty list as an argument
18:08:09 <hpc> and it's late, so ima head off
18:08:11 <daryoush> angur it does,  
18:08:13 <daryoush> Main> r2 [1..10] []
18:08:14 <augur> r2 xs [] ~ r1 xs
18:08:15 <daryoush> [10,9,8,7,6,5,4,3,2,1]
18:08:30 <augur> but its not the reverse function
18:08:31 <ddarius> daryoush: Expand the foldl definition of reverse.  The eta expand your code.
18:08:44 <ddarius> s/The/Then/
18:09:03 <augur> its the function \xs ys -> reverse xs ++ ys
18:09:44 <daryoush> The reason why I am looking at this is that this is example in "Reinventing Haskell Backtracking" paper
18:10:04 <Jotta> hpc: I want to work from the data type definitions, and then add this to this storage collection of DataType's. List and Tree are just two
18:10:08 <daryoush> it says ++ version is quadratic time, where as the other one is linear
18:12:09 <Philippa_> running a bunch of ++ with the wrong associativty is quadratic, yeah
18:12:12 <kfr> "You know how they say that when you have a problem and you decide to use regular expressions to solve it, you now have two problems? Well, Haskell is the opposite in that regard. You start out with a problem, then you go through a lot of trouble to actually learn the language and then you no longer have the problem in the first place because you have lost interest in programming." - by Philip Wadler, from "Faith, Evolution, and Programming Languages", April 
18:12:12 <kfr> 2007
18:12:39 <gwern> ouch, if even wadler doesn't like us...
18:13:03 <augur> kfr: lmfao
18:13:07 <augur> so not true
18:13:07 <kfr> gwern maybe it's part of the "avoid success" doctrine
18:13:09 <Jotta> lol
18:13:34 <augur> daryoush: entirely possible, but thats just because you're designing the function wrong ;)
18:13:55 <geheimdienst1> a programming language that makes you lose interest in programming would be very good at avoiding success
18:14:09 <daryoush> angur the point is not to do reverse, but it is how backtracking would be reduced too
18:14:16 <daryoush> reverse is example
18:14:23 <augur> you keep spelling my name wrong
18:14:23 <daryoush> to demonstrate the point
18:14:37 <daryoush> augur  ... Sorry!
18:14:41 <augur> there you go
18:14:54 <Bynbo7> daryoush: hit au<tab>
18:14:56 <Kaidelong> geheimdienst1: I am not sure that this is true
18:15:30 <Kaidelong> look at the number of people in the C# and Java world who do not embrace the humblest of features such as LINQ
18:15:46 <Kaidelong> for them programming is not interesting in itself
18:17:26 <Jotta> You can teach a monkey to program, but you cant teach a monkey to think about programming
18:17:28 <Jotta> :D
18:17:38 <augur> Jotta: actually you cant teach a monkey to program.
18:18:11 <Jotta> augur: You can. Button A and then Button B = Food.
18:18:13 <Kaidelong> augur: People have tried, I take it?
18:18:25 <augur> thats not programming
18:18:45 <augur> by that logic, my grandmother is a programmer because she can use an oven.
18:18:52 <Jotta> Quite right
18:18:57 <augur> no.
18:19:01 <Jotta> Yes
18:19:10 <augur> thats stupid go away
18:19:13 <Jotta> lol
18:19:16 <geheimdienst1> Kaidelong: hm, yeah, i read wadler as saying people with no interest in programming don't program. that's true maybe in an academic setting or among hobbyists :) you're completely right for industry. i've seen it myself
18:19:45 <Kaidelong> geheimdienst1: for what it is worth I'm working with undergraduate students here
18:19:51 <Kaidelong> and I am one
18:20:01 <Kaidelong> but I guess most of them will end up in industry
18:22:46 <Jotta> Don't you mean working in some large firm that will crush creativity, starting them off in test data drilling the creativity out of them, forcing them to employ standards some old timer in the corner has decided in using?
18:23:23 <Kaidelong> Jotta: No, I just mean that people think good features that make programming easier are a waste of their time, and that programming is about making something that works
18:23:49 <smarmy> hey, goto's get the job done
18:23:53 <Jotta> Very true
18:23:54 <Kaidelong> I personally feel that if you don't keep up with new features you start to make ugly code, and that programming is about making something that is beautiful
18:24:17 <Jotta> When a job is about the money: The end result is all that matters. Remove money = Better programmers.
18:24:20 <Kaidelong> And I must say C# and Java give a lot of ways to make things beautiful, but people do not bother
18:24:34 <Kaidelong> (even in the standard libraries)
18:24:40 <joe6> Kaidelong: from my experience, feature-creep kills the project. First, get something working and then start to add in features.
18:24:57 <Kaidelong> joe6: Sure, but that wasn't really what I was talking about
18:24:57 <Jotta> Pre-mature optermisation = Bad.
18:25:16 <Jotta> To make better programmers, we must stop paying them :D
18:25:53 * gienah I see am on the right track then (being unemployed)
18:25:58 * Kaidelong more means building things with, y'know, an architecture. And being professional. This seems lost on people who think objects are data structures and the point of making them is to have a huge blob of code in main that manipulates them directly
18:26:09 <Kaidelong> And those people seem to be the vast majority
18:26:41 <smarmy> every bad programmer is just someone who got the comp sci degree because they thought they could write video games
18:27:09 <mafs> isn't that the only reason to go for a comp sci degree?
18:27:15 <smarmy> pretty sure
18:27:27 <mafs> awesome. got scared I made the wrong choice for a second ;)
18:27:43 <Jotta> Again we each have our views on the matter. But it all comes down to the fact they are doing A (in this programming) for B (in this case money), remove the B and you are left with: A for? Because I want to.
18:28:41 <smarmy> remove the money and i'm applying to mcdonalds, because damned if i'm going to program for fun huddled in a cardboard box in the snow
18:29:13 * gienah is close to that situation :-)
18:29:22 * Jotta is waiting for his reply
18:29:23 <Philippa_> smarmy: you missed everyone who applied during one of the dot com booms
18:29:40 <Philippa_> and the many bad programmers who just had to write a small program for some task and ended up getting more such tasks bundled on them
18:30:00 <geheimdienst1> i'm not sure money is the only factor of the solution. there's enough open-source hobbyists which happily come up with complicated idiotic stuff because of they latched on to some misguided ideal
18:30:01 <smarmy> oh, yes.  the dot coms and the corporate IT script jockeys
18:31:29 <Jotta> Well the alternative is we lobby programmers. Have a 'stamp approved' system on code. Goodluck getting that in play
18:31:39 * Kaidelong thinks that software development should more be seen as art than engineering
18:31:53 <Kaidelong> it is collaborative and it solves practical problems
18:32:05 <Kaidelong> but that should be seen as making it a special kind of art, not excluding it from being art
18:32:07 <geheimdienst1> peer review anybody?
18:32:25 <Jotta> But I do believe programming alone is an old idealist way of doing something. Imagine if a doctor only used his own head to treat you :s
18:32:26 <Adamant> Jotta: regulation could work, but only if it was smart regulation, which won't happen
18:33:40 <Adamant> requiring certain levels of security and stability for important shit might need to be mandatory at some point. the main thing is to emphasize testing and goals and let industry accomplish that in whatever manner verifiably works.
18:33:55 <drbean> You can lead a horse to the computer, but you can't make it think.
18:34:31 <Jotta> In order to come up with some 'stamp-approved' system that sells it has to be: recognised widely and have benefits. BCS is one such
18:34:51 <Adamant> Jotta: I think those sorts of systems are in general idiotic
18:34:54 <joe6> i have [[a]] -> [b] and I want to splinter [b] to [[b]] based on the length of [a] in [[a]]. I am thinking of writing a recursive function to do it.
18:35:02 <Jotta> Adamant: I do too
18:35:04 <joe6> just curious if there is a smarter way of doing this?
18:35:10 <geheimdienst1> i'm kind of a fan of code review, i.e., any commit you make will be checked and thought through and discussed with your coworkers
18:35:45 <Adamant> the goal should be "program should survive threat x" or "program shall maintain so many 9's of uptime in simulated worse-than-real situation"
18:35:57 <gienah> last time I had a code review my co-workes could not understand my code, no comment at all :-)
18:36:17 <joe6> gienah: time to get better co-workers?
18:36:27 <geheimdienst1> time to write clearer code ...
18:36:28 <Jotta> Or the alternative to coming down on people is to go up on them, do what we do for high court judges or priministers, pay them so much that they are no longer doing it for the money but rather the love of doing it
18:36:42 <gienah> my co-workers are clearly better since they are working and I'm not
18:36:48 <Kaidelong> joe6: You should be able to do that with a fold, actually
18:36:51 <Adamant> there are software engineers making more than democratic heads of state
18:36:55 <Adamant> don't think that will work
18:37:12 <Kaidelong> err, a scan in this case
18:37:48 <Kaidelong> but writing it recursively might be clearer
18:37:51 <Philippa_> Adamant: SWeng people making that much can often fuck up on a similar scale to a democratic head of state if not more so
18:37:59 <Kaidelong> (if I am understanding what you want to do, which I am not sure I do)
18:38:10 <Philippa_> (democratic head of state should /not/ be one of the highest-paying jobs in the world, either)
18:38:26 <Jotta> I demand we make all code public and open to comment and ranking.
18:38:34 <Philippa_> (also: the SWeng person's likely to be a lot more liable for such fuckups!)
18:39:07 <Jotta> Ok, ok I suggest we start the final frontier of programming now....
18:39:46 <Philippa_> (there's not enough money to pay everyone in a safety- or substantially-financially-critical engineering job in the 6 figures range by a long way though)
18:40:00 <Jotta> ...no longer shall we program to syntax, lines and objects. I suggest we create the ultimate system where you select your input of data and output and click 'MAKE ME A CAKE!'.
18:41:00 <gienah> even in a safety critical code role, mgt explained to me that they could direct me to write code that had design flaw bugs built in, it was when I refused that I was forced to resign
18:41:05 <Philippa_> at which point you'll inevitably get lied to, of course
18:41:11 <Jotta> And have this sytem maintained by only 50 people. Who do it for the recognisation of maintaining such a system.
18:41:36 <Philippa_> gienah: they can indeed direct you to, but you'd be potentially committing a criminal offence by accepting that direction so hey
18:42:04 <Philippa_> (that said: I hope you were in a position to go for constructive dismissal in some form :-( )
18:42:06 <gienah> that's what I thought, it went against the engineering training to do it
18:42:29 <jmcarthur> gienah: holy crap
18:43:08 <Adamant> Philippa_: agreed
18:43:10 <gienah> this was after 3 design reviews which I sort of thought I had won technically
18:43:18 <geheimdienst1> how bad were these design flaws? manageable or killing-people bad?
18:43:30 <gienah> it was a data race
18:43:43 <Adamant> gienah: look at whistlerblower laws
18:43:49 <Adamant> depending on where you are located
18:44:03 <Adamant> if they're not compensating for the flaw somewhere else
18:44:08 <gienah> I had written a bunch of asychronouse IO type code, which whey could not understand, and was directed to write the second half with threads
18:44:21 <gienah> which would introduce a data race, which I explained
18:44:33 <Philippa_> gienah: *wince*. That I can sort of understand how it happened, but... yeah
18:44:35 <Adamant> and they're writing safety-critical code, that's borderline or actually criminal
18:44:35 <gienah> if I did it, then testing would have recorded the bug, which I could not fix
18:44:43 <Philippa_> gienah: internal company politics in a fuckwit-friendly company? Sucks
18:44:58 <gienah> it was govt
18:45:08 <jmcarthur> of course it was
18:45:11 <Philippa_> whereas race conditions are often suspiciously heisenbug-like :-(
18:45:11 <jmcarthur> *sigh*
18:45:13 <Jotta> ha
18:45:22 <Philippa_> gienah: like I said, fuckwit-friendly :-)
18:45:39 <geheimdienst1> so they wanted to be able to understand the second half, and assumed when they said "do it with threads" that would get them there ...?
18:45:53 <gienah> that's what the manager thought
18:46:11 <gienah> but actually it would have made it worse, as it would have had both threads and asynch io
18:46:36 <Philippa_> yeah. Do not change concurrency policies mid-system...
18:46:41 <Philippa_> well, not without rewriting the first half
18:46:53 <gienah> the first half had already passed testing
18:47:07 <geheimdienst1> so you weren't able to reach some compromise? say by going async but making things clear and documented
18:47:16 <gienah> no
18:47:32 <shapr> Yah, source code is primarily a means of communicating with programmers (often times yourself at a later date).
18:47:54 <jmcarthur> shapr: sure, but not at the expense of correctness, especially with safety critical code :\
18:47:57 <geheimdienst1> shapr, you're so completely right i want to hug you
18:48:02 <Philippa_> gienah: and because it's government they're running waterfall and "passed testing" = "cast in concrete", right?
18:48:21 <gienah> it was very thorougly tested
18:48:45 <jmcarthur> "if you want to change it you're go through Hell for it"
18:49:01 <jmcarthur> *going
18:49:04 <gienah> it seemed difficult to me, sure the asynch io code was hard to follow, but it did avoid threading issues
18:49:10 <shapr> jmcarthur: Yah, correctness is paramount for safety critical code.
18:49:14 <Jotta> http://hpaste.org/43499/help Simple help Required. Not sure how to use type synoms properly
18:49:57 <erikc> async io is far far preferable to threading
18:50:21 <ddarius> threading is far far preferable to async io
18:50:31 * jmcarthur agrees with ddarius and not erikc
18:50:32 <Axman6> use them both!
18:50:37 <erikc> :)
18:50:51 <ddarius> Axman6: That's what you get with GHC.
18:50:55 <gienah> haskell has a great model for this, as it has the asynch io in the event mgr, and the higher level code can use lightweight threads
18:50:58 <jmcarthur> yay ghc
18:50:59 <Axman6> threading leads to easier code, and in haskell, almost the same performance
18:51:07 <Axman6> ddarius: indeed :)
18:51:26 <Philippa_> threading isn't always easier, it depends on what other constructs you have available
18:51:28 <erikc> are the ghc lightweight threads system threads or green threads
18:51:34 <Axman6> green threads
18:51:36 <erikc> ok
18:51:45 <Axman6> they're pretty much the lightest weight threads around too
18:51:47 <erikc> async io /w green threads is far far preferable to system threads and blocking io
18:51:49 <jmcarthur> i love how the shortest, most naively written web server can give me 16000 requests per second on my cheap laptop
18:51:49 <Axman6> lighter than erlang's
18:51:53 <erikc> is what i meant
18:52:17 <jmcarthur> yeah it's like 68 bytes per thread overhead (plus a variable sized stack starting at 1K) on 32 bit machines
18:52:50 <gienah> using asynch io in application level code is kind of crazy really, like I made it work but my co-workers could not follow it
18:52:57 <gienah> so node.js seems crazy
18:53:09 <gienah> its a huge advantage of haskell and erlang
18:53:12 <jmcarthur> i've done it, but it was only for something pretty simple
18:53:35 <smarmy> we manage a completely async system
18:53:57 <smarmy> it's basically a giant FSM document and a bunch of unreadable code to match
18:54:01 <Jotta> http://hpaste.org/43499/help Anyone advice?
18:54:24 <pastorn> Jotta: deactiveta GADTs?
18:54:25 <Rotaerk> hrm, what do you use to do erlang-style message passing in haskell?
18:54:46 <pastorn> Rotaerk: constructors?
18:54:47 <gienah> Rotaerk: channels ?
18:55:06 <Jotta> pastorn: Deactivate it?
18:55:08 <jmcarthur> erlang-style message passing is rarely the easiest or cleanest way to go about it, IMO
18:55:16 <pastorn> Jotta: you're not using it
18:55:24 <jmcarthur> erlang uses message passing because it's easy to clean up when something goes horribly wrong
18:55:28 <Rotaerk> hmm it's how I've architected my game in F# so far
18:55:34 <gienah> I used to like it with occam
18:55:53 <Rotaerk> and the architecture makes perfect sense in this case, imo
18:55:59 <Jotta> pastorn: True. How do I go about creating the ListOfDataType for an example?
18:56:00 <Philippa_> jmcarthur: you can tweak the default thread stack size too, can't you? (as an RTS command line parm)
18:56:04 <jmcarthur> like when a process crashes it's typically pretty easy to recover partly due to how message passing works
18:56:06 <jmcarthur> Philippa_: yes
18:56:19 <pastorn> Jotta: a what?
18:56:41 <jmcarthur> Philippa_: which is why i only included that part in parens :)
18:56:56 <Jotta> pastorn: I want to create a "exampleListOfDataType :: [DataTpe]"
18:57:17 <pastorn> Jotta: ehm... i don't get it... what's your goal here
18:57:19 <Philippa_> ah, it won't let you set it smaller than 1K? Fair enough
18:57:30 <Axman6> if a, b and c are all of the same type, then just use [a,b,c] :\
18:57:35 <jmcarthur> Philippa_: if that's the case i wasn't aware of it
18:58:08 <Philippa_> mmm, so defaulting to 1K initially rather than always starting there then
18:58:19 <Philippa_> (I've definitely written threads that could get by on a tenth of that as stack size)
18:59:06 <Jotta> pastorn: How do I turn the e.g.'s into actual code ?
18:59:13 <jmcarthur> i wonder if there is a way to set it dynamically (fork thread A with default stack size M, thread B with default stack size N)
18:59:29 <jmcarthur> i keep saying default because it's still variable
18:59:51 <Philippa_> that would be rather nice, yeah. Then you could typeclass a bunch of stuff up and newtype around some of your threads with preferred stack size annotations
19:00:16 <pastorn> Jotta: ehm... i still don't get it... what is it you want to achieve? just practice writing datatypes?
19:01:09 <pastorn> Jotta: you could start reading here: http://en.wikibooks.org/wiki/Haskell/More_on_datatypes
19:01:18 <pastorn> wikibooks is good stuff
19:03:44 <Jotta> pastorn: I want a file of data types, pass them in and them create there folds underneath there defintions. This is the start of that
19:05:02 <Jotta> pastorn: How would I pass in, say 'List' into ListOfDataType ? 
19:07:28 <Jotta> [("List", [("Nil", [I Int| S String	| P Types Types| F Types Types| DefType]),...]),...]
19:07:36 <pastorn> Jotta: ouch
19:07:37 <Jotta> How do I get there from http://hpaste.org/43499/help ?
19:08:08 <pastorn> Jotta: and you can't put all the constructors in a list like that
19:08:23 <Jotta> I know I cant. But it shows what im aiming to do
19:08:32 <pastorn> Jotta: is there some real world use for this or are you just exercising mental masturbation here?
19:08:46 <Jotta> I want to know how to do it
19:09:08 <Philippa_> pastorn: there's plenty of use for a generic fold
19:09:44 <Philippa_> (especially one that works for a binding group of mutually-recursive datatypes!)
19:10:29 <Axman6> Jotta: from what you've pasted, i have no idea whatsoever what you're trying to do
19:10:40 <Philippa_> if I had a monadic one /and/ generated syntax naming constructors etc when I write one it'd make so, so much of the code I write quicker to write
19:11:26 <Jotta> Axman6: I want to look at a data type and store the information about it, so I can iterative over and take out what I need to create the fold for it
19:11:36 <roconnor> deriving Foldable?
19:12:04 <Philippa_> roconnor: not sure that could work for the mutually-recursive case at the moment
19:12:06 <Jotta> But im not at the fold point yet
19:12:15 <Axman6> sounds like Foldable, or maybe Data?
19:12:17 <Philippa_> (because it's tied to an individual datatype and there's no way to group up a binding group)
19:12:53 <Jotta> I'm aiming for the Foldable yes. But I have yet to just get the information out so I can iterative over it how I see fit
19:13:05 <roconnor> Philippa_: have you seen my Multiplate?
19:13:44 <Philippa_> roconnor: nope, I take it I should have a look?
19:13:58 <Jotta> phoneBook :: [(String,String)]
19:13:58 <Jotta> phoneBook =    
19:13:58 <Jotta>     [("betty","555-2938")] <<<< Same idea. But I want to use the data type to construct it
19:14:03 <Philippa_> (I've been mostly out of touch for a couple of years, so I guess I should be checking what's extant more before commenting at the moment)
19:14:07 <roconnor> @wiki Multiplate
19:14:37 <roconnor> Philippa_: http://haskell.org/haskellwiki/Multiplate
19:14:50 <roconnor> Philippa_: I made it in December
19:15:19 <roconnor> Philippa_: it isn't really automatic (though I think it could be) but it does support mutual recursion
19:15:33 <Philippa_> mmm. Will it net me a usable monadic fold yet?
19:15:39 <roconnor> I haven't really exercised the library much yet
19:15:47 <roconnor> Philippa_: yes
19:16:00 <Axman6> Jotta: i don't get what you mean by 'you want to use a data type to construct it' that's already full of datatypes
19:17:18 <Jotta> Are my e.g.'s correct : http://hpaste.org/43499/help ?
19:18:13 <roconnor> Philippa_: er, well it at least has a monadic map
19:18:37 <Axman6> Jotta: i think for the List, you want data List = Nil | Cons Int List
19:18:58 <Axman6> well, if you want the thing you have in the comments
19:19:53 <Axman6> Jotta: i think you might like to look at template haskell, which gives you access to these sorts of things
19:20:00 * roconnor wonders if a monadic fold makes sense
19:20:07 <roconnor> @type foldM
19:20:13 <roconnor> @bot
19:21:30 <smarmy> this reminds me of this for some reason: http://zenzike.com/posts/2010-12-10-from-polymorphic-to-polytypic/
19:21:34 <smarmy> although i know the goals are different
19:21:57 <Philippa_> roconnor: if you can pick a serialisation at all, it does
19:22:13 <Saizan> Jotta: maybe you could look at how Data.Data does this
19:22:14 <Philippa_> admittedly that's potentially a big if
19:22:20 <geheimdienst1> cale: ping? lambdabot is out watching cats on youtube
19:22:30 <Saizan> Jotta: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-Data.html#DataType
19:23:07 <roconnor> Philippa_: is m x a monoid when x is a monoid?
19:24:03 <Jotta> Using Data.Data how would I go about creating the fold for a given data type?
19:24:16 <ddarius> roconnor: Yes.
19:24:32 <roconnor> ddarius: can foldM be written this way?
19:25:44 <ddarius> roconnor: Where "this way" means via a fold :: Monoid m => t m -> m ?
19:25:51 <roconnor> yes
19:26:52 <ddarius> It would give a notion but not the right notion.
19:27:01 <Philippa_> hmm, I guess foldM does have the problem of what format you want to hand the subresults back in
19:27:13 <Philippa_> ideally you don't want to force traversal
19:27:28 <Philippa_> (which suggests handing them back in computation form, of course)
19:27:31 <Saizan> Jotta: you could also use an approach like this one, the fold is already implemented as "cata" there http://hackage.haskell.org/packages/archive/fixpoint/0.1.1/doc/html/Data-Fixpoint.html
19:28:49 <magicman> Two instances of Monoid would make sense... liftM2 mappend, and liftM2 (flip mappend).
19:29:02 <ddarius> magicman: More than that.
19:29:47 <magicman> Oh, right, and the flipped version of those, I guess, but you get that with any Monoid.
19:30:13 <magicman> (even more? are there more versions of mempty, other than "return mempty"?)
19:30:25 <Philippa_> roconnor: how hard's the results-as-computations version for you?
19:30:26 <ddarius> magicman: Well you get the latter one you mentioned in terms of the first by simply using the Dual monoid as the parameter.
19:30:39 <roconnor> Philippa_: what does that mean?
19:31:14 <Philippa_> normally a fold gives you the results for the child nodes as parameters, right?
19:31:26 <Philippa_> and in pure land, you effectively get stuck with a pun between values and computations?
19:31:29 <Philippa_> can't tell the difference?
19:32:04 <roconnor> a pun?
19:32:22 <Philippa_> the results-as-values implementation of a fold's the 'obvious' one when you lose that pun, but results-as-computations means the functions forming the fold can decide whether to run them or not
19:32:35 <Philippa_> they have the same type and they're indistinguishable at runtime
19:32:52 <Philippa_> in C-speak, you don't know if that Int is a 'value' or a function yielding an Int
19:33:10 <Jotta> Im getting myself so confused atm. Starting again... http://hpaste.org/43502/simple - How do I go about doing this? Question is there
19:33:18 <roconnor> Philippa_: is this the difference between getting an m a parameter vs an a parameter?
19:33:38 <Philippa_> yeah
19:34:17 <roconnor> Philippa_: well at the moment I can only fold over monoids
19:34:38 <Saizan> Jotta: the problem with answering that question is that Type is something defined by yourself, how would we know what P, F, and DefType are supposed to represent? i can guess I and S..
19:35:20 <Philippa_> ah, you're doing a list fold over the monoid, effectively? Yeah, I want the catamorphism on the datatype you'd have if you smashed the mutually-recursive ones together
19:35:38 <Jotta> If I remove all the others and leave I and S, how do I go about doing this?
19:35:47 <roconnor> Philippa_: I don't do that I don't think :(
19:36:31 <Philippa_> ah :-( Shame, most things I do with language manipulation that isn't parsing can be defined as such a fold over an appropriate monad or applicative
19:36:39 <Saizan> Jotta: no idea.. how would you represent the "List" field in Cons?
19:37:13 <Jotta> Saizan: Assume DefType is back in
19:37:28 <lostman> Jotta: I think you should have a look at Generics.Regular package
19:37:37 <roconnor> Philippa_: I have mapM :)
19:38:34 <lostman> it has all the plumbing already in place and you can use TH to generate conversion functions between your datatype and generic representation
19:38:37 <Saizan> Jotta: ("List",[("Nil",[]),("Cons",[I,DefType])]) then
19:38:38 <roconnor> Philippa_: actually I think cata is definable, but it isn't really safe, so I didn't implement it.
19:39:00 <Philippa_> mmm. What makes it unsafe?
19:39:27 <Saizan> Jotta: assuming i guessed correctly what you wnat DefType to mean.
19:39:40 <Saizan> Jotta: that's probably not going to help you write a generic fold
19:39:40 <roconnor> you give it a function parameter (data -> [a] -> a)
19:39:57 <roconnor> but the length of a depends on the paraticuar child passed to data
19:40:07 <roconnor> and that length dependence isn't captured by the type
19:40:28 <Axman6> > read . read . read . show . show . show $ 5 :: Int
19:40:36 <Axman6> :(
19:40:39 <roconnor> 5
19:40:45 <Axman6> hoorah
19:40:51 <Jotta> Saizan: Thank you - I was right in my thinking. What do you think not?
19:42:01 <Philippa_> roconnor: um, I'm not quite sure I see how the length matters there
19:42:23 <Saizan> Jotta: what would be the type of your generic fold?
19:42:23 <roconnor> Philippa_: the lenght of this list is the number of children the node has
19:42:24 <Philippa_> (I can see how it might be tricky in a total language, given that I can do things like smuggle an a or a [a] in via the monad...)
19:42:48 <roconnor> so typically the function you pass will do something like
19:43:03 <Jotta> Saizan: Ah of course, my plan is to take a data type and create the fold for it. I dont wish it to be generic at this point
19:43:11 <roconnor> foo (constructor1 _ _ _) [a1,a2,a2] = something with a1 a2 a3
19:43:25 <roconnor> foo (constructor2 _) [a1] = something with a1
19:43:36 <roconnor> foo (constructor3) [] = something
19:44:00 <Saizan> Jotta: what would be the type of a function that takes a data type and creates a fold for it?
19:44:02 <roconnor> and you risk pattern match failures if you get the length of those lists wrong
19:44:10 <Philippa_> ah, yeah, so it's the same unsafety as in uniplate. Gotcha
19:44:18 <roconnor> Philippa_: yes
19:44:37 <roconnor> Philippa_: multiplate is my extension of uniplate/compos to mutually recursive types
19:45:04 <Philippa_> yeah. If I'm willing to use uniplate-style code in the first place, I'm willing to swallow that unsafety
19:45:13 <roconnor> Philippa_: actually I haven't thought much about how para would extend to multually recursive types.  I suppose there could be other problems because I haven't thought about it.
19:45:14 <Jotta> Saizan: The type will be the name of the data type that it is being passed. I plan on using a parser, read a data defintions then add the folds to it
19:45:24 <question> Minor question: If I have a ByteString of length 4, what would be the best way to get that into a big-endian Word32?
19:45:47 <Saizan> you could define a pattern QQ, maybe, so that you can do foo [..| constructor 1 a1 a2 a3 |9~ = ...
19:45:59 <Saizan> Jotta: ah, so you're going to generate code?
19:46:07 <roconnor> ooh
19:46:09 <Saizan> Jotta: like in a preprocessor?
19:46:13 <roconnor> ndm links to multiplate now. :D
19:46:18 <Jotta> Saizan: Yes
19:46:27 <Saizan> Jotta: ah, ok, that makes sense then
19:46:58 <Philippa_> is the worry with para but not cata?
19:47:01 <Jotta> Saizan: Tree is ("Tree",[("Leaf",I),("Node",[DefType, DefType])]) ?
19:47:19 <Saizan> Jotta: but Data.Data.DataType should already have the same information then
19:47:22 <Saizan> Jotta: yep
19:47:22 <roconnor> craptastic http://community.haskell.org/~ndm/downloads/slides-uniform_boilerplate_and_list_processing-30_sep_2007.pdf is 404
19:47:44 <roconnor> Philippa_: isn't para just a generalized cata?
19:48:27 <ddarius> Philippa_: Most AST manipulations can be defined using attribute grammars which are monadic folds with the forward and backward state monad.
19:48:28 <Saizan> Jotta: because it contains a DataRep
19:48:51 <Philippa_> roconnor: that doesn't eliminate that possibility :-)
19:49:11 <ddarius> A para is a cata.
19:49:11 <Jotta> Saizan: Could you possibly make a very simple piece of code that shows me how to use it?
19:49:11 <Philippa_> ddarius: yeah, AGs aren't quite to my taste though - I prefer to have more choice in monads
19:49:25 <roconnor> Philippa_: would you be happy with a function cata :: ([a] -> a) -> data -> a ?
19:49:44 <roconnor> well I need to make that monadic
19:49:49 <Philippa_> roconnor: hmm, probably
19:50:08 <Philippa_> well, I would be for some purposes, anyway
19:50:24 <Philippa_> (for others I might need a mutually-recursive return type too)
19:50:53 <roconnor> Philippa_: I imagine monoid fold would be all you need for that cata
19:51:26 <roconnor> Philippa_: unless you use something other than mconcat for your function (something whose value depends signifigantly on the length of the input list)
19:51:30 <Saizan> ([a] -> a) is quite limited, you'd also want the values in the non-recursive fields of the constructor
19:51:45 <Philippa_> Saizan: good point!
19:51:50 <roconnor> Saizan: right, that is where para comes in
19:52:08 <Saizan> roconnor: no, cata already has those
19:52:41 <roconnor> Saizan: hmm
19:52:41 <Saizan> para adds the recursive fields :)
19:52:50 <Saizan> ?type foldr
19:52:51 <roconnor> ah
19:52:56 <roconnor> fair
19:54:38 <Saizan> Jotta: it seems i'm wrong, actually, Constr doesn't have the types of the fields in it
19:54:58 <Jotta> Saizan: Ok :(
19:55:15 <roconnor> para :: Uniplate on => (on -> [r] -> r) -> on -> r
19:55:16 <roconnor> para op x = op x $ map (para op) $ children x
19:57:06 <roconnor> tricky
19:57:49 <roconnor> I guess I'd like to see use cases of para to see if I can cobble something together
19:57:53 <roconnor> but for now I need to go to sleep
19:58:04 <roconnor> Philippa_: sorry I couldn't be more helpful
19:58:14 <kfr> How does Haskell's green thread stuff work on Windows/Linux really? Does it regular manual checks with some kind of cooperative scheduler?
19:58:17 <kfr> *does it involve
19:58:24 <Jotta> Saizan: Thanks for all your help
19:58:31 <Saizan> Jotta: np
19:58:36 <Philippa_> roconnor: no worries, I see it as having offered you an interesting use case to think about
19:58:50 <roconnor> is community.haskell.org broken?
19:58:56 <Philippa_> half of what I do around here is pair use cases with things that may be or become solutions, no?
19:59:00 <Axman6> kfr: i believe there's N OS threads, which all have access to the pool of green threads, anf they can all run any of those threads when they've finished anothert task
19:59:04 <Philippa_> regardless of whether they're actually implemented?
19:59:19 <ddarius> When did it become 11?
19:59:20 <Axman6> roconnor: yes, has been since the weekend, it's being moved to a new server
19:59:29 <roconnor> ok
20:00:22 <Saizan> kfr: GHC's scheduler can interrupt haskell threads only when they call back into the RTS for I/O or allocation
20:00:26 * Philippa_ wonders how easy it is do deforest the monadic bits of a monadic hylomorphism, and whether using different monads makes it trickier
20:00:30 <roconnor> Philippa_: anyhow.  Multiplate is sort of a generalization of unplate to mutually recursive types.  Perhaps you will find some use for it anyhow :)
20:00:32 <Philippa_> *to
20:00:57 <ddarius> factorial = paraNat (*) 1
20:01:01 <Saizan> kfr: or syscalls in general, i guess
20:01:33 * edwardk waves hello.
20:01:37 <roconnor> factorial = getProduct . foldMap Product
20:02:04 <kfr> Can you implement dependent types in Haskell?
20:02:12 <edwardk> @tell dolio apparently mac lane referred to those kinds of adjunctions as stuff like an "adjunction with parameter Y"
20:02:22 <ddarius> (Well, plus a one.)
20:02:51 <ddarius> edwardk: Do you have a copy of "Categories for the Working Mathematician"?
20:02:55 <roconnor> kfr: in GHC you have access to GADTs which has the ability to something vaguely like dependent types
20:02:55 <edwardk> ya
20:03:10 <ddarius> kfr: No.
20:03:25 <edwardk> ddarius: i just missed it on the first pass through =)
20:03:43 <edwardk> found a reference to it when googling for material on semifunctors and semiadjunections
20:03:57 <ddarius> edwardk: I wish it was a bit more encyclopedic, both in comprehensiveness and in organization.
20:03:59 <edwardk> er adjunctions even
20:04:18 <edwardk> its handy, but it kind of gets you to kan extensions then dumps you off
20:04:41 <ddarius> edwardk: That's fine.  Most introductions don't even mention Kan extensions or (co)ends.
20:04:45 <edwardk> i'm having fun with semigroupoids though. i can actually make semibifunctors into semifunctors, etc. =)
20:05:35 <edwardk> too bad semiadjunctions don't have the lovely uniqueness of real adjunctions though =/
20:06:34 <gienah> kfr: ur has dependent types
20:06:48 <kfr> I started hanging out in #esoteric and I was thinking about how to develop a language which makes runtime errors like out of range accesses on arrays impossible by its semantics and somebody told me that I might want dependent types for that
20:07:04 <kfr> Agda and Coq use that, right?
20:07:09 <edwardk> kfr: yeah
20:07:43 <Philippa_> kfr: "implement (dependent types) in (haskell)" or "implement ((dependent types) in haskell)"?
20:07:48 <Cale> You can even do it in Haskell, but it's rather awkward, because nontrivial type level programming in Haskell is hard.
20:08:08 <ddarius> edwardk: id is usually key to the uniqueness aspects.
20:08:14 <edwardk> yep
20:08:17 <Philippa_> adding dependent types to haskell and doing a good job of it's tricky. Cayenne and Agda are somewhere near the obvious points in the design space
20:08:26 <ion> How do e.g. compile-time out-of-bounds checks combine with IO? Please excuse my ignorance.
20:08:36 <gienah> kfr: http://www.impredicative.com/ur/
20:08:56 <kfr> ion: You could only provide some type of branching head function as the only primitive haha
20:09:00 <Philippa_> ion: the IO stuff returns things with a specific but statically-unknown length and you work polymorphically
20:09:03 <jmcarthur> ion: the type system would require you to perform the bound checks at some point
20:09:07 <gienah> kfr: yes agda and coq use dependent types, however they are not normal programming languages
20:09:10 <edwardk> but parameterized semiadjunctions are what i need to describe indexed bind/extend if i don't care about return, so its all good to me =)
20:09:27 <kfr> Which would basically be like maybeHead :: [a] -> Maybe a
20:09:29 <gienah> kfr: however you can write code in coq, and general haskell from the coq code :-)
20:09:40 <edwardk> :t listToMaybe
20:09:51 <lambdabot> forall a. [a] -> Maybe a
20:09:57 <edwardk> (its in Data.Maybe iirc)
20:10:01 <Adamant> they're Turing-limited, right?
20:10:01 <kfr> So every access of an element in a list would require accounting for all possible cases
20:10:10 <kfr> (element available vs. empty list error)
20:10:39 <kfr> Or you could provide nothing but map/filter/fold primitives which do not even let you access single elements explicitly haha
20:10:44 <edwardk> kfr: typically with dependent types, you track some properties about your list that will keep you from accessing it incorrectly. like its length, or the fact that its sorted, etc.
20:10:48 <jmcarthur> ion: so for example:   bounded :: Nat -> Maybe (Fin n)  -- maybe gives you an index suitable for a static-length array of length n, but only if the parameter is within the bounds
20:10:55 <kfr> But that would require me to implement functions as first class objects :[
20:11:11 <edwardk> kfr: dependent types require you to do a lot of stuff.
20:11:16 <kfr> I can imagine
20:11:22 <kfr> Even more than what I had in mind lol
20:11:22 <edwardk> also you can kiss type inference goodbye
20:11:41 <edwardk> type checking, fine, inference is generally obliterated
20:11:52 <ion> jmcarthur: Alright, thanks.
20:11:53 <kfr> Here's a sketch of the esoteric programming language I came up with yesterday: http://siyobik.info/misc/esolang/prime.html
20:12:02 <kfr> It has Unicode powers!
20:12:14 <dropdrive> Hi, how do I write the "obvious" function with type (a,b,c)->a ?
20:12:27 <edwardk> @djinn (a,b,c) -> a
20:12:28 <lambdabot> f (a, _, _) = a
20:12:29 <jmcarthur> kfr: if you like unicode you would love agda :)
20:12:32 <ion> Nice operators. (You might want to make the server use the correct charset for that document. :-P)
20:12:33 <Saizan> you still need less type annotations than in e.g. java :)
20:12:41 <ddarius> :t \(a,b,c)->a
20:12:42 <lambdabot> forall t t1 t2. (t, t1, t2) -> t
20:12:45 <dropdrive> edwardk: Thanks.
20:12:50 <ion> Oh, now it works.
20:12:55 <dropdrive> @pl \(a,b,c)->a
20:12:55 <lambdabot> (line 1, column 6):
20:12:56 <lambdabot> unexpected ","
20:12:56 <lambdabot> expecting letter or digit, operator or ")"
20:12:56 <lambdabot> ambiguous use of a non associative operator
20:13:18 <edwardk> pl can't deal with tuples of more than 2 elements
20:13:27 <edwardk> doesn't have combinators for accessing the members
20:13:34 <dropdrive> edwardk: Okay, thanks.  Is there a pl form of (a,b,c)->a?
20:13:40 <edwardk> nope
20:13:54 <edwardk> triples and above require manual pattern matching
20:14:15 <jmcarthur> or at least another function definition (which itself uses pattern matching)
20:14:31 <accel> what is wo awesome about Haskell's OpenGL bindings?
20:14:35 <ddarius> It's pattern matching all the way down.  Right after the turtles.
20:14:43 <ddarius> accel: Nothing.
20:14:45 <jmcarthur> accel: not much
20:14:53 <jmcarthur> accel: why? had you heard something?
20:15:02 <kfr> <jmcarthur> kfr: if you like unicode you would love agda :)
20:15:03 <kfr> Heh
20:15:11 <kfr> jmcarthur well I wanted to make a language of my own
20:15:14 <accel> yeah; I heard Haskell's OpenGL binding is efficient
20:15:17 <accel> and elegant
20:15:17 <Philippa_> accel: depends what you want. They Just Work if you just want a straightforward OGL binding, which is good by some languages' standards, and you can still do all the usual haskelly things
20:15:19 <adu> ddarius: haha
20:15:19 <accel> and beautiful
20:15:30 <jmcarthur> accel: well, i strongly disagree with whoever told you that
20:15:38 <Philippa_> which means you can write a pretty layer on top and if you've got an efficient definition of 'pretty' it'll still run fast
20:15:39 <djahandarie> Why did Haskell go with :: rather than : for types?
20:15:41 <jmcarthur> accel: it's basically just a C binding, not very haskelly
20:15:50 <edwardk> djahandarie to get : for lists
20:15:58 <stepkut> accel: the Haskell OpenGL bindings make the best of a bad situation :p
20:16:03 <djahandarie> Feels like a pretty bad reason
20:16:08 <Philippa_> cons was more frequently used in the early days
20:16:09 <adu> accel: I've used HOpenGL, it's not that different than C, and where it is different, it's harder
20:16:14 <Philippa_> (in relation to annotation)
20:16:15 <edwardk> djahandarie: larry wall's 1st principle of language design. every language feature wants to use :
20:16:16 <adu> not more beautiful
20:16:25 <kfr> <djahandarie> Why did Haskell go with :: rather than : for types?
20:16:25 <jmcarthur> adu: which is why i use OpenGLRaw :\
20:16:28 <kfr> Hatred for all human life
20:16:36 <kfr> djahandarie: Also, cons operator
20:16:43 <ddarius> edwardk: Ergo every keyword should be recognized by (:)*
20:17:01 <adu> Larry Wall is a genius
20:17:05 <edwardk> ddarius: sign me up i can totally see writing code in the : calculus.
20:17:25 <accel> for Haskell + OpenGL; is there anything besides HOpenGL (http://www.haskell.org/haskellwiki/Opengl) ?
20:17:26 <edwardk> adu: he occasionally has smart things to say
20:17:35 <jmcarthur> accel: perhaps somebody was telling you about StateVar or something? allows you to set opengl variables with something that looks like assignment. it's kind of nice i guess, but not enough to make it beautiful
20:17:36 <kniu> There are plenty of "unclaimed" operators, and ':' as the type-of notation has lots of precedent.
20:17:44 <ddarius> edwardk: Forth at least gives a good primitive the name :.
20:17:49 <kniu> Seriously, why (:) instead of something like
20:17:55 <kniu> (&)
20:18:02 <kniu> or (%)
20:18:12 <Philippa_> kniu: for cons, you mean?
20:18:18 <kniu> yea
20:18:23 <Philippa_> & has a more obvious interpretation
20:18:33 <Philippa_> % has at least a more traditional one, and :: isn't that far off for annotation
20:18:39 <kniu> (@)?
20:18:41 <Philippa_> (MLs tend to use them the other way round, in fact)
20:18:47 <ddarius> Also, : is the only upper case operator symbol.
20:19:07 <kfr> I think I aimed too high with making a semi functional language though, making an imperative one with a really primitive type system is probably easier
20:19:34 <Saizan> yeah, just compile down to the assignment calculus
20:19:35 <kfr> But I wanted to prevent raw memory access/pointers etc, I thought it might easier
20:19:47 <kfr> might be easier*
20:19:50 <jmcarthur> kfr: functional languages are pretty easy to write type checkers for though :)
20:20:13 <ddarius> jmcarthur: functional languages are pretty easy to write implementations for as well
20:20:22 <edwardk> anyways if you want to know why :: was used, ask the author of Miranda. Haskell just stole the syntax of Miranda whenever there wasn't a good reason to change it
20:20:31 <jmcarthur> ddarius: indeed. i was just jumping on that he was talking about type safety and such
20:20:46 <Philippa_> edwardk: betcha it was a mix of the frequency of cons vs annotation in then-typical code and "not being ML" :p
20:20:58 <edwardk> hah
20:21:02 <ddarius> edwardk: Why would we ever want to change map :: (* -> **) -> [*] -> [**] though?!
20:21:12 <edwardk> ddarius: =)
20:21:17 <kfr> What is **?
20:21:25 * ddarius has no idea what Turner was thinking.
20:21:25 <kfr> Is that the type of a type of a type?
20:21:34 <edwardk> kfr: that is miranda syntax in this case
20:21:35 <Saizan> "not being ML" is a quite sound principle syntax-wise
20:21:36 <Philippa_> ddarius: because our employers get worried when our code features **** and *******?
20:21:42 <edwardk> kfr: a haskell precursor
20:21:51 <Philippa_> @remember Saizan "not being ML" is a quite sound principle syntax-wise
20:21:51 <lambdabot> Nice!
20:22:04 <edwardk> saizan: i'd drink to that
20:22:13 <Saizan> :D
20:22:24 <ddarius> Just imagine the type of (>>=)
20:22:47 <ddarius> Actually, it would be kind of pretty in a way.
20:22:47 <Philippa_> or a GADTed up term's evaluator in a monad
20:23:16 <twb> Is code.haskell.org sick?
20:23:26 <twb> Or was my account just deleted?
20:23:55 <edwardk> yeah
20:24:05 <twb> edwardk: to which one? :-)
20:24:10 <accel> anyone know where I can purcahse a usb drive that will self destruct when it's a certain distance away from me?
20:24:28 <edwardk> twb: to neither, it was to ddarius's comment ;)
20:24:37 <twb> edwardk: ah, sorry
20:24:43 <edwardk> philippa: bah, monad transformers =)
20:24:44 <Saizan> c.h.o is being migrated
20:24:58 <twb> Saizan: thanks, I'll just leave it alone for a while
20:25:10 <ddarius> accel: I imagine most will when the distance is, say, 1,000,000 miles.
20:26:13 <jmcarthur> ddarius: unless if course accel is 1,000,000 miles from earth and his usb drive is safe in his home
20:26:18 <jmcarthur> *of course
20:26:37 <ddarius> jmcarthur: You can't expect these things to be completely reliable.
20:26:44 <jmcarthur> true
20:27:11 <accel> I think ddarius's method works on the assumption that if I happen to be 1,000,000 miles away from earth, I won't care much about my usb drive
20:27:15 <Philippa_> edwardk: I didn't say the monad wasn't the result of a transformer stack :-)
20:27:31 <Philippa_> (Miranda didn't have higher kinds though, did it?)
20:27:45 <ddarius> Philippa_: I'm pretty sure it didn't originally.
20:28:06 <jmcarthur> accel: i would just go with encryption or something
20:28:07 <edwardk> =)
20:28:08 <accel> this is more for things like: I keep a usb drive with important source code; I would like the data to disappear if I ever lose the usb drive
20:28:43 <Philippa_> ...now I have the urge to rig up a text-to-speech converter to translate sequences of * into beeps with proportional lengths, -> as "to" etc and have it give part of a talk that's been translated into Miranda
20:36:52 <Axman6> accel: you're very paranoid aren't you
20:38:07 <accel> nah; I only require the data vanish; not the device self destruct
20:38:32 <Axman6> why not just use an encrypted usb drive, like an ironkey?
20:39:04 <accel> oh crap those devices are expensive
20:39:07 <Philippa_> being prone to losing keys'd be a start
20:39:19 <Philippa_> also, as an alternative you can just put an encrypted FS on the key itself
20:39:39 <adu> accel: that's called encryption
20:39:55 <accel> there's a builtin chip that dos AES/RSA ?
20:40:20 <adu> accel: yes, it's called TCP
20:40:30 <accel> what does this TCP stand for?
20:40:33 <accel> trusted computing platform?
20:40:38 <Philippa_> adu: nah, with encryption someone could hypothetically snag the key off you by other means. A self-destructing device has definite uses if you're going to end up tangling with cops in a jurisdiction with legislation that lets them demand a key
20:41:03 <accel> yeah; I hear torture is effective vs encryption
20:41:14 <Philippa_> so's being able to lock you up for a few years if you don't provide the key
20:41:32 <accel> which is why all data should be encrypted + then stenographically stored in porn images
20:41:35 <Axman6> accel: just tell them 10 wrong passwords, it'lkl destroy the data then
20:41:49 <Philippa_> accel: if they break the steno you're fucked still
20:41:58 <Philippa_> Axman6: and then you end up in /really/ deep shit
20:42:00 <adu> accel: of animals and children, of course
20:42:17 <accel> Philippa_: encrypted data looks just like noise; how do you detect it in stenography?
20:42:19 <Axman6> Philippa_: but the data is safe!
20:42:38 <Philippa_> accel: by having an idea what the noise baseline should look like
20:42:42 <ddarius> "steganography"
20:43:03 <Adamant> indeed
20:43:05 <Philippa_> in fact, if you know what it should look like, the de-stega routine is another "key"
20:43:12 <stepkut> i store all my secret data on write only media so no one can steal it
20:43:16 <ddarius> The perhaps stenography would count as a form of steganograpy.
20:43:29 <Philippa_> so it's enough for them to have enough evidence that there's stega going on to take it to court
20:43:33 <accel> stepkut: /dev/null is also infinite storage!
20:43:39 <stepkut> accel: yep!
20:43:42 * copumpkin studies the steganosaurus
20:43:44 <ddarius> It turns out that it's usually pretty easy to detect steganography.
20:43:50 <Adamant> pretty much
20:43:57 <jmcarthur> accel: a good defense against rubber hose cryptanalysis is to have a destructable key which also requires a passphrase to use. if you are ever compromised, you normally at least have *some* chance of destroying the key. then, no matter what you end up saying, nothing can be done
20:44:12 <jmcarthur> even if you give up the passphrase
20:44:43 <ddarius> Real paranoid people would simply commit everything to memory.
20:44:43 <Philippa_> ddarius: about the best I can think of is hiding a small amount of data in something purporting to be a key (and which is still sufficiently strong as a key), or some other blatant noise source. You'd still end up answering hard questions about "what're you doing with a stick full of noise?"
20:44:53 <Philippa_> (and wasting police time is an offence in many jurisdictions)
20:45:04 <Adamant> ddarius: not in the presence of fMRI machines.
20:45:16 <Adamant> :P
20:45:23 <jmcarthur> ddarius: rubber hose cryptanalysis makes that ineffective ;)
20:45:31 <Philippa_> jmcarthur: yeah, it works so long as you're willing to accept the cost of being seen to destroy the data
20:45:40 <djahandarie> Rubber hose? Who names these things
20:45:53 <Adamant> Frank Zappa's nose
20:46:09 <djahandarie> "The euphemistic term refers to beating someone with a rubber hose until they cooperate."
20:46:14 <djahandarie> Good times.
20:46:16 <jmcarthur> Philippa_: if torture is likely, you're already involved in some rough stuff
20:46:33 <Philippa_> jmcarthur: jail time is also an issue in a number of jurisdictions though
20:46:50 <Adamant> I expect governments have all sorts of fun brain-scanning techniques at this point.
20:46:55 <jmcarthur> Philippa_: jail is less effective at getting you to spit out a passphrase, though
20:47:06 <Adamant> so I think the whole thing is kind of pointless now.
20:47:09 <jmcarthur> no need to destroy the key in that case
20:47:19 <ddarius> Adamant: I expect that they are mostly ineffective for the desired level of detail.
20:47:21 <accel> how does rubber hose encryption solve this problem?
20:47:24 <Philippa_> (if it sounds like I'm being crazy here, consider the current political climate in the UK and what the police're likely to do about any storage device potentially containing video of them misbehaving /and/ potentially containing mildly incriminating info)
20:47:28 <Adamant> ddarius: probably, for now.
20:47:38 <Adamant> Philippa_: I know about RIP
20:47:42 <accel> Philippa_: someone needs to invent a cell phone that uploads video live to satellites
20:47:43 <Adamant> you're not paranoid on that one
20:47:44 <Philippa_> (the game there is avoiding /any/ jail time)
20:47:59 <accel> someone needs to invent a cell phone that uploads video live to satellites, and then notifies 4chan
20:47:59 <Adamant> accel: it's called a satellite phone.
20:48:15 <Philippa_> accel: it'll happen. Mesh'll do once it's widespread enough too, except the cops might well be immune to anti-jamming legislation in principle as well as practice here
20:48:53 <Adamant> jamming is severely limited unless you want to totally take out the sat.
20:48:53 <Adamant> remember, it's going straight up.
20:49:10 <Philippa_> (modulo jamming, mesh is better: imagine the news shitstorm if the cops try to confiscate all storage in a mile radius?...)
20:49:36 <Philippa_> Adamant: the jamming statement was about meshes, that's strictly ground-based
20:49:41 <Adamant> ah sorry
20:49:59 <Adamant> yes, broad-spectrum jammers would work just fine
20:50:34 <Adamant> taking out 433mhz, 900mhz, 2.4ghz, 5ghz, and cell phones would stop most of it
20:50:35 <Adamant> all the licensed frequencies
20:50:41 <Adamant> excuse me, unlicensed
20:51:22 * hackagebot mwc-random 0.8.0.3 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.8.0.3 (BryanOSullivan)
20:54:21 <accel> man; waht is this world coming to
20:54:30 <accel> the day police starts carrying wireless signal jammers
20:54:40 <accel> is the day I start looking towards China for human rights
20:58:09 <shapr> Adamant: You realize that's totally on topic right? Have you seen the 802.11 MAC layer written in Haskell for the GNU USRP?
20:58:24 * hackagebot statistics 0.8.0.5 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.8.0.5 (BryanOSullivan)
20:58:55 <Adamant> accel: there is one legit use of them, for prisons.
20:59:17 <Adamant> unfortunately last i checked that's still illegal in the US according to the FCC
20:59:27 <Adamant> shapr: no, I didn't
20:59:37 <Adamant> I need to get the next gen USRP coming out
20:59:43 <Adamant> since they got bought by National
21:00:17 <{aaron}> is it possible to specify a bytestring length in a type constraint? (new to haskell here...)
21:00:50 <kfish> {aaron}, you're not coming from an agda background by any chance?
21:01:06 <{aaron}> no :/
21:01:47 <{aaron}> i'm a run of the mill java and ruby programmer, sliding towards functional programming
21:02:03 <shapr> {aaron}: welcome to a bunch of awesomeness!
21:02:42 <jmcarthur> {aaron}: to answer your question directly... there are ways, but they are usually not practical
21:02:47 <{aaron}> reading through LYAH and various tutorials while trying to convert some existing data parsing code
21:03:10 <{aaron}> jmcarthur, ok.  my particular problem is that I'm trying to use the Get monad to parse some records
21:03:21 <{aaron}> i'm following: http://www.haskell.org/haskellwiki/DealingWithBinaryData
21:03:36 <{aaron}> but the examples only show reading "Word32"...
21:04:22 <jmcarthur> {aaron}: the docs might help http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html
21:06:59 <{aaron}> so if i use getbytes/getbytestring, i just need to list ByteString as a return value...
21:08:38 <Axman6> if there's a getByteString, then it's type will already be Get ByteString, so there's no need to specify the type
21:09:41 <Axman6> its*
21:09:50 <mtnviewmark> Wow - BayHac is going to be a blow-out: over 60 people signed up
21:09:53 <mtnviewmark> !!!
21:11:31 <kfish> mtnviewmark, wow!
21:11:50 <mtnviewmark> yeah - that is about 2x what I was expecting
21:12:10 * Axman6 feels that in comparison to population size, AusHac with it's 20 people is more impressive :P
21:12:15 <kfish> is it presentations or just hax0ring?
21:12:20 * shachaf hasn't signed up but will also probably be there.
21:13:17 <mtnviewmark> It's ALL hax0ring!
21:13:49 <mtnviewmark> well- there is a day of workshops - where we're gonna teach newcomers (as well as experienced folk)
21:13:56 * shachaf has no Haskell project he's working on currently.
21:14:04 <mtnviewmark> and we'll probably have an evening of 5min flash talks
21:14:22 <shapr> Looks like there's going to be a Haskell talk in Huntsville this Friday.
21:14:26 <ddarius> mtnviewmark: The number of people that sign up and the number of people that show up are proportional, but the proportionality constant is not 1.
21:14:44 <copumpkin> if you make them pay a bit, it gets closer to 1
21:14:49 <mtnviewmark> yes, I've run events before... 
21:16:02 <ddarius> copumpkin: If you throw in free beer it gets greater than 1.
21:17:25 * BMeph is trying to convince himself to finish his current project before ripping the guts out of it and rebuilding it from scratch... :(
21:17:34 <ddarius> BMeph: Why?
21:20:00 <shapr> A working release, no matter how ugly, tends to build momentum.
21:20:48 <mtnviewmark> "A rolling release gathers mo' devs...."
21:20:56 <BMeph> ddarius: shapr got it in one. :)
21:21:56 <mtnviewmark> I keep trying to get my project to first release, but I keep adding things to the "must do before release" list faster than I knock them off
21:22:26 <BMeph> I don't need more devs, so much as at least one working example. Once it's working, reconstruction goes easier, at least from a mental perspective.
21:25:23 <kfish> mtnviewmark, free beer to all participants who close a ghc/hackage trac bug :)
21:25:37 <mtnviewmark> you funding?  ;-P
21:25:54 <jcwjcw> Hi haskellers
21:26:01 <jcwjcw> I've heard a little bit about your language
21:26:11 <jcwjcw> I know what I like in a language, and haskell might have that.
21:26:24 <tg_> black, with a spoon in it?
21:26:30 <jcwjcw> So far, my favorite language is Ocaml, because of the "if it compiles it works" feature
21:26:36 <jcwjcw> I've heard haskell is similar
21:26:40 <mtnviewmark> shaken, not stirred?
21:26:50 <jcwjcw> However, none of the features that people have cited seem interesting to me.
21:26:56 <jcwjcw> I don't particularly care about lack of side effects
21:27:05 <{aaron}> it looks like getContents is idiomatic...should I not be trying to read buffers directly?
21:27:06 <jcwjcw> ^^ lol mtnviewmark
21:27:18 <jcwjcw> I don't care about lazyness
21:27:26 <jcwjcw> I think in terms of type systems
21:27:37 <jcwjcw> So the remaining feature that could sell me is type classes
21:27:38 <tg_> oh you better care about laziness quick
21:27:44 <jcwjcw> Really?
21:27:49 <jcwjcw> one sentance, why?
21:28:16 <tg_> because haskell is lazy by default?
21:28:18 <jcwjcw> If parameters are eager than at least i know they'll always be evaluated if the method is called
21:28:25 * BMeph thinks about lazyness, but doesn't get too excited about it...
21:28:39 <jcwjcw> (*im saying i could live with lazyness if it came down to it)
21:28:40 <mtnviewmark> which, as it turns out, doesn't really buy you much!
21:28:44 <jcwjcw> I'm not seeking it
21:28:52 <kfish> mtnviewmark, not bayhac but may do so for the icfp hackathon in tokyo ;-)
21:28:54 <BMeph> jcwjcw: Why is always evaluating all parameters a good thing? :)
21:29:07 <mtnviewmark> Laziness forces purity, and purity is the shizzle
21:29:11 <jcwjcw> Because sometimes code has side effects
21:29:16 <mtnviewmark> there, that's my one sentence
21:29:21 <jcwjcw> In a pure environment, sure, it never matters
21:29:27 <jcwjcw> but we all write code that is not always pure
21:29:27 <copumpkin> mtnviewmark: fo shizzle
21:29:33 <copumpkin> jcwjcw: speak for yourself
21:29:40 <copumpkin> my code doesn't even run
21:29:43 <BMeph> jcwjcw: Sounds like a lot of work. I like to do just enough work to get the answer. Okay, I lie; I don't like doing work at all, but just enough to get the answer gets one paid! ;)
21:29:55 <jcwjcw> lol
21:30:00 <shapr> jcwjcw: Laziness lets you play with infinite data structures.
21:30:12 <jcwjcw> Okay shapr that sounds interesting
21:30:20 <copumpkin> jcwjcw: I'm serious! join #agda and come to the cult of the typecheckers
21:30:24 <mtnviewmark> Laziness lets  you structure your code more naturally!
21:30:24 <jcwjcw> But you could do it without lazyness right
21:30:29 <tg_> (that's why I'm here, becuase I'm interested in group theory of fractal groups)
21:30:30 <jcwjcw> a linked list is infinite
21:30:33 <tg_> not really, no
21:30:34 <jcwjcw> a stream is
21:30:37 <copumpkin> you can't have side effects in your code if you never run it
21:30:46 <copumpkin> not even the snarky "but your CPU heats up" comments
21:30:50 <shapr> jcwjcw: Streams and iterators in strict languages give you one dimensional infinite structures, but you get multidimensional infinite data with a non-strict language.
21:30:50 <jcwjcw> You could do the same in SML
21:30:55 <tg_> Beware of bugs in the above code; I have only proved it correct, not tried it.
21:31:18 <jcwjcw> Okay (non-strict == what?)
21:31:23 <tg_> everything else
21:31:24 <joe6> runTestTT does not print the \n as newline. How do I get the \n printed as a newline? any suggestions, please?
21:31:30 <shapr> er, non-strict is roughly the same as lazy
21:31:38 <tg_> lies!
21:31:50 <shapr> tg_: Yes, lies for teaching. exactly!
21:31:51 <jcwjcw> Okay shapr I'll look into your points. But what about these type classes?
21:31:54 <jcwjcw> how are they more expressive?
21:32:00 <jcwjcw> than what ML offers
21:32:03 <tg_> everyone here knows I don't know what I'm talking about
21:32:10 <copumpkin> they give you implicitness
21:32:16 <tg_> jcwjcw: really, the biggest advantage of haskell is simon peyton jones' quirky presentation style.
21:32:17 <shapr> jcwjcw: Type classes mean you have only one operator for addition...
21:32:17 <copumpkin> and a nice, clean model
21:32:42 <jcwjcw> so like operator overloading?
21:32:58 <jcwjcw> Why is an operator different than a function?
21:33:06 <BMeph> tg_: Combined with Simon Marlow's tireless efforts to bring us working code! :)
21:33:17 <jcwjcw> Seems like variant types in Ocaml
21:33:52 <mtnviewmark> you can think of Type Classes as being much like Interfaces in Java --- they give you a restriction, and hence a guarantee, on what a value can do in a polymorphic context
21:34:06 <jcwjcw> Wait, in ocaml. when you use variants you can't make ANY assumptions about the types
21:34:14 <tg_> welcome to haskell!
21:34:18 <jcwjcw> haha
21:34:23 <jcwjcw> okay hold on
21:34:36 <tg_> plus, does #ocaml have 700 people in it?
21:34:40 <jcwjcw> In Ocaml/SML you could accomplish the same I think
21:34:41 <joe6> guys: any suggestions on how to get the \n printed as newlines and not as \n's?. Sorry for asking again.
21:34:45 <jcwjcw> Okay tg_ funny you say that
21:34:57 <mtnviewmark> so rather than just writing a function that is polymorphic in ALL types, you can make one that is polymorphic over types that say, satisfy the type class Eq... and hence you get to use the == operator with them
21:35:00 <jcwjcw> Even if it did, they'd all be french!
21:35:09 <shapr> hah
21:35:23 <tg_> In the interest of diplomacy, I will not read into that statement whatsoever.
21:35:34 <jcwjcw> but I think I can do the same in ml
21:35:34 <mtnviewmark> joe6: in general? use putStr and putStrLn
21:35:37 <shapr> jcwjcw: Haskell is from the UK and Sweden. Why so many members from other countries?
21:35:37 <jcwjcw> or ocaml
21:35:37 <jcwjcw> mtnviewmark this is what i'm looking for
21:36:00 <jcwjcw> Ocaml sites look like they were made using angelfire
21:36:04 <joe6> mtnviewmark: how do I link up runTestTT with putStr?
21:36:07 <jcwjcw> That is one thing haskell has over ocaml
21:36:13 <tg_> shapr: snooty elitist functional programing clique'
21:36:15 <joe6> any suggestions, please?
21:36:21 <shapr> jcwjcw: better websites? or larger community?
21:36:27 <jcwjcw> mtnviewmark with SML you could have record types
21:36:51 <jcwjcw> ocaml has worse websites and a smaller community
21:36:57 <jcwjcw> the smaller community i can tolerate
21:37:11 <jcwjcw> but the ghetto websites strain my eyes so much that I have to abandon their technology
21:37:17 <stepkut> jcwjcw: heh
21:37:26 <jcwjcw> But in all seriousness, you can do the same thing in Ocaml/SML
21:37:27 <mtnviewmark> joe6 -- where are these newlines coming from? when I run with runTestTT, i get multiple lines on my console, yo dont?
21:38:04 <mtnviewmark> jcwjcw: I can't speak to that - I don't know Ocaml or ML
21:38:25 <jcwjcw> with a combination of multitypes (type t = Int*(Int->string)
21:38:54 <shapr> jcwjcw: Would be cool to have "Haskell from the OCaml perspective". Why not write a tutorial or blog post?
21:39:08 <jcwjcw> yah, that would be great, but currently i have neither perspective.
21:39:09 <shapr> jcwjcw: or maybe "OCaml from the Haskell perspective" ?
21:39:17 <jcwjcw> Just an insatiable desire for ultimate static typing
21:39:37 <shapr> jcwjcw: er, Agda?
21:39:37 <joe6> mtnviewmark: i just do ++ "\n" to string. Is that not enough?
21:39:38 <jcwjcw> I want to encode as much of my program into the type system
21:39:45 <jcwjcw> because I am an idiot compared to a compiler
21:39:52 <shapr> jcwjcw: The problem with that is the type system is untyped.
21:39:58 <mtnviewmark> joe6: in a test?
21:40:09 <jcwjcw> shapr?
21:40:10 <joe6> to the label
21:40:24 <jcwjcw> The people that wrote the type system are smarter than me
21:40:32 <mtnviewmark> oh - and you want when the test fails for the message that includes the value to somehow print that value without escaping the newlines?
21:40:37 <jcwjcw> or are you just being pedantic like all haskell snobs?
21:40:43 <mtnviewmark> AH -- the label
21:41:03 <joe6> mtnviewmark: i want the message printed with newlines not with the \n
21:41:10 <mtnviewmark> got it -
21:41:13 <mtnviewmark> no idea - never did that
21:41:18 <jcwjcw> but the type classes are exactly what I need. WIll see if Ocaml can give 'em to me.. Might come back with tail between legs begging for haskell forgiveness
21:41:35 <jcwjcw> *I repent of my ocaml waysss!
21:41:43 <shapr> jcwjcw: You're welcome to follow both ways, in my opinion.
21:41:51 <jcwjcw> There is something to be said for simplicity
21:41:55 <jcwjcw> time shapr time..
21:41:56 <shapr> I mean, there's lots of cool stuff to learn, yah?
21:41:56 <mtnviewmark> oh, we're mostly a friendly bunch.... just don't mention that you've ever enjoyed programming in C++....
21:42:00 <jcwjcw> There is so little time.
21:42:15 <jcwjcw> I'm not a liar so I would never say that
21:42:19 <shapr> jcwjcw: I understand that... I've been writing Haskell for nearly ten years and I still have so much to learn.
21:42:30 <jcwjcw> I don't *like* having to learn things
21:42:35 <jcwjcw> I like understanding
21:42:36 * mtnviewmark <-- has actually enjoyed coding in C++
21:42:40 <jcwjcw> understanding is the opposite of learning
21:42:47 <shapr> jcwjcw: How so?
21:43:01 <jcwjcw> One requires time.
21:43:02 <jcwjcw> The other saves time
21:43:18 <jcwjcw> One prevents you from doing things
21:43:24 <jcwjcw> The other enables you to do things
21:43:32 <jcwjcw> If I'm learning, that's time I can't be doing.
21:43:44 <jcwjcw> If I understand there is no more energy to expend. Only action to take
21:44:00 <jcwjcw> Haskell could be entertaining.. But for someone that already works 15 hours a day
21:44:08 <jcwjcw> I don't have time for entertainment :)
21:44:27 <shapr> Well, enjoy your action then :-) feel free to drop by with any questions!
21:44:33 <jcwjcw> But when I do, I'll check it out (or if ocaml is lame)
21:44:46 <jcwjcw> thanks! you guys are the snobs they make you out to be
21:44:51 <jcwjcw> *aren't
21:44:54 <jcwjcw> *aren't
21:44:55 <shapr> jcwjcw: btw, dependent types may be interesting to you
21:44:55 <jcwjcw> sorry
21:45:04 <jcwjcw> one sentance?
21:45:13 <jcwjcw> like subtyping?
21:45:17 <shapr> jcwjcw: You can encode the length of a list in its type
21:45:27 <shapr> can also be used to encode things like memory/cpu requirements
21:45:28 <jcwjcw> oh woooooooww that's rad!
21:46:01 <shapr> But dependently typed languages have a different set of challenges... Haskell is a slightly different sweet spot.
21:46:10 <jcwjcw> So you could define a function that operates on nonzerolengthed lists
21:46:22 <jcwjcw> cool stuff
21:46:34 <jcwjcw> f*cking type systems.. how do they work!?
21:46:40 <jcwjcw> ^reference to meme
21:46:42 <Axman6> or you could just define a list type that will always have at least one element
21:47:00 <Axman6> data NEList a = Nil a | Cons a (NEList a)
21:47:34 <shachaf> type NEList a = (a,[a])
21:47:44 <Axman6> sure
21:54:42 <shapr> jcwjcw: speaking of type systems, have you sene http://www.cafepress.com/skicalc.6225368# ?
21:55:45 <jcwjcw> he.
21:55:52 <jcwjcw> I'm not smart enough to understand that
21:56:14 <jcwjcw> That's why I need a super-static type system in the first place! ahhh irony
22:00:47 <{aaron}> i'm not sure how to use an Either result... do I need to inspect it's type somehow? or head lefts ?
22:01:26 <Axman6> @src Either
22:01:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:01:29 <Axman6> :|
22:01:54 <Axman6> that's... supposed to work! Cale!
22:02:09 <Axman6> data Either a b = Left a | Right b
22:04:00 <{aaron}> i'm not sure what to do with that info :/
22:04:54 <gienah> {aaron} i'm a beginner, could try something like: f (Left x@_) = something x
22:05:14 <gienah> f (Right x_) = something_else x
22:05:27 <Axman6> {aaron}: when you get something of type Eithe a b, you can pattern match on it: foo (Left x) = thingThatUsesX x; foo (Right y) = thingThatUsesY y
22:05:46 <{aaron}> hmm
22:05:50 <Axman6> gienah: huh, there's no need for the @'s or _'s there
22:06:04 <gienah> Axman6: thanks for the tip :-)
22:10:01 <{aaron}> so if I have an either result, i can define two functions which match either left or right type, and which can return a Nothing or some other type, and define the caller function to return a Maybe?
22:10:04 * {aaron} tries
22:10:54 <{aaron}> hmm that doesn't feel right
22:11:15 <llambda> what does one do when their -prof output looks like http://hpaste.org/43506/parsec ? feels like parsec is just sucking here
22:11:49 <Axman6> use a different parser lib
22:11:53 <Axman6> like attoparsec
22:12:02 <llambda> what if that isn't possible
22:12:10 <Axman6> then suck it up! :P
22:12:19 <llambda> what if that isn't possible either? :P
22:12:34 <BMeph> Then you're screwed! ;√æ
22:12:35 <Axman6> ragequit?
22:12:39 <shapr> {aaron}: When Either is used in place of Maybe, Left (by convention) usually holds an error message and Right holds a successful result.
22:12:39 <llambda> ;_;
22:13:03 <llambda> no magic hacks i can do to make parsec run faster?
22:13:14 <llambda> i think it was actually faster when i was using String rather than ByteString
22:13:36 <llambda> which makes me feel like i'm doing something wrong
22:14:01 <llambda> i would ping ddarius but he seems to longer be the maintainer
22:15:12 <shapr> llambda: There are various magic hacks you can use to make it go faster.
22:15:29 <llambda> :o
22:15:41 <shapr> but I think they mostly boil down to manual strictness poking
22:16:09 <llambda> wouldn't that show up in my specific parser function rather than the parsec stuff then?
22:16:10 <stepkut> ghc --make -ffaster-parsec -Oparsec
22:16:26 <llambda> unless you mean start changing strictness inside parsec itself
22:16:40 <llambda> its just kind of hard to tell where i need to poke when -prof is just telling me that parsec itself is the problem
22:18:42 <shapr> llambda: Does your profiling stats change if you change the order of any possible backtracking matches?
22:18:58 <shapr> er "do your" My english is bad today.
22:19:06 <llambda> the order?
22:19:22 <llambda> does that mean like, nested trys or what?
22:20:27 <shapr> Sure, any place where you end up using option or try
22:23:08 <{aaron}> http://hpaste.org/43507/stuck
22:24:07 <Axman6> uh, wow
22:24:46 <Axman6> firstly, you don't need brackets for function arguments: getByteString 10 will work fine
22:25:01 <{aaron}> yeah lint said that
22:25:40 <Axman6> why are you returning a massive tuple?
22:26:18 <ddarius> Cuz names are the tools of the Man, man.
22:26:21 <{aaron}> because the number of hours i've spent programming haskell can be counted on one hand, so i would like to get something working first and refactor later
22:26:52 <ddarius> "I would like to do it the hard way first, and then do it the easy way."
22:27:11 <{aaron}> yes, sometimes that's the best way to learn
22:28:02 <{aaron}> i'm just stuck on the either handling atm
22:28:39 <shapr> llambda: Did you see any difference in the profiling when you swapped around parsec match order?
22:29:17 <jeffwheeler> Hey, is there a decently reliable way to convert a large darcs repo to git? I don't need to keep them in sync, it's just a one time thing. darcs2get and darcs-to-get both failed pretty quickly, they seem to be old.
22:29:47 <jeffwheeler> Is it worth trying Tailor? Or will I lose too much from the conversion?
22:31:08 <quicksilver> jeffwheeler: whatever the GHC guys used seems to work well. Unfortunately I don't know what that was.
22:31:24 <jeffwheeler> quicksilver: maybe I should try #ghc
22:32:26 * quicksilver agrees
22:32:29 <quicksilver> pretty sure it wasn't tailor
22:36:19 <llambda> shapr, I've been poking at it for a while now and can't seem to get much to happen
22:37:05 <llambda> if there is a    do try(blah1); blah2; blah3;   it won't bother doing 2 or 3 if 1 fails right?
22:41:10 <Axman6> no, it will
22:41:25 <llambda> hmmm, that could be the problem
22:41:50 <jeffwheeler> Hm, I can never quite remember what causes this. I just manually built a package (datetime==0.2, the Hackage version doesn't work in GHC 7.0.1), but now I'm trying to install a package that depends on it.  Instead of using the package I just built, it tries to rebuild it from Hackage.
22:41:58 <Axman6> if try blah1 fails, then no input that would have been consumed by blah1 appears to have been consumed when it gets to blah2
22:42:13 <jeffwheeler> ghc-pkg list shows my package, not quite sure what cabal's reasoning is.
22:42:36 <llambda> hm okay, i see, i thought it acted slightly different
22:42:40 * llambda messes more with code
22:42:40 <ddarius> Axman6: That's a sequential composition.
22:42:48 <Saizan> jeffwheeler: you should bump the version when you do that
22:42:52 <Axman6> ddarius: hmm?
22:42:53 <ddarius> try mzero >> p is mzero
22:43:02 <jeffwheeler> Saizan: why does that matter?
22:43:16 <ddarius> Axman6: try doesn't turn failure into success.
22:43:30 <llambda> ah, so i was correct?
22:43:36 <ddarius> llambda: Yes.
22:43:42 <Axman6> my mistake
22:43:42 <llambda> damn
22:43:46 * llambda back to square one
22:43:51 <Saizan> jeffwheeler: otherwise cabal will assume that it's the exact same package as on hackage
22:43:53 * llambda messes more with code anyways
22:43:57 * Axman6 tried to remember how try works again
22:44:03 <Axman6> tries*
22:44:07 <jeffwheeler> Saizan: so if it's installed, why does it try to reinstall it?
22:44:33 <Saizan> jeffwheeler: there might be a number of reasons, --dry-run -v to see them
22:44:48 <jeffwheeler> Saizan: will do; thanks (your version bump did work)
22:44:53 <ddarius> Axman6: It simply doesn't commit regardless of whether or how much p consumes in try p.
22:45:13 <Axman6> what do you mean by commit?
22:45:42 <pozic> Axman6: "assumes that what it has parsed thusfar is the only correct path"
22:46:00 <ddarius> Axman6: You can't backtrack over a computation once it commits even if it fails.
22:46:40 <ddarius> As soon as a Parsec parser consumes some input, it commits to that branch.
22:46:48 <ddarius> try locally changes this behavior.
22:46:52 <llambda> ddarius, strangly, commenting everything after try(blah1) does make it faster somehow
22:46:58 <llambda> could lack of -O be the cause?
22:47:06 <Axman6> ah right
22:50:32 <llambda> ddarius, can't replicate that with -O2, guess something just isn't getting optimized away
22:51:42 * llambda tries switching back to String
22:53:13 <llambda> Yeah, String cuts off like 25% of the runtime compared to bytestring
22:53:57 <llambda> oh, could perhaps be because I was using a strict ByteString and something didn't like that
22:55:06 <twb> Anybody know offhand if checkinstall works with "cabal install foo" ?
22:55:23 <twb> It seems to be LD_PRELOAD based, i.e. won't work with static binaries, i.e. I don't think it'll work
22:56:12 <shachaf> twb: cabal isn't dynamically linked against libc?
22:56:16 <llambda> nope, lazy bytestring performs worse than string also
22:56:21 <llambda> guess parsec just doesn't like bytestrings
22:56:21 <twb> shachaf: oh, it's only libc?
22:56:28 <twb> shachaf: I don't really understand these things
22:56:42 <shachaf> twb: Well, checkinstall wraps calls like fopen().
22:56:58 <twb> shachaf: all I remembered was ghc didn't like dynamic linking for some silly reason
22:56:58 <Axman6> llambda: why can't you use things like attoparsec?
22:57:13 <llambda> because i'm already using the monad transformer and state features of parsec
22:57:20 <Axman6> righto
22:57:23 <llambda> porting to attoparsec would be a pretty annoying surgery
22:57:30 <shachaf> twb: I think it doesn't like dynamic linking against Haskell libraries.
22:57:34 <llambda> might need to end up doing it at this rate though
22:57:37 <shachaf> twb: There's no problem with libc, libgmp, etc.
22:57:41 <twb> shachaf: yeah, that makes more sense now you point it out
22:58:18 <twb> (My actual goal is to run gitit in a VM, without having to temporarily give that VM enough CPU and memory to run ghc6)
23:00:20 <llambda> looking at the -prof again, the bytestring uncons takes way longer than the string uncons for god knows what reason
23:00:32 <llambda> and that apparently outweighs any benifit i actually got from switching to bytestring
23:06:11 <lostman> j
23:06:17 <shapr> k
23:06:50 <shapr> lostman: Learning Haskell? Or trying J? :-)
23:07:10 <kfr> Stop posting common Haskell names for values
23:07:25 <kfr> I nearly said "variables" but I'm not sure if that makes sense in the context of Haskell
23:07:33 <kfr> f x = 1 -- what do you call x?
23:07:40 <kfr> An argument? A name? A value? A variable?
23:07:47 <kfr> Which ones apply?
23:07:55 <shapr> unimportant? no matter what you hand to x, you always get 1?
23:08:01 <kfr> ...
23:08:08 <twb> I would normally call it "the argument"
23:08:27 <twb> "let f be the function that maps x to 1"
23:08:37 <quicksilver> I would call it an argument, and a name, and a variable.
23:08:47 <shapr> but the variables don't vary...
23:09:13 <kfr> Hmm "variable" is mathematical terminology, too
23:09:14 <llambda> okay, this is the ugliest code i could find so i suspect my parsec slowness is coming from here... anyone have a better way to write this? http://hpaste.org/43508/a 
23:09:15 <twb> Within the body of f's definition, x is a "symbol", and during evaluation of that body, the symbol is bound to a value.
23:09:27 <llambda> (nb: parserA backtracks internally)
23:09:29 <kfr> At first I had this feeling that it might have the connotation of state
23:09:33 <kfr> And modifying state
23:09:49 <twb> kfr: depends on the context
23:09:59 <cheater-> hi
23:10:04 <quicksilver> variable has mixed connotations, so it can be a confusing word. But in "f x = 1", x is variable because it varies between different calls to f.
23:10:12 <quicksilver> this is the mathematical sense of 'variable'.
23:10:13 <cheater-> can ghc cross-compile to say a microcontroller?
23:10:18 <quicksilver> cheater-: no.
23:10:22 <twb> quicksilver: calls to... or applications of? ;-)
23:10:29 <quicksilver> sure.
23:10:40 <cheater-> can i compile haskell programs to small embedded systems or microcontrollers?
23:10:43 <Axman6> cheater-: there are libraries which you can use to generate code for microcontrollers though
23:10:44 <quicksilver> cheater-: although cross-compilation is a feature lots of people want, GHC can't (quite) do it.
23:10:53 <twb> cheater-: Debian provides ghc6 for arm
23:11:07 <twb> cheater-: I've successfully compiled e.g. darcs for a sheevaplug using it
23:11:09 <cheater-> twb: interesting... how do i run it on an intel pc?
23:11:11 <shapr> twb: wow
23:11:17 <twb> cheater-: you don't.
23:11:21 <quicksilver> cheater-: you don't; you run it on ARM.
23:11:27 <twb> cheater-: you get a real or virtual arm system and run ghc6 there
23:11:30 <quicksilver> as I said, GHC doesn't do cross-compilation.
23:11:40 <cheater-> twb: what do i use for a virtual arm system?
23:11:48 <twb> cheater-: I dunno, kvm?
23:11:48 <kfr> I can't believe the bootstrapping is still broen
23:11:54 <kfr> Shame on the GHC devs!
23:11:57 <kfr> broken*
23:12:08 <quicksilver> kfr: your patch to fix is appreciated in advance? ;)
23:12:11 <cheater-> twb: i dunno, you tell me
23:12:11 <twb> Note that ghc6 on arm is in some way suckier than on the first-class arches... I can't remeber how
23:12:14 <shapr> quicksilver: haha, I was going to say that!
23:12:20 <quicksilver> it's unregisterised, twb
23:12:20 <twb> I think it has to use gcc as an intermediary
23:12:23 <twb> Yeah that
23:13:03 <jeffwheeler> Can't llvm help here?
23:13:16 <jeffwheeler> Or is it the runtime that is hard?
23:13:19 <Axman6> jeffwheeler: eventually, maybe
23:13:24 <Axman6> but it's the RTS that's the problem
23:13:32 <accel> i have test.hs in leksah; is there a "compile & run" I can't find the button
23:13:39 <quicksilver> llvm does help.
23:13:45 <quicksilver> but it doesn't get you the whole way on its own.
23:14:02 <quicksilver> it's less work now, to do a native GHC-arm, than it was before the llvm backend went in.
23:14:14 <cheater-> haha, the sheevaplug page lists that it supports INTERNET 3.0
23:14:28 <kfr> cheater- that is impressive
23:14:35 <kfr> Whereas I still use INTERNET1
23:14:47 <twb> cheater-: it's just an OMAP board in a plastic case
23:14:53 <cheater-> i'm actually drafting INTERNET 3.1 migration right now
23:15:01 <cheater-> twb: OMAP?
23:15:11 <shapr> TI's ARM
23:15:13 <cheater-> aha
23:15:15 <kfr> http://en.wikipedia.org/wiki/Special:Search?search=internet+3&sourceid=Mozilla-search
23:15:19 <kfr> Internet explorer 3 hmm
23:15:27 <shapr> cheater-: https://secure.wikimedia.org/wikipedia/en/wiki/OMAP
23:15:36 <cheater-> just googled it, thanks shapr :)
23:15:38 <twb> kfr: you know you can just wikipedia.org/wiki/Special:Search/internet+3
23:16:05 <kfr> twb: Do you have any idea how much time I would lose if I bothered to clean up those links?
23:16:11 <kfr> 4-6 hours per day
23:16:18 <twb> kfr: I meant when you make the original request
23:16:58 <cheater-> i was always wondering about this - what's the smallest rechargable-battery-operated computer that runs linux and has say.. wifi, and can be used as a router for OK bandwidth?
23:17:11 <cheater-> that's an O not a zero.
23:17:25 <twb> cheater-: the ben nanonote and the yeeloong are physically small
23:17:48 <twb> For a router, you're better off buying a WRT and putting OpenWRT on it
23:17:50 <hamishmack> accel:  You need a Workspace and Package first.  Dev version makes it easier to set these up.  But in the current version it is Workspace -> New Workspace.  Followed by Package -> New Package.
23:17:52 <cheater-> it doesn't even have to come in a box though a box is actually useful
23:18:14 <cheater-> twb: but i'd like it to run linux so that i can, say, do torrents on it
23:18:21 <twb> cheater-: OpenWRT *is* linux
23:18:25 <shapr> I'd also like to find a shirt-pocket-sized Linux box with wifi
23:18:26 <cheater-> oh
23:18:27 <cheater-> nice
23:18:37 <cheater-> can you run some sort of torrent client on it?
23:18:44 <twb> And in any case, most domestic routers now ship with a linux or vxwork image that includes a torrent client
23:18:54 <cheater-> twb: i don't need a keyboard or a display - just the computer
23:18:56 <cheater-> headless
23:19:04 <accel> hamishmack: trying it out now
23:19:12 <cheater-> twb: haha, nice!
23:19:43 <cheater-> what do you suggest that is good on this side (openwrt or linux or vxwork and a lot of power)?
23:19:58 <twb> http://www.tp-link.com/products/productDetails.asp?pmodel=TL-WR1043ND is maybe USD$50
23:20:02 <accel> hamishmack: can I PM you until I set this up?
23:20:11 <twb> cheater-: what do you need power for?
23:20:24 <cheater-> twb: well, if i can choose, i'd rather have more rather than less
23:20:26 <cheater-> cpu power
23:20:31 <cheater-> and/or ram
23:20:44 <hamishmack> accel: Why not join #lekah
23:20:49 <twb> cheater-: then you probably want to aim for commodity form factor, e.g. pico ATX
23:21:03 <cheater-> twb: no, i mean out of all routers as you say
23:21:10 <cheater-> twb: since you seem to be in the know
23:21:39 <twb> cheater-: OpenWRT targets embedded systems, running at like 8MB (non-volatile)/16MB (volatile)/200MHz MIPS
23:21:56 <cheater-> i realize that's the average
23:22:09 <cheater-> now the question is which one is the most beefed up
23:22:53 <twb> This discussion is daft.
23:24:05 <cheater-> twb: if you don't know how to answer, that's ok, no reason to start getting repulsive.
23:24:30 <cheater-> this plug computer thing seems to have wifi, that's nice!
23:24:38 <twb> If you want a powerful computer to act as a computer, then just buy a computer.
23:24:51 <twb> cheap, small, embedded systems are *by definition* not powerful
23:24:59 <cheater-> if you want to answer a question i haven't asked, the conversation will be daft indeed.
23:25:01 <twb> *to act as a router, I mean
23:28:38 <cheater-> let me ask differently
23:30:21 <cheater-> twb: evaluate {x: x \in DomesticRouters and x \in {x: x in the top 10 of DomesticRouters according to cpu power} and x \in {x: x in the top 10 of DomesticRouters according to RAM size} }
23:31:36 <Axman6> old PC's make good domestic routers...
23:32:06 <Axman6> i used to run a OpenBSD box with a 133MHz Pentium and 32MB RAM, worked just fine
23:32:13 <twb> cheater-: the Netgear WNDR3700 is the most powerful commodity domestic router I know of, that's well supported by OpenWRT.  It's still only 8MB/64MB/600MHz MIPS, i.e. far crapper than your old laptop
23:32:27 <cheater-> twb: thanks, that answers my original question.
23:32:45 <twb> It's not like you're going to be able to run e.g. gcc on that
23:34:16 <twb> A new atom or ion would kick its ass
23:34:36 * Axman6 would go with a via eden
23:34:45 <twb> Or that, yeah
23:35:05 <Buckii> hello
23:35:14 <kfr> My router: MSI IM-945GSE Mini-ITX motherboard (Intel Atom N270, dual Intel PRO e1000), Atheros AR5008 802.11 b/g/n wireless PCI interface, Corsair 2048 MB 667 Mhz DDR2 SO-DIMM (running at 533 Mhz), 4 GiB Transcend Jetflash USB stick, picoPSU 60W, 12V 5A AC->DC adapter, HP ProCurve gigabit switch to connect the rest of the network to it
23:40:02 <Axman6> hi Buckii 
23:40:20 <shapr> kfr: ok, now to get GHC running on it...
23:40:20 <Buckii> hey hey 
23:40:31 <kfr> shapr: Trivial :o
23:40:33 <Buckii> hows everyones night 
23:40:44 <kfr> pacman -S ghc
23:40:48 <kfr> ghc6 though
23:40:55 <twb> If they were available in 1RU, I'd be deploying Traverse's GeOS boards
23:41:21 <kfr> shapr it's a regular Arch Linux IA-32 box
23:41:45 <twb> Since they have 2√óATM ports onboard, for which there exist drivers in linus-2.6
23:42:06 <Axman6> Linus has ATM ports? jesus
23:42:34 <Buckii> can any one help me with an issue maybe 
23:42:45 <shapr> How else can read all of the kernel mailing list traffic?
23:42:48 <twb> Axman6: it's a bit dodgy... the board puts an FPGA in front of the DSP, and linux only talks to the FPGA and relies on its to do the heavy lifting
23:42:53 <Axman6> Buckii: first rule of IRC: don't ask to ask, just ask
23:43:02 <twb> Axman6: but it's better than shipping a separate ADSL modem
23:43:02 <Buckii> lol
23:43:10 <shapr> Axman6: I thought the first rule of IRC was, "be nice" ?
23:43:16 <Buckii> hehe 
23:43:19 <Axman6> no!
23:43:21 <twb> Don't ask to ask unless you're prepared to ask to ask to ask.
23:43:25 <Buckii> that was being nice in my eyes 
23:43:33 <Axman6> twb: and to be told to not ask to ask
23:43:36 <Buckii> well now 
23:43:55 <Buckii> so whats this room all bout i kinda just actualy stumbled here 
23:44:05 <Axman6> the haskell programming language
23:44:09 <twb> lesson #2: they're channels, not rooms
23:44:13 <shapr> Buckii: Writing programs with MUCH AWESOMENESS
23:44:19 <Buckii> thank you 
23:44:40 <vegai> shapr: hey! How are you doing?
23:44:56 <shapr> hyv√§√§ huomenta vegai! I'm doing well!
23:45:16 <shapr> I really gotta try AGI scripting with Haskell.
23:45:34 <Axman6> AGI?
23:45:43 <shapr> um, Asterisk CGi 
23:46:19 <twb> I thought freeswitch was what the cool kids used now
23:46:58 <shapr> twb: I work at the company that develops Asterisk.
23:47:04 <twb> Ha
23:51:08 <twb> Oh, Wikipedia says that asterisk aims to be a PABX/IVR, where freeswitch's primary focus is on the underlying circuit switching
23:52:52 <accel> anyone ehre managed to use yi with leksah?
23:54:57 <twb> I lost interest in yi when its vty backend seemed to lag behind its gtk backend
23:57:33 <cheater-> hey twb, i just read up on that netgear. is there something similar to it with ADSL 2 support?
23:58:54 <twb> cheater-: the only ATM (i.e. ADSL) device that Linux can drive is a traverse.
23:59:37 <cheater-> twb: traverse?
23:59:38 <twb> cheater-: you either need to buy a separate ADSL modem and put it in "bridge mode", then speak PPPoE over it, or you need to run the vendor's firmware.  I cannot help with the latter.
23:59:44 <cheater-> ok. gotcha.
