00:04:22 <mm_freak> Kaidelong: also a "deriving all"-like thing would help composability
00:04:53 <mm_freak> uhm, not composability, but extensibility
00:05:26 <mm_freak> for example, if you're writing a library, which uses another one, you don't have to look all the time, whether the instances in the other library have been changed/extended
00:07:24 <Kaidelong> mm_freak: deriving all except x y z could be interesting, just wondering how you would do it
00:07:52 <Kaidelong> well
00:07:59 <Kaidelong> I suppose it is all known at compile time
00:08:03 <Kaidelong> so it shouldn't be hard at all
00:09:04 <Kaidelong> perhaps another idea is to have more specific instances have higher priority than derived ones
00:09:36 <Kaidelong> I could see people complaining about the fact that you could import a library and change the behavior of your program though
00:09:37 <Kaidelong> then again that may be a feature
00:10:21 <kuffaar> So monadic xs ys = do { x <- xs; y <- ys; return (x,y) } is the same as monadic xs ys = xs >>= (\x -> ys >>= (\y -> return (x, y))) and for monadic :: [a] -> [b] -> [(a, b)] the list monad makes this monadic xs ys = concat (map (\x -> (concat (map (\y -> [(x, y)]) ys))) xs) - did I get that right?
00:11:19 <Kaidelong> on the first part, yes! on the second, still trying to figure out what you are doing there
00:11:52 <kuffaar> instance Monad [] where
00:11:52 <kuffaar>  {return x = [x]
00:11:52 <kuffaar> ; xs >>= f = concat (map f xs)} --no?
00:11:57 <kuffaar> Oh fail paste
00:12:05 <kuffaar> Filthy hidden newlines! Curses
00:12:32 <Kaidelong> oh I see
00:12:55 <kuffaar> I was analysing an example from Real World Haskell in http://book.realworldhaskell.org/read/monads.html
00:13:05 <Kaidelong> anyway yes
00:13:05 <kuffaar> Which compares do notation for lists and list comprehensions
00:13:18 <kuffaar> By using the bind and injection definitions for the list monad
00:13:19 <Kaidelong> although you shouldn't worry too much about how the instance is implemented so much as what it does
00:13:33 <mandras> hello guys, I have a problem understanding type classes, I'm asking for help!
00:13:43 <mandras> just pasted a piece of code -- what's wrong with it?
00:14:11 <kuffaar> I don't see any link
00:14:39 <mandras> ghc6 says: "Couldn't match expected type `a' against inferred type `Double' \n `a' is a rigid type variable bound by \n the instance declaration at XXX
00:14:57 <mandras> http://hpaste.org/43018/instance_declaration
00:15:29 <luite> mandras: the problem is the type of *
00:16:05 <luite> :t map (*(2::Double))
00:16:07 <lambdabot> [Double] -> [Double]
00:16:36 <adnap> in ghci, how do you see the type for a function after giving a definition for class constraints?
00:16:36 <lambdabot> adnap: You have 1 new message. '/msg lambdabot @messages' to read it.
00:16:40 <luite> since x is a Double, you can only multiply [Double] with your implementation of the function times
00:16:42 <adnap> for instance
00:16:45 <adnap> :t liftA2
00:16:47 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
00:17:05 <adnap> let's say i want to know the type of liftA2 specifically for functions
00:17:14 <adnap> i can hint by doing
00:17:18 <adnap> :t liftA2 id
00:17:19 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
00:17:32 <adnap> but can i hint without supplying an actual function?
00:17:50 <adnap> actually, it still didn't even fill it in
00:17:53 <adnap> shoot
00:17:59 <mandras> luite: makes sense, but how do I get rid of the Double? I.e., make it any instance of Num?
00:18:14 <adnap> basically, i want it to assume that f in Applicative f is a function in this case
00:18:48 <jonkri> the tested-with property description at http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#general-fields should be extended to describe the format of "compiler list". what is the syntax?
00:20:50 <Kaidelong> @ty flip (flip liftA2 . id)
00:20:51 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
00:20:59 <Kaidelong> oh
00:21:09 <Kaidelong> let's try, umm
00:21:18 <luite> mandras: hmm, I'm not sure, you cannot just multiply one instance of Num with another. oh by the way, your plus is easier written as: plus l m = zipWith (+) l m  (which means: plus = zipWith (+) )
00:21:27 <Kaidelong> @ty flip (flip liftA2 . ($ undefined))
00:21:28 <lambdabot> forall a b c (f :: * -> *) a1. (Applicative f) => (a -> b -> c) -> (a1 -> f a) -> f b -> f c
00:21:58 <kuffaar> I don't get the $ undefined part
00:22:06 <adnap> i just want to tell it to assume that the Applicative in this case is, say Maybe, or functions
00:22:18 <Kaidelong> @ty ($ undefined)
00:22:19 <adnap> and see what the type looks like filled in
00:22:20 <lambdabot> forall a b. (a -> b) -> b
00:22:22 <mandras> luite: thanks for the zipWith...
00:22:41 <kuffaar> OHHH
00:22:45 <luite> mandras: by the way, what you're doing looks similar to a vector space, there are several vector space type classes on hackage, you can check and see how they do it
00:22:48 <kuffaar> It's like (1 +) etc
00:22:54 <kuffaar> Syntactical sugar right
00:23:03 <Kaidelong> yeah, operator sections
00:23:05 <Kaidelong> damn handy
00:23:10 <kuffaar> I was puzzled because I expected ($) in that position
00:23:26 <mandras> luite: I don't want to multiply two differente instances of Num with each other, is there a way of replacing the Double in my class declaration with any instance of Num?
00:23:30 <mm_freak> :t liftA2 :: (Applicative f, f ~ Maybe) => f (a -> b) -> f a -> f b
00:23:31 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
00:23:31 <lambdabot>     In the expression:
00:23:31 <lambdabot>           liftA2 :: (Applicative f, f ~ Maybe) => f (a -> b) -> f a -> f b
00:23:33 <mm_freak> :t liftA :: (Applicative f, f ~ Maybe) => f (a -> b) -> f a -> f b
00:23:34 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
00:23:34 <lambdabot>     In the expression:
00:23:34 <lambdabot>           liftA :: (Applicative f, f ~ Maybe) => f (a -> b) -> f a -> f b
00:24:21 <luite> mandras: you could make it a multiparameter typeclass
00:24:22 <kuffaar> What does f ~ Maybe mean there?
00:24:30 <mm_freak> kuffaar: "equals"
00:24:47 <Kaidelong> @ty flip (flip liftA2 ($undefined))
00:24:48 <lambdabot> forall b c a b1. ((a -> b1) -> b) -> (b1 -> b -> c) -> (a -> b1) -> c
00:24:55 <adnap> :t liftA2 :: (Applicative f, f ~ Maybe)
00:24:57 <lambdabot>     Class `Applicative' used as a type
00:24:57 <lambdabot>     In an expression type signature: (Applicative f, f ~ Maybe)
00:24:57 <lambdabot>     In the expression: liftA2 :: (Applicative f, f ~ Maybe)
00:25:06 <mandras> luite: what would that look like then?
00:25:13 <adnap> that's basically what i want to say to it though
00:25:15 <luite> class Integral a b where { plus :: a -> a -> a ; times :: b -> a -> a }   instance Num a => Integrable [a] a where ...
00:25:17 <kuffaar> f :: (a b, a ~ Int) => is the same as f :: (Int b) => ... then?
00:25:31 <Kaidelong> @ty flip (flip liftA2 (const . ($undefined)))
00:25:32 <lambdabot> forall b c b1 a b2. ((a -> b2) -> b) -> ((b1 -> b2) -> b -> c) -> (a -> b2) -> c
00:25:37 <mandras> luite: will try, thanks
00:25:53 <luite> mandras: you could add a functional dependency a -> b
00:26:39 <mandras> luite: what does that mean?
00:26:48 <luite> mandras: not sure if all of this is what you want, like I said, vector space does something similar with scalar multiplication, so look up how they do it
00:27:54 <luite> mandras: a -> b means that b is uniquely determined by a, in this case that a=[Double] automatically means that b=Double
00:28:44 <kuffaar> Oh I'm so stupid, RWH actually decodes the list monad example I posted earlier shortly after that...
00:28:58 <luite> mandras: there are other ways, I believe you can find an example on hackage that does the same with an associate type
00:29:05 <luite> associated
00:29:10 * ski wonders whether there are problems with `.. ~ ..' because associated types are partial ..
00:29:10 <kuffaar> Although it didn't decode the return (x, y) part
00:29:19 <kuffaar> Which should be [(x, y)]
00:29:35 <kuffaar> "Using [(x, y)] in blockPlain_reloaded might make it more relevant to this discussion."
00:29:41 <kuffaar> Hah it's already mentioned in one of the comments
00:29:54 <luite> mandras: (note that both methods need extensions over "standard" haskell 98 or 2010, FunctionalDependencies and TypeFamilies, respectively)
00:30:17 * ski . o O ( "You go talk to your associate types." )
00:31:32 <mandras> luite: thanks a lot, I'm trying to learn haskell by coding examples, not sure if I want to use extensions right away...
00:31:54 <mandras> luite: but I'll look up the vector packages to see how they do it
00:32:06 <luite> mandras: yeah this problem is probably a bit difficult, you might want to come back to it later
00:36:39 <luite> mandras: this is probably the one you're looking for: http://hackage.haskell.org/packages/archive/vector-space/0.7.2/doc/html/Data-VectorSpace.html  (the package named vector is for some kind of arrays)
00:37:37 <mandras> luite: thanks, I've already discovered that the Vector package more resembles MatLab vectors (which also have little to do with vectors...)
00:38:09 <mandras> another general question though: I've used "data" declarations in the past and have found them to be rather cumbersome in my cases
00:39:10 <mandras> basically I used them to hold multiple data items (example: data Square = Square Int Int Int [Int])
00:40:01 <mandras> in which case the functions I define on them all use pattern matching to extract the individual parts of the constructor
00:41:07 <mandras> maybe I'm still too stuck with concepts of imperative languages, but what I find cumbersome is that whenever I add a new item to the constructor, I also have to rewrite ALL functions defined on the type
00:42:09 <mandras> is there a better or simpler way of packaging multiple data into a single type? (I'm looking for something like a struct in C or an object in OO languages)
00:42:35 <luite> you could yuse Square { getX::Int, getY::Int, getListOfSomething::[Int] }
00:42:56 <Veinor> yeah, record syntax
00:43:47 <mandras> OK, so is the record syntax how you would normally encode the "world" in Haskell?
00:44:51 <Baughn> mandras: Yes. Though in any real program chances are I'd use TVars somewhere, so look those up. ;)
00:45:45 <mandras> luite: great, just spent 10 minutes on #haskell and have another week's worth of reading to do! I love it... :)
00:46:19 <luite> mandras: it's relatively quiet here at the moment, otherwise your questions would've been answered in stereo :p
00:46:42 <luite> and probably by better haskellers than me :)
00:47:28 <kuffaar> Whenever you think you just understood something in Haskell, it just gets worse.
00:50:32 <mandras> kuffaar: I've experienced that a few times before!
00:50:59 <mandras> OK guys, thanks a lot for your help, hope I can be of help on this channel one day!
00:51:04 <kuffaar> mandras the first time I touched Haskell was in 2009 and I still consider myself in the hello world stage
00:51:38 <luite> I'm not sure about that, but there are always people trying to come up with ever more clever ideas that take a while to grasp and that you'd never have come up with yourself :)
00:51:40 <kuffaar> But I must admit that the first time I actually invested some time into it was perhaps the past 4 days
00:52:32 <mandras> kuffaar: same here, although I first touched it in 2005, went away without even typing a single line of code (from the docs back then, I just couldn't figure out how on earth the compiler knows what to do from those few lines)
00:52:49 <mandras> kuffaar: came back in late 2010 and can't look back!
00:52:55 <luite> at least the tools have improved a lot since then
00:53:02 <luite> with the haskell platform and cabal-install
00:53:05 <kuffaar> Yeah I am currently producing like less than 10 lines per day although I am actively trying to code in Haskell
00:53:12 <kuffaar> I don't even use HP
00:53:36 <kuffaar> The first 4 days I spent setting up ghc 7, the newest cabal-install, MSYS, MinGW, mDTK etc on Windows
00:54:06 <kuffaar> And then getting all the dependencies and fixing up their cabal files and applying inofficial patches to make the broken packages work with ghc 7 and mailing package maintainers and submitting patches
00:54:19 <luite> whoah why did you do that? if you just installed the haskell platform you'd have been done in a few minutes. you probably don't need to build foreign libraries when you're just starting
00:55:05 <kuffaar> luite my hello world is basically web development with snap, Takusen, heist, yaml and openid
00:55:21 <luite> oh that is quite an elaborate hello world :p
00:55:24 <kuffaar> At some point you just need to try to do actual work :/
00:55:42 <mandras> I still "have" to code most stuff in other languages (e.g. Ruby, which I (used to) love), and find myself really longing for Haskell except in a very few cases (hardware access for instance)
00:55:55 <kuffaar> Yeah Ruby has been my primary language since early 2010
00:57:39 <mandras> my latest program is an ETA interpreter, which made me understand a little bit about monads, but I've just decided to rewrite it in not-so-monadic style (no, there is not a single "do" in it!)
01:02:29 <luite> mandras: couldn't you have started with something simpler? like calculating fibonacci numbers or factorials. you know, the stuf that real functional programmers do ;)
01:02:37 <luite> oop
01:02:38 <luite> s
01:02:48 <luite> I meant kuffaar 
01:03:26 <Kaidelong> main = print "Hello World"
01:03:50 <Kaidelong> what is wrong with that
01:03:53 <kuffaar> luite lol
01:04:42 <ivanm> Kaidelong: well, the output will be literally "Hello World" including the quotes
01:04:49 <Kaidelong> err
01:04:51 <Kaidelong> show then
01:04:54 <ivanm> usually that isn't needed for hello world ;-)
01:04:58 <ivanm> @type putStrLn
01:05:00 <lambdabot> String -> IO ()
01:05:00 <kuffaar> ivanm: What
01:05:04 <Kaidelong> err
01:05:06 <Kaidelong> I mean that
01:05:07 <Kaidelong> yes
01:05:08 <kuffaar> Kaidelong: I don't see the problem
01:05:28 <kuffaar> ivanm oh you're right
01:05:31 <ivanm> kuffaar: in ghci, run both ` print "Hello World" ' and `putStrLn "Hello World" ' and compare the difference
01:05:37 <ivanm> kuffaar: of course I am!
01:05:43 <dmwit> data Unit = Unit; instance Show Unit where show _ = "hello world"; main = print Unit
01:05:45 <kuffaar> yeah that didn't occur to me
01:05:50 <ivanm> dmwit: lol
01:06:10 <kuffaar> dmwit hahaha
01:06:26 * ivanm grumbles about Text-based parsers being basically liftM T.pack .....
01:06:34 <luite> dmwit: upload it to hackage :)
01:06:41 <kuffaar> luite but that doesn't have anything to do with the things I actually need to get work done
01:06:48 <kuffaar> Pretty much everything is just IO and state related
01:07:04 <dmwit> > let don't _ = () in don't { return 3; return 4 }
01:07:05 <lambdabot>   <no location info>: parse error on input `3'
01:07:15 <dmwit> > let don't _ = () in don't do { return 3; return 4 }
01:07:16 <lambdabot>   <no location info>: parse error on input `do'
01:07:21 <dmwit> oh bother
01:07:26 <dmwit> The joke is well dead, now, I suppose.
01:07:28 <Kaidelong> kuffaar: My most recent haskell experience didn't use much IO at all (but I did spend a lot of time in RandT and ST)
01:07:34 <dmwit> > let don't _ = () in don't (return 3)
01:07:35 <lambdabot>   Ambiguous type variable `m' in the constraint:
01:07:36 <lambdabot>    `GHC.Base.Monad m'
01:07:36 <lambdabot>      a...
01:07:40 <dmwit> heh
01:07:42 <dmwit> ultra fail
01:07:49 <kuffaar> The Haskell code is just glue for database interaction and markup generation :p
01:08:18 <Kaidelong> ah, well, I suppose then you'd be doing a lot of IO
01:08:30 <Kaidelong> you can separate out a lot of your algorithms, though
01:08:48 <kuffaar> What algorithms :p
01:09:15 <Kaidelong> luckily I've mostly had to do projects that were heavy on algorithms (in that case, harmony search and tabu search were the two I implemented, along with a framework to get the two working together)
01:09:35 <kuffaar> The current state of my web dev project is printing the value in an IORef into a HTML5 template
01:10:05 <ion> data Foo = Foo String deriving (Show, Eq); instance Num Foo where fromInteger 42 = Foo "Hello world"; main = print (42 :: Foo)
01:10:27 <kuffaar> No wait, I'm not even reading it yet, I just managed to make it part of the application state and initialise the counter to 0 with newIORef and liftIO
01:10:50 * Kaidelong wonders what, if anything, would stop people from making TV work with web stuff
01:11:09 <kuffaar> The next step is to read it, and then to increase it every time a certain route is that
01:11:17 <kuffaar> Kaidelong I'm not sure what you mean by that
01:11:48 <Kaidelong> http://www.haskell.org/haskellwiki/TV
01:12:33 <kuffaar> Oh, never heard of that one before
01:12:46 <kuffaar> Also, the code rendering totally breaks in Firefaux
01:13:05 <Kaidelong> I noticed
01:13:54 <luite> kuffaar: oh I've been working on something like that, but not as composable. basically tryhaskell with "Interact"-like (mathematica) functionality and graphical output
01:14:16 <luite> argh
01:14:24 <kuffaar> Name confusion?
01:14:30 <luite> I need coffee... yeah, again :)
01:18:04 <_pa_> Hmm, I can't declare a data type in ghci?
01:18:21 <luite> nope, you need to load a file for that
01:18:27 <_pa_> Ah, I see. Thanks
01:19:33 <Jafet> Prelude> writeFile "tmp.hs" "data Foo = ..."
01:20:56 <lewis1711> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours anyone have any thoughts like this? I've heard it's a bit misleading but it looks like a good excuse to pick up haskell
01:22:01 <Jafet> @vixen You're so pure, but they scheme to pick you up!
01:22:03 <lambdabot> No pic, sorry
01:22:35 <_pa_> Jafet: hah! Good idea
01:22:59 <Jafet> You can only load one file at a time, so it might not be a good idea
01:23:37 <rrc7cz> how might you support a kill signal in a simple hello world happstack app? when I runhaskell Foo.hs it boots the server, but it doesn't quit on Ctrl-C
01:24:18 <kuffaar> lewis1711 haha
01:24:50 <kuffaar> It doesn't seem like a task you would specifically "need" Haskell for
01:24:59 <_pa_> Jafet: still, that was good enough for now
01:25:32 <lewis1711> kuffaar: nope. but who really needs a programming language anyway?:)
01:26:00 <merijn> lewis1711: People who aren't rich enough to just buy smart slaves?
01:26:09 <kuffaar> lewis1711 I do
01:26:49 <lewis1711> I was trying to be all philosophical about how need is subjective, and how one mans need could be another mans want, etc etc
01:28:17 <kuffaar> lewis1711: However, writing compilers or interpreters for programming languages is one of my favourite subjects
01:28:28 <kuffaar> I play with new ideas for esoteric programming languages all the time
01:30:08 <lewis1711> kuffaar: yeah curious to see how it all works, as I have this "idea" that I can't seem to shake, so hopefully some nitty gritty interpreter writing will cure me of such notions
01:30:28 <Kaidelong> have you looked at Entropy?
01:30:46 <kuffaar> lewis1711: What idea?
01:31:29 <kuffaar> I think my first own programming language was something close to an interpreted assembly language :[
01:31:43 <lewis1711> no, I know how this works. I tell you guys and you lol at me and link me to some papers of people who have tried and failed and I get discouraged and don't end up trying and learning!
01:32:07 <merijn> I had an idea to create statically typed python with some haskell influences. I stopped once I realized that'd just end up being Haskell with objects >.>
01:32:33 <kuffaar> lewis1711 I'm not sure what you mean and I certainly won't link you to any papers since I hardly know any anyways and I constantly ridicule CS as an academic field although I'm currently finishing my MSc in it
01:32:41 <lewis1711> haha
01:32:42 <merijn> I had another idea to make python more functional, but that turned out to just be Lisp...
01:32:51 <lewis1711> merijn: or ruby even
01:32:51 <Kaidelong> http://esolangs.org/wiki/Entropy
01:32:56 <kuffaar> merijn haha I want to make a statically typed interpreted language, too
01:33:00 <Jafet> merijn: at least you've learned some important properties of Python.
01:33:07 <kuffaar> I was thinking about type inferrence, too, since I started with Haskell
01:33:11 <lewis1711> kuffaar: a scheme like language with ML like typing
01:33:23 <kuffaar> But I might not allow actual polymorphism
01:33:27 <kuffaar> lewis1711 uhmmm
01:33:52 <kuffaar> lewis1711 curiously that's not so far from what I was considering, I think
01:33:57 <merijn> kuffaar: This is the wrong channel for people who ridicule CS as an academic field :p
01:34:12 <kuffaar> merijn yeah I've been flamed in here before :p
01:34:17 <quicksilver> on the contrary, ridicule is always on topic
01:34:25 <quicksilver> as long as it is both polite and witty.
01:34:47 <quicksilver> flaming on the other hand is far off-topic.
01:34:54 <kuffaar> @quote SPJ
01:34:54 <lambdabot> SPJ says: will be a legend after his death
01:35:03 <kuffaar> Aww, sabotage!
01:35:08 <kuffaar> @quote learnHaskell
01:35:08 <lambdabot> learnHaskell says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
01:35:12 <merijn> SPJ is already a legend, isn't he? :p
01:36:04 <Jafet> He's probably doomed to be one.
01:36:13 <quicksilver> @quote SPJ cheerful
01:36:14 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
01:36:19 <quicksilver> the quote's still there
01:36:23 <quicksilver> it's just there is more than one quote.
01:36:27 <kuffaar> Haha
01:36:35 <quicksilver> the legend quote is wrong; that's not a quote of SPJ
01:36:46 <quicksilver> that's someone misusing @remember I guess
01:37:10 <merijn> I've always liked
01:37:11 <merijn> @quote something.very.weird
01:37:11 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
01:37:25 <Veinor> hahaha
01:37:59 <kuffaar> I'm not so sure that the slipping was successful in my case
01:38:08 <kuffaar> Although I do feel weird
01:38:23 <pastorn> that's from "a taste of haskell", right?
01:38:24 <merijn> I feel weird all the time after reading a few papers :p
01:38:48 <Kaidelong> when I touched SML/NJ back in 2005 I realized that functional programming was closer to my way of thinking
01:39:07 <Kaidelong> Common LISP did not do that for me when I tried it two years earlier
01:39:16 <kuffaar> Kaidelong: That's funny, I always thought it was the opposite for me
01:39:19 <merijn> I got taught OCaml in class a few years back, didn't understand anything of it...
01:39:30 <_pa_> Haha
01:39:39 <_pa_> Oh, I read that wrong. I read that as "I taught OCaml ..."
01:39:43 <kuffaar> I still find Haskell utterly unnatural and unintuitive and I first touched it in 2009 :[
01:40:00 <Kaidelong> well Haskell is weird in more ways than just being functional
01:40:09 <kuffaar> True that, true that
01:40:17 <merijn> It was my infatuation with Python's list comprehension and generators that caused me to start working with things like map/filter which eventually caused me to grok Haskell
01:40:32 <merijn> I didn't get Haskell until like the 5th time I tried learning it :p
01:40:48 <merijn> @quote vending
01:40:48 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
01:40:48 <lambdabot> of insight hits and it all makes sense.
01:41:02 <Kaidelong> When I was little I had a tendency to approach mathematics with algorithms, then I wrote some down with my own notations and worked on those notations...
01:41:20 <Kaidelong> then I forgot about that
01:41:24 <kuffaar> merijn: This is my second time and I'm slowly getting the grasp of the monadic stack and lifting and representing state in Haskell, did I do any better than you did?
01:41:34 <Kaidelong> but when I learned SML it snapped that I felt like I've been there before
01:41:57 <kuffaar> Kaidelong that's the way I felt about Javascript and PHP!
01:42:00 <merijn> Pfft, I haven't really worked with lifting and stuff so I'm not sure I understand that fully :p
01:42:13 <kuffaar> merijn what, I thought you were a Haskell overlord
01:42:20 <kuffaar> Isn't that like one of the first things you need to learn?
01:42:23 <merijn> I just pretend to be one on IRC
01:42:26 <kuffaar> Hahaha
01:42:53 <merijn> I don't do much Haskell coding, but I've been reading a lot of type theory lately which lets me pretend :p
01:43:28 <merijn> I'm always lecturing people in #python on how to code as well but secretly I mainly write vanilla C :p
01:43:33 <kuffaar> I see, you're one of those who try Haskell and then end up losing themselves in abstract discourse instead of actually coding anything
01:43:33 * Kaidelong tries to write at least a bit of Haskell each week, unless otherwise preoccupied.
01:43:46 <kuffaar> merijn haha you treacherous beast
01:43:52 <Kaidelong> right now, I'm getting to write Haskell in my networking class
01:44:04 <Kaidelong> since you can work with sockets just fine
01:44:04 * kuffaar is actively trying to code Haskell for like 12 hours per day, producing 5-10 lines
01:44:15 <merijn> That's not gonna work
01:44:29 <merijn> More productive to hang around here and learn by osmosis ;p
01:44:40 <kuffaar> Haha nice analogy
01:44:43 <earthy> even more productive to hang around here *and* code like 8 hours a day
01:44:53 <Kaidelong> I find reading papers to be better than just hanging around
01:45:02 <Kaidelong> but hanging around here means you get links to some of those
01:45:08 <merijn> Have to do lots of systems level coding for classes so I don't have much time left over for Haskell so that's where most my coding time goes
01:45:12 <earthy> *and* read the source to any package on hackage that takes your fancy ;)
01:45:26 <lewis1711> what's the distinction between an operator and a function?
01:45:35 <earthy> lewis1711: it's syntax
01:45:37 <merijn> lewis1711: In Haskell? Nothing
01:45:44 <Kaidelong> merijn: Would Sockets be system level?
01:45:47 <lewis1711> operators are infix?
01:45:51 <lewis1711> that's it?
01:46:00 <earthy> lewis1711: well... almost
01:46:07 <earthy> they can be used prefix as well
01:46:13 <kuffaar> Hmm well you can use every binary function as an infix, right?
01:46:15 <merijn> lewis1711: Functions consisting entirely of symbols are considered operators and infix by default
01:46:16 <lewis1711> oh but you need brackets
01:46:21 <mm_freak> is there an easy way to test, whether a certain value is evaluted to WHNF?
01:46:21 <lewis1711> right
01:46:28 <quicksilver> mm_freak: nope.
01:46:37 <kuffaar> Can you use functions with an arity of >= 3 as infixes in Haskell?
01:46:41 <earthy> but there's one extra parsing issue that you need to be aware of, and that is that operators can have relative binding priorities
01:46:42 <quicksilver> mm_freak: that would not be referentially transparent etc ;)
01:46:45 <merijn> kuffaar: Yes
01:46:50 <quicksilver> mm_freak: there's something to vacuum, as I recally.
01:46:57 <merijn> The remaining arguments are suffixed
01:47:03 <kuffaar> I see
01:47:04 <quicksilver> mm_freak: s/to/in/; s/y//;
01:47:14 <earthy> > let between x y z = y <= x && x <z in 2 `between` 1 3
01:47:15 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> GHC.Bool.Bool)
01:47:16 <lambdabot>    arising fro...
01:47:20 <quicksilver> you need ()
01:47:24 <merijn> Kaidelong: Could be, but right now more like implementing profiling in the kernel. And (unfortunately) some Java grid code
01:47:25 <quicksilver> (2 `between` 1) 3
01:47:40 <kuffaar> > (+1) `map` [1..]
01:47:41 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
01:47:45 * kuffaar smirks
01:48:00 <earthy> quicksilver: thanks for spotting it
01:48:12 <Kaidelong> yay then I'm doing system level programming in haskell, feels good that I didn't end up going back to C yet again for a class
01:48:12 <kuffaar> > 1 `(+)` 1
01:48:13 <lambdabot>   <no location info>: parse error on input `('
01:48:14 * earthy is still waking up :)
01:48:16 <kuffaar> Haha :/
01:48:35 <Kaidelong> kuffaar: there are limitations on what you can put inside ``, due to parsing issues
01:48:47 <merijn> Kaidelong: No mandatory languages for classes? Which university do you go? :p
01:48:59 <earthy> merijn: it depends on the class
01:49:11 <Kaidelong> merijn: Central Washington University. But it is mostly because this is a tiny 400-level class
01:49:13 <earthy> I've had classes like that
01:49:28 <Kaidelong> and the professor is a prolog guy and isn't about to stop us from using haskell
01:49:39 <Kaidelong> I know one of the other students will be using Erlang
01:49:53 <merijn> Code the solution in Prolog in Haskell's type system! :p
01:49:58 <earthy> oh well, back to the day job
01:50:10 <Kaidelong> merijn: who do you think I am, Oleg?
01:50:15 <kuffaar> Write it in ARM ASM and force them to evaluate it in QEMU
01:50:32 <lewis1711> do it in java!!
01:50:34 <lewis1711> ....
01:50:49 <merijn> Is there a Haskell to Java compiler for my classwork? :p
01:50:53 <mm_freak> quicksilver: found an easier way to optimize =)
01:51:00 <earthy> merijn: you could try scala
01:51:07 <mm_freak> one involving sharing
01:51:29 <Kaidelong> So has Oleg implemented RSA in the type system yet?
01:51:30 <kuffaar> merijn you can probably compile Haskell to like uh ARM ASM and then interpret that in an emulator in Java.
01:51:31 <merijn> The end solution needs to be in Java so then I'd need a Scala to Java compiler which seems even less likely
01:51:47 <quicksilver> scala runs on the JVM, but it doesn't compile to the java language
01:51:48 <earthy> hm. right.
01:51:59 <quicksilver> the java language is a terrible compilation target :)
01:52:00 <lewis1711> java, the portable assembler :/
01:52:09 <luite> merijn: you can use uhc to produce javascript files, and then jsc (by mozilla) to compile your javascript to java class files. then a decompiler to produce java source code
01:52:09 <waterlaz|work> could someone answear one question about haskells optimizations?
01:52:10 <quicksilver> (mind you the JVM isn't that much better)
01:52:12 <kuffaar> Clojure uses the JVM, too
01:52:13 <earthy> you need to hand in Java source code. sucks to be you
01:52:15 <merijn> I mean, at least Haskell people are silly enough to write compilers for everything and your dog :p
01:52:16 <ski> @quote oleg
01:52:16 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
01:52:23 <Kaidelong> LLVm
01:52:27 <quicksilver> waterlaz|work: not until you ask it :)
01:52:34 <waterlaz|work> I realy experience strange behavior
01:52:35 <Kaidelong> LLVM?*
01:52:43 <kuffaar> I want to write a language which can ultimately compile itself
01:52:56 <waterlaz|work> setArray arr v = do
01:52:56 <waterlaz|work>     bds <- getBounds arr
01:52:56 <waterlaz|work>     forM_ (range bds) $ \i -> writeArray arr i v
01:53:02 <Kaidelong> kuffaar: that means the language would be turing complete, and why'd you want that?
01:53:05 <waterlaz|work> quaestor, I have this function ^^
01:53:05 <Kaidelong> go for a total language
01:53:07 * earthy would like to finally get 'round to building that Algol'68 compiler.
01:53:23 <waterlaz|work> I expect the list not to be created when compiling with -O2
01:53:26 <lewis1711> humm, is it considered bad style to write infix operators as prefix with brackets? less confusing :P
01:53:42 <quicksilver> waterlaz|work: why do you expect the list not to be created?
01:53:51 <merijn> lewis1711: I'd say go with whatever is more readable
01:53:51 <earthy> lewis1711: in certain cases it is, yes, but not in all
01:53:53 <shachaf> lewis1711: If it's actually less confusing then it's not bad style.
01:54:03 <mandras> Kaidelong: it's very early in the morning at your place, isn't it?
01:54:06 <lewis1711> well *I* find it less confusing
01:54:14 <waterlaz|work> and when both setArray and the function that calls it are in the same file it does not create the list
01:54:23 <kuffaar> I'd prefer a + b over (+) a b
01:54:24 <shachaf> lewis1711; For everything?
01:54:28 <Kaidelong> mandras: Yes. I am very tired and making mistakes and should be asleep etc.
01:54:35 <waterlaz|work> quicksilver, well it is optimized away )
01:54:43 <Kaidelong> Fortunately I have nothing to do tomorrow
01:54:47 <earthy> 2 am-ish? :)
01:55:00 <Kaidelong> you could always just send me CTCP TIME
01:55:08 <mandras> Kaidelong: yeah, did that too back when I was a student... you get old amazingly fast, you know
01:55:10 <lewis1711> shachaf: many things. perhaps I've been in scheme land too long
01:55:16 <waterlaz|work> but when I put setArray in a seperate file the list is created and it slows down my program dramaticaly
01:55:32 <quicksilver> waterlaz|work: inlining is more agressive in file than across files
01:55:33 <shachaf> lewis1711: Perhaps. :-) What's the context?
01:55:35 <earthy> that's not early morning, now is it?
01:55:39 <Kaidelong> mandras: I would rather be asleep honestly
01:55:46 <quicksilver> waterlaz|work: marking setArray with {-# INLINE #-} may help.
01:55:58 <lewis1711> putStrLn ("Hello, " ++ ((!!) args 0) ++ ((!!) args 1))
01:56:14 <lewis1711> probably a way to do it with a HOF
01:56:20 <waterlaz|work> quaestor, I'm not realy sure the problem is with inlining
01:56:33 <Kaidelong> mandras: I also have an abnormal endocrine system and forgot my medication for the last two days, so that might have something to do with this
01:56:45 <quicksilver> waterlaz|work: well that's the most likely thing to change across a module boundary.
01:56:46 <shachaf> lewis1711: I find infix !! more readable.
01:56:52 <shachaf> lewis1711: But (!!) is a bad function anyway. :-)
01:57:08 <lewis1711> what's wrong with it? :P
01:57:18 * earthy laughs
01:57:24 <Kaidelong> lewis1711: inefficient and very much partial
01:57:24 <earthy> > [1,2,3] !! 4
01:57:25 <lambdabot>   *Exception: Prelude.(!!): index too large
01:57:45 <lewis1711> earthy: seems like pretty good behaviour, what did you want it to do?:)
01:57:54 <lewis1711> Kaidelong: what would you suggest?
01:57:56 <shachaf> lewis1711: Partial functions are evil.
01:58:02 <earthy> lewis1711: I want it to not bomb on me
01:58:06 <shachaf> lewis1711: A function that returns a Maybe would be a good start.
01:58:18 <Kaidelong> lewis1711: if you really need random access, you can traverse the list just once by making it a vector or an array first
01:58:19 <waterlaz|work> quicksilver, or... ok, I guess having this function for all index types makes this optimization impossible. Thanks
01:58:25 <lewis1711> really? I'd want my program to fail in that case:P
01:58:27 <shachaf> lewis1711: You could say let (a:b:_) = args in putStrLn $ "Hello, " ++ a ++ b, by the way. Though that's not all that nice either.
01:58:36 <lewis1711> yeah
01:58:39 <shachaf> lewis1711: Your whole program?
01:58:41 <earthy> lewis1711: you're not in the business of writing long-running code, right? :)
01:59:03 <shachaf> lewis1711: I want the compiler to catch the fact that there could be an error before I run my program. :-)
01:59:19 <quicksilver> waterlaz|work: yes; inlining also causes type specialization
01:59:31 <lewis1711> shachaf: yes, that'd be slightly better actually. though since you sent it to an interpeter that's a bit unrealistic
01:59:32 <lewis1711> ;)
01:59:40 <Kaidelong> why not mention that (!!) simply isn't efficient
02:00:16 <shachaf> Kaidelong: It doesn't really matter with constant arguments like 0 and 1.
02:00:20 <pokoko222> how are my sweet haskellers doing
02:00:23 <shachaf> lewis1711: An interpreter should still catch type errors. :-)
02:00:51 <lewis1711> how!?
02:01:07 <kuffaar> lewis1711: In my hypothetical language I thought about using non-polymorphic inferred types for functions like this: f a b = + a b and then you could have one f 1 2 or one f 1.0 3.4 in the program, but not both simultaneously, haha
02:01:18 <quicksilver> well, ghci is an example of an interpreter that catches type errors.
02:01:23 <kuffaar> Because it would determine the types of the arguments of f from one of those instances
02:01:23 <lewis1711> seems like ML :)
02:01:26 <quicksilver> sml + ocaml also come with interpreters.
02:01:31 <kuffaar> Oh? I didn't know ML did it like that
02:01:42 <earthy> kuffaar: sounds like a strong monomorphism restriction
02:01:47 <merijn> Everything comes with an interpreter these days :p
02:01:52 <kuffaar> lewis1711 it's basically just a lame way to infer types but it avoids the problem of having to check for recursive types and stuff
02:01:55 <merijn> Hell, there's a C REPL :p
02:02:02 <lewis1711> haha
02:02:03 <merijn> (Written in Haskell, ofc)
02:02:04 <ski> kuffaar : it only does when it has to, due to the value restriction
02:02:05 <shachaf> @karma MonomorphismRestriction
02:02:06 <lambdabot> MonomorphismRestriction has a karma of 0
02:02:10 <lewis1711> does it work? I heard about it but never downloaded it
02:02:14 <lewis1711> seemed to freaky
02:02:18 <Kaidelong> ohgodthevaluerestriction
02:02:21 <ski> (kuffaar : and in that case, it doesn't have to)
02:02:26 <kuffaar> ski: I am talking about a hypothetical language, not Haskell :o
02:02:32 <merijn> lewis1711: I don't see why it wouldn't work?
02:02:33 <Kaidelong> I keep ramming my head against the value restriction now when programming ML
02:02:39 <Kaidelong> it has gotten hard to get used to again
02:02:45 <ski> kuffaar : i was responding to "Oh? I didn't know ML did it like that"
02:02:51 <kuffaar> Oh, ok
02:03:07 <merijn> I think only Java is missing a REPL :p
02:03:19 <ski> earthy : yeah, the value restriction in the MLs is similar to the monomorphism restriction in Haskell
02:03:21 <Kaidelong> it seems so inelegant too that eta expansion could make something that doesn't work, work
02:04:05 <ski> the value restriction is irritating when you can't really eta-expand
02:04:46 <_mpu> yes it is
02:04:48 <Kaidelong> ski: there is a "solution" to that!
02:05:04 <Kaidelong> you can eta expand something by giving it an argument it ignores, basically
02:05:11 <Kaidelong> apparently that works
02:05:11 <_pa_> For a n00b: what is this value restriction and what does an eta-expansion imply?
02:05:17 <Kaidelong> and can get around the value restriction
02:05:17 <quicksilver> I think the value restriction is much worse than the monomorphism restriction.
02:05:26 <Kaidelong> which means you end up with f() rather than f
02:05:47 <quicksilver> _pa_: in SML you can't write "foo = xxx >>> yyy" if foo has a function type.
02:06:05 <quicksilver> _pa_: instead you have to write "foo x = (xxx >>> yyy) x, or similar.
02:06:06 <merijn> _pa_: eta conversion/expansion implies adding a "useless" lambda wrapping around a function
02:06:27 <merijn> i.e. "\x -> f x" <-> "f"
02:06:29 <_pa_> Oh I see
02:06:38 <ski> Kaidelong : yeah .. but i was thinking about when you want to define e.g. a parser, which is not (explicitly) a function which takes arguments
02:06:39 <shachaf> quicksilver: What, really? Why?
02:06:40 <Kaidelong> like going "\y -> const x y" instead of just "const x"
02:06:41 <_mpu> _pa_: f becomes  fun x -> f x
02:06:44 <quicksilver> makes combinator libraries really less convenient in sml
02:06:48 <_pa_> I've read a lot of Haskell but not started programming it myself yet
02:07:07 <lewis1711> > :t read
02:07:09 <lambdabot>   <no location info>: parse error on input `:'
02:07:18 <merijn> _pa_: tbh, I don't think its a term you will need commonly while writing Haskell :p
02:07:22 <lewis1711> oh shit. I broke lamdba calculus
02:07:25 <Kaidelong> the value restriction is rather terrible
02:07:27 <quicksilver> shachaf: because of impurity + side effects
02:07:30 <luite> so THIS is the reason that SPJ uses Comic Sans for his presentations! "Researchers asked 28 participants aged 18 to 40 to learn a set of facts about three fictional species of alien, which were written in different fonts. Those who read the facts in the easy-to-read Arial pure black font retained 14 per cent less information than those who were given text written in the less clear Comic Sans MS and Bodoni MT."
02:07:31 <merijn> lewis1711: Don't need the ">" in front of :t
02:07:40 <merijn> :t read
02:07:40 <lambdabot> forall a. (Read a) => String -> a
02:07:40 <ski> quicksilver : you can write `foo = xxx >>> yyy' .. the problem is rather that in that case `foo' can't get a polymorphic type
02:07:42 <_pa_> merijn: maybe not 
02:07:42 <Kaidelong> hopefully the next strict ML like language will also be pure
02:07:53 <Kaidelong> so that the value restriction is not needed
02:07:57 <_pa_> merijn: but I do Haskell (and lots of other related abstract subjects) just for fun and mental entertainment
02:08:01 <quicksilver> ski: right. Sorry. In my head it was obvious that my combinators were polymorphic ;)
02:08:05 <_pa_> "just"
02:08:26 <ski> (quicksilver : so it has nothing to do with whether `foo' has function type or not)
02:08:27 <lewis1711>  :t "3"
02:08:33 <lewis1711> why is that a char?
02:08:42 <lewis1711> also :t "34"
02:08:42 <ski> it's not
02:08:50 <merijn> :t "3"
02:08:51 <lambdabot> [Char]
02:08:56 <merijn> It's a String
02:08:57 <Kaidelong> :t '3'
02:08:58 <lambdabot> Char
02:08:59 <ski> it's a list of characters, i.e. a string
02:09:06 <quicksilver> ski: Ah. I only hit it with functions personally. But, I see.
02:09:08 <lewis1711> ohhh
02:09:12 <lewis1711> so read needs a list of strings
02:09:16 <lewis1711> that explains that
02:09:26 <lewis1711> this :t thing for functions is really handy
02:09:34 <lewis1711> (once I learn to read it)
02:09:36 <merijn> lewis1711: No, read needs a string (which is a list of chars)
02:09:49 <_mpu> :t read
02:09:49 <lambdabot> forall a. (Read a) => String -> a
02:10:10 <lewis1711> then what's wrong with
02:10:14 <lewis1711> > read "4"
02:10:16 <lambdabot>   *Exception: Prelude.read: no parse
02:10:18 <lewis1711> is not 4 a string?
02:10:20 <shachaf> > read "4" :: Int
02:10:22 <lambdabot>   4
02:10:22 <merijn> lewis1711: Ah!
02:10:26 <ski> > read "4" :: Bool
02:10:27 <lambdabot>   *Exception: Prelude.read: no parse
02:10:35 <Kaidelong> @ty read "4"
02:10:36 <shachaf> > read "()" -- Default type.
02:10:36 <lambdabot> forall a. (Read a) => a
02:10:37 <lambdabot>   ()
02:10:40 <merijn> lewis1711: "4" can be multiple things and its saying it doesn't know what you want :p
02:10:45 <Kaidelong> oh I see shachaf
02:10:49 <Kaidelong> that is interesting
02:10:49 <lewis1711> ah
02:10:59 <lewis1711> that's... somewhat confusing
02:11:02 <merijn> > read "4" :: Double
02:11:03 <lambdabot>   4.0
02:11:05 <shachaf> merijn: Actually, it's saying that i can't parse "4" as a value of type ().
02:11:10 <Kaidelong> merijn: what a terrible error message
02:11:15 <ski> @check \x y -> x == y  -- also defaulting
02:11:16 <lambdabot>   "OK, passed 500 tests."
02:11:18 <Kaidelong> For that anyway
02:11:39 <merijn> @check \x -> x == reverse x
02:11:40 <lambdabot>   "OK, passed 500 tests."
02:11:42 <Kaidelong> seems to be lambdabot
02:11:50 <merijn> Silly QuickCheck
02:12:09 <shachaf> @check \x y -> x == reverse y
02:12:10 <lambdabot>   "Falsifiable, after 0 tests:\n[()]\n[]\n"
02:12:35 <merijn> lewis1711: Normally GHC would infer which type it needs from the context
02:12:47 <shachaf> @check \x y -> and $ zipWith (==) x (reverse y)
02:12:48 <lambdabot>   "OK, passed 500 tests."
02:12:49 <_mpu> what's going on with merijn's test ?
02:13:03 <merijn> _mpu: It's generating a lists containing only ()
02:13:05 <shachaf> _mpu: Defaulting to [()].
02:13:13 <merijn> > (read "4") + 5
02:13:13 <lambdabot>   9
02:13:47 <merijn> lewis1711: Since I'm using the result of read to add it automatically determines I expect read to return a number, instead of having to guess what i want
02:13:49 <shachaf> > re–∞d "4 + 5"
02:13:52 <lambdabot>   9
02:14:14 <lewis1711> merijn: but couldn't it be a float? :O
02:14:22 <shachaf> lewis1711: Again, defaulting.
02:14:51 <merijn> lewis1711: It's returning a Num a
02:14:54 <merijn> :t (+)
02:14:55 <lambdabot> forall a. (Num a) => a -> a -> a
02:15:28 <lewis1711> so there's a type hierarchy
02:15:36 <shachaf> lewis1711: An evil one, but yes.
02:15:43 <Phyx-> lol
02:15:46 <shachaf> Amusing, too:
02:15:46 <Phyx-> why is it evil?
02:15:46 <shachaf> @src Real
02:15:47 <lambdabot> class  (Num a, Ord a) => Real a  where
02:15:47 <lambdabot>     toRational      ::  a -> Rational
02:15:50 <lewis1711> so sort of like
02:15:59 <lewis1711> let Numer = int | float
02:15:59 <merijn> lewis1711: (+) basically says it knows how to add any a which is a number, it automatically determines 5 to be a Num (no clue what the default is) and then expects a similar number from read
02:16:26 <merijn> lewis1711: Not really, go take a look at typeclasses (learn you a haskell has a good intro)
02:16:31 <merijn> @where lyah
02:16:31 <lambdabot> http://www.learnyouahaskell.com/
02:17:41 <lewis1711> I will at some stage, but I am mainly just distracting myself from my current tutorial
02:17:53 <merijn> Which one?
02:18:09 <lewis1711> write yourself a scheme in 48 hours
02:18:17 <lewis1711> captains log, hour one..
02:18:27 <merijn> I'd ditch that one and go read learn you a haskell
02:20:26 <merijn> I tried write yourself a scheme for a bit, but then I realized I much preferred non-threatening pictures to masochistic tasks while just beginning :p
02:20:45 <jonkri> would it be possible to get some more information than "At least the following dependencies are missing"? i installed everything with "cabal install haxml html mtl network polyparse regex-compat stm" but i still get the error
02:21:18 <Kaidelong> > quickCheck (\x -> mconcat x == mconcat (reverse x))
02:21:19 <lambdabot>   Not in scope: `quickCheck'
02:21:38 <Kaidelong> @check (\x -> mconcat x == mconcat (reverse x))
02:21:39 <lambdabot>   "OK, passed 500 tests."
02:22:09 <Kaidelong> I hope it isn't using () for its default monoid since () has a commutative mappend
02:22:47 <Kaidelong> @check ((\x -> mconcat x == mconcat (reverse x)) . compare 5)
02:22:48 <lambdabot>   Couldn't match expected type `[a]'
02:22:53 <merijn> What's the correct way of adding type annotations to lambda's?
02:22:56 <Kaidelong> @check ((\x -> mconcat x == mconcat (reverse x)) . fmap (compare 5))
02:22:57 <lambdabot>   "Falsifiable, after 17 tests:\n[6,-4,2,9,6,-8,-7,9,0]\n"
02:23:09 <merijn> @check \x :: [Int] -> x == reverse x
02:23:09 <lambdabot>   Parse error at "::" (column 4)
02:23:40 <merijn> @check \x -> x == reverse x :: [Int] -> Bool
02:23:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
02:23:45 <Kaidelong> @check \(x :: [Int]) -> x == reverse x -- like in ML?
02:23:45 <lambdabot>   Parse error in pattern at "->" (column 15)
02:23:59 <merijn> @check (\x -> x == reverse x) :: [Int] -> Bool
02:23:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
02:24:34 <merijn> Dunno then :\
02:24:34 <Kaidelong> @check \x-> (x :: [Int]) == reverse x -- like in ML?
02:24:35 <lambdabot>   "Falsifiable, after 3 tests:\n[4,2,2,1]\n"
02:24:49 <merijn> ah, there we go
02:25:25 <Jafet> @check let f x :: [Int] -> Bool; f x = x == reverse x in f
02:25:25 <lambdabot>   Parse error at "::" (column 9)
02:25:35 <Jafet> @check let f :: [Int] -> Bool; f x = x == reverse x in f
02:25:35 <lambdabot>   "Falsifiable, after 2 tests:\n[1,2,2]\n"
02:25:52 <Kaidelong> @check (\x -> mconcat (x :: [Ordering]) == mconcat (reverse x))
02:25:53 <lambdabot>   "Falsifiable, after 4 tests:\n[LT,EQ,GT]\n"
02:26:22 <Kaidelong> Ordering seems like a better default for Monoid than () at least
02:26:30 <Kaidelong> perhaps a simpler one would be Either () ()
02:26:49 <Kaidelong> @instances-importing Monoid
02:26:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:27:33 <Kaidelong> huh
02:28:51 <Kaidelong> well I could see this: Left x `mappend` _ = Left x; _ `mappend` Left y = Left y; Right x `mappend` Right y = Right (x `mappend` y); mempty = Right mempty
02:30:01 <Kaidelong> wait no
02:30:07 <Kaidelong> that'd still be commutative
02:30:32 <Kaidelong> Ordering it is then
02:30:35 <quicksilver> a traditional monad on either does 'first-success but collect errors'
02:30:56 <quicksilver> kind of the opposite of what you said, but similar shape
02:31:09 <quicksilver> s/monad/monoid/ (sorry!)
02:31:25 <jonkri> how can i have runhaskell Setup.hs use my local libraries installed in ~/.cabal?
02:31:29 <Kaidelong> still doesn't solve the problem of wanting a non-commutative monoid though
02:31:36 <kuffaar> jonkri: --user
02:31:36 <quicksilver> jonkri: --user
02:31:40 <quicksilver> Kaidelong: how about ++
02:31:40 <kuffaar> I win!
02:32:12 <quicksilver> Kaidelong: also (.) although that's not a haskell Monoid without a wrapper
02:32:12 <Kaidelong> quicksilver: wouldn't Ordering be a better default? Wouldn't it also default to [()]?
02:32:26 <quicksilver> well, defaults are just stupid, full stop.
02:32:35 <Kaidelong> [()] is a commutative monoid
02:32:36 <quicksilver> but, yes, Ordering is a nice simple one I agree.
02:32:39 <Kaidelong> [a] just isn't in general
02:33:48 <Kaidelong> I think [()] is actually the ONLY commutative monoid in [a]
02:34:02 <Kaidelong> so that makes that default that much more unfortunate
02:34:20 <quicksilver> well there are other stupid examples
02:34:20 <Kaidelong> (you could make another unit type equivalent to () in all but name, of course)
02:34:22 <quicksilver> but yes, basically.
02:34:30 <quicksilver> [Void] is commutative.
02:34:41 <Kaidelong> but it is not inhabited I don't think
02:34:45 <Kaidelong> so you couldn't test it anyway
02:34:46 <quicksilver> it has one element, []
02:34:49 <Kaidelong> oh
02:34:53 <Kaidelong> oh!!!
02:34:56 <Kaidelong> wow
02:35:11 <Kaidelong> it seems so obvious now
02:36:01 <crimeney> Is there a name for ***the signature of a method minus the name***, that is the parameter types + the return type of a method in computer science?
02:36:30 <shachaf> crimeney: Perhaps "type signature"?
02:36:42 <quicksilver> I would just call that the signature, I think
02:36:43 <Kaidelong> @check (\x -> mconcat (x :: [First a]) == mconcat (reverse x))
02:36:44 <lambdabot>   Inferred type is less polymorphic than expected
02:36:44 <lambdabot>    Quantified type variable...
02:36:49 <quicksilver> I don't consider the name part of the signature
02:37:02 <Kaidelong> @check (\x -> mconcat (x :: [First Bool]) == mconcat (reverse x))
02:37:03 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
02:37:03 <lambdabot>                     (Data.Monoid...
02:37:18 <Kaidelong> @check (\x -> mconcat (x :: [Maybe Bool]) == mconcat (reverse x))
02:37:18 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
02:37:19 <lambdabot>    arising from a use of...
02:37:52 <Kaidelong> @check (\x -> mconcat (x :: [Maybe Any]) == mconcat (reverse x))
02:37:53 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary Data.Monoid.Any)
02:37:53 <lambdabot>    arising from...
02:38:00 <Kaidelong> huh
02:38:13 <Kaidelong> @instances-importing Monoid
02:38:13 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:38:41 <Kaidelong> ah well, anything like that would just end up with 3 values anyway, same as Ordering
02:39:25 <Kaidelong> perhaps Ordering is truly as simple as you can get for a non-commutative monoid, after all, you need a 0 element, and then two elements that you can tell apart from each other...
02:39:31 <Kaidelong> Yes exactly!
02:39:34 <shachaf> quicksilver: [Void] is inhabited, but I don't think you could make a QuickCheck instance for it.
02:39:40 <Kaidelong> Ordering is the simplest non-commutative monoid
02:40:11 <Kaidelong> you can't do better
02:40:57 <Kaidelong> well I guess you can if you do something weird with strictness
02:41:02 <Kaidelong> but then you'd make quickcheck halt
02:41:09 <Kaidelong> err
02:41:12 <Kaidelong> stop it from doing so
02:41:19 <Kaidelong> so that's noot an option
02:41:38 <Kaidelong> also I think that'd violate a monoid law
02:41:47 <Kaidelong> mappend is supposed to be strict in both arguments, IIRC
02:41:52 * osfameron calls the monoid police
02:42:34 <quicksilver> strictness isn't in the laws
02:42:53 <quicksilver> none of the algebraic laws mention strictness because it's not an algebraic property
02:43:03 <quicksilver> I tend to read laws as only applying to the total fragment of the language
02:43:32 <shachaf> quicksilver: Haskell is a total language.
02:43:40 * shachaf will silence the dissenters.
02:43:56 <Kaidelong> quicksilver: but Haskell is partial, so we do need to think about whether it is appropriate for nonzero `mappend` _|_ to return something different from _|_ `mappend` nonzero
02:44:07 <merijn> Really? What happens when I write "fix error" then?
02:44:24 <quicksilver> I choose not to think about, Kaidelong ;)
02:44:24 <silver> > fix error
02:44:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
02:44:30 <shachaf> merijn: "fix"? "error"? I do not know these words.
02:44:40 <Jafet> @vixen like, totally
02:44:40 <lambdabot> there are a lot of weirdos on here
02:44:41 <quicksilver> I choose to think that the laws only apply in the total fragment.
02:44:48 <quicksilver> vixen++
02:45:05 <shachaf> @vixen What do you think of quicksilver?
02:45:06 <lambdabot> maybe. do you?
02:45:27 <crimeney> @vixen monoid
02:45:27 <lambdabot> Yeah
02:45:29 <Kaidelong> @vixen Are you onto?
02:45:29 <lambdabot> yes
02:45:41 <Kaidelong> @vixen Are you not onto?
02:45:42 <lambdabot> nevermind about that
02:45:52 <shachaf> @vixen Are you surjective?
02:45:53 <lambdabot> isn't it obvious?
02:46:21 <crimeney> @vixen You look marvelous
02:46:22 <lambdabot> who?
02:46:45 <Kaidelong> @vixen What is a simple non-commutative monoid?
02:46:45 <lambdabot> let's don't talk about that
02:47:06 <Kaidelong> excellent
02:47:43 <crimeney> @vixen What is is?
02:47:44 <lambdabot> let's don't talk about that
02:50:02 <Kaidelong> @instances-importing Semigroup
02:50:03 <lambdabot> Couldn't find class `Semigroup'. Try @instances-importing
02:55:25 <Kaidelong> for a group, are elements other than 0 allowed to be their own inverses?
02:57:56 <quicksilver> Kaidelong: yes, absolutely
02:58:00 <sipa> Kaidelong: in the multiplicative group of Z, -1 is its own inverse, eg.
02:58:20 <quicksilver> Kaidelong: algebraic theories typically don't forbid things.
02:58:26 <Kaidelong> okay, then the simplest group I can think of that is not commutative is the iniontegers modolu 3, with subtract
02:58:29 <Kaidelong> ion
02:58:40 <ion>  
02:58:44 <Kaidelong> oops
02:58:49 <lewis1711> groups can have more than one operation? hmm
02:58:56 <mm_freak> the simplest group has only one element
02:58:57 <sipa> groups have one operation
02:59:06 * lewis1711 has forgotten far too much abstract algebra for his liking
02:59:08 <mm_freak> and an arbitrary operator
02:59:18 <Kaidelong> mm_freak: but is it abelian?
02:59:22 <quicksilver> mm_freak: I think you missed "taht is not commutative"
02:59:33 <mm_freak> quicksilver: oh, true
02:59:48 <mm_freak> Kaidelong: obviously yes, since it has only the identity element
03:00:48 <Kaidelong> but there is a problem
03:00:49 <lewis1711> an albelian group is a group where every element is its own inverse, IIRC
03:00:53 <Kaidelong> 0 - 2 = 1
03:00:55 <lewis1711> no that's not it
03:00:56 <Kaidelong> 0 - 1 = 2
03:01:35 <Kaidelong> so it is not a group
03:02:21 <mm_freak> well, the rubik's cube group has six elements and is not abelian
03:02:30 <sipa> abelian group is a group where the operation is commutative
03:02:42 <mm_freak> can't think of anything with less elements or simpler
03:03:07 <lewis1711> sipa: ah
03:03:11 <Kaidelong> mm_freak: you just need 3, I know that for certain. Just trying to think of an example.
03:03:17 <lewis1711> I loved that shit:) must take another abstract algebra class
03:03:36 <lewis1711> favourite part of mathematics. that and graph theory
03:03:41 <mm_freak> but actually you can't tell whether a singleton element group is abelian or not, because it has only one element
03:03:45 <mm_freak> so you can regard it as both
03:03:58 <sipa> i'd say the trivial group is abelian :)
03:04:46 <Kaidelong> F + F = F, TT + T = TT, T + TT = T, F + T = T = T + F, TT + F = TT = F + TT
03:04:55 <Kaidelong> and
03:05:02 <Kaidelong> TT + TT = F, T + T = F
03:05:09 <mm_freak> there is only one possible operation with only one possible result in the single element group:  1 + 1 = 1
03:05:10 <Kaidelong> that makes a group with 3 elements that is not abelian
03:05:20 <mm_freak> so the group is both abelian and non-abelian
03:05:35 <Kaidelong> I just can't think of where you'd actually use a group like that
03:05:41 <mm_freak> well, 0 + 0 = 0 actually in the additive notation
03:06:11 <Kaidelong> sure, you can put 0 there for F, 1 for T, and 2 for TT
03:06:40 <Kaidelong> Ordering is not like that
03:06:48 <mm_freak> Kaidelong: my point is that you don't need 3 elements =)
03:07:28 <Kaidelong> mm_freak: if you only have one element you can't demonstrate that it isn't commutative
03:08:22 <mm_freak> Kaidelong: and you can't prove the opposite, so both is true‚Ä¶  you can use such a group in the context of both commutative and noncommutative groups
03:08:42 <Kaidelong> mm_freak: I don't think that'd help if you were to do a quickcheck for groups
03:08:42 <mm_freak> i think also groups with two elements have this property
03:08:48 <Kaidelong> yes
03:09:01 <Kaidelong> monoid needs at least 3 elements too before it can be non-commutative
03:09:09 <mm_freak> in fact every group, where each element is its own inverse
03:09:31 <Kaidelong> that group I demonstrated above has that property
03:09:34 <mm_freak> uhm, no
03:09:38 <mm_freak> sorry, that was wrong
03:09:42 <Kaidelong> but T + TT and TT + T are distinguishable
03:09:42 <Kaidelong> yes
03:10:50 <Kaidelong> mm_freak: I'd say you could assume something is commutative if there is no counterexample
03:11:06 <Kaidelong> but a single counterexample is enough to say it isn't, obviously
03:11:27 <mm_freak> Kaidelong: yes, but you could also say the opposite
03:11:45 <Kaidelong> mm_freak: No, you couldn't
03:11:47 <Kaidelong> 1 - 1
03:11:58 <Kaidelong> - is commutative
03:12:11 <Kaidelong> qed.
03:12:20 <sipa> that's an example, not a counterexample
03:12:23 <mm_freak> Kaidelong: if 0 and 1 are the only elements, then yes, - is commutative
03:12:36 <mm_freak> nothing wrong with that
03:12:49 <mm_freak> after all it's not an operation or your interpretation, which is commutative, but the group as a whole
03:12:58 <Kaidelong> mm_freak: not really what I was meaning there
03:13:05 <Kaidelong> I assumed the opposite would be
03:13:18 <Kaidelong> "assume something is non-commutative, unless you can find a counterexample"
03:13:43 <mm_freak> i think, the best way to tell whether something has a certain property is to test, whether you can generally use that something in a context, where that property is required
03:14:27 <Kaidelong> if there is a counterexample to the argument that something is commutative, obviously it isn't, but the same doesn't hold for saying something is not commutative
03:14:34 <Kaidelong> a counterexample does not disprove that
03:15:13 <mm_freak> i get your point, but is that the specification of a commutative group?
03:15:33 <Kaidelong> mm_freak: I was more thinking of a good base type for quickcheck to use for a monoid!
03:15:43 <Kaidelong> that group up there would also be a good default for a group
03:15:51 <Kaidelong> and it would work for the monoid
03:15:57 <Kaidelong> as well
03:16:03 <mm_freak> sure, for testing it's fine
03:16:12 <mm_freak> but not for real proofs, i think
03:16:17 <Kaidelong> oh yes
03:16:22 <Kaidelong> Well context difference
03:16:25 <Kaidelong> sorry
03:17:06 <Kaidelong> obviously finding a counterexample is very important with quick check
03:17:28 <mm_freak> (it's funny how talking about your favorite movies is considered off-topic here, but nobody complains about a lengthy discussion about abstract algebra) =)
03:17:53 <merijn> How is that funny?
03:17:55 <Kaidelong> abstract algebra is not all that off topic in a programming language channel though
03:17:57 <merijn> Seems pretty logical
03:18:13 <Kaidelong> especially in the context of one with typeclasses
03:18:19 <merijn> abstract algebra, type theory and occasionally category theory are common topics here
03:18:59 <JuanDaugherty> well not as such, only in the context of haskell
03:21:42 <lewis1711> Kaidelong: it would be in #c :P
03:21:50 <merijn> Even out of haskell context, I've held plenty of type theory discussions with no relation whatsoever to haskell :p
03:22:11 <Kaidelong> lewis1711: But C has stuff like types and expressions too, doesn't it?
03:22:31 <lewis1711> yeah but i can't imagine them having a good ol chat about abelian groups
03:22:57 <Kaidelong> well I was more interested in non-abelian groups
03:23:14 <Kaidelong> (abelian group is simple: () )
03:24:29 <Kaidelong> @check \x -> mconcat x == mconcat (reverse x)
03:24:30 <lambdabot>   "OK, passed 500 tests."
03:24:35 <Kaidelong> this is the problem though
03:24:58 <Kaidelong> @check \x -> mconcat (x :: [Ordering]) == mconcat (reverse x)
03:24:59 <lambdabot>   "Falsifiable, after 5 tests:\n[LT,GT,EQ]\n"
03:26:13 <Kaidelong> () is also an abelian monoid
03:26:27 <Kaidelong> I guess any abelian group is also an abelian monoid and an abelian semigroup
03:32:29 <mm_freak> Kaidelong: in other channels you get redirected to #math
03:32:36 <lewis1711> ugh
03:32:44 <lewis1711> have you guys been to #math on this network?
03:32:46 <lewis1711> horrible place:P
03:32:48 <lewis1711> I go to efnet
03:34:19 <Kaidelong> maybe that helps retain people who look at what is going on in the channel and think "this is too hard for me I'm leaving"
03:35:00 <mm_freak> well, #math ops told me to stop using UTF-8 ellipsis, unless i use it appropriately‚Ä¶  since then i never joined there again
03:36:06 <Kaidelong> mIRC didn't used to play nice with UTF-8 back in the day
03:36:14 <Kaidelong> that might still be the case
03:36:21 <ion> What‚Äôs ‚Äúappropriately‚Äù in this case?
03:36:52 <mm_freak> ion: no idea‚Ä¶  probably in the typographic sense
03:36:55 <ion> kaidelong: mIRC has finally switched to sending messages in UTF-8 by default.
03:37:03 <Kaidelong> yay
03:37:06 <Kaidelong> err
03:37:07 <Kaidelong> maybe
03:37:14 <Kaidelong> I do not use it so I do not really care
03:37:20 <Kaidelong> but that's good, I guess?
03:38:15 * kuffaar just finished http://book.realworldhaskell.org/read/monads.html and didn't really grasp the state monad at all
03:38:18 <ion> mm_freak: Whatever is considered ‚Äúappropriate‚Äù use of ellipsis, isn‚Äôt it irrelevant whether it‚Äôs real character or the ASCII approximation? :-)
03:39:33 <merijn> kuffaar: Monads in general or just the state monad?
03:39:42 <kuffaar> The state monad
03:40:01 <merijn> ok, I find that one a bit complicated too :p
03:40:31 <mm_freak> ion: yes, i asked myself the same question
03:41:04 <kuffaar> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Class.html
03:41:08 <kuffaar> class Monad m => MonadState s m | m -> s where
03:41:11 <kuffaar> What does that | even mean?
03:41:22 <kuffaar> Never seen that in a class statement before
03:41:25 <sipa> it's for functional dependencies
03:41:47 <kuffaar> It wasn't even part of the RWH chapter hm
03:41:56 <kuffaar> So the real thing is even more complicated
03:42:14 <faust45> is any one know how i can change coordinate system with HOpenGL
03:42:15 <faust45> ?
03:42:20 <kuffaar> sipa well what does it mean in that statement?
03:42:21 <Jafet> Fundeps are a language extension
03:42:47 <kuffaar> So Control.Monad.State.Class uses {-# LANGUAGE Fundeps #-}?
03:42:49 <mm_freak> kuffaar: it might help to think of state monads like this:  type State s a = a -> (s, a)
03:42:49 <Kaidelong> RWH does cover them at some point I believe, though
03:42:53 <Kaidelong> GADTs too
03:43:02 <sipa> kuffaar: it means that if you know the type m, there can only be one type f for which the class MonadState s m holds
03:43:07 <kuffaar> mm_freak yeah that's the one RWH uses
03:43:13 <kuffaar> Kaidelong: GADT = ?
03:43:15 <jonkri> should AGPL be added to the list of licenses in cabal?
03:43:21 <mm_freak> kuffaar: i think RWH uses a newtype
03:43:34 <kuffaar> type SimpleState s a = s -> (a, s)
03:43:37 <kuffaar> http://book.realworldhaskell.org/read/monads.html
03:43:42 <mm_freak> ah, ok
03:43:56 <mm_freak> anyway, as soon as you understand (>>=), you understand state monads
03:44:13 <Kaidelong> kuffaar: Generalized Algebraic Data Types, I believe
03:46:03 <kuffaar> I know the signature of >>= and that it's a method of the Monad type class and that it's called the bind operator and I know its definitiion for some standard monads such as Maybe and [] but I am none the wiser about state monads
03:47:06 <mm_freak> kuffaar: it's easy‚Ä¶  you have a state transformer (i.e. a function of type a -> (a,s)) and you have a function, which gives you a state transformer
03:47:24 <mm_freak> (>>=) is a combinator to pass the result (the 'a' part of the tuple) to the consuming function
03:47:45 <kuffaar> sipa: What does the type f even have to do with MonadState?
03:48:42 <mm_freak> applied to the SimpleState, (>>=) becomes this:  m a -> (a -> m b) -> m b = (s -> (a,s)) -> (a -> s -> (b,s)) -> (s -> (b,s))
03:49:19 <sipa> kuffaar: s, nog f :)
03:49:21 <sipa> kuffaar: sorry
03:49:27 <kuffaar> Oh
03:49:34 <sipa> *not
03:49:42 <mm_freak> just remember that a state transformer is just a function from a state value to a new state value and a result‚Ä¶  and (>>=) gives you a way to compose such functions
03:50:12 <hydo> Is there any safe way to upgrade time to the latest version and still keep ghc-6.12.3 from puking all over itself?
03:50:14 <kuffaar> sipa: I don't even understand the "holds" part - it's not like a MonadState is a mathematical statement which evaluates to either true or false - it's a typeclass with a set of methods
03:50:35 <sipa> kuffaar: logically it is a boolean expression over types
03:50:39 <Kaidelong> @ty flip ((.) . uncurry)
03:50:40 <lambdabot> forall b (f :: * -> *) a b1. (Functor f) => f (a, b1) -> (a -> b1 -> b) -> f b
03:50:41 <hydo> Hrm... maybe my problem was just that a lot of packages needed reinstalling.
03:51:12 <sipa> kuffaar: so you could also read it as "for a given type m, there will at most be one type s such that an instance for MonadState s m exists"
03:51:23 <Kaidelong> @ty flip (flip (.) . uncurry)
03:51:24 <lambdabot> forall a b a1 b1. (a -> b) -> (a1 -> b1 -> a) -> (a1, b1) -> b
03:52:35 <kuffaar> sipa: And when I attempt to do this more than once then ghc will spit out an error?
03:52:42 <kuffaar> Because of the Fundeps?
03:52:45 <Kaidelong> why did that not work
03:54:32 <kuffaar> sipa: I don't get this because it sounds like I can't have more than one state monade which stores nothing but a string, for example
03:54:37 <kuffaar> monad* too
03:55:42 <sipa> how many state monads can you think of that use a string as state?
03:55:56 <kuffaar> a non finite amount?
03:56:06 <sipa> give me two different ones
03:56:42 * hackagebot web-routes-quasi 0.6.3 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.3 (MichaelSnoyman)
03:56:48 <sipa> wait that's the wrong question
03:56:50 <Kaidelong> sipa: how about a turing machine with () as the non-state type?
03:57:01 <jonkri> how do i set "UnknownLicense String" in my cabal file? i've tried "UnknownLicense AGPL-3" and "UnknownLicense "AGPL-3""
03:57:04 <kuffaar> The type signatures would be identical, so you have to use newtype or data every time with a new String inside, sipa?
03:58:00 <sipa> kuffaar: if i show you a monad, which implements MonadState
03:58:08 <sipa> it will store one state only
03:58:20 <sipa> so by just looking at the type of the monad, you can see which state it uses
03:58:31 <sipa> that's what it means
03:58:31 <dcoutts_> jonkri: just use: license: AGPL-3
04:00:06 <lewis1711> > read "3"::Num
04:00:08 <lambdabot>   Class `GHC.Num.Num' used as a type
04:00:12 <lewis1711> why can't I do this?
04:00:15 <jonkri> dcoutts_: "Warning: 'license: AGPL-3' is not a recognised license. The known licenses are: GPL, GPL-2, GPL-3, LGPL, LGPL-2.1, LGPL-3, BSD3, BSD4, MIT, PublicDomain, AllRightsReserved, OtherLicense"... guess i should go with OtherLicense?
04:00:55 <lewis1711> oh..it's a class. humm this lambdabot gives better errors than ghci
04:00:55 <quicksilver> lewis1711: because "Num" isn't a type.
04:01:44 <kuffaar> Num is a typeclass
04:01:49 <dcoutts_> jonkri: if you want to be able to upload to hackage then yes, otherwise you can ignore the warning
04:01:55 <kuffaar> lewis1711: Try Int?
04:02:06 <jonkri> ah, thanks
04:03:20 <lewis1711> kuffaar: yeah I know int will work just wondering why I couldn't use Num. will find out later in my mystical haskell journey I imagine
04:03:58 <kuffaar> lewis1711: Well, it's a typeclass, not a type - you make types instances of typeclasses and then define new methods for those instances
04:04:06 <kuffaar> There are many instances of Num
04:04:15 <kuffaar> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num
04:04:23 <Kaidelong> @ty liftM
04:04:24 <earthy> you cannot use read for an arbitrary Num, as then the compiler will not know which implementation of read to pick
04:04:24 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:04:31 <Kaidelong> @ty liftM2
04:04:32 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:04:56 <Kaidelong> @ty (liftM .) . liftM
04:04:57 <lambdabot> forall a1 r (m :: * -> *) a11. (Monad m) => (a11 -> r) -> (a1 -> a11) -> m a1 -> m r
04:05:20 <Aristid-andro> :t fromInteger . read
04:05:21 <lambdabot> forall a. (Num a) => String -> a
04:05:25 <kuffaar> fromIntegral (read "1"::Int)
04:05:44 <Aristid-andro> Int is bad
04:05:51 <kuffaar> Aristid-andro hmm isn't it problematic with composition?
04:05:54 <kuffaar> Ohh it's inferred then
04:06:00 <lewis1711> interesting
04:06:01 <kuffaar> Sneaky
04:06:10 <lewis1711> type orientated programming? :P
04:06:18 <Aristid-andro> itsa haskell
04:06:21 <kuffaar> > (fromInteger . read) "1"
04:06:23 <lambdabot>   1
04:06:35 <kuffaar> > fromInteger (read "1"::Int)
04:06:37 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
04:06:37 <lambdabot>         against inf...
04:06:40 <kuffaar> Oh snap
04:06:41 <Kaidelong> @ty (liftM2 .) . liftM2
04:06:43 <lambdabot> forall a2 r (m :: * -> *) a1 a21. (Monad m) => (a1 -> a21 -> r) -> (a2 -> a1) -> m (a2 -> a21) -> m a2 -> m r
04:06:55 <Kaidelong> @ty (liftM .) . liftM2
04:06:56 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m1 a1 -> m (m1 a2) -> m (m1 r)
04:07:00 <kuffaar> > fromIntegral (read "1"::Int)
04:07:01 <lambdabot>   1
04:07:10 <kuffaar> :t fromInteger
04:07:11 <lambdabot> forall a. (Num a) => Integer -> a
04:07:37 <Aristid-andro> :t fromIntegral
04:07:38 <Kaidelong> @ty (liftM2 .) . liftM --finally?
04:07:38 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:07:40 <lambdabot> forall a1 a2 r (m :: * -> *) a11. (Monad m) => (a11 -> a2 -> r) -> (a1 -> a11) -> m a1 -> m a2 -> m r
04:08:39 <Kaidelong> @ty liftM2 >=> liftM
04:08:40 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (m a2 -> a2 -> r) -> m (m a2) -> m (m r)
04:15:59 <lewis1711> woah
04:16:02 <lewis1711> I need a colourful ghci
04:16:10 <lewis1711> or want, whatever
04:17:10 <Kristobo> hi
04:17:37 <Kristobo> hello?
04:19:55 <quicksilver> hello kristobo.
04:22:39 <Kristobo> hi, im new on  haskell 
04:22:50 <kuffaar> Kristobo: Nice, most people are
04:22:52 <kuffaar> Including me
04:23:04 <Kristobo> jajajajaj
04:23:28 <merijn> There's 660 people here, I'm pretty sure most aren't newbies :p
04:23:31 <kuffaar> You might want to use "haha" instead of "jaja" when speaking English
04:23:45 <Kaidelong> > let (&@) = id in (&@) 5
04:23:46 <kuffaar> merijn: Out of those 660 about 80 might have gotten past the hello world stage
04:23:46 <lambdabot>   5
04:23:47 <lewis1711> "Tuples are types but they are dependent on their length as well as the types of their components, so there is theoretically an infinite number of tuple types, which is too many to cover in this tutorial." - I lol'd
04:23:56 <Kristobo> lol
04:23:58 <Kristobo> hahahahhaah
04:23:59 <Kaidelong> > let (&@) = id in (5 &@)
04:24:01 <lambdabot>   5
04:24:05 <Kaidelong> what
04:24:09 <Kaidelong> that didn't work in GHCi
04:24:17 <Kaidelong> it complained about the section but not the prefix
04:24:22 <merijn> Kaidelong: Lambdabot is filled with filthy lies
04:24:37 <merijn> :t map 5 [1..]
04:24:38 <lambdabot> forall b. (Num b) => [b]
04:24:45 <Kaidelong> ...wait
04:24:49 <merijn> :t map 5
04:24:50 <lambdabot> forall a b. (Num b) => [a] -> [b]
04:24:55 <Kaidelong> > let (&@) = id in (&@) "lambdabot"
04:24:57 <lambdabot>   "lambdabot"
04:25:09 <Kaidelong> > let (&@) = id in ("lambdabot" &@)
04:25:10 <lambdabot>   "lambdabot"
04:25:21 <Kaidelong> wait what
04:25:33 <merijn> Kaidelong: You were applying the 5 function to &@
04:25:38 <merijn> > 5 5
04:25:39 <lambdabot>   5
04:25:46 <kuffaar> lol
04:25:53 <Kaidelong> > "lambdabot" "lambdabot"
04:25:54 <lambdabot>   Couldn't match expected type `t1 -> t'
04:25:54 <lambdabot>         against inferred type `[GHC....
04:25:59 <merijn> And yes, some horrible person made all Int's a function in lambdabot
04:26:05 <kuffaar> :[
04:26:11 <Kristobo> i just  want  information about  haskell to practice about it
04:26:22 <sipa> > 5 :: (Int,Double)
04:26:23 <lambdabot>   (5,5.0)
04:26:26 <Kristobo> thanks i wait your answer
04:26:29 <Kaidelong> merijn: lambdabot still accepts a section where GHCi doesn't, even without considering the function instance for numbers
04:26:30 <sipa> > 5 :: (Int,Double) + 3
04:26:30 <lambdabot>   Only unit numeric type pattern is valid
04:26:37 <sipa> > (5 :: (Int,Double)) + 3
04:26:38 <lambdabot>   (8,8.0)
04:27:18 <Kaidelong> merijn: where I replaced 5 with "lambdabot" anyway
04:28:08 <merijn> I have no idea beyond my generic warning of lambdabot being filled with vile lies.
04:30:39 <Kaidelong> > let (!!!) = (++" I tell ya!") in ("Lambdabot is filled with vile lies"!!!)
04:30:42 <lambdabot>   "Lambdabot is filled with vile lies I tell ya!"
04:31:42 <kuffaar> > let {micro x = True; oft x = True; rule = True} in micro$oft rule
04:31:43 <lambdabot>   True
04:32:00 <quicksilver> Kaidelong: let (&@) = id in (5 &@) doesn't work in ghci because it needs a Num instance for functions.
04:32:18 <quicksilver> you are not, of course, applying the 5 function to &@
04:32:19 <merijn> quicksilver: Doesn't explain the other one
04:32:23 <quicksilver> which other one?
04:32:34 <merijn> > let (&@) = id in ("lambdabot" &@)
04:32:35 <lambdabot>   "lambdabot"
04:32:54 <quicksilver> @type "a"
04:32:55 <lambdabot> [Char]
04:33:09 <quicksilver> hmm
04:33:30 <Kaidelong> or the one with !!! above
04:33:32 <quicksilver> > (id,"a")
04:33:33 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
04:33:33 <lambdabot>    arising from a use of `...
04:33:35 <Kaidelong> same thing
04:33:37 <quicksilver> @type (id,"a")
04:33:38 <lambdabot> forall a. (a -> a, [Char])
04:33:46 <quicksilver> @type [id,"a"]
04:33:47 <lambdabot>     Couldn't match expected type `a -> a'
04:33:47 <lambdabot>            against inferred type `[Char]'
04:33:47 <lambdabot>     In the expression: "a"
04:33:54 <quicksilver> > [id,"a"]
04:33:55 <lambdabot>   Couldn't match expected type `a -> a'
04:33:55 <lambdabot>         against inferred type `[GHC.T...
04:34:14 <quicksilver> nope, I don't understand that one either
04:34:22 <Kaidelong> it's a mystery
04:38:13 <quicksilver> I think it might be a GHC version.
04:38:33 <quicksilver> ("lambdabot" `id`) = id "lambdabot" = "lambdabot"
04:38:39 <quicksilver> is superficially valid.
04:39:01 <quicksilver> but my GHC here seems to force a two parameter interpretation of id, when used in a section.
04:39:51 <Kaidelong> mine too
04:40:26 <Kaidelong> @ty ($)
04:40:27 <lambdabot> forall a b. (a -> b) -> a -> b
04:40:45 <Kaidelong> no intentional meddling to make $ id then
04:41:25 <Kaidelong> > ("None at all"$)
04:41:26 <lambdabot>   Couldn't match expected type `a -> b'
04:41:26 <lambdabot>         against inferred type `[GHC.T...
04:41:49 <Kaidelong> what version of GHC is lambdabot running?
04:41:52 * hackagebot turni 2011.1.10 - tool per la creazione dei turni commessi in un negozio di vestiti  http://hackage.haskell.org/package/turni-2011.1.10 (PaoloVeronelli)
04:42:18 <Jonno_FTW> > let rot x = (take . length) $ iterate (\y->last y : init y) x in rot "banana"
04:42:19 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
04:42:19 <lambdabot>    arising from a use ...
04:44:49 <Kaidelong> > take 6 . map take 6 . tails . cycle $ "banana"
04:44:50 <lambdabot>   Couldn't match expected type `a1 -> [a]'
04:44:50 <lambdabot>         against inferred type `[[a...
04:45:01 <kuffaar> Uhm to use the State monad I should import Control.Monad.State.Class, right?
04:45:11 <kuffaar> Although State is in Control.Monad.State.Lazy?
04:45:12 <Kaidelong> > take 6 . map (take 6) . tails . cycle $ "banana"
04:45:15 <lambdabot>   ["banana","ananab","nanaba","anaban","nabana","abanan"]
04:45:21 <kuffaar> But MonadState is in Control.Monad.State.Class hm
04:46:04 <alpounet> @index MonadState
04:46:04 <lambdabot> Control.Monad.State, Control.Monad.RWS
04:46:23 <kuffaar> @index State
04:46:24 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
04:46:24 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
04:46:29 <kuffaar> Oh boy
04:46:38 <kuffaar> I guess Control.Monad.State will do
04:46:43 <alpounet> yeah
04:51:18 <kuffaar> Ambiguous module name `Control.Monad.State':
04:51:18 <kuffaar>   it was found in multiple packages: mtl-2.0.1.0 monads-fd-0.2.0.0
04:51:23 <Jonno_FTW> @src tails
04:51:23 <lambdabot> tails []         = [[]]
04:51:23 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
04:51:35 <Jonno_FTW> > tails "banana"
04:51:36 <lambdabot>   ["banana","anana","nana","ana","na","a",""]
04:52:10 <kuffaar> Wtf is monads-fd and why does it ruin everything I try to do with state monads :'(
04:53:11 <kuffaar> Why would the same module name possibly show up in multiple packages?
04:53:14 <kuffaar> That is just cruel
04:54:00 <quicksilver> two alternative implementations
04:54:04 <kuffaar> http://hackage.haskell.org/package/monads-fd
04:54:10 <kuffaar> Should I remove it...?
04:54:17 <kuffaar> This package is obsolete: use mtl instead.
04:54:23 <kuffaar> I have no idea what installed it in the first place then
04:55:01 <kuffaar> Because right now it is essentially preventing me from using Control.Monad.State?
04:55:35 <int-e> if you don't want to remmove it, ghc-pkg hide monads-fd
04:56:06 <kuffaar> Cheers
04:56:46 <kuffaar> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful I'm trying to run this example with the run :: State Int a -> a
04:56:46 <kuffaar>  in it
04:56:54 <kuffaar>     Illegal signature in pattern: State Int a -> a run m
04:56:54 <kuffaar>         Use -XScopedTypeVariables to permit it
04:57:11 <kuffaar> {-# LANGUAGE ScopedTypeVariables  #-} required?
04:57:42 <kuffaar> Even with that it doesn't compile hm
04:58:02 <kuffaar> run :: State Int a -> a --not in scope: a
04:58:10 <int-e> no. the code should be put into a file, not entered at the ghci prompt.
04:58:17 <kuffaar> int-e I did
04:58:46 <int-e> mm. odd. did you get the indentation wrong?
04:58:50 <kuffaar> I ghci'ed the file and now I am :r'ing it
04:59:16 <kuffaar> Oh yeah fail
05:04:46 <kuffaar> I don't really get this though - how come the signature of example does not require any monad in it?
05:05:02 <kuffaar> It's like you took something stateful and suddenly it's pure...?
05:05:23 <int-e> kuffaar: because the monad is implemented in terms of pure functions
05:06:29 <Jafet> Monad is just a wrapper for a common pattern in programming
05:06:31 <int-e> kuffaar: almost all monads have a function that executes it. IO is the exception here. (And some monads, when executed, will have as a result an action of a different monad, like IO, rather than a pure result.
05:06:43 <Jafet> Or, according to the wiki, two patterns
05:08:50 <merijn> kuffaar: You didn't make something stateful pure, you hid the state to make the code prettier
05:09:06 <int-e> kuffaar: underlying  State s a  is a function  s -> (s, a); the monad instance essentially hides the tedium of passing the state from one step to the next. And of course such a function will produce a value if provided with an initial state. And that's what  run  does.
05:09:56 <merijn> kuffaar: What is the difference between a global in a "stateful imperative program" and a functional program where we explicitly pass and return that same global in every function?
05:10:53 <kuffaar> One is on the stack, the other one is in .data or .bss? :p
05:11:28 <merijn> Stacks, .data and .bss are an implementation detail
05:17:49 <quicksilver> @remember Kaidelong <Kaidelong> take 6 "bananas" <lambdabot> "banana" <Kaidelong> clearly lambdabot is keeping the bananas to itself and lying about it
05:17:50 <lambdabot> I will remember.
05:19:23 <MordN> hey guys Im a newbie, can anyone tell me whats wrong with the following code? intercalate' :: a -> [a] -> [a]                   intercalate' _ [] = []                   intercalate' _ [x] = x                         intercalate' s (x:xs) = x:s:intercalate' s xs
05:20:00 <quicksilver> MordN: well, what happens when you try it?
05:20:16 <MordN>     Occurs check: cannot construct the infinite type: a = [a]     When generalising the type(s) for `intercalate''
05:20:29 <quicksilver> MordN: in your second clause, the [x] one
05:20:37 <quicksilver> MordN: the function is not returning a list
05:20:42 <quicksilver> it does in the other two cases
05:20:45 <quicksilver> that's probably not good.
05:20:59 <MordN> damn
05:21:02 <MordN> missed that one
05:21:03 <MordN> ty
05:23:08 <sm> morning.. why is lgo an optimization at http://www.reddit.com/r/haskell/comments/f150x/whats_wrong_with_my_haskell_noob_question/c1ck6ey ?
05:25:20 <quicksilver> sm: because recursive functions can't be inlined
05:25:32 <quicksilver> lgo stops foldl itself from being recursive.
05:26:13 <sm> quicksilver: thanks.. so a recursive non-top-level function is fine ?
05:27:00 <quicksilver> erm, probably
05:53:24 <Saizan> so much wrongness in the comments there
05:54:21 <merijn> Saizan: What else did you expect on reddit?
05:55:29 <j-invariant> "Why use a hammer when you can use a tactical nuke?"
05:55:30 <j-invariant> nice
06:00:34 <Bynbo7> Saizan: which comments?
06:05:10 <Saizan> Bynbo7: in the link above, the ones not finding a concrete use for foldl, or the other suggesting foldr for all the commutative functions, which corrects itself leaving the impression there's no use for foldr..
06:07:53 <ezyang> Would you consider the following pattern of f _ = error "f: not implemented" to be harmful? 
06:08:51 <Saizan> iirc, that message is less informative than the default one
06:09:07 <Saizan> (assuming you've other cases)
06:10:55 <quicksilver> the default message tells you the function name, source file, and line number
06:10:57 <j-invariant> ezyang: it's unavoidable
06:10:59 <quicksilver> normally that's handy.
06:11:33 <ezyang> well, how about in the case where, in fact, all of the cases are already covered. 
06:11:43 <ezyang> so it emits an overlapping pattern error. Is it harmful in that case? 
06:12:02 <ezyang> (this is in GHC code, and since validate compiles with -Wwarn, this is stopping my build) 
06:12:05 <quicksilver> not really, but it's only purpose is to guard against a future alternative being added
06:12:19 <quicksilver> and if a future alternative were added, the default error would be a better one?
06:12:25 <ezyang> well, shouldn't partial match errors tell you about that? 
06:12:29 <ezyang> *warnings 
06:12:39 <quicksilver> that too
06:27:24 <ion> kuffaar: You asked about State earlier. This braindump may or may not help. I tried to explain the >>= function by building it in small steps. http://heh.fi/state-monad
06:27:44 <dpratt71> I'm reading about type familes (http://www.haskell.org/haskellwiki/GHC/Type_families) and I'm not exactly 'getting' it; is there a better resource?
06:27:59 <dpratt71> (i.e. more explicit)
06:28:01 <kuffaar> Haha lambda
06:30:35 <quicksilver> dpratt71: I don't know of a better resource.
06:30:51 <quicksilver> dpratt71: are you happy with the general notion of having a 'type function' ?
06:31:07 <kuffaar> I'm not even using the state monad though
06:31:22 <kuffaar> I was dealing with SnapExtend and IORef for a counter in my hello world web dev in Haskell example
06:31:56 <dpratt71> quicksilver: more or less; that's how I've been thinking of 'kinds' (other than *)
06:32:10 <quicksilver> dpratt71: yes, 'Maybe' is an example of a type function.
06:32:21 <quicksilver> dpratt71: Int is a type, you apply Maybe to that, and "Maybe Int" is another type.
06:32:23 * hackagebot RBTree 0.0.1 - Pure haskell Red-Black-Tree implemetation  http://hackage.haskell.org/package/RBTree-0.0.1 (XingboWu)
06:32:34 <dpratt71> quicksilver: yep, cool with that
06:32:47 <quicksilver> dpratt71: however, that very special kind of type functions - parametric data types - is rather 'regimented'
06:32:58 <quicksilver> dpratt71: it's very uniform, everything is the same
06:33:10 <quicksilver> 'Maybe Bool' and 'Maybe Int' share part of their structure.
06:33:19 <quicksilver> a general type function is, well, any function on types.
06:33:36 <dpratt71> quicksilver: are you referring to the fact that * doesn't really impose anything?
06:33:43 <quicksilver> more than that.
06:33:54 <quicksilver> consider, "type family Foo a"
06:33:59 <quicksilver> now, Foo is a type function.
06:34:08 <dpratt71> ok
06:34:09 <quicksilver> but I can do anything. For example, I can say:
06:34:22 <quicksilver> type instance Foo Int = Char
06:34:34 <dpratt71> ok
06:34:34 <quicksilver> type instance Foo Bool = Either String String
06:34:47 <quicksilver> now there is nothing at all in common with 'Foo Int' and 'Foo Bool'
06:34:54 <dpratt71> right
06:35:01 <quicksilver> unlike 'Maybe Int' and 'Maybe Bool' which share top-level structure in a clear way
06:35:12 <dpratt71> ok
06:35:31 <quicksilver> so, that's step one. That's all type families themselves are.
06:35:59 <dpratt71> quicksilver: ok, I have a specific question that may unstick me (for the moment)...
06:36:15 <dpratt71> instance GMapKey Int where
06:36:17 <dpratt71>   data GMap Int v        = GMapInt (Data.IntMap.IntMap v)
06:36:34 <quicksilver> you've jumped ahead to step three :)
06:36:42 <dpratt71> what is 'GMapInt'? are we defining it here?
06:36:51 <quicksilver> it is a constructor
06:36:52 <quicksilver> of a new type
06:36:59 <quicksilver> and yes, you are defining it there.
06:37:08 <dpratt71> oooh
06:37:20 <quicksilver> so, the difference between a data family and a type family is that a 'type' family uses existing types
06:37:25 <quicksilver> like my Char/Either String String above
06:37:26 <dpratt71> a constructor! that should have been obvious
06:37:32 <quicksilver> a 'data' family is always defining *fresh* types
06:37:40 <quicksilver> (and fresh constructors along with it)
06:37:58 <dpratt71> ok
06:38:03 <quicksilver> (that was going to be step two)
06:38:11 <quicksilver> ...then step three is putting these things inside classes.
06:38:19 <quicksilver> so instead of just having these top-level type functions
06:38:24 <quicksilver> we decide to make the type function part of a class
06:38:40 <dpratt71> hmm...
06:38:57 <quicksilver> so a top level "type family Foo a" is a type function 'Foo' which works, in principle, on all types
06:39:01 <dpratt71> you speak of type families and data families as though they are distinct concepts, but...
06:39:06 <quicksilver> (although you do have to write the instances of it by hand)
06:39:25 <quicksilver> whereas a type family Foo a *inside* a class
06:39:34 <dpratt71> ...on the wiki, the first code we see on the page about type families is 'data family...'
06:39:37 <quicksilver> is a type function which must be defined only when you make something an instance of that class.
06:39:47 <quicksilver> dpratt71: OK, the notation is slightly confusing.
06:40:01 <dpratt71> quicksilver: well, to me at least :)
06:40:42 <quicksilver> I think "type family" is the most general term
06:40:48 <dpratt71> ok
06:40:49 <quicksilver> there are two sorts of "type family"
06:41:04 <quicksilver> one is a "type synonym family" where your function is mapping to other, previoiusly existing types
06:41:13 <quicksilver> (like my type instance Foo Bool = Char example)
06:41:25 <dpratt71> ok
06:41:30 <quicksilver> the other is a "data family" where your function is always mapping to fresh, newly defined types.
06:41:46 <quicksilver> so "data families" and 'type synonym families" are the two sorts of type families.
06:41:59 <quicksilver> both sorts can be put inside classes, and when they are inside classes, we call them "associated"
06:42:00 <dpratt71> ok
06:42:04 <quicksilver> ...because they're associated with a particular class.
06:42:09 <dpratt71> makes sense
06:42:27 <quicksilver> the precise haskell syntax "type family" in fact, defines a type synonym family.
06:42:33 <quicksilver> this is confusing, but consistent.
06:42:49 <quicksilver> (because the haskell syntax "type" introduces a type synonym in plain old haskell)
06:42:53 <quicksilver> type HappyInt = Int
06:43:14 <quicksilver> everything would be slightly easier to read if the keyword 'type' was replaced with 'synonym'
06:43:31 <dpratt71> right...I also think that is weird, but at least it's consistently weird, as you say
06:43:54 <dpratt71> +1 for 'synonym'
06:44:36 <dblhelix> quicksilver: and while you're at it, would you like to see "newtype" replaced with "isomorphism"?
06:45:11 <quicksilver> dblhelix: maybe, although it doesn't actually define all the parts of the isomorphism unless you put a record selector in.
06:45:24 * quicksilver doesn't mind newtype so much.
06:47:27 <gigabytes> hello
06:47:56 <gigabytes> is there any example of implementing a useful Monad that's not about state machines changing states?
06:48:09 <gigabytes> (other than the IO monad of course..)
06:48:33 <ben> list monad?
06:48:52 <koala_man> Maybe
06:50:11 <gigabytes> hm
06:50:12 <gigabytes> yes
06:50:30 <gigabytes> I meant some custom one
06:51:01 <ben> I guess a parser combinator is about state again
06:53:05 <dblhelix> quicksilver: implicitly, the other part of the isomorphism is defined as well: defining the newtype now allows you to pattern match using the newly introduced dataconstructor. Effectively, that gives you the inverse part of the iso.
06:53:48 <merijn> gigabytes: Maybe monad and List monad are good examples
06:54:00 <merijn> Oh, I'm late to the party again
06:54:21 <gigabytes> yes, they're examples but they're pre-defined
06:54:36 <merijn> How is that a problem?
06:54:48 <gigabytes> I would need some example of "oh.. I need to solve this problem and the naive solution is so ugly/slow! let's use a monad!"
06:55:12 <merijn> There are lots of tutorials showing how you could write them and that helps understand what you would use them for
06:55:23 <gigabytes> yes
06:55:27 <ezyang> gigabytes: State and Maybe are probably the best examples. 
06:55:36 <ezyang> as merijn said, there are lots of tuts on the subject. 
06:55:44 <merijn> I think LYAH contains an explanation of Maybe
06:55:46 <gigabytes> can you point me someone?
06:55:51 <merijn> @where lyah
06:55:52 <lambdabot> http://www.learnyouahaskell.com/
06:55:58 <quicksilver> dblhelix: yes, clearly.
06:56:12 <quicksilver> dblhelix: but in practice you often want it explicitly as a function too.
06:56:29 <quicksilver> gigabytes: there is no problem for which "a monad" is a solution.
06:56:37 <quicksilver> that's not how it works.
06:56:40 <quicksilver> it works like this:
06:57:01 <quicksilver> the solution to the problem is a gadget of widgets, which supports the following operations that enable me to solve the problem! Excellent!
06:57:10 <quicksilver> ah, jsut a moment, a gadget of widgets has a Monad instance, doesn't it?
06:57:28 <quicksilver> that makes implementing the solution even simpler because I can re-use these useful functions/libraries.
06:58:26 <gigabytes> hm ok
06:58:28 <gigabytes> merijn: thanks
06:58:31 <dblhelix> quicksilver: agreed. I rarely every define a newtype without explicitly naming the destructor
07:00:36 <harlekin> Having a custom Monad m, can I have an eval :: Command n a -> m () which can both evaluates Command Identity String and Command m ()? Maybe using associated data types?
07:00:55 <harlekin> s/evaluates/evaluate/
07:07:54 <gigabytes> thanks guys
07:07:55 <gigabytes> bye bye
07:08:34 <gwern> @quote sinbin
07:08:34 <lambdabot> No quotes match. I am sorry.
07:08:37 <gwern> @quote sin.bin
07:08:38 <lambdabot> No quotes match.
07:14:56 <ezyang> To think. A year ago today, I was still learning how to do search with the list monad :-) 
07:15:07 <Maxdamantus> @quote Maxdamantus
07:15:07 <lambdabot> No quotes match. Where did you learn to type?
07:17:31 <kuffaar> Ladies and gentlemen, I am proud to announce that I managed to implement a counter which is increased every time I open a page served by my Haskell web dev server. It took me only 5 days to figure out how to do this. About 3 days of that were for increasing the integer alone.
07:17:33 <alpounet> ezyang, and I was trying to figure out what Applicative, Alternative, etc etc were all about
07:17:55 <kuffaar> As you can see I'm a fast learner
07:17:58 <alpounet> heh
07:18:09 <harlekin> kuffaar, congratulations. :D
07:18:24 <ezyang> kuffaar: \o/ 
07:18:30 <ezyang> alpounet: :-) 
07:18:53 <alpounet> ezyang, now I'm trying to seriously grasp these Kan Extensions stuffs
07:18:58 <ezyang> It's actually pretty unbelievable how far I've come (and there's still so much more to learn) 
07:19:03 <ezyang> alpounet: Heh :-) 
07:19:05 <j-invariant> alpounet: what are you reading?
07:19:13 <j-invariant> alpounet: (I'm learning those too)
07:19:20 <alpounet> j-invariant, I started with Edward's blog posts
07:19:31 <alpounet> now I'm trying to attack them from a CT point of view
07:19:43 <alpounet> (with the MacLane)
07:19:47 <j-invariant> yeah I thought EdwardK posts were actually really helpfull
07:20:17 <ezyang> The wikipedia article claims kan extensions on posets are constrained optimization. Anywhere that elaborates on this? 
07:20:21 <kuffaar> Usually I just look at the first 2-3 pages of a tutorial for a new programming language and then I just look up stuff on Google when I need to mess with the API
07:21:05 <alpounet> ezyang, I may be able to answer your question in a few weeks
07:21:26 <alpounet> (yeah, I know, this is so helpful :P)
07:53:42 <raja_> hi
07:54:25 <Reemo> Hey guys, I'm (kind of) learning haskell in my cs studies and I just ran into some problems in understanding type definitions. (yes, this is homework, no I'm just looking for a hint): http://hpaste.org/43020/dictionary_type_example
07:55:03 <j-invariant> hi
07:55:04 <b0fh_ua> pl extractResults parser = DL.map fromJust . DL.filter isJust . either ( const [] ) id . AP.eitherResult . AP.parse parser
07:55:08 <b0fh_ua> @pl extractResults parser = DL.map fromJust . DL.filter isJust . either ( const [] ) id . AP.eitherResult . AP.parse parser
07:55:09 <lambdabot> extractResults = ((DL.map fromJust . DL.filter isJust . either (const []) id . AP.eitherResult) .) . AP.parse
07:55:14 <b0fh_ua> hm
07:55:26 <j-invariant> Reemo: ???
07:55:38 <Reemo> Hm?
07:55:48 <j-invariant> what do you want to know
07:56:11 <ezyang> Reemo: Oh, cute. :-) 
07:56:28 <ezyang> your definition of empty is wrong. 
07:56:34 <Reemo> yeaaaai
07:56:36 <Reemo> -.-
07:56:42 <j-invariant> ...
07:57:08 <ezyang> Well, only sort of. 
07:57:18 <alpounet> Reemo, empty is of type Dictionnary
07:57:18 <ezyang> Are you sure the type of dictionary is not String -> Maybe String? 
07:57:27 <alpounet> but your definition makes it just a String
07:57:39 <ezyang> alpounet: No, he binds the x. 
07:57:51 <alpounet> oh, yeah
07:57:54 <ezyang> empty is typed correctly. It might even be correct, for some definitions of correct. 
07:57:59 <ezyang> Hmm. 
07:58:00 <Reemo> Too much input, just give me a sec
07:58:03 * ezyang tries to figure out the right hint to give. 
07:58:05 <alpounet> sorry, misread
07:58:12 <ezyang> Implement lookup. That should be easy. 
07:58:23 <j-invariant> :/
07:58:32 <Reemo> lookup should be... lookup w from = to
07:58:33 <j-invariant> Reemo: what do you want to know
07:58:48 <ezyang> Reemo: Right. So what's to? 
07:59:01 <Reemo> The "translation"
07:59:02 <ezyang> Note that the full function signature of lookup is String -> (String -> String) -> String 
07:59:21 <ezyang> which is also a -> (a -> b) -> b (I've rather arbitrarily chosen a and b to be suggestive) 
07:59:28 <zenzike> dcoutts: just 1.5kcots? I would have thought it would be a lot more than that
07:59:48 <ezyang> Reemo: Are you familiar with viewing functions as lookup tables? 
07:59:48 <dcoutts_> zenzike: I think I lost part of the collection during a room move
07:59:56 <Reemo> Not really ezyang 
08:00:13 <alpounet> > (+1)
08:00:13 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:00:14 <lambdabot>    arising from a use of `...
08:00:15 <ezyang> Well, you're about to figure it out. 
08:00:20 <zenzike> dcoutts_: nevertheless, a fine achievement. Well done! :-)
08:00:20 <alpounet> oh, no more of these fancy instances
08:00:21 <ezyang> Reemo: Any guesses for lookup? 
08:00:35 <dcoutts_> zenzike: :-)
08:00:47 <ezyang> If I have a value of type String -> String, what's the logical thing to do to it? 
08:01:09 <Reemo> I'd stick with lookup word dict = dict word
08:01:14 <ezyang> correcT! 
08:01:20 <ezyang> ok, you have one out of four. 
08:01:30 <j-invariant> Reemo: what do you mean by The "Translation"?
08:01:55 <ezyang> I'm going to cheat and tell you that empty can be either empty = undefined, empty x = undefined, or empty x = "some default value". 
08:01:59 <Reemo> j-invariant, quotes where unintentional
08:02:04 <ezyang> Those all work. Pick one, and we'll continue with that. 
08:02:14 <Reemo> ezyang, last one is what we are supposed to use
08:02:15 <j-invariant> Reemo: okay I still don't know what i means
08:02:21 <Tomsik> I'll pick the second one.
08:02:29 <ezyang> oh, ok. 
08:02:33 <ezyang> That works fine. 
08:02:45 <Reemo> I ran into problems defining insert
08:02:45 <ezyang> Ok, now for insert, you want to somehow "modify" the function, no? 
08:02:57 <ezyang> Right. So you can't actually edit the function as it exists. 
08:03:04 <ezyang> So can you define a new function that does what you want? 
08:03:19 <Reemo> This is where i got stuck
08:03:40 <ezyang> Reemo: Ok. Well, I just gave a *huge* hint. 
08:03:48 <ezyang> You need to define a new function/lamba 
08:04:13 <ezyang> you're not 'Editing' anythign, like you might have done for a hash-map. 
08:04:24 <Reemo> Thanks for that comarison#
08:04:29 <Reemo> comparison
08:04:40 <Reemo> so I'd define something like
08:04:47 <Reemo> insert word translation dictionary = ....
08:04:48 <ezyang> If this also helps, this is a kind of inefficient implementation of a dictionary, with about the same complexity as an association list. 
08:04:55 <ezyang> yes... 
08:05:30 <ezyang> here, let me help you out a little more: 
08:05:38 <ezyang> insert word translation dictionary = \k -> ... ? 
08:06:17 <Reemo> what do you mean with \k ?
08:06:46 <Reemo> Would you mind continuing this in a query?
08:06:48 <ezyang> That means, it's a lambda function that takes k as an argument (the "word"/"key" to lookup), and then does something. 
08:07:29 <Reemo> But that isnt correct syntax, is it?
08:07:32 <ezyang> it's equivalent to 'insert word translation dictionary k =' but I find people find the implicit currying in this case confusing 
08:07:37 <ezyang> it is correct Haskell syntax. 
08:07:39 <Reemo> AHHHH!
08:07:46 <ezyang> > (\x -> x + 2) 4 
08:07:47 <lambdabot>   6
08:07:59 <Reemo> okay what about...
08:08:22 <Reemo> insert word translation dictionary key = \k -> if (k == word) translation else "not found"
08:08:38 <ezyang> You've basically got it, but that's not quite right. 
08:08:54 <ezyang> What happens if I do insert "a" "aa" (insert "b" "bb" empty)? 
08:09:13 <Reemo> Ahh
08:09:19 <jkr> I have a set of types that take parameters, say, data Shape = Triangle ... | Circle ..., but I'd also like them to be something like enumerators in certain instances, like if I have a random mkShape :: StdGen -> Shape function that needs to know if it should make a cirle or a triangle.
08:09:27 <ezyang> the other clue is that you're not using all of the arguments being passed in. 
08:09:35 <jkr> Should I just have a second ShapeEnum type that mirrors all the shapes?
08:09:53 <jkr> data ShapeEnum = TriangleEnum | CircleEnum | .. ?
08:09:53 <ezyang> jkr: That would work. 
08:09:54 <alpounet> jkr, you may be interested in the Enum typeclass
08:09:59 <jkr> or is there another way
08:10:00 <j-invariant> jkr: yes
08:10:07 <Reemo> insert word translation dictionary key = \k -> if ( k == word) translation else dictionary word
08:10:09 <ezyang> alpounet: He can't use it, because his original data type has fields. 
08:10:13 <Reemo> Something similar to that
08:10:14 <alpounet> yeah
08:10:16 <ezyang> correct! 
08:10:19 <jkr> alpounet: right, but it doesn't work with things that take type paramerters.
08:10:23 <ezyang> Ok, can you figure out delete now?. 
08:10:23 <Reemo> wtf :D
08:10:31 <Reemo> I'll try, give me a few minutes
08:10:34 <ezyang> Reemo: Do you know what an association list is? 
08:10:34 <Reemo> thanks for your help :)
08:10:38 <ezyang> :-) 
08:10:38 <alpounet> indeed jkr 
08:10:50 <jkr> ezyang, j-invariant, alpounet: Cool -- thanks all.
08:10:54 <Reemo> ezyang, a Map<K,V> ?
08:10:57 <ezyang> I feel like there's some clever way to do this with reify or something 
08:11:09 <ezyang> Reemo: It implements that interface, but in a particular way. 
08:11:15 <ezyang> it's just a list of key value pairs. 
08:11:25 <ezyang> to insert, you cons (k,v) onto the list. 
08:11:39 <ezyang> to lookup, you iterate down the list looking for a matching key. 
08:11:48 <alpounet> > lookup "haskell" [("haskell", 10), ("php", 0)]
08:11:49 <lambdabot>   Just 10
08:11:52 <ezyang> Reemo: Think about how this corresponds to our String -> String map. 
08:12:03 <ezyang> although, maybe do that after you figure out delete. 
08:12:16 <Reemo> one at a time
08:12:23 <Reemo> :)
08:13:24 <taotree> What's the difference between this declaration (which is an infinite type, isn't it?)
08:13:25 <taotree> "newtype Circuit a b = Circuit { unCircuit :: a -> (Circuit a b, b) }"
08:13:25 <taotree> and this error:
08:13:25 <taotree> "Occurs check: cannot construct the infinite type: t = (a -> t, a)"
08:13:30 <alpounet> jkr, then you just write a function of type Shape -> ShapeEnum
08:13:32 <alpounet> and it should be fine
08:13:47 <Reemo> delete word dictionary key = if (key == word) then "not found" else dictionary word
08:13:57 <taotree> the Circuit type is allowed, compiles fine
08:13:57 <ezyang> taotree: The newtype "guards" the infinite recursion 
08:14:00 <dmwit> taotree: One of them has an explicit type coercion and the other doesn't.
08:14:02 <ezyang> Reemo: \o/ 
08:14:23 <taotree> So if I create a newtype for the thing that is inferring an infinite type, it should start working?
08:14:30 <dmwit> Yes.
08:14:35 <taotree> thanks!
08:14:36 <Reemo> what does '\o/' mean?
08:14:41 <ezyang> correct. 
08:14:45 <Reemo> oh, great :)
08:15:02 <Reemo> let me give it a try
08:17:17 <Reemo> ezyang, I have some troubles imagening such data structures
08:17:29 <Reemo> is there a way to display such a "chain" with ghci?
08:17:45 <ezyang> not really. 
08:18:06 <Reemo> hmm too bad
08:18:20 <Reemo> anyway, thank you so much :)
08:19:55 <Reemo> ezyang, would you mind taking a look at some functions i wrote and tell me if they comply to "good practice" ?
08:20:06 <ezyang> they're fine. 
08:20:12 <ezyang> Haskellers would probably use one letter variable names. 
08:20:20 <Reemo> no i mean some others
08:20:20 <ezyang> but that's all I'd change. 
08:20:31 <ezyang> well, don't ask me, ask the chan :-) 
08:21:23 <j-invariant> I don't use single letter names
08:22:58 <Tomsik> I use long and descriptive names, but getting fed up with it, my one liners not fitting in one line on 16:9 screen because of this
08:23:33 <ezyang> The rule of thumb I like is the longer scope your variable is alive, the longer it should be. 
08:23:44 <ezyang> And the converse is also true. 
08:24:04 <Tomsik> pointfree :p
08:24:12 <djahandarie> ezyang, how long are your top-level definitions? :)
08:24:30 <ezyang> erm, no, that's not called converse 
08:24:53 <quicksilver> i
08:25:04 <Bynbo7> djahandarie: how long are your top level comments? :P
08:25:07 <ezyang> what is the transform from A -> B to ~A -> ~B called? 
08:25:16 <Reemo> Here http://hpaste.org/43022/some_functions
08:25:30 <ezyang> oh, it is converse. 
08:25:37 <ezyang> because the contrapositive of ~A -> ~B is B -> A. lol 
08:25:40 <yrlnry> ezyang:  no, inverse.
08:25:47 <yrlnry> ezyang:  the converse of A->B is B->A.
08:26:10 <alej> i think it's contrapositive
08:26:19 <yrlnry> The contrapositive of A->B is ~B -> ~A.
08:26:29 <alej> o rite
08:26:49 <ezyang> djahandarie: middle size. They get longer if you import them qualified, which nicely fits the rule. 
08:27:02 <alej> dyslexia ....
08:27:20 <ezyang> yeah. But if the inverse of something is true, its converse is also true, because contraposative is a valid (in classical logic, anyway) 
08:27:20 <copumpkin> @djinn (a -> b) -> (Not b -> Not a)
08:27:21 <lambdabot> f a b c = b (a c)
08:27:45 <ezyang> oh, contrapositive in the other direction. 
08:27:48 <ezyang> :^) 
08:27:59 <copumpkin> yeah, but that isn't derivable :P
08:28:31 <ezyang> I can do converse to inverse though, iiuc 
08:28:32 <Tomsik> Not a? Not b?
08:28:35 <copumpkin> it's amusing that (a -> b) -> (Not b -> Not a) is basically (.)
08:28:47 <ezyang> Not a = a -> Bot 
08:28:59 <ezyang> where data Bot is the empty type 
08:29:36 <yrlnry> What does djinn understand "Not" to mean?
08:29:43 <djahandarie> (See above)
08:29:51 <yrlnry> Oh, okay.
08:30:12 <yrlnry> @djinn a -> Not (Not a)
08:30:12 <lambdabot> f a b = b a
08:30:14 <Twey> Why isn't it called Void like usual?
08:30:17 <djahandarie> It is
08:30:47 <yrlnry> @djinn Not (a, Not a)
08:30:47 <lambdabot> f (a, b) = b a
08:31:01 * djahandarie is not sure why ezyang used Bot
08:31:18 <ezyang> Bot = Bottom 
08:31:23 <djahandarie> Ah
08:31:28 <Tomsik> I've seen it as bottom always
08:31:30 <ezyang> I've been, uh, reading too many logic texts recently  
08:31:32 <Tomsik> never "void"
08:31:33 <yrlnry> _|_
08:31:34 <edwardk> heh
08:31:38 <Tomsik> except in C
08:31:40 <Twey> It's Void in Haskell
08:31:44 <Tomsik> but that doesn't count
08:31:48 <Twey> >.>
08:31:50 <Tomsik> Weird
08:32:05 <yrlnry> ‚üÇ
08:32:16 <copumpkin> @djinn Not (Either a b) -> (Not a, Not b)
08:32:16 <exDM69> Isn't () (aka Unit) the same as "void"
08:32:16 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
08:32:22 <Twey> exDM69: No
08:32:28 <Twey> () is a type with one value
08:32:33 <Twey> Void is a type with no values
08:32:33 <copumpkin> () is a type with two values
08:32:34 <exDM69> and bottom or _|_ is non-terminating computation
08:32:37 <copumpkin> Void is a type with one value
08:32:41 <djahandarie> lol
08:32:51 <Twey> There is no valid value that is a member of Void (except bottom)
08:33:03 <exDM69> where Void used in Haskell?
08:33:20 <Twey> Magical type hackery
08:33:21 <exDM69> @hoogle Void
08:33:22 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
08:33:52 <quicksilver> exDM69: never.
08:34:00 <quicksilver> exDM69: that is, it's not in GHC or the commonly used libs.
08:34:12 <quicksilver> but it's a well-known folklore concept
08:34:20 <quicksilver> and it's probably in category-extras or something on hackage
08:34:49 <exDM69> quicksilver: okay, thanbks
08:36:45 <Twey> Hm, oh yeah ‚Äî it's in ‚Äòcategories‚Äô
08:36:50 <Twey> I always thought it was in base
08:39:30 <Reemo> ezyang, http://hpaste.org/43022/some_functions I'm not sure if I really need those helper functions, especially for findIndices
08:39:33 <ezyang> Void-like types are frequently used in phantom type things 
08:39:33 <jonkri> why does "data VariableName = String" and "data VariableValue = String | Integer" causes a "Multiple declarations of `Main.String'" error?
08:39:48 <alpounet> congrats dcoutts for you thesis heh
08:40:10 <jonkri> why am i not allowed to use String two times?
08:41:40 <quicksilver> jonkri: because it's a constructor name
08:41:47 <quicksilver> constructor names have to be unique in a scope
08:41:51 <quicksilver> probably that's not what you meant anyway
08:42:02 <quicksilver> you probably meeant data VariableName = VN String
08:42:12 <quicksilver> data VariableValue = VVS String | VVI Integer
08:42:44 <edwardk> djahandarie: sorry man
08:43:08 <dcoutts_> alpounet: thanks :-)
08:43:40 <kuffaar> I believe I've discovered a bug in ghc-pkg unregister. When you unregister something with --force it says "unregistering this would break blah blah"
08:43:56 <kuffaar> But it still unregisters it anyways
08:44:02 <kuffaar> While making it sound like it errored out
08:44:40 <dcoutts_> kuffaar: that's what --force does, it ignores the fact that you're breaking packages
08:44:53 <kuffaar> But it says _would_
08:45:02 <kuffaar> This clearly shows that it didn't remove anything
08:45:05 <kuffaar> In its output
08:45:35 <jonkri> thanks quaestor 
08:45:39 <jonkri> quicksilver
08:45:52 <kuffaar> Oh it already switches it to (ignoring) after that
08:45:57 <kuffaar> How irritating :|
08:46:22 <dcoutts_> kuffaar: right, the phrasing is not really changed between normal and --force mode.
08:46:42 <kuffaar> Yeah I think that could be made easier on the eyes haha
08:46:46 <dcoutts_> kuffaar: clearly it could be phrased better. I'm sure if you sent a patch to improve it they'd apply it.
08:52:28 <EvanCarroll> Cale: do you do the language shootout benchmarks?
08:56:14 <kuffaar> Registering snap-server-0.4.0...
08:56:14 <kuffaar> Segmentation fault/access violation in generated code
08:56:24 <kuffaar> Yay, cabal randomly crashing again :/
08:56:28 <kuffaar> (on Windows)
08:57:03 <kuffaar> Might be MSYS related, who knows
08:57:47 <tibbe> anyone here that could spare a account on their Windows server so I can run the 'network' continuous build there?
08:57:56 <ezyang> tibbe: Yeah. 
08:58:20 <ezyang> I have a Windows 7 build server. 
08:58:21 <tibbe> ezyang: I have a hudson continuous build here: http://johantibell.com:8080/job/network/
08:58:38 <tibbe> ezyang: I'd really like to run that on Windows as I end up breaking that platform once in a while
08:58:39 <ezyang> I used to do GHC builds but it was really annoying because they kep breaking. 
08:59:20 <tibbe> ezyang: the build might break a bit initially as the network internals are under heavy development at the moment but it should calm down after the next major release
09:04:29 <zong_sharo> hi, i'm writing a small translator from infix expressions to postfix here. target language provides direct stack manipulation primitives, which i want to replace with list abstraction
09:05:10 <zong_sharo> which is the smallest set of list operations will do the job?
09:05:50 <j-invariant> zong_sharo: your algorithm will tell you
09:06:09 <j-invariant> zong_sharo: you can write it in direct style then abstract it one layer away, and the natural set of operations will appear
09:06:21 <zong_sharo> j-invariant: huh?
09:06:41 <zong_sharo> please elaborate
09:06:46 <j-invariant> zong_sharo: on which aspect?
09:07:39 <zong_sharo> let me rephrase 
09:07:57 <monochrom> stack lets you push, pop, look at top. push is (:). pop and look at top are head, tail, or pattern matching.
09:08:30 <zong_sharo> monochrom: well, my target lang supports DUP, POP, EXC
09:08:33 <EvanR-work> what is the state-of-the-art in type safe relational database tables
09:08:54 <zong_sharo> it's some weird rpn stuff
09:08:56 <EvanR-work> can operations like join or select be well typed
09:09:06 <monochrom> you can write dup (x:xs) = x:x:xs. I don't know what is exc.
09:09:20 <j-invariant> EvanR-work: you can make a type system for SELECT sure but can it be embedded in haskell? that's a different question
09:09:31 <zong_sharo> EvanR-work: do you aware of haskelldb existence
09:09:35 <zong_sharo> ?
09:09:52 <EvanR-work> j-invariant: besides that, do you know about non haskell systems?
09:09:57 <EvanR-work> zong_sharo: vaguely
09:09:57 <zong_sharo> monochrom: exchanges 2 on the top
09:10:10 <monochrom> exc (x:y:xs) = y:x:xs
09:10:28 <EvanR-work> j-invariant: i was taking select to be an operation like join, not sql select
09:11:43 <j-invariant> EvanR-work: SQL?
09:11:52 <EvanR-work> doesnt have to be sql
09:12:01 <EvanR-work> just relational
09:13:03 <monochrom> there is no such thing as "the natural set of operations".
09:13:35 <EvanR-work> are you referring to something in this discussion, or branching off
09:13:52 <zong_sharo> monochrom: i need a minimal set of primitive operations over lists which will have same expressive power as this stack operations, i believe this is what i need
09:13:56 <EvanR-work> oh
09:14:17 <EvanR-work> lists are great stacks
09:14:48 <j-invariant> zong_sharo: I have given a method to find the set
09:15:04 <monochrom> j-invariant's method is for something else.
09:25:19 <taotree> Help on this occurs check error?  http://hpaste.org/43023/type_error
09:26:33 <j-invariant> taotree: (x:xs)
09:26:33 <j-invariant> ?
09:26:44 <monochrom> [x:xs] should be (x:xs)
09:27:22 <taotree> that's it. Thanks!
09:29:44 <monochrom> the location "4:0", emphasis 0, suggests that the error is really assigned to the type sig in line 3, not to "runCir _ [] = []"
09:35:51 <taotree> I'll watch for the column 0 thing, thanks. Thanks for your help and apologize for asking something that was just a syntax errors. Still learning...
09:55:41 <joe6> i am trying to understand the difference between: 
09:55:43 <joe6> > map (*3) . map (+2) ([1..9]::[Int])
09:55:45 <lambdabot>   Couldn't match expected type `[a]'
09:55:45 <lambdabot>         against inferred type `GHC.Types...
09:55:47 <joe6> > map (*3) $ map (+2) ([1..9]::[Int])
09:55:49 <lambdabot>   [9,12,15,18,21,24,27,30,33]
09:55:59 <joe6> how does changing the . to a $ help?
09:56:12 <j-invariant> joe6: . and $ are completely different things, what would you expect?
09:56:24 <joe6> >  (map (*3) . map (+2)) ([1..9]::[Int])
09:56:26 <lambdabot>   [9,12,15,18,21,24,27,30,33]
09:56:58 <j-invariant> not having brackets vs having brackets...
09:57:03 <joe6> j-invariant: why does not  map (*3) . map (+2)  <> (map (*3) . map (+2))
09:57:09 <j-invariant> joe6: they are equal
09:57:22 <j-invariant> joe6: but f . g x is f . (g x)
09:57:36 <WendyMackaye> What should i read if i want to figure out how to use haskell for game development?
09:58:09 <WendyMackaye> What's the parallel to an event loop in haskell?
09:58:18 <joe6> gotcha and (g x) is more of a stateful function?
09:58:20 <kuffaar> WendyMackaye how much Haskell do you know so far?
10:00:21 <franka> (f . g) x = f (g x) = f $ fg x
10:00:24 <WendyMackaye> Hmmm.. Not a lot. But i know a bit about the basic syntax, list functions and got a bit of the feeling of IO stuff while reading Real World Haskell's examples
10:00:28 <franka> +space
10:00:31 <hatds> The route you want to take is to learn the language in general.  How to make a game should be clear before you start.
10:00:37 <kuffaar> WendyMackaye first spend 8-12 months at the hello world stage :(
10:00:45 <franka> er, fg --> g
10:00:53 <WendyMackaye> A bit about types and type definitions
10:01:04 <WendyMackaye> Oh wow
10:01:28 <alpounet> <WendyMackaye> What's the parallel to an event loop in haskell?
10:01:34 <alpounet> it's "forever", somehow
10:01:42 <alpounet> @src forever
10:01:42 <lambdabot> Source not found. My pet ferret can type better than you!
10:01:45 <alpounet> hm
10:01:59 <WendyMackaye> Lol! Funny bot
10:02:07 <alpounet> forefer f = do { f ; forever f }
10:02:09 <alpounet> forever*
10:02:26 <WendyMackaye> Oh wow. That's kinda scary.
10:02:33 <alpounet> but well
10:02:39 <alpounet> this may not be exactly suited in your case
10:02:43 <WendyMackaye> I'll look that up in my manuals
10:02:48 <joe6> franka: what about f . g x?
10:02:49 <WendyMackaye> Hmmm
10:02:54 <alpounet> since you'd stop it depending on some conditions WendyMackaye 
10:02:59 <alpounet> like "ho, the user pressed Escape"
10:03:17 <WendyMackaye> Can i do graphical stuff with the basic installation in ubuntu?
10:03:26 <alpounet> i don't think so
10:03:35 <alpounet> but hackage is full of graphics libraries
10:04:00 <alpounet> see the GUI and Graphics sections on http://hackage.haskell.org/packages/archive/pkg-list.html
10:04:08 <WendyMackaye> Hmmm. Is Graphics.X11 capable of graphics?
10:04:15 <alpounet> (there are also game related packages, and games in general)
10:05:02 <alpounet> WendyMackaye, I guess it is but I sincerely doubt it's the best way for you to get into Haskell game development
10:05:04 <franka> joe6: I am not sure about the precedence.
10:05:26 <franka> ?eval (+1) . (+1) 2
10:05:34 <WendyMackaye> It's a bit confusing reading the Haddock documentation
10:05:44 <franka> hrm
10:05:51 <alpounet> WendyMackaye, there are bindings to the SDL library, to Cairo, and many other C libraries for drawing stuffs on the screen
10:06:00 <franka> ?botsnack
10:06:01 <lambdabot> :)
10:06:05 <alpounet> also, there is more documentation about them
10:06:10 <alpounet> so you may want to go in that direction
10:06:19 <franka> > (+1) . (+1) 2
10:06:20 <lambdabot>   No instance for (GHC.Num.Num (f a))
10:06:20 <lambdabot>    arising from a use of `e_1112' at <i...
10:06:21 <WendyMackaye> I'll investigate when i get a chance
10:06:31 <alpounet> WendyMackaye, see http://abstractabsurd.blogspot.com/2008/04/intro-to-sdl-with-haskell.html for instance
10:06:42 <hatds> All graphics are going to be supplied by a library written in another language.  The haskell part will merely be bindings to that library.
10:06:49 <alpounet> > (+1) . (+1) $ 2 -- franka 
10:06:51 <lambdabot>   4
10:06:55 <franka> > ((+1) . (+1)) 2
10:06:57 <lambdabot>   4
10:07:01 <alpounet> yup
10:07:21 <WendyMackaye> What's TEH best lib for 2d stuff?
10:07:22 <franka> So, f . g x = f . (g x) which is normally a type error.
10:07:34 <alpounet> indeed franka 
10:07:37 <WendyMackaye> Oy, medfly is on off ing
10:07:57 <WendyMackaye> I'm copying that link by hand
10:07:59 <franka> I am too lazy to check prec lists.
10:08:19 <alpounet> function application has a higher precedence than .
10:08:42 <franka> Ah yeah, of course.
10:08:59 <c_wraith> function application is higher than all binary operators.
10:09:04 <franka> Yes.
10:09:12 <c_wraith> As long as you remember that, you know most of what you need to
10:09:14 <joe6> franka: I am trying to understand why that is a type error as the type error is pretty common in my haskell usage.
10:09:45 <joe6> and am trying to understand the reasoning behind it instead of just blindly putting a $ as I am doing.
10:09:57 <franka> joe6: It is normally a type error, because (g x) would need to be a function type.
10:10:21 <franka> Since (f .) takes a function.
10:10:45 <kuffaar> Is Data.Text a lower overhead container?
10:10:49 <kuffaar> low*
10:10:53 <franka> That is, g would need to have a type like a -> (b -> c), where x :: a.
10:10:54 <kuffaar> Like ByteString?
10:11:00 <joe6> gotcha, where as (g x) would be the type of the result of g and not (b -> c)
10:11:06 <WendyMackaye> A two human players pong in javascript.. That's the only almost finished piece of software i've ever written.
10:11:22 <franka> joe6: Yep.
10:12:03 <joe6> is it a good practice to have f . g $ x or f $ g x ?
10:12:19 <joe6> i prefer the second one as it has one operator less.
10:12:34 <joe6> but am not sure if it is correct from a puritan perspective.
10:12:48 <tromp_> both have their virtues
10:12:56 <franka> It depends on how you are thinking about the problem.
10:13:00 <franka> No way is right.
10:13:09 <joe6> what is the virtue of the first option?
10:13:25 <alpounet> i like seeing function composition, i find it easier to reason on what that line does
10:13:33 <franka> In that case you are thinking about composing functions into a pipeline.
10:13:41 <joe6> gotcha, makes sense..
10:13:46 <aristid> joe6: people love simple function chains of the f . g . h kind
10:13:50 <tromp_> it's also easier to add a function to the composition
10:14:14 <alpounet> anyway both approachs will compile to the same machine code
10:14:19 <alpounet> so it's really a matter of style
10:14:25 <tromp_> although, taken to an extreme it would lead you to write f $ x, which is not that great:(
10:14:27 <alpounet> choose whichever you prefer
10:15:40 <aristid> i think there is more consensus on things like f $ g $ h, but it's hardly unequivocal
10:16:29 <alpounet> of course, function-composition-only isn't good
10:16:45 <alpounet> @pl \f g x y -> [f x, g y]
10:16:46 <lambdabot> (. flip (flip . ((:) .)) []) . flip . (((.) . (:)) .)
10:16:59 <WendyMackaye> forever's type has monad in it... That's scary. I hear monads are just like something similar, right..?
10:17:31 <hatds> what?
10:17:39 <alpounet> WendyMackaye, they're not that scary. You just need to practice, a lot, to be at ease using them.
10:17:53 <alpounet> and read materials like Learn You A Haskell
10:18:16 <c_wraith> alpounet: maybe better to not reply after the person you're replying to goes offline :)
10:18:38 <alpounet> c_wraith, i bet he just did that to annoy me
10:18:39 <alpounet> :P
10:19:02 <alpounet> <alpounet> WendyMackaye, they're not that scary. You just need to practice, a lot, to be at ease using them. <alpounet> and read materials like Learn You A Haskell
10:19:32 <franka> Scary monads! *shiver*
10:20:09 <hatds> do you understand IO, WendyMackaye?
10:20:52 <WendyMackaye> I've read a few examples in Real World Haskell
10:21:32 <joe6> WendyMackaye: best explanation of monads: http:://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
10:21:34 <tolkad> in ghc's implementation of STM, can multiple concurrent transactions read from the same TVar? What if one thread decides to modify the TVar while other threads are currently in transactions that have read from that TVar, which transactions are retried?
10:21:54 <hatds> can you write IO programs?  Like a program that asks the user to guess a secret number until they guess correctly?
10:22:10 <tolkad> hatds: yes
10:22:25 <hatds> that was addressed to WendyMackaye  :)
10:22:41 <tolkad> oh I thought you meant "is it possible", sorry
10:22:44 <c_wraith> tolkad: Whichever commits first wins
10:22:47 <sproingie> sure you can.  have the whole program a single 'do' and it looks almost identical to how you'd code it in an imperative language
10:22:47 <Tomsik> Hey, I can too. Don't discriminate me. :(
10:22:52 <c_wraith> tolkad: the rest have to retry
10:22:56 <sproingie> except for recursing instead of looping i guess
10:23:04 <tolkad> c_wraith: multiple reads at the same time are ok though?
10:23:13 <c_wraith> tolkad: yes.
10:23:54 <hatds> I think you misunderstood the context, sproingie 
10:24:22 <WendyMackaye> I guess i could. Lets see...
10:24:25 <aristid> sproingie: you can use stuff like monad-loops to get you some loopin'
10:24:32 <aristid> @hackage monad-loops
10:24:32 <lambdabot> http://hackage.haskell.org/package/monad-loops
10:24:36 <duairc> In Template Haskell, can you, given a type constructor, get a list of the data constructors for that type?
10:24:45 * WendyMackaye tries coding
10:24:57 <c_wraith> tolkad: with more context...  If threads A, B, and C read TVar t, and thread D writes to it, and all are happening concurrently, whichever of A, B, and C commit before D does neither retry, nor cause D to retry.  Any that don't commit before D are forced to retry
10:25:06 <Saizan> duairc: reify should work for that
10:25:06 <iago> hi all, I'm having the following problem
10:25:14 <iago> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
10:25:15 <iago>    __hscore_gettimeofday
10:25:15 <iago> whilst processing object file
10:25:15 <iago>    /usr/local/lib/old-time-1.0.0.6/ghc-6.12.1/HSold-time-1.0.0.6.o
10:25:16 <iago> ...
10:25:31 <iago> I have tried with -hide-package old-time-1.0.0.3 without success
10:25:48 <iago> (I have two versions installed, but unregister any of them break deps)
10:25:51 <sproingie> aristid: huh that looks pretty nifty.  i could make use of atomLoop
10:25:53 <tolkad> thanks. Also, why isn't there a function like ¬´ modifyTVarIO :: TVar a -> (a -> IO a) -> STM () ¬ª?
10:25:58 <iago> any ideas please?
10:26:32 <aristid> sproingie: yeah, stuff like that really shows the virtue of having a Monad abstraction IMO
10:27:02 <tolkad> it seems like you could ensure atomicity of that
10:27:54 <tolkad> oh! because you might use another transaction in there
10:28:01 <hatds> tolkad: wouldn't there be a problem with the IO?
10:28:06 <MrElendig> http-enumerator is the prefered way to do https work? (client side)
10:28:29 <tolkad> hatds: yeah I forgot about the transaction within another issue
10:28:45 <tab> MrElendig: yes
10:28:55 <MrElendig> thanks
10:29:35 <franka> iago: I am reliably informed that GHC 7 is out, so maybe it would help to try that.
10:29:56 <franka> Otherwise, I have no idea because I am an academic pointy-heda.
10:30:20 <tolkad> I installed ghc 7 and it broke everything and now my ghc doesn't work
10:30:28 <franka> I like to dance in my ivory tower and sing.
10:30:41 <hatds> can't ghc handle different versions of the same module (and assumes they define distinct entities)?
10:30:42 <iago> well
10:30:48 <iago> I don't know
10:31:22 <tolkad> hatds: if they are in different packages and you turn on package qualified imports then yes
10:31:26 <franka> tolkad: *horrors*
10:31:35 <tolkad> hatds: but be careful about Typeable
10:31:52 <hatds> iago: the best resolution (if available) is to update things so you don't depend on two versions of that module
10:34:05 <iago> hatds, I will give it a try
10:35:27 <tolkad> huh, my ghc works again
10:35:35 <tolkad> only I don't remember doing anything O_O
10:35:45 <tolkad> oh well at least it works
10:36:11 <tolkad> it still warns me about ld: warning: -read_only_relocs cannot be used with x86_64
10:37:00 <tolkad> and wont let me use any copmpilation backends because it is automatically turning on -fPIC
10:39:08 <tolkad> oh http://www.haskell.org/pipermail/cvs-ghc/2009-December/051668.html
10:39:52 <tolkad> I guess I'm linking against a dynamic library somehow. I wonder if there's any way to change that
10:41:02 * digitteknohippi1 wonders if he's actually subconsciously learning haskell by just leaving the chat open on screen, even though he's not really looking at it.
10:41:14 <byorgey> dcoutts: congrats!
10:43:48 <WendyMackaye> Okay. I did copy a bit the random number generating functions from the YAHT guide..
10:44:03 <WendyMackaye> But it runs
10:45:01 <WendyMackaye> hatds
10:45:20 <hatds> okay
10:45:33 <hatds> do you think you're comfortable writing IO programs like that?
10:45:45 <WendyMackaye> I guess i am
10:45:50 <hatds> :)
10:45:54 <WendyMackaye> It seems reasonable
10:46:10 <hatds> are you comfortable with how 'do notation' for IO translates into the monad functions?
10:47:58 <WendyMackaye> That's a tough question because i don't know what's a nomad is...
10:48:14 <companion_cube> it's a person living in the desert
10:48:18 <WendyMackaye> I'll read that pdf when i have www
10:48:28 <tolkad> WendyMackaye: a monad is just a monoid in the category of endofunctors
10:48:38 <companion_cube> \o/
10:48:41 <WendyMackaye> Ya, iTAP writes nomad when i try
10:48:53 <joe6> the baastad.pdf really helped me in understanding monads. 
10:49:02 <WendyMackaye> Lol! Medfly told me that joke
10:49:55 <tolkad> companion_cube: I thought a nomad was a person who by culture does not live in a fixed location
10:50:13 <companion_cube> yeah, i made a shortcut :/
10:50:33 <WendyMackaye> It's anyone who lives in constant movinging
10:50:56 * edwardk waves hello.
10:51:08 <WendyMackaye> Okay, i'll go www now.
10:51:13 <byorgey> hi edwardk 
10:51:56 <tolkad> WendyMackaye: in haskell, Monad is a type class with a few rules that all instances are supposed to follow and i associated with the do syntatic sugar
10:52:05 <tolkad> is associated*
10:52:19 <sleepynate> so.. it seems that only haskell libs seem to care that my $LANGUAGE is de.en_US.en .... any reason why it's less tolerant than other languages?
10:53:34 <aristid> sleepynate: de.en_US.en makes no sense
10:53:41 <mauke> why is your LANGUAGE set to an invalid value?
10:54:03 <sleepynate> because ubuntu is dumb :/
10:54:11 <mauke> hmm, LANGUAGE or LANG?
10:54:15 <aristid> sleepynate: what's your value of LANG?
10:54:15 <sleepynate> arch just accepts my locale
10:54:34 <sleepynate> oh... $LANG is en_US.utf8
10:54:45 <sleepynate> i'm talking $LANGUAGE
10:55:00 <mauke> I don't have any problems with LANGUAGE
10:55:02 <aristid> i wonder what's the difference between those
10:55:10 <mauke> setting LANG to de.en_US.en makes perl complain, though
10:55:10 <aristid> i don't have LANGUAGE set at all
10:55:22 <sleepynate> aristid: yea, it doesn't exist on my arch machine
10:55:32 <aristid> LANG=de_DE.utf8 is the only true value!
10:55:48 <sleepynate> aristid: well, i live and work in america :)
10:56:15 <aristid> sleepynate: next you'll tell me you use QWERTY
10:56:20 <mauke> en_US.UTF-8 all the way
10:56:33 <mauke> except for LC_COLLATE; that's POSIX
10:56:41 <aristid> mauke: i love that linux has standardised on UTF-8 now
10:57:32 <mauke> I wonder what they use on usenet now
10:58:54 <iago> tolkad, I do a $HOME fresh installation of GHC 7, everything is fine
10:59:13 <xarch> what are evaluation contexts?
10:59:44 <tolkad> iago: I'm not sure why mine didn't work.
10:59:57 <franka> xarch: program - term
11:00:02 <tolkad> iago: anyway, I'm on Mac OS 10.6 so mine is community supported anyway
11:00:05 <tolkad> anyway
11:00:17 <tolkad> as opposed to some particular way
11:00:19 <xarch> hm?
11:00:45 <sleepynate> aristid: but yea.. I was getting an invalid multi-byte wide something error on √∂
11:00:49 <franka> Take the whole program, and replace the term in question with a hole.
11:01:00 <franka> That is the evaluation context of the term.
11:01:10 <xarch> hm, ok
11:01:21 <tolkad> ‚àÄa ‚àà Way: a
11:01:27 <xarch> do you have a link to a more detailed explanation?
11:02:08 <hatds> hmm... can't we just say it is the value of all the free variables in the expression?
11:02:19 <hatds> I guess I'm not clear how the term is used
11:02:22 <franka> Well, here is one: http://redex.plt-scheme.org/why-redex.html
11:02:34 <xarch> thanks!
11:06:11 <tolkad> hatds: no because Float semantics break purity
11:07:29 <hatds> I'm willing to sweep that under the "unsafePerformIO" rug
11:07:47 <WendyMackaye> You know something
11:08:03 <tolkad> I know many things
11:08:07 <franka> Lots of somethings.
11:08:29 <franka> You would be surprised.
11:08:36 <WendyMackaye> That forever loop really reminds me of basic's goto
11:08:57 <tolkad> WendyMackaye: forever is much more like for(;;)
11:09:06 <franka> ?source forever
11:09:07 <tolkad> WendyMackaye: or while(true)
11:09:07 <lambdabot> forever not available
11:09:16 <tolkad> I think it's in Control.Monad
11:09:31 <franka> ?source Control.Monad.forever
11:09:31 <lambdabot> Control.Monad.forever not available
11:09:33 <tolkad> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad.html#v%3Aforever
11:09:51 <franka> I named the Control library. :)
11:09:52 <byorgey> @index forever
11:09:52 <lambdabot> bzzt
11:10:11 <WendyMackaye> Hmmmm
11:10:13 <mauke> @src forever
11:10:13 <lambdabot> Source not found. You type like i drive.
11:10:18 <franka> One of my 2 contributions to Haskell.
11:10:49 <WendyMackaye> No, i mean, whenever it gets to a point it wants to start over, it calls itself
11:10:55 <tolkad> that must have been a long time ago when they switched to the period-delimited module names
11:11:08 <WendyMackaye> Inside the if else tree
11:11:30 <WendyMackaye> If then else, that is
11:11:31 <franka> Yeah, it was several years ago.
11:12:01 <WendyMackaye> It's cool. Makes the transition from imperative a bit easier
11:12:08 <franka> The other one I named is Console, I think.
11:12:28 <franka> Dunno if that still exists.
11:12:39 <elliott> Is there a good library for doing topological sorts?
11:13:00 <franka> elliott: I know there is one in the GHC source code.
11:13:23 <elliott> franka: ha
11:13:36 <franka> I actually meant that seriously. ;)
11:13:42 <franka> Dunno if it is exposed.
11:14:03 <elliott> franka: If this were the mid-90s and I asked if there was a standard implementation of monads you'd have given me the same reply!
11:14:11 <franka> haha
11:14:19 <franka> Yeah, i still live in yesteryear.
11:14:38 <franka> What's with these new-fangled library things???
11:14:51 <elliott> "Cabal"? Sounds SUSPICIOUS.
11:15:13 <franka> Doesn't it?!
11:15:31 <hatds> good one
11:16:03 <ClaudiusMaximus> elliott: hayoo shows up a few results
11:16:07 <monochrom> look into Data.Graph (package name fgl, comes with haskell platform), there is a "topSort" function
11:16:33 <franka> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Graph.html#topSort
11:17:10 <monochrom> sorry, package name containers, comes with ghc
11:17:12 <elliott> monochrom: I don't want to be tied to a specific graph representation, though.
11:17:19 <elliott> well
11:17:21 <elliott> that's not what i mean
11:17:24 <elliott> I mean I'm not storing things as graphs
11:17:27 <franka> Good luck with that.
11:17:43 <monochrom> convert your data to Graph
11:17:48 <franka> Yes.
11:17:53 <elliott> I might, if I can figure out a sane way to do it...
11:18:21 <franka> You have problems with sharing?
11:18:29 <monochrom> I'm pretty sure every topological sort lib requires you to use its fetish data structure rather than your fetish data structure.
11:18:48 <hatds> then convert their source code to fit your needs?
11:18:50 <elliott> monochrom: My fetish data structure is a Set. :p
11:18:57 <elliott> Nah, I do need to turn it into a graph.
11:19:03 <elliott> It just feels weird pulling in a whole graph library to do it.
11:19:05 <monochrom> yeah, stealing source code is an option too
11:19:15 <elliott> what license are the ghc libs under?
11:19:31 <franka> You're not Conal, I guess?
11:19:44 <elliott> No, I'm not :-)
11:19:59 <monochrom> this one comes with ghc. you're speaking like "it feels weird pulling in a whole integer library just to add numbers"
11:20:00 <elliott> But I don't mind being mistaken for Conal on a regular basis, so feel free to.
11:20:14 <elliott> monochrom: Well, of course it does! There needs to be a Nat type.
11:20:30 <franka> Yeah, there does.
11:20:35 <monochrom> ok correction. this one comes with ghc. you're speaking like "it feels weird pulling in a whole nat library just to add numbers"
11:20:45 <WendyMackaye> Downloaded that baastard.pdf
11:20:54 <elliott> monochrom: But of course.
11:21:22 <monochrom> my point is if the lib comes with ghc already, "pulling in a whole lib" is a wrong way to look at it.
11:21:34 <franka> You can use the GHC libraries without restriction.
11:21:50 <elliott> franka: What, are they WTFPL'd?
11:21:53 <elliott> monochrom: Agreed.
11:22:05 <monochrom> I think the license is http://www.haskell.org/ghc/docs/latest/html/users_guide/License.html
11:22:17 <elliott> Yes, which is BSD3, it looks like.
11:22:22 <elliott> Which is definitely _not_ "without restriction".
11:23:22 <pikhq> Pretty close though.
11:23:25 <franka> BSD-style (see the file libraries/base/LICENSE)
11:23:55 <monochrom> http://hackage.haskell.org/package/containers-0.3.0.0 says BSD3
11:24:06 <franka> It doesn't matter much. If it is too restrictive, you can just reimplement it.
11:24:27 <franka> topSort is really standard.
11:24:49 <monochrom> I think BSD3 restrictions don't hamper you.
11:24:50 <franka> Since UniSys gave up its copyright claims. :)
11:25:01 <jonkri> i need some kind of stateful entity in my program which has an xmpp connection and some other relevant state, and that communicates with another entity. here are some of the responsibilities: http://paste.pocoo.org/show/320669/ - what should i look up for dealing with the inner state as well as the "message passing" between the entities? would the entities be modules?
11:26:42 <hatds> It sounds like you are asking how to have state in general
11:27:39 <franka> Isn't XMPP for storing photo information for images?
11:28:22 <jonkri> franka: xmpp = jabber = decentralized messaging protocol
11:28:30 <monochrom> no, I seem to recall xmpp being a chat protocol, exif is the photo info
11:28:33 <franka> :O
11:29:35 <franka> monochrom: Yeah, I know EXIF. But there is some thingy in Photoshop which uses something with an acronym like XMPP.
11:29:44 <monochrom> oh ha
11:30:16 <monochrom> well I know of several acronyms with multiple meanings from multiple communities.
11:30:44 <jonkri> hatds: i guess i am :)
11:30:45 <medfly`> @hoogle forever
11:30:45 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
11:30:51 <monochrom> ATM is a famous overloaded one. bank machine or fibre network thingie
11:30:54 <hatds> To model state try to make all stateful values parameters to your function.  When the function recurses you pass in the "new" state.  If you have to, you can also use IORefs for state.
11:31:31 <monochrom> and then you probably wouldn't expect TLA to mean http://research.microsoft.com/en-us/um/people/lamport/tla/tla.html :)
11:32:08 <monochrom> (I'm pretty sure Lamport was deliberately contriving to call it TLA :) )
11:33:56 <jonkri> thanks hatds, that's very helpful :) so basically, i would have an io process waiting for a message to be received?
11:34:31 <hatds> jonkri: for the message passing part it depends on what kinds of communications you want
11:35:09 <hatds> jonkri: if you want two threads to communicate look around Control.Concurrent for MVars, Chans, TVars..
11:35:10 <franka> ... What else would TLA mean?
11:35:15 <franka> Tits, legs and ass?
11:35:23 <aristid> monochrom: that's a really bad name for googleability
11:35:30 <aristid> franka: Three Letter Abbreviation
11:35:50 <aristid> oh, tla microsoft finds it
11:35:53 <hatds> jonkri: but if your two entities aren't running concurrently then you would simply pass messages as normal parameters to functions
11:36:19 <monochrom> or tla lamport
11:38:23 <jonkri> hatds: the communication between my two processes (the last two dots in the paste) are asynchronous... i guess that means no functions, right?
11:38:30 <franka> Oh, I was thinking of http://www.adobe.com/products/xmp/
11:38:55 <franka> As for ATM, everybody knows that is ass-to-mouth.
11:39:18 <hatds> jonkri: yeah, you need Control.Concurrent for async communication
11:39:55 <Eelis> i've got a weird testcase where GHC 7.0.1's type checker gets terribly by confused when i replace an occurrence of a certain function name 'f' with 'id f': http://codepad.org/2ATTZfMK   is this a bug?
11:40:20 <jonkri> great :)
11:41:16 <monochrom> have you tried it on ghc 6.12.3? which I'll do now.
11:41:28 <Eelis> monochrom: i uninstalled my 6.12 yesterday :(
11:41:57 <monochrom> ghc 6.12.3 accepts it. I think it's a bug.
11:42:05 <Eelis> ok, i'll take it to #ghc then :)
11:42:09 <monochrom> I mean I think it's a ghc 7 bug.
11:42:37 <franka> rank 2 types are not a Haskell feature anyway
11:43:27 <monochrom> have you also tried RankNTypes?
11:43:53 <Eelis> nope
11:44:11 <Eelis> same error
11:46:07 <Eelis> monochrom: by the way, thanks for checking with 6.12.3 :)
11:57:09 * hackagebot monad-param 0.0.3 - Parameterized monads  http://hackage.haskell.org/package/monad-param-0.0.3 (DominiqueDevriese)
12:07:19 <duairc> How do you reify an instance declaration in TH?
12:08:42 <edwardk> thanks dominique!
12:09:02 <edwardk> one package off my plate =)
12:09:59 <edwardk> duairc you mean how do you write the Q Dec for it?
12:10:11 <edwardk> or how to do you get one?
12:10:54 <duairc> edwardk: How do you get one?
12:11:35 <edwardk> classInstances or reify the class
12:12:44 <edwardk> reifying a class gives you a Info with a ClassI constructor which contains a list of ClassInstances
12:13:10 <duairc> edwardk: Ah okay, cool, thanks.
12:13:48 <edwardk> that only works in the actual Q monad, not through the Quasi instance for IO
12:14:11 <edwardk> so you can't test it in the repl
12:15:47 <edwardk> er s/actual Q monad/the Quasi implementation used in ghc at compile time/
12:16:56 <Saizan> to test in the repl: $(lift . show =<< ...)
12:24:14 <edwardk> saizan: with classInstances?
12:36:52 <Saizan> edwardk: reify at least
12:40:44 <kuffaar> When will network be updated for the new parsec? :/
12:55:13 <deech> Hi all, how do I create a function that generates a different list of random number generators whenever it is called? Does something like this exist on Hackage?
12:56:14 <monochrom> first of all it cannot be a pure function. you have to settle for eg IO
12:56:58 <deech> That's fine. 
12:57:34 <monochrom> look for stuff inside System.Random. standard library.
12:58:32 <deech> monochrom: Here's what I have so far: http://hpaste.org/43028/random_numbers
12:59:28 <deech> But it always generates the same set of generators.
13:01:02 <Saizan> s/getStdGen/newStdGen/
13:01:52 <monochrom> I am not sure you must obtain an unbounded list of generators rather than call an action once to get one new generator.
13:02:57 <deech> Saizan: Thanks! That worked.
13:03:20 <deech> monochrom: You are right, I didn't know of "newStdGen" so I was unsuccessfully trying to use getStdGen.
13:13:38 * hackagebot wumpus-core 0.42.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.42.0 (StephenTetley)
13:15:08 <edwardk> Saizan: is that a 7.0 thing?
13:15:39 * hackagebot wumpus-basic 0.15.0 - Basic objects and system code built on Wumpus-Core.  http://hackage.haskell.org/package/wumpus-basic-0.15.0 (StephenTetley)
13:15:41 * hackagebot wumpus-drawing 0.1.0 - High-level drawing objects built on Wumpus-Basic.  http://hackage.haskell.org/package/wumpus-drawing-0.1.0 (StephenTetley)
13:15:43 * hackagebot wumpus-tree 0.13.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.13.0 (StephenTetley)
13:16:10 <Saizan> edwardk: it always worked for me, the trick is that since it's a splice it's run in the actual Q monad, from which you generate the code for the String output
13:16:27 <edwardk> fair nuff
13:16:33 <pedro3005> what's a good way to represent a tree structure in haskell?
13:16:36 <edwardk> ah
13:16:39 * hackagebot wumpus-microprint 0.14.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.14.0 (StephenTetley)
13:17:25 <edwardk> hrmm, typo on the wumpus-core cabal's haddock
13:23:28 <j-invariant> pedro3005: data Tree a = Leaf a | Branch (Tree a) (Tree a)
13:26:24 <duairc> Okay, in Template Haskell, how do you get the body of the functions in a ClassInstance?
13:27:53 <edon> hi, do you guys know of an efficient implementation of the hamiltonian path problem in haskell?
13:27:55 <Saizan> not sure about ClassInstance, but in general TemplateHaskell doesn't let you access the body of functions
13:28:03 <pedro3005> j-invariant, okay, and then how do I manipulate that? Like, if I want to make a function that takes a Branch does something with their leaves, how would I extract them?
13:28:24 <duairc> Saizan: Ah, okay then
13:29:16 <j-invariant> pedro3005: The fundamental operation that you need is:
13:30:15 <j-invariant> pedro3005: http://hpaste.org/43030/title
13:35:52 <pedro3005> j-invariant, can you explain what that function does?
13:36:59 <j-invariant> pedro3005: do you know what type it has yet?
13:37:06 <monochrom> suppose you want to count the number of leaves. that's "tree (const 1) (+)"
13:37:12 <j-invariant> pedro3005: I will show you an example of using it first of all
13:37:21 <j-invariant> pedro3005: (but you should check the type right now)
13:38:37 <monochrom> suppose your tree has numbers in leaves and you want to "add 2 to each number". that's "tree (+ 2) Branch"
13:39:15 <monochrom> oops, "tree (\x -> Leaf (x + 2)) Branch"
13:41:33 <monochrom> perhaps you say, no, you want to write your own recursive functions to do those. after a while you will see you're repeating a pattern and it's captured by the "tree" function.
13:41:36 <j-invariant> pedro3005: here are two basic examples, http://hpaste.org/paste/43030/title_annotation#p43031
13:41:50 <pedro3005> so it's kind of a map
13:42:05 <monochrom> no, kind of foldr
13:42:12 <j-invariant> pedro3005: it's a lot like map, that's true: Try to write map in terms of it and you will notice it is slightly more general
13:42:55 <vladimir> Checkout what I've made for programmers: http://tagmask.com It's a new way to share your technical posts.
13:44:33 <j-invariant> http://tagmask.com/tags/haskell
13:45:00 <j-invariant> vladimir: not a bad idea
13:45:41 <joe6> > (fst . head . readHex $ "0009")::Int
13:45:45 <lambdabot>   mueval-core: Time limit exceeded
13:45:51 <joe6> is there a better way of doing the above?
13:46:07 <joe6> readHex returns an Integer and I am usin ::Int to convert to Int
13:46:28 <vladimir> j-invariant: thank you, it is just launched. There is small amount of posts.
13:46:30 <tibbe> working with Haskell on Windows is such a major pain
13:46:39 <monochrom> yes
13:46:49 <monochrom> but not as much as mac
13:47:03 <aavogt> joe6: it's not a conversion. If you left off the type, and used that definition as an Int somewhere else you don't need the annotation
13:47:07 <aristid> you have to use linux for the convenience
13:47:20 <aavogt> @ty readHex
13:47:22 <lambdabot> forall a. (Num a) => String -> [(a, String)]
13:48:10 <joe6> how do I convert a Word16 to an Int?
13:48:17 <monochrom> fromIntegral
13:48:28 <monochrom> the inverse is also fromIntegral
13:49:01 <joe6> monochrom: thanks
13:51:01 <joe6> :t combine
13:51:02 <lambdabot> Not in scope: `combine'
13:51:03 <joe6> combine :: Byte -> Byte -> Word16
13:51:06 <tac-tics> @type fromIntegral
13:51:07 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:51:20 <pastorn> joe6: what do you want to do?
13:51:24 <joe6> i am wondering if I cannot use (fromIntegral . combine)?
13:51:30 <pastorn> joe6: also it's called "Word8" in haskell
13:52:14 <monochrom> who is "combine"?
13:52:26 <joe6> i have 2 character Strings that I want to convert to an Int. I already have a function that converts them to Word16, so I am thinking of adding fromIntegral to it,
13:52:45 <joe6> combine converts the 2character strings to Word16
13:52:55 <monochrom> I see who is combine. (fromIntegral . combine) probably doesn't have a sensical type.
13:52:59 <joe6> and I am thinking of doing fromIntegral . combine
13:53:03 <pastorn> joe6: give an example of input/output
13:53:44 <joe6> combine "0f" "08" = 3848:Word16
13:54:07 <joe6> combine "00" "08" = 8 :: Word16
13:54:26 <joe6> > fromIntegral 3848
13:54:28 <lambdabot>   3848
13:54:50 <joe6> (fromIntegral 3848)::Int :: Int
13:54:57 <joe6> > (fromIntegral 3848)::Int
13:54:58 <Zao> > read "0x8f" :: Word32
13:54:58 <lambdabot>   3848
13:54:59 <lambdabot>   143
13:54:59 <c_wraith> : fromIntegral ?x
13:55:05 <c_wraith> :t fromIntegral ?x
13:55:06 <lambdabot> forall a b. (?x::a, Integral a, Num b) => b
13:55:35 <pastorn> Zao: holy shit, i had no idea read could handle hex notation :D
13:55:42 <joe6> don't bother. I got it.
13:55:51 <joe6> :t fromIntegral . combine "0f" $ "08"
13:55:52 <lambdabot> Not in scope: `combine'
13:55:55 <monochrom> ok, you already have a Word16, and you want fromIntegral to convert it to... Word16 again?
13:56:16 <joe6> monochrom: I want an Int out
13:56:29 <monochrom> ok sorry, convert to Int. OK that's (fromIntegral (combine x y))
13:57:03 <joe6> i was trying fromIntegral . combine and was wondering why it was not giving a sensible type. 
13:57:09 <joe6> forgot the first argument of combine
13:57:21 <monochrom> yeah you forgot combine is 2-ary
13:58:09 <monochrom> you see it's very dangerous to wantonly translate "intuitively it's composition" to (.). or generally any intuition.
13:58:44 <napping> Is there any way to unify equi-recursive types with explicit substitutions?
13:58:45 <lambdabot> napping: You have 1 new message. '/msg lambdabot @messages' to read it.
13:59:08 <joe6> function composition is pretty addictive
13:59:16 <joe6> atleast for beginners like me.
13:59:25 <j-invariant> napping: are you talking about in the implementation of type inference?
13:59:32 <napping> It seems imperative union-find with explicit pointer equality is actually easier
14:00:08 <napping> It's for type inference, yes
14:00:31 <napping> I'm trying to handle it by adding a form Mu Symbol Ty to my types
14:00:55 <napping> and handling a constraint that fails the occurs check by wrapping it up as a Mu type with a fresh variable
14:01:18 <napping> unfortunately, I don't see any good way of unifying a Mu type with another type
14:01:59 <napping> the only option I see is to keep an explicit list of already-encountered unification instances to make the coinduction work, and do a deep compare of the current pair with every saved pair at each step of the process
14:02:08 <tibbe> anyone with a working Windows Haskell setup that could test build the latest network package for me?
14:02:36 <tibbe> if so, please try to build http://johantibell.com:8080/job/network/COMPILER=ghc-7.0.1,OS=linux/lastSuccessfulBuild/artifact/dist/network-2.3.0.2.tar.gz
14:11:54 * hackagebot contravariant 0.1.0 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.1.0 (EdwardKmett)
14:15:09 <taktoa> is there any easy way to sum all the elements of two lists of type Num a => [[a]]
14:15:33 <pastorn> taktoa: sum . map sum
14:16:00 <deech> Hi all, how do I evaluate "getCurrentTime" strictly in the IO monad? I want to store the current time in 'a' , then 'threadDelay 5000', store the current time to 'b' and print them both.
14:16:11 <j-invariant> taktoa: Num a => [[a]] -> a?
14:16:17 <deech> Right now 'a' and 'b' are both evaluated by the 'print' call.
14:16:21 <taktoa> no
14:16:24 <pastorn> deech: i usually do force x = x `seq` return ()
14:16:30 <taktoa> [[a]] -> [[a]] -> [[a]]
14:16:41 <monochrom> eh? getCurrentTime is already strict, eager, whatever you call it.
14:16:43 <pastorn> deech: then i do this: do { t <- getCurrentTime; force x; blabla}
14:16:46 <j-invariant> taktoa: I'm not sure that makes sense, unless you assume they have the same dimensions?
14:16:52 <taktoa> each element of the first added to the corresponding element in the second
14:17:00 <taktoa> they have the same dimensions
14:17:01 <j-invariant> :t map . map (+)
14:17:02 <lambdabot>     Couldn't match expected type `a -> b'
14:17:02 <lambdabot>            against inferred type `[a1 -> a1]'
14:17:02 <lambdabot>     Probable cause: `map' is applied to too many arguments
14:17:08 <j-invariant> :t map . map . (+)
14:17:09 <lambdabot> forall b. (Num b) => b -> [[b]] -> [[b]]
14:17:09 <deech> pastorn: do you mean 'force t' ?
14:17:19 <monochrom> you should realize that 'threadDelay 5000' is a very short time even for a computer.
14:17:24 <pastorn> monochrom: not always... i've used it for performance testing, and then it wouldn't be executed until diffUTCTime would be called
14:17:30 <pastorn> deech: yeah, sorry
14:17:51 <pastorn> deech: you could also do force x = (x `seq` return x)
14:18:04 <pastorn> deech: that way you can have t <- (getCurrentTime >>= force)
14:18:21 <deech> pastorn : nice.
14:18:33 <j-invariant> :t zipWith (zipWith (+))
14:18:34 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
14:18:41 <joe6> when I create my own data structures and the structure has 8 or so elements, I define the structure as a list and when using that structure, I patternmatch to an error any item that does not have 8 elements.
14:18:56 <joe6> I wish there was a way to specify a list but with exactly 8 elements.
14:19:09 <edwardk> what was the last thing i said before i crashed?
14:19:10 <kuffaar> Hmm when I use foreign import ccall unsafe, do I always need to have IO in the return type or is that only necessary for stuff which modifies a state outside the function?
14:19:11 <joe6> I could list the 8 elements out but that is too much work..
14:19:17 <taktoa> j-invariant: thanks, that works
14:19:26 <joe6> just curious, if there is any such functionality.
14:19:29 <pastorn> joe6: you should list the 8 elements... or maybe you could pair them...
14:20:07 <joe6> pastorn: wondering if there are any other options other than these 2. such as maxBounded list?
14:20:21 <joe6> or a minBounded list?
14:20:38 <pastorn> joe6: i.e. if you're  doing a 'Matrix3 a', instead of doing "data Mx3 a = Mx3 a a a  a a a  a a a" you can do "data Vec3 a = Vec3 a; data Mx3 a = Mx3 (Vec3 (Vec3 a))"
14:21:09 <pastorn> *= Vec3 a a a
14:21:37 <joe6> pastorn: the list does not have the same element..
14:21:59 <pastorn> joe6: will you do pattern matching on this data? 8 elements sounds like would need records... what are you trying to represent?
14:22:13 <joe6> pastorn: I think I get what you are saying. let me think through this. good idea.
14:22:47 <joe6> pastorn: a [Word8]
14:23:03 <pastorn> joe6: yeah, but what is it?
14:23:23 <pastorn> joe6: and if you have 8*Word8, why not use Word64?
14:23:38 <joe6> type Byte = String
14:23:38 <joe6> data Message = Message [Byte] Lineno LineContent deriving (Eq,Show)
14:23:47 <pastorn> joe6: make a paste
14:23:52 <pastorn> joe6: http://codepad.org
14:23:58 <pastorn> i don't think hpaste is working...
14:25:25 <joe6> pastorn: http://hpaste.org/43032/data_structures
14:25:27 <msieradzki> what's the practical difference between Data.Array and Data.Vector?
14:25:56 <Cale> msieradzki: Data.Vector is more highly optimised
14:26:02 <pastorn> type Byte = String
14:26:04 <pastorn> joe6: lolwut?
14:26:08 <Cale> but doesn't allow arbitrary index types
14:26:38 <pastorn> msieradzki: choosing your own index types is pretty swell... you get multi-dimensional arrays trivially
14:27:04 <monochrom> http://hpaste.org/43033/getcurrenttime_works_fine
14:27:18 <pastorn> monochrom: do some non-io in between
14:27:26 <monochrom> such as?
14:27:26 <pastorn> monochrom: factorial of 1000
14:27:42 <monochrom> doesn't take long enough
14:27:43 <pastorn> monochrom: then you print the result and the time diff AFTER the second getCurerntTime
14:27:49 <pastorn> well, raise the number then!
14:27:51 <pastorn> :p
14:27:58 <joe6> pastorn: just did whatever I could to make it work.
14:28:03 <joe6> any suggestions on that code?
14:28:08 <joe6> please?
14:28:26 <pastorn> joe6: yeah, stop using string
14:28:33 <pastorn> joe6: ok, so what am i looking at here?
14:28:45 <pastorn> "ControlTxns" doesn't give up too much :(
14:29:07 <pastorn> joe6: you have a spec. you code by?
14:30:12 <joe6> pastorn: any preliminary thoughts on the data structures?
14:30:35 <joe6> most of them are just synonyms for 2 character string.
14:30:39 <pastorn> joe6: you still haven't told me what it's for, so i don't know where to start reading
14:30:47 <pastorn> i see a giant wall of stuff
14:31:31 <pastorn> and that's about it, i don't really want to start reading it before i know what it's for (you haven't commented your code)
14:31:46 <tolkad> > newSTRef
14:31:47 <lambdabot>   Overlapping instances for GHC.Show.Show
14:31:48 <lambdabot>                              (a -> ...
14:31:49 <monochrom> http://hpaste.org/paste/43033/getcurrenttime_still_works_fin#p43034 still no laziness
14:31:52 <tolkad> > newSTRef 1
14:31:54 <lambdabot>   <<ST action>>
14:32:02 <joe6> pastorn: please give me a few minutes. I got stuck with fixing the hLint stuff.
14:32:17 <pastorn> joe6: ignore hlint for now...
14:33:25 <deech> monochrom : check out http://hpaste.org/43035/lazytime. 
14:33:46 <deech> monochrom: the calls to getCurrentTime are only evaluated when print is called
14:33:51 <monochrom> huh? nothing between the two getCurrentTime's?
14:34:00 * hackagebot contravariant 0.1.0.1 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.1.0.1 (EdwardKmett)
14:34:03 <monochrom> use threadDelay 5000000000000 to see
14:34:13 <monochrom> or just 5000000 (5 seconds)
14:34:15 <pastorn> monochrom: http://hpaste.org/paste/43033/getcurrenttime_works_fine_ann#p43036
14:34:22 <joe6> pastorn: I am reading usb test data from a file to [ControlTxn] -> processing it to -> TxnMemory ( a representation of how the data will look like when sent to a simulator) and the data expected out from the simulator
14:34:33 <pastorn> monochrom: haven't run that yet, but i think that's how i got my problem
14:34:42 <joe6> the TxnMemory is basically a tuple of data (todevice, fromdevice)
14:34:49 <monochrom> "let x = product [1..50000]" is laziness of pure value, not laziness of getCurrentTime.
14:34:55 <joe6> and the actual memory read from the simulator is a list of [fromdevice]
14:34:59 <pastorn> joe6: seriously, give me a datasheet or something
14:35:37 <monochrom> there is a reason why I carefully used "print (length (show (product [1..50000])))"
14:35:50 <pastorn> monochrom: but do you agree that it's kind of stupid that the computation of x gets pushed?
14:36:11 <deech> monochrom: gah! It works as you say. 
14:36:17 <deech> What was I smoking?
14:36:39 <monochrom> I thought you were stating a property of getCurrentTime, not a property of x.
14:36:48 <joe6> pastorn: it would be the usb spec, but the data file that I am reading the data is at http://hpaste.org/paste/43032/data_structures_annotation#p43037 (please scroll down)
14:37:05 <monochrom> x is postponed, yes, welcome to ghc
14:37:16 <pastorn> monochrom: i know! hello headache!
14:37:24 <joe6> usb control transaction = read transaction or write transaction
14:37:38 <monochrom> getCurrentTime is not postponed.
14:37:47 <joe6> read transaction = setup message + [many or one in messages] + one out message
14:37:50 <pastorn> monochrom: ah
14:38:04 <pastorn> joe6: srsly, rfc or datasheet
14:38:09 <joe6> write transaction = setup messages + [many or none out messages] + one in message
14:38:14 <monochrom> if you look into the implementation, there is no "unsafeInterleaveIO" used under getCurrentTime.
14:38:43 <deech> monochrom: So I can take it as a general rule that IO is strict?
14:38:45 <monochrom> if you look into "criterion" it has a way to get x done immediately
14:38:46 <pastorn> monochrom: yeah, but i never guessed it was
14:38:53 <joe6> pastorn: give me a second, I will find the usb spec or documentation that explains it.
14:38:56 <edwardk1> deech: for the most part, yes
14:39:18 <kyagrd> deech: but there are few exceptions like getContents
14:39:26 <edwardk> modulo getContents/unsafeInterleaveIO, etc.
14:39:42 <pastorn> deech: yes, IO is strict, but if you look at the example with "let x = ..." between the getCurrentTimes, then you might understand what's going on
14:40:19 <deech> pastorn: I did look at the example, 'let' in the IO monad is computed lazily. 
14:40:24 <deech> What about 'where'?
14:40:32 <monochrom> IO is strict. pure functional programming like "let x=5" is non-strict.
14:40:49 <monochrom> where is like let in this regard
14:40:59 <deech> monochrom: cool. That clears up a lot.
14:41:32 <monochrom> @undo do { x<-gettime; let v=5; print x }
14:41:33 <lambdabot>  Parse error at "}" (column 35)
14:41:41 <monochrom> @undo do { x<-gettime; let {v=5}; print x }
14:41:41 <lambdabot> gettime >>= \ x -> let { v = 5} in print x
14:41:50 <pastorn> joe6: i can tell you that the problem i see right now is that you have set up all the types in a flat way, not in a way where you can enforce much
14:41:59 <joe6> pastorn: http://www.beyondlogic.org/usbnutshell/usb4.shtml
14:42:12 <pastorn> joe6: (enforce = type error on non-working code)
14:42:18 <ddarius> One action happens before the other, but there's nothing that makes the results of an IO action have to be evaluated.
14:42:35 <joe6> pastorn: any comments are most welcome.
14:42:40 <monochrom> gettime >>= \ x -> let { v = 5} in print x   this is what you should look at. IO's >>= ensures order. IO's >>= is the only thing that ensures order. the rest is pure functional programming, nonstrictness reigns.
14:43:06 <pastorn> monochrom, ddarius, deech: what about do { t0 <- gct; x <- return (product [1..n]); t1 <- gct }?
14:43:21 <joe6> pastorn: i think the "data BD" should be done better, without listing all the values in that list.
14:43:29 <monochrom> >>= ensures order but return doesn't. return is almost required to be non-strict.
14:43:36 <ddarius> pastorn: x is not evaluated.
14:43:40 <monochrom> @undo do { t0 <- gct; x <- return (product [1..n]); t1 <- gct }
14:43:41 <lambdabot>  Parse error at "}" (column 57)
14:44:01 <monochrom> @undo do { t0 <- gct; x <- return (product [1..n]); t1 <- gct; blah }
14:44:02 <lambdabot> gct >>= \ t0 -> return (product [1 .. n]) >>= \ x -> gct >>= \ t1 -> blah
14:44:15 <joe6> and i prefer the 2 character string as a byte as most of the comparisions or data inputs /outputs are in string form. I could put it as a Word8 but would have to convert it for each input/output
14:44:17 <monochrom> look at the >>= points. they are the only checkpoints.
14:44:44 <pastorn> ddarius: ok
14:44:58 <deech> monochrom: is >> similar?
14:44:59 <joe6> pastorn: if you notice, I have a lot of error messages for different patterns that will probably never happen.
14:45:08 <monochrom> a monad law rewrites that to: gct >>= \ t0 -> gct >>= \ t1 -> blah
14:45:17 <pastorn> joe6: that just tells me you are using the wrong interface to get your data
14:45:23 <monochrom> yes, x>>y is x>>=\_->y
14:45:25 <joe6> pastorn: I am sure most of those error conditions can be enforced using a proper architecture of types.
14:45:53 <pastorn> joe6: have you looked at any of the binary libraries?
14:46:08 <joe6> pastorn: no.
14:46:20 <pastorn> joe6: you could start with "binary" on hackage, it has two datatypes which is probably what you want, Put and Get
14:46:34 <pastorn> forms a nice symmetry... the Get is for reading and Put is for writing
14:46:48 <pastorn> joe6: have you done any parsing before?
14:46:57 <joe6> pastorn: I am reading from a text file and comparing with the contents of another text file.
14:47:13 <pastorn> joe6: why not interact with USBs directly?
14:47:16 <ddarius> edwardk: Why don't you have newtype Op a b = Op (b -> a) ?
14:47:18 <joe6> pastorn: yes, used lex and yacc 
14:47:36 <joe6> pastorn: this is not communicating with a usb device.
14:47:36 <pastorn> joe6: have you used monadic parsers?
14:48:29 <joe6> pastorn: the code I am testing is in a simulator. The simulators' memory can be manipulated and the simulator executed and the simulator output is read into a file.
14:48:39 <monochrom> pastorn: http://hpaste.org/paste/43033/bang_on#p43039 may help
14:48:55 <joe6> I am writing a wrapper that takes the test data and puts it in simulator memory format
14:48:59 <pastorn> monochrom: nice :)
14:49:09 <joe6> and then reads the simulator memory and compares it with what is expected.
14:49:43 <joe6> pastorn: basically, a glorified test suite. but with more formatted display for showing the differences.
14:49:48 <pastorn> joe6: anyway, my first thought is that strings will make this inneficient
14:50:10 <joe6> pastorn: I do not care about efficiency. This is unit-test code. 
14:50:12 <edwardk> ddarius: i considered it, but rejected it in favor of keeping the list smaller
14:50:30 <pastorn> joe6: you'll still get better code if you code for binary data
14:50:52 <pastorn> strings just feels like the wrong way to do this, since all the strings are actually encoding is binary numbers
14:51:12 <pastorn> oh wait
14:51:12 <j-invariant> is unfold a coalgebra?
14:51:14 <joe6> pastorn: I agree with you. 
14:51:29 <pastorn> joe6: i saw "setup_token_", but you can still do that with binary
14:51:33 <joe6> pastorn: but as all the interfacing is with text files.
14:51:42 <pastorn> joe6: but do you want only parsing or do you want parsing + writing?
14:51:47 <edwardk> j-invariant: unfold takes a coalgebra and uses it to build a fixed point
14:52:01 <j-invariant> okay
14:52:06 <joe6> pastorn: parsing + writing to simulator
14:52:08 <pastorn> joe6: it's no problem to treat the text files as chunks of binary data
14:52:19 <joe6> pastorn: parsing + comparing what the simulator has output
14:52:24 <pastorn> joe6: how do you write to the simulator?
14:52:49 <joe6> string of 00 01 02 03 04
14:52:52 <joe6> and so on.
14:53:08 <joe6> actually, I write to  a text file nad the simulator reads that file.
14:53:18 <pastorn> joe6: pm
14:53:48 <joe6> pastorn: do not know how. please give me a second and I will figure out how to pm you. Thanks a lot for your time.
14:54:04 <pastorn> joe6: what IRC client are you using?
14:54:10 <joe6> irssi
14:54:27 <pastorn> joe6: /query pastorn opens up our private dialogue
14:55:30 <kuffaar> mm_freak: My IPv6 host is cooler than your IPv6 host
14:56:58 <edwardk> gah i wish type operators were haskell 98
14:58:46 <sproingie> i wish a lot of things were haskell 98
14:58:56 <sproingie> like NoMonomorphismRestriction
14:59:03 <monochrom> i wish haskell 2038 were haskell 98
14:59:04 <kuffaar> Wow, an IRC mate of mine is really angry with me because he told me not to touch Haskell but I checked it out anyways. He told me that Haskell people end up losing themselves in abstract discourse or just writing stuff for the language itself without ever producing any actual applications.
14:59:12 <sproingie> hell i wish that was Haskell 2010
14:59:23 <kuffaar> He said he knew several people who started with Haskell and became useless after that
14:59:48 <sproingie> guess you'll have to show him
14:59:59 <sproingie> but haskell does ruin you on other languages
15:00:09 <sproingie> everything else feels so dark hacky
15:00:16 <sproingie> *darn
15:00:38 <kuffaar> I still plan on coding stuff in C++ really, lower level stuff
15:00:42 <kuffaar> With DLL hooking etc
15:00:47 <monochrom> that's like saying your friend is angry at you after your retirement
15:00:53 <sproingie> i still have occasional fun with forth
15:00:54 <kuffaar> There would hardly be any point in gluing it together
15:00:54 <edwardk> kuffaar: zomg, you are forced to go off and learn how to do all sorts of incredibly wonderful abstract stuff, and then when you're done you're sought after by companies who are looking for people who know what you know. that sounds _terrible_
15:01:29 <kuffaar> I think he does have somewhat of a point though, because I have made similar observations
15:01:37 <ddarius> monochrom: Haskell 2038 is probably Haskell 98, so your wish is granted.
15:01:45 <monochrom> hehehe
15:01:50 <edwardk> ddarius: nah, they may choose to add type operators by then ;)
15:01:52 <kuffaar> And he kept on pointing out how almost all Haskell code is just ghc and libaries for Haskell
15:01:53 <sproingie> i havent hacked in forth for a long time tho.  i havent really coded for fun in years :(
15:02:02 <ddarius> edwardk: If they're feeling very wild.
15:02:02 <kuffaar> Instead of actual applications which do not support Haskell
15:02:13 <sproingie> kuffaar: if "he" has anything worth hearing, let us know
15:02:34 <monochrom> xmonad. snap. yesod.
15:02:40 <kuffaar> Well I think he does have a point there, the output of the community seems... very limited
15:02:51 <monochrom> oh there is darcs too
15:02:51 <sproingie> tell that to galois
15:02:51 <edwardk> ddarius: the reason why i was debating about adding Op was because if i added than and a (a -> a -> b) ‚Äî type then i'd subsume Equivalence and Comparison, etc. which makes the examples scary again
15:03:07 <edwardk> i've tacked it on though
15:03:09 <sproingie> still no web browsers in haskell.  oh well.
15:03:27 <edwardk> since it avoids trompling the name Dual like my previous name had
15:03:42 <ddarius> edwardk: Seems to be well within the gamut of Haskell users' comprehension.
15:03:48 <edwardk> true nuff
15:03:51 <edwardk> =)
15:03:54 <sproingie> darcs is nice but i don't usually hold it up as a showcase
15:03:56 <hatds> programming communities are not charities for the greater public
15:04:00 <sproingie> since git and hg run circles around it
15:04:06 <ddarius> edwardk: So it sounds like JJ may go to the next Boston HUG.
15:04:17 <monochrom> the financial sector used haskell to bring down the whole economy of the whole world.
15:04:20 <kuffaar> Yeah snap is actually quite large already
15:04:27 <edwardk> JJ?
15:04:29 <sproingie> darcs is scary how good it is at merging, but it comes at a price
15:04:30 <edwardk> oh
15:04:34 <edwardk> raytheon jj
15:04:39 <ddarius> monochrom: I'm pretty sure Haskell had little to nothing to do with that.
15:04:40 <kuffaar> yesod is just 180 KiB of code, one man project
15:04:47 <sproingie> besides i like how git can drop me into interactive merges
15:04:49 <kuffaar> Wasn't xmonad really small, too?
15:04:49 <edwardk> cool =)
15:04:51 <jmcarthur> sproingie: not that heavy of a price, IMO
15:05:15 <sproingie> jmcarthur: it's gotten better, yes.  but checking out ghc still takes eons
15:05:16 <ddarius> kuffaar: XMonad is really small by design.  It's also rather popular in its niche.
15:05:18 <jmcarthur> sure, darcs annotate on the ghc repo sucks, but i don't have any projects like GHC sitting around
15:05:20 <jmcarthur> sproingie: no it doesn't
15:05:39 <monochrom> and I forgot manatee
15:05:40 <jmcarthur> let me fact check that real quick. i'll clear my darcs cache and time it
15:05:41 <sproingie> must have been within a year that they fixed that
15:05:51 <kuffaar> xmonad is 188 KiB, about the same size as Yesod
15:06:13 * hackagebot contravariant 0.1.1 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.1.1 (EdwardKmett)
15:06:14 <edwardk> Op added
15:06:40 <sproingie> someone should get yi into manatee
15:07:03 <edwardk> that sounds .. uncomfortable
15:07:09 <hatds> we are talking as if programs created just for the author's needs don't count as "output of the language"
15:07:11 <kuffaar> snap and heist add up to about 3 MiB of code, that's a fair amount alright
15:07:26 <sproingie> 3 megs is a lot of haskell
15:07:29 <kuffaar> hatds it doesn't undo his point
15:07:42 <sproingie> i'm starting to doubt there is a third party in this debate
15:07:55 <edwardk> kuffaar: i find something that large in haskell quite disturbing
15:08:08 <Boxo> "Far from being dryly materialistic, their work illuminates the rich underwater world where character is formed and wisdom grows." STFU, New Yorker.
15:08:12 <hatds> kuffaar: okay, but it sounded like he was complaining that it was necessarily a bad thing
15:08:33 <Boxo> whhops
15:08:33 <kuffaar> hatds: Well it does speak against the language, doesn't it?
15:08:38 <Boxo> wrong channel
15:09:09 <ddarius> kuffaar: You -can- stick with PHP you know.
15:09:18 <jmcarthur> sproingie: this is on an encrypted filesystem, to boot:  darcs get --lazy http://darcs.haskell.org/ghc ghc.darcs  3.85s user 0.27s system 3% cpu 2:14.51 total
15:09:21 <hatds> kuffaar: how many shell scripts are distributed as "applications"?  how many matlab programs?  etc
15:09:36 <sproingie> one of GHC's mottos has been "avoid success"
15:09:43 <ddarius> sproingie: It's not GHC's.
15:09:48 <jmcarthur> sproingie: getting a second copy now that it's been cached:  darcs get --lazy http://darcs.haskell.org/ghc ghc2.darcs  0.57s user 0.08s system 21% cpu 2.960 total
15:10:15 <sproingie> well if it was GHC failed at that :)
15:10:22 <kuffaar> ddarius eew
15:10:29 <kuffaar> The last time I did web dev it was in Ruby :p
15:10:34 <sproingie> jmcarthur: sheeit, that's fast
15:11:32 <jmcarthur> sproingie: annotate is still very slow on the ghc repo, and huge merges on the ghc repo can suck, but that's about it
15:11:57 <ddarius> kuffaar: PHP is used to build "large applications."  It must clearly be a great language.
15:12:29 <edwardk> ddarius: =)
15:13:02 <kuffaar> ddarius they definitely have a great output
15:13:06 <kuffaar> :P
15:13:11 <ddarius> That said, I haven't noticed many shrink-wrapped C# applications or even notable sites openly using C#.  It must be a toy.
15:13:12 <sproingie> "huge merges" are always kind of problematic anyway, but you only have to do those once
15:13:15 * hackagebot comonad 0.6.1.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.6.1.1 (EdwardKmett)
15:13:16 <sproingie> (ideally)
15:13:38 <kuffaar> I've seen plenty of stuff in C# :o even some websites
15:13:46 <kuffaar> Although primarily GUI desktop stuff
15:14:01 <edwardk> kuffaar: someone once told me 'you get what you measure'. if you want to measure applications by lines of code, you'll be working in languages that produce lots of lines of code. what i like about haskell, is that the lines i produce are elegant, and i wind up writing about 10x fewer to do any particular task that i happen to want to do, than i do in any other language.
15:14:33 <ddarius> edwardk: You must be an excellent XSLT coder.
15:14:36 <edwardk> kuffaar: c# is appropriate to certain applications. linq is rather nice, but its a very different language than haskell
15:14:50 <kuffaar> Haha I actually read that LINQ was influenced by Haskell
15:14:51 <edwardk> ddarius: =) in fact, i am ;)
15:15:00 <kuffaar> Or was it Linq
15:15:02 <edwardk> kuffaar: it was, erik meijer was an old haskeller
15:15:06 <edwardk> er is
15:15:08 <sproingie> i read a quote somewhere "perl hackers brag about one-liners.  xslt hackers brag about one-pagers"
15:15:17 <ddarius> @quote one.pager
15:15:17 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
15:15:51 <hpc> fortunately, haskell programs can be made on one line (without semicolons even!)
15:16:02 <hpc> you just need one enormous-ass lambda
15:16:16 <sproingie> personally i think haskell's primary contribution to the world of programming has been all the features people have stolen from haskell
15:16:29 <sproingie> haskell's the giving tree of the programming world, it doesn't mind
15:16:49 <jmcarthur> i think haskell's best features are yet to be stole, i.e. purity
15:16:56 <jmcarthur> *stolen
15:17:03 <edwardk> sproingie: which makes me happy, because when i foray into other languages, i get to see all of these distorted views of wonderful haskell types, then i get to come back home and love haskell again
15:17:12 <ddarius> sproingie: Works for me.  Then people will hopefully stay in their own language.
15:18:31 <kuffaar> Haskell programmers are like tortured novelists who struggle to write and they just end up doing a lot of drugs and burn out
15:18:40 <kuffaar> @quote SPJ cheerful
15:18:40 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
15:18:51 <Tomsik> a lot of drugs
15:18:53 <Tomsik> sound good
15:19:13 <edwardk> kuffaar: you are starting to sound very trollish =P
15:19:29 <kuffaar> I'm not trolling :/ I'm actually struggling to code stuff in Haskell
15:19:32 * ddarius hasn't noticed too many burned out Haskellers.
15:19:43 <kuffaar> It took me like 5 days to figure out how to use IORef for a counter
15:19:47 <kuffaar> In a Snap project
15:19:52 <Tomsik> ddarius: well, because you can't see things that burned
15:19:57 <Philippa> to the extent it happens, it tends to be for reasons that're nothing to do with Haskell I suspect
15:19:58 <Tomsik> like, did you ever see a burned letter?
15:20:05 <Philippa> yep
15:20:09 <Philippa> I mean, obviously it wasn't ashes...
15:20:21 <ddarius> Ashes are quite visible too.
15:20:25 <jmcarthur> edwardk: btw, it occurred to me yesterday that speculation forms a fun little cont monad, which would let you write some stuff pretty neatly.  e.g.  do { x <- spec a' a; y <- spec x' x; g y }
15:21:17 <jmcarthur> probably no need for its own type even
15:21:35 <monochrom> new theory why haskell is so hard to learn: there is nothing to learn in other languages.
15:21:39 <jmcarthur> since the instances are exactly the same as Cont and i can't think of any reason to hide the details
15:22:22 <ddarius> monochrom: There's -plenty- to learn in other languages.  Like MFC, COM, WPF, WCF, WF, ASP.NET, XAML ...
15:22:37 <hpc> monochrom: more like "because math education is deplorable nowadays"
15:22:51 <jmcarthur> omg abbreviations and acronyms
15:22:55 <hatds> (but SPJ is damn cheerful whenever I see him talking about haskell)
15:28:23 <lewis1711> > arg i = getArgs !! i
15:28:24 <lambdabot>   <no location info>: parse error on input `='
15:30:11 <edwardk> jmcarthur: *nods* thats how i more or less use it in the library, as a monadic fold
15:31:38 <lewis1711> http://hpaste.org/43046/type_error can't quite figure out this type stuff, halp?
15:31:49 <edwardk> hrmm
15:31:51 <edwardk> actually
15:31:57 <edwardk> i like your forumation a bit better
15:32:03 <monochrom> paste full code
15:32:05 <edwardk> just flopping the arguments around
15:32:15 <monochrom> ah, you have full code there.
15:32:30 <edwardk> but i'll admit i learned my lesson bolting Cont into real code ;)
15:32:37 <edwardk> it makes people run screaming
15:32:49 <monochrom> x <- getArgs <newline> let arg i = x !! i <newline>
15:32:51 <Renze> Good evening :)
15:33:12 <lewis1711> <- ?
15:33:16 <lewis1711> oh right
15:33:19 <lewis1711> monady stuff
15:33:30 <lewis1711> my powers fail me here
15:33:41 <edwardk> but i think a couple of combinators for specCC :: Eq a => a -> a -> Cont b a and its ilk would be nice
15:34:11 <beastaugh> if you look at the type of getArgs, it's IO [String]
15:34:13 <Renze> Does somebody know where I can find instances of MonadState?
15:34:25 <beastaugh> but the left argument to (!!) needs to be a list
15:34:36 <monochrom> though getArgs is pretty useless at the ghci prompt.
15:34:50 <Renze> If I google for anything around the subject, I only find State and StateT instances, but they don't make it clear to me to use it myself :(
15:34:51 <edwardk> specCCSTM :: Eq a => STM a -> a -> ContT b STM a ‚Äî might be a bit much though
15:35:32 <edwardk> jmcarthur: Control.Monad.Cont.Speculation ?
15:35:44 <jmcarthur> sure :)
15:37:02 <jmcarthur> i find that i rarely actually *want* Cont, but when i do use it it just feels like... normal imperative programming
15:37:06 <jmcarthur> except for the run function
15:37:15 <jmcarthur> well, and of course... this is ignoring callCC
15:37:41 <pastorn> jmcarthur: is cont useful without callCC?
15:37:46 <jmcarthur> which i still don't think is as weird as its reputation. admittedly, when i was first learning to use it, it was tough
15:38:00 <jmcarthur> pastorn: "useful" is a stretch, but i would say something it just fits
15:38:03 <hpc> :t cont
15:38:05 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
15:38:08 <jmcarthur> *sometimes it just fits
15:38:37 <hpc> :t callCC
15:38:38 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:38:48 <pastorn> @src cont
15:38:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:38:56 <pastorn> hpc: cont = Cont ?
15:38:59 <hpc> jmcarthur: i suppose, if you don't mind not being able to get any value out of your Cont r a
15:38:59 <jmcarthur> cont = Cont
15:39:09 <pastorn> yeah
15:39:13 <jmcarthur> hpc: just give it id
15:39:17 <hpc> or if you enjoy pattern-matching over continuation structures
15:39:23 <jmcarthur> :t runCont
15:39:24 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
15:39:33 <hpc> oh quiet, you
15:39:35 <hpc> :P
15:39:39 <edwardk> cont without callCC is just codensity
15:40:02 <edwardk> (well, contT that _can't_ callcc )
15:40:18 <edwardk> cont that can't callCC is Yoneda in category-extras
15:41:21 <hatds> you can still do "escaping" without callCC, but you won't be able to apply the continuation to the escaped computation
15:41:35 <edwardk> yeah
15:41:52 <edwardk> one sec. let me pull up an example
15:42:09 <edwardk> http://www.mail-archive.com/haskell-cafe@haskell.org/msg69730.html
15:42:23 <edwardk> Oracle is Codensity STM 
15:42:52 <edwardk> "needRef" is where the magic happens
15:44:14 <edwardk> the main annoyance is the current speculation-1.0.0 package doesn't require MTL or transformers, so it'd probably be best done as a separate package that uses it
15:46:08 <aristid> speculation-transformers?
15:46:12 <edwardk> yeah
15:46:33 <edwardk> pulling down speculation now
15:47:16 <edwardk> i also need to integrate the numSparks# primop into speculation, since i went and harassed jaffacake until he added it
15:47:28 <edwardk> =/
15:48:25 <edwardk> now, the interesting one to me is if there is a nice speculation comonad transformer =)
15:49:00 <edwardk> should be because its pure, and you can extract, etc.
15:49:42 <Philippa> edwardk: have you done any interesting analysis stuff with VPLs yet, or just straight-up parsers?
15:50:02 <Philippa> (I wrote a v.basic mostly-applicative left-biased-choice-VPL parsing lib on the train last night)
15:50:15 <edwardk> philippa: just parsing them. i was planning on revisiting some of my older monoidal parsing machinery and rephrasing it in terms of VPLs but nothing has actually happened there.
15:50:20 <kuffaar> @src sequence_
15:50:20 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:50:28 <edwardk> nice
15:50:34 <edwardk> how well does it work?
15:50:40 <edwardk> and do you us the VPL to cut backtracking?
15:50:43 <edwardk> er use
15:53:59 <gienah> can you please let me know what VPL is ?
15:54:02 <Philippa> edwardk: not thrown enough test cases at it, but a simple arithmetic parser worked well enough once I'd stopped tripping over default combinator implementations assuming laziness :-) Not exploiting it to cut backtracking much yet, I meant the "v.basic" part, but it's on my to-do list
15:54:08 <Philippa> gienah: Visibly Pushdown Language
15:54:14 <Philippa> alternatively, Visible Panty Line
15:54:24 <gienah> Philippa: thanks
15:54:44 <djahandarie> Possibly TMI
15:55:09 <edwardk> gienah: take a context-free language and only allow it to recurse when you have a special marking token an return when you see a different one. like '(' and ')'
15:55:11 <Philippa> djahandarie: well, maybe if I actually applied it to anyone, but I don't see myself parsing anything with someone's pubes any time soon
15:56:27 <gienah> edwardk: thanks
15:56:59 <Philippa> edwardk: was planning on doing the backtrack-avoidance the slow way anyway - write a static analysis parse that annotates with whichever of commit or try seems to make most sense
15:57:52 <Philippa> I'm also thinking I should do some work on error recovery, probably yank your tech for incremental parsing (however indirectly) and generally build something suitably 'industrial'/multi-purpose
15:58:01 <edwardk> *nods*
15:58:03 <Philippa> oh, plus the inevitable layout pass of course
15:58:17 <Philippa> basically, the lib everyone'll use instead of yours because they can get their heads round it :p
15:58:20 <edwardk> yeah, layout is sort of the killer app for this for me
15:58:22 <edwardk> hahaha
15:58:29 <hatds> I can't think of the right word I need for my variable name. Help me with this analogy   blue : color ::  asynchronous : ??
15:58:40 <edwardk> though, i don't require the whole language to be a VPL, just the structure that layout depends upon
15:59:10 <Philippa> hatds: not sure. Possible "synchronicity [setting/style]". Or communication mode or similar.
15:59:19 <sproingie> hatds: "flow control"?
15:59:39 <Philippa> edwardk: yeah. I'll think at some point about ranges of sensible extensions and which break or complicate which facilities
16:00:08 <hatds> synchronicity is the best one I think, but it's not very snappy :)
16:00:16 <Philippa> edwardk: I'm also thinking about a limited form of negation (other than plain empty) to see if I can make something play well with error reports
16:00:21 <sproingie> "synchronicity" is perhaps a bit specific
16:00:32 <Philippa> sproingie: it depends what the other elements of the set are
16:00:36 <sproingie> asynchronous : synchronicity :: blue :: notblueness
16:00:37 <hatds> the variable is describing the asynchronous/synchronous nature of an IO action
16:00:56 <Philippa> mmm, that's what I suspected
16:01:10 <iago> someone knows some hackage package that could be considered as "very good" in terms of code quality?
16:01:17 <sproingie> hm as an attribute of an object i guess it's a boolean quality
16:01:19 <Philippa> pony?
16:01:32 <sproingie> as a design of an application it's a form of flow control
16:01:33 <edwardk> iago: hrmm, xmonad
16:02:47 <hatds> isAsync is not that bad
16:03:17 <Philippa> edwardk: any suggestions for analysis techniques other than binding things that end up inside brackets to names and doing the 'obvious' grammar analyses on a direct, finite representation?
16:04:04 <Philippa> (...there's a point, would-be-ambiguity-but-for-the-bias detection is definitely on the todo list)
16:04:16 <iago> edwardk, thanks, and some other bigger? I'm doing a job about code quality in Haskell, but since there is no data in the literature my only option is to compare my project with another one considered "very good"
16:04:28 <iago> but my project is a medium-size project
16:04:44 <iago> xmonad seems quite small
16:05:52 <iago> I was thinking in GHC but I don't know if it can be considered as "very good" Haskell :P I think no
16:06:10 <Philippa> there are comparatively few good medium-to-large projects in haskell because they tend to get mercilessly refactored and then split into projects when they're big in breadth rather than depth
16:06:12 <sproingie> ghc is certainly high quality but it's a bit daunting to use as a comparison
16:06:17 <mreh> how do you go about breaking a darcs change into two changes?
16:06:38 <edwardk> jmcarthur: spec g a = Cont $ \k -> Prim.spec g k a ‚Äî man tough library ;)
16:06:48 <mreh> like a hunk into two hunks, it thinks I replaced some text, when infact I delete some and wrote some more in its place
16:06:53 <edwardk> jmcarthur: i have the half dozen versions for spec, thinking about specSTM now
16:07:00 <Philippa> and, to be fair, not so many of us get thrown a project that's truly large in inherent complexity rather than just made that way because of software engineering concerns in inefficient environments
16:07:04 <hatds> Don Stewart has a lot of packages that'd probably qualify as "good code quality" if you are counting library type stuff and not whole applications
16:07:37 <edwardk> iago: ghc would hardly be considered 'good form' haskell
16:07:59 <edwardk> iago: lots of manual argument passing and twiddly details in something that was originally defined in a very flat namespace
16:08:06 <Saizan> sproingie: are you so sure it's high quality? i thought it had quite a few quirks due to being quite old
16:08:33 <sproingie> its output is high quality anyway
16:08:40 <edwardk> iago: folks seem to be very fond of snap, but i haven't dug into the code much
16:08:43 <Philippa> edwardk: that, and it doesn't lean as heavily on its own optimiser as it might do for understandable reasons
16:08:43 <hatds> maybe some of the other compilers have tidy code bases?
16:08:44 <sproingie> compilers are something of a sausage-making process
16:08:52 <sproingie> especially one as old as ghc
16:08:55 <iago> edwardk, uhm yeah
16:09:45 <gwern> UHC should have nice code, I'd think
16:09:46 <kyagrd> Oh compilers, I thougth all compilers can import/export their intermediate form
16:10:11 <iago> snap could do the job, if I join snap, snap-core and snap-server
16:10:30 <kyagrd> Then one day when I was whining why ghc can't parse in its core, only able to dump them out
16:10:33 <iago> I see what Philippa said
16:10:33 <iago> :P
16:10:46 <hatds> in what sense wouldn't there be manual argument passing?  You mean pointfree / not pointfree?
16:10:47 <jmcarthur> edwardk: heh, yeah, i had written exactly that earlier :P
16:10:58 <gienah> mreh: maybe darcs unrecord, then darcs record again, and say no to some changes, then darcs record again and say yes to some changes that you answered no to the first time.  Or ask in #darcs
16:11:00 <kuffaar> I want to create a new thread for each new TCP client I deal with - what function should I be using for that? I think this echo server example used forkIO but the "fork" part really throws me off since Windows obviously has no forking, for example
16:11:15 <jmcarthur> mreh: darcs unrecord; darcs record; darcs record
16:11:15 <kyagrd> someone told me that even gcc doesn't have a parser for its intermidiate language
16:11:17 <napping> kyagrd: external core is supposed to do that
16:11:32 <jmcarthur> err, yeah, what gienah said :)
16:11:40 <iago> gwern, UHC could be very interesting as comparison, but just to know, why it should?
16:11:46 <Saizan> kuffaar: forkIO is not forking a process
16:12:05 <gwern> oh wait, I was thinking of EHC
16:12:07 <sm> mreh: while recording a hunk, press e
16:12:20 <Saizan> kuffaar: it's acutally creating an extremenly lightweight thread which gets mapped to an available OS thread by ghc's runtime system
16:12:21 <gwern> you know, the ?HC which is structured as like 20 increasingly more capable compilers
16:12:23 <napping> kyagrd: I hear it used to work a long time ago, but nobody ever used it so it broke. Tim Chevalier seems to be fixing it up again
16:12:44 <kyagrd> One contribution of LLVM is that it is a implmentation that has a parser for intermidiate language
16:13:23 <iago> gwern, I had know idea about that, so theoretically they made a good design job to keep things simple
16:13:27 <Saizan> kuffaar: so forkIO is what you want there, and it works fine on windows too, remember to compile the executable with -threaded though
16:13:39 <kuffaar> Saizan: Green threads? :/
16:13:45 <gwern> iago: well, so I hear. working through EHC is one of those good intentions I have and cherish and will forever be good intentions
16:13:48 <Saizan> kuffaar: yep
16:13:49 <napping> how's the select/poll/epoll on windows?
16:13:57 <kuffaar> I thought that stuff had died out
16:14:09 <iago> s/know/no sorry
16:14:11 <kuffaar> napping: select is useless, the equivalent of epoll is IOCP stuff
16:14:18 <Philippa> napping: he announced the 1.0 version of the lib today or yesterday or so
16:14:41 <mreh> sm: you win the prize!
16:14:48 <mreh> that's what I was looking for
16:14:50 <sm> yay
16:15:01 <napping> kuffaar: nah, GHC has one of the decent preemptive n/m designs
16:15:05 <sm> iago: what kind of code are you looking for ?
16:15:31 <iago> to be concrete, I will compare X project against Darcs
16:15:43 <iago> if that helps
16:16:22 <iago> UHC or snap seem good candidates for now
16:16:41 <napping> Philippa: you've written a few compilers, haven't you? Have you ever worked with equirecursive types?
16:17:09 <Philippa> napping: heh, I mostly write interpreters and typecheckers rather than compilers
16:17:26 <napping> That's actually all I'm trying to do for now
16:17:29 <Philippa> I haven't worked with them directly, no. I've definitely wanted to play "mess with the fixpoint" more than I've got round to doing
16:18:03 <iago> Darcs is about 20k lines of code, so, something near, at least >10k would be the best
16:18:03 <napping> The thing is, I've figured out a decent way to handle them with unification variables and pointer equality, but not under explicit substitutions
16:18:42 <McManiaC> does anyone know a decent C parser for haskell (preferably for happy)?
16:18:49 <McManiaC> dont want to write one on my own
16:18:52 <napping> McManiaC: Language.C?
16:18:52 <Zao> McManiaC: Apart from Language.C?
16:19:19 <kyagrd> Zao, bnfc page has an example C implementation
16:19:29 <McManiaC> oh‚Ä¶ :) thx napping, Zao 
16:19:31 <kyagrd> I don't know how fully it covers it though
16:19:53 <napping> Philippa: to get the coinduction to work, it seems like you need to keep a history of most pairs you have tried to unify, and do a deep structural equality test against each of them at each step
16:19:53 <sm> iago: there aren't actually that many haskell projects of that size yet 
16:20:30 <iago> I know
16:21:35 <elliott> are there enough haskell web frameworks in existence, or do you think we need MORE? answers on a postcard please
16:22:20 <sm> elliott: we're just getting warmed up
16:22:22 <Philippa> elliott: we need better. Only the existing ones have undesirable (for at least one person) design choices baked in. 'nuff said?
16:22:37 <kyagrd> elliott: we don't have things like Django
16:22:45 <elliott> @quote combinatorial
16:22:46 <lambdabot> ehird says: 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
16:22:47 <iago> Holumbus? It seems to be medium size, though I have no idea about its quality, someone have some idea?
16:22:51 <elliott> i said that in early 2009 i believe
16:22:55 * elliott way ahead of the curve
16:23:02 <elliott> before snap or yesod or happstack!
16:23:23 <elliott> maybe i should make my own, you know, just to make sure i'm remembered as a prophet
16:23:47 <olsner> elliott: you want web frameworks? why?
16:24:27 <Evious> Has anyone used the BERT-RPC Haskell client?
16:24:30 <napping> Philippa: have you made a type system with extensible records?
16:24:41 <elliott> olsner: i didn't say i wanted them
16:24:44 <elliott> i just don't think we have enough, dude!!
16:25:10 <olsner> elliott: if you don't think we have enough, you want more
16:25:42 <Philippa> napping: nope, but CBA - if I do, odds are it'll be qualified types and I'll yank Leijen's lexically-scoped labels system for first choice. Fairly boring
16:25:57 <elliott> olsner: i'm not saying they're a good idea, i'm just saying that there needs to be a lot of them
16:26:15 <napping> I'm trying to build one for an object system
16:27:09 <Philippa> *nod*. Got any particular criteria for what that needs to do?
16:27:23 <napping> Well, I was looking at Gilad Bracha's blog
16:27:26 <Philippa> (definitely get your head around qualified types, they're pretty much the biggest development in type inference since hindley-milner)
16:27:31 * sm gives up trying to find haskell apps > 10k LOC other than *HC and darcs
16:28:14 <napping> The particular case is to handle things like mixins, where an "abstract base class" can define methods in terms of methods assumed to exists in ways where the types are not compatible
16:28:30 <napping> and then subclasses can override them while calling on the inherited versions, and fix that up
16:28:43 <McManiaC> is there some GHC library which I could use to generate a valid .hs file by using the haskell AST?
16:29:31 <Philippa> napping: yeah, so you need a 'good enough' type for inherited versions at any given step, or a big recursive bundle
16:29:37 <napping> the general idea is to model a class as a function {r1} -> {r2}, and get an object by taking a fixpoint
16:29:45 <Philippa> yeah
16:29:54 <olsner> sm: when you get to that point you should be able to split it up into a bunch of cabal libraries and a <1kloc application that uses them
16:30:19 <olsner> arguably, GHC and Darcs have just failed splitting up sufficiently
16:30:47 <edwardk> jmcarthur: amusingly my original version of specSTM was defined using Codensity
16:30:47 <iago> gwern, EHC would be a hell, they use lot of intermediate tools which works with non-Haskell code
16:31:00 <edwardk> jmcarthur: package ready (no real docs though)
16:31:47 <napping> a derived class applies the parent class and then extends the record further - If r1 isn't compatible with r2 then it's "abstract", otherwise it's usable
16:33:06 <napping> I've thought for a while that row-variable polymorphism and extensible records should support most of what people want to do in "dynamic" languages, especially if you don't mind tagging things with extensible variants instead of using a raw typecase
16:33:53 * hackagebot speculation-transformers 0.1 - Safe, programmable, speculative parallelism with monads.  http://hackage.haskell.org/package/speculation-transformers-0.1 (EdwardKmett)
16:34:41 <Philippa> napping: yup, definitely. I mean, I want the recursive variant for preference myself because mostly I want to extend algebras rather than objects, but same difference
16:35:16 <napping> I suppose you've seen MLPolyR - it seems like they get along pretty well, and it's not much more expensive to support both
16:35:30 <gienah> napping: just thought I'd mention that there is a paper and set of Isabelle proofs on CoreC++ which is C++ multiple inheritance
16:35:49 <napping> I think I'll avoid row concatenation for now
16:36:09 <edwardk> napping: yes, but being equirecursive it is very hard to add features to MLPolyR's basic calculus
16:37:18 <napping> edwardk: really? It seems like most things should work if you disallow recursion through foralls
16:37:20 <edwardk> the usual approach is to convert an equirecursive type into normal form and then compare those
16:37:41 <edwardk> nah, equirecursion is one of those features that just usually doesn't pay its own way. its a fairly well studied option
16:37:58 <edwardk> well, nah in the sense that yes 'most things work' but you can't do everything
16:38:03 <napping> It's quite impressive with extensible variants and records
16:38:05 <Philippa> I hadn't seen MLPolyR, no - thanks, will remember to take a look next time I care enough
16:39:10 <edwardk> its good. we based our little row-typed language here in many ways on mlpolyr, defaulting some design decisions to what they did, just because it was a proven design
16:39:28 <jmcarthur> i love how all you have to do is suggest something to edwardk and an hour later it's on hackage
16:39:32 <jmcarthur> ;)
16:39:36 <napping> One of my favorite examples in that paper is CPS conversion
16:39:54 <edwardk> you can take the variant/record duality a step farther though, the open cases can be replaced with a record of continuations
16:40:36 <edwardk> so you can annihilate a record of continuations and a variant of values (case analysis),    or a variant of continuations and a record of values. (field selection)
16:40:56 * hackagebot ReplicateEffects 0.2 - Composable replication schemes of applicative functors  http://hackage.haskell.org/package/ReplicateEffects-0.2 (MartijnVanSteenbergen)
16:41:11 <edwardk> then the value/continuation duality and record/variant duality and the operations on each are all just one primitive
16:41:18 <edwardk> jmcarthur: the api what you'd expect?
16:41:31 <jmcarthur> edwardk: pretty much exactly what i had started writing myself
16:41:48 <edwardk> jmcarthur: also, i generalized from Cont to ContT rather than write separate ContT transformers
16:42:17 <edwardk> since in the new transformers Cont r = ContT r Identity, that should work nicely
16:42:19 <jmcarthur> that is the mtl way
16:42:22 <edwardk> yeah
16:42:23 <jmcarthur> yeah :)
16:42:55 <edwardk> the funny thing was my original specSTM was based on Density, and i have a speculation 'scheduler' in reactor, so i should have spotted it =)
16:43:00 <napping> It infers an argument type like expr == <`Con of a | `App of (expr,[expr]) | `Lam of ([Var],expr) | `Var of Var>, and a result type that actually shows some invariants of the transformation
16:43:05 <edwardk> er s/Density/Codensity
16:43:08 <Philippa> edwardk: you're reminding me of Wadler's Dual Calculus, at least if I'm thinking of the right thing?
16:43:24 <edwardk> philippa: you're exactly right
16:43:44 <napping> edwardk: do you have a reference for the continuation thing?
16:43:49 <edwardk> philippa: though, i rather prefer Ben Rudiak-Gould's version
16:44:06 <napping> oh, do you rely on a negation operator or something?
16:44:08 <edwardk> napping: nah, its something i did and never published
16:44:14 <Philippa> mmm, I never did check enough of his work after the talk he gave at AH - I should do
16:44:17 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/not-not-ml/index.htm talks about value continuation duality
16:44:33 <edwardk> and gives a core calculus you could implement a language on top of
16:44:39 <napping> I'm thinking of allow row variables expressions of the form (ty) ==> (row), to mean every label in the row has to be function taking an argument of the given type
16:44:44 <edwardk> in that setting, my above statemen probably makes more sense
16:45:06 <Philippa> edwardk: how far do you reckon you'd get turning it into the flavour of easy-to-add-inference calculus I've talked to you about a few times, anyway?
16:45:28 <edwardk> philippa: row types? or explicit value continuation duality?
16:45:28 <Philippa> or should I just add it to my "things to do when bored" list?
16:45:33 <Philippa> the latter
16:45:37 <Philippa> row types are trivial
16:45:39 <edwardk> the latter is pretty easy ben's way
16:45:54 <edwardk> row types can be as hard as you want them to be, if you start doing things like unions
16:45:58 <Philippa> true
16:46:23 <Philippa> but if you just want something that works, you can borrow someone else's row typing rules and plug 'em into a standardish qualified types system
16:46:29 <edwardk> yeah
16:46:39 <edwardk> thats how i've done it in the past =)
16:46:46 <edwardk> sadly here we needed something stronger =/
16:47:33 <edwardk> ill need to get copumpkin to give a talk on how it works sometime and tape it
16:47:35 <napping> can you get a strongly-normalizing language with that sort of continuation?
16:48:25 <edwardk> sure. the version in rudiak-gould's paper just says that lambda never uses the return continuation. you can even define a form of pure type system this way
16:48:39 <Philippa> edwardk: cool. Sounds like I'd have a lot of fun at your workplace if ever it made sense for either party for me to work there
16:48:39 <edwardk> though you care about Sigma types, not Pi types.
16:49:23 <edwardk> i had a class of PTS-Sigma languages i was playing with before i fled academia
16:49:40 <edwardk> based on almost exactly that transformation
16:50:05 <napping> The other thing I've been reading recently is the Yale FLINT group's papers. All the foundational verification stuff they are doing is built around "typings" of preconditions for jumping to various heap addresses
16:50:07 <Philippa> ...remind me to talk to you sometime about what can be done to make PTS(-based) designs 'modular' in some sense?
16:50:21 <edwardk> philippa: will do
16:50:22 <Philippa> (one of my intuitions says that when you're doing inference, constraint systems are a big modularity tool...)
16:50:45 <edwardk> philippa: did you see the Jan-Willem Roorda paper?
16:50:48 <Philippa> (but then, you already know I'm not big on just doing unification and ignoring constraints as a concept outright these days)
16:50:51 <Philippa> don't think so?
16:50:52 <elliott> haskell-mode does not seem to grok quasi-quotation.
16:51:16 <jmcarthur> edwardk: btw, do you have something that you're actually using speculation in, or was it just something you wanted to write for its own sake?
16:51:17 <edwardk> it was just a summary of how to do pure type systems with case analysis and an intro tp PTS's but a nice intro for folks
16:52:01 <Philippa> oh, yes, Henk etc?
16:52:04 <edwardk> jmcarthur: i was using it to benchmark how much i could speed up a boring old parser/lexer with speculation compared to all my crazy monoidal machinery
16:52:06 <edwardk> Philippa: yeah
16:52:16 <edwardk> 'Henk 2000" ‚Äî the other Henk ;)
16:52:44 <jmcarthur> ah, parsing. that's an interesting-sounding use case
16:53:28 <edwardk> it was quite competitive. i started building a more modular alex clone, but then got bogged in feature bloat, since i insisted on doing everything unicode-correctly, etc.
16:53:36 <edwardk> and started writing all the unicode class machinery, etc.
16:53:48 <jmcarthur> lol
16:53:56 <jmcarthur> i hate it when that happens
16:53:58 <edwardk> https://github.com/ekmett/luthor hasn't been touched since july
16:54:23 <edwardk> (thanks to philippa for the name)
16:54:42 <jmcarthur> lol, i just got it
16:54:44 <jmcarthur> :)
16:55:41 <edwardk> anyways the idea was to interleave the speculation pipeline into the positional lexer, using n bytes worth of backwards context to guess a state
16:55:49 <edwardk> like the microsoft paper
16:56:02 <edwardk> i had started with alex, but the version of alex i tweaked was a horrid mess
16:56:26 <edwardk> so i wanted something more principled, and which could be used in-language as a TH quasiquoter
16:56:51 <edwardk> so you just drop it in with [$lex| ‚Ä¶ |] rather than use a separate toolchain
16:57:06 <jmcarthur> yeah that's cool that it's TH
16:58:30 <ksf> speaking about i18n and haskell...
16:58:31 <edwardk> i think most if not all of the rewriting of alex into a hierarchical namespace, the TH skeleton, etc. are done, i just got bogged down in dealing with efficiently encoding unicode classes, and class based lookups
16:58:45 <edwardk> ksf: oh yeah, i need to package up that gettext machineruy
16:58:48 <edwardk> er machinery
16:58:55 <ksf> NO DONT
16:58:58 <ksf> no gettext.
16:59:00 <edwardk> =P
16:59:02 <ksf> better not have bindings at all.
16:59:08 <edwardk> gettext works, translaters know how to use it
16:59:22 <c_wraith> "works" is a relative term
16:59:26 <edwardk> yes
16:59:43 <ksf> ...I wanted to ask whether I can recruit people to do a collossal cave remake in grammatical framework.
16:59:55 <jmcarthur> hmm... branch prediction would be a cool, simple example for speculation
16:59:58 <edwardk> i started to go down the path of something closer to the richer syntax supported by clang for error messages
17:00:06 <ksf> gettext hardly works for english, even less so for more complex grammars.
17:00:17 <edwardk> ksf: you should wait for curveship to be released then port the curveship version of collossal cave to GF ;)
17:00:47 <edwardk> ksf: hence the clang-like message support mentioned above.
17:01:16 <edwardk> i just need to add a TH quasiquoter for a small DSL to describe the clang message structure, then the result can still be spat out to gettext files, but the formatting will be clang-style
17:01:45 <edwardk> jmcarthur: hrmm
17:01:54 <ksf> ...doesn't even have to be all of collossal cave. just enough to justify creating the domain-specific abstract language.
17:02:12 <jmcarthur> assuming the conditional takes some time to compute, of course
17:02:20 <ksf> edwardk, you're reinventing the wheel.
17:03:05 <edwardk> ksf: and you aren't? =)
17:03:15 <edwardk> ksf: in my case i already have what i need working. ;)
17:03:28 <ksf> no, I'm using the language grammars actual linguists wrote for gf
17:03:29 <edwardk> ksf: so the wheel hath already been reinvented
17:03:59 <ksf> supporting more than one language?
17:04:11 <edwardk> yes. en_US and en@lolcat ;)
17:04:21 <ksf> that doesn't count.
17:04:55 <edwardk> i'm well aware of the pain of i18n, thats why i went out of my way to structure so i could at least offer something to users
17:05:02 <edwardk> without compromising my entire development cycle
17:05:15 <edwardk> i've seen too many game projects try to bolt it on post-hoc
17:05:23 <ksf> one gripe I have with gf is that it doesn't even try to express its dependent types in GADTs
17:05:23 <edwardk> for me to want to do the same thing with a compiler
17:05:51 <Tomsik> Wait, your gf is "it"?
17:06:01 <ksf> Tomsik, grammaticalframework.org
17:06:04 <edwardk> i've never really gotten all that excited about gf ;)
17:06:52 <edwardk> and i have a hard time bringing myself to want to require that everyone who works on my compiler be a linguist.
17:07:14 <j-invariant> ksf: if it tried would it succeed?
17:07:47 <j-invariant> I have a feeling like you can get all excited and encode all these strange things into GADTs then be completely unable to actually program with them
17:07:48 <ksf> j-invariant, for many things, certainly.
17:08:14 <edwardk> ksf: clearly you need to rewrite it in agda ;)
17:09:03 <edwardk> that reminds me i need to make sure my lolcale support isn't broken
17:09:17 <ksf> hmmm it can output prolog.
17:10:09 <ksf> edwardk, one doesn't need to be a linguist to use an abstract domain specific language.
17:10:27 <ksf> ...especially if one knows the domain and the combinators are in english.
17:11:41 <ksf> ...after all, you could just do the same clang thing when it comes to expressivity, but get all those linearisers in a gazillion natural languages for basically free.
17:12:13 <edwardk> ksf: yes, but having worked with such a language (in inform 7, and when looking at curveship), i find that it dramatically impedes getting stuff done.
17:13:10 <ksf> you can always chose to spew out a non-i18n message and let the translators care.
17:14:14 <edwardk> yes. the model i have now does just that. and hands off the parsing of the i18n'd message from the po files to a compile time check via template haskell (that way i can check that they all comply to the same arguments)
17:15:00 <edwardk> gf is a bit heavy of a dependency for me to want to bring it in for error messages though
17:15:37 <ksf> you don't ship the gf compiler
17:15:46 <ksf> ...just a weeny interpreter and the compiled grammar.
17:16:08 <edwardk> i ship the source to my whole compiler, so it'd come along for the ride ;)
17:17:07 <edwardk> for now my needs are met with a half dozen ad-hoc combinators
17:18:15 <ksf> the runtime is a total of 4229 lines of haskell, unstripped.
17:18:35 <ksf> ...which includes Data.Binary.
17:19:05 <ksf> and you can throw out stuff like the parser and such.
17:19:51 <mreh> how do people get nice readable unobfuscated machine code from GHC if it tacks on the runtime system?
17:20:26 <elliott>       is used in a top-level splice or annotation,
17:20:26 <elliott>       and must be imported, not defined locally
17:20:27 <mreh> I've seen blogs where they show you tail call optimised code and such
17:20:32 <elliott> is this stage restriction planned to be lift?
17:20:35 <Bynbo7> mreh: i don't believe the asm output includes the RTS code
17:20:36 <elliott> (should this q be in #ghc?)
17:20:58 <ksf> elliott, feel free to poke people.
17:21:09 * elliott pokes everyone.
17:21:16 <Bynbo7> oh my :o
17:21:23 <ksf> it definitely could be relaxed quite a lot
17:21:27 <mreh> Bynbo7: that would be the obvious inference, but I don't trust it
17:21:49 <ksf> for one, actually track dependencies instead of working on a per-module basis.
17:22:36 <ksf> but the whole thing isn't completely trivial, having to re-interpret the module after splicing etc.
17:23:18 <Bynbo7> mreh: well, whenever i've looked at the ams output of GHC, it has only ever showed me the asm of my program
17:23:22 <Saizan> mreh: such loops do not allocate or use I/O so they don't call back into the RTS
17:23:32 <Bynbo7> mreh: just use ghc-core to view the Core and asm output
17:23:36 <roconnor> @src foldl
17:23:36 <lambdabot> foldl f z []     = z
17:23:36 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:23:39 <roconnor> @src reverse
17:23:39 <lambdabot> reverse = foldl (flip (:)) []
17:27:58 <mreh> man, zipWith is applicative in disguise
17:27:59 <edwardk> ksf: anyways, i leave you to your 4229 lines, but i'll stick to my 45 lines for now ;)
17:28:26 <Bynbo7> mreh: just a different way of implementing it
17:28:49 <mreh> applicative is zipWithn!
17:29:10 <Bynbo7> > zipWith (,) [1..3] [4..6]
17:29:11 <lambdabot>   [(1,4),(2,5),(3,6)]
17:29:28 <Bynbo7> > (,) <$> [1..3] <*> [4..6]
17:29:29 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:29:44 <mreh> wrong Applicative
17:29:46 <mreh> :)
17:29:54 <c_wraith> > (,) <$> ZipList [1..3] <*> ZipList [4..6]
17:29:55 <lambdabot>   No instance for (GHC.Show.Show
17:29:56 <lambdabot>                     (Control.Applicative.Zip...
17:30:21 <j-invariant> I can't write my program in haskell so I implement a type system in scheme instead??
17:30:25 <c_wraith> @hoogle ZipList a -> [a]
17:30:25 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
17:30:26 <lambdabot> Prelude repeat :: a -> [a]
17:30:26 <lambdabot> Data.List repeat :: a -> [a]
17:30:28 <j-invariant> this is stupid I suck
17:30:34 <c_wraith> > getZipList $ (,) <$> ZipList [1..3] <*> ZipList [4..6]
17:30:35 <lambdabot>   [(1,4),(2,5),(3,6)]
17:31:44 <edwardk> mreh: the relationship between the applicative for list and zipping is explored in my streams package ;)
17:31:45 <mreh> wouldn't a zipList just show as "ZipList [1,2.."
17:32:06 <c_wraith> evidently there's no Show instance for it, though
17:32:14 <edwardk> yeah
17:32:26 <edwardk> Show instances are missing for the Control.Applicative stuff and transformers, etc.
17:32:32 <mreh> bum
17:32:42 <edwardk> so are lots of useful instances
17:32:50 <c_wraith> A lot of the transformers are functions inside.  Those aren't the easiest things to Show.
17:33:04 <edwardk> c_wraith: yes, but not all. the ones that aren't can be Showable
17:33:10 <edwardk> Identity comes to mind
17:33:21 <edwardk> it rather frustrates me that Data.Functor.Identity is missing so many instances
17:33:34 <c_wraith> Oh.  Yeah, the lack of instances for Identity has bit me before
17:33:49 <mreh> you can always make your own
17:33:50 <edwardk> guess its time for another libraries@ proposal
17:33:50 <kyagrd> > 2222222222222222.111111111111111111111111111111111111111111111111111111111111111e10000000000000000000t know how fully it covers it though
17:33:57 <lambdabot>   mueval: ExitFailure 1
17:33:57 <lambdabot>  mueval-core: Time limit exceeded
17:34:03 <edwardk> mreh: until i write a library that other people will import
17:34:09 <edwardk> mreh: that is a VERY unsatisfying solution
17:34:39 <kyagrd> @type 2222222222222222.111111111111111111111111111111111111111111111111111111111111111e100000000000000000
17:34:40 <mreh> yeah, I know, but the bullet
17:34:46 <mreh> bite*
17:34:54 <lambdabot> thread killed
17:35:16 <Bynbo7> > 2222222222222222.111111111111111111111111111111111111111111111111111111111111111e10000000000000000000 :: CReal
17:35:22 <mreh> I double anyone will use my monadic pretty print, but it's only got three constructs, and I use it all over for debugging
17:35:24 <lambdabot>   mueval: ExitFailure 1
17:35:24 <lambdabot>  mueval-core: Time limit exceeded
17:35:30 <mreh> doubt*
17:35:31 <kyagrd> The behavior of GHC when large decimal like things come in is quite strange
17:35:34 <mreh> jesus, I'm tired
17:35:43 <edwardk> well, i can't write them in my own code, or anyone else who ran into the same problem will collide with my instances, so the only solution is to use wrappers or write my own classes so the instances aren't orphaned
17:35:53 <Bynbo7> mreh: got the code somewhere?
17:35:54 <edwardk> mreh: that works great because its your own class
17:36:02 <edwardk> mreh: not so great when you need a Data instance
17:36:08 <mreh> Bynbo7: i'll upload to hackage if you like
17:36:12 <kyagrd> @type 222.111e100
17:36:14 <Bynbo7> go for it
17:36:14 <lambdabot> forall t. (Fractional t) => t
17:36:29 <mreh> it's called Pretty, people will hate me for stealing that package name
17:36:46 <mreh> but the monad is called that
17:36:56 <edwardk> mreh: yeah, i think i have a half dozen classes named Pretty that look like show but use Doc or what have you ;)
17:37:18 <kyagrd> Can't understand why it is so slow, unlike large Integral type literals
17:37:26 <mreh> acutally the class is called Printable
17:37:36 <kyagrd> @type 239412340213481290348-102348012348901238402134812341234012347123412341234871234781234712347812347821347821347182341234
17:37:40 <lambdabot> forall t. (Num t) => t
17:37:41 <kuffaar> http://siyobik.info/pastebin_download.php?id=566 <- trying to use Network and Control.Concurrent.forkIO and such - it just prints "Waiting for a new connection" but it never gets to the "New connection" part and when I try to connect with telnet it just says connection refused. What am I doing wrong here?
17:37:46 <mreh> pretty awful name hum
17:38:08 <edwardk> kufaar: are you running with the threaded runtime?
17:38:14 <kuffaar> Ah.
17:38:25 <kuffaar> edwardk can you even do that with ghci?
17:38:40 <edwardk> gotta run. i leave you in capable hands
17:38:44 <edwardk> sorry
17:38:48 <Bynbo7> kuffaar: firstly, you generally use withSocketsDo in main: main = withSocketsDo $ do ...
17:38:53 <Saizan> Pretty classes are outdated, we should have Syntax classes that define invertible parsers now!
17:39:29 <mreh> right away sir
17:39:36 <mreh> (what could he mean?)
17:40:00 <Bynbo7> Saizan: you mean the same code can be used to pretty print something, and parse it?
17:40:03 <kuffaar> Bynbo7 right, I could move it further out
17:40:06 <Bynbo7> that's a pretty awesome idea
17:40:10 <kuffaar> But I don't even have a main atm
17:40:16 <Bynbo7> yeah
17:40:32 <kuffaar> So do you actually need to use ghc instead of ghci for threaded stuff?
17:40:37 <Bynbo7> have you tried running ghci with +RTS -N2 -RTS?
17:40:50 <Bynbo7> i seem to remember threading working just fine in ghci
17:40:56 <Saizan> http://portal.acm.org/citation.cfm?id=1863525
17:41:15 <kuffaar> Bynbo7 wait in this case it doesn't even fork until after the accept
17:41:18 <elliott> how does one get a gensym in template haskell?
17:41:19 <Saizan> mreh, Bynbo7: ^^^
17:41:37 <aavogt> elliott: newName?
17:41:42 <Evious> Is it possible to use Haddock without cabal (when starting a project) from the command line?
17:41:42 <Bynbo7> Saizan: ta :)
17:41:44 <j-invariant> Is it bad style to have  if x /= y then error "IMPOSSIBLE" else ...  on every second line of my program?
17:41:56 <Bynbo7> "Buy this article" >_____________________________________________<
17:42:23 <Bynbo7> j-invariant: uh yes
17:42:32 <c_wraith> j-invariant: If you have two values that are supposed to be the same, why not have one value?
17:42:40 <Bynbo7> sounds like a good place to use the Maybe monad
17:42:46 <j-invariant> c_wraith: haha
17:43:01 <Bynbo7> i don't think it was entirerly a joke
17:43:03 <c_wraith> that wasn't really a joke.
17:43:05 <Cale> kyagrd: Because it has to convert from Rational
17:43:22 <elliott> aavogt: ah, is that it?
17:43:59 <aavogt> elliott: I only have a vague idea of what gensym is
17:44:10 <elliott> aavogt: a symbol to use in a macro that cannot clash with anything else
17:44:19 <Saizan> Bynbo7: google scholar should be able to find free versions
17:44:21 <elliott> i.e., a symbol that has no syntactical representation in haskell code
17:44:27 <elliott> i know th can do this, i just dunno how
17:44:39 <aavogt> elliott: ok, then newName is right
17:44:39 <j-invariant> c_wraith: okay so maybe I am doing something stupid then, I'll try and ask a specific question about it incase someone knows a trick I don't
17:44:47 <elliott> aavogt: yay
17:45:10 <kuffaar> <Bynbo7> have you tried running ghci with +RTS -N2 -RTS?
17:45:14 <kuffaar> What does that even mean?
17:45:20 <kuffaar> How do you set those?
17:45:28 <kuffaar> :set doesn't work for those from what I can tell
17:45:32 <Bynbo7> that tells the RTS to use two threads: ghci foo.hs +RTS -N2 -RTS
17:45:41 <kuffaar> Ah, commandline arguments
17:45:47 <Bynbo7> yeah that's an option you'll need to set when calling ghci
17:45:55 <Bynbo7> you can't really change runtimes while it's running ;)
17:47:06 <kuffaar> RTS = runtime thread system?
17:47:09 <kuffaar> I don't get the N part
17:47:14 <c_wraith> runtime system
17:47:16 <Bynbo7> runtime system
17:47:28 <c_wraith> N is the argument to tell it to use multiple native threads
17:47:35 <c_wraith> N = native, in that case
17:47:37 <Bynbo7> -N2 says use two hardware threads to run you're program's haskell threads
17:47:55 <aristid> kuffaar: it's all documented somewhere :)
17:47:57 <kuffaar> Why doesn't it just spawn a new thread for each thread in the prgoram
17:48:16 <aristid> because that would be inefficient
17:48:19 <Zao> kuffaar: Because it's generally not needed.
17:48:19 <c_wraith> OS threads are a lot more expensive than haskell threads
17:49:32 <Bynbo7> kuffaar: because many haskell programs have thousands of haskell threads, which are multiplexed onto a limited number of hardware threads
17:49:41 <c_wraith> Haskell threads are something ridiculous like only 13 extra machine words of memory per thread.
17:49:49 <Bynbo7> if each haskell thread were a pthread, the system would grind to a halt very quickly
17:49:51 <c_wraith> There's no way OS threads will ever get near that.
17:49:51 <kuffaar> Usually the OS does that job
17:50:06 <aristid> not as efficiently
17:50:23 <Bynbo7> kuffaar: do you know anything about erlang?
17:50:26 <Tomsik> kuffaar: you know what's the cost of a mere syscall alone is?
17:50:32 <Tomsik> huh huh HUH?
17:50:46 <kuffaar> Bynbo7 yeah a bit
17:50:51 <kuffaar> Tomsik: It varies
17:50:58 <kuffaar> But context switches are expensive
17:51:03 <j-invariant> Okay so here is my problem: I want to implement a languag ewith a more expressive type system in haskell
17:51:03 <Bynbo7> kuffaar: OS threads are exteremely expensive compared to haskell's green/userlevel threads
17:51:23 <j-invariant> But my type checker cannot (as far as I am aware) produce an object for which there is a well typed & total evaluator
17:51:24 <Tomsik> j-invariant: you mean, you want something more than turing-complete? :p
17:51:25 <kuffaar> Why do you think Sun stopped using green threads in favour of OS threads?
17:51:41 <Zao> kuffaar: Brief overdose of drugs?
17:51:50 <c_wraith> Because things are very different in a language that has mutability by default.
17:52:13 <Bynbo7> kuffaar: well then you'd know that one of the main ways you use erlang is just great a thread for practically everything you need to compute. so you end up with thousands of threads (this is a bit of an exageration)
17:52:33 <c_wraith> Don't underestimate the importance of immutable data in simplifying threading systems.
17:52:55 <Bynbo7> so the erlang system is designed to cope with thousands of userlevel threads. haskell's threads are even more lightweight ;)
17:53:13 <kuffaar> My intuitive understanding is that with green threads you get nowhere near the granularity and the scheduling constraints provided by the OS scheduler
17:53:39 <kuffaar> I mean what do you do, run Sleep(0) in a loop and call SuspendThread SetThreadContext ResumeThread all the time?
17:53:42 <Bynbo7> kuffaar: there's a very good reason my program is #1 here: http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
17:53:59 <jmcarthur> kuffaar: in the language shootout, the C entry had to include its own green thread library just to be competitive with haskell
17:53:59 <Evious> Bynbo7, Haskell's threads are more light-weight than Erlang? Really? o.O
17:54:08 <Bynbo7> Evious: yes
17:54:22 <jmcarthur> Evious: they are, but they have some advantages over ghc's threads too, right now
17:54:23 <c_wraith> well.  GHC's are. :)
17:54:33 <jmcarthur> Evious: each thread in erlang has its own GC, for example
17:54:43 <Bynbo7> c_wraith: uh, yes. but to me, haskell == GHC ;)
17:54:43 <Evious> Gah, don't raise my hopes dude. I don't want to try and port an existing Erlang system into Haskell, only to realize that getting Haskell to scale that way is a pain. :)
17:54:55 <jmcarthur> haskell scales very well, actually
17:54:56 <aristid> jmcarthur: which is a pretty big advantage i would say
17:55:02 <jmcarthur> erlang is a bit easier to make distributed right now, though
17:55:06 <aristid> (each thread having its own GC)
17:55:14 <jmcarthur> aristid: marlow is working on this, iirc
17:55:20 <Bynbo7> Evious: distributing haskell is more difficult than erlang. if you need high performance multi-threading, it's the language to go with though
17:55:26 <c_wraith> yeah, I think it's scheduled for inclusion in next year's GHC release
17:55:26 <jmcarthur> oh, no, he's doing a concurrent gc
17:55:53 <aristid> jmcarthur: which is also nice, but it doesn't fully solve the "stop the world" problem
17:56:02 <jmcarthur> c_wraith: is it per thread gc or concurrent gc? i thought it was the latter
17:56:09 <jmcarthur> aristid: not *fully*, but quite a bit
17:56:15 <c_wraith> jmcarthur: I thought he was creating nursery generations per thread
17:56:22 <napping> jmcarthur: I'm pretty sure it's not fully concurrent
17:56:25 <Bynbo7> i think a gc per thread only works when you're pretty sure all programs are going to be using lots of small threads, which a lot of haskell programs don't
17:56:27 <jmcarthur> ah, so both then
17:56:38 <kuffaar> Bynbo7: Btw, the thread options didn't do anything
17:56:46 <napping> Bynbo7: it would be a GC per core, not per thread
17:56:49 <kuffaar> It still appears to be stuck on accept
17:57:00 <Bynbo7> napping: that makes more sense in haskell's case
17:57:04 <kuffaar> I'm connecting from 127.0.0.1
17:57:13 <kuffaar> Maybe I should debug it haha
17:57:19 <Saizan> kuffaar: did you compile with -threaded ? also, did you paste the code?
17:57:26 <kuffaar> Saizan: I used ghci
17:57:26 <sm> struggling to factor out the last two lines of https://gist.github.com/780616 .. any tips ?
17:57:32 <kuffaar> Saizan yes I pasted it
17:57:40 <kuffaar> <kuffaar> http://siyobik.info/pastebin_download.php?id=566 <- trying to use Network and Control.Concurrent.forkIO and such - it just prints "Waiting for a new connection" but it never gets to the "New connection" part and when I try to connect with telnet it just says connection refused. What am I doing wrong here?
17:57:41 <Bynbo7> kuffaar: i don't think using sequence_ . repeat is a good way to do this, i could be wrong
17:57:53 <kuffaar> Bynbo7 I just copy pasted most of this from an example
17:57:59 <kuffaar> http://hackage.haskell.org/packages/archive/network/2.2.1/doc/html/src/Network.html
17:58:05 <kuffaar> From the Network package
17:58:07 <kuffaar> Which I am using
17:58:16 <kuffaar> Oh wrong link
17:58:22 <kuffaar> Also screw that for using INADDR_ANY
17:58:32 <kuffaar> http://www.haskell.org/pipermail/haskell/2003-April/011580.html unrelated
17:58:38 <kuffaar> echoserver.hs:
17:58:43 <aristid> sm: you cold factor the c : in front of the case?
17:59:30 <sm> aristid: thx, true but I'm still tripping up on how to get that ma out
17:59:52 <j-invariant> Anyone know any nice way to deal with this? http://hpaste.org/43048/title -- I don't want to use type level numbers because my real case would be general polynomials and it gets crazy putting everything into the type system
18:00:15 <j-invariant> I put an example of things working out nicely, then I put th esecond example, with modular arithmetic.. where I can't see how to do it
18:00:16 <aristid> sm: right, can you show the type definition of Amount and referenced types? :)
18:00:40 <sm> I thought Just (_ ma) might work, but no
18:00:41 <sm> http://joyful.com/repos/hledger/hledger-lib/Hledger/Data/Types.hs
18:00:43 <aristid> :t maybeToList
18:00:45 <Saizan> sequence_ . repeat is fine
18:00:55 <lambdabot> forall a. Maybe a -> [a]
18:02:05 <kuffaar> Bynbo7 I mean do you see any reason why it should fail like this/
18:02:15 <kuffaar> I mean this is even failing before any threading takes place
18:02:23 <Tomsik> @type cata
18:02:24 <aristid> sm: i can't find UnitPrice and TotalPrice
18:02:25 <sangamon> Weakly-directed flail for help: I'd like to write, for OS X, a global keybinding manager (to supersede the 3 different tools I'm using right now).  I'd like to write it in Haskell.  Issues include: 1) HOC (Haskell-Objective-C) looks barely maintained; 2) the several articles I've read about how to do this in Objective-C all seem to suggest the Carbon API they use is deprecated; 3) none of the 3 tools I'm looking to replace are o
18:02:26 <sangamon> source, I have little experience with OS X development, and no idea where to look for the stuff I'll need to do this.  Has anybody written a working native OS X application in Haskell?  Was it clean enough to be worth it?
18:02:33 <lambdabot> Not in scope: `cata'
18:03:39 <sm> aristid: sorry, pushed now
18:04:04 <Bynbo7> kuffaar: yeah i can't see why it would fail. what port are you using?
18:04:12 <kuffaar> 80
18:04:30 <sangamon> (sorry, I'm also comprehensively ignorant of IRC etiquette)
18:05:10 <kuffaar> I also tried other ports like 1111 etc all the same
18:05:20 <Saizan> kuffaar: maybe the ip is the problem
18:05:38 <kuffaar> Saizan: Network is hard set to INADDR_ANY
18:05:40 <kuffaar> i.e. 0
18:05:43 <aristid> sm: write a toMixedAmount function for Price?
18:05:43 <sm> aristid: thx, got to run, will read any ideas you might have. Not often I can't figure out how to refactor two adjacent identical expressions :)
18:05:50 <kuffaar> So it would take any IP
18:06:04 <sm> ok, sounds good
18:06:33 <kuffaar> I'd have to use the lower BSD interface to even get it to work with 127.0.0.1 it seems
18:06:40 <aristid> sm: i think that should do already. also, see you :)
18:06:41 <kuffaar> I mean, to restrict it to local connections
18:06:46 <kuffaar> Which is what I ultimately intend to do
18:07:41 <elliott> <Tomsik> j-invariant: you mean, you want something more than turing-complete? :p
18:07:46 <elliott> what has this got to do with a more expressive type system?
18:08:40 <Tomsik> Not sure
18:09:23 <napping> kuffaar: that code works for me
18:09:29 <kuffaar> :(
18:09:42 <napping> what do you see?
18:09:42 <kuffaar> napping did you ghc or ghci it?
18:09:45 <napping> ghc
18:09:51 <kuffaar> Hmm I used ghci only
18:09:56 <kuffaar> I guess I should compile it
18:10:06 <napping> it seems the echoserver process prints out what you type into the echoclient process
18:10:24 <napping> how did you use ghci?
18:10:27 <kuffaar> Huh :o it's not an echo server
18:10:46 <kuffaar> napping I suppose you didn't even use my code :[
18:10:57 <napping> No, I didn't see a link to your code
18:10:57 <kuffaar> http://siyobik.info/pastebin_download.php?id=566
18:11:05 <napping> but the code in the message you linked seems to work, even from ghci
18:11:35 <napping> I don't know about windows, but network stuff seems to work in ghci on linux
18:11:55 <napping> About the only thing that doesn't is GTK, because of some event loop stuff
18:13:38 <kuffaar> napping but what about the code I just linked :(
18:13:40 <napping> are you sure you have permissions to listen on your port?
18:13:48 <kuffaar> Windows has no restrictions for that
18:13:55 <napping> it works fine for me
18:13:56 <kuffaar> Any non admin can bind anything by default
18:14:00 <kuffaar> Wtf :/
18:14:22 <kuffaar> Are you on Linux?
18:14:29 <napping> yes, I am for now
18:15:05 <napping> what are you trying to connect with, and what goes wrong?
18:15:18 <kuffaar> telnet
18:15:21 <kuffaar> Connection refused
18:15:55 <lars9> anyone feels haskell's module is kind of awkward? it works similar to C's header file, not as convenient as Java/C#'s package
18:16:32 <j-invariant> lars9: it sucks
18:16:43 <napping> lars9: what do those do? I thought it was pretty similar to at least Java-style packages
18:16:52 * Maxdamantus sees it as more similar to Java's system (afaik of Java)
18:17:06 <napping> better than C - at least it's not textul inclusion, but not nearly as nice as ML
18:17:47 <kuffaar> I compiled it with -threaded
18:17:53 <lars9> napping: for example, two modules can not import each other
18:17:55 <kuffaar> Still no go on port 2222
18:18:19 <napping> lars9: GHC needs .hi-boot files for that
18:18:33 <napping> recursive modules are supposed to be supported, though
18:18:49 <kuffaar> napping: putStrLn $ "New connection: " ++ hostName ++ ":" ++ (show portNumber)
18:18:51 <napping> kuffaar: try without
18:18:55 <kuffaar> That actually gets printed for you?
18:18:59 <lars9> so it's still like header file, not like Java's package, package is more like a naming system
18:18:59 <geheimdienst> napping, by recursive you mean A imports B, B imports C, C imports A?
18:19:38 <napping> geheimdienst: yeah, that's supposed to work, but GHC doesn't do it automatically
18:19:54 <geheimdienst> okay
18:19:57 <napping> kuffaar: when a new connection comes, yes
18:20:37 <napping> kuffaar: did you try to compile without -threaded?
18:20:43 <kuffaar> Nope sec
18:20:54 <napping> It may be winsock is not threadsafe
18:21:04 <kuffaar> Same thing
18:21:28 <kuffaar> napping lol nah that's not it
18:21:35 <napping> does windows have something like netstat?
18:21:41 <lars9> i mean, java's System.IO.xxx is a hierarchy naming space, but haskell's Data.List has nothing to do with Data, just two independent names
18:21:45 <kuffaar> Screw it, I'm going to try it on Linux
18:22:31 <cdsmithus> kuffaar: If you're using sockets on Windows, remember to start your application with withSocketsDo.  Dunno if that's the issue, but it's something that is often a problem for sockets with Windows.
18:22:41 <napping> lars9: they are related about as much as in java - Data.List maps to Data/List.hs, etc
18:22:49 <kuffaar> cdsmithus: http://siyobik.info/pastebin_download.php?id=566
18:23:38 <cdsmithus> Okay, you got that then. :)
18:23:42 <lars9> napping: nah, that's nothing to do with namespace
18:24:22 <kuffaar> Listening on port 2222
18:24:22 <kuffaar> Waiting for a new connection
18:24:22 <kuffaar> New connection: localhost.localdomain:39374
18:24:25 * kuffaar facepalm
18:24:27 <napping> lars9: the actual GHC package mechanism lets you make private stuff shared between all modules in a package but not publicly visible
18:24:32 <kuffaar> It works in my Linux VM right awasy
18:24:36 <kuffaar> Now this just sucks :[
18:24:36 <aristid> kuffaar: relax.
18:24:40 <napping> kuffaar: sounds like time for a bug report
18:24:48 <kuffaar> Now this just sucks :[
18:24:49 <Philippa> cdsmithus: hell, do it everywhere, but hey
18:24:51 <lars9> napping: if module is hirarchy namespace system, we should be able to import each other in two modules
18:24:57 <kuffaar> Woops that was meant for my shell haha
18:25:02 <lars9> and do things like import A.B.* etc
18:25:25 <napping> a plain import A.B  already brings in everything defined in B
18:25:36 <aristid> cdsmithus: couldn't the GHC runtime take care of initialising windows sockets if it's such a big problem?
18:25:46 <cdsmithus> aristid: Apparently not?
18:25:50 * cdsmithus shrugs.
18:26:03 <napping> and modules importing each other is something the report claims should work, but GHC doesn't bother to implement unless you manually copy some type signatures to a special interface file
18:27:01 <napping> I think it's pretty similar to Java, all in all, except for the hierarchical namespace not being tied strictly to the package organization
18:27:02 <kuffaar> aristid cdsmithus: Usually other implementations do this on their own
18:27:21 <kuffaar> I always coded it like that, too
18:27:25 <kuffaar> There's no reason not to
18:27:25 <lars9> napping: oh, GHC didn't do what the report specified?
18:27:49 <napping> no
18:27:53 <kuffaar> Can't say I like this network library much
18:28:33 <napping> wait, are you using plain Network?
18:28:38 <kuffaar> Sure
18:29:02 <napping> I usually use Network.Socket
18:29:20 <cdsmithus> Network is easier, though, if it does what you want.
18:29:34 <kuffaar> napping that's the lower level interface, right?
18:29:45 <kuffaar> I will have to use that anyways to make it stop using INADDR_ANY
18:29:51 <napping> a little bit
18:30:03 <cdsmithus> And if your complaint is about needing withSocketsDo, then Network.Socket does, too.
18:30:31 <lars9> napping: oops, that's so import
18:31:10 <napping> lars9: Is C# much nicer?
18:32:00 <lars9> s/import/important/
18:33:13 <napping> well, withScoketsDo is certainly a no-op on Linux
18:33:14 <lars9> i just realized missing the 'ant' makes it sound like satirizing, but it's not supposed to.
18:33:34 <napping> I thought you meant literal "import"
18:33:51 <napping> like, valley girl accent
18:34:28 <napping> It's the ML family that really has much nicer module systems
18:34:38 <napping> well, Functors
18:34:39 <lars9> i meant recursive importing is very convenient and very common in java/c#
18:35:07 * kuffaar debugging Windows Haskell binary in OllyDbg
18:37:03 <kuffaar> bind returned 0 alright and the port it was called on was correct, too
18:38:03 <napping> lars9: well, they are object oriented
18:38:16 <kuffaar> address family is 0x1700 huh
18:38:19 <kuffaar> That looks odd
18:38:26 <kuffaar> Isn't it supposed to be 0x0002?
18:39:10 <napping> Do you have MSDN documentation?
18:39:13 <kuffaar> AF_INET?
18:39:16 <napping> maybe they use weird codes
18:39:18 <kuffaar> http://msdn.microsoft.com/en-us/library/ms740496%28v=vs.85%29.aspx
18:39:26 <kuffaar> Nah it should be identical afaik
18:39:43 <napping> well, please report a bug
18:39:49 <napping> it sounds like something is pretty broken
18:41:43 <kuffaar> I can't deal with this, I should just quit Haskell, this is too frustrating
18:43:06 <cdsmithus> kuffaar: are you still using GHC 7?  If so, before you give up, you might take the advice you've been getting for days, and use the released version of the Haskell platform.
18:43:15 <kuffaar> :|
18:43:31 <kuffaar> I hate such version gaps
18:43:49 <mm_freak> kuffaar: my IPv4 provider was responsible
18:44:12 <kuffaar> mm_freak for what?
18:44:25 <mm_freak> kuffaar: oh, i thought you meant because of my disconnects
18:44:46 <mm_freak> i don't see your IP address, so i can't tell =)
18:44:59 <kuffaar> Why don't you see my IP address :'(
18:45:11 <mm_freak> set yourself -x (i think)
18:45:19 <kuffaar> I'm -x
18:45:26 <kuffaar> I'm totally exposed
18:45:32 <mm_freak> remove all modes you don't understand =)
18:45:48 <mm_freak> if it still doesn't work, then it's because of freenode reverse-resolving your IP address
18:45:49 <kuffaar> You are just being technologically illiterate, you walked into a trap :'(
18:45:50 <napping> Looks like I'll just have to start installing all my compilers myself
18:46:00 <kuffaar> If what doesn't work?
18:46:17 <kuffaar> mm_freak my code works in ghc 6 on Linux in a VM
18:46:18 <napping> Distributions just seem to be a bit slow about updating
18:46:35 <kuffaar> napping what distro are you on?
18:46:40 <napping> O'Caml 3.12 adds a lot of significant stuff
18:46:50 <kuffaar> Arch generally has the newest binaries, I think Gentoo is the fastest though
18:46:51 <napping> some random ubuntu on this machine
18:46:56 <mm_freak> kuffaar: there is a reverse DNS entry for your address
18:46:58 <kuffaar> Ew :[
18:47:03 <kuffaar> mm_freak yeah
18:47:28 <kuffaar> At least for this one
18:47:39 <gienah> gienah: I like gentoo
18:47:46 <napping> Looks like O'Caml finally decided to allow annotating polymorphic types!
18:50:01 <kuffaar> mm_freak: You can resolve my hostname just fine, it still exists and points to the address I connected from, I promise!
18:50:08 <kuffaar> You can get my IP!
18:50:19 <napping> I guess Haskell eventually convinced them complete type inference isn't absolutely required
18:50:39 <kuffaar> UNIX nslookup and dig default options just suck :(
18:51:26 <cdsmithus> Them too?  Well, I suppose one of these days, you'll find *something* you don't think sucks. :(
18:51:30 <kuffaar> I'm sorry, I just love bothering people with AAAA only handles
18:52:21 <kuffaar> [void@graham Veles]$ nslookup haskell.2011.hk: *** Can't find haskell.2011.hk: No answer
18:52:43 <kuffaar> [void@graham Veles]$ dig haskell.2011.hk ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0
18:52:46 <kuffaar> I mean those
18:52:51 <kuffaar> Because that's just weak
18:53:27 <kuffaar> Even Windows nslookup handles it without explicitly specifying AAAA
18:55:24 <napping> kuffaar: then you might prefer "host"
18:56:15 <mm_freak> kuffaar: i know‚Ä¶  that's from where i know that you have an RDNS entry ;)
18:56:21 <mm_freak> but mine is still better =P
18:56:47 <kuffaar> affe sounds like German
18:57:04 <kuffaar> Anyways, I just discovered something funny
18:57:11 <napping> did the debugger show anything interesting?
18:57:18 <kuffaar> It might be passing AF_INET6 to bind
18:57:22 <kuffaar> Instead of AF_INET
18:57:29 <kuffaar> telnet ::1 2222 works.
18:57:33 <kuffaar> telnet 127.0.0.1 2222 fails
18:57:38 * kuffaar scratches head
18:57:44 <napping> Wow, that's funny
18:58:11 <napping> Try Network.Socket
18:58:36 <napping> Is that how AF_INET is defined in your system headers?
18:59:11 <napping> because that's where network gets the constatns from (well, on whatever machine where it was compiled)
18:59:15 <kuffaar> AF_INET6 is defined to 23 I think
18:59:22 <kuffaar> And the first two bytes were 17 00 in OllyDbg
18:59:29 <kuffaar> On the breakpoint for bind
18:59:32 <napping> right
18:59:38 <kuffaar> And 0x17 is 23
18:59:43 <kuffaar> But the byte order is wrong
18:59:51 <napping> that's little endian
18:59:51 <kuffaar> It's a 16 bit value in big endian
18:59:58 <napping> oh, it is big endian?
19:00:06 <kuffaar> napping: The functions take network byte order
19:00:07 <kuffaar> il.e
19:00:11 <kuffaar> i.e. big endian
19:00:16 <napping> oh, that would do it
19:00:20 <kuffaar> Windows implements the BSD sockets to some degree
19:00:30 <kuffaar> No, that would not do it, it's still reverse, haha
19:00:37 <kuffaar> If it were Little Endian it would work
19:00:56 <napping> Well, it's not going over the network
19:00:59 <kuffaar> Anyways, it still says Waiting for a new connection
19:01:16 <napping> somehow it's passing AF_INET6, and it's only listening on ::1
19:01:18 <napping> that makes sense
19:01:41 <cdsmithus> I don't think AF_INET6 is typically passed in network order, though it's been a few years since I've done sockets in C.
19:01:41 <kuffaar> Whereas the telnet client says connection established
19:01:45 <kuffaar> And I can flood it with stuff
19:02:17 <kuffaar> "The sockaddr structure varies depending on the protocol selected. Except for the sin*_family parameter, sockaddr contents are expressed in network byte order."
19:02:29 <kuffaar> Ohh but this might actually be sockaddr_in6 then
19:02:30 <napping> https://github.com/haskell/network/blob/master/Network/Socket.hsc
19:02:52 <kuffaar> #if defined(IPV6_SOCKET_SUPPORT)
19:03:05 <napping> It uses getAddrInfo
19:03:52 <cdsmithus> Right, "except for sin*_family", which is where AF_INET6 goes.  so that's still host order, which is little endian for you, hence yes, it really is passing in AF_INET6
19:04:33 <kuffaar> But even when using IPv6 locally, it's still not working, haha
19:05:12 <kuffaar> The Haskell program is still not printing anything on accepting the connection
19:05:18 <kuffaar> Although it appears to be accepted
19:06:04 <cdsmithus> Try hSetBuffering handle NoBuffering on the handle?  Not sure what the default buffering is
19:06:37 <cdsmithus> Oh wait, you're not reading anyway
19:06:40 <cdsmithus> So never mind
19:08:18 <kuffaar> At first I was wondering if it was some issue with lazy IO haha
19:08:27 <kuffaar> But I do print the address right after that
19:08:40 <napping> well, the terminal is line buffered by default (at least on Linux)
19:08:48 <napping> so putStr instead of putStrLn might hide output
19:09:02 <kuffaar> But I do use putStrLn :p
19:10:07 <napping> where is that code again?
19:10:24 <kuffaar> http://siyobik.info/pastebin_download.php?id=566
19:17:12 <kuffaar> Wtf one dying instance was running in the background
19:17:20 <kuffaar> I guess that one was getting the connections
19:17:52 <kuffaar> Waiting for a new connection
19:17:53 <kuffaar> New connection: erdos:5246
19:17:53 <kuffaar> Waiting for a new connection
19:17:57 <kuffaar> Amazing stuff.
19:18:33 <kuffaar> So uh why can you listen on the same port twice...?
19:18:47 <kuffaar> Shouldn't it be throwing an exception?
19:19:09 <napping> It's a server socket
19:19:12 <napping> that's how it's supposed to work
19:19:21 <kuffaar> What? No
19:19:29 <kuffaar> napping: BSD bind returns < 0
19:19:34 <kuffaar> When the port is already bound
19:19:45 <monochrom> but you said "listen twice"
19:20:06 <kuffaar> Well for the second one the bind should obviously fail
19:20:23 <napping> I suppose
19:20:29 <monochrom> eh? do you want to say "bind twice"?
19:21:00 <kuffaar> monochrom: Application 1 calls bind on port p, bind returns 0
19:21:04 <kuffaar> Application 1 is still running
19:21:13 <kuffaar> Application 2 is launched and calls bind on port p
19:21:13 <napping> kuffaar: but you can call listen multiple times, yes?
19:21:17 <kuffaar> Bind now returns -1
19:21:49 <kuffaar> And I'd expect some error condition to occur in my Haskell program
19:22:25 <monochrom> ok then should err
19:22:32 <kuffaar> This is odd, I checked in Olly and it actually returns 0
19:22:35 <kuffaar> I don't grasp why.
19:23:08 <napping> well, it will be a non-blocking socket
19:23:12 <napping> maybe that has something to do with it?
19:24:16 <kuffaar> I don't see why it would hm
19:24:43 <napping> *** Exception: bind: resource busy (Address already in use)
19:24:48 <Bynbo7> hmm, can you pattern match on ByteStrings if you use OverloadedStrings?
19:25:47 <kuffaar> napping: :(
19:26:06 <kuffaar> In my case the new program simply sees no actino
19:26:35 <monochrom> application 2 aborts in linux
19:27:14 <kuffaar> As it should
19:27:24 <napping> is getaddrinfo returning a different address?
19:27:33 <kuffaar> napping I was just thinking about that
19:27:45 <kuffaar> BPing bind in app 2
19:28:02 <napping> plain Network is a bit too magic for my taste
19:28:18 <napping> if you used Network.Socket you could print out the returned AddrInfo options and such
19:28:27 <kuffaar> It's still 17 00 08 ae in bind hmm
19:28:38 <kuffaar> Wait where was the address
19:28:55 <kuffaar> Still 00 00 00 00 ...
19:29:58 <kuffaar> napping well it does give you a Network.Socket
19:30:11 <kuffaar> I'll check it out tomorrow, this is too frustrating, going to sleep
19:30:42 <napping> getting the sockets up is always a bit of trouble for me
19:30:47 <napping> the threads are the fun part
19:36:58 * hackagebot elf 0.23 - Parser for ELF object format.  http://hackage.haskell.org/package/elf-0.23 (ErikCharlebois)
20:16:10 <robinhoode> Hate to say it but writing too much software can turn your math brain into mush.
20:18:04 <geheimdienst1> robinhoode: yeah, it's called pragmatism :)
20:20:33 <robinhoode> On the other hand, trying to write software after loads of math seems awkward and tedious...
20:21:22 <Kegan> good thing the mind is so malleable, eh? and conditions itself to stimuli so efficiently
20:22:01 <nettok> So Haskell is programming, mathematics or both?
20:22:24 <Adamant> all programming is both.
20:23:05 <djahandarie> roconnor, Cale, does one of you go to University of Toronto or remember who goes to it in this channel?
20:25:17 <copumpkin> monochrom
20:25:21 <copumpkin> iirc
20:25:46 <djahandarie> Ooh even better, since he's been a grad student there for awhile I think
20:41:43 <ivanm> *sigh* my usage of OverloadedStrings along with a custom class that has both String and Text instances is leading to ambiguous type variable errors :(
20:42:26 <kmc> a harrowing cautionary tale
20:44:07 <ivanm> heh
20:44:23 * ivanm is pondering whether to just add explicit T.Pack values in there
21:07:05 <PerfM> HI THERE
21:07:10 <PerfM> YAAAY!
21:07:10 <PerfM> LETS ALL BE FRIENDS!
21:07:34 <Bynbo7> o.O
21:11:43 <PerfM> Okay, idle fagtrons
21:11:49 <cdsmithus> Admin?
21:11:49 <PerfM> dont wanna be friends?
21:11:50 <PerfM> effing rude bros
21:11:52 <kmc> this will end well
21:11:57 <PerfM> I hope soo
21:12:05 <PerfM> cause it started pree effing bad
21:12:08 <kmc> @where ops
21:12:09 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
21:12:21 <geheimdienst> perfm, do you have a question on haskell?
21:12:34 <PerfM> I'm sorry?
21:12:40 <PerfM> I just came here to make friends
21:12:41 <kmc> advice for the kids these days: put down the crack pipe before you IRC
21:12:43 <Cale> The programming language Haskell
21:12:51 <Cale> That's what this IRC channel is about
21:13:00 <Cale> If you want general chat, it's not here :)
21:13:09 <kmc> try ##c++
21:13:12 <PerfM> Well, shucks eh?
21:13:38 <PerfM> I'm not a beginner....nice try. 
21:13:40 <Bynbo7> yeah, they're really friendly in ##c++
21:13:43 <PerfM> I caught you
21:16:16 --- mode: ChanServ set +o jmcarthur
21:19:45 <PerfM> Haskell reminds me of hassell
21:19:50 <PerfM> which makes me think of harrass
21:19:53 <PerfM> weird right?
21:20:05 <PerfM> must be those double letters
21:20:37 --- mode: jmcarthur set +q *!*@gateway/web/freenode/ip.173.180.71.38
21:20:41 --- mode: jmcarthur set -o jmcarthur
21:21:06 <Bynbo7> i hate it when 12 year olds find IRC
21:21:08 <cdsmithus> I've never seen it take this long between someone saying "fag" and getting kicked. :(
21:21:26 <Jafet> cdsmithus: we're a friendly channel, after all
21:22:16 <glguy> cdsmithus: this way he leaves on his own because he's bored
21:22:57 <jmcarthur> i've found that often times if you just show a troll that he needs to try to be more subtle but allow him to stay then his only choice if we wants to continue is to learn haskell
21:23:33 <geheimdienst> jmcarthur: omg you are trolling people to learn haskell?
21:23:35 <geheimdienst> ;)
21:23:48 * Bynbo7 does that all the time
21:23:49 <jmcarthur> people like that don't necessarily become the most pleasant people in the world, but it gives us a good reputation at least :)
21:24:33 --- mode: ChanServ set +o jmcarthur
21:24:39 --- mode: jmcarthur set -q *!*@gateway/web/freenode/ip.173.180.71.38
21:24:41 --- mode: jmcarthur set -o jmcarthur
21:32:32 <djahandarie> jmcarthur, so that's why Haskell is popular on /prog/...
22:26:50 <Adamant> why CAN'T we be friends, on the internet?
22:28:32 <kmc> because the internet is serious business
23:11:46 <joe6> is tere a way to define a data structure of a list of items which has atleast one item.
23:11:55 <joe6> s/tere/there/?
23:12:47 <shachaf> joe6: data List a = One a | Cons a (List a)
23:13:09 <ClaudiusMaximus> ugh.  12 hours to translate 500 lines of C into 500 lines of rougthly equivalent Haskell.  i would have got it done in half the time, but for the OpenGLRaw stupid newtypes and the API that gives you GLhandle but wants a GLuint sometimes (but not always, just sometimes...)
23:13:11 <joe6> shachaf: awesome. Thanks
23:13:29 <joe6> > Cons
23:13:30 <lambdabot>   Cons
23:16:05 <mauke> (a, [a])
23:18:55 <joe6> mauke: it is a simpler representation, but would this not be a tuple
23:19:15 <mauke> what
23:20:06 <joe6> shachaf: so very item that I create of List a, I should have to do a = Cons firstelement (List [otherelements])
23:20:35 <joe6> mauke: (a,[a]) == tuple?
23:20:37 <mauke> where did you get the [ ] from?
23:20:38 <mauke> joe6: yes
23:20:44 <shachaf> joe6: No, that's mauke's data type.
23:20:52 <mauke> what
23:21:07 <mauke> this won't make you less unconfused
23:21:36 <joe6> shachaf: how do I build an item with the elements 1..9 using the data List a representation?
23:21:52 <joe6> let a = Cons 1 (List 2 3 4 5 6 7 8 9)?
23:22:10 <mauke> where did you get List from, for that matter?
23:22:11 <djahandarie> List is not a value-level function
23:22:37 <djahandarie> All you have is Cons and One
23:22:43 <mauke> Cons 1 (Cons 2 (Cons 3 (Cons 4 (Cons 5 (Cons 6 (Cons 7 (Cons 8 (One 9))))))))
23:23:07 <joe6> gotcha. Thanks.
23:23:33 <mauke> (1, [2,3,4,5,6,7,8,9])
23:23:36 <Jafet> fromList :: [a] -> Maybe (List a)
23:24:04 <joe6> > fromList 1
23:24:05 <lambdabot>   No instance for (GHC.Show.Show (m a))
23:24:05 <lambdabot>    arising from a use of `M7132290049...
23:24:06 <mauke> fromList [] = Nothing; fromList (x : xs) = Just (x, xs)
23:24:22 <shachaf> mauke's solution is probably much more convenient to work with for simple things.
23:24:51 <Jafet> They're equivalent
23:25:06 <Jafet> Well, almost equivalent
23:25:16 <joe6> ok, thanks a lot guys
23:25:28 <shachaf> Jafet: Yes, bu there are a lot more [] functions than List functions. :-)
23:26:28 <joe6> or I could use Either a [a]
23:26:32 <Bynbo7> hmm, is there some way in haskell to have things like (list 1 2 3 4 5 6) return a list with those elements, ala printf?
23:26:38 <joe6> show
23:26:38 <djahandarie> listToList :: [a] -> List a; listToList xs = foldr Cons [] xs
23:26:41 <Bynbo7> maybe (list 1 2 3 4 5 6 ()) would work
23:26:59 <Bynbo7> joe6: are you after a list with at least one element?
23:27:05 <joe6> yes
23:27:07 <mauke> Bynbo7: yes
23:27:08 <Bynbo7> because Either a [a] doesn't guarantee that
23:27:18 <Bynbo7> you can have Right []
23:27:30 <joe6> no, I have either a list with one element or a list of elements.
23:27:42 <Bynbo7> but that's not guaranteed by the type
23:27:42 <joe6> and the list is not empty
23:27:49 <mauke> joe6: lists can be empty
23:27:51 <joe6> Bynbo7: yes, i get what you are saying now.
23:27:55 <Bynbo7> why not use a prepesentation that does guarantee it?
23:28:07 <Bynbo7> which (a,[a]) does
23:28:26 <joe6> what is a prepresentation? oh, ok. that is what mauke recommendede earlier
23:28:38 <mauke> representation
23:28:52 <Bynbo7> uh, yeah, where'd that p some from
23:28:54 <Bynbo7> come*
23:28:57 <Jafet> > printf ""
23:28:58 <lambdabot>   Ambiguous type variable `r' in the constraints:
23:28:58 <lambdabot>    `Text.Printf.PrintfType ...
23:29:03 <Jafet> :t printf ""
23:29:04 <lambdabot> forall r. (PrintfType r) => r
23:29:06 <mauke> > ""++ printf ""
23:29:09 <lambdabot>   ""
23:29:30 <Bynbo7> :t printf "" 1
23:29:31 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
23:29:31 <joe6> if you had the choice of input file format, would you use parsec or read ?
23:29:33 <Jafet> Ah, advanced hackery
23:29:34 <Bynbo7> :t printf "" 1 2
23:29:34 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
23:29:37 <Bynbo7> :t printf "" 1 2 3
23:29:38 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
23:29:40 <Bynbo7>  ""
23:29:42 <Bynbo7> whoops
23:29:44 <Bynbo7> :t printf "" 1 2 3 ""
23:29:45 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
23:30:08 <mauke> > ""++ printf "2"
23:30:10 <lambdabot>   "2"
23:30:23 <shachaf> It would be nice if printf was type-checked. I suppose TH would be the only reasonable way of doing that?
23:30:37 <Bynbo7> there's a package that lets you do that i believe
23:30:51 <Jafet> Just be thankful no one is asking for format.
23:31:20 <Bynbo7> ?
23:31:33 <Jafet> (I hear it's turing-complete)
23:31:34 <joe6> basically, serialisation (read and show) vs using parsec
23:31:41 <joe6> to read an input data file.
23:32:02 <joe6> which is edited by humans, hence in a reasonable understandable format.
23:33:01 <joe6> s/in/needs to be in/
23:33:27 <joe6> guys, any thoughts please? 
23:34:10 <joe6> if it is lisp, then having the data file in lisp format would make perfect sense. but, with haskell, parsec was easy to use.
23:34:33 <joe6> I built it up to use parsec and now I am wondering if I should have chosen Read instead.
23:35:08 <joe6> parsec does what I wanted it do. but, just curious on what the preferences/guidelines are.
23:35:11 <Bynbo7> have you actually asked a question here? :\
23:35:39 <joe6> yes, between a choice of reading input file using read vs using parsec, which do you prefer?
23:36:24 <joe6> in my case, the format of the input file is controlled by me, so I am wondering which implementation is more haskell-like?
23:36:34 <joe6> serialisation or parsec?
23:36:35 <Bynbo7> depends on the situation. i recently wrote a configuration file format which was just a list of records sata types
23:36:49 <Bynbo7> and it worked quite well
23:37:00 <joe6> using read?
23:37:21 <Bynbo7> yeah
23:37:31 <joe6> have you used parsec?
23:37:47 <joe6> or, did you just prefer read for any other reason?
23:38:29 <Bynbo7> i preferred read here because we're aiming not to have to use the file format after we get the web interface finished
23:39:07 <joe6> oh, ok. so, possibly read the input from some pipe or other channel?
23:39:17 <joe6> later, i mean.
23:40:24 <Bynbo7> well, it gets serialised at the moment for being sent to simulation processes. we'll soon be putting it all in a database
23:42:51 <Bynbo7> anyway, it really depends on your usage. sometimes using read is fine, sometimes using a parser is fine, sometimes using an already defined format like JSON or yaml works well too
23:44:29 <joe6> i am looking for some guidelines on which is better for when. 
23:44:50 <joe6> just thoughts/opinions
23:47:02 <joe6> ok, will ask the question in the morning then.
23:50:42 <Bynbo7> anyone else have a ot of fun watching Guy Steel talks?
23:52:54 <rubenz> I've installed amd64 ghc 7.0.1 on ubuntu 10. Running ghc on any file gives me "/usr/bin/ld: cannot find -lgmp". Not sure how to fix this. Any suggestions?
23:53:10 <Bynbo7> install gmp
23:53:26 <rubenz> already installed
23:54:14 <rubenz> Bynbo7: It's already installed here: /usr/lib/libgmp.so.3
23:56:28 <rubenz> So, any other ideas?
23:56:47 <mauke> ln -s libgmp.so.3 /usr/lib/libgmp.so
23:57:50 <rubenz> mauke: Thanks!
