00:01:30 <ville> kniu: Buy "physically based rendering"
00:01:46 <kniu> Already did.
00:01:57 <kniu> Just looking for people to talk about it with.
00:02:27 <Adamant> a graphics channel would be nice
00:02:44 <alip> a pink floyd channel would be nicer
00:03:11 <Phyx-> hmm that looks like a nice book
00:03:25 <Phyx-> 75bucks? eek
00:13:01 * hackagebot LambdaHack 0.1.20110117 - a small roguelike game  http://hackage.haskell.org/package/LambdaHack-0.1.20110117 (AndresLoeh)
00:20:25 <Kaidelong> oh I see
00:20:34 <Kaidelong> <*> is S and pure is K
00:20:48 * pastorn is getting his parsec on
00:21:25 * Kaidelong wonders why he didn't read this paper on applicative functors sooner
00:21:33 <Phyx-> Kaidelong: you bad boy you
00:21:53 <ion> kaidelong: Which paper?
00:22:19 <Kaidelong> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
00:22:21 <Kaidelong> this one
00:22:42 <turiya> My haskell code runs very slow, where do i look for help on speeding up the code?
00:22:50 <ion> kaidelong: Thanks
00:23:02 <luite> turiya: you could read the profiling and optimization chapter in rwh
00:23:11 <Phyx-> or on the wiki
00:23:12 <Bynbo7> turiya: there's many pages on performance tuning on the haskell wiki
00:23:21 <Bynbo7> i think they're a little dated though
00:23:57 <turiya> Oh thanks..
00:24:10 <Bynbo7> turiya: what sort of program is it?
00:25:18 <turiya> Bynbo7: a small function which displays an image
00:26:05 <turiya> For small image sizes the time taken is ok but for bigger images its just too slow
00:26:22 <Bynbo7> what datatypes are you using?
00:26:49 <turiya> Basically a list of pixel values
00:27:06 <Bynbo7> yeah, that would be why it's slow ;)
00:27:25 <luite> yeah images are typically an application where unboxed arrays could be appropriate
00:28:00 <turiya> Yes, i could not find a way to boost the speed as well as maitain a neat mathematical interface
00:28:12 <pastorn> what happends when identifiers begins with _?
00:28:26 <pastorn> the compiler does something special then, right?
00:29:22 <earthy> nope
00:29:36 <earthy> only when the identifier *is* _ :)
00:29:38 <turiya> luite: unboxed arrays? Where can i find more info
00:29:49 <Bynbo7> they're in Data.Array.Unboxed
00:30:00 <joe6> pastorn: is there a better way of doing this: (>>) ( printfBuffer emptyBuffer )  (putStrLn "")
00:30:03 <pastorn> earthy: doesn't it surpress warnings or something?
00:30:05 <Kaidelong> http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Unboxed.html
00:30:12 <Kaidelong> or that
00:30:25 <luite> vector could be less than ideal since it's always indexed by Int
00:30:36 <pastorn> joe6: printBuffer emptyBuffer >> putStrLn ""
00:30:40 <pastorn> :p
00:31:37 <earthy> pastorn: yeah, if you have -fwarn-unused-matches, starting a binding with _ suppresses the warning
00:31:59 <earthy> *if* it would have been generated in the first place
00:32:08 <pastorn> eh?
00:32:10 <pastorn> generated?
00:32:15 <earthy> the warning
00:32:25 <earthy> so,  f _x = _x   is valid and would not generate warnings
00:32:39 <pastorn> and what's unused matches? stuff like {case mb of; Nothing -> ...; Just x -> ...; _ -> ...} ?
00:32:44 <earthy> however   f _x = True   is also valid and would, however, due to _x it is suppressed
00:32:59 <pastorn> ah, now i see
00:33:12 <pastorn> so you want to name your arguments, even if they don't get used
00:33:13 <joe6> pastorn: ok, thanks.
00:33:20 <earthy> pastorn: yup
00:33:43 <pastorn> joe6: you could always insert '\n' at the end of your formatting line (assuming you're using printf)
00:34:19 <Phyx-> hs2lib VsxLexer
00:34:27 <Kaidelong> > let x = 1 : (zipWith (+) <*> tail) x
00:34:28 <lambdabot>   not an expression: `let x = 1 : (zipWith (+) <*> tail) x'
00:34:30 <Phyx-> whoops, damnit, all these black windows look the same
00:34:36 <Kaidelong> > let x = 1 : (zipWith (+) <*> tail) x in x
00:34:40 <lambdabot>   mueval-core: Time limit exceeded
00:35:45 <Kaidelong> > (zipWith (+) <*> tail) [1..]
00:35:46 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
00:37:55 <Bynbo7> Kaidelong: needs at least two elements in the list to work
00:38:18 <Bynbo7> so 1:1:...
00:38:23 <pastorn> joe6: heh, i'm beginning to write _ <- f now
00:38:45 <pastorn> you made me start... makes it more readable
00:38:54 <pastorn> then all the "<-" can stay aligned
00:39:24 <ville> kniu: While not perhaps on topic on that particular channel, luxrender is based on pbrt.
00:39:40 <Kaidelong> > let x = 1 : 1 : (zipWith (+) <*> tail) x in x
00:39:41 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
00:40:23 <Kaidelong> ah great, I still like the "fibs = 1 : scanl (+) 1 fibs" version a bit better
00:40:27 <joe6> pastorn: how do i get  printf "%02x %02x %02x %02x\n" [1..4]::Word8 to printf "%02x %02x %02x %02x\n" 1 2 3 4
00:41:13 <joe6> pastorn: actually, do not bother. i will just use the above combination
00:43:04 <pastorn> joe6: you just do a simple function that prints one number, then you use mapM
00:43:08 <pastorn> joe6: or mapM_
00:43:12 <pastorn> @type mapM_
00:43:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
00:44:02 <pastorn> joe6: mapM_ (printf "%02x ") [1..4] >> printf "\n"
01:01:28 <Maxdamantus> > fix $ (1:) . (1:) . ap (zipWith (+)) tail
01:01:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
01:17:58 <alan_> :t f u x y z = map length ([ a | a <- u, a >= x ] ++ y) ++ z
01:17:59 <lambdabot> parse error on input `='
01:18:27 <alan_> :t f (u x y z) = map length ([ a | a <- u, a >= x ] ++ y) ++ z
01:18:28 <lambdabot> parse error on input `='
01:18:35 <alan_> ?
01:19:08 <ivanm> use a let or something
01:19:16 <ivanm> :t let f (u x y z) = map length ([ a | a <- u, a >= x ] ++ y) ++ z in f
01:19:17 <lambdabot> Parse error in pattern
01:19:32 <ivanm> gah, the parens
01:19:36 <ivanm> :t let f u x y z = map length ([ a | a <- u, a >= x ] ++ y) ++ z in f
01:19:37 <lambdabot> forall a. (Ord a) => [[a]] -> [a] -> [[a]] -> [Int] -> [Int]
01:20:19 <alan_> and I need to ask it is Ord because  >= induces it?
01:20:26 <Botje> yp
01:21:33 <alan_> :t let g x y z = filter x [ a | a <- y, a >= ord z ] in g
01:21:34 <lambdabot> (Int -> Bool) -> [Int] -> Char -> [Int]
01:22:34 <alan_> ok. but here we have as well >= but it doenst induce Ord. is it because of Bool? I mean Ord is already an instance of Bool
01:23:51 <quicksilver> >= does induce Ord
01:24:03 <quicksilver> but Int is already an instance of Ord
01:24:08 <quicksilver> and it's Ints you are >='ing
01:26:07 <alan_> quicksilver: oh. yeah. I got it thanks. and is there anywhere some exercises where I can define the signature of the function?
01:27:02 <kuffaar> mm_freak both Control.Concurrent and Control.ContStuff feature forkIO - which one were you using?
01:27:21 * hackagebot hashable 1.0.1.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.0.1.0 (MilanStraka)
01:29:12 <mm_freak> kuffaar: in this case it doesn't matter
01:29:20 <kuffaar> Oh, ok
01:29:25 <mm_freak> kuffaar: import Control.Concurrent hiding (forkIO)
01:29:37 <kuffaar> Yeah I did that
01:29:43 <mm_freak> contstuff's forkIO generalizes forkIO to other monad transformers
01:30:19 <kuffaar> Are ContStuff and STM widely used? I didn't even notice until just now when I tried to imitate your code that they don't actually come with ghc
01:30:47 <quicksilver> STM comes with ghc.
01:30:58 <quicksilver> ContStuff is not widely used.
01:31:21 <ivanm> never heard of ContStuff before...
01:31:33 <kuffaar> I had to cabal install stm
01:31:34 <Bynbo7> me either
01:31:42 <kuffaar> Until Control.Concurrent.STM worked
01:31:55 <kuffaar> Err, *to make it work
01:31:57 <ivanm> kuffaar: yeah, it doesn't come with ghc itself anymore
01:32:07 <kuffaar> Right ^
01:32:29 <mm_freak> quicksilver: i think STM is separeted from GHC, but it comes with the HP
01:32:33 <quicksilver> ok, well it comes in the haskell platform.
01:32:42 <quicksilver> and it's implementation is internal to GHC
01:32:47 <quicksilver> only the library part is unbundled
01:33:46 <quicksilver> I would always use the haskell platform, or distribution packages
01:33:58 <quicksilver> (and distribution packages should make the same things avaible as HP, if not more)
01:34:21 <kuffaar> mm_freak shouldn't I avoid this ContStuff at my stage? I probably hardly understand all the implications anyways and combining forever with abort just feels dirty
01:34:40 <kuffaar> Shouldn't I be using recursion with some abort condition on a certain MVar instead?
01:36:00 <pastorn> kuffaar: i usually hack it to work with System.Exit
01:36:14 <pastorn> then i can easily kill stuff from within (forever loop)
01:36:30 <pastorn> (but if you're using Cont you can actually leave that loop
01:36:52 <kuffaar> I don't think I like the semantics of a forever which is actually supposed to terminate
01:37:01 <kuffaar> Seems misleading
01:37:20 <pastorn> huh?
01:37:26 <pastorn> @src forever
01:37:27 <lambdabot> Source not found. That's something I cannot allow to happen.
01:37:33 <pastorn> wtf...
01:38:14 <Bynbo7> :t fix . (>>)
01:38:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
01:38:28 <alpounet> hm
01:38:52 <Baughn> > (fix . (>>)) [3] :: [String]
01:38:56 <lambdabot>   mueval-core: Time limit exceeded
01:39:12 <quicksilver> > forever Nothing
01:39:13 <lambdabot>   Nothing
01:39:25 <quicksilver> kuffaar: ^^ forevers can terminate. Some monads have short-cut abilities.
01:39:30 <Baughn> > forever (Just "Roses")
01:39:34 <lambdabot>   mueval-core: Time limit exceeded
01:39:41 <kuffaar> quicksilver is that considered good style? Hmm
01:39:46 <quicksilver> sure.
01:39:49 <Bynbo7> kuffaar: why not?
01:39:53 <kuffaar> It seems counter intuitive to me but then again I'm new to Haskell
01:39:58 <Bynbo7> > forever error
01:39:59 <lambdabot>   Overlapping instances for GHC.Show.Show ([GHC.Types.Char] -> b)
01:40:00 <lambdabot>    arising ...
01:40:07 <Bynbo7> > forever error "aww"
01:40:11 <lambdabot>   mueval-core: Time limit exceeded
01:43:24 <kuffaar> mm_freak: Ah, I see the withLockedPrinting :: ((String -> IO ()) -> IO ()) -> IO () -- now :p
01:44:13 <pastorn> kuffaar: you could also do this by spawning some sort of manager thread
01:44:47 <pastorn> createPrintHandler :: Chan String -> Chan String -> IO ()
01:44:55 <pastorn> one chan to read from and one to write to
01:45:24 <pastorn> then internally that would manage it so that there wouldn't be conflicts
01:45:55 <pastorn> another idea is hiding the Chans, doing createPrintHandler :: IO (IO String, String -> IO ())
01:46:04 <pastorn> returning "safe" getLine and putStrLn
01:46:25 <pastorn> (but you'd have to carry them around etc.)
01:46:29 <kuffaar> I don't even need console input
01:46:37 <kuffaar> Although I might in future, hm
01:46:52 <pastorn> kuffaar: ok... consider the global hack we talked about yesterday
01:46:55 <pastorn> you could do
01:47:13 <kuffaar> Haha no, I decided not to do anything like that at this stage
01:47:16 <pastorn> unsafePerformIO (createMVar stdout) :: MVar Handle -- with NOINLINE
01:47:35 <kuffaar> At least I can understand the stuff now that I no longer try to use ReaderT and such to achieve this
01:47:43 <kuffaar> Since several people recommended against doing that
01:47:47 <pastorn> kuffaar: why not use that?
01:48:04 <kuffaar> pastorn unsafePerformIO? You really want to ruin me this early on, eh?
01:48:27 <pastorn> if you've already messed with ReaderT you're already ruined
01:48:28 <kuffaar> pastorn you mean a monadic approach? I didn't really grasp how to use it in my code
01:48:40 <kuffaar> What, why
01:48:42 <pastorn> no, this wouldn't be a monic approach
01:48:57 <kuffaar> ReaderT s is a monad, no?
01:49:00 <pastorn> this would just be safe ways for you to do IO
01:49:14 <pastorn> yeah, but ReaderT is not what i'm proposing
01:49:18 <kuffaar> Also, how does ReaderT ruin you? It's not like it involves unsafePerformIO
01:49:33 <pastorn> dealing with the extra type constraint just for printing is extremely annoying
01:49:55 <pastorn> all you want to do is to print, but without conflicts from schedulers
01:50:40 <Baughn> pastorn: It's that, or a global variable
01:51:00 <kuffaar> I tried to use the monadic approach in my code, I managed to implement the printer like that but I failed to use it in my other code
01:51:03 <Baughn> pastorn: But keep in mind, you might later want to not send this output to stdout
01:51:04 <pastorn> so you just want putStrLn' and putStr', which behaves exactly like the normal putStr* functions, except they won't cause conflicts
01:51:11 <kuffaar> I was lost in all the lifts etc
01:51:35 <pastorn> kuffaar: exactly, doing monad transformers is often messy
01:51:51 <pastorn> fuck it, i'm writing this myself
01:52:08 <kuffaar> And somebody in here told me that I should keep the signature of stuff which performs IO to IO a really
01:52:12 <kuffaar> Instead of Blah IO a
01:52:26 <pastorn> exactly, that's why you want a global
01:52:46 <kuffaar> I mean, I would use a global in every other language :p
01:53:03 <kuffaar> No, wait, I think I usually used a class for that in C++ and Ruby
01:53:31 <kuffaar> Although it was more annoying in C++ because of std::cout operator overloading missing
01:53:43 <Baughn> kuffaar: I would disagree with that one. Layering transformers on top of IO is both useful and common.
01:54:03 <Baughn> kuffaar: Typically it ends up being type-aliased to something that doesn't even textually mention IO
01:56:04 <pastorn> FUCK!! Pentadactyl ate my code!
01:56:10 <kuffaar> Baughn: https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/Console.hs
01:56:18 <pastorn> "we're forking vimperotar because it's unstable"
01:56:21 <pastorn> riiiiiiiiiiiiiiiiiiiiiiight
01:56:21 <kuffaar> That was my old approach but I didn't really grasp how to integrate that
01:57:23 <Baughn> kuffaar: It'll come with experience. Couple comments, though..
01:57:48 <Baughn> kuffaar: - Make it an MVar Handle, or even MVar (String -> IO ()). Chacnes are you'
01:57:59 <Baughn> kuffaar: - Make it an MVar Handle, or even MVar (String -> IO ()). Chacnes are you'll want to send the output somewhere else later.
01:57:59 <pastorn> kuffaar: http://codepad.org/8RJ0IV71
01:58:03 <pastorn> there you go
01:58:10 <mm_freak> kuffaar: use whatever appears to be natural to express a certain control construct
01:58:17 <Baughn> kuffaar: - Use withMVar, not take/putMVar. The latter are only for when you use it as a message box.
01:58:41 <mm_freak> kuffaar: the logger is an infinite loop, which writes log entries (whatever that means in the given context)
01:59:04 <mm_freak> and i use ContT as a means to quit that loop cleanly
01:59:16 <kuffaar> <mm_freak> kuffaar: use whatever appears to be natural to express a certain control construct <- none of this is natural to me, it's pure FP!!
01:59:28 <kuffaar> Baughn: Oh hmmm
02:00:05 <mm_freak> quitting 'forever' in a Cont/ContT is a very natural thing to do…  you're wrongly interpreting "forever" to mean "infinite loop"
02:00:17 <mm_freak> which, by quicksilver's Maybe example, is clearly a wrong interpretation
02:00:55 <mm_freak> you need to interpret 'forever' in the context of the given monad
02:01:42 <Baughn> kuffaar: One way to think about it is that 'forever' makes a particular computation infinite, but like other infinite lazy structures there's nothing to stop the runtime from going off and running a different computation
02:01:50 <mm_freak> in the case of ContT 'forever c' means:  the continuation of c is itself, unless you use a different continuation or don't use a continuation at all (which is what 'abort' does)
02:01:55 <Baughn> Nothing says you need to *finish* every computation
02:02:28 <mm_freak> in ContT "c >> d" means that 'd' is the continuation of 'c' and 'forever c' means: c >> c >> c >> c >> …
02:02:30 <pastorn> Baughn: doesn't agda?
02:02:54 <kuffaar> Ohh I think I am developing a preference to use 'type' definitions for a lot of arguments so the function signatures carry more semantic information even when it's just for a String
02:02:58 <Baughn> pastorn: What's agda got to do with it?
02:03:09 <kuffaar> I think that's a nice thing you can do in Haskell
02:03:31 <Baughn> kuffaar: And one day you'll try to reimplement HList, /only better/. :P
02:03:36 * Baughn is still stuck on that one, actually
02:03:43 <pastorn> Baughn: can't agdas type system guarantee that you won't do naughty stuff?
02:03:55 <kuffaar> Baughn I don't even know what that is
02:04:04 <Baughn> pastorn: So can haskell's. If you mean, can it guarantee some naughtiness that haskell can't.. yes.
02:07:30 <mm_freak> Baughn: agda is not turing-complete
02:07:45 <mm_freak> haskell is, so at least the halting problem applies to haskell, which it doesn't for agda
02:08:14 <Baughn> mm_freak: Mm, lovely halting problem
02:08:28 <kuffaar> Haha, this guy who is trying to make me quit Haskell to "preserve my sanity and to keep me actually writing code" said that there's no end to the improvements you can make to even the most simple stuff
02:08:39 <kuffaar> I think I am beginning to see the foreshadows of this now
02:08:43 <Baughn> kuffaar: True, but is that supposed to be a /bad/ thing?
02:09:11 <kuffaar> I don't think so
02:09:23 <pastorn> kuffaar: that's what i'm saying - use a global and be done with it
02:10:33 <quicksilver> the code pastorn pasted is quite likely not to work.
02:10:46 <kuffaar> pastorn but I need to learn something new and I need to learn how to use monads, too, hmm
02:10:48 <quicksilver> it's quite likely that unsafePerformIO will get inlined and you'll have more than one MVar.
02:10:54 <kuffaar> Haha
02:11:05 <kuffaar> Didn't he use the NOINLINE pragma thing?
02:11:07 <pastorn> quicksilver: wait what?
02:11:16 <kuffaar> It looked really abusive and has been criticised in here before
02:11:31 * hackagebot yesod-auth-oauth 0.1 - OAuth wrapper for yesod-auth  http://hackage.haskell.org/package/yesod-auth-oauth-0.1 (HiromiIshii)
02:11:53 <mm_freak> pastorn: my point is that he didn't move from C++ to haskell to write C++ code in haskell
02:12:02 <mm_freak> he's learning how to do it properly, and i think that's fine
02:12:09 <pastorn> mm_freak: but there's no nice way to do it in haskell
02:12:17 <Baughn> That said, why don't we have a global variable haskell' proposal yet?
02:12:28 <Baughn> Not that I'm advocating global variables, but.. yes, ok, I am
02:12:29 <pastorn> Baughn: JHC has it, right?
02:12:33 <mm_freak> i'm writing a lot of really useful, practical stuff in haskell using no hacks at all
02:12:37 <pastorn> hLock <- newMVar stdout
02:12:43 <pastorn> like that
02:12:44 <Baughn> pastorn: Haven't used JHC, but I believe so
02:12:58 <mm_freak> pastorn: sure there is, why not?
02:13:55 <pastorn> mm_freak: fine, you can let all your functions take an extra (unnessecary) argument if you want to, but i prefer to not do it that way
02:14:40 <mm_freak> l
02:14:44 <mm_freak> pastorn: i don't
02:14:51 <mm_freak> there are state monad for that
02:14:56 <mm_freak> or even the good old reader monad
02:14:59 <mm_freak> or STM
02:15:01 <mm_freak> or or or…
02:15:07 <pastorn> but then you can't use your code outside those monads
02:16:13 <mm_freak> why should you?
02:16:41 <mm_freak> it's your application monad, so naturally you'll want to write your application in that monad
02:17:22 <pastorn> mm_freak: i've actually stopped using most monads
02:17:35 <pastorn> i stick to parser monads and STM (and IO, of cource)
02:17:52 <mm_freak> and instead of IO you could just as well use your own monad
02:18:07 <mm_freak> besides some lifting, it's almost a drop in replacement for IO
02:18:24 <pastorn> well, it's extremely annoying to litter code with 'liftIO'
02:18:28 <pastorn> so i prefer not to
02:19:11 <Baughn> Agreed, that's why I shortened unsafePerformIO to io.
02:19:31 <pastorn> hehe
02:19:43 <pastorn> is there a putBack function for parsec?
02:22:56 <mm_freak> well, everybody has their own way to solve it…  i like the monadic approach
02:23:18 <mm_freak> because of its composability and its non-C++ishness
02:24:38 <kuffaar> I didn't see anything between "It looked really abusive" and "well, everybody" btw
02:24:44 <kuffaar> Just went to another classs
02:24:51 <kuffaar> But my box at home has the complete history
02:27:36 <mm_freak> kuffaar: it's the global variable war again =)
02:27:52 <kuffaar> haha
02:28:06 <mm_freak> ultimately it's your decision…  my point against the global lock is that you're resorting to C++ programming
02:28:10 <kuffaar> mm_freak I mean I wanted to try the approach with the monad but I so didn't get how to deal with that
02:28:19 <kuffaar> It was the first thing I tried
02:28:28 <kuffaar> But I failed to integrate it into the other code
02:28:42 <mm_freak> kuffaar: the monad is just for convenience…  if you look closely at my code from yesterday, it doesn't even use a custom monad
02:28:45 <mm_freak> just plain ol' IO
02:29:55 <Phyx-> is it just me, or does running ghc -c <file> fail with "cc1.exe: error: unrecognized command line option "-fno-stack-protector""
02:29:58 <Phyx-> in ghc 7
02:30:31 <kuffaar> Phyx- hmm shouldn't cabal use ghc -c internally?
02:30:39 <kuffaar> I haven't seen that so far
02:30:41 <mm_freak> kuffaar: plain version:  withLogger (([String] -> IO ()) -> IO a) -> IO a
02:30:48 <kuffaar> But then again I rarely use ghc directly
02:30:59 <mm_freak> + ::
02:31:01 <kuffaar> mm_freak but that doesn't involve any ReaderT, now does it?
02:31:13 <mm_freak> version with a custom monad:  withLogger :: MyMonad a -> IO a
02:31:28 <mm_freak> or, if you're me:  withLogger :: MonadIO m => MyMonadT m a -> m a
02:31:33 <mm_freak> =)
02:32:15 <mm_freak> and then you have a separate logging function:  logStr :: String -> MyMonad ()
02:32:40 <mm_freak> or, if you're me:  logStr :: MonadIO m => String -> MyMonadT m ()
02:33:06 <mm_freak> type MyMonad = StateT (MVar LogCmd) IO
02:33:13 <mm_freak> or, if you're me:  type MyMonadT = StateT (MVar LogCmd)
02:33:20 <int-e> kuffaar: is that option contained in /path-to-ghc/lib/ghc-7.0.1(or whatever version)/extra-gcc-opts? you can edit that file
02:33:42 <Phyx-> kuffaar: i'm trying to run it,  but it fails with that error
02:34:02 <Phyx-> int-e: you mean me?
02:34:17 <int-e> Phyx-: right
02:34:20 <int-e> sorry.
02:34:24 <mm_freak> kuffaar: but as said, i wouldn't write a logger monad, but an /application/ monad, which encapsulates the configuration of your entire application, not just the logging
02:35:14 <mm_freak> you're gonna pass some application configuration around anyway, so you could just as well add the logger to that…  you're not going to use global variables for all of your application configuration, are you? ;)
02:35:23 <Phyx-> int-e: i don't see that file under /lib
02:35:51 <Phyx-> /usr/local/lib/ghc-7.0.1 rather
02:36:30 <Phyx-> hmm, well, it's using the mingw gcc instead of the one that comes with ghc
02:36:33 <Phyx-> that might be it
02:37:00 <kuffaar> mm_freak well you can compose the application configuration of this thing, among others, no?
02:37:01 <int-e> Phyx-: mm. ghc-pkg describe base | grep library-dirs  should lead you to the right place. [but I may be completely off track, I've never used ghc under Windows]
02:38:17 <mm_freak> kuffaar: what do you mean?
02:38:17 <Phyx-> int-e: lol, that's defined using $topdir
02:39:18 <int-e> Phyx-: oh. ghc --info  then?
02:39:48 <int-e> (that should've been the first place to look actually)
02:40:09 <kuffaar> mm_freak well can't you just use the logging monad within the application monad? Just stack it up and then 'type' it to compress it to a single statement ultimately?
02:40:52 <Phyx-> int-e: well, it says that the libdir is /local/lib but again in /local/lib/ghc-7.0.1/ there's only .hi files, no extra-gcc-opts
02:42:42 <Mr_Mojo> hello
02:43:04 <Phyx-> int-e: oh, but it is in /local/lib directly
02:43:26 <Phyx-> int-e: but the option is not mentioned in the filr
02:45:20 <Phyx-> bizzare
02:45:25 <Mr_Mojo> Has anyone here successfully compiled & installed haskell from source on slackware?
02:46:07 <joe6> i have a data structure as : data Y = Y {yy :: Int, yz ::Int}; data X = X { y :: Y }; emptyX = X { y = Y {yy = 0, yz = 0}}
02:46:33 <joe6> i am trying to do: emptyX {y = Y {yy = 1}}
02:46:37 <mm_freak> kuffaar: sure you can, but i wouldn't
02:46:53 <Mr_Mojo> I'm trying to install xMonad so far I have ghc installed but missing cabal & was trying to install base & filepath but got sytax errors
02:47:00 <mm_freak> kuffaar: unless you write a separate logging library, of course
02:47:01 <joe6> that is get emptyX initialized to some initial values and then add only the values that I care about.
02:47:02 <Phyx-> int-e: it only does this with the ghc i compiled in msys, the one in the installer doesn't do this.. could this be a build flag?
02:47:08 <kuffaar> mm_freak https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/Console.hs does this look reasonable at all? I largely tried to imitate what yo did, but I am not even using the [String] feature right now and I am still not really comfortable with using ContStuff because I hardly grasp this stuff and I was told that it's not even used widely
02:48:21 <int-e> Phyx-: I'm don't really know.
02:48:59 <mm_freak> kuffaar: yes, that looks reasonable
02:49:41 <mm_freak> although i would suggest not overusing 'type', because at some point you'll make your code /less/ readable, because at every spot one needs to look up what your type aliases mean
02:49:51 <joe6> if it was for just one level of depth, I could easily do: emptyX {y = 1} but am not able to get it work with the nested records.
02:50:24 <kuffaar> mm_freak yeah you do have a point, I suppose
02:50:33 <quicksilver> joe6: it is a bit of a pain.
02:50:39 <kuffaar> Although in this case I am not even doing stuff like type A = String yet
02:50:57 <Mr_Mojo> sort of like not overusing using directives in c++
02:51:03 <quicksilver> joe6: let oldy = y emptyX in emptyX { y = oldy { yy = 1 } }
02:51:30 <quicksilver> joe6: for sensible access to nested records one of the helper packages is recommended, like fclabels or data-accessor
02:51:43 <mm_freak> kuffaar: well, for example PrintStrings…  i find [String] much clearer
02:52:28 <joe6> quicksilver: do you know of any tutorials that can help me understand those packages?
02:52:49 <kuffaar> mm_freak hmm :| I see
02:53:52 <mm_freak> also, as a matter of taste, you should reconsider whether you want to hide the order of your functions in type aliases
02:54:03 <mm_freak> i'd rather write [String] -> IO () instead of PrintingFunction
02:54:31 <mm_freak> but i guess PrintingFunction is also good
02:54:31 <quicksilver> joe6: no :-S
02:55:34 <Phyx-> int-e: fixed it :)
02:56:14 <Phyx-> it was defaulting to gcc 3.4.5
02:56:19 <Phyx-> and i needed 4.5
02:56:23 <Phyx-> which was also installed
02:59:42 * hackagebot sbv 0.9.3 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.3 (LeventErkok)
02:59:43 <joe6> outStatus2ToSimulator = let old = tsEp0InBdStat emptyToSimulator  in emptyToSimulator { tsEp0InBdStat = old { tsPid3 = True }}
03:00:16 <joe6> quicksilver: can you please help? I am trying to return the modified 
03:01:08 <quicksilver> that looks right, joe6 ?
03:01:21 <joe6> quicksilver: i have the typedefinition as : outStatus2ToSimulator :: ToSimulator
03:02:12 <joe6> quicksilver: got it, it is working
03:02:19 <joe6> i was looking at something else.
03:04:27 <Mr_Mojo> hmm it wasn't a sytax error but a lexical error
03:20:55 <Phyx-> hs2lib.exe: panic! (the 'impossible' happened)
03:20:55 <Phyx->   (GHC version 7.0.1 for i386-unknown-mingw32):
03:20:56 <Phyx->         Could not find module `GHC.Paths':
03:21:02 <Phyx-> why does that constitute a panic?
03:21:04 <Phyx-> seriously
03:21:57 <Phyx-> and further more, the package is installed
03:26:03 <Phyx-> whot the hell
03:26:14 <Phyx-> how can my package list be broken already...
03:26:34 <Phyx-> oh.. the installer didn't remove the old one
03:26:37 <Phyx-> *fail*
03:27:19 <Phyx-> is there a build in command to tell ghc-pkg to just create a new package.conf?
03:29:06 <Phyx-> hmm so now the packages are fixed
03:29:09 <Phyx-> it still can't find it
03:29:21 <Phyx-> but ghci can
03:29:24 <Phyx-> *scratches head*
03:30:03 <ivanm> Phyx-: ghc-pkg recache ?
03:30:29 <Phyx-> ivanm: didn't help :(
03:30:40 <Phyx-> it's still panicking for some reason
03:30:47 <ivanm> weird...
03:30:51 <Phyx-> ghc-pkg find-module "GHC.Paths" finds it just fine
03:31:24 <Phyx-> and before i installed GHC-Paths it was reporting a normal "module not found" error
03:31:29 <Phyx-> after installing it, panics
03:35:22 <Phyx-> ok... this is an issue
03:35:34 <Phyx-> i have two different "versions" of ghc 7.0.1 using the same package.conf.d
03:37:19 <Bynbo7> so, this acovea progra is quite fun
03:37:23 <Bynbo7> program*
03:37:55 <Phyx-> is there a way to tell ghc-pkg to use a different package.conf?
03:41:08 <kuffaar> Phyx- hmm why do you have two versions anyways?
03:41:46 <Phyx-> kuffaar: one is the standard ghc binary, one is build from source with a few modifications
03:42:04 <Phyx-> was never a problem before due to the one being build from source was always a nightly snapshot
03:42:14 <Phyx-> guess only way to solve this is changing the ghc version number
03:42:17 <Phyx-> and rebuilding
03:43:14 <joe6> to print a bytestring in hex format, I am using: printf "%02x " (x::ByteString)
03:43:35 <joe6> is there a way to convert that into a string so I can derive a show instance to it
03:44:24 <kuffaar> joe6 hm what type does it return right now?
03:44:34 <joe6> IO ()
03:44:59 <joe6> i actually do: mapM_ (printf "%02x ") (x::ByteString)
03:45:00 <kuffaar> Huh :o I expected printf to return a String
03:45:20 <sipa1024> :t printf
03:45:22 <lambdabot> forall r. (PrintfType r) => String -> r
03:45:24 <joe6> that is what it does, I am wondering what I should do to get the C scanf functionality
03:45:31 <sipa1024> :t sprintf
03:45:32 <lambdabot> Not in scope: `sprintf'
03:45:37 <Bynbo7> printf can also return strings
03:45:51 <Bynbo7> > printf "test %d" 3 :: String
03:45:52 <lambdabot>   "test 3"
03:45:56 <Bynbo7> > printf "test %d" 3 :: IO ()
03:45:57 <lambdabot>   <IO ()>
03:46:41 <pastorn> @pl f >>= \x -> g >> return x
03:46:41 <lambdabot> (g >>) . return =<< f
03:46:47 <joe6> i tried this, map (printf "%02x") . 
03:46:56 <pastorn> joe6: didn't work?
03:47:20 <pastorn> joe6: try having the printf with a type signature within a where-clause
03:47:39 <Bynbo7> you'll need concatMap
03:47:43 <pastorn> joe6: it's the vararg-thing that's messing up, i guess
03:47:47 <joe6> pastorn: the mapM_ worked, but i am trying to derive a Show instance so that when I print the big record structure, it prints out the bytes in the hex format 
03:47:59 <joe6> that it prints when I just print them out using displayBuffer
03:48:03 <Bynbo7> map printf... has type [String] (sort of)
03:48:20 <Bynbo7> :t concatMap (printf "%02x)
03:48:21 <lambdabot>     lexical error in string/character literal at end of input
03:48:24 <Bynbo7> :t concatMap (printf "%02x")
03:48:25 <lambdabot> forall a b. (PrintfArg a, IsChar b) => [a] -> [b]
03:48:44 <Bynbo7> > concatMap (printf "%02x") [1,16,256]
03:48:45 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:48:46 <lambdabot>    `Text.Printf.IsChar b'
03:48:46 <lambdabot>  ...
03:48:53 <Bynbo7> > concatMap (printf "%02x") [1,16,255 :: Word8]
03:48:54 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:48:54 <lambdabot>    `GHC.Show.Show b'
03:48:54 <lambdabot>      a...
03:48:54 <pastorn> joe6: i've at least encountered the problem... try with naming your printing and fixating the arguments to it
03:49:01 <Bynbo7> > concatMap (printf "%02x") [1,16,255 :: Word8] :: String
03:49:01 <lambdabot>   "0110ff"
03:49:03 <pastorn> that helped me when i had trouble with this...
03:49:10 <Bynbo7> > concatMap (printf "%02x ") [1,16,255 :: Word8] :: String
03:49:11 <lambdabot>   "01 10 ff "
03:49:29 <joe6> concatMap did the trick
03:49:30 <joe6> thanks.
03:49:44 <Bynbo7> > intersperse " " $ (printf "%02x") [1,16,255 :: Word8] :: String
03:49:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
03:49:44 <lambdabot>         against inferred type...
03:49:45 <aristid> > intercalate " " $ map (printf "%02x ") [1,16,255 :: Word8]
03:49:46 <lambdabot>   "01  10  ff "
03:49:53 <aristid> > intercalate " " $ map (printf "%02x") [1,16,255 :: Word8]
03:49:55 <lambdabot>   "01 10 ff"
03:49:57 <Bynbo7> > intercalate " " $ (printf "%02x") [1,16,255 :: Word8] :: String
03:49:57 <lambdabot>   No instances for (Text.Printf.IsChar GHC.Word.Word8,
03:49:58 <lambdabot>                    Tex...
03:50:04 <Bynbo7> > intercalate " " $ (printf "%02x") [1,16,255 :: Word8]
03:50:05 <lambdabot>   No instances for (Text.Printf.IsChar GHC.Word.Word8,
03:50:05 <lambdabot>                    Tex...
03:50:09 <Bynbo7> >_____________<
03:50:19 <aristid> Bynbo7: you forgot the map
03:50:19 <Bynbo7> i'm sick, i don't need this crap >_<
03:50:27 <Bynbo7> indeed!
03:50:33 <Bynbo7> > intercalate " " $ map (printf "%02x") [1,16,255 :: Word8]
03:50:34 <lambdabot>   "01 10 ff"
03:50:43 <aristid> intercalate = concat .: intersperse
03:51:25 <aristid> > intercalate " " $ map (printf "%02X") [1,16,255 :: Word8]
03:51:26 <lambdabot>   "01 10 FF"
03:51:55 <joe6> pastorn: do you mind giving this a quick look, please? http://codepad.org/GguD7lBF
03:52:01 <joe6> just a quick look.
03:52:18 <Phyx-> Configure completed successfully.
03:52:19 <Phyx-> Building GHC version  : 7.0.1-VSH
03:52:22 <Phyx-> that should do it
03:52:25 <Phyx-> whata hassle
03:52:32 <Phyx-> now i have to build all the stages again
03:52:58 <joe6> pastorn: please.
03:53:15 <pastorn> joe6: what happends if the list is empty on line 53?
03:53:19 <aristid> Phyx-: i think i will stick to 6.12 until things have settled :)
03:54:01 <joe6> pastorn: good catch. will fix it.
03:54:04 <pastorn> joe6: and when you use error you should always enter the function name in the string
03:54:09 <pastorn> > head ""
03:54:10 <lambdabot>   *Exception: Prelude.head: empty list
03:54:15 <joe6> pastorn: will do, thanks.
03:54:21 <pastorn> it's error message is "head: empty list"
03:55:34 <joe6> pastorn: is it a good idea to be doing what I am doing. Having a giant initialization function and then changing its' values in the function.
03:55:52 <pastorn> joe6: line 69
03:55:58 <joe6> pastorn: just wanted to know what you think of that design pattern. good idea or bad idea?
03:56:16 <pastorn> instead of applying smsg to everything you can do 'map ($ smsg) over the functions you use
03:56:25 <Phyx-> aristid: i need 7.0 unfortunately, it's that or stick to an old 6.13 snapshot,but porting over will be harder later
03:56:42 <joe6> pastorn: that is a brilliant idea. i was thinking about that.
03:57:08 <pastorn> joe6: you could perhaps not create initial values that you change unless you actually need them along the way
03:57:12 <aristid> Phyx-: why do you need it?
03:58:13 <pastorn> so if you have data A = A { x :: X, y :: Y } you might not want to create an A (if that's the return type) until the final line, instead create x0 and y0 and at the final line have return A { x = x4, y = y8 }
03:58:13 <joe6> pastorn: i do not understand.
03:58:54 <joe6> pastorn: gotcha, good idea.
03:58:59 <Phyx-> aristid: originally because of some bugfixes with building dlls on windows, now because of some Typeable and Data instances on internal types, plus I wanna see if the new typechecker is faster
03:59:43 <aristid> Phyx-: oh, you're building on windows?
03:59:56 <Phyx-> aristid: yeah
04:00:05 <aristid> somehow i thought you use OS X :D
04:00:26 <Phyx-> lol
04:00:36 <Phyx-> i'm the sore thumb that sticks out here :P
04:00:47 <aristid> tibbe seems to use windows too
04:01:03 <pastorn> joe6: you might want a 'zeroToBdStat = ToBdStat False False False False False'
04:01:27 <joe6> pastorn: so, basically have default records for each of the subrecords and bring them together in the return
04:01:44 <pastorn> something like that...
04:01:46 <pastorn> if needed
04:01:47 <joe6> pastorn: i understand
04:02:04 <joe6> and it reduces the complexity too and make it easier to understand
04:02:13 <pastorn> unless the data going into the final record is simple, then it won't matter if you push the computation to the return
04:02:15 * Phyx- hands tibbe a cookie
04:02:32 <pastorn> joe6: you remember Ip.hs?
04:02:56 <joe6> pastorn: yes, i still look at it every hour
04:02:59 <pastorn> iirc. there was some "randomFlag = testBit x w8" stuff in the returns
04:03:04 <joe6> to see how you were doin something
04:03:14 <pastorn> well, my style isn't perfect ;)
04:03:21 <pastorn> it all depends on the task
04:03:31 <joe6> yes, i see that
04:13:56 <joe6> pastorn: with your suggested changes: http://codepad.org/J2HkZV7i
04:14:51 <pastorn> joe6: haha, you might want a 'onesBdStat' as well, to complement :)
04:15:41 <pastorn> joe6: is it fewer lines and still readable, then it's good :)
04:18:57 <joe6> pastorn: ok, thanks.
04:53:26 <jonkri> is there someway i can change how much height ghci in haskell mode takes up? (opened with C-c C-l)
04:56:06 <Botje> worst case you can drag the dividing line up or down
04:56:44 <Botje> http://www.emacswiki.org/emacs/WindowResize # random search result
04:57:05 <ray> that's just ABSURD.
04:57:12 <ray> greenscreen terminals don't have mouse pointers and you know it
04:58:26 <Botje> ray: now we have terminals in HD.
04:58:53 <Botje> we have to resort to rendering pixels as anti-aliased squares with bloom filters
04:59:12 <Botje> bloom effects, not filters :)
05:00:15 <pastorn> .term, the new shader type to go along with .frag, .vert and .geom
05:05:18 <roconnor> gwern: what is PredicitionBook.com?
05:05:18 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
05:07:28 <aristid> @index asTypeOf
05:07:29 <lambdabot> Prelude
05:08:24 <aristid> roconnor: just guessing from the name... a website for publicly recording predictions so people can check later how accurate their predictions were?
05:08:45 <int-e> pastorn: I don't get it. term as in terminal?
05:09:15 <pastorn> int-e: all part of OpenGL 5.0
05:12:47 <Phyx-> ghc-cabal.exe: dummy-ghc.exe: /usr/local/bin/ghc.exe: createProcess: does not
05:12:47 <Phyx-> exist (No such file or directory)
05:12:59 <Phyx-> would be usefull it if told me which process doesn't exist according to it
05:15:39 <roconnor> @tell gwern you might be intrested in http://r6.ca/blog/20081109T015636Z.html
05:15:39 <lambdabot> Consider it noted.
05:16:14 <mornfall> Phyx-: /usr/local/bin/ghc.exe, I believe?
05:16:31 <mornfall> Phyx-: And not process, but the executable you are trying to run.
05:16:32 <Phyx-> mornfall: nah it's there
05:16:44 <mornfall> Ah. Bummer. :)
05:16:56 <Phyx-> it's just broken :)
05:16:59 <Phyx-> no packages
05:17:20 <mornfall> Yeah, get a refund. :)
05:17:41 <Phyx-> i kinda violated the warranty
05:17:57 <Botje> happens all the time
05:18:06 <Botje> stick it together with ducttape and be done with it :)
05:18:30 <Phyx-> haskell.org/rma? :P
05:27:26 * Phyx- tries bootstrapping with a different ghc
05:37:04 <Egbert9e9> what's the difference between bracket and bracket_?
05:37:16 <Egbert9e9> i don't understand the documentation
05:37:31 <portnov> :t bracket_
05:37:31 <lambdabot> Not in scope: `bracket_'
05:38:49 <tac-tics> Things ending in _ usually throw away the return value
05:38:57 <tac-tics> And return () instead
05:39:31 <tac-tics> @type mapM
05:39:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:39:34 <tac-tics> @type mapM_
05:39:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:40:11 <aristid> i wonder if having a record with 17 members is a bad sign.
05:47:43 <Phyx-> i keep forgetting we're in 2011
05:48:39 <Egbert9e9> portnov, it's in Control.Exception
05:48:46 <tac-tics> aristid: can any of the fields be folded into subrecords?
05:49:46 <aristid> tac-tics: maybe.
06:04:54 * hackagebot antlrc 0.0.1 - Haskell binding to the ANTLR parser generator C runtime library.  http://hackage.haskell.org/package/antlrc-0.0.1 (MarkWright)
06:10:12 <Botje> Phyx-: it only sinks in around april, for me
06:12:35 <Phyx-> Botje: hehehe, same
06:14:14 <jonkri> i'm looking at a source file which uses a function called "atomically". as i did not know what it did, i tried google it and to also search all haskell files in the project that i'm looking at without finding the function definition. how would you proceed? (emacs + haskell mode)
06:15:00 <aristid> @hoogle atomically
06:15:01 <lambdabot> Control.Exception data NestedAtomically
06:15:01 <lambdabot> Control.Exception NestedAtomically :: NestedAtomically
06:15:01 <lambdabot> Control.OldException NestedAtomically :: Exception
06:15:11 <aristid> bad lambdabot, wrong result
06:18:52 <fryguybob> http://haskell.org/hoogle/?hoogle=atomically
06:19:35 <tac-tics> Lol
06:19:38 <ToRA> i'm assuming you mean "atomically" from Software Transactional Memory, (package stm on hackage), which is really defined in GHC.Conc (definition: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/GHC-Conc-Sync.html#atomically), and is actually a built in primitive provided by GHC
06:19:45 <Phyx-> hoogle should have a song
06:20:23 <joe6> i want to convert a [Bool] -> Word8, where the Bool maps to the bit value in the Word8. 
06:20:26 <joe6> http://codepad.org/x3i9Mgxp
06:20:28 <tac-tics> Lambdabot is an automated logic machine. It is not wrong. You assert absurdity, therefore you are wrong.
06:20:32 <joe6> the above has code that does it
06:20:47 <joe6> I am wondering if you have any thoughts if it can be written better
06:21:01 <joe6> or if there is a higher order function to do so.
06:29:59 <Saizan> ?type setBit
06:30:00 <lambdabot> forall a. (Bits a) => a -> Int -> a
06:30:06 <ToRA> foldl (flip ($)) 0 [ (`setBit` i) |  (True,i) <- [ True, False, True ] `zip` [0..] ] :: Word8
06:31:53 <Saizan> > foldl (flip ($)) 0 [ (`setBit` i) |  (True,i) <- [ True, False, True ] `zip` [0..] ] :: Word8
06:31:55 <lambdabot>   5
06:32:03 <joe6> ToRa: brilliant, Thanks.
06:32:03 <Saizan> you should use fold' though
06:32:09 <Saizan> *foldl'
06:32:10 <ToRA> good point
06:32:51 <ToRA> foldl (flip ($)) feels like it should be an existing combinator, though i can't rememeber what if it is
06:33:43 <Saizan> ?type foldl' (flip ($))
06:33:44 <lambdabot> forall b. b -> [b -> b] -> b
06:34:01 <Saizan> ?type flip sequence 
06:34:02 <lambdabot> forall a a1. a -> [a -> a1] -> [a1]
06:34:15 <Saizan> not quite anyway
06:38:23 <fryguybob> > let f = foldl' (\a b -> 2*a + (if b then 1 else 0)) (0 :: Word8) in f [True,True,False]
06:38:24 <lambdabot>   6
06:42:15 <gwern> preflex: seen roconnor
06:42:15 <preflex>  roconnor was last seen on #haskell 1 hour, 26 minutes and 39 seconds ago, saying: @tell gwern you might be intrested in http://r6.ca/blog/20081109T015636Z.html
06:42:15 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
06:42:48 <mun_> in logic, is the identity \lambda x. x a "subterm" of any term?
06:43:12 <quicksilver> yes.
06:43:23 <quicksilver> it is, for example, a subterm of \y . (\x . x)
06:43:26 <gwern> @tell roconnor PB = http://predictionbook.com/happenstance = convenient way to record public & private predictions online; and your link and another is already in my prediction markets article
06:43:27 <lambdabot> Consider it noted.
06:44:20 <aristid> yay, my aws library can now send both S3 and SimpleDB requests. the weird request signing scheme is defeated (for now)
06:44:53 <mun_> quicksilver, so would you consider \x. x c to be a subterm of f c, since (\x. x c) f = f c?
06:45:46 <quicksilver> mun_: no.
06:45:53 <quicksilver> mun_: subterm is a syntactic issue.
06:46:08 <quicksilver> mun_: f c has precisely two proper subterms - f and c
06:46:38 <mun_> quicksilver, but how come the identify function is also a subterm?
06:46:39 <quicksilver> (for completeness, "f c" itself and the empty term are also subterms, depending on how you formalised things)
06:46:49 <quicksilver> mun_: what?
06:46:58 <quicksilver> mun_: (\x . x) is a subterm of \y . (\x . x)
06:47:04 <tac-tics> "The empty term"?
06:47:21 <quicksilver> tac-tics: probably most formal languages don't admit empty terms.
06:47:22 <mun_> quicksilver, ooh sorry. i misread your answer before.
06:47:26 <mun_> quicksilver, it's clear now.
06:47:44 <quicksilver> tac-tics: but it's not impossible to imagine ones that do.
06:48:17 <quicksilver> for example, in a concatenative language, you can argue that the empty term is a proper progam (with denotation being id)
06:49:14 <tac-tics> Yeah
07:02:48 <stulli> Could somebody help me with this error: http://hpaste.org/43104/could_not_deduce_precision_p ? I don't get why it works in main but not in the other function.
07:14:08 <allbery_b> stulli: I see you have ScopedTypeVariables enabled; but to use a scoped variable you have to "declare" it with "forall".
07:14:14 <quicksilver> yes
07:14:24 <quicksilver> you need forall p. in the type sig on line 10
07:19:31 <stulli> allbery_b, quicksilver: Ow thanks, i think i have to read more about this extension. 
07:20:50 <jonkri> the way i understand runReaderT is that it's taking one argument, r ("runReaderT :: r -> m a"). so what does "... $ runReaderT a (Thread in' out')" do? XmppThreadT is defined as "type XmppThreadT a = ReaderT Thread IOa"
07:24:55 <Botje> what's this Thread thing?
07:25:52 <jonkri> Botje: a record with inCh :: TChan Stanza and outCh :: TChan Stanza
07:26:24 <Botje> can you put a bigger sample on hpaste?
07:27:52 <mun_> does anyone know if higher-order matching avoids all flex/flex cases?
07:27:55 <quicksilver> jonkri: you're wrong about runReaderT taking one argument.
07:28:06 <quicksilver> @type runReaderT
07:28:08 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
07:28:13 <quicksilver> it takes two
07:28:25 <quicksilver> first the action, then the environment parameter.
07:28:29 <jonkri> http://hpaste.org/43105/concurrenths
07:30:41 <jonkri> ah, i just misread the constructor at http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Reader.html#v:runReaderT
07:33:20 <quicksilver> jonkri: yes, easy to do :)
07:33:34 <quicksilver> records have a hidden extra parameter.
07:33:41 <quicksilver> (record selectors, I mean)
07:34:05 <quicksilver> so, the meaning of "runReaderT a (Thread in' out')" is "run the action a with the environment (Thread in' out')"
07:34:22 <quicksilver> from which I deduce that "a" had the type "ReaderT Thread something"
07:51:38 <ClaudiusMaximus> hm, 'simple-reflect' + 'ad' makes for some fun, but is there any expression simplifier?  ideally i would get '0' from: 'simplify $ diff (\x -> (cos x)^2 + (sin x)^2) (x :: Expr)'
07:52:17 <ClaudiusMaximus> diff for that example gives: cos x * (negate (sin x) * 1) + negate (sin x) * 1 * cos x + (sin x * (cos x * 1) + cos x * 1 * sin x)
07:53:27 <alpounet> you'd need to run a simplifier before and after differentiation
07:53:41 <alpounet> just give it a bunch of rules to simplify
07:54:07 <ClaudiusMaximus> that "just ..." is the tricky part !
07:54:16 <alpounet> like 0 + x = x, 0 * _ = 0, cos²(x) + sin²(x) = 1, etc
07:54:23 <djahandarie> ClaudiusMaximus, there aren't any bindings to one in Haskell
07:54:39 <alpounet> ClaudiusMaximus, that's something I have been thinking about
07:54:40 <djahandarie> I was thinking about writing some but that never happened
07:54:47 <alpounet> very same here heh
07:55:29 <ClaudiusMaximus> well, maybe i'll just do it by hand for now, i don't have too many equations...
07:58:15 <tac-tics> How can you identify "tail calls" in lambda calculus?
07:59:08 <tac-tics> Is it always a lamda whose subterm is an application? Are there any other restrictions?
08:00:12 <Philippa> that's pretty much it, although the concept's a lot more useful if you work in terms of n-ary functions
08:01:09 <tac-tics> Howso? (I am in fact interested in lc extended with multple args)
08:03:01 <tac-tics> Moreso, I'm looking to extend lc with an operator that makes tail calls explicit
08:03:09 <lpsmith> I read "n-ary functions" as "n-ary fractions".
08:03:34 <Philippa> tac-tics: have you met ANF? Tail calls are about as explicit as they can be in it
08:03:57 <Philippa> it's a restricted lambda calculus though - still turing complete etc etc, but forces you into a syntactic normal form
08:05:26 <tac-tics> Thanks
08:07:47 <jethr0> good afternoon, #haskell
08:08:14 <jethr0> i have a tiny question regarding writer monad...
08:08:49 <sleepynate> can we make fun of the size of your question?
08:08:56 <jethr0> absolutely
08:09:02 <sleepynate> perhaps sell you question-enchancing herbal supplements?
08:09:28 <jethr0> i've got a (StateT a (Writer b) c)
08:09:46 <sleepynate> "Women will be ADDICTED to the size of your writer monad questions!"
08:09:53 <jethr0> absolutely, anything made from endangered species
08:10:56 <jethr0> my program is caught in an infinite loop but my writer monad is not giving me output as it goes along...
08:11:06 <jethr0> makes it kinda difficult to get an idea what's happening ;(
08:13:23 <jethr0> ...
08:13:57 <jethr0> should i put the writer on the "outside" to get "debug" information as the program runs? should i use execState/evalState/runState?
08:14:05 <jethr0> ohh, these monads, they continue to haunt me ;)
08:14:33 <lpsmith> jethr0, you might be interested in Debug.Trace
08:14:41 <lpsmith> instead of the writer monad
08:15:37 <jethr0> thx. i find trace to be kinda flakey though and really wanted to grok this Writer thing. also want to use it for unit testing monadic functions
08:16:25 <jethr0> would i want to use lazy state and strict writer?
08:16:36 <lpsmith> jethr0, probably because you don't understand Haskell evaluation,  which admittedly is difficult to grok sometimes, even for experts  :)
08:17:10 <lpsmith> jethr0, probably the other way around
08:17:16 <jethr0> lpsmith: yes, thanks. i've been at it in haskell for many years and indeed i still don't grok its evaluation
08:17:53 <lpsmith> (but I don't know the particulars of your problem)
08:18:03 <jethr0> so, if i wanted to use a writer to get "realtime" "output" from a state+writer monad... which way would i nest them and what kind of state/writer (lazy/strict) would i want?
08:18:16 <lpsmith> There isn't a "lazy writer" versus "strict writer",  though the choice of monoid you use with it can matter
08:18:31 <jethr0> Control.Monad.Writer.Strict
08:19:10 <lpsmith> oh, ok, I stand corrected :-D
08:19:12 <jethr0> not in standard libs though, i guess
08:19:40 <lpsmith> well, it's in MTL-2 at least
08:20:12 <Egbert9e9> i've tried reading about bracket_ in the documentation but i don't get it
08:20:23 <Egbert9e9> i'm trying to understand the irc bot tutorial
08:20:46 <Egbert9e9> it's using Control.Exception.bracket_ at one point
08:22:33 <lpsmith> jethr0, for *most* purposes,  you want to use State.Strict.  I've got to figure out what the differences is between Writer.Strict and Writer.Lazy though
08:23:05 <jethr0> :t bracket_
08:23:06 <lambdabot> Not in scope: `bracket_'
08:23:56 <jethr0> Egbert9e9: it allows u to acquire & release resources without worrying about it manually
08:24:31 <Egbert9e9> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html
08:24:40 <jethr0> bracket (acquire resource) (\id -> release resource) (\id -> computation_using_resource)
08:24:44 <Egbert9e9> what's the difference from bracket?
08:24:51 <Egbert9e9> what's the little underscore there?
08:25:03 <jethr0> ah, usually a trailing underscore means that nothing is returned by the action
08:25:23 <Egbert9e9> hmmm
08:25:25 <jethr0> @mapM (+1) [1,2,3]
08:25:25 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
08:25:31 <Egbert9e9> O_O
08:25:36 <jethr0> >mapM (+1) [1,2,3]
08:25:49 <lpsmith> jethr0, and the trick to Debug.Trace is realizing that something doesn't get printed unless the second argument actually gets evaluated
08:25:52 <jethr0> never mind
08:26:18 <lpsmith> Beyond that,  I don't think I can help out too much more without more information
08:26:25 <jethr0> lpsmith: yes, i've tried trace a couple of times, but i found it to be quite unreliable. it has a bit of a hackey feel to it (in the negative sense)
08:26:29 <jethr0> but maybe that's just me
08:26:53 <jethr0> Egbert9e9: did that help?
08:27:07 <Egbert9e9> i'm not sure, i'll try to read the documentation again now
08:27:10 <lpsmith> well,  it's only intended for debugging.  I've never had reliability issues with trace myself. :)
08:27:21 <jethr0> thx a lot lpsmith
08:27:27 <Egbert9e9> hmm... the different type signatures
08:28:25 <jethr0> @hoogle bracket_
08:28:25 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
08:28:26 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
08:28:26 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
08:28:26 <Egbert9e9> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:28:30 <Egbert9e9> oh
08:28:36 <jethr0> @hoogle bracket
08:28:36 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:28:36 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:28:37 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:28:43 <Egbert9e9> nice!
08:29:09 <jethr0> Egbert9e9: sorry, that means that the trailing underscore means something different than i thought ;(
08:29:41 <Egbert9e9> oh
08:29:48 <jethr0> ah, my guess would be that "bracket_" doesn't use a resource_id 
08:30:43 <jethr0> so, if your acquisition process doesn't return a resource id or u don't need it than u can use bracket_, would be my idea
08:30:49 <jethr0> Egbert9e9: what would u like to use it for?
08:31:10 <Egbert9e9> i'm reading some source and trying to understand it
08:31:14 <Egbert9e9> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
08:31:55 <jethr0> in this case bracket is used (in a weird way) to execute an action and to write something before and after executing
08:33:39 <Egbert9e9> this haskell thing takes a ton of time to get used to
08:33:57 <Egbert9e9> wish i had learned it as my native language
08:34:02 <Egbert9e9> mother tongue
08:34:02 <jethr0> this is similar to "try ... catch ... finally" in other languages
08:34:08 <Egbert9e9> ya
08:35:44 <jethr0> strike the "in a weird way". perfectly sane.
08:38:17 <hpc> Egbert9e9: the code on that page isn't entirely the best, to be fair
08:38:28 <hpc> it leaves a lot to be learned on other pages
08:38:48 <Egbert9e9> sigh
08:38:51 <jethr0> maybe a better source would be "real world haskell". doesn't that have a chapter on "roll your own irc bot" as well?
08:38:56 <hpc> especially the "just use forkIO" part
08:39:10 <jethr0> real world haskell is pretty good, and it's freely available online
08:39:20 <Egbert9e9> ya, i already have it
08:39:24 <Egbert9e9> but it's so verbose
08:39:31 <Egbert9e9> soooo looong
08:39:37 <Egbert9e9> oh well
08:41:38 <hpc> don't worry about getting that code to be elegant
08:41:42 <hpc> i never could
08:43:57 <hpc> it's mostly an introduction to intermediate IO
08:49:11 <monochrom> real world haskell is not long. not like c++ in 21 days.
08:49:52 <kafee_> I've a question related to game programming:
08:50:42 <kafee_> in a arcade 2d game, if a character is walking, it is just images that are being updated?
08:50:57 <sproingie> it's all images being updated
08:51:58 <Botje> kafee_: either you scroll the background to the left or you move the character to the right
08:52:14 <sproingie> usually you need to update the character image in what's called a "walk cycle"
08:52:45 <kafee_> so, for a fight game, I have to have for each move for each clothe an image...
08:52:48 <sproingie> walk cycles are one of the trickier things to get right
08:53:07 <Botje> kafee_: you can do fancy stuff with skeletal animation
08:53:12 <Botje> (read: animating limbs separately)
08:53:31 <sproingie> these days you can use a 3d image and animate it with the tools in your modeler, but you'll still need to bake it to some degree
08:53:42 <kafee_> humm
08:54:13 <kafee_> there's no less painful method?
08:54:21 <sproingie> that is the painless method
08:54:35 <kafee_> ok, thank you guys
08:54:51 <sproingie> google for "game dev walk cycle" and you'll get some hints on how to get it done
08:55:01 <sproingie> it's one of the trickier things to get right
08:55:56 <kafee_> so instead of images I can have animations?
08:56:38 * hackagebot epubname 2.3.0 - Rename epub ebook files based on meta information  http://hackage.haskell.org/package/epubname-2.3.0 (DinoMorelli)
08:57:05 <hpc> kafee_: in a 2D arcade game, animations /are/ images
08:57:22 <hpc> since what do you have to move?
08:58:06 <kafee_> hpc: like gifs?
08:58:23 <hpc> animated gifs are just multiple images
08:58:37 <hpc> and iirc, the spec for animation makes it very hard to control the frames
09:02:04 <kmc> you should make a 2d fight game where the characters don't move
09:02:43 <hpc> like, a 3D model is made up of polygons arranged around a movable skeleton
09:02:48 <Jafet> They just throw ripostes at each other?
09:02:56 <Jafet> ("Mortal Comeback")
09:03:03 <hpc> i suppose you could do the same thing with a 2D image, but you would be moving pixels
09:03:11 <hpc> and such a thing doesn't exist
09:03:23 <monochrom> just display text sequentially like "john punches peter", "peter kicks john".
09:04:54 <hpc> "john makes a distasteful comment towards peter's mother"
09:04:58 <hpc> FATALITY
09:06:41 <sproingie> MORTAL DEBATE SOCIETY
09:06:51 <sleepynate> i like it
09:07:17 <sproingie> there was a cute shockwave game called "sissy fight" that revolved around lowering your opponent's self-esteem
09:07:31 <monochrom> haha
09:07:33 <sproingie> had pretty neat gameplay mechanics because it relied on synergies from others in the fight
09:07:35 <kmc> hpc, most 3D games are vector-based while most 2D games these days are raster-based
09:07:39 <kmc> but you can make a 2D vector game
09:07:58 <hpc> ah, forgot about that
09:08:20 <kmc> i highly recommend finding an original Asteroids console and playing for a while
09:08:23 <kmc> the graphics are beautiful
09:08:25 <sproingie> you can also make a 3d game rendered on a plane.  pretty uncommon for fighting games though, those tend to be hand-crafted
09:08:44 <sproingie> iirc we have some real afficionados of fighting games here in #haskell
09:08:55 <kmc> there are no pixels; the CPU just modulates the electron beam deflection directly
09:09:13 <gwern> a real vector game then; I hear tempest was amazing too
09:09:22 <sproingie> tempest was freakin awesome
09:09:47 <sproingie> i have to admit space giraffe was a pretty good take on tempest despite the lack of a knob
09:10:36 <kmc> they made up for it with about ten different kinds of psychedelic drugs
09:10:42 * hackagebot sbv 0.9.4 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.4 (LeventErkok)
09:12:04 <kmc> asteroids is also black and white, so there's no shadow mask artifacts either
09:12:54 <kmc> and the beam leaves brilliant white trails
09:16:05 <Jafet> Sounds vaguely bad for your eyes
09:17:58 <Jafet> Of course, back in the day your eyes would be protected by your allowance
09:18:16 <titusg> I have got a toy concurrency example with STM and threads, and it does some printing which gets garbled. How do I make sure one thread prints at a time?
09:18:36 <kmc> titusg, have them "print" by writing to a Chan
09:18:47 <kmc> then have another thread which consumes messages from that chan and prints them, one at a time
09:19:12 <titusg> That makes sense. :-) thx
09:19:17 <kmc> there are other solutions (like using MVar () as a lock) but i like this one
09:19:32 <kmc> you don't even have to expose the Chan; you can just expose its write method partially applied
09:20:23 <titusg> I'll take your word for that, will have a think about it
09:20:37 <titusg> s/think about/look at/
09:20:54 <c_wraith> If the messages are strings, and you care about performance, it's probably a good idea to evaluate them fully before putting them in the Chan.
09:21:02 <Saizan> are you testing this in ghci and/or setting NoBuffering? using LineBuffering might be enough
09:21:24 <c_wraith> Otherwise, the output writer thread can easily bog down and end up using all your memory.
09:21:56 <titusg> c_wraith: yes they are. how do I strictify them then?
09:22:33 <c_wraith> titusg: deepseq is the easiest way.  If you don't want to import that package, you can do the same thing manually
09:23:14 <titusg> c_wraith: thanks I'll read about deepseq
09:25:00 <kmc> deepseq can be expensive overkill
09:25:05 <kmc> you have to traverse the whole data structure
09:25:12 <kmc> (hopefully it's a short string)
09:25:24 <c_wraith> well, if you're strictifying a string, you have to traverse the whole data structure anyway.
09:25:36 <kmc> c_wraith, that depends on how the string is generated
09:26:00 <c_wraith> Hmm.  I suppose if the tail is a constant, you don't.
09:28:33 <titusg> they are short strings, and it's only a toy example but I don't want it to be full of things that would break larger programs :-)
09:31:15 <Phyx-> cabal install GHC-Paths --constraint 'Cabal==1.10.0.0'
09:31:27 <Phyx-> it tells me there's no cabal that satisfies that constraint
09:31:39 <Phyx-> but i have
09:31:40 <Phyx-> "Cabal-1.10.0.0"
09:31:51 <jonkri> @type liftIO
09:31:52 <lambdabot>     Ambiguous occurrence `liftIO'
09:31:52 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
09:31:52 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
09:32:11 <c_wraith> :t Control.Monad.Trans.liftIO
09:32:12 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
09:32:33 <c_wraith> Really, that class is defined in Control.Monad.Trans.  lambdabot needs some imports re-arranged
09:32:50 <jonkri> what about hoogle? http://www.haskell.org/hoogle/?hoogle=liftio
09:33:06 <Phyx-> anyone?
09:34:48 <Saizan> Phyx-: check that cabal is finding the same ghc-pkg that tells you that you have that Cabal
09:35:04 <Saizan> Phyx-: passing -v should tell you
09:35:05 <djahandarie> Phyx-, uh, does GHC-Paths even require Cabal?
09:35:13 <djahandarie> Or maybe Cabal constraint does something for all packages
09:35:15 * djahandarie doesn't know
09:35:54 <Saizan> it doesn't, actually, so that might be the problem
09:36:11 <Phyx-> Saizan: -v just exists after "reading package description"
09:36:19 <Phyx-> doesn't say why it can't satisfy the constraint
09:36:45 <Phyx-> djahandarie: yes it does, it uses "rawSystemProgramStdoutConf"
09:36:48 <Phyx-> which is in Cabal
09:37:01 <Phyx-> i just removed Cabal 1.11.1
09:37:05 <djahandarie> It doesn't list it as a dependency though
09:37:09 <djahandarie> Which could be why it is erroring
09:37:33 <Phyx-> the problem is, that 1.11.1 has different types than the normal cabal, I added a Cabal monad
09:37:33 <djahandarie> Also I don't see where it is using that
09:37:37 <Phyx-> so the types don't match up
09:38:01 <Phyx-> djahandarie: not the package itself, the custom Setup.hs
09:38:05 <Saizan> Phyx-: ghc-paths doesn't use Cabal, that's why you get that error i think, even if the message is wrong
09:38:26 <Saizan> Phyx-: to specify the Cabal version to use for Setup.hs there's another flag
09:38:49 <Saizan> Phyx-: --cabal-lib-version=
09:39:32 <Phyx-> yeah, I wonder though, it might be a good idea to provide an interop version of that function, so I don't break alot of packages on hackage :/
09:45:04 <mun_> hi
09:45:10 <mun_> is haskell simply typed?
09:45:36 <kmc> not in the sense of the simply typed lambda calculus
09:45:39 <kmc> what do you mean by that term
09:45:55 <mun_> yes, in that sense
09:46:09 <mun_> but haskell supports polymorphic types, right?
09:46:16 <kmc> right
09:46:24 <kmc> STLC is at the "least powerful" corner of the lambda cube
09:46:29 <mun_> isn't polymorphism typically not considered as "simple"?
09:46:39 <kmc> the three axes are polymorphic types, type constructors, and dependent types
09:46:42 <kmc> and haskell has two of those three
09:47:09 <mun_> right
09:47:12 <kmc> (terms depending on types, types depending on types, and types depending on terms)
09:49:11 <aavogt> kmc: are all corners occupied?
09:49:28 <kmc> they are all systems you can consistently talk about
09:49:41 <kmc> i'm not sure about occupied by "real" programming languages
09:50:23 <kmc> most dependently typed languages are constructed in such a way that you get the other two for free
09:51:14 <aavogt> but there's no  "real world agda" coming out soon
09:51:24 <kmc> i wish
09:52:03 <kmc> wikipedia says that "dependent types only" is close to LF
09:52:07 <Saizan> you need an animal for the cover
09:52:50 <kmc> anyway the lambda cube is a pretty limited way to categorize type systems
09:53:26 <kmc> "pure type systems" is a much more general vocabulary
09:55:42 <ski> (<http://www.impredicative.com/ur/> looks interesting)
09:56:47 <Phyx-> is.. it just me, or is the new typechecker in ghc 7 stricter?
09:56:50 <ski> (as does "Certified Programming with Dependent Types" at <http://adam.chlipala.net/cpdt/> by Adam Chlipala (Smerdyakov))
09:57:01 <Phyx-> ooooh
09:57:02 <Phyx-> nvm
09:57:04 <Phyx-> the lib is missing
09:57:06 <Phyx-> :/
09:57:56 <aavogt> Phyx-: some use of  Rank2Types doesn't work pointfree (without a typesignature) anymore
09:58:02 <jmcarthur> Phyx-: well, it *is* a bit more strict though
09:58:48 <Phyx-> aavogt: is that a bug or by design?
09:58:58 <Phyx-> jmcarthur: ah, then i'm not *completely* crazy yet
09:59:15 <aavogt> Phyx-: I dunno
10:00:25 <hpc> Phyx-: it's a complex scheme to gradually cut out inference capabilities until you have to put a type signature on everything :P
10:00:53 <Phyx-> hpc: :O, those bastards :P
10:01:06 <hpc> it's what i would do :P
10:01:07 <kmc> conspiracy
10:01:15 * hpc bbl
10:02:39 <aavogt> Phyx-: this change as an example http://code.haskell.org/XMonadContrib/_darcs/patches/20101113022839-1499c-e4b76537164f29e065c24db279215dbac727c01f.gz
10:05:43 <Phyx-> aavogt: 404, is that a gzip?
10:06:03 <aavogt> really, it works here
10:06:12 <Phyx-> the link ends with ".gz" here
10:06:15 <aavogt> yes
10:06:19 <Phyx-> odd
10:06:29 <Phyx-> lool
10:06:36 <Phyx-> it added a .com behind it
10:06:38 <Phyx-> for some reason
10:06:57 <aavogt> anyways, it's just     f = x . y     worked previously, but now   we need     f z = x (y z)
10:07:21 <aavogt> because z contains a rank-2 polymorphic type I think
10:07:23 <Phyx-> that's weird, i would expect it to still work
10:07:58 <kmc> i have run into this problem with (.) and ($)
10:08:10 <Phyx-> if y already contains the higher rank notation, it shouldn't be a problem, unless i'm mistaken
10:08:19 <kmc> it's a little shocking that «runST $ do { ... }» doesn't work but «runST (do { ... })» does
10:08:41 <aavogt> you could add a type signature to $
10:09:11 <kmc> yeah
10:09:28 <aavogt> hmm, I'm not so sure you can do that without redefining it
10:09:58 <kmc> :t ($) :: ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a
10:09:59 <lambdabot> forall a. ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a
10:10:26 <McManiaC> are there any cool approaches to get something like a representation for e.g. natural numbers in haskell?
10:10:27 <kmc> the issue is that type inference won't instantiate a type variable to a quantified type?
10:10:36 <McManiaC> like, Ints without 0 or negative numbers?
10:10:47 <kmc> well you can define the naturals inductively
10:10:50 <kmc> data Nat = Zero | Succ Nat
10:10:54 <kmc> and this is nice in some ways (e.g. laziness)
10:11:00 <kmc> but computation is slow
10:11:07 <kmc> you can also do it at type level, which is fun
10:11:39 <aavogt> kmc: say you don't want to name the 'a' there. You can't write                ($) `asTypeOf` (($) :: ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a), right?
10:11:57 <kmc> probably not
10:12:02 <kmc> because asTypeOf will have the same problem
10:12:15 <McManiaC> kmc: that data defintion wouldn't work for e.g. |R+ which contains real numbers bigger than 0
10:12:22 <kmc> right
10:12:23 <McManiaC> kmc: whats that type level youre talking about?
10:12:29 <kmc> data Zero; data Succ n
10:12:48 <kmc> there's articles about this on the haskell wiki
10:12:50 * djahandarie just lifts data Nat = Zero | Succ Nat and gets a free kind-level Nat
10:12:57 * djahandarie IN DREAM LAND
10:12:58 <kmc> we can do that now?
10:13:02 <kmc> :/
10:13:06 <kmc> it works in She
10:13:13 <kmc> it also might work in GHC eventually?
10:13:20 <kmc> aavogt, yeah it's annoying that you have to name 'a', since that could require ScopedTypeVariables
10:13:29 <djahandarie> Yes byorgey is working on it, but it is apparently a complex job
10:13:44 <aavogt> kmc: the 'a' might be something annoying to write out
10:15:10 <kmc> yeah
10:15:44 <aavogt> with -XRank2Types you can't really manipulate type variables anymore to avoid that
10:16:04 * aavogt means with functions in the style of asTypeOf
10:20:06 <conal> i have a favor to ask. i keep getting reports that my blog triggers security warnings for some people, and i cannot reproduce the warning. i'd really appreciate hearing what gets warnings and who doesn't, including OS & browser. for instance, http://conal.net/blog/posts/is-program-proving-viable-and-useful/
10:21:29 <Twey> Fine for me (Linux i686, Firefox 4 nightly)
10:22:43 <conal> Twey: thx
10:30:58 <McManiaC> data Nat where Nat :: Int -> Nat ? \i -> i > 0
10:31:03 <McManiaC> that would be sweet *dream*
10:31:04 <McManiaC> :D
10:31:39 <McManiaC> and not even that hard to implement I guess
10:39:07 * hackagebot gnome-keyring 0.2.2.5 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.2.2.5 (JohnMillikin)
10:39:09 <j-invariant> McManiaC: what would it do?
10:39:34 <McManiaC> only allow Int bigger than 0
10:39:41 <j-invariant> huh
10:40:10 <McManiaC> would be kindof hard to validate on runtime though
10:41:12 <McManiaC> guess you could add a new exception :>
10:41:13 <McManiaC> :D
10:41:24 <kmc> not really part of the type then
10:41:35 <kmc> or you give up the idea that Haskell is statically typed
10:41:42 <McManiaC> part of the typeconstructor
10:41:43 <kmc> but you can achieve this kind of thing with smart constructors
10:42:26 <McManiaC> s/Int/Double
10:42:33 <McManiaC> then you can't
10:43:16 <kmc> why not?
10:43:29 <McManiaC> s/you/I
10:43:30 <McManiaC> ^^
10:44:00 <kmc> you make a module, export a type PositiveDouble but not its constructor, and then you export a function which constructs them after doing a check
10:44:06 <kmc> and you implement Num etc. with similar checks
10:44:10 <McManiaC> but seriously, I dont see why that would end up in a non-statically typed haskell
10:44:25 <kmc> now, outside that module, you know statically that a PositiveDouble is positive
10:44:26 <McManiaC> it wouldn't compile if you would do something like "Nat -1"
10:44:40 <kmc> but it would compile if you did Nat (large computation that produces a negative number)
10:45:05 <j-invariant> programming with a data type  { x : Int | x < 0 } is basically impossible without full blown Theorem Proving
10:45:07 <McManiaC> the only problem would be a "Nat 3 - Nat 5", which might be legit to define but invalid to run
10:45:08 <j-invariant> built into the whole language
10:45:10 <j-invariant> am I right
10:45:53 <kmc> j-invariant, or without restricting the language in other ways
10:45:54 <McManiaC> kmc: ok, point
10:46:29 <kmc> however "full blown theorem proving", meaning dependent types, is actually a *simpler* type theory with *less stuff* than a system like Haskell's
10:46:38 <kmc> for starters, you don't have a distinction between types and terms anymore
10:47:01 <conal> kmc: not all dependent type systems identify types & terms. i think most don't.
10:47:25 <conal> kmc: maybe i missed your meaning.
10:47:31 <kmc> well you can still have a universe hierarchy
10:47:36 <kmc> i mean systems like Coq and Agda
10:48:04 <kmc> in Coq you can define types as those terms which have type Set
10:48:05 <tac-tics> And no runtime vs compile time
10:48:11 <j-invariant> what other ways are there to restrict
10:48:58 <dolio> ATS works with a separate statics and dynamics language.
10:49:28 <dolio> There's a static Int of some sort, and then a family of singletons Int i indexed by the static Int.
10:49:41 <dolio> And then you work with an existential around the family for general dynamic integers.
10:49:55 <dolio> That isn't so different from GHC.
10:50:16 <kmc> that's clever
10:50:47 <dolio> I guess. It leads to a lot of duplication.
10:51:12 <j-invariant> why can't mathematicians coem up with a way to do functions f(x,y) which can be partially applied?
10:51:29 <kmc> sounds like a good troll for #math
10:51:34 <dolio> If you look at their verified quicksort, the same thing happens.
10:52:02 <dolio> Static lists of ints, and then dynamic list singletons indexed by static lists, and an existential.
10:52:20 <kmc> dolio, are you able to read ATS, or the ATS documentation?
10:52:39 <McManiaC> what is ATS?
10:52:44 <dolio> I've only skimmed their website.
10:53:03 <kmc> www.ats-lang.org
10:53:04 <j-invariant> kmc: he told me go troll elsewhere
10:53:08 <kmc> which i guess is down?
10:53:15 <j-invariant> kmc: it was a seriously question :/
10:53:27 <McManiaC> j-invariant: f(x,·)
10:53:56 <McManiaC> ;)
10:53:57 <j-invariant> McManiaC: why don't we use that when doing differentials? dx etc
10:54:17 <McManiaC> what do you mean?
10:54:28 <kmc> j-invariant, questions with "why can't you solve this problem, dumbasses" are trolls
10:54:58 <teki> j-invariant: in some aspects, the differential operator D is a function that can be partially applied
10:55:09 <teki> for example, take D_x (the differential with respect to x)
10:55:16 <j-invariant> D_x huh
10:55:22 <kmc> why doesn't haskell have a way to add two numbers? DUMBASSES
10:55:51 <kmc> j-invariant, that's an effective way to get help in a lot of IRC channels
10:55:58 <kmc> because people will rush to defend whatever you just insulted
10:56:13 <teki> for certrain definitions of help
10:56:18 <ksf> but we haskellers dont' have any self-esteem to start with so it won't work.
10:56:22 <kmc> hehe
10:56:28 <kmc> yeah, it doesn't go over so well here
10:56:44 <gaius65> hi!
10:56:52 <kmc> hi gaius65
10:57:08 <djahandarie> "You can't add two numbers because obviously it's a poset in the opposite category of coinductive functors"
10:57:17 <djahandarie> "Oh."
10:57:28 <kmc> you need an adding monad for  that
10:57:30 <kmc> j-invariant, the right way to troll #haskell is to act confused and angry about the difference between String and IO String
10:57:40 <kmc> just for your information
10:57:43 <sproingie> i'm sensing a "how many haskellers does it take to screw in a lightbulb" joke in process here
10:58:17 <ksf> none. haskell lightbulbs are immutabel.
10:58:18 <Jafet> "None, until it has to be turned on"
10:58:26 <sproingie> zing
10:58:46 <kmc> only two, but how did they get in there?
10:59:48 <teki> one, but he has to implement a monad for it first
10:59:56 <teki> excuse me, s/he
10:59:58 <McManiaC> j-invariant: in the risk of blaming myself, but dx isn't even a function
10:59:59 <McManiaC> :D
11:00:07 <gaius65> I have a (probably simple) question about haskell syntax. When I want to create a new type the syntax is type Name = String. When I want to have a polymorphic type, it seems I can't do type List = [a]. type List a = [a] compiles, but I'm not sure if that's right and how it works. so is then "List a" the name of the type?
11:00:07 <j-invariant> kmc: DO I HAF TO TURN MY HOLE PROGAM INTO A DAMN MONAD??
11:00:16 <djahandarie> Haha exactly
11:00:16 <kmc> now you're getting the hang of it :)
11:00:36 <ZnHxr> gaius65: 'List a' is a type for any type 'a'
11:00:39 <kmc> gaius65, it's like you're defining a function, but for types
11:00:41 <kmc> f x = x + 3
11:00:43 <kmc> List a = [a]
11:00:44 <sproingie> MonadDamn
11:00:44 <ZnHxr> gaius65: also, 'type' doesn't create a new type
11:00:49 <j-invariant> gaius65: List X is a type, List can't live on its own
11:00:51 <ZnHxr> gaius65: 'type' makes a new name for an existing type
11:00:53 <kmc> "x" / "a" is a parameter
11:01:01 <kmc> and "List" is a "type constructor" which takes one argument
11:01:04 <mtnviewmark> I am the Moand... You are the Monad... We are the Monad!  Ko ko kachoo. Ko ko kachoo....
11:01:34 <j-invariant> Monads: Once you're in you will never escape
11:01:35 <systemfault> I prefer being a walrus.
11:01:37 <gaius65> ZnHxr: I know, sry that was a bit unclear written
11:01:43 <gaius65> ok, thx :)
11:01:49 <sproingie> monads are like walrus burritos
11:02:03 <djahandarie> j-invariant, unless you have a copoint :)
11:02:13 <hank> Man why didn't we learn this in school...?
11:02:17 <tac-tics> j-invariant: if you're working in haskell, yes
11:02:20 <kmc> monads: once you're in you will never escape, except that's not true for most monads
11:02:22 <sproingie> maybe for comonads we could say the w stands for walrus
11:02:43 <tac-tics> j-invariant: monads "bleed" into the types of everything.
11:02:55 <kmc> not correct
11:02:55 <ksf> ...the monad itself can't be broken.
11:03:10 <kmc> IO works like that, but most monads don't
11:03:13 <gaius65> kmc: you mena it's like a type constructor? Cause I read you can only use type construtors for data !?
11:03:17 <kmc> IO is a strange, atypical monad
11:03:19 <gaius65> you mean...
11:03:20 <ksf> possibly the thingy you are dealing with happens to be copointed, but that got nothing to do with monads.
11:03:26 <j-invariant> gaius65: that's correct
11:03:37 <kmc> gaius65, 'data' will define a *value* constructor too
11:03:39 <ZnHxr> the w stands for wouɐp
11:03:45 <kmc> data List a = MkList [a]
11:03:58 <kmc> here 'List' is a type constructor and 'MkList' is a value constructor
11:04:03 <kmc> they live in separate worlds syntactically
11:04:03 <djahandarie> To be honest I don't like the syntax for data/type/etc, I find it to be sort of confusing
11:04:05 <tac-tics> IO is the only monad you really need to write a program, though
11:04:08 <djahandarie> How all that stuff is mixed together
11:04:17 <kmc> djahandarie, i agree; I think GADT syntax is nicer
11:04:21 <gaius65> kmc: ah, ok.
11:04:26 <kmc> if i ever write a Haskell tutorial it will use GADT syntax from page 1
11:04:44 <djahandarie> lol
11:05:00 <gaius65> kmc: beeing able to write code and knowing how the syntax is called are two worlds as well^^
11:05:06 <kmc> yes
11:06:00 <McManiaC> kmc: btw, to come back to my previous question - given that "data Nat = Zero | Succ Nat" definition, you could still produce "negative numbers" with something like "Zero `minus` Succ Zero", couldn't you? you'd need to handle that aswell?
11:06:22 <j-invariant> McManiaC: what is the type of minus?
11:06:25 <kmc> McManiaC, you have to handle that case in "minus"
11:06:27 <tac-tics> Nat can't handle negatives
11:06:31 <kmc> but it's impossible for minus to return a negative number
11:06:31 <McManiaC> minus :: Nat -> Nat -> Nat
11:06:38 <j-invariant> McManiaC: so does it just crash?
11:06:39 <sproingie> minus is an operation on two Nats.  how would you implement it?
11:06:57 <j-invariant> minus x Zero = x ; minus (Succ x) (Succ y) = minus x y
11:06:58 <tac-tics> You'd need Int = Positive Nat | Negative Nat
11:06:59 <kmc> McManiaC, it's typical in number theory to define it to clamp to zero
11:07:06 <tac-tics> Or something close
11:07:08 <kmc> or you could throw an exception (ugly)
11:08:07 <monochrom> you could infinite-loop
11:08:16 <monochrom> (elegant) :)
11:08:37 <kmc> if you clamp to zero, then subtraction is primitive-recursive
11:08:41 <McManiaC> kmc: could you maybe add a default exception handler to that type via some typeclass?
11:08:51 <tac-tics> Or require subtract to take a witness of the nonzeroness of the argument
11:09:13 <tac-tics> Or rather, the stillanaturalness of the result
11:09:14 <kmc> McManiaC, ?
11:10:58 <paolino> hello, I'm hitting my fantasy limits, can anyone hint on how to compute the diagonals of a list of lists ?
11:11:46 <dolio> It's not zeroness of the argument that's a problem.
11:11:56 <kmc> paolino, that's tricky, if you want to handle infinite lists
11:12:07 <dolio> You need: (-) : (m n : Nat) -> (n <= m) -> Nat
11:12:29 <mreh> zip the lists up with [1..]
11:12:49 <kmc> hmm maybe it's no trickier
11:12:49 <dolio> However, (inductive) proofs of (n <= m) look exactly like m - n.
11:12:54 <tromp_> zipWith (!!)
11:13:03 <kmc> oh, i was thinking of transposition
11:13:07 <mreh> :t zipWith (!!) [1..]
11:13:09 <lambdabot> forall a. (Num [a], Enum [a]) => [Int] -> [a]
11:13:11 <paolino> kmc, it's ok for finite ones to begin
11:13:12 <mtnviewmark> let diag = transpose . zipWith drop [0..] . repeat in diag [[1..5], [10,20..50], [100,200..500]]
11:13:25 <mreh> :t zipWith (flip (!!)) [1..]
11:13:26 <lambdabot> forall a. [[a]] -> [a]
11:13:27 <mtnviewmark> > let diag = transpose . zipWith drop [0..] . repeat in diag [[1..5], [10,20..50], [100,200..500]]
11:13:39 <lambdabot>   [[
11:13:51 <mreh> transpose is really pretty with zipWith
11:14:12 <McManiaC> kmc: well, my point is that you can already run into such problems where you don't know how to define a function for a given (valid) data type… I don't see any difference between a "value predicate" for a data type as in "Nat :: Int -> Nat ? \x -> x > 0" and that "data Nat = Zero | Succ Nat" definition
11:14:13 <mreh> and applicative
11:14:36 <kmc> McManiaC, the difference is if I give you a Nat, you know it's non-negative
11:14:38 <kmc> by definition
11:14:46 <mreh> why couldn't ZipList be th default list applicative :(
11:14:51 <paolino> mh, did I write diagnal ?
11:14:58 <McManiaC> kmc: that applies to both versions
11:15:06 <c_wraith> mreh: so that the applicative instance is compatible with the Monad instance
11:15:10 <paolino> I meant diagonals 
11:15:16 <mtnviewmark> > let diag = transpose . zipWith drop [0..]  in diag [[1..5], [10,20..50], [100,200..500]]
11:15:17 <kmc> McManiaC, that's true, but that value predicate feature doesn't exist in Haskell
11:15:18 <mreh> c_wraith, yes I suppose
11:15:18 <lambdabot>   [[1,20,300],[2,30,400],[3,40,500],[4,50],[5]]
11:15:23 <kmc> anyway i don't know what we're arguing about
11:15:30 <mtnviewmark> not quite perfect, but a start
11:16:07 <McManiaC> kmc: it's an idea I'm thinking about… I'm a bit into GHC hacking and just wondered what other might think about it :D
11:16:26 <kmc> i think it's a cool feature
11:16:33 <mreh> > splitAt 5 [1..10]
11:16:34 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
11:16:54 <McManiaC> kmc: ok, then I misunderstood you earlier :)
11:17:04 <mtnviewmark> paolino: Is that the sort of thing you are looking for?
11:17:09 <paolino> yes
11:17:25 <mtnviewmark> but you probably want the missing lower-left diagonals too?
11:17:25 <kmc> McManiaC, people might get confused by the interaction with laziness
11:17:34 <paolino> mtnviewmark: half :)
11:17:51 <kmc> and i think adding more constructs which can throw exceptions from pure computation will be controversial
11:18:14 <paolino> I did one with cycle and splitAt
11:18:25 <paolino> but it's ugly
11:18:30 <mreh> > uncurry (((:[]) .) (:)) . splitAt 5 [1..10]
11:18:31 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
11:19:40 <mreh> I think this is a case for unfolfd
11:19:44 <mreh> unfoldr
11:19:48 <paolino> I didn't check it was even working actually, 3 lines of haskell to compute diagonals was too much
11:20:51 <kuffaar> @quote SPJ works
11:20:51 <lambdabot> SPJ says: "If it compiles, it works."
11:21:07 <Jafet> @quote work
11:21:07 <lambdabot> Randroid says: I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
11:21:19 <paolino> in fact it works
11:22:02 <mtnviewmark> ah
11:22:39 <paolino> ok I will spend the 2 and half hour of google jam to think about diagonals, instead of resolving 3 hard problems :)
11:23:03 <McManiaC> kmc: hmhm
11:23:15 <sproingie> (((:[]) .) (:)) could probably be something obscene in emoticon-speak
11:23:30 <mtnviewmark> > let diag = transpose . zipWith drop [0..], diagonals x = (reverse . drop . diag . transpose $ x) ++ diag x in  diagonals (zipWith (map . (*)) [1,10,100,1000,10000] $ repeat [1..5])
11:23:31 <lambdabot>   <no location info>: parse error on input `,'
11:23:42 <mtnviewmark> > let diag = transpose . zipWith drop [0..]; diagonals x = (reverse . drop . diag . transpose $ x) ++ diag x in  diagonals (zipWith (map . (*)) [1,10,100,1000,10000] $ repeat [1..5])
11:23:43 <lambdabot>   Couldn't match expected type `[a]'
11:23:43 <lambdabot>         against inferred type `[a1] -> [...
11:24:17 <mtnviewmark> > let diag = transpose . zipWith drop [0..] in let diagonals x = (reverse . drop . diag . transpose $ x) ++ diag x in  diagonals (zipWith (map . (*)) [1,10,100,1000,10000] $ repeat [1..5])
11:24:18 <lambdabot>   Couldn't match expected type `[a]'
11:24:18 <lambdabot>         against inferred type `[a1] -> [...
11:24:43 <paolino> I thought some join [[False,True]] could magically resolve :-(
11:25:17 <mtnviewmark> > let diag = transpose . zipWith drop [0..] in let diagonals x = (reverse . tail . diag . transpose $ x) ++ diag x in  diagonals (zipWith (map . (*)) [1,10,100,1000,10000] $ repeat [1..5])
11:25:19 <lambdabot>   [[10000],[1000,20000],[100,2000,30000],[10,200,3000,40000],[1,20,300,4000,5...
11:25:30 <mtnviewmark> ta da
11:26:48 <mtnviewmark> > let diag = transpose . zipWith drop [0..] in let diagonals x = (reverse . tail . diag . transpose $ x) ++ diag x in  diagonals  [[r,c]|r<-"abcde",c<-"12345"]
11:26:52 <lambdabot>   ["e","e5","e4","e3","e2","d1","d5","d4","d3","d2","c1","c5","c4","c3","c2",...
11:27:02 <mtnviewmark> oops
11:27:18 * hackagebot Biobase 0.1.0.1 - Base library for bioinformatics  http://hackage.haskell.org/package/Biobase-0.1.0.1 (ChristianHoener)
11:27:28 <evaryont> Is there a way to call the Xlib function 'XGetDefault' from Graphics.X11.Xlib? I don't see any particular reference to it in the api docs however..
11:27:40 <paolino> mtnviewmark: this breaks the SPJ works
11:27:55 <mtnviewmark> ?
11:28:03 <paolino> it compiles 
11:28:03 <mtnviewmark> what is the SPJ works?
11:28:13 <paolino> and don't work
11:28:35 <mtnviewmark> oh - it worked up there... it was just diagonalizing the wrong thing!  
11:28:59 <Jafet> Obviously, you didn't use enough typeclasses for SPJ works to work
11:29:17 <paolino> right
11:30:22 * paolino ponders what unfoldr has to do with diagonals
11:31:51 <mtnviewmark> > let diag = transpose . zipWith drop [0..] in let diagonals x = (reverse . tail . diag . transpose $ x) ++ diag x in  diagonals  [map ((r:).(:[])) "12345" | r<-"abcde"]
11:31:53 <lambdabot>   [["e1"],["d1","e2"],["c1","d2","e3"],["b1","c2","d3","e4"],["a1","b2","c3",...
11:32:03 <mtnviewmark> there -- I was just generating the wrong test data
11:33:38 <paolino> @src transpose
11:33:38 <lambdabot> transpose []             = []
11:33:38 <lambdabot> transpose ([]   : xss)   = transpose xss
11:33:38 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:35:11 <medfly`> @seen wli
11:35:12 <preflex>  wli was last seen on #haskell-blah 111 days, 1 hour, 33 minutes and 7 seconds ago, saying: boshhead: Instead of making the derivatives match up to the n-th order at a single point (Taylor series) you can use several points, or both ends of an interval, or similar.
11:35:12 <lambdabot> Unknown command, try @list
11:38:09 <mreh> what time does Hyde park close?
11:38:16 <mreh> oops
11:38:55 <Zao> mreh: Half past Jekyll.
11:38:56 <kmc> walking through Hyde Park at 2 AM sounds like fun
11:39:36 <paolino> @pl \x -> f x . g
11:39:36 <lambdabot> (. g) . f
11:39:59 <mreh> closes at midnight, so ha you can't!
11:40:12 <mreh> kmc: are you in London
11:40:14 <kmc> no
11:40:21 <kmc> i assumed you meant the one in Chicago
11:40:24 <kmc> for no particular reason
11:46:50 <timbaum> perhaps someone wants to have a look at some code I wrote and give comments: http://codepad.org/kXzUQGtP
11:47:02 <Adamant> kmc: you're just bored with the uuuuk
11:52:51 <paolino> :t msum
11:52:52 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:05:02 <monochrom> The Hide Park has no hidden parts.
12:05:59 <Adamant> you can't see the Hide Park, it's hiding
12:06:58 <monochrom> Why is the Invisible Man not called Mr. Hyde?
12:07:59 <paolino> H-IDE is parking
12:09:35 <monochrom> In front of a house is a "driveway" where cars may park.
12:09:56 <monochrom> In Toronto we have a "Don Valley Parkway" which is a highway.
12:10:19 <monochrom> This begs the question "why do we drive on a parkway and park on a driveway"
12:32:46 <Egbert9e9> leksah is any good?
12:33:25 <timbaum> in my opinion, it's an alternative for e.g. emacs
12:33:36 <timbaum> with advantages and disadvantages
12:37:23 <kuffaar> ghci says it can't find my package :'(
12:37:30 <kuffaar> When I compile stuff with cabal it works fine though
12:45:32 <Egbert9e9> timbaum, thanks :)
12:53:23 <tolkad> I just figured out how to get infinite amounts of memory in haskell!
12:53:41 <tolkad> HeapOverflow is an asynchronous exception
12:53:56 <tolkad> just use mask and it can't be thrown!
12:53:58 <aristid> tolkad: quick write it down before you wake up from your dream
12:54:29 <aristid> this channel is logged, but will the log file survive your waking up?
12:54:34 <kmc> a crazy loophole the wrong guy discovered
12:55:47 <tolkad> but seriously, does mask work on heap overflow exceptions? what happens if a computation in a masked thread requires memory and a heap overflow exception has been thrown?
12:56:13 <tolkad> oh GHC doesn't even throw it
12:56:13 <aristid> i guess it will lead to a funny crash
12:56:16 <kmc> nothing good
12:56:37 <ben> That's like when I tried to fix segfaults in C by catching SIGSEGV and ignoring it <:)
12:56:48 <kmc> just map a readable page at 0
12:56:51 <kmc> problem. solved.
12:57:02 <kmc> (modern linux forbids this for security reasons)
12:58:13 <kmc> at school we did a project implementing a "scheduler" and a "virtual memory system" in userspace by handling SIGALRM and SIGSEGV respectively
12:58:34 <kmc> it was adorably janky
12:59:59 <mreh> what kind of school was that?
13:05:41 <paolino> > app . ((++) . transpose . map reverse *** transpose) .  unzip . zipWith (splitAt) [0..] $ [map ((r:).(:[])) "12345" | r<-"abcde"]
13:05:43 <lambdabot>   [["b1","c2","d3","e4"],["c1","d2","e3"],["d1","e2"],["e1"],["a1","b2","c3",...
13:07:27 <Entroacceptor> Bc3
13:13:31 <c1de0x> aw. where is pumpkin?
13:13:36 <c1de0x> http://twitter.com/#!/c1de0x/status/27112320320671744
13:14:32 <pastorn> is there a better way to do this with parsec? (fmap Just (try pMove) <|> return Nothing)
13:14:55 <pastorn> i looked at option a little, but i'm scared of it
13:15:24 <pastorn> i have a hard time parsing its documentation :(
13:15:27 <pastorn> "option x p tries to apply parser p. If p fails without consuming input, it returns the value x, otherwise the value returned by p."
13:15:59 <pastorn> if you change that to "If p fails, without consuming input..." it means something different :/
13:16:17 <pastorn> do i myself have to guarantee that wathever parser i give 'option' doesn't consume anything?
13:16:20 <c1de0x> pastorn what part is difficult?
13:16:33 <kmc> pastorn, what about option . try then?
13:16:37 <kmc> try ensures it won't consume input
13:17:10 <aristid> pastorn: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Applicative.html#optional
13:17:13 <pastorn> kmc: so (optionMaybe (try pMove))
13:20:47 * hackagebot http-enumerator 0.3.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.3.1 (MichaelSnoyman)
13:21:49 * hackagebot warp 0.3.0 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.3.0 (MichaelSnoyman)
13:21:51 * hackagebot xml-enumerator 0.1.0 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.1.0 (MichaelSnoyman)
13:21:53 * hackagebot fuzzytime 0.5 - A clock which tells the time in a more familiar way  http://hackage.haskell.org/package/fuzzytime-0.5 (KamilStachowski)
13:21:56 <Evious> Woah look at 'em dependencies.
13:23:31 <pastorn> holy shit... fuzzytime has a line which is 436 characters wide :/
13:34:07 <cheater-> pastorn: why is that notable?
13:34:49 <dolio> That's 4 to 5 times as wide as any line of Haskell I've ever written.
13:35:01 <pastorn> surely that line was never meant to be read
13:35:05 <pastorn> even though it's a comment
13:41:35 <teki> do I need the bangpatterns pragma in a strict data type?  or is the syntax just suggestively similar by design?
13:41:48 <kmc> strict data fields are in Haskell 98 i believe
13:41:54 <kmc> so, the latter
13:41:56 <dolio> Prior to that, even.
13:41:58 <teki> ah okay
13:42:16 <kmc> yeah, we have old-timers who can tell you about Haskell 1.2
13:42:20 <kmc> i am not one of those :)
13:42:45 <dolio> I'm not an old-timer, but I've looked at the old reports.
13:42:51 <teki> the syntax also happens to correspond to data.map's (!) command, which is annoying
13:42:54 * kmc dimly remembers installing Hugs when he was about 12 and never really using it or getting the point
13:42:55 <teki> oh well, small fry
13:43:05 <dolio> Strict data types are the only situation where H98 data type constraints make sense, too.
13:43:14 <sproingie> hugs had friendlier error messages
13:43:14 <kmc> oh, how so?
13:43:26 <dolio> For pre-98 versions of seq, which required a constraint.
13:43:37 <kmc> *nod*
13:43:40 <dolio> So 'data Eval a => Foo a where Foo !a'
13:43:51 <dolio> Because the constraint needs to go on the constructor.
13:44:28 <kmc> and you still have the problem that pattern-matching on Foo doesn't give you the Eval context, but that's probably useless anyway
13:44:36 <dolio> Probably.
13:44:54 <dolio> But at least it has some use, instead of no use.
13:45:50 <dolio> Although, it's still a little odd for an entire feature (the constraints) to be introduced just for that special case.
13:50:05 <kmc> agreed
13:50:26 <kmc> there is a tendency towards coming up with general solutions to problems which are only obvious in a few specific cases
13:50:49 <kmc> and sometimes this is wildly successful
13:50:54 <Fuco> what would you recommend as a followup to LYAH?
13:51:05 <kmc> and sometimes you make a useless general feature
13:51:16 <kmc> Fuco, probably RWH
13:51:17 <Fuco> I'd like to see some more complex but not too complex tutorials :P
13:51:21 <kmc> but mostly, just start coding
13:51:26 <kmc> and learn what you need to do what you want to do
13:51:36 <kuffaar> Fuco: Yeah possibly Real World Haskell
13:51:50 <kmc> RWH is a good read anyway
13:52:01 <kuffaar> Fuco: I must admit, I read less than 20% of either of those and I just started coding
13:52:08 <kmc> i think that's the way to do it
13:52:11 <kuffaar> But I'm still shit at Haskell
13:52:13 <aristid> Fuco: i guess a nice first project might be a calculator.
13:52:16 <kmc> i read less than 20% of the Gentle Introduction and then just started coding
13:52:25 <kmc> Fuco, there's also the "write yourself a scheme in 48 hours" tutorial
13:52:46 <tolkad> @pl (\f g x y -> f (g x y))
13:52:46 <lambdabot> (.) . (.)
13:52:57 <Fuco> by scheme you mean the LISP dialect right?
13:53:00 <kmc> yes
13:53:10 <kmc> implementing Scheme in Haskell is a reasonable beginner-ish project
13:53:13 <Fuco> I've wrote some very primitive in scala :P
13:53:16 <kuffaar> My first project in Haskell was a multi threaded SCGI server with a web development framework with OpenID auth support, a unified markup/LaTeX generation language, some YAML parsing and some PostgreSQL IO
13:53:26 <kuffaar> It's not quite done yet
13:53:29 <kmc> kuffaar, but was it webscale?!?!?!?
13:53:29 <aristid> kuffaar: i.e. much too complex.
13:53:36 <tolkad> @pl (\x y -> print (show x y))
13:53:36 <lambdabot> (print .) . show
13:53:48 <Fuco> webscale :P
13:53:49 <kuffaar> kmc: What does webscale mean in non-suit talk?
13:53:55 <Botje> kuffaar: and your second will be the halting problem or something?
13:53:57 <kmc> i only meant the suit-talk joke
13:53:58 <aristid> tolkad: that would be interesting if it made any sense at all
13:54:00 <Fuco> the scheme thing it is, it sounds good
13:54:04 <Fuco> thanks for now :)
13:54:05 <kmc> (though i'm kind of over the whole "lol suits" thing)
13:54:13 <kmc> (makes it too easy to make fun of people who do hard things you don't understand)
13:54:14 <kuffaar> aristid: Well, you got to start somewhere, right?
13:54:18 <aristid> @pl \x y -> f (g x y)
13:54:18 <lambdabot> (f .) . g
13:54:22 <kuffaar> I don't want to write things I don't actually need :|
13:54:33 <aristid> tolkad: which is the same as f .: g :)
13:54:37 <tolkad> aristid: I was just curious if I was correct in how to compose a 2 argument function
13:55:06 <aristid> where (.:) = fmap.fmap or (.:) = (.).(.) [depending on taste]
13:55:39 <aavogt> > let (...) = const in 1 ... 2
13:55:40 <lambdabot>   1
13:56:28 <Fuco> damnit, our library doesn't have RWH :(
13:56:30 <ndrsndrs> aristid: fmap fmap fmap, obviously.
13:56:37 <kmc> Fuco, it's free online
13:56:39 <Fuco> I'm gonna have to make a suggestion
13:56:39 <kuffaar> Fuco it's available online
13:56:43 <Fuco> oh :P
13:56:46 <kmc> @where rwh
13:56:47 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:56:51 <tolkad> > mapM_ putStrLn [1..]
13:56:52 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
13:56:52 <lambdabot>    arising from the literal `...
13:56:52 <Fuco> still, I like paper better :P
13:56:54 <kuffaar> However I am still considering making a nice ePub/PDF version of it
13:57:03 <pastorn> Fuco: the on-line version has comments
13:57:03 <kuffaar> I also made a LaTeX version of LYAH lol
13:57:04 <kmc> i don't understand why anyone prefers to read a programming book on dead tree
13:57:07 <kuffaar> Programmatically
13:57:10 <tolkad> > mapM_ putStrLn (map show [1..])
13:57:12 <lambdabot>   <IO ()>
13:57:13 <kuffaar> kmc agreed
13:57:19 <kmc> search? copy-paste? syntax highlighting? hyperlinks to language documentation?
13:57:20 <kuffaar> kmc: Print media is dead to me
13:57:23 <kmc> aren't these kind of important?
13:57:35 <kuffaar> It took me long enough to get rid of all my printed books
13:57:50 <Fuco> well for me it helps to concentrate
13:57:51 <kuffaar> kmc I do use an e-reader for reading in bed shortly before I pass out
13:57:54 <ddarius> kmc: How does a book fail to have syntax highlighting?
13:57:56 <Fuco> on computer there's so many distractions
13:58:01 <kmc> ddarius, most books are printed in few colors
13:58:15 <kmc> i like print media for some things but for a practical intro to a programming language it's hilariously backward
13:58:22 <Fuco> I can take the book to our cabin in the woods and read it there for instance :P
13:58:31 <ddarius> kmc: As are most PDFs, and in fact most web sites.
13:58:37 <djahandarie> I don't print websites
13:58:59 <kmc> you can take a laptop to a cabin in the woods
13:59:04 <tolkad> kmc: books smell nice
13:59:07 <kmc> or are you going to read about programming without being able to program?
13:59:17 <Zao> You can't burn laptops well.
13:59:32 <aavogt> writing on laptops isn't as useful
13:59:57 * hackagebot regions 0.8.1 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.8.1 (BasVanDijk)
13:59:58 * kuffaar codes on both desktops and notebooks
14:00:13 <kuffaar> I don't do anything other than IRCing and coding during lectures at university really
14:00:29 <kuffaar> People are frequently irritated by the clickedieclack from my keyboard
14:00:40 <kmc> Zao, you can do it but it's not good for you
14:00:51 <kmc> i always thought the name "Kindle" was a bit morbid
14:00:53 <Zao> Thus the "well" bit.
14:00:56 <kuffaar> kmc but it's good for the environment
14:00:58 * hackagebot usb 0.7 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.7 (BasVanDijk)
14:00:58 <monochrom> you need a silent keyboard
14:01:36 <Botje> dasher!
14:01:40 <Botje> then you can write with your touchpad!
14:01:43 <tolkad> monochrom: like a neural interface
14:01:50 <Entroacceptor> kmc: I like typing myself
14:02:00 * hackagebot usb-enumerator 0.2.0.2 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.2.0.2 (BasVanDijk)
14:02:01 <Entroacceptor> (while learning)
14:02:02 * hackagebot usb-safe 0.11.0.2 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.11.0.2 (BasVanDijk)
14:02:39 <kmc> basically i understand an aesthetic preference for print books but, for practical programming books, the concrete advantages of electronic copy are so huge that i don't see why anyone actually prefers the print version
14:02:59 <monochrom> copy paste code
14:03:04 <kmc> yeah it smells nice but do you make most decisions in life based on what smells nice?
14:03:09 <kmc> i bet some people do
14:03:18 <aristid> kmc: reading long texts on a 1280x800 laptop is simply fucking annoying.
14:03:36 <monochrom> programming books need to be shorter
14:03:37 <Entroacceptor> and I dig high dpi
14:03:43 <Botje> turn it sideways :]
14:03:48 <kmc> ^^^ this
14:04:03 <kmc> aristid, the solution is to get a laptop that doesn't suck
14:04:15 <aristid> kmc: books are cheaper.
14:04:21 <kmc> isn't programming on a 1280x800 laptop also fucking annoying?
14:04:28 <aristid> no, it works :)
14:04:35 <Zao> kmc: Not worse than a 1024x600.
14:04:38 <aristid> i don't know, which resolution do you have?
14:04:45 <djahandarie> Not worse than a 800x600
14:04:59 <tolkad> I have 1440x900 and it's not so bad
14:04:59 <Entroacceptor> kmc: think of it, a book is like an extra screen
14:05:02 <aristid> not worse than 320x400
14:05:13 <aristid> tolkad: that's significantly better than 1280x800
14:05:21 <kmc> RWH costs about half as much as a new LCD monitor
14:05:23 <aristid> tolkad: but still not really nice for reading long texts
14:05:26 <pastorn> kmc: what dou you have?
14:05:31 <pastorn> i have 1400x1050
14:05:31 <kmc> laptop-wise?
14:05:35 <pastorn> yeah
14:05:45 <kmc> thinkpad x200s
14:05:46 <monochrom> 320x400 was only available on 10kg 20"x20"x20" crt monitors :)
14:05:46 <aristid> kmc: i don't have any space for a LCD monitor. i always use my computer while sitting on the bed or on a couch.
14:05:47 <kmc> 1440x900
14:05:51 <kmc> abnormally high dpi
14:05:59 <pastorn> kmc: X61 tablet
14:06:08 <pastorn> i beat you by 150 pixels :p
14:06:13 <kmc> omg
14:06:21 <tolkad> aristid: I can fit 68 lines of text in my editor window
14:06:37 <monochrom> you need to project to the ceiling
14:06:41 <kmc> it also depends on how good your eyesight is
14:06:46 <kmc> in terms of what font size is acceptable
14:06:51 <aristid> tolkad: emacs in my current settings fits 35 lines. i could use a smaller font, of course.
14:07:05 <aristid> but i don't want to strain my eyes too much
14:07:06 <kmc> i don't have a problem spending all day staring into glowing rectangles, but i can see that some would
14:07:31 <pastorn> i wish i could afford some new monitors
14:07:33 <monochrom> I can fit 2000 lines of text in my 1280x800 screen. <duck>
14:07:50 <aristid> monochrom: scrolling does not count :P
14:07:51 <ion> In Soviet Russia, glowing rectangles watch you.
14:08:12 <monochrom> I gzip the lines
14:08:30 <tolkad> aristid: I can fit 125 if I switch to a ridiculous barely legible subpixel font
14:09:02 <pastorn> tolkad: what about the xterm font?
14:09:11 <aristid> tolkad: lol. i use DejaVu Sans Mono 10pt
14:09:35 <aristid> i like the big font, because ... well, i'm torturing my eyes enough already.
14:09:36 <pastorn> best font: http://www.dafont.com/monofur.font </discussion>
14:09:49 <kmc> you can represent 64 letters using only 2 pixels and their three color components
14:09:52 <pastorn> it makes you happy
14:09:52 <tolkad> pastorn: idk, I use Monaco
14:09:57 <kmc> so just do that
14:09:58 <pastorn> tolkad: macfag?
14:10:02 <tolkad> pastorn: yeah
14:10:16 <pastorn> tolkad: check out the small 'e'
14:10:25 <aristid> pastorn: screenshot of haskell code in that font? :D
14:10:41 <pastorn> aristid: 2 secs...
14:10:54 <monochrom> it doesn't have λ and π
14:11:03 <aristid> tolkad: which font size do you use?
14:11:06 <aristid> monochrom: monaco?
14:11:06 <pastorn> http://users.mkeyd.net/~alexander/monofur_haskell.png
14:11:14 <monochrom> monofur
14:11:19 <ion> monochrom: That’s not very relevant when font fallbacks are there, though.
14:11:33 <tolkad> aristid: the lowest available without going into ugly subpixel mode, 9
14:11:34 <aristid> pastorn: ugh. terrible.
14:11:40 <systemfault> My best programming fonts are Monaco/Inconsolata/DejaVu Sans Mono and Anonymous Pro
14:11:42 <pastorn> aristid: NO U
14:11:43 <systemfault> :P
14:12:02 <pastorn> systemfault: i used to be an Inconsolata fanboi, but switched away
14:12:51 <aristid> DejaVu Sans Mono is also installed by default
14:12:52 <aristid> big plus
14:13:10 <pastorn> aristid: bah, i just place whatever i want in ~/.fonts/
14:13:36 <pastorn> works with all *nix:es i've ever tried
14:14:42 <aristid> pastorn: the lower-case s in monofur looks right-biased in an ugly way
14:14:56 <tolkad> real programmers use papyrus
14:15:06 <aristid> and comic sans ms
14:15:18 <pastorn> aristid: NO U
14:15:26 <pastorn> aristid: right-biased?
14:16:03 <aristid> pastorn: look at for example Parser in your example. it almost looks like there is a space between Par and ser
14:16:53 <pastorn> aristid: fagg u maffaga... now i'll notice that the s:s are too thin
14:16:59 <pastorn> i'll have to change font
14:17:01 <pastorn> aristid: i hate u
14:17:06 <revenantphx> Fucking haskell...
14:17:18 <revenantphx> I'm told to look into WWF for an internship thing.
14:17:39 <systemfault> I should switch to webding
14:17:43 <revenantphx> And I see a diagram, and it's showing some modular actions that can be composed. 
14:17:51 <tolkad> revenantphx: world wildlife foundation?
14:17:54 <revenantphx> And my brain instantly goes "monad? what?"
14:18:01 <revenantphx> Windows Workflow Framework
14:18:05 <revenantphx> aka WF
14:18:17 <dobblego> djahandarie, did you release your ala function?
14:18:48 <tolkad> revenantphx: oh is this some proprietary Microsoft thing?
14:18:52 <revenantphx> Yep.
14:19:07 <revenantphx> At least C# lets me use some FP things :P
14:19:48 <kmc> yes, like monad syntax
14:19:52 <Zao> Isn't it under MSPL?
14:19:53 <revenantphx> :P
14:19:57 <Zao> Or am I confusing it with other TLAs?
14:20:21 <revenantphx> ?
14:20:27 <tolkad> revenantphx: write a haskell-to-CIL compiler ;P
14:20:33 <aristid> MSPL is not a TLA
14:20:34 <revenantphx> I'm sure someone has...
14:20:42 <kmc> of course they change the names because, everyone knows lambdas and monads are useless academic wankery, but delegates and LINQ are industrial-strength and enterprise-ready
14:20:45 <Zao> aristid: WWF is, however.
14:20:49 <aristid> Zao: indeed.
14:21:00 <pastorn> kmc: hahahah
14:21:02 <revenantphx> kmc: haha.
14:21:05 <kmc> not to mention webscale
14:21:08 <revenantphx> webscale!
14:21:12 <pastorn> kmc: webscale?
14:21:15 <kmc> on the cloud
14:21:16 <pastorn> never heard of
14:21:28 <tolkad> ¿webscale?
14:21:37 <revenantphx> @let bullshitTerms = ["webscale"]
14:21:40 <lambdabot>  Defined.
14:21:53 <ion> I’m already using webscale 2.0.
14:21:54 <revenantphx> @let bullshitTerms = ["webscale", "business intelligence"]
14:21:55 <lambdabot>  <local>:3:0:
14:21:55 <lambdabot>      Multiple declarations of `L.bullshitTerms'
14:21:55 <lambdabot>      Declared a...
14:22:01 <revenantphx> hrm
14:22:08 <pastorn> @let bullshitTerms = ["webscale", "cloud", "business intelligence"]
14:22:09 <kmc> i upgraded to web 3.0 a while back
14:22:09 <lambdabot>  <local>:3:0:
14:22:09 <lambdabot>      Multiple declarations of `L.bullshitTerms'
14:22:09 <lambdabot>      Declared a...
14:22:15 <pastorn> @unlet
14:22:15 <lambdabot>  Defined.
14:22:17 <pastorn> @let bullshitTerms = ["webscale", "cloud", "business intelligence"]
14:22:17 <lambdabot>  <local>:4:0:
14:22:17 <lambdabot>      Multiple declarations of `L.bullshitTerms'
14:22:18 <lambdabot>      Declared a...
14:22:18 <revenantphx> http://cl.ly/43SY
14:22:19 <revenantphx> so guys.
14:22:25 <ion> "intellectual property"
14:22:26 <pastorn> @unlet bullShitTerms
14:22:26 <lambdabot>   TemplateHaskell is not enabled
14:22:28 <revenantphx> Why do these "activities" remind me of IO Actions so much?
14:22:31 <pastorn> @let bullshitTerms = ["webscale", "cloud", "business intelligence"]
14:22:31 <lambdabot>  <local>:4:0:
14:22:31 <lambdabot>      Multiple declarations of `L.bullshitTerms'
14:22:31 <lambdabot>      Declared a...
14:22:32 <tolkad> pastorn: webscale applications are software that could be considered "enterprise ready". it means they have the scalability required for cutting edge web 2.0
14:22:46 <pastorn> tolkad: lulz
14:22:46 <revenantphx> Can we just get onto web 3.0 already?
14:22:48 <kmc> but are they agile
14:22:54 <EvanR-work> how does ghc handle out of memory?
14:22:56 <revenantphx> agile. rofl.
14:22:58 <kmc> guys does haskell support agile scrum development?
14:23:14 <kmc> as a Certified Registered ScrumMaster ™ i demand to know
14:23:16 <Botje> @faq @faq does Haskell support agile scrum development?
14:23:17 <EvanR-work> lol
14:23:17 <lambdabot> The answer is: Yes! Haskell can do that.
14:23:20 <Botje> oops
14:23:20 <fmapE> does anyone know what the status of the next Haskell Platform is?
14:23:23 <kmc> EvanR-work, not very well
14:23:30 <kmc> it throws your thread an exception, maybe
14:23:36 <EvanR-work> maybe?
14:23:45 <kmc> yes, what if there's not enough memory for that :D
14:23:56 <kmc> most Linux systems can't run out of memory though
14:24:01 <tolkad> fmapE: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
14:24:10 <kmc> they just promise arbitrarily much memory and then start killing random processes if it can't be fulfilled
14:24:25 <tolkad> fmapE: next stable version should be released on feb 1
14:25:01 <fmapE> tolkad: Yes, that hasn't been updated since november, most of the deadlines there are past, do I just not know where the beta releases are?
14:25:21 <fmapE> (the darcs repo is basically useless)
14:25:33 <tolkad> fmapE: idk, I spent half an hour trying to find them and then gave up and just updated ghc by itself.
14:25:37 <pastorn> maybe the next one will have ghc7?
14:26:05 * hackagebot accentuateus 0.9 - A Haskell implementation of the Accentuate.us API.  http://hackage.haskell.org/package/accentuateus-0.9 (MichaelSchade)
14:26:14 <fmapE> tolkad: I'm on OS X and want to use GHC7 64bit
14:26:32 <tolkad> fmapE: same here. I just updated ghc on its own
14:26:35 <fmapE> hm
14:26:43 <fmapE> and that didn't break all of your cabal packages?
14:26:52 <tolkad> not that I know of
14:27:46 <fmapE> ok
14:27:52 <fmapE> I'll give that a shot
14:27:53 <EvanR-work> kmc: interesting
14:28:09 <EvanR-work> but i suppose haskell isnt meant for platforms without infinite memory ;)
14:28:31 <kmc> there's a good metaphor for it here: http://lwn.net/Articles/104179/
14:28:42 <tolkad> EvanR-work: haskell isn't even turing complete without infinite memory
14:28:55 <j-invariant> Haskell is turing complete
14:29:00 <kmc> haha
14:29:04 <sproingie> turing completeness does not mean it's a perfect turing machine
14:29:10 <kmc> that's brilliant tolkad
14:29:22 <sproingie> oh i forgot it was troll hour :)
14:29:25 <kmc> master troll
14:29:32 <gaius65> what does a point mean in haskell? like (tail.tail) someList
14:29:37 <kmc> @src (.)
14:29:37 <lambdabot> (f . g) x = f (g x)
14:29:37 <lambdabot> NB: In lambdabot,  (.) = fmap
14:29:44 <kmc> it's an infix operator
14:29:45 <tolkad> gaius65: function composition
14:29:51 <kmc> corresponding to function composition
14:30:01 <sproingie> lambdabot speaks caleskell
14:30:05 <tolkad> gaius65: (.) f g x = f (g x)
14:30:14 <aavogt> @remember tolkad haskell isn't even turing complete without infinite memory
14:30:15 <lambdabot> Good to know.
14:30:25 <gaius65> ah, thx
14:30:42 <j-invariant> lambda claculus isnt turing complete
14:30:59 <j-invariant> since it's impossible to write down an infinite sequence of beta reductions
14:31:04 <mreh> claculus?
14:31:24 <EvanR-work> clatu, barata.... ni*cough cough*
14:31:28 <j-invariant> turing machines aren't turing complete because tape costs 30 dollars a roll and I only have 60 dollars
14:31:34 <mreh> how do I win over my friends who are still slaving away at the von neumann architecture?
14:31:45 <mreh> heh
14:31:57 <mreh> *CS knowledge required
14:32:23 <tg_> introduce them to memristors and ask them how it can efficiently work word-at-a-time?
14:32:37 <tg_> if it's used as a logic device (which it can be)
14:33:13 <Adamant> memristors über alles
14:37:39 <joe6> is there a function that can do: a -> (a -> b -> c) -> b -> c
14:37:42 <djahandarie> dobblego, oh whoops
14:37:48 <djahandarie> I actually have that ready to go
14:37:53 <kmc> @djinn a -> (a -> b -> c) -> b -> c
14:37:54 <lambdabot> f a b = b a
14:38:20 <kmc> :t flip ($)
14:38:21 <lambdabot> forall a b. a -> (a -> b) -> b
14:38:25 <djahandarie> Do I need to do something special to get the docs on hackage?
14:38:28 <kmc> it's a specialization of that
14:38:43 <joe6> kmc: more thoughts please .  i could not understand.
14:38:44 <dobblego> djahandarie, no it is generated, just type cabal check
14:38:49 <djahandarie> Okay
14:38:49 <joe6> kmc: sorry for being thick
14:39:03 <pastorn> @type flip flip
14:39:03 <kmc> let b = s -> t
14:39:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
14:39:09 <pastorn> ugh...
14:39:17 <kmc> flip ($) :: a -> (a -> s -> t) -> s -> t
14:39:19 <djahandarie> Gah, need to write a description
14:39:20 <kmc> that's what you asked for yes?
14:39:22 <pastorn> @pl \x f y -> f x y
14:39:22 <lambdabot> flip id
14:39:31 <pastorn> joe6: ^^^
14:39:39 <joe6> pastorn: yes
14:39:39 <kmc> flip id = flip ($)
14:39:42 <joe6> pastorn: thanks.
14:39:53 <pastorn> kmc: flip id is shorter :p
14:39:55 <kmc> in fact ($) is id with a restricted type
14:40:02 <revenantphx> So guys.
14:40:03 <revenantphx> http://cl.ly/44dm
14:40:11 <revenantphx> How is this "Workflow" shenanigans not just the IO monad.
14:40:19 <revenantphx> "In this simple example, the workflow begins with a ReceiveMessage activity that gets input from the outside world."
14:40:21 <ddarius> kmc: Not exactly...
14:40:24 <revenantphx> hmmmmm....
14:40:38 <revenantphx> composable... modular... "activities"....
14:40:41 <j-invariant> ($) = id
14:40:47 <kmc> i thought "workflows" was F#'s sanitized word for "monads"
14:40:50 <joe6> what is id? i never understand it.
14:40:54 <kmc> identity function
14:40:55 <revenantphx> kmc: Pretty much.
14:40:55 <kmc> id x = x
14:40:58 <joe6> it just returns id = id
14:40:58 <kmc> @src id
14:40:59 <lambdabot> id x = x
14:41:00 <revenantphx> All this is is bound monads.
14:41:01 <j-invariant> joe6: id's easy
14:41:06 <dobblego> revenantphx, many things in "the enterprise world" are just rehashed haskell concepts and usually degenerate
14:41:16 <revenantphx> dobblego: So I've noticed ;)
14:41:35 <djahandarie> dobblego, so if it checks, I just sdist and upload?
14:41:43 <kmc> i remember a book on F# which had a listing of three reasons that workflows are totally not just monads, all of which were either incorrect or irrelevant
14:41:48 <dobblego> djahandarie, exactly
14:41:56 <revenantphx> kmc: haha, got some specifics?
14:42:00 <kmc> don't remember
14:42:02 <dobblego> kmc, really? I'd be interested in seeing that
14:42:11 <ddarius> I'm pretty sure this is a different "workflow" and isn't "just the IO monad."
14:43:08 * hackagebot yices-painless 0.1.2 - An embedded language for programming the Yices SMT solver  http://hackage.haskell.org/package/yices-painless-0.1.2 (DonaldStewart)
14:43:27 <revenantphx> ddarius: I mean abstraction wise
14:43:39 <revenantphx> ddarius: Underneath its a fair bit different nat.
14:43:57 <ddarius> revenantphx: It's not even "abstraction-wise" the same thing.
14:44:05 <revenantphx> How so?
14:44:08 * djahandarie taps impatiently while waiting for hackage to load
14:44:12 <ddarius> Unless you are simply going to call every imperative language "just the IO monad."
14:44:27 <djahandarie> Haskell is just the IO monad!
14:44:36 <kmc> lolololol
14:44:42 <djahandarie> lololololol
14:44:42 <revenantphx> maybe saying the IO monad specifically is a bit incorrect.
14:44:48 <Adamant> in the category of endofunctors
14:44:50 <revenantphx> But it is a very monadic looking abstraction ddarius 
14:44:58 <revenantphx> The right hand side, not the left.
14:44:59 <ddarius> revenantphx: How so?
14:45:10 <Phyx-> nerds...
14:45:24 <revenantphx> You have "activities" which are self-contained, modular, and composable actions basically.
14:45:35 <kmc> Haskell is the monad corresponding to the adjoint functors "smug" and "useless"
14:45:37 <Adamant> Phyx-: no, it's NEERRDDDDSSSSSS!!!!!!!!!!!!!!!
14:45:39 <ddarius> revenantphx: Yes.  We call them procedures/functions.
14:45:55 <revenantphx> ddarius: Of course.
14:45:58 <ddarius> kmc: Which is the left adjoint.
14:46:09 <revenantphx> It's more explicit though.
14:46:12 <Adamant> kmc: I don't think "smug Haskell weenie" has become a catchphrase yet
14:46:18 <kmc> yeah
14:46:36 <Adamant> fortunately I don't think people take themselves that serious here
14:46:45 <kmc> yeah, it's great how anyone making a substantive point about Lisp can be dismissed by calling them a "smug Lisp weenie" and then griping about parentheses
14:46:49 <elliott> I heard Haskell was dying, is this true?!
14:46:54 <kmc> ⸘
14:47:05 <Adamant> elliott: along with BSD and Netcraft
14:47:08 <BrianHV> so is Apple.
14:47:13 <ddarius> revenantphx: Tell me what return, fmap, and join are for workflows, then maybe I'll start agreeing with you.
14:47:13 <blubsala> i don't think anybody takes people trying to understand monads serious here :P
14:47:16 <sipa> @faq will haskell live forever?
14:47:17 <lambdabot> The answer is: Yes! Haskell can do that.
14:47:22 <sipa> see, no worries!
14:47:23 <elliott> Adamant: But I'm running Netcraft's servers on BSD powered by Haskell.
14:47:25 <elliott> What will I *DO*?!
14:47:29 <revenantphx> ddarius: haha, gotcha :P
14:47:44 <Adamant> elliott: use the magic of enterprise software
14:47:58 <Adamant> powered by hemi engine generators
14:48:17 <djahandarie> blubsala, that's because people just trying to understand monads aren't trying to learn Haskell imo. ;) Or they have been misled
14:48:49 <kmc> we answer lots of monad-related questions
14:49:01 <kmc> but total beginners who show up and say "how do i monad" are asking the wrong question
14:49:06 <ddarius> Incidentally, there would be some benefit to implementing something like workflows in Haskell.
14:49:07 <djahandarie> If you learn Functors and Applicative Functors like you should, then Monads won't be a problem and you'll also understand everything better :)
14:49:09 <Adamant> kmc: well, if the person is a long-term resident of c.l.l, it's probably a valid assertion
14:49:14 <kmc> usually they just want to do IO, for which an understanding of monads is neither sufficient nor necessary
14:49:31 <Adamant> otherwise yeah, it's just whining
14:49:41 <kmc> Adamant, may be true but ad hom is still not a valid debate tactic
14:50:01 <Adamant> kmc: you might want to telll c.l.l.'ers that
14:50:01 <EvanR-work> kmc: you think that only because youre stupid
14:50:33 <joe6> is there a better way of writing this: foldl setBit (0::Word8) [ i |  (True,i) <- zip boolslist [0 ..]]
14:51:20 <tg_> according to a recent haskell.reddit article, with foldl'
14:51:35 <joe6> where boolslist = [True,False,True,False]
14:51:43 <j-invariant> joe6: boolslist seems bad
14:52:43 <nate__> 17:56 < kmc> but total beginners who show up and say "how do i monad" are asking the wrong question
14:52:45 <nate__> 17:56 < kmc> but total beginners who show up and say "how do i monad" are asking the wrong question
14:52:53 <elliott> how do i nomad
14:52:59 <kmc> that was perplexing
14:53:12 <ndrsndrs> how do i damon
14:53:35 <hpc> how doman doi
14:53:42 <hpc> (anagrams are fun!)
14:53:47 <Adamant> well first you have to learn Boston Irish speech patterns
14:53:50 <ndrsndrs> i can't think of any more :(
14:54:16 <Adamant> then, according to Team America: World Police, you just repeat your name in every social situation
14:54:36 <sipa> Matt Damon!
14:54:39 <kuffaar> Adamonad
14:54:56 <ndrsndrs> (http://wordsmith.org/anagram/anagram.cgi?anagram=how+do+i+monad&t=1000&a=n)
14:55:14 <kuffaar> how is monnad formed ?
14:55:30 <hpc> how do i from monnad
14:55:34 <Adamant> kuffaar: then substractamonad
14:56:11 * hackagebot newtype 0.1 - A typeclass and set of functions for working with newtypes.  http://hackage.haskell.org/package/newtype-0.1 (DariusJahandarie)
14:56:30 <djahandarie> dobblego, ^^
14:56:47 <dobblego> djahandarie, woot!
15:01:46 <Adamant> djahandarie: I always think your screen name is DJ Ahandarie :P
15:02:32 <Adamant> and now, away from the OT
15:04:07 <pastorn> @pl (pI >>= \m -> char ':' >> pI >>= \s -> return (60*m + s))
15:04:07 <lambdabot> (`fmap` (char ':' >> pI)) . (+) . (60 *) =<< pI
15:07:32 <ddarius> (\m s -> 60*m + s) <$> pI <* char ':' *> pI
15:10:10 <pastorn> liftM2 (+) (liftM (*60) pIntegral) (char ':' >> pIntegral)
15:10:19 <pastorn> ddarius:^^^ <3 <3 <3 liftM*
15:11:01 <pastorn> ddarius: using (<*) and (*>) like that...
15:11:04 <pastorn> how will that parse?
15:11:31 <pastorn> isn't their fixities what resolves it
15:11:31 <ddarius> The right way.
15:11:32 <jmcarthur> yes
15:11:55 <ndrsndrs> i think one of them is meant to be <*> anyway, if i'm reading it right
15:13:00 <jmcarthur> pastorn: usually it doesn't even matter how it parses because the end result is the same, although for some functors maybe it would be more efficient one way than the other
15:13:50 <jmcarthur> what was i thinking when i just said that?
15:13:54 <jmcarthur> ignore me please
15:14:01 <pastorn> jmcarthur: NEVAR
15:14:25 <ddarius> Or maybe not.
15:14:44 <ddarius> At any rate...
15:26:32 <pastorn> ugh... parsing the ascii chessboard is messy :l
15:26:34 <pastorn> :/
15:29:07 <monochrom> why parse the board? parse the list of pieces and coordinates
15:29:30 <pastorn> monochrom: do you know how to aquire that from FICS?
15:29:38 <monochrom> I don't know.
15:30:13 <pastorn> monochrom: this is a small log: http://codepad.org/A7OsjKvN
15:30:55 <pastorn> just parsing the board would be fine, but i want to grab all the extra data to the right of it...
15:31:08 <monochrom> I see
15:31:13 <pastorn> so a simple (count 8 parseBoardLine) won't do :(
15:41:24 <monochrom> Damn you haskell. Now I type "diamond" as "diamonad"
15:42:15 <pastorn> monochrom: this is good
15:43:12 <kuffaar> Haha I want to start trying to perform my usual Ruby tasks in Haskell
15:43:27 <kuffaar> What library should I use for HTML tag soup parsing?
15:43:32 <kuffaar> With XPath lookups and such
15:43:32 <c_wraith> tagsoup :)
15:43:35 <kuffaar> Ok
15:43:41 <c_wraith> oh.  tagsoup just gives you a list of tags
15:43:46 <kuffaar> :[
15:43:57 <pastorn> kfish: what's XPath?
15:44:12 <c_wraith> a query language for identifying sets of nodes in an xml document
15:44:18 <kuffaar> http://en.wikipedia.org/wiki/Xpath
15:44:20 <pastorn> *kuffaar
15:44:38 <kuffaar> I didn't even know it was XML based hm
15:46:24 <kfish> does ruby tagsoup do xpath?
15:46:37 <c_wraith> it does something much like it
15:46:55 <c_wraith> or at least, hpricot does.  I assume that's the parser kuffaar used
15:46:57 <ddarius> It's really not hard to do similar things with just normal functions.
15:47:10 <kuffaar> c_wraith pretty much every Ruby one used it
15:47:21 <kuffaar> c_wraith I mostly use regex to extract stuff from markup
15:47:53 <c_wraith> For the level of xml manipulation I've done in haskell, I prefer using the lightweight package, which I believe is...
15:47:56 <c_wraith> @hackage xml
15:47:56 <lambdabot> http://hackage.haskell.org/package/xml
15:48:04 <kuffaar> Well, this isn't XML
15:48:06 <c_wraith> Yeah, that's the one
15:48:25 <kuffaar> I mean I can always resort to RE
15:49:24 <kfish> maybe you can use takeWhile and drops like this: http://blog.kfish.org/2007/06/review-tagsoup.html
15:50:53 * ddarius is pretty sure it would be quite easy to translate the relevant subset of XPath into simple Haskell list functions and tagsoup functions.
15:54:35 <monochrom> http://hackage.haskell.org/package/hxt-xpath can do xpath
15:55:03 <ddarius> monochrom: Yes, but that requires well-formed X(HT)ML.
15:55:58 <ddarius> But, yes, the HaXml/HXT approach maps pretty directly to XPath language elements.
15:56:02 <monochrom> not supposed to do xpath over non-xml anyway
16:09:59 <rntz> I am trying to "cabal upgrade Agda", and I get the following error:
16:10:01 <rntz> cabal: fromFlag NoFlag. Use fromFlagOrDefault
16:10:26 <rntz> anyone know what the problem might be?
16:10:38 <ivanm> don't use upgrade
16:10:43 <ivanm> "cabal install Agda --reinstall"
16:10:51 <ivanm> I think that will do it; maybe without the --reinstall
16:11:01 <ivanm> (upgrade was deprecated because it did bad things)
16:11:49 <rntz> okay, that appears to have worked (although now I'm getting dependency problems, but at least they make sense...)
16:11:53 <rntz> thanks
16:13:26 <rntz> hrm. cabal claims that ghc-6.10.4 requires Cabal ==1.6.0.3
16:13:43 <rntz> this is odd, because I have cabal 1.8.0.2 installed
16:14:16 <rntz> why would ghc depend on a specific version, rather than anything after a given version? hell, why would ghc depend on cabal at all?...
16:15:29 <ivanm> rntz: ghc ships with a number of libraries, one of which is Cabal
16:15:44 <ivanm> Cabal is the only one you can upgrade, but you shouldn't uninstall the previous version
16:16:04 <ivanm> ghc comes with Cabal primarily so that you can install new libraries with Cabal
16:17:26 <Saizan> ghc the library is another matter.
16:18:06 <Saizan> well it's one of those libs that ship with ghc the compiler and that you can't upgrade
16:21:46 <Saizan> rntz: anyhow, i think you need ghc-6.12.x for the new Agda
16:29:39 <monochrom> Agda doesn't depend on "ghc the library", not even indirectly. if "ghc-6.10.4 requires Cabal ==1.6.0.3", I say something else is toasted.
16:30:10 <dcoutts_> probably quickcheck
16:30:58 <monochrom> QuickCheck is only base, mtl, random.
16:31:11 <dcoutts_> earlier versions depend on ghc the lib too
16:31:24 <dcoutts_> we poked the QC devs until they removed the ghc dep
16:32:21 <monochrom> QuickCheck (≥2.1.0.2 & <2.2) does not depend on ghc-as-library
16:33:34 <Igloo> What did QC use from GHC?
16:34:00 <monochrom> All versions of Agda are either QuickCheck (2.1.0.1) or QuickCheck (≥2.1.0.2 & <2.2). They are all base,mtl,random only
16:34:04 <dcoutts_> Igloo: the exception ghci uses for ^C
16:36:58 <dcoutts_> mono_: QuickCheck-2.1.0.3 and later depend on ghc
16:38:02 <dcoutts_> oops, monochrom ^^
16:38:13 <monochrom> I see. somewhere hidden under "if impl(ghc >=6.7)"
16:38:25 <dcoutts_> and version 2.1.1.1 and later will omit the ghc dep if built using ghc >= 6.13 (ie ghc 7)
16:44:33 <Saizan> so the exception for ^C got exported from somewhere else or?
16:45:12 <monochrom> now it's in Control.Exception. look for UserInterrupt or something.
16:50:19 <joe6> is there a better way to write this: fromIntegral ((fromEnum (ToInterface::System.USB.Recipient))::Int) ::Word8
16:51:26 <monochrom> @type fromEnum
16:51:27 <lambdabot> forall a. (Enum a) => a -> Int
16:51:34 <Saizan> you can probably drop all the type annotations, except for :: Word8 maybe
16:51:35 <monochrom> so you can omit ::Int
16:53:06 <joe6> ok thanks.
16:58:18 <djahandarie> Might need to keep System.USB.Recipient in case toInterface is polymorphic and not inferable
17:01:45 <edwardk> is there a good way to ask the runtime if it is multithreaded and how many threads it has?
17:02:10 <c_wraith> there's numCapabilities
17:02:28 <edwardk> perfect
17:02:29 <c_wraith> though I don't think that distinguishes between the runtimes, if the result is 1
17:03:28 <joe6> can I have a list of functions with different types?
17:03:33 <edwardk> hrmm
17:03:47 <monochrom> no
17:04:03 <joe6> ok, thanks.
17:04:45 * ddarius needs to insert Cid's Theme into his memorized repetoire.
17:05:02 <djahandarie> From Final Fantasy?
17:05:03 <edwardk> c_wraith: now, where is that hiding?
17:05:09 <c_wraith> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#v:numCapabilities
17:05:18 <edwardk> found it
17:05:19 <edwardk> thanks
17:05:49 <c_wraith> But yeah, if it returns 1, you don't know what runtime you're on.  So it might not be sufficient for your needs
17:06:36 <edwardk> witht hat i can tune speculation further, since it should check numCapabilities and use that to disable speculation if its == 1, and specSTM shouldn't spark if the numSparks# exceeds some threshold multiplier of numCapabilities
17:07:00 <c_wraith> Ah.  sounds like what you want, then
17:07:46 <joe6> is there a smarter way of representing this list : [ enumToWord8 . stRecipient, enumToWord8 . stRequestType, enumToWord8 . stDeviceToHost ] :: [Setup -> Word8]
17:08:24 <joe6> the constructor functions have different types
17:08:31 <joe6> return types, i mean
17:08:48 <ddarius> Why are you using a list and why are you using a list of functions?
17:08:54 <joe6> the stRecipient, stRequestType, stDeviceToHost are the constructor functions.
17:09:24 <joe6> i plan to do map ($ (smsg::Setup) on that list
17:09:44 <joe6> so, instead of writing enumToWord8 . stRecipient smsg, for each element
17:10:07 <joe6> i meant map ($ (smsg::Setup))
17:10:33 <joe6> > testBit
17:10:34 <lambdabot>   Overlapping instances for GHC.Show.Show
17:10:34 <lambdabot>                              (a -> ...
17:10:49 <ddarius> That sounds like a dumb idea, and still, do you actually want a list of three bytes?
17:11:50 <joe6> ddarius: it is actually a bigger list of 8 bits, I just cut it down for the irc
17:12:00 <joe6> "dumb" --haha
17:13:39 <joe6> i am doing something like this: http://codepad.org/B8CeHu2B
17:13:47 <joe6> the bigger picture..
17:14:28 <joe6> or, I could cheat and list each bit with an or..
17:15:33 <joe6> ddarius: makes sense?
17:18:01 <applicative> joe6, there's a Num instance around, or a special use of "+"?  ... when you say " (map (+ smsg) [ stRecipient, ...]
17:20:21 <joe6> i was thinking that the (+ smsg) is a mistake and should have been ($ msg)
17:20:34 <applicative> oh i see
17:20:35 <joe6> as i do not know of the special use of "+"
17:21:06 <spetrea> I'm going for a cig
17:21:26 <applicative> no, I just wondered if you had defined one, excluding the Prelude use; or else defined a clever Num instance like
17:21:39 <applicative> > 5 3
17:21:40 <lambdabot>   5
17:21:55 <spetrea> > 0 -1
17:21:56 <lambdabot>   -1
17:22:00 <spetrea> err
17:22:02 <spetrea> 'tf
17:22:05 <joe6> this is what i have: http://codepad.org/zmGCUbM8
17:23:34 <fryguybob> > 0 (-1)
17:23:35 <lambdabot>   0
17:25:00 <Bynbo7> spetrea: according to lambdabot, you wrote 0 - 1
17:25:41 <djahandarie> > 0 (subtract 1)
17:25:43 <lambdabot>   0
17:26:06 <djahandarie> > 0 1
17:26:07 <lambdabot>   0
17:26:10 <djahandarie> > 0 - 1
17:26:10 <magicman> :t 0 :: (a -> Int)
17:26:11 <lambdabot> forall a. a -> Int
17:26:11 <lambdabot>   -1
17:27:04 <magicman> > map (sin*sin + cos*cos) [0..10]
17:27:05 <lambdabot>   [1.0,1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0...
17:27:13 <magicman> Hehehe.
17:29:39 <applicative> joe6, you could cut the repetition of enumToWord8 by including it in the function you're mapping, of course; maybe it would be less intelligible
17:30:05 <kuffaar> What should I use to catch exceptions which can be thrown by getDirectoryContents?
17:30:39 <kuffaar> Should I just do { contents <- getDirectoryContents  path; ... } `catch` \_ -> do { ... } ?
17:31:55 <ivanm> which catch is that? the one from extensible exceptions (Control.Exception in base 4) ?
17:32:22 <applicative> @type map ($ 1)
17:32:23 <lambdabot> forall a b. (Num a) => [a -> b] -> [b]
17:32:29 <applicative> map (($ 1) . (.(+2 )) )
17:32:45 <applicative> @type  map (($ 1) . (.(+2 )) )
17:32:45 <joe6> applicative: i tried that, but the functions have different return types
17:32:46 <lambdabot> forall a b. (Num a) => [a -> b] -> [b]
17:33:02 <joe6> the constructor functions, I mean
17:33:03 <applicative> oh, this is the problem, I was supposing it compiled
17:33:14 <kuffaar> ivanm: Hmm hasn't this catch been around for a long time?
17:33:28 <ivanm> as of 6.10.1, yes
17:33:28 <kuffaar> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:catch
17:33:43 <ivanm> but the Prelude one is likely to be renamed/deprecated soon as it has a different type
17:33:45 <ivanm> @hoogle catch
17:33:46 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
17:33:46 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
17:33:46 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
17:34:04 <ivanm> but if you're using the Prelude catch, that might be alright
17:34:47 <kuffaar> Hmm
17:35:02 <applicative> joe6, the types of stDeviceToHost and stRecipient are different, but composition with enumToWord8  takes care of it?  I think I see now
17:35:26 <kuffaar> haskell-mode upsets me, it doesn't like this { } syntax for the try/catch blocks at all
17:36:21 <joe6> applicative: yes
17:38:32 <ivanm> kuffaar: any particular reason for using { } rather than indentation?
17:38:36 <ivanm> @hoogle handle
17:38:37 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
17:38:37 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
17:38:37 <lambdabot> Control.Exception.Base handle :: Exception e => (e -> IO a) -> IO a -> IO a
17:38:48 <kuffaar> ivanm: Oh, I wasn't entirely sure how this worked
17:38:53 <kuffaar> Indentation it is then
17:39:05 <kuffaar> http://en.wikipedia.org/wiki/Exception_handling_syntax#Haskell I followed that one
17:39:11 <kuffaar> Not sure why it uses { } for no reason
17:39:27 <ivanm> kuffaar: the { ; ; } notation is to avoid having to bother with indentation, especially if you're generating code
17:40:12 <Bynbo7> kuffaar: in haskell, try and catch are just haskell functions
17:40:56 <kuffaar> I don't get how to use indentation for this
17:41:33 <kuffaar> I just have a `catch` \_ -> do
17:41:46 <kuffaar> With the same indentation as the stuff from its try block...?
17:42:12 <c_wraith> there isn't a try block in haskell, generally
17:42:28 <c_wraith> try and catch are both just combinators.  they do similar things.  you should use one or the other.
17:42:55 <c_wraith> :t Control.Exception.try
17:42:56 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
17:42:57 <kuffaar> There's actually a try function? I haven't even seen that yet
17:43:04 <kuffaar> I really need to see a proper function for this
17:43:11 <kuffaar> Because I've only seen one example online so far lol
17:43:40 <c_wraith> The type signature tells you everything you need to know about try.  *shrug*.  (yeah, I know, before you learn how to interpret that, it makes you think the docs are really opaque)
17:43:41 <kuffaar> f = catch g (\e -> if IO.isEOFError e then return [] else ioError e)
17:43:57 <kuffaar> That makes far more sense to me
17:44:02 <joe6> i have a function whos type definition is: :: Bits a => [Setup -> a] -> [b] -> [Int -> Int -> (Bool, Int)]
17:44:04 <kuffaar> Because this example used it as an infix operator
17:44:10 <kuffaar> Which made it super awkward.
17:44:15 <joe6> i am trying to filter fst t otat function
17:44:48 <joe6> as : filter fst . ( f :: Bits a => [Setup -> a] -> [b] -> [Int -> Int -> (Bool, Int)])
17:45:13 <pastorn> joe6: filter fst only works with a [(Bool,a)]
17:45:33 <joe6> oh, sorry, i should have been using zipWith3
17:45:40 <joe6> my mistake. Thanks.
17:46:03 <joe6> and that would have given my typedef ta: 
17:46:05 <joe6> :: Bits a => [Setup -> a] -> [b] -> [Int] -> [Int -> (Bool, Int)]
17:48:05 <joe6> sorry, forget it.. 
17:48:13 <joe6> was doing something wrong.
17:48:27 <joe6> the type definition has been corrected to return [(Bool,Int)]
18:20:42 <turiya> why are lists slow? if I represent a list as a function, would indexing be faster?
18:20:48 <j-invariant> turiya: yes
18:21:14 <codolio> Why is C slow?
18:21:27 <j-invariant> codolio: because it's based on linked lists
18:21:30 <mm_freak> turiya: not necessarily, but in general yes
18:21:47 <turiya> j-invariant: i still dont understand the fundamental difference between a list and an array (as in C)?
18:21:56 <mm_freak> if you use the straightforward church list representation, then functions will be even slower
18:21:59 <Axman6> a list is a linked list
18:22:05 <j-invariant> turiya: a linked list vs an array?
18:22:33 <Axman6> so, in C it would be something like struct list { elem * head; list * tail}
18:22:35 <j-invariant> turiya: to get the nth element of a linked list requires n pointer dereferences, to get the nth element of an array requires 1. Saem situation in haskell with your question.
18:22:36 <turiya> ok, pardon my ignorance but why are linked lists slow?
18:22:52 <Axman6> because there's a lot of pointer traversal
18:23:01 <mm_freak> turiya: lists in haskell correspond to this in C:  typedef struct { SomeType element; List *next; } List;
18:23:36 <turiya> hmm..pointer deferencing is slow? why?
18:23:51 <turiya> dereferencing*
18:23:55 <Axman6> you're pretty new to programming aren't you :P
18:24:17 <mm_freak> it's not "slow", but you have to do it n times to find the (n-1)th element
18:24:22 <mm_freak> n+1
18:24:27 <turiya> Axman6: not quite but my programming skill is ostly superficial :)
18:24:30 <turiya> mostly*
18:24:31 <j-invariant> turiya: it's an operation
18:24:38 <Axman6> you can;t get to the nth element without going to each of the n-1 elements before it
18:24:51 <j-invariant> turiya: hence if we count it, then looking up alinked list is O(n) vs whereas an array is O(1)
18:24:52 <Axman6> j-invariant: huh?
18:25:01 <Axman6> right, ok
18:26:11 <Axman6> turiya: an array in C is a continuous block of memory, meaning to get to the nth element of an array arr, you just need to go to the arr+nth position in that piece of memory
18:26:27 <turiya> i see. even though i dont quite understand what the processor does while dereferencing..
18:26:51 <Axman6> a linked list may be spread all over the over the place, so going to element n means going to element 1 to find out where element 2 is, then element 2 to find where element 3 is and so on
18:27:30 <turiya> why doesnt haskell use contigous memory for a list?
18:29:15 <mm_freak> turiya: because a list is not an array
18:29:20 <turiya> ok, i see that u cant expand the list if contiguous memory is used..
18:29:35 <Axman6> because they aren't good in a pure environment. if you want to change one element in an array, you have to copy the entire array to guarantee immutability. yo change one element of a list, you can reuse a all of the list after the element you changed
18:30:01 <Axman6> also to add an element to a list is O(1) at the head, but it's O(n) for an array because the whole array needs to be copied
18:30:57 <mm_freak> to be fair, you don't need to copy the array, but lists are still going to be faster
18:31:27 <turiya> "you have to copy the entire array to guarantee immutability", why?
18:31:48 <hpc> turiya: because you need a contiguous block for the whole thing, but you can't modify in place
18:31:57 <hpc> so the whole thing must be copied on every modification
18:32:11 <Axman6> turiya: well, if you mutate an element, then you've just mutated an immutable object ;)
18:32:30 <hpc> there's no smaller pieces that can be copied, like if you modified a list by pushing to the head
18:32:37 <hpc> er, s/copied/reused
18:33:22 <turiya> ok, because in haskell you cant change a variable..etc..
18:33:32 <mm_freak> you can, but you don't
18:33:59 <turiya> oh..yeah
18:34:04 <hpc> like yoda, your advice is
18:34:06 <mm_freak> there are mutable variables as well as mutable arrays
18:34:20 <mm_freak> but you use them as a last resort in usual
18:34:27 <turiya> mvars?
18:34:27 <hpc> they are also confined to IO
18:34:30 <hpc> (or ST)
18:34:43 <mm_freak> yes, MVar counts as mutable, but it's a concurrency construct
18:35:00 <hpc> the standard mutable value is IORef
18:35:15 <mm_freak> i was rather thinking of IORef and STArray and such
18:35:17 <turiya> oh..i forgot that
18:35:32 <mm_freak> turiya: just remember that lists are used as streams, not as arrays
18:35:36 <hpc> though there's also MVar, Chan, TVar, TChan
18:35:37 <hpc> etc
18:35:48 <hpc> each with extra goodies attached
18:36:26 <turiya> if i have data which is very big, lists are not very good for the purpose as I have experienced 
18:36:33 <Axman6> indeed
18:37:08 <turiya> what are the alternatives? specifically, I have image data which might contain 1000x1000x3 elements
18:37:34 <Axman6> unboxed arrays
18:37:51 <Axman6> STUArrays would be best if you need to mutate the data
18:38:04 <turiya> is the function representation better than unboxed arrays?
18:38:13 <Axman6> eh? 
18:38:24 <turiya> if i wanted to represent my image as a function ?
18:38:40 <Axman6> why would you want to do that?
18:38:55 <turiya> someone said function representation is faster than lists?
18:39:23 <Axman6> yes, but lists are extremely slow for what you want to do
18:39:59 <turiya> ok, so in the increasing order of speed, 1) lists 2) function 3) arrays?
18:40:24 <djahandarie> turiya, I don't think anyone has even said "function representation"...
18:40:28 <Axman6> that's not a very good question to ask
18:40:49 <Axman6> it really depends on what you're trying to do, which i don't know
18:41:28 <mm_freak> Axman6: STUArray is not always better than STArray
18:41:47 <Axman6> sure
18:42:07 <Axman6> but for large amounts of data, i'd much rather not have a 2-3x overhead in memory usage
18:43:10 <mm_freak> you don't save large amounts of data in an array in the first place ;)
18:43:27 <Axman6> he said he did :
18:43:29 <Axman6> :|
18:44:18 <turiya> say, i want to read an image and save the pixel values, is an array a good choice for that?
18:44:32 <Axman6> save them ehere?
18:44:34 <Axman6> where*
18:44:42 <hpc> and how will you use them?
18:45:03 <hpc> if you are already using a graphics library, you can write the image to a buffer
18:45:21 <turiya> i want to modify some or all of the values (typical in image processing) or create a new set of pixel values..
18:46:06 <turiya> hpc: i dont only want to do image display, i also want to do some processing on the pixel data
18:52:10 <mm_freak> turiya: i'd likely use some opaque data structure for that
18:52:42 <turiya> mm_freak: opaque data structre?
18:52:44 <mm_freak> data Image = forall a. Image { imagePixels :: Ptr a, imageWidth :: Int, imageHeight :: Int, … }
18:53:27 <mm_freak> of course you could also store the image in an array
18:53:36 <turiya> i did try that but I had to write a lot of C code
18:53:37 <Axman6> do not want
18:53:54 <Axman6> what do you need to write C code for?
18:54:01 <mm_freak> data Image = Image { imagePixels :: Array Int Word8, imageWidth :: Int, imageHeight :: Int, … }
18:54:15 <mm_freak> uhm
18:54:18 <mm_freak> UArray, not Array
18:54:23 <turiya> for manipulating the Ptr
18:54:31 <mm_freak> you don't need C for that
18:54:34 <mm_freak> see Data.Storable
18:54:37 <Axman6> heh, Arrays of Word8 would be fun :P
18:54:45 <mm_freak> uhm
18:54:49 <mm_freak> Foreign.Storable
18:55:01 <mm_freak> i'm still sleeping, it seems
18:55:05 <turiya> mm_freak: oh.. i did not know things could be done without C while using Ptr
18:55:21 <turiya> i stopped using Ptr's when there more C than haskell
18:55:48 <mm_freak> turiya: if you're a haskell beginner, don't do these low level things…  use an image processing library or something
18:56:01 <Axman6> agreed
18:56:02 <turiya> mmm
18:56:12 <turiya> mm_freak: there is none :(
18:56:20 <Axman6> though, it is useful to learn how to do these things in haskell
18:56:29 <Axman6> there's plenty, i'm sure
18:57:58 <Axman6> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
18:58:50 <turiya> oh..i did find one.. hopencv
19:01:07 <turiya> to extend the functionality of this library, i dont need to use C?
19:04:16 <mun> hi
19:04:24 <turiya> what is the purpose of the ST monad?
19:04:37 <mm_freak> turiya: what would we need haskell for, when we always needed to resort to C? ;)
19:04:46 <mun> in logic, given f(a) = g(b) + h(c), is g(b) considered a "subterm"?
19:04:49 <mm_freak> i haven't written a single line of C to support a haskell program
19:05:11 <Axman6> it allows you to write algorithms that perform much better when you have mutability, in a way that is pure to the outside world of your program
19:05:50 <Axman6> i'm with mm_freak, the only time i've used C from haskell was to get access to some OpenCL stuff, before there was an OpenCL package
19:06:16 <j-invariant> mun: yes
19:06:18 <turiya> oh, i thought the FFI is used frequently
19:06:39 <turiya> isnt that the same thing as using C?
19:06:42 <mun> j-invariant, but g alone is also a subterm, right?
19:07:06 <Axman6> turiya: no, it's not. it's usually onlt used to bind to C libraries
19:07:11 <j-invariant> mun: I don't think g alone is anything
19:07:20 <Axman6> turiya: you';ve been doing Haskell wrong ;)
19:08:00 <turiya> i always speed up my code using C and using FFI, thats not quite right isnt it?
19:08:08 <mun> j-invariant, how about \x. x b?
19:08:18 <j-invariant> absolutely not
19:08:32 <monochrom> @pl \x -> x b
19:08:32 <lambdabot> ($ b)
19:08:39 <turiya> Axman6: pure to the ouside world, how does the ST monad do this?
19:09:15 <mm_freak> turiya: if you're a beginner, i recommend writing high level software first
19:09:21 <Axman6> it has actually mutable variables and arrays, but pnce you use runST, everything is pure once again
19:09:37 <mm_freak> you're concerning yourself with so many low level details that you'll likely never learn how to write proper haskell code
19:09:47 <mun> j-invariant, so how would you define a subterm?
19:10:21 <j-invariant> mun: I define it using context scope
19:10:36 <turiya> mm_freak: i did write fair amount of normal haskell code but found that sometimes it is too slow for my purposes..
19:11:35 <mm_freak> turiya: in 99% of all cases you need neither C nor low level code to speed it up
19:12:22 <mun> j-invariant, ok thanks
19:12:41 <turiya> mm_freak: i was afraid it was not true but i am still searching on how to go about doing this speed up in haskell
19:13:15 <mm_freak> turiya: application?
19:13:49 <turiya> oh..image processing
19:14:31 <mm_freak> like what?
19:14:33 <Axman6> anyone know if there's a way to output newlines in CPP macros? i'm trying to define a bunch of trivial instances, which means each 'instance foo bar where' needs to be on its own line... or does it?
19:14:53 <turiya> say basic thresholding of an image
19:15:09 <mm_freak> Axman6: ;
19:15:36 <mm_freak> turiya: first of all, choose an image loading/saving library you like
19:16:05 <turiya> mm_freak: i used WX and it can load some type of images, so that part is fine..
19:17:04 <turiya> WXCore, i suppose, gives a pointer to pixel data or it can also give a list of pixel values
19:17:21 <Axman6> mm_freak: i tried adding ;, and it doesn't like it, since i'm defining 4 instance declarations in each invocation of the macro
19:18:06 <mm_freak> turiya: well, i don't know the library, so i'm not sure you can access the image data
19:18:37 <mm_freak> Axman6: instance X Y where { … }; instance …
19:18:46 <turiya> imageGetData is the function and it does give a Ptr 
19:18:56 <Axman6> that might do it, thanks
19:20:11 <Axman6> remind me to buy you a beer if we ever meet mm_freak 
19:23:07 <ddarius> Axman6: You can't put any Haskell program on one line if you so desired.
19:23:22 <Axman6> s/can't/can?
19:24:35 <ddarius> Yeah.  I don't know how that happened.
19:25:44 <duairc> Hey, does anybody know how to connect to an IRC server with lambdabot and have it run there?
19:28:27 <Axman6> mm_freak: heh, just realised that having everything on one line also means that tags in vim should work correctly, which is nice
19:28:48 <Axman6> well, hopefully, depends on whether hasktags runs CPP or not
19:29:46 <Axman6> ok, it doesn't, weak
19:31:59 <turiya>     Not a data constructor: `forall'
19:31:59 <turiya>     Perhaps you intended to use -XExistentialQuantification?
19:32:25 <turiya> is that a flag for ghci?
19:33:01 <Axman6> it's a GHC flag.
19:33:15 <Axman6> where are you using forall? if you're new to haskell, you shouldn't be using that ;)
19:33:50 <mm_freak> Axman6: ludwigsburg, germany…  my favorite pub is "the clansman"…  thanks ;)
19:33:50 <monochrom> mimicking randomly chosen code from blogs?
19:33:51 <turiya> i was writing what mm_freak wrote before
19:34:43 <turiya>  data Image = forall a. Image { imagePixels :: Ptr a, imageWidth :: Int, imageHeight :: Int,  }
19:34:43 <mm_freak> turiya: well, isn't there a higher level interface to the pixels of the image?
19:35:10 <turiya> mm_freak: there might be but i want to start from scratch :)
19:35:26 <monochrom> yes then -XExistentialQuantification on command line or {-# LANGUAGE ExistentialQuantification #-} in file
19:35:59 <turiya> yes, that works
19:36:12 <monochrom> although I do hope that you know what you're getting into
19:36:43 <turiya> doesnt it just mean that Image can have any type of Ptr?
19:36:46 <mm_freak> turiya: then see Foreign.Storable
19:37:05 <monochrom> actually, it doesn't say that.
19:37:52 <Axman6> turiya: you aren't starting from scratch imo, you're delving into quite advanced territory
19:38:01 <monochrom> actually actually, see http://www.vex.net/~trebla/weblog/any-all-some.html for how many ways you can con yourself with the word "any".
19:38:17 <ion> mm_freak: Do they wear pointy white hoods at The Klansman?
19:39:52 <turiya> what does forall a. mean?
19:40:14 * hackagebot hamtmap 0.2 - A purely functional and persistent hash map  http://hackage.haskell.org/package/hamtmap-0.2 (KevinWuWon)
19:40:19 <monochrom> it means different things. in that code above, it means existential type.
19:41:08 <monochrom> existential type means: when creating a value, "any" type can be accepted for "a". when examining a value, that information is irrecoverable.
19:41:58 <monochrom> and to eliminate the problematic word "any":
19:42:21 <turiya> so, one does not know the type and there might be runtime errors?
19:42:26 <monochrom> when creating a value, the creator chooses a type for "a". when examining a value, that information is irrecoverable.
19:42:46 <monochrom> there might be type errors. you don't even get to run time.
19:42:57 <turiya> oh..ok
19:43:18 <turiya>  data Image a = Image { imagePixels :: Ptr a, imageWidth :: Int, imageHeight :: Int,  }, is better?
19:43:53 <monochrom> this one preserves the type chosen, but also exposes it. different choices become different types.
19:44:01 <mm_freak> ion: no =)
19:44:12 <turiya> yes, so it is more transparent.
19:44:12 <mm_freak> ion: it's clansman, not klansman ;)
19:44:22 <monochrom> this is exactly like how [Int] and [Bool] can't be mixed, but in each case you know it's Int or it's Bool respectively
19:45:11 <ion> Incidentally, in Finland, a certain chain has stores named “KKK Supermarket”.
19:45:35 <ion> http://media.share.ovi.com/m1/s/0094/3b4080a7d08d42709c00410205c85f34.jpg
19:45:37 <turiya> what is the reason behind using the name "Foreign"? Is Ptr so foreign?
19:45:53 <Axman6> it's for the FFI
19:46:00 <monochrom> perhaps the FFI is the biggest user of Ptr.
19:47:38 <turiya> i see..
19:51:38 <turiya> how do i restrict a to only be a Char or a Float in "data Image a = Image { imagePixels :: Ptr a, imageWidth :: Int, imageHeight :: Int,  }"
19:52:08 <Axman6> you'd need to make a class i think
19:53:01 <turiya> oh..
19:53:33 <Veinor> why Char?
19:54:33 <turiya> so that i can pass around the Ptr to external libraries, which expect Ptr CChar or so 
19:54:50 <BMeph> CChar /= Char
19:55:12 <turiya> oh.. may be a Word8 then
19:58:18 <monochrom> "Image Char", "Image Float"
20:06:03 <brweber2> anyone have a second to help with a naive noob question?
20:06:20 <maurer_> brweber2: ask.
20:06:36 <brweber2> I have a Maybe with a custom data type
20:06:37 <BMeph> brweber2: Sorry, you're second's up! ;)
20:06:49 <brweber2> and I want to see the current value
20:06:57 <BMeph> brweber2: Sorry, go ahead. :)
20:07:05 <brweber2> BMeph well played!
20:07:29 <Veinor> brweber2: so you want to turn, say, Maybe x into x?
20:07:47 <brweber2> Veinor yes, Maybe x into Show or a string, yes
20:08:01 <cdsmithus> brweber2: Does your custom type derive a Show instance?
20:08:02 <jmcarthur> brweber2: for your custom data type you can probably just add "deriving Show" to the end of it
20:08:09 <BMeph> brweber2: So, what if you're value is Nothing, what would you have it do?
20:08:27 <BMeph> Weird. I meant "your", not "you're"
20:08:49 <brweber2> ok, so deriving Show got me halfway there
20:08:54 <brweber2> how do I get x from Maybe x?
20:09:24 <ivanm> @type maybe
20:09:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:09:26 <cdsmithus> brweber: as long as YourType has a Show instance, so does Maybe YourType
20:09:26 <ivanm> @type fromMaybe
20:09:27 <lambdabot> forall a. a -> Maybe a -> a
20:09:32 <brweber2> BMeph if the value is Nothing I'd have it show ""
20:09:44 <brweber2> cdsmithus ahh, thanks
20:09:54 <ivanm> brweber2: Show and Read are meant to print and parse valid Haskell code
20:09:59 <ivanm> _not_ for pretty-printing
20:10:09 <ivanm> if you want a pretty-printer, use a pretty-printing library
20:11:03 <cdsmithus> But if all you want is to print the value and see what it is, Show is *exactly* the right thing to use for that
20:11:22 <brweber2> thanks all!
20:11:25 <brweber2> got it working
20:12:37 <ivanm> cdsmithus: and then you build upon it until suddenly your whole library uses Show for pretty-printing...
20:16:30 <cdsmithus> Huh?  I'm confused where the pretty printing came from.
20:16:49 <cdsmithus> I thought the requirement here was to print out a value to see what it is.  Show is the right answer for that.
20:17:49 <ivanm> cdsmithus: he wanted it to print "" if the value was Nothing
20:18:07 <ivanm> that, to me, is pretty-printing
20:18:45 <cdsmithus> Oh.  Yeah, the answer I gave doesn't do that, of course... something tells me it was just a guess because someone wanted an answer.
20:19:01 <ivanm> *nod*
20:19:58 <Axman6> does Luke Palmer hang around in here?
20:20:34 <jmcarthur> Axman6: as luqui sometimes, yes
20:20:47 <Axman6> yeah, just realised that when i went to his github page
20:24:33 <copumpkin> preflex: seen luqui
20:24:33 <preflex>  luqui was last seen on #haskell 1 day, 18 hours, 13 minutes and 7 seconds ago, saying: because that's hard as heck
20:27:08 <Axman6> @ask luqui Is there any chance that you'd be able to add a feature to hothasktags which would run CPP over files using the CPP pragma before scanning for tags? We're defining some datatypes along with some instances using a CPP macro and it would be very helpful to be able to jump to their definitions (even if it is just jumping to the macro line)
20:27:09 <lambdabot> Consider it noted.
20:31:24 <tolkad> Why is ghc automatically setting -fPIC?
20:31:33 <tolkad> and -dynamic?
20:31:38 <tolkad> I wanted to use -fllvm
20:32:14 <Axman6> why can't you?
20:33:30 <tolkad> "Warning: -fllvm is incompatible with -fPIC and -dynamic on this platform;"
20:33:38 <tolkad> I never set -fPIC
20:36:07 <joe6> which is better style: mapM_ ((mapM_ write) . toSimulator)  OR mapM_ write . concatMap toSimulator
20:36:36 <pastorn> i'd go with the latter
20:36:39 <Axman6> i'd say the second is much easier to understand, and therefore better ;)
20:36:42 <joe6> both do the same thing, but just wanted to check which the experts would prefer..
20:36:57 <joe6> ok, thanks, guys
20:43:31 <john_r_watson> @pl (\x -> (isSpace x) || (',' == x))
20:43:32 <lambdabot> liftM2 (||) isSpace ((',') ==)
20:43:45 <john_r_watson> > liftM2 (||) isSpace ((',') ==) 'c'
20:43:47 <lambdabot>   False
20:44:22 <tolkad> pwnt
20:44:43 <tolkad> that character just got falsed
20:45:17 <tolkad> @pl liftM5
20:45:18 <lambdabot> liftM5
20:45:24 <tolkad> @pl liftM5 liftM5
20:45:24 <lambdabot> liftM5 liftM5
20:46:12 <tolkad> :t let liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5 in x.x.x.x.x.x.x.x.x.x.x
20:46:13 <lambdabot> parse error on input `in'
20:46:20 <tolkad> :t let x=liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5.liftM5 in x.x.x.x.x.x.x.x.x.x.x
20:46:22 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) (m3 :: * -> *) (m4 :: * -> *) (m5 :: * -> *) (m6 :: * -> *) (m7 :: * -> *) (m8 :: * -> *) (m9 :: * -> *) (m10 :: * -> *) (m11 :: * -> *) (m12 :: * -
20:46:22 <lambdabot> > *) (m13 :: * -> *) (m14 :: * -> *) (m15 :: * -> *) (m16 :: * -> *) (m17 :: * -> *) (m18 :: * -> *) (m19 :: * -> *) (m20 :: * -> *) (m21 :: * -> *) (m22 :: * -> *) (m23 :: * -> *) (m24 :: * -> *) (
20:46:22 <lambdabot> m25 :: * -> *) (m26 :: * -> *) (m27 :: * -> *) (m28 :: * -> *) (m29 :: * -> *) (m30 :: * -> *) (m31 :: * -> *) (m32 :: * -> *) (m33 :: * -> *) (m34 :: * -> *) (m35 :: * -> *) (m36 :: * -> *) (m37 ::
20:46:22 <lambdabot> * -> *) (m38 :: * -> *) (m39 :: * -> *) (m40 :: * -> *) (m41 :: * -> *) (m42 :: * -> *) (m43 :: * -> *) (m44 :: * -> *) (m45 :: * -> *) (m46 :: * -> *) (m47 :: * -> *) (m48 :: * -> *) (m49 :: * -> *)
20:46:22 <lambdabot>  (m50 :: * -> *) (m51 :: * -> *) (m52 :: * -> *) (m53 :: * -> *) (m54 :: * -> *) (m55 :: * -> *) (m56 :: * -> *) (m57 :: * -> *) (m58 :: * -> *) (m59 :: * -> *) (m60 :: * -> *) (m61 :: * -> *) (m62 :
20:46:24 <lambdabot> [39 @more lines]
20:46:24 <copumpkin> @pl is pretty dumb on expressions with no functions in it
20:46:26 <lambdabot> (line 1, column 49):
20:46:27 <lambdabot> unexpected reserved word "in" or "i"
20:46:30 <lambdabot> expecting variable, "(", operator or end of input
20:46:32 <john_r_watson> ok... why is *my* ghci giving me:     No instance for (Monad ((->) Char))
20:46:32 <john_r_watson>       arising from a use of `liftM2' at <interactive>:1:0-33
20:46:32 <john_r_watson>  
20:46:42 <copumpkin> john_r_watson: you probably want Control.Monad.Insatnces
20:46:45 <copumpkin> Instances
20:46:51 <john_r_watson> ah....
20:46:53 <john_r_watson> good call
20:46:55 <pastorn> john_r_watson: or Control.Monad.Reader
20:46:58 <copumpkin> it's the socially acceptable orphanage
20:47:34 <tolkad> @botsnack
20:47:35 <lambdabot> :)
20:48:02 <copumpkin> why anyone thought it was a good idea to stick a bunch of orphaned instances in a separate module is beyond me
20:48:22 <john_r_watson> copumpkin: indeed
20:48:41 <spetrea> is Porter Stemmer supposed to improve precision of naive bayes algo ?
20:50:03 <michie1> hey, uh, a stupid question about applicatives:  Why is 'pure' called pure when a function it's applied to can have side effects?  And what's the point of encapsulating a function into an Applicative anyway?
20:50:07 <ddarius> copumpkin: I didn't understand that either.
20:50:47 <michie1> intuitively, it's hard for me to get that 'Just show' is the pure version of show (for the Just Applicative)
20:50:53 <copumpkin> ddarius: down with orphans!
20:51:13 <copumpkin> michie1: it's not even necessarily applied to functions
20:51:16 <sbahra> copumpkin.
20:51:17 <copumpkin> it can be applied to anything
20:51:24 <copumpkin> lol
20:51:35 <michie1> copumpkin: hmm, I suppose
20:51:42 <copumpkin> > pure 5 :: Maybe Int
20:51:43 <lambdabot>   Just 5
20:51:43 <Axman6> michie1: pure should not be able to perform any side effects
20:51:52 <Axman6> even in IO, it should not
20:52:01 <michie1> yeah, okay, so it doesn't execute
20:52:04 <michie1> good point
20:52:17 <ddarius> copumpkin: Next they'll be asking for more gruel.
20:52:30 <Axman6> well, i think of pure like return, where return x >>= f should be exactly the same as f x
20:53:37 <mtnviewmark> the "pure" in the method `pure` of Applicative is the same "pure" as in the concept of "pure functions" referring to functions with no side effects.
20:53:45 <mtnviewmark> er
20:53:47 <mtnviewmark> isn't the same as
20:53:53 <michie1> hmm, okay
20:54:32 <michie1> Intuitively, if I'd want to apply a function over, say, the Maybe Applicative, I'd be inclined to type it as Maybe a -> Maybe b
20:54:37 <mtnviewmark> pure, a method of Applicative, I assume comes from some math concept... 
20:54:40 <michie1> instead, it's Maybe (a -> b)
20:55:07 <tolkad> michie1: it roughly means pure as in pure water i.e. filtered. it filters its argument of impurities and wraps it in a parametric type to signify that it has been purified
20:55:09 <michie1> which gets weirder when you use Lists instead of Maybe
20:55:22 <copumpkin> michie1: that'd be fmap you want
20:55:43 <copumpkin> pure is one part of a recipe for building n-ary functions (for n > 1) over Maybe or another functor
20:55:44 <michie1> hmm, good point
20:56:15 <joe6> is there a printf class in Haskell?
20:56:19 <mtnviewmark> I think of that pure as  "give me a pure, plain and simple value of this here Applicative type with this here value"
20:56:30 <michie1> I don't know.  I go between stages where I think I get either Monads, Applicatives and Functors, but not all three at the same time it seems.
20:57:03 <michie1> (and never fully)
20:57:12 <tolkad> michie1: did my explanation help?
20:57:14 <aristid> joe6: yes. Text.Printf
20:57:55 <michie1> tolkad: uh, a little
20:58:06 <michie1> tolkad: it reminds me there's another thing I don't get
20:58:08 <joe6> aristid: is it a typeclass?
20:58:16 <michie1> and that 'pure' is maybe the wrong entrance
20:58:18 <copumpkin> joe6: it contains one, but why do you need a typeclass?
20:58:25 <copumpkin> printf works via a typeclass hack
20:58:28 <tolkad> michie1: that's actually kind of surprising, I made that explanation up on the spot
20:58:55 <tolkad> michie1: I'm not really sure wh it's called "pure" either
20:58:58 <tolkad> why*
20:59:03 <aristid> joe6: it involves two type classes, but behaves like a function.
20:59:07 <Axman6> > printf "%s %d %f" "hello" 292 pi :: String
20:59:09 <lambdabot>   "hello 292 3.141592653589793"
20:59:16 <copumpkin> "take any pure value and stick it into the functor such that it has no effects, and is thus pure"
20:59:42 <joe6> aristid: copumpkin: ok, thanks.
21:00:15 <copumpkin> you could even take an "impure value" and stick it into the functor such that is has no effects, with pure
21:00:29 <copumpkin> > pure (putStrLn "moo!") :: Maybe (IO ())
21:00:30 <lambdabot>   Just <IO ()>
21:00:50 <copumpkin> > pure (putStrLn "moo!") :: IO (IO ()) -- even this is pure! nothing ever gets printed!
21:00:52 <lambdabot>   <IO (IO ())>
21:01:20 <copumpkin> not a huge fan of the name myself, but I can see why they called it that
21:01:55 * ddarius doesn't know why people call the printf thing a hack.
21:01:57 <copumpkin> @ask sbahra sbahra?
21:01:57 <lambdabot> Consider it noted.
21:02:26 <aristid> ddarius: maybe because it is not particularly type-safe?
21:02:44 <aristid> > printf "%s" 4 :: String
21:02:45 <lambdabot>   "*Exception: Printf.printf: bad argument
21:03:22 <ddarius> aristid: Short of dependent types or insane encodings, there is no way to get it to be "type-safe" (in this skewed sense) and be as flexible as it is.  That said, that flexibility is rarely needed.
21:03:34 <ddarius> aristid: Is div also not "type-safe?"
21:03:40 <aristid> :t div
21:03:41 <lambdabot> forall a. (Integral a) => a -> a -> a
21:03:49 <aristid> why should div not be type-safe?
21:03:51 <Axman6> there is a more typesafe version of printf using TH
21:03:54 <ddarius> (And there'd be no trouble making printf return Either or Maybe.)
21:03:57 <copumpkin> I consider it a hack because it's using typeclasses not as a collection of related types unified by a common interface or behavior (except in a loose sense of being needed by the printf syntax we want) 
21:04:01 <ddarius> > 1 `div` 0
21:04:02 <lambdabot>   *Exception: divide by zero
21:04:48 <shachaf> That's why we only use floating point numbers.
21:04:50 <shachaf> They're safer.
21:05:07 <Axman6> heh
21:05:22 <copumpkin> lol
21:06:59 <ddarius> copumpkin: How is it not a collection of types unified by a common interface?
21:07:00 <aristid> > 1 / 0
21:07:02 <lambdabot>   Infinity
21:07:58 <ddarius> copumpkin: I can see such a complaint against the crazy Regex class or a class with f :: a as it's member, but this is a straightforward family of types.
21:08:09 <ddarius> Admittedly, the base cases are a bit ad-hoc.
21:08:41 <copumpkin> well, how many people write functions polymorphic in the printf type?
21:08:44 <aristid> i think using {1}, {2}... (like python 3) instead of %d and %s would already be an improvement, admittedly the main motivation there is not really type-safety
21:09:05 <ddarius> aristid: C# uses a syntax like that.
21:09:17 <ZnHxr> aristid: I disagree
21:09:26 <aristid> it also improves I18N.
21:10:28 <aristid> for many use cases, it would also be like to have a kind of printf without format string that just concats stuff
21:10:38 <aristid> -like+nice
21:11:16 <aristid> that would be similar in spirit (not in syntax) to python's print and c++'s iostreams.
21:11:46 <ZnHxr> i.e. terrible
21:14:08 <ZnHxr> <snark> I just heard the best anagram of Banach-Tarski.
21:14:17 <ZnHxr> <snark> the anagram is "Banach-Tarski Banach-Tarski".
21:14:25 <monochrom> haha
21:14:47 <Zao> :D
21:15:40 <LFL> @pl map fst . zip
21:15:41 <lambdabot> map fst . zip
21:17:03 <ivanm> @unpl map fst . zip
21:17:03 <lambdabot> (\ c -> map fst (zip c))
21:17:22 <Axman6> the code, it makes no sense!
21:17:25 <ivanm> though that doesn't typecheck either... :p
21:17:38 <ivanm> Axman6: sure it does, if you re-define map, . or zip! ;-)
21:18:13 <Axman6> :P
21:18:32 <Axman6> :t map fst .: zip
21:18:33 <lambdabot> forall a b. [a] -> [b] -> [a]
21:19:14 <ion> znhxr: Haha
21:19:52 <Axman6> :t let (.:.) f g x y z = f (g x y z) in (.:.)
21:19:53 <lambdabot> forall t t1 t2 t3 t4. (t -> t1) -> (t2 -> t3 -> t4 -> t) -> t2 -> t3 -> t4 -> t1
21:20:21 <Axman6> :t let (.::) f g w x y z = f (g w x y z) in (.::)
21:20:22 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> t1) -> (t2 -> t3 -> t4 -> t5 -> t) -> t2 -> t3 -> t4 -> t5 -> t1
21:20:33 <aristid> :t map fst . zip
21:20:34 <lambdabot>     Couldn't match expected type `[(a, b)]'
21:20:34 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
21:20:34 <lambdabot>     Probable cause: `zip' is applied to too few arguments
21:20:39 <aristid> :t map fst .: zip
21:20:40 <lambdabot> forall a b. [a] -> [b] -> [a]
21:21:18 <LFL> It is nonsense. What I meant
21:21:37 <LFL> map fst $ zip  "hello" [0..]
21:21:50 <ddarius> ZnHxr seems more mathematical than the old guy.  What was his name?
21:23:47 <ddarius> @seen lwall
21:23:47 <preflex>  Sorry, I haven't seen lwall
21:23:47 <lambdabot> Unknown command, try @list
21:23:58 <ddarius> Oh, yeah, lambdabot doesn't have that anymore.
21:24:11 <aristid> LFL: which is a pretty inefficient way to implement const "hello" [0..]
21:24:18 <aristid> preflex: seen lwall
21:24:18 <preflex>  Sorry, I haven't seen lwall
21:24:25 <aristid> ddarius: preflex still has it.
21:24:53 <ddarius> preflex wasn't in #pugs and no doubt other Perlista infested channels (like this one.
21:26:35 <LFL> Aristid: Yeah. Actually I'm looking for something like
21:26:37 <LFL>   replicateM bufferSize (peekByte ...) 
21:26:38 <aristid> preflex does seem to be in some perl channels, because if you use xseen it sometimes answers #perl
21:26:38 <LFL> in order to build a ByteString from a buffer.
21:26:51 <aristid> preflex: xseen lwall
21:26:51 <preflex>  Sorry, I haven't seen lwall
21:27:19 <aristid> LFL: what is your buffer's type?
21:28:25 <LFL> Aristid: I'm trying to move a BLOB
21:32:23 <ZnHxr> preflex: seen TimToady
21:32:23 <preflex>  TimToady was last seen on #perl6 1 year, 318 days, 23 hours, 42 minutes and 17 seconds ago, saying: longform as in 1080? :)
21:35:03 <aristid> ZnHxr: you're even more cryptic than ddarius always is. terrible.
21:53:48 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85371/focus=85386 is great fun. "detonational semantics: what does this button do?"  note spelling
21:58:02 <ddarius> Gregg Reynolds is still around?
22:16:10 <pastorn> what's the minimal definition for Enum?
22:16:42 <ddarius> @src Enum
22:16:42 <lambdabot> class  Enum a   where
22:16:43 <lambdabot>     succ                     :: a -> a
22:16:43 <lambdabot>     pred                     :: a -> a
22:16:43 <lambdabot>     toEnum                   :: Int -> a
22:16:43 <lambdabot>     fromEnum                 :: a -> Int
22:16:45 <lambdabot> [3 @more lines]
22:16:50 <ddarius> @more
22:16:50 <lambdabot>     enumFrom                 :: a -> [a]
22:16:51 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
22:16:51 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
22:16:52 <pastorn> ddarius: all?
22:17:06 <ZnHxr> toEnum, fromEnum
22:17:13 <ddarius> I'd imagine you'd be able to get by with just toEnum and fromEnum.  The Report states the explicit rules.
22:17:15 <pastorn> ZnHxr: thanks :)
22:17:28 <pastorn> i'll try with just those two
22:20:43 <pastorn> @pl (\(x,y) -> (y,x))
22:20:43 <lambdabot> uncurry (flip (,))
22:28:21 <Axman6> > (++) . (' ':) "foo" $ bar
22:28:22 <lambdabot>   Not in scope: `bar'
22:28:27 <Axman6> > (++) . (' ':) "foo" $ "bar"
22:28:28 <lambdabot>   Couldn't match expected type `a -> a1'
22:28:29 <lambdabot>         against inferred type `[GHC....
22:29:42 <ddarius> Damn, I'm brutal.
22:30:04 <Axman6> > (++) . (' ':) $ "foo" "bar"
22:30:05 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
22:30:05 <lambdabot>         against inferr...
22:32:31 <ion> (++) . "foo" doesn’t work, as "foo" isn’t a function.
22:33:08 <Axman6> @pl \x y -> y ++ ' ':x
22:33:08 <lambdabot> flip (++) . (' ' :)
22:33:25 <Axman6> @pl \x y -> x ++ ' ':y
22:33:26 <lambdabot> (. (' ' :)) . (++)
22:57:03 <ksf> > '\EOF'
22:57:05 <lambdabot>   <no location info>:
22:57:05 <lambdabot>      lexical error in string/character literal at chara...
22:57:09 <ksf> hmmm
22:57:51 <ZnHxr> EOF is not a character
22:57:53 <ksf> > '\&'
22:57:54 <lambdabot>   <no location info>:
22:57:54 <lambdabot>      lexical error in string/character literal at chara...
22:58:14 <Axman6> > '\NUL'
22:58:15 <lambdabot>   '\NUL'
22:58:16 <ZnHxr> > 'a\&'
22:58:17 <lambdabot>   <no location info>:
22:58:17 <lambdabot>      lexical error in string/character literal at chara...
22:58:38 <ksf> > "\&"
22:58:39 <lambdabot>   ""
22:58:57 <ksf> now that's the single most useful thing ever concieved of.
22:59:25 <ZnHxr> > "\ST\&X"
22:59:26 <lambdabot>   <no location info>:
22:59:26 <lambdabot>      lexical error in string/character literal at chara...
23:00:11 <ZnHxr> > "\SO\&H"
23:00:12 <lambdabot>   "\SO\&H"
23:00:17 <ZnHxr> nice
23:23:06 * ksf wants function-local data definitions.
23:24:15 * hackagebot regular 0.3.1 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.3.1 (JosePedroMagalhaes)
23:24:45 <adu> ksf?
23:25:03 <adu> loca; data?
23:27:01 <Axman6> foo x = let data Blah = Foo | Bar in thingThatUsesBlah?
23:27:38 <Axman6> doesn't sound like an unreasonable language extension
23:31:21 <Kaidelong> ksf: You can't hide them using the module system?
23:31:57 <Kaidelong> I thought you only had to export constructors if you really wanted to
23:32:03 <Kaidelong> and just instances always get exported
23:32:32 * Kaidelong heads to bed
23:33:25 <kmc> you can hide types and constructors with the module system, which doesn't mean local data definitions would be useless
23:33:34 <kmc> sometimes we want to abstract at a level finer than module level
23:33:49 <kmc> i feel like this is what anonymous sum / product types are for
23:34:00 <kmc> ksf, do you have a particular use case in mind?
23:34:50 <c_wraith> you can have names be local to declarations, why not have data?  It's coherent, so long as the values don't leak.  And that can be checked in the type-checker pretty easily.
23:35:48 <kmc> sure, none of that is a use case though
23:36:33 <c_wraith> I've wanted it before..  Occasionally, I want to implement some algorithm that wants custom data structures, and they have no use outside that case.
23:36:49 <kmc> i've wanted that, but much more often the type would be shared by a family of related functions at top level
23:36:56 <kmc> so it's best to hide it at module level
23:37:09 <kmc> one interesting thing you could do is combine it with ScopedTypeVariables to get "type closure"
23:37:57 <kmc> f :: ∀a b. a → b → …; f x y = let type Syn = a → b in …
23:38:36 <Axman6> so, maybe someone could make a proposal for FuncLocalTypes?
23:38:37 <kmc> whereas the type Syn at top level would require two parameters, negating the point of abbreviating that type
23:38:45 <kmc> this could shorten some code
23:40:48 <ski> ksf,kmc : i've wanted that a long time ..
23:42:14 <ski> (anonymous sums and products would also be useful .. but not the same)
23:42:30 <kmc> i meant (,) and Either and the like
23:43:01 <ski> well, tuples is anonymous/light-weight positional products
23:43:26 <kmc> i actually find the syntax heavier than normal syntax
23:43:37 <ski> the syntax of what ?
23:43:37 <kmc> i'd rather say «T3 a b c» than «(a,b,c)» but whatevs
23:43:54 <ski> ok
23:45:13 <ski> (anonymous) "named" products (i.e. records) and sums (like O'Camls "polymorphic variant types" would be useful as well
23:46:09 <ski> but i suppose for smaller uses, the names could be too much syntactic burden for too little gain
23:46:16 <ski> hence positional variants as well
23:47:11 <ski> anyway, re `type Syn = a -> b' .. ideally, one should be able to make (local) instances for locally declared types (`data' and `newtype'), as well
23:47:29 <ski> probably there will need to be some restrictions, though
23:48:03 <ski> e.g. if you have `class Foo a | -> a', then you shouldn't be able to locally instance that to one thing in one place, and to another thing in another place
23:48:48 <ski> (and i'm not sure local instances for types not mentioning a locally declared type should be allowed at all)
23:49:59 <ski> when doing some kind of things, i've wanted to be able to declare local types, making them locally an instance of `Functor', e.g.
