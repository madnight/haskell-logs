00:00:01 <Axman6> > (\x -> y ^ 2 where y = x ^ 2) 5
00:00:02 <lambdabot>   <no location info>: parse error on input `where'
00:00:03 <geheimdienst> (i thought i'd use some where for a change)
00:00:05 <Axman6> guess not
00:00:26 <dolio> Where clauses are attached to definitions, not expressions.
00:01:15 <geheimdienst> when you say it like that, it's clear ...
00:14:54 <mbuf> if I have parseCSV :: String -> Either ParseError [[String]], how can I access the individual Char elements?
00:15:51 <mbuf> in [[String]]; for example, let c = [["ABC"], ["DEF"]], I need to be able to get "ABC", and "DEF"
00:17:21 <CindyLinz> lambdabot: @type liftM
00:17:22 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:17:46 <Axman6> :t fmap
00:17:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:17:57 <Axman6> :t liftA
00:17:58 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
00:21:10 <test423432> Hey Guys, I am writing a java comment parser in the following library http://www.cs.uu.nl/docs/vakken/b3tc/dist/doc/html/uu-tc/src/ParseLib-Simple-Derived.html#epsilon, however I have problem allowing symbols into the java comment... can anyone give me some tips / advice?
00:21:59 <test423432> I can already parse the following /*....*/ however .... can only be alphanumeric at the moment, but I do not want to add each of them but more like everything except "/*" or "*/"
00:48:52 <lars9> is Cont Monad useful?
00:49:36 <Axman6> for some things, sure
00:50:26 <lars9> Axman6: such as?
00:50:53 <Axman6> i have no idea, i've never used it. but plenty of people do
00:51:01 <mbuf> if I have a list of 40 elements, how can I print 10 at a time?
00:51:01 <FauxFaux> The docs have examples.
00:53:01 <accel> is there any langauge with the typing/binding system of haskell/ocaml, but low level memory control of C? (I want to be able to control how structs & arrays of structs are laid out in memory)
00:53:49 <Axman6> Timber might meet that description
00:54:12 <Starfire> I wonder if ATS is anything of the sort. I think it has some kind of dependent typing system, but probably not like Haskell/Ocaml.
00:54:45 <accel> window 2
00:54:52 <Axman6> ATS from what i can tell is basically a new syntax for C
00:55:00 <Axman6> which includes inline C
01:05:12 <alpounet> lars9, http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
01:08:08 <lars9> alpounet: thanks
01:24:36 <CaScAdE^Laptop> anyone can help me out with an expected<->inferred problem? I do not get the point how to fix http://car.pastebin.com/Q0knFG06 
01:25:13 <Axman6> you'll need to also paste the error
01:25:52 <Axman6> also, explicit use of yield is usually not needed
01:26:04 <CaScAdE^Laptop> oh, sure: http://car.pastebin.com/pPYLFQBP
01:26:59 <Axman6> you need to do tb <- createThreadBuffer;
01:28:10 <CaScAdE^Laptop> Axman6: ok, that compiles... thanks so far... now i have to understand why the stuff is not doing anything :)
01:29:03 <Axman6> remember that = in haskell is means that the things on both sides of it are exactly equal. so doing f = someIOAction just makes f exactly the same as someIOAction, it doesn't run the action and get the result
01:29:40 <Axman6> also, e == True === e for all e
01:30:15 <Axman6> res <- takeMVar mv; return res === takeMVar mv
01:30:16 <CaScAdE^Laptop> Axman6: ok, then i do not get the point why my previous version without tickets seemed to be working
01:30:56 <Axman6> also, all the brackets after show are unnecessary: show(e) == show e
01:32:48 <CaScAdE^Laptop> so why is http://car.pastebin.com/Bw1guqk8 working with the let in line 47? seemed to be like tb contains the created buffer and is not the expression to the right...
01:33:11 <peoro> hello
01:33:24 <CaScAdE^Laptop> morning :)
01:34:42 <Axman6> CaScAdE^Laptop: that shouldn't work
01:34:52 <peoro> I needed a function to check wheter a list is longer than 3. `((>3) . length)' this did the trick, but before writing it I wrote this: `(>3 length)'. I'd expect the latter would be an error, instead it's a valid function of type `(Num (([a1] -> Int) -> a), Ord a) => a -> Bool', why? what is it?
01:35:22 <Axman6> you probably want to make a function of type createThreadBuffer :: IO (ThreadBuffer a)
01:36:19 <CaScAdE^Laptop> Axman6: http://car.pastebin.com/wQ7Jd32E <-- i added the trace... seems to be what it should be
01:37:14 <Axman6> argh, your code keeps changing >_<
01:37:28 <Axman6> i thought ThreadBuffer still had three elements in it
01:38:29 <CaScAdE^Laptop> sorry, that are two different versions... the last one was the one where i was wondering why line 47 works since you mentioned it should not
01:38:55 <CaScAdE^Laptop> since i would like to know why it works although it should not :)
01:39:16 <Axman6> it should work based on the new ThreadBuffer
01:42:56 <Saizan> peoro: 3 is polymorphic, so you'll get an error only if you force ghc to actually find such an instance of Num
01:43:06 <Saizan> ?type 3
01:43:07 <lambdabot> forall t. (Num t) => t
01:47:33 <peoro> Saizan, ok, I got it: GHC is going to accept a num which is a function taking an array and an integer and returning a num, right?
01:49:07 <peoro> but then I wonder: why would that be ok? I mean, with this syntax `(>3 length)' a third parameter would be a third parameter for `>' (which only accepts 2 parameters and thus would result in an error), why could it accept a `(Num (([a1] -> Int) -> a), Ord a)' ?
01:49:56 <Axman6> peoro: they're not arrays, they're lists, there's a pretty big difference
01:51:04 <Axman6> peoro: those are class constraints, so it's just saying that there needs to be an instance of Num for (([b] -> Int) -> a) and an instance of Ord for a
01:52:11 <mux> peoro: that's not really what happens because (>) is an operator; (>3 length) is equivalent to (\x -> x>3 length)
01:53:04 <Axman6> (\x -> x > (3 length))
01:53:21 <lars9> when should we choose foldr over foldl?
01:53:31 <peoro> Axman6: yeah, sure, I'm new to Haskell and am not completely used to the terminology, anyway yup, got what a list is...
01:53:45 <Axman6> when you need laziness. they're not really equivalent though
01:54:20 <lars9> Axman6: for example?
01:54:43 <Axman6> @src and
01:54:43 <lambdabot> and   =  foldr (&&) True
01:54:44 <peoro> ok, I think I got your point
01:55:45 <Axman6> so, foldr (&&) True [True, False, True] becomes: True && (True && (False && True)))
01:56:25 <Axman6> uh
01:56:35 <Axman6> so, foldr (&&) True [True, False, True] becomes: True && (True && (False && (True && True) )))
01:56:44 <Axman6> @src (&&)
01:56:44 <lambdabot> True  && x = x
01:56:45 <lambdabot> False && _ = False
01:57:24 <Axman6> using that definition, we get:
01:57:33 <Axman6> True && (True && (False && (True && True) )))
01:57:59 <Axman6> -> True && (False && (True && True))
01:58:08 <Axman6> -> False && (True && True)
01:58:12 <Axman6> -> False
01:58:45 <lars9> Axman6: good example, thanks
01:59:08 <Axman6> starting from the beginning (for lostman's benefit whose sitting right next to me)
01:59:28 <Axman6> foldr (&&) True [True, False, True]
01:59:50 <Axman6> -> True && foldr (&&) True [False, True]
01:59:53 <lars9> and if its foldl, it becomes ((T&&F) && T) ?
01:59:56 <Axman6> -> foldr (&&) True [False, True]
02:00:09 <Axman6> -> False && foldr (&&) True [True]
02:00:11 <Axman6> -> False
02:00:48 <Axman6> lars9: the point is that if you foldl, you build up the entire binary expression before returning a value, wasting stack space
02:00:57 <Axman6> with foldl you get:
02:01:06 <Axman6> foldl (&&) True
02:01:11 <lars9> Axman6: i see, yeah
02:01:38 <Axman6> foldl (&&) True [True, False, True] -- whoops
02:01:46 <Axman6> -> foldl (&&) (True && True) [False, True]
02:02:03 <lars9> good example
02:02:13 <Axman6> -> foldl (&&) ((True && True) && False) [True]
02:02:33 <Axman6> -> foldl (&&) (((True && True) && False) && True) []
02:02:56 <Axman6> -> (((True && True) && False) && True)
02:03:26 <Axman6> -> ((True && False) && True)
02:03:29 <lars9> so foldl can not work on infinite list?
02:03:34 <Axman6> -> (False && True)
02:03:37 <Axman6> -> False
02:03:41 <Axman6> lars9: exactly
02:06:30 <lostman> but take foldr (+) for instance; unlike &&, + requires both arguments to be evaluated
02:06:50 <lostman> so foldr (+) on a long list will blow up your stack
02:06:56 <mjrosenb> can't foldl work on an infinite list as long as any given invocation of it yeilds something that is in whnf without looking at the 'list' argument?
02:07:06 <Axman6> yup, so foldr would build up a large thunk, where as foldl' would be able to compute the sum as it runs
02:07:27 <Axman6> mjrosenb: foldl doesn't return anything until it finds []
02:08:01 <lars9> lostman: yeah, so for strict evaluation, just use foldl'
02:08:06 <Axman6> > foldl const 0 [1..]
02:08:10 <lambdabot>   mueval-core: Time limit exceeded
02:08:14 <Axman6> > foldr const 0 [1..]
02:08:17 <lambdabot>   1
02:08:23 <quicksilver> > foldl undefined undefined [1..]
02:08:24 <Axman6> > foldr const 0 []
02:08:25 <lambdabot>   0
02:08:27 <lambdabot>   mueval-core: Time limit exceeded
02:08:42 <quicksilver> ^^ point is, it doesn't even examine the function, or the seed, until it finds the end of the list
02:08:44 <Axman6> > foldl' undefined undefined [1..]
02:08:46 <lambdabot>   *Exception: Prelude.undefined
02:08:54 <quicksilver> so neither of those 'undefineds' gets evaluated.
02:09:40 <mjrosenb> fair enough...
02:10:51 * mux wishes firefox was as fast under linux than under windows
02:27:29 <jacobian> "An imaginary Robert Harper reminds me to remark that the use of functions to account for type dependency in the constructor does not constitute ‘higher-order abstract syntax’ in the sense of the Logical Framework"
02:27:35 <CaScAdE^Laptop> another question regarding lists... http://car.pastebin.com/HLrVXtet  why isn't rest giving me a list but a IO a instead? (in case i read the error correctly)
02:27:40 <jacobian> Most bizarre prior art citation I've ever read in a paper
02:27:41 <peoro> how come  `foldr (&&) True $ repeat False' terminates, while `foldr (\x acc -> acc && x ) True $ repeat False' doesn't?
02:28:34 <jacobian> && probably case destuctures it's first argument first. 
02:28:59 <lars9> > foldr (flip (&&)) True $ repeat False
02:29:03 <lambdabot>   mueval-core: Time limit exceeded
02:29:36 <lars9> @src (&&)
02:29:36 <lambdabot> True  && x = x
02:29:37 <lambdabot> False && _ = False
02:29:38 <shapr> SHAZAM!
02:30:25 <huawei> ;)
02:30:38 <peoro> ok, thanks :)
02:30:57 <peoro> that's right, `foldr (\x acc -> x && acc ) True $ repeat False' also terminates
02:31:19 <peoro> fold{r,l} parameter order still confuses me
02:31:27 <jacobian> me too
02:31:33 <jacobian> I wish they'd have kept it the same for both
02:33:18 <ehamberg> hi. i decided to pick up a simple program i wrote for a class last year in which i used monadrandom. the problem is that it holds on to memory that could be freed. the interesting code is at http://hpaste.org/43271 and i guess the problem is “nextGens <- generations … return $ pop : nextGens”.
02:33:34 <ehamberg> what i really want is “pop:generations …”. how can i do this?
02:37:05 <aleator> Hi! I dug up some old code like this https://gist.github.com/793060 and started to wonder which wheel I've re-invented? It ain't iteratee, but..
02:41:26 <alpounet> ehamberg, maybe you could use streams to model this
02:46:25 <Cale> jacobian: They did keep it the same for both
02:46:30 <ehamberg> alpounet: that's quite possible. maybe i should use this as an excuse to look at streams. :-)
02:48:06 <Saizan> aleator: ListTDoneRight
02:48:08 <Cale> jacobian: If you're talking about the parameters to the function you pass to foldr/foldl, they're designed such that the tree of applications of the function will contain the elements of the list in the original order that they occurred in the list.
02:49:47 <peoro> I'm having some difficulties in trying to write pointfree expressions... Is there any better way to write `(\y -> 0 /= mod x y)' than `((0 /=) . mod x)' ? the latter seems a lot more complicated to me...
02:50:42 <magthe> peoro: point-free isn't a goal in itself, sometimes it's simply pointless
02:51:04 <magthe> write it as simple as possible for the reader's sake
02:52:15 <magthe> but reading point-free is also a skill, so someone who's used to it would probably say that the latter is just as readable as the former
02:53:39 <jacobian> sometimes it can get rid of extra variable noise making expressions more compact and easier to understand. 
02:53:49 <mux> I think I'd have written ((/= 0) . (x `mod`))
02:53:52 <mux> YMMV
02:55:45 <mjrosenb> i would have to point out that more compact and easier to understand are not synonomous.
02:56:14 <maurer_> Out of curiosity, why can't we derive Enum for recursively defined types who all have Enum instance?
02:56:18 <maurer_> *instances
02:56:20 <alpounet> it just depends on what your code does
02:56:42 <alpounet> for numerical computations i typically almost don't write point-free code
02:57:02 <alpounet> but sometimes you just better express your program's logic with point-free
02:58:00 <jacobian> mjrosenb: which is why I said sometimes ;) 
02:58:23 <peoro> ok, I got it...
02:58:46 <peoro> I'll try anyway to write pointfree expressions in order to get used to it
02:59:10 <peoro> then when I'll be more experienced hope I'll be able to understand when to use it and when not to
02:59:49 <jacobian> good approach 
03:01:27 <mjrosenb> maurer_: would you want to guarantee that every finite, terminating expression be enumerable?
03:13:38 <aleator> Saizan: Thanks. Thats interesting..
03:13:42 <ski> imo, `Enum' doesn't make much sense unless you have a total, non-dense (at any point) ordering ..
03:13:43 <ski> e.g. which ordering to use for `[Bool]' ? which "interval" should `[[True,False] .. [True,False,False,True]]' give ?
03:13:58 <ski> maurer_ : ^
03:14:05 <quicksilver> well, probably either lexicographic or binary encoding of integers.
03:14:12 <quicksilver> but I wouldn't actually argue for either as a useful instance.
03:15:46 <ski> > [1 % 3 .. 14 % 5]  -- hmm
03:15:48 <lambdabot>   [1 % 3,4 % 3,7 % 3]
03:22:26 <quicksilver> yeah, well, conflating ".." with Enum is also a mistake.
03:22:53 <quicksilver> Enum ought to be for enumerable types, and ".." ought to be in a class called 'Range' ro something.
03:23:15 <quicksilver> or, actually, it could simply be a function on Num, although that would be a slight shame.
03:23:55 <frerich> On anything which is Ord and Bounded, maybe?
03:29:09 <maurer_> The basic idea is that it is frequently natural to want to iterate over all of something, and there is a straightforward way to derive this from enum instances.
03:30:10 <maurer_> ski: Think of it instead as Cons Bool List | Nil, and it becomes straightforward
03:30:14 <maurer_> You first have a Nil
03:30:26 <maurer_> Then a Cons of both bools, with an enumeration over all lists
03:30:29 <maurer_> etc.
03:31:10 <ski> how about `Tree a' where `data Tree a = Leaf a | Branch (Tree a) (Tree a)', then ?
03:31:43 <maurer_> First we have Leaf (toEnum 0)
03:32:41 <maurer_> Then we do a branch step
03:32:44 <maurer_> Then a leaf step again
03:32:52 <maurer_> I'll write it out on hpaste
03:32:58 <ski> i'm not sure what you mean by "step", here ..
03:34:23 <aavogt> @type (fromEnum, toEnum)
03:34:27 <lambdabot> forall a a1. (Enum a, Enum a1) => (a -> Int, Int -> a1)
03:42:22 <maurer_> http://hpaste.org/43272/enumeration
03:43:11 <maurer_> Basically I'd think the strategy laid out there, considering the constructors as just another element of the giant tuple, would sork
03:43:18 <maurer_> *work
03:43:25 <maurer_> As the constructors by themselves are trivially enumerable
03:45:14 <parcs> @type curry id
03:45:15 <lambdabot> forall a b. a -> b -> (a, b)
03:45:48 <ski> hm, is that supposed to do a diagonalization enumeration of the cartesian product ?
03:47:08 <ski> > [0 ..] >>- \a -> [0 ..] >>- \b -> [(a,b)]
03:47:09 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0...
03:47:21 <Veinor> :t (>>-)
03:47:22 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
03:47:26 <maurer_> ski: Basically.
03:47:34 <ski> (i can't say i understand what `step' is actually doing)
03:47:57 <ski> maurer_ : ok
03:48:17 <ski> my point was that `succ' wouldn't be a very meaningful operation then
03:48:35 <maurer_> In many cases of enumeration it is not as is.
03:49:07 <ski> (especially since enumerating `(a,b,c)' by `(a,(b,c))' or by `((a,b),c)' would give different results)
03:49:15 <ski> maurer_ : agreed
03:49:31 <maurer_> Is there any reason why it matters what the results are? This is a deriving, it just needs to be correct and consistent.
03:49:40 <ski> which is a reason i think `Enum' shouldn't be provided for those types
03:49:57 <maurer_> And all it needs for correct here is that eventually, it would enumerate all elements.
03:50:20 <ski> i don't really care much if you provide a list (or a tree) of all elements (or better a set)
03:50:32 <ski> but i don't see how `succ' would really be very useful
03:50:40 <maurer_> Those can't be lazy
03:50:47 <ski> why not ?
03:52:17 <ski> a list can be lazy
03:52:26 <maurer_> I was more talking about the set and tree
03:52:28 <ski> what i don't like is picking some arbitrary ordering, when the actual order used doesn't matter
03:52:28 <maurer_> And the list of all elements we could do, sure, but the one typeclass we have as is which is "list all elements" is enum
03:52:55 <maurer_> Well they need some order to pick them, or you can't gaurantee that all elements will be enumerated
03:53:05 <ski> more like `Enum' together with `Bounded' (in the finite case, anyway), no ?
03:53:08 <maurer_> If a given type has a more sensical ordering, they can always manually define an enumeration that uses it
03:53:20 <maurer_> But frequently you may want to do this for an unbounded type...
03:53:47 <ski> yes .. and `Enum' then provides no way to say "give me all elements"
03:53:58 <ski> @src Enum
03:53:59 <lambdabot> class  Enum a   where
03:53:59 <lambdabot>     succ                     :: a -> a
03:54:01 <lambdabot>     pred                     :: a -> a
03:54:03 <lambdabot>     toEnum                   :: Int -> a
03:54:05 <lambdabot>     fromEnum                 :: a -> Int
03:54:07 <lambdabot> [3 @more lines]
03:54:10 <ski> @more
03:54:10 <lambdabot>     enumFrom                 :: a -> [a]
03:54:11 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
03:54:13 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
03:54:25 <maurer_> Assuming you have even one element of it, you can just do succ and pred in both directions.
03:54:38 <ski> yes .. though both of those can be partial
03:54:58 <maurer_> Also, this is why not a set:
03:55:00 <maurer_> > member 1 (foldl (flip insert) (fromList []) [0..])
03:55:01 <lambdabot>   Not in scope: `member'
03:55:18 <ski> (and i'd like `Void' to be a member of the class for domain, as well)
03:55:43 <maurer_> > Data.Set.member 1 (foldl (flip Data.Set.insert) (Data.Set.fromList []) [0..])
03:55:44 <lambdabot>   Not in scope: `Data.Set.member'Not in scope: `Data.Set.insert'Not in scope:...
03:56:26 <ski> > S.member 1 (foldl (flip S.insert) (S.fromList []) [0..])
03:56:28 <maurer_> Alternatively, you could use the "from" used in the top level type to pass on to the bottom level types when generating their lists
03:56:35 <lambdabot>   mueval: ExitFailure 1
03:56:35 <lambdabot>  mueval-core: Time limit exceeded
03:56:45 <maurer_> ski: The point is that it's nonterminating, i.e. you can't do it lazily
03:57:37 <ski> > S.member 1 (foldr S.insert (S.fromList []) [0..])
03:57:39 <lambdabot>   *Exception: stack overflow
03:58:03 <ski> agreed. the standard `Set' doesn't cut it
03:58:40 <ski> i'd still want to hide the implementation detail of the ordering used
03:58:57 <ski> anyway
03:59:19 <ski> what kind of operations were you wanting to do on the domain of a type ?
04:00:35 <ski> filtering, and the looking to see if an element was present ?
04:00:48 <ski> filtering, and finding the minimum, wrt an ordering ?
04:00:59 <mux> mmm, S.fromList [] == S.empty, and also foldr S.insert S.empty == S.fromList, right?
04:01:29 <ski> probably
04:01:41 <ski> @type S.fromList
04:01:41 <ski> @type S.empty
04:01:42 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
04:01:43 <lambdabot> forall a. S.Set a
04:01:43 <mux> > 1 `S.member` S.fromList [0..]
04:01:47 <lambdabot>   mueval-core: Time limit exceeded
04:01:48 <ski> not quite the same type ..
04:02:00 <mux> I'm saying S.fromList []
04:02:16 <mux> :t S.fromList []
04:02:17 <lambdabot> forall a. (Ord a) => S.Set a
04:02:25 <ski> (oh, and s/==/=/ :)
04:03:08 <maurer_> ski: A few things. For finite types, it would be useful to be able to generate a table of all outputs both for testing purposes and for precomputation, and for infinite ones searching for some property would be nice.
04:03:36 <ski> agreed
04:03:50 <maurer_> For example, say that I wanted to find out what IPs responded to ping. It would be nice if I could do something like mapM pingTest ((0,0,0,0)..(255,255,255,255))
04:03:57 <maurer_> err, there should be [] instead of ()
04:04:00 <maurer_> but you get the idea
04:04:25 <ski> possibly `class Domain a where domain :: [a]' or `class Domain a where domain :: ListSet a' would be nice, for that
04:04:49 <ski> (with an `ListSet a -> IO [a]' operation, to choose an ordering)
04:05:37 <maurer_> If you look at the IP case there, it's a place where setting an upper bound makes sense.
04:06:07 <ski> hm, upper bound of what ?
04:06:17 <maurer_> Upper bound of the enumeration
04:06:37 <maurer_> I suppose we could just use Domain and Ord in combination to derive an upper bound
04:06:56 <ski> would you like `[(0,0,0,0)..(255,255,255,255)]' to diagonalize, or to do lexicographic ordering ?
04:07:44 <maurer_> While lexographic ordering is nice, it's not autoderivable.
04:08:10 <maurer_> Diagonalization would mean that if I was feeling lazy, I could do [(0, 0, 0, 0)..] and it would work
04:08:41 <maurer_> If I did that and we were using lexo ordering, it would fail to enumerate some elements
04:08:48 <ski> > curry range (2,4) (3,6)  -- sometimes you might want this behaviour, instead
04:08:49 <lambdabot>   [(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
04:10:10 <ski> (or maybe that's what you actually wanted in your IP example, assuming you used `Int' or `Integer' or something similar, instead of `Int8')
04:11:51 <Veinor> man, I wish I could get a full stack trace when something errors
04:13:14 <ski> (maurer_ : anyway, just to make it clear. i'm not opposed to something that would help with what you're talking about .. i'm just not sure how best to do it .. i don't think `Enum' is the way to go, anyway)
04:18:18 * hackagebot fuzzytime 0.7 - A clock and timer that tell the time in a more human way  http://hackage.haskell.org/package/fuzzytime-0.7 (KamilStachowski)
04:19:04 * ski . o O ( fuzzy time ? what will they think of next ? )
04:20:28 <lantti> What scale it uses then... My personal clock works more or less binary "too early" - "too late" :)
04:21:43 <Veinor> i wish hxt had a better way to inject an arrow's output after runLA into another arrow than using constL
04:22:04 <Veinor> oh well.
04:37:13 <otulp> When calling a Haskell function from C, how do I allocate an array in Haskell and return it to C so that it is usable from C? I'm thinking I need a StablePtr in order for GC not to interfere, but at the same time, StablePtr is opaque from C. I'm thinking I could allocate memory with mallocArray, wrap that in a StablePtr, then return both the Ptr and the StablePtr to C. From C, I could then use the Ptr to access data, and later call back ...
04:37:19 <otulp> ... into Haskell with the StablePtr to free it. But that seems kinda messy.
04:37:33 <Cale> otulp: Use a StorableArray?
04:37:54 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Storable.html
04:41:05 <otulp> Not quite seeing it yet. Note that I'm calling Haskell from C, not C from Haskell.
04:43:29 <quicksilver> otulp: you just want a Ptr, I think.
04:44:45 <quicksilver> Cale: AFAIK StorableArray is not pinned longterm; its Ptr is only safe within the execution of the 'callback'.
04:46:43 <Axman6> how do you get forall again? which extension?
04:46:54 <luite> ScopedTypeVariables
04:47:00 <luite> something like that ;p
04:47:32 * Axman6 pokes quicksilver 
04:48:07 <quicksilver> Axman6: RankNTypes, RankTwoTypes, or ScopedTypeVariables
04:48:11 <quicksilver> or, probably, some other things.
04:48:22 <sipa> Rank2Types
04:49:34 <sipa> or ExistentialTypes
04:49:58 <ski> `ExplicitForall'
04:49:58 <peoro> @src foldr
04:49:59 <lambdabot> foldr f z []     = z
04:49:59 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:50:29 <ski> (hm, no s/Forall/ForAll/, apparently)
04:50:53 <Axman6> bleh, i need the fastest way to take a create a STUArray and then turn that into a UArray
04:51:12 <quicksilver> unsafeFreeze is a fast way to turn it into a UArray, no?
04:51:22 <Axman6> sure, but i can;t get the types to work :9
04:51:23 <ski> @hoogle runSTUArray
04:51:23 <lambdabot> Data.Array.ST runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
04:51:24 <Axman6> :(
04:51:57 <ski> (there should be a `forall s.' wrapping the argument type, there ..)
04:52:40 <ski> @type Data.Array.ST.runSTUArray
04:52:41 <lambdabot> forall i e. (Ix i) => (forall s. ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
04:52:45 <ski> ah, that's better
04:53:25 <Axman6> well that's what i'm using.
04:53:41 <Axman6> wondering if it's doing a copy or not, time to check the source
04:54:22 <Axman6> seems to use unsafeFreezeSTUArray internally
04:55:11 <mux> whoa, someone found a finite, algebraic formule for directly computing the partition function; now project euler is going to have to change half the exercises
04:55:27 <Cale> mux: lol
04:56:22 <quicksilver> is it feasible, though?
04:56:38 <quicksilver> (i.e. would it actually be faster than the approaches people were already using?)
04:56:48 <mux> according to people, yes
04:56:53 <mux> see http://blogs.plos.org/badphysics/2011/01/20/ono/
04:57:04 <mux> quoting the author: "I can take any number, plug it into P, and instantly calculate the partitions of that number. P does not return gruesome numbers with infinitely many decimal places. It.s the finite, algebraic formula that we have all been looking for."
04:59:25 <Cale> I think that 'instantly' is a bit much
05:00:04 <mux> yeah, but that's what makes me think that this is indeed supposed to be faster than other means of computing p(n)
05:00:32 <Cale> I couldn't understand the paper well enough to confirm that there actually was a better algorithm there...
05:00:44 <Cale> But there might be :)
05:03:45 <mux> yeah, the paper is way over my head as well
05:06:39 <Veinor> oh god, i'm tempted to write a string-manipulation glue script in haskell
05:06:40 <Veinor> SOMEBODY STOP ME
05:06:50 <otulp> quicksilver: (re. "you just want a Ptr") But I imagine the Ptr could then get eaten by GC before I try to use it in C land.
05:07:31 <quicksilver> otulp: it doesn't matter if it is.
05:07:40 <quicksilver> otulp: a pointer is just a pointer.
05:07:51 <quicksilver> otulp: it being GCed does not affect the range of memory it pointed to.
05:08:06 <Cale> "To describe the new formula, we consider discriminant -24 n + 1 = b^2 - 4ac positive definite integral binary quadratic forms Q(x,y) = ax^2 + bxy + cy^2 with the property that 6 divides a.
05:08:21 <Veinor> Cale: ?
05:08:31 <Cale> Just a quote from the paper :)
05:08:41 <otulp> quicksilver: ...but they that memory could happily be re-used by Haksell, destroying its contents.
05:08:42 <mux> Cale: "Example. We give an amusing proof of the fact that p(1) = 1. In this case, we have that
05:08:43 <Cale> I found the stack of adjectives somewhat amusing :)
05:08:45 <mux> 24n . 1 = 23, and we use the .0(6)-representatives"
05:08:49 <quicksilver> otulp: No.
05:08:52 <mux> "amusing", yeah right.
05:09:00 <quicksilver> otulp: well it depends how you allocated it, of course.
05:09:10 <quicksilver> otulp: a Ptr can point at anything - it's only a pointer!
05:09:27 <otulp> quicksilver: Allocated in haskell with mallocArray.
05:09:51 <otulp> ...or something similarly sensible.
05:10:03 <quicksilver> otulp: but memory allocated by Foreign.*.malloc will never be re-used by haskell.
05:10:38 <otulp> quicksilver: I didn't know that. So I can allocate in i Haskell, pass it back to C as a Ptr, then free it in C?
05:10:39 <quicksilver> (until you free it)
05:10:40 <maurer_> quicksilver: Unless you call free.
05:10:52 <quicksilver> otulp: you can't free it in C, no.
05:11:02 <maurer_> You could also attach a finalizer to it, yes?
05:11:06 <quicksilver> otulp: but your C can call back to haskell to free it, when you want to.
05:11:15 <quicksilver> maurer_: you could, but otulp specifically does not want to do that.
05:11:20 <maurer_> quicksilver: Ah.
05:11:23 <otulp> quicksilver: Then I'm all set. Thank you. 
05:11:47 <maurer_> otulp: Freeing it from C would not work because Haskell is using a different allocator.
05:12:36 <Cale> It seems like the algorithm they're suggesting involves computing a sufficiently precise approximations to certain complex numbers, where the bound can be predetermined, but it's not clear to me what the bound is, or whether it's any good.
05:13:16 <otulp> maurer_: OK. Makes sense.
05:13:19 <Cale> Using the theory of modular equations, one can bound the denominators of H_n(x). As a consequence, one can compute H_n(x) using sufficiently precise approximations of the P(αQ).
05:14:20 <romildo> #gentoo-haskell
05:14:20 <lambdabot> romildo: You have 1 new message. '/msg lambdabot @messages' to read it.
05:15:01 <Cale> It would be nice if they were to publish an expanded version of this paper which could be understood by more than about 10 people in the world.
05:16:13 <romildo> Hi.
05:16:36 <romildo> I am installing gtk2hs on windows using ghc-7.0.1.
05:17:31 <romildo> When running "cabal install glib" I am getting the error:
05:17:34 <romildo> Registering glib-0.12.0...
05:17:34 <romildo> setup.exe: internal error: unexpected package db stack: [UserPackageDB]
05:17:43 <romildo> Any clues?
05:18:25 <Cale> Well, I've never seen anything like that myself. (I don't use windows though.)
05:18:38 <Cale> It looks like possibly a cabal bug
05:18:44 <quuuux> romildo: cabal -v?
05:18:57 <quuuux> or whatever the Windows incantation is for that
05:19:53 <romildo> $ cabal --version
05:19:53 <romildo> cabal-install version 0.8.2
05:19:54 <romildo> using version 1.8.0.2 of the Cabal library
05:21:07 <romildo> But I have installed Cabal-1.10.0.0. And I am using the cabal binary 0.8.2 found in the cabal home page.
05:24:18 <accel> I have "myconverter blah.dsl -> blah.hs" is there a way to assocaite liens in blah.hs with lines in blah.dsl, so when the haskell compiler compalins about errors in blah.hs, it'll be converted to errors about blah.dsl ?
05:24:55 <quuuux> romildo: do you have any other versions of GHC on the machine?
05:25:07 <romildo> quuuux, no.
05:27:49 <romildo> quuuux, I work primarily on Gentoo Linux, where I also use ghc-7.0.1, cabal-install-0.8.2 and cabal-1.10.0.0, and it works. Now I want to build a binary of my application in Windows.
05:29:59 <quuuux> romildo: some googling suggests that your error was fixed in GHC 6.12.3, and (suspiciously) Cabal 1.8.0.2 happens to be the version 6.12.1 uses. Try using a later version of Cabal?
05:31:21 <accel> ;/join #ocaml
05:32:21 <Veinor> gasp! channel advertising!
05:33:11 <aavogt> accel: there's a pragma that looks something like  {-# LINE 42 #-}
05:33:21 <aavogt> look at what hsc2hs does
05:33:32 <accel> nice; thanks
05:34:30 <accel> is there tnohing like camlp4, but for haskell ?
05:35:56 <aavogt> accel: people use CPP :p
05:36:11 <aavogt> I guess it's not really comparable though
05:36:40 <accel> what's CPP ?
05:37:04 <aavogt> accel: also look through ghc's manual. Some extensions like QuasiQuotes can be used for new syntax
05:37:09 <aavogt> accel: the C preprocessor
05:37:31 <aavogt> you can ask ghc to run arbitrary preprocessors over your code
05:40:22 <maurer_> accel: What do you want to use camlp4 for?
05:40:50 <maurer_> accel: Mostly I'm asking because most things I've seen it used for, you don't actually need in GHC due to some random thing.
05:40:52 <Axman6> what is camlp4?
05:40:59 <maurer_> accel: You may also want to look into template haskell
05:41:50 <aavogt> Axman6: it's a preprocessor that comes with ocaml, which is supposedly pretty decent for adding new syntax
05:42:27 * quuuux was on the verge of using an ungodly combination of TH and CPP earlier, but saw wisdom before such an abomination could be constructed
05:42:30 <accel> maurer_: i've been looking at template haskell
05:42:36 <accel> maurer_: but the syntax doesn't look to change much
05:42:47 <accel> maurer_: do you have an example where template haskell can parse code taht looks like scheme, or C?
05:44:35 <danr> accel: are you looking for something like this? http://hackage.haskell.org/package/BNFC-meta-0.1.0.1
05:45:01 <aavogt> or something like http://haskell.org/haskellwiki/Quasiquotation
05:45:15 <aavogt> oh, that's the same thing
05:49:54 <maurer_> accel: With TH you can always just make a function that maps the string containing your code onto haskell code, which will be autogen'd at compile time.
05:50:35 <maurer_> The quasiquoting they linked does this, just with a slightly nicer syntax
05:50:51 <jacobian> hmmm, sometimes I wish n-tuples were syntactic sugar for repeated pairs
05:51:21 <accel> maurer_: hmm; tahnks
05:51:27 <accel> is it possible to download real world haskell as apdf
05:51:28 <accel> to print
05:51:32 <accel> rather than a bunch of online htmls?
05:53:46 <quicksilver> accel: somebody did once produce a PDF but it wasn't widely distributed; the authors would rather you bought the book if you want to read offline, I would imagine.
05:56:17 <accel> quicksilver: but I don't want to buy an ipad just to read this book
05:57:15 <quicksilver> that appears to be a non-sequitur.
05:57:21 <shawn-p> I need Smart People(tm) to confirm that there is a really interesting and hilarious bug (affecting at least a dozen languages) in the Computer Language Shootout "binarytrees" benchmark:  
05:57:22 <shawn-p> http://shootout.alioth.debian.org/u32/performance.php?test=binarytrees
05:57:23 <quicksilver> I was referring to the version printed on pulped dead trees.
05:57:30 <quicksilver> no ipad required.
05:57:42 <shawn-p> first notice that there is an apparent discontinuity in the "CPU secs" column 
05:58:03 <shawn-p> it goes 65.75, 66.31, 69.44, 116.48, 124.37...
05:58:12 <shawn-p> that caught my interest so I looked into it further
05:58:46 <shawn-p> it turns out that the programs executing < 80 seconds use an algorithm that does *significantly* less work, I believe
05:58:53 <shawn-p> its output is identical, which is why it wasn't noticed
05:59:06 <shawn-p> for example in the LuaJIT example... http://shootout.alioth.debian.org/u32/program.php?test=binarytrees&lang=luajit&id=2
05:59:18 <shawn-p> local left, right = BottomUpTree(i-1, depth), BottomUpTree(i, depth)
05:59:41 <engla> shawn-p: it's not supposed to be allowed to change the algorithm
06:00:14 <shawn-p> and the haskell example:  http://shootout.alioth.debian.org/u32/program.php?test=binarytrees&lang=ghc&id=1
06:00:21 <shawn-p> make :: Int -> Int -> Tree
06:00:21 <shawn-p> make i 0 = Node i Nil Nil
06:00:21 <shawn-p> make i d = Node i (make (i2-1) d2) (make i2 d2)
06:00:21 <shawn-p>   where i2 = 2*i; d2 = d-1
06:00:39 <shawn-p> notice that LuaJIT uses "depth", whereas haskell uses "depth-1"
06:01:12 <shawn-p> I believe this is a fundamental difference, and the reason why so many programs in the "binarytrees" benchmark are executing so slowly (PHP is a stellar 44 minutes)
06:01:24 <exDM69> what do the exclamation marks do in data constructors? like data Tree = Nil | Tree !Int !Tree !Tree in that example?
06:01:47 <Zao> exDM69: Strictness annotations.
06:01:58 <exDM69> Zao: -funbox-strict-fields?
06:02:23 <mux> exDM69: that's an optimization that relies on strictness annotations.
06:02:32 <mux> (-funbox-strict-fields)
06:02:38 <Zao> http://www.haskell.org/tutorial/moretypes.html
06:02:40 <aavogt> funbox!
06:02:48 <Zao> See section 6.3 or so
06:03:43 <aavogt> also, dangerous flags start with -funsafe
06:04:01 <portnov> @hoogle Int -> a -> [a] -> [a]
06:04:02 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
06:04:02 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
06:04:02 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
06:05:26 <mux> exDM69: if you know what 'seq' is, and view the Tree type constructor just as a simple Int -> Tree -> Tree -> Tree function, then the strictness annotation causes 'seq' to be applied to the 3 parameters.
06:05:44 * Zao puts mux in WHNF.
06:06:21 <exDM69> mux: I have only seen seq used with par
06:07:04 <mux> exDM69: well, 'seq' forces its first parameter to be evaluated to WHNF (weak-head normal form), which you can view as fully evluating the leftmost type constructor
06:07:21 <ski> @hoogle pseq
06:07:21 <lambdabot> Control.Parallel pseq :: a -> b -> b
06:07:25 <ski> @hoogle par
06:07:26 <mux> I'm not sure that makes much sense
06:07:26 <lambdabot> Control.Parallel par :: a -> b -> b
06:07:26 <lambdabot> Text.Html paragraph :: Html -> Html
06:07:26 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
06:07:28 <ski> @hoogle seq
06:07:28 <lambdabot> Prelude seq :: a -> b -> b
06:07:29 <lambdabot> Data.Sequence data Seq a
06:07:45 <mux> that is, the "leftmost type constructor" part, but I'm not sure how else to say it
06:10:58 <ski> outermost data constructor, rather
06:11:19 <ski> (`Maybe' and `Int' are type constructors; while `False' and `Just' are data constructors)
06:14:48 * hackagebot quick-generator 0.3 - Generator random test data for QuickCheck  http://hackage.haskell.org/package/quick-generator-0.3 (YuriyIskra)
06:22:43 <quicksilver> evaluating from the outside until you meet either a data constructor or a lambda.
06:23:54 <teki> is there an efficient version of read for bytestrings?
06:24:10 <maurer_> teki: Look at attoparsec ?
06:24:30 <maurer_> If you're caring about String vs ByteString, you probably don't want to use the derived show and read for serialization
06:25:11 <teki> maurer_: i just have to read a lot of doubles from a file; would attoparsec be the best bet?
06:25:49 <teki> right now reading doubles is ~70% of program runtime, which means i need to rewrite with bytestring
06:26:22 <maurer_> Why not change the program that's shipping you doubles printed out instead of as binaries?
06:27:37 <teki> maurer_: no control over input
06:28:17 <maurer_> Oh, this is one of those silly programming problems from Euler and similar?
06:29:08 <teki> maurer_: nope, this is a real world program
06:29:32 <teki> maurer_: for uni research
06:30:52 <teki> maurer_: anyway, attoparsec seems to be what i need; thanks much
06:30:55 <maurer_> OK.
06:31:55 <quicksilver> teki: attoparsec looks possible, alternatively http://hackage.haskell.org/packages/archive/bytestring-lexing/0.1.2/doc/html/Data-ByteString-Lex-Double.html
06:32:00 <dafis> teki:  the Read (and Show) instances of Double (and othe number types) are awesomely slow, you can get it much faster by writing your own parser (ByteString or not)
06:57:24 <gwern> @wn captious
06:57:27 <lambdabot> *** "captious" wn "WordNet (r) 2.0"
06:57:27 <lambdabot> captious
06:57:27 <lambdabot>      adj : tending to find and call attention to faults; "a captious
07:17:36 <krey_> why is the kind of (->) :: ?? -> ? -> *
07:17:38 <krey_> ?
07:19:00 <quicksilver> krey_: very roughly, the implementation of parametric polymorphism means that a polymorphic (->) can't take unboxed arguments
07:19:11 <quicksilver> it's a GHC implementaiton detail.
07:19:33 <krey_> quicksilver: but it should intuitively be: * -> * -> *, right?
07:20:17 <quicksilver> yes.
07:20:22 <quicksilver> it is, really.
07:20:39 <quicksilver> for the '*' you care about, it's * -> * -> *
07:20:54 <quicksilver> GHC's * contains 'more' types, and some of those don't work in it.
07:21:25 <djahandarie> @type (# 1, 2 #)
07:21:26 <lambdabot> forall t t1. (Num t, Num t1) => (# t, t1 #)
07:22:01 <djahandarie> @kind (# Int, Int #)
07:22:03 <lambdabot> (#)
07:22:14 <krey_> quicksilver: thx
07:26:05 <lars9> 
07:43:47 <llambda> If a question asks "For what values of P is the population increasing?" is   ∀P∈ℕ : P≥3  a valid form of the answer? Or do I need to write {P : P∈ℕ, P≥3}
07:46:38 <Eduard_Munteanu> llambda: I'd give an answer in the form of   P ∈ { n ∈ ℕ, n ≥ 3 }
07:46:54 <Eduard_Munteanu> erm... P ∈ { n ∈ ℕ | n ≥ 3 }
07:47:48 <Eduard_Munteanu> But it's a bit pedantic, I'm sure others work.
07:48:36 <llambda> Wouldn't n ∈ ℕ being on the left of the | mean that it is a set full of... booleans? *not sure how math notation works*
07:49:46 <dafis> { a | P } means "the set of all a such that P"
07:49:48 <Eduard_Munteanu> No, not really. { n ∈ ℕ | n ≥ 3 } and { n | n ∈ ℕ and n ≥ 3 } are equivalent.
07:49:54 <dafis> same as {a : P}
07:50:05 <copumpkin> where there's an implicit binding between the left hand side and right hand side
07:50:07 <copumpkin> oddly enough
07:50:26 <copumpkin> Sigma Nat (\n -> n >= 3)
07:50:55 <Eduard_Munteanu> Though I give you that, the notation isn't that strict.
07:51:06 <Veinor> copumpkin: haha
07:51:33 <llambda> copumpkin, Sigma Nat?
07:51:41 <llambda> Is this Agda? :)
07:51:46 * Eduard_Munteanu wonders why ℕ here shows with blue and red vertical bars
07:51:47 * copumpkin looks shifty-eyed
07:51:54 <copumpkin> llambda: maybe :)
07:52:01 <llambda> Wait no, if this was Agda it'd have unicode all over it
07:52:07 <copumpkin> well, I was too lazy to type that
07:52:25 <llambda> What does Sigma do?
07:52:45 <copumpkin> it basically encodes the notation Eduard_Munteanu just wrote
07:52:52 <copumpkin> it's an existential with a condition
07:52:58 <Eduard_Munteanu> My answer was assuming this was for an assignment/paper/homework/exam, not for automated theorem proving/checking.
07:52:59 <copumpkin> alternately, an n-ary sum
07:53:31 <llambda> Eduard_Munteanu, it's for the hell of it, but I'd like to be able to plug it into an automated theorem prover if I had the chance :)
07:54:05 <copumpkin> llambda: you can think of it as a subset of its first parameter
07:56:31 <llambda> So I could Sigma Bool (\b -> b /= false) and that would basically be the set {true} ?
07:56:45 <copumpkin> yep
07:57:31 <aristid> :t \b -> b /= False
07:57:32 <lambdabot> Bool -> Bool
07:57:44 <aristid> llambda: \b -> b /= False is just id
07:57:48 <Veinor> isn't that just... yeah
07:57:51 <Veinor> it's id :: Bool -> Bool
08:11:18 * hackagebot HDBC-postgresql 2.2.3.3 - PostgreSQL driver for HDBC  http://hackage.haskell.org/package/HDBC-postgresql-2.2.3.3 (JohnGoerzen)
08:20:49 <_mpu> @pl \f g -> f . g
08:20:50 <lambdabot> (.)
08:21:20 <_mpu> @unpl . (.)
08:21:20 <lambdabot> (\ d g -> d (\ b c -> g (b c)))
08:22:23 <_mpu> @unpl \f g -> (f .) . g
08:22:23 <lambdabot> \ f g d i -> f (g d i)
08:22:52 <_mpu> @pl \f g -> (f .) . g
08:22:52 <lambdabot> (.) . (.)
08:25:40 <gigabytes> lambdabot: help
08:25:59 <gigabytes> who can i know more about this bot's commands?
08:27:29 <aristid> gigabytes: /query him and try @help or so
08:27:33 <Botje> /msg lambdabot @help
08:27:35 <aristid> or her
08:27:43 <aristid> @vixen a/s/l
08:27:44 <lambdabot> 19/f/California
08:31:12 <Bel> Hi
08:31:50 <Bel> someone here to help me wih a program im trying to write? im new to haskell...
08:33:12 <ski> @where paste
08:33:13 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
08:33:25 <ski> paste what you've got at one of those sites ?
08:35:03 <Bel> done
08:35:15 <alpounet> we need the url to take a look at it, of course.
08:35:26 <Bel> http://paste.lisp.org/display/118976
08:35:54 <Bel> its supposed to get me the last two entries of the list
08:36:22 <gigabytes> Bel: why do you mess with the length?
08:37:18 <Bel> well, to know what the last elements are, i need to know the length of the thing, dont i?
08:37:56 <llambda> You can do it with pattern matching
08:38:08 <Bel> so i took the length end started counting down from there
08:38:22 <llambda> f (x : y : []) = ...   will only run when you have two elements left
08:38:33 <lunaris> Or even f [x,y]
08:38:53 <Bel> that sounds good... ill try it, thanks
08:39:14 <lunaris> lastTwo xs = [last (init xs), last xs] (though this is very inefficient)
08:39:31 <lunaris> So as llambda suggests, best to pattern match.
08:40:22 <gigabytes> take 2 $ reverse list
08:40:26 <gigabytes> :P
08:40:59 <troutwine> I'm trying to get up and going with parser combinators but I'm not steady yet. Can someone take a look at this and point me in the right direction: https://gist.github.com/793501#comments
08:41:36 <llambda> Should start with Parsec and String if you're just starting with parser combinators
08:42:13 <troutwine> Yeah. I'm researching the feasibility of doing something like Erlang's bit-syntax in Haskell.
08:43:20 <troutwine> Also, unless I'm quite mistaken, my lack of understanding will transfer to Parsec and I'll not gain any new insight rocking String.
08:45:29 <Bel> hmmm... now it says there's an unexpected "=" in the last line... http://paste.lisp.org/display/118976#1
08:45:50 <troutwine> llambda: Am I off the mark; how will transferring to Parsec help?
08:46:24 <llambda> troutwine, Parsec generally has more combinators and removes all the extra junk with Word and Char8
08:46:55 <Veinor> Bel: works fine for me
08:46:59 <aavogt> Bel: don't mix tabs and spaces
08:47:05 <Veinor> ... oh. yeah.
08:47:17 <aavogt> oh I guess it doesn't matter in that case
08:47:36 <troutwine> llambda: Parsec doesn't parse machine words, yes?
08:47:48 <aavogt> but just because you can make a mix of the two work, doesn't mean you should
08:48:21 <llambda> troutwine, you can use ByteString with it, but if you're just trying to familiarize yourself with parser combinators I don't see why you'd do that
08:48:51 <Bel> we were told only to use spaces and i did... but i just noticed my editor uses tabs if i press return -.-
08:49:00 <Philippa_> troutwine: it can do, but nobody's written code to make it split up the inside of a word usefully that I've seen
08:49:05 <troutwine> llambda: I mispoke somewhat; I'm trying to get to grips with attoparsec's combinators. 
08:49:19 <Philippa_> ah, attoparsec's definitely worth a play with
08:49:29 <Philippa_> (talking of which, at some point I'm going to have to name a new parsing combinator lib)
08:50:17 <Bel> thanks now it works for me too
08:50:35 <troutwine> llambda: That said, I don't understand why I'm not consuming any of the input with my current dippy setup.
08:50:55 <llambda> I'm not sure either and I don't have anywhere to code right now so I can't help with that :(
08:51:11 <troutwine> bos' HTTP parser looks simple enough, but clearly I'm not understanding something.
08:51:24 <troutwine> llambda: No worries; thanks.
08:51:58 <troutwine> Philippa_: Maybe you have an idea?
08:52:25 <llambda> troutwine, what happens if you put a space at the start of your string?
08:53:32 <Philippa_> I don't actually know Attoparsec all that well, FWIW: does it use the same trick with try/LL(1)-by-default as Parsec?
08:54:00 <Philippa_> and yeah, skipSpaces fails if there's no space
08:54:41 <troutwine> llambda: Hurm, it pulls off "That" from the input. I need to ponder a bit more.
08:54:57 <llambda> Yep, it also takes the space after it
08:55:05 <llambda> Meaning it'll die again on skipSpaces
08:56:03 <Philippa_> yeah, your 'word' parser should adopt a convention and (normally) munch only the spaces before the word
08:56:38 <troutwine> Oh, damn, because my little functor buddies aren't replacing characters on the stream. D'oh.
08:56:48 <quicksilver> one of the reasons I prefer to lex in a separate step is not to have to worry if I munch spaces before or after words. Perhaps that viewpoint is incompatible with attoparsec though.
08:57:28 <Philippa_> quicksilver: yeah, me too. Also (though not enough libs can exploit this) the smaller your token classes the less work a grammar optimiser's got to do
08:58:06 <Philippa_> if you're parsing character-by-character and you've got keywords, no way in hell your grammar's LL(1) for example
08:58:26 <quicksilver> right.
08:58:42 <quicksilver> looksexactlylikeakeywordbutgoeswrongattheverylastcharacteZ
08:58:50 <Philippa_> (why yes, the lib I'm trying to piece together /does/ do optimisation)
08:59:24 <Philippa_> in fact, once I've got my head around the various options for derivatives of regexes, I reckon I can have it annotate a grammar with try/commit calls for you
08:59:42 <llambda> I think someone needs to layout all the various ways to do parsing in Haskell and note pros/cons of each
08:59:44 <Philippa_> (though I have some thinking to do: I /think/ there's cause to have 'delimited commit')
08:59:52 <troutwine> Philippa_: That would be quite fancy. 
09:00:25 <Philippa_> troutwine: eh, most of it's fairly straightforward for the class of language I've picked thankfully, but yeah
09:01:07 <Philippa_> I ought to be able to get good error correction with some further work too, and a built-in layout system that handles most of the equivalent of the error-rule case without actually needing to catch parse errors :-)
09:02:03 <mdwright_laptop1> I'm working my way through Real World Haskell and one of the problem is to create an asInt :: String -> Int function. Is there a better way to tell when you're going to overflow an Int than by converting to an integer, doing the addition, checking, and converting back to an Int if you're below the maxBound::Int?
09:02:33 <Zao> mdwright_laptop1: Roundtrip to a String again, see if it matches?
09:03:05 <Philippa_> mdwright_laptop1: you can start by counting the digits?
09:03:25 <Philippa_> but converting to Integer first is probably the way to go
09:03:42 <Philippa_> just, do the lot to Integer first?
09:04:33 <mdwright_laptop1> Philippa_: I thought about that. My issue with it is that the over flow isn't on a boundary of 10s, so if the number happens to be between maxBound and the 10^(number of digits in maxBound), even though it won't overflow, I error out saying it will
09:04:50 <mdwright_laptop1> Philippa_: Yeah, sorry, I was going to do all the addition as Integer, then check and unconvert at the end.
09:04:58 <mdwright_laptop1> or rather, convert to Int at the end.
09:05:01 <Philippa_> mdwright_laptop1: sure, 'twas only a first-pass suggestion
09:05:17 <mdwright_laptop1> Philippa_: Yeap! And I appreciate the help :-)
09:05:19 <Philippa_> but yeah, the other way's probably much better - running the length of the String's likely to be your dominant cost anyway
09:05:45 <aavogt> if the digit counting is close to overflow, you might be guaranteed to end up with a number rather close to minBound, no?
09:05:59 <aavogt> less than one of the starting numbers
09:06:57 <mdwright_laptop1> aavogt: so you're saying if it's within the 10^number of digit and maxInt, do the conversion, check if it has the same sign as the initial part of the string (it'll be a '-' if negative, numeral otherwise)?
09:07:07 <aavogt> > maxBound + maxBound :: Word8
09:07:09 <lambdabot>   254
09:07:30 <SKK> hey
09:07:53 <SKK> what's the status of the union-find data structure?  still no functional implementation?
09:09:07 <SKK> is there anyone alive out there?
09:09:46 <SKK> :o
09:09:55 <mdwright_laptop1> SKK: Just you.
09:10:08 <SKK> :O
09:10:59 <aavogt> @check \x y -> any (< (maxBound :: Word8)) [x,y] || any (x+y<) [x,y] || fromIntegral (x+y) == fromIntegral x + fromIntegral y
09:11:01 <lambdabot>   "OK, passed 500 tests."
09:11:38 <aavogt> \x y -> not (any (< (maxBound :: Word8)) [x,y]) || any (x+y<) [x,y] || fromIntegral (x+y) == fromIntegral x + fromIntegral y
09:11:49 <aavogt> @check \x y -> not (any (< (maxBound :: Word8)) [x,y]) || any (x+y<) [x,y] || fromIntegral (x+y) == fromIntegral x + fromIntegral y
09:11:50 <lambdabot>   "OK, passed 500 tests."
09:12:29 <aavogt> mdwright_laptop1: that's what I mean ^
09:13:23 <aavogt> @check \x y -> all (< (maxBound :: Word8)) [x,y] || any (x+y<) [x,y] || fromIntegral (x+y) == fromIntegral x + fromIntegral y
09:13:25 <lambdabot>   "OK, passed 500 tests."
09:13:42 <aavogt> @check \x y -> any (x+y<) [x,y] || fromIntegral (x+y) == fromIntegral x + fromIntegral y
09:13:43 <lambdabot>   "OK, passed 500 tests."
09:14:37 <aavogt> @check \x y -> any (x+y<) [x,y] || fromIntegral (x+y) /= fromIntegral x + fromIntegral y
09:14:38 <lambdabot>   "Falsifiable, after 0 tests:\n0\n2\n"
09:15:27 <mdwright_laptop1> aavogt: gotta parse that... but need to search out power first. 
09:15:37 <mdwright_laptop1> thanks for the help though :-)
09:16:00 <aavogt> don't count on it making sense
09:23:05 <mm_freak_> is there a technical problem with circular module dependencies or why are they not allowed?
09:23:31 <quicksilver> mm_freak_: there is a technical problem, but they are nonetheless allowed.
09:23:54 <tac-tics> Because intuitionists had impredicativity
09:24:07 <tac-tics> Hate*
09:24:12 <mm_freak_> quicksilver: i'm getting errors, when i try to have cirular deps
09:24:20 <jacobian> impredicativity is alright for intuitionistic logic 
09:24:40 <quicksilver> mm_freak_: that's because you don't know how to do them
09:25:10 <quicksilver> mm_freak_: http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/separate-compilation.html#mutual-recursion
09:25:28 <jacobian> Prop in CoC is impredicative 
09:25:32 <mm_freak_> quicksilver: thanks
09:25:44 <kuffaar> CoC = ?
09:25:51 <jacobian> Calculus of Constructions 
09:26:07 <kuffaar> Is that a boring subject?
09:26:19 <jacobian> CoC is amazing
09:26:19 <aavogt> there was some preprocessor that merged modules into a single file. This was intended to get better 'whole program optimization'. Does anybody remember what it was called?
09:26:24 <jacobian> Not boring at all
09:26:24 <tac-tics> Coc is awesome
09:26:35 <Peaker> what is CoC useful for?
09:26:47 <tac-tics> Nothing and everything
09:26:58 <kuffaar> Peaker: For passing exams at university
09:26:59 <jacobian> Well, Coq is Calculus of (Co)-Inductive Constructions
09:27:01 <mdwright_laptop> Peaker: have you heard of coq?
09:27:05 <jacobian> And that's fairly useable 
09:27:11 <jacobian> [for some things]
09:27:24 <tac-tics> In coc, you can prove almost anything you would care about in a "natural" wqay
09:27:41 <jacobian> I think it's an image from the future
09:27:51 <jacobian> It's what haskell will move towards eventually 
09:27:51 <Peaker> mdwright_laptop, yeah
09:28:25 <mdwright_laptop> Peaker: See jacobian's responses. :-)
09:28:31 <kuffaar> I thought Haskell was a programming language and not a theorem prover
09:28:47 <quicksilver> aavogt: I think you mean http://www.cs.utah.edu/~hal/HAllInOne/
09:28:48 <tac-tics> it gets blurry after a while
09:28:55 <Peaker> How is CoC related to dependent types? 
09:29:21 <tac-tics> Peaker, you can write types that contain terms
09:29:47 <tac-tics> Such as "Sorted l" which is the proposition that l is a sorted list
09:29:47 <mm_freak_> quicksilver: so there is no simple standard way to do it?
09:29:57 <mm_freak_> quicksilver: or perhaps an extension?
09:31:12 <quicksilver> mm_freak_: GHC is, as far as I know, the only compiler that supports recursive modules.
09:31:17 <Peaker> tac-tics, Yeah, I know the basics of DT, I wonder how CoC relates to that
09:31:23 <quicksilver> mm_freak_: so, the way GHC does is the best way at present.
09:31:39 <tac-tics> Coq supports them.
09:31:48 <tac-tics> That's how it relates
09:31:51 <mm_freak_> ok, thanks
09:32:25 <quicksilver> mm_freak_: in my experience it is often better to avoid them by factoring out base definitions (often these are mostly types) into a common module, or similar
09:33:28 <kuffaar> What is the origin of the lambda in the lambda calulcus? Did Church just pick a random Greek letter or does it have any etymological relevance?
09:33:53 <jacobian> Peaker: In Coq proofs are done as dependent types.  In order to prove something, you have to find a program which has the type of the proof you want. 
09:33:59 <Philippa_> Peaker: CoC is Fw + dependent types, CiC is CoC plus (co)inductive types
09:34:39 <jacobian> Peaker: Alternately, you can think of it simply as a programming language with dependent types. 
09:34:56 <quuuux> preflex: xseen BONUS
09:34:56 <preflex>  BONUS was last seen on freenode/#haskell 13 days, 5 hours, 18 minutes and 12 seconds ago, saying: j-invariant: <> would be a cool name for mappend, but i don't know if they plan on adding that
09:35:35 <mm_freak_> quicksilver: yes, but either i get much longer modules by that or i get lots of them
09:37:09 <quuuux> @tell BONUS Hi, I have a friend using a screenreader who's interested in learning Haskell. Due to this, the 'layout' syntax convention is unsuitable for him. Could you please provide a version of LYAH using braces for such an audience?
09:37:09 <lambdabot> Consider it noted.
09:39:26 <quuuux> who's the best person to pester about that for RWH? dons?
09:40:32 <kuffaar> quuuux: I converted LYAH to LaTeX btw
09:40:44 <kuffaar> I wrote a script which can do that on any box
09:41:03 <Philippa_> quuuux: I know it's not ideal, but you can probably write a script to add "indent <n>" annotations on each line for a screen-reader to pick up?
09:41:10 <kuffaar> I did this because I am reading it on my e-reader
09:41:19 <Philippa_> (plus having the script'd be useful for other haskell code - most people use layout)
09:42:01 <quuuux> Philippa_: yeah, there are hackish work-arounds like that. The problem in using them for pedagogical code is that it's another barrier between 'doing as I say' and 'doing as I do'
09:42:01 <Philippa_> you could also try running code through something like John Meacham's Get Laid library
09:42:37 <gwern> Philippa_: I'm surprised there isn't some easy solution like readint it in with haskell-src-exts and writing it back out with an option toggled
09:42:47 <mdwright_laptop> kuffaar: would you be willing to share it?
09:42:51 <Philippa_> gwern: there might be, but I don't know what/where
09:42:52 <kuffaar> https://github.com/epicvrvs/learn-you-a-haskell
09:43:04 <Philippa_> gwern: it might be something the GHC API should expose
09:43:09 <kuffaar> There are still some minor errors in the output but overall it's alright
09:43:56 <kuffaar> mdwright_laptop: Somebody also made an epub version of it
09:44:02 <Philippa_> minor errors're major when you're trying to learn what is/isn't correct though
09:44:02 <kuffaar> It was somewhere on reddit
09:44:15 <ski> @where lyah
09:44:16 <lambdabot> http://www.learnyouahaskell.com/
09:44:22 <Philippa_> quuuux: it might be helpful to read the chunk of the report that specifies where all the braces are in the grammar, too
09:44:29 <Philippa_> (it was definitely useful for me!)
09:44:35 <ski> kuffaar : should we add you link to that ?
09:44:56 <kuffaar> ski: I don't know, I doubt there's big demand
09:45:05 <kuffaar> It's only for people who want a customised PDF really I think
09:45:07 <edwardk> You know your office is a strange place when you have a commutative diagram on the board that looks like: Nu -> Mu -> Milk -> Hot Chocolate -> Mocha <- Coffee <- Cofree 
09:45:19 <kuffaar> I had to enlarge the font because none of the PDF versions I tried were really useful for my reader
09:45:28 <kuffaar> And ePub support is rather meh
09:45:31 <edwardk> with attendant surrounding arrows for Cappucino, etc.
09:45:58 * ski grins
09:46:23 <gwern> edwardk: you took a photo I hope
09:46:30 * ski is reminded of the nice illustrations in the "Joy of Cats" (i.e. "Abstract and Concrete Categories")
09:46:45 <edwardk> gwern: we will as soon as we figure out a couple of the pullbacks =)
09:50:48 <Reemo> hey guys, i have a type "type Heap = Int -> Int" and "type State = (Int, [Int], Heap)". Do i need to rewrite those types in order to add a show instance to the Heap Type?
09:51:22 <ski> you will need to define a `newtype' or a `data', at the very least
09:52:00 <Reemo> ski, how shall i "convert" the type to a data...*something* ?
09:52:16 <ski> well, which do you want a `Show' for ?
09:52:26 <ski> only `State' ? only `Heap' ? both ?
09:52:27 <Eduard_Munteanu> Or use the TypeSynonymInstances extension.
09:52:40 <ski> Eduard_Munteanu : will not work here
09:52:43 <Reemo> Eduard_Munteanu, no option, but thanks for the hint
09:53:00 <Reemo> ski, Heap is the problem
09:53:16 <ski> well, what is the `Int' and `[Int]' part of the `State' ?
09:53:26 <ski> is the first maybe the current size of the heap ?
09:53:45 <Reemo> Would you mind if i query you for this particular issue?
09:53:58 <ski> why not continue talking in here ?
09:54:36 <Reemo> not being logged....
09:54:41 <ski> (that way, others can suggest things, and also others might learn from watching)
09:55:18 <Reemo> well okay
09:55:54 <ski> in any case, i would recommend only doing a `Show' instance if what you want is to generate a valid haskell expression, which will evaluate to the value shown
09:56:14 <ski> otherwise, i suggest you define your own `stateToString :: State -> String' function
09:56:38 <Reemo> ski, http://hpaste.org/43280/imp_implementation this is my code
09:57:21 <ski> if the other parts of the `State' tells how much of the `Heap' part is used, then you can use that to only convert that part of the heap to a string
09:58:16 <ski> (which would help with how to serialize the function there)
09:58:56 <ski> ok, the `[Int]' part looks like a stack ..
09:59:05 <Reemo> yeah it is ski 
09:59:20 <Reemo> You can see that an uninitialised heap space has the value 0
09:59:33 <Reemo> my idea was to just print out all heaps until the current heap space is 0
09:59:40 <Reemo> like...
10:00:37 <Reemo> [ (i, (h i)) | <- [0..(heapLength 0 h)]] where heapLength i h = if ((h i) == 0) then i else (heapLength (i+1) h)
10:01:25 <Reemo> something like that
10:01:29 <Reemo> efficiency isnt that important
10:01:54 <ski> well, are you sure that initialized parts of the heap will never contain `0's ?
10:02:09 <Reemo> okay, let it be (-1)
10:02:20 <ski> or contain `-1' ? :)
10:02:21 <quuuux> gwern: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.10.1/doc/html/Language-Haskell-Exts-Pretty.html#t:Indent
10:02:37 <quuuux> gwern: you were right to be surprised, because there is such a facility!
10:03:02 <Reemo> ski, if (h 5) = 1 but (h 3) = 0 this wouldnt work either
10:03:13 <ski> yeah
10:03:25 <Reemo> its not about perfection, its about learning haskell ;)
10:03:50 <ski> if you're willing to say that programs that store `-1' as data in the heap is bad, then it's fine
10:04:03 <ski> if you want, you could check in `sto' that `-1' is never stored in the heap
10:05:03 <Reemo> okay, thats just a matter of doing it. But how can i make Show work so one can test my application in ghci?
10:05:07 <ski> another possibility is to say `type Heap = (Int,Int -> Int)' where the first part in the pair is the current size of the heap
10:05:56 <ski> i'm still not sure why you want to do a `Show' instance, rather than just making a `stateToString :: State -> String' function
10:06:13 <Reemo> Isnt that good pratice?
10:06:41 <ski> imo, only if you're prepared to generate valid haskell expressions of the correct type
10:07:07 <Reemo> i just want (0, [0], emptyHeap) to print out (0, [0], []) in ghci
10:07:19 <ski> if all you want is to convert to a `String' (to print, or store in a file, or send over the network), then imo writing a separate function `stateToString :: State -> String' is better
10:07:44 <ski> well, if you define a function
10:08:02 <Reemo> that wouldnt be a problem
10:08:14 <Reemo> But my interest is in using Show to archieve this
10:08:22 <ski>   heapFromList :: Int -> [Int] -> Heap
10:08:39 <ski> then i don't think it's bad if you make a `Show' instance so that
10:08:43 <ski>   (0, [0], emptyHeap)
10:08:46 <ski> will print as
10:08:53 <ski>   (0, [0], heapFromList 0 [])
10:09:25 <Reemo> And how would i archieve this?
10:09:34 <Reemo> My only problem is defining a Show instance for a type
10:10:02 <ski> hm, actually it's not enough to say `-1's in the heap are uninitialized
10:10:05 <ski> as you said
10:10:11 <ski> <Reemo> ski, if (h 5) = 1 but (h 3) = 0 this wouldnt work either
10:10:24 <ski> but
10:10:25 <ski>   type Heap = (Int,Int -> Int)
10:10:28 <ski> would still work
10:10:35 <Reemo> No option to change the structure
10:11:09 <ski> then how will you know when to stop looking in the (conceptually) potentially infinite list that a `Heap' is ?
10:11:29 <Reemo> What i said, stop at the first (h i) == 0
10:11:40 <Reemo> It doesnt have to be complete nor perfect
10:11:52 <ski> what if the program stored `42' at address `8128', and `0' at address `496' ?
10:11:54 <Reemo> Its just for testing and learning how to add a show instance for a type
10:12:08 <Reemo> ski, I dont care in that case
10:12:43 <ski> ok, so you're assuming that your program only initializes the heap, from lower addresses, to higher ones
10:12:51 <Reemo> yepp
10:12:55 <ski> just as long as you're aware what you're assuming, it's all good
10:13:23 <ski> in any case, you need to do a `newtype' or `data' to make a `Show' instance, as i said
10:13:29 <ski> i.e.
10:13:39 <ski>   newtype Heap = MkHeap (Int -> Int)
10:13:40 <ski> e.g.
10:13:42 <ski> or
10:13:57 <ski>   data State = MkS Int [Int] Heap
10:14:01 <ski>   type Heap = Int -> Int
10:14:16 <Reemo> What is that MkS?
10:14:19 <ski> you have to define at least one new type, to make an instance of `Show'
10:14:29 <ski> `MkS' would be the data constructor of `State'
10:14:55 <ski> so you'd write then `MkS 0 [0] emptyHeap', instead of `(0,[0],emptyHeap)'
10:15:20 <ski> if you prefer, you can make it so that you write `MkS (0,[0],emptyHeap)' instead .. it doesn't matter
10:16:19 <inetic> hi, I've created a wrapper monad over the Data.Binary.Put monad(?), what it does is it knows how many bytes it's going to write, I think it's pretty much simmilar to the StateT. The problem is that while saving a file (~ 70MB) it consumes all my RAM (~4GB) and crashes. I've tried the ghc memory profiler, it points to the bind operator but I have no clue why, are there maybe some tutorials you could recommend that would point me to right direction?
10:16:33 <ski> (and `type ..' doesn't define a *new* type .. only `newtype' and `data' does)
10:16:50 <Reemo> ahh okay
10:17:17 <ski> (`type' only gives a new *name* to an existing type .. it defines a *synonym*, a shorthand)
10:18:01 <Reemo> ski, is it valid to just write
10:18:11 <Reemo> data State = State (Int, [Int], Heap)
10:18:15 <ski> sure
10:18:38 <ski> (i would rename the second `State' to `MkState' or something else .. but it would work as that, yes)
10:19:19 <byorgey> inetic: probably due to too much laziness in computing the length (just a guess).  Take a look at the strict state monad in Control.Monad.State.Strict.
10:19:48 <ski> Reemo : then you'd need to define `shows' or `showsPrec' inside the `Show' instance
10:20:15 <ski> (or `show' i suppose .. but i tend not to do that, for compound data)
10:23:29 <gwern> quuuux: yay! I was right!
10:23:34 * gwern is always pleased about that
10:24:21 <quuuux> gwern: I think I just won over my friend to Haskell by demonstrating a debracifier in 3 lines of code (one import, one blank, too)
10:24:30 <gwern> quuuux: a what?
10:24:43 <quuuux> er. Re-bracifier, and a de-layoutifier
10:24:54 <quuuux> I haven't slept in far too long, give me a break :(
10:25:21 <inetic> byorgey, sorry, got distracted by colleague, and thanks, will check it out
10:25:21 <dafis> quuuux:  how long is the remaining line?
10:25:25 <RichardBarrell> quuuux: interact (show . fooToBar . read) -- ?
10:25:39 <byorgey> inetic: those pesky colleagues ;)
10:25:47 <quuuux> dafis: 126 characters
10:25:48 <RichardBarrell> And "import Data.Bar.FromFoo"
10:25:49 <inetic> byorgey, :-)
10:26:00 <edwardk> adding instances for Eq, Ord etc. to Yoneda. debating about the best Ord instance. the compare is easy. YonedaT f == YonedaT g = compare (f id) (g id)
10:26:19 <edwardk> but I can optimize max/min if I force the assumption that f is a Functor
10:26:36 <edwardk> max (YonedaT f) (YonedaT g) = liftYonedaT $ f id `max` g id
10:26:55 <edwardk> which will only evaluate the function once and then remember the result
10:27:09 <edwardk> but i don't think i can get away with it, because of the stupid Functor is not a superclass of Monad nonsense
10:27:18 <RichardBarrell> edwardk: supply separate maxFunctorYoneda and minFunctorYoneda functions?
10:27:32 <edwardk> RichardBarrell: probably for the best
10:27:41 <RichardBarrell> Oh, you already require Monad?
10:27:46 <edwardk> no
10:27:51 <byorgey> inetic: you may be interested in reading http://haskell.org/haskellwiki/Space_leak and http://haskell.org/haskellwiki/Performance/Strictness
10:27:59 <edwardk> instance (Ord (f a)) => Ord (YonedaT f a)
10:28:13 <ski>   YonedaT m f a = forall b. (a -> m b) -> m (f b)  -- or what ??
10:28:34 <edwardk> ski: nah, newtype YonedaT f a = YonedaT { runYonedaT :: forall b. (a -> b) -> f b }
10:28:40 <edwardk> its what iw as previously calling Yoneda
10:28:45 <ski> oh, the old usual `Yoneda'
10:28:55 <ski> i thought it was some variation of it
10:29:07 <edwardk> but this way type Yoneda = YonedaT Identity gives a better equivalence to the structure of the other Control.Monad.Trans instances
10:29:11 <RichardBarrell> edwardk: is f required to be a Monad elsewhere?
10:29:33 <edwardk> richardbarrell: for the Monad instance, but the Applicative/Functor instances require Applicative and nothing respectively
10:29:41 <edwardk> so i can't just liftM
10:29:50 <edwardk> i inject using liftM or fmap as appropriate
10:30:43 <RichardBarrell> If you've already asking for (Monad f) => ... or (Applicative f) => ... then I can't see how asking for (Monad f, Functor f) => ... or (Applicative f, Functor f) => ... is going to be onerous.
10:30:56 <RichardBarrell> Unless I totally misread your original question.
10:31:08 <edwardk> RichardBarrell: i can't force both, because i can rely on neither ;)
10:31:12 <copumpkin> Applicative f, Functor f will collapse
10:31:36 <RichardBarrell> I misread your original question, then.
10:31:51 <Reemo> ski, works :)
10:31:55 <edwardk> meh. i'll just add maxM and maxF variants
10:32:53 <ski> edwardk : i would possibly rename 'runYonedaT' to `pamfProj' or something like that (the idea being that `pamfProj yfa ab = fmap ab (proj yfa)' where `proj :: YonedaT f a -> f a')
10:33:12 <edwardk> ski: thats a rather awful nae =)
10:33:16 <uberfry> hi, can someone help me with this please? http://hpaste.org/43281/getlasttwo
10:33:32 <edwardk> i went with runYonedaT for symmetry to the other transformers
10:34:11 * hackagebot contstuff 1.2.3 - Fast, easy to use CPS-based monad transformers  http://hackage.haskell.org/package/contstuff-1.2.3 (ErtugrulSoeylemez)
10:34:12 <ski> yeah :/ .. i would like to be able to say `newtype YonedaT f a = YonedaT { forall b. fmapProj (a -> b) :: f b }' or something like that, so we'd at least get `fmapProj ab yfa' ..
10:34:39 <ski> (why should the "record" always be the first argument of the selector ?)
10:34:47 <edwardk> i try to avoid using random abbreviations in names, so that kind of runs afoul of all of my conventions =)
10:34:51 <Eduard_Munteanu> Is Yoneda any use, besides doing CT stuff with it?
10:35:05 <ski> Reemo : .. i wonder whether your `Show' generates valid Haskell code :)
10:35:06 <edwardk> Eduard_Munteanu: think of it as type-level enforced fmap-fusion
10:35:24 <Eduard_Munteanu> I see.
10:35:44 <edwardk> Eduard_Munteanu: when working with YonedaT, fmaps get 'accumulated' in the function argument.
10:36:01 <edwardk> CodensityT similarly accumulates binds on a monad, and right associates the result.
10:36:37 <mm_freak_> edwardk: release includes refactored StateT, but i didn't notice any change in performance…  currently i'm trying to simplify the interface a bit by getting rid of the 'r' type variable where possible
10:36:40 <Eduard_Munteanu> So basically Yoneda is a special representation of Functors, right?
10:37:08 <edwardk> eduard: notice that Yoneda f is a functor, even if f is not ;)
10:37:20 <ski> `Yoneda f' is a functor, regardless of whether `f' is or not
10:37:28 <Eduard_Munteanu> Hm, interesting.
10:37:42 <ski> also, `CoYoneda f' is also a functor
10:38:04 <edwardk> yeah but there to extract it you need a functor, so thats less commonly useful (though makes for a cheaper comonad)
10:38:11 <mm_freak_> edwardk: do you think there is a way to get CPS effects without 'r'?
10:38:37 <edwardk> mm_freak_: have you universally quantified it?
10:39:07 <ski> afaict, one can think of `CoYoneda f' as the upper closure of `f'
10:39:10 <edwardk> mm_freak_: if you quantify it you can close over the entire future of computation, but you can't callCC
10:39:19 <edwardk> mm_freak_: thats usually enough for me
10:39:29 <uberfry> hi, can someone help me with this please? http://hpaste.org/43281/getlasttwo
10:39:32 <ski> (as in upper sets, i.e.)
10:39:33 <Reemo> ski, it does as i'm reusing show for native types ;)
10:39:52 <ski> Reemo : and how do you manage to show `Int -> Int' (i.e. `Heap') ?
10:39:55 <mm_freak_> edwardk: do you think it's possible without losing callCC?
10:40:06 <Reemo>     show (State (m, d, h)) = show (m, d, [(i, (h i)) | i <- [0..(heapLength 0 h)]])
10:40:07 <Reemo> where heapLength i h = if((h i) == 0) then i else (heapLength (i+1) h)
10:40:16 <edwardk> mm_freak: no
10:40:24 <ski> mm_freak_ : you need the `r' for effects
10:41:13 <ski> (well, you might be able to hide stuff in a `Dynamic' or `Object' something like that too, i guess)
10:41:24 <inetic> byorgey, those seem like very good links, thanks again Brent :-)
10:41:46 <mm_freak_> hmm, let me try a few things
10:43:23 <edwardk> doh. max (YonedaT f) (YonedaT g) = YonedaT $ \k -> f k `max` g k — duh
10:43:31 <edwardk> no lifting required
10:45:09 <ski> Reemo : i'd say
10:45:13 <ski>   showsPrec p (State (m, d, h)) = showParen (p > 0) $ showString "State (" . showsPrec 11 m . showString ", " . showsPrec 11 d . showString ", heapFromList " . shows [(i, h i) | i <- [0 .. heapLength 0 h]] . showString ")"
10:45:24 <ski> (well, indented more pretty, of course)
10:45:51 <ski> (with the same definition of `heapLength' .. maybe removing the redundant brackets)
10:49:19 <uberfry> hi, can someone help me with this please? http://hpaste.org/43281/getlasttwo
10:49:23 <uberfry> it's urgent :/
10:49:44 <ski> edwardk : huh .. how does that work, considering that `k :: a -> b', where `b' is a skolem (/rigid type variable) ?
10:50:40 <edwardk> ski the $ doesn't work if thats what you mean =)
10:50:42 <ski> (oh.. another `getLastTwo' ..)
10:51:30 <ski> hmm
10:51:36 <edwardk> ski: mentally replace it with (...)'s
10:51:55 <ski> edwardk : do you have a `forall a. Ord (f a)' which you can use for the `max', there ?
10:52:17 <edwardk> max is comparing the target values
10:52:24 <mzero> uberfry: you need to think about what colon means      x : y   matches  "a list  that starts with an element x, and the remainder of the list (possibly empty) is y "
10:52:25 <edwardk> hrmm
10:52:29 <edwardk> ick
10:52:32 <edwardk> you're right
10:52:32 <mzero> notice that y is NOT an element
10:52:39 <ski> i'm wondering how you can make a `forall b. (a -> b) -> f b', when `max' is passed two `f b's, even though you know nothing about `b'
10:52:39 <edwardk> good catch
10:52:50 <edwardk> shucks
10:52:55 <ski> if you had `forall b. Ord (f b)' i suppose it could work
10:53:00 <edwardk> ugly
10:53:03 <mzero> uberfry: so, then   x : y : z   is parsed as  x : (y : z)   (due to right associativity of colon)   ---- so
10:53:06 <edwardk> just going to leave it off
10:53:20 <ski> (but you can't write such a constraint directly .. you have to kludge it, afaik)
10:53:29 <mzero> x : y : z    matches a list that starts with element x, and a second element y, then the remainder fo the list is z
10:54:37 <edwardk> i could just add a maxF and maxM and provide rewrite rules =)
10:54:38 <mzero> uberfry: .... but now consider this       x : []      -- this matches a list that starts with element x, and the remainder fo the list must match the empty list     --- so this matches a single element list
10:54:49 <mzero> finally..... think about what     x : y : []      would match
10:54:53 <ski>   YonedaT f `max` YonedaT g = YonedaT (\k -> f (\a -> g (\b -> ...)))  -- hm, this doesn't seem to work, either
10:54:55 <mzero> hope that helps
10:55:38 <ski> edwardk : `class OrdF f where maxF :: f a -> f a -> f a' ?
10:55:55 <uberfry> ok thanks I'll evaluate your comments, brb :)
10:55:58 <edwardk> ski: nah, there'd be too few instances to be useful
10:56:12 <edwardk> only really ones with phantom arguments
10:56:29 <ski> then what would the type of `maxF' (and `maxM') be ?
10:56:43 * mzero wonders if ghci can evaluate his comments....
10:56:50 <mzero> :-)
10:57:11 <ski> that `OrdF' was the only thing i could think of, apart from changing to `YonedaT' to include the `Ord' constraint (which is a no-no, of course)
10:57:38 <ski> > ()  -- lambdabot, can you evaluate this ?
10:57:39 <lambdabot>   ()
11:02:48 <uberfry> mzero: think about what     x : y : []      would match <- 2 last elements
11:03:09 <uberfry> getLastTwo (x:y:[]) = x:y
11:03:11 <mzero> close: that matches a list of exactly two elements
11:03:12 <uberfry> that's invalid though, right?
11:03:21 <ski> the pattern is good
11:03:22 <monochrom> not 2 last element
11:03:25 <ski> the expression 'x:y' is not
11:03:28 <uberfry> yea I get what you mean
11:03:29 <mzero> right, because the left hand side is wronger
11:03:30 <mzero> nonon
11:03:35 <mzero> the RIGHT hand side is wrong
11:03:44 <uberfry> getLastTwo (x:y:[]) = (x:y)
11:03:44 <uberfry> ?
11:03:46 <mzero> the LEFT hand side does indeed match a list of exactly two elements
11:03:52 * ski stares curiously at mzero
11:04:00 <uberfry> ah wait
11:04:02 <uberfry> I got it ;)
11:04:02 <uberfry> sec
11:04:23 <monochrom> there is no pattern-matching way to get two last elements.
11:04:29 <mzero> true
11:04:46 <ski> there is, if the list is known to have length two :P
11:04:49 <mzero> folks - that is just his first equation - he has a second one ... :-)
11:04:50 <monochrom> x:y:[] matches [a,b] and nothing else.
11:05:24 <mreh> for all a and b
11:05:26 <ski> uberfry : if `x' is an element and `y' is an element, then `x:y' is nonsense
11:05:44 <djahandarie> :t (:)
11:05:46 <lambdabot> forall a. a -> [a] -> [a]
11:05:47 <mzero> "uberfry: ah wait... I got it ;)"
11:05:48 <mreh> do they understand the types
11:06:01 <uberfry> ski: (x:y) though?
11:06:03 <uberfry> getLastTwo :: [Int] -> [Int] -> [Int]
11:06:03 <uberfry> getLastTwo (x:[]) = [x]
11:06:03 <uberfry> getLastTwo (x:y:[]) = y : getLastTwo x y
11:06:06 <ski> uberfry : `:' wants `x' to be an element and 'y' to be a list of such elements .. but if `x' and `y' are both elements ("on the same level" so to speak), then `x:y' is wrong
11:06:29 <uberfry> ahhh ic
11:06:32 <uberfry> it means append then
11:06:37 <uberfry> appent to list
11:06:39 <monochrom> Dijkstra and my supervisor are right that if you choose a symmetric symbol like "+" and ":", people start expecting symmetry out of them.
11:06:42 <ski> uberfry : `(x:y)' is the same as `x:y', only bracketted more .. as is `((((((((x))):((y)))))))'
11:06:58 <uberfry> ah lol
11:07:09 <ski> monochrom : yay !
11:07:11 <mzero> remember what I said about colon and pattern matching?  same is true on the right hand side about using colon to build a list     x : y    is the list with the first element x and the remainder of the list being the LIST y (which could be empty)
11:07:21 <mreh> + is not symmetric?
11:07:30 <monochrom> + is symmetric
11:07:36 <ski> > a + b == b + a
11:07:38 <lambdabot>   False
11:07:51 <djahandarie> uberfry, if we assume your function will never be passed a list smaller than two, then getLastTwo (x:y:[]) = ... is your base case. You need another line that shrinks bigger lists down to that base case.
11:07:51 <mreh> @check a + b == b + a
11:07:52 <lambdabot>   "Falsifiable, after 0 tests:\n"
11:08:04 <ski> @check \a b -> a + b == b + a
11:08:05 <lambdabot>   "OK, passed 500 tests."
11:08:12 <mzero> I common pitfall I see in newcomers to Haskell is that we use : to match/build lists that is very different than the operators (usually , ) used in other languages
11:08:13 <mreh> that's better
11:08:17 <djahandarie> uberfry, (a base case being something that doesn't recurse)
11:08:34 <shachaf> mzero: Different how?
11:08:35 <ski> @check \a b c -> (a + b) + c == a + (b + (c :: Double))
11:08:36 <lambdabot>   "Falsifiable, after 9 tests:\n-0.3333333333333333\n3.0\n2.0\n"
11:08:56 <shachaf> mzero: It's pretty much the same as in LISP, except for being infix.
11:08:58 <uberfry> http://hpaste.org/43282/getlasttwo_annotation
11:08:59 <uberfry> this?
11:09:18 <mzero> in most langauges, the way you build an array or list or sequence with brackets and comma -- which Haskell has too, but we tend to use and teach the colon form (for many good reasons)
11:09:32 <mzero> yes, if folks are coming from List, then : is probably fine
11:09:46 <monochrom> Perl wants you to write (1,2,3) and then you think it is translated to haskell as 1:2:3
11:09:59 <uberfry> hold on brb
11:10:00 <mzero> but coming from Python / PHP / JavaScript ---- : is going to be very different than how you build a simple structure in those langauges
11:10:24 <mzero> monochrom: exactly!   
11:10:28 <djahandarie> uberfry, your type signature is entirely wrong
11:10:36 <djahandarie> uberfry, you are working with one list, not two
11:11:00 <uberfry> ah
11:11:01 <uberfry> signature
11:11:05 <uberfry> how does it work?
11:11:16 <uberfry> the sheets dont say anything about it
11:11:19 <uberfry> just examples
11:11:20 <djahandarie> getLastTwo :: [Int] -> [Int] is what it should be
11:11:25 <uberfry> ok thanks sec
11:11:28 <djahandarie> You take one list and you end up with a list
11:11:55 <djahandarie> But given this knowledge, think about how you should be /calling/ the function on lines 3 and 4
11:12:44 <mreh> are there plans for a #haskell-cafe?
11:13:01 <djahandarie> mreh, what would #haskell before? Official announcments? ;P
11:13:05 <djahandarie> be for*
11:13:09 <uberfry> so it doesn't matter what side it's on, it's always element:list ?
11:13:13 <mreh> oh, we have haskell-in-depth
11:13:45 <monochrom> yes
11:14:01 <mreh> it's a bit snobbish to require another channel
11:14:16 <uberfry> good lord, they don't explain a single thing in the sheets
11:14:27 <monochrom> what sheets?
11:14:43 <uberfry> lecture
11:14:53 <mreh> what institution?
11:14:59 <djahandarie> uberfry, learn from a superior tutorial then :)
11:15:03 <djahandarie> uberfry, http://learnyouahaskell.com
11:15:08 <uberfry> heh, thanks ;D
11:15:29 <uberfry> it's great, you know
11:15:34 <uberfry> 3 languages in 3 weeks
11:15:43 <djahandarie> Sounds stupid to me
11:15:45 <uberfry> to teach us functional programming
11:15:48 <uberfry> to me aswell
11:16:06 <uberfry> prolog or something
11:16:27 <djahandarie> You can spend 3 months on a language and not get very far if it's difficult enough :)
11:16:36 <uberfry> yep
11:16:38 <uberfry> lol
11:16:48 <uberfry> this uni is the closest to me
11:16:59 <uberfry> but it's one of those high-nosed
11:17:04 <djahandarie> Well you're lucky that they're touching on / introducing Haskell at least
11:17:05 <mreh> haskell is for life, not for christmas
11:17:11 <djahandarie> Haha
11:17:18 <uberfry> I don't mind haskell
11:17:21 <uberfry> I mind their attitude
11:17:38 <monochrom> you prefer a secondary-school kind of education?
11:17:54 <uberfry> I wouldn't mind that :)
11:17:55 <uberfry> j/k
11:18:05 <uberfry> I like not having to visit lectures
11:18:08 <mreh> gah, my Shell monad isn't extensible...
11:18:26 <mreh> maybe I should make it a transformer with a MonadIO restriction
11:20:35 <mreh> I'm going to end up with 4 monads stacked up on top of each other
11:20:58 <mreh> seems a little expensive wrapping and unwrapping
11:33:11 <Jesin> umm
11:33:48 <Jesin> 'The Either type is sometimes used to represent a value which is either correct or an error; by convention, the Left constructor is used to hold an error value and the Right constructor is used to hold a correct value (mnemonic: "right" also means "correct"). '
11:34:00 <Jesin> so, why doesn't Either have fail = Left?
11:34:24 <Jesin> alternately, what is the point of fail taking a string?
11:38:33 <copumpkin> Jesin: fail is fail
11:38:36 <copumpkin> Jesin: as in, it sucks
11:39:29 <Heffalump> it takes a string so the compiler can inject pattern match failure messages
11:39:54 <Heffalump> and Either used to use Left for the fail instance, but then the Monad instance is constrained to things you can get strings out of, so it was changed 
11:40:49 <Jesin> ah.
11:41:23 <Jesin> "fail" never really gets used, then?
11:42:17 <copumpkin> it does
11:42:26 <copumpkin> whenever you do something like Just x <- action
11:42:37 <copumpkin> if action returned an m of Nothing
11:43:00 <boegel> is there a list available somewhere of functions that people think should be in the Prelude?
11:43:25 <boegel> e.g. sum' = foldl' (+) 0 , or other simple functions that are used often?
11:43:55 <copumpkin> selections :: [a] -> [(a, [a])] or selections :: [a] -> [([a], a, [a])]
11:44:57 <krey_> hello, I'm implementing an almost programming language that only allows tail recursion. What's the best way of internally representing its recursive functions? should I store a recursive call as a reference or should I add a fixpoint constructor that uses references internally?
11:46:09 <krey_> ie. a function has to have a reference to it (say a number) for the fixpoint combinator to work, so I might as well get rid of it
11:46:18 <gwern> krey_: maybe I'm missing something but shouldn't you be doing TCO in that case?
11:46:37 <krey_> gwern: what is TCO?
11:46:51 <gwern> the famous scheme requirement, tail-call optimization, transforming them into iterative loops
11:47:55 <krey_> gwern: can't I leave that to the haskell compiler?
11:48:07 <gwern> krey_: I have no idea. I thought you were implementing a language
11:48:12 <gwern> shouldn't you know that?
11:48:37 <tac-tics> That only allows tail recursion? What does that even mean?
11:48:48 <tac-tics> You can't call in nontail positions?
11:48:58 <pastorn> krey_: do you know how the stack might grow when you call a function recursively?
11:49:30 <pastorn> krey_: sum ns = if null ns then 0 else head ns + sum tail ns
11:49:40 <krey_> gwern: sorry, I mean, it's going to be an interpreter, so I'm not sure if I could do it
11:50:16 <krey_> tac-tics: yep, only tail recursion, it's nowhere near turing complete
11:50:22 <pastorn> krey_: consider running that function on a very big list, it's going to take at least as much memory as the list is long to calculate it (each addition is stored on the stack until the base case (null ns) is reached)
11:51:16 <krey_> pastorn: I know what tail call optimisation is, I just don't think I need it. could I even do it in haskell? (this is an interpreter not a compliler)
11:51:19 <krey_> ?
11:51:39 <pastorn> krey_: well, what are you trying to optimize? arbitrary code or haskell?
11:51:59 <pastorn> do you have a syntax tree, or do you want to make your haskell go faster?
11:52:44 <jmcarthur> tail call optimization is possible in haskell, but for most code is just less meaningfull
11:52:47 <jmcarthur> *meaningful
11:52:54 <peoro> @src *
11:52:54 <lambdabot> Source not found.
11:53:09 <krey_> pastorn: yeah, here's the problem, I don't know how to do the syntax tree! should I have refernces to other functions?
11:53:20 <monochrom> "I'm implementing an almost programming language that only allows tail recursion." is pretty clear, methinks
11:53:27 <pastorn> krey_: sum ns = sum' 0 ns; sum' soFar ns = if null ns then soFar else sum' (soFar + head ns) (tail ns)
11:53:35 <peoro> hum, * operator is defined in Prelude, or is it "built in" ?
11:53:46 <copumpkin> it's in Prelude
11:53:57 <monochrom> use a pointer or reference in the internal representation.
11:54:07 <krey_> pastorn: because the semantics of the language doesn't do references
11:54:13 <peoro> ok, thanks
11:55:03 <krey_> my question could be rephrased as this: should I have both a syntax tree and a semantics tree?
11:56:15 <RichardBarrell> krey_: if you're doing any interesting analysis or transformations, yes, you should have an intermediate representation that's nicer than your syntax tree.
11:56:38 <pastorn> peoro: it's in the Num class, but the actual inner workings you can look up in 'GHC.Prim', but don't go there, it's messy ;)
11:57:10 <peoro> eheh, ok pastorn, thanks
11:57:11 <RichardBarrell> krey_: you can write compilers that pretty much just serialise their syntax trees right to machine code, though. They don't produce good microcode but they run really fast, especially if they're deforested so that the syntax tree never even actually gets built. :)
11:57:43 <RichardBarrell> krey_: i.e. the state machine that you use for parsing emits object code directly. :)
11:58:16 <peoro> would it be possible to discard the Prelude module, so that I can define functions with the same names?
11:58:21 <jmcarthur> the ocaml compiler works that way to some extent, and it even manages good code generation
11:58:39 <jmcarthur> it does very few optimizations, at least, and it's very fast
11:58:48 <jeltsch> Hi, the -P option of lhs2TeX is used to set the search path. It uses : as the path separator under Linux and ; under Windows. Can I use -P in a portable way?
11:59:11 <jeltsch> Or somehow check within a Makefile what OS I’m running on?
11:59:25 <krey_> RichardBarrell: i'm just a bit confused, because the semantics of my language contain a fixpoint combinator, but I don't really 'need' it, I could just follow the references to the next 'function'
11:59:40 <monochrom> just follow references
12:00:16 <krey_> monochrom, everyone else who helped me: thanks :)
12:01:16 <monochrom> the interpreter being a loop itself is already the fixed point combinator you seek.
12:01:34 <aavogt> quicksilver: exactly. Thanks
12:01:50 <RichardBarrell> peoro: yes, you can. There's a "no implicit Prelude option."
12:02:34 <RichardBarrell> peoro: either run ghc with the flag -XNoImplicitPrelude, or put {-# LANGUAGE NoImplicitPrelude #-} at the top of your .hs file.
12:02:47 <RichardBarrell> peoro: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
12:03:16 <peoro> ok RichardBarrell, thanks... I was just curious, don't actually need it
12:03:25 <peoro> I'll bookmark your link, anyway :)
12:06:40 <RichardBarrell> The GHC manual is full of treasures and delights. Just don't go overboard with it lest your code become wildly unportable.
12:10:09 <copumpkin> I love to make my code wildly unportable
12:12:57 <RichardBarrell> If you're doing it like that, copumpkin, then the word you should be using is 'wilfully'. :P
12:17:39 <mdwright_laptop> So, I'm currently taking a compilers class, and was considering attempting the compiler in Haskell. I haven't used Haskell all that long (~4 weeks), but do have experience in plenty of other languages, though this is my first purely functional. Is it worth attempting the compiler in Haskell, or would I be better off spending my time working in a language I'm more familiar with?
12:18:18 <RichardBarrell> Work in something that you're familiar with. I would recommend working in whatever language the examples on your handouts are written in. Easiest to get help from the TAs that way.
12:19:01 <monochrom> uphill battle if you learn a language and use it non-toy at the same time.
12:19:32 <monochrom> note that "it's easy to pick up another language, just different syntax" does not apply
12:20:38 <mdwright_laptop> monochrom: hah. Yeah, I'm aware of that... Ah well. I was hoping to have some time to pick it up before I really needed to start on the project.
12:21:07 <stepcut> haskell is a fine language for writing compilers
12:22:30 <alpounet> mdwright_laptop, well, you better have a lot of free time before the project starts if you want to write it in Haskell
12:22:53 <alpounet> it would be fine for a 2D pong game, a little tool or any such project
12:23:30 <mdwright_laptop> alpounet: Heh. Class has started. I've been going through Real World Haskell for the past few weeks. I feel pretty solid in what I have learned, but there's just so much to Haskell, and some of it I need some time to really wrap my head around.
12:25:11 <alpounet> mdwright_laptop, this is true for everything, but in particular with Haskell: you need to *practice* to grasp the things
12:26:12 <mdwright_laptop> alpounet: Yeap. I've been doing all the exercises in RWH, and some of the 99-problems/Project Euler. I was kind of hoping to use *this* as my project to really learn it, but at the same time, I'm not sure I want to bet my grade on being able to pick up enough by a certain deadline.
12:26:29 <alpounet> yeah
12:26:57 <alpounet> if you have some time left, you should try to write some actual projects
12:27:02 <alpounet> tools, games, whatever
12:27:29 <alpounet> if you don't, well, you really should do your project in a language you're more used to and have more practiced with
12:27:37 <decaf> I would like to write a boggle solver
12:28:15 <decaf> but I have absolutely no idea for now, how can I build a tree for words and keep somewhere to access 
12:28:39 <decaf> you can't *keep* anything anywhere in haskell
12:28:57 <Twey> Pass it around
12:28:58 <decaf> could you point me a document about this
12:29:11 <Twey> I think a radix tree is appropriate?
12:29:29 <Twey> http://en.wikipedia.org/wiki/Radix_tree
12:29:34 <eipi> set theme pyhy
12:29:46 <decaf> sure, simple prefix tree (trie) is enough
12:30:07 <decaf> I can build one, in imperative style
12:30:55 <Twey> http://hackage.haskell.org/package/bytestring-trie — this, maybe?
12:34:00 <decaf> great. get words from command line, put in this trie, get probabilities from boggle matrix, search in *this" trie
12:34:23 <decaf> where to keep trie itself? :)
12:34:41 <decaf> I'll read more and come back
12:50:39 <pastorn> is there some list where i can see what cabal packages that depend on some specified packagel?
12:50:53 <pastorn> or will i have to do massive wget/greping for this?
12:51:09 <dcoutts> pastorn: not an up to date list, but the new hackage snapshot has reverse dependencies
12:51:31 <pastorn> dcoutts: huh? reverse dependencies? linky?
12:54:08 <dcoutts> pastorn: example http://sparky.haskell.org:8080/package/zlib-0.5.2.0/reverse
12:54:40 <pastorn> dcoutts: that's really cool, thanks :D
12:56:20 <pumpkin> dcoutts: have I asked before (or has someone else) about some notion of conditional pairwise modules in cabal? package x provides module z when package y is present too, and if x and y are both present, you can rely on the existence of the module (i.e. cabal will go back and compile that module if you install them in the other order)
12:57:04 <dcoutts> pumpkin: problem is, that kind of thing cannot be translated into distro/other package systems
12:57:09 <dcoutts> so it's of limited utility
12:57:10 <pumpkin> ah, okay
12:59:50 <telephone> I have some questions about naming of two types of constructs. Do they have any names? hpaste: http://hpaste.org/43285/naming_of_constructions
13:01:16 <Peaker> telephone, do you mean "corecursive"?
13:01:34 <Peaker> oh they aren't corecursive
13:01:52 <pumpkin> mutual recursion?
13:02:02 <pumpkin> and composition
13:02:12 <pumpkin> not even mutual recursion
13:02:19 <Peaker> yeah, it's just normal calls
13:02:27 <telephone> Peaker, pumpkin: I don't know if they have names, I was just wondering
13:02:29 <pumpkin> the first one is composition
13:02:39 <pumpkin> the second one is just f' = h :P
13:05:08 <telephone> pumpkin: the functions are just simple to show the idea. I was wondering if there was some "name characterization" of the two types of constructs.
13:05:36 <pumpkin> the second one isn't anything I can name, other than "identity"
13:05:42 <pumpkin> the first is definitely composition
13:07:34 <telephone> Consider the functions f and f'. In f, the result comes from the function f itself. In f', it just passes the computation to another function.
13:07:59 <telephone> That is the two types of constructs I was wondering if have names.
13:18:37 <parcs> hmm
13:19:40 <parcs> for some reason binary can't read encoded Ints
13:20:20 <parcs> can anyone confirm this?
13:21:13 <parcs> encode 42 == Chunk "\NUL\NUL\NUL\NUL*" Empty
13:21:40 <parcs> wait nevermind i found my error
13:21:53 <parcs> sorry for the channel spam
13:25:01 <peoro> how can I define some functions that will be valid for a whole instance? Like what I'm trying to do here: http://pastebin.com/9G2zgYg5
13:28:22 <RichardBarrell> peoro: You want them to be attached to all three of those cases as a "where" clause, but I don't think you can attach a "where" clause to more than one arm of a pattern match. Put showLeft and showRight at top level?
13:29:21 <peoro> RichardBarrell: hum, that's sad, but will work, ok, thanks
13:29:46 <RichardBarrell> I'd very much like it if someone would tell me that I'm wrong, though.
13:31:40 <azaq23> You could also do show node = case node of .... where showLeft ...
13:32:01 <azaq23> ie put the pattern match into show for that case so you can use where
13:32:21 <Heffalump> anyone know anything about the next European hackathon?
13:33:37 <peoro> azaq23 that's right, it will work fine for my case, thanks
13:41:23 <peoro> hum... how can I check if a variable is a non-Eq value? one way is pattern matching, is it possible to do it in an `if` expression?
13:42:29 <monochrom> not sure what is "non-Eq value". if pattern matching floats your boat, use pattern matching, use a "case" expression.
13:43:07 <c_wraith> I still wish if wasn't syntax.
13:43:35 <c_wraith> being just another function would help emphasize that if is nothing special.
13:43:47 <monochrom> moving to scheme or liskell fulfills your wish because almost nothing is syntax there.
13:43:52 <Kaidelong> I think what I'm looking for is basically "pointed things with a function that makes them copointed"
13:44:31 <peoro> I know that if is nothing special, just some times I prefer its syntax to `case': it doesn't require to break line (or to use semicolons)
13:44:58 <Kaidelong> IE: class (Pointed p) => ... p ... toCopointed :: (Copointed q) => a -> p a -> q a
13:45:21 <Kaidelong> where q is determined by p
13:45:31 <monochrom> you buy that convenience of if-then-else by limiting it to two cases.
13:45:42 <mm_freak_> peoro:
13:45:47 <monochrom> or rather two branches.
13:45:51 <Kaidelong> anyone know how I could implement that (or if I don't have to)?
13:45:56 <mm_freak_> > case 3 of 3 -> "yes"; 4 -> "no"
13:45:57 <lambdabot>   "yes"
13:46:07 <mm_freak_> what's wrong with this?
13:46:49 <Kaidelong> fromMaybe would be a function that would be like "toCopointed"
13:47:02 * ddarius makes the even more convenient, toΣ :: () -> a -> a
13:47:25 <ddarius> or I gues from
13:47:28 <peoro> mm_freak_: I just find it more redeable an `if .. then .. else', but it could be just because I'm still new to Haskell syntax and because my editor highlights `if', `then', `else', but doesn't highlight semicolons
13:47:30 <monochrom> if you argue that you could restore unlimited branching by nesting if-then-else inside if-then-else, it's pretty clear "case {;;;;;}" is shorter than "else if else if else if else if else if"
13:47:30 <ddarius> Σ 
13:48:04 * ddarius rarely uses case or if.
13:48:51 <copumpkin> Kaidelong: I don't get it
13:49:32 <Kaidelong> copumpkin: the idea is, that for something which would be copointed if it's "b a -> a" was total, you have a function that will make a copointed that does have a total "b a -> a"
13:50:10 <Kaidelong> for example something that turns a list into an infinite stream by defaulting if you have an empty list
13:50:23 <peoro> anyway this is what I got: http://pastebin.com/xdAzHqCa (old "tests" are commentd out), not sure whether I could do that with a better syntax, but well, can say to be satisfied
13:51:37 <copumpkin> Kaidelong: I see
13:52:15 * Kaidelong thinks he'd need either multi-parameter typeclasses for this, or functional depencies
13:53:53 * ddarius needs to make his supersampled median filter program again.
13:54:01 * ddarius left a lot of interesting code in Texas.
13:55:19 <shachaf> ddarius: How does that happen?
13:57:20 <Kaidelong> @ty return
13:57:21 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:57:34 * Kaidelong wonders why Monad as opposed to Pointed...
13:57:48 <djahandarie> Is Pointed a superclass of Functor or a subclass
13:57:54 <djahandarie> @ty pure
13:57:55 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
13:58:02 <djahandarie> @ty point -- in category-extras
13:58:03 <lambdabot> Not in scope: `point'
13:58:04 <Kaidelong> djahandarie: why would Functor imply Pointed?
13:58:08 <Kaidelong> applicative would, though
13:58:23 <djahandarie> Imagine a class with fmap and point
13:58:40 <dibblego> it's a subclass in category-extras
13:58:44 <djahandarie> Right.
13:59:01 <dibblego> perhaps there should be subclass
13:59:05 <dibblego> *perhaps there should be no subclass
13:59:13 <Kaidelong> Functor and Pointed would actually imply Applicative
13:59:22 <dibblego> you'd need (<*>)
13:59:39 <dibblego> fmap+point cannot give you (<*>)
13:59:39 <Kaidelong> since you can make a function y -> (y -> a) -> a 
14:00:05 <dibblego> (<*>)+point can give you fmap
14:00:15 <Kaidelong> > fmap ($5) [(^2),(^3)]
14:00:16 <lambdabot>   [25,125]
14:00:32 <Kaidelong> @ty ($5)
14:00:33 <lambdabot> forall a b. (Num a) => (a -> b) -> b
14:00:42 <Kaidelong> @ty flip ($)
14:00:43 <lambdabot> forall a b. a -> (a -> b) -> b
14:00:56 <jmcarthur> what does this show?
14:01:10 <Kaidelong> @ty (<*>)
14:01:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:01:21 <Kaidelong> oh
14:01:24 <Kaidelong> you'd need Monad
14:01:34 <Kaidelong> so that's not helpful
14:01:36 <jmcarthur> huh?
14:01:45 <jmcarthur> monad alone is enough, sure
14:02:06 <jmcarthur> Functor can be defined in terms of Applicative and Applicative can be defined in terms of Monad
14:03:07 <Kaidelong> okay so you don't get Applicative from Pointed and Functor, I'm wrong
14:03:38 <dibblego> Functor from Pointed and Apply[cative]
14:04:34 <Kaidelong>  (but the reverse holds, for obvious reasons)
14:05:39 <Kaidelong> with Copointed and Functor you can get <*>, with Pointed you get pure...
14:05:59 <magicman> Now I wonder if there's a sensible instance of Pointed that's not an instance of Functor.
14:06:31 <dibblego> ContraPointed ;)
14:06:54 <monochrom> peoro: http://pastebin.com/xpLiT1QF
14:06:56 <Kaidelong> magicman: I do not think there would be:
14:07:16 <Kaidelong> (a -> b) -> (a -> p a) -> (a -> p b)
14:07:34 <Kaidelong> well
14:07:45 <Kaidelong> that wouldn't make it a functor, admittedly
14:08:04 <magicman> That's just the Pointed/Functor law, isn't it?
14:08:09 <Kaidelong> but the existance of that means that there is a functor like isomorphism for any pointed
14:08:20 <Kaidelong> to a pointed containing a different type
14:08:31 <Kaidelong> you'd just have to actually implement it
14:09:17 <Kaidelong> if there are multiple ways to implement it, I suppose there might be several functors for one pointed, but never no functors
14:10:21 <gwern> @pl sum a Biggles c d = getSum $ accumulate a b c d
14:10:22 <lambdabot> sum = const . ((getSum .) .) . flip accumulate b
14:10:39 <gwern> (biggles? where the hell did that come from?)
14:10:45 <Biggles> hi
14:10:46 <codolio> Copointed + Functor will not give you a correct Applicative.
14:11:12 <codolio> In general.
14:11:18 <gwern> @pl sum a b c d = getSum $ accumulate a b c d
14:11:18 <lambdabot> sum = (((getSum .) .) .) . accumulate
14:11:26 <Kaidelong> codolio: it wouldn't give you <*> ?
14:11:43 <codolio> It will give you something with the right type, but the wrong behavior.
14:11:50 <djahandarie> Kaidelong, it would give you something that satisfies the type but not the laws I think
14:11:55 <djahandarie> Oops, too late
14:11:58 <Kaidelong> ah
14:12:42 <dolio> Because f <*> x = extract f <$> x just throws away the context of f.
14:13:03 <iago> hi all, I'm reading a 12M XML file as an strict bytestring, then I parse it with with xml (Text.XML.Light) and I do some query over the XML... the query takes 70% of my memory, which is 4G! Any idea?
14:13:17 <gwern> iago: profiling
14:13:18 <Kaidelong> dolio: I was thinking more "fmap . flip ($) . extract"
14:14:04 <gwern> hah. I've written 2 fancy functions with monoids, and I know they're correct, but I don't know how to actually use them! http://hpaste.org/43287/sicp_monoids
14:14:05 <Kaidelong> actually wouldn't that thing be "flip fmap . extract" and have the wrong type?
14:14:15 <Kaidelong> err no
14:14:19 <Kaidelong> it'd have the right type
14:14:57 <dolio> @type let extract :: Functor f => f a -> a ; extract = undefined in fmap . flip ($) . extract
14:14:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => f1 a -> f (a -> b) -> f b
14:15:39 <dolio> In that case we're throwing away the context on x, which is also wrong.
14:16:06 <Kaidelong> I think I understand
14:16:14 <Kaidelong> c a is more meaningful than a
14:16:31 <dolio> pure id <*> x = x is expected.
14:17:13 <Kaidelong> in that case the type is actually wrong
14:17:22 <dolio> Well, whatever.
14:17:22 <Kaidelong> since you change the context
14:17:59 <Kaidelong> so yes, definitely, Applicative is not that trivial...
14:18:17 <dolio> And f <*> pure x = fmap ($x) f
14:18:29 <dolio> Or swap the arguments to those two laws if you want to.
14:20:51 <iago>     Could not find module `Text.XML.Light':
14:20:51 <iago>       Perhaps you haven't installed the profiling libraries for package `xml-1.3.7'?
14:20:55 <iago> when compiling for profiling
14:21:12 <iago> someone could point me something ?
14:21:17 <monochrom> Perhaps you haven't installed the profiling libraries for package xml-1.3.7
14:21:34 <iago> yeah, I know what it is saying
14:21:42 <iago> but I don't know about that libraries
14:21:42 * Kaidelong wonders if there is a class with "(f a -> f b) -> f (a -> b)" and "(f a -> a)" 
14:23:18 <iago> should that package be compiled with some special option to support profiling?
14:23:26 <monochrom> yes
14:24:07 <djahandarie> iago, usually the problem is that when you install libraries with cabal it doesn't install the profiling version along with it
14:24:18 <djahandarie> It really should be enabled by default but it isn't
14:24:21 <iago> djahandarie, this is the problem
14:24:49 <gwern> djahandarie: the problem is that people don't want to pay for the space
14:24:51 <djahandarie> Open your .cabal/config and uncomment the library-profiling line
14:25:02 <djahandarie> gwern, then tell those people to turn it off
14:25:09 <gwern> so distros don't ship with profiling of base libs by default, and cabal-install's bootstrap deosn't do it either
14:25:14 <conal> Kaidelong: i wonder the same.
14:25:16 <monochrom> uncomment and change.
14:25:22 <helmut> is there a simple way to express "foo bar = baz . qux bar" without writing out bar?
14:25:32 <djahandarie> Oh right, yeah, change it too
14:25:34 <gwern> @pl foo bar = baz . qux bar
14:25:35 <lambdabot> foo = (baz .) . qux
14:25:40 <gwern> helmut: ^
14:25:50 <conal> fmap.fmap
14:25:54 <helmut> thanks. Now I only need to understand it.
14:26:18 <conal> helmut: (fmap.fmap) baz qux
14:26:23 <conal> @where SEC -- for helmut
14:26:23 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
14:26:26 <helmut> every time I touch a haskell project it is like learning the language a new time.
14:26:26 <djahandarie> helmut, no we have to confuse you with more semi-related stuff before you understand the first thing
14:26:29 * Kaidelong thinks that things with a "toCopointed :: (Copointed q) => a -> p a -> q a" may actually be a example of something like that
14:26:34 <gwern> oh, I'm an idiot, I used mempty where I meant mappend
14:26:37 <gwern> so my code is teh broke
14:26:44 <gwern> no wonder the type sigs looked odd
14:27:09 <Kaidelong> where q would be a determined by a class parameter
14:27:30 * helmut is trying to implement a decision tree in haskell for understanding both decision trees and haskell.
14:27:38 <iago> djahandarie, thanks a lot, an install --reinstall did the job
14:27:53 <djahandarie> :)
14:28:18 <conal> helmut: also called "result . result", baz is applied to the result of the result of qux. there are many other such examples, including first, second etc.
14:31:40 <balodja> how structures like "newtype S r a = S (r -> (a, S r a))" are called? that's like "streams" or "infinite lists", but with some additional structure
14:33:00 <Eduard_Munteanu> It looks a bit like State.
14:33:24 <Eduard_Munteanu> @src State
14:33:25 <lambdabot> Source not found. My brain just exploded
14:34:54 <c_wraith> Eh.  That structure isn't infinite, by itself.
14:35:07 <c_wraith> It needs to be paired with an infinite source of r values to be infinite
14:35:43 <byorgey> but you can also see it as an infinite r-ary tree
14:35:49 <byorgey> and you get to explore one branch of it
14:36:05 <byorgey> you choose one of the branches at each step by passing in an r.
14:36:30 <c_wraith> hmm, yes
14:36:43 <c_wraith> That is a tree
14:37:04 <byorgey> by that logic, infinite lists aren't infinite either, they need to be paired with an infinite source of thunk-forcing ;)
14:37:22 <djahandarie> I think that's different :P
14:37:33 <c_wraith> Well.  My point was more...  An infinite list contains all the information you need to explore it.
14:37:39 <c_wraith> That structure does not
14:37:40 <balodja> byorgey, that's the point of how i use it. in my case "a" is signal and "r" is timestep. and overall structure describe some signal evolution
14:37:47 <copumpkin> it's cofree
14:37:54 <copumpkin> oh wait
14:37:57 <djahandarie> Coffee?
14:37:57 <copumpkin> not cofree
14:38:00 <edwardk> coffee
14:38:02 <copumpkin> it's just a mealy 
14:38:05 <mikeg> @hoogle a b c -> a (b, b) (c, c)
14:38:06 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:38:06 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
14:38:06 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
14:38:15 <Eduard_Munteanu> I like coffree.
14:38:16 <djahandarie> Nu Mu Milk?
14:38:24 <mikeg> Mhmm is there a function for \f -> first f . second f ?
14:38:32 <edwardk> djahandarie much better than old mu milk.
14:38:45 <copumpkin> mikeg: ***
14:38:51 <byorgey> mikeg: well, there's join (***)
14:38:52 <copumpkin> join (***)
14:38:52 <copumpkin> :P
14:38:58 <byorgey> although it's not quite as polymorphic as one might like
14:39:01 <c_wraith> wait...
14:39:05 <mikeg> thanks :)
14:39:09 <c_wraith> :t uncurry (.)
14:39:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b, f a) -> f b
14:39:15 <helmut> anyone interested in commenting on some newbe code? http://hpaste.org/43288/decisiontreelhs
14:39:18 <c_wraith> :t uncurry (Prelude..)
14:39:19 <lambdabot> forall b c a. (b -> c, a -> b) -> a -> c
14:39:20 <Eduard_Munteanu> Well does 'join' work for anything else than Kleisli arrows?
14:39:35 <balodja> copumpkin, cofree differs in how next value is obtained
14:39:37 <byorgey> :t join (***)
14:39:38 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:39:46 <copumpkin> balodja: yeah, I corrected myself to just mealy :P
14:39:53 <Eduard_Munteanu> @src join
14:39:53 <lambdabot> join x =  x >>= id
14:40:21 <Eduard_Munteanu> :/
14:40:23 <copumpkin> join is operating on (->) r there
14:40:25 <byorgey> Eduard_Munteanu: join (***) uses the ((->) r) monad in an incidental way
14:40:31 <Eduard_Munteanu> Ah.
14:41:02 <djahandarie> The word "coffee" actually looks a lot weirder than the word "cofree" to me
14:41:06 <rokoteko> how does Haskell handle floating point errors, are they in a Monad?
14:41:08 <djahandarie> Guess that says something about me...
14:41:19 <Cale> rokoteko: Special floating point values
14:41:22 <Cale> > 0/0
14:41:23 <lambdabot>   NaN
14:41:30 <Cale> > isNaN (0/0)
14:41:31 <lambdabot>   True
14:41:34 <djahandarie> @ty 0/0
14:41:35 <lambdabot> forall t. (Fractional t) => t
14:41:35 <Cale> > isNaN (1/0)
14:41:37 <lambdabot>   False
14:41:43 <djahandarie> @type isNaN
14:41:43 <Cale> > isInfinite (1/0)
14:41:44 <lambdabot> forall a. (RealFloat a) => a -> Bool
14:41:45 <lambdabot>   True
14:41:49 <Cale> > (1/0)
14:41:50 <lambdabot>   Infinity
14:41:50 <uberfry> can someone verify this please? http://hpaste.org/43290/getlasttwo_annotation
14:41:52 <Cale> > (-1/0)
14:41:53 <lambdabot>   -Infinity
14:42:04 <handonson> How do I get (unsafely) the Ptr Word8 of a ByteString?
14:42:07 <c_wraith> > (-1/0) < 0
14:42:08 <lambdabot>   True
14:42:11 <edwardk> sadly there are no DualAdjunctions between Contravariant Functors on Hask =(
14:42:15 <copumpkin> uberfry: sure, but why x:[y] instead of [x,y] ?
14:42:22 <uberfry> hmm sec
14:42:28 <uberfry> oh
14:42:28 <byorgey> helmut: looks nice in general.  Is there anything in particular you wanted comments on?
14:42:29 <c_wraith> handonson: pattern-match on the constructor.  It's exposed by the .Internal modules
14:42:31 <edwardk> (without unsafePerformIO)
14:42:32 <Eduard_Munteanu> Incidentally, NaNs work just like the Maybe monad.
14:42:33 <uberfry> I started with [x]++[y]
14:42:37 <uberfry> but then hpaste told me not to
14:42:44 <Eduard_Munteanu> Even outside of Haskell.
14:42:46 <copumpkin> Eduard_Munteanu: except Nothing == Nothing
14:42:48 <helmut> byorgey: style, efficiency
14:42:48 <rokoteko> > ((0 + i)/0) == 0
14:42:50 <lambdabot>   False
14:42:55 <Cale> uberfry: You didn't handle the case of a list with one element
14:43:01 <uberfry> oh right
14:43:02 <uberfry> sec
14:43:04 <Eduard_Munteanu> Yeah.
14:43:22 <Cale> uberfry: also, test the function on [1,2,3] and see if you get what you really wanted
14:43:41 <djahandarie> Cale, no problem, just require a minimum length Vector :)
14:43:48 <handonson> c_wraith: but aren't .Internal modules hidden?
14:43:54 <uberfry> Cale: not getting
14:43:54 <helmut> byorgey: I was also thinking about a better definition for Instance
14:43:57 <Cale> djahandarie: what?
14:43:58 <c_wraith> handonson: not in bytestring
14:44:09 <byorgey> helmut: the style is very nice
14:44:19 * djahandarie wonders if that's possible to do cleanly in Haskell without mutating the hell out of Vec
14:44:29 <copumpkin> ?
14:44:47 <c_wraith> handonson: the bytestring package just uses the .Internal modules to say "These give you access to things that will let you screw everything up.  Be careful with them."
14:44:50 <byorgey> helmut: like what?
14:44:59 <djahandarie> A function that accepts Vectors longer than 3 for example
14:45:07 <copumpkin> djahandarie: that's easy with Vec
14:45:15 <djahandarie> Does the type look nice?
14:45:23 <helmut> byorgey: I was thinking about Int -> AttributeValue, but I need some enumeratability
14:45:27 <copumpkin> forall n. Vec (S (S (S n))) -> ...
14:45:35 <djahandarie> Oh duh
14:45:36 <djahandarie> lol
14:45:43 * djahandarie sighs
14:45:50 <copumpkin> vectors shorter than a constant is harder
14:45:53 <iago> hi all, I'm reading a 12M XML file as an strict bytestring, then I parse it with with xml (Text.XML.Light) and I do some query over the XML... the query takes 70% of my memory, which is 4G! Profiler points that parseXMLDoc is the problem. Any idea? Maybe some library known to be more efficient? (3G reading 12M file seems too bad)
14:45:54 <copumpkin> but it's just like a Fin, really
14:45:56 <uberfry> http://hpaste.org/43291/getlasttwo_annotation
14:45:57 <copumpkin> an annotated Fin
14:45:57 <helmut> byorgey: even better would be to map arbitrary things, not Int. the enumeratability prevented me though
14:46:13 <byorgey> helmut: how about Data.Map?
14:46:25 <djahandarie> copumpkin, yeah I was thinking of the more general case
14:46:54 <uberfry> copumpkin: basically I need to extract the last 2 elements in a list
14:46:55 <uberfry> http://hpaste.org/43291/getlasttwo_annotation
14:47:09 <helmut> byorgey: sounds like what I want. let me try. :-)
14:47:21 <copumpkin> lastN :: Nat n -> Vec (n :+ m) -> Vec n
14:47:30 <byorgey> uberfry: getLastTwo [1,2,3] = getLastTwo (1:2:3:[]) = ... ?
14:47:43 <c_wraith> helmut: your recursive case in the last line is wrong.
14:47:46 <Eduard_Munteanu> iago: use a lazy parser
14:47:53 <Eduard_Munteanu> That uses lazy bytestrings
14:48:03 <byorgey> c_wraith: did you mean uberfry?
14:48:07 <handonson> darn it, the .Internal doc link is broken in http://hackage.haskell.org/package/bytestring
14:48:08 <uberfry> byorgey: it's the same, right?
14:48:15 <c_wraith> err, yes, I did.  sorry
14:48:18 <uberfry> lol
14:48:22 <uberfry> what's wrong about it?
14:48:23 <byorgey> uberfry: yes, and what does it evaluate to, given your definition?
14:48:24 <helmut> c_wraith: you mean it aborts after the first level?
14:48:28 <uberfry> hold on
14:48:35 <c_wraith> helmut: sorry, wasn't meaning to talk to you
14:48:35 <djahandarie> copumpkin, yeah that is pretty damn neat. There wouldn't be any weird injectivity problems or whatever with that?
14:48:43 <uberfry> well it would expect a list of minimum 4
14:48:44 <helmut> c_wraith: k
14:48:57 <uberfry> cause it trunks 3
14:49:08 <copumpkin> djahandarie: yeah, definitely
14:49:14 <uberfry> but I have no idea of how to append as a parameter...
14:49:26 <copumpkin> djahandarie: however, with iavor's work on type-level nats in GHC, it'd be fine
14:49:48 <djahandarie> The efficient ones?
14:49:57 <Eduard_Munteanu> A language feature?
14:50:03 <byorgey> uberfry: if you evaluate getLastTwo (1:2:3:[]), which pattern would it match?
14:50:06 <copumpkin> not just efficient, but the type-level naturals let the typechecker reason about them
14:50:14 <iago> Eduard_Munteanu, the use of lazy bytestring seems to do not have any significant effect
14:50:23 <uberfry> byorgey: the last one
14:50:25 <copumpkin> it can typecheck f :: Vec (n + m) -> Vec (m + n); f = id
14:50:29 <byorgey> uberfry: right, and then what would the right-hand side of that case be?
14:50:31 <copumpkin> and other similar things
14:50:33 <uberfry> getLastTwo (x:y:xs) =	getLastTwo xs
14:50:35 <uberfry> well
14:50:36 <iago> I need to read almost all the XML file
14:50:40 <djahandarie> copumpkin, damn
14:50:45 <uberfry> it would become: getLastTwo []
14:50:50 <byorgey> uberfry: not quite
14:50:51 <djahandarie> copumpkin, that would allow us to write the nice reverse with the foldr right?
14:50:51 <uberfry> sorry no
14:50:54 <uberfry> wrong
14:51:04 <copumpkin> djahandarie: unfortunately the actual branch of GHC with that in it isn't public as far as I know
14:51:06 <uberfry> getLastTwo [3]
14:51:08 <copumpkin> but it's working
14:51:13 <byorgey> uberfry: right.  Now does that seem correct to you?
14:51:20 <Eduard_Munteanu> iago: something like HXT builds up a tree of the whole XML in memory before doing any work. Perhaps you should use something else, like Tagsoup.
14:51:21 <uberfry> no
14:51:22 <uberfry> it doesn't
14:51:23 <uberfry> but
14:51:26 <copumpkin> djahandarie: foldl?
14:51:29 <uberfry> how do I send a param as : ?
14:51:40 <uberfry> cause obv : getLastTwo (x:y:xs) =	getLastTwo y:xs
14:51:41 <uberfry> doesn't work
14:51:43 <byorgey> uberfry: oh, I see what you were asking
14:51:47 <byorgey> uberfry: surround it with parentheses
14:51:50 <Eduard_Munteanu> iago: what lib are you using?
14:51:51 <byorgey> getLastTwo (y:xs)
14:51:51 <djahandarie> Err yeah foldl :P
14:51:52 <uberfry> ah sec
14:52:01 <byorgey> uberfry: otherwise it is parsed as  (getLastTwo y) : xs
14:52:02 <djahandarie> foldl (flip (:)) (VNil)
14:52:08 <djahandarie> foldl (flip (VCons)) (VNil)
14:52:13 <uberfry> MUCHAS GRACIAS!!!!!!!!!!
14:52:15 <byorgey> uberfry: because function application has higher precedence than any operators
14:52:17 <uberfry> thanks so muc :)
14:52:19 <uberfry> *much
14:52:22 <uberfry> finally, 10 hours later
14:52:23 <iago> Eduard_Munteanu, xml (Text.XML.Light)
14:52:23 <byorgey> uberfry: you're welcome, glad to help =)
14:52:28 <djahandarie> copumpkin, because the problem before was with the nats before right?
14:52:59 <djahandarie> -before
14:53:13 <copumpkin> djahandarie: hmm, I thought I was able to write foldl reverse on vecs before
14:53:31 <copumpkin> reverseV = unVecFlip . foldlV ((VecFlip .) . flip Cons . unVecFlip) (VecFlip Nil)
14:53:32 <copumpkin> :P
14:53:32 <djahandarie> Right but I recall it wasn't the obvious way
14:53:38 <Eduard_Munteanu> iago: Tagsoup basically gives you a list of tags, is that enough for you?
14:53:38 <djahandarie> Yeah lol
14:53:40 <copumpkin> it's some wrapping in newtypes
14:53:44 <copumpkin> but it's the same basic shape
14:54:46 <copumpkin> foldlV :: (forall n. p n -> a -> p (S n)) -> p Z -> Vec m a -> p m
14:55:51 <Saizan> VecFlip wouldn't be solved by nice type-level naturals
14:55:55 <iago> Eduard_Munteanu, depending, what it does when a tag is a child of other tag?
14:55:56 <copumpkin> yeah
14:56:05 <cts> :t forall
14:56:05 <lambdabot> Not in scope: `forall'
14:56:25 <Twey> forall is a keyword
14:56:32 <alpounet> cts, http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#The_forall_keyword
14:57:08 <Saizan> it'd be solved by type application, SPJ said the problem for it is having a syntax that works without making the order and/or names of type variables in the type signature matter
14:57:10 <cts> Hui!
14:57:24 <cts> Thank you, Twey&alpounet!
14:57:44 <helmut> byorgey: turns out converting to Data.Map wasn't that hard.
14:57:56 <byorgey> helmut: ok, good
14:57:56 <djahandarie> How would explicit type application look?
14:58:16 <helmut> byorgey: I only had to change a few selected places. I'm a bit puzzled about how few.
14:58:21 <byorgey> hehe
14:58:42 <byorgey> Haskell: Refactoring Made Easy (tm)
14:59:07 <djahandarie> "After you figure out what this type error is telling you" is the small print
14:59:09 <helmut> now if I can write some tokenization engine, I can write my own decision tree based spam filter!
14:59:24 <byorgey> \o/
15:00:05 <helmut> (did you ever try to find an existion decision tree based spam filter? at least debian doesn't ship one while shipping a shitload of naive bayes)
15:00:13 <Saizan> djahandarie: i guess you'd also need type lambdas (or to define a type family) so you could write "foldlV (\n -> Vec n a) (flip Cons) Nil", where the first argument is supposed to be used for "p"
15:00:15 <helmut> *existing
15:02:02 <Eduard_Munteanu> iago: I think they simply appear between the other tags, see here... http://hackage.haskell.org/packages/archive/tagsoup/0.12/doc/html/Text-HTML-TagSoup.html#v:parseTags
15:02:08 <Eduard_Munteanu> parseTags "<hello>my&amp;</world>" == [TagOpen "hello" [],TagText "my&",TagClose "world"]
15:03:46 <helmut> byorgey: thanks for your hints. one day I will grok this language. :-)
15:05:52 <iago> Eduard_Munteanu, let me see... 
15:06:26 <byorgey> helmut: you're welcome! The road to grokking Haskell is long but with lots of interesting detours, vistas, and roadside vegetable stands run by wild-eyed hermits
15:07:10 <helmut> hehe
15:07:16 <RichardBarrell> In the end you give up and write Perl inst
15:07:20 * RichardBarrell self destructs
15:07:56 <helmut> indeed I am still way faster at writing python than haskell, but haskell has some distinct and very attractive beauty.
15:08:32 <uberfry> this is correct so far, right?
15:08:32 <uberfry> schachtel :: [Int] -> [[Int]]
15:08:33 <uberfry> schachtel	(x:xs)	=	[x, schachtel xs]
15:09:01 <helmut> uberfry: I don't think that it even type checks
15:09:13 <uberfry> I want like: [1,2,3] -> [[1],[2],[3]]
15:09:19 <uberfry> helmut: it doesn't
15:09:20 <RichardBarrell> uberfry: No. The right hand side is a list [] containing an Int x.
15:09:24 <uberfry> that's why I asked if it was correct
15:09:30 <uberfry> hmm
15:09:37 <RichardBarrell> uberfry: map (:[])
15:09:37 <helmut> uberfry: map schachtel = map return
15:09:45 <hpc> argh ninja
15:09:48 <RichardBarrell> Also known as the "monkey combinator". :)
15:09:49 <pumpkin> preflex: seen soupdragon
15:09:49 <preflex>  soupdragon was last seen on #scheme 155 days, 11 hours, 41 minutes and 19 seconds ago, saying: I know how to use syntax-rules :)))
15:09:54 <pumpkin> preflex: seen vixey
15:09:55 <preflex>  vixey was last seen on ##C 232 days, 10 hours, 57 minutes and 13 seconds ago, saying: emphasis on 'might' :)
15:09:58 <djahandarie> preflex, seen fax
15:09:58 <preflex>  fax was last seen on #haskell-blah 261 days, 1 hour, 41 minutes and 19 seconds ago, saying: that's the problem you are thinking to smalll
15:10:04 <djahandarie> Strange
15:10:08 <pumpkin> preflex: seen cheshire
15:10:09 <preflex>  cheshire was last seen on #haskell-in-depth 1 year, 325 days, 23 hours, 21 minutes and 3 seconds ago, saying: the monad stuff is beyond what I can grok just by looking at
15:10:33 <uberfry> sec I'll look up map
15:10:34 <RichardBarrell> pumpkin: doing that in-channel is a little distracting.
15:10:35 <djahandarie> I've seen soupdragon around on other channels I think though
15:10:48 <pumpkin> RichardBarrell: sorry
15:10:49 <hpc> who was that guy last seen 2 years ago saying "/me rtfms"
15:10:55 <pumpkin> hpc: mmorrow
15:11:22 <helmut> is there a list of #haskell sub channels (-blah -in-depth) and their descriptios?
15:11:35 <RichardBarrell> uberfry: if you want to write it recursively, in primitives: schachtel [] = []; schachtel (x:xs) = [x]:schachtel xs;
15:11:46 <hpc> helmut: don't think so
15:11:59 <djahandarie> helmut, those are really the only two I think
15:12:00 <uberfry> thanks RichardBarrell I'll try that
15:12:01 <hpc> blah and in-depth are the two busiest though, and in-depth is inactive most days
15:12:09 <hpc> and others are ad-hoc
15:12:12 <djahandarie> helmut, there are also various .tld ones
15:12:12 <helmut> hpc: I was wondering whether there was some #haskell-newbes :-)
15:12:19 <hpc> oh, also -overflow
15:12:24 <djahandarie> And -ops
15:12:38 <hpc> though those two don't matter much
15:12:40 <jmcarthur> it's not clear from the documentation. is STM's Alternative instance retry and orElse?
15:12:48 <uberfry> ok thank you very much RichardBarrell :)
15:12:53 <djahandarie> Yeah they are meta-channels
15:13:03 <jmcarthur> i can't find it in source, either
15:13:12 <uberfry> RichardBarrell: really, thanks a lot, now I see that element can also be a list
15:13:13 <hpc> jmcarthur: check the source and search "instance Alterna..."?
15:13:15 <uberfry> well
15:13:15 <iago> Eduard_Munteanu, well, I have seen. But I'm generating XML for easier parsing... if I have to do extra effort then maybe I will avoid the use XML instead
15:13:16 <hpc> ah
15:13:24 <uberfry> x<xs
15:13:26 <RichardBarrell> uberfry: lists can contain elements.
15:13:27 <uberfry> when x:xs
15:13:35 <iago> I don't understand how read into memory 12M could need 3G
15:13:52 <uberfry> yes, so a list containing lists means the elements are lists
15:13:53 <jmcarthur> hpc: the instance is not in GHC.Conc (where STM is defined) and i can't seem to find the instance in the stm package
15:14:04 <RichardBarrell> Er, that wasn't what I meant to say, my brain doesn't work.
15:14:05 <uberfry> that's what I didn't get at first :)
15:14:54 <RichardBarrell> uberfry: yes. Anywhere you see an unbound variable in a type, such as the a in [a], you can put absolutely whatever type you please, including nested types.
15:16:00 <jmcarthur> hpc: well, i doesn't matter now. i found the MonadPlus instance, and it seems to be what i predicted. it's highly unlikely that the Alternative instance would have different semantics
15:16:16 <hpc> jmcarthur: Control.Sequential perhaps
15:16:40 * hpc read the import list for the STM package modules
15:17:19 <hpc> uberfry: but not infinite types; if you end up writing a function that needs [[[[[[[...[[[[a]]]]...]]]]]]
15:17:21 <hpc> that's an error
15:17:47 <pumpkin> it also means you probably just wanted a tree
15:18:12 <hpc> or Mu, if you are that particular variety of crazy
15:19:12 <dibblego> @hoogle (Monad m, Monad n) => m (n a) -> (a -> m (n b)) -> m (n b)
15:19:12 <lambdabot> No results found
15:20:06 <helmut> I'd like to process data that will unlikely fit into main memory (well it could, but haskell tends to bloat data), so I was thinking about reading it on demand (possibly multiple times). Any idea how I would achieve this?
15:21:03 <hpc> :t liftM (>>=)
15:21:04 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 ((a -> m b) -> m b)
15:21:33 <lpsmith> Is it at all possible to add a top-level exception handler around an existing IO thread?
15:21:57 <dibblego> :t liftM2 (>>=)
15:21:58 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (a -> m b) -> m1 (m b)
15:22:14 <hpc> helmut: if it's from a file, you can lazily read the file into [], then process
15:22:21 <uberfry> hpc: let's take things slow, I started coding today :)
15:22:26 <uberfry> appendEnd	x y:ys	=	y : appendEnd x ys
15:22:30 <hpc> uberfry: ;)
15:22:37 <helmut> hpc: it's a list of files and the complete list is unlikly to fit.
15:23:24 <erg0t> if you would make a drink and call it "the haskeller" what should it has?
15:23:26 <helmut> hpc: the problem is that I will be processing this list multiple times.
15:23:27 <hpc> helmut: it will evaluate a block of file at a time; as long as your processing doesn't need all the contents, it works
15:23:30 <hpc> oh
15:23:39 <hpc> rewrite the processing or re-open the files
15:23:54 <jmcarthur> does anybody have a nice format string for Alternative's (<|>) operator in lhs2TeX?
15:23:55 <uberfry> appendEnd  x y:ys	=  y : appendEnd x ys
15:23:56 <helmut> I guess it will all have to be monadic then?
15:23:58 <uberfry> did I miss something there?
15:24:11 <bapuche> I would like to create a list from a zipped list, along the following lines: [filter (\x -> 1==fst x) list, filter (\x -> 2==fst x) list, filter (\x -> 3== fst x) list, ...] How is this done?
15:24:15 <hpc> uberfry: parens around (y:ys)
15:24:36 <hpc> also base case, but i assume that will be correct
15:24:41 <hpc> and already written
15:24:45 <uberfry> yea
15:24:45 <uberfry> sec
15:25:12 <djahandarie> Is there something like matchListSize :: a -> b -> [a] -> [b] -> ([a], [b])  which lengthens the shorter list with the provided element until it matches the other one?
15:25:19 <uberfry> http://hpaste.org/43292/getlasttwo_annotation
15:25:28 <hpc> zipWith const
15:25:33 <hpc> perhaps
15:25:37 <hpc> oh
15:25:44 <aavogt> and some  ++ cycle [padding]
15:25:58 <hpc> yea, and what aavogt said
15:26:04 <uberfry> ok sec
15:26:20 <uberfry> wait
15:26:24 <uberfry> what do you mean by that?
15:26:42 <uberfry> btw I'm not allowed to use built in functions yet
15:27:21 <hpc> uberfry: line 7 "appendEnd' (x-1)" needs another argument
15:27:34 <uberfry> right, sorry
15:27:41 <hpc> then it will work i believe
15:27:43 <helmut> uberfry: is (:) a built in function?
15:28:01 <uberfry> well yea
15:28:03 <uberfry> but not functions
15:28:06 <uberfry> errrr
15:28:11 <helmut> what's the difference?
15:28:12 <uberfry> it's just common, I think?
15:28:15 <hpc> helmut: he can use constructors i assume :P
15:28:40 <uberfry> I'm more of a hardware dude :)
15:28:44 <uberfry> this is new territory
15:28:57 <hpc> uberfry: welcome; it's dangerous to go alone, take this sword
15:28:59 <hpc> :D
15:29:00 <aavogt> @ty \x y xs ys -> if ((>) `on` (map (const ()))) xs ys then xs `zip` (ys++repeat y) else (xs++repeat x) `zip` ys
15:29:02 <lambdabot> forall a. a -> a -> [a] -> [a] -> [(a, a)]
15:29:05 <azaq23> (:) is a data constructor of [], but that's just semantics, actually it's a function, so depends what one means by function
15:29:24 <jmcarthur> hmm, google code search gives me only one relevant result for %format "<|>". somebody used \sqcup for it. i guess that makes some sense
15:29:34 <uberfry> lmao hpc
15:29:36 <djahandarie> azaq23, no zipping required really
15:29:38 <aavogt> @ty \x y xs ys -> if map (const ()) xs > map (const ()) ys then xs `zip` (ys++repeat y) else (xs++repeat x) `zip` ys
15:29:39 <lambdabot> forall a a1. a -> a1 -> [a] -> [a1] -> [(a, a1)]
15:29:53 <djahandarie> Oops
15:29:56 <djahandarie> aavogt*
15:30:15 <aavogt> djahandarie: how would you do the above then?
15:30:48 <aavogt> I guess that one fails on infinite xs and ys
15:32:13 <uberfry> fuck yeah, got it working :D
15:32:24 <uberfry> I misused x
15:32:29 <uberfry> 						appendEnd' x y = x : appendEnd' x (y-1)
15:32:40 <uberfry> y was x before
15:33:24 <aavogt> @ty \x y xs ys -> [ (either id id a, either id id b) |     (a,b) <- (map Left xs ++ repeat (Right x)) `zip` (map Left ys ++ repeat (Right y)), isLeft a || isLeft b ]
15:33:25 <lambdabot> Not in scope: `isLeft'
15:33:26 <lambdabot> Not in scope: `isLeft'
15:33:42 <aavogt> @hoogle Either a b -> Bool
15:33:43 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
15:33:43 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
15:33:43 <lambdabot> Data.Graph.Inductive.Basic isSimple :: Graph gr => gr a b -> Bool
15:38:41 * hackagebot hmatrix-mmap 0.0.1 - Memory map Vector from disk into memory efficiently  http://hackage.haskell.org/package/hmatrix-mmap-0.0.1 (AlanFalloon)
15:45:35 <uberfry> guys this is FUN
15:45:53 <uberfry> someone's gotta tell me how they use it for reversing though :)
15:45:58 <uberfry> that's what I use ida pro for
15:48:35 <jmcarthur> uberfry: use what for reversing?
15:48:52 <uberfry> haskell
15:49:04 <uberfry> to evaluate stuff
15:49:08 <uberfry> I've never really had to
15:49:14 <djahandarie> aavogt, just ended up being lazy and used let f a b xs@(x:x') ys@(y:y') | null xs && null ys = [] | null xs = (a, y):f a b [] y' | null ys = (x, b):f a b x' [] | True = (x, y):f a b x' y' in f :P
15:49:14 <jmcarthur> uberfry: i think copumpking is using haskell to write some reverse engineering tools
15:49:16 <uberfry> I mean, it was usually tracing registers
15:49:24 <uberfry> yes
15:49:28 <jmcarthur> uberfry: oh, do you mean debugging haskell code?
15:49:31 <uberfry> the ones I do is in ida pro
15:49:32 <uberfry> no no
15:49:35 <pumpkin> @hackage hoopl
15:49:35 <lambdabot> http://hackage.haskell.org/package/hoopl
15:49:36 <jmcarthur> okay just checking
15:49:37 <uberfry> to create re tools ;)
15:50:02 <pumpkin> uberfry: yay
15:50:10 <jmcarthur> uberfry: i once tried analyzing a program compiled by GHC with ida pro, just to see how well it could pick it apart without much assistance. it was pretty epic fail
15:50:43 <pumpkin> yeah, IDA makes a few assumptions about how your functions look
15:50:49 <pumpkin> and calling conventions between them
15:50:53 <jmcarthur> yeah i was about to say that
15:50:58 <pumpkin> that GHC violates everywhere
15:51:08 <jmcarthur> it's the reason for the evil mangler
15:51:47 <pumpkin> uberfry: on intel architectures?
15:51:58 <jmcarthur> if ida pro supported ghc binaries would that mean it's an angelic demangler?
15:52:05 <pumpkin> :P
15:52:21 <jmcarthur> i guess angelic isn't the exact opposite of evil
15:52:33 <monochrom> good mangler
15:52:36 <jmcarthur> good demangler
15:52:43 <monochrom> oh oops
15:53:04 <lispy> A demonic mangle might be interesting
15:53:39 <shachaf> lispy: Or a monic demangle?
15:53:51 <djahandarie> monadic mangle
15:54:19 <shachaf> Is there a "monads as demons" tutorial?
15:54:33 <djahandarie> monadic manglemorphism
15:54:34 * shachaf notes that it took three tries to spell "demon" without the 'a'.
15:54:35 <dolio> Probably.
15:54:38 <monochrom> there is a "monad as monster" tutorial
15:55:19 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/16214/
15:55:22 * djahandarie notes down manglemorphism for later jokes
15:58:34 <pastorn> ok, so i have a bunch of things in a record
15:58:45 <pastorn> mub they all share the same typeclass
15:59:08 <pastorn> which in its turn has a function tick :: (Class c) => c -> c
16:00:02 <pastorn> so i want to run tick on all my things in my record which is in the class... how can this be done?
16:00:40 <Saizan> manually
16:00:47 <pastorn> Saizan: well, that's boring
16:00:50 <pastorn> how do  i cheat?
16:01:26 <Saizan> syb-with-class might be appropriate here
16:01:51 <Saizan> anyhow, lots of trouble for little gain, but it surely is more interesting :)
16:02:20 <pastorn> Saizan: i was thinking a list of refs with some forall magic sprinkled on it
16:02:58 <jmcarthur> pastorn: ugh, no, do it manually. you will thank yourself for it
16:03:06 <jmcarthur> or maybe some template haskell
16:03:07 <Saizan> refs as in lenses/labels/functional references?
16:03:21 <pastorn> Saizan: heh, i was thinking TVars
16:03:46 <pastorn> but lenses might be good here
16:04:09 <Saizan> anyhow, you could have a list of those wrapped in an existential
16:04:23 <uberfry> http://hpaste.org/43294/minsort <- it's fine but throws an exception
16:04:33 <uberfry> I evaluated it thoroughly but no result
16:04:43 <pastorn> that gives you the State-monad function modifies :: (s :~> a) -> (a -> a) -> m s (), doesn't it?
16:05:34 <pastorn> (i've only ever tried "fc-labels"
16:05:38 <pastorn> )
16:06:02 <Saizan> data ClassLens s where CL :: Class a => (s :~> a) -> ClassLens s
16:06:16 <Saizan> i've never used any of the packages :)
16:09:31 <jmcarthur> uberfry: ouch, those tabs make it impossible to read (and it's good haskell etiquette to avoid tabs, btw)
16:09:46 <jmcarthur> uberfry: since haskell is whitespace sensitive, tabs can confuse matters
16:10:49 <uberfry> ah sorry
16:12:18 <uberfry> http://hpaste.org/43296/minsort_annotation
16:12:20 <uberfry> like this?
16:15:33 <uberfry> jmcarthur: do you see anything in there that could result in non-exhaustive exception?
16:15:37 <jmcarthur> uberfry: i still just see a lot of tabs
16:15:45 <jmcarthur> lemme check
16:16:03 <uberfry> last function doesn't ;)
16:16:15 <uberfry> oops, forgot to rename the var, sorry :(
16:16:21 <jmcarthur> uberfry: your first two functions don't account for empty list case
16:16:49 <jmcarthur> that's not an exception, btw
16:16:49 <uberfry> sure they do..
16:16:56 <jmcarthur> oh i guess at runtime it is
16:17:07 <uberfry> oh right, kleinstes
16:17:08 <uberfry> sec
16:17:11 <jmcarthur> no they don't. they have cases for lists with one element and lists that are longer, but not empty lists
16:17:22 <jmcarthur> oh just the first
16:17:23 <jmcarthur> my bad
16:17:33 <jmcarthur> second one looks okay on the lhs
16:20:30 <uberfry> ok working fine
16:20:31 <uberfry> thanks :)
16:20:48 <uberfry> now for the final one ;D
16:20:48 * Kaidelong is planning to write something for fault-tolerant distributed computing in Haskell, and is wondering if there is an efficient solution to this problem: For three spherical objects in n dimensions, how do you find the three radii that maximize the amount of space taken up by the spherical objects without any of them overlapping each other?
16:21:01 <Kaidelong> that might have cut
16:21:16 <moosefish> Is there a good tutorial or example for a DIY DSL? I'm trying to work my own (mostly for learning purposes) but I think I need an example before I can make much more progress.
16:22:27 <moosefish> Specifically, for w\e reason I can't quite wrap my head around the 'hidden state' that some monads have.
16:23:13 <shachaf> moosefish: "hidden state" is an odd phrasing.
16:23:20 <Kaidelong> moosefish: you can think of the "m" in "m a" as a parameter
16:23:28 <Kaidelong> so it is not really that hidden
16:23:33 <shachaf> moosefish: I suggest you reimplement the state monad in order to figure out how it works. :-)
16:23:47 <Kaidelong> and then there is an analogy between m (m a) -> m a for monads and m -> m -> m for monoids
16:24:04 * hackagebot setops 0.1.1 - Uniform names (and Unicode operators) for set operations on data structures.  http://hackage.haskell.org/package/setops-0.1.1 (eelis)
16:24:16 <moosefish> shachaf: I think I need to start with just reading some simple code first -- though I guess the state monad should have been my first try :P
16:24:32 <uberfry> thank you guys so much for all the help
16:24:37 <uberfry> you can't imagine how much I appreciate it :)
16:24:57 <jmcarthur> uberfry: i can :) been there
16:24:59 <shachaf> moosefish: Are you looking for a general monad tutorial? Unfortunately nobody's had the idea of writing one yet.
16:25:02 <Kaidelong> basically when you join a monad of a monad you are merging their states
16:25:11 <Kaidelong> in a sense
16:25:18 <jmcarthur> shachaf: lol
16:25:19 <moosefish> shachaf: Well, that's why I asked. They're like standards, it's so nice to have that many options.
16:25:30 <Kaidelong> "context" might be a better word
16:25:34 <shachaf> @wiki Monads as computation
16:25:35 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
16:26:10 <moosefish> It's like the old joke about OSS programmers. You know you've made it once you've implemented any 2 of the following: a small window manager, an irc client and a text editor.
16:26:18 <jmcarthur> moosefish: the most important thing you can get from monads right now is that you don't need to get anything from monads right now
16:26:27 <moosefish> These days you're a Haskell fan once you've written at least one monad tutorial.
16:26:37 <jmcarthur> that's so two or three years ago
16:26:49 * shachaf hasn't written any monad tutorials. Success!
16:27:03 <monochrom> it is helpful to write for your own sake. it is not helpful to show it to other people
16:27:09 * Kaidelong thinks that pedagogically it may be a good idea just to talk about "IO" and then monads once people are used to "IO"
16:27:12 <Kaidelong> and some other monads
16:27:21 <shachaf> moosefish: I suggest figuring out how you'd do a stateful computation *without* the state monad. Then later you can see how the abstraction fits over it, but that's less important.
16:27:38 <shachaf> Kaidelong: The way _Programming in Haskell_ introduces monads is very good.
16:27:47 <jmcarthur> i don't think the Monad type class should get any special treatment until *many* instances of Monad have been used already
16:28:02 <shachaf> jmcarthur: Yep.
16:28:07 <jmcarthur> where the monad interface has been used, that is
16:28:21 <shachaf> In fact, you shouldn't even hear the word "Monad" until you've written at least one GHC extension.
16:28:42 <Kaidelong> it might also be helpful to have an infix fmap from left to right, and an infix ($) from left to right
16:28:46 <jmcarthur> most monad tutorials cover a few examples, but they only gloss over them. it's not the same as learning and using them for a long and then finally learning that they all have this awesome thing in common
16:29:00 <jmcarthur> Kaidelong: ?
16:29:11 <Kaidelong> jmcarthur: to match (>>=)
16:29:14 <jmcarthur> =<<
16:29:19 <jmcarthur> <=<
16:29:25 <Kaidelong> not as natural a way to think
16:29:25 <jmcarthur> is that what you mean?
16:29:32 <jmcarthur> no? i find it far more natural
16:29:39 <jmcarthur> i still don't know what you mean though
16:29:48 <jmcarthur> $ *is* infix
16:29:51 <jmcarthur> and left-to-right...
16:29:59 <shachaf> ($) `is` infix
16:30:01 <Kaidelong> jmcarthur: Mix the eggs with the butter and flower. Crack the eggs.
16:30:06 <Kaidelong> flour*
16:30:22 <jmcarthur> crack . mix [butter, flower]
16:30:24 <jmcarthur> :)
16:30:34 <jmcarthur> *flour
16:30:43 <jmcarthur> you messed me up
16:31:24 <Kaidelong> jmcarthur: You have to say what you want to do first after you say what you want to do second...
16:31:24 <shachaf> You people and your asterisks.
16:31:47 <shachaf> Kaidelong: f (g x) --> (f . g) x
16:31:57 <Kaidelong> shachaf: yes exactly
16:32:03 <shachaf> Kaidelong: It's the same order as application. Should that be reversed too?
16:32:12 <Kaidelong> shachaf: not in implementation
16:32:18 <Kaidelong> I meant for (>>=)
16:32:20 <jmcarthur> Kaidelong: i don't see anything wrong with function application as it exists already
16:32:24 <Kaidelong> you could have operators like in fpipe
16:32:29 * shachaf suggests Kaidelong use an RPN language.
16:32:30 <Kaidelong> to make the analogy, pedagogically
16:32:39 <jmcarthur> Kaidelong: arguing that things should be a mirror image of what they currently are just seems pointless to me
16:32:55 <monochrom> write in Arabic
16:32:56 <jmcarthur> as long as it is consistent
16:33:02 <Kaidelong> jmcarthur: But that is a straw man. I didn't say to replace . or $
16:33:05 <jmcarthur> i'm one to prefer =<< to >>=, personally
16:33:16 <jmcarthur> Kaidelong: i didn't say you said that, either
16:33:31 <jmcarthur> Kaidelong: but you did argue that your way is easier to understand, which is what i'm refuting
16:33:55 <monochrom> x >>= (a =<< (b >>= c)) >>= z
16:34:12 * Rotaerk stabes monochrom.
16:34:21 <jmcarthur> anybody who has used function application in *any* language or who can read english is used to verbs occuring before direct objects
16:34:32 <jmcarthur> any *programming language
16:34:36 <jmcarthur> or math
16:35:07 <Rotaerk> jmcarthur, if you're talking about a chain of verbs though, in english that's typically presented as a list from left to right
16:35:16 <jmcarthur> Rotaerk: *verbs*
16:35:17 <shachaf> jmcarthur: Not RPN languages.
16:35:29 <Rotaerk> jmcarthur, yes, verbs
16:35:35 <jmcarthur> i don't see your point
16:35:59 <monochrom> "f*ck english"  <--- example
16:36:05 <MATAH> hi guys. I just got a first look at Haskell and it makes me think that Haskell may be good for some mathematics. Do you know any mathematical programs written in Haskell?
16:36:23 <dolio> What's that *? Is that like a click or something?
16:36:31 <shachaf> > 1 + 1 -- Arithmetic
16:36:32 <lambdabot>   2
16:37:10 <jmcarthur> Rotaerk: i can see what you mean if you are talking about, say, a *list* of verbs
16:37:24 <monochrom> haskell is not miraculously good at mathematics
16:37:32 <jmcarthur> Rotaerk: but when you are talking about applying them to a noun sequentially you normally use many different clauses to do it anyway
16:37:43 <jmcarthur> Rotaerk: that would be way too redundant in most practical programming
16:37:54 <Kaidelong> http://hackage.haskell.org/packages/archive/fpipe/0.0.1/doc/html/src/Control-FPipe.html
16:37:54 <monochrom> s/ at / for /
16:38:46 <jmcarthur> Rotaerk: interestingly, we also treat lists of verbs as left to right in haskell (mapM, for example)
16:39:06 <Rotaerk> jmcarthur, in haskell, composition is right to left though
16:39:11 <jmcarthur> yes
16:39:16 <Kaidelong> jmcarthur: Don Syme's book uses the analogy to shell programming heavily in helping make the transition from imperative programming with state to composing transformations of values
16:39:23 <jmcarthur> Rotaerk: i don't even know of verb composition in english, so that doesn't seem relevant
16:39:46 <Kaidelong> I think it is a good way to show off the paradigm
16:39:58 <Rotaerk> jmcarthur, "pour all, mix, roll, bake"
16:40:05 <gwern> if anyone would like some light reading, I'd like some feedback on whether I said anything stupid about monoids in my recent SICP work: http://www.gwern.net/sicp/Chapter%201.3.html#monoids
16:40:07 <jmcarthur> Rotaerk: that is not well-formed english
16:40:15 <shachaf> jmcarthur: "I'm going to cook and then eat it"
16:40:15 <jmcarthur> Rotaerk: that is a list of verbs, if it is
16:40:31 <jmcarthur> shachaf: that's not verb composition in the same sense as (.) is function composition
16:40:36 <mm_freak_> haskell has no particular composition direction…  i think most composition operators are left to right
16:40:40 <shachaf> True. That's distribution.
16:40:43 <Rotaerk> jmcarthur, "pour all ingredients, mix them, roll that, and bake that"
16:40:54 <jmcarthur> Rotaerk: you're applying each of those verbs to different nouns
16:41:02 <jmcarthur> Rotaerk: again, it's not the same thing as (.) or flip (.)
16:41:10 <gwern> 'The ingredients pour, mix, roll, and bake' <-- in the imperative, grammatical
16:41:22 <jmcarthur> gwern++
16:41:24 <Rotaerk> jmcarthur, the mix applies to the result of pouring the ingredients, the rolling applies to the result of mixing, and the baking applies to the result of rolling
16:41:37 <jmcarthur> Rotaerk: who talks like that? :P
16:41:41 <uberfry> oh god, why didn't they introduce us to haskell from the beginning :( I could've scored 100% on every single math problem
16:42:18 <Rotaerk> jmcarthur, that last one wasn't a replacement sentence, it was an explanation of the prior one
16:42:18 <jmcarthur> Rotaerk: and even that is an *expansion* of verb composition (and shows the nouns (variables))
16:42:33 <Kaidelong> interestingly
16:42:34 <jmcarthur> Rotaerk: the prior one was also an expansion. you named the intermediates
16:42:40 <Kaidelong> if you use (.) to mean fmap
16:42:46 <Kaidelong> fpipe would be sufficient
16:43:00 <Kaidelong> to use a pipelining style to work with the IO monad
16:43:11 <Rotaerk> jmcarthur, it doesn't matter if there is a word there to represent the pipe between the two verbs
16:43:14 * gwern thought my sentence was perfect example of left-right pipelining in English. why are we still arguing
16:43:21 <jmcarthur> Rotaerk: the noun is not the pipe
16:43:24 <Rotaerk> it's still a chain of transformations, and they're done first to last from left to right
16:43:25 <Kaidelong> IE
16:43:28 <jmcarthur> gwern: i agree. i don't know why this is so hard
16:43:29 <shachaf> gwern saves the day.
16:43:46 <Kaidelong> getLine .> toLower >>= putStrLn
16:43:49 <gwern> shachaf: yet again. you all are lucky I don't charge
16:43:53 <Rotaerk> gwern, that's invalid english though
16:43:57 <monochrom> people prefer to argue
16:43:58 <gwern> Rotaerk: no, it isn't
16:43:58 <jmcarthur> Rotaerk: look at gwern's sentence. it was a good example of what real verb composition would look like if english had it
16:43:59 <shachaf> gwern: ...You don't charge?
16:44:16 * shachaf quietly directs his gwern-fund savings to more useful things.
16:44:45 <Rotaerk> jmcarthur, it's still left to right from first to last
16:44:46 <gwern> shachaf: I don't turn down donations!
16:44:56 <shachaf> gwern: Too late. It's all gone.
16:44:59 <gwern> Rotaerk: it is grammatical. it's a command, so the subject, 'you', is implied.
16:45:00 <jmcarthur> Rotaerk: yes, and i bet you would also say it's unnatural
16:45:12 <dolio> English does have that. gwern's sentence is just backwards from normal.
16:45:17 <jmcarthur> Rotaerk: you even said it wasn't valid
16:45:20 <Rotaerk> jmcarthur, no; it's natural to specify the first thing to do on the left
16:45:30 <dolio> Normal would be, "Pour, mix, roll and bake the ingredients."
16:45:32 <tg_> <adam savage> i reject your reality, and substitute my own!
16:45:35 <Rotaerk> which is why composition from right to left is unnatural
16:45:47 <jmcarthur> Rotaerk: it was left to right and you called it unnatural
16:45:54 <jmcarthur> (seriously, why is this even continuing?)
16:46:00 <Rotaerk> jmcarthur, no i didn't
16:46:05 <monochrom> programming is unnatural
16:46:05 <shachaf> #haskell >>= #-blah
16:46:06 <jmcarthur> Rotaerk: *invalid
16:46:11 <Rotaerk> it is invalid
16:46:15 <Rotaerk> it doesn't fit the english grammar
16:46:17 <jmcarthur> *sigh*
16:46:21 <monochrom> http://www.vex.net/~trebla/weblog/intuitive.html
16:46:22 <Rotaerk> but it's natural to list that way
16:46:27 <jmcarthur> Rotaerk: argue with gwern about that
16:46:36 <jmcarthur> i'm done. this is pointless
16:47:11 <jmcarthur> nobody talks the way you are arguing for. i already said that a list of verbs seems pretty natural to do left to right.
16:47:20 <Kaidelong> Rotaerk: it is nicer for some things
16:47:20 <Kaidelong> hence why having both is nice
16:47:20 <Kaidelong> IE "root . mean . map (^2)"
16:47:23 <mm_freak_> can you even express right to left verb composition unambiguously in english?  i mean without cheating ("do X, then Y, then Z in reverse order")
16:47:32 <ivanm> preflex: seen edwardk
16:47:33 <preflex>  edwardk was last seen on #haskell 2 hours, 5 minutes and 5 seconds ago, saying: (without unsafePerformIO)
16:47:37 <gwern> imagine shakespeare reciting it. 'The ingredients pour into th'intrepid mixer which doth fearfuly whirl'
16:47:38 <jmcarthur> mm_freak_: dunno
16:47:48 <Rotaerk> jmcarthur, what do you think I'm arguing for o_O
16:48:13 <gwern> 'the ingredits pour and pat down into th'...' <-- and so on until you have my original formulation
16:48:16 <jmcarthur> Rotaerk: you seem to be saying that we use verbs like we compose functions
16:48:25 <jmcarthur> Rotaerk: every example you've given so far is a list, not a composition
16:49:01 <tg_> jmcarthur: now actually stop
16:49:01 <jmcarthur> i thought i said i was done. i'm really done now. i'm gonna be productive again
16:49:07 <Rotaerk> jmcarthur, err, a list/chain of verbs is what a composition represents; the distinction between an english verb-list and a haskell-composition is the order
16:49:17 <Rotaerk> jmcarthur, which is why the haskell composition order is unintuitive
16:49:18 <tg_> is the guy who made gitit here now, or ever?
16:49:24 * Kaidelong recommends Don Syme's "Expert F#" book as a nice way to get started with functional programming and haskell
16:49:25 <mm_freak_> jmcarthur: foldl (.) id
16:49:33 <gwern> tg_: macfarlane is far too busy with philosophy and haskell to idle on #haskell :)
16:49:45 <Rotaerk> jmcarthur, at least, in english, where you read left to right
16:49:52 <Rotaerk> in arabic it'd be better right to left
16:49:53 <jmcarthur> Rotaerk: i'm done
16:49:54 * djahandarie prefers mac lane
16:50:01 <tg_> gwern: hmm
16:50:08 <gwern> tg_: I know a little about gitit though
16:50:11 <mm_freak_> Rotaerk: it's not unintuitive…  in fact, most languages compose functions from right to left lexically
16:50:12 <gwern> (more about filestore)
16:50:25 <djahandarie> Maybe this should move to #haskell-blah
16:50:28 <Rotaerk> mm_freak_, how?
16:50:28 * kuffaar recommends "Windows/Linux userland development in IA-32 assembly" to get started with functional programming and Haskell
16:50:32 <jmcarthur> it definitely should
16:50:46 <mm_freak_> Rotaerk: in C you write f(g(x)) to mean apply first g, then f
16:50:57 <Rotaerk> mm_freak_, that's not composition though
16:51:05 <Kaidelong> kuffaar: actually doing assembler might be good at understanding some aspects of functional programming, like function calls
16:51:12 <kuffaar> lol.
16:51:17 <Rotaerk> mm_freak_, that's application
16:51:19 <monochrom> mm_freak_: do you have a haskell question?
16:51:29 <Kaidelong> good for*
16:51:30 <monochrom> Rotaerk: do you have a a haskell question?
16:51:39 <Rotaerk> no
16:51:48 <Rotaerk> is this channel strictly for question-asking?
16:51:53 <monochrom> no
16:51:56 <kuffaar> No, Haskell is so simple nobody would ever ask anything about it
16:51:57 <jmcarthur> it's strictly for haskell
16:52:03 <jmcarthur> #haskell-blah is strictly for not haskell
16:52:06 <gwern> (nobody had any opinions on my code and explanations in http://www.gwern.net/sicp/Chapter%201.3.html#monoids or http://www.gwern.net/sicp/Chapter%201.3.html#with-monoids ?)
16:52:07 <Rotaerk> we're discussing haskell
16:52:16 <gwern> #haskell-blah is honored more in the breach than th'event :)
16:52:16 <jmcarthur> you're discussing natural language
16:52:23 <Rotaerk> with relation to haskell
16:52:24 <monochrom> not entirely strictly, but since there is popular demand to move to #haskell-blah...
16:52:39 <jmcarthur> very very loose relation
16:52:52 <jmcarthur> more related to programming in general
16:53:06 <djahandarie> When there is a natural language discussion filling my whole scrollback on a 1200px high screen I imagine it's okay to ask to move it to -blah
16:53:15 <mm_freak_> Rotaerk: anyway, in haskell there is a strong bias towards writing the end product on the left side
16:53:51 <jmcarthur> lambda notation is backward :)
16:53:55 <mm_freak_> but if you're uncomfortable with this, use left to right composition like (>>>)
16:54:10 <Rotaerk> djahandarie, the conversation was about "it should be this way in haskell because it's this way in natural language", and somehow it was interpreted as "this is how people should naturally speak" or something
16:54:16 <Kaidelong> kuffaar: reason I mentioned it is because I think Don Syme did a good job illustrating to imperative programmers why functional programming might be a good thing.
16:54:29 <kyagrd> Anyone using RankNTypes in ghc7?
16:54:42 <kuffaar> kyagrd I came across it only once so far
16:54:44 <djahandarie> Rotaerk, maybe it just needs to be swung back in the right direction like mm_freak_ just did then :)
16:54:48 <kuffaar> But I ended up not turning it on
16:54:52 <Kaidelong> so it might be a good first book if you intend to use haskell, in an indirect way
16:55:09 <djahandarie> kyagrd, I have at one point I think
16:55:24 <Kaidelong> (and F# is occassionally compared to Haskell in it)
16:55:29 <kyagrd> Things that woked in ghc6 doesn't work in ghc7
16:55:39 <djahandarie> kyagrd, got an hpaste example?
16:55:45 <kyagrd> For example when I have "type Cons a b = a"
16:55:50 <jmcarthur> kyagrd: it requires a few more type signatures, usually
16:56:16 <kyagrd> I mean "type Const a b = a"
16:56:30 <gwern> 'The JSMin JavaScript compressor has been retired in favour of more free alternative compressors after it was determined that JSMin's condition that it "be used for Good, not Evil" rendered it incompatible with MediaWiki's General Public License (GPL), which does not restrict reuse in any way (wikitech-l mailing list).'
16:56:58 <gwern> when reading the weekly wikipedia newspaper, one does not expect such comments
16:57:31 <kuffaar> gwern: I facepalm whenever I see people parrotting that crap, I think it's inspired by that Google slogan, among others
16:57:34 <kyagrd> ghc6 used to equatte "forall a . a -> Const b a" and "forall a . a -> Const (Const b a) a"
16:57:36 <Kaidelong> pedantry in the wikipedia community, unthinkable
16:57:39 <kyagrd> but ghc7 doesn't
16:57:49 <kyagrd> I'll make a hpaste example
16:57:50 <jmcarthur> gwern: wow
16:58:34 * Saizan guesses it's a matter of impredicative instantiation
16:58:35 <gwern> jmcarthur: wikipedia - defending the League of Evil's ability to easily update internal documentation
16:58:52 <tg_> did I interpret that correctly?
16:59:05 <tg_> mediawiki rejected a technology liscensced as LGPL + "do no wrong"
16:59:09 <tg_> because of the modification?
16:59:24 <tg_> S/LGPL/GPL/
16:59:24 <jmcarthur> so the license with no restrictions has a restriction that prevents restrictions about good and evil usage of code
16:59:27 <gwern> tg_: the 4 freedoms or whatever - discrimination against no group. not even supervillains
16:59:39 <tg_> gwern: is this part of the CCC framework?
16:59:45 <tg_> no, this is the software liscenscing
16:59:46 <tg_> wow
16:59:47 <tg_> that's weird
17:00:09 <jmcarthur> i would say the do no evil clause was ambiguous at best, though... in their defense
17:00:17 <Y_Less> GPL is very restricted, they just don't like people to realise it
17:00:27 <jmcarthur> well, we shouldn't start a license war here
17:00:34 <ion> Such a clause obviously renders a license nonfree.
17:00:38 <Saizan> we already had a natural language one
17:00:56 <jmcarthur> Saizan: sorry for my part in that
17:01:00 <jmcarthur> everybody who cares ^^
17:01:17 <tg_> ion: does it? what if they changed it to "strive to used for good, not evil"?
17:01:27 <tg_> that's not incompatible with freedom?
17:01:33 <jmcarthur> #-blah
17:01:39 * tg_ sits
17:01:42 <jmcarthur> (and i like this topic, personally)
17:02:14 <monochrom> all of you are missing out all the fun and interesting people in #haskell-blah !
17:02:32 <gwern> monochrom: nice try
17:02:39 <tg_> so fun and so interesting that he's not participating in it
17:02:45 <monochrom> haha
17:02:54 <ivanm> monochrom: but the fun and interesting people in -blah aren't talking!
17:02:58 <Saizan> we miss you, monochrom!
17:03:09 <shachaf> You people are still blah-bbering in here?
17:03:25 <Philippa_> jmcarthur: yeah, either such a clause is meaningless or you should never, ever sign it
17:03:38 <tg_> in this channel, interaction with lambdabot and questions about that only allowed!
17:03:43 <Eduard_Munteanu> I hear all Haskell-related talk now goes on in -blah :P
17:04:03 <Saizan> shachaf: kyagrd said he would paste some code but he(?) never got back with a link
17:05:00 <kyagrd> Wait a min ...
17:05:05 <kuffaar> Saizan: English has a gender neutral pronoun <:
17:05:11 <Saizan> kyagrd: joking :)
17:05:22 <mm_freak_> as if we were on topic all the time…  unlike all other language channels, this one spends well 30% of its time talking about other languages…  and i've never heard anyone complain, when we talk about agda ;)
17:05:39 <monochrom> indeed kuffaar write its code very carefully
17:05:49 <kuffaar> writes*?
17:05:54 <monochrom> yeah, writes
17:05:55 <gwern> the kuffaar puts the lotion on its code
17:05:55 <kuffaar> monochrom: "they" is quite common actually
17:06:06 <Saizan> but you can't have flame wars on agda, not enough strong opinions
17:06:09 <monochrom> I'm just teasing you :)
17:06:10 <kuffaar> "They never got back with a link" <- can refer to a single person
17:06:23 <kuffaar> http://en.wikipedia.org/wiki/Singular_they
17:06:39 <djahandarie> Saizan, Agda is a dependently-typed language!
17:06:57 <kuffaar> I use it on IRC all the time
17:06:58 <Saizan> djahandarie: true
17:07:03 <mm_freak_> Saizan: so we haven't had "we need dependent types in haskell!" discussions?
17:07:05 <kuffaar> Instead of pretending that everybody is male
17:07:13 <Eduard_Munteanu> Sounds like addictedly-typed language.
17:07:21 <djahandarie> Saizan, Agda is a proof-assistant based on intuitionistic type theory!
17:07:32 <kyagrd> http://hpaste.org/43297/ghc7_problem_with_rankntypes_a here
17:08:57 * monochrom writes letter to Hongwei Xi. "Remember me from Marktoberdorf 2000? I now love Haskell. It would be nice if you could come up with Dependent Haskell like you did Dependent ML. We guys and girls in #haskell will thank you forever. Best regards, ..."
17:09:35 <Saizan> mm_freak_: i've never seen those go like the c++ or natural language or license ones, the worst they get is "dependent types can give my ponies", anyhow esoteric programming language theory always seemed more in-topic than haskell itself here :)
17:09:59 <mm_freak_> yeah
17:10:26 <kyagrd> Should I report this ghc trac?
17:10:33 <gwern> 'What we really need is a statement from Douglas Crockford, along these lines:
17:10:33 <gwern> "I give permission for Wikimedia, its customers, partners, and minions, to use
17:10:33 <gwern> JSLint for evil."
17:11:49 <tg_> they just don't have the hubris to declare that wikipedia IS good work
17:12:57 <Saizan> kyagrd: "mcata f = f (mcata (\x -> f x)) . out" works
17:13:38 <kyagrd> ok, but why not the original form?
17:13:50 <Saizan> kyagrd: i think this is expected because they removed some of the "hacks" in the type checker for impredicative inference in the last release, though icbw
17:14:17 <kyagrd> So does that mean ghc7 stopped to equate type synonyms under RankNTypes?
17:15:13 <mm_freak_> > filterM([0<1,0>1]) "abc"
17:15:14 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
17:15:14 <lambdabot>         against inferre...
17:15:49 <Saizan> kyagrd: written like that sounds quite weird, so maybe it's really a bug
17:15:58 <mm_freak_> > filterM(pure[0<1,0>1]) "abc"
17:15:59 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
17:16:35 <kyagrd> It doesn't seem to be documented in the release note, maybe just disabled by accident
17:17:33 * Kaidelong wonders if "filter" should be (MonadPlus m) => m a -> (a -> Bool) -> m a
17:17:39 <Kaidelong> err
17:17:44 <Kaidelong> well, first two arguments reversed
17:17:49 <mm_freak_> > filterM(pure[0<1..]) "abc"
17:17:50 <lambdabot>   ["abc"]
17:18:02 <mm_freak_> > filterM(pure[0>1..]) "abc"
17:18:03 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
17:18:15 <mm_freak_> shorter subsequences?
17:24:19 <aristid> :t [0>1 .. ]
17:24:20 <lambdabot> [Bool]
17:24:27 <aristid> > [0>1 .. ]
17:24:28 <lambdabot>   [False,True]
17:24:32 <aristid> > [0<1 .. ]
17:24:33 <lambdabot>   [True]
17:25:24 <shachaf> [0>1,1>0..]
17:25:30 <shachaf> > [0>1,1>0..]
17:25:31 <lambdabot>   [False,True]
17:26:18 <djahandarie> mm_freak_, nice!
17:27:02 <shachaf> > length "filterM(pure[0>1..])"
17:27:03 <lambdabot>   20
17:27:11 <shachaf> > length "subsequences"
17:27:12 <lambdabot>   12
17:28:04 <djahandarie> :t filterM$pure[0<1..]
17:28:05 <lambdabot> forall a. [a] -> [[a]]
17:29:39 <kyagrd> Added to ghc trac issue http://hackage.haskell.org/trac/ghc/ticket/4917
17:34:22 <Jesin> umm
17:34:24 <Jesin> newtype Mu f = Mu (f (Mu f))  deriving Show
17:34:28 <Jesin> what is ^ that?
17:34:34 <Jesin> and how do I interpret it
17:34:43 <Jesin> well, it's a recursively defined newtype
17:34:45 <Jesin> but
17:34:48 <Jesin> how do I interpret that  :p
17:35:14 <monochrom> I don't know why "deriving Show" and what it buys you. I'll ignore that.
17:36:13 <kyagrd> Jesin: It's a fixpoint for datatypes
17:36:41 <monochrom> But as a first example, define also "data F self = Nil | More Int self". Then "Mu F" is isomorphic to [Int]
17:37:56 <monochrom> or define "data G self a = No | Mo a self", then "Mu G" is isomorphic to [a].
17:38:04 <kyagrd> Can't generally derive Show for that
17:38:13 <Jesin> well
17:38:15 <Jesin> I copypasted
17:38:21 <Jesin> ignore the deriving Show
17:38:23 <Jesin> :p
17:38:32 <kyagrd> you usually have to use stand alone deriving when you are into that kind of trick
17:39:11 <Saizan> data G a self = ...; Mu (G a); otherwise you'd need kind polymorphism
17:39:26 <monochrom> hrm!
17:39:26 <Saizan> or composition
17:39:38 <kyagrd> Jesin http://knol.google.com/k/catamorphisms see this article
17:39:51 <monochrom> Yes, use "data G a self =". I'm dumb.
17:40:34 <gwern> a knol!
17:40:44 <gwern> I wonder when google will kill knol
17:41:06 <Eduard_Munteanu> Why? What else did they kill?
17:41:08 <monochrom> You could handwavingly expand "Mu F = F (Mu F) = Nil | More Int (Mu F)" so this is why it looks like [Int].
17:41:46 <monochrom> google killed alta vista
17:42:06 <gwern> Eduard_Munteanu: google notebook comes to mind as one that affected me
17:42:19 <gwern> oh, and google wave
17:42:53 <gwern> google voice, too, didn't they?
17:43:01 <Eduard_Munteanu> Hm, didn't use those Google thingies.
17:44:12 <augur> anyone know of any "new paradigms"?
17:44:35 <Jesin> *sigh* I copypasted that from here btw http://www.willamette.edu/~fruehr/haskell/evolution.html
17:44:46 <Jesin> :p
17:45:28 <reacocard> gwern: voice is still very much alive
17:45:49 <gwern> reacocard: really? wasn't there a google phone number you could call for directions or something but google shut it down?
17:45:59 <gwern> I remember a number of people quite sad over it
17:46:04 <reacocard> that's GOOG-411, not voice
17:46:16 * gwern makes a prediction: better than even odds knol is dead by 2020: http://predictionbook.com/predictions/2156
17:46:33 <gwern> reacocard: oh, ok. that's what I meant, then
17:46:39 <monochrom> with "data N c = Z | S c", "Mu N = N (Mu N) = Z | S (Mu N)" so you have peano numbers.
17:47:11 <gwern> I am a little disappointed in edwardk for using knol
17:47:16 <aristid> gwern: i don't think you'll find a lot of people willing to bet against you there
17:47:45 <gwern> aristid: still useful to write these things down
17:47:45 <aristid> or wait, your prediction is a bit stronger
17:48:10 <aristid> gwern: i'm not sure if they will entirely stop hosting it
17:48:30 <gwern> google isn't good with followthrough. look at google groups.
17:48:45 <monochrom> google groups is just fine
17:49:01 <Jesin> ...
17:49:02 <gwern> one group I'm on is wonder what to do with our collected documents now that google said oh btw we're deleting it all
17:49:09 <Jesin> GeoCities is still available in Japan apparently
17:49:18 <aristid> gwern: download them and put them on github?
17:49:18 <gwern> to say nothing of their shitty usenet hosting
17:49:30 <gwern> aristid: dump a bunch of psychology PDFs on github?
17:49:39 <aristid> why not?
17:49:40 <gwern> aristid: is that even kosher by their ToS?
17:50:00 <aristid> uh, you could ask them if they are fine with that if you have doubts
17:50:15 <gwern> aristid: bigger problem is that they're not really techies. heck, even I don't want to use git
17:50:18 <aristid> or you could put them on a server
17:50:43 <monochrom> blogspot. which is google again.
17:50:44 <kuffaar> <gwern> aristid: is that even kosher by their ToS?
17:50:45 <kuffaar> Who cares
17:50:52 <kuffaar> Just do it
17:51:03 <aristid> kuffaar: whoever does not want it to be deleted without notice
17:52:01 <duairc> I've read a lot about how you should use MonadWriter for logging, but the only examples I've seen use String or [String] or things like that, and they all say that this is inefficient. What kind of things do people use with MonadWriter in practice?
17:52:19 <gwern> ANYWAY. google doesn't have the best long-term track record
17:52:27 <gwern> they just haven't quite pulled a Yahoo yet
17:52:38 <kuffaar> gwern: Record of what?
17:52:52 <Eduard_Munteanu> IMHO, Yahoo's (free) services just suck
17:53:01 <gwern> kuffaar: record of hosting stuff for the long-term when it involves a failed project
17:53:24 <aristid> gwern: you referencing google groups files mostly?
17:53:25 <Jesin> blogspot hasn't failed, I think...
17:53:32 <gwern> aristid: and the others I cited
17:53:35 <kuffaar> <gwern> aristid: bigger problem is that they're not really techies. heck, even I don't want to use git
17:53:39 <Saizan> duairc: Endo [Char] is alres+y 
17:53:49 <kuffaar> Why not? It's not like using it is radically different from other DVCS
17:53:52 <Saizan> duairc: *already better
17:54:00 <aristid> gwern: you didn't cite any others?
17:54:03 <kuffaar> clone, pull, commit, push?
17:54:13 <gwern> 'are you a project that was supposed to be super successful and kill wikipedia? and only a hundred or thousand people use you and you are an object of derision? then best not make any plans for the 2020s'
17:54:46 <gwern> kuffaar: again, not techies. they have trouble editing a standard config.ini
17:54:47 <aristid> gwern: no, knol does not count as an example for not hosting stuff, because it is still all hosted.
17:54:58 <gwern> aristid: currently...
17:55:12 <kuffaar> gwern: I was talking about you!
17:55:13 <gwern> aristid: if googl were already deleting knol stuff, it'd hardly be an interesting prediction
17:55:16 <aristid> gwern: i'm searching for examples that already happened
17:55:28 <aristid> gwern: to be able to judge your prediction better
17:55:37 <Eduard_Munteanu> gwern: what about a plain mailing list + FTP / archive site.
17:55:38 <Eduard_Munteanu> ?
17:55:51 <gwern> kuffaar: and what, make me a bottle-neck for every group member who wants to upload a PDF? too much of a barrier. I learned on Wikipedia to respect and fear trivial inconveniences
17:56:09 <gwern> a simple browser upload interface is best, and that's what google is taking awya from us
17:57:04 <aristid> hmm.
17:57:05 <gwern> Eduard_Munteanu: FTP? are you joking?
17:57:13 <aristid> is there a simple service for such things?
17:57:23 <gwern> I might as well tell them to telnet into my server and edit some gopher listings
17:57:48 <aristid> well, unsecured ftp can be used easily from windows explorer ;)
17:58:06 <Kaidelong> http://hackage.haskell.org/packages/archive/Pipe/2.1.2/doc/html/System-Process-Pipe.html <-- is this done with OS pipes?
17:58:12 <gwern> aristid: that's what I'd like to know. dropbox doesn't seem to support group access and we'd like only group members to upload - but all group members. access tied to group access. again, something best done on google's end
17:58:12 <Eduard_Munteanu> No, I mean installing some mailing list stuff on a server and having the files show up on FTP. Then it's just following links from e-mails to get the files.
17:58:45 <aristid> gwern: ok, i wonder if google groups has an API or so to fetch the member list
17:59:16 <gwern> aristid: I doubt it. and even if it did, I would still resent google for breaking a perfectly cromulent status quo and forcing me to do work I didn't have to
17:59:30 <aristid> gwern: i know that there is dropbox for teams, and that it has shared folders, but certainly no google groups integration
17:59:34 * hackagebot smallarray 0.2.0 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.2.0 (AntoineLatter)
18:01:03 <aristid> gwern: and i have no idea why google did what they did there
18:01:30 <Kaidelong> smallarray looks interesting but there is no documentation for it
18:01:44 <deech> I was reading a blog post (http://cdsmith.wordpress.com/2011/01/03/big-ideas-for-haskell/) which says that Haskell functions are not serializable. Is there some technical reason this isn't possible in Haskell?
18:02:08 <BMeph> Back to the subject of Google killings, GSpace comes to mind. I loved GSpace - use your GMail account as a "cloud-based virtual drive," as the current buzzwords would call it.
18:02:20 <monochrom> takes a while for hackage to run the next batch of builds and build haddock.
18:02:35 <gwern> deech: functions are serializable. it's been done like 3 or 4 times now
18:02:42 <aristid> BMeph: gspace seems to still exist, it has a website at least
18:03:01 <gwern> deech: except it always requires some GHC hacks, and no one has yet gotten it into a GHC release
18:03:05 <Saizan> deech: just the usual problem of requiring compiler magic
18:03:06 <aristid> gwern: i wonder if tying google docs access to group membership would work
18:03:09 <BMeph> aristid: Read the website info, and you'll see that it's getting shut down soon... :\
18:03:25 <Saizan> gwern: can you name one?
18:03:47 <gwern> Saizan: sure, there's one in preprint whose author I sent a copy of SerTH
18:03:52 <gwern> let me look up my email
18:04:21 <BMeph> There should be a HaskellWiki entry for that... :)
18:04:23 <gwern> Saizan: 'Orthogonal Serialisation for Haskell' <-- saw it on reddit
18:04:30 <aristid> BMeph: where? i don't see a shut down notice
18:04:37 <Eduard_Munteanu> Does that hint to a Haskell sorta RPC? It sounds trivial.
18:06:19 <gwern> Eduard_Munteanu: sending functions over the network was the motivation for 1 or 2 previous serialization implementations like iirc Mobile Haskell
18:06:30 <deech> I guess I'm not understanding the challenge. I can store a function in any data structure, so there is some internal representation. Why is this hard to serialize?
18:07:06 <gwern> deech: because it lacks principles. what are you going to dump, some binary mess which might be of any type when you read it back?
18:07:31 <Eduard_Munteanu> Is that sending code, or just a function name? Because if it's the latter, it sounds really easy to accomplish by calling the system linker or something.
18:07:33 <copumpkin> zygoloid: you around?
18:07:51 <gwern> Eduard_Munteanu: fairly sure they sent code. sending function name sounds very limited
18:08:02 <copumpkin> it is very limited
18:08:08 <copumpkin> and I don't think they send code
18:08:09 <Eduard_Munteanu> Well, that sounds difficult.
18:08:45 <gwern> although as I said serialization has been investigated and done a number of times so maybe one group did just send names and invoked the linker on the remote system
18:08:45 <copumpkin> deech: you store a function in a data structure by storing its closure, that is a pointer to a statically compiled function and some environment for it
18:09:11 <copumpkin> you can send the environment easily
18:09:23 <copumpkin> the pointer to the statically compiled function is meaningless on the other side though
18:09:25 <gwern> (serialization is one of my best examples for the thesis that haskellers lack followthrough. people keep asking for it, and keep doing it, and yet...)
18:10:11 <Eduard_Munteanu> I guess that only works with homogenous, as in same architecture and CPU, machines.
18:10:17 <deech> copumpkin: This is simplistic, but how about simply storing the inferred type of the function along with its binary representation?
18:10:18 <edwardk> copumpkin: awake?
18:10:32 <copumpkin> what's its binary representation? and why bother with the type?
18:10:39 <edwardk> deech: serializing functions?
18:10:40 <copumpkin> edwardk: possibly :)
18:10:44 <Saizan> PhD projects lack followthrough, and this is something messy enough that it's hard to get the code accepted into GHC HEAD during one
18:10:58 <edwardk> deech: the problem is what do you do with resources that can't serialize safely, like IO handles?
18:11:26 <aristid> gwern: ok, google docs supports limiting access to google group members
18:11:29 <deech> edwardk: Good point. I don't know. 
18:11:39 <edwardk> copumpkin: argument in favor of adding an Extend class: instances for [] Maybe, Either a, etc.
18:11:41 <gwern> aristid: it support PDFs and whatnot?
18:11:41 * copumpkin is trying to figure out card marking
18:11:50 <aristid> gwern: yes.
18:11:54 <edwardk> copumpkin: notch the corner
18:11:55 <copumpkin> edwardk: oh yeah
18:12:01 <copumpkin> edwardk: oh yeah
18:12:02 <copumpkin> :P
18:12:20 <aristid> gwern: i suppose that is the real reason behind the shutdown of google groups files: they want you to use google docs instead.
18:12:34 <gwern> aristid: wouldn't surprise me. still somewhat assholeish of them
18:12:40 <edwardk> as in the existing ghc scheme for it?
18:12:48 <edwardk> or how it works in general?
18:13:22 <aristid> gwern: yeah, it's not very gentleman-like.
18:13:30 * lpsmith wishes IO supported callCC,  and maybe callCC1 and dynamicWind
18:13:31 <edwardk> deech: the best way i can think of is to exploit something like the type system washburn used in principia narcissus
18:13:38 * hackagebot smallstring 0.3.0 - A Unicode text type, optimized for low memory overhead  http://hackage.haskell.org/package/smallstring-0.3.0 (AntoineLatter)
18:13:44 <aristid> lpsmith: why?
18:13:52 <gwern> aristid: I sometimes wonder if there's an internal google status divide between those who work on flagship products like search, chrome, gmail, etc. and those working on the obscure relatively-failed products like google notebook or google groups, and this divide is why the latter suck so much - the employees are just utterly demoralized
18:13:58 <edwardk> deech: that would tell you for each type a.) if you were trying to serialize it and b.) if you could
18:14:00 <kamatsu> if i have a POSIX process id as a string
18:14:07 <kamatsu> can Haskell determine if that process is running?
18:14:08 <edwardk> but that leaks into the language
18:14:16 <kamatsu> I can only find examples for child processes of the current process
18:14:21 <lpsmith> aristid, I'm looking for a way to install a top-level exception handler for an IO thread
18:14:33 <aristid> gwern: yeah, i think there's plenty of status involved in this. google does allow engineers to move between projects i think, and they will probably want to move to "cool" projects
18:14:39 <edwardk> kamatsu: you can look in /proc =)
18:14:50 <lpsmith> Using callCC and mutable references,  I can implement mapCont and thus install my handler
18:14:51 <edwardk> kamatsu: not terribly portable though
18:14:53 <aristid> gwern: i think maybe they should reward "dull" work better
18:14:57 <kamatsu> edwardk: doesn't matter
18:15:01 <kamatsu> i'll try that
18:15:10 <kamatsu> gwern: that definitely exists.
18:15:26 <kamatsu> gwern: google shift developers out of projects that are not that successful
18:15:30 <gwern> aristid: for example, the google custom search engines. very useful in wikipedia work. there was a problem and an engineer emailed me. I emailed back with a laundry list of suggestions to make CSEs much better, and have heard nothing and CSEs haven't changed a bit in like years
18:15:39 <deech> edwardk: I haven't heard of that system. I'll google it. But what about pure functions? Those don't have the IO issues you mention.
18:15:51 <edwardk> copumpkin: the argument against adding extend is it goes in comonad, and it then requires me to import semigroup to make the extend instance
18:15:52 <gwern> kamatsu: you interned there didn't you?
18:15:55 <kamatsu> gwern: yep
18:16:06 <edwardk> deech: they do if they close over an IO file handle in their environment.
18:16:19 <gwern> kamatsu: you think the status thing is enough to explain why the minor projects suck so much?
18:16:23 <kamatsu> gwern: my manager mentioned that google were threatening to pull some developers from Wave cos usage didn't pick up.
18:16:31 <aristid> gwern: maybe if you know the RIGHT people, you can do something
18:16:38 <kamatsu> evidently they did so after I left.
18:16:40 <gwern> kamatsu: hah. we know how that turned out don't we
18:16:56 <edwardk> deech: the problem is you fundamentally require an extension to types to know whether or not a given thunk is serializable, and that judgment may require some pretty heavy lifting
18:17:05 <kamatsu> i think Wave can still work given more time to mature
18:17:11 <kamatsu> but yeah, Google pulled the plug
18:17:31 <kamatsu> they tend not to ever pull the plug completely and they leave a few small teams working on the minor projects
18:17:35 <copumpkin> edwardk: semigroups are fine!
18:17:40 <deech> edwardk: I see your point.
18:17:42 <edwardk> copumpkin: k =)
18:17:46 <lpsmith> Of course,  I should specify that it's an existing error thread,  and you have some code that can run in that thread.    So it's not entirely external,  but I'm also assuming that you don't have full control over the thread either; specifically you don't control how it was forkIO'ed
18:17:51 <edwardk> Data.Functor.Extend it is
18:17:52 <kamatsu> but I know some of their not popular projects have 2 main developers and 1 PM.
18:18:06 <copumpkin> edwardk: but then again I use agda, so take my notion of practicality with a grain of salt
18:18:06 <deech> Certainly sounds non-trivial now that you've explained it.
18:18:09 <edwardk> i might as well 'be the change i want to see in the world'
18:18:24 <lpsmith> Maybe Agda will be practical in 20 years :)
18:18:30 <gwern> kamatsu: I don't entirely understand why the minor projects don't seem to improve. for example, I had one improvement that would have saved me dozens of hours, annotating CSE hits with a blacklist/whitelist button. still hasn't appeared, and from what I can tell, it wasn't a major change at all
18:18:31 <aristid> kamatsu: nothing wrong with small teams
18:18:38 <edwardk> deech: usually i just ignore those issues and let it blow up, but i'm a bit crazy
18:18:54 <aristid> lpsmith: haskell was not practical 20 years ago, agda is not practical now? this line of thinking?
18:19:00 <gwern> kamatsu: are they stuck on a constant upgrade treadmill, dealing with the latest bigtable change or whatever?
18:19:03 <kamatsu> aristid: true, but I imagine this problem gwern mentions is just that google under-resource unpopular projects, sometimes prematurely.
18:19:10 <lpsmith> aristid, Yeah basically
18:19:11 <edwardk> after all, we live with withFoo functions all over that rely on you not holding onto the resource across its scope
18:19:26 <kamatsu> gwern: that happens too. Google used to have a very nice abstraction on top of bigtable called megastore.
18:19:32 <kamatsu> gwern: lots of old projects were built on it
18:19:32 <gwern> these are the things I speculate about
18:19:42 <lpsmith> of course,  I was kind of replying to copumpkin's comment
18:19:44 * shapr hugs gwern 
18:19:44 <deech> copumpkin: I dunno I recently read about an Agda web-framework (http://www.reddit.com/r/haskell/comments/d8dck/lemmachine_a_web_framework_in_agda/?sort=old). It maybe practical after all.
18:19:47 <edwardk> deech: but there are a number of other things in the RTS like that. i mean take Data.Unique, internally its just a counter. when you send them over the network, though?
18:19:54 <kamatsu> gwern: megastore was pronounced "bad" across the entire company for some reason and everyone is encouraged to move their projects off it
18:19:57 * gwern gingerly hugs shapr back. no homo
18:20:00 <shapr> haha
18:20:05 <edwardk> shapr!
18:20:07 <kamatsu> gwern: build tools and other features are deprecated often in favour of new stuff
18:20:11 <tac-tics> Haskell is practical now? I thought we just kept it around because we hate our dayjobs.
18:20:12 <shapr> edwardk: o hai! How's code?
18:20:23 <edwardk> shapr: quite well.
18:20:25 <shapr> tac-tics: I've been paid to write Haskell, how else do you define practical?
18:20:29 <edwardk> lots of tiny projects on github
18:20:34 <aristid> edwardk: fixing Data.Unique to be serialisable should not be that hard, but it would be a lot slower then
18:20:34 <shachaf> @get-shapr
18:20:35 <lambdabot> shapr!!
18:20:38 <gwern> kamatsu: I suppose that's one of the downsides of perfectionist engineers
18:20:55 <gwern> aristid: how would you fix Unique? make it generate GUIDs?
18:20:57 <edwardk> aristid: which reduces the power of having it =/
18:21:01 <shapr> shachaf: You screamt?
18:21:16 <kamatsu> gwern: the other thing is often google engineers get sucked into ratholes. One of the downsides of flat structure is there isn't a huge amount of accountability
18:21:25 <gwern> kamatsu: ratholes?
18:21:31 <shapr> rabbit holes?
18:21:33 <aristid> gwern: UUIDs, but yes.
18:21:33 <tac-tics> Shapr: you can send a monkey to space to, and it's been done, but I still won't call it a practical thing to do
18:21:39 <tac-tics> ;)
18:21:48 <deech> edwardk: I guess that's the advantage of dealing with a VM right? The smalltalk and lisp guys can save an image and restart it.
18:21:50 <kamatsu> gwern: engineers work on tiny little problems that aren't relevant, managers are in on it, no one notices that these problems don't need to be solved.
18:21:56 <shapr> tac-tics: Ok, how would you quantify the practicality of a language?
18:22:07 <heis> Fine people of #haskell: is there some philosophical difference between ReadP and Parsec?  Is Parsec just a more extensive implementation of the same concept?  Are you aware of a tutorial-level example of building a parser of either type from scratch?
18:22:08 <gwern> kamatsu: oh. I guess I'd call that navel-gazing or yak-shaving
18:22:43 <aristid> heis: i think parsec is a lot less ad hoc, and much easier to use
18:22:49 <tac-tics> Shapr: like any interesting property of a language, that is an undecidable predicate
18:22:50 <kamatsu> gwern: Google also don't always hire the best managers
18:23:04 <kamatsu> gwern: hell, my boss thought that adding more developers makes project go faster
18:23:18 <kamatsu> gwern: he's gone to facebook now, good riddance
18:23:20 <gwern> kamatsu: how could it not? more developers means a greater peak LoC/day!
18:23:22 <copumpkin> tac-tics: doesn't prevent heuristics
18:23:26 <heis> Well, my goal here is not to use a fully-featured parser, but to understand how a simplified version of either works
18:23:39 * gwern expects to see Google Wave implemented piece by piece in facebook
18:23:51 <kamatsu> gwern: he was also the guy that did maps
18:23:55 <heis> All the wrapper types in either makes it hard to figure out the basic concepts from teh source
18:23:57 <shachaf> shapr: Just wanted to see if the command was still there.
18:23:58 <kamatsu> gwern: expect facebook to do social travel stuff
18:24:03 <gwern> good idea
18:24:38 <Saizan> heis: there are papers about their implementations
18:24:58 <shapr> tac-tics: In that case, my personal heuristics judge Haskell as totally practical, perhaps too practical.
18:25:26 <kamatsu> gwern: also, Google buy alot of startups and then just shove the people in those startups into teams
18:25:32 <pedro3005> what's the proper way of doing this?
18:25:35 <pedro3005> Prelude> any (\x -> x == True) [True, False]
18:25:35 <pedro3005> True
18:25:42 <copumpkin> pedro3005: all
18:25:48 <gwern> @remember shapr my personal heuristics judge Haskell as totally practical, perhaps too practical.
18:25:48 <lambdabot> Done.
18:25:49 <kamatsu> gwern: because startup employees aren't hired by the usual processes, they're not always technically very competent.
18:25:51 <pedro3005> huh, really
18:26:05 <kamatsu> gwern: some of Google's minor products are just those startup's products and they haven't changed much since.
18:26:06 <copumpkin> pedro3005: (== True)  ~ id
18:26:11 <copumpkin> pedro3005: and any id = all
18:26:17 <mm_freak_> <
18:26:20 <copumpkin> pedro3005: and by all I mean or
18:26:25 <copumpkin> :P
18:26:31 <pedro3005> copumpkin, wait, what? that wasn't very clear
18:26:45 <Axman6> pedro3005: x == True === x always
18:26:46 <gwern> kamatsu: doesn't surprise me. the maw of the great beast doesn't always masticate finely
18:26:47 <kamatsu> gwern: I was speaking to guys from a mobile ads startup bought by Google. He didn't even know what functional programming was, let alone Haskell :(
18:26:51 <shapr> kamatsu: At some level, that makes sense... it's like buying research results from other companies, then seeing if they can be profitable.
18:26:53 <Axman6> so you could write all (\x -> x)
18:26:58 <Axman6> or all id
18:27:03 <Axman6> or and
18:27:04 <Axman6> because
18:27:07 <gwern> :t any (\x -> x == True)
18:27:08 <Axman6> @src and
18:27:08 <lambdabot> and   =  foldr (&&) True
18:27:08 <lambdabot> [Bool] -> Bool
18:27:16 <gwern> @hoogle [Bool] -> Bool
18:27:17 <lambdabot> Prelude and :: [Bool] -> Bool
18:27:17 <lambdabot> Prelude or :: [Bool] -> Bool
18:27:17 <lambdabot> Data.List and :: [Bool] -> Bool
18:27:18 <sutats> Not sure where to ask this, but which would be grow faster: O(2 ^ sqrt(ln(ln n))) or O(n)? In my mind, the former looks somewhat like O(2 ^ n), but when I substitute actual numbers for n (even large values), it never seems to surpass linear growth.
18:27:20 <pedro3005> but I want any, not all
18:27:20 <Axman6> @src all
18:27:21 <lambdabot> all p =  and . map p
18:27:22 <copumpkin> except it was any, but just s/all/any. and /s/and/or/
18:27:29 <Axman6> pedro3005: then you weant or
18:27:32 <pikhq> kamatsu: On the other hand, even "normal hiring processes" don't exactly guarantee technical competence.
18:27:34 <Axman6> @src or
18:27:35 <lambdabot> or    =  foldr (||) False
18:27:35 <kamatsu> gwern: However I also spoke to the guys from Etherpad who joined Wave, and they were smart cookies.
18:27:44 <Axman6> @src any
18:27:45 <lambdabot> any p =  or . map p
18:27:46 <kamatsu> pikhq: true but they guarantee a minimal understanding of problem solving and computer science
18:27:48 <aristid> kamatsu: are you saying that technical competence is a problem of google's? i rather think that EVERYTHING ELSE is their problem :)
18:27:57 <pikhq> kamatsu: Not really.
18:27:59 <copumpkin> #haskell-blah 
18:28:04 * shapr agrees with copumpkin 
18:28:05 <gwern> kamatsu: etherpad tackles an interesting problem. overlap with darcs and operational transformations
18:28:18 <kamatsu> gwern: wave uses the same thing, operational transforms
18:28:18 <shapr> Truly, Google-oriented discussion belongs on #haskell-blah
18:28:25 <kamatsu> gwern: i have a haskell implementation on github
18:28:40 <shapr> kamatsu: of operational transformations?
18:28:42 <kamatsu> yes
18:28:43 <shapr> kamatsu: url?
18:28:55 <gwern> kamatsu: yeah, operational transforms were discussed a few times on the darcs mailing list, but we await the person with the knowledge of both haskell/darcs-patch-theory and operational transformations
18:29:03 <shapr> kamatsu: Oh, I've heard of you.
18:29:11 <aristid> shapr: now you're participating in what you wanted to move to -blah just seconds ago :P
18:29:11 <Axman6> heh
18:29:17 <gwern> for all we know, operational transform results solved darcs patch theory decades ago
18:29:22 <kamatsu> https://github.com/liamoc/opardum-server
18:29:26 <shapr> aristid: Nah, we got started talking about Haskell source code at this point, it's good.
18:29:30 <gwern> wouldn't be the first time silos caused problem
18:29:33 <kamatsu> it was just based on what I learnt of it during my internship
18:29:44 <kamatsu> actually, the theory is very similar to darcs
18:29:50 <shapr> So where do I read more about operational transformations?
18:29:57 <kamatsu> uh, i can explain them do you if you like
18:30:03 <kamatsu> but perhaps i should move it to haskell-blah.
18:30:08 <kamatsu> *to
18:30:09 <edwardk> deech: yeah but the price is the (lack of) semantics that make up lisp/smalltalk ;)
18:30:11 <gwern> shapr: I have no idea. if we knew, we might know how it matched up with darcs :)
18:30:18 <copumpkin> #haskell-overflow
18:30:33 * copumpkin feels like traffic police
18:30:37 <aristid> copumpkin: no, #haskell-blah is better because i'm already in there.
18:30:54 <edwardk> i've spent a fair bit of time looking at operational transform theory, doesn't solve the darcs problem as far as i can tell
18:31:18 <edwardk> lot of overlap though
18:32:32 <mjonsson> is there any language where function application is right-associative?
18:33:02 <shachaf> Ha, I misread mjonsson as sjanssen. It's been a while since he's been around, hasn't it?
18:33:06 <shachaf> preflex: seen sjanssen
18:33:07 <preflex>  sjanssen was last seen on #haskell 236 days, 22 hours, 48 minutes and 19 seconds ago, saying: jbapple: I'm not familiar with any of those packages, so I really don't know
18:33:12 <shapr> edwardk: being discussed on #haskell-overflow if you want to object
18:33:34 <shapr> Also been awhile since jbapple was on #haskell
18:33:47 <edwardk> shapr: he hops on irc, but usually doesn't make it to the channel
18:35:06 <aristid> mjonsson: reverse polish notation, and forth
18:35:56 <aristid> mjonsson: more generally i would expect any such language to have the rightmost argument be the function
18:36:08 <aristid> and anything to the left would be the arguments
18:38:15 <john_r_watson> anyone up for haskell golf?
18:38:23 <john_r_watson> code golf
18:38:41 <mjonsson> aristid: yeah, that seems to be the closest.. those languages also flip the argument order
18:39:15 <aristid> mjonsson: strictly speaking forth does not really have functions, but hey
18:39:21 <john_r_watson> return true w/ balanced parens, false otherwise:
18:39:22 <john_r_watson> answer = (0==) . foldl step 0
18:39:22 <john_r_watson>   where { step (-1) _ = -1; step n '(' = n+1; step n ')' = n-1; step n _ = n }
18:39:22 <john_r_watson>  
18:39:33 <Jesin> [21:49:02]	<aristid>	mjonsson: strictly speaking forth does not really have functions, but hey
18:39:36 <Jesin> how about Factor then
18:39:37 <Jesin> :p
18:39:40 <Jesin> Factor kinda does
18:39:59 <Jesin> ...eh
18:40:07 <Jesin> well, it has serialized code blocks
18:40:08 <Jesin> :p
18:40:18 <Jesin> and I think its "words" have arity
18:41:14 <Jesin> also, @pl should learn to recognize when it can specialize safely
18:41:24 <Jesin> rather than just generalizing
18:41:44 <Jesin> well, that and @unpl
18:42:37 <Jesin> as it is, @pl can put (>>=) and ap into things, referring to the (->) monad
18:43:03 <Jesin> but neither @pl nor @unpl seems able to recognize when (>>=) is used in such a way that it can only be in the (->) monad
18:45:45 * hackagebot smallarray 0.2.1 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.2.1 (AntoineLatter)
18:46:26 <turiya> hi
18:47:31 <shapr> o hai turiya, how's code?
18:47:33 <turiya> u i j 0 = i*j
18:47:33 <turiya> u i j n = (u (i-1) j (n-1)) + (u i (j-1) n) and u :: Int -> Int -> Int. Now, u 1 100 30 takes a long time. Would the C version be an better?
18:48:12 <Jesin> this looks potentially ackermann-like?
18:48:13 <turiya> any*
18:48:35 <monochrom> this is just fibonacci-like
18:48:42 <Jesin> right, ok
18:48:45 <Saizan> turiya: tried some bang patterns on i and j? also the double recursion looks like it could benefit from memoization/dynamic programming
18:48:52 <Jesin> also ^ that
18:49:39 <turiya> Saizan: whats memoization
18:49:48 <Axman6> hmm, would you use a 2D or 3D array to memoise that?
18:49:58 <Jesin> hmm
18:50:11 <Jesin> maybe don't bother with arrays?
18:50:16 <Axman6> it feels like you'd need 3D, but i can't tell if the n doesn't need to be indexed
18:50:22 <Axman6> bah
18:51:09 <monochrom> it does not terminate. here is an infinite sequence of calls: u 1 1 1, u 1 0 1, u 1 (-1) 1, u 1 (-2) 1, u 1 (-3) 1 ...
18:51:25 <Jesin> @type let {u i j 0 = i*j; u i j n = (u (i-1) j (n-1)) + (u i (j-1) n)} in u
18:51:26 <lambdabot> forall a t. (Num a, Num t) => a -> a -> t -> a
18:51:29 <Jesin> umm
18:51:40 <monochrom> for the happy case of a non-terminating function, the C version is not faster than the haskell version :)
18:51:44 <Jesin> turiya, it doesn't look like you have the type signature right
18:52:00 <Jesin> also the non-terminating is a problem yeah
18:52:01 <Saizan> turiya: http://www.haskell.org/haskellwiki/Memoization
18:52:39 <Latro> @pl \x1 x2 x3 x4 -> not $ f x1 x2 x3 x4
18:52:40 <lambdabot> (((not .) .) .) . f
18:52:52 <Latro> ^is there a way to fully generalize this without directly using typeclasses?
18:53:04 <Latro> that is, to arbitrary arity
18:53:39 <dolio> No.
18:53:43 <turiya> monchrom: haa.. i did not think about termination, in my code, the i, j and n are >0
18:53:45 <Axman6> @let (f .:: g) a b c d = f (g a b c d)
18:53:46 <lambdabot>  Defined.
18:53:51 <Axman6> :t (.::)
18:53:52 <lambdabot> forall t4 t5 t t1 t2 t3. (t4 -> t5) -> (t -> t1 -> t2 -> t3 -> t4) -> t -> t1 -> t2 -> t3 -> t5
18:54:02 <kyagrd> Latro: template haskell???
18:54:13 <Axman6> :t not .:: unfedined
18:54:14 <lambdabot> Not in scope: `unfedined'
18:54:19 <Axman6> :t not .:: undefined
18:54:20 <Latro> that's just having the compiler write code for you
18:54:20 <lambdabot> forall t t1 t2 t3. t -> t1 -> t2 -> t3 -> Bool
18:54:22 <Axman6> heh
18:54:23 <Latro> not what I meant
18:54:39 <aristid> Axman6: why not just (.::) = fmap . fmap . fmap . fmap?
18:54:48 <Axman6> because that's far less clear
18:54:55 <monochrom> my u 1 1 1 has i,j,n>0.
18:54:56 <aristid> :t fmap . fmap . fmap . fmap
18:54:57 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
18:55:03 <aristid> Axman6: i  think it's more clear, actually.
18:55:37 <Jesin> umm
18:55:43 <Jesin> Latro
18:55:50 <Jesin> [22:02:39]	<Latro>	is there a way to fully generalize this without directly using typeclasses?
18:56:02 <Jesin> is there a way to fully generalize that WITH directly using typeclasses?
18:56:04 <Jesin> :p
18:56:05 <Latro> sure
18:56:15 <Latro> class Predicate where
18:56:18 <Latro> complement :: a->a
18:56:23 <Latro> instance Predicate Bool where
18:56:27 <Latro> complement = not
18:56:37 <Latro> instance Predicate (Predicate b => a -> b) where
18:56:40 <Latro> complement = complement .
18:56:51 <Jesin> use parens please
18:56:54 <Jesin> (complement .)
18:56:56 <Jesin> :p
18:57:00 <Latro> not necessary
18:57:19 <kyagrd> Latro: why not? it is a section
18:57:21 <Latro> it's on a right hand side on its own :p
18:57:39 <Jesin> :t map .
18:57:41 <lambdabot> parse error (possibly incorrect indentation)
18:57:49 <Latro> ...hmm
18:57:51 <Latro> :t (map .)
18:57:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f ([a] -> [b])
18:57:54 <Latro> touche
18:58:05 <turiya> monochrom: i made an error, it shud have been u i j n = (u (i-1) j (n-1)) + (u i (j-1) (n-1))
18:58:14 <Latro> ...someone made lambdabot's map into a functor thing
18:58:18 <monochrom> much better!
18:58:20 <Latro> oh wait no
18:58:22 <Latro> nvm
18:58:25 <Latro> that's from .
18:58:26 <Jesin> :t (.)
18:58:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:58:35 <Jesin> :t map
18:58:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:58:38 <monochrom> you mean someone made lambdabot's "." into a functor thing.
18:58:39 <Jesin> ...
18:58:57 <Jesin> having (.) be fmap when MAP ISN'T
18:58:59 <Jesin> what
18:59:01 <turiya> my actual function wa s a bit more complicated, i wanted to simplify and ended up with a non-terminating function :)
18:59:14 <Jesin> umm
18:59:18 <gwern> fast and loose is morally sound (except when it isn't)
18:59:26 <Jesin> turiya, could you write out the whole thing here?
18:59:39 <Jesin> that is, the full pattern-matching with base cases?
18:59:59 <Latro> anyway, yeah, complement = (complement .)
19:00:29 <turiya> Jesin: i havent written it in code, it is still in that research paper. i wanted to know if i can speed things up in C before i do so..
19:00:33 <Latro> now you can do like zipWithN (complement f) x1s x2s ... xns
19:01:25 <Jesin> u i j 0 = i*j
19:01:27 <Jesin> u i j n = (u (i-1) j (n-1)) + (u i (j-1) (n-1))
19:01:31 <Jesin> is the full definition then?
19:02:09 <turiya> for any one intersted: the paper is "Nonlinear total variation based noise removal algorithms" page 262
19:02:16 <turiya> Jesin: yes..
19:02:23 <Jesin> well
19:02:24 <Jesin> for speedup
19:02:28 <Jesin> I would recommend you do this
19:03:00 <Jesin> u i j 0 = i*j
19:03:02 <Jesin> u !i !j !n = (u (i-1) j (n-1)) + (u i (j-1) (n-1))
19:03:10 <Jesin> err
19:03:11 <Jesin> hmm.
19:03:14 <Jesin> actually
19:03:28 <parcs> what is the "proper" way of using Data.Binary with Network?
19:04:07 <Jesin> that's not quite right, umm
19:04:12 <parcs> i'm currently doing a lot of this: decode <$> L8.hGetContents handle and L8.hPut handle $ encode data_
19:04:49 <turiya> I dont have much idea on speeding things in Haskell
19:05:28 <accel> using ghc's native code generator backend; can Haskell beat C on anything other than eating up globs and globs of heap memory? (not meant to troll; seriously considering if there is even a _single_ case where haskell beats C)
19:05:47 <Axman6> parallelism
19:05:56 <Jesin> and list manipulation
19:05:58 <Jesin> :p
19:05:59 <edwardk> accel: we can do tail calls across functions because we don't use the c stack, and we have nice parallelism constructs
19:06:01 <Axman6> also, if you want speed, you should try using the llvm backend
19:06:08 <c_wraith> accel: ghc is *way* faster at concurrent tasks than C
19:06:31 <Axman6> accel: also, programs using gobs of memory if, sorry to say, your fault, not the compiler's
19:06:54 <Jesin> well
19:06:55 <accel> why is the llvm backend faster than ghc's code generator?
19:07:01 <c_wraith> Especially things like the thread ring benchmark.  Where last I saw, ghc was making everything else look slow.
19:07:11 <Jesin> it's your fault for not learning to force strictness
19:07:18 <accel> so dining philosophers, santa's elves, etc ... haskell beats all else
19:07:21 <Jesin> in places where that could be a problem
19:07:30 <Jesin> umm
19:07:39 <Axman6> accel: those aren't parallel programs, they're concurrent
19:07:47 <Jesin> dining philosophers is a problem you have to avoid in parallelism
19:08:08 <c_wraith> Axman6: GHC is awfully good at concurrency, too
19:08:12 <gwern> accel: have you looked at the shootout?
19:08:16 <edwardk> accel: because ghc doesn't really care about all the conventional imperative optimizations that llvm does. plus llvm only wins on some benchmarks (mainly those that really heavily use unboxed values)
19:08:17 <Axman6> c_wraith: indeed
19:09:27 <Jesin> accel, umm
19:09:32 <Jesin> [22:15:15]	<accel>	using ghc's native code generator backend; can Haskell beat C on anything other than eating up globs and globs of heap memory?
19:09:43 <Jesin> regarding the heap memory
19:09:43 <accel> yeah; taht's me
19:09:55 <Jesin> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
19:10:22 <locks> who uses haskell anyway
19:10:24 <Jesin> if you get a feel for when you have to explicitly force strict evaluation
19:10:34 <Axman6> we do
19:10:34 <Jesin> then you avoid eating memory like that
19:11:37 <Jesin> !!
19:11:57 <Jesin> accel, also: sorry, that article does not explain the solution correctly
19:12:09 <Jesin> seq does not solve the problems you would think it should solve
19:12:13 <accel> Jesin: real world haskell has a good solution
19:12:19 <accel> i like their use of foldl & !
19:12:29 <accel> really oepned my eyes to "ohhhhh; that's how you optimize haskell code"
19:12:41 <accel> I ordered the book just because I read that one chapter; and felt; I owe these guys $40.00
19:12:48 <Axman6> eh, there are much more interesting ways to optimise haskell code
19:12:56 <accel> Axman6: give me proof
19:13:01 <Axman6> just read Don Stewart's blog
19:13:42 <Jesin> or
19:13:48 <Axman6> things like stream fusion, which can produce code that's faster than C for the same job
19:14:00 <Jesin> that kind of thing yes
19:14:09 <Jesin> btw, is stream fusion in the default GHC distribution?
19:14:37 <Axman6> there are optimisations for it, but you should be using the package if you really need things to fuse
19:14:56 <Jesin> I think GHC uses foldr/build/augment and such by default...
19:15:02 <Axman6> yes
19:15:15 <accel> how do I check if ghci 6.12.1 has stream fusion?
19:15:40 <Axman6> check the dev commits i guess. that's a very old ghc though
19:15:49 <Jesin> also, I've noticed an apparent inconsistency in GHC.Base regarding this optimization
19:16:06 <Jesin> {-# INLINE [0] foldr #-}
19:16:08 <Jesin> -- Inline only in the final stage, after the foldr/cons rule has had a chance
19:16:54 <Jesin> but
19:17:04 <Axman6> if you want speed, you shouldn'y be using lists for tyhis sort of stuff anyway
19:17:14 <Veinor> something that I've always wondered: in interpreted languages, it's easy to write plugins that can be dynamically loaded, you just eval() them.
19:17:21 <Veinor> how do you do that in a compiled language like haskell?
19:17:25 <Jesin> -- The foldr/cons rule looks nice, but it can give disastrously
19:17:26 <Jesin> -- bloated code when commpiling
19:17:28 <Jesin> --      array (a,b) [(1,2), (2,2), (3,2), ...very long list... ]
19:17:29 <Jesin> -- i.e. when there are very very long literal lists
19:17:31 <Jesin> -- So I've disabled it for now.
19:17:32 <Jesin> :p
19:17:33 <jmcarthur> i don't even consider strictness annotations to be optimizations
19:17:34 <shachaf> Veinor: Usually badly.
19:17:40 <jmcarthur> to me they are fundamental to the meaning of the code
19:17:58 <accel> besides infinite lists; when should you not use strictness?
19:18:22 <shachaf> jmcarthur: Do you consider using a better algorithm to be an optimization?
19:18:44 <jmcarthur> shachaf: i'm speaking on a lower level than choice of algorithm
19:18:48 <Axman6> accel: when you need laziness
19:18:56 <tg_> I asked this earlier in #-blah, and was told to ask here:
19:18:57 <tg_> [20:16] <tg_> If I wanted something along the lines of: the experience of ghci decorated with a more(visually) expressive interface (think Mathematica or MathML or inline haskell++), what tools are farthest along this pipedream?
19:19:04 <dolio> Strictness annotations are about the meaning of code.
19:19:11 <dolio> It just happens that they improve performance sometimes.
19:19:15 <tg_> [20:17] <tg_> or, starting from another direction, an interactive version of gitit
19:19:18 <jmcarthur> shachaf: that is, the fact that changing strictness changes the algorithm demonstrates that strictness is semantically meaningful
19:19:44 <shachaf> Strictness annotations are about performance. It just happens they improve the meaning of the code sometimes.
19:20:00 * shachaf 's code is more meaningful than your code.
19:20:08 <accel> isn't the whole point of laziness that, up to infinite recursion, strict vs lazy does not change the result?
19:20:22 <tg_> accel: that's the point of pure functions
19:20:22 <Axman6> no
19:20:26 <tg_> not laziness
19:20:33 <jmcarthur> accel: ah, but strict vs. lazy *can* change the result (termination)
19:20:56 <Jesin> "infinite recursion" is not something to be brushed off lightly
19:21:27 <Jesin> and is not as easy to detect as it sounds
19:21:37 <Jesin> (halting problem  :P )
19:21:38 <tg_> easy to define, hard to detect :o
19:21:54 <shachaf> Jesin: Infinite recursion is easy to detect in plenty of languages.
19:22:11 <Jesin> shachaf: not in every case in any language that's turing-complete
19:22:22 <shachaf> Jesin: BASIC, for instance.
19:22:28 <Jesin> XD
19:22:32 <Jesin> easy
19:22:37 <Jesin> with all those GOTOs?
19:22:39 <tg_> My abstraction of laziness was always something like: you have a language feature that allows your code to, at well-defined points, stop and consider how execution should continue
19:22:40 <accel> I said 'up to infinite recursion' <-- which implies termination
19:22:45 <shachaf> Jesin: That's not recursion.
19:22:57 <tg_> is that innaccurate?
19:22:58 <jmcarthur> shachaf: strictness annotations are about more than performance. they can mean the difference between termination and nontermination. i'd say that is meaningful beyond mere optimizations
19:22:59 <tg_> s/inn/in/
19:23:17 <jmcarthur> it just happens that they can improve performance ^_^
19:23:24 <jmcarthur> when used appropriately
19:23:26 <Jesin> accel: I think that strictness produces _|_ in some cases where laziness doesn't
19:23:29 <shachaf> jmcarthur: Laziness can sometimes cause non-practical-termination. :-)
19:23:33 <Jesin> and vice versa simply because of stack overflow
19:23:33 <jmcarthur> shachaf: right
19:23:35 <dolio> The definition of strictness is f _|_ = _|_, which is about the denotation of a function. When people use strictness annotations, it's because functions with certain denotations optimize better than functions with others.
19:23:56 <Axman6> accel: laziness can give you advantages like deforestation. if the compiler can see that a datascructure doesn't actually ever need to exist, it won't actually create the data, and everything will be turned into functions
19:23:56 <jmcarthur> denotation = meaning
19:24:02 <Jesin> but in cases where neither results in _|_, they give the same answer
19:24:07 <tg_> dolio: so the definition of laziness is f _|_ = thunk?
19:24:31 <dolio> Laziness is an evaluation strategy.
19:24:41 <dolio> A non-strict function is one such that f _|_ /= _|_.
19:24:42 <jmcarthur> tg_: f is strict if f _|_ = _|_. it is non-strict otherwise
19:25:07 <jmcarthur> tg_: lazy evaluation is a type of non-strict evaluation in which no expression is evaluated more than once
19:25:08 <Jesin> :t (+) undefined
19:25:09 <lambdabot> forall a. (Num a) => a -> a
19:25:13 <Jesin> :t (+) undefined undefined
19:25:15 <lambdabot> forall a. (Num a) => a
19:25:35 <Jesin> eh.
19:25:40 <Axman6> like say you have a binary tree produced by: foo i 0 = Leaf i; foo i n = Node i (foo (-i) (n-1)) (foo (i+1) d-1), and you have a consuming function: eat (Leaf x) = x; eat (Node x l r) = x + eat l + ear r, the compiler can see that the tree never needs to exist
19:26:49 <dolio> A better example of an operational annotation is par. par x y denotes the same thing as y, but it has different operational implications.
19:26:56 <jmcarthur> tg_: i wasn't clear on non-strict *evaluation* though. that's when arguments are not evaluated unless needed
19:27:05 <gwern> Veinor: you know, dons's thesis is on eval() in haskell
19:27:11 <tg_> jmcarthur: I was wondering how to ask for clarification
19:27:12 <gwern> you could read it
19:27:40 <jmcarthur> tg_: non-strict evaluation essentially preserves the non-strictness of a function, you could say
19:27:50 <jmcarthur> g2g
19:27:55 <tg_> jmcarthur: ciao
19:28:06 <Veinor> gwern: wat
19:28:16 <dolio> Non-strict evaluation strategies may evaluate arguments when they're not needed.
19:28:29 <dolio> They just have to allow some non-strict functions.
19:29:18 <gwern> Veinor: there are a lot of approaches
19:29:31 <dolio> For instance, you can evaluate 'f x y z' by spinning off threads to evaluate x, y and z, even if f ultimately ignores them.
19:30:06 <dolio> Or evaluate x, y and z first, but only for up to a certain length of time, before giving up and just going into f first.
19:31:49 <Jesin> http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel.html
19:36:43 <accel> stream fusion wasn't invnted until 2007 ?
19:36:46 <accel> the idea looks kinda simple
19:37:09 <monochrom> I call that crazy evaluation so it rhymes with lazy evaluation :)
19:39:18 <Axman6> accel: it's an optimisation that you can only easily apply in a pure language
19:48:52 <drbean> Why doesn't the HTML documentation that comes with ghc have a link to the source?
19:55:20 <poincare101> drbean: why is B is the second letter of the alphabet?
19:56:47 <geheimdienst> drbean, good question, i've sometimes wished for it myself. is the documentation on the web better for you? (searchable with hayoo or hoogle)
19:56:50 <geheimdienst> @where hayoo
19:56:50 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
19:58:53 <tensorpudding> proving the contrapositive is not kosher in intuitionist logic, is it?
20:00:09 <dolio> What do you mean by that?
20:00:26 <dolio> P -> Q implies Not Q -> Not P, but not vice versa.
20:00:39 <monochrom> actually my ghc comes with doc with links to source code
20:01:28 <tensorpudding> i guess I was asking if (not Q -> not P) -> (P -> Q) was valid
20:01:31 <geheimdienst> monochrom: probably has to do with how good a job your distro's packager did ...
20:02:04 <tolkad> If I write an instance involving pattern matching on any integral type, will this be forced to be implemented as a single function forcing the use of the slow version of fromIntegral in ghc haskell?
20:04:17 <drbean> @where hoogle
20:04:17 <lambdabot> http://haskell.org/hoogle
20:04:28 <Jesin> nah, in intuitionist logic, not p is basically sugar for p -> _|_
20:04:36 <tolkad> like: « class CheckTupleLength a b where { checkTupleLength :: a -> b -> Bool }; instance Integral c => CheckTupleLength (a, b) c where { checkTupleLength _ 2 = True; checkTupleLength _ _ = False } »
20:05:04 <tolkad> will that instance be forced to use the slow version of fromIntegral that converts to the arbitrary precision type?
20:05:09 <dolio> You can do the same in classical logic.
20:05:29 <Latro> need to define what you mean by ->
20:05:36 <geheimdienst> drbean: be aware that hoogle searches not many packages ... i usually prefer hayoo, even if it looks more cluttered
20:05:44 <Latro> do you mean |-
20:05:44 <Latro> ?
20:06:50 <tolkad> Jesin: nah, not p is sugar for (p NAND p)
20:07:57 <tolkad> I'm asking about the fromIntegral thing because I learned of the existence of SPECIALIZE which implies ghc will not normall specialize instance functions for specific types
20:08:16 <Jesin> tolkad: in intuitionistic logic?
20:08:25 <tolkad> I'm wondering if this implication is correct and if that means that the polymorphic general version of fromIntegral will have to be used
20:08:29 <tolkad> Jesin: no in ghc haskell
20:08:35 <accel> http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template <-- is it possible to do expression templates in haskell?
20:08:40 <tolkad> Jesin: oh you mean the (p NAND p) thing
20:08:42 <Jesin> yeah
20:08:55 <tolkad> Jesin: no not in intuitionistic logic
20:09:23 <tolkad> Jesin: but I don't understand why you want everything to be intuitive
20:10:47 <Jesin> umm
20:11:14 <Jesin> I was responding to a question
20:11:20 <tolkad> oh
20:11:23 <accel> http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template <-- is it possible to do expression templates in haskell?
20:11:24 <Jesin> [23:08:42]	<tensorpudding>	proving the contrapositive is not kosher in intuitionist logic, is it?
20:11:26 <Jesin> [23:09:58]	<dolio>	What do you mean by that?
20:11:27 <tolkad> I was just saying stuff
20:11:27 <Jesin> [23:10:15]	<dolio>	P -> Q implies Not Q -> Not P, but not vice versa.
20:11:29 <Jesin> [23:11:17]	<tensorpudding>	i guess I was asking if (not Q -> not P) -> (P -> Q) was valid
20:11:30 <Jesin> about intuitionist logic
20:11:33 <Jesin> :p
20:11:34 <accel> http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template <-- is it possible to do expression templates in haskell?
20:11:40 <Axman6> accel: ah, you're a C++ programmer, everything makes more sense now ;)
20:11:46 <Jesin> and in that case, NOT P is sugar for P -> _|_
20:11:53 <accel> Axman6: crap, are C++ programmers hunted here?
20:11:56 <Jesin> and if you prove _|_ your system is broken
20:12:03 <Latro> well
20:12:03 <Axman6> accel: well, you
20:12:05 <Latro> that one, anyway
20:12:18 <Axman6> you'd have a very different view on programming
20:12:21 <Latro> though, wait, what is _|_, just the contradictory statement?
20:12:29 <drbean> monochrom's ghc with the doc which links to the source is from which distro?
20:12:32 <Jesin> basically yes
20:12:40 <Latro> then that statement is too general
20:12:43 <Latro> paraconsistent :p
20:12:49 <Jesin> Latro
20:12:54 <Jesin> I specified intuitionist logic!
20:13:01 <Latro> "if you prove _|_ your system is broken"
20:13:02 <Jesin> at least twice!
20:13:07 <accel> http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template <-- is it possible to do expression templates in haskell?
20:13:08 <Latro> sounds fully general to me
20:13:09 <Jesin> I meant your axiom system
20:13:13 <monochrom> from ghc download page such as http://www.haskell.org/ghc/download_ghc_6_12_3
20:13:16 <Axman6> accel: please stop asking!
20:13:19 <Axman6> ffs
20:13:29 <accel> it's not possible?
20:13:45 <Axman6> i have no idea what it does
20:13:56 <monochrom> it is possible to do expression templates in haskell. here is how: just write normal expressions.
20:13:59 <tolkad> oh. I had a question about logic. any consistent axiomatic system that has recursively enumerable theorems is not capable of proving all facts about the natural numbers
20:14:01 <Axman6> but, EDSL's are extremely common
20:14:05 <Axman6> in hasdkell*
20:14:07 <Axman6> -d
20:14:47 <Axman6> accel: from the description, you can get what it says using higher order functions
20:14:48 <monochrom> To see why: "to create DSEL" done. "lazy evaluation" done. "pass expression not result to function" done.
20:15:01 <tolkad> is there a consistent axiomatic system with a countable. non-recursively enumerable set of theorems that is capable of proving all facts about the natural numbers?
20:15:30 <Latro> that'd be a weaker natural numbers
20:15:42 <monochrom> example: main = forever (putStrLn "hi").  forever is defined by: forever m = m >> forever m.  Works.
20:15:46 <tolkad> how can you have a weaker set of natural numbers
20:15:52 <Latro> your axioms define the natural numbers
20:16:08 <Jesin> umm
20:16:10 <Jesin> Latro
20:16:14 <Latro> an axiom system where all theorems about the natural numbers are provable has fewer true statements
20:16:16 <Jesin> non-recursively-enumerable
20:16:29 <Latro> wait...that's an ambiguous term
20:16:48 <Latro> are theorems that aren't recursively enumerable allowed, or are some recursively enumerable theorems forbidden
20:17:05 <Jesin> I think he's allowing theorems that cannot be recursively enumerated
20:17:10 * hackagebot filestore 0.4.0.1 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.4.0.1 (JohnMacFarlane)
20:17:18 <Jesin> <tolkad> is there a consistent axiomatic system with a countable. non-recursively enumerable set of theorems that is capable of proving all facts about the natural numbers?
20:17:22 <tolkad> the set of theorems is not recursively enumerable
20:17:23 <Jesin> hmm
20:17:25 <Latro> then I don't think there's a sensible notion of "proof" is there?
20:17:26 <Jesin> well
20:17:30 <tolkad> the set of theorems must be countable
20:17:43 <Jesin> tolkad: in most systems of logic
20:17:48 <Latro> countable but not recursively enumerable, hmm
20:17:52 <Jesin> the set of formulass
20:17:54 <Jesin> is countable
20:17:56 <Jesin> :p
20:17:58 <monochrom> also you don't have to use higher-order functions. (you can.) for example forever is not higher-order, m is not (necessarily) a function.
20:18:47 <Jesin> if your set of formulas consists of arbitrarily-long finite strings of symbols taken from a finite alphabet
20:19:02 <tolkad> I'm asking because I read that the first incompleteness theorem applies to axiomatic systems whose set of theorems are recursively enumerable
20:19:09 <Axman6> accel: from what I can tell, that Expression template stuff is exactly the same as what we do in haskell all the time, without thinking. it only feels powerful in C++ because you have to put a lot of work into it, and it's still less powerful than the equivalent haskell
20:19:12 <Jesin> then it is countable
20:19:36 <tolkad> it would be a stronger statement to say that it applies to axiomatic systems whose set of theorems are countable
20:19:54 <Jesin> yes, and I don't think that statement is made
20:19:56 <Jesin> :p
20:20:15 <Jesin> basically, take the language of Peano arithmetic
20:20:20 <accel> Axman6: what are good examples of haskell EDSLs ?
20:20:27 <Jesin> the set of formulas in that language is countable
20:20:47 <Jesin> if you take the set of axioms to be "the set of true statements"
20:20:53 <Latro> .......
20:20:56 <Latro> CIRCULARITY
20:20:56 <Axman6> accel: accelerate, atom, probably hundreds of others
20:21:04 <Latro> :(
20:21:17 <Jesin> then that very well may be consistent
20:21:17 <Latro> there aren't true statements without already having axioms, jesin
20:21:28 <Jesin> Latro, I agree with you there
20:21:41 <Latro> hmm, actually, maybe not
20:21:43 <Jesin> however that's just my opinion
20:21:44 <Latro> implications can be true
20:21:45 <Jesin> :P
20:21:59 <Jesin> see, the thing is
20:22:01 <Jesin> [23:31:07]	<Latro>	there aren't true statements without already having axioms, jesin
20:22:16 <Jesin> ^ you can't claim that statement is true without taking as an axiom or deriving it from axioms
20:22:23 <Latro> ...
20:22:27 <Jesin> :P
20:22:35 <Latro> if you don't take that as an axiom, then what the hell are you doing
20:22:58 <Jesin> "there is absolute truth but we will never know it", perhaps?
20:23:01 <Latro> though, again, it's blurry whether or not statements of the form p |- q are "statements"
20:23:04 <tolkad> the set of axioms is a subset of the set of true statements
20:23:05 <monochrom> haskell IO is already an EDSL actually
20:23:05 <monochrom> many libraries on hackage are EDSLs. parser libs, serialization libs, pretty-printer libs...
20:23:06 <accel> is there a language like haskell; exceit strict rather than lazy?
20:23:27 <Latro> I forget...maybe Miranda?
20:23:28 <Latro> Clean?
20:23:32 <dolio> No.
20:23:39 <dolio> Those are both lazy.
20:23:42 <tolkad> Jesin: that's not an example of an axiomatic system without a recursively enumerable set of theorems
20:23:45 <Axman6> timber?
20:23:47 <Latro> not curry
20:23:47 <Axman6> ocaml?
20:23:53 <accel> ocaml's not pure
20:23:56 <Jesin> tolkad, umm
20:23:57 <Latro> ocaml is not all that much like haskell
20:24:03 <Jesin> the thing about not being recursively enumerable
20:24:03 <Latro> purity is a trivial point
20:24:04 <ivanm> disciple?
20:24:07 <Latro> type inference is another
20:24:09 <Jesin> is YOU CAN'T GIVE AN EXAMPLE
20:24:11 * hackagebot gitit 0.7.3.9 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.9 (JohnMacFarlane)
20:24:12 <Jesin> :P
20:24:23 <tolkad> Jesin: you can give an example of a non-recursively enumerable set -_-
20:24:29 <monochrom> "like haskell" requires non-strictness in a strong sense, because otherwise a lot of other features of haskell wouldn't make sense.
20:24:39 <tolkad> Jesin: here, I'll do it: the set of non-halting turing machines
20:24:48 <Jesin> oh fine
20:24:49 <Latro> yeah
20:24:50 <accel> monochrom: why?
20:24:50 <Latro> gimme one
20:24:55 <Jesin> well
20:24:56 <Latro> you can give me the set
20:24:58 <accel> monochrom: why can't you hae monads, type clases, ... without laziness?
20:24:59 <Latro> give me an element of it
20:25:14 <Latro> monads aren't a feature, per se
20:25:21 <tolkad> Latro: main = forever (return ())
20:25:43 <Latro> things are implemented using them, but they themselves aren't that fancy
20:25:45 <Latro> and fair enough
20:25:48 <monochrom> ok time for you to define "like haskell". because merely type class is not my idea of "like haskell".
20:26:10 <tolkad> Latro: you can recursively enumerate any finite subset of the set of non-halting turing machines
20:26:23 <monochrom> and "..." won't do
20:26:35 <tolkad> Latro: and an infinite number of non-finite subsets
20:26:54 <accel> I want haskell without laziness. Does such a langauge exist?
20:27:11 <Axman6> maybe you should try and understand how to use laziness
20:27:22 <Jesin> hmm
20:27:24 <Axman6> rather than complaining about it because you don't get it
20:27:24 <Latro> what issue do you have with laziness
20:27:25 <Jesin> [23:24:50]	<tolkad>	is there a consistent axiomatic system with a countable. non-recursively enumerable set of theorems that is capable of proving all facts about the natural numbers?
20:27:36 <Latro> incidentally
20:27:38 <Latro> "is there a consistent"
20:27:41 <Latro> is wrong
20:27:44 <Latro> "is there a provably consistent"
20:27:45 <ivanm> not haskell, but they're about to start talking about multicore/parallel programming in erlang, scala, etc. here: http://lca2011.linux.org.au/stream/N515-QUT%28AU%29.html
20:27:47 <Latro> is probably what you want
20:27:59 <Jesin> but, Latro
20:28:01 <Latro> because there's probably a consistent one with recursively enumerable sets of theorems
20:28:12 <Latro> the second incompleteness theorem just makes it impossible to prove that
20:28:19 <Jesin> "provable" gives back the recursively enumerable thing, I think
20:28:32 <Jesin> umm, Latro
20:28:36 <Latro> umm, then we're back to throwing up our hands?
20:28:37 <Jesin> [23:37:51]	<Latro>	because there's probably a consistent one with recursively enumerable sets of theorems
20:28:43 <Jesin> the FIRST incompleteness theorem
20:28:45 <Jesin> says there isn't.
20:28:51 <Latro> no consistent one?
20:28:55 <Latro> oh, that covers all the facts
20:28:56 <Latro> nvm
20:29:08 <Latro> missed all the qualifiers, my bad
20:29:27 <tolkad> accel: {-# RULES "lol" forall a. a = unsafePerformIO (evaluate a)  #-}
20:29:35 <tolkad> ^^ try dat
20:29:35 <Axman6> heh
20:29:38 <Jesin> ...
20:29:38 <Latro> .....AGH
20:29:40 <Jesin> O.o
20:29:48 <lpjhjdh> can parsec handle utf8?
20:29:54 <Axman6> pretty sure that's guaranteed to be pure
20:30:14 <Axman6> lpjhjdh: i'd be surprised if it couldn't, since haskell strings are at least urf-8
20:30:41 <Axman6> tolkad: o'd quite like to see what happens when you do that
20:30:51 <lpjhjdh> Axman6: ah right, ucs4?
20:31:12 <tolkad> Axman6: I'll try it on hello world
20:31:28 <Axman6> i don't believe it's ucs4...
20:32:14 <tolkad> Axman6: aww it says it has to have a function application on the LHS
20:32:17 <monochrom> My "like haskell" means the use of pure functions (data are immutable) does not lead to retardedly inefficient algorithms (just slightly inefficient). This requires non-strictness, probably also laziness.
20:33:21 <accel> monochrom: how does pure functions imply non-strictness?
20:33:31 <monochrom> I didn't say that.
20:33:36 * BMeph prefers not eating his hands, thus avoiding the need to throw them up later!
20:33:45 <accel> how does not retardedl inefficient algorithms imply non strictness?
20:33:46 <tolkad> monochrom: couldn't we just use ST instead?
20:33:50 <Jesin> ...lol...
20:34:04 <monochrom> ST uses mutable data.
20:34:04 <ivanm> I lied, the guy in the talk just mentioned haskell
20:34:10 <tolkad> monochrom: yeah
20:34:33 <tolkad> If I write an instance involving pattern matching on any integral type, will this be forced to be implemented as a single function forcing the use of the slow version of fromIntegral in ghc haskell?
20:34:34 <tolkad> like: « class CheckTupleLength a b where { checkTupleLength :: a -> b -> Bool }; instance Integral c => CheckTupleLength (a, b) c where { checkTupleLength _ 2 = True; checkTupleLength _ _ = False } »
20:34:45 <dolio> @google more-haste-less-speed lazy-versus-eager
20:34:47 <lambdabot> http://portal.acm.org/citation.cfm?id=969871
20:34:47 <lambdabot> Title: More haste, less speed: lazy versus eager evaluation
20:35:03 <monochrom> there are reasons such as concurrency so that I really prefer immutable data so there is no crazy locking considerations.
20:36:19 <monochrom> dolio's @google answers accel's latest ill-phrased question. and yes, for the record I didn't say (not retardedl inefficient algorithms imply non strictness) either.
20:37:10 <tolkad> rather than using CPP in haskell you can just use RULES. they're like macros in haskell!
20:38:30 <ivanm> tolkad: I've never heard of RULES being considered as a macro
20:39:28 <edwardk> heya ivanm
20:39:35 <kuffaar> I call all {-# stuff macros
20:39:35 * ddarius should make a Turing machine in RULE pragmas.
20:39:46 <tolkad> {-# RULES "something" forall a. max a b = if a > b then a else b  #-}
20:39:49 <kuffaar> You should make a Turing machine out of wood
20:39:56 <Axman6> they're pragmas, not macros
20:39:57 <ivanm> hey edwardk 
20:40:08 <kuffaar> Oh yeah, I actually call them pragmas, not macros
20:40:20 <ivanm> kuffaar: nah, lego turing machine is cooler
20:40:26 <kuffaar> Axman6 with CPP you get macros though, right? :)
20:40:31 <Axman6> yes
20:40:34 <edwardk> as for why i'm not using MTL, i just don't need it for the portions i'm providing, i was going to add a graphs-fd and graphs-tf if i found i needed the instances.
20:40:43 <ivanm> edwardk: *nod*
20:40:52 <edwardk> and it keeps me separated into haskell 98 components and everything else
20:40:58 <ivanm> edwardk: I just figured it made sense since you were defining ask, etc.
20:41:10 * BMeph prefers "max a b = div (a + b + abs (a - b)) 2"...
20:41:12 <ivanm> I hate to tell you this, but I don't think any of that library is H98 :p
20:41:29 <edwardk> oh yeah
20:41:32 <edwardk> type families =)
20:41:34 <edwardk> forgot
20:41:36 <ddarius> BMeph: How do you divide strings?
20:41:37 <edwardk> heh
20:41:46 <aristid> edwardk: then you might as well go all the way ;)
20:41:51 <ivanm> edwardk: so monads-tf makes the most sense then
20:42:02 <edwardk> reflex from other projects. anyways, avoid mtl avoids me having to care if they have a post 2.0 mtl installed and usable by all their other dependencies
20:42:06 <tolkad> wait I thought transformers was the current fad?
20:42:07 <aristid> ivanm: huh? no :)
20:42:10 <tolkad> what's monads-tf?
20:42:22 <aristid> tolkad: monads-tf uses transformers
20:42:22 <ivanm> aristid: he's using type families; how does mtl make more sense than monads-tf?
20:42:25 <edwardk> ivanm: no. monads-tf will never be used by my code whether i use tyope families or not until it moves out of the namespace of the existing mtl
20:42:28 <monochrom> monads-tf uses type families
20:42:29 <BMeph> ddarius: Carefully; some of them are Super! ;þ
20:42:32 <aristid> ivanm: it's the standard!
20:42:33 <ivanm> edwardk: fair enough
20:42:39 <ivanm> aristid: no it isn't
20:42:40 <edwardk> ivanm: it has the same problem your fgl replacement would
20:42:54 <ivanm> aristid: if it isn't in an actual report, it isn't a standard IMHO!
20:43:03 <Jesin> [23:43:11]	<accel>	monochrom: how does pure functions imply non-strictness?
20:43:05 <Jesin> [23:43:36]	<accel>	how does not retardedl inefficient algorithms imply non strictness?
20:43:08 <Jesin> they don't
20:43:10 <Jesin> but
20:43:29 <ivanm> edwardk: let's not get into that again :p
20:43:32 <edwardk> ivanm: mtl is used by large swathes of hackage including MANY dependencies of my own packages. monads-tf is needlessly incompatible and therefore useless
20:43:53 <Jesin> the idea there was that out of {pure functional, efficient, strict}, you can't have all 3
20:43:57 <edwardk> if it was Control.Monad.Family.Foo or whatever it'd work fine, and could co-exist with mtl, and transformers
20:44:02 <monochrom> you see I am not alone in insisting that what I say be not mutilated
20:44:05 <tolkad> edwardk: package qualified instances are the best. especially since you can cause segfaults using Data.Typeable
20:44:11 <aristid> ivanm: and thanks to mtl 2.0, monads-fd and mtl are compatible now.
20:44:31 <edwardk> and i'd freely support both, in fact that was what was discussed at one point on the libraries mailing list but i think the asymmetry was galling and it somehow got stalled
20:44:51 <ivanm> edwardk: dammit, you made me miss the guy talking about haskell!
20:45:01 <edwardk> tolkad: i like having the illusion of portability. that will never be implemented by jhc, and its very much tied to ghc internals that it works
20:45:01 <Axman6> oh no :(
20:45:07 <Axman6> ivanm: topic?
20:45:12 <tolkad> edwardk: you could use CPP
20:45:20 <edwardk> aristid: no they aren't
20:45:31 <ivanm> Axman6: different langauges for multicore and parallel programming
20:45:36 <Axman6> ah nice
20:45:39 <edwardk> er
20:45:42 <edwardk> monads-fd and mtl are
20:45:44 <ivanm> actually, he just started: he was talking about something else with the haskell slide up :s
20:45:47 <edwardk> but monads-tf isn't
20:45:50 <tolkad> edwardk: thens someone can just put I_WANT_MOANDS_TF in their cabal file
20:45:52 <Axman6> i've missed so much interesting stuff while i've been here :(
20:46:00 <aristid> edwardk: i talked about monads-fd and mtl :P
20:46:01 <ivanm> Axman6: I gave the streaming link up before
20:46:04 <aristid> edwardk: :P :P
20:46:16 <Axman6> i'm at work though :(
20:46:19 <edwardk> tolkad: no, because cabal projects can't depend on another cabal project 'with a particular flag active' 
20:46:21 <ivanm> http://lca2011.linux.org.au/stream/N515-QUT%28AU%29.html
20:46:24 <Axman6> and i have no sound
20:46:31 <edwardk> so you can't use flags for conditional module compilation safely
20:46:32 <ivanm> Axman6: videos will be up later
20:46:36 <Axman6> excellent
20:46:47 <edwardk> in fact the only thng you can really safely use them for is toggling off executables
20:46:50 <Axman6> though, ym MBP's GPU died the other day, so i've got no laptop at the moment either
20:46:54 <tolkad> edwardk: you could upload two versions of the package, one with the flag enabled, one without
20:47:03 <Axman6> bloody 8600m's
20:47:04 <ivanm> edwardk: or alternate implementations with compatible APIs
20:47:17 <aristid> edwardk: and this only because cabal doesn't support build tool dependencies :)
20:47:50 <edwardk> ivanm: hence why i have a common core that ignores all of those issues, and the ability to later graft on a package for graphs-fd that provides it for the few folks who care
20:47:50 <ivanm> aristid: you mean cabal-install?
20:47:57 <ivanm> edwardk: *nod*
20:48:08 <tolkad> edwardk: just upload all possible flag combinations as different packages
20:48:18 <ivanm> eh, the haskell bit was mainly "it's pure, it's different, it's clear, it's kinda cool"
20:48:19 <accel> w/quit
20:48:40 <edwardk> ivanm: most folks use these things monomorphically, and what transformers has shown us, is that most class vendors just need the data types, not the classes
20:48:41 <ivanm> edwardk: I still find it weird that you basically explicitly re-define a Reader instance at the top-level though ;-)
20:48:42 <aristid> ivanm: yeah, i mean cabal-install.
20:48:47 <geheimdienst> it's helpful! it tells you when your program is broken *before* running it!
20:49:00 <edwardk> ivanm: look at transformers. there is a monomorphic 'ask' in Control.Monad.Trans.Reader
20:49:01 <ivanm> geheimdienst: what is?
20:49:06 <ivanm> edwardk: true
20:49:25 <geheimdienst> i meant haskell, you said it's pure and clear and cool
20:49:41 <dibblego> is there a preferred approach for a data type and its monadic version? i.e. write them both separately or perhaps write the monadic version and the other in terms of the monadic version and Identity, perhaps something else?
20:50:07 <aristid> dibblego: monadic version?
20:50:09 <edwardk> dibblego: i've adopted the transformers approach of building just the transformer and defining the other in terms of it
20:50:10 <tolkad> geheimdienst: it's more pure and more clear and more clear than other most other languages with a mature community and compiler
20:50:15 <tolkad> more cool*
20:50:24 <dibblego> edwardk, so like Control.Monad.State ?
20:50:28 <ivanm> dibblego: the guy talking about different FP languages seems to agree with you about scala, etc.: "It's not verbose when compared with Java..." :p
20:50:37 <edwardk> type Yoneda = YonedaT Identity; newtype YonedaT f a = YonedaT { runYonedaT :: forall r. (a -> r) -> f r }
20:50:54 <dibblego> ivanm, I didn't think there is any contention, except among a few argumentum ad ignorantiams
20:51:01 <ivanm> dibblego: heh
20:51:03 <tolkad> geheimdienst: there are plenty of places where haskell is impure
20:51:11 <aristid> type Reader = (->)
20:51:18 <horms> Hi Axman6
20:51:18 <tolkad> geheimdienst: but you can avoid them if you want to
20:51:24 <dibblego> I've been writing Haskell for months, back on to Scala today
20:51:25 <Axman6> hey
20:51:32 <geheimdienst> yeah, well, it's a good step up from other languages where *everything* is impure
20:51:34 <Axman6> horms: i believe you're in the same room as ivanm 
20:51:44 <ivanm> >_>
20:52:00 <horms> ivanm: are you somewhere in Brisbane?
20:52:03 <ivanm> edwardk: if I was to try adding in manipulation classes, how granular would you want them?
20:52:08 <ivanm> horms: linux.conf.au
20:52:12 <horms> haha
20:52:13 <ivanm> so yes ;-)
20:52:13 <Axman6> heh
20:52:15 <edwardk> aristid: i keep the instances for (->) around, but i define equivalents. like type Traced m = TracedT m Identity; newtype TracedT m w a = TracedT { runTracedT :: w (m -> a) } 
20:52:26 <Axman6> you're both at the parallel... languages? talk right?
20:52:27 <ivanm> and here's juhp!
20:52:31 <edwardk> ivanm: when in doubt i've been modeling off of the boost graph library
20:52:32 <horms> yes
20:52:41 <ivanm> juhp: are you in the parallel miniconf as well?
20:52:44 <tolkad> If I write an instance involving pattern matching on any integral type, will this be forced to be implemented as a single function forcing the use of the slow version of fromIntegral in ghc haskell?
20:52:44 <tolkad> like: « class CheckTupleLength a b where { checkTupleLength :: a -> b -> Bool }; instance Integral c => CheckTupleLength (a, b) c where { checkTupleLength _ 2 = True; checkTupleLength _ _ = False } »
20:52:50 <aristid> edwardk: TracedT is comonadic?
20:52:54 <ivanm> edwardk: so you'd want me to follow that?
20:52:56 <horms> There is a confirmed Haskell sighting at linux.conf.au
20:52:58 <juhp> ivanm: yeah :)
20:53:10 <edwardk> ivanm: with the Bfs/Dfs etc monads being monadified versions of the visitor patterns from boost
20:53:12 <aristid> edwardk: or no
20:53:22 <edwardk> aristid: yeah, its 'cowriter'
20:53:22 <ivanm> juhp: OK, there's at least 3 of us now then...
20:53:25 <ddarius> edwardk: C# and C++.  Next you'll be looking to PHP for inspiration.
20:53:35 <edwardk> ddarius: =)
20:53:38 <aristid> edwardk: but with Identity it converges to Reader?
20:53:39 <ivanm> horms: I talked about Haskell yesterday as well! (only in a lightning talk though)
20:53:49 <edwardk> ddarius: i'm anything but a purist ;)
20:53:53 <tolkad> horms: looks like the webserver is python
20:53:56 <horms> ivan: nice
20:53:57 <edwardk> aristid: exactly
20:54:00 <horms> ivanm: nice
20:54:20 <edwardk> aristid: in general the comonad transformers will put the comonad they transform in a different place than the monad transformer will
20:54:23 <ivanm> edwardk: any particular reason for following their model?
20:54:41 <edwardk> ivanm: its successful, and serves as a straw man in the absence of a more thought out plan
20:54:53 <edwardk> plus, it wasn't fgl ;)
20:54:56 <aristid> edwardk: how many of them converge with a different Monad for Identity?
20:55:03 <ivanm> @slap edwardk 
20:55:04 <lambdabot> I don't perform such side effects on command!
20:55:04 <ivanm> :p
20:55:08 <edwardk> and it was isomorphic to what i converged to by moving my comonadic graph library over to monads
20:55:09 <ivanm> lambdabot: grrrrr.....
20:55:13 <Jesin> lol
20:55:20 <geheimdienst> lambdabot is lazy
20:55:24 <edwardk> aristid: well, note the instance for TracedT requires a monoid on the environment
20:55:32 <aristid> ivanm: why does fgl hard-code Node = Int (or was it Integer?)?
20:55:49 <ivanm> aristid: history
20:55:56 <aristid> edwardk: environment = m?
20:56:00 <ivanm> aristid: changing that is part of the plan
20:56:02 <BMeph> That's one place where Haskell has spoiled me - purity. I'm so shocked when I'm reading through a program and run into some 'net-accessing piece, because the types didn't warn me... :(...
20:56:34 <aristid> ivanm: you want to completely rework fgl?
20:56:40 <ddarius> edwardk: Luckily, I like both C# and C++.  Not PHP though.
20:56:42 <ivanm> aristid: yup
20:56:49 <edwardk> Cowriter: Monoid m => m -> a, Reader: e -> a,  Writer: Monoid m => (m, a), Coreader: (e, a)
20:57:17 <aristid> edwardk: oh, the beautiful symmetry!
20:57:21 <edwardk> aristid: thats why he is somewhat annoyed at me for trompling all over his graphs =)
20:57:25 <ivanm> aristid: actually, I was going to write a new lower-level graph library, but haven't released anything despite talking about it for a couple of years and edwardk stole my thunder by stealing the namespace I was going to use :@
20:57:43 <aristid> ivanm: edwardk is evil like that.
20:57:51 <Axman6> ddarius: what is there to like about C++ anyway? i decided i have a go at picking it up again the other day, and got horrified pretty quickly by some of the "features" of the language
20:57:55 <ivanm> yeah...
20:58:02 <edwardk> aristid: then State: s -> (a, s)  — Store: (s -> a, s) — one is (,)e `o` (->)e — the other is (->)e `o` (,) e
20:58:17 <ivanm> Axman6: well, C++0x has lambdas...
20:58:27 <monochrom> I like C++'s { } syntax. THE END.
20:58:37 <Axman6> heh
20:58:41 <ivanm> monochrom: so do you use braces in your haskell code as well?
20:58:43 <aristid> State: (->) s ((,) a s), Store: (,) ((->) s a) s
20:58:49 <ivanm> besides, isn't that _C's_ braces?
20:58:53 <monochrom> yes sometimes
20:59:08 <ddarius> Axman6: There are plenty of bad things in C++, but it does what C does, as far as representation and layout control while providing -some- basis for abstraction.
20:59:09 <Axman6> see, it feels like a language i should like, but i can't find anything to like about it that isn't offset by things that horrify me
20:59:11 <edwardk> aristid, you can flip the args to store to get symmetry
20:59:12 <monochrom> actually I also like the camel_case convention.
20:59:20 <aristid> edwardk: yes, that would help.
20:59:34 <edwardk> aristid: mathematicians usually write it on the other side though
20:59:47 <edwardk> a * e, rather than (,) e
21:00:06 <aristid> edwardk: that's just mathematical historical baggage :)
21:00:06 <ivanm> edwardk: btw, with your Void type, is it actually possible to create values for it?
21:00:07 <monochrom> I like C++'s { } syntax because it is more symmetric than Pascal's begin end syntax.
21:00:09 <edwardk> the a * e, notation gives you a more obvious connectoon between reader and coreader
21:00:14 <edwardk> aristid: not entirely.
21:00:23 <edwardk> ivanm: not directly, thats the point ;)
21:00:30 <ivanm> *nod*
21:00:32 <edwardk> ivanm: the idea is they are vacuous instances
21:00:34 <aristid> edwardk: is there something more important then the symmetry?
21:00:36 <ivanm> what's the point of the void function then?
21:00:38 <aristid> -then+than
21:00:41 <ivanm> I can't even work out how it works :/
21:00:48 <ivanm> (works as in "type checks")
21:00:58 <ddarius> aristid: The monads completely determine the comonads (and vice versa) via the adjunction underlying State.
21:00:59 <edwardk> ivanm: haha, it says if you ever did have a member of the uninhabited type, you'd have a member of any type
21:01:01 <monochrom> the point of void function is side effects
21:01:17 <ivanm> edwardk: oh, right
21:01:43 <aristid> ddarius: the problem being that i don't know what adjunction means.
21:01:45 <ddarius> monochrom: A true Void returning function would have to either never be called or do some sort of non-local control affect.
21:01:46 <monochrom> it type-checks iff you don't "use" its return value
21:01:51 <ddarius> s/affect/effect/
21:01:54 <edwardk> ddarius: oh, i proved a nice counter example for the existence of any dual adjunction between contravariant endofunctors on hask.
21:02:07 <tolkad> monochrom: the point of IO () functions is side effects
21:02:10 <edwardk> ddarius: its kinda obvious, and comes down tot he fact that it gives you unsafePerformIO
21:02:12 <ivanm> edwardk: so it's just there to have a type that you're not meant to use?
21:02:24 <edwardk> ivanm: yes. it represents the empty graph
21:02:37 <edwardk> ivanm: Identity is what was formerly Data.Graph.Empty
21:02:46 <dibblego> the point of IO () functions is (not side-effects)
21:02:59 <ivanm> *nod*
21:03:08 <ddarius> edwardk: It would turn monads into comonads providing an extract for F (IO (U a))?
21:03:20 <ivanm> dibblego: huh?
21:03:37 <edwardk> ddarius: yeah
21:03:50 <dibblego> ivanm, the very specific point of "IO () functions" is to be side-effect free (i.e. not side-effects)
21:03:54 <edwardk> ddarius: any such dual adjunction would by necessity allow you to escape IO
21:04:00 <tolkad> I was saying IO () is analagous to void. pointing out that haskell let's you program without purity too if you wanto to
21:04:08 <BMeph> effects: they're not side-effects! :)
21:04:14 <dibblego> no () is analogous to void
21:04:22 <tolkad> BMeph: side effects to evaluation
21:04:30 <tolkad> BMeph: not side effects to execution
21:04:31 <accel> Prelude> simple x y z = x * ( y + z )
21:04:31 <accel> <interactive>:1:13: parse error on input `='
21:04:32 <accel> why ?
21:04:35 <edwardk> ddarius: so i can safely remove Data.Functor.Contravariant.DualAdjunction from the adjunctions package, and the Control.Comonad.Contra.Adjoint transformer as they aren't inhabitable.
21:04:40 <dibblego> accel, use the let keyword 
21:04:45 <ivanm> accel: you can't define functions like that in ghci
21:04:46 <dibblego> let simple x y z = x * ( y + z )
21:04:55 <ivanm> ghci isn't a full-blown REPL in the lisp, etc. sense
21:04:58 <ddarius> edwardk: Aren't inhabitable says you!
21:05:02 <accel> dibblego: thanks
21:05:35 <edwardk> ddarius: provide me a counter example that doesn't use some form of unsafe coercion ;)
21:05:37 <tolkad> BMeph: wait that was non-sensical. you're right
21:05:39 <monochrom> perhaps ghci and hugs are the real REPL, true and faithful to the E part.
21:06:06 <ivanm> monochrom: hmmmm.....
21:06:25 <accel> anyone here use vim? what inden file do you use for haskell?
21:06:38 * ivanm heads off home
21:06:53 <ivanm> the afternoon talks are rather boring IMHO
21:07:14 <edwardk> ddarius: oh, i'm going ahead with adding a superclass to comonad for the semigroup on (=>=)
21:07:18 <monochrom> not as boring as #haskell lately.
21:07:23 <edwardk> too many useful instances
21:07:43 <edwardk> since i can define it for any comonad over a kleisli category
21:08:00 <accel> oh great wizards of #haskell; how do I indent haskell code in vim?
21:08:20 <Axman6> accel: you're very impatient aren't you
21:08:22 <ddarius> monochrom: Taking that perspective, the thing that makes "Lisps'" REPL so powerful is that you can add data structures and functions via an evaluable expression.
21:08:28 <monochrom> perhaps all vim users are away
21:08:29 <dolio> The tab key.
21:08:36 <ddarius> monochrom: Just kick the non-interesting people.
21:08:46 <dolio> Or the space bar.
21:08:49 <Kaidelong> I use vim
21:08:56 <accel> Axman6: impatience is measured in pico units of me
21:09:24 <Kaidelong> although I use the spacebar for that
21:10:22 <kfish> accel, http://projects.haskell.org/haskellmode-vim/
21:10:54 * ddarius is hungry.
21:10:56 <Axman6> can i just say, whoever thought it was a good idea not to make bound statements have a show instance, or any way to inspect them, should feel my wrath
21:10:59 * ddarius should really go grocery shopping.
21:11:15 <ddarius> Axman6: You can use vacuum.
21:11:56 <accel> kfish: thanks; that is useful
21:12:13 <Axman6> that's... not nearly as useful as having a show instance
21:12:46 <ddarius> Axman6: You're right, it's far and away more useful.
21:13:07 <Kaidelong> vacuum looks a bit like ghood
21:13:36 <accel> why is vim so poorly supported
21:13:43 <accel> are most haskell ysers emacs users?
21:13:44 <Axman6> how on earth is it useful? i just want to see the string being passed to doQuery, but there's no way to do it (this in in takusen by the way)
21:13:57 <kuffaar> accel: I'm not sure hmm I've actually seen more vim users I think
21:14:11 <kuffaar> I currently use a customised haskell-mode with emacs
21:14:12 <Axman6> ddarius: i think my niglecting to mention takusen might have caused some confusion, sorry =)
21:14:43 <kuffaar> I'm not quite happy with the way it indents by default but I stopped caring
21:14:59 <Axman6> and neglecting
21:15:29 <kuffaar> Takusen will be the next thing I'll be dealing with once I've got my SCGI server working
21:15:32 <Kaidelong> ddarius: serializing with show and read?
21:15:32 <Kaidelong> not that that's a great way to do it
21:15:32 <Kaidelong> but hey
21:15:58 <ddarius> Axman6: Ah, that does change things.
21:16:13 <Axman6> thought it might, sorry :)
21:16:23 <kuffaar> Or I could go batshit and roll my own Postgres code from scratch, too
21:21:57 <lars9> is it possible to make this recursive data stucture instance of Eq? data Cons a = Value a | Cons (Cons a) (Cons a)
21:22:08 <Axman6> of course, why not?
21:22:18 <Kaidelong> "deriving (Eq)"
21:22:22 <monochrom> yes you can just deriving Eq
21:22:27 <lars9> How to?
21:22:39 <monochrom> data Cons a = Value a | Cons (Cons a) (Cons a) deriving Eq
21:22:39 <kuffaar> data Cons a = Value a | Cons (Cons a) (Cons a) deriving (Eq)
21:22:42 <lars9> but it can be recursive and hence infinite
21:22:49 <Kaidelong> you may want to derive Read, Show, and Ord as well
21:22:57 <monochrom> same for [a]
21:23:13 <lars9> i mean i can be recursive
21:23:23 <Kaidelong> lars9: then (==) just becomes partial
21:23:37 <monochrom> everything you say holds for [a] too, and [a] still has Eq
21:23:39 <lars9> a = Cons (Value 1) b, b = Cons (Value 2) a
21:23:49 <Kaidelong> > [1..] == [1..]
21:23:53 <lambdabot>   mueval-core: Time limit exceeded
21:23:54 <lars9> i mean circles...
21:24:01 <Axman6> lars9: that will work, it will just take forever
21:24:10 <lars9> how to compare two circles?
21:25:13 <monochrom> can't be done. don't worry about it.
21:25:15 <lars9> suppose a1->b1->a1, a2->b2->a2
21:25:36 <Kaidelong> lars9: it is okay if (==) is partial
21:25:42 <monochrom> make it simpler. a = Cons a a.
21:25:43 <Kaidelong> a lot of things in haskell are partial
21:25:57 <monochrom> consider also b = 0 : b.
21:27:12 <lars9> is there anyway to do it? i mean, an algorithm to compare recursive Cons
21:27:16 <lars9> exist?
21:27:33 <Axman6> if you represent it as a graph i;m sure there's a way
21:27:33 <Kaidelong> lars9: yes. It's recursive
21:28:28 <lars9> I was asked about this question just now and I think I screwed up, but there is no hard comparison in haskell, and unless I add a 'name' to the Cons, there is no way to compare...
21:28:40 <Kaidelong> if your Cons data type is a strictly infinite data type (there is no end to any instance of it) don't bother deriving Eq because == will never terminate for anything
21:29:02 <lars9> I can do this: Cons String (Cons a) (Cons a), String here is the name of a node.
21:29:17 <Axman6> if you use Ptrs there'd be a pretty simple way, but then everything turns into IO
21:29:23 <Kaidelong> lars9: if the a is comparable, you can compare by comparing the as
21:29:26 <lars9> then I can use DFS and numbering to compare two graphs
21:29:31 <Kaidelong> hence "deriving"
21:29:40 <Kaidelong> same with Eq
21:29:43 <mzero> well, if equality of the string garuntees equality of the structure under it... then yes you can write an == that will work for circular structures
21:30:06 <lars9> mzero: sure not.
21:30:33 <Jesin> hmm, does the Reader monad add anything that isn't already defined the same way for (->)?
21:30:45 <lars9> mzero: like two graphs can have the same structure, same values, and different names, they can still be the same
21:30:46 <kfish> accel, vim's well supported, what more do you need than syntax highlighting, indentation, tags, autocomplete ...?
21:31:25 <mzero> but, lars9, I think you're on the right track: Since in Haskell there is no "equals the same object in memory" operator.... you can't really check two equal circular structures for equality in finite time
21:31:51 <accel> kfish: identatino does not worked
21:31:54 <accel> I just insatlled vim's haskellmode
21:31:58 <lars9> mzero: yeah, ahhhhh screwed up, haskell is not ML, they have hard compare in ML.
21:32:17 <mzero> by "hard compare" you mean "are these the same address in memory"?
21:32:21 <lars9> yeah
21:32:31 <accel> I've installed http://projects.haskell.org/haskellmode-vim/  yet identation does not work for me. What else should I install ?
21:32:37 <mzero> well.. there is probably GHC trickery to do that
21:32:42 <mzero> but not in pure Haskell
21:33:04 <lars9> ahhhhh, so fraustrated on that question
21:33:50 <Axman6> accel: define 'does not work'
21:34:05 <azaq23> Jesin: Doesn't look like it - nothing nontrivial, at least http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Reader.html
21:34:06 <accel> data Shape = Circle Float
21:34:06 <accel> | Square Float
21:34:10 <accel> that's how vim identgs my code
21:34:38 <mzero> lars9: consder     a = 3 : 5 : a        b = 3 : 5 : 3 : 5 : b
21:34:55 <accel> http://hpaste.org/43299/accel <-- this is how vim idents my code. I do not like. How do I fix?
21:34:57 <mzero> should these be considered equal? In haskell they are indistinguishable!
21:35:23 <Jesin> what's the point of all that code, then
21:35:38 <Jesin> =/
21:35:44 <kfish> accel: set autoindent
21:36:04 <accel> kfish: autoindent is on
21:36:30 <Jesin> they could define everything like fmap = Reader . fmap . runReader; (>>=) = Reader . (>>=) . runReader
21:36:41 <lars9> mzero: thanks, my mind is just tooo fried now, too unstable
21:37:12 <mzero> lars9 --- IF you know the total size of each structure.... then you can compare for equality by testing n nodes upto the larger of the two sizes -- if they are equal, you're good.... in-so-far as they can be considered 
21:37:15 <azaq23> :t Reader . fmap . runReader
21:37:16 <lambdabot> Not in scope: data constructor `Reader'
21:37:28 <Jesin> and since it's a newtype, wouldn't Reader and runReader get treated as being basically not there in the compiled code, and just used in type inferences during compilation?
21:38:16 <Jesin> err
21:38:18 <Jesin> sorry
21:38:19 <Jesin> I meant
21:38:30 <Jesin> fmap f = Reader . fmap f . runReader
21:38:51 <Jesin> and type specialization and newtype would basically optimize all that away?
21:38:55 <kfish> accel: http://hpaste.org/43300/haskellvim
21:39:28 <accel> kfish: http://www.vim.org/scripts/script.php?script_id=1968 ?
21:39:31 <accel> kfish: have that installed alraedy
21:42:17 <kfish> accel, :-/
21:42:53 <lars9> mzero: thanks, i'll try to recover my deeply fired brain...
21:43:12 <lars9> *s/fir/fri
21:48:35 <dysinger> accel: use emacs :P
21:48:59 <accel> dysinger: I only have 12 GB of Ram :-(
21:49:07 <kfish> HEH
21:49:41 <kfish> (oopscaps) accel: not sure what is wrong with your config, but autoindent works for me :-/
21:49:58 <dysinger> accel: heh
21:50:33 <accel> kfish: if there's nothing secret, can you post your ~/.vimrc and ~/.vim to github?
21:50:44 <accel> I'd like to diff debug to find out why mine is broken
21:51:09 <kfish> accel, ok just a sec
21:54:39 <Raynes> The collective 42MB RAM of my 3 Emacs instances is almost too much to bear.
21:56:45 <mzero> <creaky-voice> I remember when I had to edit with only 4kB of core-RAM and a small magnet on a stick... </creaky-voice>
21:57:10 <geheimdienst> @remember monochrom the guys that I see when I look into the irc window believe that I'm just a bunch of text.
21:57:11 <lambdabot> Done.
21:57:43 * geheimdienst opens http://www.youtube.com/watch?v=ZzRwnUTKFpA and watches the flash player eat 89 megs of ram. so what. ram unused is ram wasted.
21:58:10 <accel> yeah; RAM is like brain cells
21:58:13 <accel> if you don't use them, they get slower
21:58:24 <accel> that's why I always hae my computer cmpute digits of pi in the background
21:58:32 <accel> when ti's not cracking the wikileaks insurance file
21:59:22 <geheimdienst> i meant, if you have 4 gigs of ram and meticulously pay attention to never use more than 1-2, you might as well have bought only 2 gigs
22:00:09 <Lemon> Is Manuel Chakravarty in this channel?
22:00:37 <ddarius> Yes.
22:00:42 <ddarius> Though not right this second.
22:00:50 <Lemon> k.
22:00:56 <kuffaar> Is he a high quality human?
22:01:29 <Lemon> I just have a few questions regarding the paper "Accelerating Haskell Codes With Multicore GPUs"
22:01:46 <Lemon> For which an email might not be suitable.
22:02:26 <Axman6> Lemon: he's TacticalGrace
22:02:39 <Axman6> he was here recently
22:02:46 <geheimdienst> preflex: seen TacticalGrace
22:02:46 <preflex>  TacticalGrace was last seen on #ghc 74 days, 6 hours, 28 minutes and 29 seconds ago, saying: ok
22:02:52 <geheimdienst> let me quantify that ...
22:03:00 <geheimdienst> preflex: seen TacticalGrace_
22:03:00 <preflex>  Sorry, I haven't seen TacticalGrace_
22:03:06 <Axman6> but, i saw him disconnect a few minutes ago...
22:03:10 <Lemon> hm
22:03:19 <geheimdienst> preflex didn't, apparently
22:03:23 <Axman6> preflex: seen TacticalGrace
22:03:23 <preflex>  TacticalGrace was last seen on #ghc 74 days, 6 hours, 29 minutes and 6 seconds ago, saying: ok
22:03:31 <Jesin> [01:12:56]	<lambdabot>	monochrom says: Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
22:03:32 <Axman6> 14:56 -!- TacticalGrace [~chak@withinreason.cse.unsw.EDU.AU] has quit [Ping timeout: 255 seconds] -!-
22:03:34 <Jesin> lol
22:03:35 <Jesin> :p
22:04:15 <geheimdienst> sometimes i think our bots are messing with us
22:05:22 <Axman6> he tends to talk more in #ghc
22:05:48 <geheimdienst> "more" in the sense of one "ok" in 74 days
22:05:49 <geheimdienst> ;-)
22:05:51 <geheimdienst> j/k
22:06:55 <accel> darn it
22:06:59 <accel> so my vim gets do-block identation right
22:07:06 <accel> but just screws up on "data Shape = ... "
22:07:25 <Axman6> screws up how?
22:07:40 <Axman6> there's many different ways to indent... well most of haskell
22:07:48 <accel> http://hpaste.org/43301/accel
22:08:24 <Axman6> >> isn't that hard to type
22:08:35 <accel> >> ?
22:08:44 <Axman6> also, tick = modify succ
22:09:00 <Axman6> >> in vim shifts a like to the right a tabstop i believe
22:09:10 <geheimdienst> accel, in normal mode in vim, type >> to indent the current line
22:09:35 <accel> yeah
22:09:40 <accel> but I like to be able to highlight a block
22:09:42 <accel> and hit "="
22:09:43 <Axman6> when you insert a new line after that, it'll be be indented the same as the previous
22:09:45 <accel> which will screw up
22:09:51 <accel> since vim has the wrong fules
22:09:53 <accel> *rules*
22:09:58 <geheimdienst> 4>> to indent this line and the following 3
22:10:09 <geheimdienst> >} to indent from current line to next empty line
22:10:11 <jeffwheeler> But, to be fair, Haskell's rules are hard.
22:10:13 <accel> I know how to use vim. I don't know why my haskell indentation is fscked up
22:10:14 <Axman6> it doesn't have the wrong rules, it has no idea you meant to define a new constructor on the next line
22:10:25 <accel> Axman6: why does emacs know that then?
22:10:44 <accel> indent/haskell.vim has no rule for "data"
22:10:46 <Axman6> because it assumes you want that. some people do want that, some don't
22:10:49 <accel> I think that's part of the problem
22:10:57 <Axman6> add one and quit bitching
22:11:03 <accel> whoa
22:11:13 <accel> that requires actual work
22:12:32 <geheimdienst> accel, i have sometimes had trouble with vim's haskell indenting myself. if you know vim config stuff and could make an improvement, many people would thank you
22:13:07 <dropdrive> Hi all, I'm on Arch.  Is the recommended package "haskell-platform" in AUR?
22:13:27 <kaustuv_> Axman6: I am perplexed by your response to my comment on /r/haskell, but reddit just went down so I can't respond there. Do you actually believe that the array increment problem can be solved by a single pass over the array of integers? Even when its size is considerably smaller than the size of the stream of updates?
22:14:13 <kaustuv_> I suppose I don't see what magic the vector package might use to obviate any of the work that needs to be done.
22:16:41 <Cale> What's the array increment problem?
22:17:53 <tlonim> dropdrive: yes.. until it is added to community. 
22:18:34 <kaustuv_> Cale: http://www.lix.polytechnique.fr/~kaustuv/expo/incr_uarray/ (it's not a very interesting or important microbenchmark, just one that happened to be relevant to my needs at the time)
22:20:53 <dropdrive> tlonim: Okay, thanks.  (I guess I can just install the dependencies using pacman?)
22:21:36 <geheimdienst> so is the haskell platform these days recommended over using cabal?
22:22:06 <geheimdienst> (i'm very happy with the cabal packages, so i guess there's not much point to switching)
22:22:11 <Saizan> ..the haskell platform includes cabal
22:22:49 <Saizan> it's just a script/installer on top of the cabal packages
22:23:20 <dysinger> geheimdienst: the haskell platform is just a bunch of cabal packages
22:23:35 <dysinger> geheimdienst: you can get the same result by cabal-installing stuff
22:23:51 <dysinger> y what Saizan said :)
22:24:55 <geheimdienst> yes yes, i meant: suppose i need hunit. i've always gone and done "cabal install HUnit". if i had the platform installed, i could avoid some of that
22:25:46 <kaustuv_> Axman6: I have to get to work. You have my code and the problem statement. If you can coax the vector package to improve on my code, I would be very eager to learn of it (my e-mail address is found from that page and is also easily google-able). If you can't, that's fine as well and thanks for the discussion so far.
22:26:02 <Saizan> yeah, you'd have more packages installed by default
22:27:08 <accel> geheimdienst: good call; fixing vim indenting got "data ... =" to ahve "|" match with "=" now :-)
22:29:22 <accel> what's the comment char in haskell?
22:29:32 <dibblego> -- this is a line
22:29:37 <dibblego> {- this is a block -}
22:30:43 <accel> dibblego: does (- -) nest ?
22:30:52 <romanandreg> can someone explain me how to solve this issue 
22:30:53 <romanandreg> http://pastie.org/1495223
22:30:56 <dibblego> you mean {- -}, yes
22:30:57 <geheimdienst> yeah. and it's {}, not ()
22:31:03 <geheimdienst> :)
22:31:09 <accel> ah
22:31:09 <accel> thanks
22:31:56 <romanandreg> ?
22:33:39 <geheimdienst> accel, this stuff you're editing, is that in the file indent/haskell.vim? i can't even find the file to look at on my system
22:34:02 <accel> geheimdienst: it/s ~/.indent/haskell.vim
22:34:18 <accel> geheimdienst: for example, to match up the 'data' word, I use:
22:34:19 <accel> match(line, '\<data\s*[^ ]*\s*\zs\|\<do\s\+\zs[^{]\|\<where\s\+\zs\w\|\<let\s\+\zs\S\|^\s*\zs|\s')
22:34:43 <romanandreg> this existencial types are being a big pain 
22:35:22 <geheimdienst> interesting. i don't have a file there. is that s'posed to be part of haskellmode?
22:35:47 <accel> no, it's part of: go to vim.org, search for "haskell indent"; there's some script by some guy written back in 2007
22:35:50 <accel> I couldn't find anything better
22:36:02 <geheimdienst> i see :) thanks for the research so far
22:36:42 <accel> geheimdienst: yeah; I'm doing this not at all for my own personal benefit; and purely for the good of rht evim haskell community :-)
22:37:33 <geheimdienst> well, best is if both yourself and the community profit from it
22:38:26 <accel> hmm; maybe I should charge for my vim haskell mode :-)
22:39:45 <ddarius> romanandreg: You aren't using existentials.
22:40:18 <accel> whoa; just got deriving working
22:40:26 <accel> never realized writing vim identation files could be fun
22:41:21 <dropdrive> tlonim: I don't seem to be able to upgrade ghc, even with IgnorePkg in pacman.conf.  Have you encountered this problem before?
22:43:02 <accel> what is the type of: "square s = Rectangle s s" ?
22:44:04 <accel> how do I tell haskell: it's okay if this file does not ahve a "main" ?
22:44:19 <Zao> accel: Depends on what you're doing.
22:44:28 <accel> I just want the compiler to do type checking
22:44:32 <accel> it can compile it too if it wants
22:44:33 <Zao> accel: Most files do not have mains. Typically only the Main module does.
22:44:35 <accel> but I do't have a main method
22:44:37 <shachaf> accel: ghci would work.
22:44:52 <Zao> ghc -c would do
22:45:04 <geheimdienst> bah, just stick in a main = return () to make ghc happy
22:47:03 <accel> so "," in (,) separates tuples, whie "," in [] separates lists items ?
22:48:16 <geheimdienst> yup
22:50:43 <Cale> accel: Yeah, the comma isn't an independent part of the syntax
22:51:17 <geheimdienst> > (,) "lol" 42
22:51:18 <lambdabot>   ("lol",42)
22:51:29 <ddarius> > 1, 2
22:52:06 <lambdabot>   <no location info>: parse error on input `,'
22:52:07 <accel> whoa; infix prefix abuse
22:52:07 <geheimdienst> :t (,)
22:52:07 <lambdabot> forall a b. a -> b -> (a, b)
22:52:15 <geheimdienst> btw, is (,) caleskell or does that work generally?
22:52:57 <accel> what's caleskell ?
22:54:15 <Saizan> generally
22:54:15 <Cale> geheimdienst: it works generally
22:54:23 <geheimdienst> thanks
22:56:03 <romanandreg> ddarius: I though just by using the "forall" on the Field definition it was existensial
22:59:30 <Kaidelong> Cale: I was looking at toList in MonadRandom, and I think you could get an asymptotic improvement on it with a data-structure that allows random access
22:59:38 <Kaidelong> unless there is something I'm missing here
22:59:53 <Kaidelong> but you could search it in sqaure-root-sized steps rather than going through each element
23:00:33 <Kaidelong> (and then check a square-root-sized slice element by element)
23:01:00 <accel> is standard haskell naming convention for functions likeThis or like_this ?
23:01:08 <c_wraith> camelcase
23:01:24 <c_wraith> I suppose camelCase if I wanted to be annoying. :)
23:01:38 <accel> camelCase if you want to be accurate
23:02:12 <Cale> Kaidelong: I did nothing to optimise that code
23:02:18 <accel> how do I convert int to float ?
23:02:34 <Cale> fromIntegral
23:02:57 <Cale> fromIntegral will turn any integer-like numbers into any sort of numbers at all
23:03:00 <Kaidelong> Cale: at least it was easy to understand! If I implement the vector version, would you like me to send it to you? It'd be trivial really.
23:03:51 <accel> genNum x = fromIntegral x :: genNum ( fromIntegral x - 1)
23:03:51 * hackagebot text 0.11.0.2 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.2 (BryanOSullivan)
23:03:56 <Axman6> accel: i hope you mean Double, there's almost no reason to use Float unless you need to store a lot of them in memory
23:03:57 <accel> why is there an error on "-" ?
23:04:28 <Axman6> what's the :: supposed to be doing there?
23:04:33 <accel> I want to simulate numerical problems
23:04:36 <Cale> Kaidelong: You can just upload a new version to hackage if you'd prefer
23:04:42 <accel> methinkgs that :: should be a L
23:04:43 <accel> a :
23:04:50 <accel> and magically, it now compiles
23:04:55 <Cale> Kaidelong: When I originally wrote that code, I just stuck it on the Haskell wiki
23:04:58 <Axman6> heh
23:05:02 <Cale> Kaidelong: I'm not the one who packaged it
23:05:09 * Kaidelong will confess that he has no experience with darcs or hackage...
23:05:10 * Axman6 loves magic compiles
23:05:26 <Zao> :: begins a type annotation, : is a list cons.
23:06:12 <dropdrive> Cale: Is this idea dead?  http://www.mail-archive.com/haskell-prime@haskell.org/msg02492.html  Would you recommend that a Haskell beginner adopt this?  How would I go about doing this (write my own prelude?)?  Thanks.
23:08:30 <Kaidelong> > (^2) . (*2) . [1..10]
23:08:32 <lambdabot>   [4,16,36,64,100,144,196,256,324,400]
23:08:32 <accel> whoa, _t is magical
23:09:16 * Kaidelong tries to remember where the ((->) r) functor instance lives...
23:09:19 <Kaidelong> oh
23:09:24 <Kaidelong> Control.Monad.Instances I believe
23:09:31 <edwardk> yeah
23:09:36 <Kaidelong> you can hide the prelude with -XNoImplicitPrelude
23:10:16 <edwardk> kaidelong: i've given up on hiding the prelude or pretending it doesn't eist, i've decided to just write what i want the rest of the world to look like and see if anyone comes with me ;)
23:10:40 <accel> whoa, the haskellmode is awesome
23:10:57 * Kaidelong agrees with edwardk on that... but hopefully this helps dropdrive...
23:11:50 <Kaidelong> Perhaps fpipe could be changed so that <. and .> are infix versions of fmap rather than . and you just import Control.Monad.Instances with it
23:13:26 <Kaidelong> @ty ($)
23:13:27 <lambdabot> forall a b. (a -> b) -> a -> b
23:13:37 <Kaidelong> @ty (<*>)
23:13:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:14:56 <Kaidelong> @instances-importing Apply
23:14:56 <lambdabot> Couldn't find class `Apply'. Try @instances-importing
23:15:47 * Kaidelong wonders if ($) is a method of something. It is definitely not a <*> of anything.
23:16:14 <ddarius> ($) is id (almost)
23:16:30 <ddarius> id is a method of Category if that counts for anything
23:16:43 <Kaidelong> > ($) 5
23:16:44 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
23:16:44 <lambdabot>    arising from a use of `...
23:16:47 <Kaidelong> lol
23:16:52 <Saizan> it is (<*>) of the identity applicative, and (=<<) of the identity monad
23:17:08 <Saizan> well, modulo newtypes
23:17:11 <Kaidelong> > (^2) `id` 5
23:17:12 <lambdabot>   25
23:17:15 <ddarius> Similarly for comonads.
23:19:08 * Kaidelong wonders why operators are required to be binary when (%$#@) can be used for cases where the operator is actually unary and not binary
23:21:21 <geheimdienst> > ("lol" ++) `reverse` "tac"
23:21:22 <lambdabot>   Couldn't match expected type `[a]'
23:21:22 <lambdabot>         against inferred type `[GHC.Type...
23:21:56 <edwardk> kaidelong: there is a ghc extension that allows postfix operators with surrounding ()'s
23:22:03 <edwardk> (foo !) = ...
23:22:11 <Kaidelong> actually it seems somewhat strange in the context of currying. You could interpret certain sections as "flip . (#@$)" and show a type error
23:22:12 <Kaidelong> > flip id
23:22:12 <Kaidelong> oh wait
23:22:12 <Kaidelong> that actually makes sense
23:22:12 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a -> b) -> b)
23:22:13 <lambdabot>    arising fro...
23:22:13 <Kaidelong> > flip negate
23:22:14 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a -> b) -> b)
23:22:14 <Kaidelong> > flip toLower
23:22:14 <lambdabot>    arising fro...
23:22:15 <lambdabot>   Couldn't match expected type `a -> b'
23:22:33 <geheimdienst> > (3+) `id` 5
23:22:35 <lambdabot>   8
23:22:48 <geheimdienst> > ("lol"++) `id` "cat"
23:22:50 <lambdabot>   "lolcat"
23:23:33 <geheimdienst> > ("lol" ++) "stac" `reverse`
23:23:34 <Kaidelong> edwardk: it makes sense to do it anyway, since it is a syntax issue.
23:23:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:23:48 <geheimdienst> > ("lol" ++) ("stac" `reverse`)
23:23:50 <lambdabot>   "lolcats"
23:24:18 <geheimdienst> my haskell-fu is strong this morning
23:24:56 * Kaidelong may be able to phrase that better
23:24:59 <Kaidelong> it's an a syntactic decision that appears to be arbitrary?
23:25:06 <Kaidelong> an
23:25:13 <Kaidelong> a
23:25:58 <ddarius> Most syntactic decisions are arbitrary.
23:26:28 <mjrosenb> in general, i would not assume that lambdabot gives an accurate representation of the haskell that you work with on a day to day basis.
23:36:18 <romanandreg> can someone explain me this error => http://pastie.org/1495293
23:36:22 <romanandreg> ?
23:36:23 <romanandreg> please
23:37:27 <dolio> getValue is required to be able to produce a Maybe a for all instantiations of a.
23:37:57 <dibblego> romanandreg, that error aside, you might be interested in http://hackage.haskell.org/package/json-combinator
23:38:00 <dolio> But, your setValue is trying to fill it with a value of some particular type.
23:38:18 <dolio> Specified by the caller of setValue.
23:39:09 <dolio> The correct type for that function would be: setValue :: (forall a. JSON a => a) -> Field -> Field
23:42:13 <romanandreg> uhmm
23:42:13 <romanandreg> dolio: let me try that
23:42:14 <dolio> Anyhow, that said, I'm skeptical that that's actually what you want.
23:42:18 <romanandreg> what is the difference between two different definitions?
23:42:19 <romanandreg> if it is not being set by the caller
23:42:19 <romanandreg> who sets it?
23:42:19 <romanandreg> :-o
23:42:50 <dolio> A value of type (forall a. JSON a => a) is a first-class value that can be instantiated to any type by whoever has it.
23:43:07 <dolio> Field says it contains one of those.
23:43:39 <dolio> Well, any type within the restrictions by the JSON thing.
23:44:20 <romanandreg> I think that's what I want, not completely sure though :-)
23:44:21 <dolio> However, it's likely that you want it to be a value of some unknown JSON type, if I had to guess.
23:44:33 <romanandreg> let the test be executed and will let you know
23:44:58 <romanandreg> dolio: it is always going to be unknown?
23:45:03 <romanandreg> If I define it that way?
23:45:22 <dolio> All you will know is that the type satisfies the JSON constraint.
23:45:41 <lpsmith> romanandreg, the general rule of thumb is,  unless you actually know you want a rank-2 type,  you probably don't.
23:45:56 <lpsmith> However,  you might want an existential type here
23:46:08 <hvr> ...anyone has an ETA when the next ghc-7.0.2 RC or final will be released?
23:46:37 <lpsmith> which you would write as     data Field = forall a. JSON a => Field { ..., getValue :: a } 
23:47:52 <lpsmith> romanandreg, actually, the value you have must be able to assume the type of *all* members of the JSON class.
23:48:02 <lpsmith> :t []
23:48:03 <lambdabot> forall a. [a]
23:48:40 <lpsmith> If I wrote   data Funny = Funny (forall a. [a])
23:49:22 <lpsmith> Then the *only* value (that terminates normally) of Funny would be (Funny [])
23:49:52 <romanandreg> lpsmith: so
23:50:14 <romanandreg> writhing the forall at the constructor level is different than doing it on the attribute of the Field constructor?
23:50:37 <lpsmith> yes,  if it's on the outside,  you should read the "forall" as "exists"
23:51:19 <lpsmith> it's not a very novice-friendly syntax,  but it actually does make sense
23:51:55 <dibblego> edwardk, are you there?
23:52:01 <ddarius> It was mostly chosen to avoid adding another keyword (and that it makes sense.)
23:52:06 <dblhelix> @seen edwardk
23:52:07 <lambdabot> Unknown command, try @list
23:52:07 <preflex>  edwardk was last seen on #haskell 30 minutes and 5 seconds ago, saying: (foo !) = ...
23:52:32 <romanandreg> lpsmith: well yeah, I didn't know the difference
23:52:39 <romanandreg> not even sure what a RankNTypes is
23:52:40 <lpsmith> Because in first order logic,   forall a. ( a -> b )  === (exists a . a) -> b
23:53:53 <reacocard> is there an 'official' style guideline anywhere for haskell, like python's PEP 8?
23:54:19 <ddarius> No.
23:54:27 <romanandreg> when I'm trying the forall before the Field constructor
23:54:30 <romanandreg> I get this error
23:54:31 <romanandreg> Record update for insufficiently polymorphic field:
23:54:44 <romanandreg> what does that mean?
23:54:52 <c_wraith> You can't use record syntax with existential types
23:55:08 <romanandreg> oh
23:55:12 <lpsmith> c_wraith, I think he's still using a rank-n type.
23:55:24 <lpsmith> romanandreg, or did you change it already?
23:56:24 <lpsmith> romanandreg,  the trick to understanding rank-n,  in my opinion,  is to start by pondering questions like
23:56:49 <lpsmith> "How many values have the type  forall a . ( a -> a ) ?"
23:56:53 <c_wraith> Oh.  right, that erorr message does make more sense as a rank-n type
23:57:09 <lpsmith> "How many values have the type  forall a . [a] ?)
23:57:30 <lpsmith> "How many values have the type   forall a b . a -> b -> a ?" 
23:57:33 <lpsmith> etc.
23:58:05 <romanandreg> gosh this doesn't stop :-(
23:58:06 <romanandreg> http://pastie.org/1495332
23:58:28 <romanandreg> lpsmith: I changed it already
23:59:26 <romanandreg> lpsmith: I think I have to dig a bit more into types in order to even come up with those questions, haven't had the need until now
