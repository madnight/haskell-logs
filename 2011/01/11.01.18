00:02:15 * hackagebot sbv 0.9.5 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.5 (LeventErkok)
00:06:16 * hackagebot UtilityTM 0.0.2 - Utility functions that are missing from the standard library  http://hackage.haskell.org/package/UtilityTM-0.0.2 (TonyMorris)
00:34:31 * hackagebot sbv 0.9.6 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.6 (LeventErkok)
02:15:46 <ivanm> what is an appropriate name for a function that returns all edges incident to a vertex in a graph (as well as the variants that return incoming and outgoing edges only)?
02:16:19 <Jafet> edges, edgesFrom, edgesTo
02:16:35 <ivanm> Jafet: well, I was going to do that, but I'm using "edges" to get the list of all edges in the graph :/
02:16:45 <Jafet> Use polymorphism to get both
02:16:58 <ivanm> huh?
02:17:11 <ivanm> that would require splitting it off into another class, something I'm not keen on doing
02:17:16 <ivanm> and would probably only confuse the issue
02:17:42 <Jafet> Well, I don't have any serious suggestions for that
02:17:51 <geheimdienst> allEdges?
02:18:11 <Jafet> Getting all edges in a graph seems like a less common thing to do -- huffman encode it to something else
02:18:31 <ivanm> Jafet: I get all the edges from a graph more than I get all the edges from a particular vertex...
02:18:50 <ivanm> geheimdienst: hmmm, maybe
02:19:23 <ivanm> but just saying "edges" doesn't really denote that it's those incident with a particular vertex IMHO
02:19:26 <Jafet> In that case it would have more right to the name, then
02:19:39 <ivanm> incidentEdges is a possibility, but maybe too long :/
02:19:53 <geheimdienst> edges for all edges, edgesFrom, edgesTo, edgesOf?
02:19:59 <geheimdienst> edgesOf myVertex
02:20:05 <Jafet> edgesFromTo, following Prelude
02:20:17 <ivanm> Jafet: heh
02:20:21 <ivanm> geheimdienst: yeah, edgesOf might work
02:20:25 * ivanm goes with that for now
02:20:29 <geheimdienst> edgesFor is another variant
02:20:40 * geheimdienst -> suspend, battery dying
02:20:46 <ivanm> cya geheimdienst 
02:20:52 <geheimdienst> cu ivanm
02:21:31 <ivanm> *sigh* it's too easy to think of inter-related functions on graphs: should the primary one be edges{From,To,Whatever} or neighbours ?
02:24:24 <Jafet> They're different views of the same graph, so it depends on what you're doing
02:51:25 <Blkt> good day everyone
03:01:18 <dobblego> good day to you Blkt 
03:01:52 <Blkt> :)
03:04:54 <koala_man> what's the prudent library to use to load and save bitmaps (no editing functionality needed)
03:05:57 <chris_____> Hi i'm Chris. Bot in haskell running on iPad.
03:06:17 <ivanm> koala_man: I don't know about "prudent"... but there's a library called "bitmap" on hackage
03:07:14 <koala_man> I'm sure there are loads, but none seemed to be blessed by the haskell platform
03:08:45 <koala_man> is it just me or does bitmap not include the functionality for reading/writing standard file formats_
03:10:29 <ivanm> koala_man: being "blessed" by the platform doesn't really mean that much
03:10:54 <koala_man> it means I don't have to try four different libraries and see which one I can get to compile
03:10:59 <ivanm> especially in this case, as bitmap manipulation is presumably not a common task that you would expect the majority of haskell programmers to be wanting to do
03:11:08 <ivanm> there are imagemagick bindings IIRC...
03:11:53 <koala_man> but opengl is?
03:12:17 <ivanm> for historic reasons
03:12:24 <koala_man> ah
03:12:41 <ivanm> HP started off as GHC's extralibs, which IIUC were originally all the major Haskell libraries that existed
03:13:02 <geheimdienst> haskell unfortunately does not seem to be strong on the graphics front, judging from http://www.haskell.org/haskellwiki/Applications_and_libraries/Graphics
03:13:25 <ivanm> also, I think one argument for libraries like opengl being part of the platform is that they're a PITA to build on windows, so having an installer come with it can be useful
03:13:32 <jonkri> i want to learn emacs, vi or yi, which one do you recommend? i don't want to start a flamewar or anything, i realize that they are all good at different things and in different ways. i agree with most of the things at http://xahlee.org/emacs/emacs_kb_shortcuts_pain.html about emacs. i don't want to have to use a mouse. this is primarily for haskell
03:13:43 <ivanm> geheimdienst: *shrug* that assumes that wiki page is kept up to date
03:14:08 <ivanm> jonkri: yi doesn't yet build on latest ghc; emacs mode is rather good and used by a lot of people here; vi is also used a fair amount
03:14:15 <ivanm> do you have experience with either emacs or vi?
03:14:20 <ivanm> if so, go with that one
03:14:28 <Axman6> we all use vim here for haskell work
03:14:46 <ivanm> Axman6: "we" == "that place in tokyo you're at currently" ?
03:14:50 <Axman6> yeah
03:15:10 <ivanm> well, I was about to @slap you because I thought you meant "we" == "#haskell"!
03:15:43 <jonkri> ivan: no. i want to learn one editor really well
03:15:53 <jonkri> does vi has more ergonomic keyboard commands than emacs? does ghc integrate nicely?
03:16:16 <Axman6> i feel vim is more hand friendly than emacs
03:16:27 <Axman6> but, i'm not an advocate of either
03:17:01 <jonkri> Axman6: what do you use?
03:17:16 <Axman6> i prefer TextMate because i'm used to it
03:17:51 <Axman6> i don't really feel that haskell is a language that really needs a great editor though. it can help, but it's not completely necessary
03:17:53 <jonkri> feel free to suggest other editors and ide's too btw... i've used eclipse but i want to use the keyboard more (even though eclipse has a tremendous configurable keyboard shortcut system too)
03:17:59 <koala_man> vi is terrible and doesn't integrate with anything. vim is awesome.
03:18:40 <jonkri> Axman6: good point. i guess i mostly want to be able to switch between files and ghci conveniently, and have some higher level system for finding errors (highlighting lines etc)
03:18:58 <jonkri> does vim has debugger integration?
03:19:19 <Axman6> no one really uses debuggers wityh haskell
03:19:30 <Axman6> so i've got no idea, i'm sure it must somehow
03:22:26 <ivanm> jonkri: well, the haskell-mode for emacs does most of that
03:22:43 <ivanm> though I find that the first error or two that ghci reports isn't highlighted for some reason...
03:22:57 <ivanm> also, when running ghci inside emacs, you don't get ghci's normal tab-completion :(
03:23:17 <Jafet> You can run it in M-x term
03:23:23 <jonkri> ivanm: i don't find the buffer switching shortcuts very convenient, but maybe i misunderstand something
03:23:35 <jonkri> yeah, i miss that too
03:23:42 <ivanm> jonkri: there are alternatives; I use shift-arrowkeys
03:23:52 <ivanm> Jafet: then it doesn't integrate with C-c C-l!
03:26:36 <jonkri> ivanm: do you configure a lot of other keybindings?
03:26:56 <jonkri> does vim do most of those features too?
03:27:45 <ivanm> not really; I re-bind PgUp/Dn so that they go back and forth better, C-c C-r to re-load modules in ghci and C-x a r for align-regexp
03:28:03 <ivanm> oh, and I use ido for opening files, etc.
03:28:12 <ivanm> I don't believe vim has ghci integration
03:28:37 <quicksilver> there are ways to integrate vim + ghci
03:28:41 <Axman6> ivanm: maybe you could leave answering querstions about vim to someone who uses it rtegularly ;) (not me)
03:28:49 <quicksilver> but many people probably just run ghci in another window
03:28:54 <ivanm> Axman6: heh
03:28:57 <ivanm> fair enough
03:29:21 <quicksilver> for example : http://www.vim.org/scripts/script.php?script_id=2356
03:29:24 <jonkri> ivanm: could i see your .emacs file?
03:29:42 <ivanm> jonkri: eh, it's a bit big and split into several files :s
03:29:55 <ivanm> a lot of failed experiments I really should clean out as well...
03:30:01 <jonkri> :P
03:30:13 <geheimdienst> ivanm, you sound as if talking about my xmonad.hs
03:30:18 <ivanm> geheimdienst: heh
03:31:00 <ivanm> jonkri: at one stage I was using gnus as my mail client (stopped for unrelated reasons) and was starting to split my config up so that I could have a separate instance just for gnus (since emacs still doesn't have concurrency :@)
03:31:04 <geheimdienst> i keep finding strange hacks and outlandish keybindings
03:34:17 <jonkri> ivanm: i see. i don't understand what align-regexp is, but the other shortcuts sounds really interesting
03:34:36 <jonkri> thanks quicksilver 
03:34:45 <ivanm> jonkri: align-regexp lets you specify a regexp on how to line up vertically parts of a block of text
03:35:02 <ivanm> browse through the emacs wiki for a while to find cool things to do ;-)
03:38:36 * liyang thinks he found a bug in c2hs. :(
03:43:42 <nmkolev> how does one define a new type being a set of something(s)? I would like to define a new type Entities and it should be a set of integers.
03:44:05 <jonkri> i think iw ill give http://xahlee.org/emacs/ergonomic_emacs_keybinding.html a try
03:45:30 <Axman6> nmkolev: use a Data.Set.Set?
03:45:37 <Axman6> or, even better, IntSet?
03:45:47 <Axman6> (Data.IntSet.IntSet)
03:46:25 <AB__> hi
03:46:38 <AB__> I've been waiting a long time to ask this question, but here it is
03:46:50 * Axman6 can't wait
03:47:27 <nmkolev> what would be the type definition when using Data.Set.Set?
03:47:28 <AB__> I've been trying to learn haskell, as I thought the RWH book and the language had some interesting traits, the language especially as a functional language..
03:47:42 <nmkolev> type Entities = ?
03:47:52 <AB__> but when I got to this part in the getting started section, I came across the floating point enumerations
03:47:56 <Axman6> nmkolev: typeEntities = IntSet
03:48:12 <AB__> for example, [1.0,1.1..2.0] gives something like
03:48:19 <nmkolev> I will need it for things other than Ints further along
03:48:34 <Axman6> then use a Set
03:48:40 <Axman6> type Entities a = Set a
03:49:05 <AB__> bugger it
03:49:08 <AB__> wont let me paste
03:49:20 <Axman6> > [1.0, 1.1..2.0]
03:49:21 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
03:49:21 <AB__> trailing numbers like 1.20000001
03:49:26 <AB__> yep
03:49:34 <AB__> now isn't this counterintuitive?
03:49:40 <AB__> i know floats are tricky, but...
03:49:45 <nmkolev> Axman6: thanks!
03:49:45 <Axman6> that's a well known problem with floating point number
03:50:06 <Axman6> > 1.1+0.1
03:50:07 <lambdabot>   1.2000000000000002
03:50:15 <Axman6> > 0.1
03:50:16 <lambdabot>   0.1
03:50:24 <AB__> sure, it just threw me off a bit because I like intuitive software. so I know that won't work
03:50:31 <AB__> is there any function that can do that for you?
03:50:39 <AB__> eg. give 1.1,1.2,1.3 etc etc
03:50:43 <Axman6> > 1.3
03:50:44 <lambdabot>   1.3
03:50:51 <geheimdienst> would Data.Fixed be a solution?
03:51:01 <Axman6> well, do you know how 0.1 is represented in binary?
03:51:03 <geheimdienst> (fixed point instead of floating point)
03:51:30 <AB__> I'm not too good with the maths but I would LIKE the maths to return accurate values
03:51:37 <Axman6> well touch
03:51:40 <AB__> it keeps me organized
03:51:47 <Axman6> see, 0.1 is an irrational number in binary
03:51:57 <AB__> sorry axman6, no I don't
03:52:06 <Axman6> it comes out looking something like 0.0011011011011...
03:52:15 <Axman6> tough*
03:52:47 <AB__> yeah, I thought so..
03:53:01 <AB__> see, I know sometimes intuitive software is too much to ask for
03:53:25 <AB__> but I WOULD like accurate values to be returned, as in decimal fractions instead of that form
03:53:28 <Axman6> it's got nothing to do with intuitive software, it's got to do with there being limitations with computers
03:53:41 <Axman6> > [1.0,1.1..2.0] :: CReal
03:53:43 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
03:53:43 <lambdabot>         against infe...
03:53:47 <Axman6> > [1.0,1.1..2.0] :: [CReal]
03:53:49 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
03:53:58 <AB__> so are you saying that there is no way at all to create a function that will do that for you?
03:54:03 <Axman6> CReals have infinite precision, but they're extremely slow
03:54:16 <Axman6> > [1.0,1.1..2.0] :: [Rational]
03:54:17 <lambdabot>   [1 % 1,11 % 10,6 % 5,13 % 10,7 % 5,3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1]
03:54:28 <jonkri> ahh, "C-x C-f is undefined" :>
03:54:41 <Axman6> > map fromRational [1.0,1.1..2.0] :: [Double]
03:54:42 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
03:54:48 <Axman6> that works i guess
03:54:54 <AB__> ah
03:55:06 <AB__> which one is that, lambdabot?
03:55:15 <Axman6> huh?
03:55:49 <AB__> did he get an output of [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]?
03:56:05 <Axman6> you know lambdabot is a bot right?
03:56:14 <AB__> I know these questions might seem simplistic or childish to ask, but they really are important to me :)
03:56:21 <nmkolev> type Entities = Set Int; instance Show Entities where ... and ghc complains of overlapping instances. I can see why, but how do I prevent it from using the one defined on sets?
03:56:27 <AB__> no, I didn't
03:56:31 <geheimdienst> AB__: no, i think you really have a point
03:57:22 <AB__> geheimdienst: yes, my point exactly
03:57:29 <AB__> so, axman you put in a creal
03:57:40 <AB__> that outputs the kind of result I wanted
03:57:45 <AB__> but very slow
03:58:01 <Axman6> but you probably don't want to use CReal for anything other than trivial examples, because it's very slow
03:58:08 <Axman6> yeah
03:58:15 <Axman6> > showCReal 80 pi
03:58:16 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
03:58:28 <Axman6> > pi ^ 4 :: CReal
03:58:30 <lambdabot>   97.4090910340024372364403326887051112497276
03:58:30 <geheimdienst> use CReals, until the slowness bothers you?
03:58:34 <Axman6> > pi ^ 10 :: CReal
03:58:35 <lambdabot>   93648.0474760830209737166901849193456359981573
03:58:42 <Axman6> i'd use Rationals if you can
03:58:57 <AB__> that was my thought, geheimdienst
03:59:14 <geheimdienst> how do CReals, Rationals, and Data.Fixed relate to each other?
03:59:24 <Axman6> @src Rational
03:59:25 <lambdabot> type Rational = Ratio Integer
03:59:26 <Axman6> @src Ratio
03:59:27 <lambdabot> data (Integral a) => Ratio a = !a :% !a
03:59:44 <Axman6> i've never used Data.Fixed
03:59:59 <Axman6> and i don't believe it would solve this problem, i could be wrong
04:00:28 <geheimdienst> i'm not sure, i only stumbled across it recently while reading code that used it
04:01:10 <geheimdienst> so, Int : Integer :: Float : CReal?
04:01:29 <Axman6> i wouldn't say so
04:01:51 <Axman6> > pi ^ 1000 :: CReal
04:01:55 <lambdabot>   mueval-core: Time limit exceeded
04:01:59 <Axman6> > pi ^ 1000 :: Double
04:02:00 <lambdabot>   Infinity
04:02:03 <Axman6> heh
04:02:10 <Axman6> > pi ^ 100 :: Double
04:02:11 <lambdabot>   5.187848314319599e49
04:02:16 <Axman6> > pi ^ 100 :: CReal
04:02:17 <lambdabot>   51878483143196131920862615246303013562686760680405.784990071842358082188144...
04:02:26 <geheimdienst> so Double is a lot quicker, but wrong
04:02:27 <geheimdienst> :)
04:03:24 <Axman6> -
04:03:26 <Axman6> -_-
04:03:27 <geheimdienst> i thought Int is limited (32 bits or whatever), while Integer has no limit
04:03:46 <Axman6> I see neither of you have taken a course that goes into this stuff
04:04:08 <Axman6> geheimdienst: yes, but Integer is also extremely fast at what it does
04:04:16 <geheimdienst> no, i'm just confuddled by the multitude of numberish things in the haskell libs
04:04:16 <AB__> talking about limits of computers vs intended values... I can see CReal isn't used in the tutorial because of its inefficiency, but it'll have to do for now
04:04:25 <sipa> >> (2 ^ 100) :: Integer
04:04:28 <sipa> > (2 ^ 100) :: Integer
04:04:29 <lambdabot>   1267650600228229401496703205376
04:04:40 <Axman6> > 2 ^ 1000 :: Integer
04:04:42 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
04:04:46 <Axman6> > 2 ^ 100000 :: Integer
04:04:47 <lambdabot>   999002093014384507944032764330033590980429139054181691771529273863145832464...
04:07:15 <liyang> Bug in c2hs? Anyone seen this before? The latest darcs version is no better. http://hpaste.org/43118/c2hs_sizeof_bug
04:07:19 <aleksag2> hei hei 
04:07:26 <runemy> hei alex
04:07:30 <aleksag2> skjera?
04:08:32 * geheimdienst suspects liyang has a 64-bit computer
04:08:50 <geheimdienst> liyang, i think you have 2 pointers in your struct (array = pointer)
04:09:01 <liyang> geheimdienst: outer_t should be 64 bytes…
04:09:05 <geheimdienst> so the size of the struct would be the 2 * size of a pointer
04:09:36 <liyang> hang on, let me show you something that works.
04:10:02 <geheimdienst> i could be wrong, my c-fu is not very strong
04:12:02 <AB__> > [1.0,1.1..2.0] :: [CReal]
04:12:03 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
04:12:19 <AB__> GHC doesn't give same output
04:12:28 <Axman6> > fromEnum (7 :: CReal)
04:12:29 <lambdabot>   *Exception: Cannot fromEnum CReal
04:12:37 <alpounet> > [1.0, 1.1, ..., 1.89@ :: CReal
04:12:38 <lambdabot>   <no location info>: parse error on input `,'
04:12:45 <alpounet> > [1.0, 1.1, ..., 1.89] :: CReal
04:12:46 <lambdabot>   <no location info>: parse error on input `,'
04:12:54 <Axman6> too many ,'s...
04:12:56 <alpounet> er
04:12:56 <alpounet> m
04:12:59 <ivanm> AB__: why, what does GHC give?
04:13:00 <alpounet> > [1.0, 1.1, .., 1.89] :: CReal
04:13:01 <lambdabot>   <no location info>: parse error on input `..'
04:13:10 <alpounet> am i stupid today
04:13:12 <alpounet> damn
04:13:14 <AB__> ah, stupid me
04:13:20 <Axman6> > [1.0, 1.1..1.89] :: [CReal]
04:13:21 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8]
04:13:23 <AB__> I think I probably haven't loaded the correct module
04:13:30 <alpounet> yeah ok
04:13:37 <AB__> forgot about the 'laziness' :)
04:13:40 <Axman6> AB__: CReals come from a hackage package
04:14:01 <AB__> ok..
04:14:28 <liyang> geheimdienst: http://hpaste.org/paste/43118/c2hs_sizeof_bug_annotation#p43119
04:14:35 <alpounet> the 'numbers' package
04:14:47 <AB__> yeah, dled
04:15:00 <geheimdienst> hm, i see what you mean, liyang ...
04:15:21 <norm2782> byorgey: hi! I'm considering printing the relationship diagram from the Typeclassopedia in poster format to decorate my livingroom wall. I figured I'd ask for your permission first before ordering a print :) would that be alright? also, do you have that diagram as separate pdf or dot file? 
04:15:53 <Axman6> @where typeclassopedia
04:15:54 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:17:34 <AB__> I would normally not come on here to talk about it since I like to figure out things by myself, but this behavior was so unusual (I'm not a programmer, so not familiar with the floating point behavior in other languages), and the explanations in the RWH book make absolutely no sense and leave a beginner dumbfounded - I think it's best they omit using floating point numbers in list enumeration.
04:18:00 <ivanm> AB__: yeah, that's a contentious issue
04:18:01 <Axman6> if you're learning haskell and not asking questions in here, you're doing it wrong
04:18:23 <ivanm> Axman6: hey, I think it took me a while to learn about #haskell after I started learning it!
04:18:41 <Axman6> yeah but you're slow :P
04:18:41 * ivanm is reminded that he has to review bird's book still :s
04:18:45 <ivanm> @slap Axman6 
04:18:45 * lambdabot activates her slap-o-matic...
04:18:49 <Axman6> git to it!
04:19:12 <zenzike> ivanm: the chapters I've read are pretty good
04:19:13 <Philippa> RWH isn't really a (typical) beginner's book, people should stop advising it as such
04:19:37 <Philippa> if you're already a /good/ coder in general then that's different, but if you're closer to average and starting haskell, it's at completely the wrong level
04:19:41 <AB__> lots of possible replies, but..
04:19:45 * Axman6 only advises people use RWH after being somewhat familliar with haskell
04:19:57 <AB__> I like a manual that is rigorous
04:20:15 <AB__> not in the sense of the haskell report mind you :) just solid in explanation
04:20:32 <AB__> without having to go elsewhere if something really dumbfounds you
04:21:14 <AB__> zenzike: yes, there's something about it. anyway, getting to it again..
04:21:24 <Axman6> sounds like you should be reading LYAH
04:21:27 <geheimdienst> liyang, i think you're right. it must be a c2hs bug
04:21:42 <geheimdienst> i've made a tiny c program, and it does print the expected thing ... http://hpaste.org/43120/c2hsbug
04:21:52 <Axman6> how odd
04:22:11 <geheimdienst> so c2hs does it differently than gcc
04:22:15 <liyang> geheimdienst: http://hackage.haskell.org/trac/c2hs/ticket/9 might be related, though that's been there for 2 years already.
04:22:35 <liyang> I'm not convinced that trac is being used.
04:22:46 <liyang> s/that/& &/
04:24:29 <AB__> axman6: sorry to disagree, but it seems learning the essentials about types etc and all the fundamentals you need to know are useful later on
04:24:41 <AB__> I don't like manuals that 'dumb down' material to the reader
04:25:06 <Axman6> i'm sorry, but LYAH covers exactly the things that are fundamental to Haskell
04:25:20 <Axman6> if you don't understand what in it, then you'll get nowhere
04:25:46 <AB__> it's not that hard to understand
04:26:28 <geheimdienst> so in summary, i think it's a bug. you should stick the hpaste links in a mail to somebody. (you're right about the trac possibly being disused)
04:27:00 <AB__> i know it's kind of a 'it should be this way' when I haven't really even started learning the language, but it is kind of important...
04:27:14 <Axman6> liyang: you should discuss thins in #ghc as well i believe
04:27:25 <geheimdienst> yeah that's a good idea
04:27:27 <AB__> something like the floating point behavior given with [1.0,1.1..2.0] throws me off
04:27:33 <AB__> I'd like a bit of mathematical rigour
04:27:39 <AB__> consistency across the board is best
04:27:41 <Axman6> > 1.2-(1.1+0.1)
04:27:42 <lambdabot>   -2.220446049250313e-16
04:27:45 <AB__> despite the limitations of computers
04:28:14 <AB__> that stuff is best left until LATER ON, when someone grasps the significance of it
04:28:23 <geheimdienst> AB__: in my opinion, floating point is kinda evil and should be avoided
04:28:26 <Axman6> if you have a better way to do these things, please let the computing world know. it's a very well known problem, and there is a lot of research into the issue
04:28:50 <geheimdienst> Axman6: fixed-point!?
04:29:03 <AB__> axman6: my point EXACTLY. I -don't- know, and I can see it's a highly technical quirk
04:29:12 <AB__> but it really SHOULD be left to last :)
04:29:15 <Axman6> -_-
04:29:31 <geheimdienst> if it makes you feel better, floats are an IEEE standard that haskell, c, ... implement. so you'll get the same idiotic behavior in a c program that sums 1.1 and 0.1
04:30:12 <Axman6> well what's your alternative then? make the default real number type something that's unusably slow? or should we stick to the prepresentation that has high performance hardware support?
04:30:15 <AB__> yes, I thought so
04:30:42 * quicksilver doesn't think high performance floating point numbers are idiotic.
04:30:45 <AB__> axman6: neither. leave floating point enumerations out of the equation until later
04:30:50 <quicksilver> you just need to understand them.
04:31:07 <quicksilver> the haskell ".." syntax is moderately idiotic, though ;)
04:31:11 <AB__> just remove the example: [1.0,1.25..2.0]
04:31:15 <quicksilver> "too cute"
04:31:15 <AB__> which does work
04:31:18 <geheimdienst> let's all use assembly for everything, "you just need to understand it ..."
04:31:26 <AB__> and for quite inexplicable reasons to someone like me :)
04:31:39 <Axman6> AB__: if you had read the right tutorial, you'd be blissfully unaware of this problem. you're RWD, and Double's are a part of real world haskell usage. you made the choice, it's not the book's fault
04:32:19 <Axman6> RWH is not designed as an introduction to haskell, even if it does have a chapter introducing you to it
04:32:31 <Axman6> it is about real wortld usage of haskell
04:32:41 <geheimdienst> AB__: i think you're right that floats and their hairiness has no place in a beginner's book. however, as axman says, RWH is not exactly aimed at beginners
04:32:55 <Axman6> so, i would fully expect it to tell you about the real world implications of using things like Doubles
04:33:56 <AB__> hang on.. haskell website puts RWH under heading
04:33:57 <Axman6> there are plenty of introductions to haskell that don't go into such details
04:34:08 <AB__> "1 Introductions to Haskell"
04:34:17 <AB__> and it is at the top of the list "best places to start"
04:34:26 <Axman6> does it start with LYAH?
04:34:29 <AB__> should I go with that definition, or yours? :)
04:34:41 <Axman6> because if it doesn't, it needs updating
04:34:50 <AB__> that's second
04:34:50 <geheimdienst> guys, i think we should change the wiki
04:34:58 <Axman6> my views here are basically the same as those of the rest of the community
04:35:05 <geheimdienst> what philippa said earlier is right, imo
04:35:15 <Axman6> it's quite poossible that list was written when LYAH was very new, it's come a long way
04:37:34 <AB__> I understand what everyone here is saying, but for special reasons I still think RWH is a great intro
04:37:49 <AB__> will give answers in a bit, brb
04:39:01 <Philippa> Axman6: AB__ is asking for something usable as a reference document as well
04:40:13 <Axman6> sure, but you should be looking for a reference after learning the language imo
04:41:10 <Entroacceptor> if he thinks it's a great intro, why come complaining then?
04:41:21 <Philippa> Axman6: MMV hugely
04:41:38 <Maxdamantus> Is MVar specifically designed primarily for concurrent code, or is it often used in non-concurrent code too?
04:41:45 <Philippa> quite often, I want to do certain things 'faster' than the intro - when I do, a reference is /exactly/ the material I need to work out WTF is going on quickly
04:41:59 <Philippa> I was learning with the reference to hand when I was 8
04:42:04 <Philippa> it worked
04:42:08 <ddarius> It makes little sense in code that doesn't use forkIO.
04:42:13 <kuffaar> I use Hoogle as a reference
04:42:17 <Axman6> Maxdamantus: well, it's fast enough to use for non concurrent code, but if you're not doing something concurrently, then you probably want to use IORefs
04:42:28 <Maxdamantus> Ah, okay.
04:42:36 <Entroacceptor> Philippa: I like learning using a tutorial AND and a reference, too
04:42:50 <Entroacceptor> but I don't think you can put both together easily
04:43:01 <Axman6> wiki updated
04:43:02 <Maxdamantus> Right, that's basically got a subset of the functionality.
04:43:10 <Philippa> sure, they shouldn't be the same document
04:43:26 <Philippa> it's a little bit trickier in a case where the language is commonly used with a collection of extensions, too
04:43:32 <Philippa> makes the reference a lot more complicated
04:44:03 <Philippa> ultimately the reference is the only way to check your own code through though, and it's not like the implementation hands you typings and (good) traces yet
04:44:26 <Axman6> Maxdamantus: IORefs can be pretty safely used in a concurrent fassion too, using atomicModifyIORef
04:44:35 <Axman6> and doing so is extremely fast
04:44:48 <kuffaar> *fashion?
04:45:03 <Maxdamantus> fission
04:45:03 <Axman6> uh, indeed
04:45:10 <Axman6> yes, concurrent fission
04:45:42 <quicksilver> fission has to be concurrent, really
04:45:49 <quicksilver> a single nucleus generates insignificant energy
04:45:54 <Axman6> well, useful fission does
04:47:00 <AB__> ok, here we go :)
04:47:14 <AB__> **controversial opinion alert**
04:47:14 <Maxdamantus> Hm, what did I do?
04:47:59 <AB__> I think long term goals are really useful for learning a programming language
04:48:12 <AB__> its not really enough to want a learn a language for the code itself
04:48:21 <AB__> saying 'i want to do x by date x' helps immensely
04:48:32 <quicksilver> my controversial opinion is that there are as many different learning styles as students.
04:48:44 <AB__> possible
04:48:46 <Axman6> that also helps you write some truly awful code too :)
04:48:49 <quicksilver> however, I, personally, find long term goals useful.
04:48:55 <quicksilver> or, indeed, short or medium term ones.
04:49:00 <quicksilver> "I want to write a computer game"
04:49:15 <AB__> so, that..
04:49:43 <AB__> goals should be idealistic, just for purely motivational reasons, although they may never translate to that in practice
04:49:44 * Maxdamantus finds short-term ones better .. at least you write half a program.
04:49:46 <Philippa> Axman6: well yes, everyone's got x lines of shit code in them, the trick's to get themn out and get on with it
04:50:01 <AB__> erm... how this relates to the reasoning I was going to give...
04:50:25 <AB__> well, these sorts of questions seem trivial and premature to the seasoned programmer, but I think they're really fundamental
04:50:30 <AB__> to getting new people to learn to program
04:50:35 <AB__> especially in THEIR language
04:50:37 <AB__> eg haskell
04:51:15 <AB__> ok, so learning types
04:51:16 <kuffaar> I think Haskell needs a way to prevent the function signature boiler plate stuff - the name of the function shouldn't be required to be mentioned twice. I think it would be much nicer if you could simply make a signature without a name which is simply applied to the next function after it, that would make it much easier, I think. Maybe something like a type prefix notation instead of a type suffix notation (which :: essentially is)
04:51:28 <AB__> for example, look at this on the haskell website:
04:51:57 <EnglishGent> hello :)
04:52:00 <AB__> "WOW! I basically wrote this without testing just thinking about my program in terms of transformations between types. I wrote the test/example code and had almost no implementation errors in the code! The compiler/type-system is really really good at preventing you from making coding mistakes! I've never in my life had a block of code this big work on the first try. I am WAY impressed."
04:52:11 <AB__> etc etc
04:52:21 <Axman6> kuffaar: you know you can leave type signatures out right?
04:52:45 <AB__> this sort of transformational thinking which you instill early on really helps people learn to think differently (and properly) about programming
04:53:08 <Maxdamantus> foo :: A -> B -> C -> D; foo a b c = ... … foo = (\a b c -> ...) :: A -> B -> C -> D
04:53:21 <Philippa> AB__: it is, but testing still matters!
04:53:37 <raichoo> good day
04:53:54 <AB__> if you take the PHP manual for example, and I know PHP has nothing to do with haskell, but in terms of learning a language it can only be viewed as a REFERENCE
04:54:00 <Philippa> AB__: trust me, if you do anything non-trivial - and if "the free theorems prove it correct" applies, it's trivial - you need testing :-)
04:54:02 <AB__> not a manual
04:54:04 <Philippa> hi raichoo
04:54:24 <raichoo> hi Philippa 
04:54:49 <AB__> I find the learn you a haskell book extremely condescending
04:55:02 <AB__> you might as well have pointed me to the basic python tutorial
04:55:09 <AB__> I already know how to DO all that stuff
04:55:18 <AB__> I've used python before
04:55:19 <raichoo> wat? It's very entertaining and teaches a lot of good stuff.
04:55:38 <AB__> so does the python tutorial
04:55:43 <kuffaar> <Axman6> kuffaar: you know you can leave type signatures out right?
04:55:48 <kuffaar> Axman6 but you need them all the time
04:56:00 <Axman6> huh?
04:56:00 <kuffaar> And when you put something at the top level then it needs to have a signature anyways
04:56:06 <Axman6> no it doesn't
04:56:13 <kuffaar> Otherwise you get a warning
04:56:41 <AB__> look at: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-3.html
04:56:42 <Axman6> AB__: if you've come from the python world, then you likely have next to no idea about static typing
04:56:57 <int-e> kuffaar: well, it's a style warning.
04:57:11 <AB__> this introductory compsci book pretty much explains my reasoning for me
04:57:25 <AB__> not just the fun part, but learning HOW to program
04:57:28 <Philippa> AB__: skip a few chapters in LYAH, refer back when you need to. The usual strategy when you need the hard stuff fast, IOW
04:57:42 <AB__> and thats why I need to learn about static typing :)
04:57:58 <int-e> (and it's a good idea to have type signatures because then type errors from the compiler will improve)
04:58:13 <Philippa> int-e: yeah, though it pisses me off every time they're actually required
04:58:28 <quicksilver> kuffaar: you are not obliged to respect warnings.
04:58:48 <quicksilver> From habit (possibly bad) I never use GHC warnings.
04:59:01 <EnglishGent> hi quicksilver :)
04:59:11 <quicksilver> hi
04:59:16 <AB__> philippa, sorry, that acronym went right by me. IOW?
04:59:17 <AB__> :)
04:59:19 <raichoo> AB__: I've been programming for the last 20 years, haskell gave me the feeling that I needed to start all over again. That was a very refreshing experience.
04:59:34 <int-e> AB__: "in other words"
04:59:35 <Philippa> AB__: In Other Words
04:59:47 <AB__> thanks
05:00:06 <Philippa> alternatively you can skim the early chapters rather than paying much attention
05:00:07 <int-e> @quote stereo
05:00:08 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
05:00:14 <Philippa> enough to pick up if it tells you about annotating anything
05:00:20 <Botje> hey, the stereo quote is back!
05:00:23 <Philippa> @quote stereo metaquote
05:00:23 <lambdabot> No quotes for this person. Just try something else.
05:00:25 <EnglishGent> I've used both Python & Haskell - they might look superficially similar syntatically - but they are *very* different in terms of semantics
05:00:33 <AB__> raichoo: that's precisely correct
05:00:49 <Philippa> EnglishGent: no kidding. Also, haskell's syntax is vastly superior :p
05:00:53 <AB__> I like the efficiency idea of haskell and the idea of laziness
05:01:08 <AB__> it's a functional programming language supported by a strong community and reference
05:01:14 <AB__> that's enough to whet the appetite
05:01:14 <EnglishGent> Philippa - hey I *much* prefer Haskell to Python :)
05:01:15 <Botje> AB__: you forgot the type system :P
05:01:29 <AB__> sorry
05:01:30 <AB__> :)
05:01:43 * EnglishGent finds Python has quite a lot of gotcha's :|
05:01:50 <Axman6> the type system is very important, and i don't think RWH covers it very much at all
05:01:53 <int-e> Botje: that's ok. the compiler will remind him ;)
05:02:24 <Botje> heh heh
05:02:33 <AB__> but my point is, I find thr RWH book extremely straightforward and non-condescending, and it's... inescapable, that is, to read the next part you should read the previous one!
05:02:42 <AB__> typo: *the
05:02:45 <Botje> "Cannot infer Missing context "TypeSystem a" from "haskell""
05:02:53 <EnglishGent> it doesnt (RWH) - I think RWH kind of assumes you are already familiar with the language at least undergraduate level
05:03:07 <Axman6> indeed
05:03:15 <EnglishGent> i.e. have done all the cliched things like defining factorial :)
05:03:49 <AB__> hmm, not really sure how else to explain it
05:04:08 <Axman6> to me, the idea of using RWH is a way to learn haskell is completely bizzare, it never would have worked for me
05:04:23 <AB__> it really should be "inescapable" - that is, one part leads to another. all things said, I really should get back to it
05:04:24 <ivanm> Axman6: so, who's the slow one then? :p
05:05:06 <EnglishGent> I've used it - but that was becuase I learnt chunks of Haskell by actually writing useful code in it - at which point one becomes worried about things like speed
05:05:37 <yaxu> hi all, I'm after a quick sanity chieck -- is this statement true: "In Haskell, functions are automatically curried, allowing terse partial function application"
05:05:46 * EnglishGent should add that he is in *no* way an expert on Haskell :)
05:05:47 <AB__> axman6 - I know that, but perhaps my learning style is, as someone above me mentioned, different
05:06:02 <EnglishGent> yaxu - yes
05:06:11 <yaxu> EnglishGent: hooray
05:06:18 <Axman6> AB__: i wouldn't say it is that different
05:06:20 <alpounet> RWH worked quite well for me but only because i had written some haskell before
05:06:23 <Axman6> anyway, dinner time.
05:06:26 <AB__> I especially like the way comments are initialled and acted on
05:06:40 <EnglishGent> bon apetite Axman6
05:06:42 <EnglishGent> :)
05:06:51 <AB__> this has been a bit of a rant
05:07:24 <AB__> but I'm a little fed up with books that suddenly leave the beginner with symptoms of the language that have next to no explanation
05:07:44 <Philippa> yaxu: haskell arguably doesn't know what an uncurried function is, but sure
05:07:45 <AB__> (sorry, that is not the language, but of the "IEEE" standard, as others have pointed out)
05:07:48 <EnglishGent> beh try reading math textbooks :/
05:08:00 <Philippa> (it /does/, it's one with a tuple as the parameter, but YKWIM :p)
05:08:12 * EnglishGent finds most have very little exposition :/
05:08:25 <Philippa> (but arguably haskell also doesn't know what a /curried/ function is - it just has sugar that encourages them
05:08:26 <Philippa> )
05:10:53 <EnglishGent> btw - has anyone here looked at Chameleon? (exotic Haskell variant)
05:11:12 * EnglishGent trying to make sense of some stuff regarding it
05:12:13 <kuffaar> mm_freak I got my derivative of your code working but why did you use MVar for passing commands and a TVar for writing to that variable really?
05:12:18 <azaq23> Philippa: -> seems to be the only type operator that is right associative, though, which makes it and it's convenience regarding currying a special case
05:12:23 <keep_Learning> hello all 
05:12:50 * azaq23 meant type constructor of course
05:12:58 <keep_Learning> i have to calculate log a / log b where a and b are Integers 
05:13:13 <keep_Learning> and answer should also be Integer 
05:13:26 <keep_Learning> let                                         prime_1 = takeWhile (<b_1) prime --prime is primelist                                         bconst=  log $ fromIntegral b_1                                         pripow = [ truncate $ bconst/log $ fromIntegral p | p<-prime_1]                                      in 3 
05:13:31 <Philippa> azaq23: there's other sugar too, yes
05:14:37 <EnglishGent> hi keep_Learning :)
05:14:40 <keep_Learning> http://hpaste.org/43121/double_conversion
05:15:09 <keep_Learning> i am getting some compiler error 
05:16:41 <parcs> keep_Learning: put parentheses around log $ fromIntegral p
05:17:18 <azaq23> bconst/log $ fromIntegral x is not bconst / (log $ fromIntegral x)
05:17:25 <mm_freak> kuffaar: i didn't
05:17:46 <keep_Learning> parcs: thank you
05:17:50 <mm_freak> kuffaar: the MVar is the message channel…  the TVar is only used for signalling
05:18:31 <keep_Learning> parcs: great 
05:18:35 <keep_Learning> parcs: :)
05:30:53 <yaxu> Philippa: interesting
05:31:32 <tac-tics> @quote
05:31:32 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
05:31:32 <lambdabot> everyone inside.
05:32:26 <tac-tics> > 1+1
05:32:26 <lambdabot>   2
05:34:59 <byorgey> norm2782: sure, no problem.  You can find the dot file here: http://code.haskell.org/~byorgey/typeclassopedia/dependencies.dot
05:37:51 <norm2782> byorgey: cool, thanks!
05:58:02 * ddarius thinks putting a dependency diagram on a single poster would be well within fair-use.
06:07:37 <kenny``> hello, i've got a very basic question, i have wo write function which returns (String -> String) but how is that possible, String would be easy but returning a function in a function? Thanks :)
06:08:25 <sipa> that's one of the essential features of functional programming
06:08:35 <sipa> the ability to use and pass around functions as normal values
06:10:02 <Bynbo7> kenny``: let me guess, you're writing a dictionary using functions?
06:10:14 <alpounet> haha
06:10:32 <Bynbo7> kenny``: if so, you're the third person this week to come asking about this assignment
06:10:44 * absentia is the 4th.
06:13:53 <kenny```> sorry consplit, did I miss anything regarding my question?
06:14:03 <absentia> yes, what was your question?
06:14:38 <quicksilver> "but returning a function in a function?" was his question.
06:14:43 <quicksilver> the answer is "Yes."
06:14:44 <kenny```> ello, i've got a very basic question, i have wo write function which returns (String -> String ) but how is that possible, String would be easy but returning a function in a function? Thanks :)
06:14:51 <Bynbo7> kenny``: let me guess, you're writing a dictionary using functions?
06:14:53 <Bynbo7> kenny``: if so, you're the third person this week to come asking about this assignment
06:14:57 <kuffaar> Haha
06:14:57 <Bynbo7> that's what i said ;)
06:15:02 <kenny```> Bynbo7: how do you know?
06:15:07 <absentia> yes, returning a function in a function is a breeze.
06:15:09 <quicksilver> let f x = \y -> y + 1
06:15:15 <dankna> that's very amusing
06:15:16 <quicksilver> ^^ look mom, my function returned a function.
06:15:20 <kenny```> Bynbo7: seriously?
06:15:22 <kuffaar> Warning: unused argument `x'
06:15:26 <Bynbo7> kenny```: yes
06:16:12 <quicksilver> kuffaar: no you see why I turn off warnings, they're stupid :P
06:16:15 <absentia> gotta love academic languages
06:16:21 <kuffaar> quicksilver wtf :| that's a good warning
06:16:22 <kuffaar> Should be _ then
06:16:44 <kenny```> Bynbo7: hehe, so is there anything that would help me?
06:17:55 <Bynbo7> kenny```: well, you haven't really explained what your problem is. but i think i can help
06:18:11 <Bynbo7> kenny```: firstly, functions that return functions are fundamental to haskell
06:18:18 <Bynbo7> the function map as this type:
06:18:20 <Bynbo7> :t map
06:18:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:18:41 <Bynbo7> now, that may look like it takes a function, and a list and returns a list, but that's not quite true
06:18:59 <Bynbo7> the type is actually (a -> b) -> ([a] -> [b])
06:19:14 <kenny```> ah, good to know
06:19:22 <Bynbo7> i takes a function from a to b, and returns another function which takes a list of a's, and returns a list of b's
06:19:31 <Bynbo7> this lets you do things like:
06:19:46 <Bynbo7> > let foo = map show in foo [1..10]
06:19:47 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10"]
06:19:57 <Bynbo7> :t let foo = map show in foo 
06:19:58 <lambdabot> forall a. (Show a) => [a] -> [String]
06:20:05 <Bynbo7> :t map show
06:20:06 <lambdabot> forall a. (Show a) => [a] -> [String]
06:20:42 <kuffaar> f :: String -> String; f _ = "I hate Haskell"
06:20:57 <kuffaar> f is a function which returns a function which takes a string and returns a string, no? :D
06:21:11 <Bynbo7> no
06:21:23 <tac-tics> > f "no"
06:21:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:21:24 <lambdabot>    `GHC.Show.Show a'
06:21:24 <lambdabot>      a...
06:21:24 <Bynbo7> it's a function that takes a string and returns a string
06:21:55 <tac-tics> > f "no" :: String
06:21:56 <lambdabot>   No instance for (SimpleReflect.FromExpr [GHC.Types.Char])
06:21:56 <lambdabot>    arising from a...
06:22:06 <tac-tics> @type f
06:22:07 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:22:25 <EnglishGent> yes - but f :: a -> String; f _ = "I love Haskell" would be a better example :P
06:22:28 <EnglishGent> :)
06:22:29 <kuffaar> Bynbo7 I was trying to make a point about partial application
06:22:47 <Bynbo7> but you were wrong ;)
06:22:53 <kuffaar> It's not like f :: (String -> String) would be any different, right?
06:22:57 <kuffaar> The ( ) is redundant
06:24:59 <kuffaar> So anything that evaluates to String -> String is basically a term which is a nullary function which "returns a function which takes a string and returns a string" :p
06:26:13 <kuffaar> And f happens to have just that type!
06:26:35 * hackagebot hashable 1.0.1.1 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.0.1.1 (JohanTibell)
06:26:49 <ski> kuffaar : do you think having to repeat the operation name for each defining equation bothersome, too ?
06:26:59 <quicksilver> kuffaar: nullary function is not a useful concept
06:27:12 <quicksilver> kuffaar: it is a function if it has (->) type. If it does not, it is not.
06:27:30 <quicksilver> it's a natural extension in a certain sense, but it's not a useful terminology.
06:27:42 <Bynbo7> your description was still wrong though
06:27:54 <quicksilver> 'a' :: Char is not a nullary function. It's a value of type Char.
06:28:42 <kuffaar> quicksilver same thing :D
06:29:08 <jkramer> Ahoy
06:29:35 <jkramer> I think there's something wrong with doesFileExist from System.Directory
06:29:39 <kuffaar> Ahoy, let's leave the ship and mate with hookers while we are on leave
06:29:47 <jkramer> It returns false for a UNIX socket here
06:30:04 <jkramer> Hookers \o/
06:30:13 <kuffaar> jkramer that sounds bad
06:30:34 <quicksilver> jkramer: doesFileExist checks if it's a regular file, I think
06:30:41 <quicksilver> that may or may not be a bug
06:30:47 <jkramer> I had a look at the source on hackage (http://hackage.haskell.org/packages/archive/directory/latest/doc/html/src/System-Directory.html#doesFileExist) and pasted it into a test.hs, and it works
06:30:50 <quicksilver> depending quite what you think the function is supposed to do :(
06:30:57 <jkramer> But I'm not sure if the version I'm running is the same
06:31:18 <jkramer> quicksilver: I want to know if the socket (which is a file) exists :)
06:31:29 <quicksilver> I understand what you want :)
06:31:34 <quicksilver> I was just wondering what it's supposed to do
06:31:36 <jkramer> The definition of doesFileExist is "does it exist and is not a directory", so I think it should fit
06:31:37 <quicksilver> maybe it got changed as you say
06:31:48 <quicksilver> what version were you running?
06:32:05 <jkramer> Not sure, what package is it in? base?
06:32:21 <quicksilver> jkramer: well, I meant what GHC version, actually
06:32:28 <quicksilver> in recent GHC's its in a package called 'directory'
06:32:34 <quicksilver> in the old ones it was in base, I think
06:32:56 <jkramer> 6.12.1 (on Linux, there's some kind of mingw windows check in the source)
06:33:51 <jkramer> I think the problem might be the "isDirectory" check, because when I test it in ghci and tab-complete the path to the socket file, ghci appends a "/" at the end of it :D
06:34:05 <kuffaar> o-o
06:34:07 <quicksilver> odder and odder
06:34:35 <kuffaar> This requires some POSIX examination
06:34:43 <kuffaar> The flags I mean
06:34:58 <kuffaar> jkramer checking out stuff in /dev might be worth it, too
06:35:04 <kuffaar> Those have interesting flags
06:35:16 <mux> just for what it's worth, 90% of the time you don't want to use stuff like isDirectory, or isFile, or whatever, or you pave the way for race conditions in your code. it's in general safer to assume that things are what you expect them to be, and handle errors graciously if the assumption is wrong
06:35:54 <kuffaar> mux: Yeah I see people who do isBlahbalh and then assume it's true without checking for errors after that :p
06:37:12 * ski still wonders what kuffaar think on multiple-equation definitions ..
06:37:29 <kuffaar> ski I'm sorry, I was distracted
06:37:40 <kuffaar> ski: I'm not sure what that means
06:37:45 <jkramer> I need to know if the socket is there though, and offer different functions to the user depending on the result. "You might try to do $foo, we'll see if it works out" isn't very userfriendly :)
06:37:46 <ski> @src length
06:37:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:37:49 <ski> bah
06:37:50 <ski> @src map
06:37:51 <lambdabot> map _ []     = []
06:37:51 <lambdabot> map f (x:xs) = f x : map f xs
06:37:55 <kuffaar> Right
06:38:01 <kuffaar> ski yeah I don't like that either
06:38:03 <ski> you have to mention `map' at the start of the lines, twice, there
06:38:08 <kuffaar> IT would be nicer if you could mention it only once
06:38:15 <ski> well, you *could* say
06:38:23 <ski>   map f xs = case xs of
06:38:27 <ski>     [  ] -> ..
06:38:32 <ski>     x:xs -> ...
06:38:34 <kuffaar> Yeah
06:39:00 <ski> (though an "anonymous case" would be even better here .. like `function' in O'Caml)
06:39:13 <kenny```> sorry, consplit again, sorr...anyting after Bynbo7 no kenny``` mh?
06:39:14 <ski> anyway, i don't think it a great burden to repeat the name
06:39:44 <ski> and in return i get the ability to read each equation in isolation, as a true statement
06:39:53 <kuffaar> ski when you decide to rename the function, you need to perform O(n) updates in the definition :'(
06:40:00 <ski> (subject to a few known gotchas, yes)
06:41:36 <ski> well, you can mark the whole definition (e.g. `M-h'), and rename all occurances there
06:42:46 <ski> (though better would be to have a semantic rename, that renamed all occurances which refer the same operation ..)
06:43:30 <kenny```> did my link hat's thdid my link http://hpaste.org/43123/dictionary reached the channel? (consplit, sorry again)
06:43:31 <jkramer> kuffaar, quicksilver: http://hpaste.org/43124/weird_doesfileexist_behavior
06:44:20 <kuffaar> Wow, you actually use infix catch :o
06:44:41 <jkramer> Nah, that's the pasted doesFileExist from http://hackage.haskell.org/packages/archive/directory/latest/doc/html/src/System-Directory.html#doesFileExist :)
06:44:48 <kuffaar> Oh, ok
06:44:55 <ski> kenny``` : rename `dictionary' to `Dictionary' .. for defined types, you need to start with an upper case letter
06:45:01 <jkramer> Well with the windows stuff removed
06:45:22 <kenny```> ski: Done :)
06:45:44 <kenny```> of course the insert-function does not work (first parameter ist the dictionary-entry, second the translation and third the dictionary) but i have no clue how to return a dictonary
06:46:12 <ski> well, a dictionary is a function that given any word (a string) gives a new word (a string)
06:46:27 <ski> presumably the input word is in one language, and the output word in another language
06:46:37 <kenny```> ski: thats right
06:46:42 <ski> look at your `empty'
06:46:49 <ski>   empty e = "not found"
06:46:53 <ski> this is the same as
06:46:58 <ski>   empty = \e -> "not found"
06:47:10 <jkramer> Can I see the doesFileExist version of GHC 6.12.1 somewhere without cloning the whole repo?
06:47:29 <ski> so `empty' is the dictionary function, that given any word `e', ignores it, and always give back the string `"not found"'
06:47:40 <quicksilver> jkramer: yes, by clicking the source links here http://www.haskell.org/ghc/docs/6.12.2/html/libraries/directory-1.0.1.1/System-Directory.html
06:48:07 <jkramer> Thanks
06:48:17 <ski> in the `insert' case, you possibly want to return something like `\e2 -> ...', where `...' is some expression that determines what word to reply, when given the `e2' word
06:48:38 <ski> > (\x -> x * x) 5
06:48:39 <lambdabot>   25
06:48:48 <ski> > map (\x -> x * x) [0,1,2,3,4,5]
06:48:49 <lambdabot>   [0,1,4,9,16,25]
06:49:21 <ski> `\x -> x * x' is a function value (sometimes called "anonymous function"), that given any number `x' gives back the number `x * x'
06:49:25 <jkramer> Can anyone reproduce the problem with the snippet I posted above?
06:49:53 <ski> kenny``` : in your case, you want to return a function value, that given any word `e2', replies with the appropriate word corresponding to that word
06:50:06 <ski> (of course you can rename `e2' to `otherWord' or whatever you like)
06:50:27 <ski> kenny``` : all clear ? :)
06:51:07 <kenny```> ski: not all of it, I think i have to read through it a few times
06:51:20 <ski> > let f = (\x -> x * x) in f 5
06:51:33 <ski> @botsmack
06:51:33 <jkramer> doesDirectoryExist "/tmp/shell-fm.sck" gives True btw, so I guess it's really the posix stat flag
06:51:49 <lambdabot> :)
06:51:52 <lambdabot>   mueval-core: Time limit exceeded
06:51:56 <ski> > let f = (\x -> x * x) in f 5
06:51:58 <lambdabot>   25
06:52:05 <ski> > let f x = x * x in f 5
06:52:06 <lambdabot>   25
06:52:17 <ski> kenny``` : do you understand how those two queries work ?
06:52:21 <kenny```> I get that so far :)
06:52:57 <ski> in both cases, the function that maps any `x' to `x * x' is given the name `f'
06:53:21 <ski> in the first one, the value `\x -> x * x' is given the name `f' directly
06:53:46 <ski> in the second one, `f' is defined implicitly, by saying what `f x' will be (for any possible `x')
06:53:58 <ski> it amounts to the same thing, it's only different styles
06:54:14 <kenny```> alrighty
06:54:21 <ski> so
06:54:52 <ski>   insert dictionaryEntry translation dictionary = \otherWord -> ...
06:55:02 <ski> would be one way to write what you want
06:55:06 <ski> another way would be
06:55:12 <ski>   insert dictionaryEntry translation dictionary = newDictionary
06:55:14 <ski>     where
06:55:24 <ski>     newDictionary otherWord = ...
06:55:46 <ski> you'll have to decide which one is clearest to you
06:56:52 <ski> (and there's more variations of this, of course .. i think probably one of the two above will be clearest, though)
06:57:47 <kenny```> that's really a great help, thank you :)
06:58:21 <kuffaar> <jkramer> kuffaar, quicksilver: http://hpaste.org/43124/weird_doesfileexist_behavior
06:58:24 <kuffaar> Odd stuff
06:58:40 <ski> (btw, to me, `word' or `inputWord' (or `englishWord' if the input is supposed to be in english) would probably be clearer than `dictionaryEntry' ..)
06:59:49 <JaffaCake1> Igloo: I'm trying to use more recent mingw tarballs and having some problems
07:00:10 <Igloo> JaffaCake1: Oh?
07:00:13 <JaffaCake1> Igloo: cc1.exe depends on a couple of the DLLs in mingw/bin
07:00:21 <JaffaCake1> I can't see how it is supposed to find them
07:00:44 <JaffaCake> we had 4.5.0, I'm trying to use 4.5.2
07:00:53 <JaffaCake> I wonder if these DLL dependencies are new?
07:01:03 <JaffaCake> libgmp, libmpc, libmpfr
07:01:05 <Igloo> Could be. It's not ringing any bells
07:01:27 <Igloo> Hmm, I did have to add those then I updated to 4.5.0, IIRC, but just adding the tarballs worked
07:01:34 <Igloo> Maybe you need a newer version of those too?
07:02:01 <kenny```> so   insert dictionaryEntry translation dictionary = newDictionary
07:02:01 <kenny```>     where
07:02:01 <kenny```> newDictionary otherWord = dictionary dictionaryEntry
07:02:01 <kenny```> should do the trick
07:03:03 <mikeg> Is there a GeoIP library that does country? the "geoip" package looks like it will only give lat/long coordinates
07:03:04 <JaffaCake> Igloo: oh wait, I think driver/gcc is supposed to fix this
07:03:49 <ski> kenny``` : well, that surely defines `insert' to give back a dictionary .. but it probably won't do what you wanted `insert' to do
07:04:07 <Igloo> Oh, sorry, looks like you're right
07:04:45 <kenny```> ski: that's to bad :)
07:04:46 <ski> kenny``` : that code doesn't use `dictionaryEntry' and `translation', so it will give the same dictionary back, regardless of what those arguments are
07:05:26 <ski> kenny``` : in fact, in that code, `newDictionary' is the *same* dictionary as `dictionary' (hm, would it be better to rename that to `oldDictionary' ?)
07:05:55 <kenny```> ski: yeah, that's right. unfortunatly I have to go now, I really appricate your help, I may come back later :)
07:05:58 <kenny```> thanks a lot
07:06:05 <ski> hm, no, sorry
07:06:13 <ski> it's not the same dictionary .. but it's still bad
07:07:43 <ski> (i misread .. you *do* use `dictionaryEntry' in the definition of `newDictionary' .. what you *don't* use is `otherWord' .. so `newDictionary' is currently a dictionary that translate *every* word `otherWord', into the *same* word (namely the one that the old dictionary translates `dictionaryEntry' to))
07:07:44 <kenny```> I'm back in two hours :-D
07:07:54 * ski is probably gone, by then
07:08:16 <ski> someone else will probably be happy to help you, though
07:08:20 * kenny``` has to deal with it, by then :)
07:08:29 <kenny```> -by
07:08:41 <kenny```> have a nice day :)
07:08:44 <ski> yw
07:10:38 <spirit> can classes contain data?
07:10:55 <ski> with the recent associated data extension, yes
07:11:14 <ski> (if by "contain data" you mean "contain `data' type declarations")
07:11:17 <ZnHxr> I'm not sure I understand the question
07:11:32 <spirit> i mean data type declarations
07:11:48 <ski> ok
07:12:16 <spirit> do i get the associated data extension via cabal?
07:12:24 <quicksilver> no, it's built in to GHC
07:12:37 <quicksilver> you just need -XTypeFamilies
07:13:30 <spirit> how would that translate to ghci usage? -XTypeFamilies i mean?
07:13:58 <ski> spirit : see <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#assoc-data-family-decl> for info ?
07:14:14 <Bynbo7> well, you can't define classes in ghci, so does it matter? you should be doing this in a file
07:14:36 <ski> `-XTypeFamilies' *is* a GHCi flag ..
07:15:54 <spirit> ghci -XTypeFamilies and then i load my module via :l filename.hs?
07:16:04 <ski> that would work
07:16:06 <ZnHxr> ghci filename.hs
07:16:19 <ski>   {-# LANGUAGE TypeFamilies #-}
07:16:20 <ZnHxr> and the file would start with {-# LANGUAGE TypeFamilies #-}
07:16:27 <Bynbo7> of you can ass {-# LANGUAGE TypeFamilies #-} to filename.hs
07:16:27 <ski> at the top of the file would be better, though
07:16:49 <ZnHxr> parse error at "of you can ass"
07:17:04 <Bynbo7> yeah, wtf?
07:17:09 <Bynbo7> or you can add
07:17:19 <spirit> :-D
07:17:26 <spirit> will try that, cheers!
07:17:28 * ski read it as "of course you can add"
07:44:43 <jkramer> Is there a function or keyword that can replace "<-"?
07:44:51 <pastorn> jkramer: >>=
07:44:56 <pastorn> @type (>>=)
07:44:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:45:09 <jkramer> Not quite what I want. :)
07:45:21 <ski> replace, how ?
07:45:24 <sipa> do { a <- b; c } is syntactic sugar for b >>= \a -> c
07:45:32 <ski> @undo do a <- b; c
07:45:32 <lambdabot> b >>= \ a -> c
07:45:33 <jkramer> I want to do something like this: let foo = [getLine, getLine, getLine] in mapM (???) foo
07:45:40 <pastorn> jkramer: do { x <- f; g x } compiles to (f >>= \x -> g x)
07:46:04 <ZnHxr> jkramer: huh?
07:46:09 <ski>   forM (replicate 3 getLine) $ \line -> do
07:46:10 <ski>     ...
07:46:11 <pastorn> jkramer: ins <- replicateM 3 getLine
07:46:12 <ski> ?
07:46:55 <spirit> when trying to add data type declarations to classes, i get a parsing error (symbol '=')
07:46:59 <pastorn> jkramer: or you could use sequence
07:47:02 <pastorn> @type sequence
07:47:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:47:06 <jkramer> getLine is a bad example I guess :)
07:47:09 <spirit> here's my code:
07:47:12 <spirit> {-# LANGUAGE TypeFamilies #-}
07:47:12 <spirit> class Test t where
07:47:12 <spirit>   data Person = Person { firstName :: String  } deriving (Show)
07:47:14 <ZnHxr> jkramer: so is mapM
07:47:18 <pastorn> jkramer: feels like you want sequence
07:47:19 <ZnHxr> jkramer: what are you actually trying to do?
07:47:27 <jkramer> Ah, sequence is what I want :)
07:47:28 <jkramer> Thanks
07:47:31 <ski> spirit : you only should add the part to the left of `=' to the `class' declaration (and then you should add a kind annotation, i think)
07:47:51 <ski> spirit : the actual `data' (or `newtype') declarations will go inside the `instance' declarations for that class
07:48:21 <jkramer> But is there something like sequence for single monads?
07:48:36 <ski> spirit : so, try `data Person :: *' or maybe `data Person t :: *' inside that `class Test t'
07:48:41 <jkramer> Just out of interest
07:48:46 <pastorn> jkramer: single monads?
07:48:46 <quicksilver> jkramer: "single monads" ?
07:48:48 <ski> what is "single monads" ?
07:48:53 <pastorn> sequence is for any monad
07:48:59 <ski> @type sequence
07:49:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:49:40 <teki> how lightweight are ghc's threads?  i.e. let's say i'm mapping a function over a list (each item in the list takes about 0.2 seconds to evaluate)
07:49:40 <teki> would i be better off grouping 10 items together and sparking them or just sparking every single one?
07:49:40 <jkramer> Well non-lists
07:49:57 <ski> @type Data.Traversable.sequence
07:49:58 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
07:49:59 <ski> that ?
07:50:13 <pastorn> teki: look into DPH for that stuff
07:50:15 <jkramer> Probably, gotta try :)
07:50:17 <quicksilver> teki: 0.2 seconds is a long time, that would be worth parallelising.
07:50:22 <Bynbo7> teki: in this case, you'd be much better off using the parallel primitives rather than concurrency
07:50:27 <quicksilver> teki: but it can be tricky to get the performance you want.
07:50:41 <quicksilver> Bynbo7: "sparking" suggests he is thinking of parallel primitives, no?
07:51:03 <teki> quicksilver: by parallel primitives is that just the stuff in control.parallel.strategies?
07:51:05 <Bynbo7> well, he asked about threads
07:51:09 <quicksilver> yes
07:51:14 <quicksilver> well sparks do use GHC threads
07:51:16 <teki> okay, that's what i figured
07:51:28 <Bynbo7> quicksilver: i thought they used something more lightweight
07:51:42 <ddarius> weather.com's estimate of snowfall for today in this area has remarkably gone from 0.4in to 2.6in now that more than an inch has fallen and it's still going strong.
07:51:42 <quicksilver> GHC threads are quite lightweight
07:51:50 <Bynbo7> i know :)
07:51:52 <ski> > runWriter (Data.Traversable.sequence (Just (tell "foo" >> return False)))
07:51:53 <lambdabot>   (Just False,"foo")
07:51:56 <quicksilver> sparks are described as being "more lightweight than threads"
07:52:00 <jkramer> Oh right, I think I was looking for "mapM (id)" :)
07:52:06 <quicksilver> but thats in the sense that you don't get a new thread for each spark
07:52:08 <jkramer> But sequence is even better
07:52:13 <quicksilver> instead they're assigned to existing threads.
07:52:24 <teki> quicksilver: that last comment makes a lot of sense
07:52:33 <teki> i didn't want to set off a bunch of threads
07:52:36 <quicksilver> I try :)
07:52:38 <teki> was my concern
07:52:40 <ZnHxr> jkramer: mapM f = sequence . map f
07:52:56 <ZnHxr> jkramer: ∴ mapM id = sequence . map id = sequence . id = sequence
07:53:18 <ZnHxr> I are an optimizing compiler
07:53:19 <spirit> how would the instance declaration of 'Person' look like?
07:53:55 <ski> spirit : for `data Person t :: *' ?
07:54:00 <spirit> yes
07:54:26 <quicksilver> I do have a slight concern that spirit is laboring under a misapprehension about what classes are for.
07:54:41 <quicksilver> it looks a bit like you're trying to do something like a java class.
07:54:50 <Bynbo7> this is a bad thing!
07:54:51 <ski> well .. that *could* be, yes
07:55:09 <spirit> i'm trying to write a MAUDE module / theory in haskell
07:55:34 * ski assumed spirit already knew the basics about type classes, when asking about associated data types
07:55:46 <ddarius> ski: That's silly.
07:56:03 <ski> ddarius : in retrospect, yes, it probably was
07:56:53 <quicksilver> I hadn't heard of maude before
07:56:54 <quicksilver> interesting.
07:57:03 <quicksilver> I suspect you're beter off just encoding that as a type, not a class.
07:57:17 <ddarius> quicksilver: The OBJ family is interesting in general.
07:57:22 <spirit> In MAUDE there are 'sorts' and 'operations' (+ ...)
07:58:53 <kuffaar> readFile is lazy IO hmm
07:59:08 <kuffaar> But with files that's not as problematic as it is with sockets, right?
07:59:17 <kuffaar> People kept on warning me about lazy IO in here
07:59:47 <ddarius> @google "higher order functions considered unnecessary for higher order programming"
07:59:48 <lambdabot> http://cseweb.ucsd.edu/~goguen/pps/utyop.ps
08:00:40 <copumpkin> "'considered' in title considered pretentious way of making point"
08:00:47 <spirit> would i just put data type declarations inside modules?
08:01:18 <spirit> i tried my best to understand that paper, but didn't manage
08:01:55 <spirit> it seems haskell is more versatile and general purpose than MAUDE
08:01:57 <spirit> (OBJ)
08:02:14 <spirit> i therefore try to translate stuff i need to implement to haskell
08:03:37 <ddarius> copumpkin: The real title is "Higher order functions are hard to model algebraically, so we'll just say you didn't want them anyway," but the editor felt that that was too length.
08:03:40 <ddarius> +y
08:03:46 <copumpkin> lol
08:03:47 <ski> spirit : yes, if you're not wanting anything special/advanced, data type definitions would just go into your modules directly
08:04:34 <spirit> will try that, ski, thanks!
08:07:36 <EnglishGent> hi copumpkin :)
08:07:46 <copumpkin> hi EnglishGent! it's been a while
08:07:52 <EnglishGent> it has! :|
08:10:11 <kuffaar> Hmm I need to process like 100 MiB of plain text, using readFile and String isn't a great idea for that is it since String uses 40 bytes per Char on AMD64, right?
08:10:27 <ZnHxr> depends on how you process it
08:10:30 <pastorn> kuffaar: what's the data? text or binary stuff?
08:10:34 <kuffaar> Text
08:10:46 <kuffaar> It's markup :[
08:10:48 <pastorn> kuffaar: you *can* use attoparsec
08:10:48 <kuffaar> HTML
08:10:54 <pastorn> oh, there's tagsoup
08:10:58 <kuffaar> Yeah
08:10:59 <pastorn> which i think is pretty fast
08:11:01 <kuffaar> I want to use tagsoup
08:11:09 <kuffaar> Oh can it read files on its own?
08:11:30 <pastorn> kuffaar: you probably want to use it with Data.ByteString.Lazy
08:11:39 <Bynbo7> bloody hell, 100MB of HTML?
08:13:00 <kuffaar> parseTags hmm
08:13:27 <pastorn> kuffaar: if you use a strict bytestring you have to load your data into RAM completely before parsing
08:13:47 <pastorn> might be faster, but personally i like lazyness more :)
08:14:37 <kuffaar> Well, the fastest way would be to use a concurrent producer consumer model
08:14:56 <kuffaar> Where one thread continuously reads new stuff up a certain limit
08:15:30 <pastorn> kuffaar: STM for the winz
08:15:50 <kuffaar> I've used TVar before, but I'm not sure I really grasp it
08:16:02 <kuffaar> I just copied it off mm_freak
08:16:05 <arcatan> sounds like an use-case for enumerator
08:16:10 <Bynbo7> the fastest way would be to use iteratees ;)
08:16:20 <pastorn> kuffaar: in this case you might want to use TChan
08:16:44 <kuffaar> Well, it's probably no big deal, you can probably parse this in like 2-3 seconds lol
08:17:00 <kuffaar> HDD reads at 80 MiB/s and CPU/memory are nto the bottleneck
08:17:35 <kuffaar> But with String it could be :p
08:18:17 <Bynbo7> yes
08:18:36 <Bynbo7> if there's a parser that can use bytesterings or text, then use those.
08:18:47 <Bynbo7> an html parser
08:18:56 * Bynbo7 -> sleep
08:19:03 <kuffaar> What's the difference between Text and ByteString?
08:19:19 <Bynbo7> encodings
08:19:50 <spirit> it's one module per file, right?
08:20:45 <elliott> What's the "best practice" for getting and formatting datetimes? The built-in time package?
08:24:16 <kuffaar> Prelude Text.HTML.TagSoup> :t parseTags
08:24:17 <kuffaar> parseTags :: Text.StringLike.StringLike str => str -> [Tag str]
08:25:08 <edwardk> hrmm what is the timeline on ghc 7 being in the platform?
08:25:10 <kuffaar> What is StringLike :o
08:26:45 <edwardk> mostly curious because i was looking to release a new version of the speculation library with support for numSparks
08:28:02 <pastorn> kuffaar: it's for OverloadedStrings
08:28:12 <pastorn> -XOverloadedStrings
08:28:54 <kuffaar> Not familiar with that either
08:29:31 <pastorn> google it ;)
08:32:07 <quicksilver> -XOverloadedString has a class called IsString
08:32:18 <quicksilver> StringLike is a similar idea but not the same class.
08:32:39 <quicksilver> http://hackage.haskell.org/packages/archive/tagsoup/0.8/doc/html/Text-StringLike.html
08:32:48 <quicksilver> IsString is really about overloading constants though.
08:34:00 <edwardk> IsString makes very pretty parsers
08:36:20 <kuffaar> WARNING: This module is not intended for use outside the TagSoup library. 
08:40:11 <quicksilver> right.
08:40:48 <kuffaar> Ah, StringLike ByteString
08:41:01 <kuffaar> http://hackage.haskell.org/packages/archive/tagsoup/0.8/doc/html/Text-StringLike.html
08:41:08 * hackagebot List 0.4.1 - List monad transformer and class  http://hackage.haskell.org/package/List-0.4.1 (YairChuchem)
08:41:09 <kuffaar> Why does it have two instances for ByteString?
08:41:20 <kuffaar> Is that because the lazy and the strict one have the same name?
08:41:40 <ZnHxr> preflex: 8ball Is that because the lazy and the strict one have the same name?
08:41:40 <preflex>  as I see it, yes
08:42:45 <kmc> grr bytestrings are not string-like at all
08:42:53 <tac-tics> Today class, we're going to learn about lazy evaluation. Any questions?
08:43:28 <kmc> ByteString.Char8 is such a lie
08:43:51 <ZnHxr> but necessary for many things
08:43:59 <copumpkin> I disagree
08:44:18 <edwardk> kmc: only if you care about appending
08:45:01 <edwardk> the problem that i have with classes like stringlike is that they lead to bad assumptions about how to work with something, since they tell you absolutely nothing about the asymptotics of each operation
08:45:10 * hackagebot ListTree 0.2.0 - Trees and monadic trees expressed as monadic lists where the underlying monad is a list  http://hackage.haskell.org/package/ListTree-0.2.0 (YairChuchem)
08:45:12 * hackagebot sbv 0.9.7 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.7 (LeventErkok)
08:49:11 * hackagebot hubigraph 0.3.2 - A haskell wrap for Ubigraph  http://hackage.haskell.org/package/hubigraph-0.3.2 (KoheiOzaki)
08:51:42 * ddarius doesn't want to use an HttpModule.
08:54:15 <edwardk> ddarius: so now that you have a comonad-to-monad, for an encore, a monad-to-comonad? =)
08:54:57 <krey_> hello, [] is a functor right? so what do you call (:[])?
08:55:04 <quicksilver> a monkey.
08:55:10 <krey_> :)
08:55:15 <conal> krey_: pure
08:55:16 <quicksilver> The two [] are different in that sentence.
08:55:19 <krey_> no, seriously, trying to get my head around these
08:55:22 <ddarius> edwardk: It's also a monad-to-comonad transformer if you view it in the op category.
08:55:26 <conal> krey_: because [] is also an applicative functor
08:55:30 <quicksilver> the [] which is a functor is the *type* constructor.
08:55:36 <edwardk> [] at the type level is a Functor, [] at the term level is just a constructor
08:55:41 <quicksilver> I.e., the thing that takes you from Int to [Int]
08:55:46 <edwardk> ddarius: in Hask ;)
08:56:01 <quicksilver> the [] in (:[]) is just a value - the empty list.
08:56:28 <krey_> quicksilver, conal: cool, so it's an applicative functor, what's the definition of that?
08:56:44 <krey_> (in category theory)
08:56:46 <ZnHxr> [] is an applicative functor
08:56:51 <edwardk> @google Control.Applicative
08:56:52 <lambdabot> http://users.skynet.be/jyp/html/base/Control-Applicative.html
08:56:53 <lambdabot> Title: Control.Applicative
08:57:25 <conal> krey_: it's like Functor but with a symmetric counterpart to fmap
08:58:16 <krey_> conal: could you be more precise? is it a natural transformation?
08:58:42 <ddarius> edwardk: If you can make a left adjoint to Either a in Hask, I believe I can make you a monad-to-comonad transformer in Hask.
08:59:16 <conal> krey_: closely related to strong lax monoidal functor, iirc. explained in the Applicative paper. digging up ...
08:59:19 <ddarius> Actually, I don't think that's true.
08:59:29 <conal> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
08:59:30 <ddarius> The variances don't come out right.
08:59:36 <conal> krey_: ^^
09:00:06 <Saizan> krey_: you can see pure :: a -> f a as a natural transformation 1 -> F, where 1 is the identity functor
09:00:08 <edwardk> ddarius: well you could use Ran Either Identity ;)
09:00:10 <edwardk> =/
09:00:40 <krey_> Saizan: thank you, that is what I was looking for
09:00:42 <Saizan> krey_: functors F with such a natural transformation are called pointed
09:01:02 <conal> ah yeah. Applicative is overkill.
09:01:15 <krey_> conal: thank you too, paper saved for later, now must focus on the maths side
09:01:29 <conal> :)
09:01:37 <tac-tics> @type fix id
09:01:38 <lambdabot> forall a. a
09:01:50 <tac-tics> Blasphemy, lambdabot!
09:01:51 <krey_> @type undefined
09:01:52 <lambdabot> forall a. a
09:02:11 <tac-tics> @type error id
09:02:12 <lambdabot>     Couldn't match expected type `[Char]'
09:02:12 <lambdabot>            against inferred type `a -> a'
09:02:13 <lambdabot>     In the first argument of `error', namely `id'
09:02:17 <tac-tics> @type error ""
09:02:18 <lambdabot> forall a. a
09:02:43 <tac-tics> @type unsafeIO
09:02:44 <lambdabot> Not in scope: `unsafeIO'
09:03:26 <kenny```> ski: I'm back, are you already gone?
09:04:34 * conal just noticed that flattr connects to twitter. nice.
09:05:15 * hackagebot peakachu 0.3.0 - Experiemental library for composable interactive programs  http://hackage.haskell.org/package/peakachu-0.3.0 (YairChuchem)
09:07:22 <ddarius> Actually, the variances are right, so, yeah, you could do it with a left adjoint to Either a, which would, itself, be adjoint to itself on the left.
09:07:42 <edwardk> ddarius: so does Ran Either Identity work for your purposes?
09:07:48 <edwardk> as that left adjoint?
09:09:58 <ddarius> Well, general properties of adjoints and can extensions say that that (with an extra argument to Either) would be the left adjoint -iff- it is preserved by Either a.  But I'm pretty sure Haskell doesn't have a left adjoint to Either a as that would be a (first-class) continuation operator.
09:10:09 <ddarius> You could do it in the Cont Kleisli category though.
09:10:19 <edwardk> fair enough
09:11:07 <edwardk> okay, i'm happy enough with a reason for its absence in that form, same reasoning as strength and costrength, etc.
09:15:55 <teki> if i want a strict data type defined using record syntax, would i do data MyType = MyType {field1 :: !Int, field2 :: !Int}?
09:16:56 <Saizan> yes
09:17:03 <teki> alright, thanks
09:22:09 <krey_> Saizan: what categories is [] a functor between?
09:22:58 <lunaris> krey_: Do you mean other than Hask and Hask?
09:23:04 <lunaris> (IANACT)
09:23:28 <krey_> lunaris: I mean, mathematically
09:23:33 <Saizan> krey_: Hask and Hask :) where Hask is the category with haskell types as objects and haskell functions as arrows
09:23:48 <lunaris> krey_: Then I have no idea =D
09:24:28 <conal> krey_: i'd look to domain theory for the answer
09:24:59 <krey_> conal: I no nothing about that, but sure, how?
09:25:03 <Saizan> krey_: in a more general settings it could be seen as Set -> Set or Set -> Mon
09:25:06 <edwardk> krey: [] is an 'endofunctor' on Hask, it maps functions in haskell to functions in haskell (that just happen to manipulate lists elementwise) 
09:25:17 <conal> krey_: google for "domain theory" and "denotational semantics"
09:25:22 <edwardk> :t fmap
09:25:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:25:24 <edwardk> :t map
09:25:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:25:45 <Saizan> i'm not sure why domain theory would help here specifically
09:25:48 <edwardk> map takes an arrow in Hask (a -> b) and gives you another arrow in Hask ([a] -> [b])
09:26:16 <conal> krey_: denotational semantics maps from syntax (and more broadly) to semantics. 
09:26:39 <conal> krey_: provides a nice math foundation for programming languages.
09:27:32 <edwardk> conal: its also a good way to make a newbie run away screaming ;)
09:27:58 <conal> edwardk: even one looking for a math pov?
09:27:59 * krey_ aint no newbie
09:28:07 <Saizan> a formalist from a meta level above would say that it maps syntax to another syntax :)
09:28:09 <edwardk> no offense intended, krey
09:28:48 <krey_> Saizan: :)
09:29:09 <edwardk> saizan: =)
09:30:04 <conal> Saizan: yep. originally from language X to the lambda calculus.
09:30:47 <krey_> Saizan: so, how do other type functions come into the picture?
09:30:59 <krey_> (other than [])
09:31:03 <kenny```> hi, I have to write a function insert which returns a new dictionary (http://hpaste.org/43125/dictionary) but I cant figure out how to return a type Dictionary instead of a String, thanks :)
09:31:14 <edwardk> i wish there was a better name than 'Contravariant Yoneda lemma" or "Coyoneda"
09:31:55 <conal> krey_: denotational semantics will give you a handle on functional programming if you stay away from things like IO. what's left is what's sometimes called "denotative programming".
09:32:20 <monochrom> we're talking about the [] functor not the [[]] functor.
09:32:42 <krey_> conal: is it like lambda calc? cos I can do that
09:33:08 <ZnHxr> kenny```: do you know the \x -> ... syntax?
09:33:30 <kenny```> heard of it
09:33:54 <kenny```> like empty = \anyEntry -> "not found"
09:33:57 <ZnHxr> well, that's how you write functions
09:34:02 <ZnHxr> and Dictionary is a function
09:34:05 <hpc> kenny```: \x -> x is a function that takes an x and returns it
09:34:11 <hpc> so id = \x -> x
09:34:25 <ZnHxr> newDictionary = \query -> ...
09:34:29 <hpc> generally, f x = foo can be translated to f = \x -> foo
09:34:41 <monochrom> and especially since no one has brought up "what are the fixed points of the [] functor" there is no need to bring up domain theory.
09:35:04 <conal> krey_: closely related, especially in it origin. Chris Strachey was giving semantics to languages by mapping them into the (untyped) lambda calculus. but no one had yet found a model for the lambda calculus. Dana Scott discovered a model, now called "domain theory" (which has evolved since Dana's first lattice-oriented version).
09:35:33 <conal> krey_: The discipline is called "denotational semantics" or "Strachey-Scott semantics".
09:35:41 <krey_> monochrom: now you have :) are there any?
09:35:50 <ZnHxr> for the people playing along at home, here's the problem kenny``` is trying to solve: http://mauke.dyndns.org/tmp/Blatt10.pdf
09:36:11 <monochrom> I don't know
09:36:32 <krey_> conal: sounds funky, I went to one of Scott's lectures, didn't understand anything, but it was really cool
09:36:36 <kenny```> ZnHxr: newDictionary as a new function and query as param?
09:36:45 <krey_> conal: where can I read about this? and how much math do I need?
09:37:01 <ZnHxr> kenny```: yes
09:37:19 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85371 summarizes denotational semantics
09:37:27 <conal> krey_: i don't know what book to recommend. i learned from joe stoy's book in the mid-80s. dated now.
09:37:53 <kenny```> and query does only contain the newInput or more?
09:38:03 <ZnHxr> kenny```: huh?
09:38:14 <ZnHxr> kenny```: ah, you haven't written lookup yet
09:38:22 * hackagebot zlib-enum 0.0 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.0 (MalteSommerkorn)
09:38:29 <kenny```> No I haven't
09:38:32 <Saizan> krey_: most "type functions" you can define in Haskell98 end up being functors between Hask, Hask^op or products of those
09:38:35 <ZnHxr> kenny```: do that first
09:38:48 <krey_> conal: :(, also, I don't understand what you mean by a 'model' for lambda calculus
09:39:18 <kenny```> alright. The linked pdf isn't mine (seems to of one of my fellow students)
09:39:20 <Saizan> krey_: when you add TypeFamilies and/or GADTs it's more complicated
09:39:59 <ZnHxr> kenny```: if you look in the logs, this question has come up a few times in the last days :-)
09:40:11 <conal> krey_: a mathematical domain. e.g. a set of values that correspond to meanings of terms of a formal language, e.g. of the lambda calculus
09:40:41 <kenny```> ZnHxr: I just joined today, there aren't any logs online, are there?
09:41:08 <quicksilver> kenny```: /topic
09:41:40 <kenny```> quicksilver: oh nice, thanks :)
09:41:42 <maltem> or http://irclogs.ls-themes.org/freenode/haskell/ if you like more color
09:48:25 <EvanCarroll> So, Warp is planning on giving snap-server a run for its money
09:48:35 <ddarius> edwardk: Note that any adjunction whose right adjoint is Hask -> Hask^op will work to produce a monad-to-comonad transformer.
09:49:17 <krey_> anyone know a good book on domain theory?
09:50:01 <conal> krey_: btw, you might discover some of these same notions if you ask yourself the question "what does it mean?" when looking at languages.
09:50:10 <ddarius> Most books wouldn't be on domain theory itself.
09:50:41 <conal> krey_: "what kinds of things are meant by expressions in this language?" and work toward math-style precision. start simple, e.g. with a simple language of boolean or arithmetic expressions.
09:50:49 <edwardk> ddarius: yeah, i just don't have any of those lying around =)
09:50:50 <krey_> ddarius: ok, what would you recommend on semantics of computation / lambda calc / etc?
09:51:37 <krey_> conal: i don't really get what you mean. I was taught that lambda calculus doesn't really 'mean' anything, (as opposed to say FO logic)
09:51:38 <hatds> you might start with the haskell wikibook
09:51:58 <ddarius> That seems silly to me.
09:52:06 <conal> krey_: wow. doesn't mean anything? really?
09:52:22 <ddarius> krey_: Hopefully noone shows you type theory.  Then first-order logic will cease to mean anything.
09:52:25 <hatds> a wiki of any sort will tend to reference textbooks too.  preview those books in google books if you are curious which ones are worth reading
09:52:39 <ray> it's all meaninglesssssss
09:52:53 <krey_> ddarius: :D, why?
09:53:08 <EnglishGent> krey_ - have you come across the Curry-Howard isomorphism? 
09:53:11 <conal> krey_: try this book (free online): http://people.cis.ksu.edu/~schmidt/text/densem.html .  i haven't read it but have heard it recommended.
09:53:29 <ddarius> krey_: Because first-order logic corresponds to a particular typed lambda calculus.
09:53:34 <krey_> EnglishGent: yes, and I'm also english :)
09:53:39 <ray> (as people around here are fond of pointing out)
09:53:45 <EnglishGent> ok - just wondering :)
09:53:57 <hatds> krey_: well it does and doesn't mean anything. You have to take a step back and say "OK, but we obvious want some rigorous way of ascribing familiar programming notions to these lambda functions"  e.g. "what's the analogue of a non-terminating program for lambda functions?"
09:54:16 <krey_> ddarius: sure, without the "inappropriate" rules
09:54:26 * hackagebot DefendTheKing 0.3 - A simple RTS game  http://hackage.haskell.org/package/DefendTheKing-0.3 (YairChuchem)
09:55:11 <krey_> conal: thanks, i'll take a look
09:55:23 <conal> krey_: enjoy!
09:56:18 <krey_> conal: I meant to say, when we were doing lambda calculus, we just said, you don't have to worry about what all of this means, it's just syntax
09:56:20 <azaq23> isn't lambda calculus also equivalent with basic set theory? church numerals instead of set theoretic construction of the naturals, etc. There is also a formulation of russels paradox in the untyped lambda calculus
09:56:50 <jmcarthur> "<edwardk> conal: [denotational semantics is] also a good way to make a newbie run away screaming ;)"  <-- i think this is a problem of presentation, not of material
09:57:03 <ddarius> azaq23: Naive set theory can be expressed with a lambda calculus-like notation with the addition of some constants for FOL operations.
09:57:05 <conal> krey_: oh! not that it doesn't mean anything; rather the class wasn't about meaning.
09:57:25 <jmcarthur> then again, most of math is feared due to presentation more than material, so i guess there's nothing unique about domain theory
09:57:30 <conal> i like the answers given on http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85371
09:58:00 <ddarius> jmcarthur: It depends on how detailed you go.  The general idea is straightforward.  The details of bounded, algebraic, directed-complete partial orders, can be a bit technical...
09:58:02 <edwardk> jmcarthur: perhaps. i just find its easier to build intuition, then pound rigor than the converse, but conal and I are sort of yin and yang on this aspect. ;)
09:58:08 <conal> jmcarthur: i think so also (issue of presentation)
09:58:19 <EnglishGent> I agree jmcarthur - but at the same time I find an *awful* lot of math to be presented badly :|
09:58:21 <krey_> conal: when we did propositional logic, we were told that a proposition is basically a sentence, etc. so proofs actually correspond to some sort of natural reasoning
09:58:58 <ddarius> krey_: And what does "natural reasoning" mean?
09:59:02 <conal> edwardk: hm. i think of myself as working that way also: starting with intuition and filtering with rigor.
09:59:27 <j-invariant> hello
09:59:33 <conal> edwardk: do you mean you see me poking more on rigor with newbies that you would?
09:59:36 <krey_> ddarius: come on, this was just an introduction to the whole thing :)
09:59:43 <EnglishGent> ddarius - reasoning badly? 
09:59:56 <EnglishGent> that *seems* to be the most common mode of reasoning..... :|
10:00:09 <edwardk> conal: yeah, but i don't see that necessarily as a bad thing — more of a good cop, bad cop thing ;)
10:00:50 <conal> edwardk: ah. still, i'll keep an eye on myself. thx for the feedback. and i like the good cop, bad cop image. :)
10:00:53 <ddarius> krey_: Yes, but explicating "natural reasoning" was one of the purposes of logic in general.
10:01:03 <conal> edwardk: just checking: i'm the bad cop, right?
10:01:21 <j-invariant> conal: you are both
10:01:23 <jmcarthur> conal: i think there's something significant about how you phrased it compared to how edwardk phrased it, myself. edwardk said "pound" it with rigor, and you said "filter" it with rigor. it sounds like edwardk is talking more about formalizing existing ideas and you are talking more about distilling them.
10:01:26 <Cin> jmcarthur: I was thinking about that the other day (re presentation), and how monad bafflement among the programmer demographic is ubiquitous
10:01:29 <conal> heh
10:01:48 <krey_> ddarius: of course! but what does lambda calculus explicate then? is this a question model theory answers? fixpoints 'n stuff?
10:01:52 <jmcarthur> not to make one sound better than the other
10:02:33 <Cin> jmcarthur: (that is, it's not that the material is hard, but the wishy washy presentation by analogy crap)
10:02:38 <edwardk> conal: if you have to ask… ;) 
10:02:40 <j-invariant> model theory is about the symmetry of the undescribable 
10:02:50 <ddarius> krey_: You should definitely check out the Curry-Howard correspondence which was mentioned earlier.  One perspective is that (typed) lambda calculi correspond to the proof theory of a logic.
10:03:00 <azaq23> ddarius: FOL means first order logic? Isn't there some equivalent formulation along the lines of this http://www.csse.monash.edu.au/~lloyd/tildeFP/Lambda/Examples/const-bool/, although this link doesn't define quantification? Anyway, thanks
10:03:01 <conal> jmcarthur: ah, thx.
10:03:04 <j-invariant> nothing to do with curry howard
10:03:06 <edwardk> conal: oh, i started working on a sort of 'imperative reactive programming' framework for haskell
10:03:14 <jmcarthur> Cin: well, there's a flip side too. showing people a bunch of symbols and saying "it's obvious" isn't a great presentation either
10:03:20 <conal> edwardk: eep!
10:03:26 <Twey> Heh
10:03:28 <edwardk> conal: speaking of yin and yang ;)
10:03:31 <conal> edwardk: with or without semantics?
10:03:31 <ddarius> edwardk: I don't think there's anymore room in that category on Hackage.
10:03:51 <Twey> e^(iτ) = 1.  Clear?
10:03:52 <krey_> ddarius: I 'know' the Curry-Howard correspondence! yes, if you go with truth means provability, then sure
10:04:05 <edwardk> conal: https://github.com/ekmett/reactor/blob/master/Reactor/Observable.hs
10:04:12 <EnglishGent> jmcarthur - no, but in maths it's tradditional :P
10:04:20 <jmcarthur> Cin: i think a lot of math just lacks simple, clear *explanations* of the simple, clear definitions
10:04:25 <edwardk> conal: thats more your axe to grind than mine, the semantics are pretty much those of the .net reactive framework though
10:04:35 <hatds> Monads are pretty wishy washy in any you teach them though.  'Monad' is a word to describe a class of things which is very easy to describe but whose description (return & bind) is unfulfilling.
10:04:38 <jmcarthur> EnglishGent: and that's the problem. we talk about the facts without talking about the significance
10:04:43 <ddarius> .NET, always a good place to go for semantics.
10:04:46 <hatds> hence all the analogies
10:04:46 <edwardk> conal: that version is a bit dated, i should upload a more recent version
10:04:57 <jmcarthur> and i don't mean "significance" necessarily in a "real-world" way
10:05:09 <edwardk> but it at least gives the idea, all the imperative machinery gets walled up behind the Observable monad, and you wire it up with Observers.
10:05:18 <edwardk> ddarius: =)
10:05:28 <conal> edwardk: i don't know whether the .net reactive framework has what i'd call semantics, but i think i get your meaning.
10:05:32 * hackagebot zlib-enum 0.1 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.1 (MalteSommerkorn)
10:05:39 <jmcarthur> hatds: it's not wishy washy. it's well-defined. it's just intangible
10:05:44 <tlonim> in haskell fix is the y-combinator right ?
10:05:49 <j-invariant> tlonim: no
10:05:50 <jmcarthur> tlonim: it's a primitive
10:05:57 <jmcarthur> or rather, not even that
10:05:58 <tlonim> oh.
10:06:01 <j-invariant> tlonim: they have the same semantics
10:06:05 <edwardk> conal: basically i was just attempting to distill it to something i could do task-parallel programming in haskell with.
10:06:07 <jmcarthur> it's just part of the language, i should say
10:06:16 <tlonim> then what is the equivalent ? I mean it also finds the fixed point of a function right ?
10:06:18 <hatds> jmcarthur: the unfulfilling part makes it wishy washy
10:06:29 <ddarius> edwardk: I'm actually thinking implementing something like workflows in Haskell might be a bit fun.
10:06:31 <j-invariant> tlonim: they have the same semantics so they are "equivalent" but they are different things
10:06:37 <hatds> jmcarthur: for a narrow sense of wishy washy
10:06:40 <maltem> @source fix
10:06:40 <lambdabot> fix not available
10:06:41 <tlonim> j-invariant: ok
10:06:41 <edwardk> so more the bastard child of intel's thread building blocks, .net reactive and scala's actors
10:06:42 <conal> edwardk: cool.  and point taken" precise semantics (especially denotational) is my axe to grind. i sometime forget it isn't everyone's.
10:06:49 <conal> (taken: ...)
10:06:49 <j-invariant> tlonim: do you know what exactly the y-combinator is?
10:06:58 <tlonim> j-invariant: just reading now :)
10:07:02 <ZnHxr> @src fix
10:07:02 <lambdabot> fix f = let x = f x in x
10:07:08 <tlonim> j-invariant: but what i am reading is in scheme ..so was checking
10:07:17 <j-invariant> tlonim: so you can't write it in haskell, yes I was just going to recommend trying scheme
10:07:27 <tlonim> j-invariant: oh.
10:07:30 <conal> the use haskell as a playground for imperative programming breaks my heart.
10:07:30 <Cin> jmcarthur: sure, the flip side is just as bad
10:07:38 <edwardk> sok. i like having semantics, but i don't typically start from the semantic and seek a model. i seek an efficient model and then try to figure out if i can live with its semantics ;)
10:07:57 <ddarius> One thing j-invariant is getting at is that the Y combinator is a particular lambda term, and not, technically, the function it represents, though people often use it that way.
10:08:22 <edwardk> conal: then whatever you do don't look in Reactor.Deque ;)
10:08:23 <j-invariant> ddarius: yes and also that the fact 'fix' has the same semantics as y-combinatior is a deep theorem of semantics
10:08:31 <maltem> jmcarthur, fix could be a primitive, but for Haskell they chose to have its functionality implicit in (recursive) let
10:08:33 * hackagebot parallel-io 0.3.2 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.3.2 (MaxBolingbroke)
10:08:49 <conal> edwardk: okay, i won't.
10:09:20 <jmcarthur> maltem: well, it's kind of implicit in ghc's graph reduction strategy, is what i was really getting at, although that's not specifically answering the question i admit
10:09:42 <ddarius> maltem: Actually, fix couldn't quite be a primitive with the same power as recursive let unless it was made even more special than just a given function.
10:09:54 <conal> edwardk: do you care about whether you get deterministic semantics or not?
10:10:50 <edwardk> this is actually quite consciously non-deterministic in some areas because it relies on work-stealing and task splitting, so determinism can only be preserved by whether or not users of the library comply with certain restrictions on their operations (associativity, etc.)
10:10:56 <Cin> jmcarthur: I think it's an audience problem. you don't know who your audience is. I tried to read the Ur paper but realised I had no idea what any of it meant or the reasoning behind it, which, it appears, is supposed to be obvious or otherwise the paper needs an accompaniment. if I learn some type theory I'll probably be familiar with what it's talking about
10:11:38 <jmcarthur> conal: i once considered what it would be like if there was a pure, functional language that was intended to be used in tandem with an imperative language for all IO rather than pushing the IO into it at all. that is, the only way to make it interact with the real world is to call into it from an imperative language. that way it would clean the language much cleaner and make the imperative stuff seem 
10:11:40 <jmcarthur> (rightly) all that more ugly
10:12:20 <jmcarthur> *it would keep the language much cleaner
10:12:43 <conal> edwardk: aside from associativity, how about simultaneous (or near-simultaneous) event occurrences? i don't think imperative systems usually get determinism (well-definedness) with simultaneity.
10:12:57 <edwardk> the gist is i have a 'Task' monad which provides access to spawning work and making it happen eventually, but when you spawn something it can be stolen and split if another cpu is idle. my main goal is being able to productively leverage all of the available computational resources.
10:13:53 <edwardk> with regards to those, i consistently use atomic flags to ensure the protocol isn't violated even in the presence of simultaneous event firings. if you need your Observer to be serialized you can implement it as an Actor.
10:14:30 <conal> edwardk: cool. i'm glad you're thinking through determism.
10:14:40 <edwardk> the protocol is basically that each observable will fire a number of messages with (!), and optionally terminate with a break or a handle for an exception at each observer.
10:15:28 <edwardk> any desired synchronization or prevention of simultaneous event-firings is the job of the observer, though combinators are present to serialize, etc.
10:15:59 <edwardk> and if you just want some kind of Moore machine or actor you can lean on built-in plumbing for that
10:16:40 <edwardk> other combinators can be used to 'fix' observables that violate protocol, etc.
10:18:11 <hatds> jmcarthur: but there would be nothing stopping people from then using an imperative language with a notion of (IO a) values... the only difference would then be that the (IO a) values and the pure values live in different languages
10:18:42 <hatds> jmcarthur: which is not really any different than having them both be values of a common language separated by a type system
10:19:25 <edwardk> hatds: except that you can use the same combinators on IO actions as you can on any other monad
10:19:44 <hatds> hmm
10:19:59 <edwardk> removing the magic from IO is one of Haskell's best tricks
10:20:41 <pheaver> has anyone seen this when running cabal sdist on a vmware filesystem (sharing the host filesystem with the guest): cabal: dist/src/sdist.28862/foo-0.1/foo.cabal: permission denied
10:20:42 <hatds> but the complaint is that it is a *trick* I guess
10:20:48 <jmcarthur> no
10:21:07 <edwardk> hatds: well, it doesn't have to be a trick. you could instead have IO as a free monad, that just happens to have an interpreter in the compiler
10:21:08 <pheaver> (it always happens when i run cabal sdist on a vmware filesystem)
10:21:38 <jmcarthur> the complaint is that people are declaring the problem that you can't interact with the real world in pure, functional code yet as "solved" just because you can write imperative code in a functional language
10:21:43 <edwardk> data IO a = GetChar (Char -> IO a) | PutChar Char (IO a) | ...
10:22:12 <jmcarthur> my proposal is to discourage people from prematurely reaching that conclusion
10:22:14 <edwardk> then evaluating a program is just folding over that data structure
10:23:33 <conal> jmcarthur: i'm glad.  same reason i wrote http://conal.net/blog/posts/the-c-language-is-purely-functional/
10:23:37 <jmcarthur> IO is the embodiment of imperative programming, embedded into a pure, functional language. rather than an alternative to imperative programming as haskell advertizes, we have simply embraced it.
10:24:18 <edwardk> jmcarthur: admittedly with some minor modifications, since it is much easier to talk about composing said IO actions
10:24:20 <hatds> jmcarthur: so you don't want to admit an interpretation of the problem that implies it has been solved with the "IO (non)-solution", but you want to admit an interpretation of the problem which isn't inherently unsolvable?
10:24:30 <conal> my beef with the idea that haskell "solves functional I/O" with haskell's IO is that IO just recreates the essential problems of imperative programming.
10:24:43 <jmcarthur> edwardk: that's true. we have gained some advantages over most other imperative languages due to the separation of evaluation from execution
10:24:43 <conal> which are semantic in origin.
10:24:59 <absentia> ya, god forbid computing ever had a need for anything as silly as I/O
10:25:12 <hatds> that's not the point
10:25:36 * absentia is just in a grouchy mood today... please ignore me.
10:25:42 <hatds> the point is if we should stop "setting our sights on better ways to do IO" essentially
10:25:48 <conal> computing might need I/O in its implementation. maybe not in its interface & semantics
10:25:49 <edwardk> clearly, you should run your program, and if it terminates, it answered yes, and if not, it answered no. so run it and its negation in parallel on two machines and you can answer questions!
10:25:52 <tac-tics> Plus, it keeps the lesser programmers away
10:25:57 <conal> hatds: exactly.
10:26:07 <edwardk> =)
10:26:15 <absentia> the halting problem is boring.
10:26:15 <ray> avoid success
10:26:39 <jmcarthur> hatds: the problem is "pure, functional languages can't interact with the outside world." the current solution is "then we'll just generate imperative code as a DSL." the problem i have with the solution is the "imperative" part. it's no longer pure, functional.
10:26:40 <edwardk> hatds: i'm all for better ways to tackle IO, the current sin-bin is hideous
10:27:03 <hatds> conal, jmcarthur: but what interpretation of "the IO problem" allows a solution that is in any way better?
10:27:14 <jmcarthur> hatds: and it comes with the same problems as other imperative languages. interleaving concurrency, etc.
10:27:16 <conal> another angle is that haskell IO is a power-tool for incomprehensible programming.
10:27:29 <jmcarthur> hatds: that's the question that is yet to be solved
10:27:43 <conal> hatds: http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/
10:27:51 <hatds> I've read that :)
10:28:14 <jmcarthur> hatds: the only point i have is that while IO is a practical way *around* the problem, it doesn't actually solve the problem itself
10:28:18 <ben> tl;dr, can it?
10:28:31 <pastorn> ben: :D
10:28:48 <conal> hatds: interpret "the IO problem" as follows: how can we finish moving imperative computations out of the programming model into the implementation of a more precise & simple model?
10:29:17 <conal> jmcarthur: nicely put. and that's exactly how i see IO.
10:29:30 <absentia> has haskell escaped academia yet?
10:29:35 <conal> a clever trick for avoiding a deep question.
10:29:42 <jmcarthur> absentia: it escaped academia as soon as IO was invented ;)
10:29:47 <hatds> my guess is that we become smarter at narrowing what imperative computations we need to get useful things done.  if we don't narrow that scope we don't narrow the problems of IO
10:29:50 <j-invariant> what problem??
10:29:52 <absentia> jm: touche!
10:30:08 <conal> and so of course the avoidance trick doesn't fix the deep problems of the imperative model.
10:30:22 <absentia> what is a problem of the imperative model?
10:30:37 <conal> absentia: http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf
10:30:47 <absentia> thx
10:30:53 <jmcarthur> absentia: hard to understand, doesn't even accurately model the real world as much as people tend to think
10:31:03 <conal> absentia: unsuitability for precise (and therefore correct) reasoning.
10:31:03 <j-invariant> who cares about the real world?
10:31:05 <hpc> conal: could you give a tl;dr? i might be leaving soon
10:31:10 <j-invariant> IO has nothing to do with the real world
10:31:11 <absentia> oh, I read that.
10:31:13 <tac-tics> Haskell will never fully escape academia....
10:31:13 <conal> hpc: ^^
10:31:23 <hpc> oh, you just did
10:31:34 <jmcarthur> tac-tics: neither will any other programming language
10:31:40 <hatds> 'programming' hasn't escaped academia
10:31:42 <tswett> Is there a clear difference between concurrency and parallelism?
10:31:42 <hatds> :)
10:31:52 <hatds> yes
10:31:57 * byorgey is not sure why academia needs 'escaping'
10:31:58 <absentia> maybe we're creating programming languages the wrong way?  or... we don't yet seem to "get it" that we're just "doing it wrong" ?
10:32:03 <j-invariant> conal: put Hoare triples on it, problem solved
10:32:06 <absentia> ts: yes
10:32:11 <tac-tics> jmcarthur: proof by counter example PHP ;(
10:32:19 <pumpkin> whore triples?
10:32:20 <jmcarthur> lol okay
10:32:26 <tac-tics> <3
10:32:27 <elliott> tac-tics: Academia will never fully escape Haskell.
10:32:27 <conal> i see imperative programming (including haskell's) as semantically too complex to allow rigor. and hence programming is mostly barbarism (http://conal.net/blog/posts/is-program-proving-viable-and-useful/).
10:32:37 <ray> i've escaped academia
10:32:42 * elliott barbarises #haskell
10:32:42 <ray> but they're hunting me down
10:32:44 <tswett> Do I need to separately ask what that difference is, or is that included?
10:32:46 <absentia> by:  sorry, I was just being mean.
10:32:46 <tswett> :P
10:33:05 <hatds> tswett: http://www.haskell.org/pipermail/haskell-cafe/2008-September/047312.html
10:33:07 <conal> j-invariant: joking about Hoare logic, right?
10:33:17 <j-invariant> conal: not at all, maybe you know something about it which I don't
10:33:28 <absentia> god I love  the URLs frothing forth from this conversation.
10:33:46 <ray> percolating
10:34:00 <j-invariant> why would it be seen as a joke, afaict hoare triples are perfect
10:34:00 <absentia> you guys (and gals ) have all the fun.
10:34:09 <conal> j-invariant: try Hoare logic when you add concurrency.
10:34:13 <jmcarthur> tswett: i tend to think of concurrency being an abstraction (different trains of thought should be able to happen theoretically at the "same time" without having to explicitly "interleave" their computations) and parallelism being an optimization (actually doing more than one thing at the same time). there are better definitions out there
10:34:21 <j-invariant> conal: oh right I don't know anything about concurrency..
10:34:32 <EnglishGent> jmcarthur - C .. that escaped academia (unfortunately)
10:35:03 <hatds> unsafeEscapeAcademia
10:35:05 <ray> threads are the abstraction
10:35:11 <tac-tics> Lol
10:35:14 <ray> well an abstraction
10:35:18 <jmcarthur> threads are one possible abstraction for concurrency
10:35:24 <EnglishGent> lol!
10:35:25 <conal> j-invariant: same issue with the (erroneous) myth that Haskell IO is equivalent to State World (or anything nearly as simple).
10:35:33 <tac-tics> Hatds: instance Monad Academia
10:35:34 <byorgey> j-invariant: Hoare triples are great, but saying they are the solution is like saying that clean, efficient hospitals are the solution to disease
10:35:42 <tswett> jmcarthur: so concurrency is when two computations can run without each having to wait for the other to finish, and parallelism is when two computations literally, physically run at the same time?
10:35:58 <j-invariant> byorgey: can you elaborate on that analogy?
10:36:11 <tswett> (Come to think of it, if two computations both had to wait for the other to finish before running, they wouldn't accomplish much.  :P)
10:36:26 <ray> i'm not sure what people mean when they say "concurrency", and i suspect it differs
10:36:29 <byorgey> j-invariant: as long as we are stuck with disease, we need clean, efficient hospitals.  But really we want to get rid of the diseases.
10:36:35 <j-invariant> How does one specify the correctness of a concurrent program?
10:36:42 <edwardk> Haskell was how I escaped from reasoning about Hoare triples. Previous to discovering Haskell, that was the only tool I had for proving programs correct. The advent of Hoare Type Theory almost made me curl up into a ball and cry ;)
10:36:46 <jmcarthur> j-invariant: great question!
10:36:53 <jmcarthur> j-invariant: it's tough with IO
10:37:00 <tswett> "This concurrent program is correct."  "This concurrent program is incorrect."  >.>
10:37:23 <byorgey> j-invariant: likewise, as long as we are stuck with imperative programming models, Hoare logic is great for proving things about them.  But it only goes so far, and really we want better programming models.
10:37:25 <j-invariant> I think the pure functional programs are diseased too
10:37:35 <pumpkin> tswett: I'd say concurrency is the ability of independent things to run at once (even on a single-CPU'd machine) and parallelism is when you speed up a single task by splitting the work across multiple work units (doesn't have to be achieved by concurrency, as in for example SIMD)
10:37:39 <j-invariant> e.g. you can't know whether a function terminates or not, unless you prove it
10:37:40 <edwardk> j-invariant: separation logic and/or lots of happens-before semantic manipulation.
10:37:41 <ray> edwardk: so hoare logic really is as painful as it looks then?
10:37:58 <edwardk> ray: the basic stuff is pretty easy to use
10:38:10 <jmcarthur> j-invariant: a strongly normalizing language doesn't suffer from that issue
10:38:31 <j-invariant> yes it does
10:38:44 <j-invariant> coq for example
10:38:45 <jmcarthur> j-invariant: ?
10:38:50 <tac-tics> What about a strongly normalizing, but slow as hell language?
10:39:00 <ray> some things look painful but there's a trick to it and it's not so bad (like haskell)
10:39:07 <tswett> pumpkin: okay.  Yeah, that seems to mesh with what jmcarthur said.
10:39:13 <edwardk> tac-tics: thats fine, wait some number of years and it'll be fast enough to use ;)
10:39:29 <edwardk> ray: nah, its pretty much a constant level of suck
10:39:33 <jmcarthur> j-invariant: by restricting the space of programs you can write to just a subset of terminating programs (that we know how to prove that they terminate) it's essentially a non-issue
10:39:51 <j-invariant> no i don't agree
10:39:58 <jmcarthur> because?
10:39:59 <Philonous> pumpkin: Or more generally, concurrency is multiple tasks competing for resources while parallelism is the opposite, namely speeding a single task up by having it use multiple resources
10:40:04 <tac-tics> Edwardk: moore can't last forever
10:40:05 <EnglishGent> um - is it? (serious question) what about a program that terminates -- but will in practice take so long that the sun will burn out long before you get an answer?
10:40:26 <j-invariant> I said that you don't know if a function terminates unless you prove it. Merely writing a function in a calculus like that requires proving its termination
10:40:28 <jmcarthur> EnglishGent: but that's not the problem that was brought up
10:40:30 <byorgey> jmcarthur: it just pushes the pain around, from the pain of proving termination to the pain of writing programs in the right way so that they will be accepted.
10:40:42 <j-invariant> Haskell trusts you: C trusts you even more
10:41:14 <EnglishGent> I confess I missed the origional problem jmcarthur - but it's something that bugs me - I cant help wondering if we can do something about timing gurantees in a suitable type-system
10:41:16 * absentia trusts no one.
10:41:17 <edwardk> tac-tics: i don't expect it to, it just acts as a powerful psychological driver, pushing the industry forward and keeping it from resting on its laurels.
10:41:17 <tac-tics> EnglishGent: if it doesn't eventually terminate due to destrucion of the machine, you can't call it strongly normalizing
10:41:23 <jmcarthur> j-invariant: there are many desirable properties that you have to prove. termination is only one of them. it's much easier in a functional language than an imperative one
10:41:44 <edwardk> englishgent: foo :: O(log n) Int ? 
10:41:52 <j-invariant> the point is: if you get rid of "IO" you sstill have theorems to prove
10:42:02 <EnglishGent> something like that edwardk :)
10:42:12 <jmcarthur> j-invariant: and my point is that the point of getting rid of IO is that those theorems are *much* easier in its absense
10:42:22 <jmcarthur> *absence
10:42:25 <EnglishGent> (please dont ask me exactly how - if I knew that I'd be writing a paper on it - at most it's the germ of an idea)
10:42:32 <j-invariant> jmcarthur: I don't find that
10:42:40 <hpc> edwardk: the coolest part of that system would be the inferencer
10:42:49 <edwardk> hpc: =)
10:42:54 <jmcarthur> j-invariant: then what's the point of using a pure, functional language at all?
10:42:54 <hpc> :t howSlowIsThisFunction
10:42:55 <lambdabot> Not in scope: `howSlowIsThisFunction'
10:42:59 <jmcarthur> j-invariant: IMO that's the whole point
10:43:06 <dolio> Have you ever programmed in Coq or Agda? Most functions don't require proofs of termination. Merely the fact that you can write them down, naturally, in the language constitutes a proof of termination.
10:43:12 <j-invariant> in any case there is no difference between functional and procedural programming
10:43:25 <jmcarthur> dolio: well, you have to write it in a particular way, often
10:43:31 <j-invariant> just use state monad in the haskell code: Now you have a pure function which implements an "imperative" algorithm
10:43:33 <jmcarthur> j-invariant: i don't follow
10:43:37 <EnglishGent> hmm - dont we need a fundamental result first.... otherwise you dont know if "P a, NP a => _ -> a' has a value or not :|
10:43:43 <dolio> 'map f [] = [] ; map f (x :: xs) = f x :: map f xs'
10:43:50 <dolio> Boom, that's valid Agda.
10:43:54 <jmcarthur> j-invariant: so.. your point is that you can write confusing code in a functional language?
10:43:54 <edwardk> hpc: keep in mind i just put a big O on that, so the algorithm claim seriously suboptimal bounds ;)
10:44:07 <j-invariant> jmcarthur: nothing is confusing about State
10:44:13 <tac-tics> Lol
10:44:24 <Philonous> j-invariant: The claim that there are connections between them is not the same as the claim that they don't differ
10:44:25 <j-invariant> it's just (a,e) -> b or something
10:44:30 <tlonim> "Merely the fact that you can write them down, naturally, in the language constitutes a proof of termination."  halting problem solution ?
10:44:35 <hpc> @unmtl State a b
10:44:35 <lambdabot> a -> (b, a)
10:44:42 <jmcarthur> "Oh, look, I can write imperative code in a functional language. Functional languages are pointless!"
10:44:45 <edwardk> s -> (a, s)
10:44:48 <dolio> tlonim: The language isn't Turing complete.
10:44:51 <tac-tics> Haskell has such a powerful type system, it wraps around at infinity, and ends up looking exactly like perl
10:44:57 <EnglishGent> tlonim - not necessairly - can just mean your language isnt powerful enough to express all computable functions
10:45:08 <tlonim> dolio: ok
10:45:21 * EnglishGent crosses himself when tac-tics mentions Perl
10:45:23 <j-invariant> it's just prejudice to say that all imperative programs are confusing and pure functional programs are easire to prove correct
10:45:28 <tlonim> EnglishGent: aha..with constraints. good point
10:45:29 <ddarius> Modern variants of Hoare triples (such as things like separation logic) can handle concurrency to at least some extent, and aren't bad.
10:45:33 <hpc> tac-tics: you mean python; perl is not nearly far enough away from the "good" axis
10:45:51 <EnglishGent> I'm an atheist - but somehow *that language* still makes me fear for my immortal soul
10:45:51 <EnglishGent> :|
10:45:56 <j-invariant> This is no true in practice: Some algorithms are naturally pure, some naturally imperative. Put the wrong creature in the wrong habitat and it makes life difficult
10:46:11 <jmcarthur> you mean some formulations of some algorithms
10:46:21 <tlonim> EnglishGent: perl ? lol
10:46:23 <jmcarthur> i doubt you can back up your claim as written
10:46:28 <EnglishGent> argh!
10:46:35 * EnglishGent crosses himself again :P
10:46:39 <j-invariant> ddarius: do you happend to know any basic resource, I would be able to read?
10:46:47 <edwardk> EnglishGent: i wrote perl for a number of years, that explains where my moral compass went. ;)
10:47:05 <cantropy> hello! I am trying to make sense of what the following error message means. I have figured out why it errors but do not comprehend the error message http://hpaste.org/paste/43127/infinite_type_compiler_error#p43128
10:47:16 <j-invariant> jmcarthur: feel free to object and ask for elaboration etc.
10:47:25 <hpc> jmcarthur: i take it as an axiom; there's inevitably going to be some things that are verbose in some grammars but terse in others
10:47:26 <EnglishGent> well at least you've now seen the light edwardk -you are in #haskell after all :)
10:47:34 <hpc> whether they are useful or not is philosophical
10:47:45 <edwardk> englishgent: yes, but i was drawn in through the existence of pugs ;)
10:47:47 <cantropy> why does it say infinite type construction error?
10:47:58 <ddarius> edwardk: Melted down for sigils?
10:48:11 <edwardk> cantropy: because the [x:xs] there is saying that you need a list of lists
10:48:36 <ray> sigil bullets to slay cs academics
10:48:43 <jmcarthur> hpc: that is true, but the claim seems to be that if you restrict yourself to imperative ways of thinking then "languages that are functional" are nonetheless equivalent to "languages that are imperative"
10:48:57 <jmcarthur> but without the qualification that i included
10:48:59 <cantropy> edwardk: and xs is expected to be recursively list of lists as well?
10:49:21 <jmcarthur> *are equivalent
10:49:22 <edwardk> cantropy: but the type signature says you need a list, then because you use maximum' on it , its argument is expected to be both a and [a] — but that can't unify
10:49:35 <hpc> jmcarthur: ah; the claim i read was more along the lines of apples and oranges, rather than "all is equally pointless" ;)
10:49:37 <edwardk> because if it did it would look like [[[[[[[[[[[[[[...]]]]]]]]]]]]]]]]]]]]
10:49:51 <Twey> Ad infinitum
10:49:52 <nyingen> I also have a type mismatch I'm not understanding, related to StateT: http://hpaste.org/43129/why_is_this_type_mismatch_ocur
10:49:52 <edwardk> (substitute [a] for a in [a] over and over)
10:49:56 <Twey> But balanced ;)
10:50:02 <nyingen> maybe it's a package problem
10:50:03 <EnglishGent> well in a sense they *are* - their both turing complete (functional & imperative languages) - it's just that functional languages are easier to reason about
10:50:20 <j-invariant> EnglishGent: why do you say that they are easier to reason about?
10:50:20 <edwardk> [a] [[a]] [[[a]]] … so the type would be an infinitely recursive list of lists of lists of ...
10:50:31 <edwardk> haskell saves you from your self here (unlike prolog)
10:50:32 <hpc> EnglishGent: for some problems
10:50:46 <EnglishGent> j-invariant becuase in an imperative language you cant assume that f(x) + g(x) == g(x) + f(x)
10:50:48 <hpc> imo, perl is one of the best ways to reason about string manipulation
10:50:48 <edwardk> because in almost all cases where you say something like that, you didn't mean it
10:50:56 <pumpkin> or you meant a tree
10:50:58 <ddarius> edwardk: I believe Prolog implementation are supposed to have the occurs check.
10:51:04 <EnglishGent> f & g might have side effects that change the behaviour of the other function
10:51:06 <jmcarthur> j-invariant: you know things won't change behind your back. you don't have to worry about operational details. you know things will be consistent. you have a set of axioms that you can trust.
10:51:07 <ddarius> Or it might have been a strong recommendation.
10:51:26 <hpc> EnglishGent: you can't necessarily assume that in functional languages either
10:51:30 <j-invariant> EnglishGent: well f(x) + g(x) == g(x) + f(x) is a term in your programming language. Not the specification language.
10:51:35 <Philonous> ddarius: So not having iso-recursive types is a feature, not a flaw?
10:51:47 <EnglishGent> you can in Haskell! (well - as long as your not doing floating-point math you can)
10:51:54 <hpc> instance Num a => Num (IO a) where a + b = x <- a; y <- b; return (x + y)
10:51:55 <edwardk> ddarius: my recollection is there is a unify_with_occurs_check primitive floating around in many prologs i think it was standardized at one point
10:51:59 <cantropy> edwardk: I see very clearly why the error occurs, I am trying to visualize what the haskell compiler does when pattern matching the xs bit in the construct [x:xs]
10:52:00 <ddarius> Philonous: Prolog is untyped.
10:52:23 <hpc> EnglishGent: see my admittedly disgusting Num instance
10:52:33 <EnglishGent> reference hpc? :)
10:52:49 <hpc> it's five lines up
10:52:50 <Philonous> ddarius: Oh, ok, I meant equirecrusive, anyway
10:53:00 <dolio> Philonous: It's the values that need an occurs check. Because computation is based on unification.
10:53:19 <jmcarthur> j-invariant: and if you are writing denotatively, you have normally a simple, well-studied model to reason with, on top of all these other properties
10:53:20 <j-invariant> jmcarthur: that descriptions applies to something very simple like pure functions. How do you prove something about a monadic program? Unfold it completely to get a pure function?
10:53:21 * monochrom observes that the entirety of formal methods begins by converting imperative programming back to functional programming. Then again perhaps this is just because functions are all we have on the math side.
10:53:26 <EnglishGent> and j-invariant - perhaps - but in all seriousness, even when working in imperative languages we try hard to (or at least I try hard) to avoid such interactions - they cause horrible loss of modularity, make code much harder to maintain
10:53:27 <hpc> EnglishGent: in imperative languages, everything is in IO, metaphorically
10:53:39 <hpc> so one can do the same thing in haskell
10:53:43 <j-invariant> jmcarthur: in places other than #haskell, procedural program verifcation is better studied...
10:53:44 <jmcarthur> j-invariant: "monad functions" are pure, unless you are talking about IO, which was my original point
10:53:55 <j-invariant> no I am not talking about IO in this case
10:53:57 <monochrom> or generally, relations are all we have on the math side
10:53:57 <tac-tics> @let xs = [xs]
10:53:58 <lambdabot>  <local>:1:6:
10:53:58 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
10:53:58 <lambdabot> ...
10:53:59 * hackagebot tuple-gen 1.0 - Generating all n-tuples without getting stuck in one infinity  http://hackage.haskell.org/package/tuple-gen-1.0 (TillmannVogt)
10:54:07 <jmcarthur> j-invariant: i have done some work in procedural verification. it sucks. have you tried it?
10:54:13 <dcoutts_> pheaver: is it sharing using nfs?
10:54:14 <edwardk> cantropy: the compiler doesn't know very much all it knows when it sees [x:xs] is that you have some outer type, lets call it 'a' which must be equal to some type [b], then inside that (x:xs) tells it that b is [c], and x : c, and xs: c. then these constraints propagate through, and because of how you _use_ xs later in the body that complaint arises.
10:54:19 <edwardk> er
10:54:23 <EnglishGent> yes - you can... but at least you would know you were inside a monad 
10:54:24 <edwardk> x : c, and xs : [c]
10:54:29 <hpc> not to mention, i could just write a shitty num instance, where (+) _ _ = 4
10:54:37 <pheaver> it's shared using this filesystem that vmware uses
10:54:41 <pheaver> "hgfs" i guess
10:54:43 <jmcarthur> j-invariant: if you are not talking about IO at all then you are still talking about completely pure code
10:54:50 <Philonous> dolio: Oh, of course. So it errors out rather than looping forever?
10:55:00 <tac-tics> Pure is relative
10:55:17 <edwardk> cantropy: basiclaly the compiler sets up a bunch of type variables, and then when it picks up information on their usage, it instantiates those variables through a process called unification
10:55:21 <cantropy> edwardk: and combining the tpes (c:[c]) becomes [c] does it?
10:55:28 <Philonous> dolio: Maybe I should look into logic programming at some point 
10:55:35 <pheaver> vmware let's the host OS share folders to the guest OS, which it mounts using a (proprietary?) filesystem module that vmware provides
10:55:36 <edwardk> :t (:)
10:55:36 <lambdabot> forall a. a -> [a] -> [a]
10:55:37 <monochrom> in some sense there is no imperative programming except for syntax sugar over functional programming
10:55:39 <ddarius> Philonous: You definitely should.
10:55:40 <jmcarthur> j-invariant: encapsulation is the only way you aren't going to be aware of everything going on, and in that case you are just relying on the stated properties of the encapsulated code. those properties are also easier to make clear in a functional language
10:55:53 <jmcarthur> for the same reasons as above
10:55:53 <j-invariant> jmcarthur: that doesn't answer my queston though
10:55:56 <tac-tics> read >>= write is pure, but  write(read()) isnt
10:56:02 <edwardk> cantropy: see the above type signature for the constructor (:)
10:56:04 <jmcarthur> j-invariant: your question about monads?
10:56:05 <dolio> Philonous: Something like that. My knowledge of prolog's evaluation is kind of weak. If it tried to unify 'a' with (Haskell notation) '1:a', it'd get an infinite list of 1s. I assume Prolog doesn't like those.
10:56:14 <EnglishGent> Philonous - there's a language called 'Curry' that is a large set of Haskell + logic programming (if your interested)
10:56:18 <jmcarthur> j-invariant: monads are pure. period. they have a simple, precise meaning, and they can't change things behind your back.
10:56:22 * EnglishGent would also recommend Mercury
10:56:27 <cantropy> edwardk: yep got it, thank you!
10:56:31 <ddarius> Philonous: You should definitely learn Prolog even though it is a crappy language.  It successors, like lambdaProlog, are much nicer, but, unfortunately, there are very few serious logic language implementations for logic languages other than Prolog.
10:56:33 <Philonous> ddarius: What language would I want to try? Mercury? Plain Prolog?
10:56:38 <j-invariant> I know what they are I was asking to find out what your approach is
10:56:41 <edwardk> dolio: haskell is perfectly happy with infinite unifications in general
10:56:43 <edwardk> er
10:56:45 <edwardk> prolog is
10:56:51 <jmcarthur> i don't remember a question about my approach
10:56:58 * EnglishGent used Prolog for his masters project - I dont like it very much - it's not nearly as mathematical as it's syntax suggest to you it should be
10:57:01 <j-invariant> jmcarthur: that descriptions applies to something very simple like pure functions. How do you prove something about a monadic program? Unfold it completely to get a pure function?
10:57:06 <jmcarthur> oh
10:57:20 <jmcarthur> j-invariant: that depends on what you are trying to prove. that is a very general question
10:57:27 <EnglishGent> the need for cuts is a horrible hack :/
10:57:30 <jmcarthur> j-invariant: unfolding is likely the worst possible approach though
10:57:39 <j-invariant> jmcarthur: ah then we agree
10:57:46 <edwardk> englishgent: live in datalog where possible =P
10:57:48 <jmcarthur> j-invariant: monads have properties that you can use without unfolding
10:57:59 <ddarius> EnglishGent: That's why you should look into lambdaProlog.  It's nicer in pretty much every way.
10:58:05 <jmcarthur> j-invariant: and *specific* monads moreso
10:58:10 <EnglishGent> linky ddarius? :)
10:58:18 <ddarius> @google lambdaProlog
10:58:18 <tac-tics> Even if IO is "pure", it locks in the order of operations
10:58:20 <lambdabot> http://www.lix.polytechnique.fr/~dale/lProlog/
10:58:20 <lambdabot> Title: λProlog Home Page
10:58:25 <EnglishGent> thanks :)
10:58:26 <j-invariant> jmcarthur: do you have an yconcrete examples of this because I cannot visualize what you mean
10:58:27 <Philonous> ddarius: Dou you know whether Mercury is any good?
10:58:28 <tac-tics> Which is what haskell loves to brag about
10:58:37 <jmcarthur> tac-tics: IO is one of the exceptions to what i'm arguing :(
10:58:51 <tac-tics> State too
10:58:56 <jmcarthur> j-invariant: the monad laws, semantic models, etc.
10:59:05 <jmcarthur> tac-tics: State is much nicer than IO
10:59:06 <tac-tics> In general, any monad
10:59:06 <hpc> jmcarthur: it isn't an exception if you take the compiler point of view
10:59:08 * conal has a soft spot for lambdaProlog
10:59:09 <EnglishGent> hi tensorpudding
10:59:11 <jmcarthur> tac-tics: you can actually reason about State
10:59:12 <ddarius> Philonous: One of the people that worked on it early on, doesn't think too highly of it.  It's no doubt still nicer than Prolog, but my impression of it, is that it is a little noisy and ugly.
10:59:15 <hpc> where the haskell program evaluates to another program
10:59:21 <hpc> then none of the monad laws are broken
10:59:32 <jmcarthur> hpc: you mean an operational point of view
10:59:42 <hpc> yes, that
10:59:54 <jmcarthur> hpc: it's difficult to argue that it obeys the monad laws in the presence of concurrency. you have to have a model to do that
10:59:56 <j-invariant> semantic models? the monad IS a semantic model
11:00:12 <j-invariant> "you want the semantics? You can't handle the semantics!"
11:00:14 <jmcarthur> j-invariant: "monad" is a proprty of that model
11:00:18 <jmcarthur> *property
11:00:23 <EnglishGent> I like mercury's idea of mode declarations - havent really used the language though
11:00:23 <Philonous> ddarius: Well I'll have a go at lambdaProlog then. Thanks
11:00:23 <jmcarthur> there are other properties too
11:00:46 <dolio> The (a?) lambda prolog compiler (teyjus) sounded pretty impressive to me for a small project, back when I looked at it
11:00:54 <conal> ddarius: as another data point, i worked on lambdaProlog early on, and i do think highly of it.
11:01:04 <dolio> They have a theoretical model of the language that supports some nice properties.
11:01:21 <ddarius> Philonous: I still recommend learning Prolog.  It is -the- logic language, and, unfortunately, most effort in logic languages takes place around it.
11:01:23 <edwardk> personally i find datalog-like models to be a nicer place to look for semantics than existing FRP models for how to handle the mixture of induction and deduction that is provided by FRP
11:01:47 <edwardk> speaking of which, conal, have you look at hellerstein's work on overlog/daedalus/bloom?
11:01:54 <edwardk> er looked
11:02:15 <Philonous> ddarius: Roger that.
11:02:31 <conal> edwardk: i haven't
11:02:57 <jmcarthur> hpc: it's important that i'm talking about *meaning* and not *implementation*. you say that a particular implementation does satisfy the monad laws, and i agree, but that doesn't help me reason about its meaning, considering that it's implementation in this case is just a translation to yet another program which i need to be able to reason about.
11:03:11 <jmcarthur> *its implementation
11:03:45 <hpc> well, i view concurrency as broken anyway
11:03:55 <monochrom> "put a >> put b = put b" is a theorem of the State monad. To prove it, you have to unfold. To use it, for example "runState (put 0 >> put 1 >> put 2 >> put 3 >> get) = runState (put 3 >> get)", there is no more unfold. Another theorem completes it as "runState (put 3 >> get) = ((), 3)"
11:04:14 <jmcarthur> hpc: you mean threads?
11:04:32 <edwardk> the short short answer is to move everything into a datalog-like model, which is nice because any individual moment in time can evaluate its state completely, then instead of doing some imperative stuff before returning to datalog, the world is just extended with an open set of time stamps and some rules to propagate information forward across timestamps
11:04:33 <jmcarthur> concurrency itself is just an idea, and i don't think it's broken at all
11:04:37 <hpc> as in "concurrency" vs "parallelism"
11:04:52 <edwardk> this is nice because you don't get the risk of easy infinite loops that you do with FRP
11:05:11 <jmcarthur> hpc: as i see it, concurrency is a potentially useful abstraction which we just manage to mess up a lot
11:05:18 <monochrom> oops, "runState (put 3 >> get) = (3,3)"
11:05:31 <ion> runState (put 3 >> get) x
11:05:34 <jmcarthur> hpc: for example conflating concurrency with nondeterminism
11:05:39 <monochrom> oops yeah
11:06:07 <jmcarthur> or with interleaving
11:06:20 <hpc> jmcarthur: i don't conflate; it is broken for allowing the possibility of nondeterministic execution
11:06:24 <cantropy> edwardk: is there any xs in the incorrect pattern match [x:xs] which will evaluate to a type [x]? if not wouldn't it be clearer if the compiler gave the error that [x:xs] cannot evaluate to a [x]. or rather why is the compiler not able to figure out that the pattern match is impossible?
11:06:25 <jmcarthur> that
11:06:33 <jmcarthur> hpc: concurrency isn't necessarily nondeterministic
11:06:46 <jmcarthur> threads might be, though
11:06:50 <JeroenDL> How can I get from "abc" to ["aa", "ab", "ac"] using map ?
11:06:51 <monochrom> nondeterminism isn't necessarily concurrent
11:06:51 <edwardk> cantropy: it picked up the name [a] from your type signature
11:06:52 <hpc> IO isn't necessarily impure
11:06:56 <conal> for instance, FRP is extremely concurrent (continuously so, and fine-grain) and yet deterministic.
11:06:56 <jmcarthur> monochrom: indeed
11:07:16 <hpc> arguments in the category of things that might be something else are a bit useless :P
11:07:23 <jmcarthur> hpc: what conal just said is actually the whole point of FRP
11:07:25 <hpc> anyway, i gotta go
11:07:36 * hpc skillfully dodges a losing argument :P
11:07:37 <monochrom> unimaginative programmers insist on the rest of the language being deterministic, and so their only nondeterminism comes from a scheduler.
11:07:42 <jmcarthur> :(
11:07:58 <hpc> (i wish i could stay and lose properly though)
11:07:58 <jmcarthur> hpc: losing and winning is silly. learning (for both of us) is a far better goal
11:08:13 <edwardk> cantropy: what it did was figure out that the type was [a] from the signature, and then that it had to be [[a]] from the fact that you used maximum' on xs, at that point in time it bailed out on you. the message is just somewhat less than intuitive ;)
11:08:14 <jmcarthur> i don't feel like i'm winning anything
11:08:16 <hpc> i know, just kidding around
11:08:17 <afarmer-lab> is there an RC for haskell platform 2011.x?
11:08:24 <hpc> anyway, seriously bye
11:08:41 <JeroenDL> Anyone know this ?   ->  How can I get from "abc" to ["aa", "ab", "ac"] using map ?  (So I want to prepend 'a' to every char)
11:09:11 <edwardk> > map ('a':) "hello"
11:09:12 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:09:12 <lambdabot>         against inferred ty...
11:09:36 <edwardk> > map (('a':). return) "hello"
11:09:40 <lambdabot>   mueval-core: Time limit exceeded
11:10:04 <ZnHxr> > liftM (map toEnum . (97 :) . return . fromEnum c) "abc"
11:10:05 <lambdabot>   Couldn't match expected type `a1 -> GHC.Types.Int'
11:10:05 <lambdabot>         against inferred...
11:10:15 <monochrom> > map (\x -> 'a':x:[]) "hello"
11:10:17 <lambdabot>   ["ah","ae","al","al","ao"]
11:10:19 <ddarius> @tell hpc Look at declarative concurrency in Peter van Roy's CTM.
11:10:19 <lambdabot> Consider it noted.
11:10:34 <JeroenDL> thx monochrom 
11:10:34 <ZnHxr> > liftM (return . map toEnum . (97 :) . return . fromEnum c) "abc"
11:10:35 <lambdabot>   Couldn't match expected type `a1 -> GHC.Types.Int'
11:10:36 <lambdabot>         against inferred...
11:10:40 <ZnHxr> er, wait
11:10:50 <JeroenDL> Seems its harder then you might think though
11:10:58 <j-invariant> ddarius: is there a specification model for declarative concurrency?
11:11:00 <cantropy> edwardk: ah I see. but I wonder why it needs to wait for the unfication process when maximum' xs is invoked to trigger the error, whereas it could figure out much before that there is no xs  in maximum' [x:xs] such that [x:xs] will reduce to a [x] ...
11:11:03 <monochrom> you see what is meant by some complicated there is no obvious deficiency.
11:11:04 <ZnHxr> > liftM (map toEnum . (97 :) . return . fromEnum) "abc"
11:11:06 <lambdabot>   [[*Exception: Prelude.Enum.().toEnum: bad argument
11:11:09 <monochrom> s/some/so/
11:11:10 <ZnHxr> there we go
11:11:19 <j-invariant> like so I can say "this program works"
11:11:26 <jmcarthur> j-invariant: some of the FRP models are examples
11:11:34 <ZnHxr> > liftM (map toEnum . (97 :) . return . fromEnum) "abc" `asTypeOf` ""
11:11:35 <lambdabot>   Couldn't match expected type `[a]'
11:11:35 <lambdabot>         against inferred type `GHC.Types...
11:11:48 <ZnHxr> > liftM (map toEnum . (97 :) . return . fromEnum) "abc" `asTypeOf` return ""
11:11:50 <lambdabot>   ["aa","ab","ac"]
11:11:55 * jmcarthur looks at what ddarius just linked to
11:11:59 <ddarius> j-invariant: Yes.
11:12:02 <jmcarthur> err... *mentioned
11:12:05 <j-invariant> well I meant the stuff in the CTM book  but if you know any examples of FRP used for this I would like to see that too
11:12:09 <Phyx-> i'm getting weird linker errors with ghc.. http://phyx.pastebin.com/gdcjU30M
11:12:54 <jmcarthur> j-invariant: some of conal's approaches are model-driven
11:13:27 <jmcarthur> j-invariant: http://conal.net/papers/push-pull-frp/
11:13:37 <jmcarthur> the model has some flaws, IMO, but there's a model at least
11:13:58 <j-invariant> but I mean like example concurrent programs & specifications fo rthem
11:14:18 <conal> if i understand the sense of "model-driven", then almost everything i work on is model-driven. my design process starts with "what does it mean?" (i.e., what model)
11:14:18 <jonkri> what is the Int argument in http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v:hGetNonBlocking ?
11:14:29 <jmcarthur> conal: that is exactly what i meant
11:14:37 <conal> jmcarthur: cool :)
11:14:39 <edwardk> cantropy: for this example that would work. for more complicated cases, it'd need to wait, for instance, what if you didn't have a type signature?
11:14:43 <j-invariant> bbl
11:14:55 <edwardk> cantropy: this way it only has the code in the compiler once
11:15:01 <ZnHxr> jonkri: "First argument is the Handle to read from, and the second is the number of bytes to read."
11:15:13 <conal> i've been calling this process "denotational design". i like "model-driven" also.
11:15:18 <jmcarthur> conal: it takes me longer to write a library than it used to, thanks to you
11:15:26 <jmcarthur> ;)
11:15:28 <conal> jmcarthur: :) !
11:15:47 <kuffaar> Given a list of file names [FilePath] and a processFile :: FilePath -> IO (Maybe [String]), how do I map them to IO [Maybe [String]] as opposed to [IO Maybe [String]]?
11:15:50 <monochrom> edwardk: you may like http://www.cs.toronto.edu/~hehner/aPToP/ . Even Hoare himself has switched to something similar, see his book Unified Theories of Programming.
11:15:53 <conal> jmcarthur: hopefully not longer to create a well-defined & elegant library.
11:16:14 <jmcarthur> well, that takes less time now :)
11:16:47 <ZnHxr> kuffaar: mapM
11:16:48 <Phyx-> ok, this is weird.. I have in an instance "instance Storable a => FFIType a (Ptr a)" now i make a call to fromFFI with added annotation :: FFIType SrcSpan (Ptr SrcSpan). GHC 6.12 compiled it, GHC 7 rejects it claiming it wants an instance of FFIType SrcSpan (Ptr SrcSpan).
11:16:52 <kuffaar> Ahh
11:16:53 <cantropy> edwardk: makes sense now, but given that there is a type signature given, maybe the compiler could provide a better error message. I wonder is the haskell compiler a single pass compiler?
11:17:01 <ddarius> jmcarthur: Presumably a similar thing happened when you first started using Haskell.
11:17:19 <kuffaar> That is precisely what I needed, thanks
11:17:26 <edwardk> cantropy: well, type signatures are just a source of more unification constraints =)
11:17:36 <edwardk> cantropy: (that is a minor oversimplification)
11:18:06 * ddarius has seen aPToP several times, but never read it.
11:18:57 <monochrom> it begins without much surprise: a program/specification is a relation...
11:19:01 <edwardk> cantropy: technically the presence of a signature flips things around from type inference to type checking, but i don't really see that helping much in your case here. 'pattern can not match' is just not a concept the compiler deals with
11:19:05 <pumpkin> monochrom: surely not!
11:19:25 <EnglishGent> wb pumpkin :)
11:19:25 <monochrom> surely too...
11:19:32 <pumpkin> EnglishGent: hi :)
11:21:12 <cantropy> edwardk: aha makes much more sense now. and that is why we get runtime pattern not match errors
11:22:25 <EnglishGent> does anyone know of any Haskell code for accessing the Kad network? (a'la Amule / Emule)
11:22:58 <edwardk> cantropy: yeah what happens is when the compiler sees you writing a pattern match for a given type, it fills in 'stub' branches for any cases you didn't cover that print those messages. (-Wall will complain that it had to do so)
11:23:12 <cantropy> edwardk: but this is pattern type not matching as opposed to pattern not matching. so that is something whch is still a possible compiler improvement scope?
11:23:48 <edwardk> possibly, but in the presence of GADTs, and all the crazy type extensions it may be trickier than you think
11:24:43 <edwardk> in general it seems the ghc guys take the approach of trying to find simpler rules that catch all the problems than making specialized code paths that can bit-rot or give inconsistent results but which give slightly prettier error messages
11:25:55 <JeroenDL> monochrom: what would I have to change if            k = Int  ?           map (\x ->(show k):[x]) v   doesnt work 'cause that gives "5" in stead of '5'  ?
11:25:57 <edwardk> plus there is the technical issue that when compiling a pattern is first parsed as an expression. and while parsing no type information is really used, because things like associativity aren't even known until its done parsing the whole file and has found all the infix declarations
11:27:01 <monochrom> show k ++ [x]
11:27:15 <jonkri> can i use a handle acquired with http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html#v:connectTo with the ByteString hGetContents function? i get a couldn't match expected type error against inferred type IO Data.ByteString.Internal.ByteString...
11:27:18 <JeroenDL> ok, that makes sense ... doh
11:27:38 <nyingen> so I used ghc-pkg to hide a package, but it's still being loaded when I run ghc on my source file
11:27:46 <nyingen> despite the fact that I don't import it
11:28:10 <nyingen> can other packages I'm importing force the loading of a hidden package?
11:28:15 <nyingen> I'm a bit confused here
11:31:04 <cantropy> edwardk: thank you very much, that was an illuminating discussion. if adding more features can yield bitrot, then I suspect there is a scope (but maybe no time, or appetite) for a revamp. but like you say, I am just looking at a very high level, there are many edge constraints that need to be consistent.
11:35:28 <joe6> i have come to a point where I feel haskell programming is akin to puzzle solving.
11:35:33 <joe6> anyone feel the same?
11:35:44 <j-invariant> what do you mean, is that progress/
11:35:50 <Botje> i bang out code and let the typechecker fix it for me
11:36:02 <beastaugh> don't you find all programming akin to puzzle solving?
11:36:14 <mm_freak> joe6: depends…  if you just want to get your code work without having to understand anything, then yes
11:36:15 <joe6> i do not know, i want to check with your experiences if my experiences are headed in the wrong direction.
11:36:36 <joe6> beastaugh: yes, on abstraction
11:36:41 <EvanR-work> beastaugh: programming in php is akin to building a sand castle
11:37:01 <arcatan> whenever i'm learning new (hard) things, it feels like puzzle solving
11:37:23 <joe6> mm_freak: why do you say that? you have to understtand the structure and size of the component to solve a puzzle?
11:37:34 <JeroenDL> http://pastebin.com/1XdVFFaU Why does it think that 'b' needs to be a char ??
11:37:38 <joe6> arcatan: ok.
11:37:50 <JeroenDL> (really small piece of code)
11:38:08 <beastaugh> hah
11:38:11 <beastaugh> nice analogy
11:38:14 <aristid> EvanR-work: with liquid sand.
11:38:17 <EvanR-work> lol
11:38:55 <edwardk> cantropy: there have been a number of haskell compilers that have focused on better error messages than exotic type system features. Chameleon, Helium, etc. come to mind (though not 100% haskell IIRC), GHC on the other hand focuses on extensibility with new language features to the expense of the kind of feature you are looking for
11:38:58 <mm_freak> joe6: if you try to get the deeper insight to actually know what you are writing, then it's more like a strange, allegorical experience…  you're passing through a thick fog at first…  and suddenly it makes click, the fog vanishes and you see a beautiful new world, which was previously hidden
11:39:04 <mm_freak> =)
11:40:07 <mm_freak> joe6: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
11:40:41 <aristid> edwardk: coming from a c++ (with gcc) background, ghc's error messages are delightfully readable.
11:41:00 <accel> these days, does haskell compile down to C, or does haskell generate it's own code natively?
11:41:04 <joe6> mm_freak: I meant puzzle solving in a good way. not in a negative sense. am checking your article.
11:41:08 <monochrom> I do all programming as problem-solving. This is why my first line of code happens later than other people but I get it finished bugfree sooner than other people.
11:41:14 <aristid> accel: usually no C is involved anymore.
11:41:27 <ddarius> Programming -is- problem-solving.
11:41:50 <monochrom> Other people's 2-week non-step sleepless assignment is my 4-hour assignment.
11:41:56 <sleepynate> ddarius: you mean it's not using rails to monetize my SEO ?
11:42:09 <JeroenDL> http://pastebin.com/1XdVFFaU Why does it think that 'b' needs to be a char ? (Really small piece of code)
11:42:15 <pastorn> monochrom: go waterfall!
11:42:31 <ddarius> sleepynate: Presumably monetizing your SEO was a problem that needed solving.
11:42:50 <mm_freak> joe6: it's not my article, but i love it =)
11:42:55 <pastorn> monochrom: i have sort off the same approach, that's why i have a hard time with "incremental" development :/
11:43:07 <joe6> mm_freak: brilliant message. wow, that guy is a very good writer.
11:43:17 <sleepynate> ddarius: the only problem anyone who uses that kind of phrase around me has is that they haven't left my office yet
11:43:27 <joe6> i am still at the first night stage. where everything is sweaty and perfect.
11:43:45 <monochrom> I do incremental too. Each incrememnt is a problem-solving session.
11:44:00 <edwardk> aristid: hahaha. i agree. ghc made me very happy it at least points to the right location in the source and gives kind of the right idea of what to look at. i've recently been using clang a lot, which makes both look pretty pathetic by way of comparison though
11:44:03 <joe6> monochrom: that is a very interesting observation.
11:44:25 <ddarius> Are clang's error messages -that- much better?
11:44:48 <joe6> monochrom: i am noticing that writing the program is making me think about the solution with so much clarity, atleast using Haskell, as thought to me by pastorn.
11:46:24 <ray> monochrom: it takes so much more mental effort to change something you've already written
11:46:31 <ray> this applies not just to programs
11:46:37 <ray> but to revising novels or whatever
11:46:43 <ray> it's the hardest part
11:47:35 <jmcarthur> accel: GHC currently has its own native code generator, an LLVM backend, or a C backend. the C backend is deprecated, though
11:47:50 <JeroenDL> (Sorry to be spamming, but could somebody please take a look ?) http://pastebin.com/1XdVFFaU Why does it think that 'b' needs to be a char ? (Really small piece of code)
11:48:09 <jmcarthur> JeroenDL: an on-topic question is not spam
11:48:39 <JeroenDL> If I keep repeating myself it is :p
11:49:00 <jmcarthur> ah
11:49:59 <Botje> map (\x -> (show k) ++ [x]) v -- show k :: String, so [x] :: String, so x :: Char
11:50:25 <Botje> x is the parameter name in a map of v, so v :: [Char]
11:50:40 <Botje> so it cannot be "any type", as you claim with the type variable b
11:51:55 <joe6> s/thought/taught/
11:52:07 <Botje> ;w 23
11:52:08 <Botje> oops
11:52:18 <JeroenDL> thx Botje
11:52:47 <beastaugh> JeroenDL: if you remove the type signature and try to load it in ghci, you can see what type it infers for the function
11:53:15 <JeroenDL> beastaugh: i did that, and it showed that it wanted [char], but I still didnt understand _why_
11:53:17 <ray> :t \((k,v):xs) -> (map (\x -> (show k) ++ [x]) v) ++ (splits xs)
11:53:18 <lambdabot> Not in scope: `splits'
11:53:27 <beastaugh> splits :: (Show t) => [(t, [Char])] -> [[Char]]
11:54:19 <beastaugh> JeroenDL: well, like Botje said, your type signature is overly general
11:55:13 <EvanR-work> bananasplits :: [Fleegle,Bingo,Drooper,Snorky]
11:55:22 <EvanR-work> oh
11:55:23 <EvanR-work> =
11:55:32 <EvanR-work> still hung over...
11:56:18 <accel> does haskell support macros?
11:56:43 <EvanR-work> min x y = if x < y then x else y
11:57:24 <EvanR-work> functions are like macros
11:57:24 <edwardk> accel: yes, through template haskell
11:57:28 <EvanR-work> or that
12:00:24 <accel> cool; thanks
12:09:45 <accel> is there anyway in haskell to remove laziness?
12:09:47 <accel> especially in a do block
12:09:53 <aristid> :t seq
12:09:55 <lambdabot> forall a t. a -> t -> t
12:09:56 <aristid> :t (!)
12:09:57 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
12:09:59 <aristid> :t ($!)
12:10:01 <lambdabot> forall a b. (a -> b) -> a -> b
12:10:06 <accel> ?
12:10:16 <aristid> accel: seq and ($!) can be used to "remove laziness"
12:10:20 <ray> the first and third of those
12:10:27 <Heffalump> is there a strict identity monad/
12:10:28 <Heffalump> ?
12:10:29 <aristid> yes, the (!) was just a typo.
12:10:34 <aristid> Heffalump: in monadLib, yes
12:10:42 <jmcarthur> also in parallel
12:10:52 <jmcarthur> Eval is strict identity, iirc
12:11:06 <EvanR-work> does strict monad harm performance
12:11:18 <jmcarthur> i love vague questions
12:11:38 <ray> also patterns like f !x = ... which is the same as f x = x `seq` ...
12:12:36 <jmcarthur> that requires an extension though
12:13:37 <ray> yes for now it requires an extension
12:15:40 <ohai> ohai
12:16:46 <byorgey> ohai ohai
12:16:57 <ohai> Tryin' out Haskell ^^
12:17:08 <ohai> Seems pretty noob-friendly
12:17:08 <byorgey> fun =)
12:17:18 <byorgey> we try
12:17:28 <byorgey> got any questions so far?
12:17:37 <ohai> not yet, @ lesson 2 ATM
12:17:43 <ohai> So, you are a Haskell developer?
12:17:46 <ohai> That's epic
12:18:06 <byorgey> depends how you define "Haskell developer", but yes, I suppose I am =)
12:18:14 <ohai> cool :)
12:19:12 <ohai> hmm
12:19:25 <ohai> there is fst to get the first value, is there a function to get nth value?
12:19:53 <byorgey> ohai: there is for lists, but not for tuples
12:19:58 <ohai> I see
12:20:02 <edwardk> ohai: out of a list, yes, but not out of a tuple, what would its type be?
12:20:06 <ben> fst is for pairs, there is only a first and a second value, no n'th :)
12:20:11 <ohai> oooh
12:20:12 <ohai> I see
12:20:21 <ohai> so tuple can only have 2 members?
12:20:27 <byorgey> right
12:20:30 <ohai> oh I see
12:20:31 <ohai> thanks
12:20:33 <byorgey> there are also triples which can have three
12:20:33 <v0|d> core
12:20:35 <Rotaerk> no, just a 2-tuple
12:20:36 <v0|d> ops.
12:20:41 <ohai> oh
12:20:41 <ohai> I get it
12:20:43 <ohai> 2-ple
12:20:43 <ben> The kind of tuple that works with fst can only have two members
12:20:43 <ohai> lolz
12:20:44 <byorgey> and quadruples and ... but beyond triples you will go blind
12:20:45 <EnglishGent> hi byorgey, ohai :)
12:20:45 <ohai> thanks
12:20:45 <Rotaerk> tuple doesn't imply 2
12:20:50 <ohai> Hi!
12:20:56 <EvanR-work> a pair has 2
12:20:57 <ben> Rotaerk: Then why is it called two-ple
12:21:01 <Rotaerk> a 2-tuple is otherwise known as duple
12:21:07 <EvanR-work> TUP le
12:21:10 <Rotaerk> tuple is generic, and has no count associated with it
12:21:29 <EvanR-work> who pronounces it twople
12:21:40 <EvanR-work> besides my boss
12:21:50 <ben> Germans, I suppose
12:22:00 <ohai> so let name is variable creation?
12:22:18 <EvanR-work> let x = y in z
12:22:25 <EvanR-work> definition of a variable
12:22:27 <ohai> o.O
12:22:49 <ohai> cool
12:22:51 <byorgey> the etymology of "tuple" is strange.  Basically it is a shortening of quintuple, sextuple, septuple, octuple...
12:23:03 <ohai> Can I declare a variable for later use?
12:23:07 <byorgey> except those are really  quint-u-ple, sext-u-ple, ...
12:23:18 <byorgey> the 't' is just from the fact that those prefixes all happen to END with t
12:23:25 <kuffaar> @quote SPJ compiles
12:23:25 <jmcarthur> ohai: in ghci you can (maybe not on tryhaskell.org though)
12:23:25 <lambdabot> SPJ says: "If it compiles, it works."
12:23:29 <byorgey> witness 'quadruple', 'duple', 'triple'
12:23:52 <ray> 'pair'
12:23:59 <jmcarthur> ohai: in a normal haskell file, you would either define a top-level value or just do a local let or where definition
12:24:10 <ohai> hmm
12:24:40 <ray> why does haskell lack one-tuples :)
12:24:54 <shachaf> ray: Control.Monad.Identity.
12:25:10 <byorgey> ray: http://hackage.haskell.org/package/OneTuple
12:25:13 <jmcarthur> ohai: ghci roughly mimicks what we call "do notation", which is just an imperative-looking syntax. in do notation, you can just say "let x = y" and use x in later lines without having to say the "in" part
12:25:16 <ray> it skips from 0-tuples to pairs
12:25:17 <shachaf> I suppose that's not a 1-tuple, actually.
12:25:23 <jmcarthur> and that's all there is to know about let i guess
12:25:27 <ohai> oh
12:25:47 <ray> yeah i know OneTuple it's just a shame it doesn't work with ()
12:26:15 <dolio> Who cares?
12:26:18 <byorgey> OneTuple is a joke, I don't see what one-tuple syntax would buy you =)
12:26:31 <ray> it's all a joke
12:26:58 <EvanR-work> is there a standard one tuple data structure
12:27:07 <EvanR-work> data X a = X a
12:27:21 <jmcarthur> that would work, but what's the point?
12:27:24 <maltem> We have one-tuples if you allow them to be identified with the value contained therein
12:27:26 <ray> it's kinda like empty data declarations but useless
12:27:26 <EvanR-work> i know it would work
12:27:31 <shachaf> There actually is a () OneTuple syntax, but it's a type alias instead of a newtype/data type.
12:27:50 <shachaf> > let f :: ((Int)) -> (Int); f ((x)) = (x) in f ((5))
12:27:52 <lambdabot>   5
12:28:07 <shachaf> For instance.
12:28:08 <jmcarthur> there would be a point of all n-tuples desugared into nested 2-tuples with () at the end
12:28:29 <sproingie> a 1-tuple of x is just x
12:28:35 <jmcarthur> *if all
12:28:57 <ray> isn't that how set theorists construct tuples after constructing pairs
12:29:19 <jmcarthur> i don't know, but it seems more useful to me than having different constructor for each arity
12:29:37 <jmcarthur> with the nested version you can at least use type classes to define recursive functions over n-tuples
12:29:59 <ray> and pairs are {{a,b},{a}} i think
12:30:23 <ohai> mind****
12:30:30 <ohai> *dies*
12:30:36 <maltem> that is indeed the set-theoretic formalisation
12:30:38 <dolio> Set theory is lame.
12:30:38 <jmcarthur> aw
12:31:02 <Evious> Has anyone used QuickCheck to test external systems using IO properties?
12:31:03 <ddarius> There is more than one way to define pairs in set theory.
12:31:08 <Evious> I'm confused by the Rose type defined there.
12:31:13 <aristid> jmcarthur: but with the nested versions, you get many more possible bottoms :)
12:31:36 <maltem> alright then, the best-known set-theoretic formalisation
12:31:42 <jmcarthur> aristid: i don't see that necessarily as a problem
12:31:47 <jmcarthur> it depends on what you want
12:32:09 <dolio> aristid: Nah, you get lots of useless elements that aren't quite bottom.
12:32:23 <jmcarthur> varying levels of definedness
12:32:24 <aristid> dolio: inner bottoms :P
12:32:25 <ray> pretty sure it's the one i learned in school and promptly forgot anyway
12:33:11 <aristid> i decided to refrain from making juvenile jokes about "bottom"
12:34:38 <ray> let the bottoms hit the floor
12:38:59 <dented42> I'm playing around with generating contiguous subsequences from a list, and I've written a function here http://hpaste.org/43131/ that generates a portion of the result. However I would like to try and rewrite it using a fold, but I'm not really sure how to go about doing so, or if it is even possible. Any hints?
12:40:18 <EvanR-work> aristid: bottoms up, bottoms up
12:40:52 <monochrom> it's bottoms all the way down
12:40:56 <nyingen> (_|_)?
12:41:36 <ion> (_(_) (_|_) (_)_) (_|_)
12:41:54 <EvanR-work> lolwtf
12:42:16 <aristid> > subsequences [1..4]
12:42:17 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
12:42:31 <aristid> lambdabot: those are not contiguous
12:42:43 <EvanR-work> @src subsequences
12:42:43 <lambdabot> Source not found.
12:43:05 <conal> dented42: take the definition of foldr and see if you can infer what the first two arguments must be.
12:43:23 <jmcarthur> dented42: your function is a standard library function if you want to cheat and look at how it's written
12:43:34 <jmcarthur> :t tails
12:43:35 <lambdabot> forall a. [a] -> [[a]]
12:45:02 <jmcarthur> dented42: i way to think of foldr is that it replaces (:) and [] with a function and value of your choosing. if you can come up with what the function and value should be then you're good. by writing out the pattern matching as you did, you've already done most of that work :)
12:45:06 <jmcarthur> *a way
12:45:46 <jmcarthur> maybe i'm just confusing matters though
12:45:48 <mm_freak> > tails "abcde"
12:45:50 <lambdabot>   ["abcde","bcde","cde","de","e",""]
12:46:22 <dented42> jmcarthur: No, I understand what you mean. Thanks, I think I can take it from here.
12:46:38 <jmcarthur> np
12:47:13 <aristid> :t initials
12:47:14 <lambdabot> Not in scope: `initials'
12:47:17 <aristid> :t inits
12:47:18 <lambdabot> forall a. [a] -> [[a]]
12:47:26 <aristid> :t inits .: tails
12:47:27 <lambdabot> forall a. [a] -> [[[a]]]
12:47:37 <aristid> :t concat . inits .: tails
12:47:37 * conal enjoys having a programming paradigm that allows useful systematic reasoning & derivation.
12:47:38 <lambdabot> forall a. [a] -> [[a]]
12:47:47 <aristid> conal: which is?
12:47:49 <jmcarthur> dented42: actually, tails uses explicit recursion i think
12:48:19 <conal> aristid: denotative/functional (as in Haskell minus IO & ilk)
12:48:28 <jmcarthur> dented42: and i'm not sure if foldr will be a perfect fit
12:48:47 <aristid> conal: would MonadPrompt count as denotative?
12:49:08 <jmcarthur> unfoldr might be more appropriate, and it's sometimes a bit more difficult to work with
12:49:26 <jmcarthur> just because the function you give it has a more complicated type
12:49:28 <conal> dented42: if you try the derivation exercise i suggested, you'll either find your answer or you'll understand why there isn't one. (and not just "proof by lack of imagination")
12:50:00 <ryanakca> On http://www.haskell.org/haskellwiki/99_questions/Solutions/2 , why doesn't the first definition of myButLast'' always get taken, what's the difference between [x,_] and (_:xs), aren't they both lists?
12:50:06 <mm_freak> aristid: inits?
12:50:14 <dented42> jmcarthur: Ok, that makes sense. I've not heard of unfoldr, I shall look it up.
12:50:16 <aristid> mm_freak: yes?
12:50:16 <jmcarthur> ryanakca: the first restricts the list to two elements
12:50:27 <jmcarthur> ryanakca: the latter just says the list has at least one element
12:50:34 <aristid> > tails "abc"
12:50:35 <lambdabot>   ["abc","bc","c",""]
12:50:39 <ryanakca> jmcarthur: Aha, thanks.
12:50:43 <aristid> > (inits .: tails) "abc"
12:50:44 <conal> aristid: if & only if it has a precise denotation.
12:50:44 <lambdabot>   [["","a","ab","abc"],["","b","bc"],["","c"],[""]]
12:50:48 <mm_freak> aristid: ah, you found it already
12:51:03 <jmcarthur> ryanakca: the first is equivalent to:     (x:_:[])
12:51:04 <aristid> mm_freak: ah, lol
12:51:46 <Philonous> ddarius: I almost said prolog is like type level programming in haskell, just better, but I guess that'd be the wrong way around
12:52:41 <djahandarie> Only fundeps anyways
12:52:54 <dolio> Much better.
12:54:09 <aristid> > ((tail . inits) .: tails) "abc"
12:54:12 <lambdabot>   [["a","ab","abc"],["b","bc"],["c"],[]]
12:54:19 <aristid> > (concat . (tail . inits) .: tails) "abc"
12:54:21 <lambdabot>   ["a","ab","abc","b","bc","c"]
12:54:52 <dolio> For instance, 'instance C1 <T> => C2 <T'>' could work like prolog's 'c2(<E>) :- c1(<E'>)', but it doesn't.
12:55:08 <dented42> aristd: what does .: do?
12:56:35 <djahandarie> Is there an n-ary function composition function?
12:57:00 <dolio> No.
12:57:06 <djahandarie> Like compose S(S(S(Z))) f g
12:57:20 <sipa> :t (.:)
12:57:21 <conal> djahandarie: however, binary composition itself is composable.
12:57:22 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:57:36 <conal> djahandarie: neat idea. hm!
12:57:45 <sipa> cd ..
12:57:47 <sipa> oops
12:58:30 <aristid> dented42: .: is fmap.fmap
12:58:39 <aristid> dented42: in lambdabot at least.
12:58:43 <dented42> ah, ok
12:59:19 <jmcarthur> djahandarie: if you just have (succ :: (a -> a) -> a -> a) and (zero :: a -> a) then you have an embedding of that already. that is, church numerals
12:59:22 <dolio> Getting something like that to work right (with just a natural number argument) might be hairy.
12:59:40 <aristid> does GHC support functor fusion?
12:59:44 <jmcarthur> err
12:59:48 <jmcarthur> did i do that right?
13:00:01 <jmcarthur> nope
13:00:46 <djahandarie> Oh by the way, conal, you might be interested in this http://hackage.haskell.org/package/newtype-0.1
13:00:57 <mm_freak> > map tail . takeWhile (not . null) . iterate tail . (undefined:) $ "abcde"
13:00:59 <lambdabot>   ["abcde","bcde","cde","de","e",""]
13:01:26 <conal> djahandarie: thanks! looks like something i'd use. or at least enjoy learning.
13:01:28 <jmcarthur> > let succ n f x = f (n f x); zero f x = x in succ (succ (succ zero)) (*2) 1
13:01:30 <lambdabot>   8
13:01:36 <jmcarthur> djahandarie: ^^
13:01:56 <aristid> :t let succ n f x = f (n f x)
13:01:57 <lambdabot> <no location info>: not an expression: `let succ n f x = f (n f x)'
13:01:59 <aristid> :t let succ n f x = f (n f x) in succ
13:02:00 <lambdabot> forall t t1 t2. ((t -> t1) -> t2 -> t) -> (t -> t1) -> t2 -> t1
13:02:07 <djahandarie> Whoa, neat
13:02:09 <mm_freak> conal: i'm pretty sure you can write n-ary composition by a few type system tricks
13:02:14 <aristid> jmcarthur: is that a church encoded succ?
13:02:17 <jmcarthur> yeah
13:02:18 <cwraith> that's a pretty cool package
13:03:05 <conal> mm_freak: would be cool. if you try, please let me know how it goes. djahandarie's trick looks useful, too.
13:03:07 <jmcarthur> djahandarie: for the ADT version you were asking about you would just implement an interpreter on Nat that just gives succ for S and zero for Z
13:03:31 <djahandarie> Right
13:04:01 <kenny```> ZnHxr: sorry, had things to do, still willing to help?
13:04:09 <aristid> djahandarie: does that mean that with the newtype package, the ZipList examples could be nicer?
13:04:25 <conal> a little point removal clarifies that succ def for me: succ n f = f . n f
13:04:47 <jmcarthur> hah, i already had my own newtype module
13:05:24 <aristid> @pl succ n f = f . n f
13:05:25 <lambdabot> succ = ap (.)
13:05:32 <aristid> woah, nicely succinct
13:05:35 <aristid> if a bit cryptic
13:05:44 <conal> wow. i'd only gotten as far as succ = liftA2 (.) id
13:05:54 <conal> also cryptic to me
13:06:01 <djahandarie> :t ap (.)
13:06:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => ((a -> b) -> f a) -> (a -> b) -> f b
13:06:10 <aristid> conal: well, that last step from liftA2 (.) id to ap (.) should be mechanic
13:06:10 <djahandarie> Oh god
13:06:18 <djahandarie> :t ap (Prelude..)
13:06:19 <lambdabot> forall b c a. ((b -> c) -> a -> b) -> (b -> c) -> a -> c
13:06:56 <mm_freak> conal: to clarify, what would ternary composition be?
13:07:05 <aristid> :t ((.) <$> id <*>)
13:07:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => ((a -> b) -> f a) -> (a -> b) -> f b
13:07:16 <conal> mm_freak: there's more than one notion.
13:07:17 <jmcarthur> conal: when i see something that looks elegant but is cryptic, i think that means i'm not understanding something that might be worth understanding. (it looks rather cryptic to me, too)
13:07:29 <Fuco> :t doesn't work in PM?
13:07:30 <lambdabot> parse error on input `in'
13:07:38 <jmcarthur> Fuco: try @type
13:07:43 <jmcarthur> i'm not sure why :t doesn't work in PM
13:07:44 <mm_freak> conal: ok, i need a notion to know what i want to implement
13:07:51 <Fuco> thanks :)
13:08:11 <conal> jmcarthur: me too!
13:08:31 <conal> so i'm not very sympathetic to objections to cryptic code. i like code that makes people smarter
13:08:51 <jmcarthur> yeah, so i tend to write a lot of point free code and people think i'm just intentionally obfuscating it
13:08:53 <kuffaar> Haskell is inherently cryptic
13:09:01 <kuffaar> Show any longer piece of Haskell to a C++ programmer
13:09:04 <jmcarthur> kuffaar: bull crap :P
13:09:17 <kuffaar> And they'd understand more of it if it was written in MIPS assembly
13:09:30 <mm_freak> kuffaar: show any longer piece of (real) C++ code to a C programmer
13:09:37 <aristid> kuffaar: C++ is inherently cryptic. Show any longer piece of Haskell to a MIPS assembly programmer
13:09:38 <jmcarthur> that just means C++ programmers don't like bottom-up programming as they might normally claim
13:09:41 <kuffaar> What does that have to do with Haskell
13:10:07 <mm_freak> kuffaar: a more powerful language looks always cryptic to a user of a less powerful language
13:10:18 <mm_freak> kuffaar: http://www.paulgraham.com/avg.html
13:10:29 <kuffaar> Paul Graham hates Common Lisp
13:10:36 <kuffaar> He hates the loop macro and CLOS
13:10:39 <kuffaar> He can fuck off
13:10:42 <jmcarthur> woah
13:10:46 <kuffaar> Don't read that dirt
13:10:53 <hpc> ...
13:10:54 <lambdabot> hpc: You have 1 new message. '/msg lambdabot @messages' to read it.
13:11:00 <mm_freak> kuffaar: have you read it?
13:11:05 <aristid> kuffaar: hey, please don't talk like that
13:11:06 <jmcarthur> kuffaar: you don't have to like the guy
13:11:39 <kuffaar> Sorry
13:11:41 <aristid> whenever somebody talks like that i think of the cargo cult guy :D
13:11:44 <mm_freak> kuffaar: if not, you should, from an objective standpoint disregarding that it was written by paul graham
13:11:45 <dolio> Common Lisp is bad, though. And Scheme. 'lambda' is too long, needs to be 'fn'.
13:12:01 <aristid> dolio: no, it has to be \
13:12:28 <hpc> or λ
13:12:32 <hpc> make them work for that code
13:12:33 <mm_freak> kuffaar: i'm referring to the blub paradox, which is explained in that article
13:12:51 <mm_freak> and is not inherently bound to common lisp
13:13:29 <mm_freak> the point is:  show any piece of real C++ code to a C programmer, and they will be as confused as a C++ programmer studying any longer piece of haskell code
13:13:42 <jmcarthur> kuffaar: i think the logical fallacy you seem to have succumbed to is called "poisoning the well".  something you perceive as bad about a person means something they say is false (or, at least in this case, not worth reading)
13:13:46 <kuffaar> mm_freak I already know it actually
13:13:46 <mm_freak> so it's not that haskell is cryptic…  it's just that not everybody has learned it
13:14:01 <jmcarthur> i point it out not to be an ass but to show why i didn't like what you just did
13:15:00 <mm_freak> in fact, i'm sure the C++ programmer will have a much easier time reading haskell than the C programmer will have reading C++
13:15:37 <tg_> mm_freak_: that seems unlikely, even if Haskell is better in some sense.
13:15:38 <EvanR-work> we should take object oriented for what it is, and not try to add attachments like implementation inheritance, multiple dispatch to try and make it a more general purpose tool
13:15:47 <revenantphx> mm_freak: I can attest to the C++ stuff.
13:15:50 <rmitt_> dolio: why do you say that Scheme is bad?
13:15:56 <jmcarthur> EvanR-work: that requires consensus on what OO is
13:16:06 <revenantphx> I'm really used to C, and usually looking at C++ involves a WTF?
13:16:13 <EvanR-work> jmcarthur: im a consensus of one ;)
13:16:20 <dolio> rmitt_: Because its keywords are too long. Arc fixes them.
13:16:20 <revenantphx> Actually, Java looks closer to C than C++ nowadays.
13:16:32 <mm_freak> tg_: note that good C++ programmers already know a lot of the concepts…  if they know /some/ FP, too, then they should be able to read (not write) haskell quite fluently
13:16:41 <jmcarthur> not many things look close to C++
13:16:55 <revenantphx> I can think of one, jmcarthur.
13:17:02 <revenantphx> http://cl.ly/44MT
13:17:21 <tg_> mm_freak: yes, but understanding concepts is somewhat disperate from the application of those concepts in a language
13:17:27 <kuffaar> I come from C++, Ruby and Common Lisp and I am struggling to achieve even the most basic things in Haskell
13:17:27 <olsner> IMO, knowing C++ was completely useless when I tried learning haskell
13:17:28 <mm_freak> tg_: a C programmer on the other hand has only the most basic language features…  no exceptions, no type polymorphism, no lambdas, …
13:17:35 <revenantphx> kuffaar: like what?
13:17:43 <revenantphx> "basic things" isn't the same in all languages.
13:17:58 <olsner> but haskell is probably easier to read than C++ for anyone not knowing it
13:17:59 <tg_> mm_freak: my point is, it's difficult to say this person (a C++ programmer) with such familiarity with that language, should quickly find Haskell more readable or comprehensible
13:18:14 <jmcarthur> revenantphx: is that a different language than C++? it looks just like quicksort in C++ to me
13:18:27 <revenantphx> jmcarthur: what?
13:18:48 <revenantphx> concat [qsortOneLine [y | y <- tail xs, y < x] ++ x : qsortOneLine [y | y <- tail xs, y >= x] | x <- take 1 xs]
13:18:50 <kuffaar> revenantphx: My first project in Haskell is a multi threaded SCGI server with a web development framework with OpenID auth support, a unified markup/LaTeX generation language, some YAML parsing and some PostgreSQL IO
13:18:52 <mm_freak> tg_: i'm not questioning that…  i'm not saying that a C++ programmer will find it /easy/ to read a haskell program
13:18:52 <revenantphx> doesn't look like C++ to me at all.
13:18:59 <jmcarthur> revenantphx: your link
13:19:06 <kuffaar> I think I struggled to even figure out how to perform synchronised console IO
13:19:08 <revenantphx> kuffaar: I like how you're throwing as many terms in there as possible.
13:19:10 <mm_freak> tg_: but a C++ programmer might find it easier to read haskell than a C programmer finds to read C++
13:19:13 <kuffaar> From multiple threads
13:19:14 <revenantphx> As if that somehow makes you look smarter.
13:19:24 <kuffaar> revenantphx: :(
13:19:31 <tg_> mm_freak: that's a much more sensible argument to me
13:19:41 <jmcarthur> guys, don't be so aggressive
13:19:48 <mm_freak> tg_: of course i'm assuming the old school C programmer, who has always denied that other languages might be better than C, and has never learned/understood advanced language features
13:19:53 <revenantphx> mm_freak: I agree wit hthat btw.
13:19:57 <EvanR-work> c++ does that to people
13:20:04 <djahandarie> aristid, a nice way of writing transpose: ala ZipList traverse
13:20:12 <revenantphx> mm_freak: I agree and I learned C for two years with barely any C++
13:20:16 <aristid> djahandarie: yay \o/
13:20:17 <revenantphx> like, almost never even looking at it.
13:20:20 <aristid> :t traverse
13:20:21 <lambdabot> Not in scope: `traverse'
13:20:29 <aristid> :t Data.Foldable.traverse
13:20:30 <lambdabot> Not in scope: `Data.Foldable.traverse'
13:20:33 <revenantphx> @hoogle traverse
13:20:34 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:20:34 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
13:20:38 <aristid> :t Data.Traversable.traverse
13:20:39 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:20:47 <mm_freak> revenantphx: yeah, and i'd even say that most programmers switching from C to C++ never write proper/idiomatic C++ code
13:20:53 <kuffaar> revenantphx: Are you saying I made it up? :[
13:20:55 <revenantphx> of course not :P
13:20:58 <revenantphx> kuffaar: Not at all.
13:21:01 <kuffaar> Oh, ok
13:21:11 <aristid> :t Data.Traversable.traverse . (ZipList .)
13:21:11 <lambdabot> forall a b (t :: * -> *). (Data.Traversable.Traversable t) => (a -> [b]) -> t a -> ZipList (t b)
13:21:12 <revenantphx> Just saying you're bandying around terms without needing too.
13:21:19 <aristid> :t getZipList .: Data.Traversable.traverse . (ZipList .)
13:21:21 <lambdabot> forall a b (t :: * -> *). (Data.Traversable.Traversable t) => (a -> [b]) -> t a -> [t b]
13:21:46 <aristid> djahandarie: like this?
13:21:49 <kuffaar> revenantphx: Well, I could have said "I'm rewriting my site in Haskell" but that wouldn't have revealed any technical details
13:21:49 <jmcarthur> kuffaar: haskell has quite a learning curve if all you know is imperative languages, yes
13:21:53 <kuffaar> Yeah
13:22:05 <aristid> kuffaar: but it's plenty of fun IMO :)
13:22:07 <kuffaar> And not just that
13:22:55 <aristid> Not just that: it also reeks of the stale stench of cargo cult mathematics
13:22:58 <aristid> or something like that.
13:23:00 <jmcarthur> *sigh*
13:23:11 <revenantphx> Imperative languages are like a bowl of apples. They're all different but relatively similar. Functional languages are like a bowl of tropical fruit. You've got your pineapple, your guava, your starfruit, your lychee... they're all unique and not suited to the same tasks.
13:23:24 <kuffaar> I don't know of any other language where functions get a special signature when they perform IO, etc
13:23:25 <revenantphx> But they are all delicious~
13:23:29 <djahandarie> aristid, (getZipList .: traverse $ ZipList)
13:23:44 <mm_freak> kuffaar: see Clean
13:23:46 <jmcarthur> kuffaar: that's a *good* thing about haskell ;)
13:23:50 <aristid> :t getZipList .: traverse $ ZipList
13:23:51 <lambdabot> Not in scope: `traverse'
13:23:56 <aristid> GAAAAH
13:23:59 <kuffaar> mm_freak I thought Clean was strongly inspired by Haskell
13:24:03 <aristid> :t getZipList .: Data.Traversable.traverse $ ZipList
13:24:04 <lambdabot> forall b (t :: * -> *). (Data.Traversable.Traversable t) => t [b] -> [t b]
13:24:20 <mm_freak> kuffaar: i don't know, but Clean is referentially transparent, too…  and it has a different IO concept than monads
13:25:06 <aristid> mm_freak: is it better or worse? :>
13:25:11 <conal> jmcarthur: thanks much for your shepherding in this chat room! encouraging clarity, objectivity, and civility.
13:25:50 * jmcarthur blushes
13:25:58 <revenantphx> You are a gentleman and a scholar.
13:26:00 <mm_freak> aristid: depends…  you can encode more information in the type system in Clean
13:26:21 <mm_freak> aristid: as far as i know you can even write a function, which can use a file handle and do no other side effects
13:26:48 <mm_freak> you can do that in haskell, too, but you need a special monad for that
13:27:13 <Egbert9e9> uh
13:27:33 <aristid> mm_freak: interesting. where can i read more about that?
13:27:38 <Egbert9e9> i know it's not funny at all
13:27:42 <mm_freak> aristid: in the Clean homepage =)
13:27:44 <Egbert9e9> but i'll say it anyways
13:27:53 <mm_freak> in → on
13:28:03 <aristid> mm_freak: http://www.cleanlanguage.co.uk/ ? :P
13:28:08 <Egbert9e9> haskell is like garfield
13:28:12 <Egbert9e9> because it's lazy
13:28:14 <mm_freak> aristid: anyway, i still prefer monadic IO, because you get elegant combinators
13:28:15 <Egbert9e9> <_<
13:28:59 <aristid> mm_freak: monadic IO is easy enough to use to have helped haskell's adoption, IMO
13:30:26 <mm_freak> aristid: yeah, also i think Clean has no type classes
13:30:37 <dolio> Clean has classes.
13:30:44 <dolio> But they can only contain one method each, as I recall.
13:30:50 <pastorn> dolio: that ought to compensate it...
13:31:05 <aavogt> dolio: that's not actually a limitation, no?
13:31:18 <dolio> Might depend.
13:31:19 <jmcarthur> the idea is that they are more fine-grained
13:31:42 <dolio> I mean, you can obviously break stuff up.
13:31:45 <jmcarthur> but since the same thing *can* be achieved with haskell type classes, i'm not sure whether i like it or not
13:31:48 <aavogt> dolio: well I think all H98 classes can safely be split up
13:32:08 <dolio> What about Ord? That has multiple minimal definitions for instance.
13:32:09 <jmcarthur> the ability to do something doesn't mean that it's as natural as when it's the default
13:32:39 <jmcarthur> dolio: defaulting across multiple classes would solve that
13:32:51 <jmcarthur> i kind of want a similar feature in haskell
13:32:59 <aristid> fmap = liftM
13:33:01 <jmcarthur> define a monad instance and defaulting gives you applicative and functor
13:33:03 <jmcarthur> yeah
13:33:14 <mm_freak> well, the only feature from Clean i miss in haskell is uniqueness types
13:33:16 <j-invariant> instance Monad m where ... deriving Functor, Applicative
13:33:30 <dolio> So you'd split Ord into two type classes that mutually define each other?
13:33:43 <dolio> One for, say, (<=), and another for compare?
13:34:01 <dolio> And all the other derived operators that can be overrided to be more efficient.
13:34:16 <jmcarthur> j-invariant: http://hpaste.org/42828/superclass_defaults
13:34:36 <jmcarthur> dolio: sure, i think that would be a decent approach
13:34:48 <dolio> I don't.
13:35:14 <jmcarthur> dolio: i don't know of Clean has that feature, by the way. i'm just musing on possibilities
13:35:17 <jmcarthur> *if Clean
13:35:36 <dolio> foo :: (Eq a, Le a, Gt a, Comparable a) => ...
13:36:00 <jmcarthur> dolio: a Clean developer might look at haskell type classes and wonder at how much extra work it would be to divide them up the way they are used to, too
13:36:23 <jmcarthur> yeah, rather like that ^^
13:36:42 <mm_freak> i'd prefer a nice interface between the two languages, because Clean is good for fast algorithms, while haskell is good for fast/elegant high level stuff
13:36:44 <jmcarthur> that is, i agree with you that it's messy and ugly for this case
13:36:56 <Saizan> make them circularly a superclass of each other
13:37:06 <aristid> how about just one type class Comparable and accept the lower efficiency?
13:37:07 <jmcarthur> Saizan: yeah that's the idea here i think
13:37:19 <jmcarthur> oh i didn't catch that dolio was giving a *function* definition
13:37:43 <dolio> My point is: there exist classes that make sense as a single unit with multiple related functions, and not so much as a hierarchy.
13:37:46 <jmcarthur> still, it's quite some boilerplate just to define a class
13:38:03 <jmcarthur> rather... a class of classes...
13:38:28 <dolio> So making the former impossible doesn't seem like a good decision to me, even if a lot of classes can be split up that way, and should be split up that way.
13:38:41 <jmcarthur> i agree
13:38:56 <dolio> I mean, I'm in favor of having both join and (>>=) in Monad.
13:38:58 <mm_freak> at least we would 
13:38:59 <jmcarthur> i was just saying that dividing it up by default doesn't mean you can't define something like Ord
13:39:12 <mm_freak> at least we wouldn't have the Functor/Applicative/Monad dilemma
13:39:13 <dolio> And they're both sufficient given a functor prerequisite.
13:39:36 <adu> mm_freak: and what dilemma is that?
13:40:19 <fryguybob> mm_freak: This is something along the lines of an interface between the two: http://www.cs.ru.nl/~thomas/publications/groj10-exchanging-sources-between.pdf
13:40:29 <mm_freak> adu: that a value of type "Monad m => m a" may give you a compiler error:  Couldn't deduce Functor m from Monad m
13:40:46 <adu> interesting
13:42:27 <mm_freak> fryguybob: doesn't seem to be an /interface/, but rather a third superlanguage
13:42:40 <fryguybob> mm_freak: Right.
13:43:16 <mm_freak> and from what i'm reading i'd be very limited in what haskell features i can use
13:43:52 <mm_freak> i usually don't get very far without my beloved existentials, type families and scoped type variables =)
13:45:03 <Serke> Speaking about Clean, its developers are working on a new front-end to the compiler that will accept Haskell 98 source code. They claim it will be possible to mix Haskell and Clean code and make use of both Haskell and Clean libraries. See http://wiki.clean.cs.ru.nl/Latest_developments
13:46:08 <j-invariant> wow
13:46:16 <j-invariant> whwy not just use haskell X)
13:46:31 <EvanR-work> clean is not dead yet?
13:46:34 <fryguybob> Serke: That's referring to the paper I linked to.
13:48:19 <Serke> EvanR-work: apparently, no. Clean 2.3 was released not too long ago
13:49:10 <finnomenon> hi
13:53:20 <Cale> hello
13:54:04 <EnglishGent> hello Cale :)
13:54:46 <glguy> NOOOOO
13:54:51 <glguy> not a feeling...
13:54:56 <glguy> back to the choons
13:55:04 <glguy> (omg, wrong chanel again)
13:55:17 * glguy isn't configured for IRC multitasking
13:55:45 * EnglishGent knows the problem
13:55:51 <EnglishGent> I need to get a multi-core brain :|
13:56:07 <djahandarie> I need a less parallel brain :)
14:01:18 <ddarius> dolio: At some point they added full Haskell-like classes.
14:01:32 <dolio> Ah, okay.
14:01:47 <ddarius> There's also something else they made more like Haskell, but I forget what it was.
14:02:00 <edwardk> i have to admit the biggest turn off to me about clean is the mismash of issues with partial application due to uniqueness types and the horrible syntax used for types =)
14:03:56 <edwardk> my brain is a rather streamlined concurrent system, just not a parallel one. i'm not random and inconsistent about what i work on, i'm just time slicing!
14:04:37 <EnglishGent> I'll have to remember that one....
14:04:43 <edwardk> i also avoided using a fair scheduler in the interest of efficiency. this may be a design flaw.
14:05:07 <EnglishGent> :)
14:05:08 <edwardk> … and by the time i get back to something, its mostly been paged out.
14:05:32 <aristid> edwardk: maybe you should introduce a forceful fairness rescheduling every once in a while, but not on every schedule
14:05:56 <Egbert9e9> what does it mean 
14:06:00 <edwardk> those are called deadlines =)
14:06:07 <Egbert9e9> "type-valued expression"?
14:06:46 <cantropy> hello! I am trying to wrap my head around the difference between curring and function compositions. A few minutes of a standard beginner text gives me a feeling that both can be used to build higher order functions but I don't have a grasp of the exact difference between the two.
14:07:05 <cantropy> an interesting analogy might be to the unix shell
14:07:26 <cantropy> I know composition is something like using pipes to connect two or more programs
14:07:39 <cantropy> what is the unix shell equivalent of currying then?
14:07:42 <cantropy> eval?
14:07:47 <c_wraith> it doesn't really have one
14:07:51 <edwardk> currying takes a function that takes a pair and makes it a function that takes an argument and returns a function that expects the remaining one. composition takes two functions and pipelines them
14:08:10 <edwardk> cantropy there isn't really one
14:08:29 <tac-tics> Currying just means instead of (a, b)->c, you use a->b->c
14:08:33 <c_wraith> currying is breaking one function into multiple smaller pieces.  composition is combining multiple small pieces together.
14:08:36 * EnglishGent remembers telling people a while back that the Unix shell was trying to be a lazily evaluated functional language.... and failing
14:09:08 <tac-tics> @type \(x,y)->(+) x y
14:09:09 <lambdabot> forall t. (Num t) => (t, t) -> t
14:09:27 <tac-tics> \x -> \y -> (+) x y
14:09:39 <tac-tics> @type \x -> \y -> (+) x y
14:09:40 <lambdabot> forall a. (Num a) => a -> a -> a
14:10:05 <tac-tics> The difference is the first requires both parameters at once
14:10:06 <ddarius> Shell script has curry/uncurry iff it has higher-order functions.  Which I'm pretty sure most do via evil string hackery and eval.
14:10:11 <regularlambda> is haskell can be used for AI?
14:10:14 <tac-tics> The second can take one at a time
14:10:17 <ddarius> (if not directly)
14:10:51 <regularlambda> which language is the best for AI?
14:10:58 <regularlambda> drop me a line pls
14:11:17 <ion> What was Skynet implemented in again?
14:11:21 <EnglishGent> regularlambda - that really depends what kind of problem your trying to solve
14:11:25 <edwardk>   regularlambda: haskell works fine for AI
14:11:26 <EnglishGent> ion - Perl :P
14:11:30 <cantropy> c_wraith: how does it mean in practise breaking one function into smaller pieces, it sort of python generators?
14:11:34 <regularlambda> machine learning EnglishGent 
14:11:35 <djahandarie> I would say Haskell doesn't have enough useful libraries for AI
14:11:50 <djahandarie> You'd need to come up with a lot of stuff from scratch
14:11:52 <EnglishGent> Lisp is a fairly tradditional choice for AI - as is Prolog
14:11:56 <cantropy> c_wraith: like using yield in a function, ... maybe not quite.
14:11:59 <EnglishGent> (though I dont recommend Prolog)
14:12:25 <revenantphx> I'd seriously recommend INTERCAL for that task.
14:12:29 <revenantphx> It's great for AI programming.
14:12:39 <djahandarie> IIRC, a lot of the AI stuff was being held by back by the graph library situation
14:12:40 <regularlambda> EnglishGent: yes it is very difficult and hardly connected with perl modules and python scripts
14:12:52 <c_wraith> cantropy: It's more like saying "this function, it actually is a function that returns a function that returns a function.  So you can use it to return a function that you can then use later, if you like"
14:13:44 <tac-tics> You dawg, I heard you like functions, so I wrote a function that returns a function so you can curry while you code
14:14:16 <edwardk> djahandarie: yeah tomberek went off with ivanm to hack on fgl, and the work on hnn kinda dried up (didn't help that alpounet's computer died around that time)
14:14:20 <cantropy> c_wraith: is that something like the adapter design pattern, only more flexible ... ?
14:15:17 <c_wraith> cantropy:  kind of.  currying is actually pretty simple in practice.  You should just play with it a bit.
14:16:00 <cantropy> c_wraith: yes, I have, only I am trying to put into my head a conceptual picture of what it exactly is. its more like a function object that can be applied with an argument.
14:17:16 <ion> If you can do ‘f 1 2 3’, ‘let g = f 1 2 in g 3’ or ‘(f 1 2) 3’ is the same thing.
14:17:16 <edwardk> > let foo (x,y) = x + y; bar = curry foo; baz = bar 1 in baz 12
14:17:17 <lambdabot>   13
14:17:40 <edwardk> foo takes a pair as its argument, bar is a curried version f foo, which means you can call bar 1 2 instead of foo (1,2)
14:17:54 <c_wraith> cantropy: It's really best to just think of them as partially applied functions.  They're inert until their final argument comes along.
14:18:10 <edwardk> baz is bar partially applied, by fixing the first argument to be '1'. you can then call baz multiple times with different choices for the second argument
14:18:21 <edwardk> but since (+) is already curried, this becomes
14:18:30 <cantropy> edwardk: I wonder what is the :t of curry in that snippet you wrote
14:18:31 <edwardk> > let inc = (+) 1 in inc 12
14:18:32 <lambdabot>   13
14:18:58 <edwardk> technically its Num a => a — but you can think of it as Int
14:19:06 <edwardk> er of curry
14:19:08 <edwardk> :t curry
14:19:09 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:19:22 <edwardk> curry f a b = f (a,b)
14:19:24 <ddarius> The type says "everything."
14:19:45 <edwardk> :t uncurry
14:19:46 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:20:00 <edwardk> uncurry f ab = f (fst ab) (snd ab)
14:20:03 <cantropy> ddarius: it will take make a little getting used to, to read the haskell type defs
14:20:14 <cantropy> ddarius: take me
14:20:26 <edwardk> cantropy: so soon, you just met =)
14:20:45 <Cale> lol
14:20:52 <cantropy> edwardk: :) it was a correction to previous typo
14:20:53 <ddarius> uncurry ~(a,b) = f a b
14:21:00 <ddarius> + f
14:21:10 <ion> Since you know python: >>> plus = lambda a: lambda b: a+b; inc = plus(1); (plus(3)(4), inc(42))
14:21:12 <edwardk> i was leaving off irrefutable patterns for another time =)
14:21:12 <ion> (7, 43)
14:21:35 <aristid> @src fst
14:21:36 <lambdabot> fst (x,_) =  x
14:21:50 <aristid> shouldn't fst use an irrefutable pattern there, too?
14:21:51 <ion> > let plus = (+); inc = (+) 1 in (plus 3 4, inc 42)
14:21:52 <lambdabot>   (7,43)
14:22:03 <aristid> hmm, no, it does not need to
14:22:21 <edwardk> aristid: it won't happen until you force its answer at which point it needs to force anyways
14:23:11 * ddarius considers going and eating a steak somewhere.
14:23:33 * ddarius also considers doing his schoolwork now that he has schoolwork again.
14:24:21 <j-invariant> ddarius: what type of classis i t?
14:24:57 <edwardk> given ddarius's predilection for random travel, i have this bad visual if him grilling up a steak, then taking it cross country and eating it in some sort of http://www.wherethehellismatt.com/ scene
14:25:15 <djahandarie> Hahaha
14:25:15 <edwardk> the t-shirt is about right
14:26:43 <cantropy> @src curry
14:26:43 <lambdabot> curry f x y = f (x, y)
14:26:48 <cantropy> @src uncurry
14:26:48 <lambdabot> uncurry f p = f (fst p) (snd p)
14:26:54 <ddarius> edwardk: I was talking to JJ about the Moab desert.  And by that I mean JJ was talking to me about it.  I want to go now.
14:27:02 <edwardk> hahahaa
14:28:33 <djahandarie> "Deilitarized Zone, Korea" got a laugh out of me in that video
14:29:55 * EnglishGent suggests that ddarius fork .. and then he can eat steak *and* do schoolwork :)
14:30:42 * cantropy wonders if there is a command instruction help for lambdabot
14:31:09 <alpounet> edwardk, that's the least you can say :p
14:31:49 <edwardk> alpounet: Feel free to correct me i'm wrong about the fate of hnn
14:32:04 <alpounet> you are not
14:32:16 <alpounet> mostly held off by fgl, since thomas wants better graphs
14:32:28 <alpounet> and by the lack of time and the fact that my laptop just gave up
14:32:59 <cantropy> \me finds lambdabot instruction set at http://code.haskell.org/lambdabot/COMMANDS
14:34:14 <ivanm> alpounet: yeah, work on FGL halted a bit as well; we're trying to get the underlying graph library abstractions in place first
14:34:27 <EnglishGent> lambdabot - open the pod bay doors please
14:34:30 <alpounet> ivan, yeah, I read your blogposts :)
14:34:37 <alpounet> i have read*
14:34:48 <ivanm> it doesn't help that tomberek is online and working on it when I'm busy with uni stuff, but now that I'm working on it he's not here ;-)
14:34:56 <alpounet> heh
14:35:12 <cantropy> is there a cabal install switch which will also keep the haskell source code?
14:35:37 <alpounet> ivan, and moreover, coming up with "the" good abstraction is really, really hard
14:35:42 <dcoutts_> cantropy: sorry, not yet
14:35:45 <alpounet> i discussed it a bit with Thomas
14:35:54 <ivanm> yup
14:36:06 <ivanm> the arguments about dealing with labels is a case in point :s
14:36:07 <dcoutts_> cantropy: it'll be much easier once we add proper "ways" support to the build system
14:36:33 <EnglishGent> ivan - is the discussion on the graph library archived somewhere?
14:36:38 * EnglishGent would be interested to see it :)
14:36:45 <dschoepe> EnglishGent: on gmane probably
14:36:50 <cantropy> dcoutts_: but it downloads the source first anyway isn't it? but just deletes it afterwards, right?
14:37:21 <ddarius> Cripes.   The material has moved from Python to Java.
14:37:31 <EnglishGent> dschoepe - linky? :)
14:37:41 <edwardk> maybe I _should_ dig out and polish that comonadic graph library after all =P
14:38:02 <ivanm> EnglishGent: various places
14:38:15 <ivanm> a lot of the stuff was tomberek and I talking about it via google chat though
14:38:16 <dschoepe> EnglishGent: http://search.gmane.org/?query=fgl&author=&group=gmane.comp.lang.haskell.cafe&sort=relevance&DEFAULTOP=and&xP=Zgraph&xFILTERS=Gcomp.haskell.cafe---A
14:38:39 <ivanm> I have links to it at various points in my blog posts, mainly the later ones about FGL, etc.
14:39:02 <ddarius> "By the end of this course, the student shall be able to satisfy the following outcomes expectations:    * Module 1          o Explain the basic logic of probability theory"  This should be interesting...  (not the content, the impending interactions)
14:39:35 <EnglishGent> thanks :)
14:40:20 <Egbert9e9> "A benefit of lazy evaluation is that you can write code like an Icon or Python generator that spins forever, returning a value on each cycle, and it will only be called for the exact number of returns that the enclosing program actually needs even if the caller is itself a generator."
14:40:48 <Egbert9e9> oh
14:40:49 <Egbert9e9> nvm
14:42:42 <EnglishGent> beh - I think my client is using unsafePerformIO :|
14:45:16 <dcoutts_> cantropy: ohh, that's what you mean, well it's east enough to unpack the tarball, use cabal unpack foo-1.0
14:45:33 <dcoutts_> cantropy: I thought you meant to install the pre-processed Haskell sources
14:45:56 <alpounet> ivanm, regarding the labels, i was maybe thinking of a Labels module
14:46:25 <alpounet> but it has its drawbacks too
14:48:45 <cantropy> dcoutts_: so isn't cabal unpack not equivalent to installing pre-processed Haskell sources?
14:49:30 <monochrom> there is no pre-processing
14:49:34 <dcoutts_> cantropy: by pre-processed I mean after running the pre-processors
14:49:48 <dcoutts_> perhaps a confusing term
14:49:52 <dcoutts_> post-pre-processed :-)
14:49:53 <adulteratedjedi> `/exit
14:50:30 <monochrom> cabal unpack simply tar -xzf the tar.gz
14:51:01 <cantropy> monochrom: okay
14:53:46 <pastorn> @type fixM
14:53:47 <lambdabot> Not in scope: `fixM'
14:53:54 <cantropy> dcoutts_: I haven't yet read the cabal user guide ..
14:55:39 <pastorn> how do i write this with mfix? http://hpaste.org/43134/fix
14:55:46 <pastorn> i intend to use it with
14:56:05 <pastorn> seek (== "login:") (hGetLine h)
14:56:41 <monochrom> mfix won't be useful
14:56:50 <gwern> well, so much for installing ghc 7. wound up with a bunch of inscrutable cabal dep errors regarding directory
14:56:53 <pastorn> it won't? but i have the recursion and all there...
14:57:17 <monochrom> another victim of reasoning by words
14:57:25 <monochrom> see http://www.haskell.org/haskellwiki/MonadFix
14:57:47 <monochrom> in particular I quote myself: It is tempting to see “recursion” and guess it means performing actions recursively or repeatedly. No.
14:58:22 <EnglishGent> wb tapwater_
14:58:38 <monochrom> the same calibre of reasoning as "the empty set is about empty, the empty string is about empty, 0 is about empty, therefore they're all the same"
14:59:08 <monochrom> (perhaps they're the same in the likes of lisp and scheme)
14:59:20 <EnglishGent> well they are all related... in many languages their all false in a boolean context
14:59:21 <Philippa> more likely to be in PHP
14:59:56 <Philippa> they're related by the concept of emptiness, yes (though less so if 0 isn't a natural or /maybe/ integer)
15:00:09 <monochrom> "they are related" is the most tautological and irrelevant statement ever. everything is related to everything.
15:00:10 <EnglishGent> pairs of lists & lists of pairs are isomorphic - but they arent the same
15:00:27 <EnglishGent> yes - but you know what I mean monochrom :P
15:00:34 <ben> monochrom: There is a certain logic in making the identity elements of their repspective monoids identify with each other
15:00:39 <aristid> class SomehowSimilar a where somewhatEqual :: a -> a -> Bool
15:02:09 <lpsmith_> Is there a haskell package for writing your own telnet server?
15:02:53 <aristid> lpsmith_: huh? isn't telnet a pretty trivial protocol?
15:03:02 <ivanm> alpounet: "Labels module" ?
15:03:49 <alpounet> ivan, yeah, a module that would export label-versions of the graph functions
15:03:55 <lpsmith_> aristid, yeah,  just curious
15:04:19 <ivanm> alpounet: same problems
15:04:36 <ivanm> much easier IMHO to have compulsory labels but have a module for cases where the label is ()
15:04:53 <ivanm> (or maybe make it for (Monoid l) and use mempty...)
15:05:00 <alpounet> hm
15:05:02 <alpounet> good point
15:05:05 <ddarius> EnglishGent: I would not call pairs of lists and lists of pairs isomorphic.  What is the list of pairs that corresponds to ([2],[]) ?
15:05:08 * azaq23 noticed that the hugs version at codepad.org can't handle negative bases for (**), not that this matters
15:05:20 <ivanm> ddarius: [(2,undefined)] :p
15:06:14 <EnglishGent> [(2, bottom)]
15:07:01 <ivanm> undefined, bottom, same diff
15:08:03 <ddarius> Then what is the list of pairs that corresponds to ([2], 1:undefined)
15:08:23 <monochrom> time to invoke "you know what I mean" again
15:08:36 <aristid> [(Just 2, Nothing)]
15:08:49 <EnglishGent> it's a fair point though - I should have said pairs of lists, where both lists are the same length :)
15:09:00 <regularlambda> >
15:09:37 <centrinia> What does ([2,1],[undefined,undefined]) correspond to?
15:09:53 <regularlambda> two tuples with no linkage
15:09:54 <regularlambda> :P
15:09:59 * EnglishGent duly invokes it :P
15:10:11 <aristid> > uncurry zip ([2,1],[undefined,undefined])
15:10:12 <lambdabot>   [(2,*Exception: Prelude.undefined
15:10:22 <ddarius> centrinia: [(2,undefined), (1, undefined)]
15:15:13 <Egbert9e9> i feel so dirty reading about bob
15:15:25 <monochrom> wrong window?
15:15:29 * EnglishGent passes Egbert9e9 some soap
15:15:40 <Egbert9e9> http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
15:16:28 <Egbert9e9> not that i'm going to stop
15:17:25 <Egbert9e9> Mathnerd314, tauday.com
15:20:25 <Evious> Is iteratee the successor to the enumerator package?
15:20:46 <dankna> okay so
15:20:49 <dankna> I'm embarrassed asking this
15:20:58 <dankna> but what's the name of the floating-point modulus function?
15:21:27 <EnglishGent> gotta go - have a nice evening everyone :)
15:21:37 <dankna> @hoogle Real -> Real -> Real
15:21:37 <lambdabot> Warning: Unknown type Real
15:21:37 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:21:37 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
15:21:48 <dankna> @hoogle Real a => a -> a -> a
15:21:48 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
15:21:49 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:21:49 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
15:22:12 <dankna> yeah I saw mod' in Data.Fixed, but surely it can't be that?  why is it in Data.Fixed?
15:23:17 <centrinia> Just multiply your floats by some power of the base so that they become integers, do the modulo operation, and then divide the result by that power of the base that you computed earlier.
15:23:45 <dankna> !  haha
15:24:30 <dankna> you're lucky I'm not a newcomer to the language or you'd be dealing with one confused would-be coder :)
15:25:03 <aristid> dankna: maybe mod' is just especially useful with Data.Fixed?
15:25:21 <dankna> aristid: I guess
15:25:29 <ion> Being new to a specific programming language isn’t really relevant in this case. :-P
15:25:42 <dankna> well, yeah, I guess I meant, you're lucky I'm not new to programming
15:25:55 <dankna> not that I object to a joke
15:26:06 <dankna> but I can just picture the hapless person who took that as serious advice
15:26:30 <dankna> actually, that would be pretty funny to see
15:27:22 <ion> Another idea along the lines of centrinia’s: just cast the float as an integer and do integer modulo.
15:27:36 <centrinia> That can cause a serious loss of precision.
15:28:19 <dankna> "Total loss of precision" is my favorite cool-sounding error message.
15:28:20 <ion> I mean, float a; return *(int *)&a;
15:28:47 <danr> dankna: when do you get that error message?
15:28:48 <aristid> somehow it suddenly scares me that most crypto software is written in C
15:28:49 <centrinia> ion, you will get the exponent and sign fields with the mantissa.
15:29:00 <ion> centrinia: yes
15:29:10 <dankna> danr: I believe that it happens if for example you try to compute 1.0e128 - 1.0e-128
15:29:11 <sioraiocht> aristid: what do you want it written in?
15:29:26 <dankna> danr: I'm not really sure, though
15:29:28 <aristid> sioraiocht: haskell of course! lol
15:29:47 <sioraiocht> aristid: write something!
15:29:57 <aristid> sioraiocht: i'm not cryptographer.
15:29:58 <danr> dankna: interesting. thanks :)
15:30:01 <dankna> sure :)
15:30:07 <sioraiocht> aristid: surely you can read an algorithm, though!
15:30:10 <aristid> you know the rule: only cryptographers should write crypto code.
15:30:19 <dankna> I've written crypto code.  It worked.  I don't know how.
15:30:26 * sioraiocht is using exclamation points cuz it's late!
15:30:28 <dankna> so I definitely second what aristid just said
15:30:39 * sioraiocht took a course in crypto in undergrad...
15:30:48 <sioraiocht> I vaguely understand why public key encryption works
15:31:09 <dankna> well, that leads into deep questions like what it means to understand why it works :)
15:31:12 <sioraiocht> but yes, when I read why some crypto applicaiotn is "insecure" I always thing WTF I would never have thought of that
15:31:19 <dankna> indeed
15:32:19 <dankna> supposedly the existence of differential cryptanalysis took everyone by surprise - the NSA released a tiny patch to the RSA algorithm with the purpose of making it harder, and that was how the world learned that their crypto had never been secure in the first place :)
15:32:33 <dankna> I don't know how true the story is though
15:33:07 <monochrom> untrue
15:33:12 <ion> This isn’t exactly C’s fault, more like the programmer’s fault for putting inconspicuous side-effects in function call parameters, but anyway: http://www.daemonology.net/blog/2011-01-18-tarsnap-critical-security-bug.html
15:33:36 <aristid> ion: well, haskell does encourage splitting out side effects :)
15:33:42 <ion> indeed
15:35:32 <mkscrg> hello, i'm just picking up haskell and want to define a type which is a positive integer in [1..10]
15:35:42 <monochrom> can't be done
15:35:48 <sproingie> that's actually more than a little tricky
15:35:53 <j-invariant> mkscrg: imptossible
15:36:01 <sproingie> data OneToTen = One | Two | Three ...
15:36:36 <mkscrg> is there something like a guard expression, but for type constructors?
15:36:45 <monochrom> no
15:40:55 <arnihermann> I'm having troubles with cabal, I have a dependency on HStringTemplate, but when I run configure on my project, I get: Setup.hs: At least the following dependencies are missing: HStringTemplate ==0.6.6
15:40:59 <arnihermann> any thoughts?
15:41:00 <Gracenotes> mkOneToTen :: Int -> Maybe OneToTen
15:41:24 <ivanm> arnihermann: check your .cabal file
15:41:26 <monochrom> do you have HStringTemplate version 0.6.6?
15:41:39 <arnihermann> I installed it ages using cabal
15:41:42 <monochrom> I mean do you have it installed and recognized properly
15:41:46 <ivanm> that version seems overly restrictive
15:41:47 <dcoutts_> arnihermann: use the cabal program both for installing other packages and for working with your own package (rather than using runghc Setup.hs blah)
15:41:55 <arnihermann> dcoutts_: ah!
15:41:56 <ivanm> arnihermann: "ghc-pkg list HStringTemplate"
15:42:01 <arnihermann> ivanm: it's in there
15:42:13 <arnihermann> I was using runhaskell Setup.hs
15:42:21 <monochrom> well why would that fail
15:42:31 <ivanm> monochrom: I'm guessing it uses global pkg-db by default
15:42:38 <ivanm> whereas cabal-install uses local by default
15:42:39 <monochrom> oops
15:42:46 * ivanm just figured that out as well
15:42:52 <dcoutts_> arnihermann: the technical difference is that the default for runghc Setup.hs is to do global installs, the default for the cabal program is per-user installs.
15:43:15 <arnihermann> dcoutts_: that worked
15:43:18 <arnihermann> right
15:43:25 <arnihermann> thanks!
15:43:28 <Zao> dcoutts_: I'm sure you can say --user to Setup too, right?
15:43:31 <dcoutts_> arnihermann: and since global packages cannot depend on per-user ones, then when it's doing a global install it does not look at the per-user package db. The error message could be better though.
15:43:36 <dcoutts_> Zao: that's right.
15:43:57 <dcoutts_> Zao: but I think it's more helpful advice to tell people to use the same program for both.
15:44:17 <Zao> dcoutts_: Sure.
15:44:39 <Zao> dcoutts_: I do kind of dislike the duality of using cabal-install standalone and using cabal-install inside a source tree.
15:45:18 <dcoutts_> Zao: what do you mean by duality? what is it you don't like?
15:45:28 <monochrom> ln -s /usr/bin/cabal /usr/bin/build-by-cabal
15:46:39 <Heffalump> dcoutts_: have you seen these emails about broken SMTP @projects.haskell.org ?
15:46:45 <dcoutts_> the main reason that both aspects, building pre-prepared packages, and local builds is in one tool is because when building a local package with external deps, it is useful to get those pulled in
15:46:48 <dcoutts_> Heffalump: I've not
15:46:59 <Heffalump> there've been a few on Haskell-cafe
15:47:03 <dcoutts_> Heffalump: is it still broken?
15:47:18 <Heffalump> I think so (no MX record, nothing listening on port 25 of the A record)
15:47:19 * dcoutts_ notes that the community server still needs to move to it's more beefy VM
15:47:36 <c_wraith> dcoutts_: it'd be better if you could get the external deps for your local package *without* using the "install" command.
15:47:50 <Heffalump> I just forwarded you a copy of one of said complaints
15:48:35 <ivanm> didn't someone just say they were going to check it out?
15:48:58 <dcoutts_> c_wraith: you can, use cabal install --dry-run
15:49:14 <dcoutts_> c_wraith: I'll also be adding a cabal install --only-dependencies flag
15:49:31 <dcoutts_> ie install the deps of the things you specify, not the things themselves
15:49:34 <c_wraith> dcoutts_: Hmm.  Didn't realize --dry-run would interact like that with install with no packages listed
15:49:54 <dcoutts_> c_wraith: "cabal install" on it's own is equivalent to "cabal install ./"
15:50:05 <dcoutts_> c_wraith: though the latter syntax is only available in the next release
15:50:18 <Heffalump> ivanm: ah, yes, Yitzchak Gale said something on haskell-cafe a few hours ago
15:50:52 <dcoutts_> ah, did yitz say he was on the issue?
15:50:55 <accel> is there a haskell library to give me direct access to memory layout + code generation?
15:50:57 <dcoutts_> he's on the admin team
15:51:00 <c_wraith> dcoutts_: in my experience, "cabal install --dry-run foo" hasn't ever installed anything..  Just told me what it would install.  Is it actually different?
15:51:28 <accel> say I have (in C) struct Vec3{ float x, y, z;} ; and I want to define a Vec3 plus(Vec3, Vec3); is there a way in haskell that I can have memory layout control & generate assembly code?
15:51:43 <dcoutts_> c_wraith: I don't quite get your question. --dry-run just means it does not actually install anything but lists what it would install
15:52:09 <c_wraith> dcoutts_: I was hoping for the --only-dependency flag functionality.
15:52:18 <c_wraith> which it sounds like will be available in the future
15:52:19 <dcoutts_> c_wraith: ok, next release
15:53:01 <ddarius> accel: You could use the Foreign hierarchy, but if memory layout and precise assembly are that important to you, you are probably better off writing those portions in a different language.
15:53:37 <Heffalump> dcoutts_: he said he tried to fix it (by restarting exim) but failed and that he'd bring it up with the other admins
15:53:48 <dcoutts_> Heffalump: ok
16:00:46 <kuffaar> Bah, I'm really not getting along with TagSoup
16:00:52 <sbahra> edwardk: Ping?
16:00:52 <lambdabot> sbahra: You have 1 new message. '/msg lambdabot @messages' to read it.
16:01:16 <kuffaar> Regex is so much easier :/
16:01:30 <kuffaar> I can't believe I tried to do this in Haskell, I would have solved this in Ruby in under 6 minutes
16:01:41 <tolkad> If I'm writing a web server in haskell and I want a maximum memory usage for each thread generated in response to a web request, is there any way to do that?
16:01:44 <monochrom> the opposite for me
16:02:05 <tolkad> like the way PHP has a max memory usage for each request thread
16:02:30 <monochrom> if regex is easier, use regex, you can still use haskell
16:02:54 <kuffaar> monochrom but people give me crap for using RE for this all the time
16:03:08 <kuffaar> But I don't really get TagSoup hm
16:03:16 <dankna> tolkad: that's an interesting security policy.  I didn't know PHP had that.  well, I think the answer is that there's no way.
16:03:18 <tolkad> kuffaar: you tried parsec?
16:03:25 <kuffaar> Nope, not familiar with it
16:03:33 <kuffaar> tolkad can it deal with malformed HTML?
16:03:48 <tolkad> kuffaar: it's a general parsing library.
16:03:58 <kuffaar> That doesn't sound like fun
16:04:03 <aristid> it is fun.
16:04:09 <aristid> maybe not when you deal with html tho.
16:04:17 <monochrom> people should not give you crap. regex itself should give you crap. since regex isn't quite suitable. but my attitude is that you should find it out yourself.
16:04:18 <Zao> dcoutts_: The change in semantics from a package manager to a tool which you can tell to configure/build/install.
16:04:30 <Zao> Where install there has a completely different meaning from  cabal install asdf
16:04:30 <kuffaar> Regex is very suitable for this
16:04:31 <tolkad> kuffaar: yeah it's pretty easy. you could probably write a translator directly from regex to it anyway
16:04:55 <aristid> Zao: isn't asdf a lisp tool? :)
16:05:12 <Zao> dcoutts_: I also dislike how cabal-install refuses to mention any errors you get when installing things that fail due to missing configure environment, missing libraries, etc.
16:05:36 <Zao> Just "there was an error, lol", after which you have to cabal unpack the offender and build manually just to find out what was wrong at all.
16:05:40 <Zao> </rant>
16:05:41 <tolkad> kuffaar: you shouldn't encounter any malformed html on legitimate websites
16:05:41 <kuffaar> aristid yues it is
16:05:45 <ivanm> Zao: well, cabal-install isn't a package manager ;-)
16:05:47 <tolkad> kuffaar: just get an SGML parser
16:05:52 <Zao> ivanm: You know what I mean.
16:05:57 <kuffaar> <tolkad> kuffaar: you shouldn't encounter any malformed html on legitimate websites <- very funny
16:06:08 <ivanm> tolkad: doesn't google return malformed HTML so as to save on bandwidth?
16:06:10 <kuffaar> But the sites I deal with are almost always malformed anyways
16:06:18 <tolkad> ivanm: I think it's valid SGML, isn't it?
16:06:41 <ivanm> yes, but not valid HTML-4 (but will apparently be valid HTML-5 once the standards are finalised, etc.)
16:06:51 <tolkad> yeah so just get an SGML parser
16:07:02 <tolkad> unless it's that badly malformed that it's not even SGML
16:07:17 <kuffaar> Resolving dependencies...
16:07:17 <kuffaar> Segmentation fault/access violation in generated code
16:07:21 <kuffaar> Yay for cabal.
16:07:28 <tolkad> 0_0
16:07:29 <kuffaar> Configuring AfraidParser-0.1...
16:07:29 <kuffaar> Segmentation fault/access violation in generated code
16:07:31 <kuffaar> And more of it
16:08:32 <tolkad> kuffar: Parsec is much more readable than regex and makes it possible to compose parsing rules
16:08:33 <aristid> kuffaar: sounds like something is gone seriously awry
16:08:44 <kuffaar> aristid this happens quite frequently
16:09:04 <aristid> kuffaar: which platform are you on?
16:09:10 <tolkad> kuffaar: see this page for some examples: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
16:09:11 <kuffaar> Windows 7 64-bit
16:09:23 <aristid> kuffaar: ok, got no experience with that.
16:09:28 <kuffaar> Of course not
16:09:37 <kuffaar> Windows users are third class citizens
16:09:41 <pheaver> ...
16:09:52 <aristid> kuffaar: it's a bit of a self selection i guess
16:10:02 <aristid> windows users use whatever they can use with visual studio
16:10:10 <finnomenon> I want to create a list with all 3-digit numbers which are divisible by 5 (with use of a generator). does this look good? http://hpaste.org/43135/divisible_by_5
16:10:11 <pastorn> hGetLine is behaving weirdly for me :(
16:10:16 <kuffaar> aristid: I use emacs
16:10:22 <kuffaar> So I guess the joke is on you :(
16:10:27 <aristid> kuffaar: cool, i use emacs too.
16:10:45 <Philonous> kuffaar: Than switch to Linux already
16:10:47 <pastorn> each line i grab begins with '\r', but i have set the NewlineMode to CRLF CRLF
16:10:56 <Philonous> Then*
16:11:06 <kuffaar> Philonous: I use Linux on the servers, my router and the notebook and in a VM on top of Windows all the time
16:11:17 <pheaver> finnomenon: sure, but you could also do this: [100, 105..199]  :)
16:11:39 <kuffaar> But I can't play new games or record music on Linux really
16:11:44 <ddarius> pheaver: That's hardly all three digit numbers.
16:12:01 <pheaver> yeah yeah yeah, typo, change 199 to 999, ok
16:12:35 <finnomenon> pheaver: next part of the exercise is to write a function which compares my version with the one you made
16:12:44 <pheaver> oh, heh
16:12:51 <tolkad> kuffaar: seriously though take a look at Parsec if you have the time. the parsers you write will be much more readable and it's much more powerful than regex, allowing you to parse recursive structures and such
16:12:57 <finnomenon> and returns true if they are
16:13:30 <Philonous> kuffaar: Uh, sorry, I was joking. Should have used a smiley or something.
16:13:52 <kuffaar> tolkad alright hm
16:15:00 <tolkad> kuffaar: what version of ghc do you have?
16:15:26 <kuffaar> tolkad: 7.1.2
16:15:28 <kuffaar> No wait
16:15:36 <kuffaar> 7.0.1
16:15:40 <kuffaar> I always mix them up haah
16:15:52 <kuffaar> E:\Code\Haskell\AfraidParser>cabal --version
16:15:53 <kuffaar> cabal-install version 0.9.5
16:15:53 <kuffaar> using version 1.10.0.0 of the Cabal library
16:16:27 <kuffaar> tolkad: Could cabal-install or Cabal even be the source of the segfault?
16:16:33 <kuffaar> Or are they all sandboxed?
16:16:42 <kuffaar> I have no idea if they use some low level stuff internally which could be causing this
16:18:24 <ezyang> I've been playing around with how to write Prolog programs in Haskell, and something I noticed is that for Prolog, a lot of the time you can right one definition and then it can flow both ways (given the result, give the argument; given the argument, give the result). Is there a way to do this in Haskell? 
16:18:53 <aristid> ezyang: lenses?
16:19:07 <ezyang> Aw, but I still have to manually define both directions :-) 
16:19:08 <copumpkin> ezyang: just use the type level
16:19:21 <aristid> copumpkin: haha
16:19:40 <ezyang> copumpkin: I don't parse :-) 
16:19:55 <Philonous> ezyang: Define some primitive lenses and implement composition, then you can build larger ones without worrying about the details
16:20:25 <copumpkin> ezyang: class Add a b c | a b -> c
16:20:31 <ddarius> ezyang: Simply implement unification.
16:20:33 <copumpkin> instance add Z a a
16:20:34 <ddarius> It's quite easy.
16:20:47 <ddarius> Similarly for backtracking.
16:20:54 <ezyang> copumpkin: Oh, fundeps. Hahaha. 
16:20:59 <elliottt> anyone here have some llvm experience?
16:21:07 <elliottt> o/ ezyang
16:21:10 <ddarius> I can attest to the fact that you can amke a pure Prolog interpreter in less than 100 lines of Haskell.
16:21:18 <ezyang> ddarius: Ah, but that's embedding a prolog interpreter in Haskell, which feels like cheating :-) 
16:21:25 <ezyang> elliottt: oh hey! 
16:22:07 <ezyang> I'd like something a little... more embedded, I guess. 
16:22:09 <ddarius> ezyang: What you want to do is exactly embedding Prolog into Haskell.
16:22:15 <ddarius> You don't need the front-end.
16:22:31 <ddarius> @google typed logic variables
16:22:32 <lambdabot> http://lambda-the-ultimate.org/node/1454
16:22:32 <lambdabot> Title: Typed Concurrent Programming with Logic Variables | Lambda the Ultimate
16:22:36 <ddarius> Curses
16:22:41 <ddarius> @google "typed logic variables"
16:22:43 <lambdabot> http://ircarchive.info/haskell/2007/3/28/111.html
16:22:43 <lambdabot> Title: haskell thedward: what's preventing a search and replace? one thing I can say ab ...
16:22:48 <djahandarie> lol
16:22:51 * ddarius sighs.
16:22:52 * BMeph suspects ddarius would enjoy Maude embedded into Haskell...
16:23:11 <ddarius> BMeph: I've thought about doing that, but it doesn't really do what I want.
16:23:18 <ddarius> I want things beyond term rewriting.
16:23:42 <ezyang> ddarius: What's the paper called? 
16:24:02 <ddarius> @google "Typed Logical Variables in Haskell"
16:24:03 <lambdabot> http://haskell.org/haskell-workshop/2000/papers/20.ps
16:24:11 <ezyang> aha 
16:24:12 <ddarius> Also the work on Wired adds some features beyond that.
16:25:02 <BMeph> Hmm, "typed logic variables" reminds me of Mercury for some reason... :)
16:26:06 <Mathnerd314> ddarius: what things beyond Maude, out of curiosity?
16:26:20 <ezyang> (fwiw, I ended up in this place because I have some HW problems that are asking me to evaluate some circuits in prolog, and I'm having difficulty seeing if logic programming gives me anything extra (which as far as I can tell, the answer is no.)) 
16:28:12 <ezyang> and then I started wondering, what does logic give me beyond nondeterministic choice. Unification is a good answer :-) 
16:34:04 <ddarius> Mathnerd314: Things like implication constraints (which Maude may be able to do well enough) and quantification.
16:34:24 <ddarius> ezyang: Again, you probably should look at Wired.
16:34:28 <ezyang> ddarius: Ok. 
16:34:57 <ezyang> http://www.cs.chalmers.se/~emax/documents/PhD_thesis.pdf :-( 
16:35:13 <ddarius> Also, most electrical circuits components are joined by relational constraints, not functional constraints.
16:35:39 <ezyang> that's true. 
16:35:59 <liyang> I'm a bit confused about exactly what I'm suppose to use for FFI… c2hs or hsc2hs?
16:37:24 <ezyang> But what's a little vexing is if I define relational constraints then I will return the right answer multiple times :-(. I guess I could use cuts to get around that. 
16:37:24 <ddarius> ezyang: In that vein, but going rather far afield, Jan Willems work in behavioral control theory is interesting.
16:37:25 <ddarius> You shouldn't be returning the same right answer multiple times.
16:37:25 <ezyang> ddarius: Man, I get so many interesting papers from you :-) 
16:41:19 <Mathnerd314> liyang: http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
16:48:14 <markus3> hi! Today I decided to try out happstack, but had an issue: it didn't install immediately, because haskell-src-exts needed >= happy-1.17, which cabal said, it didn't find... Then I installed happy directly and all wnt well. I'm on a gentoo box , and installing packages globally. Any ideas, why that happened, or how to find out what happened?
16:48:40 <gronka> .
16:49:52 <ivanm> markus3: install happy by hand first
16:49:59 <ivanm> but why not use the ebuilds?
16:50:15 <Saizan> markus3: it's just that cabal only installs library dependencies for you automatically, not build-tools
16:50:41 <djahandarie> What would you guys recommend for extremely minimal GUI stuff in Haskell? What I plan on doing is going to basically act like a terminal, but just with nice fonts, colors and such.
16:50:44 <ivanm> markus3: if you used the ebuilds, they would install happy for you!
16:50:54 <markus3> ok
16:51:26 <markus3> what do you mena by "cabal only installs library dependencies for you automatically, not build-tools"?
16:52:31 <markus3> oh, I think I get it
16:53:10 <markus3> something is a build-tool and not a dependency
16:53:21 <Saizan> happy is
16:55:00 <markus3> where in the sources would I have to look to see it?
16:55:15 <c_wraith> it's in the .cabal file, in the build-tools section
16:55:34 <c_wraith> maybe I should say <foo>.cabal
16:56:02 <markus3> ahah, but it somehow manifests in happstack sources too?
16:56:28 <ivanm> markus3: haskell-src-exts needs happy
16:56:35 <ivanm> and it appears that happstack needs haskell-src-exts
16:57:34 <markus3> ok, thanks for the answers :)
16:58:30 <redd_> Would a zipper comonad evaluating /paths/ on attributed trees fail, for some fundamental reason not related to implementation details, to satisfy the comonad laws? I can't think of a reason, but it would be good to know.
17:05:48 <kuffaar> Isn't there some guide to parsec for people who only know RE? Haha
17:05:52 <parcs> @type map . map
17:05:54 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
17:07:39 <kuffaar> Trying to figure out how to translate /a(.+?)b/ to parsec
17:10:00 <aristid> parcs: fmap . fmap is a generalisation of that :)
17:11:04 <ivanm> kuffaar: why not read a parsec tutorial or try playing with it?
17:11:10 * ivanm personally prefers polyparse anyway
17:11:13 <kuffaar> Yeah, I'm reading http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
17:11:17 <parcs> @type (.:) +1
17:11:19 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g, Num (f (g b))) => (a -> b) -> f (g a) -> f (g b)
17:11:22 <monochrom> kuffaar: http://hpaste.org/43137/tagsoup_gets_links
17:11:37 <parcs> @type (.:) (+1)
17:11:39 <lambdabot> forall a (f :: * -> *) (g :: * -> *). (Num a, Functor f, Functor g) => f (g a) -> f (g a)
17:12:28 <kuffaar> monochrom: Yeah I already have some TagSoup in this thing but it seems quite a lot of work still
17:12:30 <monochrom> it fetches a page and extracts all hyperlinks (<a ... href="extract this" ...>)
17:12:34 <kuffaar> Have to mess with indexes etc
17:12:37 <ivanm> kuffaar: RWH has a section on parsec
17:12:41 <monochrom> what indexes?
17:12:42 <ivanm> but I believe it's still only parsec-2
17:12:43 <kuffaar> Interesting
17:13:12 <ion> kuffaar: I haven’t tried Parsec yet, but thinking of the regexp as a([^b]+)b might help.
17:13:14 <kuffaar> monochrom: I need to parse tables and stuff and TagSoup doesn't really define a tree structure does it?
17:13:45 <kuffaar> So you only get offsets into the tag soup instead of accessing branches within the markup tree
17:13:46 <monochrom> no wonder. you need big guns like haxml or hxt
17:14:51 <monochrom> but it also means regex won't help either. I mean all regex does is to give you what tagsoup gives you.
17:16:18 <monochrom> I wonder what Text.HTML.TagSoup.Tree does. Looks tree-ish.
17:16:25 <ddarius> monochrom: I thought you let people figure this out on their own.
17:16:45 <kuffaar> <monochrom> but it also means regex won't help either. I mean all regex does is to give you what tagsoup gives you.
17:16:50 <kuffaar> Nah, it's fairly easy with RE
17:17:00 <kuffaar> I just go a(.+?)b(.+?)c and so on
17:17:03 <kuffaar> To extract all fields
17:17:14 <kuffaar> And I use the scan function in Ruby for that
17:17:26 <kuffaar> It's basically a 5 liner with the function definition
17:18:17 <monochrom> one single comment may foil your RE
17:19:04 <finnomenon> I have generated two lists and would like to compare them and return "true" if they are identical. I start with     twoListsIdentical :: Eq a => [a] -> [a] -> Bool     then how can I walk through to compare them item by item?
17:19:25 <ddarius> Silly monochrom.  You thought you were supposed to write the -correct- program?
17:19:46 <kuffaar> monochrom: What comment?
17:19:59 <monochrom> A comment whose content matches your RE
17:20:16 <ivanm> finnomenon: pattern match
17:20:39 <monochrom> If your RE is a(.+?)b(.+?)c, then my comment is <!-- axbxc -->
17:20:48 <redd_> I remember a paper on codata that used a "viewable machine states" analogy extensively for the first 5 pages or so. Does anyone know which paper this is?
17:20:54 <ivanm> twoListsIdentical [] [] = True; twoListsIdentical (a:as) (b:bs) | a == b = twoListsIdentical as bs; twoListsIdentical _ _ = False
17:20:57 <ion> <a href="axbxc">
17:21:15 <ezyang> redd_: I think I know what you're talking about. Just a sec. 
17:21:20 <redd_> Comparing lists for equality is just recursion over Nil and (;)
17:21:29 <finnomenon> thank you ivanm 
17:21:30 <kuffaar> monochrom: That would break my parsec code, too
17:21:39 <kuffaar> And it doesn't happen anyways, it's just for quick jobs
17:22:34 <monochrom> you can use regex in haskell too.
17:23:55 <monochrom> but I see how regex people solves problems by defining the problems away.
17:24:17 <kuffaar> I have so much RE in my Ruby code it's not funny anymore
17:24:31 <kuffaar> But whenever something changes it has to be updated anyways
17:24:37 <kuffaar> There's nothing you can really do about that in general
17:24:48 <kuffaar> You would need a strong AI to fully solve that
17:25:10 <ezyang> redd_: Can't find it. 
17:25:25 <ezyang> Total Functional Programming was what you reminded me of, but it doesn't discuss observability. 
17:25:30 <aristid> kuffaar: parsec simply is really convenient to use. more convenient than regexes, IMO
17:25:38 <kuffaar> Yeah I'm looking into it
17:26:15 <redd_> No problem; thanks for looking, though, ezyang. 
17:26:25 <kuffaar> So I use string "a" at first followed by...
17:26:37 <redd_> I'll look into Total Functional Programming
17:27:38 <kuffaar> I suppose the try function is similar to RE's {0,1} aka ? thing
17:28:03 <Saizan> no
17:28:09 <kuffaar> :(
17:28:43 <kuffaar> <|> looks like RE | to me
17:29:12 <monochrom> no one is talking about "when something changes"
17:29:28 <redd_> Total Functional Programming reminds me of the "Reasoning About Codata" paper on Applicative, which is pretty cool.
17:31:13 <ddarius> monochrom: The trick is if you write wrong programs to begin with, that doesn't change when the problem does.  Or if it does, it's only for the better!
17:31:29 <kuffaar> Oh, there's a between function
17:31:32 <kuffaar> That sounds good to me
17:32:58 <kuffaar> Ah, option is more like ?, I think
17:35:55 <gwern> writing wrong programs is fine if you cease to use them before the bugs start biting
17:36:18 <monochrom> that much is fine.
17:38:22 <redd_> The only /really/ bad part is when all of your program is correct except that "<" sign at line 500.
17:38:31 <tolkad> is there any way to make Data.Binary.Get lazy?
17:38:59 <kuffaar> Hahah that tutorial actually has an example which converts an EBNF grammar to Parsec code
17:39:06 <gwern> tolkad: sure, it's been done
17:39:13 <gwern> people've hacked it up
17:39:31 <gwern> but unfortunately the cage match battle royale for the 'lazy binary' title is still ongoing
17:40:25 <tolkad> gwern: so why didn't it get uploaded as package binary-lazy so I could just import Data.Binary.Get.Lazy?
17:40:35 <gwern> dunno. ethics maybe
17:40:46 <tolkad> ethics?!
17:41:42 <ezyang> edd_: Ah, that's a good find. Thanks! 
17:41:54 <gwern> tolkad: oh, we haskellers are all about ethics
17:42:10 <tolkad> gwern: how is it unethical to make data.binary.get lazy?
17:42:14 <gwern> haven't you ever noticed how we talk about 'the moral equivalent' or what's the moral thing to do?
17:42:42 <monochrom> yeah, the moral thing to do is to use an isomorphism
17:43:03 <monochrom> but I think moral and ethics are a bit different
17:43:35 <Philippa> "moral equivalent" isn't always an isomorphism
17:43:59 <Philippa> it's actually more useful as a cluster concept when it's a weirdish mapping in general
17:45:29 <gwern> tolkad: when I say hacked it up, I'm using hack in the negative sense
17:45:52 <gwern> djikstra would not like it
17:46:03 <lispy> gwern: like, hacking your neighbors up?
17:46:18 <lispy> Er, I guess that depends on your neighbors ;)
17:46:21 <gwern> lispy: yes, but with bits rather than blood
17:46:40 <tolkad> and whether they are using WEP
17:47:03 <gwern> tolkad: maybe you could look into one of the binary alternatives. cereal seems to be mentioned a lot
17:47:31 <lispy> The shortest phrase in the hacker's bible: Jesus WEP
17:48:13 <tolkad> gwern: it isn't even possible for cereal to be lazy because it uses Either instead of exceptions
17:48:42 <lispy> tolkad: cereal is definitely not lazy.  Do you need lazy or incremental?
17:49:07 <gwern> tolkad: ok, so one of the others
17:49:12 <tolkad> lispy: let's just say I don't want to put in a lot of effort
17:49:20 <ben> hah
17:50:02 <lispy> I thought binary is lazy, but I admit to having not used it myself.
17:50:26 <gwern> well, it says it uses lazy bytestrings
17:50:33 <tolkad> nope, I tried this: http://pastebin.com/G764DK9T
17:50:36 <tolkad> fails with stack overflow
17:51:54 <tolkad> maybe BS.pack isn't lazy though...
17:52:50 <tolkad> no it's lazy
17:55:36 <gwern> you usually see stack overflow more with excess laziness than strctness, no?
17:56:55 <tolkad> it had a stack overflow before any output
17:57:17 <tolkad> if it was lazy it would have produced output on its way to the stack overflow
17:57:36 <believa> Is it possible to have nested use of the arrow syntax? E.g. a 'proc-do' within a 'proc-do'.
17:57:52 <tolkad> anyway I checked the source. it uses unpacked tuples with no lazy pattern matching
17:59:24 <Philonous> believa: Yes
18:00:21 <believa> Philonous: Ok. Could you point me to an example showing the syntax in use? Not sure how the nested proc would look.
18:01:18 <tolkad> I guess I should use Parsec to parse binary data instead of binary
18:01:43 <Philonous> believa: Let me see if I used it somewhere
18:02:04 <believa> Philonous: Thanks.
18:03:34 <Philonous> believa: But basically you can have (proc x -> somearrowstuff) anywhere you can have an arrow value. (Arrow do notation is orthogonal to proc). It's just like an anonymous function
18:07:11 <Philonous> believa: http://hpaste.org/43138/nested_proc
18:08:49 <believa> Philonous: Ok. Makes sense. Thanks!
18:09:11 <Philonous> Hope it helped
18:17:09 <vienneau> hi, first-day haskell user here. I'm having trouble calling "yesod" from the bash prompt (must not be in $PATH). I'm on Ubuntu 10.10, using the haskell-platform apt package. I did `cabal update` and `cabal install yesod`, which exited normally.
18:17:37 <aristid> vienneau: add $HOME/.cabal/bin to your PATH.
18:17:37 <kuffaar> vienneau: Huh? It's a library, isn't it?
18:17:50 <kuffaar> Oh, right, cabal isn't installed there by default
18:17:56 <vienneau> aristid: thanks, I'll try that
18:18:05 <kuffaar> I'm too used to it being in my .cabal because I built it myself
18:18:28 <Bynbo7> vienneau: you're a first time haskell user and you're starting with yesod? this is probably a bad idea
18:18:44 <kuffaar> Bynbo7 why?
18:18:47 <vienneau> Bynbo7: I do realize that, I really do. But I'm curious :)
18:18:49 <Bynbo7> you'll almost certainly want to learn Haskell first
18:18:56 <kuffaar> Bynbo7 it was the first thing I tried when I started with Haskell I think
18:19:07 <kuffaar> Well, you got to start with something, might aswell pick that
18:19:08 <Bynbo7> vienneau: fair enough, just don't expect to be able to write anything that works :)
18:19:23 <vienneau> Bynbo7: I've been working my way through Real World Haskell today. I thought I'd try and install some libraries and poke around with web frameworks.
18:19:38 <kuffaar> I took a look at Snap, Happstack, Yesod
18:19:46 <kuffaar> In the end I decided to write my own framework though
18:20:01 <kuffaar> Hah, it's the famous ManateeLazyCat
18:20:29 <ManateeLazyCat> kuffaar: Hi all. :)
18:20:47 <kuffaar> ManateeLazyCat: 您是否对您的疯狂计划的进展？ ~-~
18:21:05 <vienneau> btw, thanks for the help aristid, kuffaar, and Bynbo7
18:21:09 <kuffaar> Bynbo7: Snap is generally the one with the most features, by the way
18:21:18 <ManateeLazyCat> kuffaar: I'm busy on my wedding recently. ;p
18:21:19 <kuffaar> A lot of code and a helpful IRC channel
18:21:24 <kuffaar> ManateeLazyCat I see
18:21:31 <Bynbo7> kuffaar: i'm well aware of that, we're using it at work ;)
18:21:37 <kuffaar> Woops
18:21:38 <ManateeLazyCat> kuffaar: I will hard work after wedding. :)
18:21:42 <kuffaar> That was dierected at vienneau, sorry
18:21:48 <ManateeLazyCat> kuffaar: Use Google Translate?
18:22:00 <kuffaar> ManateeLazyCat: Yeah, my knowledge of Mandarin is rather limited
18:22:06 <Bynbo7> which i should be at at the moment. managed to sleep through my three alarms and only just woke up. I hate being sick :(
18:22:12 <kuffaar> I can read only like 8-12 symbols
18:22:17 <ManateeLazyCat> kuffaar: 很高兴认识你。 :)
18:22:27 <monochrom> perhaps the wedding is the real crazy plan
18:22:52 <ManateeLazyCat> monochrom: I have with my GF 4 years, so i want give her a result. :)
18:23:04 <kuffaar> Now out of those I could only read the 你 part
18:23:21 <monochrom> "glad to meet you"
18:23:38 <kuffaar> So Google Translate suggested
18:23:43 <ManateeLazyCat> monochrom: We're in Chinese's christmas: Chun Jie. :)
18:23:44 <kuffaar> monochrom do you speak Mandarin?
18:23:49 <ManateeLazyCat> kuffaar: No
18:24:10 <ManateeLazyCat> kuffaar: monochrom use Google Translate too. :)
18:24:16 <kuffaar> :p
18:24:39 <ManateeLazyCat> kuffaar: I'm looking for some crazy people help me. :)
18:24:55 <monochrom> I use monochrom parser combinators
18:25:12 <kuffaar> I am considering writing an IRC client in Haskell, with Qt
18:25:20 <kuffaar> Maybe it would even attract a small user base, who knows
18:25:30 <ManateeLazyCat> @package manatee-ircclient 
18:25:31 <lambdabot> http://hackage.haskell.org/package/manatee-ircclient
18:25:38 <gwern> hahah
18:25:39 <kuffaar> Yeah, I saw the video
18:25:46 <ManateeLazyCat> kuffaar: ^^^^ Base on gtk2hs and fastirc
18:25:49 <kuffaar> Most of my life takes place on IRC, might aswell put more time into that
18:26:16 <lispy> ah, IRC
18:26:20 <gwern> ah, NIH
18:26:26 <kuffaar> ManateeLazyCat: IRC is pretty unknown in the PRC, right? Most people just use QQ and forums?
18:26:48 <ManateeLazyCat> kuffaar: Yeap, 99.9999% Chinese people use QQ
18:26:50 <monochrom> ah, made in China
18:26:55 <Philonous> ManateeLazyCat: Btw. are you going to implement the java script core bindings to webkit?
18:26:59 <ManateeLazyCat> kuffaar: Most of Chinese even haven't heard IRC.
18:27:04 <kuffaar> Yeah, I figured
18:27:15 <kuffaar> IRC is largely restricted to Europe and North America, also some South Americans
18:27:30 <ManateeLazyCat> Philonous: Yeap, i will, but that will be finish after IDE.
18:27:36 <kuffaar> You find people from odd places now and then but empirically it's pretty much that
18:27:53 <ion> manateelazycat: Does the great firewall affect IRC?
18:27:57 <kuffaar> east Asia is really underrepresented on IRC
18:28:01 <ManateeLazyCat> ion: No.
18:28:15 <ManateeLazyCat> ion: GFW just care most people
18:28:38 <ManateeLazyCat> ion: Just geek use IRC in China.
18:28:40 <kuffaar> 天安门大屠杀！推翻政府！色情问题大家好！
18:28:44 <ion> alright
18:28:44 <kuffaar> Heh yeah
18:28:52 <aristid> kuffaar: maybe it's also the low timezone overlap?
18:28:54 <ManateeLazyCat> ion: Even most of programmer don't know IRC.
18:29:21 <kuffaar> aristid: No :o that's not much of an issue
18:29:34 <dankna> well, IRC is a legacy protocol
18:29:34 <aristid> kuffaar: why are no japanese on irc, then?
18:29:36 <dankna> imo
18:29:53 <kuffaar> aristid: There are some, but it's rare, the internet is just really really segregated
18:30:05 <aristid> dankna: XMPP MUC is incredibly unpopular.
18:30:05 <kuffaar> East Asia pretty much lives in a world on its own online
18:30:09 <ManateeLazyCat> kuffaar: Yeap, GFW filter those, but i don't think that's right way focus those, because they're has pass, in the history....
18:30:12 <kuffaar> I've used XMPP channels ;D
18:30:31 <dankna> aristid: yeah, but protocol-wise it's really solid.  it just lacks a front-end with the (wince, shudder) good design of mIRC
18:31:04 <ManateeLazyCat> Philonous: Now, manatee-browser just have sandbox and multi-tab features, about JavaScript framework still haven't finish.
18:31:06 <dankna> correcting this state of affairs is back-burner project number ten or so
18:31:32 <dankna> where by back burner I mean so far from the front of the stove that it's actually in the deep freeze, but hey
18:31:46 <kuffaar> aristid: I mean the time difference between central Europe and the west coast of the US is 9 hours already, 12 hours being the maximum
18:31:50 <kuffaar> And it's not an issue
18:31:59 <kuffaar> I still talk to people from the west coast all the time
18:32:08 <ManateeLazyCat> @time
18:32:09 <kuffaar> Plus my sleeping pattern is totally random anyways
18:32:10 <lambdabot> Local time for ManateeLazyCat is Wed Jan 19 10:37:32 2011
18:32:27 <kuffaar> That's UTC + 8?
18:32:35 <kuffaar> I'm in UTC + 1
18:32:52 <ManateeLazyCat> kuffaar: Yeap, i'm at China (UTC +8)
18:33:34 <Philonous> ManateeLazyCat: Looking forward to it. I would like to manipulate the DOM-tree, and I haven't found a way other than injecting JS yet
18:35:01 <ManateeLazyCat> Philonous: Great, if you have any problem about binding, we can discuss at gtk2hs mailing-list.
18:35:42 <ManateeLazyCat> Philonous: gtk2hs mailing-list have Axel, he know many binding details. :)
18:36:23 <Philonous> Philonous: I'll subscribe tomorrow. I seriously need to go to bed now
18:36:43 <ManateeLazyCat> Philonous: Good dream. :)
18:36:57 <Philonous> Thanks. 
18:43:28 <tolkad> I wonder how much programming resources can be accessed in China
18:44:14 <brweber2> how do I make a data class a derivable class?
18:44:28 <tolkad> brweber2: in standard haskell you can't
18:44:49 <tolkad> brweber2: in ghc haskell you can't without the use of template-haskell
18:44:57 <brweber2> tolkad ok, so I have to create an instance?
18:45:37 <ManateeLazyCat> tolkad: I read haskeller's papers, most in English.
18:46:28 <brweber2> tolkad thanks, I'll have to figure out another way (I'd rather stay with standard haskell for now)
18:46:36 <kuffaar> What parsec function do I use to do extract the X from "blah>X"?
18:47:06 <kuffaar> Do you actually use between for that?
18:47:51 <monochrom> I don't. string "blah>" >> anyChar
18:48:19 <kuffaar> monochrom: I forgot to mention, blah is not a static string
18:48:22 <kuffaar> It's random
18:48:30 <tolkad> kuffaar: what characters can be in it?
18:48:35 <kuffaar> So basically .+?>(.+)
18:48:39 <kuffaar> In RE
18:48:41 <tolkad> kuffaar: ah
18:49:19 <monochrom> many (noneOf ">") >> char '>' >> anyChar
18:49:26 <brweber2> tolkad is there a way to not derive, but to be more explicit ... about my data type being of a particular class? (not sure I've worded that correctly?)
18:49:52 <tolkad> brweber2: one data type can have many instances
18:49:56 <monochrom> write your own instances.
18:49:59 <kuffaar> monochrom ah hmm
18:50:07 <kuffaar> Funny, that's more like CS RE.
18:50:41 <tolkad> brweber2: instance Eq Bool where { True == True = True; False == False = True; _ == _ = False }
18:50:49 <brweber2> monochrom ok, that's basically what I was trying to ask if I had to do that, thanks
18:50:58 <monochrom> instance Eq YourDataType where x==y = True
18:51:18 <brweber2> tolkad ok, thanks
18:52:28 <tolkad> brweber2: if your data type doesn't have any parameters it's pretty straightforward, just write the « instance YourDataType where » header and put the function definitions in the instance body
18:53:25 <ManateeLazyCat> I need off to busy on wedding, bye all. :)
18:53:40 <kuffaar> monochrom: Shouldn't that be many anyChar?
18:53:54 <monochrom> will slurp everything
18:53:59 <kuffaar> That's the idea
18:54:05 <kuffaar> (.+)
18:54:30 <kuffaar> Hah, he still uses ERC
18:54:32 <monochrom> then delete (>> char '>' >> anyChar) because that's dead code
18:54:35 <kuffaar> Instead of his own client
18:54:44 <kuffaar> monochrom: Huh? :o
18:54:49 <monochrom> Huh?
18:54:57 <kuffaar> <kuffaar> So basically .+?>(.+)
18:55:22 <monochrom> that's many (noneOf ">") >> char '>' >> anyChar
18:55:33 <kuffaar> But anyChar is only one
18:55:41 <kuffaar> That sounds like .+?>(.) to me
18:56:03 <tolkad> brweber2: if your data type has parameters you need to write an instance for each fully applied type, or a single more general instance (but not both). for example: « instance Eq a => [a] where { [] == [] = True; (x:xs) == (y:ys) = (x == y) && (xs == ys); _ == _ = False} » OR « instance [Bool] where { [] == [] = True; (x:xs) == (y:ys) = (x == y) && (xs == ys); _ == _ = False} »
18:56:29 <tolkad> brweber2: if you do both, the instances will be overlapping, and you will get an error message
18:56:29 <monochrom> thought you meant to change (many (noneOf ">")) to (many anyChar)
18:56:44 <monochrom> many (noneOf ">") >> char '>' >> many anyChar
18:57:01 <kuffaar> Right
18:57:12 <brweber2> tolkad perfect, I do have type parameters
18:57:29 <monochrom> but I doubt that you really have nothing more to parse after it
18:57:30 <brweber2> tolkad I'm obviously still very, very much a haskell noob, thanks for the help
18:59:21 <klapaucjusz> Does Haskell have strictness annotations?
18:59:27 <monochrom> yes
18:59:31 <klapaucjusz> The wiki only mentions seq and $!
18:59:41 <klapaucjusz> monochrom: what's the syntax?
18:59:57 <kuffaar> monochrom: Oh yeah, I misunderstood how between worked but I just read the code
18:59:59 <Axman6> foo !x = ...
18:59:59 <monochrom> there is also one in data type definitions. "data Hello = Ctor !Int"
19:00:06 <kuffaar> do{ open; x <- p; close; return x }
19:00:14 <kuffaar> Wow, he really hates newlines
19:00:25 <brweber2> tolkad in your example, I have two questions... why do you have => [a] before the where
19:00:35 <kuffaar> I thought p would operate in an environment which doesn't see the rest of the code
19:00:42 <kuffaar> Of the input*
19:00:44 <klapaucjusz> monochrom: I'm speaking of function arguments.
19:00:46 <brweber2> tolkad and the second pattern where you compare x and y, what is the second part of that statement?
19:00:56 <tolkad> brweber2: it's an instance for [a], where a is any type which has an Eq instance
19:00:56 <klapaucjusz> I was expecting to be able to say
19:01:04 <klapaucjusz>   foo :: !Int -> Int
19:01:06 <monochrom> then you seq or use pattern matching
19:01:09 <klapaucjusz> but apparently ghc doesn't grok that.
19:01:12 <djahandarie> open >> p >>= (\x -> close >> return x)
19:01:20 <monochrom> no strictness annotation in types
19:01:22 <klapaucjusz> monochrom: ok.
19:01:35 <klapaucjusz> Strange.  I was pretty sure I had used them.
19:02:03 <tolkad> brweber2: you can add constraints to a type signature specifying which classes a type must have an instance for with the format « (T1 a, T2 a, …) => a »
19:02:19 <monochrom> do{ open; x <- p; close; return x }  does not need any newlines. too short for newlines.
19:02:50 <monochrom> see also http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
19:02:58 <djahandarie> @undo do{ open; x <- p; close; return x }
19:02:58 <kuffaar> It's more typing with { } ;
19:02:59 <lambdabot> open >> p >>= \ x -> close >> return x
19:03:08 <tolkad> brweber2: « (x == y) && (xs == ys) »? this is True if x equals y AND xs equals ys
19:03:25 <tolkad> brweber2: it's a recursive function call
19:03:28 <djahandarie> kuffaar, you technically don't need the {} I think
19:03:40 <ivanm> djahandarie: for @undo you do
19:03:50 <ivanm> to group the statements in the do block
19:03:53 <tolkad> brweber2: did that answer your question?
19:03:54 <djahandarie> I mean just for Haskell. :P
19:03:58 <brweber2> tolkad ahhh, it is just recursion... I missed that somehow
19:04:01 <monochrom> a small amount more typing is ok if the effect is to convey the message that the code is supposed to be trivial
19:04:33 <ion> @. pl undo do open; x <- p; close; return x
19:04:33 <lambdabot> open >> p >>= (close >>) . return
19:04:42 <monochrom> methinks mainstream programmers glorify their trivial work by splitting lines to the point each line has only 3 words or something. see also http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
19:04:45 * Axman6 wonders why between isn't written open *> p <* close
19:05:06 <kuffaar> :t (*>)
19:05:07 <monochrom> because it was written a decade before *> and <*
19:05:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
19:08:19 <tolkad> brweber2: without the (Eq a) constraint, we couldn't call « x == y » because we wouldn't know if there was an Eq instance for a
19:09:40 <brweber2> tolkad is there a way to find out about a typeclass in ghci?
19:09:50 <monochrom> :info Eq
19:10:09 <brweber2> monochrom thanks, I had tried :t and :k with no luck obivously
19:12:47 <QinGW> :t
19:15:28 <brweber2> tolkad monochrom I got it working!  Final thanks for the night :)
19:15:39 <monochrom> you're welcome
19:16:03 <tolkad> yup : )
19:20:54 <ddarius> Day 1 straight razor shaving: nicht so gut.
19:21:11 <Axman6> do you still have a chin?
19:21:33 <kuffaar> In the past I just used a regular rough buzz cutter to do my scalp and the face
19:21:38 <kuffaar> Once a month or so
19:23:18 <dolio> You buy a razor new? Or get one used?
19:23:54 <ddarius> dolio: A new one through a sharpening service.
19:23:55 * copumpkin hopes ddarius isn't gurgling blood on the floor next to his computer, after typing nicht so gut into IRC instead of calling 911
19:26:52 <djahandarie> What in the world is the point of using a straight razor
19:26:59 <ddarius> Last time I called 911, I hung up on the first ring.  They called back: "Did you just call 911?" "Yeah, I just had a motorcycle accident, but I think I can get to the hospital myself." "Alright." "Thanks." *hangs up*
19:27:21 <dolio> Ultimately, you can save money.
19:27:33 <dolio> Although new razors are kind of pricey, last I looked.
19:27:35 <ddarius> All I had was a fracture radius, detached ligament in my wrist, and a gaping hole on my knee.
19:27:38 <Axman6> you can get a better shave too
19:27:47 <dolio> Yeah, that too.
19:28:00 <Axman6> ddarius: have you seen those videos on youtube about how to wetshave properly?
19:28:02 <dolio> Plus, it's cool.
19:28:21 <ddarius> dolio: They are.  It would take a few years to recoup the cost of just the razor v. the Mach 3, say, depending on how quickly you go through blades.
19:28:23 <Axman6> and hardcore
19:28:27 <lispy> ddarius: I have mixed feelings about how paramedics are trained to respond to a person saying they are fine after an accident.  Many times people say when it's not true.
19:28:27 <Axman6> chicks dig scars
19:28:45 <ddarius> lispy: How do you believe they are trained?
19:29:08 <djahandarie> With hope
19:29:08 <lispy> ddarius: There is some law or some bit of their training that says they can't force help on you.
19:29:13 * ddarius has a huge scar on his forearm and a metal plate in it.
19:29:24 <lispy> and that sometimes get interpreted as "if they say no, leave them alone."
19:30:16 <ddarius> lispy: I don't think that would happen that often; a paramedic walking away after someone who didn't seem fine said they were.
19:30:31 <ddarius> lispy: I'll find out soon enough what they are or aren't trained to do though.
19:30:41 <Axman6> lispy: consent is a very important issue in medical treatment.
19:31:01 * monochrom is interested how ddarius will find out
19:31:02 <lispy> Axman6: exactly
19:31:03 <Axman6> luckily, if you fall unconcious, there's implied concent, even if they have explicitly said they do not want treatment
19:31:29 <Axman6> at least in australia
19:31:36 <Axman6> pretty sure in the US as well
19:31:42 <ddarius> monochrom: I'm interested in going through, at least the beginning phases of, EMT training.
19:31:48 <lispy> OT, but do you guys know the different between using the bzImage you get from 'make' in the kernel tree vs. the image you get in /boot when you do a 'make install' ?
19:31:54 <Axman6> our first aid training is pretty explicit about what's legal and what's not
19:32:04 <monochrom> oh, I see, not by experimenting injuries on yourself
19:32:31 <lispy> I guess it's whatever install.sh does
19:32:52 <ddarius> monochrom: No.  I don't like that "bone breaking" kind of pain.  Also, the shots they give you for pain killer is the worst feeling thing.
19:33:54 <ddarius> Axman6: The, very basic, first aid they train you to provide in the US military, doesn't cover such legal issues at all.
19:36:15 <klapaucjusz> What's a good place to learn about GADTs?
19:36:24 <monochrom> the ghc user guide
19:36:35 <lispy> klapaucjusz: the haskell.org wiki has a few articles
19:36:48 <lispy> klapaucjusz: what is your background?  Do you already understand existential types?
19:36:56 <Axman6> ddarius: i have a feeling there are much less legal issues in war :P
19:37:30 * ddarius would suggest some of the newer papers behind GADTs.
19:37:56 <lispy> Not trying to nit pick grammar (I really just want to get better at it myself), should that be "much fewer legal issues" or "far fewer legal issues" ?
19:38:20 <klapaucjusz> lispy: yes.
19:38:49 <klapaucjusz> lispy: I'm looking at the wiki right now.  Pottier-Régis-Gianas looks promising.
19:39:03 <lispy> klapaucjusz: ah, then the only that you're likely to encounter that is truly new about them is the type refinement in the constructors
19:39:57 <lispy> klapaucjusz: data Foo a {- the only thing we care about 'a' here is the kind } where FooInt :: Int
19:40:23 <lispy> oops
19:40:31 <monochrom> wait, FooInt :: Int -> Foo Int
19:40:32 <lispy> data Foo a where FooInt :: Foo Int
19:41:00 <lispy> klapaucjusz: The point being is that, when you pattern match on FooInt you find out that 'a' is Int
19:41:30 <klapaucjusz> Oh, you're Jason.
19:41:32 <klapaucjusz> Hi.
19:41:41 <lispy> klapaucjusz: data Foo a where FooB :: b -> Foo b, this is equivalent to data Foo a where FooB :: a -> Foo a
19:41:49 <lispy> Yes, I'm Jason :)
19:42:01 <ddarius> In GHC's current implementation, which I think is pretty elegant, the main thing that GADTs do that other type constructs didn't before is locally provide constraints.  Admittedly, to make that the "only" thing GADTs do, they had to add equality constraints.
19:42:14 <ddarius> Which were added pretty much at the same time as GADTs.
19:43:14 <lispy> I think the GADT syntax is really elegant too
19:43:18 <klapaucjusz> So is Pottier-Régis-Gianas a good read, or do you recommend something else?
19:43:34 <lispy> Do you have a link, it's not familiar to me just from the title
19:43:53 <ddarius> @where spj
19:43:53 <lambdabot> I know nothing about spj.
19:43:53 <klapaucjusz> Stratified type inference for generalized algebraic data types
19:43:57 <ddarius> What!
19:44:05 <ddarius> @where simonpj
19:44:05 <lambdabot> I know nothing about simonpj.
19:44:18 <djahandarie> @where simon peyton-jones
19:44:18 <klapaucjusz> http://cristal.inria.fr/~fpottier/publis/pottier-regis-gianas-05.pdf
19:44:19 <lambdabot> I know nothing about simon.
19:44:21 <Axman6> YOU MUST KNOW YOU MASTER!
19:44:31 <Axman6> YOUR TOO*
19:44:40 <djahandarie> The misspelling made it better
19:44:48 <Axman6> heh, indeed
19:45:10 <lispy> klapaucjusz: if I read that paper, it must not have been memorable for me :)
19:46:42 <lispy> klapaucjusz: Appendix B gives some examples: http://files.codersbase.com/thesis.pdf  If you want a good theoretical introduction look at the SPJ paper that ddarius recommended.
19:46:59 <lispy> klapaucjusz: I have a single spaced version of that thesis.pdf if you would prefer it
19:48:53 <lispy> klapaucjusz: at this url: http://files.codersbase.com/typewitnesses-singespace.pdf  :)
19:49:18 <klapaucjusz> I'm actually looking at programming examples more than the theory.
19:50:06 <Saizan> maybe "Fun with type functions" then, but that uses type families too
19:50:35 <dolio> Why Dependent Types Matter. :)
19:51:21 <Saizan> even better :)
19:51:33 <lispy> klapaucjusz: the sort of canonical motivating examples are typically AST based
19:51:48 <klapaucjusz> Heh.  Thesis is cool.
19:53:13 <believa> In http://hpaste.org/43140/effect_of_failing_arrow - "mid" is a non-empty list but "midX" is (for illustrative purposes) empty. Why does runX then return an empty list? Does the arrow syntax do some kind of zipWith behind the scenes?
19:57:49 <Saizan> believa: are you familiar with the list monad?
19:58:02 <aristid> :t let (a >~> b) m = a >>= \v -> m >> b v in (>~>)
19:58:04 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => m a -> (a -> m b) -> m a1 -> m b
19:58:09 <believa> Saizan: Mostly ...
19:58:26 <aristid> :t let (a >~> b) m v = a v >>= \w -> m >> b w in (>~>)
19:58:27 <lambdabot> forall t (m :: * -> *) a b a1. (Monad m) => (t -> m a) -> (a -> m b) -> m a1 -> t -> m b
19:58:50 <aristid> @hoogle (t -> m a) -> (a -> m b) -> m a1 -> t -> m b
19:58:51 <lambdabot> No results found
19:58:57 <aristid> hah.
19:59:16 <Saizan> believa: in the list monad if you have e.g. "do x <- a; y <- b; return (x,y);" and b is an empty list, the whole expression is an empty list too
19:59:49 <Saizan> believa: HXT arrows are a fancier version of that
20:00:07 <ivanm> Saizan: HXT uses non-standard arrows?
20:00:26 <Saizan> ivanm: no
20:01:35 <believa> Saizan: Ok. What if the lengths were of different lengths?
20:02:00 <believa> Saizan: ... *lists* were of different *lengths*?
20:02:20 <Saizan> believa: it's not zipping them
20:02:36 * hackagebot accentuateus 0.9.1 - A Haskell implementation of the Accentuate.us API.  http://hackage.haskell.org/package/accentuateus-0.9.1 (MichaelSchade)
20:02:39 <Saizan> > do x <- [1,2]; y <- [1,2,3]; return (x,y)
20:02:40 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
20:03:30 <believa> Saizan: I see - all possible combinations. If one is empty, then there are no combinations.
20:03:46 <Axman6> > [[x,y] | x <- "abc"; y <- "xyz"]
20:03:47 <lambdabot>   <no location info>: parse error on input `;'
20:03:53 <Axman6> > [[x,y] | x <- "abc", y <- "xyz"]
20:03:53 * BMeph believes that believa has "got it"!
20:03:54 <lambdabot>   ["ax","ay","az","bx","by","bz","cx","cy","cz"]
20:03:56 <magicman> :t \x y -> left x ||| right y
20:03:57 <lambdabot> forall (a :: * -> * -> *) b c d b1. (ArrowChoice a) => a b c -> a b1 d -> a (Either (Either b d) (Either c b1)) (Either c d)
20:04:03 <ion> In the list monad >>= is akin to “for each”.
20:04:07 <magicman> Awesome :D
20:04:53 <BMeph> ion: Or as we call it, "concatMap". ;)
20:05:03 <ion> :-)
20:05:07 <believa> Saizan: Thanks.
20:05:21 <Saizan> believa: np :)
20:05:35 <klapaucjusz> lispy: I got it ;-)
20:06:05 <lispy> klapaucjusz: great (btw, once I /whois'd you, I figured you appreciate the darcs topic ;)
20:06:30 <aristid> :t let (a >~> b) m = \v -> a v >>= \w -> m >> b w in (>~>)
20:06:32 <lambdabot> forall t (m :: * -> *) a b a1. (Monad m) => (t -> m a) -> (a -> m b) -> m a1 -> t -> m b
20:08:02 <aristid> :t let (a >~> b) m = a >=> m >=> b in (>~>)
20:08:03 <lambdabot> forall a (m :: * -> *) b b1 c. (Monad m) => (a -> m b) -> (b1 -> m c) -> (b -> m b1) -> a -> m c
20:12:06 <finnomenon> http://pastebin.com/jn0uyXp8 can somebody see where the (unexpected `;', possibly due to bad layout)   is coming from?
20:12:46 <Saizan> you've to indent the |s
20:16:06 <joe6> *Main> main
20:16:06 <joe6> *** Exception: parse error
20:16:21 <joe6> is there a simple way to find out where that parse error is happening?
20:16:53 <Axman6> not without knowing anything at all about your program...
20:17:07 <Saizan> you could use the ghci debugger
20:17:25 <joe6> Saizan: cool, that was what I was looking for.
20:17:40 <Saizan> or maybe just grep for uses of read?:)
20:17:51 <Saizan> > read ".." :: Int
20:17:52 <lambdabot>   *Exception: Prelude.read: no parse
20:17:56 <Saizan> ah, no.
20:18:15 <joe6> I am using read in more than a few places. 
20:18:29 <Saizan> joe6: iirc, you've to :set -fbreak-on-exception and run :trace main, but check GHC's manual
20:18:49 <joe6> thanks, is there a way to tell the ghci to tell where (which line) the error is happening.
20:19:05 <joe6> Saizan: will check out your suggestin.
20:20:39 <joe6> Saizan: it just says " Stopped at <exception thrown>" does not show the line number or anything. w
20:20:47 <joe6> will check out the debugger documentation.
20:24:06 <Saizan> yeah, there's some command to look at the trace
20:24:40 <joe6> ok, thanks.
20:27:35 <sa> hi
21:01:14 <colah> Is it possible to create something of the form * -> a -> *? 
21:01:42 <colah> Eg. n times Cartesian product would be * -> a -> *
21:03:11 <Axman6> eh?
21:03:35 <Axman6> can you give an example of what you mean? i assume the notation you're using there isn't the kinda notation
21:03:38 <Axman6> :k (+)
21:03:39 <lambdabot> Not in scope: type variable `+'
21:03:48 <Axman6> :k (->)
21:03:50 <lambdabot> ?? -> ? -> *
21:03:55 <colah> No , I mean kinds.
21:04:06 <colah> I mean something that intertwines kinds and types
21:05:22 <joe6> i am reading file contents using readFile. it has a lot of rows and I am using the read contents in a zipWith a smaller list. Will all the big files contens be read? or does it read the contents lazily only to the extent required?
21:05:58 <joe6> s/contens/contents/
21:06:06 <Philippa> nope, we don't have dependent kinds any more than we have dependent types
21:06:06 <Axman6> i should read them lazily, but you may be doing something that causes the whole file to be read
21:06:28 <joe6> ok, thanks.
21:07:40 <colah> Well, at least I know what it's called now. Thanks.
21:09:54 <dobblego> is there not a randomPick :: [a] -> IO a ?
21:18:44 <lpsmith> Out of curiousity,  is there a GHC extension that allows me to use type synonyms like this? http://hpaste.org/43141   
21:20:42 <mtnviewmark> hmmm... what do you get when you compile that?
21:21:32 <lpsmith> records.hs:9:0:
21:21:32 <lpsmith>     Type synonym `Fst' should have 2 arguments, but has been given 0
21:21:32 <lpsmith>     In the type signature for `mkRecordFst':
21:21:32 <lpsmith>       mkRecordFst :: String -> String -> Record Fst
21:21:42 <lpsmith> Although,  I just found LiberalTypeSynonyms
21:22:48 <lpsmith> Yeah,  liberalTypeSynonyms doesn't do that,  and somehow I'm not entirely surprised
21:22:59 <lpsmith> mtnviewmark, ^
21:24:09 <mtnviewmark> hmmm.... if you use      data Fst a b = Fst a    and   data Snd a b = Snd b     does it work?
21:24:26 <lpsmith> well,  basically yes
21:24:27 <mtnviewmark> (modulo the additional constructors, which I assume you don't want in your record)
21:24:32 <lpsmith> exactly
21:25:12 <lpsmith> well,  I don't care if they are in my record that much... but they are kind of a pain
21:25:15 <mtnviewmark> I think the type synonym machinery just isn't going to be powerful enough... there's sort of no "thing" for it to hand the properiies of Fst/Snd onto
21:25:59 <lpsmith> My intuition vaguely agrees with the sentiment,  though I wish I was more comfortable with type theory to have a good explanation
21:26:58 <Cale> Yeah, arbitrary type functions are kinda tricky.
21:27:49 <lpsmith> Cale,  I'm not asking for arbitrary type functions,  just const and flip const :)
21:28:25 <lpsmith> but yes
21:29:57 <Cale> It appears that type families are subject to the same restrictions even.
21:31:52 <ddarius> lpsmith: const would cause problems.
21:33:17 <lpsmith> ddarius, why?
21:50:11 <Axman6> I don't suppose anyone's worked with takusen before have they? :(
21:50:56 <lpsmith> I've played with it
21:51:14 <lpsmith> But I decided it was a little too esoteric for my current tastes
21:51:41 <lpsmith> (And not sure it could even be used in my current use case,  e.g. connection caching)
21:52:23 <Axman6> it was decided that we'd use it. i'm starting to regret this decision
21:53:05 <Axman6> it also doesn't help that half the docs are missing on hackage
21:53:46 <Axman6> i'm fairly confident i know how to retrive things from the database, but inserting them is another thing
21:53:56 <lpsmith> heh
21:54:14 <lpsmith> Is there a good way of unpacking SQL results into records?
21:54:48 <lpsmith> I managed to both insert and retrieve things using Takusen
21:55:13 <Axman6> the way i'd like to have out database strtuctured, there'll be a lot of joining
21:55:35 <Axman6> and i currently have no idea how to do that nicely.
21:55:41 <Axman6> maybe i should read more docs >_>
21:55:50 <ivanm> Axman6: what a ridiculous idea!
21:59:06 <Axman6> urgh, the docs are pretty pathetic
21:59:14 <Axman6> sqlbind "select ?, ... where col = ? and ..." [bindP ..., bindP ...]
21:59:24 <Axman6> without explaining what those things mean >_<
22:00:12 <Axman6> wtf is a DML command >_<
22:00:58 <ivanm> Data Manipulation Language ?
22:01:08 <Axman6> and DDL?
22:01:21 <ivanm> Data Definition Language IIRC
22:01:29 <ivanm> yup, that's it
22:01:31 <Axman6> sounds good to me
22:01:38 <ivanm> Axman6: I take it you didn't do much SQL @ ANU?
22:02:08 <ivanm> the former is for rows in tables; the latter is for creating/manipulating tables
22:02:17 <Axman6> i've done one course on it, got an HD too, but i've never heard either of those mentioned
22:02:18 <ivanm> (simplistically speaking)
22:03:02 <ivanm> Axman6: btw, define:DML and define:DDL in google helps :p
22:03:10 <Axman6> heh
22:13:56 <joe6> pastorn: are you around?
22:14:03 <ivanm> preflex: seen pastorn 
22:14:03 <preflex>  pastorn was last seen on #haskell 6 hours, 3 minutes and 27 seconds ago, saying: each line i grab begins with '\r', but i have set the NewlineMode to CRLF CRLF
22:14:13 <pastorn> parcs: hiya
22:14:16 <pastorn> joe6: 
22:14:18 <pastorn> i mean
22:14:23 <pastorn> parcs: sorry :'(
22:15:08 <joe6> pastorn: quick question: as you know i built up the data structures and am now to the point where I am comparing what is 
22:15:17 <joe6> received from the simulator with what is expected.
22:15:39 <joe6> in my previous attempt, I used the pretty print library to print out the differences.
22:16:04 <joe6> i know of Data.Algorithm.Diff which does a pretty good job of comparing structures.
22:16:33 <joe6> I am wondering what your thoughts might be on how to compare and print the differences between the expected vs actual
22:17:17 <pastorn> joe6: ehm... this is sort of difficult
22:17:24 <pastorn> so you have your parsed structures, right?
22:17:27 <pastorn> your giant records
22:17:30 <joe6> yes
22:17:38 <joe6> yes, they are the giant records.
22:17:45 <pastorn> and you want to run (==) on all comparable fields in the 'expected' and 'recieved' structures
22:18:03 <pastorn> this sounds like a job for "scrap your boilerplate"
22:18:43 <pastorn> but i don't know very much at all about this, but SYB allows you do run some function recursively through arbitrary structures (as long as you provide some weird typeclass, i think)
22:19:00 <pastorn> you'll have to read up on it... i think it might be what you need, but i'm not very certain
22:19:01 <joe6> pastorn: this is what it looks like now. http://codepad.org/cpOHYYi5
22:21:48 <joe6> pastorn: as you can notice, the getDiff of the Diff package can tell that these 2 records are different. but, then I would have to manually check each field.
22:23:11 <joe6> pastorn: this is the output of the program that I had previously: http://codepad.org/zCHBWC55
22:23:49 <joe6> pastorn: i got the output by using a lot of pretty print 
22:24:01 <pastorn> joe6: well, as i said, i think SYB might be helpful here
22:24:15 <joe6> pastorn: ok, then I will check out SYB.
22:24:26 <pastorn> well, for just strings it's not that hard to find differences
22:24:39 <pastorn> you can do zipWith + filter to find out what differs quite easily
22:24:45 <joe6> should I just google of "SYB haskell" or is there a better term to search for it.
22:25:30 <joe6> pastorn: yes, the differences are easy, but showing the exact differences or the fields that differ.
22:25:38 <joe6> might get a bit icky.
22:25:51 <wagle> anyone know anything about this:
22:26:08 <wagle> gitit: Could not find module `Data.Digest.Pure.SHA':
22:27:00 <pastorn> joe6: as i said, read a bit about SYB, it might be what you want, but you should ask somone else, i've never used it (only had it described to me)
22:27:20 <ivanm> wagle: install the sha library from hackage
22:27:51 <wagle> ivanm: it somehow got uninstalled
22:28:07 <ivanm> since cabal-install can't uninstall, that isn't likely...
22:28:14 <ivanm> it could have been broken though
22:28:31 <wagle> gitit worked until i rebooted
22:28:53 <joe6> pastorn: ok, thanks.
22:28:58 <wagle> but ok, will frob cabal
22:29:18 <pastorn> joe6: there are other anti-boilerplate libraries, i don't remember their names now
22:29:25 <pastorn> joe6: you should check the haskell wiki
22:29:36 <pastorn> (haskell.org, that is
22:30:01 <ivanm> preflex: seen lambdabot
22:30:01 <preflex>  lambdabot was last seen on #haskell 1 hour, 26 minutes and 13 seconds ago, saying: ?? -> ? -> *
22:31:16 <Axman6> hmm, i wish there were a nice way to put types inside data structures. could make working with databases much nicer (well, database definitions anyway)
22:33:37 <ivanm> this netsplit seems to be lasting longer than usual :s
22:40:40 <joe6> pastorn: that was a good suggestion. It appears that I should use SYB or the Data.Generics aka uniplate. This is the smart way of doing the job.
22:40:48 <joe6> pastorn: thanks for the guidance.
22:41:46 <joe6> pastorn: i never thought that something like that was possible. very interesting concept to learn.
22:42:17 <wagle> time package fails with "Exitfailure 11"..  what do I do to fix or workaround?
22:44:08 <pastorn> joe6: i've heard complaints about SYB being slow, maybe that's changed now (i have no clue)... though i dont' think performance for your diffing might be a real issue
22:56:32 <BMeph> @hoogle something
23:34:11 <wagle> is there a way to uninstall cabal and the haskell platfrom and start over?  its hosed
23:43:33 <pastorn> wagle: rm -rf ~/.ghc ~/.cabal
23:43:47 <pastorn> and then do a 'which ghc' to find where it's located
23:44:46 <wagle> where is the --global location for ~/.ghc?
23:45:20 <pastorn> i have /usr/local/bin/ for the binaries and /usr/local/lib/ghci-*version*/
23:45:26 <pastorn> for the libraries
23:45:27 <lars9> @src dropWhile
23:45:37 <lars9> @src dropWhile
23:45:39 <pastorn> lars9: she's gone underground
23:45:49 <lars9> lambdabot down?
23:48:24 <lars9> is there an inifite integer trie?
23:48:55 <pastorn> lars9: hackage ;
23:48:58 <pastorn> :p
23:49:03 <pastorn> lars9: i think hayoo still works
23:49:30 <lars9> @hayoo map
23:50:46 <wagle> my problem is that my entire haskell environment is hosed because I rebooted after a failed cabal upgrade..  i need to get work down NOW, and i cant
23:51:01 <pastorn> lars9: lambdabot is STILL down
23:51:27 <wagle> i uninstalled ghc apparently, but not haskell-platform
23:52:31 <wagle> i'm deleting /usr/local entirely, and trying to rebuild it, but it was hiding info (installed package lists, etc) outside of there
23:52:38 <wagle> and not in my home dir
23:53:38 <Veinor> not in ~/.ghc ?
23:57:55 <raichoo> good morning
23:58:48 <wagle> ~/.ghc wasnt there
23:59:37 * Veinor shrugs
